PC     Output      Line
040000             0001  ; ========================================
040000             0002  ; FROM mos_api.inc
040000             0003  ; ----------------------------------------
040000             0004  
040000             0005  ;
040000             0006  ; Title:	AGON MOS - API for user projects
040000             0007  ; Author:	Dean Belfield
040000             0008  ; Created:	03/08/2022
040000             0009  ; Last Updated:	11/11/2023
040000             0010  ;
040000             0011  ; Modinfo:
040000             0012  ; 05/08/2022:	Added mos_feof
040000             0013  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0014  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0015  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0016  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0017  ; 13/10/2022:	Added mos_oscli
040000             0018  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0019  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0020  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0021  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0022  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0023  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0024  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0025  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0026  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0027  ; 19/05/2023:	Added sysvar_scrMode
040000             0028  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0029  ; 03/08/2023:	Added mos_setkbvector
040000             0030  ; 10/08/2023:	Added mos_getkbmap
040000             0031  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0032  ; 09/04/2024:   Adapter to ez80asm
040000             0033  ; VDP control (VDU 23, 0, n)
040000             0034  ;
040000             0035  vdp_gp:			EQU 	80h
040000             0036  vdp_keycode:		EQU 	81h
040000             0037  vdp_cursor:		EQU	82h
040000             0038  vdp_scrchar:		EQU	83h
040000             0039  vdp_scrpixel:		EQU	84h
040000             0040  vdp_audio:		EQU	85h
040000             0041  vdp_mode:		EQU	86h
040000             0042  vdp_rtc:		EQU	87h
040000             0043  vdp_keystate:		EQU	88h
040000             0044  vdp_logicalcoords:	EQU	C0h
040000             0045  vdp_terminalmode:	EQU	FFh
040000             0046  
040000             0047  ; MOS high level functions
040000             0048  ;
040000             0049  mos_getkey:		EQU	00h
040000             0050  mos_load:		EQU	01h
040000             0051  mos_save:		EQU	02h
040000             0052  mos_cd:			EQU	03h
040000             0053  mos_dir:		EQU	04h
040000             0054  mos_del:		EQU	05h
040000             0055  mos_ren:		EQU	06h
040000             0056  mos_mkdir:		EQU	07h
040000             0057  mos_sysvars:		EQU	08h
040000             0058  mos_editline:		EQU	09h
040000             0059  mos_fopen:		EQU	0Ah
040000             0060  mos_fclose:		EQU	0Bh
040000             0061  mos_fgetc:		EQU	0Ch
040000             0062  mos_fputc:		EQU	0Dh
040000             0063  mos_feof:		EQU	0Eh
040000             0064  mos_getError:		EQU	0Fh
040000             0065  mos_oscli:		EQU	10h
040000             0066  mos_copy:		EQU	11h
040000             0067  mos_getrtc:		EQU	12h
040000             0068  mos_setrtc:		EQU	13h
040000             0069  mos_setintvector:	EQU	14h
040000             0070  mos_uopen:		EQU	15h
040000             0071  mos_uclose:		EQU	16h
040000             0072  mos_ugetc:		EQU	17h
040000             0073  mos_uputc:		EQU 	18h
040000             0074  mos_getfil:		EQU	19h
040000             0075  mos_fread:		EQU	1Ah
040000             0076  mos_fwrite:		EQU	1Bh
040000             0077  mos_flseek:		EQU	1Ch
040000             0078  mos_setkbvector:	EQU	1Dh
040000             0079  mos_getkbmap:		EQU	1Eh
040000             0080  mos_i2c_open:		EQU	1Fh
040000             0081  mos_i2c_close:		EQU	20h
040000             0082  mos_i2c_write:		EQU	21h
040000             0083  mos_i2c_read:		EQU	22h
040000             0084  
040000             0085  
040000             0086  ; FatFS file access functions
040000             0087  ;
040000             0088  ffs_fopen:		EQU	80h
040000             0089  ffs_fclose:		EQU	81h
040000             0090  ffs_fread:		EQU	82h
040000             0091  ffs_fwrite:		EQU	83h
040000             0092  ffs_flseek:		EQU	84h
040000             0093  ffs_ftruncate:		EQU	85h
040000             0094  ffs_fsync:		EQU	86h
040000             0095  ffs_fforward:		EQU	87h
040000             0096  ffs_fexpand:		EQU	88h
040000             0097  ffs_fgets:		EQU	89h
040000             0098  ffs_fputc:		EQU	8Ah
040000             0099  ffs_fputs:		EQU	8Bh
040000             0100  ffs_fprintf:		EQU	8Ch
040000             0101  ffs_ftell:		EQU	8Dh
040000             0102  ffs_feof:		EQU	8Eh
040000             0103  ffs_fsize:		EQU	8Fh
040000             0104  ffs_ferror:		EQU	90h
040000             0105  
040000             0106  ; FatFS directory access functions
040000             0107  ;
040000             0108  ffs_dopen:		EQU	91h
040000             0109  ffs_dclose:		EQU	92h
040000             0110  ffs_dread:		EQU	93h
040000             0111  ffs_dfindfirst:		EQU	94h
040000             0112  ffs_dfindnext:		EQU	95h
040000             0113  
040000             0114  ; FatFS file and directory management functions
040000             0115  ;
040000             0116  ffs_stat:		EQU	96h
040000             0117  ffs_unlink:		EQU	97h
040000             0118  ffs_rename:		EQU	98h
040000             0119  ffs_chmod:		EQU	99h
040000             0120  ffs_utime:		EQU	9Ah
040000             0121  ffs_mkdir:		EQU	9Bh
040000             0122  ffs_chdir:		EQU	9Ch
040000             0123  ffs_chdrive:		EQU	9Dh
040000             0124  ffs_getcwd:		EQU	9Eh
040000             0125  
040000             0126  ; FatFS volume management and system configuration functions
040000             0127  ;
040000             0128  ffs_mount:		EQU	9Fh
040000             0129  ffs_mkfs:		EQU	A0h
040000             0130  ffs_fdisk:		EQU	A1h
040000             0131  ffs_getfree:		EQU	A2h
040000             0132  ffs_getlabel:		EQU	A3h
040000             0133  ffs_setlabel:		EQU	A4h
040000             0134  ffs_setcp:		EQU	A5h
040000             0135  
040000             0136  ; File access modes
040000             0137  ;
040000             0138  fa_read:		EQU	01h
040000             0139  fa_write:		EQU	02h
040000             0140  fa_open_existing:	EQU	00h
040000             0141  fa_create_new:		EQU	04h
040000             0142  fa_create_always:	EQU	08h
040000             0143  fa_open_always:		EQU	10h
040000             0144  fa_open_append:		EQU	30h
040000             0145  
040000             0146  ; System variable indexes for api_sysvars
040000             0147  ; Index into _sysvars in globals.asm
040000             0148  ;
040000             0149  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0150  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0151  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0152  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0153  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0154  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0155  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0156  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0157  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0158  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0159  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0160  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0161  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0162  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0163  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0164  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0165  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0166  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0167  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0168  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0169  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0170  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0171  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0172  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0173  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0174  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0175  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0176  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0177  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0178  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0179  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0180  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0181  
040000             0182  ; Flags for the VPD protocol
040000             0183  ;
040000             0184  vdp_pflag_cursor:	EQU	00000001b
040000             0185  vdp_pflag_scrchar:	EQU	00000010b
040000             0186  vdp_pflag_point:	EQU	00000100b
040000             0187  vdp_pflag_audio:	EQU	00001000b
040000             0188  vdp_pflag_mode:		EQU	00010000b
040000             0189  vdp_pflag_rtc:		EQU	00100000b
040000             0190  vdp_pflag_mouse:	EQU	01000000b
040000             0191  ; vdp_pflag_buffered:	EQU	10000000b
040000             0192  
040000             0193  ;
040000             0194  ; FatFS structures
040000             0195  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0196  ;
040000             0197  ; Object ID and allocation information (FFOBJID)
040000             0198  ;
040000             0199  ;FFOBJID	.STRUCT
040000             0200  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0201  ;	id:		DS	2	; Hosting volume mount ID
040000             0202  ;	attr:		DS	1	; Object attribute;
040000             0203  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0204  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0205  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0206  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0207  ;
040000             0208  ; File object structure (FIL)
040000             0209  ;
040000             0210  ; FIL .STRUCT
040000             0211  ; 	obj:		.TAG	FFOBJID	; Object identifier
040000             0212  ; 	flag:		DS	1	; File status flags
040000             0213  ; 	err:		DS	1	; Abort flag (error code)
040000             0214  ; 	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0215  ; 	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0216  ; 	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0217  ; 	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0218  ; 	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0219  ; FIL_SIZE .ENDSTRUCT FIL
040000             0220  ;
040000             0221  ; Directory object structure (DIR)
040000             0222  ;
040000             0223  ;DIR .STRUCT
040000             0224  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0225  ;	dptr:		DS	4	; Current read/write offset
040000             0226  ;	clust:		DS	4	; Current cluster
040000             0227  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0228  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0229  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0230  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0231  ;DIR_SIZE .ENDSTRUCT DIR
040000             0232  ;
040000             0233  ; File information structure (FILINFO)
040000             0234  ;
040000             0235  ;FILINFO .STRUCT
040000             0236  ;	fsize:		DS 	4	; File size
040000             0237  ;	fdate:		DS	2	; Modified date;
040000             0238  ;	ftime:		DS	2	; Modified time
040000             0239  ;	fattrib:	DS	1	; File attribute
040000             0240  ;	altname:	DS	13	; Alternative file name
040000             0241  ;	fname:		DS	256	; Primary file name
040000             0242  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0243  
040000             0244  ;
040000             0245  ; Macro for calling the API
040000             0246  ; Parameters:
040000             0247  ; - function: One of the function numbers listed above
040000             0248  ;
040000             0249  			MACRO	MOSCALL function
040000             0250  			LD	A, function
040000             0251  			RST.L	08h
040000             0252  			ENDMACRO
040000             0253  
040000             0254  ; ========================================
040000             0255  ; FROM macros.inc
040000             0256  ; ----------------------------------------
040000             0257  
040000             0258  			; Title:	BBC Basic Interpreter - Z80 version
040000             0259  			;		Useful macros
040000             0260  			; Author:	Dean Belfield
040000             0261  			; Created:	12/05/2023
040000             0262  			; Last Updated:	11/06/2023
040000             0263  			;
040000             0264  			; Modinfo:
040000             0265  			; 11/06/2023:	Modified to run in ADL mode
040000             0266  			; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
040000             0267  
040000             0268  			MACRO EXREG	rp1, rp2
040000             0269  			PUSH	rp1
040000             0270  			POP	rp2
040000             0271  			ENDMACRO
040000             0272  
040000             0273  			; MACRO ADD8U_DE	reg
040000             0274  			MACRO ADD8U_DE
040000             0275  			ADD	A, E
040000             0276  			LD	E, A
040000             0277  			ADC	A, D
040000             0278  			SUB	E
040000             0279  			LD	D, A
040000             0280  			ENDMACRO
040000             0281  
040000             0282  			; MACRO ADD8U_HL	reg
040000             0283  			MACRO ADD8U_HL
040000             0284  			ADD	A, L
040000             0285  			LD	L, A
040000             0286  			ADC	A, H
040000             0287  			SUB	L
040000             0288  			LD	H, A
040000             0289  			ENDMACRO
040000             0290  
040000             0291  			MACRO VDU	val
040000             0292  			LD	A, val
040000             0293  			CALL	OSWRCH
040000             0294  			ENDMACRO
040000             0295  
040000             0296  			MACRO SET_GPIO	reg, val
040000             0297  			IN0	A, (reg)
040000             0298  			OR	val
040000             0299  			OUT0	(reg), A
040000             0300  			ENDMACRO
040000             0301  
040000             0302  			MACRO RES_GPIO	reg, val
040000             0303  			PUSH	BC
040000             0304  			LD	A, val
040000             0305  			CPL
040000             0306  			LD	C, A
040000             0307  			IN0	A, (reg)
040000             0308  			AND	C
040000             0309  			OUT0	(reg), A
040000             0310  			POP	BC
040000             0311  			ENDMACRO
040000             0312  
040000             0313  ; ========================================
040000             0314  ; FROM ram.asm
040000             0315  ; ----------------------------------------
040000             0316  
040000             0317  ;
040000             0318  ; Title:	BBC Basic Interpreter - Z80 version
040000             0319  ;		RAM Module for BBC Basic Interpreter
040000             0320  ;		For use with Version 2.0 of BBC BASIC
040000             0321  ;		Standard CP/M Distribution Version
040000             0322  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
040000             0323  ; Modified By:	Dean Belfield
040000             0324  ; Created:	12/05/2023
040000             0325  ; Last Updated:	26/06/2023
040000             0326  ;
040000             0327  ; Modinfo:
040000             0328  ; 06/06/2023:	Modified to run in ADL mode
040000             0329  ; 26/06/2023:	Added temporary stores R0 and R1
040000             0330  
040000             0331  			; .ASSUME	ADL = 1
040000             0332  
040000             0333  			; DEFINE	LORAM, SPACE = ROM
040000             0334  			; SEGMENT LORAM
040000             0335  
040000             0336  ; 			XDEF	ACCS
040000             0337  ; 			XDEF	BUFFER
040000             0338  ; 			XDEF	STAVAR
040000             0339  ; 			XDEF	DYNVAR
040000             0340  ; 			XDEF	FNPTR
040000             0341  ; 			XDEF	PROPTR
040000             0342  ; 			XDEF	PAGE_
040000             0343  ; 			XDEF	TOP
040000             0344  ; 			XDEF	LOMEM
040000             0345  ; 			XDEF 	FREE
040000             0346  ; 			XDEF	HIMEM
040000             0347  ; 			XDEF	LINENO
040000             0348  ; 			XDEF	TRACEN
040000             0349  ; 			XDEF	AUTONO
040000             0350  ; 			XDEF	ERRTRP
040000             0351  ; 			XDEF	ERRTXT
040000             0352  ; 			XDEF	DATPTR
040000             0353  ; 			XDEF	ERL
040000             0354  ; 			XDEF	ERRLIN
040000             0355  ; 			XDEF	RANDOM
040000             0356  ; 			XDEF	COUNT
040000             0357  ; 			XDEF	WIDTH
040000             0358  ; 			XDEF	ERR
040000             0359  ; 			XDEF	LISTON
040000             0360  ; 			XDEF	INCREM
040000             0361  
040000             0362  ; 			XDEF	FLAGS
040000             0363  ; 			XDEF	OSWRCHPT
040000             0364  ; 			XDEF	OSWRCHCH
040000             0365  ; 			XDEF	OSWRCHFH
040000             0366  ; 			XDEF	KEYDOWN
040000             0367  ; 			XDEF	KEYASCII
040000             0368  ; 			XDEF	KEYCOUNT
040000             0369  
040000             0370  ; 			XDEF	R0
040000             0371  ; 			XDEF	R1
040000             0372  
040000             0373  ; 			XDEF	RAM_START
040000             0374  ; 			XDEF	RAM_END
040000             0375  ; 			XDEF	USER
040000             0376  
040000             0377  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
040000             0378  RAM_START:
040000             0379  ;
040000             0380  ACCS:			DS		256             ; String Accumulator
040100             0381  BUFFER:			DS		256             ; String Input Buffer
040200             0382  STAVAR:			DS	 	27*4            ; Static Variables
04026C             0383  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
04030E             0384  FNPTR:  		DS    		3               ; Dynamic Function Pointers
040311             0385  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
040314             0386  ;
040314             0387  PAGE_:   		DS		3               ; Start of User Program
040317             0388  TOP:    		DS		3               ; First Location after User Program
04031A             0389  LOMEM:  		DS		3               ; Start of Dynamic Storage
04031D             0390  FREE:   		DS		3               ; First Free Space Byte
040320             0391  HIMEM:  		DS		3               ; First Protected Byte
040323             0392  ;
040323             0393  LINENO: 		DS		3               ; Line Number
040326             0394  TRACEN:			DS		3               ; Trace Flag
040329             0395  AUTONO:			DS		3               ; Auto Flag
04032C             0396  ERRTRP:			DS		3               ; Error Trap
04032F             0397  ERRTXT:			DS		2               ; Error Message Pointer
040331             0398  DATPTR:			DS		2               ; Data Pointer
040333             0399  ERL:			DS		2               ; Error Line
040335             0400  ERRLIN:			DS		3               ; The "ON ERROR" Line
040338             0401  RANDOM:			DS		5               ; Random Number
04033D             0402  COUNT:			DS		1               ; Print Position
04033E             0403  WIDTH:			DS		1               ; Print Width
04033F             0404  ERR:			DS		1               ; Error Number
040340             0405  LISTON:			DS		1               ; LISTO (bottom nibble)
040341             0406  							; - BIT 0: If set, output a space after the line number
040341             0407  							; - BIT 1: If set, then indent FOR/NEXT loops
040341             0408  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
040341             0409  							; - BIT 3: If set, then output to buffer for *EDIT
040341             0410  							; OPT FLAG (top nibble)
040341             0411  							; - BIT 4: If set, then list whilst assembling
040341             0412  							; - BIT 5: If set, then assembler errors are reported
040341             0413  							; - BIT 6: If set, then place the code starting at address pointed to by O%
040341             0414  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
040341             0415  INCREM:			DS		1               ; Auto-Increment Value
040342             0416  ;
040342             0417  ; Extra Agon-implementation specific system variables
040342             0418  ;
040342             0419  FLAGS:			DS		1		; Miscellaneous flags
040343             0420  							; - BIT 7: Set if ESC pressed
040343             0421  							; - BIT 6: Set to disable ESC
040343             0422  OSWRCHPT:		DS		2		; Pointer for *EDIT
040345             0423  OSWRCHCH:		DS		1		; Channel of OSWRCH
040346             0424  							; - 0: Console
040346             0425  							; - 1: File
040346             0426  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
040347             0427  KEYDOWN:		DS		1		; Keydown flag
040348             0428  KEYASCII:		DS		1		; ASCII code of pressed key
040349             0429  KEYCOUNT:		DS		1		; Counts every time a key is pressed
04034A             0430  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
04034D             0431  R1:			DS		3		;
040350             0432  ;
040350             0433  ; This must be at the end
040350             0434  ;
040350             0435  RAM_END:
040350 FF FF FF FF 0436  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040400             0437  USER:							; Must be aligned on a page boundary
040400             0438  
040400             0439  ; ========================================
040400             0440  ; FROM equs.inc
040400             0441  ; ----------------------------------------
040400             0442  
040400             0443  ;
040400             0444  ; Title:	BBC Basic for AGON - Equs
040400             0445  ; Author:	Dean Belfield
040400             0446  ; Created:	12/05/2023
040400             0447  ; Last Updated:	08/06/2023
040400             0448  ;
040400             0449  ; Modinfo:
040400             0450  ; 08/06/2023:	Added SIZEW
040400             0451  
040400             0452  ; 			XREF		STAVAR
040400             0453  ; 			XREF		ACCS
040400             0454  
040400             0455  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
040400             0456  ;Stack_Top:		EQU		0000h	; Stack at top
040400             0457  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
040400             0458  
040400             0459  ; For GPIO
040400             0460  ; PA not available on eZ80L92
040400             0461  ;
040400             0462  PA_DR:			EQU		96h
040400             0463  PA_DDR:			EQU		97h
040400             0464  PA_ALT1:		EQU		98h
040400             0465  PA_ALT2:		EQU		99h
040400             0466  PB_DR:          	EQU		9Ah
040400             0467  PB_DDR:        	 	EQU		9Bh
040400             0468  PB_ALT1:        	EQU		9Ch
040400             0469  PB_ALT2:        	EQU		9Dh
040400             0470  PC_DR:          	EQU		9Eh
040400             0471  PC_DDR:         	EQU		9Fh
040400             0472  PC_ALT1:        	EQU		A0h
040400             0473  PC_ALT2:        	EQU		A1h
040400             0474  PD_DR:          	EQU		A2h
040400             0475  PD_DDR:			EQU		A3h
040400             0476  PD_ALT1:		EQU		A4h
040400             0477  PD_ALT2:		EQU		A5h
040400             0478  
040400             0479  GPIOMODE_OUT:		EQU		0	; Output
040400             0480  GPIOMODE_IN:		EQU		1	; Input
040400             0481  GPIOMODE_DIO:		EQU		2	; Open Drain IO
040400             0482  GPIOMODE_SIO:		EQU		3	; Open Source IO
040400             0483  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
040400             0484  GPIOMODE_ALTF:		EQU		5;	; Alt Function
040400             0485  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
040400             0486  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
040400             0487  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
040400             0488  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
040400             0489  
040400             0490  ; Originally in ram.asm
040400             0491  ;
040400             0492  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
040400             0493  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
040400             0494  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
040400             0495  
040400             0496  ; Originally in main.asm
040400             0497  ;
040400             0498  CR:			EQU     0DH
040400             0499  LF:			EQU     0AH
040400             0500  ESC:			EQU     1BH
040400             0501  
040400             0502  ; ========================================
040400             0503  ; FROM init.asm
040400             0504  ; ----------------------------------------
040400             0505  
040400             0506  ;
040400             0507  ; Title:	BBC Basic ADL for AGON - Initialisation Code
040400             0508  ;		Initialisation Code
040400             0509  ; Author:	Dean Belfield
040400             0510  ; Created:	12/05/2023
040400             0511  ; Last Updated:	26/11/2023
040400             0512  ;
040400             0513  ; Modinfo:
040400             0514  ; 11/07/2023:	Fixed *BYE for ADL mode
040400             0515  ; 26/11/2023:	Moved the ram clear routine into here
040400             0516  
040400             0517  			; SEGMENT CODE
040400             0518  
040400             0519  ; 			XDEF	_end
040400             0520  
040400             0521  ; 			XREF	_main				; In main.asm
040400             0522  
040400             0523  ; 			XREF	RAM_START			; In ram.asm
040400             0524  ; 			XREF	RAM_END
040400             0525  
040400             0526  			; .ASSUME	ADL = 1
040400             0527  
040400             0528  			; INCLUDE	"equs.inc"
040400             0529  
040400             0530  argv_ptrs_max:		EQU	16				; Maximum number of arguments allowed in argv
040400             0531  
040400             0532  ;
040400             0533  ; Start in ADL mode
040400             0534  ;
040400 C3 45 04 04 0535  			JP	_start				; Jump to start
040404             0536  ;
040404             0537  ; The header stuff is from byte 64 onwards
040404             0538  ;
040404 42 42 43 42 0539  _exec_name:		DB	"BBCBASIC.BIN", 0		; The executable name, only used in argv
       41 53 49 43 
       2E 42 49 4E 
       00          
040411             0540  
040411 FF FF FF FF 0541  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
040440             0542  
040440 4D 4F 53    0543  			DB	"MOS"				; Flag for MOS - to confirm this is a valid MOS command
040443 00          0544  			DB	00h				; MOS header version 0
040444 01          0545  			DB	01h				; Flag for run mode (0: Z80, 1: ADL)
040445             0546  ;
040445             0547  ; And the code follows on immediately after the header
040445             0548  ;
040445 F5          0549  _start:			PUSH		AF			; Preserve the rest of the registers
040446 C5          0550  			PUSH		BC
040447 D5          0551  			PUSH		DE
040448 DD E5       0552  			PUSH		IX
04044A FD E5       0553  			PUSH		IY
04044C             0554  
04044C ED 73 D7 04 0555  			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       04          
040451             0556  
040451 DD 21 DA 04 0557  			LD		IX, _argv_ptrs		; The argv array pointer address
       04          
040456 DD E5       0558  			PUSH		IX
040458 CD 88 04 04 0559  			CALL		_parse_params		; Parse the parameters
04045C DD E1       0560  			POP		IX			; IX: argv
04045E 06 00       0561  			LD		B, 0			;  C: argc
040460 CD 75 04 04 0562  			CALL		_clear_ram
040464 C3 7B 3B 04 0563  			JP		_main			; Start user code
040468             0564  ;
040468             0565  ; This bit of code is called from STAR_BYE and returns us safely to MOS
040468             0566  ;
040468 ED 7B D7 04 0567  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
04046D             0568  
04046D FD E1       0569  			POP		IY			; Restore the registers
04046F DD E1       0570  			POP		IX
040471 D1          0571  			POP		DE
040472 C1          0572  			POP		BC
040473 F1          0573  			POP		AF
040474 C9          0574  			RET					; Return to MOS
040475             0575  
040475             0576  ;Clear the application memory
040475             0577  ;
040475 C5          0578  _clear_ram:		PUSH		BC
040476 21 00 00 04 0579  			LD		HL, RAM_START
04047A 11 01 00 04 0580  			LD		DE, RAM_START + 1
04047E 01 4F 03 00 0581  			LD		BC, RAM_END - RAM_START - 1
040482 AF          0582  			XOR		A
040483 77          0583  			LD		(HL), A
040484 ED B0       0584  			LDIR
040486 C1          0585  			POP		BC
040487 C9          0586  			RET
040488             0587  
040488             0588  ; Parse the parameter string into a C array
040488             0589  ; Parameters
040488             0590  ; - HL: Address of parameter string
040488             0591  ; - IX: Address for array pointer storage
040488             0592  ; Returns:
040488             0593  ; -  C: Number of parameters parsed
040488             0594  ;
040488 01 04 04 04 0595  _parse_params:		LD	BC, _exec_name
04048C DD 0F 00    0596  			LD	(IX+0), BC		; ARGV[0] = the executable name
04048F DD 23       0597  			INC	IX
040491 DD 23       0598  			INC	IX
040493 DD 23       0599  			INC	IX
040495 CD D0 04 04 0600  			CALL	_skip_spaces		; Skip HL past any leading spaces
040499             0601  ;
040499 01 01 00 00 0602  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
04049D 06 0F       0603  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
04049F             0604  ;
04049F             0605  _parse_params_1:
04049F C5          0606  			PUSH	BC			; Stack ARGC
0404A0 E5          0607  			PUSH	HL			; Stack start address of token
0404A1 CD C1 04 04 0608  			CALL	_get_token		; Get the next token
0404A5 79          0609  			LD	A, C			; A: Length of the token in characters
0404A6 D1          0610  			POP	DE			; Start address of token (was in HL)
0404A7 C1          0611  			POP	BC			; ARGC
0404A8 B7          0612  			OR	A			; Check for A=0 (no token found) OR at end of string
0404A9 C8          0613  			RET	Z
0404AA             0614  ;
0404AA DD 1F 00    0615  			LD	(IX+0), DE		; Store the pointer to the token
0404AD E5          0616  			PUSH	HL			; DE=HL
0404AE D1          0617  			POP	DE
0404AF CD D0 04 04 0618  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0404B3 AF          0619  			XOR	A
0404B4 12          0620  			LD	(DE), A			; Zero-terminate the token
0404B5 DD 23       0621  			INC	IX
0404B7 DD 23       0622  			INC	IX
0404B9 DD 23       0623  			INC	IX			; Advance to next pointer position
0404BB 0C          0624  			INC	C			; Increment ARGC
0404BC 79          0625  			LD	A, C			; Check for C >= A
0404BD B8          0626  			CP	B
0404BE 38 DF       0627  			JR	C, _parse_params_1	; And loop
0404C0 C9          0628  			RET
0404C1             0629  
0404C1             0630  ; Get the next token
0404C1             0631  ; Parameters:
0404C1             0632  ; - HL: Address of parameter string
0404C1             0633  ; Returns:
0404C1             0634  ; - HL: Address of first character after token
0404C1             0635  ; -  C: Length of token (in characters)
0404C1             0636  ;
0404C1 0E 00       0637  _get_token:		LD	C, 0			; Initialise length
0404C3 7E          0638  @@:			LD	A, (HL)			; Get the character from the parameter string
0404C4 B7          0639  			OR	A			; Exit if 0 (end of parameter string in MOS)
0404C5 C8          0640  			RET 	Z
0404C6 FE 0D       0641  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0404C8 C8          0642  			RET	Z
0404C9 FE 20       0643  			CP	' '			; Exit if space (end of token)
0404CB C8          0644  			RET	Z
0404CC 23          0645  			INC	HL			; Advance to next character
0404CD 0C          0646  			INC 	C			; Increment length
0404CE 18 F3       0647  			JR	@B
0404D0             0648  
0404D0             0649  ; Skip spaces in the parameter string
0404D0             0650  ; Parameters:
0404D0             0651  ; - HL: Address of parameter string
0404D0             0652  ; Returns:
0404D0             0653  ; - HL: Address of next none-space character
0404D0             0654  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0404D0             0655  ;
0404D0 7E          0656  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0404D1 FE 20       0657  			CP	' '			; Exit if not space
0404D3 C0          0658  			RET	NZ
0404D4 23          0659  			INC	HL			; Advance to next character
0404D5 18 F9       0660  			JR	_skip_spaces		; Increment length
0404D7             0661  
0404D7             0662  ; Storage
0404D7             0663  ;
0404D7             0664  _sps:			DS	3			; Storage for the stack pointer
0404DA 00 00 00 00 0665  _argv_ptrs:		BLKP	argv_ptrs_max, 0	; Storage for the argv array pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04050A             0666  
04050A             0667  ; ========================================
04050A             0668  ; FROM agon_graphics.asm
04050A             0669  ; ----------------------------------------
04050A             0670  
04050A             0671  ;
04050A             0672  ; Title:	BBC Basic for AGON - Graphics stuff
04050A             0673  ; Author:	Dean Belfield
04050A             0674  ; Created:	12/05/2023
04050A             0675  ; Last Updated:	07/06/2023
04050A             0676  ;
04050A             0677  ; Modinfo:
04050A             0678  ; 07/06/2023:	Modified to run in ADL mode
04050A             0679  
04050A             0680  			; .ASSUME	ADL = 1
04050A             0681  
04050A             0682  			; INCLUDE	"equs.inc"
04050A             0683  			; INCLUDE "macros.inc"
04050A             0684  			; INCLUDE "mos_api.inc"	; In MOS/src
04050A             0685  
04050A             0686  			; SEGMENT CODE
04050A             0687  
04050A             0688  ; 			XDEF	CLG
04050A             0689  ; 			XDEF	CLRSCN
04050A             0690  ; 			XDEF	MODE
04050A             0691  ; 			XDEF	COLOUR
04050A             0692  ; 			XDEF	GCOL
04050A             0693  ; 			XDEF	MOVE
04050A             0694  ; 			XDEF	PLOT
04050A             0695  ; 			XDEF	DRAW
04050A             0696  ; 			XDEF	POINT
04050A             0697  ; 			XDEF	GETSCHR
04050A             0698  
04050A             0699  ; 			XREF	OSWRCH
04050A             0700  ; 			XREF	ASC_TO_NUMBER
04050A             0701  ; 			XREF	EXTERR
04050A             0702  ; 			XREF	EXPRI
04050A             0703  ; 			XREF	COMMA
04050A             0704  ; 			XREF	XEQ
04050A             0705  ; 			XREF	NXT
04050A             0706  ; 			XREF	BRAKET
04050A             0707  ; 			XREF	COUNT0
04050A             0708  ; 			XREF	CRTONULL
04050A             0709  ; 			XREF	NULLTOCR
04050A             0710  ; 			XREF	CRLF
04050A             0711  ; 			XREF	EXPR_W2
04050A             0712  ; 			XREF	INKEY1
04050A             0713  
04050A             0714  ; CLG: clears the graphics area
04050A             0715  ;
04050A             0716  CLG:			VDU	10h
04050A 3E 10       0001M 			LD	A, val
04050C CD D0 36 04 0002M 			CALL	OSWRCH
040510 C3 B6 14 04 0717  			JP	XEQ
040514             0718  
040514             0719  ; CLS: clears the text area
040514             0720  ;
040514 3E 0C       0721  CLRSCN:			LD	A, 0Ch
040516 C3 D0 36 04 0722  			JP	OSWRCH
04051A             0723  
04051A             0724  ; MODE n: Set video mode
04051A             0725  ;
04051A DD E5       0726  MODE:			PUSH	IX			; Get the system vars in IX
04051C             0727  			MOSCALL	mos_sysvars		; Reset the semaphore
04051C 3E 08       0001M 			LD	A, function
04051E 5B CF       0002M 			RST.L	08h
040520 DD CB 04 A6 0728  			RES	4, (IX+sysvar_vpd_pflags)
040524 CD 27 0C 04 0729  			CALL    EXPRI
040528 D9          0730  			EXX
040529             0731  			VDU	16H			; Mode change
040529 3E 16       0001M 			LD	A, val
04052B CD D0 36 04 0002M 			CALL	OSWRCH
04052F             0732  			VDU	L
04052F 7D          0001M 			LD	A, val
040530 CD D0 36 04 0002M 			CALL	OSWRCH
040534             0733  			MOSCALL	mos_sysvars
040534 3E 08       0001M 			LD	A, function
040536 5B CF       0002M 			RST.L	08h
040538 DD CB 04 66 0734  @@:			BIT	4, (IX+sysvar_vpd_pflags)
04053C 28 FA       0735  			JR	Z, @B			; Wait for the result
04053E DD E1       0736  			POP	IX
040540 C3 B6 14 04 0737  			JP	XEQ
040544             0738  
040544             0739  ; GET(x,y): Get the ASCII code of a character on screen
040544             0740  ;
040544 FD 23       0741  GETSCHR:		INC	IY
040546 CD 27 0C 04 0742  			CALL    EXPRI      		; Get X coordinate
04054A D9          0743  			EXX
04054B 22 00 00 04 0744  			LD	(VDU_BUFFER+0), HL
04054F CD 42 13 04 0745  			CALL	COMMA
040553 CD 27 0C 04 0746  			CALL	EXPRI			; Get Y coordinate
040557 D9          0747  			EXX
040558 22 02 00 04 0748  			LD	(VDU_BUFFER+2), HL
04055C CD 4F 13 04 0749  			CALL	BRAKET			; Closing bracket
040560             0750  ;
040560 DD E5       0751  			PUSH	IX			; Get the system vars in IX
040562             0752  			MOSCALL	mos_sysvars		; Reset the semaphore
040562 3E 08       0001M 			LD	A, function
040564 5B CF       0002M 			RST.L	08h
040566 DD CB 04 8E 0753  			RES	1, (IX+sysvar_vpd_pflags)
04056A             0754  			VDU	23
04056A 3E 17       0001M 			LD	A, val
04056C CD D0 36 04 0002M 			CALL	OSWRCH
040570             0755  			VDU	0
040570 3E 00       0001M 			LD	A, val
040572 CD D0 36 04 0002M 			CALL	OSWRCH
040576             0756  			VDU	vdp_scrchar
040576 3E 83       0001M 			LD	A, val
040578 CD D0 36 04 0002M 			CALL	OSWRCH
04057C             0757  			VDU	(VDU_BUFFER+0)
04057C 3A 00 00 04 0001M 			LD	A, val
040580 CD D0 36 04 0002M 			CALL	OSWRCH
040584             0758  			VDU	(VDU_BUFFER+1)
040584 3A 01 00 04 0001M 			LD	A, val
040588 CD D0 36 04 0002M 			CALL	OSWRCH
04058C             0759  			VDU	(VDU_BUFFER+2)
04058C 3A 02 00 04 0001M 			LD	A, val
040590 CD D0 36 04 0002M 			CALL	OSWRCH
040594             0760  			VDU	(VDU_BUFFER+3)
040594 3A 03 00 04 0001M 			LD	A, val
040598 CD D0 36 04 0002M 			CALL	OSWRCH
04059C DD CB 04 4E 0761  @@:			BIT	1, (IX+sysvar_vpd_pflags)
0405A0 28 FA       0762  			JR	Z, @B			; Wait for the result
0405A2 DD 7E 09    0763  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0405A5 B7          0764  			OR	A			; Check for 00h
0405A6 37          0765  			SCF				; C = character map
0405A7 20 02       0766  			JR	NZ, @F			; We have a character, so skip next bit
0405A9 AF          0767  			XOR	A			; Clear carry
0405AA 3D          0768  			DEC	A			; Set A to FFh
0405AB DD E1       0769  @@:			POP	IX
0405AD C3 FE 10 04 0770  			JP	INKEY1			; Jump back to the GET command
0405B1             0771  
0405B1             0772  ; POINT(x,y): Get the pixel colour of a point on screen
0405B1             0773  ;
0405B1 CD 27 0C 04 0774  POINT:			CALL    EXPRI      		; Get X coordinate
0405B5 D9          0775  			EXX
0405B6 22 00 00 04 0776  			LD	(VDU_BUFFER+0), HL
0405BA CD 42 13 04 0777  			CALL	COMMA
0405BE CD 27 0C 04 0778  			CALL	EXPRI			; Get Y coordinate
0405C2 D9          0779  			EXX
0405C3 22 02 00 04 0780  			LD	(VDU_BUFFER+2), HL
0405C7 CD 4F 13 04 0781  			CALL	BRAKET			; Closing bracket
0405CB             0782  ;
0405CB DD E5       0783  			PUSH	IX			; Get the system vars in IX
0405CD             0784  			MOSCALL	mos_sysvars		; Reset the semaphore
0405CD 3E 08       0001M 			LD	A, function
0405CF 5B CF       0002M 			RST.L	08h
0405D1 DD CB 04 96 0785  			RES	2, (IX+sysvar_vpd_pflags)
0405D5             0786  			VDU	23
0405D5 3E 17       0001M 			LD	A, val
0405D7 CD D0 36 04 0002M 			CALL	OSWRCH
0405DB             0787  			VDU	0
0405DB 3E 00       0001M 			LD	A, val
0405DD CD D0 36 04 0002M 			CALL	OSWRCH
0405E1             0788  			VDU	vdp_scrpixel
0405E1 3E 84       0001M 			LD	A, val
0405E3 CD D0 36 04 0002M 			CALL	OSWRCH
0405E7             0789  			VDU	(VDU_BUFFER+0)
0405E7 3A 00 00 04 0001M 			LD	A, val
0405EB CD D0 36 04 0002M 			CALL	OSWRCH
0405EF             0790  			VDU	(VDU_BUFFER+1)
0405EF 3A 01 00 04 0001M 			LD	A, val
0405F3 CD D0 36 04 0002M 			CALL	OSWRCH
0405F7             0791  			VDU	(VDU_BUFFER+2)
0405F7 3A 02 00 04 0001M 			LD	A, val
0405FB CD D0 36 04 0002M 			CALL	OSWRCH
0405FF             0792  			VDU	(VDU_BUFFER+3)
0405FF 3A 03 00 04 0001M 			LD	A, val
040603 CD D0 36 04 0002M 			CALL	OSWRCH
040607 DD CB 04 56 0793  @@:			BIT	2, (IX+sysvar_vpd_pflags)
04060B 28 FA       0794  			JR	Z, @B			; Wait for the result
04060D             0795  ;
04060D             0796  ; Return the data as a 1 byte index
04060D             0797  ;
04060D             0798  			; LD	L, (IX+(sysvar_scrpixelIndex))
04060D DD 6E 0A    0799  			ld l, (IX+sysvar_scrpixel) ; changed to be compatible with ez80asm
040610 DD E1       0800  			POP	IX
040612 C3 9C 0E 04 0801  			JP	COUNT0
040616             0802  
040616             0803  
040616             0804  ; COLOUR colour
040616             0805  ; COLOUR L,P
040616             0806  ; COLOUR L,R,G,B
040616             0807  ;
040616 CD 27 0C 04 0808  COLOUR:			CALL	EXPRI			; The colour / mode
04061A D9          0809  			EXX
04061B 7D          0810  			LD	A, L
04061C 32 00 00 04 0811  			LD	(VDU_BUFFER+0), A	; Store first parameter
040620 CD 90 13 04 0812  			CALL	NXT			; Are there any more parameters?
040624 FE 2C       0813  			CP	','
040626 28 12       0814  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
040628             0815  ;
040628             0816  			VDU	11h			; Just set the colour
040628 3E 11       0001M 			LD	A, val
04062A CD D0 36 04 0002M 			CALL	OSWRCH
04062E             0817  			VDU	(VDU_BUFFER+0)
04062E 3A 00 00 04 0001M 			LD	A, val
040632 CD D0 36 04 0002M 			CALL	OSWRCH
040636 C3 B6 14 04 0818  			JP	XEQ
04063A             0819  ;
04063A CD 42 13 04 0820  COLOUR_1:		CALL	COMMA
04063E CD 27 0C 04 0821  			CALL	EXPRI			; Parse R (OR P)
040642 D9          0822  			EXX
040643 7D          0823  			LD	A, L
040644 32 01 00 04 0824  			LD	(VDU_BUFFER+1), A
040648 CD 90 13 04 0825  			CALL	NXT			; Are there any more parameters?
04064C FE 2C       0826  			CP	','
04064E 28 2C       0827  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
040650             0828  ;
040650             0829  			VDU	13h			; VDU:COLOUR
040650 3E 13       0001M 			LD	A, val
040652 CD D0 36 04 0002M 			CALL	OSWRCH
040656             0830  			VDU	(VDU_BUFFER+0)		; Logical Colour
040656 3A 00 00 04 0001M 			LD	A, val
04065A CD D0 36 04 0002M 			CALL	OSWRCH
04065E             0831  			VDU	(VDU_BUFFER+1)		; Palette Colour
04065E 3A 01 00 04 0001M 			LD	A, val
040662 CD D0 36 04 0002M 			CALL	OSWRCH
040666             0832  			VDU	0			; RGB set to 0
040666 3E 00       0001M 			LD	A, val
040668 CD D0 36 04 0002M 			CALL	OSWRCH
04066C             0833  			VDU	0
04066C 3E 00       0001M 			LD	A, val
04066E CD D0 36 04 0002M 			CALL	OSWRCH
040672             0834  			VDU	0
040672 3E 00       0001M 			LD	A, val
040674 CD D0 36 04 0002M 			CALL	OSWRCH
040678 C3 B6 14 04 0835  			JP	XEQ
04067C             0836  ;
04067C CD 42 13 04 0837  COLOUR_2:		CALL	COMMA
040680 CD 27 0C 04 0838  			CALL	EXPRI			; Parse G
040684 D9          0839  			EXX
040685 7D          0840  			LD	A, L
040686 32 02 00 04 0841  			LD	(VDU_BUFFER+2), A
04068A CD 42 13 04 0842  			CALL	COMMA
04068E CD 27 0C 04 0843  			CALL	EXPRI			; Parse B
040692 D9          0844  			EXX
040693 7D          0845  			LD	A, L
040694 32 03 00 04 0846  			LD	(VDU_BUFFER+3), A
040698             0847  			VDU	13h			; VDU:COLOUR
040698 3E 13       0001M 			LD	A, val
04069A CD D0 36 04 0002M 			CALL	OSWRCH
04069E             0848  			VDU	(VDU_BUFFER+0)		; Logical Colour
04069E 3A 00 00 04 0001M 			LD	A, val
0406A2 CD D0 36 04 0002M 			CALL	OSWRCH
0406A6             0849  			VDU	FFh			; Physical Colour (-1 for RGB mode)
0406A6 3E FF       0001M 			LD	A, val
0406A8 CD D0 36 04 0002M 			CALL	OSWRCH
0406AC             0850  			VDU	(VDU_BUFFER+1)		; R
0406AC 3A 01 00 04 0001M 			LD	A, val
0406B0 CD D0 36 04 0002M 			CALL	OSWRCH
0406B4             0851  			VDU	(VDU_BUFFER+2)		; G
0406B4 3A 02 00 04 0001M 			LD	A, val
0406B8 CD D0 36 04 0002M 			CALL	OSWRCH
0406BC             0852  			VDU	(VDU_BUFFER+3)		; B
0406BC 3A 03 00 04 0001M 			LD	A, val
0406C0 CD D0 36 04 0002M 			CALL	OSWRCH
0406C4 C3 B6 14 04 0853  			JP	XEQ
0406C8             0854  
0406C8             0855  ; GCOL mode,colour
0406C8             0856  ;
0406C8 CD 27 0C 04 0857  GCOL:			CALL	EXPRI			; Parse MODE
0406CC D9          0858  			EXX
0406CD 7D          0859  			LD	A, L
0406CE 32 00 00 04 0860  			LD	(VDU_BUFFER+0), A
0406D2 CD 42 13 04 0861  			CALL	COMMA
0406D6             0862  ;
0406D6 CD 27 0C 04 0863  			CALL	EXPRI			; Parse Colour
0406DA D9          0864  			EXX
0406DB 7D          0865  			LD	A, L
0406DC 32 01 00 04 0866  			LD	(VDU_BUFFER+1), A
0406E0             0867  ;
0406E0             0868  			VDU	12h			; VDU:GCOL
0406E0 3E 12       0001M 			LD	A, val
0406E2 CD D0 36 04 0002M 			CALL	OSWRCH
0406E6             0869  			VDU	(VDU_BUFFER+0)		; Mode
0406E6 3A 00 00 04 0001M 			LD	A, val
0406EA CD D0 36 04 0002M 			CALL	OSWRCH
0406EE             0870  			VDU	(VDU_BUFFER+1)		; Colour
0406EE 3A 01 00 04 0001M 			LD	A, val
0406F2 CD D0 36 04 0002M 			CALL	OSWRCH
0406F6 C3 B6 14 04 0871  			JP	XEQ
0406FA             0872  
0406FA             0873  ; PLOT mode,x,y
0406FA             0874  ;
0406FA CD 27 0C 04 0875  PLOT:			CALL	EXPRI		; Parse mode
0406FE D9          0876  			EXX
0406FF E5          0877  			PUSH	HL		; Push mode (L) onto stack
040700 CD 42 13 04 0878  			CALL	COMMA
040704 CD 5E 3B 04 0879  			CALL	EXPR_W2		; Parse X and Y
040708 C1          0880  			POP	BC		; Pop mode (C) off stack
040709             0881  PLOT_1:			VDU	19H		; VDU code for PLOT
040709 3E 19       0001M 			LD	A, val
04070B CD D0 36 04 0002M 			CALL	OSWRCH
04070F             0882  			VDU	C		;  C: Mode
04070F 79          0001M 			LD	A, val
040710 CD D0 36 04 0002M 			CALL	OSWRCH
040714             0883  			VDU	E		; DE: X
040714 7B          0001M 			LD	A, val
040715 CD D0 36 04 0002M 			CALL	OSWRCH
040719             0884  			VDU	D
040719 7A          0001M 			LD	A, val
04071A CD D0 36 04 0002M 			CALL	OSWRCH
04071E             0885  			VDU	L		; HL: Y
04071E 7D          0001M 			LD	A, val
04071F CD D0 36 04 0002M 			CALL	OSWRCH
040723             0886  			VDU	H
040723 7C          0001M 			LD	A, val
040724 CD D0 36 04 0002M 			CALL	OSWRCH
040728 C3 B6 14 04 0887  			JP	XEQ
04072C             0888  
04072C             0889  ; MOVE x,y
04072C             0890  ;
04072C CD 5E 3B 04 0891  MOVE:			CALL	EXPR_W2		; Parse X and Y
040730 0E 04       0892  			LD	C, 04H		; Plot mode 04H (Move)
040732 18 D5       0893  			JR	PLOT_1		; Plot
040734             0894  
040734             0895  ; DRAW x1,y1
040734             0896  ; DRAW x1,y1,x2,y2
040734             0897  ;
040734 CD 5E 3B 04 0898  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
040738 CD 90 13 04 0899  			CALL	NXT		; Are there any more parameters?
04073C FE 2C       0900  			CP	','
04073E 0E 05       0901  			LD	C, 05h		; Code for LINE
040740 20 C7       0902  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
040742             0903  			VDU	19h		; Move to the first coordinates
040742 3E 19       0001M 			LD	A, val
040744 CD D0 36 04 0002M 			CALL	OSWRCH
040748             0904  			VDU	04h
040748 3E 04       0001M 			LD	A, val
04074A CD D0 36 04 0002M 			CALL	OSWRCH
04074E             0905  			VDU	E
04074E 7B          0001M 			LD	A, val
04074F CD D0 36 04 0002M 			CALL	OSWRCH
040753             0906  			VDU	D
040753 7A          0001M 			LD	A, val
040754 CD D0 36 04 0002M 			CALL	OSWRCH
040758             0907  			VDU	L
040758 7D          0001M 			LD	A, val
040759 CD D0 36 04 0002M 			CALL	OSWRCH
04075D             0908  			VDU	H
04075D 7C          0001M 			LD	A, val
04075E CD D0 36 04 0002M 			CALL	OSWRCH
040762 CD 42 13 04 0909  			CALL	COMMA
040766 C5          0910  			PUSH	BC
040767 CD 5E 3B 04 0911  			CALL	EXPR_W2		; Get X2 and Y2
04076B C1          0912  			POP	BC
04076C 18 9B       0913  			JR	PLOT_1		; Now DRAW the line to those positions
04076E             0914  
04076E             0915  
04076E             0916  
04076E             0917  
04076E             0918  ; ========================================
04076E             0919  ; FROM agon_sound.asm
04076E             0920  ; ----------------------------------------
04076E             0921  
04076E             0922  ;
04076E             0923  ; Title:	BBC Basic for AGON - Audio stuff
04076E             0924  ; Author:	Dean Belfield
04076E             0925  ; Created:	12/05/2023
04076E             0926  ; Last Updated:	12/05/2023
04076E             0927  ;
04076E             0928  ; Modinfo:
04076E             0929  
04076E             0930  			; .ASSUME	ADL = 1
04076E             0931  
04076E             0932  			; INCLUDE	"equs.inc"
04076E             0933  			; INCLUDE "macros.inc"
04076E             0934  			; INCLUDE "mos_api.inc"	; In MOS/src
04076E             0935  
04076E             0936  			; SEGMENT CODE
04076E             0937  
04076E             0938  ; 			XDEF	SOUND
04076E             0939  
04076E             0940  ; 			XREF	COMMA
04076E             0941  ; 			XREF	EXPR_W2
04076E             0942  ; 			XREF	XEQ
04076E             0943  ; 			XREF	LTRAP
04076E             0944  ; 			XREF	OSWRCH
04076E             0945  ; 			XREF	VDU_BUFFER
04076E             0946  
04076E             0947  
04076E             0948  ; SOUND channel,volume,pitch,duration
04076E             0949  ; volume: 0 (off) to -15 (full volume)
04076E             0950  ; pitch: 0 - 255
04076E             0951  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
04076E             0952  ;
04076E CD 5E 3B 04 0953  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
040772 7D          0954  			LD	A, L 			;  A: Volume
040773 F5          0955  			PUSH	AF
040774 D5          0956  			PUSH	DE
040775 CD 42 13 04 0957  			CALL	COMMA
040779 CD 5E 3B 04 0958  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
04077D 53          0959  			LD	D, E			;  D: Pitch
04077E 5D          0960  			LD	E, L 			;  E: Duration
04077F E1          0961  			POP	HL 			; HL: Channel/Control
040780 F1          0962  			POP	AF
040781 ED 44       0963  			NEG
040783 FE 10       0964  			CP	16			; Check volume is in bounds
040785 D2 B6 14 04 0965  			JP	NC, XEQ			; Out of bounds, do nothing
040789             0966  ;
040789             0967  ; Store	in VDU vars
040789             0968  ;
040789 4F          0969  			LD	C, A			; Store Volume in C
04078A 7D          0970  			LD	A, L
04078B 32 00 00 04 0971  			LD	(VDU_BUFFER+0), A	; Channel
04078F AF          0972  			XOR	A
040790 32 01 00 04 0973  			LD	(VDU_BUFFER+1), A	; Waveform
040794             0974  ;
040794             0975  ; Calculate the volume
040794             0976  ;
040794 06 06       0977  			LD	B, 6			; C already contains the volume
040796 ED 4C       0978  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
040798 79          0979  			LD	A, C
040799 32 02 00 04 0980  			LD	(VDU_BUFFER+2), A
04079D             0981  ;
04079D             0982  ; And the frequency
04079D             0983  ;
04079D 4B          0984  			LD	C, E			; Store duration in C
04079E 26 00       0985  			LD	H, 0			; Lookup the frequency
0407A0 6A          0986  			LD	L, D
0407A1 11 28 08 04 0987  			LD	DE, SOUND_FREQ_LOOKUP
0407A5 29          0988  			ADD	HL, HL
0407A6 19          0989  			ADD	HL, DE
0407A7 7E          0990  			LD	A, (HL)
0407A8 32 03 00 04 0991  			LD	(VDU_BUFFER+3), A
0407AC 23          0992  			INC	HL
0407AD 7E          0993  			LD	A, (HL)
0407AE 32 04 00 04 0994  			LD	(VDU_BUFFER+4), A
0407B2             0995  ;
0407B2             0996  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0407B2             0997  ;
0407B2 06 32       0998  			LD	B, 50			; C contains the duration, so MLT by 50
0407B4 ED 4C       0999  			MLT	BC
0407B6 ED 43 05 00 1000  			LD	(VDU_BUFFER+5), BC
       04          
0407BB             1001  ;
0407BB DD E5       1002  			PUSH	IX			; Get the system vars in IX
0407BD             1003  			MOSCALL	mos_sysvars		; Reset the semaphore
0407BD 3E 08       0001M 			LD	A, function
0407BF 5B CF       0002M 			RST.L	08h
0407C1 5B DD CB 04 1004  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0407C6             1005  ;
0407C6             1006  			VDU	23			; Send the sound command
0407C6 3E 17       0001M 			LD	A, val
0407C8 CD D0 36 04 0002M 			CALL	OSWRCH
0407CC             1007  			VDU	0
0407CC 3E 00       0001M 			LD	A, val
0407CE CD D0 36 04 0002M 			CALL	OSWRCH
0407D2             1008  			VDU	vdp_audio
0407D2 3E 85       0001M 			LD	A, val
0407D4 CD D0 36 04 0002M 			CALL	OSWRCH
0407D8             1009  			VDU	(VDU_BUFFER+0)		; 0: Channel
0407D8 3A 00 00 04 0001M 			LD	A, val
0407DC CD D0 36 04 0002M 			CALL	OSWRCH
0407E0             1010  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0407E0 3A 01 00 04 0001M 			LD	A, val
0407E4 CD D0 36 04 0002M 			CALL	OSWRCH
0407E8             1011  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0407E8 3A 02 00 04 0001M 			LD	A, val
0407EC CD D0 36 04 0002M 			CALL	OSWRCH
0407F0             1012  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0407F0 3A 03 00 04 0001M 			LD	A, val
0407F4 CD D0 36 04 0002M 			CALL	OSWRCH
0407F8             1013  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0407F8 3A 04 00 04 0001M 			LD	A, val
0407FC CD D0 36 04 0002M 			CALL	OSWRCH
040800             1014  			VDU	(VDU_BUFFER+5)		; 5: Duration L
040800 3A 05 00 04 0001M 			LD	A, val
040804 CD D0 36 04 0002M 			CALL	OSWRCH
040808             1015  			VDU	(VDU_BUFFER+6)		; 6: Duration H
040808 3A 06 00 04 0001M 			LD	A, val
04080C CD D0 36 04 0002M 			CALL	OSWRCH
040810             1016  ;
040810             1017  ; Wait for acknowledgement
040810             1018  ;
040810 5B DD CB 04 1019  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
040815 28 F9       1020  			JR	Z, @B			; Wait for the result
040817 CD 41 37 04 1021  			CALL	LTRAP			; Check for ESC
04081B 5B DD 7E 0E 1022  			LD.LIL	A, (IX+sysvar_audioSuccess)
04081F A7          1023  			AND	A			; Check if VDP has queued the note
040820 28 9F       1024  			JR	Z, SOUND0		; No, so loop back and send again
040822             1025  ;
040822 DD E1       1026  			POP	IX
040824 C3 B6 14 04 1027  			JP	XEQ
040828             1028  
040828             1029  ; Frequency Lookup Table
040828             1030  ; Set up to replicate the BBC Micro audio frequencies
040828             1031  ;
040828             1032  ; Split over 5 complete octaves, with 53 being middle C
040828             1033  ; * C4: 262hz
040828             1034  ; + A4: 440hz
040828             1035  ;
040828             1036  ;	2	3	4	5	6	7	8
040828             1037  ;
040828             1038  ; B	1	49	97	145	193	241
040828             1039  ; A#	0	45	93	141	189	237
040828             1040  ; A		41	89+	137	185	233
040828             1041  ; G#		37	85	133	181	229
040828             1042  ; G		33	81	129	177	225
040828             1043  ; F#		29	77	125	173	221
040828             1044  ; F		25	73	121	169	217
040828             1045  ; E		21	69	117	165	213
040828             1046  ; D#		17	65	113	161	209
040828             1047  ; D		13	61	109	157	205	253
040828             1048  ; C#		9	57	105	153	201	249
040828             1049  ; C		5	53*	101	149	197	245
040828             1050  ;
040828 75 00 76 00 1051  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
040838 89 00 8B 00 1052  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
040848 99 00 9C 00 1053  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
040858 AC 00 AF 00 1054  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
040868 C1 00 C4 00 1055  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
040878 D9 00 DC 00 1056  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
040888 F3 00 F7 00 1057  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
040898 11 01 15 01 1058  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0408A8 33 01 37 01 1059  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0408B8 58 01 5D 01 1060  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0408C8 82 01 88 01 1061  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0408D8 B2 01 B8 01 1062  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0408E8 E7 01 EE 01 1063  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0408F8 22 02 2A 02 1064  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
040908 65 02 6E 02 1065  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
040918 B1 02 BB 02 1066  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
040928 05 03 10 03 1067  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
040938 63 03 70 03 1068  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
040948 CE 03 DC 03 1069  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
040958 45 04 55 04 1070  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
040968 CB 04 DD 04 1071  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
040978 62 05 76 05 1072  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
040988 0A 06 21 06 1073  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
040998 C8 06 E1 06 1074  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0409A8 9C 07 B8 07 1075  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0409B8 8A 08 A9 08 1076  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0409C8 95 09 B9 09 1077  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0409D8 C2 0A EA 0A 1078  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0409E8 13 0C 40 0C 1079  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0409F8 8E 0D C0 0D 1080  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
040A08 36 0F 6F 0F 1081  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
040A18 13 11 53 11 1082  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
040A28             1083  
040A28             1084  
040A28             1085  
040A28             1086  ; ========================================
040A28             1087  ; FROM eval.asm
040A28             1088  ; ----------------------------------------
040A28             1089  
040A28             1090  ;
040A28             1091  ; Title:	BBC Basic Interpreter - Z80 version
040A28             1092  ;		Expression Evaluation & Arithmetic Module - "EVAL"
040A28             1093  ; Author:	(C) Copyright  R.T.Russell  1984
040A28             1094  ; Modified By:	Dean Belfield
040A28             1095  ; Created:	12/05/2023
040A28             1096  ; Last Updated:	17/08/2023
040A28             1097  ;
040A28             1098  ; Modinfo:
040A28             1099  ; 07/06/2023:	Modified to run in ADL mode
040A28             1100  ; 26/06/2023:	Fixed HEX and HEXSTR
040A28             1101  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
040A28             1102  ; 17/08/2023:	Added binary constants
040A28             1103  
040A28             1104  			; .ASSUME	ADL = 1
040A28             1105  
040A28             1106  			; INCLUDE	"equs.inc"
040A28             1107  			; INCLUDE "macros.inc"
040A28             1108  			; INCLUDE "mos_api.inc"	; In MOS/src
040A28             1109  
040A28             1110  			; SEGMENT CODE
040A28             1111  
040A28             1112  ; 			XDEF	EXPR
040A28             1113  ; 			XDEF	EXPRN
040A28             1114  ; 			XDEF	EXPRI
040A28             1115  ; 			XDEF	EXPRS
040A28             1116  ; 			XDEF	ITEMI
040A28             1117  ; 			XDEF	LOADN
040A28             1118  ; 			XDEF	LOAD4
040A28             1119  ; 			XDEF	CONS
040A28             1120  ; 			XDEF	LOADS
040A28             1121  ; 			XDEF	SFIX
040A28             1122  ; 			XDEF	VAL0
040A28             1123  ; 			XDEF	SEARCH
040A28             1124  ; 			XDEF	SWAP
040A28             1125  ; 			XDEF	TEST
040A28             1126  ; 			XDEF	DECODE
040A28             1127  ; 			XDEF	HEXSTR
040A28             1128  ; 			XDEF	STR
040A28             1129  ; 			XDEF	ZERO
040A28             1130  ; 			XDEF	PUSHS
040A28             1131  ; 			XDEF	POPS
040A28             1132  ; 			XDEF	COMMA
040A28             1133  ; 			XDEF	BRAKET
040A28             1134  ; 			XDEF	NXT
040A28             1135  ; 			XDEF	COUNT0
040A28             1136  
040A28             1137  ; 			XREF	ADVAL
040A28             1138  ; 			XREF	FN
040A28             1139  ; 			XREF	POINT
040A28             1140  ; 			XREF	USR
040A28             1141  ; 			XREF	SYNTAX
040A28             1142  ; 			XREF	ERROR_
040A28             1143  ; 			XREF	CHECK
040A28             1144  ; 			XREF	GETVAR
040A28             1145  ; 			XREF	LISTON
040A28             1146  ; 			XREF	RANGE
040A28             1147  ; 			XREF	FPP
040A28             1148  ; 			XREF	GETCSR
040A28             1149  ; 			XREF	CHANEL
040A28             1150  ; 			XREF	OSSTAT
040A28             1151  ; 			XREF	OSBGET
040A28             1152  ; 			XREF	LOMEM
040A28             1153  ; 			XREF	HIMEM
040A28             1154  ; 			XREF	PAGE_
040A28             1155  ; 			XREF	TOP
040A28             1156  ; 			XREF	ERL
040A28             1157  ; 			XREF	ERR
040A28             1158  ; 			XREF	COUNT
040A28             1159  ; 			XREF	OSOPEN
040A28             1160  ; 			XREF	GETEXT
040A28             1161  ; 			XREF	GETPTR
040A28             1162  ; 			XREF	GETIME
040A28             1163  ; 			XREF	GETIMS
040A28             1164  ; 			XREF	LEXAN2
040A28             1165  ; 			XREF	RANDOM
040A28             1166  ; 			XREF	STORE5
040A28             1167  ; 			XREF	GETSCHR
040A28             1168  ; 			XREF	OSRDCH
040A28             1169  ; 			XREF	OSKEY
040A28             1170  ; 			XREF	INKEY1
040A28             1171  ; 			XREF	EXTERR
040A28             1172  ;
040A28             1173  ; BINARY FLOATING POINT REPRESENTATION:
040A28             1174  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
040A28             1175  ;     8 BIT EXCESS-128 SIGNED EXPONENT
040A28             1176  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
040A28             1177  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
040A28             1178  ;
040A28             1179  ; BINARY INTEGER REPRESENTATION:
040A28             1180  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
040A28             1181  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
040A28             1182  ;
040A28             1183  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
040A28             1184  ;                             EXPONENT - C
040A28             1185  ;
040A28             1186  
040A28             1187  ;
040A28             1188  ; Table of addresses for functions
040A28             1189  ;
040A28             1190  FUNTOK:			EQU	8DH			; First token number
040A28             1191  ;
040A28 03 12 04    1192  FUNTBL:			DW24	DECODE			; Line number
040A2B B1 0E 04    1193  			DW24	OPENIN			; OPENIN
040A2E D3 0E 04    1194  			DW24	PTR_eval			; PTR
040A31             1195  			; DW24	PAGE			; PAGE (label definition not found)
040A31 DD 0E 04    1196  			DW24	TIMEV_eval			; TIME
040A34 59 0E 04    1197  			DW24	LOMEMV_eval			; LOMEM
040A37 63 0E 04    1198  			DW24	HIMEMV_eval			; HIMEM
040A3A 31 0F 04    1199  			DW24	ABSV_eval			; ABS
040A3D 6D 0F 04    1200  			DW24	ACS_eval			; ACS
040A40 70 3B 04    1201  			DW24	ADVAL			; ADVAL
040A43 42 0E 04    1202  			DW24	ASC			; ASC
040A46 65 0F 04    1203  			DW24	ASN_eval			; ASN
040A49 69 0F 04    1204  			DW24	ATN_eval			; ATN
040A4C 0B 0E 04    1205  			DW24	BGET			; BGET
040A4F 51 0F 04    1206  			DW24	COS_eval			; COS
040A52 98 0E 04    1207  			DW24	COUNTV			; COUNT
040A55 39 0F 04    1208  			DW24	DEG_eval			; DEG
040A58 8C 0E 04    1209  			DW24	ERLV			; ERL
040A5B 92 0E 04    1210  			DW24	ERRV			; ERR
040A5E 96 0F 04    1211  			DW24	EVAL_			; EVAL
040A61 59 0F 04    1212  			DW24	EXP_eval			; EXP
040A64 C9 0E 04    1213  			DW24	EXT_eval			; EXT
040A67 B0 12 04    1214  			DW24	ZERO			; FALSE
040A6A             1215  			; DW24	FN			; FN (label definition not found)
040A6A 29 0E 04    1216  			DW24	GET			; GET
040A6D 18 0E 04    1217  			DW24	INKEY			; INKEY
040A70 48 10 04    1218  			DW24	INSTR			; INSTR(
040A73 45 0F 04    1219  			DW24	INT__eval			; INT
040A76 52 0E 04    1220  			DW24	LEN			; LEN
040A79 5D 0F 04    1221  			DW24	LN_eval			; LN
040A7C 61 0F 04    1222  			DW24	LOG_eval			; LOG
040A7F 35 0F 04    1223  			DW24	NOTK_eval			; NOT
040A82 AD 0E 04    1224  			DW24	OPENUP			; OPENUP
040A85 AA 0E 04    1225  			DW24	OPENOT			; OPENOUT
040A88 2D 0F 04    1226  			DW24	PI_eval			; PI
040A8B B1 05 04    1227  			DW24	POINT			; POINT(
040A8E EA 0D 04    1228  			DW24	POS			; POS
040A91 3D 0F 04    1229  			DW24	RAD_eval			; RAD
040A94 CA 0F 04    1230  			DW24	RND			; RND
040A97 41 0F 04    1231  			DW24	SGN_eval			; SGN
040A9A 55 0F 04    1232  			DW24	SIN_eval			; SIN
040A9D 49 0F 04    1233  			DW24	SQR_eval			; SQR
040AA0 4D 0F 04    1234  			DW24	TAN_eval			; TAN
040AA3 77 0E 04    1235  			DW24	TOPV			; TO(P)
040AA6 22 0F 04    1236  			DW24	FOR_eval			; FOR
040AA9 6C 1E 04    1237  			DW24	USR			; USR
040AAC 87 0F 04    1238  			DW24	VAL_eval			; VAL
040AAF F3 0D 04    1239  			DW24	VPOS			; VPOS
040AB2 DC 10 04    1240  			DW24	CHRS			; CHRS
040AB5 E4 10 04    1241  			DW24	GETS			; GETS
040AB8 F5 10 04    1242  			DW24	INKEYS			; INKEYS
040ABB 7A 11 04    1243  			DW24	LEFTS			; LEFTS(
040ABE 42 11 04    1244  			DW24	MIDS			; MIDS(
040AC1 9A 11 04    1245  			DW24	RIGHTS			; RIGHTS(
040AC4 67 12 04    1246  			DW24	STRS			; STR$
040AC7 BB 11 04    1247  			DW24	STRING_			; STRINGS(
040ACA FB 0D 04    1248  			DW24	EOF			; EOF
040ACD             1249  ;
040ACD             1250  FUNTBL_END:		EQU	$
040ACD             1251  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
040ACD             1252  TCMD_eval:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
040ACD             1253  ;
040ACD             1254  ANDK:			EQU     80H
040ACD             1255  DIVK:			EQU     81H
040ACD             1256  EORK:			EQU     82H
040ACD             1257  MODK:			EQU     83H
040ACD             1258  ORK:			EQU     84H
040ACD             1259  ;
040ACD 0D 0F 04    1260  SOPTBL:			DW24	SLE			; <= (STRING)
040AD0 16 0F 04    1261  			DW24	SNE			; <>
040AD3 06 0F 04    1262  			DW24	SGE			; >=
040AD6 F7 0E 04    1263  			DW24	SLT			; <
040AD9 1D 0F 04    1264  			DW24	SEQ			; =
040ADC FE 0E 04    1265  			DW24	SGT			; >
040ADF             1266  ;
040ADF             1267  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
040ADF             1268  ;     Expression type is returned in A'F':
040ADF             1269  ;        Numeric - A' bit 7=0, F' sign bit cleared.
040ADF             1270  ;         String - A' bit 7=1, F' sign bit set.
040ADF             1271  ; Floating-point or integer result returned in HLH'L'C
040ADF             1272  ; Integer result denoted by C=0 and HLH'L' non-zero.
040ADF             1273  ; String result returned in string accumulator, DE set.
040ADF             1274  ;
040ADF             1275  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
040ADF             1276  ;               (2) ^
040ADF             1277  ;               (3) * / MOD DIV
040ADF             1278  ;               (4) + -
040ADF             1279  ;               (5) = <> <= >= > <
040ADF             1280  ;               (6) AND
040ADF             1281  ;               (7) EOR OR
040ADF             1282  
040ADF             1283  ;
040ADF             1284  ; Level 7: EOR and OR
040ADF             1285  ;
040ADF CD F8 0A 04 1286  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
040AE3 FE 82       1287  EXPR0A:			CP      EORK            	; Is operator EOR?
040AE5 28 03       1288  			JR      Z,EXPR0B		; Yes, so skip to next bit
040AE7 FE 84       1289  			CP      ORK			; Is operator OR
040AE9 C0          1290  			RET     NZ			; No, so return
040AEA             1291  ;
040AEA CD 5E 13 04 1292  EXPR0B:			CALL    SAVE_eval            	; Save first operand
040AEE CD F8 0A 04 1293  			CALL    EXPR1           	; Get second operand
040AF2 CD 6D 13 04 1294  			CALL    DOIT            	; Do the operation
040AF6 18 EB       1295  			JR      EXPR0A          	; And continue
040AF8             1296  ;
040AF8             1297  ; Level 6: AND
040AF8             1298  ;
040AF8 CD 0D 0B 04 1299  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
040AFC FE 80       1300  EXPR1A:			CP      ANDK			; Is operator AND?
040AFE C0          1301  			RET     NZ			; No, so return
040AFF CD 5E 13 04 1302  			CALL    SAVE_eval			; Save first operand
040B03 CD 0D 0B 04 1303  			CALL    EXPR2			; Get second operand
040B07 CD 6D 13 04 1304  			CALL    DOIT			; Do the operation
040B0B 18 EF       1305  			JR      EXPR1A			; And continue
040B0D             1306  ;
040B0D             1307  ; Level 5: Comparisons
040B0D             1308  ;
040B0D CD 7F 0B 04 1309  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
040B11 CD 35 13 04 1310  			CALL    RELOP?			; Is it ">", "=" or "<"?
040B15 C0          1311  			RET     NZ			; No, so return
040B16 47          1312  			LD      B,A			; Store the first operator in B
040B17 FD 23       1313  			INC     IY              	; Bump over operator
040B19 CD 90 13 04 1314  			CALL    NXT			;
040B1D CD 35 13 04 1315  			CALL    RELOP?          	; Is it a compound operator?
040B21 20 09       1316  			JR      NZ,EXPR2B		; No, so skip next bit
040B23 FD 23       1317  			INC     IY			; Bump over operator
040B25 B8          1318  			CP      B			; Compare with first
040B26 CA B7 15 04 1319  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
040B2A 80          1320  			ADD     A,B
040B2B 47          1321  			LD      B,A			; B: Unique code for the compound operator
040B2C 78          1322  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
040B2D 08          1323  			EX      AF,AF'
040B2E FA 48 0B 04 1324  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
040B32 08          1325  			EX      AF,AF'
040B33 D6 04       1326  			SUB     4
040B35 FE 3A       1327  			CP      '>'-4
040B37 20 02       1328  			JR      NZ,EXPR2C
040B39 C6 02       1329  			ADD     A,2
040B3B CD 60 13 04 1330  EXPR2C:			CALL    SAVE1
040B3F CD 7F 0B 04 1331  			CALL    EXPR3
040B43 CD 6D 13 04 1332  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
040B47 C9          1333  			RET
040B48             1334  ;
040B48 08          1335  EXPR2S:			EX      AF,AF'			; Handle string comparisons
040B49 3D          1336  			DEC     A
040B4A E6 07       1337  			AND     7
040B4C CD D1 12 04 1338  			CALL    PUSHS           	; Save string on the stack
040B50 F5          1339  			PUSH    AF              	; Save the operator
040B51 CD 7F 0B 04 1340  			CALL    EXPR3           	; Get the second string
040B55 08          1341  			EX      AF,AF'
040B56 F2 53 0C 04 1342  			JP      P,TYPE__eval
040B5A F1          1343  			POP     AF
040B5B 4B          1344  			LD      C,E             	; Length of string #2
040B5C D1          1345  			POP     DE
040B5D 21 00 00 00 1346  			LD      HL,0
040B61 39          1347  			ADD     HL,SP
040B62 43          1348  			LD      B,E             	; Length of string #1
040B63 D5          1349  			PUSH    DE
040B64 11 00 00 04 1350  			LD      DE,ACCS
040B68 EB          1351  			EX      DE,HL
040B69 CD 9C 13 04 1352  			CALL    DISPT2
040B6D D1          1353  			POP     DE
040B6E EB          1354  			EX      DE,HL
040B6F 7D          1355  			LD	A,L
040B70 21 00 00 00 1356  			LD	HL,0
040B74 6F          1357  			LD	L,A
040B75 39          1358  			ADD     HL,SP
040B76 F9          1359  			LD      SP,HL
040B77 EB          1360  			EX      DE,HL
040B78 AF          1361  			XOR     A               	; Numeric marker
040B79 4F          1362  			LD      C,A             	; Integer marker
040B7A 08          1363  			EX      AF,AF'
040B7B FD 7E 00    1364  			LD      A,(IY)
040B7E C9          1365  			RET
040B7F             1366  ;
040B7F             1367  ; Level 4: + and -
040B7F             1368  ;
040B7F CD E1 0B 04 1369  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
040B83 FE 2D       1370  EXPR3A:			CP      '-'			; Is it "-"?
040B85 28 09       1371  			JR      Z,EXPR3B		; Yes, so skip the next bit
040B87 FE 2B       1372  			CP      '+'			; Is it "+"?
040B89 C0          1373  			RET     NZ			; No, so return
040B8A 08          1374  			EX      AF,AF'			; Get the type
040B8B FA 9E 0B 04 1375  			JP      M,EXPR3S		; Branch here if string
040B8F 08          1376  			EX      AF,AF'
040B90 CD 5E 13 04 1377  EXPR3B:			CALL    SAVE_eval			; Save the first operator
040B94 CD E1 0B 04 1378  			CALL    EXPR4			; Fetch the second operator
040B98 CD 6D 13 04 1379  			CALL    DOIT			; Do the operation
040B9C 18 E5       1380  			JR      EXPR3A			; And continue
040B9E             1381  ;
040B9E 08          1382  EXPR3S:			EX      AF,AF'			; Handle string concatenation
040B9F FD 23       1383  			INC     IY              	; Bump past the "+"
040BA1 CD D1 12 04 1384  			CALL    PUSHS           	; Save the string on the stack
040BA5 CD E1 0B 04 1385  			CALL    EXPR4           	; Fetch the second operator
040BA9 08          1386  			EX      AF,AF'
040BAA F2 53 0C 04 1387  			JP      P,TYPE__eval			; If it is not a string, then Error: "Type mismatch"
040BAE 01 00 00 00 1388  			LD	BC, 0			; Clear BC
040BB2 4B          1389  			LD      C,E             	; C: Length of the second string
040BB3 D1          1390  			POP     DE
040BB4 D5          1391  			PUSH    DE
040BB5 21 00 00 04 1392  			LD      HL,ACCS
040BB9 7B          1393  			LD	A,E			;  E: Length of the first string
040BBA 11 00 00 04 1394  			LD      DE,ACCS
040BBE 5F          1395  			LD	E,A 			; DE: Pointer to the end of the first string
040BBF 79          1396  			LD      A,C
040BC0 B7          1397  			OR      A
040BC1 28 0F       1398  			JR      Z,EXP3S3
040BC3 6F          1399  			LD      L,A             	; Source
040BC4 83          1400  			ADD     A,E
040BC5 5F          1401  			LD      E,A             	; Destination
040BC6 3E 13       1402  			LD      A,19
040BC8 DA 5D 43 04 1403  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
040BCC D5          1404  			PUSH    DE
040BCD 1D          1405  			DEC     E
040BCE 2D          1406  			DEC     L
040BCF ED B8       1407  			LDDR                    	; Copy
040BD1 D1          1408  			POP     DE
040BD2 D9          1409  EXP3S3:			EXX
040BD3 C1          1410  			POP     BC
040BD4 CD FE 12 04 1411  			CALL    POPS            	; Restore from stack
040BD8 D9          1412  			EXX
040BD9 F6 80       1413  			OR      80H             	; Flag as a string
040BDB 08          1414  			EX      AF,AF'
040BDC FD 7E 00    1415  			LD      A,(IY)			; Fetch the next character
040BDF 18 A2       1416  			JR      EXPR3A			; And continue
040BE1             1417  ;
040BE1             1418  ; Level 3: * / MOD DIV
040BE1             1419  ;
040BE1 CD 02 0C 04 1420  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
040BE5 FE 2A       1421  EXPR4A:			CP      '*'			; "*" is valid
040BE7 28 0B       1422  			JR      Z,EXPR4B
040BE9 FE 2F       1423  			CP      '/'			; "/" is valid
040BEB 28 07       1424  			JR      Z,EXPR4B
040BED FE 83       1425  			CP      MODK			; MOD token is valid
040BEF 28 03       1426  			JR      Z,EXPR4B
040BF1 FE 81       1427  			CP      DIVK			; DIV token is valid
040BF3 C0          1428  			RET     NZ			; And return if it is anything else
040BF4 CD 5E 13 04 1429  EXPR4B:			CALL    SAVE_eval
040BF8 CD 02 0C 04 1430  			CALL    EXPR5
040BFC CD 6D 13 04 1431  			CALL    DOIT
040C00 18 E3       1432  			JR      EXPR4A
040C02             1433  ;
040C02             1434  ; Level 2: ^
040C02             1435  ;
040C02 CD E2 0C 04 1436  EXPR5:			CALL    ITEM			; Get variable
040C06 B7          1437  			OR      A               	; Test type
040C07 08          1438  			EX      AF,AF'          	; Save type
040C08 CD 90 13 04 1439  EXPR5A:			CALL    NXT			; Skip spaces
040C0C FE 5E       1440  			CP      '^'			; Is the operator "^"?
040C0E C0          1441  			RET     NZ			; No, so return
040C0F CD 5E 13 04 1442  			CALL    SAVE_eval			; Save first operand
040C13 CD E2 0C 04 1443  			CALL    ITEM			; Get second operand
040C17 B7          1444  			OR      A			; Test type
040C18 08          1445  			EX      AF,AF'			; Save type
040C19 CD 6D 13 04 1446  			CALL    DOIT			; Do the operation
040C1D 18 E9       1447  			JR      EXPR5A			; And continue
040C1F             1448  ;
040C1F             1449  ; Evaluate a numeric expression
040C1F             1450  ;
040C1F CD DF 0A 04 1451  EXPRN:			CALL    EXPR			; Evaluate expression
040C23 08          1452  			EX      AF,AF'			; Get the type
040C24 F0          1453  			RET     P			; And return if it is a number
040C25 18 2C       1454  			JR      TYPE__eval			; Otherwise Error: "Type mismatch"
040C27             1455  ;
040C27             1456  ; Evaluate a fixed-point expression
040C27             1457  ;
040C27 CD DF 0A 04 1458  EXPRI:			CALL    EXPR			; Evaluate the expression
040C2B 08          1459  			EX      AF,AF'			; Get the type
040C2C F2 7F 0F 04 1460  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040C30 18 21       1461  			JR      TYPE__eval			; Otherwise Error: "Type mismatch"
040C32             1462  ;
040C32             1463  ; Evaluate a string expression
040C32             1464  ;
040C32 CD DF 0A 04 1465  EXPRS:			CALL    EXPR			; Evaluate the expression
040C36 08          1466  			EX      AF,AF'			; Get the type
040C37 F8          1467  			RET     M			; And return if it is a string
040C38 18 19       1468  			JR      TYPE__eval			; Otherwise Error: "Type mismatch"
040C3A             1469  ;
040C3A             1470  ; Get a numeric variable
040C3A             1471  ;
040C3A CD E2 0C 04 1472  ITEMN:			CALL    ITEM			; Get the variable
040C3E B7          1473  			OR      A			; Test the type
040C3F F0          1474  			RET     P			; And return if it is a number
040C40 18 11       1475  			JR      TYPE__eval			; Otherwise Error: "Type mismatch"
040C42             1476  ;
040C42             1477  ; Get a fixed-point variable
040C42             1478  ;
040C42 CD E2 0C 04 1479  ITEMI:			CALL    ITEM			; Get the variable
040C46 B7          1480  			OR      A			; Test the type
040C47 F2 7F 0F 04 1481  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
040C4B 18 06       1482  			JR      TYPE__eval			; Otherwise Error: "Type mismatch"
040C4D             1483  ;
040C4D             1484  ; Get a string variable
040C4D             1485  ;
040C4D CD E2 0C 04 1486  ITEMS:			CALL    ITEM			; Get the variable
040C51 B7          1487  			OR      A			; Test the type
040C52 F8          1488  			RET     M			; If it is a string, then return
040C53             1489  ;							; Otherwise
040C53 3E 06       1490  TYPE__eval:			LD      A,6			; Error: "Type mismatch"
040C55 C3 5D 43 04 1491  			JP      ERROR_
040C59             1492  ;
040C59             1493  ; Evaluate a bracketed expression
040C59             1494  ;
040C59 CD DF 0A 04 1495  ITEM1:			CALL    EXPR            	; Evaluate the expression
040C5D CD 4F 13 04 1496  			CALL    BRAKET			; Check for closing bracket
040C61 08          1497  			EX      AF,AF'
040C62 C9          1498  			RET
040C63             1499  ;
040C63             1500  ; HEX - Get hexadecimal constant.
040C63             1501  ;   Inputs: ASCII string at (IY)
040C63             1502  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040C63             1503  ;           IY updated (points to delimiter)
040C63             1504  ;
040C63 CD B0 12 04 1505  HEX_eval:			CALL    ZERO			; Set result to 0
040C67 CD 18 13 04 1506  			CALL    HEXDIG			; Fetch the character from IY
040C6B 38 1B       1507  			JR      C,BADHEX		; If invalid HEX_eval character, then Error: "Bad HEX_eval"
040C6D FD 23       1508  HEX1:			INC     IY			; Move pointer to next character
040C6F E6 0F       1509  			AND     0FH			; Clear the top nibble
040C71 06 04       1510  			LD      B,4			; Loop counter
040C73             1511  ;
040C73 D9          1512  HEX2:			EXX				; Shift the result left B (4) times. This makes
040C74 52 29       1513  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
040C76 D9          1514  			EXX				; .
040C77 52 ED 6A    1515  			ADC.S   HL,HL			; .
040C7A 10 F7       1516  			DJNZ    HEX2			; And loop
040C7C D9          1517  			EXX
040C7D B5          1518  			OR      L			; OR in the digit
040C7E 6F          1519  			LD      L,A
040C7F D9          1520  			EXX
040C80             1521  ;
040C80 CD 18 13 04 1522  			CALL    HEXDIG			; Fetch the next character
040C84 30 E7       1523  			JR      NC,HEX1			; If it is a HEX_eval digit then loop
040C86 AF          1524  			XOR     A			; Clear A
040C87 C9          1525  			RET
040C88             1526  ;
040C88 3E 1C       1527  BADHEX:			LD      A,28
040C8A C3 5D 43 04 1528  			JP      ERROR_          	; Error: "Bad HEX_eval"
040C8E             1529  ;
040C8E             1530  ; BIN - Get binary constant.
040C8E             1531  ;   Inputs: ASCII string at (IY)
040C8E             1532  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
040C8E             1533  ;           IY updated (points to delimiter)
040C8E             1534  ;
040C8E CD B0 12 04 1535  BIN:			CALL    ZERO			; Set result to 0
040C92 CD 2B 13 04 1536  			CALL	BINDIG			; Fetch the character from IY
040C96 38 13       1537  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
040C98 FD 23       1538  BIN1:			INC	IY			; Move pointer to next character
040C9A 0F          1539  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
040C9B D9          1540  			EXX				;
040C9C 52 ED 6A    1541  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
040C9F D9          1542  			EXX
040CA0 52 ED 6A    1543  			ADC.S	HL,HL
040CA3 CD 2B 13 04 1544  			CALL	BINDIG			; Fetch the next character
040CA7 30 EF       1545  			JR	NC,BIN1
040CA9 AF          1546  			XOR	A			; Clear A
040CAA C9          1547  			RET
040CAB             1548  ;
040CAB 3E 1C       1549  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX_eval
040CAD CD 74 43 04 1550  			CALL	EXTERR
040CB1 42 61 64 20 1551  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
040CBC             1552  ;
040CBC             1553  ; MINUS - Unary minus.
040CBC             1554  ;   Inputs: IY = text pointer
040CBC             1555  ;  Outputs: Numeric result, same type as argument.
040CBC             1556  ;           Result in H'L'HLC
040CBC             1557  ;
040CBC CD 3A 0C 04 1558  MINUS:			CALL    ITEMN			; Get the numeric argument
040CC0 0D          1559  MINUS0:			DEC     C			; Check exponent (C)
040CC1 0C          1560  			INC     C			; If it is zero, then it's either a FP zero or an integer
040CC2 28 06       1561  			JR      Z,NEGATE_eval        	; So do an integer negation
040CC4             1562  ;
040CC4 7C          1563  			LD      A,H			; Do a FP negation by
040CC5 EE 80       1564  			XOR     80H             	; Toggling the sign bit (H)
040CC7 67          1565  			LD      H,A
040CC8 AF          1566  			XOR     A               	; Numeric marker
040CC9 C9          1567  			RET
040CCA             1568  ;
040CCA D9          1569  NEGATE_eval:			EXX				; This section does a two's complement negation on H'L'HLC
040CCB 7C          1570  			LD      A,H			; First do a one's complement by negating all the bytes
040CCC 2F          1571  			CPL
040CCD 67          1572  			LD      H,A
040CCE 7D          1573  			LD      A,L
040CCF 2F          1574  			CPL
040CD0 6F          1575  			LD      L,A
040CD1 D9          1576  			EXX
040CD2 7C          1577  			LD      A,H
040CD3 2F          1578  			CPL
040CD4 67          1579  			LD      H,A
040CD5 7D          1580  			LD      A,L
040CD6 2F          1581  			CPL
040CD7 6F          1582  			LD      L,A
040CD8 D9          1583  ADD1_eval:			EXX				; Then add 1
040CD9 23          1584  			INC     HL
040CDA 7C          1585  			LD      A,H
040CDB B5          1586  			OR      L
040CDC D9          1587  			EXX
040CDD 3E 00       1588  			LD      A,0             	; Numeric marker
040CDF C0          1589  			RET     NZ
040CE0 23          1590  			INC     HL
040CE1 C9          1591  			RET
040CE2             1592  ;
040CE2             1593  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
040CE2             1594  ; Item type is returned in A:  Bit 7=0 numeric.
040CE2             1595  ;                              Bit 7=1 string.
040CE2             1596  ; Numeric item returned in HLH'L'C.
040CE2             1597  ; String item returned in string accumulator,
040CE2             1598  ;   DE addresses byte after last (E=length).
040CE2             1599  ;
040CE2 CD 99 1F 04 1600  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
040CE6 CD 90 13 04 1601  			CALL    NXT			; Skip spaces
040CEA FD 23       1602  			INC     IY			; Move to the prefix character
040CEC FE 26       1603  			CP      '&'			; If `&`
040CEE CA 63 0C 04 1604  			JP      Z,HEX_eval           	; Then get a HEX_eval constant
040CF2 FE 25       1605  			CP	'%'			; If '%'
040CF4 28 98       1606  			JR	Z,BIN			; Then get a BINARY constant
040CF6 FE 2D       1607  			CP      '-'			; If `-`
040CF8 28 C2       1608  			JR      Z,MINUS         	; Then get a negative number
040CFA FE 2B       1609  			CP      '+'			; If `+`
040CFC CA 3A 0C 04 1610  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
040D00 FE 28       1611  			CP      '('			; If `(`
040D02 CA 59 0C 04 1612  			JP      Z,ITEM1         	; Start of a bracketed expression
040D06 FE 22       1613  			CP      34			; If `"`
040D08 28 7A       1614  			JR      Z,CONS          	; Start of a string constant
040D0A FE C4       1615  			CP      TCMD_eval			; Is it out of range of the function table?
040D0C D2 B7 15 04 1616  			JP      NC,SYNTAX       	; Error: "Syntax Error"
040D10 FE 8D       1617  			CP      FUNTOK			; If it is in range, then
040D12 D2 A3 13 04 1618  			JP      NC,DISPAT_eval       	; It's a function
040D16 FD 2B       1619  			DEC     IY
040D18 FE 3A       1620  			CP      ':'
040D1A 30 0C       1621  			JR      NC,ITEM2		; VARIABLE?
040D1C FE 30       1622  			CP      '0'
040D1E D2 AB 0D 04 1623  			JP      NC,CON_eval			; NUMERIC CONSTANT
040D22 FE 2E       1624  			CP      '.'
040D24 CA AB 0D 04 1625  			JP      Z,CON_eval			; NUMERIC CONSTANT
040D28 CD 37 46 04 1626  ITEM2:			CALL    GETVAR			; VARIABLE
040D2C 20 37       1627  			JR      NZ,NOSUCH
040D2E B7          1628  			OR      A
040D2F FA BD 0D 04 1629  			JP      M,LOADS			; STRING VARIABLE
040D33 B7          1630  LOADN:			OR      A
040D34 28 20       1631  			JR      Z,LOAD1			; BYTE VARIABLE
040D36 0E 00       1632  			LD      C,0
040D38 CB 47       1633  			BIT     0,A
040D3A 28 03       1634  			JR      Z,LOAD4			; INTEGER VARIABLE
040D3C DD 4E 04    1635  LOAD5:			LD      C,(IX+4)
040D3F D9          1636  LOAD4:			EXX
040D40 21 00 00 00 1637  			LD	HL, 0			; TODO: Optimise
040D44 DD 6E 00    1638  			LD      L,(IX+0)
040D47 DD 66 01    1639  			LD      H,(IX+1)
040D4A D9          1640  			EXX
040D4B 21 00 00 00 1641  			LD	HL, 0			; TODO: Optimise
040D4F DD 6E 02    1642  			LD      L,(IX+2)
040D52 DD 66 03    1643  			LD      H,(IX+3)
040D55 C9          1644  			RET
040D56             1645  ;
040D56 21 00 00 00 1646  LOAD1:			LD      HL,0
040D5A D9          1647  			EXX
040D5B 21 00 00 00 1648  			LD      HL,0			; TODO: Optimise
040D5F DD 6E 00    1649  			LD      L,(IX+0)
040D62 D9          1650  			EXX
040D63 4C          1651  			LD      C,H
040D64 C9          1652  			RET
040D65             1653  ;
040D65 DA B7 15 04 1654  NOSUCH:			JP      C,SYNTAX
040D69 3A 40 03 04 1655  			LD      A,(LISTON)
040D6D CB 6F       1656  			BIT     5,A
040D6F 3E 1A       1657  			LD      A,26
040D71 20 26       1658  			JR      NZ,ERROR0_eval		; Throw "No such variable"
040D73 FD 23       1659  NOS1:			INC     IY
040D75 CD 6C 48 04 1660  			CALL    RANGE
040D79 30 F8       1661  			JR      NC,NOS1
040D7B DD 21 40 08 1662  			LD      IX,PC
       10          
040D80 AF          1663  			XOR     A
040D81 4F          1664  			LD      C,A
040D82 18 BB       1665  			JR      LOAD4
040D84             1666  ;
040D84             1667  ;CONS - Get string constant from ASCII string.
040D84             1668  ;   Inputs: ASCII string at (IY)
040D84             1669  ;  Outputs: Result in string accumulator.
040D84             1670  ;           D = MS byte of ACCS, E = string length
040D84             1671  ;           A7 = 1 (string marker)
040D84             1672  ;           IY updated
040D84             1673  ;
040D84 11 00 00 04 1674  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
040D88 FD 7E 00    1675  CONS3:			LD      A,(IY)			; Fetch the first character and
040D8B FD 23       1676  			INC     IY			; Increment the pointer
040D8D FE 22       1677  			CP      '"'			; Check for start quote
040D8F 28 0C       1678  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
040D91             1679  ;
040D91 12          1680  CONS1:			LD      (DE),A			; Store the character in the string accumulator
040D92 1C          1681  			INC     E			; Increment the string accumulator pointer
040D93 FE 0D       1682  			CP      CR			; Is it CR
040D95 20 F1       1683  			JR      NZ,CONS3		; No, so keep looping
040D97             1684  ;
040D97 3E 09       1685  			LD      A,9
040D99 C3 5D 43 04 1686  ERROR0_eval:			JP      ERROR_           	; Throw error "Missing '"'
040D9D             1687  ;
040D9D FD 7E 00    1688  CONS2:			LD      A,(IY)			; Fetch the next character
040DA0 FE 22       1689  			CP      '"'			; Check for end quote?
040DA2 FD 23       1690  			INC     IY			; Increment the pointer
040DA4 28 EB       1691  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
040DA6 FD 2B       1692  			DEC     IY			;
040DA8 3E 80       1693  			LD      A,80H           	; String marker
040DAA C9          1694  			RET
040DAB             1695  ;
040DAB             1696  ;CON - Get unsigned numeric constant from ASCII string.
040DAB             1697  ;   Inputs: ASCII string at (IY).
040DAB             1698  ;  Outputs: Variable-type result in HLH'L'C
040DAB             1699  ;           IY updated (points to delimiter)
040DAB             1700  ;           A7 = 0 (numeric marker)
040DAB             1701  ;
040DAB FD E5       1702  CON_eval:			PUSH    IY
040DAD DD E1       1703  			POP     IX
040DAF 3E 24       1704  			LD      A,36
040DB1 CD 1C 27 04 1705  			CALL    FPP
040DB5 38 E2       1706  			JR      C,ERROR0_eval
040DB7 DD E5       1707  			PUSH    IX
040DB9 FD E1       1708  			POP     IY
040DBB AF          1709  			XOR     A
040DBC C9          1710  			RET
040DBD             1711  ;
040DBD 11 00 00 04 1712  LOADS:			LD      DE,ACCS			; Where to store the string
040DC1 1F          1713  			RRA
040DC2 30 1A       1714  			JR      NC,LOADS2       	; Skip if it is a fixed string
040DC4             1715  ;
040DC4 D9          1716  			EXX				; This block was a call to LOAD4
040DC5 DD 6E 00    1717  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
040DC8 DD 66 01    1718  			LD      H,(IX+1)		; The maximum original string length
040DCB D9          1719  			EXX
040DCC DD 27 02    1720  			LD	HL,(IX+2)		; Address of the string (24-bit)
040DCF             1721  ;
040DCF D9          1722  			EXX
040DD0 7D          1723  			LD      A,L
040DD1 D9          1724  			EXX
040DD2 B7          1725  			OR      A
040DD3 01 00 00 00 1726  			LD	BC,0			; BC: Number of bytes to copy
040DD7 4F          1727  			LD      C,A
040DD8 3E 80       1728  			LD      A,80H           	; String marker
040DDA C8          1729  			RET     Z
040DDB ED B0       1730  			LDIR
040DDD C9          1731  			RET
040DDE 7E          1732  LOADS2:			LD      A,(HL)
040DDF 12          1733  			LD      (DE),A
040DE0 23          1734  			INC     HL
040DE1 FE 0D       1735  			CP      CR
040DE3 3E 80       1736  			LD      A,80H           	; String marker
040DE5 C8          1737  			RET     Z
040DE6 1C          1738  			INC     E
040DE7 20 F5       1739  			JR      NZ,LOADS2
040DE9 C9          1740  			RET                     	; Return null string
040DEA             1741  ;
040DEA             1742  ;VARIABLE-TYPE FUNCTIONS:
040DEA             1743  ;
040DEA             1744  ;Result returned in HLH'L'C (floating point)
040DEA             1745  ;Result returned in HLH'L' (C=0) (integer)
040DEA             1746  ;Result returned in string accumulator & DE (string)
040DEA             1747  ;All registers destroyed.
040DEA             1748  ;IY (text pointer) updated.
040DEA             1749  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
040DEA             1750  ;
040DEA             1751  ;POS - horizontal cursor position.
040DEA             1752  ;VPOS - vertical cursor position.
040DEA             1753  ;EOF - return status of file.
040DEA             1754  ;BGET - read byte from file.
040DEA             1755  ;INKEY - as GET but wait only n centiseconds.
040DEA             1756  ;GET - wait for keypress and return ASCII value.
040DEA             1757  ;GET(n) - input from Z80 port n.
040DEA             1758  ;ASC - ASCII value of string.
040DEA             1759  ;LEN - length of string.
040DEA             1760  ;LOMEM - location of dynamic variables.
040DEA             1761  ;HIMEM - top of available RAM.
040DEA             1762  ;PAGE - start of current text page.
040DEA             1763  ;TOP - address of first free byte after program.
040DEA             1764  ;ERL - line number where last error occurred.
040DEA             1765  ;ERR - number of last error.
040DEA             1766  ;COUNT - number of printing characters since CR.
040DEA             1767  ;Results are integer numeric.
040DEA             1768  ;
040DEA CD 9C 36 04 1769  POS:			CALL    GETCSR			; Return the horizontal cursor position
040DEE EB          1770  			EX      DE,HL			;  L: The X cursor position
040DEF C3 9E 0E 04 1771  			JP      COUNT1			; Return an 8-bit value
040DF3             1772  ;
040DF3 CD 9C 36 04 1773  VPOS:			CALL    GETCSR			; Return the vertical cursor position
040DF7 C3 9E 0E 04 1774  			JP      COUNT1			; Return an 8-bit value
040DFB             1775  ;
040DFB CD D0 21 04 1776  EOF:			CALL    CHANEL			; Check for EOF
040DFF CD 25 3B 04 1777  			CALL    OSSTAT
040E03 CA 22 0F 04 1778  			JP      Z,FOR_eval			; Yes, so return true
040E07 C3 B0 12 04 1779  			JP      ZERO			; Otherwise return false (zero)
040E0B             1780  ;
040E0B CD D0 21 04 1781  BGET:			CALL    CHANEL          	; Channel number
040E0F CD 14 3B 04 1782  			CALL    OSBGET
040E13 6F          1783  			LD      L,A
040E14 C3 9C 0E 04 1784  			JP      COUNT0			; Return an 8-bit value
040E18             1785  ;
040E18 CD 42 0C 04 1786  INKEY:			CALL    ITEMI			; Get the argument
040E1C CB 7C       1787  			BIT	7, H			; Check the sign
040E1E D9          1788  			EXX				; HL: The argument
040E1F C2 08 11 04 1789  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
040E23 CD FA 10 04 1790  			CALL	INKEY0 			; Do INKEY(n)
040E27 18 1D       1791  			JR      ASC0			; Return a numeric value
040E29             1792  ;
040E29 CD 90 13 04 1793  GET:			CALL    NXT			; Skip whitespace
040E2D FE 28       1794  			CP      '('			; Is it GET(
040E2F 20 0B       1795  			JR      NZ,GET0			; No, so get a keyboard character
040E31 CD 42 0C 04 1796  			CALL    ITEMI           	; Yes, so fetch the port address
040E35 D9          1797  			EXX
040E36 44          1798  			LD      B,H			; BC: The port address
040E37 4D          1799  			LD      C,L
040E38 ED 68       1800  			IN      L,(C)           	;  L: Input from port BC
040E3A 18 60       1801  			JR      COUNT0			; Return an 8-bit value
040E3C             1802  ;
040E3C CD E4 10 04 1803  GET0:			CALL    GETS			; Read the keyboard character
040E40 18 0A       1804  			JR      ASC1			; And return the value
040E42             1805  ;
040E42 CD 4D 0C 04 1806  ASC:			CALL    ITEMS			; Get the string argument argument
040E46 AF          1807  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
040E47 BB          1808  			CP      E			; Is the pointer 0
040E48 CA 22 0F 04 1809  			JP      Z,FOR_eval          	; Yes, so return -1 as it is a null string
040E4C 2A 00 00 04 1810  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
040E50 18 4A       1811  			JR      COUNT0			; An 8-bit value
040E52             1812  ;
040E52 CD 4D 0C 04 1813  LEN:			CALL    ITEMS			; Get the string argument
040E56 EB          1814  			EX      DE,HL			; HL: Pointer into ACCS
040E57 18 43       1815  			JR      COUNT0			; Return L
040E59             1816  ;
040E59 2A 1A 03 04 1817  LOMEMV_eval:			LD      HL,(LOMEM)		; Return the LOMEM system variable
040E5D 3A 1C 03 04 1818  			LD	A, (LOMEM+2)
040E61 18 41       1819  			JR      COUNT2			; A 24-bit value
040E63             1820  ;
040E63 2A 20 03 04 1821  HIMEMV_eval:			LD      HL,(HIMEM)		; Return the HIMEM system variable
040E67 3A 22 03 04 1822  			LD	A, (HIMEM+2)
040E6B 18 37       1823  			JR      COUNT2			; A 24-bit value
040E6D             1824  ;
040E6D 2A 14 03 04 1825  PAGEV_eval:			LD    	HL,(PAGE_)		; Return the PAGE system variable
040E71 3A 16 03 04 1826  			LD	A, (PAGE_+2)		; A 24-bit value
040E75 18 2D       1827  			JR      COUNT2
040E77             1828  ;
040E77 FD 7E 00    1829  TOPV:			LD      A,(IY)			; Return the TOP system variable
040E7A FD 23       1830  			INC     IY              	; Skip "P"
040E7C FE 50       1831  			CP      'P'
040E7E C2 B7 15 04 1832  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
040E82 2A 17 03 04 1833  			LD      HL,(TOP)
040E86 3A 19 03 04 1834  			LD	A, (TOP+2)
040E8A 18 18       1835  			JR      COUNT2
040E8C             1836  ;
040E8C 2A 33 03 04 1837  ERLV:			LD      HL,(ERL)		; Return the error line
040E90 18 0C       1838  			JR      COUNT1			; A 16-bit value
040E92             1839  ;
040E92 2A 3F 03 04 1840  ERRV:			LD      HL,(ERR)		; Return the error value
040E96 18 04       1841  			JR      COUNT0			; An 8-bit value
040E98             1842  ;
040E98 2A 3D 03 04 1843  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
040E9C             1844  
040E9C 26 00       1845  COUNT0:			LD      H,0			; Return L
040E9E D9          1846  COUNT1:			EXX				; Return HL
040E9F AF          1847  			XOR     A
040EA0 4F          1848  			LD      C,A             	; Integer marker
040EA1 67          1849  			LD      H,A
040EA2 6F          1850  			LD      L,A
040EA3 C9          1851  			RET
040EA4 D9          1852  COUNT2:			EXX
040EA5 6F          1853  			LD	L,A
040EA6 AF          1854  			XOR	A
040EA7 4F          1855  			LD	C,A			; Integer marker
040EA8 67          1856  			LD	H,A
040EA9 C9          1857  			RET
040EAA             1858  ;
040EAA             1859  ;OPENIN - Open a file for reading.
040EAA             1860  ;OPENOT - Open a file for writing.
040EAA             1861  ;OPENUP - Open a file for reading or writing.
040EAA             1862  ;Result is integer channel number (0 if error)
040EAA             1863  ;
040EAA AF          1864  OPENOT:			XOR     A			; Open for writing
040EAB 18 06       1865  			JR	OPENIN_1
040EAD             1866  ;
040EAD 3E 02       1867  OPENUP:			LD      A,2			; Open for reading / writing
040EAF 18 02       1868  			JR	OPENIN_1
040EB1             1869  ;
040EB1 3E 01       1870  OPENIN:			LD      A,1			; Open for reading
040EB3             1871  ;
040EB3 F5          1872  OPENIN_1:		PUSH    AF              	; Save OPEN type
040EB4 CD 4D 0C 04 1873  			CALL    ITEMS           	; Fetch the filename
040EB8 3E 0D       1874  			LD      A,CR
040EBA 12          1875  			LD      (DE),A
040EBB F1          1876  			POP     AF              	; Restore the OPEN type
040EBC C6 FF       1877  			ADD     A,-1            	; Affect the flags
040EBE 21 00 00 04 1878  			LD      HL,ACCS
040EC2 CD FD 3A 04 1879  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
040EC6 6F          1880  			LD      L,A			; L: Channel number
040EC7 18 D3       1881  			JR      COUNT0			; Return channel number to BASIC
040EC9             1882  ;
040EC9             1883  ;EXT - Return length of file.
040EC9             1884  ;PTR - Return current file pointer.
040EC9             1885  ;Results are integer numeric.
040EC9             1886  ;
040EC9 CD D0 21 04 1887  EXT_eval:			CALL    CHANEL
040ECD CD 47 3B 04 1888  			CALL    GETEXT
040ED1 18 15       1889  			JR      TIME0
040ED3             1890  ;
040ED3 CD D0 21 04 1891  PTR_eval:			CALL    CHANEL
040ED7 CD 2F 3B 04 1892  			CALL    GETPTR
040EDB 18 0B       1893  			JR      TIME0
040EDD             1894  ;
040EDD             1895  ;TIME - Return current value of elapsed time.
040EDD             1896  ;Result is integer numeric.
040EDD             1897  ;
040EDD FD 7E 00    1898  TIMEV_eval:			LD      A,(IY)
040EE0 FE 24       1899  			CP      '$'
040EE2 28 0A       1900  			JR      Z,TIMEVS_eval
040EE4 CD 7C 36 04 1901  			CALL    GETIME
040EE8 D5          1902  TIME0:			PUSH    DE
040EE9 D9          1903  			EXX
040EEA E1          1904  			POP     HL
040EEB AF          1905  			XOR     A
040EEC 4F          1906  			LD      C,A
040EED C9          1907  			RET
040EEE             1908  ;
040EEE             1909  ;TIME$ - Return date/time string.
040EEE             1910  ;Result is string
040EEE             1911  ;
040EEE FD 23       1912  TIMEVS_eval:			INC     IY              ;SKIP $
040EF0 CD 4C 3B 04 1913  			CALL    GETIMS
040EF4 3E 80       1914  			LD      A,80H           ;MARK STRING
040EF6 C9          1915  			RET
040EF7             1916  ;
040EF7             1917  ;String comparison:
040EF7             1918  ;
040EF7 CD AC 12 04 1919  SLT:			CALL    SCP
040EFB D0          1920  			RET     NC
040EFC 18 24       1921  			JR      FOR_eval
040EFE             1922  ;
040EFE CD AC 12 04 1923  SGT:			CALL    SCP
040F02 C8          1924  			RET     Z
040F03 D8          1925  			RET     C
040F04 18 1C       1926  			JR      FOR_eval
040F06             1927  ;
040F06 CD AC 12 04 1928  SGE:			CALL    SCP
040F0A D8          1929  			RET     C
040F0B 18 15       1930  			JR      FOR_eval
040F0D             1931  ;
040F0D CD AC 12 04 1932  SLE:			CALL    SCP
040F11 28 0F       1933  			JR      Z,FOR_eval
040F13 D0          1934  			RET     NC
040F14 18 0C       1935  			JR      FOR_eval
040F16             1936  ;
040F16 CD AC 12 04 1937  SNE:			CALL    SCP
040F1A C8          1938  			RET     Z
040F1B 18 05       1939  			JR      FOR_eval
040F1D             1940  ;
040F1D CD AC 12 04 1941  SEQ:			CALL    SCP
040F21 C0          1942  			RET     NZ
040F22 3E FF       1943  FOR_eval:			LD      A,-1
040F24 D9          1944  			EXX
040F25 67          1945  			LD      H,A
040F26 6F          1946  			LD      L,A
040F27 D9          1947  			EXX
040F28 67          1948  			LD      H,A
040F29 6F          1949  			LD      L,A
040F2A 3C          1950  			INC     A
040F2B 4F          1951  			LD      C,A
040F2C C9          1952  			RET
040F2D             1953  ;
040F2D             1954  ;PI - Return PI (3.141592654)
040F2D             1955  ;Result is floating-point numeric.
040F2D             1956  ;
040F2D 3E 23       1957  PI_eval:			LD      A,35
040F2F 18 44       1958  			JR      FPP1
040F31             1959  ;
040F31             1960  ;ABS - Absolute value
040F31             1961  ;Result is numeric, variable type.
040F31             1962  ;
040F31 3E 10       1963  ABSV_eval:			LD      A,16
040F33 18 3A       1964  			JR      FPPN
040F35             1965  ;
040F35             1966  ;NOT - Complement integer.
040F35             1967  ;Result is integer numeric.
040F35             1968  ;
040F35 3E 1A       1969  NOTK_eval:			LD      A,26
040F37 18 36       1970  			JR      FPPN
040F39             1971  ;
040F39             1972  ;DEG - Convert radians to degrees
040F39             1973  ;Result is floating-point numeric.
040F39             1974  ;
040F39 3E 15       1975  DEG_eval:			LD      A,21
040F3B 18 32       1976  			JR      FPPN
040F3D             1977  ;
040F3D             1978  ;RAD - Convert degrees to radians
040F3D             1979  ;Result is floating-point numeric.
040F3D             1980  ;
040F3D 3E 1B       1981  RAD_eval:			LD      A,27
040F3F 18 2E       1982  			JR      FPPN
040F41             1983  ;
040F41             1984  ;SGN - Return -1, 0 or +1
040F41             1985  ;Result is integer numeric.
040F41             1986  ;
040F41 3E 1C       1987  SGN_eval:			LD      A,28
040F43 18 2A       1988  			JR      FPPN
040F45             1989  ;
040F45             1990  ;INT - Floor function
040F45             1991  ;Result is integer numeric.
040F45             1992  ;
040F45 3E 17       1993  INT__eval:			LD      A,23
040F47 18 26       1994  			JR      FPPN
040F49             1995  ;
040F49             1996  ;SQR - square root
040F49             1997  ;Result is floating-point numeric.
040F49             1998  ;
040F49 3E 1E       1999  SQR_eval:			LD      A,30
040F4B 18 22       2000  			JR      FPPN
040F4D             2001  ;
040F4D             2002  ;TAN - Tangent function
040F4D             2003  ;Result is floating-point numeric.
040F4D             2004  ;
040F4D 3E 1F       2005  TAN_eval:			LD      A,31
040F4F 18 1E       2006  			JR      FPPN
040F51             2007  ;
040F51             2008  ;COS - Cosine function
040F51             2009  ;Result is floating-point numeric.
040F51             2010  ;
040F51 3E 14       2011  COS_eval:			LD      A,20
040F53 18 1A       2012  			JR      FPPN
040F55             2013  ;
040F55             2014  ;SIN - Sine function
040F55             2015  ;Result is floating-point numeric.
040F55             2016  ;
040F55 3E 1D       2017  SIN_eval:			LD      A,29
040F57 18 16       2018  			JR      FPPN
040F59             2019  ;
040F59             2020  ;EXP - Exponential function
040F59             2021  ;Result is floating-point numeric.
040F59             2022  ;
040F59 3E 16       2023  EXP_eval:			LD      A,22
040F5B 18 12       2024  			JR      FPPN
040F5D             2025  ;
040F5D             2026  ;LN - Natural log.
040F5D             2027  ;Result is floating-point numeric.
040F5D             2028  ;
040F5D 3E 18       2029  LN_eval:			LD      A,24
040F5F 18 0E       2030  			JR      FPPN
040F61             2031  ;
040F61             2032  ;LOG - base-10 logarithm.
040F61             2033  ;Result is floating-point numeric.
040F61             2034  ;
040F61 3E 19       2035  LOG_eval:			LD      A,25
040F63 18 0A       2036  			JR      FPPN
040F65             2037  ;
040F65             2038  ;ASN - Arc-sine
040F65             2039  ;Result is floating-point numeric.
040F65             2040  ;
040F65 3E 12       2041  ASN_eval:			LD      A,18
040F67 18 06       2042  			JR      FPPN
040F69             2043  ;
040F69             2044  ;ATN - arc-tangent
040F69             2045  ;Result is floating-point numeric.
040F69             2046  ;
040F69 3E 13       2047  ATN_eval:			LD      A,19
040F6B 18 02       2048  			JR      FPPN
040F6D             2049  ;
040F6D             2050  ;ACS - arc-cosine
040F6D             2051  ;Result is floating point numeric.
040F6D             2052  ;
040F6D 3E 11       2053  ACS_eval:			LD      A,17
040F6F F5          2054  FPPN:			PUSH    AF
040F70 CD 3A 0C 04 2055  			CALL    ITEMN
040F74 F1          2056  			POP     AF
040F75 CD 1C 27 04 2057  FPP1:			CALL    FPP
040F79 DA 5D 43 04 2058  			JP      C,ERROR_
040F7D AF          2059  			XOR     A
040F7E C9          2060  			RET
040F7F             2061  ;
040F7F             2062  ;SFIX - Convert to fixed-point notation
040F7F             2063  ;
040F7F 3E 26       2064  SFIX:			LD      A,38
040F81 18 F2       2065  			JR      FPP1
040F83             2066  ;
040F83             2067  ;SFLOAT - Convert to floating-point notation
040F83             2068  ;
040F83 3E 27       2069  SFLOAT_eval:			LD      A,39
040F85 18 EE       2070  			JR      FPP1
040F87             2071  ;
040F87             2072  ;VAL - Return numeric value of string.
040F87             2073  ;Result is variable type numeric.
040F87             2074  ;
040F87 CD 4D 0C 04 2075  VAL_eval:			CALL    ITEMS
040F8B AF          2076  VAL0:			XOR     A
040F8C 12          2077  			LD      (DE),A
040F8D DD 21 00 00 2078  			LD      IX,ACCS
       04          
040F92 3E 24       2079  			LD      A,36
040F94 18 DF       2080  			JR      FPP1
040F96             2081  ;
040F96             2082  ;EVAL - Pass string to expression evaluator.
040F96             2083  ;Result is variable type (numeric or string).
040F96             2084  ;
040F96 CD 4D 0C 04 2085  EVAL_:			CALL    ITEMS
040F9A 3E 0D       2086  			LD      A,CR
040F9C 12          2087  			LD      (DE),A
040F9D FD E5       2088  			PUSH    IY
040F9F 11 00 00 04 2089  			LD      DE,ACCS
040FA3 FD 21 00 00 2090  			LD      IY,ACCS
       04          
040FA8 0E 00       2091  			LD      C,0
040FAA CD 9C 48 04 2092  			CALL    LEXAN2          ;TOKENISE
040FAE 12          2093  			LD      (DE),A
040FAF 13          2094  			INC     DE
040FB0 AF          2095  			XOR     A
040FB1 CD D1 12 04 2096  			CALL    PUSHS           ;PUT ON STACK
040FB5 FD 21 03 00 2097  			LD      IY,SIZEW	;WAS 2
       00          
040FBA FD 39       2098  			ADD     IY,SP
040FBC CD DF 0A 04 2099  			CALL    EXPR
040FC0 FD E1       2100  			POP     IY
040FC2 FD 39       2101  			ADD     IY,SP
040FC4 FD F9       2102  			LD      SP,IY           ;ADJUST STACK POINTER
040FC6 FD E1       2103  			POP     IY
040FC8 08          2104  			EX      AF,AF'
040FC9 C9          2105  			RET
040FCA             2106  ;
040FCA             2107  ;RND - Random number function.
040FCA             2108  ; RND gives random integer 0-&FFFFFFFF
040FCA             2109  ; RND(-n) seeds random number & returns -n.
040FCA             2110  ; RND(0) returns last value in RND(1) form.
040FCA             2111  ; RND(1) returns floating-point 0-0.99999999.
040FCA             2112  ; RND(n) returns random integer 1-n.
040FCA             2113  ;
040FCA DD 21 38 03 2114  RND:			LD      IX,RANDOM
       04          
040FCF CD 90 13 04 2115  			CALL    NXT
040FD3 FE 28       2116  			CP      '('
040FD5 28 20       2117  			JR      Z,RND5          ;ARGUMENT FOLLOWS
040FD7 CD 3C 0D 04 2118  			CALL    LOAD5
040FDB CB 19       2119  RND1:			RR      C
040FDD 06 20       2120  			LD      B,32
040FDF D9          2121  RND2:			EXX                     ;CALCULATE NEXT
040FE0 52 ED 6A    2122  			ADC.S   HL,HL
040FE3 D9          2123  			EXX
040FE4 52 ED 6A    2124  			ADC.S   HL,HL
040FE7 CB 5D       2125  			BIT     3,L
040FE9 28 01       2126  			JR      Z,RND3
040FEB 3F          2127  			CCF
040FEC 10 F1       2128  RND3:			DJNZ    RND2
040FEE CB 11       2129  RND4:			RL      C               ;SAVE CARRY
040FF0 CD 25 1F 04 2130  			CALL    STORE5          ;STORE NEW NUMBER
040FF4 AF          2131  			XOR     A
040FF5 4F          2132  			LD      C,A
040FF6 C9          2133  			RET
040FF7 CD 42 0C 04 2134  RND5:			CALL    ITEMI
040FFB DD 21 38 03 2135  			LD      IX,RANDOM
       04          
041000 CB 7C       2136  			BIT     7,H             ;NEGATIVE?
041002 37          2137  			SCF
041003 20 E9       2138  			JR      NZ,RND4         ;SEED
041005 CD FC 11 04 2139  			CALL    TEST
041009 F5          2140  			PUSH    AF
04100A CD F4 11 04 2141  			CALL    SWAP
04100E D9          2142  			EXX
04100F CD 3C 0D 04 2143  			CALL    LOAD5
041013 C4 DB 0F 04 2144  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
041017 D9          2145  			EXX                     ;SCRAMBLE (CARE!)
041018 0E 7F       2146  			LD      C,7FH
04101A CB 7C       2147  RND6:			BIT     7,H             ;FLOAT
04101C 20 0A       2148  			JR      NZ,RND7
04101E D9          2149  			EXX
04101F 52 29       2150  			ADD.S   HL,HL
041021 D9          2151  			EXX
041022 52 ED 6A    2152  			ADC.S   HL,HL
041025 0D          2153  			DEC     C
041026 20 F2       2154  			JR      NZ,RND6
041028 CB BC       2155  RND7:			RES     7,H             ;POSITIVE 0-0.999999
04102A F1          2156  			POP     AF
04102B C8          2157  			RET     Z               ;ZERO ARGUMENT
04102C D9          2158  			EXX
04102D 7B          2159  			LD      A,E
04102E 3D          2160  			DEC     A
04102F B2          2161  			OR      D
041030 D9          2162  			EXX
041031 B3          2163  			OR      E
041032 B2          2164  			OR      D
041033 C8          2165  			RET     Z               ;ARGUMENT=1
041034 06 00       2166  			LD      B,0             ;INTEGER MARKER
041036 3E 0A       2167  			LD      A,10
041038 CD 1C 27 04 2168  			CALL    FPP             ;MULTIPLY
04103C DA 5D 43 04 2169  			JP      C,ERROR_
041040 CD 7F 0F 04 2170  			CALL    SFIX
041044 C3 D8 0C 04 2171  			JP      ADD1_eval
041048             2172  ;
041048             2173  ; INSTR - String search.
041048             2174  ; Result is integer numeric.
041048             2175  ;
041048 CD 3E 13 04 2176  INSTR:			CALL    EXPRSC			; Get the first string expression
04104C CD D1 12 04 2177  			CALL    PUSHS           	; Push the string onto the stack
041050 CD 32 0C 04 2178  			CALL    EXPRS           	; Get the second string expression
041054 C1          2179  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
041055 21 00 00 00 2180  			LD      HL,0
041059 39          2181  			ADD     HL,SP           	; HL: Pointer to main string
04105A C5          2182  			PUSH    BC              	;  C: Main string length
04105B 43          2183  			LD      B,E             	;  B: Sub-string length
04105C CD 90 13 04 2184  			CALL    NXT			; Skip whitespace
041060 FE 2C       2185  			CP      ','			; Check if there is a comma for the third parameter
041062 3E 00       2186  			LD      A,0			;  A: Default start position in string
041064 20 1A       2187  			JR      NZ,INSTR1		; No, so skip the next bit
041066 FD 23       2188  			INC     IY              	; Skip the comma
041068 C5          2189  			PUSH    BC              	; Save the lengths
041069 E5          2190  			PUSH    HL              	; Save the pointer to the main string
04106A CD D1 12 04 2191  			CALL    PUSHS			; Push the string onto the stack
04106E CD 27 0C 04 2192  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
041072 C1          2193  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
041073 CD FE 12 04 2194  			CALL    POPS			; Pop the string off the stack
041077 E1          2195  			POP     HL              	; Restore the pointer to the main string
041078 C1          2196  			POP     BC              	; Restore the lengths
041079 D9          2197  			EXX
04107A 7D          2198  			LD      A,L			; A: The start position in the  string
04107B D9          2199  			EXX
04107C B7          2200  			OR      A			; Set the flags
04107D 28 01       2201  			JR      Z,INSTR1		; If it is zero, then skip
04107F 3D          2202  			DEC     A
041080 11 00 00 04 2203  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
041084 CD A2 10 04 2204  			CALL    SEARCH			; Do the search
041088 D1          2205  			POP     DE
041089 28 03       2206  			JR      Z,INSTR2        	; NB: Carry cleared
04108B ED 62       2207  			SBC     HL,HL
04108D 39          2208  			ADD     HL,SP
04108E ED 72       2209  INSTR2:			SBC     HL,SP
041090 EB          2210  			EX      DE,HL
041091 7D          2211  			LD	A,L
041092 21 00 00 00 2212  			LD      HL,0
041096 6F          2213  			LD	L,A
041097 39          2214  			ADD     HL,SP
041098 F9          2215  			LD      SP,HL
041099 EB          2216  			EX      DE,HL
04109A CD 4F 13 04 2217  			CALL    BRAKET			; Check for closing bracket
04109E C3 9E 0E 04 2218  			JP      COUNT1			; Return a numeric integer
0410A2             2219  ;
0410A2             2220  ; SEARCH - Search string for sub-string
0410A2             2221  ;    Inputs: Main string at HL length C
0410A2             2222  ;            Sub-string  at DE length B
0410A2             2223  ;            Starting offset A
0410A2             2224  ;   Outputs: NZ - not found
0410A2             2225  ;            Z - found at location HL-1
0410A2             2226  ;            Carry always cleared
0410A2             2227  ;
0410A2 C5          2228  SEARCH:			PUSH    BC			; Add the starting offset to HL
0410A3 01 00 00 00 2229  			LD      BC,0
0410A7 4F          2230  			LD      C,A
0410A8 09          2231  			ADD     HL,BC           	; New start address
0410A9 C1          2232  			POP     BC
0410AA 91          2233  			SUB     C			; If the starting offset > main string length, then do nothing
0410AB 30 2C       2234  			JR      NC,SRCH4
0410AD ED 44       2235  			NEG
0410AF 4F          2236  			LD      C,A             	; Remaining length
0410B0             2237  ;
0410B0 C5          2238  SRCH1_eval:			PUSH    BC
0410B1 79          2239  			LD	A,C
0410B2 01 00 00 00 2240  			LD	BC,0
0410B6 4F          2241  			LD	C,A
0410B7 1A          2242  			LD      A,(DE)
0410B8 ED B1       2243  			CPIR                    	; Find the first character
0410BA 79          2244  			LD      A,C
0410BB C1          2245  			POP     BC
0410BC 20 1B       2246  			JR      NZ,SRCH4
0410BE 4F          2247  			LD      C,A
0410BF             2248  ;
0410BF             2249  ; This block of four instructions was commented as a bug fix by R.T.Russell
0410BF             2250  ;
0410BF 05          2251  			DEC     B			; Bug fix
0410C0 B8          2252  			CP      B			; Bug fix
0410C1 04          2253  			INC     B			; Bug fix
0410C2 38 15       2254  			JR      C,SRCH4			; Bug fix
0410C4             2255  ;
0410C4 C5          2256  			PUSH    BC
0410C5 D5          2257  			PUSH    DE
0410C6 E5          2258  			PUSH    HL
0410C7 05          2259  			DEC     B
0410C8 28 08       2260  			JR      Z,SRCH3         	; Found!
0410CA 13          2261  SRCH2_eval:			INC     DE
0410CB 1A          2262  			LD      A,(DE)
0410CC BE          2263  			CP      (HL)
0410CD 20 03       2264  			JR      NZ,SRCH3
0410CF 23          2265  			INC     HL
0410D0 10 F8       2266  			DJNZ    SRCH2_eval
0410D2 E1          2267  SRCH3:			POP     HL
0410D3 D1          2268  			POP     DE
0410D4 C1          2269  			POP     BC
0410D5 20 D9       2270  			JR      NZ,SRCH1_eval
0410D7 AF          2271  			XOR     A               	; Flags: Z, NC
0410D8 C9          2272  			RET                     	; Found
0410D9             2273  ;
0410D9 F6 FF       2274  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0410DB C9          2275  			RET                     	; Not found
0410DC             2276  ;
0410DC             2277  ;CHRS - Return character with given ASCII value.
0410DC             2278  ;Result is string.
0410DC             2279  ;
0410DC CD 42 0C 04 2280  CHRS:			CALL    ITEMI
0410E0 D9          2281  			EXX
0410E1 7D          2282  			LD      A,L
0410E2 18 0E       2283  			JR      GET1
0410E4             2284  ;
0410E4             2285  ;GETS - Return key pressed as stringor character at position (X,Y).
0410E4             2286  ;Result is string.
0410E4             2287  ;
0410E4 CD 90 13 04 2288  GETS:			CALL	NXT		;NEW CODE FOR_eval GET$(X,Y)
0410E8 FE 28       2289  			CP	'('
0410EA CA 44 05 04 2290  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0410EE CD F9 36 04 2291  			CALL    OSRDCH
0410F2 37          2292  GET1:			SCF
0410F3 18 09       2293  			JR      INKEY1
0410F5             2294  ;
0410F5             2295  ; INKEYS - Wait up to n centiseconds for keypress.
0410F5             2296  ;          Return key pressed as string or null
0410F5             2297  ;          string if time elapsed.
0410F5             2298  ; Result is string.
0410F5             2299  ;
0410F5 CD 42 0C 04 2300  INKEYS:			CALL    ITEMI			; Fetch the argument
0410F9 D9          2301  			EXX
0410FA CD 02 37 04 2302  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0410FE 11 00 00 04 2303  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
041102 12          2304  			LD      (DE),A
041103 3E 80       2305  			LD      A,80H
041105 D0          2306  			RET     NC
041106 1C          2307  			INC     E
041107 C9          2308  			RET
041108             2309  ;
041108             2310  ; INKEYM - Check immediately whether a given key is being pressed
041108             2311  ; Result is integer numeric
041108             2312  ;
041108             2313  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
041108 3E 1E       0001M 			LD	A, function
04110A 5B CF       0002M 			RST.L	08h
04110C 23          2314  			INC	HL			; Index from 0
04110D 7D          2315  			LD	A, L			; Negate the LSB of the answer
04110E ED 44       2316  			NEG
041110 4F          2317  			LD	C, A			;  E: The positive keycode value
041111 3E 01       2318  			LD	A, 1			; Throw an "Out of range" error
041113 FA 5D 43 04 2319  			JP	M, ERROR_		; if the argument < - 128
041117             2320  ;
041117 21 3A 11 04 2321  			LD	HL, BITLOOKUP		; HL: The bit lookup table
04111B 11 00 00 00 2322  			LD	DE, 0
04111F 79          2323  			LD	A, C
041120 E6 07       2324  			AND	00000111b		; Just need the first three bits
041122 5F          2325  			LD	E, A			; DE: The bit number
041123 19          2326  			ADD	HL, DE
041124 46          2327  			LD	B, (HL)			;  B: The mask
041125             2328  ;
041125 79          2329  			LD	A, C			; Fetch the keycode again
041126 E6 78       2330  			AND	01111000b		; And divide by 8
041128 0F          2331  			RRCA
041129 0F          2332  			RRCA
04112A 0F          2333  			RRCA
04112B 5F          2334  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
04112C DD 19       2335  			ADD	IX, DE			; IX: The address
04112E 78          2336  			LD	A, B			;  B: The mask
04112F DD A6 00    2337  			AND	(IX+0)			; Check whether the bit is set
041132 CA B0 12 04 2338  			JP	Z, ZERO			; No, so return 0
041136 C3 22 0F 04 2339  			JP	FOR_eval			; Otherwise return -1
04113A             2340  ;
04113A             2341  ; A bit lookup table
04113A             2342  ;
04113A 01 02 04 08 2343  BITLOOKUP:		DB	01h, 02h, 04h, 08h
04113E 10 20 40 80 2344  			DB	10h, 20h, 40h, 80h
041142             2345  ;
041142             2346  ; MID$ - Return sub-string.
041142             2347  ; Result is string.
041142             2348  ;
041142 CD 3E 13 04 2349  MIDS:			CALL    EXPRSC			; Get the first string expression
041146 CD D1 12 04 2350  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
04114A CD 27 0C 04 2351  			CALL    EXPRI			; Get the second expression
04114E C1          2352  			POP     BC			; C: String length, B: Value of A before PUSHS was called
04114F CD FE 12 04 2353  			CALL    POPS			; Pop the string back off the stack to the string accumulator
041153 D9          2354  			EXX
041154 7D          2355  			LD      A,L			; A: The start index
041155 D9          2356  			EXX
041156 B7          2357  			OR      A			; If the start index is 0, then we don't need to do the next bit
041157 28 0E       2358  			JR      Z,MIDS1
041159 3D          2359  			DEC     A
04115A 6F          2360  			LD      L,A			; L: The start index - 1
04115B 93          2361  			SUB     E			; Subtract from the string length
04115C 1E 00       2362  			LD      E,0			; Preemptively set the string length to 0
04115E 30 07       2363  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
041160 ED 44       2364  			NEG				; Negate the answer and
041162 4F          2365  			LD      C,A			; C: Number of bytes to copy
041163 CD A6 11 04 2366  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
041167 CD 90 13 04 2367  MIDS1:			CALL    NXT			; Skip whitespace
04116B FE 2C       2368  			CP      ','			; Check for a comma
04116D FD 23       2369  			INC     IY			; Advance to the next character in the BASIC line
04116F 28 0D       2370  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
041171 FD 2B       2371  			DEC     IY			; Restore the BASIC program pointer
041173 CD 4F 13 04 2372  			CALL    BRAKET			; Check for a bracket
041177 3E 80       2373  			LD      A,80H			; String marker
041179 C9          2374  			RET
04117A             2375  ;
04117A             2376  ; LEFT$ - Return left part of string.
04117A             2377  ; Carry cleared if entire string returned.
04117A             2378  ; Result is string.
04117A             2379  ;
04117A CD 3E 13 04 2380  LEFTS:			CALL    EXPRSC			; Get the first string expression
04117E CD D1 12 04 2381  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
041182 CD 27 0C 04 2382  			CALL    EXPRI			; Get the second expression
041186 C1          2383  			POP     BC			; C: String length, B: Value of A before PUSHS was called
041187 CD FE 12 04 2384  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
04118B CD 4F 13 04 2385  			CALL    BRAKET			; Check for closing bracket
04118F D9          2386  			EXX
041190 7D          2387  			LD      A,L			; L: The second parameter
041191 D9          2388  			EXX
041192 BB          2389  			CP      E			; Compare with the string length
041193 30 02       2390  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
041195 6B          2391  			LD      L,E             	; For RIGHTS, no effect in LEFTS
041196 5F          2392  LEFT2:			LD      E,A			; E: The new length of string
041197 3E 80       2393  LEFT3:			LD      A,80H           	; String marker
041199 C9          2394  			RET
04119A             2395  ;
04119A             2396  ; RIGHT$ - Return right part of string.
04119A             2397  ; Result is string.
04119A             2398  ;
04119A CD 7A 11 04 2399  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
04119E D0          2400  			RET     NC			; Do nothing if the second parameter is >= string length
04119F 1C          2401  			INC     E			; Check for a zero length string
0411A0 1D          2402  			DEC     E
0411A1 C8          2403  			RET     Z			; Yes, so do nothing
0411A2 4B          2404  			LD      C,E			;  C: Number of bytes to copy
0411A3 7D          2405  			LD      A,L
0411A4 93          2406  			SUB     E
0411A5 6F          2407  			LD      L,A			;  L: Index into the string
0411A6 79          2408  RIGHT1:			LD	A,C
0411A7 01 00 00 00 2409  			LD	BC,0
0411AB 4F          2410  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
0411AC 7D          2411  			LD	A,L
0411AD 21 00 00 04 2412  			LD	HL,ACCS
0411B1 6F          2413  			LD	L,A			; HL: Source (in ACCS)
0411B2 11 00 00 04 2414  			LD      DE,ACCS			; DE: Destination (start of ACCS)
0411B6 ED B0       2415  			LDIR                    	; Copy
0411B8 3E 80       2416  			LD      A,80H			; String marker
0411BA C9          2417  			RET
0411BB             2418  ;
0411BB             2419  ; STRINGS - Return n concatenations of a string.
0411BB             2420  ; Result is string.
0411BB             2421  ;
0411BB CD 27 0C 04 2422  STRING_:		CALL    EXPRI			; Get number of times to replicate
0411BF CD 42 13 04 2423  			CALL    COMMA			; Check for comma
0411C3 D9          2424  			EXX
0411C4 7D          2425  			LD      A,L			; L: Number of iterations of string
0411C5 D9          2426  			EXX
0411C6 F5          2427  			PUSH    AF
0411C7 CD 32 0C 04 2428  			CALL    EXPRS			; Get the string
0411CB CD 4F 13 04 2429  			CALL    BRAKET			; Check for closing bracket
0411CF F1          2430  			POP     AF			; A: Number of iterations of string
0411D0 B7          2431  			OR      A			; Set flags
0411D1 28 C3       2432  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0411D3 3D          2433  			DEC     A
0411D4 4F          2434  			LD      C,A			; C: Loop counter
0411D5 3E 80       2435  			LD      A,80H			; String marker
0411D7 C8          2436  			RET     Z
0411D8 1C          2437  			INC     E			; Check for empty string
0411D9 1D          2438  			DEC     E
0411DA C8          2439  			RET     Z              		; And return
0411DB 43          2440  			LD      B,E			; B: String length tally
0411DC 21 00 00 04 2441  			LD	HL,ACCS
0411E0 C5          2442  STRIN1:			PUSH    BC
0411E1 7E          2443  STRIN2:			LD      A,(HL)
0411E2 23          2444  			INC     HL
0411E3 12          2445  			LD      (DE),A
0411E4 1C          2446  			INC     E
0411E5 3E 13       2447  			LD      A,19
0411E7 CA 5D 43 04 2448  			JP      Z,ERROR_         	; Throw a "String too long" error
0411EB 10 F4       2449  			DJNZ    STRIN2
0411ED C1          2450  			POP     BC
0411EE 0D          2451  			DEC     C
0411EF 20 EF       2452  			JR      NZ,STRIN1
0411F1 3E 80       2453  			LD      A,80H
0411F3 C9          2454  			RET
0411F4             2455  ;
0411F4             2456  ;SUBROUTINES
0411F4             2457  ;
0411F4             2458  ;SWAP - Swap arguments
0411F4             2459  ;Exchanges DE,HL D'E',H'L' and B,C
0411F4             2460  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0411F4             2461  ;
0411F4 79          2462  SWAP:			LD      A,C
0411F5 48          2463  			LD      C,B
0411F6 47          2464  			LD      B,A
0411F7 EB          2465  			EX      DE,HL
0411F8 D9          2466  			EXX
0411F9 EB          2467  			EX      DE,HL
0411FA D9          2468  			EXX
0411FB C9          2469  			RET
0411FC             2470  ;
0411FC             2471  ;TEST - Test HLH'L' for zero
0411FC             2472  ;Outputs: Z-flag set & A=0 if zero
0411FC             2473  ;Destroys: A,F
0411FC             2474  ;
0411FC 7C          2475  TEST:			LD      A,H
0411FD B5          2476  			OR      L
0411FE D9          2477  			EXX
0411FF B4          2478  			OR      H
041200 B5          2479  			OR      L
041201 D9          2480  			EXX
041202 C9          2481  			RET
041203             2482  ;
041203             2483  ;DECODE - Decode line number in pseudo-binary.
041203             2484  ;   Inputs: IY = Text pointer.
041203             2485  ;   Outputs: HL=0, H'L'=line number, C=0.
041203             2486  ;   Destroys: A,C,H,L,H',L',IY,F
041203             2487  ;
041203 D9          2488  DECODE:			EXX
041204 21 00 00 00 2489  			LD	HL, 0
041208 FD 7E 00    2490  			LD      A,(IY)
04120B FD 23       2491  			INC     IY
04120D 17          2492  			RLA
04120E 17          2493  			RLA
04120F 67          2494  			LD      H,A
041210 E6 C0       2495  			AND     0C0H
041212 FD AE 00    2496  			XOR     (IY)
041215 FD 23       2497  			INC     IY
041217 6F          2498  			LD      L,A
041218 7C          2499  			LD      A,H
041219 17          2500  			RLA
04121A 17          2501  			RLA
04121B E6 C0       2502  			AND     0C0H
04121D FD AE 00    2503  			XOR     (IY)
041220 FD 23       2504  			INC     IY
041222 67          2505  			LD      H,A
041223 D9          2506  			EXX
041224             2507  ;			XOR     A
041224             2508  ;			LD      C,A
041224             2509  ;			LD      H,A
041224             2510  ;			LD      L,A
041224 21 00 00 00 2511  			LD	HL, 0
041228 4D          2512  			LD	C, L
041229 C9          2513  			RET
04122A             2514  ;
04122A             2515  ;HEXSTR - convert numeric value to HEX string.
04122A             2516  ;   Inputs: HLH'L'C = integer or floating-point number
04122A             2517  ;  Outputs: String in string accumulator.
04122A             2518  ;           E = string length.  D = ACCS/256
04122A             2519  ;
04122A FD 23       2520  HEXSTS:			INC     IY              ;SKIP TILDE
04122C CD 3A 0C 04 2521  			CALL    ITEMN
041230 CD 37 12 04 2522  			CALL    HEXSTR
041234 3E 80       2523  			LD      A,80H
041236 C9          2524  			RET
041237             2525  ;
041237 CD 7F 0F 04 2526  HEXSTR:			CALL    SFIX
04123B 01 08 00 00 2527  			LD      BC,8
04123F 11 00 00 04 2528  			LD      DE,ACCS
041243 C5          2529  HEXST1:			PUSH    BC
041244 06 04       2530  			LD      B,4
041246 AF          2531  			XOR     A
041247 D9          2532  HEXST2:			EXX
041248 52 29       2533  			ADD.S	HL,HL
04124A D9          2534  			EXX
04124B 52 ED 6A    2535  			ADC.S	HL,HL
04124E 17          2536  			RLA
04124F 10 F6       2537  			DJNZ    HEXST2
041251 C1          2538  			POP     BC
041252 0D          2539  			DEC     C
041253 F8          2540  			RET     M
041254 28 06       2541  			JR      Z,HEXST3
041256 B7          2542  			OR      A
041257 20 03       2543  			JR      NZ,HEXST3
041259 B8          2544  			CP      B
04125A 28 E7       2545  			JR      Z,HEXST1
04125C C6 90       2546  HEXST3:			ADD     A,90H
04125E 27          2547  			DAA
04125F CE 40       2548  			ADC     A,40H
041261 27          2549  			DAA
041262 12          2550  			LD      (DE),A
041263 13          2551  			INC     DE
041264 47          2552  			LD      B,A
041265 18 DC       2553  			JR      HEXST1
041267             2554  ;
041267             2555  ;Function STR - convert numeric value to ASCII string.
041267             2556  ;   Inputs: HLH'L'C = integer or floating-point number.
041267             2557  ;  Outputs: String in string accumulator.
041267             2558  ;           E = length, D = ACCS/256
041267             2559  ;           A = 80H (type=string)
041267             2560  ;
041267             2561  ;First normalise for decimal output:
041267             2562  ;
041267 CD 90 13 04 2563  STRS:			CALL    NXT
04126B FE 7E       2564  			CP      '~'
04126D 28 BB       2565  			JR      Z,HEXSTS
04126F CD 3A 0C 04 2566  			CALL    ITEMN
041273 DD 21 00 02 2567  			LD      IX,STAVAR
       04          
041278 DD 7E 03    2568  			LD      A,(IX+3)
04127B B7          2569  			OR      A
04127C DD 21 A9 12 2570  			LD      IX,G9-1         ;G9 FORMAT
       04          
041281 28 05       2571  			JR      Z,STR0
041283 DD 21 00 02 2572  STR:			LD      IX,STAVAR
       04          
041288 11 00 00 04 2573  STR0:			LD      DE,ACCS
04128C 3E 25       2574  			LD      A,37
04128E CD 1C 27 04 2575  			CALL    FPP
041292 DA 5D 43 04 2576  			JP      C,ERROR_
041296 DD CB 02 46 2577  			BIT     0,(IX+2)
04129A 3E 80       2578  STR1:			LD      A,80H           ;STRING MARKER
04129C C8          2579  			RET     Z
04129D 79          2580  			LD      A,C
04129E C6 04       2581  			ADD     A,4
0412A0 BB          2582  STR2_eval:			CP      E
0412A1 28 F7       2583  			JR      Z,STR1
0412A3 EB          2584  			EX      DE,HL
0412A4 36 20       2585  			LD      (HL),' '        ;TRAILING SPACE
0412A6 23          2586  			INC     HL
0412A7 EB          2587  			EX      DE,HL
0412A8 18 F6       2588  			JR      STR2_eval
0412AA             2589  ;
0412AA 09 00       2590  G9:			DW    9
0412AC             2591  ;
0412AC             2592  ;STRING COMPARE
0412AC             2593  ;Compare string (DE) length B with string (HL) length C.
0412AC             2594  ;Result preset to false.
0412AC             2595  ;
0412AC CD BA 12 04 2596  SCP:			CALL	SCP0
0412B0             2597  ;
0412B0 3E 00       2598  ZERO:			LD      A,0
0412B2 D9          2599  			EXX
0412B3 67          2600  			LD      H,A
0412B4 6F          2601  			LD      L,A
0412B5 D9          2602  			EXX
0412B6 67          2603  			LD      H,A
0412B7 6F          2604  			LD      L,A
0412B8 4F          2605  			LD      C,A
0412B9 C9          2606  			RET
0412BA             2607  ;
0412BA 04          2608  SCP0:			INC     B
0412BB 0C          2609  			INC     C
0412BC 05          2610  SCP1:			DEC     B
0412BD 28 0A       2611  			JR      Z,SCP2
0412BF 0D          2612  			DEC     C
0412C0 28 0C       2613  			JR      Z,SCP3
0412C2 1A          2614  			LD      A,(DE)
0412C3 BE          2615  			CP      (HL)
0412C4 C0          2616  			RET     NZ
0412C5 13          2617  			INC     DE
0412C6 23          2618  			INC     HL
0412C7 18 F3       2619  			JR      SCP1
0412C9 B7          2620  SCP2:			OR      A
0412CA 0D          2621  			DEC     C
0412CB C8          2622  			RET     Z
0412CC 37          2623  			SCF
0412CD C9          2624  			RET
0412CE B7          2625  SCP3:			OR      A
0412CF 0C          2626  			INC     C
0412D0 C9          2627  			RET
0412D1             2628  ;
0412D1             2629  ; PUSHS - SAVE STRING ON STACK.
0412D1             2630  ;     Inputs: String in string accumulator.
0412D1             2631  ;             E = string length.
0412D1             2632  ;             A - saved on stack.
0412D1             2633  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0412D1             2634  ;
0412D1 CD 99 1F 04 2635  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0412D5 DD E1       2636  			POP     IX              	; IX: Return address
0412D7 B7          2637  			OR      A               	; Clear the carry flag
0412D8 01 00 00 00 2638  			LD	BC,0			; BC: Length of the string
0412DC 4B          2639  			LD	C,E
0412DD 21 00 00 04 2640  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0412E1 11 00 00 04 2641  			LD	DE,ACCS
0412E5 59          2642  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0412E6 ED 52       2643  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0412E8 39          2644  			ADD     HL,SP			; Grow the stack
0412E9 F9          2645  			LD      SP,HL
0412EA 57          2646  			LD      D,A			;  D: This needs to be set to A for some functions
0412EB 47          2647  			LD	B,A			; Stack A and C (the string length)
0412EC C5          2648  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0412ED 06 00       2649  			LD	B,0			; Reset B to 0 for the LDIR in this function
0412EF 28 0B       2650  			JR      Z,PUSHS1        	; Is it zero length?
0412F1 11 00 00 04 2651  			LD      DE,ACCS			; DE: Destination
0412F5 EB          2652  			EX      DE,HL			; HL: Destination, DE: Address on stack
0412F6 ED B0       2653  			LDIR	                    	; Copy to stack
0412F8 CD 99 1F 04 2654  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0412FC DD E9       2655  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0412FE             2656  ;
0412FE             2657  ; POPS - RESTORE STRING FROM STACK.
0412FE             2658  ;     Inputs: C = string length.
0412FE             2659  ;    Outputs: String in string accumulator.
0412FE             2660  ;             E = string length.
0412FE             2661  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0412FE             2662  ;
0412FE DD E1       2663  POPS:			POP     IX              	; IX: Return address
041300 69          2664  			LD	L,C			; Temporarily store string length in L
041301 01 00 00 00 2665  			LD	BC,0
041305 4D          2666  			LD	C,L			; BC: Number of bytes to copy
041306 21 00 00 00 2667  			LD      HL,0			; HL: 0
04130A 39          2668  			ADD     HL,SP			; HL: Stack address
04130B 11 00 00 04 2669  			LD      DE,ACCS			; DE: Destination
04130F 0C          2670  			INC     C			; Quick check to see if this is a zero length string
041310 0D          2671  			DEC     C
041311 28 02       2672  			JR      Z,POPS1         	; Yes it is, so skip
041313 ED B0       2673  			LDIR                    	; No, so copy from the stack
041315 F9          2674  POPS1:			LD      SP,HL			; Shrink the stack
041316 DD E9       2675  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
041318             2676  ;
041318 FD 7E 00    2677  HEXDIG:			LD      A,(IY)
04131B FE 30       2678  			CP      '0'
04131D D8          2679  			RET     C
04131E FE 3A       2680  			CP      '9'+1
041320 3F          2681  			CCF
041321 D0          2682  			RET     NC
041322 FE 41       2683  			CP      'A'
041324 D8          2684  			RET     C
041325 D6 37       2685  			SUB     'A'-10
041327 FE 10       2686  			CP      16
041329 3F          2687  			CCF
04132A C9          2688  			RET
04132B             2689  ;
04132B FD 7E 00    2690  BINDIG:			LD	A,(IY)
04132E FE 30       2691  			CP	'0'
041330 D8          2692  			RET	C
041331 FE 32       2693  			CP	'1'+1
041333 3F          2694  			CCF
041334 C9          2695  			RET
041335             2696  ;
041335 FE 3E       2697  RELOP?:			CP      '>'
041337 D0          2698  			RET     NC
041338 FE 3D       2699  			CP      '='
04133A D0          2700  			RET     NC
04133B FE 3C       2701  			CP      '<'
04133D C9          2702  			RET
04133E             2703  ;
04133E CD 32 0C 04 2704  EXPRSC:			CALL    EXPRS
041342 CD 90 13 04 2705  COMMA:			CALL    NXT
041346 FD 23       2706  			INC     IY
041348 FE 2C       2707  			CP      ','
04134A C8          2708  			RET     Z
04134B 3E 05       2709  			LD      A,5
04134D 18 0B       2710  			JR      ERROR1_eval          ;"Missing ,"
04134F             2711  ;
04134F CD 90 13 04 2712  BRAKET:			CALL    NXT
041353 FD 23       2713  			INC     IY
041355 FE 29       2714  			CP      ')'
041357 C8          2715  			RET     Z
041358 3E 1B       2716  			LD      A,27
04135A C3 5D 43 04 2717  ERROR1_eval:			JP      ERROR_           ;"Missing )"
04135E             2718  ;
04135E FD 23       2719  SAVE_eval:			INC     IY
041360 08          2720  SAVE1:			EX      AF,AF'
041361 FA 53 0C 04 2721  			JP      M,TYPE__eval
041365 08          2722  			EX      AF,AF'
041366 E3          2723  			EX      (SP),HL
041367 D9          2724  			EXX
041368 E5          2725  			PUSH    HL
041369 D9          2726  			EXX
04136A F5          2727  			PUSH    AF
04136B C5          2728  			PUSH    BC
04136C E9          2729  			JP      (HL)
04136D             2730  ;
04136D 08          2731  DOIT:			EX      AF,AF'
04136E FA 53 0C 04 2732  			JP      M,TYPE__eval
041372 D9          2733  			EXX
041373 C1          2734  			POP     BC              ;RETURN ADDRESS
041374 D9          2735  			EXX
041375 79          2736  			LD      A,C
041376 C1          2737  			POP     BC
041377 47          2738  			LD      B,A
041378 F1          2739  			POP     AF              ;OPERATOR
041379 D9          2740  			EXX
04137A EB          2741  			EX      DE,HL
04137B E1          2742  			POP     HL
04137C D9          2743  			EXX
04137D EB          2744  			EX      DE,HL
04137E E1          2745  			POP     HL
04137F D9          2746  			EXX
041380 C5          2747  			PUSH    BC
041381 D9          2748  			EXX
041382 E6 0F       2749  			AND     0FH
041384 CD 1C 27 04 2750  			CALL    FPP
041388 38 D0       2751  			JR      C,ERROR1_eval
04138A AF          2752  			XOR     A
04138B 08          2753  			EX      AF,AF'          ;TYPE
04138C FD 7E 00    2754  			LD      A,(IY)
04138F C9          2755  			RET
041390             2756  ;
041390             2757  ; Skip spaces
041390             2758  ; - IY: String pointer
041390             2759  ; Returns:
041390             2760  ;  - A: The non-space character found
041390             2761  ; - IY: Points to the character before that
041390             2762  ;
041390 FD 7E 00    2763  NXT:			LD      A,(IY)			; Fetch the character
041393 FE 20       2764  			CP      ' '			; If it is space, then return
041395 C0          2765  			RET     NZ
041396 FD 23       2766  			INC     IY			; Increment the pointer and
041398 C3 90 13 04 2767  			JP      NXT			; Loop
04139C             2768  ;
04139C E5          2769  DISPT2:			PUSH    HL
04139D 21 CD 0A 04 2770  			LD      HL,SOPTBL
0413A1 18 07       2771  			JR      DISPT0
0413A3             2772  ;
0413A3 E5          2773  DISPAT_eval:			PUSH    HL
0413A4 D6 8D       2774  			SUB     FUNTOK
0413A6 21 28 0A 04 2775  			LD      HL,FUNTBL
0413AA C5          2776  DISPT0:			PUSH    BC
0413AB             2777  
0413AB 01 03 00 00 2778  			LD	BC, 3
0413AF 47          2779  			LD	B, A
0413B0 ED 4C       2780  			MLT	BC
0413B2 09          2781  			ADD	HL, BC
0413B3 ED 27       2782  			LD	HL, (HL)
0413B5             2783  
0413B5             2784  ;			ADD     A,A
0413B5             2785  ;			LD      C,A
0413B5             2786  ;			LD      B,0
0413B5             2787  ;			ADD     HL,BC
0413B5             2788  ;			LD      A,(HL)
0413B5             2789  ;			INC     HL
0413B5             2790  ;			LD      H,(HL)
0413B5             2791  ;			LD      L,A
0413B5             2792  
0413B5 C1          2793  			POP     BC
0413B6 E3          2794  			EX      (SP),HL
0413B7 C9          2795  			RET                     ;OFF TO ROUTINE
0413B8             2796  
0413B8             2797  
0413B8             2798  ; ========================================
0413B8             2799  ; FROM exec.asm
0413B8             2800  ; ----------------------------------------
0413B8             2801  
0413B8             2802  ;
0413B8             2803  ; Title:	BBC Basic Interpreter - Z80 version
0413B8             2804  ;		Statement Execution & Assembler Module - "EXEC"
0413B8             2805  ; Author:	(C) Copyright  R.T.Russell  1984
0413B8             2806  ; Modified By:	Dean Belfield
0413B8             2807  ; Created:	12/05/2023
0413B8             2808  ; Last Updated:	26/06/2023
0413B8             2809  ;
0413B8             2810  ; Modinfo:
0413B8             2811  ; 27/01/1984:	Version 2.1
0413B8             2812  ; 02/03/1987:	Version 3.0
0413B8             2813  ; 11/06/1987:	Version 3.1
0413B8             2814  ; 12/05/2023:	Modified by Dean Belfield
0413B8             2815  ; 07/06/2023:	Modified to run in ADL mode
0413B8             2816  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
0413B8             2817  
0413B8             2818  			; .ASSUME	ADL = 1
0413B8             2819  
0413B8             2820  			; INCLUDE	"equs.inc"
0413B8             2821  
0413B8             2822  			; SEGMENT CODE
0413B8             2823  
0413B8             2824  ; 			XDEF	XEQ
0413B8             2825  ; 			XDEF	CHAIN0
0413B8             2826  ; 			XDEF	RUN
0413B8             2827  ; 			XDEF	SYNTAX
0413B8             2828  ; 			XDEF	ESCAPE
0413B8             2829  ; 			XDEF	FN
0413B8             2830  ; 			XDEF	USR
0413B8             2831  ; 			XDEF	STORE5
0413B8             2832  ; 			XDEF	STORE4
0413B8             2833  ; 			XDEF	CHECK
0413B8             2834  ; 			XDEF	TERMQ
0413B8             2835  ; 			XDEF	FILL
0413B8             2836  ; 			XDEF	X4OR5
0413B8             2837  ; 			XDEF	MUL16
0413B8             2838  ; 			XDEF	CHANEL
0413B8             2839  ; 			XDEF	ASSEM
0413B8             2840  
0413B8             2841  ; 			XREF	AUTO
0413B8             2842  ; 			XREF	DELETE
0413B8             2843  ; 			XREF	LOAD
0413B8             2844  ; 			XREF	LIST_
0413B8             2845  ; 			XREF	NEW
0413B8             2846  ; 			XREF	OLD
0413B8             2847  ; 			XREF	RENUM
0413B8             2848  ; 			XREF	SAVE
0413B8             2849  ; 			XREF	SOUND
0413B8             2850  ; 			XREF	CLG
0413B8             2851  ; 			XREF	DRAW
0413B8             2852  ; 			XREF	ENVEL
0413B8             2853  ; 			XREF	GCOL
0413B8             2854  ; 			XREF	MODE
0413B8             2855  ; 			XREF	MOVE
0413B8             2856  ; 			XREF	PLOT
0413B8             2857  ; 			XREF	COLOUR
0413B8             2858  ; 			XREF	EXPRS
0413B8             2859  ; 			XREF	HIMEM
0413B8             2860  ; 			XREF	LOAD0
0413B8             2861  ; 			XREF	RANDOM
0413B8             2862  ; 			XREF	CLEAR
0413B8             2863  ; 			XREF	ERRTRP
0413B8             2864  ; 			XREF	PAGE_
0413B8             2865  ; 			XREF	DATAPTR
0413B8             2866  ; 			XREF	ERRLIN
0413B8             2867  ; 			XREF	TRAP
0413B8             2868  ; 			XREF	NXT
0413B8             2869  ; 			XREF	SETLIN
0413B8             2870  ; 			XREF	CLOOP
0413B8             2871  ; 			XREF	OSSHUT
0413B8             2872  ; 			XREF	WARM
0413B8             2873  ; 			XREF	TRACEN
0413B8             2874  ; 			XREF	OUTCHR
0413B8             2875  ; 			XREF	PBCDL
0413B8             2876  ; 			XREF	OSCLI
0413B8             2877  ; 			XREF	LISTON
0413B8             2878  ; 			XREF	GETVAR
0413B8             2879  ; 			XREF	PUTVAR
0413B8             2880  ; 			XREF	DATPTR
0413B8             2881  ; 			XREF	ERROR_
0413B8             2882  ; 			XREF	EXPR
0413B8             2883  ; 			XREF	CREATE
0413B8             2884  ; 			XREF	EXPRI
0413B8             2885  ; 			XREF	BRAKET
0413B8             2886  ; 			XREF	FREE
0413B8             2887  ; 			XREF	OSBPUT
0413B8             2888  ; 			XREF	COUNT
0413B8             2889  ; 			XREF	STR
0413B8             2890  ; 			XREF	HEXSTR
0413B8             2891  ; 			XREF	CRLF
0413B8             2892  ; 			XREF	ITEMI
0413B8             2893  ; 			XREF	FINDL
0413B8             2894  ; 			XREF	TEST
0413B8             2895  ; 			XREF	EXPRN
0413B8             2896  ; 			XREF	DLOAD5
0413B8             2897  ; 			XREF	DLOAD5_SPL
0413B8             2898  ; 			XREF	LOADN
0413B8             2899  ; 			XREF	FPP
0413B8             2900  ; 			XREF	SWAP
0413B8             2901  ; 			XREF	GETDEF
0413B8             2902  ; 			XREF	ZERO
0413B8             2903  ; 			XREF	OSBGET
0413B8             2904  ; 			XREF	BUFFER
0413B8             2905  ; 			XREF	CONS
0413B8             2906  ; 			XREF	VAL0
0413B8             2907  ; 			XREF	OSLINE
0413B8             2908  ; 			XREF	CLRSCN
0413B8             2909  ; 			XREF	TELL
0413B8             2910  ; 			XREF	SAYLN
0413B8             2911  ; 			XREF	REPORT
0413B8             2912  ; 			XREF	PUTPTR
0413B8             2913  ; 			XREF	PUTIME
0413B8             2914  ; 			XREF	PUTIMS
0413B8             2915  ; 			XREF	LOMEM
0413B8             2916  ; 			XREF	WIDTH
0413B8             2917  ; 			XREF	OSWRCH
0413B8             2918  ; 			XREF	COMMA
0413B8             2919  ; 			XREF	OSCALL
0413B8             2920  ; 			XREF	SFIX
0413B8             2921  ; 			XREF	LOAD4
0413B8             2922  ; 			XREF	PUSHS
0413B8             2923  ; 			XREF	POPS
0413B8             2924  ; 			XREF	LOADS
0413B8             2925  ; 			XREF	PUTCSR
0413B8             2926  ; 			XREF	OUT_
0413B8             2927  ; 			XREF	R0
0413B8             2928  ;
0413B8             2929  ; List of token values used in this module
0413B8             2930  ;
0413B8             2931  TAND:			EQU     80H
0413B8             2932  TOR:			EQU     84H
0413B8             2933  TERROR_exec:			EQU     85H
0413B8             2934  LINE__exec:			EQU     86H
0413B8             2935  OFF_:			EQU     87H
0413B8             2936  STEP:			EQU     88H
0413B8             2937  SPC:			EQU     89H
0413B8             2938  TAB:			EQU     8AH
0413B8             2939  ELSE__exec:			EQU     8BH
0413B8             2940  THEN_exec:			EQU     8CH
0413B8             2941  LINO_exec:			EQU     8DH
0413B8             2942  TO_exec:			EQU     B8H
0413B8             2943  TCMD_exec:			EQU     C6H
0413B8             2944  TCALL:			EQU     D6H
0413B8             2945  DATA__exec:			EQU     DCH
0413B8             2946  DEF_:			EQU     DDH
0413B8             2947  TGOSUB:			EQU     E4H
0413B8             2948  TGOTO:			EQU     E5H
0413B8             2949  TON:			EQU     EEH
0413B8             2950  TPROC:			EQU     F2H
0413B8             2951  TSTOP:			EQU     FAH
0413B8             2952  
0413B8             2953  ; The command table
0413B8             2954  ; Commands are tokens from C6H onwards; this lookup table is used to
0413B8             2955  ; run the corresponding function; Note that DATA and DEF both use the same
0413B8             2956  ; code as REM
0413B8             2957  ;
0413B8 E6 42 04    2958  CMDTAB:			DW24  AUTO			; C6H
0413BB 49 41 04    2959  			DW24  DELETE			; C7H
0413BE 27 43 04    2960  			DW24  LOAD			; C8H
0413C1 84 41 04    2961  			DW24  LIST_			; C9H
0413C4 04 43 04    2962  			DW24  NEW			; CAH
0413C7 0A 43 04    2963  			DW24  OLD			; CBH
0413CA 13 42 04    2964  			DW24  RENUM			; CCH
0413CD 38 43 04    2965  			DW24  SAVE			; CDH
0413D0 F2 1E 04    2966  			DW24  PUT			; CEH
0413D3 E8 1C 04    2967  			DW24  PTR_exec			; CFH
0413D6 02 1D 04    2968  			DW24  PAGEV_exec			; D0H
0413D9 15 1D 04    2969  			DW24  TIMEV_exec			; D1H
0413DC 3E 1D 04    2970  			DW24  LOMEMV_exec			; D2H
0413DF 57 1D 04    2971  			DW24  HIMEMV_exec			; D3H
0413E2 6E 07 04    2972  			DW24  SOUND			; D4H
0413E5 0C 1E 04    2973  			DW24  BPUT			; D5H
0413E8 24 1E 04    2974  			DW24  CALL_			; D6H
0413EB 6C 14 04    2975  			DW24  CHAIN			; D7H
0413EE B7 1C 04    2976  			DW24  CLR			; D8H
0413F1 00 1E 04    2977  			DW24  CLOSE			; D9H
0413F4 0A 05 04    2978  			DW24  CLG			; DAH
0413F7 8A 1C 04    2979  			DW24  CLS			; DBH
0413FA 4B 15 04    2980  			DW24  REM_exec             		; DCH: DATA
0413FD 4B 15 04    2981  			DW24  REM_exec             		; DDH: DEF
041400 11 16 04    2982  			DW24  DIM_exec			; DEH
041403 34 07 04    2983  			DW24  DRAW			; DFH
041406 E6 14 04    2984  			DW24  END_			; E0H
041409 A2 1A 04    2985  			DW24  ENDPRO			; E1H
04140C 70 3B 04    2986  			DW24  ENVEL			; E2H
04140F B7 18 04    2987  			DW24  FOR_exec			; E3H
041412 67 18 04    2988  			DW24  GOSUB_exec			; E4H
041415 4B 18 04    2989  			DW24  GOTO_exec			; E5H
041418 C8 06 04    2990  			DW24  GCOL			; E6H
04141B 56 1C 04    2991  			DW24  IF_			; E7H
04141E 44 1B 04    2992  			DW24  INPUT			; E8H
041421 6C 15 04    2993  			DW24  LET			; E9H
041424 47 1A 04    2994  			DW24  LOCAL__exec			; EAH
041427 1A 05 04    2995  			DW24  MODE			; EBH
04142A 2C 07 04    2996  			DW24  MOVE			; ECH
04142D 05 19 04    2997  			DW24  NEXT_exec			; EDH
041430 DE 17 04    2998  			DW24  ON__exec			; EEH
041433 C1 1D 04    2999  			DW24  VDU			; EFH
041436 FA 06 04    3000  			DW24  PLOT			; F0H
041439 E7 16 04    3001  			DW24  PRINT_			; F1H
04143C A4 19 04    3002  			DW24  PROC_exec			; F2H
04143F F6 1B 04    3003  			DW24  READ			; F3H
041442 4B 15 04    3004  			DW24  REM_exec			; F4H
041445 87 18 04    3005  			DW24  REPEAT_exec			; F5H
041448 AF 1C 04    3006  			DW24  REPOR			; F6H
04144B C1 1C 04    3007  			DW24  RESTOR_exec			; F7H
04144E 75 18 04    3008  			DW24  RETURN			; F8H
041451 66 14 04    3009  			DW24  RUN			; F9H
041454 97 1C 04    3010  			DW24  STOP			; FAH
041457 16 06 04    3011  			DW24  COLOUR			; FBH
04145A A3 1D 04    3012  			DW24  TRACE_exec			; FCH
04145D 91 18 04    3013  			DW24  UNTIL_exec			; FDH
041460 95 1D 04    3014  			DW24  WIDTHV			; FEH
041463 31 15 04    3015  			DW24  CLI             		; FFH: OSCLI
041466             3016  
041466             3017  ; RUN
041466             3018  ; RUN "filename"
041466             3019  ;
041466 CD C4 20 04 3020  RUN:			CALL    TERMQ			; Standalone RUN command?
04146A 28 10       3021  			JR      Z,RUN0			; Yes, so just RUN the code
04146C             3022  
04146C             3023  ; CHAIN "filename"
04146C             3024  ;
04146C CD 32 0C 04 3025  CHAIN:			CALL    EXPRS			; Get the filename
041470 3E 0D       3026  			LD      A,CR			; Terminate it with a CR
041472 12          3027  			LD      (DE),A
041473 ED 7B 20 03 3028  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       04          
041478 CD 1C 44 04 3029  			CALL    LOAD0			; And load the file in
04147C             3030  ;
04147C ED 7B 20 03 3031  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       04          
041481 DD 21 38 03 3032  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       04          
041486 ED 5F       3033  @@:			LD      A, R			; Use the R register to seed the random number generator
041488 28 FC       3034  			JR      Z, @B			; Loop unti we get a non-zero value in A
04148A 07          3035  			RLCA				; Rotate it
04148B 07          3036  			RLCA
04148C DD 77 03    3037  			LD      (IX+3),A		; And store
04148F 9F          3038  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
041490 DD 77 04    3039  			LD      (IX+4),A		; And store
041493 CD 73 44 04 3040  			CALL    CLEAR
041497 21 00 00 00 3041  			LD      HL,0			; Clear the error trap sysvar
04149B 22 2C 03 04 3042  			LD      (ERRTRP),HL
04149F 2A 14 03 04 3043  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
0414A3 3E DC       3044  			LD      A,DATA__exec			; The DATA token value
0414A5 CD 98 21 04 3045  			CALL    SEARCH_exec          	; Search for the first DATA token in the tokenised listing
0414A9 22 31 03 04 3046  			LD      (DATPTR),HL     	; Set data pointer
0414AD FD 2A 14 03 3047  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       04          
0414B2             3048  ;
0414B2 CD FA 14 04 3049  XEQ0:			CALL    NEWLIN
0414B6 FD 22 35 03 3050  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       04          
0414BB CD 3D 37 04 3051  			CALL    TRAP           		; Check keyboard
0414BF CD 90 13 04 3052  XEQ1:			CALL    NXT
0414C3 FD 23       3053  			INC     IY
0414C5 FE 3A       3054  			CP      ':'             	; Seperator
0414C7 28 F6       3055  			JR      Z,XEQ1
0414C9 FE 0D       3056  			CP      CR
0414CB 28 E5       3057  			JR      Z,XEQ0          	; New program line
0414CD D6 C6       3058  			SUB     TCMD_exec
0414CF DA 5A 15 04 3059  			JP      C,LET0          	; Implied "LET"
0414D3             3060  
0414D3 01 03 00 00 3061  			LD	BC, 3
0414D7 47          3062  			LD	B, A
0414D8 ED 4C       3063  			MLT	BC
0414DA 21 B8 13 04 3064  			LD	HL,CMDTAB
0414DE 09          3065  			ADD	HL, BC
0414DF ED 27       3066  			LD	HL, (HL)		; Table entry
0414E1             3067  
0414E1             3068  ;			ADD     A,A
0414E1             3069  ;			LD      C,A
0414E1             3070  ;			LD      B,0
0414E1             3071  ;			LD      HL,CMDTAB
0414E1             3072  ;			ADD     HL,BC
0414E1             3073  ;			LD      A,(HL)          	; Table entry
0414E1             3074  ;			INC     HL
0414E1             3075  ;			LD      H,(HL)
0414E1             3076  ;			LD      L,A
0414E1             3077  
0414E1 CD 90 13 04 3078  			CALL    NXT
0414E5 E9          3079  			JP      (HL)            	; Execute the statement
0414E6             3080  
0414E6             3081  ;END
0414E6             3082  ;
0414E6 CD AB 45 04 3083  END_:			CALL    SETLIN          ;FIND CURRENT LINE
0414EA 7C          3084  			LD      A,H
0414EB B5          3085  			OR      L               ;DIRECT?
0414EC CA 45 3C 04 3086  			JP      Z,CLOOP
0414F0 1E 00       3087  			LD      E,0
0414F2 CD 0C 3B 04 3088  			CALL    OSSHUT          ;CLOSE ALL FILES
0414F6 C3 44 3C 04 3089  			JP      WARM            ;"Ready"
0414FA             3090  ;
0414FA FD 7E 00    3091  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
0414FD 01 03 00 00 3092  			LD      BC,3
041501 FD 09       3093  			ADD     IY,BC
041503 B7          3094  			OR      A
041504 28 E0       3095  			JR      Z,END_           ;LENGTH=0, EXIT
041506 2A 26 03 04 3096  			LD      HL,(TRACEN)
04150A 7C          3097  			LD      A,H
04150B B5          3098  			OR      L
04150C C8          3099  			RET     Z
04150D 11 00 00 00 3100  			LD	DE, 0		;Clear DE
041511 FD 56 FF    3101  			LD      D,(IY-1)        ;DE = LINE NUMBER_exec
041514 FD 5E FE    3102  			LD      E,(IY-2)
041517 ED 52       3103  			SBC     HL,DE
041519 D8          3104  			RET     C
04151A EB          3105  			EX      DE,HL
04151B 3E 5B       3106  			LD      A,'['           ;TRACE
04151D CD 4C 45 04 3107  			CALL    OUTCHR
041521 CD F4 45 04 3108  			CALL    PBCDL
041525 3E 5D       3109  			LD      A,']'
041527 CD 4C 45 04 3110  			CALL    OUTCHR
04152B 3E 20       3111  			LD      A,' '
04152D C3 4C 45 04 3112  			JP      OUTCHR
041531             3113  
041531             3114  ; Routines for each statement -------------------------------------------------
041531             3115  
041531             3116  ; OSCLI
041531             3117  ;
041531 CD 32 0C 04 3118  CLI:			CALL    EXPRS
041535 3E 0D       3119  			LD      A,CR
041537 12          3120  			LD      (DE),A
041538 21 00 00 04 3121  			LD      HL,ACCS
04153C CD 60 37 04 3122  			CALL    OSCLI
041540 C3 B6 14 04 3123  			JP      XEQ
041544             3124  
041544             3125  ; REM, *
041544             3126  ;
041544 FD E5       3127  EXT_exec:			PUSH    IY
041546 E1          3128  			POP     HL
041547 CD 60 37 04 3129  			CALL    OSCLI
04154B FD E5       3130  REM_exec:			PUSH    IY
04154D E1          3131  			POP     HL
04154E 3E 0D       3132  			LD      A,CR
041550 47          3133  			LD      B,A
041551 ED B1       3134  			CPIR                    ;FIND LINE END
041553 E5          3135  			PUSH    HL
041554 FD E1       3136  			POP     IY
041556 C3 B2 14 04 3137  			JP      XEQ0
04155A             3138  
04155A             3139  ; [LET] var = expr
04155A             3140  ;
04155A FE C5       3141  LET0:			CP      ELSE__exec-TCMD_exec
04155C 28 ED       3142  			JR      Z,REM_exec
04155E             3143  			; CP      ('*'-TCMD) & 0FFH ; ez80asm doesn't do () in expressions
04155E FE 64       3144  			CP      '*'-TCMD_exec & 0FFH
041560 28 E2       3145  			JR      Z,EXT_exec
041562             3146  			; CP      ('='-TCMD) & 0FFH ; ditto
041562 FE 77       3147  			CP      '='-TCMD_exec & 0FFH
041564 28 5B       3148  			JR      Z,FNEND
041566             3149  			; CP      ('['-TCMD) & 0FFH ; ibid
041566 FE 95       3150  			CP      '['-TCMD_exec & 0FFH
041568 28 25       3151  			JR      Z,ASM
04156A FD 2B       3152  			DEC     IY
04156C CD 08 1F 04 3153  LET:			CALL    ASSIGN			; Assign the variable
041570 CA B6 14 04 3154  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
041574 38 41       3155  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
041576             3156  ;
041576 F5          3157  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
041577 CD DA 20 04 3158  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
04157B E5          3159  			PUSH    HL			; HL: Address of the variable
04157C CD 32 0C 04 3160  			CALL    EXPRS
041580 DD E1       3161  			POP     IX			; IX: Address of the variable
041582 F1          3162  			POP     AF			; AF: The variable type
041583 CD 4A 1F 04 3163  			CALL    STACCS			; Copy the string from ACCS to the variable area
041587 C3 B6 14 04 3164  XEQR:			JP      XEQ
04158B             3165  ;
04158B CD FA 14 04 3166  ASM0:			CALL    NEWLIN
04158F FD 22 35 03 3167  ASM:			LD      (ERRLIN),IY
       04          
041594 CD 3D 37 04 3168  			CALL    TRAP
041598 CD E5 21 04 3169  			CALL    ASSEM
04159C 38 19       3170  			JR      C,SYNTAX
04159E FE 0D       3171  			CP      CR
0415A0 28 E9       3172  			JR      Z,ASM0
0415A2 21 40 03 04 3173  			LD      HL,LISTON
0415A6 7E          3174  			LD      A,(HL)
0415A7 E6 0F       3175  			AND     0FH
0415A9 F6 B0       3176  			OR      B0H
0415AB 77          3177  			LD      (HL),A
0415AC 18 D9       3178  			JR      XEQR
0415AE             3179  ;
0415AE CD 37 46 04 3180  VAR_:			CALL    GETVAR
0415B2 C8          3181  			RET     Z
0415B3 D2 26 46 04 3182  			JP      NC,PUTVAR
0415B7 3E 10       3183  SYNTAX:			LD      A,16            ;"Syntax error"
0415B9 18 02       3184  			JR	ERROR0_exec
0415BB 3E 11       3185  ESCAPE:			LD      A,17            ;"Escape"
0415BD C3 5D 43 04 3186  ERROR0_exec:			JP      ERROR_
0415C1             3187  
0415C1             3188  ; =
0415C1             3189  ;
0415C1 CD DF 0A 04 3190  FNEND:			CALL    EXPR            ;FUNCTION RESULT
0415C5 43          3191  			LD      B,E
0415C6 EB          3192  			EX      DE,HL
0415C7 D9          3193  			EXX                     ;SAVE RESULT
0415C8 EB          3194  			EX      DE,HL           ; IN DEB'C'D'E'
0415C9 C1          3195  FNEND5:			POP     BC
0415CA 21 A2 20 04 3196  			LD      HL,LOCCHK
0415CE B7          3197  			OR      A
0415CF ED 42       3198  			SBC     HL,BC
0415D1 28 1C       3199  			JR      Z,FNEND0        ;LOCAL VARIABLE
0415D3 21 A4 19 04 3200  			LD      HL,FNCHK
0415D7 B7          3201  			OR      A
0415D8 ED 42       3202  			SBC     HL,BC
0415DA 3E 07       3203  			LD      A,7
0415DC 20 DF       3204  			JR      NZ,ERROR0_exec       ;"No FN"
0415DE FD E1       3205  			POP     IY
0415E0 FD 22 35 03 3206  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       04          
0415E5 EB          3207  			EX      DE,HL
0415E6 D9          3208  			EXX
0415E7 EB          3209  			EX      DE,HL
0415E8 11 00 00 04 3210  			LD      DE,ACCS
0415EC 58          3211  			LD      E,B
0415ED 08          3212  			EX      AF,AF'
0415EE C9          3213  			RET
0415EF             3214  ;
0415EF DD E1       3215  FNEND0:			POP     IX
0415F1 C1          3216  			POP     BC
0415F2 78          3217  			LD      A,B
0415F3 B7          3218  			OR      A
0415F4 FA 02 16 04 3219  			JP      M,FNEND1        ;STRING
0415F8 E1          3220  			POP     HL
0415F9 D9          3221  			EXX
0415FA E1          3222  			POP     HL
0415FB D9          3223  			EXX
0415FC CD 20 1F 04 3224  			CALL    STORE
041600 18 C7       3225  			JR      FNEND5
041602 21 00 00 00 3226  FNEND1:			LD      HL,0
041606 39          3227  			ADD     HL,SP
041607 D5          3228  			PUSH    DE
041608 59          3229  			LD      E,C
041609 CD 4E 1F 04 3230  			CALL    STORES
04160D D1          3231  			POP     DE
04160E F9          3232  			LD      SP,HL
04160F 18 B8       3233  			JR      FNEND5
041611             3234  
041611             3235  ; DIM var(dim1[,dim2[,...]])[,var(...]
041611             3236  ; DIM var expr[,var expr...]
041611             3237  ;
041611 CD 37 46 04 3238  DIM_exec:			CALL    GETVAR          	; Get the variable
041615 DA A1 16 04 3239  			JP      C,BADDIM		; Throw a "Bad Dim" error
041619 CA AB 16 04 3240  			JP      Z,DIM4			; If Z then the command is DIM_exec var% expr, so don't need to create an entity
04161D CD AB 47 04 3241  			CALL    CREATE			; Create a new entity
041621 E5          3242  			PUSH    HL			; HL: Address of the entity
041622 DD E1       3243  			POP     IX			; IX: Address of the entity
041624 FD 7E 00    3244  			LD      A,(IY)			; Fetch the next character from the tokenised string
041627 FE 28       3245  			CP      '('			; Check for opening brackets
041629 7A          3246  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
04162A 20 7F       3247  			JR      NZ,DIM4			; It is not a bracket; the command is DIM_exec var expr
04162C             3248  ;
04162C             3249  ; At this point we're reserving a variable array
04162C             3250  ;
04162C E5          3251  			PUSH    HL			; HL: Address of the entity
04162D F5          3252  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
04162E 11 01 00 00 3253  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
041632 42          3254  			LD      B,D			;  B: The number of dimensions in the array
041633             3255  ;
041633 FD 23       3256  DIM1:			INC     IY			; Skip to the next token
041635 C5          3257  			PUSH    BC			; Stack the dimension counter
041636 D5          3258  			PUSH    DE			; Stack the total size of array accumulator
041637 DD E5       3259  			PUSH    IX			; Stack the entity address
041639 CD 27 0C 04 3260  			CALL    EXPRI           	; Fetch the size of this dimension
04163D CB 7C       3261  			BIT     7,H			; If it is negative then
04163F 20 60       3262  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
041641 D9          3263  			EXX
041642 23          3264  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
041643 DD E1       3265  			POP     IX			; IX: The entity address
041645 DD 23       3266  			INC     IX
041647 DD 75 00    3267  			LD      (IX),L          	; Save the size of this dimension in the entity
04164A DD 23       3268  			INC     IX
04164C DD 74 00    3269  			LD      (IX),H
04164F C1          3270  			POP     BC
041650 CD BC 21 04 3271  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
041654 38 4F       3272  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
041656 EB          3273  			EX      DE,HL           	; DE: The new total size of array accumulator
041657 C1          3274  			POP     BC
041658 04          3275  			INC     B               	;  B: The dimension counter; increment
041659 FD 7E 00    3276  			LD      A,(IY)			; Fetch the nex token
04165C FE 2C       3277  			CP      ','             	; Check for another dimension in the array
04165E 28 D3       3278  			JR      Z,DIM1			; And loop
041660             3279  ;
041660 CD 4F 13 04 3280  			CALL    BRAKET          	; Check for closing bracket
041664 F1          3281  			POP     AF              	; Restore the type
041665 DD 23       3282  			INC     IX
041667 DD E3       3283  			EX      (SP),IX
041669 DD 70 00    3284  			LD      (IX),B          	; Number of dimensions
04166C CD AF 21 04 3285  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
041670 E1          3286  			POP     HL			; Restore the entity address
041671 38 32       3287  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
041673             3288  ;
041673             3289  ; We now allocate the memory for the array
041673             3290  ;
041673 19          3291  DIM3:			ADD     HL,DE
041674 38 2F       3292  			JR      C,NOROOM
041676 E5          3293  			PUSH    HL
041677 24          3294  			INC     H
041678 28 2B       3295  			JR      Z,NOROOM
04167A ED 72       3296  			SBC     HL,SP
04167C 30 27       3297  			JR      NC,NOROOM       	; Throw an "Out of Space" error
04167E E1          3298  			POP     HL
04167F 22 1D 03 04 3299  			LD      (FREE),HL
041683 7A          3300  DIM2:			LD      A,D
041684 B3          3301  			OR      E
041685 28 06       3302  			JR      Z,DIM5
041687 2B          3303  			DEC     HL
041688 36 00       3304  			LD      (HL),0         		; Initialise the array
04168A 1B          3305  			DEC     DE
04168B 18 F6       3306  			JR      DIM2
04168D CD 90 13 04 3307  DIM5:			CALL    NXT
041691 FE 2C       3308  			CP      ','            		; Another variable?
041693 C2 B6 14 04 3309  			JP      NZ,XEQ
041697 FD 23       3310  			INC     IY
041699 CD 90 13 04 3311  			CALL    NXT
04169D C3 11 16 04 3312  			JP      DIM_exec
0416A1             3313  ;
0416A1             3314  ; DIM errors
0416A1             3315  ;
0416A1 3E 0A       3316  BADDIM:			LD      A,10            	; Throw a "Bad DIM_exec" error
0416A3 18 02       3317  			JR	ERROR1_exec
0416A5 3E 0B       3318  NOROOM:			LD      A,11            	; Throw a "DIM_exec space" error
0416A7 C3 5D 43 04 3319  ERROR1_exec:			JP      ERROR_
0416AB             3320  ;
0416AB             3321  ; At this point we're reserving a block of memory, i.e.
0416AB             3322  ; DIM var expr[,var expr...]
0416AB             3323  ;
0416AB B7          3324  DIM4:			OR      A			;  A: The dimension variable type
0416AC 28 F3       3325  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
0416AE FA A1 16 04 3326  			JP      M,BADDIM        	; or a string
0416B2 47          3327  			LD      B,A			; Temporarily store the dimension variable type in B
0416B3 FD 7E FF    3328  			LD      A,(IY-1)		; Get the last character but one
0416B6 FE 29       3329  			CP      ')'			; Check if it is a trailing bracket
0416B8 28 E7       3330  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
0416BA             3331  ;
0416BA 21 00 00 00 3332  			LD	HL,0			; Clear HL
0416BE 3A 1D 03 04 3333  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
0416C2 6F          3334  			LD	L,A
0416C3 3A 1E 03 04 3335  			LD	A,(FREE+1)
0416C7 67          3336  			LD	H,A
0416C8 78          3337  			LD	A,B			; Restore the dimension variable type
0416C9 D9          3338  			EXX
0416CA 21 00 00 00 3339  			LD	HL,0			; Clear HL
0416CE 47          3340  			LD	B,A			; Temporarily store the dimension variable type in B
0416CF 3A 1F 03 04 3341  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
0416D3 6F          3342  			LD	L,A
0416D4 78          3343  			LD	A,B			; Restore the dimension variable type
0416D5 4C          3344  			LD	C,H
0416D6 CD 20 1F 04 3345  			CALL    STORE           	; Store the address
0416DA CD 27 0C 04 3346  			CALL    EXPRI			; Get the number of bytes to store
0416DE D9          3347  			EXX
0416DF 23          3348  			INC     HL			; Add one to it
0416E0 EB          3349  			EX      DE,HL
0416E1 2A 1D 03 04 3350  			LD      HL,(FREE)
0416E5 18 8C       3351  			JR      DIM3			; Continue with the DIM_exec
0416E7             3352  
0416E7             3353  ; PRINT list...
0416E7             3354  ; PRINT #channel,list...
0416E7             3355  ;
0416E7 FE 23       3356  PRINT_:			CP      '#'
0416E9 20 7C       3357  			JR      NZ,PRINT0
0416EB CD DC 21 04 3358  			CALL    CHNL            ;CHANNEL NO. = E
0416EF CD 90 13 04 3359  PRNTN1:			CALL    NXT
0416F3 FE 2C       3360  			CP      ','
0416F5 C2 B6 14 04 3361  			JP      NZ,XEQ
0416F9 FD 23       3362  			INC     IY
0416FB D5          3363  			PUSH    DE
0416FC CD DF 0A 04 3364  			CALL    EXPR            ;ITEM TO_exec PRINT
041700 08          3365  			EX      AF,AF'
041701 FA 27 17 04 3366  			JP      M,PRNTN2        ;STRING
041705 D1          3367  			POP     DE
041706 C5          3368  			PUSH    BC
041707 D9          3369  			EXX
041708 7D          3370  			LD      A,L
041709 D9          3371  			EXX
04170A CD 1C 3B 04 3372  			CALL    OSBPUT
04170E D9          3373  			EXX
04170F 7C          3374  			LD      A,H
041710 D9          3375  			EXX
041711 CD 1C 3B 04 3376  			CALL    OSBPUT
041715 7D          3377  			LD      A,L
041716 CD 1C 3B 04 3378  			CALL    OSBPUT
04171A 7C          3379  			LD      A,H
04171B CD 1C 3B 04 3380  			CALL    OSBPUT
04171F C1          3381  			POP     BC
041720 79          3382  			LD      A,C
041721 CD 1C 3B 04 3383  			CALL    OSBPUT
041725 18 C8       3384  			JR      PRNTN1
041727 4B          3385  PRNTN2:			LD      C,E
041728 D1          3386  			POP     DE
041729 21 00 00 04 3387  			LD      HL,ACCS
04172D 0C          3388  			INC     C
04172E 0D          3389  PRNTN3:			DEC     C
04172F 28 0A       3390  			JR      Z,PRNTN4
041731 7E          3391  			LD      A,(HL)
041732 23          3392  			INC     HL
041733 C5          3393  			PUSH    BC
041734 CD 1C 3B 04 3394  			CALL    OSBPUT
041738 C1          3395  			POP     BC
041739 18 F3       3396  			JR      PRNTN3
04173B 3E 0D       3397  PRNTN4:			LD      A,CR
04173D CD 1C 3B 04 3398  			CALL    OSBPUT
041741 18 AC       3399  			JR      PRNTN1
041743             3400  ;
041743 06 02       3401  PRINT6:			LD      B,2
041745 18 27       3402  			JR      PRINTC
041747 01 00 01 00 3403  PRINT8:			LD      BC,100H
04174B 18 21       3404  			JR      PRINTC
04174D 21 00 02 04 3405  PRINT9:			LD      HL,STAVAR
041751 AF          3406  			XOR     A
041752 BE          3407  			CP      (HL)
041753 28 12       3408  			JR      Z,PRINT0
041755 3A 3D 03 04 3409  			LD      A,(COUNT)
041759 B7          3410  			OR      A
04175A 28 0B       3411  			JR      Z,PRINT0
04175C 96          3412  PRINTA:			SUB     (HL)
04175D 28 08       3413  			JR      Z,PRINT0
04175F 30 FB       3414  			JR      NC,PRINTA
041761 ED 44       3415  			NEG
041763 CD 39 21 04 3416  			CALL    FILL
041767 3A 00 02 04 3417  PRINT0:			LD      A,(STAVAR)
04176B 4F          3418  			LD      C,A             ;PRINTS
04176C 06 00       3419  			LD      B,0             ;PRINTF
04176E CD C4 20 04 3420  PRINTC:			CALL    TERMQ
041772 28 3F       3421  			JR      Z,PRINT4
041774 CB 80       3422  			RES     0,B
041776 FD 23       3423  			INC     IY
041778 FE 7E       3424  			CP      '~'
04177A 28 C7       3425  			JR      Z,PRINT6
04177C FE 3B       3426  			CP      ';'
04177E 28 C7       3427  			JR      Z,PRINT8
041780 FE 2C       3428  			CP      ','
041782 28 C9       3429  			JR      Z,PRINT9
041784 CD E9 20 04 3430  			CALL    FORMAT          ;SPC, TAB, '
041788 28 E4       3431  			JR      Z,PRINTC
04178A FD 2B       3432  			DEC     IY
04178C C5          3433  			PUSH    BC
04178D CD DF 0A 04 3434  			CALL    EXPR            ;VARIABLE TYPE
041791 08          3435  			EX      AF,AF'
041792 FA AC 17 04 3436  			JP      M,PRINT3        ;STRING
041796 D1          3437  			POP     DE
041797 D5          3438  			PUSH    DE
041798 CB 4A       3439  			BIT     1,D
04179A F5          3440  			PUSH    AF
04179B CC 83 12 04 3441  			CALL    Z,STR           ;DECIMAL
04179F F1          3442  			POP     AF
0417A0 C4 37 12 04 3443  			CALL    NZ,HEXSTR       ;HEX
0417A4 C1          3444  			POP     BC
0417A5 C5          3445  			PUSH    BC
0417A6 79          3446  			LD      A,C
0417A7 93          3447  			SUB     E
0417A8 D4 39 21 04 3448  			CALL    NC,FILL         ;RIGHT JUSTIFY
0417AC C1          3449  PRINT3:			POP     BC
0417AD CD 48 21 04 3450  			CALL    PTEXT           ;PRINT
0417B1 18 BB       3451  			JR      PRINTC
0417B3 CB 40       3452  PRINT4:			BIT     0,B
0417B5 CC 44 45 04 3453  			CALL    Z,CRLF
0417B9 C3 B6 14 04 3454  			JP      XEQ
0417BD             3455  
0417BD             3456  ; ON ERROR statement [:statement...]
0417BD             3457  ; ON ERROR OFF
0417BD             3458  ;
0417BD FD 23       3459  ONERR:			INC     IY              ;SKIP "ERROR"
0417BF 21 00 00 00 3460  			LD      HL,0
0417C3 22 2C 03 04 3461  			LD      (ERRTRP),HL
0417C7 CD 90 13 04 3462  			CALL    NXT
0417CB FE 87       3463  			CP      OFF_
0417CD FD 23       3464  			INC     IY
0417CF CA B6 14 04 3465  			JP      Z,XEQ
0417D3 FD 2B       3466  			DEC     IY
0417D5 FD 22 2C 03 3467  			LD      (ERRTRP),IY
       04          
0417DA C3 4B 15 04 3468  			JP      REM_exec
0417DE             3469  
0417DE             3470  ; ON expr GOTO line[,line...] [ELSE statement]
0417DE             3471  ; ON expr GOTO line[,line...] [ELSE line]
0417DE             3472  ; ON expr GOSUB line[,line...] [ELSE statement]
0417DE             3473  ; ON expr GOSUB line[,line...] [ELSE line]
0417DE             3474  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
0417DE             3475  ;
0417DE FE 85       3476  ON__exec:			CP      TERROR_exec
0417E0 28 DB       3477  			JR      Z,ONERR         ;"ON ERROR"
0417E2 CD 27 0C 04 3478  			CALL    EXPRI
0417E6 FD 7E 00    3479  			LD      A,(IY)
0417E9 FD 23       3480  			INC     IY
0417EB 1E 2C       3481  			LD      E,','           ;SEPARATOR
0417ED FE E5       3482  			CP      TGOTO
0417EF 28 0B       3483  			JR      Z,ON1
0417F1 FE E4       3484  			CP      TGOSUB
0417F3 28 07       3485  			JR      Z,ON1
0417F5 1E F2       3486  			LD      E,TPROC
0417F7 BB          3487  			CP      E
0417F8 3E 27       3488  			LD      A,39
0417FA 20 45       3489  			JR      NZ,ERROR2_exec       ;"ON syntax"
0417FC 57          3490  ON1:			LD      D,A
0417FD D9          3491  			EXX
0417FE E5          3492  			PUSH    HL
0417FF D9          3493  			EXX
041800 C1          3494  			POP     BC              ;ON INDEX
041801 78          3495  			LD      A,B
041802 B4          3496  			OR      H
041803 B5          3497  			OR      L
041804 20 2A       3498  			JR      NZ,ON4          ;OUT OF RANGE
041806 B1          3499  			OR      C
041807 28 27       3500  			JR      Z,ON4
041809 0D          3501  			DEC     C
04180A 28 0E       3502  			JR      Z,ON3           ;INDEX=1
04180C CD C4 20 04 3503  ON2:			CALL    TERMQ
041810 28 1E       3504  			JR      Z,ON4           ;OUT OF RANGE
041812 FD 23       3505  			INC     IY              ;SKIP DELIMITER
041814 BB          3506  			CP      E
041815 20 F5       3507  			JR      NZ,ON2
041817 0D          3508  			DEC     C
041818 20 F2       3509  			JR      NZ,ON2
04181A 7B          3510  ON3:			LD      A,E
04181B FE F2       3511  			CP      TPROC
04181D 28 26       3512  			JR      Z,ONPROC
04181F D5          3513  			PUSH    DE
041820 CD 42 0C 04 3514  			CALL    ITEMI           ;LINE NUMBER_exec
041824 D1          3515  			POP     DE
041825 7A          3516  			LD      A,D
041826 FE E5       3517  			CP      TGOTO
041828 28 2D       3518  			JR      Z,GOTO2
04182A CD D1 20 04 3519  			CALL    SPAN            ;SKIP REST OF LIST
04182E 18 3B       3520  			JR      GOSUB1
041830             3521  ;
041830 FD 7E 00    3522  ON4:			LD      A,(IY)
041833 FD 23       3523  			INC     IY
041835 FE 8B       3524  			CP      ELSE__exec
041837 CA 6B 1C 04 3525  			JP      Z,IF1           ;ELSE CLAUSE
04183B FE 0D       3526  			CP      CR
04183D 20 F1       3527  			JR      NZ,ON4
04183F 3E 28       3528  			LD      A,40
041841 C3 5D 43 04 3529  ERROR2_exec:			JP      ERROR_           ;"ON range"
041845             3530  ;
041845 3E EE       3531  ONPROC:			LD      A,TON
041847 C3 A4 19 04 3532  			JP      PROC_exec
04184B             3533  
04184B             3534  ; GOTO line
04184B             3535  ;
04184B CD 42 0C 04 3536  GOTO_exec:			CALL    ITEMI           	; Fetch the line number
04184F CD C4 20 04 3537  GOTO1:			CALL    TERMQ			; Check for terminator
041853 C2 B7 15 04 3538  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
041857 D9          3539  GOTO2:			EXX
041858 CD 8C 45 04 3540  			CALL    FINDL			; HL: Line number - Find the line
04185C E5          3541  			PUSH    HL			; HL: Address of the line
04185D FD E1       3542  			POP     IY			; IY = HL
04185F CA B2 14 04 3543  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
041863 3E 29       3544  			LD      A,41			; Otherwise throw a "No such line" error
041865 18 DA       3545  			JR      ERROR2_exec
041867             3546  
041867             3547  ; GOSUB line
041867             3548  ; This pushes the following data onto the execution stack
041867             3549  ; - 3 bytes: Current execution address
041867             3550  ; - 3 bytes: Marker (the address of label GOSCHK)
041867             3551  ;
041867 CD 42 0C 04 3552  GOSUB_exec:			CALL    ITEMI			; Fetch the line number
04186B FD E5       3553  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
04186D CD 99 1F 04 3554  			CALL    CHECK           	; Check there is enough room
041871 CD 4F 18 04 3555  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO_exec the line number
041875             3556  GOSCHK:			EQU     $
041875             3557  
041875             3558  ; RETURN
041875             3559  ; This pops the following data off the execution stack as pushed by GOSUB
041875             3560  ; - 3 bytes: Marker (should be the address of label GOSCHK)
041875             3561  ; - 3 bytes: The return execution address
041875             3562  ;
041875 D1          3563  RETURN:			POP     DE			; Pop the marker off the execution stack
041876 21 75 18 04 3564  			LD      HL,GOSCHK		; Compare with GOSCHK
04187A B7          3565  			OR      A
04187B ED 52       3566  			SBC     HL,DE
04187D FD E1       3567  			POP     IY			; Pop the return address off the execution stack
04187F CA B6 14 04 3568  			JP      Z,XEQ			; Provided this has been called by a GOSUB_exec then continue execution at the return address
041883 3E 26       3569  			LD      A,38			; Otherwise throw a "No GOSUB_exec" error
041885 18 BA       3570  			JR      ERROR2_exec
041887             3571  
041887             3572  ; REPEAT
041887             3573  ; This pushes the following data onto the execution stack
041887             3574  ; - 3 bytes: Current execution address
041887             3575  ; - 3 bytes: Marker (the address of label REPCHK)
041887             3576  ;
041887 FD E5       3577  REPEAT_exec:			PUSH    IY			; Push the current execution address onto the execution stack
041889 CD 99 1F 04 3578  			CALL    CHECK			; Check if there is enough room
04188D CD B6 14 04 3579  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
041891             3580  REPCHK:			EQU     $
041891             3581  
041891             3582  ; UNTIL expr
041891             3583  ; This pops the following data off the execution stack
041891             3584  ; - 3 bytes: Marker (should be the address of label REPCHK)
041891             3585  ; - 3 bytes: The address of the REPEAT instruction
041891             3586  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
041891             3587  ;
041891 C1          3588  UNTIL_exec:			POP     BC			; Fetch the marker
041892 C5          3589  			PUSH    BC			; And push it back onto the execution stack
041893 21 91 18 04 3590  			LD      HL,REPCHK		; Compare with REPCHK
041897 B7          3591  			OR      A
041898 ED 42       3592  			SBC     HL,BC
04189A 3E 2B       3593  			LD      A,43
04189C 20 A3       3594  			JR      NZ,ERROR2_exec		; Throw a "No REPEAT_exec" if this value does not match
04189E CD 27 0C 04 3595  			CALL    EXPRI			; Fetch the expression
0418A2 CD FC 11 04 3596  			CALL    TEST			; Test if the expression evaluates to zero
0418A6 C1          3597  			POP     BC			; Pop the marker
0418A7 D1          3598  			POP     DE			; Pop the address of the REPEAT_exec instruction
0418A8 20 05       3599  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL_exec instruction (we're done looping)
0418AA D5          3600  			PUSH    DE			; Push the address of the REPEAT_exec instruction back on the stack
0418AB C5          3601  			PUSH    BC			; Push the marker back on the stack
0418AC D5          3602  			PUSH    DE			; IY = DE
0418AD FD E1       3603  			POP     IY			; This sets the execution address back to the REPEAT_exec instruction
0418AF C3 B6 14 04 3604  XEQ2:			JP      XEQ			; Continue execution
0418B3             3605  
0418B3             3606  ; FOR var = expr TO expr [STEP expr]
0418B3             3607  ; This pushes the following data onto the execution stack
0418B3             3608  ; - 3 bytes: The limit value
0418B3             3609  ; - 3 bytes: The step value
0418B3             3610  ; - 3 bytes: The current execution address
0418B3             3611  ; - 3 bytes: The address of the loop variable
0418B3             3612  ; - 3 bytes: Marker (the address of FORCHK)
0418B3             3613  ;
0418B3 3E 22       3614  FORVAR:			LD      A,34
0418B5 18 8A       3615  			JR      ERROR2_exec          	; Throw "FOR_exec variable" error
0418B7             3616  ;
0418B7 CD 08 1F 04 3617  FOR_exec:			CALL    ASSIGN			; Assign the START expression value to a variable
0418BB 20 F6       3618  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR_exec variable" error
0418BD F5          3619  			PUSH    AF              	; Save the variable type
0418BE FD 7E 00    3620  			LD      A,(IY)			; Check the next token
0418C1 FE B8       3621  			CP      TO_exec			; Compare with the token value for "TO_exec"
0418C3 3E 24       3622  			LD      A,36			; Set the error code to 36 ("No TO_exec")
0418C5 C2 41 18 04 3623  			JP      NZ,ERROR2_exec       	; And throw the error if that token is missing
0418C9 FD 23       3624  			INC     IY			; Skip to the next token
0418CB             3625  ;
0418CB DD E5       3626  			PUSH    IX
0418CD CD 1F 0C 04 3627  			CALL    EXPRN           	; Fetch the LIMIT expression value
0418D1 DD E1       3628  			POP     IX
0418D3 F1          3629  			POP     AF
0418D4 47          3630  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
0418D5 C5          3631  			PUSH    BC              	; Stack the LIMIT value
0418D6 E5          3632  			PUSH    HL
0418D7 21 00 00 00 3633  			LD      HL,0
0418DB 4C          3634  			LD      C,H
0418DC D9          3635  			EXX
0418DD E5          3636  			PUSH    HL
0418DE             3637  ;
0418DE 21 01 00 00 3638  			LD      HL,1            	; The preset STEP value is 1
0418E2 D9          3639  			EXX
0418E3 FD 7E 00    3640  			LD      A,(IY)			; Fetch the next token
0418E6 FE 88       3641  			CP      STEP			; Compare with the token value for "STEP"
0418E8 20 0A       3642  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
0418EA             3643  ;
0418EA FD 23       3644  			INC     IY			; Skip past the STEP token
0418EC DD E5       3645  			PUSH    IX
0418EE CD 1F 0C 04 3646  			CALL    EXPRN          		; Fetch the STEP expression value
0418F2 DD E1       3647  			POP     IX
0418F4             3648  ;
0418F4 C5          3649  FOR1:			PUSH    BC			; Stack the STEP value
0418F5 E5          3650  			PUSH    HL
0418F6 D9          3651  			EXX
0418F7 E5          3652  			PUSH    HL
0418F8 D9          3653  			EXX
0418F9             3654  ;
0418F9 FD E5       3655  			PUSH    IY              	; Stack the current execution address
0418FB DD E5       3656  			PUSH    IX              	; Stack the loop variable
0418FD CD 99 1F 04 3657  			CALL    CHECK
041901 CD B6 14 04 3658  			CALL    XEQ
041905             3659  FORCHK:			EQU     $
041905             3660  
041905             3661  ; NEXT [var[,var...]]
041905             3662  ; This pops the following data off the execution stack
041905             3663  ; - 3 bytes: Marker (the address of FORCHK)
041905             3664  ; - 3 bytes: The address of the loop variable
041905             3665  ; - 3 bytes: The current execution address
041905             3666  ; - 3 bytes: The step value
041905             3667  ; - 3 bytes: The limit value
041905             3668  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
041905             3669  ;
041905 C1          3670  NEXT_exec:			POP     BC              	; Pop the marker off the execution stack
041906 21 05 19 04 3671  			LD      HL,FORCHK		; Compare with FORCHK
04190A B7          3672  			OR      A
04190B ED 42       3673  			SBC     HL,BC
04190D 3E 20       3674  			LD      A,32
04190F C2 9B 19 04 3675  			JP      NZ,ERROR3_exec      		; If this does not match, throw a "No FOR_exec" error
041913 CD C4 20 04 3676  			CALL    TERMQ			; Check for terminator (a NEXT_exec without a variable)
041917 E1          3677  			POP     HL			; Pop the address of the loop variable off the execution stack
041918 E5          3678  			PUSH    HL			; Push it back onto the execution stack
041919 C5          3679  			PUSH    BC			; Push the marker back onto the execution stack
04191A E5          3680  			PUSH    HL			; HL: Address of the loop variable off the stack
04191B C4 37 46 04 3681  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
04191F D1          3682  			POP     DE			; DE: Address of the loop variable off the stack
041920 EB          3683  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
041921 B7          3684  			OR      A
041922 ED 52       3685  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
041924 20 61       3686  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
041926 D5          3687  			PUSH    DE
041927 DD 21 0C 00 3688  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
04192C DD 39       3689  			ADD     IX,SP
04192E CD 93 30 04 3690  			CALL    DLOAD5_SPL      	; Load the STEP value
041932 DD 7E 10    3691  			LD      A,(IX+16)       	; Get the STEP type
041935 DD E1       3692  			POP     IX
041937 CD 33 0D 04 3693  			CALL    LOADN           	; Load the LOOP variable
04193B CB 7A       3694  			BIT     7,D             	; Check the sign
04193D F5          3695  			PUSH    AF
04193E 3E 0B       3696  			LD      A,'+' & 0FH
041940 CD 1C 27 04 3697  			CALL    FPP             	; Add the STEP
041944 38 55       3698  			JR      C,ERROR3_exec
041946 F1          3699  			POP     AF              	; Restore TYPE
041947 F5          3700  			PUSH    AF
041948 CD 20 1F 04 3701  			CALL    STORE           	; Update the variable
04194C DD 21 15 00 3702  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
041951 DD 39       3703  			ADD     IX,SP
041953 CD 93 30 04 3704  			CALL    DLOAD5_SPL      	; Load the LIMIT value
041957 F1          3705  			POP     AF
041958 CC F4 11 04 3706  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
04195C             3707  			; LD      A,0+('<'-4) & 0FH
04195C 3E 08       3708  			ld a,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
04195E CD 1C 27 04 3709  			CALL    FPP             	; Test against the limit
041962 38 37       3710  			JR      C,ERROR3_exec		; Throw an error if FPP returns bad
041964 24          3711  			INC     H
041965 20 14       3712  			JR      NZ,LOOP_        	; Keep looping
041967 21 1B 00 00 3713  			LD      HL,27			; Adjust the stack
04196B 39          3714  			ADD     HL,SP
04196C F9          3715  			LD      SP,HL
04196D CD 90 13 04 3716  			CALL    NXT
041971 FE 2C       3717  			CP      ','			; Check for multiple variables
041973 C2 B6 14 04 3718  			JP      NZ,XEQ			; No, so we are done at ths point
041977 FD 23       3719  			INC     IY			; Increment to the next variable
041979 18 8A       3720  			JR      NEXT_exec			; And continue
04197B             3721  ;
04197B C1          3722  LOOP_:			POP     BC
04197C D1          3723  			POP     DE
04197D FD E1       3724  			POP     IY
04197F FD E5       3725  			PUSH    IY
041981 D5          3726  			PUSH    DE
041982 C5          3727  			PUSH    BC
041983 C3 B6 14 04 3728  			JP      XEQ
041987             3729  ;
041987 21 1B 00 00 3730  NEXT1:			LD      HL,27			; TODO: What does this do?
04198B 39          3731  			ADD     HL,SP
04198C F9          3732  			LD      SP,HL			; Adjust the stack
04198D C1          3733  			POP     BC
04198E 21 05 19 04 3734  			LD      HL,FORCHK
041992 ED 42       3735  			SBC     HL,BC
041994 E1          3736  			POP     HL              	; Variable pointer
041995 E5          3737  			PUSH    HL
041996 C5          3738  			PUSH    BC
041997 28 89       3739  			JR      Z,NEXT0
041999             3740  ;
041999 3E 21       3741  			LD      A,33
04199B C3 5D 43 04 3742  ERROR3_exec:			JP      ERROR_           	; Throw the error "Can't match FOR_exec"
04199F             3743  
04199F             3744  ; FNname
04199F             3745  ; N.B. ENTERED WITH A <> TON
04199F             3746  ;
04199F F5          3747  FN:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0419A0 CD A9 19 04 3748  			CALL    PROC1
0419A4             3749  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0419A4             3750  
0419A4             3751  ; PROCname
0419A4             3752  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
0419A4             3753  ; This pushes the following data onto the execution stack
0419A4             3754  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
0419A4             3755  ; - 3 bytes: Marker (the address of PROCHK)
0419A4             3756  ;
0419A4 F5          3757  PROC_exec:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0419A5 CD A9 19 04 3758  			CALL    PROC1			; and is also space reserved on the stack for the return address
0419A9             3759  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0419A9             3760  ;
0419A9 CD 99 1F 04 3761  PROC1:			CALL    CHECK			; Check there is space for this
0419AD FD 2B       3762  			DEC     IY			; Decrement IY to the PROC_exec token
0419AF FD E5       3763  			PUSH    IY			; Stack the pointer
0419B1 CD F8 46 04 3764  			CALL    GETDEF			; Search for this PROC_exec/FN entry in the dynamic area
0419B5 C1          3765  			POP     BC			; BC = IY
0419B6 28 41       3766  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0419B8 3E 1E       3767  			LD      A,30
0419BA 38 DF       3768  			JR      C,ERROR3_exec        	; Throw error "Bad call" if invalid PROC_exec/FN call
0419BC             3769  ;
0419BC             3770  ; At this point the PROC/FN has not yet been registered in the dynamic area
0419BC             3771  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0419BC             3772  ;
0419BC C5          3773  			PUSH    BC			; BC: Still pointing to the PROC_exec token in the tokenised line
0419BD 2A 14 03 04 3774  			LD      HL,(PAGE_)		; HL: Start of program memory
0419C1             3775  ;
0419C1 3E DD       3776  PROC2:			LD      A,DEF_			;  A: The token to search for
0419C3 CD 98 21 04 3777  			CALL    SEARCH_exec          	; Look for "DEF" as the first token in a program line
0419C7 38 26       3778  			JR      C,PROC3			; Not found, so jump to PROC3
0419C9 E5          3779  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0419CA FD E1       3780  			POP     IY			; IY = HL
0419CC FD 23       3781  			INC     IY              	; Skip the DEF token
0419CE CD 90 13 04 3782  			CALL    NXT			; And any whitespace
0419D2 CD F8 46 04 3783  			CALL    GETDEF			; Search for this PROC_exec/FN entry in the dynamic area
0419D6 FD E5       3784  			PUSH    IY
0419D8 D1          3785  			POP     DE			; DE: Points to the PROC_exec/FN token in tokenised line of the DEFPROC
0419D9 38 09       3786  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC_exec first)
0419DB C4 AB 47 04 3787  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0419DF FD E5       3788  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0419E1 D1          3789  			POP     DE			; DE = IY
0419E2 ED 1F       3790  			LD	(HL),DE			; Save address
0419E4             3791  ;
0419E4 EB          3792  PROC6:			EX      DE,HL			; HL: Address of the procedure
0419E5 3E 0D       3793  			LD      A,CR			; The character to search for
0419E7 01 00 01 00 3794  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0419EB ED B1       3795  			CPIR                    	; Skip to next line
0419ED 18 D2       3796  			JR      PROC2			; Rinse, lather and repeat
0419EF             3797  ;
0419EF             3798  ; At this point a DEF has not been found for the PROC/FN
0419EF             3799  ;
0419EF FD E1       3800  PROC3:			POP     IY              	; Restore the execution address
0419F1 CD F8 46 04 3801  			CALL    GETDEF			; Search for this PROC_exec/FN entry in the dynamic area
0419F5 3E 1D       3802  			LD      A,29
0419F7 20 A2       3803  			JR      NZ,ERROR3_exec      		; Throw error "No such FN/PROC_exec" if not found
0419F9             3804  ;
0419F9             3805  ; At this point we have a PROC/FN entry in the dynamic area
0419F9             3806  ;
0419F9 ED 17       3807  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0419FB 21 03 00 00 3808  			LD	HL,3
0419FF 39          3809  			ADD     HL,SP
041A00 CD 90 13 04 3810  			CALL    NXT             	; Allow space before "("
041A04 D5          3811  			PUSH    DE              	; Exchange DE and IY
041A05 FD E3       3812  			EX      (SP),IY
041A07 FE 28       3813  			CP      '('             	; Arguments?
041A09 D1          3814  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
041A0A 20 20       3815  			JR      NZ,PROC5
041A0C CD 90 13 04 3816  			CALL    NXT             	; Allow space before "("
041A10 FE 28       3817  			CP      '('
041A12 C2 B7 15 04 3818  			JP      NZ,SYNTAX       	; Throw "Syntax error"
041A16 FD E5       3819  			PUSH    IY
041A18 C1          3820  			POP     BC              	; Save IY in BC
041A19 D9          3821  			EXX
041A1A CD 44 20 04 3822  			CALL    SAVLOC          	; Save local parameters
041A1E CD 4F 13 04 3823  			CALL    BRAKET          	; Closing bracket
041A22 D9          3824  			EXX
041A23 C5          3825  			PUSH    BC
041A24 FD E1       3826  			POP     IY              	; Restore IY
041A26 E5          3827  			PUSH    HL
041A27 CD C0 1F 04 3828  			CALL    ARGUE           	; Transfer arguments
041A2B E1          3829  			POP     HL
041A2C             3830  ;
041A2C 23          3831  PROC5:			INC	HL			; Increment to the ON PROC_exec flag address
041A2D 7E          3832  			LD	A, (HL)			; And fetch the value
041A2E 2B          3833  			DEC 	HL
041A2F ED 1F       3834  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
041A31 FE EE       3835  			CP	TON			; Was it "ON PROC_exec"?
041A33 C2 B6 14 04 3836  			JP	NZ, XEQ			; No, so back to XEQ
041A37 D5          3837  			PUSH    DE			; Exchange DE and IY
041A38 FD E3       3838  			EX      (SP),IY
041A3A CD D1 20 04 3839  			CALL    SPAN            	; Skip rest of ON list
041A3E FD E3       3840  			EX      (SP),IY			; Exchange DE and IY
041A40 D1          3841  			POP     DE
041A41 ED 1F       3842  			LD	(HL), DE		; Save the return address
041A43 C3 B6 14 04 3843  			JP      XEQ
041A47             3844  
041A47             3845  ; LOCAL var[,var...]
041A47             3846  ;
041A47 C1          3847  LOCAL__exec:			POP     BC			; BC: The current check marker (on the stack)
041A48 C5          3848  			PUSH    BC
041A49 21 A4 19 04 3849  			LD      HL,FNCHK		; Check if we are in a FN
041A4D B7          3850  			OR      A
041A4E ED 42       3851  			SBC     HL,BC
041A50 28 16       3852  			JR      Z,LOCAL1		; Yes, so all good, we can use local
041A52 21 A9 19 04 3853  			LD      HL,PROCHK		; Now check if we are in a PROC_exec
041A56 B7          3854  			OR      A
041A57 ED 42       3855  			SBC     HL,BC
041A59 28 0D       3856  			JR      Z,LOCAL1		; Again, all good, we can use local
041A5B 21 A2 20 04 3857  			LD      HL,LOCCHK		; Finally check for the local parameters marker
041A5F B7          3858  			OR      A
041A60 ED 42       3859  			SBC     HL,BC			; If it is not present, then
041A62 3E 0C       3860  			LD      A,12
041A64 C2 5D 43 04 3861  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
041A68             3862  ;
041A68             3863  ; At this point we are adding a local variable into a PROC or FN
041A68             3864  ;
041A68 FD E5       3865  LOCAL1:			PUSH    IY			; IY: BASIC pointer
041A6A C1          3866  			POP     BC			; BC: Copy of the BASIC pointer
041A6B D9          3867  			EXX
041A6C FD 2B       3868  			DEC     IY
041A6E CD 44 20 04 3869  			CALL    SAVLOC
041A72 D9          3870  			EXX
041A73 C5          3871  			PUSH    BC
041A74 FD E1       3872  			POP     IY
041A76             3873  ;
041A76 CD 37 46 04 3874  LOCAL2:			CALL    GETVAR			; Get the variable location
041A7A C2 B7 15 04 3875  			JP      NZ,SYNTAX
041A7E B7          3876  			OR      A               	; Check the variable type (80h = string)
041A7F 08          3877  			EX      AF,AF'
041A80 CD B0 12 04 3878  			CALL    ZERO			; Zero the variable anyway
041A84 08          3879  			EX      AF,AF'
041A85 F5          3880  			PUSH    AF
041A86 F4 20 1F 04 3881  			CALL    P,STORE         	; Call STORE if it is not a string
041A8A F1          3882  			POP     AF
041A8B 59          3883  			LD      E,C
041A8C FC 4E 1F 04 3884  			CALL    M,STORES		; Call STORES if it is a string
041A90 CD 90 13 04 3885  			CALL    NXT			; Skip to the next character in the expression
041A94 FE 2C       3886  			CP      ','			; Is it a comma?
041A96 C2 B6 14 04 3887  			JP      NZ,XEQ			; No, so we're done, carry on executing
041A9A FD 23       3888  			INC     IY			; Yes, so skip the comma
041A9C CD 90 13 04 3889  			CALL    NXT			; And any whitespace
041AA0 18 D4       3890  			JR      LOCAL2			; Then loop back and handle any further local variables
041AA2             3891  
041AA2             3892  ; ENDPROC
041AA2             3893  ;
041AA2 C1          3894  ENDPRO:			POP     BC			; Pop the check value off the stack
041AA3 21 A2 20 04 3895  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
041AA7 B7          3896  			OR      A
041AA8 ED 42       3897  			SBC     HL,BC
041AAA 28 13       3898  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
041AAC             3899  ;
041AAC 21 A9 19 04 3900  			LD      HL,PROCHK       	; Check if it is the PROC_exec marker
041AB0 B7          3901  			OR      A
041AB1 ED 42       3902  			SBC     HL,BC
041AB3 FD E1       3903  			POP     IY
041AB5 CA B6 14 04 3904  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
041AB9 3E 0D       3905  			LD      A,13			; Otherwise throw the "No PROC_exec" error
041ABB C3 5D 43 04 3906  			JP      ERROR_
041ABF             3907  ;
041ABF DD E1       3908  UNSTK:			POP     IX			; Unstack a single local variable
041AC1 C1          3909  			POP     BC
041AC2 78          3910  			LD      A,B
041AC3 B7          3911  			OR      A
041AC4 FA D2 1A 04 3912  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
041AC8 E1          3913  			POP     HL			; Unstack a normal variable
041AC9 D9          3914  			EXX
041ACA E1          3915  			POP     HL
041ACB D9          3916  			EXX
041ACC CD 20 1F 04 3917  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
041AD0 18 D0       3918  			JR      ENDPRO			; And loop back to ENDPRO
041AD2             3919  ;
041AD2 21 00 00 00 3920  UNSTK1:			LD      HL,0			; Unstack a string
041AD6 39          3921  			ADD     HL,SP
041AD7 59          3922  			LD      E,C
041AD8 CD 4E 1F 04 3923  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
041ADC F9          3924  			LD      SP,HL
041ADD 18 C3       3925  			JR      ENDPRO
041ADF             3926  
041ADF             3927  ; INPUT #channel,var,var...
041ADF             3928  ;
041ADF CD DC 21 04 3929  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER_exec
041AE3 CD 90 13 04 3930  INPN1:			CALL    NXT
041AE7 FE 2C       3931  			CP      ','
041AE9 C2 B6 14 04 3932  			JP      NZ,XEQ
041AED FD 23       3933  			INC     IY
041AEF CD 90 13 04 3934  			CALL    NXT
041AF3 D5          3935  			PUSH    DE
041AF4 CD AE 15 04 3936  			CALL    VAR_
041AF8 D1          3937  			POP     DE
041AF9 F5          3938  			PUSH    AF              ;SAVE TYPE
041AFA E5          3939  			PUSH    HL              ;VARPTR
041AFB B7          3940  			OR      A
041AFC FA 28 1B 04 3941  			JP      M,INPN2         ;STRING
041B00 CD 14 3B 04 3942  			CALL    OSBGET
041B04 D9          3943  			EXX
041B05 6F          3944  			LD      L,A
041B06 D9          3945  			EXX
041B07 CD 14 3B 04 3946  			CALL    OSBGET
041B0B D9          3947  			EXX
041B0C 67          3948  			LD      H,A
041B0D D9          3949  			EXX
041B0E CD 14 3B 04 3950  			CALL    OSBGET
041B12 6F          3951  			LD      L,A
041B13 CD 14 3B 04 3952  			CALL    OSBGET
041B17 67          3953  			LD      H,A
041B18 CD 14 3B 04 3954  			CALL    OSBGET
041B1C 4F          3955  			LD      C,A
041B1D DD E1       3956  			POP     IX
041B1F F1          3957  			POP     AF              ;RESTORE TYPE
041B20 D5          3958  			PUSH    DE              ;SAVE CHANNEL
041B21 CD 20 1F 04 3959  			CALL    STORE
041B25 D1          3960  			POP     DE
041B26 18 BB       3961  			JR      INPN1
041B28 21 00 00 04 3962  INPN2:			LD      HL,ACCS
041B2C CD 14 3B 04 3963  INPN3:			CALL    OSBGET
041B30 FE 0D       3964  			CP      CR
041B32 28 04       3965  			JR      Z,INPN4
041B34 77          3966  			LD      (HL),A
041B35 2C          3967  			INC     L
041B36 20 F4       3968  			JR      NZ,INPN3
041B38 DD E1       3969  INPN4:			POP     IX
041B3A F1          3970  			POP     AF
041B3B D5          3971  			PUSH    DE
041B3C EB          3972  			EX      DE,HL
041B3D CD 4A 1F 04 3973  			CALL    STACCS
041B41 D1          3974  			POP     DE
041B42 18 9F       3975  			JR      INPN1
041B44             3976  
041B44             3977  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041B44             3978  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
041B44             3979  ;
041B44 FE 23       3980  INPUT:			CP      '#'
041B46 28 97       3981  			JR      Z,INPUTN
041B48 0E 00       3982  			LD      C,0             ;FLAG PROMPT
041B4A FE 86       3983  			CP      LINE__exec
041B4C 20 04       3984  			JR      NZ,INPUT0
041B4E FD 23       3985  			INC     IY              ;SKIP "LINE"
041B50 0E 80       3986  			LD      C,80H
041B52 21 00 01 04 3987  INPUT0:			LD      HL,BUFFER
041B56 36 0D       3988  			LD      (HL),CR         ;INITIALISE EMPTY
041B58 CD C4 20 04 3989  INPUT1:			CALL    TERMQ
041B5C CA B6 14 04 3990  			JP      Z,XEQ           ;DONE
041B60 FD 23       3991  			INC     IY
041B62 FE 2C       3992  			CP      ','
041B64 28 5C       3993  			JR      Z,INPUT3        ;SKIP COMMA
041B66 FE 3B       3994  			CP      ';'
041B68 28 58       3995  			JR      Z,INPUT3
041B6A E5          3996  			PUSH    HL              ;SAVE BUFFER POINTER
041B6B FE 22       3997  			CP      34		;ASCII ""
041B6D 20 0C       3998  			JR      NZ,INPUT6
041B6F C5          3999  			PUSH    BC
041B70 CD 84 0D 04 4000  			CALL    CONS
041B74 C1          4001  			POP     BC
041B75 CD 48 21 04 4002  			CALL    PTEXT           ;PRINT PROMPT
041B79 18 06       4003  			JR      INPUT9
041B7B CD E9 20 04 4004  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
041B7F 20 05       4005  			JR      NZ,INPUT2
041B81 E1          4006  INPUT9:			POP     HL
041B82 CB C1       4007  			SET     0,C             ;FLAG NO PROMPT
041B84 18 CC       4008  			JR      INPUT0
041B86 FD 2B       4009  INPUT2:			DEC     IY
041B88 C5          4010  			PUSH    BC
041B89 CD AE 15 04 4011  			CALL    VAR_
041B8D C1          4012  			POP     BC
041B8E E1          4013  			POP     HL
041B8F F5          4014  			PUSH    AF              ;SAVE TYPE
041B90 7E          4015  			LD      A,(HL)
041B91 23          4016  			INC     HL
041B92 FE 0D       4017  			CP      CR              ;BUFFER EMPTY?
041B94 CC C6 1B 04 4018  			CALL    Z,REFILL
041B98 CB 79       4019  			BIT     7,C
041B9A F5          4020  			PUSH    AF
041B9B C4 6A 21 04 4021  			CALL    NZ,LINES
041B9F F1          4022  			POP     AF
041BA0 CC 57 21 04 4023  			CALL    Z,FETCHS
041BA4 F1          4024  			POP     AF              ;RESTORE TYPE
041BA5 C5          4025  			PUSH    BC
041BA6 E5          4026  			PUSH    HL
041BA7 B7          4027  			OR      A
041BA8 FA BC 1B 04 4028  			JP      M,INPUT4        ;STRING
041BAC F5          4029  			PUSH    AF
041BAD DD E5       4030  			PUSH    IX
041BAF CD 8B 0F 04 4031  			CALL    VAL0
041BB3 DD E1       4032  			POP     IX
041BB5 F1          4033  			POP     AF
041BB6 CD 20 1F 04 4034  			CALL    STORE
041BBA 18 04       4035  			JR      INPUT5
041BBC CD 4A 1F 04 4036  INPUT4:			CALL    STACCS
041BC0 E1          4037  INPUT5:			POP     HL
041BC1 C1          4038  			POP     BC
041BC2 CB 81       4039  INPUT3:			RES     0,C
041BC4 18 92       4040  			JR      INPUT1
041BC6             4041  ;
041BC6 CB 41       4042  REFILL:			BIT     0,C
041BC8 20 0C       4043  			JR      NZ,REFIL0       ;NO PROMPT
041BCA 3E 3F       4044  			LD      A,'?'
041BCC CD 4C 45 04 4045  			CALL    OUTCHR          ;PROMPT
041BD0 3E 20       4046  			LD      A,' '
041BD2 CD 4C 45 04 4047  			CALL    OUTCHR
041BD6 21 00 01 04 4048  REFIL0:			LD      HL,BUFFER
041BDA C5          4049  			PUSH    BC
041BDB E5          4050  			PUSH    HL
041BDC DD E5       4051  			PUSH    IX
041BDE CD 2F 36 04 4052  			CALL    OSLINE
041BE2 DD E1       4053  			POP     IX
041BE4 E1          4054  			POP     HL
041BE5 C1          4055  			POP     BC
041BE6 47          4056  			LD      B,A             ;POS AT ENTRY
041BE7 AF          4057  			XOR     A
041BE8 32 3D 03 04 4058  			LD      (COUNT),A
041BEC B8          4059  			CP      B
041BED C8          4060  			RET     Z
041BEE 7E          4061  REFIL1:			LD      A,(HL)
041BEF FE 0D       4062  			CP      CR
041BF1 C8          4063  			RET     Z
041BF2 23          4064  			INC     HL
041BF3 10 F9       4065  			DJNZ    REFIL1
041BF5 C9          4066  			RET
041BF6             4067  
041BF6             4068  ; READ var[,var...]
041BF6             4069  ;
041BF6 FE 23       4070  READ:			CP      '#'
041BF8 CA DF 1A 04 4071  			JP      Z,INPUTN
041BFC 2A 31 03 04 4072  			LD      HL,(DATPTR)
041C00 7E          4073  READ0:			LD      A,(HL)
041C01 23          4074  			INC     HL              ;SKIP COMMA OR "DATA"
041C02 FE 0D       4075  			CP      CR              ;END OF DATA STMT?
041C04 CC 48 1C 04 4076  			CALL    Z,GETDAT
041C08 E5          4077  			PUSH    HL
041C09 CD AE 15 04 4078  			CALL    VAR_
041C0D E1          4079  			POP     HL
041C0E B7          4080  			OR      A
041C0F FA 28 1C 04 4081  			JP      M,READ1         ;STRING
041C13 E5          4082  			PUSH    HL
041C14 FD E3       4083  			EX      (SP),IY
041C16 F5          4084  			PUSH    AF              ;SAVE TYPE
041C17 DD E5       4085  			PUSH    IX
041C19 CD 1F 0C 04 4086  			CALL    EXPRN
041C1D DD E1       4087  			POP     IX
041C1F F1          4088  			POP     AF
041C20 CD 20 1F 04 4089  			CALL    STORE
041C24 FD E3       4090  			EX      (SP),IY
041C26 18 09       4091  			JR      READ2
041C28 CD 57 21 04 4092  READ1:			CALL    FETCHS
041C2C E5          4093  			PUSH    HL
041C2D CD 4A 1F 04 4094  			CALL    STACCS
041C31 E1          4095  READ2:			POP     HL
041C32 22 31 03 04 4096  			LD      (DATPTR),HL
041C36 CD 90 13 04 4097  			CALL    NXT
041C3A FE 2C       4098  			CP      ','
041C3C C2 B6 14 04 4099  			JP      NZ,XEQ
041C40 FD 23       4100  			INC     IY
041C42 CD 90 13 04 4101  			CALL    NXT
041C46 18 B8       4102  			JR      READ0
041C48             4103  ;
041C48 3E DC       4104  GETDAT:			LD      A,DATA__exec
041C4A CD 98 21 04 4105  			CALL    SEARCH_exec
041C4E 23          4106  			INC     HL
041C4F D0          4107  			RET     NC
041C50 3E 2A       4108  			LD      A,42
041C52 C3 5D 43 04 4109  ERROR4:			JP      ERROR_           ;"Out of DATA"
041C56             4110  
041C56             4111  ; IF expr statement
041C56             4112  ; IF expr THEN statement [ELSE statement]
041C56             4113  ; IF expr THEN line [ELSE line]
041C56             4114  ;
041C56 CD 27 0C 04 4115  IF_:			CALL    EXPRI
041C5A CD FC 11 04 4116  			CALL    TEST
041C5E 28 19       4117  			JR      Z,IFNOT         ;FALSE
041C60 FD 7E 00    4118  			LD      A,(IY)
041C63 FE 8C       4119  			CP      THEN_exec
041C65 C2 B6 14 04 4120  			JP      NZ,XEQ
041C69 FD 23       4121  			INC     IY              ;SKIP "THEN_exec"
041C6B CD 90 13 04 4122  IF1:			CALL    NXT
041C6F FE 8D       4123  			CP      LINO_exec
041C71 C2 B6 14 04 4124  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
041C75 C3 4B 18 04 4125  			JP      GOTO_exec            ;LINE NO. FOLLOWS
041C79 FD 7E 00    4126  IFNOT:			LD      A,(IY)
041C7C FE 0D       4127  			CP      CR
041C7E FD 23       4128  			INC     IY
041C80 CA B2 14 04 4129  			JP      Z,XEQ0          ;END OF LINE
041C84 FE 8B       4130  			CP      ELSE__exec
041C86 20 F1       4131  			JR      NZ,IFNOT
041C88 18 E1       4132  			JR      IF1
041C8A             4133  
041C8A             4134  ; CLS
041C8A             4135  ;
041C8A CD 14 05 04 4136  CLS:		CALL    CLRSCN
041C8E AF          4137  			XOR     A
041C8F 32 3D 03 04 4138  			LD      (COUNT),A
041C93 C3 B6 14 04 4139  			JP      XEQ
041C97             4140  
041C97             4141  ; STOP
041C97             4142  ;
041C97 CD 8D 49 04 4143  STOP:			CALL    TELL
041C9B 0D          4144  			DB	CR
041C9C 0A          4145  			DB	LF
041C9D FA          4146  			DB	TSTOP
041C9E 00          4147  			DB	0
041C9F CD AB 45 04 4148  			CALL    SETLIN          ;FIND CURRENT LINE
041CA3 CD DF 45 04 4149  			CALL    SAYLN
041CA7 CD 44 45 04 4150  			CALL    CRLF
041CAB C3 45 3C 04 4151  			JP      CLOOP
041CAF             4152  
041CAF             4153  ; REPORT
041CAF             4154  ;
041CAF CD 7F 49 04 4155  REPOR:			CALL    REPORT
041CB3 C3 B6 14 04 4156  			JP      XEQ
041CB7             4157  
041CB7             4158  ; CLEAR
041CB7             4159  ;
041CB7 CD 73 44 04 4160  CLR:			CALL    CLEAR
041CBB 2A 14 03 04 4161  			LD      HL,(PAGE_)
041CBF 18 19       4162  			JR      RESTR1
041CC1             4163  
041CC1             4164  ; RESTORE [line]
041CC1             4165  ;
041CC1 2A 14 03 04 4166  RESTOR_exec:			LD      HL,(PAGE_)
041CC5 CD C4 20 04 4167  			CALL    TERMQ
041CC9 28 0F       4168  			JR      Z,RESTR1
041CCB CD 42 0C 04 4169  			CALL    ITEMI
041CCF D9          4170  			EXX
041CD0 CD 8C 45 04 4171  			CALL    FINDL           ;SEARCH FOR_exec LINE
041CD4 3E 29       4172  			LD      A,41
041CD6 C2 52 1C 04 4173  			JP      NZ,ERROR4       ;"No such line"
041CDA 3E DC       4174  RESTR1:			LD      A,DATA__exec
041CDC CD 98 21 04 4175  			CALL    SEARCH_exec
041CE0 22 31 03 04 4176  			LD      (DATPTR),HL
041CE4 C3 B6 14 04 4177  			JP      XEQ
041CE8             4178  
041CE8             4179  ; PTR#channel=expr
041CE8             4180  ; PAGE=expr
041CE8             4181  ; TIME=expr
041CE8             4182  ; LOMEM=expr
041CE8             4183  ; HIMEM=expr
041CE8             4184  ;
041CE8 CD D0 21 04 4185  PTR_exec:			CALL    CHANEL
041CEC CD DA 20 04 4186  			CALL    EQUALS
041CF0 7B          4187  			LD      A,E
041CF1 F5          4188  			PUSH    AF
041CF2 CD 27 0C 04 4189  			CALL    EXPRI
041CF6 E5          4190  			PUSH    HL
041CF7 D9          4191  			EXX
041CF8 D1          4192  			POP     DE
041CF9 F1          4193  			POP     AF
041CFA CD 34 3B 04 4194  			CALL    PUTPTR
041CFE C3 B6 14 04 4195  			JP      XEQ
041D02             4196  ;
041D02 CD DA 20 04 4197  PAGEV_exec:			CALL    EQUALS
041D06 CD 27 0C 04 4198  			CALL    EXPRI
041D0A D9          4199  			EXX
041D0B 2E 00       4200  			LD      L,0
041D0D 22 14 03 04 4201  			LD      (PAGE_),HL
041D11 C3 B6 14 04 4202  			JP      XEQ
041D15             4203  ;
041D15 FE 24       4204  TIMEV_exec:			CP      '$'
041D17 28 13       4205  			JR      Z,TIMEVS_exec
041D19 CD DA 20 04 4206  			CALL    EQUALS
041D1D CD 27 0C 04 4207  			CALL    EXPRI
041D21 E5          4208  			PUSH    HL
041D22 D9          4209  			EXX
041D23 D1          4210  			POP     DE
041D24 CD 67 36 04 4211  			CALL    PUTIME
041D28 C3 B6 14 04 4212  			JP      XEQ
041D2C             4213  ;
041D2C FD 23       4214  TIMEVS_exec:			INC     IY              ;SKIP '$'
041D2E CD DA 20 04 4215  			CALL    EQUALS
041D32 CD 32 0C 04 4216  			CALL    EXPRS
041D36 CD 70 3B 04 4217  			CALL    PUTIMS
041D3A C3 B6 14 04 4218  			JP      XEQ
041D3E             4219  ;
041D3E CD DA 20 04 4220  LOMEMV_exec:			CALL    EQUALS
041D42 CD 27 0C 04 4221  			CALL    EXPRI
041D46 CD 73 44 04 4222  			CALL    CLEAR
041D4A D9          4223  			EXX
041D4B 22 1A 03 04 4224  			LD      (LOMEM),HL
041D4F 22 1D 03 04 4225  			LD      (FREE),HL
041D53 C3 B6 14 04 4226  			JP      XEQ
041D57             4227  ;
041D57 CD DA 20 04 4228  HIMEMV_exec:			CALL    EQUALS			; Check for '=' and throw an error if not found
041D5B CD 27 0C 04 4229  			CALL    EXPRI			; Load the expression into registers
041D5F 7D          4230  			LD	A,L			;  A: The MSB of the 24-bit value
041D60 D9          4231  			EXX				; HL: The LSW of the 24-bit value
041D61 22 4A 03 04 4232  			LD	(R0),HL
041D65 32 4C 03 04 4233  			LD	(R0+2),A
041D69 2A 1D 03 04 4234  			LD	HL,(FREE)
041D6D 11 00 01 00 4235  			LD      DE,256
041D71 19          4236  			ADD	HL,DE
041D72 EB          4237  			EX	DE,HL			; DE: FREE + 256
041D73 2A 4A 03 04 4238  			LD	HL,(R0)			; HL: The passed expression
041D77 AF          4239  			XOR     A
041D78 ED 52       4240  			SBC     HL,DE
041D7A 19          4241  			ADD     HL,DE			; Do a bounds check
041D7B DA 5D 43 04 4242  			JP      C,ERROR_         	; Throw the error: "No room"
041D7F ED 5B 20 03 4243  			LD      DE,(HIMEM)
       04          
041D84 22 20 03 04 4244  			LD      (HIMEM),HL
041D88 EB          4245  			EX      DE,HL
041D89 ED 72       4246  			SBC     HL,SP			; Adjust the stack
041D8B C2 B6 14 04 4247  			JP      NZ,XEQ
041D8F EB          4248  			EX      DE,HL
041D90 F9          4249  			LD      SP,HL           	; Load the SP
041D91 C3 B6 14 04 4250  			JP      XEQ
041D95             4251  
041D95             4252  ; WIDTH expr
041D95             4253  ;
041D95 CD 27 0C 04 4254  WIDTHV:			CALL    EXPRI
041D99 D9          4255  			EXX
041D9A 7D          4256  			LD      A,L
041D9B 32 3E 03 04 4257  			LD      (WIDTH),A
041D9F C3 B6 14 04 4258  			JP      XEQ
041DA3             4259  
041DA3             4260  ; TRACE ON
041DA3             4261  ; TRACE OFF
041DA3             4262  ; TRACE line
041DA3             4263  ;
041DA3 FD 23       4264  TRACE_exec:			INC     IY
041DA5 21 00 00 00 4265  			LD      HL,0
041DA9 FE EE       4266  			CP      TON
041DAB 28 0B       4267  			JR      Z,TRACE0
041DAD FE 87       4268  			CP      OFF_
041DAF 28 08       4269  			JR      Z,TRACE1
041DB1 FD 2B       4270  			DEC     IY
041DB3 CD 27 0C 04 4271  			CALL    EXPRI
041DB7 D9          4272  			EXX
041DB8 2B          4273  TRACE0:			DEC     HL
041DB9 22 26 03 04 4274  TRACE1:			LD      (TRACEN),HL
041DBD C3 B6 14 04 4275  			JP      XEQ
041DC1             4276  
041DC1             4277  ; VDU expr,expr;....
041DC1             4278  ;
041DC1 DD 21 00 01 4279  VDU:			LD	IX,BUFFER		; Storage for the VDU stream
       04          
041DC6 DD E5       4280  VDU1:			PUSH	IX
041DC8 CD 27 0C 04 4281  			CALL    EXPRI			; Fetch the VDU character
041DCC DD E1       4282  			POP	IX
041DCE D9          4283  			EXX
041DCF DD 75 00    4284  			LD	(IX+0),L		; Write out the character to the buffer
041DD2 DD 23       4285  			INC	IX
041DD4 FD 7E 00    4286  			LD      A,(IY)			;  A: The separator character
041DD7 FE 2C       4287  			CP      ','			; Is it a comma?
041DD9 28 09       4288  			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
041DDB FE 3B       4289  			CP      ';'			; Is it a semicolon?
041DDD 20 07       4290  			JR      NZ,VDU3			; No, so skip to the next expression
041DDF DD 74 00    4291  			LD	(IX+0),H		; Write out the high byte to the buffer
041DE2 DD 23       4292  			INC	IX
041DE4 FD 23       4293  VDU2:			INC     IY			; Skip to the next character
041DE6 CD C4 20 04 4294  VDU3:			CALL    TERMQ			; Skip past white space
041DEA 20 DA       4295  			JR      NZ,VDU1			; Loop unti reached end of the VDU command
041DEC DD 7D       4296  			LD	A,IXL			;  A: Number of bytes to write out
041DEE B7          4297  			OR	A
041DEF 28 0B       4298  			JR 	Z,VDU4			; No bytes to write, so skip the next bit
041DF1 21 00 01 04 4299  			LD	HL,BUFFER		; HL: Start of stream
041DF5 01 00 00 00 4300  			LD	BC,0
041DF9 4F          4301  			LD	C,A			; BC: Number of bytes to write out
041DFA 5B DF       4302  			RST.LIL	18h			; Output the buffer to MOS
041DFC C3 B6 14 04 4303  VDU4:			JP      XEQ
041E00             4304  
041E00             4305  ; CLOSE channel number
041E00             4306  ;
041E00 CD D0 21 04 4307  CLOSE:			CALL    CHANEL			; Fetch the channel number
041E04 CD 0C 3B 04 4308  			CALL    OSSHUT			; Close the channel
041E08 C3 B6 14 04 4309  			JP      XEQ
041E0C             4310  
041E0C             4311  ; BPUT channel,byte
041E0C             4312  ;
041E0C CD D0 21 04 4313  BPUT:			CALL    CHANEL          	; Fetch the channel number
041E10 D5          4314  			PUSH    DE			; DE: Channel number
041E11 CD 42 13 04 4315  			CALL    COMMA			; Skip to the next expression
041E15 CD 27 0C 04 4316  			CALL    EXPRI           	; Feth the data
041E19 D9          4317  			EXX
041E1A 7D          4318  			LD      A,L			; A: The byte to write
041E1B D1          4319  			POP     DE
041E1C CD 1C 3B 04 4320  			CALL    OSBPUT			; Write the byte out
041E20 C3 B6 14 04 4321  			JP      XEQ
041E24             4322  
041E24             4323  ; CALL address[,var[,var...]]
041E24             4324  ;
041E24             4325  ; Note that the parameter table differs from the Z80 version
041E24             4326  ; Each entry now takes up 4 bytes, not 3, so the table is now:
041E24             4327  ;  -1 byte:  Number of parameters
041E24             4328  ; Then, for each parameter:
041E24             4329  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
041E24             4330  ;  -3 bytes: Parameter address
041E24             4331  ;
041E24             4332  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
041E24             4333  ;
041E24 CD 27 0C 04 4334  CALL_:			CALL    EXPRI           	; Fetch the address
041E28 7D          4335  			LD	A,L			;  A: MSB of address
041E29 D9          4336  			EXX
041E2A 22 4A 03 04 4337  			LD	(R0+0),HL		; HL: LSW of address
041E2E 32 4C 03 04 4338  			LD	(R0+2),A
041E32 06 00       4339  			LD      B,0             	;  B: The parameter counter
041E34 11 00 01 04 4340  			LD      DE,BUFFER       	; DE: Vector
041E38             4341  ;
041E38 CD 90 13 04 4342  CALL1:			CALL    NXT			; Skip whitespace
041E3C FE 2C       4343  			CP      ','			; Check for comma
041E3E 20 1B       4344  			JR      NZ,CALL2		; If no more parameters, then jump here
041E40 FD 23       4345  			INC     IY			; Skip to the next character
041E42 04          4346  			INC     B			; Increment the parameter count
041E43 CD 90 13 04 4347  			CALL    NXT			; Skip whitespace
041E47 C5          4348  			PUSH    BC
041E48 D5          4349  			PUSH    DE
041E49 CD AE 15 04 4350  			CALL    VAR_
041E4D D1          4351  			POP     DE
041E4E C1          4352  			POP     BC
041E4F 13          4353  			INC     DE
041E50 12          4354  			LD      (DE),A			; Save the parameter type
041E51 13          4355  			INC     DE
041E52 EB          4356  			EX      DE,HL
041E53 ED 1F       4357  			LD	(HL),DE			; Save the parameter address (3 bytes)
041E55 23          4358  			INC	HL
041E56 23          4359  			INC	HL
041E57 23          4360  			INC	HL
041E58 EB          4361  			EX      DE,HL
041E59 18 DD       4362  			JR      CALL1
041E5B             4363  ;
041E5B 78          4364  CALL2:			LD      A,B
041E5C 32 00 01 04 4365  			LD      (BUFFER),A      	; Save the parameter count
041E60 2A 4A 03 04 4366  			LD	HL,(R0)			; HL: Address of the code
041E64 CD 7E 1E 04 4367  			CALL    USR1			; And call it
041E68 C3 B6 14 04 4368  			JP      XEQ
041E6C             4369  
041E6C             4370  ; USR(address)
041E6C             4371  ;
041E6C CD 42 0C 04 4372  USR:			CALL    ITEMI			; Evaluate the expression
041E70 7D          4373  			LD	A,L			;  A: MSB of address
041E71 D9          4374  			EXX
041E72 22 4A 03 04 4375  			LD	(R0+0),HL		; HL: LSW of address
041E76 32 4C 03 04 4376  			LD	(R0+2),A
041E7A 2A 4A 03 04 4377  			LD	HL,(R0)			; Get the 24-bit address in HL
041E7E             4378  ;
041E7E E5          4379  USR1:			PUSH    HL              	; Address on stack
041E7F FD E3       4380  			EX      (SP),IY
041E81 24          4381  			INC     H               	; Check for PAGE &00FFxx
041E82 B4          4382  			OR	H
041E83 21 ED 1E 04 4383  			LD      HL,USR2         	; Return address
041E87 E5          4384  			PUSH    HL
041E88 DD 21 00 02 4385  			LD      IX,STAVAR
       04          
041E8D CC D2 3A 04 4386  			CALL    Z,OSCALL        	; Intercept &00FFxx
041E91             4387  ;
041E91 DD 4E 18    4388  			LD      C, (IX+24)		; F%
041E94 C5          4389  			PUSH    BC
041E95             4390  ;
041E95 DD 7E 08    4391  			LD	A, (IX+8)		; B% -> MSW
041E98 32 4B 03 04 4392  			LD	(R0+1), A
041E9C DD 7E 09    4393  			LD	A, (IX+9)
041E9F 32 4C 03 04 4394  			LD	(R0+2), A
041EA3 DD 7E 0C    4395  			LD	A, (IX+12)		; C% -> LSB
041EA6 32 4A 03 04 4396  			LD	(R0+0), A
041EAA ED 4B 4A 03 4397  			LD	BC, (R0)
       04          
041EAF             4398  ;
041EAF DD 7E 10    4399  			LD	A, (IX+16)		; D% -> MSW
041EB2 32 4B 03 04 4400  			LD	(R0+1), A
041EB6 DD 7E 11    4401  			LD	A, (IX+17)
041EB9 32 4C 03 04 4402  			LD	(R0+2), A
041EBD DD 7E 14    4403  			LD	A, (IX+20)		; E% -> LSB
041EC0 32 4A 03 04 4404  			LD	(R0+0), A
041EC4 ED 5B 4A 03 4405  			LD	DE, (R0)
       04          
041EC9             4406  ;
041EC9 DD 7E 20    4407  			LD	A, (IX+32)		; H% -> MSW
041ECC 32 4B 03 04 4408  			LD	(R0+1), A
041ED0 DD 7E 21    4409  			LD	A, (IX+33)
041ED3 32 4C 03 04 4410  			LD	(R0+2), A
041ED7 DD 7E 30    4411  			LD	A, (IX+48)		; L% -> LSB
041EDA 32 4A 03 04 4412  			LD	(R0+0), A
041EDE 2A 4A 03 04 4413  			LD	HL, (R0)
041EE2             4414  ;
041EE2 F1          4415  			POP     AF			; F%
041EE3 DD 7E 04    4416  			LD      A, (IX+4)        	; A%
041EE6             4417  
041EE6 DD 21 00 01 4418  			LD      IX,BUFFER
       04          
041EEB FD E9       4419  			JP      (IY)            	; Off to user routine
041EED             4420  ;
041EED FD E1       4421  USR2:			POP     IY
041EEF AF          4422  			XOR     A
041EF0 4F          4423  			LD      C,A
041EF1 C9          4424  			RET
041EF2             4425  
041EF2             4426  ; PUT port,data
041EF2             4427  ;
041EF2 CD 27 0C 04 4428  PUT:			CALL    EXPRI           ;PORT ADDRESS
041EF6 D9          4429  			EXX
041EF7 E5          4430  			PUSH    HL
041EF8 CD 42 13 04 4431  			CALL    COMMA
041EFC CD 27 0C 04 4432  			CALL    EXPRI           ;DATA
041F00 D9          4433  			EXX
041F01 C1          4434  			POP     BC
041F02 ED 69       4435  			OUT     (C),L           ;OUTPUT TO_exec PORT BC
041F04 C3 B6 14 04 4436  			JP      XEQ
041F08             4437  
041F08             4438  ; SUBROUTINES -----------------------------------------------------------------
041F08             4439  
041F08             4440  ; ASSIGN - Assign a numeric value to a variable.
041F08             4441  ; Outputs: NC,  Z - OK, numeric.
041F08             4442  ;          NC, NZ - OK, string.
041F08             4443  ;           C, NZ - illegal
041F08             4444  ;
041F08 CD 37 46 04 4445  ASSIGN:			CALL    GETVAR          	; Try to get the variable
041F0C D8          4446  			RET     C               	; Return with C if it is an illegal variable
041F0D C4 26 46 04 4447  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
041F11 B7          4448  			OR      A
041F12 F8          4449  			RET     M               	; Return if type is string (81h)
041F13 F5          4450  			PUSH    AF              	; It's a numeric type from this point on
041F14 CD DA 20 04 4451  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
041F18 E5          4452  			PUSH    HL
041F19 CD 1F 0C 04 4453  			CALL    EXPRN
041F1D DD E1       4454  			POP     IX
041F1F F1          4455  			POP     AF
041F20 CB 47       4456  STORE:			BIT     0,A
041F22 28 13       4457  			JR      Z,STOREI
041F24 BF          4458  			CP      A               	; Set the variable to 0
041F25 DD 71 04    4459  STORE5:			LD      (IX+4),C
041F28 D9          4460  STORE4:			EXX
041F29 DD 75 00    4461  			LD      (IX+0),L
041F2C DD 74 01    4462  			LD      (IX+1),H
041F2F D9          4463  			EXX
041F30 DD 75 02    4464  			LD      (IX+2),L
041F33 DD 74 03    4465  			LD      (IX+3),H
041F36 C9          4466  			RET
041F37 F5          4467  STOREI:			PUSH    AF
041F38 0C          4468  			INC     C               ;SPEED - & PRESERVE F'
041F39 0D          4469  			DEC     C               ; WHEN CALLED BY FNEND0
041F3A C4 7F 0F 04 4470  			CALL    NZ,SFIX         ;CONVERT TO_exec INTEGER
041F3E F1          4471  			POP     AF
041F3F FE 04       4472  			CP      4
041F41 28 E5       4473  			JR      Z,STORE4
041F43 BF          4474  			CP      A               ;SET ZERO
041F44 D9          4475  STORE1:			EXX
041F45 DD 75 00    4476  			LD      (IX+0),L
041F48 D9          4477  			EXX
041F49 C9          4478  			RET
041F4A             4479  ;
041F4A             4480  ; Copy a string from the string accumulator to variable storage on the stack
041F4A             4481  ; Parameters:
041F4A             4482  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
041F4A             4483  ; - IX: Address of the variable storage on the stack
041F4A             4484  ;
041F4A 21 00 00 04 4485  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
041F4E             4486  ;
041F4E             4487  ; Parameters:
041F4E             4488  ; As above, but:
041F4E             4489  ; - HL: Address of the string to be stored
041F4E             4490  ; -  E: The string length
041F4E             4491  ; NB:
041F4E             4492  ; Strings are mutable
041F4E             4493  ; Strings are stored in the following format in the variable:
041F4E             4494  ; - Address of the next variable (3 bytes)
041F4E             4495  ; - The rest of the variable name - this is zero terminated
041F4E             4496  ; - Current string length (byte)
041F4E             4497  ; - Maximum (original) string length (byte)
041F4E             4498  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
041F4E             4499  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
041F4E             4500  ;
041F4E 1F          4501  STORES:			RRA				; Rotate right to shift bit 0 into carry
041F4F 30 5D       4502  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
041F51 E5          4503  			PUSH    HL			; Stack ACCS
041F52             4504  ;
041F52             4505  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
041F52             4506  ;
041F52 D9          4507  			EXX				; This block was a call to LOAD4
041F53 DD 6E 00    4508  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
041F56 DD 66 01    4509  			LD      H,(IX+1)		; The maximum original string length
041F59 D9          4510  			EXX
041F5A DD 27 02    4511  			LD	HL,(IX+2)		; Address of the string (24-bit)
041F5D             4512  ;
041F5D 7B          4513  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
041F5E D9          4514  			EXX
041F5F 6F          4515  			LD      L,A			; L': Length of string currently stored on the stack
041F60 7C          4516  			LD      A,H             	; H': The maximum (original) string length
041F61 D9          4517  			EXX
041F62 BB          4518  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
041F63 30 17       4519  			JR      NC,STORS1       	; Yes there is, so skip the next bit
041F65             4520  ;
041F65             4521  ; At this point we're either initialising a new string or assigning more memory to an existing string
041F65             4522  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
041F65             4523  ; then the existing and new strings may both exist in memory.
041F65             4524  ;
041F65 D9          4525  			EXX
041F66 65          4526  			LD      H,L			; H: Set the maximum string length to the string length
041F67 D9          4527  			EXX
041F68 E5          4528  			PUSH    HL
041F69 01 00 00 00 4529  			LD	BC, 0
041F6D 4F          4530  			LD      C,A			; BC: The maximum (original) string length
041F6E 09          4531  			ADD     HL,BC			; Work out whether this is the last string in memory
041F6F ED 4B 1D 03 4532  			LD      BC,(FREE)
       04          
041F74 ED 42       4533  			SBC     HL,BC			; Is string last?
041F76 E1          4534  			POP     HL
041F77 37          4535  			SCF
041F78 28 02       4536  			JR      Z,STORS1
041F7A             4537  			; LD	HL, BC			; HL=BC ; how did this even assemble in the first place?!
041F7A C5          4538  			push bc
041F7B E1          4539  			pop hl
041F7C             4540  ;
041F7C             4541  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
041F7C             4542  ; - H': The maximum (original) string length
041F7C             4543  ; - L': The actual string length (must be less than H')
041F7C             4544  ; - HL: Address of the string in memory
041F7C             4545  ;
041F7C D9          4546  STORS1:			EXX				; This block was a call to STORE4
041F7D DD 75 00    4547  			LD      (IX+0),L		; The actual string length (must be less then H')
041F80 DD 74 01    4548  			LD      (IX+1),H		; The maximum (original) string length
041F83 D9          4549  			EXX
041F84 DD 2F 02    4550  			LD	(IX+2),HL		; The pointer to the original string
041F87             4551  ;
041F87 01 00 00 00 4552  			LD	BC, 0
041F8B 4B          4553  			LD      C,E			; BC: The new string length
041F8C EB          4554  			EX      DE,HL
041F8D E1          4555  			POP     HL
041F8E 0D          4556  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
041F8F 0C          4557  			INC     C			; check whether BC is 0 without affecting the carry flag
041F90 C8          4558  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
041F91 ED B0       4559  			LDIR				; Replace the string in memory
041F93 D0          4560  			RET     NC
041F94 ED 53 1D 03 4561  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       04          
041F99             4562  ;
041F99             4563  ; Check whether the stack is full
041F99             4564  ;
041F99 E5          4565  CHECK:			PUSH    HL
041F9A C5          4566  			PUSH	BC
041F9B 2A 1D 03 04 4567  			LD      HL,(FREE)		; HL: Address of first free space byte
041F9F 01 00 01 00 4568  			LD	BC,100h			; BC: One page of memory
041FA3 09          4569  			ADD	HL,BC			; Add a page to FREE
041FA4 ED 72       4570  			SBC     HL,SP			; And subtract the current SP
041FA6 C1          4571  			POP	BC
041FA7 E1          4572  			POP     HL
041FA8 D8          4573  			RET     C			; The SP is not in the same page, so just return
041FA9 AF          4574  			XOR     A			; Otherwise
041FAA C3 5D 43 04 4575  			JP      ERROR_			; Throw error "No room"
041FAE             4576  ;
041FAE 01 00 00 00 4577  STORS3:			LD	BC,0
041FB2 4B          4578  			LD      C,E			; BC: String length
041FB3 DD E5       4579  			PUSH    IX
041FB5 D1          4580  			POP     DE			; DE: Destination
041FB6 AF          4581  			XOR     A			; Check if string length is 0
041FB7 B9          4582  			CP      C
041FB8 28 02       4583  			JR      Z,STORS5		; Yes, so don't copy
041FBA ED B0       4584  			LDIR
041FBC 3E 0D       4585  STORS5:			LD      A,CR			; Finally add the terminator
041FBE 12          4586  			LD      (DE),A
041FBF C9          4587  			RET
041FC0             4588  
041FC0             4589  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
041FC0             4590  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
041FC0             4591  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
041FC0             4592  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
041FC0             4593  ;    Inputs: DE addresses parameter list
041FC0             4594  ;            IY addresses dummy variable list
041FC0             4595  ;   Outputs: DE,IY updated
041FC0             4596  ;  Destroys: Everything
041FC0             4597  ;
041FC0 3E FF       4598  ARGUE:			LD      A,-1
041FC2 F5          4599  			PUSH    AF              	; Put marker on the stack
041FC3 FD 23       4600  ARGUE1:			INC     IY              	; Bump past '(' or ',''
041FC5 13          4601  			INC     DE
041FC6 D5          4602  			PUSH    DE
041FC7 CD 90 13 04 4603  			CALL    NXT			; Skip any whitespace
041FCB CD 37 46 04 4604  			CALL    GETVAR			; Get the location of the variable in HL/IX
041FCF 38 3F       4605  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
041FD1 C4 26 46 04 4606  			CALL    NZ,PUTVAR
041FD5 D1          4607  			POP     DE
041FD6 E5          4608  			PUSH    HL              	; VARPTR
041FD7 B7          4609  			OR      A               	; Check the variable type
041FD8 F5          4610  			PUSH    AF
041FD9 D5          4611  			PUSH    DE
041FDA FD E3       4612  			EX      (SP),IY
041FDC FA F4 1F 04 4613  			JP      M,ARGUE2        	; Jump here if it is a string
041FE0             4614  ;
041FE0 CD 1F 0C 04 4615  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
041FE4 FD E3       4616  			EX      (SP),IY
041FE6 D1          4617  			POP     DE
041FE7 F1          4618  			POP     AF
041FE8 D9          4619  			EXX
041FE9 E5          4620  			PUSH    HL
041FEA D9          4621  			EXX
041FEB E5          4622  			PUSH    HL
041FEC 47          4623  			LD      B,A
041FED C5          4624  			PUSH    BC
041FEE CD 99 1F 04 4625  			CALL    CHECK           	; Check room
041FF2 18 0F       4626  			JR      ARGUE4
041FF4             4627  ;
041FF4 CD 32 0C 04 4628  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
041FF8 FD E3       4629  			EX      (SP),IY
041FFA D9          4630  			EXX
041FFB D1          4631  			POP     DE
041FFC D9          4632  			EXX
041FFD F1          4633  			POP     AF
041FFE CD D1 12 04 4634  			CALL    PUSHS
042002 D9          4635  			EXX
042003             4636  ;
042003 CD 90 13 04 4637  ARGUE4:			CALL    NXT			; Skip whitespace
042007 FE 2C       4638  			CP      ','			; Check to see if the next value is a comma
042009 20 0B       4639  			JR      NZ,ARGUE5		; No, so jump here
04200B 1A          4640  			LD      A,(DE)
04200C FE 2C       4641  			CP      ','			; Are there any more arguments?
04200E 28 B3       4642  			JR      Z,ARGUE1        	; Yes, so loop
042010             4643  ;
042010 3E 1F       4644  ARGERR:			LD      A,31
042012 C3 5D 43 04 4645  			JP      ERROR_           	; Throw error "Arguments"
042016             4646  ;
042016 CD 4F 13 04 4647  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
04201A 1A          4648  			LD      A,(DE)
04201B FE 29       4649  			CP      ')'
04201D 20 F1       4650  			JR      NZ,ARGERR
04201F 13          4651  			INC     DE
042020 D9          4652  			EXX
042021 C1          4653  ARGUE6:			POP     BC
042022 78          4654  			LD      A,B
042023 3C          4655  			INC     A
042024 D9          4656  			EXX
042025 C8          4657  			RET     Z               	; Marker popped
042026 D9          4658  			EXX
042027 3D          4659  			DEC     A
042028 FA 38 20 04 4660  			JP      M,ARGUE7        	; If it is a string, then jump here
04202C E1          4661  			POP     HL
04202D D9          4662  			EXX
04202E E1          4663  			POP     HL
04202F D9          4664  			EXX
042030 DD E1       4665  			POP     IX
042032 CD 20 1F 04 4666  			CALL    STORE	           	; Write to dummy variable
042036 18 E9       4667  			JR      ARGUE6
042038             4668  ;
042038 CD FE 12 04 4669  ARGUE7:			CALL    POPS
04203C DD E1       4670  			POP     IX
04203E CD 4A 1F 04 4671  			CALL    STACCS
042042 18 DD       4672  			JR      ARGUE6
042044             4673  
042044             4674  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
042044             4675  ;   OF A FUNCTION OR PROCEDURE.
042044             4676  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
042044             4677  ;    Inputs: IY is parameters pointer
042044             4678  ;   Outputs: IY updated
042044             4679  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
042044             4680  ;
042044 D1          4681  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
042045             4682  ;
042045 FD 23       4683  SAVLO1:			INC     IY              	; Bump past '(' or ','
042047 CD 90 13 04 4684  			CALL    NXT			; And also any whitespace
04204B D5          4685  			PUSH    DE			; Push the return address back onto the stack
04204C D9          4686  			EXX
04204D C5          4687  			PUSH    BC
04204E D5          4688  			PUSH    DE
04204F E5          4689  			PUSH    HL
042050 D9          4690  			EXX
042051 CD AE 15 04 4691  			CALL    VAR_             	; Dummy variable
042055 D9          4692  			EXX
042056 E1          4693  			POP     HL
042057 D1          4694  			POP     DE
042058 C1          4695  			POP     BC
042059 D9          4696  			EXX
04205A D1          4697  			POP     DE
04205B B7          4698  			OR      A               	; Check the variable type
04205C FA 6F 20 04 4699  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
042060 D9          4700  			EXX
042061 E5          4701  			PUSH    HL              	; Save H'L'
042062 D9          4702  			EXX
042063 47          4703  			LD      B,A             	;  B: Variable type
042064 CD 33 0D 04 4704  			CALL    LOADN
042068 D9          4705  			EXX
042069 E3          4706  			EX      (SP),HL
04206A D9          4707  			EXX
04206B E5          4708  			PUSH    HL
04206C C5          4709  			PUSH    BC
04206D 18 2D       4710  			JR      SAVLO4
04206F             4711  ;
04206F F5          4712  SAVLO2:			PUSH    AF              	; Save the type (string)
042070 D5          4713  			PUSH    DE
042071 D9          4714  			EXX
042072 E5          4715  			PUSH    HL
042073 D9          4716  			EXX
042074 CD BD 0D 04 4717  			CALL    LOADS
042078 D9          4718  			EXX
042079 E1          4719  			POP     HL
04207A D9          4720  			EXX
04207B 01 00 00 00 4721  			LD	BC,0
04207F 4B          4722  			LD      C,E			; BC: String length
042080 D1          4723  			POP     DE
042081 CD 99 1F 04 4724  			CALL    CHECK			; Check if there is space on the stack
042085 F1          4725  			POP     AF              	; Level stack
042086 21 00 00 00 4726  			LD      HL,0
04208A ED 42       4727  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
04208C 39          4728  			ADD     HL,SP			; Make space for the string on the stack
04208D F9          4729  			LD      SP,HL
04208E 47          4730  			LD      B,A             	;  B: Variable type
04208F C5          4731  			PUSH    BC
042090 28 0A       4732  			JR      Z,SAVLO4
042092 D5          4733  			PUSH    DE
042093 11 00 00 04 4734  			LD      DE,ACCS
042097 EB          4735  			EX      DE,HL
042098 45          4736  			LD      B,L
042099 ED B0       4737  			LDIR                    	; Save the string onto the stack
04209B D1          4738  			POP     DE
04209C             4739  ;
04209C DD E5       4740  SAVLO4:			PUSH    IX			; VARPTR
04209E CD A2 20 04 4741  			CALL    SAVLO5
0420A2             4742  LOCCHK:			EQU     $
0420A2 CD 99 1F 04 4743  SAVLO5:			CALL    CHECK
0420A6 CD 90 13 04 4744  			CALL    NXT
0420AA FE 2C       4745  			CP      ','             	; Are there any more local variables?
0420AC 28 97       4746  			JR      Z,SAVLO1		; Yes, so loop
0420AE EB          4747  			EX      DE,HL			; DE -> HL: The return address
0420AF E9          4748  			JP      (HL)            	; And effectvely return
0420B0             4749  ;
0420B0 FD 7E 00    4750  DELIM:			LD      A,(IY)          	; Assembler delimiter
0420B3 FE 20       4751  			CP      ' '
0420B5 C8          4752  			RET     Z
0420B6 FE 2C       4753  			CP      ','
0420B8 C8          4754  			RET     Z
0420B9 FE 29       4755  			CP      ')'
0420BB C8          4756  			RET     Z
0420BC FE 3B       4757  TERM:			CP      ';'             	; Assembler terminator
0420BE C8          4758  			RET     Z
0420BF FE 5C       4759  			CP      '\'
0420C1 C8          4760  			RET     Z
0420C2 18 07       4761  			JR      TERM0
0420C4             4762  ;
0420C4 CD 90 13 04 4763  TERMQ:			CALL    NXT
0420C8 FE 8B       4764  			CP      ELSE__exec
0420CA D0          4765  			RET     NC
0420CB FE 3A       4766  TERM0:			CP      ':'             	; Assembler seperator
0420CD D0          4767  			RET     NC
0420CE FE 0D       4768  			CP      CR
0420D0 C9          4769  			RET
0420D1             4770  ;
0420D1 CD C4 20 04 4771  SPAN:			CALL    TERMQ
0420D5 C8          4772  			RET     Z
0420D6 FD 23       4773  			INC     IY
0420D8 18 F7       4774  			JR      SPAN
0420DA             4775  ;
0420DA             4776  ; This snippet is used to check whether an expression is followed by an '=' symbol
0420DA             4777  ;
0420DA CD 90 13 04 4778  EQUALS:			CALL    NXT			; Skip whitespace
0420DE FD 23       4779  			INC     IY			; Skip past the character in question
0420E0 FE 3D       4780  			CP      '='			; Is it '='
0420E2 C8          4781  			RET     Z			; Yes, so return
0420E3 3E 04       4782  			LD      A,4			; Otherwise
0420E5 C3 5D 43 04 4783  			JP      ERROR_           	; Throw error "Mistake"
0420E9             4784  ;
0420E9 FE 8A       4785  FORMAT:			CP      TAB
0420EB 28 0D       4786  			JR      Z,DOTAB
0420ED FE 89       4787  			CP      SPC
0420EF 28 40       4788  			JR      Z,DOSPC
0420F1 FE 27       4789  			CP      '''
0420F3 C0          4790  			RET     NZ
0420F4 CD 44 45 04 4791  			CALL    CRLF
0420F8 AF          4792  			XOR     A
0420F9 C9          4793  			RET
0420FA             4794  ;
0420FA C5          4795  DOTAB:			PUSH    BC
0420FB CD 27 0C 04 4796  			CALL    EXPRI
0420FF D9          4797  			EXX
042100 C1          4798  			POP     BC
042101 FD 7E 00    4799  			LD      A,(IY)
042104 FE 2C       4800  			CP      ','
042106 28 14       4801  			JR      Z,DOTAB1
042108 CD 4F 13 04 4802  			CALL    BRAKET
04210C 7D          4803  			LD      A,L
04210D 21 3D 03 04 4804  TABIT:			LD      HL,COUNT
042111 BE          4805  			CP      (HL)
042112 C8          4806  			RET     Z
042113 F5          4807  			PUSH    AF
042114 DC 44 45 04 4808  			CALL    C,CRLF
042118 F1          4809  			POP     AF
042119 96          4810  			SUB     (HL)
04211A 18 1D       4811  			JR      FILL
04211C FD 23       4812  DOTAB1:			INC     IY
04211E C5          4813  			PUSH    BC
04211F E5          4814  			PUSH    HL
042120 CD 27 0C 04 4815  			CALL    EXPRI
042124 D9          4816  			EXX
042125 D1          4817  			POP     DE
042126 C1          4818  			POP     BC
042127 CD 4F 13 04 4819  			CALL    BRAKET
04212B CD 91 36 04 4820  			CALL    PUTCSR
04212F AF          4821  			XOR     A
042130 C9          4822  			RET
042131             4823  ;
042131 C5          4824  DOSPC:			PUSH    BC
042132 CD 42 0C 04 4825  			CALL    ITEMI
042136 D9          4826  			EXX
042137 7D          4827  			LD      A,L
042138 C1          4828  			POP     BC
042139 B7          4829  FILL:			OR      A
04213A C8          4830  			RET     Z
04213B C5          4831  			PUSH    BC
04213C 47          4832  			LD      B,A
04213D 3E 20       4833  FILL1:			LD      A,' '
04213F CD 4C 45 04 4834  			CALL    OUTCHR
042143 10 F8       4835  			DJNZ    FILL1
042145 C1          4836  			POP     BC
042146 AF          4837  			XOR     A
042147 C9          4838  			RET
042148             4839  ;
042148 21 00 00 04 4840  PTEXT:			LD      HL,ACCS
04214C 1C          4841  			INC     E
04214D 1D          4842  PTEXT1:			DEC     E
04214E C8          4843  			RET     Z
04214F 7E          4844  			LD      A,(HL)
042150 23          4845  			INC     HL
042151 CD 4C 45 04 4846  			CALL    OUTCHR
042155 18 F6       4847  			JR      PTEXT1
042157             4848  ;
042157 F5          4849  FETCHS:			PUSH    AF
042158 C5          4850  			PUSH    BC
042159 E5          4851  			PUSH    HL
04215A FD E3       4852  			EX      (SP),IY
04215C CD 77 21 04 4853  			CALL    XTRACT
042160 CD 90 13 04 4854  			CALL    NXT
042164 FD E3       4855  			EX      (SP),IY
042166 E1          4856  			POP     HL
042167 C1          4857  			POP     BC
042168 F1          4858  			POP     AF
042169 C9          4859  			RET
04216A             4860  ;
04216A 11 00 00 04 4861  LINES:			LD      DE,ACCS
04216E 7E          4862  LINE1S:			LD      A,(HL)
04216F 12          4863  			LD      (DE),A
042170 FE 0D       4864  			CP      CR
042172 C8          4865  			RET     Z
042173 23          4866  			INC     HL
042174 1C          4867  			INC     E
042175 18 F7       4868  			JR      LINE1S
042177             4869  ;
042177 CD 90 13 04 4870  XTRACT:			CALL    NXT
04217B FE 22       4871  			CP      '"'
04217D FD 23       4872  			INC     IY
04217F CA 84 0D 04 4873  			JP      Z,CONS
042183 FD 2B       4874  			DEC     IY
042185 11 00 00 04 4875  			LD      DE,ACCS
042189 FD 7E 00    4876  XTRAC1:			LD      A,(IY)
04218C 12          4877  			LD      (DE),A
04218D FE 2C       4878  			CP      ','
04218F C8          4879  			RET     Z
042190 FE 0D       4880  			CP      CR
042192 C8          4881  			RET     Z
042193 FD 23       4882  			INC     IY
042195 1C          4883  			INC     E
042196 18 F1       4884  			JR      XTRAC1
042198             4885  
042198             4886  ; Search for a token at the start of a program line
042198             4887  ; - HL: Pointer to the start of a tokenised line in the program area
042198             4888  ; Returns:
042198             4889  ; - HL: Pointer to the
042198             4890  ; -  F: Carry set if not found
042198             4891  ; Corrupts:
042198             4892  ; - BC
042198             4893  ;
042198 01 00 00 00 4894  SEARCH_exec:			LD      BC,0			; Clear BC
04219C             4895  ;
04219C 4E          4896  SRCH1_exec:			LD      C,(HL)			;  C: Fetch the line length
04219D 0C          4897  			INC     C			; Check for 0, i.e. end of program marker
04219E 0D          4898  			DEC     C
04219F 28 0B       4899  			JR      Z,SRCH2_exec         	; Not found the token, so end
0421A1 23          4900  			INC     HL			; Skip the line length and line number
0421A2 23          4901  			INC     HL
0421A3 23          4902  			INC     HL
0421A4 BE          4903  			CP      (HL)			; Compare with the token
0421A5 C8          4904  			RET     Z			; Found it, so return with carry not set
0421A6 0D          4905  			DEC     C			; Skip to the next line
0421A7 0D          4906  			DEC     C
0421A8 0D          4907  			DEC     C
0421A9 09          4908  			ADD     HL,BC
0421AA 18 F0       4909  			JR      SRCH1_exec			; Rinse, lather and repeat
0421AC             4910  ;
0421AC 2B          4911  SRCH2_exec:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0421AD 37          4912  			SCF				; And set the carry flag
0421AE C9          4913  			RET
0421AF             4914  
0421AF             4915  ; Multiply by 4 or 5
0421AF             4916  ; This function is used to allocate space for dimensioned variables
0421AF             4917  ; This is a 24-bit operation
0421AF             4918  ; - DE: Number to multiple
0421AF             4919  ; -  A: 04h (Integer) - takes up 4 bytes
0421AF             4920  ;       05h (Float)   - takes up 5 bytes
0421AF             4921  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
0421AF             4922  ; Returns:
0421AF             4923  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
0421AF             4924  ; -  F: Carry if overflow
0421AF             4925  ; Corrupts:
0421AF             4926  ; - HL
0421AF FE 04       4927  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0421B1             4928  			; LD	HL,DE  ; HOW!?
0421B1 D5          4929  			push de
0421B2 E1          4930  			pop hl
0421B3 29          4931  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0421B4 D8          4932  			RET     C			; Exit if overflow
0421B5 29          4933  			ADD     HL,HL			; Multiply by 2 again
0421B6 D8          4934  			RET     C			; Exit if overflow
0421B7 EB          4935  			EX      DE,HL			; DE: Product
0421B8 C8          4936  			RET     Z			; Exit if A = 4
0421B9 19          4937  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0421BA EB          4938  			EX      DE,HL			; DE: Product
0421BB C9          4939  			RET
0421BC             4940  
0421BC             4941  ; 16-bit unsigned multiply
0421BC             4942  ; - HL: Operand 1
0421BC             4943  ; - BC: Operand 2
0421BC             4944  ; Returns:
0421BC             4945  ; - HL: Result
0421BC             4946  ; -  F: C if overflow
0421BC             4947  ;
0421BC C5          4948  MUL16:			PUSH	BC
0421BD 51          4949  			LD	D, C			; Set up the registers for the multiplies
0421BE 5D          4950  			LD	E, L
0421BF 69          4951  			LD	L, C
0421C0 4B          4952  			LD	C, E
0421C1 ED 6C       4953  			MLT	HL			; HL = H * C (*256)
0421C3 ED 5C       4954  			MLT	DE			; DE = L * C
0421C5 ED 4C       4955  			MLT	BC			; BC = B * L (*256)
0421C7 09          4956  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0421C8 C1          4957  			POP	BC
0421C9 AF          4958  			XOR	A
0421CA 9C          4959  			SBC	H			; If H is not zero then it's an overflow
0421CB D8          4960  			RET	C
0421CC 65          4961  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0421CD 6F          4962  			LD	L, A
0421CE 19          4963  			ADD	HL, DE
0421CF C9          4964  			RET
0421D0             4965  ;
0421D0 CD 90 13 04 4966  CHANEL:			CALL    NXT			; Skip whitespace
0421D4 FE 23       4967  			CP      '#'			; Check for the '#' symbol
0421D6 3E 2D       4968  			LD      A,45
0421D8 C2 5D 43 04 4969  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0421DC FD 23       4970  CHNL:			INC     IY             		; Bump past the '#'
0421DE CD 42 0C 04 4971  			CALL    ITEMI			; Get the channel number
0421E2 D9          4972  			EXX
0421E3 EB          4973  			EX      DE,HL			; DE: The channel number
0421E4 C9          4974  			RET
0421E5             4975  
0421E5             4976  ; ASSEMBLER -------------------------------------------------------------------
0421E5             4977  
0421E5             4978  ; Language independant control section:
0421E5             4979  ;  Outputs: A=delimiter, carry set if syntax error.
0421E5             4980  ;
0421E5 CD 05 27 04 4981  ASSEM:			CALL    SKIP
0421E9 FD 23       4982  			INC     IY
0421EB FE 3A       4983  			CP      ':'
0421ED 28 F6       4984  			JR      Z,ASSEM
0421EF FE 5D       4985  			CP      ']'
0421F1 C8          4986  			RET     Z
0421F2 FE 0D       4987  			CP      CR
0421F4 C8          4988  			RET     Z
0421F5 FD 2B       4989  			DEC     IY
0421F7 DD 2A 40 08 4990  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       10          
0421FC 21 40 03 04 4991  			LD      HL,LISTON
042200 CB 76       4992  			BIT     6,(HL)
042202 28 05       4993  			JR      Z,ASSEM0
042204 DD 2A 3C 08 4994  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       10          
042209 DD E5       4995  ASSEM0:			PUSH    IX
04220B FD E5       4996  			PUSH    IY
04220D CD BD 22 04 4997  			CALL    ASMB
042211 C1          4998  			POP     BC
042212 D1          4999  			POP     DE
042213 D8          5000  			RET     C
042214 CD 05 27 04 5001  			CALL    SKIP
042218 37          5002  			SCF
042219 C0          5003  			RET     NZ
04221A FD 2B       5004  			DEC     IY
04221C FD 23       5005  ASSEM3:			INC     IY
04221E FD 7E 00    5006  			LD      A,(IY)
042221 CD CB 20 04 5007  			CALL    TERM0
042225 20 F5       5008  			JR      NZ,ASSEM3
042227 3A 40 03 04 5009  			LD      A,(LISTON)
04222B DD E5       5010  			PUSH    IX
04222D E1          5011  			POP     HL
04222E B7          5012  			OR      A
04222F ED 52       5013  			SBC     HL,DE
042231 EB          5014  			EX      DE,HL           	; DE: Number of bytes
042232 E5          5015  			PUSH    HL
042233 2A 40 08 10 5016  			LD      HL,(PC)
042237 E5          5017  			PUSH    HL
042238 19          5018  			ADD     HL,DE
042239 22 40 08 10 5019  			LD      (PC),HL         	; Update PC
04223D CB 77       5020  			BIT     6,A
04223F 28 09       5021  			JR      Z,ASSEM5
042241 2A 3C 08 10 5022  			LD      HL,(OC)
042245 19          5023  			ADD     HL,DE
042246 22 3C 08 10 5024  			LD      (OC),HL         	; Update OC
04224A E1          5025  ASSEM5:			POP     HL              	; Old PC
04224B DD E1       5026  			POP     IX              	; Code here
04224D CB 67       5027  			BIT     4,A
04224F 28 94       5028  			JR      Z,ASSEM
042251 22 4A 03 04 5029  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
042255 3A 4C 03 04 5030  			LD	A,(R0+2)		; Print out the address
042259 CD A7 22 04 5031  			CALL	HEX_exec
04225D 7C          5032  			LD      A,H
04225E CD A7 22 04 5033  			CALL    HEX_exec
042262 7D          5034  			LD      A,L
042263 CD 9F 22 04 5035  			CALL    HEXSP
042267 AF          5036  			XOR     A
042268 BB          5037  			CP      E
042269 28 18       5038  			JR      Z,ASSEM2
04226B             5039  ;
04226B 3A 3D 03 04 5040  ASSEM1:			LD      A,(COUNT)
04226F FE 14       5041  			CP      20
042271 3E 07       5042  			LD      A,7
042273 D4 0D 21 04 5043  			CALL    NC,TABIT        	; Next line
042277 DD 7E 00    5044  			LD      A,(IX)
04227A CD 9F 22 04 5045  			CALL    HEXSP
04227E DD 23       5046  			INC     IX
042280 1D          5047  			DEC     E
042281 20 E8       5048  			JR      NZ,ASSEM1
042283             5049  ;
042283 3E 16       5050  ASSEM2:			LD      A,22			; Tab to the disassembly field
042285 CD 0D 21 04 5051  			CALL    TABIT
042289 FD E5       5052  			PUSH    IY
04228B E1          5053  			POP     HL
04228C ED 42       5054  			SBC     HL,BC
04228E 0A          5055  ASSEM4:			LD      A,(BC)
04228F CD 69 45 04 5056  			CALL    OUT_
042293 03          5057  			INC     BC
042294 2D          5058  			DEC     L
042295 20 F7       5059  			JR      NZ,ASSEM4
042297 CD 44 45 04 5060  			CALL    CRLF
04229B C3 E5 21 04 5061  			JP      ASSEM
04229F             5062  ;
04229F CD A7 22 04 5063  HEXSP:			CALL    HEX_exec
0422A3 3E 20       5064  			LD      A,' '
0422A5 18 12       5065  			JR      OUTCH1
0422A7 F5          5066  HEX_exec:			PUSH    AF
0422A8 0F          5067  			RRCA
0422A9 0F          5068  			RRCA
0422AA 0F          5069  			RRCA
0422AB 0F          5070  			RRCA
0422AC CD B1 22 04 5071  			CALL    HEXOUT
0422B0 F1          5072  			POP     AF
0422B1 E6 0F       5073  HEXOUT:			AND     0FH
0422B3 C6 90       5074  			ADD     A,90H
0422B5 27          5075  			DAA
0422B6 CE 40       5076  			ADC     A,40H
0422B8 27          5077  			DAA
0422B9 C3 69 45 04 5078  OUTCH1:			JP      OUT_
0422BD             5079  
0422BD             5080  ; Processor Specific Translation Section:
0422BD             5081  ;
0422BD             5082  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0422BD             5083  ;                 C: Opcode beig built
0422BD             5084  ;                 D: Flags
0422BD             5085  ;			Bit 7: Set to 1 if the instruction uses long addressing
0422BD             5086  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0422BD             5087  ;                 E: Offset from IX or IY
0422BD             5088  ;                HL: Numeric operand value
0422BD             5089  ;                IX: Code destination pointer
0422BD             5090  ;                IY: Source text pointer
0422BD             5091  ;    Inputs: A = initial character
0422BD             5092  ;   Outputs: Carry set if syntax error.
0422BD             5093  ;
0422BD FE 2E       5094  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0422BF 20 1F       5095  			JR      NZ,ASMB1		; No, so just process the instruction
0422C1 FD 23       5096  			INC     IY			; Skip past the dot to the label name
0422C3 DD E5       5097  			PUSH    IX			; Store the code destination pointer
0422C5 CD AE 15 04 5098  			CALL    VAR_			; Create a variable
0422C9 F5          5099  			PUSH    AF
0422CA CD B0 12 04 5100  			CALL    ZERO			; Zero it
0422CE 3A 42 08 10 5101  			LD	A,(PC+2)
0422D2 6F          5102  			LD	L,A			; The MSB of the 24-bit address
0422D3 D9          5103  			EXX
0422D4 2A 40 08 10 5104  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0422D8 D9          5105  			EXX
0422D9 F1          5106  			POP     AF
0422DA CD 20 1F 04 5107  			CALL    STORE			; Store the program counter
0422DE DD E1       5108  			POP     IX			; Restore the code destination pointer
0422E0             5109  ;
0422E0 3A 40 03 04 5110  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0422E4 E6 80       5111  			AND	80H
0422E6 57          5112  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0422E7 CD 05 27 04 5113  			CALL    SKIP			; Skip any whitespace
0422EB C8          5114  			RET     Z			; And return if there is nothing further to process
0422EC FE D6       5115  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0422EE 0E C4       5116  			LD      C,0C4H			;  A: The base operand
0422F0 FD 23       5117  			INC     IY			; Skip past the token
0422F2 CA 3A 24 04 5118  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0422F6 FD 2B       5119  			DEC     IY			; Skip back, as we're not doing the above at this point
0422F8 21 1C 27 04 5120  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0422FC CD B4 26 04 5121  			CALL    FIND			; Find the opcode
042300 D8          5122  			RET     C			; If not found, then return; carry indicates an error condition
042301 48          5123  			LD      C,B     		;  C: A copy of the opcode
042302             5124  ;
042302             5125  ; GROUP 0: Trivial cases requiring no computation
042302             5126  ; GROUP 1: As Group 0, but with "ED" prefix
042302             5127  ;
042302 D6 44       5128  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
042304 30 08       5129  			JR      NC,GROUP02		; If not in that range, then check GROUP2
042306 FE CB       5130  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
042308 D4 0D 26 04 5131  			CALL    NC,ED			; Needs to be prefixed with ED
04230C 18 76       5132  			JR      BYTE0			; Then write the opcode byte
04230E             5133  ;
04230E             5134  ; GROUP 2: BIT, RES, SET
04230E             5135  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
04230E             5136  ;
04230E D6 0A       5137  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
042310 30 12       5138  			JR      NC,GROUP04		; If not in that range, then check GROUP4
042312 FE F9       5139  			CP      3-10			;
042314 DC A2 26 04 5140  			CALL    C,BIT_
042318 D8          5141  			RET     C
042319 CD 73 26 04 5142  			CALL    REGLO
04231D D8          5143  			RET     C
04231E CD 11 26 04 5144  			CALL    CB
042322 18 60       5145  			JR      BYTE0
042324             5146  ;
042324             5147  ; GROUP 4 - PUSH, POP, EX (SP)
042324             5148  ;
042324 D6 03       5149  GROUP04:		SUB     3			; The number of opcodes in GROUP4
042326 30 07       5150  			JR      NC,GROUP05		; If not in that range, then check GROUP5
042328 CD 95 26 04 5151  GROUP04_1:		CALL    PAIR_exec
04232C D8          5152  			RET     C
04232D 18 55       5153  			JR      BYTE0
04232F             5154  ;
04232F             5155  ; GROUP 5 - SUB, AND, XOR, OR, CP
04232F             5156  ; GROUP 6 - ADD, ADC, SBC
04232F             5157  ;
04232F D6 0A       5158  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
042331 30 39       5159  			JR      NC,GROUP07
042333 FE FD       5160  			CP      5-8
042335 06 07       5161  			LD      B,7
042337 D4 21 26 04 5162  			CALL    NC,OPND			; Get the first operand
04233B 78          5163  			LD      A,B
04233C FE 07       5164  			CP      7			; Is the operand 'A'?
04233E 20 15       5165  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
042340             5166  ;
042340 CD 73 26 04 5167  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
042344 79          5168  			LD      A,C
042345 30 2E       5169  			JR      NC,BIND1		; If it is a register, then write that out
042347 EE 46       5170  			XOR     46H			; Handle ADD A,n
042349 CD 13 26 04 5171  			CALL    BIND
04234D CD 53 26 04 5172  DB_:			CALL    NUMBER_exec
042351 C3 0C 24 04 5173  			JP      VAL8
042355             5174  ;
042355 E6 3F       5175  GROUP05_HL:		AND     3FH
042357 FE 0C       5176  			CP      12
042359 37          5177  			SCF
04235A C0          5178  			RET     NZ
04235B 79          5179  			LD      A,C
04235C FE 80       5180  			CP      80H
04235E 0E 09       5181  			LD      C,9
042360 28 C6       5182  			JR      Z,GROUP04_1
042362 EE 1C       5183  			XOR     1CH
042364 0F          5184  			RRCA
042365 4F          5185  			LD      C,A
042366 CD 0D 26 04 5186  			CALL    ED
04236A 18 BC       5187  			JR      GROUP04_1
04236C             5188  ;
04236C             5189  ; GROUP 7 - INC, DEC
04236C             5190  ;
04236C D6 02       5191  GROUP07:		SUB     2			; The number of opcodes in GROUP7
04236E 30 19       5192  			JR      NC,GROUP08
042370 CD 7A 26 04 5193  			CALL    REGHI
042374 79          5194  			LD      A,C
042375 D2 13 26 04 5195  BIND1:			JP      NC,BIND
042379 EE 64       5196  			XOR     64H
04237B 07          5197  			RLCA
04237C 07          5198  			RLCA
04237D 07          5199  			RLCA
04237E 4F          5200  			LD      C,A
04237F CD 9A 26 04 5201  			CALL    PAIR1_exec
042383 D8          5202  			RET     C
042384 79          5203  BYTE0:			LD      A,C
042385 C3 42 26 04 5204  			JP      BYTE_
042389             5205  ;
042389             5206  ; Group 8: IN0, OUT0
042389             5207  ;
042389 D6 02       5208  GROUP08:		SUB	2			; The number of opcodes in GROUP8
04238B 30 2C       5209  			JR	NC,GROUP09
04238D FE FF       5210  			CP	1-2
04238F CC 53 26 04 5211  			CALL    Z,NUMBER_exec		; Fetch number first if OUT
042393 08          5212  			EX      AF,AF'			; Save flags
042394 CD 67 26 04 5213  			CALL    REG			; Get the register value regardless
042398 D8          5214  			RET     C			; Return if not a register
042399 08          5215  			EX      AF,AF'			; Restore the flags
04239A DC 53 26 04 5216  			CALL    C,NUMBER_exec		; Fetch number last if IN
04239E 78          5217  			LD	A,B			; Get the register number
04239F FE 06       5218  			CP	6			; Fail on (HL)
0423A1 37          5219  			SCF
0423A2 C8          5220  			RET	Z
0423A3 FE 08       5221  			CP	8			; Check it is just single pairs only
0423A5 3F          5222  			CCF
0423A6 D8          5223  			RET	C			; And return if it is an invalid register
0423A7 07          5224  			RLCA				; Bind with the operand
0423A8 07          5225  			RLCA
0423A9 07          5226  			RLCA
0423AA 81          5227  			ADD	A,C
0423AB 4F          5228  			LD	C,A
0423AC CD 0D 26 04 5229  			CALL	ED			; Prefix with ED
0423B0 79          5230  			LD	A,C
0423B1 CD 42 26 04 5231  			CALL	BYTE_			; Write out the operand
0423B5 C3 0C 24 04 5232  			JP	VAL8			; Write out the value
0423B9             5233  ;
0423B9             5234  ; GROUP 9 - IN
0423B9             5235  ; GROUP 10 - OUT
0423B9             5236  ;
0423B9 D6 02       5237  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
0423BB 30 25       5238  			JR      NC,GROUP11
0423BD FE FF       5239  			CP      1-2			; Check if Group 9 or Group 1
0423BF CC 01 26 04 5240  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
0423C3 08          5241  			EX      AF,AF'			; Save flags
0423C4 CD 7A 26 04 5242  			CALL    REGHI			; Get the register value regardless
0423C8 D8          5243  			RET     C			; Return if not a register
0423C9 08          5244  			EX      AF,AF'			; Restore the flags
0423CA DC 01 26 04 5245  			CALL    C,CORN			; Call CORN if Group 9 (IN)
0423CE 24          5246  			INC     H			; If it is IN r,(C) or OUT (C),r then
0423CF 28 B3       5247  			JR      Z,BYTE0			; Just write the operand out
0423D1             5248  ;
0423D1 78          5249  			LD      A,B			; Check the register
0423D2 FE 07       5250  			CP      7
0423D4 37          5251  			SCF
0423D5 C0          5252  			RET     NZ			; If it is not A, then return
0423D6             5253  ;
0423D6 79          5254  			LD      A,C			; Bind the register with the operand
0423D7 EE 03       5255  			XOR     3
0423D9 07          5256  			RLCA
0423DA 07          5257  			RLCA
0423DB 07          5258  			RLCA
0423DC CD 42 26 04 5259  			CALL    BYTE_			; Write out the operand
0423E0 18 2A       5260  			JR      VAL8			; And the value
0423E2             5261  ;
0423E2             5262  ; GROUP 11 - JR, DJNZ
0423E2             5263  ;
0423E2 D6 02       5264  GROUP11:		SUB     2			; The number of opcodes in GROUP11
0423E4 30 2B       5265  			JR      NC,GROUP12
0423E6 FE FF       5266  			CP      1-2
0423E8 C4 81 26 04 5267  			CALL    NZ,COND_
0423EC 79          5268  			LD      A,C
0423ED 30 02       5269  			JR      NC,@F
0423EF 3E 18       5270  			LD      A,18H
0423F1 CD 42 26 04 5271  @@:			CALL    BYTE_
0423F5 CD 53 26 04 5272  			CALL    NUMBER_exec
0423F9 ED 5B 40 08 5273  			LD      DE,(PC)
       10          
0423FE 13          5274  			INC     DE
0423FF 37          5275  			SCF
042400 ED 52       5276  			SBC     HL,DE
042402 7D          5277  			LD      A,L
042403 17          5278  			RLA
042404 9F          5279  			SBC     A,A
042405 BC          5280  			CP      H
042406 3E 01       5281  TOOFAR:			LD      A,1
042408 C2 5D 43 04 5282  			JP      NZ,ERROR_		; Throw an "Out of range" error
04240C 7D          5283  VAL8:			LD      A,L
04240D C3 42 26 04 5284  			JP      BYTE_
042411             5285  ;
042411             5286  ; GROUP 12 - JP
042411             5287  ;
042411 D6 01       5288  GROUP12:		SUB	1			; The number of opcodes in GROUP12
042413 30 21       5289  			JR	NC,GROUP13
042415 CD 67 25 04 5290  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
042419 D8          5291  			RET	C			; Exit if an invalid suffix is provided
04241A CD 81 26 04 5292  			CALL    COND_			; Evaluate the conditions
04241E 79          5293  			LD      A,C
04241F 30 0D       5294  			JR      NC,GROUP12_1
042421 78          5295  			LD      A,B
042422 E6 3F       5296  			AND     3FH
042424 FE 06       5297  			CP      6
042426 3E E9       5298  			LD      A,0E9H
042428 CA 42 26 04 5299  			JP      Z,BYTE_
04242C 3E C3       5300  			LD      A,0C3H
04242E CD 42 26 04 5301  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
042432 C3 BC 25 04 5302  			JP	ADDR_			; Output the address
042436             5303  ;
042436             5304  ; GROUP 13 - CALL
042436             5305  ;
042436 D6 01       5306  GROUP13:		SUB	1			; The number of opcodes in GROUP13
042438 30 0C       5307  			JR	NC,GROUP14
04243A CD 7F 25 04 5308  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
04243E CD 61 24 04 5309  			CALL    GROUP15_1		; Output the opcode (with conditions)
042442 C3 BC 25 04 5310  			JP	ADDR_			; Output the address
042446             5311  ;
042446             5312  ; GROUP 14 - RST
042446             5313  ;
042446 D6 01       5314  GROUP14:		SUB	1			; The number of opcodes in GROUP14
042448 30 13       5315  			JR	NC,GROUP15
04244A CD 7F 25 04 5316  			CALL	EZ80SF_FULL		; Evaluate the suffix
04244E D8          5317  			RET	C			; Exit if an invalid suffix provided
04244F CD 53 26 04 5318  			CALL    NUMBER_exec
042453 A1          5319  			AND     C
042454 B4          5320  			OR      H
042455 20 AF       5321  			JR      NZ,TOOFAR
042457 7D          5322  			LD      A,L
042458 B1          5323  			OR      C
042459 C3 42 26 04 5324  	  		JP      BYTE_
04245D             5325  ;
04245D             5326  ; GROUP 15 - RET
04245D             5327  ;
04245D D6 01       5328  GROUP15:		SUB	1			; The number of opcodes in GROUP15
04245F 30 0F       5329  			JR	NC,GROUP16
042461 CD 81 26 04 5330  GROUP15_1:		CALL    COND_
042465 79          5331  			LD      A,C
042466 D2 42 26 04 5332  			JP      NC,BYTE_
04246A F6 09       5333  			OR      9
04246C C3 42 26 04 5334  			JP      BYTE_
042470             5335  ;
042470             5336  ; GROUP 16 - LD
042470             5337  ;
042470 D6 01       5338  GROUP16:		SUB	1			; The number of opcodes in GROUP16
042472 30 74       5339  			JR	NC,GROUP17
042474 CD 7F 25 04 5340  			CALL	EZ80SF_FULL		; Evaluate the suffix
042478 CD B0 26 04 5341  			CALL    LDOP			; Check for accumulator loads
04247C D2 DC 25 04 5342  			JP      NC,LDA			; Yes, so jump here
042480 CD 7A 26 04 5343  			CALL    REGHI
042484 08          5344  			EX      AF,AF'
042485 CD 05 27 04 5345  			CALL    SKIP
042489 FE 28       5346  			CP      '('			; Check for bracket
04248B 28 24       5347  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
04248D 08          5348  			EX      AF,AF'
04248E D2 40 23 04 5349  			JP      NC,GROUP05_1		; Load single register direct; go here
042492 0E 01       5350  			LD      C,1
042494 CD 9A 26 04 5351  			CALL    PAIR1_exec
042498 D8          5352  			RET     C
042499 3E 0E       5353  			LD      A,14
04249B B8          5354  			CP      B
04249C 47          5355  			LD      B,A
04249D CC 95 26 04 5356  			CALL    Z,PAIR_exec
0424A1 78          5357  			LD      A,B
0424A2 E6 3F       5358  			AND     3FH
0424A4 FE 0C       5359  			CP      12
0424A6 79          5360  			LD      A,C
0424A7 C2 2E 24 04 5361  			JP      NZ,GROUP12_1		; Load register pair direct; go here
0424AB 3E F9       5362  			LD      A,0F9H
0424AD C3 42 26 04 5363  			JP      BYTE_
0424B1             5364  ;
0424B1 08          5365  LDIN:			EX      AF,AF'
0424B2 C5          5366  			PUSH    BC
0424B3 D4 73 26 04 5367  			CALL    NC,REGLO
0424B7 79          5368  			LD      A,C
0424B8 C1          5369  			POP     BC
0424B9 D2 13 26 04 5370  			JP      NC,BIND
0424BD 0E 0A       5371  			LD      C,0AH
0424BF CD 9A 26 04 5372  			CALL    PAIR1_exec
0424C3 CD E7 25 04 5373  			CALL    LD16
0424C7 D2 2E 24 04 5374  			JP      NC,GROUP12_1
0424CB CD 53 26 04 5375  			CALL    NUMBER_exec
0424CF 0E 02       5376  			LD      C,2
0424D1 CD 95 26 04 5377  			CALL    PAIR_exec
0424D5 CD E7 25 04 5378  			CALL    LD16
0424D9 D8          5379  			RET     C
0424DA CD 42 26 04 5380  			CALL    BYTE_
0424DE CB 7A       5381  			BIT	7,D			; Check the ADL flag
0424E0 C2 D1 25 04 5382  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
0424E4 C3 C4 25 04 5383  			JP      VAL16			; Otherwise use 16-bit addresses
0424E8             5384  ;
0424E8             5385  ; Group 17 - TST
0424E8             5386  ;
0424E8 D6 01       5387  GROUP17:		SUB	1			; The number of opcodes in GROUP17
0424EA 30 25       5388  			JR	NC,OPTS
0424EC CD 0D 26 04 5389  			CALL	ED			; Needs to be prefixed with ED
0424F0 CD 67 26 04 5390  			CALL	REG			; Fetch the register
0424F4 30 0E       5391  			JR	NC,GROUP17_1		; It's just a register
0424F6             5392  ;
0424F6 3E 64       5393  			LD	A,64H			; Opcode for TST n
0424F8 CD 42 26 04 5394  			CALL	BYTE_			; Write out the opcode
0424FC CD 53 26 04 5395  			CALL	NUMBER_exec			; Get the number
042500 C3 0C 24 04 5396  			JP	VAL8			; And write that out
042504             5397  ;
042504 78          5398  GROUP17_1:		LD	A,B			; Check the register rangs
042505 FE 08       5399  			CP	8
042507 3F          5400  			CCF
042508 D8          5401  			RET	C			; Ret with carry flag set for error if out of range
042509 07          5402  			RLCA				; Get the opcode value
04250A 07          5403  			RLCA
04250B 07          5404  			RLCA
04250C 81          5405  			ADD	A,C			; Add the opcode base in
04250D C3 42 26 04 5406  			JP	BYTE_
042511             5407  
042511             5408  ;
042511             5409  ; Assembler directives - OPT, ADL
042511             5410  ;
042511 D6 02       5411  OPTS:			SUB	2
042513 30 2B       5412  			JR	NC, DEFS
042515 FE FF       5413  			CP	1-2			; Check for ADL opcode
042517 28 13       5414  			JR	Z, ADL_
042519             5415  ;
042519 CD 53 26 04 5416  OPT:			CALL    NUMBER_exec			; Fetch the OPT value
04251D 21 40 03 04 5417  			LD      HL,LISTON		; Address of the LISTON/OPT flag
042521 E6 07       5418  			AND	7			; Only interested in the first three bits
042523 4F          5419  			LD      C,A			; Store the new OPT value in C
042524 ED 6F       5420  			RLD				; Shift the top nibble of LISTON (OPT) into A
042526 E6 08       5421  			AND	8			; Clear the bottom three bits, preserving the ADL bit
042528 B1          5422  			OR	C			; OR in the new value
042529 ED 67       5423  			RRD				; And shift the nibble back in
04252B C9          5424  			RET
04252C             5425  ;
04252C CD 53 26 04 5426  ADL_:			CALL	NUMBER_exec			; Fetch the ADL value
042530 E6 01       5427  			AND	1			; Only interested if it is 0 or 1
042532 0F          5428  			RRCA				; Rotate to bit 7
042533 4F          5429  			LD	C,A			; Store in C
042534 3A 40 03 04 5430  			LD	A,(LISTON)		; Get the LISTON system variable
042538 E6 7F       5431  			AND	7Fh			; Clear bit 7
04253A B1          5432  			OR	C			; OR in the ADL value
04253B 32 40 03 04 5433  			LD	(LISTON),A		; Store
04253F C9          5434  			RET
042540             5435  ;
042540             5436  ; DEFB, DEFW, DEFL, DEFM
042540             5437  ;
042540 B7          5438  DEFS:			OR	A			; Handle DEFB
042541 CA 4D 23 04 5439  			JP	Z, DB_
042545 3D          5440  			DEC	A			; Handle DEFW
042546 CA C0 25 04 5441  			JP	Z, ADDR16
04254A 3D          5442  			DEC	A			; Handle DEFL
04254B CA CD 25 04 5443  			JP	Z, ADDR24
04254F             5444  ;
04254F DD E5       5445  			PUSH    IX			; Handle DEFM
042551 CD 32 0C 04 5446  			CALL    EXPRS
042555 DD E1       5447  			POP     IX
042557 21 00 00 04 5448  			LD      HL,ACCS
04255B AF          5449  @@:			XOR     A
04255C BB          5450  			CP      E
04255D C8          5451  			RET     Z
04255E 7E          5452  			LD      A,(HL)
04255F 23          5453  			INC     HL
042560 CD 42 26 04 5454  			CALL    BYTE_
042564 1D          5455  			DEC     E
042565 18 F4       5456  			JR      @B
042567             5457  
042567             5458  ;
042567             5459  ;SUBROUTINES:
042567             5460  ;
042567 FD 7E 00    5461  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
04256A FE 2E       5462  			CP	'.'
04256C 28 02       5463  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
04256E B7          5464  			OR	A			; Reset the carry flag (no error)
04256F C9          5465  			RET				; And return
042570 FD 23       5466  @@:			INC	IY			; Skip the dot
042572 C5          5467  			PUSH	BC			; Push the operand
042573 21 1C 27 04 5468  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
042577 CD B4 26 04 5469  			CALL	FIND			; Look up the operand
04257B 30 24       5470  			JR	NC,EZ80SF_OK
04257D C1          5471  			POP	BC			; Not found at this point, so will return with a C (error)
04257E C9          5472  			RET
04257F             5473  ;
04257F FD 7E 00    5474  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
042582 FE 2E       5475  			CP	'.'
042584 28 02       5476  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
042586 B7          5477  			OR	A			; Reset the carry flag (no error)
042587 C9          5478  			RET				; And return
042588 FD 23       5479  @@:			INC	IY 			; Skip the dot
04258A C5          5480  			PUSH	BC			; Push the operand
04258B 21 1C 27 04 5481  			LD	HL,EZ80SFS_1		; First check the fully qualified table
04258F CD B4 26 04 5482  			CALL	FIND 			; Look up the operand
042593 30 0C       5483  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
042595 CD B0 25 04 5484  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
042599 CD B4 26 04 5485  			CALL	FIND
04259D 30 02       5486  			JR	NC,EZ80SF_OK
04259F C1          5487  			POP	BC			; Not found at this point, so will return with a C (error)
0425A0 C9          5488  			RET
0425A1             5489  ;
0425A1 78          5490  EZ80SF_OK:		LD	A,B			; The operand value
0425A2 D4 42 26 04 5491  			CALL	NC,BYTE_ 		; Write it out if found
0425A6 CB BA       5492  			RES	7,D			; Clear the default ADL mode from the flags
0425A8 E6 02       5493  			AND	2			; Check the second half of the suffix (.xxL)
0425AA 0F          5494  			RRCA				; Shift into bit 7
0425AB 0F          5495  			RRCA
0425AC B2          5496  			OR	D			; Or into bit 7 of D
0425AD 57          5497  			LD	D,A
0425AE C1          5498  			POP	BC 			; Restore the operand
0425AF C9          5499  			RET
0425B0             5500  ;
0425B0 21 1C 27 04 5501  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
0425B4 CB 7A       5502  			BIT 	7,D			; if bit 7 of D is 0
0425B6 C8          5503  			RET	Z
0425B7 21 1C 27 04 5504  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
0425BB C9          5505  			RET
0425BC             5506  ;
0425BC CB 7A       5507  ADDR_:			BIT	7,D			; Check the ADL flag
0425BE 20 0D       5508  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
0425C0             5509  ;
0425C0 CD 53 26 04 5510  ADDR16:			CALL	NUMBER_exec			; Fetch an address (16-bit) and fall through to VAL16
0425C4 CD 0C 24 04 5511  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
0425C8 7C          5512  			LD      A,H
0425C9 C3 42 26 04 5513  			JP      BYTE_
0425CD             5514  ;
0425CD CD 53 26 04 5515  ADDR24:			CALL    NUMBER_exec			; Fetch an address (24-bit) and fall through to VAL24
0425D1 CD C4 25 04 5516  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
0425D5 D9          5517  			EXX
0425D6 7D          5518  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
0425D7 D9          5519  			EXX
0425D8 C3 42 26 04 5520  			JP	BYTE_
0425DC             5521  ;
0425DC FE 04       5522  LDA:			CP      4
0425DE DC 0D 26 04 5523  			CALL    C,ED
0425E2 78          5524  			LD      A,B
0425E3 C3 42 26 04 5525  			JP      BYTE_
0425E7             5526  ;
0425E7 78          5527  LD16:			LD      A,B
0425E8 38 0F       5528  			JR      C,LD8
0425EA 78          5529  			LD      A,B
0425EB E6 3F       5530  			AND     3FH
0425ED FE 0C       5531  			CP      12
0425EF 79          5532  			LD      A,C
0425F0 C8          5533  			RET     Z
0425F1 CD 0D 26 04 5534  			CALL    ED
0425F5 79          5535  			LD      A,C
0425F6 F6 43       5536  			OR      43H
0425F8 C9          5537  			RET
0425F9             5538  ;
0425F9 FE 07       5539  LD8:			CP      7
0425FB 37          5540  			SCF
0425FC C0          5541  			RET     NZ
0425FD 79          5542  			LD      A,C
0425FE F6 30       5543  			OR      30H
042600 C9          5544  			RET
042601             5545  ;
042601             5546  ; Used in IN and OUT to handle whether the operand is C or a number
042601             5547  ;
042601 C5          5548  CORN:			PUSH    BC
042602 CD 21 26 04 5549  			CALL    OPND			; Get the operand
042606 CB 68       5550  			BIT     5,B
042608 C1          5551  			POP     BC
042609 28 48       5552  			JR      Z,NUMBER_exec		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
04260B 26 FF       5553  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
04260D             5554  ;
04260D 3E ED       5555  ED:			LD      A,0EDH			; Write an ED prefix out
04260F 18 31       5556  			JR      BYTE_
042611             5557  ;
042611 3E CB       5558  CB:			LD      A,0CBH
042613 FE 76       5559  BIND:			CP      76H
042615 37          5560  			SCF
042616 C8          5561  			RET     Z               	; Reject LD (HL),(HL)
042617 CD 42 26 04 5562  			CALL    BYTE_
04261B CB 72       5563  			BIT	6,D			; Check the index bit in flags
04261D C8          5564  			RET     Z
04261E 7B          5565  			LD      A,E			; If there is an index, output the offset
04261F 18 21       5566  			JR      BYTE_
042621             5567  ;
042621             5568  ; Search through the operand table
042621             5569  ; Returns:
042621             5570  ; - B: The operand type
042621             5571  ; - D: Bit 7: 0 = no prefix, 1 = prefix
042621             5572  ; - E: The IX/IY offset
042621             5573  ; - F: Carry if not found
042621             5574  ;
042621 E5          5575  OPND:			PUSH    HL			; Preserve HL
042622 21 1C 27 04 5576  			LD      HL,OPRNDS		; The operands table
042626 CD B4 26 04 5577  			CALL    FIND			; Find the operand
04262A E1          5578  			POP     HL
04262B D8          5579  			RET     C			; Return if not found
04262C CB 78       5580  			BIT     7,B			; Check if it is an index register (IX, IY)
04262E C8          5581  			RET     Z			; Return if it isn't
04262F CB F2       5582  			SET	6,D			; Set flag to indicate we've got an index
042631 CB 58       5583  			BIT     3,B			; Check if an offset is required
042633 E5          5584  			PUSH    HL
042634 CC 49 26 04 5585  			CALL    Z,OFFSET_exec		; If bit 3 of B is zero, then get the offset
042638 5D          5586  			LD      E,L			; E: The offset
042639 E1          5587  			POP     HL
04263A 3E DD       5588  			LD	A,DDH			; IX prefix
04263C CB 70       5589  			BIT     6,B			; If bit 6 is reset then
04263E 28 02       5590  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
042640 3E FD       5591  			LD	A,FDH			; IY prefix
042642             5592  ;
042642 DD 77 00    5593  BYTE_:			LD      (IX),A			; Write a byte out
042645 DD 23       5594  			INC     IX
042647 B7          5595  			OR      A
042648 C9          5596  			RET
042649             5597  ;
042649 FD 7E 00    5598  OFFSET_exec:			LD      A,(IY)
04264C FE 29       5599  			CP      ')'
04264E 21 00 00 00 5600  			LD      HL,0
042652 C8          5601  			RET     Z
042653 CD 05 27 04 5602  NUMBER_exec:			CALL    SKIP
042657 C5          5603  			PUSH    BC
042658 D5          5604  			PUSH    DE
042659 DD E5       5605  			PUSH    IX
04265B CD 27 0C 04 5606  			CALL    EXPRI
04265F DD E1       5607  			POP     IX
042661 D9          5608  			EXX
042662 D1          5609  			POP     DE
042663 C1          5610  			POP     BC
042664 7D          5611  			LD      A,L
042665 B7          5612  			OR      A
042666 C9          5613  			RET
042667             5614  ;
042667 CD 21 26 04 5615  REG:			CALL    OPND
04266B D8          5616  			RET     C
04266C 78          5617  			LD      A,B
04266D E6 3F       5618  			AND     3FH
04266F FE 08       5619  			CP      8
042671 3F          5620  			CCF
042672 C9          5621  			RET
042673             5622  ;
042673 CD 67 26 04 5623  REGLO:			CALL    REG
042677 D8          5624  			RET     C
042678 18 33       5625  			JR      ORC
04267A             5626  ;
04267A CD 67 26 04 5627  REGHI:			CALL    REG
04267E D8          5628  			RET     C
04267F 18 29       5629  			JR      SHL3
042681             5630  ;
042681 CD 21 26 04 5631  COND_:			CALL    OPND
042685 D8          5632  			RET     C
042686 78          5633  			LD      A,B
042687 E6 1F       5634  			AND     1FH
042689 D6 10       5635  			SUB     16
04268B 30 1D       5636  			JR      NC,SHL3
04268D FE F1       5637  			CP      -15
04268F 37          5638  			SCF
042690 C0          5639  			RET     NZ
042691 3E 03       5640  			LD      A,3
042693 18 15       5641  			JR      SHL3
042695             5642  ;
042695 CD 21 26 04 5643  PAIR_exec:			CALL    OPND
042699 D8          5644  			RET     C
04269A 78          5645  PAIR1_exec:			LD      A,B
04269B E6 0F       5646  			AND     0FH
04269D D6 08       5647  			SUB     8
04269F D8          5648  			RET     C
0426A0 18 08       5649  			JR      SHL3
0426A2             5650  ;
0426A2 CD 53 26 04 5651  BIT_:			CALL    NUMBER_exec
0426A6 FE 08       5652  			CP      8
0426A8 3F          5653  			CCF
0426A9 D8          5654  			RET     C
0426AA 07          5655  SHL3:			RLCA
0426AB 07          5656  			RLCA
0426AC 07          5657  			RLCA
0426AD B1          5658  ORC:			OR      C
0426AE 4F          5659  			LD      C,A
0426AF C9          5660  			RET
0426B0             5661  ;
0426B0 21 1C 27 04 5662  LDOP:			LD      HL,LDOPS
0426B4             5663  
0426B4             5664  ;
0426B4             5665  ; Look up a value in a table
0426B4             5666  ; Parameters:
0426B4             5667  ; - IY: Address of the assembly language line in the BASIC program area
0426B4             5668  ; - HL: Address of the table
0426B4             5669  ; Returns:
0426B4             5670  ; - B: The operand code
0426B4             5671  ; - F: Carry set if not found
0426B4             5672  ;
0426B4 CD 05 27 04 5673  FIND:			CALL    SKIP			; Skip delimiters
0426B8             5674  ;
0426B8 06 00       5675  EXIT__exec:			LD      B,0			; Set B to 0
0426BA 37          5676  			SCF				; Set the carry flag
0426BB C8          5677  			RET     Z			; Returns if Z
0426BC             5678  ;
0426BC FE DD       5679  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
0426BE 28 04       5680  			JR      Z,FIND0
0426C0 FE 85       5681  			CP      TOR+1			; Special case for tokens AND and OR
0426C2 3F          5682  			CCF
0426C3 D8          5683  			RET     C
0426C4 7E          5684  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
0426C5 B7          5685  			OR      A
0426C6 28 F0       5686  			JR      Z,EXIT__exec			; Exit
0426C8 FD AE 00    5687  			XOR     (IY)
0426CB E6 5F       5688  			AND     01011111B
0426CD 28 09       5689  			JR      Z,FIND2
0426CF CB 7E       5690  FIND1:			BIT     7,(HL)
0426D1 23          5691  			INC     HL
0426D2 28 FB       5692  			JR      Z,FIND1
0426D4 23          5693  			INC     HL
0426D5 04          5694  			INC     B
0426D6 18 EC       5695  			JR      FIND0
0426D8             5696  ;
0426D8 FD E5       5697  FIND2:			PUSH    IY
0426DA CB 7E       5698  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
0426DC FD 23       5699  			INC     IY
0426DE 23          5700  			INC     HL
0426DF 20 11       5701  			JR      NZ,FIND5		; Yes
0426E1 BE          5702  			CP      (HL)
0426E2 CC 04 27 04 5703  			CALL    Z,SKIP0
0426E6 7E          5704  			LD      A,(HL)
0426E7 FD AE 00    5705  			XOR     (IY)
0426EA E6 5F       5706  			AND     01011111B
0426EC 28 EC       5707  			JR      Z,FIND3
0426EE FD E1       5708  FIND4:			POP     IY
0426F0 18 DD       5709  			JR      FIND1
0426F2             5710  ;
0426F2 CD B0 20 04 5711  FIND5:			CALL    DELIM			; Is it a delimiter?
0426F6 C4 19 27 04 5712  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
0426FA C4 13 27 04 5713  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
0426FE 20 EE       5714  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
042700             5715  ;
042700 78          5716  FIND6:			LD      A,B			; At this point we have a token
042701 46          5717  			LD      B,(HL)			; Fetch the token type code
042702 E1          5718  			POP     HL			; Restore the stack
042703 C9          5719  			RET
042704             5720  ;
042704 23          5721  SKIP0:			INC     HL
042705 CD B0 20 04 5722  SKIP:			CALL    DELIM			; Is it a delimiter?
042709 C0          5723  			RET     NZ			; No, so return
04270A CD BC 20 04 5724  			CALL    TERM			; Is it a terminator?
04270E C8          5725  			RET     Z			; Yes, so return
04270F FD 23       5726  			INC     IY			; Increment the basic program counter
042711 18 F2       5727  			JR      SKIP			; And loop
042713             5728  ;
042713 FE 2B       5729  SIGN:			CP      '+'			; Check whether the character is a sign symbol
042715 C8          5730  			RET     Z
042716 FE 2D       5731  			CP      '-'
042718 C9          5732  			RET
042719             5733  ;
042719 FE 2E       5734  DOT:			CP	'.'			; Check if it is a dot character
04271B C9          5735  			RET
04271C             5736  
04271C             5737  ; Z80 opcode list
04271C             5738  ;
04271C             5739  ; Group 0: (15 opcodes)
04271C             5740  ; Trivial cases requiring no computation
04271C             5741  ;
04271C             5742  OPCODS:
04271C             5743  ; 			DB	'NO','P'+80H,00h	; # 00h
04271C             5744  ; 			DB	'RLC','A'+80H,07h
04271C             5745  ; 			DB	'EX',0,'AF',0,'AF','''+80H,08h
04271C             5746  ; 			DB	'RRC','A'+80H,0FH
04271C             5747  ; 			DB	'RL','A'+80H,17H
04271C             5748  ; 			DB	'RR','A'+80H,1FH
04271C             5749  ; 			DB	'DA','A'+80H,27H
04271C             5750  ; 			DB	'CP','L'+80H,2FH
04271C             5751  ; 			DB	'SC','F'+80H,37H
04271C             5752  ; 			DB	'CC','F'+80H,3FH
04271C             5753  ; 			DB	'HAL','T'+80H,76H
04271C             5754  ; 			DB	'EX','X'+80H,D9H
04271C             5755  ; 			DB	'EX',0,'DE',0,'H','L'+80H,EBH
04271C             5756  ; 			DB	'D','I'+80H,F3H
04271C             5757  ; 			DB	'E','I'+80H,FBH
04271C             5758  ; ;
04271C             5759  ; ; Group 1: (53 opcodes)
04271C             5760  ; ; As Group 0, but with an ED prefix
04271C             5761  ; ;
04271C             5762  ; 			DB	'NE','G'+80H,44H	; 0Fh
04271C             5763  ; 			DB	'IM',0,'0'+80H,46H
04271C             5764  ; 			DB	'RET','N'+80H,45H
04271C             5765  ; 			DB	'MLT',0,'B','C'+80H,4CH
04271C             5766  ; 			DB	'RET','I'+80H,4DH
04271C             5767  ; 			DB	'IM',0,'1'+80H,56H
04271C             5768  ; 			DB	'MLT',0,'D','E'+80H,5CH
04271C             5769  ; 			DB	'IM',0,'2'+80H,5EH
04271C             5770  ; 			DB	'RR','D'+80H,67H
04271C             5771  ; 			DB	'MLT',0,'H','L'+80H,6CH
04271C             5772  ; 			DB	'LD',0,'MB',0,'A'+80H,6DH
04271C             5773  ; 			DB	'LD',0,'A',0,'M','B'+80H,6EH
04271C             5774  ; 			DB	'RL','D'+80H,6FH
04271C             5775  ; 			DB	'SL','P'+80H,76H
04271C             5776  ; 			DB	'MLT',0,'S','P'+80H,7CH
04271C             5777  ; 			DB	'STMI','X'+80H,7DH
04271C             5778  ; 			DB	'RSMI','X'+80H,7EH
04271C             5779  ; 			DB	'INI','M'+80H,82H
04271C             5780  ; 			DB	'OTI','M'+80H,83H
04271C             5781  ; 			DB	'INI','2'+80H,84H
04271C             5782  ; 			DB	'IND','M'+80H,8AH
04271C             5783  ; 			DB	'OTD','M'+80H,8BH
04271C             5784  ; 			DB	'IND','2'+80H,8CH
04271C             5785  ; 			DB	'INIM','R'+80H,92H
04271C             5786  ; 			DB	'OTIM','R'+80H,93H
04271C             5787  ; 			DB	'INI2','R'+80H,94H
04271C             5788  ; 			DB	'INDM','R'+80H,9AH
04271C             5789  ; 			DB	'OTDM','R'+80H,9BH
04271C             5790  ; 			DB	'IND2','R'+80H,9CH
04271C             5791  ; 			DB	'LD','I'+80H,A0H
04271C             5792  ; 			DB	'CP','I'+80H,A1H
04271C             5793  ; 			DB	'IN','I'+80H,A2H
04271C             5794  ; 			DB	'OUTI','2'+80H,A4H	; These are swapped round so that FIND will find
04271C             5795  ; 			DB	'OUT','I'+80H,A3H	; OUTI2 before OUTI
04271C             5796  ; 			DB	'LD','D'+80H,A8H
04271C             5797  ; 			DB	'CP','D'+80H,A9H
04271C             5798  ; 			DB	'IN','D'+80H,AAH
04271C             5799  ; 			DB	'OUTD','2'+80H,ACH	; Similarly these are swapped round so that FIND
04271C             5800  ; 			DB	'OUT','D'+80H,ABH	; will find OUTD2 before OUTD
04271C             5801  ; 			DB	'LDI','R'+80H,B0H
04271C             5802  ; 			DB	'CPI','R'+80H,B1H
04271C             5803  ; 			DB	'INI','R'+80H,B2H
04271C             5804  ; 			DB	'OTI','R'+80H,B3H
04271C             5805  ; 			DB	'OTI2','R'+80H,B4H
04271C             5806  ; 			DB	'LDD','R'+80H,B8H
04271C             5807  ; 			DB	'CPD','R'+80H,B9H
04271C             5808  ; 			DB	'IND','R'+80H,BAH
04271C             5809  ; 			DB	'OTD','R'+80H,BBH
04271C             5810  ; 			DB	'OTD2','R'+80H,BCH
04271C             5811  ; 			DB	'INIR','X'+80H,C2H
04271C             5812  ; 			DB	'OTIR','X'+80H,C3H
04271C             5813  ; 			DB	'INDR','X'+80H,CAH
04271C             5814  ; 			DB	'OTDR','X'+80H,CBH
04271C             5815  ; ;
04271C             5816  ; ; Group 2: (3 opcodes)
04271C             5817  ; ;
04271C             5818  ; 			DB	'BI','T'+80H,40H	; 44h
04271C             5819  ; 			DB	'RE','S'+80H,80H
04271C             5820  ; 			DB	'SE','T'+80H,C0H
04271C             5821  ; ;
04271C             5822  ; ; Group 3: (7 opcodes)
04271C             5823  ; ;
04271C             5824  ; 			DB	'RL','C'+80H,00H	; 47h
04271C             5825  ; 			DB	'RR','C'+80H,08H
04271C             5826  ; 			DB	'R','L'+80H,10H
04271C             5827  ; 			DB	'R','R'+80H,18H
04271C             5828  ; 			DB	'SL','A'+80H,20H
04271C             5829  ; 			DB	'SR','A'+80H,28H
04271C             5830  ; 			DB	'SR','L'+80H,38H
04271C             5831  ; ;
04271C             5832  ; ; Group 4: (3 opcodes)
04271C             5833  ; ;
04271C             5834  ; 			DB	'PO','P'+80H,C1H	; 4Eh
04271C             5835  ; 			DB	'PUS','H'+80H,C5H
04271C             5836  ; 			DB	'EX',0,'(S','P'+80H,E3H
04271C             5837  ; ;
04271C             5838  ; ; Group 5: (7 opcodes)
04271C             5839  ; ;
04271C             5840  ; 			DB	'SU','B'+80H,90H	; 51h
04271C             5841  ; 			DB	'AN','D'+80H,A0H
04271C             5842  ; 			DB	'XO','R'+80H,A8H
04271C             5843  ; 			DB	'O','R'+80H,B0H
04271C             5844  ; 			DB	'C','P'+80H,B8H
04271C             5845  ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
04271C             5846  ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
04271C             5847  ; ;
04271C             5848  ; ; Group 6 (3 opcodes)
04271C             5849  ; ;
04271C             5850  ; 			DB	'AD','D'+80H,80H	; 58h
04271C             5851  ; 			DB	'AD','C'+80H,88H
04271C             5852  ; 			DB	'SB','C'+80H,98H
04271C             5853  ; ;
04271C             5854  ; ; Group 7: (2 opcodes)
04271C             5855  ; ;
04271C             5856  ; 			DB	'IN','C'+80H,04H	; 5Bh
04271C             5857  ; 			DB	'DE','C'+80H,05H
04271C             5858  ; ;
04271C             5859  ; ; Group 8: (2 opcodes)
04271C             5860  ; ;
04271C             5861  ; 			DB	'IN','0'+80H,00H	; 5Dh
04271C             5862  ; 			DB	'OUT','0'+80H,01H
04271C             5863  ; ;
04271C             5864  ; ; Group 9: (1 opcode)
04271C             5865  ; ;
04271C             5866  ; 			DB	'I','N'+80H,40H		; 5Fh
04271C             5867  ; ;
04271C             5868  ; ; Group 10: (1 opcode)
04271C             5869  ; ;
04271C             5870  ; 			DB	'OU','T'+80H,41H	; 60h
04271C             5871  ; ;
04271C             5872  ; ; Group 11: (2 opcodes)
04271C             5873  ; ;
04271C             5874  ; 			DB	'J','R'+80H,20H		; 61h
04271C             5875  ; 			DB	'DJN','Z'+80H,10H
04271C             5876  ; ;
04271C             5877  ; ; Group 12: (1 opcode)
04271C             5878  ; ;
04271C             5879  ; 			DB	'J','P'+80H,C2H		; 63h
04271C             5880  ; ;
04271C             5881  ; ; Group 13: (1 opcode)
04271C             5882  ; ;
04271C             5883  ; 			DB	'CAL','L'+80H,C4H	; 64h
04271C             5884  ; ;
04271C             5885  ; ; Group 14: (1 opcode)
04271C             5886  ; ;
04271C             5887  ; 			DB	'RS','T'+80H,C7H	; 65h
04271C             5888  ; ;
04271C             5889  ; ; Group 15: (1 opcode)
04271C             5890  ; ;
04271C             5891  ; 			DB	'RE','T'+80H,C0H	; 66h
04271C             5892  ; ;
04271C             5893  ; ; Group 16: (1 opcode)
04271C             5894  ; ;
04271C             5895  ; 			DB	'L','D'+80H,40H		; 67h
04271C             5896  ; ;
04271C             5897  ; ; Group 17: (1 opcode)
04271C             5898  ; ;
04271C             5899  ; 			DB	'TS','T'+80H,04H	; 68h
04271C             5900  
04271C             5901  ; ;
04271C             5902  ; ; Assembler Directives
04271C             5903  ; ;
04271C             5904  ; 			DB	'OP','T'+80H,00H	; 69h OPT
04271C             5905  ; 			DB	'AD','L'+80H,00H	; 6Ah ADL
04271C             5906  ; ;
04271C             5907  ; 			DB	DEF_ & 7FH,'B'+80H,00H	; 6Bh Tokenised DEF + B
04271C             5908  ; 			DB	DEF_ & 7FH,'W'+80H,00H	; 6Ch Tokenised DEF + W
04271C             5909  ; 			DB	DEF_ & 7FH,'L'+80H,00H	; 6Dh Tokenised DEF + L
04271C             5910  ; 			DB 	DEF_ & 7FH,'M'+80H,00H	; 6Eh Tokenised DEF + M
04271C             5911  ; ;
04271C             5912  ; 			DB	0
04271C             5913  ;
04271C             5914  ; Operands
04271C             5915  ;
04271C             5916  OPRNDS:
04271C             5917  ; 			DB	'B'+80H, 00H
04271C             5918  ; 			DB	'C'+80H, 01H
04271C             5919  ; 			DB	'D'+80H, 02H
04271C             5920  ; 			DB	'E'+80H, 03H
04271C             5921  ; 			DB	'H'+80H, 04H
04271C             5922  ; 			DB	'L'+80H, 05H
04271C             5923  ; 			DB	'(H','L'+80H,06H
04271C             5924  ; 			DB	'A'+80H, 07H
04271C             5925  ; 			DB	'(I','X'+80H,86H
04271C             5926  ; 			DB	'(I','Y'+80H,C6H
04271C             5927  ; ;
04271C             5928  ; 			DB	'B','C'+80H,08H
04271C             5929  ; 			DB	'D','E'+80H,0AH
04271C             5930  ; 			DB	'H','L'+80H,0CH
04271C             5931  ; 			DB	'I','X'+80H,8CH
04271C             5932  ; 			DB	'I','Y'+80H,CCH
04271C             5933  ; 			DB	'A','F'+80H,0EH
04271C             5934  ; 			DB	'S','P'+80H,0EH
04271C             5935  ; ;
04271C             5936  ; 			DB	'N','Z'+80H,10H
04271C             5937  ; 			DB	'Z'+80H,11H
04271C             5938  ; 			DB	'N','C'+80H,12H
04271C             5939  ; 			DB	'P','O'+80H,14H
04271C             5940  ; 			DB	'P','E'+80H,15H
04271C             5941  ; 			DB	'P'+80H,16H
04271C             5942  ; 			DB	'M'+80H,17H
04271C             5943  ; ;
04271C             5944  ; 			DB	'(','C'+80H,20H
04271C             5945  ; ;
04271C             5946  ; 			DB	0
04271C             5947  ; ;
04271C             5948  ; Load operations
04271C             5949  ;
04271C             5950  LDOPS:
04271C             5951  ; 			DB	'I',0,'A'+80H,47H
04271C             5952  ; 			DB	'R',0,'A'+80H,4FH
04271C             5953  ; 			DB	'A',0,'I'+80H,57H
04271C             5954  ; 			DB	'A',0,'R'+80H,5FH
04271C             5955  ; 			DB	'(BC',0,'A'+80H,02h
04271C             5956  ; 			DB	'(DE',0,'A'+80H,12H
04271C             5957  ; 			DB	'A',0,'(B','C'+80H,0AH
04271C             5958  ; 			DB	'A',0,'(D','E'+80H,1AH
04271C             5959  ; ;
04271C             5960  ; 			DB	0
04271C             5961  ;
04271C             5962  ; eZ80 addressing mode suffixes
04271C             5963  ;
04271C             5964  ; Fully qualified suffixes
04271C             5965  ;
04271C             5966  EZ80SFS_1:
04271C             5967  			; DB	'LI','S'+80H,49H
04271C             5968  			; DB	'SI','L'+80H,52H
04271C             5969  EZ80SFS_2:
04271C             5970  ; 			DB	'SI','S'+80H,40H
04271C             5971  ; 			DB	'LI','L'+80H,5BH
04271C             5972  ; ;
04271C             5973  ; 			DB	0
04271C             5974  ;
04271C             5975  ; Shortcuts when ADL mode is 0
04271C             5976  ;
04271C             5977  EZ80SFS_ADL0:
04271C             5978  ; 			DB	'S'+80H,40H		; Equivalent to .SIS
04271C             5979  ; 			DB	'L'+80H,49H		; Equivalent to .LIS
04271C             5980  ; 			DB	'I','S'+80H,40H		; Equivalent to .SIS
04271C             5981  ; 			DB	'I','L'+80H,52H		; Equivalent to .SIL
04271C             5982  ; ;
04271C             5983  ; 			DB	0
04271C             5984  ;
04271C             5985  ; Shortcuts when ADL mode is 1
04271C             5986  ;
04271C             5987  EZ80SFS_ADL1:
04271C             5988  ; 			DB	'S'+80H,52H		; Equivalent to .SIL
04271C             5989  ; 			DB	'L'+80H,5BH		; Equivalent to .LIL
04271C             5990  ; 			DB	'I','S'+80H,49H		; Equivalent to .LIS
04271C             5991  ; 			DB	'I','L'+80H,5BH		; Equivalent to .LIL
04271C             5992  ; ;
04271C             5993  ; 			DB	0
04271C             5994  ;
04271C             5995  ; .LIST
04271C             5996  ; in equs.inc
04271C             5997  ; LF:			EQU     0AH
04271C             5998  ; CR:			EQU     0DH
04271C             5999  ; ========================================
04271C             6000  ; FROM fpp.asm
04271C             6001  ; ----------------------------------------
04271C             6002  
04271C             6003  ;
04271C             6004  ; Title:	BBC Basic Interpreter - Z80 version
04271C             6005  ;		Z80 Floating Point Package
04271C             6006  ; Author:	(C) Copyright  R.T.Russell  1986
04271C             6007  ; Modified By:	Dean Belfield
04271C             6008  ; Created:	03/05/2022
04271C             6009  ; Last Updated:	07/06/2023
04271C             6010  ;
04271C             6011  ; Modinfo:
04271C             6012  ; 26/10/1986:	Version 0.0
04271C             6013  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
04271C             6014  ; 12/05/2023:	Modified by Dean Belfield
04271C             6015  ; 07/06/2023:	Modified to run in ADL mode
04271C             6016  
04271C             6017  			; .ASSUME	ADL = 1
04271C             6018  
04271C             6019  			; SEGMENT CODE
04271C             6020  
04271C             6021  ; 			XDEF	FPP
04271C             6022  ; 			XDEF	DLOAD5
04271C             6023  ; 			XDEF	DLOAD5_SPL
04271C             6024  ;
04271C             6025  ;BINARY FLOATING POINT REPRESENTATION:
04271C             6026  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
04271C             6027  ;    8 BIT EXCESS-128 SIGNED EXPONENT
04271C             6028  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
04271C             6029  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
04271C             6030  ;
04271C             6031  ;BINARY INTEGER REPRESENTATION:
04271C             6032  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
04271C             6033  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
04271C             6034  ;
04271C             6035  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
04271C             6036  ;                            EXPONENT - C
04271C             6037  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
04271C             6038  ;                               EXPONENT - B
04271C             6039  
04271C             6040  ;
04271C             6041  ;Error codes:
04271C             6042  ;
04271C             6043  
04271C             6044  BADOP:			EQU     1               ;Bad operation code
04271C             6045  DIVBY0:			EQU     18              ;Division by zero
04271C             6046  TOOBIG_fpp:			EQU     20              ;Too big
04271C             6047  NGROOT:			EQU     21              ;Negative root
04271C             6048  LOGRNG:			EQU     22              ;Log range
04271C             6049  ACLOST:			EQU     23              ;Accuracy lost
04271C             6050  EXPRNG:			EQU     24              ;Exp range
04271C             6051  ;
04271C             6052  ;Call entry and despatch code:
04271C             6053  ;
04271C FD E5       6054  FPP:			PUSH    IY              ;Save IY
04271E FD 21 00 00 6055          		LD      IY,0
       00          
042723 FD 39       6056          		ADD     IY,SP           ;Save SP in IY
042725 CD 35 27 04 6057          		CALL    OP              ;Perform operation
042729 BF          6058          		CP      A               ;Good return (Z, NC)
04272A FD E1       6059  EXIT__fpp:			POP     IY              ;Restore IY
04272C C9          6060          		RET                     ;Return to caller
04272D             6061  ;
04272D             6062  ;Error exit:
04272D             6063  ;
04272D 3E 01       6064  BAD_fpp:			LD      A,BADOP         ;"Bad operation code"
04272F FD F9       6065  ERROR_FPP_:			LD      SP,IY           ;Restore SP from IY
042731 B7          6066          		OR      A               ;Set NZ
042732 37          6067          		SCF                     ;Set C
042733 18 F5       6068          		JR      EXIT__fpp
042735             6069  ;
042735             6070  ;Perform operation or function:
042735             6071  ;
042735             6072  ; OP:			CP      (RTABLE-DTABLE)/3
042735 FE 2A       6073  OP:			CP      RTABLE-DTABLE/3
042737 30 F4       6074          		JR      NC,BAD_fpp
042739             6075          		; CP      (FTABLE-DTABLE)/3
042739 FE 10       6076          		CP      FTABLE-DTABLE/3
04273B 30 08       6077          		JR      NC,DISPAT_fpp
04273D 08          6078          		EX      AF,AF'
04273E 78          6079          		LD      A,B
04273F B1          6080          		OR      C               ;Both integer?
042740 C4 48 32 04 6081          		CALL    NZ,FLOATA       ;No, so float both
042744 08          6082          		EX      AF,AF'
042745 E5          6083  DISPAT_fpp:			PUSH    HL
042746 21 58 27 04 6084          		LD      HL,DTABLE
04274A C5          6085          		PUSH    BC
04274B 01 03 00 00 6086  			LD	BC, 3		; C = 3
04274F 47          6087  			LD	B, A 		; B = op-code
042750 ED 4C       6088  			MLT 	BC 		;BC = op-code * 3
042752 09          6089  			ADD	HL, BC 		;Add to table base
042753 ED 27       6090  			LD	HL, (HL)	;Get the routine address (24-bit)
042755             6091  
042755             6092  ;        		ADD     A, A            ;A = op-code * 2
042755             6093  ;        		LD      C,A
042755             6094  ;        		LD      B,0             ;BC = op-code * 2
042755             6095  ;        		ADD     HL,BC
042755             6096  ;        		LD      A,(HL)          ;Get low byte
042755             6097  ;        		INC     HL
042755             6098  ;        		LD      H,(HL)          ;Get high byte
042755             6099  ;        		LD      L,A
042755             6100  
042755 C1          6101          		POP     BC
042756 E3          6102          		EX      (SP),HL
042757 C9          6103          		RET                     ;Off to routine
042758             6104  ;
042758             6105  ;Despatch table:
042758             6106  ;
042758 0A 28 04    6107  DTABLE:			DW24  IAND            ;AND (INTEGER)
04275B 78 28 04    6108          		DW24  IBDIV           ;DIV
04275E 1D 28 04    6109          		DW24  IEOR            ;EOR
042761 43 28 04    6110          		DW24  IMOD            ;MOD
042764 30 28 04    6111          		DW24  IOR             ;OR
042767 FE 2A 04    6112          		DW24  ILE             ;<=
04276A 0D 2B 04    6113          		DW24  INE             ;<>
04276D F1 2A 04    6114          		DW24  IGE             ;>=
042770 D6 2A 04    6115          		DW24  ILT             ;<
042773 1A 2B 04    6116          		DW24  IEQ             ;=
042776 66 29 04    6117          		DW24  IMUL            ;*
042779 A1 28 04    6118          		DW24  IADD            ;+
04277C E3 2A 04    6119          		DW24  IGT             ;>
04277F 88 28 04    6120          		DW24  ISUB            ;-
042782 1D 2A 04    6121          		DW24  IPOW            ;^
042785 13 29 04    6122          		DW24  IDIV            ;/
042788             6123  ;
042788 2C 2B 04    6124  FTABLE:			DW24  ABSV_fpp            ;ABS
04278B 12 2F 04    6125          		DW24  ACS_fpp             ;ACS
04278E 50 2E 04    6126          		DW24  ASN_fpp             ;ASN
042791 80 2E 04    6127          		DW24  ATN_fpp             ;ATN
042794 4B 2C 04    6128          		DW24  COS_fpp             ;COS
042797 5A 2B 04    6129          		DW24  DEG_fpp             ;DEG
04279A 07 2D 04    6130          		DW24  EXP_fpp             ;EXP
04279D AE 2B 04    6131          		DW24  INT__fpp            ;INT
0427A0 A5 2D 04    6132          		DW24  LN_fpp              ;LN
0427A3 3A 2E 04    6133          		DW24  LOG_fpp             ;LOG
0427A6 38 2B 04    6134          		DW24  NOTK_fpp            ;NOT
0427A9 64 2B 04    6135          		DW24  RAD_fpp             ;RAD
0427AC 7F 2B 04    6136          		DW24  SGN_fpp             ;SGN
0427AF 58 2C 04    6137          		DW24  SIN_fpp             ;SIN
0427B2 C7 2B 04    6138          		DW24  SQR_fpp             ;SQR
0427B5 25 2C 04    6139          		DW24  TAN_fpp             ;TAN
0427B8             6140  ;
0427B8 D5 32 04    6141  		        DW24  ZERO_fpp            ;ZERO
0427BB E0 2C 04    6142          		DW24  FONE            ;FONE
0427BE 2C 28 04    6143          		DW24  FOR_fpp            ;FOR
0427C1 4C 2B 04    6144          		DW24  PI_fpp              ;PI
0427C4             6145  ;
0427C4 93 2B 04    6146  		        DW24  VAL_fpp             ;VAL
0427C7 1B 2F 04    6147          		DW24  STR_fpp             ;STR$
0427CA             6148  ;
0427CA 7C 31 04    6149          		DW24  SFIX_fpp            ;FIX
0427CD 58 32 04    6150          		DW24  SFLOAT_fpp          ;FLOAT
0427D0             6151  ;
0427D0 A6 32 04    6152  		        DW24  FTEST           ;TEST
0427D3 B8 32 04    6153          		DW24  FCOMP           ;COMPARE
0427D6             6154  ;
0427D6 06 28 04    6155  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0427D9 74 28 04    6156          		DW24  FBDIV           ;DIV
0427DC 19 28 04    6157          		DW24  FEOR            ;EOR
0427DF 3F 28 04    6158          		DW24  FMOD            ;MOD
0427E2 2C 28 04    6159          		DW24  FOR_fpp             ;OR
0427E5 F8 2A 04    6160          		DW24  FLE             ;<=
0427E8 07 2B 04    6161          		DW24  FNE             ;<>
0427EB EB 2A 04    6162          		DW24  FGE             ;>=
0427EE D0 2A 04    6163          		DW24  FLT             ;<
0427F1 14 2B 04    6164          		DW24  FEQ             ;=
0427F4 C0 29 04    6165          		DW24  FMUL            ;*
0427F7 AE 28 04    6166          		DW24  FADD            ;+
0427FA DD 2A 04    6167          		DW24  FGT             ;>
0427FD 95 28 04    6168          		DW24  FSUB            ;-
042800 9D 2A 04    6169          		DW24  FPOW            ;^
042803 17 29 04    6170          		DW24  FDIV            ;/
042806             6171  ;
042806             6172  ;       PAGE
042806             6173  ;
042806             6174  ;ARITHMETIC AND LOGICAL OPERATORS:
042806             6175  ;All take two arguments, in HLH'L'C & DED'E'B.
042806             6176  ;Output in HLH'L'C
042806             6177  ;All registers except IX, IY destroyed.
042806             6178  ; (N.B. FPOW destroys IX).
042806             6179  ;
042806             6180  ;FAND - Floating-point AND.
042806             6181  ;IAND - Integer AND.
042806             6182  ;
042806 CD 70 31 04 6183  FAND:			CALL    FIX2
04280A 7C          6184  IAND:			LD      A,H
04280B A2          6185          		AND     D
04280C 67          6186          		LD      H,A
04280D 7D          6187          		LD      A,L
04280E A3          6188          		AND     E
04280F 6F          6189          		LD      L,A
042810 D9          6190          		EXX
042811 7C          6191          		LD      A,H
042812 A2          6192          		AND     D
042813 67          6193          		LD      H,A
042814 7D          6194          		LD      A,L
042815 A3          6195          		AND     E
042816 6F          6196          		LD      L,A
042817 D9          6197          		EXX
042818 C9          6198          		RET
042819             6199  ;
042819             6200  ;FEOR - Floating-point exclusive-OR.
042819             6201  ;IEOR - Integer exclusive-OR.
042819             6202  ;
042819 CD 70 31 04 6203  FEOR:			CALL    FIX2
04281D 7C          6204  IEOR:			LD      A,H
04281E AA          6205          		XOR     D
04281F 67          6206          		LD      H,A
042820 7D          6207          		LD      A,L
042821 AB          6208          		XOR     E
042822 6F          6209          		LD      L,A
042823 D9          6210          		EXX
042824 7C          6211          		LD      A,H
042825 AA          6212          		XOR     D
042826 67          6213          		LD      H,A
042827 7D          6214          		LD      A,L
042828 AB          6215          		XOR     E
042829 6F          6216          		LD      L,A
04282A D9          6217          		EXX
04282B C9          6218          		RET
04282C             6219  ;
04282C             6220  ;FOR - Floating-point OR.
04282C             6221  ;IOR - Integer OR.
04282C             6222  ;
04282C CD 70 31 04 6223  FOR_fpp:			CALL    FIX2
042830 7C          6224  IOR:			LD      A,H
042831 B2          6225          		OR      D
042832 67          6226          		LD      H,A
042833 7D          6227          		LD      A,L
042834 B3          6228          		OR      E
042835 6F          6229          		LD      L,A
042836 D9          6230          		EXX
042837 7C          6231          		LD      A,H
042838 B2          6232          		OR      D
042839 67          6233          		LD      H,A
04283A 7D          6234          		LD      A,L
04283B B3          6235          		OR      E
04283C 6F          6236          		LD      L,A
04283D D9          6237          		EXX
04283E C9          6238          		RET
04283F             6239  ;
04283F             6240  ;FMOD - Floating-point remainder.
04283F             6241  ;IMOD - Integer remainder.
04283F             6242  ;
04283F CD 70 31 04 6243  FMOD:			CALL    FIX2
042843 7C          6244  IMOD:			LD      A,H
042844 AA          6245          		XOR     D               ;DIV RESULT SIGN
042845 CB 7C       6246          		BIT     7,H
042847 08          6247          		EX      AF,AF'
042848 CB 7C       6248          		BIT     7,H
04284A C4 8C 31 04 6249          		CALL    NZ,NEGATE_fpp       ;MAKE ARGUMENTS +VE
04284E CD 89 32 04 6250          		CALL    SWAP_fpp
042852 CB 7C       6251          		BIT     7,H
042854 C4 8C 31 04 6252          		CALL    NZ,NEGATE_fpp
042858 44          6253          		LD      B,H
042859 4D          6254          		LD      C,L
04285A 21 00 00 00 6255          		LD      HL,0
04285E D9          6256          		EXX
04285F 44          6257          		LD      B,H
042860 4D          6258          		LD      C,L
042861 21 00 00 00 6259          		LD      HL,0
042865 3E DF       6260          		LD      A,-33
042867 CD 16 34 04 6261          		CALL    DIVA            ;DIVIDE
04286B D9          6262          		EXX
04286C 0E 00       6263          		LD      C,0             ;INTEGER MARKER
04286E 08          6264          		EX      AF,AF'
04286F C8          6265          		RET     Z
042870 C3 8C 31 04 6266          		JP      NEGATE_fpp
042874             6267  ;
042874             6268  ;BDIV - Integer division.
042874             6269  ;
042874 CD 70 31 04 6270  FBDIV:			CALL    FIX2
042878 CD 43 28 04 6271  IBDIV:			CALL    IMOD
04287C B7          6272          		OR      A
04287D CD 89 32 04 6273          		CALL    SWAP_fpp
042881 0E 00       6274          		LD      C,0
042883 F0          6275          		RET     P
042884 C3 8C 31 04 6276          		JP      NEGATE_fpp
042888             6277  ;
042888             6278  ;ISUB - Integer subtraction.
042888             6279  ;FSUB - Floating point subtraction with rounding.
042888             6280  ;
042888 CD 24 33 04 6281  ISUB:			CALL    SUB_
04288C E0          6282          		RET     PO
04288D CD 1C 33 04 6283          		CALL    ADD_
042891 CD 4C 32 04 6284          		CALL    FLOAT2
042895 7A          6285  FSUB:			LD      A,D
042896 EE 80       6286          		XOR     80H             ;CHANGE SIGN THEN ADD
042898 57          6287          		LD      D,A
042899 18 13       6288          		JR      FADD
04289B             6289  ;
04289B             6290  ;Reverse subtract.
04289B             6291  ;
04289B 7C          6292  RSUB:			LD      A,H
04289C EE 80       6293          		XOR     80H
04289E 67          6294          		LD      H,A
04289F 18 0D       6295          		JR      FADD
0428A1             6296  ;
0428A1             6297  ;IADD - Integer addition.
0428A1             6298  ;FADD - Floating point addition with rounding.
0428A1             6299  ;
0428A1 CD 1C 33 04 6300  IADD:			CALL    ADD_
0428A5 E0          6301          		RET     PO
0428A6 CD 24 33 04 6302          		CALL    SUB_
0428AA CD 4C 32 04 6303          		CALL    FLOAT2
0428AE 05          6304  FADD:			DEC     B
0428AF 04          6305          		INC     B
0428B0 C8          6306          		RET     Z               ;ARG 2 ZERO_fpp
0428B1 0D          6307          		DEC     C
0428B2 0C          6308          		INC     C
0428B3 CA 89 32 04 6309          		JP      Z,SWAP_fpp          ;ARG 1 ZERO_fpp
0428B7 D9          6310          		EXX
0428B8 01 00 00 00 6311          		LD      BC,0            ;INITIALISE
0428BC D9          6312          		EXX
0428BD 7C          6313          		LD      A,H
0428BE AA          6314          		XOR     D               ;XOR SIGNS
0428BF F5          6315          		PUSH    AF
0428C0 78          6316          		LD      A,B
0428C1 B9          6317          		CP      C               ;COMPARE EXPONENTS
0428C2 DC 89 32 04 6318          		CALL    C,SWAP_fpp          ;MAKE DED'E'B LARGEST
0428C6 78          6319          		LD      A,B
0428C7 CB FC       6320          		SET     7,H             ;IMPLIED 1
0428C9 C4 5D 31 04 6321          		CALL    NZ,FIX          ;ALIGN
0428CD F1          6322          		POP     AF
0428CE 7A          6323          		LD      A,D             ;SIGN OF LARGER
0428CF CB FA       6324          		SET     7,D             ;IMPLIED 1
0428D1 FA E1 28 04 6325          		JP      M,FADD3         ;SIGNS DIFFERENT
0428D5 CD 1C 33 04 6326          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0428D9 DC 91 32 04 6327          		CALL    C,DIV2          ;NORMALISE
0428DD CB FC       6328          		SET     7,H
0428DF 18 0D       6329          		JR      FADD4
0428E1             6330  ;
0428E1 CD 24 33 04 6331  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0428E5 DC A4 31 04 6332          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0428E9 CD 23 32 04 6333          		CALL    FLO48
0428ED 2F          6334          		CPL                     ;CHANGE RESULT SIGN
0428EE D9          6335  FADD4:			EXX
0428EF EB          6336          		EX      DE,HL
0428F0 21 00 80 00 6337          		LD      HL,8000H
0428F4 B7          6338          		OR      A               ;CLEAR CARRY
0428F5 52 ED 42    6339          		SBC.S   HL,BC
0428F8 EB          6340          		EX      DE,HL
0428F9 D9          6341          		EXX
0428FA CC 83 32 04 6342          		CALL    Z,ODD           ;ROUND UNBIASSED
0428FE DC 71 32 04 6343          		CALL    C,ADD1_fpp          ;ROUND UP
042902 DC 9E 32 04 6344          		CALL    C,INCC
042906 CB BC       6345          		RES     7,H
042908 0D          6346          		DEC     C
042909 0C          6347          		INC     C
04290A CA D5 32 04 6348          		JP      Z,ZERO_fpp
04290E B7          6349          		OR      A               ;RESULT SIGNQ
04290F F0          6350          		RET     P               ;POSITIVE
042910 CB FC       6351          		SET     7,H             ;NEGATIVE
042912 C9          6352          		RET
042913             6353  ;
042913             6354  ;IDIV - Integer division.
042913             6355  ;FDIV - Floating point division with rounding.
042913             6356  ;
042913 CD 4C 32 04 6357  IDIV:			CALL    FLOAT2
042917 05          6358  FDIV:			DEC     B               ;TEST FOR_fpp ZERO_fpp
042918 04          6359          		INC     B
042919 3E 12       6360          		LD      A,DIVBY0
04291B CA 2F 27 04 6361          		JP      Z,ERROR_FPP_         ;"Division by zero"
04291F 0D          6362          		DEC     C               ;TEST FOR_fpp ZERO_fpp
042920 0C          6363          		INC     C
042921 C8          6364          		RET     Z
042922 7C          6365          		LD      A,H
042923 AA          6366          		XOR     D               ;CALC. RESULT SIGN
042924 08          6367          		EX      AF,AF'          ;SAVE SIGN
042925 CB FA       6368          		SET     7,D             ;REPLACE IMPLIED 1's
042927 CB FC       6369          		SET     7,H
042929 C5          6370          		PUSH    BC              ;SAVE EXPONENTS
04292A 42          6371          		LD      B,D             ;LOAD REGISTERS
04292B 4B          6372          		LD      C,E
04292C 11 00 00 00 6373          		LD      DE,0
042930 D9          6374          		EXX
042931 42          6375          		LD      B,D
042932 4B          6376          		LD      C,E
042933 11 00 00 00 6377          		LD      DE,0
042937 3E E0       6378          		LD      A,-32           ;LOOP COUNTER
042939 CD 16 34 04 6379          		CALL    DIVA            ;DIVIDE
04293D D9          6380          		EXX
04293E CB 7A       6381          		BIT     7,D
042940 D9          6382          		EXX
042941 CC 35 34 04 6383          		CALL    Z,DIVB          ;NORMALISE & INC A
042945 EB          6384          		EX      DE,HL
042946 D9          6385          		EXX
042947 CB 38       6386          		SRL     B               ;DIVISOR/2
042949 CB 19       6387          		RR      C
04294B B7          6388          		OR      A               ;CLEAR CARRY
04294C 52 ED 42    6389          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
04294F 3F          6390          		CCF
042950 EB          6391          		EX      DE,HL           ;RESULT IN HLH'L'
042951 CC 83 32 04 6392          		CALL    Z,ODD           ;ROUND UNBIASSED
042955 DC 71 32 04 6393          		CALL    C,ADD1_fpp          ;ROUND UP
042959 C1          6394          		POP     BC              ;RESTORE EXPONENTS
04295A DC 9E 32 04 6395          		CALL    C,INCC
04295E 1F          6396          		RRA                     ;LSB OF A TO CARRY
04295F 79          6397          		LD      A,C             ;COMPUTE NEW EXPONENT
042960 98          6398          		SBC     A,B
042961 3F          6399          		CCF
042962 C3 03 2A 04 6400          		JP      CHKOVF
042966             6401  ;
042966             6402  ;IMUL - Integer multiplication.
042966             6403  ;
042966 7C          6404  IMUL:			LD      A,H
042967 AA          6405          		XOR     D
042968 08          6406          		EX      AF,AF'          ;SAVE RESULT SIGN
042969 CB 7C       6407          		BIT     7,H
04296B C4 8C 31 04 6408          		CALL    NZ,NEGATE_fpp
04296F CD 89 32 04 6409          		CALL    SWAP_fpp
042973 CB 7C       6410          		BIT     7,H
042975 C4 8C 31 04 6411          		CALL    NZ,NEGATE_fpp
042979 44          6412          		LD      B,H
04297A 4D          6413          		LD      C,L
04297B 21 00 00 00 6414          		LD      HL,0
04297F D9          6415          		EXX
042980 44          6416          		LD      B,H
042981 4D          6417          		LD      C,L
042982 21 00 00 00 6418          		LD      HL,0
042986 3E DF       6419          		LD      A,-33
042988 CD 4D 34 04 6420          		CALL    MULA            ;MULTIPLY
04298C D9          6421          		EXX
04298D 0E BF       6422          		LD      C,191           ;PRESET EXPONENT
04298F CD B1 32 04 6423          		CALL    TEST_fpp            ;TEST RANGE
042993 20 0F       6424          		JR      NZ,IMUL1        ;TOO BIG
042995 CB 7A       6425          		BIT     7,D
042997 20 0B       6426          		JR      NZ,IMUL1
042999 CD 89 32 04 6427          		CALL    SWAP_fpp
04299D 4A          6428          		LD      C,D             ;INTEGER MARKER
04299E 08          6429          		EX      AF,AF'
04299F F0          6430          		RET     P
0429A0 C3 8C 31 04 6431          		JP      NEGATE_fpp
0429A4             6432  ;
0429A4 0D          6433  IMUL1:			DEC     C
0429A5 D9          6434          		EXX
0429A6 CB 23       6435          		SLA     E
0429A8 CB 12       6436          		RL      D
0429AA D9          6437          		EXX
0429AB CB 13       6438          		RL      E
0429AD CB 12       6439          		RL      D
0429AF D9          6440          		EXX
0429B0 52 ED 6A    6441          		ADC.S   HL,HL
0429B3 D9          6442          		EXX
0429B4 52 ED 6A    6443          		ADC.S   HL,HL
0429B7 F2 A4 29 04 6444          		JP      P,IMUL1         ;NORMALISE
0429BB 08          6445          		EX      AF,AF'
0429BC F8          6446          		RET     M
0429BD CB BC       6447          		RES     7,H             ;POSITIVE
0429BF C9          6448          		RET
0429C0             6449  ;
0429C0             6450  ;FMUL - Floating point multiplication with rounding.
0429C0             6451  ;
0429C0 05          6452  FMUL:			DEC     B               ;TEST FOR_fpp ZERO_fpp
0429C1 04          6453          		INC     B
0429C2 CA D5 32 04 6454          		JP      Z,ZERO_fpp
0429C6 0D          6455          		DEC     C               ;TEST FOR_fpp ZERO_fpp
0429C7 0C          6456          		INC     C
0429C8 C8          6457          		RET     Z
0429C9 7C          6458          		LD      A,H
0429CA AA          6459          		XOR     D               ;CALC. RESULT SIGN
0429CB 08          6460          		EX      AF,AF'
0429CC CB FA       6461          		SET     7,D             ;REPLACE IMPLIED 1's
0429CE CB FC       6462          		SET     7,H
0429D0 C5          6463          		PUSH    BC              ;SAVE EXPONENTS
0429D1 44          6464          		LD      B,H             ;LOAD REGISTERS
0429D2 4D          6465          		LD      C,L
0429D3 21 00 00 00 6466          		LD      HL,0
0429D7 D9          6467          		EXX
0429D8 44          6468          		LD      B,H
0429D9 4D          6469          		LD      C,L
0429DA 21 00 00 00 6470          		LD      HL,0
0429DE 3E E0       6471          		LD      A,-32           ;LOOP COUNTER
0429E0 CD 4D 34 04 6472          		CALL    MULA            ;MULTIPLY
0429E4 DC 63 34 04 6473          		CALL    C,MULB          ;NORMALISE & INC A
0429E8 D9          6474          		EXX
0429E9 E5          6475          		PUSH    HL
0429EA 21 00 80 00 6476          		LD      HL,8000H
0429EE B7          6477          		OR      A               ;CLEAR CARRY
0429EF 52 ED 52    6478          		SBC.S   HL,DE
0429F2 E1          6479          		POP     HL
0429F3 CC 83 32 04 6480          		CALL    Z,ODD           ;ROUND UNBIASSED
0429F7 DC 71 32 04 6481          		CALL    C,ADD1_fpp          ;ROUND UP
0429FB C1          6482          		POP     BC              ;RESTORE EXPONENTS
0429FC DC 9E 32 04 6483          		CALL    C,INCC
042A00 1F          6484          		RRA                     ;LSB OF A TO CARRY
042A01 79          6485          		LD      A,C             ;COMPUTE NEW EXPONENT
042A02 88          6486          		ADC     A,B
042A03 38 06       6487  CHKOVF:			JR      C,CHKO1
042A05 F2 D5 32 04 6488          		JP      P,ZERO_fpp          ;UNDERFLOW
042A09 18 04       6489          		JR      CHKO2
042A0B FA A0 32 04 6490  CHKO1:			JP      M,OFLOW         ;OVERFLOW
042A0F C6 80       6491  CHKO2:			ADD     A,80H
042A11 4F          6492          		LD      C,A
042A12 CA D5 32 04 6493          		JP      Z,ZERO_fpp
042A16 08          6494          		EX      AF,AF'          ;RESTORE SIGN BIT
042A17 CB BC       6495          		RES     7,H
042A19 F0          6496          		RET     P
042A1A CB FC       6497          		SET     7,H
042A1C C9          6498          		RET
042A1D             6499  ;
042A1D             6500  ;IPOW - Integer involution.
042A1D             6501  ;
042A1D CD 89 32 04 6502  IPOW:			CALL    SWAP_fpp
042A21 CB 7C       6503          		BIT     7,H
042A23 F5          6504          		PUSH    AF              ;SAVE SIGN
042A24 C4 8C 31 04 6505          		CALL    NZ,NEGATE_fpp
042A28 48          6506  IPOW0:			LD      C,B
042A29 06 20       6507          		LD      B,32            ;LOOP COUNTER
042A2B CD 41 33 04 6508  IPOW1:			CALL    X2
042A2F 38 08       6509          		JR      C,IPOW2
042A31 10 F8       6510          		DJNZ    IPOW1
042A33 F1          6511          		POP     AF
042A34 D9          6512          		EXX
042A35 2C          6513          		INC     L               ;RESULT=1
042A36 D9          6514          		EXX
042A37 4C          6515          		LD      C,H
042A38 C9          6516          		RET
042A39             6517  ;
042A39 F1          6518  IPOW2:			POP     AF
042A3A C5          6519          		PUSH    BC
042A3B EB          6520          		EX      DE,HL
042A3C E5          6521          		PUSH    HL
042A3D D9          6522          		EXX
042A3E EB          6523          		EX      DE,HL
042A3F E5          6524          		PUSH    HL
042A40 D9          6525          		EXX
042A41 DD 21 00 00 6526          		LD      IX,0
       00          
042A46 DD 39       6527          		ADD     IX,SP
042A48 28 48       6528          		JR      Z,IPOW4
042A4A C5          6529          		PUSH    BC
042A4B D9          6530          		EXX
042A4C D5          6531          		PUSH    DE
042A4D D9          6532          		EXX
042A4E D5          6533          		PUSH    DE
042A4F CD 58 32 04 6534          		CALL    SFLOAT_fpp
042A53 CD 8C 2D 04 6535          		CALL    RECIP
042A57 DD 71 04    6536          		LD      (IX+4),C
042A5A D9          6537          		EXX
042A5B DD 75 00    6538          		LD      (IX+0),L
042A5E DD 74 01    6539          		LD      (IX+1),H
042A61 D9          6540          		EXX
042A62 DD 75 02    6541          		LD      (IX+2),L
042A65 DD 74 03    6542          		LD      (IX+3),H
042A68 18 21       6543          		JR      IPOW5
042A6A             6544  ;
042A6A C5          6545  IPOW3:			PUSH    BC
042A6B D9          6546          		EXX
042A6C CB 23       6547          		SLA     E
042A6E CB 12       6548          		RL      D
042A70 D5          6549          		PUSH    DE
042A71 D9          6550          		EXX
042A72 CB 13       6551          		RL      E
042A74 CB 12       6552          		RL      D
042A76 D5          6553          		PUSH    DE
042A77 3E 0A       6554          		LD      A,'*' & 0FH
042A79 F5          6555          		PUSH    AF
042A7A CD 55 33 04 6556          		CALL    COPY_
042A7E CD 35 27 04 6557          		CALL    OP              ;SQUARE
042A82 F1          6558          		POP     AF
042A83 CD 81 30 04 6559          		CALL    DLOAD5
042A87 DC 35 27 04 6560          		CALL    C,OP            ;MULTIPLY BY X
042A8B D1          6561  IPOW5:			POP     DE
042A8C D9          6562          		EXX
042A8D D1          6563          		POP     DE
042A8E D9          6564          		EXX
042A8F 79          6565          		LD      A,C
042A90 C1          6566          		POP     BC
042A91 4F          6567          		LD      C,A
042A92 10 D6       6568  IPOW4:			DJNZ    IPOW3
042A94 F1          6569          		POP     AF
042A95 F1          6570          		POP     AF
042A96 F1          6571          		POP     AF
042A97 C9          6572          		RET
042A98             6573  ;
042A98 F1          6574  FPOW0:			POP     AF
042A99 F1          6575          		POP     AF
042A9A F1          6576          		POP     AF
042A9B 18 8B       6577          		JR      IPOW0
042A9D             6578  ;
042A9D             6579  ;FPOW - Floating-point involution.
042A9D             6580  ;
042A9D CB 7A       6581  FPOW:			BIT     7,D
042A9F F5          6582          		PUSH    AF
042AA0 CD 89 32 04 6583          		CALL    SWAP_fpp
042AA4 CD 65 33 04 6584          		CALL    PUSH5
042AA8 0D          6585          		DEC     C
042AA9 0C          6586          		INC     C
042AAA 28 EC       6587          		JR      Z,FPOW0
042AAC 3E 9E       6588          		LD      A,158
042AAE B9          6589          		CP      C
042AAF 38 0A       6590          		JR      C,FPOW1
042AB1 3C          6591          		INC     A
042AB2 CD 5D 31 04 6592          		CALL    FIX
042AB6 08          6593          		EX      AF,AF'
042AB7 F2 98 2A 04 6594          		JP      P,FPOW0
042ABB CD 89 32 04 6595  FPOW1:			CALL    SWAP_fpp
042ABF CD A9 2D 04 6596          		CALL    LN0
042AC3 CD 6E 33 04 6597          		CALL    POP5
042AC7 F1          6598          		POP     AF
042AC8 CD C0 29 04 6599          		CALL    FMUL
042ACC C3 0B 2D 04 6600          		JP      EXP0
042AD0             6601  ;
042AD0             6602  ;Integer and floating-point compare.
042AD0             6603  ;Result is FOR_ (-1) or FALSE (0).
042AD0             6604  ;
042AD0 CD DF 32 04 6605  FLT:			CALL    FCP
042AD4 18 04       6606          		JR      ILT1
042AD6 CD D1 32 04 6607  ILT:			CALL    ICP
042ADA D0          6608  ILT1:			RET     NC
042ADB 18 42       6609          		JR      FOR_
042ADD             6610  ;
042ADD CD DF 32 04 6611  FGT:			CALL    FCP
042AE1 18 04       6612          		JR      IGT1
042AE3 CD D1 32 04 6613  IGT:			CALL    ICP
042AE7 C8          6614  IGT1:			RET     Z
042AE8 D8          6615          		RET     C
042AE9 18 34       6616          		JR      FOR_
042AEB             6617  ;
042AEB CD DF 32 04 6618  FGE:			CALL    FCP
042AEF 18 04       6619          		JR      IGE1
042AF1 CD D1 32 04 6620  IGE:			CALL    ICP
042AF5 D8          6621  IGE1:			RET     C
042AF6 18 27       6622          		JR      FOR_
042AF8             6623  ;
042AF8 CD DF 32 04 6624  FLE:			CALL    FCP
042AFC 18 04       6625          		JR      ILE1
042AFE CD D1 32 04 6626  ILE:			CALL    ICP
042B02 28 1B       6627  ILE1:			JR      Z,FOR_
042B04 D0          6628          		RET     NC
042B05 18 18       6629          		JR      FOR_
042B07             6630  ;
042B07 CD DF 32 04 6631  FNE:			CALL    FCP
042B0B 18 04       6632          		JR      INE1
042B0D CD D1 32 04 6633  INE:			CALL    ICP
042B11 C8          6634  INE1:			RET     Z
042B12 18 0B       6635          		JR      FOR_
042B14             6636  ;
042B14 CD DF 32 04 6637  FEQ:			CALL    FCP
042B18 18 04       6638          		JR      IEQ1
042B1A CD D1 32 04 6639  IEQ:			CALL    ICP
042B1E C0          6640  IEQ1:			RET     NZ
042B1F 21 FF FF FF 6641  FOR_:			LD      HL,-1
042B23 D9          6642          		EXX
042B24 21 FF FF FF 6643          		LD      HL,-1
042B28 D9          6644          		EXX
042B29 AF          6645          		XOR     A
042B2A 4F          6646          		LD      C,A
042B2B C9          6647          		RET
042B2C             6648  ;
042B2C             6649  ;FUNCTIONS:
042B2C             6650  ;
042B2C             6651  ;Result returned in HLH'L'C (floating point)
042B2C             6652  ;Result returned in HLH'L' (C=0) (integer)
042B2C             6653  ;All registers except IY destroyed.
042B2C             6654  ;
042B2C             6655  ;ABS - Absolute value
042B2C             6656  ;Result is numeric, variable type.
042B2C             6657  ;
042B2C CB 7C       6658  ABSV_fpp:			BIT     7,H
042B2E C8          6659          		RET     Z               ;POSITIVE/ZERO_fpp
042B2F 0D          6660          		DEC     C
042B30 0C          6661          		INC     C
042B31 CA 8C 31 04 6662          		JP      Z,NEGATE_fpp        ;INTEGER
042B35 CB BC       6663          		RES     7,H
042B37 C9          6664          		RET
042B38             6665  ;
042B38             6666  ;NOT - Complement integer.
042B38             6667  ;Result is integer numeric.
042B38             6668  ;
042B38 CD 7C 31 04 6669  NOTK_fpp:			CALL    SFIX_fpp
042B3C 7C          6670          		LD      A,H
042B3D 2F          6671          		CPL
042B3E 67          6672          		LD      H,A
042B3F 7D          6673          		LD      A,L
042B40 2F          6674          		CPL
042B41 6F          6675          		LD      L,A
042B42 D9          6676          		EXX
042B43 7C          6677          		LD      A,H
042B44 2F          6678          		CPL
042B45 67          6679          		LD      H,A
042B46 7D          6680          		LD      A,L
042B47 2F          6681          		CPL
042B48 6F          6682          		LD      L,A
042B49 D9          6683          		EXX
042B4A AF          6684          		XOR     A               ;NUMERIC MARKER
042B4B C9          6685          		RET
042B4C             6686  ;
042B4C             6687  ;PI - Return PI (3.141592654)
042B4C             6688  ;Result is floating-point numeric.
042B4C             6689  ;
042B4C 21 0F 49 00 6690  PI_fpp:			LD      HL,490FH
042B50 D9          6691          		EXX
042B51 21 A2 DA 00 6692          		LD      HL,0DAA2H
042B55 D9          6693          		EXX
042B56 0E 81       6694          		LD      C,81H
042B58 AF          6695          		XOR     A               ;NUMERIC MARKER
042B59 C9          6696          		RET
042B5A             6697  ;
042B5A             6698  ;DEG - Convert radians to degrees
042B5A             6699  ;Result is floating-point numeric.
042B5A             6700  ;
042B5A CD 6E 2B 04 6701  DEG_fpp:			CALL    FPI180
042B5E CD C0 29 04 6702          		CALL    FMUL
042B62 AF          6703          		XOR     A
042B63 C9          6704          		RET
042B64             6705  ;
042B64             6706  ;RAD - Convert degrees to radians
042B64             6707  ;Result is floating-point numeric.
042B64             6708  ;
042B64 CD 6E 2B 04 6709  RAD_fpp:			CALL    FPI180
042B68 CD 17 29 04 6710          		CALL    FDIV
042B6C AF          6711          		XOR     A
042B6D C9          6712          		RET
042B6E             6713  ;
042B6E             6714  ;180/PI
042B6E             6715  ;
042B6E CD 58 32 04 6716  FPI180:			CALL    SFLOAT_fpp
042B72 11 2E 65 00 6717          		LD      DE,652EH
042B76 D9          6718          		EXX
042B77 11 D3 E0 00 6719          		LD      DE,0E0D3H
042B7B D9          6720          		EXX
042B7C 06 85       6721          		LD      B,85H
042B7E C9          6722          		RET
042B7F             6723  ;
042B7F             6724  ;SGN - Return -1, 0 or +1
042B7F             6725  ;Result is integer numeric.
042B7F             6726  ;
042B7F CD B1 32 04 6727  SGN_fpp:			CALL    TEST_fpp
042B83 B1          6728          		OR      C
042B84 C8          6729          		RET     Z               ;ZERO
042B85 CB 7C       6730          		BIT     7,H
042B87 C2 2C 28 04 6731          		JP      NZ,FOR_fpp         ;-1
042B8B CD D5 32 04 6732          		CALL    ZERO_fpp
042B8F C3 71 32 04 6733          		JP      ADD1_fpp            ;1
042B93             6734  ;
042B93             6735  ;VAL - Return numeric value of string.
042B93             6736  ;Input: ASCII string at IX
042B93             6737  ;Result is variable type numeric.
042B93             6738  ;
042B93 CD EF 34 04 6739  VAL_fpp:			CALL    SIGNQ
042B97 F5          6740          		PUSH    AF
042B98 CD 9F 30 04 6741          		CALL    CON_fpp
042B9C F1          6742          		POP     AF
042B9D FE 2D       6743          		CP      '-'
042B9F 3E 00       6744          		LD      A,0             ;NUMERIC MARKER
042BA1 C0          6745          		RET     NZ
042BA2 0D          6746          		DEC     C
042BA3 0C          6747          		INC     C
042BA4 CA 8C 31 04 6748          		JP      Z,NEGATE_fpp        ;ZERO/INTEGER
042BA8 7C          6749          		LD      A,H
042BA9 EE 80       6750          		XOR     80H             ;CHANGE SIGN (FP)
042BAB 67          6751          		LD      H,A
042BAC AF          6752          		XOR     A
042BAD C9          6753          		RET
042BAE             6754  ;
042BAE             6755  ;INT - Floor function
042BAE             6756  ;Result is integer numeric.
042BAE             6757  ;
042BAE 0D          6758  INT__fpp:			DEC     C
042BAF 0C          6759          		INC     C
042BB0 C8          6760          		RET     Z               ;ZERO/INTEGER
042BB1 3E 9F       6761          		LD      A,159
042BB3 44          6762          		LD      B,H             ;B7=SIGN BIT
042BB4 CD 5D 31 04 6763          		CALL    FIX
042BB8 08          6764          		EX      AF,AF'
042BB9 A0          6765          		AND     B
042BBA FC 71 32 04 6766          		CALL    M,ADD1_fpp          ;NEGATIVE NON-INTEGER
042BBE 78          6767          		LD      A,B
042BBF B7          6768          		OR      A
042BC0 FC 8C 31 04 6769          		CALL    M,NEGATE_fpp
042BC4 AF          6770          		XOR     A
042BC5 4F          6771          		LD      C,A
042BC6 C9          6772          		RET
042BC7             6773  ;
042BC7             6774  ;SQR - square root
042BC7             6775  ;Result is floating-point numeric.
042BC7             6776  ;
042BC7 CD 58 32 04 6777  SQR_fpp:			CALL    SFLOAT_fpp
042BCB CB 7C       6778  SQR0:			BIT     7,H
042BCD 3E 15       6779          		LD      A,NGROOT
042BCF C2 2F 27 04 6780          		JP      NZ,ERROR_FPP_        ;"-ve root"
042BD3 0D          6781          		DEC     C
042BD4 0C          6782          		INC     C
042BD5 C8          6783          		RET     Z               ;ZERO
042BD6 CB FC       6784          		SET     7,H             ;IMPLIED 1
042BD8 CB 41       6785          		BIT     0,C
042BDA CC 91 32 04 6786          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
042BDE 79          6787          		LD      A,C
042BDF D6 80       6788          		SUB     80H
042BE1 CB 2F       6789          		SRA     A               ;HALVE EXPONENT
042BE3 C6 80       6790          		ADD     A,80H
042BE5 4F          6791          		LD      C,A
042BE6 C5          6792          		PUSH    BC              ;SAVE EXPONENT
042BE7 EB          6793          		EX      DE,HL
042BE8 21 00 00 00 6794          		LD      HL,0
042BEC 44          6795          		LD      B,H
042BED 4D          6796          		LD      C,L
042BEE D9          6797          		EXX
042BEF EB          6798          		EX      DE,HL
042BF0 21 00 00 00 6799          		LD      HL,0
042BF4 44          6800          		LD      B,H
042BF5 4D          6801          		LD      C,L
042BF6 3E E1       6802          		LD      A,-31
042BF8 CD 87 34 04 6803          		CALL    SQRA            ;ROOT
042BFC D9          6804          		EXX
042BFD CB 78       6805          		BIT     7,B
042BFF D9          6806          		EXX
042C00 CC 87 34 04 6807          		CALL    Z,SQRA          ;NORMALISE & INC A
042C04 CD C8 34 04 6808          		CALL    SQRB
042C08 B7          6809          		OR      A               ;CLEAR CARRY
042C09 CD 35 34 04 6810          		CALL    DIVB
042C0D CB 1B       6811          		RR      E               ;LSB TO CARRY
042C0F 60          6812          		LD      H,B
042C10 69          6813          		LD      L,C
042C11 D9          6814          		EXX
042C12 60          6815          		LD      H,B
042C13 69          6816          		LD      L,C
042C14 DC 71 32 04 6817          		CALL    C,ADD1_fpp          ;ROUND UP
042C18 C1          6818          		POP     BC              ;RESTORE EXPONENT
042C19 DC 9E 32 04 6819          		CALL    C,INCC
042C1D 1F          6820          		RRA
042C1E 9F          6821          		SBC     A,A
042C1F 81          6822          		ADD     A,C
042C20 4F          6823          		LD      C,A
042C21 CB BC       6824          		RES     7,H             ;POSITIVE
042C23 AF          6825          		XOR     A
042C24 C9          6826          		RET
042C25             6827  ;
042C25             6828  ;TAN - Tangent function
042C25             6829  ;Result is floating-point numeric.
042C25             6830  ;
042C25 CD 58 32 04 6831  TAN_fpp:			CALL    SFLOAT_fpp
042C29 CD 65 33 04 6832          		CALL    PUSH5
042C2D CD 4F 2C 04 6833          		CALL    COS0
042C31 CD 6E 33 04 6834          		CALL    POP5
042C35 CD 65 33 04 6835          		CALL    PUSH5
042C39 CD 89 32 04 6836          		CALL    SWAP_fpp
042C3D CD 5C 2C 04 6837          		CALL    SIN0
042C41 CD 6E 33 04 6838          		CALL    POP5
042C45 CD 17 29 04 6839          		CALL    FDIV
042C49 AF          6840          		XOR     A               ;NUMERIC MARKER
042C4A C9          6841          		RET
042C4B             6842  ;
042C4B             6843  ;COS - Cosine function
042C4B             6844  ;Result is floating-point numeric.
042C4B             6845  ;
042C4B CD 58 32 04 6846  COS_fpp:			CALL    SFLOAT_fpp
042C4F CD B4 31 04 6847  COS0:			CALL    SCALE
042C53 1C          6848          		INC     E
042C54 1C          6849          		INC     E
042C55 7B          6850          		LD      A,E
042C56 18 10       6851          		JR      SIN1
042C58             6852  ;
042C58             6853  ;SIN - Sine function
042C58             6854  ;Result is floating-point numeric.
042C58             6855  ;
042C58 CD 58 32 04 6856  SIN_fpp:			CALL    SFLOAT_fpp
042C5C E5          6857  SIN0:			PUSH    HL              ;H7=SIGN
042C5D CD B4 31 04 6858          		CALL    SCALE
042C61 F1          6859          		POP     AF
042C62 07          6860          		RLCA
042C63 07          6861          		RLCA
042C64 07          6862          		RLCA
042C65 E6 04       6863          		AND     4
042C67 AB          6864          		XOR     E
042C68 F5          6865  SIN1:			PUSH    AF              ;OCTANT
042C69 CB BC       6866          		RES     7,H
042C6B 1F          6867          		RRA
042C6C CD FA 2C 04 6868          		CALL    PIBY4
042C70 DC 9B 28 04 6869          		CALL    C,RSUB          ;X=(PI_fpp/4)-X
042C74 F1          6870          		POP     AF
042C75 F5          6871          		PUSH    AF
042C76 E6 03       6872          		AND     3
042C78 E2 B1 2C 04 6873          		JP      PO,SIN2         ;USE COSINE APPROX.
042C7C CD 65 33 04 6874          		CALL    PUSH5           ;SAVE X
042C80 CD 5D 33 04 6875          		CALL    SQUARE          ;PUSH X*X
042C84 CD A2 33 04 6876          		CALL    POLY
042C88 B7 A8       6877          		DW	0A8B7H          ;a(8)
042C8A 11 36       6878          		DW	3611H
042C8C 6D          6879          		DB	6DH
042C8D 26 DE       6880          		DW	0DE26H          ;a(6)
042C8F 05 D0       6881          		DW	0D005H
042C91 73          6882          		DB	73H
042C92 C0 80       6883          		DW	80C0H           ;a(4)
042C94 88 08       6884          		DW	888H
042C96 79          6885          		DB	79H
042C97 9D AA       6886          		DW	0AA9DH          ;a(2)
042C99 AA AA       6887          		DW	0AAAAH
042C9B 7D          6888          		DB	7DH
042C9C 00 00       6889          		DW	0               ;a(0)
042C9E 00 00       6890          		DW	0
042CA0 80          6891          		DB	80H
042CA1 CD 6E 33 04 6892          		CALL    POP5
042CA5 CD 6E 33 04 6893          		CALL    POP5
042CA9 CD C0 29 04 6894          		CALL    FMUL
042CAD C3 D6 2C 04 6895          		JP      SIN3
042CB1             6896  ;
042CB1 CD 5D 33 04 6897  SIN2:			CALL    SQUARE          ;PUSH X*X
042CB5 CD A2 33 04 6898          		CALL    POLY
042CB9 71 D5       6899          		DW	0D571H          ;b(8)
042CBB 78 4C       6900          		DW	4C78H
042CBD 70          6901          		DB	70H
042CBE AF 94       6902          		DW	94AFH           ;b(6)
042CC0 03 B6       6903          		DW	0B603H
042CC2 76          6904          		DB	76H
042CC3 C8 9C       6905          		DW	9CC8H           ;b(4)
042CC5 AA 2A       6906          		DW	2AAAH
042CC7 7B          6907          		DB	7BH
042CC8 DD FF       6908          		DW	0FFDDH          ;b(2)
042CCA FF FF       6909          		DW	0FFFFH
042CCC 7E          6910          		DB	7EH
042CCD 00 00       6911          		DW	0               ;b(0)
042CCF 00 00       6912          		DW	0
042CD1 80          6913          		DB	80H
042CD2 CD 6E 33 04 6914          		CALL    POP5
042CD6 F1          6915  SIN3:			POP     AF
042CD7 E6 04       6916          		AND     4
042CD9 C8          6917          		RET     Z
042CDA 0D          6918          		DEC     C
042CDB 0C          6919          		INC     C
042CDC C8          6920          		RET     Z               ;ZERO
042CDD CB FC       6921          		SET     7,H             ;MAKE NEGATIVE
042CDF C9          6922          		RET
042CE0             6923  ;
042CE0             6924  ;Floating-point one:
042CE0             6925  ;
042CE0 21 00 00 00 6926  FONE:			LD      HL,0
042CE4 D9          6927          		EXX
042CE5 21 00 00 00 6928          		LD      HL,0
042CE9 D9          6929          		EXX
042CEA 0E 80       6930          		LD      C,80H
042CEC C9          6931          		RET
042CED             6932  ;
042CED 11 00 00 00 6933  DONE:			LD      DE,0
042CF1 D9          6934          		EXX
042CF2 11 00 00 00 6935          		LD      DE,0
042CF6 D9          6936          		EXX
042CF7 06 80       6937          		LD      B,80H
042CF9 C9          6938          		RET
042CFA             6939  ;
042CFA 11 0F 49 00 6940  PIBY4:			LD      DE,490FH
042CFE D9          6941          		EXX
042CFF 11 A2 DA 00 6942          		LD      DE,0DAA2H
042D03 D9          6943          		EXX
042D04 06 7F       6944          		LD      B,7FH
042D06 C9          6945          		RET
042D07             6946  ;
042D07             6947  ;EXP - Exponential function
042D07             6948  ;Result is floating-point numeric.
042D07             6949  ;
042D07 CD 58 32 04 6950  EXP_fpp:			CALL    SFLOAT_fpp
042D0B CD 98 2D 04 6951  EXP0:			CALL    LN2             ;LN(2)
042D0F D9          6952          		EXX
042D10 1D          6953  	        	DEC     E
042D11 01 CF D1 00 6954  		        LD      BC,0D1CFH       ;0.6931471805599453
042D15 D9          6955          		EXX
042D16 E5          6956          		PUSH    HL              ;H7=SIGN
042D17 CD C7 31 04 6957          		CALL    MOD48           ;"MODULUS"
042D1B F1          6958          		POP     AF
042D1C CB 7B       6959          		BIT     7,E
042D1E 28 0B       6960          		JR      Z,EXP1
042D20 17          6961          		RLA
042D21 DA D5 32 04 6962          		JP      C,ZERO_fpp
042D25 3E 18       6963          		LD      A,EXPRNG
042D27 C3 2F 27 04 6964          		JP      ERROR_FPP_           ;"Exp range"
042D2B             6965  ;
042D2B E6 80       6966  EXP1:			AND     80H
042D2D B3          6967          		OR      E
042D2E F5          6968          		PUSH    AF              ;INTEGER PART
042D2F CB BC       6969          		RES     7,H
042D31 CD 65 33 04 6970          		CALL    PUSH5           ;PUSH X*LN_fpp(2)
042D35 CD A2 33 04 6971          		CALL    POLY
042D39 72 40       6972          		DW	4072H           ;a(7)
042D3B 2E 94       6973          		DW	942EH
042D3D 73          6974          		DB	73H
042D3E 65 6F       6975          		DW	6F65H           ;a(6)
042D40 4F 2E       6976          		DW	2E4FH
042D42 76          6977          		DB	76H
042D43 37 6D       6978          		DW	6D37H           ;a(5)
042D45 02 88       6979          		DW	8802H
042D47 79          6980          		DB	79H
042D48 12 E5       6981          		DW	0E512H          ;a(4)
042D4A A0 2A       6982          		DW	2AA0H
042D4C 7B          6983          		DB	7BH
042D4D 14 4F       6984          		DW	4F14H           ;a(3)
042D4F AA AA       6985          		DW	0AAAAH
042D51 7D          6986          		DB	7DH
042D52 56 FD       6987          		DW	0FD56H          ;a(2)
042D54 FF 7F       6988          		DW	7FFFH
042D56 7E          6989          		DB	7EH
042D57 FE FF       6990          		DW	0FFFEH          ;a(1)
042D59 FF FF       6991          		DW	0FFFFH
042D5B 7F          6992          		DB	7FH
042D5C 00 00       6993          		DW	0               ;a(0)
042D5E 00 00       6994          		DW	0
042D60 80          6995          		DB	80H
042D61 CD 6E 33 04 6996          		CALL    POP5
042D65 F1          6997          		POP     AF
042D66 F5          6998          		PUSH    AF
042D67 F4 8C 2D 04 6999          		CALL    P,RECIP         ;X=1/X
042D6B F1          7000          		POP     AF
042D6C F2 74 2D 04 7001          		JP      P,EXP4
042D70 E6 7F       7002          		AND     7FH
042D72 ED 44       7003          		NEG
042D74 C6 80       7004  EXP4:			ADD     A,80H
042D76 81          7005          		ADD     A,C
042D77 38 06       7006          		JR      C,EXP2
042D79 F2 D5 32 04 7007          		JP      P,ZERO_fpp          ;UNDERFLOW
042D7D 18 04       7008          		JR      EXP3
042D7F FA A0 32 04 7009  EXP2:			JP      M,OFLOW         ;OVERFLOW
042D83 C6 80       7010  EXP3:			ADD     A,80H
042D85 CA D5 32 04 7011          		JP      Z,ZERO_fpp
042D89 4F          7012          		LD      C,A
042D8A AF          7013          		XOR     A               ;NUMERIC MARKER
042D8B C9          7014          		RET
042D8C             7015  ;
042D8C CD ED 2C 04 7016  RECIP:			CALL    DONE
042D90 CD 89 32 04 7017  RDIV:			CALL    SWAP_fpp
042D94 C3 17 29 04 7018          		JP      FDIV            ;RECIPROCAL
042D98             7019  ;
042D98 11 72 31 00 7020  LN2:			LD      DE,3172H        ;LN(2)
042D9C D9          7021          		EXX
042D9D 11 F8 17 00 7022          		LD      DE,17F8H
042DA1 D9          7023          		EXX
042DA2 06 7F       7024          		LD      B,7FH
042DA4 C9          7025          		RET
042DA5             7026  ;
042DA5             7027  ;LN - Natural log.
042DA5             7028  ;Result is floating-point numeric.
042DA5             7029  ;
042DA5 CD 58 32 04 7030  LN_fpp:			CALL    SFLOAT_fpp
042DA9 3E 16       7031  LN0:			LD      A,LOGRNG
042DAB CB 7C       7032          		BIT     7,H
042DAD C2 2F 27 04 7033          		JP      NZ,ERROR_FPP_        ;"Log range"
042DB1 0C          7034          		INC     C
042DB2 0D          7035          		DEC     C
042DB3 CA 2F 27 04 7036          		JP      Z,ERROR_FPP_
042DB7 11 04 35 00 7037          		LD      DE,3504H        ;SQR(2)
042DBB D9          7038          		EXX
042DBC 11 33 F3 00 7039          		LD      DE,0F333H       ;1.41421356237
042DC0 D9          7040          		EXX
042DC1 CD E8 32 04 7041          		CALL    ICP0            ;MANTISSA>SQR_fpp(2)?
042DC5 79          7042          		LD      A,C             ;EXPONENT
042DC6 0E 80       7043          		LD      C,80H           ;1 <= X < 2
042DC8 38 02       7044          		JR      C,LN4
042DCA 0D          7045          		DEC     C
042DCB 3C          7046          		INC     A
042DCC F5          7047  LN4:			PUSH    AF              ;SAVE EXPONENT
042DCD CD 7A 33 04 7048          		CALL    RATIO           ;X=(X-1)/(X+1)
042DD1 CD 65 33 04 7049          		CALL    PUSH5
042DD5 CD 5D 33 04 7050  		        CALL    SQUARE          ;PUSH X*X
042DD9 CD A2 33 04 7051          		CALL    POLY
042DDD 48 CC       7052          		DW	0CC48H          ;a(9)
042DDF FB 74       7053          		DW	74FBH
042DE1 7D          7054          		DB	7DH
042DE2 AF AE       7055          		DW	0AEAFH          ;a(7)
042DE4 FF 11       7056          		DW	11FFH
042DE6 7E          7057          		DB	7EH
042DE7 8C D9       7058          		DW	0D98CH          ;a(5)
042DE9 CD 4C       7059          		DW	4CCDH
042DEB 7E          7060          		DB	7EH
042DEC E3 A9       7061          		DW	0A9E3H          ;a(3)
042DEE AA 2A       7062          		DW	2AAAH
042DF0 7F          7063          		DB	7FH
042DF1 00 00       7064          		DW	0               ;a(1)
042DF3 00 00       7065          		DW	0
042DF5 81          7066          		DB	81H
042DF6 CD 6E 33 04 7067          		CALL    POP5
042DFA CD 6E 33 04 7068          		CALL    POP5
042DFE CD C0 29 04 7069          		CALL    FMUL
042E02 F1          7070          		POP     AF              ;EXPONENT
042E03 CD 65 33 04 7071          		CALL    PUSH5
042E07 08          7072          		EX      AF,AF'
042E08 CD D5 32 04 7073          		CALL    ZERO_fpp
042E0C 08          7074          		EX      AF,AF'
042E0D D6 80       7075          		SUB     80H
042E0F 28 1F       7076          		JR      Z,LN3
042E11 30 02       7077          		JR      NC,LN1
042E13 2F          7078          		CPL
042E14 3C          7079          		INC     A
042E15 67          7080  LN1:			LD      H,A
042E16 0E 87       7081          		LD      C,87H
042E18 F5          7082          		PUSH    AF
042E19 CD 38 32 04 7083          		CALL    FLOAT_
042E1D CB BC       7084          		RES     7,H
042E1F CD 98 2D 04 7085          		CALL    LN2
042E23 CD C0 29 04 7086          		CALL    FMUL
042E27 F1          7087          		POP     AF
042E28 30 06       7088          		JR      NC,LN3
042E2A FA 30 2E 04 7089          		JP      M,LN3
042E2E CB FC       7090          		SET     7,H
042E30 CD 6E 33 04 7091  LN3:			CALL    POP5
042E34 CD AE 28 04 7092          		CALL    FADD
042E38 AF          7093          		XOR     A
042E39 C9          7094          		RET
042E3A             7095  ;
042E3A             7096  ;LOG - base-10 logarithm.
042E3A             7097  ;Result is floating-point numeric.
042E3A             7098  ;
042E3A CD A5 2D 04 7099  LOG_fpp:			CALL    LN_fpp
042E3E 11 5B 5E 00 7100          		LD      DE,5E5BH        ;LOG(e)
042E42 D9          7101          		EXX
042E43 11 A9 D8 00 7102          		LD      DE,0D8A9H
042E47 D9          7103          		EXX
042E48 06 7E       7104          		LD      B,7EH
042E4A CD C0 29 04 7105          		CALL    FMUL
042E4E AF          7106          		XOR     A
042E4F C9          7107          		RET
042E50             7108  ;
042E50             7109  ;ASN - Arc-sine
042E50             7110  ;Result is floating-point numeric.
042E50             7111  ;
042E50 CD 58 32 04 7112  ASN_fpp:			CALL    SFLOAT_fpp
042E54 CD 65 33 04 7113          		CALL    PUSH5
042E58 CD 55 33 04 7114          		CALL    COPY_
042E5C CD C0 29 04 7115          		CALL    FMUL
042E60 CD ED 2C 04 7116          		CALL    DONE
042E64 CD 9B 28 04 7117          		CALL    RSUB
042E68 CD CB 2B 04 7118          		CALL    SQR0
042E6C CD 6E 33 04 7119          		CALL    POP5
042E70 0C          7120          		INC     C
042E71 0D          7121          		DEC     C
042E72 3E 02       7122          		LD      A,2
042E74 D5          7123          		PUSH    DE
042E75 CA FA 2E 04 7124          		JP      Z,ACS1
042E79 D1          7125          		POP     DE
042E7A CD 90 2D 04 7126          		CALL    RDIV
042E7E 18 04       7127          		JR      ATN0
042E80             7128  ;
042E80             7129  ;ATN - arc-tangent
042E80             7130  ;Result is floating-point numeric.
042E80             7131  ;
042E80 CD 58 32 04 7132  ATN_fpp:			CALL    SFLOAT_fpp
042E84 E5          7133  ATN0:			PUSH    HL              ;SAVE SIGN
042E85 CB BC       7134          		RES     7,H
042E87 11 13 54 00 7135          		LD      DE,5413H        ;TAN(PI_fpp/8)=SQR_fpp(2)-1
042E8B D9          7136          		EXX
042E8C 11 D0 CC 00 7137          		LD      DE,0CCD0H
042E90 D9          7138          		EXX
042E91 06 7E       7139          		LD      B,7EH
042E93 CD E5 32 04 7140          		CALL    FCP0            ;COMPARE
042E97 06 00       7141          		LD      B,0
042E99 38 22       7142          		JR      C,ATN2
042E9B 11 82 1A 00 7143          		LD      DE,1A82H        ;TAN(3*PI_fpp/8)=SQR_fpp(2)+1
042E9F D9          7144          		EXX
042EA0 11 9A 79 00 7145          		LD      DE,799AH
042EA4 D9          7146          		EXX
042EA5 06 81       7147          		LD      B,81H
042EA7 CD E5 32 04 7148          		CALL    FCP0            ;COMPARE
042EAB 38 0A       7149          		JR      C,ATN1
042EAD CD 8C 2D 04 7150          		CALL    RECIP           ;X=1/X
042EB1 06 02       7151          		LD      B,2
042EB3 C3 BD 2E 04 7152          		JP      ATN2
042EB7 CD 7A 33 04 7153  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
042EBB 06 01       7154          		LD      B,1
042EBD C5          7155  ATN2:			PUSH    BC              ;SAVE FLAG
042EBE CD 65 33 04 7156          		CALL    PUSH5
042EC2 CD 5D 33 04 7157          		CALL    SQUARE          ;PUSH X*X
042EC6 CD A2 33 04 7158          		CALL    POLY
042ECA 35 F3       7159          		DW	0F335H          ;a(13)
042ECC D8 37       7160          		DW	37D8H
042ECE 7B          7161          		DB	7BH
042ECF 91 6B       7162          		DW	6B91H           ;a(11)
042ED1 B9 AA       7163          		DW	0AAB9H
042ED3 7C          7164          		DB	7CH
042ED4 DE 41       7165          		DW	41DEH           ;a(9)
042ED6 97 61       7166          		DW	6197H
042ED8 7C          7167          		DB	7CH
042ED9 7B 9D       7168          		DW	9D7BH           ;a(7)
042EDB 37 92       7169          		DW	9237H
042EDD 7D          7170          		DB	7DH
042EDE 5A 2A       7171          		DW	2A5AH           ;a(5)
042EE0 CC 4C       7172          		DW	4CCCH
042EE2 7D          7173          		DB	7DH
042EE3 5C A9       7174          		DW	0A95CH          ;a(3)
042EE5 AA AA       7175          		DW	0AAAAH
042EE7 7E          7176          		DB	7EH
042EE8 00 00       7177          		DW	0               ;a(1)
042EEA 00 00       7178          		DW	0
042EEC 80          7179          		DB	80H
042EED CD 6E 33 04 7180          		CALL    POP5
042EF1 CD 6E 33 04 7181          		CALL    POP5
042EF5 CD C0 29 04 7182          		CALL    FMUL
042EF9 F1          7183          		POP     AF
042EFA CD FA 2C 04 7184  ACS1:			CALL    PIBY4           ;PI/4
042EFE 1F          7185          		RRA
042EFF F5          7186          		PUSH    AF
042F00 DC AE 28 04 7187          		CALL    C,FADD
042F04 F1          7188          		POP     AF
042F05 04          7189          		INC     B
042F06 1F          7190          		RRA
042F07 DC 9B 28 04 7191          		CALL    C,RSUB
042F0B F1          7192          		POP     AF
042F0C B7          7193          		OR      A
042F0D F0          7194          		RET     P
042F0E CB FC       7195          		SET     7,H             ;MAKE NEGATIVE
042F10 AF          7196          		XOR     A
042F11 C9          7197          		RET
042F12             7198  ;
042F12             7199  ;ACS - Arc cosine=PI/2-ASN.
042F12             7200  ;Result is floating point numeric.
042F12             7201  ;
042F12 CD 50 2E 04 7202  ACS_fpp:			CALL    ASN_fpp
042F16 3E 02       7203          		LD      A,2
042F18 F5          7204          		PUSH    AF
042F19 18 DF       7205          		JR      ACS1
042F1B             7206  ;
042F1B             7207  ;Function STR - convert numeric value to ASCII string.
042F1B             7208  ;   Inputs: HLH'L'C = integer or floating-point number
042F1B             7209  ;           DE = address at which to store string
042F1B             7210  ;           IX = address of @% format control
042F1B             7211  ;  Outputs: String stored, with NUL terminator
042F1B             7212  ;
042F1B             7213  ;First normalise for decimal output:
042F1B             7214  ;
042F1B CD 58 32 04 7215  STR_fpp:			CALL    SFLOAT_fpp
042F1F 06 00       7216          		LD      B,0             ;DEFAULT PT. POSITION
042F21 CB 7C       7217          		BIT     7,H             ;NEGATIVE?
042F23 28 06       7218          		JR      Z,STR10
042F25 CB BC       7219          		RES     7,H
042F27 3E 2D       7220          		LD      A,'-'
042F29 12          7221          		LD      (DE),A          ;STORE SIGN
042F2A 13          7222          		INC     DE
042F2B AF          7223  STR10:			XOR     A               ;CLEAR A
042F2C B9          7224          		CP      C
042F2D 28 4E       7225          		JR      Z,STR2_fpp          ;ZERO
042F2F D5          7226          		PUSH    DE              ;SAVE TEXT POINTER
042F30 78          7227          		LD      A,B
042F31 F5          7228  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
042F32 79          7229          		LD      A,C             ;BINARY EXPONENT
042F33 FE A1       7230          		CP      161
042F35 30 1C       7231          		JR      NC,STR14
042F37 FE 9B       7232          		CP      155
042F39 30 29       7233          		JR      NC,STR15
042F3B 2F          7234          		CPL
042F3C FE E1       7235          		CP      225
042F3E 38 02       7236          		JR      C,STR13
042F40 3E F8       7237          		LD      A,-8
042F42 C6 1C       7238  STR13:			ADD     A,28
042F44 CD D1 33 04 7239          		CALL    POWR10
042F48 F5          7240          		PUSH    AF
042F49 CD C0 29 04 7241          		CALL    FMUL
042F4D F1          7242          		POP     AF
042F4E 47          7243          		LD      B,A
042F4F F1          7244          		POP     AF
042F50 90          7245          		SUB     B
042F51 18 DE       7246          		JR      STR11
042F53 D6 20       7247  STR14:			SUB     32
042F55 CD D1 33 04 7248          		CALL    POWR10
042F59 F5          7249          		PUSH    AF
042F5A CD 17 29 04 7250          		CALL    FDIV
042F5E F1          7251          		POP     AF
042F5F 47          7252          		LD      B,A
042F60 F1          7253          		POP     AF
042F61 80          7254          		ADD     A,B
042F62 18 CD       7255          		JR      STR11
042F64 3E 09       7256  STR15:			LD      A,9
042F66 CD D1 33 04 7257          		CALL    POWR10          ;10^9
042F6A CD E5 32 04 7258          		CALL    FCP0
042F6E 79          7259          		LD      A,C
042F6F C1          7260          		POP     BC
042F70 4F          7261          		LD      C,A
042F71 CB FC       7262          		SET     7,H             ;IMPLIED 1
042F73 DC 0D 33 04 7263          		CALL    C,X10B          ;X10, DEC B
042F77 D1          7264          		POP     DE              ;RESTORE TEXT POINTER
042F78 CB B9       7265          		RES     7,C
042F7A 3E 00       7266          		LD      A,0
042F7C 17          7267          		RLA                     ;PUT CARRY IN LSB
042F7D             7268  ;
042F7D             7269  ;At this point decimal normalisation has been done,
042F7D             7270  ;now convert to decimal digits:
042F7D             7271  ;      AHLH'L' = number in normalised integer form
042F7D             7272  ;            B = decimal place adjustment
042F7D             7273  ;            C = binary place adjustment (29-33)
042F7D             7274  ;
042F7D 0C          7275  STR2_fpp:			INC     C
042F7E 08          7276          		EX      AF,AF'          ;SAVE A
042F7F 78          7277          		LD      A,B
042F80 DD CB 02 4E 7278          		BIT     1,(IX+2)
042F84 20 08       7279          		JR      NZ,STR20
042F86 AF          7280          		XOR     A
042F87 DD BE 01    7281          		CP      (IX+1)
042F8A 28 0B       7282          		JR      Z,STR21
042F8C 3E F6       7283          		LD      A,-10
042F8E DD 86 01    7284  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
042F91 B7          7285          		OR      A               ;CLEAR CARRY
042F92 FA 97 2F 04 7286          		JP      M,STR21
042F96 AF          7287          		XOR     A
042F97 F5          7288  STR21:			PUSH    AF
042F98 08          7289          		EX      AF,AF'          ;RESTORE A
042F99 CD 41 33 04 7290  STR22:			CALL    X2              ;RL AHLH'L'
042F9D 8F          7291          		ADC     A,A
042F9E FE 0A       7292          		CP      10
042FA0 38 05       7293          		JR      C,STR23
042FA2 D6 0A       7294          		SUB     10
042FA4 D9          7295          		EXX
042FA5 2C          7296          		INC     L               ;SET RESULT BIT
042FA6 D9          7297          		EXX
042FA7 0D          7298  STR23:			DEC     C
042FA8 20 EF       7299          		JR      NZ,STR22        ;32 TIMES
042FAA 4F          7300          		LD      C,A             ;REMAINDER
042FAB 7C          7301          		LD      A,H
042FAC E6 3F       7302          		AND     3FH             ;CLEAR OUT JUNK
042FAE 67          7303          		LD      H,A
042FAF F1          7304          		POP     AF
042FB0 F2 BE 2F 04 7305          		JP      P,STR24
042FB4 3C          7306          		INC     A
042FB5 20 1C       7307          		JR      NZ,STR26
042FB7 3E 04       7308          		LD      A,4
042FB9 B9          7309          		CP      C               ;ROUND UP?
042FBA 3E 00       7310          		LD      A,0
042FBC 18 15       7311          		JR      STR26
042FBE F5          7312  STR24:			PUSH    AF
042FBF 79          7313          		LD      A,C
042FC0 CE 30       7314          		ADC     A,'0'           ;ADD CARRY
042FC2 FE 30       7315          		CP      '0'
042FC4 28 05       7316          		JR      Z,STR25         ;SUPPRESS ZERO_fpp
042FC6 FE 3A       7317          		CP      '9'+1
042FC8 3F          7318          		CCF
042FC9 30 08       7319          		JR      NC,STR26
042FCB E3          7320  STR25:			EX      (SP),HL
042FCC CB 75       7321          		BIT     6,L             ;ZERO FLAG
042FCE E3          7322  		        EX      (SP),HL
042FCF 20 05       7323          		JR      NZ,STR27
042FD1 3E 30       7324          		LD      A,'0'
042FD3 3C          7325  STR26:			INC     A               ;SET +VE
042FD4 3D          7326          		DEC     A
042FD5 F5          7327          		PUSH    AF              ;PUT ON STACK + CARRY
042FD6 04          7328  STR27:			INC     B
042FD7 CD B1 32 04 7329          		CALL    TEST_fpp            ;IS HLH'L' ZERO_fpp?
042FDB 0E 20       7330          		LD      C,32
042FDD 3E 00       7331          		LD      A,0
042FDF 20 B8       7332          		JR      NZ,STR22
042FE1 F1          7333          		POP     AF
042FE2 F5          7334          		PUSH    AF
042FE3 3E 00       7335          		LD      A,0
042FE5 38 B2       7336          		JR      C,STR22
042FE7             7337  ;
042FE7             7338  ;At this point, the decimal character string is stored
042FE7             7339  ; on the stack. Trailing zeroes are suppressed and may
042FE7             7340  ; need to be replaced.
042FE7             7341  ;B register holds decimal point position.
042FE7             7342  ;Now format number and store as ASCII string:
042FE7             7343  ;
042FE7 EB          7344  STR3:			EX      DE,HL           ;STRING POINTER
042FE8 0E FF       7345          		LD      C,-1            ;FLAG "E"
042FEA 16 01       7346          		LD      D,1
042FEC DD 5E 01    7347          		LD      E,(IX+1)        ;f2
042FEF DD CB 02 46 7348          		BIT     0,(IX+2)
042FF3 20 35       7349          		JR      NZ,STR34        ;E MODE
042FF5 DD CB 02 4E 7350          		BIT     1,(IX+2)
042FF9 28 12       7351          		JR      Z,STR31
042FFB 78          7352          		LD      A,B             ;F MODE
042FFC B7          7353          		OR      A
042FFD 28 05       7354          		JR      Z,STR30
042FFF FA 04 30 04 7355          		JP      M,STR30
043003 50          7356          		LD      D,B
043004 7A          7357  STR30:			LD      A,D
043005 DD 86 01    7358          		ADD     A,(IX+1)
043008 5F          7359          		LD      E,A
043009 FE 0B       7360          		CP      11
04300B 38 19       7361          		JR      C,STR32
04300D 78          7362  STR31:			LD      A,B             ;G MODE
04300E 11 01 01 00 7363          		LD      DE,101H
043012 B7          7364          		OR      A
043013 FA 2A 30 04 7365          		JP      M,STR34
043017 28 0D       7366          		JR      Z,STR32
043019 DD 7E 01    7367          		LD      A,(IX+1)
04301C B7          7368          		OR      A
04301D 20 02       7369          		JR      NZ,STR3A
04301F 3E 0A       7370          		LD      A,10
043021 B8          7371  STR3A:			CP      B
043022 38 06       7372          		JR      C,STR34
043024 50          7373          		LD      D,B
043025 58          7374          		LD      E,B
043026 78          7375  STR32:			LD      A,B
043027 C6 81       7376          		ADD     A,129
043029 4F          7377          		LD      C,A
04302A CB FA       7378  STR34:			SET     7,D
04302C 1D          7379          		DEC     E
04302D 7A          7380  STR35:			LD      A,D
04302E B9          7381          		CP      C
04302F 30 0E       7382          		JR      NC,STR33
043031 F1          7383  STR36:			POP     AF
043032 28 04       7384          		JR      Z,STR37
043034 F2 41 30 04 7385          		JP      P,STR38
043038 F5          7386  STR37:			PUSH    AF
043039 1C          7387          		INC     E
04303A 1D          7388          		DEC     E
04303B FA 52 30 04 7389          		JP      M,STR4
04303F 3E 30       7390  STR33:			LD      A,'0'
043041 15          7391  STR38:			DEC     D
043042 E2 49 30 04 7392          		JP      PO,STR39
043046 36 2E       7393          		LD      (HL),'.'
043048 23          7394          		INC     HL
043049 77          7395  STR39:			LD      (HL),A
04304A 23          7396          		INC     HL
04304B 1D          7397          		DEC     E
04304C F2 2D 30 04 7398          		JP      P,STR35
043050 18 DF       7399          		JR      STR36
043052             7400  ;
043052 F1          7401  STR4:			POP     AF
043053 0C          7402  STR40:			INC     C
043054 4D          7403          		LD      C,L
043055 20 28       7404          		JR      NZ,STR44
043057 36 45       7405          		LD      (HL),'E'        ;EXPONENT
043059 23          7406          		INC     HL
04305A 78          7407          		LD      A,B
04305B 3D          7408          		DEC     A
04305C F2 65 30 04 7409          		JP      P,STR41
043060 36 2D       7410          		LD      (HL),'-'
043062 23          7411          		INC     HL
043063 ED 44       7412          		NEG
043065 36 30       7413  STR41:			LD      (HL),'0'
043067 28 15       7414          		JR      Z,STR47
043069 FE 0A       7415          		CP      10
04306B 47          7416          		LD      B,A
04306C 3E 3A       7417          		LD      A,':'
04306E 38 03       7418          		JR      C,STR42
043070 23          7419          		INC     HL
043071 36 30       7420          		LD      (HL),'0'
043073 34          7421  STR42:			INC     (HL)
043074 BE          7422          		CP      (HL)
043075 20 05       7423          		JR      NZ,STR43
043077 36 30       7424          		LD      (HL),'0'
043079 2B          7425          		DEC     HL
04307A 34          7426          		INC     (HL)
04307B 23          7427          		INC     HL
04307C 10 F5       7428  STR43:			DJNZ    STR42
04307E 23          7429  STR47:			INC     HL
04307F EB          7430  STR44:			EX      DE,HL
043080 C9          7431        			RET
043081             7432  ;
043081             7433  ;Support subroutines:
043081             7434  ;
043081 DD 46 04    7435  DLOAD5:			LD      B,(IX+4)
043084 D9          7436          		EXX
043085 DD 5E 00    7437          		LD      E,(IX+0)
043088 DD 56 01    7438          		LD      D,(IX+1)
04308B D9          7439          		EXX
04308C DD 5E 02    7440          		LD      E,(IX+2)
04308F DD 56 03    7441          		LD      D,(IX+3)
043092 C9          7442          		RET
043093             7443  ;
043093 DD 46 06    7444  DLOAD5_SPL:		LD      B,(IX+6)
043096 D9          7445  			EXX
043097 DD 17 00    7446  			LD	DE, (IX+0)
04309A D9          7447  			EXX
04309B DD 17 03    7448  			LD	DE, (IX+3)
04309E C9          7449  			RET
04309F             7450  ;
04309F             7451  ;CON - Get unsigned numeric constant from ASCII string.
04309F             7452  ;   Inputs: ASCII string at (IX).
04309F             7453  ;  Outputs: Variable-type result in HLH'L'C
04309F             7454  ;           IX updated (points to delimiter)
04309F             7455  ;           A7 = 0 (numeric marker)
04309F             7456  ;
04309F CD D5 32 04 7457  CON_fpp:			CALL    ZERO_fpp            ;INITIALISE TO ZERO_fpp
0430A3 0E 00       7458          		LD      C,0             ;TRUNCATION COUNTER
0430A5 CD 33 31 04 7459          		CALL    NUMBER_fpp          ;GET INTEGER PART
0430A9 FE 2E       7460          		CP      '.'
0430AB 06 00       7461          		LD      B,0             ;DECL. PLACE COUNTER
0430AD CC 31 31 04 7462          		CALL    Z,NUMBIX        ;GET FRACTION PART
0430B1 FE 45       7463          		CP      'E'
0430B3 3E 00       7464          		LD      A,0             ;INITIALISE EXPONENT
0430B5 CC FF 30 04 7465          		CALL    Z,GETEXP        ;GET EXPONENT
0430B9 CB 7C       7466          		BIT     7,H
0430BB 20 08       7467          		JR      NZ,CON0         ;INTEGER OVERFLOW
0430BD B7          7468          		OR      A
0430BE 20 05       7469          		JR      NZ,CON0         ;EXPONENT NON-ZERO_fpp
0430C0 B8          7470          		CP      B
0430C1 20 02       7471          		JR      NZ,CON0         ;DECIMAL POINT
0430C3 B9          7472          		CP      C
0430C4 C8          7473          		RET     Z               ;INTEGER
0430C5 90          7474  CON0:			SUB     B
0430C6 81          7475          		ADD     A,C
0430C7 0E 9F       7476          		LD      C,159
0430C9 CD 38 32 04 7477          		CALL    FLOAT_
0430CD CB BC       7478          		RES     7,H             ;DITCH IMPLIED 1
0430CF B7          7479          		OR      A
0430D0 C8          7480          		RET     Z               ;DONE
0430D1 FA DF 30 04 7481          		JP      M,CON2          ;NEGATIVE EXPONENT
0430D5 CD D1 33 04 7482          		CALL    POWR10
0430D9 CD C0 29 04 7483          		CALL    FMUL            ;SCALE
0430DD AF          7484          		XOR     A
0430DE C9          7485          		RET
0430DF FE DA       7486  CON2:			CP      -38
0430E1 38 0C       7487          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
0430E3 ED 44       7488          		NEG
0430E5 CD D1 33 04 7489          		CALL    POWR10
0430E9 CD 17 29 04 7490          		CALL    FDIV            ;SCALE
0430ED AF          7491          		XOR     A
0430EE C9          7492          		RET
0430EF F5          7493  CON3:			PUSH    AF
0430F0 3E 26       7494          		LD      A,38
0430F2 CD D1 33 04 7495          		CALL    POWR10
0430F6 CD 17 29 04 7496          		CALL    FDIV
0430FA F1          7497          		POP     AF
0430FB C6 26       7498          		ADD     A,38
0430FD 18 E0       7499          		JR      CON2
0430FF             7500  ;
0430FF             7501  ;GETEXP - Get decimal exponent from string
0430FF             7502  ;     Inputs: ASCII string at (IX)
0430FF             7503  ;             (IX points at 'E')
0430FF             7504  ;             A = initial value
0430FF             7505  ;    Outputs: A = new exponent
0430FF             7506  ;             IX updated.
0430FF             7507  ;   Destroys: A,A',IX,F,F'
0430FF             7508  ;
0430FF C5          7509  GETEXP:			PUSH    BC              ;SAVE REGISTERS
043100 47          7510          		LD      B,A             ;INITIAL VALUE
043101 0E 02       7511          		LD      C,2             ;2 DIGITS MAX
043103 DD 23       7512          		INC     IX              ;BUMP PAST 'E'
043105 CD EF 34 04 7513          		CALL    SIGNQ
043109 08          7514          		EX      AF,AF'          ;SAVE EXPONENT SIGN
04310A CD E5 34 04 7515  GETEX1:			CALL    DIGITQ
04310E 38 18       7516          		JR      C,GETEX2
043110 78          7517          		LD      A,B             ;B=B*10
043111 87          7518          		ADD     A,A
043112 87          7519          		ADD     A,A
043113 80          7520          		ADD     A,B
043114 87          7521          		ADD     A,A
043115 47          7522          		LD      B,A
043116 DD 7E 00    7523          		LD      A,(IX)          ;GET BACK DIGIT
043119 DD 23       7524          		INC     IX
04311B E6 0F       7525          		AND     0FH             ;MASK UNWANTED BITS
04311D 80          7526          		ADD     A,B             ;ADD IN DIGIT
04311E 47          7527          		LD      B,A
04311F 0D          7528          		DEC     C
043120 F2 0A 31 04 7529          		JP      P,GETEX1
043124 06 64       7530          		LD      B,100           ;FORCE OVERFLOW
043126 18 E2       7531          		JR      GETEX1
043128 08          7532  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
043129 FE 2D       7533          		CP      '-'
04312B 78          7534          		LD      A,B
04312C C1          7535          		POP     BC              ;RESTORE
04312D C0          7536          		RET     NZ
04312E ED 44       7537          		NEG                     ;NEGATE EXPONENT
043130 C9          7538          		RET
043131             7539  ;
043131             7540  ;NUMBER: Get unsigned integer from string.
043131             7541  ;    Inputs: string at (IX)
043131             7542  ;            C = truncated digit count
043131             7543  ;                (initially zero)
043131             7544  ;            B = total digit count
043131             7545  ;            HLH'L' = initial value
043131             7546  ;   Outputs: HLH'L' = number (binary integer)
043131             7547  ;            A = delimiter.
043131             7548  ;            B, C & IX updated
043131             7549  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
043131             7550  ;
043131 DD 23       7551  NUMBIX:			INC     IX
043133 CD E5 34 04 7552  NUMBER_fpp:			CALL    DIGITQ
043137 D8          7553          		RET     C
043138 04          7554          		INC     B               ;INCREMENT DIGIT COUNT
043139 DD 23       7555          		INC     IX
04313B CD 2E 33 04 7556          		CALL    X10             ;*10 & COPY OLD VALUE
04313F 38 15       7557          		JR      C,NUMB1         ;OVERFLOW
043141 0D          7558          		DEC     C               ;SEE IF TRUNCATED
043142 0C          7559          		INC     C
043143 20 11       7560          		JR      NZ,NUMB1        ;IMPORTANT!
043145 E6 0F       7561          		AND     0FH
043147 D9          7562          		EXX
043148 06 00       7563          		LD      B,0
04314A 4F          7564          		LD      C,A
04314B 52 09       7565          		ADD.S   HL,BC           ;ADD IN DIGIT
04314D D9          7566          		EXX
04314E 30 E3       7567          		JR      NC,NUMBER_fpp
043150 52 23       7568          		INC.S   HL              ;CARRY
043152 7C          7569          		LD      A,H
043153 B5          7570          		OR      L
043154 20 DD       7571          		JR      NZ,NUMBER_fpp
043156 0C          7572  NUMB1:			INC     C               ;TRUNCATION COUNTER
043157 CD 8C 32 04 7573          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
04315B 18 D6       7574          		JR      NUMBER_fpp
04315D             7575  ;
04315D             7576  ;FIX - Fix number to specified exponent value.
04315D             7577  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
04315D             7578  ;            A = desired exponent (A>C)
04315D             7579  ;   Outputs: HLH'L'C = fixed number (unsigned)
04315D             7580  ;            fraction shifted into B'C'
04315D             7581  ;            A'F' positive if integer input
04315D             7582  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
04315D             7583  ;
04315D 08          7584  FIX:			EX      AF,AF'
04315E AF          7585          		XOR     A
04315F 08          7586          		EX      AF,AF'
043160 CB FC       7587          		SET     7,H             ;IMPLIED 1
043162 CD 91 32 04 7588  FIX1:			CALL    DIV2
043166 B9          7589          		CP      C
043167 C8          7590          		RET     Z
043168 D2 62 31 04 7591          		JP      NC,FIX1
04316C C3 A0 32 04 7592          		JP      OFLOW
043170             7593  ;
043170             7594  ;SFIX - Convert to integer if necessary.
043170             7595  ;    Input: Variable-type number in HLH'L'C
043170             7596  ;   Output: Integer in HLH'L', C=0
043170             7597  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
043170             7598  ;
043170             7599  ;NEGATE - Negate HLH'L'
043170             7600  ;    Destroys: H,L,H',L',F
043170             7601  ;
043170 CD 89 32 04 7602  FIX2:			CALL    SWAP_fpp
043174 CD 7C 31 04 7603          		CALL    SFIX_fpp
043178 CD 89 32 04 7604          		CALL    SWAP_fpp
04317C 0D          7605  SFIX_fpp:			DEC     C
04317D 0C          7606          		INC     C
04317E C8          7607          		RET     Z               ;INTEGER/ZERO_fpp
04317F CB 7C       7608          		BIT     7,H             ;SIGN
043181 F5          7609          		PUSH    AF
043182 3E 9F       7610          		LD      A,159
043184 CD 5D 31 04 7611          		CALL    FIX
043188 F1          7612          		POP     AF
043189 0E 00       7613          		LD      C,0
04318B C8          7614          		RET     Z
04318C B7          7615  NEGATE_fpp:			OR      A               ;CLEAR CARRY
04318D D9          7616          		EXX
04318E D5          7617  NEG0:			PUSH    DE
04318F EB          7618          		EX      DE,HL
043190 21 00 00 00 7619          		LD      HL,0
043194 52 ED 52    7620          		SBC.S   HL,DE
043197 D1          7621          		POP     DE
043198 D9          7622          		EXX
043199 D5          7623          		PUSH    DE
04319A EB          7624          		EX      DE,HL
04319B 21 00 00 00 7625          		LD      HL,0
04319F 52 ED 52    7626          		SBC.S   HL,DE
0431A2 D1          7627          		POP     DE
0431A3 C9          7628          		RET
0431A4             7629  ;
0431A4             7630  ;NEG - Negate HLH'L'B'C'
0431A4             7631  ;    Also complements A (used in FADD)
0431A4             7632  ;    Destroys: A,H,L,B',C',H',L',F
0431A4             7633  ;
0431A4 D9          7634  NEG_:			EXX
0431A5 2F          7635          		CPL
0431A6 E5          7636          		PUSH    HL
0431A7 B7          7637          		OR      A               ;CLEAR CARRY
0431A8 21 00 00 00 7638          		LD      HL,0
0431AC 52 ED 42    7639          		SBC.S   HL,BC
0431AF 44          7640          		LD      B,H
0431B0 4D          7641          		LD      C,L
0431B1 E1          7642          		POP     HL
0431B2 18 DA       7643          		JR      NEG0
0431B4             7644  ;
0431B4             7645  ;SCALE - Trig scaling.
0431B4             7646  ;MOD48 - 48-bit floating-point "modulus" (remainder).
0431B4             7647  ;   Inputs: HLH'L'C unsigned floating-point dividend
0431B4             7648  ;           DED'E'B'C'B unsigned 48-bit FP divisor
0431B4             7649  ;  Outputs: HLH'L'C floating point remainder (H7=1)
0431B4             7650  ;           E = quotient (bit 7 is sticky)
0431B4             7651  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0431B4             7652  ;FLO48 - Float unsigned number (48 bits)
0431B4             7653  ;    Input/output in HLH'L'B'C'C
0431B4             7654  ;   Destroys: C,H,L,B',C',H',L',F
0431B4             7655  ;
0431B4 3E 96       7656  SCALE:			LD      A,150
0431B6 B9          7657          		CP      C
0431B7 3E 17       7658          		LD      A,ACLOST
0431B9 DA 2F 27 04 7659          		JP      C,ERROR_FPP_         ;"Accuracy lost"
0431BD CD FA 2C 04 7660          		CALL    PIBY4
0431C1 D9          7661          		EXX
0431C2 01 69 21 00 7662          		LD      BC,2169H        ;3.141592653589793238
0431C6 D9          7663          		EXX
0431C7 CB FA       7664  MOD48:			SET     7,D             ;IMPLIED 1
0431C9 CB FC       7665          		SET     7,H
0431CB 79          7666          		LD      A,C
0431CC 0E 00       7667          		LD      C,0             ;INIT QUOTIENT
0431CE DD 21 00 00 7668          		LD      IX,0
       00          
0431D3 DD E5       7669          		PUSH    IX              ;PUT ZERO_fpp ON STACK
0431D5 B8          7670          		CP      B
0431D6 38 46       7671          		JR      C,MOD485        ;DIVIDEND<DIVISOR
0431D8 D9          7672  MOD481:			EXX                     ;CARRY=0 HERE
0431D9 E3          7673          		EX      (SP),HL
0431DA 52 ED 42    7674          		SBC.S   HL,BC
0431DD E3          7675          		EX      (SP),HL
0431DE 52 ED 52    7676          		SBC.S   HL,DE
0431E1 D9          7677          		EXX
0431E2 52 ED 52    7678          		SBC.S   HL,DE
0431E5 30 0C       7679          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0431E7 D9          7680          		EXX
0431E8 E3          7681          		EX      (SP),HL
0431E9 52 09       7682          		ADD.S   HL,BC
0431EB E3          7683          		EX      (SP),HL
0431EC 52 ED 5A    7684          		ADC.S   HL,DE
0431EF D9          7685          		EXX
0431F0 52 ED 5A    7686          		ADC.S   HL,DE
0431F3 3F          7687  MOD482:			CCF
0431F4 CB 11       7688          		RL      C               ;QUOTIENT
0431F6 30 02       7689          		JR      NC,MOD483
0431F8 CB F9       7690          		SET     7,C             ;STICKY BIT
0431FA 3D          7691  MOD483:			DEC     A
0431FB B8          7692          		CP      B
0431FC 38 1F       7693          		JR      C,MOD484        ;DIVIDEND<DIVISOR
0431FE E3          7694          		EX      (SP),HL
0431FF 52 29       7695          		ADD.S   HL,HL           ;DIVIDEND * 2
043201 E3          7696          		EX      (SP),HL
043202 D9          7697          		EXX
043203 52 ED 6A    7698          		ADC.S   HL,HL
043206 D9          7699          		EXX
043207 52 ED 6A    7700          		ADC.S   HL,HL
04320A 30 CC       7701          		JR      NC,MOD481       ;AGAIN
04320C B7          7702          		OR      A
04320D D9          7703          		EXX
04320E E3          7704          		EX      (SP),HL
04320F 52 ED 42    7705          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
043212 E3          7706          		EX      (SP),HL
043213 52 ED 52    7707          		SBC.S   HL,DE
043216 D9          7708          		EXX
043217 52 ED 52    7709          		SBC.S   HL,DE
04321A B7          7710          		OR      A
04321B 18 D6       7711          		JR      MOD482
04321D             7712  ;
04321D 3C          7713  MOD484:			INC     A
04321E 59          7714  MOD485:			LD      E,C             ;QUOTIENT
04321F 4F          7715          		LD      C,A             ;REMAINDER EXPONENT
043220 D9          7716          		EXX
043221 C1          7717          		POP     BC
043222 D9          7718          		EXX
043223 CB 7C       7719  FLO48:			BIT     7,H
043225 C0          7720          		RET     NZ
043226 D9          7721          		EXX
043227 CB 21       7722          		SLA     C
043229 CB 10       7723          		RL      B
04322B 52 ED 6A    7724          		ADC.S   HL,HL
04322E D9          7725          		EXX
04322F 52 ED 6A    7726          		ADC.S   HL,HL
043232 0D          7727          		DEC     C
043233 C2 23 32 04 7728          		JP      NZ,FLO48
043237 C9          7729          		RET
043238             7730  ;
043238             7731  ;Float unsigned number
043238             7732  ;    Input/output in HLH'L'C
043238             7733  ;   Destroys: C,H,L,H',L',F
043238             7734  ;
043238 CB 7C       7735  FLOAT_:			BIT     7,H
04323A C0          7736          		RET     NZ
04323B D9          7737          		EXX                     ;SAME AS "X2"
04323C 52 29       7738          		ADD.S   HL,HL           ;TIME-CRITICAL
04323E D9          7739          		EXX                     ;REGION
04323F 52 ED 6A    7740          		ADC.S   HL,HL           ;(BENCHMARKS)
043242 0D          7741          		DEC     C
043243 C2 38 32 04 7742          		JP      NZ,FLOAT_
043247 C9          7743          		RET
043248             7744  ;
043248             7745  ;SFLOAT - Convert to floating-point if necessary.
043248             7746  ;    Input: Variable-type number in HLH'L'C
043248             7747  ;    Output: Floating-point in HLH'L'C
043248             7748  ;    Destroys: A,C,H,L,H',L',F
043248             7749  ;
043248 08          7750  FLOATA:			EX      AF,AF'
043249             7751          		; ADD     A,(RTABLE-DTABLE)/3
043249 C6 2A       7752          		ADD     A,RTABLE-DTABLE/3
04324B 08          7753          		EX      AF,AF'
04324C CD 89 32 04 7754  FLOAT2:			CALL    SWAP_fpp
043250 CD 58 32 04 7755          		CALL    SFLOAT_fpp
043254 CD 89 32 04 7756          		CALL    SWAP_fpp
043258 0D          7757  SFLOAT_fpp:			DEC     C
043259 0C          7758          		INC     C
04325A C0          7759          		RET     NZ              ;ALREADY FLOATING-POINT
04325B CD B1 32 04 7760          		CALL    TEST_fpp
04325F C8          7761          		RET     Z               ;ZERO
043260 7C          7762          		LD      A,H
043261 B7          7763          		OR      A
043262 FC 8C 31 04 7764          		CALL    M,NEGATE_fpp
043266 0E 9F       7765          		LD      C,159
043268 CD 38 32 04 7766          		CALL    FLOAT_
04326C B7          7767          		OR      A
04326D F8          7768          		RET     M               ;NEGATIVE
04326E CB BC       7769          		RES     7,H
043270 C9          7770          		RET
043271             7771  ;
043271             7772  ;ROUND UP
043271             7773  ;Return with carry set if 32-bit overflow
043271             7774  ;   Destroys: H,L,B',C',H',L',F
043271             7775  ;
043271 D9          7776  ADD1_fpp:			EXX
043272 01 01 00 00 7777          		LD      BC,1
043276 52 09       7778          		ADD.S   HL,BC
043278 D9          7779          		EXX
043279 D0          7780          		RET     NC
04327A C5          7781          		PUSH    BC
04327B 01 01 00 00 7782          		LD      BC,1
04327F 52 09       7783          		ADD.S   HL,BC
043281 C1          7784          		POP     BC
043282 C9          7785          		RET
043283             7786  ;
043283             7787  ;ODD - Add one if even, leave alone if odd.
043283             7788  ; (Used to perform unbiassed rounding, i.e.
043283             7789  ;  number is rounded up half the time)
043283             7790  ;    Destroys: L',F (carry cleared)
043283             7791  ;
043283 B7          7792  ODD:			OR      A               ;CLEAR CARRY
043284 D9          7793          		EXX
043285 CB C5       7794          		SET     0,L             ;MAKE ODD
043287 D9          7795          		EXX
043288 C9          7796          		RET
043289             7797  ;
043289             7798  ;SWAP - Swap arguments.
043289             7799  ;    Exchanges DE,HL D'E',H'L' and B,C
043289             7800  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
043289             7801  ;SWAP1 - Swap DEHL with D'E'H'L'
043289             7802  ;    Destroys: D,E,H,L,D',E',H',L'
043289             7803  ;
043289 79          7804  SWAP_fpp:			LD      A,C
04328A 48          7805          		LD      C,B
04328B 47          7806          		LD      B,A
04328C EB          7807  SWAP1:			EX      DE,HL
04328D D9          7808          		EXX
04328E EB          7809          		EX      DE,HL
04328F D9          7810          		EXX
043290 C9          7811          		RET
043291             7812  ;
043291             7813  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
043291             7814  ; INCC - destroys C,F
043291             7815  ; OFLOW
043291             7816  ;
043291 CD 4A 33 04 7817  DIV2:			CALL    D2
043295 D9          7818          		EXX
043296 CB 18       7819          		RR      B
043298 CB 19       7820          		RR      C
04329A 08          7821          		EX      AF,AF'
04329B B0          7822          		OR      B
04329C 08          7823          		EX      AF,AF'
04329D D9          7824          		EXX
04329E 0C          7825  INCC:			INC     C
04329F C0          7826          		RET     NZ
0432A0 3E 14       7827  OFLOW:			LD      A,TOOBIG_fpp
0432A2 C3 2F 27 04 7828          		JP      ERROR_FPP_           ;"Too big"
0432A6             7829  ;
0432A6             7830  ; FTEST - Test for zero & sign
0432A6             7831  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
0432A6             7832  ;
0432A6 CD B1 32 04 7833  FTEST:			CALL    TEST_fpp
0432AA C8          7834          		RET     Z
0432AB 7C          7835          		LD      A,H
0432AC E6 80       7836          		AND     10000000B
0432AE F6 40       7837          		OR      01000000B
0432B0 C9          7838          		RET
0432B1             7839  ;
0432B1             7840  ; TEST - Test HLH'L' for zero.
0432B1             7841  ;     Output: Z-flag set & A=0 if HLH'L'=0
0432B1             7842  ;     Destroys: A,F
0432B1             7843  ;
0432B1 7C          7844  TEST_fpp:			LD      A,H
0432B2 B5          7845          		OR      L
0432B3 D9          7846          		EXX
0432B4 B4          7847          		OR      H
0432B5 B5          7848          		OR      L
0432B6 D9          7849          		EXX
0432B7 C9          7850          		RET
0432B8             7851  ;
0432B8             7852  ; FCOMP - Compare two numbers
0432B8             7853  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
0432B8             7854  ;
0432B8 78          7855  FCOMP:			LD      A,B
0432B9 B1          7856          		OR      C               ;Both integer?
0432BA 20 0B       7857          		JR      NZ,FCOMP1
0432BC CD D1 32 04 7858          		CALL    ICP
0432C0 3E 00       7859  FCOMP0:			LD      A,0
0432C2 C8          7860          		RET     Z               ;Equal
0432C3 3E 80       7861          		LD      A,80H
0432C5 1F          7862          		RRA
0432C6 C9          7863          		RET
0432C7             7864  ;
0432C7 CD 4C 32 04 7865  FCOMP1:			CALL    FLOAT2          ;Float both
0432CB CD DF 32 04 7866          		CALL    FCP
0432CF 18 EF       7867          		JR      FCOMP0
0432D1             7868  ;
0432D1             7869  ; Integer and floating point compare.
0432D1             7870  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
0432D1             7871  ; Result pre-set to FALSE
0432D1             7872  ; ICP1, FCP1 destroy A,F
0432D1             7873  ;
0432D1             7874  ; ZERO - Return zero.
0432D1             7875  ;  Destroys: A,C,H,L,H',L'
0432D1             7876  ;
0432D1 CD 04 33 04 7877  ICP:			CALL    ICP1
0432D5 3E 00       7878  ZERO_fpp:			LD      A,0
0432D7 D9          7879          		EXX
0432D8 67          7880          		LD      H,A
0432D9 6F          7881  	       		LD      L,A
0432DA D9          7882          		EXX
0432DB 67          7883        			LD      H,A
0432DC 6F          7884       			LD      L,A
0432DD 4F          7885  	    		LD      C,A
0432DE C9          7886          		RET
0432DF             7887  ;
0432DF CD F6 32 04 7888  FCP:			CALL    FCP1
0432E3 18 F0       7889          		JR      ZERO_fpp            ;PRESET FALSE
0432E5             7890  ;
0432E5 79          7891  FCP0:			LD      A,C
0432E6 B8          7892          		CP      B               ;COMPARE EXPONENTS
0432E7 C0          7893          		RET     NZ
0432E8             7894  ICP0:
0432E8 52 ED 52    7895  			SBC.S   HL,DE           ;COMP MANTISSA MSB
0432EB 52 19       7896          		ADD.S   HL,DE
0432ED C0          7897          		RET     NZ
0432EE D9          7898          		EXX
0432EF 52 ED 52    7899          		SBC.S   HL,DE           ;COMP MANTISSA LSB
0432F2 52 19       7900          		ADD.S   HL,DE
0432F4 D9          7901          		EXX
0432F5 C9          7902          		RET
0432F6             7903  ;
0432F6 7C          7904  FCP1:			LD      A,H
0432F7 AA          7905          		XOR     D
0432F8 7C          7906          		LD      A,H
0432F9 17          7907          		RLA
0432FA F8          7908          		RET     M
0432FB 30 E8       7909          		JR      NC,FCP0
0432FD CD E5 32 04 7910          		CALL    FCP0
043301 C8          7911          		RET     Z               ;** V0.1 BUG FIX
043302 3F          7912          		CCF
043303 C9          7913          		RET
043304             7914  ;
043304 7C          7915  ICP1:			LD      A,H
043305 AA          7916          		XOR     D
043306 F2 E8 32 04 7917          		JP      P,ICP0
04330A 7C          7918          		LD      A,H
04330B 17          7919          		RLA
04330C C9          7920          		RET
04330D             7921  ;
04330D             7922  ; ADD - Integer add.
04330D             7923  ; Carry, sign & zero flags valid on exit
04330D             7924  ;     Destroys: H,L,H',L',F
04330D             7925  ;
04330D 05          7926  X10B:			DEC     B
04330E 0C          7927          		INC     C
04330F CD 56 33 04 7928  X5:			CALL    COPY0
043313 CD 49 33 04 7929          		CALL    D2C
043317 CD 49 33 04 7930          		CALL    D2C
04331B 08          7931          		EX      AF,AF'          ;SAVE CARRY
04331C D9          7932  ADD_:			EXX
04331D 52 19       7933          		ADD.S   HL,DE
04331F D9          7934          		EXX
043320 52 ED 5A    7935          		ADC.S   HL,DE
043323 C9          7936          		RET
043324             7937  ;
043324             7938  ; SUB - Integer subtract.
043324             7939  ; Carry, sign & zero flags valid on exit
043324             7940  ;     Destroys: H,L,H',L',F
043324             7941  ;
043324 D9          7942  SUB_:			EXX
043325 B7          7943          		OR      A
043326 52 ED 52    7944          		SBC.S   HL,DE
043329 D9          7945          		EXX
04332A 52 ED 52    7946          		SBC.S   HL,DE
04332D C9          7947          		RET
04332E             7948  ;
04332E             7949  ; X10 - unsigned integer * 10
04332E             7950  ;    Inputs: HLH'L' initial value
04332E             7951  ;   Outputs: DED'E' = initial HLH'L'
04332E             7952  ;            Carry bit set if overflow
04332E             7953  ;            If carry not set HLH'L'=result
04332E             7954  ;  Destroys: D,E,H,L,D',E',H',L',F
04332E             7955  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
04332E             7956  ;     Carry set if MSB=1 before shift.
04332E             7957  ;     Sign set if MSB=1 after shift.
04332E             7958  ;     Destroys: H,L,H',L',F
04332E             7959  ;
04332E CD 56 33 04 7960  X10:			CALL    COPY0           ;DED'E'=HLH'L'
043332 CD 41 33 04 7961          		CALL    X2
043336 D8          7962          		RET     C               ;TOO BIG
043337 CD 41 33 04 7963          		CALL    X2
04333B D8          7964          		RET     C
04333C CD 1C 33 04 7965          		CALL    ADD_
043340 D8          7966          		RET     C
043341 D9          7967  X2:			EXX
043342 52 29       7968          		ADD.S   HL,HL
043344 D9          7969          		EXX
043345 52 ED 6A    7970          		ADC.S   HL,HL
043348 C9          7971          		RET
043349             7972  ;
043349             7973  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
043349             7974  ;     Carry set if LSB=1 before shift.
043349             7975  ;     Destroys: H,L,H',L',F
043349             7976  ;
043349 0C          7977  D2C:			INC     C
04334A CB 3C       7978  D2:			SRL     H
04334C CB 1D       7979          		RR      L
04334E D9          7980          		EXX
04334F CB 1C       7981          		RR      H
043351 CB 1D       7982          		RR      L
043353 D9          7983          		EXX
043354 C9          7984          		RET
043355             7985  ;
043355             7986  ; COPY - COPY HLH'L'C INTO DED'E'B
043355             7987  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
043355             7988  ;
043355 41          7989  COPY_:			LD      B,C
043356 54          7990  COPY0:			LD      D,H
043357 5D          7991          		LD      E,L
043358 D9          7992          		EXX
043359 54          7993          		LD      D,H
04335A 5D          7994          		LD      E,L
04335B D9          7995          		EXX
04335C C9          7996          		RET
04335D             7997  ;
04335D             7998  ; SQUARE - PUSH X*X
04335D             7999  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
04335D             8000  ;   Destroys: SP,IX
04335D             8001  ;
04335D CD 55 33 04 8002  SQUARE:			CALL    COPY_
043361 CD C0 29 04 8003          		CALL    FMUL
043365 DD E1       8004  PUSH5:			POP     IX              ;RETURN ADDRESS
043367 C5          8005          		PUSH    BC
043368 E5          8006          		PUSH    HL
043369 D9          8007          		EXX
04336A E5          8008          		PUSH    HL
04336B D9          8009          		EXX
04336C DD E9       8010          		JP      (IX)            ;"RETURN"
04336E             8011  ;
04336E             8012  ; POP5 - POP DED'E'B OFF STACK.
04336E             8013  ;   Destroys: A,B,D,E,D',E',SP,IX
04336E             8014  ;
04336E DD E1       8015  POP5:			POP     IX              ;RETURN ADDRESS
043370 D9          8016          		EXX
043371 D1          8017          		POP     DE
043372 D9          8018          		EXX
043373 D1          8019          		POP     DE
043374 79          8020          		LD      A,C
043375 C1          8021          		POP     BC
043376 41          8022          		LD      B,C
043377 4F          8023          		LD      C,A
043378 DD E9       8024          		JP      (IX)            ;"RETURN"
04337A             8025  ;
04337A             8026  ; RATIO - Calculate (X-1)/(X+1)
04337A             8027  ;     Inputs: X in HLH'L'C
04337A             8028  ;    Outputs: (X-1)/(X+1) in HLH'L'C
04337A             8029  ;   Destroys: Everything except IY,SP,I
04337A             8030  ;
04337A CD 65 33 04 8031  RATIO:			CALL    PUSH5           ;SAVE X
04337E CD ED 2C 04 8032          		CALL    DONE
043382 CD AE 28 04 8033          		CALL    FADD
043386 CD 6E 33 04 8034          		CALL    POP5            ;RESTORE X
04338A CD 65 33 04 8035          		CALL    PUSH5           ;SAVE X+1
04338E CD 89 32 04 8036          		CALL    SWAP_fpp
043392 CD ED 2C 04 8037          		CALL    DONE
043396 CD 95 28 04 8038          		CALL    FSUB
04339A CD 6E 33 04 8039          		CALL    POP5            ;RESTORE X+1
04339E C3 17 29 04 8040          		JP      FDIV
0433A2             8041  ;
0433A2             8042  ; POLY - Evaluate a polynomial.
0433A2             8043  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
0433A2             8044  ;             Polynomial coefficients follow call.
0433A2             8045  ;    Outputs: Result in HLH'L'C
0433A2             8046  ;   Destroys: Everything except IY,SP,I
0433A2             8047  ; Routine terminates on finding a coefficient >=1.
0433A2             8048  ; Note: The last coefficient is EXECUTED on return
0433A2             8049  ;       so must contain only innocuous bytes!
0433A2             8050  ;
0433A2 DD 21 03 00 8051  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
0433A7 DD 39       8052          		ADD     IX, SP
0433A9 DD E3       8053          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0433AB             8054  ;
0433AB CD 81 30 04 8055          		CALL    DLOAD5          		; Load the first coefficient from (IX)
0433AF CD C0 29 04 8056  POLY1:			CALL    FMUL
0433B3 11 05 00 00 8057          		LD      DE, 5				; Skip to the next coefficient
0433B7 DD 19       8058          		ADD     IX, DE
0433B9 CD 81 30 04 8059          		CALL    DLOAD5          		; Load the second coefficient from (IX)
0433BD DD E3       8060          		EX      (SP), IX			; Restore the SP just in case we need to return
0433BF 04          8061          		INC     B
0433C0 05          8062          		DEC     B               		; Test B for end byte (80h)
0433C1 FA AE 28 04 8063          		JP      M,FADD				; Yes, so add and return
0433C5 CD AE 28 04 8064          		CALL    FADD				; No, so add
0433C9 CD 93 30 04 8065          		CALL    DLOAD5_SPL			; Load X from SP
0433CD DD E3       8066          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0433CF 18 DE       8067          		JR      POLY1				; And loop
0433D1             8068  ;
0433D1             8069  ; POWR10 - Calculate power of ten.
0433D1             8070  ;     Inputs: A=power of 10 required (A<128)
0433D1             8071  ;             A=binary exponent to be exceeded (A>=128)
0433D1             8072  ;    Outputs: DED'E'B = result
0433D1             8073  ;             A = actual power of ten returned
0433D1             8074  ;   Destroys: A,B,D,E,A',D',E',F,F'
0433D1             8075  ;
0433D1 3C          8076  POWR10:			INC     A
0433D2 08          8077          		EX      AF,AF'
0433D3 E5          8078          		PUSH    HL
0433D4 D9          8079          		EXX
0433D5 E5          8080          		PUSH    HL
0433D6 D9          8081          		EXX
0433D7 CD ED 2C 04 8082          		CALL    DONE
0433DB CD 89 32 04 8083          		CALL    SWAP_fpp
0433DF AF          8084          		XOR     A
0433E0 08          8085  POWR11:			EX      AF,AF'
0433E1 3D          8086          		DEC     A
0433E2 28 26       8087          		JR      Z,POWR14        ;EXIT TYPE 1
0433E4 F2 EC 33 04 8088          		JP      P,POWR13
0433E8 B9          8089          		CP      C
0433E9 38 1F       8090          		JR      C,POWR14        ;EXIT TYPE 2
0433EB 3C          8091          		INC     A
0433EC 08          8092  POWR13:			EX      AF,AF'
0433ED 3C          8093          		INC     A
0433EE CB FC       8094          		SET     7,H
0433F0 CD 0F 33 04 8095          		CALL    X5
0433F4 30 06       8096          		JR      NC,POWR12
0433F6 08          8097          		EX      AF,AF'
0433F7 CD 49 33 04 8098          		CALL    D2C
0433FB 08          8099          		EX      AF,AF'
0433FC 08          8100  POWR12:			EX      AF,AF'
0433FD DC 71 32 04 8101          		CALL    C,ADD1_fpp          ;ROUND UP
043401 0C          8102          		INC     C
043402 FA E0 33 04 8103          		JP      M,POWR11
043406 C3 A0 32 04 8104          		JP      OFLOW
04340A CD 89 32 04 8105  POWR14:			CALL    SWAP_fpp
04340E CB BA       8106          		RES     7,D
043410 D9          8107          		EXX
043411 E1          8108          		POP     HL
043412 D9          8109          		EXX
043413 E1          8110          		POP     HL
043414 08          8111          		EX      AF,AF'
043415 C9          8112          		RET
043416             8113  ;
043416             8114  ; DIVA, DIVB - DIVISION PRIMITIVE.
043416             8115  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
043416             8116  ;               Remainder in H'L'HL
043416             8117  ;     Inputs: A = loop counter (normally -32)
043416             8118  ;     Destroys: A,D,E,H,L,D',E',H',L',F
043416             8119  ;
043416 B7          8120  DIVA:			OR      A               ;CLEAR CARRY
043417             8121  DIV0:
043417 52 ED 42    8122  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
04341A D9          8123          		EXX
04341B 52 ED 42    8124          		SBC.S   HL,BC
04341E D9          8125          		EXX
04341F 30 07       8126          		JR      NC,DIV1
043421 52 09       8127          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
043423 D9          8128          		EXX
043424 52 ED 4A    8129          		ADC.S   HL,BC
043427 D9          8130          		EXX
043428 3F          8131  DIV1:			CCF
043429 CB 13       8132  DIVC:			RL      E               ;SHIFT RESULT INTO DE
04342B CB 12       8133          		RL      D
04342D D9          8134          		EXX
04342E CB 13       8135          		RL      E
043430 CB 12       8136          		RL      D
043432 D9          8137          		EXX
043433 3C          8138          		INC     A
043434 F0          8139          		RET     P
043435             8140  DIVB:
043435 52 ED 6A    8141  			ADC.S   HL,HL           ;DIVIDEND*2
043438 D9          8142          		EXX
043439 52 ED 6A    8143          		ADC.S   HL,HL
04343C D9          8144          		EXX
04343D 30 D8       8145          		JR      NC,DIV0
04343F B7          8146          		OR      A
043440 52 ED 42    8147          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
043443 D9          8148          		EXX
043444 52 ED 42    8149          		SBC.S   HL,BC
043447 D9          8150          		EXX
043448 37          8151          		SCF
043449 C3 29 34 04 8152          		JP      DIVC
04344D             8153  ;
04344D             8154  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
04344D             8155  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
04344D             8156  ;    Inputs: A = loop counter (usually -32)
04344D             8157  ;            H'L'HL = 0
04344D             8158  ;    Destroys: D,E,H,L,D',E',H',L',A,F
04344D             8159  ;
04344D B7          8160  MULA:			OR      A               ;CLEAR CARRY
04344E D9          8161  MUL0:			EXX
04344F CB 1A       8162          		RR      D               ;MULTIPLIER/2
043451 CB 1B       8163          		RR      E
043453 D9          8164          		EXX
043454 CB 1A       8165          		RR      D
043456 CB 1B       8166          		RR      E
043458 30 07       8167          		JR      NC,MUL1
04345A 52 09       8168          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
04345C D9          8169          		EXX
04345D 52 ED 4A    8170          		ADC.S   HL,BC
043460 D9          8171          		EXX
043461 3C          8172  MUL1:			INC     A
043462 F0          8173          		RET     P
043463 D9          8174  MULB:			EXX
043464 CB 1C       8175          		RR      H               ;PRODUCT/2
043466 CB 1D       8176          		RR      L
043468 D9          8177          		EXX
043469 CB 1C       8178          		RR      H
04346B CB 1D       8179          		RR      L
04346D C3 4E 34 04 8180          		JP      MUL0
043471             8181  ;
043471             8182  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
043471             8183  ;     Function: B'C'BC = SQR (D'E'DE)
043471             8184  ;     Inputs: A = loop counter (normally -31)
043471             8185  ;             B'C'BCH'L'HL initialised to 0
043471             8186  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
043471             8187  ;
043471             8188  SQR1:
043471 52 ED 42    8189  			SBC.S   HL,BC
043474 D9          8190          		EXX
043475 52 ED 42    8191          		SBC.S   HL,BC
043478 D9          8192          		EXX
043479 0C          8193          		INC     C
04347A 30 09       8194          		JR      NC,SQR2
04347C 0D          8195          		DEC     C
04347D 52 09       8196          		ADD.S   HL,BC
04347F D9          8197          		EXX
043480 52 ED 4A    8198          		ADC.S   HL,BC
043483 D9          8199          		EXX
043484 0D          8200          		DEC     C
043485 3C          8201  SQR2:			INC     A
043486 F0          8202          		RET     P
043487 CB 21       8203  SQRA:			SLA     C
043489 CB 10       8204          		RL      B
04348B D9          8205          		EXX
04348C CB 11       8206          		RL      C
04348E CB 10       8207          		RL      B
043490 D9          8208          		EXX
043491 0C          8209          		INC     C
043492 CB 23       8210          		SLA     E
043494 CB 12       8211          		RL      D
043496 D9          8212          		EXX
043497 CB 13       8213          		RL      E
043499 CB 12       8214          		RL      D
04349B D9          8215          		EXX
04349C 52 ED 6A    8216          		ADC.S   HL,HL
04349F D9          8217          		EXX
0434A0 52 ED 6A    8218          		ADC.S   HL,HL
0434A3 D9          8219          		EXX
0434A4 CB 23       8220          		SLA     E
0434A6 CB 12       8221          		RL      D
0434A8 D9          8222          		EXX
0434A9 CB 13       8223          		RL      E
0434AB CB 12       8224          		RL      D
0434AD D9          8225          		EXX
0434AE 52 ED 6A    8226          		ADC.S   HL,HL
0434B1 D9          8227          		EXX
0434B2 52 ED 6A    8228          		ADC.S   HL,HL
0434B5 D9          8229          		EXX
0434B6 D2 71 34 04 8230          		JP      NC,SQR1
0434BA B7          8231  SQR3:			OR      A
0434BB 52 ED 42    8232          		SBC.S   HL,BC
0434BE D9          8233          		EXX
0434BF 52 ED 42    8234          		SBC.S   HL,BC
0434C2 D9          8235          		EXX
0434C3 0C          8236          		INC     C
0434C4 C3 85 34 04 8237          		JP      SQR2
0434C8             8238  ;
0434C8             8239  SQRB:
0434C8 52 29       8240  			ADD.S   HL,HL
0434CA D9          8241          		EXX
0434CB 52 ED 6A    8242          		ADC.S   HL,HL
0434CE D9          8243          		EXX
0434CF 38 E9       8244          		JR      C,SQR3
0434D1 3C          8245          		INC     A
0434D2 0C          8246          		INC     C
0434D3 52 ED 42    8247          		SBC.S   HL,BC
0434D6 D9          8248          		EXX
0434D7 52 ED 42    8249          		SBC.S   HL,BC
0434DA D9          8250          		EXX
0434DB D0          8251          		RET     NC
0434DC 52 09       8252          		ADD.S   HL,BC
0434DE D9          8253          		EXX
0434DF 52 ED 4A    8254          		ADC.S   HL,BC
0434E2 D9          8255          		EXX
0434E3 0D          8256          		DEC     C
0434E4 C9          8257          		RET
0434E5             8258  ;
0434E5 DD 7E 00    8259  DIGITQ:			LD      A,(IX)
0434E8 FE 3A       8260          		CP      '9'+1
0434EA 3F          8261          		CCF
0434EB D8          8262          		RET     C
0434EC FE 30       8263          		CP      '0'
0434EE C9          8264          		RET
0434EF             8265  ;
0434EF DD 7E 00    8266  SIGNQ:			LD      A,(IX)
0434F2 DD 23       8267          		INC     IX
0434F4 FE 20       8268          		CP      ' '
0434F6 28 F7       8269          		JR      Z,SIGNQ
0434F8 FE 2B       8270          		CP      '+'
0434FA C8          8271          		RET     Z
0434FB FE 2D       8272          		CP      '-'
0434FD C8          8273          		RET     Z
0434FE DD 2B       8274          		DEC     IX
043500 C9          8275          		RET
043501             8276  ; ========================================
043501             8277  ; FROM interrupts.asm
043501             8278  ; ----------------------------------------
043501             8279  
043501             8280  ;
043501             8281  ; Title:	BBC Basic for AGON - Interrupts
043501             8282  ; Author:	Dean Belfield
043501             8283  ; Created:	12/05/2023
043501             8284  ; Last Updated:	07/06/2023
043501             8285  ;
043501             8286  ; Modinfo:
043501             8287  ; 07/06/2023:	Modified to run in ADL mode
043501             8288  
043501             8289  			; .ASSUME	ADL = 1
043501             8290  
043501             8291  			; INCLUDE	"macros.inc"
043501             8292  			; INCLUDE	"equs.inc"
043501             8293  			; INCLUDE "mos_api.inc"	; In MOS/src
043501             8294  
043501             8295  			; SEGMENT CODE
043501             8296  
043501             8297  ; 			XDEF	VBLANK_INIT
043501             8298  ; 			XDEF	VBLANK_STOP
043501             8299  ; 			XDEF	VBLANK_HANDLER
043501             8300  
043501             8301  ; 			XREF	ESCSET
043501             8302  ; 			XREF	KEYDOWN		; In ram.asm
043501             8303  ; 			XREF	KEYASCII 	; In ram.asm
043501             8304  ; 			XREF	KEYCOUNT	; In ram.asm
043501             8305  
043501             8306  ; Hook into the MOS VBLANK interrupt
043501             8307  ;
043501 F3          8308  VBLANK_INIT:		DI
043502 21 56 35 04 8309  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
043506 1E 32       8310  			LD		E, 32h				; Set up the VBlank Interrupt Vector
043508             8311  			MOSCALL		mos_setintvector
043508 3E 14       0001M 			LD	A, function
04350A 5B CF       0002M 			RST.L	08h
04350C             8312  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
04350C EB          8313  			ex		de, hl 				; how did the above ever work?
04350D 21 64 35 04 8314  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
043511 ED 1F       8315  			LD		(HL), DE			; Self-modify the code
043513 FB          8316  			EI
043514 C9          8317  			RET
043515             8318  
043515             8319  ; Unhook the custom VBLANK interrupt
043515             8320  ;
043515 F3          8321  VBLANK_STOP:		DI
043516 21 64 35 04 8322  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
04351A ED 17       8323  			LD		DE, (HL)
04351C EB          8324  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
04351D 1E 32       8325  			LD		E, 32h
04351F             8326  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
04351F 3E 14       0001M 			LD	A, function
043521 5B CF       0002M 			RST.L	08h
043523 FB          8327  			EI
043524 C9          8328  			RET
043525             8329  
043525             8330  ; A safe LIS call to ESCSET
043525             8331  ;
043525             8332  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
043525 3E 08       0001M 			LD	A, function
043527 5B CF       0002M 			RST.L	08h
043529 21 49 03 04 8333  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
04352D DD 7E 19    8334  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
043530 BE          8335  			CP 		(HL)				; with our local copy
043531 20 0A       8336  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
043533             8337  ;
043533 AF          8338  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
043534 32 48 03 04 8339  			LD		(KEYASCII), A
043538 32 47 03 04 8340  			LD		(KEYDOWN), A
04353C C9          8341  			RET	 					; And return
04353D             8342  ;
04353D 77          8343  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
04353E DD 7E 18    8344  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
043541 B7          8345  			OR		A
043542 28 EF       8346  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
043544             8347  ;
043544 32 47 03 04 8348  			LD		(KEYDOWN), A 			; Store the keydown value
043548 DD 7E 05    8349  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
04354B 32 48 03 04 8350  			LD		(KEYASCII), A 			; Store locally
04354F FE 1B       8351  			CP		1Bh				; Is it escape?
043551 CC 1C 37 04 8352  			CALL		Z, ESCSET			; Yes, so set the escape flags
043555 C9          8353  			RET						; Return to the interrupt handler
043556             8354  
043556 F3          8355  VBLANK_HANDLER:		DI
043557 F5          8356  			PUSH		AF
043558 E5          8357  			PUSH		HL
043559 DD E5       8358  			PUSH		IX
04355B CD 25 35 04 8359  			CALL		DO_KEYBOARD
04355F DD E1       8360  			POP		IX
043561 E1          8361  			POP		HL
043562 F1          8362  			POP		AF
043563             8363  ;
043563             8364  ; Finally jump to the MOS interrupt
043563             8365  ;
043563 C3 00 00 00 8366  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
043567             8367  ; ========================================
043567             8368  ; FROM misc.asm
043567             8369  ; ----------------------------------------
043567             8370  
043567             8371  ;
043567             8372  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
043567             8373  ; Author:	Dean Belfield
043567             8374  ; Created:	12/05/2023
043567             8375  ; Last Updated:	12/05/2023
043567             8376  ;
043567             8377  ; Modinfo:
043567             8378  
043567             8379  			; INCLUDE	"equs.inc"
043567             8380  			; INCLUDE	"macros.inc"
043567             8381  
043567             8382  			; .ASSUME	ADL = 1
043567             8383  
043567             8384  			; SEGMENT CODE
043567             8385  
043567             8386  ; 			XDEF	ASC_TO_NUMBER
043567             8387  ; 			XDEF	SWITCH_A
043567             8388  ; 			XDEF	NULLTOCR
043567             8389  ; 			XDEF	CRTONULL
043567             8390  ; 			XDEF	CSTR_FNAME
043567             8391  ; 			XDEF	CSTR_LINE
043567             8392  ; 			XDEF	CSTR_FINDCH
043567             8393  ; 			XDEF	CSTR_ENDSWITH
043567             8394  ; 			XDEF	CSTR_CAT
043567             8395  
043567             8396  ; 			XREF	OSWRCH
043567             8397  ; 			XREF	KEYWDS
043567             8398  ; 			XREF	KEYWDL
043567             8399  
043567             8400  ; Read a number and convert to binary
043567             8401  ; If prefixed with &, will read as hex, otherwise decimal
043567             8402  ;   Inputs: HL: Pointer in string buffer
043567             8403  ;  Outputs: HL: Updated text pointer
043567             8404  ;           DE: Value
043567             8405  ;            A: Terminator (spaces skipped)
043567             8406  ; Destroys: A,D,E,H,L,F
043567             8407  ;
043567 C5          8408  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
043568 11 00 00 00 8409  			LD	DE, 0			; Initialise DE
04356C CD AE 35 04 8410  			CALL	SKIPSP_misc			; Skip whitespace
043570 7E          8411  			LD	A, (HL)			; Read first character
043571 FE 26       8412  			CP	'&'			; Is it prefixed with '&' (HEX number)?
043573 20 1F       8413  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
043575 23          8414  			INC	HL			; Otherwise fall through to ASC_TO_HEX
043576             8415  ;
043576 7E          8416  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
043577 CD BC 35 04 8417  			CALL    UPPRC_misc			; Convert to uppercase
04357B D6 30       8418  			SUB	'0'			; Normalise to 0
04357D 38 2E       8419  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
04357F FE 0A       8420  			CP 	10			; Check if >= 10
043581 38 06       8421  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
043583 D6 07       8422  			SUB 	7			; Adjust ASCII A-F to nibble
043585 FE 10       8423  			CP 	16			; Check for > F
043587 30 24       8424  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
043589 EB          8425  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
04358A 29          8426  			ADD	HL, HL
04358B 29          8427  			ADD	HL, HL
04358C 29          8428  			ADD	HL, HL
04358D 29          8429  			ADD	HL, HL
04358E EB          8430  			EX	DE, HL
04358F B3          8431  			OR      E			; OR the new digit in to the least significant nibble
043590 5F          8432  			LD      E, A
043591 23          8433  			INC     HL			; Onto the next character
043592 18 E2       8434  			JR      ASC_TO_NUMBER1		; And loop
043594             8435  ;
043594 7E          8436  ASC_TO_NUMBER3:		LD	A, (HL)
043595 D6 30       8437  			SUB	'0'			; Normalise to 0
043597 38 14       8438  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
043599 FE 0A       8439  			CP	10			; Check if >= 10
04359B 30 10       8440  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
04359D EB          8441  			EX 	DE, HL 			; Stick DE in HL
04359E 44          8442  			LD	B, H 			; And copy HL into BC
04359F 4D          8443  			LD	C, L
0435A0 29          8444  			ADD	HL, HL 			; x 2
0435A1 29          8445  			ADD	HL, HL 			; x 4
0435A2 09          8446  			ADD	HL, BC 			; x 5
0435A3 29          8447  			ADD	HL, HL 			; x 10
0435A4 EB          8448  			EX	DE, HL
0435A5             8449  			ADD8U_DE 			; Add A to DE (macro)
0435A5 83          0001M 			ADD	A, E
0435A6 5F          0002M 			LD	E, A
0435A7 8A          0003M 			ADC	A, D
0435A8 93          0004M 			SUB	E
0435A9 57          0005M 			LD	D, A
0435AA 23          8450  			INC	HL
0435AB 18 E7       8451  			JR	ASC_TO_NUMBER3
0435AD C1          8452  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSP_misc here
0435AE             8453  
0435AE             8454  ; Skip a space
0435AE             8455  ; HL: Pointer in string buffer
0435AE             8456  ;
0435AE 7E          8457  SKIPSP_misc:			LD      A, (HL)
0435AF FE 20       8458  			CP      ' '
0435B1 C0          8459  			RET     NZ
0435B2 23          8460  			INC     HL
0435B3 18 F9       8461  			JR      SKIPSP_misc
0435B5             8462  
0435B5             8463  ; Skip a string
0435B5             8464  ; HL: Pointer in string buffer
0435B5             8465  ;
0435B5 7E          8466  SKIPNOTSP:		LD	A, (HL)
0435B6 FE 20       8467  			CP	' '
0435B8 C8          8468  			RET	Z
0435B9 23          8469  			INC	HL
0435BA 18 F9       8470  			JR	SKIPNOTSP
0435BC             8471  
0435BC             8472  ; Convert a character to upper case
0435BC             8473  ;  A: Character to convert
0435BC             8474  ;
0435BC E6 7F       8475  UPPRC_misc:  		AND     7FH
0435BE FE 60       8476  			CP      '`'
0435C0 D8          8477  			RET     C
0435C1 E6 5F       8478  			AND     5FH			; Convert to upper case
0435C3 C9          8479  			RET
0435C4             8480  
0435C4             8481  ; Switch on A - lookup table immediately after call
0435C4             8482  ;  A: Index into lookup table
0435C4             8483  ;
0435C4 E3          8484  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
0435C5 87          8485  			ADD	A, A			; Multiply A by two
0435C6             8486  			ADD8U_HL 			; Add to HL (macro)
0435C6 85          0001M 			ADD	A, L
0435C7 6F          0002M 			LD	L, A
0435C8 8C          0003M 			ADC	A, H
0435C9 95          0004M 			SUB	L
0435CA 67          0005M 			LD	H, A
0435CB 7E          8487  			LD	A, (HL)			; follow the call. Fetch an address from the
0435CC 23          8488  			INC	HL 			; table.
0435CD 66          8489  			LD	H, (HL)
0435CE 6F          8490  			LD	L, A
0435CF E3          8491  			EX	(SP), HL		; Swap this new address back, restores HL
0435D0 C9          8492  			RET				; Return program control to this new address
0435D1             8493  
0435D1             8494  ; Convert the buffer to a null terminated string and back
0435D1             8495  ; HL: Buffer address
0435D1             8496  ;
0435D1 C5          8497  NULLTOCR:		PUSH 	BC
0435D2 06 00       8498  			LD	B, 0
0435D4 0E 0D       8499  			LD	C, CR
0435D6 18 05       8500  			JR	CRTONULL0
0435D8             8501  ;
0435D8 C5          8502  CRTONULL:		PUSH	BC
0435D9 06 0D       8503  			LD	B, CR
0435DB 0E 00       8504  			LD	C, 0
0435DD             8505  ;
0435DD E5          8506  CRTONULL0:		PUSH	HL
0435DE 7E          8507  CRTONULL1:		LD	A, (HL)
0435DF B8          8508  			CP 	B
0435E0 28 03       8509  			JR	Z, CRTONULL2
0435E2 23          8510  			INC	HL
0435E3 18 F9       8511  			JR	CRTONULL1
0435E5 71          8512  CRTONULL2:		LD	(HL), C
0435E6 E1          8513  			POP 	HL
0435E7 C1          8514  			POP	BC
0435E8 C9          8515  			RET
0435E9             8516  
0435E9             8517  ; Copy a filename to DE and zero terminate it
0435E9             8518  ; HL: Source
0435E9             8519  ; DE: Destination (ACCS)
0435E9             8520  ;
0435E9 7E          8521  CSTR_FNAME:		LD	A, (HL)			; Get source
0435EA FE 20       8522  			CP	32			; Is it space
0435EC 28 09       8523  			JR	Z, @F
0435EE FE 0D       8524  			CP	CR			; Or is it CR
0435F0 28 05       8525  			JR	Z, @F
0435F2 12          8526  			LD	(DE), A			; No, so store
0435F3 23          8527  			INC	HL			; Increment
0435F4 13          8528  			INC	DE
0435F5 18 F2       8529  			JR	CSTR_FNAME		; And loop
0435F7 AF          8530  @@:			XOR	A			; Zero terminate the target string
0435F8 12          8531  			LD	(DE), A
0435F9 13          8532  			INC	DE			; And point to next free address
0435FA C9          8533  			RET
0435FB             8534  
0435FB             8535  ; Copy a CR terminated line to DE and zero terminate it
0435FB             8536  ; HL: Source
0435FB             8537  ; DE: Destination (ACCS)
0435FB             8538  ;
0435FB 7E          8539  CSTR_LINE:		LD	A, (HL)			; Get source
0435FC FE 0D       8540  			CP	CR			; Is it CR
0435FE 28 05       8541  			JR	Z, @F
043600 12          8542  			LD	(DE), A			; No, so store
043601 23          8543  			INC	HL			; Increment
043602 13          8544  			INC	DE
043603 18 F6       8545  			JR	CSTR_LINE		; And loop
043605 AF          8546  @@:			XOR	A			; Zero terminate the target string
043606 12          8547  			LD	(DE), A
043607 13          8548  			INC	DE			; And point to next free address
043608 C9          8549  			RET
043609             8550  
043609             8551  ; Find the first occurrence of a character (case sensitive)
043609             8552  ; HL: Source
043609             8553  ;  C: Character to find
043609             8554  ; Returns:
043609             8555  ; HL: Pointer to character, or end of string marker
043609             8556  ;
043609 7E          8557  CSTR_FINDCH:		LD	A, (HL)			; Get source
04360A B9          8558  			CP	C			; Is it our character?
04360B C8          8559  			RET	Z			; Yes, so exit
04360C B7          8560  			OR	A			; Is it the end of string?
04360D C8          8561  			RET	Z			; Yes, so exit
04360E 23          8562  			INC	HL
04360F 18 F8       8563  			JR	CSTR_FINDCH
043611             8564  
043611             8565  ; Check whether a string ends with another string (case insensitive)
043611             8566  ; HL: Source
043611             8567  ; DE: The substring we want to test with
043611             8568  ; Returns:
043611             8569  ;  F: Z if HL ends with DE, otherwise NZ
043611             8570  ;
043611 7E          8571  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
043612 CD BC 35 04 8572  			CALL	UPPRC_misc			; Convert to upper case
043616 4F          8573  			LD	C, A
043617 1A          8574  			LD	A, (DE)			; Get the substring byte
043618 B9          8575  			CP	C
043619 C0          8576  			RET	NZ			; Return NZ if at any point the strings don't match
04361A B1          8577  			OR	C			; Check whether both bytes are zero
04361B C8          8578  			RET	Z			; If so, return, as we have reached the end of both strings
04361C 23          8579  			INC	HL
04361D 13          8580  			INC	DE
04361E 18 F1       8581  			JR	CSTR_ENDSWITH		; And loop
043620             8582  
043620             8583  ; Concatenate a string onto the end of another string
043620             8584  ; HL: Source
043620             8585  ; DE: Second string
043620             8586  ;
043620 7E          8587  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
043621 B7          8588  			OR	A
043622 28 03       8589  			JR	Z, CSTR_CAT_1
043624 23          8590  			INC	HL
043625 18 F9       8591  			JR	CSTR_CAT
043627             8592  ;
043627 1A          8593  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
043628 77          8594  			LD	(HL), A
043629 B7          8595  			OR	A			; Check for end of string
04362A C8          8596  			RET	Z			; And return
04362B 23          8597  			INC	HL
04362C 13          8598  			INC	DE
04362D 18 F8       8599  			JR	CSTR_CAT_1		; Loop until finished
04362F             8600  ; ========================================
04362F             8601  ; FROM patch.asm
04362F             8602  ; ----------------------------------------
04362F             8603  
04362F             8604  ;
04362F             8605  ; Title:	BBC Basic for AGON
04362F             8606  ; Author:	Dean Belfield
04362F             8607  ; Created:	12/05/2023
04362F             8608  ; Last Updated:	15/11/2023
04362F             8609  ;
04362F             8610  ; Modinfo:
04362F             8611  ; 11/07/2023:	Fixed *BYE for ADL mode
04362F             8612  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
04362F             8613  
04362F             8614  			; .ASSUME	ADL = 1
04362F             8615  
04362F             8616  			; INCLUDE	"equs.inc"
04362F             8617  			; INCLUDE "macros.inc"
04362F             8618  			; INCLUDE "mos_api.inc"	; In MOS/src
04362F             8619  
04362F             8620  			; SEGMENT CODE
04362F             8621  
04362F             8622  ; 			XDEF	OSWRCH
04362F             8623  ; 			XDEF	OSLINE
04362F             8624  ; 			XDEF	ESCSET
04362F             8625  ; 			XDEF	PUTIME
04362F             8626  ; 			XDEF	GETIME
04362F             8627  ; 			XDEF	PUTCSR
04362F             8628  ; 			XDEF 	GETCSR
04362F             8629  ; 			XDEF	OSRDCH
04362F             8630  ; 			XDEF	PROMPT
04362F             8631  ; 			XDEF	OSKEY
04362F             8632  ; 			XDEF	TRAP
04362F             8633  ; 			XDEF	LTRAP
04362F             8634  ; 			XDEF	OSINIT
04362F             8635  ; 			XDEF	OSCLI
04362F             8636  ; 			XDEF	OSBPUT
04362F             8637  ; 			XDEF	OSBGET
04362F             8638  ; 			XDEF	OSSTAT
04362F             8639  ; 			XDEF	OSSHUT
04362F             8640  ; 			XDEF	OSOPEN
04362F             8641  ; 			XDEF	OSCALL
04362F             8642  ; 			XDEF	GETPTR
04362F             8643  ; 			XDEF	PUTPTR
04362F             8644  ; 			XDEF	GETEXT
04362F             8645  ; 			XDEF	GETIMS
04362F             8646  ; 			XDEF	RESET
04362F             8647  ; 			XDEF	OSLOAD
04362F             8648  ; 			XDEF	OSSAVE
04362F             8649  ; 			XDEF	EXPR_W2
04362F             8650  ; 			XDEF	STAR_VERSION
04362F             8651  
04362F             8652  ; 			XREF	_end			; In init.asm
04362F             8653  
04362F             8654  ; 			XREF	ASC_TO_NUMBER
04362F             8655  ; 			XREF	RAM_START
04362F             8656  ; 			XREF	RAM_END
04362F             8657  ; 			XREF	FLAGS
04362F             8658  ; 			XREF	ESCAPE
04362F             8659  ; 			XREF	USER
04362F             8660  ; 			XREF	RAM_Top
04362F             8661  ; 			XREF	EXTERR
04362F             8662  ; 			XREF	COUNT0
04362F             8663  ; 			XREF	EXPRI
04362F             8664  ; 			XREF	COMMA
04362F             8665  ; 			XREF	XEQ
04362F             8666  ; 			XREF	NXT
04362F             8667  ; 			XREF	NULLTOCR
04362F             8668  ; 			XREF	CRLF
04362F             8669  ; 			XREF	CSTR_FNAME
04362F             8670  ; 			XREF	CSTR_LINE
04362F             8671  ; 			XREF	CSTR_FINDCH
04362F             8672  ; 			XREF	CSTR_ENDSWITH
04362F             8673  ; 			XREF	CSTR_CAT
04362F             8674  ; 			XREF	FINDL
04362F             8675  ; 			XREF	OUT_
04362F             8676  ; 			XREF	ERROR_
04362F             8677  ; 			XREF	ONEDIT
04362F             8678  ; 			XREF	TELL
04362F             8679  ; 			XREF	OSWRCHPT
04362F             8680  ; 			XREF	OSWRCHCH
04362F             8681  ; 			XREF	OSWRCHFH
04362F             8682  ; 			XREF	LISTON
04362F             8683  ; 			XREF	LISTIT
04362F             8684  ; 			XREF	PAGE_
04362F             8685  ; 			XREF	ONEDIT1
04362F             8686  ; 			XREF	CLEAN
04362F             8687  ; 			XREF	NEWIT
04362F             8688  ; 			XREF	BAD
04362F             8689  ; 			XREF	VBLANK_INIT
04362F             8690  ; 			XREF	VBLANK_STOP
04362F             8691  ; 			XREF	KEYDOWN
04362F             8692  ; 			XREF	KEYASCII
04362F             8693  ; 			XREF	WIDTH
04362F             8694  ; 			XREF	ASSEM
04362F             8695  
04362F             8696  ; OSLINE: Invoke the line editor
04362F             8697  ;
04362F 1E 01       8698  OSLINE:			LD 	E, 1			; Default is to clear the buffer
043631             8699  
043631             8700  ; Entry point to line editor that does not clear the buffer
043631             8701  ;
043631 FD E5       8702  OSLINE1:		PUSH	IY
043633 E5          8703  			PUSH	HL			; Buffer address
043634 01 00 01 00 8704  			LD	BC, 256			; Buffer length
043638             8705  			MOSCALL	mos_editline		; Call the MOS line editor
043638 3E 09       0001M 			LD	A, function
04363A 5B CF       0002M 			RST.L	08h
04363C E1          8706  			POP	HL			; Pop the address
04363D FD E1       8707  			POP	IY
04363F F5          8708  			PUSH	AF			; Stack the return value (key pressed)
043640 CD D1 35 04 8709  			CALL	NULLTOCR		; Turn the 0 character to a CR
043644 CD 44 45 04 8710  			CALL	CRLF			; Display CRLF
043648 F1          8711  			POP	AF
043649 FE 1B       8712  			CP	1Bh 			; Check if ESC terminated the input
04364B CA 47 37 04 8713  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
04364F 3A 42 03 04 8714  			LD	A, (FLAGS)		; Otherwise
043653 CB BF       8715  			RES	7, A 			; Clear the escape flag
043655 32 42 03 04 8716  			LD	(FLAGS), A
043659 CD 1E 39 04 8717  			CALL	WAIT_VBLANK 		; Wait a frame
04365D AF          8718   			XOR	A			; Return A = 0
04365E 32 47 03 04 8719  			LD	(KEYDOWN), A
043662 32 48 03 04 8720  			LD	(KEYASCII), A
043666 C9          8721  			RET
043667             8722  
043667             8723  ; PUTIME: set current time to DE:HL, in centiseconds.
043667             8724  ;
043667 DD E5       8725  PUTIME:			PUSH 	IX
043669             8726  			MOSCALL	mos_sysvars
043669 3E 08       0001M 			LD	A, function
04366B 5B CF       0002M 			RST.L	08h
04366D DD 75 00    8727  			LD	(IX + sysvar_time + 0), L
043670 DD 74 01    8728  			LD	(IX + sysvar_time + 1), H
043673 DD 73 02    8729  			LD	(IX + sysvar_time + 2), E
043676 DD 72 03    8730  			LD	(IX + sysvar_time + 3), D
043679 DD E1       8731  			POP	IX
04367B C9          8732  			RET
04367C             8733  
04367C             8734  ; GETIME: return current time in DE:HL, in centiseconds
04367C             8735  ;
04367C DD E5       8736  GETIME:			PUSH 	IX
04367E             8737  			MOSCALL	mos_sysvars
04367E 3E 08       0001M 			LD	A, function
043680 5B CF       0002M 			RST.L	08h
043682 DD 6E 00    8738  			LD	L, (IX + sysvar_time + 0)
043685 DD 66 01    8739  			LD	H, (IX + sysvar_time + 1)
043688 DD 5E 02    8740  			LD	E, (IX + sysvar_time + 2)
04368B DD 56 03    8741  			LD	D, (IX + sysvar_time + 3)
04368E DD E1       8742  			POP	IX
043690 C9          8743  			RET
043691             8744  
043691             8745  ; PUTCSR: move to cursor to x=DE, y=HL
043691             8746  ;
043691 3E 1F       8747  PUTCSR:			LD	A, 1Fh			; TAB
043693 5B D7       8748  			RST.LIL	10h
043695 7B          8749  			LD	A, E			; X
043696 5B D7       8750  			RST.LIL 10h
043698 7D          8751  			LD	A, L			; Y
043699 5B D7       8752  			RST.LIL 10h
04369B C9          8753  			RET
04369C             8754  
04369C             8755  ; GETCSR: return cursor position in x=DE, y=HL
04369C             8756  ;
04369C DD E5       8757  GETCSR:			PUSH	IX			; Get the system vars in IX
04369E             8758  			MOSCALL	mos_sysvars		; Reset the semaphore
04369E 3E 08       0001M 			LD	A, function
0436A0 5B CF       0002M 			RST.L	08h
0436A2 DD CB 04 86 8759  			RES	0, (IX+sysvar_vpd_pflags)
0436A6             8760  			VDU	23
0436A6 3E 17       0001M 			LD	A, val
0436A8 CD D0 36 04 0002M 			CALL	OSWRCH
0436AC             8761  			VDU	0
0436AC 3E 00       0001M 			LD	A, val
0436AE CD D0 36 04 0002M 			CALL	OSWRCH
0436B2             8762  			VDU	vdp_cursor
0436B2 3E 82       0001M 			LD	A, val
0436B4 CD D0 36 04 0002M 			CALL	OSWRCH
0436B8 DD CB 04 46 8763  @@:			BIT	0, (IX+sysvar_vpd_pflags)
0436BC 28 FA       8764  			JR	Z, @B			; Wait for the result
0436BE 16 00       8765  			LD 	D, 0
0436C0 62          8766  			LD	H, D
0436C1 DD 5E 07    8767  			LD	E, (IX + sysvar_cursorX)
0436C4 DD 6E 08    8768  			LD	L, (IX + sysvar_cursorY)
0436C7 DD E1       8769  			POP	IX
0436C9 C9          8770  			RET
0436CA             8771  
0436CA             8772  ; PROMPT: output the input prompt
0436CA             8773  ;
0436CA 3E 3E       8774  PROMPT: 		LD	A,'>'
0436CC C3 D0 36 04 8775  			JP	OSWRCH
0436D0             8776  
0436D0             8777  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
0436D0             8778  ; A: Character to write
0436D0             8779  ;
0436D0 E5          8780  OSWRCH:			PUSH	HL
0436D1 21 40 03 04 8781  			LD	HL, LISTON		; Fetch the LISTON variable
0436D5 CB 5E       8782  			BIT	3, (HL)			; Check whether we are in *EDIT mode
0436D7 20 0B       8783  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0436D9             8784  ;
0436D9 2A 45 03 04 8785  			LD	HL, (OSWRCHCH)		; L: Channel #
0436DD 2D          8786  			DEC	L			; If it is 1
0436DE 28 10       8787  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0436E0             8788  ;
0436E0 E1          8789  			POP	HL			; Otherwise
0436E1 5B D7       8790  			RST.LIL	10h			; Output the character to MOS
0436E3 C9          8791  			RET
0436E4             8792  ;
0436E4 2A 43 03 04 8793  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0436E8 77          8794  			LD	(HL), A			; Echo the character into the buffer
0436E9 23          8795  			INC	HL			; Increment pointer
0436EA 22 43 03 04 8796  			LD	(OSWRCHPT), HL		; Write pointer back
0436EE E1          8797  			POP	HL
0436EF C9          8798  			RET
0436F0             8799  ;
0436F0 D5          8800  OSWRCH_FILE:		PUSH	DE
0436F1 5C          8801  			LD	E, H			; Filehandle to E
0436F2 CD 1C 3B 04 8802  			CALL	OSBPUT			; Write the byte out
0436F6 D1          8803  			POP	DE
0436F7 E1          8804  			POP	HL
0436F8 C9          8805  			RET
0436F9             8806  
0436F9             8807  ; OSRDCH: Read a character in from the ESP32 keyboard handler
0436F9             8808  ; This is only called in GETS (eval.asm)
0436F9             8809  ;
0436F9             8810  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0436F9 3E 00       0001M 			LD	A, function
0436FB 5B CF       0002M 			RST.L	08h
0436FD FE 1B       8811  			CP	1Bh
0436FF 28 46       8812  			JR	Z, LTRAP1
043701 C9          8813  			RET
043702             8814  
043702             8815  
043702             8816  ;OSKEY - Read key with time-limit, test for ESCape.
043702             8817  ;Main function is carried out in user patch.
043702             8818  ;   Inputs: HL = time limit (centiseconds)
043702             8819  ;  Outputs: Carry reset if time-out
043702             8820  ;           If carry set A = character
043702             8821  ; Destroys: A,H,L,F
043702             8822  ;
043702 CD 33 37 04 8823  OSKEY:			CALL	READKEY			; Read the keyboard
043706 28 0A       8824  			JR	Z, @F 			; Skip if we have a key
043708 7C          8825  			LD	A, H 			; Check loop counter
043709 B5          8826  			OR 	L
04370A C8          8827  			RET 	Z 			; Return, we've not got a key at this point
04370B CD 1E 39 04 8828  			CALL	WAIT_VBLANK 		; Wait a frame
04370F 2B          8829  			DEC 	HL			; Decrement
043710 18 F0       8830  			JR	OSKEY 			; And loop
043712             8831  ;
043712 21 47 03 04 8832  @@:			LD	HL, KEYDOWN		; We have a key, so
043716 36 00       8833  			LD	(HL), 0			; clear the keydown flag
043718 FE 1B       8834  			CP	1BH			; If we are not pressing ESC,
04371A 37          8835  			SCF 				; then flag we've got a character
04371B C0          8836  			RET	NZ
04371C             8837  ;
04371C             8838  ; ESCSET
04371C             8839  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
04371C             8840  ;
04371C E5          8841  ESCSET: 		PUSH    HL
04371D 21 42 03 04 8842          		LD      HL,FLAGS		; Pointer to FLAGS
043721 CB 76       8843          		BIT     6,(HL)			; If bit 6 is set, then
043723 20 02       8844          		JR      NZ,ESCDIS		; escape is disabled, so skip
043725 CB FE       8845          		SET     7,(HL)			; Set bit 7, the escape flag
043727 E1          8846  ESCDIS: 		POP     HL
043728 C9          8847          		RET
043729             8848  ;
043729             8849  ; ESCTEST
043729             8850  ; Test for ESC key
043729             8851  ;
043729 CD 33 37 04 8852  ESCTEST:		CALL	READKEY			; Read the keyboard
04372D C0          8853  			RET	NZ			; Skip if no key is pressed
04372E FE 1B       8854  			CP	1BH			; If ESC pressed then
043730 28 EA       8855  			JR	Z,ESCSET		; jump to the escape set routine
043732 C9          8856  			RET
043733             8857  
043733             8858  ; Read the keyboard
043733             8859  ; Returns:
043733             8860  ; - A: ASCII of the pressed key
043733             8861  ; - F: Z if the key is pressed, otherwise NZ
043733             8862  ;
043733 3A 47 03 04 8863  READKEY:		LD	A, (KEYDOWN)		; Get key down
043737 3D          8864  			DEC	A 			; Set Z flag if keydown is 1
043738 3A 48 03 04 8865  			LD	A, (KEYASCII)		; Get key ASCII value
04373C C9          8866  			RET
04373D             8867  ;
04373D             8868  ; TRAP
04373D             8869  ; This is called whenever BASIC needs to check for ESC
04373D             8870  ;
04373D CD 29 37 04 8871  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
043741             8872  ;
043741 3A 42 03 04 8873  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
043745 B7          8874  			OR	A			; This checks for bit 7; if it is not set then the result will
043746 F0          8875  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
043747 21 42 03 04 8876  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
04374B CB BE       8877  			RES	7,(HL)			; Clear the escape pressed flag and
04374D C3 BB 15 04 8878  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
043751             8879  
043751             8880  ;OSINIT - Initialise RAM mapping etc.
043751             8881  ;If BASIC is entered by BBCBASIC FILENAME then file
043751             8882  ;FILENAME.BBC is automatically CHAINed.
043751             8883  ;   Outputs: DE = initial value of HIMEM (top of RAM)
043751             8884  ;            HL = initial value of PAGE (user program)
043751             8885  ;            Z-flag reset indicates AUTO-RUN.
043751             8886  ;  Destroys: A,D,E,H,L,F
043751             8887  ;
043751 CD 01 35 04 8888  OSINIT:			CALL	VBLANK_INIT
043755 AF          8889  			XOR	A
043756 21 00 04 04 8890  			LD 	HL, USER
04375A 11 00 00 0B 8891  			LD	DE, RAM_Top
04375E 5F          8892  			LD	E, A			; Page boundary
04375F C9          8893  			RET
043760             8894  
043760             8895  ;
043760             8896  ;OSCLI - Process a MOS command
043760             8897  ;
043760 CD D4 37 04 8898  OSCLI: 			CALL    SKIPSP_patch
043764 FE 0D       8899  			CP      CR
043766 C8          8900  			RET     Z
043767 FE 7C       8901  			CP      '|'
043769 C8          8902  			RET     Z
04376A EB          8903  			EX      DE,HL
04376B 21 E3 37 04 8904  			LD      HL,COMDS
04376F 1A          8905  OSCLI0:			LD      A,(DE)
043770 CD DB 37 04 8906  			CALL    UPPRC_patch
043774 BE          8907  			CP      (HL)
043775 28 0B       8908  			JR      Z,OSCLI2
043777 38 30       8909  			JR      C,OSCLI6
043779 CB 7E       8910  OSCLI1:			BIT     7,(HL)
04377B 23          8911  			INC     HL
04377C 28 FB       8912  			JR      Z,OSCLI1
04377E 23          8913  			INC     HL
04377F 23          8914  			INC     HL
043780 18 ED       8915  			JR      OSCLI0
043782             8916  ;
043782 D5          8917  OSCLI2:			PUSH    DE
043783 13          8918  OSCLI3:			INC     DE
043784 23          8919  			INC     HL
043785 1A          8920  			LD      A,(DE)
043786 CD DB 37 04 8921  			CALL    UPPRC_patch
04378A FE 2E       8922  			CP      '.'			; ABBREVIATED?
04378C 28 0A       8923  			JR      Z,OSCLI4
04378E AE          8924  			XOR     (HL)
04378F 28 F2       8925  			JR      Z,OSCLI3
043791 FE 80       8926  			CP      80H
043793 28 03       8927  			JR      Z,OSCLI4
043795 D1          8928  			POP     DE
043796 18 E1       8929  			JR      OSCLI1
043798             8930  ;
043798 F1          8931  OSCLI4:			POP     AF
043799 13          8932  		        INC     DE
04379A CB 7E       8933  OSCLI5:			BIT     7,(HL)
04379C 23          8934  			INC     HL
04379D 28 FB       8935  			JR      Z,OSCLI5
04379F 7E          8936  			LD      A,(HL)
0437A0 23          8937  			INC     HL
0437A1 66          8938  			LD      H,(HL)
0437A2 6F          8939  			LD      L,A
0437A3 E5          8940  			PUSH    HL
0437A4 EB          8941  			EX      DE,HL
0437A5 C3 D4 37 04 8942  			JP      SKIPSP_patch
0437A9             8943  ;
0437A9 EB          8944  OSCLI6:			EX	DE, HL			; HL: Buffer for command
0437AA 11 00 00 04 8945  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0437AE D5          8946  			PUSH	DE			; Store buffer address
0437AF CD FB 35 04 8947  			CALL	CSTR_LINE		; Fetch the line
0437B3 E1          8948  			POP	HL			; HL: Pointer to command string in ACCS
0437B4 FD E5       8949  			PUSH	IY
0437B6             8950  			MOSCALL	mos_oscli		; Returns OSCLI error in A
0437B6 3E 10       0001M 			LD	A, function
0437B8 5B CF       0002M 			RST.L	08h
0437BA FD E1       8951  			POP	IY
0437BC B7          8952  			OR	A			; 0 means MOS returned OK
0437BD C8          8953  			RET	Z			; So don't do anything
0437BE C3 F8 39 04 8954  			JP 	OSERROR			; Otherwise it's a MOS error
0437C2             8955  
0437C2 3E FE       8956  HUH:    		LD      A,254			; Bad command error
0437C4 CD 74 43 04 8957          		CALL    EXTERR
0437C8 42 61 64 20 8958          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0437D3 00          8959          		DEFB    0
0437D4             8960  
0437D4 7E          8961  SKIPSP_patch:			LD      A,(HL)
0437D5 FE 20       8962          		CP      ' '
0437D7 C0          8963          		RET     NZ
0437D8 23          8964          		INC     HL
0437D9 18 F9       8965          		JR      SKIPSP_patch
0437DB             8966  
0437DB E6 7F       8967  UPPRC_patch:  		AND     7FH
0437DD FE 60       8968  			CP      '`'
0437DF D8          8969  			RET     C
0437E0 E6 5F       8970  			AND     5FH			; CONVERT TO UPPER CASE
0437E2 C9          8971  			RET
0437E3             8972  
0437E3             8973  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0437E3             8974  ; These must be in alphabetical order
0437E3             8975  ;
0437E3 41 53 4D    8976  COMDS:  		DB	"AS","M"+80h		; ASM
0437E6 01 38       8977  			DW	STAR_ASM
0437E8 42 59 45    8978  			DB	"BY","E"+80h		; BYE
0437EB 0D 38       8979  			DW	STAR_BYE
0437ED 45 44 49 54 8980  			DB	"EDI","T"+80h		; EDIT
0437F1 42 38       8981  			DW	STAR_EDIT
0437F3 46 58       8982  			DB	"F","X"+80h		; FX
0437F5 82 38       8983  			DW	STAR_FX
0437F7 56 45 52 53 8984  			DB	"VERSIO","N"+80h	; VERSION
       49 4F 4E    
0437FE 19 38       8985  			DW	STAR_VERSION
043800 FF          8986  			DB	FFh
043801             8987  
043801             8988  ; *ASM string
043801             8989  ;
043801 FD E5       8990  STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
043803 E5          8991  			PUSH	HL			; HL = IY
043804 FD E1       8992  			POP	IY
043806 CD E5 21 04 8993  			CALL	ASSEM			; Invoke the assembler
04380A FD E1       8994  			POP	IY
04380C C9          8995  			RET
04380D             8996  
04380D             8997  ; *BYE
04380D             8998  ;
04380D CD 15 35 04 8999  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
043811 21 00 00 00 9000  			LD	HL, 0			; The return value
043815 C3 68 04 04 9001  			JP	_end 			; Jump back to the end routine in init.asm
043819             9002  
043819             9003  ; *VERSION
043819             9004  ;
043819 CD 8D 49 04 9005  STAR_VERSION:		CALL    TELL			; Output the welcome message
04381D 42 42 43 20 9006  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
043841 C9          9007  			RET
043842             9008  
043842             9009  ; *EDIT linenum
043842             9010  ;
043842 CD 67 35 04 9011  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
043846 EB          9012  			EX	DE, HL			; HL: Line number
043847 CD 8C 45 04 9013  			CALL	FINDL			; HL: Address in RAM of tokenised line
04384B 3E 29       9014  			LD	A, 41			; F:NZ If the line is not found
04384D C2 5D 43 04 9015  			JP	NZ, ERROR_		; Do error 41: No such line in that case
043851             9016  ;
043851             9017  ; Use LISTIT to output the line to the ACCS buffer
043851             9018  ;
043851 23          9019  			INC	HL			; Skip the length byte
043852 5E          9020  			LD	E, (HL)			; Fetch the line number
043853 23          9021  			INC	HL
043854 56          9022  			LD	D, (HL)
043855 23          9023  			INC	HL
043856 DD 21 00 00 9024  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       04          
04385B DD 22 43 03 9025  			LD	(OSWRCHPT), IX
       04          
043860 DD 21 40 03 9026  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       04          
043865 DD 7E 00    9027  			LD	A, (IX)			; Store that variable
043868 F5          9028  			PUSH	AF
043869 DD 36 00 09 9029  			LD	(IX), 09h		; Set to echo to buffer
04386D CD 8F 44 04 9030  			CALL	LISTIT
043871 F1          9031  			POP	AF
043872 DD 77 00    9032  			LD	(IX), A			; Restore the original LISTON variable
043875 21 00 00 04 9033  			LD	HL, ACCS		; HL: ACCS
043879 5D          9034  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
04387A CD 31 36 04 9035  			CALL	OSLINE1			; Invoke the editor
04387E C3 95 3C 04 9036  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
043882             9037  
043882             9038  ; OSCLI FX n
043882             9039  ;
043882 CD 67 35 04 9040  STAR_FX:		CALL	ASC_TO_NUMBER
043886 4B          9041  			LD	C, E			; C: Save FX #
043887 CD 67 35 04 9042  			CALL	ASC_TO_NUMBER
04388B 7A          9043  			LD	A, D  			; Is first parameter > 255?
04388C B7          9044  			OR 	A
04388D 28 03       9045  			JR	Z, STAR_FX1		; Yes, so skip next bit
04388F EB          9046  			EX	DE, HL 			; Parameter is 16-bit
043890 18 07       9047  			JR	STAR_FX2
043892             9048  ;
043892 43          9049  STAR_FX1:		LD	B, E 			; B: Save First parameter
043893 CD 67 35 04 9050  			CALL	ASC_TO_NUMBER		; Fetch second parameter
043897 68          9051  			LD	L, B 			; L: First parameter
043898 63          9052  			LD	H, E 			; H: Second parameter
043899             9053  ;
043899 79          9054  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
04389A             9055  ;
04389A             9056  ; OSBYTE
04389A             9057  ;  A: FX #
04389A             9058  ;  L: First parameter
04389A             9059  ;  H: Second parameter
04389A             9060  ;
04389A FE 0B       9061  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
04389C 28 18       9062  			JR	Z, OSBYTE_0B
04389E FE 0C       9063  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0438A0 28 43       9064  			JR	Z, OSBYTE_0C
0438A2 FE 13       9065  			CP	13H			; *FX 19: Wait for vblank
0438A4 28 6E       9066  			JR	Z, OSBYTE_13
0438A6 FE 76       9067  			CP	76H			; *FX 118, n: Set keyboard LED
0438A8 CA 2F 39 04 9068  			JP	Z, OSBYTE_76
0438AC FE A0       9069  			CP	A0H
0438AE CA 5F 39 04 9070  			JP	Z, OSBYTE_A0
0438B2 C3 C2 37 04 9071  			JP	HUH			; Anything else trips an error
0438B6             9072  
0438B6             9073  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0438B6             9074  ; Parameters:
0438B6             9075  ; - HL: Repeat delay
0438B6             9076  ;
0438B6             9077  OSBYTE_0B:		VDU	23
0438B6 3E 17       0001M 			LD	A, val
0438B8 CD D0 36 04 0002M 			CALL	OSWRCH
0438BC             9078  			VDU	0
0438BC 3E 00       0001M 			LD	A, val
0438BE CD D0 36 04 0002M 			CALL	OSWRCH
0438C2             9079  			VDU	vdp_keystate
0438C2 3E 88       0001M 			LD	A, val
0438C4 CD D0 36 04 0002M 			CALL	OSWRCH
0438C8             9080  			VDU	L
0438C8 7D          0001M 			LD	A, val
0438C9 CD D0 36 04 0002M 			CALL	OSWRCH
0438CD             9081  			VDU	H
0438CD 7C          0001M 			LD	A, val
0438CE CD D0 36 04 0002M 			CALL	OSWRCH
0438D2             9082  			VDU	0
0438D2 3E 00       0001M 			LD	A, val
0438D4 CD D0 36 04 0002M 			CALL	OSWRCH
0438D8             9083  			VDU 	0
0438D8 3E 00       0001M 			LD	A, val
0438DA CD D0 36 04 0002M 			CALL	OSWRCH
0438DE             9084  			VDU	255
0438DE 3E FF       0001M 			LD	A, val
0438E0 CD D0 36 04 0002M 			CALL	OSWRCH
0438E4 C9          9085  			RET
0438E5             9086  
0438E5             9087  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
0438E5             9088  ; Parameters:
0438E5             9089  ; - HL: Repeat rate
0438E5             9090  ;
0438E5             9091  OSBYTE_0C:		VDU	23
0438E5 3E 17       0001M 			LD	A, val
0438E7 CD D0 36 04 0002M 			CALL	OSWRCH
0438EB             9092  			VDU	0
0438EB 3E 00       0001M 			LD	A, val
0438ED CD D0 36 04 0002M 			CALL	OSWRCH
0438F1             9093  			VDU	vdp_keystate
0438F1 3E 88       0001M 			LD	A, val
0438F3 CD D0 36 04 0002M 			CALL	OSWRCH
0438F7             9094  			VDU	0
0438F7 3E 00       0001M 			LD	A, val
0438F9 CD D0 36 04 0002M 			CALL	OSWRCH
0438FD             9095  			VDU 	0
0438FD 3E 00       0001M 			LD	A, val
0438FF CD D0 36 04 0002M 			CALL	OSWRCH
043903             9096  			VDU	L
043903 7D          0001M 			LD	A, val
043904 CD D0 36 04 0002M 			CALL	OSWRCH
043908             9097  			VDU	H
043908 7C          0001M 			LD	A, val
043909 CD D0 36 04 0002M 			CALL	OSWRCH
04390D             9098  			VDU	255
04390D 3E FF       0001M 			LD	A, val
04390F CD D0 36 04 0002M 			CALL	OSWRCH
043913 C9          9099  			RET
043914             9100  
043914             9101  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
043914             9102  ;
043914 CD 1E 39 04 9103  OSBYTE_13:		CALL	WAIT_VBLANK
043918 2E 00       9104  			LD	L, 0			; Returns 0
04391A C3 9C 0E 04 9105  			JP	COUNT0
04391E             9106  ;
04391E DD E5       9107  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
043920             9108  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
043920 3E 08       0001M 			LD	A, function
043922 5B CF       0002M 			RST.L	08h
043924 DD 7E 00    9109  			LD	A, (IX + sysvar_time + 0)
043927 DD BE 00    9110  @@:			CP 	A, (IX + sysvar_time + 0)
04392A 28 FB       9111  			JR	Z, @B
04392C DD E1       9112  			POP	IX
04392E C9          9113  			RET
04392F             9114  
04392F             9115  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
04392F             9116  ; Parameters:
04392F             9117  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
04392F             9118  ;
04392F             9119  OSBYTE_76:		VDU	23
04392F 3E 17       0001M 			LD	A, val
043931 CD D0 36 04 0002M 			CALL	OSWRCH
043935             9120  			VDU	0
043935 3E 00       0001M 			LD	A, val
043937 CD D0 36 04 0002M 			CALL	OSWRCH
04393B             9121  			VDU	vdp_keystate
04393B 3E 88       0001M 			LD	A, val
04393D CD D0 36 04 0002M 			CALL	OSWRCH
043941             9122  			VDU	0
043941 3E 00       0001M 			LD	A, val
043943 CD D0 36 04 0002M 			CALL	OSWRCH
043947             9123  			VDU 	0
043947 3E 00       0001M 			LD	A, val
043949 CD D0 36 04 0002M 			CALL	OSWRCH
04394D             9124  			VDU	0
04394D 3E 00       0001M 			LD	A, val
04394F CD D0 36 04 0002M 			CALL	OSWRCH
043953             9125  			VDU	0
043953 3E 00       0001M 			LD	A, val
043955 CD D0 36 04 0002M 			CALL	OSWRCH
043959             9126  			VDU	L
043959 7D          0001M 			LD	A, val
04395A CD D0 36 04 0002M 			CALL	OSWRCH
04395E C9          9127  			RET
04395F             9128  
04395F             9129  ; OSBYTE 0xA0: Fetch system variable
04395F             9130  ; Parameters:
04395F             9131  ; - L: The system variable to fetch
04395F             9132  ;
04395F DD E5       9133  OSBYTE_A0:		PUSH	IX
043961             9134  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
043961 3E 08       0001M 			LD	A, function
043963 5B CF       0002M 			RST.L	08h
043965 01 00 00 00 9135  			LD	BC, 0
043969 4D          9136  			LD	C, L			; BCU = L
04396A DD 09       9137  			ADD	IX, BC			; Add to IX
04396C DD 6E 00    9138  			LD	L, (IX + 0)		; Fetch the return value
04396F DD E1       9139  			POP	IX
043971 C3 9C 0E 04 9140  			JP 	COUNT0
043975             9141  
043975             9142  ;OSLOAD - Load an area of memory from a file.
043975             9143  ;   Inputs: HL addresses filename (CR terminated)
043975             9144  ;           DE = address at which to load
043975             9145  ;           BC = maximum allowed size (bytes)
043975             9146  ;  Outputs: Carry reset indicates no room for file.
043975             9147  ; Destroys: A,B,C,D,E,H,L,F
043975             9148  ;
043975 C5          9149  OSLOAD:			PUSH	BC			; Stack the size
043976 D5          9150  			PUSH	DE			; Stack the load address
043977 11 00 00 04 9151  			LD	DE, ACCS		; Buffer address for filename
04397B CD E9 35 04 9152  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
04397F 21 00 00 04 9153  			LD	HL, ACCS		; HL: Filename
043983 CD 75 3A 04 9154  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
043987 CD 89 3A 04 9155  			CALL	EXT_HANDLER		; Get the default handler
04398B D1          9156  			POP	DE			; Restore the load address
04398C C1          9157  			POP	BC			; Restore the size
04398D B7          9158  			OR	A
04398E 28 60       9159  			JR 	Z, OSLOAD_BBC
043990             9160  ;
043990             9161  ; Load the file in as a text file
043990             9162  ;
043990 AF          9163  OSLOAD_TXT:		XOR	A			; Set file attributes to read
043991 CD FD 3A 04 9164  			CALL	OSOPEN			; Open the file
043995 5F          9165  			LD 	E, A 			; The filehandle
043996 B7          9166  			OR	A
043997 3E 04       9167  			LD	A, 4			; File not found error
043999 28 5D       9168  			JR	Z, OSERROR		; Jump to error handler
04399B CD 69 44 04 9169  			CALL	NEWIT			; Call NEW to clear the program space
04399F             9170  ;
04399F 21 00 00 04 9171  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0439A3             9172  ;
0439A3             9173  ; First skip any whitespace (indents) at the beginning of the input
0439A3             9174  ;
0439A3 CD 14 3B 04 9175  @@:			CALL	OSBGET			; Read the byte into A
0439A7 38 1E       9176  			JR	C, OSLOAD_TXT3		; Is it EOF?
0439A9 FE 0A       9177  			CP	LF 			; Is it LF?
0439AB 28 1A       9178  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0439AD FE 21       9179  			CP	21h			; Is it less than or equal to ASCII space?
0439AF 38 F2       9180  			JR	C, @B 			; Yes, so keep looping
0439B1 77          9181  			LD	(HL), A 		; Store the first character
0439B2 2C          9182  			INC	L
0439B3             9183  ;
0439B3             9184  ; Now read the rest of the line in
0439B3             9185  ;
0439B3 CD 14 3B 04 9186  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0439B7 38 2B       9187  			JR	C, OSLOAD_TXT4		; Is it EOF?
0439B9 FE 20       9188  			CP	20h			; Skip if not an ASCII character
0439BB 38 06       9189  			JR	C, @F
0439BD 77          9190  			LD	(HL), A 		; Store in the input buffer
0439BE 2C          9191  			INC	L			; Increment the buffer pointer
0439BF CA F5 42 04 9192  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0439C3 FE 0A       9193  @@:			CP	LF			; Check for LF
0439C5 20 EC       9194  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0439C7             9195  ;
0439C7             9196  ; Finally, handle EOL/EOF
0439C7             9197  ;
0439C7 36 0D       9198  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0439C9 7D          9199  			LD	A, L			; Check for minimum line length
0439CA FE 02       9200  			CP	2			; If it is 2 characters or less (including CR)
0439CC 38 0A       9201  			JR	C, @F			; Then don't bother entering it
0439CE D5          9202  			PUSH	DE			; Preserve the filehandle
0439CF CD A1 3C 04 9203  			CALL	ONEDIT1			; Enter the line in memory
0439D3 DC 3C 44 04 9204  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0439D7 D1          9205  			POP	DE
0439D8 CD 25 3B 04 9206  @@:			CALL	OSSTAT			; End of file?
0439DC 20 C1       9207  			JR	NZ, OSLOAD_TXT1		; No, so loop
0439DE CD 0C 3B 04 9208  			CALL	OSSHUT			; Close the file
0439E2 37          9209  			SCF				; Flag to BASIC that we're good
0439E3 C9          9210  			RET
0439E4             9211  ;
0439E4             9212  ; Special case for BASIC programs with no blank line at the end
0439E4             9213  ;
0439E4 FE 20       9214  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0439E6 38 06       9215  			JR	C, @F
0439E8 77          9216  			LD	(HL), A			; Store the character
0439E9 2C          9217  			INC	L
0439EA CA F5 42 04 9218  			JP	Z, BAD
0439EE 18 D7       9219  @@:			JR	OSLOAD_TXT3
0439F0             9220  
0439F0             9221  ;
0439F0             9222  ; Load the file in as a tokenised binary blob
0439F0             9223  ;
0439F0             9224  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0439F0 3E 01       0001M 			LD	A, function
0439F2 5B CF       0002M 			RST.L	08h
0439F4 D0          9225  			RET	NC			; If load returns with carry reset - NO ROOM
0439F5 B7          9226  			OR	A			; If there is no error (A=0)
0439F6 37          9227  			SCF				; Need to set carry indicating there was room
0439F7 C8          9228  			RET	Z			; Return
0439F8             9229  ;
0439F8 F5          9230  OSERROR:		PUSH	AF			; Handle the MOS error
0439F9 21 00 00 04 9231  			LD	HL, ACCS		; Address of the buffer
0439FD 01 00 01 00 9232  			LD	BC, 256			; Length of the buffer
043A01 5F          9233  			LD	E, A			; The error code
043A02             9234  			MOSCALL	mos_getError		; Copy the error message into the buffer
043A02 3E 0F       0001M 			LD	A, function
043A04 5B CF       0002M 			RST.L	08h
043A06 F1          9235  			POP	AF
043A07 E5          9236  			PUSH	HL			; Stack the address of the error (now in ACCS)
043A08 C6 7F       9237  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
043A0A C3 74 43 04 9238  			JP	EXTERR			; Trigger an external error
043A0E             9239  
043A0E             9240  ;OSSAVE - Save an area of memory to a file.
043A0E             9241  ;   Inputs: HL addresses filename (term CR)
043A0E             9242  ;           DE = start address of data to save
043A0E             9243  ;           BC = length of data to save (bytes)
043A0E             9244  ; Destroys: A,B,C,D,E,H,L,F
043A0E             9245  ;
043A0E C5          9246  OSSAVE:			PUSH	BC			; Stack the size
043A0F D5          9247  			PUSH	DE			; Stack the save address
043A10 11 00 00 04 9248  			LD	DE, ACCS		; Buffer address for filename
043A14 CD E9 35 04 9249  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
043A18 21 00 00 04 9250  			LD	HL, ACCS		; HL: Filename
043A1C CD 75 3A 04 9251  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
043A20 CD 89 3A 04 9252  			CALL	EXT_HANDLER		; Get the default handler
043A24 D1          9253  			POP	DE			; Restore the save address
043A25 C1          9254  			POP	BC			; Restore the size
043A26 B7          9255  			OR	A			; Is the extension .BBC
043A27 28 44       9256  			JR	Z, OSSAVE_BBC		; Yes, so use that
043A29             9257  ;
043A29             9258  ; Save the file out as a text file
043A29             9259  ;
043A29 3A 45 03 04 9260  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
043A2D F5          9261  			PUSH	AF
043A2E AF          9262  			XOR	A
043A2F 3C          9263  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
043A30 32 45 03 04 9264  			LD	(OSWRCHCH), A
043A34 CD FD 3A 04 9265  			CALL	OSOPEN			; Open the file
043A38 32 46 03 04 9266  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
043A3C DD 21 40 03 9267  			LD	IX, LISTON		; Required for LISTIT
       04          
043A41 2A 14 03 04 9268  			LD	HL, (PAGE_)		; Get start of program area
043A45 D9          9269  			EXX
043A46 01 00 00 00 9270  			LD	BC, 0			; Set the initial indent counters
043A4A D9          9271  			EXX
043A4B 7E          9272  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
043A4C B7          9273  			OR	A
043A4D 28 0F       9274  			JR	Z, OSSAVE_TXT2
043A4F 23          9275  			INC	HL			; Skip the length byte
043A50 11 00 00 00 9276  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
043A54 5E          9277  			LD	E, (HL)			; Get the line number
043A55 23          9278  			INC	HL
043A56 56          9279  			LD	D, (HL)
043A57 23          9280  			INC	HL
043A58 CD 8F 44 04 9281  			CALL	LISTIT			; List the line
043A5C 18 ED       9282  			JR	OSSAVE_TXT1
043A5E 3A 46 03 04 9283  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
043A62 5F          9284  			LD	E, A
043A63 CD 0C 3B 04 9285  			CALL	OSSHUT			; Close it
043A67 F1          9286  			POP	AF			; Restore the channel
043A68 32 45 03 04 9287  			LD	(OSWRCHCH), A
043A6C C9          9288  			RET
043A6D             9289  ;
043A6D             9290  ; Save the file out as a tokenised binary blob
043A6D             9291  ;
043A6D             9292  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
043A6D 3E 02       0001M 			LD	A, function
043A6F 5B CF       0002M 			RST.L	08h
043A71 B7          9293  			OR	A			; If there is no error (A=0)
043A72 C8          9294  			RET	Z			; Just return
043A73 18 83       9295  			JR	OSERROR			; Trip an error
043A75             9296  
043A75             9297  ; Check if an extension is specified in the filename
043A75             9298  ; Add a default if not specified
043A75             9299  ; HL: Filename (CSTR format)
043A75             9300  ;
043A75 E5          9301  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
043A76 0E 2E       9302  			LD	C, '.'			; Search for dot (marks start of extension)
043A78 CD 09 36 04 9303  			CALL	CSTR_FINDCH
043A7C B7          9304  			OR	A			; Check for end of string marker
043A7D 20 08       9305  			JR	NZ, @F			; No, so skip as we have an extension at this point
043A7F 11 B9 3A 04 9306  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
043A83 CD 20 36 04 9307  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
043A87 E1          9308  @@:			POP	HL			; Restore the filename pointer
043A88 C9          9309  			RET
043A89             9310  
043A89             9311  ; Check if an extension is valid and, if so, provide a pointer to a handler
043A89             9312  ; HL: Filename (CSTR format)
043A89             9313  ; Returns:
043A89             9314  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
043A89             9315  ;
043A89 E5          9316  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
043A8A 0E 2E       9317  			LD	C, '.'			; Find the '.'
043A8C CD 09 36 04 9318  			CALL	CSTR_FINDCH
043A90 11 B9 3A 04 9319  			LD	DE, EXT_LOOKUP		; The lookup table
043A94             9320  ;
043A94 E5          9321  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
043A95 CD 11 36 04 9322  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
043A99 E1          9323  			POP	HL			; Restore the pointer to the extension
043A9A 28 19       9324  			JR	Z, EXT_HANDLER_2	; We have a match!
043A9C             9325  ;
043A9C 1A          9326  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
043A9D 13          9327  			INC	DE
043A9E B7          9328  			OR	A
043A9F 20 FB       9329  			JR	NZ, @B
043AA1 13          9330  			INC	DE			; Skip the file extension # byte
043AA2             9331  ;
043AA2 1A          9332  			LD	A, (DE)			; Are we at the end of the table?
043AA3 B7          9333  			OR	A
043AA4 20 EE       9334  			JR	NZ, EXT_HANDLER_1	; No, so loop
043AA6             9335  ;
043AA6 3E CC       9336  			LD      A,204			; Throw a "Bad name" error
043AA8 CD 74 43 04 9337          		CALL    EXTERR
043AAC 42 61 64 20 9338          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
043AB5             9339  ;
043AB5 13          9340  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
043AB6 1A          9341  			LD	A, (DE)
043AB7 E1          9342  			POP	HL			; Restore the filename pointer
043AB8 C9          9343  			RET
043AB9             9344  ;
043AB9             9345  
043AB9             9346  
043AB9             9347  ; Extension lookup table
043AB9             9348  ; CSTR, TYPE
043AB9             9349  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
043AB9             9350  ; 	- 1: Human readable plain text
043AB9             9351  ;
043AB9 2E 42 42 43 9352  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
043ABF 2E 54 58 54 9353  			DB	".TXT", 0, 1
       00 01       
043AC5 2E 41 53 43 9354  			DB	".ASC", 0, 1
       00 01       
043ACB 2E 42 41 53 9355  			DB	".BAS", 0, 1
       00 01       
043AD1 00          9356  			DB	0			; End of table
043AD2             9357  
043AD2             9358  ;OSCALL - Intercept page &FF calls and provide an alternative address
043AD2             9359  ;
043AD2             9360  ;&FFF7:	OSCLI	Execute *command.
043AD2             9361  ;&FFF4:	OSBYTE	Various byte-wide functions.
043AD2             9362  ;&FFF1:	OSWORD	Various control block functions.
043AD2             9363  ;&FFEE:	OSWRCH	Write character to output stream.
043AD2             9364  ;&FFE7:	OSNEWL	Write NewLine to output stream.
043AD2             9365  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
043AD2             9366  ;&FFE0:	OSRDCH	Wait for character from input stream.
043AD2             9367  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
043AD2             9368  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
043AD2             9369  ;&FFD7:	OSBGET	Read a byte from an a channel.
043AD2             9370  ;&FFD4:	OSBPUT	Write a byte to a channel.
043AD2             9371  ;&FFD1:	OSGBPB	Read and write blocks of data.
043AD2             9372  ;&FFCE:	OSFIND	Open or close a file.
043AD2             9373  ;
043AD2 21 E8 3A 04 9374  OSCALL:			LD	HL, OSCALL_TABLE
043AD6 7E          9375  OSCALL_1:		LD	A, (HL)
043AD7 23          9376  			INC	HL
043AD8 FE FF       9377  			CP	FFh
043ADA C8          9378  			RET	Z
043ADB FD BD       9379  			CP	A, IYL
043ADD 28 06       9380  			JR	Z, OSCALL_2
043ADF D0          9381  			RET	NC
043AE0 23          9382  			INC	HL
043AE1 23          9383  			INC	HL
043AE2 23          9384  			INC	HL
043AE3 18 F1       9385  			JR	OSCALL_1
043AE5 ED 31       9386  OSCALL_2:		LD	IY,(HL)
043AE7 C9          9387  			RET
043AE8 D4          9388  OSCALL_TABLE:		DB 	D4h
043AE9 1C 3B 04    9389  			DW24 	OSBPUT
043AEC D7          9390  			DB 	D7h
043AED 14 3B 04    9391  			DW24 	OSBGET
043AF0 EE          9392  			DB 	EEh
043AF1 D0 36 04    9393  			DW24 	OSWRCH
043AF4 F4          9394  			DB	F4h
043AF5 9A 38 04    9395  			DW24 	OSBYTE
043AF8 F7          9396  			DB	F7h
043AF9 60 37 04    9397  			DW24	OSCLI
043AFC FF          9398  			DB	FFh
043AFD             9399  
043AFD             9400  ; OSOPEN
043AFD             9401  ; HL: Pointer to path
043AFD             9402  ;  F: C Z
043AFD             9403  ;     x x OPENIN
043AFD             9404  ; 	  OPENOUT
043AFD             9405  ;     x	  OPENUP
043AFD             9406  ; Returns:
043AFD             9407  ;  A: Filehandle, 0 if cannot open
043AFD             9408  ;
043AFD 0E 01       9409  OSOPEN:			LD	C, fa_read
043AFF 28 06       9410  			JR	Z, @F
043B01 0E 32       9411  			LD	C, fa_write | fa_open_append
043B03 38 02       9412  			JR	C, @F
043B05 0E 0A       9413  			LD	C, fa_write | fa_create_always
043B07             9414  @@:			MOSCALL	mos_fopen
043B07 3E 0A       0001M 			LD	A, function
043B09 5B CF       0002M 			RST.L	08h
043B0B C9          9415  			RET
043B0C             9416  
043B0C             9417  ;OSSHUT - Close disk file(s).
043B0C             9418  ; E = file channel
043B0C             9419  ;  If E=0 all files are closed (except SPOOL)
043B0C             9420  ; Destroys: A,B,C,D,E,H,L,F
043B0C             9421  ;
043B0C C5          9422  OSSHUT:			PUSH	BC
043B0D 4B          9423  			LD	C, E
043B0E             9424  			MOSCALL	mos_fclose
043B0E 3E 0B       0001M 			LD	A, function
043B10 5B CF       0002M 			RST.L	08h
043B12 C1          9425  			POP	BC
043B13 C9          9426  			RET
043B14             9427  
043B14             9428  ; OSBGET - Read a byte from a random disk file.
043B14             9429  ;  E = file channel
043B14             9430  ; Returns
043B14             9431  ;  A = byte read
043B14             9432  ;  Carry set if LAST BYTE of file
043B14             9433  ; Destroys: A,B,C,F
043B14             9434  ;
043B14 C5          9435  OSBGET:			PUSH	BC
043B15 4B          9436  			LD	C, E
043B16             9437  			MOSCALL	mos_fgetc
043B16 3E 0C       0001M 			LD	A, function
043B18 5B CF       0002M 			RST.L	08h
043B1A C1          9438  			POP	BC
043B1B C9          9439  			RET
043B1C             9440  
043B1C             9441  ; OSBPUT - Write a byte to a random disk file.
043B1C             9442  ;  E = file channel
043B1C             9443  ;  A = byte to write
043B1C             9444  ; Destroys: A,B,C,F
043B1C             9445  ;
043B1C C5          9446  OSBPUT:			PUSH	BC
043B1D 4B          9447  			LD	C, E
043B1E 47          9448  			LD	B, A
043B1F             9449  			MOSCALL	mos_fputc
043B1F 3E 0D       0001M 			LD	A, function
043B21 5B CF       0002M 			RST.L	08h
043B23 C1          9450  			POP	BC
043B24 C9          9451  			RET
043B25             9452  
043B25             9453  ; OSSTAT - Read file status
043B25             9454  ;  E = file channel
043B25             9455  ; Returns
043B25             9456  ;  F: Z flag set - EOF
043B25             9457  ;  A: If Z then A = 0
043B25             9458  ; Destroys: A,D,E,H,L,F
043B25             9459  ;
043B25 C5          9460  OSSTAT:			PUSH	BC
043B26 4B          9461  			LD	C, E
043B27             9462  			MOSCALL	mos_feof
043B27 3E 0E       0001M 			LD	A, function
043B29 5B CF       0002M 			RST.L	08h
043B2B C1          9463  			POP	BC
043B2C FE 01       9464  			CP	1
043B2E C9          9465  			RET
043B2F             9466  
043B2F             9467  ; GETPTR - Return file pointer.
043B2F             9468  ;    E = file channel
043B2F             9469  ; Returns:
043B2F             9470  ; DEHL = pointer (0-&7FFFFF)
043B2F             9471  ; Destroys: A,B,C,D,E,H,L,F
043B2F             9472  ;
043B2F FD E5       9473  GETPTR:			PUSH		IY
043B31             9474  			; LD		C, E
043B31             9475  			; MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
043B31             9476  			; PUSH		HL
043B31             9477  			; POP		IY		; IYU: Pointer to FIL structure
043B31             9478  			; LD		L, (IY + FIL.fptr + 0)
043B31             9479  			; LD		H, (IY + FIL.fptr + 1)
043B31             9480  			; LD		E, (IY + FIL.fptr + 2)
043B31             9481  			; LD		D, (IY + FIL.fptr + 3)
043B31 FD E1       9482  			POP		IY
043B33 C9          9483  			RET
043B34             9484  
043B34             9485  ; PUTPTR - Update file pointer.
043B34             9486  ;    A = file channel
043B34             9487  ; DEHL = new pointer (0-&7FFFFF)
043B34             9488  ; Destroys: A,B,C,D,E,H,L,F
043B34             9489  ;
043B34 FD E5       9490  PUTPTR:			PUSH		IY
043B36 4F          9491  			LD		C, A  		; C: Filehandle
043B37 E5          9492  			PUSH		HL
043B38 21 02 00 00 9493  			LD		HL, 2
043B3C 39          9494  			ADD		HL, SP
043B3D 73          9495  			LD		(HL), E 	; 3rd byte of DWORD set to E
043B3E E1          9496  			POP		HL
043B3F 5A          9497  			LD		E, D  		; 4th byte passed as E
043B40             9498  			MOSCALL		mos_flseek
043B40 3E 1C       0001M 			LD	A, function
043B42 5B CF       0002M 			RST.L	08h
043B44 FD E1       9499  			POP		IY
043B46 C9          9500  			RET
043B47             9501  
043B47             9502  ; GETEXT - Find file size.
043B47             9503  ;    E = file channel
043B47             9504  ; Returns:
043B47             9505  ; DEHL = file size (0-&800000)
043B47             9506  ; Destroys: A,B,C,D,E,H,L,F
043B47             9507  ;
043B47 FD E5       9508  GETEXT:			PUSH		IY
043B49             9509  			; LD		C, E
043B49             9510  			; MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
043B49             9511  			; PUSH		HL
043B49             9512  			; POP		IY		; IYU: Pointer to FIL structure
043B49             9513  			; LD		L, (IY + FIL.obj.objsize + 0)
043B49             9514  			; LD		H, (IY + FIL.obj.objsize + 1)
043B49             9515  			; LD		E, (IY + FIL.obj.objsize + 2)
043B49             9516  			; LD		D, (IY + FIL.obj.objsize + 3)
043B49 FD E1       9517  			POP		IY
043B4B C9          9518  			RET
043B4C             9519  
043B4C             9520  ; GETIMS - Get time from RTC
043B4C             9521  ;
043B4C FD E5       9522  GETIMS:			PUSH	IY
043B4E 21 00 00 04 9523  			LD	HL, ACCS 		; Where to store the time string
043B52             9524  			MOSCALL	mos_getrtc
043B52 3E 12       0001M 			LD	A, function
043B54 5B CF       0002M 			RST.L	08h
043B56 11 00 00 04 9525  			LD	DE, ACCS		; DE: pointer to start of string accumulator
043B5A 5F          9526  			LD	E, A 			;  E: now points to the end of the string
043B5B FD E1       9527  			POP	IY
043B5D C9          9528  			RET
043B5E             9529  
043B5E             9530  ; Get two word values from EXPR in DE, HL
043B5E             9531  ; IY: Pointer to expression string
043B5E             9532  ; Returns:
043B5E             9533  ; DE: P1
043B5E             9534  ; HL: P2
043B5E             9535  ;
043B5E CD 27 0C 04 9536  EXPR_W2:		CALL	EXPRI			; Get first parameter
043B62 D9          9537  			EXX
043B63 E5          9538  			PUSH	HL
043B64 CD 42 13 04 9539  			CALL	COMMA
043B68 CD 27 0C 04 9540  			CALL	EXPRI			; Get second parameter
043B6C D9          9541  			EXX
043B6D D1          9542  			POP	DE
043B6E C9          9543  			RET
043B6F             9544  
043B6F             9545  ; Stuff not implemented yet
043B6F             9546  ;
043B6F C9          9547  RESET:			RET
043B70             9548  
043B70             9549  ; ========================================
043B70             9550  ; FROM sorry.asm
043B70             9551  ; ----------------------------------------
043B70             9552  
043B70             9553  ;
043B70             9554  ; Title:	BBC Basic Interpreter - Z80 version
043B70             9555  ;		Catch-all for unimplemented functionality
043B70             9556  ; Author:	Dean Belfield
043B70             9557  ; Created:	12/05/2023
043B70             9558  ; Last Updated:	12/05/2023
043B70             9559  ;
043B70             9560  ; Modinfo:
043B70             9561  
043B70             9562  			; .ASSUME	ADL = 1
043B70             9563  
043B70             9564  			; SEGMENT CODE
043B70             9565  
043B70             9566  ; 			XDEF	ENVEL
043B70             9567  ; 			XDEF	ADVAL
043B70             9568  ; 			XDEF	PUTIMS
043B70             9569  
043B70             9570  ; 			XREF	EXTERR
043B70             9571  
043B70             9572  ENVEL:
043B70             9573  ADVAL:
043B70             9574  PUTIMS:
043B70 AF          9575  			XOR     A
043B71 CD 74 43 04 9576  			CALL    EXTERR
043B75 53 6F 72 72 9577  			DEFB    "Sorry"
       79          
043B7A 00          9578  			DEFB    0
043B7B             9579  
043B7B             9580  ; ========================================
043B7B             9581  ; FROM main.asm
043B7B             9582  ; ----------------------------------------
043B7B             9583  
043B7B             9584  ;
043B7B             9585  ; Title:	BBC Basic Interpreter - Z80 version
043B7B             9586  ;		Command, Error and Lexical Analysis Module - "MAIN"
043B7B             9587  ; Author:	(C) Copyright  R.T.Russell  1984
043B7B             9588  ; Modified By:	Dean Belfield
043B7B             9589  ; Created:	12/05/2023
043B7B             9590  ; Last Updated:	26/11/2023
043B7B             9591  ;
043B7B             9592  ; Modinfo:
043B7B             9593  ; 07/05/1984:	Version 2.3
043B7B             9594  ; 01/03/1987:	Version 3.0
043B7B             9595  ; 03/05/2022:	Modified by Dean Belfield
043B7B             9596  ; 06/06/2023:	Modified to run in ADL mode
043B7B             9597  ; 26/06/2023:	Fixed binary and unary indirection
043B7B             9598  ; 17/08/2023:	Added binary constants
043B7B             9599  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
043B7B             9600  ; 26/11/2023:	Fixed bug in AUTOLOAD
043B7B             9601  
043B7B             9602  			.ASSUME	ADL = 1
043B7B             9603  
043B7B             9604  			; include "mos_api.inc"
043B7B             9605  			; include "macros.inc"
043B7B             9606  			; include "ram.asm"
043B7B             9607  			; INCLUDE "equs.inc"
043B7B             9608  			; include "init.asm"
043B7B             9609  			; include "agon_graphics.asm"
043B7B             9610  			; include "agon_sound.asm"
043B7B             9611  			; include "eval.asm"
043B7B             9612  			; include "exec.asm"
043B7B             9613  			; include "fpp.asm"
043B7B             9614  			; include "gpio.asm"
043B7B             9615  			; include "interrupts.asm"
043B7B             9616  			; include "patch.asm"
043B7B             9617  			; include "sorry.asm"
043B7B             9618  
043B7B             9619  			; SEGMENT CODE
043B7B             9620  
043B7B             9621  ; 			XDEF	_main
043B7B             9622  
043B7B             9623  ; 			XDEF	COLD
043B7B             9624  ; 			XDEF	WARM
043B7B             9625  ; 			XDEF	CLOOP
043B7B             9626  ; 			XDEF	DELETE
043B7B             9627  ; 			XDEF	LIST_
043B7B             9628  ; 			XDEF	RENUM
043B7B             9629  ; 			XDEF	AUTO
043B7B             9630  ; 			XDEF	NEW
043B7B             9631  ; 			XDEF	OLD
043B7B             9632  ; 			XDEF	LOAD
043B7B             9633  ; 			XDEF	SAVE
043B7B             9634  ; 			XDEF	ERROR_
043B7B             9635  ; 			XDEF	EXTERR
043B7B             9636  ; 			XDEF	LOAD0
043B7B             9637  ; 			XDEF	CLEAR
043B7B             9638  ; 			XDEF	CRLF
043B7B             9639  ; 			XDEF	OUTCHR
043B7B             9640  ; 			XDEF	OUT_
043B7B             9641  ; 			XDEF	FINDL
043B7B             9642  ; 			XDEF	SETLIN
043B7B             9643  ; 			XDEF	PBCDL
043B7B             9644  ; 			XDEF	SAYLN
043B7B             9645  ; 			XDEF	PUTVAR
043B7B             9646  ; 			XDEF	GETVAR
043B7B             9647  ; 			XDEF	GETDEF
043B7B             9648  ; 			XDEF	CREATE
043B7B             9649  ; 			XDEF	RANGE
043B7B             9650  ; 			XDEF	LEXAN2
043B7B             9651  ; 			XDEF	REPORT
043B7B             9652  ; 			XDEF	TELL
043B7B             9653  ; 			XDEF	SPACE_
043B7B             9654  ; 			XDEF	KEYWDS
043B7B             9655  ; 			XDEF	KEYWDL
043B7B             9656  ; 			XDEF	ONEDIT
043B7B             9657  ; 			XDEF	ONEDIT1
043B7B             9658  ; 			XDEF	LISTIT
043B7B             9659  ; 			XDEF	CLEAN
043B7B             9660  
043B7B             9661  ; 			XREF	LISTON
043B7B             9662  ; 			XREF	ERRTXT
043B7B             9663  ; 			XREF	OSINIT
043B7B             9664  ; 			XREF	HIMEM
043B7B             9665  ; 			XREF	PAGE_
043B7B             9666  ; 			XREF	CHAIN0
043B7B             9667  ; 			XREF	PROMPT
043B7B             9668  ; 			XREF	ERRTRP
043B7B             9669  ; 			XREF	ERRLIN
043B7B             9670  ; 			XREF	AUTONO
043B7B             9671  ; 			XREF	LINENO
043B7B             9672  ; 			XREF	INCREM
043B7B             9673  ; 			XREF	OSLINE
043B7B             9674  ; 			XREF	COUNT
043B7B             9675  ; 			XREF	NXT
043B7B             9676  ; 			XREF	BUFFER
043B7B             9677  ; 			XREF	XEQ
043B7B             9678  ; 			XREF	TOP
043B7B             9679  ; 			XREF	EXPRI
043B7B             9680  ; 			XREF	SEARCH
043B7B             9681  ; 			XREF	LTRAP
043B7B             9682  ; 			XREF	LOMEM
043B7B             9683  ; 			XREF	DECODE
043B7B             9684  ; 			XREF	EXPRS
043B7B             9685  ; 			XREF	OSSAVE
043B7B             9686  ; 			XREF	ERR
043B7B             9687  ; 			XREF	ERL
043B7B             9688  ; 			XREF	TRACEN
043B7B             9689  ; 			XREF	RESET
043B7B             9690  ; 			XREF	OSSHUT
043B7B             9691  ; 			XREF	OSLOAD
043B7B             9692  ; 			XREF	FREE
043B7B             9693  ; 			XREF	DYNVAR
043B7B             9694  ; 			XREF	FILL
043B7B             9695  ; 			XREF	OSWRCH
043B7B             9696  ; 			XREF	WIDTH
043B7B             9697  ; 			XREF	COMMA
043B7B             9698  ; 			XREF	MUL16
043B7B             9699  ; 			XREF	BRAKET
043B7B             9700  ; 			XREF	X4OR5
043B7B             9701  ; 			XREF	LOADN
043B7B             9702  ; 			XREF	SFIX
043B7B             9703  ; 			XREF	ITEMI
043B7B             9704  ; 			XREF	FNPTR
043B7B             9705  ; 			XREF	PROPTR
043B7B             9706  ; 			XREF	CHECK
043B7B             9707  ; 			XREF	TERMQ
043B7B             9708  ; 			XREF	OSWRCHCH
043B7B             9709  ; 			XREF	NEWIT
043B7B             9710  ; 			XREF	BAD
043B7B             9711  ; 			XREF	RAM_START
043B7B             9712  ; 			XREF	RAM_END
043B7B             9713  ; 			XREF	R0
043B7B             9714  ; 			XREF	STAR_VERSION
043B7B             9715  
043B7B             9716  ; 			XREF	_end			; In init.asm
043B7B             9717  ;
043B7B             9718  ; A handful of common token IDs
043B7B             9719  ;
043B7B             9720  TERROR_main:			EQU     85H
043B7B             9721  LINE__main:			EQU     86H
043B7B             9722  ELSE__main:			EQU     8BH
043B7B             9723  THEN_main:			EQU     8CH
043B7B             9724  LINO_main:			EQU     8DH
043B7B             9725  FN_main:			EQU     A4H
043B7B             9726  TO_main:			EQU     B8H
043B7B             9727  REN:			EQU     CCH
043B7B             9728  DATA__main:			EQU     DCH
043B7B             9729  DIM_main:			EQU     DEH
043B7B             9730  FOR_main:			EQU     E3H
043B7B             9731  GOSUB_main:			EQU     E4H
043B7B             9732  GOTO_main:			EQU     E5H
043B7B             9733  TIF:			EQU     E7H
043B7B             9734  LOCAL__main:			EQU     EAH
043B7B             9735  NEXT_main:			EQU     EDH
043B7B             9736  ON__main:			EQU     EEH
043B7B             9737  PROC_main:			EQU     F2H
043B7B             9738  REM_main:			EQU     F4H
043B7B             9739  REPEAT_main:			EQU     F5H
043B7B             9740  RESTOR_main:			EQU     F7H
043B7B             9741  TRACE_main:			EQU     FCH
043B7B             9742  UNTIL_main:			EQU     FDH
043B7B             9743  ;
043B7B             9744  ; This defines the block of tokens that are pseudo-variables.
043B7B             9745  ; There are two versions of each token, a GET and a SET
043B7B             9746  
043B7B             9747  ; Name  : GET : SET
043B7B             9748  ; ------:-----:----
043B7B             9749  ; PTR   : 8Fh : CFh
043B7B             9750  ; PAGE  : 90h : D0h
043B7B             9751  ; TIME  : 91h : D1h
043B7B             9752  ; LOMEM : 92h : D2h
043B7B             9753  ; HIMEM : 93h : D3h
043B7B             9754  ;
043B7B             9755  ; Examples:
043B7B             9756  ;   LET A% = PAGE : REM This is the GET version
043B7B             9757  ;   PAGE = 40000  : REM This is the SET version
043B7B             9758  ;
043B7B             9759  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
043B7B             9760  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
043B7B             9761  OFFSET_main:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
043B7B             9762  
043B7B             9763  ; The main routine
043B7B             9764  ; IXU: argv - pointer to array of parameters
043B7B             9765  ;   C: argc - number of parameters
043B7B             9766  ; Returns:
043B7B             9767  ;  HL: Error code, or 0 if OK
043B7B             9768  ;
043B7B 21 00 00 04 9769  _main:			LD	HL, ACCS		; Clear the ACCS
043B7F 36 00       9770  			LD	(HL), 0
043B81 79          9771  			LD	A, C
043B82 FE 02       9772  			CP	2
043B84 28 2D       9773  			JR	Z, AUTOLOAD		; 2 parameters = autoload
043B86 38 3F       9774  			JR	C, COLD			; 1 parameter = normal start
043B88 CD 19 38 04 9775  			CALL	STAR_VERSION
043B8C CD 8D 49 04 9776  			CALL	TELL
043B90 55 73 61 67 9777  			DB	"Usage:\n\r"
       65 3A 0A 0D 
043B98 52 55 4E 20 9778  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
043BAB 21 00 00 00 9779  			LD	HL, 0			; The error code
043BAF C3 68 04 04 9780  			JP	_end
043BB3             9781  ;
043BB3 DD 27 03    9782  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
043BB6 11 00 00 04 9783  			LD	DE, ACCS		;  DE: Destination address
043BBA 7E          9784  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
043BBB 12          9785  			LD	(DE), A			;
043BBC 23          9786  			INC	HL			; Increase the source pointer
043BBD 1C          9787  			INC	E			; We only need to increase E as ACCS is on a page boundary
043BBE 28 03       9788  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
043BC0 B7          9789  			OR	A
043BC1 20 F7       9790  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
043BC3 1D          9791  AUTOLOAD_2:		DEC	E
043BC4 3E 0D       9792  			LD	A, CR
043BC6 12          9793  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
043BC7             9794  ;
043BC7 E1          9795  COLD:			POP	HL			; Pop the return address to init off SPS
043BC8 E5          9796  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
043BC9 21 00 02 04 9797  			LD	HL, STAVAR		; Cold start
043BCD F9          9798  			LD	SP, HL
043BCE 36 0A       9799  			LD	(HL), 10
043BD0 23          9800  			INC	HL
043BD1 36 09       9801  			LD	(HL),9
043BD3 CD 51 37 04 9802  			CALL    OSINIT			; Call the machine specific OS initialisation routines
043BD7 ED 53 20 03 9803  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       04          
043BDC 22 14 03 04 9804  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
043BE0 3E B7       9805  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
043BE2 32 40 03 04 9806  			LD      (LISTON),A
043BE6 21 21 3C 04 9807  			LD      HL,NOTICE
043BEA 22 2F 03 04 9808  			LD      (ERRTXT),HL
043BEE CD 69 44 04 9809  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
043BF2 3A 00 00 04 9810  			LD	A,(ACCS)		; Check if there is a filename in ACCS
043BF6 B7          9811  			OR	A
043BF7 C2 73 14 04 9812  			JP	NZ,CHAIN0		; Yes, so load and run
043BFB CD 19 38 04 9813  			CALL	STAR_VERSION		;
043BFF CD 8D 49 04 9814  			CALL    TELL			; Output the welcome message
043C03 42 42 43 20 9815  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
043C21 28 43 29 20 9816  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
043C41 0A 0D 00    9817  			DB	"\n\r", 0
043C44             9818  ;
043C44 F6          9819  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
043C45             9820  ;
043C45             9821  ; This is the main entry point for BASIC
043C45             9822  ;
043C45 37          9823  CLOOP:			SCF				; See above - not sure why this is here!
043C46 ED 7B 20 03 9824  			LD      SP,(HIMEM)
       04          
043C4B CD CA 36 04 9825  			CALL    PROMPT          	; Prompt user
043C4F 21 40 03 04 9826  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
043C53 7E          9827  			LD      A,(HL)			; Fetch the value
043C54 E6 0F       9828  			AND     0FH             	; Bottom nibble: LISTO
043C56 F6 B0       9829  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
043C58 77          9830  			LD      (HL),A			; Store back in
043C59 ED 62       9831  			SBC     HL,HL           	; HL: 0
043C5B 22 2C 03 04 9832  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
043C5F 22 35 03 04 9833  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
043C63             9834  ;
043C63 2A 29 03 04 9835  			LD      HL,(AUTONO)		; Get the auto line number
043C67 22 23 03 04 9836  			LD      (LINENO),HL		; Store in line number
043C6B 7C          9837  			LD      A,H			; If the auto line number is zero then
043C6C B5          9838  			OR      L
043C6D 28 1E       9839  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
043C6F             9840  ;
043C6F             9841  ; This section handles auto line numbering
043C6F             9842  ;
043C6F E5          9843  			PUSH    HL			; Stack the line number
043C70 CD F8 45 04 9844  			CALL    PBCD           	 	; Output the line number
043C74 E1          9845  			POP     HL			; Pop the line number back off the stack
043C75             9846  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
043C75             9847  ;			LD      B,0			; So clear B
043C75 01 00 00 00 9848  			LD	BC, 0			; Load BC with Increment
043C79 3A 41 03 04 9849  			LD	A,(INCREM)
043C7D 4F          9850  			LD	C, A
043C7E 09          9851  			ADD     HL,BC			; Add the increment to the line number
043C7F DA 22 48 04 9852  			JP      C,TOOBIG_main		; And error if we wrap
043C83 22 29 03 04 9853  			LD      (AUTONO),HL		; Store the new auto line number
043C87 3E 20       9854  			LD      A,' '			; Print a space
043C89 CD 4C 45 04 9855  			CALL    OUTCHR
043C8D             9856  ;
043C8D             9857  ; This section invokes the line editor
043C8D             9858  ;
043C8D 21 00 00 04 9859  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
043C91 CD 2F 36 04 9860  			CALL    OSLINE          	; Call the line editor in MOS
043C95 CD A1 3C 04 9861  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
043C99 DC 3C 44 04 9862  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
043C9D C3 45 3C 04 9863  			JP      CLOOP			; Jump back to immediate mode
043CA1             9864  ;
043CA1             9865  ; This bit enters the line into memory
043CA1             9866  ; Also called from OSLOAD_TXT
043CA1             9867  ; Returns:
043CA1             9868  ; F: C if a new line has been entered (CLEAN will need to be called)
043CA1             9869  ;
043CA1 AF          9870  ONEDIT1:		XOR     A			; Entry point after *EDIT
043CA2 32 3D 03 04 9871  			LD      (COUNT),A
043CA6 FD 21 00 00 9872  			LD      IY,ACCS
       04          
043CAB CD F6 47 04 9873  			CALL    LINNUM			; HL: The line number from the input buffer
043CAF CD 90 13 04 9874  			CALL    NXT			; Skip spaces
043CB3 7C          9875  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
043CB4 B5          9876  			OR      L
043CB5 28 04       9877  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
043CB7 22 23 03 04 9878  			LD      (LINENO),HL		; Otherwise store it
043CBB             9879  ;
043CBB             9880  ; This bit does the lexical analysis and tokenisation
043CBB             9881  ;
043CBB 0E 01       9882  LNZERO:			LD	C,1			; Left mode
043CBD 11 00 01 04 9883  			LD      DE,BUFFER		; Buffer for tokenised BASIC
043CC1 CD 9C 48 04 9884  			CALL    LEXAN2          	; Lexical analysis on the user input
043CC5 12          9885  			LD      (DE),A          	; Terminator
043CC6 AF          9886  			XOR     A
043CC7             9887  ;			LD      B,A
043CC7             9888  ;			LD      C,E             	; BC: Line length
043CC7 01 00 00 00 9889  			LD	BC,0
043CCB 4B          9890  			LD	C,E			; BC: Line length
043CCC 13          9891  			INC     DE
043CCD 12          9892  			LD      (DE),A          	; Zero next
043CCE 2A 23 03 04 9893  			LD      HL,(LINENO)		; Get the line number
043CD2 7C          9894  			LD      A,H			; Is it zero, i.e. a command with no line number?
043CD3 B5          9895  			OR      L
043CD4 FD 21 00 01 9896  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       04          
043CD9 CA B6 14 04 9897  			JP      Z,XEQ           	; Execute it
043CDD             9898  ;
043CDD             9899  ; This section stores the BASIC line in memory
043CDD             9900  ;
043CDD C5          9901  			PUSH    BC
043CDE E5          9902  			PUSH    HL
043CDF CD 48 44 04 9903  			CALL    SETTOP          	; Set TOP sysvar
043CE3 E1          9904  			POP     HL
043CE4 CD 8C 45 04 9905  			CALL    FINDL			; Find the address of the line
043CE8 CC FF 43 04 9906  			CALL    Z,DEL			; Delete the existing line if found
043CEC C1          9907  			POP     BC
043CED 79          9908  			LD      A,C			; Check for the line length being zero, i.e.
043CEE B7          9909  			OR      A			; the user has just entered a line number in the command line
043CEF C8          9910  			RET	Z 	         	; If so, then don't do anything else
043CF0 C6 04       9911  			ADD     A,4
043CF2 4F          9912  			LD      C,A             	; Length inclusive
043CF3 D5          9913  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
043CF4 C5          9914  			PUSH    BC              	; BC: Line length
043CF5 EB          9915  			EX      DE,HL			; DE: Address of the line in memory
043CF6 2A 17 03 04 9916  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
043CFA E5          9917  			PUSH    HL			; Stack TOP (current TOP value)
043CFB 09          9918  			ADD     HL,BC			; Add the line length to HL, the new TOP value
043CFC E5          9919  			PUSH    HL			; Stack HL (new TOP value)
043CFD 24          9920  			INC     H			; Add 256 to HL
043CFE AF          9921  			XOR     A
043CFF ED 72       9922  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
043D01 E1          9923  			POP     HL			; Pop HL (new TOP value)
043D02 D2 5D 43 04 9924  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
043D06 22 17 03 04 9925  			LD      (TOP),HL		; Store new value of TOP
043D0A E3          9926  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
043D0B E5          9927  			PUSH    HL			; PUSH current TOP value
043D0C 23          9928  			INC     HL
043D0D B7          9929  			OR      A
043D0E ED 52       9930  			SBC     HL,DE			; DE: Address of the line in memory
043D10 44          9931  			LD      B,H             	; BC: Amount to move
043D11 4D          9932  			LD      C,L
043D12 E1          9933  			POP     HL			; HL: Destination (current TOP value)
043D13 D1          9934  			POP     DE			; DE: Source (new TOP value)
043D14 28 02       9935  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
043D16 ED B8       9936  			LDDR                    	; Otherwise, make space for the new line in the program
043D18 C1          9937  ATEND:			POP     BC              	; BC: Line length
043D19 D1          9938  			POP     DE              	; DE: Line number
043D1A 23          9939  			INC     HL			; HL: Destination address
043D1B 71          9940  			LD      (HL),C          	; Store length
043D1C 23          9941  			INC     HL
043D1D 73          9942  			LD      (HL),E          	; Store line number
043D1E 23          9943  			INC     HL
043D1F 72          9944  			LD      (HL),D
043D20 23          9945  			INC     HL
043D21 11 00 01 04 9946  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
043D25 EB          9947  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
043D26 0D          9948  			DEC     C			; Subtract 3 from the number of bytes to copy to
043D27 0D          9949  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
043D28 0D          9950  			DEC     C
043D29 ED B0       9951  			LDIR                    	; Add the line to the BASIC program
043D2B 37          9952  			SCF				; To flag we need to call CLEAN
043D2C C9          9953  			RET
043D2D             9954  ;
043D2D             9955  ; List of tokens and keywords. If a keyword is followed by 0 then
043D2D             9956  ; it will only match with the keyword followed immediately by
043D2D             9957  ; a delimiter
043D2D             9958  ;
043D2D 80 41 4E 44 9959  KEYWDS:			DB    80H, "AND"
043D31 94 41 42 53 9960  			DB    94H, "ABS"
043D35 95 41 43 53 9961  			DB    95H, "ACS"
043D39 96 41 44 56 9962  			DB    96H, "ADVAL"
       41 4C       
043D3F 97 41 53 43 9963  			DB    97H, "ASC"
043D43 98 41 53 4E 9964  			DB    98H, "ASN"
043D47 99 41 54 4E 9965  			DB    99H, "ATN"
043D4B C6 41 55 54 9966  			DB    C6H, "AUTO"
       4F          
043D50 9A 42 47 45 9967  			DB    9AH, "BGET", 0
       54 00       
043D56 D5 42 50 55 9968  			DB    D5H, "BPUT", 0
       54 00       
043D5C FB 43 4F 4C 9969  			DB    FBH, "COLOUR"
       4F 55 52    
043D63 FB 43 4F 4C 9970  			DB    FBH, "COLOR"
       4F 52       
043D69 D6 43 41 4C 9971  			DB    D6H, "CALL"
       4C          
043D6E D7 43 48 41 9972  			DB    D7H, "CHAIN"
       49 4E       
043D74 BD 43 48 52 9973  			DB    BDH, "CHR$"
       24          
043D79 D8 43 4C 45 9974  			DB    D8H, "CLEAR", 0
       41 52 00    
043D80 D9 43 4C 4F 9975  			DB    D9H, "CLOSE", 0
       53 45 00    
043D87 DA 43 4C 47 9976  			DB    DAH, "CLG", 0
       00          
043D8C DB 43 4C 53 9977  			DB    DBH, "CLS", 0
       00          
043D91 9B 43 4F 53 9978  			DB    9BH, "COS"
043D95 9C 43 4F 55 9979  			DB    9CH, "COUNT", 0
       4E 54 00    
043D9C DC 44 41 54 9980  			DB    DCH, "DATA"
       41          
043DA1 9D 44 45 47 9981  			DB    9DH, "DEG"
043DA5 DD 44 45 46 9982  			DB    DDH, "DEF"
043DA9 C7 44 45 4C 9983  			DB    C7H, "DELETE"
       45 54 45    
043DB0 81 44 49 56 9984  			DB    81H, "DIV"
043DB4 DE 44 49 4D 9985  			DB    DEH, "DIM_main"
       5F 6D 61 69 
       6E          
043DBD DF 44 52 41 9986  			DB    DFH, "DRAW"
       57          
043DC2 E1 45 4E 44 9987  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
043DCB E0 45 4E 44 9988  			DB    E0H, "END", 0
       00          
043DD0 E2 45 4E 56 9989  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
043DD9 8B 45 4C 53 9990  			DB    8BH, "ELSE"
       45          
043DDE A0 45 56 41 9991  			DB    A0H, "EVAL"
       4C          
043DE3 9E 45 52 4C 9992  			DB    9EH, "ERL", 0
       00          
043DE8 85 45 52 52 9993  			DB    85H, "ERROR"
       4F 52       
043DEE C5 45 4F 46 9994  			DB    C5H, "EOF", 0
       00          
043DF3 82 45 4F 52 9995  			DB    82H, "EOR"
043DF7 9F 45 52 52 9996  			DB    9FH, "ERR", 0
       00          
043DFC A1 45 58 50 9997  			DB    A1H, "EXP"
043E00 A2 45 58 54 9998  			DB    A2H, "EXT", 0
       00          
043E05 E3 46 4F 52 9999  			DB    E3H, "FOR_main"
       5F 6D 61 69 
       6E          
043E0E A3 46 41 4C 10000  			DB    A3H, "FALSE", 0
       53 45 00    
043E15 A4 46 4E 5F 10001  			DB    A4H, "FN_main"
       6D 61 69 6E 
043E1D E5 47 4F 54 10002  			DB    E5H, "GOTO_main"
       4F 5F 6D 61 
       69 6E       
043E27 BE 47 45 54 10003  			DB    BEH, "GET$"
       24          
043E2C A5 47 45 54 10004  			DB    A5H, "GET"
043E30 E4 47 4F 53 10005  			DB    E4H, "GOSUB_main"
       55 42 5F 6D 
       61 69 6E    
043E3B E6 47 43 4F 10006  			DB    E6H, "GCOL"
       4C          
043E40 93 48 49 4D 10007  			DB    93H, "HIMEM", 0
       45 4D 00    
043E47 E8 49 4E 50 10008  			DB    E8H, "INPUT"
       55 54       
043E4D E7 49 46    10009  			DB    E7H, "IF"
043E50 BF 49 4E 4B 10010  			DB    BFH, "INKEY$"
       45 59 24    
043E57 A6 49 4E 4B 10011  			DB    A6H, "INKEY"
       45 59       
043E5D A8 49 4E 54 10012  			DB    A8H, "INT"
043E61 A7 49 4E 53 10013  			DB    A7H, "INSTR("
       54 52 28    
043E68 C9 4C 49 53 10014  			DB    C9H, "LIST"
       54          
043E6D 86 4C 49 4E 10015  			DB    86H, "LINE"
       45          
043E72 C8 4C 4F 41 10016  			DB    C8H, "LOAD"
       44          
043E77 92 4C 4F 4D 10017  			DB    92H, "LOMEM", 0
       45 4D 00    
043E7E EA 4C 4F 43 10018  			DB    EAH, "LOCAL"
       41 4C       
043E84 C0 4C 45 46 10019  			DB    C0H, "LEFT$("
       54 24 28    
043E8B A9 4C 45 4E 10020  			DB    A9H, "LEN"
043E8F E9 4C 45 54 10021  			DB    E9H, "LET"
043E93 AB 4C 4F 47 10022  			DB    ABH, "LOG"
043E97 AA 4C 4E    10023  			DB    AAH, "LN"
043E9A C1 4D 49 44 10024  			DB    C1H, "MID$("
       24 28       
043EA0 EB 4D 4F 44 10025  			DB    EBH, "MODE"
       45          
043EA5 83 4D 4F 44 10026  			DB    83H, "MOD"
043EA9 EC 4D 4F 56 10027  			DB    ECH, "MOVE"
       45          
043EAE ED 4E 45 58 10028  			DB    EDH, "NEXT_main"
       54 5F 6D 61 
       69 6E       
043EB8 CA 4E 45 57 10029  			DB    CAH, "NEW", 0
       00          
043EBD AC 4E 4F 54 10030  			DB    ACH, "NOT"
043EC1 CB 4F 4C 44 10031  			DB    CBH, "OLD", 0
       00          
043EC6 EE 4F 4E    10032  			DB    EEH, "ON"
043EC9 87 4F 46 46 10033  			DB    87H, "OFF"
043ECD 84 4F 52    10034  			DB    84H, "OR"
043ED0 8E 4F 50 45 10035  			DB    8EH, "OPENIN"
       4E 49 4E    
043ED7 AE 4F 50 45 10036  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
043EDF AD 4F 50 45 10037  			DB    ADH, "OPENUP"
       4E 55 50    
043EE6 FF 4F 53 43 10038  			DB    FFH, "OSCLI"
       4C 49       
043EEC F1 50 52 49 10039  			DB    F1H, "PRINT"
       4E 54       
043EF2 90 50 41 47 10040  			DB    90H, "PAGE", 0
       45 00       
043EF8 8F 50 54 52 10041  			DB    8FH, "PTR", 0
       00          
043EFD AF 50 49 00 10042  			DB    AFH, "PI", 0
043F01 F0 50 4C 4F 10043  			DB    F0H, "PLOT"
       54          
043F06 B0 50 4F 49 10044  			DB    B0H, "POINT("
       4E 54 28    
043F0D F2 50 52 4F 10045  			DB    F2H, "PROC_main"
       43 5F 6D 61 
       69 6E       
043F17 B1 50 4F 53 10046  			DB    B1H, "POS", 0
       00          
043F1C CE 50 55 54 10047  			DB    CEH, "PUT"
043F20 F8 52 45 54 10048  			DB    F8H, "RETURN", 0
       55 52 4E 00 
043F28 F5 52 45 50 10049  			DB    F5H, "REPEAT_main"
       45 41 54 5F 
       6D 61 69 6E 
043F34 F6 52 45 50 10050  			DB    F6H, "REPORT", 0
       4F 52 54 00 
043F3C F3 52 45 41 10051  			DB    F3H, "READ"
       44          
043F41 F4 52 45 4D 10052  			DB    F4H, "REM_main"
       5F 6D 61 69 
       6E          
043F4A F9 52 55 4E 10053  			DB    F9H, "RUN", 0
       00          
043F4F B2 52 41 44 10054  			DB    B2H, "RAD"
043F53 F7 52 45 53 10055  			DB    F7H, "RESTORE"
       54 4F 52 45 
043F5B C2 52 49 47 10056  			DB    C2H, "RIGHT$("
       48 54 24 28 
043F63 B3 52 4E 44 10057  			DB    B3H, "RND", 0
       00          
043F68 CC 52 45 4E 10058  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
043F71 88 53 54 45 10059  			DB    88H, "STEP"
       50          
043F76 CD 53 41 56 10060  			DB    CDH, "SAVE"
       45          
043F7B B4 53 47 4E 10061  			DB    B4H, "SGN"
043F7F B5 53 49 4E 10062  			DB    B5H, "SIN"
043F83 B6 53 51 52 10063  			DB    B6H, "SQR"
043F87 89 53 50 43 10064  			DB    89H, "SPC"
043F8B C3 53 54 52 10065  			DB    C3H, "STR$"
       24          
043F90 C4 53 54 52 10066  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
043F99 D4 53 4F 55 10067  			DB    D4H, "SOUND"
       4E 44       
043F9F FA 53 54 4F 10068  			DB    FAH, "STOP", 0
       50 00       
043FA5 B7 54 41 4E 10069  			DB    B7H, "TAN"
043FA9 8C 54 48 45 10070  			DB    8CH, "THEN_main"
       4E 5F 6D 61 
       69 6E       
043FB3 B8 54 4F 5F 10071  			DB    B8H, "TO_main"
       6D 61 69 6E 
043FBB 8A 54 41 42 10072  			DB    8AH, "TAB("
       28          
043FC0 FC 54 52 41 10073  			DB    FCH, "TRACE_main"
       43 45 5F 6D 
       61 69 6E    
043FCB 91 54 49 4D 10074  			DB    91H, "TIME", 0
       45 00       
043FD1 B9 54 52 55 10075  			DB    B9H, "TRUE", 0
       45 00       
043FD7 FD 55 4E 54 10076  			DB    FDH, "UNTIL_main"
       49 4C 5F 6D 
       61 69 6E    
043FE2 BA 55 53 52 10077  			DB    BAH, "USR"
043FE6 EF 56 44 55 10078  			DB    EFH, "VDU"
043FEA BB 56 41 4C 10079  			DB    BBH, "VAL"
043FEE BC 56 50 4F 10080  			DB    BCH, "VPOS", 0
       53 00       
043FF4 FE 57 49 44 10081  			DB    FEH, "WIDTH"
       54 48       
043FFA D3 48 49 4D 10082  			DB    D3H, "HIMEM"
       45 4D       
044000 D2 4C 4F 4D 10083  			DB    D2H, "LOMEM"
       45 4D       
044006 D0 50 41 47 10084  			DB    D0H, "PAGE"
       45          
04400B CF 50 54 52 10085  			DB    CFH, "PTR"
04400F D1 54 49 4D 10086  			DB    D1H, "TIME"
       45          
044014             10087  ;
044014             10088  ; These are indexed from the ERRWDS table
044014             10089  ;
044014 01 4D 69 73 10090  			DB    01H, "Missing "
       73 69 6E 67 
       20          
04401D 02 4E 6F 20 10091  			DB    02H, "No such "
       73 75 63 68 
       20          
044026 03 42 61 64 10092  			DB    03H, "Bad "
       20          
04402B 04 20 72 61 10093  			DB    04H, " range"
       6E 67 65    
044032 05 76 61 72 10094  			DB    05H, "variable"
       69 61 62 6C 
       65          
04403B 06 4F 75 74 10095  			DB    06H, "Out of"
       20 6F 66    
044042 07 4E 6F 20 10096  			DB    07H, "No "
044046 08 20 73 70 10097  			DB    08H, " space"
       61 63 65    
04404D             10098  
04404D             10099  KEYWDL:			EQU     $-KEYWDS
04404D FF FF       10100  			DW    -1
04404F             10101  ;
04404F             10102  ; Error messages
04404F             10103  ;
04404F 07 72 6F 6F 10104  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
044055 06 04 00    10105  			DB    6, 4, 0			;  1: Out of range
044058 00          10106  			DB    0				;  2: *
044059 00          10107  			DB    0				;  3: *
04405A 4D 69 73 74 10108  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
044062 01 2C 00    10109  			DB    1, ",", 0			;  5: Missing ,
044065 54 79 70 65 10110  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
044073 07 A4 00    10111  			DB    7, FN_main, 0			;  7: No FN_main
044076 00          10112  			DB    0				;  8: *
044077 01 22 00    10113  			DB    1, 34, 0			;  9: Missing "
04407A 03 DE 00    10114  			DB    3, DIM_main, 0			; 10: Bad DIM_main
04407D DE 08 00    10115  			DB    DIM_main, 8, 0			; 11: DIM_main space
044080 4E 6F 74 20 10116  			DB    "Not ", LOCAL__main, 0		; 12: Not LOCAL
       EA 00       
044086 07 F2 00    10117  			DB    7, PROC_main, 0		; 13: No PROC_main
044089 41 72 72 61 10118  			DB    "Array", 0		; 14: Array
       79 00       
04408F 53 75 62 73 10119  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
044099 53 79 6E 74 10120  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0440A6 45 73 63 61 10121  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0440AD 44 69 76 69 10122  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0440BE 53 74 72 69 10123  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
0440CE 54 6F 6F 20 10124  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
0440D6 2D 76 65 20 10125  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
0440DF 4C 6F 67 04 10126  			DB    "Log", 4, 0		; 22: Log range
       00          
0440E4 41 63 63 75 10127  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
0440F2 45 78 70 04 10128  			DB    "Exp", 4, 0		; 24: Exp range
       00          
0440F7 00          10129  			DB    0				; 25: *
0440F8 02 05 00    10130  			DB    2, 5, 0			; 26: No such variable
0440FB 01 29 00    10131  			DB    1, ")", 0			; 27: Missing )
0440FE 03 48 45 58 10132  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
044103 02 A4 2F F2 10133  			DB    2, FN_main, "/", PROC_main, 0	; 29: No such FN_main/PROC_main
       00          
044108 03 63 61 6C 10134  			DB    3, "call", 0		; 30: Bad call
       6C 00       
04410E 41 72 67 75 10135  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
044118 07 E3 00    10136  			DB    7, FOR_main, 0			; 32: No FOR_main
04411B 43 61 6E E3 10137  			DB    "Can"t match ", FOR_main, 0	; 33: Can"t match FOR_main
       00          
044120 E3 20 05 00 10138  			DB    FOR_main, " ", 5, 0		; 34: FOR_main variable
044124 00          10139  			DB    0				; 35: *
044125 07 B8 00    10140  			DB    7, TO_main, 0			; 36: No TO_main
044128 00          10141  			DB    0				; 37: *
044129 07 E4 00    10142  			DB    7, GOSUB_main, 0		; 38: No GOSUB_main
04412C EE 20 73 79 10143  			DB    ON__main, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
044135 EE 04 00    10144  			DB    ON__main, 4, 0			; 40: ON range
044138 02 6C 69 6E 10145  			DB    2, "line", 0		; 41: No such line
       65 00       
04413E 06 20 DC 00 10146  			DB    6, " ", DATA__main, 0		; 42: Out of DATA
044142 07 F5 00    10147  			DB    7, REPEAT_main, 0		; 43: No REPEAT_main
044145 00          10148  			DB    0				; 44: *
044146 01 23 00    10149  			DB    1, "#", 0			; 45: Missing #
044149             10150  ;
044149             10151  ; COMMANDS:
044149             10152  ;
044149             10153  ; DELETE line,line
044149             10154  ;
044149 CD 48 44 04 10155  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
04414D CD 50 48 04 10156  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
044151 7E          10157  DELET1:			LD      A,(HL)			; Check whether it's the last line
044152 B7          10158  			OR      A
044153 CA DA 41 04 10159  			JP      Z,WARMNC		; Yes, so do nothing
044157 23          10160  			INC     HL			; Skip the line length byte
044158 11 00 00 00 10161  			LD	DE, 0			; Clear DE
04415C 5E          10162  			LD      E,(HL)			; Fetch the line number in DE
04415D 23          10163  			INC     HL
04415E 56          10164  			LD      D,(HL)
04415F 7A          10165  			LD      A,D			; If the line number is zero then
044160 B3          10166  			OR      E
044161 28 1D       10167  			JR      Z,CLOOP1        	; Do nothing
044163 2B          10168  			DEC     HL			; Decrement BASIC program pointer back to length
044164 2B          10169  			DEC     HL
044165 EB          10170  			EX      DE,HL			; Check if we've gone past the terminating line
044166 37          10171  			SCF
044167 ED 42       10172  			SBC     HL,BC
044169 EB          10173  			EX      DE,HL
04416A 30 6E       10174  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
04416C C5          10175  			PUSH    BC
04416D CD FF 43 04 10176  			CALL    DEL			; Delete the line pointed to by HL
044171 C1          10177  			POP     BC
044172 18 DD       10178  			JR      DELET1			; And loop round to the next line
044174             10179  ;
044174             10180  ; LISTO expr
044174             10181  ;
044174 FD 23       10182  LISTO:			INC     IY              	; Skip "O" byte
044176 CD 27 0C 04 10183  			CALL    EXPRI			; Get expr
04417A D9          10184  			EXX
04417B 7D          10185  			LD      A,L
04417C 32 40 03 04 10186  			LD      (LISTON),A		; Store in LISTON sysvar
044180 C3 45 3C 04 10187  CLOOP1:			JP      CLOOP
044184             10188  ;
044184             10189  ; LIST
044184             10190  ; LIST line
044184             10191  ; LIST line,line [IF string]
044184             10192  ; LIST ,line
044184             10193  ; LIST line,
044184             10194  ;
044184 FE 4F       10195  LIST_:			CP      'O'			; Check for O (LISTO)
044186 28 EC       10196  			JR      Z,LISTO			; and jump to LISTO if zero
044188 CD 50 48 04 10197  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
04418C CD 90 13 04 10198  			CALL    NXT			; Skip space
044190 FE E7       10199  			CP      TIF             	; Check for IF clause (token IF)
044192 3E 00       10200  			LD      A,0             	; Initialise the IF clause string length
044194 20 17       10201  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
044196             10202  ;
044196 FD 23       10203  			INC     IY              	; Skip the IF token
044198 CD 90 13 04 10204  			CALL    NXT             	; And skip any spaces
04419C EB          10205  			EX      DE,HL			; DE: Address in memory
04419D FD E5       10206  			PUSH    IY			; LD IY, HL
04419F E1          10207  			POP     HL              	; HL is now the address of the tokenised line
0441A0 3E 0D       10208  			LD      A,CR
0441A2 C5          10209  			PUSH    BC			; Stack the second line number arg
0441A3 01 00 01 00 10210  			LD      BC,256
0441A7 ED B1       10211  			CPIR                    	; Locate CR byte
0441A9 79          10212  			LD      A,C
0441AA 2F          10213  			CPL                    	 	; A: Substring length (of IF clause)
0441AB C1          10214  			POP     BC			; Restore the second line number arg
0441AC EB          10215  			EX      DE,HL			; HL: Address in memory
0441AD             10216  ;
0441AD 5F          10217  LISTB:			LD      E,A             	; E: IF clause string length
0441AE 78          10218  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0441AF B1          10219  			OR      C
0441B0 20 01       10220  			JR      NZ,LISTA		; If there isn't a second line number
0441B2 0B          10221  			DEC     BC			; then we set it to the maximum of 65535
0441B3             10222  ;
0441B3 D9          10223  LISTA:			EXX
0441B4 DD 21 40 03 10224  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       04          
0441B9 01 00 00 00 10225  			LD      BC,0            	; BC': Indentation counter (C: FOR_main/NEXT_main, B: REPEAT_main/UNTIL_main)
0441BD D9          10226  			EXX
0441BE 3E 14       10227  			LD      A,20			; Number of lines to list
0441C0             10228  ;
0441C0 C5          10229  LISTC:			PUSH    BC              	; Save second line number
0441C1 D5          10230  			PUSH    DE              	; Save IF clause length
0441C2 E5          10231  			PUSH    HL              	; Save BASIC program counter
0441C3 08          10232  			EX      AF,AF'
0441C4             10233  ;
0441C4             10234  ; BBC BASIC for Z80 lines are stored as follows:
0441C4             10235  ;
0441C4             10236  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0441C4             10237  ; - [&00] [&FF] [&FF]: End of program marker
0441C4             10238  ;
0441C4             10239  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0441C4             10240  ;
0441C4 7E          10241  			LD      A,(HL)			; Check for end of program marker
0441C5 B7          10242  			OR      A			; If found
0441C6 28 12       10243  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0441C8             10244  ;
0441C8             10245  ; Check if past terminating line number
0441C8             10246  ;
0441C8 7B          10247  			LD      A,E             	; A: IF clause length
0441C9 23          10248  			INC     HL			; Skip the length byte
0441CA 11 00 00 00 10249  			LD	DE,0			; Clear DE
0441CE 5E          10250  			LD      E,(HL)			; Fetch the line number in DE
0441CF 23          10251  			INC     HL
0441D0 56          10252  			LD      D,(HL)
0441D1 2B          10253  			DEC     HL			; Step HL back to the length byte
0441D2 2B          10254  			DEC     HL
0441D3 D5          10255  			PUSH    DE             	 	; Push the line number on the stack
0441D4 EB          10256  			EX      DE,HL			; HL: line number
0441D5 37          10257  			SCF				; Do a 16-bit compare of HL and DE
0441D6 ED 42       10258  			SBC     HL,BC
0441D8 EB          10259  			EX      DE,HL
0441D9 D1          10260  			POP     DE              	; Restore the line number
0441DA D2 44 3C 04 10261  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0441DE 4E          10262  			LD      C,(HL)          	; C: Line length + 4
0441DF 47          10263  			LD      B,A             	; B: IF clause length
0441E0             10264  ;
0441E0             10265  ; Check if "UNLISTABLE":
0441E0             10266  ;
0441E0 7A          10267  			LD      A,D			; TODO: What is "UNLISTABLE?"
0441E1 B3          10268  			OR      E
0441E2 CA 45 3C 04 10269  			JP      Z,CLOOP
0441E6             10270  ;
0441E6             10271  ; Check for IF clause:
0441E6             10272  ;
0441E6 23          10273  			INC     HL			; Skip the length
0441E7 23          10274  			INC     HL			; Skip the line number
0441E8 23          10275  			INC     HL              	; HL: Address of the tokenised BASIC line
0441E9 0D          10276  			DEC     C			;  C: Line length
0441EA 0D          10277  			DEC     C
0441EB 0D          10278  			DEC     C
0441EC 0D          10279  			DEC     C
0441ED D5          10280  			PUSH    DE              	; Save the line number
0441EE E5          10281  			PUSH    HL              	; Save the BASIC program address
0441EF AF          10282  			XOR     A               	;
0441F0 B8          10283  			CP      B              	 	; Check for an IF clause (B!=0)
0441F1 FD E5       10284  			PUSH    IY			; LD IY, DE
0441F3 D1          10285  			POP     DE              	; DE: Address of the IF clause string in the input buffer
0441F4 C4 A2 10 04 10286  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0441F8 E1          10287  			POP     HL              	; Restore BASIC program address
0441F9 D1          10288  			POP     DE              	; Restore line number
0441FA FD E5       10289  			PUSH    IY
0441FC CC 8F 44 04 10290  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
044200 FD E1       10291  			POP     IY
044202             10292  ;
044202 08          10293  			EX      AF,AF'
044203 3D          10294  			DEC     A			; Decrement line list counter
044204 CD 41 37 04 10295  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
044208 E1          10296  			POP     HL             	 	; Restore BASIC program address to beginning of line
044209 11 00 00 00 10297  			LD	DE,0
04420D 5E          10298  			LD      E,(HL)			; Fetch the length of line in DE
04420E 19          10299  			ADD     HL,DE           	; Go to the next line
04420F D1          10300  			POP     DE              	; Restore IF clause length
044210 C1          10301  			POP     BC              	; Restore second line number
044211 18 AD       10302  			JR      LISTC			; Loop back to do next line
044213             10303  ;
044213             10304  ; RENUMBER
044213             10305  ; RENUMBER start
044213             10306  ; RENUMBER start,increment
044213             10307  ; RENUMBER ,increment
044213             10308  ;
044213 CD 73 44 04 10309  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
044217 CD 28 48 04 10310  			CALL    PAIR_main            	; Fetch the parameters - HL: start (NEW line number), BC: increment
04421B D9          10311  			EXX
04421C 2A 14 03 04 10312  			LD      HL,(PAGE_)		; HL: Top of program
044220 ED 5B 1A 03 10313  			LD      DE,(LOMEM)		; DE: Start address of the heap
       04          
044225             10314  ;
044225             10315  ; Build the table
044225             10316  ;
044225 7E          10317  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
044226 B7          10318  			OR      A			; Is it zero, i.e. the end of program marker?
044227 28 36       10319  			JR      Z,RENUM2		; Yes, so skip to the next part
044229 23          10320  			INC     HL
04422A 4E          10321  			LD      C,(HL)          	; BC: The OLD line number
04422B 23          10322  			INC     HL
04422C 46          10323  			LD      B,(HL)
04422D 78          10324  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
04422E B1          10325  			OR      C
04422F CA 45 3C 04 10326  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
044233 EB          10327  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
044234 71          10328  			LD      (HL),C			; Store the OLD line number in the heap
044235 23          10329  			INC     HL
044236 70          10330  			LD      (HL),B
044237 23          10331  			INC     HL
044238 D9          10332  			EXX				; HL: line number, BC: increment (16-bit values)
044239 E5          10333  			PUSH    HL			; HL: Stack the NEW line number value
04423A 52 09       10334  			ADD.S   HL,BC           	; Add the increment
04423C DA 22 48 04 10335  			JP      C,TOOBIG_main        	; If > 65535, then error: "Too big"
044240 D9          10336  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
044241 C1          10337  			POP     BC			; BC: Pop the NEW line number value off the stack
044242 71          10338  			LD      (HL),C			; Store the NEW line number in the heap
044243 23          10339  			INC     HL
044244 70          10340  			LD      (HL),B
044245 23          10341  			INC     HL
044246 EB          10342  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
044247 2B          10343  			DEC     HL			; Back up to the line length byte
044248 2B          10344  			DEC     HL
044249 01 00 00 00 10345  			LD	BC, 0
04424D 4E          10346  			LD      C,(HL)			; BC: Line length
04424E 09          10347  			ADD	HL,BC           	; Advance HL to next line
04424F EB          10348  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
044250 E5          10349  			PUSH    HL
044251 24          10350  			INC     H			; Increment to next page
044252 ED 72       10351  			SBC     HL,SP			; Subtract from SP
044254 E1          10352  			POP     HL
044255 EB          10353  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
044256 38 CD       10354  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
044258 CD 74 43 04 10355  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
04425C CC          10356  			DB    	REN
04425D 08          10357  			DB    	8
04425E 00          10358  			DB    	0
04425F             10359  ;
04425F             10360  ; At this point a list of BASIC line numbers have been written to the heap
04425F             10361  ; as word pairs:
04425F             10362  ; - DW: The OLD line number
04425F             10363  ; - DW: The NEW line number
04425F             10364  ;
04425F EB          10365  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
044260 36 FF       10366  			LD      (HL),-1			; Mark the end with FFFFh
044262 23          10367  			INC     HL
044263 36 FF       10368  			LD      (HL),-1
044265 ED 5B 1A 03 10369  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       04          
04426A D9          10370  			EXX
04426B 2A 14 03 04 10371  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
04426F 4E          10372  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
044270 79          10373  			LD      A,C			; If it is zero, then no program, so...
044271 B7          10374  			OR      A
044272 CA 44 3C 04 10375  			JP      Z,WARM			; Jump to warm start
044276 D9          10376  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
044277 EB          10377  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
044278 23          10378  			INC     HL			; Skip to the NEW line number
044279 23          10379  			INC     HL
04427A 5E          10380  			LD      E,(HL)			; DE: The NEW line number
04427B 23          10381  			INC     HL
04427C 56          10382  			LD      D,(HL)
04427D 23          10383  			INC     HL
04427E D5          10384  			PUSH    DE			; Stack the NEW line number
04427F EB          10385  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
044280 22 23 03 04 10386  			LD      (LINENO),HL		; Store the line number in LINENO
044284 D9          10387  			EXX				; HL: Pointer to the BASIC program area
044285 D1          10388  			POP     DE			; DE: The NEW line number
044286 23          10389  			INC     HL
044287 73          10390  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
044288 23          10391  			INC     HL
044289 72          10392  			LD      (HL),D
04428A 23          10393  			INC     HL
04428B 0D          10394  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
04428C 0D          10395  			DEC     C
04428D 0D          10396  			DEC     C
04428E 79          10397  			LD	A,C
04428F 01 00 00 00 10398  			LD	BC,0
044293 4F          10399  			LD	C,A			; BC: Line length
044294             10400  ;
044294 3E 8D       10401  RENUM7:			LD      A,LINO_main			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO_main/GOSUB_main)
044296 ED B1       10402  			CPIR                    	; Search for the token
044298 20 D5       10403  			JR      NZ,RENUM3		; If not found, then loop to process the next line
04429A             10404  ;
04429A             10405  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
04429A             10406  ;
04429A C5          10407  			PUSH    BC			; Stack everything
04429B E5          10408  			PUSH    HL
04429C E5          10409  			PUSH    HL			; HL: Pointer to encoded line number
04429D FD E1       10410  			POP     IY			; IY: Pointer to encoded line number
04429F D9          10411  			EXX
0442A0 CD 03 12 04 10412  			CALL    DECODE			; Decode the encoded line number (in HL')
0442A4 D9          10413  			EXX				; HL: Decoded line number
0442A5 44          10414  			LD      B,H			; BC: Decoded line number
0442A6 4D          10415  			LD      C,L
0442A7 2A 1A 03 04 10416  			LD      HL,(LOMEM)		; HL: Pointer to heap
0442AB             10417  ;
0442AB             10418  ; This section of code cross-references the decoded (OLD) line number with the list
0442AB             10419  ; created previously in the global heap
0442AB             10420  ;
0442AB 5E          10421  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0442AC 23          10422  			INC     HL
0442AD 56          10423  			LD      D,(HL)
0442AE 23          10424  			INC     HL
0442AF EB          10425  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0442B0 B7          10426  			OR      A               	; Clear the carry and...
0442B1 52 ED 42    10427  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0442B4 EB          10428  			EX      DE,HL			; HL: Pointer in the global heap
0442B5 5E          10429  			LD      E,(HL)          	; DE: The NEW line number
0442B6 23          10430  			INC     HL
0442B7 56          10431  			LD      D,(HL)
0442B8 23          10432  			INC     HL
0442B9 38 F0       10433  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0442BB EB          10434  			EX      DE,HL			; DE: Pointer in the global heap
0442BC 28 1D       10435  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0442BE             10436  ;
0442BE CD 8D 49 04 10437  			CALL    TELL			; Display this error if the line number is not found
0442C2 46 61 69 6C 10438  			DB    	"Failed at "
       65 64 20 61 
       74 20       
0442CC 00          10439  			DB    	0
0442CD 2A 23 03 04 10440  			LD      HL,(LINENO)
0442D1 CD F4 45 04 10441  			CALL    PBCDL
0442D5 CD 44 45 04 10442  			CALL    CRLF
0442D9 18 07       10443  			JR      RENUM6			; And carry on renumbering
0442DB             10444  ;
0442DB             10445  ; This snippet re-encodes the line number in the BASIC program
0442DB             10446  ;
0442DB D1          10447  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0442DC D5          10448  			PUSH    DE
0442DD 1B          10449  			DEC     DE			; Back up a byte to the LINO_main token
0442DE CD 59 49 04 10450  			CALL    ENCODE          	; Re-write the new line number out
0442E2 E1          10451  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0442E3 C1          10452  			POP     BC			; BC: The remaining line length
0442E4 18 AE       10453  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0442E6             10454  ;
0442E6             10455  ; AUTO
0442E6             10456  ; AUTO start,increment
0442E6             10457  ; AUTO start
0442E6             10458  ; AUTO ,increment
0442E6             10459  ;
0442E6 CD 28 48 04 10460  AUTO:			CALL    PAIR_main			; Get the parameter pair (HL: first parameter, BC: second parameter)
0442EA 22 29 03 04 10461  			LD      (AUTONO),HL		; Store the start in AUTONO
0442EE 79          10462  			LD      A,C			; Increment is 8 bit (0-255)
0442EF 32 41 03 04 10463  			LD      (INCREM),A		; Store that in INCREM
0442F3 18 2E       10464  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0442F5             10465  ;
0442F5             10466  ; BAD
0442F5             10467  ; NEW
0442F5             10468  ;
0442F5 CD 8D 49 04 10469  BAD:			CALL    TELL            	; Output "Bad program" error
0442F9 03          10470  			DB    3				; Token for "BAD"
0442FA 70 72 6F 67 10471  			DB    "program"
       72 61 6D    
044301 0D          10472  			DB    CR
044302 0A          10473  			DB    LF
044303 00          10474  			DB    0				; Falls through to NEW
044304             10475  ;
044304 CD 69 44 04 10476  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
044308 18 19       10477  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
04430A             10478  ;
04430A             10479  ; OLD
04430A             10480  ;
04430A 2A 14 03 04 10481  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
04430E E5          10482  			PUSH    HL			; Stack it
04430F 23          10483  			INC     HL			; Skip the potential length byte of first line of code
044310 23          10484  			INC     HL			; And the line number word
044311 23          10485  			INC     HL
044312 01 FC 00 00 10486  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
044316 3E 0D       10487  			LD      A,CR
044318 ED B1       10488  			CPIR
04431A 20 D9       10489  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
04431C 7D          10490  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
04431D E1          10491  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
04431E 77          10492  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
04431F CD 3C 44 04 10493  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
044323 C3 45 3C 04 10494  CLOOP0:			JP      CLOOP			; Jump back to the command loop
044327             10495  ;
044327             10496  ; LOAD filename
044327             10497  ;
044327 CD 32 0C 04 10498  LOAD:			CALL    EXPRS           	; Get the filename
04432B 3E 0D       10499  			LD      A,CR			; DE points to the last byte of filename in ACCS
04432D 12          10500  			LD      (DE),A			; Terminate filename with a CR
04432E CD 1C 44 04 10501  			CALL    LOAD0			; Load the file in, then CLEAN
044332 CD 73 44 04 10502  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
044336 18 21       10503  			JR      WARM0			; Jump back to the command loop
044338             10504  ;
044338             10505  ; SAVE filename
044338             10506  ;
044338 CD 48 44 04 10507  SAVE:			CALL    SETTOP          	; Set TOP sysvar
04433C CD 32 0C 04 10508  			CALL    EXPRS           	; Get the filename
044340 3E 0D       10509  			LD      A,CR			; Terminate the filename with a CR
044342 12          10510  			LD      (DE),A
044343 ED 5B 14 03 10511  			LD      DE,(PAGE_)		; DE: Start of program memory
       04          
044348 2A 17 03 04 10512  			LD      HL,(TOP)		; HL: Top of program memory
04434C B7          10513  			OR      A			; Calculate program size (TOP-PAGE)
04434D ED 52       10514  			SBC     HL,DE
04434F 44          10515  			LD      B,H             	; BC: Length of program in bytes
044350 4D          10516  			LD      C,L
044351 21 00 00 04 10517  			LD      HL,ACCS			; HL: Address of the filename
044355 CD 0E 3A 04 10518  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
044359 C3 44 3C 04 10519  WARM0:			JP      WARM			; Jump back to the command loop
04435D             10520  
04435D             10521  ;
04435D             10522  ; ERROR
04435D             10523  ; Called whenever BASIC needs to halt with an error
04435D             10524  ; Error messages are indexed from 0
04435D             10525  ; Inputs:
04435D             10526  ;  A: Error number
04435D             10527  ;
04435D ED 7B 20 03 10528  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
044362 21 4F 40 04 10529  			LD      HL,ERRWDS		; Index into the error string table
044366 B7          10530  			OR      A			; We don't need to search for the first error
044367 28 0A       10531  			JR      Z,ERROR1_main		; So skip the search routine
044369             10532  ;
044369             10533  ; Search the error table for error #A
044369             10534  ; HL will end up being the pointer into the correct error
044369             10535  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
044369             10536  ;
044369 47          10537  			LD      B,A             	; Store error number in B
04436A 08          10538  			EX      AF,AF'			; Store error number in AF'
04436B AF          10539  			XOR     A
04436C BE          10540  ERROR0_main:			CP      (HL)			; Compare the character with 0 (the terminator byte)
04436D 23          10541  			INC     HL			; Increment the string pointer
04436E 20 FC       10542  			JR      NZ,ERROR0_main		; Loop until with hit a 0
044370 10 FA       10543  			DJNZ    ERROR0_main			; Decrements the error number and loop until 0
044372 08          10544  			EX      AF,AF'			; Restore the error number from AF'
044373             10545  ;
044373             10546  ; At this point HL points to the tokenised error string
044373             10547  ;
044373 E5          10548  ERROR1_main:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
044374             10549  
044374             10550  ;
044374             10551  ; EXTERR
044374             10552  ; Inputs:
044374             10553  ;  A: Error number
044374             10554  ;
044374             10555  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
044374             10556  ; The error text immediately follows the CALL to EXTERR, for example:
044374             10557  ; > CALL  EXTERR
044374             10558  ; > DB    "Silly", 0
044374             10559  ; So we can get the address of the string by popping the return address off the stack
044374             10560  ;
044374 E1          10561  EXTERR:			POP     HL			; Pop the error string pointer
044375 22 2F 03 04 10562  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
044379 ED 7B 20 03 10563  			LD      SP,(HIMEM)		; Set SP to HIMEM
       04          
04437E 32 3F 03 04 10564  			LD      (ERR),A			; Store error number in ERR sysvar
044382 CD AB 45 04 10565  			CALL    SETLIN			; Get line number
044386 22 33 03 04 10566  			LD      (ERL),HL		; Store in ERL sysvar
04438A B7          10567  			OR      A			; Is error number 0?
04438B 28 0D       10568  			JR      Z,ERROR2_main		; Yes, so skip the next bit as error number 0 is untrappable
04438D             10569  ;
04438D 2A 2C 03 04 10570  			LD      HL,(ERRTRP)		; Check whether the error is trapped
044391 7C          10571  			LD      A,H
044392 B5          10572  			OR      L
044393 E5          10573  			PUSH    HL			; HL: Error line
044394 FD E1       10574  			POP     IY			; IY: HL
044396 C2 B6 14 04 10575  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
04439A             10576  ;
04439A 21 00 00 00 10577  ERROR2_main:			LD      HL,0
04439E 22 29 03 04 10578  			LD      (AUTONO),HL		; Cancel AUTO
0443A2 22 26 03 04 10579  			LD      (TRACEN),HL     	; Cancel TRACE_main
0443A6 CD 6F 3B 04 10580  			CALL    RESET           	; Reset OPSYS
0443AA CD 44 45 04 10581  			CALL    CRLF			; Output newline
0443AE CD 7F 49 04 10582  			CALL    REPORT          	; Output the error message
0443B2 CD DF 45 04 10583  			CALL    SAYLN			; Output " at line nnnn" message.
0443B6 1E 00       10584  			LD      E,0			; Close all files
0443B8 DC 0C 3B 04 10585  			CALL    C,OSSHUT
0443BC CD 44 45 04 10586  			CALL    CRLF			; Output newline
0443C0 C3 45 3C 04 10587  			JP      CLOOP			; Back to CLOOP
0443C4             10588  ;
0443C4             10589  ; SUBROUTINES:
0443C4             10590  ;
0443C4             10591  ; LEX - SEARCH FOR KEYWORDS
0443C4             10592  ;   Inputs: HL = start of keyword table
0443C4             10593  ;           IY = start of match text
0443C4             10594  ;  Outputs: If found, Z-flag set, A=token.
0443C4             10595  ;           If not found, Z-flag reset, A=(IY).
0443C4             10596  ;           IY updated (if NZ, IY unchanged).
0443C4             10597  ; Destroys: A,B,H,L,IY,F
0443C4             10598  ;
0443C4 21 2D 3D 04 10599  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0443C8             10600  ;
0443C8 FD 7E 00    10601  LEX0:			LD      A,(IY)			; Fetch the character to match
0443CB 46          10602  			LD      B,(HL)			; B: The token from the keywords table
0443CC 23          10603  			INC     HL			; Increment the pointer in the keywords table
0443CD BE          10604  			CP      (HL)			; Compare the first characters
0443CE 28 08       10605  			JR      Z,LEX2			; If there is a match, then skip to LEX2
0443D0 D8          10606  			RET     C               	; No match, so fail
0443D1             10607  ;
0443D1             10608  ; This snippet of code skips to the next token in the KEYWDS table
0443D1             10609  ;
0443D1 23          10610  LEX1:			INC     HL			; Increment the pointer
0443D2 CB 7E       10611  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0443D4 28 FB       10612  			JR      Z,LEX1			; No, so loop
0443D6 18 F0       10613  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
0443D8             10614  ;
0443D8 FD E5       10615  LEX2:			PUSH    IY              	; Save the input pointer
0443DA 23          10616  LEX3:			INC     HL			; Increment the keyword pointer
0443DB CB 7E       10617  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0443DD 20 1C       10618  			JR      NZ,LEX6         	; Jump to here as we've found a token
0443DF FD 23       10619  			INC     IY			; Increment the text pointer
0443E1 FD 7E 00    10620  			LD      A,(IY)			; Fetch the character
0443E4 FE 2E       10621  			CP      '.'			; Is it an abbreviated keyword?
0443E6 28 13       10622  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0443E8 BE          10623  			CP      (HL)			; Compare with the keywords list
0443E9 28 EF       10624  			JR      Z,LEX3			; It's a match, so continue checking this keyword
0443EB CD 78 48 04 10625  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0443EF 38 04       10626  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0443F1             10627  ;
0443F1 FD E1       10628  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0443F3 18 DC       10629  			JR      LEX1			; And loop back to start again
0443F5             10630  ;
0443F5             10631  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
0443F5             10632  ; immediately delimited
0443F5             10633  ;
0443F5 7E          10634  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0443F6 B7          10635  			OR      A			; If it is not zero, then...
0443F7 20 F8       10636  			JR      NZ,LEX4			; Keep searching
0443F9 FD 2B       10637  			DEC     IY			; If it is zero, then skip the input pointer back one byte
0443FB             10638  ;
0443FB             10639  ; We've found a token at this point
0443FB             10640  ;
0443FB F1          10641  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0443FC AF          10642  			XOR     A			; Set the Z flag
0443FD 78          10643  			LD      A,B			; A: The token
0443FE C9          10644  			RET
0443FF             10645  ;
0443FF             10646  ; DEL - DELETE A PROGRAM LINE.
0443FF             10647  ;   Inputs: HL addresses program line.
0443FF             10648  ; Destroys: B,C,F
0443FF             10649  ;
0443FF             10650  ; This simply erases the line by moving all of the code after the line to be deleted back over
0443FF             10651  ; it using an LDIR
0443FF             10652  ;
0443FF D5          10653  DEL:			PUSH    DE
044400 E5          10654  			PUSH    HL
044401 E5          10655  			PUSH    HL			; HL: Address of the program line
044402 06 00       10656  			LD      B,0			; BC: Length of the line
044404 4E          10657  			LD      C,(HL)
044405 09          10658  			ADD     HL,BC			; HL: Advanced to the start of the next line
044406 E5          10659  			PUSH    HL
044407 EB          10660  			EX      DE,HL			; DE: Pointer to the next line
044408 2A 17 03 04 10661  			LD      HL,(TOP)		; HL: Pointer to the end of the program
04440C ED 52       10662  			SBC     HL,DE
04440E 44          10663  			LD      B,H			; BC: Size of block to move
04440F 4D          10664  			LD      C,L
044410 E1          10665  			POP     HL			; HL: Pointer to next line
044411 D1          10666  			POP     DE			; DE: Pointer to this line
044412 ED B0       10667  			LDIR                    	; Delete the line
044414 ED 53 17 03 10668  			LD      (TOP),DE		; Adjust TOP
       04          
044419 E1          10669  			POP     HL
04441A D1          10670  			POP     DE
04441B C9          10671  			RET
04441C             10672  ;
04441C             10673  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
04441C             10674  ;   Inputs: Filename in ACCS (term CR)
04441C             10675  ; Destroys: A,B,C,D,E,H,L,F
04441C             10676  ;
04441C             10677  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
04441C             10678  ; AND WRITE FF FF, THEN LOAD (TOP).
04441C             10679  ; Destroys: A,B,C,H,L,F
04441C             10680  ;
04441C ED 5B 14 03 10681  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       04          
044421 21 00 FF FF 10682  			LD      HL,-256
044425 39          10683  			ADD     HL,SP
044426 ED 52       10684  			SBC     HL,DE           	; Find available space
044428 44          10685  			LD      B,H
044429 4D          10686  			LD      C,L
04442A 21 00 00 04 10687  			LD      HL,ACCS
04442E CD 75 39 04 10688  			CALL    OSLOAD          	; Call the OSLOAD function in patch
044432 D4 69 44 04 10689  			CALL    NC,NEWIT		; If NC then NEW
044436 3E 00       10690  			LD      A,0
044438 D2 5D 43 04 10691  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
04443C             10692  ;
04443C CD 48 44 04 10693  CLEAN:			CALL    SETTOP			; Set TOP sysvar
044440 2B          10694  			DEC     HL			; Write out the end of program markers
044441 36 FF       10695  			LD      (HL),-1
044443 2B          10696  			DEC     HL
044444 36 FF       10697  			LD      (HL),-1
044446 18 2B       10698  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
044448             10699  ;
044448             10700  ; Set the TOP sysvar; the first free location after the end of the current program
044448             10701  ; Returns:
044448             10702  ; - HL: TOP
044448             10703  ;
044448 2A 14 03 04 10704  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
04444C 01 00 00 00 10705  			LD	BC, 0			; BC: 0
044450 3E 0D       10706  			LD      A,CR			; End of line marker
044452 4E          10707  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
044453 0C          10708  			INC     C			; Check for zero
044454 0D          10709  			DEC     C
044455 28 0A       10710  			JR      Z,SETOP2		; If it is zero, we've reached the end
044457 09          10711  			ADD     HL,BC			; Skip to next line
044458 2B          10712  			DEC     HL			; Check end of previous line
044459 BE          10713  			CP      (HL)
04445A 23          10714  			INC     HL
04445B 28 F5       10715  			JR      Z,SETOP1		; If CR then loop
04445D C3 F5 42 04 10716  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
044461             10717  ;
044461 23          10718  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
044462 23          10719  			INC     HL			; NB: Called from NEWIT
044463 23          10720  			INC     HL
044464 22 17 03 04 10721  			LD      (TOP),HL		; Store in TOP sysvar
044468 C9          10722  			RET
044469             10723  ;
044469             10724  ; NEWIT - NEW PROGRAM THEN CLEAR
044469             10725  ;   Destroys: H,L
044469             10726  ;
044469             10727  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
044469             10728  ; FUNCTION AND PROCEDURE POINTERS.
044469             10729  ;   Destroys: Nothing
044469             10730  ;
044469 2A 14 03 04 10731  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
04446D 36 00       10732  			LD      (HL),0			; Stick a 0 in there
04446F CD 61 44 04 10733  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
044473             10734  ;
044473 E5          10735  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
044474 2A 17 03 04 10736  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
044478 22 1A 03 04 10737  			LD      (LOMEM),HL		; Set the LOMEM sysvar
04447C 22 1D 03 04 10738  			LD      (FREE),HL		; And the FREE sysvar with that value
044480 21 6C 02 04 10739  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
044484 C5          10740  			PUSH    BC
044485             10741  			; LD      B,3*(54+2)		; Loop counter
044485 06 A8       10742  			LD B,54+2*3			; EZ80ASM doesn't do order of operations
044487 36 00       10743  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
044489 23          10744  			INC     HL
04448A 10 FB       10745  			DJNZ    CLEAR1
04448C C1          10746  			POP     BC
04448D E1          10747  			POP     HL			; Restore the BASIC program pointer
04448E C9          10748  			RET
04448F             10749  ;
04448F             10750  ;LISTIT - LIST A PROGRAM LINE.
04448F             10751  ;    Inputs: HL addresses line
04448F             10752  ;            DE = line number (binary)
04448F             10753  ;            IX = Pointer to LISTON
04448F             10754  ;             B = FOR/NEXT indent level
04448F             10755  ;             C = REPEAT/UNTIL indent level
04448F             10756  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
04448F             10757  ;
04448F E5          10758  LISTIT:			PUSH    HL			; Stack the address of the line
044490 EB          10759  			EX      DE,HL			; HL: Line number
044491 C5          10760  			PUSH    BC
044492 CD F8 45 04 10761  			CALL    PBCD			; Print the line number
044496 C1          10762  			POP     BC
044497 E1          10763  			POP     HL			; HL: Address of the first token/character
044498 7E          10764  			LD      A,(HL)			; Fetch the token
044499 FE ED       10765  			CP      NEXT_main			; Is it NEXT_main...
04449B CC 25 45 04 10766  			CALL    Z,INDENT		; Yes, so indent in
04449F FE FD       10767  			CP      UNTIL_main			; Or is it UNTIL_main...
0444A1 CC 25 45 04 10768  			CALL    Z,INDENT		; Yes, so indent in
0444A5 D9          10769  			EXX
0444A6 3E 20       10770  			LD      A,' '
0444A8 DD CB 00 46 10771  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0444AC C4 4C 45 04 10772  			CALL    NZ,OUTCHR		; Then print a space after the line number
0444B0 78          10773  			LD      A,B			; Fetch the FOR_main/NEXT_main indent level
0444B1 87          10774  			ADD     A,A			; Multiply by 2
0444B2 DD CB 00 4E 10775  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0444B6 C4 39 21 04 10776  			CALL    NZ,FILL			; Then print the FOR_main/NEXT_main indent
0444BA 79          10777  			LD      A,C			; Fetch the REPEAT_main/UNTIL_main indent level
0444BB 87          10778  			ADD     A,A			; Multiply by 2
0444BC DD CB 00 56 10779  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0444C0 C4 39 21 04 10780  			CALL    NZ,FILL			; Then print the REPEAT_main/UNTIL_main indent
0444C4 D9          10781  			EXX
0444C5 7E          10782  			LD      A,(HL)			; Fetch the token
0444C6 FE E3       10783  			CP      FOR_main			; Is it FOR_main?
0444C8 CC 25 45 04 10784  			CALL    Z,INDENT		; Yes, so indent
0444CC FE F5       10785  			CP      REPEAT_main			; Is it REPEAT_main?
0444CE CC 25 45 04 10786  			CALL    Z,INDENT		; Yes, so indent
0444D2 1E 00       10787  			LD      E,0			; E: The quote counter - reset to 0
0444D4 7E          10788  LIST8:			LD      A,(HL)			; Fetch a character / token byte
0444D5 23          10789  			INC     HL
0444D6 FE 0D       10790  			CP      CR			; Is it end of line?
0444D8 28 0B       10791  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0444DA FE 22       10792  			CP      34			; Is it a quote character?
0444DC 20 01       10793  			JR      NZ,LIST7		; No, so skip to next bit
0444DE 1C          10794  			INC     E			; Otherwise increment quote counter
0444DF CD 14 45 04 10795  LIST7:			CALL    LOUT			; Output the character / token
0444E3 18 EF       10796  			JR      LIST8			; And repeat
0444E5             10797  ;
0444E5             10798  ; DB: Modification for *EDIT
0444E5             10799  ; Terminate the line with either a CRLF or a NUL character
0444E5             10800  ;
0444E5 DD CB 00 5E 10801  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0444E9 28 59       10802  			JR	Z, CRLF			; Yes, so print a CRLF
0444EB AF          10803  			XOR	A			; Otherwise print a NUL (0)
0444EC C3 D0 36 04 10804  			JP	OSWRCH
0444F0             10805  ;
0444F0             10806  ; Decode the 3 byte GOTO type line number
0444F0             10807  ;
0444F0 E5          10808  PRLINO:			PUSH    HL			; Swap HL and IY
0444F1 FD E1       10809  			POP     IY			; IY: Pointer to the line number
0444F3 C5          10810  			PUSH    BC
0444F4 CD 03 12 04 10811  			CALL    DECODE			; Decode
0444F8 C1          10812  			POP     BC
0444F9 D9          10813  			EXX
0444FA C5          10814  			PUSH    BC
0444FB CD F4 45 04 10815  			CALL    PBCDL			; Output the line number
0444FF C1          10816  			POP     BC
044500 D9          10817  			EXX
044501 FD E5       10818  			PUSH    IY			; Swap HL and IY
044503 E1          10819  			POP     HL			; HL: Pointer to the next character in the line
044504 C9          10820  			RET
044505             10821  ;
044505             10822  ; DB: Modification for internationalisation
044505             10823  ;
044505 CD 69 45 04 10824  PRREM:			CALL	OUT_			; Output the REM_main token
044509             10825  ; @@:			LD	A, (HL)			; Fetch the character
044509 7E          10826  @@:			LD	A, (HL)			; Fetch the character
04450A FE 0D       10827  			CP	CR			; If it is end of line, then
04450C C8          10828  			RET	Z			; we have finished
04450D CD 4C 45 04 10829  			CALL	OUTCHR			; Ouput the character
044511 23          10830  			INC	HL
044512             10831  			; JR	@B			; And loop
044512 18 F5       10832  			JR	@B			; And loop
044514             10833  ;
044514             10834  ; DB: End of modification
044514             10835  ;
044514 CB 43       10836  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
044516 20 34       10837  			JR      NZ,OUTCHR		; don't tokenise, just output the character
044518 FE F4       10838  			CP	REM_main			; DB: Is it REM_main
04451A 28 E9       10839  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM_main
04451C FE 8D       10840  			CP      LINO_main			; Is it a line number (following GOTO_main/GOSUB_main etc)?
04451E 28 D0       10841  			JR      Z,PRLINO		; Yes, so decode and print the line number
044520 CD 69 45 04 10842  			CALL    OUT_			; Output a character / keyword
044524 7E          10843  			LD      A,(HL)			; Fetch the next character
044525             10844  ;
044525             10845  ; This block of code handles the indentation
044525             10846  ; B: Counter for FOR/NEXT indent
044525             10847  ; C: Counter for REPEAT/UNTIL indent
044525             10848  ;
044525 D9          10849  INDENT:			EXX
044526 FE E3       10850  			CP      FOR_main			; If the token is FOR_main
044528 28 09       10851  			JR      Z,IND1			; Then INC B
04452A FE ED       10852  			CP      NEXT_main			; If it is NEXT_main
04452C 20 06       10853  			JR      NZ,IND2_		; Then...
04452E 05          10854  			DEC     B			; DEC B
04452F F2 34 45 04 10855  			JP      P,IND2_			; If we have gone below 0 then
044533 04          10856  IND1:			INC     B			; Increment back to 0
044534             10857  ;
044534 FE F5       10858  IND2_:			CP      REPEAT_main			; If the token is REPEAT_main
044536 28 09       10859  			JR      Z,IND3			; Then INC C
044538 FE FD       10860  			CP      UNTIL_main			; If it is UNTIL_main
04453A 20 06       10861  			JR      NZ,IND4			; Then...
04453C 0D          10862  			DEC     C			; DEC C
04453D F2 42 45 04 10863  			JP      P,IND4			; If we have gone below 0 then
044541 0C          10864  IND3:			INC     C			; Incremet back to 0
044542 D9          10865  IND4:			EXX
044543 C9          10866  			RET
044544             10867  ;
044544             10868  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
044544             10869  ;  Destroys: A,F
044544             10870  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
044544             10871  ;    Inputs: A = character
044544             10872  ;  Destroys: A,F
044544             10873  ;
044544 3E 0D       10874  CRLF:			LD      A,CR			; Output CR
044546 CD 4C 45 04 10875  			CALL    OUTCHR
04454A 3E 0A       10876  			LD      A,LF			; Output LF
04454C             10877  ;
04454C CD D0 36 04 10878  OUTCHR:			CALL    OSWRCH			; Output the character in A
044550 D6 0D       10879  			SUB     CR			; Check for CR
044552 28 06       10880  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
044554 D8          10881  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
044555 3A 3D 03 04 10882  			LD      A,(COUNT)		; Increment the count
044559 3C          10883  			INC     A
04455A             10884  ;
04455A 32 3D 03 04 10885  CARRET:			LD      (COUNT),A		; Store the new count value
04455E C8          10886  			RET     Z			; Return if the count has wrapped to 0
04455F E5          10887  			PUSH    HL			; Now check if count = print width
044560 2A 3E 03 04 10888  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
044564 BD          10889  			CP      L			; L is the width. Compare it with count.
044565 E1          10890  			POP     HL
044566 C0          10891  			RET     NZ			; If we've not hit print width, then just return
044567 18 DB       10892  			JR      CRLF			; Otherwise output CRLF
044569             10893  ;
044569             10894  ; OUT - SEND CHARACTER OR KEYWORD
044569             10895  ;   Inputs: A = character (>=10, <128)
044569             10896  ;           A = Token (<10, >=128)
044569             10897  ;  Destroys: A,F
044569             10898  ;
044569 FE 8A       10899  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
04456B EA 4C 45 04 10900  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
04456F             10901  ;
04456F             10902  ; This bit looks up the character in the KEYWDS token table and expands it
04456F             10903  ; Note the CP 138; this sets the overflow flag as follows:
04456F             10904  ;
04456F             10905  ; NB:
04456F             10906  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
04456F             10907  ;  2. CP is effectively a SUB; sets the flags without affecting A
04456F             10908  ;  3. The operation n - -118 ~ n + 118
04456F             10909  ;
04456F             10910  ; So:
04456F             10911  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
04456F             10912  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
04456F             10913  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
04456F             10914  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
04456F             10915  ;
04456F C5          10916  			PUSH    BC			; Preserve BC and HL
044570 E5          10917  			PUSH    HL
044571 21 2D 3D 04 10918  			LD      HL,KEYWDS		; The list of tokens and keywords
044575 01 20 03 00 10919  			LD      BC,KEYWDL		; The length of the keyword list
044579 ED B1       10920  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
04457B             10921  ;							; At this point HL points to the next byte, the first character of the token
04457B 7E          10922  TOKEN1:			LD      A,(HL)			; Fetch the character
04457C 23          10923  			INC     HL			; Increment to the next byte in the token table
04457D FE 8A       10924  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
04457F F5          10925  			PUSH    AF			; Then...
044580 EC 4C 45 04 10926  			CALL    PE,OUTCHR		; Output the character...
044584 F1          10927  			POP     AF			;
044585 EA 7B 45 04 10928  			JP      PE,TOKEN1		; And loop to the next character
044589 E1          10929  			POP     HL			; Done, so tidy up the stack and exit
04458A C1          10930  			POP     BC
04458B C9          10931  			RET
04458C             10932  ;
04458C             10933  ; FINDL - FIND PROGRAM LINE
04458C             10934  ;   Inputs: HL = line number (binary)
04458C             10935  ;  Outputs: HL addresses line (if found)
04458C             10936  ;           DE = line number
04458C             10937  ;           Z-flag set if found.
04458C             10938  ; Destroys: A,B,C,D,E,H,L,F
04458C             10939  ;
04458C EB          10940  FINDL:			EX      DE,HL			; DE: Line number (binary)
04458D 2A 14 03 04 10941  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
044591 AF          10942  			XOR     A               	;  A: 0
044592 BE          10943  			CP      (HL)			; Check for end of program marker
044593 3C          10944  			INC     A			;  A: 1
044594 D0          10945  			RET     NC			; Return with 1 if 0
044595 AF          10946  			XOR     A               	; Clear the carry flag
044596             10947  ;			LD      B,A			;  B: 0
044596 01 00 00 00 10948  			LD	BC, 0			; BC: 0
04459A             10949  ;
04459A 4E          10950  FINDL1:			LD      C,(HL)			;  C: The line length
04459B E5          10951  			PUSH    HL			; Stack the current program counter
04459C 23          10952  			INC     HL			; Skip to the line number bytes
04459D 7E          10953  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
04459E 23          10954  			INC     HL
04459F 66          10955  			LD      H,(HL)
0445A0 6F          10956  			LD      L,A
0445A1 52 ED 52    10957  			SBC.S   HL,DE			; Compare with the line number we're searching for
0445A4 E1          10958  			POP     HL			; Get the current program counter
0445A5 D0          10959  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0445A6 09          10960  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0445A7 C3 9A 45 04 10961  			JP      FINDL1			; And loop
0445AB             10962  ;
0445AB             10963  ; SETLIN - Search program for line containing address
0445AB             10964  ;          Update (LINENO)
0445AB             10965  ;   Inputs: Address in (ERRLIN)
0445AB             10966  ;  Outputs: Line number in HL and (LINENO)
0445AB             10967  ; Destroys: B,C,D,E,H,L,F
0445AB             10968  ;
0445AB 01 00 00 00 10969  SETLIN:			LD	BC, 0			; Zero BC for later
0445AF             10970  ;			LD      B, 0			; Zero B for later
0445AF ED 5B 35 03 10971  			LD      DE, (ERRLIN)		; DE: Address of line
       04          
0445B4 2A 14 03 04 10972  			LD      HL, (PAGE_)		; HL: Start of user program area
0445B8 B7          10973  			OR      A			; Do a 24 bit compare without destroying HL
0445B9 ED 52       10974  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0445BB 19          10975  			ADD     HL, DE			;  C: DE > HL
0445BC 30 1B       10976  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0445BE             10977  ;
0445BE 4E          10978  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0445BF 0C          10979  			INC     C			; This is a way to check for zero without using the accumulator
0445C0 0D          10980  			DEC     C			; If it is zero, then...
0445C1 28 16       10981  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0445C3 09          10982  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0445C4 ED 52       10983  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0445C6 19          10984  			ADD     HL, DE
0445C7 38 F5       10985  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0445C9 ED 42       10986  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
0445CB 23          10987  			INC     HL			; Skip the length counter
0445CC 11 00 00 00 10988  			LD	DE, 0			; Zero DE
0445D0 5E          10989  			LD      E, (HL)          	; Fetch the line number
0445D1 23          10990  			INC     HL
0445D2 56          10991  			LD      D, (HL)
0445D3 EB          10992  			EX      DE, HL			; HL: The line number
0445D4 22 23 03 04 10993  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0445D8 C9          10994  			RET
0445D9             10995  ;
0445D9 21 00 00 00 10996  SET3:			LD      HL, 0			; We've not found the line at this point so
0445DD 18 F5       10997  			JR      SET2			; Set LINENO to 0
0445DF             10998  ;
0445DF             10999  ;SAYLN - PRINT " at line nnnn" MESSAGE.
0445DF             11000  ;  Outputs: Carry=0 if line number is zero.
0445DF             11001  ;           Carry=1 if line number is non-zero.
0445DF             11002  ; Destroys: A,B,C,D,E,H,L,F
0445DF             11003  ;
0445DF 2A 23 03 04 11004  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0445E3 7C          11005  			LD      A,H			; If it is zero then
0445E4 B5          11006  			OR      L
0445E5 C8          11007  			RET     Z			; Don't need to do anything; return with F:C set to 0
0445E6 CD 8D 49 04 11008  			CALL    TELL			; Output the error message
0445EA 20 61 74 20 11009  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
0445F4 0E 00       11010  PBCDL:			LD      C,0			; C: Leading character (NUL)
0445F6 18 02       11011  			JR      PBCD0			; Output the line number; return with F:C set to 1
0445F8             11012  ;
0445F8             11013  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
0445F8             11014  ;   Inputs: HL = number (binary).
0445F8             11015  ;  Outputs: Carry = 1
0445F8             11016  ; Destroys: A,B,C,D,E,H,L,F
0445F8             11017  ;
0445F8 0E 20       11018  PBCD:			LD      C,' '			; C: Leading character (" ")
0445FA 06 05       11019  PBCD0:			LD      B,5			; Number of digits in result
0445FC 11 10 27 00 11020  			LD      DE,10000		; Start off with the 10,000 column
044600 AF          11021  PBCD1:			XOR     A			; Counter
044601 ED 52       11022  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
044603 3C          11023  			INC     A
044604 30 FB       11024  			JR      NC,PBCD2
044606 19          11025  			ADD     HL,DE			; The loop overruns by one, so adjust here
044607 3D          11026  			DEC     A			; A: Number of 10,000s
044608 28 04       11027  			JR      Z,PBCD3			; If it is 0, then skip the next bit
04460A CB E1       11028  			SET     4,C			; C: Set to '0' ASCII (30h)
04460C CB E9       11029  			SET     5,C
04460E B1          11030  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
04460F C4 4C 45 04 11031  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
044613 78          11032  			LD      A,B			; If on first transition, skip this
044614 FE 05       11033  			CP      5			; TODO: Need to find out why
044616 28 06       11034  			JR      Z,PBCD4
044618 29          11035  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
044619 54          11036  			LD      D,H			;         : rather than shifting DE right
04461A 5D          11037  			LD      E,L			;         : This makes a lot of sense
04461B 29          11038  			ADD     HL,HL			; HL x  4
04461C 29          11039  			ADD     HL,HL			; HL x  8
04461D 19          11040  			ADD     HL,DE			; HL x 10
04461E 11 E8 03 00 11041  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
044622 10 DC       11042  			DJNZ    PBCD1			; Loop until done
044624 37          11043  			SCF				; SCF set for SAYLN in this module
044625 C9          11044  			RET
044626             11045  ;
044626             11046  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
044626             11047  ;   Inputs: HL, IY as returned from GETVAR (NZ).
044626             11048  ;  Outputs: As GETVAR.
044626             11049  ; Destroys: everything
044626             11050  ;
044626 CD AB 47 04 11051  PUTVAR:			CALL    CREATE			; Create the variable
04462A FD 7E 00    11052  			LD      A,(IY)			; Fetch the next character
04462D FE 28       11053  			CP      '('			; Check for bad use of array
04462F 20 70       11054  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
044631 3E 0E       11055  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
044633 C3 5D 43 04 11056  ERROR3_main:			JP      ERROR_
044637             11057  ;
044637             11058  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
044637             11059  ;   Inputs: IY addresses first character.
044637             11060  ;  Outputs: Carry set and NZ if illegal character.
044637             11061  ;           Z-flag set if variable found, then:
044637             11062  ;            A = variable type (0,4,5,128 or 129)
044637             11063  ;            HL = IX = variable pointer.
044637             11064  ;            IY updated
044637             11065  ;           If Z-flag & carry reset, then:
044637             11066  ;            HL, IY set for subsequent PUTVAR call.
044637             11067  ; Destroys: everything
044637             11068  ;
044637 FD 7E 00    11069  GETVAR:			LD      A,(IY)			; Get the first character
04463A FE 24       11070  			CP      '$'			; Is it a string?
04463C 28 69       11071  			JR      Z,GETV4			; Yes, so branch here
04463E FE 21       11072  			CP      '!'			; Is it indirection (32-bit)?
044640 28 69       11073  			JR      Z,GETV5			; Yes, so branch here
044642 FE 3F       11074  			CP      '?'			; Is it indirection (8-bit)?
044644 28 69       11075  			JR      Z,GETV6			; Yes, so branch here
044646             11076  ;
044646 CD 15 47 04 11077  			CALL    LOCATE			; Locate the variable
04464A C0          11078  			RET     NZ			; And exit here if not found
04464B             11079  ;
04464B             11080  ; At this point:
04464B             11081  ;  HL: Address of variable in memory
04464B             11082  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
04464B             11083  ;
04464B FD 7E 00    11084  			LD      A,(IY)			; Further checks
04464E FE 28       11085  			CP      '('             	; Is it an array?
044650 20 47       11086  			JR      NZ,GETVX        	; No, so exit
044652             11087  ;
044652             11088  ; We are processing an array at this point
044652             11089  ;
044652 D5          11090  			PUSH    DE              	; Save the variable type (in D)
044653 7E          11091  			LD      A,(HL)          	; Fetch the number of dimensions
044654 B7          11092  			OR      A
044655 28 DA       11093  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
044657 23          11094  			INC     HL			;
044658 11 00 00 00 11095  			LD      DE,0            	; Accumulator
04465C F5          11096  			PUSH    AF
04465D FD 23       11097  			INC     IY              	; Skip "("
04465F 18 05       11098  			JR      GETV3
044661             11099  ;
044661 F5          11100  GETV2:			PUSH    AF
044662 CD 42 13 04 11101  			CALL    COMMA
044666 E5          11102  GETV3:			PUSH    HL
044667 D5          11103  			PUSH    DE
044668 CD 27 0C 04 11104  			CALL    EXPRI			; Get the subscript
04466C D9          11105  			EXX
04466D D1          11106  			POP     DE
04466E E3          11107  			EX      (SP),HL
04466F 4E          11108  			LD      C,(HL)
044670 23          11109  			INC     HL
044671 46          11110  			LD      B,(HL)
044672 23          11111  			INC     HL
044673 E3          11112  			EX      (SP),HL
044674 EB          11113  			EX      DE,HL
044675 D5          11114  			PUSH    DE
044676 CD BC 21 04 11115  			CALL    MUL16			; HL=HL*BC
04467A D1          11116  			POP     DE
04467B 19          11117  			ADD     HL,DE
04467C EB          11118  			EX      DE,HL
04467D B7          11119  			OR      A
04467E ED 42       11120  			SBC     HL,BC
044680 3E 0F       11121  			LD      A,15
044682 30 AF       11122  			JR      NC,ERROR3_main		; Throw a "Subscript" error
044684 E1          11123  			POP     HL
044685 F1          11124  			POP     AF
044686 3D          11125  			DEC     A               	; Dimension counter
044687 20 D8       11126  			JR      NZ,GETV2
044689 CD 4F 13 04 11127  			CALL    BRAKET          	; Check for closing bracket
04468D F1          11128  			POP     AF              	; Restore the type
04468E E5          11129  			PUSH    HL
04468F CD AF 21 04 11130  			CALL    X4OR5           	; DE=DE*n
044693 E1          11131  			POP     HL
044694 19          11132  			ADD     HL,DE
044695 57          11133  			LD      D,A             	; The type
044696 FD 7E 00    11134  			LD      A,(IY)
044699 FE 3F       11135  GETVX:			CP      '?'
04469B 28 1E       11136  			JR      Z,GETV9
04469D FE 21       11137  			CP      '!'
04469F 28 16       11138  			JR      Z,GETV8
0446A1 E5          11139  GETVZ:			PUSH    HL              	; Set exit conditions
0446A2 DD E1       11140  			POP     IX
0446A4 7A          11141  			LD      A,D
0446A5 BF          11142  			CP      A
0446A6 C9          11143  			RET
0446A7             11144  ;
0446A7             11145  ; Process strings, unary & binary indirection:
0446A7             11146  ;
0446A7 3E 80       11147  GETV4:			LD      A,128           	; Static strings
0446A9 18 05       11148  			JR      GETV7
0446AB             11149  ;
0446AB 3E 04       11150  GETV5:			LD      A,4             	; Unary 32-bit indirection
0446AD 18 01       11151  			JR      GETV7
0446AF             11152  ;
0446AF AF          11153  GETV6:			XOR     A               	; Unary 8-bit indirection
0446B0             11154  ;
0446B0 21 00 00 00 11155  GETV7:			LD      HL,0
0446B4 F5          11156  			PUSH    AF
0446B5 18 24       11157  			JR      GETV0
0446B7             11158  ;
0446B7 06 04       11159  GETV8:			LD      B,4             	; Binary 32-bt indirection
0446B9 18 02       11160  			JR      GETVA
0446BB             11161  ;
0446BB 06 00       11162  GETV9:			LD      B,0             	; Binary 8-bit indirection
0446BD             11163  ;
0446BD E5          11164  GETVA:			PUSH    HL
0446BE DD E1       11165  			POP     IX
0446C0 7A          11166  			LD      A,D            		; Fetch the variable type
0446C1 FE 81       11167  			CP      129			; Is it a string?
0446C3 C8          11168  			RET     Z               	; Yes, so exit here
0446C4 C5          11169  			PUSH    BC
0446C5 CD 33 0D 04 11170  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
0446C9 CD 7F 0F 04 11171  			CALL    SFIX
0446CD 7D          11172  			LD	A,L
0446CE D9          11173  			EXX
0446CF 22 4A 03 04 11174  			LD	(R0+0),HL
0446D3 32 4C 03 04 11175  			LD	(R0+2),A
0446D7 2A 4A 03 04 11176  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
0446DB             11177  ;
0446DB E5          11178  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
0446DC FD 23       11179  			INC     IY
0446DE CD 42 0C 04 11180  			CALL    ITEMI
0446E2 7D          11181  			LD	A,L			;  A: The MSB of the address
0446E3 D9          11182  			EXX
0446E4 22 4A 03 04 11183  			LD	(R0+0),HL		; HL: The LSW of the address
0446E8 32 4C 03 04 11184  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
0446EC D1          11185  			POP     DE
0446ED F1          11186  			POP     AF
0446EE 2A 4A 03 04 11187  			LD	HL,(R0)			; HL: L'HL
0446F2 19          11188  			ADD     HL,DE
0446F3 E5          11189  			PUSH    HL
0446F4 DD E1       11190  			POP     IX
0446F6 BF          11191  			CP      A
0446F7 C9          11192  			RET
0446F8             11193  ;
0446F8             11194  ;GETDEF - Find entry for FN or PROC in dynamic area.
0446F8             11195  ;   Inputs: IY addresses byte following "DEF" token.
0446F8             11196  ;  Outputs: Z flag set if found
0446F8             11197  ;           Carry set if neither FN or PROC first.
0446F8             11198  ;           If Z: HL points to entry
0446F8             11199  ;                 IY addresses delimiter
0446F8             11200  ; Destroys: A,D,E,H,L,IY,F
0446F8             11201  ;
0446F8 FD 7E 01    11202  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
0446FB CD 78 48 04 11203  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
0446FF D8          11204  			RET     C			; No so return with C set
044700 FD 7E 00    11205  			LD      A,(IY)			; Fetch the current character from the tokenised line
044703 21 0E 03 04 11206  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
044707 FE A4       11207  			CP      FN_main			; Is it the token FN_main?
044709 28 4A       11208  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
04470B 21 11 03 04 11209  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
04470F FE F2       11210  			CP      PROC_main			; Is it the token PROC_main?
044711 28 42       11211  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
044713 37          11212  			SCF				; No, so just return with C set
044714 C9          11213  			RET
044715             11214  ;
044715             11215  ; LOCATE - Try to locate variable name in static or dynamic variables.
044715             11216  ; If illegal first character return carry, non-zero.
044715             11217  ; If found, return no-carry, zero.
044715             11218  ; If not found, return no-carry, non-zero.
044715             11219  ;   Inputs: IY=Addresses first character of name.
044715             11220  ;            A=(IY)
044715             11221  ;  Outputs:  F=Z set if found, then:
044715             11222  ;           IY=addresses terminator
044715             11223  ;           HL=addresses location of variable
044715             11224  ;            D=type of variable: 4 = integer
044715             11225  ;                                5 = floating point
044715             11226  ;                              129 = string
044715             11227  ; Destroys: A,D,E,H,L,IY,F
044715             11228  ;
044715             11229  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
044715             11230  ; They can contain any alphanumeric character and underscore (_)
044715             11231  ; String variables are postfixed with the dollar ($) character
044715             11232  ; Integer variables are postfixed with the percent (%) character
044715             11233  ; Static integer variables are named @%, A% to Z%
044715             11234  ; All other variables are dynamic
044715             11235  ;
044715 D6 40       11236  LOCATE:			SUB     '@'			; Check for valid range
044717 D8          11237  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
044718 21 00 00 00 11238  			LD      HL, 0			; Clear HL
04471C FE 1B       11239  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
04471E 30 1E       11240  			JR      NC,LOC0         	; Then branch here
044720 6F          11241  			LD	L, A			; HL = A
044721 FD 7E 01    11242  			LD      A,(IY+1)        	; Check the 2nd character
044724 FE 25       11243  			CP      '%'			; If not "%" then it is not static...
044726 20 21       11244  			JR      NZ,LOC1         	; Branch here
044728 FD 7E 02    11245  			LD      A,(IY+2)		; Check the 3rd character
04472B FE 28       11246  			CP      '('			; If it is "(" (array) then it is not static...
04472D 28 1A       11247  			JR      Z,LOC1          	; Branch here
04472F             11248  ;
04472F             11249  ; At this point we're dealing with a static variable
04472F             11250  ;
04472F 29          11251  			ADD     HL,HL			; HL: Variable index * 4
044730 29          11252  			ADD	HL,HL
044731 11 00 02 04 11253  			LD      DE,STAVAR       	; The static variable area in memory
044735 19          11254  			ADD     HL,DE			; HL: The address of the static variable
044736 FD 23       11255  			INC     IY			; Skip the program pointer past the static variable name
044738 FD 23       11256  			INC     IY
04473A 16 04       11257  			LD      D,4             	; Set the type to be integer
04473C AF          11258  			XOR     A			; Set the Z flag
04473D C9          11259  			RET
04473E             11260  ;
04473E             11261  ; At this point it's potentially a dynamic variable, just need to do a few more checks
04473E             11262  ;
04473E FE 1F       11263  LOC0:			CP      '_'-'@'			; Check the first character is in
044740 D8          11264  			RET     C			; the range "_" to
044741 FE 3B       11265  			CP      'z'-'@'+1		; "z" (lowercase characters only)
044743 3F          11266  			CCF				; If it is not in range then
044744 3D          11267  			DEC     A               	; Set NZ flag and
044745 D8          11268  			RET     C			; Exit here
044746 D6 03       11269  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
044748 6F          11270  			LD	L, A			; HL = A
044749             11271  ;
044749             11272  ; Yes, it's definitely a dynamic variable at this point...
044749             11273  ;
044749 7D          11274  LOC1:			LD	A, L			; Fetch variable index
04474A 87          11275  			ADD	A, A			; x 2
04474B 85          11276  			ADD	A, L			; x 3
04474C D6 03       11277  			SUB	3			; Subtract 2 TODO: Should be 3
04474E 6F          11278  			LD	L, A
04474F 11 6C 02 04 11279  			LD      DE, DYNVAR       	; The dynamic variable storage
044753 D8          11280  			RET	C			; Bounds check to trap for variable '@'
044754 19          11281  			ADD     HL, DE			; HL: Address of first entry
044755             11282  ;
044755             11283  ; Loop through the linked list of variables to find a match
044755             11284  ;
044755 ED 17       11285  LOC2:			LD	DE, (HL)		; Fetch the original pointer
044757 E5          11286  			PUSH	HL			; Need to preserve HL for LOC6
044758 AF          11287  			XOR	A			; Reset carry flag
044759 ED 62       11288  			SBC	HL, HL			; Set HL to 0
04475B ED 52       11289  			SBC	HL, DE			; Compare with 0
04475D E1          11290  			POP	HL			; Restore the original pointer
04475E 28 49       11291  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
044760             11292  			; LD	HL, DE			; Make a copy of this pointer in HL
044760 D5          11293  			push de ; HOW DID THE ABOVE EVEN ASSEMBLE IN THE ORIGINAL?!
044761 E1          11294  			pop hl	; Make a copy of this pointer in HL
044762 23          11295  			INC     HL              	; Skip the link (24-bits)
044763 23          11296  			INC     HL
044764 23          11297  			INC	HL			; HL: Address of the variable name in DYNVARS
044765 FD E5       11298  			PUSH    IY			; IY: Address of the variable name in the program
044767             11299  ;
044767 7E          11300  LOC3:			LD      A,(HL)         		; Compare
044768 23          11301  			INC     HL
044769 FD 23       11302  			INC     IY
04476B FD BE 00    11303  			CP      (IY)
04476E 28 F7       11304  			JR      Z, LOC3			; Keep looping whilst we've got a match...
044770 B7          11305  			OR      A               	; Have we hit a terminator?
044771 28 07       11306  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
044773             11307  ;
044773 FD E1       11308  LOC4:			POP     IY			; Restore the pointer in the program
044775 EB          11309  			EX      DE, HL			; HL: New pointer in DYNVARS
044776 C3 55 47 04 11310  			JP      LOC2            	; Loop round and try again
04477A             11311  ;
04477A             11312  ; We might have located a variable at this point, just need to do a few more tests
04477A             11313  ;
04477A FD 2B       11314  LOC5:			DEC     IY
04477C FD 7E 00    11315  			LD      A,(IY)
04477F FE 28       11316  			CP      '('
044781 28 15       11317  			JR      Z,LOC5A         	; FOUND
044783 FD 23       11318  			INC     IY
044785 CD 6C 48 04 11319  			CALL    RANGE
044789 38 0D       11320  			JR      C,LOC5A         	; FOUND
04478B FE 28       11321  			CP      '('
04478D 28 E4       11322  			JR      Z,LOC4          	; KEEP LOOKING
04478F FD 7E FF    11323  			LD      A,(IY-1)
044792 CD 78 48 04 11324  			CALL    RANGE1
044796 30 DB       11325  			JR      NC,LOC4         	; KEEP LOOKING
044798 D1          11326  LOC5A:			POP     DE
044799 FD 7E FF    11327  TYPE__main:			LD      A,(IY-1)		; Check the string type postfix
04479C FE 24       11328  			CP      '$'			; Is it a string?
04479E 16 81       11329  			LD      D,129			; Yes, so return D = 129
0447A0 C8          11330  			RET     Z
0447A1 FE 25       11331  			CP      '%'			; Is it an integer?
0447A3 16 04       11332  			LD      D,4			; Yes, so return D = 4
0447A5 C8          11333  			RET     Z
0447A6 14          11334  			INC     D			; At this point it must be a float
0447A7 BF          11335  			CP      A			; Set the flags
0447A8 C9          11336  			RET
0447A9             11337  ;
0447A9             11338  ; The variable is undefined at this point; HL will be zero
0447A9             11339  ;
0447A9 3C          11340  LOC6:			INC     A               	; Set NZ flag
0447AA C9          11341  			RET
0447AB             11342  ;
0447AB             11343  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
0447AB             11344  ;   Inputs: HL, IY as returned from LOCATE (NZ).
0447AB             11345  ;  Outputs: As LOCATE, GETDEF.
0447AB             11346  ; Destroys: As LOCATE, GETDEF.
0447AB             11347  ;
0447AB AF          11348  CREATE:			XOR     A
0447AC ED 5B 1D 03 11349  			LD      DE,(FREE)		; Get the last byte of available RAM
       04          
0447B1 ED 1F       11350  			LD	(HL), DE		; Store
0447B3 EB          11351  			EX      DE,HL
0447B4 77          11352  			LD      (HL),A			; Clear the link of the new entity
0447B5 23          11353  			INC     HL
0447B6 77          11354  			LD      (HL),A
0447B7 23          11355  			INC     HL
0447B8 77          11356  			LD      (HL),A
0447B9 23          11357  			INC     HL
0447BA FD 23       11358  LOC7:			INC     IY
0447BC CD 6C 48 04 11359  			CALL    RANGE           	; END OF VARIABLE?
0447C0 38 15       11360  			JR      C,LOC8
0447C2 77          11361  			LD      (HL),A
0447C3 23          11362  			INC     HL
0447C4 CD 78 48 04 11363  			CALL    RANGE1
0447C8 30 F0       11364  			JR      NC,LOC7
0447CA FE 28       11365  			CP      '('
0447CC 28 09       11366  			JR      Z,LOC8
0447CE FD 7E 01    11367  			LD      A,(IY+1)
0447D1 FE 28       11368  			CP      '('
0447D3 28 E5       11369  			JR      Z,LOC7
0447D5 FD 23       11370  			INC     IY
0447D7 36 00       11371  LOC8:			LD      (HL),0          	; TERMINATOR
0447D9 23          11372  			INC     HL
0447DA E5          11373  			PUSH    HL
0447DB CD 99 47 04 11374  			CALL    TYPE__main			; Get the variable type in D
0447DF 3E 04       11375  			LD      A,4			; If it is an integer then it takes up 4 bytes
0447E1 BA          11376  			CP      D
0447E2 28 01       11377  			JR      Z,LOC9			; So skip the next bit
0447E4 3C          11378  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0447E5 36 00       11379  LOC9:			LD      (HL),0          	; Initialise the memory to zero
0447E7 23          11380  			INC     HL
0447E8 3D          11381  			DEC     A
0447E9 20 FA       11382  			JR      NZ,LOC9
0447EB 22 1D 03 04 11383  			LD      (FREE),HL		; Adjust the stack
0447EF CD 99 1F 04 11384  			CALL    CHECK			; Check whether we are out of space
0447F3 E1          11385  			POP     HL
0447F4 AF          11386  			XOR     A
0447F5 C9          11387  			RET
0447F6             11388  ;
0447F6             11389  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
0447F6             11390  ;   Inputs: IY = Text Pointer
0447F6             11391  ;  Outputs: HL = Line number (zero if none)
0447F6             11392  ;           IY updated
0447F6             11393  ; Destroys: A,D,E,H,L,IY,F
0447F6             11394  ;
0447F6             11395  ; This bit of code performs a BASE 10 shift to build up the number
0447F6             11396  ; So if the string passed is "345", the algorithm does this:
0447F6             11397  ;
0447F6             11398  ;    HL : Digit	: Operation
0447F6             11399  ; ----- : ----- : ---------
0447F6             11400  ; 00000 :	:
0447F6             11401  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
0447F6             11402  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
0447F6             11403  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
0447F6             11404  ;
0447F6             11405  ; The multiply by 10 is done by an unrolled shift and add loop
0447F6             11406  ;
0447F6 CD 90 13 04 11407  LINNUM:			CALL    NXT			; Skip whitespace to the first character
0447FA 40 21 00 00 11408  			LD.SIS  HL,0			; The running total
0447FE FD 7E 00    11409  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
044801 D6 30       11410  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
044803 D8          11411  			RET     C			; And return if less than 0
044804 FE 0A       11412  			CP      10			; Or greater than or equal to 10
044806 D0          11413  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
044807 FD 23       11414  			INC     IY			; Increment the string pointer
044809 54          11415  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
04480A 5D          11416  			LD      E,L			; Store the original number in DE
04480B 52 29       11417  			ADD.S   HL,HL           	; *2
04480D 38 13       11418  			JR      C,TOOBIG_main		; At each point, error if > 65535 (carry flag set)
04480F 52 29       11419  			ADD.S   HL,HL           	; *4S
044811 38 0F       11420  			JR      C,TOOBIG_main
044813 52 19       11421  			ADD.S   HL,DE           	; *5
044815 38 0B       11422  			JR      C,TOOBIG_main
044817 52 29       11423  			ADD.S   HL,HL           	; *10
044819 38 07       11424  			JR      C,TOOBIG_main
04481B 5F          11425  			LD      E,A			; A->DE: the digit to add in
04481C 16 00       11426  			LD      D,0
04481E 52 19       11427  			ADD.S   HL,DE           	; Add in the digit to the running total
044820 30 DC       11428  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
044822             11429  ;
044822 3E 14       11430  TOOBIG_main:			LD      A,20
044824 C3 5D 43 04 11431  			JP      ERROR_           	; Error: "Too big"
044828             11432  ;
044828             11433  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
044828             11434  ;   Inputs: IY = text pointer
044828             11435  ;  Outputs: HL = first number (10 by default)
044828             11436  ;           BC = second number (10 by default)
044828             11437  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
044828             11438  ;
044828 CD F6 47 04 11439  PAIR_main:			CALL    LINNUM          	; Parse the first line number
04482C 7C          11440  			LD      A,H			; If it is not zero, then...
04482D B5          11441  			OR      L
04482E 20 02       11442  			JR      NZ,PAIR1_main		; Skip...
044830 2E 0A       11443  			LD      L,10			; HL: the default value (10)
044832             11444  ;
044832 CD C4 20 04 11445  PAIR1_main:			CALL    TERMQ			; Check for ELSE, : or CR
044836 FD 23       11446  			INC     IY			; Skip to next character
044838 E5          11447  			PUSH    HL			; Stack the first line number
044839 21 0A 00 00 11448  			LD      HL,10			; HL: the second default (10)
04483D C4 F6 47 04 11449  			CALL    NZ,LINNUM       	; Parse the second line number
044841 E3          11450  			EX      (SP),HL			; HL: The first line number (off the stack)
044842 C1          11451  			POP     BC			; BC: Second line number
044843 78          11452  			LD      A,B			; If the second line number is not zero then...
044844 B1          11453  			OR      C			; We're good...
044845 C0          11454  			RET     NZ			; Exit, otherwise...
044846 CD 74 43 04 11455  			CALL    EXTERR			; Throw error: "Silly"
04484A 53 69 6C 6C 11456  			DB    	"Silly", 0
       79 00       
044850             11457  ;
044850             11458  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
044850             11459  ;   Inputs: IY = text pointer
044850             11460  ;  Outputs: HL = points to program text
044850             11461  ;           BC = second number (0 by default)
044850             11462  ; Destroys: A,B,C,D,E,H,L,IY,F
044850             11463  ;
044850 CD F6 47 04 11464  DLPAIR:			CALL    LINNUM			; Parse the first line number
044854 E5          11465  			PUSH    HL			; Stack it
044855 CD C4 20 04 11466  			CALL    TERMQ			; Check for ELSE, : or CR
044859 28 0A       11467  			JR      Z,DLP1			; And exit if so
04485B FE E7       11468  			CP      TIF			; Is the token IF?
04485D 28 06       11469  			JR      Z,DLP1			; Yes, so skip the next bit...
04485F FD 23       11470  			INC     IY			; Otherwise...
044861 CD F6 47 04 11471  			CALL    LINNUM			; Fetch the second line number
044865 E3          11472  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
044866 CD 8C 45 04 11473  			CALL    FINDL			; HL: Find the address of the line
04486A C1          11474  			POP     BC			; BC: The second number
04486B C9          11475  			RET
04486C             11476  ;
04486C             11477  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
04486C             11478  ;   Inputs: IY addresses character
04486C             11479  ;  Outputs: Carry set if out-of-range.
04486C             11480  ; Destroys: A,F
04486C             11481  ;
04486C             11482  ; It is called here to check the following
04486C             11483  ; In range: "$", "%" and "("
04486C             11484  ;   Plus all characters in RANGE1 and RANGE2
04486C             11485  ;
04486C FD 7E 00    11486  RANGE:			LD      A,(IY)			; Fetch the character
04486F FE 24       11487  			CP      '$'			; Postfix for string variable is valid
044871 C8          11488  			RET     Z
044872 FE 25       11489  			CP      '%'			; Postfix for integer variable is valid
044874 C8          11490  			RET     Z
044875 FE 28       11491  			CP      '('			; Postfix for array is valid
044877 C8          11492  			RET     Z
044878             11493  ;
044878             11494  ; It is called here to check the following
044878             11495  ; In range: "0" to "9" and "@"
044878             11496  ;   Plus all characters in RANGE2
044878             11497  ;
044878 FE 30       11498  RANGE1:			CP      '0'			; If it is between '0'...
04487A D8          11499  			RET     C
04487B FE 3A       11500  			CP      '9'+1			; And '9'...
04487D 3F          11501  			CCF
04487E D0          11502  			RET     NC			; Then it is valid
04487F FE 40       11503  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
044881 C8          11504  			RET     Z
044882             11505  ;
044882             11506  ; It is called here to check the following
044882             11507  ; In range: "A" to "Z", "a' to "z", "_" and "`"
044882             11508  ;
044882 FE 41       11509  RANGE2:			CP      'A'			; If it is between 'A'...
044884 D8          11510  			RET     C
044885 FE 5B       11511  			CP      'Z'+1			; And 'Z'...
044887 3F          11512  			CCF
044888 D0          11513  			RET     NC			; Then it is valid
044889 FE 5F       11514  			CP      '_'			; If it is underscore, grave, or between 'a'
04488B D8          11515  			RET     C
04488C FE 7B       11516  			CP      'z'+1			; And 'z'
04488E 3F          11517  			CCF				; Then it is valid
04488F C9          11518  			RET
044890             11519  ;
044890             11520  ; Throw a 'LINE space' error (line too long)
044890             11521  ; This is called from LEXAN
044890             11522  ;
044890 AF          11523  SPACE_: 		XOR     A
044891 CD 74 43 04 11524  			CALL    EXTERR          	; "LINE space"
044895 86 08 00    11525  			DB    	LINE__main, 8, 0
044898             11526  ;
044898             11527  ; LEXAN - LEXICAL ANALYSIS.
044898             11528  ;  Bit 0,C: 1=left, 0=right
044898             11529  ;  Bit 2,C: 1=in BINARY
044898             11530  ;  Bit 3,C: 1=in HEX
044898             11531  ;  Bit 4,C: 1=accept line number
044898             11532  ;  Bit 5,C: 1=in variable, FN, PROC
044898             11533  ;  Bit 6,C: 1=in REM, DATA, *
044898             11534  ;  Bit 7,C: 1=in quotes
044898             11535  ;   Inputs: IY addresses source string
044898             11536  ;           DE addresses destination string (must be page boundary)
044898             11537  ;            C sets initial mode
044898             11538  ;  Outputs: DE, IY updated
044898             11539  ;            A holds carriage return
044898             11540  ;
044898 12          11541  LEXAN1:			LD      (DE),A          	; Transfer to buffer
044899 13          11542  			INC     DE              	; Increment the pointers
04489A FD 23       11543  			INC     IY			; And fall through to the main function
04489C             11544  ;
04489C             11545  ; This is the main entry point
04489C             11546  ;
04489C 7B          11547  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
04489D FE FC       11548  			CP      252             	; If it is >= 252 bytes, then...
04489F 30 EF       11549  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0448A1 FD 7E 00    11550  			LD      A,(IY)			; Fetch character from source string
0448A4 FE 0D       11551  			CP      CR			; If it is a CR
0448A6 C8          11552  			RET     Z               	; Then it is end of line; we're done parsing
0448A7 CD 78 48 04 11553  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0448AB 30 06       11554  			JR      NC,LEXAN3		; Yes, so skip
0448AD CB A9       11555  			RES     5,C             	; FLAG: NOT IN VARIABLE
0448AF CB 99       11556  			RES     3,C             	; FLAG: NOT IN HEX
0448B1 CB 91       11557  			RES	2,C			; FLAG: NOT IN BINARY
0448B3             11558  ;
0448B3 FE 20       11559  LEXAN3:			CP      ' '			; Ignore spaces
0448B5 28 E1       11560  			JR      Z,LEXAN1
0448B7 FE 2C       11561  			CP      ','			; Ignore commas
0448B9 28 DD       11562  			JR      Z,LEXAN1
0448BB FE 32       11563  			CP	'2'			; If less than '2'
0448BD 30 02       11564  			JR	NC, @F			; No, so skip
0448BF CB 91       11565  			RES	2,C			; FLAG: NOT IN BINARY
0448C1 FE 47       11566  @@:			CP      'G'			; If less then 'G'
0448C3 38 02       11567  			JR      C,LEXAN4		; Yes, so skip
0448C5 CB 99       11568  			RES     3,C             	; FLAG: NOT IN HEX
0448C7             11569  ;
0448C7 FE 22       11570  LEXAN4:			CP      34			; Is it a quote character?
0448C9 20 05       11571  			JR      NZ,LEXAN5		; No, so skip
0448CB CB 11       11572  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
0448CD 3F          11573  			CCF                     	; Toggle the carry
0448CE CB 19       11574  			RR      C			; And then shifting it back into bit 7 of C
0448D0             11575  ;
0448D0 CB 61       11576  LEXAN5:			BIT     4,C			; Accept line number?
0448D2 28 12       11577  			JR      Z,LEXAN6		; No, so skip
0448D4 CB A1       11578  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
0448D6 C5          11579  			PUSH    BC
0448D7 D5          11580  			PUSH    DE
0448D8 CD F6 47 04 11581  			CALL    LINNUM         		; Parse the line number to HL
0448DC D1          11582  			POP     DE
0448DD C1          11583  			POP     BC
0448DE 7C          11584  			LD      A,H			; If it is not zero
0448DF B5          11585  			OR      L
0448E0 C4 59 49 04 11586  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
0448E4 18 B6       11587  			JR      LEXAN2          	; And loop
0448E6             11588  ;
0448E6 0D          11589  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0448E7 28 0A       11590  			JR      Z,LEXAN7        	; If so, skip
0448E9 0C          11591  			INC     C			; Otherwise restore C
0448EA 20 AC       11592  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0448EC B7          11593  			OR      A			; Set the flags based on the character
0448ED F4 C4 43 04 11594  			CALL    P,LEX           	; Tokenise if A < 128
0448F1 18 13       11595  			JR      LEXAN8			; And skip
0448F3             11596  ;
0448F3             11597  ; Processing the LEFT hand side here
0448F3             11598  ;
0448F3 FE 2A       11599  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0448F5 28 17       11600  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0448F7 B7          11601  			OR      A			; Set the flags based on the character
0448F8 F4 C4 43 04 11602  			CALL    P,LEX           	; Tokenise if A < 128
0448FC             11603  ;
0448FC             11604  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
0448FC             11605  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
0448FC             11606  ; Examples:
0448FC             11607  ;   LET A% = PAGE : REM This is the GET version
0448FC             11608  ;   PAGE = 40000  : REM This is the SET version
0448FC             11609  ;
0448FC FE 8F       11610  			CP      TOKLO			; TOKLO is 8Fh
0448FE 38 06       11611  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
044900 FE 94       11612  			CP      TOKHI+1			; TOKHI is 93h
044902 30 02       11613  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
044904 C6 40       11614  			ADD     A,OFFSET_main       		; Add OFFSET_main (40h) to make the token the SET version
044906             11615  ;
044906 FE F4       11616  LEXAN8:			CP      REM_main			; If the token is REM_main
044908 28 04       11617  			JR      Z,LEXAN9		; Then stop tokenising
04490A FE DC       11618  			CP      DATA__main			; If it is not DATA then
04490C 20 02       11619  			JR      NZ,LEXANA		; Skip
04490E CB F1       11620  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
044910             11621  ;
044910 FE A4       11622  LEXANA:			CP      FN_main			; If the token is FN_main
044912 28 0A       11623  			JR      Z,LEXANB
044914 FE F2       11624  			CP      PROC_main			; Or the token is PROC_main
044916 28 06       11625  			JR      Z,LEXANB		; Then jump to here
044918 CD 82 48 04 11626  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
04491C 38 02       11627  			JR      C,LEXANC		; Jump here if out of range
04491E             11628  ;
04491E CB E9       11629  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN_main/PROC_main
044920 FE 26       11630  LEXANC:			CP      '&'			; Check for hex prefix
044922 20 02       11631  			JR      NZ,LEXAND		; If not, skip
044924 CB D9       11632  			SET     3,C             	; FLAG: IN HEX
044926             11633  ;
044926 FE 25       11634  LEXAND:			CP	'%'			; Check for binary prefix
044928 20 02       11635  			JR	NZ,LEXANE		; If not, skip
04492A CB D1       11636  			SET	2,C			; FLAG: IN BINARY
04492C             11637  ;
04492C 21 50 49 04 11638  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
044930 C5          11639  			PUSH    BC
044931 01 06 00 00 11640  			LD      BC,LIST1L		; The list length
044935 ED B1       11641  			CPIR				; Check if the token is in this list
044937 C1          11642  			POP     BC
044938 20 02       11643  			JR      NZ,LEXANF		; If not, then skip
04493A CB E1       11644  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
04493C             11645  ;
04493C 21 54 49 04 11646  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
044940 C5          11647  			PUSH    BC
044941 01 05 00 00 11648  			LD      BC,LIST2L		; The list length
044945 ED B1       11649  			CPIR				; Check if the token is in this list
044947 C1          11650  			POP     BC
044948 20 02       11651  			JR      NZ,LEXANG		; If not, then skip
04494A CB C1       11652  			SET     0,C             	; FLAG: ENTER LEFT MODE
04494C C3 98 48 04 11653  LEXANG:			JP      LEXAN1			; And loop
044950             11654  
044950             11655  ;
044950             11656  ; LIST1: List of tokens that must be followed by line numbers
044950             11657  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
044950             11658  ;
044950 E5          11659  LIST1:			DB	GOTO_main
044951 E4          11660  			DB	GOSUB_main
044952 F7          11661  			DB	RESTOR_main
044953 FC          11662  			DB	TRACE_main
044954 8C          11663  LIST2:			DB	THEN_main
044955 8B          11664  			DB	ELSE__main
044956             11665  LIST1L:			EQU     $-LIST1
044956 F5          11666  			DB	REPEAT_main
044957 85          11667  			DB	TERROR_main
044958 3A          11668  			DB    	':'
044959             11669  LIST2L:			EQU     $-LIST2
044959             11670  ;
044959             11671  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
044959             11672  ;   Inputs: HL=line number, DE=string pointer
044959             11673  ;  Outputs: DE updated, BIT 4,C set.
044959             11674  ; Destroys: A,B,C,D,E,F
044959             11675  ;
044959             11676  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
044959             11677  ;
044959             11678  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
044959             11679  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
044959             11680  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
044959             11681  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
044959             11682  ; each byte are then stored, in LO/HI order, ORred with 0x40.
044959             11683  ;
044959 CB E1       11684  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
04495B EB          11685  			EX      DE, HL			; HL: string pointer, DE: line number
04495C 36 8D       11686  			LD      (HL), LINO_main		; Store 8Dh first to flag next bytes as an encoded line number
04495E 23          11687  			INC     HL
04495F 7A          11688  			LD      A,D			; Get the high byte
044960 E6 C0       11689  			AND     0C0H			; Get the top two bits	DD000000
044962 0F          11690  			RRCA				; Shift right		00DD0000
044963 0F          11691  			RRCA
044964 47          11692  			LD      B,A			; Store in B
044965 7B          11693  			LD      A,E			; Get the low byte
044966 E6 C0       11694  			AND     0C0H			; Get the top two bits	EE000000
044968 B0          11695  			OR      B			; Combine with D	EEDD0000
044969 0F          11696  			RRCA				; Shift right		00EEDD00
04496A 0F          11697  			RRCA
04496B EE 54       11698  			XOR     01010100B		; XOR with 54h
04496D 77          11699  			LD      (HL),A			; Store this as the second byte
04496E 23          11700  			INC     HL
04496F 7B          11701  			LD      A,E			; Get the low byte
044970 E6 3F       11702  			AND     3FH			; Strip the top two bits off
044972 F6 40       11703  			OR      '@'			; OR with 40h
044974 77          11704  			LD      (HL),A			; Store
044975 23          11705  			INC     HL
044976 7A          11706  			LD      A,D			; Get the high byte
044977 E6 3F       11707  			AND     3FH			; Strip the top two bits off
044979 F6 40       11708  			OR      '@'			; OR with 40h
04497B 77          11709  			LD      (HL),A			; Store
04497C 23          11710  			INC     HL
04497D EB          11711  			EX      DE,HL			; DE: string pointer, HL: line number
04497E C9          11712  			RET
04497F             11713  ;
04497F             11714  ; TEXT - OUTPUT MESSAGE.
04497F             11715  ;   Inputs: HL addresses text (terminated by nul)
04497F             11716  ;  Outputs: HL addresses character following nul.
04497F             11717  ; Destroys: A,H,L,F
04497F             11718  ;
04497F 2A 2F 03 04 11719  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
044983             11720  ;
044983 7E          11721  TEXT_:			LD      A, (HL)			; Fetch the character
044984 23          11722  			INC     HL			; Increment pointer to next character
044985 B7          11723  			OR      A			; Check for the nul (0) string terminator
044986 C8          11724  			RET     Z			; And return if so
044987 CD 69 45 04 11725  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
04498B 18 F6       11726  			JR      TEXT_			; And loop
04498D             11727  ;
04498D             11728  ; TELL - OUTPUT MESSAGE.
04498D             11729  ;   Inputs: Text follows subroutine call (term=nul)
04498D             11730  ; Destroys: A,F
04498D             11731  ;
04498D             11732  ; Example usage:
04498D             11733  ;
04498D             11734  ;	CALL	TELL			Call the function
04498D             11735  ;	DB	"Hello World", 0	Followed by a zero terminated string
04498D             11736  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
04498D             11737  ;
04498D E3          11738  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
04498E CD 83 49 04 11739  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
044992 E3          11740  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
044993 C9          11741  			RET				; at this point we'll return to the first instruction after the message
