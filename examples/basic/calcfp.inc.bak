; INCLUDES FOR CALCFP

; MACROS WE NEED

; from eval.asm
;HEXSTR - convert numeric value to HEX string.
;   Inputs: HLH'L'C = integer or floating-point number
;  Outputs: String in string accumulator.
;           E = string length.  D = ACCS/256
;
HEXSTS:			INC     IY              ;SKIP TILDE
			CALL    ITEMN
			CALL    HEXSTR
			LD      A,80H
			RET
;
HEXSTR:			CALL    SFIX
			LD      BC,8
			LD      DE,ACCS
HEXST1:			PUSH    BC
			LD      B,4
			XOR     A
HEXST2:			EXX
			ADD.S	HL,HL
			EXX
			ADC.S	HL,HL
			RLA
			DJNZ    HEXST2
			POP     BC
			DEC     C
			RET     M
			JR      Z,HEXST3
			OR      A
			JR      NZ,HEXST3
			CP      B
			JR      Z,HEXST1
HEXST3:			ADD     A,90H
			DAA
			ADC     A,40H
			DAA
			LD      (DE),A
			INC     DE
			LD      B,A
			JR      HEXST1

; =================================================================================================
; from fpp.asm
; -------------------------------------------------------------------------------------------------
;
; Title:	BBC Basic Interpreter - Z80 version
;		Z80 Floating Point Package
; Author:	(C) Copyright  R.T.Russell  1986
; Modified By:	Dean Belfield
; Created:	03/05/2022
; Last Updated:	07/06/2023
;
; Modinfo:
; 26/10/1986:	Version 0.0
; 14/12/1988:	Vesion 0.1 (Bug Fix)
; 12/05/2023:	Modified by Dean Belfield
; 07/06/2023:	Modified to run in ADL mode

			.ASSUME	ADL = 1

			; SEGMENT CODE
				
			; XDEF	FPP
			; XDEF	DLOAD5
			; XDEF	DLOAD5_SPL			
;
;BINARY FLOATING POINT REPRESENTATION:
;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
;    8 BIT EXCESS-128 SIGNED EXPONENT
;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
;
;BINARY INTEGER REPRESENTATION:
;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
;
;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
;                            EXPONENT - C
;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
;                               EXPONENT - B

;
;Error codes:
;

BADOP:			EQU     1               ;Bad operation code
DIVBY0:			EQU     18              ;Division by zero
TOOBIG:			EQU     20              ;Too big
NGROOT:			EQU     21              ;Negative root
LOGRNG:			EQU     22              ;Log range
ACLOST:			EQU     23              ;Accuracy lost
EXPRNG:			EQU     24              ;Exp range
;
;Call entry and despatch code:
;
FPP:			PUSH    IY              ;Save IY
        		LD      IY,0
        		ADD     IY,SP           ;Save SP in IY
        		CALL    OP              ;Perform operation
        		CP      A               ;Good return (Z, NC)
EXIT_:			POP     IY              ;Restore IY
        		RET                     ;Return to caller
;
;Error exit:
;
BAD:			LD      A,BADOP         ;"Bad operation code"
ERROR__FPP:			LD      SP,IY           ;Restore SP from IY
        		OR      A               ;Set NZ
        		SCF                     ;Set C
        		JR      EXIT_
;
;Perform operation or function:
;
OP:			CP      RTABLE-DTABLE/3
        		JR      NC,BAD
        		CP      FTABLE-DTABLE/3
        		JR      NC,DISPAT
        		EX      AF,AF'
        		LD      A,B
        		OR      C               ;Both integer?
        		CALL    NZ,FLOATA       ;No, so float both
        		EX      AF,AF'
DISPAT:			PUSH    HL
        		LD      HL,DTABLE
        		PUSH    BC
			LD	BC, 3		; C = 3
			LD	B, A 		; B = op-code
			MLT 	BC 		;BC = op-code * 3
			ADD	HL, BC 		;Add to table base 
			LD	HL, (HL)	;Get the routine address (24-bit)

;        		ADD     A, A            ;A = op-code * 2
;        		LD      C,A
;        		LD      B,0             ;BC = op-code * 2
;        		ADD     HL,BC
;        		LD      A,(HL)          ;Get low byte
;        		INC     HL
;        		LD      H,(HL)          ;Get high byte
;        		LD      L,A

        		POP     BC
        		EX      (SP),HL
        		RET                     ;Off to routine
;
;Despatch table:
;
DTABLE:			DW24  IAND            ;AND (INTEGER)
        		DW24  IBDIV           ;DIV
        		DW24  IEOR            ;EOR
        		DW24  IMOD            ;MOD
        		DW24  IOR             ;OR
        		DW24  ILE             ;<=
        		DW24  INE             ;<>
        		DW24  IGE             ;>=
        		DW24  ILT             ;<
        		DW24  IEQ             ;=
        		DW24  IMUL            ;*
        		DW24  IADD            ;+
        		DW24  IGT             ;>
        		DW24  ISUB            ;-
        		DW24  IPOW            ;^
        		DW24  IDIV            ;/
;
FTABLE:			DW24  ABSV            ;ABS
        		DW24  ACS             ;ACS
        		DW24  ASN             ;ASN
        		DW24  ATN             ;ATN
        		DW24  COS             ;COS
        		DW24  DEG             ;DEG
        		DW24  EXP             ;EXP
        		DW24  INT_            ;INT
        		DW24  LN              ;LN
        		DW24  LOG             ;LOG
        		DW24  NOTK            ;NOT
        		DW24  RAD             ;RAD
        		DW24  SGN             ;SGN
        		DW24  SIN             ;SIN
        		DW24  SQR             ;SQR
        		DW24  TAN             ;TAN
;
		        DW24  ZERO            ;ZERO
        		DW24  FONE            ;FONE
        		DW24  TRUE            ;TRUE
        		DW24  PI              ;PI
;
		        DW24  VAL             ;VAL
        		DW24  STR             ;STR$
;
        		DW24  SFIX            ;FIX
        		DW24  SFLOAT          ;FLOAT
;
		        DW24  FTEST           ;TEST
        		DW24  FCOMP           ;COMPARE
;
RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
        		DW24  FBDIV           ;DIV
        		DW24  FEOR            ;EOR
        		DW24  FMOD            ;MOD
        		DW24  FOR             ;OR
        		DW24  FLE             ;<= 
        		DW24  FNE             ;<>
        		DW24  FGE             ;>=
        		DW24  FLT             ;<
        		DW24  FEQ             ;=
        		DW24  FMUL            ;*
        		DW24  FADD            ;+
        		DW24  FGT             ;>
        		DW24  FSUB            ;-
        		DW24  FPOW            ;^
        		DW24  FDIV            ;/
;
;       PAGE
;
;ARITHMETIC AND LOGICAL OPERATORS:
;All take two arguments, in HLH'L'C & DED'E'B.
;Output in HLH'L'C
;All registers except IX, IY destroyed.
; (N.B. FPOW destroys IX).
;
;FAND - Floating-point AND.
;IAND - Integer AND.
;
FAND:			CALL    FIX2
IAND:			LD      A,H
        		AND     D
        		LD      H,A
        		LD      A,L
        		AND     E
        		LD      L,A
        		EXX
        		LD      A,H
        		AND     D
        		LD      H,A
        		LD      A,L
        		AND     E
        		LD      L,A
        		EXX
        		RET
;
;FEOR - Floating-point exclusive-OR.
;IEOR - Integer exclusive-OR.
;
FEOR:			CALL    FIX2
IEOR:			LD      A,H
        		XOR     D
        		LD      H,A
        		LD      A,L
        		XOR     E
        		LD      L,A
        		EXX
        		LD      A,H
        		XOR     D
        		LD      H,A
        		LD      A,L
        		XOR     E
        		LD      L,A
        		EXX
        		RET
;
;FOR - Floating-point OR.
;IOR - Integer OR.
;
FOR:			CALL    FIX2
IOR:			LD      A,H
        		OR      D
        		LD      H,A
        		LD      A,L
        		OR      E
        		LD      L,A
        		EXX
        		LD      A,H
        		OR      D
        		LD      H,A
        		LD      A,L
        		OR      E
        		LD      L,A
        		EXX
        		RET
;
;FMOD - Floating-point remainder.
;IMOD - Integer remainder.
;
FMOD:			CALL    FIX2
IMOD:			LD      A,H
        		XOR     D               ;DIV RESULT SIGN
        		BIT     7,H
        		EX      AF,AF'
        		BIT     7,H
        		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
        		CALL    SWAP
        		BIT     7,H
        		CALL    NZ,NEGATE
        		LD      B,H
        		LD      C,L
        		LD      HL,0
        		EXX
        		LD      B,H
        		LD      C,L
        		LD      HL,0
        		LD      A,-33
        		CALL    DIVA            ;DIVIDE
        		EXX
        		LD      C,0             ;INTEGER MARKER
        		EX      AF,AF'
        		RET     Z
        		JP      NEGATE
;
;BDIV - Integer division.
;
FBDIV:			CALL    FIX2
IBDIV:			CALL    IMOD
        		OR      A
        		CALL    SWAP
        		LD      C,0
        		RET     P
        		JP      NEGATE
;
;ISUB - Integer subtraction.
;FSUB - Floating point subtraction with rounding.
;
ISUB:			CALL    SUB_
        		RET     PO
        		CALL    ADD_
        		CALL    FLOAT2
FSUB:			LD      A,D
        		XOR     80H             ;CHANGE SIGN THEN ADD
        		LD      D,A
        		JR      FADD
;
;Reverse subtract.
;
RSUB:			LD      A,H
        		XOR     80H
        		LD      H,A
        		JR      FADD
;
;IADD - Integer addition.
;FADD - Floating point addition with rounding.
;
IADD:			CALL    ADD_
        		RET     PO
        		CALL    SUB_
        		CALL    FLOAT2
FADD:			DEC     B
        		INC     B
        		RET     Z               ;ARG 2 ZERO
        		DEC     C
        		INC     C
        		JP      Z,SWAP          ;ARG 1 ZERO
        		EXX
        		LD      BC,0            ;INITIALISE
        		EXX
        		LD      A,H
        		XOR     D               ;XOR SIGNS
        		PUSH    AF
        		LD      A,B
        		CP      C               ;COMPARE EXPONENTS
        		CALL    C,SWAP          ;MAKE DED'E'B LARGEST
        		LD      A,B
        		SET     7,H             ;IMPLIED 1
        		CALL    NZ,FIX          ;ALIGN
        		POP     AF
        		LD      A,D             ;SIGN OF LARGER
        		SET     7,D             ;IMPLIED 1
        		JP      M,FADD3         ;SIGNS DIFFERENT
        		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
        		CALL    C,DIV2          ;NORMALISE
        		SET     7,H
        		JR      FADD4
;
FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
        		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
        		CALL    FLO48
        		CPL                     ;CHANGE RESULT SIGN
FADD4:			EXX
        		EX      DE,HL
        		LD      HL,8000H
        		OR      A               ;CLEAR CARRY
        		SBC.S   HL,BC
        		EX      DE,HL
        		EXX
        		CALL    Z,ODD           ;ROUND UNBIASSED
        		CALL    C,ADD1          ;ROUND UP
        		CALL    C,INCC
        		RES     7,H
        		DEC     C
        		INC     C
        		JP      Z,ZERO
        		OR      A               ;RESULT SIGNQ
        		RET     P               ;POSITIVE
        		SET     7,H             ;NEGATIVE
        		RET
;
;IDIV - Integer division.
;FDIV - Floating point division with rounding.
;
IDIV:			CALL    FLOAT2
FDIV:			DEC     B               ;TEST FOR ZERO
        		INC     B
        		LD      A,DIVBY0
        		JP      Z,ERROR__FPP         ;"Division by zero"
        		DEC     C               ;TEST FOR ZERO
        		INC     C
        		RET     Z
        		LD      A,H
        		XOR     D               ;CALC. RESULT SIGN
        		EX      AF,AF'          ;SAVE SIGN
        		SET     7,D             ;REPLACE IMPLIED 1's
        		SET     7,H
        		PUSH    BC              ;SAVE EXPONENTS
        		LD      B,D             ;LOAD REGISTERS
        		LD      C,E
        		LD      DE,0
        		EXX
        		LD      B,D
        		LD      C,E
        		LD      DE,0
        		LD      A,-32           ;LOOP COUNTER
        		CALL    DIVA            ;DIVIDE
        		EXX
        		BIT     7,D
        		EXX
        		CALL    Z,DIVB          ;NORMALISE & INC A
        		EX      DE,HL
        		EXX
        		SRL     B               ;DIVISOR/2
        		RR      C
        		OR      A               ;CLEAR CARRY
        		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
        		CCF
        		EX      DE,HL           ;RESULT IN HLH'L'
        		CALL    Z,ODD           ;ROUND UNBIASSED
        		CALL    C,ADD1          ;ROUND UP
        		POP     BC              ;RESTORE EXPONENTS
        		CALL    C,INCC
        		RRA                     ;LSB OF A TO CARRY
        		LD      A,C             ;COMPUTE NEW EXPONENT
        		SBC     A,B
        		CCF
        		JP      CHKOVF
;
;IMUL - Integer multiplication.
;
IMUL:			LD      A,H
        		XOR     D
        		EX      AF,AF'          ;SAVE RESULT SIGN
        		BIT     7,H
        		CALL    NZ,NEGATE
        		CALL    SWAP
        		BIT     7,H
        		CALL    NZ,NEGATE
        		LD      B,H
        		LD      C,L
        		LD      HL,0
        		EXX
        		LD      B,H
        		LD      C,L
        		LD      HL,0
        		LD      A,-33
        		CALL    MULA            ;MULTIPLY
        		EXX
        		LD      C,191           ;PRESET EXPONENT
        		CALL    TEST            ;TEST RANGE
        		JR      NZ,IMUL1        ;TOO BIG
        		BIT     7,D
        		JR      NZ,IMUL1
        		CALL    SWAP
        		LD      C,D             ;INTEGER MARKER
        		EX      AF,AF'
        		RET     P
        		JP      NEGATE
;
IMUL1:			DEC     C
        		EXX
        		SLA     E
        		RL      D
        		EXX
        		RL      E
        		RL      D
        		EXX
        		ADC.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		JP      P,IMUL1         ;NORMALISE
        		EX      AF,AF'
        		RET     M
        		RES     7,H             ;POSITIVE
        		RET
;
;FMUL - Floating point multiplication with rounding.
;
FMUL:			DEC     B               ;TEST FOR ZERO
        		INC     B
        		JP      Z,ZERO
        		DEC     C               ;TEST FOR ZERO
        		INC     C
        		RET     Z
        		LD      A,H
        		XOR     D               ;CALC. RESULT SIGN
        		EX      AF,AF'
        		SET     7,D             ;REPLACE IMPLIED 1's
        		SET     7,H
        		PUSH    BC              ;SAVE EXPONENTS
        		LD      B,H             ;LOAD REGISTERS
        		LD      C,L
        		LD      HL,0
        		EXX
        		LD      B,H
        		LD      C,L
        		LD      HL,0
        		LD      A,-32           ;LOOP COUNTER
        		CALL    MULA            ;MULTIPLY
        		CALL    C,MULB          ;NORMALISE & INC A
        		EXX
        		PUSH    HL
        		LD      HL,8000H
        		OR      A               ;CLEAR CARRY
        		SBC.S   HL,DE
        		POP     HL
        		CALL    Z,ODD           ;ROUND UNBIASSED
        		CALL    C,ADD1          ;ROUND UP
        		POP     BC              ;RESTORE EXPONENTS
        		CALL    C,INCC
        		RRA                     ;LSB OF A TO CARRY
        		LD      A,C             ;COMPUTE NEW EXPONENT
        		ADC     A,B
CHKOVF:			JR      C,CHKO1
        		JP      P,ZERO          ;UNDERFLOW
        		JR      CHKO2
CHKO1:			JP      M,OFLOW         ;OVERFLOW
CHKO2:			ADD     A,80H
        		LD      C,A
        		JP      Z,ZERO
        		EX      AF,AF'          ;RESTORE SIGN BIT
        		RES     7,H
        		RET     P
        		SET     7,H
        		RET
;
;IPOW - Integer involution.
;
IPOW:			CALL    SWAP
        		BIT     7,H
        		PUSH    AF              ;SAVE SIGN
        		CALL    NZ,NEGATE
IPOW0:			LD      C,B
        		LD      B,32            ;LOOP COUNTER
IPOW1:			CALL    X2
        		JR      C,IPOW2
        		DJNZ    IPOW1
        		POP     AF
        		EXX
        		INC     L               ;RESULT=1
        		EXX
        		LD      C,H
        		RET
;
IPOW2:			POP     AF
        		PUSH    BC
        		EX      DE,HL
        		PUSH    HL
        		EXX
        		EX      DE,HL
        		PUSH    HL
        		EXX
        		LD      IX,0
        		ADD     IX,SP
        		JR      Z,IPOW4
        		PUSH    BC
        		EXX
        		PUSH    DE
        		EXX
        		PUSH    DE
        		CALL    SFLOAT
        		CALL    RECIP
        		LD      (IX+4),C
        		EXX
        		LD      (IX+0),L
        		LD      (IX+1),H
        		EXX
        		LD      (IX+2),L
        		LD      (IX+3),H
        		JR      IPOW5
;
IPOW3:			PUSH    BC
        		EXX
        		SLA     E
        		RL      D
        		PUSH    DE
        		EXX
        		RL      E
        		RL      D
        		PUSH    DE
        		LD      A,'*' & 0FH
        		PUSH    AF
        		CALL    COPY_
        		CALL    OP              ;SQUARE
        		POP     AF
        		CALL    DLOAD5
        		CALL    C,OP            ;MULTIPLY BY X
IPOW5:			POP     DE
        		EXX
        		POP     DE
        		EXX
        		LD      A,C
        		POP     BC
        		LD      C,A
IPOW4:			DJNZ    IPOW3
        		POP     AF
        		POP     AF
        		POP     AF
        		RET
;
FPOW0:			POP     AF
        		POP     AF
        		POP     AF
        		JR      IPOW0
;
;FPOW - Floating-point involution.
;
FPOW:			BIT     7,D
        		PUSH    AF
        		CALL    SWAP
        		CALL    PUSH5
        		DEC     C
        		INC     C
        		JR      Z,FPOW0
        		LD      A,158
        		CP      C
        		JR      C,FPOW1
        		INC     A
        		CALL    FIX
        		EX      AF,AF'
        		JP      P,FPOW0
FPOW1:			CALL    SWAP
        		CALL    LN0
        		CALL    POP5
        		POP     AF
        		CALL    FMUL
        		JP      EXP0
;
;Integer and floating-point compare.
;Result is TRUE (-1) or FALSE (0).
;
FLT:			CALL    FCP
        		JR      ILT1
ILT:			CALL    ICP
ILT1:			RET     NC
        		JR      TRUE
;
FGT:			CALL    FCP
        		JR      IGT1
IGT:			CALL    ICP
IGT1:			RET     Z
        		RET     C
        		JR      TRUE
;
FGE:			CALL    FCP
        		JR      IGE1
IGE:			CALL    ICP
IGE1:			RET     C
        		JR      TRUE
;
FLE:			CALL    FCP
        		JR      ILE1
ILE:			CALL    ICP
ILE1:			JR      Z,TRUE
        		RET     NC
        		JR      TRUE
;
FNE:			CALL    FCP
        		JR      INE1
INE:			CALL    ICP
INE1:			RET     Z
        		JR      TRUE
;
FEQ:			CALL    FCP
        		JR      IEQ1
IEQ:			CALL    ICP
IEQ1:			RET     NZ
TRUE:			LD      HL,-1
        		EXX
        		LD      HL,-1
        		EXX
        		XOR     A
        		LD      C,A
        		RET
;
;FUNCTIONS:
;
;Result returned in HLH'L'C (floating point)
;Result returned in HLH'L' (C=0) (integer)
;All registers except IY destroyed.
;
;ABS - Absolute value
;Result is numeric, variable type.
;
ABSV:			BIT     7,H
        		RET     Z               ;POSITIVE/ZERO
        		DEC     C
        		INC     C
        		JP      Z,NEGATE        ;INTEGER
        		RES     7,H
        		RET
;
;NOT - Complement integer.
;Result is integer numeric.
;
NOTK:			CALL    SFIX
        		LD      A,H
        		CPL
        		LD      H,A
        		LD      A,L
        		CPL
        		LD      L,A
        		EXX
        		LD      A,H
        		CPL
        		LD      H,A
        		LD      A,L
        		CPL
        		LD      L,A
        		EXX
        		XOR     A               ;NUMERIC MARKER
        		RET
;
;PI - Return PI (3.141592654)
;Result is floating-point numeric.
;
PI:			LD      HL,490FH
        		EXX
        		LD      HL,0DAA2H
        		EXX
        		LD      C,81H
        		XOR     A               ;NUMERIC MARKER
        		RET
;
;DEG - Convert radians to degrees
;Result is floating-point numeric.
;
DEG:			CALL    FPI180
        		CALL    FMUL
        		XOR     A
        		RET
;
;RAD - Convert degrees to radians
;Result is floating-point numeric.
;
RAD:			CALL    FPI180
        		CALL    FDIV
        		XOR     A
        		RET
;
;180/PI
;
FPI180:			CALL    SFLOAT
        		LD      DE,652EH
        		EXX
        		LD      DE,0E0D3H
        		EXX
        		LD      B,85H
        		RET
;
;SGN - Return -1, 0 or +1
;Result is integer numeric.
;
SGN:			CALL    TEST
        		OR      C
        		RET     Z               ;ZERO
        		BIT     7,H
        		JP      NZ,TRUE         ;-1
        		CALL    ZERO
        		JP      ADD1            ;1
;
;VAL - Return numeric value of string.
;Input: ASCII string at IX
;Result is variable type numeric.
;
VAL:			CALL    SIGNQ
        		PUSH    AF
        		CALL    CON_FPP
        		POP     AF
        		CP      '-'
        		LD      A,0             ;NUMERIC MARKER
        		RET     NZ
        		DEC     C
        		INC     C
        		JP      Z,NEGATE        ;ZERO/INTEGER
        		LD      A,H
        		XOR     80H             ;CHANGE SIGN (FP)
        		LD      H,A
        		XOR     A
        		RET
;
;INT - Floor function
;Result is integer numeric.
;
INT_:			DEC     C
        		INC     C
        		RET     Z               ;ZERO/INTEGER
        		LD      A,159
        		LD      B,H             ;B7=SIGN BIT
        		CALL    FIX
        		EX      AF,AF'
        		AND     B
        		CALL    M,ADD1          ;NEGATIVE NON-INTEGER
        		LD      A,B
        		OR      A
        		CALL    M,NEGATE
        		XOR     A
        		LD      C,A
        		RET
;
;SQR - square root
;Result is floating-point numeric.
;
SQR:			CALL    SFLOAT
SQR0:			BIT     7,H
        		LD      A,NGROOT
        		JP      NZ,ERROR__FPP        ;"-ve root"
        		DEC     C
        		INC     C
        		RET     Z               ;ZERO
        		SET     7,H             ;IMPLIED 1
        		BIT     0,C
        		CALL    Z,DIV2          ;MAKE EXPONENT ODD
        		LD      A,C
        		SUB     80H
        		SRA     A               ;HALVE EXPONENT
        		ADD     A,80H
        		LD      C,A
        		PUSH    BC              ;SAVE EXPONENT
        		EX      DE,HL
        		LD      HL,0
        		LD      B,H
        		LD      C,L
        		EXX
        		EX      DE,HL
        		LD      HL,0
        		LD      B,H
        		LD      C,L
        		LD      A,-31
        		CALL    SQRA            ;ROOT
        		EXX
        		BIT     7,B
        		EXX
        		CALL    Z,SQRA          ;NORMALISE & INC A
        		CALL    SQRB
        		OR      A               ;CLEAR CARRY
        		CALL    DIVB
        		RR      E               ;LSB TO CARRY
        		LD      H,B
        		LD      L,C
        		EXX
        		LD      H,B
        		LD      L,C
        		CALL    C,ADD1          ;ROUND UP
        		POP     BC              ;RESTORE EXPONENT
        		CALL    C,INCC
        		RRA
        		SBC     A,A
        		ADD     A,C
        		LD      C,A
        		RES     7,H             ;POSITIVE
        		XOR     A
        		RET
;
;TAN - Tangent function
;Result is floating-point numeric.
;
TAN:			CALL    SFLOAT
        		CALL    PUSH5
        		CALL    COS0
        		CALL    POP5
        		CALL    PUSH5
        		CALL    SWAP
        		CALL    SIN0
        		CALL    POP5
        		CALL    FDIV
        		XOR     A               ;NUMERIC MARKER
        		RET
;
;COS - Cosine function
;Result is floating-point numeric.
;
COS:			CALL    SFLOAT
COS0:			CALL    SCALE
        		INC     E
        		INC     E
        		LD      A,E
        		JR      SIN1
;
;SIN - Sine function
;Result is floating-point numeric.
;
SIN:			CALL    SFLOAT
SIN0:			PUSH    HL              ;H7=SIGN
        		CALL    SCALE
        		POP     AF
        		RLCA
        		RLCA
        		RLCA
        		AND     4
        		XOR     E
SIN1:			PUSH    AF              ;OCTANT
        		RES     7,H
        		RRA
        		CALL    PIBY4
        		CALL    C,RSUB          ;X=(PI/4)-X
        		POP     AF
        		PUSH    AF
        		AND     3
        		JP      PO,SIN2         ;USE COSINE APPROX.
        		CALL    PUSH5           ;SAVE X
        		CALL    SQUARE          ;PUSH X*X
        		CALL    POLY
        		DW	0A8B7H          ;a(8)
        		DW	3611H
        		DB	6DH
        		DW	0DE26H          ;a(6)
        		DW	0D005H
        		DB	73H
        		DW	80C0H           ;a(4)
        		DW	888H
        		DB	79H
        		DW	0AA9DH          ;a(2)
        		DW	0AAAAH
        		DB	7DH
        		DW	0               ;a(0)
        		DW	0
        		DB	80H
        		CALL    POP5
        		CALL    POP5
        		CALL    FMUL
        		JP      SIN3
;
SIN2:			CALL    SQUARE          ;PUSH X*X
        		CALL    POLY
        		DW	0D571H          ;b(8)
        		DW	4C78H
        		DB	70H
        		DW	94AFH           ;b(6)
        		DW	0B603H
        		DB	76H
        		DW	9CC8H           ;b(4)
        		DW	2AAAH
        		DB	7BH
        		DW	0FFDDH          ;b(2)
        		DW	0FFFFH
        		DB	7EH
        		DW	0               ;b(0)
        		DW	0
        		DB	80H
        		CALL    POP5
SIN3:			POP     AF
        		AND     4
        		RET     Z
        		DEC     C
        		INC     C
        		RET     Z               ;ZERO
        		SET     7,H             ;MAKE NEGATIVE
        		RET
;
;Floating-point one:
;
FONE:			LD      HL,0
        		EXX
        		LD      HL,0
        		EXX
        		LD      C,80H
        		RET
;
DONE:			LD      DE,0
        		EXX
        		LD      DE,0
        		EXX
        		LD      B,80H
        		RET
;
PIBY4:			LD      DE,490FH
        		EXX
        		LD      DE,0DAA2H
        		EXX
        		LD      B,7FH
        		RET
;
;EXP - Exponential function
;Result is floating-point numeric.
;
EXP:			CALL    SFLOAT
EXP0:			CALL    LN2             ;LN(2)
        		EXX
	        	DEC     E
		        LD      BC,0D1CFH       ;0.6931471805599453
        		EXX
        		PUSH    HL              ;H7=SIGN
        		CALL    MOD48           ;"MODULUS"
        		POP     AF
        		BIT     7,E
        		JR      Z,EXP1
        		RLA
        		JP      C,ZERO
        		LD      A,EXPRNG
        		JP      ERROR__FPP           ;"Exp range"
;
EXP1:			AND     80H
        		OR      E
        		PUSH    AF              ;INTEGER PART
        		RES     7,H
        		CALL    PUSH5           ;PUSH X*LN(2)
        		CALL    POLY
        		DW	4072H           ;a(7)
        		DW	942EH
        		DB	73H
        		DW	6F65H           ;a(6)
        		DW	2E4FH
        		DB	76H
        		DW	6D37H           ;a(5)
        		DW	8802H
        		DB	79H
        		DW	0E512H          ;a(4)
        		DW	2AA0H
        		DB	7BH
        		DW	4F14H           ;a(3)
        		DW	0AAAAH
        		DB	7DH
        		DW	0FD56H          ;a(2)
        		DW	7FFFH
        		DB	7EH
        		DW	0FFFEH          ;a(1)
        		DW	0FFFFH
        		DB	7FH
        		DW	0               ;a(0)
        		DW	0
        		DB	80H
        		CALL    POP5
        		POP     AF
        		PUSH    AF
        		CALL    P,RECIP         ;X=1/X
        		POP     AF
        		JP      P,EXP4
        		AND     7FH
        		NEG
EXP4:			ADD     A,80H
        		ADD     A,C
        		JR      C,EXP2
        		JP      P,ZERO          ;UNDERFLOW
        		JR      EXP3
EXP2:			JP      M,OFLOW         ;OVERFLOW
EXP3:			ADD     A,80H
        		JP      Z,ZERO
        		LD      C,A
        		XOR     A               ;NUMERIC MARKER
        		RET
;
RECIP:			CALL    DONE
RDIV:			CALL    SWAP
        		JP      FDIV            ;RECIPROCAL
;
LN2:			LD      DE,3172H        ;LN(2)
        		EXX
        		LD      DE,17F8H
        		EXX
        		LD      B,7FH
        		RET
;
;LN - Natural log.
;Result is floating-point numeric.
;
LN:			CALL    SFLOAT
LN0:			LD      A,LOGRNG
        		BIT     7,H
        		JP      NZ,ERROR__FPP        ;"Log range"
        		INC     C
        		DEC     C
        		JP      Z,ERROR__FPP
        		LD      DE,3504H        ;SQR(2)
        		EXX
        		LD      DE,0F333H       ;1.41421356237
        		EXX
        		CALL    ICP0            ;MANTISSA>SQR(2)?
        		LD      A,C             ;EXPONENT
        		LD      C,80H           ;1 <= X < 2
        		JR      C,LN4
        		DEC     C
        		INC     A
LN4:			PUSH    AF              ;SAVE EXPONENT
        		CALL    RATIO           ;X=(X-1)/(X+1)
        		CALL    PUSH5
		        CALL    SQUARE          ;PUSH X*X
        		CALL    POLY
        		DW	0CC48H          ;a(9)
        		DW	74FBH
        		DB	7DH
        		DW	0AEAFH          ;a(7)
        		DW	11FFH
        		DB	7EH
        		DW	0D98CH          ;a(5)
        		DW	4CCDH
        		DB	7EH
        		DW	0A9E3H          ;a(3)
        		DW	2AAAH
        		DB	7FH
        		DW	0               ;a(1)
        		DW	0
        		DB	81H
        		CALL    POP5
        		CALL    POP5
        		CALL    FMUL
        		POP     AF              ;EXPONENT
        		CALL    PUSH5
        		EX      AF,AF'
        		CALL    ZERO
        		EX      AF,AF'
        		SUB     80H
        		JR      Z,LN3
        		JR      NC,LN1
        		CPL
        		INC     A
LN1:			LD      H,A
        		LD      C,87H
        		PUSH    AF
        		CALL    FLOAT_
        		RES     7,H
        		CALL    LN2
        		CALL    FMUL
        		POP     AF
        		JR      NC,LN3
        		JP      M,LN3
        		SET     7,H
LN3:			CALL    POP5
        		CALL    FADD
        		XOR     A
        		RET
;
;LOG - base-10 logarithm.
;Result is floating-point numeric.
;
LOG:			CALL    LN
        		LD      DE,5E5BH        ;LOG(e)
        		EXX
        		LD      DE,0D8A9H
        		EXX
        		LD      B,7EH
        		CALL    FMUL
        		XOR     A
        		RET
;
;ASN - Arc-sine
;Result is floating-point numeric.
;
ASN:			CALL    SFLOAT
        		CALL    PUSH5
        		CALL    COPY_
        		CALL    FMUL
        		CALL    DONE
        		CALL    RSUB
        		CALL    SQR0
        		CALL    POP5
        		INC     C
        		DEC     C
        		LD      A,2
        		PUSH    DE
        		JP      Z,ACS1
        		POP     DE
        		CALL    RDIV
        		JR      ATN0
;
;ATN - arc-tangent
;Result is floating-point numeric.
;
ATN:			CALL    SFLOAT
ATN0:			PUSH    HL              ;SAVE SIGN
        		RES     7,H
        		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
        		EXX
        		LD      DE,0CCD0H
        		EXX
        		LD      B,7EH
        		CALL    FCP0            ;COMPARE
        		LD      B,0
        		JR      C,ATN2
        		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
        		EXX
        		LD      DE,799AH
        		EXX
        		LD      B,81H
        		CALL    FCP0            ;COMPARE
        		JR      C,ATN1
        		CALL    RECIP           ;X=1/X
        		LD      B,2
        		JP      ATN2
ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
        		LD      B,1
ATN2:			PUSH    BC              ;SAVE FLAG
        		CALL    PUSH5
        		CALL    SQUARE          ;PUSH X*X
        		CALL    POLY
        		DW	0F335H          ;a(13)
        		DW	37D8H
        		DB	7BH
        		DW	6B91H           ;a(11)
        		DW	0AAB9H
        		DB	7CH
        		DW	41DEH           ;a(9)
        		DW	6197H
        		DB	7CH
        		DW	9D7BH           ;a(7)
        		DW	9237H
        		DB	7DH
        		DW	2A5AH           ;a(5)
        		DW	4CCCH
        		DB	7DH
        		DW	0A95CH          ;a(3)
        		DW	0AAAAH
        		DB	7EH
        		DW	0               ;a(1)
        		DW	0
        		DB	80H
        		CALL    POP5
        		CALL    POP5
        		CALL    FMUL
        		POP     AF
ACS1:			CALL    PIBY4           ;PI/4
        		RRA
        		PUSH    AF
        		CALL    C,FADD
        		POP     AF
        		INC     B
        		RRA
        		CALL    C,RSUB
        		POP     AF
        		OR      A
        		RET     P
        		SET     7,H             ;MAKE NEGATIVE
        		XOR     A
        		RET
;
;ACS - Arc cosine=PI/2-ASN.
;Result is floating point numeric.
;
ACS:			CALL    ASN
        		LD      A,2
        		PUSH    AF
        		JR      ACS1
;
;Function STR - convert numeric value to ASCII string.
;   Inputs: HLH'L'C = integer or floating-point number
;           DE = address at which to store string
;           IX = address of @% format control
;  Outputs: String stored, with NUL terminator
;
;First normalise for decimal output:
;
STR:			CALL    SFLOAT
        		LD      B,0             ;DEFAULT PT. POSITION
        		BIT     7,H             ;NEGATIVE?
        		JR      Z,STR10
        		RES     7,H
        		LD      A,'-'
        		LD      (DE),A          ;STORE SIGN
        		INC     DE
STR10:			XOR     A               ;CLEAR A
        		CP      C
        		JR      Z,STR2          ;ZERO
        		PUSH    DE              ;SAVE TEXT POINTER
        		LD      A,B
STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
        		LD      A,C             ;BINARY EXPONENT
        		CP      161
        		JR      NC,STR14
        		CP      155
        		JR      NC,STR15
        		CPL
        		CP      225
        		JR      C,STR13
        		LD      A,-8
STR13:			ADD     A,28
        		CALL    POWR10
        		PUSH    AF
        		CALL    FMUL
        		POP     AF
        		LD      B,A
        		POP     AF
        		SUB     B
        		JR      STR11
STR14:			SUB     32
        		CALL    POWR10
        		PUSH    AF
        		CALL    FDIV
        		POP     AF
        		LD      B,A
        		POP     AF
        		ADD     A,B
        		JR      STR11
STR15:			LD      A,9
        		CALL    POWR10          ;10^9
        		CALL    FCP0
        		LD      A,C
        		POP     BC
        		LD      C,A
        		SET     7,H             ;IMPLIED 1
        		CALL    C,X10B          ;X10, DEC B
        		POP     DE              ;RESTORE TEXT POINTER
        		RES     7,C
        		LD      A,0
        		RLA                     ;PUT CARRY IN LSB
;
;At this point decimal normalisation has been done,
;now convert to decimal digits:
;      AHLH'L' = number in normalised integer form
;            B = decimal place adjustment
;            C = binary place adjustment (29-33)
;
STR2:			INC     C
        		EX      AF,AF'          ;SAVE A
        		LD      A,B
        		BIT     1,(IX+2)
        		JR      NZ,STR20
        		XOR     A
        		CP      (IX+1)
        		JR      Z,STR21
        		LD      A,-10
STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
        		OR      A               ;CLEAR CARRY
        		JP      M,STR21
        		XOR     A
STR21:			PUSH    AF
        		EX      AF,AF'          ;RESTORE A
STR22:			CALL    X2              ;RL AHLH'L'
        		ADC     A,A
        		CP      10
        		JR      C,STR23
        		SUB     10
        		EXX
        		INC     L               ;SET RESULT BIT
        		EXX
STR23:			DEC     C
        		JR      NZ,STR22        ;32 TIMES
        		LD      C,A             ;REMAINDER
        		LD      A,H
        		AND     3FH             ;CLEAR OUT JUNK
        		LD      H,A
        		POP     AF
        		JP      P,STR24
        		INC     A
        		JR      NZ,STR26
        		LD      A,4
        		CP      C               ;ROUND UP?
        		LD      A,0
        		JR      STR26
STR24:			PUSH    AF
        		LD      A,C
        		ADC     A,'0'           ;ADD CARRY
        		CP      '0'
        		JR      Z,STR25         ;SUPPRESS ZERO
        		CP      '9'+1
        		CCF
        		JR      NC,STR26
STR25:			EX      (SP),HL
        		BIT     6,L             ;ZERO FLAG
		        EX      (SP),HL
        		JR      NZ,STR27
        		LD      A,'0'
STR26:			INC     A               ;SET +VE
        		DEC     A
        		PUSH    AF              ;PUT ON STACK + CARRY
STR27:			INC     B
        		CALL    TEST            ;IS HLH'L' ZERO?
        		LD      C,32
        		LD      A,0
        		JR      NZ,STR22
        		POP     AF
        		PUSH    AF
        		LD      A,0
        		JR      C,STR22
;
;At this point, the decimal character string is stored
; on the stack. Trailing zeroes are suppressed and may
; need to be replaced.
;B register holds decimal point position.
;Now format number and store as ASCII string:
;
STR3:			EX      DE,HL           ;STRING POINTER
        		LD      C,-1            ;FLAG "E"
        		LD      D,1
        		LD      E,(IX+1)        ;f2
        		BIT     0,(IX+2)
        		JR      NZ,STR34        ;E MODE
        		BIT     1,(IX+2)
        		JR      Z,STR31
        		LD      A,B             ;F MODE
        		OR      A
        		JR      Z,STR30
        		JP      M,STR30
        		LD      D,B
STR30:			LD      A,D
        		ADD     A,(IX+1)
        		LD      E,A
        		CP      11
        		JR      C,STR32
STR31:			LD      A,B             ;G MODE
        		LD      DE,101H
        		OR      A
        		JP      M,STR34
        		JR      Z,STR32
        		LD      A,(IX+1)
        		OR      A
        		JR      NZ,STR3A
        		LD      A,10
STR3A:			CP      B
        		JR      C,STR34
        		LD      D,B
        		LD      E,B
STR32:			LD      A,B
        		ADD     A,129
        		LD      C,A
STR34:			SET     7,D
        		DEC     E
STR35:			LD      A,D
        		CP      C
        		JR      NC,STR33
STR36:			POP     AF
        		JR      Z,STR37
        		JP      P,STR38
STR37:			PUSH    AF
        		INC     E
        		DEC     E
        		JP      M,STR4
STR33:			LD      A,'0'
STR38:			DEC     D
        		JP      PO,STR39
        		LD      (HL),'.'
        		INC     HL
STR39:			LD      (HL),A
        		INC     HL
        		DEC     E
        		JP      P,STR35
        		JR      STR36
;
STR4:			POP     AF
STR40:			INC     C
        		LD      C,L
        		JR      NZ,STR44
        		LD      (HL),'E'        ;EXPONENT
        		INC     HL
        		LD      A,B
        		DEC     A
        		JP      P,STR41
        		LD      (HL),'-'
        		INC     HL
        		NEG
STR41:			LD      (HL),'0'
        		JR      Z,STR47
        		CP      10
        		LD      B,A
        		LD      A,':'
        		JR      C,STR42
        		INC     HL
        		LD      (HL),'0'
STR42:			INC     (HL)
        		CP      (HL)
        		JR      NZ,STR43
        		LD      (HL),'0'
        		DEC     HL
        		INC     (HL)
        		INC     HL
STR43:			DJNZ    STR42
STR47:			INC     HL
STR44:			EX      DE,HL
      			RET
;
;Support subroutines:
;
DLOAD5:			LD      B,(IX+4)
        		EXX
        		LD      E,(IX+0)
        		LD      D,(IX+1)
        		EXX
        		LD      E,(IX+2)
        		LD      D,(IX+3)
        		RET
;
DLOAD5_SPL:		LD      B,(IX+6)
			EXX
			LD	DE, (IX+0)
			EXX
			LD	DE, (IX+3)
			RET
;
;CON_FPP - Get unsigned numeric constant from ASCII string.
;   Inputs: ASCII string at (IX).
;  Outputs: Variable-type result in HLH'L'C
;           IX updated (points to delimiter)
;           A7 = 0 (numeric marker)
;
CON_FPP:			CALL    ZERO            ;INITIALISE TO ZERO
        		LD      C,0             ;TRUNCATION COUNTER
        		CALL    NUMBER          ;GET INTEGER PART
        		CP      '.'
        		LD      B,0             ;DECL. PLACE COUNTER
        		CALL    Z,NUMBIX        ;GET FRACTION PART
        		CP      'E'
        		LD      A,0             ;INITIALISE EXPONENT
        		CALL    Z,GETEXP        ;GET EXPONENT
        		BIT     7,H
        		JR      NZ,CON0         ;INTEGER OVERFLOW
        		OR      A
        		JR      NZ,CON0         ;EXPONENT NON-ZERO
        		CP      B
        		JR      NZ,CON0         ;DECIMAL POINT
        		CP      C
        		RET     Z               ;INTEGER
CON0:			SUB     B
        		ADD     A,C
        		LD      C,159
        		CALL    FLOAT_
        		RES     7,H             ;DITCH IMPLIED 1
        		OR      A
        		RET     Z               ;DONE
        		JP      M,CON2          ;NEGATIVE EXPONENT
        		CALL    POWR10
        		CALL    FMUL            ;SCALE
        		XOR     A
        		RET
CON2:			CP      -38
        		JR      C,CON3          ;CAN'T SCALE IN ONE GO
        		NEG
        		CALL    POWR10
        		CALL    FDIV            ;SCALE
        		XOR     A
        		RET
CON3:			PUSH    AF
        		LD      A,38
        		CALL    POWR10
        		CALL    FDIV
        		POP     AF
        		ADD     A,38
        		JR      CON2
;
;GETEXP - Get decimal exponent from string
;     Inputs: ASCII string at (IX)
;             (IX points at 'E')
;             A = initial value
;    Outputs: A = new exponent
;             IX updated.
;   Destroys: A,A',IX,F,F'
;
GETEXP:			PUSH    BC              ;SAVE REGISTERS
        		LD      B,A             ;INITIAL VALUE
        		LD      C,2             ;2 DIGITS MAX
        		INC     IX              ;BUMP PAST 'E'
        		CALL    SIGNQ
        		EX      AF,AF'          ;SAVE EXPONENT SIGN
GETEX1:			CALL    DIGITQ
        		JR      C,GETEX2
        		LD      A,B             ;B=B*10
        		ADD     A,A
        		ADD     A,A
        		ADD     A,B
        		ADD     A,A
        		LD      B,A
        		LD      A,(IX)          ;GET BACK DIGIT
        		INC     IX
        		AND     0FH             ;MASK UNWANTED BITS
        		ADD     A,B             ;ADD IN DIGIT
        		LD      B,A
        		DEC     C
        		JP      P,GETEX1
        		LD      B,100           ;FORCE OVERFLOW
        		JR      GETEX1
GETEX2:			EX      AF,AF'          ;RESTORE SIGN
        		CP      '-'
        		LD      A,B
        		POP     BC              ;RESTORE
        		RET     NZ
        		NEG                     ;NEGATE EXPONENT
        		RET
;
;NUMBER: Get unsigned integer from string.
;    Inputs: string at (IX)
;            C = truncated digit count
;                (initially zero)
;            B = total digit count
;            HLH'L' = initial value
;   Outputs: HLH'L' = number (binary integer)
;            A = delimiter.
;            B, C & IX updated
;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
;
NUMBIX:			INC     IX
NUMBER:			CALL    DIGITQ
        		RET     C
        		INC     B               ;INCREMENT DIGIT COUNT
        		INC     IX
        		CALL    X10             ;*10 & COPY OLD VALUE
        		JR      C,NUMB1         ;OVERFLOW
        		DEC     C               ;SEE IF TRUNCATED
        		INC     C
        		JR      NZ,NUMB1        ;IMPORTANT!
        		AND     0FH
        		EXX
        		LD      B,0
        		LD      C,A
        		ADD.S   HL,BC           ;ADD IN DIGIT
        		EXX
        		JR      NC,NUMBER
        		INC.S   HL              ;CARRY
        		LD      A,H
        		OR      L
        		JR      NZ,NUMBER
NUMB1:			INC     C               ;TRUNCATION COUNTER
        		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
        		JR      NUMBER
;
;FIX - Fix number to specified exponent value.
;    Inputs: HLH'L'C = +ve non-zero number (floated)
;            A = desired exponent (A>C)
;   Outputs: HLH'L'C = fixed number (unsigned)
;            fraction shifted into B'C'
;            A'F' positive if integer input
;  Destroys: C,H,L,A',B',C',H',L',F,F'
;
FIX:			EX      AF,AF'
        		XOR     A
        		EX      AF,AF'
        		SET     7,H             ;IMPLIED 1
FIX1:			CALL    DIV2
        		CP      C
        		RET     Z
        		JP      NC,FIX1
        		JP      OFLOW
;
;SFIX - Convert to integer if necessary.
;    Input: Variable-type number in HLH'L'C
;   Output: Integer in HLH'L', C=0
; Destroys: A,C,H,L,A',B',C',H',L',F,F'
;
;NEGATE - Negate HLH'L'
;    Destroys: H,L,H',L',F
;
FIX2:			CALL    SWAP
        		CALL    SFIX
        		CALL    SWAP
SFIX:			DEC     C
        		INC     C
        		RET     Z               ;INTEGER/ZERO
        		BIT     7,H             ;SIGN
        		PUSH    AF
        		LD      A,159
        		CALL    FIX
        		POP     AF
        		LD      C,0
        		RET     Z
NEGATE:			OR      A               ;CLEAR CARRY
        		EXX
NEG0:			PUSH    DE
        		EX      DE,HL
        		LD      HL,0
        		SBC.S   HL,DE
        		POP     DE
        		EXX
        		PUSH    DE
        		EX      DE,HL
        		LD      HL,0
        		SBC.S   HL,DE
        		POP     DE
        		RET
;
;NEG - Negate HLH'L'B'C'
;    Also complements A (used in FADD)
;    Destroys: A,H,L,B',C',H',L',F
;
NEG_:			EXX
        		CPL
        		PUSH    HL
        		OR      A               ;CLEAR CARRY
        		LD      HL,0
        		SBC.S   HL,BC
        		LD      B,H
        		LD      C,L
        		POP     HL
        		JR      NEG0
;
;SCALE - Trig scaling.
;MOD48 - 48-bit floating-point "modulus" (remainder).
;   Inputs: HLH'L'C unsigned floating-point dividend
;           DED'E'B'C'B unsigned 48-bit FP divisor
;  Outputs: HLH'L'C floating point remainder (H7=1)
;           E = quotient (bit 7 is sticky)
; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
;FLO48 - Float unsigned number (48 bits)
;    Input/output in HLH'L'B'C'C
;   Destroys: C,H,L,B',C',H',L',F
;
SCALE:			LD      A,150
        		CP      C
        		LD      A,ACLOST
        		JP      C,ERROR__FPP         ;"Accuracy lost"
        		CALL    PIBY4
        		EXX
        		LD      BC,2169H        ;3.141592653589793238
        		EXX
MOD48:			SET     7,D             ;IMPLIED 1
        		SET     7,H
        		LD      A,C
        		LD      C,0             ;INIT QUOTIENT
        		LD      IX,0
        		PUSH    IX              ;PUT ZERO ON STACK
        		CP      B
        		JR      C,MOD485        ;DIVIDEND<DIVISOR
MOD481:			EXX                     ;CARRY=0 HERE
        		EX      (SP),HL
        		SBC.S   HL,BC
        		EX      (SP),HL
        		SBC.S   HL,DE
        		EXX
        		SBC.S   HL,DE
        		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
        		EXX
        		EX      (SP),HL
        		ADD.S   HL,BC
        		EX      (SP),HL
        		ADC.S   HL,DE
        		EXX
        		ADC.S   HL,DE
MOD482:			CCF
        		RL      C               ;QUOTIENT
        		JR      NC,MOD483
        		SET     7,C             ;STICKY BIT
MOD483:			DEC     A
        		CP      B
        		JR      C,MOD484        ;DIVIDEND<DIVISOR
        		EX      (SP),HL
        		ADD.S   HL,HL           ;DIVIDEND * 2
        		EX      (SP),HL
        		EXX
        		ADC.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		JR      NC,MOD481       ;AGAIN
        		OR      A
        		EXX
        		EX      (SP),HL
        		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
        		EX      (SP),HL
        		SBC.S   HL,DE
        		EXX
        		SBC.S   HL,DE
        		OR      A
        		JR      MOD482
;
MOD484:			INC     A
MOD485:			LD      E,C             ;QUOTIENT
        		LD      C,A             ;REMAINDER EXPONENT
        		EXX
        		POP     BC
        		EXX
FLO48:			BIT     7,H
        		RET     NZ
        		EXX
        		SLA     C
        		RL      B
        		ADC.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		DEC     C
        		JP      NZ,FLO48
        		RET
;
;Float unsigned number
;    Input/output in HLH'L'C
;   Destroys: C,H,L,H',L',F
;
FLOAT_:			BIT     7,H
        		RET     NZ
        		EXX                     ;SAME AS "X2"
        		ADD.S   HL,HL           ;TIME-CRITICAL
        		EXX                     ;REGION
        		ADC.S   HL,HL           ;(BENCHMARKS)
        		DEC     C
        		JP      NZ,FLOAT_
        		RET
;
;SFLOAT - Convert to floating-point if necessary.
;    Input: Variable-type number in HLH'L'C
;    Output: Floating-point in HLH'L'C
;    Destroys: A,C,H,L,H',L',F
;
FLOATA:			EX      AF,AF'
        		ADD     A,RTABLE-DTABLE/3
        		EX      AF,AF'
FLOAT2:			CALL    SWAP
        		CALL    SFLOAT
        		CALL    SWAP
SFLOAT:			DEC     C
        		INC     C
        		RET     NZ              ;ALREADY FLOATING-POINT
        		CALL    TEST
        		RET     Z               ;ZERO
        		LD      A,H
        		OR      A
        		CALL    M,NEGATE
        		LD      C,159
        		CALL    FLOAT_
        		OR      A
        		RET     M               ;NEGATIVE
        		RES     7,H
        		RET
;
;ROUND UP
;Return with carry set if 32-bit overflow
;   Destroys: H,L,B',C',H',L',F
;
ADD1:			EXX
        		LD      BC,1
        		ADD.S   HL,BC
        		EXX
        		RET     NC
        		PUSH    BC
        		LD      BC,1
        		ADD.S   HL,BC
        		POP     BC
        		RET
;
;ODD - Add one if even, leave alone if odd.
; (Used to perform unbiassed rounding, i.e.
;  number is rounded up half the time)
;    Destroys: L',F (carry cleared)
;
ODD:			OR      A               ;CLEAR CARRY
        		EXX
        		SET     0,L             ;MAKE ODD
        		EXX
        		RET
;
;SWAP - Swap arguments.
;    Exchanges DE,HL D'E',H'L' and B,C
;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
;SWAP1 - Swap DEHL with D'E'H'L'
;    Destroys: D,E,H,L,D',E',H',L'
;
SWAP:			LD      A,C
        		LD      C,B
        		LD      B,A
SWAP1:			EX      DE,HL
        		EXX
        		EX      DE,HL
        		EXX
        		RET
;
; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
; INCC - destroys C,F
; OFLOW
;
DIV2:			CALL    D2
        		EXX
        		RR      B
        		RR      C
        		EX      AF,AF'
        		OR      B
        		EX      AF,AF'
        		EXX
INCC:			INC     C
        		RET     NZ
OFLOW:			LD      A,TOOBIG
        		JP      ERROR__FPP           ;"Too big"
;
; FTEST - Test for zero & sign
;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
;
FTEST:			CALL    TEST
        		RET     Z
        		LD      A,H
        		AND     10000000B
        		OR      01000000B
        		RET
;
; TEST - Test HLH'L' for zero.
;     Output: Z-flag set & A=0 if HLH'L'=0
;     Destroys: A,F
;
TEST:			LD      A,H
        		OR      L
        		EXX
        		OR      H
        		OR      L
        		EXX
        		RET
;
; FCOMP - Compare two numbers
;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
;
FCOMP:			LD      A,B
        		OR      C               ;Both integer?
        		JR      NZ,FCOMP1
        		CALL    ICP
FCOMP0:			LD      A,0
        		RET     Z               ;Equal
        		LD      A,80H
        		RRA
        		RET
;
FCOMP1:			CALL    FLOAT2          ;Float both
        		CALL    FCP
        		JR      FCOMP0
;
; Integer and floating point compare.
; Sets carry & zero flags according to HLH'L'C-DED'E'B
; Result pre-set to FALSE
; ICP1, FCP1 destroy A,F
;
; ZERO - Return zero.
;  Destroys: A,C,H,L,H',L'
;
ICP:			CALL    ICP1
ZERO:			LD      A,0
        		EXX
        		LD      H,A
	       		LD      L,A
        		EXX
      			LD      H,A
     			LD      L,A
	    		LD      C,A
        		RET
;
FCP:			CALL    FCP1
        		JR      ZERO            ;PRESET FALSE
;
FCP0:			LD      A,C
        		CP      B               ;COMPARE EXPONENTS
        		RET     NZ
ICP0:			
			SBC.S   HL,DE           ;COMP MANTISSA MSB
        		ADD.S   HL,DE
        		RET     NZ
        		EXX
        		SBC.S   HL,DE           ;COMP MANTISSA LSB
        		ADD.S   HL,DE
        		EXX
        		RET
;
FCP1:			LD      A,H
        		XOR     D
        		LD      A,H
        		RLA
        		RET     M
        		JR      NC,FCP0
        		CALL    FCP0
        		RET     Z               ;** V0.1 BUG FIX
        		CCF
        		RET
;
ICP1:			LD      A,H
        		XOR     D
        		JP      P,ICP0
        		LD      A,H
        		RLA
        		RET
;
; ADD - Integer add.
; Carry, sign & zero flags valid on exit
;     Destroys: H,L,H',L',F
;
X10B:			DEC     B
        		INC     C
X5:			CALL    COPY0
        		CALL    D2C
        		CALL    D2C
        		EX      AF,AF'          ;SAVE CARRY
ADD_:			EXX
        		ADD.S   HL,DE
        		EXX
        		ADC.S   HL,DE
        		RET
;
; SUB - Integer subtract.
; Carry, sign & zero flags valid on exit
;     Destroys: H,L,H',L',F
;
SUB_:			EXX
        		OR      A
        		SBC.S   HL,DE
        		EXX
        		SBC.S   HL,DE
        		RET
;
; X10 - unsigned integer * 10
;    Inputs: HLH'L' initial value
;   Outputs: DED'E' = initial HLH'L'
;            Carry bit set if overflow
;            If carry not set HLH'L'=result
;  Destroys: D,E,H,L,D',E',H',L',F
; X2 - Multiply HLH'L' by 2 as 32-bit integer.
;     Carry set if MSB=1 before shift.
;     Sign set if MSB=1 after shift.
;     Destroys: H,L,H',L',F
;
X10:			CALL    COPY0           ;DED'E'=HLH'L'
        		CALL    X2
        		RET     C               ;TOO BIG
        		CALL    X2
        		RET     C
        		CALL    ADD_
        		RET     C
X2:			EXX
        		ADD.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		RET
;
; D2 - Divide HLH'L' by 2 as 32-bit integer.
;     Carry set if LSB=1 before shift.
;     Destroys: H,L,H',L',F
;
D2C:			INC     C
D2:			SRL     H
        		RR      L
        		EXX
        		RR      H
        		RR      L
        		EXX
        		RET
;
; COPY - COPY HLH'L'C INTO DED'E'B
;   Destroys: B,C,D,E,H,L,D',E',H',L'
;
COPY_:			LD      B,C
COPY0:			LD      D,H
        		LD      E,L
        		EXX
        		LD      D,H
        		LD      E,L
        		EXX
        		RET
;
; SQUARE - PUSH X*X
; PUSH5 - PUSH HLH'L'C ONTO STACK.
;   Destroys: SP,IX
;
SQUARE:			CALL    COPY_
        		CALL    FMUL
PUSH5:			POP     IX              ;RETURN ADDRESS
        		PUSH    BC
        		PUSH    HL
        		EXX
        		PUSH    HL
        		EXX
        		JP      (IX)            ;"RETURN"
;
; POP5 - POP DED'E'B OFF STACK.
;   Destroys: A,B,D,E,D',E',SP,IX
;
POP5:			POP     IX              ;RETURN ADDRESS
        		EXX
        		POP     DE
        		EXX
        		POP     DE
        		LD      A,C
        		POP     BC
        		LD      B,C
        		LD      C,A
        		JP      (IX)            ;"RETURN"
;
; RATIO - Calculate (X-1)/(X+1)
;     Inputs: X in HLH'L'C
;    Outputs: (X-1)/(X+1) in HLH'L'C
;   Destroys: Everything except IY,SP,I
;
RATIO:			CALL    PUSH5           ;SAVE X
        		CALL    DONE
        		CALL    FADD
        		CALL    POP5            ;RESTORE X
        		CALL    PUSH5           ;SAVE X+1
        		CALL    SWAP
        		CALL    DONE
        		CALL    FSUB
        		CALL    POP5            ;RESTORE X+1
        		JP      FDIV
;
; POLY - Evaluate a polynomial.
;     Inputs: X in HLH'L'C and also stored at (SP+2)
;             Polynomial coefficients follow call.
;    Outputs: Result in HLH'L'C
;   Destroys: Everything except IY,SP,I
; Routine terminates on finding a coefficient >=1.
; Note: The last coefficient is EXECUTED on return
;       so must contain only innocuous bytes!
;
POLY:			LD      IX, 3				; Advance the SP to the return address
        		ADD     IX, SP				
        		EX      (SP), IX			; IX: Points to the inline list of coefficients
;		
        		CALL    DLOAD5          		; Load the first coefficient from (IX)
POLY1:			CALL    FMUL
        		LD      DE, 5				; Skip to the next coefficient
        		ADD     IX, DE		
        		CALL    DLOAD5          		; Load the second coefficient from (IX)
        		EX      (SP), IX			; Restore the SP just in case we need to return
        		INC     B		
        		DEC     B               		; Test B for end byte (80h)
        		JP      M,FADD				; Yes, so add and return
        		CALL    FADD				; No, so add
        		CALL    DLOAD5_SPL			; Load X from SP
        		EX      (SP), IX			; IX: Points to the inline list of coefficients
        		JR      POLY1				; And loop
;
; POWR10 - Calculate power of ten.
;     Inputs: A=power of 10 required (A<128)
;             A=binary exponent to be exceeded (A>=128)
;    Outputs: DED'E'B = result
;             A = actual power of ten returned
;   Destroys: A,B,D,E,A',D',E',F,F'
;
POWR10:			INC     A
        		EX      AF,AF'
        		PUSH    HL
        		EXX
        		PUSH    HL
        		EXX
        		CALL    DONE
        		CALL    SWAP
        		XOR     A
POWR11:			EX      AF,AF'
        		DEC     A
        		JR      Z,POWR14        ;EXIT TYPE 1
        		JP      P,POWR13
        		CP      C
        		JR      C,POWR14        ;EXIT TYPE 2
        		INC     A
POWR13:			EX      AF,AF'
        		INC     A
        		SET     7,H
        		CALL    X5
        		JR      NC,POWR12
        		EX      AF,AF'
        		CALL    D2C
        		EX      AF,AF'
POWR12:			EX      AF,AF'
        		CALL    C,ADD1          ;ROUND UP
        		INC     C
        		JP      M,POWR11
        		JP      OFLOW
POWR14:			CALL    SWAP
        		RES     7,D
        		EXX
        		POP     HL
        		EXX
        		POP     HL
        		EX      AF,AF'
        		RET
;
; DIVA, DIVB - DIVISION PRIMITIVE.
;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
;               Remainder in H'L'HL
;     Inputs: A = loop counter (normally -32)
;     Destroys: A,D,E,H,L,D',E',H',L',F
;
DIVA:			OR      A               ;CLEAR CARRY
DIV0:			
			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
        		EXX
        		SBC.S   HL,BC
        		EXX
        		JR      NC,DIV1
        		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
        		EXX
        		ADC.S   HL,BC
        		EXX
DIV1:			CCF
DIVC:			RL      E               ;SHIFT RESULT INTO DE
        		RL      D
        		EXX
        		RL      E
        		RL      D
        		EXX
        		INC     A
        		RET     P
DIVB:			
			ADC.S   HL,HL           ;DIVIDEND*2
        		EXX
        		ADC.S   HL,HL
        		EXX
        		JR      NC,DIV0
        		OR      A
        		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
        		EXX
        		SBC.S   HL,BC
        		EXX
        		SCF
        		JP      DIVC
;
;MULA, MULB - MULTIPLICATION PRIMITIVE.
;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
;    Inputs: A = loop counter (usually -32)
;            H'L'HL = 0
;    Destroys: D,E,H,L,D',E',H',L',A,F
;
MULA:			OR      A               ;CLEAR CARRY
MUL0:			EXX
        		RR      D               ;MULTIPLIER/2
        		RR      E
        		EXX
        		RR      D
        		RR      E
        		JR      NC,MUL1
        		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
        		EXX
        		ADC.S   HL,BC
        		EXX
MUL1:			INC     A
        		RET     P
MULB:			EXX
        		RR      H               ;PRODUCT/2
        		RR      L
        		EXX
        		RR      H
        		RR      L
        		JP      MUL0
;
; SQRA, SQRB - SQUARE ROOT PRIMITIVES
;     Function: B'C'BC = SQR (D'E'DE)
;     Inputs: A = loop counter (normally -31)
;             B'C'BCH'L'HL initialised to 0
;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
;
SQR1:			
			SBC.S   HL,BC
        		EXX
        		SBC.S   HL,BC
        		EXX
        		INC     C
        		JR      NC,SQR2
        		DEC     C
        		ADD.S   HL,BC
        		EXX
        		ADC.S   HL,BC
        		EXX
        		DEC     C
SQR2:			INC     A
        		RET     P
SQRA:			SLA     C
        		RL      B
        		EXX
        		RL      C
        		RL      B
        		EXX
        		INC     C
        		SLA     E
        		RL      D
        		EXX
        		RL      E
        		RL      D
        		EXX
        		ADC.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		EXX
        		SLA     E
        		RL      D
        		EXX
        		RL      E
        		RL      D
        		EXX
        		ADC.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		EXX
        		JP      NC,SQR1
SQR3:			OR      A
        		SBC.S   HL,BC
        		EXX
        		SBC.S   HL,BC
        		EXX
        		INC     C
        		JP      SQR2
;
SQRB:			
			ADD.S   HL,HL
        		EXX
        		ADC.S   HL,HL
        		EXX
        		JR      C,SQR3
        		INC     A
        		INC     C
        		SBC.S   HL,BC
        		EXX
        		SBC.S   HL,BC
        		EXX
        		RET     NC
        		ADD.S   HL,BC
        		EXX
        		ADC.S   HL,BC
        		EXX
        		DEC     C
        		RET
;
DIGITQ:			LD      A,(IX)
        		CP      '9'+1
        		CCF
        		RET     C
        		CP      '0'
        		RET
;
SIGNQ:			LD      A,(IX)
        		INC     IX
        		CP      ' '
        		JR      Z,SIGNQ
        		CP      '+'
        		RET     Z
        		CP      '-'
        		RET     Z
        		DEC     IX
        		RET

; =================================================================================================
; FROM eval.asm
; -------------------------------------------------------------------------------------------------
;
; Title:	BBC Basic Interpreter - Z80 version
;		Expression Evaluation & Arithmetic Module - "EVAL"
; Author:	(C) Copyright  R.T.Russell  1984
; Modified By:	Dean Belfield
; Created:	12/05/2023
; Last Updated:	17/08/2023
;
; Modinfo:
; 07/06/2023:	Modified to run in ADL mode
; 26/06/2023:	Fixed HEX and HEXSTR
; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
; 17/08/2023:	Added binary constants

; BINARY FLOATING POINT REPRESENTATION:
;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
;     8 BIT EXCESS-128 SIGNED EXPONENT
;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
;
; BINARY INTEGER REPRESENTATION:
;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
;
; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
;                             EXPONENT - C
;

;
; Table of addresses for functions
;
FUNTOK:			EQU	8DH			; First token number
;
FUNTBL:			DW24	DECODE			; Line number
			DW24	OPENIN			; OPENIN
			DW24	PTR			; PTR
			DW24	PAGEV			; PAGE
			DW24	TIMEV			; TIME
			DW24	LOMEMV			; LOMEM
			DW24	HIMEMV			; HIMEM
			DW24	ABSV			; ABS
			DW24	ACS			; ACS
			DW24	ADVAL			; ADVAL
			DW24	ASC			; ASC
			DW24	ASN			; ASN
			DW24	ATN			; ATN
			DW24	BGET			; BGET
			DW24	COS			; COS
			DW24	COUNTV			; COUNT
			DW24	DEG			; DEG
			DW24	ERLV			; ERL
			DW24	ERRV			; ERR
			DW24	EVAL_			; EVAL
			DW24	EXP			; EXP
			DW24	EXT			; EXT
			DW24	ZERO			; FALSE
			DW24	FN			; FN
			DW24	GET			; GET
			DW24	INKEY			; INKEY
			DW24	INSTR			; INSTR(
			DW24	INT_			; INT
			DW24	LEN			; LEN
			DW24	LN			; LN
			DW24	LOG			; LOG
			DW24	NOTK			; NOT
			DW24	OPENUP			; OPENUP
			DW24	OPENOT			; OPENOUT
			DW24	PI			; PI
			DW24	POINT			; POINT(
			DW24	POS			; POS
			DW24	RAD			; RAD
			DW24	RND			; RND
			DW24	SGN			; SGN
			DW24	SIN			; SIN
			DW24	SQR			; SQR
			DW24	TAN			; TAN
			DW24	TOPV			; TO(P)
			DW24	TRUE			; TRUE
			DW24	USR			; USR
			DW24	VAL			; VAL
			DW24	VPOS			; VPOS
			DW24	CHRS			; CHRS
			DW24	GETS			; GETS
			DW24	INKEYS			; INKEYS
			DW24	LEFTS			; LEFTS(
			DW24	MIDS			; MIDS(
			DW24	RIGHTS			; RIGHTS(
			DW24	STRS			; STR$
			DW24	STRING_			; STRINGS(
			DW24	EOF			; EOF
;
FUNTBL_END:		EQU	$
; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
TCMD:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reordered b/c EZ80ASM doesn't do order of operations
;
ANDK:			EQU     80H
DIVK:			EQU     81H
EORK:			EQU     82H
MODK:			EQU     83H
ORK:			EQU     84H
;
SOPTBL:			DW24	SLE			; <= (STRING)
			DW24	SNE			; <>
			DW24	SGE			; >=
			DW24	SLT			; <
			DW24	SEQ			; =
			DW24	SGT			; >
;
; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
;     Expression type is returned in A'F':
;        Numeric - A' bit 7=0, F' sign bit cleared.
;         String - A' bit 7=1, F' sign bit set.
; Floating-point or integer result returned in HLH'L'C
; Integer result denoted by C=0 and HLH'L' non-zero.
; String result returned in string accumulator, DE set.
;
; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
;               (2) ^
;               (3) * / MOD DIV
;               (4) + -
;               (5) = <> <= >= > <
;               (6) AND
;               (7) EOR OR

;
; Level 7: EOR and OR
;
EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
EXPR0A:			CP      EORK            	; Is operator EOR?
			JR      Z,EXPR0B		; Yes, so skip to next bit
			CP      ORK			; Is operator OR
			RET     NZ			; No, so return
;
EXPR0B:			CALL    SAVE            	; Save first operand
			CALL    EXPR1           	; Get second operand
			CALL    DOIT            	; Do the operation
			JR      EXPR0A          	; And continue
;
; Level 6: AND
;
EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
EXPR1A:			CP      ANDK			; Is operator AND?
			RET     NZ			; No, so return
			CALL    SAVE			; Save first operand
			CALL    EXPR2			; Get second operand
			CALL    DOIT			; Do the operation
			JR      EXPR1A			; And continue
;
; Level 5: Comparisons
;
EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
			CALL    RELOP?			; Is it ">", "=" or "<"?
			RET     NZ			; No, so return
			LD      B,A			; Store the first operator in B
			INC     IY              	; Bump over operator
			CALL    NXT			; 
			CALL    RELOP?          	; Is it a compound operator?
			JR      NZ,EXPR2B		; No, so skip next bit
			INC     IY			; Bump over operator
			CP      B			; Compare with first
			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
			ADD     A,B			
			LD      B,A			; B: Unique code for the compound operator
EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
			EX      AF,AF'
			JP      M,EXPR2S		; If it is a string, then branch here to handle it
			EX      AF,AF'
			SUB     4
			CP      '>'-4
			JR      NZ,EXPR2C
			ADD     A,2
EXPR2C:			CALL    SAVE1
			CALL    EXPR3
			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
			RET
;
EXPR2S:			EX      AF,AF'			; Handle string comparisons
			DEC     A
			AND     7
			CALL    PUSHS           	; Save string on the stack
			PUSH    AF              	; Save the operator
			CALL    EXPR3           	; Get the second string
			EX      AF,AF'
			JP      P,TYPE_EVAL
			POP     AF
			LD      C,E             	; Length of string #2
			POP     DE
			LD      HL,0
			ADD     HL,SP
			LD      B,E             	; Length of string #1
			PUSH    DE
			LD      DE,ACCS
			EX      DE,HL
			CALL    DISPT2
			POP     DE
			EX      DE,HL
			LD	A,L
			LD	HL,0
			LD	L,A
			ADD     HL,SP
			LD      SP,HL
			EX      DE,HL
			XOR     A               	; Numeric marker
			LD      C,A             	; Integer marker
			EX      AF,AF'
			LD      A,(IY)
			RET
;
; Level 4: + and -
;
EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
EXPR3A:			CP      '-'			; Is it "-"?
			JR      Z,EXPR3B		; Yes, so skip the next bit
			CP      '+'			; Is it "+"?
			RET     NZ			; No, so return
			EX      AF,AF'			; Get the type
			JP      M,EXPR3S		; Branch here if string
			EX      AF,AF'
EXPR3B:			CALL    SAVE			; Save the first operator
			CALL    EXPR4			; Fetch the second operator
			CALL    DOIT			; Do the operation
			JR      EXPR3A			; And continue
;
EXPR3S:			EX      AF,AF'			; Handle string concatenation
			INC     IY              	; Bump past the "+"
			CALL    PUSHS           	; Save the string on the stack
			CALL    EXPR4           	; Fetch the second operator
			EX      AF,AF'
			JP      P,TYPE_EVAL			; If it is not a string, then Error: "Type mismatch"
			LD	BC, 0			; Clear BC
			LD      C,E             	; C: Length of the second string
			POP     DE
			PUSH    DE
			LD      HL,ACCS
			LD	A,E			;  E: Length of the first string
			LD      DE,ACCS
			LD	E,A 			; DE: Pointer to the end of the first string
			LD      A,C			
			OR      A
			JR      Z,EXP3S3
			LD      L,A             	; Source
			ADD     A,E
			LD      E,A             	; Destination
			LD      A,19
			JP      C,ERROR_EVAL         	; A carry indicates string > 255 bytes, so Error: "String too long"
			PUSH    DE
			DEC     E
			DEC     L
			LDDR                    	; Copy
			POP     DE
EXP3S3:			EXX
			POP     BC
			CALL    POPS            	; Restore from stack
			EXX
			OR      80H             	; Flag as a string
			EX      AF,AF'
			LD      A,(IY)			; Fetch the next character
			JR      EXPR3A			; And continue
;
; Level 3: * / MOD DIV
;
EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
EXPR4A:			CP      '*'			; "*" is valid
			JR      Z,EXPR4B
			CP      '/'			; "/" is valid
			JR      Z,EXPR4B
			CP      MODK			; MOD token is valid
			JR      Z,EXPR4B
			CP      DIVK			; DIV token is valid
			RET     NZ			; And return if it is anything else
EXPR4B:			CALL    SAVE
			CALL    EXPR5
			CALL    DOIT
			JR      EXPR4A
;
; Level 2: ^
;
EXPR5:			CALL    ITEM			; Get variable
			OR      A               	; Test type
			EX      AF,AF'          	; Save type 
EXPR5A:			CALL    NXT			; Skip spaces
			CP      '^'			; Is the operator "^"?
			RET     NZ			; No, so return
			CALL    SAVE			; Save first operand
			CALL    ITEM			; Get second operand
			OR      A			; Test type
			EX      AF,AF'			; Save type
			CALL    DOIT			; Do the operation
			JR      EXPR5A			; And continue
;
; Evaluate a numeric expression
;
EXPRN:			CALL    EXPR			; Evaluate expression
			EX      AF,AF'			; Get the type
			RET     P			; And return if it is a number
			JR      TYPE_EVAL			; Otherwise Error: "Type mismatch"
;
; Evaluate a fixed-point expression 
;
EXPRI:			CALL    EXPR			; Evaluate the expression
			EX      AF,AF'			; Get the type
			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
			JR      TYPE_EVAL			; Otherwise Error: "Type mismatch"
;	
; Evaluate a string expression
;	
EXPRS:			CALL    EXPR			; Evaluate the expression
			EX      AF,AF'			; Get the type
			RET     M			; And return if it is a string
			JR      TYPE_EVAL			; Otherwise Error: "Type mismatch"
;
; Get a numeric variable
;
ITEMN:			CALL    ITEM			; Get the variable
			OR      A			; Test the type
			RET     P			; And return if it is a number
			JR      TYPE_EVAL			; Otherwise Error: "Type mismatch"
;
; Get a fixed-point variable 
;
ITEMI:			CALL    ITEM			; Get the variable
			OR      A			; Test the type
			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
			JR      TYPE_EVAL			; Otherwise Error: "Type mismatch"
;
; Get a string variable 
;
ITEMS:			CALL    ITEM			; Get the variable
			OR      A			; Test the type
			RET     M			; If it is a string, then return
;							; Otherwise
TYPE_EVAL:			LD      A,6			; Error: "Type mismatch"
			JP      ERROR_EVAL           	
;
; Evaluate a bracketed expression
;
ITEM1:			CALL    EXPR            	; Evaluate the expression
			CALL    BRAKET			; Check for closing bracket
			EX      AF,AF'
			RET
;
; HEX - Get hexadecimal constant.
;   Inputs: ASCII string at (IY)
;  Outputs: Integer result in H'L'HL, C=0, A7=0.
;           IY updated (points to delimiter)
;
HEX:			CALL    ZERO			; Set result to 0
			CALL    HEXDIG			; Fetch the character from IY
			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
HEX1:			INC     IY			; Move pointer to next character
			AND     0FH			; Clear the top nibble
			LD      B,4			; Loop counter
;
HEX2:			EXX				; Shift the result left B (4) times. This makes
			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
			EXX				; .
			ADC.S   HL,HL			; .
			DJNZ    HEX2			; And loop
			EXX
			OR      L			; OR in the digit
			LD      L,A
			EXX
;
			CALL    HEXDIG			; Fetch the next character
			JR      NC,HEX1			; If it is a HEX digit then loop
			XOR     A			; Clear A
			RET
;
BADHEX:			LD      A,28
			JP      ERROR_EVAL          	; Error: "Bad HEX"
;
; BIN - Get binary constant.
;   Inputs: ASCII string at (IY)
;  Outputs: Integer result in H'L'HL, C=0, A7=0.
;           IY updated (points to delimiter)
;
BIN:			CALL    ZERO			; Set result to 0
			CALL	BINDIG			; Fetch the character from IY
			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
BIN1:			INC	IY			; Move pointer to next character
			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
			EXX				; 
			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
			EXX
			ADC.S	HL,HL
			CALL	BINDIG			; Fetch the next character
			JR	NC,BIN1
			XOR	A			; Clear A
			RET
;
BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
			CALL	EXTERR
			DB	"Bad Binary", 0
;
; MINUS - Unary minus.
;   Inputs: IY = text pointer
;  Outputs: Numeric result, same type as argument.
;           Result in H'L'HLC
;
MINUS:			CALL    ITEMN			; Get the numeric argument
MINUS0:			DEC     C			; Check exponent (C)
			INC     C			; If it is zero, then it's either a FP zero or an integer
			JR      Z,@NEGATE        	; So do an integer negation
;
			LD      A,H			; Do a FP negation by 
			XOR     80H             	; Toggling the sign bit (H)
			LD      H,A
			XOR     A               	; Numeric marker
			RET
;
@NEGATE:			EXX				; This section does a two's complement negation on H'L'HLC
			LD      A,H			; First do a one's complement by negating all the bytes
			CPL
			LD      H,A
			LD      A,L
			CPL
			LD      L,A
			EXX
			LD      A,H
			CPL
			LD      H,A
			LD      A,L
			CPL
			LD      L,A
@ADD1:			EXX				; Then add 1
			INC     HL			
			LD      A,H
			OR      L
			EXX
			LD      A,0             	; Numeric marker
			RET     NZ
			INC     HL
			RET
;
; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
; Item type is returned in A:  Bit 7=0 numeric.
;                              Bit 7=1 string.
; Numeric item returned in HLH'L'C.
; String item returned in string accumulator,
;   DE addresses byte after last (E=length).
;
ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
			CALL    NXT			; Skip spaces
			INC     IY			; Move to the prefix character
			CP      '&'			; If `&`
			JP      Z,HEX           	; Then get a HEX constant
			CP	'%'			; If '%'
			JR	Z,BIN			; Then get a BINARY constant
			CP      '-'			; If `-`
			JR      Z,MINUS         	; Then get a negative number
			CP      '+'			; If `+`
			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
			CP      '('			; If `(`
			JP      Z,ITEM1         	; Start of a bracketed expression
			CP      34			; If `"`
			JR      Z,CONS          	; Start of a string constant
			CP      TCMD			; Is it out of range of the function table?
			JP      NC,SYNTAX       	; Error: "Syntax Error"
			CP      FUNTOK			; If it is in range, then 
			JP      NC,DISPAT       	; It's a function
			DEC     IY			
			CP      ':'
			JR      NC,ITEM2		; VARIABLE?
			CP      '0'
			JP      NC,CON_EVAL			; NUMERIC CONSTANT
			CP      '.'
			JP      Z,CON_EVAL			; NUMERIC CONSTANT
ITEM2:			CALL    GETVAR			; VARIABLE
			JR      NZ,NOSUCH
			OR      A
			JP      M,LOADS			; STRING VARIABLE
LOADN:			OR      A
			JR      Z,LOAD1			; BYTE VARIABLE
			LD      C,0
			BIT     0,A
			JR      Z,LOAD4			; INTEGER VARIABLE
LOAD5:			LD      C,(IX+4)
LOAD4:			EXX
			LD	HL, 0			; TODO: Optimise
			LD      L,(IX+0)
			LD      H,(IX+1)
			EXX
			LD	HL, 0			; TODO: Optimise
			LD      L,(IX+2)
			LD      H,(IX+3)
			RET
;
LOAD1:			LD      HL,0
			EXX
			LD      HL,0			; TODO: Optimise
			LD      L,(IX+0)
			EXX
			LD      C,H
			RET
;
NOSUCH:			JP      C,SYNTAX
			LD      A,(LISTON)
			BIT     5,A
			LD      A,26
			JR      NZ,ERROR0		; Throw "No such variable"
NOS1:			INC     IY
			CALL    RANGE
			JR      NC,NOS1
			LD      IX,PC
			XOR     A
			LD      C,A
			JR      LOAD4
;
;CONS - Get string constant from ASCII string.
;   Inputs: ASCII string at (IY)
;  Outputs: Result in string accumulator.
;           D = MS byte of ACCS, E = string length
;           A7 = 1 (string marker)
;           IY updated
;
CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
CONS3:			LD      A,(IY)			; Fetch the first character and
			INC     IY			; Increment the pointer
			CP      '"'			; Check for start quote
			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
;
CONS1:			LD      (DE),A			; Store the character in the string accumulator
			INC     E			; Increment the string accumulator pointer
			CP      CR			; Is it CR
			JR      NZ,CONS3		; No, so keep looping
;
			LD      A,9
ERROR0:			JP      ERROR_EVAL           	; Throw error "Missing '"'
;
CONS2:			LD      A,(IY)			; Fetch the next character
			CP      '"'			; Check for end quote?
			INC     IY			; Increment the pointer
			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
			DEC     IY			; 
			LD      A,80H           	; String marker
			RET
;
;CON_EVAL - Get unsigned numeric constant from ASCII string.
;   Inputs: ASCII string at (IY).
;  Outputs: Variable-type result in HLH'L'C
;           IY updated (points to delimiter)
;           A7 = 0 (numeric marker)
;
CON_EVAL:			PUSH    IY
			POP     IX
			LD      A,36
			CALL    FPP
			JR      C,ERROR0
			PUSH    IX
			POP     IY
			XOR     A
			RET
;
LOADS:			LD      DE,ACCS			; Where to store the string
			RRA
			JR      NC,LOADS2       	; Skip if it is a fixed string
;
			EXX				; This block was a call to LOAD4
			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
			LD      H,(IX+1)		; The maximum original string length
			EXX
			LD	HL,(IX+2)		; Address of the string (24-bit)
;
			EXX
			LD      A,L
			EXX
			OR      A
			LD	BC,0			; BC: Number of bytes to copy
			LD      C,A
			LD      A,80H           	; String marker
			RET     Z
			LDIR
			RET
LOADS2:			LD      A,(HL)
			LD      (DE),A
			INC     HL
			CP      CR
			LD      A,80H           	; String marker
			RET     Z
			INC     E
			JR      NZ,LOADS2
			RET                     	; Return null string
;
;VARIABLE-TYPE FUNCTIONS:
;
;Result returned in HLH'L'C (floating point)
;Result returned in HLH'L' (C=0) (integer)
;Result returned in string accumulator & DE (string)
;All registers destroyed.
;IY (text pointer) updated.
;Bit 7 of A indicates type: 0 = numeric, 1 = string.
;
;POS - horizontal cursor position.
;VPOS - vertical cursor position.
;EOF - return status of file.
;BGET - read byte from file.
;INKEY - as GET but wait only n centiseconds.
;GET - wait for keypress and return ASCII value.
;GET(n) - input from Z80 port n.
;ASC - ASCII value of string.
;LEN - length of string.
;LOMEM - location of dynamic variables.
;HIMEM - top of available RAM.
;PAGE - start of current text page.
;TOP - address of first free byte after program.
;ERL - line number where last error occurred.
;ERR - number of last error.
;COUNT - number of printing characters since CR.
;Results are integer numeric.
;
POS:			CALL    GETCSR			; Return the horizontal cursor position
			EX      DE,HL			;  L: The X cursor position
			JP      COUNT1			; Return an 8-bit value
;			
VPOS:			CALL    GETCSR			; Return the vertical cursor position
			JP      COUNT1			; Return an 8-bit value
;			
EOF:			CALL    CHANEL			; Check for EOF
			CALL    OSSTAT
			JP      Z,TRUE			; Yes, so return true
			JP      ZERO			; Otherwise return false (zero)
;			
BGET:			CALL    CHANEL          	; Channel number
			CALL    OSBGET
			LD      L,A
			JP      COUNT0			; Return an 8-bit value
;			
INKEY:			CALL    ITEMI			; Get the argument
			BIT	7, H			; Check the sign
			EXX				; HL: The argument
			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
			CALL	INKEY0 			; Do INKEY(n)
			JR      ASC0			; Return a numeric value
;			
GET:			CALL    NXT			; Skip whitespace
			CP      '('			; Is it GET(
			JR      NZ,GET0			; No, so get a keyboard character
			CALL    ITEMI           	; Yes, so fetch the port address
			EXX
			LD      B,H			; BC: The port address
			LD      C,L
			IN      L,(C)           	;  L: Input from port BC
			JR      COUNT0			; Return an 8-bit value
;
GET0:			CALL    GETS			; Read the keyboard character			
			JR      ASC1			; And return the value
;			
ASC:			CALL    ITEMS			; Get the string argument argument
ASC0:			XOR     A			; Quickly check the length of the string in ACCS
			CP      E			; Is the pointer 0
			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
			JR      COUNT0			; An 8-bit value
;
LEN:			CALL    ITEMS			; Get the string argument
			EX      DE,HL			; HL: Pointer into ACCS
			JR      COUNT0			; Return L
;			
LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
			LD	A, (LOMEM+2)
			JR      COUNT2			; A 24-bit value
;			
HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
			LD	A, (HIMEM+2)
			JR      COUNT2			; A 24-bit value
;			
PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
			LD	A, (PAGE_+2)		; A 24-bit value
			JR      COUNT2
;			
TOPV:			LD      A,(IY)			; Return the TOP system variable
			INC     IY              	; Skip "P"
			CP      'P'
			JP      NZ,SYNTAX       	; Throw "Syntax Error"
			LD      HL,(TOP)
			LD	A, (TOP+2)
			JR      COUNT2
;			
ERLV:			LD      HL,(ERL)		; Return the error line
			JR      COUNT1			; A 16-bit value
;			
ERRV:			LD      HL,(ERR)		; Return the error value
			JR      COUNT0			; An 8-bit value
;			
COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar

COUNT0:			LD      H,0			; Return L
COUNT1:			EXX				; Return HL
			XOR     A
			LD      C,A             	; Integer marker
			LD      H,A
			LD      L,A
			RET
COUNT2:			EXX
			LD	L,A 
			XOR	A 
			LD	C,A			; Integer marker
			LD	H,A 
			RET
;
;OPENIN - Open a file for reading.
;OPENOT - Open a file for writing.
;OPENUP - Open a file for reading or writing.
;Result is integer channel number (0 if error)
;
OPENOT:			XOR     A			; Open for writing
			JR	OPENIN_1
;			
OPENUP:			LD      A,2			; Open for reading / writing
			JR	OPENIN_1
;
OPENIN:			LD      A,1			; Open for reading
;
OPENIN_1:		PUSH    AF              	; Save OPEN type
			CALL    ITEMS           	; Fetch the filename
			LD      A,CR
			LD      (DE),A
			POP     AF              	; Restore the OPEN type
			ADD     A,-1            	; Affect the flags
			LD      HL,ACCS
			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
			LD      L,A			; L: Channel number
			JR      COUNT0			; Return channel number to BASIC
;
;EXT - Return length of file.
;PTR - Return current file pointer.
;Results are integer numeric.
;
EXT:			CALL    CHANEL
			CALL    GETEXT
			JR      TIME0
;
PTR:			CALL    CHANEL
			CALL    GETPTR
			JR      TIME0
;
;TIME - Return current value of elapsed time.
;Result is integer numeric.
;
TIMEV:			LD      A,(IY)
			CP      '$'
			JR      Z,TIMEVS
			CALL    GETIME
TIME0:			PUSH    DE
			EXX
			POP     HL
			XOR     A
			LD      C,A
			RET
;
;TIME$ - Return date/time string.
;Result is string
;
TIMEVS:			INC     IY              ;SKIP $
			CALL    GETIMS
			LD      A,80H           ;MARK STRING
			RET
;
;String comparison:
;
SLT:			CALL    SCP
			RET     NC
			JR      TRUE_TIMEVS
;
SGT:			CALL    SCP
			RET     Z
			RET     C
			JR      TRUE_TIMEVS
;
SGE:			CALL    SCP
			RET     C
			JR      TRUE_TIMEVS
;
SLE:			CALL    SCP
			JR      Z,TRUE_TIMEVS
			RET     NC
			JR      TRUE_TIMEVS
;
SNE:			CALL    SCP
			RET     Z
			JR      TRUE_TIMEVS
;
SEQ:			CALL    SCP
			RET     NZ
; TRUE:			LD      A,-1
TRUE_TIMEVS:			LD      A,-1
			EXX
			LD      H,A
			LD      L,A
			EXX
			LD      H,A
			LD      L,A
			INC     A
			LD      C,A
			RET
;
;PI - Return PI (3.141592654)
;Result is floating-point numeric.
;
PI:			LD      A,35
			JR      FPP1
;
;ABS - Absolute value
;Result is numeric, variable type.
;
ABSV:			LD      A,16
			JR      FPPN
;
;NOT - Complement integer.
;Result is integer numeric.
;
NOTK:			LD      A,26
			JR      FPPN
;
;DEG - Convert radians to degrees
;Result is floating-point numeric.
;
DEG:			LD      A,21
			JR      FPPN
;
;RAD - Convert degrees to radians
;Result is floating-point numeric.
;
RAD:			LD      A,27
			JR      FPPN
;
;SGN - Return -1, 0 or +1
;Result is integer numeric.
;
SGN:			LD      A,28
			JR      FPPN
;
;INT - Floor function
;Result is integer numeric.
;
INT_:			LD      A,23
			JR      FPPN
;
;SQR - square root
;Result is floating-point numeric.
;
SQR:			LD      A,30
			JR      FPPN
;
;TAN - Tangent function
;Result is floating-point numeric.
;
TAN:			LD      A,31
			JR      FPPN
;
;COS - Cosine function
;Result is floating-point numeric.
;
COS:			LD      A,20
			JR      FPPN
;
;SIN - Sine function
;Result is floating-point numeric.
;
SIN:			LD      A,29
			JR      FPPN
;
;EXP - Exponential function
;Result is floating-point numeric.
;
EXP:			LD      A,22
			JR      FPPN
;
;LN - Natural log.
;Result is floating-point numeric.
;
LN:			LD      A,24
			JR      FPPN
;
;LOG - base-10 logarithm.
;Result is floating-point numeric.
;
LOG:			LD      A,25
			JR      FPPN
;
;ASN - Arc-sine
;Result is floating-point numeric.
;
ASN:			LD      A,18
			JR      FPPN
;
;ATN - arc-tangent
;Result is floating-point numeric.
;
ATN:			LD      A,19
			JR      FPPN
;
;ACS - arc-cosine
;Result is floating point numeric.
;
ACS:			LD      A,17
FPPN:			PUSH    AF
			CALL    ITEMN
			POP     AF
FPP1:			CALL    FPP
			JP      C,ERROR_EVAL
			XOR     A
			RET
;
;SFIX - Convert to fixed-point notation
;
SFIX:			LD      A,38
			JR      FPP1
;
;SFLOAT - Convert to floating-point notation
;
SFLOAT:			LD      A,39
			JR      FPP1
;
;VAL - Return numeric value of string.
;Result is variable type numeric.
;
VAL:			CALL    ITEMS
VAL0:			XOR     A
			LD      (DE),A
			LD      IX,ACCS
			LD      A,36
			JR      FPP1
;
;EVAL - Pass string to expression evaluator.
;Result is variable type (numeric or string).
;
EVAL_:			CALL    ITEMS
			LD      A,CR
			LD      (DE),A
			PUSH    IY
			LD      DE,ACCS
			LD      IY,ACCS
			LD      C,0
			CALL    LEXAN2          ;TOKENISE
			LD      (DE),A
			INC     DE
			XOR     A
			CALL    PUSHS           ;PUT ON STACK
			LD      IY,SIZEW	;WAS 2
			ADD     IY,SP
			CALL    EXPR
			POP     IY
			ADD     IY,SP
			LD      SP,IY           ;ADJUST STACK POINTER
			POP     IY
			EX      AF,AF'
			RET
;
;RND - Random number function.
; RND gives random integer 0-&FFFFFFFF
; RND(-n) seeds random number & returns -n.
; RND(0) returns last value in RND(1) form.
; RND(1) returns floating-point 0-0.99999999.
; RND(n) returns random integer 1-n.
;
RND:			LD      IX,RANDOM
			CALL    NXT
			CP      '('
			JR      Z,RND5          ;ARGUMENT FOLLOWS
			CALL    LOAD5
RND1:			RR      C
			LD      B,32
RND2:			EXX                     ;CALCULATE NEXT
			ADC.S   HL,HL
			EXX
			ADC.S   HL,HL
			BIT     3,L
			JR      Z,RND3
			CCF
RND3:			DJNZ    RND2
RND4:			RL      C               ;SAVE CARRY
			CALL    STORE5          ;STORE NEW NUMBER
			XOR     A
			LD      C,A
			RET
RND5:			CALL    ITEMI
			LD      IX,RANDOM
			BIT     7,H             ;NEGATIVE?
			SCF
			JR      NZ,RND4         ;SEED
			CALL    TEST
			PUSH    AF
			CALL    SWAP
			EXX
			CALL    LOAD5
			CALL    NZ,RND1         ;NEXT IF NON-ZERO
			EXX                     ;SCRAMBLE (CARE!)
			LD      C,7FH
RND6:			BIT     7,H             ;FLOAT
			JR      NZ,RND7
			EXX
			ADD.S   HL,HL
			EXX
			ADC.S   HL,HL
			DEC     C
			JR      NZ,RND6
RND7:			RES     7,H             ;POSITIVE 0-0.999999
			POP     AF
			RET     Z               ;ZERO ARGUMENT
			EXX
			LD      A,E
			DEC     A
			OR      D
			EXX
			OR      E
			OR      D
			RET     Z               ;ARGUMENT=1
			LD      B,0             ;INTEGER MARKER
			LD      A,10
			CALL    FPP             ;MULTIPLY
			JP      C,ERROR_EVAL
			CALL    SFIX
			JP      ADD1
;
; INSTR - String search.
; Result is integer numeric.
;
INSTR:			CALL    EXPRSC			; Get the first string expression
			CALL    PUSHS           	; Push the string onto the stack
			CALL    EXPRS           	; Get the second string expression
			POP     BC			;  C: String length, B: Value of A before PUSHS was called
			LD      HL,0
			ADD     HL,SP           	; HL: Pointer to main string
			PUSH    BC              	;  C: Main string length
			LD      B,E             	;  B: Sub-string length
			CALL    NXT			; Skip whitespace
			CP      ','			; Check if there is a comma for the third parameter
			LD      A,0			;  A: Default start position in string
			JR      NZ,INSTR1		; No, so skip the next bit
			INC     IY              	; Skip the comma
			PUSH    BC              	; Save the lengths
			PUSH    HL              	; Save the pointer to the main string
			CALL    PUSHS			; Push the string onto the stack
			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
			CALL    POPS			; Pop the string off the stack
			POP     HL              	; Restore the pointer to the main string
			POP     BC              	; Restore the lengths
			EXX
			LD      A,L			; A: The start position in the  string
			EXX
			OR      A			; Set the flags
			JR      Z,INSTR1		; If it is zero, then skip
			DEC     A
INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
			CALL    SEARCH			; Do the search
			POP     DE
			JR      Z,INSTR2        	; NB: Carry cleared
			SBC     HL,HL
			ADD     HL,SP
INSTR2:			SBC     HL,SP
			EX      DE,HL
			LD	A,L
			LD      HL,0
			LD	L,A
			ADD     HL,SP
			LD      SP,HL
			EX      DE,HL
			CALL    BRAKET			; Check for closing bracket
			JP      COUNT1			; Return a numeric integer
;
; SEARCH - Search string for sub-string
;    Inputs: Main string at HL length C
;            Sub-string  at DE length B
;            Starting offset A
;   Outputs: NZ - not found
;            Z - found at location HL-1
;            Carry always cleared
;
SEARCH:			PUSH    BC			; Add the starting offset to HL
			LD      BC,0
			LD      C,A
			ADD     HL,BC           	; New start address
			POP     BC
			SUB     C			; If the starting offset > main string length, then do nothing
			JR      NC,SRCH4
			NEG
			LD      C,A             	; Remaining length
;
SRCH1:			PUSH    BC
			LD	A,C
			LD	BC,0
			LD	C,A
			LD      A,(DE)
			CPIR                    	; Find the first character
			LD      A,C
			POP     BC
			JR      NZ,SRCH4
			LD      C,A
;
; This block of four instructions was commented as a bug fix by R.T.Russell
;
			DEC     B			; Bug fix
			CP      B			; Bug fix
			INC     B			; Bug fix
			JR      C,SRCH4			; Bug fix
;			
			PUSH    BC
			PUSH    DE
			PUSH    HL
			DEC     B
			JR      Z,SRCH3         	; Found!
SRCH2:			INC     DE
			LD      A,(DE)
			CP      (HL)
			JR      NZ,SRCH3
			INC     HL
			DJNZ    SRCH2
SRCH3:			POP     HL
			POP     DE
			POP     BC
			JR      NZ,SRCH1
			XOR     A               	; Flags: Z, NC
			RET                     	; Found
;
SRCH4:			OR      0FFH            	; Flags: NZ, NC
			RET                     	; Not found
;
;CHRS - Return character with given ASCII value.
;Result is string.
;
CHRS:			CALL    ITEMI
			EXX
			LD      A,L
			JR      GET1
;
;GETS - Return key pressed as stringor character at position (X,Y).
;Result is string.
;
GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
			CP	'('
			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
			CALL    OSRDCH
GET1:			SCF
			JR      INKEY1
;
; INKEYS - Wait up to n centiseconds for keypress.
;          Return key pressed as string or null
;          string if time elapsed.
; Result is string.
;
INKEYS:			CALL    ITEMI			; Fetch the argument
			EXX
INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
			LD      (DE),A
			LD      A,80H
			RET     NC
			INC     E
			RET
;
; INKEYM - Check immediately whether a given key is being pressed
; Result is integer numeric
;
INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
			INC	HL			; Index from 0
			LD	A, L			; Negate the LSB of the answer
			NEG
			LD	C, A			;  E: The positive keycode value
			LD	A, 1			; Throw an "Out of range" error
			JP	M, ERROR_EVAL		; if the argument < - 128
;
			LD	HL, BITLOOKUP		; HL: The bit lookup table
			LD	DE, 0
			LD	A, C
			AND	00000111b		; Just need the first three bits
			LD	E, A			; DE: The bit number
			ADD	HL, DE
			LD	B, (HL)			;  B: The mask
;
			LD	A, C			; Fetch the keycode again
			AND	01111000b		; And divide by 8
			RRCA
			RRCA
			RRCA
			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
			ADD	IX, DE			; IX: The address
			LD	A, B			;  B: The mask
			AND	(IX+0)			; Check whether the bit is set
			JP	Z, ZERO			; No, so return 0
			JP	TRUE			; Otherwise return -1
;
; A bit lookup table
;
BITLOOKUP:		DB	01h, 02h, 04h, 08h
			DB	10h, 20h, 40h, 80h
;
; MID$ - Return sub-string.
; Result is string.
;
MIDS:			CALL    EXPRSC			; Get the first string expression
			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
			CALL    EXPRI			; Get the second expression
			POP     BC			; C: String length, B: Value of A before PUSHS was called
			CALL    POPS			; Pop the string back off the stack to the string accumulator
			EXX
			LD      A,L			; A: The start index
			EXX
			OR      A			; If the start index is 0, then we don't need to do the next bit
			JR      Z,MIDS1
			DEC     A			
			LD      L,A			; L: The start index - 1
			SUB     E			; Subtract from the string length
			LD      E,0			; Preemptively set the string length to 0
			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
			NEG				; Negate the answer and
			LD      C,A			; C: Number of bytes to copy
			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
MIDS1:			CALL    NXT			; Skip whitespace
			CP      ','			; Check for a comma
			INC     IY			; Advance to the next character in the BASIC line
			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
			DEC     IY			; Restore the BASIC program pointer
			CALL    BRAKET			; Check for a bracket
			LD      A,80H			; String marker
			RET
;
; LEFT$ - Return left part of string.
; Carry cleared if entire string returned.
; Result is string.
;
LEFTS:			CALL    EXPRSC			; Get the first string expression
LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
			CALL    EXPRI			; Get the second expression
			POP     BC			; C: String length, B: Value of A before PUSHS was called
			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
			CALL    BRAKET			; Check for closing bracket
			EXX
			LD      A,L			; L: The second parameter
			EXX
			CP      E			; Compare with the string length
			JR      NC,LEFT3		; If it is greater than or equal then do nothing
			LD      L,E             	; For RIGHTS, no effect in LEFTS
LEFT2:			LD      E,A			; E: The new length of string
LEFT3:			LD      A,80H           	; String marker
			RET
;
; RIGHT$ - Return right part of string.
; Result is string.
;
RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
			RET     NC			; Do nothing if the second parameter is >= string length
			INC     E			; Check for a zero length string
			DEC     E
			RET     Z			; Yes, so do nothing
			LD      C,E			;  C: Number of bytes to copy
			LD      A,L
			SUB     E
			LD      L,A			;  L: Index into the string
RIGHT1:			LD	A,C
			LD	BC,0
			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
			LD	A,L
			LD	HL,ACCS
			LD	L,A			; HL: Source (in ACCS)
			LD      DE,ACCS			; DE: Destination (start of ACCS)
			LDIR                    	; Copy
			LD      A,80H			; String marker
			RET
;
; STRINGS - Return n concatenations of a string.
; Result is string.
;
STRING_:		CALL    EXPRI			; Get number of times to replicate
			CALL    COMMA			; Check for comma
			EXX
			LD      A,L			; L: Number of iterations of string
			EXX
			PUSH    AF
			CALL    EXPRS			; Get the string
			CALL    BRAKET			; Check for closing bracket
			POP     AF			; A: Number of iterations of string
			OR      A			; Set flags
			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
			DEC     A
			LD      C,A			; C: Loop counter
			LD      A,80H			; String marker
			RET     Z
			INC     E			; Check for empty string
			DEC     E
			RET     Z              		; And return
			LD      B,E			; B: String length tally
			LD	HL,ACCS
STRIN1:			PUSH    BC
STRIN2:			LD      A,(HL)
			INC     HL
			LD      (DE),A
			INC     E
			LD      A,19
			JP      Z,ERROR_EVAL         	; Throw a "String too long" error
			DJNZ    STRIN2
			POP     BC
			DEC     C
			JR      NZ,STRIN1
			LD      A,80H
			RET
;
;SUBROUTINES
;
;SWAP - Swap arguments
;Exchanges DE,HL D'E',H'L' and B,C
;Destroys: A,B,C,D,E,H,L,D',E',H',L'
;
SWAP:			LD      A,C
			LD      C,B
			LD      B,A
			EX      DE,HL
			EXX
			EX      DE,HL
			EXX
			RET
;
;TEST - Test HLH'L' for zero
;Outputs: Z-flag set & A=0 if zero
;Destroys: A,F
;
TEST:			LD      A,H
			OR      L
			EXX
			OR      H
			OR      L
			EXX
			RET
;
;DECODE - Decode line number in pseudo-binary.
;   Inputs: IY = Text pointer.
;   Outputs: HL=0, H'L'=line number, C=0.
;   Destroys: A,C,H,L,H',L',IY,F
;
DECODE:			EXX
			LD	HL, 0
			LD      A,(IY)
			INC     IY
			RLA
			RLA
			LD      H,A
			AND     0C0H
			XOR     (IY)
			INC     IY
			LD      L,A
			LD      A,H
			RLA
			RLA
			AND     0C0H
			XOR     (IY)
			INC     IY
			LD      H,A
			EXX
;			XOR     A
;			LD      C,A
;			LD      H,A
;			LD      L,A
			LD	HL, 0
			LD	C, L
			RET
;
;HEXSTR - convert numeric value to HEX string.
;   Inputs: HLH'L'C = integer or floating-point number
;  Outputs: String in string accumulator.
;           E = string length.  D = ACCS/256
;
HEXSTS:			INC     IY              ;SKIP TILDE
			CALL    ITEMN
			CALL    HEXSTR
			LD      A,80H
			RET
;
HEXSTR:			CALL    SFIX
			LD      BC,8
			LD      DE,ACCS
HEXST1:			PUSH    BC
			LD      B,4
			XOR     A
HEXST2:			EXX
			ADD.S	HL,HL
			EXX
			ADC.S	HL,HL
			RLA
			DJNZ    HEXST2
			POP     BC
			DEC     C
			RET     M
			JR      Z,HEXST3
			OR      A
			JR      NZ,HEXST3
			CP      B
			JR      Z,HEXST1
HEXST3:			ADD     A,90H
			DAA
			ADC     A,40H
			DAA
			LD      (DE),A
			INC     DE
			LD      B,A
			JR      HEXST1
;
;Function STR - convert numeric value to ASCII string.
;   Inputs: HLH'L'C = integer or floating-point number.
;  Outputs: String in string accumulator.
;           E = length, D = ACCS/256
;           A = 80H (type=string)
;
;First normalise for decimal output:
;
STRS:			CALL    NXT
			CP      '~'
			JR      Z,HEXSTS
			CALL    ITEMN
			LD      IX,STAVAR
			LD      A,(IX+3)
			OR      A
			LD      IX,G9-1         ;G9 FORMAT
			JR      Z,STR0
STR:			LD      IX,STAVAR
STR0:			LD      DE,ACCS
			LD      A,37
			CALL    FPP
			JP      C,ERROR_EVAL
			BIT     0,(IX+2)
STR1:			LD      A,80H           ;STRING MARKER
			RET     Z
			LD      A,C
			ADD     A,4
STR2:			CP      E
			JR      Z,STR1
			EX      DE,HL	
			LD      (HL),' '        ;TRAILING SPACE
			INC     HL
			EX      DE,HL
			JR      STR2
;
G9:			DW    9
;
;STRING COMPARE
;Compare string (DE) length B with string (HL) length C.
;Result preset to false.
;
SCP:			CALL	SCP0
;
ZERO:			LD      A,0
			EXX
			LD      H,A
			LD      L,A
			EXX
			LD      H,A
			LD      L,A
			LD      C,A
			RET
;
SCP0:			INC     B
			INC     C
SCP1:			DEC     B
			JR      Z,SCP2
			DEC     C
			JR      Z,SCP3
			LD      A,(DE)
			CP      (HL)
			RET     NZ
			INC     DE
			INC     HL
			JR      SCP1
SCP2:			OR      A
			DEC     C
			RET     Z
			SCF
			RET
SCP3:			OR      A
			INC     C
			RET
;
; PUSHS - SAVE STRING ON STACK.
;     Inputs: String in string accumulator.
;             E = string length.
;             A - saved on stack.
;   Destroys: B,C,D,E,H,L,IX,SP,F
;
PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
			POP     IX              	; IX: Return address
			OR      A               	; Clear the carry flag
			LD	BC,0			; BC: Length of the string
			LD	C,E
			LD      HL,ACCS			; HL: Pointer to the string accumulator
			LD	DE,ACCS
			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
			ADD     HL,SP			; Grow the stack
			LD      SP,HL
			LD      D,A			;  D: This needs to be set to A for some functions
			LD	B,A			; Stack A and C (the string length)
			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
			LD	B,0			; Reset B to 0 for the LDIR in this function
			JR      Z,PUSHS1        	; Is it zero length?
			LD      DE,ACCS			; DE: Destination
			EX      DE,HL			; HL: Destination, DE: Address on stack
			LDIR	                    	; Copy to stack
			CALL    CHECK			; Final check to see if there is sufficient space on the stack
PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
;
; POPS - RESTORE STRING FROM STACK.
;     Inputs: C = string length.
;    Outputs: String in string accumulator.
;             E = string length.
;   Destroys: B,C,D,E,H,L,IX,SP,F
;
POPS:			POP     IX              	; IX: Return address
			LD	L,C			; Temporarily store string length in L
			LD	BC,0
			LD	C,L			; BC: Number of bytes to copy
			LD      HL,0			; HL: 0
			ADD     HL,SP			; HL: Stack address
			LD      DE,ACCS			; DE: Destination
			INC     C			; Quick check to see if this is a zero length string
			DEC     C
			JR      Z,POPS1         	; Yes it is, so skip
			LDIR                    	; No, so copy from the stack
POPS1:			LD      SP,HL			; Shrink the stack
			JP      (IX)            	; Effectively "RET" (IX contains the return address)
;
HEXDIG:			LD      A,(IY)
			CP      '0'
			RET     C
			CP      '9'+1
			CCF
			RET     NC
			CP      'A'
			RET     C
			SUB     'A'-10
			CP      16
			CCF
			RET
;
BINDIG:			LD	A,(IY)
			CP	'0'
			RET	C
			CP	'1'+1
			CCF
			RET
;
RELOP?:			CP      '>'
			RET     NC
			CP      '='
			RET     NC
			CP      '<'
			RET
;
EXPRSC:			CALL    EXPRS
COMMA:			CALL    NXT
			INC     IY
			CP      ','
			RET     Z
			LD      A,5
			JR      ERROR1          ;"Missing ,"
;
BRAKET:			CALL    NXT
			INC     IY
			CP      ')'
			RET     Z
			LD      A,27
ERROR1:			JP      ERROR_EVAL           ;"Missing )"
;
SAVE:			INC     IY
SAVE1:			EX      AF,AF'
			JP      M,TYPE_EVAL
			EX      AF,AF'
			EX      (SP),HL
			EXX
			PUSH    HL
			EXX
			PUSH    AF
			PUSH    BC
			JP      (HL)
;
DOIT:			EX      AF,AF'
			JP      M,TYPE_EVAL
			EXX
			POP     BC              ;RETURN ADDRESS
			EXX
			LD      A,C
			POP     BC
			LD      B,A
			POP     AF              ;OPERATOR
			EXX
			EX      DE,HL
			POP     HL
			EXX
			EX      DE,HL
			POP     HL
			EXX
			PUSH    BC
			EXX
			AND     0FH
			CALL    FPP
			JR      C,ERROR1
			XOR     A
			EX      AF,AF'          ;TYPE
			LD      A,(IY)
			RET
;
; Skip spaces
; - IY: String pointer
; Returns:
;  - A: The non-space character found
; - IY: Points to the character before that
; 
NXT:			LD      A,(IY)			; Fetch the character	
			CP      ' '			; If it is space, then return
			RET     NZ
			INC     IY			; Increment the pointer and
			JP      NXT			; Loop
;
DISPT2:			PUSH    HL
			LD      HL,SOPTBL
			JR      DISPT0
;
DISPAT:			PUSH    HL
			SUB     FUNTOK
			LD      HL,FUNTBL
DISPT0:			PUSH    BC
			
			LD	BC, 3
			LD	B, A
			MLT	BC
			ADD	HL, BC
			LD	HL, (HL)

;			ADD     A,A
;			LD      C,A
;			LD      B,0
;			ADD     HL,BC
;			LD      A,(HL)
;			INC     HL
;			LD      H,(HL)
;			LD      L,A

			POP     BC
			EX      (SP),HL
			RET                     ;OFF TO ROUTINE

; =================================================================================================
; FROM ram.asm
; -------------------------------------------------------------------------------------------------
ACCS:			DS		256             ; String Accumulator


; =================================================================================================
; FUNCTIONS / LABELS / EQUS WE NEED
; -------------------------------------------------------------------------------------------------
; ITEMN: in eval.asm
; NXT: in eval.asm
; CON: in fpp.asm and eval.asm
;   -- renamed CON_FPP cand CON_EVAL

; ACCS: in ram.asm
; STAVAR: in ram.asm

; TYPE_: in eval.asm and main.asm
;   -- renamed TYPE_EVAL and TYPE_MAIN

; ERROR_: in main.asm and fpp.asm
;   -- renamed ERROR_MAIN and ERROR_FPP