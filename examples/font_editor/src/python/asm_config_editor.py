
from config_editor_dialog import ConfigEditorDialog
from config_manager import get_app_config_value, load_font_metadata_from_xml
import subprocess
import sys
import os
import shutil
import re

class DoAssemblyDialog(ConfigEditorDialog):
    """
    A modal dialog for assembly configuration that includes the font configuration dictionary.
    """
    def __init__(self, parent, config_editor_file, app_reference, font_config, *args, **kwargs):
        self.font_config = font_config
        font_filepath = get_app_config_value("most_recent_file")
        self.font_filename = os.path.basename(font_filepath)
        super().__init__(parent, config_editor_file, app_reference, *args, **kwargs)

    def init_values(self):
        """Initialize values based on the font configuration."""
        self.editor.controls['font_filename'].value = self.font_filename

    def on_go(self):
        """Handle the GO button click by running the build_and_deploy_fonts function."""
        print("GO button pressed")

        # Extract the current configuration values from the form
        kwargs = self.editor.get_config()

        # Call the build_and_deploy_fonts function with the extracted configuration
        build_and_deploy_fonts(**kwargs)

        # Close the dialog after triggering the build
        self.destroy()

# Helper function to parse font filename into components
def parse_font_file(full_font_filepath):
    font_xml_file = f"{full_font_filepath}.xml"
    print(f"Loading font metadata from: {font_xml_file}")
    font_config = load_font_metadata_from_xml(font_xml_file)
    return font_config['font_name'], font_config['font_variant'], font_config['font_width_mod'], font_config['font_height_mod'], os.path.basename(full_font_filepath)

# Helper function to sanitize label names
def sanitize_label(label):
    # Replace non-alphanumeric characters except underscores with underscores
    return re.sub(r'[^A-Za-z0-9_]', '_', label)

def build_fonts_asm(src_dir, font_dir, tgt_bin_dir, recursive=False):
    """
    Generates an assembly file listing fonts from .font files in the target directory.

    :param src_dir: Source directory (not used here but kept for consistency)
    :param font_dir: Directory containing .font files
    :param recursive: If True, performs a recursive search; if False, only searches the top level
    :return: List of sorted .font file paths
    """
    font_files = []

    # Walk through the directory
    for root, _, files in os.walk(font_dir):
        # If not recursive, skip subdirectories
        if not recursive and root != font_dir:
            continue

        for file in files:
            if file.endswith(".font"):
                full_path = os.path.join(root, file)
                font_files.append(full_path)

    # Sort font files
    font_files.sort()

    # Parse font files into structured data
    parsed_fonts = [parse_font_file(font_file) for font_file in font_files]

    # Write assembly file
    # font_rel_dir = os.path.relpath(font_dir, tgt_bin_dir)
    # if font_rel_dir and not font_rel_dir.endswith(os.path.sep):
    #     font_rel_dir += os.path.sep
    font_rel_dir = "/mos/fonts/" # for moslets we want this as an absolute path

    output_file = os.path.join(src_dir, "fonts_list.inc")
    with open(output_file, "w") as asm_file:
        asm_file.write("; Generated by asm_config_editor.py\n")
        asm_file.write("font_list_record_size: equ 12\n")
        asm_file.write("font_list_width: equ 0\n")
        asm_file.write("font_list_height: equ 3\n")
        asm_file.write("font_list_bufferId: equ 6\n")
        asm_file.write("font_list_filename: equ 9\n\n")
        asm_file.write(f"num_fonts: equ {len(parsed_fonts)}\n\n")

        # Write Index list
        asm_file.write("; Index list:\n")
        for idx, (font_name, variant, width, height, base_filename) in enumerate(parsed_fonts):
            label = sanitize_label(os.path.splitext(base_filename)[0])  # Sanitize without extension
            asm_file.write(f"{label}: equ {idx}\n")
        asm_file.write("\n")

        # Write font_list section
        asm_file.write("font_list: ; width; height; bufferId; filename;:\n")
        bufferId = 64000 ; # Starting buffer ID, 64000 is where the 8-bit buffer IDs for bitmaps begin, which we never use 
        for font_name, variant, width, height, base_filename in parsed_fonts:
            label = sanitize_label(os.path.splitext(base_filename)[0])  # Sanitize without extension
            asm_file.write(f"\tdl {width}, {height}, {bufferId}, fn_{label}\n")
            bufferId += 1
        asm_file.write("\n")

        # Write files_list section
        asm_file.write("; files_list: ; filename:\n")
        for font_name, variant, width, height, base_filename in parsed_fonts:
            label = sanitize_label(os.path.splitext(base_filename)[0])  # Sanitize without extension
            font_path = f"{font_rel_dir}{base_filename}"  # Keep original filename with extension
            asm_file.write(f"fn_{label}: db \"{font_path}\",0\n")

def make_cfg(font_filename, screen_mode, src_dir):
    """
    Generates a configuration file with the given screen mode and font name.

    :param font_filename: The font file name (used to generate the font label)
    :param screen_mode: The screen mode value to be set in the config file
    :param src_dir: The directory where the config file will be saved
    """
    # Sanitize the font label
    font_label = sanitize_label(os.path.splitext(font_filename)[0])
    
    # Define the config file path
    cfg_file = os.path.join(src_dir, "cfg.inc")

    # Write to the config file
    with open(cfg_file, 'w') as f:
        f.write(f"screen_mode: equ {screen_mode}\n")
        f.write(f"font_name: equ {font_label}\n")

    print(f"Configuration file created at: {cfg_file}")

def write_autoexec(file_path, tgt_bin_dir, bin_file):
    """
    Creates a text file containing commands for the emulator, with CRLF line endings.

    :param file_path: Path where the script file will be saved
    :param tgt_bin_dir: Directory path for the emulator target directory
    :param bin_file: The filename of the assembled binary file
    """
    # Define the lines for the emulator script
    script_lines = [
        'SET KEYBOARD 1',
        f'cd {tgt_bin_dir}',
        f'load {bin_file}',
        'run'
    ]

    # Open the file in write mode with newline set to '\r\n'
    with open(file_path, 'w') as f:
        # Write each line with explicit CRLF line endings
        for line in script_lines:
            f.write(line + '\r\n')

def build_and_deploy_fonts(
    font_filename,
    screen_mode,
    asm_dir,
    asm_file,
    tgt_bin_dir,
    tgt_bin_file,
    tgt_font_dir,
    emulator_dir,
    emulator_tgt_dir,
    sdcard_tgt_dir,
    emulator_exec,
    build_fonts,
    assemble,
    copy_emulator,
    copy_sdcard,
    run_emulator
):
    """
    Assembles font files, copies to emulator and SD card directories, and runs the emulator.

    :param asm_dir: Directory containing the assembly source file
    :param asm_file: Assembly source file name
    :param tgt_bin_file: Output binary file (created in asm_dir, then moved)
    ;param tgt_font_dir: Target directory for font files
    :param emulator_dir: Source directory for emulator files
    :param emulator_tgt_dir: Target directory in the emulator
    :param sdcard_tgt_dir: Target directory on the SD card
    :param emulator_exec: Path to the emulator executable
    :param assemble: Flag to run the assembler
    :param copy_emulator: Flag to copy files to emulator
    :param copy_sdcard: Flag to copy files to SD card
    :param run_emulator: Flag to run the emulator
    """
    original_dir = os.getcwd()

    def run_ez80asm():
        success = False  # Initialize success flag
        try:
            # Change working directory to the assembly directory
            os.chdir(asm_dir)

            # Define the output file local to the assembly directory
            local_output_file = os.path.join(asm_dir, tgt_bin_file)

            # Build the ez80asm command
            command = [
                "ez80asm",
                asm_file,          # Input assembly file
                "-l",              # Option to generate listing file
                tgt_bin_file       # Output local binary file
            ]

            print(f"Assembling with command: {' '.join(command)}")

            # Execute the command
            result = subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            print(result.stdout.decode())

            # Set success flag if assembly is successful
            success = True

        except subprocess.CalledProcessError as e:
            print(f'Assembly failed with error: {e.stderr.decode()}')
            sys.exit(1)
        except Exception as e:
            print(f'An error occurred during assembly: {e}')
            sys.exit(1)
        finally:
            # Restore the original working directory
            os.chdir(original_dir)

        # Move the assembled file to the target directory if successful
        if success:
            tgt_full_path = os.path.join(tgt_bin_dir, tgt_bin_file)
            shutil.move(local_output_file, tgt_full_path)
            print(f'Successfully assembled and moved to {tgt_full_path}')

    def copy_to_directory(src_dir, tgt_dir, include_pattern=None):
        """
        Copies files from src_dir to tgt_dir, optionally filtering by a regex pattern.

        :param src_dir: Source directory to copy from
        :param tgt_dir: Target directory to copy to
        :param include_pattern: Optional regex pattern to filter files (default: None)
        """
        try:
            if os.path.exists(tgt_dir):
                shutil.rmtree(tgt_dir)
            os.makedirs(tgt_dir, exist_ok=True)

            # Walk through the source directory
            for root, _, files in os.walk(src_dir):
                for file in files:
                    # If a pattern is provided, check if the file matches the pattern
                    if include_pattern is None or re.match(include_pattern, file):
                        src_file = os.path.join(root, file)
                        rel_path = os.path.relpath(src_file, src_dir)
                        tgt_file = os.path.join(tgt_dir, rel_path)

                        os.makedirs(os.path.dirname(tgt_file), exist_ok=True)
                        shutil.copy2(src_file, tgt_file)

            print(f'Successfully copied files from {src_dir} to {tgt_dir}')

        except Exception as e:
            print(f'An error occurred while copying files: {e}')
            sys.exit(1)

    def run_fab_emulator():
        autoexec_file = os.path.join(emulator_dir, 'sdcard', 'autoexec.txt')
        write_autoexec(autoexec_file, emulator_tgt_dir, tgt_bin_file)
        try:
            os.chdir(emulator_dir)
            os.listdir(emulator_dir)  # Check if the directory is accessible

            command = [emulator_exec]
            
            # Start the emulator as a separate process, suppressing its I/O
            with open(os.devnull, 'wb') as devnull:
                process = subprocess.Popen(
                    command,
                    stdout=devnull,
                    stderr=devnull,
                    stdin=devnull
                )
            print(f'Emulator started with PID {process.pid}')

        except Exception as e:
            print(f'An error occurred while starting the emulator: {e}')
            sys.exit(1)
        finally:
            os.chdir(original_dir)


    # Execute functions based on parameters
    if build_fonts:
        make_cfg(font_filename, screen_mode, asm_dir)
        build_fonts_asm(asm_dir, tgt_font_dir, tgt_bin_dir)
    if assemble:
        run_ez80asm()
    if copy_emulator:
        print("Copying emulator files disabled.")
        # copy_to_directory(tgt_bin_dir, emulator_tgt_dir)
    if copy_sdcard:
        # print("Copying SD card files disabled.")
        if os.path.exists(sdcard_tgt_dir):
            copy_to_directory(tgt_bin_dir, sdcard_tgt_dir, include_pattern=r'.*\.(bin|font)$')
        else:
            print(f"SD card target directory not found: {sdcard_tgt_dir}")
    if run_emulator:
        run_fab_emulator()