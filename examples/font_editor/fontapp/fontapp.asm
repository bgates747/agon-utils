    assume adl=1 
    org 0x040000 

; mos_api.inc
mos_fopen:			EQU	0Ah
fa_read:			EQU	01h
mos_fread:			EQU	1Ah
mos_fclose:			EQU	0Bh


; Macro for calling the API
; Parameters:
; - function: One of the function numbers listed above
;
	MACRO	MOSCALL	function
			LD	A, function
			RST.LIL	08h
	ENDMACRO 	

    jp start 
    align 64 
    db "MOS" 
    db 00h 
    db 01h 

start: 
    push af
    push bc
    push de
    push ix
    push iy

    call main

exit:
    pop iy
    pop ix
    pop de
    pop bc
    pop af
    ld hl,0

    ret

; --- MAIN PROGRAM FILE ---
main:
; set screen mode
    ld a,18   ; 1024  768   2     60hz single-buffered
    call vdu_set_screen_mode
; clear the screen
    call vdu_cls
; clear all buffers
    call vdu_clear_all_buffers
; load fonts
	call fonts_load
; select font
    ld hl,Lat2_VGA16_8x16
    ld a,1 ; flags
    call vdu_font_select
; show selected font
    call printInline
    db 13,10,13,10
    db 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,13,10
    db 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,13,10
    db 64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,13,10
    db 80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,13,10
    db 96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,13,10
    db 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,13,10
    db 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,13,10
    db 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,13,10
    db 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,13,10
    db 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,13,10
    db 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,13,10
    db 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,13,10
    db 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,13,10
    db 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,13,10,13,10
    db 0 ; string terminator
    ret
; end main

; fonts_list.inc
; Generated by asm_config_editor.py
font_list_record_size: equ 12
font_list_width: equ 0
font_list_height: equ 3
font_list_bufferId: equ 6
font_list_filename: equ 9

num_fonts: equ 29

; Font bufferId's list:
amiga_forever_16x16: equ 64000
amiga_forever_16x24: equ 64001
amiga_forever_8x16: equ 64002
amiga_forever_8x8: equ 64003
computer_pixel_7_10x15: equ 64004
computer_pixel_7_10x24: equ 64005
computer_pixel_7_8x12: equ 64006
computer_pixel_7_8x14: equ 64007
computer_pixel_7_8x16: equ 64008
dopecre_8x8: equ 64009
gamer_2_8x8: equ 64010
Lat15_VGA8_8x8: equ 64011
Lat2_Terminus12x6_6x12: equ 64012
Lat2_TerminusBold14_8x14: equ 64013
Lat2_VGA14_8x14: equ 64014
Lat2_VGA16_8x16: equ 64015
Lat2_VGA8_8x8: equ 64016
Lat38_VGA8_8x8: equ 64017
Lat7_Fixed13_8x13: equ 64018
Lat7_Terminus12x6_6x12: equ 64019
Lat7_TerminusBold16_8x16: equ 64020
Lat7_VGA14_8x14: equ 64021
Lat7_VGA16_8x16: equ 64022
Lat7_VGA8_8x8: equ 64023
planetary_contact_8x8: equ 64024
scriptorium_12x14: equ 64025
Squarewave_Bold_8x12: equ 64026
super_mario_bros_2_8x8: equ 64027
wendy_neue_6x6: equ 64028

font_list: ; width; height; bufferId; filename;:
	dl 16, 16, 64000, fn_amiga_forever_16x16
	dl 16, 24, 64001, fn_amiga_forever_16x24
	dl 8, 16, 64002, fn_amiga_forever_8x16
	dl 8, 8, 64003, fn_amiga_forever_8x8
	dl 10, 15, 64004, fn_computer_pixel_7_10x15
	dl 10, 24, 64005, fn_computer_pixel_7_10x24
	dl 8, 12, 64006, fn_computer_pixel_7_8x12
	dl 8, 14, 64007, fn_computer_pixel_7_8x14
	dl 8, 16, 64008, fn_computer_pixel_7_8x16
	dl 8, 8, 64009, fn_dopecre_8x8
	dl 8, 8, 64010, fn_gamer_2_8x8
	dl 8, 8, 64011, fn_Lat15_VGA8_8x8
	dl 6, 12, 64012, fn_Lat2_Terminus12x6_6x12
	dl 8, 14, 64013, fn_Lat2_TerminusBold14_8x14
	dl 8, 14, 64014, fn_Lat2_VGA14_8x14
	dl 8, 16, 64015, fn_Lat2_VGA16_8x16
	dl 8, 8, 64016, fn_Lat2_VGA8_8x8
	dl 8, 8, 64017, fn_Lat38_VGA8_8x8
	dl 8, 13, 64018, fn_Lat7_Fixed13_8x13
	dl 6, 12, 64019, fn_Lat7_Terminus12x6_6x12
	dl 8, 16, 64020, fn_Lat7_TerminusBold16_8x16
	dl 8, 14, 64021, fn_Lat7_VGA14_8x14
	dl 8, 16, 64022, fn_Lat7_VGA16_8x16
	dl 8, 8, 64023, fn_Lat7_VGA8_8x8
	dl 8, 8, 64024, fn_planetary_contact_8x8
	dl 12, 14, 64025, fn_scriptorium_12x14
	dl 8, 12, 64026, fn_Squarewave_Bold_8x12
	dl 8, 8, 64027, fn_super_mario_bros_2_8x8
	dl 6, 6, 64028, fn_wendy_neue_6x6

; files_list: ; filename:
fn_amiga_forever_16x16: db "fonts/amiga_forever_16x16.font",0
fn_amiga_forever_16x24: db "fonts/amiga_forever_16x24.font",0
fn_amiga_forever_8x16: db "fonts/amiga_forever_8x16.font",0
fn_amiga_forever_8x8: db "fonts/amiga_forever_8x8.font",0
fn_computer_pixel_7_10x15: db "fonts/computer_pixel_7_10x15.font",0
fn_computer_pixel_7_10x24: db "fonts/computer_pixel_7_10x24.font",0
fn_computer_pixel_7_8x12: db "fonts/computer_pixel_7_8x12.font",0
fn_computer_pixel_7_8x14: db "fonts/computer_pixel_7_8x14.font",0
fn_computer_pixel_7_8x16: db "fonts/computer_pixel_7_8x16.font",0
fn_dopecre_8x8: db "fonts/dopecre_8x8.font",0
fn_gamer_2_8x8: db "fonts/gamer_2_8x8.font",0
fn_Lat15_VGA8_8x8: db "fonts/Lat15-VGA8_8x8.font",0
fn_Lat2_Terminus12x6_6x12: db "fonts/Lat2-Terminus12x6_6x12.font",0
fn_Lat2_TerminusBold14_8x14: db "fonts/Lat2-TerminusBold14_8x14.font",0
fn_Lat2_VGA14_8x14: db "fonts/Lat2-VGA14_8x14.font",0
fn_Lat2_VGA16_8x16: db "fonts/Lat2-VGA16_8x16.font",0
fn_Lat2_VGA8_8x8: db "fonts/Lat2-VGA8_8x8.font",0
fn_Lat38_VGA8_8x8: db "fonts/Lat38-VGA8_8x8.font",0
fn_Lat7_Fixed13_8x13: db "fonts/Lat7-Fixed13_8x13.font",0
fn_Lat7_Terminus12x6_6x12: db "fonts/Lat7-Terminus12x6_6x12.font",0
fn_Lat7_TerminusBold16_8x16: db "fonts/Lat7-TerminusBold16_8x16.font",0
fn_Lat7_VGA14_8x14: db "fonts/Lat7-VGA14_8x14.font",0
fn_Lat7_VGA16_8x16: db "fonts/Lat7-VGA16_8x16.font",0
fn_Lat7_VGA8_8x8: db "fonts/Lat7-VGA8_8x8.font",0
fn_planetary_contact_8x8: db "fonts/planetary_contact_8x8.font",0
fn_scriptorium_12x14: db "fonts/scriptorium_12x14.font",0
fn_Squarewave_Bold_8x12: db "fonts/Squarewave_Bold_8x12.font",0
fn_super_mario_bros_2_8x8: db "fonts/super_mario_bros_2_8x8.font",0
fn_wendy_neue_6x6: db "fonts/wendy_neue_6x6.font",0

; fonts.inc
fonts_load:
    ld ix,font_list ; pointer to font list lookup
    ld b,num_fonts ; loop counter

@load_loop:
    push bc ; save loop counter

; load font into a buffer
    ld hl,(ix+font_list_bufferId)
    ld iy,(ix+font_list_filename)
    call vdu_load_buffer_from_file

; create font from buffer
    ld hl,(ix+font_list_bufferId)
    ld e,(ix+font_list_width)
    ld d,(ix+font_list_height)
    ld a,0 ; flags
    call vdu_font_create

; comment out this block if you want a "silent" font load
; select font
    ld hl,(ix+font_list_bufferId)
    ld a,1 ; flags
    call vdu_font_select
; print font filename
    call printNewLine
    ld hl,(ix+font_list_filename)
    call printString

; advance font_list pointer to next record
    lea ix,ix+font_list_record_size

; restore loop counter
    pop bc
    djnz @load_loop

; all done
    ret

; vdu_fonts.inc
; select font
; inputs: hl = bufferId, a = font flags
; Flags:
; Bit	Description
; 0	Adjust cursor position to ensure text baseline is aligned
;   0: Do not adjust cursor position (best for changing font on a new line)
;   1: Adjust cursor position (best for changing font in the middle of a line)
; 1-7	Reserved for future use
; VDU 23, 0, &95, 0, bufferId; flags: Select font
vdu_font_select:
    ld (@bufferId),hl
    ld (@flags),a
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
    ret
@cmd: db 23, 0, 0x95, 0
@bufferId: dw 0x0000
@flags: db 0x00
@end:

; create font from buffer
; inputs: hl = bufferId, e = width, d = height, d = ascent, a = flags
; VDU 23, 0, &95, 1, bufferId; width, height, ascent, flags: Create font from buffer
vdu_font_create:
    ld (@bufferId),hl
    ld (@width),de ; also loads height
    ld (@flags),a
    ld a,d ; height
    ld (@ascent),a ; ascent = height
; consolidate buffer
    call vdu_consolidate_buffer
; create font
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
    ret
@cmd: db 23, 0, 0x95, 1
@bufferId: dw 0x0000
@width: db 0x00
@height: db 0x00
@ascent: db 0x00
@flags: db 0x00
@end:

; set or adjust font property
; inputs: hl = bufferId, a = field, de = value
; VDU 23, 0, &95, 2, bufferId; field, value;: Set or adjust font property
vdu_font_property:
    ld (@bufferId),hl
    ld (@field),a
    ld (@value),de
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
    ret
@cmd: db 23, 0, 0x95, 2
@bufferId: dw 0x0000
@field: db 0x00
@value: dw 0x0000
@end: db 0x00 ; padding

; VDU 23, 0, &95, 3, bufferId; [<args>]: Reserved

; Clear/Delete font
; inputs: hl = bufferId
; VDU 23, 0, &95, 4, bufferId;: Clear/Delete font
vdu_font_clear:
    ld (@bufferId),hl
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
    ret
@cmd: db 23, 0, 0x95, 4
@bufferId: dw 0x0000
@end: db 0x00 ; padding

; Copy system font to buffer
; inputs: hl = bufferId
; VDU 23, 0, &95, 5, bufferId;: Copy system font to buffer
vdu_font_copy_system:
    ld (@bufferId),hl
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
    ret
@cmd: db 23, 0, 0x95, 5
@bufferId: dw 0x0000
@end: db 0x00 ; padding

; functions.inc
; Print a zero-terminated string inline with code, e.g.:
;
;    call printInline
;    ASCIZ "Hello, world!\r\n"
;
; Destroys: HL,AF
printInline:
    pop hl ; get the return address = pointer to start of string
    call printString ; HL advances to end of string
    push hl ; restore the return address = pointer to end of string
    ret

; Print Newline sequence to VDP
; destroys bc
printNewLine:
    push af ; for some reason rst.lil 10h sets carry flag
    LD A, '\r'
    RST.LIL 10h
    LD A, '\n'
    RST.LIL 10h
    pop af
    RET

; Print a zero-terminated string
; HL: Pointer to string
printString:
    PUSH BC
    LD BC,0
    LD A,0
    RST.LIL 18h
    POP BC
    RET

; vdu.inc
; scratch variables 
bufferId0: dl 0x000000
bufferId1: dl 0x000000

vdu_set_screen_mode:
	ld (@arg),a        
	ld hl,@cmd         
	ld bc,@end-@cmd    
	rst.lil $18         
	ret
@cmd: db 22 ; set screen mode
@arg: db 0  ; screen mode parameter
@end:

; VDU 12: Clear text area (CLS)
vdu_cls:
    ld a,12
	rst.lil $10  
	ret

; inputs: hl = bufferId; iy = pointer to filename
vdu_load_buffer_from_file:
    ld (bufferId0),hl

; clear target buffer
    call vdu_clear_buffer

; open the file in read mode
; Open a file
; HLU: Filename
;   C: Mode
; Returns:
;   A: Filehandle, or 0 if couldn't open
	push iy ; pointer to filename
	pop hl
	ld c,fa_read
    MOSCALL mos_fopen
    ld (@filehandle),a

@read_file:
; Read a block of data from a file
;   C: Filehandle
; HLU: Pointer to where to write the data to
; DEU: Number of bytes to read
; Returns:
; DEU: Number of bytes read
    ld a,(@filehandle)
    ld c,a
    ld hl,filedata
    ld de,8192 ; max we can read into onboard sram at one time
    MOSCALL mos_fread

; test de for zero bytes read
    ld hl,0
    xor a ; clear carry
    sbc hl,de
    jp z,@close_file

; load a vdu buffer from local memory
; inputs: hl = bufferId ; bc = length ; de = pointer to data
    ld hl,(bufferId0)
    push de ; chunksize
    pop bc
    ld de,filedata
    call vdu_load_buffer

; read the next block
    jp @read_file

; close the file
@close_file:
    ld a,(@filehandle)
    MOSCALL mos_fclose
    ret ; vdu_load_buffer_from_file

@filehandle: db 0 ; file handle
@fil: dl 0 ; pointer to FIL struct

@chunkpointer: dl 0 ; pointer to current chunk

; File information structure (FILINFO)
@filinfo:
@filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
@filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
@filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
@filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
@filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
@filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)

; Command 14: Consolidate blocks in a buffer
vdu_consolidate_buffer:
; set parameters for vdu call
    ld a,l
    ld (@bufferId),a
    ld a,h
    ld (@bufferId+1),a
    ld hl,@beg
    ld bc,@end-@beg
    rst.lil $18
    ret
; VDU 23, 0, &A0, bufferId; 14
@beg: db 23,0,0xA0
@bufferId: dw 0x0000
           db 14
@end:


; load a vdu buffer from local memory
; inputs: hl = bufferId ; bc = length ; de = pointer to data
vdu_load_buffer:
    ld (@length),bc
    push de ; save data pointer
; send the vdu command string
    ld a,l
    ld (@bufferId),a
    ld a,h
    ld (@bufferId+1),a
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
; send the buffer data
    pop hl ; pointer to data
    ld bc,(@length)
    rst.lil $18 ; send it
    ret
; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
@cmd:       db 23,0,0xA0
@bufferId:	dw 0x0000
		    db 0 ; load buffer
@length:	dw 0x0000
@end: db 0 ; padding

; vdu_buffered_api.inc

; Clear all buffers
; inputs: none
vdu_clear_all_buffers:
; clear all buffers
    ld hl,@beg
    ld bc,@end-@beg
    rst.lil $18
    ret
@beg: db 23,0,$A0
      dw -1 ; bufferId -1 (65535) means clear all buffers
      db 2  ; command 2: clear a buffer
@end:
; end vdu_clear_all_buffers

; Command 2: Clear a buffer
; VDU 23, 0 &A0, bufferId; 2
; inputs: hl = bufferId
vdu_clear_buffer:
    ld (@bufferId),hl
    ld a,2 ; clear buffer
    ld (@bufferId+2),a
    ld hl,@cmd
    ld bc,@end-@cmd
    rst.lil $18
    ret
@cmd:     db 23,0,0xA0
@bufferId: dw 0x0000
           db 2 ; clear buffer
@end: 
; end vdu_clear_buffer

; must be last line of program so filedata doesn't stomp on code or other data
filedata: equ $
