        Output     Line 
       
               0001 ;
               0002 ; Title:	calcbas
               0003 ; Author:	Brandon R. Gates
               0004 ; Created:	29/10/2024
               0005 
               0006 ; ========================================
               0007 ; MODIFIED MOSLET INITIALIZATION CODE
               0008 ; ========================================
               0009 ;
               0010 ; Title:	Copy - Initialisation Code
               0011 ; Author:	Dean Belfield, Lennart Benschop
               0012 ; Created:	06/11/2022
               0013 ; Last Updated:	26/12/2022
               0014 ;
               0015 ; Modinfo:
               0016 ; 17/12/2022:	Added parameter processing
               0017 ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
               0018 ; Changed:      08/04/2924 adapt to ez80asm
               0019 ;
               0020 ASSUME	ADL = 1
               0021 INCLUDE "mos_api.inc"
              0001* ;
              0002* ; Title:	AGON MOS - API for user projects
              0003* ; Author:	Dean Belfield
              0004* ; Created:	03/08/2022
              0005* ; Last Updated:	11/11/2023
              0006* ;
              0007* ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
              0008* ;
              0009* ; Modinfo:
              0010* ; 05/08/2022:	Added mos_feof
              0011* ; 09/08/2022:	Added system variables: cursorX, cursorY
              0012* ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
              0013* ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
              0014* ; 24/09/2022:	Added mos_getError, mos_mkdir
              0015* ; 13/10/2022:	Added mos_oscli
              0016* ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
              0017* ; 04/03/2023:	Added sysvar_scrpixelIndex
              0018* ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
              0019* ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
              0020* ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
              0021* ; 22/03/2023:	The VDP commands are now indexed from 0x80
              0022* ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
              0023* ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
              0024* ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
              0025* ; 19/05/2023:	Added sysvar_scrMode
              0026* ; 05/06/2023:	Added sysvar_rtcEnable
              0027* ; 03/08/2023:	Added mos_setkbvector
              0028* ; 10/08/2023:	Added mos_getkbmap
              0029* ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
              0030* ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
              0031* ;
              0032* ; VDP control (VDU 23, 0, n)
              0033* ;
              0034* vdp_gp:			EQU 	80h
              0035* vdp_keycode:		EQU 	81h
              0036* vdp_cursor:		EQU	82h
              0037* vdp_scrchar:		EQU	83h
              0038* vdp_scrpixel:		EQU	84h
              0039* vdp_audio:		EQU	85h
              0040* vdp_mode:		EQU	86h
              0041* vdp_rtc:		EQU	87h
              0042* vdp_keystate:		EQU	88h
              0043* vdp_logicalcoords:	EQU	C0h
              0044* vdp_terminalmode:	EQU	FFh
              0045* 
              0046* ; MOS high level functions
              0047* ;
              0048* mos_getkey:		EQU	00h
              0049* mos_load:		EQU	01h
              0050* mos_save:		EQU	02h
              0051* mos_cd:			EQU	03h
              0052* mos_dir:		EQU	04h
              0053* mos_del:		EQU	05h
              0054* mos_ren:		EQU	06h
              0055* mos_mkdir:		EQU	07h
              0056* mos_sysvars:		EQU	08h
              0057* mos_editline:		EQU	09h
              0058* mos_fopen:		EQU	0Ah
              0059* mos_fclose:		EQU	0Bh
              0060* mos_fgetc:		EQU	0Ch
              0061* mos_fputc:		EQU	0Dh
              0062* mos_feof:		EQU	0Eh
              0063* mos_getError:		EQU	0Fh
              0064* mos_oscli:		EQU	10h
              0065* mos_copy:		EQU	11h
              0066* mos_getrtc:		EQU	12h
              0067* mos_setrtc:		EQU	13h
              0068* mos_setintvector:	EQU	14h
              0069* mos_uopen:		EQU	15h
              0070* mos_uclose:		EQU	16h
              0071* mos_ugetc:		EQU	17h
              0072* mos_uputc:		EQU 	18h
              0073* mos_getfil:		EQU	19h
              0074* mos_fread:		EQU	1Ah
              0075* mos_fwrite:		EQU	1Bh
              0076* mos_flseek:		EQU	1Ch
              0077* mos_setkbvector:	EQU	1Dh
              0078* mos_getkbmap:		EQU	1Eh
              0079* mos_i2c_open:		EQU	1Fh
              0080* mos_i2c_close:		EQU	20h
              0081* mos_i2c_write:		EQU	21h
              0082* mos_i2c_read:		EQU	22h
              0083* 
              0084* 
              0085* ; FatFS file access functions
              0086* ;
              0087* ffs_fopen:		EQU	80h
              0088* ffs_fclose:		EQU	81h
              0089* ffs_fread:		EQU	82h
              0090* ffs_fwrite:		EQU	83h
              0091* ffs_flseek:		EQU	84h
              0092* ffs_ftruncate:		EQU	85h
              0093* ffs_fsync:		EQU	86h
              0094* ffs_fforward:		EQU	87h
              0095* ffs_fexpand:		EQU	88h
              0096* ffs_fgets:		EQU	89h
              0097* ffs_fputc:		EQU	8Ah
              0098* ffs_fputs:		EQU	8Bh
              0099* ffs_fprintf:		EQU	8Ch
              0100* ffs_ftell:		EQU	8Dh
              0101* ffs_feof:		EQU	8Eh
              0102* ffs_fsize:		EQU	8Fh
              0103* ffs_ferror:		EQU	90h
              0104* 
              0105* ; FatFS directory access functions
              0106* ;
              0107* ffs_dopen:		EQU	91h
              0108* ffs_dclose:		EQU	92h
              0109* ffs_dread:		EQU	93h
              0110* ffs_dfindfirst:		EQU	94h
              0111* ffs_dfindnext:		EQU	95h
              0112* 
              0113* ; FatFS file and directory management functions
              0114* ;
              0115* ffs_stat:		EQU	96h
              0116* ffs_unlink:		EQU	97h
              0117* ffs_rename:		EQU	98h
              0118* ffs_chmod:		EQU	99h
              0119* ffs_utime:		EQU	9Ah
              0120* ffs_mkdir:		EQU	9Bh
              0121* ffs_chdir:		EQU	9Ch
              0122* ffs_chdrive:		EQU	9Dh
              0123* ffs_getcwd:		EQU	9Eh
              0124* 
              0125* ; FatFS volume management and system configuration functions
              0126* ;
              0127* ffs_mount:		EQU	9Fh
              0128* ffs_mkfs:		EQU	A0h
              0129* ffs_fdisk:		EQU	A1h
              0130* ffs_getfree:		EQU	A2h
              0131* ffs_getlabel:		EQU	A3h
              0132* ffs_setlabel:		EQU	A4h
              0133* ffs_setcp:		EQU	A5h
              0134* 
              0135* ; File access modes
              0136* ;
              0137* fa_read:		EQU	01h
              0138* fa_write:		EQU	02h
              0139* fa_open_existing:	EQU	00h
              0140* fa_create_new:		EQU	04h
              0141* fa_create_always:	EQU	08h
              0142* fa_open_always:		EQU	10h
              0143* fa_open_append:		EQU	30h
              0144* 
              0145* ; System variable indexes for api_sysvars
              0146* ; Index into _sysvars in globals.asm
              0147* ;
              0148* sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
              0149* sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
              0150* sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
              0151* sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
              0152* sysvar_cursorX:		EQU	07h	; 1: Cursor X position
              0153* sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
              0154* sysvar_scrchar:		EQU	09h	; 1: Character read from screen
              0155* sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
              0156* sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
              0157* sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
              0158* sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
              0159* sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
              0160* sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
              0161* sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
              0162* sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
              0163* sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
              0164* sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
              0165* sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
              0166* sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
              0167* sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
              0168* sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
              0169* sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
              0170* sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
              0171* sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
              0172* sysvar_scrMode:		EQU	27h	; 1: Screen mode
              0173* sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
              0174* sysvar_mouseX:		EQU	29h	; 2: Mouse X position
              0175* sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
              0176* sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
              0177* sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
              0178* sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
              0179* sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
              0180* ;
              0181* ; Flags for the VPD protocol
              0182* ;
              0183* vdp_pflag_cursor:	EQU	00000001b
              0184* vdp_pflag_scrchar:	EQU	00000010b
              0185* vdp_pflag_point:	EQU	00000100b
              0186* vdp_pflag_audio:	EQU	00001000b
              0187* vdp_pflag_mode:		EQU	00010000b
              0188* vdp_pflag_rtc:		EQU	00100000b
              0189* vdp_pflag_mouse:	EQU	01000000b
              0190* ; vdp_pflag_buffered:	EQU	10000000b
              0191* 
              0192* 
              0193* ; FatFS structures
              0194* ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
              0195* ;
              0196* ; Object ID and allocation information (FFOBJID)
              0197* FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
              0198* FFOBJID.id:       EQU 3    ; Hosting volume mount ID
              0199* FFOBJID.attr:     EQU 5    ; Object attribute
              0200* FFOBJID.stat:     EQU 6    ; Object chain status
              0201* FFOBJID.sclust:   EQU 7    ; Object data start cluster
              0202* FFOBJID.objsize:  EQU 11   ; Object size
              0203* FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
              0204* ;
              0205* ; File object structure (FIL)
              0206* ;
              0207* FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0208* FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
              0209* FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
              0210* FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
              0211* FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
              0212* FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
              0213* FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
              0214* FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
              0215* FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
              0216* ;
              0217* ; Directory object structure (DIR)
              0218* ;
              0219* DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0220* DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
              0221* DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
              0222* DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
              0223* DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
              0224* DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
              0225* DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
              0226* DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
              0227* ;
              0228* ; File information structure (FILINFO)
              0229* ;
              0230* FILINFO.fsize:    EQU 0    ; File size
              0231* FILINFO.fdate:    EQU 4    ; Modified date
              0232* FILINFO.ftime:    EQU 6    ; Modified time
              0233* FILINFO.fattrib:  EQU 8    ; File attribute
              0234* FILINFO.altname:  EQU 9    ; Alternative file name
              0235* FILINFO.fname:    EQU 22   ; Primary file name
              0236* FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
              0237* ;
              0238* ; Macro for calling the API
              0239* ; Parameters:
              0240* ; - function: One of the function numbers listed above
              0241* ;
              0242* MACRO MOSCALL	function
              0243* LD	A, function
              0244* RST.LIS	08h
              0245* ENDMACRO
               0022 ORG 0x0B0000 ; Is a moslet
               0023 
               0024 MACRO PROGNAME
               0025 ASCIZ "calcbas"
               0026 ENDMACRO
               0027 ;
               0028 ; Start in ADL mode
               0029 ;
0B0000 C3      0030 JP	_start
0B0001 45 
0B0002 00 
0B0003 0B 
               0031 ;
               0032 ; The header stuff is from byte 64 onwards
               0033 ;
               0034 _exec_name:
               0035 PROGNAME			; The executable name, only used in argv
0B0004 63     0001M ASCIZ "calcbas"
0B0005 61 
0B0006 6C 
0B0007 63 
0B0007 62   
0B0008 61 
0B0009 73 
0B000A 00 
               0036 
0B000C FF      0037 ALIGN	64
0B000D FF 
0B000E FF 
0B000F FF 
0B000F FF   
0B0010 FF 
0B0011 FF 
0B0012 FF 
0B0012 FF   
0B0013 FF 
0B0014 FF 
0B0015 FF 
0B0015 FF   
0B0016 FF 
0B0017 FF 
0B0018 FF 
0B0018 FF   
0B0019 FF 
0B001A FF 
0B001B FF 
0B001B FF   
0B001C FF 
0B001D FF 
0B001E FF 
0B001E FF   
0B001F FF 
0B0020 FF 
0B0021 FF 
0B0021 FF   
0B0022 FF 
0B0023 FF 
0B0024 FF 
0B0024 FF   
0B0025 FF 
0B0026 FF 
0B0027 FF 
0B0027 FF   
0B0028 FF 
0B0029 FF 
0B002A FF 
0B002A FF   
0B002B FF 
0B002C FF 
0B002D FF 
0B002D FF   
0B002E FF 
0B002F FF 
0B0030 FF 
0B0030 FF   
0B0031 FF 
0B0032 FF 
0B0033 FF 
               0038 
0B0040 4D      0039 DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0041 4F 
0B0042 53 
0B0043 00      0040 DB	00h			; MOS header version 0
0B0044 01      0041 DB	01h			; Flag for run mode (0: Z80, 1: ADL)
               0042 ;
               0043 ; And the code follows on immediately after the header
               0044 ;
               0045 _start:
0B0045 F5      0046 PUSH	AF			; Preserve the registers
0B0046 C5      0047 PUSH	BC
0B0047 D5      0048 PUSH	DE
0B0048 DD      0049 PUSH	IX
0B0049 E5 
0B004A FD      0050 PUSH	IY
0B004B E5 
0B004C ED      0051 LD	A, MB			; Save MB
0B004D 6E 
0B004E F5      0052 PUSH 	AF
0B004F AF      0053 XOR 	A
0B0050 ED      0054 LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0051 6D 
               0055 
0B0052 CD      0056 CALL		_clear_ram ; Clear the BASIC memory allocation
0B0053 BD 
0B0054 00 
0B0055 0B 
               0057 
0B0056 DD      0058 LD	IX, argv_ptrs		; The argv array pointer address
0B0057 21 
0B0058 C7 
0B0059 17 
0B0059 0B   
0B005B DD      0059 PUSH	IX
0B005C E5 
0B005D CD      0060 CALL	_parse_params		; Parse the parameters
0B005E 74 
0B005F 00 
0B0060 0B 
0B0061 DD      0061 POP	IX			; IX: argv
0B0062 E1 
0B0063 06      0062 LD	B, 0			;  C: argc
0B0064 00 
0B0065 CD      0063 CALL	_main_init			; Start user code
0B0066 30 
0B0067 18 
0B0068 0B 
               0064 
0B0069 F1      0065 POP 	AF
0B006A ED      0066 LD	MB, A
0B006B 6D 
0B006C FD      0067 POP	IY			; Restore registers
0B006D E1 
0B006E DD      0068 POP	IX
0B006F E1 
0B0070 D1      0069 POP	DE
0B0071 C1      0070 POP	BC
0B0072 F1      0071 POP	AF
0B0073 C9      0072 RET
               0073 
               0074 ; Parse the parameter string into a C array
               0075 ; Parameters
               0076 ; - HL: Address of parameter string
               0077 ; - IX: Address for array pointer storage
               0078 ; Returns:
               0079 ; -  C: Number of parameters parsed
               0080 ;
0B0074 01      0081 _parse_params:		LD	BC, _exec_name
0B0075 04 
0B0076 00 
0B0077 0B 
0B0078 DD      0082 LD	(IX+0), BC		; ARGV[0] = the executable name
0B0079 0F 
0B007A 00 
0B007B ED      0083 LEA     IX, IX+3
0B007C 32 
0B007D 03 
0B007E CD      0084 CALL	_skip_spaces		; Skip HL past any leading spaces
0B007F B6 
0B0080 00 
0B0081 0B 
               0085 ;
0B0082 01      0086 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0083 01 
0B0084 00 
0B0085 00 
0B0086 06      0087 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0087 0F 
               0088 ;
               0089 _parse_params_1:
0B0088 C5      0090 PUSH	BC			; Stack ARGC
0B0089 E5      0091 PUSH	HL			; Stack start address of token
0B008A CD      0092 CALL	_get_token		; Get the next token
0B008B A7 
0B008C 00 
0B008D 0B 
0B008E 79      0093 LD	A, C			; A: Length of the token in characters
0B008F D1      0094 POP	DE			; Start address of token (was in HL)
0B0090 C1      0095 POP	BC			; ARGC
0B0091 B7      0096 OR	A			; Check for A=0 (no token found) OR at end of string
0B0092 C8      0097 RET	Z
               0098 ;
0B0093 DD      0099 LD	(IX+0), DE		; Store the pointer to the token
0B0094 1F 
0B0095 00 
0B0096 E5      0100 PUSH	HL			; DE=HL
0B0097 D1      0101 POP	DE
0B0098 CD      0102 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0099 B6 
0B009A 00 
0B009B 0B 
0B009C AF      0103 XOR	A
0B009D 12      0104 LD	(DE), A			; Zero-terminate the token
0B009E ED      0105 LEA  	IX, IX+3			; Advance to next pointer position
0B009F 32 
0B00A0 03 
0B00A1 0C      0106 INC	C			; Increment ARGC
0B00A2 79      0107 LD	A, C			; Check for C >= A
0B00A3 B8      0108 CP	B
0B00A4 38      0109 JR	C, _parse_params_1	; And loop
0B00A5 E2 
0B00A6 C9      0110 RET
               0111 
               0112 ; Get the next token
               0113 ; Parameters:
               0114 ; - HL: Address of parameter string
               0115 ; Returns:
               0116 ; - HL: Address of first character after token
               0117 ; -  C: Length of token (in characters)
               0118 ;
0B00A7 0E      0119 _get_token:		LD	C, 0			; Initialise length
0B00A8 00 
0B00A9 7E      0120 @@:			LD	A, (HL)			; Get the character from the parameter string
0B00AA B7      0121 OR	A			; Exit if 0 (end of parameter string in MOS)
0B00AB C8      0122 RET 	Z
0B00AC FE      0123 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AD 0D 
0B00AE C8      0124 RET	Z
0B00AF FE      0125 CP	' '			; Exit if space (end of token)
0B00B0 20 
0B00B1 C8      0126 RET	Z
0B00B2 23      0127 INC	HL			; Advance to next character
0B00B3 0C      0128 INC 	C			; Increment length
0B00B4 18      0129 JR	@B
0B00B5 F3 
               0130 
               0131 ; Skip spaces in the parameter string
               0132 ; Parameters:
               0133 ; - HL: Address of parameter string
               0134 ; Returns:
               0135 ; - HL: Address of next none-space character
               0136 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0137 ;
0B00B6 7E      0138 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B7 FE      0139 CP	' '			; Exit if not space
0B00B8 20 
0B00B9 C0      0140 RET	NZ
0B00BA 23      0141 INC	HL			; Advance to next character
0B00BB 18      0142 JR	_skip_spaces		; Increment length
0B00BC F9 
               0143 
               0144 ; ========================================
               0145 ; BASIC INITIALIZATION CODE FROM basic/init.asm
               0146 ; ========================================
               0147 ;
               0148 ;Clear the application memory
               0149 ;
               0150 _clear_ram:
0B00BD E5      0151 push hl
0B00BE C5      0152 PUSH		BC
0B00BF 21      0153 LD		HL, RAM_START
0B00C0 00 
0B00C1 1A 
0B00C2 0B 
0B00C3 11      0154 LD		DE, RAM_START + 1
0B00C4 01 
0B00C5 1A 
0B00C6 0B 
0B00C7 01      0155 LD		BC, RAM_END - RAM_START - 1
0B00C8 4F 
0B00C9 03 
0B00CA 00 
0B00CB AF      0156 XOR		A
0B00CC 77      0157 LD		(HL), A
0B00CD ED      0158 LDIR
0B00CE B0 
0B00CF C1      0159 POP		BC
0B00D0 E1      0160 pop hl
0B00D1 C9      0161 RET
               0162 
               0163 ; ========================================
               0164 ; BEGIN APPLICATION CODE
               0165 ; ========================================
               0166 
               0167 ; API INCLUDES
               0168 include "basic/fpp.asm"
              0001* ;
              0002* ; Title:	BBC Basic Interpreter - Z80 version
              0003* ;		Z80 Floating Point Package
              0004* ; Author:	(C) Copyright  R.T.Russell  1986
              0005* ; Modified By:	Dean Belfield
              0006* ; Created:	03/05/2022
              0007* ; Last Updated:	07/06/2023
              0008* ;
              0009* ; Modinfo:
              0010* ; 26/10/1986:	Version 0.0
              0011* ; 14/12/1988:	Vesion 0.1 (Bug Fix)
              0012* ; 12/05/2023:	Modified by Dean Belfield
              0013* ; 07/06/2023:	Modified to run in ADL mode
              0014* 
              0015* ; .ASSUME	ADL = 1
              0016* 
              0017* ; SEGMENT CODE
              0018* 
              0019* ; XDEF	FPP
              0020* ; XDEF	DLOAD5
              0021* ; XDEF	DLOAD5_SPL
              0022* ;
              0023* ;BINARY FLOATING POINT REPRESENTATION:
              0024* ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
              0025* ;    8 BIT EXCESS-128 SIGNED EXPONENT
              0026* ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
              0027* ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
              0028* ;
              0029* ;BINARY INTEGER REPRESENTATION:
              0030* ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
              0031* ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
              0032* ;
              0033* ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
              0034* ;                            EXPONENT - C
              0035* ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
              0036* ;                               EXPONENT - B
              0037* 
              0038* ;
              0039* ;Error codes:
              0040* ;
              0041* 
              0042* BADOP:			EQU     1               ;Bad operation code
              0043* DIVBY0:			EQU     18              ;Division by zero
              0044* TOOBIG_FP:			EQU     20              ;Too big
              0045* NGROOT:			EQU     21              ;Negative root
              0046* LOGRNG:			EQU     22              ;Log range
              0047* ACLOST:			EQU     23              ;Accuracy lost
              0048* EXPRNG:			EQU     24              ;Exp range
              0049* ;
              0050* ;Call entry and despatch code:
              0051* ;
0B00D2 FD     0052* FPP:			PUSH    IY              ;Save IY
0B00D3 E5 
0B00D4 FD     0053* LD      IY,0
0B00D5 21 
0B00D6 00 
0B00D7 00 
0B00D7 00   
0B00D9 FD     0054* ADD     IY,SP           ;Save SP in IY
0B00DA 39 
0B00DB CD     0055* CALL    OP              ;Perform operation
0B00DC EB 
0B00DD 00 
0B00DE 0B 
0B00DF BF     0056* CP      A               ;Good return (Z, NC)
0B00E0 FD     0057* EXIT_FP_:			POP     IY              ;Restore IY
0B00E1 E1 
0B00E2 C9     0058* RET                     ;Return to caller
              0059* ;
              0060* ;Error exit:
              0061* ;
0B00E3 3E     0062* BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B00E4 01 
0B00E5 FD     0063* ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B00E6 F9 
0B00E7 B7     0064* OR      A               ;Set NZ
0B00E8 37     0065* SCF                     ;Set C
0B00E9 18     0066* JR      EXIT_FP_
0B00EA F5 
              0067* ;
              0068* ;Perform operation or function:
              0069* ;
              0070* ; OP:			CP      (RTABLE-DTABLE)/3
0B00EB FE     0071* OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B00EC 2A 
              0072* 
0B00ED 30     0073* JR      NC,BAD_FP
0B00EE F4 
              0074* ; CP      (FTABLE-DTABLE)/3
0B00EF FE     0075* CP      FTABLE-DTABLE/3 ; ditto
0B00F0 10 
0B00F1 30     0076* JR      NC,DISPAT_FP
0B00F2 08 
0B00F3 08     0077* EX      AF,AF'
0B00F4 78     0078* LD      A,B
0B00F5 B1     0079* OR      C               ;Both integer?
0B00F6 C4     0080* CALL    NZ,FLOATA       ;No, so float both
0B00F7 FE 
0B00F8 0B 
0B00F9 0B 
0B00FA 08     0081* EX      AF,AF'
0B00FB E5     0082* DISPAT_FP:			PUSH    HL
0B00FC 21     0083* LD      HL,DTABLE
0B00FD 0E 
0B00FE 01 
0B00FF 0B 
0B0100 C5     0084* PUSH    BC
0B0101 01     0085* LD	BC, 3		; C = 3
0B0102 03 
0B0103 00 
0B0104 00 
0B0105 47     0086* LD	B, A 		; B = op-code
0B0106 ED     0087* MLT 	BC 		;BC = op-code * 3
0B0107 4C 
0B0108 09     0088* ADD	HL, BC 		;Add to table base
0B0109 ED     0089* LD	HL, (HL)	;Get the routine address (24-bit)
0B010A 27 
              0090* 
              0091* ;        		ADD     A, A            ;A = op-code * 2
              0092* ;        		LD      C,A
              0093* ;        		LD      B,0             ;BC = op-code * 2
              0094* ;        		ADD     HL,BC
              0095* ;        		LD      A,(HL)          ;Get low byte
              0096* ;        		INC     HL
              0097* ;        		LD      H,(HL)          ;Get high byte
              0098* ;        		LD      L,A
              0099* 
0B010B C1     0100* POP     BC
0B010C E3     0101* EX      (SP),HL
0B010D C9     0102* RET                     ;Off to routine
              0103* ;
              0104* ;Despatch table:
              0105* ;
0B010E C0     0106* DTABLE:			DW24  IAND            ;AND (INTEGER)
0B010F 01 
0B0110 0B 
0B0111 2E     0107* DW24  IBDIV           ;DIV
0B0112 02 
0B0113 0B 
0B0114 D3     0108* DW24  IEOR            ;EOR
0B0115 01 
0B0116 0B 
0B0117 F9     0109* DW24  IMOD            ;MOD
0B0118 01 
0B0119 0B 
0B011A E6     0110* DW24  IOR             ;OR
0B011B 01 
0B011C 0B 
0B011D B4     0111* DW24  ILE             ;<=
0B011E 04 
0B011F 0B 
0B0120 C3     0112* DW24  INE             ;<>
0B0121 04 
0B0122 0B 
0B0123 A7     0113* DW24  IGE             ;>=
0B0124 04 
0B0125 0B 
0B0126 8C     0114* DW24  ILT             ;<
0B0127 04 
0B0128 0B 
0B0129 D0     0115* DW24  IEQ             ;=
0B012A 04 
0B012B 0B 
0B012C 1C     0116* DW24  IMUL            ;*
0B012D 03 
0B012E 0B 
0B012F 57     0117* DW24  IADD            ;+
0B0130 02 
0B0131 0B 
0B0132 99     0118* DW24  IGT             ;>
0B0133 04 
0B0134 0B 
0B0135 3E     0119* DW24  ISUB            ;-
0B0136 02 
0B0137 0B 
0B0138 D3     0120* DW24  IPOW            ;^
0B0139 03 
0B013A 0B 
0B013B C9     0121* DW24  IDIV            ;/
0B013C 02 
0B013D 0B 
              0122* ;
              0123* FTABLE:
0B013E E2     0124* DW24  ABSV_FP            ;ABS
0B013F 04 
0B0140 0B 
0B0141 C8     0125* DW24  ACS_FP             ;ACS
0B0142 08 
0B0143 0B 
0B0144 06     0126* DW24  ASN_FP             ;ASN
0B0145 08 
0B0146 0B 
0B0147 36     0127* DW24  ATN_FP             ;ATN
0B0148 08 
0B0149 0B 
0B014A 01     0128* DW24  COS_FP             ;COS
0B014B 06 
0B014C 0B 
0B014D 10     0129* DW24  DEG_FP             ;DEG
0B014E 05 
0B014F 0B 
0B0150 BD     0130* DW24  EXP_FP             ;EXP
0B0151 06 
0B0152 0B 
0B0153 64     0131* DW24  INT_FP_            ;INT
0B0154 05 
0B0155 0B 
0B0156 5B     0132* DW24  LN_FP              ;LN
0B0157 07 
0B0158 0B 
0B0159 F0     0133* DW24  LOG_FP             ;LOG
0B015A 07 
0B015B 0B 
0B015C EE     0134* DW24  NOTK_FP            ;NOT
0B015D 04 
0B015E 0B 
0B015F 1A     0135* DW24  RAD_FP             ;RAD
0B0160 05 
0B0161 0B 
0B0162 35     0136* DW24  SGN_FP             ;SGN
0B0163 05 
0B0164 0B 
0B0165 0E     0137* DW24  SIN_FP             ;SIN
0B0166 06 
0B0167 0B 
0B0168 7D     0138* DW24  SQR_FP             ;SQR
0B0169 05 
0B016A 0B 
0B016B DB     0139* DW24  TAN_FP             ;TAN
0B016C 05 
0B016D 0B 
              0140* ;
0B016E 8B     0141* DW24  ZERO_FP            ;ZERO
0B016F 0C 
0B0170 0B 
0B0171 96     0142* DW24  FONE_FP            ;FONE
0B0172 06 
0B0173 0B 
0B0174 D5     0143* DW24  TRUE_FP            ;TRUE
0B0175 04 
0B0176 0B 
0B0177 02     0144* DW24  PI_FP              ;PI
0B0178 05 
0B0179 0B 
              0145* ;
0B017A 49     0146* DW24  VAL_FP             ;VAL
0B017B 05 
0B017C 0B 
0B017D D1     0147* DW24  STR_FP             ;STR$
0B017E 08 
0B017F 0B 
              0148* ;
0B0180 32     0149* DW24  SFIX_FP            ;FIX
0B0181 0B 
0B0182 0B 
0B0183 0E     0150* DW24  SFLOAT_FP          ;FLOAT
0B0184 0C 
0B0185 0B 
              0151* ;
0B0186 5C     0152* DW24  FTEST_FP           ;TEST
0B0187 0C 
0B0188 0B 
0B0189 6E     0153* DW24  FCOMP_FP           ;COMPARE
0B018A 0C 
0B018B 0B 
              0154* ;
0B018C BC     0155* RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B018D 01 
0B018E 0B 
0B018F 2A     0156* DW24  FBDIV           ;DIV
0B0190 02 
0B0191 0B 
0B0192 CF     0157* DW24  FEOR            ;EOR
0B0193 01 
0B0194 0B 
0B0195 F5     0158* DW24  FMOD            ;MOD
0B0196 01 
0B0197 0B 
0B0198 E2     0159* DW24  FFOR             ;OR
0B0199 01 
0B019A 0B 
0B019B AE     0160* DW24  FLE             ;<=
0B019C 04 
0B019D 0B 
0B019E BD     0161* DW24  FNE             ;<>
0B019F 04 
0B01A0 0B 
0B01A1 A1     0162* DW24  FGE             ;>=
0B01A2 04 
0B01A3 0B 
0B01A4 86     0163* DW24  FLT             ;<
0B01A5 04 
0B01A6 0B 
0B01A7 CA     0164* DW24  FEQ             ;=
0B01A8 04 
0B01A9 0B 
0B01AA 76     0165* DW24  FMUL            ;*
0B01AB 03 
0B01AC 0B 
0B01AD 64     0166* DW24  FADD            ;+
0B01AE 02 
0B01AF 0B 
0B01B0 93     0167* DW24  FGT             ;>
0B01B1 04 
0B01B2 0B 
0B01B3 4B     0168* DW24  FSUB            ;-
0B01B4 02 
0B01B5 0B 
0B01B6 53     0169* DW24  FPOW            ;^
0B01B7 04 
0B01B8 0B 
0B01B9 CD     0170* DW24  FDIV            ;/
0B01BA 02 
0B01BB 0B 
              0171* ;
              0172* ;       PAGE
              0173* ;
              0174* ;ARITHMETIC AND LOGICAL OPERATORS:
              0175* ;All take two arguments, in HLH'L'C & DED'E'B.
              0176* ;Output in HLH'L'C
              0177* ;All registers except IX, IY destroyed.
              0178* ; (N.B. FPOW destroys IX).
              0179* ;
              0180* ;FAND - Floating-point AND.
              0181* ;IAND - Integer AND.
              0182* ;
0B01BC CD     0183* FAND:			CALL    FIX2
0B01BD 26 
0B01BE 0B 
0B01BF 0B 
0B01C0 7C     0184* IAND:			LD      A,H
0B01C1 A2     0185* AND     D
0B01C2 67     0186* LD      H,A
0B01C3 7D     0187* LD      A,L
0B01C4 A3     0188* AND     E
0B01C5 6F     0189* LD      L,A
0B01C6 D9     0190* EXX
0B01C7 7C     0191* LD      A,H
0B01C8 A2     0192* AND     D
0B01C9 67     0193* LD      H,A
0B01CA 7D     0194* LD      A,L
0B01CB A3     0195* AND     E
0B01CC 6F     0196* LD      L,A
0B01CD D9     0197* EXX
0B01CE C9     0198* RET
              0199* ;
              0200* ;FEOR - Floating-point exclusive-OR.
              0201* ;IEOR - Integer exclusive-OR.
              0202* ;
0B01CF CD     0203* FEOR:			CALL    FIX2
0B01D0 26 
0B01D1 0B 
0B01D2 0B 
0B01D3 7C     0204* IEOR:			LD      A,H
0B01D4 AA     0205* XOR     D
0B01D5 67     0206* LD      H,A
0B01D6 7D     0207* LD      A,L
0B01D7 AB     0208* XOR     E
0B01D8 6F     0209* LD      L,A
0B01D9 D9     0210* EXX
0B01DA 7C     0211* LD      A,H
0B01DB AA     0212* XOR     D
0B01DC 67     0213* LD      H,A
0B01DD 7D     0214* LD      A,L
0B01DE AB     0215* XOR     E
0B01DF 6F     0216* LD      L,A
0B01E0 D9     0217* EXX
0B01E1 C9     0218* RET
              0219* ;
              0220* ;FOR - Floating-point OR.
              0221* ;IOR - Integer OR.
              0222* ;
0B01E2 CD     0223* FFOR:			CALL    FIX2
0B01E3 26 
0B01E4 0B 
0B01E5 0B 
0B01E6 7C     0224* IOR:			LD      A,H
0B01E7 B2     0225* OR      D
0B01E8 67     0226* LD      H,A
0B01E9 7D     0227* LD      A,L
0B01EA B3     0228* OR      E
0B01EB 6F     0229* LD      L,A
0B01EC D9     0230* EXX
0B01ED 7C     0231* LD      A,H
0B01EE B2     0232* OR      D
0B01EF 67     0233* LD      H,A
0B01F0 7D     0234* LD      A,L
0B01F1 B3     0235* OR      E
0B01F2 6F     0236* LD      L,A
0B01F3 D9     0237* EXX
0B01F4 C9     0238* RET
              0239* ;
              0240* ;FMOD - Floating-point remainder.
              0241* ;IMOD - Integer remainder.
              0242* ;
0B01F5 CD     0243* FMOD:			CALL    FIX2
0B01F6 26 
0B01F7 0B 
0B01F8 0B 
0B01F9 7C     0244* IMOD:			LD      A,H
0B01FA AA     0245* XOR     D               ;DIV RESULT SIGN
0B01FB CB     0246* BIT     7,H
0B01FC 7C 
0B01FD 08     0247* EX      AF,AF'
0B01FE CB     0248* BIT     7,H
0B01FF 7C 
0B0200 C4     0249* CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B0201 42 
0B0202 0B 
0B0203 0B 
0B0204 CD     0250* CALL    SWAP_FP
0B0205 3F 
0B0206 0C 
0B0207 0B 
0B0208 CB     0251* BIT     7,H
0B0209 7C 
0B020A C4     0252* CALL    NZ,NEGATE
0B020B 42 
0B020C 0B 
0B020D 0B 
0B020E 44     0253* LD      B,H
0B020F 4D     0254* LD      C,L
0B0210 21     0255* LD      HL,0
0B0211 00 
0B0212 00 
0B0213 00 
0B0214 D9     0256* EXX
0B0215 44     0257* LD      B,H
0B0216 4D     0258* LD      C,L
0B0217 21     0259* LD      HL,0
0B0218 00 
0B0219 00 
0B021A 00 
0B021B 3E     0260* LD      A,-33
0B021C DF 
0B021D CD     0261* CALL    DIVA            ;DIVIDE
0B021E CC 
0B021F 0D 
0B0220 0B 
0B0221 D9     0262* EXX
0B0222 0E     0263* LD      C,0             ;INTEGER MARKER
0B0223 00 
0B0224 08     0264* EX      AF,AF'
0B0225 C8     0265* RET     Z
0B0226 C3     0266* JP      NEGATE
0B0227 42 
0B0228 0B 
0B0229 0B 
              0267* ;
              0268* ;BDIV - Integer division.
              0269* ;
0B022A CD     0270* FBDIV:			CALL    FIX2
0B022B 26 
0B022C 0B 
0B022D 0B 
0B022E CD     0271* IBDIV:			CALL    IMOD
0B022F F9 
0B0230 01 
0B0231 0B 
0B0232 B7     0272* OR      A
0B0233 CD     0273* CALL    SWAP_FP
0B0234 3F 
0B0235 0C 
0B0236 0B 
0B0237 0E     0274* LD      C,0
0B0238 00 
0B0239 F0     0275* RET     P
0B023A C3     0276* JP      NEGATE
0B023B 42 
0B023C 0B 
0B023D 0B 
              0277* ;
              0278* ;ISUB - Integer subtraction.
              0279* ;FSUB - Floating point subtraction with rounding.
              0280* ;
0B023E CD     0281* ISUB:			CALL    SUB_
0B023F DA 
0B0240 0C 
0B0241 0B 
0B0242 E0     0282* RET     PO
0B0243 CD     0283* CALL    ADD_
0B0244 D2 
0B0245 0C 
0B0246 0B 
0B0247 CD     0284* CALL    FLOAT2
0B0248 02 
0B0249 0C 
0B024A 0B 
0B024B 7A     0285* FSUB:			LD      A,D
0B024C EE     0286* XOR     80H             ;CHANGE SIGN THEN ADD
0B024D 80 
0B024E 57     0287* LD      D,A
0B024F 18     0288* JR      FADD
0B0250 13 
              0289* ;
              0290* ;Reverse subtract.
              0291* ;
0B0251 7C     0292* RSUB:			LD      A,H
0B0252 EE     0293* XOR     80H
0B0253 80 
0B0254 67     0294* LD      H,A
0B0255 18     0295* JR      FADD
0B0256 0D 
              0296* ;
              0297* ;IADD - Integer addition.
              0298* ;FADD - Floating point addition with rounding.
              0299* ;
0B0257 CD     0300* IADD:			CALL    ADD_
0B0258 D2 
0B0259 0C 
0B025A 0B 
0B025B E0     0301* RET     PO
0B025C CD     0302* CALL    SUB_
0B025D DA 
0B025E 0C 
0B025F 0B 
0B0260 CD     0303* CALL    FLOAT2
0B0261 02 
0B0262 0C 
0B0263 0B 
0B0264 05     0304* FADD:			DEC     B
0B0265 04     0305* INC     B
0B0266 C8     0306* RET     Z               ;ARG 2 ZERO
0B0267 0D     0307* DEC     C
0B0268 0C     0308* INC     C
0B0269 CA     0309* JP      Z,SWAP_FP          ;ARG 1 ZERO
0B026A 3F 
0B026B 0C 
0B026C 0B 
0B026D D9     0310* EXX
0B026E 01     0311* LD      BC,0            ;INITIALISE
0B026F 00 
0B0270 00 
0B0271 00 
0B0272 D9     0312* EXX
0B0273 7C     0313* LD      A,H
0B0274 AA     0314* XOR     D               ;XOR SIGNS
0B0275 F5     0315* PUSH    AF
0B0276 78     0316* LD      A,B
0B0277 B9     0317* CP      C               ;COMPARE EXPONENTS
0B0278 DC     0318* CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B0279 3F 
0B027A 0C 
0B027B 0B 
0B027C 78     0319* LD      A,B
0B027D CB     0320* SET     7,H             ;IMPLIED 1
0B027E FC 
0B027F C4     0321* CALL    NZ,FIX          ;ALIGN
0B0280 13 
0B0281 0B 
0B0282 0B 
0B0283 F1     0322* POP     AF
0B0284 7A     0323* LD      A,D             ;SIGN OF LARGER
0B0285 CB     0324* SET     7,D             ;IMPLIED 1
0B0286 FA 
0B0287 FA     0325* JP      M,FADD3         ;SIGNS DIFFERENT
0B0288 97 
0B0289 02 
0B028A 0B 
0B028B CD     0326* CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B028C D2 
0B028D 0C 
0B028E 0B 
0B028F DC     0327* CALL    C,DIV2          ;NORMALISE
0B0290 47 
0B0291 0C 
0B0292 0B 
0B0293 CB     0328* SET     7,H
0B0294 FC 
0B0295 18     0329* JR      FADD4
0B0296 0D 
              0330* ;
0B0297 CD     0331* FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B0298 DA 
0B0299 0C 
0B029A 0B 
0B029B DC     0332* CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B029C 5A 
0B029D 0B 
0B029E 0B 
0B029F CD     0333* CALL    FLO48
0B02A0 D9 
0B02A1 0B 
0B02A2 0B 
0B02A3 2F     0334* CPL                     ;CHANGE RESULT SIGN
0B02A4 D9     0335* FADD4:			EXX
0B02A5 EB     0336* EX      DE,HL
0B02A6 21     0337* LD      HL,8000H
0B02A7 00 
0B02A8 80 
0B02A9 00 
0B02AA B7     0338* OR      A               ;CLEAR CARRY
0B02AB 52     0339* SBC.S   HL,BC
0B02AC ED 
0B02AD 42 
0B02AE EB     0340* EX      DE,HL
0B02AF D9     0341* EXX
0B02B0 CC     0342* CALL    Z,ODD           ;ROUND UNBIASSED
0B02B1 39 
0B02B2 0C 
0B02B3 0B 
0B02B4 DC     0343* CALL    C,ADD1_FP          ;ROUND UP
0B02B5 27 
0B02B6 0C 
0B02B7 0B 
0B02B8 DC     0344* CALL    C,INCC
0B02B9 54 
0B02BA 0C 
0B02BB 0B 
0B02BC CB     0345* RES     7,H
0B02BD BC 
0B02BE 0D     0346* DEC     C
0B02BF 0C     0347* INC     C
0B02C0 CA     0348* JP      Z,ZERO_FP
0B02C1 8B 
0B02C2 0C 
0B02C3 0B 
0B02C4 B7     0349* OR      A               ;RESULT SIGNQ
0B02C5 F0     0350* RET     P               ;POSITIVE
0B02C6 CB     0351* SET     7,H             ;NEGATIVE
0B02C7 FC 
0B02C8 C9     0352* RET
              0353* ;
              0354* ;IDIV - Integer division.
              0355* ;FDIV - Floating point division with rounding.
              0356* ;
0B02C9 CD     0357* IDIV:			CALL    FLOAT2
0B02CA 02 
0B02CB 0C 
0B02CC 0B 
0B02CD 05     0358* FDIV:			DEC     B               ;TEST FOR ZERO
0B02CE 04     0359* INC     B
0B02CF 3E     0360* LD      A,DIVBY0
0B02D0 12 
0B02D1 CA     0361* JP      Z,ERROR_FP_         ;"Division by zero"
0B02D2 E5 
0B02D3 00 
0B02D4 0B 
0B02D5 0D     0362* DEC     C               ;TEST FOR ZERO
0B02D6 0C     0363* INC     C
0B02D7 C8     0364* RET     Z
0B02D8 7C     0365* LD      A,H
0B02D9 AA     0366* XOR     D               ;CALC. RESULT SIGN
0B02DA 08     0367* EX      AF,AF'          ;SAVE SIGN
0B02DB CB     0368* SET     7,D             ;REPLACE IMPLIED 1's
0B02DC FA 
0B02DD CB     0369* SET     7,H
0B02DE FC 
0B02DF C5     0370* PUSH    BC              ;SAVE EXPONENTS
0B02E0 42     0371* LD      B,D             ;LOAD REGISTERS
0B02E1 4B     0372* LD      C,E
0B02E2 11     0373* LD      DE,0
0B02E3 00 
0B02E4 00 
0B02E5 00 
0B02E6 D9     0374* EXX
0B02E7 42     0375* LD      B,D
0B02E8 4B     0376* LD      C,E
0B02E9 11     0377* LD      DE,0
0B02EA 00 
0B02EB 00 
0B02EC 00 
0B02ED 3E     0378* LD      A,-32           ;LOOP COUNTER
0B02EE E0 
0B02EF CD     0379* CALL    DIVA            ;DIVIDE
0B02F0 CC 
0B02F1 0D 
0B02F2 0B 
0B02F3 D9     0380* EXX
0B02F4 CB     0381* BIT     7,D
0B02F5 7A 
0B02F6 D9     0382* EXX
0B02F7 CC     0383* CALL    Z,DIVB          ;NORMALISE & INC A
0B02F8 EB 
0B02F9 0D 
0B02FA 0B 
0B02FB EB     0384* EX      DE,HL
0B02FC D9     0385* EXX
0B02FD CB     0386* SRL     B               ;DIVISOR/2
0B02FE 38 
0B02FF CB     0387* RR      C
0B0300 19 
0B0301 B7     0388* OR      A               ;CLEAR CARRY
0B0302 52     0389* SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B0303 ED 
0B0304 42 
0B0305 3F     0390* CCF
0B0306 EB     0391* EX      DE,HL           ;RESULT IN HLH'L'
0B0307 CC     0392* CALL    Z,ODD           ;ROUND UNBIASSED
0B0308 39 
0B0309 0C 
0B030A 0B 
0B030B DC     0393* CALL    C,ADD1_FP          ;ROUND UP
0B030C 27 
0B030D 0C 
0B030E 0B 
0B030F C1     0394* POP     BC              ;RESTORE EXPONENTS
0B0310 DC     0395* CALL    C,INCC
0B0311 54 
0B0312 0C 
0B0313 0B 
0B0314 1F     0396* RRA                     ;LSB OF A TO CARRY
0B0315 79     0397* LD      A,C             ;COMPUTE NEW EXPONENT
0B0316 98     0398* SBC     A,B
0B0317 3F     0399* CCF
0B0318 C3     0400* JP      CHKOVF
0B0319 B9 
0B031A 03 
0B031B 0B 
              0401* ;
              0402* ;IMUL - Integer multiplication.
              0403* ;
0B031C 7C     0404* IMUL:			LD      A,H
0B031D AA     0405* XOR     D
0B031E 08     0406* EX      AF,AF'          ;SAVE RESULT SIGN
0B031F CB     0407* BIT     7,H
0B0320 7C 
0B0321 C4     0408* CALL    NZ,NEGATE
0B0322 42 
0B0323 0B 
0B0324 0B 
0B0325 CD     0409* CALL    SWAP_FP
0B0326 3F 
0B0327 0C 
0B0328 0B 
0B0329 CB     0410* BIT     7,H
0B032A 7C 
0B032B C4     0411* CALL    NZ,NEGATE
0B032C 42 
0B032D 0B 
0B032E 0B 
0B032F 44     0412* LD      B,H
0B0330 4D     0413* LD      C,L
0B0331 21     0414* LD      HL,0
0B0332 00 
0B0333 00 
0B0334 00 
0B0335 D9     0415* EXX
0B0336 44     0416* LD      B,H
0B0337 4D     0417* LD      C,L
0B0338 21     0418* LD      HL,0
0B0339 00 
0B033A 00 
0B033B 00 
0B033C 3E     0419* LD      A,-33
0B033D DF 
0B033E CD     0420* CALL    MULA            ;MULTIPLY
0B033F 03 
0B0340 0E 
0B0341 0B 
0B0342 D9     0421* EXX
0B0343 0E     0422* LD      C,191           ;PRESET EXPONENT
0B0344 BF 
0B0345 CD     0423* CALL    TEST_FP            ;TEST RANGE
0B0346 67 
0B0347 0C 
0B0348 0B 
0B0349 20     0424* JR      NZ,IMUL1        ;TOO BIG
0B034A 0F 
0B034B CB     0425* BIT     7,D
0B034C 7A 
0B034D 20     0426* JR      NZ,IMUL1
0B034E 0B 
0B034F CD     0427* CALL    SWAP_FP
0B0350 3F 
0B0351 0C 
0B0352 0B 
0B0353 4A     0428* LD      C,D             ;INTEGER MARKER
0B0354 08     0429* EX      AF,AF'
0B0355 F0     0430* RET     P
0B0356 C3     0431* JP      NEGATE
0B0357 42 
0B0358 0B 
0B0359 0B 
              0432* ;
0B035A 0D     0433* IMUL1:			DEC     C
0B035B D9     0434* EXX
0B035C CB     0435* SLA     E
0B035D 23 
0B035E CB     0436* RL      D
0B035F 12 
0B0360 D9     0437* EXX
0B0361 CB     0438* RL      E
0B0362 13 
0B0363 CB     0439* RL      D
0B0364 12 
0B0365 D9     0440* EXX
0B0366 52     0441* ADC.S   HL,HL
0B0367 ED 
0B0368 6A 
0B0369 D9     0442* EXX
0B036A 52     0443* ADC.S   HL,HL
0B036B ED 
0B036C 6A 
0B036D F2     0444* JP      P,IMUL1         ;NORMALISE
0B036E 5A 
0B036F 03 
0B0370 0B 
0B0371 08     0445* EX      AF,AF'
0B0372 F8     0446* RET     M
0B0373 CB     0447* RES     7,H             ;POSITIVE
0B0374 BC 
0B0375 C9     0448* RET
              0449* ;
              0450* ;FMUL - Floating point multiplication with rounding.
              0451* ;
0B0376 05     0452* FMUL:			DEC     B               ;TEST FOR ZERO
0B0377 04     0453* INC     B
0B0378 CA     0454* JP      Z,ZERO_FP
0B0379 8B 
0B037A 0C 
0B037B 0B 
0B037C 0D     0455* DEC     C               ;TEST FOR ZERO
0B037D 0C     0456* INC     C
0B037E C8     0457* RET     Z
0B037F 7C     0458* LD      A,H
0B0380 AA     0459* XOR     D               ;CALC. RESULT SIGN
0B0381 08     0460* EX      AF,AF'
0B0382 CB     0461* SET     7,D             ;REPLACE IMPLIED 1's
0B0383 FA 
0B0384 CB     0462* SET     7,H
0B0385 FC 
0B0386 C5     0463* PUSH    BC              ;SAVE EXPONENTS
0B0387 44     0464* LD      B,H             ;LOAD REGISTERS
0B0388 4D     0465* LD      C,L
0B0389 21     0466* LD      HL,0
0B038A 00 
0B038B 00 
0B038C 00 
0B038D D9     0467* EXX
0B038E 44     0468* LD      B,H
0B038F 4D     0469* LD      C,L
0B0390 21     0470* LD      HL,0
0B0391 00 
0B0392 00 
0B0393 00 
0B0394 3E     0471* LD      A,-32           ;LOOP COUNTER
0B0395 E0 
0B0396 CD     0472* CALL    MULA            ;MULTIPLY
0B0397 03 
0B0398 0E 
0B0399 0B 
0B039A DC     0473* CALL    C,MULB          ;NORMALISE & INC A
0B039B 19 
0B039C 0E 
0B039D 0B 
0B039E D9     0474* EXX
0B039F E5     0475* PUSH    HL
0B03A0 21     0476* LD      HL,8000H
0B03A1 00 
0B03A2 80 
0B03A3 00 
0B03A4 B7     0477* OR      A               ;CLEAR CARRY
0B03A5 52     0478* SBC.S   HL,DE
0B03A6 ED 
0B03A7 52 
0B03A8 E1     0479* POP     HL
0B03A9 CC     0480* CALL    Z,ODD           ;ROUND UNBIASSED
0B03AA 39 
0B03AB 0C 
0B03AC 0B 
0B03AD DC     0481* CALL    C,ADD1_FP          ;ROUND UP
0B03AE 27 
0B03AF 0C 
0B03B0 0B 
0B03B1 C1     0482* POP     BC              ;RESTORE EXPONENTS
0B03B2 DC     0483* CALL    C,INCC
0B03B3 54 
0B03B4 0C 
0B03B5 0B 
0B03B6 1F     0484* RRA                     ;LSB OF A TO CARRY
0B03B7 79     0485* LD      A,C             ;COMPUTE NEW EXPONENT
0B03B8 88     0486* ADC     A,B
0B03B9 38     0487* CHKOVF:			JR      C,CHKO1
0B03BA 06 
0B03BB F2     0488* JP      P,ZERO_FP          ;UNDERFLOW
0B03BC 8B 
0B03BD 0C 
0B03BE 0B 
0B03BF 18     0489* JR      CHKO2
0B03C0 04 
0B03C1 FA     0490* CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B03C2 56 
0B03C3 0C 
0B03C4 0B 
0B03C5 C6     0491* CHKO2:			ADD     A,80H
0B03C6 80 
0B03C7 4F     0492* LD      C,A
0B03C8 CA     0493* JP      Z,ZERO_FP
0B03C9 8B 
0B03CA 0C 
0B03CB 0B 
0B03CC 08     0494* EX      AF,AF'          ;RESTORE SIGN BIT
0B03CD CB     0495* RES     7,H
0B03CE BC 
0B03CF F0     0496* RET     P
0B03D0 CB     0497* SET     7,H
0B03D1 FC 
0B03D2 C9     0498* RET
              0499* ;
              0500* ;IPOW - Integer involution.
              0501* ;
0B03D3 CD     0502* IPOW:			CALL    SWAP_FP
0B03D4 3F 
0B03D5 0C 
0B03D6 0B 
0B03D7 CB     0503* BIT     7,H
0B03D8 7C 
0B03D9 F5     0504* PUSH    AF              ;SAVE SIGN
0B03DA C4     0505* CALL    NZ,NEGATE
0B03DB 42 
0B03DC 0B 
0B03DD 0B 
0B03DE 48     0506* IPOW0:			LD      C,B
0B03DF 06     0507* LD      B,32            ;LOOP COUNTER
0B03E0 20 
0B03E1 CD     0508* IPOW1:			CALL    X2
0B03E2 F7 
0B03E3 0C 
0B03E4 0B 
0B03E5 38     0509* JR      C,IPOW2
0B03E6 08 
0B03E7 10     0510* DJNZ    IPOW1
0B03E8 F8 
0B03E9 F1     0511* POP     AF
0B03EA D9     0512* EXX
0B03EB 2C     0513* INC     L               ;RESULT=1
0B03EC D9     0514* EXX
0B03ED 4C     0515* LD      C,H
0B03EE C9     0516* RET
              0517* ;
0B03EF F1     0518* IPOW2:			POP     AF
0B03F0 C5     0519* PUSH    BC
0B03F1 EB     0520* EX      DE,HL
0B03F2 E5     0521* PUSH    HL
0B03F3 D9     0522* EXX
0B03F4 EB     0523* EX      DE,HL
0B03F5 E5     0524* PUSH    HL
0B03F6 D9     0525* EXX
0B03F7 DD     0526* LD      IX,0
0B03F8 21 
0B03F9 00 
0B03FA 00 
0B03FA 00   
0B03FC DD     0527* ADD     IX,SP
0B03FD 39 
0B03FE 28     0528* JR      Z,IPOW4
0B03FF 48 
0B0400 C5     0529* PUSH    BC
0B0401 D9     0530* EXX
0B0402 D5     0531* PUSH    DE
0B0403 D9     0532* EXX
0B0404 D5     0533* PUSH    DE
0B0405 CD     0534* CALL    SFLOAT_FP
0B0406 0E 
0B0407 0C 
0B0408 0B 
0B0409 CD     0535* CALL    RECIP
0B040A 42 
0B040B 07 
0B040C 0B 
0B040D DD     0536* LD      (IX+4),C
0B040E 71 
0B040F 04 
0B0410 D9     0537* EXX
0B0411 DD     0538* LD      (IX+0),L
0B0412 75 
0B0413 00 
0B0414 DD     0539* LD      (IX+1),H
0B0415 74 
0B0416 01 
0B0417 D9     0540* EXX
0B0418 DD     0541* LD      (IX+2),L
0B0419 75 
0B041A 02 
0B041B DD     0542* LD      (IX+3),H
0B041C 74 
0B041D 03 
0B041E 18     0543* JR      IPOW5
0B041F 21 
              0544* ;
0B0420 C5     0545* IPOW3:			PUSH    BC
0B0421 D9     0546* EXX
0B0422 CB     0547* SLA     E
0B0423 23 
0B0424 CB     0548* RL      D
0B0425 12 
0B0426 D5     0549* PUSH    DE
0B0427 D9     0550* EXX
0B0428 CB     0551* RL      E
0B0429 13 
0B042A CB     0552* RL      D
0B042B 12 
0B042C D5     0553* PUSH    DE
0B042D 3E     0554* LD      A,'*' & 0FH
0B042E 0A 
0B042F F5     0555* PUSH    AF
0B0430 CD     0556* CALL    COPY_
0B0431 0B 
0B0432 0D 
0B0433 0B 
0B0434 CD     0557* CALL    OP              ;SQUARE
0B0435 EB 
0B0436 00 
0B0437 0B 
0B0438 F1     0558* POP     AF
0B0439 CD     0559* CALL    DLOAD5
0B043A 37 
0B043B 0A 
0B043C 0B 
0B043D DC     0560* CALL    C,OP            ;MULTIPLY BY X
0B043E EB 
0B043F 00 
0B0440 0B 
0B0441 D1     0561* IPOW5:			POP     DE
0B0442 D9     0562* EXX
0B0443 D1     0563* POP     DE
0B0444 D9     0564* EXX
0B0445 79     0565* LD      A,C
0B0446 C1     0566* POP     BC
0B0447 4F     0567* LD      C,A
0B0448 10     0568* IPOW4:			DJNZ    IPOW3
0B0449 D6 
0B044A F1     0569* POP     AF
0B044B F1     0570* POP     AF
0B044C F1     0571* POP     AF
0B044D C9     0572* RET
              0573* ;
0B044E F1     0574* FPOW0:			POP     AF
0B044F F1     0575* POP     AF
0B0450 F1     0576* POP     AF
0B0451 18     0577* JR      IPOW0
0B0452 8B 
              0578* ;
              0579* ;FPOW - Floating-point involution.
              0580* ;
0B0453 CB     0581* FPOW:			BIT     7,D
0B0454 7A 
0B0455 F5     0582* PUSH    AF
0B0456 CD     0583* CALL    SWAP_FP
0B0457 3F 
0B0458 0C 
0B0459 0B 
0B045A CD     0584* CALL    PUSH5
0B045B 1B 
0B045C 0D 
0B045D 0B 
0B045E 0D     0585* DEC     C
0B045F 0C     0586* INC     C
0B0460 28     0587* JR      Z,FPOW0
0B0461 EC 
0B0462 3E     0588* LD      A,158
0B0463 9E 
0B0464 B9     0589* CP      C
0B0465 38     0590* JR      C,FPOW1
0B0466 0A 
0B0467 3C     0591* INC     A
0B0468 CD     0592* CALL    FIX
0B0469 13 
0B046A 0B 
0B046B 0B 
0B046C 08     0593* EX      AF,AF'
0B046D F2     0594* JP      P,FPOW0
0B046E 4E 
0B046F 04 
0B0470 0B 
0B0471 CD     0595* FPOW1:			CALL    SWAP_FP
0B0472 3F 
0B0473 0C 
0B0474 0B 
0B0475 CD     0596* CALL    LN0
0B0476 5F 
0B0477 07 
0B0478 0B 
0B0479 CD     0597* CALL    POP5
0B047A 24 
0B047B 0D 
0B047C 0B 
0B047D F1     0598* POP     AF
0B047E CD     0599* CALL    FMUL
0B047F 76 
0B0480 03 
0B0481 0B 
0B0482 C3     0600* JP      EXP0
0B0483 C1 
0B0484 06 
0B0485 0B 
              0601* ;
              0602* ;Integer and floating-point compare.
              0603* ;Result is TRUE (-1) or FALSE (0).
              0604* ;
0B0486 CD     0605* FLT:			CALL    FCP
0B0487 95 
0B0488 0C 
0B0489 0B 
0B048A 18     0606* JR      ILT1
0B048B 04 
0B048C CD     0607* ILT:			CALL    ICP
0B048D 87 
0B048E 0C 
0B048F 0B 
0B0490 D0     0608* ILT1:			RET     NC
0B0491 18     0609* JR      TRUE_FP
0B0492 42 
              0610* ;
0B0493 CD     0611* FGT:			CALL    FCP
0B0494 95 
0B0495 0C 
0B0496 0B 
0B0497 18     0612* JR      IGT1
0B0498 04 
0B0499 CD     0613* IGT:			CALL    ICP
0B049A 87 
0B049B 0C 
0B049C 0B 
0B049D C8     0614* IGT1:			RET     Z
0B049E D8     0615* RET     C
0B049F 18     0616* JR      TRUE_FP
0B04A0 34 
              0617* ;
0B04A1 CD     0618* FGE:			CALL    FCP
0B04A2 95 
0B04A3 0C 
0B04A4 0B 
0B04A5 18     0619* JR      IGE1
0B04A6 04 
0B04A7 CD     0620* IGE:			CALL    ICP
0B04A8 87 
0B04A9 0C 
0B04AA 0B 
0B04AB D8     0621* IGE1:			RET     C
0B04AC 18     0622* JR      TRUE_FP
0B04AD 27 
              0623* ;
0B04AE CD     0624* FLE:			CALL    FCP
0B04AF 95 
0B04B0 0C 
0B04B1 0B 
0B04B2 18     0625* JR      ILE1
0B04B3 04 
0B04B4 CD     0626* ILE:			CALL    ICP
0B04B5 87 
0B04B6 0C 
0B04B7 0B 
0B04B8 28     0627* ILE1:			JR      Z,TRUE_FP
0B04B9 1B 
0B04BA D0     0628* RET     NC
0B04BB 18     0629* JR      TRUE_FP
0B04BC 18 
              0630* ;
0B04BD CD     0631* FNE:			CALL    FCP
0B04BE 95 
0B04BF 0C 
0B04C0 0B 
0B04C1 18     0632* JR      INE1
0B04C2 04 
0B04C3 CD     0633* INE:			CALL    ICP
0B04C4 87 
0B04C5 0C 
0B04C6 0B 
0B04C7 C8     0634* INE1:			RET     Z
0B04C8 18     0635* JR      TRUE_FP
0B04C9 0B 
              0636* ;
0B04CA CD     0637* FEQ:			CALL    FCP
0B04CB 95 
0B04CC 0C 
0B04CD 0B 
0B04CE 18     0638* JR      IEQ1
0B04CF 04 
0B04D0 CD     0639* IEQ:			CALL    ICP
0B04D1 87 
0B04D2 0C 
0B04D3 0B 
0B04D4 C0     0640* IEQ1:			RET     NZ
0B04D5 21     0641* TRUE_FP:			LD      HL,-1
0B04D6 FF 
0B04D7 FF 
0B04D8 FF 
0B04D9 D9     0642* EXX
0B04DA 21     0643* LD      HL,-1
0B04DB FF 
0B04DC FF 
0B04DD FF 
0B04DE D9     0644* EXX
0B04DF AF     0645* XOR     A
0B04E0 4F     0646* LD      C,A
0B04E1 C9     0647* RET
              0648* ;
              0649* ;FUNCTIONS:
              0650* ;
              0651* ;Result returned in HLH'L'C (floating point)
              0652* ;Result returned in HLH'L' (C=0) (integer)
              0653* ;All registers except IY destroyed.
              0654* ;
              0655* ;ABS - Absolute value
              0656* ;Result is numeric, variable type.
              0657* ;
0B04E2 CB     0658* ABSV_FP:			BIT     7,H
0B04E3 7C 
0B04E4 C8     0659* RET     Z               ;POSITIVE/ZERO
0B04E5 0D     0660* DEC     C
0B04E6 0C     0661* INC     C
0B04E7 CA     0662* JP      Z,NEGATE        ;INTEGER
0B04E8 42 
0B04E9 0B 
0B04EA 0B 
0B04EB CB     0663* RES     7,H
0B04EC BC 
0B04ED C9     0664* RET
              0665* ;
              0666* ;NOT - Complement integer.
              0667* ;Result is integer numeric.
              0668* ;
0B04EE CD     0669* NOTK_FP:			CALL    SFIX_FP
0B04EF 32 
0B04F0 0B 
0B04F1 0B 
0B04F2 7C     0670* LD      A,H
0B04F3 2F     0671* CPL
0B04F4 67     0672* LD      H,A
0B04F5 7D     0673* LD      A,L
0B04F6 2F     0674* CPL
0B04F7 6F     0675* LD      L,A
0B04F8 D9     0676* EXX
0B04F9 7C     0677* LD      A,H
0B04FA 2F     0678* CPL
0B04FB 67     0679* LD      H,A
0B04FC 7D     0680* LD      A,L
0B04FD 2F     0681* CPL
0B04FE 6F     0682* LD      L,A
0B04FF D9     0683* EXX
0B0500 AF     0684* XOR     A               ;NUMERIC MARKER
0B0501 C9     0685* RET
              0686* ;
              0687* ;PI - Return PI (3.141592654)
              0688* ;Result is floating-point numeric.
              0689* ;
0B0502 21     0690* PI_FP:			LD      HL,490FH
0B0503 0F 
0B0504 49 
0B0505 00 
0B0506 D9     0691* EXX
0B0507 21     0692* LD      HL,0DAA2H
0B0508 A2 
0B0509 DA 
0B050A 00 
0B050B D9     0693* EXX
0B050C 0E     0694* LD      C,81H
0B050D 81 
0B050E AF     0695* XOR     A               ;NUMERIC MARKER
0B050F C9     0696* RET
              0697* ;
              0698* ;DEG - Convert radians to degrees
              0699* ;Result is floating-point numeric.
              0700* ;
0B0510 CD     0701* DEG_FP:			CALL    FPI180
0B0511 24 
0B0512 05 
0B0513 0B 
0B0514 CD     0702* CALL    FMUL
0B0515 76 
0B0516 03 
0B0517 0B 
0B0518 AF     0703* XOR     A
0B0519 C9     0704* RET
              0705* ;
              0706* ;RAD - Convert degrees to radians
              0707* ;Result is floating-point numeric.
              0708* ;
0B051A CD     0709* RAD_FP:			CALL    FPI180
0B051B 24 
0B051C 05 
0B051D 0B 
0B051E CD     0710* CALL    FDIV
0B051F CD 
0B0520 02 
0B0521 0B 
0B0522 AF     0711* XOR     A
0B0523 C9     0712* RET
              0713* ;
              0714* ;180/PI
              0715* ;
0B0524 CD     0716* FPI180:			CALL    SFLOAT_FP
0B0525 0E 
0B0526 0C 
0B0527 0B 
0B0528 11     0717* LD      DE,652EH
0B0529 2E 
0B052A 65 
0B052B 00 
0B052C D9     0718* EXX
0B052D 11     0719* LD      DE,0E0D3H
0B052E D3 
0B052F E0 
0B0530 00 
0B0531 D9     0720* EXX
0B0532 06     0721* LD      B,85H
0B0533 85 
0B0534 C9     0722* RET
              0723* ;
              0724* ;SGN - Return -1, 0 or +1
              0725* ;Result is integer numeric.
              0726* ;
0B0535 CD     0727* SGN_FP:			CALL    TEST_FP
0B0536 67 
0B0537 0C 
0B0538 0B 
0B0539 B1     0728* OR      C
0B053A C8     0729* RET     Z               ;ZERO
0B053B CB     0730* BIT     7,H
0B053C 7C 
0B053D C2     0731* JP      NZ,TRUE_FP         ;-1
0B053E D5 
0B053F 04 
0B0540 0B 
0B0541 CD     0732* CALL    ZERO_FP
0B0542 8B 
0B0543 0C 
0B0544 0B 
0B0545 C3     0733* JP      ADD1_FP            ;1
0B0546 27 
0B0547 0C 
0B0548 0B 
              0734* ;
              0735* ;VAL - Return numeric value of string.
              0736* ;Input: ASCII string at IX
              0737* ;Result is variable type numeric.
              0738* ;
0B0549 CD     0739* VAL_FP:			CALL    SIGNQ
0B054A A5 
0B054B 0E 
0B054C 0B 
0B054D F5     0740* PUSH    AF
0B054E CD     0741* CALL    CON_FP
0B054F 55 
0B0550 0A 
0B0551 0B 
0B0552 F1     0742* POP     AF
0B0553 FE     0743* CP      '-'
0B0554 2D 
0B0555 3E     0744* LD      A,0             ;NUMERIC MARKER
0B0556 00 
0B0557 C0     0745* RET     NZ
0B0558 0D     0746* DEC     C
0B0559 0C     0747* INC     C
0B055A CA     0748* JP      Z,NEGATE        ;ZERO/INTEGER
0B055B 42 
0B055C 0B 
0B055D 0B 
0B055E 7C     0749* LD      A,H
0B055F EE     0750* XOR     80H             ;CHANGE SIGN (FP)
0B0560 80 
0B0561 67     0751* LD      H,A
0B0562 AF     0752* XOR     A
0B0563 C9     0753* RET
              0754* ;
              0755* ;INT - Floor function
              0756* ;Result is integer numeric.
              0757* ;
0B0564 0D     0758* INT_FP_:			DEC     C
0B0565 0C     0759* INC     C
0B0566 C8     0760* RET     Z               ;ZERO/INTEGER
0B0567 3E     0761* LD      A,159
0B0568 9F 
0B0569 44     0762* LD      B,H             ;B7=SIGN BIT
0B056A CD     0763* CALL    FIX
0B056B 13 
0B056C 0B 
0B056D 0B 
0B056E 08     0764* EX      AF,AF'
0B056F A0     0765* AND     B
0B0570 FC     0766* CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B0571 27 
0B0572 0C 
0B0573 0B 
0B0574 78     0767* LD      A,B
0B0575 B7     0768* OR      A
0B0576 FC     0769* CALL    M,NEGATE
0B0577 42 
0B0578 0B 
0B0579 0B 
0B057A AF     0770* XOR     A
0B057B 4F     0771* LD      C,A
0B057C C9     0772* RET
              0773* ;
              0774* ;SQR - square root
              0775* ;Result is floating-point numeric.
              0776* ;
0B057D CD     0777* SQR_FP:			CALL    SFLOAT_FP
0B057E 0E 
0B057F 0C 
0B0580 0B 
0B0581 CB     0778* SQR0:			BIT     7,H
0B0582 7C 
0B0583 3E     0779* LD      A,NGROOT
0B0584 15 
0B0585 C2     0780* JP      NZ,ERROR_FP_        ;"-ve root"
0B0586 E5 
0B0587 00 
0B0588 0B 
0B0589 0D     0781* DEC     C
0B058A 0C     0782* INC     C
0B058B C8     0783* RET     Z               ;ZERO
0B058C CB     0784* SET     7,H             ;IMPLIED 1
0B058D FC 
0B058E CB     0785* BIT     0,C
0B058F 41 
0B0590 CC     0786* CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B0591 47 
0B0592 0C 
0B0593 0B 
0B0594 79     0787* LD      A,C
0B0595 D6     0788* SUB     80H
0B0596 80 
0B0597 CB     0789* SRA     A               ;HALVE EXPONENT
0B0598 2F 
0B0599 C6     0790* ADD     A,80H
0B059A 80 
0B059B 4F     0791* LD      C,A
0B059C C5     0792* PUSH    BC              ;SAVE EXPONENT
0B059D EB     0793* EX      DE,HL
0B059E 21     0794* LD      HL,0
0B059F 00 
0B05A0 00 
0B05A1 00 
0B05A2 44     0795* LD      B,H
0B05A3 4D     0796* LD      C,L
0B05A4 D9     0797* EXX
0B05A5 EB     0798* EX      DE,HL
0B05A6 21     0799* LD      HL,0
0B05A7 00 
0B05A8 00 
0B05A9 00 
0B05AA 44     0800* LD      B,H
0B05AB 4D     0801* LD      C,L
0B05AC 3E     0802* LD      A,-31
0B05AD E1 
0B05AE CD     0803* CALL    SQRA            ;ROOT
0B05AF 3D 
0B05B0 0E 
0B05B1 0B 
0B05B2 D9     0804* EXX
0B05B3 CB     0805* BIT     7,B
0B05B4 78 
0B05B5 D9     0806* EXX
0B05B6 CC     0807* CALL    Z,SQRA          ;NORMALISE & INC A
0B05B7 3D 
0B05B8 0E 
0B05B9 0B 
0B05BA CD     0808* CALL    SQRB
0B05BB 7E 
0B05BC 0E 
0B05BD 0B 
0B05BE B7     0809* OR      A               ;CLEAR CARRY
0B05BF CD     0810* CALL    DIVB
0B05C0 EB 
0B05C1 0D 
0B05C2 0B 
0B05C3 CB     0811* RR      E               ;LSB TO CARRY
0B05C4 1B 
0B05C5 60     0812* LD      H,B
0B05C6 69     0813* LD      L,C
0B05C7 D9     0814* EXX
0B05C8 60     0815* LD      H,B
0B05C9 69     0816* LD      L,C
0B05CA DC     0817* CALL    C,ADD1_FP          ;ROUND UP
0B05CB 27 
0B05CC 0C 
0B05CD 0B 
0B05CE C1     0818* POP     BC              ;RESTORE EXPONENT
0B05CF DC     0819* CALL    C,INCC
0B05D0 54 
0B05D1 0C 
0B05D2 0B 
0B05D3 1F     0820* RRA
0B05D4 9F     0821* SBC     A,A
0B05D5 81     0822* ADD     A,C
0B05D6 4F     0823* LD      C,A
0B05D7 CB     0824* RES     7,H             ;POSITIVE
0B05D8 BC 
0B05D9 AF     0825* XOR     A
0B05DA C9     0826* RET
              0827* ;
              0828* ;TAN - Tangent function
              0829* ;Result is floating-point numeric.
              0830* ;
0B05DB CD     0831* TAN_FP:			CALL    SFLOAT_FP
0B05DC 0E 
0B05DD 0C 
0B05DE 0B 
0B05DF CD     0832* CALL    PUSH5
0B05E0 1B 
0B05E1 0D 
0B05E2 0B 
0B05E3 CD     0833* CALL    COS0
0B05E4 05 
0B05E5 06 
0B05E6 0B 
0B05E7 CD     0834* CALL    POP5
0B05E8 24 
0B05E9 0D 
0B05EA 0B 
0B05EB CD     0835* CALL    PUSH5
0B05EC 1B 
0B05ED 0D 
0B05EE 0B 
0B05EF CD     0836* CALL    SWAP_FP
0B05F0 3F 
0B05F1 0C 
0B05F2 0B 
0B05F3 CD     0837* CALL    SIN0
0B05F4 12 
0B05F5 06 
0B05F6 0B 
0B05F7 CD     0838* CALL    POP5
0B05F8 24 
0B05F9 0D 
0B05FA 0B 
0B05FB CD     0839* CALL    FDIV
0B05FC CD 
0B05FD 02 
0B05FE 0B 
0B05FF AF     0840* XOR     A               ;NUMERIC MARKER
0B0600 C9     0841* RET
              0842* ;
              0843* ;COS - Cosine function
              0844* ;Result is floating-point numeric.
              0845* ;
0B0601 CD     0846* COS_FP:			CALL    SFLOAT_FP
0B0602 0E 
0B0603 0C 
0B0604 0B 
0B0605 CD     0847* COS0:			CALL    SCALE
0B0606 6A 
0B0607 0B 
0B0608 0B 
0B0609 1C     0848* INC     E
0B060A 1C     0849* INC     E
0B060B 7B     0850* LD      A,E
0B060C 18     0851* JR      SIN1
0B060D 10 
              0852* ;
              0853* ;SIN - Sine function
              0854* ;Result is floating-point numeric.
              0855* ;
0B060E CD     0856* SIN_FP:			CALL    SFLOAT_FP
0B060F 0E 
0B0610 0C 
0B0611 0B 
0B0612 E5     0857* SIN0:			PUSH    HL              ;H7=SIGN
0B0613 CD     0858* CALL    SCALE
0B0614 6A 
0B0615 0B 
0B0616 0B 
0B0617 F1     0859* POP     AF
0B0618 07     0860* RLCA
0B0619 07     0861* RLCA
0B061A 07     0862* RLCA
0B061B E6     0863* AND     4
0B061C 04 
0B061D AB     0864* XOR     E
0B061E F5     0865* SIN1:			PUSH    AF              ;OCTANT
0B061F CB     0866* RES     7,H
0B0620 BC 
0B0621 1F     0867* RRA
0B0622 CD     0868* CALL    PIBY4
0B0623 B0 
0B0624 06 
0B0625 0B 
0B0626 DC     0869* CALL    C,RSUB          ;X=(PI/4)-X
0B0627 51 
0B0628 02 
0B0629 0B 
0B062A F1     0870* POP     AF
0B062B F5     0871* PUSH    AF
0B062C E6     0872* AND     3
0B062D 03 
0B062E E2     0873* JP      PO,SIN2         ;USE COSINE APPROX.
0B062F 67 
0B0630 06 
0B0631 0B 
0B0632 CD     0874* CALL    PUSH5           ;SAVE X
0B0633 1B 
0B0634 0D 
0B0635 0B 
0B0636 CD     0875* CALL    SQUARE          ;PUSH X*X
0B0637 13 
0B0638 0D 
0B0639 0B 
0B063A CD     0876* CALL    POLY
0B063B 58 
0B063C 0D 
0B063D 0B 
0B063E B7     0877* DW	0A8B7H          ;a(8)
0B063F A8 
0B0640 11     0878* DW	3611H
0B0641 36 
0B0642 6D     0879* DB	6DH
0B0643 26     0880* DW	0DE26H          ;a(6)
0B0644 DE 
0B0645 05     0881* DW	0D005H
0B0646 D0 
0B0647 73     0882* DB	73H
0B0648 C0     0883* DW	80C0H           ;a(4)
0B0649 80 
0B064A 88     0884* DW	888H
0B064B 08 
0B064C 79     0885* DB	79H
0B064D 9D     0886* DW	0AA9DH          ;a(2)
0B064E AA 
0B064F AA     0887* DW	0AAAAH
0B0650 AA 
0B0651 7D     0888* DB	7DH
0B0652 00     0889* DW	0               ;a(0)
0B0653 00 
0B0654 00     0890* DW	0
0B0655 00 
0B0656 80     0891* DB	80H
0B0657 CD     0892* CALL    POP5
0B0658 24 
0B0659 0D 
0B065A 0B 
0B065B CD     0893* CALL    POP5
0B065C 24 
0B065D 0D 
0B065E 0B 
0B065F CD     0894* CALL    FMUL
0B0660 76 
0B0661 03 
0B0662 0B 
0B0663 C3     0895* JP      SIN3
0B0664 8C 
0B0665 06 
0B0666 0B 
              0896* ;
0B0667 CD     0897* SIN2:			CALL    SQUARE          ;PUSH X*X
0B0668 13 
0B0669 0D 
0B066A 0B 
0B066B CD     0898* CALL    POLY
0B066C 58 
0B066D 0D 
0B066E 0B 
0B066F 71     0899* DW	0D571H          ;b(8)
0B0670 D5 
0B0671 78     0900* DW	4C78H
0B0672 4C 
0B0673 70     0901* DB	70H
0B0674 AF     0902* DW	94AFH           ;b(6)
0B0675 94 
0B0676 03     0903* DW	0B603H
0B0677 B6 
0B0678 76     0904* DB	76H
0B0679 C8     0905* DW	9CC8H           ;b(4)
0B067A 9C 
0B067B AA     0906* DW	2AAAH
0B067C 2A 
0B067D 7B     0907* DB	7BH
0B067E DD     0908* DW	0FFDDH          ;b(2)
0B067F FF 
0B0680 FF     0909* DW	0FFFFH
0B0681 FF 
0B0682 7E     0910* DB	7EH
0B0683 00     0911* DW	0               ;b(0)
0B0684 00 
0B0685 00     0912* DW	0
0B0686 00 
0B0687 80     0913* DB	80H
0B0688 CD     0914* CALL    POP5
0B0689 24 
0B068A 0D 
0B068B 0B 
0B068C F1     0915* SIN3:			POP     AF
0B068D E6     0916* AND     4
0B068E 04 
0B068F C8     0917* RET     Z
0B0690 0D     0918* DEC     C
0B0691 0C     0919* INC     C
0B0692 C8     0920* RET     Z               ;ZERO
0B0693 CB     0921* SET     7,H             ;MAKE NEGATIVE
0B0694 FC 
0B0695 C9     0922* RET
              0923* ;
              0924* ;Floating-point one:
              0925* ;
0B0696 21     0926* FONE_FP:			LD      HL,0
0B0697 00 
0B0698 00 
0B0699 00 
0B069A D9     0927* EXX
0B069B 21     0928* LD      HL,0
0B069C 00 
0B069D 00 
0B069E 00 
0B069F D9     0929* EXX
0B06A0 0E     0930* LD      C,80H
0B06A1 80 
0B06A2 C9     0931* RET
              0932* ;
0B06A3 11     0933* DONE:			LD      DE,0
0B06A4 00 
0B06A5 00 
0B06A6 00 
0B06A7 D9     0934* EXX
0B06A8 11     0935* LD      DE,0
0B06A9 00 
0B06AA 00 
0B06AB 00 
0B06AC D9     0936* EXX
0B06AD 06     0937* LD      B,80H
0B06AE 80 
0B06AF C9     0938* RET
              0939* ;
0B06B0 11     0940* PIBY4:			LD      DE,490FH
0B06B1 0F 
0B06B2 49 
0B06B3 00 
0B06B4 D9     0941* EXX
0B06B5 11     0942* LD      DE,0DAA2H
0B06B6 A2 
0B06B7 DA 
0B06B8 00 
0B06B9 D9     0943* EXX
0B06BA 06     0944* LD      B,7FH
0B06BB 7F 
0B06BC C9     0945* RET
              0946* ;
              0947* ;EXP - Exponential function
              0948* ;Result is floating-point numeric.
              0949* ;
0B06BD CD     0950* EXP_FP:			CALL    SFLOAT_FP
0B06BE 0E 
0B06BF 0C 
0B06C0 0B 
0B06C1 CD     0951* EXP0:			CALL    LN2             ;LN(2)
0B06C2 4E 
0B06C3 07 
0B06C4 0B 
0B06C5 D9     0952* EXX
0B06C6 1D     0953* DEC     E
0B06C7 01     0954* LD      BC,0D1CFH       ;0.6931471805599453
0B06C8 CF 
0B06C9 D1 
0B06CA 00 
0B06CB D9     0955* EXX
0B06CC E5     0956* PUSH    HL              ;H7=SIGN
0B06CD CD     0957* CALL    MOD48           ;"MODULUS"
0B06CE 7D 
0B06CF 0B 
0B06D0 0B 
0B06D1 F1     0958* POP     AF
0B06D2 CB     0959* BIT     7,E
0B06D3 7B 
0B06D4 28     0960* JR      Z,EXP1
0B06D5 0B 
0B06D6 17     0961* RLA
0B06D7 DA     0962* JP      C,ZERO_FP
0B06D8 8B 
0B06D9 0C 
0B06DA 0B 
0B06DB 3E     0963* LD      A,EXPRNG
0B06DC 18 
0B06DD C3     0964* JP      ERROR_FP_           ;"Exp range"
0B06DE E5 
0B06DF 00 
0B06E0 0B 
              0965* ;
0B06E1 E6     0966* EXP1:			AND     80H
0B06E2 80 
0B06E3 B3     0967* OR      E
0B06E4 F5     0968* PUSH    AF              ;INTEGER PART
0B06E5 CB     0969* RES     7,H
0B06E6 BC 
0B06E7 CD     0970* CALL    PUSH5           ;PUSH X*LN(2)
0B06E8 1B 
0B06E9 0D 
0B06EA 0B 
0B06EB CD     0971* CALL    POLY
0B06EC 58 
0B06ED 0D 
0B06EE 0B 
0B06EF 72     0972* DW	4072H           ;a(7)
0B06F0 40 
0B06F1 2E     0973* DW	942EH
0B06F2 94 
0B06F3 73     0974* DB	73H
0B06F4 65     0975* DW	6F65H           ;a(6)
0B06F5 6F 
0B06F6 4F     0976* DW	2E4FH
0B06F7 2E 
0B06F8 76     0977* DB	76H
0B06F9 37     0978* DW	6D37H           ;a(5)
0B06FA 6D 
0B06FB 02     0979* DW	8802H
0B06FC 88 
0B06FD 79     0980* DB	79H
0B06FE 12     0981* DW	0E512H          ;a(4)
0B06FF E5 
0B0700 A0     0982* DW	2AA0H
0B0701 2A 
0B0702 7B     0983* DB	7BH
0B0703 14     0984* DW	4F14H           ;a(3)
0B0704 4F 
0B0705 AA     0985* DW	0AAAAH
0B0706 AA 
0B0707 7D     0986* DB	7DH
0B0708 56     0987* DW	0FD56H          ;a(2)
0B0709 FD 
0B070A FF     0988* DW	7FFFH
0B070B 7F 
0B070C 7E     0989* DB	7EH
0B070D FE     0990* DW	0FFFEH          ;a(1)
0B070E FF 
0B070F FF     0991* DW	0FFFFH
0B0710 FF 
0B0711 7F     0992* DB	7FH
0B0712 00     0993* DW	0               ;a(0)
0B0713 00 
0B0714 00     0994* DW	0
0B0715 00 
0B0716 80     0995* DB	80H
0B0717 CD     0996* CALL    POP5
0B0718 24 
0B0719 0D 
0B071A 0B 
0B071B F1     0997* POP     AF
0B071C F5     0998* PUSH    AF
0B071D F4     0999* CALL    P,RECIP         ;X=1/X
0B071E 42 
0B071F 07 
0B0720 0B 
0B0721 F1     1000* POP     AF
0B0722 F2     1001* JP      P,EXP4
0B0723 2A 
0B0724 07 
0B0725 0B 
0B0726 E6     1002* AND     7FH
0B0727 7F 
0B0728 ED     1003* NEG
0B0729 44 
0B072A C6     1004* EXP4:			ADD     A,80H
0B072B 80 
0B072C 81     1005* ADD     A,C
0B072D 38     1006* JR      C,EXP2
0B072E 06 
0B072F F2     1007* JP      P,ZERO_FP          ;UNDERFLOW
0B0730 8B 
0B0731 0C 
0B0732 0B 
0B0733 18     1008* JR      EXP3
0B0734 04 
0B0735 FA     1009* EXP2:			JP      M,OFLOW         ;OVERFLOW
0B0736 56 
0B0737 0C 
0B0738 0B 
0B0739 C6     1010* EXP3:			ADD     A,80H
0B073A 80 
0B073B CA     1011* JP      Z,ZERO_FP
0B073C 8B 
0B073D 0C 
0B073E 0B 
0B073F 4F     1012* LD      C,A
0B0740 AF     1013* XOR     A               ;NUMERIC MARKER
0B0741 C9     1014* RET
              1015* ;
0B0742 CD     1016* RECIP:			CALL    DONE
0B0743 A3 
0B0744 06 
0B0745 0B 
0B0746 CD     1017* RDIV:			CALL    SWAP_FP
0B0747 3F 
0B0748 0C 
0B0749 0B 
0B074A C3     1018* JP      FDIV            ;RECIPROCAL
0B074B CD 
0B074C 02 
0B074D 0B 
              1019* ;
0B074E 11     1020* LN2:			LD      DE,3172H        ;LN(2)
0B074F 72 
0B0750 31 
0B0751 00 
0B0752 D9     1021* EXX
0B0753 11     1022* LD      DE,17F8H
0B0754 F8 
0B0755 17 
0B0756 00 
0B0757 D9     1023* EXX
0B0758 06     1024* LD      B,7FH
0B0759 7F 
0B075A C9     1025* RET
              1026* ;
              1027* ;LN - Natural log.
              1028* ;Result is floating-point numeric.
              1029* ;
0B075B CD     1030* LN_FP:			CALL    SFLOAT_FP
0B075C 0E 
0B075D 0C 
0B075E 0B 
0B075F 3E     1031* LN0:			LD      A,LOGRNG
0B0760 16 
0B0761 CB     1032* BIT     7,H
0B0762 7C 
0B0763 C2     1033* JP      NZ,ERROR_FP_        ;"Log range"
0B0764 E5 
0B0765 00 
0B0766 0B 
0B0767 0C     1034* INC     C
0B0768 0D     1035* DEC     C
0B0769 CA     1036* JP      Z,ERROR_FP_
0B076A E5 
0B076B 00 
0B076C 0B 
0B076D 11     1037* LD      DE,3504H        ;SQR(2)
0B076E 04 
0B076F 35 
0B0770 00 
0B0771 D9     1038* EXX
0B0772 11     1039* LD      DE,0F333H       ;1.41421356237
0B0773 33 
0B0774 F3 
0B0775 00 
0B0776 D9     1040* EXX
0B0777 CD     1041* CALL    ICP0            ;MANTISSA>SQR(2)?
0B0778 9E 
0B0779 0C 
0B077A 0B 
0B077B 79     1042* LD      A,C             ;EXPONENT
0B077C 0E     1043* LD      C,80H           ;1 <= X < 2
0B077D 80 
0B077E 38     1044* JR      C,LN4
0B077F 02 
0B0780 0D     1045* DEC     C
0B0781 3C     1046* INC     A
0B0782 F5     1047* LN4:			PUSH    AF              ;SAVE EXPONENT
0B0783 CD     1048* CALL    RATIO           ;X=(X-1)/(X+1)
0B0784 30 
0B0785 0D 
0B0786 0B 
0B0787 CD     1049* CALL    PUSH5
0B0788 1B 
0B0789 0D 
0B078A 0B 
0B078B CD     1050* CALL    SQUARE          ;PUSH X*X
0B078C 13 
0B078D 0D 
0B078E 0B 
0B078F CD     1051* CALL    POLY
0B0790 58 
0B0791 0D 
0B0792 0B 
0B0793 48     1052* DW	0CC48H          ;a(9)
0B0794 CC 
0B0795 FB     1053* DW	74FBH
0B0796 74 
0B0797 7D     1054* DB	7DH
0B0798 AF     1055* DW	0AEAFH          ;a(7)
0B0799 AE 
0B079A FF     1056* DW	11FFH
0B079B 11 
0B079C 7E     1057* DB	7EH
0B079D 8C     1058* DW	0D98CH          ;a(5)
0B079E D9 
0B079F CD     1059* DW	4CCDH
0B07A0 4C 
0B07A1 7E     1060* DB	7EH
0B07A2 E3     1061* DW	0A9E3H          ;a(3)
0B07A3 A9 
0B07A4 AA     1062* DW	2AAAH
0B07A5 2A 
0B07A6 7F     1063* DB	7FH
0B07A7 00     1064* DW	0               ;a(1)
0B07A8 00 
0B07A9 00     1065* DW	0
0B07AA 00 
0B07AB 81     1066* DB	81H
0B07AC CD     1067* CALL    POP5
0B07AD 24 
0B07AE 0D 
0B07AF 0B 
0B07B0 CD     1068* CALL    POP5
0B07B1 24 
0B07B2 0D 
0B07B3 0B 
0B07B4 CD     1069* CALL    FMUL
0B07B5 76 
0B07B6 03 
0B07B7 0B 
0B07B8 F1     1070* POP     AF              ;EXPONENT
0B07B9 CD     1071* CALL    PUSH5
0B07BA 1B 
0B07BB 0D 
0B07BC 0B 
0B07BD 08     1072* EX      AF,AF'
0B07BE CD     1073* CALL    ZERO_FP
0B07BF 8B 
0B07C0 0C 
0B07C1 0B 
0B07C2 08     1074* EX      AF,AF'
0B07C3 D6     1075* SUB     80H
0B07C4 80 
0B07C5 28     1076* JR      Z,LN3
0B07C6 1F 
0B07C7 30     1077* JR      NC,LN1
0B07C8 02 
0B07C9 2F     1078* CPL
0B07CA 3C     1079* INC     A
0B07CB 67     1080* LN1:			LD      H,A
0B07CC 0E     1081* LD      C,87H
0B07CD 87 
0B07CE F5     1082* PUSH    AF
0B07CF CD     1083* CALL    FLOAT_
0B07D0 EE 
0B07D1 0B 
0B07D2 0B 
0B07D3 CB     1084* RES     7,H
0B07D4 BC 
0B07D5 CD     1085* CALL    LN2
0B07D6 4E 
0B07D7 07 
0B07D8 0B 
0B07D9 CD     1086* CALL    FMUL
0B07DA 76 
0B07DB 03 
0B07DC 0B 
0B07DD F1     1087* POP     AF
0B07DE 30     1088* JR      NC,LN3
0B07DF 06 
0B07E0 FA     1089* JP      M,LN3
0B07E1 E6 
0B07E2 07 
0B07E3 0B 
0B07E4 CB     1090* SET     7,H
0B07E5 FC 
0B07E6 CD     1091* LN3:			CALL    POP5
0B07E7 24 
0B07E8 0D 
0B07E9 0B 
0B07EA CD     1092* CALL    FADD
0B07EB 64 
0B07EC 02 
0B07ED 0B 
0B07EE AF     1093* XOR     A
0B07EF C9     1094* RET
              1095* ;
              1096* ;LOG - base-10 logarithm.
              1097* ;Result is floating-point numeric.
              1098* ;
0B07F0 CD     1099* LOG_FP:			CALL    LN_FP
0B07F1 5B 
0B07F2 07 
0B07F3 0B 
0B07F4 11     1100* LD      DE,5E5BH        ;LOG(e)
0B07F5 5B 
0B07F6 5E 
0B07F7 00 
0B07F8 D9     1101* EXX
0B07F9 11     1102* LD      DE,0D8A9H
0B07FA A9 
0B07FB D8 
0B07FC 00 
0B07FD D9     1103* EXX
0B07FE 06     1104* LD      B,7EH
0B07FF 7E 
0B0800 CD     1105* CALL    FMUL
0B0801 76 
0B0802 03 
0B0803 0B 
0B0804 AF     1106* XOR     A
0B0805 C9     1107* RET
              1108* ;
              1109* ;ASN - Arc-sine
              1110* ;Result is floating-point numeric.
              1111* ;
0B0806 CD     1112* ASN_FP:			CALL    SFLOAT_FP
0B0807 0E 
0B0808 0C 
0B0809 0B 
0B080A CD     1113* CALL    PUSH5
0B080B 1B 
0B080C 0D 
0B080D 0B 
0B080E CD     1114* CALL    COPY_
0B080F 0B 
0B0810 0D 
0B0811 0B 
0B0812 CD     1115* CALL    FMUL
0B0813 76 
0B0814 03 
0B0815 0B 
0B0816 CD     1116* CALL    DONE
0B0817 A3 
0B0818 06 
0B0819 0B 
0B081A CD     1117* CALL    RSUB
0B081B 51 
0B081C 02 
0B081D 0B 
0B081E CD     1118* CALL    SQR0
0B081F 81 
0B0820 05 
0B0821 0B 
0B0822 CD     1119* CALL    POP5
0B0823 24 
0B0824 0D 
0B0825 0B 
0B0826 0C     1120* INC     C
0B0827 0D     1121* DEC     C
0B0828 3E     1122* LD      A,2
0B0829 02 
0B082A D5     1123* PUSH    DE
0B082B CA     1124* JP      Z,ACS1
0B082C B0 
0B082D 08 
0B082E 0B 
0B082F D1     1125* POP     DE
0B0830 CD     1126* CALL    RDIV
0B0831 46 
0B0832 07 
0B0833 0B 
0B0834 18     1127* JR      ATN0
0B0835 04 
              1128* ;
              1129* ;ATN - arc-tangent
              1130* ;Result is floating-point numeric.
              1131* ;
0B0836 CD     1132* ATN_FP:			CALL    SFLOAT_FP
0B0837 0E 
0B0838 0C 
0B0839 0B 
0B083A E5     1133* ATN0:			PUSH    HL              ;SAVE SIGN
0B083B CB     1134* RES     7,H
0B083C BC 
0B083D 11     1135* LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B083E 13 
0B083F 54 
0B0840 00 
0B0841 D9     1136* EXX
0B0842 11     1137* LD      DE,0CCD0H
0B0843 D0 
0B0844 CC 
0B0845 00 
0B0846 D9     1138* EXX
0B0847 06     1139* LD      B,7EH
0B0848 7E 
0B0849 CD     1140* CALL    FCP0            ;COMPARE
0B084A 9B 
0B084B 0C 
0B084C 0B 
0B084D 06     1141* LD      B,0
0B084E 00 
0B084F 38     1142* JR      C,ATN2
0B0850 22 
0B0851 11     1143* LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B0852 82 
0B0853 1A 
0B0854 00 
0B0855 D9     1144* EXX
0B0856 11     1145* LD      DE,799AH
0B0857 9A 
0B0858 79 
0B0859 00 
0B085A D9     1146* EXX
0B085B 06     1147* LD      B,81H
0B085C 81 
0B085D CD     1148* CALL    FCP0            ;COMPARE
0B085E 9B 
0B085F 0C 
0B0860 0B 
0B0861 38     1149* JR      C,ATN1
0B0862 0A 
0B0863 CD     1150* CALL    RECIP           ;X=1/X
0B0864 42 
0B0865 07 
0B0866 0B 
0B0867 06     1151* LD      B,2
0B0868 02 
0B0869 C3     1152* JP      ATN2
0B086A 73 
0B086B 08 
0B086C 0B 
0B086D CD     1153* ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B086E 30 
0B086F 0D 
0B0870 0B 
0B0871 06     1154* LD      B,1
0B0872 01 
0B0873 C5     1155* ATN2:			PUSH    BC              ;SAVE FLAG
0B0874 CD     1156* CALL    PUSH5
0B0875 1B 
0B0876 0D 
0B0877 0B 
0B0878 CD     1157* CALL    SQUARE          ;PUSH X*X
0B0879 13 
0B087A 0D 
0B087B 0B 
0B087C CD     1158* CALL    POLY
0B087D 58 
0B087E 0D 
0B087F 0B 
0B0880 35     1159* DW	0F335H          ;a(13)
0B0881 F3 
0B0882 D8     1160* DW	37D8H
0B0883 37 
0B0884 7B     1161* DB	7BH
0B0885 91     1162* DW	6B91H           ;a(11)
0B0886 6B 
0B0887 B9     1163* DW	0AAB9H
0B0888 AA 
0B0889 7C     1164* DB	7CH
0B088A DE     1165* DW	41DEH           ;a(9)
0B088B 41 
0B088C 97     1166* DW	6197H
0B088D 61 
0B088E 7C     1167* DB	7CH
0B088F 7B     1168* DW	9D7BH           ;a(7)
0B0890 9D 
0B0891 37     1169* DW	9237H
0B0892 92 
0B0893 7D     1170* DB	7DH
0B0894 5A     1171* DW	2A5AH           ;a(5)
0B0895 2A 
0B0896 CC     1172* DW	4CCCH
0B0897 4C 
0B0898 7D     1173* DB	7DH
0B0899 5C     1174* DW	0A95CH          ;a(3)
0B089A A9 
0B089B AA     1175* DW	0AAAAH
0B089C AA 
0B089D 7E     1176* DB	7EH
0B089E 00     1177* DW	0               ;a(1)
0B089F 00 
0B08A0 00     1178* DW	0
0B08A1 00 
0B08A2 80     1179* DB	80H
0B08A3 CD     1180* CALL    POP5
0B08A4 24 
0B08A5 0D 
0B08A6 0B 
0B08A7 CD     1181* CALL    POP5
0B08A8 24 
0B08A9 0D 
0B08AA 0B 
0B08AB CD     1182* CALL    FMUL
0B08AC 76 
0B08AD 03 
0B08AE 0B 
0B08AF F1     1183* POP     AF
0B08B0 CD     1184* ACS1:			CALL    PIBY4           ;PI/4
0B08B1 B0 
0B08B2 06 
0B08B3 0B 
0B08B4 1F     1185* RRA
0B08B5 F5     1186* PUSH    AF
0B08B6 DC     1187* CALL    C,FADD
0B08B7 64 
0B08B8 02 
0B08B9 0B 
0B08BA F1     1188* POP     AF
0B08BB 04     1189* INC     B
0B08BC 1F     1190* RRA
0B08BD DC     1191* CALL    C,RSUB
0B08BE 51 
0B08BF 02 
0B08C0 0B 
0B08C1 F1     1192* POP     AF
0B08C2 B7     1193* OR      A
0B08C3 F0     1194* RET     P
0B08C4 CB     1195* SET     7,H             ;MAKE NEGATIVE
0B08C5 FC 
0B08C6 AF     1196* XOR     A
0B08C7 C9     1197* RET
              1198* ;
              1199* ;ACS - Arc cosine=PI/2-ASN.
              1200* ;Result is floating point numeric.
              1201* ;
0B08C8 CD     1202* ACS_FP:			CALL    ASN_FP
0B08C9 06 
0B08CA 08 
0B08CB 0B 
0B08CC 3E     1203* LD      A,2
0B08CD 02 
0B08CE F5     1204* PUSH    AF
0B08CF 18     1205* JR      ACS1
0B08D0 DF 
              1206* ;
              1207* ;Function STR - convert numeric value to ASCII string.
              1208* ;   Inputs: HLH'L'C = integer or floating-point number
              1209* ;           DE = address at which to store string
              1210* ;           IX = address of @% format control
              1211* ;  Outputs: String stored, with NUL terminator
              1212* ;
              1213* ;First normalise for decimal output:
              1214* ;
0B08D1 CD     1215* STR_FP:			CALL    SFLOAT_FP
0B08D2 0E 
0B08D3 0C 
0B08D4 0B 
0B08D5 06     1216* LD      B,0             ;DEFAULT PT. POSITION
0B08D6 00 
0B08D7 CB     1217* BIT     7,H             ;NEGATIVE?
0B08D8 7C 
0B08D9 28     1218* JR      Z,STR10
0B08DA 06 
0B08DB CB     1219* RES     7,H
0B08DC BC 
0B08DD 3E     1220* LD      A,'-'
0B08DE 2D 
0B08DF 12     1221* LD      (DE),A          ;STORE SIGN
0B08E0 13     1222* INC     DE
0B08E1 AF     1223* STR10:			XOR     A               ;CLEAR A
0B08E2 B9     1224* CP      C
0B08E3 28     1225* JR      Z,STR02          ;ZERO
0B08E4 4E 
0B08E5 D5     1226* PUSH    DE              ;SAVE TEXT POINTER
0B08E6 78     1227* LD      A,B
0B08E7 F5     1228* STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B08E8 79     1229* LD      A,C             ;BINARY EXPONENT
0B08E9 FE     1230* CP      161
0B08EA A1 
0B08EB 30     1231* JR      NC,STR14
0B08EC 1C 
0B08ED FE     1232* CP      155
0B08EE 9B 
0B08EF 30     1233* JR      NC,STR15
0B08F0 29 
0B08F1 2F     1234* CPL
0B08F2 FE     1235* CP      225
0B08F3 E1 
0B08F4 38     1236* JR      C,STR13
0B08F5 02 
0B08F6 3E     1237* LD      A,-8
0B08F7 F8 
0B08F8 C6     1238* STR13:			ADD     A,28
0B08F9 1C 
0B08FA CD     1239* CALL    POWR10
0B08FB 87 
0B08FC 0D 
0B08FD 0B 
0B08FE F5     1240* PUSH    AF
0B08FF CD     1241* CALL    FMUL
0B0900 76 
0B0901 03 
0B0902 0B 
0B0903 F1     1242* POP     AF
0B0904 47     1243* LD      B,A
0B0905 F1     1244* POP     AF
0B0906 90     1245* SUB     B
0B0907 18     1246* JR      STR11
0B0908 DE 
0B0909 D6     1247* STR14:			SUB     32
0B090A 20 
0B090B CD     1248* CALL    POWR10
0B090C 87 
0B090D 0D 
0B090E 0B 
0B090F F5     1249* PUSH    AF
0B0910 CD     1250* CALL    FDIV
0B0911 CD 
0B0912 02 
0B0913 0B 
0B0914 F1     1251* POP     AF
0B0915 47     1252* LD      B,A
0B0916 F1     1253* POP     AF
0B0917 80     1254* ADD     A,B
0B0918 18     1255* JR      STR11
0B0919 CD 
0B091A 3E     1256* STR15:			LD      A,9
0B091B 09 
0B091C CD     1257* CALL    POWR10          ;10^9
0B091D 87 
0B091E 0D 
0B091F 0B 
0B0920 CD     1258* CALL    FCP0
0B0921 9B 
0B0922 0C 
0B0923 0B 
0B0924 79     1259* LD      A,C
0B0925 C1     1260* POP     BC
0B0926 4F     1261* LD      C,A
0B0927 CB     1262* SET     7,H             ;IMPLIED 1
0B0928 FC 
0B0929 DC     1263* CALL    C,X10B          ;X10, DEC B
0B092A C3 
0B092B 0C 
0B092C 0B 
0B092D D1     1264* POP     DE              ;RESTORE TEXT POINTER
0B092E CB     1265* RES     7,C
0B092F B9 
0B0930 3E     1266* LD      A,0
0B0931 00 
0B0932 17     1267* RLA                     ;PUT CARRY IN LSB
              1268* ;
              1269* ;At this point decimal normalisation has been done,
              1270* ;now convert to decimal digits:
              1271* ;      AHLH'L' = number in normalised integer form
              1272* ;            B = decimal place adjustment
              1273* ;            C = binary place adjustment (29-33)
              1274* ;
0B0933 0C     1275* STR02:			INC     C
0B0934 08     1276* EX      AF,AF'          ;SAVE A
0B0935 78     1277* LD      A,B
0B0936 DD     1278* BIT     1,(IX+2)
0B0937 CB 
0B0938 02 
0B0939 4E 
0B093A 20     1279* JR      NZ,STR20
0B093B 08 
0B093C AF     1280* XOR     A
0B093D DD     1281* CP      (IX+1)
0B093E BE 
0B093F 01 
0B0940 28     1282* JR      Z,STR21
0B0941 0B 
0B0942 3E     1283* LD      A,-10
0B0943 F6 
0B0944 DD     1284* STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B0945 86 
0B0946 01 
0B0947 B7     1285* OR      A               ;CLEAR CARRY
0B0948 FA     1286* JP      M,STR21
0B0949 4D 
0B094A 09 
0B094B 0B 
0B094C AF     1287* XOR     A
0B094D F5     1288* STR21:			PUSH    AF
0B094E 08     1289* EX      AF,AF'          ;RESTORE A
0B094F CD     1290* STR22:			CALL    X2              ;RL AHLH'L'
0B0950 F7 
0B0951 0C 
0B0952 0B 
0B0953 8F     1291* ADC     A,A
0B0954 FE     1292* CP      10
0B0955 0A 
0B0956 38     1293* JR      C,STR23
0B0957 05 
0B0958 D6     1294* SUB     10
0B0959 0A 
0B095A D9     1295* EXX
0B095B 2C     1296* INC     L               ;SET RESULT BIT
0B095C D9     1297* EXX
0B095D 0D     1298* STR23:			DEC     C
0B095E 20     1299* JR      NZ,STR22        ;32 TIMES
0B095F EF 
0B0960 4F     1300* LD      C,A             ;REMAINDER
0B0961 7C     1301* LD      A,H
0B0962 E6     1302* AND     3FH             ;CLEAR OUT JUNK
0B0963 3F 
0B0964 67     1303* LD      H,A
0B0965 F1     1304* POP     AF
0B0966 F2     1305* JP      P,STR24
0B0967 74 
0B0968 09 
0B0969 0B 
0B096A 3C     1306* INC     A
0B096B 20     1307* JR      NZ,STR26
0B096C 1C 
0B096D 3E     1308* LD      A,4
0B096E 04 
0B096F B9     1309* CP      C               ;ROUND UP?
0B0970 3E     1310* LD      A,0
0B0971 00 
0B0972 18     1311* JR      STR26
0B0973 15 
0B0974 F5     1312* STR24:			PUSH    AF
0B0975 79     1313* LD      A,C
0B0976 CE     1314* ADC     A,'0'           ;ADD CARRY
0B0977 30 
0B0978 FE     1315* CP      '0'
0B0979 30 
0B097A 28     1316* JR      Z,STR25         ;SUPPRESS ZERO
0B097B 05 
0B097C FE     1317* CP      '9'+1
0B097D 3A 
0B097E 3F     1318* CCF
0B097F 30     1319* JR      NC,STR26
0B0980 08 
0B0981 E3     1320* STR25:			EX      (SP),HL
0B0982 CB     1321* BIT     6,L             ;ZERO FLAG
0B0983 75 
0B0984 E3     1322* EX      (SP),HL
0B0985 20     1323* JR      NZ,STR27
0B0986 05 
0B0987 3E     1324* LD      A,'0'
0B0988 30 
0B0989 3C     1325* STR26:			INC     A               ;SET +VE
0B098A 3D     1326* DEC     A
0B098B F5     1327* PUSH    AF              ;PUT ON STACK + CARRY
0B098C 04     1328* STR27:			INC     B
0B098D CD     1329* CALL    TEST_FP            ;IS HLH'L' ZERO?
0B098E 67 
0B098F 0C 
0B0990 0B 
0B0991 0E     1330* LD      C,32
0B0992 20 
0B0993 3E     1331* LD      A,0
0B0994 00 
0B0995 20     1332* JR      NZ,STR22
0B0996 B8 
0B0997 F1     1333* POP     AF
0B0998 F5     1334* PUSH    AF
0B0999 3E     1335* LD      A,0
0B099A 00 
0B099B 38     1336* JR      C,STR22
0B099C B2 
              1337* ;
              1338* ;At this point, the decimal character string is stored
              1339* ; on the stack. Trailing zeroes are suppressed and may
              1340* ; need to be replaced.
              1341* ;B register holds decimal point position.
              1342* ;Now format number and store as ASCII string:
              1343* ;
0B099D EB     1344* STR3:			EX      DE,HL           ;STRING POINTER
0B099E 0E     1345* LD      C,-1            ;FLAG "E"
0B099F FF 
0B09A0 16     1346* LD      D,1
0B09A1 01 
0B09A2 DD     1347* LD      E,(IX+1)        ;f2
0B09A3 5E 
0B09A4 01 
0B09A5 DD     1348* BIT     0,(IX+2)
0B09A6 CB 
0B09A7 02 
0B09A8 46 
0B09A9 20     1349* JR      NZ,STR34        ;E MODE
0B09AA 35 
0B09AB DD     1350* BIT     1,(IX+2)
0B09AC CB 
0B09AD 02 
0B09AE 4E 
0B09AF 28     1351* JR      Z,STR31
0B09B0 12 
0B09B1 78     1352* LD      A,B             ;F MODE
0B09B2 B7     1353* OR      A
0B09B3 28     1354* JR      Z,STR30
0B09B4 05 
0B09B5 FA     1355* JP      M,STR30
0B09B6 BA 
0B09B7 09 
0B09B8 0B 
0B09B9 50     1356* LD      D,B
0B09BA 7A     1357* STR30:			LD      A,D
0B09BB DD     1358* ADD     A,(IX+1)
0B09BC 86 
0B09BD 01 
0B09BE 5F     1359* LD      E,A
0B09BF FE     1360* CP      11
0B09C0 0B 
0B09C1 38     1361* JR      C,STR32
0B09C2 19 
0B09C3 78     1362* STR31:			LD      A,B             ;G MODE
0B09C4 11     1363* LD      DE,101H
0B09C5 01 
0B09C6 01 
0B09C7 00 
0B09C8 B7     1364* OR      A
0B09C9 FA     1365* JP      M,STR34
0B09CA E0 
0B09CB 09 
0B09CC 0B 
0B09CD 28     1366* JR      Z,STR32
0B09CE 0D 
0B09CF DD     1367* LD      A,(IX+1)
0B09D0 7E 
0B09D1 01 
0B09D2 B7     1368* OR      A
0B09D3 20     1369* JR      NZ,STR3A
0B09D4 02 
0B09D5 3E     1370* LD      A,10
0B09D6 0A 
0B09D7 B8     1371* STR3A:			CP      B
0B09D8 38     1372* JR      C,STR34
0B09D9 06 
0B09DA 50     1373* LD      D,B
0B09DB 58     1374* LD      E,B
0B09DC 78     1375* STR32:			LD      A,B
0B09DD C6     1376* ADD     A,129
0B09DE 81 
0B09DF 4F     1377* LD      C,A
0B09E0 CB     1378* STR34:			SET     7,D
0B09E1 FA 
0B09E2 1D     1379* DEC     E
0B09E3 7A     1380* STR35:			LD      A,D
0B09E4 B9     1381* CP      C
0B09E5 30     1382* JR      NC,STR33
0B09E6 0E 
0B09E7 F1     1383* STR36:			POP     AF
0B09E8 28     1384* JR      Z,STR37
0B09E9 04 
0B09EA F2     1385* JP      P,STR38
0B09EB F7 
0B09EC 09 
0B09ED 0B 
0B09EE F5     1386* STR37:			PUSH    AF
0B09EF 1C     1387* INC     E
0B09F0 1D     1388* DEC     E
0B09F1 FA     1389* JP      M,STR4
0B09F2 08 
0B09F3 0A 
0B09F4 0B 
0B09F5 3E     1390* STR33:			LD      A,'0'
0B09F6 30 
0B09F7 15     1391* STR38:			DEC     D
0B09F8 E2     1392* JP      PO,STR39
0B09F9 FF 
0B09FA 09 
0B09FB 0B 
0B09FC 36     1393* LD      (HL),'.'
0B09FD 2E 
0B09FE 23     1394* INC     HL
0B09FF 77     1395* STR39:			LD      (HL),A
0B0A00 23     1396* INC     HL
0B0A01 1D     1397* DEC     E
0B0A02 F2     1398* JP      P,STR35
0B0A03 E3 
0B0A04 09 
0B0A05 0B 
0B0A06 18     1399* JR      STR36
0B0A07 DF 
              1400* ;
0B0A08 F1     1401* STR4:			POP     AF
0B0A09 0C     1402* STR40:			INC     C
0B0A0A 4D     1403* LD      C,L
0B0A0B 20     1404* JR      NZ,STR44
0B0A0C 28 
0B0A0D 36     1405* LD      (HL),'E'        ;EXPONENT
0B0A0E 45 
0B0A0F 23     1406* INC     HL
0B0A10 78     1407* LD      A,B
0B0A11 3D     1408* DEC     A
0B0A12 F2     1409* JP      P,STR41
0B0A13 1B 
0B0A14 0A 
0B0A15 0B 
0B0A16 36     1410* LD      (HL),'-'
0B0A17 2D 
0B0A18 23     1411* INC     HL
0B0A19 ED     1412* NEG
0B0A1A 44 
0B0A1B 36     1413* STR41:			LD      (HL),'0'
0B0A1C 30 
0B0A1D 28     1414* JR      Z,STR47
0B0A1E 15 
0B0A1F FE     1415* CP      10
0B0A20 0A 
0B0A21 47     1416* LD      B,A
0B0A22 3E     1417* LD      A,':'
0B0A23 3A 
0B0A24 38     1418* JR      C,STR42
0B0A25 03 
0B0A26 23     1419* INC     HL
0B0A27 36     1420* LD      (HL),'0'
0B0A28 30 
0B0A29 34     1421* STR42:			INC     (HL)
0B0A2A BE     1422* CP      (HL)
0B0A2B 20     1423* JR      NZ,STR43
0B0A2C 05 
0B0A2D 36     1424* LD      (HL),'0'
0B0A2E 30 
0B0A2F 2B     1425* DEC     HL
0B0A30 34     1426* INC     (HL)
0B0A31 23     1427* INC     HL
0B0A32 10     1428* STR43:			DJNZ    STR42
0B0A33 F5 
0B0A34 23     1429* STR47:			INC     HL
0B0A35 EB     1430* STR44:			EX      DE,HL
0B0A36 C9     1431* RET
              1432* ;
              1433* ;Support subroutines:
              1434* ;
0B0A37 DD     1435* DLOAD5:			LD      B,(IX+4)
0B0A38 46 
0B0A39 04 
0B0A3A D9     1436* EXX
0B0A3B DD     1437* LD      E,(IX+0)
0B0A3C 5E 
0B0A3D 00 
0B0A3E DD     1438* LD      D,(IX+1)
0B0A3F 56 
0B0A40 01 
0B0A41 D9     1439* EXX
0B0A42 DD     1440* LD      E,(IX+2)
0B0A43 5E 
0B0A44 02 
0B0A45 DD     1441* LD      D,(IX+3)
0B0A46 56 
0B0A47 03 
0B0A48 C9     1442* RET
              1443* ;
0B0A49 DD     1444* DLOAD5_SPL:		LD      B,(IX+6)
0B0A4A 46 
0B0A4B 06 
0B0A4C D9     1445* EXX
0B0A4D DD     1446* LD	DE, (IX+0)
0B0A4E 17 
0B0A4F 00 
0B0A50 D9     1447* EXX
0B0A51 DD     1448* LD	DE, (IX+3)
0B0A52 17 
0B0A53 03 
0B0A54 C9     1449* RET
              1450* ;
              1451* ;CON_FP - Get unsigned numeric constant from ASCII string.
              1452* ;   Inputs: ASCII string at (IX).
              1453* ;  Outputs: Variable-type result in HLH'L'C
              1454* ;           IX updated (points to delimiter)
              1455* ;           A7 = 0 (numeric marker)
              1456* ;
0B0A55 CD     1457* CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B0A56 8B 
0B0A57 0C 
0B0A58 0B 
0B0A59 0E     1458* LD      C,0             ;TRUNCATION COUNTER
0B0A5A 00 
0B0A5B CD     1459* CALL    UINT          ;GET INTEGER PART
0B0A5C E9 
0B0A5D 0A 
0B0A5E 0B 
0B0A5F FE     1460* CP      '.'
0B0A60 2E 
0B0A61 06     1461* LD      B,0             ;DECL. PLACE COUNTER
0B0A62 00 
0B0A63 CC     1462* CALL    Z,NUMBIX        ;GET FRACTION PART
0B0A64 E7 
0B0A65 0A 
0B0A66 0B 
0B0A67 FE     1463* CP      'E'
0B0A68 45 
0B0A69 3E     1464* LD      A,0             ;INITIALISE EXPONENT
0B0A6A 00 
0B0A6B CC     1465* CALL    Z,GETEXP        ;GET EXPONENT
0B0A6C B5 
0B0A6D 0A 
0B0A6E 0B 
0B0A6F CB     1466* BIT     7,H
0B0A70 7C 
0B0A71 20     1467* JR      NZ,CON0         ;INTEGER OVERFLOW
0B0A72 08 
0B0A73 B7     1468* OR      A
0B0A74 20     1469* JR      NZ,CON0         ;EXPONENT NON-ZERO
0B0A75 05 
0B0A76 B8     1470* CP      B
0B0A77 20     1471* JR      NZ,CON0         ;DECIMAL POINT
0B0A78 02 
0B0A79 B9     1472* CP      C
0B0A7A C8     1473* RET     Z               ;INTEGER
0B0A7B 90     1474* CON0:			SUB     B
0B0A7C 81     1475* ADD     A,C
0B0A7D 0E     1476* LD      C,159
0B0A7E 9F 
0B0A7F CD     1477* CALL    FLOAT_
0B0A80 EE 
0B0A81 0B 
0B0A82 0B 
0B0A83 CB     1478* RES     7,H             ;DITCH IMPLIED 1
0B0A84 BC 
0B0A85 B7     1479* OR      A
0B0A86 C8     1480* RET     Z               ;DONE
0B0A87 FA     1481* JP      M,CON2          ;NEGATIVE EXPONENT
0B0A88 95 
0B0A89 0A 
0B0A8A 0B 
0B0A8B CD     1482* CALL    POWR10
0B0A8C 87 
0B0A8D 0D 
0B0A8E 0B 
0B0A8F CD     1483* CALL    FMUL            ;SCALE
0B0A90 76 
0B0A91 03 
0B0A92 0B 
0B0A93 AF     1484* XOR     A
0B0A94 C9     1485* RET
0B0A95 FE     1486* CON2:			CP      -38
0B0A96 DA 
0B0A97 38     1487* JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B0A98 0C 
0B0A99 ED     1488* NEG
0B0A9A 44 
0B0A9B CD     1489* CALL    POWR10
0B0A9C 87 
0B0A9D 0D 
0B0A9E 0B 
0B0A9F CD     1490* CALL    FDIV            ;SCALE
0B0AA0 CD 
0B0AA1 02 
0B0AA2 0B 
0B0AA3 AF     1491* XOR     A
0B0AA4 C9     1492* RET
0B0AA5 F5     1493* CON3:			PUSH    AF
0B0AA6 3E     1494* LD      A,38
0B0AA7 26 
0B0AA8 CD     1495* CALL    POWR10
0B0AA9 87 
0B0AAA 0D 
0B0AAB 0B 
0B0AAC CD     1496* CALL    FDIV
0B0AAD CD 
0B0AAE 02 
0B0AAF 0B 
0B0AB0 F1     1497* POP     AF
0B0AB1 C6     1498* ADD     A,38
0B0AB2 26 
0B0AB3 18     1499* JR      CON2
0B0AB4 E0 
              1500* ;
              1501* ;GETEXP - Get decimal exponent from string
              1502* ;     Inputs: ASCII string at (IX)
              1503* ;             (IX points at 'E')
              1504* ;             A = initial value
              1505* ;    Outputs: A = new exponent
              1506* ;             IX updated.
              1507* ;   Destroys: A,A',IX,F,F'
              1508* ;
0B0AB5 C5     1509* GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B0AB6 47     1510* LD      B,A             ;INITIAL VALUE
0B0AB7 0E     1511* LD      C,2             ;2 DIGITS MAX
0B0AB8 02 
0B0AB9 DD     1512* INC     IX              ;BUMP PAST 'E'
0B0ABA 23 
0B0ABB CD     1513* CALL    SIGNQ
0B0ABC A5 
0B0ABD 0E 
0B0ABE 0B 
0B0ABF 08     1514* EX      AF,AF'          ;SAVE EXPONENT SIGN
0B0AC0 CD     1515* GETEX1:			CALL    DIGITQ
0B0AC1 9B 
0B0AC2 0E 
0B0AC3 0B 
0B0AC4 38     1516* JR      C,GETEX2
0B0AC5 18 
0B0AC6 78     1517* LD      A,B             ;B=B*10
0B0AC7 87     1518* ADD     A,A
0B0AC8 87     1519* ADD     A,A
0B0AC9 80     1520* ADD     A,B
0B0ACA 87     1521* ADD     A,A
0B0ACB 47     1522* LD      B,A
0B0ACC DD     1523* LD      A,(IX)          ;GET BACK DIGIT
0B0ACD 7E 
0B0ACE 00 
0B0ACF DD     1524* INC     IX
0B0AD0 23 
0B0AD1 E6     1525* AND     0FH             ;MASK UNWANTED BITS
0B0AD2 0F 
0B0AD3 80     1526* ADD     A,B             ;ADD IN DIGIT
0B0AD4 47     1527* LD      B,A
0B0AD5 0D     1528* DEC     C
0B0AD6 F2     1529* JP      P,GETEX1
0B0AD7 C0 
0B0AD8 0A 
0B0AD9 0B 
0B0ADA 06     1530* LD      B,100           ;FORCE OVERFLOW
0B0ADB 64 
0B0ADC 18     1531* JR      GETEX1
0B0ADD E2 
0B0ADE 08     1532* GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B0ADF FE     1533* CP      '-'
0B0AE0 2D 
0B0AE1 78     1534* LD      A,B
0B0AE2 C1     1535* POP     BC              ;RESTORE
0B0AE3 C0     1536* RET     NZ
0B0AE4 ED     1537* NEG                     ;NEGATE EXPONENT
0B0AE5 44 
0B0AE6 C9     1538* RET
              1539* ;
              1540* ;UINT: Get unsigned integer from string.
              1541* ;    Inputs: string at (IX)
              1542* ;            C = truncated digit count
              1543* ;                (initially zero)
              1544* ;            B = total digit count
              1545* ;            HLH'L' = initial value
              1546* ;   Outputs: HLH'L' = number (binary integer)
              1547* ;            A = delimiter.
              1548* ;            B, C & IX updated
              1549* ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
              1550* ;
0B0AE7 DD     1551* NUMBIX:			INC     IX
0B0AE8 23 
0B0AE9 CD     1552* UINT:			CALL    DIGITQ
0B0AEA 9B 
0B0AEB 0E 
0B0AEC 0B 
0B0AED D8     1553* RET     C
0B0AEE 04     1554* INC     B               ;INCREMENT DIGIT COUNT
0B0AEF DD     1555* INC     IX
0B0AF0 23 
0B0AF1 CD     1556* CALL    X10             ;*10 & COPY OLD VALUE
0B0AF2 E4 
0B0AF3 0C 
0B0AF4 0B 
0B0AF5 38     1557* JR      C,NUMB1         ;OVERFLOW
0B0AF6 15 
0B0AF7 0D     1558* DEC     C               ;SEE IF TRUNCATED
0B0AF8 0C     1559* INC     C
0B0AF9 20     1560* JR      NZ,NUMB1        ;IMPORTANT!
0B0AFA 11 
0B0AFB E6     1561* AND     0FH
0B0AFC 0F 
0B0AFD D9     1562* EXX
0B0AFE 06     1563* LD      B,0
0B0AFF 00 
0B0B00 4F     1564* LD      C,A
0B0B01 52     1565* ADD.S   HL,BC           ;ADD IN DIGIT
0B0B02 09 
0B0B03 D9     1566* EXX
0B0B04 30     1567* JR      NC,UINT
0B0B05 E3 
0B0B06 52     1568* INC.S   HL              ;CARRY
0B0B07 23 
0B0B08 7C     1569* LD      A,H
0B0B09 B5     1570* OR      L
0B0B0A 20     1571* JR      NZ,UINT
0B0B0B DD 
0B0B0C 0C     1572* NUMB1:			INC     C               ;TRUNCATION COUNTER
0B0B0D CD     1573* CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B0B0E 42 
0B0B0F 0C 
0B0B10 0B 
0B0B11 18     1574* JR      UINT
0B0B12 D6 
              1575* ;
              1576* ;FIX - Fix number to specified exponent value.
              1577* ;    Inputs: HLH'L'C = +ve non-zero number (floated)
              1578* ;            A = desired exponent (A>C)
              1579* ;   Outputs: HLH'L'C = fixed number (unsigned)
              1580* ;            fraction shifted into B'C'
              1581* ;            A'F' positive if integer input
              1582* ;  Destroys: C,H,L,A',B',C',H',L',F,F'
              1583* ;
0B0B13 08     1584* FIX:			EX      AF,AF'
0B0B14 AF     1585* XOR     A
0B0B15 08     1586* EX      AF,AF'
0B0B16 CB     1587* SET     7,H             ;IMPLIED 1
0B0B17 FC 
0B0B18 CD     1588* FIX1:			CALL    DIV2
0B0B19 47 
0B0B1A 0C 
0B0B1B 0B 
0B0B1C B9     1589* CP      C
0B0B1D C8     1590* RET     Z
0B0B1E D2     1591* JP      NC,FIX1
0B0B1F 18 
0B0B20 0B 
0B0B21 0B 
0B0B22 C3     1592* JP      OFLOW
0B0B23 56 
0B0B24 0C 
0B0B25 0B 
              1593* ;
              1594* ;SFIX - Convert to integer if necessary.
              1595* ;    Input: Variable-type number in HLH'L'C
              1596* ;   Output: Integer in HLH'L', C=0
              1597* ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
              1598* ;
              1599* ;NEGATE - Negate HLH'L'
              1600* ;    Destroys: H,L,H',L',F
              1601* ;
0B0B26 CD     1602* FIX2:			CALL    SWAP_FP
0B0B27 3F 
0B0B28 0C 
0B0B29 0B 
0B0B2A CD     1603* CALL    SFIX_FP
0B0B2B 32 
0B0B2C 0B 
0B0B2D 0B 
0B0B2E CD     1604* CALL    SWAP_FP
0B0B2F 3F 
0B0B30 0C 
0B0B31 0B 
0B0B32 0D     1605* SFIX_FP:			DEC     C
0B0B33 0C     1606* INC     C
0B0B34 C8     1607* RET     Z               ;INTEGER/ZERO
0B0B35 CB     1608* BIT     7,H             ;SIGN
0B0B36 7C 
0B0B37 F5     1609* PUSH    AF
0B0B38 3E     1610* LD      A,159
0B0B39 9F 
0B0B3A CD     1611* CALL    FIX
0B0B3B 13 
0B0B3C 0B 
0B0B3D 0B 
0B0B3E F1     1612* POP     AF
0B0B3F 0E     1613* LD      C,0
0B0B40 00 
0B0B41 C8     1614* RET     Z
0B0B42 B7     1615* NEGATE:			OR      A               ;CLEAR CARRY
0B0B43 D9     1616* EXX
0B0B44 D5     1617* NEG0:			PUSH    DE
0B0B45 EB     1618* EX      DE,HL
0B0B46 21     1619* LD      HL,0
0B0B47 00 
0B0B48 00 
0B0B49 00 
0B0B4A 52     1620* SBC.S   HL,DE
0B0B4B ED 
0B0B4C 52 
0B0B4D D1     1621* POP     DE
0B0B4E D9     1622* EXX
0B0B4F D5     1623* PUSH    DE
0B0B50 EB     1624* EX      DE,HL
0B0B51 21     1625* LD      HL,0
0B0B52 00 
0B0B53 00 
0B0B54 00 
0B0B55 52     1626* SBC.S   HL,DE
0B0B56 ED 
0B0B57 52 
0B0B58 D1     1627* POP     DE
0B0B59 C9     1628* RET
              1629* ;
              1630* ;NEG - Negate HLH'L'B'C'
              1631* ;    Also complements A (used in FADD)
              1632* ;    Destroys: A,H,L,B',C',H',L',F
              1633* ;
0B0B5A D9     1634* NEG_:			EXX
0B0B5B 2F     1635* CPL
0B0B5C E5     1636* PUSH    HL
0B0B5D B7     1637* OR      A               ;CLEAR CARRY
0B0B5E 21     1638* LD      HL,0
0B0B5F 00 
0B0B60 00 
0B0B61 00 
0B0B62 52     1639* SBC.S   HL,BC
0B0B63 ED 
0B0B64 42 
0B0B65 44     1640* LD      B,H
0B0B66 4D     1641* LD      C,L
0B0B67 E1     1642* POP     HL
0B0B68 18     1643* JR      NEG0
0B0B69 DA 
              1644* ;
              1645* ;SCALE - Trig scaling.
              1646* ;MOD48 - 48-bit floating-point "modulus" (remainder).
              1647* ;   Inputs: HLH'L'C unsigned floating-point dividend
              1648* ;           DED'E'B'C'B unsigned 48-bit FP divisor
              1649* ;  Outputs: HLH'L'C floating point remainder (H7=1)
              1650* ;           E = quotient (bit 7 is sticky)
              1651* ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
              1652* ;FLO48 - Float unsigned number (48 bits)
              1653* ;    Input/output in HLH'L'B'C'C
              1654* ;   Destroys: C,H,L,B',C',H',L',F
              1655* ;
0B0B6A 3E     1656* SCALE:			LD      A,150
0B0B6B 96 
0B0B6C B9     1657* CP      C
0B0B6D 3E     1658* LD      A,ACLOST
0B0B6E 17 
0B0B6F DA     1659* JP      C,ERROR_FP_         ;"Accuracy lost"
0B0B70 E5 
0B0B71 00 
0B0B72 0B 
0B0B73 CD     1660* CALL    PIBY4
0B0B74 B0 
0B0B75 06 
0B0B76 0B 
0B0B77 D9     1661* EXX
0B0B78 01     1662* LD      BC,2169H        ;3.141592653589793238
0B0B79 69 
0B0B7A 21 
0B0B7B 00 
0B0B7C D9     1663* EXX
0B0B7D CB     1664* MOD48:			SET     7,D             ;IMPLIED 1
0B0B7E FA 
0B0B7F CB     1665* SET     7,H
0B0B80 FC 
0B0B81 79     1666* LD      A,C
0B0B82 0E     1667* LD      C,0             ;INIT QUOTIENT
0B0B83 00 
0B0B84 DD     1668* LD      IX,0
0B0B85 21 
0B0B86 00 
0B0B87 00 
0B0B87 00   
0B0B89 DD     1669* PUSH    IX              ;PUT ZERO ON STACK
0B0B8A E5 
0B0B8B B8     1670* CP      B
0B0B8C 38     1671* JR      C,MOD485        ;DIVIDEND<DIVISOR
0B0B8D 46 
0B0B8E D9     1672* MOD481:			EXX                     ;CARRY=0 HERE
0B0B8F E3     1673* EX      (SP),HL
0B0B90 52     1674* SBC.S   HL,BC
0B0B91 ED 
0B0B92 42 
0B0B93 E3     1675* EX      (SP),HL
0B0B94 52     1676* SBC.S   HL,DE
0B0B95 ED 
0B0B96 52 
0B0B97 D9     1677* EXX
0B0B98 52     1678* SBC.S   HL,DE
0B0B99 ED 
0B0B9A 52 
0B0B9B 30     1679* JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B0B9C 0C 
0B0B9D D9     1680* EXX
0B0B9E E3     1681* EX      (SP),HL
0B0B9F 52     1682* ADD.S   HL,BC
0B0BA0 09 
0B0BA1 E3     1683* EX      (SP),HL
0B0BA2 52     1684* ADC.S   HL,DE
0B0BA3 ED 
0B0BA4 5A 
0B0BA5 D9     1685* EXX
0B0BA6 52     1686* ADC.S   HL,DE
0B0BA7 ED 
0B0BA8 5A 
0B0BA9 3F     1687* MOD482:			CCF
0B0BAA CB     1688* RL      C               ;QUOTIENT
0B0BAB 11 
0B0BAC 30     1689* JR      NC,MOD483
0B0BAD 02 
0B0BAE CB     1690* SET     7,C             ;STICKY BIT
0B0BAF F9 
0B0BB0 3D     1691* MOD483:			DEC     A
0B0BB1 B8     1692* CP      B
0B0BB2 38     1693* JR      C,MOD484        ;DIVIDEND<DIVISOR
0B0BB3 1F 
0B0BB4 E3     1694* EX      (SP),HL
0B0BB5 52     1695* ADD.S   HL,HL           ;DIVIDEND * 2
0B0BB6 29 
0B0BB7 E3     1696* EX      (SP),HL
0B0BB8 D9     1697* EXX
0B0BB9 52     1698* ADC.S   HL,HL
0B0BBA ED 
0B0BBB 6A 
0B0BBC D9     1699* EXX
0B0BBD 52     1700* ADC.S   HL,HL
0B0BBE ED 
0B0BBF 6A 
0B0BC0 30     1701* JR      NC,MOD481       ;AGAIN
0B0BC1 CC 
0B0BC2 B7     1702* OR      A
0B0BC3 D9     1703* EXX
0B0BC4 E3     1704* EX      (SP),HL
0B0BC5 52     1705* SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B0BC6 ED 
0B0BC7 42 
0B0BC8 E3     1706* EX      (SP),HL
0B0BC9 52     1707* SBC.S   HL,DE
0B0BCA ED 
0B0BCB 52 
0B0BCC D9     1708* EXX
0B0BCD 52     1709* SBC.S   HL,DE
0B0BCE ED 
0B0BCF 52 
0B0BD0 B7     1710* OR      A
0B0BD1 18     1711* JR      MOD482
0B0BD2 D6 
              1712* ;
0B0BD3 3C     1713* MOD484:			INC     A
0B0BD4 59     1714* MOD485:			LD      E,C             ;QUOTIENT
0B0BD5 4F     1715* LD      C,A             ;REMAINDER EXPONENT
0B0BD6 D9     1716* EXX
0B0BD7 C1     1717* POP     BC
0B0BD8 D9     1718* EXX
0B0BD9 CB     1719* FLO48:			BIT     7,H
0B0BDA 7C 
0B0BDB C0     1720* RET     NZ
0B0BDC D9     1721* EXX
0B0BDD CB     1722* SLA     C
0B0BDE 21 
0B0BDF CB     1723* RL      B
0B0BE0 10 
0B0BE1 52     1724* ADC.S   HL,HL
0B0BE2 ED 
0B0BE3 6A 
0B0BE4 D9     1725* EXX
0B0BE5 52     1726* ADC.S   HL,HL
0B0BE6 ED 
0B0BE7 6A 
0B0BE8 0D     1727* DEC     C
0B0BE9 C2     1728* JP      NZ,FLO48
0B0BEA D9 
0B0BEB 0B 
0B0BEC 0B 
0B0BED C9     1729* RET
              1730* ;
              1731* ;Float unsigned number
              1732* ;    Input/output in HLH'L'C
              1733* ;   Destroys: C,H,L,H',L',F
              1734* ;
0B0BEE CB     1735* FLOAT_:			BIT     7,H
0B0BEF 7C 
0B0BF0 C0     1736* RET     NZ
0B0BF1 D9     1737* EXX                     ;SAME AS "X2"
0B0BF2 52     1738* ADD.S   HL,HL           ;TIME-CRITICAL
0B0BF3 29 
0B0BF4 D9     1739* EXX                     ;REGION
0B0BF5 52     1740* ADC.S   HL,HL           ;(BENCHMARKS)
0B0BF6 ED 
0B0BF7 6A 
0B0BF8 0D     1741* DEC     C
0B0BF9 C2     1742* JP      NZ,FLOAT_
0B0BFA EE 
0B0BFB 0B 
0B0BFC 0B 
0B0BFD C9     1743* RET
              1744* ;
              1745* ;SFLOAT - Convert to floating-point if necessary.
              1746* ;    Input: Variable-type number in HLH'L'C
              1747* ;    Output: Floating-point in HLH'L'C
              1748* ;    Destroys: A,C,H,L,H',L',F
              1749* ;
0B0BFE 08     1750* FLOATA:			EX      AF,AF'
              1751* ; ADD     A,(RTABLE-DTABLE)/3
0B0BFF C6     1752* ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B0C00 2A 
0B0C01 08     1753* EX      AF,AF'
0B0C02 CD     1754* FLOAT2:			CALL    SWAP_FP
0B0C03 3F 
0B0C04 0C 
0B0C05 0B 
0B0C06 CD     1755* CALL    SFLOAT_FP
0B0C07 0E 
0B0C08 0C 
0B0C09 0B 
0B0C0A CD     1756* CALL    SWAP_FP
0B0C0B 3F 
0B0C0C 0C 
0B0C0D 0B 
0B0C0E 0D     1757* SFLOAT_FP:			DEC     C
0B0C0F 0C     1758* INC     C
0B0C10 C0     1759* RET     NZ              ;ALREADY FLOATING-POINT
0B0C11 CD     1760* CALL    TEST_FP
0B0C12 67 
0B0C13 0C 
0B0C14 0B 
0B0C15 C8     1761* RET     Z               ;ZERO
0B0C16 7C     1762* LD      A,H
0B0C17 B7     1763* OR      A
0B0C18 FC     1764* CALL    M,NEGATE
0B0C19 42 
0B0C1A 0B 
0B0C1B 0B 
0B0C1C 0E     1765* LD      C,159
0B0C1D 9F 
0B0C1E CD     1766* CALL    FLOAT_
0B0C1F EE 
0B0C20 0B 
0B0C21 0B 
0B0C22 B7     1767* OR      A
0B0C23 F8     1768* RET     M               ;NEGATIVE
0B0C24 CB     1769* RES     7,H
0B0C25 BC 
0B0C26 C9     1770* RET
              1771* ;
              1772* ;ROUND UP
              1773* ;Return with carry set if 32-bit overflow
              1774* ;   Destroys: H,L,B',C',H',L',F
              1775* ;
0B0C27 D9     1776* ADD1_FP:			EXX
0B0C28 01     1777* LD      BC,1
0B0C29 01 
0B0C2A 00 
0B0C2B 00 
0B0C2C 52     1778* ADD.S   HL,BC
0B0C2D 09 
0B0C2E D9     1779* EXX
0B0C2F D0     1780* RET     NC
0B0C30 C5     1781* PUSH    BC
0B0C31 01     1782* LD      BC,1
0B0C32 01 
0B0C33 00 
0B0C34 00 
0B0C35 52     1783* ADD.S   HL,BC
0B0C36 09 
0B0C37 C1     1784* POP     BC
0B0C38 C9     1785* RET
              1786* ;
              1787* ;ODD - Add one if even, leave alone if odd.
              1788* ; (Used to perform unbiassed rounding, i.e.
              1789* ;  number is rounded up half the time)
              1790* ;    Destroys: L',F (carry cleared)
              1791* ;
0B0C39 B7     1792* ODD:			OR      A               ;CLEAR CARRY
0B0C3A D9     1793* EXX
0B0C3B CB     1794* SET     0,L             ;MAKE ODD
0B0C3C C5 
0B0C3D D9     1795* EXX
0B0C3E C9     1796* RET
              1797* ;
              1798* ;SWAP_FP - Swap arguments.
              1799* ;    Exchanges DE,HL D'E',H'L' and B,C
              1800* ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
              1801* ;SWAP1 - Swap DEHL with D'E'H'L'
              1802* ;    Destroys: D,E,H,L,D',E',H',L'
              1803* ;
0B0C3F 79     1804* SWAP_FP:			LD      A,C
0B0C40 48     1805* LD      C,B
0B0C41 47     1806* LD      B,A
0B0C42 EB     1807* SWAP1:			EX      DE,HL
0B0C43 D9     1808* EXX
0B0C44 EB     1809* EX      DE,HL
0B0C45 D9     1810* EXX
0B0C46 C9     1811* RET
              1812* ;
              1813* ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
              1814* ; INCC - destroys C,F
              1815* ; OFLOW
              1816* ;
0B0C47 CD     1817* DIV2:			CALL    D2
0B0C48 00 
0B0C49 0D 
0B0C4A 0B 
0B0C4B D9     1818* EXX
0B0C4C CB     1819* RR      B
0B0C4D 18 
0B0C4E CB     1820* RR      C
0B0C4F 19 
0B0C50 08     1821* EX      AF,AF'
0B0C51 B0     1822* OR      B
0B0C52 08     1823* EX      AF,AF'
0B0C53 D9     1824* EXX
0B0C54 0C     1825* INCC:			INC     C
0B0C55 C0     1826* RET     NZ
0B0C56 3E     1827* OFLOW:			LD      A,TOOBIG_FP
0B0C57 14 
0B0C58 C3     1828* JP      ERROR_FP_           ;"Too big"
0B0C59 E5 
0B0C5A 00 
0B0C5B 0B 
              1829* ;
              1830* ; FTEST - Test for zero & sign
              1831* ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
              1832* ;
0B0C5C CD     1833* FTEST_FP:			CALL    TEST_FP
0B0C5D 67 
0B0C5E 0C 
0B0C5F 0B 
0B0C60 C8     1834* RET     Z
0B0C61 7C     1835* LD      A,H
0B0C62 E6     1836* AND     10000000B
0B0C63 80 
0B0C64 F6     1837* OR      01000000B
0B0C65 40 
0B0C66 C9     1838* RET
              1839* ;
              1840* ; TEST_FP - Test HLH'L' for zero.
              1841* ;     Output: Z-flag set & A=0 if HLH'L'=0
              1842* ;     Destroys: A,F
              1843* ;
0B0C67 7C     1844* TEST_FP:			LD      A,H
0B0C68 B5     1845* OR      L
0B0C69 D9     1846* EXX
0B0C6A B4     1847* OR      H
0B0C6B B5     1848* OR      L
0B0C6C D9     1849* EXX
0B0C6D C9     1850* RET
              1851* ;
              1852* ; FCOMP - Compare two numbers
              1853* ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
              1854* ;
0B0C6E 78     1855* FCOMP_FP:			LD      A,B
0B0C6F B1     1856* OR      C               ;Both integer?
0B0C70 20     1857* JR      NZ,FCOMP1
0B0C71 0B 
0B0C72 CD     1858* CALL    ICP
0B0C73 87 
0B0C74 0C 
0B0C75 0B 
0B0C76 3E     1859* FCOMP0:			LD      A,0
0B0C77 00 
0B0C78 C8     1860* RET     Z               ;Equal
0B0C79 3E     1861* LD      A,80H
0B0C7A 80 
0B0C7B 1F     1862* RRA
0B0C7C C9     1863* RET
              1864* ;
0B0C7D CD     1865* FCOMP1:			CALL    FLOAT2          ;Float both
0B0C7E 02 
0B0C7F 0C 
0B0C80 0B 
0B0C81 CD     1866* CALL    FCP
0B0C82 95 
0B0C83 0C 
0B0C84 0B 
0B0C85 18     1867* JR      FCOMP0
0B0C86 EF 
              1868* ;
              1869* ; Integer and floating point compare.
              1870* ; Sets carry & zero flags according to HLH'L'C-DED'E'B
              1871* ; Result pre-set to FALSE
              1872* ; ICP1, FCP1 destroy A,F
              1873* ;
              1874* ; ZERO - Return zero.
              1875* ;  Destroys: A,C,H,L,H',L'
              1876* ;
0B0C87 CD     1877* ICP:			CALL    ICP1
0B0C88 BA 
0B0C89 0C 
0B0C8A 0B 
0B0C8B 3E     1878* ZERO_FP:			LD      A,0
0B0C8C 00 
0B0C8D D9     1879* EXX
0B0C8E 67     1880* LD      H,A
0B0C8F 6F     1881* LD      L,A
0B0C90 D9     1882* EXX
0B0C91 67     1883* LD      H,A
0B0C92 6F     1884* LD      L,A
0B0C93 4F     1885* LD      C,A
0B0C94 C9     1886* RET
              1887* ;
0B0C95 CD     1888* FCP:			CALL    FCP1
0B0C96 AC 
0B0C97 0C 
0B0C98 0B 
0B0C99 18     1889* JR      ZERO_FP            ;PRESET FALSE
0B0C9A F0 
              1890* ;
0B0C9B 79     1891* FCP0:			LD      A,C
0B0C9C B8     1892* CP      B               ;COMPARE EXPONENTS
0B0C9D C0     1893* RET     NZ
              1894* ICP0:
0B0C9E 52     1895* SBC.S   HL,DE           ;COMP MANTISSA MSB
0B0C9F ED 
0B0CA0 52 
0B0CA1 52     1896* ADD.S   HL,DE
0B0CA2 19 
0B0CA3 C0     1897* RET     NZ
0B0CA4 D9     1898* EXX
0B0CA5 52     1899* SBC.S   HL,DE           ;COMP MANTISSA LSB
0B0CA6 ED 
0B0CA7 52 
0B0CA8 52     1900* ADD.S   HL,DE
0B0CA9 19 
0B0CAA D9     1901* EXX
0B0CAB C9     1902* RET
              1903* ;
0B0CAC 7C     1904* FCP1:			LD      A,H
0B0CAD AA     1905* XOR     D
0B0CAE 7C     1906* LD      A,H
0B0CAF 17     1907* RLA
0B0CB0 F8     1908* RET     M
0B0CB1 30     1909* JR      NC,FCP0
0B0CB2 E8 
0B0CB3 CD     1910* CALL    FCP0
0B0CB4 9B 
0B0CB5 0C 
0B0CB6 0B 
0B0CB7 C8     1911* RET     Z               ;** V0.1 BUG FIX
0B0CB8 3F     1912* CCF
0B0CB9 C9     1913* RET
              1914* ;
0B0CBA 7C     1915* ICP1:			LD      A,H
0B0CBB AA     1916* XOR     D
0B0CBC F2     1917* JP      P,ICP0
0B0CBD 9E 
0B0CBE 0C 
0B0CBF 0B 
0B0CC0 7C     1918* LD      A,H
0B0CC1 17     1919* RLA
0B0CC2 C9     1920* RET
              1921* ;
              1922* ; ADD - Integer add.
              1923* ; Carry, sign & zero flags valid on exit
              1924* ;     Destroys: H,L,H',L',F
              1925* ;
0B0CC3 05     1926* X10B:			DEC     B
0B0CC4 0C     1927* INC     C
0B0CC5 CD     1928* X5:			CALL    COPY0
0B0CC6 0C 
0B0CC7 0D 
0B0CC8 0B 
0B0CC9 CD     1929* CALL    D2C
0B0CCA FF 
0B0CCB 0C 
0B0CCC 0B 
0B0CCD CD     1930* CALL    D2C
0B0CCE FF 
0B0CCF 0C 
0B0CD0 0B 
0B0CD1 08     1931* EX      AF,AF'          ;SAVE CARRY
0B0CD2 D9     1932* ADD_:			EXX
0B0CD3 52     1933* ADD.S   HL,DE
0B0CD4 19 
0B0CD5 D9     1934* EXX
0B0CD6 52     1935* ADC.S   HL,DE
0B0CD7 ED 
0B0CD8 5A 
0B0CD9 C9     1936* RET
              1937* ;
              1938* ; SUB - Integer subtract.
              1939* ; Carry, sign & zero flags valid on exit
              1940* ;     Destroys: H,L,H',L',F
              1941* ;
0B0CDA D9     1942* SUB_:			EXX
0B0CDB B7     1943* OR      A
0B0CDC 52     1944* SBC.S   HL,DE
0B0CDD ED 
0B0CDE 52 
0B0CDF D9     1945* EXX
0B0CE0 52     1946* SBC.S   HL,DE
0B0CE1 ED 
0B0CE2 52 
0B0CE3 C9     1947* RET
              1948* ;
              1949* ; X10 - unsigned integer * 10
              1950* ;    Inputs: HLH'L' initial value
              1951* ;   Outputs: DED'E' = initial HLH'L'
              1952* ;            Carry bit set if overflow
              1953* ;            If carry not set HLH'L'=result
              1954* ;  Destroys: D,E,H,L,D',E',H',L',F
              1955* ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
              1956* ;     Carry set if MSB=1 before shift.
              1957* ;     Sign set if MSB=1 after shift.
              1958* ;     Destroys: H,L,H',L',F
              1959* ;
0B0CE4 CD     1960* X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B0CE5 0C 
0B0CE6 0D 
0B0CE7 0B 
0B0CE8 CD     1961* CALL    X2
0B0CE9 F7 
0B0CEA 0C 
0B0CEB 0B 
0B0CEC D8     1962* RET     C               ;TOO BIG
0B0CED CD     1963* CALL    X2
0B0CEE F7 
0B0CEF 0C 
0B0CF0 0B 
0B0CF1 D8     1964* RET     C
0B0CF2 CD     1965* CALL    ADD_
0B0CF3 D2 
0B0CF4 0C 
0B0CF5 0B 
0B0CF6 D8     1966* RET     C
0B0CF7 D9     1967* X2:			EXX
0B0CF8 52     1968* ADD.S   HL,HL
0B0CF9 29 
0B0CFA D9     1969* EXX
0B0CFB 52     1970* ADC.S   HL,HL
0B0CFC ED 
0B0CFD 6A 
0B0CFE C9     1971* RET
              1972* ;
              1973* ; D2 - Divide HLH'L' by 2 as 32-bit integer.
              1974* ;     Carry set if LSB=1 before shift.
              1975* ;     Destroys: H,L,H',L',F
              1976* ;
0B0CFF 0C     1977* D2C:			INC     C
0B0D00 CB     1978* D2:			SRL     H
0B0D01 3C 
0B0D02 CB     1979* RR      L
0B0D03 1D 
0B0D04 D9     1980* EXX
0B0D05 CB     1981* RR      H
0B0D06 1C 
0B0D07 CB     1982* RR      L
0B0D08 1D 
0B0D09 D9     1983* EXX
0B0D0A C9     1984* RET
              1985* ;
              1986* ; COPY - COPY HLH'L'C INTO DED'E'B
              1987* ;   Destroys: B,C,D,E,H,L,D',E',H',L'
              1988* ;
0B0D0B 41     1989* COPY_:			LD      B,C
0B0D0C 54     1990* COPY0:			LD      D,H
0B0D0D 5D     1991* LD      E,L
0B0D0E D9     1992* EXX
0B0D0F 54     1993* LD      D,H
0B0D10 5D     1994* LD      E,L
0B0D11 D9     1995* EXX
0B0D12 C9     1996* RET
              1997* ;
              1998* ; SQUARE - PUSH X*X
              1999* ; PUSH5 - PUSH HLH'L'C ONTO STACK.
              2000* ;   Destroys: SP,IX
              2001* ;
0B0D13 CD     2002* SQUARE:			CALL    COPY_
0B0D14 0B 
0B0D15 0D 
0B0D16 0B 
0B0D17 CD     2003* CALL    FMUL
0B0D18 76 
0B0D19 03 
0B0D1A 0B 
0B0D1B DD     2004* PUSH5:			POP     IX              ;RETURN ADDRESS
0B0D1C E1 
0B0D1D C5     2005* PUSH    BC
0B0D1E E5     2006* PUSH    HL
0B0D1F D9     2007* EXX
0B0D20 E5     2008* PUSH    HL
0B0D21 D9     2009* EXX
0B0D22 DD     2010* JP      (IX)            ;"RETURN"
0B0D23 E9 
              2011* ;
              2012* ; POP5 - POP DED'E'B OFF STACK.
              2013* ;   Destroys: A,B,D,E,D',E',SP,IX
              2014* ;
0B0D24 DD     2015* POP5:			POP     IX              ;RETURN ADDRESS
0B0D25 E1 
0B0D26 D9     2016* EXX
0B0D27 D1     2017* POP     DE
0B0D28 D9     2018* EXX
0B0D29 D1     2019* POP     DE
0B0D2A 79     2020* LD      A,C
0B0D2B C1     2021* POP     BC
0B0D2C 41     2022* LD      B,C
0B0D2D 4F     2023* LD      C,A
0B0D2E DD     2024* JP      (IX)            ;"RETURN"
0B0D2F E9 
              2025* ;
              2026* ; RATIO - Calculate (X-1)/(X+1)
              2027* ;     Inputs: X in HLH'L'C
              2028* ;    Outputs: (X-1)/(X+1) in HLH'L'C
              2029* ;   Destroys: Everything except IY,SP,I
              2030* ;
0B0D30 CD     2031* RATIO:			CALL    PUSH5           ;SAVE X
0B0D31 1B 
0B0D32 0D 
0B0D33 0B 
0B0D34 CD     2032* CALL    DONE
0B0D35 A3 
0B0D36 06 
0B0D37 0B 
0B0D38 CD     2033* CALL    FADD
0B0D39 64 
0B0D3A 02 
0B0D3B 0B 
0B0D3C CD     2034* CALL    POP5            ;RESTORE X
0B0D3D 24 
0B0D3E 0D 
0B0D3F 0B 
0B0D40 CD     2035* CALL    PUSH5           ;SAVE X+1
0B0D41 1B 
0B0D42 0D 
0B0D43 0B 
0B0D44 CD     2036* CALL    SWAP_FP
0B0D45 3F 
0B0D46 0C 
0B0D47 0B 
0B0D48 CD     2037* CALL    DONE
0B0D49 A3 
0B0D4A 06 
0B0D4B 0B 
0B0D4C CD     2038* CALL    FSUB
0B0D4D 4B 
0B0D4E 02 
0B0D4F 0B 
0B0D50 CD     2039* CALL    POP5            ;RESTORE X+1
0B0D51 24 
0B0D52 0D 
0B0D53 0B 
0B0D54 C3     2040* JP      FDIV
0B0D55 CD 
0B0D56 02 
0B0D57 0B 
              2041* ;
              2042* ; POLY - Evaluate a polynomial.
              2043* ;     Inputs: X in HLH'L'C and also stored at (SP+2)
              2044* ;             Polynomial coefficients follow call.
              2045* ;    Outputs: Result in HLH'L'C
              2046* ;   Destroys: Everything except IY,SP,I
              2047* ; Routine terminates on finding a coefficient >=1.
              2048* ; Note: The last coefficient is EXECUTED on return
              2049* ;       so must contain only innocuous bytes!
              2050* ;
0B0D58 DD     2051* POLY:			LD      IX, 3				; Advance the SP to the return address
0B0D59 21 
0B0D5A 03 
0B0D5B 00 
0B0D5B 00   
0B0D5D DD     2052* ADD     IX, SP
0B0D5E 39 
0B0D5F DD     2053* EX      (SP), IX			; IX: Points to the inline list of coefficients
0B0D60 E3 
              2054* ;
0B0D61 CD     2055* CALL    DLOAD5          		; Load the first coefficient from (IX)
0B0D62 37 
0B0D63 0A 
0B0D64 0B 
0B0D65 CD     2056* POLY1:			CALL    FMUL
0B0D66 76 
0B0D67 03 
0B0D68 0B 
0B0D69 11     2057* LD      DE, 5				; Skip to the next coefficient
0B0D6A 05 
0B0D6B 00 
0B0D6C 00 
0B0D6D DD     2058* ADD     IX, DE
0B0D6E 19 
0B0D6F CD     2059* CALL    DLOAD5          		; Load the second coefficient from (IX)
0B0D70 37 
0B0D71 0A 
0B0D72 0B 
0B0D73 DD     2060* EX      (SP), IX			; Restore the SP just in case we need to return
0B0D74 E3 
0B0D75 04     2061* INC     B
0B0D76 05     2062* DEC     B               		; Test B for end byte (80h)
0B0D77 FA     2063* JP      M,FADD				; Yes, so add and return
0B0D78 64 
0B0D79 02 
0B0D7A 0B 
0B0D7B CD     2064* CALL    FADD				; No, so add
0B0D7C 64 
0B0D7D 02 
0B0D7E 0B 
0B0D7F CD     2065* CALL    DLOAD5_SPL			; Load X from SP
0B0D80 49 
0B0D81 0A 
0B0D82 0B 
0B0D83 DD     2066* EX      (SP), IX			; IX: Points to the inline list of coefficients
0B0D84 E3 
0B0D85 18     2067* JR      POLY1				; And loop
0B0D86 DE 
              2068* ;
              2069* ; POWR10 - Calculate power of ten.
              2070* ;     Inputs: A=power of 10 required (A<128)
              2071* ;             A=binary exponent to be exceeded (A>=128)
              2072* ;    Outputs: DED'E'B = result
              2073* ;             A = actual power of ten returned
              2074* ;   Destroys: A,B,D,E,A',D',E',F,F'
              2075* ;
0B0D87 3C     2076* POWR10:			INC     A
0B0D88 08     2077* EX      AF,AF'
0B0D89 E5     2078* PUSH    HL
0B0D8A D9     2079* EXX
0B0D8B E5     2080* PUSH    HL
0B0D8C D9     2081* EXX
0B0D8D CD     2082* CALL    DONE
0B0D8E A3 
0B0D8F 06 
0B0D90 0B 
0B0D91 CD     2083* CALL    SWAP_FP
0B0D92 3F 
0B0D93 0C 
0B0D94 0B 
0B0D95 AF     2084* XOR     A
0B0D96 08     2085* POWR11:			EX      AF,AF'
0B0D97 3D     2086* DEC     A
0B0D98 28     2087* JR      Z,POWR14        ;EXIT TYPE 1
0B0D99 26 
0B0D9A F2     2088* JP      P,POWR13
0B0D9B A2 
0B0D9C 0D 
0B0D9D 0B 
0B0D9E B9     2089* CP      C
0B0D9F 38     2090* JR      C,POWR14        ;EXIT TYPE 2
0B0DA0 1F 
0B0DA1 3C     2091* INC     A
0B0DA2 08     2092* POWR13:			EX      AF,AF'
0B0DA3 3C     2093* INC     A
0B0DA4 CB     2094* SET     7,H
0B0DA5 FC 
0B0DA6 CD     2095* CALL    X5
0B0DA7 C5 
0B0DA8 0C 
0B0DA9 0B 
0B0DAA 30     2096* JR      NC,POWR12
0B0DAB 06 
0B0DAC 08     2097* EX      AF,AF'
0B0DAD CD     2098* CALL    D2C
0B0DAE FF 
0B0DAF 0C 
0B0DB0 0B 
0B0DB1 08     2099* EX      AF,AF'
0B0DB2 08     2100* POWR12:			EX      AF,AF'
0B0DB3 DC     2101* CALL    C,ADD1_FP          ;ROUND UP
0B0DB4 27 
0B0DB5 0C 
0B0DB6 0B 
0B0DB7 0C     2102* INC     C
0B0DB8 FA     2103* JP      M,POWR11
0B0DB9 96 
0B0DBA 0D 
0B0DBB 0B 
0B0DBC C3     2104* JP      OFLOW
0B0DBD 56 
0B0DBE 0C 
0B0DBF 0B 
0B0DC0 CD     2105* POWR14:			CALL    SWAP_FP
0B0DC1 3F 
0B0DC2 0C 
0B0DC3 0B 
0B0DC4 CB     2106* RES     7,D
0B0DC5 BA 
0B0DC6 D9     2107* EXX
0B0DC7 E1     2108* POP     HL
0B0DC8 D9     2109* EXX
0B0DC9 E1     2110* POP     HL
0B0DCA 08     2111* EX      AF,AF'
0B0DCB C9     2112* RET
              2113* ;
              2114* ; DIVA, DIVB - DIVISION PRIMITIVE.
              2115* ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
              2116* ;               Remainder in H'L'HL
              2117* ;     Inputs: A = loop counter (normally -32)
              2118* ;     Destroys: A,D,E,H,L,D',E',H',L',F
              2119* ;
0B0DCC B7     2120* DIVA:			OR      A               ;CLEAR CARRY
              2121* DIV0:
0B0DCD 52     2122* SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B0DCE ED 
0B0DCF 42 
0B0DD0 D9     2123* EXX
0B0DD1 52     2124* SBC.S   HL,BC
0B0DD2 ED 
0B0DD3 42 
0B0DD4 D9     2125* EXX
0B0DD5 30     2126* JR      NC,DIV1
0B0DD6 07 
0B0DD7 52     2127* ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B0DD8 09 
0B0DD9 D9     2128* EXX
0B0DDA 52     2129* ADC.S   HL,BC
0B0DDB ED 
0B0DDC 4A 
0B0DDD D9     2130* EXX
0B0DDE 3F     2131* DIV1:			CCF
0B0DDF CB     2132* DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B0DE0 13 
0B0DE1 CB     2133* RL      D
0B0DE2 12 
0B0DE3 D9     2134* EXX
0B0DE4 CB     2135* RL      E
0B0DE5 13 
0B0DE6 CB     2136* RL      D
0B0DE7 12 
0B0DE8 D9     2137* EXX
0B0DE9 3C     2138* INC     A
0B0DEA F0     2139* RET     P
              2140* DIVB:
0B0DEB 52     2141* ADC.S   HL,HL           ;DIVIDEND*2
0B0DEC ED 
0B0DED 6A 
0B0DEE D9     2142* EXX
0B0DEF 52     2143* ADC.S   HL,HL
0B0DF0 ED 
0B0DF1 6A 
0B0DF2 D9     2144* EXX
0B0DF3 30     2145* JR      NC,DIV0
0B0DF4 D8 
0B0DF5 B7     2146* OR      A
0B0DF6 52     2147* SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B0DF7 ED 
0B0DF8 42 
0B0DF9 D9     2148* EXX
0B0DFA 52     2149* SBC.S   HL,BC
0B0DFB ED 
0B0DFC 42 
0B0DFD D9     2150* EXX
0B0DFE 37     2151* SCF
0B0DFF C3     2152* JP      DIVC
0B0E00 DF 
0B0E01 0D 
0B0E02 0B 
              2153* ;
              2154* ;MULA, MULB - MULTIPLICATION PRIMITIVE.
              2155* ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
              2156* ;    Inputs: A = loop counter (usually -32)
              2157* ;            H'L'HL = 0
              2158* ;    Destroys: D,E,H,L,D',E',H',L',A,F
              2159* ;
0B0E03 B7     2160* MULA:			OR      A               ;CLEAR CARRY
0B0E04 D9     2161* MUL0:			EXX
0B0E05 CB     2162* RR      D               ;MULTIPLIER/2
0B0E06 1A 
0B0E07 CB     2163* RR      E
0B0E08 1B 
0B0E09 D9     2164* EXX
0B0E0A CB     2165* RR      D
0B0E0B 1A 
0B0E0C CB     2166* RR      E
0B0E0D 1B 
0B0E0E 30     2167* JR      NC,MUL1
0B0E0F 07 
0B0E10 52     2168* ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B0E11 09 
0B0E12 D9     2169* EXX
0B0E13 52     2170* ADC.S   HL,BC
0B0E14 ED 
0B0E15 4A 
0B0E16 D9     2171* EXX
0B0E17 3C     2172* MUL1:			INC     A
0B0E18 F0     2173* RET     P
0B0E19 D9     2174* MULB:			EXX
0B0E1A CB     2175* RR      H               ;PRODUCT/2
0B0E1B 1C 
0B0E1C CB     2176* RR      L
0B0E1D 1D 
0B0E1E D9     2177* EXX
0B0E1F CB     2178* RR      H
0B0E20 1C 
0B0E21 CB     2179* RR      L
0B0E22 1D 
0B0E23 C3     2180* JP      MUL0
0B0E24 04 
0B0E25 0E 
0B0E26 0B 
              2181* ;
              2182* ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
              2183* ;     Function: B'C'BC = SQR (D'E'DE)
              2184* ;     Inputs: A = loop counter (normally -31)
              2185* ;             B'C'BCH'L'HL initialised to 0
              2186* ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
              2187* ;
              2188* SQR1:
0B0E27 52     2189* SBC.S   HL,BC
0B0E28 ED 
0B0E29 42 
0B0E2A D9     2190* EXX
0B0E2B 52     2191* SBC.S   HL,BC
0B0E2C ED 
0B0E2D 42 
0B0E2E D9     2192* EXX
0B0E2F 0C     2193* INC     C
0B0E30 30     2194* JR      NC,SQR2
0B0E31 09 
0B0E32 0D     2195* DEC     C
0B0E33 52     2196* ADD.S   HL,BC
0B0E34 09 
0B0E35 D9     2197* EXX
0B0E36 52     2198* ADC.S   HL,BC
0B0E37 ED 
0B0E38 4A 
0B0E39 D9     2199* EXX
0B0E3A 0D     2200* DEC     C
0B0E3B 3C     2201* SQR2:			INC     A
0B0E3C F0     2202* RET     P
0B0E3D CB     2203* SQRA:			SLA     C
0B0E3E 21 
0B0E3F CB     2204* RL      B
0B0E40 10 
0B0E41 D9     2205* EXX
0B0E42 CB     2206* RL      C
0B0E43 11 
0B0E44 CB     2207* RL      B
0B0E45 10 
0B0E46 D9     2208* EXX
0B0E47 0C     2209* INC     C
0B0E48 CB     2210* SLA     E
0B0E49 23 
0B0E4A CB     2211* RL      D
0B0E4B 12 
0B0E4C D9     2212* EXX
0B0E4D CB     2213* RL      E
0B0E4E 13 
0B0E4F CB     2214* RL      D
0B0E50 12 
0B0E51 D9     2215* EXX
0B0E52 52     2216* ADC.S   HL,HL
0B0E53 ED 
0B0E54 6A 
0B0E55 D9     2217* EXX
0B0E56 52     2218* ADC.S   HL,HL
0B0E57 ED 
0B0E58 6A 
0B0E59 D9     2219* EXX
0B0E5A CB     2220* SLA     E
0B0E5B 23 
0B0E5C CB     2221* RL      D
0B0E5D 12 
0B0E5E D9     2222* EXX
0B0E5F CB     2223* RL      E
0B0E60 13 
0B0E61 CB     2224* RL      D
0B0E62 12 
0B0E63 D9     2225* EXX
0B0E64 52     2226* ADC.S   HL,HL
0B0E65 ED 
0B0E66 6A 
0B0E67 D9     2227* EXX
0B0E68 52     2228* ADC.S   HL,HL
0B0E69 ED 
0B0E6A 6A 
0B0E6B D9     2229* EXX
0B0E6C D2     2230* JP      NC,SQR1
0B0E6D 27 
0B0E6E 0E 
0B0E6F 0B 
0B0E70 B7     2231* SQR3:			OR      A
0B0E71 52     2232* SBC.S   HL,BC
0B0E72 ED 
0B0E73 42 
0B0E74 D9     2233* EXX
0B0E75 52     2234* SBC.S   HL,BC
0B0E76 ED 
0B0E77 42 
0B0E78 D9     2235* EXX
0B0E79 0C     2236* INC     C
0B0E7A C3     2237* JP      SQR2
0B0E7B 3B 
0B0E7C 0E 
0B0E7D 0B 
              2238* ;
              2239* SQRB:
0B0E7E 52     2240* ADD.S   HL,HL
0B0E7F 29 
0B0E80 D9     2241* EXX
0B0E81 52     2242* ADC.S   HL,HL
0B0E82 ED 
0B0E83 6A 
0B0E84 D9     2243* EXX
0B0E85 38     2244* JR      C,SQR3
0B0E86 E9 
0B0E87 3C     2245* INC     A
0B0E88 0C     2246* INC     C
0B0E89 52     2247* SBC.S   HL,BC
0B0E8A ED 
0B0E8B 42 
0B0E8C D9     2248* EXX
0B0E8D 52     2249* SBC.S   HL,BC
0B0E8E ED 
0B0E8F 42 
0B0E90 D9     2250* EXX
0B0E91 D0     2251* RET     NC
0B0E92 52     2252* ADD.S   HL,BC
0B0E93 09 
0B0E94 D9     2253* EXX
0B0E95 52     2254* ADC.S   HL,BC
0B0E96 ED 
0B0E97 4A 
0B0E98 D9     2255* EXX
0B0E99 0D     2256* DEC     C
0B0E9A C9     2257* RET
              2258* ;
0B0E9B DD     2259* DIGITQ:			LD      A,(IX)
0B0E9C 7E 
0B0E9D 00 
0B0E9E FE     2260* CP      '9'+1
0B0E9F 3A 
0B0EA0 3F     2261* CCF
0B0EA1 D8     2262* RET     C
0B0EA2 FE     2263* CP      '0'
0B0EA3 30 
0B0EA4 C9     2264* RET
              2265* ;
0B0EA5 DD     2266* SIGNQ:			LD      A,(IX)
0B0EA6 7E 
0B0EA7 00 
0B0EA8 DD     2267* INC     IX
0B0EA9 23 
0B0EAA FE     2268* CP      ' '
0B0EAB 20 
0B0EAC 28     2269* JR      Z,SIGNQ
0B0EAD F7 
0B0EAE FE     2270* CP      '+'
0B0EAF 2B 
0B0EB0 C8     2271* RET     Z
0B0EB1 FE     2272* CP      '-'
0B0EB2 2D 
0B0EB3 C8     2273* RET     Z
0B0EB4 DD     2274* DEC     IX
0B0EB5 2B 
0B0EB6 C9     2275* RET
               0169 include "functions.inc"
              0001* MACRO LOAD_FLOAT ARG
              0002* ld ix,$+11
              0003* call VAL_FP
              0004* jp (ix)
              0005* asciz ARG
              0006* ENDMACRO
              0007* 
              0008* MACRO printChar char
              0009* LD A, char
              0010* RST.LIL 10h
              0011* ENDMACRO
              0012* 
              0013* ; test the sign of HL
              0014* ; inputs: HL obviously
              0015* ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
              0016* ; destroys: flags
              0017* MACRO sign_hlu
              0018* add hl,de
              0019* or a
              0020* sbc hl,de
              0021* ENDMACRO
              0022* 
              0023* ; Simulated call to subroutine at HL
              0024* ; inputs: HL pointing to the subroutine address plus whatever the called function expects
              0025* ; outputs: whatever the subroutine does, including HL and BC
              0026* ; destroys: only what the subroutine does, but always BC
              0027* MACRO callHL
              0028* ld bc,$+7     ; Address of first instruction after the jump
              0029* push bc       ; which constitutes the return address
              0030* jp   (hl)     ; Jump to the address in HL
              0031* ENDMACRO
              0032* 
              0033* ; Simulated call to subroutine at IX
              0034* ; inputs: IX pointing to the subroutine address plus whatever the called function expects
              0035* ; outputs: whatever the subroutine does, including IX and BC
              0036* ; destroys: only what the subroutine does, but always BC
              0037* MACRO callIX
              0038* ld bc,$+7     ; Address of first instruction after the jump
              0039* push bc       ; which constitutes the return address
              0040* jp   (ix)     ; Jump to the address in IX
              0041* ENDMACRO
              0042* 
              0043* ; Simulated call to soubroutinte at IY
              0044* ; inputs: IY pointing to the subroutine address plus whatever the called function expects
              0045* ; outputs: whatever the subroutine does, including IY and BC
              0046* ; destroys: only what the subroutine does, but always BC
              0047* MACRO callIY
              0048* ld bc,$+7     ; Address of first instruction after the jump
              0049* push bc       ; which constitutes the return address
              0050* jp   (iy)     ; Jump to the address in IY
              0051* ENDMACRO
              0052* 
              0053* ; put the value in HLU into the accumulator
              0054* ; destroys: af
              0055* MACRO HLU_TO_A
              0056* push hl ; 4 cycles
              0057* inc sp ; 1 cycle
              0058* pop af  ; 4 cycles
              0059* dec sp ; 1 cycle
              0060* ; 10 cycles total
              0061* ENDMACRO
              0062* 
              0063* A_TO_HLU:
              0064* ; call is 7 cycles
0B0EB7 22     0065* ld (@scratch),hl ; 7 cycles
0B0EB8 C4 
0B0EB9 0E 
0B0EBA 0B 
0B0EBB 32     0066* ld (@scratch+2),a ; 5 cycles
0B0EBC C6 
0B0EBD 0E 
0B0EBE 0B 
0B0EBF 2A     0067* ld hl,(@scratch) ; 7 cycles
0B0EC0 C4 
0B0EC1 0E 
0B0EC2 0B 
0B0EC3 C9     0068* ret ; 6 cycles
              0069* ; 25 cycles total
0B0EC4 00     0070* @scratch: dl 0
0B0EC5 00 
0B0EC6 00 
              0071* 
              0072* ; TODO: implement this
              0073* ; MACRO A_TO_HLU
              0074* ;     push.s af
              0075* ;     inc sp
              0076* ;     push.s hl
              0077* ;     pop hl
              0078* ;     inc sp
              0079* ;     inc sp
              0080* ; ENDMACRO
              0081* 
              0082* MACRO PUSH_ALL
              0083* ex af,af'
              0084* exx
              0085* push af
              0086* push hl
              0087* push bc
              0088* push de
              0089* 
              0090* ex af,af'
              0091* exx
              0092* push af
              0093* push hl
              0094* push bc
              0095* push de
              0096* push ix
              0097* push iy
              0098* ENDMACRO
              0099* 
              0100* MACRO POP_ALL
              0101* pop iy
              0102* pop ix
              0103* pop de
              0104* pop bc
              0105* pop hl
              0106* pop af
              0107* ex af,af'
              0108* exx
              0109* 
              0110* pop de
              0111* pop bc
              0112* pop hl
              0113* pop af
              0114* ex af,af'
              0115* exx
              0116* ENDMACRO
              0117* 
              0118* ; Print a zero-terminated string inline with code, e.g.:
              0119* ;
              0120* ;    call printInline
              0121* ;    ASCIZ "Hello, world!\r\n"
              0122* ;
              0123* ; Destroys: HL,AF
              0124* printInline:
0B0EC7 E1     0125* pop hl ; get the return address = pointer to start of string
0B0EC8 CD     0126* call printString ; HL advances to end of string
0B0EC9 CE 
0B0ECA 0E 
0B0ECB 0B 
0B0ECC E5     0127* push hl ; restore the return address = pointer to end of string
0B0ECD C9     0128* ret
              0129* 
              0130* ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
              0131* ; Print a zero-terminated string
              0132* ; HL: Pointer to string
              0133* printString:
0B0ECE C5     0134* PUSH	BC
0B0ECF 01     0135* LD		BC,0
0B0ED0 00 
0B0ED1 00 
0B0ED2 00 
0B0ED3 3E     0136* LD 	 	A,0
0B0ED4 00 
0B0ED5 5B     0137* RST.LIL 18h
0B0ED6 DF 
0B0ED7 C1     0138* POP		BC
0B0ED8 C9     0139* RET
              0140* ; print a VDU sequence
              0141* ; HL: Pointer to VDU sequence - <1 byte length> <data>
              0142* sendVDUsequence:
0B0ED9 C5     0143* PUSH	BC
0B0EDA 01     0144* LD		BC, 0
0B0EDB 00 
0B0EDC 00 
0B0EDD 00 
0B0EDE 4E     0145* LD		C, (HL)
0B0EDF 5B     0146* RST.LIL	18h
0B0EE0 DF 
0B0EE1 C1     0147* POP		BC
0B0EE2 C9     0148* RET
              0149* ; Print Newline sequence to VDP
              0150* printNewLine:
0B0EE3 F5     0151* push af ; for some reason rst.lil 10h sets carry flag
0B0EE4 3E     0152* LD	A, '\r'
0B0EE5 0D 
0B0EE6 5B     0153* RST.LIL 10h
0B0EE7 D7 
0B0EE8 3E     0154* LD	A, '\n'
0B0EE9 0A 
0B0EEA 5B     0155* RST.LIL 10h
0B0EEB D7 
0B0EEC F1     0156* pop af
0B0EED C9     0157* RET
              0158* 
              0159* ; Print a 24-bit HEX number
              0160* ; HLU: Number to print
              0161* printHex24:
              0162* HLU_TO_A
0B0EEE E5    0001*M push hl ; 4 cycles
0B0EEF 33    0002*M inc sp ; 1 cycle
0B0EF0 F1    0003*M pop af  ; 4 cycles
0B0EF1 3B    0004*M dec sp ; 1 cycle
             0005*M ; 10 cycles total
0B0EF2 CD     0163* CALL	printHex8
0B0EF3 FC 
0B0EF4 0E 
0B0EF5 0B 
              0164* ; Print a 16-bit HEX number
              0165* ; HL: Number to print
              0166* printHex16:
0B0EF6 7C     0167* LD		A,H
0B0EF7 CD     0168* CALL	printHex8
0B0EF8 FC 
0B0EF9 0E 
0B0EFA 0B 
0B0EFB 7D     0169* LD		A,L
              0170* ; Print an 8-bit HEX number
              0171* ; A: Number to print
              0172* printHex8:
0B0EFC 4F     0173* LD		C,A
0B0EFD 1F     0174* RRA
0B0EFE 1F     0175* RRA
0B0EFF 1F     0176* RRA
0B0F00 1F     0177* RRA
0B0F01 CD     0178* CALL	@F
0B0F02 06 
0B0F03 0F 
0B0F04 0B 
0B0F05 79     0179* LD		A,C
              0180* @@:
0B0F06 E6     0181* AND		0Fh
0B0F07 0F 
0B0F08 C6     0182* ADD		A,90h
0B0F09 90 
0B0F0A 27     0183* DAA
0B0F0B CE     0184* ADC		A,40h
0B0F0C 40 
0B0F0D 27     0185* DAA
0B0F0E 5B     0186* RST.LIL	10h
0B0F0F D7 
0B0F10 C9     0187* RET
              0188* 
              0189* printHexA:
0B0F11 F5     0190* push af
0B0F12 C5     0191* push bc
0B0F13 CD     0192* call printHex8
0B0F14 FC 
0B0F15 0E 
0B0F16 0B 
0B0F17 3E     0193* ld a,' '
0B0F18 20 
0B0F19 5B     0194* rst.lil 10h
0B0F1A D7 
0B0F1B C1     0195* pop bc
0B0F1C F1     0196* pop af
0B0F1D C9     0197* ret
              0198* 
              0199* printHexHL:
0B0F1E F5     0200* push af
0B0F1F C5     0201* push bc
0B0F20 CD     0202* call printHex16
0B0F21 F6 
0B0F22 0E 
0B0F23 0B 
0B0F24 3E     0203* ld a,' '
0B0F25 20 
0B0F26 5B     0204* rst.lil 10h
0B0F27 D7 
0B0F28 C1     0205* pop bc
0B0F29 F1     0206* pop af
0B0F2A C9     0207* ret
              0208* 
              0209* printHexUHL:
0B0F2B F5     0210* push af
0B0F2C C5     0211* push bc
0B0F2D CD     0212* call printHex24
0B0F2E EE 
0B0F2F 0E 
0B0F30 0B 
0B0F31 3E     0213* ld a,' '
0B0F32 20 
0B0F33 5B     0214* rst.lil 10h
0B0F34 D7 
0B0F35 C1     0215* pop bc
0B0F36 F1     0216* pop af
0B0F37 C9     0217* ret
              0218* 
              0219* printHexAUHL:
0B0F38 F5     0220* push af
0B0F39 C5     0221* push bc
0B0F3A CD     0222* call printHex8
0B0F3B FC 
0B0F3C 0E 
0B0F3D 0B 
0B0F3E 3E     0223* ld a,'.'
0B0F3F 2E 
0B0F40 5B     0224* rst.lil 10h
0B0F41 D7 
0B0F42 CD     0225* call printHex24
0B0F43 EE 
0B0F44 0E 
0B0F45 0B 
0B0F46 3E     0226* ld a,' '
0B0F47 20 
0B0F48 5B     0227* rst.lil 10h
0B0F49 D7 
0B0F4A C1     0228* pop bc
0B0F4B F1     0229* pop af
0B0F4C C9     0230* ret
              0231* 
              0232* printHexABHL:
              0233* ; preserve registers
0B0F4D C5     0234* push bc ; b will be ok c will not
0B0F4E F5     0235* push af ; will get totally destroyed
              0236* ; print a
0B0F4F CD     0237* call printHex8
0B0F50 FC 
0B0F51 0E 
0B0F52 0B 
              0238* ; print b
0B0F53 78     0239* ld a,b
0B0F54 CD     0240* call printHex8
0B0F55 FC 
0B0F56 0E 
0B0F57 0B 
              0241* ; print hl
0B0F58 CD     0242* call printHex16
0B0F59 F6 
0B0F5A 0E 
0B0F5B 0B 
              0243* ; restore registers
0B0F5C F1     0244* pop af
0B0F5D C1     0245* pop bc
0B0F5E C9     0246* ret
              0247* 
              0248* printHexBHL:
              0249* ; preserve registers
0B0F5F C5     0250* push bc ; b will be ok c will not
0B0F60 F5     0251* push af ; will get totally destroyed
              0252* ; print b
0B0F61 78     0253* ld a,b
0B0F62 CD     0254* call printHex8
0B0F63 FC 
0B0F64 0E 
0B0F65 0B 
              0255* ; print hl
0B0F66 CD     0256* call printHex16
0B0F67 F6 
0B0F68 0E 
0B0F69 0B 
              0257* ; restore registers
0B0F6A F1     0258* pop af
0B0F6B C1     0259* pop bc
0B0F6C C9     0260* ret
              0261* 
              0262* printHexCDE:
              0263* ; preserve registers
0B0F6D C5     0264* push bc ; b will be ok c will not
0B0F6E F5     0265* push af ; will get totally destroyed
              0266* ; print c
0B0F6F 79     0267* ld a,c
0B0F70 CD     0268* call printHex8
0B0F71 FC 
0B0F72 0E 
0B0F73 0B 
              0269* ; print de
0B0F74 EB     0270* ex de,hl
0B0F75 CD     0271* call printHex16
0B0F76 F6 
0B0F77 0E 
0B0F78 0B 
0B0F79 EB     0272* ex de,hl
              0273* ; restore registers
0B0F7A F1     0274* pop af
0B0F7B C1     0275* pop bc
0B0F7C C9     0276* ret
              0277* 
              0278* printHexUIX:
              0279* ; store everything in scratch
0B0F7D 22     0280* ld (uhl),hl
0B0F7E F6 
0B0F7F 13 
0B0F80 0B 
0B0F81 ED     0281* ld (ubc),bc
0B0F82 43 
0B0F83 F9 
0B0F84 13 
0B0F84 0B   
0B0F86 ED     0282* ld (ude),de
0B0F87 53 
0B0F88 FC 
0B0F89 13 
0B0F89 0B   
0B0F8B DD     0283* ld (uix),ix
0B0F8C 22 
0B0F8D FF 
0B0F8E 13 
0B0F8E 0B   
0B0F90 FD     0284* ld (uiy),iy
0B0F91 22 
0B0F92 02 
0B0F93 14 
0B0F93 0B   
0B0F95 F5     0285* push af ; fml
              0286* 
0B0F96 21     0287* ld hl,str_ixu
0B0F97 8D 
0B0F98 13 
0B0F99 0B 
0B0F9A CD     0288* call printString
0B0F9B CE 
0B0F9C 0E 
0B0F9D 0B 
0B0F9E 2A     0289* ld hl,(uix)
0B0F9F FF 
0B0FA0 13 
0B0FA1 0B 
0B0FA2 CD     0290* call printHex24
0B0FA3 EE 
0B0FA4 0E 
0B0FA5 0B 
0B0FA6 CD     0291* call printNewLine
0B0FA7 E3 
0B0FA8 0E 
0B0FA9 0B 
              0292* 
              0293* ; restore everything
0B0FAA 2A     0294* ld hl, (uhl)
0B0FAB F6 
0B0FAC 13 
0B0FAD 0B 
0B0FAE ED     0295* ld bc, (ubc)
0B0FAF 4B 
0B0FB0 F9 
0B0FB1 13 
0B0FB1 0B   
0B0FB3 ED     0296* ld de, (ude)
0B0FB4 5B 
0B0FB5 FC 
0B0FB6 13 
0B0FB6 0B   
0B0FB8 DD     0297* ld ix, (uix)
0B0FB9 2A 
0B0FBA FF 
0B0FBB 13 
0B0FBB 0B   
0B0FBD FD     0298* ld iy, (uiy)
0B0FBE 2A 
0B0FBF 02 
0B0FC0 14 
0B0FC0 0B   
0B0FC2 F1     0299* pop af
              0300* ; all done
0B0FC3 C9     0301* ret
              0302* 
              0303* ; Print a 0x HEX prefix
              0304* DisplayHexPrefix:
0B0FC4 3E     0305* LD	A, '0'
0B0FC5 30 
0B0FC6 5B     0306* RST.LIL 10h
0B0FC7 D7 
0B0FC8 3E     0307* LD	A, 'x'
0B0FC9 78 
0B0FCA 5B     0308* RST.LIL 10h
0B0FCB D7 
0B0FCC C9     0309* RET
              0310* 
              0311* MACRO printDecBC
              0312* push hl
              0313* push bc
              0314* pop hl
              0315* call printDec
              0316* pop hl
              0317* ENDMACRO
              0318* 
              0319* MACRO printDecDE
              0320* push hl
              0321* push de
              0322* pop hl
              0323* call printDec
              0324* pop hl
              0325* ENDMACRO
              0326* 
              0327* MACRO printDecHL
              0328* call printDec
              0329* ENDMACRO
              0330* 
              0331* MACRO printDecIX
              0332* push hl
              0333* push ix
              0334* pop hl
              0335* call printDec
              0336* pop hl
              0337* ENDMACRO
              0338* 
              0339* MACRO printDecIY
              0340* push hl
              0341* push iy
              0342* pop hl
              0343* call printDec
              0344* pop hl
              0345* ENDMACRO
              0346* 
              0347* 
              0348* ; Prints the right justified decimal value in HL without leading zeroes
              0349* ; HL : Value to print
              0350* ; preserves all registers and flags
              0351* printDec:
              0352* ; BEGIN MY CODE
              0353* ; back up all the things
0B0FCD F5     0354* push af
0B0FCE C5     0355* push bc
0B0FCF D5     0356* push de
0B0FD0 E5     0357* push hl
              0358* ; END MY CODE
0B0FD1 11     0359* LD	 DE, _printDecBuffer
0B0FD2 F9 
0B0FD3 0F 
0B0FD4 0B 
0B0FD5 CD     0360* CALL u24_to_ascii
0B0FD6 09 
0B0FD7 10 
0B0FD8 0B 
              0361* ; BEGIN MY CODE
              0362* ; replace leading zeroes with spaces
0B0FD9 21     0363* LD	 HL, _printDecBuffer
0B0FDA F9 
0B0FDB 0F 
0B0FDC 0B 
0B0FDD 06     0364* ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0FDE 07 
              0365* @loop:
0B0FDF 7E     0366* LD	 A, (HL)
0B0FE0 FE     0367* CP	 '0'
0B0FE1 30 
0B0FE2 C2     0368* JP	 NZ, @done
0B0FE3 EC 
0B0FE4 0F 
0B0FE5 0B 
0B0FE6 3E     0369* LD   A, ' '
0B0FE7 20 
0B0FE8 77     0370* LD	 (HL), A
0B0FE9 23     0371* INC	 HL
              0372* ; CALL vdu_cursor_forward
0B0FEA 10     0373* DJNZ @loop
0B0FEB F3 
              0374* @done:
              0375* ; END MY CODE
0B0FEC 21     0376* LD	 HL, _printDecBuffer
0B0FED F9 
0B0FEE 0F 
0B0FEF 0B 
0B0FF0 CD     0377* CALL printString
0B0FF1 CE 
0B0FF2 0E 
0B0FF3 0B 
              0378* ; BEGIN MY CODE
              0379* ; restore all the things
0B0FF4 E1     0380* pop hl
0B0FF5 D1     0381* pop de
0B0FF6 C1     0382* pop bc
0B0FF7 F1     0383* pop af
              0384* ; END MY CODE
0B0FF8 C9     0385* RET
0B0FF9 00     0386* _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
0B0FFA 00 
0B0FFB 00 
0B0FFC 00 
0B0FFC 00   
0B0FFD 00 
0B0FFE 00 
0B0FFF 00 
0B0FFF 00   
0B1000 00 
0B1001 00 
0B1002 00 
0B1002 00   
0B1003 00 
0B1004 00 
0B1005 00 
              0387* 
              0388* ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
              0389* ; starting to memory location pointing by DE, in decimal form and with leading zeroes
              0390* ; so it will allways be 8 characters length
              0391* ; HL : Value to convert to string
              0392* ; DE : pointer to buffer, at least 8 byte + 0
              0393* u24_to_ascii:
0B1009 01     0394* LD	 BC,-10000000
0B100A 80 
0B100B 69 
0B100C 67 
0B100D CD     0395* CALL @one_digit
0B100E 40 
0B100F 10 
0B1010 0B 
0B1011 01     0396* LD	 BC,-1000000
0B1012 C0 
0B1013 BD 
0B1014 F0 
0B1015 CD     0397* CALL @one_digit
0B1016 40 
0B1017 10 
0B1018 0B 
0B1019 01     0398* LD	 BC,-100000
0B101A 60 
0B101B 79 
0B101C FE 
0B101D CD     0399* CALL @one_digit
0B101E 40 
0B101F 10 
0B1020 0B 
0B1021 01     0400* LD   BC,-10000
0B1022 F0 
0B1023 D8 
0B1024 FF 
0B1025 CD     0401* CALL @one_digit
0B1026 40 
0B1027 10 
0B1028 0B 
0B1029 01     0402* LD   BC,-1000
0B102A 18 
0B102B FC 
0B102C FF 
0B102D CD     0403* CALL @one_digit
0B102E 40 
0B102F 10 
0B1030 0B 
0B1031 01     0404* LD   BC,-100
0B1032 9C 
0B1033 FF 
0B1034 FF 
0B1035 CD     0405* CALL @one_digit
0B1036 40 
0B1037 10 
0B1038 0B 
0B1039 0E     0406* LD   C,-10
0B103A F6 
0B103B CD     0407* CALL @one_digit
0B103C 40 
0B103D 10 
0B103E 0B 
0B103F 48     0408* LD   C,B
              0409* @one_digit:
0B1040 3E     0410* LD   A,'0'-1
0B1041 2F 
              0411* @divide_me:
0B1042 3C     0412* INC  A
0B1043 09     0413* ADD  HL,BC
0B1044 38     0414* JR   C,@divide_me
0B1045 FC 
0B1046 ED     0415* SBC  HL,BC
0B1047 42 
0B1048 12     0416* LD   (DE),A
0B1049 13     0417* INC  DE
0B104A C9     0418* RET
              0419* 
              0420* print_u24:
0B104B D5     0421* push de
0B104C E5     0422* push hl
0B104D 11     0423* ld de,_printDecBuffer
0B104E F9 
0B104F 0F 
0B1050 0B 
0B1051 CD     0424* call u24_to_ascii
0B1052 09 
0B1053 10 
0B1054 0B 
0B1055 21     0425* ld hl,_printDecBuffer
0B1056 F9 
0B1057 0F 
0B1058 0B 
0B1059 CD     0426* call printString
0B105A CE 
0B105B 0E 
0B105C 0B 
0B105D 3E     0427* ld a,' '
0B105E 20 
0B105F 5B     0428* rst.lil 10h
0B1060 D7 
0B1061 E1     0429* pop hl
0B1062 D1     0430* pop de
0B1063 C9     0431* ret
              0432* 
              0433* ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
              0434* ; HL : Value to convert to string (integer part in H, fractional part in L)
              0435* ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
              0436* u168_to_ascii:
              0437* ; add a leading space to make room for sign flag if needed
0B1064 3E     0438* ld a,' '
0B1065 20 
0B1066 12     0439* ld (de),a
0B1067 13     0440* inc de
              0441* ; Convert integer part
0B1068 E5     0442* push hl               ; Save HL (well need the fractional part later)
0B1069 CD     0443* call hlu_udiv256    ; Shift to get integer portion in HL
0B106A 5C 
0B106B 15 
0B106C 0B 
0B106D 01     0444* ld   bc, -10000
0B106E F0 
0B106F D8 
0B1070 FF 
0B1071 CD     0445* call @one_int
0B1072 94 
0B1073 10 
0B1074 0B 
0B1075 01     0446* ld   bc, -1000
0B1076 18 
0B1077 FC 
0B1078 FF 
0B1079 CD     0447* call @one_int
0B107A 94 
0B107B 10 
0B107C 0B 
0B107D 01     0448* ld   bc, -100
0B107E 9C 
0B107F FF 
0B1080 FF 
0B1081 CD     0449* call @one_int
0B1082 94 
0B1083 10 
0B1084 0B 
0B1085 0E     0450* ld   c, -10
0B1086 F6 
0B1087 CD     0451* call @one_int
0B1088 94 
0B1089 10 
0B108A 0B 
0B108B 48     0452* ld   c, b
0B108C CD     0453* call @one_int
0B108D 94 
0B108E 10 
0B108F 0B 
0B1090 C3     0454* jp   @frac            ; Jump to fractional part conversion
0B1091 9F 
0B1092 10 
0B1093 0B 
              0455* @one_int:
0B1094 3E     0456* ld   a, '0' - 1       ; Start ASCII character at '0'
0B1095 2F 
              0457* @divide_me:
0B1096 3C     0458* inc  a
0B1097 09     0459* add  hl, bc           ; Accumulate until overflow
0B1098 38     0460* jr   c, @divide_me
0B1099 FC 
0B109A ED     0461* sbc  hl, bc           ; Remove excess after overflow
0B109B 42 
0B109C 12     0462* ld   (de), a          ; Store ASCII digit
0B109D 13     0463* inc  de
0B109E C9     0464* ret
              0465* ; Convert fractional part
              0466* @frac:
0B109F 3E     0467* ld   a, '.'           ; Decimal point
0B10A0 2E 
0B10A1 12     0468* ld   (de), a
0B10A2 13     0469* inc  de
0B10A3 E1     0470* pop  hl               ; Restore HL with original fraction
0B10A4 06     0471* ld   b, 3             ; Loop counter for 3 fractional digits
0B10A5 03 
              0472* @frac_loop:
0B10A6 26     0473* ld   h, 10            ; Load multiplier for fractional part
0B10A7 0A 
0B10A8 ED     0474* mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B10A9 6C 
0B10AA 3E     0475* ld   a, '0'
0B10AB 30 
0B10AC 84     0476* add  a, h             ; Convert integer part to ASCII
0B10AD 12     0477* ld   (de), a
0B10AE 13     0478* inc  de
0B10AF 10     0479* djnz @frac_loop       ; Repeat for each fractional digit
0B10B0 F5 
              0480* ; Add null terminator
0B10B1 AF     0481* xor  a                ; Null terminator
0B10B2 12     0482* ld   (de), a
0B10B3 C9     0483* ret
              0484* 
              0485* print_u168:
0B10B4 D5     0486* push de
0B10B5 E5     0487* push hl
0B10B6 11     0488* ld de,_printDecBuffer
0B10B7 F9 
0B10B8 0F 
0B10B9 0B 
0B10BA CD     0489* call u168_to_ascii
0B10BB 64 
0B10BC 10 
0B10BD 0B 
0B10BE 21     0490* ld hl,_printDecBuffer
0B10BF F9 
0B10C0 0F 
0B10C1 0B 
0B10C2 CD     0491* call printString
0B10C3 CE 
0B10C4 0E 
0B10C5 0B 
0B10C6 E1     0492* pop hl
0B10C7 D1     0493* pop de
0B10C8 C9     0494* ret
              0495* 
              0496* ; signed version of u168_to_ascii
              0497* s168_to_ascii:
0B10C9 D5     0498* push de ; save starting address of buffer
0B10CA CD     0499* call hlu_abs
0B10CB F5 
0B10CC 14 
0B10CD 0B 
0B10CE F5     0500* push af ; save sign flag
0B10CF CD     0501* call u168_to_ascii
0B10D0 64 
0B10D1 10 
0B10D2 0B 
0B10D3 F1     0502* pop af ; restore sign flag
0B10D4 D1     0503* pop de ; restore starting address of buffer
0B10D5 F0     0504* ret p ; hlu was positive so nothing to do
0B10D6 3E     0505* ld a,'-'
0B10D7 2D 
0B10D8 12     0506* ld (de),a
0B10D9 C9     0507* ret
              0508* 
              0509* print_s168:
0B10DA D5     0510* push de
0B10DB E5     0511* push hl
0B10DC 11     0512* ld de,_printDecBuffer
0B10DD F9 
0B10DE 0F 
0B10DF 0B 
0B10E0 CD     0513* call s168_to_ascii
0B10E1 C9 
0B10E2 10 
0B10E3 0B 
0B10E4 21     0514* ld hl,_printDecBuffer
0B10E5 F9 
0B10E6 0F 
0B10E7 0B 
0B10E8 CD     0515* call printString
0B10E9 CE 
0B10EA 0E 
0B10EB 0B 
0B10EC E1     0516* pop hl
0B10ED D1     0517* pop de
0B10EE C9     0518* ret
              0519* 
              0520* print_s168_hl:
0B10EF F5     0521* push af
0B10F0 E5     0522* push hl
0B10F1 CD     0523* call print_s168
0B10F2 DA 
0B10F3 10 
0B10F4 0B 
0B10F5 3E     0524* ld a,' '
0B10F6 20 
0B10F7 5B     0525* rst.lil 10h
0B10F8 D7 
0B10F9 E1     0526* pop hl
0B10FA F1     0527* pop af
0B10FB C9     0528* ret
              0529* 
              0530* print_s168_bc:
0B10FC F5     0531* push af
0B10FD C5     0532* push bc
0B10FE E5     0533* push hl
0B10FF C5     0534* push bc
0B1100 E1     0535* pop hl
0B1101 CD     0536* call print_s168
0B1102 DA 
0B1103 10 
0B1104 0B 
0B1105 3E     0537* ld a,' '
0B1106 20 
0B1107 5B     0538* rst.lil 10h
0B1108 D7 
0B1109 E1     0539* pop hl
0B110A C1     0540* pop bc
0B110B F1     0541* pop af
0B110C C9     0542* ret
              0543* 
              0544* print_s168_de:
0B110D F5     0545* push af
0B110E D5     0546* push de
0B110F E5     0547* push hl
0B1110 EB     0548* ex de,hl
0B1111 CD     0549* call print_s168
0B1112 DA 
0B1113 10 
0B1114 0B 
0B1115 3E     0550* ld a,' '
0B1116 20 
0B1117 5B     0551* rst.lil 10h
0B1118 D7 
0B1119 E1     0552* pop hl
0B111A D1     0553* pop de
0B111B F1     0554* pop af
0B111C C9     0555* ret
              0556* 
              0557* print_s168_hl_bc_de:
0B111D F5     0558* push af
0B111E C5     0559* push bc
0B111F D5     0560* push de
0B1120 E5     0561* push hl
0B1121 CD     0562* call print_s168
0B1122 DA 
0B1123 10 
0B1124 0B 
0B1125 3E     0563* ld a,' '
0B1126 20 
0B1127 5B     0564* rst.lil 10h
0B1128 D7 
0B1129 C5     0565* push bc
0B112A E1     0566* pop hl
0B112B CD     0567* call print_s168
0B112C DA 
0B112D 10 
0B112E 0B 
0B112F 3E     0568* ld a,' '
0B1130 20 
0B1131 5B     0569* rst.lil 10h
0B1132 D7 
0B1133 EB     0570* ex de,hl
0B1134 CD     0571* call print_s168
0B1135 DA 
0B1136 10 
0B1137 0B 
0B1138 3E     0572* ld a,' '
0B1139 20 
0B113A 5B     0573* rst.lil 10h
0B113B D7 
0B113C E1     0574* pop hl
0B113D D1     0575* pop de
0B113E C1     0576* pop bc
0B113F F1     0577* pop af
0B1140 C9     0578* ret
              0579* 
              0580* print_s168_bc_de:
0B1141 F5     0581* push af
0B1142 C5     0582* push bc
0B1143 D5     0583* push de
0B1144 C5     0584* push bc
0B1145 E1     0585* pop hl
0B1146 CD     0586* call print_s168
0B1147 DA 
0B1148 10 
0B1149 0B 
0B114A 3E     0587* ld a,' '
0B114B 20 
0B114C 5B     0588* rst.lil 10h
0B114D D7 
0B114E EB     0589* ex de,hl
0B114F CD     0590* call print_s168
0B1150 DA 
0B1151 10 
0B1152 0B 
0B1153 3E     0591* ld a,' '
0B1154 20 
0B1155 5B     0592* rst.lil 10h
0B1156 D7 
0B1157 E1     0593* pop hl
0B1158 D1     0594* pop de
0B1159 C1     0595* pop bc
0B115A F1     0596* pop af
0B115B C9     0597* ret
              0598* 
              0599* print_s168_a:
0B115C F5     0600* push af
0B115D C5     0601* push bc
0B115E E5     0602* push hl
0B115F 21     0603* ld hl,0
0B1160 00 
0B1161 00 
0B1162 00 
0B1163 6F     0604* ld l,a
0B1164 CD     0605* call print_s168_hl
0B1165 EF 
0B1166 10 
0B1167 0B 
0B1168 E1     0606* pop hl
0B1169 C1     0607* pop bc
0B116A F1     0608* pop af
0B116B C9     0609* ret
              0610* 
              0611* ; #### new functions added by Brandon R. Gates ####
              0612* 
              0613* ; print the binary representation of the 8-bit value in a
              0614* ; destroys a, hl, bc
              0615* printBin8:
0B116C 06     0616* ld b,8      ; loop counter for 8 bits
0B116D 08 
0B116E 21     0617* ld hl,@cmd  ; set hl to the low byte of the output string
0B116F 89 
0B1170 11 
0B1171 0B 
              0618* ; (which will be the high bit of the value in a)
              0619* @loop:
0B1172 07     0620* rlca ; put the next highest bit into carry
0B1173 38     0621* jr c,@one
0B1174 04 
0B1175 36     0622* ld (hl),'0'
0B1176 30 
0B1177 18     0623* jr @next_bit
0B1178 02 
              0624* @one:
0B1179 36     0625* ld (hl),'1'
0B117A 31 
              0626* @next_bit:
0B117B 23     0627* inc hl
0B117C 10     0628* djnz @loop
0B117D F4 
              0629* ; print it
0B117E 21     0630* ld hl,@cmd
0B117F 89 
0B1180 11 
0B1181 0B 
0B1182 01     0631* ld bc,@end-@cmd
0B1183 08 
0B1184 00 
0B1185 00 
0B1186 5B     0632* rst.lil $18
0B1187 DF 
0B1188 C9     0633* ret
              0634* @cmd: ds 8 ; eight bytes for eight bits
              0635* @end:
              0636* 
              0637* ; print the binary representation of the 8-bit value in a
              0638* ; in reverse order (lsb first)
              0639* ; destroys a, hl, bc
              0640* printBin8Rev:
0B1191 06     0641* ld b,8      ; loop counter for 8 bits
0B1192 08 
0B1193 21     0642* ld hl,@cmd  ; set hl to the low byte of the output string
0B1194 AE 
0B1195 11 
0B1196 0B 
              0643* ; (which will be the high bit of the value in a)
              0644* @loop:
0B1197 0F     0645* rrca ; put the next lowest bit into carry
0B1198 38     0646* jr c,@one
0B1199 04 
0B119A 36     0647* ld (hl),'0'
0B119B 30 
0B119C 18     0648* jr @next_bit
0B119D 02 
              0649* @one:
0B119E 36     0650* ld (hl),'1'
0B119F 31 
              0651* @next_bit:
0B11A0 23     0652* inc hl
0B11A1 10     0653* djnz @loop
0B11A2 F4 
              0654* ; print it
0B11A3 21     0655* ld hl,@cmd
0B11A4 AE 
0B11A5 11 
0B11A6 0B 
0B11A7 01     0656* ld bc,@end-@cmd
0B11A8 08 
0B11A9 00 
0B11AA 00 
0B11AB 5B     0657* rst.lil $18
0B11AC DF 
0B11AD C9     0658* ret
              0659* @cmd: ds 8 ; eight bytes for eight bits
              0660* @end:
              0661* 
              0662* ; print registers to screen in hexidecimal format
              0663* ; inputs: none
              0664* ; outputs: values of every register printed to screen
              0665* ;    values of each register in global scratch memory
              0666* ; destroys: nothing
              0667* stepRegistersHex:
              0668* ; store everything in scratch
0B11B6 22     0669* ld (uhl),hl
0B11B7 F6 
0B11B8 13 
0B11B9 0B 
0B11BA ED     0670* ld (ubc),bc
0B11BB 43 
0B11BC F9 
0B11BD 13 
0B11BD 0B   
0B11BF ED     0671* ld (ude),de
0B11C0 53 
0B11C1 FC 
0B11C2 13 
0B11C2 0B   
0B11C4 DD     0672* ld (uix),ix
0B11C5 22 
0B11C6 FF 
0B11C7 13 
0B11C7 0B   
0B11C9 FD     0673* ld (uiy),iy
0B11CA 22 
0B11CB 02 
0B11CC 14 
0B11CC 0B   
0B11CE F5     0674* push af ; fml
0B11CF E1     0675* pop hl  ; thanks, zilog
0B11D0 22     0676* ld (uaf),hl
0B11D1 F3 
0B11D2 13 
0B11D3 0B 
0B11D4 F5     0677* push af ; dammit
              0678* 
              0679* ; home the cursor
              0680* ; call vdu_home_cursor
              0681* 
              0682* ; print each register
0B11D5 21     0683* ld hl,str_afu
0B11D6 79 
0B11D7 13 
0B11D8 0B 
0B11D9 CD     0684* call printString
0B11DA CE 
0B11DB 0E 
0B11DC 0B 
0B11DD 2A     0685* ld hl,(uaf)
0B11DE F3 
0B11DF 13 
0B11E0 0B 
0B11E1 CD     0686* call printHex24
0B11E2 EE 
0B11E3 0E 
0B11E4 0B 
0B11E5 CD     0687* call printNewLine
0B11E6 E3 
0B11E7 0E 
0B11E8 0B 
              0688* 
0B11E9 21     0689* ld hl,str_hlu
0B11EA 7E 
0B11EB 13 
0B11EC 0B 
0B11ED CD     0690* call printString
0B11EE CE 
0B11EF 0E 
0B11F0 0B 
0B11F1 2A     0691* ld hl,(uhl)
0B11F2 F6 
0B11F3 13 
0B11F4 0B 
0B11F5 CD     0692* call printHex24
0B11F6 EE 
0B11F7 0E 
0B11F8 0B 
0B11F9 CD     0693* call printNewLine
0B11FA E3 
0B11FB 0E 
0B11FC 0B 
              0694* 
0B11FD 21     0695* ld hl,str_bcu
0B11FE 83 
0B11FF 13 
0B1200 0B 
0B1201 CD     0696* call printString
0B1202 CE 
0B1203 0E 
0B1204 0B 
0B1205 2A     0697* ld hl,(ubc)
0B1206 F9 
0B1207 13 
0B1208 0B 
0B1209 CD     0698* call printHex24
0B120A EE 
0B120B 0E 
0B120C 0B 
0B120D CD     0699* call printNewLine
0B120E E3 
0B120F 0E 
0B1210 0B 
              0700* 
0B1211 21     0701* ld hl,str_deu
0B1212 88 
0B1213 13 
0B1214 0B 
0B1215 CD     0702* call printString
0B1216 CE 
0B1217 0E 
0B1218 0B 
0B1219 2A     0703* ld hl,(ude)
0B121A FC 
0B121B 13 
0B121C 0B 
0B121D CD     0704* call printHex24
0B121E EE 
0B121F 0E 
0B1220 0B 
0B1221 CD     0705* call printNewLine
0B1222 E3 
0B1223 0E 
0B1224 0B 
              0706* 
0B1225 21     0707* ld hl,str_ixu
0B1226 8D 
0B1227 13 
0B1228 0B 
0B1229 CD     0708* call printString
0B122A CE 
0B122B 0E 
0B122C 0B 
0B122D 2A     0709* ld hl,(uix)
0B122E FF 
0B122F 13 
0B1230 0B 
0B1231 CD     0710* call printHex24
0B1232 EE 
0B1233 0E 
0B1234 0B 
0B1235 CD     0711* call printNewLine
0B1236 E3 
0B1237 0E 
0B1238 0B 
              0712* 
0B1239 21     0713* ld hl,str_iyu
0B123A 92 
0B123B 13 
0B123C 0B 
0B123D CD     0714* call printString
0B123E CE 
0B123F 0E 
0B1240 0B 
0B1241 2A     0715* ld hl,(uiy)
0B1242 02 
0B1243 14 
0B1244 0B 
0B1245 CD     0716* call printHex24
0B1246 EE 
0B1247 0E 
0B1248 0B 
0B1249 CD     0717* call printNewLine
0B124A E3 
0B124B 0E 
0B124C 0B 
              0718* 
              0719* ; call vsync
              0720* 
0B124D CD     0721* call printNewLine
0B124E E3 
0B124F 0E 
0B1250 0B 
              0722* 
              0723* ; check for right shift key and quit if pressed
              0724* MOSCALL mos_getkbmap
0B1251 3E    0001*M LD	A, function
0B1252 1E 
0B1253 49    0002*M RST.LIS	08h
0B1254 CF 
              0725* @stayhere:
              0726* ; 7 RightShift
0B1255 DD     0727* bit 6,(ix+0)
0B1256 CB 
0B1257 00 
0B1258 76 
0B1259 20     0728* jr nz,@RightShift
0B125A 02 
0B125B 18     0729* jr @stayhere
0B125C F8 
              0730* @RightShift:
0B125D DD     0731* res 0,(ix+14) ; debounce the key (hopefully)
0B125E CB 
0B125F 0E 
0B1260 86 
0B1261 3E     0732* ld a,%10000000
0B1262 80 
              0733* ; call multiPurposeDelay
              0734* 
              0735* ; restore everything
0B1263 2A     0736* ld hl, (uhl)
0B1264 F6 
0B1265 13 
0B1266 0B 
0B1267 ED     0737* ld bc, (ubc)
0B1268 4B 
0B1269 F9 
0B126A 13 
0B126A 0B   
0B126C ED     0738* ld de, (ude)
0B126D 5B 
0B126E FC 
0B126F 13 
0B126F 0B   
0B1271 DD     0739* ld ix, (uix)
0B1272 2A 
0B1273 FF 
0B1274 13 
0B1274 0B   
0B1276 FD     0740* ld iy, (uiy)
0B1277 2A 
0B1278 02 
0B1279 14 
0B1279 0B   
0B127B F1     0741* pop af
              0742* ; all done
0B127C C9     0743* ret
              0744* 
              0745* ; print registers to screen in hexidecimal format
              0746* ; inputs: none
              0747* ; outputs: values of every register printed to screen
              0748* ;    values of each register in global scratch memory
              0749* ; destroys: nothing
              0750* dumpRegistersHex:
              0751* ; store everything in scratch
0B127D 22     0752* ld (uhl),hl
0B127E F6 
0B127F 13 
0B1280 0B 
0B1281 ED     0753* ld (ubc),bc
0B1282 43 
0B1283 F9 
0B1284 13 
0B1284 0B   
0B1286 ED     0754* ld (ude),de
0B1287 53 
0B1288 FC 
0B1289 13 
0B1289 0B   
0B128B DD     0755* ld (uix),ix
0B128C 22 
0B128D FF 
0B128E 13 
0B128E 0B   
0B1290 FD     0756* ld (uiy),iy
0B1291 22 
0B1292 02 
0B1293 14 
0B1293 0B   
0B1295 F5     0757* push af ; fml
0B1296 E1     0758* pop hl  ; thanks, zilog
0B1297 22     0759* ld (uaf),hl
0B1298 F3 
0B1299 13 
0B129A 0B 
0B129B F5     0760* push af ; dammit
              0761* 
              0762* ; home the cursor
              0763* ; call vdu_home_cursor
              0764* ; call printNewLine
              0765* 
              0766* ; print each register
0B129C 21     0767* ld hl,str_afu
0B129D 79 
0B129E 13 
0B129F 0B 
0B12A0 CD     0768* call printString
0B12A1 CE 
0B12A2 0E 
0B12A3 0B 
0B12A4 2A     0769* ld hl,(uaf)
0B12A5 F3 
0B12A6 13 
0B12A7 0B 
0B12A8 CD     0770* call printHex24
0B12A9 EE 
0B12AA 0E 
0B12AB 0B 
              0771* ; call printNewLine
              0772* 
0B12AC 21     0773* ld hl,str_hlu
0B12AD 7E 
0B12AE 13 
0B12AF 0B 
0B12B0 CD     0774* call printString
0B12B1 CE 
0B12B2 0E 
0B12B3 0B 
0B12B4 2A     0775* ld hl,(uhl)
0B12B5 F6 
0B12B6 13 
0B12B7 0B 
0B12B8 CD     0776* call printHex24
0B12B9 EE 
0B12BA 0E 
0B12BB 0B 
              0777* ; call printNewLine
              0778* 
0B12BC 21     0779* ld hl,str_bcu
0B12BD 83 
0B12BE 13 
0B12BF 0B 
0B12C0 CD     0780* call printString
0B12C1 CE 
0B12C2 0E 
0B12C3 0B 
0B12C4 2A     0781* ld hl,(ubc)
0B12C5 F9 
0B12C6 13 
0B12C7 0B 
0B12C8 CD     0782* call printHex24
0B12C9 EE 
0B12CA 0E 
0B12CB 0B 
              0783* ; call printNewLine
              0784* 
0B12CC 21     0785* ld hl,str_deu
0B12CD 88 
0B12CE 13 
0B12CF 0B 
0B12D0 CD     0786* call printString
0B12D1 CE 
0B12D2 0E 
0B12D3 0B 
0B12D4 2A     0787* ld hl,(ude)
0B12D5 FC 
0B12D6 13 
0B12D7 0B 
0B12D8 CD     0788* call printHex24
0B12D9 EE 
0B12DA 0E 
0B12DB 0B 
              0789* ; call printNewLine
              0790* 
0B12DC 21     0791* ld hl,str_ixu
0B12DD 8D 
0B12DE 13 
0B12DF 0B 
0B12E0 CD     0792* call printString
0B12E1 CE 
0B12E2 0E 
0B12E3 0B 
0B12E4 2A     0793* ld hl,(uix)
0B12E5 FF 
0B12E6 13 
0B12E7 0B 
0B12E8 CD     0794* call printHex24
0B12E9 EE 
0B12EA 0E 
0B12EB 0B 
              0795* ; call printNewLine
              0796* 
0B12EC 21     0797* ld hl,str_iyu
0B12ED 92 
0B12EE 13 
0B12EF 0B 
0B12F0 CD     0798* call printString
0B12F1 CE 
0B12F2 0E 
0B12F3 0B 
0B12F4 2A     0799* ld hl,(uiy)
0B12F5 02 
0B12F6 14 
0B12F7 0B 
0B12F8 CD     0800* call printHex24
0B12F9 EE 
0B12FA 0E 
0B12FB 0B 
              0801* ; call printNewLine
              0802* 
              0803* ; call vdu_vblank
              0804* 
0B12FC CD     0805* call printNewLine
0B12FD E3 
0B12FE 0E 
0B12FF 0B 
              0806* ; restore everything
0B1300 2A     0807* ld hl, (uhl)
0B1301 F6 
0B1302 13 
0B1303 0B 
0B1304 ED     0808* ld bc, (ubc)
0B1305 4B 
0B1306 F9 
0B1307 13 
0B1307 0B   
0B1309 ED     0809* ld de, (ude)
0B130A 5B 
0B130B FC 
0B130C 13 
0B130C 0B   
0B130E DD     0810* ld ix, (uix)
0B130F 2A 
0B1310 FF 
0B1311 13 
0B1311 0B   
0B1313 FD     0811* ld iy, (uiy)
0B1314 2A 
0B1315 02 
0B1316 14 
0B1316 0B   
0B1318 F1     0812* pop af
              0813* ; all done
0B1319 C9     0814* ret
              0815* 
              0816* dumpRegistersHexPrime:
0B131A D9     0817* exx
0B131B 08     0818* ex af,af'
0B131C CD     0819* call dumpRegistersHex
0B131D 7D 
0B131E 12 
0B131F 0B 
0B1320 08     0820* ex af,af'
0B1321 D9     0821* exx
0B1322 C9     0822* ret
              0823* 
              0824* ; additionally dump prime registers
              0825* ; inputs: none
              0826* ; outputs: values of every register printed to screen
              0827* ; destroys: nothing
              0828* dumpRegistersHexAll:
0B1323 CD     0829* call dumpRegistersHex
0B1324 7D 
0B1325 12 
0B1326 0B 
0B1327 08     0830* ex af,af'
0B1328 D9     0831* exx
0B1329 CD     0832* call dumpRegistersHex
0B132A 7D 
0B132B 12 
0B132C 0B 
0B132D 08     0833* ex af,af'
0B132E D9     0834* exx
0B132F C9     0835* ret
              0836* 
              0837* ; print hlu to screen in hexidecimal format
              0838* ; inputs: none
              0839* ; destroys: nothing
              0840* print_hex_hl:
0B1330 F5     0841* push af
0B1331 E5     0842* push hl
0B1332 21     0843* ld hl,str_hlu
0B1333 7E 
0B1334 13 
0B1335 0B 
0B1336 CD     0844* call printString
0B1337 CE 
0B1338 0E 
0B1339 0B 
0B133A E1     0845* pop hl
0B133B E5     0846* push hl
0B133C CD     0847* call printHex24
0B133D EE 
0B133E 0E 
0B133F 0B 
0B1340 3E     0848* ld a,' '
0B1341 20 
0B1342 5B     0849* rst.lil 10h
0B1343 D7 
0B1344 E1     0850* pop hl
0B1345 F1     0851* pop af
0B1346 C9     0852* ret
              0853* 
              0854* ; print bcu to screen in hexidecimal format
              0855* ; inputs: none
              0856* ; destroys: nothing
              0857* print_hex_bc:
0B1347 F5     0858* push af
0B1348 E5     0859* push hl
0B1349 C5     0860* push bc
0B134A 21     0861* ld hl,str_bcu
0B134B 83 
0B134C 13 
0B134D 0B 
0B134E CD     0862* call printString
0B134F CE 
0B1350 0E 
0B1351 0B 
0B1352 E1     0863* pop hl
0B1353 E5     0864* push hl
0B1354 CD     0865* call printHex24
0B1355 EE 
0B1356 0E 
0B1357 0B 
0B1358 3E     0866* ld a,' '
0B1359 20 
0B135A 5B     0867* rst.lil 10h
0B135B D7 
0B135C C1     0868* pop bc
0B135D E1     0869* pop hl
0B135E F1     0870* pop af
0B135F C9     0871* ret
              0872* 
              0873* ; print deu to screen in hexidecimal format
              0874* ; inputs: none
              0875* ; destroys: nothing
              0876* print_hex_de:
0B1360 F5     0877* push af
0B1361 E5     0878* push hl
0B1362 D5     0879* push de
0B1363 21     0880* ld hl,str_deu
0B1364 88 
0B1365 13 
0B1366 0B 
0B1367 CD     0881* call printString
0B1368 CE 
0B1369 0E 
0B136A 0B 
0B136B E1     0882* pop hl
0B136C E5     0883* push hl
0B136D CD     0884* call printHex24
0B136E EE 
0B136F 0E 
0B1370 0B 
0B1371 3E     0885* ld a,' '
0B1372 20 
0B1373 5B     0886* rst.lil 10h
0B1374 D7 
0B1375 D1     0887* pop de
0B1376 E1     0888* pop hl
0B1377 F1     0889* pop af
0B1378 C9     0890* ret
              0891* 
0B1379 20     0892* str_afu: db " af=",0
0B137A 61 
0B137B 66 
0B137C 3D 
0B137C 00   
0B137E 20     0893* str_hlu: db " hl=",0
0B137F 68 
0B1380 6C 
0B1381 3D 
0B1381 00   
0B1383 20     0894* str_bcu: db " bc=",0
0B1384 62 
0B1385 63 
0B1386 3D 
0B1386 00   
0B1388 20     0895* str_deu: db " de=",0
0B1389 64 
0B138A 65 
0B138B 3D 
0B138B 00   
0B138D 20     0896* str_ixu: db " ix=",0
0B138E 69 
0B138F 78 
0B1390 3D 
0B1390 00   
0B1392 20     0897* str_iyu: db " iy=",0
0B1393 69 
0B1394 79 
0B1395 3D 
0B1395 00   
              0898* 
              0899* ; print udeuhl to screen in hexidecimal format
              0900* ; inputs: none
              0901* ; outputs: concatenated hexidecimal udeuhl
              0902* ; destroys: nothing
              0903* dumpUDEUHLHex:
              0904* ; store everything in scratch
0B1397 22     0905* ld (uhl),hl
0B1398 F6 
0B1399 13 
0B139A 0B 
0B139B ED     0906* ld (ubc),bc
0B139C 43 
0B139D F9 
0B139E 13 
0B139E 0B   
0B13A0 ED     0907* ld (ude),de
0B13A1 53 
0B13A2 FC 
0B13A3 13 
0B13A3 0B   
0B13A5 DD     0908* ld (uix),ix
0B13A6 22 
0B13A7 FF 
0B13A8 13 
0B13A8 0B   
0B13AA FD     0909* ld (uiy),iy
0B13AB 22 
0B13AC 02 
0B13AD 14 
0B13AD 0B   
0B13AF F5     0910* push af
              0911* 
              0912* ; print each register
              0913* 
0B13B0 21     0914* ld hl,str_udeuhl
0B13B1 EA 
0B13B2 13 
0B13B3 0B 
0B13B4 CD     0915* call printString
0B13B5 CE 
0B13B6 0E 
0B13B7 0B 
0B13B8 2A     0916* ld hl,(ude)
0B13B9 FC 
0B13BA 13 
0B13BB 0B 
0B13BC CD     0917* call printHex24
0B13BD EE 
0B13BE 0E 
0B13BF 0B 
0B13C0 3E     0918* ld a,'.'	; print a dot to separate the values
0B13C1 2E 
0B13C2 5B     0919* rst.lil 10h
0B13C3 D7 
0B13C4 2A     0920* ld hl,(uhl)
0B13C5 F6 
0B13C6 13 
0B13C7 0B 
0B13C8 CD     0921* call printHex24
0B13C9 EE 
0B13CA 0E 
0B13CB 0B 
0B13CC CD     0922* call printNewLine
0B13CD E3 
0B13CE 0E 
0B13CF 0B 
              0923* 
              0924* ; restore everything
0B13D0 2A     0925* ld hl, (uhl)
0B13D1 F6 
0B13D2 13 
0B13D3 0B 
0B13D4 ED     0926* ld bc, (ubc)
0B13D5 4B 
0B13D6 F9 
0B13D7 13 
0B13D7 0B   
0B13D9 ED     0927* ld de, (ude)
0B13DA 5B 
0B13DB FC 
0B13DC 13 
0B13DC 0B   
0B13DE DD     0928* ld ix, (uix)
0B13DF 2A 
0B13E0 FF 
0B13E1 13 
0B13E1 0B   
0B13E3 FD     0929* ld iy, (uiy)
0B13E4 2A 
0B13E5 02 
0B13E6 14 
0B13E6 0B   
0B13E8 F1     0930* pop af
              0931* ; all done
0B13E9 C9     0932* ret
              0933* 
0B13EA 75     0934* str_udeuhl: db "ude.uhl=",0
0B13EB 64 
0B13EC 65 
0B13ED 2E 
0B13ED 75   
0B13EE 68 
0B13EF 6C 
0B13F0 3D 
0B13F0 00   
              0935* 
              0936* ; global scratch memory for registers
0B13F3 00     0937* uaf: dl 0
0B13F4 00 
0B13F5 00 
0B13F6 00     0938* uhl: dl 0
0B13F7 00 
0B13F8 00 
0B13F9 00     0939* ubc: dl 0
0B13FA 00 
0B13FB 00 
0B13FC 00     0940* ude: dl 0
0B13FD 00 
0B13FE 00 
0B13FF 00     0941* uix: dl 0
0B1400 00 
0B1401 00 
0B1402 00     0942* uiy: dl 0
0B1403 00 
0B1404 00 
0B1405 00     0943* usp: dl 0
0B1406 00 
0B1407 00 
0B1408 00     0944* upc: dl 0
0B1409 00 
0B140A 00 
              0945* 
              0946* ; inputs: whatever is in the flags register
              0947* ; outputs: binary representation of flags
              0948* ;          with a header so we know which is what
              0949* ; destroys: nothing
              0950* ; preserves: everything
              0951* dumpFlags:
              0952* ; first we curse zilog for not giving direct access to flags
0B140B F5     0953* push af ; this is so we can send it back unharmed
0B140C F5     0954* push af ; this is so we can pop it to hl
              0955* ; store everything in scratch
0B140D 22     0956* ld (uhl),hl
0B140E F6 
0B140F 13 
0B1410 0B 
0B1411 ED     0957* ld (ubc),bc
0B1412 43 
0B1413 F9 
0B1414 13 
0B1414 0B   
0B1416 ED     0958* ld (ude),de
0B1417 53 
0B1418 FC 
0B1419 13 
0B1419 0B   
0B141B DD     0959* ld (uix),ix
0B141C 22 
0B141D FF 
0B141E 13 
0B141E 0B   
0B1420 FD     0960* ld (uiy),iy
0B1421 22 
0B1422 02 
0B1423 14 
0B1423 0B   
              0961* ; next we print the header
0B1425 21     0962* ld hl,@header
0B1426 51 
0B1427 14 
0B1428 0B 
0B1429 CD     0963* call printString
0B142A CE 
0B142B 0E 
0B142C 0B 
0B142D E1     0964* pop hl ; flags are now in l
0B142E 7D     0965* ld a,l ; flags are now in a
0B142F CD     0966* call printBin8
0B1430 6C 
0B1431 11 
0B1432 0B 
0B1433 CD     0967* call printNewLine
0B1434 E3 
0B1435 0E 
0B1436 0B 
              0968* ; restore everything
0B1437 2A     0969* ld hl, (uhl)
0B1438 F6 
0B1439 13 
0B143A 0B 
0B143B ED     0970* ld bc, (ubc)
0B143C 4B 
0B143D F9 
0B143E 13 
0B143E 0B   
0B1440 ED     0971* ld de, (ude)
0B1441 5B 
0B1442 FC 
0B1443 13 
0B1443 0B   
0B1445 DD     0972* ld ix, (uix)
0B1446 2A 
0B1447 FF 
0B1448 13 
0B1448 0B   
0B144A FD     0973* ld iy, (uiy)
0B144B 2A 
0B144C 02 
0B144D 14 
0B144D 0B   
0B144F F1     0974* pop af ; send her home the way she came
0B1450 C9     0975* ret
              0976* ; Bit 7 (S): Sign flag
              0977* ; Bit 6 (Z): Zero flag
              0978* ; Bit 5 (5): Reserved (copy of bit 5 of the result)
              0979* ; Bit 4 (H): Half Carry flag
              0980* ; Bit 3 (3): Reserved (copy of bit 3 of the result)
              0981* ; Bit 2 (PV): Parity/Overflow flag
              0982* ; Bit 1 (N): Subtract flag
              0983* ; Bit 0 (C): Carry flag
0B1451 53     0984* @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
0B1452 5A 
0B1453 78 
0B1454 48 
0B1454 78   
0B1455 50 
0B1456 4E 
0B1457 43 
0B1457 0D   
0B1458 0A 
0B1459 00 
              0985* 
              0986* ; set all the bits in the flag register
              0987* ; more of an academic exercise than anything useful
              0988* ; inputs; none
              0989* ; outputs; a=0,f=255
              0990* ; destroys: flags, hl
              0991* ; preserves: a, because why not
              0992* setAllFlags:
0B145C 21     0993* ld hl,255
0B145D FF 
0B145E 00 
0B145F 00 
0B1460 67     0994* ld h,a ; four cycles to preserve a is cheap
0B1461 E5     0995* push hl
0B1462 F1     0996* pop af
0B1463 C9     0997* ret
              0998* 
              0999* ; reset all the bits in the flag register
              1000* ; unlike its inverse counterpart, this may actually be useful
              1001* ; inputs; none
              1002* ; outputs; a=0,f=0
              1003* ; destroys: flags, hl
              1004* ; preserves: a, because why not
              1005* resetAllFlags:
0B1464 21     1006* ld hl,0
0B1465 00 
0B1466 00 
0B1467 00 
0B1468 67     1007* ld h,a ; four cycles to preserve a is cheap
0B1469 E5     1008* push hl
0B146A F1     1009* pop af
0B146B C9     1010* ret
              1011* 
              1012* ; wait until user presses a key
              1013* ; inputs: none
              1014* ; outputs: none
              1015* ; destroys: af,ix
              1016* waitKeypress:
              1017* MOSCALL mos_sysvars
0B146C 3E    0001*M LD	A, function
0B146D 08 
0B146E 49    0002*M RST.LIS	08h
0B146F CF 
0B1470 AF     1018* xor a ; zero out any prior keypresses
0B1471 DD     1019* ld (ix+sysvar_keyascii),a
0B1472 77 
0B1473 05 
              1020* @loop:
0B1474 DD     1021* ld a,(ix+sysvar_keyascii)
0B1475 7E 
0B1476 05 
0B1477 A7     1022* and a
0B1478 C0     1023* ret nz
0B1479 18     1024* jr @loop
0B147A F9 
              1025* 
              1026* 
              1027* ; print bytes from an address to the screen in hexidecimal format
              1028* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1029* ; outputs: values of each byte printed to screen separated by spaces
              1030* ; destroys: nothing
              1031* dumpMemoryHex:
              1032* ; save registers to the stack
0B147B C5     1033* push bc
0B147C E5     1034* push hl
0B147D F5     1035* push af
              1036* 
              1037* ; print the address and separator
0B147E CD     1038* call printHex24
0B147F EE 
0B1480 0E 
0B1481 0B 
0B1482 3E     1039* ld a,':'
0B1483 3A 
0B1484 5B     1040* rst.lil 10h
0B1485 D7 
0B1486 3E     1041* ld a,' '
0B1487 20 
0B1488 5B     1042* rst.lil 10h
0B1489 D7 
              1043* 
              1044* ; set b to be our loop counter
0B148A F1     1045* pop af
0B148B 47     1046* ld b,a
0B148C E1     1047* pop hl
0B148D E5     1048* push hl
0B148E F5     1049* push af
              1050* @loop:
              1051* ; print the byte
0B148F 7E     1052* ld a,(hl)
0B1490 CD     1053* call printHex8
0B1491 FC 
0B1492 0E 
0B1493 0B 
              1054* ; print a space
0B1494 3E     1055* ld a,' '
0B1495 20 
0B1496 5B     1056* rst.lil 10h
0B1497 D7 
0B1498 23     1057* inc hl
0B1499 10     1058* djnz @loop
0B149A F4 
0B149B CD     1059* call printNewLine
0B149C E3 
0B149D 0E 
0B149E 0B 
              1060* 
              1061* ; restore everything
0B149F F1     1062* pop af
0B14A0 E1     1063* pop hl
0B14A1 C1     1064* pop bc
              1065* 
              1066* ; all done
0B14A2 C9     1067* ret
              1068* 
              1069* 
              1070* ; print bytes from an address to the screen in binary format
              1071* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1072* ; outputs: values of each byte printed to screen separated by spaces
              1073* ; destroys: nothing
              1074* dumpMemoryBin:
              1075* ; save all registers to the stack
0B14A3 F5     1076* push af
0B14A4 C5     1077* push bc
0B14A5 D5     1078* push de
0B14A6 E5     1079* push hl
0B14A7 DD     1080* push ix
0B14A8 E5 
0B14A9 FD     1081* push iy
0B14AA E5 
              1082* 
              1083* ; set b to be our loop counter
0B14AB 47     1084* ld b,a
              1085* @loop:
              1086* ; print the byte
0B14AC 7E     1087* ld a,(hl)
0B14AD E5     1088* push hl
0B14AE C5     1089* push bc
0B14AF CD     1090* call printBin8
0B14B0 6C 
0B14B1 11 
0B14B2 0B 
0B14B3 C1     1091* pop bc
              1092* ; print a space
0B14B4 3E     1093* ld a,' '
0B14B5 20 
0B14B6 5B     1094* rst.lil 10h
0B14B7 D7 
0B14B8 E1     1095* pop hl
0B14B9 23     1096* inc hl
0B14BA 10     1097* djnz @loop
0B14BB F0 
0B14BC CD     1098* call printNewLine
0B14BD E3 
0B14BE 0E 
0B14BF 0B 
              1099* 
              1100* ; restore everything
0B14C0 FD     1101* pop iy
0B14C1 E1 
0B14C2 DD     1102* pop ix
0B14C3 E1 
0B14C4 E1     1103* pop hl
0B14C5 D1     1104* pop de
0B14C6 C1     1105* pop bc
0B14C7 F1     1106* pop af
              1107* ; all done
0B14C8 C9     1108* ret
              1109* 
              1110* ; print bytes from an address to the screen in binary format
              1111* ; with the bits of each byte in reverse order (lsb first)
              1112* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1113* ; outputs: values of each byte printed to screen separated by spaces
              1114* ; destroys: nothing
              1115* dumpMemoryBinRev:
              1116* ; save all registers to the stack
0B14C9 F5     1117* push af
0B14CA C5     1118* push bc
0B14CB D5     1119* push de
0B14CC E5     1120* push hl
0B14CD DD     1121* push ix
0B14CE E5 
0B14CF FD     1122* push iy
0B14D0 E5 
              1123* 
              1124* ; set b to be our loop counter
0B14D1 47     1125* ld b,a
              1126* @loop:
              1127* ; print the byte
0B14D2 7E     1128* ld a,(hl)
0B14D3 E5     1129* push hl
0B14D4 C5     1130* push bc
0B14D5 CD     1131* call printBin8Rev
0B14D6 91 
0B14D7 11 
0B14D8 0B 
0B14D9 C1     1132* pop bc
              1133* ; print a space
0B14DA 3E     1134* ld a,' '
0B14DB 20 
0B14DC 5B     1135* rst.lil 10h
0B14DD D7 
0B14DE E1     1136* pop hl
0B14DF 23     1137* inc hl
0B14E0 10     1138* djnz @loop
0B14E1 F0 
0B14E2 CD     1139* call printNewLine
0B14E3 E3 
0B14E4 0E 
0B14E5 0B 
              1140* 
              1141* ; restore everything
0B14E6 FD     1142* pop iy
0B14E7 E1 
0B14E8 DD     1143* pop ix
0B14E9 E1 
0B14EA E1     1144* pop hl
0B14EB D1     1145* pop de
0B14EC C1     1146* pop bc
0B14ED F1     1147* pop af
              1148* ; all done
0B14EE C9     1149* ret
               0170 include "maths.inc"
              0001* ;------------------------------------------------------------------------
              0002* ; Scratch area for calculations
              0003* ;------------------------------------------------------------------------
0B14EF 00     0004* scratch1:	dw24	0	;bit manipulation buffer 1
0B14F0 00 
0B14F1 00 
0B14F2 00     0005* scratch2:	dw24	0	;bit manipulation buffer 2
0B14F3 00 
0B14F4 00 
              0006* 
              0007* ; absolute value of hlu
              0008* ; returns: abs(hlu), flags set according to the incoming sign of hlu:
              0009* ;         s1,z0,pv0,n1,c0 if hlu was negative
              0010* ;         s0,z1,pv0,n1,c0 if hlu was zero
              0011* ;         s0,z0,pv0,n1,c0 if hlu was positive
              0012* ; destroys: a
              0013* hlu_abs:
0B14F5 19     0014* add hl,de
0B14F6 B7     0015* or a
0B14F7 ED     0016* sbc hl,de
0B14F8 52 
0B14F9 FA     0017* jp m,@is_neg
0B14FA FE 
0B14FB 14 
0B14FC 0B 
0B14FD C9     0018* ret         ; hlu is positive or zero so we're done
              0019* @is_neg:
0B14FE F5     0020* push af     ; otherwise, save current flags for return
0B14FF CD     0021* call neg_hlu ; negate hlu
0B1500 05 
0B1501 15 
0B1502 0B 
0B1503 F1     0022* pop af      ; get back flags
0B1504 C9     0023* ret
              0024* 
              0025* ; flip the sign of hlu
              0026* ; inputs: hlu
              0027* ; returns: 0-hlu, flags set appropriately for the result:
              0028* ;         s1,z0,pv0,n1,c1 if result is negative
              0029* ;         s0,z1,pv0,n1,c0 if result is zero
              0030* ;         s0,z0,pv0,n1,c1 if result is positive
              0031* ; destroys a
              0032* neg_hlu:
0B1505 D5     0033* push de     ; save de
0B1506 EB     0034* ex de,hl    ; put hl into de
0B1507 21     0035* ld hl,0     ; clear hl
0B1508 00 
0B1509 00 
0B150A 00 
0B150B AF     0036* xor a       ; clear carry
0B150C ED     0037* sbc hl,de   ; 0-hlu = -hlu
0B150D 52 
0B150E D1     0038* pop de      ; get de back
0B150F C9     0039* ret         ; easy peasy
              0040* 
              0041* ;------------------------------------------------------------------------
              0042* ; divide hlu by 2, inspired by above
              0043* ;------------------------------------------------------------------------
              0044* hlu_div2:
0B1510 22     0045* ld		(scratch1),hl
0B1511 EF 
0B1512 14 
0B1513 0B 
0B1514 21     0046* ld		hl,scratch1+2
0B1515 F1 
0B1516 14 
0B1517 0B 
0B1518 CB     0047* rr		(hl)
0B1519 1E 
0B151A 2B     0048* dec		hl
0B151B CB     0049* rr		(hl)
0B151C 1E 
0B151D 2B     0050* dec		hl
0B151E CB     0051* rr		(hl)
0B151F 1E 
0B1520 23     0052* inc		hl
0B1521 23     0053* inc		hl
0B1522 2A     0054* ld hl,(scratch1)
0B1523 EF 
0B1524 14 
0B1525 0B 
0B1526 C9     0055* ret
              0056* 
              0057* ; this is my little hack to divide by 16
              0058* hlu_div16:
0B1527 AF     0059* xor a
0B1528 29     0060* add hl,hl
0B1529 17     0061* rla
0B152A 29     0062* add hl,hl
0B152B 17     0063* rla
0B152C 29     0064* add hl,hl
0B152D 17     0065* rla
0B152E 29     0066* add hl,hl
0B152F 17     0067* rla
0B1530 22     0068* ld (@scratch),hl
0B1531 3D 
0B1532 15 
0B1533 0B 
0B1534 32     0069* ld (@scratch+3),a
0B1535 40 
0B1536 15 
0B1537 0B 
0B1538 2A     0070* ld hl,(@scratch+1)
0B1539 3E 
0B153A 15 
0B153B 0B 
0B153C C9     0071* ret
              0072* @scratch: ds 4
              0073* 
              0074* ; hlu signed division by 256
              0075* ; returns: hlu / 256
              0076* ; destroys: af
              0077* hlu_sdiv256:
0B1541 AF     0078* xor a ; assume hl is positive
0B1542 22     0079* ld (@buffer),hl
0B1543 58 
0B1544 15 
0B1545 0B 
              0080* sign_hlu
0B1546 19    0001*M add hl,de
0B1547 B7    0002*M or a
0B1548 ED    0003*M sbc hl,de
0B1549 52 
0B154A F2     0081* jp p,@hl_pos
0B154B 4F 
0B154C 15 
0B154D 0B 
0B154E 3D     0082* dec a
              0083* @hl_pos:
0B154F 32     0084* ld (@buffer+3),a
0B1550 5B 
0B1551 15 
0B1552 0B 
0B1553 2A     0085* ld hl,(@buffer+1)
0B1554 59 
0B1555 15 
0B1556 0B 
0B1557 C9     0086* ret
              0087* @buffer: ds 4
              0088* 
              0089* ; hlu 1 byte right shift, unsigned
              0090* ; returns: hlu / 256, fractional portion in a
              0091* ; destroys: af
              0092* hlu_udiv256:
0B155C AF     0093* xor a
0B155D 32     0094* ld (@buffer+3),a
0B155E 6E 
0B155F 15 
0B1560 0B 
0B1561 7D     0095* ld a,l ; save the fractional portion
0B1562 22     0096* ld (@buffer),hl
0B1563 6B 
0B1564 15 
0B1565 0B 
0B1566 2A     0097* ld hl,(@buffer+1)
0B1567 6C 
0B1568 15 
0B1569 0B 
0B156A C9     0098* ret
              0099* @buffer: ds 4
              0100* 
              0101* MACRO hlu_mul256
              0102* add hl,hl ; * 2
              0103* add hl,hl ; * 4
              0104* add hl,hl ; * 8
              0105* add hl,hl ; * 16
              0106* add hl,hl ; * 32
              0107* add hl,hl ; * 64
              0108* add hl,hl ; * 128
              0109* add hl,hl ; * 256
              0110* ENDMACRO
              0111* 
              0112* ; compute the modulo of hlu by deu
              0113* ; outputs: hlu = hlu % deu
              0114* ; destroys: f, hl
              0115* hlu_mod:
0B156F B7     0116* or a ; clear carry
              0117* @loop:
0B1570 ED     0118* sbc hl,de
0B1571 52 
0B1572 DA     0119* jp c, @end
0B1573 7A 
0B1574 15 
0B1575 0B 
0B1576 C3     0120* jp @loop
0B1577 70 
0B1578 15 
0B1579 0B 
              0121* @end:
0B157A 19     0122* add hl,de
0B157B C9     0123* ret
              0124* 
              0125* 
0B157C 00     0126* add_bcd_arg1: db #00,#00,#00,#00
0B157D 00 
0B157E 00 
0B157F 00 
0B1580 00     0127* add_bcd_arg2: db #00,#00,#00,#00
0B1581 00 
0B1582 00 
0B1583 00 
              0128* 
              0129* ; set bcd values in a scratch memory address from registers bcde
              0130* ; input: hl; scratch address,bcde; 8-place bcd number
              0131* ; destroys ; hl
              0132* set_bcd:
0B1584 73     0133* ld (hl),e
0B1585 23     0134* inc hl
0B1586 72     0135* ld (hl),d
0B1587 23     0136* inc hl
0B1588 71     0137* ld (hl),c
0B1589 23     0138* inc hl
0B158A 70     0139* ld (hl),b
0B158B C9     0140* ret
              0141* 
              0142* ; load bcd values from a scratch memory address to bcde
              0143* ; input: hl; scratch address
              0144* ; output: bcde; 8-place bcd number
              0145* ; destroys: hl
              0146* get_bcd:
0B158C 5E     0147* ld e,(hl)
0B158D 23     0148* inc hl
0B158E 56     0149* ld d,(hl)
0B158F 23     0150* inc hl
0B1590 4E     0151* ld c,(hl)
0B1591 23     0152* inc hl
0B1592 46     0153* ld b,(hl)
0B1593 C9     0154* ret
              0155* 
              0156* ; BCD addition
              0157* ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
              0158* ;       a is the number of bytes holding each number (number of places/2)
              0159* ; outputs: (hl) + (de) --> (hl)
              0160* ; destroys: a,b,de,hl
              0161* add_bcd:
0B1594 47     0162* ld b,a ; loop counter
0B1595 AF     0163* xor a ; reset a, clear carry flag
              0164* adcec:
0B1596 1A     0165* ld a,(de) ; addend to acc
0B1597 8E     0166* adc a,(hl) ; add (hl) to acc
0B1598 27     0167* daa ; adjust result to bcd
0B1599 77     0168* ld (hl),a ; store result
0B159A 23     0169* inc hl ; advance memory pointers
0B159B 13     0170* inc de
0B159C 10     0171* djnz adcec ; loop until b == 0
0B159D F8 
0B159E C9     0172* ret
              0173* 
              0174* ; BCD subtraction
              0175* ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
              0176* ;       a is the number of bytes holding each number (number of places/2)
              0177* ; outputs: (hl) - (de) --> (hl)
              0178* ; destroys: a,b,de,hl
              0179* sub_bcd:
0B159F 47     0180* ld b,a ; loop counter
0B15A0 AF     0181* xor a ; reset a,clear carry flag
              0182* subdec:
0B15A1 1A     0183* ld a,(de) ; subtrahend to acc
0B15A2 9E     0184* sbc a,(hl) ; subtract (hl) from acc
0B15A3 27     0185* daa ; adjust result to bcd
0B15A4 77     0186* ld (hl),a ; store result
0B15A5 23     0187* inc hl ; advance memory pointers
0B15A6 13     0188* inc de
0B15A7 10     0189* djnz subdec ; loop until b == 0
0B15A8 F8 
0B15A9 C9     0190* ret
              0191* 
              0192* ; http://www.z80.info/pseudo-random.txt
              0193* rand_8:
0B15AA C5     0194* push bc
0B15AB 3A     0195* ld a,(r_seed)
0B15AC BE 
0B15AD 15 
0B15AE 0B 
0B15AF 4F     0196* ld c,a
              0197* 
0B15B0 0F     0198* rrca ; multiply by 32
0B15B1 0F     0199* rrca
0B15B2 0F     0200* rrca
0B15B3 EE     0201* xor 0x1f
0B15B4 1F 
              0202* 
0B15B5 81     0203* add a,c
0B15B6 DE     0204* sbc a,255 ; carry
0B15B7 FF 
              0205* 
0B15B8 32     0206* ld (r_seed),a
0B15B9 BE 
0B15BA 15 
0B15BB 0B 
0B15BC C1     0207* pop bc
0B15BD C9     0208* ret
0B15BE 50     0209* r_seed: defb $50
               0171 include "mathfpp.inc"
              0001* ; integer operations
              0002* iand:	EQU 58	; AND (INTEGER)
              0003* ibdiv:	EQU 59	; DIV
              0004* ieor:	EQU 60	; EOR
              0005* imod:	EQU 61	; MOD
              0006* ior:	EQU 62	; OR
              0007* ile:	EQU 63	; <=
              0008* ine:	EQU 64	; <>
              0009* ige:	EQU 65	; >=
              0010* ilt:	EQU 66	; <
              0011* ieq:	EQU 67	; =
              0012* imul:	EQU 68	; *
              0013* iadd:	EQU 69	; +
              0014* igt:	EQU 70	; >
              0015* isub:	EQU 71	; -
              0016* ipow:	EQU 72	; ^
              0017* idiv:	EQU 73	; /
              0018* ;
              0019* ; floating point functions
              0020* absv:	EQU 16	; ABS
              0021* acs:	EQU 17	; ACS
              0022* asn:	EQU 18	; ASN
              0023* atn:	EQU 19	; ATN
              0024* cos:	EQU 20	; COS
              0025* deg:	EQU 21	; DEG
              0026* exp:	EQU 22	; EXP
              0027* int_:	EQU 23	; INT
              0028* ln:	EQU 24	; LN
              0029* log:	EQU 25	; LOG
              0030* notk:	EQU 26	; NOT
              0031* rad:	EQU 27	; RAD
              0032* sgn:	EQU 28	; SGN
              0033* sin:	EQU 29	; SIN
              0034* sqr:	EQU 30	; SQR
              0035* tan:	EQU 31	; TAN
              0036* zero:	EQU 32	; ZERO
              0037* fone:	EQU 33	; FONE
              0038* true:	EQU 34	; TRUE
              0039* pi:	EQU 35	; PI
              0040* val:	EQU 36	; VAL
              0041* str:	EQU 37	; STR$
              0042* sfix:	EQU 38	; FIX
              0043* sfloat:	EQU 39	; FLOAT
              0044* ftest:	EQU 40	; TEST
              0045* fcomp:	EQU 41	; COMPARE
              0046* ;
              0047* ; floating point operations
              0048* fand:	EQU  0	; AND (FLOATING-POINT)
              0049* fbdiv:	EQU  1	; DIV
              0050* feor:	EQU  2	; EOR
              0051* fmod:	EQU  3	; MOD
              0052* ffor:	EQU  4	; OR
              0053* fle:	EQU  5	; <=
              0054* fne:	EQU  6	; <>
              0055* fge:	EQU  7	; >=
              0056* flt:	EQU  8	; <
              0057* feq:	EQU  9	; =
              0058* fmul:	EQU 10	; *
              0059* fadd:	EQU 11	; +
              0060* fgt:	EQU 12	; >
              0061* fsub:	EQU 13	; -
              0062* fpow:	EQU 14	; ^
              0063* fdiv:	EQU 15	; /
              0064* 
              0065* ; --- originally in eval.asm ---
              0066* ;SWAP - Swap arguments
              0067* ;Exchanges DE,HL D'E',H'L' and B,C
              0068* ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
              0069* ;
0B15BF 79     0070* SWAP:			LD      A,C
0B15C0 48     0071* LD      C,B
0B15C1 47     0072* LD      B,A
0B15C2 EB     0073* EX      DE,HL
0B15C3 D9     0074* EXX
0B15C4 EB     0075* EX      DE,HL
0B15C5 D9     0076* EXX
0B15C6 C9     0077* RET
              0078* 
              0079* ; convert floating point number to integer and store it in HLU
              0080* ; inputs: HLH'L'C = floating point number
              0081* ; outputs: HLU = integer part of the number
              0082* ; destroys: all except DEU and U'D'E', index registers
              0083* int2hlu:
0B15C7 3E     0084* ld a,int_
0B15C8 17 
0B15C9 CD     0085* call FPP
0B15CA D2 
0B15CB 00 
0B15CC 0B 
0B15CD 7D     0086* ld a,l
0B15CE F5     0087* push af
0B15CF D9     0088* exx
0B15D0 E5     0089* push hl
0B15D1 D9     0090* exx
0B15D2 E1     0091* pop hl
0B15D3 F1     0092* pop af
0B15D4 CD     0093* call A_TO_HLU
0B15D5 B7 
0B15D6 0E 
0B15D7 0B 
0B15D8 C9     0094* ret
              0095* 
              0096* ; convert polar coordinates to cartesian coordinates as deltas from the origin
              0097* ; inputs: HLH'L'C = angle in radians
              0098* ;         DED'E'B = radius
              0099* ; outputs: HLH'L'C = dx
              0100* ;          DED'E'B = dy
              0101* polar_to_cartesian_fpp:
              0102* ; store input parameters in scratch
0B15D9 FD     0103* ld iy,@angle
0B15DA 21 
0B15DB 31 
0B15DC 16 
0B15DC 0B   
0B15DE CD     0104* call store_float_iy_nor
0B15DF 88 
0B15E0 16 
0B15E1 0B 
0B15E2 FD     0105* ld iy,@radius
0B15E3 21 
0B15E4 36 
0B15E5 16 
0B15E5 0B   
0B15E7 CD     0106* call store_float_iy_alt
0B15E8 AC 
0B15E9 16 
0B15EA 0B 
              0107* ; compute dy = sin(angle) * radius
0B15EB 3E     0108* ld a,sin
0B15EC 1D 
0B15ED CD     0109* call FPP ; HLH'L'C = sin(angle)
0B15EE D2 
0B15EF 00 
0B15F0 0B 
0B15F1 FD     0110* ld iy,@radius
0B15F2 21 
0B15F3 36 
0B15F4 16 
0B15F4 0B   
0B15F6 CD     0111* call fetch_float_iy_alt ; DED'E'B = radius
0B15F7 BE 
0B15F8 16 
0B15F9 0B 
0B15FA 3E     0112* ld a,fmul
0B15FB 0A 
0B15FC CD     0113* call FPP ; HLH'L'C = sin(angle) * radius
0B15FD D2 
0B15FE 00 
0B15FF 0B 
0B1600 FD     0114* ld iy,@scratch
0B1601 21 
0B1602 3B 
0B1603 16 
0B1603 0B   
0B1605 CD     0115* call store_float_iy_nor ; @scratch = dy
0B1606 88 
0B1607 16 
0B1608 0B 
              0116* ; compute dx = cos(angle) * radius
0B1609 FD     0117* ld iy,@angle
0B160A 21 
0B160B 31 
0B160C 16 
0B160C 0B   
0B160E CD     0118* call fetch_float_iy_nor
0B160F 9A 
0B1610 16 
0B1611 0B 
0B1612 3E     0119* ld a,cos
0B1613 14 
0B1614 CD     0120* call FPP ; HLH'L'C = cos(angle)
0B1615 D2 
0B1616 00 
0B1617 0B 
0B1618 FD     0121* ld iy,@radius
0B1619 21 
0B161A 36 
0B161B 16 
0B161B 0B   
0B161D CD     0122* call fetch_float_iy_alt ; DED'E'B = radius
0B161E BE 
0B161F 16 
0B1620 0B 
0B1621 3E     0123* ld a,fmul
0B1622 0A 
0B1623 CD     0124* call FPP ; HLH'L'C = cos(angle) * radius
0B1624 D2 
0B1625 00 
0B1626 0B 
              0125* ; restore dy from @scratch
0B1627 FD     0126* ld iy,@scratch
0B1628 21 
0B1629 3B 
0B162A 16 
0B162A 0B   
0B162C CD     0127* call fetch_float_iy_alt
0B162D BE 
0B162E 16 
0B162F 0B 
0B1630 C9     0128* ret
              0129* 
              0130* @angle: ds 5
              0131* @radius: ds 5
              0132* @scratch: ds 5
              0133* 
              0134* ; store HLH'L'C floating point number in a 40-bit buffer
              0135* ; inputs: HLH'L'C = floating point number
              0136* ;         ix = buffer address
              0137* ; outputs: buffer filled with floating point number
              0138* ; destroys: nothing
              0139* store_float_nor:
0B1640 DD     0140* ld (ix+0),c
0B1641 71 
0B1642 00 
0B1643 DD     0141* ld (ix+3),l
0B1644 75 
0B1645 03 
0B1646 DD     0142* ld (ix+4),h
0B1647 74 
0B1648 04 
0B1649 D9     0143* exx
0B164A DD     0144* ld (ix+1),l
0B164B 75 
0B164C 01 
0B164D DD     0145* ld (ix+2),h
0B164E 74 
0B164F 02 
0B1650 D9     0146* exx
0B1651 C9     0147* ret
              0148* 
              0149* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0150* ; inputs: ix = buffer address
              0151* ; outputs: HLH'L'C = floating point number
              0152* ; destroys: HLH'L'C
              0153* fetch_float_nor:
0B1652 DD     0154* ld c,(ix+0)
0B1653 4E 
0B1654 00 
0B1655 DD     0155* ld l,(ix+3)
0B1656 6E 
0B1657 03 
0B1658 DD     0156* ld h,(ix+4)
0B1659 66 
0B165A 04 
0B165B D9     0157* exx
0B165C DD     0158* ld l,(ix+1)
0B165D 6E 
0B165E 01 
0B165F DD     0159* ld h,(ix+2)
0B1660 66 
0B1661 02 
0B1662 D9     0160* exx
0B1663 C9     0161* ret
              0162* 
              0163* ; store DED'E'B floating point number in a 40-bit buffer
              0164* ; inputs: DED'E'B = floating point number
              0165* ;         ix = buffer address
              0166* ; outputs: buffer filled with floating point number
              0167* ; destroys: nothing
              0168* store_float_alt:
0B1664 DD     0169* ld (ix+0),b
0B1665 70 
0B1666 00 
0B1667 DD     0170* ld (ix+3),e
0B1668 73 
0B1669 03 
0B166A DD     0171* ld (ix+4),d
0B166B 72 
0B166C 04 
0B166D D9     0172* exx
0B166E DD     0173* ld (ix+1),e
0B166F 73 
0B1670 01 
0B1671 DD     0174* ld (ix+2),d
0B1672 72 
0B1673 02 
0B1674 D9     0175* exx
0B1675 C9     0176* ret
              0177* 
              0178* ; fetch DED'E'B floating point number from a 40-bit buffer
              0179* ; inputs: ix = buffer address
              0180* ; outputs: DED'E'B = floating point number
              0181* ; destroys: DED'E'B
              0182* fetch_float_alt:
0B1676 DD     0183* ld b,(ix+0)
0B1677 46 
0B1678 00 
0B1679 DD     0184* ld e,(ix+3)
0B167A 5E 
0B167B 03 
0B167C DD     0185* ld d,(ix+4)
0B167D 56 
0B167E 04 
0B167F D9     0186* exx
0B1680 DD     0187* ld e,(ix+1)
0B1681 5E 
0B1682 01 
0B1683 DD     0188* ld d,(ix+2)
0B1684 56 
0B1685 02 
0B1686 D9     0189* exx
0B1687 C9     0190* ret
              0191* 
              0192* 
              0193* ; store HLH'L'C floating point number in a 40-bit buffer
              0194* ; inputs: HLH'L'C = floating point number
              0195* ;         iy = buffer address
              0196* ; outputs: buffer filled with floating point number
              0197* ; destroys: nothing
              0198* store_float_iy_nor:
0B1688 FD     0199* ld (iy+0),c
0B1689 71 
0B168A 00 
0B168B FD     0200* ld (iy+3),l
0B168C 75 
0B168D 03 
0B168E FD     0201* ld (iy+4),h
0B168F 74 
0B1690 04 
0B1691 D9     0202* exx
0B1692 FD     0203* ld (iy+1),l
0B1693 75 
0B1694 01 
0B1695 FD     0204* ld (iy+2),h
0B1696 74 
0B1697 02 
0B1698 D9     0205* exx
0B1699 C9     0206* ret
              0207* 
              0208* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0209* ; inputs: iy = buffer address
              0210* ; outputs: HLH'L'C = floating point number
              0211* ; destroys: HLH'L'C
              0212* fetch_float_iy_nor:
0B169A FD     0213* ld c,(iy+0)
0B169B 4E 
0B169C 00 
0B169D FD     0214* ld l,(iy+3)
0B169E 6E 
0B169F 03 
0B16A0 FD     0215* ld h,(iy+4)
0B16A1 66 
0B16A2 04 
0B16A3 D9     0216* exx
0B16A4 FD     0217* ld l,(iy+1)
0B16A5 6E 
0B16A6 01 
0B16A7 FD     0218* ld h,(iy+2)
0B16A8 66 
0B16A9 02 
0B16AA D9     0219* exx
0B16AB C9     0220* ret
              0221* 
              0222* ; store DED'E'B floating point number in a 40-bit buffer
              0223* ; inputs: DED'E'B = floating point number
              0224* ;         iy = buffer address
              0225* ; outputs: buffer filled with floating point number
              0226* ; destroys: nothing
              0227* store_float_iy_alt:
0B16AC FD     0228* ld (iy+0),b
0B16AD 70 
0B16AE 00 
0B16AF FD     0229* ld (iy+3),e
0B16B0 73 
0B16B1 03 
0B16B2 FD     0230* ld (iy+4),d
0B16B3 72 
0B16B4 04 
0B16B5 D9     0231* exx
0B16B6 FD     0232* ld (iy+1),e
0B16B7 73 
0B16B8 01 
0B16B9 FD     0233* ld (iy+2),d
0B16BA 72 
0B16BB 02 
0B16BC D9     0234* exx
0B16BD C9     0235* ret
              0236* 
              0237* ; fetch DED'E'B floating point number from a 40-bit buffer
              0238* ; inputs: iy = buffer address
              0239* ; outputs: DED'E'B = floating point number
              0240* ; destroys: DED'E'B
              0241* fetch_float_iy_alt:
0B16BE FD     0242* ld b,(iy+0)
0B16BF 46 
0B16C0 00 
0B16C1 FD     0243* ld e,(iy+3)
0B16C2 5E 
0B16C3 03 
0B16C4 FD     0244* ld d,(iy+4)
0B16C5 56 
0B16C6 04 
0B16C7 D9     0245* exx
0B16C8 FD     0246* ld e,(iy+1)
0B16C9 5E 
0B16CA 01 
0B16CB FD     0247* ld d,(iy+2)
0B16CC 56 
0B16CD 02 
0B16CE D9     0248* exx
0B16CF C9     0249* ret
              0250* 
              0251* ; print HLH'L'C floating point number in hex format
              0252* ; inputs: HLH'L'C = floating point number
              0253* print_float_hex_nor:
              0254* PUSH_ALL
0B16D0 08    0001*M ex af,af'
0B16D1 D9    0002*M exx
0B16D2 F5    0003*M push af
0B16D3 E5    0004*M push hl
0B16D4 C5    0005*M push bc
0B16D5 D5    0006*M push de
             0007*M 
0B16D6 08    0008*M ex af,af'
0B16D7 D9    0009*M exx
0B16D8 F5    0010*M push af
0B16D9 E5    0011*M push hl
0B16DA C5    0012*M push bc
0B16DB D5    0013*M push de
0B16DC DD    0014*M push ix
0B16DD E5 
0B16DE FD    0015*M push iy
0B16DF E5 
0B16E0 CD     0255* call printHex16
0B16E1 F6 
0B16E2 0E 
0B16E3 0B 
0B16E4 3E     0256* ld a,'.'
0B16E5 2E 
0B16E6 5B     0257* rst.lil 10h
0B16E7 D7 
0B16E8 D9     0258* exx
0B16E9 CD     0259* call printHex16
0B16EA F6 
0B16EB 0E 
0B16EC 0B 
0B16ED D9     0260* exx
0B16EE 3E     0261* ld a,'^'
0B16EF 5E 
0B16F0 5B     0262* rst.lil 10h
0B16F1 D7 
0B16F2 79     0263* ld a,c
0B16F3 CD     0264* call printHex8
0B16F4 FC 
0B16F5 0E 
0B16F6 0B 
              0265* POP_ALL
0B16F7 FD    0001*M pop iy
0B16F8 E1 
0B16F9 DD    0002*M pop ix
0B16FA E1 
0B16FB D1    0003*M pop de
0B16FC C1    0004*M pop bc
0B16FD E1    0005*M pop hl
0B16FE F1    0006*M pop af
0B16FF 08    0007*M ex af,af'
0B1700 D9    0008*M exx
             0009*M 
0B1701 D1    0010*M pop de
0B1702 C1    0011*M pop bc
0B1703 E1    0012*M pop hl
0B1704 F1    0013*M pop af
0B1705 08    0014*M ex af,af'
0B1706 D9    0015*M exx
0B1707 C9     0266* ret
              0267* 
              0268* ; print DED'E'B floating point number in hex format
              0269* ; inputs: DED'E'B = floating point number
              0270* print_float_hex_alt:
              0271* PUSH_ALL
0B1708 08    0001*M ex af,af'
0B1709 D9    0002*M exx
0B170A F5    0003*M push af
0B170B E5    0004*M push hl
0B170C C5    0005*M push bc
0B170D D5    0006*M push de
             0007*M 
0B170E 08    0008*M ex af,af'
0B170F D9    0009*M exx
0B1710 F5    0010*M push af
0B1711 E5    0011*M push hl
0B1712 C5    0012*M push bc
0B1713 D5    0013*M push de
0B1714 DD    0014*M push ix
0B1715 E5 
0B1716 FD    0015*M push iy
0B1717 E5 
0B1718 EB     0272* ex de,hl
0B1719 CD     0273* call printHex16
0B171A F6 
0B171B 0E 
0B171C 0B 
0B171D EB     0274* ex de,hl
0B171E 3E     0275* ld a,'.'
0B171F 2E 
0B1720 5B     0276* rst.lil 10h
0B1721 D7 
0B1722 D9     0277* exx
0B1723 EB     0278* ex de,hl
0B1724 CD     0279* call printHex16
0B1725 F6 
0B1726 0E 
0B1727 0B 
0B1728 EB     0280* ex de,hl
0B1729 D9     0281* exx
0B172A 3E     0282* ld a,'^'
0B172B 5E 
0B172C 5B     0283* rst.lil 10h
0B172D D7 
0B172E 78     0284* ld a,b
0B172F CD     0285* call printHex8
0B1730 FC 
0B1731 0E 
0B1732 0B 
              0286* POP_ALL
0B1733 FD    0001*M pop iy
0B1734 E1 
0B1735 DD    0002*M pop ix
0B1736 E1 
0B1737 D1    0003*M pop de
0B1738 C1    0004*M pop bc
0B1739 E1    0005*M pop hl
0B173A F1    0006*M pop af
0B173B 08    0007*M ex af,af'
0B173C D9    0008*M exx
             0009*M 
0B173D D1    0010*M pop de
0B173E C1    0011*M pop bc
0B173F E1    0012*M pop hl
0B1740 F1    0013*M pop af
0B1741 08    0014*M ex af,af'
0B1742 D9    0015*M exx
0B1743 C9     0287* ret
              0288* 
              0289* print_floats_hex:
0B1744 CD     0290* call print_float_hex_nor
0B1745 D0 
0B1746 16 
0B1747 0B 
0B1748 3E     0291* ld a,' '
0B1749 20 
0B174A 5B     0292* rst.lil 10h
0B174B D7 
0B174C CD     0293* call print_float_hex_alt
0B174D 08 
0B174E 17 
0B174F 0B 
0B1750 C9     0294* ret
              0295* 
              0296* ; print a floating point number in decimal format
              0297* ; inputs: HL'H'L'C is the number to print
              0298* ; outputs: number printed to screen
              0299* ;          ACCS null-terminated string representation of the number
              0300* ; destroys: everything except ix
              0301* print_float_dec:
              0302* print_float_dec_nor:
0B1751 DD     0303* push ix             ; preserve
0B1752 E5 
              0304* 
              0305* ; back up floats in normal and alternate registers
0B1753 DD     0306* ld ix,@float_nor
0B1754 21 
0B1755 94 
0B1756 17 
0B1756 0B   
0B1758 CD     0307* call store_float_nor
0B1759 40 
0B175A 16 
0B175B 0B 
0B175C DD     0308* ld ix,@float_alt
0B175D 21 
0B175E 99 
0B175F 17 
0B175F 0B   
0B1761 CD     0309* call store_float_alt
0B1762 64 
0B1763 16 
0B1764 0B 
              0310* 
              0311* ; convert the number to a string
0B1765 11     0312* ld de,ACCS          ; point to the string accumulator
0B1766 00 
0B1767 1A 
0B1768 0B 
0B1769 DD     0313* ld ix,@G9-1         ; get the format code for the number
0B176A 21 
0B176B 91 
0B176C 17 
0B176C 0B   
0B176E CD     0314* call STR_FP         ; convert the number to a string
0B176F D1 
0B1770 08 
0B1771 0B 
0B1772 EB     0315* ex de,hl            ; point to end of the string
0B1773 36     0316* ld (hl),0           ; null-terminate the string
0B1774 00 
0B1775 21     0317* ld hl,ACCS          ; point to the string accumulator
0B1776 00 
0B1777 1A 
0B1778 0B 
0B1779 CD     0318* call printString
0B177A CE 
0B177B 0E 
0B177C 0B 
              0319* 
              0320* ; restore floats in normal and alternate registers
0B177D DD     0321* ld ix,@float_nor
0B177E 21 
0B177F 94 
0B1780 17 
0B1780 0B   
0B1782 CD     0322* call fetch_float_nor
0B1783 52 
0B1784 16 
0B1785 0B 
0B1786 DD     0323* ld ix,@float_alt
0B1787 21 
0B1788 99 
0B1789 17 
0B1789 0B   
0B178B CD     0324* call fetch_float_alt
0B178C 76 
0B178D 16 
0B178E 0B 
              0325* 
              0326* ; cleanup and go home
0B178F DD     0327* pop ix              ; restore
0B1790 E1 
0B1791 C9     0328* ret
0B1792 09     0329* @G9:			DW    9
0B1793 00 
              0330* @float_nor: ds 5
              0331* @float_alt: ds 5
              0332* 
              0333* print_float_dec_alt:
0B179E CD     0334* CALL SWAP
0B179F BF 
0B17A0 15 
0B17A1 0B 
0B17A2 CD     0335* CALL print_float_dec_nor
0B17A3 51 
0B17A4 17 
0B17A5 0B 
0B17A6 CD     0336* CALL SWAP
0B17A7 BF 
0B17A8 15 
0B17A9 0B 
0B17AA C9     0337* ret
              0338* 
              0339* ;PI - Return PI (3.14159265)
              0340* ;Result is floating-point numeric.
              0341* ;
0B17AB 11     0342* pi_alt:			LD      DE,0x490F
0B17AC 0F 
0B17AD 49 
0B17AE 00 
0B17AF D9     0343* EXX
0B17B0 11     0344* LD      DE,0xDAA2
0B17B1 A2 
0B17B2 DA 
0B17B3 00 
0B17B4 D9     0345* EXX
0B17B5 06     0346* LD      B,0x81
0B17B6 81 
0B17B7 AF     0347* XOR     A               ;NUMERIC MARKER
0B17B8 C9     0348* RET
              0349* 
              0350* ;PI - Return PI * 2 (6.28318531)
              0351* ;Result is floating-point numeric.
              0352* ;
0B17B9 11     0353* pi2_alt:		LD      DE,0x490F
0B17BA 0F 
0B17BB 49 
0B17BC 00 
0B17BD D9     0354* EXX
0B17BE 11     0355* LD      DE,0xDAA3
0B17BF A3 
0B17C0 DA 
0B17C1 00 
0B17C2 D9     0356* EXX
0B17C3 06     0357* LD      B,0x82
0B17C4 82 
0B17C5 AF     0358* XOR     A               ;NUMERIC MARKER
0B17C6 C9     0359* RET
               0172 
               0173 ; APPLICATION INCLUDES
               0174 
               0175 ; Storage for the argv array pointers
               0176 min_args: equ 2
               0177 argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B17C7 00      0178 argv_ptrs:		    BLKP	argv_ptrs_max, 0
0B17C8 00 
0B17C9 00 
0B17CA 00 
0B17CA 00   
0B17CB 00 
0B17CC 00 
0B17CD 00 
0B17CD 00   
0B17CE 00 
0B17CF 00 
0B17D0 00 
0B17D0 00   
0B17D1 00 
0B17D2 00 
0B17D3 00 
0B17D3 00   
0B17D4 00 
0B17D5 00 
0B17D6 00 
0B17D6 00   
0B17D7 00 
0B17D8 00 
0B17D9 00 
0B17D9 00   
0B17DA 00 
0B17DB 00 
0B17DC 00 
0B17DC 00   
0B17DD 00 
0B17DE 00 
0B17DF 00 
0B17DF 00   
0B17E0 00 
0B17E1 00 
0B17E2 00 
0B17E2 00   
0B17E3 00 
0B17E4 00 
0B17E5 00 
0B17E5 00   
0B17E6 00 
0B17E7 00 
0B17E8 00 
0B17E8 00   
0B17E9 00 
0B17EA 00 
0B17EB 00 
               0179 _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
               0180 
               0181 ; Storage for the arguments, ORDER MATTERS
               0182 arg1: ds 5
               0183 arg2: ds 5
               0184 
               0185 ; GLOBAL MESSAGE STRINGS
0B1804 55      0186 str_usage: ASCIZ "Usage: scratch <args>\r\n"
0B1805 73 
0B1806 61 
0B1807 67 
0B1807 65   
0B1808 3A 
0B1809 20 
0B180A 73 
0B180A 63   
0B180B 72 
0B180C 61 
0B180D 74 
0B180D 63   
0B180E 68 
0B180F 20 
0B1810 3C 
0B1810 61   
0B1811 72 
0B1812 67 
0B1813 73 
0B1813 3E   
0B1814 0D 
0B1815 0A 
0B1816 00 
0B181C 45      0187 str_error: ASCIZ "Error!\r\n"
0B181D 72 
0B181E 72 
0B181F 6F 
0B181F 72   
0B1820 21 
0B1821 0D 
0B1822 0A 
0B1822 00   
0B1825 53      0188 str_success: ASCIZ "Success!\r\n"
0B1826 75 
0B1827 63 
0B1828 63 
0B1828 65   
0B1829 73 
0B182A 73 
0B182B 21 
0B182B 0D   
0B182C 0A 
0B182D 00 
               0189 
               0190 ; ========= MAIN LOOP =========
               0191 ; The main routine
               0192 ; IXU: argv - pointer to array of parameters
               0193 ;   C: argc - number of parameters
               0194 ; Returns:
               0195 ;  HL: Error code, or 0 if OK
               0196 
               0197 _main_init:
0B1830 79      0198 ld a,c              ; how many arguments?
0B1831 FE      0199 cp min_args         ; not enough?
0B1832 02 
0B1833 30      0200 jr nc,main          ; if enough, go to main loop
0B1834 23 
0B1835 21      0201 ld hl,str_usage     ; if not enough, print usage
0B1836 04 
0B1837 18 
0B1838 0B 
0B1839 CD      0202 call printString
0B183A CE 
0B183B 0E 
0B183C 0B 
               0203 ; fall through to _main_end_error
               0204 
               0205 _main_end_error:
0B183D 21      0206 ld hl,str_error     ; print error message
0B183E 1C 
0B183F 18 
0B1840 0B 
0B1841 CD      0207 call printString
0B1842 CE 
0B1843 0E 
0B1844 0B 
0B1845 21      0208 ld hl,19            ; return error code 19
0B1846 13 
0B1847 00 
0B1848 00 
0B1849 C9      0209 ret
               0210 
               0211 ; begin BASIC-specific end code
               0212 ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B184A ED      0213 _end:			LD		SP, (_sps)		; Restore the stack pointer
0B184B 7B 
0B184C F7 
0B184D 17 
0B184D 0B   
               0214 ; fall through to _main_end_ok
               0215 ; end BASIC-specific end code
               0216 
               0217 _main_end_ok:
               0218 ; ld hl,str_success   ; print success message
               0219 ; call printString
0B184F CD      0220 call printNewLine
0B1850 E3 
0B1851 0E 
0B1852 0B 
0B1853 21      0221 ld hl,0             ; return 0 for success
0B1854 00 
0B1855 00 
0B1856 00 
0B1857 C9      0222 ret
               0223 
               0224 ; ========= BEGIN CUSTOM MAIN LOOP =========
               0225 main:
0B1858 DD      0226 ld hl,(ix)          ; get the first argument in case hl doesn't land here with it
0B1859 27 
0B185A 00 
               0227 
               0228 ; ld iy,arg1
               0229 ; call store_arg_iy_float
               0230 ; call print_float_dec
               0231 ; call printInline
               0232 ; asciz " op "
               0233 
               0234 ; ld iy,arg2
               0235 ; call store_arg_iy_float
               0236 ; call print_float_dec
               0237 ; call printInline
               0238 ; asciz " = "
               0239 
               0240 ; ld iy,arg1
               0241 ; call fetch_float_iy_nor
               0242 
               0243 ; ld iy,arg2
               0244 ; call fetch_float_iy_alt
               0245 
               0246 ; ld a,fmul
               0247 ; call FPP
               0248 ; call print_float_dec
               0249 
               0250 ; --- polar_to_cartesian_fpp ---
               0251 
0B185B CD      0252 call printInline
0B185C C7 
0B185D 0E 
0B185E 0B 
0B185F 20      0253 asciz " degrees: "
0B1860 64 
0B1861 65 
0B1862 67 
0B1862 72   
0B1863 65 
0B1864 65 
0B1865 73 
0B1865 3A   
0B1866 20 
0B1867 00 
0B186A FD      0254 ld iy,arg1
0B186B 21 
0B186C FA 
0B186D 17 
0B186D 0B   
0B186F CD      0255 call store_arg_iy_float
0B1870 E7 
0B1871 18 
0B1872 0B 
0B1873 CD      0256 call print_float_dec
0B1874 51 
0B1875 17 
0B1876 0B 
               0257 
0B1877 CD      0258 call printInline
0B1878 C7 
0B1879 0E 
0B187A 0B 
0B187B 20      0259 asciz " radians: "
0B187C 72 
0B187D 61 
0B187E 64 
0B187E 69   
0B187F 61 
0B1880 6E 
0B1881 73 
0B1881 3A   
0B1882 20 
0B1883 00 
0B1886 CD      0260 call fetch_float_iy_nor
0B1887 9A 
0B1888 16 
0B1889 0B 
0B188A 3E      0261 ld a,rad
0B188B 1B 
0B188C CD      0262 call FPP
0B188D D2 
0B188E 00 
0B188F 0B 
0B1890 CD      0263 call store_float_iy_nor
0B1891 88 
0B1892 16 
0B1893 0B 
0B1894 CD      0264 call print_float_dec
0B1895 51 
0B1896 17 
0B1897 0B 
               0265 
0B1898 CD      0266 call printInline
0B1899 C7 
0B189A 0E 
0B189B 0B 
0B189C 20      0267 asciz " radius: "
0B189D 72 
0B189E 61 
0B189F 64 
0B189F 69   
0B18A0 75 
0B18A1 73 
0B18A2 3A 
0B18A2 20   
0B18A3 00 
0B18A6 FD      0268 ld iy,arg2
0B18A7 21 
0B18A8 FF 
0B18A9 17 
0B18A9 0B   
0B18AB CD      0269 call store_arg_iy_float
0B18AC E7 
0B18AD 18 
0B18AE 0B 
0B18AF CD      0270 call fetch_float_iy_alt
0B18B0 BE 
0B18B1 16 
0B18B2 0B 
0B18B3 CD      0271 call print_float_dec_alt
0B18B4 9E 
0B18B5 17 
0B18B6 0B 
               0272 
0B18B7 FD      0273 ld iy,arg1
0B18B8 21 
0B18B9 FA 
0B18BA 17 
0B18BA 0B   
0B18BC CD      0274 call fetch_float_iy_nor
0B18BD 9A 
0B18BE 16 
0B18BF 0B 
0B18C0 CD      0275 call polar_to_cartesian_fpp
0B18C1 D9 
0B18C2 15 
0B18C3 0B 
0B18C4 CD      0276 call printNewLine
0B18C5 E3 
0B18C6 0E 
0B18C7 0B 
0B18C8 CD      0277 call print_float_dec_nor
0B18C9 51 
0B18CA 17 
0B18CB 0B 
0B18CC CD      0278 call printNewLine
0B18CD E3 
0B18CE 0E 
0B18CF 0B 
0B18D0 CD      0279 call print_float_dec_alt
0B18D1 9E 
0B18D2 17 
0B18D3 0B 
               0280 
               0281 ; --- END polar_to_cartesian_fpp ---
               0282 
               0283 ; ; --- TESTING ---
               0284 ;     ld iy,arg2
               0285 ;     call store_arg_iy_float
               0286 ;     call get_arg_float
               0287 ;     call fetch_float_iy_alt
               0288 
               0289 ;     call print_float_dec_alt
               0290 ;     call printNewLine
               0291 ;     call print_float_dec_nor
               0292 
               0293 ; ; --- END TESTING ---
               0294 
               0295 
               0296 ; ; --- DEBUGGING ---
               0297 ; ld iy,arg1
               0298 ; call store_arg_iy_float
               0299 ; call print_float_dec
               0300 ; call printInline
               0301 ; asciz " "
               0302 
               0303 ; ld iy,arg2
               0304 ; call store_arg_iy_float
               0305 ; call print_float_dec
               0306 ; call printInline
               0307 ; asciz " = "
               0308 
               0309 ; ld iy,arg1
               0310 ; call fetch_float_iy_nor
               0311 
               0312 ; ld iy,arg2
               0313 ; call fetch_float_iy_alt
               0314 
               0315 ; ld a,fmul
               0316 ; call FPP
               0317 ; call print_float_dec
               0318 
               0319 ; ; --- END DEBUGGING ---
               0320 
0B18D4 C3      0321 jp _main_end_ok     ; return success
0B18D5 4F 
0B18D6 18 
0B18D7 0B 
               0322 
               0323 ; ========== HELPER FUNCTIONS ==========
               0324 ;
               0325 ; get the next argument after ix as a floating point number
               0326 ; inputs: ix = pointer to the argument string
               0327 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0328 ; destroys: everything except iy, including prime registers
               0329 get_arg_float:
0B18D8 ED      0330 lea ix,ix+3 ; point to the next argument
0B18D9 32 
0B18DA 03 
0B18DB DD      0331 push ix ; preserve
0B18DC E5 
0B18DD DD      0332 ld ix,(ix)  ; point to argument string
0B18DE 37 
0B18DF 00 
0B18E0 CD      0333 call VAL_FP ; convert the string to a float
0B18E1 49 
0B18E2 05 
0B18E3 0B 
0B18E4 DD      0334 pop ix ; restore
0B18E5 E1 
0B18E6 C9      0335 ret ; return with the value in HLH'L'C
               0336 
               0337 ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
               0338 ; inputs: ix = pointer to the argument string
               0339 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0340 ; destroys: everything except iy, including prime registers
               0341 store_arg_iy_float:
0B18E7 ED      0342 lea ix,ix+3 ; point to the next argument
0B18E8 32 
0B18E9 03 
0B18EA DD      0343 push ix ; preserve
0B18EB E5 
0B18EC DD      0344 ld ix,(ix)  ; point to argument string
0B18ED 37 
0B18EE 00 
0B18EF CD      0345 call VAL_FP ; convert the string to a float
0B18F0 49 
0B18F1 05 
0B18F2 0B 
0B18F3 CD      0346 call store_float_iy_nor ; save the float in buffer
0B18F4 88 
0B18F5 16 
0B18F6 0B 
0B18F7 DD      0347 pop ix ; restore
0B18F8 E1 
0B18F9 C9      0348 ret ; return with the value in HLH'L'C
               0349 ;
               0350 ; get the next argument after ix as a string
               0351 ; inputs: ix = pointer to the argument string
               0352 ; outputs: HL = pointer to the argument string, ix points to the next argument
               0353 ; destroys: a, h, l, f
               0354 get_arg_text:
0B18FA ED      0355 lea ix,ix+3 ; point to the next argument
0B18FB 32 
0B18FC 03 
0B18FD DD      0356 ld hl,(ix)  ; get the argument string
0B18FE 27 
0B18FF 00 
0B1900 C9      0357 ret
               0358 ;
               0359 ; match the next argument after ix to the dispatch table at iy
               0360 ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
               0361 ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
               0362 ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
               0363 ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
               0364 ; destroys: a, hl, de, ix, iy, flags
               0365 match_next:
0B1901 ED      0366 lea ix,ix+3         ; point to the next argument
0B1902 32 
0B1903 03 
               0367 @loop:
0B1904 FD      0368 ld hl,(iy)          ; pointer argument dispatch record
0B1905 27 
0B1906 00 
               0369 sign_hlu            ; check for list terminator
0B1907 19     0001M add hl,de
0B1908 B7     0002M or a
0B1909 ED     0003M sbc hl,de
0B190A 52 
0B190B CA      0370 jp z,@no_match      ; if a=0, return error
0B190C 23 
0B190D 19 
0B190E 0B 
0B190F 23      0371 inc hl              ; skip over jp instruction
0B1910 23      0372 inc hl
0B1911 DD      0373 ld de,(ix)          ; pointer to the argument string
0B1912 17 
0B1913 00 
0B1914 CD      0374 call str_equal      ; compare the argument to the dispatch table entry
0B1915 3A 
0B1916 19 
0B1917 0B 
0B1918 CA      0375 jp z,@match         ; if equal, return success
0B1919 25 
0B191A 19 
0B191B 0B 
0B191C ED      0376 lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B191D 33 
0B191E 03 
0B191F C3      0377 jp @loop            ; and loop
0B1920 04 
0B1921 19 
0B1922 0B 
               0378 @no_match:
0B1923 3C      0379 inc a               ; no match so return a=1 and zero flag reset
0B1924 C9      0380 ret
               0381 @match:
0B1925 FD      0382 ld iy,(iy)          ; get the function pointer
0B1926 37 
0B1927 00 
0B1928 C9      0383 ret                 ; return a=0 and zero flag set
               0384 
               0385 ; same as match_next, but prints the parameter if a match is found
               0386 match_next_and_print:
0B1929 CD      0387 call match_next
0B192A 01 
0B192B 19 
0B192C 0B 
0B192D C0      0388 ret nz ; no match found
0B192E ED      0389 lea ix,ix-3
0B192F 32 
0B1930 FD 
0B1931 CD      0390 call get_arg_text ; hl points to the operator string
0B1932 FA 
0B1933 18 
0B1934 0B 
0B1935 CD      0391 call print_param
0B1936 45 
0B1937 19 
0B1938 0B 
0B1939 C9      0392 ret
               0393 
               0394 ; compare two zero-terminated strings for equality, case-sensitive
               0395 ; hl: pointer to first string, de: pointer to second string
               0396 ; returns: z if equal, nz if not equal
               0397 ; destroys: a, hl, de
               0398 str_equal:
0B193A 1A      0399 ld a,(de)           ; get the first character
0B193B BE      0400 cp (hl)             ; compare to the second character
0B193C C0      0401 ret nz              ; if not equal, return
0B193D B7      0402 or a
0B193E C8      0403 ret z               ; if equal and zero, return
0B193F 23      0404 inc hl              ; next character
0B1940 13      0405 inc de
0B1941 C3      0406 jp str_equal        ; loop until end of string
0B1942 3A 
0B1943 19 
0B1944 0B 
               0407 
               0408 ; print the parameter string pointed to by ix
               0409 ; destroys: a, hl
               0410 print_param:
0B1945 DD      0411 ld hl,(ix)          ; get the parameter pointer
0B1946 27 
0B1947 00 
0B1948 CD      0412 call printString    ; print the parameter string
0B1949 CE 
0B194A 0E 
0B194B 0B 
0B194C 3E      0413 ld a,' '            ; print a space separator
0B194D 20 
0B194E 5B      0414 rst.lil $10
0B194F D7 
0B1950 C9      0415 ret
               0416 
               0417 ; print the parameters
               0418 ; inputs: b = number of parameters, ix = pointer to the parameters
               0419 ; destroys: a, hl, bc
               0420 print_params:
0B1951 41      0421 ld b,c              ; loop counter = number of parameters
0B1952 DD      0422 push ix             ; save the pointer to the parameters
0B1953 E5 
               0423 @loop:
0B1954 C5      0424 push bc             ; save the loop counter
0B1955 CD      0425 call print_param    ; print the parameter
0B1956 45 
0B1957 19 
0B1958 0B 
0B1959 ED      0426 lea ix,ix+3         ; next parameter pointer
0B195A 32 
0B195B 03 
0B195C C1      0427 pop bc              ; get back the loop counter
0B195D 10      0428 djnz @loop          ; loop until done
0B195E F5 
0B195F DD      0429 pop ix              ; restore the pointer to the parameters
0B1960 E1 
0B1961 C9      0430 ret
               0431 
               0432 debug_print:
0B1962 CD      0433 call printNewLine
0B1963 E3 
0B1964 0E 
0B1965 0B 
0B1966 CD      0434 call dumpRegistersHexAll
0B1967 23 
0B1968 13 
0B1969 0B 
0B196A CD      0435 call printNewLine
0B196B E3 
0B196C 0E 
0B196D 0B 
0B196E C9      0436 ret
               0437 
               0438 include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
              0001* ;
              0002* ; Title:	BBC Basic Interpreter - Z80 version
              0003* ;		RAM Module for BBC Basic Interpreter
              0004* ;		For use with Version 2.0 of BBC BASIC
              0005* ;		Standard CP/M Distribution Version
              0006* ; Author:	(C) Copyright  R.T.Russell 31-12-1983
              0007* ; Modified By:	Dean Belfield
              0008* ; Created:	12/05/2023
              0009* ; Last Updated:	26/06/2023
              0010* ;
              0011* ; Modinfo:
              0012* ; 06/06/2023:	Modified to run in ADL mode
              0013* ; 26/06/2023:	Added temporary stores R0 and R1
              0014* 
              0015* ; .ASSUME	ADL = 1
              0016* 
              0017* ; DEFINE	LORAM, SPACE = ROM
              0018* ; SEGMENT LORAM
              0019* 
              0020* ; XDEF	ACCS
              0021* ; XDEF	BUFFER
              0022* ; XDEF	STAVAR
              0023* ; XDEF	DYNVAR
              0024* ; XDEF	FNPTR
              0025* ; XDEF	PROPTR
              0026* ; XDEF	PAGE_
              0027* ; XDEF	TOP
              0028* ; XDEF	LOMEM
              0029* ; XDEF 	FREE
              0030* ; XDEF	HIMEM
              0031* ; XDEF	LINENO
              0032* ; XDEF	TRACEN
              0033* ; XDEF	AUTONO
              0034* ; XDEF	ERRTRP
              0035* ; XDEF	ERRTXT
              0036* ; XDEF	DATPTR
              0037* ; XDEF	ERL
              0038* ; XDEF	ERRLIN
              0039* ; XDEF	RANDOM
              0040* ; XDEF	COUNT
              0041* ; XDEF	WIDTH
              0042* ; XDEF	ERR
              0043* ; XDEF	LISTON
              0044* ; XDEF	INCREM
              0045* 
              0046* ; XDEF	FLAGS
              0047* ; XDEF	OSWRCHPT
              0048* ; XDEF	OSWRCHCH
              0049* ; XDEF	OSWRCHFH
              0050* ; XDEF	KEYDOWN
              0051* ; XDEF	KEYASCII
              0052* ; XDEF	KEYCOUNT
              0053* 
              0054* ; XDEF	R0
              0055* ; XDEF	R1
              0056* 
              0057* ; XDEF	RAM_START
              0058* ; XDEF	RAM_END
              0059* ; XDEF	USER
              0060* 
              0061* end_binary: ;  for assemble.py to know where to truncate the binary file
0B196F FF     0062* ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
0B1970 FF 
0B1971 FF 
0B1972 FF 
0B1972 FF   
0B1973 FF 
0B1974 FF 
0B1975 FF 
0B1975 FF   
0B1976 FF 
0B1977 FF 
0B1978 FF 
0B1978 FF   
0B1979 FF 
0B197A FF 
0B197B FF 
0B197B FF   
0B197C FF 
0B197D FF 
0B197E FF 
0B197E FF   
0B197F FF 
0B1980 FF 
0B1981 FF 
0B1981 FF   
0B1982 FF 
0B1983 FF 
0B1984 FF 
0B1984 FF   
0B1985 FF 
0B1986 FF 
0B1987 FF 
0B1987 FF   
0B1988 FF 
0B1989 FF 
0B198A FF 
0B198A FF   
0B198B FF 
0B198C FF 
0B198D FF 
0B198D FF   
0B198E FF 
0B198F FF 
0B1990 FF 
0B1990 FF   
0B1991 FF 
0B1992 FF 
0B1993 FF 
0B1993 FF   
0B1994 FF 
0B1995 FF 
0B1996 FF 
0B1996 FF   
0B1997 FF 
0B1998 FF 
0B1999 FF 
0B1999 FF   
0B199A FF 
0B199B FF 
0B199C FF 
0B199C FF   
0B199D FF 
0B199E FF 
0B199F FF 
0B199F FF   
0B19A0 FF 
0B19A1 FF 
0B19A2 FF 
0B19A2 FF   
0B19A3 FF 
0B19A4 FF 
0B19A5 FF 
0B19A5 FF   
0B19A6 FF 
0B19A7 FF 
0B19A8 FF 
0B19A8 FF   
0B19A9 FF 
0B19AA FF 
0B19AB FF 
0B19AB FF   
0B19AC FF 
0B19AD FF 
0B19AE FF 
0B19AE FF   
0B19AF FF 
0B19B0 FF 
0B19B1 FF 
0B19B1 FF   
0B19B2 FF 
0B19B3 FF 
0B19B4 FF 
0B19B4 FF   
0B19B5 FF 
0B19B6 FF 
0B19B7 FF 
0B19B7 FF   
0B19B8 FF 
0B19B9 FF 
0B19BA FF 
0B19BA FF   
0B19BB FF 
0B19BC FF 
0B19BD FF 
0B19BD FF   
0B19BE FF 
0B19BF FF 
0B19C0 FF 
0B19C0 FF   
0B19C1 FF 
0B19C2 FF 
0B19C3 FF 
0B19C3 FF   
0B19C4 FF 
0B19C5 FF 
0B19C6 FF 
0B19C6 FF   
0B19C7 FF 
0B19C8 FF 
0B19C9 FF 
0B19C9 FF   
0B19CA FF 
0B19CB FF 
0B19CC FF 
0B19CC FF   
0B19CD FF 
0B19CE FF 
0B19CF FF 
0B19CF FF   
0B19D0 FF 
0B19D1 FF 
0B19D2 FF 
0B19D2 FF   
0B19D3 FF 
0B19D4 FF 
0B19D5 FF 
0B19D5 FF   
0B19D6 FF 
0B19D7 FF 
0B19D8 FF 
0B19D8 FF   
0B19D9 FF 
0B19DA FF 
0B19DB FF 
0B19DB FF   
              0063* RAM_START:
              0064* ;
0B1A00 00     0065* ACCS:           BLKB    256,0             ; String Accumulator
0B1A01 00 
0B1A02 00 
0B1A03 00 
0B1A03 00   
0B1A04 00 
0B1A05 00 
0B1A06 00 
0B1A06 00   
0B1A07 00 
0B1A08 00 
0B1A09 00 
0B1A09 00   
0B1A0A 00 
0B1A0B 00 
0B1A0C 00 
0B1A0C 00   
0B1A0D 00 
0B1A0E 00 
0B1A0F 00 
0B1A0F 00   
0B1A10 00 
0B1A11 00 
0B1A12 00 
0B1A12 00   
0B1A13 00 
0B1A14 00 
0B1A15 00 
0B1A15 00   
0B1A16 00 
0B1A17 00 
0B1A18 00 
0B1A18 00   
0B1A19 00 
0B1A1A 00 
0B1A1B 00 
0B1A1B 00   
0B1A1C 00 
0B1A1D 00 
0B1A1E 00 
0B1A1E 00   
0B1A1F 00 
0B1A20 00 
0B1A21 00 
0B1A21 00   
0B1A22 00 
0B1A23 00 
0B1A24 00 
0B1A24 00   
0B1A25 00 
0B1A26 00 
0B1A27 00 
0B1A27 00   
0B1A28 00 
0B1A29 00 
0B1A2A 00 
0B1A2A 00   
0B1A2B 00 
0B1A2C 00 
0B1A2D 00 
0B1A2D 00   
0B1A2E 00 
0B1A2F 00 
0B1A30 00 
0B1A30 00   
0B1A31 00 
0B1A32 00 
0B1A33 00 
0B1A33 00   
0B1A34 00 
0B1A35 00 
0B1A36 00 
0B1A36 00   
0B1A37 00 
0B1A38 00 
0B1A39 00 
0B1A39 00   
0B1A3A 00 
0B1A3B 00 
0B1A3C 00 
0B1A3C 00   
0B1A3D 00 
0B1A3E 00 
0B1A3F 00 
0B1A3F 00   
0B1A40 00 
0B1A41 00 
0B1A42 00 
0B1A42 00   
0B1A43 00 
0B1A44 00 
0B1A45 00 
0B1A45 00   
0B1A46 00 
0B1A47 00 
0B1A48 00 
0B1A48 00   
0B1A49 00 
0B1A4A 00 
0B1A4B 00 
0B1A4B 00   
0B1A4C 00 
0B1A4D 00 
0B1A4E 00 
0B1A4E 00   
0B1A4F 00 
0B1A50 00 
0B1A51 00 
0B1A51 00   
0B1A52 00 
0B1A53 00 
0B1A54 00 
0B1A54 00   
0B1A55 00 
0B1A56 00 
0B1A57 00 
0B1A57 00   
0B1A58 00 
0B1A59 00 
0B1A5A 00 
0B1A5A 00   
0B1A5B 00 
0B1A5C 00 
0B1A5D 00 
0B1A5D 00   
0B1A5E 00 
0B1A5F 00 
0B1A60 00 
0B1A60 00   
0B1A61 00 
0B1A62 00 
0B1A63 00 
0B1A63 00   
0B1A64 00 
0B1A65 00 
0B1A66 00 
0B1A66 00   
0B1A67 00 
0B1A68 00 
0B1A69 00 
0B1A69 00   
0B1A6A 00 
0B1A6B 00 
0B1A6C 00 
0B1A6C 00   
0B1A6D 00 
0B1A6E 00 
0B1A6F 00 
0B1A6F 00   
0B1A70 00 
0B1A71 00 
0B1A72 00 
0B1A72 00   
0B1A73 00 
0B1A74 00 
0B1A75 00 
0B1A75 00   
0B1A76 00 
0B1A77 00 
0B1A78 00 
0B1A78 00   
0B1A79 00 
0B1A7A 00 
0B1A7B 00 
0B1A7B 00   
0B1A7C 00 
0B1A7D 00 
0B1A7E 00 
0B1A7E 00   
0B1A7F 00 
0B1A80 00 
0B1A81 00 
0B1A81 00   
0B1A82 00 
0B1A83 00 
0B1A84 00 
0B1A84 00   
0B1A85 00 
0B1A86 00 
0B1A87 00 
0B1A87 00   
0B1A88 00 
0B1A89 00 
0B1A8A 00 
0B1A8A 00   
0B1A8B 00 
0B1A8C 00 
0B1A8D 00 
0B1A8D 00   
0B1A8E 00 
0B1A8F 00 
0B1A90 00 
0B1A90 00   
0B1A91 00 
0B1A92 00 
0B1A93 00 
0B1A93 00   
0B1A94 00 
0B1A95 00 
0B1A96 00 
0B1A96 00   
0B1A97 00 
0B1A98 00 
0B1A99 00 
0B1A99 00   
0B1A9A 00 
0B1A9B 00 
0B1A9C 00 
0B1A9C 00   
0B1A9D 00 
0B1A9E 00 
0B1A9F 00 
0B1A9F 00   
0B1AA0 00 
0B1AA1 00 
0B1AA2 00 
0B1AA2 00   
0B1AA3 00 
0B1AA4 00 
0B1AA5 00 
0B1AA5 00   
0B1AA6 00 
0B1AA7 00 
0B1AA8 00 
0B1AA8 00   
0B1AA9 00 
0B1AAA 00 
0B1AAB 00 
0B1AAB 00   
0B1AAC 00 
0B1AAD 00 
0B1AAE 00 
0B1AAE 00   
0B1AAF 00 
0B1AB0 00 
0B1AB1 00 
0B1AB1 00   
0B1AB2 00 
0B1AB3 00 
0B1AB4 00 
0B1AB4 00   
0B1AB5 00 
0B1AB6 00 
0B1AB7 00 
0B1AB7 00   
0B1AB8 00 
0B1AB9 00 
0B1ABA 00 
0B1ABA 00   
0B1ABB 00 
0B1ABC 00 
0B1ABD 00 
0B1ABD 00   
0B1ABE 00 
0B1ABF 00 
0B1AC0 00 
0B1B00 00     0066* BUFFER:         BLKB    256,0             ; String Input Buffer
0B1B01 00 
0B1B02 00 
0B1B03 00 
0B1B03 00   
0B1B04 00 
0B1B05 00 
0B1B06 00 
0B1B06 00   
0B1B07 00 
0B1B08 00 
0B1B09 00 
0B1B09 00   
0B1B0A 00 
0B1B0B 00 
0B1B0C 00 
0B1B0C 00   
0B1B0D 00 
0B1B0E 00 
0B1B0F 00 
0B1B0F 00   
0B1B10 00 
0B1B11 00 
0B1B12 00 
0B1B12 00   
0B1B13 00 
0B1B14 00 
0B1B15 00 
0B1B15 00   
0B1B16 00 
0B1B17 00 
0B1B18 00 
0B1B18 00   
0B1B19 00 
0B1B1A 00 
0B1B1B 00 
0B1B1B 00   
0B1B1C 00 
0B1B1D 00 
0B1B1E 00 
0B1B1E 00   
0B1B1F 00 
0B1B20 00 
0B1B21 00 
0B1B21 00   
0B1B22 00 
0B1B23 00 
0B1B24 00 
0B1B24 00   
0B1B25 00 
0B1B26 00 
0B1B27 00 
0B1B27 00   
0B1B28 00 
0B1B29 00 
0B1B2A 00 
0B1B2A 00   
0B1B2B 00 
0B1B2C 00 
0B1B2D 00 
0B1B2D 00   
0B1B2E 00 
0B1B2F 00 
0B1B30 00 
0B1B30 00   
0B1B31 00 
0B1B32 00 
0B1B33 00 
0B1B33 00   
0B1B34 00 
0B1B35 00 
0B1B36 00 
0B1B36 00   
0B1B37 00 
0B1B38 00 
0B1B39 00 
0B1B39 00   
0B1B3A 00 
0B1B3B 00 
0B1B3C 00 
0B1B3C 00   
0B1B3D 00 
0B1B3E 00 
0B1B3F 00 
0B1B3F 00   
0B1B40 00 
0B1B41 00 
0B1B42 00 
0B1B42 00   
0B1B43 00 
0B1B44 00 
0B1B45 00 
0B1B45 00   
0B1B46 00 
0B1B47 00 
0B1B48 00 
0B1B48 00   
0B1B49 00 
0B1B4A 00 
0B1B4B 00 
0B1B4B 00   
0B1B4C 00 
0B1B4D 00 
0B1B4E 00 
0B1B4E 00   
0B1B4F 00 
0B1B50 00 
0B1B51 00 
0B1B51 00   
0B1B52 00 
0B1B53 00 
0B1B54 00 
0B1B54 00   
0B1B55 00 
0B1B56 00 
0B1B57 00 
0B1B57 00   
0B1B58 00 
0B1B59 00 
0B1B5A 00 
0B1B5A 00   
0B1B5B 00 
0B1B5C 00 
0B1B5D 00 
0B1B5D 00   
0B1B5E 00 
0B1B5F 00 
0B1B60 00 
0B1B60 00   
0B1B61 00 
0B1B62 00 
0B1B63 00 
0B1B63 00   
0B1B64 00 
0B1B65 00 
0B1B66 00 
0B1B66 00   
0B1B67 00 
0B1B68 00 
0B1B69 00 
0B1B69 00   
0B1B6A 00 
0B1B6B 00 
0B1B6C 00 
0B1B6C 00   
0B1B6D 00 
0B1B6E 00 
0B1B6F 00 
0B1B6F 00   
0B1B70 00 
0B1B71 00 
0B1B72 00 
0B1B72 00   
0B1B73 00 
0B1B74 00 
0B1B75 00 
0B1B75 00   
0B1B76 00 
0B1B77 00 
0B1B78 00 
0B1B78 00   
0B1B79 00 
0B1B7A 00 
0B1B7B 00 
0B1B7B 00   
0B1B7C 00 
0B1B7D 00 
0B1B7E 00 
0B1B7E 00   
0B1B7F 00 
0B1B80 00 
0B1B81 00 
0B1B81 00   
0B1B82 00 
0B1B83 00 
0B1B84 00 
0B1B84 00   
0B1B85 00 
0B1B86 00 
0B1B87 00 
0B1B87 00   
0B1B88 00 
0B1B89 00 
0B1B8A 00 
0B1B8A 00   
0B1B8B 00 
0B1B8C 00 
0B1B8D 00 
0B1B8D 00   
0B1B8E 00 
0B1B8F 00 
0B1B90 00 
0B1B90 00   
0B1B91 00 
0B1B92 00 
0B1B93 00 
0B1B93 00   
0B1B94 00 
0B1B95 00 
0B1B96 00 
0B1B96 00   
0B1B97 00 
0B1B98 00 
0B1B99 00 
0B1B99 00   
0B1B9A 00 
0B1B9B 00 
0B1B9C 00 
0B1B9C 00   
0B1B9D 00 
0B1B9E 00 
0B1B9F 00 
0B1B9F 00   
0B1BA0 00 
0B1BA1 00 
0B1BA2 00 
0B1BA2 00   
0B1BA3 00 
0B1BA4 00 
0B1BA5 00 
0B1BA5 00   
0B1BA6 00 
0B1BA7 00 
0B1BA8 00 
0B1BA8 00   
0B1BA9 00 
0B1BAA 00 
0B1BAB 00 
0B1BAB 00   
0B1BAC 00 
0B1BAD 00 
0B1BAE 00 
0B1BAE 00   
0B1BAF 00 
0B1BB0 00 
0B1BB1 00 
0B1BB1 00   
0B1BB2 00 
0B1BB3 00 
0B1BB4 00 
0B1BB4 00   
0B1BB5 00 
0B1BB6 00 
0B1BB7 00 
0B1BB7 00   
0B1BB8 00 
0B1BB9 00 
0B1BBA 00 
0B1BBA 00   
0B1BBB 00 
0B1BBC 00 
0B1BBD 00 
0B1BBD 00   
0B1BBE 00 
0B1BBF 00 
0B1BC0 00 
0B1C00 00     0067* STAVAR:         BLKB    27*4,0            ; Static Variables
0B1C01 00 
0B1C02 00 
0B1C03 00 
0B1C03 00   
0B1C04 00 
0B1C05 00 
0B1C06 00 
0B1C06 00   
0B1C07 00 
0B1C08 00 
0B1C09 00 
0B1C09 00   
0B1C0A 00 
0B1C0B 00 
0B1C0C 00 
0B1C0C 00   
0B1C0D 00 
0B1C0E 00 
0B1C0F 00 
0B1C0F 00   
0B1C10 00 
0B1C11 00 
0B1C12 00 
0B1C12 00   
0B1C13 00 
0B1C14 00 
0B1C15 00 
0B1C15 00   
0B1C16 00 
0B1C17 00 
0B1C18 00 
0B1C18 00   
0B1C19 00 
0B1C1A 00 
0B1C1B 00 
0B1C1B 00   
0B1C1C 00 
0B1C1D 00 
0B1C1E 00 
0B1C1E 00   
0B1C1F 00 
0B1C20 00 
0B1C21 00 
0B1C21 00   
0B1C22 00 
0B1C23 00 
0B1C24 00 
0B1C24 00   
0B1C25 00 
0B1C26 00 
0B1C27 00 
0B1C27 00   
0B1C28 00 
0B1C29 00 
0B1C2A 00 
0B1C2A 00   
0B1C2B 00 
0B1C2C 00 
0B1C2D 00 
0B1C2D 00   
0B1C2E 00 
0B1C2F 00 
0B1C30 00 
0B1C30 00   
0B1C31 00 
0B1C32 00 
0B1C33 00 
0B1C33 00   
0B1C34 00 
0B1C35 00 
0B1C36 00 
0B1C36 00   
0B1C37 00 
0B1C38 00 
0B1C39 00 
0B1C39 00   
0B1C3A 00 
0B1C3B 00 
0B1C3C 00 
0B1C3C 00   
0B1C3D 00 
0B1C3E 00 
0B1C3F 00 
0B1C3F 00   
0B1C40 00 
0B1C41 00 
0B1C42 00 
0B1C42 00   
0B1C43 00 
0B1C44 00 
0B1C45 00 
0B1C45 00   
0B1C46 00 
0B1C47 00 
0B1C48 00 
0B1C48 00   
0B1C49 00 
0B1C4A 00 
0B1C4B 00 
0B1C4B 00   
0B1C4C 00 
0B1C4D 00 
0B1C4E 00 
0B1C4E 00   
0B1C4F 00 
0B1C50 00 
0B1C51 00 
0B1C6C 00     0068* DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
0B1C6D 00 
0B1C6E 00 
0B1C6F 00 
0B1C6F 00   
0B1C70 00 
0B1C71 00 
0B1C72 00 
0B1C72 00   
0B1C73 00 
0B1C74 00 
0B1C75 00 
0B1C75 00   
0B1C76 00 
0B1C77 00 
0B1C78 00 
0B1C78 00   
0B1C79 00 
0B1C7A 00 
0B1C7B 00 
0B1C7B 00   
0B1C7C 00 
0B1C7D 00 
0B1C7E 00 
0B1C7E 00   
0B1C7F 00 
0B1C80 00 
0B1C81 00 
0B1C81 00   
0B1C82 00 
0B1C83 00 
0B1C84 00 
0B1C84 00   
0B1C85 00 
0B1C86 00 
0B1C87 00 
0B1C87 00   
0B1C88 00 
0B1C89 00 
0B1C8A 00 
0B1C8A 00   
0B1C8B 00 
0B1C8C 00 
0B1C8D 00 
0B1C8D 00   
0B1C8E 00 
0B1C8F 00 
0B1C90 00 
0B1C90 00   
0B1C91 00 
0B1C92 00 
0B1C93 00 
0B1C93 00   
0B1C94 00 
0B1C95 00 
0B1C96 00 
0B1C96 00   
0B1C97 00 
0B1C98 00 
0B1C99 00 
0B1C99 00   
0B1C9A 00 
0B1C9B 00 
0B1C9C 00 
0B1C9C 00   
0B1C9D 00 
0B1C9E 00 
0B1C9F 00 
0B1C9F 00   
0B1CA0 00 
0B1CA1 00 
0B1CA2 00 
0B1CA2 00   
0B1CA3 00 
0B1CA4 00 
0B1CA5 00 
0B1CA5 00   
0B1CA6 00 
0B1CA7 00 
0B1CA8 00 
0B1CA8 00   
0B1CA9 00 
0B1CAA 00 
0B1CAB 00 
0B1CAB 00   
0B1CAC 00 
0B1CAD 00 
0B1CAE 00 
0B1CAE 00   
0B1CAF 00 
0B1CB0 00 
0B1CB1 00 
0B1CB1 00   
0B1CB2 00 
0B1CB3 00 
0B1CB4 00 
0B1CB4 00   
0B1CB5 00 
0B1CB6 00 
0B1CB7 00 
0B1CB7 00   
0B1CB8 00 
0B1CB9 00 
0B1CBA 00 
0B1CBA 00   
0B1CBB 00 
0B1CBC 00 
0B1CBD 00 
0B1CBD 00   
0B1CBE 00 
0B1CBF 00 
0B1CC0 00 
0B1CC0 00   
0B1CC1 00 
0B1CC2 00 
0B1CC3 00 
0B1CC3 00   
0B1CC4 00 
0B1CC5 00 
0B1CC6 00 
0B1CC6 00   
0B1CC7 00 
0B1CC8 00 
0B1CC9 00 
0B1CC9 00   
0B1CCA 00 
0B1CCB 00 
0B1CCC 00 
0B1CCC 00   
0B1CCD 00 
0B1CCE 00 
0B1CCF 00 
0B1CCF 00   
0B1CD0 00 
0B1CD1 00 
0B1CD2 00 
0B1CD2 00   
0B1CD3 00 
0B1CD4 00 
0B1CD5 00 
0B1CD5 00   
0B1CD6 00 
0B1CD7 00 
0B1CD8 00 
0B1CD8 00   
0B1CD9 00 
0B1CDA 00 
0B1CDB 00 
0B1CDB 00   
0B1CDC 00 
0B1CDD 00 
0B1CDE 00 
0B1CDE 00   
0B1CDF 00 
0B1CE0 00 
0B1CE1 00 
0B1CE1 00   
0B1CE2 00 
0B1CE3 00 
0B1CE4 00 
0B1CE4 00   
0B1CE5 00 
0B1D0E 00     0069* FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B1D0F 00 
0B1D10 00 
0B1D11 00     0070* PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B1D12 00 
0B1D13 00 
              0071* ;
0B1D14 00     0072* PAGE_:          BLKB    3,0               ; Start of User Program
0B1D15 00 
0B1D16 00 
0B1D17 00     0073* TOP:            BLKB    3,0               ; First Location after User Program
0B1D18 00 
0B1D19 00 
0B1D1A 00     0074* LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B1D1B 00 
0B1D1C 00 
0B1D1D 00     0075* FREE:           BLKB    3,0               ; First Free Space Byte
0B1D1E 00 
0B1D1F 00 
0B1D20 00     0076* HIMEM:          BLKB    3,0               ; First Protected Byte
0B1D21 00 
0B1D22 00 
              0077* ;
0B1D23 00     0078* LINENO:         BLKB    3,0               ; Line Number
0B1D24 00 
0B1D25 00 
0B1D26 00     0079* TRACEN:         BLKB    3,0               ; Trace Flag
0B1D27 00 
0B1D28 00 
0B1D29 00     0080* AUTONO:         BLKB    3,0               ; Auto Flag
0B1D2A 00 
0B1D2B 00 
0B1D2C 00     0081* ERRTRP:         BLKB    3,0               ; Error Trap
0B1D2D 00 
0B1D2E 00 
0B1D2F 00     0082* ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B1D30 00 
0B1D31 00     0083* DATPTR:         BLKB    2,0               ; Data Pointer
0B1D32 00 
0B1D33 00     0084* ERL:            BLKB    2,0               ; Error Line
0B1D34 00 
0B1D35 00     0085* ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B1D36 00 
0B1D37 00 
0B1D38 00     0086* RANDOM:         BLKB    5,0               ; Random Number
0B1D39 00 
0B1D3A 00 
0B1D3B 00 
0B1D3B 00   
0B1D3D 00     0087* COUNT:          BLKB    1,0               ; Print Position
0B1D3E 00     0088* WIDTH:          BLKB    1,0               ; Print Width
0B1D3F 00     0089* ERR:            BLKB    1,0               ; Error Number
0B1D40 00     0090* LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
              0091* ; - BIT 0: If set, output a space after the line number
              0092* ; - BIT 1: If set, then indent FOR/NEXT loops
              0093* ; - BIT 2: If set, then indent REPEAT/UNTIL loops
              0094* ; - BIT 3: If set, then output to buffer for *EDIT
              0095* ; OPT FLAG (top nibble)
              0096* ; - BIT 4: If set, then list whilst assembling
              0097* ; - BIT 5: If set, then assembler errors are reported
              0098* ; - BIT 6: If set, then place the code starting at address pointed to by O%
              0099* ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B1D41 00     0100* INCREM:         BLKB    1,0               ; Auto-Increment Value
              0101* ;
              0102* ; --------------------------------------------------------------------------------------------
              0103* ; BEGIN MODIFIED CODE
              0104* ; --------------------------------------------------------------------------------------------
              0105* ; Originally in equs.inc
              0106* ;
              0107* OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
              0108* PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
              0109* VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
              0110* ; --------------------------------------------------------------------------------------------
              0111* ; END MODIFIED CODE
              0112* ; --------------------------------------------------------------------------------------------
              0113* 
              0114* ; Extra Agon-implementation specific system variables
              0115* ;
0B1D42 00     0116* FLAGS:          BLKB    1,0       ; Miscellaneous flags
              0117* ; - BIT 7: Set if ESC pressed
              0118* ; - BIT 6: Set to disable ESC
0B1D43 00     0119* OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B1D44 00 
0B1D45 00     0120* OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
              0121* ; - 0: Console
              0122* ; - 1: File
0B1D46 00     0123* OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B1D47 00     0124* KEYDOWN:        BLKB    1,0       ; Keydown flag
0B1D48 00     0125* KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B1D49 00     0126* KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B1D4A 00     0127* R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B1D4B 00 
0B1D4C 00 
0B1D4D 00     0128* R1:             BLKB    3,0
0B1D4E 00 
0B1D4F 00 
              0129* 
              0130* ;
              0131* ; This must be at the end
              0132* ;
              0133* RAM_END:
0B1D50 FF     0134* ALIGN	256
0B1D51 FF 
0B1D52 FF 
0B1D53 FF 
0B1D53 FF   
0B1D54 FF 
0B1D55 FF 
0B1D56 FF 
0B1D56 FF   
0B1D57 FF 
0B1D58 FF 
0B1D59 FF 
0B1D59 FF   
0B1D5A FF 
0B1D5B FF 
0B1D5C FF 
0B1D5C FF   
0B1D5D FF 
0B1D5E FF 
0B1D5F FF 
0B1D5F FF   
0B1D60 FF 
0B1D61 FF 
0B1D62 FF 
0B1D62 FF   
0B1D63 FF 
0B1D64 FF 
0B1D65 FF 
0B1D65 FF   
0B1D66 FF 
0B1D67 FF 
0B1D68 FF 
0B1D68 FF   
0B1D69 FF 
0B1D6A FF 
0B1D6B FF 
0B1D6B FF   
0B1D6C FF 
0B1D6D FF 
0B1D6E FF 
0B1D6E FF   
0B1D6F FF 
0B1D70 FF 
0B1D71 FF 
0B1D71 FF   
0B1D72 FF 
0B1D73 FF 
0B1D74 FF 
0B1D74 FF   
0B1D75 FF 
0B1D76 FF 
0B1D77 FF 
0B1D77 FF   
0B1D78 FF 
0B1D79 FF 
0B1D7A FF 
0B1D7A FF   
0B1D7B FF 
0B1D7C FF 
0B1D7D FF 
0B1D7D FF   
0B1D7E FF 
0B1D7F FF 
0B1D80 FF 
0B1D80 FF   
0B1D81 FF 
0B1D82 FF 
0B1D83 FF 
0B1D83 FF   
0B1D84 FF 
0B1D85 FF 
0B1D86 FF 
0B1D86 FF   
0B1D87 FF 
0B1D88 FF 
0B1D89 FF 
0B1D89 FF   
0B1D8A FF 
0B1D8B FF 
0B1D8C FF 
0B1D8C FF   
0B1D8D FF 
0B1D8E FF 
0B1D8F FF 
0B1D8F FF   
0B1D90 FF 
0B1D91 FF 
0B1D92 FF 
0B1D92 FF   
0B1D93 FF 
0B1D94 FF 
0B1D95 FF 
0B1D95 FF   
0B1D96 FF 
0B1D97 FF 
0B1D98 FF 
0B1D98 FF   
0B1D99 FF 
0B1D9A FF 
0B1D9B FF 
0B1D9B FF   
0B1D9C FF 
0B1D9D FF 
0B1D9E FF 
0B1D9E FF   
0B1D9F FF 
0B1DA0 FF 
0B1DA1 FF 
0B1DA1 FF   
0B1DA2 FF 
0B1DA3 FF 
0B1DA4 FF 
0B1DA4 FF   
0B1DA5 FF 
0B1DA6 FF 
0B1DA7 FF 
0B1DA7 FF   
0B1DA8 FF 
0B1DA9 FF 
0B1DAA FF 
0B1DAA FF   
0B1DAB FF 
0B1DAC FF 
0B1DAD FF 
0B1DAD FF   
0B1DAE FF 
0B1DAF FF 
0B1DB0 FF 
0B1DB0 FF   
0B1DB1 FF 
0B1DB2 FF 
0B1DB3 FF 
0B1DB3 FF   
0B1DB4 FF 
0B1DB5 FF 
0B1DB6 FF 
0B1DB6 FF   
0B1DB7 FF 
0B1DB8 FF 
0B1DB9 FF 
0B1DB9 FF   
0B1DBA FF 
0B1DBB FF 
0B1DBC FF 
0B1DBC FF   
0B1DBD FF 
0B1DBE FF 
0B1DBF FF 
0B1DBF FF   
0B1DC0 FF 
0B1DC1 FF 
0B1DC2 FF 
0B1DC2 FF   
0B1DC3 FF 
0B1DC4 FF 
0B1DC5 FF 
0B1DC5 FF   
0B1DC6 FF 
0B1DC7 FF 
0B1DC8 FF 
0B1DC8 FF   
0B1DC9 FF 
0B1DCA FF 
0B1DCB FF 
0B1DCB FF   
0B1DCC FF 
0B1DCD FF 
0B1DCE FF 
0B1DCE FF   
0B1DCF FF 
0B1DD0 FF 
0B1DD1 FF 
0B1DD1 FF   
0B1DD2 FF 
0B1DD3 FF 
0B1DD4 FF 
              0135* USER:							; Must be aligned on a page boundary
              0136* 
