        Output     Line 
       
               0001 ;
               0002 ; Title:	flower
               0003 ; Author:	Brandon R. Gates (BeeGee747)
               0004 ; Created:	Nov. 2024
               0005 ;
               0006 ; This program draws 2D curves related to the epitrochoid family (i.e. Spirographs),
               0007 ; more generally known as roulettes. However, instead of an outer wheel rolling
               0008 ; around on an inner wheel, this algorithm can be thought of as a rotating arm whose
               0009 ; radius oscillates a set number of times per rotation, which is set by the petals parameter.
               0010 ; Unlike the Spirograph toy which plots a continuous curve, the vectors parameter determines
               0011 ; the number of points plotted per oscillation. Specifying a small number of vectors leads
               0012 ; to more angular polygonal-type curves reminiscent of string art. Also unlike the toy,
               0013 ; a shrink factor can be specified resulting in graphs which are true spirals.
               0014 ;
               0015 ; More information about epitrochoid curves can be found here:
               0016 ; https://mathcurve.com/courbes2d.gb/epitrochoid/epitrochoid.shtml
               0017 ;
               0018 ; Parameters with example values:
               0019 ; petals       = 3.03  : Number of radius oscillations per cycle.
               0020 ; vectors      = 1.98  : Number of points plotted per oscillation.
               0021 ; depth        = 0.6   : Multiplier determining the depth of the oscillation.
               0022 ; periods      = 66    : Number of full rotations.
               0023 ; shrink       = 0.8   : Multiplier determining the final radius relative to the start.
               0024 ; theta_init   = 0.0   : Starting angle of the drawing cursor relative to the origin.
               0025 ; radius_scale = 512   : Starting radius.
               0026 ;
               0027 ; ========================================
               0028 ; MOSLET INITIALIZATION CODE
               0029 ; ========================================
               0030 ;
               0031 ASSUME	ADL = 1
               0032 INCLUDE "mos_api.inc"
              0001* ;
              0002* ; Title:	AGON MOS - API for user projects
              0003* ; Author:	Dean Belfield
              0004* ; Created:	03/08/2022
              0005* ; Last Updated:	11/11/2023
              0006* ;
              0007* ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
              0008* ;
              0009* ; Modinfo:
              0010* ; 05/08/2022:	Added mos_feof
              0011* ; 09/08/2022:	Added system variables: cursorX, cursorY
              0012* ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
              0013* ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
              0014* ; 24/09/2022:	Added mos_getError, mos_mkdir
              0015* ; 13/10/2022:	Added mos_oscli
              0016* ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
              0017* ; 04/03/2023:	Added sysvar_scrpixelIndex
              0018* ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
              0019* ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
              0020* ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
              0021* ; 22/03/2023:	The VDP commands are now indexed from 0x80
              0022* ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
              0023* ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
              0024* ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
              0025* ; 19/05/2023:	Added sysvar_scrMode
              0026* ; 05/06/2023:	Added sysvar_rtcEnable
              0027* ; 03/08/2023:	Added mos_setkbvector
              0028* ; 10/08/2023:	Added mos_getkbmap
              0029* ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
              0030* ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
              0031* ;
              0032* ; VDP control (VDU 23, 0, n)
              0033* ;
              0034* vdp_gp:			EQU 	80h
              0035* vdp_keycode:		EQU 	81h
              0036* vdp_cursor:		EQU	82h
              0037* vdp_scrchar:		EQU	83h
              0038* vdp_scrpixel:		EQU	84h
              0039* vdp_audio:		EQU	85h
              0040* vdp_mode:		EQU	86h
              0041* vdp_rtc:		EQU	87h
              0042* vdp_keystate:		EQU	88h
              0043* vdp_logicalcoords:	EQU	C0h
              0044* vdp_terminalmode:	EQU	FFh
              0045* 
              0046* ; MOS high level functions
              0047* ;
              0048* mos_getkey:		EQU	00h
              0049* mos_load:		EQU	01h
              0050* mos_save:		EQU	02h
              0051* mos_cd:			EQU	03h
              0052* mos_dir:		EQU	04h
              0053* mos_del:		EQU	05h
              0054* mos_ren:		EQU	06h
              0055* mos_mkdir:		EQU	07h
              0056* mos_sysvars:		EQU	08h
              0057* mos_editline:		EQU	09h
              0058* mos_fopen:		EQU	0Ah
              0059* mos_fclose:		EQU	0Bh
              0060* mos_fgetc:		EQU	0Ch
              0061* mos_fputc:		EQU	0Dh
              0062* mos_feof:		EQU	0Eh
              0063* mos_getError:		EQU	0Fh
              0064* mos_oscli:		EQU	10h
              0065* mos_copy:		EQU	11h
              0066* mos_getrtc:		EQU	12h
              0067* mos_setrtc:		EQU	13h
              0068* mos_setintvector:	EQU	14h
              0069* mos_uopen:		EQU	15h
              0070* mos_uclose:		EQU	16h
              0071* mos_ugetc:		EQU	17h
              0072* mos_uputc:		EQU 	18h
              0073* mos_getfil:		EQU	19h
              0074* mos_fread:		EQU	1Ah
              0075* mos_fwrite:		EQU	1Bh
              0076* mos_flseek:		EQU	1Ch
              0077* mos_setkbvector:	EQU	1Dh
              0078* mos_getkbmap:		EQU	1Eh
              0079* mos_i2c_open:		EQU	1Fh
              0080* mos_i2c_close:		EQU	20h
              0081* mos_i2c_write:		EQU	21h
              0082* mos_i2c_read:		EQU	22h
              0083* 
              0084* 
              0085* ; FatFS file access functions
              0086* ;
              0087* ffs_fopen:		EQU	80h
              0088* ffs_fclose:		EQU	81h
              0089* ffs_fread:		EQU	82h
              0090* ffs_fwrite:		EQU	83h
              0091* ffs_flseek:		EQU	84h
              0092* ffs_ftruncate:		EQU	85h
              0093* ffs_fsync:		EQU	86h
              0094* ffs_fforward:		EQU	87h
              0095* ffs_fexpand:		EQU	88h
              0096* ffs_fgets:		EQU	89h
              0097* ffs_fputc:		EQU	8Ah
              0098* ffs_fputs:		EQU	8Bh
              0099* ffs_fprintf:		EQU	8Ch
              0100* ffs_ftell:		EQU	8Dh
              0101* ffs_feof:		EQU	8Eh
              0102* ffs_fsize:		EQU	8Fh
              0103* ffs_ferror:		EQU	90h
              0104* 
              0105* ; FatFS directory access functions
              0106* ;
              0107* ffs_dopen:		EQU	91h
              0108* ffs_dclose:		EQU	92h
              0109* ffs_dread:		EQU	93h
              0110* ffs_dfindfirst:		EQU	94h
              0111* ffs_dfindnext:		EQU	95h
              0112* 
              0113* ; FatFS file and directory management functions
              0114* ;
              0115* ffs_stat:		EQU	96h
              0116* ffs_unlink:		EQU	97h
              0117* ffs_rename:		EQU	98h
              0118* ffs_chmod:		EQU	99h
              0119* ffs_utime:		EQU	9Ah
              0120* ffs_mkdir:		EQU	9Bh
              0121* ffs_chdir:		EQU	9Ch
              0122* ffs_chdrive:		EQU	9Dh
              0123* ffs_getcwd:		EQU	9Eh
              0124* 
              0125* ; FatFS volume management and system configuration functions
              0126* ;
              0127* ffs_mount:		EQU	9Fh
              0128* ffs_mkfs:		EQU	A0h
              0129* ffs_fdisk:		EQU	A1h
              0130* ffs_getfree:		EQU	A2h
              0131* ffs_getlabel:		EQU	A3h
              0132* ffs_setlabel:		EQU	A4h
              0133* ffs_setcp:		EQU	A5h
              0134* 
              0135* ; File access modes
              0136* ;
              0137* fa_read:		EQU	01h
              0138* fa_write:		EQU	02h
              0139* fa_open_existing:	EQU	00h
              0140* fa_create_new:		EQU	04h
              0141* fa_create_always:	EQU	08h
              0142* fa_open_always:		EQU	10h
              0143* fa_open_append:		EQU	30h
              0144* 
              0145* ; System variable indexes for api_sysvars
              0146* ; Index into _sysvars in globals.asm
              0147* ;
              0148* sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
              0149* sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
              0150* sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
              0151* sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
              0152* sysvar_cursorX:		EQU	07h	; 1: Cursor X position
              0153* sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
              0154* sysvar_scrchar:		EQU	09h	; 1: Character read from screen
              0155* sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
              0156* sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
              0157* sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
              0158* sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
              0159* sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
              0160* sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
              0161* sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
              0162* sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
              0163* sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
              0164* sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
              0165* sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
              0166* sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
              0167* sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
              0168* sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
              0169* sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
              0170* sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
              0171* sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
              0172* sysvar_scrMode:		EQU	27h	; 1: Screen mode
              0173* sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
              0174* sysvar_mouseX:		EQU	29h	; 2: Mouse X position
              0175* sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
              0176* sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
              0177* sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
              0178* sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
              0179* sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
              0180* ;
              0181* ; Flags for the VPD protocol
              0182* ;
              0183* vdp_pflag_cursor:	EQU	00000001b
              0184* vdp_pflag_scrchar:	EQU	00000010b
              0185* vdp_pflag_point:	EQU	00000100b
              0186* vdp_pflag_audio:	EQU	00001000b
              0187* vdp_pflag_mode:		EQU	00010000b
              0188* vdp_pflag_rtc:		EQU	00100000b
              0189* vdp_pflag_mouse:	EQU	01000000b
              0190* ; vdp_pflag_buffered:	EQU	10000000b
              0191* 
              0192* 
              0193* ; FatFS structures
              0194* ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
              0195* ;
              0196* ; Object ID and allocation information (FFOBJID)
              0197* FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
              0198* FFOBJID.id:       EQU 3    ; Hosting volume mount ID
              0199* FFOBJID.attr:     EQU 5    ; Object attribute
              0200* FFOBJID.stat:     EQU 6    ; Object chain status
              0201* FFOBJID.sclust:   EQU 7    ; Object data start cluster
              0202* FFOBJID.objsize:  EQU 11   ; Object size
              0203* FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
              0204* ;
              0205* ; File object structure (FIL)
              0206* ;
              0207* FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0208* FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
              0209* FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
              0210* FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
              0211* FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
              0212* FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
              0213* FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
              0214* FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
              0215* FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
              0216* ;
              0217* ; Directory object structure (DIR)
              0218* ;
              0219* DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0220* DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
              0221* DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
              0222* DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
              0223* DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
              0224* DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
              0225* DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
              0226* DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
              0227* ;
              0228* ; File information structure (FILINFO)
              0229* ;
              0230* FILINFO.fsize:    EQU 0    ; File size
              0231* FILINFO.fdate:    EQU 4    ; Modified date
              0232* FILINFO.ftime:    EQU 6    ; Modified time
              0233* FILINFO.fattrib:  EQU 8    ; File attribute
              0234* FILINFO.altname:  EQU 9    ; Alternative file name
              0235* FILINFO.fname:    EQU 22   ; Primary file name
              0236* FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
              0237* ;
              0238* ; Macro for calling the API
              0239* ; Parameters:
              0240* ; - function: One of the function numbers listed above
              0241* ;
              0242* MACRO MOSCALL	function
              0243* LD	A, function
              0244* RST.LIS	08h
              0245* ENDMACRO
               0033 ORG 0x0B0000 ; Is a moslet
               0034 
               0035 MACRO PROGNAME
               0036 ASCIZ "flower"
               0037 ENDMACRO
               0038 ;
               0039 ; Start in ADL mode
               0040 ;
0B0000 C3      0041 JP	_start
0B0001 45 
0B0002 00 
0B0003 0B 
               0042 ;
               0043 ; The header stuff is from byte 64 onwards
               0044 ;
               0045 _exec_name:
               0046 PROGNAME			; The executable name, only used in argv
0B0004 66     0001M ASCIZ "flower"
0B0005 6C 
0B0006 6F 
0B0007 77 
0B0007 65   
0B0008 72 
0B0009 00 
               0047 
0B000B FF      0048 ALIGN	64
0B000C FF 
0B000D FF 
0B000E FF 
0B000E FF   
0B000F FF 
0B0010 FF 
0B0011 FF 
0B0011 FF   
0B0012 FF 
0B0013 FF 
0B0014 FF 
0B0014 FF   
0B0015 FF 
0B0016 FF 
0B0017 FF 
0B0017 FF   
0B0018 FF 
0B0019 FF 
0B001A FF 
0B001A FF   
0B001B FF 
0B001C FF 
0B001D FF 
0B001D FF   
0B001E FF 
0B001F FF 
0B0020 FF 
0B0020 FF   
0B0021 FF 
0B0022 FF 
0B0023 FF 
0B0023 FF   
0B0024 FF 
0B0025 FF 
0B0026 FF 
0B0026 FF   
0B0027 FF 
0B0028 FF 
0B0029 FF 
0B0029 FF   
0B002A FF 
0B002B FF 
0B002C FF 
0B002C FF   
0B002D FF 
0B002E FF 
0B002F FF 
0B002F FF   
0B0030 FF 
0B0031 FF 
0B0032 FF 
0B0032 FF   
               0049 
0B0040 4D      0050 DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0041 4F 
0B0042 53 
0B0043 00      0051 DB	00h			; MOS header version 0
0B0044 01      0052 DB	01h			; Flag for run mode (0: Z80, 1: ADL)
               0053 ;
               0054 ; And the code follows on immediately after the header
               0055 ;
               0056 _start:
0B0045 F5      0057 PUSH	AF			; Preserve the registers
0B0046 C5      0058 PUSH	BC
0B0047 D5      0059 PUSH	DE
0B0048 DD      0060 PUSH	IX
0B0049 E5 
0B004A FD      0061 PUSH	IY
0B004B E5 
0B004C ED      0062 LD	A, MB			; Save MB
0B004D 6E 
0B004E F5      0063 PUSH 	AF
0B004F AF      0064 XOR 	A
0B0050 ED      0065 LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0051 6D 
               0066 
0B0052 CD      0067 CALL		_clear_ram ; Clear the BASIC memory allocation
0B0053 BD 
0B0054 00 
0B0055 0B 
               0068 
0B0056 DD      0069 LD	IX, argv_ptrs		; The argv array pointer address
0B0057 21 
0B0058 AE 
0B0059 1C 
0B0059 0B   
0B005B DD      0070 PUSH	IX
0B005C E5 
0B005D CD      0071 CALL	_parse_params		; Parse the parameters
0B005E 74 
0B005F 00 
0B0060 0B 
0B0061 DD      0072 POP	IX			; IX: argv
0B0062 E1 
0B0063 06      0073 LD	B, 0			;  C: argc
0B0064 00 
0B0065 CD      0074 CALL	_main_init			; Start user code
0B0066 71 
0B0067 1D 
0B0068 0B 
               0075 
0B0069 F1      0076 POP 	AF
0B006A ED      0077 LD	MB, A
0B006B 6D 
0B006C FD      0078 POP	IY			; Restore registers
0B006D E1 
0B006E DD      0079 POP	IX
0B006F E1 
0B0070 D1      0080 POP	DE
0B0071 C1      0081 POP	BC
0B0072 F1      0082 POP	AF
0B0073 C9      0083 RET
               0084 
               0085 ; Parse the parameter string into a C array
               0086 ; Parameters
               0087 ; - HL: Address of parameter string
               0088 ; - IX: Address for array pointer storage
               0089 ; Returns:
               0090 ; -  C: Number of parameters parsed
               0091 ;
0B0074 01      0092 _parse_params:		LD	BC, _exec_name
0B0075 04 
0B0076 00 
0B0077 0B 
0B0078 DD      0093 LD	(IX+0), BC		; ARGV[0] = the executable name
0B0079 0F 
0B007A 00 
0B007B ED      0094 LEA     IX, IX+3
0B007C 32 
0B007D 03 
0B007E CD      0095 CALL	_skip_spaces		; Skip HL past any leading spaces
0B007F B6 
0B0080 00 
0B0081 0B 
               0096 ;
0B0082 01      0097 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0083 01 
0B0084 00 
0B0085 00 
0B0086 06      0098 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0087 0F 
               0099 ;
               0100 _parse_params_1:
0B0088 C5      0101 PUSH	BC			; Stack ARGC
0B0089 E5      0102 PUSH	HL			; Stack start address of token
0B008A CD      0103 CALL	_get_token		; Get the next token
0B008B A7 
0B008C 00 
0B008D 0B 
0B008E 79      0104 LD	A, C			; A: Length of the token in characters
0B008F D1      0105 POP	DE			; Start address of token (was in HL)
0B0090 C1      0106 POP	BC			; ARGC
0B0091 B7      0107 OR	A			; Check for A=0 (no token found) OR at end of string
0B0092 C8      0108 RET	Z
               0109 ;
0B0093 DD      0110 LD	(IX+0), DE		; Store the pointer to the token
0B0094 1F 
0B0095 00 
0B0096 E5      0111 PUSH	HL			; DE=HL
0B0097 D1      0112 POP	DE
0B0098 CD      0113 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0099 B6 
0B009A 00 
0B009B 0B 
0B009C AF      0114 XOR	A
0B009D 12      0115 LD	(DE), A			; Zero-terminate the token
0B009E ED      0116 LEA  	IX, IX+3			; Advance to next pointer position
0B009F 32 
0B00A0 03 
0B00A1 0C      0117 INC	C			; Increment ARGC
0B00A2 79      0118 LD	A, C			; Check for C >= A
0B00A3 B8      0119 CP	B
0B00A4 38      0120 JR	C, _parse_params_1	; And loop
0B00A5 E2 
0B00A6 C9      0121 RET
               0122 
               0123 ; Get the next token
               0124 ; Parameters:
               0125 ; - HL: Address of parameter string
               0126 ; Returns:
               0127 ; - HL: Address of first character after token
               0128 ; -  C: Length of token (in characters)
               0129 ;
0B00A7 0E      0130 _get_token:		LD	C, 0			; Initialise length
0B00A8 00 
0B00A9 7E      0131 @@:			LD	A, (HL)			; Get the character from the parameter string
0B00AA B7      0132 OR	A			; Exit if 0 (end of parameter string in MOS)
0B00AB C8      0133 RET 	Z
0B00AC FE      0134 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AD 0D 
0B00AE C8      0135 RET	Z
0B00AF FE      0136 CP	' '			; Exit if space (end of token)
0B00B0 20 
0B00B1 C8      0137 RET	Z
0B00B2 23      0138 INC	HL			; Advance to next character
0B00B3 0C      0139 INC 	C			; Increment length
0B00B4 18      0140 JR	@B
0B00B5 F3 
               0141 
               0142 ; Skip spaces in the parameter string
               0143 ; Parameters:
               0144 ; - HL: Address of parameter string
               0145 ; Returns:
               0146 ; - HL: Address of next none-space character
               0147 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0148 ;
0B00B6 7E      0149 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B7 FE      0150 CP	' '			; Exit if not space
0B00B8 20 
0B00B9 C0      0151 RET	NZ
0B00BA 23      0152 INC	HL			; Advance to next character
0B00BB 18      0153 JR	_skip_spaces		; Increment length
0B00BC F9 
               0154 
               0155 ; ========================================
               0156 ; BASIC INITIALIZATION CODE FROM basic/init.asm
               0157 ; ========================================
               0158 ;
               0159 ;Clear the application memory
               0160 ;
               0161 _clear_ram:
0B00BD E5      0162 push hl
0B00BE C5      0163 PUSH		BC
0B00BF 21      0164 LD		HL, RAM_START
0B00C0 00 
0B00C1 22 
0B00C2 0B 
0B00C3 11      0165 LD		DE, RAM_START + 1
0B00C4 01 
0B00C5 22 
0B00C6 0B 
0B00C7 01      0166 LD		BC, RAM_END - RAM_START - 1
0B00C8 4F 
0B00C9 03 
0B00CA 00 
0B00CB AF      0167 XOR		A
0B00CC 77      0168 LD		(HL), A
0B00CD ED      0169 LDIR
0B00CE B0 
0B00CF C1      0170 POP		BC
0B00D0 E1      0171 pop hl
0B00D1 C9      0172 RET
               0173 
               0174 ; ========================================
               0175 ; BEGIN APPLICATION CODE
               0176 ; ========================================
               0177 
               0178 ; API INCLUDES
               0179 include "basic/fpp.asm"
              0001* ;
              0002* ; Title:	BBC Basic Interpreter - Z80 version
              0003* ;		Z80 Floating Point Package
              0004* ; Author:	(C) Copyright  R.T.Russell  1986
              0005* ; Modified By:	Dean Belfield
              0006* ; Created:	03/05/2022
              0007* ; Last Updated:	07/06/2023
              0008* ;
              0009* ; Modinfo:
              0010* ; 26/10/1986:	Version 0.0
              0011* ; 14/12/1988:	Vesion 0.1 (Bug Fix)
              0012* ; 12/05/2023:	Modified by Dean Belfield
              0013* ; 07/06/2023:	Modified to run in ADL mode
              0014* 
              0015* ; .ASSUME	ADL = 1
              0016* 
              0017* ; SEGMENT CODE
              0018* 
              0019* ; XDEF	FPP
              0020* ; XDEF	DLOAD5
              0021* ; XDEF	DLOAD5_SPL
              0022* ;
              0023* ;BINARY FLOATING POINT REPRESENTATION:
              0024* ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
              0025* ;    8 BIT EXCESS-128 SIGNED EXPONENT
              0026* ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
              0027* ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
              0028* ;
              0029* ;BINARY INTEGER REPRESENTATION:
              0030* ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
              0031* ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
              0032* ;
              0033* ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
              0034* ;                            EXPONENT - C
              0035* ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
              0036* ;                               EXPONENT - B
              0037* 
              0038* ;
              0039* ;Error codes:
              0040* ;
              0041* 
              0042* BADOP:			EQU     1               ;Bad operation code
              0043* DIVBY0:			EQU     18              ;Division by zero
              0044* TOOBIG_FP:			EQU     20              ;Too big
              0045* NGROOT:			EQU     21              ;Negative root
              0046* LOGRNG:			EQU     22              ;Log range
              0047* ACLOST:			EQU     23              ;Accuracy lost
              0048* EXPRNG:			EQU     24              ;Exp range
              0049* ;
              0050* ;Call entry and despatch code:
              0051* ;
0B00D2 FD     0052* FPP:			PUSH    IY              ;Save IY
0B00D3 E5 
0B00D4 FD     0053* LD      IY,0
0B00D5 21 
0B00D6 00 
0B00D7 00 
0B00D7 00   
0B00D9 FD     0054* ADD     IY,SP           ;Save SP in IY
0B00DA 39 
0B00DB CD     0055* CALL    OP              ;Perform operation
0B00DC EB 
0B00DD 00 
0B00DE 0B 
0B00DF BF     0056* CP      A               ;Good return (Z, NC)
0B00E0 FD     0057* EXIT_FP_:			POP     IY              ;Restore IY
0B00E1 E1 
0B00E2 C9     0058* RET                     ;Return to caller
              0059* ;
              0060* ;Error exit:
              0061* ;
0B00E3 3E     0062* BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B00E4 01 
0B00E5 FD     0063* ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B00E6 F9 
0B00E7 B7     0064* OR      A               ;Set NZ
0B00E8 37     0065* SCF                     ;Set C
0B00E9 18     0066* JR      EXIT_FP_
0B00EA F5 
              0067* ;
              0068* ;Perform operation or function:
              0069* ;
              0070* ; OP:			CP      (RTABLE-DTABLE)/3
0B00EB FE     0071* OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B00EC 2A 
              0072* 
0B00ED 30     0073* JR      NC,BAD_FP
0B00EE F4 
              0074* ; CP      (FTABLE-DTABLE)/3
0B00EF FE     0075* CP      FTABLE-DTABLE/3 ; ditto
0B00F0 10 
0B00F1 30     0076* JR      NC,DISPAT_FP
0B00F2 08 
0B00F3 08     0077* EX      AF,AF'
0B00F4 78     0078* LD      A,B
0B00F5 B1     0079* OR      C               ;Both integer?
0B00F6 C4     0080* CALL    NZ,FLOATA       ;No, so float both
0B00F7 FE 
0B00F8 0B 
0B00F9 0B 
0B00FA 08     0081* EX      AF,AF'
0B00FB E5     0082* DISPAT_FP:			PUSH    HL
0B00FC 21     0083* LD      HL,DTABLE
0B00FD 0E 
0B00FE 01 
0B00FF 0B 
0B0100 C5     0084* PUSH    BC
0B0101 01     0085* LD	BC, 3		; C = 3
0B0102 03 
0B0103 00 
0B0104 00 
0B0105 47     0086* LD	B, A 		; B = op-code
0B0106 ED     0087* MLT 	BC 		;BC = op-code * 3
0B0107 4C 
0B0108 09     0088* ADD	HL, BC 		;Add to table base
0B0109 ED     0089* LD	HL, (HL)	;Get the routine address (24-bit)
0B010A 27 
              0090* 
              0091* ;        		ADD     A, A            ;A = op-code * 2
              0092* ;        		LD      C,A
              0093* ;        		LD      B,0             ;BC = op-code * 2
              0094* ;        		ADD     HL,BC
              0095* ;        		LD      A,(HL)          ;Get low byte
              0096* ;        		INC     HL
              0097* ;        		LD      H,(HL)          ;Get high byte
              0098* ;        		LD      L,A
              0099* 
0B010B C1     0100* POP     BC
0B010C E3     0101* EX      (SP),HL
0B010D C9     0102* RET                     ;Off to routine
              0103* ;
              0104* ;Despatch table:
              0105* ;
0B010E C0     0106* DTABLE:			DW24  IAND            ;AND (INTEGER)
0B010F 01 
0B0110 0B 
0B0111 2E     0107* DW24  IBDIV           ;DIV
0B0112 02 
0B0113 0B 
0B0114 D3     0108* DW24  IEOR            ;EOR
0B0115 01 
0B0116 0B 
0B0117 F9     0109* DW24  IMOD            ;MOD
0B0118 01 
0B0119 0B 
0B011A E6     0110* DW24  IOR             ;OR
0B011B 01 
0B011C 0B 
0B011D B4     0111* DW24  ILE             ;<=
0B011E 04 
0B011F 0B 
0B0120 C3     0112* DW24  INE             ;<>
0B0121 04 
0B0122 0B 
0B0123 A7     0113* DW24  IGE             ;>=
0B0124 04 
0B0125 0B 
0B0126 8C     0114* DW24  ILT             ;<
0B0127 04 
0B0128 0B 
0B0129 D0     0115* DW24  IEQ             ;=
0B012A 04 
0B012B 0B 
0B012C 1C     0116* DW24  IMUL            ;*
0B012D 03 
0B012E 0B 
0B012F 57     0117* DW24  IADD            ;+
0B0130 02 
0B0131 0B 
0B0132 99     0118* DW24  IGT             ;>
0B0133 04 
0B0134 0B 
0B0135 3E     0119* DW24  ISUB            ;-
0B0136 02 
0B0137 0B 
0B0138 D3     0120* DW24  IPOW            ;^
0B0139 03 
0B013A 0B 
0B013B C9     0121* DW24  IDIV            ;/
0B013C 02 
0B013D 0B 
              0122* ;
              0123* FTABLE:
0B013E E2     0124* DW24  ABSV_FP            ;ABS
0B013F 04 
0B0140 0B 
0B0141 C8     0125* DW24  ACS_FP             ;ACS
0B0142 08 
0B0143 0B 
0B0144 06     0126* DW24  ASN_FP             ;ASN
0B0145 08 
0B0146 0B 
0B0147 36     0127* DW24  ATN_FP             ;ATN
0B0148 08 
0B0149 0B 
0B014A 01     0128* DW24  COS_FP             ;COS
0B014B 06 
0B014C 0B 
0B014D 10     0129* DW24  DEG_FP             ;DEG
0B014E 05 
0B014F 0B 
0B0150 BD     0130* DW24  EXP_FP             ;EXP
0B0151 06 
0B0152 0B 
0B0153 64     0131* DW24  INT_FP_            ;INT
0B0154 05 
0B0155 0B 
0B0156 5B     0132* DW24  LN_FP              ;LN
0B0157 07 
0B0158 0B 
0B0159 F0     0133* DW24  LOG_FP             ;LOG
0B015A 07 
0B015B 0B 
0B015C EE     0134* DW24  NOTK_FP            ;NOT
0B015D 04 
0B015E 0B 
0B015F 1A     0135* DW24  RAD_FP             ;RAD
0B0160 05 
0B0161 0B 
0B0162 35     0136* DW24  SGN_FP             ;SGN
0B0163 05 
0B0164 0B 
0B0165 0E     0137* DW24  SIN_FP             ;SIN
0B0166 06 
0B0167 0B 
0B0168 7D     0138* DW24  SQR_FP             ;SQR
0B0169 05 
0B016A 0B 
0B016B DB     0139* DW24  TAN_FP             ;TAN
0B016C 05 
0B016D 0B 
              0140* ;
0B016E 8B     0141* DW24  ZERO_FP            ;ZERO
0B016F 0C 
0B0170 0B 
0B0171 96     0142* DW24  FONE_FP            ;FONE
0B0172 06 
0B0173 0B 
0B0174 D5     0143* DW24  TRUE_FP            ;TRUE
0B0175 04 
0B0176 0B 
0B0177 02     0144* DW24  PI_FP              ;PI
0B0178 05 
0B0179 0B 
              0145* ;
0B017A 49     0146* DW24  VAL_FP             ;VAL
0B017B 05 
0B017C 0B 
0B017D D1     0147* DW24  STR_FP             ;STR$
0B017E 08 
0B017F 0B 
              0148* ;
0B0180 32     0149* DW24  SFIX_FP            ;FIX
0B0181 0B 
0B0182 0B 
0B0183 0E     0150* DW24  SFLOAT_FP          ;FLOAT
0B0184 0C 
0B0185 0B 
              0151* ;
0B0186 5C     0152* DW24  FTEST_FP           ;TEST
0B0187 0C 
0B0188 0B 
0B0189 6E     0153* DW24  FCOMP_FP           ;COMPARE
0B018A 0C 
0B018B 0B 
              0154* ;
0B018C BC     0155* RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B018D 01 
0B018E 0B 
0B018F 2A     0156* DW24  FBDIV           ;DIV
0B0190 02 
0B0191 0B 
0B0192 CF     0157* DW24  FEOR            ;EOR
0B0193 01 
0B0194 0B 
0B0195 F5     0158* DW24  FMOD            ;MOD
0B0196 01 
0B0197 0B 
0B0198 E2     0159* DW24  FFOR             ;OR
0B0199 01 
0B019A 0B 
0B019B AE     0160* DW24  FLE             ;<=
0B019C 04 
0B019D 0B 
0B019E BD     0161* DW24  FNE             ;<>
0B019F 04 
0B01A0 0B 
0B01A1 A1     0162* DW24  FGE             ;>=
0B01A2 04 
0B01A3 0B 
0B01A4 86     0163* DW24  FLT             ;<
0B01A5 04 
0B01A6 0B 
0B01A7 CA     0164* DW24  FEQ             ;=
0B01A8 04 
0B01A9 0B 
0B01AA 76     0165* DW24  FMUL            ;*
0B01AB 03 
0B01AC 0B 
0B01AD 64     0166* DW24  FADD            ;+
0B01AE 02 
0B01AF 0B 
0B01B0 93     0167* DW24  FGT             ;>
0B01B1 04 
0B01B2 0B 
0B01B3 4B     0168* DW24  FSUB            ;-
0B01B4 02 
0B01B5 0B 
0B01B6 53     0169* DW24  FPOW            ;^
0B01B7 04 
0B01B8 0B 
0B01B9 CD     0170* DW24  FDIV            ;/
0B01BA 02 
0B01BB 0B 
              0171* ;
              0172* ;       PAGE
              0173* ;
              0174* ;ARITHMETIC AND LOGICAL OPERATORS:
              0175* ;All take two arguments, in HLH'L'C & DED'E'B.
              0176* ;Output in HLH'L'C
              0177* ;All registers except IX, IY destroyed.
              0178* ; (N.B. FPOW destroys IX).
              0179* ;
              0180* ;FAND - Floating-point AND.
              0181* ;IAND - Integer AND.
              0182* ;
0B01BC CD     0183* FAND:			CALL    FIX2
0B01BD 26 
0B01BE 0B 
0B01BF 0B 
0B01C0 7C     0184* IAND:			LD      A,H
0B01C1 A2     0185* AND     D
0B01C2 67     0186* LD      H,A
0B01C3 7D     0187* LD      A,L
0B01C4 A3     0188* AND     E
0B01C5 6F     0189* LD      L,A
0B01C6 D9     0190* EXX
0B01C7 7C     0191* LD      A,H
0B01C8 A2     0192* AND     D
0B01C9 67     0193* LD      H,A
0B01CA 7D     0194* LD      A,L
0B01CB A3     0195* AND     E
0B01CC 6F     0196* LD      L,A
0B01CD D9     0197* EXX
0B01CE C9     0198* RET
              0199* ;
              0200* ;FEOR - Floating-point exclusive-OR.
              0201* ;IEOR - Integer exclusive-OR.
              0202* ;
0B01CF CD     0203* FEOR:			CALL    FIX2
0B01D0 26 
0B01D1 0B 
0B01D2 0B 
0B01D3 7C     0204* IEOR:			LD      A,H
0B01D4 AA     0205* XOR     D
0B01D5 67     0206* LD      H,A
0B01D6 7D     0207* LD      A,L
0B01D7 AB     0208* XOR     E
0B01D8 6F     0209* LD      L,A
0B01D9 D9     0210* EXX
0B01DA 7C     0211* LD      A,H
0B01DB AA     0212* XOR     D
0B01DC 67     0213* LD      H,A
0B01DD 7D     0214* LD      A,L
0B01DE AB     0215* XOR     E
0B01DF 6F     0216* LD      L,A
0B01E0 D9     0217* EXX
0B01E1 C9     0218* RET
              0219* ;
              0220* ;FOR - Floating-point OR.
              0221* ;IOR - Integer OR.
              0222* ;
0B01E2 CD     0223* FFOR:			CALL    FIX2
0B01E3 26 
0B01E4 0B 
0B01E5 0B 
0B01E6 7C     0224* IOR:			LD      A,H
0B01E7 B2     0225* OR      D
0B01E8 67     0226* LD      H,A
0B01E9 7D     0227* LD      A,L
0B01EA B3     0228* OR      E
0B01EB 6F     0229* LD      L,A
0B01EC D9     0230* EXX
0B01ED 7C     0231* LD      A,H
0B01EE B2     0232* OR      D
0B01EF 67     0233* LD      H,A
0B01F0 7D     0234* LD      A,L
0B01F1 B3     0235* OR      E
0B01F2 6F     0236* LD      L,A
0B01F3 D9     0237* EXX
0B01F4 C9     0238* RET
              0239* ;
              0240* ;FMOD - Floating-point remainder.
              0241* ;IMOD - Integer remainder.
              0242* ;
0B01F5 CD     0243* FMOD:			CALL    FIX2
0B01F6 26 
0B01F7 0B 
0B01F8 0B 
0B01F9 7C     0244* IMOD:			LD      A,H
0B01FA AA     0245* XOR     D               ;DIV RESULT SIGN
0B01FB CB     0246* BIT     7,H
0B01FC 7C 
0B01FD 08     0247* EX      AF,AF'
0B01FE CB     0248* BIT     7,H
0B01FF 7C 
0B0200 C4     0249* CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B0201 42 
0B0202 0B 
0B0203 0B 
0B0204 CD     0250* CALL    SWAP_FP
0B0205 3F 
0B0206 0C 
0B0207 0B 
0B0208 CB     0251* BIT     7,H
0B0209 7C 
0B020A C4     0252* CALL    NZ,NEGATE
0B020B 42 
0B020C 0B 
0B020D 0B 
0B020E 44     0253* LD      B,H
0B020F 4D     0254* LD      C,L
0B0210 21     0255* LD      HL,0
0B0211 00 
0B0212 00 
0B0213 00 
0B0214 D9     0256* EXX
0B0215 44     0257* LD      B,H
0B0216 4D     0258* LD      C,L
0B0217 21     0259* LD      HL,0
0B0218 00 
0B0219 00 
0B021A 00 
0B021B 3E     0260* LD      A,-33
0B021C DF 
0B021D CD     0261* CALL    DIVA            ;DIVIDE
0B021E CC 
0B021F 0D 
0B0220 0B 
0B0221 D9     0262* EXX
0B0222 0E     0263* LD      C,0             ;INTEGER MARKER
0B0223 00 
0B0224 08     0264* EX      AF,AF'
0B0225 C8     0265* RET     Z
0B0226 C3     0266* JP      NEGATE
0B0227 42 
0B0228 0B 
0B0229 0B 
              0267* ;
              0268* ;BDIV - Integer division.
              0269* ;
0B022A CD     0270* FBDIV:			CALL    FIX2
0B022B 26 
0B022C 0B 
0B022D 0B 
0B022E CD     0271* IBDIV:			CALL    IMOD
0B022F F9 
0B0230 01 
0B0231 0B 
0B0232 B7     0272* OR      A
0B0233 CD     0273* CALL    SWAP_FP
0B0234 3F 
0B0235 0C 
0B0236 0B 
0B0237 0E     0274* LD      C,0
0B0238 00 
0B0239 F0     0275* RET     P
0B023A C3     0276* JP      NEGATE
0B023B 42 
0B023C 0B 
0B023D 0B 
              0277* ;
              0278* ;ISUB - Integer subtraction.
              0279* ;FSUB - Floating point subtraction with rounding.
              0280* ;
0B023E CD     0281* ISUB:			CALL    SUB_
0B023F DA 
0B0240 0C 
0B0241 0B 
0B0242 E0     0282* RET     PO
0B0243 CD     0283* CALL    ADD_
0B0244 D2 
0B0245 0C 
0B0246 0B 
0B0247 CD     0284* CALL    FLOAT2
0B0248 02 
0B0249 0C 
0B024A 0B 
0B024B 7A     0285* FSUB:			LD      A,D
0B024C EE     0286* XOR     80H             ;CHANGE SIGN THEN ADD
0B024D 80 
0B024E 57     0287* LD      D,A
0B024F 18     0288* JR      FADD
0B0250 13 
              0289* ;
              0290* ;Reverse subtract.
              0291* ;
0B0251 7C     0292* RSUB:			LD      A,H
0B0252 EE     0293* XOR     80H
0B0253 80 
0B0254 67     0294* LD      H,A
0B0255 18     0295* JR      FADD
0B0256 0D 
              0296* ;
              0297* ;IADD - Integer addition.
              0298* ;FADD - Floating point addition with rounding.
              0299* ;
0B0257 CD     0300* IADD:			CALL    ADD_
0B0258 D2 
0B0259 0C 
0B025A 0B 
0B025B E0     0301* RET     PO
0B025C CD     0302* CALL    SUB_
0B025D DA 
0B025E 0C 
0B025F 0B 
0B0260 CD     0303* CALL    FLOAT2
0B0261 02 
0B0262 0C 
0B0263 0B 
0B0264 05     0304* FADD:			DEC     B
0B0265 04     0305* INC     B
0B0266 C8     0306* RET     Z               ;ARG 2 ZERO
0B0267 0D     0307* DEC     C
0B0268 0C     0308* INC     C
0B0269 CA     0309* JP      Z,SWAP_FP          ;ARG 1 ZERO
0B026A 3F 
0B026B 0C 
0B026C 0B 
0B026D D9     0310* EXX
0B026E 01     0311* LD      BC,0            ;INITIALISE
0B026F 00 
0B0270 00 
0B0271 00 
0B0272 D9     0312* EXX
0B0273 7C     0313* LD      A,H
0B0274 AA     0314* XOR     D               ;XOR SIGNS
0B0275 F5     0315* PUSH    AF
0B0276 78     0316* LD      A,B
0B0277 B9     0317* CP      C               ;COMPARE EXPONENTS
0B0278 DC     0318* CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B0279 3F 
0B027A 0C 
0B027B 0B 
0B027C 78     0319* LD      A,B
0B027D CB     0320* SET     7,H             ;IMPLIED 1
0B027E FC 
0B027F C4     0321* CALL    NZ,FIX          ;ALIGN
0B0280 13 
0B0281 0B 
0B0282 0B 
0B0283 F1     0322* POP     AF
0B0284 7A     0323* LD      A,D             ;SIGN OF LARGER
0B0285 CB     0324* SET     7,D             ;IMPLIED 1
0B0286 FA 
0B0287 FA     0325* JP      M,FADD3         ;SIGNS DIFFERENT
0B0288 97 
0B0289 02 
0B028A 0B 
0B028B CD     0326* CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B028C D2 
0B028D 0C 
0B028E 0B 
0B028F DC     0327* CALL    C,DIV2          ;NORMALISE
0B0290 47 
0B0291 0C 
0B0292 0B 
0B0293 CB     0328* SET     7,H
0B0294 FC 
0B0295 18     0329* JR      FADD4
0B0296 0D 
              0330* ;
0B0297 CD     0331* FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B0298 DA 
0B0299 0C 
0B029A 0B 
0B029B DC     0332* CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B029C 5A 
0B029D 0B 
0B029E 0B 
0B029F CD     0333* CALL    FLO48
0B02A0 D9 
0B02A1 0B 
0B02A2 0B 
0B02A3 2F     0334* CPL                     ;CHANGE RESULT SIGN
0B02A4 D9     0335* FADD4:			EXX
0B02A5 EB     0336* EX      DE,HL
0B02A6 21     0337* LD      HL,8000H
0B02A7 00 
0B02A8 80 
0B02A9 00 
0B02AA B7     0338* OR      A               ;CLEAR CARRY
0B02AB 52     0339* SBC.S   HL,BC
0B02AC ED 
0B02AD 42 
0B02AE EB     0340* EX      DE,HL
0B02AF D9     0341* EXX
0B02B0 CC     0342* CALL    Z,ODD           ;ROUND UNBIASSED
0B02B1 39 
0B02B2 0C 
0B02B3 0B 
0B02B4 DC     0343* CALL    C,ADD1_FP          ;ROUND UP
0B02B5 27 
0B02B6 0C 
0B02B7 0B 
0B02B8 DC     0344* CALL    C,INCC
0B02B9 54 
0B02BA 0C 
0B02BB 0B 
0B02BC CB     0345* RES     7,H
0B02BD BC 
0B02BE 0D     0346* DEC     C
0B02BF 0C     0347* INC     C
0B02C0 CA     0348* JP      Z,ZERO_FP
0B02C1 8B 
0B02C2 0C 
0B02C3 0B 
0B02C4 B7     0349* OR      A               ;RESULT SIGNQ
0B02C5 F0     0350* RET     P               ;POSITIVE
0B02C6 CB     0351* SET     7,H             ;NEGATIVE
0B02C7 FC 
0B02C8 C9     0352* RET
              0353* ;
              0354* ;IDIV - Integer division.
              0355* ;FDIV - Floating point division with rounding.
              0356* ;
0B02C9 CD     0357* IDIV:			CALL    FLOAT2
0B02CA 02 
0B02CB 0C 
0B02CC 0B 
0B02CD 05     0358* FDIV:			DEC     B               ;TEST FOR ZERO
0B02CE 04     0359* INC     B
0B02CF 3E     0360* LD      A,DIVBY0
0B02D0 12 
0B02D1 CA     0361* JP      Z,ERROR_FP_         ;"Division by zero"
0B02D2 E5 
0B02D3 00 
0B02D4 0B 
0B02D5 0D     0362* DEC     C               ;TEST FOR ZERO
0B02D6 0C     0363* INC     C
0B02D7 C8     0364* RET     Z
0B02D8 7C     0365* LD      A,H
0B02D9 AA     0366* XOR     D               ;CALC. RESULT SIGN
0B02DA 08     0367* EX      AF,AF'          ;SAVE SIGN
0B02DB CB     0368* SET     7,D             ;REPLACE IMPLIED 1's
0B02DC FA 
0B02DD CB     0369* SET     7,H
0B02DE FC 
0B02DF C5     0370* PUSH    BC              ;SAVE EXPONENTS
0B02E0 42     0371* LD      B,D             ;LOAD REGISTERS
0B02E1 4B     0372* LD      C,E
0B02E2 11     0373* LD      DE,0
0B02E3 00 
0B02E4 00 
0B02E5 00 
0B02E6 D9     0374* EXX
0B02E7 42     0375* LD      B,D
0B02E8 4B     0376* LD      C,E
0B02E9 11     0377* LD      DE,0
0B02EA 00 
0B02EB 00 
0B02EC 00 
0B02ED 3E     0378* LD      A,-32           ;LOOP COUNTER
0B02EE E0 
0B02EF CD     0379* CALL    DIVA            ;DIVIDE
0B02F0 CC 
0B02F1 0D 
0B02F2 0B 
0B02F3 D9     0380* EXX
0B02F4 CB     0381* BIT     7,D
0B02F5 7A 
0B02F6 D9     0382* EXX
0B02F7 CC     0383* CALL    Z,DIVB          ;NORMALISE & INC A
0B02F8 EB 
0B02F9 0D 
0B02FA 0B 
0B02FB EB     0384* EX      DE,HL
0B02FC D9     0385* EXX
0B02FD CB     0386* SRL     B               ;DIVISOR/2
0B02FE 38 
0B02FF CB     0387* RR      C
0B0300 19 
0B0301 B7     0388* OR      A               ;CLEAR CARRY
0B0302 52     0389* SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B0303 ED 
0B0304 42 
0B0305 3F     0390* CCF
0B0306 EB     0391* EX      DE,HL           ;RESULT IN HLH'L'
0B0307 CC     0392* CALL    Z,ODD           ;ROUND UNBIASSED
0B0308 39 
0B0309 0C 
0B030A 0B 
0B030B DC     0393* CALL    C,ADD1_FP          ;ROUND UP
0B030C 27 
0B030D 0C 
0B030E 0B 
0B030F C1     0394* POP     BC              ;RESTORE EXPONENTS
0B0310 DC     0395* CALL    C,INCC
0B0311 54 
0B0312 0C 
0B0313 0B 
0B0314 1F     0396* RRA                     ;LSB OF A TO CARRY
0B0315 79     0397* LD      A,C             ;COMPUTE NEW EXPONENT
0B0316 98     0398* SBC     A,B
0B0317 3F     0399* CCF
0B0318 C3     0400* JP      CHKOVF
0B0319 B9 
0B031A 03 
0B031B 0B 
              0401* ;
              0402* ;IMUL - Integer multiplication.
              0403* ;
0B031C 7C     0404* IMUL:			LD      A,H
0B031D AA     0405* XOR     D
0B031E 08     0406* EX      AF,AF'          ;SAVE RESULT SIGN
0B031F CB     0407* BIT     7,H
0B0320 7C 
0B0321 C4     0408* CALL    NZ,NEGATE
0B0322 42 
0B0323 0B 
0B0324 0B 
0B0325 CD     0409* CALL    SWAP_FP
0B0326 3F 
0B0327 0C 
0B0328 0B 
0B0329 CB     0410* BIT     7,H
0B032A 7C 
0B032B C4     0411* CALL    NZ,NEGATE
0B032C 42 
0B032D 0B 
0B032E 0B 
0B032F 44     0412* LD      B,H
0B0330 4D     0413* LD      C,L
0B0331 21     0414* LD      HL,0
0B0332 00 
0B0333 00 
0B0334 00 
0B0335 D9     0415* EXX
0B0336 44     0416* LD      B,H
0B0337 4D     0417* LD      C,L
0B0338 21     0418* LD      HL,0
0B0339 00 
0B033A 00 
0B033B 00 
0B033C 3E     0419* LD      A,-33
0B033D DF 
0B033E CD     0420* CALL    MULA            ;MULTIPLY
0B033F 03 
0B0340 0E 
0B0341 0B 
0B0342 D9     0421* EXX
0B0343 0E     0422* LD      C,191           ;PRESET EXPONENT
0B0344 BF 
0B0345 CD     0423* CALL    TEST_FP            ;TEST RANGE
0B0346 67 
0B0347 0C 
0B0348 0B 
0B0349 20     0424* JR      NZ,IMUL1        ;TOO BIG
0B034A 0F 
0B034B CB     0425* BIT     7,D
0B034C 7A 
0B034D 20     0426* JR      NZ,IMUL1
0B034E 0B 
0B034F CD     0427* CALL    SWAP_FP
0B0350 3F 
0B0351 0C 
0B0352 0B 
0B0353 4A     0428* LD      C,D             ;INTEGER MARKER
0B0354 08     0429* EX      AF,AF'
0B0355 F0     0430* RET     P
0B0356 C3     0431* JP      NEGATE
0B0357 42 
0B0358 0B 
0B0359 0B 
              0432* ;
0B035A 0D     0433* IMUL1:			DEC     C
0B035B D9     0434* EXX
0B035C CB     0435* SLA     E
0B035D 23 
0B035E CB     0436* RL      D
0B035F 12 
0B0360 D9     0437* EXX
0B0361 CB     0438* RL      E
0B0362 13 
0B0363 CB     0439* RL      D
0B0364 12 
0B0365 D9     0440* EXX
0B0366 52     0441* ADC.S   HL,HL
0B0367 ED 
0B0368 6A 
0B0369 D9     0442* EXX
0B036A 52     0443* ADC.S   HL,HL
0B036B ED 
0B036C 6A 
0B036D F2     0444* JP      P,IMUL1         ;NORMALISE
0B036E 5A 
0B036F 03 
0B0370 0B 
0B0371 08     0445* EX      AF,AF'
0B0372 F8     0446* RET     M
0B0373 CB     0447* RES     7,H             ;POSITIVE
0B0374 BC 
0B0375 C9     0448* RET
              0449* ;
              0450* ;FMUL - Floating point multiplication with rounding.
              0451* ;
0B0376 05     0452* FMUL:			DEC     B               ;TEST FOR ZERO
0B0377 04     0453* INC     B
0B0378 CA     0454* JP      Z,ZERO_FP
0B0379 8B 
0B037A 0C 
0B037B 0B 
0B037C 0D     0455* DEC     C               ;TEST FOR ZERO
0B037D 0C     0456* INC     C
0B037E C8     0457* RET     Z
0B037F 7C     0458* LD      A,H
0B0380 AA     0459* XOR     D               ;CALC. RESULT SIGN
0B0381 08     0460* EX      AF,AF'
0B0382 CB     0461* SET     7,D             ;REPLACE IMPLIED 1's
0B0383 FA 
0B0384 CB     0462* SET     7,H
0B0385 FC 
0B0386 C5     0463* PUSH    BC              ;SAVE EXPONENTS
0B0387 44     0464* LD      B,H             ;LOAD REGISTERS
0B0388 4D     0465* LD      C,L
0B0389 21     0466* LD      HL,0
0B038A 00 
0B038B 00 
0B038C 00 
0B038D D9     0467* EXX
0B038E 44     0468* LD      B,H
0B038F 4D     0469* LD      C,L
0B0390 21     0470* LD      HL,0
0B0391 00 
0B0392 00 
0B0393 00 
0B0394 3E     0471* LD      A,-32           ;LOOP COUNTER
0B0395 E0 
0B0396 CD     0472* CALL    MULA            ;MULTIPLY
0B0397 03 
0B0398 0E 
0B0399 0B 
0B039A DC     0473* CALL    C,MULB          ;NORMALISE & INC A
0B039B 19 
0B039C 0E 
0B039D 0B 
0B039E D9     0474* EXX
0B039F E5     0475* PUSH    HL
0B03A0 21     0476* LD      HL,8000H
0B03A1 00 
0B03A2 80 
0B03A3 00 
0B03A4 B7     0477* OR      A               ;CLEAR CARRY
0B03A5 52     0478* SBC.S   HL,DE
0B03A6 ED 
0B03A7 52 
0B03A8 E1     0479* POP     HL
0B03A9 CC     0480* CALL    Z,ODD           ;ROUND UNBIASSED
0B03AA 39 
0B03AB 0C 
0B03AC 0B 
0B03AD DC     0481* CALL    C,ADD1_FP          ;ROUND UP
0B03AE 27 
0B03AF 0C 
0B03B0 0B 
0B03B1 C1     0482* POP     BC              ;RESTORE EXPONENTS
0B03B2 DC     0483* CALL    C,INCC
0B03B3 54 
0B03B4 0C 
0B03B5 0B 
0B03B6 1F     0484* RRA                     ;LSB OF A TO CARRY
0B03B7 79     0485* LD      A,C             ;COMPUTE NEW EXPONENT
0B03B8 88     0486* ADC     A,B
0B03B9 38     0487* CHKOVF:			JR      C,CHKO1
0B03BA 06 
0B03BB F2     0488* JP      P,ZERO_FP          ;UNDERFLOW
0B03BC 8B 
0B03BD 0C 
0B03BE 0B 
0B03BF 18     0489* JR      CHKO2
0B03C0 04 
0B03C1 FA     0490* CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B03C2 56 
0B03C3 0C 
0B03C4 0B 
0B03C5 C6     0491* CHKO2:			ADD     A,80H
0B03C6 80 
0B03C7 4F     0492* LD      C,A
0B03C8 CA     0493* JP      Z,ZERO_FP
0B03C9 8B 
0B03CA 0C 
0B03CB 0B 
0B03CC 08     0494* EX      AF,AF'          ;RESTORE SIGN BIT
0B03CD CB     0495* RES     7,H
0B03CE BC 
0B03CF F0     0496* RET     P
0B03D0 CB     0497* SET     7,H
0B03D1 FC 
0B03D2 C9     0498* RET
              0499* ;
              0500* ;IPOW - Integer involution.
              0501* ;
0B03D3 CD     0502* IPOW:			CALL    SWAP_FP
0B03D4 3F 
0B03D5 0C 
0B03D6 0B 
0B03D7 CB     0503* BIT     7,H
0B03D8 7C 
0B03D9 F5     0504* PUSH    AF              ;SAVE SIGN
0B03DA C4     0505* CALL    NZ,NEGATE
0B03DB 42 
0B03DC 0B 
0B03DD 0B 
0B03DE 48     0506* IPOW0:			LD      C,B
0B03DF 06     0507* LD      B,32            ;LOOP COUNTER
0B03E0 20 
0B03E1 CD     0508* IPOW1:			CALL    X2
0B03E2 F7 
0B03E3 0C 
0B03E4 0B 
0B03E5 38     0509* JR      C,IPOW2
0B03E6 08 
0B03E7 10     0510* DJNZ    IPOW1
0B03E8 F8 
0B03E9 F1     0511* POP     AF
0B03EA D9     0512* EXX
0B03EB 2C     0513* INC     L               ;RESULT=1
0B03EC D9     0514* EXX
0B03ED 4C     0515* LD      C,H
0B03EE C9     0516* RET
              0517* ;
0B03EF F1     0518* IPOW2:			POP     AF
0B03F0 C5     0519* PUSH    BC
0B03F1 EB     0520* EX      DE,HL
0B03F2 E5     0521* PUSH    HL
0B03F3 D9     0522* EXX
0B03F4 EB     0523* EX      DE,HL
0B03F5 E5     0524* PUSH    HL
0B03F6 D9     0525* EXX
0B03F7 DD     0526* LD      IX,0
0B03F8 21 
0B03F9 00 
0B03FA 00 
0B03FA 00   
0B03FC DD     0527* ADD     IX,SP
0B03FD 39 
0B03FE 28     0528* JR      Z,IPOW4
0B03FF 48 
0B0400 C5     0529* PUSH    BC
0B0401 D9     0530* EXX
0B0402 D5     0531* PUSH    DE
0B0403 D9     0532* EXX
0B0404 D5     0533* PUSH    DE
0B0405 CD     0534* CALL    SFLOAT_FP
0B0406 0E 
0B0407 0C 
0B0408 0B 
0B0409 CD     0535* CALL    RECIP
0B040A 42 
0B040B 07 
0B040C 0B 
0B040D DD     0536* LD      (IX+4),C
0B040E 71 
0B040F 04 
0B0410 D9     0537* EXX
0B0411 DD     0538* LD      (IX+0),L
0B0412 75 
0B0413 00 
0B0414 DD     0539* LD      (IX+1),H
0B0415 74 
0B0416 01 
0B0417 D9     0540* EXX
0B0418 DD     0541* LD      (IX+2),L
0B0419 75 
0B041A 02 
0B041B DD     0542* LD      (IX+3),H
0B041C 74 
0B041D 03 
0B041E 18     0543* JR      IPOW5
0B041F 21 
              0544* ;
0B0420 C5     0545* IPOW3:			PUSH    BC
0B0421 D9     0546* EXX
0B0422 CB     0547* SLA     E
0B0423 23 
0B0424 CB     0548* RL      D
0B0425 12 
0B0426 D5     0549* PUSH    DE
0B0427 D9     0550* EXX
0B0428 CB     0551* RL      E
0B0429 13 
0B042A CB     0552* RL      D
0B042B 12 
0B042C D5     0553* PUSH    DE
0B042D 3E     0554* LD      A,'*' & 0FH
0B042E 0A 
0B042F F5     0555* PUSH    AF
0B0430 CD     0556* CALL    COPY_
0B0431 0B 
0B0432 0D 
0B0433 0B 
0B0434 CD     0557* CALL    OP              ;SQUARE
0B0435 EB 
0B0436 00 
0B0437 0B 
0B0438 F1     0558* POP     AF
0B0439 CD     0559* CALL    DLOAD5
0B043A 37 
0B043B 0A 
0B043C 0B 
0B043D DC     0560* CALL    C,OP            ;MULTIPLY BY X
0B043E EB 
0B043F 00 
0B0440 0B 
0B0441 D1     0561* IPOW5:			POP     DE
0B0442 D9     0562* EXX
0B0443 D1     0563* POP     DE
0B0444 D9     0564* EXX
0B0445 79     0565* LD      A,C
0B0446 C1     0566* POP     BC
0B0447 4F     0567* LD      C,A
0B0448 10     0568* IPOW4:			DJNZ    IPOW3
0B0449 D6 
0B044A F1     0569* POP     AF
0B044B F1     0570* POP     AF
0B044C F1     0571* POP     AF
0B044D C9     0572* RET
              0573* ;
0B044E F1     0574* FPOW0:			POP     AF
0B044F F1     0575* POP     AF
0B0450 F1     0576* POP     AF
0B0451 18     0577* JR      IPOW0
0B0452 8B 
              0578* ;
              0579* ;FPOW - Floating-point involution.
              0580* ;
0B0453 CB     0581* FPOW:			BIT     7,D
0B0454 7A 
0B0455 F5     0582* PUSH    AF
0B0456 CD     0583* CALL    SWAP_FP
0B0457 3F 
0B0458 0C 
0B0459 0B 
0B045A CD     0584* CALL    PUSH5
0B045B 1B 
0B045C 0D 
0B045D 0B 
0B045E 0D     0585* DEC     C
0B045F 0C     0586* INC     C
0B0460 28     0587* JR      Z,FPOW0
0B0461 EC 
0B0462 3E     0588* LD      A,158
0B0463 9E 
0B0464 B9     0589* CP      C
0B0465 38     0590* JR      C,FPOW1
0B0466 0A 
0B0467 3C     0591* INC     A
0B0468 CD     0592* CALL    FIX
0B0469 13 
0B046A 0B 
0B046B 0B 
0B046C 08     0593* EX      AF,AF'
0B046D F2     0594* JP      P,FPOW0
0B046E 4E 
0B046F 04 
0B0470 0B 
0B0471 CD     0595* FPOW1:			CALL    SWAP_FP
0B0472 3F 
0B0473 0C 
0B0474 0B 
0B0475 CD     0596* CALL    LN0
0B0476 5F 
0B0477 07 
0B0478 0B 
0B0479 CD     0597* CALL    POP5
0B047A 24 
0B047B 0D 
0B047C 0B 
0B047D F1     0598* POP     AF
0B047E CD     0599* CALL    FMUL
0B047F 76 
0B0480 03 
0B0481 0B 
0B0482 C3     0600* JP      EXP0
0B0483 C1 
0B0484 06 
0B0485 0B 
              0601* ;
              0602* ;Integer and floating-point compare.
              0603* ;Result is TRUE (-1) or FALSE (0).
              0604* ;
0B0486 CD     0605* FLT:			CALL    FCP
0B0487 95 
0B0488 0C 
0B0489 0B 
0B048A 18     0606* JR      ILT1
0B048B 04 
0B048C CD     0607* ILT:			CALL    ICP
0B048D 87 
0B048E 0C 
0B048F 0B 
0B0490 D0     0608* ILT1:			RET     NC
0B0491 18     0609* JR      TRUE_FP
0B0492 42 
              0610* ;
0B0493 CD     0611* FGT:			CALL    FCP
0B0494 95 
0B0495 0C 
0B0496 0B 
0B0497 18     0612* JR      IGT1
0B0498 04 
0B0499 CD     0613* IGT:			CALL    ICP
0B049A 87 
0B049B 0C 
0B049C 0B 
0B049D C8     0614* IGT1:			RET     Z
0B049E D8     0615* RET     C
0B049F 18     0616* JR      TRUE_FP
0B04A0 34 
              0617* ;
0B04A1 CD     0618* FGE:			CALL    FCP
0B04A2 95 
0B04A3 0C 
0B04A4 0B 
0B04A5 18     0619* JR      IGE1
0B04A6 04 
0B04A7 CD     0620* IGE:			CALL    ICP
0B04A8 87 
0B04A9 0C 
0B04AA 0B 
0B04AB D8     0621* IGE1:			RET     C
0B04AC 18     0622* JR      TRUE_FP
0B04AD 27 
              0623* ;
0B04AE CD     0624* FLE:			CALL    FCP
0B04AF 95 
0B04B0 0C 
0B04B1 0B 
0B04B2 18     0625* JR      ILE1
0B04B3 04 
0B04B4 CD     0626* ILE:			CALL    ICP
0B04B5 87 
0B04B6 0C 
0B04B7 0B 
0B04B8 28     0627* ILE1:			JR      Z,TRUE_FP
0B04B9 1B 
0B04BA D0     0628* RET     NC
0B04BB 18     0629* JR      TRUE_FP
0B04BC 18 
              0630* ;
0B04BD CD     0631* FNE:			CALL    FCP
0B04BE 95 
0B04BF 0C 
0B04C0 0B 
0B04C1 18     0632* JR      INE1
0B04C2 04 
0B04C3 CD     0633* INE:			CALL    ICP
0B04C4 87 
0B04C5 0C 
0B04C6 0B 
0B04C7 C8     0634* INE1:			RET     Z
0B04C8 18     0635* JR      TRUE_FP
0B04C9 0B 
              0636* ;
0B04CA CD     0637* FEQ:			CALL    FCP
0B04CB 95 
0B04CC 0C 
0B04CD 0B 
0B04CE 18     0638* JR      IEQ1
0B04CF 04 
0B04D0 CD     0639* IEQ:			CALL    ICP
0B04D1 87 
0B04D2 0C 
0B04D3 0B 
0B04D4 C0     0640* IEQ1:			RET     NZ
0B04D5 21     0641* TRUE_FP:			LD      HL,-1
0B04D6 FF 
0B04D7 FF 
0B04D8 FF 
0B04D9 D9     0642* EXX
0B04DA 21     0643* LD      HL,-1
0B04DB FF 
0B04DC FF 
0B04DD FF 
0B04DE D9     0644* EXX
0B04DF AF     0645* XOR     A
0B04E0 4F     0646* LD      C,A
0B04E1 C9     0647* RET
              0648* ;
              0649* ;FUNCTIONS:
              0650* ;
              0651* ;Result returned in HLH'L'C (floating point)
              0652* ;Result returned in HLH'L' (C=0) (integer)
              0653* ;All registers except IY destroyed.
              0654* ;
              0655* ;ABS - Absolute value
              0656* ;Result is numeric, variable type.
              0657* ;
0B04E2 CB     0658* ABSV_FP:			BIT     7,H
0B04E3 7C 
0B04E4 C8     0659* RET     Z               ;POSITIVE/ZERO
0B04E5 0D     0660* DEC     C
0B04E6 0C     0661* INC     C
0B04E7 CA     0662* JP      Z,NEGATE        ;INTEGER
0B04E8 42 
0B04E9 0B 
0B04EA 0B 
0B04EB CB     0663* RES     7,H
0B04EC BC 
0B04ED C9     0664* RET
              0665* ;
              0666* ;NOT - Complement integer.
              0667* ;Result is integer numeric.
              0668* ;
0B04EE CD     0669* NOTK_FP:			CALL    SFIX_FP
0B04EF 32 
0B04F0 0B 
0B04F1 0B 
0B04F2 7C     0670* LD      A,H
0B04F3 2F     0671* CPL
0B04F4 67     0672* LD      H,A
0B04F5 7D     0673* LD      A,L
0B04F6 2F     0674* CPL
0B04F7 6F     0675* LD      L,A
0B04F8 D9     0676* EXX
0B04F9 7C     0677* LD      A,H
0B04FA 2F     0678* CPL
0B04FB 67     0679* LD      H,A
0B04FC 7D     0680* LD      A,L
0B04FD 2F     0681* CPL
0B04FE 6F     0682* LD      L,A
0B04FF D9     0683* EXX
0B0500 AF     0684* XOR     A               ;NUMERIC MARKER
0B0501 C9     0685* RET
              0686* ;
              0687* ;PI - Return PI (3.141592654)
              0688* ;Result is floating-point numeric.
              0689* ;
0B0502 21     0690* PI_FP:			LD      HL,490FH
0B0503 0F 
0B0504 49 
0B0505 00 
0B0506 D9     0691* EXX
0B0507 21     0692* LD      HL,0DAA2H
0B0508 A2 
0B0509 DA 
0B050A 00 
0B050B D9     0693* EXX
0B050C 0E     0694* LD      C,81H
0B050D 81 
0B050E AF     0695* XOR     A               ;NUMERIC MARKER
0B050F C9     0696* RET
              0697* ;
              0698* ;DEG - Convert radians to degrees
              0699* ;Result is floating-point numeric.
              0700* ;
0B0510 CD     0701* DEG_FP:			CALL    FPI180
0B0511 24 
0B0512 05 
0B0513 0B 
0B0514 CD     0702* CALL    FMUL
0B0515 76 
0B0516 03 
0B0517 0B 
0B0518 AF     0703* XOR     A
0B0519 C9     0704* RET
              0705* ;
              0706* ;RAD - Convert degrees to radians
              0707* ;Result is floating-point numeric.
              0708* ;
0B051A CD     0709* RAD_FP:			CALL    FPI180
0B051B 24 
0B051C 05 
0B051D 0B 
0B051E CD     0710* CALL    FDIV
0B051F CD 
0B0520 02 
0B0521 0B 
0B0522 AF     0711* XOR     A
0B0523 C9     0712* RET
              0713* ;
              0714* ;180/PI
              0715* ;
0B0524 CD     0716* FPI180:			CALL    SFLOAT_FP
0B0525 0E 
0B0526 0C 
0B0527 0B 
0B0528 11     0717* LD      DE,652EH
0B0529 2E 
0B052A 65 
0B052B 00 
0B052C D9     0718* EXX
0B052D 11     0719* LD      DE,0E0D3H
0B052E D3 
0B052F E0 
0B0530 00 
0B0531 D9     0720* EXX
0B0532 06     0721* LD      B,85H
0B0533 85 
0B0534 C9     0722* RET
              0723* ;
              0724* ;SGN - Return -1, 0 or +1
              0725* ;Result is integer numeric.
              0726* ;
0B0535 CD     0727* SGN_FP:			CALL    TEST_FP
0B0536 67 
0B0537 0C 
0B0538 0B 
0B0539 B1     0728* OR      C
0B053A C8     0729* RET     Z               ;ZERO
0B053B CB     0730* BIT     7,H
0B053C 7C 
0B053D C2     0731* JP      NZ,TRUE_FP         ;-1
0B053E D5 
0B053F 04 
0B0540 0B 
0B0541 CD     0732* CALL    ZERO_FP
0B0542 8B 
0B0543 0C 
0B0544 0B 
0B0545 C3     0733* JP      ADD1_FP            ;1
0B0546 27 
0B0547 0C 
0B0548 0B 
              0734* ;
              0735* ;VAL - Return numeric value of string.
              0736* ;Input: ASCII string at IX
              0737* ;Result is variable type numeric.
              0738* ;
0B0549 CD     0739* VAL_FP:			CALL    SIGNQ
0B054A A5 
0B054B 0E 
0B054C 0B 
0B054D F5     0740* PUSH    AF
0B054E CD     0741* CALL    CON_FP
0B054F 55 
0B0550 0A 
0B0551 0B 
0B0552 F1     0742* POP     AF
0B0553 FE     0743* CP      '-'
0B0554 2D 
0B0555 3E     0744* LD      A,0             ;NUMERIC MARKER
0B0556 00 
0B0557 C0     0745* RET     NZ
0B0558 0D     0746* DEC     C
0B0559 0C     0747* INC     C
0B055A CA     0748* JP      Z,NEGATE        ;ZERO/INTEGER
0B055B 42 
0B055C 0B 
0B055D 0B 
0B055E 7C     0749* LD      A,H
0B055F EE     0750* XOR     80H             ;CHANGE SIGN (FP)
0B0560 80 
0B0561 67     0751* LD      H,A
0B0562 AF     0752* XOR     A
0B0563 C9     0753* RET
              0754* ;
              0755* ;INT - Floor function
              0756* ;Result is integer numeric.
              0757* ;
0B0564 0D     0758* INT_FP_:			DEC     C
0B0565 0C     0759* INC     C
0B0566 C8     0760* RET     Z               ;ZERO/INTEGER
0B0567 3E     0761* LD      A,159
0B0568 9F 
0B0569 44     0762* LD      B,H             ;B7=SIGN BIT
0B056A CD     0763* CALL    FIX
0B056B 13 
0B056C 0B 
0B056D 0B 
0B056E 08     0764* EX      AF,AF'
0B056F A0     0765* AND     B
0B0570 FC     0766* CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B0571 27 
0B0572 0C 
0B0573 0B 
0B0574 78     0767* LD      A,B
0B0575 B7     0768* OR      A
0B0576 FC     0769* CALL    M,NEGATE
0B0577 42 
0B0578 0B 
0B0579 0B 
0B057A AF     0770* XOR     A
0B057B 4F     0771* LD      C,A
0B057C C9     0772* RET
              0773* ;
              0774* ;SQR - square root
              0775* ;Result is floating-point numeric.
              0776* ;
0B057D CD     0777* SQR_FP:			CALL    SFLOAT_FP
0B057E 0E 
0B057F 0C 
0B0580 0B 
0B0581 CB     0778* SQR0:			BIT     7,H
0B0582 7C 
0B0583 3E     0779* LD      A,NGROOT
0B0584 15 
0B0585 C2     0780* JP      NZ,ERROR_FP_        ;"-ve root"
0B0586 E5 
0B0587 00 
0B0588 0B 
0B0589 0D     0781* DEC     C
0B058A 0C     0782* INC     C
0B058B C8     0783* RET     Z               ;ZERO
0B058C CB     0784* SET     7,H             ;IMPLIED 1
0B058D FC 
0B058E CB     0785* BIT     0,C
0B058F 41 
0B0590 CC     0786* CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B0591 47 
0B0592 0C 
0B0593 0B 
0B0594 79     0787* LD      A,C
0B0595 D6     0788* SUB     80H
0B0596 80 
0B0597 CB     0789* SRA     A               ;HALVE EXPONENT
0B0598 2F 
0B0599 C6     0790* ADD     A,80H
0B059A 80 
0B059B 4F     0791* LD      C,A
0B059C C5     0792* PUSH    BC              ;SAVE EXPONENT
0B059D EB     0793* EX      DE,HL
0B059E 21     0794* LD      HL,0
0B059F 00 
0B05A0 00 
0B05A1 00 
0B05A2 44     0795* LD      B,H
0B05A3 4D     0796* LD      C,L
0B05A4 D9     0797* EXX
0B05A5 EB     0798* EX      DE,HL
0B05A6 21     0799* LD      HL,0
0B05A7 00 
0B05A8 00 
0B05A9 00 
0B05AA 44     0800* LD      B,H
0B05AB 4D     0801* LD      C,L
0B05AC 3E     0802* LD      A,-31
0B05AD E1 
0B05AE CD     0803* CALL    SQRA            ;ROOT
0B05AF 3D 
0B05B0 0E 
0B05B1 0B 
0B05B2 D9     0804* EXX
0B05B3 CB     0805* BIT     7,B
0B05B4 78 
0B05B5 D9     0806* EXX
0B05B6 CC     0807* CALL    Z,SQRA          ;NORMALISE & INC A
0B05B7 3D 
0B05B8 0E 
0B05B9 0B 
0B05BA CD     0808* CALL    SQRB
0B05BB 7E 
0B05BC 0E 
0B05BD 0B 
0B05BE B7     0809* OR      A               ;CLEAR CARRY
0B05BF CD     0810* CALL    DIVB
0B05C0 EB 
0B05C1 0D 
0B05C2 0B 
0B05C3 CB     0811* RR      E               ;LSB TO CARRY
0B05C4 1B 
0B05C5 60     0812* LD      H,B
0B05C6 69     0813* LD      L,C
0B05C7 D9     0814* EXX
0B05C8 60     0815* LD      H,B
0B05C9 69     0816* LD      L,C
0B05CA DC     0817* CALL    C,ADD1_FP          ;ROUND UP
0B05CB 27 
0B05CC 0C 
0B05CD 0B 
0B05CE C1     0818* POP     BC              ;RESTORE EXPONENT
0B05CF DC     0819* CALL    C,INCC
0B05D0 54 
0B05D1 0C 
0B05D2 0B 
0B05D3 1F     0820* RRA
0B05D4 9F     0821* SBC     A,A
0B05D5 81     0822* ADD     A,C
0B05D6 4F     0823* LD      C,A
0B05D7 CB     0824* RES     7,H             ;POSITIVE
0B05D8 BC 
0B05D9 AF     0825* XOR     A
0B05DA C9     0826* RET
              0827* ;
              0828* ;TAN - Tangent function
              0829* ;Result is floating-point numeric.
              0830* ;
0B05DB CD     0831* TAN_FP:			CALL    SFLOAT_FP
0B05DC 0E 
0B05DD 0C 
0B05DE 0B 
0B05DF CD     0832* CALL    PUSH5
0B05E0 1B 
0B05E1 0D 
0B05E2 0B 
0B05E3 CD     0833* CALL    COS0
0B05E4 05 
0B05E5 06 
0B05E6 0B 
0B05E7 CD     0834* CALL    POP5
0B05E8 24 
0B05E9 0D 
0B05EA 0B 
0B05EB CD     0835* CALL    PUSH5
0B05EC 1B 
0B05ED 0D 
0B05EE 0B 
0B05EF CD     0836* CALL    SWAP_FP
0B05F0 3F 
0B05F1 0C 
0B05F2 0B 
0B05F3 CD     0837* CALL    SIN0
0B05F4 12 
0B05F5 06 
0B05F6 0B 
0B05F7 CD     0838* CALL    POP5
0B05F8 24 
0B05F9 0D 
0B05FA 0B 
0B05FB CD     0839* CALL    FDIV
0B05FC CD 
0B05FD 02 
0B05FE 0B 
0B05FF AF     0840* XOR     A               ;NUMERIC MARKER
0B0600 C9     0841* RET
              0842* ;
              0843* ;COS - Cosine function
              0844* ;Result is floating-point numeric.
              0845* ;
0B0601 CD     0846* COS_FP:			CALL    SFLOAT_FP
0B0602 0E 
0B0603 0C 
0B0604 0B 
0B0605 CD     0847* COS0:			CALL    SCALE
0B0606 6A 
0B0607 0B 
0B0608 0B 
0B0609 1C     0848* INC     E
0B060A 1C     0849* INC     E
0B060B 7B     0850* LD      A,E
0B060C 18     0851* JR      SIN1
0B060D 10 
              0852* ;
              0853* ;SIN - Sine function
              0854* ;Result is floating-point numeric.
              0855* ;
0B060E CD     0856* SIN_FP:			CALL    SFLOAT_FP
0B060F 0E 
0B0610 0C 
0B0611 0B 
0B0612 E5     0857* SIN0:			PUSH    HL              ;H7=SIGN
0B0613 CD     0858* CALL    SCALE
0B0614 6A 
0B0615 0B 
0B0616 0B 
0B0617 F1     0859* POP     AF
0B0618 07     0860* RLCA
0B0619 07     0861* RLCA
0B061A 07     0862* RLCA
0B061B E6     0863* AND     4
0B061C 04 
0B061D AB     0864* XOR     E
0B061E F5     0865* SIN1:			PUSH    AF              ;OCTANT
0B061F CB     0866* RES     7,H
0B0620 BC 
0B0621 1F     0867* RRA
0B0622 CD     0868* CALL    PIBY4
0B0623 B0 
0B0624 06 
0B0625 0B 
0B0626 DC     0869* CALL    C,RSUB          ;X=(PI/4)-X
0B0627 51 
0B0628 02 
0B0629 0B 
0B062A F1     0870* POP     AF
0B062B F5     0871* PUSH    AF
0B062C E6     0872* AND     3
0B062D 03 
0B062E E2     0873* JP      PO,SIN2         ;USE COSINE APPROX.
0B062F 67 
0B0630 06 
0B0631 0B 
0B0632 CD     0874* CALL    PUSH5           ;SAVE X
0B0633 1B 
0B0634 0D 
0B0635 0B 
0B0636 CD     0875* CALL    SQUARE          ;PUSH X*X
0B0637 13 
0B0638 0D 
0B0639 0B 
0B063A CD     0876* CALL    POLY
0B063B 58 
0B063C 0D 
0B063D 0B 
0B063E B7     0877* DW	0A8B7H          ;a(8)
0B063F A8 
0B0640 11     0878* DW	3611H
0B0641 36 
0B0642 6D     0879* DB	6DH
0B0643 26     0880* DW	0DE26H          ;a(6)
0B0644 DE 
0B0645 05     0881* DW	0D005H
0B0646 D0 
0B0647 73     0882* DB	73H
0B0648 C0     0883* DW	80C0H           ;a(4)
0B0649 80 
0B064A 88     0884* DW	888H
0B064B 08 
0B064C 79     0885* DB	79H
0B064D 9D     0886* DW	0AA9DH          ;a(2)
0B064E AA 
0B064F AA     0887* DW	0AAAAH
0B0650 AA 
0B0651 7D     0888* DB	7DH
0B0652 00     0889* DW	0               ;a(0)
0B0653 00 
0B0654 00     0890* DW	0
0B0655 00 
0B0656 80     0891* DB	80H
0B0657 CD     0892* CALL    POP5
0B0658 24 
0B0659 0D 
0B065A 0B 
0B065B CD     0893* CALL    POP5
0B065C 24 
0B065D 0D 
0B065E 0B 
0B065F CD     0894* CALL    FMUL
0B0660 76 
0B0661 03 
0B0662 0B 
0B0663 C3     0895* JP      SIN3
0B0664 8C 
0B0665 06 
0B0666 0B 
              0896* ;
0B0667 CD     0897* SIN2:			CALL    SQUARE          ;PUSH X*X
0B0668 13 
0B0669 0D 
0B066A 0B 
0B066B CD     0898* CALL    POLY
0B066C 58 
0B066D 0D 
0B066E 0B 
0B066F 71     0899* DW	0D571H          ;b(8)
0B0670 D5 
0B0671 78     0900* DW	4C78H
0B0672 4C 
0B0673 70     0901* DB	70H
0B0674 AF     0902* DW	94AFH           ;b(6)
0B0675 94 
0B0676 03     0903* DW	0B603H
0B0677 B6 
0B0678 76     0904* DB	76H
0B0679 C8     0905* DW	9CC8H           ;b(4)
0B067A 9C 
0B067B AA     0906* DW	2AAAH
0B067C 2A 
0B067D 7B     0907* DB	7BH
0B067E DD     0908* DW	0FFDDH          ;b(2)
0B067F FF 
0B0680 FF     0909* DW	0FFFFH
0B0681 FF 
0B0682 7E     0910* DB	7EH
0B0683 00     0911* DW	0               ;b(0)
0B0684 00 
0B0685 00     0912* DW	0
0B0686 00 
0B0687 80     0913* DB	80H
0B0688 CD     0914* CALL    POP5
0B0689 24 
0B068A 0D 
0B068B 0B 
0B068C F1     0915* SIN3:			POP     AF
0B068D E6     0916* AND     4
0B068E 04 
0B068F C8     0917* RET     Z
0B0690 0D     0918* DEC     C
0B0691 0C     0919* INC     C
0B0692 C8     0920* RET     Z               ;ZERO
0B0693 CB     0921* SET     7,H             ;MAKE NEGATIVE
0B0694 FC 
0B0695 C9     0922* RET
              0923* ;
              0924* ;Floating-point one:
              0925* ;
0B0696 21     0926* FONE_FP:			LD      HL,0
0B0697 00 
0B0698 00 
0B0699 00 
0B069A D9     0927* EXX
0B069B 21     0928* LD      HL,0
0B069C 00 
0B069D 00 
0B069E 00 
0B069F D9     0929* EXX
0B06A0 0E     0930* LD      C,80H
0B06A1 80 
0B06A2 C9     0931* RET
              0932* ;
0B06A3 11     0933* DONE:			LD      DE,0
0B06A4 00 
0B06A5 00 
0B06A6 00 
0B06A7 D9     0934* EXX
0B06A8 11     0935* LD      DE,0
0B06A9 00 
0B06AA 00 
0B06AB 00 
0B06AC D9     0936* EXX
0B06AD 06     0937* LD      B,80H
0B06AE 80 
0B06AF C9     0938* RET
              0939* ;
0B06B0 11     0940* PIBY4:			LD      DE,490FH
0B06B1 0F 
0B06B2 49 
0B06B3 00 
0B06B4 D9     0941* EXX
0B06B5 11     0942* LD      DE,0DAA2H
0B06B6 A2 
0B06B7 DA 
0B06B8 00 
0B06B9 D9     0943* EXX
0B06BA 06     0944* LD      B,7FH
0B06BB 7F 
0B06BC C9     0945* RET
              0946* ;
              0947* ;EXP - Exponential function
              0948* ;Result is floating-point numeric.
              0949* ;
0B06BD CD     0950* EXP_FP:			CALL    SFLOAT_FP
0B06BE 0E 
0B06BF 0C 
0B06C0 0B 
0B06C1 CD     0951* EXP0:			CALL    LN2             ;LN(2)
0B06C2 4E 
0B06C3 07 
0B06C4 0B 
0B06C5 D9     0952* EXX
0B06C6 1D     0953* DEC     E
0B06C7 01     0954* LD      BC,0D1CFH       ;0.6931471805599453
0B06C8 CF 
0B06C9 D1 
0B06CA 00 
0B06CB D9     0955* EXX
0B06CC E5     0956* PUSH    HL              ;H7=SIGN
0B06CD CD     0957* CALL    MOD48           ;"MODULUS"
0B06CE 7D 
0B06CF 0B 
0B06D0 0B 
0B06D1 F1     0958* POP     AF
0B06D2 CB     0959* BIT     7,E
0B06D3 7B 
0B06D4 28     0960* JR      Z,EXP1
0B06D5 0B 
0B06D6 17     0961* RLA
0B06D7 DA     0962* JP      C,ZERO_FP
0B06D8 8B 
0B06D9 0C 
0B06DA 0B 
0B06DB 3E     0963* LD      A,EXPRNG
0B06DC 18 
0B06DD C3     0964* JP      ERROR_FP_           ;"Exp range"
0B06DE E5 
0B06DF 00 
0B06E0 0B 
              0965* ;
0B06E1 E6     0966* EXP1:			AND     80H
0B06E2 80 
0B06E3 B3     0967* OR      E
0B06E4 F5     0968* PUSH    AF              ;INTEGER PART
0B06E5 CB     0969* RES     7,H
0B06E6 BC 
0B06E7 CD     0970* CALL    PUSH5           ;PUSH X*LN(2)
0B06E8 1B 
0B06E9 0D 
0B06EA 0B 
0B06EB CD     0971* CALL    POLY
0B06EC 58 
0B06ED 0D 
0B06EE 0B 
0B06EF 72     0972* DW	4072H           ;a(7)
0B06F0 40 
0B06F1 2E     0973* DW	942EH
0B06F2 94 
0B06F3 73     0974* DB	73H
0B06F4 65     0975* DW	6F65H           ;a(6)
0B06F5 6F 
0B06F6 4F     0976* DW	2E4FH
0B06F7 2E 
0B06F8 76     0977* DB	76H
0B06F9 37     0978* DW	6D37H           ;a(5)
0B06FA 6D 
0B06FB 02     0979* DW	8802H
0B06FC 88 
0B06FD 79     0980* DB	79H
0B06FE 12     0981* DW	0E512H          ;a(4)
0B06FF E5 
0B0700 A0     0982* DW	2AA0H
0B0701 2A 
0B0702 7B     0983* DB	7BH
0B0703 14     0984* DW	4F14H           ;a(3)
0B0704 4F 
0B0705 AA     0985* DW	0AAAAH
0B0706 AA 
0B0707 7D     0986* DB	7DH
0B0708 56     0987* DW	0FD56H          ;a(2)
0B0709 FD 
0B070A FF     0988* DW	7FFFH
0B070B 7F 
0B070C 7E     0989* DB	7EH
0B070D FE     0990* DW	0FFFEH          ;a(1)
0B070E FF 
0B070F FF     0991* DW	0FFFFH
0B0710 FF 
0B0711 7F     0992* DB	7FH
0B0712 00     0993* DW	0               ;a(0)
0B0713 00 
0B0714 00     0994* DW	0
0B0715 00 
0B0716 80     0995* DB	80H
0B0717 CD     0996* CALL    POP5
0B0718 24 
0B0719 0D 
0B071A 0B 
0B071B F1     0997* POP     AF
0B071C F5     0998* PUSH    AF
0B071D F4     0999* CALL    P,RECIP         ;X=1/X
0B071E 42 
0B071F 07 
0B0720 0B 
0B0721 F1     1000* POP     AF
0B0722 F2     1001* JP      P,EXP4
0B0723 2A 
0B0724 07 
0B0725 0B 
0B0726 E6     1002* AND     7FH
0B0727 7F 
0B0728 ED     1003* NEG
0B0729 44 
0B072A C6     1004* EXP4:			ADD     A,80H
0B072B 80 
0B072C 81     1005* ADD     A,C
0B072D 38     1006* JR      C,EXP2
0B072E 06 
0B072F F2     1007* JP      P,ZERO_FP          ;UNDERFLOW
0B0730 8B 
0B0731 0C 
0B0732 0B 
0B0733 18     1008* JR      EXP3
0B0734 04 
0B0735 FA     1009* EXP2:			JP      M,OFLOW         ;OVERFLOW
0B0736 56 
0B0737 0C 
0B0738 0B 
0B0739 C6     1010* EXP3:			ADD     A,80H
0B073A 80 
0B073B CA     1011* JP      Z,ZERO_FP
0B073C 8B 
0B073D 0C 
0B073E 0B 
0B073F 4F     1012* LD      C,A
0B0740 AF     1013* XOR     A               ;NUMERIC MARKER
0B0741 C9     1014* RET
              1015* ;
0B0742 CD     1016* RECIP:			CALL    DONE
0B0743 A3 
0B0744 06 
0B0745 0B 
0B0746 CD     1017* RDIV:			CALL    SWAP_FP
0B0747 3F 
0B0748 0C 
0B0749 0B 
0B074A C3     1018* JP      FDIV            ;RECIPROCAL
0B074B CD 
0B074C 02 
0B074D 0B 
              1019* ;
0B074E 11     1020* LN2:			LD      DE,3172H        ;LN(2)
0B074F 72 
0B0750 31 
0B0751 00 
0B0752 D9     1021* EXX
0B0753 11     1022* LD      DE,17F8H
0B0754 F8 
0B0755 17 
0B0756 00 
0B0757 D9     1023* EXX
0B0758 06     1024* LD      B,7FH
0B0759 7F 
0B075A C9     1025* RET
              1026* ;
              1027* ;LN - Natural log.
              1028* ;Result is floating-point numeric.
              1029* ;
0B075B CD     1030* LN_FP:			CALL    SFLOAT_FP
0B075C 0E 
0B075D 0C 
0B075E 0B 
0B075F 3E     1031* LN0:			LD      A,LOGRNG
0B0760 16 
0B0761 CB     1032* BIT     7,H
0B0762 7C 
0B0763 C2     1033* JP      NZ,ERROR_FP_        ;"Log range"
0B0764 E5 
0B0765 00 
0B0766 0B 
0B0767 0C     1034* INC     C
0B0768 0D     1035* DEC     C
0B0769 CA     1036* JP      Z,ERROR_FP_
0B076A E5 
0B076B 00 
0B076C 0B 
0B076D 11     1037* LD      DE,3504H        ;SQR(2)
0B076E 04 
0B076F 35 
0B0770 00 
0B0771 D9     1038* EXX
0B0772 11     1039* LD      DE,0F333H       ;1.41421356237
0B0773 33 
0B0774 F3 
0B0775 00 
0B0776 D9     1040* EXX
0B0777 CD     1041* CALL    ICP0            ;MANTISSA>SQR(2)?
0B0778 9E 
0B0779 0C 
0B077A 0B 
0B077B 79     1042* LD      A,C             ;EXPONENT
0B077C 0E     1043* LD      C,80H           ;1 <= X < 2
0B077D 80 
0B077E 38     1044* JR      C,LN4
0B077F 02 
0B0780 0D     1045* DEC     C
0B0781 3C     1046* INC     A
0B0782 F5     1047* LN4:			PUSH    AF              ;SAVE EXPONENT
0B0783 CD     1048* CALL    RATIO           ;X=(X-1)/(X+1)
0B0784 30 
0B0785 0D 
0B0786 0B 
0B0787 CD     1049* CALL    PUSH5
0B0788 1B 
0B0789 0D 
0B078A 0B 
0B078B CD     1050* CALL    SQUARE          ;PUSH X*X
0B078C 13 
0B078D 0D 
0B078E 0B 
0B078F CD     1051* CALL    POLY
0B0790 58 
0B0791 0D 
0B0792 0B 
0B0793 48     1052* DW	0CC48H          ;a(9)
0B0794 CC 
0B0795 FB     1053* DW	74FBH
0B0796 74 
0B0797 7D     1054* DB	7DH
0B0798 AF     1055* DW	0AEAFH          ;a(7)
0B0799 AE 
0B079A FF     1056* DW	11FFH
0B079B 11 
0B079C 7E     1057* DB	7EH
0B079D 8C     1058* DW	0D98CH          ;a(5)
0B079E D9 
0B079F CD     1059* DW	4CCDH
0B07A0 4C 
0B07A1 7E     1060* DB	7EH
0B07A2 E3     1061* DW	0A9E3H          ;a(3)
0B07A3 A9 
0B07A4 AA     1062* DW	2AAAH
0B07A5 2A 
0B07A6 7F     1063* DB	7FH
0B07A7 00     1064* DW	0               ;a(1)
0B07A8 00 
0B07A9 00     1065* DW	0
0B07AA 00 
0B07AB 81     1066* DB	81H
0B07AC CD     1067* CALL    POP5
0B07AD 24 
0B07AE 0D 
0B07AF 0B 
0B07B0 CD     1068* CALL    POP5
0B07B1 24 
0B07B2 0D 
0B07B3 0B 
0B07B4 CD     1069* CALL    FMUL
0B07B5 76 
0B07B6 03 
0B07B7 0B 
0B07B8 F1     1070* POP     AF              ;EXPONENT
0B07B9 CD     1071* CALL    PUSH5
0B07BA 1B 
0B07BB 0D 
0B07BC 0B 
0B07BD 08     1072* EX      AF,AF'
0B07BE CD     1073* CALL    ZERO_FP
0B07BF 8B 
0B07C0 0C 
0B07C1 0B 
0B07C2 08     1074* EX      AF,AF'
0B07C3 D6     1075* SUB     80H
0B07C4 80 
0B07C5 28     1076* JR      Z,LN3
0B07C6 1F 
0B07C7 30     1077* JR      NC,LN1
0B07C8 02 
0B07C9 2F     1078* CPL
0B07CA 3C     1079* INC     A
0B07CB 67     1080* LN1:			LD      H,A
0B07CC 0E     1081* LD      C,87H
0B07CD 87 
0B07CE F5     1082* PUSH    AF
0B07CF CD     1083* CALL    FLOAT_
0B07D0 EE 
0B07D1 0B 
0B07D2 0B 
0B07D3 CB     1084* RES     7,H
0B07D4 BC 
0B07D5 CD     1085* CALL    LN2
0B07D6 4E 
0B07D7 07 
0B07D8 0B 
0B07D9 CD     1086* CALL    FMUL
0B07DA 76 
0B07DB 03 
0B07DC 0B 
0B07DD F1     1087* POP     AF
0B07DE 30     1088* JR      NC,LN3
0B07DF 06 
0B07E0 FA     1089* JP      M,LN3
0B07E1 E6 
0B07E2 07 
0B07E3 0B 
0B07E4 CB     1090* SET     7,H
0B07E5 FC 
0B07E6 CD     1091* LN3:			CALL    POP5
0B07E7 24 
0B07E8 0D 
0B07E9 0B 
0B07EA CD     1092* CALL    FADD
0B07EB 64 
0B07EC 02 
0B07ED 0B 
0B07EE AF     1093* XOR     A
0B07EF C9     1094* RET
              1095* ;
              1096* ;LOG - base-10 logarithm.
              1097* ;Result is floating-point numeric.
              1098* ;
0B07F0 CD     1099* LOG_FP:			CALL    LN_FP
0B07F1 5B 
0B07F2 07 
0B07F3 0B 
0B07F4 11     1100* LD      DE,5E5BH        ;LOG(e)
0B07F5 5B 
0B07F6 5E 
0B07F7 00 
0B07F8 D9     1101* EXX
0B07F9 11     1102* LD      DE,0D8A9H
0B07FA A9 
0B07FB D8 
0B07FC 00 
0B07FD D9     1103* EXX
0B07FE 06     1104* LD      B,7EH
0B07FF 7E 
0B0800 CD     1105* CALL    FMUL
0B0801 76 
0B0802 03 
0B0803 0B 
0B0804 AF     1106* XOR     A
0B0805 C9     1107* RET
              1108* ;
              1109* ;ASN - Arc-sine
              1110* ;Result is floating-point numeric.
              1111* ;
0B0806 CD     1112* ASN_FP:			CALL    SFLOAT_FP
0B0807 0E 
0B0808 0C 
0B0809 0B 
0B080A CD     1113* CALL    PUSH5
0B080B 1B 
0B080C 0D 
0B080D 0B 
0B080E CD     1114* CALL    COPY_
0B080F 0B 
0B0810 0D 
0B0811 0B 
0B0812 CD     1115* CALL    FMUL
0B0813 76 
0B0814 03 
0B0815 0B 
0B0816 CD     1116* CALL    DONE
0B0817 A3 
0B0818 06 
0B0819 0B 
0B081A CD     1117* CALL    RSUB
0B081B 51 
0B081C 02 
0B081D 0B 
0B081E CD     1118* CALL    SQR0
0B081F 81 
0B0820 05 
0B0821 0B 
0B0822 CD     1119* CALL    POP5
0B0823 24 
0B0824 0D 
0B0825 0B 
0B0826 0C     1120* INC     C
0B0827 0D     1121* DEC     C
0B0828 3E     1122* LD      A,2
0B0829 02 
0B082A D5     1123* PUSH    DE
0B082B CA     1124* JP      Z,ACS1
0B082C B0 
0B082D 08 
0B082E 0B 
0B082F D1     1125* POP     DE
0B0830 CD     1126* CALL    RDIV
0B0831 46 
0B0832 07 
0B0833 0B 
0B0834 18     1127* JR      ATN0
0B0835 04 
              1128* ;
              1129* ;ATN - arc-tangent
              1130* ;Result is floating-point numeric.
              1131* ;
0B0836 CD     1132* ATN_FP:			CALL    SFLOAT_FP
0B0837 0E 
0B0838 0C 
0B0839 0B 
0B083A E5     1133* ATN0:			PUSH    HL              ;SAVE SIGN
0B083B CB     1134* RES     7,H
0B083C BC 
0B083D 11     1135* LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B083E 13 
0B083F 54 
0B0840 00 
0B0841 D9     1136* EXX
0B0842 11     1137* LD      DE,0CCD0H
0B0843 D0 
0B0844 CC 
0B0845 00 
0B0846 D9     1138* EXX
0B0847 06     1139* LD      B,7EH
0B0848 7E 
0B0849 CD     1140* CALL    FCP0            ;COMPARE
0B084A 9B 
0B084B 0C 
0B084C 0B 
0B084D 06     1141* LD      B,0
0B084E 00 
0B084F 38     1142* JR      C,ATN2
0B0850 22 
0B0851 11     1143* LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B0852 82 
0B0853 1A 
0B0854 00 
0B0855 D9     1144* EXX
0B0856 11     1145* LD      DE,799AH
0B0857 9A 
0B0858 79 
0B0859 00 
0B085A D9     1146* EXX
0B085B 06     1147* LD      B,81H
0B085C 81 
0B085D CD     1148* CALL    FCP0            ;COMPARE
0B085E 9B 
0B085F 0C 
0B0860 0B 
0B0861 38     1149* JR      C,ATN1
0B0862 0A 
0B0863 CD     1150* CALL    RECIP           ;X=1/X
0B0864 42 
0B0865 07 
0B0866 0B 
0B0867 06     1151* LD      B,2
0B0868 02 
0B0869 C3     1152* JP      ATN2
0B086A 73 
0B086B 08 
0B086C 0B 
0B086D CD     1153* ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B086E 30 
0B086F 0D 
0B0870 0B 
0B0871 06     1154* LD      B,1
0B0872 01 
0B0873 C5     1155* ATN2:			PUSH    BC              ;SAVE FLAG
0B0874 CD     1156* CALL    PUSH5
0B0875 1B 
0B0876 0D 
0B0877 0B 
0B0878 CD     1157* CALL    SQUARE          ;PUSH X*X
0B0879 13 
0B087A 0D 
0B087B 0B 
0B087C CD     1158* CALL    POLY
0B087D 58 
0B087E 0D 
0B087F 0B 
0B0880 35     1159* DW	0F335H          ;a(13)
0B0881 F3 
0B0882 D8     1160* DW	37D8H
0B0883 37 
0B0884 7B     1161* DB	7BH
0B0885 91     1162* DW	6B91H           ;a(11)
0B0886 6B 
0B0887 B9     1163* DW	0AAB9H
0B0888 AA 
0B0889 7C     1164* DB	7CH
0B088A DE     1165* DW	41DEH           ;a(9)
0B088B 41 
0B088C 97     1166* DW	6197H
0B088D 61 
0B088E 7C     1167* DB	7CH
0B088F 7B     1168* DW	9D7BH           ;a(7)
0B0890 9D 
0B0891 37     1169* DW	9237H
0B0892 92 
0B0893 7D     1170* DB	7DH
0B0894 5A     1171* DW	2A5AH           ;a(5)
0B0895 2A 
0B0896 CC     1172* DW	4CCCH
0B0897 4C 
0B0898 7D     1173* DB	7DH
0B0899 5C     1174* DW	0A95CH          ;a(3)
0B089A A9 
0B089B AA     1175* DW	0AAAAH
0B089C AA 
0B089D 7E     1176* DB	7EH
0B089E 00     1177* DW	0               ;a(1)
0B089F 00 
0B08A0 00     1178* DW	0
0B08A1 00 
0B08A2 80     1179* DB	80H
0B08A3 CD     1180* CALL    POP5
0B08A4 24 
0B08A5 0D 
0B08A6 0B 
0B08A7 CD     1181* CALL    POP5
0B08A8 24 
0B08A9 0D 
0B08AA 0B 
0B08AB CD     1182* CALL    FMUL
0B08AC 76 
0B08AD 03 
0B08AE 0B 
0B08AF F1     1183* POP     AF
0B08B0 CD     1184* ACS1:			CALL    PIBY4           ;PI/4
0B08B1 B0 
0B08B2 06 
0B08B3 0B 
0B08B4 1F     1185* RRA
0B08B5 F5     1186* PUSH    AF
0B08B6 DC     1187* CALL    C,FADD
0B08B7 64 
0B08B8 02 
0B08B9 0B 
0B08BA F1     1188* POP     AF
0B08BB 04     1189* INC     B
0B08BC 1F     1190* RRA
0B08BD DC     1191* CALL    C,RSUB
0B08BE 51 
0B08BF 02 
0B08C0 0B 
0B08C1 F1     1192* POP     AF
0B08C2 B7     1193* OR      A
0B08C3 F0     1194* RET     P
0B08C4 CB     1195* SET     7,H             ;MAKE NEGATIVE
0B08C5 FC 
0B08C6 AF     1196* XOR     A
0B08C7 C9     1197* RET
              1198* ;
              1199* ;ACS - Arc cosine=PI/2-ASN.
              1200* ;Result is floating point numeric.
              1201* ;
0B08C8 CD     1202* ACS_FP:			CALL    ASN_FP
0B08C9 06 
0B08CA 08 
0B08CB 0B 
0B08CC 3E     1203* LD      A,2
0B08CD 02 
0B08CE F5     1204* PUSH    AF
0B08CF 18     1205* JR      ACS1
0B08D0 DF 
              1206* ;
              1207* ;Function STR - convert numeric value to ASCII string.
              1208* ;   Inputs: HLH'L'C = integer or floating-point number
              1209* ;           DE = address at which to store string
              1210* ;           IX = address of @% format control
              1211* ;  Outputs: String stored, with NUL terminator
              1212* ;
              1213* ;First normalise for decimal output:
              1214* ;
0B08D1 CD     1215* STR_FP:			CALL    SFLOAT_FP
0B08D2 0E 
0B08D3 0C 
0B08D4 0B 
0B08D5 06     1216* LD      B,0             ;DEFAULT PT. POSITION
0B08D6 00 
0B08D7 CB     1217* BIT     7,H             ;NEGATIVE?
0B08D8 7C 
0B08D9 28     1218* JR      Z,STR10
0B08DA 06 
0B08DB CB     1219* RES     7,H
0B08DC BC 
0B08DD 3E     1220* LD      A,'-'
0B08DE 2D 
0B08DF 12     1221* LD      (DE),A          ;STORE SIGN
0B08E0 13     1222* INC     DE
0B08E1 AF     1223* STR10:			XOR     A               ;CLEAR A
0B08E2 B9     1224* CP      C
0B08E3 28     1225* JR      Z,STR02          ;ZERO
0B08E4 4E 
0B08E5 D5     1226* PUSH    DE              ;SAVE TEXT POINTER
0B08E6 78     1227* LD      A,B
0B08E7 F5     1228* STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B08E8 79     1229* LD      A,C             ;BINARY EXPONENT
0B08E9 FE     1230* CP      161
0B08EA A1 
0B08EB 30     1231* JR      NC,STR14
0B08EC 1C 
0B08ED FE     1232* CP      155
0B08EE 9B 
0B08EF 30     1233* JR      NC,STR15
0B08F0 29 
0B08F1 2F     1234* CPL
0B08F2 FE     1235* CP      225
0B08F3 E1 
0B08F4 38     1236* JR      C,STR13
0B08F5 02 
0B08F6 3E     1237* LD      A,-8
0B08F7 F8 
0B08F8 C6     1238* STR13:			ADD     A,28
0B08F9 1C 
0B08FA CD     1239* CALL    POWR10
0B08FB 87 
0B08FC 0D 
0B08FD 0B 
0B08FE F5     1240* PUSH    AF
0B08FF CD     1241* CALL    FMUL
0B0900 76 
0B0901 03 
0B0902 0B 
0B0903 F1     1242* POP     AF
0B0904 47     1243* LD      B,A
0B0905 F1     1244* POP     AF
0B0906 90     1245* SUB     B
0B0907 18     1246* JR      STR11
0B0908 DE 
0B0909 D6     1247* STR14:			SUB     32
0B090A 20 
0B090B CD     1248* CALL    POWR10
0B090C 87 
0B090D 0D 
0B090E 0B 
0B090F F5     1249* PUSH    AF
0B0910 CD     1250* CALL    FDIV
0B0911 CD 
0B0912 02 
0B0913 0B 
0B0914 F1     1251* POP     AF
0B0915 47     1252* LD      B,A
0B0916 F1     1253* POP     AF
0B0917 80     1254* ADD     A,B
0B0918 18     1255* JR      STR11
0B0919 CD 
0B091A 3E     1256* STR15:			LD      A,9
0B091B 09 
0B091C CD     1257* CALL    POWR10          ;10^9
0B091D 87 
0B091E 0D 
0B091F 0B 
0B0920 CD     1258* CALL    FCP0
0B0921 9B 
0B0922 0C 
0B0923 0B 
0B0924 79     1259* LD      A,C
0B0925 C1     1260* POP     BC
0B0926 4F     1261* LD      C,A
0B0927 CB     1262* SET     7,H             ;IMPLIED 1
0B0928 FC 
0B0929 DC     1263* CALL    C,X10B          ;X10, DEC B
0B092A C3 
0B092B 0C 
0B092C 0B 
0B092D D1     1264* POP     DE              ;RESTORE TEXT POINTER
0B092E CB     1265* RES     7,C
0B092F B9 
0B0930 3E     1266* LD      A,0
0B0931 00 
0B0932 17     1267* RLA                     ;PUT CARRY IN LSB
              1268* ;
              1269* ;At this point decimal normalisation has been done,
              1270* ;now convert to decimal digits:
              1271* ;      AHLH'L' = number in normalised integer form
              1272* ;            B = decimal place adjustment
              1273* ;            C = binary place adjustment (29-33)
              1274* ;
0B0933 0C     1275* STR02:			INC     C
0B0934 08     1276* EX      AF,AF'          ;SAVE A
0B0935 78     1277* LD      A,B
0B0936 DD     1278* BIT     1,(IX+2)
0B0937 CB 
0B0938 02 
0B0939 4E 
0B093A 20     1279* JR      NZ,STR20
0B093B 08 
0B093C AF     1280* XOR     A
0B093D DD     1281* CP      (IX+1)
0B093E BE 
0B093F 01 
0B0940 28     1282* JR      Z,STR21
0B0941 0B 
0B0942 3E     1283* LD      A,-10
0B0943 F6 
0B0944 DD     1284* STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B0945 86 
0B0946 01 
0B0947 B7     1285* OR      A               ;CLEAR CARRY
0B0948 FA     1286* JP      M,STR21
0B0949 4D 
0B094A 09 
0B094B 0B 
0B094C AF     1287* XOR     A
0B094D F5     1288* STR21:			PUSH    AF
0B094E 08     1289* EX      AF,AF'          ;RESTORE A
0B094F CD     1290* STR22:			CALL    X2              ;RL AHLH'L'
0B0950 F7 
0B0951 0C 
0B0952 0B 
0B0953 8F     1291* ADC     A,A
0B0954 FE     1292* CP      10
0B0955 0A 
0B0956 38     1293* JR      C,STR23
0B0957 05 
0B0958 D6     1294* SUB     10
0B0959 0A 
0B095A D9     1295* EXX
0B095B 2C     1296* INC     L               ;SET RESULT BIT
0B095C D9     1297* EXX
0B095D 0D     1298* STR23:			DEC     C
0B095E 20     1299* JR      NZ,STR22        ;32 TIMES
0B095F EF 
0B0960 4F     1300* LD      C,A             ;REMAINDER
0B0961 7C     1301* LD      A,H
0B0962 E6     1302* AND     3FH             ;CLEAR OUT JUNK
0B0963 3F 
0B0964 67     1303* LD      H,A
0B0965 F1     1304* POP     AF
0B0966 F2     1305* JP      P,STR24
0B0967 74 
0B0968 09 
0B0969 0B 
0B096A 3C     1306* INC     A
0B096B 20     1307* JR      NZ,STR26
0B096C 1C 
0B096D 3E     1308* LD      A,4
0B096E 04 
0B096F B9     1309* CP      C               ;ROUND UP?
0B0970 3E     1310* LD      A,0
0B0971 00 
0B0972 18     1311* JR      STR26
0B0973 15 
0B0974 F5     1312* STR24:			PUSH    AF
0B0975 79     1313* LD      A,C
0B0976 CE     1314* ADC     A,'0'           ;ADD CARRY
0B0977 30 
0B0978 FE     1315* CP      '0'
0B0979 30 
0B097A 28     1316* JR      Z,STR25         ;SUPPRESS ZERO
0B097B 05 
0B097C FE     1317* CP      '9'+1
0B097D 3A 
0B097E 3F     1318* CCF
0B097F 30     1319* JR      NC,STR26
0B0980 08 
0B0981 E3     1320* STR25:			EX      (SP),HL
0B0982 CB     1321* BIT     6,L             ;ZERO FLAG
0B0983 75 
0B0984 E3     1322* EX      (SP),HL
0B0985 20     1323* JR      NZ,STR27
0B0986 05 
0B0987 3E     1324* LD      A,'0'
0B0988 30 
0B0989 3C     1325* STR26:			INC     A               ;SET +VE
0B098A 3D     1326* DEC     A
0B098B F5     1327* PUSH    AF              ;PUT ON STACK + CARRY
0B098C 04     1328* STR27:			INC     B
0B098D CD     1329* CALL    TEST_FP            ;IS HLH'L' ZERO?
0B098E 67 
0B098F 0C 
0B0990 0B 
0B0991 0E     1330* LD      C,32
0B0992 20 
0B0993 3E     1331* LD      A,0
0B0994 00 
0B0995 20     1332* JR      NZ,STR22
0B0996 B8 
0B0997 F1     1333* POP     AF
0B0998 F5     1334* PUSH    AF
0B0999 3E     1335* LD      A,0
0B099A 00 
0B099B 38     1336* JR      C,STR22
0B099C B2 
              1337* ;
              1338* ;At this point, the decimal character string is stored
              1339* ; on the stack. Trailing zeroes are suppressed and may
              1340* ; need to be replaced.
              1341* ;B register holds decimal point position.
              1342* ;Now format number and store as ASCII string:
              1343* ;
0B099D EB     1344* STR3:			EX      DE,HL           ;STRING POINTER
0B099E 0E     1345* LD      C,-1            ;FLAG "E"
0B099F FF 
0B09A0 16     1346* LD      D,1
0B09A1 01 
0B09A2 DD     1347* LD      E,(IX+1)        ;f2
0B09A3 5E 
0B09A4 01 
0B09A5 DD     1348* BIT     0,(IX+2)
0B09A6 CB 
0B09A7 02 
0B09A8 46 
0B09A9 20     1349* JR      NZ,STR34        ;E MODE
0B09AA 35 
0B09AB DD     1350* BIT     1,(IX+2)
0B09AC CB 
0B09AD 02 
0B09AE 4E 
0B09AF 28     1351* JR      Z,STR31
0B09B0 12 
0B09B1 78     1352* LD      A,B             ;F MODE
0B09B2 B7     1353* OR      A
0B09B3 28     1354* JR      Z,STR30
0B09B4 05 
0B09B5 FA     1355* JP      M,STR30
0B09B6 BA 
0B09B7 09 
0B09B8 0B 
0B09B9 50     1356* LD      D,B
0B09BA 7A     1357* STR30:			LD      A,D
0B09BB DD     1358* ADD     A,(IX+1)
0B09BC 86 
0B09BD 01 
0B09BE 5F     1359* LD      E,A
0B09BF FE     1360* CP      11
0B09C0 0B 
0B09C1 38     1361* JR      C,STR32
0B09C2 19 
0B09C3 78     1362* STR31:			LD      A,B             ;G MODE
0B09C4 11     1363* LD      DE,101H
0B09C5 01 
0B09C6 01 
0B09C7 00 
0B09C8 B7     1364* OR      A
0B09C9 FA     1365* JP      M,STR34
0B09CA E0 
0B09CB 09 
0B09CC 0B 
0B09CD 28     1366* JR      Z,STR32
0B09CE 0D 
0B09CF DD     1367* LD      A,(IX+1)
0B09D0 7E 
0B09D1 01 
0B09D2 B7     1368* OR      A
0B09D3 20     1369* JR      NZ,STR3A
0B09D4 02 
0B09D5 3E     1370* LD      A,10
0B09D6 0A 
0B09D7 B8     1371* STR3A:			CP      B
0B09D8 38     1372* JR      C,STR34
0B09D9 06 
0B09DA 50     1373* LD      D,B
0B09DB 58     1374* LD      E,B
0B09DC 78     1375* STR32:			LD      A,B
0B09DD C6     1376* ADD     A,129
0B09DE 81 
0B09DF 4F     1377* LD      C,A
0B09E0 CB     1378* STR34:			SET     7,D
0B09E1 FA 
0B09E2 1D     1379* DEC     E
0B09E3 7A     1380* STR35:			LD      A,D
0B09E4 B9     1381* CP      C
0B09E5 30     1382* JR      NC,STR33
0B09E6 0E 
0B09E7 F1     1383* STR36:			POP     AF
0B09E8 28     1384* JR      Z,STR37
0B09E9 04 
0B09EA F2     1385* JP      P,STR38
0B09EB F7 
0B09EC 09 
0B09ED 0B 
0B09EE F5     1386* STR37:			PUSH    AF
0B09EF 1C     1387* INC     E
0B09F0 1D     1388* DEC     E
0B09F1 FA     1389* JP      M,STR4
0B09F2 08 
0B09F3 0A 
0B09F4 0B 
0B09F5 3E     1390* STR33:			LD      A,'0'
0B09F6 30 
0B09F7 15     1391* STR38:			DEC     D
0B09F8 E2     1392* JP      PO,STR39
0B09F9 FF 
0B09FA 09 
0B09FB 0B 
0B09FC 36     1393* LD      (HL),'.'
0B09FD 2E 
0B09FE 23     1394* INC     HL
0B09FF 77     1395* STR39:			LD      (HL),A
0B0A00 23     1396* INC     HL
0B0A01 1D     1397* DEC     E
0B0A02 F2     1398* JP      P,STR35
0B0A03 E3 
0B0A04 09 
0B0A05 0B 
0B0A06 18     1399* JR      STR36
0B0A07 DF 
              1400* ;
0B0A08 F1     1401* STR4:			POP     AF
0B0A09 0C     1402* STR40:			INC     C
0B0A0A 4D     1403* LD      C,L
0B0A0B 20     1404* JR      NZ,STR44
0B0A0C 28 
0B0A0D 36     1405* LD      (HL),'E'        ;EXPONENT
0B0A0E 45 
0B0A0F 23     1406* INC     HL
0B0A10 78     1407* LD      A,B
0B0A11 3D     1408* DEC     A
0B0A12 F2     1409* JP      P,STR41
0B0A13 1B 
0B0A14 0A 
0B0A15 0B 
0B0A16 36     1410* LD      (HL),'-'
0B0A17 2D 
0B0A18 23     1411* INC     HL
0B0A19 ED     1412* NEG
0B0A1A 44 
0B0A1B 36     1413* STR41:			LD      (HL),'0'
0B0A1C 30 
0B0A1D 28     1414* JR      Z,STR47
0B0A1E 15 
0B0A1F FE     1415* CP      10
0B0A20 0A 
0B0A21 47     1416* LD      B,A
0B0A22 3E     1417* LD      A,':'
0B0A23 3A 
0B0A24 38     1418* JR      C,STR42
0B0A25 03 
0B0A26 23     1419* INC     HL
0B0A27 36     1420* LD      (HL),'0'
0B0A28 30 
0B0A29 34     1421* STR42:			INC     (HL)
0B0A2A BE     1422* CP      (HL)
0B0A2B 20     1423* JR      NZ,STR43
0B0A2C 05 
0B0A2D 36     1424* LD      (HL),'0'
0B0A2E 30 
0B0A2F 2B     1425* DEC     HL
0B0A30 34     1426* INC     (HL)
0B0A31 23     1427* INC     HL
0B0A32 10     1428* STR43:			DJNZ    STR42
0B0A33 F5 
0B0A34 23     1429* STR47:			INC     HL
0B0A35 EB     1430* STR44:			EX      DE,HL
0B0A36 C9     1431* RET
              1432* ;
              1433* ;Support subroutines:
              1434* ;
0B0A37 DD     1435* DLOAD5:			LD      B,(IX+4)
0B0A38 46 
0B0A39 04 
0B0A3A D9     1436* EXX
0B0A3B DD     1437* LD      E,(IX+0)
0B0A3C 5E 
0B0A3D 00 
0B0A3E DD     1438* LD      D,(IX+1)
0B0A3F 56 
0B0A40 01 
0B0A41 D9     1439* EXX
0B0A42 DD     1440* LD      E,(IX+2)
0B0A43 5E 
0B0A44 02 
0B0A45 DD     1441* LD      D,(IX+3)
0B0A46 56 
0B0A47 03 
0B0A48 C9     1442* RET
              1443* ;
0B0A49 DD     1444* DLOAD5_SPL:		LD      B,(IX+6)
0B0A4A 46 
0B0A4B 06 
0B0A4C D9     1445* EXX
0B0A4D DD     1446* LD	DE, (IX+0)
0B0A4E 17 
0B0A4F 00 
0B0A50 D9     1447* EXX
0B0A51 DD     1448* LD	DE, (IX+3)
0B0A52 17 
0B0A53 03 
0B0A54 C9     1449* RET
              1450* ;
              1451* ;CON_FP - Get unsigned numeric constant from ASCII string.
              1452* ;   Inputs: ASCII string at (IX).
              1453* ;  Outputs: Variable-type result in HLH'L'C
              1454* ;           IX updated (points to delimiter)
              1455* ;           A7 = 0 (numeric marker)
              1456* ;
0B0A55 CD     1457* CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B0A56 8B 
0B0A57 0C 
0B0A58 0B 
0B0A59 0E     1458* LD      C,0             ;TRUNCATION COUNTER
0B0A5A 00 
0B0A5B CD     1459* CALL    UINT          ;GET INTEGER PART
0B0A5C E9 
0B0A5D 0A 
0B0A5E 0B 
0B0A5F FE     1460* CP      '.'
0B0A60 2E 
0B0A61 06     1461* LD      B,0             ;DECL. PLACE COUNTER
0B0A62 00 
0B0A63 CC     1462* CALL    Z,NUMBIX        ;GET FRACTION PART
0B0A64 E7 
0B0A65 0A 
0B0A66 0B 
0B0A67 FE     1463* CP      'E'
0B0A68 45 
0B0A69 3E     1464* LD      A,0             ;INITIALISE EXPONENT
0B0A6A 00 
0B0A6B CC     1465* CALL    Z,GETEXP        ;GET EXPONENT
0B0A6C B5 
0B0A6D 0A 
0B0A6E 0B 
0B0A6F CB     1466* BIT     7,H
0B0A70 7C 
0B0A71 20     1467* JR      NZ,CON0         ;INTEGER OVERFLOW
0B0A72 08 
0B0A73 B7     1468* OR      A
0B0A74 20     1469* JR      NZ,CON0         ;EXPONENT NON-ZERO
0B0A75 05 
0B0A76 B8     1470* CP      B
0B0A77 20     1471* JR      NZ,CON0         ;DECIMAL POINT
0B0A78 02 
0B0A79 B9     1472* CP      C
0B0A7A C8     1473* RET     Z               ;INTEGER
0B0A7B 90     1474* CON0:			SUB     B
0B0A7C 81     1475* ADD     A,C
0B0A7D 0E     1476* LD      C,159
0B0A7E 9F 
0B0A7F CD     1477* CALL    FLOAT_
0B0A80 EE 
0B0A81 0B 
0B0A82 0B 
0B0A83 CB     1478* RES     7,H             ;DITCH IMPLIED 1
0B0A84 BC 
0B0A85 B7     1479* OR      A
0B0A86 C8     1480* RET     Z               ;DONE
0B0A87 FA     1481* JP      M,CON2          ;NEGATIVE EXPONENT
0B0A88 95 
0B0A89 0A 
0B0A8A 0B 
0B0A8B CD     1482* CALL    POWR10
0B0A8C 87 
0B0A8D 0D 
0B0A8E 0B 
0B0A8F CD     1483* CALL    FMUL            ;SCALE
0B0A90 76 
0B0A91 03 
0B0A92 0B 
0B0A93 AF     1484* XOR     A
0B0A94 C9     1485* RET
0B0A95 FE     1486* CON2:			CP      -38
0B0A96 DA 
0B0A97 38     1487* JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B0A98 0C 
0B0A99 ED     1488* NEG
0B0A9A 44 
0B0A9B CD     1489* CALL    POWR10
0B0A9C 87 
0B0A9D 0D 
0B0A9E 0B 
0B0A9F CD     1490* CALL    FDIV            ;SCALE
0B0AA0 CD 
0B0AA1 02 
0B0AA2 0B 
0B0AA3 AF     1491* XOR     A
0B0AA4 C9     1492* RET
0B0AA5 F5     1493* CON3:			PUSH    AF
0B0AA6 3E     1494* LD      A,38
0B0AA7 26 
0B0AA8 CD     1495* CALL    POWR10
0B0AA9 87 
0B0AAA 0D 
0B0AAB 0B 
0B0AAC CD     1496* CALL    FDIV
0B0AAD CD 
0B0AAE 02 
0B0AAF 0B 
0B0AB0 F1     1497* POP     AF
0B0AB1 C6     1498* ADD     A,38
0B0AB2 26 
0B0AB3 18     1499* JR      CON2
0B0AB4 E0 
              1500* ;
              1501* ;GETEXP - Get decimal exponent from string
              1502* ;     Inputs: ASCII string at (IX)
              1503* ;             (IX points at 'E')
              1504* ;             A = initial value
              1505* ;    Outputs: A = new exponent
              1506* ;             IX updated.
              1507* ;   Destroys: A,A',IX,F,F'
              1508* ;
0B0AB5 C5     1509* GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B0AB6 47     1510* LD      B,A             ;INITIAL VALUE
0B0AB7 0E     1511* LD      C,2             ;2 DIGITS MAX
0B0AB8 02 
0B0AB9 DD     1512* INC     IX              ;BUMP PAST 'E'
0B0ABA 23 
0B0ABB CD     1513* CALL    SIGNQ
0B0ABC A5 
0B0ABD 0E 
0B0ABE 0B 
0B0ABF 08     1514* EX      AF,AF'          ;SAVE EXPONENT SIGN
0B0AC0 CD     1515* GETEX1:			CALL    DIGITQ
0B0AC1 9B 
0B0AC2 0E 
0B0AC3 0B 
0B0AC4 38     1516* JR      C,GETEX2
0B0AC5 18 
0B0AC6 78     1517* LD      A,B             ;B=B*10
0B0AC7 87     1518* ADD     A,A
0B0AC8 87     1519* ADD     A,A
0B0AC9 80     1520* ADD     A,B
0B0ACA 87     1521* ADD     A,A
0B0ACB 47     1522* LD      B,A
0B0ACC DD     1523* LD      A,(IX)          ;GET BACK DIGIT
0B0ACD 7E 
0B0ACE 00 
0B0ACF DD     1524* INC     IX
0B0AD0 23 
0B0AD1 E6     1525* AND     0FH             ;MASK UNWANTED BITS
0B0AD2 0F 
0B0AD3 80     1526* ADD     A,B             ;ADD IN DIGIT
0B0AD4 47     1527* LD      B,A
0B0AD5 0D     1528* DEC     C
0B0AD6 F2     1529* JP      P,GETEX1
0B0AD7 C0 
0B0AD8 0A 
0B0AD9 0B 
0B0ADA 06     1530* LD      B,100           ;FORCE OVERFLOW
0B0ADB 64 
0B0ADC 18     1531* JR      GETEX1
0B0ADD E2 
0B0ADE 08     1532* GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B0ADF FE     1533* CP      '-'
0B0AE0 2D 
0B0AE1 78     1534* LD      A,B
0B0AE2 C1     1535* POP     BC              ;RESTORE
0B0AE3 C0     1536* RET     NZ
0B0AE4 ED     1537* NEG                     ;NEGATE EXPONENT
0B0AE5 44 
0B0AE6 C9     1538* RET
              1539* ;
              1540* ;UINT: Get unsigned integer from string.
              1541* ;    Inputs: string at (IX)
              1542* ;            C = truncated digit count
              1543* ;                (initially zero)
              1544* ;            B = total digit count
              1545* ;            HLH'L' = initial value
              1546* ;   Outputs: HLH'L' = number (binary integer)
              1547* ;            A = delimiter.
              1548* ;            B, C & IX updated
              1549* ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
              1550* ;
0B0AE7 DD     1551* NUMBIX:			INC     IX
0B0AE8 23 
0B0AE9 CD     1552* UINT:			CALL    DIGITQ
0B0AEA 9B 
0B0AEB 0E 
0B0AEC 0B 
0B0AED D8     1553* RET     C
0B0AEE 04     1554* INC     B               ;INCREMENT DIGIT COUNT
0B0AEF DD     1555* INC     IX
0B0AF0 23 
0B0AF1 CD     1556* CALL    X10             ;*10 & COPY OLD VALUE
0B0AF2 E4 
0B0AF3 0C 
0B0AF4 0B 
0B0AF5 38     1557* JR      C,NUMB1         ;OVERFLOW
0B0AF6 15 
0B0AF7 0D     1558* DEC     C               ;SEE IF TRUNCATED
0B0AF8 0C     1559* INC     C
0B0AF9 20     1560* JR      NZ,NUMB1        ;IMPORTANT!
0B0AFA 11 
0B0AFB E6     1561* AND     0FH
0B0AFC 0F 
0B0AFD D9     1562* EXX
0B0AFE 06     1563* LD      B,0
0B0AFF 00 
0B0B00 4F     1564* LD      C,A
0B0B01 52     1565* ADD.S   HL,BC           ;ADD IN DIGIT
0B0B02 09 
0B0B03 D9     1566* EXX
0B0B04 30     1567* JR      NC,UINT
0B0B05 E3 
0B0B06 52     1568* INC.S   HL              ;CARRY
0B0B07 23 
0B0B08 7C     1569* LD      A,H
0B0B09 B5     1570* OR      L
0B0B0A 20     1571* JR      NZ,UINT
0B0B0B DD 
0B0B0C 0C     1572* NUMB1:			INC     C               ;TRUNCATION COUNTER
0B0B0D CD     1573* CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B0B0E 42 
0B0B0F 0C 
0B0B10 0B 
0B0B11 18     1574* JR      UINT
0B0B12 D6 
              1575* ;
              1576* ;FIX - Fix number to specified exponent value.
              1577* ;    Inputs: HLH'L'C = +ve non-zero number (floated)
              1578* ;            A = desired exponent (A>C)
              1579* ;   Outputs: HLH'L'C = fixed number (unsigned)
              1580* ;            fraction shifted into B'C'
              1581* ;            A'F' positive if integer input
              1582* ;  Destroys: C,H,L,A',B',C',H',L',F,F'
              1583* ;
0B0B13 08     1584* FIX:			EX      AF,AF'
0B0B14 AF     1585* XOR     A
0B0B15 08     1586* EX      AF,AF'
0B0B16 CB     1587* SET     7,H             ;IMPLIED 1
0B0B17 FC 
0B0B18 CD     1588* FIX1:			CALL    DIV2
0B0B19 47 
0B0B1A 0C 
0B0B1B 0B 
0B0B1C B9     1589* CP      C
0B0B1D C8     1590* RET     Z
0B0B1E D2     1591* JP      NC,FIX1
0B0B1F 18 
0B0B20 0B 
0B0B21 0B 
0B0B22 C3     1592* JP      OFLOW
0B0B23 56 
0B0B24 0C 
0B0B25 0B 
              1593* ;
              1594* ;SFIX - Convert to integer if necessary.
              1595* ;    Input: Variable-type number in HLH'L'C
              1596* ;   Output: Integer in HLH'L', C=0
              1597* ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
              1598* ;
              1599* ;NEGATE - Negate HLH'L'
              1600* ;    Destroys: H,L,H',L',F
              1601* ;
0B0B26 CD     1602* FIX2:			CALL    SWAP_FP
0B0B27 3F 
0B0B28 0C 
0B0B29 0B 
0B0B2A CD     1603* CALL    SFIX_FP
0B0B2B 32 
0B0B2C 0B 
0B0B2D 0B 
0B0B2E CD     1604* CALL    SWAP_FP
0B0B2F 3F 
0B0B30 0C 
0B0B31 0B 
0B0B32 0D     1605* SFIX_FP:			DEC     C
0B0B33 0C     1606* INC     C
0B0B34 C8     1607* RET     Z               ;INTEGER/ZERO
0B0B35 CB     1608* BIT     7,H             ;SIGN
0B0B36 7C 
0B0B37 F5     1609* PUSH    AF
0B0B38 3E     1610* LD      A,159
0B0B39 9F 
0B0B3A CD     1611* CALL    FIX
0B0B3B 13 
0B0B3C 0B 
0B0B3D 0B 
0B0B3E F1     1612* POP     AF
0B0B3F 0E     1613* LD      C,0
0B0B40 00 
0B0B41 C8     1614* RET     Z
0B0B42 B7     1615* NEGATE:			OR      A               ;CLEAR CARRY
0B0B43 D9     1616* EXX
0B0B44 D5     1617* NEG0:			PUSH    DE
0B0B45 EB     1618* EX      DE,HL
0B0B46 21     1619* LD      HL,0
0B0B47 00 
0B0B48 00 
0B0B49 00 
0B0B4A 52     1620* SBC.S   HL,DE
0B0B4B ED 
0B0B4C 52 
0B0B4D D1     1621* POP     DE
0B0B4E D9     1622* EXX
0B0B4F D5     1623* PUSH    DE
0B0B50 EB     1624* EX      DE,HL
0B0B51 21     1625* LD      HL,0
0B0B52 00 
0B0B53 00 
0B0B54 00 
0B0B55 52     1626* SBC.S   HL,DE
0B0B56 ED 
0B0B57 52 
0B0B58 D1     1627* POP     DE
0B0B59 C9     1628* RET
              1629* ;
              1630* ;NEG - Negate HLH'L'B'C'
              1631* ;    Also complements A (used in FADD)
              1632* ;    Destroys: A,H,L,B',C',H',L',F
              1633* ;
0B0B5A D9     1634* NEG_:			EXX
0B0B5B 2F     1635* CPL
0B0B5C E5     1636* PUSH    HL
0B0B5D B7     1637* OR      A               ;CLEAR CARRY
0B0B5E 21     1638* LD      HL,0
0B0B5F 00 
0B0B60 00 
0B0B61 00 
0B0B62 52     1639* SBC.S   HL,BC
0B0B63 ED 
0B0B64 42 
0B0B65 44     1640* LD      B,H
0B0B66 4D     1641* LD      C,L
0B0B67 E1     1642* POP     HL
0B0B68 18     1643* JR      NEG0
0B0B69 DA 
              1644* ;
              1645* ;SCALE - Trig scaling.
              1646* ;MOD48 - 48-bit floating-point "modulus" (remainder).
              1647* ;   Inputs: HLH'L'C unsigned floating-point dividend
              1648* ;           DED'E'B'C'B unsigned 48-bit FP divisor
              1649* ;  Outputs: HLH'L'C floating point remainder (H7=1)
              1650* ;           E = quotient (bit 7 is sticky)
              1651* ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
              1652* ;FLO48 - Float unsigned number (48 bits)
              1653* ;    Input/output in HLH'L'B'C'C
              1654* ;   Destroys: C,H,L,B',C',H',L',F
              1655* ;
0B0B6A 3E     1656* SCALE:			LD      A,150
0B0B6B 96 
0B0B6C B9     1657* CP      C
0B0B6D 3E     1658* LD      A,ACLOST
0B0B6E 17 
0B0B6F DA     1659* JP      C,ERROR_FP_         ;"Accuracy lost"
0B0B70 E5 
0B0B71 00 
0B0B72 0B 
0B0B73 CD     1660* CALL    PIBY4
0B0B74 B0 
0B0B75 06 
0B0B76 0B 
0B0B77 D9     1661* EXX
0B0B78 01     1662* LD      BC,2169H        ;3.141592653589793238
0B0B79 69 
0B0B7A 21 
0B0B7B 00 
0B0B7C D9     1663* EXX
0B0B7D CB     1664* MOD48:			SET     7,D             ;IMPLIED 1
0B0B7E FA 
0B0B7F CB     1665* SET     7,H
0B0B80 FC 
0B0B81 79     1666* LD      A,C
0B0B82 0E     1667* LD      C,0             ;INIT QUOTIENT
0B0B83 00 
0B0B84 DD     1668* LD      IX,0
0B0B85 21 
0B0B86 00 
0B0B87 00 
0B0B87 00   
0B0B89 DD     1669* PUSH    IX              ;PUT ZERO ON STACK
0B0B8A E5 
0B0B8B B8     1670* CP      B
0B0B8C 38     1671* JR      C,MOD485        ;DIVIDEND<DIVISOR
0B0B8D 46 
0B0B8E D9     1672* MOD481:			EXX                     ;CARRY=0 HERE
0B0B8F E3     1673* EX      (SP),HL
0B0B90 52     1674* SBC.S   HL,BC
0B0B91 ED 
0B0B92 42 
0B0B93 E3     1675* EX      (SP),HL
0B0B94 52     1676* SBC.S   HL,DE
0B0B95 ED 
0B0B96 52 
0B0B97 D9     1677* EXX
0B0B98 52     1678* SBC.S   HL,DE
0B0B99 ED 
0B0B9A 52 
0B0B9B 30     1679* JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B0B9C 0C 
0B0B9D D9     1680* EXX
0B0B9E E3     1681* EX      (SP),HL
0B0B9F 52     1682* ADD.S   HL,BC
0B0BA0 09 
0B0BA1 E3     1683* EX      (SP),HL
0B0BA2 52     1684* ADC.S   HL,DE
0B0BA3 ED 
0B0BA4 5A 
0B0BA5 D9     1685* EXX
0B0BA6 52     1686* ADC.S   HL,DE
0B0BA7 ED 
0B0BA8 5A 
0B0BA9 3F     1687* MOD482:			CCF
0B0BAA CB     1688* RL      C               ;QUOTIENT
0B0BAB 11 
0B0BAC 30     1689* JR      NC,MOD483
0B0BAD 02 
0B0BAE CB     1690* SET     7,C             ;STICKY BIT
0B0BAF F9 
0B0BB0 3D     1691* MOD483:			DEC     A
0B0BB1 B8     1692* CP      B
0B0BB2 38     1693* JR      C,MOD484        ;DIVIDEND<DIVISOR
0B0BB3 1F 
0B0BB4 E3     1694* EX      (SP),HL
0B0BB5 52     1695* ADD.S   HL,HL           ;DIVIDEND * 2
0B0BB6 29 
0B0BB7 E3     1696* EX      (SP),HL
0B0BB8 D9     1697* EXX
0B0BB9 52     1698* ADC.S   HL,HL
0B0BBA ED 
0B0BBB 6A 
0B0BBC D9     1699* EXX
0B0BBD 52     1700* ADC.S   HL,HL
0B0BBE ED 
0B0BBF 6A 
0B0BC0 30     1701* JR      NC,MOD481       ;AGAIN
0B0BC1 CC 
0B0BC2 B7     1702* OR      A
0B0BC3 D9     1703* EXX
0B0BC4 E3     1704* EX      (SP),HL
0B0BC5 52     1705* SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B0BC6 ED 
0B0BC7 42 
0B0BC8 E3     1706* EX      (SP),HL
0B0BC9 52     1707* SBC.S   HL,DE
0B0BCA ED 
0B0BCB 52 
0B0BCC D9     1708* EXX
0B0BCD 52     1709* SBC.S   HL,DE
0B0BCE ED 
0B0BCF 52 
0B0BD0 B7     1710* OR      A
0B0BD1 18     1711* JR      MOD482
0B0BD2 D6 
              1712* ;
0B0BD3 3C     1713* MOD484:			INC     A
0B0BD4 59     1714* MOD485:			LD      E,C             ;QUOTIENT
0B0BD5 4F     1715* LD      C,A             ;REMAINDER EXPONENT
0B0BD6 D9     1716* EXX
0B0BD7 C1     1717* POP     BC
0B0BD8 D9     1718* EXX
0B0BD9 CB     1719* FLO48:			BIT     7,H
0B0BDA 7C 
0B0BDB C0     1720* RET     NZ
0B0BDC D9     1721* EXX
0B0BDD CB     1722* SLA     C
0B0BDE 21 
0B0BDF CB     1723* RL      B
0B0BE0 10 
0B0BE1 52     1724* ADC.S   HL,HL
0B0BE2 ED 
0B0BE3 6A 
0B0BE4 D9     1725* EXX
0B0BE5 52     1726* ADC.S   HL,HL
0B0BE6 ED 
0B0BE7 6A 
0B0BE8 0D     1727* DEC     C
0B0BE9 C2     1728* JP      NZ,FLO48
0B0BEA D9 
0B0BEB 0B 
0B0BEC 0B 
0B0BED C9     1729* RET
              1730* ;
              1731* ;Float unsigned number
              1732* ;    Input/output in HLH'L'C
              1733* ;   Destroys: C,H,L,H',L',F
              1734* ;
0B0BEE CB     1735* FLOAT_:			BIT     7,H
0B0BEF 7C 
0B0BF0 C0     1736* RET     NZ
0B0BF1 D9     1737* EXX                     ;SAME AS "X2"
0B0BF2 52     1738* ADD.S   HL,HL           ;TIME-CRITICAL
0B0BF3 29 
0B0BF4 D9     1739* EXX                     ;REGION
0B0BF5 52     1740* ADC.S   HL,HL           ;(BENCHMARKS)
0B0BF6 ED 
0B0BF7 6A 
0B0BF8 0D     1741* DEC     C
0B0BF9 C2     1742* JP      NZ,FLOAT_
0B0BFA EE 
0B0BFB 0B 
0B0BFC 0B 
0B0BFD C9     1743* RET
              1744* ;
              1745* ;SFLOAT - Convert to floating-point if necessary.
              1746* ;    Input: Variable-type number in HLH'L'C
              1747* ;    Output: Floating-point in HLH'L'C
              1748* ;    Destroys: A,C,H,L,H',L',F
              1749* ;
0B0BFE 08     1750* FLOATA:			EX      AF,AF'
              1751* ; ADD     A,(RTABLE-DTABLE)/3
0B0BFF C6     1752* ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B0C00 2A 
0B0C01 08     1753* EX      AF,AF'
0B0C02 CD     1754* FLOAT2:			CALL    SWAP_FP
0B0C03 3F 
0B0C04 0C 
0B0C05 0B 
0B0C06 CD     1755* CALL    SFLOAT_FP
0B0C07 0E 
0B0C08 0C 
0B0C09 0B 
0B0C0A CD     1756* CALL    SWAP_FP
0B0C0B 3F 
0B0C0C 0C 
0B0C0D 0B 
0B0C0E 0D     1757* SFLOAT_FP:			DEC     C
0B0C0F 0C     1758* INC     C
0B0C10 C0     1759* RET     NZ              ;ALREADY FLOATING-POINT
0B0C11 CD     1760* CALL    TEST_FP
0B0C12 67 
0B0C13 0C 
0B0C14 0B 
0B0C15 C8     1761* RET     Z               ;ZERO
0B0C16 7C     1762* LD      A,H
0B0C17 B7     1763* OR      A
0B0C18 FC     1764* CALL    M,NEGATE
0B0C19 42 
0B0C1A 0B 
0B0C1B 0B 
0B0C1C 0E     1765* LD      C,159
0B0C1D 9F 
0B0C1E CD     1766* CALL    FLOAT_
0B0C1F EE 
0B0C20 0B 
0B0C21 0B 
0B0C22 B7     1767* OR      A
0B0C23 F8     1768* RET     M               ;NEGATIVE
0B0C24 CB     1769* RES     7,H
0B0C25 BC 
0B0C26 C9     1770* RET
              1771* ;
              1772* ;ROUND UP
              1773* ;Return with carry set if 32-bit overflow
              1774* ;   Destroys: H,L,B',C',H',L',F
              1775* ;
0B0C27 D9     1776* ADD1_FP:			EXX
0B0C28 01     1777* LD      BC,1
0B0C29 01 
0B0C2A 00 
0B0C2B 00 
0B0C2C 52     1778* ADD.S   HL,BC
0B0C2D 09 
0B0C2E D9     1779* EXX
0B0C2F D0     1780* RET     NC
0B0C30 C5     1781* PUSH    BC
0B0C31 01     1782* LD      BC,1
0B0C32 01 
0B0C33 00 
0B0C34 00 
0B0C35 52     1783* ADD.S   HL,BC
0B0C36 09 
0B0C37 C1     1784* POP     BC
0B0C38 C9     1785* RET
              1786* ;
              1787* ;ODD - Add one if even, leave alone if odd.
              1788* ; (Used to perform unbiassed rounding, i.e.
              1789* ;  number is rounded up half the time)
              1790* ;    Destroys: L',F (carry cleared)
              1791* ;
0B0C39 B7     1792* ODD:			OR      A               ;CLEAR CARRY
0B0C3A D9     1793* EXX
0B0C3B CB     1794* SET     0,L             ;MAKE ODD
0B0C3C C5 
0B0C3D D9     1795* EXX
0B0C3E C9     1796* RET
              1797* ;
              1798* ;SWAP_FP - Swap arguments.
              1799* ;    Exchanges DE,HL D'E',H'L' and B,C
              1800* ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
              1801* ;SWAP1 - Swap DEHL with D'E'H'L'
              1802* ;    Destroys: D,E,H,L,D',E',H',L'
              1803* ;
0B0C3F 79     1804* SWAP_FP:			LD      A,C
0B0C40 48     1805* LD      C,B
0B0C41 47     1806* LD      B,A
0B0C42 EB     1807* SWAP1:			EX      DE,HL
0B0C43 D9     1808* EXX
0B0C44 EB     1809* EX      DE,HL
0B0C45 D9     1810* EXX
0B0C46 C9     1811* RET
              1812* ;
              1813* ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
              1814* ; INCC - destroys C,F
              1815* ; OFLOW
              1816* ;
0B0C47 CD     1817* DIV2:			CALL    D2
0B0C48 00 
0B0C49 0D 
0B0C4A 0B 
0B0C4B D9     1818* EXX
0B0C4C CB     1819* RR      B
0B0C4D 18 
0B0C4E CB     1820* RR      C
0B0C4F 19 
0B0C50 08     1821* EX      AF,AF'
0B0C51 B0     1822* OR      B
0B0C52 08     1823* EX      AF,AF'
0B0C53 D9     1824* EXX
0B0C54 0C     1825* INCC:			INC     C
0B0C55 C0     1826* RET     NZ
0B0C56 3E     1827* OFLOW:			LD      A,TOOBIG_FP
0B0C57 14 
0B0C58 C3     1828* JP      ERROR_FP_           ;"Too big"
0B0C59 E5 
0B0C5A 00 
0B0C5B 0B 
              1829* ;
              1830* ; FTEST - Test for zero & sign
              1831* ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
              1832* ;
0B0C5C CD     1833* FTEST_FP:			CALL    TEST_FP
0B0C5D 67 
0B0C5E 0C 
0B0C5F 0B 
0B0C60 C8     1834* RET     Z
0B0C61 7C     1835* LD      A,H
0B0C62 E6     1836* AND     10000000B
0B0C63 80 
0B0C64 F6     1837* OR      01000000B
0B0C65 40 
0B0C66 C9     1838* RET
              1839* ;
              1840* ; TEST_FP - Test HLH'L' for zero.
              1841* ;     Output: Z-flag set & A=0 if HLH'L'=0
              1842* ;     Destroys: A,F
              1843* ;
0B0C67 7C     1844* TEST_FP:			LD      A,H
0B0C68 B5     1845* OR      L
0B0C69 D9     1846* EXX
0B0C6A B4     1847* OR      H
0B0C6B B5     1848* OR      L
0B0C6C D9     1849* EXX
0B0C6D C9     1850* RET
              1851* ;
              1852* ; FCOMP - Compare two numbers
              1853* ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
              1854* ;
0B0C6E 78     1855* FCOMP_FP:			LD      A,B
0B0C6F B1     1856* OR      C               ;Both integer?
0B0C70 20     1857* JR      NZ,FCOMP1
0B0C71 0B 
0B0C72 CD     1858* CALL    ICP
0B0C73 87 
0B0C74 0C 
0B0C75 0B 
0B0C76 3E     1859* FCOMP0:			LD      A,0
0B0C77 00 
0B0C78 C8     1860* RET     Z               ;Equal
0B0C79 3E     1861* LD      A,80H
0B0C7A 80 
0B0C7B 1F     1862* RRA
0B0C7C C9     1863* RET
              1864* ;
0B0C7D CD     1865* FCOMP1:			CALL    FLOAT2          ;Float both
0B0C7E 02 
0B0C7F 0C 
0B0C80 0B 
0B0C81 CD     1866* CALL    FCP
0B0C82 95 
0B0C83 0C 
0B0C84 0B 
0B0C85 18     1867* JR      FCOMP0
0B0C86 EF 
              1868* ;
              1869* ; Integer and floating point compare.
              1870* ; Sets carry & zero flags according to HLH'L'C-DED'E'B
              1871* ; Result pre-set to FALSE
              1872* ; ICP1, FCP1 destroy A,F
              1873* ;
              1874* ; ZERO - Return zero.
              1875* ;  Destroys: A,C,H,L,H',L'
              1876* ;
0B0C87 CD     1877* ICP:			CALL    ICP1
0B0C88 BA 
0B0C89 0C 
0B0C8A 0B 
0B0C8B 3E     1878* ZERO_FP:			LD      A,0
0B0C8C 00 
0B0C8D D9     1879* EXX
0B0C8E 67     1880* LD      H,A
0B0C8F 6F     1881* LD      L,A
0B0C90 D9     1882* EXX
0B0C91 67     1883* LD      H,A
0B0C92 6F     1884* LD      L,A
0B0C93 4F     1885* LD      C,A
0B0C94 C9     1886* RET
              1887* ;
0B0C95 CD     1888* FCP:			CALL    FCP1
0B0C96 AC 
0B0C97 0C 
0B0C98 0B 
0B0C99 18     1889* JR      ZERO_FP            ;PRESET FALSE
0B0C9A F0 
              1890* ;
0B0C9B 79     1891* FCP0:			LD      A,C
0B0C9C B8     1892* CP      B               ;COMPARE EXPONENTS
0B0C9D C0     1893* RET     NZ
              1894* ICP0:
0B0C9E 52     1895* SBC.S   HL,DE           ;COMP MANTISSA MSB
0B0C9F ED 
0B0CA0 52 
0B0CA1 52     1896* ADD.S   HL,DE
0B0CA2 19 
0B0CA3 C0     1897* RET     NZ
0B0CA4 D9     1898* EXX
0B0CA5 52     1899* SBC.S   HL,DE           ;COMP MANTISSA LSB
0B0CA6 ED 
0B0CA7 52 
0B0CA8 52     1900* ADD.S   HL,DE
0B0CA9 19 
0B0CAA D9     1901* EXX
0B0CAB C9     1902* RET
              1903* ;
0B0CAC 7C     1904* FCP1:			LD      A,H
0B0CAD AA     1905* XOR     D
0B0CAE 7C     1906* LD      A,H
0B0CAF 17     1907* RLA
0B0CB0 F8     1908* RET     M
0B0CB1 30     1909* JR      NC,FCP0
0B0CB2 E8 
0B0CB3 CD     1910* CALL    FCP0
0B0CB4 9B 
0B0CB5 0C 
0B0CB6 0B 
0B0CB7 C8     1911* RET     Z               ;** V0.1 BUG FIX
0B0CB8 3F     1912* CCF
0B0CB9 C9     1913* RET
              1914* ;
0B0CBA 7C     1915* ICP1:			LD      A,H
0B0CBB AA     1916* XOR     D
0B0CBC F2     1917* JP      P,ICP0
0B0CBD 9E 
0B0CBE 0C 
0B0CBF 0B 
0B0CC0 7C     1918* LD      A,H
0B0CC1 17     1919* RLA
0B0CC2 C9     1920* RET
              1921* ;
              1922* ; ADD - Integer add.
              1923* ; Carry, sign & zero flags valid on exit
              1924* ;     Destroys: H,L,H',L',F
              1925* ;
0B0CC3 05     1926* X10B:			DEC     B
0B0CC4 0C     1927* INC     C
0B0CC5 CD     1928* X5:			CALL    COPY0
0B0CC6 0C 
0B0CC7 0D 
0B0CC8 0B 
0B0CC9 CD     1929* CALL    D2C
0B0CCA FF 
0B0CCB 0C 
0B0CCC 0B 
0B0CCD CD     1930* CALL    D2C
0B0CCE FF 
0B0CCF 0C 
0B0CD0 0B 
0B0CD1 08     1931* EX      AF,AF'          ;SAVE CARRY
0B0CD2 D9     1932* ADD_:			EXX
0B0CD3 52     1933* ADD.S   HL,DE
0B0CD4 19 
0B0CD5 D9     1934* EXX
0B0CD6 52     1935* ADC.S   HL,DE
0B0CD7 ED 
0B0CD8 5A 
0B0CD9 C9     1936* RET
              1937* ;
              1938* ; SUB - Integer subtract.
              1939* ; Carry, sign & zero flags valid on exit
              1940* ;     Destroys: H,L,H',L',F
              1941* ;
0B0CDA D9     1942* SUB_:			EXX
0B0CDB B7     1943* OR      A
0B0CDC 52     1944* SBC.S   HL,DE
0B0CDD ED 
0B0CDE 52 
0B0CDF D9     1945* EXX
0B0CE0 52     1946* SBC.S   HL,DE
0B0CE1 ED 
0B0CE2 52 
0B0CE3 C9     1947* RET
              1948* ;
              1949* ; X10 - unsigned integer * 10
              1950* ;    Inputs: HLH'L' initial value
              1951* ;   Outputs: DED'E' = initial HLH'L'
              1952* ;            Carry bit set if overflow
              1953* ;            If carry not set HLH'L'=result
              1954* ;  Destroys: D,E,H,L,D',E',H',L',F
              1955* ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
              1956* ;     Carry set if MSB=1 before shift.
              1957* ;     Sign set if MSB=1 after shift.
              1958* ;     Destroys: H,L,H',L',F
              1959* ;
0B0CE4 CD     1960* X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B0CE5 0C 
0B0CE6 0D 
0B0CE7 0B 
0B0CE8 CD     1961* CALL    X2
0B0CE9 F7 
0B0CEA 0C 
0B0CEB 0B 
0B0CEC D8     1962* RET     C               ;TOO BIG
0B0CED CD     1963* CALL    X2
0B0CEE F7 
0B0CEF 0C 
0B0CF0 0B 
0B0CF1 D8     1964* RET     C
0B0CF2 CD     1965* CALL    ADD_
0B0CF3 D2 
0B0CF4 0C 
0B0CF5 0B 
0B0CF6 D8     1966* RET     C
0B0CF7 D9     1967* X2:			EXX
0B0CF8 52     1968* ADD.S   HL,HL
0B0CF9 29 
0B0CFA D9     1969* EXX
0B0CFB 52     1970* ADC.S   HL,HL
0B0CFC ED 
0B0CFD 6A 
0B0CFE C9     1971* RET
              1972* ;
              1973* ; D2 - Divide HLH'L' by 2 as 32-bit integer.
              1974* ;     Carry set if LSB=1 before shift.
              1975* ;     Destroys: H,L,H',L',F
              1976* ;
0B0CFF 0C     1977* D2C:			INC     C
0B0D00 CB     1978* D2:			SRL     H
0B0D01 3C 
0B0D02 CB     1979* RR      L
0B0D03 1D 
0B0D04 D9     1980* EXX
0B0D05 CB     1981* RR      H
0B0D06 1C 
0B0D07 CB     1982* RR      L
0B0D08 1D 
0B0D09 D9     1983* EXX
0B0D0A C9     1984* RET
              1985* ;
              1986* ; COPY - COPY HLH'L'C INTO DED'E'B
              1987* ;   Destroys: B,C,D,E,H,L,D',E',H',L'
              1988* ;
0B0D0B 41     1989* COPY_:			LD      B,C
0B0D0C 54     1990* COPY0:			LD      D,H
0B0D0D 5D     1991* LD      E,L
0B0D0E D9     1992* EXX
0B0D0F 54     1993* LD      D,H
0B0D10 5D     1994* LD      E,L
0B0D11 D9     1995* EXX
0B0D12 C9     1996* RET
              1997* ;
              1998* ; SQUARE - PUSH X*X
              1999* ; PUSH5 - PUSH HLH'L'C ONTO STACK.
              2000* ;   Destroys: SP,IX
              2001* ;
0B0D13 CD     2002* SQUARE:			CALL    COPY_
0B0D14 0B 
0B0D15 0D 
0B0D16 0B 
0B0D17 CD     2003* CALL    FMUL
0B0D18 76 
0B0D19 03 
0B0D1A 0B 
0B0D1B DD     2004* PUSH5:			POP     IX              ;RETURN ADDRESS
0B0D1C E1 
0B0D1D C5     2005* PUSH    BC
0B0D1E E5     2006* PUSH    HL
0B0D1F D9     2007* EXX
0B0D20 E5     2008* PUSH    HL
0B0D21 D9     2009* EXX
0B0D22 DD     2010* JP      (IX)            ;"RETURN"
0B0D23 E9 
              2011* ;
              2012* ; POP5 - POP DED'E'B OFF STACK.
              2013* ;   Destroys: A,B,D,E,D',E',SP,IX
              2014* ;
0B0D24 DD     2015* POP5:			POP     IX              ;RETURN ADDRESS
0B0D25 E1 
0B0D26 D9     2016* EXX
0B0D27 D1     2017* POP     DE
0B0D28 D9     2018* EXX
0B0D29 D1     2019* POP     DE
0B0D2A 79     2020* LD      A,C
0B0D2B C1     2021* POP     BC
0B0D2C 41     2022* LD      B,C
0B0D2D 4F     2023* LD      C,A
0B0D2E DD     2024* JP      (IX)            ;"RETURN"
0B0D2F E9 
              2025* ;
              2026* ; RATIO - Calculate (X-1)/(X+1)
              2027* ;     Inputs: X in HLH'L'C
              2028* ;    Outputs: (X-1)/(X+1) in HLH'L'C
              2029* ;   Destroys: Everything except IY,SP,I
              2030* ;
0B0D30 CD     2031* RATIO:			CALL    PUSH5           ;SAVE X
0B0D31 1B 
0B0D32 0D 
0B0D33 0B 
0B0D34 CD     2032* CALL    DONE
0B0D35 A3 
0B0D36 06 
0B0D37 0B 
0B0D38 CD     2033* CALL    FADD
0B0D39 64 
0B0D3A 02 
0B0D3B 0B 
0B0D3C CD     2034* CALL    POP5            ;RESTORE X
0B0D3D 24 
0B0D3E 0D 
0B0D3F 0B 
0B0D40 CD     2035* CALL    PUSH5           ;SAVE X+1
0B0D41 1B 
0B0D42 0D 
0B0D43 0B 
0B0D44 CD     2036* CALL    SWAP_FP
0B0D45 3F 
0B0D46 0C 
0B0D47 0B 
0B0D48 CD     2037* CALL    DONE
0B0D49 A3 
0B0D4A 06 
0B0D4B 0B 
0B0D4C CD     2038* CALL    FSUB
0B0D4D 4B 
0B0D4E 02 
0B0D4F 0B 
0B0D50 CD     2039* CALL    POP5            ;RESTORE X+1
0B0D51 24 
0B0D52 0D 
0B0D53 0B 
0B0D54 C3     2040* JP      FDIV
0B0D55 CD 
0B0D56 02 
0B0D57 0B 
              2041* ;
              2042* ; POLY - Evaluate a polynomial.
              2043* ;     Inputs: X in HLH'L'C and also stored at (SP+2)
              2044* ;             Polynomial coefficients follow call.
              2045* ;    Outputs: Result in HLH'L'C
              2046* ;   Destroys: Everything except IY,SP,I
              2047* ; Routine terminates on finding a coefficient >=1.
              2048* ; Note: The last coefficient is EXECUTED on return
              2049* ;       so must contain only innocuous bytes!
              2050* ;
0B0D58 DD     2051* POLY:			LD      IX, 3				; Advance the SP to the return address
0B0D59 21 
0B0D5A 03 
0B0D5B 00 
0B0D5B 00   
0B0D5D DD     2052* ADD     IX, SP
0B0D5E 39 
0B0D5F DD     2053* EX      (SP), IX			; IX: Points to the inline list of coefficients
0B0D60 E3 
              2054* ;
0B0D61 CD     2055* CALL    DLOAD5          		; Load the first coefficient from (IX)
0B0D62 37 
0B0D63 0A 
0B0D64 0B 
0B0D65 CD     2056* POLY1:			CALL    FMUL
0B0D66 76 
0B0D67 03 
0B0D68 0B 
0B0D69 11     2057* LD      DE, 5				; Skip to the next coefficient
0B0D6A 05 
0B0D6B 00 
0B0D6C 00 
0B0D6D DD     2058* ADD     IX, DE
0B0D6E 19 
0B0D6F CD     2059* CALL    DLOAD5          		; Load the second coefficient from (IX)
0B0D70 37 
0B0D71 0A 
0B0D72 0B 
0B0D73 DD     2060* EX      (SP), IX			; Restore the SP just in case we need to return
0B0D74 E3 
0B0D75 04     2061* INC     B
0B0D76 05     2062* DEC     B               		; Test B for end byte (80h)
0B0D77 FA     2063* JP      M,FADD				; Yes, so add and return
0B0D78 64 
0B0D79 02 
0B0D7A 0B 
0B0D7B CD     2064* CALL    FADD				; No, so add
0B0D7C 64 
0B0D7D 02 
0B0D7E 0B 
0B0D7F CD     2065* CALL    DLOAD5_SPL			; Load X from SP
0B0D80 49 
0B0D81 0A 
0B0D82 0B 
0B0D83 DD     2066* EX      (SP), IX			; IX: Points to the inline list of coefficients
0B0D84 E3 
0B0D85 18     2067* JR      POLY1				; And loop
0B0D86 DE 
              2068* ;
              2069* ; POWR10 - Calculate power of ten.
              2070* ;     Inputs: A=power of 10 required (A<128)
              2071* ;             A=binary exponent to be exceeded (A>=128)
              2072* ;    Outputs: DED'E'B = result
              2073* ;             A = actual power of ten returned
              2074* ;   Destroys: A,B,D,E,A',D',E',F,F'
              2075* ;
0B0D87 3C     2076* POWR10:			INC     A
0B0D88 08     2077* EX      AF,AF'
0B0D89 E5     2078* PUSH    HL
0B0D8A D9     2079* EXX
0B0D8B E5     2080* PUSH    HL
0B0D8C D9     2081* EXX
0B0D8D CD     2082* CALL    DONE
0B0D8E A3 
0B0D8F 06 
0B0D90 0B 
0B0D91 CD     2083* CALL    SWAP_FP
0B0D92 3F 
0B0D93 0C 
0B0D94 0B 
0B0D95 AF     2084* XOR     A
0B0D96 08     2085* POWR11:			EX      AF,AF'
0B0D97 3D     2086* DEC     A
0B0D98 28     2087* JR      Z,POWR14        ;EXIT TYPE 1
0B0D99 26 
0B0D9A F2     2088* JP      P,POWR13
0B0D9B A2 
0B0D9C 0D 
0B0D9D 0B 
0B0D9E B9     2089* CP      C
0B0D9F 38     2090* JR      C,POWR14        ;EXIT TYPE 2
0B0DA0 1F 
0B0DA1 3C     2091* INC     A
0B0DA2 08     2092* POWR13:			EX      AF,AF'
0B0DA3 3C     2093* INC     A
0B0DA4 CB     2094* SET     7,H
0B0DA5 FC 
0B0DA6 CD     2095* CALL    X5
0B0DA7 C5 
0B0DA8 0C 
0B0DA9 0B 
0B0DAA 30     2096* JR      NC,POWR12
0B0DAB 06 
0B0DAC 08     2097* EX      AF,AF'
0B0DAD CD     2098* CALL    D2C
0B0DAE FF 
0B0DAF 0C 
0B0DB0 0B 
0B0DB1 08     2099* EX      AF,AF'
0B0DB2 08     2100* POWR12:			EX      AF,AF'
0B0DB3 DC     2101* CALL    C,ADD1_FP          ;ROUND UP
0B0DB4 27 
0B0DB5 0C 
0B0DB6 0B 
0B0DB7 0C     2102* INC     C
0B0DB8 FA     2103* JP      M,POWR11
0B0DB9 96 
0B0DBA 0D 
0B0DBB 0B 
0B0DBC C3     2104* JP      OFLOW
0B0DBD 56 
0B0DBE 0C 
0B0DBF 0B 
0B0DC0 CD     2105* POWR14:			CALL    SWAP_FP
0B0DC1 3F 
0B0DC2 0C 
0B0DC3 0B 
0B0DC4 CB     2106* RES     7,D
0B0DC5 BA 
0B0DC6 D9     2107* EXX
0B0DC7 E1     2108* POP     HL
0B0DC8 D9     2109* EXX
0B0DC9 E1     2110* POP     HL
0B0DCA 08     2111* EX      AF,AF'
0B0DCB C9     2112* RET
              2113* ;
              2114* ; DIVA, DIVB - DIVISION PRIMITIVE.
              2115* ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
              2116* ;               Remainder in H'L'HL
              2117* ;     Inputs: A = loop counter (normally -32)
              2118* ;     Destroys: A,D,E,H,L,D',E',H',L',F
              2119* ;
0B0DCC B7     2120* DIVA:			OR      A               ;CLEAR CARRY
              2121* DIV0:
0B0DCD 52     2122* SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B0DCE ED 
0B0DCF 42 
0B0DD0 D9     2123* EXX
0B0DD1 52     2124* SBC.S   HL,BC
0B0DD2 ED 
0B0DD3 42 
0B0DD4 D9     2125* EXX
0B0DD5 30     2126* JR      NC,DIV1
0B0DD6 07 
0B0DD7 52     2127* ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B0DD8 09 
0B0DD9 D9     2128* EXX
0B0DDA 52     2129* ADC.S   HL,BC
0B0DDB ED 
0B0DDC 4A 
0B0DDD D9     2130* EXX
0B0DDE 3F     2131* DIV1:			CCF
0B0DDF CB     2132* DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B0DE0 13 
0B0DE1 CB     2133* RL      D
0B0DE2 12 
0B0DE3 D9     2134* EXX
0B0DE4 CB     2135* RL      E
0B0DE5 13 
0B0DE6 CB     2136* RL      D
0B0DE7 12 
0B0DE8 D9     2137* EXX
0B0DE9 3C     2138* INC     A
0B0DEA F0     2139* RET     P
              2140* DIVB:
0B0DEB 52     2141* ADC.S   HL,HL           ;DIVIDEND*2
0B0DEC ED 
0B0DED 6A 
0B0DEE D9     2142* EXX
0B0DEF 52     2143* ADC.S   HL,HL
0B0DF0 ED 
0B0DF1 6A 
0B0DF2 D9     2144* EXX
0B0DF3 30     2145* JR      NC,DIV0
0B0DF4 D8 
0B0DF5 B7     2146* OR      A
0B0DF6 52     2147* SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B0DF7 ED 
0B0DF8 42 
0B0DF9 D9     2148* EXX
0B0DFA 52     2149* SBC.S   HL,BC
0B0DFB ED 
0B0DFC 42 
0B0DFD D9     2150* EXX
0B0DFE 37     2151* SCF
0B0DFF C3     2152* JP      DIVC
0B0E00 DF 
0B0E01 0D 
0B0E02 0B 
              2153* ;
              2154* ;MULA, MULB - MULTIPLICATION PRIMITIVE.
              2155* ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
              2156* ;    Inputs: A = loop counter (usually -32)
              2157* ;            H'L'HL = 0
              2158* ;    Destroys: D,E,H,L,D',E',H',L',A,F
              2159* ;
0B0E03 B7     2160* MULA:			OR      A               ;CLEAR CARRY
0B0E04 D9     2161* MUL0:			EXX
0B0E05 CB     2162* RR      D               ;MULTIPLIER/2
0B0E06 1A 
0B0E07 CB     2163* RR      E
0B0E08 1B 
0B0E09 D9     2164* EXX
0B0E0A CB     2165* RR      D
0B0E0B 1A 
0B0E0C CB     2166* RR      E
0B0E0D 1B 
0B0E0E 30     2167* JR      NC,MUL1
0B0E0F 07 
0B0E10 52     2168* ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B0E11 09 
0B0E12 D9     2169* EXX
0B0E13 52     2170* ADC.S   HL,BC
0B0E14 ED 
0B0E15 4A 
0B0E16 D9     2171* EXX
0B0E17 3C     2172* MUL1:			INC     A
0B0E18 F0     2173* RET     P
0B0E19 D9     2174* MULB:			EXX
0B0E1A CB     2175* RR      H               ;PRODUCT/2
0B0E1B 1C 
0B0E1C CB     2176* RR      L
0B0E1D 1D 
0B0E1E D9     2177* EXX
0B0E1F CB     2178* RR      H
0B0E20 1C 
0B0E21 CB     2179* RR      L
0B0E22 1D 
0B0E23 C3     2180* JP      MUL0
0B0E24 04 
0B0E25 0E 
0B0E26 0B 
              2181* ;
              2182* ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
              2183* ;     Function: B'C'BC = SQR (D'E'DE)
              2184* ;     Inputs: A = loop counter (normally -31)
              2185* ;             B'C'BCH'L'HL initialised to 0
              2186* ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
              2187* ;
              2188* SQR1:
0B0E27 52     2189* SBC.S   HL,BC
0B0E28 ED 
0B0E29 42 
0B0E2A D9     2190* EXX
0B0E2B 52     2191* SBC.S   HL,BC
0B0E2C ED 
0B0E2D 42 
0B0E2E D9     2192* EXX
0B0E2F 0C     2193* INC     C
0B0E30 30     2194* JR      NC,SQR2
0B0E31 09 
0B0E32 0D     2195* DEC     C
0B0E33 52     2196* ADD.S   HL,BC
0B0E34 09 
0B0E35 D9     2197* EXX
0B0E36 52     2198* ADC.S   HL,BC
0B0E37 ED 
0B0E38 4A 
0B0E39 D9     2199* EXX
0B0E3A 0D     2200* DEC     C
0B0E3B 3C     2201* SQR2:			INC     A
0B0E3C F0     2202* RET     P
0B0E3D CB     2203* SQRA:			SLA     C
0B0E3E 21 
0B0E3F CB     2204* RL      B
0B0E40 10 
0B0E41 D9     2205* EXX
0B0E42 CB     2206* RL      C
0B0E43 11 
0B0E44 CB     2207* RL      B
0B0E45 10 
0B0E46 D9     2208* EXX
0B0E47 0C     2209* INC     C
0B0E48 CB     2210* SLA     E
0B0E49 23 
0B0E4A CB     2211* RL      D
0B0E4B 12 
0B0E4C D9     2212* EXX
0B0E4D CB     2213* RL      E
0B0E4E 13 
0B0E4F CB     2214* RL      D
0B0E50 12 
0B0E51 D9     2215* EXX
0B0E52 52     2216* ADC.S   HL,HL
0B0E53 ED 
0B0E54 6A 
0B0E55 D9     2217* EXX
0B0E56 52     2218* ADC.S   HL,HL
0B0E57 ED 
0B0E58 6A 
0B0E59 D9     2219* EXX
0B0E5A CB     2220* SLA     E
0B0E5B 23 
0B0E5C CB     2221* RL      D
0B0E5D 12 
0B0E5E D9     2222* EXX
0B0E5F CB     2223* RL      E
0B0E60 13 
0B0E61 CB     2224* RL      D
0B0E62 12 
0B0E63 D9     2225* EXX
0B0E64 52     2226* ADC.S   HL,HL
0B0E65 ED 
0B0E66 6A 
0B0E67 D9     2227* EXX
0B0E68 52     2228* ADC.S   HL,HL
0B0E69 ED 
0B0E6A 6A 
0B0E6B D9     2229* EXX
0B0E6C D2     2230* JP      NC,SQR1
0B0E6D 27 
0B0E6E 0E 
0B0E6F 0B 
0B0E70 B7     2231* SQR3:			OR      A
0B0E71 52     2232* SBC.S   HL,BC
0B0E72 ED 
0B0E73 42 
0B0E74 D9     2233* EXX
0B0E75 52     2234* SBC.S   HL,BC
0B0E76 ED 
0B0E77 42 
0B0E78 D9     2235* EXX
0B0E79 0C     2236* INC     C
0B0E7A C3     2237* JP      SQR2
0B0E7B 3B 
0B0E7C 0E 
0B0E7D 0B 
              2238* ;
              2239* SQRB:
0B0E7E 52     2240* ADD.S   HL,HL
0B0E7F 29 
0B0E80 D9     2241* EXX
0B0E81 52     2242* ADC.S   HL,HL
0B0E82 ED 
0B0E83 6A 
0B0E84 D9     2243* EXX
0B0E85 38     2244* JR      C,SQR3
0B0E86 E9 
0B0E87 3C     2245* INC     A
0B0E88 0C     2246* INC     C
0B0E89 52     2247* SBC.S   HL,BC
0B0E8A ED 
0B0E8B 42 
0B0E8C D9     2248* EXX
0B0E8D 52     2249* SBC.S   HL,BC
0B0E8E ED 
0B0E8F 42 
0B0E90 D9     2250* EXX
0B0E91 D0     2251* RET     NC
0B0E92 52     2252* ADD.S   HL,BC
0B0E93 09 
0B0E94 D9     2253* EXX
0B0E95 52     2254* ADC.S   HL,BC
0B0E96 ED 
0B0E97 4A 
0B0E98 D9     2255* EXX
0B0E99 0D     2256* DEC     C
0B0E9A C9     2257* RET
              2258* ;
0B0E9B DD     2259* DIGITQ:			LD      A,(IX)
0B0E9C 7E 
0B0E9D 00 
0B0E9E FE     2260* CP      '9'+1
0B0E9F 3A 
0B0EA0 3F     2261* CCF
0B0EA1 D8     2262* RET     C
0B0EA2 FE     2263* CP      '0'
0B0EA3 30 
0B0EA4 C9     2264* RET
              2265* ;
0B0EA5 DD     2266* SIGNQ:			LD      A,(IX)
0B0EA6 7E 
0B0EA7 00 
0B0EA8 DD     2267* INC     IX
0B0EA9 23 
0B0EAA FE     2268* CP      ' '
0B0EAB 20 
0B0EAC 28     2269* JR      Z,SIGNQ
0B0EAD F7 
0B0EAE FE     2270* CP      '+'
0B0EAF 2B 
0B0EB0 C8     2271* RET     Z
0B0EB1 FE     2272* CP      '-'
0B0EB2 2D 
0B0EB3 C8     2273* RET     Z
0B0EB4 DD     2274* DEC     IX
0B0EB5 2B 
0B0EB6 C9     2275* RET
               0180 include "functions.inc"
              0001* 
              0002* MACRO printChar char
              0003* LD A, char
              0004* RST.LIL 10h
              0005* ENDMACRO
              0006* 
              0007* ; test the sign of HL
              0008* ; inputs: HL obviously
              0009* ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
              0010* ; destroys: flags
              0011* MACRO sign_hlu
              0012* add hl,de
              0013* or a
              0014* sbc hl,de
              0015* ENDMACRO
              0016* 
              0017* ; Simulated call to subroutine at HL
              0018* ; inputs: HL pointing to the subroutine address plus whatever the called function expects
              0019* ; outputs: whatever the subroutine does, including HL and BC
              0020* ; destroys: only what the subroutine does, but always BC
              0021* MACRO callHL
              0022* ld bc,$+7     ; Address of first instruction after the jump
              0023* push bc       ; which constitutes the return address
              0024* jp   (hl)     ; Jump to the address in HL
              0025* ENDMACRO
              0026* 
              0027* ; Simulated call to subroutine at IX
              0028* ; inputs: IX pointing to the subroutine address plus whatever the called function expects
              0029* ; outputs: whatever the subroutine does, including IX and BC
              0030* ; destroys: only what the subroutine does, but always BC
              0031* MACRO callIX
              0032* ld bc,$+7     ; Address of first instruction after the jump
              0033* push bc       ; which constitutes the return address
              0034* jp   (ix)     ; Jump to the address in IX
              0035* ENDMACRO
              0036* 
              0037* ; Simulated call to soubroutinte at IY
              0038* ; inputs: IY pointing to the subroutine address plus whatever the called function expects
              0039* ; outputs: whatever the subroutine does, including IY and BC
              0040* ; destroys: only what the subroutine does, but always BC
              0041* MACRO callIY
              0042* ld bc,$+7     ; Address of first instruction after the jump
              0043* push bc       ; which constitutes the return address
              0044* jp   (iy)     ; Jump to the address in IY
              0045* ENDMACRO
              0046* 
              0047* ; put the value in HLU into the accumulator
              0048* ; destroys: af
              0049* MACRO HLU_TO_A
              0050* push hl ; 4 cycles
              0051* inc sp ; 1 cycle
              0052* pop af  ; 4 cycles
              0053* dec sp ; 1 cycle
              0054* ; 10 cycles total
              0055* ENDMACRO
              0056* 
              0057* A_TO_HLU:
              0058* ; call is 7 cycles
0B0EB7 22     0059* ld (@scratch),hl ; 7 cycles
0B0EB8 C4 
0B0EB9 0E 
0B0EBA 0B 
0B0EBB 32     0060* ld (@scratch+2),a ; 5 cycles
0B0EBC C6 
0B0EBD 0E 
0B0EBE 0B 
0B0EBF 2A     0061* ld hl,(@scratch) ; 7 cycles
0B0EC0 C4 
0B0EC1 0E 
0B0EC2 0B 
0B0EC3 C9     0062* ret ; 6 cycles
              0063* ; 25 cycles total
0B0EC4 00     0064* @scratch: dl 0
0B0EC5 00 
0B0EC6 00 
              0065* 
              0066* ; TODO: implement this
              0067* ; MACRO A_TO_HLU
              0068* ;     push.s af
              0069* ;     inc sp
              0070* ;     push.s hl
              0071* ;     pop hl
              0072* ;     inc sp
              0073* ;     inc sp
              0074* ; ENDMACRO
              0075* 
              0076* MACRO PUSH_ALL
              0077* ex af,af'
              0078* exx
              0079* push af
              0080* push hl
              0081* push bc
              0082* push de
              0083* 
              0084* ex af,af'
              0085* exx
              0086* push af
              0087* push hl
              0088* push bc
              0089* push de
              0090* push ix
              0091* push iy
              0092* ENDMACRO
              0093* 
              0094* MACRO POP_ALL
              0095* pop iy
              0096* pop ix
              0097* pop de
              0098* pop bc
              0099* pop hl
              0100* pop af
              0101* ex af,af'
              0102* exx
              0103* 
              0104* pop de
              0105* pop bc
              0106* pop hl
              0107* pop af
              0108* ex af,af'
              0109* exx
              0110* ENDMACRO
              0111* 
              0112* ; Print a zero-terminated string inline with code, e.g.:
              0113* ;
              0114* ;    call printInline
              0115* ;    ASCIZ "Hello, world!\r\n"
              0116* ;
              0117* ; Destroys: HL,AF
              0118* printInline:
0B0EC7 E1     0119* pop hl ; get the return address = pointer to start of string
0B0EC8 CD     0120* call printString ; HL advances to end of string
0B0EC9 CE 
0B0ECA 0E 
0B0ECB 0B 
0B0ECC E5     0121* push hl ; restore the return address = pointer to end of string
0B0ECD C9     0122* ret
              0123* 
              0124* ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
              0125* ; Print a zero-terminated string
              0126* ; HL: Pointer to string
              0127* printString:
0B0ECE C5     0128* PUSH	BC
0B0ECF 01     0129* LD		BC,0
0B0ED0 00 
0B0ED1 00 
0B0ED2 00 
0B0ED3 3E     0130* LD 	 	A,0
0B0ED4 00 
0B0ED5 5B     0131* RST.LIL 18h
0B0ED6 DF 
0B0ED7 C1     0132* POP		BC
0B0ED8 C9     0133* RET
              0134* ; print a VDU sequence
              0135* ; HL: Pointer to VDU sequence - <1 byte length> <data>
              0136* sendVDUsequence:
0B0ED9 C5     0137* PUSH	BC
0B0EDA 01     0138* LD		BC, 0
0B0EDB 00 
0B0EDC 00 
0B0EDD 00 
0B0EDE 4E     0139* LD		C, (HL)
0B0EDF 5B     0140* RST.LIL	18h
0B0EE0 DF 
0B0EE1 C1     0141* POP		BC
0B0EE2 C9     0142* RET
              0143* ; Print Newline sequence to VDP
              0144* printNewLine:
0B0EE3 F5     0145* push af ; for some reason rst.lil 10h sets carry flag
0B0EE4 3E     0146* LD	A, '\r'
0B0EE5 0D 
0B0EE6 5B     0147* RST.LIL 10h
0B0EE7 D7 
0B0EE8 3E     0148* LD	A, '\n'
0B0EE9 0A 
0B0EEA 5B     0149* RST.LIL 10h
0B0EEB D7 
0B0EEC F1     0150* pop af
0B0EED C9     0151* RET
              0152* 
              0153* ; Print a 24-bit HEX number
              0154* ; HLU: Number to print
              0155* printHex24:
              0156* HLU_TO_A
0B0EEE E5    0001*M push hl ; 4 cycles
0B0EEF 33    0002*M inc sp ; 1 cycle
0B0EF0 F1    0003*M pop af  ; 4 cycles
0B0EF1 3B    0004*M dec sp ; 1 cycle
             0005*M ; 10 cycles total
0B0EF2 CD     0157* CALL	printHex8
0B0EF3 FC 
0B0EF4 0E 
0B0EF5 0B 
              0158* ; Print a 16-bit HEX number
              0159* ; HL: Number to print
              0160* printHex16:
0B0EF6 7C     0161* LD		A,H
0B0EF7 CD     0162* CALL	printHex8
0B0EF8 FC 
0B0EF9 0E 
0B0EFA 0B 
0B0EFB 7D     0163* LD		A,L
              0164* ; Print an 8-bit HEX number
              0165* ; A: Number to print
              0166* printHex8:
0B0EFC 4F     0167* LD		C,A
0B0EFD 1F     0168* RRA
0B0EFE 1F     0169* RRA
0B0EFF 1F     0170* RRA
0B0F00 1F     0171* RRA
0B0F01 CD     0172* CALL	@F
0B0F02 06 
0B0F03 0F 
0B0F04 0B 
0B0F05 79     0173* LD		A,C
              0174* @@:
0B0F06 E6     0175* AND		0Fh
0B0F07 0F 
0B0F08 C6     0176* ADD		A,90h
0B0F09 90 
0B0F0A 27     0177* DAA
0B0F0B CE     0178* ADC		A,40h
0B0F0C 40 
0B0F0D 27     0179* DAA
0B0F0E 5B     0180* RST.LIL	10h
0B0F0F D7 
0B0F10 C9     0181* RET
              0182* 
              0183* printHexA:
0B0F11 F5     0184* push af
0B0F12 C5     0185* push bc
0B0F13 CD     0186* call printHex8
0B0F14 FC 
0B0F15 0E 
0B0F16 0B 
0B0F17 3E     0187* ld a,' '
0B0F18 20 
0B0F19 5B     0188* rst.lil 10h
0B0F1A D7 
0B0F1B C1     0189* pop bc
0B0F1C F1     0190* pop af
0B0F1D C9     0191* ret
              0192* 
              0193* printHexHL:
0B0F1E F5     0194* push af
0B0F1F C5     0195* push bc
0B0F20 CD     0196* call printHex16
0B0F21 F6 
0B0F22 0E 
0B0F23 0B 
0B0F24 3E     0197* ld a,' '
0B0F25 20 
0B0F26 5B     0198* rst.lil 10h
0B0F27 D7 
0B0F28 C1     0199* pop bc
0B0F29 F1     0200* pop af
0B0F2A C9     0201* ret
              0202* 
              0203* printHexUHL:
0B0F2B F5     0204* push af
0B0F2C C5     0205* push bc
0B0F2D CD     0206* call printHex24
0B0F2E EE 
0B0F2F 0E 
0B0F30 0B 
0B0F31 3E     0207* ld a,' '
0B0F32 20 
0B0F33 5B     0208* rst.lil 10h
0B0F34 D7 
0B0F35 C1     0209* pop bc
0B0F36 F1     0210* pop af
0B0F37 C9     0211* ret
              0212* 
              0213* printHexAUHL:
0B0F38 F5     0214* push af
0B0F39 C5     0215* push bc
0B0F3A CD     0216* call printHex8
0B0F3B FC 
0B0F3C 0E 
0B0F3D 0B 
0B0F3E 3E     0217* ld a,'.'
0B0F3F 2E 
0B0F40 5B     0218* rst.lil 10h
0B0F41 D7 
0B0F42 CD     0219* call printHex24
0B0F43 EE 
0B0F44 0E 
0B0F45 0B 
0B0F46 3E     0220* ld a,' '
0B0F47 20 
0B0F48 5B     0221* rst.lil 10h
0B0F49 D7 
0B0F4A C1     0222* pop bc
0B0F4B F1     0223* pop af
0B0F4C C9     0224* ret
              0225* 
              0226* printHexABHL:
              0227* ; preserve registers
0B0F4D C5     0228* push bc ; b will be ok c will not
0B0F4E F5     0229* push af ; will get totally destroyed
              0230* ; print a
0B0F4F CD     0231* call printHex8
0B0F50 FC 
0B0F51 0E 
0B0F52 0B 
              0232* ; print b
0B0F53 78     0233* ld a,b
0B0F54 CD     0234* call printHex8
0B0F55 FC 
0B0F56 0E 
0B0F57 0B 
              0235* ; print hl
0B0F58 CD     0236* call printHex16
0B0F59 F6 
0B0F5A 0E 
0B0F5B 0B 
              0237* ; restore registers
0B0F5C F1     0238* pop af
0B0F5D C1     0239* pop bc
0B0F5E C9     0240* ret
              0241* 
              0242* printHexBHL:
              0243* ; preserve registers
0B0F5F C5     0244* push bc ; b will be ok c will not
0B0F60 F5     0245* push af ; will get totally destroyed
              0246* ; print b
0B0F61 78     0247* ld a,b
0B0F62 CD     0248* call printHex8
0B0F63 FC 
0B0F64 0E 
0B0F65 0B 
              0249* ; print hl
0B0F66 CD     0250* call printHex16
0B0F67 F6 
0B0F68 0E 
0B0F69 0B 
              0251* ; restore registers
0B0F6A F1     0252* pop af
0B0F6B C1     0253* pop bc
0B0F6C C9     0254* ret
              0255* 
              0256* printHexCDE:
              0257* ; preserve registers
0B0F6D C5     0258* push bc ; b will be ok c will not
0B0F6E F5     0259* push af ; will get totally destroyed
              0260* ; print c
0B0F6F 79     0261* ld a,c
0B0F70 CD     0262* call printHex8
0B0F71 FC 
0B0F72 0E 
0B0F73 0B 
              0263* ; print de
0B0F74 EB     0264* ex de,hl
0B0F75 CD     0265* call printHex16
0B0F76 F6 
0B0F77 0E 
0B0F78 0B 
0B0F79 EB     0266* ex de,hl
              0267* ; restore registers
0B0F7A F1     0268* pop af
0B0F7B C1     0269* pop bc
0B0F7C C9     0270* ret
              0271* 
              0272* printHexUIX:
              0273* ; store everything in scratch
0B0F7D 22     0274* ld (uhl),hl
0B0F7E F6 
0B0F7F 13 
0B0F80 0B 
0B0F81 ED     0275* ld (ubc),bc
0B0F82 43 
0B0F83 F9 
0B0F84 13 
0B0F84 0B   
0B0F86 ED     0276* ld (ude),de
0B0F87 53 
0B0F88 FC 
0B0F89 13 
0B0F89 0B   
0B0F8B DD     0277* ld (uix),ix
0B0F8C 22 
0B0F8D FF 
0B0F8E 13 
0B0F8E 0B   
0B0F90 FD     0278* ld (uiy),iy
0B0F91 22 
0B0F92 02 
0B0F93 14 
0B0F93 0B   
0B0F95 F5     0279* push af ; fml
              0280* 
0B0F96 21     0281* ld hl,str_ixu
0B0F97 8D 
0B0F98 13 
0B0F99 0B 
0B0F9A CD     0282* call printString
0B0F9B CE 
0B0F9C 0E 
0B0F9D 0B 
0B0F9E 2A     0283* ld hl,(uix)
0B0F9F FF 
0B0FA0 13 
0B0FA1 0B 
0B0FA2 CD     0284* call printHex24
0B0FA3 EE 
0B0FA4 0E 
0B0FA5 0B 
0B0FA6 CD     0285* call printNewLine
0B0FA7 E3 
0B0FA8 0E 
0B0FA9 0B 
              0286* 
              0287* ; restore everything
0B0FAA 2A     0288* ld hl, (uhl)
0B0FAB F6 
0B0FAC 13 
0B0FAD 0B 
0B0FAE ED     0289* ld bc, (ubc)
0B0FAF 4B 
0B0FB0 F9 
0B0FB1 13 
0B0FB1 0B   
0B0FB3 ED     0290* ld de, (ude)
0B0FB4 5B 
0B0FB5 FC 
0B0FB6 13 
0B0FB6 0B   
0B0FB8 DD     0291* ld ix, (uix)
0B0FB9 2A 
0B0FBA FF 
0B0FBB 13 
0B0FBB 0B   
0B0FBD FD     0292* ld iy, (uiy)
0B0FBE 2A 
0B0FBF 02 
0B0FC0 14 
0B0FC0 0B   
0B0FC2 F1     0293* pop af
              0294* ; all done
0B0FC3 C9     0295* ret
              0296* 
              0297* ; Print a 0x HEX prefix
              0298* DisplayHexPrefix:
0B0FC4 3E     0299* LD	A, '0'
0B0FC5 30 
0B0FC6 5B     0300* RST.LIL 10h
0B0FC7 D7 
0B0FC8 3E     0301* LD	A, 'x'
0B0FC9 78 
0B0FCA 5B     0302* RST.LIL 10h
0B0FCB D7 
0B0FCC C9     0303* RET
              0304* 
              0305* MACRO printDecBC
              0306* push hl
              0307* push bc
              0308* pop hl
              0309* call printDec
              0310* pop hl
              0311* ENDMACRO
              0312* 
              0313* MACRO printDecDE
              0314* push hl
              0315* push de
              0316* pop hl
              0317* call printDec
              0318* pop hl
              0319* ENDMACRO
              0320* 
              0321* MACRO printDecHL
              0322* call printDec
              0323* ENDMACRO
              0324* 
              0325* MACRO printDecIX
              0326* push hl
              0327* push ix
              0328* pop hl
              0329* call printDec
              0330* pop hl
              0331* ENDMACRO
              0332* 
              0333* MACRO printDecIY
              0334* push hl
              0335* push iy
              0336* pop hl
              0337* call printDec
              0338* pop hl
              0339* ENDMACRO
              0340* 
              0341* 
              0342* ; Prints the right justified decimal value in HL without leading zeroes
              0343* ; HL : Value to print
              0344* ; preserves all registers and flags
              0345* printDec:
              0346* ; BEGIN MY CODE
              0347* ; back up all the things
0B0FCD F5     0348* push af
0B0FCE C5     0349* push bc
0B0FCF D5     0350* push de
0B0FD0 E5     0351* push hl
              0352* ; END MY CODE
0B0FD1 11     0353* LD	 DE, _printDecBuffer
0B0FD2 F9 
0B0FD3 0F 
0B0FD4 0B 
0B0FD5 CD     0354* CALL u24_to_ascii
0B0FD6 09 
0B0FD7 10 
0B0FD8 0B 
              0355* ; BEGIN MY CODE
              0356* ; replace leading zeroes with spaces
0B0FD9 21     0357* LD	 HL, _printDecBuffer
0B0FDA F9 
0B0FDB 0F 
0B0FDC 0B 
0B0FDD 06     0358* ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0FDE 07 
              0359* @loop:
0B0FDF 7E     0360* LD	 A, (HL)
0B0FE0 FE     0361* CP	 '0'
0B0FE1 30 
0B0FE2 C2     0362* JP	 NZ, @done
0B0FE3 EC 
0B0FE4 0F 
0B0FE5 0B 
0B0FE6 3E     0363* LD   A, ' '
0B0FE7 20 
0B0FE8 77     0364* LD	 (HL), A
0B0FE9 23     0365* INC	 HL
              0366* ; CALL vdu_cursor_forward
0B0FEA 10     0367* DJNZ @loop
0B0FEB F3 
              0368* @done:
              0369* ; END MY CODE
0B0FEC 21     0370* LD	 HL, _printDecBuffer
0B0FED F9 
0B0FEE 0F 
0B0FEF 0B 
0B0FF0 CD     0371* CALL printString
0B0FF1 CE 
0B0FF2 0E 
0B0FF3 0B 
              0372* ; BEGIN MY CODE
              0373* ; restore all the things
0B0FF4 E1     0374* pop hl
0B0FF5 D1     0375* pop de
0B0FF6 C1     0376* pop bc
0B0FF7 F1     0377* pop af
              0378* ; END MY CODE
0B0FF8 C9     0379* RET
0B0FF9 00     0380* _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
0B0FFA 00 
0B0FFB 00 
0B0FFC 00 
0B0FFC 00   
0B0FFD 00 
0B0FFE 00 
0B0FFF 00 
0B0FFF 00   
0B1000 00 
0B1001 00 
0B1002 00 
0B1002 00   
0B1003 00 
0B1004 00 
0B1005 00 
              0381* 
              0382* ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
              0383* ; starting to memory location pointing by DE, in decimal form and with leading zeroes
              0384* ; so it will allways be 8 characters length
              0385* ; HL : Value to convert to string
              0386* ; DE : pointer to buffer, at least 8 byte + 0
              0387* u24_to_ascii:
0B1009 01     0388* LD	 BC,-10000000
0B100A 80 
0B100B 69 
0B100C 67 
0B100D CD     0389* CALL @one_digit
0B100E 40 
0B100F 10 
0B1010 0B 
0B1011 01     0390* LD	 BC,-1000000
0B1012 C0 
0B1013 BD 
0B1014 F0 
0B1015 CD     0391* CALL @one_digit
0B1016 40 
0B1017 10 
0B1018 0B 
0B1019 01     0392* LD	 BC,-100000
0B101A 60 
0B101B 79 
0B101C FE 
0B101D CD     0393* CALL @one_digit
0B101E 40 
0B101F 10 
0B1020 0B 
0B1021 01     0394* LD   BC,-10000
0B1022 F0 
0B1023 D8 
0B1024 FF 
0B1025 CD     0395* CALL @one_digit
0B1026 40 
0B1027 10 
0B1028 0B 
0B1029 01     0396* LD   BC,-1000
0B102A 18 
0B102B FC 
0B102C FF 
0B102D CD     0397* CALL @one_digit
0B102E 40 
0B102F 10 
0B1030 0B 
0B1031 01     0398* LD   BC,-100
0B1032 9C 
0B1033 FF 
0B1034 FF 
0B1035 CD     0399* CALL @one_digit
0B1036 40 
0B1037 10 
0B1038 0B 
0B1039 0E     0400* LD   C,-10
0B103A F6 
0B103B CD     0401* CALL @one_digit
0B103C 40 
0B103D 10 
0B103E 0B 
0B103F 48     0402* LD   C,B
              0403* @one_digit:
0B1040 3E     0404* LD   A,'0'-1
0B1041 2F 
              0405* @divide_me:
0B1042 3C     0406* INC  A
0B1043 09     0407* ADD  HL,BC
0B1044 38     0408* JR   C,@divide_me
0B1045 FC 
0B1046 ED     0409* SBC  HL,BC
0B1047 42 
0B1048 12     0410* LD   (DE),A
0B1049 13     0411* INC  DE
0B104A C9     0412* RET
              0413* 
              0414* print_u24:
0B104B D5     0415* push de
0B104C E5     0416* push hl
0B104D 11     0417* ld de,_printDecBuffer
0B104E F9 
0B104F 0F 
0B1050 0B 
0B1051 CD     0418* call u24_to_ascii
0B1052 09 
0B1053 10 
0B1054 0B 
0B1055 21     0419* ld hl,_printDecBuffer
0B1056 F9 
0B1057 0F 
0B1058 0B 
0B1059 CD     0420* call printString
0B105A CE 
0B105B 0E 
0B105C 0B 
0B105D 3E     0421* ld a,' '
0B105E 20 
0B105F 5B     0422* rst.lil 10h
0B1060 D7 
0B1061 E1     0423* pop hl
0B1062 D1     0424* pop de
0B1063 C9     0425* ret
              0426* 
              0427* ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
              0428* ; HL : Value to convert to string (integer part in H, fractional part in L)
              0429* ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
              0430* u168_to_ascii:
              0431* ; add a leading space to make room for sign flag if needed
0B1064 3E     0432* ld a,' '
0B1065 20 
0B1066 12     0433* ld (de),a
0B1067 13     0434* inc de
              0435* ; Convert integer part
0B1068 E5     0436* push hl               ; Save HL (well need the fractional part later)
0B1069 CD     0437* call hlu_udiv256    ; Shift to get integer portion in HL
0B106A 52 
0B106B 15 
0B106C 0B 
0B106D 01     0438* ld   bc, -10000
0B106E F0 
0B106F D8 
0B1070 FF 
0B1071 CD     0439* call @one_int
0B1072 94 
0B1073 10 
0B1074 0B 
0B1075 01     0440* ld   bc, -1000
0B1076 18 
0B1077 FC 
0B1078 FF 
0B1079 CD     0441* call @one_int
0B107A 94 
0B107B 10 
0B107C 0B 
0B107D 01     0442* ld   bc, -100
0B107E 9C 
0B107F FF 
0B1080 FF 
0B1081 CD     0443* call @one_int
0B1082 94 
0B1083 10 
0B1084 0B 
0B1085 0E     0444* ld   c, -10
0B1086 F6 
0B1087 CD     0445* call @one_int
0B1088 94 
0B1089 10 
0B108A 0B 
0B108B 48     0446* ld   c, b
0B108C CD     0447* call @one_int
0B108D 94 
0B108E 10 
0B108F 0B 
0B1090 C3     0448* jp   @frac            ; Jump to fractional part conversion
0B1091 9F 
0B1092 10 
0B1093 0B 
              0449* @one_int:
0B1094 3E     0450* ld   a, '0' - 1       ; Start ASCII character at '0'
0B1095 2F 
              0451* @divide_me:
0B1096 3C     0452* inc  a
0B1097 09     0453* add  hl, bc           ; Accumulate until overflow
0B1098 38     0454* jr   c, @divide_me
0B1099 FC 
0B109A ED     0455* sbc  hl, bc           ; Remove excess after overflow
0B109B 42 
0B109C 12     0456* ld   (de), a          ; Store ASCII digit
0B109D 13     0457* inc  de
0B109E C9     0458* ret
              0459* ; Convert fractional part
              0460* @frac:
0B109F 3E     0461* ld   a, '.'           ; Decimal point
0B10A0 2E 
0B10A1 12     0462* ld   (de), a
0B10A2 13     0463* inc  de
0B10A3 E1     0464* pop  hl               ; Restore HL with original fraction
0B10A4 06     0465* ld   b, 3             ; Loop counter for 3 fractional digits
0B10A5 03 
              0466* @frac_loop:
0B10A6 26     0467* ld   h, 10            ; Load multiplier for fractional part
0B10A7 0A 
0B10A8 ED     0468* mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B10A9 6C 
0B10AA 3E     0469* ld   a, '0'
0B10AB 30 
0B10AC 84     0470* add  a, h             ; Convert integer part to ASCII
0B10AD 12     0471* ld   (de), a
0B10AE 13     0472* inc  de
0B10AF 10     0473* djnz @frac_loop       ; Repeat for each fractional digit
0B10B0 F5 
              0474* ; Add null terminator
0B10B1 AF     0475* xor  a                ; Null terminator
0B10B2 12     0476* ld   (de), a
0B10B3 C9     0477* ret
              0478* 
              0479* print_u168:
0B10B4 D5     0480* push de
0B10B5 E5     0481* push hl
0B10B6 11     0482* ld de,_printDecBuffer
0B10B7 F9 
0B10B8 0F 
0B10B9 0B 
0B10BA CD     0483* call u168_to_ascii
0B10BB 64 
0B10BC 10 
0B10BD 0B 
0B10BE 21     0484* ld hl,_printDecBuffer
0B10BF F9 
0B10C0 0F 
0B10C1 0B 
0B10C2 CD     0485* call printString
0B10C3 CE 
0B10C4 0E 
0B10C5 0B 
0B10C6 E1     0486* pop hl
0B10C7 D1     0487* pop de
0B10C8 C9     0488* ret
              0489* 
              0490* ; signed version of u168_to_ascii
              0491* s168_to_ascii:
0B10C9 D5     0492* push de ; save starting address of buffer
0B10CA CD     0493* call hlu_abs
0B10CB EB 
0B10CC 14 
0B10CD 0B 
0B10CE F5     0494* push af ; save sign flag
0B10CF CD     0495* call u168_to_ascii
0B10D0 64 
0B10D1 10 
0B10D2 0B 
0B10D3 F1     0496* pop af ; restore sign flag
0B10D4 D1     0497* pop de ; restore starting address of buffer
0B10D5 F0     0498* ret p ; hlu was positive so nothing to do
0B10D6 3E     0499* ld a,'-'
0B10D7 2D 
0B10D8 12     0500* ld (de),a
0B10D9 C9     0501* ret
              0502* 
              0503* print_s168:
0B10DA D5     0504* push de
0B10DB E5     0505* push hl
0B10DC 11     0506* ld de,_printDecBuffer
0B10DD F9 
0B10DE 0F 
0B10DF 0B 
0B10E0 CD     0507* call s168_to_ascii
0B10E1 C9 
0B10E2 10 
0B10E3 0B 
0B10E4 21     0508* ld hl,_printDecBuffer
0B10E5 F9 
0B10E6 0F 
0B10E7 0B 
0B10E8 CD     0509* call printString
0B10E9 CE 
0B10EA 0E 
0B10EB 0B 
0B10EC E1     0510* pop hl
0B10ED D1     0511* pop de
0B10EE C9     0512* ret
              0513* 
              0514* print_s168_hl:
0B10EF F5     0515* push af
0B10F0 E5     0516* push hl
0B10F1 CD     0517* call print_s168
0B10F2 DA 
0B10F3 10 
0B10F4 0B 
0B10F5 3E     0518* ld a,' '
0B10F6 20 
0B10F7 5B     0519* rst.lil 10h
0B10F8 D7 
0B10F9 E1     0520* pop hl
0B10FA F1     0521* pop af
0B10FB C9     0522* ret
              0523* 
              0524* print_s168_bc:
0B10FC F5     0525* push af
0B10FD C5     0526* push bc
0B10FE E5     0527* push hl
0B10FF C5     0528* push bc
0B1100 E1     0529* pop hl
0B1101 CD     0530* call print_s168
0B1102 DA 
0B1103 10 
0B1104 0B 
0B1105 3E     0531* ld a,' '
0B1106 20 
0B1107 5B     0532* rst.lil 10h
0B1108 D7 
0B1109 E1     0533* pop hl
0B110A C1     0534* pop bc
0B110B F1     0535* pop af
0B110C C9     0536* ret
              0537* 
              0538* print_s168_de:
0B110D F5     0539* push af
0B110E D5     0540* push de
0B110F E5     0541* push hl
0B1110 EB     0542* ex de,hl
0B1111 CD     0543* call print_s168
0B1112 DA 
0B1113 10 
0B1114 0B 
0B1115 3E     0544* ld a,' '
0B1116 20 
0B1117 5B     0545* rst.lil 10h
0B1118 D7 
0B1119 E1     0546* pop hl
0B111A D1     0547* pop de
0B111B F1     0548* pop af
0B111C C9     0549* ret
              0550* 
              0551* print_s168_hl_bc_de:
0B111D F5     0552* push af
0B111E C5     0553* push bc
0B111F D5     0554* push de
0B1120 E5     0555* push hl
0B1121 CD     0556* call print_s168
0B1122 DA 
0B1123 10 
0B1124 0B 
0B1125 3E     0557* ld a,' '
0B1126 20 
0B1127 5B     0558* rst.lil 10h
0B1128 D7 
0B1129 C5     0559* push bc
0B112A E1     0560* pop hl
0B112B CD     0561* call print_s168
0B112C DA 
0B112D 10 
0B112E 0B 
0B112F 3E     0562* ld a,' '
0B1130 20 
0B1131 5B     0563* rst.lil 10h
0B1132 D7 
0B1133 EB     0564* ex de,hl
0B1134 CD     0565* call print_s168
0B1135 DA 
0B1136 10 
0B1137 0B 
0B1138 3E     0566* ld a,' '
0B1139 20 
0B113A 5B     0567* rst.lil 10h
0B113B D7 
0B113C E1     0568* pop hl
0B113D D1     0569* pop de
0B113E C1     0570* pop bc
0B113F F1     0571* pop af
0B1140 C9     0572* ret
              0573* 
              0574* print_s168_bc_de:
0B1141 F5     0575* push af
0B1142 C5     0576* push bc
0B1143 D5     0577* push de
0B1144 C5     0578* push bc
0B1145 E1     0579* pop hl
0B1146 CD     0580* call print_s168
0B1147 DA 
0B1148 10 
0B1149 0B 
0B114A 3E     0581* ld a,' '
0B114B 20 
0B114C 5B     0582* rst.lil 10h
0B114D D7 
0B114E EB     0583* ex de,hl
0B114F CD     0584* call print_s168
0B1150 DA 
0B1151 10 
0B1152 0B 
0B1153 3E     0585* ld a,' '
0B1154 20 
0B1155 5B     0586* rst.lil 10h
0B1156 D7 
0B1157 E1     0587* pop hl
0B1158 D1     0588* pop de
0B1159 C1     0589* pop bc
0B115A F1     0590* pop af
0B115B C9     0591* ret
              0592* 
              0593* print_s168_a:
0B115C F5     0594* push af
0B115D C5     0595* push bc
0B115E E5     0596* push hl
0B115F 21     0597* ld hl,0
0B1160 00 
0B1161 00 
0B1162 00 
0B1163 6F     0598* ld l,a
0B1164 CD     0599* call print_s168_hl
0B1165 EF 
0B1166 10 
0B1167 0B 
0B1168 E1     0600* pop hl
0B1169 C1     0601* pop bc
0B116A F1     0602* pop af
0B116B C9     0603* ret
              0604* 
              0605* ; #### new functions added by Brandon R. Gates ####
              0606* 
              0607* ; print the binary representation of the 8-bit value in a
              0608* ; destroys a, hl, bc
              0609* printBin8:
0B116C 06     0610* ld b,8      ; loop counter for 8 bits
0B116D 08 
0B116E 21     0611* ld hl,@cmd  ; set hl to the low byte of the output string
0B116F 89 
0B1170 11 
0B1171 0B 
              0612* ; (which will be the high bit of the value in a)
              0613* @loop:
0B1172 07     0614* rlca ; put the next highest bit into carry
0B1173 38     0615* jr c,@one
0B1174 04 
0B1175 36     0616* ld (hl),'0'
0B1176 30 
0B1177 18     0617* jr @next_bit
0B1178 02 
              0618* @one:
0B1179 36     0619* ld (hl),'1'
0B117A 31 
              0620* @next_bit:
0B117B 23     0621* inc hl
0B117C 10     0622* djnz @loop
0B117D F4 
              0623* ; print it
0B117E 21     0624* ld hl,@cmd
0B117F 89 
0B1180 11 
0B1181 0B 
0B1182 01     0625* ld bc,@end-@cmd
0B1183 08 
0B1184 00 
0B1185 00 
0B1186 5B     0626* rst.lil $18
0B1187 DF 
0B1188 C9     0627* ret
              0628* @cmd: ds 8 ; eight bytes for eight bits
              0629* @end:
              0630* 
              0631* ; print the binary representation of the 8-bit value in a
              0632* ; in reverse order (lsb first)
              0633* ; destroys a, hl, bc
              0634* printBin8Rev:
0B1191 06     0635* ld b,8      ; loop counter for 8 bits
0B1192 08 
0B1193 21     0636* ld hl,@cmd  ; set hl to the low byte of the output string
0B1194 AE 
0B1195 11 
0B1196 0B 
              0637* ; (which will be the high bit of the value in a)
              0638* @loop:
0B1197 0F     0639* rrca ; put the next lowest bit into carry
0B1198 38     0640* jr c,@one
0B1199 04 
0B119A 36     0641* ld (hl),'0'
0B119B 30 
0B119C 18     0642* jr @next_bit
0B119D 02 
              0643* @one:
0B119E 36     0644* ld (hl),'1'
0B119F 31 
              0645* @next_bit:
0B11A0 23     0646* inc hl
0B11A1 10     0647* djnz @loop
0B11A2 F4 
              0648* ; print it
0B11A3 21     0649* ld hl,@cmd
0B11A4 AE 
0B11A5 11 
0B11A6 0B 
0B11A7 01     0650* ld bc,@end-@cmd
0B11A8 08 
0B11A9 00 
0B11AA 00 
0B11AB 5B     0651* rst.lil $18
0B11AC DF 
0B11AD C9     0652* ret
              0653* @cmd: ds 8 ; eight bytes for eight bits
              0654* @end:
              0655* 
              0656* ; print registers to screen in hexidecimal format
              0657* ; inputs: none
              0658* ; outputs: values of every register printed to screen
              0659* ;    values of each register in global scratch memory
              0660* ; destroys: nothing
              0661* stepRegistersHex:
              0662* ; store everything in scratch
0B11B6 22     0663* ld (uhl),hl
0B11B7 F6 
0B11B8 13 
0B11B9 0B 
0B11BA ED     0664* ld (ubc),bc
0B11BB 43 
0B11BC F9 
0B11BD 13 
0B11BD 0B   
0B11BF ED     0665* ld (ude),de
0B11C0 53 
0B11C1 FC 
0B11C2 13 
0B11C2 0B   
0B11C4 DD     0666* ld (uix),ix
0B11C5 22 
0B11C6 FF 
0B11C7 13 
0B11C7 0B   
0B11C9 FD     0667* ld (uiy),iy
0B11CA 22 
0B11CB 02 
0B11CC 14 
0B11CC 0B   
0B11CE F5     0668* push af ; fml
0B11CF E1     0669* pop hl  ; thanks, zilog
0B11D0 22     0670* ld (uaf),hl
0B11D1 F3 
0B11D2 13 
0B11D3 0B 
0B11D4 F5     0671* push af ; dammit
              0672* 
              0673* ; home the cursor
              0674* ; call vdu_home_cursor
              0675* 
              0676* ; print each register
0B11D5 21     0677* ld hl,str_afu
0B11D6 79 
0B11D7 13 
0B11D8 0B 
0B11D9 CD     0678* call printString
0B11DA CE 
0B11DB 0E 
0B11DC 0B 
0B11DD 2A     0679* ld hl,(uaf)
0B11DE F3 
0B11DF 13 
0B11E0 0B 
0B11E1 CD     0680* call printHex24
0B11E2 EE 
0B11E3 0E 
0B11E4 0B 
0B11E5 CD     0681* call printNewLine
0B11E6 E3 
0B11E7 0E 
0B11E8 0B 
              0682* 
0B11E9 21     0683* ld hl,str_hlu
0B11EA 7E 
0B11EB 13 
0B11EC 0B 
0B11ED CD     0684* call printString
0B11EE CE 
0B11EF 0E 
0B11F0 0B 
0B11F1 2A     0685* ld hl,(uhl)
0B11F2 F6 
0B11F3 13 
0B11F4 0B 
0B11F5 CD     0686* call printHex24
0B11F6 EE 
0B11F7 0E 
0B11F8 0B 
0B11F9 CD     0687* call printNewLine
0B11FA E3 
0B11FB 0E 
0B11FC 0B 
              0688* 
0B11FD 21     0689* ld hl,str_bcu
0B11FE 83 
0B11FF 13 
0B1200 0B 
0B1201 CD     0690* call printString
0B1202 CE 
0B1203 0E 
0B1204 0B 
0B1205 2A     0691* ld hl,(ubc)
0B1206 F9 
0B1207 13 
0B1208 0B 
0B1209 CD     0692* call printHex24
0B120A EE 
0B120B 0E 
0B120C 0B 
0B120D CD     0693* call printNewLine
0B120E E3 
0B120F 0E 
0B1210 0B 
              0694* 
0B1211 21     0695* ld hl,str_deu
0B1212 88 
0B1213 13 
0B1214 0B 
0B1215 CD     0696* call printString
0B1216 CE 
0B1217 0E 
0B1218 0B 
0B1219 2A     0697* ld hl,(ude)
0B121A FC 
0B121B 13 
0B121C 0B 
0B121D CD     0698* call printHex24
0B121E EE 
0B121F 0E 
0B1220 0B 
0B1221 CD     0699* call printNewLine
0B1222 E3 
0B1223 0E 
0B1224 0B 
              0700* 
0B1225 21     0701* ld hl,str_ixu
0B1226 8D 
0B1227 13 
0B1228 0B 
0B1229 CD     0702* call printString
0B122A CE 
0B122B 0E 
0B122C 0B 
0B122D 2A     0703* ld hl,(uix)
0B122E FF 
0B122F 13 
0B1230 0B 
0B1231 CD     0704* call printHex24
0B1232 EE 
0B1233 0E 
0B1234 0B 
0B1235 CD     0705* call printNewLine
0B1236 E3 
0B1237 0E 
0B1238 0B 
              0706* 
0B1239 21     0707* ld hl,str_iyu
0B123A 92 
0B123B 13 
0B123C 0B 
0B123D CD     0708* call printString
0B123E CE 
0B123F 0E 
0B1240 0B 
0B1241 2A     0709* ld hl,(uiy)
0B1242 02 
0B1243 14 
0B1244 0B 
0B1245 CD     0710* call printHex24
0B1246 EE 
0B1247 0E 
0B1248 0B 
0B1249 CD     0711* call printNewLine
0B124A E3 
0B124B 0E 
0B124C 0B 
              0712* 
              0713* ; call vsync
              0714* 
0B124D CD     0715* call printNewLine
0B124E E3 
0B124F 0E 
0B1250 0B 
              0716* 
              0717* ; check for right shift key and quit if pressed
              0718* MOSCALL mos_getkbmap
0B1251 3E    0001*M LD	A, function
0B1252 1E 
0B1253 49    0002*M RST.LIS	08h
0B1254 CF 
              0719* @stayhere:
              0720* ; 7 RightShift
0B1255 DD     0721* bit 6,(ix+0)
0B1256 CB 
0B1257 00 
0B1258 76 
0B1259 20     0722* jr nz,@RightShift
0B125A 02 
0B125B 18     0723* jr @stayhere
0B125C F8 
              0724* @RightShift:
0B125D DD     0725* res 0,(ix+14) ; debounce the key (hopefully)
0B125E CB 
0B125F 0E 
0B1260 86 
0B1261 3E     0726* ld a,%10000000
0B1262 80 
              0727* ; call multiPurposeDelay
              0728* 
              0729* ; restore everything
0B1263 2A     0730* ld hl, (uhl)
0B1264 F6 
0B1265 13 
0B1266 0B 
0B1267 ED     0731* ld bc, (ubc)
0B1268 4B 
0B1269 F9 
0B126A 13 
0B126A 0B   
0B126C ED     0732* ld de, (ude)
0B126D 5B 
0B126E FC 
0B126F 13 
0B126F 0B   
0B1271 DD     0733* ld ix, (uix)
0B1272 2A 
0B1273 FF 
0B1274 13 
0B1274 0B   
0B1276 FD     0734* ld iy, (uiy)
0B1277 2A 
0B1278 02 
0B1279 14 
0B1279 0B   
0B127B F1     0735* pop af
              0736* ; all done
0B127C C9     0737* ret
              0738* 
              0739* ; print registers to screen in hexidecimal format
              0740* ; inputs: none
              0741* ; outputs: values of every register printed to screen
              0742* ;    values of each register in global scratch memory
              0743* ; destroys: nothing
              0744* dumpRegistersHex:
              0745* ; store everything in scratch
0B127D 22     0746* ld (uhl),hl
0B127E F6 
0B127F 13 
0B1280 0B 
0B1281 ED     0747* ld (ubc),bc
0B1282 43 
0B1283 F9 
0B1284 13 
0B1284 0B   
0B1286 ED     0748* ld (ude),de
0B1287 53 
0B1288 FC 
0B1289 13 
0B1289 0B   
0B128B DD     0749* ld (uix),ix
0B128C 22 
0B128D FF 
0B128E 13 
0B128E 0B   
0B1290 FD     0750* ld (uiy),iy
0B1291 22 
0B1292 02 
0B1293 14 
0B1293 0B   
0B1295 F5     0751* push af ; fml
0B1296 E1     0752* pop hl  ; thanks, zilog
0B1297 22     0753* ld (uaf),hl
0B1298 F3 
0B1299 13 
0B129A 0B 
0B129B F5     0754* push af ; dammit
              0755* 
              0756* ; home the cursor
              0757* ; call vdu_home_cursor
              0758* ; call printNewLine
              0759* 
              0760* ; print each register
0B129C 21     0761* ld hl,str_afu
0B129D 79 
0B129E 13 
0B129F 0B 
0B12A0 CD     0762* call printString
0B12A1 CE 
0B12A2 0E 
0B12A3 0B 
0B12A4 2A     0763* ld hl,(uaf)
0B12A5 F3 
0B12A6 13 
0B12A7 0B 
0B12A8 CD     0764* call printHex24
0B12A9 EE 
0B12AA 0E 
0B12AB 0B 
              0765* ; call printNewLine
              0766* 
0B12AC 21     0767* ld hl,str_hlu
0B12AD 7E 
0B12AE 13 
0B12AF 0B 
0B12B0 CD     0768* call printString
0B12B1 CE 
0B12B2 0E 
0B12B3 0B 
0B12B4 2A     0769* ld hl,(uhl)
0B12B5 F6 
0B12B6 13 
0B12B7 0B 
0B12B8 CD     0770* call printHex24
0B12B9 EE 
0B12BA 0E 
0B12BB 0B 
              0771* ; call printNewLine
              0772* 
0B12BC 21     0773* ld hl,str_bcu
0B12BD 83 
0B12BE 13 
0B12BF 0B 
0B12C0 CD     0774* call printString
0B12C1 CE 
0B12C2 0E 
0B12C3 0B 
0B12C4 2A     0775* ld hl,(ubc)
0B12C5 F9 
0B12C6 13 
0B12C7 0B 
0B12C8 CD     0776* call printHex24
0B12C9 EE 
0B12CA 0E 
0B12CB 0B 
              0777* ; call printNewLine
              0778* 
0B12CC 21     0779* ld hl,str_deu
0B12CD 88 
0B12CE 13 
0B12CF 0B 
0B12D0 CD     0780* call printString
0B12D1 CE 
0B12D2 0E 
0B12D3 0B 
0B12D4 2A     0781* ld hl,(ude)
0B12D5 FC 
0B12D6 13 
0B12D7 0B 
0B12D8 CD     0782* call printHex24
0B12D9 EE 
0B12DA 0E 
0B12DB 0B 
              0783* ; call printNewLine
              0784* 
0B12DC 21     0785* ld hl,str_ixu
0B12DD 8D 
0B12DE 13 
0B12DF 0B 
0B12E0 CD     0786* call printString
0B12E1 CE 
0B12E2 0E 
0B12E3 0B 
0B12E4 2A     0787* ld hl,(uix)
0B12E5 FF 
0B12E6 13 
0B12E7 0B 
0B12E8 CD     0788* call printHex24
0B12E9 EE 
0B12EA 0E 
0B12EB 0B 
              0789* ; call printNewLine
              0790* 
0B12EC 21     0791* ld hl,str_iyu
0B12ED 92 
0B12EE 13 
0B12EF 0B 
0B12F0 CD     0792* call printString
0B12F1 CE 
0B12F2 0E 
0B12F3 0B 
0B12F4 2A     0793* ld hl,(uiy)
0B12F5 02 
0B12F6 14 
0B12F7 0B 
0B12F8 CD     0794* call printHex24
0B12F9 EE 
0B12FA 0E 
0B12FB 0B 
              0795* ; call printNewLine
              0796* 
              0797* ; call vdu_vblank
              0798* 
0B12FC CD     0799* call printNewLine
0B12FD E3 
0B12FE 0E 
0B12FF 0B 
              0800* ; restore everything
0B1300 2A     0801* ld hl, (uhl)
0B1301 F6 
0B1302 13 
0B1303 0B 
0B1304 ED     0802* ld bc, (ubc)
0B1305 4B 
0B1306 F9 
0B1307 13 
0B1307 0B   
0B1309 ED     0803* ld de, (ude)
0B130A 5B 
0B130B FC 
0B130C 13 
0B130C 0B   
0B130E DD     0804* ld ix, (uix)
0B130F 2A 
0B1310 FF 
0B1311 13 
0B1311 0B   
0B1313 FD     0805* ld iy, (uiy)
0B1314 2A 
0B1315 02 
0B1316 14 
0B1316 0B   
0B1318 F1     0806* pop af
              0807* ; all done
0B1319 C9     0808* ret
              0809* 
              0810* dumpRegistersHexPrime:
0B131A D9     0811* exx
0B131B 08     0812* ex af,af'
0B131C CD     0813* call dumpRegistersHex
0B131D 7D 
0B131E 12 
0B131F 0B 
0B1320 08     0814* ex af,af'
0B1321 D9     0815* exx
0B1322 C9     0816* ret
              0817* 
              0818* ; additionally dump prime registers
              0819* ; inputs: none
              0820* ; outputs: values of every register printed to screen
              0821* ; destroys: nothing
              0822* dumpRegistersHexAll:
0B1323 CD     0823* call dumpRegistersHex
0B1324 7D 
0B1325 12 
0B1326 0B 
0B1327 08     0824* ex af,af'
0B1328 D9     0825* exx
0B1329 CD     0826* call dumpRegistersHex
0B132A 7D 
0B132B 12 
0B132C 0B 
0B132D 08     0827* ex af,af'
0B132E D9     0828* exx
0B132F C9     0829* ret
              0830* 
              0831* ; print hlu to screen in hexidecimal format
              0832* ; inputs: none
              0833* ; destroys: nothing
              0834* print_hex_hl:
0B1330 F5     0835* push af
0B1331 E5     0836* push hl
0B1332 21     0837* ld hl,str_hlu
0B1333 7E 
0B1334 13 
0B1335 0B 
0B1336 CD     0838* call printString
0B1337 CE 
0B1338 0E 
0B1339 0B 
0B133A E1     0839* pop hl
0B133B E5     0840* push hl
0B133C CD     0841* call printHex24
0B133D EE 
0B133E 0E 
0B133F 0B 
0B1340 3E     0842* ld a,' '
0B1341 20 
0B1342 5B     0843* rst.lil 10h
0B1343 D7 
0B1344 E1     0844* pop hl
0B1345 F1     0845* pop af
0B1346 C9     0846* ret
              0847* 
              0848* ; print bcu to screen in hexidecimal format
              0849* ; inputs: none
              0850* ; destroys: nothing
              0851* print_hex_bc:
0B1347 F5     0852* push af
0B1348 E5     0853* push hl
0B1349 C5     0854* push bc
0B134A 21     0855* ld hl,str_bcu
0B134B 83 
0B134C 13 
0B134D 0B 
0B134E CD     0856* call printString
0B134F CE 
0B1350 0E 
0B1351 0B 
0B1352 E1     0857* pop hl
0B1353 E5     0858* push hl
0B1354 CD     0859* call printHex24
0B1355 EE 
0B1356 0E 
0B1357 0B 
0B1358 3E     0860* ld a,' '
0B1359 20 
0B135A 5B     0861* rst.lil 10h
0B135B D7 
0B135C C1     0862* pop bc
0B135D E1     0863* pop hl
0B135E F1     0864* pop af
0B135F C9     0865* ret
              0866* 
              0867* ; print deu to screen in hexidecimal format
              0868* ; inputs: none
              0869* ; destroys: nothing
              0870* print_hex_de:
0B1360 F5     0871* push af
0B1361 E5     0872* push hl
0B1362 D5     0873* push de
0B1363 21     0874* ld hl,str_deu
0B1364 88 
0B1365 13 
0B1366 0B 
0B1367 CD     0875* call printString
0B1368 CE 
0B1369 0E 
0B136A 0B 
0B136B E1     0876* pop hl
0B136C E5     0877* push hl
0B136D CD     0878* call printHex24
0B136E EE 
0B136F 0E 
0B1370 0B 
0B1371 3E     0879* ld a,' '
0B1372 20 
0B1373 5B     0880* rst.lil 10h
0B1374 D7 
0B1375 D1     0881* pop de
0B1376 E1     0882* pop hl
0B1377 F1     0883* pop af
0B1378 C9     0884* ret
              0885* 
0B1379 20     0886* str_afu: db " af=",0
0B137A 61 
0B137B 66 
0B137C 3D 
0B137C 00   
0B137E 20     0887* str_hlu: db " hl=",0
0B137F 68 
0B1380 6C 
0B1381 3D 
0B1381 00   
0B1383 20     0888* str_bcu: db " bc=",0
0B1384 62 
0B1385 63 
0B1386 3D 
0B1386 00   
0B1388 20     0889* str_deu: db " de=",0
0B1389 64 
0B138A 65 
0B138B 3D 
0B138B 00   
0B138D 20     0890* str_ixu: db " ix=",0
0B138E 69 
0B138F 78 
0B1390 3D 
0B1390 00   
0B1392 20     0891* str_iyu: db " iy=",0
0B1393 69 
0B1394 79 
0B1395 3D 
0B1395 00   
              0892* 
              0893* ; print udeuhl to screen in hexidecimal format
              0894* ; inputs: none
              0895* ; outputs: concatenated hexidecimal udeuhl
              0896* ; destroys: nothing
              0897* dumpUDEUHLHex:
              0898* ; store everything in scratch
0B1397 22     0899* ld (uhl),hl
0B1398 F6 
0B1399 13 
0B139A 0B 
0B139B ED     0900* ld (ubc),bc
0B139C 43 
0B139D F9 
0B139E 13 
0B139E 0B   
0B13A0 ED     0901* ld (ude),de
0B13A1 53 
0B13A2 FC 
0B13A3 13 
0B13A3 0B   
0B13A5 DD     0902* ld (uix),ix
0B13A6 22 
0B13A7 FF 
0B13A8 13 
0B13A8 0B   
0B13AA FD     0903* ld (uiy),iy
0B13AB 22 
0B13AC 02 
0B13AD 14 
0B13AD 0B   
0B13AF F5     0904* push af
              0905* 
              0906* ; print each register
              0907* 
0B13B0 21     0908* ld hl,str_udeuhl
0B13B1 EA 
0B13B2 13 
0B13B3 0B 
0B13B4 CD     0909* call printString
0B13B5 CE 
0B13B6 0E 
0B13B7 0B 
0B13B8 2A     0910* ld hl,(ude)
0B13B9 FC 
0B13BA 13 
0B13BB 0B 
0B13BC CD     0911* call printHex24
0B13BD EE 
0B13BE 0E 
0B13BF 0B 
0B13C0 3E     0912* ld a,'.'	; print a dot to separate the values
0B13C1 2E 
0B13C2 5B     0913* rst.lil 10h
0B13C3 D7 
0B13C4 2A     0914* ld hl,(uhl)
0B13C5 F6 
0B13C6 13 
0B13C7 0B 
0B13C8 CD     0915* call printHex24
0B13C9 EE 
0B13CA 0E 
0B13CB 0B 
0B13CC CD     0916* call printNewLine
0B13CD E3 
0B13CE 0E 
0B13CF 0B 
              0917* 
              0918* ; restore everything
0B13D0 2A     0919* ld hl, (uhl)
0B13D1 F6 
0B13D2 13 
0B13D3 0B 
0B13D4 ED     0920* ld bc, (ubc)
0B13D5 4B 
0B13D6 F9 
0B13D7 13 
0B13D7 0B   
0B13D9 ED     0921* ld de, (ude)
0B13DA 5B 
0B13DB FC 
0B13DC 13 
0B13DC 0B   
0B13DE DD     0922* ld ix, (uix)
0B13DF 2A 
0B13E0 FF 
0B13E1 13 
0B13E1 0B   
0B13E3 FD     0923* ld iy, (uiy)
0B13E4 2A 
0B13E5 02 
0B13E6 14 
0B13E6 0B   
0B13E8 F1     0924* pop af
              0925* ; all done
0B13E9 C9     0926* ret
              0927* 
0B13EA 75     0928* str_udeuhl: db "ude.uhl=",0
0B13EB 64 
0B13EC 65 
0B13ED 2E 
0B13ED 75   
0B13EE 68 
0B13EF 6C 
0B13F0 3D 
0B13F0 00   
              0929* 
              0930* ; global scratch memory for registers
0B13F3 00     0931* uaf: dl 0
0B13F4 00 
0B13F5 00 
0B13F6 00     0932* uhl: dl 0
0B13F7 00 
0B13F8 00 
0B13F9 00     0933* ubc: dl 0
0B13FA 00 
0B13FB 00 
0B13FC 00     0934* ude: dl 0
0B13FD 00 
0B13FE 00 
0B13FF 00     0935* uix: dl 0
0B1400 00 
0B1401 00 
0B1402 00     0936* uiy: dl 0
0B1403 00 
0B1404 00 
0B1405 00     0937* usp: dl 0
0B1406 00 
0B1407 00 
0B1408 00     0938* upc: dl 0
0B1409 00 
0B140A 00 
              0939* 
              0940* ; inputs: whatever is in the flags register
              0941* ; outputs: binary representation of flags
              0942* ;          with a header so we know which is what
              0943* ; destroys: nothing
              0944* ; preserves: everything
              0945* dumpFlags:
              0946* ; first we curse zilog for not giving direct access to flags
0B140B F5     0947* push af ; this is so we can send it back unharmed
0B140C F5     0948* push af ; this is so we can pop it to hl
              0949* ; store everything in scratch
0B140D 22     0950* ld (uhl),hl
0B140E F6 
0B140F 13 
0B1410 0B 
0B1411 ED     0951* ld (ubc),bc
0B1412 43 
0B1413 F9 
0B1414 13 
0B1414 0B   
0B1416 ED     0952* ld (ude),de
0B1417 53 
0B1418 FC 
0B1419 13 
0B1419 0B   
0B141B DD     0953* ld (uix),ix
0B141C 22 
0B141D FF 
0B141E 13 
0B141E 0B   
0B1420 FD     0954* ld (uiy),iy
0B1421 22 
0B1422 02 
0B1423 14 
0B1423 0B   
              0955* ; next we print the header
0B1425 21     0956* ld hl,@header
0B1426 51 
0B1427 14 
0B1428 0B 
0B1429 CD     0957* call printString
0B142A CE 
0B142B 0E 
0B142C 0B 
0B142D E1     0958* pop hl ; flags are now in l
0B142E 7D     0959* ld a,l ; flags are now in a
0B142F CD     0960* call printBin8
0B1430 6C 
0B1431 11 
0B1432 0B 
0B1433 CD     0961* call printNewLine
0B1434 E3 
0B1435 0E 
0B1436 0B 
              0962* ; restore everything
0B1437 2A     0963* ld hl, (uhl)
0B1438 F6 
0B1439 13 
0B143A 0B 
0B143B ED     0964* ld bc, (ubc)
0B143C 4B 
0B143D F9 
0B143E 13 
0B143E 0B   
0B1440 ED     0965* ld de, (ude)
0B1441 5B 
0B1442 FC 
0B1443 13 
0B1443 0B   
0B1445 DD     0966* ld ix, (uix)
0B1446 2A 
0B1447 FF 
0B1448 13 
0B1448 0B   
0B144A FD     0967* ld iy, (uiy)
0B144B 2A 
0B144C 02 
0B144D 14 
0B144D 0B   
0B144F F1     0968* pop af ; send her home the way she came
0B1450 C9     0969* ret
              0970* ; Bit 7 (S): Sign flag
              0971* ; Bit 6 (Z): Zero flag
              0972* ; Bit 5 (5): Reserved (copy of bit 5 of the result)
              0973* ; Bit 4 (H): Half Carry flag
              0974* ; Bit 3 (3): Reserved (copy of bit 3 of the result)
              0975* ; Bit 2 (PV): Parity/Overflow flag
              0976* ; Bit 1 (N): Subtract flag
              0977* ; Bit 0 (C): Carry flag
0B1451 53     0978* @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
0B1452 5A 
0B1453 78 
0B1454 48 
0B1454 78   
0B1455 50 
0B1456 4E 
0B1457 43 
0B1457 0D   
0B1458 0A 
0B1459 00 
              0979* 
              0980* ; set all the bits in the flag register
              0981* ; more of an academic exercise than anything useful
              0982* ; inputs; none
              0983* ; outputs; a=0,f=255
              0984* ; destroys: flags, hl
              0985* ; preserves: a, because why not
              0986* setAllFlags:
0B145C 21     0987* ld hl,255
0B145D FF 
0B145E 00 
0B145F 00 
0B1460 67     0988* ld h,a ; four cycles to preserve a is cheap
0B1461 E5     0989* push hl
0B1462 F1     0990* pop af
0B1463 C9     0991* ret
              0992* 
              0993* ; reset all the bits in the flag register
              0994* ; unlike its inverse counterpart, this may actually be useful
              0995* ; inputs; none
              0996* ; outputs; a=0,f=0
              0997* ; destroys: flags, hl
              0998* ; preserves: a, because why not
              0999* resetAllFlags:
0B1464 21     1000* ld hl,0
0B1465 00 
0B1466 00 
0B1467 00 
0B1468 67     1001* ld h,a ; four cycles to preserve a is cheap
0B1469 E5     1002* push hl
0B146A F1     1003* pop af
0B146B C9     1004* ret
              1005* 
              1006* ; wait until user presses a key
              1007* ; inputs: none
              1008* ; outputs: ascii code of key pressed in a
              1009* ; destroys: af,ix
              1010* waitKeypress:
              1011* MOSCALL mos_getkey
0B146C 3E    0001*M LD	A, function
0B146D 00 
0B146E 49    0002*M RST.LIS	08h
0B146F CF 
0B1470 C9     1012* ret
              1013* 
              1014* ; print bytes from an address to the screen in hexidecimal format
              1015* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1016* ; outputs: values of each byte printed to screen separated by spaces
              1017* ; destroys: nothing
              1018* dumpMemoryHex:
              1019* ; save registers to the stack
0B1471 C5     1020* push bc
0B1472 E5     1021* push hl
0B1473 F5     1022* push af
              1023* 
              1024* ; print the address and separator
0B1474 CD     1025* call printHex24
0B1475 EE 
0B1476 0E 
0B1477 0B 
0B1478 3E     1026* ld a,':'
0B1479 3A 
0B147A 5B     1027* rst.lil 10h
0B147B D7 
0B147C 3E     1028* ld a,' '
0B147D 20 
0B147E 5B     1029* rst.lil 10h
0B147F D7 
              1030* 
              1031* ; set b to be our loop counter
0B1480 F1     1032* pop af
0B1481 47     1033* ld b,a
0B1482 E1     1034* pop hl
0B1483 E5     1035* push hl
0B1484 F5     1036* push af
              1037* @loop:
              1038* ; print the byte
0B1485 7E     1039* ld a,(hl)
0B1486 CD     1040* call printHex8
0B1487 FC 
0B1488 0E 
0B1489 0B 
              1041* ; print a space
0B148A 3E     1042* ld a,' '
0B148B 20 
0B148C 5B     1043* rst.lil 10h
0B148D D7 
0B148E 23     1044* inc hl
0B148F 10     1045* djnz @loop
0B1490 F4 
0B1491 CD     1046* call printNewLine
0B1492 E3 
0B1493 0E 
0B1494 0B 
              1047* 
              1048* ; restore everything
0B1495 F1     1049* pop af
0B1496 E1     1050* pop hl
0B1497 C1     1051* pop bc
              1052* 
              1053* ; all done
0B1498 C9     1054* ret
              1055* 
              1056* 
              1057* ; print bytes from an address to the screen in binary format
              1058* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1059* ; outputs: values of each byte printed to screen separated by spaces
              1060* ; destroys: nothing
              1061* dumpMemoryBin:
              1062* ; save all registers to the stack
0B1499 F5     1063* push af
0B149A C5     1064* push bc
0B149B D5     1065* push de
0B149C E5     1066* push hl
0B149D DD     1067* push ix
0B149E E5 
0B149F FD     1068* push iy
0B14A0 E5 
              1069* 
              1070* ; set b to be our loop counter
0B14A1 47     1071* ld b,a
              1072* @loop:
              1073* ; print the byte
0B14A2 7E     1074* ld a,(hl)
0B14A3 E5     1075* push hl
0B14A4 C5     1076* push bc
0B14A5 CD     1077* call printBin8
0B14A6 6C 
0B14A7 11 
0B14A8 0B 
0B14A9 C1     1078* pop bc
              1079* ; print a space
0B14AA 3E     1080* ld a,' '
0B14AB 20 
0B14AC 5B     1081* rst.lil 10h
0B14AD D7 
0B14AE E1     1082* pop hl
0B14AF 23     1083* inc hl
0B14B0 10     1084* djnz @loop
0B14B1 F0 
0B14B2 CD     1085* call printNewLine
0B14B3 E3 
0B14B4 0E 
0B14B5 0B 
              1086* 
              1087* ; restore everything
0B14B6 FD     1088* pop iy
0B14B7 E1 
0B14B8 DD     1089* pop ix
0B14B9 E1 
0B14BA E1     1090* pop hl
0B14BB D1     1091* pop de
0B14BC C1     1092* pop bc
0B14BD F1     1093* pop af
              1094* ; all done
0B14BE C9     1095* ret
              1096* 
              1097* ; print bytes from an address to the screen in binary format
              1098* ; with the bits of each byte in reverse order (lsb first)
              1099* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1100* ; outputs: values of each byte printed to screen separated by spaces
              1101* ; destroys: nothing
              1102* dumpMemoryBinRev:
              1103* ; save all registers to the stack
0B14BF F5     1104* push af
0B14C0 C5     1105* push bc
0B14C1 D5     1106* push de
0B14C2 E5     1107* push hl
0B14C3 DD     1108* push ix
0B14C4 E5 
0B14C5 FD     1109* push iy
0B14C6 E5 
              1110* 
              1111* ; set b to be our loop counter
0B14C7 47     1112* ld b,a
              1113* @loop:
              1114* ; print the byte
0B14C8 7E     1115* ld a,(hl)
0B14C9 E5     1116* push hl
0B14CA C5     1117* push bc
0B14CB CD     1118* call printBin8Rev
0B14CC 91 
0B14CD 11 
0B14CE 0B 
0B14CF C1     1119* pop bc
              1120* ; print a space
0B14D0 3E     1121* ld a,' '
0B14D1 20 
0B14D2 5B     1122* rst.lil 10h
0B14D3 D7 
0B14D4 E1     1123* pop hl
0B14D5 23     1124* inc hl
0B14D6 10     1125* djnz @loop
0B14D7 F0 
0B14D8 CD     1126* call printNewLine
0B14D9 E3 
0B14DA 0E 
0B14DB 0B 
              1127* 
              1128* ; restore everything
0B14DC FD     1129* pop iy
0B14DD E1 
0B14DE DD     1130* pop ix
0B14DF E1 
0B14E0 E1     1131* pop hl
0B14E1 D1     1132* pop de
0B14E2 C1     1133* pop bc
0B14E3 F1     1134* pop af
              1135* ; all done
0B14E4 C9     1136* ret
               0181 include "maths.inc"
              0001* ;------------------------------------------------------------------------
              0002* ; Scratch area for calculations
              0003* ;------------------------------------------------------------------------
0B14E5 00     0004* scratch1:	dw24	0	;bit manipulation buffer 1
0B14E6 00 
0B14E7 00 
0B14E8 00     0005* scratch2:	dw24	0	;bit manipulation buffer 2
0B14E9 00 
0B14EA 00 
              0006* 
              0007* ; absolute value of hlu
              0008* ; returns: abs(hlu), flags set according to the incoming sign of hlu:
              0009* ;         s1,z0,pv0,n1,c0 if hlu was negative
              0010* ;         s0,z1,pv0,n1,c0 if hlu was zero
              0011* ;         s0,z0,pv0,n1,c0 if hlu was positive
              0012* ; destroys: a
              0013* hlu_abs:
0B14EB 19     0014* add hl,de
0B14EC B7     0015* or a
0B14ED ED     0016* sbc hl,de
0B14EE 52 
0B14EF FA     0017* jp m,@is_neg
0B14F0 F4 
0B14F1 14 
0B14F2 0B 
0B14F3 C9     0018* ret         ; hlu is positive or zero so we're done
              0019* @is_neg:
0B14F4 F5     0020* push af     ; otherwise, save current flags for return
0B14F5 CD     0021* call neg_hlu ; negate hlu
0B14F6 FB 
0B14F7 14 
0B14F8 0B 
0B14F9 F1     0022* pop af      ; get back flags
0B14FA C9     0023* ret
              0024* 
              0025* ; flip the sign of hlu
              0026* ; inputs: hlu
              0027* ; returns: 0-hlu, flags set appropriately for the result:
              0028* ;         s1,z0,pv0,n1,c1 if result is negative
              0029* ;         s0,z1,pv0,n1,c0 if result is zero
              0030* ;         s0,z0,pv0,n1,c1 if result is positive
              0031* ; destroys a
              0032* neg_hlu:
0B14FB D5     0033* push de     ; save de
0B14FC EB     0034* ex de,hl    ; put hl into de
0B14FD 21     0035* ld hl,0     ; clear hl
0B14FE 00 
0B14FF 00 
0B1500 00 
0B1501 AF     0036* xor a       ; clear carry
0B1502 ED     0037* sbc hl,de   ; 0-hlu = -hlu
0B1503 52 
0B1504 D1     0038* pop de      ; get de back
0B1505 C9     0039* ret         ; easy peasy
              0040* 
              0041* ;------------------------------------------------------------------------
              0042* ; divide hlu by 2, inspired by above
              0043* ;------------------------------------------------------------------------
              0044* hlu_div2:
0B1506 22     0045* ld		(scratch1),hl
0B1507 E5 
0B1508 14 
0B1509 0B 
0B150A 21     0046* ld		hl,scratch1+2
0B150B E7 
0B150C 14 
0B150D 0B 
0B150E CB     0047* rr		(hl)
0B150F 1E 
0B1510 2B     0048* dec		hl
0B1511 CB     0049* rr		(hl)
0B1512 1E 
0B1513 2B     0050* dec		hl
0B1514 CB     0051* rr		(hl)
0B1515 1E 
0B1516 23     0052* inc		hl
0B1517 23     0053* inc		hl
0B1518 2A     0054* ld hl,(scratch1)
0B1519 E5 
0B151A 14 
0B151B 0B 
0B151C C9     0055* ret
              0056* 
              0057* ; this is my little hack to divide by 16
              0058* hlu_div16:
0B151D AF     0059* xor a
0B151E 29     0060* add hl,hl
0B151F 17     0061* rla
0B1520 29     0062* add hl,hl
0B1521 17     0063* rla
0B1522 29     0064* add hl,hl
0B1523 17     0065* rla
0B1524 29     0066* add hl,hl
0B1525 17     0067* rla
0B1526 22     0068* ld (@scratch),hl
0B1527 33 
0B1528 15 
0B1529 0B 
0B152A 32     0069* ld (@scratch+3),a
0B152B 36 
0B152C 15 
0B152D 0B 
0B152E 2A     0070* ld hl,(@scratch+1)
0B152F 34 
0B1530 15 
0B1531 0B 
0B1532 C9     0071* ret
              0072* @scratch: ds 4
              0073* 
              0074* ; hlu signed division by 256
              0075* ; returns: hlu / 256
              0076* ; destroys: af
              0077* hlu_sdiv256:
0B1537 AF     0078* xor a ; assume hl is positive
0B1538 22     0079* ld (@buffer),hl
0B1539 4E 
0B153A 15 
0B153B 0B 
              0080* sign_hlu
0B153C 19    0001*M add hl,de
0B153D B7    0002*M or a
0B153E ED    0003*M sbc hl,de
0B153F 52 
0B1540 F2     0081* jp p,@hl_pos
0B1541 45 
0B1542 15 
0B1543 0B 
0B1544 3D     0082* dec a
              0083* @hl_pos:
0B1545 32     0084* ld (@buffer+3),a
0B1546 51 
0B1547 15 
0B1548 0B 
0B1549 2A     0085* ld hl,(@buffer+1)
0B154A 4F 
0B154B 15 
0B154C 0B 
0B154D C9     0086* ret
              0087* @buffer: ds 4
              0088* 
              0089* ; hlu 1 byte right shift, unsigned
              0090* ; returns: hlu / 256, fractional portion in a
              0091* ; destroys: af
              0092* hlu_udiv256:
0B1552 AF     0093* xor a
0B1553 32     0094* ld (@buffer+3),a
0B1554 64 
0B1555 15 
0B1556 0B 
0B1557 7D     0095* ld a,l ; save the fractional portion
0B1558 22     0096* ld (@buffer),hl
0B1559 61 
0B155A 15 
0B155B 0B 
0B155C 2A     0097* ld hl,(@buffer+1)
0B155D 62 
0B155E 15 
0B155F 0B 
0B1560 C9     0098* ret
              0099* @buffer: ds 4
              0100* 
              0101* MACRO hlu_mul256
              0102* add hl,hl ; * 2
              0103* add hl,hl ; * 4
              0104* add hl,hl ; * 8
              0105* add hl,hl ; * 16
              0106* add hl,hl ; * 32
              0107* add hl,hl ; * 64
              0108* add hl,hl ; * 128
              0109* add hl,hl ; * 256
              0110* ENDMACRO
              0111* 
              0112* ; compute the modulo of hlu by deu
              0113* ; outputs: hlu = hlu % deu
              0114* ; destroys: f, hl
              0115* hlu_mod:
0B1565 B7     0116* or a ; clear carry
              0117* @loop:
0B1566 ED     0118* sbc hl,de
0B1567 52 
0B1568 DA     0119* jp c, @end
0B1569 70 
0B156A 15 
0B156B 0B 
0B156C C3     0120* jp @loop
0B156D 66 
0B156E 15 
0B156F 0B 
              0121* @end:
0B1570 19     0122* add hl,de
0B1571 C9     0123* ret
              0124* 
              0125* 
0B1572 00     0126* add_bcd_arg1: db #00,#00,#00,#00
0B1573 00 
0B1574 00 
0B1575 00 
0B1576 00     0127* add_bcd_arg2: db #00,#00,#00,#00
0B1577 00 
0B1578 00 
0B1579 00 
              0128* 
              0129* ; set bcd values in a scratch memory address from registers bcde
              0130* ; input: hl; scratch address,bcde; 8-place bcd number
              0131* ; destroys ; hl
              0132* set_bcd:
0B157A 73     0133* ld (hl),e
0B157B 23     0134* inc hl
0B157C 72     0135* ld (hl),d
0B157D 23     0136* inc hl
0B157E 71     0137* ld (hl),c
0B157F 23     0138* inc hl
0B1580 70     0139* ld (hl),b
0B1581 C9     0140* ret
              0141* 
              0142* ; load bcd values from a scratch memory address to bcde
              0143* ; input: hl; scratch address
              0144* ; output: bcde; 8-place bcd number
              0145* ; destroys: hl
              0146* get_bcd:
0B1582 5E     0147* ld e,(hl)
0B1583 23     0148* inc hl
0B1584 56     0149* ld d,(hl)
0B1585 23     0150* inc hl
0B1586 4E     0151* ld c,(hl)
0B1587 23     0152* inc hl
0B1588 46     0153* ld b,(hl)
0B1589 C9     0154* ret
              0155* 
              0156* ; BCD addition
              0157* ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
              0158* ;       a is the number of bytes holding each number (number of places/2)
              0159* ; outputs: (hl) + (de) --> (hl)
              0160* ; destroys: a,b,de,hl
              0161* add_bcd:
0B158A 47     0162* ld b,a ; loop counter
0B158B AF     0163* xor a ; reset a, clear carry flag
              0164* adcec:
0B158C 1A     0165* ld a,(de) ; addend to acc
0B158D 8E     0166* adc a,(hl) ; add (hl) to acc
0B158E 27     0167* daa ; adjust result to bcd
0B158F 77     0168* ld (hl),a ; store result
0B1590 23     0169* inc hl ; advance memory pointers
0B1591 13     0170* inc de
0B1592 10     0171* djnz adcec ; loop until b == 0
0B1593 F8 
0B1594 C9     0172* ret
              0173* 
              0174* ; BCD subtraction
              0175* ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
              0176* ;       a is the number of bytes holding each number (number of places/2)
              0177* ; outputs: (hl) - (de) --> (hl)
              0178* ; destroys: a,b,de,hl
              0179* sub_bcd:
0B1595 47     0180* ld b,a ; loop counter
0B1596 AF     0181* xor a ; reset a,clear carry flag
              0182* subdec:
0B1597 1A     0183* ld a,(de) ; subtrahend to acc
0B1598 9E     0184* sbc a,(hl) ; subtract (hl) from acc
0B1599 27     0185* daa ; adjust result to bcd
0B159A 77     0186* ld (hl),a ; store result
0B159B 23     0187* inc hl ; advance memory pointers
0B159C 13     0188* inc de
0B159D 10     0189* djnz subdec ; loop until b == 0
0B159E F8 
0B159F C9     0190* ret
              0191* 
              0192* ; http://www.z80.info/pseudo-random.txt
              0193* rand_8:
0B15A0 C5     0194* push bc
0B15A1 3A     0195* ld a,(r_seed)
0B15A2 B4 
0B15A3 15 
0B15A4 0B 
0B15A5 4F     0196* ld c,a
              0197* 
0B15A6 0F     0198* rrca ; multiply by 32
0B15A7 0F     0199* rrca
0B15A8 0F     0200* rrca
0B15A9 EE     0201* xor 0x1f
0B15AA 1F 
              0202* 
0B15AB 81     0203* add a,c
0B15AC DE     0204* sbc a,255 ; carry
0B15AD FF 
              0205* 
0B15AE 32     0206* ld (r_seed),a
0B15AF B4 
0B15B0 15 
0B15B1 0B 
0B15B2 C1     0207* pop bc
0B15B3 C9     0208* ret
0B15B4 50     0209* r_seed: defb $50
               0182 include "fpp_ext.inc"
              0001* ; integer operations
              0002* iand:	EQU 58	; AND (INTEGER)
              0003* ibdiv:	EQU 59	; DIV
              0004* ieor:	EQU 60	; EOR
              0005* imod:	EQU 61	; MOD
              0006* ior:	EQU 62	; OR
              0007* ile:	EQU 63	; <=
              0008* ine:	EQU 64	; <>
              0009* ige:	EQU 65	; >=
              0010* ilt:	EQU 66	; <
              0011* ieq:	EQU 67	; =
              0012* imul:	EQU 68	; *
              0013* iadd:	EQU 69	; +
              0014* igt:	EQU 70	; >
              0015* isub:	EQU 71	; -
              0016* ipow:	EQU 72	; ^
              0017* idiv:	EQU 73	; /
              0018* ;
              0019* ; floating point functions
              0020* absv:	EQU 16	; ABS
              0021* acs:	EQU 17	; ACS
              0022* asn:	EQU 18	; ASN
              0023* atn:	EQU 19	; ATN
              0024* cos:	EQU 20	; COS
              0025* deg:	EQU 21	; DEG
              0026* exp:	EQU 22	; EXP
              0027* int_:	EQU 23	; INT
              0028* ln:	    EQU 24	; LN
              0029* log:	EQU 25	; LOG
              0030* notk:	EQU 26	; NOT
              0031* rad:	EQU 27	; RAD
              0032* sgn:	EQU 28	; SGN
              0033* sin:	EQU 29	; SIN
              0034* sqr:	EQU 30	; SQR
              0035* tan:	EQU 31	; TAN
              0036* zero:	EQU 32	; ZERO
              0037* fone:	EQU 33	; FONE
              0038* true:	EQU 34	; TRUE
              0039* pi:	    EQU 35	; PI
              0040* val:	EQU 36	; VAL
              0041* str:	EQU 37	; STR$
              0042* sfix:	EQU 38	; FIX
              0043* sfloat:	EQU 39	; FLOAT
              0044* ftest:	EQU 40	; TEST
              0045* fcomp:	EQU 41	; COMPARE
              0046* ;
              0047* ; floating point operations
              0048* fand:	EQU  0	; AND (FLOATING-POINT)
              0049* fbdiv:	EQU  1	; DIV
              0050* feor:	EQU  2	; EOR
              0051* fmod:	EQU  3	; MOD
              0052* ffor:	EQU  4	; OR
              0053* fle:	EQU  5	; <=
              0054* fne:	EQU  6	; <>
              0055* fge:	EQU  7	; >=
              0056* flt:	EQU  8	; <
              0057* feq:	EQU  9	; =
              0058* fmul:	EQU 10	; *
              0059* fadd:	EQU 11	; +
              0060* fgt:	EQU 12	; >
              0061* fsub:	EQU 13	; -
              0062* fpow:	EQU 14	; ^
              0063* fdiv:	EQU 15	; /
              0064* 
              0065* MACRO LOAD_FLOAT ARG
              0066* ld ix,$+11
              0067* call val_fp ; convert the string to a float
              0068* jp (ix)
              0069* asciz ARG
              0070* ENDMACRO
              0071* 
              0072* ; --- originally in eval.asm ---
              0073* ;SWAP - Swap arguments
              0074* ;Exchanges DE,HL D'E',H'L' and B,C
              0075* ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
              0076* ;
0B15B5 79     0077* SWAP:			LD      A,C
0B15B6 48     0078* LD      C,B
0B15B7 47     0079* LD      B,A
0B15B8 EB     0080* EX      DE,HL
0B15B9 D9     0081* EXX
0B15BA EB     0082* EX      DE,HL
0B15BB D9     0083* EXX
0B15BC C9     0084* RET
              0085* 
              0086* ; same as VAL_FP in fpp.asm, but preserves any float stored in DED'E'B
              0087* val_fp:
0B15BD FD     0088* push iy ; preserve
0B15BE E5 
0B15BF FD     0089* ld iy,@val
0B15C0 21 
0B15C1 DA 
0B15C2 15 
0B15C2 0B   
0B15C4 CD     0090* call store_float_iy_alt
0B15C5 CC 
0B15C6 16 
0B15C7 0B 
0B15C8 3E     0091* ld a,val
0B15C9 24 
0B15CA CD     0092* call FPP ; string converted to float in HLH'L'C
0B15CB D2 
0B15CC 00 
0B15CD 0B 
0B15CE FD     0093* ld iy,@val
0B15CF 21 
0B15D0 DA 
0B15D1 15 
0B15D1 0B   
0B15D3 CD     0094* call fetch_float_iy_alt
0B15D4 DE 
0B15D5 16 
0B15D6 0B 
0B15D7 FD     0095* pop iy ; restore
0B15D8 E1 
0B15D9 C9     0096* ret
              0097* @val: ds 5
              0098* 
              0099* ; same as INT_FP_ in fpp.asm but preserves B, which keeps any float stored in DED'E'B intact
              0100* ; af will also return differently from the original
              0101* ;INT - Floor function
              0102* ;Result is integer numeric.
              0103* ;
              0104* int_fp_:
0B15DF C5     0105* push bc ; preserve b
0B15E0 3E     0106* ld a,int_
0B15E1 17 
0B15E2 CD     0107* call FPP
0B15E3 D2 
0B15E4 00 
0B15E5 0B 
0B15E6 F1     0108* pop af ; restore b to a
0B15E7 47     0109* ld b,a ; restore b
0B15E8 C9     0110* RET
              0111* 
              0112* ; convert floating point number to integer and store it in HLU
              0113* ; inputs: HLH'L'C = floating point number
              0114* ; outputs: HLU = integer part of the number
              0115* ; destroys: all except DEU and U'D'E'B, index registers
              0116* int2hlu:
0B15E9 CD     0117* call int_fp_
0B15EA DF 
0B15EB 15 
0B15EC 0B 
0B15ED 7D     0118* ld a,l
0B15EE F5     0119* push af
0B15EF D9     0120* exx
0B15F0 E5     0121* push hl
0B15F1 D9     0122* exx
0B15F2 E1     0123* pop hl
0B15F3 F1     0124* pop af
0B15F4 CD     0125*  A_TO_HLU
0B15F5 B7 
0B15F6 0E 
0B15F7 0B 
0B15F8 C9     0126* ret
              0127* 
              0128* ; convert polar coordinates to cartesian coordinates as deltas from the origin
              0129* ; inputs: HLH'L'C = angle in radians
              0130* ;         DED'E'B = radius
              0131* ; outputs: HLH'L'C = dx
              0132* ;          DED'E'B = dy
              0133* polar_to_cartesian_fpp:
              0134* ; store input parameters in scratch
0B15F9 FD     0135* ld iy,@angle
0B15FA 21 
0B15FB 51 
0B15FC 16 
0B15FC 0B   
0B15FE CD     0136* call store_float_iy_nor
0B15FF A8 
0B1600 16 
0B1601 0B 
0B1602 FD     0137* ld iy,@radius
0B1603 21 
0B1604 56 
0B1605 16 
0B1605 0B   
0B1607 CD     0138* call store_float_iy_alt
0B1608 CC 
0B1609 16 
0B160A 0B 
              0139* ; compute dy = sin(angle) * radius
0B160B 3E     0140* ld a,sin
0B160C 1D 
0B160D CD     0141* call FPP ; HLH'L'C = sin(angle)
0B160E D2 
0B160F 00 
0B1610 0B 
0B1611 FD     0142* ld iy,@radius
0B1612 21 
0B1613 56 
0B1614 16 
0B1614 0B   
0B1616 CD     0143* call fetch_float_iy_alt ; DED'E'B = radius
0B1617 DE 
0B1618 16 
0B1619 0B 
0B161A 3E     0144* ld a,fmul
0B161B 0A 
0B161C CD     0145* call FPP ; HLH'L'C = sin(angle) * radius
0B161D D2 
0B161E 00 
0B161F 0B 
0B1620 FD     0146* ld iy,@scratch
0B1621 21 
0B1622 5B 
0B1623 16 
0B1623 0B   
0B1625 CD     0147* call store_float_iy_nor ; @scratch = dy
0B1626 A8 
0B1627 16 
0B1628 0B 
              0148* ; compute dx = cos(angle) * radius
0B1629 FD     0149* ld iy,@angle
0B162A 21 
0B162B 51 
0B162C 16 
0B162C 0B   
0B162E CD     0150* call fetch_float_iy_nor
0B162F BA 
0B1630 16 
0B1631 0B 
0B1632 3E     0151* ld a,cos
0B1633 14 
0B1634 CD     0152* call FPP ; HLH'L'C = cos(angle)
0B1635 D2 
0B1636 00 
0B1637 0B 
0B1638 FD     0153* ld iy,@radius
0B1639 21 
0B163A 56 
0B163B 16 
0B163B 0B   
0B163D CD     0154* call fetch_float_iy_alt ; DED'E'B = radius
0B163E DE 
0B163F 16 
0B1640 0B 
0B1641 3E     0155* ld a,fmul
0B1642 0A 
0B1643 CD     0156* call FPP ; HLH'L'C = cos(angle) * radius
0B1644 D2 
0B1645 00 
0B1646 0B 
              0157* ; restore dy from @scratch
0B1647 FD     0158* ld iy,@scratch
0B1648 21 
0B1649 5B 
0B164A 16 
0B164A 0B   
0B164C CD     0159* call fetch_float_iy_alt
0B164D DE 
0B164E 16 
0B164F 0B 
0B1650 C9     0160* ret
              0161* @angle: ds 5
              0162* @radius: ds 5
              0163* @scratch: ds 5
              0164* 
              0165* ; store HLH'L'C floating point number in a 40-bit buffer
              0166* ; inputs: HLH'L'C = floating point number
              0167* ;         ix = buffer address
              0168* ; outputs: buffer filled with floating point number
              0169* ; destroys: nothing
              0170* store_float_nor:
0B1660 DD     0171* ld (ix+0),c
0B1661 71 
0B1662 00 
0B1663 DD     0172* ld (ix+3),l
0B1664 75 
0B1665 03 
0B1666 DD     0173* ld (ix+4),h
0B1667 74 
0B1668 04 
0B1669 D9     0174* exx
0B166A DD     0175* ld (ix+1),l
0B166B 75 
0B166C 01 
0B166D DD     0176* ld (ix+2),h
0B166E 74 
0B166F 02 
0B1670 D9     0177* exx
0B1671 C9     0178* ret
              0179* 
              0180* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0181* ; inputs: ix = buffer address
              0182* ; outputs: HLH'L'C = floating point number
              0183* ; destroys: HLH'L'C
              0184* fetch_float_nor:
0B1672 DD     0185* ld c,(ix+0)
0B1673 4E 
0B1674 00 
0B1675 DD     0186* ld l,(ix+3)
0B1676 6E 
0B1677 03 
0B1678 DD     0187* ld h,(ix+4)
0B1679 66 
0B167A 04 
0B167B D9     0188* exx
0B167C DD     0189* ld l,(ix+1)
0B167D 6E 
0B167E 01 
0B167F DD     0190* ld h,(ix+2)
0B1680 66 
0B1681 02 
0B1682 D9     0191* exx
0B1683 C9     0192* ret
              0193* 
              0194* ; store DED'E'B floating point number in a 40-bit buffer
              0195* ; inputs: DED'E'B = floating point number
              0196* ;         ix = buffer address
              0197* ; outputs: buffer filled with floating point number
              0198* ; destroys: nothing
              0199* store_float_alt:
0B1684 DD     0200* ld (ix+0),b
0B1685 70 
0B1686 00 
0B1687 DD     0201* ld (ix+3),e
0B1688 73 
0B1689 03 
0B168A DD     0202* ld (ix+4),d
0B168B 72 
0B168C 04 
0B168D D9     0203* exx
0B168E DD     0204* ld (ix+1),e
0B168F 73 
0B1690 01 
0B1691 DD     0205* ld (ix+2),d
0B1692 72 
0B1693 02 
0B1694 D9     0206* exx
0B1695 C9     0207* ret
              0208* 
              0209* ; fetch DED'E'B floating point number from a 40-bit buffer
              0210* ; inputs: ix = buffer address
              0211* ; outputs: DED'E'B = floating point number
              0212* ; destroys: DED'E'B
              0213* fetch_float_alt:
0B1696 DD     0214* ld b,(ix+0)
0B1697 46 
0B1698 00 
0B1699 DD     0215* ld e,(ix+3)
0B169A 5E 
0B169B 03 
0B169C DD     0216* ld d,(ix+4)
0B169D 56 
0B169E 04 
0B169F D9     0217* exx
0B16A0 DD     0218* ld e,(ix+1)
0B16A1 5E 
0B16A2 01 
0B16A3 DD     0219* ld d,(ix+2)
0B16A4 56 
0B16A5 02 
0B16A6 D9     0220* exx
0B16A7 C9     0221* ret
              0222* 
              0223* 
              0224* ; store HLH'L'C floating point number in a 40-bit buffer
              0225* ; inputs: HLH'L'C = floating point number
              0226* ;         iy = buffer address
              0227* ; outputs: buffer filled with floating point number
              0228* ; destroys: nothing
              0229* store_float_iy_nor:
0B16A8 FD     0230* ld (iy+0),c
0B16A9 71 
0B16AA 00 
0B16AB FD     0231* ld (iy+3),l
0B16AC 75 
0B16AD 03 
0B16AE FD     0232* ld (iy+4),h
0B16AF 74 
0B16B0 04 
0B16B1 D9     0233* exx
0B16B2 FD     0234* ld (iy+1),l
0B16B3 75 
0B16B4 01 
0B16B5 FD     0235* ld (iy+2),h
0B16B6 74 
0B16B7 02 
0B16B8 D9     0236* exx
0B16B9 C9     0237* ret
              0238* 
              0239* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0240* ; inputs: iy = buffer address
              0241* ; outputs: HLH'L'C = floating point number
              0242* ; destroys: HLH'L'C
              0243* fetch_float_iy_nor:
0B16BA FD     0244* ld c,(iy+0)
0B16BB 4E 
0B16BC 00 
0B16BD FD     0245* ld l,(iy+3)
0B16BE 6E 
0B16BF 03 
0B16C0 FD     0246* ld h,(iy+4)
0B16C1 66 
0B16C2 04 
0B16C3 D9     0247* exx
0B16C4 FD     0248* ld l,(iy+1)
0B16C5 6E 
0B16C6 01 
0B16C7 FD     0249* ld h,(iy+2)
0B16C8 66 
0B16C9 02 
0B16CA D9     0250* exx
0B16CB C9     0251* ret
              0252* 
              0253* ; store DED'E'B floating point number in a 40-bit buffer
              0254* ; inputs: DED'E'B = floating point number
              0255* ;         iy = buffer address
              0256* ; outputs: buffer filled with floating point number
              0257* ; destroys: nothing
              0258* store_float_iy_alt:
0B16CC FD     0259* ld (iy+0),b
0B16CD 70 
0B16CE 00 
0B16CF FD     0260* ld (iy+3),e
0B16D0 73 
0B16D1 03 
0B16D2 FD     0261* ld (iy+4),d
0B16D3 72 
0B16D4 04 
0B16D5 D9     0262* exx
0B16D6 FD     0263* ld (iy+1),e
0B16D7 73 
0B16D8 01 
0B16D9 FD     0264* ld (iy+2),d
0B16DA 72 
0B16DB 02 
0B16DC D9     0265* exx
0B16DD C9     0266* ret
              0267* 
              0268* ; fetch DED'E'B floating point number from a 40-bit buffer
              0269* ; inputs: iy = buffer address
              0270* ; outputs: DED'E'B = floating point number
              0271* ; destroys: DED'E'B
              0272* fetch_float_iy_alt:
0B16DE FD     0273* ld b,(iy+0)
0B16DF 46 
0B16E0 00 
0B16E1 FD     0274* ld e,(iy+3)
0B16E2 5E 
0B16E3 03 
0B16E4 FD     0275* ld d,(iy+4)
0B16E5 56 
0B16E6 04 
0B16E7 D9     0276* exx
0B16E8 FD     0277* ld e,(iy+1)
0B16E9 5E 
0B16EA 01 
0B16EB FD     0278* ld d,(iy+2)
0B16EC 56 
0B16ED 02 
0B16EE D9     0279* exx
0B16EF C9     0280* ret
              0281* 
              0282* ; print HLH'L'C floating point number in hex format
              0283* ; inputs: HLH'L'C = floating point number
              0284* print_float_hex_nor:
              0285* PUSH_ALL
0B16F0 08    0001*M ex af,af'
0B16F1 D9    0002*M exx
0B16F2 F5    0003*M push af
0B16F3 E5    0004*M push hl
0B16F4 C5    0005*M push bc
0B16F5 D5    0006*M push de
             0007*M 
0B16F6 08    0008*M ex af,af'
0B16F7 D9    0009*M exx
0B16F8 F5    0010*M push af
0B16F9 E5    0011*M push hl
0B16FA C5    0012*M push bc
0B16FB D5    0013*M push de
0B16FC DD    0014*M push ix
0B16FD E5 
0B16FE FD    0015*M push iy
0B16FF E5 
0B1700 C5     0286* push bc ; preserve c
0B1701 CD     0287* call printHex16
0B1702 F6 
0B1703 0E 
0B1704 0B 
0B1705 3E     0288* ld a,'.'
0B1706 2E 
0B1707 5B     0289* rst.lil 10h
0B1708 D7 
0B1709 D9     0290* exx
0B170A CD     0291* call printHex16
0B170B F6 
0B170C 0E 
0B170D 0B 
0B170E D9     0292* exx
0B170F 3E     0293* ld a,'^'
0B1710 5E 
0B1711 5B     0294* rst.lil 10h
0B1712 D7 
0B1713 C1     0295* pop bc ; restore c
0B1714 79     0296* ld a,c
0B1715 CD     0297* call printHex8
0B1716 FC 
0B1717 0E 
0B1718 0B 
              0298* POP_ALL
0B1719 FD    0001*M pop iy
0B171A E1 
0B171B DD    0002*M pop ix
0B171C E1 
0B171D D1    0003*M pop de
0B171E C1    0004*M pop bc
0B171F E1    0005*M pop hl
0B1720 F1    0006*M pop af
0B1721 08    0007*M ex af,af'
0B1722 D9    0008*M exx
             0009*M 
0B1723 D1    0010*M pop de
0B1724 C1    0011*M pop bc
0B1725 E1    0012*M pop hl
0B1726 F1    0013*M pop af
0B1727 08    0014*M ex af,af'
0B1728 D9    0015*M exx
0B1729 C9     0299* ret
              0300* 
              0301* ; print DED'E'B floating point number in hex format
              0302* ; inputs: DED'E'B = floating point number
              0303* print_float_hex_alt:
              0304* PUSH_ALL
0B172A 08    0001*M ex af,af'
0B172B D9    0002*M exx
0B172C F5    0003*M push af
0B172D E5    0004*M push hl
0B172E C5    0005*M push bc
0B172F D5    0006*M push de
             0007*M 
0B1730 08    0008*M ex af,af'
0B1731 D9    0009*M exx
0B1732 F5    0010*M push af
0B1733 E5    0011*M push hl
0B1734 C5    0012*M push bc
0B1735 D5    0013*M push de
0B1736 DD    0014*M push ix
0B1737 E5 
0B1738 FD    0015*M push iy
0B1739 E5 
0B173A C5     0305* push bc ; preserve b
0B173B EB     0306* ex de,hl
0B173C CD     0307* call printHex16
0B173D F6 
0B173E 0E 
0B173F 0B 
0B1740 EB     0308* ex de,hl
0B1741 3E     0309* ld a,'.'
0B1742 2E 
0B1743 5B     0310* rst.lil 10h
0B1744 D7 
0B1745 D9     0311* exx
0B1746 EB     0312* ex de,hl
0B1747 CD     0313* call printHex16
0B1748 F6 
0B1749 0E 
0B174A 0B 
0B174B EB     0314* ex de,hl
0B174C D9     0315* exx
0B174D 3E     0316* ld a,'^'
0B174E 5E 
0B174F 5B     0317* rst.lil 10h
0B1750 D7 
0B1751 F1     0318* pop af ; restore b to a
0B1752 CD     0319* call printHex8
0B1753 FC 
0B1754 0E 
0B1755 0B 
              0320* POP_ALL
0B1756 FD    0001*M pop iy
0B1757 E1 
0B1758 DD    0002*M pop ix
0B1759 E1 
0B175A D1    0003*M pop de
0B175B C1    0004*M pop bc
0B175C E1    0005*M pop hl
0B175D F1    0006*M pop af
0B175E 08    0007*M ex af,af'
0B175F D9    0008*M exx
             0009*M 
0B1760 D1    0010*M pop de
0B1761 C1    0011*M pop bc
0B1762 E1    0012*M pop hl
0B1763 F1    0013*M pop af
0B1764 08    0014*M ex af,af'
0B1765 D9    0015*M exx
0B1766 C9     0321* ret
              0322* 
              0323* print_floats_hex:
0B1767 CD     0324* call print_float_hex_nor
0B1768 F0 
0B1769 16 
0B176A 0B 
0B176B 3E     0325* ld a,' '
0B176C 20 
0B176D 5B     0326* rst.lil 10h
0B176E D7 
0B176F CD     0327* call print_float_hex_alt
0B1770 2A 
0B1771 17 
0B1772 0B 
0B1773 C9     0328* ret
              0329* 
              0330* ; print a floating point number in decimal format
              0331* ; inputs: HL'H'L'C is the number to print
              0332* ; outputs: number printed to screen
              0333* ;          ACCS null-terminated string representation of the number
              0334* ; destroys: everything except ix
              0335* print_float_dec:
              0336* print_float_dec_nor:
0B1774 DD     0337* push ix             ; preserve
0B1775 E5 
              0338* 
              0339* ; back up floats in normal and alternate registers
0B1776 DD     0340* ld ix,@float_nor
0B1777 21 
0B1778 B7 
0B1779 17 
0B1779 0B   
0B177B CD     0341* call store_float_nor
0B177C 60 
0B177D 16 
0B177E 0B 
0B177F DD     0342* ld ix,@float_alt
0B1780 21 
0B1781 BC 
0B1782 17 
0B1782 0B   
0B1784 CD     0343* call store_float_alt
0B1785 84 
0B1786 16 
0B1787 0B 
              0344* 
              0345* ; convert the number to a string
0B1788 11     0346* ld de,ACCS          ; point to the string accumulator
0B1789 00 
0B178A 22 
0B178B 0B 
0B178C DD     0347* ld ix,@G9-1         ; get the format code for the number
0B178D 21 
0B178E B4 
0B178F 17 
0B178F 0B   
0B1791 CD     0348* call STR_FP         ; convert the number to a string
0B1792 D1 
0B1793 08 
0B1794 0B 
0B1795 EB     0349* ex de,hl            ; point to end of the string
0B1796 36     0350* ld (hl),0           ; null-terminate the string
0B1797 00 
0B1798 21     0351* ld hl,ACCS          ; point to the string accumulator
0B1799 00 
0B179A 22 
0B179B 0B 
0B179C CD     0352* call printString
0B179D CE 
0B179E 0E 
0B179F 0B 
              0353* 
              0354* ; restore floats in normal and alternate registers
0B17A0 DD     0355* ld ix,@float_nor
0B17A1 21 
0B17A2 B7 
0B17A3 17 
0B17A3 0B   
0B17A5 CD     0356* call fetch_float_nor
0B17A6 72 
0B17A7 16 
0B17A8 0B 
0B17A9 DD     0357* ld ix,@float_alt
0B17AA 21 
0B17AB BC 
0B17AC 17 
0B17AC 0B   
0B17AE CD     0358* call fetch_float_alt
0B17AF 96 
0B17B0 16 
0B17B1 0B 
              0359* 
              0360* ; cleanup and go home
0B17B2 DD     0361* pop ix              ; restore
0B17B3 E1 
0B17B4 C9     0362* ret
0B17B5 09     0363* @G9:			DW    9
0B17B6 00 
              0364* @float_nor: ds 5
              0365* @float_alt: ds 5
              0366* 
              0367* print_float_dec_alt:
0B17C1 CD     0368* CALL SWAP
0B17C2 B5 
0B17C3 15 
0B17C4 0B 
0B17C5 CD     0369* CALL print_float_dec_nor
0B17C6 74 
0B17C7 17 
0B17C8 0B 
0B17C9 CD     0370* CALL SWAP
0B17CA B5 
0B17CB 15 
0B17CC 0B 
0B17CD C9     0371* ret
              0372* 
              0373* ;PI - Return PI (3.14159265)
              0374* ;Result is floating-point numeric.
              0375* ;
0B17CE 11     0376* pi_alt:			LD      DE,0x490F
0B17CF 0F 
0B17D0 49 
0B17D1 00 
0B17D2 D9     0377* EXX
0B17D3 11     0378* LD      DE,0xDAA2
0B17D4 A2 
0B17D5 DA 
0B17D6 00 
0B17D7 D9     0379* EXX
0B17D8 06     0380* LD      B,0x81
0B17D9 81 
0B17DA AF     0381* XOR     A               ;NUMERIC MARKER
0B17DB C9     0382* RET
              0383* 
              0384* ;PI - Return PI * 2 (6.28318531)
              0385* ;Result is floating-point numeric.
              0386* ;
0B17DC 11     0387* pi2_alt:		LD      DE,0x490F
0B17DD 0F 
0B17DE 49 
0B17DF 00 
0B17E0 D9     0388* EXX
0B17E1 11     0389* LD      DE,0xDAA3
0B17E2 A3 
0B17E3 DA 
0B17E4 00 
0B17E5 D9     0390* EXX
0B17E6 06     0391* LD      B,0x82
0B17E7 82 
0B17E8 AF     0392* XOR     A               ;NUMERIC MARKER
0B17E9 C9     0393* RET
               0183 include "vdu.inc"
              0001* 
              0002* ; VDU 30: Home cursor
              0003* vdu_home_cursor:
0B17EA 3E     0004* ld a,30
0B17EB 1E 
0B17EC 5B     0005* rst.lil $10
0B17ED D7 
0B17EE C9     0006* ret
              0007* 
              0008* cursor_on:
0B17EF 21     0009* ld hl,@cmd
0B17F0 FA 
0B17F1 17 
0B17F2 0B 
0B17F3 01     0010* ld bc,@end-@cmd
0B17F4 03 
0B17F5 00 
0B17F6 00 
0B17F7 5B     0011* rst.lil $18
0B17F8 DF 
0B17F9 C9     0012* ret
              0013* @cmd:
0B17FA 17     0014* db 23,1,1
0B17FB 01 
0B17FC 01 
              0015* @end:
              0016* 
              0017* cursor_off:
0B17FD 21     0018* ld hl,@cmd
0B17FE 08 
0B17FF 18 
0B1800 0B 
0B1801 01     0019* ld bc,@end-@cmd
0B1802 03 
0B1803 00 
0B1804 00 
0B1805 5B     0020* rst.lil $18
0B1806 DF 
0B1807 C9     0021* ret
              0022* @cmd:
0B1808 17     0023* db 23,1,0
0B1809 01 
0B180A 00 
              0024* @end:
              0025* 
              0026* ; VDU 9: Move cursor forward one character
              0027* vdu_cursor_forward:
0B180B 3E     0028* ld a,9
0B180C 09 
0B180D 5B     0029* rst.lil $10
0B180E D7 
0B180F C9     0030* ret
              0031* 
              0032* ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
              0033* ; inputs: c=x, b=y 8-bit unsigned integers
              0034* vdu_move_cursor:
0B1810 ED     0035* ld (@x0),bc
0B1811 43 
0B1812 21 
0B1813 18 
0B1813 0B   
0B1815 21     0036* ld hl,@cmd
0B1816 20 
0B1817 18 
0B1818 0B 
0B1819 01     0037* ld bc,@end-@cmd
0B181A 03 
0B181B 00 
0B181C 00 
0B181D 5B     0038* rst.lil $18
0B181E DF 
0B181F C9     0039* ret
0B1820 1F     0040* @cmd: 	db 31
0B1821 00     0041* @x0:	db 0
0B1822 00     0042* @y0: 	db 0
0B1823 00     0043* @end: 	db 0 ; padding
              0044* 
              0045* ; VDU 12: Clear text area (CLS)
              0046* vdu_cls:
0B1824 3E     0047* ld a,12
0B1825 0C 
0B1826 5B     0048* rst.lil $10
0B1827 D7 
0B1828 C9     0049* ret
              0050* 
              0051* vdu_flip:
0B1829 21     0052* ld hl,@cmd
0B182A 34 
0B182B 18 
0B182C 0B 
0B182D 01     0053* ld bc,@end-@cmd
0B182E 03 
0B182F 00 
0B1830 00 
0B1831 5B     0054* rst.lil $18
0B1832 DF 
0B1833 C9     0055* ret
0B1834 17     0056* @cmd: db 23,0,0xC3
0B1835 00 
0B1836 C3 
              0057* @end:
              0058* 
              0059* ; VDU 16: Clear graphics area (CLG)
              0060* vdu_clg:
0B1837 3E     0061* ld a,16
0B1838 10 
0B1839 5B     0062* rst.lil $10
0B183A D7 
0B183B C9     0063* ret
              0064* 
              0065* ; COLOUR MODES
              0066* ; Mode	Effect
              0067* ; 0	Set on-screen pixel to target colour value
              0068* ; 1	OR value with the on-screen pixel
              0069* ; 2	AND value with the on-screen pixel
              0070* ; 3	XOR value with the on-screen pixel
              0071* ; 4	Invert the on-screen pixel
              0072* ; 5	No operation
              0073* ; 6	AND the inverse of the specified colour with the on-screen pixel
              0074* ; 7	OR the inverse of the specified colour with the on-screen pixel
              0075* 
              0076* ; VDU 17, colour: Define text colour (COLOUR)
              0077* vdu_colour_text:
0B183C 32     0078* ld (@arg),a
0B183D 4C 
0B183E 18 
0B183F 0B 
0B1840 21     0079* ld hl,@cmd
0B1841 4B 
0B1842 18 
0B1843 0B 
0B1844 01     0080* ld bc,@end-@cmd
0B1845 02 
0B1846 00 
0B1847 00 
0B1848 5B     0081* rst.lil $18
0B1849 DF 
0B184A C9     0082* ret
0B184B 11     0083* @cmd: db 17
0B184C 00     0084* @arg: db 0
              0085* @end:
              0086* 
              0087* ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
              0088* ; inputs: a=mode, c=colour (add 128 to set background colour)
              0089* vdu_gcol:
0B184D 32     0090* ld (@mode),a
0B184E 62 
0B184F 18 
0B1850 0B 
0B1851 79     0091* ld a,c
0B1852 32     0092* ld (@col),a
0B1853 63 
0B1854 18 
0B1855 0B 
0B1856 21     0093* ld hl,@cmd
0B1857 61 
0B1858 18 
0B1859 0B 
0B185A 01     0094* ld bc,@end-@cmd
0B185B 03 
0B185C 00 
0B185D 00 
0B185E 5B     0095* rst.lil $18
0B185F DF 
0B1860 C9     0096* ret
0B1861 12     0097* @cmd:  db 18
0B1862 00     0098* @mode: db 0
0B1863 00     0099* @col:  db 0
              0100* @end:
              0101* 
              0102* 
              0103* ; VDU 28, left, bottom, right, top: Set text viewport **
              0104* ; MIND THE LITTLE-ENDIANESS
              0105* ; inputs: c=left,b=bottom,e=right,d=top
              0106* ; outputs; nothing
              0107* ; destroys: a might make it out alive
              0108* vdu_set_txt_viewport:
0B1864 ED     0109* ld (@lb),bc
0B1865 43 
0B1866 7A 
0B1867 18 
0B1867 0B   
0B1869 ED     0110* ld (@rt),de
0B186A 53 
0B186B 7C 
0B186C 18 
0B186C 0B   
0B186E 21     0111* ld hl,@cmd
0B186F 79 
0B1870 18 
0B1871 0B 
0B1872 01     0112* ld bc,@end-@cmd
0B1873 05 
0B1874 00 
0B1875 00 
0B1876 5B     0113* rst.lil $18
0B1877 DF 
0B1878 C9     0114* ret
0B1879 1C     0115* @cmd:   db 28 ; set text viewport command
0B187A 00     0116* @lb: 	dw 0x0000 ; set by bc
0B187B 00 
0B187C 00     0117* @rt: 	dw 0x0000 ; set by de
0B187D 00 
0B187E 00     0118* @end:   db 0x00	  ; padding
              0119* 
              0120* ; Wait for VBLANK interrupt
              0121* vdu_vblank:
0B187F DD     0122* PUSH 	IX
0B1880 E5 
              0123* MOSCALL	mos_sysvars
0B1881 3E    0001*M LD	A, function
0B1882 08 
0B1883 49    0002*M RST.LIS	08h
0B1884 CF 
0B1885 DD     0124* LD	A, (IX + sysvar_time + 0)
0B1886 7E 
0B1887 00 
              0125* @wait:
0B1888 DD     0126* CP 	A, (IX + sysvar_time + 0)
0B1889 BE 
0B188A 00 
0B188B 28     0127* JR	Z, @wait
0B188C FB 
0B188D DD     0128* POP	IX
0B188E E1 
0B188F C9     0129* RET
              0130* 
              0131* ; VDU 29, x; y;: Set graphics origin
              0132* ; This command sets the graphics origin.
              0133* ; The origin is the point on the screen where the coordinates (0,0) are located.
              0134* ; inputs: bc=x0,de=y0
              0135* ; outputs; nothing
              0136* ; destroys: a might make it out alive
              0137* vdu_set_gfx_origin:
0B1890 ED     0138* ld (@x0),bc
0B1891 43 
0B1892 A6 
0B1893 18 
0B1893 0B   
0B1895 ED     0139* ld (@y0),de
0B1896 53 
0B1897 A8 
0B1898 18 
0B1898 0B   
0B189A 21     0140* ld hl,@cmd
0B189B A5 
0B189C 18 
0B189D 0B 
0B189E 01     0141* ld bc,@end-@cmd
0B189F 05 
0B18A0 00 
0B18A1 00 
0B18A2 5B     0142* rst.lil $18
0B18A3 DF 
0B18A4 C9     0143* ret
0B18A5 1D     0144* @cmd:   db 29 ; set graphics origin command
0B18A6 00     0145* @x0: 	dw 0x0000 ; set by bc
0B18A7 00 
0B18A8 00     0146* @y0: 	dw 0x0000 ; set by de
0B18A9 00 
0B18AA 00     0147* @end:   db 0x00	  ; padding
              0148* 
              0149* ; VDU 24, left; bottom; right; top;: Set graphics viewport
              0150* ; NOTE: the order of the y-coordinate parameters are inverted
              0151* ; 	because we have turned off logical screen scaling
              0152* ; inputs: bc=x0,de=y0,ix=x1,iy=y1
              0153* ; outputs; nothing
              0154* ; destroys: a might make it out alive
              0155* vdu_set_gfx_viewport:
0B18AB ED     0156* ld (@x0),bc
0B18AC 43 
0B18AD CB 
0B18AE 18 
0B18AE 0B   
0B18B0 FD     0157* ld (@y1),iy
0B18B1 22 
0B18B2 CD 
0B18B3 18 
0B18B3 0B   
0B18B5 DD     0158* ld (@x1),ix
0B18B6 22 
0B18B7 CF 
0B18B8 18 
0B18B8 0B   
0B18BA ED     0159* ld (@y0),de
0B18BB 53 
0B18BC D1 
0B18BD 18 
0B18BD 0B   
0B18BF 21     0160* ld hl,@cmd
0B18C0 CA 
0B18C1 18 
0B18C2 0B 
0B18C3 01     0161* ld bc,@end-@cmd
0B18C4 09 
0B18C5 00 
0B18C6 00 
0B18C7 5B     0162* rst.lil $18
0B18C8 DF 
0B18C9 C9     0163* ret
0B18CA 18     0164* @cmd:   db 24 ; set graphics viewport command
0B18CB 00     0165* @x0: 	dw 0x0000 ; set by bc
0B18CC 00 
0B18CD 00     0166* @y1: 	dw 0x0000 ; set by iy
0B18CE 00 
0B18CF 00     0167* @x1: 	dw 0x0000 ; set by ix
0B18D0 00 
0B18D1 00     0168* @y0: 	dw 0x0000 ; set by de
0B18D2 00 
0B18D3 00     0169* @end:   db 0x00	  ; padding
              0170* 
              0171* ; SCREEN MODES
              0172* ; ===============================
              0173* ; Mode  Horz  Vert  Cols  Refresh
              0174* ; ---   ----  ----  ----  -------
              0175* ; 11    320   240   2     60hz
              0176* ; 139   320   240   2     60hz
              0177* ; 23    512   384   2     60hz
              0178* ; 151   512   384   2     60hz
              0179* ; 6     640   240   2     60hz
              0180* ; 134   640   240   2     60hz
              0181* ; 2     640   480   2     60hz
              0182* ; 130   640   480   2     60hz
              0183* ; 17    800   600   2     60hz
              0184* ; 145   800   600   2     60hz
              0185* ; 18    1024  768   2     60hz
              0186* ; 146   1024  768   2     60hz
              0187* ; ---   ----  ----  ----  -------
              0188* ; 10    320   240   4     60hz
              0189* ; 138   320   240   4     60hz
              0190* ; 22    512   384   4     60hz
              0191* ; 150   512   384   4     60hz
              0192* ; 5     640   240   4     60hz
              0193* ; 133   640   240   4     60hz
              0194* ; 1     640   480   4     60hz
              0195* ; 129   640   480   4     60hz
              0196* ; 16    800   600   4     60hz
              0197* ; 19    1024  768   4     60hz
              0198* ; ---   ----  ----  ----  -------
              0199* ; 9     320   240   16    60hz
              0200* ; 137   320   240   16    60hz
              0201* ; 21    512   384   16    60hz
              0202* ; 149   512   384   16    60hz
              0203* ; 4     640   240   16    60hz
              0204* ; 132   640   240   16    60hz
              0205* ; 0     640   480   16    60hz
              0206* ; 7     n/a   n/a   16    60hz
              0207* ; ---   ----  ----  ----  -------
              0208* ; 8     320   240   64    60hz
              0209* ; 136   320   240   64    60hz
              0210* ; 20    512   384   64    60hz
              0211* ; 3     640   240   64    60hz
              0212* ; ---   ----  ----  ----  -------
              0213* vdu_set_screen_mode:
0B18D4 32     0214* ld (@arg),a
0B18D5 E4 
0B18D6 18 
0B18D7 0B 
0B18D8 21     0215* ld hl,@cmd
0B18D9 E3 
0B18DA 18 
0B18DB 0B 
0B18DC 01     0216* ld bc,@end-@cmd
0B18DD 02 
0B18DE 00 
0B18DF 00 
0B18E0 5B     0217* rst.lil $18
0B18E1 DF 
0B18E2 C9     0218* ret
0B18E3 16     0219* @cmd: db 22 ; set screen mode
0B18E4 00     0220* @arg: db 0  ; screen mode parameter
              0221* @end:
              0222* 
              0223* ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
              0224* ; inputs: a is scaling mode, 1=on, 0=off
              0225* ; note: default setting on boot is scaling ON
              0226* vdu_set_scaling:
0B18E5 32     0227* ld (@arg),a
0B18E6 F7 
0B18E7 18 
0B18E8 0B 
0B18E9 21     0228* ld hl,@cmd
0B18EA F4 
0B18EB 18 
0B18EC 0B 
0B18ED 01     0229* ld bc,@end-@cmd
0B18EE 04 
0B18EF 00 
0B18F0 00 
0B18F1 5B     0230* rst.lil $18
0B18F2 DF 
0B18F3 C9     0231* ret
0B18F4 17     0232* @cmd: db 23,0,0xC0
0B18F5 00 
0B18F6 C0 
0B18F7 00     0233* @arg: db 0  ; scaling on/off
              0234* @end:
              0235* 
              0236* ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
              0237* ; inputs: hl=bufferId
              0238* vdu_buff_select:
0B18F8 22     0239* ld (@bufferId),hl
0B18F9 0A 
0B18FA 19 
0B18FB 0B 
0B18FC 21     0240* ld hl,@cmd
0B18FD 07 
0B18FE 19 
0B18FF 0B 
0B1900 01     0241* ld bc,@end-@cmd
0B1901 05 
0B1902 00 
0B1903 00 
0B1904 5B     0242* rst.lil $18
0B1905 DF 
0B1906 C9     0243* ret
0B1907 17     0244* @cmd: db 23,27,0x20
0B1908 1B 
0B1909 20 
0B190A 00     0245* @bufferId: dw 0x0000
0B190B 00 
0B190C 00     0246* @end: db 0x00 ; padding
              0247* 
              0248* ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
              0249* ; inputs: a=format; bc=width; de=height
              0250* ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
              0251* ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
              0252* ; 0 	RGBA8888 (4-bytes per pixel)
              0253* ; 1 	RGBA2222 (1-bytes per pixel)
              0254* ; 2 	Mono/Mask (1-bit per pixel)
              0255* ; 3 	Reserved for internal use by VDP (native format)
              0256* vdu_bmp_create:
0B190D ED     0257* ld (@width),bc
0B190E 43 
0B190F 29 
0B1910 19 
0B1910 0B   
0B1912 ED     0258* ld (@height),de
0B1913 53 
0B1914 2B 
0B1915 19 
0B1915 0B   
0B1917 32     0259* ld (@fmt),a
0B1918 2D 
0B1919 19 
0B191A 0B 
0B191B 21     0260* ld hl,@cmd
0B191C 26 
0B191D 19 
0B191E 0B 
0B191F 01     0261* ld bc,@end-@cmd
0B1920 08 
0B1921 00 
0B1922 00 
0B1923 5B     0262* rst.lil $18
0B1924 DF 
0B1925 C9     0263* ret
0B1926 17     0264* @cmd:       db 23,27,0x21
0B1927 1B 
0B1928 21 
0B1929 00     0265* @width:     dw 0x0000
0B192A 00 
0B192B 00     0266* @height:    dw 0x0000
0B192C 00 
0B192D 00     0267* @fmt:       db 0x00
              0268* @end:
              0269* 
              0270* ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
              0271* ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
              0272* vdu_load_img_rgba2_to_8:
              0273* ; backup the target buffer id and image dimensions
0B192E E5     0274* push hl
0B192F D5     0275* push de
0B1930 C5     0276* push bc
              0277* ; load the rgba2 image to working buffer 65534
0B1931 21     0278* ld hl,65534 ; temporary working buffer id
0B1932 FE 
0B1933 FF 
0B1934 00 
0B1935 CD     0279* call vdu_load_buffer_from_file
0B1936 38 
0B1937 1A 
0B1938 0B 
              0280* ; restore the image dimensions and target buffer id
0B1939 C1     0281* pop bc
0B193A D1     0282* pop de
0B193B E1     0283* pop hl
              0284* ; fall through to vdu_rgba2_to_8
              0285* 
              0286* ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
              0287* ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
              0288* ; the "expand bitmap" command is:
              0289* ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
              0290* ; and then to reverse the byte order to fix endian-ness:
              0291* ; VDU 23,0,&A0,targetBufferID%;24,4,4;
              0292* ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
              0293* ; VDU 23,27,&20,targetBufferID%;
              0294* ; VDU 23,27,&21,width%;height%;0
              0295* ; -------------------------------------------------------------------
              0296* ; inputs: bc,de image width,height ; hl = targetBufferId
              0297* ; prerequisites: rgba2 image data loaded into workingBufferId 65534
              0298* vdu_rgba2_to_8:
              0299* ; load the image dimensions and buffer id parameters
0B193C ED     0300* ld (@width),bc
0B193D 43 
0B193E 98 
0B193F 19 
0B193F 0B   
0B1941 ED     0301* ld (@height),de
0B1942 53 
0B1943 9A 
0B1944 19 
0B1944 0B   
0B1946 22     0302* ld (@bufferId0),hl
0B1947 7D 
0B1948 19 
0B1949 0B 
0B194A 22     0303* ld (@bufferId2),hl
0B194B 8A 
0B194C 19 
0B194D 0B 
0B194E 22     0304* ld (@bufferId1),hl
0B194F 93 
0B1950 19 
0B1951 0B 
              0305* ; clean up bytes that got stomped on by the ID loads
0B1952 3E     0306* ld a,0x48
0B1953 48 
0B1954 32     0307* ld (@bufferId0+2),a
0B1955 7F 
0B1956 19 
0B1957 0B 
0B1958 3E     0308* ld a,23
0B1959 17 
0B195A 32     0309* ld (@bufferId1+2),a
0B195B 95 
0B195C 19 
0B195D 0B 
0B195E 3E     0310* ld a,24
0B195F 18 
0B1960 32     0311* ld (@bufferId2+2),a
0B1961 8C 
0B1962 19 
0B1963 0B 
0B1964 AF     0312* xor a
0B1965 32     0313* ld (@height+2),a
0B1966 9C 
0B1967 19 
0B1968 0B 
              0314* ; send the vdu command strings
0B1969 21     0315* ld hl,@beg
0B196A 74 
0B196B 19 
0B196C 0B 
0B196D 01     0316* ld bc,@end-@beg
0B196E 29 
0B196F 00 
0B1970 00 
0B1971 5B     0317* rst.lil $18
0B1972 DF 
0B1973 C9     0318* ret
              0319* @beg:
              0320* ; Command 14: Consolidate blocks in a buffer
              0321* ; VDU 23, 0, &A0, bufferId; 14
0B1974 17     0322* db 23,0,0xA0
0B1975 00 
0B1976 A0 
0B1977 FE     0323* dw 65534 ; workingBufferId
0B1978 FF 
0B1979 0E     0324* db 14 ; consolidate blocks
              0325* ; the "expand bitmap" command is:
              0326* ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B197A 17     0327* db 23,0,0xA0
0B197B 00 
0B197C A0 
0B197D 00     0328* @bufferId0: dw 0x0000 ; targetBufferId
0B197E 00 
0B197F 48     0329* db 0x48 ; given as decimal command 72 in the docs
0B1980 02     0330* db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B1981 FE     0331* dw 65534 ; sourceBufferId
0B1982 FF 
0B1983 00     0332* db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B1984 7F 
0B1985 BF 
0B1986 FF 
              0333* ; reverse the byte order to fix endian-ness:
              0334* ; Command 24: Reverse the order of data of blocks within a buffer
              0335* ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
              0336* ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B1987 17     0337* db 23,0,0xA0
0B1988 00 
0B1989 A0 
0B198A 00     0338* @bufferId2:    dw 0x0000 ; targetBufferId
0B198B 00 
0B198C 18     0339* db 24 ; reverse byte order
0B198D 04     0340* db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B198E 04     0341* dw 4 ; size (4 bytes)
0B198F 00 
              0342* ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
              0343* ; VDU 23,27,&20,targetBufferID%;
0B1990 17     0344* db 23,27,0x20 ; select bitmap
0B1991 1B 
0B1992 20 
0B1993 00     0345* @bufferId1: dw 0x0000 ; targetBufferId
0B1994 00 
              0346* ; VDU 23,27,&21,width%;height%;0
0B1995 17     0347* db 23,27,0x21 ; create bitmap from buffer
0B1996 1B 
0B1997 21 
0B1998 00     0348* @width: dw 0x0000
0B1999 00 
0B199A 00     0349* @height: dw 0x0000
0B199B 00 
0B199C 00     0350* db 0x00 ; rgba8888 format
              0351* @end:
              0352* 
              0353* ; scratch variables
0B199D 00     0354* bufferId0: dl 0x000000
0B199E 00 
0B199F 00 
0B19A0 00     0355* bufferId1: dl 0x000000
0B19A1 00 
0B19A2 00 
              0356* 
              0357* ; load a vdu buffer from local memory
              0358* ; inputs: hl = bufferId ; bc = length ; de = pointer to data
              0359* vdu_load_buffer:
0B19A3 ED     0360* ld (@length),bc
0B19A4 43 
0B19A5 CC 
0B19A6 19 
0B19A6 0B   
0B19A8 D5     0361* push de ; save data pointer
              0362* ; send the vdu command string
0B19A9 7D     0363* ld a,l
0B19AA 32     0364* ld (@bufferId),a
0B19AB C9 
0B19AC 19 
0B19AD 0B 
0B19AE 7C     0365* ld a,h
0B19AF 32     0366* ld (@bufferId+1),a
0B19B0 CA 
0B19B1 19 
0B19B2 0B 
0B19B3 21     0367* ld hl,@cmd
0B19B4 C6 
0B19B5 19 
0B19B6 0B 
0B19B7 01     0368* ld bc,@end-@cmd
0B19B8 08 
0B19B9 00 
0B19BA 00 
0B19BB 5B     0369* rst.lil $18
0B19BC DF 
              0370* ; send the buffer data
0B19BD E1     0371* pop hl ; pointer to data
0B19BE ED     0372* ld bc,(@length)
0B19BF 4B 
0B19C0 CC 
0B19C1 19 
0B19C1 0B   
0B19C3 5B     0373* rst.lil $18 ; send it
0B19C4 DF 
0B19C5 C9     0374* ret
              0375* ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B19C6 17     0376* @cmd:       db 23,0,0xA0
0B19C7 00 
0B19C8 A0 
0B19C9 00     0377* @bufferId:	dw 0x0000
0B19CA 00 
0B19CB 00     0378* db 0 ; load buffer
0B19CC 00     0379* @length:	dw 0x0000
0B19CD 00 
0B19CE 00     0380* @end: db 0 ; padding
              0381* 
              0382* ; clear a buffer
              0383* ; inputs: hl = bufferId
              0384* vdu_clear_buffer:
0B19CF 7D     0385* ld a,l
0B19D0 32     0386* ld (@bufferId),a
0B19D1 E7 
0B19D2 19 
0B19D3 0B 
0B19D4 7C     0387* ld a,h
0B19D5 32     0388* ld (@bufferId+1),a
0B19D6 E8 
0B19D7 19 
0B19D8 0B 
0B19D9 21     0389* ld hl,@cmd
0B19DA E4 
0B19DB 19 
0B19DC 0B 
0B19DD 01     0390* ld bc,@end-@cmd
0B19DE 06 
0B19DF 00 
0B19E0 00 
0B19E1 5B     0391* rst.lil $18
0B19E2 DF 
0B19E3 C9     0392* ret
0B19E4 17     0393* @cmd:       db 23,0,0xA0
0B19E5 00 
0B19E6 A0 
0B19E7 00     0394* @bufferId:	dw 0x0000
0B19E8 00 
0B19E9 02     0395* db 2 ; clear buffer
              0396* @end:
              0397* 
              0398* vdu_clear_all_buffers:
              0399* ; clear all buffers
0B19EA 21     0400* ld hl,@beg
0B19EB F5 
0B19EC 19 
0B19ED 0B 
0B19EE 01     0401* ld bc,@end-@beg
0B19EF 06 
0B19F0 00 
0B19F1 00 
0B19F2 5B     0402* rst.lil $18
0B19F3 DF 
0B19F4 C9     0403* ret
0B19F5 17     0404* @beg: db 23,0,$A0
0B19F6 00 
0B19F7 A0 
0B19F8 FF     0405* dw -1 ; clear all buffers
0B19F9 FF 
0B19FA 02     0406* db 2  ; command 2: clear a buffer
              0407* @end:
              0408* 
              0409* ; Command 14: Consolidate blocks in a buffer
              0410* vdu_consolidate_buffer:
              0411* ; set parameters for vdu call
0B19FB 7D     0412* ld a,l
0B19FC 32     0413* ld (@bufferId),a
0B19FD 13 
0B19FE 1A 
0B19FF 0B 
0B1A00 7C     0414* ld a,h
0B1A01 32     0415* ld (@bufferId+1),a
0B1A02 14 
0B1A03 1A 
0B1A04 0B 
0B1A05 21     0416* ld hl,@beg
0B1A06 10 
0B1A07 1A 
0B1A08 0B 
0B1A09 01     0417* ld bc,@end-@beg
0B1A0A 06 
0B1A0B 00 
0B1A0C 00 
0B1A0D 5B     0418* rst.lil $18
0B1A0E DF 
0B1A0F C9     0419* ret
              0420* ; VDU 23, 0, &A0, bufferId; 14
0B1A10 17     0421* @beg: db 23,0,0xA0
0B1A11 00 
0B1A12 A0 
0B1A13 00     0422* @bufferId: dw 0x0000
0B1A14 00 
0B1A15 0E     0423* db 14
              0424* @end:
              0425* 
              0426* ; load an image file to a buffer and make it a bitmap
              0427* ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
              0428* vdu_load_img:
              0429* ; back up image type and dimension parameters
0B1A16 22     0430* ld (bufferId0),hl
0B1A17 9D 
0B1A18 19 
0B1A19 0B 
0B1A1A F5     0431* push af
0B1A1B C5     0432* push bc
0B1A1C D5     0433* push de
              0434* ; load the image
0B1A1D CD     0435* call vdu_load_buffer_from_file
0B1A1E 38 
0B1A1F 1A 
0B1A20 0B 
              0436* ; now make it a bitmap
0B1A21 2A     0437* ld hl,(bufferId0)
0B1A22 9D 
0B1A23 19 
0B1A24 0B 
0B1A25 CD     0438* call vdu_consolidate_buffer
0B1A26 FB 
0B1A27 19 
0B1A28 0B 
0B1A29 2A     0439* ld hl,(bufferId0)
0B1A2A 9D 
0B1A2B 19 
0B1A2C 0B 
0B1A2D CD     0440* call vdu_buff_select
0B1A2E F8 
0B1A2F 18 
0B1A30 0B 
0B1A31 D1     0441* pop de ; image height
0B1A32 C1     0442* pop bc ; image width
0B1A33 F1     0443* pop af ; image type
0B1A34 C3     0444* jp vdu_bmp_create ; will return to caller from there
0B1A35 0D 
0B1A36 19 
0B1A37 0B 
              0445* 
              0446* ; inputs: hl = bufferId; iy = pointer to filename
              0447* vdu_load_buffer_from_file:
0B1A38 22     0448* ld (bufferId0),hl
0B1A39 9D 
0B1A3A 19 
0B1A3B 0B 
              0449* 
              0450* ; clear target buffer
0B1A3C CD     0451* call vdu_clear_buffer
0B1A3D CF 
0B1A3E 19 
0B1A3F 0B 
              0452* 
              0453* ; open the file in read mode
              0454* ; Open a file
              0455* ; HLU: Filename
              0456* ;   C: Mode
              0457* ; Returns:
              0458* ;   A: Filehandle, or 0 if couldn't open
0B1A40 FD     0459* push iy ; pointer to filename
0B1A41 E5 
0B1A42 E1     0460* pop hl
0B1A43 0E     0461* ld c,fa_read
0B1A44 01 
              0462* MOSCALL mos_fopen
0B1A45 3E    0001*M LD	A, function
0B1A46 0A 
0B1A47 49    0002*M RST.LIS	08h
0B1A48 CF 
0B1A49 32     0463* ld (@filehandle),a
0B1A4A 84 
0B1A4B 1A 
0B1A4C 0B 
              0464* 
              0465* @read_file:
              0466* ; Read a block of data from a file
              0467* ;   C: Filehandle
              0468* ; HLU: Pointer to where to write the data to
              0469* ; DEU: Number of bytes to read
              0470* ; Returns:
              0471* ; DEU: Number of bytes read
0B1A4D 3A     0472* ld a,(@filehandle)
0B1A4E 84 
0B1A4F 1A 
0B1A50 0B 
0B1A51 4F     0473* ld c,a
0B1A52 21     0474* ld hl,filedata
0B1A53 00 
0B1A54 E0 
0B1A55 B7 
0B1A56 11     0475* ld de,8192 ; max we can read into onboard sram at one time
0B1A57 00 
0B1A58 20 
0B1A59 00 
              0476* MOSCALL mos_fread
0B1A5A 3E    0001*M LD	A, function
0B1A5B 1A 
0B1A5C 49    0002*M RST.LIS	08h
0B1A5D CF 
              0477* 
              0478* ; ; DEBUG: print chunk size
              0479* ;     push de
              0480* ;     pop hl
              0481* ;     call printDec
              0482* ;     call printNewLine
              0483* 
              0484* ; test de for zero bytes read
0B1A5E 21     0485* ld hl,0
0B1A5F 00 
0B1A60 00 
0B1A61 00 
0B1A62 AF     0486* xor a ; clear carry
0B1A63 ED     0487* sbc hl,de
0B1A64 52 
0B1A65 CA     0488* jp z,@close_file
0B1A66 7B 
0B1A67 1A 
0B1A68 0B 
              0489* 
              0490* ; load a vdu buffer from local memory
              0491* ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1A69 2A     0492* ld hl,(bufferId0)
0B1A6A 9D 
0B1A6B 19 
0B1A6C 0B 
0B1A6D D5     0493* push de ; chunksize
0B1A6E C1     0494* pop bc
0B1A6F 11     0495* ld de,filedata
0B1A70 00 
0B1A71 E0 
0B1A72 B7 
0B1A73 CD     0496* call vdu_load_buffer
0B1A74 A3 
0B1A75 19 
0B1A76 0B 
              0497* 
              0498* ; ; print progress breadcrumbs
              0499* ;     ld a,'.'
              0500* ;     rst.lil 10h
              0501* 
              0502* ; read the next block
0B1A77 C3     0503* jp @read_file
0B1A78 4D 
0B1A79 1A 
0B1A7A 0B 
              0504* 
              0505* ; close the file
              0506* @close_file:
0B1A7B 3A     0507* ld a,(@filehandle)
0B1A7C 84 
0B1A7D 1A 
0B1A7E 0B 
              0508* MOSCALL mos_fclose
0B1A7F 3E    0001*M LD	A, function
0B1A80 0B 
0B1A81 49    0002*M RST.LIS	08h
0B1A82 CF 
0B1A83 C9     0509* ret ; vdu_load_buffer_from_file
              0510* 
0B1A84 00     0511* @filehandle: db 0 ; file handle
0B1A85 00     0512* @fil: dl 0 ; pointer to FIL struct
0B1A86 00 
0B1A87 00 
              0513* 
0B1A88 00     0514* @chunkpointer: dl 0 ; pointer to current chunk
0B1A89 00 
0B1A8A 00 
              0515* 
              0516* ; File information structure (FILINFO)
              0517* @filinfo:
0B1A8B 00     0518* @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B1A8C 00 
0B1A8D 00 
0B1A8E 00 
0B1A8F 00     0519* @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B1A90 00 
0B1A91 00     0520* @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B1A92 00 
0B1A93 00     0521* @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B1A94 00     0522* @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
0B1A95 00 
0B1A96 00 
0B1A97 00 
0B1A97 00   
0B1A98 00 
0B1A99 00 
0B1A9A 00 
0B1A9A 00   
0B1A9B 00 
0B1A9C 00 
0B1A9D 00 
0B1A9D 00   
0B1AA1 00     0523* @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
0B1AA2 00 
0B1AA3 00 
0B1AA4 00 
0B1AA4 00   
0B1AA5 00 
0B1AA6 00 
0B1AA7 00 
0B1AA7 00   
0B1AA8 00 
0B1AA9 00 
0B1AAA 00 
0B1AAA 00   
0B1AAB 00 
0B1AAC 00 
0B1AAD 00 
0B1AAD 00   
0B1AAE 00 
0B1AAF 00 
0B1AB0 00 
0B1AB0 00   
0B1AB1 00 
0B1AB2 00 
0B1AB3 00 
0B1AB3 00   
0B1AB4 00 
0B1AB5 00 
0B1AB6 00 
0B1AB6 00   
0B1AB7 00 
0B1AB8 00 
0B1AB9 00 
0B1AB9 00   
0B1ABA 00 
0B1ABB 00 
0B1ABC 00 
0B1ABC 00   
0B1ABD 00 
0B1ABE 00 
0B1ABF 00 
0B1ABF 00   
0B1AC0 00 
0B1AC1 00 
0B1AC2 00 
0B1AC2 00   
0B1AC3 00 
0B1AC4 00 
0B1AC5 00 
0B1AC5 00   
0B1AC6 00 
0B1AC7 00 
0B1AC8 00 
0B1AC8 00   
0B1AC9 00 
0B1ACA 00 
0B1ACB 00 
0B1ACB 00   
0B1ACC 00 
0B1ACD 00 
0B1ACE 00 
0B1ACE 00   
0B1ACF 00 
0B1AD0 00 
0B1AD1 00 
0B1AD1 00   
0B1AD2 00 
0B1AD3 00 
0B1AD4 00 
0B1AD4 00   
0B1AD5 00 
0B1AD6 00 
0B1AD7 00 
0B1AD7 00   
0B1AD8 00 
0B1AD9 00 
0B1ADA 00 
0B1ADA 00   
0B1ADB 00 
0B1ADC 00 
0B1ADD 00 
0B1ADD 00   
0B1ADE 00 
0B1ADF 00 
0B1AE0 00 
0B1AE0 00   
0B1AE1 00 
0B1AE2 00 
0B1AE3 00 
0B1AE3 00   
0B1AE4 00 
0B1AE5 00 
0B1AE6 00 
0B1AE6 00   
0B1AE7 00 
0B1AE8 00 
0B1AE9 00 
0B1AE9 00   
0B1AEA 00 
0B1AEB 00 
0B1AEC 00 
0B1AEC 00   
0B1AED 00 
0B1AEE 00 
0B1AEF 00 
0B1AEF 00   
0B1AF0 00 
0B1AF1 00 
0B1AF2 00 
0B1AF2 00   
0B1AF3 00 
0B1AF4 00 
0B1AF5 00 
0B1AF5 00   
0B1AF6 00 
0B1AF7 00 
0B1AF8 00 
0B1AF8 00   
0B1AF9 00 
0B1AFA 00 
0B1AFB 00 
0B1AFB 00   
0B1AFC 00 
0B1AFD 00 
0B1AFE 00 
0B1AFE 00   
0B1AFF 00 
0B1B00 00 
0B1B01 00 
0B1B01 00   
0B1B02 00 
0B1B03 00 
0B1B04 00 
0B1B04 00   
0B1B05 00 
0B1B06 00 
0B1B07 00 
0B1B07 00   
0B1B08 00 
0B1B09 00 
0B1B0A 00 
0B1B0A 00   
0B1B0B 00 
0B1B0C 00 
0B1B0D 00 
0B1B0D 00   
0B1B0E 00 
0B1B0F 00 
0B1B10 00 
0B1B10 00   
0B1B11 00 
0B1B12 00 
0B1B13 00 
0B1B13 00   
0B1B14 00 
0B1B15 00 
0B1B16 00 
0B1B16 00   
0B1B17 00 
0B1B18 00 
0B1B19 00 
0B1B19 00   
0B1B1A 00 
0B1B1B 00 
0B1B1C 00 
0B1B1C 00   
0B1B1D 00 
0B1B1E 00 
0B1B1F 00 
0B1B1F 00   
0B1B20 00 
0B1B21 00 
0B1B22 00 
0B1B22 00   
0B1B23 00 
0B1B24 00 
0B1B25 00 
0B1B25 00   
0B1B26 00 
0B1B27 00 
0B1B28 00 
0B1B28 00   
0B1B29 00 
0B1B2A 00 
0B1B2B 00 
0B1B2B 00   
0B1B2C 00 
0B1B2D 00 
0B1B2E 00 
0B1B2E 00   
0B1B2F 00 
0B1B30 00 
0B1B31 00 
0B1B31 00   
0B1B32 00 
0B1B33 00 
0B1B34 00 
0B1B34 00   
0B1B35 00 
0B1B36 00 
0B1B37 00 
0B1B37 00   
0B1B38 00 
0B1B39 00 
0B1B3A 00 
0B1B3A 00   
0B1B3B 00 
0B1B3C 00 
0B1B3D 00 
0B1B3D 00   
0B1B3E 00 
0B1B3F 00 
0B1B40 00 
0B1B40 00   
0B1B41 00 
0B1B42 00 
0B1B43 00 
0B1B43 00   
0B1B44 00 
0B1B45 00 
0B1B46 00 
0B1B46 00   
0B1B47 00 
0B1B48 00 
0B1B49 00 
0B1B49 00   
0B1B4A 00 
0B1B4B 00 
0B1B4C 00 
0B1B4C 00   
0B1B4D 00 
0B1B4E 00 
0B1B4F 00 
0B1B4F 00   
0B1B50 00 
0B1B51 00 
0B1B52 00 
0B1B52 00   
0B1B53 00 
0B1B54 00 
0B1B55 00 
0B1B55 00   
0B1B56 00 
0B1B57 00 
0B1B58 00 
0B1B58 00   
0B1B59 00 
0B1B5A 00 
0B1B5B 00 
0B1B5B 00   
0B1B5C 00 
0B1B5D 00 
0B1B5E 00 
0B1B5E 00   
0B1B5F 00 
0B1B60 00 
0B1B61 00 
               0184 include "vdu_plot.inc"
              0001* ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
              0002* ; PLOT code 	(Decimal) 	Effect
              0003* ; &00-&07 	0-7 	Solid line, includes both ends
              0004* plot_sl_both: equ 0x00
              0005* 
              0006* ; &08-&0F 	8-15 	Solid line, final point omitted
              0007* plot_sl_first: equ 0x08
              0008* 
              0009* ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
              0010* ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
              0011* 
              0012* ; &20-&27 	32-39 	Solid line, first point omitted
              0013* plot_sl_last: equ 0x20
              0014* 
              0015* ; &28-&2F 	40-47 	Solid line, both points omitted
              0016* plot_sl_none: equ 0x28
              0017* 
              0018* ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
              0019* ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
              0020* 
              0021* ; &40-&47 	64-71 	Point plot
              0022* plot_pt: equ 0x40
              0023* 
              0024* ; &48-&4F 	72-79 	Line fill left and right to non-background 
              0025* plot_lf_lr_non_bg: equ 0x48
              0026* 
              0027* ; &50-&57 	80-87 	Triangle fill
              0028* plot_tf: equ 0x50
              0029* 
              0030* ; &58-&5F 	88-95 	Line fill right to background 
              0031* plot_lf_r_bg: equ 0x58
              0032* 
              0033* ; &60-&67 	96-103 	Rectangle fill
              0034* plot_rf: equ 0x60
              0035* 
              0036* ; &68-&6F 	104-111 	Line fill left and right to foreground 
              0037* plot_lf_lr_fg: equ 0x60
              0038* 
              0039* ; &70-&77 	112-119 	Parallelogram fill
              0040* plot_pf: equ 0x70
              0041* 
              0042* ; &78-&7F 	120-127 	Line fill right to non-foreground 
              0043* plot_lf_r_non_fg: equ 0x78
              0044* 
              0045* ; &80-&87 	128-135 	Not supported (Flood until non-background)
              0046* ; &88-&8F 	136-143 	Not supported (Flood until foreground)
              0047* 
              0048* ; &90-&97 	144-151 	Circle outline
              0049* plot_co: equ 0x90
              0050* 
              0051* ; &98-&9F 	152-159 	Circle fill
              0052* plot_cf: equ 0x98
              0053* 
              0054* ; &A0-&A7 	160-167 	Not supported (Circular arc)
              0055* ; &A8-&AF 	168-175 	Not supported (Circular segment)
              0056* ; &B0-&B7 	176-183 	Not supported (Circular sector)
              0057* 
              0058* ; &B8-&BF 	184-191 	Rectangle copy/move
              0059* plot_rcm: equ 0xB8
              0060* 
              0061* ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
              0062* ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
              0063* ; &D0-&D7 	208-215 	Not defined
              0064* ; &D8-&DF 	216-223 	Not defined
              0065* ; &E0-&E7 	224-231 	Not defined
              0066* 
              0067* ; &E8-&EF 	232-239 	Bitmap plot 
              0068* plot_bmp: equ 0xE8
              0069* 
              0070* ; &F0-&F7 	240-247 	Not defined
              0071* ; &F8-&FF 	248-255 	Not defined
              0072* 
              0073* ;  Support added in Agon Console8 VDP 2.1.0  Support added in
              0074* ; Agon Console8 VDP 2.2.0
              0075* 
              0076* ; Within each group of eight plot codes, the effects are as follows:
              0077* ; Plot code 	Effect
              0078* ; 0 	Move relative
              0079* mv_rel: equ 0
              0080* 
              0081* ; 1 	Plot relative in current foreground colour
              0082* dr_rel_fg: equ 1
              0083* 
              0084* ; 2 	Not supported (Plot relative in logical inverse colour)
              0085* ; 3 	Plot relative in current background colour
              0086* dr_rel_bg: equ 3
              0087* 
              0088* ; 4 	Move absolute
              0089* mv_abs: equ 4
              0090* 
              0091* ; 5 	Plot absolute in current foreground colour
              0092* dr_abs_fg: equ 5
              0093* 
              0094* ; 6 	Not supported (Plot absolute in logical inverse colour)
              0095* ; 7 	Plot absolute in current background colour
              0096* dr_abs_bg: equ 7
              0097* 
              0098* ; Codes 0-3 use the position data provided as part of the command
              0099* ; as a relative position, adding the position given to the current
              0100* ; graphical cursor position. Codes 4-7 use the position data provided
              0101* ; as part of the command as an absolute position, setting the current
              0102* ; graphical cursor position to the position given.
              0103* 
              0104* ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
              0105* ; current pixel colour. These operations cannot currently be supported
              0106* ; by the graphics system the Agon VDP uses, so these codes are not
              0107* ; supported. Support for these codes may be added in a future version
              0108* ; of the VDP firmware.
              0109* 
              0110* ; 16 colour palette constants
              0111* c_black: equ 0
              0112* c_red_dk: equ 1
              0113* c_green_dk: equ 2
              0114* c_yellow_dk: equ 3
              0115* c_blue_dk: equ 4
              0116* c_magenta_dk: equ 5
              0117* c_cyan_dk: equ 6
              0118* c_grey: equ 7
              0119* c_grey_dk: equ 8
              0120* c_red: equ 9
              0121* c_green: equ 10
              0122* c_yellow: equ 11
              0123* c_blue: equ 12
              0124* c_magenta: equ 13
              0125* c_cyan: equ 14
              0126* c_white: equ 15
              0127* 
              0128* ; VDU 25, mode, x; y;: PLOT command
              0129* ; inputs: a=mode, bc=x0, de=y0
              0130* vdu_plot:
0B1BA1 32     0131* ld (@mode),a
0B1BA2 BB 
0B1BA3 1B 
0B1BA4 0B 
0B1BA5 ED     0132* ld (@x0),bc
0B1BA6 43 
0B1BA7 BC 
0B1BA8 1B 
0B1BA8 0B   
0B1BAA ED     0133* ld (@y0),de
0B1BAB 53 
0B1BAC BE 
0B1BAD 1B 
0B1BAD 0B   
0B1BAF 21     0134* ld hl,@cmd
0B1BB0 BA 
0B1BB1 1B 
0B1BB2 0B 
0B1BB3 01     0135* ld bc,@end-@cmd
0B1BB4 06 
0B1BB5 00 
0B1BB6 00 
0B1BB7 5B     0136* rst.lil $18
0B1BB8 DF 
0B1BB9 C9     0137* ret
0B1BBA 19     0138* @cmd:   db 25
0B1BBB 00     0139* @mode:  db 0
0B1BBC 00     0140* @x0: 	dw 0
0B1BBD 00 
0B1BBE 00     0141* @y0: 	dw 0
0B1BBF 00 
0B1BC0 00     0142* @end:   db 0 ; extra byte to soak up deu
              0143* 
              0144* ; VDU 25, mode, x; y;: PLOT command
              0145* ; USING 16.8 FIXED POINT COORDINATES
              0146* ; inputs: a=mode, ub.c=x0, ud.e=y0
              0147* vdu_plot_168:
0B1BC1 ED     0148* ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
0B1BC2 53 
0B1BC3 DD 
0B1BC4 1B 
0B1BC4 0B   
0B1BC6 ED     0149* ld (@x0-1),bc ; integer portion only
0B1BC7 43 
0B1BC8 DB 
0B1BC9 1B 
0B1BC9 0B   
0B1BCB 32     0150* ld (@mode),a  ; load this order b/c we shifted bc right
0B1BCC DB 
0B1BCD 1B 
0B1BCE 0B 
0B1BCF 21     0151* ld hl,@cmd
0B1BD0 DA 
0B1BD1 1B 
0B1BD2 0B 
0B1BD3 01     0152* ld bc,@end-@cmd
0B1BD4 06 
0B1BD5 00 
0B1BD6 00 
0B1BD7 5B     0153* rst.lil $18
0B1BD8 DF 
              0154* ; ld hl,@cmd
              0155* ; ld a,6
              0156* ; call dumpMemoryHex
              0157* ; call printNewLine
0B1BD9 C9     0158* ret
0B1BDA 19     0159* @cmd:   db 25
0B1BDB 00     0160* @mode:  db 0
0B1BDC 00     0161* @x0: 	dw 0
0B1BDD 00 
0B1BDE 00     0162* @y0: 	dw 0
0B1BDF 00 
              0163* @end:  ; no padding required b/c we shifted de right
              0164* 
              0165* ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
              0166* ; &E8-&EF 	232-239 	Bitmap plot 
              0167* ; VDU 25, mode, x; y;: PLOT command
              0168* ; inputs: bc=x0, de=y0
              0169* ; prerequisites: vdu_buff_select
              0170* vdu_plot_bmp:
0B1BE0 ED     0171* ld (@x0),bc
0B1BE1 43 
0B1BE2 F7 
0B1BE3 1B 
0B1BE3 0B   
0B1BE5 ED     0172* ld (@y0),de
0B1BE6 53 
0B1BE7 F9 
0B1BE8 1B 
0B1BE8 0B   
0B1BEA 21     0173* ld hl,@cmd
0B1BEB F5 
0B1BEC 1B 
0B1BED 0B 
0B1BEE 01     0174* ld bc,@end-@cmd
0B1BEF 06 
0B1BF0 00 
0B1BF1 00 
0B1BF2 5B     0175* rst.lil $18
0B1BF3 DF 
0B1BF4 C9     0176* ret
0B1BF5 19     0177* @cmd:   db 25
0B1BF6 ED     0178* @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1BF7 00     0179* @x0: 	dw 0x0000
0B1BF8 00 
0B1BF9 00     0180* @y0: 	dw 0x0000
0B1BFA 00 
0B1BFB 00     0181* @end:   db 0x00 ; padding
              0182* 
              0183* ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
              0184* ; &E8-&EF 	232-239 	Bitmap plot 
              0185* ; VDU 25, mode, x; y;: PLOT command
              0186* ; inputs: bc=x0, de=y0
              0187* ; USING 16.8 FIXED POINT COORDINATES
              0188* ; inputs: ub.c is x coordinate, ud.e is y coordinate
              0189* ;   the fractional portiion of the inputs are truncated
              0190* ;   leaving only the 16-bit integer portion
              0191* ; prerequisites: vdu_buff_select
              0192* vdu_plot_bmp168:
              0193* ; populate in the reverse of normal to keep the
              0194* ; inputs from stomping on each other
0B1BFC ED     0195* ld (@y0-1),de
0B1BFD 53 
0B1BFE 1A 
0B1BFF 1C 
0B1BFF 0B   
0B1C01 ED     0196* ld (@x0-1),bc
0B1C02 43 
0B1C03 18 
0B1C04 1C 
0B1C04 0B   
0B1C06 3E     0197* ld a,plot_bmp+dr_abs_fg ; 0xED
0B1C07 ED 
0B1C08 32     0198* ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B1C09 18 
0B1C0A 1C 
0B1C0B 0B 
0B1C0C 21     0199* ld hl,@cmd
0B1C0D 17 
0B1C0E 1C 
0B1C0F 0B 
0B1C10 01     0200* ld bc,@end-@cmd
0B1C11 06 
0B1C12 00 
0B1C13 00 
0B1C14 5B     0201* rst.lil $18
0B1C15 DF 
0B1C16 C9     0202* ret
0B1C17 19     0203* @cmd:   db 25
0B1C18 ED     0204* @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1C19 00     0205* @x0: 	dw 0x0000
0B1C1A 00 
0B1C1B 00     0206* @y0: 	dw 0x0000
0B1C1C 00 
              0207* @end:  ; no padding required b/c we shifted de right
              0208* 
              0209* ; draw a filled rectangle
              0210* vdu_plot_rf:
0B1C1D ED     0211* ld (@x0),bc
0B1C1E 43 
0B1C1F 44 
0B1C20 1C 
0B1C20 0B   
0B1C22 ED     0212* ld (@y0),de
0B1C23 53 
0B1C24 46 
0B1C25 1C 
0B1C25 0B   
0B1C27 DD     0213* ld (@x1),ix
0B1C28 22 
0B1C29 4A 
0B1C2A 1C 
0B1C2A 0B   
0B1C2C FD     0214* ld (@y1),iy
0B1C2D 22 
0B1C2E 4C 
0B1C2F 1C 
0B1C2F 0B   
0B1C31 3E     0215* ld a,25 ; we have to reload the 2nd plot command
0B1C32 19 
0B1C33 32     0216* ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1C34 48 
0B1C35 1C 
0B1C36 0B 
0B1C37 21     0217* ld hl,@cmd0
0B1C38 42 
0B1C39 1C 
0B1C3A 0B 
0B1C3B 01     0218* ld bc,@end-@cmd0
0B1C3C 0C 
0B1C3D 00 
0B1C3E 00 
0B1C3F 5B     0219* rst.lil $18
0B1C40 DF 
0B1C41 C9     0220* ret
0B1C42 19     0221* @cmd0:  db 25 ; plot
0B1C43 04     0222* @arg0:  db plot_sl_both+mv_abs
0B1C44 00     0223* @x0:    dw 0x0000
0B1C45 00 
0B1C46 00     0224* @y0:    dw 0x0000
0B1C47 00 
0B1C48 19     0225* @cmd1:  db 25 ; plot
0B1C49 65     0226* @arg1:  db plot_rf+dr_abs_fg
0B1C4A 00     0227* @x1:    dw 0x0000
0B1C4B 00 
0B1C4C 00     0228* @y1:    dw 0x0000
0B1C4D 00 
0B1C4E 00     0229* @end:   db 0x00 ; padding
              0230* 
              0231* ; draw a filled circle
              0232* vdu_plot_cf:
0B1C4F ED     0233* ld (@x0),bc
0B1C50 43 
0B1C51 76 
0B1C52 1C 
0B1C52 0B   
0B1C54 ED     0234* ld (@y0),de
0B1C55 53 
0B1C56 78 
0B1C57 1C 
0B1C57 0B   
0B1C59 DD     0235* ld (@x1),ix
0B1C5A 22 
0B1C5B 7C 
0B1C5C 1C 
0B1C5C 0B   
0B1C5E FD     0236* ld (@y1),iy
0B1C5F 22 
0B1C60 7E 
0B1C61 1C 
0B1C61 0B   
0B1C63 3E     0237* ld a,25 ; we have to reload the 2nd plot command
0B1C64 19 
0B1C65 32     0238* ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1C66 7A 
0B1C67 1C 
0B1C68 0B 
0B1C69 21     0239* ld hl,@cmd0
0B1C6A 74 
0B1C6B 1C 
0B1C6C 0B 
0B1C6D 01     0240* ld bc,@end-@cmd0
0B1C6E 0C 
0B1C6F 00 
0B1C70 00 
0B1C71 5B     0241* rst.lil $18
0B1C72 DF 
0B1C73 C9     0242* ret
0B1C74 19     0243* @cmd0:  db 25 ; plot
0B1C75 04     0244* @arg0:  db plot_sl_both+mv_abs
0B1C76 00     0245* @x0:    dw 0x0000
0B1C77 00 
0B1C78 00     0246* @y0:    dw 0x0000
0B1C79 00 
0B1C7A 19     0247* @cmd1:  db 25 ; plot
0B1C7B 9D     0248* @arg1:  db plot_cf+dr_abs_fg
0B1C7C 00     0249* @x1:    dw 0x0000
0B1C7D 00 
0B1C7E 00     0250* @y1:    dw 0x0000
0B1C7F 00 
0B1C80 00     0251* @end:   db 0x00 ; padding
              0252* 
              0253* ; VDU 25, mode, x; y;: PLOT command
              0254* ; inputs: a=mode, ix=x0, iy=y0
              0255* plot:
0B1C81 32     0256* ld (@mode),a
0B1C82 9B 
0B1C83 1C 
0B1C84 0B 
0B1C85 DD     0257* ld (@x0),ix
0B1C86 22 
0B1C87 9C 
0B1C88 1C 
0B1C88 0B   
0B1C8A FD     0258* ld (@y0),iy
0B1C8B 22 
0B1C8C 9E 
0B1C8D 1C 
0B1C8D 0B   
0B1C8F 21     0259* ld hl,@cmd
0B1C90 9A 
0B1C91 1C 
0B1C92 0B 
0B1C93 01     0260* ld bc,@end-@cmd
0B1C94 06 
0B1C95 00 
0B1C96 00 
0B1C97 5B     0261* rst.lil $18
0B1C98 DF 
0B1C99 C9     0262* ret
0B1C9A 19     0263* @cmd:   db 25
0B1C9B 00     0264* @mode:  db 0
0B1C9C 00     0265* @x0: 	dw 0
0B1C9D 00 
0B1C9E 00     0266* @y0: 	dw 0
0B1C9F 00 
0B1CA0 00     0267* @end:   db 0 ; padding
              0268* 
              0269* ; VDU 5: Write text at graphics cursor
              0270* ; inputs: hl = pointer to text, ix=x0, iy=y0
              0271* ; prerequisites: gcol foreground set, VDU 5 set
              0272* plot_text:
0B1CA1 E5     0273* push hl ; save text pointer
              0274* ; move graphics cursor to x0, y0
0B1CA2 3E     0275* ld a,plot_pt+mv_abs
0B1CA3 44 
0B1CA4 CD     0276* call plot
0B1CA5 81 
0B1CA6 1C 
0B1CA7 0B 
              0277* ; write text
0B1CA8 E1     0278* pop hl ; restore text pointer
0B1CA9 CD     0279* call printString
0B1CAA CE 
0B1CAB 0E 
0B1CAC 0B 
0B1CAD C9     0280* ret
               0185 include "files.inc"
              0001* ; load to onboard 8k sram
              0002* filedata: equ 0xB7E000; Directory object structure (DIR)
               0186 
               0187 ; APPLICATION INCLUDES
               0188 
               0189 ; Storage for the argv array pointers
               0190 min_args: equ 1
               0191 argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B1CAE 00      0192 argv_ptrs:		    BLKP	argv_ptrs_max, 0
0B1CAF 00 
0B1CB0 00 
0B1CB1 00 
0B1CB1 00   
0B1CB2 00 
0B1CB3 00 
0B1CB4 00 
0B1CB4 00   
0B1CB5 00 
0B1CB6 00 
0B1CB7 00 
0B1CB7 00   
0B1CB8 00 
0B1CB9 00 
0B1CBA 00 
0B1CBA 00   
0B1CBB 00 
0B1CBC 00 
0B1CBD 00 
0B1CBD 00   
0B1CBE 00 
0B1CBF 00 
0B1CC0 00 
0B1CC0 00   
0B1CC1 00 
0B1CC2 00 
0B1CC3 00 
0B1CC3 00   
0B1CC4 00 
0B1CC5 00 
0B1CC6 00 
0B1CC6 00   
0B1CC7 00 
0B1CC8 00 
0B1CC9 00 
0B1CC9 00   
0B1CCA 00 
0B1CCB 00 
0B1CCC 00 
0B1CCC 00   
0B1CCD 00 
0B1CCE 00 
0B1CCF 00 
0B1CCF 00   
0B1CD0 00 
0B1CD1 00 
0B1CD2 00 
               0193 _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
               0194 
               0195 ; Storage for the arguments, ORDER MATTERS
               0196 arg1: ds 5
               0197 arg2: ds 5
               0198 
               0199 ; GLOBAL MESSAGE STRINGS
0B1CEB 55      0200 str_usage: ASCIZ "Usage: scratch <args>\r\n"
0B1CEC 73 
0B1CED 61 
0B1CEE 67 
0B1CEE 65   
0B1CEF 3A 
0B1CF0 20 
0B1CF1 73 
0B1CF1 63   
0B1CF2 72 
0B1CF3 61 
0B1CF4 74 
0B1CF4 63   
0B1CF5 68 
0B1CF6 20 
0B1CF7 3C 
0B1CF7 61   
0B1CF8 72 
0B1CF9 67 
0B1CFA 73 
0B1CFA 3E   
0B1CFB 0D 
0B1CFC 0A 
0B1CFD 00 
0B1D03 45      0201 str_error: ASCIZ "Error!\r\n"
0B1D04 72 
0B1D05 72 
0B1D06 6F 
0B1D06 72   
0B1D07 21 
0B1D08 0D 
0B1D09 0A 
0B1D09 00   
0B1D0C 53      0202 str_success: ASCIZ "Success!\r\n"
0B1D0D 75 
0B1D0E 63 
0B1D0F 63 
0B1D0F 65   
0B1D10 73 
0B1D11 73 
0B1D12 21 
0B1D12 0D   
0B1D13 0A 
0B1D14 00 
               0203 
               0204 ; GLOBAL VARIABLES / DEFAULTS
               0205 ; ---- input arguments (float) ----
               0206 input_params_num: equ 7
               0207 input_params:
0B1D17 81      0208 petals:             db   0x81, 0x1F, 0x85, 0xEB, 0x41 ; 3.03
0B1D18 1F 
0B1D19 85 
0B1D1A EB 
0B1D1A 41   
0B1D1C 80      0209 vectors:            db   0x80, 0xD7, 0xA3, 0x70, 0x7D ; 1.98
0B1D1D D7 
0B1D1E A3 
0B1D1F 70 
0B1D1F 7D   
0B1D21 7F      0210 depth:              db   0x7F, 0x9A, 0x99, 0x99, 0x19 ; 0.6
0B1D22 9A 
0B1D23 99 
0B1D24 99 
0B1D24 19   
0B1D26 00      0211 periods:            db   0x00, 0x42, 0x00, 0x00, 0x00 ; 66.0
0B1D27 42 
0B1D28 00 
0B1D29 00 
0B1D29 00   
0B1D2B 7F      0212 shrink:             db   0x7F, 0xCC, 0xCC, 0xCC, 0x4C ; 0.8
0B1D2C CC 
0B1D2D CC 
0B1D2E CC 
0B1D2E 4C   
0B1D30 00      0213 radius_scale: 	    db   0x00, 0x00, 0x02, 0x00, 0x00 ; 512.0
0B1D31 00 
0B1D32 02 
0B1D33 00 
0B1D33 00   
0B1D35 00      0214 theta_init: 	    db   0x00, 0x00, 0x00, 0x00, 0x00 ; 0
0B1D36 00 
0B1D37 00 
0B1D38 00 
0B1D38 00   
               0215 
               0216 ; ---- main loop constants (float unless noted otherwise) ----
0B1D3A 00      0217 step_theta_prime:   blkb 5,0    ; Step increment for theta_prime in each loop iteration
0B1D3B 00 
0B1D3C 00 
0B1D3D 00 
0B1D3D 00   
0B1D3F 00      0218 step_theta_petal:   blkb 5,0    ; Step increment for theta_petal in each loop iteration
0B1D40 00 
0B1D41 00 
0B1D42 00 
0B1D42 00   
0B1D44 00      0219 total_steps:        blkb 5,0    ; Total number of iterations based on periods and step_theta_prime
0B1D45 00 
0B1D46 00 
0B1D47 00 
0B1D47 00   
0B1D49 00      0220 step_shrink:        blkb 5,0    ; Step decrement applied to radius in each iteration
0B1D4A 00 
0B1D4B 00 
0B1D4C 00 
0B1D4C 00   
               0221 
               0222 ; ---- main loop state variables (float) ----
0B1D4E 00      0223 theta_prime: 	    blkb 5,0    ; Angle of the drawing cursor relative to the origin
0B1D4F 00 
0B1D50 00 
0B1D51 00 
0B1D51 00   
0B1D53 00      0224 theta_petal: 	    blkb 5,0    ; Angle used to compute radius offset of the petal circle
0B1D54 00 
0B1D55 00 
0B1D56 00 
0B1D56 00   
0B1D58 00      0225 radius_prime:       blkb 5,0    ; Initial radius before shrink factor is applied
0B1D59 00 
0B1D5A 00 
0B1D5B 00 
0B1D5B 00   
0B1D5D 00      0226 radius_petal:       blkb 5,0    ; Radius of the petal circle
0B1D5E 00 
0B1D5F 00 
0B1D60 00 
0B1D60 00   
0B1D62 00      0227 radius:             blkb 5,0    ; Total radius of the curve
0B1D63 00 
0B1D64 00 
0B1D65 00 
0B1D65 00   
0B1D67 00      0228 x_prev:             blkb 5,0    ; Previous x coordinate
0B1D68 00 
0B1D69 00 
0B1D6A 00 
0B1D6A 00   
0B1D6C 00      0229 y_prev:             blkb 5,0    ; Previous y coordinate
0B1D6D 00 
0B1D6E 00 
0B1D6F 00 
0B1D6F 00   
               0230 
               0231 ; ========= MAIN LOOP =========
               0232 ; The main routine
               0233 ; IXU: argv - pointer to array of parameters
               0234 ;   C: argc - number of parameters
               0235 ; Returns:
               0236 ;  HL: Error code, or 0 if OK
               0237 
               0238 _main_init:
0B1D71 79      0239 ld a,c              ; how many arguments?
0B1D72 FE      0240 cp min_args         ; not enough?
0B1D73 01 
0B1D74 30      0241 jr nc,main          ; if enough, go to main loop
0B1D75 23 
0B1D76 21      0242 ld hl,str_usage     ; if not enough, print usage
0B1D77 EB 
0B1D78 1C 
0B1D79 0B 
0B1D7A CD      0243 call printString
0B1D7B CE 
0B1D7C 0E 
0B1D7D 0B 
               0244 ; fall through to _main_end_error
               0245 
               0246 _main_end_error:
0B1D7E 21      0247 ld hl,str_error     ; print error message
0B1D7F 03 
0B1D80 1D 
0B1D81 0B 
0B1D82 CD      0248 call printString
0B1D83 CE 
0B1D84 0E 
0B1D85 0B 
0B1D86 21      0249 ld hl,19            ; return error code 19
0B1D87 13 
0B1D88 00 
0B1D89 00 
0B1D8A C9      0250 ret
               0251 
               0252 ; begin BASIC-specific end code
               0253 ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B1D8B ED      0254 _end:			LD		SP, (_sps)		; Restore the stack pointer
0B1D8C 7B 
0B1D8D DE 
0B1D8E 1C 
0B1D8E 0B   
               0255 ; fall through to _main_end_ok
               0256 ; end BASIC-specific end code
               0257 
               0258 _main_end_ok:
               0259 ; call printNewLine
               0260 ; ld hl,str_success   ; print success message
               0261 ; call printString
0B1D90 CD      0262 call printNewLine
0B1D91 E3 
0B1D92 0E 
0B1D93 0B 
0B1D94 21      0263 ld hl,0             ; return 0 for success
0B1D95 00 
0B1D96 00 
0B1D97 00 
0B1D98 C9      0264 ret
               0265 
               0266 ; ========= BEGIN CUSTOM MAIN LOOP =========
               0267 main:
0B1D99 0D      0268 dec c               ; decrement the argument count to skip the program name
0B1D9A CD      0269 call load_input     ; load the input arguments
0B1D9B F0 
0B1D9C 1F 
0B1D9D 0B 
0B1D9E CD      0270 call vdu_cls        ; clear the screen
0B1D9F 24 
0B1DA0 18 
0B1DA1 0B 
0B1DA2 CD      0271 call print_input    ; print the input arguments
0B1DA3 0C 
0B1DA4 20 
0B1DA5 0B 
               0272 
               0273 ; Set screen origin to the center
0B1DA6 01      0274 ld bc,1280/2 ; x
0B1DA7 80 
0B1DA8 02 
0B1DA9 00 
0B1DAA 11      0275 ld de,1024/2 ; y
0B1DAB 00 
0B1DAC 02 
0B1DAD 00 
0B1DAE CD      0276 call vdu_set_gfx_origin
0B1DAF 90 
0B1DB0 18 
0B1DB1 0B 
               0277 
               0278 ; --- convert input thetas to radians
0B1DB2 FD      0279 ld iy,theta_prime
0B1DB3 21 
0B1DB4 4E 
0B1DB5 1D 
0B1DB5 0B   
0B1DB7 CD      0280 call fetch_float_iy_nor
0B1DB8 BA 
0B1DB9 16 
0B1DBA 0B 
0B1DBB 3E      0281 ld a,rad
0B1DBC 1B 
0B1DBD CD      0282 call FPP
0B1DBE D2 
0B1DBF 00 
0B1DC0 0B 
0B1DC1 CD      0283 call store_float_iy_nor
0B1DC2 A8 
0B1DC3 16 
0B1DC4 0B 
               0284 
0B1DC5 FD      0285 ld iy,theta_petal
0B1DC6 21 
0B1DC7 53 
0B1DC8 1D 
0B1DC8 0B   
0B1DCA CD      0286 call fetch_float_iy_nor
0B1DCB BA 
0B1DCC 16 
0B1DCD 0B 
0B1DCE 3E      0287 ld a,rad
0B1DCF 1B 
0B1DD0 CD      0288 call FPP
0B1DD1 D2 
0B1DD2 00 
0B1DD3 0B 
0B1DD4 CD      0289 call store_float_iy_nor
0B1DD5 A8 
0B1DD6 16 
0B1DD7 0B 
               0290 
0B1DD8 FD      0291 ld iy,theta_init
0B1DD9 21 
0B1DDA 35 
0B1DDB 1D 
0B1DDB 0B   
0B1DDD CD      0292 call fetch_float_iy_nor
0B1DDE BA 
0B1DDF 16 
0B1DE0 0B 
0B1DE1 3E      0293 ld a,rad
0B1DE2 1B 
0B1DE3 CD      0294 call FPP
0B1DE4 D2 
0B1DE5 00 
0B1DE6 0B 
0B1DE7 CD      0295 call store_float_iy_nor
0B1DE8 A8 
0B1DE9 16 
0B1DEA 0B 
               0296 
0B1DEB FD      0297 ld iy,theta_prime ; set theta_prime to theta_init
0B1DEC 21 
0B1DED 4E 
0B1DEE 1D 
0B1DEE 0B   
0B1DF0 CD      0298 call store_float_iy_nor
0B1DF1 A8 
0B1DF2 16 
0B1DF3 0B 
               0299 
               0300 ; --- compute the main loop parameters ---
               0301 ; step_theta_prime = 2 * pi / (petals * vectors)
0B1DF4 FD      0302 ld iy,petals
0B1DF5 21 
0B1DF6 17 
0B1DF7 1D 
0B1DF7 0B   
0B1DF9 CD      0303 call fetch_float_iy_nor
0B1DFA BA 
0B1DFB 16 
0B1DFC 0B 
0B1DFD FD      0304 ld iy,vectors
0B1DFE 21 
0B1DFF 1C 
0B1E00 1D 
0B1E00 0B   
0B1E02 CD      0305 call fetch_float_iy_alt
0B1E03 DE 
0B1E04 16 
0B1E05 0B 
0B1E06 3E      0306 ld a,fmul
0B1E07 0A 
0B1E08 CD      0307 call FPP ; HLH'L'C = petals * vectors
0B1E09 D2 
0B1E0A 00 
0B1E0B 0B 
               0308 
0B1E0C CD      0309 call pi2_alt ; DED'E'B = 2 * pi
0B1E0D DC 
0B1E0E 17 
0B1E0F 0B 
0B1E10 CD      0310 call SWAP ; HLH'L'C <--> DED'E'B
0B1E11 B5 
0B1E12 15 
0B1E13 0B 
0B1E14 3E      0311 ld a,fdiv
0B1E15 0F 
0B1E16 CD      0312 call FPP ; HLH'L'C = 2 * pi / (petals * vectors)
0B1E17 D2 
0B1E18 00 
0B1E19 0B 
0B1E1A FD      0313 ld iy,step_theta_prime
0B1E1B 21 
0B1E1C 3A 
0B1E1D 1D 
0B1E1D 0B   
0B1E1F CD      0314 call store_float_iy_nor
0B1E20 A8 
0B1E21 16 
0B1E22 0B 
               0315 
               0316 ; step_theta_petal = 2 * pi / vectors
0B1E23 FD      0317 ld iy,vectors
0B1E24 21 
0B1E25 1C 
0B1E26 1D 
0B1E26 0B   
0B1E28 CD      0318 call fetch_float_iy_nor
0B1E29 BA 
0B1E2A 16 
0B1E2B 0B 
0B1E2C CD      0319 call pi2_alt ; DED'E'B = 2 * pi
0B1E2D DC 
0B1E2E 17 
0B1E2F 0B 
0B1E30 CD      0320 call SWAP ; HLH'L'C <--> DED'E'B
0B1E31 B5 
0B1E32 15 
0B1E33 0B 
0B1E34 3E      0321 ld a,fdiv
0B1E35 0F 
0B1E36 CD      0322 call FPP ; HLH'L'C = 2 * pi / vectors
0B1E37 D2 
0B1E38 00 
0B1E39 0B 
               0323 ; fmod rounds to the nearest integer, so we leave it out until we can find a better solution
               0324 ; call pi2_alt ; DED'E'B = 2 * pi
               0325 ; ld a,fmod
               0326 ; call FPP ; HLH'L'C = 2 * pi % vectors
0B1E3A FD      0327 ld iy,step_theta_petal
0B1E3B 21 
0B1E3C 3F 
0B1E3D 1D 
0B1E3D 0B   
0B1E3F CD      0328 call store_float_iy_nor
0B1E40 A8 
0B1E41 16 
0B1E42 0B 
               0329 
               0330 ; total_steps = int(petals * vectors * periods)
0B1E43 FD      0331 ld iy,petals
0B1E44 21 
0B1E45 17 
0B1E46 1D 
0B1E46 0B   
0B1E48 CD      0332 call fetch_float_iy_nor
0B1E49 BA 
0B1E4A 16 
0B1E4B 0B 
0B1E4C FD      0333 ld iy,vectors
0B1E4D 21 
0B1E4E 1C 
0B1E4F 1D 
0B1E4F 0B   
0B1E51 CD      0334 call fetch_float_iy_alt
0B1E52 DE 
0B1E53 16 
0B1E54 0B 
0B1E55 3E      0335 ld a,fmul
0B1E56 0A 
0B1E57 CD      0336 call FPP ; HLH'L'C = petals * vectors
0B1E58 D2 
0B1E59 00 
0B1E5A 0B 
               0337 
0B1E5B FD      0338 ld iy,periods
0B1E5C 21 
0B1E5D 26 
0B1E5E 1D 
0B1E5E 0B   
0B1E60 CD      0339 call fetch_float_iy_alt
0B1E61 DE 
0B1E62 16 
0B1E63 0B 
0B1E64 3E      0340 ld a,fmul
0B1E65 0A 
0B1E66 CD      0341 call FPP ; HLH'L'C = petals * vectors * periods
0B1E67 D2 
0B1E68 00 
0B1E69 0B 
0B1E6A FD      0342 ld iy,total_steps
0B1E6B 21 
0B1E6C 44 
0B1E6D 1D 
0B1E6D 0B   
0B1E6F CD      0343 call store_float_iy_nor ; we'll make it an integer after computing step_shrink
0B1E70 A8 
0B1E71 16 
0B1E72 0B 
               0344 
               0345 ; Initialize radius_prime accounting for depth
               0346 LOAD_FLOAT "1"
0B1E73 DD     0001M ld ix,$+11
0B1E74 21 
0B1E75 7E 
0B1E76 1E 
0B1E76 0B   
0B1E78 CD     0002M call val_fp ; convert the string to a float
0B1E79 BD 
0B1E7A 15 
0B1E7B 0B 
0B1E7C DD     0003M jp (ix)
0B1E7D E9 
0B1E7E 31     0004M asciz ARG
0B1E7F 00 
0B1E80 FD      0347 ld iy,depth
0B1E81 21 
0B1E82 21 
0B1E83 1D 
0B1E83 0B   
0B1E85 CD      0348 call fetch_float_iy_alt
0B1E86 DE 
0B1E87 16 
0B1E88 0B 
0B1E89 3E      0349 ld a,fadd
0B1E8A 0B 
0B1E8B CD      0350 call FPP ; HLH'L'C = 1 + depth
0B1E8C D2 
0B1E8D 00 
0B1E8E 0B 
0B1E8F CD      0351 call SWAP ; DED'E'B = 1 + depth
0B1E90 B5 
0B1E91 15 
0B1E92 0B 
0B1E93 FD      0352 ld iy,radius_scale
0B1E94 21 
0B1E95 30 
0B1E96 1D 
0B1E96 0B   
0B1E98 CD      0353 call fetch_float_iy_nor
0B1E99 BA 
0B1E9A 16 
0B1E9B 0B 
0B1E9C 3E      0354 ld a,fdiv
0B1E9D 0F 
0B1E9E CD      0355 call FPP ; HLH'L'C = radius_scale / (1 + depth)
0B1E9F D2 
0B1EA0 00 
0B1EA1 0B 
0B1EA2 FD      0356 ld iy,radius_prime
0B1EA3 21 
0B1EA4 58 
0B1EA5 1D 
0B1EA5 0B   
0B1EA7 CD      0357 call store_float_iy_nor
0B1EA8 A8 
0B1EA9 16 
0B1EAA 0B 
               0358 
               0359 ; Calculate shrink per step (linear)
               0360 ; step_shrink = -shrink * radius_scale / total_steps
0B1EAB FD      0361 ld iy,shrink
0B1EAC 21 
0B1EAD 2B 
0B1EAE 1D 
0B1EAE 0B   
0B1EB0 CD      0362 call fetch_float_iy_alt
0B1EB1 DE 
0B1EB2 16 
0B1EB3 0B 
0B1EB4 3E      0363 ld a,fmul
0B1EB5 0A 
0B1EB6 CD      0364 call FPP ; HLH'L'C = shrink * radius_prime
0B1EB7 D2 
0B1EB8 00 
0B1EB9 0B 
0B1EBA FD      0365 ld iy,total_steps
0B1EBB 21 
0B1EBC 44 
0B1EBD 1D 
0B1EBD 0B   
0B1EBF CD      0366 call fetch_float_iy_alt
0B1EC0 DE 
0B1EC1 16 
0B1EC2 0B 
0B1EC3 3E      0367 ld a,fdiv
0B1EC4 0F 
0B1EC5 CD      0368 call FPP ; HLH'L'C = shrink * radius_scale / total_steps
0B1EC6 D2 
0B1EC7 00 
0B1EC8 0B 
               0369 
               0370 ; call NEG_ ; HLH'L'C = -shrink * radius_scale / total_steps
               0371 ; NEG_ is not working as expected, so we'll just subtract from zero
0B1EC9 CD      0372 call SWAP
0B1ECA B5 
0B1ECB 15 
0B1ECC 0B 
               0373 LOAD_FLOAT "0"
0B1ECD DD     0001M ld ix,$+11
0B1ECE 21 
0B1ECF D8 
0B1ED0 1E 
0B1ED0 0B   
0B1ED2 CD     0002M call val_fp ; convert the string to a float
0B1ED3 BD 
0B1ED4 15 
0B1ED5 0B 
0B1ED6 DD     0003M jp (ix)
0B1ED7 E9 
0B1ED8 30     0004M asciz ARG
0B1ED9 00 
0B1EDA 3E      0374 ld a,fsub
0B1EDB 0D 
0B1EDC CD      0375 call FPP ; HLH'L'C = -shrink * radius_scale / total_steps
0B1EDD D2 
0B1EDE 00 
0B1EDF 0B 
0B1EE0 FD      0376 ld iy,step_shrink
0B1EE1 21 
0B1EE2 49 
0B1EE3 1D 
0B1EE3 0B   
0B1EE5 CD      0377 call store_float_iy_nor
0B1EE6 A8 
0B1EE7 16 
0B1EE8 0B 
               0378 
               0379 ; Make total_steps an integer and store it in uhl
0B1EE9 FD      0380 ld iy,total_steps
0B1EEA 21 
0B1EEB 44 
0B1EEC 1D 
0B1EEC 0B   
0B1EEE CD      0381 call fetch_float_iy_nor
0B1EEF BA 
0B1EF0 16 
0B1EF1 0B 
0B1EF2 CD      0382 call int2hlu ; UHL = int(total_steps)
0B1EF3 E9 
0B1EF4 15 
0B1EF5 0B 
0B1EF6 FD      0383 ld (iy),hl
0B1EF7 2F 
0B1EF8 00 
               0384 
               0385 ; set initial point and move graphics cursor to it
0B1EF9 CD      0386 call calc_point ; HLH'L'C = x DED'E'B = y
0B1EFA A2 
0B1EFB 1F 
0B1EFC 0B 
               0387 
0B1EFD 3E      0388 ld a,plot_pt+mv_abs
0B1EFE 44 
0B1EFF CD      0389 call vdu_plot_float
0B1F00 78 
0B1F01 1F 
0B1F02 0B 
               0390 
               0391 ; fall through to main loop
               0392 
               0393 @loop:
               0394 ; Advance thetas
               0395 ; theta_prime += step_theta_prime
0B1F03 FD      0396 ld iy,step_theta_prime
0B1F04 21 
0B1F05 3A 
0B1F06 1D 
0B1F06 0B   
0B1F08 CD      0397 call fetch_float_iy_nor
0B1F09 BA 
0B1F0A 16 
0B1F0B 0B 
0B1F0C FD      0398 ld iy,theta_prime
0B1F0D 21 
0B1F0E 4E 
0B1F0F 1D 
0B1F0F 0B   
0B1F11 CD      0399 call fetch_float_iy_alt
0B1F12 DE 
0B1F13 16 
0B1F14 0B 
0B1F15 3E      0400 ld a,fadd
0B1F16 0B 
0B1F17 CD      0401 call FPP ; HLH'L'C = theta_prime + step_theta_prime
0B1F18 D2 
0B1F19 00 
0B1F1A 0B 
0B1F1B CD      0402 call store_float_iy_nor ; theta_prime
0B1F1C A8 
0B1F1D 16 
0B1F1E 0B 
               0403 
               0404 ; theta_petal += step_theta_petal
0B1F1F FD      0405 ld iy,step_theta_petal
0B1F20 21 
0B1F21 3F 
0B1F22 1D 
0B1F22 0B   
0B1F24 CD      0406 call fetch_float_iy_nor
0B1F25 BA 
0B1F26 16 
0B1F27 0B 
0B1F28 FD      0407 ld iy,theta_petal
0B1F29 21 
0B1F2A 53 
0B1F2B 1D 
0B1F2B 0B   
0B1F2D CD      0408 call fetch_float_iy_alt
0B1F2E DE 
0B1F2F 16 
0B1F30 0B 
0B1F31 3E      0409 ld a,fadd
0B1F32 0B 
0B1F33 CD      0410 call FPP ; HLH'L'C = theta_petal + step_theta_petal
0B1F34 D2 
0B1F35 00 
0B1F36 0B 
0B1F37 CD      0411 call store_float_iy_nor ; theta_petal
0B1F38 A8 
0B1F39 16 
0B1F3A 0B 
               0412 
               0413 ; Update radius_prime
               0414 ; radius_prime += step_shrink
0B1F3B FD      0415 ld iy,step_shrink
0B1F3C 21 
0B1F3D 49 
0B1F3E 1D 
0B1F3E 0B   
0B1F40 CD      0416 call fetch_float_iy_nor
0B1F41 BA 
0B1F42 16 
0B1F43 0B 
0B1F44 FD      0417 ld iy,radius_prime
0B1F45 21 
0B1F46 58 
0B1F47 1D 
0B1F47 0B   
0B1F49 CD      0418 call fetch_float_iy_alt
0B1F4A DE 
0B1F4B 16 
0B1F4C 0B 
0B1F4D 3E      0419 ld a,fadd
0B1F4E 0B 
0B1F4F CD      0420 call FPP ; HLH'L'C = radius_prime + step_shrink
0B1F50 D2 
0B1F51 00 
0B1F52 0B 
0B1F53 CD      0421 call store_float_iy_nor ; radius_prime
0B1F54 A8 
0B1F55 16 
0B1F56 0B 
               0422 
               0423 ; Calculate new coordinates and draw a line from the previous point
0B1F57 CD      0424 call calc_point ; HLH'L'C = x DED'E'B = y
0B1F58 A2 
0B1F59 1F 
0B1F5A 0B 
0B1F5B 3E      0425 ld a,plot_sl_both+dr_abs_fg ; plot mode
0B1F5C 05 
0B1F5D CD      0426 call vdu_plot_float
0B1F5E 78 
0B1F5F 1F 
0B1F60 0B 
               0427 
               0428 ; Decrement the loop counter
0B1F61 2A      0429 ld hl,(total_steps)
0B1F62 44 
0B1F63 1D 
0B1F64 0B 
0B1F65 11      0430 ld de,-1
0B1F66 FF 
0B1F67 FF 
0B1F68 FF 
0B1F69 A7      0431 and a ; clear carry
0B1F6A ED      0432 adc hl,de
0B1F6B 5A 
0B1F6C 22      0433 ld (total_steps),hl
0B1F6D 44 
0B1F6E 1D 
0B1F6F 0B 
0B1F70 F2      0434 jp p,@loop
0B1F71 03 
0B1F72 1F 
0B1F73 0B 
               0435 
0B1F74 C3      0436 jp _main_end_ok
0B1F75 90 
0B1F76 1D 
0B1F77 0B 
               0437 
               0438 ; VDU 25, mode, x; y;: PLOT command
               0439 ; inputs: a=mode, HL'H'L'C=x, DE'D'E'B=y
               0440 vdu_plot_float:
0B1F78 32      0441 ld (@mode),a
0B1F79 9C 
0B1F7A 1F 
0B1F7B 0B 
               0442 
0B1F7C CD      0443 call int2hlu
0B1F7D E9 
0B1F7E 15 
0B1F7F 0B 
0B1F80 22      0444 ld (@x0),hl
0B1F81 9D 
0B1F82 1F 
0B1F83 0B 
               0445 
0B1F84 CD      0446 call SWAP
0B1F85 B5 
0B1F86 15 
0B1F87 0B 
0B1F88 CD      0447 call int2hlu
0B1F89 E9 
0B1F8A 15 
0B1F8B 0B 
0B1F8C 22      0448 ld (@y0),hl
0B1F8D 9F 
0B1F8E 1F 
0B1F8F 0B 
               0449 
0B1F90 21      0450 ld hl,@cmd
0B1F91 9B 
0B1F92 1F 
0B1F93 0B 
0B1F94 01      0451 ld bc,@end-@cmd
0B1F95 06 
0B1F96 00 
0B1F97 00 
0B1F98 5B      0452 rst.lil $18
0B1F99 DF 
0B1F9A C9      0453 ret
0B1F9B 19      0454 @cmd:   db 25
0B1F9C 00      0455 @mode:  db 0
0B1F9D 00      0456 @x0: 	dw 0
0B1F9E 00 
0B1F9F 00      0457 @y0: 	dw 0
0B1FA0 00 
0B1FA1 00      0458 @end:   db 0 ; padding
               0459 
               0460 ; compute the Cartesian coordinates of the next point on the curve
               0461 ; inputs: theta_prime, theta_petal, radius_prime, depth
               0462 ; outputs: HLH'L'C = x, DED'E'B = y
               0463 calc_point:
               0464 ; Calculate the petal radius and total radius
               0465 ; radius_petal = math.cos(theta_petal) * depth
0B1FA2 FD      0466 ld iy,theta_petal
0B1FA3 21 
0B1FA4 53 
0B1FA5 1D 
0B1FA5 0B   
0B1FA7 CD      0467 call fetch_float_iy_nor
0B1FA8 BA 
0B1FA9 16 
0B1FAA 0B 
0B1FAB 3E      0468 ld a,cos
0B1FAC 14 
0B1FAD CD      0469 call FPP ; HLH'L'C = cos(theta_petal)
0B1FAE D2 
0B1FAF 00 
0B1FB0 0B 
0B1FB1 FD      0470 ld iy,depth
0B1FB2 21 
0B1FB3 21 
0B1FB4 1D 
0B1FB4 0B   
0B1FB6 CD      0471 call fetch_float_iy_alt
0B1FB7 DE 
0B1FB8 16 
0B1FB9 0B 
0B1FBA 3E      0472 ld a,fmul
0B1FBB 0A 
0B1FBC CD      0473 call FPP ; HLH'L'C = radius_petal
0B1FBD D2 
0B1FBE 00 
0B1FBF 0B 
               0474 
               0475 ; radius = radius_prime + radius_petal * radius_prime
0B1FC0 FD      0476 ld iy,radius_prime
0B1FC1 21 
0B1FC2 58 
0B1FC3 1D 
0B1FC3 0B   
0B1FC5 CD      0477 call fetch_float_iy_alt
0B1FC6 DE 
0B1FC7 16 
0B1FC8 0B 
0B1FC9 3E      0478 ld a,fmul
0B1FCA 0A 
0B1FCB CD      0479 call FPP ; HLH'L'C = radius_petal * radius_prime
0B1FCC D2 
0B1FCD 00 
0B1FCE 0B 
0B1FCF FD      0480 ld iy,radius_prime
0B1FD0 21 
0B1FD1 58 
0B1FD2 1D 
0B1FD2 0B   
0B1FD4 CD      0481 call fetch_float_iy_alt
0B1FD5 DE 
0B1FD6 16 
0B1FD7 0B 
0B1FD8 3E      0482 ld a,fadd
0B1FD9 0B 
0B1FDA CD      0483 call FPP ; HLH'L'C = radius
0B1FDB D2 
0B1FDC 00 
0B1FDD 0B 
0B1FDE CD      0484 call SWAP ; DED'E'B = radius
0B1FDF B5 
0B1FE0 15 
0B1FE1 0B 
               0485 
               0486 ; Convert polar to Cartesian coordinates
0B1FE2 FD      0487 ld iy,theta_prime
0B1FE3 21 
0B1FE4 4E 
0B1FE5 1D 
0B1FE5 0B   
0B1FE7 CD      0488 call fetch_float_iy_nor ; HLH'L'C = theta_prime
0B1FE8 BA 
0B1FE9 16 
0B1FEA 0B 
0B1FEB CD      0489 call polar_to_cartesian_fpp ; HLH'L'C = x, DED'E'B = y
0B1FEC F9 
0B1FED 15 
0B1FEE 0B 
               0490 
0B1FEF C9      0491 ret
               0492 
               0493 ; --- Load arguments ---
               0494 ; --------------------------------
               0495 load_input:
0B1FF0 06      0496 ld b,input_params_num ; loop counter assuming correct number of arguments were entered
0B1FF1 07 
0B1FF2 79      0497 ld a,c ; number of arguments entered
0B1FF3 90      0498 sub b ; compare expected with entered
0B1FF4 F2      0499 jp p,@F ; entered arguments >= expected, so proceed ignoring any excess arguments
0B1FF5 FB 
0B1FF6 1F 
0B1FF7 0B 
0B1FF8 80      0500 add a,b ; set loop counter to entered arguments
0B1FF9 C8      0501 ret z ; no arguments entered so return, leaving all to defaults
0B1FFA 47      0502 ld b,a
               0503 @@:
0B1FFB FD      0504 ld iy,input_params  ; point to the arguments table
0B1FFC 21 
0B1FFD 17 
0B1FFE 1D 
0B1FFE 0B   
               0505 @loop:
0B2000 C5      0506 push bc ; save the loop counter
0B2001 CD      0507 call store_arg_iy_float ; get the next argument and store it
0B2002 E9 
0B2003 20 
0B2004 0B 
0B2005 ED      0508 lea iy,iy+5  ; point to the next parameter
0B2006 33 
0B2007 05 
0B2008 C1      0509 pop bc ; get back the loop counter
0B2009 10      0510 djnz @loop ; loop until done
0B200A F5 
0B200B C9      0511 ret
               0512 
               0513 print_input:
0B200C 06      0514 ld b,input_params_num ; loop counter = number of arguments
0B200D 07 
0B200E FD      0515 ld iy,input_params  ; point to the arguments table
0B200F 21 
0B2010 17 
0B2011 1D 
0B2011 0B   
               0516 @loop:
0B2013 C5      0517 push bc ; save the loop counter
0B2014 CD      0518 call fetch_float_iy_nor ; fetch the next parameter into HLH'L'C
0B2015 BA 
0B2016 16 
0B2017 0B 
0B2018 CD      0519 call print_float_dec_nor ; print the parameter
0B2019 74 
0B201A 17 
0B201B 0B 
0B201C 3E      0520 ld a,' ' ; print a space separator
0B201D 20 
0B201E 5B      0521 rst.lil $10
0B201F D7 
0B2020 ED      0522 lea iy,iy+5  ; point to the next parameter
0B2021 33 
0B2022 05 
0B2023 C1      0523 pop bc ; get back the loop counter
0B2024 10      0524 djnz @loop ; loop until done
0B2025 ED 
0B2026 C9      0525 ret
               0526 
               0527 ; --- Specific parameter processing functions ---
               0528 args_count_off:
0B2027 21      0529 ld hl,@str_args_count_off
0B2028 33 
0B2029 20 
0B202A 0B 
0B202B CD      0530 call printString
0B202C CE 
0B202D 0E 
0B202E 0B 
0B202F C3      0531 jp _main_end_error
0B2030 7E 
0B2031 1D 
0B2032 0B 
0B2033 41      0532 @str_args_count_off: db "Argument counts mismatch!\r\n",0
0B2034 72 
0B2035 67 
0B2036 75 
0B2036 6D   
0B2037 65 
0B2038 6E 
0B2039 74 
0B2039 20   
0B203A 63 
0B203B 6F 
0B203C 75 
0B203C 6E   
0B203D 74 
0B203E 73 
0B203F 20 
0B203F 6D   
0B2040 69 
0B2041 73 
0B2042 6D 
0B2042 61   
0B2043 74 
0B2044 63 
0B2045 68 
0B2045 21   
0B2046 0D 
0B2047 0A 
0B2048 00 
               0533 
               0534 ; ---- text strings ----
0B204F 73      0535 str_step_theta_prime: ASCIZ "step_theta_prime: "
0B2050 74 
0B2051 65 
0B2052 70 
0B2052 5F   
0B2053 74 
0B2054 68 
0B2055 65 
0B2055 74   
0B2056 61 
0B2057 5F 
0B2058 70 
0B2058 72   
0B2059 69 
0B205A 6D 
0B205B 65 
0B205B 3A   
0B205C 20 
0B205D 00 
0B2062 73      0536 str_step_theta_petal: ASCIZ "step_theta_petal: "
0B2063 74 
0B2064 65 
0B2065 70 
0B2065 5F   
0B2066 74 
0B2067 68 
0B2068 65 
0B2068 74   
0B2069 61 
0B206A 5F 
0B206B 70 
0B206B 65   
0B206C 74 
0B206D 61 
0B206E 6C 
0B206E 3A   
0B206F 20 
0B2070 00 
0B2075 74      0537 str_total_steps: ASCIZ "total_steps: "
0B2076 6F 
0B2077 74 
0B2078 61 
0B2078 6C   
0B2079 5F 
0B207A 73 
0B207B 74 
0B207B 65   
0B207C 70 
0B207D 73 
0B207E 3A 
0B207E 20   
0B207F 00 
0B2083 73      0538 str_step_shrink: ASCIZ "step_shrink: "
0B2084 74 
0B2085 65 
0B2086 70 
0B2086 5F   
0B2087 73 
0B2088 68 
0B2089 72 
0B2089 69   
0B208A 6E 
0B208B 6B 
0B208C 3A 
0B208C 20   
0B208D 00 
               0539 
0B2091 74      0540 str_theta_prime: ASCIZ "theta_prime: "
0B2092 68 
0B2093 65 
0B2094 74 
0B2094 61   
0B2095 5F 
0B2096 70 
0B2097 72 
0B2097 69   
0B2098 6D 
0B2099 65 
0B209A 3A 
0B209A 20   
0B209B 00 
0B209F 72      0541 str_radius_prime: ASCIZ "radius_prime: "
0B20A0 61 
0B20A1 64 
0B20A2 69 
0B20A2 75   
0B20A3 73 
0B20A4 5F 
0B20A5 70 
0B20A5 72   
0B20A6 69 
0B20A7 6D 
0B20A8 65 
0B20A8 3A   
0B20A9 20 
0B20AA 00 
0B20AE 72      0542 str_radius_petal: ASCIZ "radius_petal: "
0B20AF 61 
0B20B0 64 
0B20B1 69 
0B20B1 75   
0B20B2 73 
0B20B3 5F 
0B20B4 70 
0B20B4 65   
0B20B5 74 
0B20B6 61 
0B20B7 6C 
0B20B7 3A   
0B20B8 20 
0B20B9 00 
0B20BD 74      0543 str_theta_petal: ASCIZ "theta_petal: "
0B20BE 68 
0B20BF 65 
0B20C0 74 
0B20C0 61   
0B20C1 5F 
0B20C2 70 
0B20C3 65 
0B20C3 74   
0B20C4 61 
0B20C5 6C 
0B20C6 3A 
0B20C6 20   
0B20C7 00 
               0544 
0B20CB 72      0545 str_radius: ASCIZ "radius: "
0B20CC 61 
0B20CD 64 
0B20CE 69 
0B20CE 75   
0B20CF 73 
0B20D0 3A 
0B20D1 20 
0B20D1 00   
0B20D4 78      0546 str_xy: ASCIZ "x,y: "
0B20D5 2C 
0B20D6 79 
0B20D7 3A 
0B20D7 20   
0B20D8 00 
               0547 
               0548 ; ========== HELPER FUNCTIONS ==========
               0549 ;
               0550 ; get the next argument after ix as a floating point number
               0551 ; inputs: ix = pointer to the argument string
               0552 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0553 ; destroys: everything except iy, including prime registers
               0554 get_arg_float:
0B20DA ED      0555 lea ix,ix+3 ; point to the next argument
0B20DB 32 
0B20DC 03 
0B20DD DD      0556 push ix ; preserve
0B20DE E5 
0B20DF DD      0557 ld ix,(ix)  ; point to argument string
0B20E0 37 
0B20E1 00 
0B20E2 CD      0558 call val_fp ; convert the string to a float
0B20E3 BD 
0B20E4 15 
0B20E5 0B 
0B20E6 DD      0559 pop ix ; restore
0B20E7 E1 
0B20E8 C9      0560 ret ; return with the value in HLH'L'C
               0561 
               0562 ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
               0563 ; inputs: ix = pointer to the argument string
               0564 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0565 ; destroys: everything except iy, including prime registers
               0566 store_arg_iy_float:
0B20E9 ED      0567 lea ix,ix+3 ; point to the next argument
0B20EA 32 
0B20EB 03 
0B20EC DD      0568 push ix ; preserve
0B20ED E5 
0B20EE DD      0569 ld ix,(ix)  ; point to argument string
0B20EF 37 
0B20F0 00 
0B20F1 CD      0570 call val_fp ; convert the string to a float
0B20F2 BD 
0B20F3 15 
0B20F4 0B 
0B20F5 CD      0571 call store_float_iy_nor ; save the float in buffer
0B20F6 A8 
0B20F7 16 
0B20F8 0B 
0B20F9 DD      0572 pop ix ; restore
0B20FA E1 
0B20FB C9      0573 ret ; return with the value in HLH'L'C
               0574 ;
               0575 ; get the next argument after ix as a string
               0576 ; inputs: ix = pointer to the argument string
               0577 ; outputs: HL = pointer to the argument string, ix points to the next argument
               0578 ; destroys: a, h, l, f
               0579 get_arg_text:
0B20FC ED      0580 lea ix,ix+3 ; point to the next argument
0B20FD 32 
0B20FE 03 
0B20FF DD      0581 ld hl,(ix)  ; get the argument string
0B2100 27 
0B2101 00 
0B2102 C9      0582 ret
               0583 ;
               0584 ; match the next argument after ix to the dispatch table at iy
               0585 ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
               0586 ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
               0587 ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
               0588 ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
               0589 ; destroys: a, hl, de, ix, iy, flags
               0590 match_next:
0B2103 ED      0591 lea ix,ix+3         ; point to the next argument
0B2104 32 
0B2105 03 
               0592 @loop:
0B2106 FD      0593 ld hl,(iy)          ; pointer argument dispatch record
0B2107 27 
0B2108 00 
               0594 sign_hlu            ; check for list terminator
0B2109 19     0001M add hl,de
0B210A B7     0002M or a
0B210B ED     0003M sbc hl,de
0B210C 52 
0B210D CA      0595 jp z,@no_match      ; if a=0, return error
0B210E 25 
0B210F 21 
0B2110 0B 
0B2111 23      0596 inc hl              ; skip over jp instruction
0B2112 23      0597 inc hl
0B2113 DD      0598 ld de,(ix)          ; pointer to the argument string
0B2114 17 
0B2115 00 
0B2116 CD      0599 call str_equal      ; compare the argument to the dispatch table entry
0B2117 3C 
0B2118 21 
0B2119 0B 
0B211A CA      0600 jp z,@match         ; if equal, return success
0B211B 27 
0B211C 21 
0B211D 0B 
0B211E ED      0601 lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B211F 33 
0B2120 03 
0B2121 C3      0602 jp @loop            ; and loop
0B2122 06 
0B2123 21 
0B2124 0B 
               0603 @no_match:
0B2125 3C      0604 inc a               ; no match so return a=1 and zero flag reset
0B2126 C9      0605 ret
               0606 @match:
0B2127 FD      0607 ld iy,(iy)          ; get the function pointer
0B2128 37 
0B2129 00 
0B212A C9      0608 ret                 ; return a=0 and zero flag set
               0609 
               0610 ; same as match_next, but prints the parameter if a match is found
               0611 match_next_and_print:
0B212B CD      0612 call match_next
0B212C 03 
0B212D 21 
0B212E 0B 
0B212F C0      0613 ret nz ; no match found
0B2130 ED      0614 lea ix,ix-3
0B2131 32 
0B2132 FD 
0B2133 CD      0615 call get_arg_text ; hl points to the operator string
0B2134 FC 
0B2135 20 
0B2136 0B 
0B2137 CD      0616 call print_param
0B2138 47 
0B2139 21 
0B213A 0B 
0B213B C9      0617 ret
               0618 
               0619 ; compare two zero-terminated strings for equality, case-sensitive
               0620 ; hl: pointer to first string, de: pointer to second string
               0621 ; returns: z if equal, nz if not equal
               0622 ; destroys: a, hl, de
               0623 str_equal:
0B213C 1A      0624 ld a,(de)           ; get the first character
0B213D BE      0625 cp (hl)             ; compare to the second character
0B213E C0      0626 ret nz              ; if not equal, return
0B213F B7      0627 or a
0B2140 C8      0628 ret z               ; if equal and zero, return
0B2141 23      0629 inc hl              ; next character
0B2142 13      0630 inc de
0B2143 C3      0631 jp str_equal        ; loop until end of string
0B2144 3C 
0B2145 21 
0B2146 0B 
               0632 
               0633 ; print the parameter string pointed to by ix
               0634 ; destroys: a, hl
               0635 print_param:
0B2147 DD      0636 ld hl,(ix)          ; get the parameter pointer
0B2148 27 
0B2149 00 
0B214A CD      0637 call printString    ; print the parameter string
0B214B CE 
0B214C 0E 
0B214D 0B 
0B214E 3E      0638 ld a,' '            ; print a space separator
0B214F 20 
0B2150 5B      0639 rst.lil $10
0B2151 D7 
0B2152 C9      0640 ret
               0641 
               0642 ; print the parameters
               0643 ; inputs: b = number of parameters, ix = pointer to the parameters
               0644 ; destroys: a, hl, bc
               0645 print_params:
0B2153 41      0646 ld b,c              ; loop counter = number of parameters
0B2154 DD      0647 push ix             ; save the pointer to the parameters
0B2155 E5 
               0648 @loop:
0B2156 C5      0649 push bc             ; save the loop counter
0B2157 CD      0650 call print_param    ; print the parameter
0B2158 47 
0B2159 21 
0B215A 0B 
0B215B ED      0651 lea ix,ix+3         ; next parameter pointer
0B215C 32 
0B215D 03 
0B215E C1      0652 pop bc              ; get back the loop counter
0B215F 10      0653 djnz @loop          ; loop until done
0B2160 F5 
0B2161 DD      0654 pop ix              ; restore the pointer to the parameters
0B2162 E1 
0B2163 C9      0655 ret
               0656 
               0657 include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
              0001* ;
              0002* ; Title:	BBC Basic Interpreter - Z80 version
              0003* ;		RAM Module for BBC Basic Interpreter
              0004* ;		For use with Version 2.0 of BBC BASIC
              0005* ;		Standard CP/M Distribution Version
              0006* ; Author:	(C) Copyright  R.T.Russell 31-12-1983
              0007* ; Modified By:	Dean Belfield
              0008* ; Created:	12/05/2023
              0009* ; Last Updated:	26/06/2023
              0010* ;
              0011* ; Modinfo:
              0012* ; 06/06/2023:	Modified to run in ADL mode
              0013* ; 26/06/2023:	Added temporary stores R0 and R1
              0014* 
              0015* ; .ASSUME	ADL = 1
              0016* 
              0017* ; DEFINE	LORAM, SPACE = ROM
              0018* ; SEGMENT LORAM
              0019* 
              0020* ; XDEF	ACCS
              0021* ; XDEF	BUFFER
              0022* ; XDEF	STAVAR
              0023* ; XDEF	DYNVAR
              0024* ; XDEF	FNPTR
              0025* ; XDEF	PROPTR
              0026* ; XDEF	PAGE_
              0027* ; XDEF	TOP
              0028* ; XDEF	LOMEM
              0029* ; XDEF 	FREE
              0030* ; XDEF	HIMEM
              0031* ; XDEF	LINENO
              0032* ; XDEF	TRACEN
              0033* ; XDEF	AUTONO
              0034* ; XDEF	ERRTRP
              0035* ; XDEF	ERRTXT
              0036* ; XDEF	DATPTR
              0037* ; XDEF	ERL
              0038* ; XDEF	ERRLIN
              0039* ; XDEF	RANDOM
              0040* ; XDEF	COUNT
              0041* ; XDEF	WIDTH
              0042* ; XDEF	ERR
              0043* ; XDEF	LISTON
              0044* ; XDEF	INCREM
              0045* 
              0046* ; XDEF	FLAGS
              0047* ; XDEF	OSWRCHPT
              0048* ; XDEF	OSWRCHCH
              0049* ; XDEF	OSWRCHFH
              0050* ; XDEF	KEYDOWN
              0051* ; XDEF	KEYASCII
              0052* ; XDEF	KEYCOUNT
              0053* 
              0054* ; XDEF	R0
              0055* ; XDEF	R1
              0056* 
              0057* ; XDEF	RAM_START
              0058* ; XDEF	RAM_END
              0059* ; XDEF	USER
              0060* 
              0061* end_binary: ;  for assemble.py to know where to truncate the binary file
0B2164 FF     0062* ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
0B2165 FF 
0B2166 FF 
0B2167 FF 
0B2167 FF   
0B2168 FF 
0B2169 FF 
0B216A FF 
0B216A FF   
0B216B FF 
0B216C FF 
0B216D FF 
0B216D FF   
0B216E FF 
0B216F FF 
0B2170 FF 
0B2170 FF   
0B2171 FF 
0B2172 FF 
0B2173 FF 
0B2173 FF   
0B2174 FF 
0B2175 FF 
0B2176 FF 
0B2176 FF   
0B2177 FF 
0B2178 FF 
0B2179 FF 
0B2179 FF   
0B217A FF 
0B217B FF 
0B217C FF 
0B217C FF   
0B217D FF 
0B217E FF 
0B217F FF 
0B217F FF   
0B2180 FF 
0B2181 FF 
0B2182 FF 
0B2182 FF   
0B2183 FF 
0B2184 FF 
0B2185 FF 
0B2185 FF   
0B2186 FF 
0B2187 FF 
0B2188 FF 
0B2188 FF   
0B2189 FF 
0B218A FF 
0B218B FF 
0B218B FF   
0B218C FF 
0B218D FF 
0B218E FF 
0B218E FF   
0B218F FF 
0B2190 FF 
0B2191 FF 
0B2191 FF   
0B2192 FF 
0B2193 FF 
0B2194 FF 
0B2194 FF   
0B2195 FF 
0B2196 FF 
0B2197 FF 
0B2197 FF   
0B2198 FF 
0B2199 FF 
0B219A FF 
0B219A FF   
0B219B FF 
0B219C FF 
0B219D FF 
0B219D FF   
0B219E FF 
0B219F FF 
0B21A0 FF 
0B21A0 FF   
0B21A1 FF 
0B21A2 FF 
0B21A3 FF 
0B21A3 FF   
0B21A4 FF 
0B21A5 FF 
0B21A6 FF 
0B21A6 FF   
0B21A7 FF 
0B21A8 FF 
0B21A9 FF 
0B21A9 FF   
0B21AA FF 
0B21AB FF 
0B21AC FF 
0B21AC FF   
0B21AD FF 
0B21AE FF 
0B21AF FF 
0B21AF FF   
0B21B0 FF 
0B21B1 FF 
0B21B2 FF 
0B21B2 FF   
0B21B3 FF 
0B21B4 FF 
0B21B5 FF 
0B21B5 FF   
0B21B6 FF 
0B21B7 FF 
0B21B8 FF 
0B21B8 FF   
0B21B9 FF 
0B21BA FF 
0B21BB FF 
0B21BB FF   
0B21BC FF 
0B21BD FF 
0B21BE FF 
0B21BE FF   
0B21BF FF 
0B21C0 FF 
0B21C1 FF 
0B21C1 FF   
0B21C2 FF 
0B21C3 FF 
0B21C4 FF 
0B21C4 FF   
0B21C5 FF 
0B21C6 FF 
0B21C7 FF 
0B21C7 FF   
0B21C8 FF 
0B21C9 FF 
0B21CA FF 
0B21CA FF   
0B21CB FF 
0B21CC FF 
0B21CD FF 
0B21CD FF   
0B21CE FF 
0B21CF FF 
0B21D0 FF 
0B21D0 FF   
0B21D1 FF 
0B21D2 FF 
0B21D3 FF 
0B21D3 FF   
0B21D4 FF 
0B21D5 FF 
0B21D6 FF 
0B21D6 FF   
0B21D7 FF 
0B21D8 FF 
0B21D9 FF 
              0063* RAM_START:
              0064* ;
0B2200 00     0065* ACCS:           BLKB    256,0             ; String Accumulator
0B2201 00 
0B2202 00 
0B2203 00 
0B2203 00   
0B2204 00 
0B2205 00 
0B2206 00 
0B2206 00   
0B2207 00 
0B2208 00 
0B2209 00 
0B2209 00   
0B220A 00 
0B220B 00 
0B220C 00 
0B220C 00   
0B220D 00 
0B220E 00 
0B220F 00 
0B220F 00   
0B2210 00 
0B2211 00 
0B2212 00 
0B2212 00   
0B2213 00 
0B2214 00 
0B2215 00 
0B2215 00   
0B2216 00 
0B2217 00 
0B2218 00 
0B2218 00   
0B2219 00 
0B221A 00 
0B221B 00 
0B221B 00   
0B221C 00 
0B221D 00 
0B221E 00 
0B221E 00   
0B221F 00 
0B2220 00 
0B2221 00 
0B2221 00   
0B2222 00 
0B2223 00 
0B2224 00 
0B2224 00   
0B2225 00 
0B2226 00 
0B2227 00 
0B2227 00   
0B2228 00 
0B2229 00 
0B222A 00 
0B222A 00   
0B222B 00 
0B222C 00 
0B222D 00 
0B222D 00   
0B222E 00 
0B222F 00 
0B2230 00 
0B2230 00   
0B2231 00 
0B2232 00 
0B2233 00 
0B2233 00   
0B2234 00 
0B2235 00 
0B2236 00 
0B2236 00   
0B2237 00 
0B2238 00 
0B2239 00 
0B2239 00   
0B223A 00 
0B223B 00 
0B223C 00 
0B223C 00   
0B223D 00 
0B223E 00 
0B223F 00 
0B223F 00   
0B2240 00 
0B2241 00 
0B2242 00 
0B2242 00   
0B2243 00 
0B2244 00 
0B2245 00 
0B2245 00   
0B2246 00 
0B2247 00 
0B2248 00 
0B2248 00   
0B2249 00 
0B224A 00 
0B224B 00 
0B224B 00   
0B224C 00 
0B224D 00 
0B224E 00 
0B224E 00   
0B224F 00 
0B2250 00 
0B2251 00 
0B2251 00   
0B2252 00 
0B2253 00 
0B2254 00 
0B2254 00   
0B2255 00 
0B2256 00 
0B2257 00 
0B2257 00   
0B2258 00 
0B2259 00 
0B225A 00 
0B225A 00   
0B225B 00 
0B225C 00 
0B225D 00 
0B225D 00   
0B225E 00 
0B225F 00 
0B2260 00 
0B2260 00   
0B2261 00 
0B2262 00 
0B2263 00 
0B2263 00   
0B2264 00 
0B2265 00 
0B2266 00 
0B2266 00   
0B2267 00 
0B2268 00 
0B2269 00 
0B2269 00   
0B226A 00 
0B226B 00 
0B226C 00 
0B226C 00   
0B226D 00 
0B226E 00 
0B226F 00 
0B226F 00   
0B2270 00 
0B2271 00 
0B2272 00 
0B2272 00   
0B2273 00 
0B2274 00 
0B2275 00 
0B2275 00   
0B2276 00 
0B2277 00 
0B2278 00 
0B2278 00   
0B2279 00 
0B227A 00 
0B227B 00 
0B227B 00   
0B227C 00 
0B227D 00 
0B227E 00 
0B227E 00   
0B227F 00 
0B2280 00 
0B2281 00 
0B2281 00   
0B2282 00 
0B2283 00 
0B2284 00 
0B2284 00   
0B2285 00 
0B2286 00 
0B2287 00 
0B2287 00   
0B2288 00 
0B2289 00 
0B228A 00 
0B228A 00   
0B228B 00 
0B228C 00 
0B228D 00 
0B228D 00   
0B228E 00 
0B228F 00 
0B2290 00 
0B2290 00   
0B2291 00 
0B2292 00 
0B2293 00 
0B2293 00   
0B2294 00 
0B2295 00 
0B2296 00 
0B2296 00   
0B2297 00 
0B2298 00 
0B2299 00 
0B2299 00   
0B229A 00 
0B229B 00 
0B229C 00 
0B229C 00   
0B229D 00 
0B229E 00 
0B229F 00 
0B229F 00   
0B22A0 00 
0B22A1 00 
0B22A2 00 
0B22A2 00   
0B22A3 00 
0B22A4 00 
0B22A5 00 
0B22A5 00   
0B22A6 00 
0B22A7 00 
0B22A8 00 
0B22A8 00   
0B22A9 00 
0B22AA 00 
0B22AB 00 
0B22AB 00   
0B22AC 00 
0B22AD 00 
0B22AE 00 
0B22AE 00   
0B22AF 00 
0B22B0 00 
0B22B1 00 
0B22B1 00   
0B22B2 00 
0B22B3 00 
0B22B4 00 
0B22B4 00   
0B22B5 00 
0B22B6 00 
0B22B7 00 
0B22B7 00   
0B22B8 00 
0B22B9 00 
0B22BA 00 
0B22BA 00   
0B22BB 00 
0B22BC 00 
0B22BD 00 
0B22BD 00   
0B22BE 00 
0B22BF 00 
0B22C0 00 
0B2300 00     0066* BUFFER:         BLKB    256,0             ; String Input Buffer
0B2301 00 
0B2302 00 
0B2303 00 
0B2303 00   
0B2304 00 
0B2305 00 
0B2306 00 
0B2306 00   
0B2307 00 
0B2308 00 
0B2309 00 
0B2309 00   
0B230A 00 
0B230B 00 
0B230C 00 
0B230C 00   
0B230D 00 
0B230E 00 
0B230F 00 
0B230F 00   
0B2310 00 
0B2311 00 
0B2312 00 
0B2312 00   
0B2313 00 
0B2314 00 
0B2315 00 
0B2315 00   
0B2316 00 
0B2317 00 
0B2318 00 
0B2318 00   
0B2319 00 
0B231A 00 
0B231B 00 
0B231B 00   
0B231C 00 
0B231D 00 
0B231E 00 
0B231E 00   
0B231F 00 
0B2320 00 
0B2321 00 
0B2321 00   
0B2322 00 
0B2323 00 
0B2324 00 
0B2324 00   
0B2325 00 
0B2326 00 
0B2327 00 
0B2327 00   
0B2328 00 
0B2329 00 
0B232A 00 
0B232A 00   
0B232B 00 
0B232C 00 
0B232D 00 
0B232D 00   
0B232E 00 
0B232F 00 
0B2330 00 
0B2330 00   
0B2331 00 
0B2332 00 
0B2333 00 
0B2333 00   
0B2334 00 
0B2335 00 
0B2336 00 
0B2336 00   
0B2337 00 
0B2338 00 
0B2339 00 
0B2339 00   
0B233A 00 
0B233B 00 
0B233C 00 
0B233C 00   
0B233D 00 
0B233E 00 
0B233F 00 
0B233F 00   
0B2340 00 
0B2341 00 
0B2342 00 
0B2342 00   
0B2343 00 
0B2344 00 
0B2345 00 
0B2345 00   
0B2346 00 
0B2347 00 
0B2348 00 
0B2348 00   
0B2349 00 
0B234A 00 
0B234B 00 
0B234B 00   
0B234C 00 
0B234D 00 
0B234E 00 
0B234E 00   
0B234F 00 
0B2350 00 
0B2351 00 
0B2351 00   
0B2352 00 
0B2353 00 
0B2354 00 
0B2354 00   
0B2355 00 
0B2356 00 
0B2357 00 
0B2357 00   
0B2358 00 
0B2359 00 
0B235A 00 
0B235A 00   
0B235B 00 
0B235C 00 
0B235D 00 
0B235D 00   
0B235E 00 
0B235F 00 
0B2360 00 
0B2360 00   
0B2361 00 
0B2362 00 
0B2363 00 
0B2363 00   
0B2364 00 
0B2365 00 
0B2366 00 
0B2366 00   
0B2367 00 
0B2368 00 
0B2369 00 
0B2369 00   
0B236A 00 
0B236B 00 
0B236C 00 
0B236C 00   
0B236D 00 
0B236E 00 
0B236F 00 
0B236F 00   
0B2370 00 
0B2371 00 
0B2372 00 
0B2372 00   
0B2373 00 
0B2374 00 
0B2375 00 
0B2375 00   
0B2376 00 
0B2377 00 
0B2378 00 
0B2378 00   
0B2379 00 
0B237A 00 
0B237B 00 
0B237B 00   
0B237C 00 
0B237D 00 
0B237E 00 
0B237E 00   
0B237F 00 
0B2380 00 
0B2381 00 
0B2381 00   
0B2382 00 
0B2383 00 
0B2384 00 
0B2384 00   
0B2385 00 
0B2386 00 
0B2387 00 
0B2387 00   
0B2388 00 
0B2389 00 
0B238A 00 
0B238A 00   
0B238B 00 
0B238C 00 
0B238D 00 
0B238D 00   
0B238E 00 
0B238F 00 
0B2390 00 
0B2390 00   
0B2391 00 
0B2392 00 
0B2393 00 
0B2393 00   
0B2394 00 
0B2395 00 
0B2396 00 
0B2396 00   
0B2397 00 
0B2398 00 
0B2399 00 
0B2399 00   
0B239A 00 
0B239B 00 
0B239C 00 
0B239C 00   
0B239D 00 
0B239E 00 
0B239F 00 
0B239F 00   
0B23A0 00 
0B23A1 00 
0B23A2 00 
0B23A2 00   
0B23A3 00 
0B23A4 00 
0B23A5 00 
0B23A5 00   
0B23A6 00 
0B23A7 00 
0B23A8 00 
0B23A8 00   
0B23A9 00 
0B23AA 00 
0B23AB 00 
0B23AB 00   
0B23AC 00 
0B23AD 00 
0B23AE 00 
0B23AE 00   
0B23AF 00 
0B23B0 00 
0B23B1 00 
0B23B1 00   
0B23B2 00 
0B23B3 00 
0B23B4 00 
0B23B4 00   
0B23B5 00 
0B23B6 00 
0B23B7 00 
0B23B7 00   
0B23B8 00 
0B23B9 00 
0B23BA 00 
0B23BA 00   
0B23BB 00 
0B23BC 00 
0B23BD 00 
0B23BD 00   
0B23BE 00 
0B23BF 00 
0B23C0 00 
0B2400 00     0067* STAVAR:         BLKB    27*4,0            ; Static Variables
0B2401 00 
0B2402 00 
0B2403 00 
0B2403 00   
0B2404 00 
0B2405 00 
0B2406 00 
0B2406 00   
0B2407 00 
0B2408 00 
0B2409 00 
0B2409 00   
0B240A 00 
0B240B 00 
0B240C 00 
0B240C 00   
0B240D 00 
0B240E 00 
0B240F 00 
0B240F 00   
0B2410 00 
0B2411 00 
0B2412 00 
0B2412 00   
0B2413 00 
0B2414 00 
0B2415 00 
0B2415 00   
0B2416 00 
0B2417 00 
0B2418 00 
0B2418 00   
0B2419 00 
0B241A 00 
0B241B 00 
0B241B 00   
0B241C 00 
0B241D 00 
0B241E 00 
0B241E 00   
0B241F 00 
0B2420 00 
0B2421 00 
0B2421 00   
0B2422 00 
0B2423 00 
0B2424 00 
0B2424 00   
0B2425 00 
0B2426 00 
0B2427 00 
0B2427 00   
0B2428 00 
0B2429 00 
0B242A 00 
0B242A 00   
0B242B 00 
0B242C 00 
0B242D 00 
0B242D 00   
0B242E 00 
0B242F 00 
0B2430 00 
0B2430 00   
0B2431 00 
0B2432 00 
0B2433 00 
0B2433 00   
0B2434 00 
0B2435 00 
0B2436 00 
0B2436 00   
0B2437 00 
0B2438 00 
0B2439 00 
0B2439 00   
0B243A 00 
0B243B 00 
0B243C 00 
0B243C 00   
0B243D 00 
0B243E 00 
0B243F 00 
0B243F 00   
0B2440 00 
0B2441 00 
0B2442 00 
0B2442 00   
0B2443 00 
0B2444 00 
0B2445 00 
0B2445 00   
0B2446 00 
0B2447 00 
0B2448 00 
0B2448 00   
0B2449 00 
0B244A 00 
0B244B 00 
0B244B 00   
0B244C 00 
0B244D 00 
0B244E 00 
0B244E 00   
0B244F 00 
0B2450 00 
0B2451 00 
0B246C 00     0068* DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
0B246D 00 
0B246E 00 
0B246F 00 
0B246F 00   
0B2470 00 
0B2471 00 
0B2472 00 
0B2472 00   
0B2473 00 
0B2474 00 
0B2475 00 
0B2475 00   
0B2476 00 
0B2477 00 
0B2478 00 
0B2478 00   
0B2479 00 
0B247A 00 
0B247B 00 
0B247B 00   
0B247C 00 
0B247D 00 
0B247E 00 
0B247E 00   
0B247F 00 
0B2480 00 
0B2481 00 
0B2481 00   
0B2482 00 
0B2483 00 
0B2484 00 
0B2484 00   
0B2485 00 
0B2486 00 
0B2487 00 
0B2487 00   
0B2488 00 
0B2489 00 
0B248A 00 
0B248A 00   
0B248B 00 
0B248C 00 
0B248D 00 
0B248D 00   
0B248E 00 
0B248F 00 
0B2490 00 
0B2490 00   
0B2491 00 
0B2492 00 
0B2493 00 
0B2493 00   
0B2494 00 
0B2495 00 
0B2496 00 
0B2496 00   
0B2497 00 
0B2498 00 
0B2499 00 
0B2499 00   
0B249A 00 
0B249B 00 
0B249C 00 
0B249C 00   
0B249D 00 
0B249E 00 
0B249F 00 
0B249F 00   
0B24A0 00 
0B24A1 00 
0B24A2 00 
0B24A2 00   
0B24A3 00 
0B24A4 00 
0B24A5 00 
0B24A5 00   
0B24A6 00 
0B24A7 00 
0B24A8 00 
0B24A8 00   
0B24A9 00 
0B24AA 00 
0B24AB 00 
0B24AB 00   
0B24AC 00 
0B24AD 00 
0B24AE 00 
0B24AE 00   
0B24AF 00 
0B24B0 00 
0B24B1 00 
0B24B1 00   
0B24B2 00 
0B24B3 00 
0B24B4 00 
0B24B4 00   
0B24B5 00 
0B24B6 00 
0B24B7 00 
0B24B7 00   
0B24B8 00 
0B24B9 00 
0B24BA 00 
0B24BA 00   
0B24BB 00 
0B24BC 00 
0B24BD 00 
0B24BD 00   
0B24BE 00 
0B24BF 00 
0B24C0 00 
0B24C0 00   
0B24C1 00 
0B24C2 00 
0B24C3 00 
0B24C3 00   
0B24C4 00 
0B24C5 00 
0B24C6 00 
0B24C6 00   
0B24C7 00 
0B24C8 00 
0B24C9 00 
0B24C9 00   
0B24CA 00 
0B24CB 00 
0B24CC 00 
0B24CC 00   
0B24CD 00 
0B24CE 00 
0B24CF 00 
0B24CF 00   
0B24D0 00 
0B24D1 00 
0B24D2 00 
0B24D2 00   
0B24D3 00 
0B24D4 00 
0B24D5 00 
0B24D5 00   
0B24D6 00 
0B24D7 00 
0B24D8 00 
0B24D8 00   
0B24D9 00 
0B24DA 00 
0B24DB 00 
0B24DB 00   
0B24DC 00 
0B24DD 00 
0B24DE 00 
0B24DE 00   
0B24DF 00 
0B24E0 00 
0B24E1 00 
0B24E1 00   
0B24E2 00 
0B24E3 00 
0B24E4 00 
0B24E4 00   
0B24E5 00 
0B250E 00     0069* FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B250F 00 
0B2510 00 
0B2511 00     0070* PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B2512 00 
0B2513 00 
              0071* ;
0B2514 00     0072* PAGE_:          BLKB    3,0               ; Start of User Program
0B2515 00 
0B2516 00 
0B2517 00     0073* TOP:            BLKB    3,0               ; First Location after User Program
0B2518 00 
0B2519 00 
0B251A 00     0074* LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B251B 00 
0B251C 00 
0B251D 00     0075* FREE:           BLKB    3,0               ; First Free Space Byte
0B251E 00 
0B251F 00 
0B2520 00     0076* HIMEM:          BLKB    3,0               ; First Protected Byte
0B2521 00 
0B2522 00 
              0077* ;
0B2523 00     0078* LINENO:         BLKB    3,0               ; Line Number
0B2524 00 
0B2525 00 
0B2526 00     0079* TRACEN:         BLKB    3,0               ; Trace Flag
0B2527 00 
0B2528 00 
0B2529 00     0080* AUTONO:         BLKB    3,0               ; Auto Flag
0B252A 00 
0B252B 00 
0B252C 00     0081* ERRTRP:         BLKB    3,0               ; Error Trap
0B252D 00 
0B252E 00 
0B252F 00     0082* ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B2530 00 
0B2531 00     0083* DATPTR:         BLKB    2,0               ; Data Pointer
0B2532 00 
0B2533 00     0084* ERL:            BLKB    2,0               ; Error Line
0B2534 00 
0B2535 00     0085* ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B2536 00 
0B2537 00 
0B2538 00     0086* RANDOM:         BLKB    5,0               ; Random Number
0B2539 00 
0B253A 00 
0B253B 00 
0B253B 00   
0B253D 00     0087* COUNT:          BLKB    1,0               ; Print Position
0B253E 00     0088* WIDTH:          BLKB    1,0               ; Print Width
0B253F 00     0089* ERR:            BLKB    1,0               ; Error Number
0B2540 00     0090* LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
              0091* ; - BIT 0: If set, output a space after the line number
              0092* ; - BIT 1: If set, then indent FOR/NEXT loops
              0093* ; - BIT 2: If set, then indent REPEAT/UNTIL loops
              0094* ; - BIT 3: If set, then output to buffer for *EDIT
              0095* ; OPT FLAG (top nibble)
              0096* ; - BIT 4: If set, then list whilst assembling
              0097* ; - BIT 5: If set, then assembler errors are reported
              0098* ; - BIT 6: If set, then place the code starting at address pointed to by O%
              0099* ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B2541 00     0100* INCREM:         BLKB    1,0               ; Auto-Increment Value
              0101* ;
              0102* ; --------------------------------------------------------------------------------------------
              0103* ; BEGIN MODIFIED CODE
              0104* ; --------------------------------------------------------------------------------------------
              0105* ; Originally in equs.inc
              0106* ;
              0107* OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
              0108* PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
              0109* VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
              0110* ; --------------------------------------------------------------------------------------------
              0111* ; END MODIFIED CODE
              0112* ; --------------------------------------------------------------------------------------------
              0113* 
              0114* ; Extra Agon-implementation specific system variables
              0115* ;
0B2542 00     0116* FLAGS:          BLKB    1,0       ; Miscellaneous flags
              0117* ; - BIT 7: Set if ESC pressed
              0118* ; - BIT 6: Set to disable ESC
0B2543 00     0119* OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B2544 00 
0B2545 00     0120* OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
              0121* ; - 0: Console
              0122* ; - 1: File
0B2546 00     0123* OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B2547 00     0124* KEYDOWN:        BLKB    1,0       ; Keydown flag
0B2548 00     0125* KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B2549 00     0126* KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B254A 00     0127* R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B254B 00 
0B254C 00 
0B254D 00     0128* R1:             BLKB    3,0
0B254E 00 
0B254F 00 
              0129* 
              0130* ;
              0131* ; This must be at the end
              0132* ;
              0133* RAM_END:
0B2550 FF     0134* ALIGN	256
0B2551 FF 
0B2552 FF 
0B2553 FF 
0B2553 FF   
0B2554 FF 
0B2555 FF 
0B2556 FF 
0B2556 FF   
0B2557 FF 
0B2558 FF 
0B2559 FF 
0B2559 FF   
0B255A FF 
0B255B FF 
0B255C FF 
0B255C FF   
0B255D FF 
0B255E FF 
0B255F FF 
0B255F FF   
0B2560 FF 
0B2561 FF 
0B2562 FF 
0B2562 FF   
0B2563 FF 
0B2564 FF 
0B2565 FF 
0B2565 FF   
0B2566 FF 
0B2567 FF 
0B2568 FF 
0B2568 FF   
0B2569 FF 
0B256A FF 
0B256B FF 
0B256B FF   
0B256C FF 
0B256D FF 
0B256E FF 
0B256E FF   
0B256F FF 
0B2570 FF 
0B2571 FF 
0B2571 FF   
0B2572 FF 
0B2573 FF 
0B2574 FF 
0B2574 FF   
0B2575 FF 
0B2576 FF 
0B2577 FF 
0B2577 FF   
0B2578 FF 
0B2579 FF 
0B257A FF 
0B257A FF   
0B257B FF 
0B257C FF 
0B257D FF 
0B257D FF   
0B257E FF 
0B257F FF 
0B2580 FF 
0B2580 FF   
0B2581 FF 
0B2582 FF 
0B2583 FF 
0B2583 FF   
0B2584 FF 
0B2585 FF 
0B2586 FF 
0B2586 FF   
0B2587 FF 
0B2588 FF 
0B2589 FF 
0B2589 FF   
0B258A FF 
0B258B FF 
0B258C FF 
0B258C FF   
0B258D FF 
0B258E FF 
0B258F FF 
0B258F FF   
0B2590 FF 
0B2591 FF 
0B2592 FF 
0B2592 FF   
0B2593 FF 
0B2594 FF 
0B2595 FF 
0B2595 FF   
0B2596 FF 
0B2597 FF 
0B2598 FF 
0B2598 FF   
0B2599 FF 
0B259A FF 
0B259B FF 
0B259B FF   
0B259C FF 
0B259D FF 
0B259E FF 
0B259E FF   
0B259F FF 
0B25A0 FF 
0B25A1 FF 
0B25A1 FF   
0B25A2 FF 
0B25A3 FF 
0B25A4 FF 
0B25A4 FF   
0B25A5 FF 
0B25A6 FF 
0B25A7 FF 
0B25A7 FF   
0B25A8 FF 
0B25A9 FF 
0B25AA FF 
0B25AA FF   
0B25AB FF 
0B25AC FF 
0B25AD FF 
0B25AD FF   
0B25AE FF 
0B25AF FF 
0B25B0 FF 
0B25B0 FF   
0B25B1 FF 
0B25B2 FF 
0B25B3 FF 
0B25B3 FF   
0B25B4 FF 
0B25B5 FF 
0B25B6 FF 
0B25B6 FF   
0B25B7 FF 
0B25B8 FF 
0B25B9 FF 
0B25B9 FF   
0B25BA FF 
0B25BB FF 
0B25BC FF 
0B25BC FF   
0B25BD FF 
0B25BE FF 
0B25BF FF 
0B25BF FF   
0B25C0 FF 
0B25C1 FF 
0B25C2 FF 
0B25C2 FF   
0B25C3 FF 
0B25C4 FF 
0B25C5 FF 
0B25C5 FF   
0B25C6 FF 
0B25C7 FF 
0B25C8 FF 
0B25C8 FF   
0B25C9 FF 
0B25CA FF 
0B25CB FF 
0B25CB FF   
0B25CC FF 
0B25CD FF 
0B25CE FF 
0B25CE FF   
0B25CF FF 
0B25D0 FF 
0B25D1 FF 
0B25D1 FF   
0B25D2 FF 
0B25D3 FF 
0B25D4 FF 
              0135* USER:							; Must be aligned on a page boundary
              0136* 
