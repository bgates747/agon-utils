        Output     Line 
       
               0001 ;
               0002 ; Title:	flower
               0003 ; Author:	Brandon R. Gates
               0004 ; Created:	Nov. 2024
               0005 ;
               0006 ; This program draws 2D curves related to the hypotrochoid / epitrochoid family (i.e. Spirographs),
               0007 ; more generally known as roulettes. While it is possible to construct curves fitting the precise
               0008 ; definitions of such curves, the program is not limited to them as slipping of the outer circle
               0009 ; is allowable. In addition, continually plotting the curve insribed by the outer circle is not required.
               0010 ; This allows rotating polygonal shapes remniscent of string art, as well as daisy-like curves.
               0011 ; Hence the name "flower" even though the program is not limited to such shapes.
               0012 ; Another key difference is that cumulative shrinking can be applied to the radii of the rotating circles,
               0013 ; thus allowing curves which form true spirals in contrast to the Spirograph toy, which does not.
               0014 ;
               0015 ; Parameters with example values:
               0016 ; petals      = 3.03  :
               0017 ; vectors     = 1.98  :
               0018 ; depth       = 0.6   :
               0019 ; periods     = 66    :
               0020 ; shrink      = 0.8   :
               0021 ; theta_prime = 0.0   :
               0022 ; radius_scale= 480   :
               0023 ;
               0024 ; ========================================
               0025 ; MODIFIED MOSLET INITIALIZATION CODE
               0026 ; ========================================
               0027 ;
               0028 ; Title:	Copy - Initialisation Code
               0029 ; Author:	Dean Belfield, Lennart Benschop
               0030 ; Created:	06/11/2022
               0031 ; Last Updated:	26/12/2022
               0032 ;
               0033 ; Modinfo:
               0034 ; 17/12/2022:	Added parameter processing
               0035 ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
               0036 ; Changed:      08/04/2924 adapt to ez80asm
               0037 ;
               0038 ASSUME	ADL = 1
               0039 INCLUDE "mos_api.inc"
              0001* ;
              0002* ; Title:	AGON MOS - API for user projects
              0003* ; Author:	Dean Belfield
              0004* ; Created:	03/08/2022
              0005* ; Last Updated:	11/11/2023
              0006* ;
              0007* ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
              0008* ;
              0009* ; Modinfo:
              0010* ; 05/08/2022:	Added mos_feof
              0011* ; 09/08/2022:	Added system variables: cursorX, cursorY
              0012* ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
              0013* ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
              0014* ; 24/09/2022:	Added mos_getError, mos_mkdir
              0015* ; 13/10/2022:	Added mos_oscli
              0016* ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
              0017* ; 04/03/2023:	Added sysvar_scrpixelIndex
              0018* ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
              0019* ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
              0020* ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
              0021* ; 22/03/2023:	The VDP commands are now indexed from 0x80
              0022* ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
              0023* ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
              0024* ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
              0025* ; 19/05/2023:	Added sysvar_scrMode
              0026* ; 05/06/2023:	Added sysvar_rtcEnable
              0027* ; 03/08/2023:	Added mos_setkbvector
              0028* ; 10/08/2023:	Added mos_getkbmap
              0029* ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
              0030* ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
              0031* ;
              0032* ; VDP control (VDU 23, 0, n)
              0033* ;
              0034* vdp_gp:			EQU 	80h
              0035* vdp_keycode:		EQU 	81h
              0036* vdp_cursor:		EQU	82h
              0037* vdp_scrchar:		EQU	83h
              0038* vdp_scrpixel:		EQU	84h
              0039* vdp_audio:		EQU	85h
              0040* vdp_mode:		EQU	86h
              0041* vdp_rtc:		EQU	87h
              0042* vdp_keystate:		EQU	88h
              0043* vdp_logicalcoords:	EQU	C0h
              0044* vdp_terminalmode:	EQU	FFh
              0045* 
              0046* ; MOS high level functions
              0047* ;
              0048* mos_getkey:		EQU	00h
              0049* mos_load:		EQU	01h
              0050* mos_save:		EQU	02h
              0051* mos_cd:			EQU	03h
              0052* mos_dir:		EQU	04h
              0053* mos_del:		EQU	05h
              0054* mos_ren:		EQU	06h
              0055* mos_mkdir:		EQU	07h
              0056* mos_sysvars:		EQU	08h
              0057* mos_editline:		EQU	09h
              0058* mos_fopen:		EQU	0Ah
              0059* mos_fclose:		EQU	0Bh
              0060* mos_fgetc:		EQU	0Ch
              0061* mos_fputc:		EQU	0Dh
              0062* mos_feof:		EQU	0Eh
              0063* mos_getError:		EQU	0Fh
              0064* mos_oscli:		EQU	10h
              0065* mos_copy:		EQU	11h
              0066* mos_getrtc:		EQU	12h
              0067* mos_setrtc:		EQU	13h
              0068* mos_setintvector:	EQU	14h
              0069* mos_uopen:		EQU	15h
              0070* mos_uclose:		EQU	16h
              0071* mos_ugetc:		EQU	17h
              0072* mos_uputc:		EQU 	18h
              0073* mos_getfil:		EQU	19h
              0074* mos_fread:		EQU	1Ah
              0075* mos_fwrite:		EQU	1Bh
              0076* mos_flseek:		EQU	1Ch
              0077* mos_setkbvector:	EQU	1Dh
              0078* mos_getkbmap:		EQU	1Eh
              0079* mos_i2c_open:		EQU	1Fh
              0080* mos_i2c_close:		EQU	20h
              0081* mos_i2c_write:		EQU	21h
              0082* mos_i2c_read:		EQU	22h
              0083* 
              0084* 
              0085* ; FatFS file access functions
              0086* ;
              0087* ffs_fopen:		EQU	80h
              0088* ffs_fclose:		EQU	81h
              0089* ffs_fread:		EQU	82h
              0090* ffs_fwrite:		EQU	83h
              0091* ffs_flseek:		EQU	84h
              0092* ffs_ftruncate:		EQU	85h
              0093* ffs_fsync:		EQU	86h
              0094* ffs_fforward:		EQU	87h
              0095* ffs_fexpand:		EQU	88h
              0096* ffs_fgets:		EQU	89h
              0097* ffs_fputc:		EQU	8Ah
              0098* ffs_fputs:		EQU	8Bh
              0099* ffs_fprintf:		EQU	8Ch
              0100* ffs_ftell:		EQU	8Dh
              0101* ffs_feof:		EQU	8Eh
              0102* ffs_fsize:		EQU	8Fh
              0103* ffs_ferror:		EQU	90h
              0104* 
              0105* ; FatFS directory access functions
              0106* ;
              0107* ffs_dopen:		EQU	91h
              0108* ffs_dclose:		EQU	92h
              0109* ffs_dread:		EQU	93h
              0110* ffs_dfindfirst:		EQU	94h
              0111* ffs_dfindnext:		EQU	95h
              0112* 
              0113* ; FatFS file and directory management functions
              0114* ;
              0115* ffs_stat:		EQU	96h
              0116* ffs_unlink:		EQU	97h
              0117* ffs_rename:		EQU	98h
              0118* ffs_chmod:		EQU	99h
              0119* ffs_utime:		EQU	9Ah
              0120* ffs_mkdir:		EQU	9Bh
              0121* ffs_chdir:		EQU	9Ch
              0122* ffs_chdrive:		EQU	9Dh
              0123* ffs_getcwd:		EQU	9Eh
              0124* 
              0125* ; FatFS volume management and system configuration functions
              0126* ;
              0127* ffs_mount:		EQU	9Fh
              0128* ffs_mkfs:		EQU	A0h
              0129* ffs_fdisk:		EQU	A1h
              0130* ffs_getfree:		EQU	A2h
              0131* ffs_getlabel:		EQU	A3h
              0132* ffs_setlabel:		EQU	A4h
              0133* ffs_setcp:		EQU	A5h
              0134* 
              0135* ; File access modes
              0136* ;
              0137* fa_read:		EQU	01h
              0138* fa_write:		EQU	02h
              0139* fa_open_existing:	EQU	00h
              0140* fa_create_new:		EQU	04h
              0141* fa_create_always:	EQU	08h
              0142* fa_open_always:		EQU	10h
              0143* fa_open_append:		EQU	30h
              0144* 
              0145* ; System variable indexes for api_sysvars
              0146* ; Index into _sysvars in globals.asm
              0147* ;
              0148* sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
              0149* sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
              0150* sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
              0151* sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
              0152* sysvar_cursorX:		EQU	07h	; 1: Cursor X position
              0153* sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
              0154* sysvar_scrchar:		EQU	09h	; 1: Character read from screen
              0155* sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
              0156* sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
              0157* sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
              0158* sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
              0159* sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
              0160* sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
              0161* sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
              0162* sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
              0163* sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
              0164* sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
              0165* sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
              0166* sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
              0167* sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
              0168* sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
              0169* sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
              0170* sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
              0171* sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
              0172* sysvar_scrMode:		EQU	27h	; 1: Screen mode
              0173* sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
              0174* sysvar_mouseX:		EQU	29h	; 2: Mouse X position
              0175* sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
              0176* sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
              0177* sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
              0178* sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
              0179* sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
              0180* ;
              0181* ; Flags for the VPD protocol
              0182* ;
              0183* vdp_pflag_cursor:	EQU	00000001b
              0184* vdp_pflag_scrchar:	EQU	00000010b
              0185* vdp_pflag_point:	EQU	00000100b
              0186* vdp_pflag_audio:	EQU	00001000b
              0187* vdp_pflag_mode:		EQU	00010000b
              0188* vdp_pflag_rtc:		EQU	00100000b
              0189* vdp_pflag_mouse:	EQU	01000000b
              0190* ; vdp_pflag_buffered:	EQU	10000000b
              0191* 
              0192* 
              0193* ; FatFS structures
              0194* ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
              0195* ;
              0196* ; Object ID and allocation information (FFOBJID)
              0197* FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
              0198* FFOBJID.id:       EQU 3    ; Hosting volume mount ID
              0199* FFOBJID.attr:     EQU 5    ; Object attribute
              0200* FFOBJID.stat:     EQU 6    ; Object chain status
              0201* FFOBJID.sclust:   EQU 7    ; Object data start cluster
              0202* FFOBJID.objsize:  EQU 11   ; Object size
              0203* FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
              0204* ;
              0205* ; File object structure (FIL)
              0206* ;
              0207* FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0208* FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
              0209* FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
              0210* FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
              0211* FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
              0212* FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
              0213* FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
              0214* FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
              0215* FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
              0216* ;
              0217* ; Directory object structure (DIR)
              0218* ;
              0219* DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0220* DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
              0221* DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
              0222* DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
              0223* DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
              0224* DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
              0225* DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
              0226* DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
              0227* ;
              0228* ; File information structure (FILINFO)
              0229* ;
              0230* FILINFO.fsize:    EQU 0    ; File size
              0231* FILINFO.fdate:    EQU 4    ; Modified date
              0232* FILINFO.ftime:    EQU 6    ; Modified time
              0233* FILINFO.fattrib:  EQU 8    ; File attribute
              0234* FILINFO.altname:  EQU 9    ; Alternative file name
              0235* FILINFO.fname:    EQU 22   ; Primary file name
              0236* FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
              0237* ;
              0238* ; Macro for calling the API
              0239* ; Parameters:
              0240* ; - function: One of the function numbers listed above
              0241* ;
              0242* MACRO MOSCALL	function
              0243* LD	A, function
              0244* RST.LIS	08h
              0245* ENDMACRO
               0040 ORG 0x0B0000 ; Is a moslet
               0041 
               0042 MACRO PROGNAME
               0043 ASCIZ "flower"
               0044 ENDMACRO
               0045 ;
               0046 ; Start in ADL mode
               0047 ;
0B0000 C3      0048 JP	_start
0B0001 45 
0B0002 00 
0B0003 0B 
               0049 ;
               0050 ; The header stuff is from byte 64 onwards
               0051 ;
               0052 _exec_name:
               0053 PROGNAME			; The executable name, only used in argv
0B0004 66     0001M ASCIZ "flower"
0B0005 6C 
0B0006 6F 
0B0007 77 
0B0007 65   
0B0008 72 
0B0009 00 
               0054 
0B000B FF      0055 ALIGN	64
0B000C FF 
0B000D FF 
0B000E FF 
0B000E FF   
0B000F FF 
0B0010 FF 
0B0011 FF 
0B0011 FF   
0B0012 FF 
0B0013 FF 
0B0014 FF 
0B0014 FF   
0B0015 FF 
0B0016 FF 
0B0017 FF 
0B0017 FF   
0B0018 FF 
0B0019 FF 
0B001A FF 
0B001A FF   
0B001B FF 
0B001C FF 
0B001D FF 
0B001D FF   
0B001E FF 
0B001F FF 
0B0020 FF 
0B0020 FF   
0B0021 FF 
0B0022 FF 
0B0023 FF 
0B0023 FF   
0B0024 FF 
0B0025 FF 
0B0026 FF 
0B0026 FF   
0B0027 FF 
0B0028 FF 
0B0029 FF 
0B0029 FF   
0B002A FF 
0B002B FF 
0B002C FF 
0B002C FF   
0B002D FF 
0B002E FF 
0B002F FF 
0B002F FF   
0B0030 FF 
0B0031 FF 
0B0032 FF 
0B0032 FF   
               0056 
0B0040 4D      0057 DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0041 4F 
0B0042 53 
0B0043 00      0058 DB	00h			; MOS header version 0
0B0044 01      0059 DB	01h			; Flag for run mode (0: Z80, 1: ADL)
               0060 ;
               0061 ; And the code follows on immediately after the header
               0062 ;
               0063 _start:
0B0045 F5      0064 PUSH	AF			; Preserve the registers
0B0046 C5      0065 PUSH	BC
0B0047 D5      0066 PUSH	DE
0B0048 DD      0067 PUSH	IX
0B0049 E5 
0B004A FD      0068 PUSH	IY
0B004B E5 
0B004C ED      0069 LD	A, MB			; Save MB
0B004D 6E 
0B004E F5      0070 PUSH 	AF
0B004F AF      0071 XOR 	A
0B0050 ED      0072 LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0051 6D 
               0073 
               0074 ; CALL		_clear_ram ; Clear the BASIC memory allocation
               0075 
0B0052 DD      0076 LD	IX, argv_ptrs		; The argv array pointer address
0B0053 21 
0B0054 D6 
0B0055 56 
0B0055 0B   
0B0057 DD      0077 PUSH	IX
0B0058 E5 
0B0059 CD      0078 CALL	_parse_params		; Parse the parameters
0B005A 70 
0B005B 00 
0B005C 0B 
0B005D DD      0079 POP	IX			; IX: argv
0B005E E1 
0B005F 06      0080 LD	B, 0			;  C: argc
0B0060 00 
0B0061 CD      0081 CALL	_main_init			; Start user code
0B0062 3F 
0B0063 57 
0B0064 0B 
               0082 
0B0065 F1      0083 POP 	AF
0B0066 ED      0084 LD	MB, A
0B0067 6D 
0B0068 FD      0085 POP	IY			; Restore registers
0B0069 E1 
0B006A DD      0086 POP	IX
0B006B E1 
0B006C D1      0087 POP	DE
0B006D C1      0088 POP	BC
0B006E F1      0089 POP	AF
0B006F C9      0090 RET
               0091 
               0092 ; Parse the parameter string into a C array
               0093 ; Parameters
               0094 ; - HL: Address of parameter string
               0095 ; - IX: Address for array pointer storage
               0096 ; Returns:
               0097 ; -  C: Number of parameters parsed
               0098 ;
0B0070 01      0099 _parse_params:		LD	BC, _exec_name
0B0071 04 
0B0072 00 
0B0073 0B 
0B0074 DD      0100 LD	(IX+0), BC		; ARGV[0] = the executable name
0B0075 0F 
0B0076 00 
0B0077 ED      0101 LEA     IX, IX+3
0B0078 32 
0B0079 03 
0B007A CD      0102 CALL	_skip_spaces		; Skip HL past any leading spaces
0B007B B2 
0B007C 00 
0B007D 0B 
               0103 ;
0B007E 01      0104 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B007F 01 
0B0080 00 
0B0081 00 
0B0082 06      0105 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0083 0F 
               0106 ;
               0107 _parse_params_1:
0B0084 C5      0108 PUSH	BC			; Stack ARGC
0B0085 E5      0109 PUSH	HL			; Stack start address of token
0B0086 CD      0110 CALL	_get_token		; Get the next token
0B0087 A3 
0B0088 00 
0B0089 0B 
0B008A 79      0111 LD	A, C			; A: Length of the token in characters
0B008B D1      0112 POP	DE			; Start address of token (was in HL)
0B008C C1      0113 POP	BC			; ARGC
0B008D B7      0114 OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8      0115 RET	Z
               0116 ;
0B008F DD      0117 LD	(IX+0), DE		; Store the pointer to the token
0B0090 1F 
0B0091 00 
0B0092 E5      0118 PUSH	HL			; DE=HL
0B0093 D1      0119 POP	DE
0B0094 CD      0120 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0095 B2 
0B0096 00 
0B0097 0B 
0B0098 AF      0121 XOR	A
0B0099 12      0122 LD	(DE), A			; Zero-terminate the token
0B009A ED      0123 LEA  	IX, IX+3			; Advance to next pointer position
0B009B 32 
0B009C 03 
0B009D 0C      0124 INC	C			; Increment ARGC
0B009E 79      0125 LD	A, C			; Check for C >= A
0B009F B8      0126 CP	B
0B00A0 38      0127 JR	C, _parse_params_1	; And loop
0B00A1 E2 
0B00A2 C9      0128 RET
               0129 
               0130 ; Get the next token
               0131 ; Parameters:
               0132 ; - HL: Address of parameter string
               0133 ; Returns:
               0134 ; - HL: Address of first character after token
               0135 ; -  C: Length of token (in characters)
               0136 ;
0B00A3 0E      0137 _get_token:		LD	C, 0			; Initialise length
0B00A4 00 
0B00A5 7E      0138 @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7      0139 OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8      0140 RET 	Z
0B00A8 FE      0141 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00A9 0D 
0B00AA C8      0142 RET	Z
0B00AB FE      0143 CP	' '			; Exit if space (end of token)
0B00AC 20 
0B00AD C8      0144 RET	Z
0B00AE 23      0145 INC	HL			; Advance to next character
0B00AF 0C      0146 INC 	C			; Increment length
0B00B0 18      0147 JR	@B
0B00B1 F3 
               0148 
               0149 ; Skip spaces in the parameter string
               0150 ; Parameters:
               0151 ; - HL: Address of parameter string
               0152 ; Returns:
               0153 ; - HL: Address of next none-space character
               0154 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0155 ;
0B00B2 7E      0156 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE      0157 CP	' '			; Exit if not space
0B00B4 20 
0B00B5 C0      0158 RET	NZ
0B00B6 23      0159 INC	HL			; Advance to next character
0B00B7 18      0160 JR	_skip_spaces		; Increment length
0B00B8 F9 
               0161 
               0162 ; ========================================
               0163 ; BASIC INITIALIZATION CODE FROM basic/init.asm
               0164 ; ========================================
               0165 ;
               0166 ;Clear the application memory
               0167 ;
               0168 _clear_ram:
0B00B9 E5      0169 push hl
0B00BA C5      0170 PUSH		BC
0B00BB 21      0171 LD		HL, RAM_START
0B00BC 00 
0B00BD 5B 
0B00BE 0B 
0B00BF 11      0172 LD		DE, RAM_START + 1
0B00C0 01 
0B00C1 5B 
0B00C2 0B 
0B00C3 01      0173 LD		BC, RAM_END - RAM_START - 1
0B00C4 4F 
0B00C5 03 
0B00C6 00 
0B00C7 AF      0174 XOR		A
0B00C8 77      0175 LD		(HL), A
0B00C9 ED      0176 LDIR
0B00CA B0 
0B00CB C1      0177 POP		BC
0B00CC E1      0178 pop hl
0B00CD C9      0179 RET
               0180 
               0181 ; ========================================
               0182 ; BEGIN APPLICATION CODE
               0183 ; ========================================
               0184 
               0185 ; API INCLUDES
               0186 include "basic.inc"
              0001* include "basic/macros.inc"
             0001** ; Title:	BBC Basic Interpreter - Z80 version
             0002** ;		Useful macros
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	11/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 11/06/2023:	Modified to run in ADL mode
             0009** ; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
             0010** 
             0011** MACRO EXREG	rp1, rp2
             0012** PUSH	rp1
             0013** POP	rp2
             0014** ENDMACRO
             0015** 
             0016** ; MACRO ADD8U_DE	reg
             0017** MACRO ADD8U_DE
             0018** ADD	A, E
             0019** LD	E, A
             0020** ADC	A, D
             0021** SUB	E
             0022** LD	D, A
             0023** ENDMACRO
             0024** 
             0025** ; MACRO ADD8U_HL	reg
             0026** MACRO ADD8U_HL
             0027** ADD	A, L
             0028** LD	L, A
             0029** ADC	A, H
             0030** SUB	L
             0031** LD	H, A
             0032** ENDMACRO
             0033** 
             0034** MACRO VDU	val
             0035** LD	A, val
             0036** CALL	OSWRCH
             0037** ENDMACRO
             0038** 
             0039** MACRO SET_GPIO	reg, val
             0040** IN0	A, (reg)
             0041** OR	val
             0042** OUT0	(reg), A
             0043** ENDMACRO
             0044** 
             0045** MACRO RES_GPIO	reg, val
             0046** PUSH	BC
             0047** LD	A, val
             0048** CPL
             0049** LD	C, A
             0050** IN0	A, (reg)
             0051** AND	C
             0052** OUT0	(reg), A
             0053** POP	BC
             0054** ENDMACRO
              0002* include "basic/equs.inc"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Equs
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	08/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 08/06/2023:	Added SIZEW
             0009** 
             0010** ; XREF		STAVAR
             0011** ; XREF		ACCS
             0012** 
             0013** RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
             0014** ;Stack_Top:		EQU		0000h	; Stack at top
             0015** SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
             0016** 
             0017** ; For GPIO
             0018** ; PA not available on eZ80L92
             0019** ;
             0020** PA_DR:			EQU		96h
             0021** PA_DDR:			EQU		97h
             0022** PA_ALT1:		EQU		98h
             0023** PA_ALT2:		EQU		99h
             0024** PB_DR:          	EQU		9Ah
             0025** PB_DDR:        	 	EQU		9Bh
             0026** PB_ALT1:        	EQU		9Ch
             0027** PB_ALT2:        	EQU		9Dh
             0028** PC_DR:          	EQU		9Eh
             0029** PC_DDR:         	EQU		9Fh
             0030** PC_ALT1:        	EQU		A0h
             0031** PC_ALT2:        	EQU		A1h
             0032** PD_DR:          	EQU		A2h
             0033** PD_DDR:			EQU		A3h
             0034** PD_ALT1:		EQU		A4h
             0035** PD_ALT2:		EQU		A5h
             0036** 
             0037** GPIOMODE_OUT:		EQU		0	; Output
             0038** GPIOMODE_IN:		EQU		1	; Input
             0039** GPIOMODE_DIO:		EQU		2	; Open Drain IO
             0040** GPIOMODE_SIO:		EQU		3	; Open Source IO
             0041** GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
             0042** GPIOMODE_ALTF:		EQU		5;	; Alt Function
             0043** GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
             0044** GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
             0045** GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
             0046** GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
             0047** 
             0048** ; ; Originally in ram.asm
             0049** ; ;
             0050** ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
             0051** ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
             0052** ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
             0053** 
             0054** ; Originally in main.asm
             0055** ;
             0056** CR:			EQU     0DH
             0057** LF:			EQU     0AH
             0058** ESC:			EQU     1BH
              0003* include "basic/eval.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Expression Evaluation & Arithmetic Module - "EVAL"
             0004** ; Author:	(C) Copyright  R.T.Russell  1984
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	12/05/2023
             0007** ; Last Updated:	17/08/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 07/06/2023:	Modified to run in ADL mode
             0011** ; 26/06/2023:	Fixed HEX and HEXSTR
             0012** ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
             0013** ; 17/08/2023:	Added binary constants
             0014** 
             0015** ; .ASSUME	ADL = 1
             0016** 
             0017** ; INCLUDE	"equs.inc"
             0018** ; INCLUDE "macros.inc"
             0019** ; INCLUDE "mos_api.inc"	; In MOS/src
             0020** 
             0021** ; SEGMENT CODE
             0022** 
             0023** ; XDEF	EXPR
             0024** ; XDEF	EXPRN
             0025** ; XDEF	EXPRI
             0026** ; XDEF	EXPRS
             0027** ; XDEF	ITEMI
             0028** ; XDEF	LOADN
             0029** ; XDEF	LOAD4
             0030** ; XDEF	CONS
             0031** ; XDEF	LOADS
             0032** ; XDEF	SFIX
             0033** ; XDEF	VAL0
             0034** ; XDEF	SEARCH
             0035** ; XDEF	SWAP
             0036** ; XDEF	TEST
             0037** ; XDEF	DECODE
             0038** ; XDEF	HEXSTR
             0039** ; XDEF	STR
             0040** ; XDEF	ZERO
             0041** ; XDEF	PUSHS
             0042** ; XDEF	POPS
             0043** ; XDEF	COMMA
             0044** ; XDEF	BRAKET
             0045** ; XDEF	NXT
             0046** ; XDEF	COUNT0
             0047** 
             0048** ; XREF	ADVAL
             0049** ; XREF	FN_EX
             0050** ; XREF	POINT
             0051** ; XREF	USR
             0052** ; XREF	SYNTAX
             0053** ; XREF	ERROR_
             0054** ; XREF	CHECK
             0055** ; XREF	GETVAR
             0056** ; XREF	LISTON
             0057** ; XREF	RANGE
             0058** ; XREF	FPP
             0059** ; XREF	GETCSR
             0060** ; XREF	CHANEL
             0061** ; XREF	OSSTAT
             0062** ; XREF	OSBGET
             0063** ; XREF	LOMEM
             0064** ; XREF	HIMEM
             0065** ; XREF	PAGE_
             0066** ; XREF	TOP
             0067** ; XREF	ERL
             0068** ; XREF	ERR
             0069** ; XREF	COUNT
             0070** ; XREF	OSOPEN
             0071** ; XREF	GETEXT
             0072** ; XREF	GETPTR
             0073** ; XREF	GETIME
             0074** ; XREF	GETIMS
             0075** ; XREF	LEXAN2
             0076** ; XREF	RANDOM
             0077** ; XREF	STORE5
             0078** ; XREF	GETSCHR
             0079** ; XREF	OSRDCH
             0080** ; XREF	OSKEY
             0081** ; XREF	INKEY1
             0082** ; XREF	EXTERR
             0083** ;
             0084** ; BINARY FLOATING POINT REPRESENTATION:
             0085** ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
             0086** ;     8 BIT EXCESS-128 SIGNED EXPONENT
             0087** ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
             0088** ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
             0089** ;
             0090** ; BINARY INTEGER REPRESENTATION:
             0091** ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
             0092** ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
             0093** ;
             0094** ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
             0095** ;                             EXPONENT - C
             0096** ;
             0097** 
             0098** ;
             0099** ; Table of addresses for functions
             0100** ;
             0101** FUNTOK:			EQU	8DH			; First token number
             0102** ;
0B00CE AA    0103** FUNTBL:			DW24	DECODE			; Line number
0B00CF 08 
0B00D0 0B 
0B00D1 58    0104** DW24	OPENIN			; OPENIN
0B00D2 05 
0B00D3 0B 
0B00D4 7A    0105** DW24	PTR_EV			; PTR
0B00D5 05 
0B00D6 0B 
0B00D7 14    0106** DW24	PAGEV			; PAGE
0B00D8 05 
0B00D9 0B 
0B00DA 84    0107** DW24	TIMEV			; TIME
0B00DB 05 
0B00DC 0B 
0B00DD 00    0108** DW24	LOMEMV			; LOMEM
0B00DE 05 
0B00DF 0B 
0B00E0 0A    0109** DW24	HIMEMV			; HIMEM
0B00E1 05 
0B00E2 0B 
0B00E3 D8    0110** DW24	ABSV			; ABS
0B00E4 05 
0B00E5 0B 
0B00E6 14    0111** DW24	ACS			; ACS
0B00E7 06 
0B00E8 0B 
0B00E9 7B    0112** DW24	ADVAL			; ADVAL
0B00EA 43 
0B00EB 0B 
0B00EC E9    0113** DW24	ASC			; ASC
0B00ED 04 
0B00EE 0B 
0B00EF 0C    0114** DW24	ASN			; ASN
0B00F0 06 
0B00F1 0B 
0B00F2 10    0115** DW24	ATN			; ATN
0B00F3 06 
0B00F4 0B 
0B00F5 B2    0116** DW24	BGET			; BGET
0B00F6 04 
0B00F7 0B 
0B00F8 F8    0117** DW24	COS			; COS
0B00F9 05 
0B00FA 0B 
0B00FB 3F    0118** DW24	COUNTV			; COUNT
0B00FC 05 
0B00FD 0B 
0B00FE E0    0119** DW24	DEG			; DEG
0B00FF 05 
0B0100 0B 
0B0101 33    0120** DW24	ERLV			; ERL
0B0102 05 
0B0103 0B 
0B0104 39    0121** DW24	ERRV			; ERR
0B0105 05 
0B0106 0B 
0B0107 3D    0122** DW24	EVAL_			; EVAL
0B0108 06 
0B0109 0B 
0B010A 00    0123** DW24	EXP			; EXP
0B010B 06 
0B010C 0B 
0B010D 70    0124** DW24	EXT			; EXT
0B010E 05 
0B010F 0B 
0B0110 57    0125** DW24	ZERO			; FALSE
0B0111 09 
0B0112 0B 
0B0113 43    0126** DW24	FN_EX			; FN
0B0114 10 
0B0115 0B 
0B0116 D0    0127** DW24	GET			; GET
0B0117 04 
0B0118 0B 
0B0119 BF    0128** DW24	INKEY			; INKEY
0B011A 04 
0B011B 0B 
0B011C EF    0129** DW24	INSTR			; INSTR(
0B011D 06 
0B011E 0B 
0B011F EC    0130** DW24	INT_			; INT
0B0120 05 
0B0121 0B 
0B0122 F9    0131** DW24	LEN			; LEN
0B0123 04 
0B0124 0B 
0B0125 04    0132** DW24	LN			; LN
0B0126 06 
0B0127 0B 
0B0128 08    0133** DW24	LOG			; LOG
0B0129 06 
0B012A 0B 
0B012B DC    0134** DW24	NOTK			; NOT
0B012C 05 
0B012D 0B 
0B012E 54    0135** DW24	OPENUP			; OPENUP
0B012F 05 
0B0130 0B 
0B0131 51    0136** DW24	OPENOT			; OPENOUT
0B0132 05 
0B0133 0B 
0B0134 D4    0137** DW24	PI			; PI
0B0135 05 
0B0136 0B 
0B0137 2D    0138** DW24	POINT			; POINT(
0B0138 44 
0B0139 0B 
0B013A 91    0139** DW24	POS			; POS
0B013B 04 
0B013C 0B 
0B013D E4    0140** DW24	RAD			; RAD
0B013E 05 
0B013F 0B 
0B0140 71    0141** DW24	RND			; RND
0B0141 06 
0B0142 0B 
0B0143 E8    0142** DW24	SGN			; SGN
0B0144 05 
0B0145 0B 
0B0146 FC    0143** DW24	SIN			; SIN
0B0147 05 
0B0148 0B 
0B0149 F0    0144** DW24	SQR			; SQR
0B014A 05 
0B014B 0B 
0B014C F4    0145** DW24	TAN			; TAN
0B014D 05 
0B014E 0B 
0B014F 1E    0146** DW24	TOPV			; TO(P)
0B0150 05 
0B0151 0B 
0B0152 C9    0147** DW24	TRUE			; TRUE
0B0153 05 
0B0154 0B 
0B0155 E6    0148** DW24	USR			; USR
0B0156 14 
0B0157 0B 
0B0158 2E    0149** DW24	VAL			; VAL
0B0159 06 
0B015A 0B 
0B015B 9A    0150** DW24	VPOS			; VPOS
0B015C 04 
0B015D 0B 
0B015E 83    0151** DW24	CHRS			; CHRS
0B015F 07 
0B0160 0B 
0B0161 8B    0152** DW24	GETS			; GETS
0B0162 07 
0B0163 0B 
0B0164 9C    0153** DW24	INKEYS			; INKEYS
0B0165 07 
0B0166 0B 
0B0167 21    0154** DW24	LEFTS			; LEFTS(
0B0168 08 
0B0169 0B 
0B016A E9    0155** DW24	MIDS			; MIDS(
0B016B 07 
0B016C 0B 
0B016D 41    0156** DW24	RIGHTS			; RIGHTS(
0B016E 08 
0B016F 0B 
0B0170 0E    0157** DW24	STRS			; STR$
0B0171 09 
0B0172 0B 
0B0173 62    0158** DW24	STRING_			; STRINGS(
0B0174 08 
0B0175 0B 
0B0176 A2    0159** DW24	EOF			; EOF
0B0177 04 
0B0178 0B 
             0160** ;
             0161** FUNTBL_END:		EQU	$
             0162** ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
             0163** TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
             0164** 
             0165** ANDK:			EQU     80H
             0166** DIVK:			EQU     81H
             0167** EORK:			EQU     82H
             0168** MODK:			EQU     83H
             0169** ORK:			EQU     84H
             0170** ;
0B0179 B4    0171** SOPTBL:			DW24	SLE			; <= (STRING)
0B017A 05 
0B017B 0B 
0B017C BD    0172** DW24	SNE			; <>
0B017D 05 
0B017E 0B 
0B017F AD    0173** DW24	SGE			; >=
0B0180 05 
0B0181 0B 
0B0182 9E    0174** DW24	SLT			; <
0B0183 05 
0B0184 0B 
0B0185 C4    0175** DW24	SEQ			; =
0B0186 05 
0B0187 0B 
0B0188 A5    0176** DW24	SGT			; >
0B0189 05 
0B018A 0B 
             0177** ;
             0178** ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
             0179** ;     Expression type is returned in A'F':
             0180** ;        Numeric - A' bit 7=0, F' sign bit cleared.
             0181** ;         String - A' bit 7=1, F' sign bit set.
             0182** ; Floating-point or integer result returned in HLH'L'C
             0183** ; Integer result denoted by C=0 and HLH'L' non-zero.
             0184** ; String result returned in string accumulator, DE set.
             0185** ;
             0186** ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
             0187** ;               (2) ^
             0188** ;               (3) * / MOD DIV
             0189** ;               (4) + -
             0190** ;               (5) = <> <= >= > <
             0191** ;               (6) AND
             0192** ;               (7) EOR OR
             0193** 
             0194** ;
             0195** ; Level 7: EOR and OR
             0196** ;
0B018B CD    0197** EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0B018C A4 
0B018D 01 
0B018E 0B 
0B018F FE    0198** EXPR0A:			CP      EORK            	; Is operator EOR?
0B0190 82 
0B0191 28    0199** JR      Z,EXPR0B		; Yes, so skip to next bit
0B0192 03 
0B0193 FE    0200** CP      ORK			; Is operator OR
0B0194 84 
0B0195 C0    0201** RET     NZ			; No, so return
             0202** ;
0B0196 CD    0203** EXPR0B:			CALL    SAVE_EV            	; Save first operand
0B0197 02 
0B0198 0A 
0B0199 0B 
0B019A CD    0204** CALL    EXPR1           	; Get second operand
0B019B A4 
0B019C 01 
0B019D 0B 
0B019E CD    0205** CALL    DOIT            	; Do the operation
0B019F 11 
0B01A0 0A 
0B01A1 0B 
0B01A2 18    0206** JR      EXPR0A          	; And continue
0B01A3 EB 
             0207** ;
             0208** ; Level 6: AND
             0209** ;
0B01A4 CD    0210** EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0B01A5 B9 
0B01A6 01 
0B01A7 0B 
0B01A8 FE    0211** EXPR1A:			CP      ANDK			; Is operator AND?
0B01A9 80 
0B01AA C0    0212** RET     NZ			; No, so return
0B01AB CD    0213** CALL    SAVE_EV			; Save first operand
0B01AC 02 
0B01AD 0A 
0B01AE 0B 
0B01AF CD    0214** CALL    EXPR2			; Get second operand
0B01B0 B9 
0B01B1 01 
0B01B2 0B 
0B01B3 CD    0215** CALL    DOIT			; Do the operation
0B01B4 11 
0B01B5 0A 
0B01B6 0B 
0B01B7 18    0216** JR      EXPR1A			; And continue
0B01B8 EF 
             0217** ;
             0218** ; Level 5: Comparisons
             0219** ;
0B01B9 CD    0220** EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0B01BA 2B 
0B01BB 02 
0B01BC 0B 
0B01BD CD    0221** CALL    RELOP?			; Is it ">", "=" or "<"?
0B01BE D9 
0B01BF 09 
0B01C0 0B 
0B01C1 C0    0222** RET     NZ			; No, so return
0B01C2 47    0223** LD      B,A			; Store the first operator in B
0B01C3 FD    0224** INC     IY              	; Bump over operator
0B01C4 23 
0B01C5 CD    0225** CALL    NXT			;
0B01C6 34 
0B01C7 0A 
0B01C8 0B 
0B01C9 CD    0226** CALL    RELOP?          	; Is it a compound operator?
0B01CA D9 
0B01CB 09 
0B01CC 0B 
0B01CD 20    0227** JR      NZ,EXPR2B		; No, so skip next bit
0B01CE 09 
0B01CF FD    0228** INC     IY			; Bump over operator
0B01D0 23 
0B01D1 B8    0229** CP      B			; Compare with first
0B01D2 CA    0230** JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
0B01D3 5B 
0B01D4 0C 
0B01D5 0B 
0B01D6 80    0231** ADD     A,B
0B01D7 47    0232** LD      B,A			; B: Unique code for the compound operator
0B01D8 78    0233** EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
0B01D9 08    0234** EX      AF,AF'
0B01DA FA    0235** JP      M,EXPR2S		; If it is a string, then branch here to handle it
0B01DB F4 
0B01DC 01 
0B01DD 0B 
0B01DE 08    0236** EX      AF,AF'
0B01DF D6    0237** SUB     4
0B01E0 04 
0B01E1 FE    0238** CP      '>'-4
0B01E2 3A 
0B01E3 20    0239** JR      NZ,EXPR2C
0B01E4 02 
0B01E5 C6    0240** ADD     A,2
0B01E6 02 
0B01E7 CD    0241** EXPR2C:			CALL    SAVE1
0B01E8 04 
0B01E9 0A 
0B01EA 0B 
0B01EB CD    0242** CALL    EXPR3
0B01EC 2B 
0B01ED 02 
0B01EE 0B 
0B01EF CD    0243** CALL    DOIT            	; NB: Must NOT be "JP DOIT"
0B01F0 11 
0B01F1 0A 
0B01F2 0B 
0B01F3 C9    0244** RET
             0245** ;
0B01F4 08    0246** EXPR2S:			EX      AF,AF'			; Handle string comparisons
0B01F5 3D    0247** DEC     A
0B01F6 E6    0248** AND     7
0B01F7 07 
0B01F8 CD    0249** CALL    PUSHS           	; Save string on the stack
0B01F9 78 
0B01FA 09 
0B01FB 0B 
0B01FC F5    0250** PUSH    AF              	; Save the operator
0B01FD CD    0251** CALL    EXPR3           	; Get the second string
0B01FE 2B 
0B01FF 02 
0B0200 0B 
0B0201 08    0252** EX      AF,AF'
0B0202 F2    0253** JP      P,TYPE_EV_
0B0203 FA 
0B0204 02 
0B0205 0B 
0B0206 F1    0254** POP     AF
0B0207 4B    0255** LD      C,E             	; Length of string #2
0B0208 D1    0256** POP     DE
0B0209 21    0257** LD      HL,0
0B020A 00 
0B020B 00 
0B020C 00 
0B020D 39    0258** ADD     HL,SP
0B020E 43    0259** LD      B,E             	; Length of string #1
0B020F D5    0260** PUSH    DE
0B0210 11    0261** LD      DE,ACCS
0B0211 00 
0B0212 5B 
0B0213 0B 
0B0214 EB    0262** EX      DE,HL
0B0215 CD    0263** CALL    DISPT2
0B0216 40 
0B0217 0A 
0B0218 0B 
0B0219 D1    0264** POP     DE
0B021A EB    0265** EX      DE,HL
0B021B 7D    0266** LD	A,L
0B021C 21    0267** LD	HL,0
0B021D 00 
0B021E 00 
0B021F 00 
0B0220 6F    0268** LD	L,A
0B0221 39    0269** ADD     HL,SP
0B0222 F9    0270** LD      SP,HL
0B0223 EB    0271** EX      DE,HL
0B0224 AF    0272** XOR     A               	; Numeric marker
0B0225 4F    0273** LD      C,A             	; Integer marker
0B0226 08    0274** EX      AF,AF'
0B0227 FD    0275** LD      A,(IY)
0B0228 7E 
0B0229 00 
0B022A C9    0276** RET
             0277** ;
             0278** ; Level 4: + and -
             0279** ;
0B022B CD    0280** EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
0B022C 88 
0B022D 02 
0B022E 0B 
0B022F FE    0281** EXPR3A:			CP      '-'			; Is it "-"?
0B0230 2D 
0B0231 28    0282** JR      Z,EXPR3B		; Yes, so skip the next bit
0B0232 09 
0B0233 FE    0283** CP      '+'			; Is it "+"?
0B0234 2B 
0B0235 C0    0284** RET     NZ			; No, so return
0B0236 08    0285** EX      AF,AF'			; Get the type
0B0237 FA    0286** JP      M,EXPR3S		; Branch here if string
0B0238 4A 
0B0239 02 
0B023A 0B 
0B023B 08    0287** EX      AF,AF'
0B023C CD    0288** EXPR3B:			CALL    SAVE_EV			; Save the first operator
0B023D 02 
0B023E 0A 
0B023F 0B 
0B0240 CD    0289** CALL    EXPR4			; Fetch the second operator
0B0241 88 
0B0242 02 
0B0243 0B 
0B0244 CD    0290** CALL    DOIT			; Do the operation
0B0245 11 
0B0246 0A 
0B0247 0B 
0B0248 18    0291** JR      EXPR3A			; And continue
0B0249 E5 
             0292** ;
0B024A 08    0293** EXPR3S:			EX      AF,AF'			; Handle string concatenation
0B024B FD    0294** INC     IY              	; Bump past the "+"
0B024C 23 
0B024D CD    0295** CALL    PUSHS           	; Save the string on the stack
0B024E 78 
0B024F 09 
0B0250 0B 
0B0251 CD    0296** CALL    EXPR4           	; Fetch the second operator
0B0252 88 
0B0253 02 
0B0254 0B 
0B0255 08    0297** EX      AF,AF'
0B0256 F2    0298** JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0B0257 FA 
0B0258 02 
0B0259 0B 
0B025A 01    0299** LD	BC, 0			; Clear BC
0B025B 00 
0B025C 00 
0B025D 00 
0B025E 4B    0300** LD      C,E             	; C: Length of the second string
0B025F D1    0301** POP     DE
0B0260 D5    0302** PUSH    DE
0B0261 21    0303** LD      HL,ACCS
0B0262 00 
0B0263 5B 
0B0264 0B 
             0304** ; BEGIN MISSING FROM BINARY
             0305** ; LD	A,E			;  E: Length of the first string
             0306** ; LD      DE,ACCS
             0307** ; LD	E,A 			; DE: Pointer to the end of the first string
             0308** ; END MISSING FROM BINARY
0B0265 54    0309** LD		D,H ; ADDED FROM BINARY
0B0266 79    0310** LD      A,C
0B0267 B7    0311** OR      A
0B0268 28    0312** JR      Z,EXP3S3
0B0269 0F 
0B026A 6F    0313** LD      L,A             	; Source
0B026B 83    0314** ADD     A,E
0B026C 5F    0315** LD      E,A             	; Destination
0B026D 3E    0316** LD      A,19
0B026E 13 
0B026F DA    0317** JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0B0270 24 
0B0271 37 
0B0272 0B 
0B0273 D5    0318** PUSH    DE
0B0274 1D    0319** DEC     E
0B0275 2D    0320** DEC     L
0B0276 ED    0321** LDDR                    	; Copy
0B0277 B8 
0B0278 D1    0322** POP     DE
0B0279 D9    0323** EXP3S3:			EXX
0B027A C1    0324** POP     BC
0B027B CD    0325** CALL    POPS            	; Restore from stack
0B027C A2 
0B027D 09 
0B027E 0B 
0B027F D9    0326** EXX
0B0280 F6    0327** OR      80H             	; Flag as a string
0B0281 80 
0B0282 08    0328** EX      AF,AF'
0B0283 FD    0329** LD      A,(IY)			; Fetch the next character
0B0284 7E 
0B0285 00 
0B0286 18    0330** JR      EXPR3A			; And continue
0B0287 A7 
             0331** ;
             0332** ; Level 3: * / MOD DIV
             0333** ;
0B0288 CD    0334** EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0B0289 A9 
0B028A 02 
0B028B 0B 
0B028C FE    0335** EXPR4A:			CP      '*'			; "*" is valid
0B028D 2A 
0B028E 28    0336** JR      Z,EXPR4B
0B028F 0B 
0B0290 FE    0337** CP      '/'			; "/" is valid
0B0291 2F 
0B0292 28    0338** JR      Z,EXPR4B
0B0293 07 
0B0294 FE    0339** CP      MODK			; MOD token is valid
0B0295 83 
0B0296 28    0340** JR      Z,EXPR4B
0B0297 03 
0B0298 FE    0341** CP      DIVK			; DIV token is valid
0B0299 81 
0B029A C0    0342** RET     NZ			; And return if it is anything else
0B029B CD    0343** EXPR4B:			CALL    SAVE_EV
0B029C 02 
0B029D 0A 
0B029E 0B 
0B029F CD    0344** CALL    EXPR5
0B02A0 A9 
0B02A1 02 
0B02A2 0B 
0B02A3 CD    0345** CALL    DOIT
0B02A4 11 
0B02A5 0A 
0B02A6 0B 
0B02A7 18    0346** JR      EXPR4A
0B02A8 E3 
             0347** ;
             0348** ; Level 2: ^
             0349** ;
0B02A9 CD    0350** EXPR5:			CALL    ITEM			; Get variable
0B02AA 89 
0B02AB 03 
0B02AC 0B 
0B02AD B7    0351** OR      A               	; Test type
0B02AE 08    0352** EX      AF,AF'          	; Save type
0B02AF CD    0353** EXPR5A:			CALL    NXT			; Skip spaces
0B02B0 34 
0B02B1 0A 
0B02B2 0B 
0B02B3 FE    0354** CP      '^'			; Is the operator "^"?
0B02B4 5E 
0B02B5 C0    0355** RET     NZ			; No, so return
0B02B6 CD    0356** CALL    SAVE_EV			; Save first operand
0B02B7 02 
0B02B8 0A 
0B02B9 0B 
0B02BA CD    0357** CALL    ITEM			; Get second operand
0B02BB 89 
0B02BC 03 
0B02BD 0B 
0B02BE B7    0358** OR      A			; Test type
0B02BF 08    0359** EX      AF,AF'			; Save type
0B02C0 CD    0360** CALL    DOIT			; Do the operation
0B02C1 11 
0B02C2 0A 
0B02C3 0B 
0B02C4 18    0361** JR      EXPR5A			; And continue
0B02C5 E9 
             0362** ;
             0363** ; Evaluate a numeric expression
             0364** ;
0B02C6 CD    0365** EXPRN:			CALL    EXPR			; Evaluate expression
0B02C7 8B 
0B02C8 01 
0B02C9 0B 
0B02CA 08    0366** EX      AF,AF'			; Get the type
0B02CB F0    0367** RET     P			; And return if it is a number
0B02CC 18    0368** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02CD 2C 
             0369** ;
             0370** ; Evaluate a fixed-point expression
             0371** ;
0B02CE CD    0372** EXPRI:			CALL    EXPR			; Evaluate the expression
0B02CF 8B 
0B02D0 01 
0B02D1 0B 
0B02D2 08    0373** EX      AF,AF'			; Get the type
0B02D3 F2    0374** JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B02D4 26 
0B02D5 06 
0B02D6 0B 
0B02D7 18    0375** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02D8 21 
             0376** ;
             0377** ; Evaluate a string expression
             0378** ;
0B02D9 CD    0379** EXPRS:			CALL    EXPR			; Evaluate the expression
0B02DA 8B 
0B02DB 01 
0B02DC 0B 
0B02DD 08    0380** EX      AF,AF'			; Get the type
0B02DE F8    0381** RET     M			; And return if it is a string
0B02DF 18    0382** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02E0 19 
             0383** ;
             0384** ; Get a numeric variable
             0385** ;
0B02E1 CD    0386** ITEMN:			CALL    ITEM			; Get the variable
0B02E2 89 
0B02E3 03 
0B02E4 0B 
0B02E5 B7    0387** OR      A			; Test the type
0B02E6 F0    0388** RET     P			; And return if it is a number
0B02E7 18    0389** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02E8 11 
             0390** ;
             0391** ; Get a fixed-point variable
             0392** ;
0B02E9 CD    0393** ITEMI:			CALL    ITEM			; Get the variable
0B02EA 89 
0B02EB 03 
0B02EC 0B 
0B02ED B7    0394** OR      A			; Test the type
0B02EE F2    0395** JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B02EF 26 
0B02F0 06 
0B02F1 0B 
0B02F2 18    0396** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02F3 06 
             0397** ;
             0398** ; Get a string variable
             0399** ;
0B02F4 CD    0400** ITEMS:			CALL    ITEM			; Get the variable
0B02F5 89 
0B02F6 03 
0B02F7 0B 
0B02F8 B7    0401** OR      A			; Test the type
0B02F9 F8    0402** RET     M			; If it is a string, then return
             0403** ;							; Otherwise
0B02FA 3E    0404** TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
0B02FB 06 
0B02FC C3    0405** JP      ERROR_
0B02FD 24 
0B02FE 37 
0B02FF 0B 
             0406** ;
             0407** ; Evaluate a bracketed expression
             0408** ;
0B0300 CD    0409** ITEM1:			CALL    EXPR            	; Evaluate the expression
0B0301 8B 
0B0302 01 
0B0303 0B 
0B0304 CD    0410** CALL    BRAKET			; Check for closing bracket
0B0305 F3 
0B0306 09 
0B0307 0B 
0B0308 08    0411** EX      AF,AF'
0B0309 C9    0412** RET
             0413** ;
             0414** ; HEX - Get hexadecimal constant.
             0415** ;   Inputs: ASCII string at (IY)
             0416** ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
             0417** ;           IY updated (points to delimiter)
             0418** ;
0B030A CD    0419** HEX:			CALL    ZERO			; Set result to 0
0B030B 57 
0B030C 09 
0B030D 0B 
0B030E CD    0420** CALL    HEXDIG			; Fetch the character from IY
0B030F BC 
0B0310 09 
0B0311 0B 
0B0312 38    0421** JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
0B0313 1B 
0B0314 FD    0422** HEX1:			INC     IY			; Move pointer to next character
0B0315 23 
0B0316 E6    0423** AND     0FH			; Clear the top nibble
0B0317 0F 
0B0318 06    0424** LD      B,4			; Loop counter
0B0319 04 
             0425** ;
0B031A D9    0426** HEX2:			EXX				; Shift the result left B (4) times. This makes
0B031B 52    0427** ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
0B031C 29 
0B031D D9    0428** EXX				; .
0B031E 52    0429** ADC.S   HL,HL			; .
0B031F ED 
0B0320 6A 
0B0321 10    0430** DJNZ    HEX2			; And loop
0B0322 F7 
0B0323 D9    0431** EXX
0B0324 B5    0432** OR      L			; OR in the digit
0B0325 6F    0433** LD      L,A
0B0326 D9    0434** EXX
             0435** ;
0B0327 CD    0436** CALL    HEXDIG			; Fetch the next character
0B0328 BC 
0B0329 09 
0B032A 0B 
0B032B 30    0437** JR      NC,HEX1			; If it is a HEX digit then loop
0B032C E7 
0B032D AF    0438** XOR     A			; Clear A
0B032E C9    0439** RET
             0440** ;
0B032F 3E    0441** BADHEX:			LD      A,28
0B0330 1C 
0B0331 C3    0442** JP      ERROR_          	; Error: "Bad HEX"
0B0332 24 
0B0333 37 
0B0334 0B 
             0443** ;
             0444** ; BIN - Get binary constant.
             0445** ;   Inputs: ASCII string at (IY)
             0446** ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
             0447** ;           IY updated (points to delimiter)
             0448** ;
0B0335 CD    0449** BIN:			CALL    ZERO			; Set result to 0
0B0336 57 
0B0337 09 
0B0338 0B 
0B0339 CD    0450** CALL	BINDIG			; Fetch the character from IY
0B033A CF 
0B033B 09 
0B033C 0B 
0B033D 38    0451** JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
0B033E 13 
0B033F FD    0452** BIN1:			INC	IY			; Move pointer to next character
0B0340 23 
0B0341 0F    0453** RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
0B0342 D9    0454** EXX				;
0B0343 52    0455** ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
0B0344 ED 
0B0345 6A 
0B0346 D9    0456** EXX
0B0347 52    0457** ADC.S	HL,HL
0B0348 ED 
0B0349 6A 
0B034A CD    0458** CALL	BINDIG			; Fetch the next character
0B034B CF 
0B034C 09 
0B034D 0B 
0B034E 30    0459** JR	NC,BIN1
0B034F EF 
0B0350 AF    0460** XOR	A			; Clear A
0B0351 C9    0461** RET
             0462** ;
0B0352 3E    0463** BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0B0353 1C 
0B0354 CD    0464** CALL	EXTERR
0B0355 3B 
0B0356 37 
0B0357 0B 
0B0358 42    0465** DB	"Bad Binary", 0
0B0359 61 
0B035A 64 
0B035B 20 
0B035B 42   
0B035C 69 
0B035D 6E 
0B035E 61 
0B035E 72   
0B035F 79 
0B0360 00 
             0466** ;
             0467** ; MINUS - Unary minus.
             0468** ;   Inputs: IY = text pointer
             0469** ;  Outputs: Numeric result, same type as argument.
             0470** ;           Result in H'L'HLC
             0471** ;
0B0363 CD    0472** MINUS:			CALL    ITEMN			; Get the numeric argument
0B0364 E1 
0B0365 02 
0B0366 0B 
0B0367 0D    0473** MINUS0:			DEC     C			; Check exponent (C)
0B0368 0C    0474** INC     C			; If it is zero, then it's either a FP zero or an integer
0B0369 28    0475** JR      Z,NEGATE_EV        	; So do an integer negation
0B036A 06 
             0476** ;
0B036B 7C    0477** LD      A,H			; Do a FP negation by
0B036C EE    0478** XOR     80H             	; Toggling the sign bit (H)
0B036D 80 
0B036E 67    0479** LD      H,A
0B036F AF    0480** XOR     A               	; Numeric marker
0B0370 C9    0481** RET
             0482** ;
0B0371 D9    0483** NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0B0372 7C    0484** LD      A,H			; First do a one's complement by negating all the bytes
0B0373 2F    0485** CPL
0B0374 67    0486** LD      H,A
0B0375 7D    0487** LD      A,L
0B0376 2F    0488** CPL
0B0377 6F    0489** LD      L,A
0B0378 D9    0490** EXX
0B0379 7C    0491** LD      A,H
0B037A 2F    0492** CPL
0B037B 67    0493** LD      H,A
0B037C 7D    0494** LD      A,L
0B037D 2F    0495** CPL
0B037E 6F    0496** LD      L,A
0B037F D9    0497** ADD1:			EXX				; Then add 1
0B0380 23    0498** INC     HL
0B0381 7C    0499** LD      A,H
0B0382 B5    0500** OR      L
0B0383 D9    0501** EXX
0B0384 3E    0502** LD      A,0             	; Numeric marker
0B0385 00 
0B0386 C0    0503** RET     NZ
0B0387 23    0504** INC     HL
0B0388 C9    0505** RET
             0506** ;
             0507** ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
             0508** ; Item type is returned in A:  Bit 7=0 numeric.
             0509** ;                              Bit 7=1 string.
             0510** ; Numeric item returned in HLH'L'C.
             0511** ; String item returned in string accumulator,
             0512** ;   DE addresses byte after last (E=length).
             0513** ;
0B0389 CD    0514** ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0B038A 13 
0B038B 16 
0B038C 0B 
0B038D CD    0515** CALL    NXT			; Skip spaces
0B038E 34 
0B038F 0A 
0B0390 0B 
0B0391 FD    0516** INC     IY			; Move to the prefix character
0B0392 23 
0B0393 FE    0517** CP      '&'			; If `&`
0B0394 26 
0B0395 CA    0518** JP      Z,HEX           	; Then get a HEX constant
0B0396 0A 
0B0397 03 
0B0398 0B 
0B0399 FE    0519** CP	'%'			; If '%'
0B039A 25 
0B039B 28    0520** JR	Z,BIN			; Then get a BINARY constant
0B039C 98 
0B039D FE    0521** CP      '-'			; If `-`
0B039E 2D 
0B039F 28    0522** JR      Z,MINUS         	; Then get a negative number
0B03A0 C2 
0B03A1 FE    0523** CP      '+'			; If `+`
0B03A2 2B 
0B03A3 CA    0524** JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0B03A4 E1 
0B03A5 02 
0B03A6 0B 
0B03A7 FE    0525** CP      '('			; If `(`
0B03A8 28 
0B03A9 CA    0526** JP      Z,ITEM1         	; Start of a bracketed expression
0B03AA 00 
0B03AB 03 
0B03AC 0B 
0B03AD FE    0527** CP      34			; If `"`
0B03AE 22 
0B03AF 28    0528** JR      Z,CONS          	; Start of a string constant
0B03B0 7A 
0B03B1 FE    0529** CP      TCMD_EV			; Is it out of range of the function table?
0B03B2 C6 
0B03B3 D2    0530** JP      NC,SYNTAX       	; Error: "Syntax Error"
0B03B4 5B 
0B03B5 0C 
0B03B6 0B 
0B03B7 FE    0531** CP      FUNTOK			; If it is in range, then
0B03B8 8D 
0B03B9 D2    0532** JP      NC,DISPAT       	; It's a function
0B03BA 47 
0B03BB 0A 
0B03BC 0B 
0B03BD FD    0533** DEC     IY
0B03BE 2B 
0B03BF FE    0534** CP      ':'
0B03C0 3A 
0B03C1 30    0535** JR      NC,ITEM2		; VARIABLE?
0B03C2 0C 
0B03C3 FE    0536** CP      '0'
0B03C4 30 
0B03C5 D2    0537** JP      NC,CON			; NUMERIC CONSTANT
0B03C6 52 
0B03C7 04 
0B03C8 0B 
0B03C9 FE    0538** CP      '.'
0B03CA 2E 
0B03CB CA    0539** JP      Z,CON			; NUMERIC CONSTANT
0B03CC 52 
0B03CD 04 
0B03CE 0B 
0B03CF CD    0540** ITEM2:			CALL    GETVAR			; VARIABLE
0B03D0 FE 
0B03D1 39 
0B03D2 0B 
0B03D3 20    0541** JR      NZ,NOSUCH
0B03D4 37 
0B03D5 B7    0542** OR      A
0B03D6 FA    0543** JP      M,LOADS			; STRING VARIABLE
0B03D7 64 
0B03D8 04 
0B03D9 0B 
0B03DA B7    0544** LOADN:			OR      A
0B03DB 28    0545** JR      Z,LOAD1			; BYTE VARIABLE
0B03DC 20 
0B03DD 0E    0546** LD      C,0
0B03DE 00 
0B03DF CB    0547** BIT     0,A
0B03E0 47 
0B03E1 28    0548** JR      Z,LOAD4			; INTEGER VARIABLE
0B03E2 03 
0B03E3 DD    0549** LOAD5:			LD      C,(IX+4)
0B03E4 4E 
0B03E5 04 
0B03E6 D9    0550** LOAD4:			EXX
0B03E7 21    0551** LD	HL, 0			; TODO: Optimise
0B03E8 00 
0B03E9 00 
0B03EA 00 
0B03EB DD    0552** LD      L,(IX+0)
0B03EC 6E 
0B03ED 00 
0B03EE DD    0553** LD      H,(IX+1)
0B03EF 66 
0B03F0 01 
0B03F1 D9    0554** EXX
0B03F2 21    0555** LD	HL, 0			; TODO: Optimise
0B03F3 00 
0B03F4 00 
0B03F5 00 
0B03F6 DD    0556** LD      L,(IX+2)
0B03F7 6E 
0B03F8 02 
0B03F9 DD    0557** LD      H,(IX+3)
0B03FA 66 
0B03FB 03 
0B03FC C9    0558** RET
             0559** ;
0B03FD 21    0560** LOAD1:			LD      HL,0
0B03FE 00 
0B03FF 00 
0B0400 00 
0B0401 D9    0561** EXX
0B0402 21    0562** LD      HL,0			; TODO: Optimise
0B0403 00 
0B0404 00 
0B0405 00 
0B0406 DD    0563** LD      L,(IX+0)
0B0407 6E 
0B0408 00 
0B0409 D9    0564** EXX
0B040A 4C    0565** LD      C,H
0B040B C9    0566** RET
             0567** ;
0B040C DA    0568** NOSUCH:			JP      C,SYNTAX
0B040D 5B 
0B040E 0C 
0B040F 0B 
0B0410 3A    0569** LD      A,(LISTON)
0B0411 40 
0B0412 5E 
0B0413 0B 
0B0414 CB    0570** BIT     5,A
0B0415 6F 
0B0416 3E    0571** LD      A,26
0B0417 1A 
0B0418 20    0572** JR      NZ,ERROR0_EV		; Throw "No such variable"
0B0419 26 
0B041A FD    0573** NOS1:			INC     IY
0B041B 23 
0B041C CD    0574** CALL    RANGE
0B041D 33 
0B041E 3C 
0B041F 0B 
0B0420 30    0575** JR      NC,NOS1
0B0421 F8 
0B0422 DD    0576** LD      IX,PC
0B0423 21 
0B0424 40 
0B0425 5D 
0B0425 0B   
0B0427 AF    0577** XOR     A
0B0428 4F    0578** LD      C,A
0B0429 18    0579** JR      LOAD4
0B042A BB 
             0580** ;
             0581** ;CONS - Get string constant from ASCII string.
             0582** ;   Inputs: ASCII string at (IY)
             0583** ;  Outputs: Result in string accumulator.
             0584** ;           D = MS byte of ACCS, E = string length
             0585** ;           A7 = 1 (string marker)
             0586** ;           IY updated
             0587** ;
0B042B 11    0588** CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
0B042C 00 
0B042D 5B 
0B042E 0B 
0B042F FD    0589** CONS3:			LD      A,(IY)			; Fetch the first character and
0B0430 7E 
0B0431 00 
0B0432 FD    0590** INC     IY			; Increment the pointer
0B0433 23 
0B0434 FE    0591** CP      '"'			; Check for start quote
0B0435 22 
0B0436 28    0592** JR      Z,CONS2			; Yes, so jump to the bit that parses the string
0B0437 0C 
             0593** ;
0B0438 12    0594** CONS1:			LD      (DE),A			; Store the character in the string accumulator
0B0439 1C    0595** INC     E			; Increment the string accumulator pointer
0B043A FE    0596** CP      CR			; Is it CR
0B043B 0D 
0B043C 20    0597** JR      NZ,CONS3		; No, so keep looping
0B043D F1 
             0598** ;
0B043E 3E    0599** LD      A,9
0B043F 09 
0B0440 C3    0600** ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
0B0441 24 
0B0442 37 
0B0443 0B 
             0601** ;
0B0444 FD    0602** CONS2:			LD      A,(IY)			; Fetch the next character
0B0445 7E 
0B0446 00 
0B0447 FE    0603** CP      '"'			; Check for end quote?
0B0448 22 
0B0449 FD    0604** INC     IY			; Increment the pointer
0B044A 23 
0B044B 28    0605** JR      Z,CONS1			; It is the end of string marker so jump to the end routine
0B044C EB 
0B044D FD    0606** DEC     IY			;
0B044E 2B 
0B044F 3E    0607** LD      A,80H           	; String marker
0B0450 80 
0B0451 C9    0608** RET
             0609** ;
             0610** ;CON - Get unsigned numeric constant from ASCII string.
             0611** ;   Inputs: ASCII string at (IY).
             0612** ;  Outputs: Variable-type result in HLH'L'C
             0613** ;           IY updated (points to delimiter)
             0614** ;           A7 = 0 (numeric marker)
             0615** ;
0B0452 FD    0616** CON:			PUSH    IY
0B0453 E5 
0B0454 DD    0617** POP     IX
0B0455 E1 
0B0456 3E    0618** LD      A,36
0B0457 24 
0B0458 CD    0619** CALL    FPP
0B0459 2E 
0B045A 20 
0B045B 0B 
0B045C 38    0620** JR      C,ERROR0_EV
0B045D E2 
0B045E DD    0621** PUSH    IX
0B045F E5 
0B0460 FD    0622** POP     IY
0B0461 E1 
0B0462 AF    0623** XOR     A
0B0463 C9    0624** RET
             0625** ;
0B0464 11    0626** LOADS:			LD      DE,ACCS			; Where to store the string
0B0465 00 
0B0466 5B 
0B0467 0B 
0B0468 1F    0627** RRA
0B0469 30    0628** JR      NC,LOADS2       	; Skip if it is a fixed string
0B046A 1A 
             0629** ;
0B046B D9    0630** EXX				; This block was a call to LOAD4
0B046C DD    0631** LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B046D 6E 
0B046E 00 
0B046F DD    0632** LD      H,(IX+1)		; The maximum original string length
0B0470 66 
0B0471 01 
0B0472 D9    0633** EXX
0B0473 DD    0634** LD	HL,(IX+2)		; Address of the string (24-bit)
0B0474 27 
0B0475 02 
             0635** ;
0B0476 D9    0636** EXX
0B0477 7D    0637** LD      A,L
0B0478 D9    0638** EXX
0B0479 B7    0639** OR      A
0B047A 01    0640** LD	BC,0			; BC: Number of bytes to copy
0B047B 00 
0B047C 00 
0B047D 00 
0B047E 4F    0641** LD      C,A
0B047F 3E    0642** LD      A,80H           	; String marker
0B0480 80 
0B0481 C8    0643** RET     Z
0B0482 ED    0644** LDIR
0B0483 B0 
0B0484 C9    0645** RET
0B0485 7E    0646** LOADS2:			LD      A,(HL)
0B0486 12    0647** LD      (DE),A
0B0487 23    0648** INC     HL
0B0488 FE    0649** CP      CR
0B0489 0D 
0B048A 3E    0650** LD      A,80H           	; String marker
0B048B 80 
0B048C C8    0651** RET     Z
0B048D 1C    0652** INC     E
0B048E 20    0653** JR      NZ,LOADS2
0B048F F5 
0B0490 C9    0654** RET                     	; Return null string
             0655** ;
             0656** ;VARIABLE-TYPE FUNCTIONS:
             0657** ;
             0658** ;Result returned in HLH'L'C (floating point)
             0659** ;Result returned in HLH'L' (C=0) (integer)
             0660** ;Result returned in string accumulator & DE (string)
             0661** ;All registers destroyed.
             0662** ;IY (text pointer) updated.
             0663** ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
             0664** ;
             0665** ;POS - horizontal cursor position.
             0666** ;VPOS - vertical cursor position.
             0667** ;EOF - return status of file.
             0668** ;BGET - read byte from file.
             0669** ;INKEY - as GET but wait only n centiseconds.
             0670** ;GET - wait for keypress and return ASCII value.
             0671** ;GET(n) - input from Z80 port n.
             0672** ;ASC - ASCII value of string.
             0673** ;LEN - length of string.
             0674** ;LOMEM - location of dynamic variables.
             0675** ;HIMEM - top of available RAM.
             0676** ;PAGE - start of current text page.
             0677** ;TOP - address of first free byte after program.
             0678** ;ERL - line number where last error occurred.
             0679** ;ERR - number of last error.
             0680** ;COUNT - number of printing characters since CR.
             0681** ;Results are integer numeric.
             0682** ;
0B0491 CD    0683** POS:			CALL    GETCSR			; Return the horizontal cursor position
0B0492 90 
0B0493 3E 
0B0494 0B 
0B0495 EB    0684** EX      DE,HL			;  L: The X cursor position
0B0496 C3    0685** JP      COUNT1			; Return an 8-bit value
0B0497 45 
0B0498 05 
0B0499 0B 
             0686** ;
0B049A CD    0687** VPOS:			CALL    GETCSR			; Return the vertical cursor position
0B049B 90 
0B049C 3E 
0B049D 0B 
0B049E C3    0688** JP      COUNT1			; Return an 8-bit value
0B049F 45 
0B04A0 05 
0B04A1 0B 
             0689** ;
0B04A2 CD    0690** EOF:			CALL    CHANEL			; Check for EOF
0B04A3 4A 
0B04A4 18 
0B04A5 0B 
0B04A6 CD    0691** CALL    OSSTAT
0B04A7 08 
0B04A8 43 
0B04A9 0B 
0B04AA CA    0692** JP      Z,TRUE			; Yes, so return true
0B04AB C9 
0B04AC 05 
0B04AD 0B 
0B04AE C3    0693** JP      ZERO			; Otherwise return false (zero)
0B04AF 57 
0B04B0 09 
0B04B1 0B 
             0694** ;
0B04B2 CD    0695** BGET:			CALL    CHANEL          	; Channel number
0B04B3 4A 
0B04B4 18 
0B04B5 0B 
0B04B6 CD    0696** CALL    OSBGET
0B04B7 F7 
0B04B8 42 
0B04B9 0B 
0B04BA 6F    0697** LD      L,A
0B04BB C3    0698** JP      COUNT0			; Return an 8-bit value
0B04BC 43 
0B04BD 05 
0B04BE 0B 
             0699** ;
0B04BF CD    0700** INKEY:			CALL    ITEMI			; Get the argument
0B04C0 E9 
0B04C1 02 
0B04C2 0B 
0B04C3 CB    0701** BIT	7, H			; Check the sign
0B04C4 7C 
0B04C5 D9    0702** EXX				; HL: The argument
0B04C6 C2    0703** JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
0B04C7 AF 
0B04C8 07 
0B04C9 0B 
0B04CA CD    0704** CALL	INKEY0 			; Do INKEY(n)
0B04CB A1 
0B04CC 07 
0B04CD 0B 
0B04CE 18    0705** JR      ASC0			; Return a numeric value
0B04CF 1D 
             0706** ;
0B04D0 CD    0707** GET:			CALL    NXT			; Skip whitespace
0B04D1 34 
0B04D2 0A 
0B04D3 0B 
0B04D4 FE    0708** CP      '('			; Is it GET(
0B04D5 28 
0B04D6 20    0709** JR      NZ,GET0			; No, so get a keyboard character
0B04D7 0B 
0B04D8 CD    0710** CALL    ITEMI           	; Yes, so fetch the port address
0B04D9 E9 
0B04DA 02 
0B04DB 0B 
0B04DC D9    0711** EXX
0B04DD 44    0712** LD      B,H			; BC: The port address
0B04DE 4D    0713** LD      C,L
0B04DF ED    0714** IN      L,(C)           	;  L: Input from port BC
0B04E0 68 
0B04E1 18    0715** JR      COUNT0			; Return an 8-bit value
0B04E2 60 
             0716** ;
0B04E3 CD    0717** GET0:			CALL    GETS			; Read the keyboard character
0B04E4 8B 
0B04E5 07 
0B04E6 0B 
0B04E7 18    0718** JR      ASC1			; And return the value
0B04E8 0A 
             0719** ;
0B04E9 CD    0720** ASC:			CALL    ITEMS			; Get the string argument argument
0B04EA F4 
0B04EB 02 
0B04EC 0B 
0B04ED AF    0721** ASC0:			XOR     A			; Quickly check the length of the string in ACCS
0B04EE BB    0722** CP      E			; Is the pointer 0
0B04EF CA    0723** JP      Z,TRUE          	; Yes, so return -1 as it is a null string
0B04F0 C9 
0B04F1 05 
0B04F2 0B 
0B04F3 2A    0724** ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
0B04F4 00 
0B04F5 5B 
0B04F6 0B 
0B04F7 18    0725** JR      COUNT0			; An 8-bit value
0B04F8 4A 
             0726** ;
0B04F9 CD    0727** LEN:			CALL    ITEMS			; Get the string argument
0B04FA F4 
0B04FB 02 
0B04FC 0B 
0B04FD EB    0728** EX      DE,HL			; HL: Pointer into ACCS
0B04FE 18    0729** JR      COUNT0			; Return L
0B04FF 43 
             0730** ;
0B0500 2A    0731** LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
0B0501 1A 
0B0502 5E 
0B0503 0B 
0B0504 3A    0732** LD	A, (LOMEM+2)
0B0505 1C 
0B0506 5E 
0B0507 0B 
0B0508 18    0733** JR      COUNT2			; A 24-bit value
0B0509 41 
             0734** ;
0B050A 2A    0735** HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
0B050B 20 
0B050C 5E 
0B050D 0B 
0B050E 3A    0736** LD	A, (HIMEM+2)
0B050F 22 
0B0510 5E 
0B0511 0B 
0B0512 18    0737** JR      COUNT2			; A 24-bit value
0B0513 37 
             0738** ;
0B0514 2A    0739** PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
0B0515 14 
0B0516 5E 
0B0517 0B 
0B0518 3A    0740** LD	A, (PAGE_+2)		; A 24-bit value
0B0519 16 
0B051A 5E 
0B051B 0B 
0B051C 18    0741** JR      COUNT2
0B051D 2D 
             0742** ;
0B051E FD    0743** TOPV:			LD      A,(IY)			; Return the TOP system variable
0B051F 7E 
0B0520 00 
0B0521 FD    0744** INC     IY              	; Skip "P"
0B0522 23 
0B0523 FE    0745** CP      'P'
0B0524 50 
0B0525 C2    0746** JP      NZ,SYNTAX       	; Throw "Syntax Error"
0B0526 5B 
0B0527 0C 
0B0528 0B 
0B0529 2A    0747** LD      HL,(TOP)
0B052A 17 
0B052B 5E 
0B052C 0B 
0B052D 3A    0748** LD	A, (TOP+2)
0B052E 19 
0B052F 5E 
0B0530 0B 
0B0531 18    0749** JR      COUNT2
0B0532 18 
             0750** ;
0B0533 2A    0751** ERLV:			LD      HL,(ERL)		; Return the error line
0B0534 33 
0B0535 5E 
0B0536 0B 
0B0537 18    0752** JR      COUNT1			; A 16-bit value
0B0538 0C 
             0753** ;
0B0539 2A    0754** ERRV:			LD      HL,(ERR)		; Return the error value
0B053A 3F 
0B053B 5E 
0B053C 0B 
0B053D 18    0755** JR      COUNT0			; An 8-bit value
0B053E 04 
             0756** ;
0B053F 2A    0757** COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
0B0540 3D 
0B0541 5E 
0B0542 0B 
             0758** 
0B0543 26    0759** COUNT0:			LD      H,0			; Return L
0B0544 00 
0B0545 D9    0760** COUNT1:			EXX				; Return HL
0B0546 AF    0761** XOR     A
0B0547 4F    0762** LD      C,A             	; Integer marker
0B0548 67    0763** LD      H,A
0B0549 6F    0764** LD      L,A
0B054A C9    0765** RET
0B054B D9    0766** COUNT2:			EXX
0B054C 6F    0767** LD	L,A
0B054D AF    0768** XOR	A
0B054E 4F    0769** LD	C,A			; Integer marker
0B054F 67    0770** LD	H,A
0B0550 C9    0771** RET
             0772** ;
             0773** ;OPENIN - Open a file for reading.
             0774** ;OPENOT - Open a file for writing.
             0775** ;OPENUP - Open a file for reading or writing.
             0776** ;Result is integer channel number (0 if error)
             0777** ;
0B0551 AF    0778** OPENOT:			XOR     A			; Open for writing
0B0552 18    0779** JR	OPENIN_1
0B0553 06 
             0780** ;
0B0554 3E    0781** OPENUP:			LD      A,2			; Open for reading / writing
0B0555 02 
0B0556 18    0782** JR	OPENIN_1
0B0557 02 
             0783** ;
0B0558 3E    0784** OPENIN:			LD      A,1			; Open for reading
0B0559 01 
             0785** ;
0B055A F5    0786** OPENIN_1:		PUSH    AF              	; Save OPEN type
0B055B CD    0787** CALL    ITEMS           	; Fetch the filename
0B055C F4 
0B055D 02 
0B055E 0B 
0B055F 3E    0788** LD      A,CR
0B0560 0D 
0B0561 12    0789** LD      (DE),A
0B0562 F1    0790** POP     AF              	; Restore the OPEN type
0B0563 C6    0791** ADD     A,-1            	; Affect the flags
0B0564 FF 
0B0565 21    0792** LD      HL,ACCS
0B0566 00 
0B0567 5B 
0B0568 0B 
0B0569 CD    0793** CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0B056A E0 
0B056B 42 
0B056C 0B 
0B056D 6F    0794** LD      L,A			; L: Channel number
0B056E 18    0795** JR      COUNT0			; Return channel number to BASIC
0B056F D3 
             0796** ;
             0797** ;EXT - Return length of file.
             0798** ;PTR_EV - Return current file pointer.
             0799** ;Results are integer numeric.
             0800** ;
0B0570 CD    0801** EXT:			CALL    CHANEL
0B0571 4A 
0B0572 18 
0B0573 0B 
0B0574 CD    0802** CALL    GETEXT
0B0575 3E 
0B0576 43 
0B0577 0B 
0B0578 18    0803** JR      TIME0
0B0579 15 
             0804** ;
0B057A CD    0805** PTR_EV:			CALL    CHANEL
0B057B 4A 
0B057C 18 
0B057D 0B 
0B057E CD    0806** CALL    GETPTR
0B057F 12 
0B0580 43 
0B0581 0B 
0B0582 18    0807** JR      TIME0
0B0583 0B 
             0808** ;
             0809** ;TIME - Return current value of elapsed time.
             0810** ;Result is integer numeric.
             0811** ;
0B0584 FD    0812** TIMEV:			LD      A,(IY)
0B0585 7E 
0B0586 00 
0B0587 FE    0813** CP      '$'
0B0588 24 
0B0589 28    0814** JR      Z,TIMEVS
0B058A 0A 
0B058B CD    0815** CALL    GETIME
0B058C 70 
0B058D 3E 
0B058E 0B 
0B058F D5    0816** TIME0:			PUSH    DE
0B0590 D9    0817** EXX
0B0591 E1    0818** POP     HL
0B0592 AF    0819** XOR     A
0B0593 4F    0820** LD      C,A
0B0594 C9    0821** RET
             0822** ;
             0823** ;TIME$ - Return date/time string.
             0824** ;Result is string
             0825** ;
0B0595 FD    0826** TIMEVS:			INC     IY              ;SKIP $
0B0596 23 
0B0597 CD    0827** CALL    GETIMS
0B0598 57 
0B0599 43 
0B059A 0B 
0B059B 3E    0828** LD      A,80H           ;MARK STRING
0B059C 80 
0B059D C9    0829** RET
             0830** ;
             0831** ;String comparison:
             0832** ;
0B059E CD    0833** SLT:			CALL    SCP
0B059F 53 
0B05A0 09 
0B05A1 0B 
0B05A2 D0    0834** RET     NC
0B05A3 18    0835** JR      TRUE
0B05A4 24 
             0836** ;
0B05A5 CD    0837** SGT:			CALL    SCP
0B05A6 53 
0B05A7 09 
0B05A8 0B 
0B05A9 C8    0838** RET     Z
0B05AA D8    0839** RET     C
0B05AB 18    0840** JR      TRUE
0B05AC 1C 
             0841** ;
0B05AD CD    0842** SGE:			CALL    SCP
0B05AE 53 
0B05AF 09 
0B05B0 0B 
0B05B1 D8    0843** RET     C
0B05B2 18    0844** JR      TRUE
0B05B3 15 
             0845** ;
0B05B4 CD    0846** SLE:			CALL    SCP
0B05B5 53 
0B05B6 09 
0B05B7 0B 
0B05B8 28    0847** JR      Z,TRUE
0B05B9 0F 
0B05BA D0    0848** RET     NC
0B05BB 18    0849** JR      TRUE
0B05BC 0C 
             0850** ;
0B05BD CD    0851** SNE:			CALL    SCP
0B05BE 53 
0B05BF 09 
0B05C0 0B 
0B05C1 C8    0852** RET     Z
0B05C2 18    0853** JR      TRUE
0B05C3 05 
             0854** ;
0B05C4 CD    0855** SEQ:			CALL    SCP
0B05C5 53 
0B05C6 09 
0B05C7 0B 
0B05C8 C0    0856** RET     NZ
0B05C9 3E    0857** TRUE:			LD      A,-1
0B05CA FF 
0B05CB D9    0858** EXX
0B05CC 67    0859** LD      H,A
0B05CD 6F    0860** LD      L,A
0B05CE D9    0861** EXX
0B05CF 67    0862** LD      H,A
0B05D0 6F    0863** LD      L,A
0B05D1 3C    0864** INC     A
0B05D2 4F    0865** LD      C,A
0B05D3 C9    0866** RET
             0867** ;
             0868** ;PI - Return PI (3.141592654)
             0869** ;Result is floating-point numeric.
             0870** ;
0B05D4 3E    0871** PI:			LD      A,35
0B05D5 23 
0B05D6 18    0872** JR      FPP1
0B05D7 44 
             0873** ;
             0874** ;ABS - Absolute value
             0875** ;Result is numeric, variable type.
             0876** ;
0B05D8 3E    0877** ABSV:			LD      A,16
0B05D9 10 
0B05DA 18    0878** JR      FPPN
0B05DB 3A 
             0879** ;
             0880** ;NOT - Complement integer.
             0881** ;Result is integer numeric.
             0882** ;
0B05DC 3E    0883** NOTK:			LD      A,26
0B05DD 1A 
0B05DE 18    0884** JR      FPPN
0B05DF 36 
             0885** ;
             0886** ;DEG - Convert radians to degrees
             0887** ;Result is floating-point numeric.
             0888** ;
0B05E0 3E    0889** DEG:			LD      A,21
0B05E1 15 
0B05E2 18    0890** JR      FPPN
0B05E3 32 
             0891** ;
             0892** ;RAD - Convert degrees to radians
             0893** ;Result is floating-point numeric.
             0894** ;
0B05E4 3E    0895** RAD:			LD      A,27
0B05E5 1B 
0B05E6 18    0896** JR      FPPN
0B05E7 2E 
             0897** ;
             0898** ;SGN - Return -1, 0 or +1
             0899** ;Result is integer numeric.
             0900** ;
0B05E8 3E    0901** SGN:			LD      A,28
0B05E9 1C 
0B05EA 18    0902** JR      FPPN
0B05EB 2A 
             0903** ;
             0904** ;INT - Floor function
             0905** ;Result is integer numeric.
             0906** ;
0B05EC 3E    0907** INT_:			LD      A,23
0B05ED 17 
0B05EE 18    0908** JR      FPPN
0B05EF 26 
             0909** ;
             0910** ;SQR - square root
             0911** ;Result is floating-point numeric.
             0912** ;
0B05F0 3E    0913** SQR:			LD      A,30
0B05F1 1E 
0B05F2 18    0914** JR      FPPN
0B05F3 22 
             0915** ;
             0916** ;TAN - Tangent function
             0917** ;Result is floating-point numeric.
             0918** ;
0B05F4 3E    0919** TAN:			LD      A,31
0B05F5 1F 
0B05F6 18    0920** JR      FPPN
0B05F7 1E 
             0921** ;
             0922** ;COS - Cosine function
             0923** ;Result is floating-point numeric.
             0924** ;
0B05F8 3E    0925** COS:			LD      A,20
0B05F9 14 
0B05FA 18    0926** JR      FPPN
0B05FB 1A 
             0927** ;
             0928** ;SIN - Sine function
             0929** ;Result is floating-point numeric.
             0930** ;
0B05FC 3E    0931** SIN:			LD      A,29
0B05FD 1D 
0B05FE 18    0932** JR      FPPN
0B05FF 16 
             0933** ;
             0934** ;EXP - Exponential function
             0935** ;Result is floating-point numeric.
             0936** ;
0B0600 3E    0937** EXP:			LD      A,22
0B0601 16 
0B0602 18    0938** JR      FPPN
0B0603 12 
             0939** ;
             0940** ;LN - Natural log.
             0941** ;Result is floating-point numeric.
             0942** ;
0B0604 3E    0943** LN:			LD      A,24
0B0605 18 
0B0606 18    0944** JR      FPPN
0B0607 0E 
             0945** ;
             0946** ;LOG - base-10 logarithm.
             0947** ;Result is floating-point numeric.
             0948** ;
0B0608 3E    0949** LOG:			LD      A,25
0B0609 19 
0B060A 18    0950** JR      FPPN
0B060B 0A 
             0951** ;
             0952** ;ASN - Arc-sine
             0953** ;Result is floating-point numeric.
             0954** ;
0B060C 3E    0955** ASN:			LD      A,18
0B060D 12 
0B060E 18    0956** JR      FPPN
0B060F 06 
             0957** ;
             0958** ;ATN - arc-tangent
             0959** ;Result is floating-point numeric.
             0960** ;
0B0610 3E    0961** ATN:			LD      A,19
0B0611 13 
0B0612 18    0962** JR      FPPN
0B0613 02 
             0963** ;
             0964** ;ACS - arc-cosine
             0965** ;Result is floating point numeric.
             0966** ;
0B0614 3E    0967** ACS:			LD      A,17
0B0615 11 
0B0616 F5    0968** FPPN:			PUSH    AF
0B0617 CD    0969** CALL    ITEMN
0B0618 E1 
0B0619 02 
0B061A 0B 
0B061B F1    0970** POP     AF
0B061C CD    0971** FPP1:			CALL    FPP
0B061D 2E 
0B061E 20 
0B061F 0B 
0B0620 DA    0972** JP      C,ERROR_
0B0621 24 
0B0622 37 
0B0623 0B 
0B0624 AF    0973** XOR     A
0B0625 C9    0974** RET
             0975** ;
             0976** ;SFIX - Convert to fixed-point notation
             0977** ;
0B0626 3E    0978** SFIX:			LD      A,38
0B0627 26 
0B0628 18    0979** JR      FPP1
0B0629 F2 
             0980** ;
             0981** ;SFLOAT - Convert to floating-point notation
             0982** ;
0B062A 3E    0983** SFLOAT:			LD      A,39
0B062B 27 
0B062C 18    0984** JR      FPP1
0B062D EE 
             0985** ;
             0986** ;VAL - Return numeric value of string.
             0987** ;Result is variable type numeric.
             0988** ;
0B062E CD    0989** VAL:			CALL    ITEMS
0B062F F4 
0B0630 02 
0B0631 0B 
0B0632 AF    0990** VAL0:			XOR     A
0B0633 12    0991** LD      (DE),A
0B0634 DD    0992** LD      IX,ACCS
0B0635 21 
0B0636 00 
0B0637 5B 
0B0637 0B   
0B0639 3E    0993** LD      A,36
0B063A 24 
0B063B 18    0994** JR      FPP1
0B063C DF 
             0995** ;
             0996** ;EVAL - Pass string to expression evaluator.
             0997** ;Result is variable type (numeric or string).
             0998** ;
0B063D CD    0999** EVAL_:			CALL    ITEMS
0B063E F4 
0B063F 02 
0B0640 0B 
0B0641 3E    1000** LD      A,CR
0B0642 0D 
0B0643 12    1001** LD      (DE),A
0B0644 FD    1002** PUSH    IY
0B0645 E5 
0B0646 11    1003** LD      DE,ACCS
0B0647 00 
0B0648 5B 
0B0649 0B 
0B064A FD    1004** LD      IY,ACCS
0B064B 21 
0B064C 00 
0B064D 5B 
0B064D 0B   
0B064F 0E    1005** LD      C,0
0B0650 00 
0B0651 CD    1006** CALL    LEXAN2          ;TOKENISE
0B0652 63 
0B0653 3C 
0B0654 0B 
0B0655 12    1007** LD      (DE),A
0B0656 13    1008** INC     DE
0B0657 AF    1009** XOR     A
0B0658 CD    1010** CALL    PUSHS           ;PUT ON STACK
0B0659 78 
0B065A 09 
0B065B 0B 
0B065C FD    1011** LD      IY,SIZEW	;WAS 2
0B065D 21 
0B065E 03 
0B065F 00 
0B065F 00   
0B0661 FD    1012** ADD     IY,SP
0B0662 39 
0B0663 CD    1013** CALL    EXPR
0B0664 8B 
0B0665 01 
0B0666 0B 
0B0667 FD    1014** POP     IY
0B0668 E1 
0B0669 FD    1015** ADD     IY,SP
0B066A 39 
0B066B FD    1016** LD      SP,IY           ;ADJUST STACK POINTER
0B066C F9 
0B066D FD    1017** POP     IY
0B066E E1 
0B066F 08    1018** EX      AF,AF'
0B0670 C9    1019** RET
             1020** ;
             1021** ;RND - Random number function.
             1022** ; RND gives random integer 0-&FFFFFFFF
             1023** ; RND(-n) seeds random number & returns -n.
             1024** ; RND(0) returns last value in RND(1) form.
             1025** ; RND(1) returns floating-point 0-0.99999999.
             1026** ; RND(n) returns random integer 1-n.
             1027** ;
0B0671 DD    1028** RND:			LD      IX,RANDOM
0B0672 21 
0B0673 38 
0B0674 5E 
0B0674 0B   
0B0676 CD    1029** CALL    NXT
0B0677 34 
0B0678 0A 
0B0679 0B 
0B067A FE    1030** CP      '('
0B067B 28 
0B067C 28    1031** JR      Z,RND5          ;ARGUMENT FOLLOWS
0B067D 20 
0B067E CD    1032** CALL    LOAD5
0B067F E3 
0B0680 03 
0B0681 0B 
0B0682 CB    1033** RND1:			RR      C
0B0683 19 
0B0684 06    1034** LD      B,32
0B0685 20 
0B0686 D9    1035** RND2:			EXX                     ;CALCULATE NEXT
0B0687 52    1036** ADC.S   HL,HL
0B0688 ED 
0B0689 6A 
0B068A D9    1037** EXX
0B068B 52    1038** ADC.S   HL,HL
0B068C ED 
0B068D 6A 
0B068E CB    1039** BIT     3,L
0B068F 5D 
0B0690 28    1040** JR      Z,RND3
0B0691 01 
0B0692 3F    1041** CCF
0B0693 10    1042** RND3:			DJNZ    RND2
0B0694 F1 
0B0695 CB    1043** RND4:			RL      C               ;SAVE CARRY
0B0696 11 
0B0697 CD    1044** CALL    STORE5          ;STORE NEW NUMBER
0B0698 9F 
0B0699 15 
0B069A 0B 
0B069B AF    1045** XOR     A
0B069C 4F    1046** LD      C,A
0B069D C9    1047** RET
0B069E CD    1048** RND5:			CALL    ITEMI
0B069F E9 
0B06A0 02 
0B06A1 0B 
0B06A2 DD    1049** LD      IX,RANDOM
0B06A3 21 
0B06A4 38 
0B06A5 5E 
0B06A5 0B   
0B06A7 CB    1050** BIT     7,H             ;NEGATIVE?
0B06A8 7C 
0B06A9 37    1051** SCF
0B06AA 20    1052** JR      NZ,RND4         ;SEED
0B06AB E9 
0B06AC CD    1053** CALL    TEST
0B06AD A3 
0B06AE 08 
0B06AF 0B 
0B06B0 F5    1054** PUSH    AF
0B06B1 CD    1055** CALL    SWAP
0B06B2 9B 
0B06B3 08 
0B06B4 0B 
0B06B5 D9    1056** EXX
0B06B6 CD    1057** CALL    LOAD5
0B06B7 E3 
0B06B8 03 
0B06B9 0B 
0B06BA C4    1058** CALL    NZ,RND1         ;NEXT IF NON-ZERO
0B06BB 82 
0B06BC 06 
0B06BD 0B 
0B06BE D9    1059** EXX                     ;SCRAMBLE (CARE!)
0B06BF 0E    1060** LD      C,7FH
0B06C0 7F 
0B06C1 CB    1061** RND6:			BIT     7,H             ;FLOAT
0B06C2 7C 
0B06C3 20    1062** JR      NZ,RND7
0B06C4 0A 
0B06C5 D9    1063** EXX
0B06C6 52    1064** ADD.S   HL,HL
0B06C7 29 
0B06C8 D9    1065** EXX
0B06C9 52    1066** ADC.S   HL,HL
0B06CA ED 
0B06CB 6A 
0B06CC 0D    1067** DEC     C
0B06CD 20    1068** JR      NZ,RND6
0B06CE F2 
0B06CF CB    1069** RND7:			RES     7,H             ;POSITIVE 0-0.999999
0B06D0 BC 
0B06D1 F1    1070** POP     AF
0B06D2 C8    1071** RET     Z               ;ZERO ARGUMENT
0B06D3 D9    1072** EXX
0B06D4 7B    1073** LD      A,E
0B06D5 3D    1074** DEC     A
0B06D6 B2    1075** OR      D
0B06D7 D9    1076** EXX
0B06D8 B3    1077** OR      E
0B06D9 B2    1078** OR      D
0B06DA C8    1079** RET     Z               ;ARGUMENT=1
0B06DB 06    1080** LD      B,0             ;INTEGER MARKER
0B06DC 00 
0B06DD 3E    1081** LD      A,10
0B06DE 0A 
0B06DF CD    1082** CALL    FPP             ;MULTIPLY
0B06E0 2E 
0B06E1 20 
0B06E2 0B 
0B06E3 DA    1083** JP      C,ERROR_
0B06E4 24 
0B06E5 37 
0B06E6 0B 
0B06E7 CD    1084** CALL    SFIX
0B06E8 26 
0B06E9 06 
0B06EA 0B 
0B06EB C3    1085** JP      ADD1
0B06EC 7F 
0B06ED 03 
0B06EE 0B 
             1086** ;
             1087** ; INSTR - String search.
             1088** ; Result is integer numeric.
             1089** ;
0B06EF CD    1090** INSTR:			CALL    EXPRSC			; Get the first string expression
0B06F0 E2 
0B06F1 09 
0B06F2 0B 
0B06F3 CD    1091** CALL    PUSHS           	; Push the string onto the stack
0B06F4 78 
0B06F5 09 
0B06F6 0B 
0B06F7 CD    1092** CALL    EXPRS           	; Get the second string expression
0B06F8 D9 
0B06F9 02 
0B06FA 0B 
0B06FB C1    1093** POP     BC			;  C: String length, B: Value of A before PUSHS was called
0B06FC 21    1094** LD      HL,0
0B06FD 00 
0B06FE 00 
0B06FF 00 
0B0700 39    1095** ADD     HL,SP           	; HL: Pointer to main string
0B0701 C5    1096** PUSH    BC              	;  C: Main string length
0B0702 43    1097** LD      B,E             	;  B: Sub-string length
0B0703 CD    1098** CALL    NXT			; Skip whitespace
0B0704 34 
0B0705 0A 
0B0706 0B 
0B0707 FE    1099** CP      ','			; Check if there is a comma for the third parameter
0B0708 2C 
0B0709 3E    1100** LD      A,0			;  A: Default start position in string
0B070A 00 
0B070B 20    1101** JR      NZ,INSTR1		; No, so skip the next bit
0B070C 1A 
0B070D FD    1102** INC     IY              	; Skip the comma
0B070E 23 
0B070F C5    1103** PUSH    BC              	; Save the lengths
0B0710 E5    1104** PUSH    HL              	; Save the pointer to the main string
0B0711 CD    1105** CALL    PUSHS			; Push the string onto the stack
0B0712 78 
0B0713 09 
0B0714 0B 
0B0715 CD    1106** CALL    EXPRI			; Get the third (numeric) parameter - the starting position
0B0716 CE 
0B0717 02 
0B0718 0B 
0B0719 C1    1107** POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
0B071A CD    1108** CALL    POPS			; Pop the string off the stack
0B071B A2 
0B071C 09 
0B071D 0B 
0B071E E1    1109** POP     HL              	; Restore the pointer to the main string
0B071F C1    1110** POP     BC              	; Restore the lengths
0B0720 D9    1111** EXX
0B0721 7D    1112** LD      A,L			; A: The start position in the  string
0B0722 D9    1113** EXX
0B0723 B7    1114** OR      A			; Set the flags
0B0724 28    1115** JR      Z,INSTR1		; If it is zero, then skip
0B0725 01 
0B0726 3D    1116** DEC     A
0B0727 11    1117** INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
0B0728 00 
0B0729 5B 
0B072A 0B 
0B072B CD    1118** CALL    SEARCH			; Do the search
0B072C 49 
0B072D 07 
0B072E 0B 
0B072F D1    1119** POP     DE
0B0730 28    1120** JR      Z,INSTR2        	; NB: Carry cleared
0B0731 03 
0B0732 ED    1121** SBC     HL,HL
0B0733 62 
0B0734 39    1122** ADD     HL,SP
0B0735 ED    1123** INSTR2:			SBC     HL,SP
0B0736 72 
0B0737 EB    1124** EX      DE,HL
0B0738 7D    1125** LD	A,L
0B0739 21    1126** LD      HL,0
0B073A 00 
0B073B 00 
0B073C 00 
0B073D 6F    1127** LD	L,A
0B073E 39    1128** ADD     HL,SP
0B073F F9    1129** LD      SP,HL
0B0740 EB    1130** EX      DE,HL
0B0741 CD    1131** CALL    BRAKET			; Check for closing bracket
0B0742 F3 
0B0743 09 
0B0744 0B 
0B0745 C3    1132** JP      COUNT1			; Return a numeric integer
0B0746 45 
0B0747 05 
0B0748 0B 
             1133** ;
             1134** ; SEARCH - Search string for sub-string
             1135** ;    Inputs: Main string at HL length C
             1136** ;            Sub-string  at DE length B
             1137** ;            Starting offset A
             1138** ;   Outputs: NZ - not found
             1139** ;            Z - found at location HL-1
             1140** ;            Carry always cleared
             1141** ;
0B0749 C5    1142** SEARCH:			PUSH    BC			; Add the starting offset to HL
0B074A 01    1143** LD      BC,0
0B074B 00 
0B074C 00 
0B074D 00 
0B074E 4F    1144** LD      C,A
0B074F 09    1145** ADD     HL,BC           	; New start address
0B0750 C1    1146** POP     BC
0B0751 91    1147** SUB     C			; If the starting offset > main string length, then do nothing
0B0752 30    1148** JR      NC,SRCH4
0B0753 2C 
0B0754 ED    1149** NEG
0B0755 44 
0B0756 4F    1150** LD      C,A             	; Remaining length
             1151** ;
0B0757 C5    1152** SRCH1:			PUSH    BC
0B0758 79    1153** LD	A,C
0B0759 01    1154** LD	BC,0
0B075A 00 
0B075B 00 
0B075C 00 
0B075D 4F    1155** LD	C,A
0B075E 1A    1156** LD      A,(DE)
0B075F ED    1157** CPIR                    	; Find the first character
0B0760 B1 
0B0761 79    1158** LD      A,C
0B0762 C1    1159** POP     BC
0B0763 20    1160** JR      NZ,SRCH4
0B0764 1B 
0B0765 4F    1161** LD      C,A
             1162** ;
             1163** ; This block of four instructions was commented as a bug fix by R.T.Russell
             1164** ;
0B0766 05    1165** DEC     B			; Bug fix
0B0767 B8    1166** CP      B			; Bug fix
0B0768 04    1167** INC     B			; Bug fix
0B0769 38    1168** JR      C,SRCH4			; Bug fix
0B076A 15 
             1169** ;
0B076B C5    1170** PUSH    BC
0B076C D5    1171** PUSH    DE
0B076D E5    1172** PUSH    HL
0B076E 05    1173** DEC     B
0B076F 28    1174** JR      Z,SRCH3         	; Found!
0B0770 08 
0B0771 13    1175** SRCH2:			INC     DE
0B0772 1A    1176** LD      A,(DE)
0B0773 BE    1177** CP      (HL)
0B0774 20    1178** JR      NZ,SRCH3
0B0775 03 
0B0776 23    1179** INC     HL
0B0777 10    1180** DJNZ    SRCH2
0B0778 F8 
0B0779 E1    1181** SRCH3:			POP     HL
0B077A D1    1182** POP     DE
0B077B C1    1183** POP     BC
0B077C 20    1184** JR      NZ,SRCH1
0B077D D9 
0B077E AF    1185** XOR     A               	; Flags: Z, NC
0B077F C9    1186** RET                     	; Found
             1187** ;
0B0780 F6    1188** SRCH4:			OR      0FFH            	; Flags: NZ, NC
0B0781 FF 
0B0782 C9    1189** RET                     	; Not found
             1190** ;
             1191** ;CHRS - Return character with given ASCII value.
             1192** ;Result is string.
             1193** ;
0B0783 CD    1194** CHRS:			CALL    ITEMI
0B0784 E9 
0B0785 02 
0B0786 0B 
0B0787 D9    1195** EXX
0B0788 7D    1196** LD      A,L
0B0789 18    1197** JR      GET1
0B078A 0E 
             1198** ;
             1199** ;GETS - Return key pressed as stringor character at position (X,Y).
             1200** ;Result is string.
             1201** ;
0B078B CD    1202** GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0B078C 34 
0B078D 0A 
0B078E 0B 
0B078F FE    1203** CP	'('
0B0790 28 
0B0791 CA    1204** JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0B0792 C0 
0B0793 43 
0B0794 0B 
0B0795 CD    1205** CALL    OSRDCH
0B0796 ED 
0B0797 3E 
0B0798 0B 
0B0799 37    1206** GET1:			SCF
0B079A 18    1207** JR      INKEY1
0B079B 09 
             1208** ;
             1209** ; INKEYS - Wait up to n centiseconds for keypress.
             1210** ;          Return key pressed as string or null
             1211** ;          string if time elapsed.
             1212** ; Result is string.
             1213** ;
0B079C CD    1214** INKEYS:			CALL    ITEMI			; Fetch the argument
0B079D E9 
0B079E 02 
0B079F 0B 
0B07A0 D9    1215** EXX
0B07A1 CD    1216** INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0B07A2 F6 
0B07A3 3E 
0B07A4 0B 
0B07A5 11    1217** INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0B07A6 00 
0B07A7 5B 
0B07A8 0B 
0B07A9 12    1218** LD      (DE),A
0B07AA 3E    1219** LD      A,80H
0B07AB 80 
0B07AC D0    1220** RET     NC
0B07AD 1C    1221** INC     E
0B07AE C9    1222** RET
             1223** ;
             1224** ; INKEYM - Check immediately whether a given key is being pressed
             1225** ; Result is integer numeric
             1226** ;
             1227** INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0B07AF 3E   0001**M LD	A, function
0B07B0 1E 
0B07B1 49   0002**M RST.LIS	08h
0B07B2 CF 
0B07B3 23    1228** INC	HL			; Index from 0
0B07B4 7D    1229** LD	A, L			; Negate the LSB of the answer
0B07B5 ED    1230** NEG
0B07B6 44 
0B07B7 4F    1231** LD	C, A			;  E: The positive keycode value
0B07B8 3E    1232** LD	A, 1			; Throw an "Out of range" error
0B07B9 01 
0B07BA FA    1233** JP	M, ERROR_		; if the argument < - 128
0B07BB 24 
0B07BC 37 
0B07BD 0B 
             1234** ;
0B07BE 21    1235** LD	HL, BITLOOKUP		; HL: The bit lookup table
0B07BF E1 
0B07C0 07 
0B07C1 0B 
0B07C2 11    1236** LD	DE, 0
0B07C3 00 
0B07C4 00 
0B07C5 00 
0B07C6 79    1237** LD	A, C
0B07C7 E6    1238** AND	00000111b		; Just need the first three bits
0B07C8 07 
0B07C9 5F    1239** LD	E, A			; DE: The bit number
0B07CA 19    1240** ADD	HL, DE
0B07CB 46    1241** LD	B, (HL)			;  B: The mask
             1242** ;
0B07CC 79    1243** LD	A, C			; Fetch the keycode again
0B07CD E6    1244** AND	01111000b		; And divide by 8
0B07CE 78 
0B07CF 0F    1245** RRCA
0B07D0 0F    1246** RRCA
0B07D1 0F    1247** RRCA
0B07D2 5F    1248** LD	E, A			; DE: The offset (the MSW has already been cleared previously)
0B07D3 DD    1249** ADD	IX, DE			; IX: The address
0B07D4 19 
0B07D5 78    1250** LD	A, B			;  B: The mask
0B07D6 DD    1251** AND	(IX+0)			; Check whether the bit is set
0B07D7 A6 
0B07D8 00 
0B07D9 CA    1252** JP	Z, ZERO			; No, so return 0
0B07DA 57 
0B07DB 09 
0B07DC 0B 
0B07DD C3    1253** JP	TRUE			; Otherwise return -1
0B07DE C9 
0B07DF 05 
0B07E0 0B 
             1254** ;
             1255** ; A bit lookup table
             1256** ;
0B07E1 01    1257** BITLOOKUP:		DB	01h, 02h, 04h, 08h
0B07E2 02 
0B07E3 04 
0B07E4 08 
0B07E5 10    1258** DB	10h, 20h, 40h, 80h
0B07E6 20 
0B07E7 40 
0B07E8 80 
             1259** ;
             1260** ; MID$ - Return sub-string.
             1261** ; Result is string.
             1262** ;
0B07E9 CD    1263** MIDS:			CALL    EXPRSC			; Get the first string expression
0B07EA E2 
0B07EB 09 
0B07EC 0B 
0B07ED CD    1264** CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B07EE 78 
0B07EF 09 
0B07F0 0B 
0B07F1 CD    1265** CALL    EXPRI			; Get the second expression
0B07F2 CE 
0B07F3 02 
0B07F4 0B 
0B07F5 C1    1266** POP     BC			; C: String length, B: Value of A before PUSHS was called
0B07F6 CD    1267** CALL    POPS			; Pop the string back off the stack to the string accumulator
0B07F7 A2 
0B07F8 09 
0B07F9 0B 
0B07FA D9    1268** EXX
0B07FB 7D    1269** LD      A,L			; A: The start index
0B07FC D9    1270** EXX
0B07FD B7    1271** OR      A			; If the start index is 0, then we don't need to do the next bit
0B07FE 28    1272** JR      Z,MIDS1
0B07FF 0E 
0B0800 3D    1273** DEC     A
0B0801 6F    1274** LD      L,A			; L: The start index - 1
0B0802 93    1275** SUB     E			; Subtract from the string length
0B0803 1E    1276** LD      E,0			; Preemptively set the string length to 0
0B0804 00 
0B0805 30    1277** JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
0B0806 07 
0B0807 ED    1278** NEG				; Negate the answer and
0B0808 44 
0B0809 4F    1279** LD      C,A			; C: Number of bytes to copy
0B080A CD    1280** CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
0B080B 4D 
0B080C 08 
0B080D 0B 
0B080E CD    1281** MIDS1:			CALL    NXT			; Skip whitespace
0B080F 34 
0B0810 0A 
0B0811 0B 
0B0812 FE    1282** CP      ','			; Check for a comma
0B0813 2C 
0B0814 FD    1283** INC     IY			; Advance to the next character in the BASIC line
0B0815 23 
0B0816 28    1284** JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
0B0817 0D 
0B0818 FD    1285** DEC     IY			; Restore the BASIC program pointer
0B0819 2B 
0B081A CD    1286** CALL    BRAKET			; Check for a bracket
0B081B F3 
0B081C 09 
0B081D 0B 
0B081E 3E    1287** LD      A,80H			; String marker
0B081F 80 
0B0820 C9    1288** RET
             1289** ;
             1290** ; LEFT$ - Return left part of string.
             1291** ; Carry cleared if entire string returned.
             1292** ; Result is string.
             1293** ;
0B0821 CD    1294** LEFTS:			CALL    EXPRSC			; Get the first string expression
0B0822 E2 
0B0823 09 
0B0824 0B 
0B0825 CD    1295** LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B0826 78 
0B0827 09 
0B0828 0B 
0B0829 CD    1296** CALL    EXPRI			; Get the second expression
0B082A CE 
0B082B 02 
0B082C 0B 
0B082D C1    1297** POP     BC			; C: String length, B: Value of A before PUSHS was called
0B082E CD    1298** CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
0B082F A2 
0B0830 09 
0B0831 0B 
0B0832 CD    1299** CALL    BRAKET			; Check for closing bracket
0B0833 F3 
0B0834 09 
0B0835 0B 
0B0836 D9    1300** EXX
0B0837 7D    1301** LD      A,L			; L: The second parameter
0B0838 D9    1302** EXX
0B0839 BB    1303** CP      E			; Compare with the string length
0B083A 30    1304** JR      NC,LEFT3		; If it is greater than or equal then do nothing
0B083B 02 
0B083C 6B    1305** LD      L,E             	; For RIGHTS, no effect in LEFTS
0B083D 5F    1306** LEFT2:			LD      E,A			; E: The new length of string
0B083E 3E    1307** LEFT3:			LD      A,80H           	; String marker
0B083F 80 
0B0840 C9    1308** RET
             1309** ;
             1310** ; RIGHT$ - Return right part of string.
             1311** ; Result is string.
             1312** ;
0B0841 CD    1313** RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
0B0842 21 
0B0843 08 
0B0844 0B 
0B0845 D0    1314** RET     NC			; Do nothing if the second parameter is >= string length
0B0846 1C    1315** INC     E			; Check for a zero length string
0B0847 1D    1316** DEC     E
0B0848 C8    1317** RET     Z			; Yes, so do nothing
0B0849 4B    1318** LD      C,E			;  C: Number of bytes to copy
0B084A 7D    1319** LD      A,L
0B084B 93    1320** SUB     E
0B084C 6F    1321** LD      L,A			;  L: Index into the string
0B084D 79    1322** RIGHT1:			LD	A,C
0B084E 01    1323** LD	BC,0
0B084F 00 
0B0850 00 
0B0851 00 
0B0852 4F    1324** LD	C,A			; BC: Number of bytes to copy (with top word cleared)
0B0853 7D    1325** LD	A,L
0B0854 21    1326** LD	HL,ACCS
0B0855 00 
0B0856 5B 
0B0857 0B 
0B0858 6F    1327** LD	L,A			; HL: Source (in ACCS)
0B0859 11    1328** LD      DE,ACCS			; DE: Destination (start of ACCS)
0B085A 00 
0B085B 5B 
0B085C 0B 
0B085D ED    1329** LDIR                    	; Copy
0B085E B0 
0B085F 3E    1330** LD      A,80H			; String marker
0B0860 80 
0B0861 C9    1331** RET
             1332** ;
             1333** ; STRINGS - Return n concatenations of a string.
             1334** ; Result is string.
             1335** ;
0B0862 CD    1336** STRING_:		CALL    EXPRI			; Get number of times to replicate
0B0863 CE 
0B0864 02 
0B0865 0B 
0B0866 CD    1337** CALL    COMMA			; Check for comma
0B0867 E6 
0B0868 09 
0B0869 0B 
0B086A D9    1338** EXX
0B086B 7D    1339** LD      A,L			; L: Number of iterations of string
0B086C D9    1340** EXX
0B086D F5    1341** PUSH    AF
0B086E CD    1342** CALL    EXPRS			; Get the string
0B086F D9 
0B0870 02 
0B0871 0B 
0B0872 CD    1343** CALL    BRAKET			; Check for closing bracket
0B0873 F3 
0B0874 09 
0B0875 0B 
0B0876 F1    1344** POP     AF			; A: Number of iterations of string
0B0877 B7    1345** OR      A			; Set flags
0B0878 28    1346** JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0B0879 C3 
0B087A 3D    1347** DEC     A
0B087B 4F    1348** LD      C,A			; C: Loop counter
0B087C 3E    1349** LD      A,80H			; String marker
0B087D 80 
0B087E C8    1350** RET     Z
0B087F 1C    1351** INC     E			; Check for empty string
0B0880 1D    1352** DEC     E
0B0881 C8    1353** RET     Z              		; And return
0B0882 43    1354** LD      B,E			; B: String length tally
0B0883 21    1355** LD	HL,ACCS
0B0884 00 
0B0885 5B 
0B0886 0B 
0B0887 C5    1356** STRIN1:			PUSH    BC
0B0888 7E    1357** STRIN2:			LD      A,(HL)
0B0889 23    1358** INC     HL
0B088A 12    1359** LD      (DE),A
0B088B 1C    1360** INC     E
0B088C 3E    1361** LD      A,19
0B088D 13 
0B088E CA    1362** JP      Z,ERROR_         	; Throw a "String too long" error
0B088F 24 
0B0890 37 
0B0891 0B 
0B0892 10    1363** DJNZ    STRIN2
0B0893 F4 
0B0894 C1    1364** POP     BC
0B0895 0D    1365** DEC     C
0B0896 20    1366** JR      NZ,STRIN1
0B0897 EF 
0B0898 3E    1367** LD      A,80H
0B0899 80 
0B089A C9    1368** RET
             1369** ;
             1370** ;SUBROUTINES
             1371** ;
             1372** ;SWAP - Swap arguments
             1373** ;Exchanges DE,HL D'E',H'L' and B,C
             1374** ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
             1375** ;
0B089B 79    1376** SWAP:			LD      A,C
0B089C 48    1377** LD      C,B
0B089D 47    1378** LD      B,A
0B089E EB    1379** EX      DE,HL
0B089F D9    1380** EXX
0B08A0 EB    1381** EX      DE,HL
0B08A1 D9    1382** EXX
0B08A2 C9    1383** RET
             1384** ;
             1385** ;TEST - Test HLH'L' for zero
             1386** ;Outputs: Z-flag set & A=0 if zero
             1387** ;Destroys: A,F
             1388** ;
0B08A3 7C    1389** TEST:			LD      A,H
0B08A4 B5    1390** OR      L
0B08A5 D9    1391** EXX
0B08A6 B4    1392** OR      H
0B08A7 B5    1393** OR      L
0B08A8 D9    1394** EXX
0B08A9 C9    1395** RET
             1396** ;
             1397** ;DECODE - Decode line number in pseudo-binary.
             1398** ;   Inputs: IY = Text pointer.
             1399** ;   Outputs: HL=0, H'L'=line number, C=0.
             1400** ;   Destroys: A,C,H,L,H',L',IY,F
             1401** ;
0B08AA D9    1402** DECODE:			EXX
0B08AB 21    1403** LD	HL, 0
0B08AC 00 
0B08AD 00 
0B08AE 00 
0B08AF FD    1404** LD      A,(IY)
0B08B0 7E 
0B08B1 00 
0B08B2 FD    1405** INC     IY
0B08B3 23 
0B08B4 17    1406** RLA
0B08B5 17    1407** RLA
0B08B6 67    1408** LD      H,A
0B08B7 E6    1409** AND     0C0H
0B08B8 C0 
0B08B9 FD    1410** XOR     (IY)
0B08BA AE 
0B08BB 00 
0B08BC FD    1411** INC     IY
0B08BD 23 
0B08BE 6F    1412** LD      L,A
0B08BF 7C    1413** LD      A,H
0B08C0 17    1414** RLA
0B08C1 17    1415** RLA
0B08C2 E6    1416** AND     0C0H
0B08C3 C0 
0B08C4 FD    1417** XOR     (IY)
0B08C5 AE 
0B08C6 00 
0B08C7 FD    1418** INC     IY
0B08C8 23 
0B08C9 67    1419** LD      H,A
0B08CA D9    1420** EXX
             1421** ;			XOR     A
             1422** ;			LD      C,A
             1423** ;			LD      H,A
             1424** ;			LD      L,A
0B08CB 21    1425** LD	HL, 0
0B08CC 00 
0B08CD 00 
0B08CE 00 
0B08CF 4D    1426** LD	C, L
0B08D0 C9    1427** RET
             1428** ;
             1429** ;HEXSTR - convert numeric value to HEX string.
             1430** ;   Inputs: HLH'L'C = integer or floating-point number
             1431** ;  Outputs: String in string accumulator.
             1432** ;           E = string length.  D = ACCS/256
             1433** ;
0B08D1 FD    1434** HEXSTS:			INC     IY              ;SKIP TILDE
0B08D2 23 
0B08D3 CD    1435** CALL    ITEMN
0B08D4 E1 
0B08D5 02 
0B08D6 0B 
0B08D7 CD    1436** CALL    HEXSTR
0B08D8 DE 
0B08D9 08 
0B08DA 0B 
0B08DB 3E    1437** LD      A,80H
0B08DC 80 
0B08DD C9    1438** RET
             1439** ;
0B08DE CD    1440** HEXSTR:			CALL    SFIX
0B08DF 26 
0B08E0 06 
0B08E1 0B 
0B08E2 01    1441** LD      BC,8
0B08E3 08 
0B08E4 00 
0B08E5 00 
0B08E6 11    1442** LD      DE,ACCS
0B08E7 00 
0B08E8 5B 
0B08E9 0B 
0B08EA C5    1443** HEXST1:			PUSH    BC
0B08EB 06    1444** LD      B,4
0B08EC 04 
0B08ED AF    1445** XOR     A
0B08EE D9    1446** HEXST2:			EXX
0B08EF 52    1447** ADD.S	HL,HL
0B08F0 29 
0B08F1 D9    1448** EXX
0B08F2 52    1449** ADC.S	HL,HL
0B08F3 ED 
0B08F4 6A 
0B08F5 17    1450** RLA
0B08F6 10    1451** DJNZ    HEXST2
0B08F7 F6 
0B08F8 C1    1452** POP     BC
0B08F9 0D    1453** DEC     C
0B08FA F8    1454** RET     M
0B08FB 28    1455** JR      Z,HEXST3
0B08FC 06 
0B08FD B7    1456** OR      A
0B08FE 20    1457** JR      NZ,HEXST3
0B08FF 03 
0B0900 B8    1458** CP      B
0B0901 28    1459** JR      Z,HEXST1
0B0902 E7 
0B0903 C6    1460** HEXST3:			ADD     A,90H
0B0904 90 
0B0905 27    1461** DAA
0B0906 CE    1462** ADC     A,40H
0B0907 40 
0B0908 27    1463** DAA
0B0909 12    1464** LD      (DE),A
0B090A 13    1465** INC     DE
0B090B 47    1466** LD      B,A
0B090C 18    1467** JR      HEXST1
0B090D DC 
             1468** ;
             1469** ;Function STR - convert numeric value to ASCII string.
             1470** ;   Inputs: HLH'L'C = integer or floating-point number.
             1471** ;  Outputs: String in string accumulator.
             1472** ;           E = length, D = ACCS/256
             1473** ;           A = 80H (type=string)
             1474** ;
             1475** ;First normalise for decimal output:
             1476** ;
0B090E CD    1477** STRS:			CALL    NXT
0B090F 34 
0B0910 0A 
0B0911 0B 
0B0912 FE    1478** CP      '~'
0B0913 7E 
0B0914 28    1479** JR      Z,HEXSTS
0B0915 BB 
0B0916 CD    1480** CALL    ITEMN
0B0917 E1 
0B0918 02 
0B0919 0B 
0B091A DD    1481** LD      IX,STAVAR
0B091B 21 
0B091C 00 
0B091D 5D 
0B091D 0B   
0B091F DD    1482** LD      A,(IX+3)
0B0920 7E 
0B0921 03 
0B0922 B7    1483** OR      A
0B0923 DD    1484** LD      IX,G9-1         ;G9 FORMAT
0B0924 21 
0B0925 50 
0B0926 09 
0B0926 0B   
0B0928 28    1485** JR      Z,STR0
0B0929 05 
0B092A DD    1486** STR:			LD      IX,STAVAR
0B092B 21 
0B092C 00 
0B092D 5D 
0B092D 0B   
0B092F 11    1487** STR0:			LD      DE,ACCS
0B0930 00 
0B0931 5B 
0B0932 0B 
0B0933 3E    1488** LD      A,37
0B0934 25 
0B0935 CD    1489** CALL    FPP
0B0936 2E 
0B0937 20 
0B0938 0B 
0B0939 DA    1490** JP      C,ERROR_
0B093A 24 
0B093B 37 
0B093C 0B 
0B093D DD    1491** BIT     0,(IX+2)
0B093E CB 
0B093F 02 
0B0940 46 
0B0941 3E    1492** STR1:			LD      A,80H           ;STRING MARKER
0B0942 80 
0B0943 C8    1493** RET     Z
0B0944 79    1494** LD      A,C
0B0945 C6    1495** ADD     A,4
0B0946 04 
0B0947 BB    1496** STR2:			CP      E
0B0948 28    1497** JR      Z,STR1
0B0949 F7 
0B094A EB    1498** EX      DE,HL
0B094B 36    1499** LD      (HL),' '        ;TRAILING SPACE
0B094C 20 
0B094D 23    1500** INC     HL
0B094E EB    1501** EX      DE,HL
0B094F 18    1502** JR      STR2
0B0950 F6 
             1503** ;
0B0951 09    1504** G9:			DW    9
0B0952 00 
             1505** ;
             1506** ;STRING COMPARE
             1507** ;Compare string (DE) length B with string (HL) length C.
             1508** ;Result preset to false.
             1509** ;
0B0953 CD    1510** SCP:			CALL	SCP0
0B0954 61 
0B0955 09 
0B0956 0B 
             1511** ;
0B0957 3E    1512** ZERO:			LD      A,0
0B0958 00 
0B0959 D9    1513** EXX
0B095A 67    1514** LD      H,A
0B095B 6F    1515** LD      L,A
0B095C D9    1516** EXX
0B095D 67    1517** LD      H,A
0B095E 6F    1518** LD      L,A
0B095F 4F    1519** LD      C,A
0B0960 C9    1520** RET
             1521** ;
0B0961 04    1522** SCP0:			INC     B
0B0962 0C    1523** INC     C
0B0963 05    1524** SCP1:			DEC     B
0B0964 28    1525** JR      Z,SCP2
0B0965 0A 
0B0966 0D    1526** DEC     C
0B0967 28    1527** JR      Z,SCP3
0B0968 0C 
0B0969 1A    1528** LD      A,(DE)
0B096A BE    1529** CP      (HL)
0B096B C0    1530** RET     NZ
0B096C 13    1531** INC     DE
0B096D 23    1532** INC     HL
0B096E 18    1533** JR      SCP1
0B096F F3 
0B0970 B7    1534** SCP2:			OR      A
0B0971 0D    1535** DEC     C
0B0972 C8    1536** RET     Z
0B0973 37    1537** SCF
0B0974 C9    1538** RET
0B0975 B7    1539** SCP3:			OR      A
0B0976 0C    1540** INC     C
0B0977 C9    1541** RET
             1542** ;
             1543** ; PUSHS - SAVE STRING ON STACK.
             1544** ;     Inputs: String in string accumulator.
             1545** ;             E = string length.
             1546** ;             A - saved on stack.
             1547** ;   Destroys: B,C,D,E,H,L,IX,SP,F
             1548** ;
0B0978 CD    1549** PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0B0979 13 
0B097A 16 
0B097B 0B 
0B097C DD    1550** POP     IX              	; IX: Return address
0B097D E1 
0B097E B7    1551** OR      A               	; Clear the carry flag
0B097F 01    1552** LD	BC,0			; BC: Length of the string
0B0980 00 
0B0981 00 
0B0982 00 
0B0983 4B    1553** LD	C,E
0B0984 21    1554** LD      HL,ACCS			; HL: Pointer to the string accumulator
0B0985 00 
0B0986 5B 
0B0987 0B 
0B0988 11    1555** LD	DE,ACCS
0B0989 00 
0B098A 5B 
0B098B 0B 
0B098C 59    1556** LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0B098D ED    1557** SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0B098E 52 
0B098F 39    1558** ADD     HL,SP			; Grow the stack
0B0990 F9    1559** LD      SP,HL
0B0991 57    1560** LD      D,A			;  D: This needs to be set to A for some functions
             1561** ; BEGIN MISSING FROM BINARY
             1562** ; LD	B,A			; Stack A and C (the string length)
             1563** ; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
             1564** ; LD	B,0			; Reset B to 0 for the LDIR in this function
             1565** ; END MISSING FROM BINARY
0B0992 D5    1566** PUSH 	DE ; ADDED FROM BINARY
0B0993 28    1567** JR      Z,PUSHS1        	; Is it zero length?
0B0994 0B 
0B0995 11    1568** LD      DE,ACCS			; DE: Destination
0B0996 00 
0B0997 5B 
0B0998 0B 
0B0999 EB    1569** EX      DE,HL			; HL: Destination, DE: Address on stack
0B099A ED    1570** LDIR	                    	; Copy to stack
0B099B B0 
0B099C CD    1571** CALL    CHECK			; Final check to see if there is sufficient space on the stack
0B099D 13 
0B099E 16 
0B099F 0B 
0B09A0 DD    1572** PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B09A1 E9 
             1573** ;
             1574** ; POPS - RESTORE STRING FROM STACK.
             1575** ;     Inputs: C = string length.
             1576** ;    Outputs: String in string accumulator.
             1577** ;             E = string length.
             1578** ;   Destroys: B,C,D,E,H,L,IX,SP,F
             1579** ;
0B09A2 DD    1580** POPS:			POP     IX              	; IX: Return address
0B09A3 E1 
0B09A4 69    1581** LD	L,C			; Temporarily store string length in L
0B09A5 01    1582** LD	BC,0
0B09A6 00 
0B09A7 00 
0B09A8 00 
0B09A9 4D    1583** LD	C,L			; BC: Number of bytes to copy
0B09AA 21    1584** LD      HL,0			; HL: 0
0B09AB 00 
0B09AC 00 
0B09AD 00 
0B09AE 39    1585** ADD     HL,SP			; HL: Stack address
0B09AF 11    1586** LD      DE,ACCS			; DE: Destination
0B09B0 00 
0B09B1 5B 
0B09B2 0B 
0B09B3 0C    1587** INC     C			; Quick check to see if this is a zero length string
0B09B4 0D    1588** DEC     C
0B09B5 28    1589** JR      Z,POPS1         	; Yes it is, so skip
0B09B6 02 
0B09B7 ED    1590** LDIR                    	; No, so copy from the stack
0B09B8 B0 
0B09B9 F9    1591** POPS1:			LD      SP,HL			; Shrink the stack
0B09BA DD    1592** JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B09BB E9 
             1593** ;
0B09BC FD    1594** HEXDIG:			LD      A,(IY)
0B09BD 7E 
0B09BE 00 
0B09BF FE    1595** CP      '0'
0B09C0 30 
0B09C1 D8    1596** RET     C
0B09C2 FE    1597** CP      '9'+1
0B09C3 3A 
0B09C4 3F    1598** CCF
0B09C5 D0    1599** RET     NC
0B09C6 FE    1600** CP      'A'
0B09C7 41 
0B09C8 D8    1601** RET     C
0B09C9 D6    1602** SUB     'A'-10
0B09CA 37 
0B09CB FE    1603** CP      16
0B09CC 10 
0B09CD 3F    1604** CCF
0B09CE C9    1605** RET
             1606** ;
0B09CF FD    1607** BINDIG:			LD	A,(IY)
0B09D0 7E 
0B09D1 00 
0B09D2 FE    1608** CP	'0'
0B09D3 30 
0B09D4 D8    1609** RET	C
0B09D5 FE    1610** CP	'1'+1
0B09D6 32 
0B09D7 3F    1611** CCF
0B09D8 C9    1612** RET
             1613** ;
0B09D9 FE    1614** RELOP?:			CP      '>'
0B09DA 3E 
0B09DB D0    1615** RET     NC
0B09DC FE    1616** CP      '='
0B09DD 3D 
0B09DE D0    1617** RET     NC
0B09DF FE    1618** CP      '<'
0B09E0 3C 
0B09E1 C9    1619** RET
             1620** ;
0B09E2 CD    1621** EXPRSC:			CALL    EXPRS
0B09E3 D9 
0B09E4 02 
0B09E5 0B 
0B09E6 CD    1622** COMMA:			CALL    NXT
0B09E7 34 
0B09E8 0A 
0B09E9 0B 
0B09EA FD    1623** INC     IY
0B09EB 23 
0B09EC FE    1624** CP      ','
0B09ED 2C 
0B09EE C8    1625** RET     Z
0B09EF 3E    1626** LD      A,5
0B09F0 05 
0B09F1 18    1627** JR      ERROR1_EV          ;"Missing ,"
0B09F2 0B 
             1628** ;
0B09F3 CD    1629** BRAKET:			CALL    NXT
0B09F4 34 
0B09F5 0A 
0B09F6 0B 
0B09F7 FD    1630** INC     IY
0B09F8 23 
0B09F9 FE    1631** CP      ')'
0B09FA 29 
0B09FB C8    1632** RET     Z
0B09FC 3E    1633** LD      A,27
0B09FD 1B 
0B09FE C3    1634** ERROR1_EV:			JP      ERROR_           ;"Missing )"
0B09FF 24 
0B0A00 37 
0B0A01 0B 
             1635** ;
0B0A02 FD    1636** SAVE_EV:			INC     IY
0B0A03 23 
0B0A04 08    1637** SAVE1:			EX      AF,AF'
0B0A05 FA    1638** JP      M,TYPE_EV_
0B0A06 FA 
0B0A07 02 
0B0A08 0B 
0B0A09 08    1639** EX      AF,AF'
0B0A0A E3    1640** EX      (SP),HL
0B0A0B D9    1641** EXX
0B0A0C E5    1642** PUSH    HL
0B0A0D D9    1643** EXX
0B0A0E F5    1644** PUSH    AF
0B0A0F C5    1645** PUSH    BC
0B0A10 E9    1646** JP      (HL)
             1647** ;
0B0A11 08    1648** DOIT:			EX      AF,AF'
0B0A12 FA    1649** JP      M,TYPE_EV_
0B0A13 FA 
0B0A14 02 
0B0A15 0B 
0B0A16 D9    1650** EXX
0B0A17 C1    1651** POP     BC              ;RETURN ADDRESS
0B0A18 D9    1652** EXX
0B0A19 79    1653** LD      A,C
0B0A1A C1    1654** POP     BC
0B0A1B 47    1655** LD      B,A
0B0A1C F1    1656** POP     AF              ;OPERATOR
0B0A1D D9    1657** EXX
0B0A1E EB    1658** EX      DE,HL
0B0A1F E1    1659** POP     HL
0B0A20 D9    1660** EXX
0B0A21 EB    1661** EX      DE,HL
0B0A22 E1    1662** POP     HL
0B0A23 D9    1663** EXX
0B0A24 C5    1664** PUSH    BC
0B0A25 D9    1665** EXX
0B0A26 E6    1666** AND     0FH
0B0A27 0F 
0B0A28 CD    1667** CALL    FPP
0B0A29 2E 
0B0A2A 20 
0B0A2B 0B 
0B0A2C 38    1668** JR      C,ERROR1_EV
0B0A2D D0 
0B0A2E AF    1669** XOR     A
0B0A2F 08    1670** EX      AF,AF'          ;TYPE
0B0A30 FD    1671** LD      A,(IY)
0B0A31 7E 
0B0A32 00 
0B0A33 C9    1672** RET
             1673** ;
             1674** ; Skip spaces
             1675** ; - IY: String pointer
             1676** ; Returns:
             1677** ;  - A: The non-space character found
             1678** ; - IY: Points to the character before that
             1679** ;
0B0A34 FD    1680** NXT:			LD      A,(IY)			; Fetch the character
0B0A35 7E 
0B0A36 00 
0B0A37 FE    1681** CP      ' '			; If it is space, then return
0B0A38 20 
0B0A39 C0    1682** RET     NZ
0B0A3A FD    1683** INC     IY			; Increment the pointer and
0B0A3B 23 
0B0A3C C3    1684** JP      NXT			; Loop
0B0A3D 34 
0B0A3E 0A 
0B0A3F 0B 
             1685** ;
0B0A40 E5    1686** DISPT2:			PUSH    HL
0B0A41 21    1687** LD      HL,SOPTBL
0B0A42 79 
0B0A43 01 
0B0A44 0B 
0B0A45 18    1688** JR      DISPT0
0B0A46 07 
             1689** ;
0B0A47 E5    1690** DISPAT:			PUSH    HL
0B0A48 D6    1691** SUB     FUNTOK
0B0A49 8D 
0B0A4A 21    1692** LD      HL,FUNTBL
0B0A4B CE 
0B0A4C 00 
0B0A4D 0B 
0B0A4E C5    1693** DISPT0:			PUSH    BC
             1694** 
0B0A4F 01    1695** LD	BC, 3
0B0A50 03 
0B0A51 00 
0B0A52 00 
0B0A53 47    1696** LD	B, A
0B0A54 ED    1697** MLT	BC
0B0A55 4C 
0B0A56 09    1698** ADD	HL, BC
0B0A57 ED    1699** LD	HL, (HL)
0B0A58 27 
             1700** 
             1701** ;			ADD     A,A
             1702** ;			LD      C,A
             1703** ;			LD      B,0
             1704** ;			ADD     HL,BC
             1705** ;			LD      A,(HL)
             1706** ;			INC     HL
             1707** ;			LD      H,(HL)
             1708** ;			LD      L,A
             1709** 
0B0A59 C1    1710** POP     BC
0B0A5A E3    1711** EX      (SP),HL
0B0A5B C9    1712** RET                     ;OFF TO ROUTINE
             1713** 
              0004* include "basic/exec.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Statement Execution & Assembler Module - "EXEC"
             0004** ; Author:	(C) Copyright  R.T.Russell  1984
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	12/05/2023
             0007** ; Last Updated:	26/06/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 27/01/1984:	Version 2.1
             0011** ; 02/03/1987:	Version 3.0
             0012** ; 11/06/1987:	Version 3.1
             0013** ; 12/05/2023:	Modified by Dean Belfield
             0014** ; 07/06/2023:	Modified to run in ADL mode
             0015** ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
             0016** 
             0017** ; .ASSUME	ADL = 1
             0018** 
             0019** ; INCLUDE	"equs.inc"
             0020** 
             0021** ; SEGMENT CODE
             0022** 
             0023** ; XDEF	XEQ
             0024** ; XDEF	CHAIN0
             0025** ; XDEF	RUN
             0026** ; XDEF	SYNTAX
             0027** ; XDEF	ESCAPE
             0028** ; XDEF	FN_EX
             0029** ; XDEF	USR
             0030** ; XDEF	STORE5
             0031** ; XDEF	STORE4
             0032** ; XDEF	CHECK
             0033** ; XDEF	TERMQ
             0034** ; XDEF	FILL
             0035** ; XDEF	X4OR5
             0036** ; XDEF	MUL16
             0037** ; XDEF	CHANEL
             0038** ; XDEF	ASSEM
             0039** 
             0040** ; XREF	AUTO
             0041** ; XREF	DELETE
             0042** ; XREF	LOAD
             0043** ; XREF	LIST_
             0044** ; XREF	NEW
             0045** ; XREF	OLD
             0046** ; XREF	RENUM
             0047** ; XREF	SAVE
             0048** ; XREF	SOUND
             0049** ; XREF	CLG
             0050** ; XREF	DRAW
             0051** ; XREF	ENVEL
             0052** ; XREF	GCOL
             0053** ; XREF	MODE
             0054** ; XREF	MOVE
             0055** ; XREF	PLOT
             0056** ; XREF	COLOUR
             0057** ; XREF	EXPRS
             0058** ; XREF	HIMEM
             0059** ; XREF	LOAD0
             0060** ; XREF	RANDOM
             0061** ; XREF	CLEAR
             0062** ; XREF	ERRTRP
             0063** ; XREF	PAGE_
             0064** ; XREF	DATAPTR
             0065** ; XREF	ERRLIN
             0066** ; XREF	TRAP
             0067** ; XREF	NXT
             0068** ; XREF	SETLIN
             0069** ; XREF	CLOOP
             0070** ; XREF	OSSHUT
             0071** ; XREF	WARM
             0072** ; XREF	TRACEN
             0073** ; XREF	OUTCHR
             0074** ; XREF	PBCDL
             0075** ; XREF	OSCLI
             0076** ; XREF	LISTON
             0077** ; XREF	GETVAR
             0078** ; XREF	PUTVAR
             0079** ; XREF	DATPTR
             0080** ; XREF	ERROR_
             0081** ; XREF	EXPR
             0082** ; XREF	CREATE
             0083** ; XREF	EXPRI
             0084** ; XREF	BRAKET
             0085** ; XREF	FREE
             0086** ; XREF	OSBPUT
             0087** ; XREF	COUNT
             0088** ; XREF	STR
             0089** ; XREF	HEXSTR
             0090** ; XREF	CRLF
             0091** ; XREF	ITEMI
             0092** ; XREF	FINDL
             0093** ; XREF	TEST
             0094** ; XREF	EXPRN
             0095** ; XREF	DLOAD5
             0096** ; XREF	DLOAD5_SPL
             0097** ; XREF	LOADN
             0098** ; XREF	FPP
             0099** ; XREF	SWAP
             0100** ; XREF	GETDEF
             0101** ; XREF	ZERO
             0102** ; XREF	OSBGET
             0103** ; XREF	BUFFER
             0104** ; XREF	CONS
             0105** ; XREF	VAL0
             0106** ; XREF	OSLINE
             0107** ; XREF	CLRSCN
             0108** ; XREF	TELL
             0109** ; XREF	SAYLN
             0110** ; XREF	REPORT
             0111** ; XREF	PUTPTR
             0112** ; XREF	PUTIME
             0113** ; XREF	PUTIMS
             0114** ; XREF	LOMEM
             0115** ; XREF	WIDTH
             0116** ; XREF	OSWRCH
             0117** ; XREF	COMMA
             0118** ; XREF	OSCALL
             0119** ; XREF	SFIX
             0120** ; XREF	LOAD4
             0121** ; XREF	PUSHS
             0122** ; XREF	POPS
             0123** ; XREF	LOADS
             0124** ; XREF	PUTCSR
             0125** ; XREF	OUT_
             0126** ; XREF	R0
             0127** ;
             0128** ; List of token values used in this module
             0129** ;
             0130** TAND:			EQU     80H
             0131** TOR:			EQU     84H
             0132** TERROR_EX:			EQU     85H
             0133** LINE_EX_:			EQU     86H
             0134** OFF_:			EQU     87H
             0135** STEP:			EQU     88H
             0136** SPC:			EQU     89H
             0137** TAB:			EQU     8AH
             0138** ELSE_EX_:			EQU     8BH
             0139** THEN_EX_:			EQU     8CH
             0140** LINO_EX:			EQU     8DH
             0141** TO_EX:			EQU     B8H
             0142** TCMD_EX:			EQU     C6H
             0143** TCALL:			EQU     D6H
             0144** DATA_EX_:			EQU     DCH
             0145** DEF_:			EQU     DDH
             0146** TGOSUB:			EQU     E4H
             0147** TGOTO:			EQU     E5H
             0148** TON:			EQU     EEH
             0149** TPROC:			EQU     F2H
             0150** TSTOP:			EQU     FAH
             0151** 
             0152** ; The command table
             0153** ; Commands are tokens from C6H onwards; this lookup table is used to
             0154** ; run the corresponding function; Note that DATA and DEF both use the same
             0155** ; code as REM
             0156** ;
0B0A5C AD    0157** CMDTAB:			DW24  AUTO			; C6H
0B0A5D 36 
0B0A5E 0B 
0B0A5F 10    0158** DW24  DELETE			; C7H
0B0A60 35 
0B0A61 0B 
0B0A62 EE    0159** DW24  LOAD			; C8H
0B0A63 36 
0B0A64 0B 
0B0A65 4B    0160** DW24  LIST_			; C9H
0B0A66 35 
0B0A67 0B 
0B0A68 CB    0161** DW24  NEW			; CAH
0B0A69 36 
0B0A6A 0B 
0B0A6B D1    0162** DW24  OLD			; CBH
0B0A6C 36 
0B0A6D 0B 
0B0A6E DA    0163** DW24  RENUM			; CCH
0B0A6F 35 
0B0A70 0B 
0B0A71 FF    0164** DW24  SAVE			; CDH
0B0A72 36 
0B0A73 0B 
0B0A74 6C    0165** DW24  PUT			; CEH
0B0A75 15 
0B0A76 0B 
0B0A77 8C    0166** DW24  PTR_EX			; CFH
0B0A78 13 
0B0A79 0B 
0B0A7A A6    0167** DW24  PAGEV_EX			; D0H
0B0A7B 13 
0B0A7C 0B 
0B0A7D B9    0168** DW24  TIMEV_EX			; D1H
0B0A7E 13 
0B0A7F 0B 
0B0A80 E2    0169** DW24  LOMEMV_EX			; D2H
0B0A81 13 
0B0A82 0B 
0B0A83 FB    0170** DW24  HIMEMV_EX			; D3H
0B0A84 13 
0B0A85 0B 
0B0A86 EA    0171** DW24  SOUND			; D4H
0B0A87 45 
0B0A88 0B 
0B0A89 86    0172** DW24  BPUT			; D5H
0B0A8A 14 
0B0A8B 0B 
0B0A8C 9E    0173** DW24  CALL_			; D6H
0B0A8D 14 
0B0A8E 0B 
0B0A8F 10    0174** DW24  CHAIN			; D7H
0B0A90 0B 
0B0A91 0B 
0B0A92 5B    0175** DW24  CLR			; D8H
0B0A93 13 
0B0A94 0B 
0B0A95 7A    0176** DW24  CLOSE			; D9H
0B0A96 14 
0B0A97 0B 
0B0A98 86    0177** DW24  CLG			; DAH
0B0A99 43 
0B0A9A 0B 
0B0A9B 2E    0178** DW24  CLS			; DBH
0B0A9C 13 
0B0A9D 0B 
0B0A9E EF    0179** DW24  REM_EX             		; DCH: DATA
0B0A9F 0B 
0B0AA0 0B 
0B0AA1 EF    0180** DW24  REM_EX             		; DDH: DEF
0B0AA2 0B 
0B0AA3 0B 
0B0AA4 B5    0181** DW24  DIM_EX			; DEH
0B0AA5 0C 
0B0AA6 0B 
0B0AA7 B0    0182** DW24  DRAW			; DFH
0B0AA8 45 
0B0AA9 0B 
0B0AAA 8A    0183** DW24  END_			; E0H
0B0AAB 0B 
0B0AAC 0B 
0B0AAD 46    0184** DW24  ENDPRO			; E1H
0B0AAE 11 
0B0AAF 0B 
0B0AB0 7B    0185** DW24  ENVEL			; E2H
0B0AB1 43 
0B0AB2 0B 
0B0AB3 5B    0186** DW24  FOR_EX			; E3H
0B0AB4 0F 
0B0AB5 0B 
0B0AB6 0B    0187** DW24  GOSUB_EX			; E4H
0B0AB7 0F 
0B0AB8 0B 
0B0AB9 EF    0188** DW24  GOTO_EX			; E5H
0B0ABA 0E 
0B0ABB 0B 
0B0ABC 44    0189** DW24  GCOL			; E6H
0B0ABD 45 
0B0ABE 0B 
0B0ABF FA    0190** DW24  IF_			; E7H
0B0AC0 12 
0B0AC1 0B 
0B0AC2 E8    0191** DW24  INPUT			; E8H
0B0AC3 11 
0B0AC4 0B 
0B0AC5 10    0192** DW24  LET			; E9H
0B0AC6 0C 
0B0AC7 0B 
0B0AC8 EB    0193** DW24  LOCAL_EX_			; EAH
0B0AC9 10 
0B0ACA 0B 
0B0ACB 96    0194** DW24  MODE			; EBH
0B0ACC 43 
0B0ACD 0B 
0B0ACE A8    0195** DW24  MOVE			; ECH
0B0ACF 45 
0B0AD0 0B 
0B0AD1 A9    0196** DW24  NEXT_EX			; EDH
0B0AD2 0F 
0B0AD3 0B 
0B0AD4 82    0197** DW24  ON_EX_			; EEH
0B0AD5 0E 
0B0AD6 0B 
0B0AD7 54    0198** DW24  VDU			; EFH
0B0AD8 14 
0B0AD9 0B 
0B0ADA 76    0199** DW24  PLOT			; F0H
0B0ADB 45 
0B0ADC 0B 
0B0ADD 8B    0200** DW24  PRINT_			; F1H
0B0ADE 0D 
0B0ADF 0B 
0B0AE0 48    0201** DW24  PROC_EX			; F2H
0B0AE1 10 
0B0AE2 0B 
0B0AE3 9A    0202** DW24  READ			; F3H
0B0AE4 12 
0B0AE5 0B 
0B0AE6 EF    0203** DW24  REM_EX			; F4H
0B0AE7 0B 
0B0AE8 0B 
0B0AE9 2B    0204** DW24  REPEAT_EX			; F5H
0B0AEA 0F 
0B0AEB 0B 
0B0AEC 53    0205** DW24  REPOR			; F6H
0B0AED 13 
0B0AEE 0B 
0B0AEF 65    0206** DW24  RESTOR_EX			; F7H
0B0AF0 13 
0B0AF1 0B 
0B0AF2 19    0207** DW24  RETURN			; F8H
0B0AF3 0F 
0B0AF4 0B 
0B0AF5 0A    0208** DW24  RUN			; F9H
0B0AF6 0B 
0B0AF7 0B 
0B0AF8 3B    0209** DW24  STOP			; FAH
0B0AF9 13 
0B0AFA 0B 
0B0AFB 92    0210** DW24  COLOUR			; FBH
0B0AFC 44 
0B0AFD 0B 
0B0AFE 36    0211** DW24  TRACE_EX			; FCH
0B0AFF 14 
0B0B00 0B 
0B0B01 35    0212** DW24  UNTIL_EX			; FDH
0B0B02 0F 
0B0B03 0B 
0B0B04 28    0213** DW24  WIDTHV			; FEH
0B0B05 14 
0B0B06 0B 
0B0B07 D5    0214** DW24  CLI             		; FFH: OSCLI
0B0B08 0B 
0B0B09 0B 
             0215** 
             0216** ; RUN
             0217** ; RUN "filename"
             0218** ;
0B0B0A CD    0219** RUN:			CALL    TERMQ			; Standalone RUN command?
0B0B0B 3E 
0B0B0C 17 
0B0B0D 0B 
0B0B0E 28    0220** JR      Z,RUN0			; Yes, so just RUN the code
0B0B0F 10 
             0221** 
             0222** ; CHAIN "filename"
             0223** ;
0B0B10 CD    0224** CHAIN:			CALL    EXPRS			; Get the filename
0B0B11 D9 
0B0B12 02 
0B0B13 0B 
0B0B14 3E    0225** LD      A,CR			; Terminate it with a CR
0B0B15 0D 
0B0B16 12    0226** LD      (DE),A
0B0B17 ED    0227** CHAIN0:			LD      SP,(HIMEM)		; Reset SP
0B0B18 7B 
0B0B19 20 
0B0B1A 5E 
0B0B1A 0B   
0B0B1C CD    0228** CALL    LOAD0			; And load the file in
0B0B1D E3 
0B0B1E 37 
0B0B1F 0B 
             0229** ;
0B0B20 ED    0230** RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
0B0B21 7B 
0B0B22 20 
0B0B23 5E 
0B0B23 0B   
0B0B25 DD    0231** LD      IX,RANDOM		; Pointer to the RANDOM sysvar
0B0B26 21 
0B0B27 38 
0B0B28 5E 
0B0B28 0B   
0B0B2A ED    0232** @@:			LD      A, R			; Use the R register to seed the random number generator
0B0B2B 5F 
0B0B2C 28    0233** JR      Z, @B			; Loop unti we get a non-zero value in A
0B0B2D FC 
0B0B2E 07    0234** RLCA				; Rotate it
0B0B2F 07    0235** RLCA
0B0B30 DD    0236** LD      (IX+3),A		; And store
0B0B31 77 
0B0B32 03 
0B0B33 9F    0237** SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
0B0B34 DD    0238** LD      (IX+4),A		; And store
0B0B35 77 
0B0B36 04 
0B0B37 CD    0239** CALL    CLEAR
0B0B38 3A 
0B0B39 38 
0B0B3A 0B 
0B0B3B 21    0240** LD      HL,0			; Clear the error trap sysvar
0B0B3C 00 
0B0B3D 00 
0B0B3E 00 
0B0B3F 22    0241** LD      (ERRTRP),HL
0B0B40 2C 
0B0B41 5E 
0B0B42 0B 
0B0B43 2A    0242** LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
0B0B44 14 
0B0B45 5E 
0B0B46 0B 
0B0B47 3E    0243** LD      A,DATA_EX_			; The DATA token value
0B0B48 DC 
0B0B49 CD    0244** CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
0B0B4A 12 
0B0B4B 18 
0B0B4C 0B 
0B0B4D 22    0245** LD      (DATPTR),HL     	; Set data pointer
0B0B4E 31 
0B0B4F 5E 
0B0B50 0B 
0B0B51 FD    0246** LD      IY,(PAGE_)		; Load IY with the start of program memory
0B0B52 2A 
0B0B53 14 
0B0B54 5E 
0B0B54 0B   
             0247** ;
0B0B56 CD    0248** XEQ0:			CALL    NEWLIN
0B0B57 9E 
0B0B58 0B 
0B0B59 0B 
0B0B5A FD    0249** XEQ:			LD      (ERRLIN),IY     	; Error pointer
0B0B5B 22 
0B0B5C 35 
0B0B5D 5E 
0B0B5D 0B   
0B0B5F CD    0250** CALL    TRAP           		; Check keyboard
0B0B60 31 
0B0B61 3F 
0B0B62 0B 
0B0B63 CD    0251** XEQ1:			CALL    NXT
0B0B64 34 
0B0B65 0A 
0B0B66 0B 
0B0B67 FD    0252** INC     IY
0B0B68 23 
0B0B69 FE    0253** CP      ':'             	; Seperator
0B0B6A 3A 
0B0B6B 28    0254** JR      Z,XEQ1
0B0B6C F6 
0B0B6D FE    0255** CP      CR
0B0B6E 0D 
0B0B6F 28    0256** JR      Z,XEQ0          	; New program line
0B0B70 E5 
0B0B71 D6    0257** SUB     TCMD_EX
0B0B72 C6 
0B0B73 DA    0258** JP      C,LET0          	; Implied "LET"
0B0B74 FE 
0B0B75 0B 
0B0B76 0B 
             0259** 
0B0B77 01    0260** LD	BC, 3
0B0B78 03 
0B0B79 00 
0B0B7A 00 
0B0B7B 47    0261** LD	B, A
0B0B7C ED    0262** MLT	BC
0B0B7D 4C 
0B0B7E 21    0263** LD	HL,CMDTAB
0B0B7F 5C 
0B0B80 0A 
0B0B81 0B 
0B0B82 09    0264** ADD	HL, BC
0B0B83 ED    0265** LD	HL, (HL)		; Table entry
0B0B84 27 
             0266** 
             0267** ;			ADD     A,A
             0268** ;			LD      C,A
             0269** ;			LD      B,0
             0270** ;			LD      HL,CMDTAB
             0271** ;			ADD     HL,BC
             0272** ;			LD      A,(HL)          	; Table entry
             0273** ;			INC     HL
             0274** ;			LD      H,(HL)
             0275** ;			LD      L,A
             0276** 
0B0B85 CD    0277** CALL    NXT
0B0B86 34 
0B0B87 0A 
0B0B88 0B 
0B0B89 E9    0278** JP      (HL)            	; Execute the statement
             0279** 
             0280** ;END
             0281** ;
0B0B8A CD    0282** END_:			CALL    SETLIN          ;FIND CURRENT LINE
0B0B8B 72 
0B0B8C 39 
0B0B8D 0B 
0B0B8E 7C    0283** LD      A,H
0B0B8F B5    0284** OR      L               ;DIRECT?
0B0B90 CA    0285** JP      Z,CLOOP
0B0B91 44 
0B0B92 30 
0B0B93 0B 
0B0B94 1E    0286** LD      E,0
0B0B95 00 
0B0B96 CD    0287** CALL    OSSHUT          ;CLOSE ALL FILES
0B0B97 EF 
0B0B98 42 
0B0B99 0B 
0B0B9A C3    0288** JP      WARM            ;"Ready"
0B0B9B 43 
0B0B9C 30 
0B0B9D 0B 
             0289** ;
0B0B9E FD    0290** NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
0B0B9F 7E 
0B0BA0 00 
0B0BA1 01    0291** LD      BC,3
0B0BA2 03 
0B0BA3 00 
0B0BA4 00 
0B0BA5 FD    0292** ADD     IY,BC
0B0BA6 09 
0B0BA7 B7    0293** OR      A
0B0BA8 28    0294** JR      Z,END_           ;LENGTH=0, EXIT
0B0BA9 E0 
0B0BAA 2A    0295** LD      HL,(TRACEN)
0B0BAB 26 
0B0BAC 5E 
0B0BAD 0B 
0B0BAE 7C    0296** LD      A,H
0B0BAF B5    0297** OR      L
0B0BB0 C8    0298** RET     Z
0B0BB1 11    0299** LD	DE, 0		;Clear DE
0B0BB2 00 
0B0BB3 00 
0B0BB4 00 
0B0BB5 FD    0300** LD      D,(IY-1)        ;DE = LINE NUMBER
0B0BB6 56 
0B0BB7 FF 
0B0BB8 FD    0301** LD      E,(IY-2)
0B0BB9 5E 
0B0BBA FE 
0B0BBB ED    0302** SBC     HL,DE
0B0BBC 52 
0B0BBD D8    0303** RET     C
0B0BBE EB    0304** EX      DE,HL
0B0BBF 3E    0305** LD      A,'['           ;TRACE
0B0BC0 5B 
0B0BC1 CD    0306** CALL    OUTCHR
0B0BC2 13 
0B0BC3 39 
0B0BC4 0B 
0B0BC5 CD    0307** CALL    PBCDL
0B0BC6 BB 
0B0BC7 39 
0B0BC8 0B 
0B0BC9 3E    0308** LD      A,']'
0B0BCA 5D 
0B0BCB CD    0309** CALL    OUTCHR
0B0BCC 13 
0B0BCD 39 
0B0BCE 0B 
0B0BCF 3E    0310** LD      A,' '
0B0BD0 20 
0B0BD1 C3    0311** JP      OUTCHR
0B0BD2 13 
0B0BD3 39 
0B0BD4 0B 
             0312** 
             0313** ; Routines for each statement -------------------------------------------------
             0314** 
             0315** ; OSCLI
             0316** ;
0B0BD5 CD    0317** CLI:			CALL    EXPRS
0B0BD6 D9 
0B0BD7 02 
0B0BD8 0B 
0B0BD9 3E    0318** LD      A,CR
0B0BDA 0D 
0B0BDB 12    0319** LD      (DE),A
0B0BDC 21    0320** LD      HL,ACCS
0B0BDD 00 
0B0BDE 5B 
0B0BDF 0B 
0B0BE0 CD    0321** CALL    OSCLI
0B0BE1 54 
0B0BE2 3F 
0B0BE3 0B 
0B0BE4 C3    0322** JP      XEQ
0B0BE5 5A 
0B0BE6 0B 
0B0BE7 0B 
             0323** 
             0324** ; REM, *
             0325** ;
0B0BE8 FD    0326** EXT_EX:			PUSH    IY
0B0BE9 E5 
0B0BEA E1    0327** POP     HL
0B0BEB CD    0328** CALL    OSCLI
0B0BEC 54 
0B0BED 3F 
0B0BEE 0B 
0B0BEF FD    0329** REM_EX:			PUSH    IY
0B0BF0 E5 
0B0BF1 E1    0330** POP     HL
0B0BF2 3E    0331** LD      A,CR
0B0BF3 0D 
0B0BF4 47    0332** LD      B,A
0B0BF5 ED    0333** CPIR                    ;FIND LINE END
0B0BF6 B1 
0B0BF7 E5    0334** PUSH    HL
0B0BF8 FD    0335** POP     IY
0B0BF9 E1 
0B0BFA C3    0336** JP      XEQ0
0B0BFB 56 
0B0BFC 0B 
0B0BFD 0B 
             0337** 
             0338** ; [LET] var = expr
             0339** ;
0B0BFE FE    0340** LET0:			CP      ELSE_EX_-TCMD_EX
0B0BFF C5 
0B0C00 28    0341** JR      Z,REM_EX
0B0C01 ED 
             0342** ; CP      ('*'-TCMD) & 0FFH
             0343** ; JR      Z,EXT_EX
             0344** ; CP      ('='-TCMD) & 0FFH
             0345** ; JR      Z,FNEND
             0346** ; CP      ('['-TCMD) & 0FFH
             0347** ; ez80asm doesn't like () in expressions
0B0C02 FE    0348** CP      '*'-TCMD_EX & 0FFH
0B0C03 64 
0B0C04 28    0349** JR      Z,EXT_EX
0B0C05 E2 
0B0C06 FE    0350** CP      '='-TCMD_EX & 0FFH
0B0C07 77 
0B0C08 28    0351** JR      Z,FNEND
0B0C09 5B 
0B0C0A FE    0352** CP      '['-TCMD_EX & 0FFH
0B0C0B 95 
0B0C0C 28    0353** JR      Z,ASM
0B0C0D 25 
0B0C0E FD    0354** DEC     IY
0B0C0F 2B 
0B0C10 CD    0355** LET:			CALL    ASSIGN			; Assign the variable
0B0C11 82 
0B0C12 15 
0B0C13 0B 
0B0C14 CA    0356** JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
0B0C15 5A 
0B0C16 0B 
0B0C17 0B 
0B0C18 38    0357** JR      C,SYNTAX        	; Return if C as it is an illegal variable
0B0C19 41 
             0358** ;
0B0C1A F5    0359** PUSH    AF              	; At this point we're dealing with a string type (A=81h)
0B0C1B CD    0360** CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B0C1C 54 
0B0C1D 17 
0B0C1E 0B 
0B0C1F E5    0361** PUSH    HL			; HL: Address of the variable
0B0C20 CD    0362** CALL    EXPRS
0B0C21 D9 
0B0C22 02 
0B0C23 0B 
0B0C24 DD    0363** POP     IX			; IX: Address of the variable
0B0C25 E1 
0B0C26 F1    0364** POP     AF			; AF: The variable type
0B0C27 CD    0365** CALL    STACCS			; Copy the string from ACCS to the variable area
0B0C28 C4 
0B0C29 15 
0B0C2A 0B 
0B0C2B C3    0366** XEQR:			JP      XEQ
0B0C2C 5A 
0B0C2D 0B 
0B0C2E 0B 
             0367** ;
0B0C2F CD    0368** ASM0:			CALL    NEWLIN
0B0C30 9E 
0B0C31 0B 
0B0C32 0B 
0B0C33 FD    0369** ASM:			LD      (ERRLIN),IY
0B0C34 22 
0B0C35 35 
0B0C36 5E 
0B0C36 0B   
0B0C38 CD    0370** CALL    TRAP
0B0C39 31 
0B0C3A 3F 
0B0C3B 0B 
0B0C3C CD    0371** CALL    ASSEM
0B0C3D 5F 
0B0C3E 18 
0B0C3F 0B 
0B0C40 38    0372** JR      C,SYNTAX
0B0C41 19 
0B0C42 FE    0373** CP      CR
0B0C43 0D 
0B0C44 28    0374** JR      Z,ASM0
0B0C45 E9 
0B0C46 21    0375** LD      HL,LISTON
0B0C47 40 
0B0C48 5E 
0B0C49 0B 
0B0C4A 7E    0376** LD      A,(HL)
0B0C4B E6    0377** AND     0FH
0B0C4C 0F 
0B0C4D F6    0378** OR      B0H
0B0C4E B0 
0B0C4F 77    0379** LD      (HL),A
0B0C50 18    0380** JR      XEQR
0B0C51 D9 
             0381** ;
0B0C52 CD    0382** VAR_:			CALL    GETVAR
0B0C53 FE 
0B0C54 39 
0B0C55 0B 
0B0C56 C8    0383** RET     Z
0B0C57 D2    0384** JP      NC,PUTVAR
0B0C58 ED 
0B0C59 39 
0B0C5A 0B 
0B0C5B 3E    0385** SYNTAX:			LD      A,16            ;"Syntax error"
0B0C5C 10 
0B0C5D 18    0386** JR	ERROR0_EX
0B0C5E 02 
0B0C5F 3E    0387** ESCAPE:			LD      A,17            ;"Escape"
0B0C60 11 
0B0C61 C3    0388** ERROR0_EX:			JP      ERROR_
0B0C62 24 
0B0C63 37 
0B0C64 0B 
             0389** 
             0390** ; =
             0391** ;
0B0C65 CD    0392** FNEND:			CALL    EXPR            ;FUNCTION RESULT
0B0C66 8B 
0B0C67 01 
0B0C68 0B 
0B0C69 43    0393** LD      B,E
0B0C6A EB    0394** EX      DE,HL
0B0C6B D9    0395** EXX                     ;SAVE RESULT
0B0C6C EB    0396** EX      DE,HL           ; IN DEB'C'D'E'
0B0C6D C1    0397** FNEND5:			POP     BC
0B0C6E 21    0398** LD      HL,LOCCHK
0B0C6F 1C 
0B0C70 17 
0B0C71 0B 
0B0C72 B7    0399** OR      A
0B0C73 ED    0400** SBC     HL,BC
0B0C74 42 
0B0C75 28    0401** JR      Z,FNEND0        ;LOCAL VARIABLE
0B0C76 1C 
0B0C77 21    0402** LD      HL,FNCHK
0B0C78 48 
0B0C79 10 
0B0C7A 0B 
0B0C7B B7    0403** OR      A
0B0C7C ED    0404** SBC     HL,BC
0B0C7D 42 
0B0C7E 3E    0405** LD      A,7
0B0C7F 07 
0B0C80 20    0406** JR      NZ,ERROR0_EX       ;"No FN"
0B0C81 DF 
0B0C82 FD    0407** POP     IY
0B0C83 E1 
0B0C84 FD    0408** LD      (ERRLIN),IY     ;IN CASE OF ERROR
0B0C85 22 
0B0C86 35 
0B0C87 5E 
0B0C87 0B   
0B0C89 EB    0409** EX      DE,HL
0B0C8A D9    0410** EXX
0B0C8B EB    0411** EX      DE,HL
0B0C8C 11    0412** LD      DE,ACCS
0B0C8D 00 
0B0C8E 5B 
0B0C8F 0B 
0B0C90 58    0413** LD      E,B
0B0C91 08    0414** EX      AF,AF'
0B0C92 C9    0415** RET
             0416** ;
0B0C93 DD    0417** FNEND0:			POP     IX
0B0C94 E1 
0B0C95 C1    0418** POP     BC
0B0C96 78    0419** LD      A,B
0B0C97 B7    0420** OR      A
0B0C98 FA    0421** JP      M,FNEND1        ;STRING
0B0C99 A6 
0B0C9A 0C 
0B0C9B 0B 
0B0C9C E1    0422** POP     HL
0B0C9D D9    0423** EXX
0B0C9E E1    0424** POP     HL
0B0C9F D9    0425** EXX
0B0CA0 CD    0426** CALL    STORE
0B0CA1 9A 
0B0CA2 15 
0B0CA3 0B 
0B0CA4 18    0427** JR      FNEND5
0B0CA5 C7 
0B0CA6 21    0428** FNEND1:			LD      HL,0
0B0CA7 00 
0B0CA8 00 
0B0CA9 00 
0B0CAA 39    0429** ADD     HL,SP
0B0CAB D5    0430** PUSH    DE
0B0CAC 59    0431** LD      E,C
0B0CAD CD    0432** CALL    STORES
0B0CAE C8 
0B0CAF 15 
0B0CB0 0B 
0B0CB1 D1    0433** POP     DE
0B0CB2 F9    0434** LD      SP,HL
0B0CB3 18    0435** JR      FNEND5
0B0CB4 B8 
             0436** 
             0437** ; DIM var(dim1[,dim2[,...]])[,var(...]
             0438** ; DIM var expr[,var expr...]
             0439** ;
0B0CB5 CD    0440** DIM_EX:			CALL    GETVAR          	; Get the variable
0B0CB6 FE 
0B0CB7 39 
0B0CB8 0B 
0B0CB9 DA    0441** JP      C,BADDIM		; Throw a "Bad Dim" error
0B0CBA 45 
0B0CBB 0D 
0B0CBC 0B 
0B0CBD CA    0442** JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
0B0CBE 4F 
0B0CBF 0D 
0B0CC0 0B 
0B0CC1 CD    0443** CALL    CREATE			; Create a new entity
0B0CC2 72 
0B0CC3 3B 
0B0CC4 0B 
0B0CC5 E5    0444** PUSH    HL			; HL: Address of the entity
0B0CC6 DD    0445** POP     IX			; IX: Address of the entity
0B0CC7 E1 
0B0CC8 FD    0446** LD      A,(IY)			; Fetch the next character from the tokenised string
0B0CC9 7E 
0B0CCA 00 
0B0CCB FE    0447** CP      '('			; Check for opening brackets
0B0CCC 28 
0B0CCD 7A    0448** LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
0B0CCE 20    0449** JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
0B0CCF 7F 
             0450** ;
             0451** ; At this point we're reserving a variable array
             0452** ;
0B0CD0 E5    0453** PUSH    HL			; HL: Address of the entity
0B0CD1 F5    0454** PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
0B0CD2 11    0455** LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
0B0CD3 01 
0B0CD4 00 
0B0CD5 00 
0B0CD6 42    0456** LD      B,D			;  B: The number of dimensions in the array
             0457** ;
0B0CD7 FD    0458** DIM1:			INC     IY			; Skip to the next token
0B0CD8 23 
0B0CD9 C5    0459** PUSH    BC			; Stack the dimension counter
0B0CDA D5    0460** PUSH    DE			; Stack the total size of array accumulator
0B0CDB DD    0461** PUSH    IX			; Stack the entity address
0B0CDC E5 
0B0CDD CD    0462** CALL    EXPRI           	; Fetch the size of this dimension
0B0CDE CE 
0B0CDF 02 
0B0CE0 0B 
0B0CE1 CB    0463** BIT     7,H			; If it is negative then
0B0CE2 7C 
0B0CE3 20    0464** JR      NZ,BADDIM		; Throw a "Bad Dim" error
0B0CE4 60 
0B0CE5 D9    0465** EXX
0B0CE6 23    0466** INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
0B0CE7 DD    0467** POP     IX			; IX: The entity address
0B0CE8 E1 
0B0CE9 DD    0468** INC     IX
0B0CEA 23 
0B0CEB DD    0469** LD      (IX),L          	; Save the size of this dimension in the entity
0B0CEC 75 
0B0CED 00 
0B0CEE DD    0470** INC     IX
0B0CEF 23 
0B0CF0 DD    0471** LD      (IX),H
0B0CF1 74 
0B0CF2 00 
0B0CF3 C1    0472** POP     BC
0B0CF4 CD    0473** CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
0B0CF5 36 
0B0CF6 18 
0B0CF7 0B 
0B0CF8 38    0474** JR      C,NOROOM        	; Throw a "No Room" error if overflow
0B0CF9 4F 
0B0CFA EB    0475** EX      DE,HL           	; DE: The new total size of array accumulator
0B0CFB C1    0476** POP     BC
0B0CFC 04    0477** INC     B               	;  B: The dimension counter; increment
0B0CFD FD    0478** LD      A,(IY)			; Fetch the nex token
0B0CFE 7E 
0B0CFF 00 
0B0D00 FE    0479** CP      ','             	; Check for another dimension in the array
0B0D01 2C 
0B0D02 28    0480** JR      Z,DIM1			; And loop
0B0D03 D3 
             0481** ;
0B0D04 CD    0482** CALL    BRAKET          	; Check for closing bracket
0B0D05 F3 
0B0D06 09 
0B0D07 0B 
0B0D08 F1    0483** POP     AF              	; Restore the type
0B0D09 DD    0484** INC     IX
0B0D0A 23 
0B0D0B DD    0485** EX      (SP),IX
0B0D0C E3 
0B0D0D DD    0486** LD      (IX),B          	; Number of dimensions
0B0D0E 70 
0B0D0F 00 
0B0D10 CD    0487** CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
0B0D11 29 
0B0D12 18 
0B0D13 0B 
0B0D14 E1    0488** POP     HL			; Restore the entity address
0B0D15 38    0489** JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
0B0D16 32 
             0490** ;
             0491** ; We now allocate the memory for the array
             0492** ;
0B0D17 19    0493** DIM3:			ADD     HL,DE
0B0D18 38    0494** JR      C,NOROOM
0B0D19 2F 
0B0D1A E5    0495** PUSH    HL
0B0D1B 24    0496** INC     H
0B0D1C 28    0497** JR      Z,NOROOM
0B0D1D 2B 
0B0D1E ED    0498** SBC     HL,SP
0B0D1F 72 
0B0D20 30    0499** JR      NC,NOROOM       	; Throw an "Out of Space" error
0B0D21 27 
0B0D22 E1    0500** POP     HL
0B0D23 22    0501** LD      (FREE),HL
0B0D24 1D 
0B0D25 5E 
0B0D26 0B 
0B0D27 7A    0502** DIM2:			LD      A,D
0B0D28 B3    0503** OR      E
0B0D29 28    0504** JR      Z,DIM5
0B0D2A 06 
0B0D2B 2B    0505** DEC     HL
0B0D2C 36    0506** LD      (HL),0         		; Initialise the array
0B0D2D 00 
0B0D2E 1B    0507** DEC     DE
0B0D2F 18    0508** JR      DIM2
0B0D30 F6 
0B0D31 CD    0509** DIM5:			CALL    NXT
0B0D32 34 
0B0D33 0A 
0B0D34 0B 
0B0D35 FE    0510** CP      ','            		; Another variable?
0B0D36 2C 
0B0D37 C2    0511** JP      NZ,XEQ
0B0D38 5A 
0B0D39 0B 
0B0D3A 0B 
0B0D3B FD    0512** INC     IY
0B0D3C 23 
0B0D3D CD    0513** CALL    NXT
0B0D3E 34 
0B0D3F 0A 
0B0D40 0B 
0B0D41 C3    0514** JP      DIM_EX
0B0D42 B5 
0B0D43 0C 
0B0D44 0B 
             0515** ;
             0516** ; DIM errors
             0517** ;
0B0D45 3E    0518** BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
0B0D46 0A 
0B0D47 18    0519** JR	ERROR1_EX
0B0D48 02 
0B0D49 3E    0520** NOROOM:			LD      A,11            	; Throw a "DIM space" error
0B0D4A 0B 
0B0D4B C3    0521** ERROR1_EX:			JP      ERROR_
0B0D4C 24 
0B0D4D 37 
0B0D4E 0B 
             0522** ;
             0523** ; At this point we're reserving a block of memory, i.e.
             0524** ; DIM var expr[,var expr...]
             0525** ;
0B0D4F B7    0526** DIM4:			OR      A			;  A: The dimension variable type
0B0D50 28    0527** JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
0B0D51 F3 
0B0D52 FA    0528** JP      M,BADDIM        	; or a string
0B0D53 45 
0B0D54 0D 
0B0D55 0B 
0B0D56 47    0529** LD      B,A			; Temporarily store the dimension variable type in B
0B0D57 FD    0530** LD      A,(IY-1)		; Get the last character but one
0B0D58 7E 
0B0D59 FF 
0B0D5A FE    0531** CP      ')'			; Check if it is a trailing bracket
0B0D5B 29 
0B0D5C 28    0532** JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
0B0D5D E7 
             0533** ;
0B0D5E 21    0534** LD	HL,0			; Clear HL
0B0D5F 00 
0B0D60 00 
0B0D61 00 
0B0D62 3A    0535** LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
0B0D63 1D 
0B0D64 5E 
0B0D65 0B 
0B0D66 6F    0536** LD	L,A
0B0D67 3A    0537** LD	A,(FREE+1)
0B0D68 1E 
0B0D69 5E 
0B0D6A 0B 
0B0D6B 67    0538** LD	H,A
0B0D6C 78    0539** LD	A,B			; Restore the dimension variable type
0B0D6D D9    0540** EXX
0B0D6E 21    0541** LD	HL,0			; Clear HL
0B0D6F 00 
0B0D70 00 
0B0D71 00 
0B0D72 47    0542** LD	B,A			; Temporarily store the dimension variable type in B
0B0D73 3A    0543** LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
0B0D74 1F 
0B0D75 5E 
0B0D76 0B 
0B0D77 6F    0544** LD	L,A
0B0D78 78    0545** LD	A,B			; Restore the dimension variable type
0B0D79 4C    0546** LD	C,H
0B0D7A CD    0547** CALL    STORE           	; Store the address
0B0D7B 9A 
0B0D7C 15 
0B0D7D 0B 
0B0D7E CD    0548** CALL    EXPRI			; Get the number of bytes to store
0B0D7F CE 
0B0D80 02 
0B0D81 0B 
0B0D82 D9    0549** EXX
0B0D83 23    0550** INC     HL			; Add one to it
0B0D84 EB    0551** EX      DE,HL
0B0D85 2A    0552** LD      HL,(FREE)
0B0D86 1D 
0B0D87 5E 
0B0D88 0B 
0B0D89 18    0553** JR      DIM3			; Continue with the DIM
0B0D8A 8C 
             0554** 
             0555** ; PRINT list...
             0556** ; PRINT #channel,list...
             0557** ;
0B0D8B FE    0558** PRINT_:			CP      '#'
0B0D8C 23 
0B0D8D 20    0559** JR      NZ,PRINT0
0B0D8E 7C 
0B0D8F CD    0560** CALL    CHNL            ;CHANNEL NO. = E
0B0D90 56 
0B0D91 18 
0B0D92 0B 
0B0D93 CD    0561** PRNTN1:			CALL    NXT
0B0D94 34 
0B0D95 0A 
0B0D96 0B 
0B0D97 FE    0562** CP      ','
0B0D98 2C 
0B0D99 C2    0563** JP      NZ,XEQ
0B0D9A 5A 
0B0D9B 0B 
0B0D9C 0B 
0B0D9D FD    0564** INC     IY
0B0D9E 23 
0B0D9F D5    0565** PUSH    DE
0B0DA0 CD    0566** CALL    EXPR            ;ITEM TO PRINT
0B0DA1 8B 
0B0DA2 01 
0B0DA3 0B 
0B0DA4 08    0567** EX      AF,AF'
0B0DA5 FA    0568** JP      M,PRNTN2        ;STRING
0B0DA6 CB 
0B0DA7 0D 
0B0DA8 0B 
0B0DA9 D1    0569** POP     DE
0B0DAA C5    0570** PUSH    BC
0B0DAB D9    0571** EXX
0B0DAC 7D    0572** LD      A,L
0B0DAD D9    0573** EXX
0B0DAE CD    0574** CALL    OSBPUT
0B0DAF FF 
0B0DB0 42 
0B0DB1 0B 
0B0DB2 D9    0575** EXX
0B0DB3 7C    0576** LD      A,H
0B0DB4 D9    0577** EXX
0B0DB5 CD    0578** CALL    OSBPUT
0B0DB6 FF 
0B0DB7 42 
0B0DB8 0B 
0B0DB9 7D    0579** LD      A,L
0B0DBA CD    0580** CALL    OSBPUT
0B0DBB FF 
0B0DBC 42 
0B0DBD 0B 
0B0DBE 7C    0581** LD      A,H
0B0DBF CD    0582** CALL    OSBPUT
0B0DC0 FF 
0B0DC1 42 
0B0DC2 0B 
0B0DC3 C1    0583** POP     BC
0B0DC4 79    0584** LD      A,C
0B0DC5 CD    0585** CALL    OSBPUT
0B0DC6 FF 
0B0DC7 42 
0B0DC8 0B 
0B0DC9 18    0586** JR      PRNTN1
0B0DCA C8 
0B0DCB 4B    0587** PRNTN2:			LD      C,E
0B0DCC D1    0588** POP     DE
0B0DCD 21    0589** LD      HL,ACCS
0B0DCE 00 
0B0DCF 5B 
0B0DD0 0B 
0B0DD1 0C    0590** INC     C
0B0DD2 0D    0591** PRNTN3:			DEC     C
0B0DD3 28    0592** JR      Z,PRNTN4
0B0DD4 0A 
0B0DD5 7E    0593** LD      A,(HL)
0B0DD6 23    0594** INC     HL
0B0DD7 C5    0595** PUSH    BC
0B0DD8 CD    0596** CALL    OSBPUT
0B0DD9 FF 
0B0DDA 42 
0B0DDB 0B 
0B0DDC C1    0597** POP     BC
0B0DDD 18    0598** JR      PRNTN3
0B0DDE F3 
0B0DDF 3E    0599** PRNTN4:			LD      A,CR
0B0DE0 0D 
0B0DE1 CD    0600** CALL    OSBPUT
0B0DE2 FF 
0B0DE3 42 
0B0DE4 0B 
0B0DE5 18    0601** JR      PRNTN1
0B0DE6 AC 
             0602** ;
0B0DE7 06    0603** PRINT6:			LD      B,2
0B0DE8 02 
0B0DE9 18    0604** JR      PRINTC
0B0DEA 27 
0B0DEB 01    0605** PRINT8:			LD      BC,100H
0B0DEC 00 
0B0DED 01 
0B0DEE 00 
0B0DEF 18    0606** JR      PRINTC
0B0DF0 21 
0B0DF1 21    0607** PRINT9:			LD      HL,STAVAR
0B0DF2 00 
0B0DF3 5D 
0B0DF4 0B 
0B0DF5 AF    0608** XOR     A
0B0DF6 BE    0609** CP      (HL)
0B0DF7 28    0610** JR      Z,PRINT0
0B0DF8 12 
0B0DF9 3A    0611** LD      A,(COUNT)
0B0DFA 3D 
0B0DFB 5E 
0B0DFC 0B 
0B0DFD B7    0612** OR      A
0B0DFE 28    0613** JR      Z,PRINT0
0B0DFF 0B 
0B0E00 96    0614** PRINTA:			SUB     (HL)
0B0E01 28    0615** JR      Z,PRINT0
0B0E02 08 
0B0E03 30    0616** JR      NC,PRINTA
0B0E04 FB 
0B0E05 ED    0617** NEG
0B0E06 44 
0B0E07 CD    0618** CALL    FILL
0B0E08 B3 
0B0E09 17 
0B0E0A 0B 
0B0E0B 3A    0619** PRINT0:			LD      A,(STAVAR)
0B0E0C 00 
0B0E0D 5D 
0B0E0E 0B 
0B0E0F 4F    0620** LD      C,A             ;PRINTS
0B0E10 06    0621** LD      B,0             ;PRINTF
0B0E11 00 
0B0E12 CD    0622** PRINTC:			CALL    TERMQ
0B0E13 3E 
0B0E14 17 
0B0E15 0B 
0B0E16 28    0623** JR      Z,PRINT4
0B0E17 3F 
0B0E18 CB    0624** RES     0,B
0B0E19 80 
0B0E1A FD    0625** INC     IY
0B0E1B 23 
0B0E1C FE    0626** CP      '~'
0B0E1D 7E 
0B0E1E 28    0627** JR      Z,PRINT6
0B0E1F C7 
0B0E20 FE    0628** CP      ';'
0B0E21 3B 
0B0E22 28    0629** JR      Z,PRINT8
0B0E23 C7 
0B0E24 FE    0630** CP      ','
0B0E25 2C 
0B0E26 28    0631** JR      Z,PRINT9
0B0E27 C9 
0B0E28 CD    0632** CALL    FORMAT          ;SPC, TAB, '
0B0E29 63 
0B0E2A 17 
0B0E2B 0B 
0B0E2C 28    0633** JR      Z,PRINTC
0B0E2D E4 
0B0E2E FD    0634** DEC     IY
0B0E2F 2B 
0B0E30 C5    0635** PUSH    BC
0B0E31 CD    0636** CALL    EXPR            ;VARIABLE TYPE
0B0E32 8B 
0B0E33 01 
0B0E34 0B 
0B0E35 08    0637** EX      AF,AF'
0B0E36 FA    0638** JP      M,PRINT3        ;STRING
0B0E37 50 
0B0E38 0E 
0B0E39 0B 
0B0E3A D1    0639** POP     DE
0B0E3B D5    0640** PUSH    DE
0B0E3C CB    0641** BIT     1,D
0B0E3D 4A 
0B0E3E F5    0642** PUSH    AF
0B0E3F CC    0643** CALL    Z,STR           ;DECIMAL
0B0E40 2A 
0B0E41 09 
0B0E42 0B 
0B0E43 F1    0644** POP     AF
0B0E44 C4    0645** CALL    NZ,HEXSTR       ;HEX
0B0E45 DE 
0B0E46 08 
0B0E47 0B 
0B0E48 C1    0646** POP     BC
0B0E49 C5    0647** PUSH    BC
0B0E4A 79    0648** LD      A,C
0B0E4B 93    0649** SUB     E
0B0E4C D4    0650** CALL    NC,FILL         ;RIGHT JUSTIFY
0B0E4D B3 
0B0E4E 17 
0B0E4F 0B 
0B0E50 C1    0651** PRINT3:			POP     BC
0B0E51 CD    0652** CALL    PTEXT           ;PRINT
0B0E52 C2 
0B0E53 17 
0B0E54 0B 
0B0E55 18    0653** JR      PRINTC
0B0E56 BB 
0B0E57 CB    0654** PRINT4:			BIT     0,B
0B0E58 40 
0B0E59 CC    0655** CALL    Z,CRLF
0B0E5A 0B 
0B0E5B 39 
0B0E5C 0B 
0B0E5D C3    0656** JP      XEQ
0B0E5E 5A 
0B0E5F 0B 
0B0E60 0B 
             0657** 
             0658** ; ON ERROR statement [:statement...]
             0659** ; ON ERROR OFF
             0660** ;
0B0E61 FD    0661** ONERR:			INC     IY              ;SKIP "ERROR"
0B0E62 23 
0B0E63 21    0662** LD      HL,0
0B0E64 00 
0B0E65 00 
0B0E66 00 
0B0E67 22    0663** LD      (ERRTRP),HL
0B0E68 2C 
0B0E69 5E 
0B0E6A 0B 
0B0E6B CD    0664** CALL    NXT
0B0E6C 34 
0B0E6D 0A 
0B0E6E 0B 
0B0E6F FE    0665** CP      OFF_
0B0E70 87 
0B0E71 FD    0666** INC     IY
0B0E72 23 
0B0E73 CA    0667** JP      Z,XEQ
0B0E74 5A 
0B0E75 0B 
0B0E76 0B 
0B0E77 FD    0668** DEC     IY
0B0E78 2B 
0B0E79 FD    0669** LD      (ERRTRP),IY
0B0E7A 22 
0B0E7B 2C 
0B0E7C 5E 
0B0E7C 0B   
0B0E7E C3    0670** JP      REM_EX
0B0E7F EF 
0B0E80 0B 
0B0E81 0B 
             0671** 
             0672** ; ON expr GOTO line[,line...] [ELSE statement]
             0673** ; ON expr GOTO line[,line...] [ELSE line]
             0674** ; ON expr GOSUB line[,line...] [ELSE statement]
             0675** ; ON expr GOSUB line[,line...] [ELSE line]
             0676** ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
             0677** ;
0B0E82 FE    0678** ON_EX_:			CP      TERROR_EX
0B0E83 85 
0B0E84 28    0679** JR      Z,ONERR         ;"ON ERROR"
0B0E85 DB 
0B0E86 CD    0680** CALL    EXPRI
0B0E87 CE 
0B0E88 02 
0B0E89 0B 
0B0E8A FD    0681** LD      A,(IY)
0B0E8B 7E 
0B0E8C 00 
0B0E8D FD    0682** INC     IY
0B0E8E 23 
0B0E8F 1E    0683** LD      E,','           ;SEPARATOR
0B0E90 2C 
0B0E91 FE    0684** CP      TGOTO
0B0E92 E5 
0B0E93 28    0685** JR      Z,ON1
0B0E94 0B 
0B0E95 FE    0686** CP      TGOSUB
0B0E96 E4 
0B0E97 28    0687** JR      Z,ON1
0B0E98 07 
0B0E99 1E    0688** LD      E,TPROC
0B0E9A F2 
0B0E9B BB    0689** CP      E
0B0E9C 3E    0690** LD      A,39
0B0E9D 27 
0B0E9E 20    0691** JR      NZ,ERROR2_EX       ;"ON syntax"
0B0E9F 45 
0B0EA0 57    0692** ON1:			LD      D,A
0B0EA1 D9    0693** EXX
0B0EA2 E5    0694** PUSH    HL
0B0EA3 D9    0695** EXX
0B0EA4 C1    0696** POP     BC              ;ON INDEX
0B0EA5 78    0697** LD      A,B
0B0EA6 B4    0698** OR      H
0B0EA7 B5    0699** OR      L
0B0EA8 20    0700** JR      NZ,ON4          ;OUT OF RANGE
0B0EA9 2A 
0B0EAA B1    0701** OR      C
0B0EAB 28    0702** JR      Z,ON4
0B0EAC 27 
0B0EAD 0D    0703** DEC     C
0B0EAE 28    0704** JR      Z,ON3           ;INDEX=1
0B0EAF 0E 
0B0EB0 CD    0705** ON2:			CALL    TERMQ
0B0EB1 3E 
0B0EB2 17 
0B0EB3 0B 
0B0EB4 28    0706** JR      Z,ON4           ;OUT OF RANGE
0B0EB5 1E 
0B0EB6 FD    0707** INC     IY              ;SKIP DELIMITER
0B0EB7 23 
0B0EB8 BB    0708** CP      E
0B0EB9 20    0709** JR      NZ,ON2
0B0EBA F5 
0B0EBB 0D    0710** DEC     C
0B0EBC 20    0711** JR      NZ,ON2
0B0EBD F2 
0B0EBE 7B    0712** ON3:			LD      A,E
0B0EBF FE    0713** CP      TPROC
0B0EC0 F2 
0B0EC1 28    0714** JR      Z,ONPROC
0B0EC2 26 
0B0EC3 D5    0715** PUSH    DE
0B0EC4 CD    0716** CALL    ITEMI           ;LINE NUMBER
0B0EC5 E9 
0B0EC6 02 
0B0EC7 0B 
0B0EC8 D1    0717** POP     DE
0B0EC9 7A    0718** LD      A,D
0B0ECA FE    0719** CP      TGOTO
0B0ECB E5 
0B0ECC 28    0720** JR      Z,GOTO2
0B0ECD 2D 
0B0ECE CD    0721** CALL    SPAN            ;SKIP REST OF LIST
0B0ECF 4B 
0B0ED0 17 
0B0ED1 0B 
0B0ED2 18    0722** JR      GOSUB1
0B0ED3 3B 
             0723** ;
0B0ED4 FD    0724** ON4:			LD      A,(IY)
0B0ED5 7E 
0B0ED6 00 
0B0ED7 FD    0725** INC     IY
0B0ED8 23 
0B0ED9 FE    0726** CP      ELSE_EX_
0B0EDA 8B 
0B0EDB CA    0727** JP      Z,IF1           ;ELSE CLAUSE
0B0EDC 0F 
0B0EDD 13 
0B0EDE 0B 
0B0EDF FE    0728** CP      CR
0B0EE0 0D 
0B0EE1 20    0729** JR      NZ,ON4
0B0EE2 F1 
0B0EE3 3E    0730** LD      A,40
0B0EE4 28 
0B0EE5 C3    0731** ERROR2_EX:			JP      ERROR_           ;"ON range"
0B0EE6 24 
0B0EE7 37 
0B0EE8 0B 
             0732** ;
0B0EE9 3E    0733** ONPROC:			LD      A,TON
0B0EEA EE 
0B0EEB C3    0734** JP      PROC_EX
0B0EEC 48 
0B0EED 10 
0B0EEE 0B 
             0735** 
             0736** ; GOTO line
             0737** ;
0B0EEF CD    0738** GOTO_EX:			CALL    ITEMI           	; Fetch the line number
0B0EF0 E9 
0B0EF1 02 
0B0EF2 0B 
0B0EF3 CD    0739** GOTO1:			CALL    TERMQ			; Check for terminator
0B0EF4 3E 
0B0EF5 17 
0B0EF6 0B 
0B0EF7 C2    0740** JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
0B0EF8 5B 
0B0EF9 0C 
0B0EFA 0B 
0B0EFB D9    0741** GOTO2:			EXX
0B0EFC CD    0742** CALL    FINDL			; HL: Line number - Find the line
0B0EFD 53 
0B0EFE 39 
0B0EFF 0B 
0B0F00 E5    0743** PUSH    HL			; HL: Address of the line
0B0F01 FD    0744** POP     IY			; IY = HL
0B0F02 E1 
0B0F03 CA    0745** JP      Z,XEQ0			; If the line is found, then continue execution at that point
0B0F04 56 
0B0F05 0B 
0B0F06 0B 
0B0F07 3E    0746** LD      A,41			; Otherwise throw a "No such line" error
0B0F08 29 
0B0F09 18    0747** JR      ERROR2_EX
0B0F0A DA 
             0748** 
             0749** ; GOSUB line
             0750** ; This pushes the following data onto the execution stack
             0751** ; - 3 bytes: Current execution address
             0752** ; - 3 bytes: Marker (the address of label GOSCHK)
             0753** ;
0B0F0B CD    0754** GOSUB_EX:			CALL    ITEMI			; Fetch the line number
0B0F0C E9 
0B0F0D 02 
0B0F0E 0B 
0B0F0F FD    0755** GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
0B0F10 E5 
0B0F11 CD    0756** CALL    CHECK           	; Check there is enough room
0B0F12 13 
0B0F13 16 
0B0F14 0B 
0B0F15 CD    0757** CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
0B0F16 F3 
0B0F17 0E 
0B0F18 0B 
             0758** GOSCHK:			EQU     $
             0759** 
             0760** ; RETURN
             0761** ; This pops the following data off the execution stack as pushed by GOSUB
             0762** ; - 3 bytes: Marker (should be the address of label GOSCHK)
             0763** ; - 3 bytes: The return execution address
             0764** ;
0B0F19 D1    0765** RETURN:			POP     DE			; Pop the marker off the execution stack
0B0F1A 21    0766** LD      HL,GOSCHK		; Compare with GOSCHK
0B0F1B 19 
0B0F1C 0F 
0B0F1D 0B 
0B0F1E B7    0767** OR      A
0B0F1F ED    0768** SBC     HL,DE
0B0F20 52 
0B0F21 FD    0769** POP     IY			; Pop the return address off the execution stack
0B0F22 E1 
0B0F23 CA    0770** JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
0B0F24 5A 
0B0F25 0B 
0B0F26 0B 
0B0F27 3E    0771** LD      A,38			; Otherwise throw a "No GOSUB" error
0B0F28 26 
0B0F29 18    0772** JR      ERROR2_EX
0B0F2A BA 
             0773** 
             0774** ; REPEAT
             0775** ; This pushes the following data onto the execution stack
             0776** ; - 3 bytes: Current execution address
             0777** ; - 3 bytes: Marker (the address of label REPCHK)
             0778** ;
0B0F2B FD    0779** REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
0B0F2C E5 
0B0F2D CD    0780** CALL    CHECK			; Check if there is enough room
0B0F2E 13 
0B0F2F 16 
0B0F30 0B 
0B0F31 CD    0781** CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
0B0F32 5A 
0B0F33 0B 
0B0F34 0B 
             0782** REPCHK:			EQU     $
             0783** 
             0784** ; UNTIL expr
             0785** ; This pops the following data off the execution stack
             0786** ; - 3 bytes: Marker (should be the address of label REPCHK)
             0787** ; - 3 bytes: The address of the REPEAT instruction
             0788** ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
             0789** ;
0B0F35 C1    0790** UNTIL_EX:			POP     BC			; Fetch the marker
0B0F36 C5    0791** PUSH    BC			; And push it back onto the execution stack
0B0F37 21    0792** LD      HL,REPCHK		; Compare with REPCHK
0B0F38 35 
0B0F39 0F 
0B0F3A 0B 
0B0F3B B7    0793** OR      A
0B0F3C ED    0794** SBC     HL,BC
0B0F3D 42 
0B0F3E 3E    0795** LD      A,43
0B0F3F 2B 
0B0F40 20    0796** JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
0B0F41 A3 
0B0F42 CD    0797** CALL    EXPRI			; Fetch the expression
0B0F43 CE 
0B0F44 02 
0B0F45 0B 
0B0F46 CD    0798** CALL    TEST			; Test if the expression evaluates to zero
0B0F47 A3 
0B0F48 08 
0B0F49 0B 
0B0F4A C1    0799** POP     BC			; Pop the marker
0B0F4B D1    0800** POP     DE			; Pop the address of the REPEAT instruction
0B0F4C 20    0801** JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
0B0F4D 05 
0B0F4E D5    0802** PUSH    DE			; Push the address of the REPEAT instruction back on the stack
0B0F4F C5    0803** PUSH    BC			; Push the marker back on the stack
0B0F50 D5    0804** PUSH    DE			; IY = DE
0B0F51 FD    0805** POP     IY			; This sets the execution address back to the REPEAT instruction
0B0F52 E1 
0B0F53 C3    0806** XEQ2:			JP      XEQ			; Continue execution
0B0F54 5A 
0B0F55 0B 
0B0F56 0B 
             0807** 
             0808** ; FOR var = expr TO expr [STEP expr]
             0809** ; This pushes the following data onto the execution stack
             0810** ; - 3 bytes: The limit value
             0811** ; - 3 bytes: The step value
             0812** ; - 3 bytes: The current execution address
             0813** ; - 3 bytes: The address of the loop variable
             0814** ; - 3 bytes: Marker (the address of FORCHK)
             0815** ;
0B0F57 3E    0816** FORVAR:			LD      A,34
0B0F58 22 
0B0F59 18    0817** JR      ERROR2_EX          	; Throw "FOR variable" error
0B0F5A 8A 
             0818** ;
0B0F5B CD    0819** FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
0B0F5C 82 
0B0F5D 15 
0B0F5E 0B 
0B0F5F 20    0820** JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
0B0F60 F6 
0B0F61 F5    0821** PUSH    AF              	; Save the variable type
0B0F62 FD    0822** LD      A,(IY)			; Check the next token
0B0F63 7E 
0B0F64 00 
0B0F65 FE    0823** CP      TO_EX			; Compare with the token value for "TO"
0B0F66 B8 
0B0F67 3E    0824** LD      A,36			; Set the error code to 36 ("No TO")
0B0F68 24 
0B0F69 C2    0825** JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
0B0F6A E5 
0B0F6B 0E 
0B0F6C 0B 
0B0F6D FD    0826** INC     IY			; Skip to the next token
0B0F6E 23 
             0827** ;
0B0F6F DD    0828** PUSH    IX
0B0F70 E5 
0B0F71 CD    0829** CALL    EXPRN           	; Fetch the LIMIT expression value
0B0F72 C6 
0B0F73 02 
0B0F74 0B 
0B0F75 DD    0830** POP     IX
0B0F76 E1 
0B0F77 F1    0831** POP     AF
0B0F78 47    0832** LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
0B0F79 C5    0833** PUSH    BC              	; Stack the LIMIT value
0B0F7A E5    0834** PUSH    HL
0B0F7B 21    0835** LD      HL,0
0B0F7C 00 
0B0F7D 00 
0B0F7E 00 
0B0F7F 4C    0836** LD      C,H
0B0F80 D9    0837** EXX
0B0F81 E5    0838** PUSH    HL
             0839** ;
0B0F82 21    0840** LD      HL,1            	; The preset STEP value is 1
0B0F83 01 
0B0F84 00 
0B0F85 00 
0B0F86 D9    0841** EXX
0B0F87 FD    0842** LD      A,(IY)			; Fetch the next token
0B0F88 7E 
0B0F89 00 
0B0F8A FE    0843** CP      STEP			; Compare with the token value for "STEP"
0B0F8B 88 
0B0F8C 20    0844** JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
0B0F8D 0A 
             0845** ;
0B0F8E FD    0846** INC     IY			; Skip past the STEP token
0B0F8F 23 
0B0F90 DD    0847** PUSH    IX
0B0F91 E5 
0B0F92 CD    0848** CALL    EXPRN          		; Fetch the STEP expression value
0B0F93 C6 
0B0F94 02 
0B0F95 0B 
0B0F96 DD    0849** POP     IX
0B0F97 E1 
             0850** ;
0B0F98 C5    0851** FOR1:			PUSH    BC			; Stack the STEP value
0B0F99 E5    0852** PUSH    HL
0B0F9A D9    0853** EXX
0B0F9B E5    0854** PUSH    HL
0B0F9C D9    0855** EXX
             0856** ;
0B0F9D FD    0857** PUSH    IY              	; Stack the current execution address
0B0F9E E5 
0B0F9F DD    0858** PUSH    IX              	; Stack the loop variable
0B0FA0 E5 
0B0FA1 CD    0859** CALL    CHECK
0B0FA2 13 
0B0FA3 16 
0B0FA4 0B 
0B0FA5 CD    0860** CALL    XEQ
0B0FA6 5A 
0B0FA7 0B 
0B0FA8 0B 
             0861** FORCHK:			EQU     $
             0862** 
             0863** ; NEXT [var[,var...]]
             0864** ; This pops the following data off the execution stack
             0865** ; - 3 bytes: Marker (the address of FORCHK)
             0866** ; - 3 bytes: The address of the loop variable
             0867** ; - 3 bytes: The current execution address
             0868** ; - 3 bytes: The step value
             0869** ; - 3 bytes: The limit value
             0870** ; It also ensures that the data is pushed back on for subsequent NEXT instructions
             0871** ;
0B0FA9 C1    0872** NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
0B0FAA 21    0873** LD      HL,FORCHK		; Compare with FORCHK
0B0FAB A9 
0B0FAC 0F 
0B0FAD 0B 
0B0FAE B7    0874** OR      A
0B0FAF ED    0875** SBC     HL,BC
0B0FB0 42 
0B0FB1 3E    0876** LD      A,32
0B0FB2 20 
0B0FB3 C2    0877** JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
0B0FB4 3F 
0B0FB5 10 
0B0FB6 0B 
0B0FB7 CD    0878** CALL    TERMQ			; Check for terminator (a NEXT without a variable)
0B0FB8 3E 
0B0FB9 17 
0B0FBA 0B 
0B0FBB E1    0879** POP     HL			; Pop the address of the loop variable off the execution stack
0B0FBC E5    0880** PUSH    HL			; Push it back onto the execution stack
0B0FBD C5    0881** PUSH    BC			; Push the marker back onto the execution stack
0B0FBE E5    0882** PUSH    HL			; HL: Address of the loop variable off the stack
0B0FBF C4    0883** CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
0B0FC0 FE 
0B0FC1 39 
0B0FC2 0B 
0B0FC3 D1    0884** POP     DE			; DE: Address of the loop variable off the stack
0B0FC4 EB    0885** EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
0B0FC5 B7    0886** OR      A
0B0FC6 ED    0887** NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
0B0FC7 52 
0B0FC8 20    0888** JR      NZ,NEXT1		; They don't, so jump to NEXT1
0B0FC9 61 
0B0FCA D5    0889** PUSH    DE
0B0FCB DD    0890** LD      IX,9+3			; IX: Address of the STEP value on the execution stack
0B0FCC 21 
0B0FCD 0C 
0B0FCE 00 
0B0FCE 00   
0B0FD0 DD    0891** ADD     IX,SP
0B0FD1 39 
0B0FD2 CD    0892** CALL    DLOAD5_SPL      	; Load the STEP value
0B0FD3 A5 
0B0FD4 29 
0B0FD5 0B 
0B0FD6 DD    0893** LD      A,(IX+16)       	; Get the STEP type
0B0FD7 7E 
0B0FD8 10 
0B0FD9 DD    0894** POP     IX
0B0FDA E1 
0B0FDB CD    0895** CALL    LOADN           	; Load the LOOP variable
0B0FDC DA 
0B0FDD 03 
0B0FDE 0B 
0B0FDF CB    0896** BIT     7,D             	; Check the sign
0B0FE0 7A 
0B0FE1 F5    0897** PUSH    AF
0B0FE2 3E    0898** LD      A,'+' & 0FH
0B0FE3 0B 
0B0FE4 CD    0899** CALL    FPP             	; Add the STEP
0B0FE5 2E 
0B0FE6 20 
0B0FE7 0B 
0B0FE8 38    0900** JR      C,ERROR3_EX
0B0FE9 55 
0B0FEA F1    0901** POP     AF              	; Restore TYPE
0B0FEB F5    0902** PUSH    AF
0B0FEC CD    0903** CALL    STORE           	; Update the variable
0B0FED 9A 
0B0FEE 15 
0B0FEF 0B 
0B0FF0 DD    0904** LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
0B0FF1 21 
0B0FF2 15 
0B0FF3 00 
0B0FF3 00   
0B0FF5 DD    0905** ADD     IX,SP
0B0FF6 39 
0B0FF7 CD    0906** CALL    DLOAD5_SPL      	; Load the LIMIT value
0B0FF8 A5 
0B0FF9 29 
0B0FFA 0B 
0B0FFB F1    0907** POP     AF
0B0FFC CC    0908** CALL    Z,SWAP			; Swap the arguments if the sign is ?
0B0FFD 9B 
0B0FFE 08 
0B0FFF 0B 
             0909** ; LD      A,0+('<'-4) & 0FH
0B1000 3E    0910** LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
0B1001 08 
0B1002 CD    0911** CALL    FPP             	; Test against the limit
0B1003 2E 
0B1004 20 
0B1005 0B 
0B1006 38    0912** JR      C,ERROR3_EX		; Throw an error if FPP returns bad
0B1007 37 
0B1008 24    0913** INC     H
0B1009 20    0914** JR      NZ,LOOP_        	; Keep looping
0B100A 14 
0B100B 21    0915** LD      HL,27			; Adjust the stack
0B100C 1B 
0B100D 00 
0B100E 00 
0B100F 39    0916** ADD     HL,SP
0B1010 F9    0917** LD      SP,HL
0B1011 CD    0918** CALL    NXT
0B1012 34 
0B1013 0A 
0B1014 0B 
0B1015 FE    0919** CP      ','			; Check for multiple variables
0B1016 2C 
0B1017 C2    0920** JP      NZ,XEQ			; No, so we are done at ths point
0B1018 5A 
0B1019 0B 
0B101A 0B 
0B101B FD    0921** INC     IY			; Increment to the next variable
0B101C 23 
0B101D 18    0922** JR      NEXT_EX			; And continue
0B101E 8A 
             0923** ;
0B101F C1    0924** LOOP_:			POP     BC
0B1020 D1    0925** POP     DE
0B1021 FD    0926** POP     IY
0B1022 E1 
0B1023 FD    0927** PUSH    IY
0B1024 E5 
0B1025 D5    0928** PUSH    DE
0B1026 C5    0929** PUSH    BC
0B1027 C3    0930** JP      XEQ
0B1028 5A 
0B1029 0B 
0B102A 0B 
             0931** ;
0B102B 21    0932** NEXT1:			LD      HL,27			; TODO: What does this do?
0B102C 1B 
0B102D 00 
0B102E 00 
0B102F 39    0933** ADD     HL,SP
0B1030 F9    0934** LD      SP,HL			; Adjust the stack
0B1031 C1    0935** POP     BC
0B1032 21    0936** LD      HL,FORCHK
0B1033 A9 
0B1034 0F 
0B1035 0B 
0B1036 ED    0937** SBC     HL,BC
0B1037 42 
0B1038 E1    0938** POP     HL              	; Variable pointer
0B1039 E5    0939** PUSH    HL
0B103A C5    0940** PUSH    BC
0B103B 28    0941** JR      Z,NEXT0
0B103C 89 
             0942** ;
0B103D 3E    0943** LD      A,33
0B103E 21 
0B103F C3    0944** ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
0B1040 24 
0B1041 37 
0B1042 0B 
             0945** 
             0946** ; FNname
             0947** ; N.B. ENTERED WITH A <> TON
             0948** ;
0B1043 F5    0949** FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0B1044 CD    0950** CALL    PROC1
0B1045 4D 
0B1046 10 
0B1047 0B 
             0951** FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
             0952** 
             0953** ; PROCname
             0954** ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
             0955** ; This pushes the following data onto the execution stack
             0956** ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
             0957** ; - 3 bytes: Marker (the address of PROCHK)
             0958** ;
0B1048 F5    0959** PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0B1049 CD    0960** CALL    PROC1			; and is also space reserved on the stack for the return address
0B104A 4D 
0B104B 10 
0B104C 0B 
             0961** PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
             0962** ;
0B104D CD    0963** PROC1:			CALL    CHECK			; Check there is space for this
0B104E 13 
0B104F 16 
0B1050 0B 
0B1051 FD    0964** DEC     IY			; Decrement IY to the PROC token
0B1052 2B 
0B1053 FD    0965** PUSH    IY			; Stack the pointer
0B1054 E5 
0B1055 CD    0966** CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1056 BF 
0B1057 3A 
0B1058 0B 
0B1059 C1    0967** POP     BC			; BC = IY
0B105A 28    0968** JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0B105B 41 
0B105C 3E    0969** LD      A,30
0B105D 1E 
0B105E 38    0970** JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0B105F DF 
             0971** ;
             0972** ; At this point the PROC/FN has not yet been registered in the dynamic area
             0973** ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
             0974** ;
0B1060 C5    0975** PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0B1061 2A    0976** LD      HL,(PAGE_)		; HL: Start of program memory
0B1062 14 
0B1063 5E 
0B1064 0B 
             0977** ;
0B1065 3E    0978** PROC2:			LD      A,DEF_			;  A: The token to search for
0B1066 DD 
0B1067 CD    0979** CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0B1068 12 
0B1069 18 
0B106A 0B 
0B106B 38    0980** JR      C,PROC3			; Not found, so jump to PROC3
0B106C 26 
0B106D E5    0981** PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0B106E FD    0982** POP     IY			; IY = HL
0B106F E1 
0B1070 FD    0983** INC     IY              	; Skip the DEF token
0B1071 23 
0B1072 CD    0984** CALL    NXT			; And any whitespace
0B1073 34 
0B1074 0A 
0B1075 0B 
0B1076 CD    0985** CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1077 BF 
0B1078 3A 
0B1079 0B 
0B107A FD    0986** PUSH    IY
0B107B E5 
0B107C D1    0987** POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0B107D 38    0988** JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0B107E 09 
0B107F C4    0989** CALL    NZ,CREATE		; Create an entity in the dynamic area
0B1080 72 
0B1081 3B 
0B1082 0B 
0B1083 FD    0990** PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0B1084 E5 
0B1085 D1    0991** POP     DE			; DE = IY
0B1086 ED    0992** LD	(HL),DE			; Save address
0B1087 1F 
             0993** ;
0B1088 EB    0994** PROC6:			EX      DE,HL			; HL: Address of the procedure
0B1089 3E    0995** LD      A,CR			; The character to search for
0B108A 0D 
0B108B 01    0996** LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0B108C 00 
0B108D 01 
0B108E 00 
0B108F ED    0997** CPIR                    	; Skip to next line
0B1090 B1 
0B1091 18    0998** JR      PROC2			; Rinse, lather and repeat
0B1092 D2 
             0999** ;
             1000** ; At this point a DEF has not been found for the PROC/FN
             1001** ;
0B1093 FD    1002** PROC3:			POP     IY              	; Restore the execution address
0B1094 E1 
0B1095 CD    1003** CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1096 BF 
0B1097 3A 
0B1098 0B 
0B1099 3E    1004** LD      A,29
0B109A 1D 
0B109B 20    1005** JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0B109C A2 
             1006** ;
             1007** ; At this point we have a PROC/FN entry in the dynamic area
             1008** ;
0B109D ED    1009** PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0B109E 17 
0B109F 21    1010** LD	HL,3
0B10A0 03 
0B10A1 00 
0B10A2 00 
0B10A3 39    1011** ADD     HL,SP
0B10A4 CD    1012** CALL    NXT             	; Allow space before "("
0B10A5 34 
0B10A6 0A 
0B10A7 0B 
0B10A8 D5    1013** PUSH    DE              	; Exchange DE and IY
0B10A9 FD    1014** EX      (SP),IY
0B10AA E3 
0B10AB FE    1015** CP      '('             	; Arguments?
0B10AC 28 
0B10AD D1    1016** POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0B10AE 20    1017** JR      NZ,PROC5
0B10AF 20 
0B10B0 CD    1018** CALL    NXT             	; Allow space before "("
0B10B1 34 
0B10B2 0A 
0B10B3 0B 
0B10B4 FE    1019** CP      '('
0B10B5 28 
0B10B6 C2    1020** JP      NZ,SYNTAX       	; Throw "Syntax error"
0B10B7 5B 
0B10B8 0C 
0B10B9 0B 
0B10BA FD    1021** PUSH    IY
0B10BB E5 
0B10BC C1    1022** POP     BC              	; Save IY in BC
0B10BD D9    1023** EXX
0B10BE CD    1024** CALL    SAVLOC          	; Save local parameters
0B10BF BE 
0B10C0 16 
0B10C1 0B 
0B10C2 CD    1025** CALL    BRAKET          	; Closing bracket
0B10C3 F3 
0B10C4 09 
0B10C5 0B 
0B10C6 D9    1026** EXX
0B10C7 C5    1027** PUSH    BC
0B10C8 FD    1028** POP     IY              	; Restore IY
0B10C9 E1 
0B10CA E5    1029** PUSH    HL
0B10CB CD    1030** CALL    ARGUE           	; Transfer arguments
0B10CC 3A 
0B10CD 16 
0B10CE 0B 
0B10CF E1    1031** POP     HL
             1032** ;
0B10D0 23    1033** PROC5:			INC	HL			; Increment to the ON PROC flag address
0B10D1 7E    1034** LD	A, (HL)			; And fetch the value
0B10D2 2B    1035** DEC 	HL
0B10D3 ED    1036** LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
0B10D4 1F 
0B10D5 FE    1037** CP	TON			; Was it "ON PROC"?
0B10D6 EE 
0B10D7 C2    1038** JP	NZ, XEQ			; No, so back to XEQ
0B10D8 5A 
0B10D9 0B 
0B10DA 0B 
0B10DB D5    1039** PUSH    DE			; Exchange DE and IY
0B10DC FD    1040** EX      (SP),IY
0B10DD E3 
0B10DE CD    1041** CALL    SPAN            	; Skip rest of ON list
0B10DF 4B 
0B10E0 17 
0B10E1 0B 
0B10E2 FD    1042** EX      (SP),IY			; Exchange DE and IY
0B10E3 E3 
0B10E4 D1    1043** POP     DE
0B10E5 ED    1044** LD	(HL), DE		; Save the return address
0B10E6 1F 
0B10E7 C3    1045** JP      XEQ
0B10E8 5A 
0B10E9 0B 
0B10EA 0B 
             1046** 
             1047** ; LOCAL var[,var...]
             1048** ;
0B10EB C1    1049** LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
0B10EC C5    1050** PUSH    BC
0B10ED 21    1051** LD      HL,FNCHK		; Check if we are in a FN
0B10EE 48 
0B10EF 10 
0B10F0 0B 
0B10F1 B7    1052** OR      A
0B10F2 ED    1053** SBC     HL,BC
0B10F3 42 
0B10F4 28    1054** JR      Z,LOCAL1		; Yes, so all good, we can use local
0B10F5 16 
0B10F6 21    1055** LD      HL,PROCHK		; Now check if we are in a PROC
0B10F7 4D 
0B10F8 10 
0B10F9 0B 
0B10FA B7    1056** OR      A
0B10FB ED    1057** SBC     HL,BC
0B10FC 42 
0B10FD 28    1058** JR      Z,LOCAL1		; Again, all good, we can use local
0B10FE 0D 
0B10FF 21    1059** LD      HL,LOCCHK		; Finally check for the local parameters marker
0B1100 1C 
0B1101 17 
0B1102 0B 
0B1103 B7    1060** OR      A
0B1104 ED    1061** SBC     HL,BC			; If it is not present, then
0B1105 42 
0B1106 3E    1062** LD      A,12
0B1107 0C 
0B1108 C2    1063** JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
0B1109 24 
0B110A 37 
0B110B 0B 
             1064** ;
             1065** ; At this point we are adding a local variable into a PROC or FN
             1066** ;
0B110C FD    1067** LOCAL1:			PUSH    IY			; IY: BASIC pointer
0B110D E5 
0B110E C1    1068** POP     BC			; BC: Copy of the BASIC pointer
0B110F D9    1069** EXX
0B1110 FD    1070** DEC     IY
0B1111 2B 
0B1112 CD    1071** CALL    SAVLOC
0B1113 BE 
0B1114 16 
0B1115 0B 
0B1116 D9    1072** EXX
0B1117 C5    1073** PUSH    BC
0B1118 FD    1074** POP     IY
0B1119 E1 
             1075** ;
0B111A CD    1076** LOCAL2:			CALL    GETVAR			; Get the variable location
0B111B FE 
0B111C 39 
0B111D 0B 
0B111E C2    1077** JP      NZ,SYNTAX
0B111F 5B 
0B1120 0C 
0B1121 0B 
0B1122 B7    1078** OR      A               	; Check the variable type (80h = string)
0B1123 08    1079** EX      AF,AF'
0B1124 CD    1080** CALL    ZERO			; Zero the variable anyway
0B1125 57 
0B1126 09 
0B1127 0B 
0B1128 08    1081** EX      AF,AF'
0B1129 F5    1082** PUSH    AF
0B112A F4    1083** CALL    P,STORE         	; Call STORE if it is not a string
0B112B 9A 
0B112C 15 
0B112D 0B 
0B112E F1    1084** POP     AF
0B112F 59    1085** LD      E,C
0B1130 FC    1086** CALL    M,STORES		; Call STORES if it is a string
0B1131 C8 
0B1132 15 
0B1133 0B 
0B1134 CD    1087** CALL    NXT			; Skip to the next character in the expression
0B1135 34 
0B1136 0A 
0B1137 0B 
0B1138 FE    1088** CP      ','			; Is it a comma?
0B1139 2C 
0B113A C2    1089** JP      NZ,XEQ			; No, so we're done, carry on executing
0B113B 5A 
0B113C 0B 
0B113D 0B 
0B113E FD    1090** INC     IY			; Yes, so skip the comma
0B113F 23 
0B1140 CD    1091** CALL    NXT			; And any whitespace
0B1141 34 
0B1142 0A 
0B1143 0B 
0B1144 18    1092** JR      LOCAL2			; Then loop back and handle any further local variables
0B1145 D4 
             1093** 
             1094** ; ENDPROC
             1095** ;
0B1146 C1    1096** ENDPRO:			POP     BC			; Pop the check value off the stack
0B1147 21    1097** LD      HL,LOCCHK		; Check if it is the LOCAL Marker
0B1148 1C 
0B1149 17 
0B114A 0B 
0B114B B7    1098** OR      A
0B114C ED    1099** SBC     HL,BC
0B114D 42 
0B114E 28    1100** JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
0B114F 13 
             1101** ;
0B1150 21    1102** LD      HL,PROCHK       	; Check if it is the PROC marker
0B1151 4D 
0B1152 10 
0B1153 0B 
0B1154 B7    1103** OR      A
0B1155 ED    1104** SBC     HL,BC
0B1156 42 
0B1157 FD    1105** POP     IY
0B1158 E1 
0B1159 CA    1106** JP      Z,XEQ			; Yes, it is, so carry on, all is good
0B115A 5A 
0B115B 0B 
0B115C 0B 
0B115D 3E    1107** LD      A,13			; Otherwise throw the "No PROC" error
0B115E 0D 
0B115F C3    1108** JP      ERROR_
0B1160 24 
0B1161 37 
0B1162 0B 
             1109** ;
0B1163 DD    1110** UNSTK:			POP     IX			; Unstack a single local variable
0B1164 E1 
0B1165 C1    1111** POP     BC
0B1166 78    1112** LD      A,B
0B1167 B7    1113** OR      A
0B1168 FA    1114** JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0B1169 76 
0B116A 11 
0B116B 0B 
0B116C E1    1115** POP     HL			; Unstack a normal variable
0B116D D9    1116** EXX
0B116E E1    1117** POP     HL
0B116F D9    1118** EXX
0B1170 CD    1119** CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0B1171 9A 
0B1172 15 
0B1173 0B 
0B1174 18    1120** JR      ENDPRO			; And loop back to ENDPRO
0B1175 D0 
             1121** ;
0B1176 21    1122** UNSTK1:			LD      HL,0			; Unstack a string
0B1177 00 
0B1178 00 
0B1179 00 
0B117A 39    1123** ADD     HL,SP
0B117B 59    1124** LD      E,C
0B117C CD    1125** CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0B117D C8 
0B117E 15 
0B117F 0B 
0B1180 F9    1126** LD      SP,HL
0B1181 18    1127** JR      ENDPRO
0B1182 C3 
             1128** 
             1129** ; INPUT #channel,var,var...
             1130** ;
0B1183 CD    1131** INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0B1184 56 
0B1185 18 
0B1186 0B 
0B1187 CD    1132** INPN1:			CALL    NXT
0B1188 34 
0B1189 0A 
0B118A 0B 
0B118B FE    1133** CP      ','
0B118C 2C 
0B118D C2    1134** JP      NZ,XEQ
0B118E 5A 
0B118F 0B 
0B1190 0B 
0B1191 FD    1135** INC     IY
0B1192 23 
0B1193 CD    1136** CALL    NXT
0B1194 34 
0B1195 0A 
0B1196 0B 
0B1197 D5    1137** PUSH    DE
0B1198 CD    1138** CALL    VAR_
0B1199 52 
0B119A 0C 
0B119B 0B 
0B119C D1    1139** POP     DE
0B119D F5    1140** PUSH    AF              ;SAVE TYPE
0B119E E5    1141** PUSH    HL              ;VARPTR
0B119F B7    1142** OR      A
0B11A0 FA    1143** JP      M,INPN2         ;STRING
0B11A1 CC 
0B11A2 11 
0B11A3 0B 
0B11A4 CD    1144** CALL    OSBGET
0B11A5 F7 
0B11A6 42 
0B11A7 0B 
0B11A8 D9    1145** EXX
0B11A9 6F    1146** LD      L,A
0B11AA D9    1147** EXX
0B11AB CD    1148** CALL    OSBGET
0B11AC F7 
0B11AD 42 
0B11AE 0B 
0B11AF D9    1149** EXX
0B11B0 67    1150** LD      H,A
0B11B1 D9    1151** EXX
0B11B2 CD    1152** CALL    OSBGET
0B11B3 F7 
0B11B4 42 
0B11B5 0B 
0B11B6 6F    1153** LD      L,A
0B11B7 CD    1154** CALL    OSBGET
0B11B8 F7 
0B11B9 42 
0B11BA 0B 
0B11BB 67    1155** LD      H,A
0B11BC CD    1156** CALL    OSBGET
0B11BD F7 
0B11BE 42 
0B11BF 0B 
0B11C0 4F    1157** LD      C,A
0B11C1 DD    1158** POP     IX
0B11C2 E1 
0B11C3 F1    1159** POP     AF              ;RESTORE TYPE
0B11C4 D5    1160** PUSH    DE              ;SAVE CHANNEL
0B11C5 CD    1161** CALL    STORE
0B11C6 9A 
0B11C7 15 
0B11C8 0B 
0B11C9 D1    1162** POP     DE
0B11CA 18    1163** JR      INPN1
0B11CB BB 
0B11CC 21    1164** INPN2:			LD      HL,ACCS
0B11CD 00 
0B11CE 5B 
0B11CF 0B 
0B11D0 CD    1165** INPN3:			CALL    OSBGET
0B11D1 F7 
0B11D2 42 
0B11D3 0B 
0B11D4 FE    1166** CP      CR
0B11D5 0D 
0B11D6 28    1167** JR      Z,INPN4
0B11D7 04 
0B11D8 77    1168** LD      (HL),A
0B11D9 2C    1169** INC     L
0B11DA 20    1170** JR      NZ,INPN3
0B11DB F4 
0B11DC DD    1171** INPN4:			POP     IX
0B11DD E1 
0B11DE F1    1172** POP     AF
0B11DF D5    1173** PUSH    DE
0B11E0 EB    1174** EX      DE,HL
0B11E1 CD    1175** CALL    STACCS
0B11E2 C4 
0B11E3 15 
0B11E4 0B 
0B11E5 D1    1176** POP     DE
0B11E6 18    1177** JR      INPN1
0B11E7 9F 
             1178** 
             1179** ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
             1180** ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
             1181** ;
0B11E8 FE    1182** INPUT:			CP      '#'
0B11E9 23 
0B11EA 28    1183** JR      Z,INPUTN
0B11EB 97 
0B11EC 0E    1184** LD      C,0             ;FLAG PROMPT
0B11ED 00 
0B11EE FE    1185** CP      LINE_EX_
0B11EF 86 
0B11F0 20    1186** JR      NZ,INPUT0
0B11F1 04 
0B11F2 FD    1187** INC     IY              ;SKIP "LINE"
0B11F3 23 
0B11F4 0E    1188** LD      C,80H
0B11F5 80 
0B11F6 21    1189** INPUT0:			LD      HL,BUFFER
0B11F7 00 
0B11F8 5C 
0B11F9 0B 
0B11FA 36    1190** LD      (HL),CR         ;INITIALISE EMPTY
0B11FB 0D 
0B11FC CD    1191** INPUT1:			CALL    TERMQ
0B11FD 3E 
0B11FE 17 
0B11FF 0B 
0B1200 CA    1192** JP      Z,XEQ           ;DONE
0B1201 5A 
0B1202 0B 
0B1203 0B 
0B1204 FD    1193** INC     IY
0B1205 23 
0B1206 FE    1194** CP      ','
0B1207 2C 
0B1208 28    1195** JR      Z,INPUT3        ;SKIP COMMA
0B1209 5C 
0B120A FE    1196** CP      ';'
0B120B 3B 
0B120C 28    1197** JR      Z,INPUT3
0B120D 58 
0B120E E5    1198** PUSH    HL              ;SAVE BUFFER POINTER
0B120F FE    1199** CP      34		;ASCII ""
0B1210 22 
0B1211 20    1200** JR      NZ,INPUT6
0B1212 0C 
0B1213 C5    1201** PUSH    BC
0B1214 CD    1202** CALL    CONS
0B1215 2B 
0B1216 04 
0B1217 0B 
0B1218 C1    1203** POP     BC
0B1219 CD    1204** CALL    PTEXT           ;PRINT PROMPT
0B121A C2 
0B121B 17 
0B121C 0B 
0B121D 18    1205** JR      INPUT9
0B121E 06 
0B121F CD    1206** INPUT6:			CALL    FORMAT          ;SPC, TAB, '
0B1220 63 
0B1221 17 
0B1222 0B 
0B1223 20    1207** JR      NZ,INPUT2
0B1224 05 
0B1225 E1    1208** INPUT9:			POP     HL
0B1226 CB    1209** SET     0,C             ;FLAG NO PROMPT
0B1227 C1 
0B1228 18    1210** JR      INPUT0
0B1229 CC 
0B122A FD    1211** INPUT2:			DEC     IY
0B122B 2B 
0B122C C5    1212** PUSH    BC
0B122D CD    1213** CALL    VAR_
0B122E 52 
0B122F 0C 
0B1230 0B 
0B1231 C1    1214** POP     BC
0B1232 E1    1215** POP     HL
0B1233 F5    1216** PUSH    AF              ;SAVE TYPE
0B1234 7E    1217** LD      A,(HL)
0B1235 23    1218** INC     HL
0B1236 FE    1219** CP      CR              ;BUFFER EMPTY?
0B1237 0D 
0B1238 CC    1220** CALL    Z,REFILL
0B1239 6A 
0B123A 12 
0B123B 0B 
0B123C CB    1221** BIT     7,C
0B123D 79 
0B123E F5    1222** PUSH    AF
0B123F C4    1223** CALL    NZ,LINES
0B1240 E4 
0B1241 17 
0B1242 0B 
0B1243 F1    1224** POP     AF
0B1244 CC    1225** CALL    Z,FETCHS
0B1245 D1 
0B1246 17 
0B1247 0B 
0B1248 F1    1226** POP     AF              ;RESTORE TYPE
0B1249 C5    1227** PUSH    BC
0B124A E5    1228** PUSH    HL
0B124B B7    1229** OR      A
0B124C FA    1230** JP      M,INPUT4        ;STRING
0B124D 60 
0B124E 12 
0B124F 0B 
0B1250 F5    1231** PUSH    AF
0B1251 DD    1232** PUSH    IX
0B1252 E5 
0B1253 CD    1233** CALL    VAL0
0B1254 32 
0B1255 06 
0B1256 0B 
0B1257 DD    1234** POP     IX
0B1258 E1 
0B1259 F1    1235** POP     AF
0B125A CD    1236** CALL    STORE
0B125B 9A 
0B125C 15 
0B125D 0B 
0B125E 18    1237** JR      INPUT5
0B125F 04 
0B1260 CD    1238** INPUT4:			CALL    STACCS
0B1261 C4 
0B1262 15 
0B1263 0B 
0B1264 E1    1239** INPUT5:			POP     HL
0B1265 C1    1240** POP     BC
0B1266 CB    1241** INPUT3:			RES     0,C
0B1267 81 
0B1268 18    1242** JR      INPUT1
0B1269 92 
             1243** ;
0B126A CB    1244** REFILL:			BIT     0,C
0B126B 41 
0B126C 20    1245** JR      NZ,REFIL0       ;NO PROMPT
0B126D 0C 
0B126E 3E    1246** LD      A,'?'
0B126F 3F 
0B1270 CD    1247** CALL    OUTCHR          ;PROMPT
0B1271 13 
0B1272 39 
0B1273 0B 
0B1274 3E    1248** LD      A,' '
0B1275 20 
0B1276 CD    1249** CALL    OUTCHR
0B1277 13 
0B1278 39 
0B1279 0B 
0B127A 21    1250** REFIL0:			LD      HL,BUFFER
0B127B 00 
0B127C 5C 
0B127D 0B 
0B127E C5    1251** PUSH    BC
0B127F E5    1252** PUSH    HL
0B1280 DD    1253** PUSH    IX
0B1281 E5 
0B1282 CD    1254** CALL    OSLINE
0B1283 23 
0B1284 3E 
0B1285 0B 
0B1286 DD    1255** POP     IX
0B1287 E1 
0B1288 E1    1256** POP     HL
0B1289 C1    1257** POP     BC
0B128A 47    1258** LD      B,A             ;POS AT ENTRY
0B128B AF    1259** XOR     A
0B128C 32    1260** LD      (COUNT),A
0B128D 3D 
0B128E 5E 
0B128F 0B 
0B1290 B8    1261** CP      B
0B1291 C8    1262** RET     Z
0B1292 7E    1263** REFIL1:			LD      A,(HL)
0B1293 FE    1264** CP      CR
0B1294 0D 
0B1295 C8    1265** RET     Z
0B1296 23    1266** INC     HL
0B1297 10    1267** DJNZ    REFIL1
0B1298 F9 
0B1299 C9    1268** RET
             1269** 
             1270** ; READ var[,var...]
             1271** ;
0B129A FE    1272** READ:			CP      '#'
0B129B 23 
0B129C CA    1273** JP      Z,INPUTN
0B129D 83 
0B129E 11 
0B129F 0B 
0B12A0 2A    1274** LD      HL,(DATPTR)
0B12A1 31 
0B12A2 5E 
0B12A3 0B 
0B12A4 7E    1275** READ0:			LD      A,(HL)
0B12A5 23    1276** INC     HL              ;SKIP COMMA OR "DATA"
0B12A6 FE    1277** CP      CR              ;END OF DATA STMT?
0B12A7 0D 
0B12A8 CC    1278** CALL    Z,GETDAT
0B12A9 EC 
0B12AA 12 
0B12AB 0B 
0B12AC E5    1279** PUSH    HL
0B12AD CD    1280** CALL    VAR_
0B12AE 52 
0B12AF 0C 
0B12B0 0B 
0B12B1 E1    1281** POP     HL
0B12B2 B7    1282** OR      A
0B12B3 FA    1283** JP      M,READ1         ;STRING
0B12B4 CC 
0B12B5 12 
0B12B6 0B 
0B12B7 E5    1284** PUSH    HL
0B12B8 FD    1285** EX      (SP),IY
0B12B9 E3 
0B12BA F5    1286** PUSH    AF              ;SAVE TYPE
0B12BB DD    1287** PUSH    IX
0B12BC E5 
0B12BD CD    1288** CALL    EXPRN
0B12BE C6 
0B12BF 02 
0B12C0 0B 
0B12C1 DD    1289** POP     IX
0B12C2 E1 
0B12C3 F1    1290** POP     AF
0B12C4 CD    1291** CALL    STORE
0B12C5 9A 
0B12C6 15 
0B12C7 0B 
0B12C8 FD    1292** EX      (SP),IY
0B12C9 E3 
0B12CA 18    1293** JR      READ2
0B12CB 09 
0B12CC CD    1294** READ1:			CALL    FETCHS
0B12CD D1 
0B12CE 17 
0B12CF 0B 
0B12D0 E5    1295** PUSH    HL
0B12D1 CD    1296** CALL    STACCS
0B12D2 C4 
0B12D3 15 
0B12D4 0B 
0B12D5 E1    1297** READ2:			POP     HL
0B12D6 22    1298** LD      (DATPTR),HL
0B12D7 31 
0B12D8 5E 
0B12D9 0B 
0B12DA CD    1299** CALL    NXT
0B12DB 34 
0B12DC 0A 
0B12DD 0B 
0B12DE FE    1300** CP      ','
0B12DF 2C 
0B12E0 C2    1301** JP      NZ,XEQ
0B12E1 5A 
0B12E2 0B 
0B12E3 0B 
0B12E4 FD    1302** INC     IY
0B12E5 23 
0B12E6 CD    1303** CALL    NXT
0B12E7 34 
0B12E8 0A 
0B12E9 0B 
0B12EA 18    1304** JR      READ0
0B12EB B8 
             1305** ;
0B12EC 3E    1306** GETDAT:			LD      A,DATA_EX_
0B12ED DC 
0B12EE CD    1307** CALL    SEARCH_EX
0B12EF 12 
0B12F0 18 
0B12F1 0B 
0B12F2 23    1308** INC     HL
0B12F3 D0    1309** RET     NC
0B12F4 3E    1310** LD      A,42
0B12F5 2A 
0B12F6 C3    1311** ERROR4:			JP      ERROR_           ;"Out of DATA"
0B12F7 24 
0B12F8 37 
0B12F9 0B 
             1312** 
             1313** ; IF expr statement
             1314** ; IF expr THEN statement [ELSE statement]
             1315** ; IF expr THEN line [ELSE line]
             1316** ;
0B12FA CD    1317** IF_:			CALL    EXPRI
0B12FB CE 
0B12FC 02 
0B12FD 0B 
0B12FE CD    1318** CALL    TEST
0B12FF A3 
0B1300 08 
0B1301 0B 
0B1302 28    1319** JR      Z,IFNOT         ;FALSE
0B1303 19 
0B1304 FD    1320** LD      A,(IY)
0B1305 7E 
0B1306 00 
0B1307 FE    1321** CP      THEN_EX_
0B1308 8C 
0B1309 C2    1322** JP      NZ,XEQ
0B130A 5A 
0B130B 0B 
0B130C 0B 
0B130D FD    1323** INC     IY              ;SKIP "THEN"
0B130E 23 
0B130F CD    1324** IF1:			CALL    NXT
0B1310 34 
0B1311 0A 
0B1312 0B 
0B1313 FE    1325** CP      LINO_EX
0B1314 8D 
0B1315 C2    1326** JP      NZ,XEQ          ;STATEMENT FOLLOWS
0B1316 5A 
0B1317 0B 
0B1318 0B 
0B1319 C3    1327** JP      GOTO_EX            ;LINE NO. FOLLOWS
0B131A EF 
0B131B 0E 
0B131C 0B 
0B131D FD    1328** IFNOT:			LD      A,(IY)
0B131E 7E 
0B131F 00 
0B1320 FE    1329** CP      CR
0B1321 0D 
0B1322 FD    1330** INC     IY
0B1323 23 
0B1324 CA    1331** JP      Z,XEQ0          ;END OF LINE
0B1325 56 
0B1326 0B 
0B1327 0B 
0B1328 FE    1332** CP      ELSE_EX_
0B1329 8B 
0B132A 20    1333** JR      NZ,IFNOT
0B132B F1 
0B132C 18    1334** JR      IF1
0B132D E1 
             1335** 
             1336** ; CLS
             1337** ;
0B132E CD    1338** CLS:		CALL    CLRSCN
0B132F 90 
0B1330 43 
0B1331 0B 
0B1332 AF    1339** XOR     A
0B1333 32    1340** LD      (COUNT),A
0B1334 3D 
0B1335 5E 
0B1336 0B 
0B1337 C3    1341** JP      XEQ
0B1338 5A 
0B1339 0B 
0B133A 0B 
             1342** 
             1343** ; STOP
             1344** ;
0B133B CD    1345** STOP:			CALL    TELL
0B133C 54 
0B133D 3D 
0B133E 0B 
0B133F 0D    1346** DB	CR
0B1340 0A    1347** DB	LF
0B1341 FA    1348** DB	TSTOP
0B1342 00    1349** DB	0
0B1343 CD    1350** CALL    SETLIN          ;FIND CURRENT LINE
0B1344 72 
0B1345 39 
0B1346 0B 
0B1347 CD    1351** CALL    SAYLN
0B1348 A6 
0B1349 39 
0B134A 0B 
0B134B CD    1352** CALL    CRLF
0B134C 0B 
0B134D 39 
0B134E 0B 
0B134F C3    1353** JP      CLOOP
0B1350 44 
0B1351 30 
0B1352 0B 
             1354** 
             1355** ; REPORT
             1356** ;
0B1353 CD    1357** REPOR:			CALL    REPORT
0B1354 46 
0B1355 3D 
0B1356 0B 
0B1357 C3    1358** JP      XEQ
0B1358 5A 
0B1359 0B 
0B135A 0B 
             1359** 
             1360** ; CLEAR
             1361** ;
0B135B CD    1362** CLR:			CALL    CLEAR
0B135C 3A 
0B135D 38 
0B135E 0B 
0B135F 2A    1363** LD      HL,(PAGE_)
0B1360 14 
0B1361 5E 
0B1362 0B 
0B1363 18    1364** JR      RESTR1
0B1364 19 
             1365** 
             1366** ; RESTORE [line]
             1367** ;
0B1365 2A    1368** RESTOR_EX:			LD      HL,(PAGE_)
0B1366 14 
0B1367 5E 
0B1368 0B 
0B1369 CD    1369** CALL    TERMQ
0B136A 3E 
0B136B 17 
0B136C 0B 
0B136D 28    1370** JR      Z,RESTR1
0B136E 0F 
0B136F CD    1371** CALL    ITEMI
0B1370 E9 
0B1371 02 
0B1372 0B 
0B1373 D9    1372** EXX
0B1374 CD    1373** CALL    FINDL           ;SEARCH FOR LINE
0B1375 53 
0B1376 39 
0B1377 0B 
0B1378 3E    1374** LD      A,41
0B1379 29 
0B137A C2    1375** JP      NZ,ERROR4       ;"No such line"
0B137B F6 
0B137C 12 
0B137D 0B 
0B137E 3E    1376** RESTR1:			LD      A,DATA_EX_
0B137F DC 
0B1380 CD    1377** CALL    SEARCH_EX
0B1381 12 
0B1382 18 
0B1383 0B 
0B1384 22    1378** LD      (DATPTR),HL
0B1385 31 
0B1386 5E 
0B1387 0B 
0B1388 C3    1379** JP      XEQ
0B1389 5A 
0B138A 0B 
0B138B 0B 
             1380** 
             1381** ; PTR#channel=expr
             1382** ; PAGE=expr
             1383** ; TIME=expr
             1384** ; LOMEM=expr
             1385** ; HIMEM=expr
             1386** ;
0B138C CD    1387** PTR_EX:			CALL    CHANEL
0B138D 4A 
0B138E 18 
0B138F 0B 
0B1390 CD    1388** CALL    EQUALS
0B1391 54 
0B1392 17 
0B1393 0B 
0B1394 7B    1389** LD      A,E
0B1395 F5    1390** PUSH    AF
0B1396 CD    1391** CALL    EXPRI
0B1397 CE 
0B1398 02 
0B1399 0B 
0B139A E5    1392** PUSH    HL
0B139B D9    1393** EXX
0B139C D1    1394** POP     DE
0B139D F1    1395** POP     AF
0B139E CD    1396** CALL    PUTPTR
0B139F 2B 
0B13A0 43 
0B13A1 0B 
0B13A2 C3    1397** JP      XEQ
0B13A3 5A 
0B13A4 0B 
0B13A5 0B 
             1398** ;
0B13A6 CD    1399** PAGEV_EX:			CALL    EQUALS
0B13A7 54 
0B13A8 17 
0B13A9 0B 
0B13AA CD    1400** CALL    EXPRI
0B13AB CE 
0B13AC 02 
0B13AD 0B 
0B13AE D9    1401** EXX
0B13AF 2E    1402** LD      L,0
0B13B0 00 
0B13B1 22    1403** LD      (PAGE_),HL
0B13B2 14 
0B13B3 5E 
0B13B4 0B 
0B13B5 C3    1404** JP      XEQ
0B13B6 5A 
0B13B7 0B 
0B13B8 0B 
             1405** ;
0B13B9 FE    1406** TIMEV_EX:			CP      '$'
0B13BA 24 
0B13BB 28    1407** JR      Z,TIMEVS_EX
0B13BC 13 
0B13BD CD    1408** CALL    EQUALS
0B13BE 54 
0B13BF 17 
0B13C0 0B 
0B13C1 CD    1409** CALL    EXPRI
0B13C2 CE 
0B13C3 02 
0B13C4 0B 
0B13C5 E5    1410** PUSH    HL
0B13C6 D9    1411** EXX
0B13C7 D1    1412** POP     DE
0B13C8 CD    1413** CALL    PUTIME
0B13C9 5B 
0B13CA 3E 
0B13CB 0B 
0B13CC C3    1414** JP      XEQ
0B13CD 5A 
0B13CE 0B 
0B13CF 0B 
             1415** ;
0B13D0 FD    1416** TIMEVS_EX:			INC     IY              ;SKIP '$'
0B13D1 23 
0B13D2 CD    1417** CALL    EQUALS
0B13D3 54 
0B13D4 17 
0B13D5 0B 
0B13D6 CD    1418** CALL    EXPRS
0B13D7 D9 
0B13D8 02 
0B13D9 0B 
0B13DA CD    1419** CALL    PUTIMS
0B13DB 7B 
0B13DC 43 
0B13DD 0B 
0B13DE C3    1420** JP      XEQ
0B13DF 5A 
0B13E0 0B 
0B13E1 0B 
             1421** ;
0B13E2 CD    1422** LOMEMV_EX:			CALL    EQUALS
0B13E3 54 
0B13E4 17 
0B13E5 0B 
0B13E6 CD    1423** CALL    EXPRI
0B13E7 CE 
0B13E8 02 
0B13E9 0B 
0B13EA CD    1424** CALL    CLEAR
0B13EB 3A 
0B13EC 38 
0B13ED 0B 
0B13EE D9    1425** EXX
0B13EF 22    1426** LD      (LOMEM),HL
0B13F0 1A 
0B13F1 5E 
0B13F2 0B 
0B13F3 22    1427** LD      (FREE),HL
0B13F4 1D 
0B13F5 5E 
0B13F6 0B 
0B13F7 C3    1428** JP      XEQ
0B13F8 5A 
0B13F9 0B 
0B13FA 0B 
             1429** ;
0B13FB CD    1430** HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
0B13FC 54 
0B13FD 17 
0B13FE 0B 
0B13FF CD    1431** CALL    EXPRI			; Load the expression into registers
0B1400 CE 
0B1401 02 
0B1402 0B 
             1432** ; BEGIN MISSING FROM BINARY
             1433** ; LD	A,L			;  A: The MSB of the 24-bit value
             1434** ; EXX				; HL: The LSW of the 24-bit value
             1435** ; LD	(R0),HL
             1436** ; LD	(R0+2),A
             1437** ; LD	HL,(FREE)
             1438** ; LD      DE,256
             1439** ; ADD	HL,DE
             1440** ; EX	DE,HL			; DE: FREE + 256
             1441** ; LD	HL,(R0)			; HL: The passed expression
             1442** ; END MISSING FROM BINARY
             1443** ; BEGIN ADDED FROM BINARY
0B1403 D9    1444** exx
0B1404 ED    1445** ld de,(FREE)
0B1405 5B 
0B1406 1D 
0B1407 5E 
0B1407 0B   
0B1409 14    1446** inc d
             1447** ; END ADDED FROM BINARY
0B140A AF    1448** XOR     A
0B140B ED    1449** SBC     HL,DE
0B140C 52 
0B140D 19    1450** ADD     HL,DE			; Do a bounds check
0B140E DA    1451** JP      C,ERROR_         	; Throw the error: "No room"
0B140F 24 
0B1410 37 
0B1411 0B 
0B1412 ED    1452** LD      DE,(HIMEM)
0B1413 5B 
0B1414 20 
0B1415 5E 
0B1415 0B   
0B1417 22    1453** LD      (HIMEM),HL
0B1418 20 
0B1419 5E 
0B141A 0B 
0B141B EB    1454** EX      DE,HL
0B141C ED    1455** SBC     HL,SP			; Adjust the stack
0B141D 72 
0B141E C2    1456** JP      NZ,XEQ
0B141F 5A 
0B1420 0B 
0B1421 0B 
0B1422 EB    1457** EX      DE,HL
0B1423 F9    1458** LD      SP,HL           	; Load the SP
0B1424 C3    1459** JP      XEQ
0B1425 5A 
0B1426 0B 
0B1427 0B 
             1460** 
             1461** ; WIDTH expr
             1462** ;
0B1428 CD    1463** WIDTHV:			CALL    EXPRI
0B1429 CE 
0B142A 02 
0B142B 0B 
0B142C D9    1464** EXX
0B142D 7D    1465** LD      A,L
0B142E 32    1466** LD      (WIDTH),A
0B142F 3E 
0B1430 5E 
0B1431 0B 
0B1432 C3    1467** JP      XEQ
0B1433 5A 
0B1434 0B 
0B1435 0B 
             1468** 
             1469** ; TRACE ON
             1470** ; TRACE OFF
             1471** ; TRACE line
             1472** ;
0B1436 FD    1473** TRACE_EX:			INC     IY
0B1437 23 
0B1438 21    1474** LD      HL,0
0B1439 00 
0B143A 00 
0B143B 00 
0B143C FE    1475** CP      TON
0B143D EE 
0B143E 28    1476** JR      Z,TRACE0
0B143F 0B 
0B1440 FE    1477** CP      OFF_
0B1441 87 
0B1442 28    1478** JR      Z,TRACE1
0B1443 08 
0B1444 FD    1479** DEC     IY
0B1445 2B 
0B1446 CD    1480** CALL    EXPRI
0B1447 CE 
0B1448 02 
0B1449 0B 
0B144A D9    1481** EXX
0B144B 2B    1482** TRACE0:			DEC     HL
0B144C 22    1483** TRACE1:			LD      (TRACEN),HL
0B144D 26 
0B144E 5E 
0B144F 0B 
0B1450 C3    1484** JP      XEQ
0B1451 5A 
0B1452 0B 
0B1453 0B 
             1485** 
             1486** ; VDU expr,expr;....
             1487** ;
             1488** ; BEGIN MISSING FROM BINARY
             1489** ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
             1490** ; VDU1:			PUSH	IX
             1491** ; 			CALL    EXPRI			; Fetch the VDU character
             1492** ; 			POP	IX
             1493** ; 			EXX
             1494** ; 			LD	(IX+0),L		; Write out the character to the buffer
             1495** ; 			INC	IX
             1496** ; 			LD      A,(IY)			;  A: The separator character
             1497** ; 			CP      ','			; Is it a comma?
             1498** ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
             1499** ; 			CP      ';'			; Is it a semicolon?
             1500** ; 			JR      NZ,VDU3			; No, so skip to the next expression
             1501** ; 			LD	(IX+0),H		; Write out the high byte to the buffer
             1502** ; 			INC	IX
             1503** ; VDU2:			INC     IY			; Skip to the next character
             1504** ; VDU3:			CALL    TERMQ			; Skip past white space
             1505** ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
             1506** ; 			LD	A,IXL			;  A: Number of bytes to write out
             1507** ; 			OR	A
             1508** ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
             1509** ; 			LD	HL,BUFFER		; HL: Start of stream
             1510** ; 			LD	BC,0
             1511** ; 			LD	C,A			; BC: Number of bytes to write out
             1512** ; 			RST.LIL	18h			; Output the buffer to MOS
             1513** ; END MISSING FROM BINARY
             1514** ; BEGIN ADDED FROM BINARY
             1515** VDU:
0B1454 CD    1516** call EXPRI
0B1455 CE 
0B1456 02 
0B1457 0B 
0B1458 D9    1517** exx
0B1459 7D    1518** ld a,l
0B145A CD    1519** call OSWRCH
0B145B C4 
0B145C 3E 
0B145D 0B 
0B145E FD    1520** ld a,(iy)
0B145F 7E 
0B1460 00 
0B1461 FE    1521** cp $2c
0B1462 2C 
0B1463 28    1522** jr z,$+$0b
0B1464 09 
0B1465 FE    1523** cp $3b
0B1466 3B 
0B1467 20    1524** jr nz,$+$09
0B1468 07 
0B1469 7C    1525** ld a,h
0B146A CD    1526** call OSWRCH
0B146B C4 
0B146C 3E 
0B146D 0B 
0B146E FD    1527** inc iy
0B146F 23 
0B1470 CD    1528** call TERMQ
0B1471 3E 
0B1472 17 
0B1473 0B 
0B1474 20    1529** jr nz,$-$20
0B1475 DE 
             1530** ; END ADDED FROM BINARY
0B1476 C3    1531** VDU4:			JP      XEQ
0B1477 5A 
0B1478 0B 
0B1479 0B 
             1532** 
             1533** ; CLOSE channel number
             1534** ;
0B147A CD    1535** CLOSE:			CALL    CHANEL			; Fetch the channel number
0B147B 4A 
0B147C 18 
0B147D 0B 
0B147E CD    1536** CALL    OSSHUT			; Close the channel
0B147F EF 
0B1480 42 
0B1481 0B 
0B1482 C3    1537** JP      XEQ
0B1483 5A 
0B1484 0B 
0B1485 0B 
             1538** 
             1539** ; BPUT channel,byte
             1540** ;
0B1486 CD    1541** BPUT:			CALL    CHANEL          	; Fetch the channel number
0B1487 4A 
0B1488 18 
0B1489 0B 
0B148A D5    1542** PUSH    DE			; DE: Channel number
0B148B CD    1543** CALL    COMMA			; Skip to the next expression
0B148C E6 
0B148D 09 
0B148E 0B 
0B148F CD    1544** CALL    EXPRI           	; Feth the data
0B1490 CE 
0B1491 02 
0B1492 0B 
0B1493 D9    1545** EXX
0B1494 7D    1546** LD      A,L			; A: The byte to write
0B1495 D1    1547** POP     DE
0B1496 CD    1548** CALL    OSBPUT			; Write the byte out
0B1497 FF 
0B1498 42 
0B1499 0B 
0B149A C3    1549** JP      XEQ
0B149B 5A 
0B149C 0B 
0B149D 0B 
             1550** 
             1551** ; CALL address[,var[,var...]]
             1552** ;
             1553** ; Note that the parameter table differs from the Z80 version
             1554** ; Each entry now takes up 4 bytes, not 3, so the table is now:
             1555** ;  -1 byte:  Number of parameters
             1556** ; Then, for each parameter:
             1557** ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
             1558** ;  -3 bytes: Parameter address
             1559** ;
             1560** ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
             1561** ;
0B149E CD    1562** CALL_:			CALL    EXPRI           	; Fetch the address
0B149F CE 
0B14A0 02 
0B14A1 0B 
0B14A2 7D    1563** LD	A,L			;  A: MSB of address
0B14A3 D9    1564** EXX
0B14A4 22    1565** LD	(R0+0),HL		; HL: LSW of address
0B14A5 4A 
0B14A6 5E 
0B14A7 0B 
0B14A8 32    1566** LD	(R0+2),A
0B14A9 4C 
0B14AA 5E 
0B14AB 0B 
0B14AC 06    1567** LD      B,0             	;  B: The parameter counter
0B14AD 00 
0B14AE 11    1568** LD      DE,BUFFER       	; DE: Vector
0B14AF 00 
0B14B0 5C 
0B14B1 0B 
             1569** ;
0B14B2 CD    1570** CALL1:			CALL    NXT			; Skip whitespace
0B14B3 34 
0B14B4 0A 
0B14B5 0B 
0B14B6 FE    1571** CP      ','			; Check for comma
0B14B7 2C 
0B14B8 20    1572** JR      NZ,CALL2		; If no more parameters, then jump here
0B14B9 1B 
0B14BA FD    1573** INC     IY			; Skip to the next character
0B14BB 23 
0B14BC 04    1574** INC     B			; Increment the parameter count
0B14BD CD    1575** CALL    NXT			; Skip whitespace
0B14BE 34 
0B14BF 0A 
0B14C0 0B 
0B14C1 C5    1576** PUSH    BC
0B14C2 D5    1577** PUSH    DE
0B14C3 CD    1578** CALL    VAR_
0B14C4 52 
0B14C5 0C 
0B14C6 0B 
0B14C7 D1    1579** POP     DE
0B14C8 C1    1580** POP     BC
0B14C9 13    1581** INC     DE
0B14CA 12    1582** LD      (DE),A			; Save the parameter type
0B14CB 13    1583** INC     DE
0B14CC EB    1584** EX      DE,HL
0B14CD ED    1585** LD	(HL),DE			; Save the parameter address (3 bytes)
0B14CE 1F 
0B14CF 23    1586** INC	HL
0B14D0 23    1587** INC	HL
0B14D1 23    1588** INC	HL
0B14D2 EB    1589** EX      DE,HL
0B14D3 18    1590** JR      CALL1
0B14D4 DD 
             1591** ;
0B14D5 78    1592** CALL2:			LD      A,B
0B14D6 32    1593** LD      (BUFFER),A      	; Save the parameter count
0B14D7 00 
0B14D8 5C 
0B14D9 0B 
0B14DA 2A    1594** LD	HL,(R0)			; HL: Address of the code
0B14DB 4A 
0B14DC 5E 
0B14DD 0B 
0B14DE CD    1595** CALL    USR1			; And call it
0B14DF F8 
0B14E0 14 
0B14E1 0B 
0B14E2 C3    1596** JP      XEQ
0B14E3 5A 
0B14E4 0B 
0B14E5 0B 
             1597** 
             1598** ; USR(address)
             1599** ;
0B14E6 CD    1600** USR:			CALL    ITEMI			; Evaluate the expression
0B14E7 E9 
0B14E8 02 
0B14E9 0B 
0B14EA 7D    1601** LD	A,L			;  A: MSB of address
0B14EB D9    1602** EXX
0B14EC 22    1603** LD	(R0+0),HL		; HL: LSW of address
0B14ED 4A 
0B14EE 5E 
0B14EF 0B 
0B14F0 32    1604** LD	(R0+2),A
0B14F1 4C 
0B14F2 5E 
0B14F3 0B 
0B14F4 2A    1605** LD	HL,(R0)			; Get the 24-bit address in HL
0B14F5 4A 
0B14F6 5E 
0B14F7 0B 
             1606** ;
0B14F8 E5    1607** USR1:			PUSH    HL              	; Address on stack
0B14F9 FD    1608** EX      (SP),IY
0B14FA E3 
0B14FB 24    1609** INC     H               	; Check for PAGE &00FFxx
0B14FC B4    1610** OR	H
0B14FD 21    1611** LD      HL,USR2         	; Return address
0B14FE 67 
0B14FF 15 
0B1500 0B 
0B1501 E5    1612** PUSH    HL
0B1502 DD    1613** LD      IX,STAVAR
0B1503 21 
0B1504 00 
0B1505 5D 
0B1505 0B   
0B1507 CC    1614** CALL    Z,OSCALL        	; Intercept &00FFxx
0B1508 B5 
0B1509 42 
0B150A 0B 
             1615** ;
0B150B DD    1616** LD      C, (IX+24)		; F%
0B150C 4E 
0B150D 18 
0B150E C5    1617** PUSH    BC
             1618** ;
0B150F DD    1619** LD	A, (IX+8)		; B% -> MSW
0B1510 7E 
0B1511 08 
0B1512 32    1620** LD	(R0+1), A
0B1513 4B 
0B1514 5E 
0B1515 0B 
0B1516 DD    1621** LD	A, (IX+9)
0B1517 7E 
0B1518 09 
0B1519 32    1622** LD	(R0+2), A
0B151A 4C 
0B151B 5E 
0B151C 0B 
0B151D DD    1623** LD	A, (IX+12)		; C% -> LSB
0B151E 7E 
0B151F 0C 
0B1520 32    1624** LD	(R0+0), A
0B1521 4A 
0B1522 5E 
0B1523 0B 
0B1524 ED    1625** LD	BC, (R0)
0B1525 4B 
0B1526 4A 
0B1527 5E 
0B1527 0B   
             1626** ;
0B1529 DD    1627** LD	A, (IX+16)		; D% -> MSW
0B152A 7E 
0B152B 10 
0B152C 32    1628** LD	(R0+1), A
0B152D 4B 
0B152E 5E 
0B152F 0B 
0B1530 DD    1629** LD	A, (IX+17)
0B1531 7E 
0B1532 11 
0B1533 32    1630** LD	(R0+2), A
0B1534 4C 
0B1535 5E 
0B1536 0B 
0B1537 DD    1631** LD	A, (IX+20)		; E% -> LSB
0B1538 7E 
0B1539 14 
0B153A 32    1632** LD	(R0+0), A
0B153B 4A 
0B153C 5E 
0B153D 0B 
0B153E ED    1633** LD	DE, (R0)
0B153F 5B 
0B1540 4A 
0B1541 5E 
0B1541 0B   
             1634** ;
0B1543 DD    1635** LD	A, (IX+32)		; H% -> MSW
0B1544 7E 
0B1545 20 
0B1546 32    1636** LD	(R0+1), A
0B1547 4B 
0B1548 5E 
0B1549 0B 
0B154A DD    1637** LD	A, (IX+33)
0B154B 7E 
0B154C 21 
0B154D 32    1638** LD	(R0+2), A
0B154E 4C 
0B154F 5E 
0B1550 0B 
0B1551 DD    1639** LD	A, (IX+48)		; L% -> LSB
0B1552 7E 
0B1553 30 
0B1554 32    1640** LD	(R0+0), A
0B1555 4A 
0B1556 5E 
0B1557 0B 
0B1558 2A    1641** LD	HL, (R0)
0B1559 4A 
0B155A 5E 
0B155B 0B 
             1642** ;
0B155C F1    1643** POP     AF			; F%
0B155D DD    1644** LD      A, (IX+4)        	; A%
0B155E 7E 
0B155F 04 
             1645** 
0B1560 DD    1646** LD      IX,BUFFER
0B1561 21 
0B1562 00 
0B1563 5C 
0B1563 0B   
0B1565 FD    1647** JP      (IY)            	; Off to user routine
0B1566 E9 
             1648** ;
0B1567 FD    1649** USR2:			POP     IY
0B1568 E1 
0B1569 AF    1650** XOR     A
0B156A 4F    1651** LD      C,A
0B156B C9    1652** RET
             1653** 
             1654** ; PUT port,data
             1655** ;
0B156C CD    1656** PUT:			CALL    EXPRI           ;PORT ADDRESS
0B156D CE 
0B156E 02 
0B156F 0B 
0B1570 D9    1657** EXX
0B1571 E5    1658** PUSH    HL
0B1572 CD    1659** CALL    COMMA
0B1573 E6 
0B1574 09 
0B1575 0B 
0B1576 CD    1660** CALL    EXPRI           ;DATA
0B1577 CE 
0B1578 02 
0B1579 0B 
0B157A D9    1661** EXX
0B157B C1    1662** POP     BC
0B157C ED    1663** OUT     (C),L           ;OUTPUT TO PORT BC
0B157D 69 
0B157E C3    1664** JP      XEQ
0B157F 5A 
0B1580 0B 
0B1581 0B 
             1665** 
             1666** ; SUBROUTINES -----------------------------------------------------------------
             1667** 
             1668** ; ASSIGN - Assign a numeric value to a variable.
             1669** ; Outputs: NC,  Z - OK, numeric.
             1670** ;          NC, NZ - OK, string.
             1671** ;           C, NZ - illegal
             1672** ;
0B1582 CD    1673** ASSIGN:			CALL    GETVAR          	; Try to get the variable
0B1583 FE 
0B1584 39 
0B1585 0B 
0B1586 D8    1674** RET     C               	; Return with C if it is an illegal variable
0B1587 C4    1675** CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0B1588 ED 
0B1589 39 
0B158A 0B 
0B158B B7    1676** OR      A
0B158C F8    1677** RET     M               	; Return if type is string (81h)
0B158D F5    1678** PUSH    AF              	; It's a numeric type from this point on
0B158E CD    1679** CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B158F 54 
0B1590 17 
0B1591 0B 
0B1592 E5    1680** PUSH    HL
0B1593 CD    1681** CALL    EXPRN
0B1594 C6 
0B1595 02 
0B1596 0B 
0B1597 DD    1682** POP     IX
0B1598 E1 
0B1599 F1    1683** POP     AF
0B159A CB    1684** STORE:			BIT     0,A
0B159B 47 
0B159C 28    1685** JR      Z,STOREI
0B159D 13 
0B159E BF    1686** CP      A               	; Set the variable to 0
0B159F DD    1687** STORE5:			LD      (IX+4),C
0B15A0 71 
0B15A1 04 
0B15A2 D9    1688** STORE4:			EXX
0B15A3 DD    1689** LD      (IX+0),L
0B15A4 75 
0B15A5 00 
0B15A6 DD    1690** LD      (IX+1),H
0B15A7 74 
0B15A8 01 
0B15A9 D9    1691** EXX
0B15AA DD    1692** LD      (IX+2),L
0B15AB 75 
0B15AC 02 
0B15AD DD    1693** LD      (IX+3),H
0B15AE 74 
0B15AF 03 
0B15B0 C9    1694** RET
0B15B1 F5    1695** STOREI:			PUSH    AF
0B15B2 0C    1696** INC     C               ;SPEED - & PRESERVE F'
0B15B3 0D    1697** DEC     C               ; WHEN CALLED BY FNEND0
0B15B4 C4    1698** CALL    NZ,SFIX         ;CONVERT TO INTEGER
0B15B5 26 
0B15B6 06 
0B15B7 0B 
0B15B8 F1    1699** POP     AF
0B15B9 FE    1700** CP      4
0B15BA 04 
0B15BB 28    1701** JR      Z,STORE4
0B15BC E5 
0B15BD BF    1702** CP      A               ;SET ZERO
0B15BE D9    1703** STORE1:			EXX
0B15BF DD    1704** LD      (IX+0),L
0B15C0 75 
0B15C1 00 
0B15C2 D9    1705** EXX
0B15C3 C9    1706** RET
             1707** ;
             1708** ; Copy a string from the string accumulator to variable storage on the stack
             1709** ; Parameters:
             1710** ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
             1711** ; - IX: Address of the variable storage on the stack
             1712** ;
0B15C4 21    1713** STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B15C5 00 
0B15C6 5B 
0B15C7 0B 
             1714** ;
             1715** ; Parameters:
             1716** ; As above, but:
             1717** ; - HL: Address of the string to be stored
             1718** ; -  E: The string length
             1719** ; NB:
             1720** ; Strings are mutable
             1721** ; Strings are stored in the following format in the variable:
             1722** ; - Address of the next variable (3 bytes)
             1723** ; - The rest of the variable name - this is zero terminated
             1724** ; - Current string length (byte)
             1725** ; - Maximum (original) string length (byte)
             1726** ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
             1727** ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
             1728** ;
0B15C8 1F    1729** STORES:			RRA				; Rotate right to shift bit 0 into carry
0B15C9 30    1730** JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
0B15CA 5D 
0B15CB E5    1731** PUSH    HL			; Stack ACCS
             1732** ;
             1733** ; Load the string pointer and lengths into registers - these are all zeroed for new strings
             1734** ;
0B15CC D9    1735** EXX				; This block was a call to LOAD4
0B15CD DD    1736** LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B15CE 6E 
0B15CF 00 
0B15D0 DD    1737** LD      H,(IX+1)		; The maximum original string length
0B15D1 66 
0B15D2 01 
0B15D3 D9    1738** EXX
0B15D4 DD    1739** LD	HL,(IX+2)		; Address of the string (24-bit)
0B15D5 27 
0B15D6 02 
             1740** ;
0B15D7 7B    1741** LD      A,E             	; E : Length of string in ACCS (as passed to the function)
0B15D8 D9    1742** EXX
0B15D9 6F    1743** LD      L,A			; L': Length of string currently stored on the stack
0B15DA 7C    1744** LD      A,H             	; H': The maximum (original) string length
0B15DB D9    1745** EXX
0B15DC BB    1746** CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
0B15DD 30    1747** JR      NC,STORS1       	; Yes there is, so skip the next bit
0B15DE 17 
             1748** ;
             1749** ; At this point we're either initialising a new string or assigning more memory to an existing string
             1750** ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
             1751** ; then the existing and new strings may both exist in memory.
             1752** ;
0B15DF D9    1753** EXX
0B15E0 65    1754** LD      H,L			; H: Set the maximum string length to the string length
0B15E1 D9    1755** EXX
0B15E2 E5    1756** PUSH    HL
0B15E3 01    1757** LD	BC, 0
0B15E4 00 
0B15E5 00 
0B15E6 00 
0B15E7 4F    1758** LD      C,A			; BC: The maximum (original) string length
0B15E8 09    1759** ADD     HL,BC			; Work out whether this is the last string in memory
0B15E9 ED    1760** LD      BC,(FREE)
0B15EA 4B 
0B15EB 1D 
0B15EC 5E 
0B15EC 0B   
0B15EE ED    1761** SBC     HL,BC			; Is string last?
0B15EF 42 
0B15F0 E1    1762** POP     HL
0B15F1 37    1763** SCF
0B15F2 28    1764** JR      Z,STORS1
0B15F3 02 
             1765** ; LD	HL, BC			; HL=BC
0B15F4 C5    1766** push bc
0B15F5 E1    1767** pop hl
             1768** ;
             1769** ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
             1770** ; - H': The maximum (original) string length
             1771** ; - L': The actual string length (must be less than H')
             1772** ; - HL: Address of the string in memory
             1773** ;
0B15F6 D9    1774** STORS1:			EXX				; This block was a call to STORE4
0B15F7 DD    1775** LD      (IX+0),L		; The actual string length (must be less then H')
0B15F8 75 
0B15F9 00 
0B15FA DD    1776** LD      (IX+1),H		; The maximum (original) string length
0B15FB 74 
0B15FC 01 
0B15FD D9    1777** EXX
0B15FE DD    1778** LD	(IX+2),HL		; The pointer to the original string
0B15FF 2F 
0B1600 02 
             1779** ;
0B1601 01    1780** LD	BC, 0
0B1602 00 
0B1603 00 
0B1604 00 
0B1605 4B    1781** LD      C,E			; BC: The new string length
0B1606 EB    1782** EX      DE,HL
0B1607 E1    1783** POP     HL
0B1608 0D    1784** DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
0B1609 0C    1785** INC     C			; check whether BC is 0 without affecting the carry flag
0B160A C8    1786** RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
0B160B ED    1787** LDIR				; Replace the string in memory
0B160C B0 
0B160D D0    1788** RET     NC
0B160E ED    1789** LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
0B160F 53 
0B1610 1D 
0B1611 5E 
0B1611 0B   
             1790** ;
             1791** ; Check whether the stack is full
             1792** ;
0B1613 E5    1793** CHECK:			PUSH    HL
0B1614 C5    1794** PUSH	BC
0B1615 2A    1795** LD      HL,(FREE)		; HL: Address of first free space byte
0B1616 1D 
0B1617 5E 
0B1618 0B 
0B1619 01    1796** LD	BC,100h			; BC: One page of memory
0B161A 00 
0B161B 01 
0B161C 00 
0B161D 09    1797** ADD	HL,BC			; Add a page to FREE
0B161E ED    1798** SBC     HL,SP			; And subtract the current SP
0B161F 72 
0B1620 C1    1799** POP	BC
0B1621 E1    1800** POP     HL
0B1622 D8    1801** RET     C			; The SP is not in the same page, so just return
0B1623 AF    1802** XOR     A			; Otherwise
0B1624 C3    1803** JP      ERROR_			; Throw error "No room"
0B1625 24 
0B1626 37 
0B1627 0B 
             1804** ;
0B1628 01    1805** STORS3:			LD	BC,0
0B1629 00 
0B162A 00 
0B162B 00 
0B162C 4B    1806** LD      C,E			; BC: String length
0B162D DD    1807** PUSH    IX
0B162E E5 
0B162F D1    1808** POP     DE			; DE: Destination
0B1630 AF    1809** XOR     A			; Check if string length is 0
0B1631 B9    1810** CP      C
0B1632 28    1811** JR      Z,STORS5		; Yes, so don't copy
0B1633 02 
0B1634 ED    1812** LDIR
0B1635 B0 
0B1636 3E    1813** STORS5:			LD      A,CR			; Finally add the terminator
0B1637 0D 
0B1638 12    1814** LD      (DE),A
0B1639 C9    1815** RET
             1816** 
             1817** ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
             1818** ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
             1819** ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
             1820** ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
             1821** ;    Inputs: DE addresses parameter list
             1822** ;            IY addresses dummy variable list
             1823** ;   Outputs: DE,IY updated
             1824** ;  Destroys: Everything
             1825** ;
0B163A 3E    1826** ARGUE:			LD      A,-1
0B163B FF 
0B163C F5    1827** PUSH    AF              	; Put marker on the stack
0B163D FD    1828** ARGUE1:			INC     IY              	; Bump past '(' or ',''
0B163E 23 
0B163F 13    1829** INC     DE
0B1640 D5    1830** PUSH    DE
0B1641 CD    1831** CALL    NXT			; Skip any whitespace
0B1642 34 
0B1643 0A 
0B1644 0B 
0B1645 CD    1832** CALL    GETVAR			; Get the location of the variable in HL/IX
0B1646 FE 
0B1647 39 
0B1648 0B 
0B1649 38    1833** JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0B164A 3F 
0B164B C4    1834** CALL    NZ,PUTVAR
0B164C ED 
0B164D 39 
0B164E 0B 
0B164F D1    1835** POP     DE
0B1650 E5    1836** PUSH    HL              	; VARPTR
0B1651 B7    1837** OR      A               	; Check the variable type
0B1652 F5    1838** PUSH    AF
0B1653 D5    1839** PUSH    DE
0B1654 FD    1840** EX      (SP),IY
0B1655 E3 
0B1656 FA    1841** JP      M,ARGUE2        	; Jump here if it is a string
0B1657 6E 
0B1658 16 
0B1659 0B 
             1842** ;
0B165A CD    1843** CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0B165B C6 
0B165C 02 
0B165D 0B 
0B165E FD    1844** EX      (SP),IY
0B165F E3 
0B1660 D1    1845** POP     DE
0B1661 F1    1846** POP     AF
0B1662 D9    1847** EXX
0B1663 E5    1848** PUSH    HL
0B1664 D9    1849** EXX
0B1665 E5    1850** PUSH    HL
0B1666 47    1851** LD      B,A
0B1667 C5    1852** PUSH    BC
0B1668 CD    1853** CALL    CHECK           	; Check room
0B1669 13 
0B166A 16 
0B166B 0B 
0B166C 18    1854** JR      ARGUE4
0B166D 0F 
             1855** ;
0B166E CD    1856** ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0B166F D9 
0B1670 02 
0B1671 0B 
0B1672 FD    1857** EX      (SP),IY
0B1673 E3 
0B1674 D9    1858** EXX
0B1675 D1    1859** POP     DE
0B1676 D9    1860** EXX
0B1677 F1    1861** POP     AF
0B1678 CD    1862** CALL    PUSHS
0B1679 78 
0B167A 09 
0B167B 0B 
0B167C D9    1863** EXX
             1864** ;
0B167D CD    1865** ARGUE4:			CALL    NXT			; Skip whitespace
0B167E 34 
0B167F 0A 
0B1680 0B 
0B1681 FE    1866** CP      ','			; Check to see if the next value is a comma
0B1682 2C 
0B1683 20    1867** JR      NZ,ARGUE5		; No, so jump here
0B1684 0B 
0B1685 1A    1868** LD      A,(DE)
0B1686 FE    1869** CP      ','			; Are there any more arguments?
0B1687 2C 
0B1688 28    1870** JR      Z,ARGUE1        	; Yes, so loop
0B1689 B3 
             1871** ;
0B168A 3E    1872** ARGERR:			LD      A,31
0B168B 1F 
0B168C C3    1873** JP      ERROR_           	; Throw error "Arguments"
0B168D 24 
0B168E 37 
0B168F 0B 
             1874** ;
0B1690 CD    1875** ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0B1691 F3 
0B1692 09 
0B1693 0B 
0B1694 1A    1876** LD      A,(DE)
0B1695 FE    1877** CP      ')'
0B1696 29 
0B1697 20    1878** JR      NZ,ARGERR
0B1698 F1 
0B1699 13    1879** INC     DE
0B169A D9    1880** EXX
0B169B C1    1881** ARGUE6:			POP     BC
0B169C 78    1882** LD      A,B
0B169D 3C    1883** INC     A
0B169E D9    1884** EXX
0B169F C8    1885** RET     Z               	; Marker popped
0B16A0 D9    1886** EXX
0B16A1 3D    1887** DEC     A
0B16A2 FA    1888** JP      M,ARGUE7        	; If it is a string, then jump here
0B16A3 B2 
0B16A4 16 
0B16A5 0B 
0B16A6 E1    1889** POP     HL
0B16A7 D9    1890** EXX
0B16A8 E1    1891** POP     HL
0B16A9 D9    1892** EXX
0B16AA DD    1893** POP     IX
0B16AB E1 
0B16AC CD    1894** CALL    STORE	           	; Write to dummy variable
0B16AD 9A 
0B16AE 15 
0B16AF 0B 
0B16B0 18    1895** JR      ARGUE6
0B16B1 E9 
             1896** ;
0B16B2 CD    1897** ARGUE7:			CALL    POPS
0B16B3 A2 
0B16B4 09 
0B16B5 0B 
0B16B6 DD    1898** POP     IX
0B16B7 E1 
0B16B8 CD    1899** CALL    STACCS
0B16B9 C4 
0B16BA 15 
0B16BB 0B 
0B16BC 18    1900** JR      ARGUE6
0B16BD DD 
             1901** 
             1902** ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
             1903** ;   OF A FUNCTION OR PROCEDURE.
             1904** ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
             1905** ;    Inputs: IY is parameters pointer
             1906** ;   Outputs: IY updated
             1907** ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
             1908** ;
0B16BE D1    1909** SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
             1910** ;
0B16BF FD    1911** SAVLO1:			INC     IY              	; Bump past '(' or ','
0B16C0 23 
0B16C1 CD    1912** CALL    NXT			; And also any whitespace
0B16C2 34 
0B16C3 0A 
0B16C4 0B 
0B16C5 D5    1913** PUSH    DE			; Push the return address back onto the stack
0B16C6 D9    1914** EXX
0B16C7 C5    1915** PUSH    BC
0B16C8 D5    1916** PUSH    DE
0B16C9 E5    1917** PUSH    HL
0B16CA D9    1918** EXX
0B16CB CD    1919** CALL    VAR_             	; Dummy variable
0B16CC 52 
0B16CD 0C 
0B16CE 0B 
0B16CF D9    1920** EXX
0B16D0 E1    1921** POP     HL
0B16D1 D1    1922** POP     DE
0B16D2 C1    1923** POP     BC
0B16D3 D9    1924** EXX
0B16D4 D1    1925** POP     DE
0B16D5 B7    1926** OR      A               	; Check the variable type
0B16D6 FA    1927** JP      M,SAVLO2        	; 80h = string, so jump to save a local string
0B16D7 E9 
0B16D8 16 
0B16D9 0B 
0B16DA D9    1928** EXX
0B16DB E5    1929** PUSH    HL              	; Save H'L'
0B16DC D9    1930** EXX
0B16DD 47    1931** LD      B,A             	;  B: Variable type
0B16DE CD    1932** CALL    LOADN
0B16DF DA 
0B16E0 03 
0B16E1 0B 
0B16E2 D9    1933** EXX
0B16E3 E3    1934** EX      (SP),HL
0B16E4 D9    1935** EXX
0B16E5 E5    1936** PUSH    HL
0B16E6 C5    1937** PUSH    BC
0B16E7 18    1938** JR      SAVLO4
0B16E8 2D 
             1939** ;
0B16E9 F5    1940** SAVLO2:			PUSH    AF              	; Save the type (string)
0B16EA D5    1941** PUSH    DE
0B16EB D9    1942** EXX
0B16EC E5    1943** PUSH    HL
0B16ED D9    1944** EXX
0B16EE CD    1945** CALL    LOADS
0B16EF 64 
0B16F0 04 
0B16F1 0B 
0B16F2 D9    1946** EXX
0B16F3 E1    1947** POP     HL
0B16F4 D9    1948** EXX
0B16F5 01    1949** LD	BC,0
0B16F6 00 
0B16F7 00 
0B16F8 00 
0B16F9 4B    1950** LD      C,E			; BC: String length
0B16FA D1    1951** POP     DE
0B16FB CD    1952** CALL    CHECK			; Check if there is space on the stack
0B16FC 13 
0B16FD 16 
0B16FE 0B 
0B16FF F1    1953** POP     AF              	; Level stack
0B1700 21    1954** LD      HL,0
0B1701 00 
0B1702 00 
0B1703 00 
0B1704 ED    1955** SBC     HL,BC			; HL: Number of bytes required on the stack for the string
0B1705 42 
0B1706 39    1956** ADD     HL,SP			; Make space for the string on the stack
0B1707 F9    1957** LD      SP,HL
0B1708 47    1958** LD      B,A             	;  B: Variable type
0B1709 C5    1959** PUSH    BC
0B170A 28    1960** JR      Z,SAVLO4
0B170B 0A 
0B170C D5    1961** PUSH    DE
0B170D 11    1962** LD      DE,ACCS
0B170E 00 
0B170F 5B 
0B1710 0B 
0B1711 EB    1963** EX      DE,HL
0B1712 45    1964** LD      B,L
0B1713 ED    1965** LDIR                    	; Save the string onto the stack
0B1714 B0 
0B1715 D1    1966** POP     DE
             1967** ;
0B1716 DD    1968** SAVLO4:			PUSH    IX			; VARPTR
0B1717 E5 
0B1718 CD    1969** CALL    SAVLO5
0B1719 1C 
0B171A 17 
0B171B 0B 
             1970** LOCCHK:			EQU     $
0B171C CD    1971** SAVLO5:			CALL    CHECK
0B171D 13 
0B171E 16 
0B171F 0B 
0B1720 CD    1972** CALL    NXT
0B1721 34 
0B1722 0A 
0B1723 0B 
0B1724 FE    1973** CP      ','             	; Are there any more local variables?
0B1725 2C 
0B1726 28    1974** JR      Z,SAVLO1		; Yes, so loop
0B1727 97 
0B1728 EB    1975** EX      DE,HL			; DE -> HL: The return address
0B1729 E9    1976** JP      (HL)            	; And effectvely return
             1977** ;
0B172A FD    1978** DELIM:			LD      A,(IY)          	; Assembler delimiter
0B172B 7E 
0B172C 00 
0B172D FE    1979** CP      ' '
0B172E 20 
0B172F C8    1980** RET     Z
0B1730 FE    1981** CP      ','
0B1731 2C 
0B1732 C8    1982** RET     Z
0B1733 FE    1983** CP      ')'
0B1734 29 
0B1735 C8    1984** RET     Z
0B1736 FE    1985** TERM:			CP      ';'             	; Assembler terminator
0B1737 3B 
0B1738 C8    1986** RET     Z
0B1739 FE    1987** CP      '\'
0B173A 5C 
0B173B C8    1988** RET     Z
0B173C 18    1989** JR      TERM0
0B173D 07 
             1990** ;
0B173E CD    1991** TERMQ:			CALL    NXT
0B173F 34 
0B1740 0A 
0B1741 0B 
0B1742 FE    1992** CP      ELSE_EX_
0B1743 8B 
0B1744 D0    1993** RET     NC
0B1745 FE    1994** TERM0:			CP      ':'             	; Assembler seperator
0B1746 3A 
0B1747 D0    1995** RET     NC
0B1748 FE    1996** CP      CR
0B1749 0D 
0B174A C9    1997** RET
             1998** ;
0B174B CD    1999** SPAN:			CALL    TERMQ
0B174C 3E 
0B174D 17 
0B174E 0B 
0B174F C8    2000** RET     Z
0B1750 FD    2001** INC     IY
0B1751 23 
0B1752 18    2002** JR      SPAN
0B1753 F7 
             2003** ;
             2004** ; This snippet is used to check whether an expression is followed by an '=' symbol
             2005** ;
0B1754 CD    2006** EQUALS:			CALL    NXT			; Skip whitespace
0B1755 34 
0B1756 0A 
0B1757 0B 
0B1758 FD    2007** INC     IY			; Skip past the character in question
0B1759 23 
0B175A FE    2008** CP      '='			; Is it '='
0B175B 3D 
0B175C C8    2009** RET     Z			; Yes, so return
0B175D 3E    2010** LD      A,4			; Otherwise
0B175E 04 
0B175F C3    2011** JP      ERROR_           	; Throw error "Mistake"
0B1760 24 
0B1761 37 
0B1762 0B 
             2012** ;
0B1763 FE    2013** FORMAT:			CP      TAB
0B1764 8A 
0B1765 28    2014** JR      Z,DOTAB
0B1766 0D 
0B1767 FE    2015** CP      SPC
0B1768 89 
0B1769 28    2016** JR      Z,DOSPC
0B176A 40 
0B176B FE    2017** CP      '''
0B176C 27 
0B176D C0    2018** RET     NZ
0B176E CD    2019** CALL    CRLF
0B176F 0B 
0B1770 39 
0B1771 0B 
0B1772 AF    2020** XOR     A
0B1773 C9    2021** RET
             2022** ;
0B1774 C5    2023** DOTAB:			PUSH    BC
0B1775 CD    2024** CALL    EXPRI
0B1776 CE 
0B1777 02 
0B1778 0B 
0B1779 D9    2025** EXX
0B177A C1    2026** POP     BC
0B177B FD    2027** LD      A,(IY)
0B177C 7E 
0B177D 00 
0B177E FE    2028** CP      ','
0B177F 2C 
0B1780 28    2029** JR      Z,DOTAB1
0B1781 14 
0B1782 CD    2030** CALL    BRAKET
0B1783 F3 
0B1784 09 
0B1785 0B 
0B1786 7D    2031** LD      A,L
0B1787 21    2032** TABIT:			LD      HL,COUNT
0B1788 3D 
0B1789 5E 
0B178A 0B 
0B178B BE    2033** CP      (HL)
0B178C C8    2034** RET     Z
0B178D F5    2035** PUSH    AF
0B178E DC    2036** CALL    C,CRLF
0B178F 0B 
0B1790 39 
0B1791 0B 
0B1792 F1    2037** POP     AF
0B1793 96    2038** SUB     (HL)
0B1794 18    2039** JR      FILL
0B1795 1D 
0B1796 FD    2040** DOTAB1:			INC     IY
0B1797 23 
0B1798 C5    2041** PUSH    BC
0B1799 E5    2042** PUSH    HL
0B179A CD    2043** CALL    EXPRI
0B179B CE 
0B179C 02 
0B179D 0B 
0B179E D9    2044** EXX
0B179F D1    2045** POP     DE
0B17A0 C1    2046** POP     BC
0B17A1 CD    2047** CALL    BRAKET
0B17A2 F3 
0B17A3 09 
0B17A4 0B 
0B17A5 CD    2048** CALL    PUTCSR
0B17A6 85 
0B17A7 3E 
0B17A8 0B 
0B17A9 AF    2049** XOR     A
0B17AA C9    2050** RET
             2051** ;
0B17AB C5    2052** DOSPC:			PUSH    BC
0B17AC CD    2053** CALL    ITEMI
0B17AD E9 
0B17AE 02 
0B17AF 0B 
0B17B0 D9    2054** EXX
0B17B1 7D    2055** LD      A,L
0B17B2 C1    2056** POP     BC
0B17B3 B7    2057** FILL:			OR      A
0B17B4 C8    2058** RET     Z
0B17B5 C5    2059** PUSH    BC
0B17B6 47    2060** LD      B,A
0B17B7 3E    2061** FILL1:			LD      A,' '
0B17B8 20 
0B17B9 CD    2062** CALL    OUTCHR
0B17BA 13 
0B17BB 39 
0B17BC 0B 
0B17BD 10    2063** DJNZ    FILL1
0B17BE F8 
0B17BF C1    2064** POP     BC
0B17C0 AF    2065** XOR     A
0B17C1 C9    2066** RET
             2067** ;
0B17C2 21    2068** PTEXT:			LD      HL,ACCS
0B17C3 00 
0B17C4 5B 
0B17C5 0B 
0B17C6 1C    2069** INC     E
0B17C7 1D    2070** PTEXT1:			DEC     E
0B17C8 C8    2071** RET     Z
0B17C9 7E    2072** LD      A,(HL)
0B17CA 23    2073** INC     HL
0B17CB CD    2074** CALL    OUTCHR
0B17CC 13 
0B17CD 39 
0B17CE 0B 
0B17CF 18    2075** JR      PTEXT1
0B17D0 F6 
             2076** ;
0B17D1 F5    2077** FETCHS:			PUSH    AF
0B17D2 C5    2078** PUSH    BC
0B17D3 E5    2079** PUSH    HL
0B17D4 FD    2080** EX      (SP),IY
0B17D5 E3 
0B17D6 CD    2081** CALL    XTRACT
0B17D7 F1 
0B17D8 17 
0B17D9 0B 
0B17DA CD    2082** CALL    NXT
0B17DB 34 
0B17DC 0A 
0B17DD 0B 
0B17DE FD    2083** EX      (SP),IY
0B17DF E3 
0B17E0 E1    2084** POP     HL
0B17E1 C1    2085** POP     BC
0B17E2 F1    2086** POP     AF
0B17E3 C9    2087** RET
             2088** ;
0B17E4 11    2089** LINES:			LD      DE,ACCS
0B17E5 00 
0B17E6 5B 
0B17E7 0B 
0B17E8 7E    2090** LINE1S:			LD      A,(HL)
0B17E9 12    2091** LD      (DE),A
0B17EA FE    2092** CP      CR
0B17EB 0D 
0B17EC C8    2093** RET     Z
0B17ED 23    2094** INC     HL
0B17EE 1C    2095** INC     E
0B17EF 18    2096** JR      LINE1S
0B17F0 F7 
             2097** ;
0B17F1 CD    2098** XTRACT:			CALL    NXT
0B17F2 34 
0B17F3 0A 
0B17F4 0B 
0B17F5 FE    2099** CP      '"'
0B17F6 22 
0B17F7 FD    2100** INC     IY
0B17F8 23 
0B17F9 CA    2101** JP      Z,CONS
0B17FA 2B 
0B17FB 04 
0B17FC 0B 
0B17FD FD    2102** DEC     IY
0B17FE 2B 
0B17FF 11    2103** LD      DE,ACCS
0B1800 00 
0B1801 5B 
0B1802 0B 
0B1803 FD    2104** XTRAC1:			LD      A,(IY)
0B1804 7E 
0B1805 00 
0B1806 12    2105** LD      (DE),A
0B1807 FE    2106** CP      ','
0B1808 2C 
0B1809 C8    2107** RET     Z
0B180A FE    2108** CP      CR
0B180B 0D 
0B180C C8    2109** RET     Z
0B180D FD    2110** INC     IY
0B180E 23 
0B180F 1C    2111** INC     E
0B1810 18    2112** JR      XTRAC1
0B1811 F1 
             2113** 
             2114** ; Search for a token at the start of a program line
             2115** ; - HL: Pointer to the start of a tokenised line in the program area
             2116** ; Returns:
             2117** ; - HL: Pointer to the
             2118** ; -  F: Carry set if not found
             2119** ; Corrupts:
             2120** ; - BC
             2121** ;
0B1812 01    2122** SEARCH_EX:			LD      BC,0			; Clear BC
0B1813 00 
0B1814 00 
0B1815 00 
             2123** ;
0B1816 4E    2124** SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
0B1817 0C    2125** INC     C			; Check for 0, i.e. end of program marker
0B1818 0D    2126** DEC     C
0B1819 28    2127** JR      Z,SRCH2_EX         	; Not found the token, so end
0B181A 0B 
0B181B 23    2128** INC     HL			; Skip the line length and line number
0B181C 23    2129** INC     HL
0B181D 23    2130** INC     HL
0B181E BE    2131** CP      (HL)			; Compare with the token
0B181F C8    2132** RET     Z			; Found it, so return with carry not set
0B1820 0D    2133** DEC     C			; Skip to the next line
0B1821 0D    2134** DEC     C
0B1822 0D    2135** DEC     C
0B1823 09    2136** ADD     HL,BC
0B1824 18    2137** JR      SRCH1_EX			; Rinse, lather and repeat
0B1825 F0 
             2138** ;
0B1826 2B    2139** SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0B1827 37    2140** SCF				; And set the carry flag
0B1828 C9    2141** RET
             2142** 
             2143** ; Multiply by 4 or 5
             2144** ; This function is used to allocate space for dimensioned variables
             2145** ; This is a 24-bit operation
             2146** ; - DE: Number to multiple
             2147** ; -  A: 04h (Integer) - takes up 4 bytes
             2148** ;       05h (Float)   - takes up 5 bytes
             2149** ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
             2150** ; Returns:
             2151** ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
             2152** ; -  F: Carry if overflow
             2153** ; Corrupts:
             2154** ; - HL
0B1829 FE    2155** X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0B182A 04 
             2156** ; LD	HL,DE
0B182B D5    2157** push de
0B182C E1    2158** pop hl
0B182D 29    2159** ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0B182E D8    2160** RET     C			; Exit if overflow
0B182F 29    2161** ADD     HL,HL			; Multiply by 2 again
0B1830 D8    2162** RET     C			; Exit if overflow
0B1831 EB    2163** EX      DE,HL			; DE: Product
0B1832 C8    2164** RET     Z			; Exit if A = 4
0B1833 19    2165** ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0B1834 EB    2166** EX      DE,HL			; DE: Product
0B1835 C9    2167** RET
             2168** 
             2169** ; 16-bit unsigned multiply
             2170** ; - HL: Operand 1
             2171** ; - BC: Operand 2
             2172** ; Returns:
             2173** ; - HL: Result
             2174** ; -  F: C if overflow
             2175** ;
0B1836 C5    2176** MUL16:			PUSH	BC
0B1837 51    2177** LD	D, C			; Set up the registers for the multiplies
0B1838 5D    2178** LD	E, L
0B1839 69    2179** LD	L, C
0B183A 4B    2180** LD	C, E
0B183B ED    2181** MLT	HL			; HL = H * C (*256)
0B183C 6C 
0B183D ED    2182** MLT	DE			; DE = L * C
0B183E 5C 
0B183F ED    2183** MLT	BC			; BC = B * L (*256)
0B1840 4C 
0B1841 09    2184** ADD	HL, BC			; HL = The sum of the two most significant multiplications
0B1842 C1    2185** POP	BC
0B1843 AF    2186** XOR	A
0B1844 9C    2187** SBC	H			; If H is not zero then it's an overflow
0B1845 D8    2188** RET	C
0B1846 65    2189** LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0B1847 6F    2190** LD	L, A
0B1848 19    2191** ADD	HL, DE
0B1849 C9    2192** RET
             2193** ;
0B184A CD    2194** CHANEL:			CALL    NXT			; Skip whitespace
0B184B 34 
0B184C 0A 
0B184D 0B 
0B184E FE    2195** CP      '#'			; Check for the '#' symbol
0B184F 23 
0B1850 3E    2196** LD      A,45
0B1851 2D 
0B1852 C2    2197** JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0B1853 24 
0B1854 37 
0B1855 0B 
0B1856 FD    2198** CHNL:			INC     IY             		; Bump past the '#'
0B1857 23 
0B1858 CD    2199** CALL    ITEMI			; Get the channel number
0B1859 E9 
0B185A 02 
0B185B 0B 
0B185C D9    2200** EXX
0B185D EB    2201** EX      DE,HL			; DE: The channel number
0B185E C9    2202** RET
             2203** 
             2204** ; ASSEMBLER -------------------------------------------------------------------
             2205** 
             2206** ; Language independant control section:
             2207** ;  Outputs: A=delimiter, carry set if syntax error.
             2208** ;
0B185F CD    2209** ASSEM:			CALL    SKIP
0B1860 79 
0B1861 1D 
0B1862 0B 
0B1863 FD    2210** INC     IY
0B1864 23 
0B1865 FE    2211** CP      ':'
0B1866 3A 
0B1867 28    2212** JR      Z,ASSEM
0B1868 F6 
0B1869 FE    2213** CP      ']'
0B186A 5D 
0B186B C8    2214** RET     Z
0B186C FE    2215** CP      CR
0B186D 0D 
0B186E C8    2216** RET     Z
0B186F FD    2217** DEC     IY
0B1870 2B 
0B1871 DD    2218** LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
0B1872 2A 
0B1873 40 
0B1874 5D 
0B1874 0B   
0B1876 21    2219** LD      HL,LISTON
0B1877 40 
0B1878 5E 
0B1879 0B 
0B187A CB    2220** BIT     6,(HL)
0B187B 76 
0B187C 28    2221** JR      Z,ASSEM0
0B187D 05 
0B187E DD    2222** LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
0B187F 2A 
0B1880 3C 
0B1881 5D 
0B1881 0B   
0B1883 DD    2223** ASSEM0:			PUSH    IX
0B1884 E5 
0B1885 FD    2224** PUSH    IY
0B1886 E5 
0B1887 CD    2225** CALL    ASMB
0B1888 37 
0B1889 19 
0B188A 0B 
0B188B C1    2226** POP     BC
0B188C D1    2227** POP     DE
0B188D D8    2228** RET     C
0B188E CD    2229** CALL    SKIP
0B188F 79 
0B1890 1D 
0B1891 0B 
0B1892 37    2230** SCF
0B1893 C0    2231** RET     NZ
0B1894 FD    2232** DEC     IY
0B1895 2B 
0B1896 FD    2233** ASSEM3:			INC     IY
0B1897 23 
0B1898 FD    2234** LD      A,(IY)
0B1899 7E 
0B189A 00 
0B189B CD    2235** CALL    TERM0
0B189C 45 
0B189D 17 
0B189E 0B 
0B189F 20    2236** JR      NZ,ASSEM3
0B18A0 F5 
0B18A1 3A    2237** LD      A,(LISTON)
0B18A2 40 
0B18A3 5E 
0B18A4 0B 
0B18A5 DD    2238** PUSH    IX
0B18A6 E5 
0B18A7 E1    2239** POP     HL
0B18A8 B7    2240** OR      A
0B18A9 ED    2241** SBC     HL,DE
0B18AA 52 
0B18AB EB    2242** EX      DE,HL           	; DE: Number of bytes
0B18AC E5    2243** PUSH    HL
0B18AD 2A    2244** LD      HL,(PC)
0B18AE 40 
0B18AF 5D 
0B18B0 0B 
0B18B1 E5    2245** PUSH    HL
0B18B2 19    2246** ADD     HL,DE
0B18B3 22    2247** LD      (PC),HL         	; Update PC
0B18B4 40 
0B18B5 5D 
0B18B6 0B 
0B18B7 CB    2248** BIT     6,A
0B18B8 77 
0B18B9 28    2249** JR      Z,ASSEM5
0B18BA 09 
0B18BB 2A    2250** LD      HL,(OC)
0B18BC 3C 
0B18BD 5D 
0B18BE 0B 
0B18BF 19    2251** ADD     HL,DE
0B18C0 22    2252** LD      (OC),HL         	; Update OC
0B18C1 3C 
0B18C2 5D 
0B18C3 0B 
0B18C4 E1    2253** ASSEM5:			POP     HL              	; Old PC
0B18C5 DD    2254** POP     IX              	; Code here
0B18C6 E1 
0B18C7 CB    2255** BIT     4,A
0B18C8 67 
0B18C9 28    2256** JR      Z,ASSEM
0B18CA 94 
0B18CB 22    2257** LD	(R0),HL			; Store HL in R0 so we can access the MSB
0B18CC 4A 
0B18CD 5E 
0B18CE 0B 
0B18CF 3A    2258** LD	A,(R0+2)		; Print out the address
0B18D0 4C 
0B18D1 5E 
0B18D2 0B 
0B18D3 CD    2259** CALL	HEX_EX
0B18D4 21 
0B18D5 19 
0B18D6 0B 
0B18D7 7C    2260** LD      A,H
0B18D8 CD    2261** CALL    HEX_EX
0B18D9 21 
0B18DA 19 
0B18DB 0B 
0B18DC 7D    2262** LD      A,L
0B18DD CD    2263** CALL    HEXSP
0B18DE 19 
0B18DF 19 
0B18E0 0B 
0B18E1 AF    2264** XOR     A
0B18E2 BB    2265** CP      E
0B18E3 28    2266** JR      Z,ASSEM2
0B18E4 18 
             2267** ;
0B18E5 3A    2268** ASSEM1:			LD      A,(COUNT)
0B18E6 3D 
0B18E7 5E 
0B18E8 0B 
0B18E9 FE    2269** CP      20
0B18EA 14 
0B18EB 3E    2270** LD      A,7
0B18EC 07 
0B18ED D4    2271** CALL    NC,TABIT        	; Next line
0B18EE 87 
0B18EF 17 
0B18F0 0B 
0B18F1 DD    2272** LD      A,(IX)
0B18F2 7E 
0B18F3 00 
0B18F4 CD    2273** CALL    HEXSP
0B18F5 19 
0B18F6 19 
0B18F7 0B 
0B18F8 DD    2274** INC     IX
0B18F9 23 
0B18FA 1D    2275** DEC     E
0B18FB 20    2276** JR      NZ,ASSEM1
0B18FC E8 
             2277** ;
0B18FD 3E    2278** ASSEM2:			LD      A,22			; Tab to the disassembly field
0B18FE 16 
0B18FF CD    2279** CALL    TABIT
0B1900 87 
0B1901 17 
0B1902 0B 
0B1903 FD    2280** PUSH    IY
0B1904 E5 
0B1905 E1    2281** POP     HL
0B1906 ED    2282** SBC     HL,BC
0B1907 42 
0B1908 0A    2283** ASSEM4:			LD      A,(BC)
0B1909 CD    2284** CALL    OUT_
0B190A 30 
0B190B 39 
0B190C 0B 
0B190D 03    2285** INC     BC
0B190E 2D    2286** DEC     L
0B190F 20    2287** JR      NZ,ASSEM4
0B1910 F7 
0B1911 CD    2288** CALL    CRLF
0B1912 0B 
0B1913 39 
0B1914 0B 
0B1915 C3    2289** JP      ASSEM
0B1916 5F 
0B1917 18 
0B1918 0B 
             2290** ;
0B1919 CD    2291** HEXSP:			CALL    HEX_EX
0B191A 21 
0B191B 19 
0B191C 0B 
0B191D 3E    2292** LD      A,' '
0B191E 20 
0B191F 18    2293** JR      OUTCH1
0B1920 12 
0B1921 F5    2294** HEX_EX:			PUSH    AF
0B1922 0F    2295** RRCA
0B1923 0F    2296** RRCA
0B1924 0F    2297** RRCA
0B1925 0F    2298** RRCA
0B1926 CD    2299** CALL    HEXOUT
0B1927 2B 
0B1928 19 
0B1929 0B 
0B192A F1    2300** POP     AF
0B192B E6    2301** HEXOUT:			AND     0FH
0B192C 0F 
0B192D C6    2302** ADD     A,90H
0B192E 90 
0B192F 27    2303** DAA
0B1930 CE    2304** ADC     A,40H
0B1931 40 
0B1932 27    2305** DAA
0B1933 C3    2306** OUTCH1:			JP      OUT_
0B1934 30 
0B1935 39 
0B1936 0B 
             2307** 
             2308** ; Processor Specific Translation Section:
             2309** ;
             2310** ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
             2311** ;                 C: Opcode beig built
             2312** ;                 D: Flags
             2313** ;			Bit 7: Set to 1 if the instruction uses long addressing
             2314** ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
             2315** ;                 E: Offset from IX or IY
             2316** ;                HL: Numeric operand value
             2317** ;                IX: Code destination pointer
             2318** ;                IY: Source text pointer
             2319** ;    Inputs: A = initial character
             2320** ;   Outputs: Carry set if syntax error.
             2321** ;
0B1937 FE    2322** ASMB:			CP      '.'			; Check for a dot; this indicates a label
0B1938 2E 
0B1939 20    2323** JR      NZ,ASMB1		; No, so just process the instruction
0B193A 1F 
0B193B FD    2324** INC     IY			; Skip past the dot to the label name
0B193C 23 
0B193D DD    2325** PUSH    IX			; Store the code destination pointer
0B193E E5 
0B193F CD    2326** CALL    VAR_			; Create a variable
0B1940 52 
0B1941 0C 
0B1942 0B 
0B1943 F5    2327** PUSH    AF
0B1944 CD    2328** CALL    ZERO			; Zero it
0B1945 57 
0B1946 09 
0B1947 0B 
0B1948 3A    2329** LD	A,(PC+2)
0B1949 42 
0B194A 5D 
0B194B 0B 
0B194C 6F    2330** LD	L,A			; The MSB of the 24-bit address
0B194D D9    2331** EXX
0B194E 2A    2332** LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0B194F 40 
0B1950 5D 
0B1951 0B 
0B1952 D9    2333** EXX
0B1953 F1    2334** POP     AF
0B1954 CD    2335** CALL    STORE			; Store the program counter
0B1955 9A 
0B1956 15 
0B1957 0B 
0B1958 DD    2336** POP     IX			; Restore the code destination pointer
0B1959 E1 
             2337** ;
0B195A 3A    2338** ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0B195B 40 
0B195C 5E 
0B195D 0B 
0B195E E6    2339** AND	80H
0B195F 80 
0B1960 57    2340** LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0B1961 CD    2341** CALL    SKIP			; Skip any whitespace
0B1962 79 
0B1963 1D 
0B1964 0B 
0B1965 C8    2342** RET     Z			; And return if there is nothing further to process
0B1966 FE    2343** CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0B1967 D6 
0B1968 0E    2344** LD      C,0C4H			;  A: The base operand
0B1969 C4 
0B196A FD    2345** INC     IY			; Skip past the token
0B196B 23 
0B196C CA    2346** JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0B196D AE 
0B196E 1A 
0B196F 0B 
0B1970 FD    2347** DEC     IY			; Skip back, as we're not doing the above at this point
0B1971 2B 
0B1972 21    2348** LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0B1973 90 
0B1974 1D 
0B1975 0B 
0B1976 CD    2349** CALL    FIND			; Find the opcode
0B1977 28 
0B1978 1D 
0B1979 0B 
0B197A D8    2350** RET     C			; If not found, then return; carry indicates an error condition
0B197B 48    2351** LD      C,B     		;  C: A copy of the opcode
             2352** ;
             2353** ; GROUP 0: Trivial cases requiring no computation
             2354** ; GROUP 1: As Group 0, but with "ED" prefix
             2355** ;
0B197C D6    2356** SUB     68			; The number of opcodes in GROUP0 and GROUP1
0B197D 44 
0B197E 30    2357** JR      NC,GROUP02		; If not in that range, then check GROUP2
0B197F 08 
0B1980 FE    2358** CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0B1981 CB 
0B1982 D4    2359** CALL    NC,ED			; Needs to be prefixed with ED
0B1983 81 
0B1984 1C 
0B1985 0B 
0B1986 18    2360** JR      BYTE0			; Then write the opcode byte
0B1987 76 
             2361** ;
             2362** ; GROUP 2: BIT, RES, SET
             2363** ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
             2364** ;
0B1988 D6    2365** GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0B1989 0A 
0B198A 30    2366** JR      NC,GROUP04		; If not in that range, then check GROUP4
0B198B 12 
0B198C FE    2367** CP      3-10			;
0B198D F9 
0B198E DC    2368** CALL    C,BIT_
0B198F 16 
0B1990 1D 
0B1991 0B 
0B1992 D8    2369** RET     C
0B1993 CD    2370** CALL    REGLO
0B1994 E7 
0B1995 1C 
0B1996 0B 
0B1997 D8    2371** RET     C
0B1998 CD    2372** CALL    CB
0B1999 85 
0B199A 1C 
0B199B 0B 
0B199C 18    2373** JR      BYTE0
0B199D 60 
             2374** ;
             2375** ; GROUP 4 - PUSH, POP, EX (SP)
             2376** ;
0B199E D6    2377** GROUP04:		SUB     3			; The number of opcodes in GROUP4
0B199F 03 
0B19A0 30    2378** JR      NC,GROUP05		; If not in that range, then check GROUP5
0B19A1 07 
0B19A2 CD    2379** GROUP04_1:		CALL    PAIR_EX
0B19A3 09 
0B19A4 1D 
0B19A5 0B 
0B19A6 D8    2380** RET     C
0B19A7 18    2381** JR      BYTE0
0B19A8 55 
             2382** ;
             2383** ; GROUP 5 - SUB, AND, XOR, OR, CP
             2384** ; GROUP 6 - ADD, ADC, SBC
             2385** ;
0B19A9 D6    2386** GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0B19AA 0A 
0B19AB 30    2387** JR      NC,GROUP07
0B19AC 39 
0B19AD FE    2388** CP      5-8
0B19AE FD 
0B19AF 06    2389** LD      B,7
0B19B0 07 
0B19B1 D4    2390** CALL    NC,OPND			; Get the first operand
0B19B2 95 
0B19B3 1C 
0B19B4 0B 
0B19B5 78    2391** LD      A,B
0B19B6 FE    2392** CP      7			; Is the operand 'A'?
0B19B7 07 
0B19B8 20    2393** JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0B19B9 15 
             2394** ;
0B19BA CD    2395** GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0B19BB E7 
0B19BC 1C 
0B19BD 0B 
0B19BE 79    2396** LD      A,C
0B19BF 30    2397** JR      NC,BIND1		; If it is a register, then write that out
0B19C0 2E 
0B19C1 EE    2398** XOR     46H			; Handle ADD A,n
0B19C2 46 
0B19C3 CD    2399** CALL    BIND
0B19C4 87 
0B19C5 1C 
0B19C6 0B 
0B19C7 CD    2400** DB_:			CALL    NUMBER
0B19C8 C7 
0B19C9 1C 
0B19CA 0B 
0B19CB C3    2401** JP      VAL8
0B19CC 80 
0B19CD 1A 
0B19CE 0B 
             2402** ;
0B19CF E6    2403** GROUP05_HL:		AND     3FH
0B19D0 3F 
0B19D1 FE    2404** CP      12
0B19D2 0C 
0B19D3 37    2405** SCF
0B19D4 C0    2406** RET     NZ
0B19D5 79    2407** LD      A,C
0B19D6 FE    2408** CP      80H
0B19D7 80 
0B19D8 0E    2409** LD      C,9
0B19D9 09 
0B19DA 28    2410** JR      Z,GROUP04_1
0B19DB C6 
0B19DC EE    2411** XOR     1CH
0B19DD 1C 
0B19DE 0F    2412** RRCA
0B19DF 4F    2413** LD      C,A
0B19E0 CD    2414** CALL    ED
0B19E1 81 
0B19E2 1C 
0B19E3 0B 
0B19E4 18    2415** JR      GROUP04_1
0B19E5 BC 
             2416** ;
             2417** ; GROUP 7 - INC, DEC
             2418** ;
0B19E6 D6    2419** GROUP07:		SUB     2			; The number of opcodes in GROUP7
0B19E7 02 
0B19E8 30    2420** JR      NC,GROUP08
0B19E9 19 
0B19EA CD    2421** CALL    REGHI
0B19EB EE 
0B19EC 1C 
0B19ED 0B 
0B19EE 79    2422** LD      A,C
0B19EF D2    2423** BIND1:			JP      NC,BIND
0B19F0 87 
0B19F1 1C 
0B19F2 0B 
0B19F3 EE    2424** XOR     64H
0B19F4 64 
0B19F5 07    2425** RLCA
0B19F6 07    2426** RLCA
0B19F7 07    2427** RLCA
0B19F8 4F    2428** LD      C,A
0B19F9 CD    2429** CALL    PAIR1_EX
0B19FA 0E 
0B19FB 1D 
0B19FC 0B 
0B19FD D8    2430** RET     C
0B19FE 79    2431** BYTE0:			LD      A,C
0B19FF C3    2432** JP      BYTE_
0B1A00 B6 
0B1A01 1C 
0B1A02 0B 
             2433** ;
             2434** ; Group 8: IN0, OUT0
             2435** ;
0B1A03 D6    2436** GROUP08:		SUB	2			; The number of opcodes in GROUP8
0B1A04 02 
0B1A05 30    2437** JR	NC,GROUP09
0B1A06 26 
0B1A07 FE    2438** CP	1-2
0B1A08 FF 
0B1A09 CC    2439** CALL    Z,NUMBER		; Fetch number first if OUT
0B1A0A C7 
0B1A0B 1C 
0B1A0C 0B 
0B1A0D 08    2440** EX      AF,AF'			; Save flags
0B1A0E CD    2441** CALL    REG			; Get the register value regardless
0B1A0F DB 
0B1A10 1C 
0B1A11 0B 
0B1A12 D8    2442** RET     C			; Return if not a register
0B1A13 08    2443** EX      AF,AF'			; Restore the flags
0B1A14 DC    2444** CALL    C,NUMBER		; Fetch number last if IN
0B1A15 C7 
0B1A16 1C 
0B1A17 0B 
0B1A18 78    2445** LD	A,B			; Get the register number
0B1A19 FE    2446** CP	6			; Fail on (HL)
0B1A1A 06 
0B1A1B 37    2447** SCF
0B1A1C C8    2448** RET	Z
0B1A1D FE    2449** CP	8			; Check it is just single pairs only
0B1A1E 08 
0B1A1F 3F    2450** CCF
0B1A20 D8    2451** RET	C			; And return if it is an invalid register
0B1A21 07    2452** RLCA				; Bind with the operand
0B1A22 07    2453** RLCA
0B1A23 07    2454** RLCA
0B1A24 81    2455** ADD	A,C
             2456** ; BEGIN NOT IN BINARY
             2457** ; LD	C,A
             2458** ; CALL	ED			; Prefix with ED
             2459** ; LD	A,C
             2460** ; END NOT IN BINARY
0B1A25 CD    2461** CALL	BYTE_			; Write out the operand
0B1A26 B6 
0B1A27 1C 
0B1A28 0B 
0B1A29 C3    2462** JP	VAL8			; Write out the value
0B1A2A 80 
0B1A2B 1A 
0B1A2C 0B 
             2463** ;
             2464** ; GROUP 9 - IN
             2465** ; GROUP 10 - OUT
             2466** ;
0B1A2D D6    2467** GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
0B1A2E 02 
0B1A2F 30    2468** JR      NC,GROUP11
0B1A30 25 
0B1A31 FE    2469** CP      1-2			; Check if Group 9 or Group 1
0B1A32 FF 
0B1A33 CC    2470** CALL    Z,CORN			; Call CORN if Group 10 (OUT)
0B1A34 75 
0B1A35 1C 
0B1A36 0B 
0B1A37 08    2471** EX      AF,AF'			; Save flags
0B1A38 CD    2472** CALL    REGHI			; Get the register value regardless
0B1A39 EE 
0B1A3A 1C 
0B1A3B 0B 
0B1A3C D8    2473** RET     C			; Return if not a register
0B1A3D 08    2474** EX      AF,AF'			; Restore the flags
0B1A3E DC    2475** CALL    C,CORN			; Call CORN if Group 9 (IN)
0B1A3F 75 
0B1A40 1C 
0B1A41 0B 
0B1A42 24    2476** INC     H			; If it is IN r,(C) or OUT (C),r then
0B1A43 28    2477** JR      Z,BYTE0			; Just write the operand out
0B1A44 B9 
             2478** ;
0B1A45 78    2479** LD      A,B			; Check the register
0B1A46 FE    2480** CP      7
0B1A47 07 
0B1A48 37    2481** SCF
0B1A49 C0    2482** RET     NZ			; If it is not A, then return
             2483** ;
0B1A4A 79    2484** LD      A,C			; Bind the register with the operand
0B1A4B EE    2485** XOR     3
0B1A4C 03 
0B1A4D 07    2486** RLCA
0B1A4E 07    2487** RLCA
0B1A4F 07    2488** RLCA
0B1A50 CD    2489** CALL    BYTE_			; Write out the operand
0B1A51 B6 
0B1A52 1C 
0B1A53 0B 
0B1A54 18    2490** JR      VAL8			; And the value
0B1A55 2A 
             2491** ;
             2492** ; GROUP 11 - JR, DJNZ
             2493** ;
0B1A56 D6    2494** GROUP11:		SUB     2			; The number of opcodes in GROUP11
0B1A57 02 
0B1A58 30    2495** JR      NC,GROUP12
0B1A59 2B 
0B1A5A FE    2496** CP      1-2
0B1A5B FF 
0B1A5C C4    2497** CALL    NZ,COND_
0B1A5D F5 
0B1A5E 1C 
0B1A5F 0B 
0B1A60 79    2498** LD      A,C
0B1A61 30    2499** JR      NC,@F
0B1A62 02 
0B1A63 3E    2500** LD      A,18H
0B1A64 18 
0B1A65 CD    2501** @@:			CALL    BYTE_
0B1A66 B6 
0B1A67 1C 
0B1A68 0B 
0B1A69 CD    2502** CALL    NUMBER
0B1A6A C7 
0B1A6B 1C 
0B1A6C 0B 
0B1A6D ED    2503** LD      DE,(PC)
0B1A6E 5B 
0B1A6F 40 
0B1A70 5D 
0B1A70 0B   
0B1A72 13    2504** INC     DE
0B1A73 37    2505** SCF
0B1A74 ED    2506** SBC     HL,DE
0B1A75 52 
0B1A76 7D    2507** LD      A,L
0B1A77 17    2508** RLA
0B1A78 9F    2509** SBC     A,A
0B1A79 BC    2510** CP      H
0B1A7A 3E    2511** TOOFAR:			LD      A,1
0B1A7B 01 
0B1A7C C2    2512** JP      NZ,ERROR_		; Throw an "Out of range" error
0B1A7D 24 
0B1A7E 37 
0B1A7F 0B 
0B1A80 7D    2513** VAL8:			LD      A,L
0B1A81 C3    2514** JP      BYTE_
0B1A82 B6 
0B1A83 1C 
0B1A84 0B 
             2515** ;
             2516** ; GROUP 12 - JP
             2517** ;
0B1A85 D6    2518** GROUP12:		SUB	1			; The number of opcodes in GROUP12
0B1A86 01 
0B1A87 30    2519** JR	NC,GROUP13
0B1A88 21 
0B1A89 CD    2520** CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
0B1A8A DB 
0B1A8B 1B 
0B1A8C 0B 
0B1A8D D8    2521** RET	C			; Exit if an invalid suffix is provided
0B1A8E CD    2522** CALL    COND_			; Evaluate the conditions
0B1A8F F5 
0B1A90 1C 
0B1A91 0B 
0B1A92 79    2523** LD      A,C
0B1A93 30    2524** JR      NC,GROUP12_1
0B1A94 0D 
0B1A95 78    2525** LD      A,B
0B1A96 E6    2526** AND     3FH
0B1A97 3F 
0B1A98 FE    2527** CP      6
0B1A99 06 
0B1A9A 3E    2528** LD      A,0E9H
0B1A9B E9 
0B1A9C CA    2529** JP      Z,BYTE_
0B1A9D B6 
0B1A9E 1C 
0B1A9F 0B 
0B1AA0 3E    2530** LD      A,0C3H
0B1AA1 C3 
0B1AA2 CD    2531** GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
0B1AA3 B6 
0B1AA4 1C 
0B1AA5 0B 
0B1AA6 C3    2532** JP	ADDR_			; Output the address
0B1AA7 30 
0B1AA8 1C 
0B1AA9 0B 
             2533** ;
             2534** ; GROUP 13 - CALL
             2535** ;
0B1AAA D6    2536** GROUP13:		SUB	1			; The number of opcodes in GROUP13
0B1AAB 01 
0B1AAC 30    2537** JR	NC,GROUP14
0B1AAD 0C 
0B1AAE CD    2538** GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
0B1AAF F3 
0B1AB0 1B 
0B1AB1 0B 
0B1AB2 CD    2539** CALL    GROUP15_1		; Output the opcode (with conditions)
0B1AB3 D5 
0B1AB4 1A 
0B1AB5 0B 
0B1AB6 C3    2540** JP	ADDR_			; Output the address
0B1AB7 30 
0B1AB8 1C 
0B1AB9 0B 
             2541** ;
             2542** ; GROUP 14 - RST
             2543** ;
0B1ABA D6    2544** GROUP14:		SUB	1			; The number of opcodes in GROUP14
0B1ABB 01 
0B1ABC 30    2545** JR	NC,GROUP15
0B1ABD 13 
0B1ABE CD    2546** CALL	EZ80SF_FULL		; Evaluate the suffix
0B1ABF F3 
0B1AC0 1B 
0B1AC1 0B 
0B1AC2 D8    2547** RET	C			; Exit if an invalid suffix provided
0B1AC3 CD    2548** CALL    NUMBER
0B1AC4 C7 
0B1AC5 1C 
0B1AC6 0B 
0B1AC7 A1    2549** AND     C
0B1AC8 B4    2550** OR      H
0B1AC9 20    2551** JR      NZ,TOOFAR
0B1ACA AF 
0B1ACB 7D    2552** LD      A,L
0B1ACC B1    2553** OR      C
0B1ACD C3    2554** JP      BYTE_
0B1ACE B6 
0B1ACF 1C 
0B1AD0 0B 
             2555** ;
             2556** ; GROUP 15 - RET
             2557** ;
0B1AD1 D6    2558** GROUP15:		SUB	1			; The number of opcodes in GROUP15
0B1AD2 01 
0B1AD3 30    2559** JR	NC,GROUP16
0B1AD4 0F 
0B1AD5 CD    2560** GROUP15_1:		CALL    COND_
0B1AD6 F5 
0B1AD7 1C 
0B1AD8 0B 
0B1AD9 79    2561** LD      A,C
0B1ADA D2    2562** JP      NC,BYTE_
0B1ADB B6 
0B1ADC 1C 
0B1ADD 0B 
0B1ADE F6    2563** OR      9
0B1ADF 09 
0B1AE0 C3    2564** JP      BYTE_
0B1AE1 B6 
0B1AE2 1C 
0B1AE3 0B 
             2565** ;
             2566** ; GROUP 16 - LD
             2567** ;
0B1AE4 D6    2568** GROUP16:		SUB	1			; The number of opcodes in GROUP16
0B1AE5 01 
0B1AE6 30    2569** JR	NC,GROUP17
0B1AE7 74 
0B1AE8 CD    2570** CALL	EZ80SF_FULL		; Evaluate the suffix
0B1AE9 F3 
0B1AEA 1B 
0B1AEB 0B 
0B1AEC CD    2571** CALL    LDOP			; Check for accumulator loads
0B1AED 24 
0B1AEE 1D 
0B1AEF 0B 
0B1AF0 D2    2572** JP      NC,LDA			; Yes, so jump here
0B1AF1 50 
0B1AF2 1C 
0B1AF3 0B 
0B1AF4 CD    2573** CALL    REGHI
0B1AF5 EE 
0B1AF6 1C 
0B1AF7 0B 
0B1AF8 08    2574** EX      AF,AF'
0B1AF9 CD    2575** CALL    SKIP
0B1AFA 79 
0B1AFB 1D 
0B1AFC 0B 
0B1AFD FE    2576** CP      '('			; Check for bracket
0B1AFE 28 
0B1AFF 28    2577** JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
0B1B00 24 
0B1B01 08    2578** EX      AF,AF'
0B1B02 D2    2579** JP      NC,GROUP05_1		; Load single register direct; go here
0B1B03 BA 
0B1B04 19 
0B1B05 0B 
0B1B06 0E    2580** LD      C,1
0B1B07 01 
0B1B08 CD    2581** CALL    PAIR1_EX
0B1B09 0E 
0B1B0A 1D 
0B1B0B 0B 
0B1B0C D8    2582** RET     C
0B1B0D 3E    2583** LD      A,14
0B1B0E 0E 
0B1B0F B8    2584** CP      B
0B1B10 47    2585** LD      B,A
0B1B11 CC    2586** CALL    Z,PAIR_EX
0B1B12 09 
0B1B13 1D 
0B1B14 0B 
0B1B15 78    2587** LD      A,B
0B1B16 E6    2588** AND     3FH
0B1B17 3F 
0B1B18 FE    2589** CP      12
0B1B19 0C 
0B1B1A 79    2590** LD      A,C
0B1B1B C2    2591** JP      NZ,GROUP12_1		; Load register pair direct; go here
0B1B1C A2 
0B1B1D 1A 
0B1B1E 0B 
0B1B1F 3E    2592** LD      A,0F9H
0B1B20 F9 
0B1B21 C3    2593** JP      BYTE_
0B1B22 B6 
0B1B23 1C 
0B1B24 0B 
             2594** ;
0B1B25 08    2595** LDIN:			EX      AF,AF'
0B1B26 C5    2596** PUSH    BC
0B1B27 D4    2597** CALL    NC,REGLO
0B1B28 E7 
0B1B29 1C 
0B1B2A 0B 
0B1B2B 79    2598** LD      A,C
0B1B2C C1    2599** POP     BC
0B1B2D D2    2600** JP      NC,BIND
0B1B2E 87 
0B1B2F 1C 
0B1B30 0B 
0B1B31 0E    2601** LD      C,0AH
0B1B32 0A 
0B1B33 CD    2602** CALL    PAIR1_EX
0B1B34 0E 
0B1B35 1D 
0B1B36 0B 
0B1B37 CD    2603** CALL    LD16
0B1B38 5B 
0B1B39 1C 
0B1B3A 0B 
0B1B3B D2    2604** JP      NC,GROUP12_1
0B1B3C A2 
0B1B3D 1A 
0B1B3E 0B 
0B1B3F CD    2605** CALL    NUMBER
0B1B40 C7 
0B1B41 1C 
0B1B42 0B 
0B1B43 0E    2606** LD      C,2
0B1B44 02 
0B1B45 CD    2607** CALL    PAIR_EX
0B1B46 09 
0B1B47 1D 
0B1B48 0B 
0B1B49 CD    2608** CALL    LD16
0B1B4A 5B 
0B1B4B 1C 
0B1B4C 0B 
0B1B4D D8    2609** RET     C
0B1B4E CD    2610** CALL    BYTE_
0B1B4F B6 
0B1B50 1C 
0B1B51 0B 
0B1B52 CB    2611** BIT	7,D			; Check the ADL flag
0B1B53 7A 
0B1B54 C2    2612** JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
0B1B55 45 
0B1B56 1C 
0B1B57 0B 
0B1B58 C3    2613** JP      VAL16			; Otherwise use 16-bit addresses
0B1B59 38 
0B1B5A 1C 
0B1B5B 0B 
             2614** ;
             2615** ; Group 17 - TST
             2616** ;
0B1B5C D6    2617** GROUP17:		SUB	1			; The number of opcodes in GROUP17
0B1B5D 01 
0B1B5E 30    2618** JR	NC,OPTS
0B1B5F 25 
0B1B60 CD    2619** CALL	ED			; Needs to be prefixed with ED
0B1B61 81 
0B1B62 1C 
0B1B63 0B 
0B1B64 CD    2620** CALL	REG			; Fetch the register
0B1B65 DB 
0B1B66 1C 
0B1B67 0B 
0B1B68 30    2621** JR	NC,GROUP17_1		; It's just a register
0B1B69 0E 
             2622** ;
0B1B6A 3E    2623** LD	A,64H			; Opcode for TST n
0B1B6B 64 
0B1B6C CD    2624** CALL	BYTE_			; Write out the opcode
0B1B6D B6 
0B1B6E 1C 
0B1B6F 0B 
0B1B70 CD    2625** CALL	NUMBER			; Get the number
0B1B71 C7 
0B1B72 1C 
0B1B73 0B 
0B1B74 C3    2626** JP	VAL8			; And write that out
0B1B75 80 
0B1B76 1A 
0B1B77 0B 
             2627** ;
0B1B78 78    2628** GROUP17_1:		LD	A,B			; Check the register rangs
0B1B79 FE    2629** CP	8
0B1B7A 08 
0B1B7B 3F    2630** CCF
0B1B7C D8    2631** RET	C			; Ret with carry flag set for error if out of range
0B1B7D 07    2632** RLCA				; Get the opcode value
0B1B7E 07    2633** RLCA
0B1B7F 07    2634** RLCA
0B1B80 81    2635** ADD	A,C			; Add the opcode base in
0B1B81 C3    2636** JP	BYTE_
0B1B82 B6 
0B1B83 1C 
0B1B84 0B 
             2637** 
             2638** ;
             2639** ; Assembler directives - OPT, ADL
             2640** ;
0B1B85 D6    2641** OPTS:			SUB	2
0B1B86 02 
0B1B87 30    2642** JR	NC, DEFS
0B1B88 2B 
0B1B89 FE    2643** CP	1-2			; Check for ADL opcode
0B1B8A FF 
0B1B8B 28    2644** JR	Z, ADL_
0B1B8C 13 
             2645** ;
0B1B8D CD    2646** OPT:			CALL    NUMBER			; Fetch the OPT value
0B1B8E C7 
0B1B8F 1C 
0B1B90 0B 
0B1B91 21    2647** LD      HL,LISTON		; Address of the LISTON/OPT flag
0B1B92 40 
0B1B93 5E 
0B1B94 0B 
0B1B95 E6    2648** AND	7			; Only interested in the first three bits
0B1B96 07 
0B1B97 4F    2649** LD      C,A			; Store the new OPT value in C
0B1B98 ED    2650** RLD				; Shift the top nibble of LISTON (OPT) into A
0B1B99 6F 
0B1B9A E6    2651** AND	8			; Clear the bottom three bits, preserving the ADL bit
0B1B9B 08 
0B1B9C B1    2652** OR	C			; OR in the new value
0B1B9D ED    2653** RRD				; And shift the nibble back in
0B1B9E 67 
0B1B9F C9    2654** RET
             2655** ;
0B1BA0 CD    2656** ADL_:			CALL	NUMBER			; Fetch the ADL value
0B1BA1 C7 
0B1BA2 1C 
0B1BA3 0B 
0B1BA4 E6    2657** AND	1			; Only interested if it is 0 or 1
0B1BA5 01 
0B1BA6 0F    2658** RRCA				; Rotate to bit 7
0B1BA7 4F    2659** LD	C,A			; Store in C
0B1BA8 3A    2660** LD	A,(LISTON)		; Get the LISTON system variable
0B1BA9 40 
0B1BAA 5E 
0B1BAB 0B 
0B1BAC E6    2661** AND	7Fh			; Clear bit 7
0B1BAD 7F 
0B1BAE B1    2662** OR	C			; OR in the ADL value
0B1BAF 32    2663** LD	(LISTON),A		; Store
0B1BB0 40 
0B1BB1 5E 
0B1BB2 0B 
0B1BB3 C9    2664** RET
             2665** ;
             2666** ; DEFB, DEFW, DEFL, DEFM
             2667** ;
0B1BB4 B7    2668** DEFS:			OR	A			; Handle DEFB
0B1BB5 CA    2669** JP	Z, DB_
0B1BB6 C7 
0B1BB7 19 
0B1BB8 0B 
0B1BB9 3D    2670** DEC	A			; Handle DEFW
0B1BBA CA    2671** JP	Z, ADDR16
0B1BBB 34 
0B1BBC 1C 
0B1BBD 0B 
0B1BBE 3D    2672** DEC	A			; Handle DEFL
0B1BBF CA    2673** JP	Z, ADDR24
0B1BC0 41 
0B1BC1 1C 
0B1BC2 0B 
             2674** ;
0B1BC3 DD    2675** PUSH    IX			; Handle DEFM
0B1BC4 E5 
0B1BC5 CD    2676** CALL    EXPRS
0B1BC6 D9 
0B1BC7 02 
0B1BC8 0B 
0B1BC9 DD    2677** POP     IX
0B1BCA E1 
0B1BCB 21    2678** LD      HL,ACCS
0B1BCC 00 
0B1BCD 5B 
0B1BCE 0B 
0B1BCF AF    2679** @@:			XOR     A
0B1BD0 BB    2680** CP      E
0B1BD1 C8    2681** RET     Z
0B1BD2 7E    2682** LD      A,(HL)
0B1BD3 23    2683** INC     HL
0B1BD4 CD    2684** CALL    BYTE_
0B1BD5 B6 
0B1BD6 1C 
0B1BD7 0B 
0B1BD8 1D    2685** DEC     E
0B1BD9 18    2686** JR      @B
0B1BDA F4 
             2687** 
             2688** ;
             2689** ;SUBROUTINES:
             2690** ;
0B1BDB FD    2691** EZ80SF_PART:		LD	A,(IY)			; Check for a dot
0B1BDC 7E 
0B1BDD 00 
0B1BDE FE    2692** CP	'.'
0B1BDF 2E 
0B1BE0 28    2693** JR	Z, @F			; If present, then carry on processing the eZ80 suffix
0B1BE1 02 
0B1BE2 B7    2694** OR	A			; Reset the carry flag (no error)
0B1BE3 C9    2695** RET				; And return
0B1BE4 FD    2696** @@:			INC	IY			; Skip the dot
0B1BE5 23 
0B1BE6 C5    2697** PUSH	BC			; Push the operand
0B1BE7 21    2698** LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
0B1BE8 0F 
0B1BE9 20 
0B1BEA 0B 
0B1BEB CD    2699** CALL	FIND			; Look up the operand
0B1BEC 28 
0B1BED 1D 
0B1BEE 0B 
0B1BEF 30    2700** JR	NC,EZ80SF_OK
0B1BF0 24 
0B1BF1 C1    2701** POP	BC			; Not found at this point, so will return with a C (error)
0B1BF2 C9    2702** RET
             2703** ;
0B1BF3 FD    2704** EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
0B1BF4 7E 
0B1BF5 00 
0B1BF6 FE    2705** CP	'.'
0B1BF7 2E 
0B1BF8 28    2706** JR	Z,@F			; If present, then carry on processing the eZ80 suffix
0B1BF9 02 
0B1BFA B7    2707** OR	A			; Reset the carry flag (no error)
0B1BFB C9    2708** RET				; And return
0B1BFC FD    2709** @@:			INC	IY 			; Skip the dot
0B1BFD 23 
0B1BFE C5    2710** PUSH	BC			; Push the operand
0B1BFF 21    2711** LD	HL,EZ80SFS_1		; First check the fully qualified table
0B1C00 07 
0B1C01 20 
0B1C02 0B 
0B1C03 CD    2712** CALL	FIND 			; Look up the operand
0B1C04 28 
0B1C05 1D 
0B1C06 0B 
0B1C07 30    2713** JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
0B1C08 0C 
0B1C09 CD    2714** CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
0B1C0A 24 
0B1C0B 1C 
0B1C0C 0B 
0B1C0D CD    2715** CALL	FIND
0B1C0E 28 
0B1C0F 1D 
0B1C10 0B 
0B1C11 30    2716** JR	NC,EZ80SF_OK
0B1C12 02 
0B1C13 C1    2717** POP	BC			; Not found at this point, so will return with a C (error)
0B1C14 C9    2718** RET
             2719** ;
0B1C15 78    2720** EZ80SF_OK:		LD	A,B			; The operand value
0B1C16 D4    2721** CALL	NC,BYTE_ 		; Write it out if found
0B1C17 B6 
0B1C18 1C 
0B1C19 0B 
0B1C1A CB    2722** RES	7,D			; Clear the default ADL mode from the flags
0B1C1B BA 
0B1C1C E6    2723** AND	2			; Check the second half of the suffix (.xxL)
0B1C1D 02 
0B1C1E 0F    2724** RRCA				; Shift into bit 7
0B1C1F 0F    2725** RRCA
0B1C20 B2    2726** OR	D			; Or into bit 7 of D
0B1C21 57    2727** LD	D,A
0B1C22 C1    2728** POP	BC 			; Restore the operand
0B1C23 C9    2729** RET
             2730** ;
0B1C24 21    2731** EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
0B1C25 18 
0B1C26 20 
0B1C27 0B 
0B1C28 CB    2732** BIT 	7,D			; if bit 7 of D is 0
0B1C29 7A 
0B1C2A C8    2733** RET	Z
0B1C2B 21    2734** LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
0B1C2C 23 
0B1C2D 20 
0B1C2E 0B 
0B1C2F C9    2735** RET
             2736** ;
0B1C30 CB    2737** ADDR_:			BIT	7,D			; Check the ADL flag
0B1C31 7A 
0B1C32 20    2738** JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
0B1C33 0D 
             2739** ;
0B1C34 CD    2740** ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
0B1C35 C7 
0B1C36 1C 
0B1C37 0B 
0B1C38 CD    2741** VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
0B1C39 80 
0B1C3A 1A 
0B1C3B 0B 
0B1C3C 7C    2742** LD      A,H
0B1C3D C3    2743** JP      BYTE_
0B1C3E B6 
0B1C3F 1C 
0B1C40 0B 
             2744** ;
0B1C41 CD    2745** ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
0B1C42 C7 
0B1C43 1C 
0B1C44 0B 
0B1C45 CD    2746** VAL24:			CALL	VAL16			; Lower 16-bits are in HL
0B1C46 38 
0B1C47 1C 
0B1C48 0B 
0B1C49 D9    2747** EXX
0B1C4A 7D    2748** LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
0B1C4B D9    2749** EXX
0B1C4C C3    2750** JP	BYTE_
0B1C4D B6 
0B1C4E 1C 
0B1C4F 0B 
             2751** ;
0B1C50 FE    2752** LDA:			CP      4
0B1C51 04 
0B1C52 DC    2753** CALL    C,ED
0B1C53 81 
0B1C54 1C 
0B1C55 0B 
0B1C56 78    2754** LD      A,B
0B1C57 C3    2755** JP      BYTE_
0B1C58 B6 
0B1C59 1C 
0B1C5A 0B 
             2756** ;
0B1C5B 78    2757** LD16:			LD      A,B
0B1C5C 38    2758** JR      C,LD8
0B1C5D 0F 
0B1C5E 78    2759** LD      A,B
0B1C5F E6    2760** AND     3FH
0B1C60 3F 
0B1C61 FE    2761** CP      12
0B1C62 0C 
0B1C63 79    2762** LD      A,C
0B1C64 C8    2763** RET     Z
0B1C65 CD    2764** CALL    ED
0B1C66 81 
0B1C67 1C 
0B1C68 0B 
0B1C69 79    2765** LD      A,C
0B1C6A F6    2766** OR      43H
0B1C6B 43 
0B1C6C C9    2767** RET
             2768** ;
0B1C6D FE    2769** LD8:			CP      7
0B1C6E 07 
0B1C6F 37    2770** SCF
0B1C70 C0    2771** RET     NZ
0B1C71 79    2772** LD      A,C
0B1C72 F6    2773** OR      30H
0B1C73 30 
0B1C74 C9    2774** RET
             2775** ;
             2776** ; Used in IN and OUT to handle whether the operand is C or a number
             2777** ;
0B1C75 C5    2778** CORN:			PUSH    BC
0B1C76 CD    2779** CALL    OPND			; Get the operand
0B1C77 95 
0B1C78 1C 
0B1C79 0B 
0B1C7A CB    2780** BIT     5,B
0B1C7B 68 
0B1C7C C1    2781** POP     BC
0B1C7D 28    2782** JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
0B1C7E 48 
0B1C7F 26    2783** LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
0B1C80 FF 
             2784** ;
0B1C81 3E    2785** ED:			LD      A,0EDH			; Write an ED prefix out
0B1C82 ED 
0B1C83 18    2786** JR      BYTE_
0B1C84 31 
             2787** ;
0B1C85 3E    2788** CB:			LD      A,0CBH
0B1C86 CB 
0B1C87 FE    2789** BIND:			CP      76H
0B1C88 76 
0B1C89 37    2790** SCF
0B1C8A C8    2791** RET     Z               	; Reject LD (HL),(HL)
0B1C8B CD    2792** CALL    BYTE_
0B1C8C B6 
0B1C8D 1C 
0B1C8E 0B 
0B1C8F CB    2793** BIT	6,D			; Check the index bit in flags
0B1C90 72 
0B1C91 C8    2794** RET     Z
0B1C92 7B    2795** LD      A,E			; If there is an index, output the offset
0B1C93 18    2796** JR      BYTE_
0B1C94 21 
             2797** ;
             2798** ; Search through the operand table
             2799** ; Returns:
             2800** ; - B: The operand type
             2801** ; - D: Bit 7: 0 = no prefix, 1 = prefix
             2802** ; - E: The IX/IY offset
             2803** ; - F: Carry if not found
             2804** ;
0B1C95 E5    2805** OPND:			PUSH    HL			; Preserve HL
0B1C96 21    2806** LD      HL,OPRNDS		; The operands table
0B1C97 99 
0B1C98 1F 
0B1C99 0B 
0B1C9A CD    2807** CALL    FIND			; Find the operand
0B1C9B 28 
0B1C9C 1D 
0B1C9D 0B 
0B1C9E E1    2808** POP     HL
0B1C9F D8    2809** RET     C			; Return if not found
0B1CA0 CB    2810** BIT     7,B			; Check if it is an index register (IX, IY)
0B1CA1 78 
0B1CA2 C8    2811** RET     Z			; Return if it isn't
0B1CA3 CB    2812** SET	6,D			; Set flag to indicate we've got an index
0B1CA4 F2 
0B1CA5 CB    2813** BIT     3,B			; Check if an offset is required
0B1CA6 58 
0B1CA7 E5    2814** PUSH    HL
0B1CA8 CC    2815** CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
0B1CA9 BD 
0B1CAA 1C 
0B1CAB 0B 
0B1CAC 5D    2816** LD      E,L			; E: The offset
0B1CAD E1    2817** POP     HL
0B1CAE 3E    2818** LD	A,DDH			; IX prefix
0B1CAF DD 
0B1CB0 CB    2819** BIT     6,B			; If bit 6 is reset then
0B1CB1 70 
0B1CB2 28    2820** JR      Z,BYTE_			; It's an IX instruction, otherwise set
0B1CB3 02 
0B1CB4 3E    2821** LD	A,FDH			; IY prefix
0B1CB5 FD 
             2822** ;
0B1CB6 DD    2823** BYTE_:			LD      (IX),A			; Write a byte out
0B1CB7 77 
0B1CB8 00 
0B1CB9 DD    2824** INC     IX
0B1CBA 23 
0B1CBB B7    2825** OR      A
0B1CBC C9    2826** RET
             2827** ;
0B1CBD FD    2828** OFFSET_EX:			LD      A,(IY)
0B1CBE 7E 
0B1CBF 00 
0B1CC0 FE    2829** CP      ')'
0B1CC1 29 
0B1CC2 21    2830** LD      HL,0
0B1CC3 00 
0B1CC4 00 
0B1CC5 00 
0B1CC6 C8    2831** RET     Z
0B1CC7 CD    2832** NUMBER:			CALL    SKIP
0B1CC8 79 
0B1CC9 1D 
0B1CCA 0B 
0B1CCB C5    2833** PUSH    BC
0B1CCC D5    2834** PUSH    DE
0B1CCD DD    2835** PUSH    IX
0B1CCE E5 
0B1CCF CD    2836** CALL    EXPRI
0B1CD0 CE 
0B1CD1 02 
0B1CD2 0B 
0B1CD3 DD    2837** POP     IX
0B1CD4 E1 
0B1CD5 D9    2838** EXX
0B1CD6 D1    2839** POP     DE
0B1CD7 C1    2840** POP     BC
0B1CD8 7D    2841** LD      A,L
0B1CD9 B7    2842** OR      A
0B1CDA C9    2843** RET
             2844** ;
0B1CDB CD    2845** REG:			CALL    OPND
0B1CDC 95 
0B1CDD 1C 
0B1CDE 0B 
0B1CDF D8    2846** RET     C
0B1CE0 78    2847** LD      A,B
0B1CE1 E6    2848** AND     3FH
0B1CE2 3F 
0B1CE3 FE    2849** CP      8
0B1CE4 08 
0B1CE5 3F    2850** CCF
0B1CE6 C9    2851** RET
             2852** ;
0B1CE7 CD    2853** REGLO:			CALL    REG
0B1CE8 DB 
0B1CE9 1C 
0B1CEA 0B 
0B1CEB D8    2854** RET     C
0B1CEC 18    2855** JR      ORC
0B1CED 33 
             2856** ;
0B1CEE CD    2857** REGHI:			CALL    REG
0B1CEF DB 
0B1CF0 1C 
0B1CF1 0B 
0B1CF2 D8    2858** RET     C
0B1CF3 18    2859** JR      SHL3
0B1CF4 29 
             2860** ;
0B1CF5 CD    2861** COND_:			CALL    OPND
0B1CF6 95 
0B1CF7 1C 
0B1CF8 0B 
0B1CF9 D8    2862** RET     C
0B1CFA 78    2863** LD      A,B
0B1CFB E6    2864** AND     1FH
0B1CFC 1F 
0B1CFD D6    2865** SUB     16
0B1CFE 10 
0B1CFF 30    2866** JR      NC,SHL3
0B1D00 1D 
0B1D01 FE    2867** CP      -15
0B1D02 F1 
0B1D03 37    2868** SCF
0B1D04 C0    2869** RET     NZ
0B1D05 3E    2870** LD      A,3
0B1D06 03 
0B1D07 18    2871** JR      SHL3
0B1D08 15 
             2872** ;
0B1D09 CD    2873** PAIR_EX:			CALL    OPND
0B1D0A 95 
0B1D0B 1C 
0B1D0C 0B 
0B1D0D D8    2874** RET     C
0B1D0E 78    2875** PAIR1_EX:			LD      A,B
0B1D0F E6    2876** AND     0FH
0B1D10 0F 
0B1D11 D6    2877** SUB     8
0B1D12 08 
0B1D13 D8    2878** RET     C
0B1D14 18    2879** JR      SHL3
0B1D15 08 
             2880** ;
0B1D16 CD    2881** BIT_:			CALL    NUMBER
0B1D17 C7 
0B1D18 1C 
0B1D19 0B 
0B1D1A FE    2882** CP      8
0B1D1B 08 
0B1D1C 3F    2883** CCF
0B1D1D D8    2884** RET     C
0B1D1E 07    2885** SHL3:			RLCA
0B1D1F 07    2886** RLCA
0B1D20 07    2887** RLCA
0B1D21 B1    2888** ORC:			OR      C
0B1D22 4F    2889** LD      C,A
0B1D23 C9    2890** RET
             2891** ;
0B1D24 21    2892** LDOP:			LD      HL,LDOPS
0B1D25 DE 
0B1D26 1F 
0B1D27 0B 
             2893** 
             2894** ;
             2895** ; Look up a value in a table
             2896** ; Parameters:
             2897** ; - IY: Address of the assembly language line in the BASIC program area
             2898** ; - HL: Address of the table
             2899** ; Returns:
             2900** ; - B: The operand code
             2901** ; - F: Carry set if not found
             2902** ;
0B1D28 CD    2903** FIND:			CALL    SKIP			; Skip delimiters
0B1D29 79 
0B1D2A 1D 
0B1D2B 0B 
             2904** ;
0B1D2C 06    2905** EXIT_:			LD      B,0			; Set B to 0
0B1D2D 00 
0B1D2E 37    2906** SCF				; Set the carry flag
0B1D2F C8    2907** RET     Z			; Returns if Z
             2908** ;
0B1D30 FE    2909** CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
0B1D31 DD 
0B1D32 28    2910** JR      Z,FIND0
0B1D33 04 
0B1D34 FE    2911** CP      TOR+1			; Special case for tokens AND and OR
0B1D35 85 
0B1D36 3F    2912** CCF
0B1D37 D8    2913** RET     C
0B1D38 7E    2914** FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
0B1D39 B7    2915** OR      A
0B1D3A 28    2916** JR      Z,EXIT_			; Exit
0B1D3B F0 
0B1D3C FD    2917** XOR     (IY)
0B1D3D AE 
0B1D3E 00 
0B1D3F E6    2918** AND     01011111B
0B1D40 5F 
0B1D41 28    2919** JR      Z,FIND2
0B1D42 09 
0B1D43 CB    2920** FIND1:			BIT     7,(HL)
0B1D44 7E 
0B1D45 23    2921** INC     HL
0B1D46 28    2922** JR      Z,FIND1
0B1D47 FB 
0B1D48 23    2923** INC     HL
0B1D49 04    2924** INC     B
0B1D4A 18    2925** JR      FIND0
0B1D4B EC 
             2926** ;
0B1D4C FD    2927** FIND2:			PUSH    IY
0B1D4D E5 
0B1D4E CB    2928** FIND3:			BIT     7,(HL)			; Is this the end of token marker?
0B1D4F 7E 
0B1D50 FD    2929** INC     IY
0B1D51 23 
0B1D52 23    2930** INC     HL
0B1D53 20    2931** JR      NZ,FIND5		; Yes
0B1D54 11 
0B1D55 BE    2932** CP      (HL)
0B1D56 CC    2933** CALL    Z,SKIP0
0B1D57 78 
0B1D58 1D 
0B1D59 0B 
0B1D5A 7E    2934** LD      A,(HL)
0B1D5B FD    2935** XOR     (IY)
0B1D5C AE 
0B1D5D 00 
0B1D5E E6    2936** AND     01011111B
0B1D5F 5F 
0B1D60 28    2937** JR      Z,FIND3
0B1D61 EC 
0B1D62 FD    2938** FIND4:			POP     IY
0B1D63 E1 
0B1D64 18    2939** JR      FIND1
0B1D65 DD 
             2940** ;
0B1D66 CD    2941** FIND5:			CALL    DELIM			; Is it a delimiter?
0B1D67 2A 
0B1D68 17 
0B1D69 0B 
0B1D6A C4    2942** CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
0B1D6B 8D 
0B1D6C 1D 
0B1D6D 0B 
0B1D6E C4    2943** CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
0B1D6F 87 
0B1D70 1D 
0B1D71 0B 
0B1D72 20    2944** JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
0B1D73 EE 
             2945** ;
0B1D74 78    2946** FIND6:			LD      A,B			; At this point we have a token
0B1D75 46    2947** LD      B,(HL)			; Fetch the token type code
0B1D76 E1    2948** POP     HL			; Restore the stack
0B1D77 C9    2949** RET
             2950** ;
0B1D78 23    2951** SKIP0:			INC     HL
0B1D79 CD    2952** SKIP:			CALL    DELIM			; Is it a delimiter?
0B1D7A 2A 
0B1D7B 17 
0B1D7C 0B 
0B1D7D C0    2953** RET     NZ			; No, so return
0B1D7E CD    2954** CALL    TERM			; Is it a terminator?
0B1D7F 36 
0B1D80 17 
0B1D81 0B 
0B1D82 C8    2955** RET     Z			; Yes, so return
0B1D83 FD    2956** INC     IY			; Increment the basic program counter
0B1D84 23 
0B1D85 18    2957** JR      SKIP			; And loop
0B1D86 F2 
             2958** ;
0B1D87 FE    2959** SIGN:			CP      '+'			; Check whether the character is a sign symbol
0B1D88 2B 
0B1D89 C8    2960** RET     Z
0B1D8A FE    2961** CP      '-'
0B1D8B 2D 
0B1D8C C9    2962** RET
             2963** ;
0B1D8D FE    2964** DOT:			CP	'.'			; Check if it is a dot character
0B1D8E 2E 
0B1D8F C9    2965** RET
             2966** ; Z80 opcode list
             2967** ;
             2968** ; Group 0: (15 opcodes)
             2969** ; Trivial cases requiring no computation
             2970** ;
             2971** ; BEGIN REFACTOR FROM BINARY
             2972** ; OPCODS:
             2973** ; 			DB	"NO","P"+80H,00h	; # 00h
             2974** ; 			DB	"RLC","A"+80H,07h
             2975** ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
             2976** ; 			DB	"RRC","A"+80H,0FH
             2977** ; 			DB	"RL","A"+80H,17H
             2978** ; 			DB	"RR","A"+80H,1FH
             2979** ; 			DB	"DA","A"+80H,27H
             2980** ; 			DB	"CP","L"+80H,2FH
             2981** ; 			DB	"SC","F"+80H,37H
             2982** ; 			DB	"CC","F"+80H,3FH
             2983** ; 			DB	"HAL","T"+80H,76H
             2984** ; 			DB	"EX","X"+80H,D9H
             2985** ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
             2986** ; 			DB	"D","I"+80H,F3H
             2987** ; 			DB	"E","I"+80H,FBH
             2988** ; ;
             2989** ; ; Group 1: (53 opcodes)
             2990** ; ; As Group 0, but with an ED prefix
             2991** ; ;
             2992** ; 			DB	"NE","G"+80H,44H	; 0Fh
             2993** ; 			DB	"IM",0,"0"+80H,46H
             2994** ; 			DB	"RET","N"+80H,45H
             2995** ; 			DB	"MLT",0,"B","C"+80H,4CH
             2996** ; 			DB	"RET","I"+80H,4DH
             2997** ; 			DB	"IM",0,"1"+80H,56H
             2998** ; 			DB	"MLT",0,"D","E"+80H,5CH
             2999** ; 			DB	"IM",0,"2"+80H,5EH
             3000** ; 			DB	"RR","D"+80H,67H
             3001** ; 			DB	"MLT",0,"H","L"+80H,6CH
             3002** ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
             3003** ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
             3004** ; 			DB	"RL","D"+80H,6FH
             3005** ; 			DB	"SL","P"+80H,76H
             3006** ; 			DB	"MLT",0,"S","P"+80H,7CH
             3007** ; 			DB	"STMI","X"+80H,7DH
             3008** ; 			DB	"RSMI","X"+80H,7EH
             3009** ; 			DB	"INI","M"+80H,82H
             3010** ; 			DB	"OTI","M"+80H,83H
             3011** ; 			DB	"INI","2"+80H,84H
             3012** ; 			DB	"IND","M"+80H,8AH
             3013** ; 			DB	"OTD","M"+80H,8BH
             3014** ; 			DB	"IND","2"+80H,8CH
             3015** ; 			DB	"INIM","R"+80H,92H
             3016** ; 			DB	"OTIM","R"+80H,93H
             3017** ; 			DB	"INI2","R"+80H,94H
             3018** ; 			DB	"INDM","R"+80H,9AH
             3019** ; 			DB	"OTDM","R"+80H,9BH
             3020** ; 			DB	"IND2","R"+80H,9CH
             3021** ; 			DB	"LD","I"+80H,A0H
             3022** ; 			DB	"CP","I"+80H,A1H
             3023** ; 			DB	"IN","I"+80H,A2H
             3024** ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
             3025** ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
             3026** ; 			DB	"LD","D"+80H,A8H
             3027** ; 			DB	"CP","D"+80H,A9H
             3028** ; 			DB	"IN","D"+80H,AAH
             3029** ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
             3030** ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
             3031** ; 			DB	"LDI","R"+80H,B0H
             3032** ; 			DB	"CPI","R"+80H,B1H
             3033** ; 			DB	"INI","R"+80H,B2H
             3034** ; 			DB	"OTI","R"+80H,B3H
             3035** ; 			DB	"OTI2","R"+80H,B4H
             3036** ; 			DB	"LDD","R"+80H,B8H
             3037** ; 			DB	"CPD","R"+80H,B9H
             3038** ; 			DB	"IND","R"+80H,BAH
             3039** ; 			DB	"OTD","R"+80H,BBH
             3040** ; 			DB	"OTD2","R"+80H,BCH
             3041** ; 			DB	"INIR","X"+80H,C2H
             3042** ; 			DB	"OTIR","X"+80H,C3H
             3043** ; 			DB	"INDR","X"+80H,CAH
             3044** ; 			DB	"OTDR","X"+80H,CBH
             3045** ; ;
             3046** ; ; Group 2: (3 opcodes)
             3047** ; ;
             3048** ; 			DB	"BI","T"+80H,40H	; 44h
             3049** ; 			DB	"RE","S"+80H,80H
             3050** ; 			DB	"SE","T"+80H,C0H
             3051** ; ;
             3052** ; ; Group 3: (7 opcodes)
             3053** ; ;
             3054** ; 			DB	"RL","C"+80H,00H	; 47h
             3055** ; 			DB	"RR","C"+80H,08H
             3056** ; 			DB	"R","L"+80H,10H
             3057** ; 			DB	"R","R"+80H,18H
             3058** ; 			DB	"SL","A"+80H,20H
             3059** ; 			DB	"SR","A"+80H,28H
             3060** ; 			DB	"SR","L"+80H,38H
             3061** ; ;
             3062** ; ; Group 4: (3 opcodes)
             3063** ; ;
             3064** ; 			DB	"PO","P"+80H,C1H	; 4Eh
             3065** ; 			DB	"PUS","H"+80H,C5H
             3066** ; 			DB	"EX",0,"(S","P"+80H,E3H
             3067** ; ;
             3068** ; ; Group 5: (7 opcodes)
             3069** ; ;
             3070** ; 			DB	"SU","B"+80H,90H	; 51h
             3071** ; 			DB	"AN","D"+80H,A0H
             3072** ; 			DB	"XO","R"+80H,A8H
             3073** ; 			DB	"O","R"+80H,B0H
             3074** ; 			DB	"C","P"+80H,B8H
             3075** ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
             3076** ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
             3077** ; ;
             3078** ; ; Group 6 (3 opcodes)
             3079** ; ;
             3080** ; 			DB	"AD","D"+80H,80H	; 58h
             3081** ; 			DB	"AD","C"+80H,88H
             3082** ; 			DB	"SB","C"+80H,98H
             3083** ; ;
             3084** ; ; Group 7: (2 opcodes)
             3085** ; ;
             3086** ; 			DB	"IN","C"+80H,04H	; 5Bh
             3087** ; 			DB	"DE","C"+80H,05H
             3088** ; ;
             3089** ; ; Group 8: (2 opcodes)
             3090** ; ;
             3091** ; 			DB	"IN","0"+80H,00H	; 5Dh
             3092** ; 			DB	"OUT","0"+80H,01H
             3093** ; ;
             3094** ; ; Group 9: (1 opcode)
             3095** ; ;
             3096** ; 			DB	"I","N"+80H,40H		; 5Fh
             3097** ; ;
             3098** ; ; Group 10: (1 opcode)
             3099** ; ;
             3100** ; 			DB	"OU","T"+80H,41H	; 60h
             3101** ; ;
             3102** ; ; Group 11: (2 opcodes)
             3103** ; ;
             3104** ; 			DB	"J","R"+80H,20H		; 61h
             3105** ; 			DB	"DJN","Z"+80H,10H
             3106** ; ;
             3107** ; ; Group 12: (1 opcode)
             3108** ; ;
             3109** ; 			DB	"J","P"+80H,C2H		; 63h
             3110** ; ;
             3111** ; ; Group 13: (1 opcode)
             3112** ; ;
             3113** ; 			DB	"CAL","L"+80H,C4H	; 64h
             3114** ; ;
             3115** ; ; Group 14: (1 opcode)
             3116** ; ;
             3117** ; 			DB	"RS","T"+80H,C7H	; 65h
             3118** ; ;
             3119** ; ; Group 15: (1 opcode)
             3120** ; ;
             3121** ; 			DB	"RE","T"+80H,C0H	; 66h
             3122** ; ;
             3123** ; ; Group 16: (1 opcode)
             3124** ; ;
             3125** ; 			DB	"L","D"+80H,40H		; 67h
             3126** ; ;
             3127** ; ; Group 17: (1 opcode)
             3128** ; ;
             3129** ; 			DB	"TS","T"+80H,04H	; 68h
             3130** 
             3131** ; ;
             3132** ; ; Assembler Directives
             3133** ; ;
             3134** ; 			DB	"OP","T"+80H,00H	; 69h OPT
             3135** ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
             3136** ; ;
             3137** ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
             3138** ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
             3139** ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
             3140** ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
             3141** ; ;
             3142** ; 			DB	0
             3143** ; ;
             3144** ; ; Operands
             3145** ; ;
             3146** ; OPRNDS:			DB	"B"+80H, 00H
             3147** ; 			DB	"C"+80H, 01H
             3148** ; 			DB	"D"+80H, 02H
             3149** ; 			DB	"E"+80H, 03H
             3150** ; 			DB	"H"+80H, 04H
             3151** ; 			DB	"L"+80H, 05H
             3152** ; 			DB	"(H","L"+80H,06H
             3153** ; 			DB	"A"+80H, 07H
             3154** ; 			DB	"(I","X"+80H,86H
             3155** ; 			DB	"(I","Y"+80H,C6H
             3156** ; ;
             3157** ; 			DB	"B","C"+80H,08H
             3158** ; 			DB	"D","E"+80H,0AH
             3159** ; 			DB	"H","L"+80H,0CH
             3160** ; 			DB	"I","X"+80H,8CH
             3161** ; 			DB	"I","Y"+80H,CCH
             3162** ; 			DB	"A","F"+80H,0EH
             3163** ; 			DB	"S","P"+80H,0EH
             3164** ; ;
             3165** ; 			DB	"N","Z"+80H,10H
             3166** ; 			DB	"Z"+80H,11H
             3167** ; 			DB	"N","C"+80H,12H
             3168** ; 			DB	"P","O"+80H,14H
             3169** ; 			DB	"P","E"+80H,15H
             3170** ; 			DB	"P"+80H,16H
             3171** ; 			DB	"M"+80H,17H
             3172** ; ;
             3173** ; 			DB	"(","C"+80H,20H
             3174** ; ;
             3175** ; 			DB	0
             3176** ; ;
             3177** ; ; Load operations
             3178** ; ;
             3179** ; LDOPS:			DB	"I",0,"A"+80H,47H
             3180** ; 			DB	"R",0,"A"+80H,4FH
             3181** ; 			DB	"A",0,"I"+80H,57H
             3182** ; 			DB	"A",0,"R"+80H,5FH
             3183** ; 			DB	"(BC",0,"A"+80H,02h
             3184** ; 			DB	"(DE",0,"A"+80H,12H
             3185** ; 			DB	"A",0,"(B","C"+80H,0AH
             3186** ; 			DB	"A",0,"(D","E"+80H,1AH
             3187** ; ;
             3188** ; 			DB	0
             3189** ; ;
             3190** ; ; eZ80 addressing mode suffixes
             3191** ; ;
             3192** ; ; Fully qualified suffixes
             3193** ; ;
             3194** ; EZ80SFS_1:		DB	"LI","S"+80H,49H
             3195** ; 			DB	"SI","L"+80H,52H
             3196** ; EZ80SFS_2:		DB	"SI","S"+80H,40H
             3197** ; 			DB	"LI","L"+80H,5BH
             3198** ; ;
             3199** ; 			DB	0
             3200** ; ;
             3201** ; ; Shortcuts when ADL mode is 0
             3202** ; ;
             3203** ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
             3204** ; 			DB	"L"+80H,49H		; Equivalent to .LIS
             3205** ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
             3206** ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
             3207** ; ;
             3208** ; 			DB	0
             3209** ; ;
             3210** ; ; Shortcuts when ADL mode is 1
             3211** ; ;
             3212** ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
             3213** ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
             3214** ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
             3215** ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
             3216** ; ;
             3217** ; 			DB	0
             3218** ; END REFACTOR FROM BINARY
             3219** ; BEGIN INSERT FROM BINARY
             3220** ;
             3221** ; Trivial cases requiring no computation
             3222** OPCODS:
0B1D90 4E    3223** db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
0B1D91 4F    3224** db 0x4f ; 041DCD
0B1D92 D0    3225** db 0xd0 ; 041DCE
0B1D93 00    3226** db 0x00 ; 041DCF
0B1D94 52    3227** db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
0B1D95 4C    3228** db 0x4c ; 041DD1
0B1D96 43    3229** db 0x43 ; 041DD2
0B1D97 C1    3230** db 0xc1 ; 041DD3
0B1D98 07    3231** db 0x07 ; 041DD4
0B1D99 45    3232** db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
0B1D9A 58    3233** db 0x58 ; 041DD6
0B1D9B 00    3234** db 0x00 ; 041DD7
0B1D9C 41    3235** db 0x41 ; 041DD8
0B1D9D 46    3236** db 0x46 ; 041DD9
0B1D9E 00    3237** db 0x00 ; 041DDA
0B1D9F 41    3238** db 0x41 ; 041DDB
0B1DA0 46    3239** db 0x46 ; 041DDC
0B1DA1 A7    3240** db 0xa7 ; 041DDD
0B1DA2 08    3241** db 0x08 ; 041DDE
0B1DA3 52    3242** db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
0B1DA4 52    3243** db 0x52 ; 041DE0
0B1DA5 43    3244** db 0x43 ; 041DE1
0B1DA6 C1    3245** db 0xc1 ; 041DE2
0B1DA7 0F    3246** db 0x0f ; 041DE3
0B1DA8 52    3247** db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
0B1DA9 4C    3248** db 0x4c ; 041DE5
0B1DAA C1    3249** db 0xc1 ; 041DE6
0B1DAB 17    3250** db 0x17 ; 041DE7
0B1DAC 52    3251** db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
0B1DAD 52    3252** db 0x52 ; 041DE9
0B1DAE C1    3253** db 0xc1 ; 041DEA
0B1DAF 1F    3254** db 0x1f ; 041DEB
0B1DB0 44    3255** db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
0B1DB1 41    3256** db 0x41 ; 041DED
0B1DB2 C1    3257** db 0xc1 ; 041DEE
0B1DB3 27    3258** db 0x27 ; 041DEF
0B1DB4 43    3259** db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
0B1DB5 50    3260** db 0x50 ; 041DF1
0B1DB6 CC    3261** db 0xcc ; 041DF2
0B1DB7 2F    3262** db 0x2f ; 041DF3
0B1DB8 53    3263** db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
0B1DB9 43    3264** db 0x43 ; 041DF5
0B1DBA C6    3265** db 0xc6 ; 041DF6
0B1DBB 37    3266** db 0x37 ; 041DF7
0B1DBC 43    3267** db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
0B1DBD 43    3268** db 0x43 ; 041DF9
0B1DBE C6    3269** db 0xc6 ; 041DFA
0B1DBF 3F    3270** db 0x3f ; 041DFB
0B1DC0 48    3271** db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
0B1DC1 41    3272** db 0x41 ; 041DFD
0B1DC2 4C    3273** db 0x4c ; 041DFE
0B1DC3 D4    3274** db 0xd4 ; 041DFF
0B1DC4 76    3275** db 0x76 ; 041E00
0B1DC5 45    3276** db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
0B1DC6 58    3277** db 0x58 ; 041E02
0B1DC7 D8    3278** db 0xd8 ; 041E03
0B1DC8 D9    3279** db 0xd9 ; 041E04
0B1DC9 45    3280** db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
0B1DCA 58    3281** db 0x58 ; 041E06
0B1DCB 00    3282** db 0x00 ; 041E07
0B1DCC 44    3283** db 0x44 ; 041E08
0B1DCD 45    3284** db 0x45 ; 041E09
0B1DCE 00    3285** db 0x00 ; 041E0A
0B1DCF 48    3286** db 0x48 ; 041E0B
0B1DD0 CC    3287** db 0xcc ; 041E0C
0B1DD1 EB    3288** db 0xeb ; 041E0D
0B1DD2 44    3289** db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
0B1DD3 C9    3290** db 0xc9 ; 041E0F
0B1DD4 F3    3291** db 0xf3 ; 041E10
0B1DD5 45    3292** db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
0B1DD6 C9    3293** db 0xc9 ; 041E12
0B1DD7 FB    3294** db 0xfb ; 041E13
             3295** ;
             3296** ; Group 1: (53 opcodes)
             3297** ; As Group 0, but with an ED prefix
             3298** ;
0B1DD8 4E    3299** db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
0B1DD9 45    3300** db 0x45 ; 041E15
0B1DDA C7    3301** db 0xc7 ; 041E16
0B1DDB 44    3302** db 0x44 ; 041E17
0B1DDC 49    3303** db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
0B1DDD 4D    3304** db 0x4d ; 041E19
0B1DDE 00    3305** db 0x00 ; 041E1A
0B1DDF B0    3306** db 0xb0 ; 041E1B
0B1DE0 46    3307** db 0x46 ; 041E1C
0B1DE1 52    3308** db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
0B1DE2 45    3309** db 0x45 ; 041E1E
0B1DE3 54    3310** db 0x54 ; 041E1F
0B1DE4 CE    3311** db 0xce ; 041E20
0B1DE5 45    3312** db 0x45 ; 041E21
0B1DE6 4D    3313** db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
0B1DE7 4C    3314** db 0x4c ; 041E23
0B1DE8 54    3315** db 0x54 ; 041E24
0B1DE9 00    3316** db 0x00 ; 041E25
0B1DEA 42    3317** db 0x42 ; 041E26
0B1DEB C3    3318** db 0xc3 ; 041E27
0B1DEC 4C    3319** db 0x4c ; 041E28
0B1DED 52    3320** db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
0B1DEE 45    3321** db 0x45 ; 041E2A
0B1DEF 54    3322** db 0x54 ; 041E2B
0B1DF0 C9    3323** db 0xc9 ; 041E2C
0B1DF1 4D    3324** db 0x4d ; 041E2D
0B1DF2 49    3325** db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
0B1DF3 4D    3326** db 0x4d ; 041E2F
0B1DF4 00    3327** db 0x00 ; 041E30
0B1DF5 B1    3328** db 0xb1 ; 041E31
0B1DF6 56    3329** db 0x56 ; 041E32
0B1DF7 4D    3330** db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
0B1DF8 4C    3331** db 0x4c ; 041E34
0B1DF9 54    3332** db 0x54 ; 041E35
0B1DFA 00    3333** db 0x00 ; 041E36
0B1DFB 44    3334** db 0x44 ; 041E37
0B1DFC C5    3335** db 0xc5 ; 041E38
0B1DFD 5C    3336** db 0x5c ; 041E39
0B1DFE 49    3337** db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
0B1DFF 4D    3338** db 0x4d ; 041E3B
0B1E00 00    3339** db 0x00 ; 041E3C
0B1E01 B2    3340** db 0xb2 ; 041E3D
0B1E02 5E    3341** db 0x5e ; 041E3E
0B1E03 52    3342** db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
0B1E04 52    3343** db 0x52 ; 041E40
0B1E05 C4    3344** db 0xc4 ; 041E41
0B1E06 67    3345** db 0x67 ; 041E42
0B1E07 4D    3346** db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
0B1E08 4C    3347** db 0x4c ; 041E44
0B1E09 54    3348** db 0x54 ; 041E45
0B1E0A 00    3349** db 0x00 ; 041E46
0B1E0B 48    3350** db 0x48 ; 041E47
0B1E0C CC    3351** db 0xcc ; 041E48
0B1E0D 6C    3352** db 0x6c ; 041E49
0B1E0E 4C    3353** db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
0B1E0F 44    3354** db 0x44 ; 041E4B
0B1E10 00    3355** db 0x00 ; 041E4C
0B1E11 4D    3356** db 0x4d ; 041E4D
0B1E12 42    3357** db 0x42 ; 041E4E
0B1E13 00    3358** db 0x00 ; 041E4F
0B1E14 C1    3359** db 0xc1 ; 041E50
0B1E15 6D    3360** db 0x6d ; 041E51
0B1E16 4C    3361** db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
0B1E17 44    3362** db 0x44 ; 041E53
0B1E18 00    3363** db 0x00 ; 041E54
0B1E19 41    3364** db 0x41 ; 041E55
0B1E1A 00    3365** db 0x00 ; 041E56
0B1E1B 4D    3366** db 0x4d ; 041E57
0B1E1C C2    3367** db 0xc2 ; 041E58
0B1E1D 6E    3368** db 0x6e ; 041E59
0B1E1E 52    3369** db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
0B1E1F 4C    3370** db 0x4c ; 041E5B
0B1E20 C4    3371** db 0xc4 ; 041E5C
0B1E21 6F    3372** db 0x6f ; 041E5D
0B1E22 53    3373** db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
0B1E23 4C    3374** db 0x4c ; 041E5F
0B1E24 D0    3375** db 0xd0 ; 041E60
0B1E25 76    3376** db 0x76 ; 041E61
0B1E26 4D    3377** db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
0B1E27 4C    3378** db 0x4c ; 041E63
0B1E28 54    3379** db 0x54 ; 041E64
0B1E29 00    3380** db 0x00 ; 041E65
0B1E2A 53    3381** db 0x53 ; 041E66
0B1E2B D0    3382** db 0xd0 ; 041E67
0B1E2C 7C    3383** db 0x7c ; 041E68
0B1E2D 53    3384** db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
0B1E2E 54    3385** db 0x54 ; 041E6A
0B1E2F 4D    3386** db 0x4d ; 041E6B
0B1E30 49    3387** db 0x49 ; 041E6C
0B1E31 D8    3388** db 0xd8 ; 041E6D
0B1E32 7D    3389** db 0x7d ; 041E6E
0B1E33 52    3390** db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
0B1E34 53    3391** db 0x53 ; 041E70
0B1E35 4D    3392** db 0x4d ; 041E71
0B1E36 49    3393** db 0x49 ; 041E72
0B1E37 D8    3394** db 0xd8 ; 041E73
0B1E38 7E    3395** db 0x7e ; 041E74
0B1E39 49    3396** db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
0B1E3A 4E    3397** db 0x4e ; 041E76
0B1E3B 49    3398** db 0x49 ; 041E77
0B1E3C CD    3399** db 0xcd ; 041E78
0B1E3D 82    3400** db 0x82 ; 041E79
0B1E3E 4F    3401** db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
0B1E3F 54    3402** db 0x54 ; 041E7B
0B1E40 49    3403** db 0x49 ; 041E7C
0B1E41 CD    3404** db 0xcd ; 041E7D
0B1E42 83    3405** db 0x83 ; 041E7E
0B1E43 49    3406** db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
0B1E44 4E    3407** db 0x4e ; 041E80
0B1E45 49    3408** db 0x49 ; 041E81
0B1E46 B2    3409** db 0xb2 ; 041E82
0B1E47 84    3410** db 0x84 ; 041E83
0B1E48 49    3411** db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
0B1E49 4E    3412** db 0x4e ; 041E85
0B1E4A 44    3413** db 0x44 ; 041E86
0B1E4B CD    3414** db 0xcd ; 041E87
0B1E4C 8A    3415** db 0x8a ; 041E88
0B1E4D 4F    3416** db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
0B1E4E 54    3417** db 0x54 ; 041E8A
0B1E4F 44    3418** db 0x44 ; 041E8B
0B1E50 CD    3419** db 0xcd ; 041E8C
0B1E51 8B    3420** db 0x8b ; 041E8D
0B1E52 49    3421** db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
0B1E53 4E    3422** db 0x4e ; 041E8F
0B1E54 44    3423** db 0x44 ; 041E90
0B1E55 B2    3424** db 0xb2 ; 041E91
0B1E56 8C    3425** db 0x8c ; 041E92
0B1E57 49    3426** db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
0B1E58 4E    3427** db 0x4e ; 041E94
0B1E59 49    3428** db 0x49 ; 041E95
0B1E5A 4D    3429** db 0x4d ; 041E96
0B1E5B D2    3430** db 0xd2 ; 041E97
0B1E5C 92    3431** db 0x92 ; 041E98
0B1E5D 4F    3432** db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
0B1E5E 54    3433** db 0x54 ; 041E9A
0B1E5F 49    3434** db 0x49 ; 041E9B
0B1E60 4D    3435** db 0x4d ; 041E9C
0B1E61 D2    3436** db 0xd2 ; 041E9D
0B1E62 93    3437** db 0x93 ; 041E9E
0B1E63 49    3438** db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
0B1E64 4E    3439** db 0x4e ; 041EA0
0B1E65 49    3440** db 0x49 ; 041EA1
0B1E66 32    3441** db 0x32 ; 041EA2
0B1E67 D2    3442** db 0xd2 ; 041EA3
0B1E68 94    3443** db 0x94 ; 041EA4
0B1E69 49    3444** db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
0B1E6A 4E    3445** db 0x4e ; 041EA6
0B1E6B 44    3446** db 0x44 ; 041EA7
0B1E6C 4D    3447** db 0x4d ; 041EA8
0B1E6D D2    3448** db 0xd2 ; 041EA9
0B1E6E 9A    3449** db 0x9a ; 041EAA
0B1E6F 4F    3450** db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
0B1E70 54    3451** db 0x54 ; 041EAC
0B1E71 44    3452** db 0x44 ; 041EAD
0B1E72 4D    3453** db 0x4d ; 041EAE
0B1E73 D2    3454** db 0xd2 ; 041EAF
0B1E74 9B    3455** db 0x9b ; 041EB0
0B1E75 49    3456** db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
0B1E76 4E    3457** db 0x4e ; 041EB2
0B1E77 44    3458** db 0x44 ; 041EB3
0B1E78 32    3459** db 0x32 ; 041EB4
0B1E79 D2    3460** db 0xd2 ; 041EB5
0B1E7A 9C    3461** db 0x9c ; 041EB6
0B1E7B 4C    3462** db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
0B1E7C 44    3463** db 0x44 ; 041EB8
0B1E7D C9    3464** db 0xc9 ; 041EB9
0B1E7E A0    3465** db 0xa0 ; 041EBA
0B1E7F 43    3466** db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
0B1E80 50    3467** db 0x50 ; 041EBC
0B1E81 C9    3468** db 0xc9 ; 041EBD
0B1E82 A1    3469** db 0xa1 ; 041EBE
0B1E83 49    3470** db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
0B1E84 4E    3471** db 0x4e ; 041EC0
0B1E85 C9    3472** db 0xc9 ; 041EC1
0B1E86 A2    3473** db 0xa2 ; 041EC2
0B1E87 4F    3474** db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
0B1E88 55    3475** db 0x55 ; 041EC4
0B1E89 54    3476** db 0x54 ; 041EC5
0B1E8A 49    3477** db 0x49 ; 041EC6
0B1E8B B2    3478** db 0xb2 ; 041EC7
0B1E8C A4    3479** db 0xa4 ; 041EC8
0B1E8D 4F    3480** db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
0B1E8E 55    3481** db 0x55 ; 041ECA
0B1E8F 54    3482** db 0x54 ; 041ECB
0B1E90 C9    3483** db 0xc9 ; 041ECC
0B1E91 A3    3484** db 0xa3 ; 041ECD
0B1E92 4C    3485** db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
0B1E93 44    3486** db 0x44 ; 041ECF
0B1E94 C4    3487** db 0xc4 ; 041ED0
0B1E95 A8    3488** db 0xa8 ; 041ED1
0B1E96 43    3489** db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
0B1E97 50    3490** db 0x50 ; 041ED3
0B1E98 C4    3491** db 0xc4 ; 041ED4
0B1E99 A9    3492** db 0xa9 ; 041ED5
0B1E9A 49    3493** db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
0B1E9B 4E    3494** db 0x4e ; 041ED7
0B1E9C C4    3495** db 0xc4 ; 041ED8
0B1E9D AA    3496** db 0xaa ; 041ED9
0B1E9E 4F    3497** db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
0B1E9F 55    3498** db 0x55 ; 041EDB
0B1EA0 54    3499** db 0x54 ; 041EDC
0B1EA1 44    3500** db 0x44 ; 041EDD
0B1EA2 B2    3501** db 0xb2 ; 041EDE
0B1EA3 AC    3502** db 0xac ; 041EDF
0B1EA4 4F    3503** db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
0B1EA5 55    3504** db 0x55 ; 041EE1
0B1EA6 54    3505** db 0x54 ; 041EE2
0B1EA7 C4    3506** db 0xc4 ; 041EE3
0B1EA8 AB    3507** db 0xab ; 041EE4
0B1EA9 4C    3508** db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
0B1EAA 44    3509** db 0x44 ; 041EE6
0B1EAB 49    3510** db 0x49 ; 041EE7
0B1EAC D2    3511** db 0xd2 ; 041EE8
0B1EAD B0    3512** db 0xb0 ; 041EE9
0B1EAE 43    3513** db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
0B1EAF 50    3514** db 0x50 ; 041EEB
0B1EB0 49    3515** db 0x49 ; 041EEC
0B1EB1 D2    3516** db 0xd2 ; 041EED
0B1EB2 B1    3517** db 0xb1 ; 041EEE
0B1EB3 49    3518** db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
0B1EB4 4E    3519** db 0x4e ; 041EF0
0B1EB5 49    3520** db 0x49 ; 041EF1
0B1EB6 D2    3521** db 0xd2 ; 041EF2
0B1EB7 B2    3522** db 0xb2 ; 041EF3
0B1EB8 4F    3523** db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
0B1EB9 54    3524** db 0x54 ; 041EF5
0B1EBA 49    3525** db 0x49 ; 041EF6
0B1EBB D2    3526** db 0xd2 ; 041EF7
0B1EBC B3    3527** db 0xb3 ; 041EF8
0B1EBD 4F    3528** db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
0B1EBE 54    3529** db 0x54 ; 041EFA
0B1EBF 49    3530** db 0x49 ; 041EFB
0B1EC0 32    3531** db 0x32 ; 041EFC
0B1EC1 D2    3532** db 0xd2 ; 041EFD
0B1EC2 B4    3533** db 0xb4 ; 041EFE
0B1EC3 4C    3534** db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
0B1EC4 44    3535** db 0x44 ; 041F00
0B1EC5 44    3536** db 0x44 ; 041F01
0B1EC6 D2    3537** db 0xd2 ; 041F02
0B1EC7 B8    3538** db 0xb8 ; 041F03
0B1EC8 43    3539** db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
0B1EC9 50    3540** db 0x50 ; 041F05
0B1ECA 44    3541** db 0x44 ; 041F06
0B1ECB D2    3542** db 0xd2 ; 041F07
0B1ECC B9    3543** db 0xb9 ; 041F08
0B1ECD 49    3544** db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
0B1ECE 4E    3545** db 0x4e ; 041F0A
0B1ECF 44    3546** db 0x44 ; 041F0B
0B1ED0 D2    3547** db 0xd2 ; 041F0C
0B1ED1 BA    3548** db 0xba ; 041F0D
0B1ED2 4F    3549** db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
0B1ED3 54    3550** db 0x54 ; 041F0F
0B1ED4 44    3551** db 0x44 ; 041F10
0B1ED5 D2    3552** db 0xd2 ; 041F11
0B1ED6 BB    3553** db 0xbb ; 041F12
0B1ED7 4F    3554** db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
0B1ED8 54    3555** db 0x54 ; 041F14
0B1ED9 44    3556** db 0x44 ; 041F15
0B1EDA 32    3557** db 0x32 ; 041F16
0B1EDB D2    3558** db 0xd2 ; 041F17
0B1EDC BC    3559** db 0xbc ; 041F18
0B1EDD 49    3560** db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
0B1EDE 4E    3561** db 0x4e ; 041F1A
0B1EDF 49    3562** db 0x49 ; 041F1B
0B1EE0 52    3563** db 0x52 ; 041F1C
0B1EE1 D8    3564** db 0xd8 ; 041F1D
0B1EE2 C2    3565** db 0xc2 ; 041F1E
0B1EE3 4F    3566** db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
0B1EE4 54    3567** db 0x54 ; 041F20
0B1EE5 49    3568** db 0x49 ; 041F21
0B1EE6 52    3569** db 0x52 ; 041F22
0B1EE7 D8    3570** db 0xd8 ; 041F23
0B1EE8 C3    3571** db 0xc3 ; 041F24
0B1EE9 49    3572** db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
0B1EEA 4E    3573** db 0x4e ; 041F26
0B1EEB 44    3574** db 0x44 ; 041F27
0B1EEC 52    3575** db 0x52 ; 041F28
0B1EED D8    3576** db 0xd8 ; 041F29
0B1EEE CA    3577** db 0xca ; 041F2A
0B1EEF 4F    3578** db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
0B1EF0 54    3579** db 0x54 ; 041F2C
0B1EF1 44    3580** db 0x44 ; 041F2D
0B1EF2 52    3581** db 0x52 ; 041F2E
0B1EF3 D8    3582** db 0xd8 ; 041F2F
0B1EF4 CB    3583** db 0xcb ; 041F30
             3584** ;
             3585** ; Group 2: (3 opcodes)
             3586** ;
0B1EF5 42    3587** db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
0B1EF6 49    3588** db 0x49 ; 041F32
0B1EF7 D4    3589** db 0xd4 ; 041F33
0B1EF8 40    3590** db 0x40 ; 041F34
0B1EF9 52    3591** db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
0B1EFA 45    3592** db 0x45 ; 041F36
0B1EFB D3    3593** db 0xd3 ; 041F37
0B1EFC 80    3594** db 0x80 ; 041F38
0B1EFD 53    3595** db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
0B1EFE 45    3596** db 0x45 ; 041F3A
0B1EFF D4    3597** db 0xd4 ; 041F3B
0B1F00 C0    3598** db 0xc0 ; 041F3C
             3599** ;
             3600** ; Group 3: (7 opcodes)
             3601** ;
0B1F01 52    3602** db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
0B1F02 4C    3603** db 0x4c ; 041F3E
0B1F03 C3    3604** db 0xc3 ; 041F3F
0B1F04 00    3605** db 0x00 ; 041F40
0B1F05 52    3606** db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
0B1F06 52    3607** db 0x52 ; 041F42
0B1F07 C3    3608** db 0xc3 ; 041F43
0B1F08 08    3609** db 0x08 ; 041F44
0B1F09 52    3610** db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
0B1F0A CC    3611** db 0xcc ; 041F46
0B1F0B 10    3612** db 0x10 ; 041F47
0B1F0C 52    3613** db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
0B1F0D D2    3614** db 0xd2 ; 041F49
0B1F0E 18    3615** db 0x18 ; 041F4A
0B1F0F 53    3616** db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
0B1F10 4C    3617** db 0x4c ; 041F4C
0B1F11 C1    3618** db 0xc1 ; 041F4D
0B1F12 20    3619** db 0x20 ; 041F4E
0B1F13 53    3620** db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
0B1F14 52    3621** db 0x52 ; 041F50
0B1F15 C1    3622** db 0xc1 ; 041F51
0B1F16 28    3623** db 0x28 ; 041F52
0B1F17 53    3624** db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
0B1F18 52    3625** db 0x52 ; 041F54
0B1F19 CC    3626** db 0xcc ; 041F55
0B1F1A 38    3627** db 0x38 ; 041F56
             3628** ;
             3629** ; Group 4: (3 opcodes)
             3630** ;
0B1F1B 50    3631** db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
0B1F1C 4F    3632** db 0x4f ; 041F58
0B1F1D D0    3633** db 0xd0 ; 041F59
0B1F1E C1    3634** db 0xc1 ; 041F5A
0B1F1F 50    3635** db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
0B1F20 55    3636** db 0x55 ; 041F5C
0B1F21 53    3637** db 0x53 ; 041F5D
0B1F22 C8    3638** db 0xc8 ; 041F5E
0B1F23 C5    3639** db 0xc5 ; 041F5F
0B1F24 45    3640** db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
0B1F25 58    3641** db 0x58 ; 041F61
0B1F26 00    3642** db 0x00 ; 041F62
0B1F27 28    3643** db 0x28 ; 041F63
0B1F28 53    3644** db 0x53 ; 041F64
0B1F29 D0    3645** db 0xd0 ; 041F65
0B1F2A E3    3646** db 0xe3 ; 041F66
             3647** ;
             3648** ; Group 5: (7 opcodes)
             3649** ;
0B1F2B 53    3650** db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
0B1F2C 55    3651** db 0x55 ; 041F68
0B1F2D C2    3652** db 0xc2 ; 041F69
0B1F2E 90    3653** db 0x90 ; 041F6A
0B1F2F 41    3654** db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
0B1F30 4E    3655** db 0x4e ; 041F6C
0B1F31 C4    3656** db 0xc4 ; 041F6D
0B1F32 A0    3657** db 0xa0 ; 041F6E
0B1F33 58    3658** db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
0B1F34 4F    3659** db 0x4f ; 041F70
0B1F35 D2    3660** db 0xd2 ; 041F71
0B1F36 A8    3661** db 0xa8 ; 041F72
0B1F37 4F    3662** db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
0B1F38 D2    3663** db 0xd2 ; 041F74
0B1F39 B0    3664** db 0xb0 ; 041F75
0B1F3A 43    3665** db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
0B1F3B D0    3666** db 0xd0 ; 041F77
0B1F3C B8    3667** db 0xb8 ; 041F78
0B1F3D 80    3668** db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
0B1F3E A0    3669** db 0xa0 ; 041F7A
0B1F3F 84    3670** db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
0B1F40 B0    3671** db 0xb0 ; 041F7C
             3672** ;
             3673** ; Group 6 (3 opcodes)
             3674** ;
0B1F41 41    3675** db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
0B1F42 44    3676** db 0x44 ; 041F7E
0B1F43 C4    3677** db 0xc4 ; 041F7F
0B1F44 80    3678** db 0x80 ; 041F80
0B1F45 41    3679** db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
0B1F46 44    3680** db 0x44 ; 041F82
0B1F47 C3    3681** db 0xc3 ; 041F83
0B1F48 88    3682** db 0x88 ; 041F84
0B1F49 53    3683** db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
0B1F4A 42    3684** db 0x42 ; 041F86
0B1F4B C3    3685** db 0xc3 ; 041F87
0B1F4C 98    3686** db 0x98 ; 041F88
             3687** ;
             3688** ; Group 7: (2 opcodes)
             3689** ;
0B1F4D 49    3690** db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
0B1F4E 4E    3691** db 0x4e ; 041F8A
0B1F4F C3    3692** db 0xc3 ; 041F8B
0B1F50 04    3693** db 0x04 ; 041F8C
0B1F51 44    3694** db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
0B1F52 45    3695** db 0x45 ; 041F8E
0B1F53 C3    3696** db 0xc3 ; 041F8F
0B1F54 05    3697** db 0x05 ; 041F90
             3698** ;
             3699** ; Group 8: (2 opcodes)
             3700** ;
0B1F55 49    3701** db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
0B1F56 4E    3702** db 0x4e ; 041F92
0B1F57 B0    3703** db 0xb0 ; 041F93
0B1F58 00    3704** db 0x00 ; 041F94
0B1F59 4F    3705** db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
0B1F5A 55    3706** db 0x55 ; 041F96
0B1F5B 54    3707** db 0x54 ; 041F97
0B1F5C B0    3708** db 0xb0 ; 041F98
0B1F5D 01    3709** db 0x01 ; 041F99
             3710** ;
             3711** ; Group 9: (1 opcode)
             3712** ;
0B1F5E 49    3713** db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
0B1F5F CE    3714** db 0xce ; 041F9B
0B1F60 40    3715** db 0x40 ; 041F9C
             3716** ;
             3717** ; Group 10: (1 opcode)
             3718** ;
0B1F61 4F    3719** db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
0B1F62 55    3720** db 0x55 ; 041F9E
0B1F63 D4    3721** db 0xd4 ; 041F9F
0B1F64 41    3722** db 0x41 ; 041FA0
             3723** ;
             3724** ; Group 11: (2 opcodes)
             3725** ;
0B1F65 4A    3726** db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
0B1F66 D2    3727** db 0xd2 ; 041FA2
0B1F67 20    3728** db 0x20 ; 041FA3
0B1F68 44    3729** db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
0B1F69 4A    3730** db 0x4a ; 041FA5
0B1F6A 4E    3731** db 0x4e ; 041FA6
0B1F6B DA    3732** db 0xda ; 041FA7
0B1F6C 10    3733** db 0x10 ; 041FA8
             3734** ;
             3735** ; Group 12: (1 opcode)
             3736** ;
0B1F6D 4A    3737** db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
0B1F6E D0    3738** db 0xd0 ; 041FAA
0B1F6F C2    3739** db 0xc2 ; 041FAB
             3740** ;
             3741** ; Group 13: (1 opcode)
             3742** ;
0B1F70 43    3743** db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
0B1F71 41    3744** db 0x41 ; 041FAD
0B1F72 4C    3745** db 0x4c ; 041FAE
0B1F73 CC    3746** db 0xcc ; 041FAF
0B1F74 C4    3747** db 0xc4 ; 041FB0
             3748** ;
             3749** ; Group 14: (1 opcode)
             3750** ;
0B1F75 52    3751** db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
0B1F76 53    3752** db 0x53 ; 041FB2
0B1F77 D4    3753** db 0xd4 ; 041FB3
0B1F78 C7    3754** db 0xc7 ; 041FB4
             3755** ;
             3756** ; Group 15: (1 opcode)
             3757** ;
0B1F79 52    3758** db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
0B1F7A 45    3759** db 0x45 ; 041FB6
0B1F7B D4    3760** db 0xd4 ; 041FB7
0B1F7C C0    3761** db 0xc0 ; 041FB8
             3762** ;
             3763** ; Group 16: (1 opcode)
             3764** ;
0B1F7D 4C    3765** db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
0B1F7E C4    3766** db 0xc4 ; 041FBA
0B1F7F 40    3767** db 0x40 ; 041FBB
             3768** ;
             3769** ; Group 17: (1 opcode)
             3770** ;
0B1F80 54    3771** db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
0B1F81 53    3772** db 0x53 ; 041FBD
0B1F82 D4    3773** db 0xd4 ; 041FBE
0B1F83 04    3774** db 0x04 ; 041FBF
             3775** ;
             3776** ; Assembler Directives
             3777** ;
0B1F84 4F    3778** db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
0B1F85 50    3779** db 0x50 ; 041FC1
0B1F86 D4    3780** db 0xd4 ; 041FC2
0B1F87 00    3781** db 0x00 ; 041FC3
0B1F88 41    3782** db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
0B1F89 44    3783** db 0x44 ; 041FC5
0B1F8A CC    3784** db 0xcc ; 041FC6
0B1F8B 00    3785** db 0x00 ; 041FC7
0B1F8C 5D    3786** db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
0B1F8D C2    3787** db 0xc2 ; 041FC9
0B1F8E 00    3788** db 0x00 ; 041FCA
0B1F8F 5D    3789** db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
0B1F90 D7    3790** db 0xd7 ; 041FCC
0B1F91 00    3791** db 0x00 ; 041FCD
0B1F92 5D    3792** db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
0B1F93 CC    3793** db 0xcc ; 041FCF
0B1F94 00    3794** db 0x00 ; 041FD0
0B1F95 5D    3795** db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
0B1F96 CD    3796** db 0xcd ; 041FD2
0B1F97 00    3797** db 0x00 ; 041FD3
0B1F98 00    3798** db 0x00 ; 041FD4 00      5426 DB	0
             3799** ;
             3800** ; Operands
             3801** ;
             3802** OPRNDS:
0B1F99 C2    3803** db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
0B1F9A 00    3804** db 0x00 ; 041FD6
0B1F9B C3    3805** db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
0B1F9C 01    3806** db 0x01 ; 041FD8
0B1F9D C4    3807** db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
0B1F9E 02    3808** db 0x02 ; 041FDA
0B1F9F C5    3809** db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
0B1FA0 03    3810** db 0x03 ; 041FDC
0B1FA1 C8    3811** db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
0B1FA2 04    3812** db 0x04 ; 041FDE
0B1FA3 CC    3813** db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
0B1FA4 05    3814** db 0x05 ; 041FE0
0B1FA5 28    3815** db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
0B1FA6 48    3816** db 0x48 ; 041FE2
0B1FA7 CC    3817** db 0xcc ; 041FE3
0B1FA8 06    3818** db 0x06 ; 041FE4
0B1FA9 C1    3819** db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
0B1FAA 07    3820** db 0x07 ; 041FE6
0B1FAB 28    3821** db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
0B1FAC 49    3822** db 0x49 ; 041FE8
0B1FAD D8    3823** db 0xd8 ; 041FE9
0B1FAE 86    3824** db 0x86 ; 041FEA
0B1FAF 28    3825** db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
0B1FB0 49    3826** db 0x49 ; 041FEC
0B1FB1 D9    3827** db 0xd9 ; 041FED
0B1FB2 C6    3828** db 0xc6 ; 041FEE
0B1FB3 42    3829** db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
0B1FB4 C3    3830** db 0xc3 ; 041FF0
0B1FB5 08    3831** db 0x08 ; 041FF1
0B1FB6 44    3832** db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
0B1FB7 C5    3833** db 0xc5 ; 041FF3
0B1FB8 0A    3834** db 0x0a ; 041FF4
0B1FB9 48    3835** db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
0B1FBA CC    3836** db 0xcc ; 041FF6
0B1FBB 0C    3837** db 0x0c ; 041FF7
0B1FBC 49    3838** db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
0B1FBD D8    3839** db 0xd8 ; 041FF9
0B1FBE 8C    3840** db 0x8c ; 041FFA
0B1FBF 49    3841** db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
0B1FC0 D9    3842** db 0xd9 ; 041FFC
0B1FC1 CC    3843** db 0xcc ; 041FFD
0B1FC2 41    3844** db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
0B1FC3 C6    3845** db 0xc6 ; 041FFF
0B1FC4 0E    3846** db 0x0e ; 042000
0B1FC5 53    3847** db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
0B1FC6 D0    3848** db 0xd0 ; 042002
0B1FC7 0E    3849** db 0x0e ; 042003
0B1FC8 4E    3850** db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
0B1FC9 DA    3851** db 0xda ; 042005
0B1FCA 10    3852** db 0x10 ; 042006
0B1FCB DA    3853** db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
0B1FCC 11    3854** db 0x11 ; 042008
0B1FCD 4E    3855** db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
0B1FCE C3    3856** db 0xc3 ; 04200A
0B1FCF 12    3857** db 0x12 ; 04200B
0B1FD0 50    3858** db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
0B1FD1 CF    3859** db 0xcf ; 04200D
0B1FD2 14    3860** db 0x14 ; 04200E
0B1FD3 50    3861** db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
0B1FD4 C5    3862** db 0xc5 ; 042010
0B1FD5 15    3863** db 0x15 ; 042011
0B1FD6 D0    3864** db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
0B1FD7 16    3865** db 0x16 ; 042013
0B1FD8 CD    3866** db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
0B1FD9 17    3867** db 0x17 ; 042015
0B1FDA 28    3868** db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
0B1FDB C3    3869** db 0xc3 ; 042017
0B1FDC 20    3870** db 0x20 ; 042018
0B1FDD 00    3871** db 0x00 ; 042019 00      5459 DB	0
             3872** ;
             3873** ; Load operations
             3874** ;
             3875** LDOPS:
0B1FDE 49    3876** db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
0B1FDF 00    3877** db 0x00 ; 04201B
0B1FE0 C1    3878** db 0xc1 ; 04201C
0B1FE1 47    3879** db 0x47 ; 04201D
0B1FE2 52    3880** db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
0B1FE3 00    3881** db 0x00 ; 04201F
0B1FE4 C1    3882** db 0xc1 ; 042020
0B1FE5 4F    3883** db 0x4f ; 042021
0B1FE6 41    3884** db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
0B1FE7 00    3885** db 0x00 ; 042023
0B1FE8 C9    3886** db 0xc9 ; 042024
0B1FE9 57    3887** db 0x57 ; 042025
0B1FEA 41    3888** db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
0B1FEB 00    3889** db 0x00 ; 042027
0B1FEC D2    3890** db 0xd2 ; 042028
0B1FED 5F    3891** db 0x5f ; 042029
0B1FEE 28    3892** db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
0B1FEF 42    3893** db 0x42 ; 04202B
0B1FF0 43    3894** db 0x43 ; 04202C
0B1FF1 00    3895** db 0x00 ; 04202D
0B1FF2 C1    3896** db 0xc1 ; 04202E
0B1FF3 02    3897** db 0x02 ; 04202F
0B1FF4 28    3898** db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
0B1FF5 44    3899** db 0x44 ; 042031
0B1FF6 45    3900** db 0x45 ; 042032
0B1FF7 00    3901** db 0x00 ; 042033
0B1FF8 C1    3902** db 0xc1 ; 042034
0B1FF9 12    3903** db 0x12 ; 042035
0B1FFA 41    3904** db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
0B1FFB 00    3905** db 0x00 ; 042037
0B1FFC 28    3906** db 0x28 ; 042038
0B1FFD 42    3907** db 0x42 ; 042039
0B1FFE C3    3908** db 0xc3 ; 04203A
0B1FFF 0A    3909** db 0x0a ; 04203B
0B2000 41    3910** db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
0B2001 00    3911** db 0x00 ; 04203D
0B2002 28    3912** db 0x28 ; 04203E
0B2003 44    3913** db 0x44 ; 04203F
0B2004 C5    3914** db 0xc5 ; 042040
0B2005 1A    3915** db 0x1a ; 042041
0B2006 00    3916** db 0x00 ; 042042 00      5472 DB	0
             3917** ;
             3918** ; eZ80 addressing mode suffixes
             3919** ;
             3920** ; Fully qualified suffixes
             3921** ;
             3922** EZ80SFS_1:
0B2007 4C    3923** db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
0B2008 49    3924** db 0x49 ; 042044
0B2009 D3    3925** db 0xd3 ; 042045
0B200A 49    3926** db 0x49 ; 042046
0B200B 53    3927** db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
0B200C 49    3928** db 0x49 ; 042048
0B200D CC    3929** db 0xcc ; 042049
0B200E 52    3930** db 0x52 ; 04204A
             3931** 
             3932** EZ80SFS_2:
0B200F 53    3933** db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
0B2010 49    3934** db 0x49 ; 04204C
0B2011 D3    3935** db 0xd3 ; 04204D
0B2012 40    3936** db 0x40 ; 04204E
0B2013 4C    3937** db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
0B2014 49    3938** db 0x49 ; 042050
0B2015 CC    3939** db 0xcc ; 042051
0B2016 5B    3940** db 0x5b ; 042052
0B2017 00    3941** db 0x00 ; 042053 00      5483 DB	0
             3942** ;
             3943** ; Shortcuts when ADL mode is 0
             3944** ;
             3945** EZ80SFS_ADL0:
0B2018 D3    3946** db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0B2019 40    3947** db 0x40 ; 042055
0B201A CC    3948** db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
0B201B 49    3949** db 0x49 ; 042057
0B201C 49    3950** db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
0B201D D3    3951** db 0xd3 ; 042059
0B201E 40    3952** db 0x40 ; 04205A
0B201F 49    3953** db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
0B2020 CC    3954** db 0xcc ; 04205C
0B2021 52    3955** db 0x52 ; 04205D
0B2022 00    3956** db 0x00 ; 04205E 00      5492 DB	0
             3957** ;
             3958** ; Shortcuts when ADL mode is 1
             3959** ;
             3960** EZ80SFS_ADL1:
0B2023 D3    3961** db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0B2024 52    3962** db 0x52 ; 042060
0B2025 CC    3963** db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
0B2026 5B    3964** db 0x5b ; 042062
0B2027 49    3965** db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
0B2028 D3    3966** db 0xd3 ; 042064
0B2029 49    3967** db 0x49 ; 042065
0B202A 49    3968** db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
0B202B CC    3969** db 0xcc ; 042067
0B202C 5B    3970** db 0x5b ; 042068
0B202D 00    3971** db 0x00 ; 042069 00      5501 DB	0
             3972** ; END INSERT FROM BINARY
             3973** ;
             3974** ; .LIST
             3975** ;
             3976** ; already defined in equs.inc
             3977** ; LF:			EQU     0AH
             3978** ; CR:			EQU     0DH
              0005* include "basic/fpp.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Z80 Floating Point Package
             0004** ; Author:	(C) Copyright  R.T.Russell  1986
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	03/05/2022
             0007** ; Last Updated:	07/06/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 26/10/1986:	Version 0.0
             0011** ; 14/12/1988:	Vesion 0.1 (Bug Fix)
             0012** ; 12/05/2023:	Modified by Dean Belfield
             0013** ; 07/06/2023:	Modified to run in ADL mode
             0014** 
             0015** ; .ASSUME	ADL = 1
             0016** 
             0017** ; SEGMENT CODE
             0018** 
             0019** ; XDEF	FPP
             0020** ; XDEF	DLOAD5
             0021** ; XDEF	DLOAD5_SPL
             0022** ;
             0023** ;BINARY FLOATING POINT REPRESENTATION:
             0024** ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
             0025** ;    8 BIT EXCESS-128 SIGNED EXPONENT
             0026** ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
             0027** ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
             0028** ;
             0029** ;BINARY INTEGER REPRESENTATION:
             0030** ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
             0031** ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
             0032** ;
             0033** ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
             0034** ;                            EXPONENT - C
             0035** ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
             0036** ;                               EXPONENT - B
             0037** 
             0038** ;
             0039** ;Error codes:
             0040** ;
             0041** 
             0042** BADOP:			EQU     1               ;Bad operation code
             0043** DIVBY0:			EQU     18              ;Division by zero
             0044** TOOBIG_FP:			EQU     20              ;Too big
             0045** NGROOT:			EQU     21              ;Negative root
             0046** LOGRNG:			EQU     22              ;Log range
             0047** ACLOST:			EQU     23              ;Accuracy lost
             0048** EXPRNG:			EQU     24              ;Exp range
             0049** ;
             0050** ;Call entry and despatch code:
             0051** ;
0B202E FD    0052** FPP:			PUSH    IY              ;Save IY
0B202F E5 
0B2030 FD    0053** LD      IY,0
0B2031 21 
0B2032 00 
0B2033 00 
0B2033 00   
0B2035 FD    0054** ADD     IY,SP           ;Save SP in IY
0B2036 39 
0B2037 CD    0055** CALL    OP              ;Perform operation
0B2038 47 
0B2039 20 
0B203A 0B 
0B203B BF    0056** CP      A               ;Good return (Z, NC)
0B203C FD    0057** EXIT_FP_:			POP     IY              ;Restore IY
0B203D E1 
0B203E C9    0058** RET                     ;Return to caller
             0059** ;
             0060** ;Error exit:
             0061** ;
0B203F 3E    0062** BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B2040 01 
0B2041 FD    0063** ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B2042 F9 
0B2043 B7    0064** OR      A               ;Set NZ
0B2044 37    0065** SCF                     ;Set C
0B2045 18    0066** JR      EXIT_FP_
0B2046 F5 
             0067** ;
             0068** ;Perform operation or function:
             0069** ;
             0070** ; OP:			CP      (RTABLE-DTABLE)/3
0B2047 FE    0071** OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2048 2A 
             0072** 
0B2049 30    0073** JR      NC,BAD_FP
0B204A F4 
             0074** ; CP      (FTABLE-DTABLE)/3
0B204B FE    0075** CP      FTABLE-DTABLE/3 ; ditto
0B204C 10 
0B204D 30    0076** JR      NC,DISPAT_FP
0B204E 08 
0B204F 08    0077** EX      AF,AF'
0B2050 78    0078** LD      A,B
0B2051 B1    0079** OR      C               ;Both integer?
0B2052 C4    0080** CALL    NZ,FLOATA       ;No, so float both
0B2053 5A 
0B2054 2B 
0B2055 0B 
0B2056 08    0081** EX      AF,AF'
0B2057 E5    0082** DISPAT_FP:			PUSH    HL
0B2058 21    0083** LD      HL,DTABLE
0B2059 6A 
0B205A 20 
0B205B 0B 
0B205C C5    0084** PUSH    BC
0B205D 01    0085** LD	BC, 3		; C = 3
0B205E 03 
0B205F 00 
0B2060 00 
0B2061 47    0086** LD	B, A 		; B = op-code
0B2062 ED    0087** MLT 	BC 		;BC = op-code * 3
0B2063 4C 
0B2064 09    0088** ADD	HL, BC 		;Add to table base
0B2065 ED    0089** LD	HL, (HL)	;Get the routine address (24-bit)
0B2066 27 
             0090** 
             0091** ;        		ADD     A, A            ;A = op-code * 2
             0092** ;        		LD      C,A
             0093** ;        		LD      B,0             ;BC = op-code * 2
             0094** ;        		ADD     HL,BC
             0095** ;        		LD      A,(HL)          ;Get low byte
             0096** ;        		INC     HL
             0097** ;        		LD      H,(HL)          ;Get high byte
             0098** ;        		LD      L,A
             0099** 
0B2067 C1    0100** POP     BC
0B2068 E3    0101** EX      (SP),HL
0B2069 C9    0102** RET                     ;Off to routine
             0103** ;
             0104** ;Despatch table:
             0105** ;
0B206A 1C    0106** DTABLE:			DW24  IAND            ;AND (INTEGER)
0B206B 21 
0B206C 0B 
0B206D 8A    0107** DW24  IBDIV           ;DIV
0B206E 21 
0B206F 0B 
0B2070 2F    0108** DW24  IEOR            ;EOR
0B2071 21 
0B2072 0B 
0B2073 55    0109** DW24  IMOD            ;MOD
0B2074 21 
0B2075 0B 
0B2076 42    0110** DW24  IOR             ;OR
0B2077 21 
0B2078 0B 
0B2079 10    0111** DW24  ILE             ;<=
0B207A 24 
0B207B 0B 
0B207C 1F    0112** DW24  INE             ;<>
0B207D 24 
0B207E 0B 
0B207F 03    0113** DW24  IGE             ;>=
0B2080 24 
0B2081 0B 
0B2082 E8    0114** DW24  ILT             ;<
0B2083 23 
0B2084 0B 
0B2085 2C    0115** DW24  IEQ             ;=
0B2086 24 
0B2087 0B 
0B2088 78    0116** DW24  IMUL            ;*
0B2089 22 
0B208A 0B 
0B208B B3    0117** DW24  IADD            ;+
0B208C 21 
0B208D 0B 
0B208E F5    0118** DW24  IGT             ;>
0B208F 23 
0B2090 0B 
0B2091 9A    0119** DW24  ISUB            ;-
0B2092 21 
0B2093 0B 
0B2094 2F    0120** DW24  IPOW            ;^
0B2095 23 
0B2096 0B 
0B2097 25    0121** DW24  IDIV            ;/
0B2098 22 
0B2099 0B 
             0122** ;
             0123** FTABLE:
0B209A 3E    0124** DW24  ABSV_FP            ;ABS
0B209B 24 
0B209C 0B 
0B209D 24    0125** DW24  ACS_FP             ;ACS
0B209E 28 
0B209F 0B 
0B20A0 62    0126** DW24  ASN_FP             ;ASN
0B20A1 27 
0B20A2 0B 
0B20A3 92    0127** DW24  ATN_FP             ;ATN
0B20A4 27 
0B20A5 0B 
0B20A6 5D    0128** DW24  COS_FP             ;COS
0B20A7 25 
0B20A8 0B 
0B20A9 6C    0129** DW24  DEG_FP             ;DEG
0B20AA 24 
0B20AB 0B 
0B20AC 19    0130** DW24  EXP_FP             ;EXP
0B20AD 26 
0B20AE 0B 
0B20AF C0    0131** DW24  INT_FP_            ;INT
0B20B0 24 
0B20B1 0B 
0B20B2 B7    0132** DW24  LN_FP              ;LN
0B20B3 26 
0B20B4 0B 
0B20B5 4C    0133** DW24  LOG_FP             ;LOG
0B20B6 27 
0B20B7 0B 
0B20B8 4A    0134** DW24  NOTK_FP            ;NOT
0B20B9 24 
0B20BA 0B 
0B20BB 76    0135** DW24  RAD_FP             ;RAD
0B20BC 24 
0B20BD 0B 
0B20BE 91    0136** DW24  SGN_FP             ;SGN
0B20BF 24 
0B20C0 0B 
0B20C1 6A    0137** DW24  SIN_FP             ;SIN
0B20C2 25 
0B20C3 0B 
0B20C4 D9    0138** DW24  SQR_FP             ;SQR
0B20C5 24 
0B20C6 0B 
0B20C7 37    0139** DW24  TAN_FP             ;TAN
0B20C8 25 
0B20C9 0B 
             0140** ;
0B20CA E7    0141** DW24  ZERO_FP            ;ZERO
0B20CB 2B 
0B20CC 0B 
0B20CD F2    0142** DW24  FONE_FP            ;FONE
0B20CE 25 
0B20CF 0B 
0B20D0 31    0143** DW24  TRUE_FP            ;TRUE
0B20D1 24 
0B20D2 0B 
0B20D3 5E    0144** DW24  PI_FP              ;PI
0B20D4 24 
0B20D5 0B 
             0145** ;
0B20D6 A5    0146** DW24  VAL_FP             ;VAL
0B20D7 24 
0B20D8 0B 
0B20D9 2D    0147** DW24  STR_FP             ;STR$
0B20DA 28 
0B20DB 0B 
             0148** ;
0B20DC 8E    0149** DW24  SFIX_FP            ;FIX
0B20DD 2A 
0B20DE 0B 
0B20DF 6A    0150** DW24  SFLOAT_FP          ;FLOAT
0B20E0 2B 
0B20E1 0B 
             0151** ;
0B20E2 B8    0152** DW24  FTEST_FP           ;TEST
0B20E3 2B 
0B20E4 0B 
0B20E5 CA    0153** DW24  FCOMP_FP           ;COMPARE
0B20E6 2B 
0B20E7 0B 
             0154** ;
0B20E8 18    0155** RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B20E9 21 
0B20EA 0B 
0B20EB 86    0156** DW24  FBDIV           ;DIV
0B20EC 21 
0B20ED 0B 
0B20EE 2B    0157** DW24  FEOR            ;EOR
0B20EF 21 
0B20F0 0B 
0B20F1 51    0158** DW24  FMOD            ;MOD
0B20F2 21 
0B20F3 0B 
0B20F4 3E    0159** DW24  FFOR             ;OR
0B20F5 21 
0B20F6 0B 
0B20F7 0A    0160** DW24  FLE             ;<=
0B20F8 24 
0B20F9 0B 
0B20FA 19    0161** DW24  FNE             ;<>
0B20FB 24 
0B20FC 0B 
0B20FD FD    0162** DW24  FGE             ;>=
0B20FE 23 
0B20FF 0B 
0B2100 E2    0163** DW24  FLT             ;<
0B2101 23 
0B2102 0B 
0B2103 26    0164** DW24  FEQ             ;=
0B2104 24 
0B2105 0B 
0B2106 D2    0165** DW24  FMUL            ;*
0B2107 22 
0B2108 0B 
0B2109 C0    0166** DW24  FADD            ;+
0B210A 21 
0B210B 0B 
0B210C EF    0167** DW24  FGT             ;>
0B210D 23 
0B210E 0B 
0B210F A7    0168** DW24  FSUB            ;-
0B2110 21 
0B2111 0B 
0B2112 AF    0169** DW24  FPOW            ;^
0B2113 23 
0B2114 0B 
0B2115 29    0170** DW24  FDIV            ;/
0B2116 22 
0B2117 0B 
             0171** ;
             0172** ;       PAGE
             0173** ;
             0174** ;ARITHMETIC AND LOGICAL OPERATORS:
             0175** ;All take two arguments, in HLH'L'C & DED'E'B.
             0176** ;Output in HLH'L'C
             0177** ;All registers except IX, IY destroyed.
             0178** ; (N.B. FPOW destroys IX).
             0179** ;
             0180** ;FAND - Floating-point AND.
             0181** ;IAND - Integer AND.
             0182** ;
0B2118 CD    0183** FAND:			CALL    FIX2
0B2119 82 
0B211A 2A 
0B211B 0B 
0B211C 7C    0184** IAND:			LD      A,H
0B211D A2    0185** AND     D
0B211E 67    0186** LD      H,A
0B211F 7D    0187** LD      A,L
0B2120 A3    0188** AND     E
0B2121 6F    0189** LD      L,A
0B2122 D9    0190** EXX
0B2123 7C    0191** LD      A,H
0B2124 A2    0192** AND     D
0B2125 67    0193** LD      H,A
0B2126 7D    0194** LD      A,L
0B2127 A3    0195** AND     E
0B2128 6F    0196** LD      L,A
0B2129 D9    0197** EXX
0B212A C9    0198** RET
             0199** ;
             0200** ;FEOR - Floating-point exclusive-OR.
             0201** ;IEOR - Integer exclusive-OR.
             0202** ;
0B212B CD    0203** FEOR:			CALL    FIX2
0B212C 82 
0B212D 2A 
0B212E 0B 
0B212F 7C    0204** IEOR:			LD      A,H
0B2130 AA    0205** XOR     D
0B2131 67    0206** LD      H,A
0B2132 7D    0207** LD      A,L
0B2133 AB    0208** XOR     E
0B2134 6F    0209** LD      L,A
0B2135 D9    0210** EXX
0B2136 7C    0211** LD      A,H
0B2137 AA    0212** XOR     D
0B2138 67    0213** LD      H,A
0B2139 7D    0214** LD      A,L
0B213A AB    0215** XOR     E
0B213B 6F    0216** LD      L,A
0B213C D9    0217** EXX
0B213D C9    0218** RET
             0219** ;
             0220** ;FOR - Floating-point OR.
             0221** ;IOR - Integer OR.
             0222** ;
0B213E CD    0223** FFOR:			CALL    FIX2
0B213F 82 
0B2140 2A 
0B2141 0B 
0B2142 7C    0224** IOR:			LD      A,H
0B2143 B2    0225** OR      D
0B2144 67    0226** LD      H,A
0B2145 7D    0227** LD      A,L
0B2146 B3    0228** OR      E
0B2147 6F    0229** LD      L,A
0B2148 D9    0230** EXX
0B2149 7C    0231** LD      A,H
0B214A B2    0232** OR      D
0B214B 67    0233** LD      H,A
0B214C 7D    0234** LD      A,L
0B214D B3    0235** OR      E
0B214E 6F    0236** LD      L,A
0B214F D9    0237** EXX
0B2150 C9    0238** RET
             0239** ;
             0240** ;FMOD - Floating-point remainder.
             0241** ;IMOD - Integer remainder.
             0242** ;
0B2151 CD    0243** FMOD:			CALL    FIX2
0B2152 82 
0B2153 2A 
0B2154 0B 
0B2155 7C    0244** IMOD:			LD      A,H
0B2156 AA    0245** XOR     D               ;DIV RESULT SIGN
0B2157 CB    0246** BIT     7,H
0B2158 7C 
0B2159 08    0247** EX      AF,AF'
0B215A CB    0248** BIT     7,H
0B215B 7C 
0B215C C4    0249** CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B215D 9E 
0B215E 2A 
0B215F 0B 
0B2160 CD    0250** CALL    SWAP_FP
0B2161 9B 
0B2162 2B 
0B2163 0B 
0B2164 CB    0251** BIT     7,H
0B2165 7C 
0B2166 C4    0252** CALL    NZ,NEGATE
0B2167 9E 
0B2168 2A 
0B2169 0B 
0B216A 44    0253** LD      B,H
0B216B 4D    0254** LD      C,L
0B216C 21    0255** LD      HL,0
0B216D 00 
0B216E 00 
0B216F 00 
0B2170 D9    0256** EXX
0B2171 44    0257** LD      B,H
0B2172 4D    0258** LD      C,L
0B2173 21    0259** LD      HL,0
0B2174 00 
0B2175 00 
0B2176 00 
0B2177 3E    0260** LD      A,-33
0B2178 DF 
0B2179 CD    0261** CALL    DIVA            ;DIVIDE
0B217A 28 
0B217B 2D 
0B217C 0B 
0B217D D9    0262** EXX
0B217E 0E    0263** LD      C,0             ;INTEGER MARKER
0B217F 00 
0B2180 08    0264** EX      AF,AF'
0B2181 C8    0265** RET     Z
0B2182 C3    0266** JP      NEGATE
0B2183 9E 
0B2184 2A 
0B2185 0B 
             0267** ;
             0268** ;BDIV - Integer division.
             0269** ;
0B2186 CD    0270** FBDIV:			CALL    FIX2
0B2187 82 
0B2188 2A 
0B2189 0B 
0B218A CD    0271** IBDIV:			CALL    IMOD
0B218B 55 
0B218C 21 
0B218D 0B 
0B218E B7    0272** OR      A
0B218F CD    0273** CALL    SWAP_FP
0B2190 9B 
0B2191 2B 
0B2192 0B 
0B2193 0E    0274** LD      C,0
0B2194 00 
0B2195 F0    0275** RET     P
0B2196 C3    0276** JP      NEGATE
0B2197 9E 
0B2198 2A 
0B2199 0B 
             0277** ;
             0278** ;ISUB - Integer subtraction.
             0279** ;FSUB - Floating point subtraction with rounding.
             0280** ;
0B219A CD    0281** ISUB:			CALL    SUB_
0B219B 36 
0B219C 2C 
0B219D 0B 
0B219E E0    0282** RET     PO
0B219F CD    0283** CALL    ADD_
0B21A0 2E 
0B21A1 2C 
0B21A2 0B 
0B21A3 CD    0284** CALL    FLOAT2
0B21A4 5E 
0B21A5 2B 
0B21A6 0B 
0B21A7 7A    0285** FSUB:			LD      A,D
0B21A8 EE    0286** XOR     80H             ;CHANGE SIGN THEN ADD
0B21A9 80 
0B21AA 57    0287** LD      D,A
0B21AB 18    0288** JR      FADD
0B21AC 13 
             0289** ;
             0290** ;Reverse subtract.
             0291** ;
0B21AD 7C    0292** RSUB:			LD      A,H
0B21AE EE    0293** XOR     80H
0B21AF 80 
0B21B0 67    0294** LD      H,A
0B21B1 18    0295** JR      FADD
0B21B2 0D 
             0296** ;
             0297** ;IADD - Integer addition.
             0298** ;FADD - Floating point addition with rounding.
             0299** ;
0B21B3 CD    0300** IADD:			CALL    ADD_
0B21B4 2E 
0B21B5 2C 
0B21B6 0B 
0B21B7 E0    0301** RET     PO
0B21B8 CD    0302** CALL    SUB_
0B21B9 36 
0B21BA 2C 
0B21BB 0B 
0B21BC CD    0303** CALL    FLOAT2
0B21BD 5E 
0B21BE 2B 
0B21BF 0B 
0B21C0 05    0304** FADD:			DEC     B
0B21C1 04    0305** INC     B
0B21C2 C8    0306** RET     Z               ;ARG 2 ZERO
0B21C3 0D    0307** DEC     C
0B21C4 0C    0308** INC     C
0B21C5 CA    0309** JP      Z,SWAP_FP          ;ARG 1 ZERO
0B21C6 9B 
0B21C7 2B 
0B21C8 0B 
0B21C9 D9    0310** EXX
0B21CA 01    0311** LD      BC,0            ;INITIALISE
0B21CB 00 
0B21CC 00 
0B21CD 00 
0B21CE D9    0312** EXX
0B21CF 7C    0313** LD      A,H
0B21D0 AA    0314** XOR     D               ;XOR SIGNS
0B21D1 F5    0315** PUSH    AF
0B21D2 78    0316** LD      A,B
0B21D3 B9    0317** CP      C               ;COMPARE EXPONENTS
0B21D4 DC    0318** CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B21D5 9B 
0B21D6 2B 
0B21D7 0B 
0B21D8 78    0319** LD      A,B
0B21D9 CB    0320** SET     7,H             ;IMPLIED 1
0B21DA FC 
0B21DB C4    0321** CALL    NZ,FIX          ;ALIGN
0B21DC 6F 
0B21DD 2A 
0B21DE 0B 
0B21DF F1    0322** POP     AF
0B21E0 7A    0323** LD      A,D             ;SIGN OF LARGER
0B21E1 CB    0324** SET     7,D             ;IMPLIED 1
0B21E2 FA 
0B21E3 FA    0325** JP      M,FADD3         ;SIGNS DIFFERENT
0B21E4 F3 
0B21E5 21 
0B21E6 0B 
0B21E7 CD    0326** CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B21E8 2E 
0B21E9 2C 
0B21EA 0B 
0B21EB DC    0327** CALL    C,DIV2          ;NORMALISE
0B21EC A3 
0B21ED 2B 
0B21EE 0B 
0B21EF CB    0328** SET     7,H
0B21F0 FC 
0B21F1 18    0329** JR      FADD4
0B21F2 0D 
             0330** ;
0B21F3 CD    0331** FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B21F4 36 
0B21F5 2C 
0B21F6 0B 
0B21F7 DC    0332** CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B21F8 B6 
0B21F9 2A 
0B21FA 0B 
0B21FB CD    0333** CALL    FLO48
0B21FC 35 
0B21FD 2B 
0B21FE 0B 
0B21FF 2F    0334** CPL                     ;CHANGE RESULT SIGN
0B2200 D9    0335** FADD4:			EXX
0B2201 EB    0336** EX      DE,HL
0B2202 21    0337** LD      HL,8000H
0B2203 00 
0B2204 80 
0B2205 00 
0B2206 B7    0338** OR      A               ;CLEAR CARRY
0B2207 52    0339** SBC.S   HL,BC
0B2208 ED 
0B2209 42 
0B220A EB    0340** EX      DE,HL
0B220B D9    0341** EXX
0B220C CC    0342** CALL    Z,ODD           ;ROUND UNBIASSED
0B220D 95 
0B220E 2B 
0B220F 0B 
0B2210 DC    0343** CALL    C,ADD1_FP          ;ROUND UP
0B2211 83 
0B2212 2B 
0B2213 0B 
0B2214 DC    0344** CALL    C,INCC
0B2215 B0 
0B2216 2B 
0B2217 0B 
0B2218 CB    0345** RES     7,H
0B2219 BC 
0B221A 0D    0346** DEC     C
0B221B 0C    0347** INC     C
0B221C CA    0348** JP      Z,ZERO_FP
0B221D E7 
0B221E 2B 
0B221F 0B 
0B2220 B7    0349** OR      A               ;RESULT SIGNQ
0B2221 F0    0350** RET     P               ;POSITIVE
0B2222 CB    0351** SET     7,H             ;NEGATIVE
0B2223 FC 
0B2224 C9    0352** RET
             0353** ;
             0354** ;IDIV - Integer division.
             0355** ;FDIV - Floating point division with rounding.
             0356** ;
0B2225 CD    0357** IDIV:			CALL    FLOAT2
0B2226 5E 
0B2227 2B 
0B2228 0B 
0B2229 05    0358** FDIV:			DEC     B               ;TEST FOR ZERO
0B222A 04    0359** INC     B
0B222B 3E    0360** LD      A,DIVBY0
0B222C 12 
0B222D CA    0361** JP      Z,ERROR_FP_         ;"Division by zero"
0B222E 41 
0B222F 20 
0B2230 0B 
0B2231 0D    0362** DEC     C               ;TEST FOR ZERO
0B2232 0C    0363** INC     C
0B2233 C8    0364** RET     Z
0B2234 7C    0365** LD      A,H
0B2235 AA    0366** XOR     D               ;CALC. RESULT SIGN
0B2236 08    0367** EX      AF,AF'          ;SAVE SIGN
0B2237 CB    0368** SET     7,D             ;REPLACE IMPLIED 1's
0B2238 FA 
0B2239 CB    0369** SET     7,H
0B223A FC 
0B223B C5    0370** PUSH    BC              ;SAVE EXPONENTS
0B223C 42    0371** LD      B,D             ;LOAD REGISTERS
0B223D 4B    0372** LD      C,E
0B223E 11    0373** LD      DE,0
0B223F 00 
0B2240 00 
0B2241 00 
0B2242 D9    0374** EXX
0B2243 42    0375** LD      B,D
0B2244 4B    0376** LD      C,E
0B2245 11    0377** LD      DE,0
0B2246 00 
0B2247 00 
0B2248 00 
0B2249 3E    0378** LD      A,-32           ;LOOP COUNTER
0B224A E0 
0B224B CD    0379** CALL    DIVA            ;DIVIDE
0B224C 28 
0B224D 2D 
0B224E 0B 
0B224F D9    0380** EXX
0B2250 CB    0381** BIT     7,D
0B2251 7A 
0B2252 D9    0382** EXX
0B2253 CC    0383** CALL    Z,DIVB          ;NORMALISE & INC A
0B2254 47 
0B2255 2D 
0B2256 0B 
0B2257 EB    0384** EX      DE,HL
0B2258 D9    0385** EXX
0B2259 CB    0386** SRL     B               ;DIVISOR/2
0B225A 38 
0B225B CB    0387** RR      C
0B225C 19 
0B225D B7    0388** OR      A               ;CLEAR CARRY
0B225E 52    0389** SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B225F ED 
0B2260 42 
0B2261 3F    0390** CCF
0B2262 EB    0391** EX      DE,HL           ;RESULT IN HLH'L'
0B2263 CC    0392** CALL    Z,ODD           ;ROUND UNBIASSED
0B2264 95 
0B2265 2B 
0B2266 0B 
0B2267 DC    0393** CALL    C,ADD1_FP          ;ROUND UP
0B2268 83 
0B2269 2B 
0B226A 0B 
0B226B C1    0394** POP     BC              ;RESTORE EXPONENTS
0B226C DC    0395** CALL    C,INCC
0B226D B0 
0B226E 2B 
0B226F 0B 
0B2270 1F    0396** RRA                     ;LSB OF A TO CARRY
0B2271 79    0397** LD      A,C             ;COMPUTE NEW EXPONENT
0B2272 98    0398** SBC     A,B
0B2273 3F    0399** CCF
0B2274 C3    0400** JP      CHKOVF
0B2275 15 
0B2276 23 
0B2277 0B 
             0401** ;
             0402** ;IMUL - Integer multiplication.
             0403** ;
0B2278 7C    0404** IMUL:			LD      A,H
0B2279 AA    0405** XOR     D
0B227A 08    0406** EX      AF,AF'          ;SAVE RESULT SIGN
0B227B CB    0407** BIT     7,H
0B227C 7C 
0B227D C4    0408** CALL    NZ,NEGATE
0B227E 9E 
0B227F 2A 
0B2280 0B 
0B2281 CD    0409** CALL    SWAP_FP
0B2282 9B 
0B2283 2B 
0B2284 0B 
0B2285 CB    0410** BIT     7,H
0B2286 7C 
0B2287 C4    0411** CALL    NZ,NEGATE
0B2288 9E 
0B2289 2A 
0B228A 0B 
0B228B 44    0412** LD      B,H
0B228C 4D    0413** LD      C,L
0B228D 21    0414** LD      HL,0
0B228E 00 
0B228F 00 
0B2290 00 
0B2291 D9    0415** EXX
0B2292 44    0416** LD      B,H
0B2293 4D    0417** LD      C,L
0B2294 21    0418** LD      HL,0
0B2295 00 
0B2296 00 
0B2297 00 
0B2298 3E    0419** LD      A,-33
0B2299 DF 
0B229A CD    0420** CALL    MULA            ;MULTIPLY
0B229B 5F 
0B229C 2D 
0B229D 0B 
0B229E D9    0421** EXX
0B229F 0E    0422** LD      C,191           ;PRESET EXPONENT
0B22A0 BF 
0B22A1 CD    0423** CALL    TEST_FP            ;TEST RANGE
0B22A2 C3 
0B22A3 2B 
0B22A4 0B 
0B22A5 20    0424** JR      NZ,IMUL1        ;TOO BIG
0B22A6 0F 
0B22A7 CB    0425** BIT     7,D
0B22A8 7A 
0B22A9 20    0426** JR      NZ,IMUL1
0B22AA 0B 
0B22AB CD    0427** CALL    SWAP_FP
0B22AC 9B 
0B22AD 2B 
0B22AE 0B 
0B22AF 4A    0428** LD      C,D             ;INTEGER MARKER
0B22B0 08    0429** EX      AF,AF'
0B22B1 F0    0430** RET     P
0B22B2 C3    0431** JP      NEGATE
0B22B3 9E 
0B22B4 2A 
0B22B5 0B 
             0432** ;
0B22B6 0D    0433** IMUL1:			DEC     C
0B22B7 D9    0434** EXX
0B22B8 CB    0435** SLA     E
0B22B9 23 
0B22BA CB    0436** RL      D
0B22BB 12 
0B22BC D9    0437** EXX
0B22BD CB    0438** RL      E
0B22BE 13 
0B22BF CB    0439** RL      D
0B22C0 12 
0B22C1 D9    0440** EXX
0B22C2 52    0441** ADC.S   HL,HL
0B22C3 ED 
0B22C4 6A 
0B22C5 D9    0442** EXX
0B22C6 52    0443** ADC.S   HL,HL
0B22C7 ED 
0B22C8 6A 
0B22C9 F2    0444** JP      P,IMUL1         ;NORMALISE
0B22CA B6 
0B22CB 22 
0B22CC 0B 
0B22CD 08    0445** EX      AF,AF'
0B22CE F8    0446** RET     M
0B22CF CB    0447** RES     7,H             ;POSITIVE
0B22D0 BC 
0B22D1 C9    0448** RET
             0449** ;
             0450** ;FMUL - Floating point multiplication with rounding.
             0451** ;
0B22D2 05    0452** FMUL:			DEC     B               ;TEST FOR ZERO
0B22D3 04    0453** INC     B
0B22D4 CA    0454** JP      Z,ZERO_FP
0B22D5 E7 
0B22D6 2B 
0B22D7 0B 
0B22D8 0D    0455** DEC     C               ;TEST FOR ZERO
0B22D9 0C    0456** INC     C
0B22DA C8    0457** RET     Z
0B22DB 7C    0458** LD      A,H
0B22DC AA    0459** XOR     D               ;CALC. RESULT SIGN
0B22DD 08    0460** EX      AF,AF'
0B22DE CB    0461** SET     7,D             ;REPLACE IMPLIED 1's
0B22DF FA 
0B22E0 CB    0462** SET     7,H
0B22E1 FC 
0B22E2 C5    0463** PUSH    BC              ;SAVE EXPONENTS
0B22E3 44    0464** LD      B,H             ;LOAD REGISTERS
0B22E4 4D    0465** LD      C,L
0B22E5 21    0466** LD      HL,0
0B22E6 00 
0B22E7 00 
0B22E8 00 
0B22E9 D9    0467** EXX
0B22EA 44    0468** LD      B,H
0B22EB 4D    0469** LD      C,L
0B22EC 21    0470** LD      HL,0
0B22ED 00 
0B22EE 00 
0B22EF 00 
0B22F0 3E    0471** LD      A,-32           ;LOOP COUNTER
0B22F1 E0 
0B22F2 CD    0472** CALL    MULA            ;MULTIPLY
0B22F3 5F 
0B22F4 2D 
0B22F5 0B 
0B22F6 DC    0473** CALL    C,MULB          ;NORMALISE & INC A
0B22F7 75 
0B22F8 2D 
0B22F9 0B 
0B22FA D9    0474** EXX
0B22FB E5    0475** PUSH    HL
0B22FC 21    0476** LD      HL,8000H
0B22FD 00 
0B22FE 80 
0B22FF 00 
0B2300 B7    0477** OR      A               ;CLEAR CARRY
0B2301 52    0478** SBC.S   HL,DE
0B2302 ED 
0B2303 52 
0B2304 E1    0479** POP     HL
0B2305 CC    0480** CALL    Z,ODD           ;ROUND UNBIASSED
0B2306 95 
0B2307 2B 
0B2308 0B 
0B2309 DC    0481** CALL    C,ADD1_FP          ;ROUND UP
0B230A 83 
0B230B 2B 
0B230C 0B 
0B230D C1    0482** POP     BC              ;RESTORE EXPONENTS
0B230E DC    0483** CALL    C,INCC
0B230F B0 
0B2310 2B 
0B2311 0B 
0B2312 1F    0484** RRA                     ;LSB OF A TO CARRY
0B2313 79    0485** LD      A,C             ;COMPUTE NEW EXPONENT
0B2314 88    0486** ADC     A,B
0B2315 38    0487** CHKOVF:			JR      C,CHKO1
0B2316 06 
0B2317 F2    0488** JP      P,ZERO_FP          ;UNDERFLOW
0B2318 E7 
0B2319 2B 
0B231A 0B 
0B231B 18    0489** JR      CHKO2
0B231C 04 
0B231D FA    0490** CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B231E B2 
0B231F 2B 
0B2320 0B 
0B2321 C6    0491** CHKO2:			ADD     A,80H
0B2322 80 
0B2323 4F    0492** LD      C,A
0B2324 CA    0493** JP      Z,ZERO_FP
0B2325 E7 
0B2326 2B 
0B2327 0B 
0B2328 08    0494** EX      AF,AF'          ;RESTORE SIGN BIT
0B2329 CB    0495** RES     7,H
0B232A BC 
0B232B F0    0496** RET     P
0B232C CB    0497** SET     7,H
0B232D FC 
0B232E C9    0498** RET
             0499** ;
             0500** ;IPOW - Integer involution.
             0501** ;
0B232F CD    0502** IPOW:			CALL    SWAP_FP
0B2330 9B 
0B2331 2B 
0B2332 0B 
0B2333 CB    0503** BIT     7,H
0B2334 7C 
0B2335 F5    0504** PUSH    AF              ;SAVE SIGN
0B2336 C4    0505** CALL    NZ,NEGATE
0B2337 9E 
0B2338 2A 
0B2339 0B 
0B233A 48    0506** IPOW0:			LD      C,B
0B233B 06    0507** LD      B,32            ;LOOP COUNTER
0B233C 20 
0B233D CD    0508** IPOW1:			CALL    X2
0B233E 53 
0B233F 2C 
0B2340 0B 
0B2341 38    0509** JR      C,IPOW2
0B2342 08 
0B2343 10    0510** DJNZ    IPOW1
0B2344 F8 
0B2345 F1    0511** POP     AF
0B2346 D9    0512** EXX
0B2347 2C    0513** INC     L               ;RESULT=1
0B2348 D9    0514** EXX
0B2349 4C    0515** LD      C,H
0B234A C9    0516** RET
             0517** ;
0B234B F1    0518** IPOW2:			POP     AF
0B234C C5    0519** PUSH    BC
0B234D EB    0520** EX      DE,HL
0B234E E5    0521** PUSH    HL
0B234F D9    0522** EXX
0B2350 EB    0523** EX      DE,HL
0B2351 E5    0524** PUSH    HL
0B2352 D9    0525** EXX
0B2353 DD    0526** LD      IX,0
0B2354 21 
0B2355 00 
0B2356 00 
0B2356 00   
0B2358 DD    0527** ADD     IX,SP
0B2359 39 
0B235A 28    0528** JR      Z,IPOW4
0B235B 48 
0B235C C5    0529** PUSH    BC
0B235D D9    0530** EXX
0B235E D5    0531** PUSH    DE
0B235F D9    0532** EXX
0B2360 D5    0533** PUSH    DE
0B2361 CD    0534** CALL    SFLOAT_FP
0B2362 6A 
0B2363 2B 
0B2364 0B 
0B2365 CD    0535** CALL    RECIP
0B2366 9E 
0B2367 26 
0B2368 0B 
0B2369 DD    0536** LD      (IX+4),C
0B236A 71 
0B236B 04 
0B236C D9    0537** EXX
0B236D DD    0538** LD      (IX+0),L
0B236E 75 
0B236F 00 
0B2370 DD    0539** LD      (IX+1),H
0B2371 74 
0B2372 01 
0B2373 D9    0540** EXX
0B2374 DD    0541** LD      (IX+2),L
0B2375 75 
0B2376 02 
0B2377 DD    0542** LD      (IX+3),H
0B2378 74 
0B2379 03 
0B237A 18    0543** JR      IPOW5
0B237B 21 
             0544** ;
0B237C C5    0545** IPOW3:			PUSH    BC
0B237D D9    0546** EXX
0B237E CB    0547** SLA     E
0B237F 23 
0B2380 CB    0548** RL      D
0B2381 12 
0B2382 D5    0549** PUSH    DE
0B2383 D9    0550** EXX
0B2384 CB    0551** RL      E
0B2385 13 
0B2386 CB    0552** RL      D
0B2387 12 
0B2388 D5    0553** PUSH    DE
0B2389 3E    0554** LD      A,'*' & 0FH
0B238A 0A 
0B238B F5    0555** PUSH    AF
0B238C CD    0556** CALL    COPY_
0B238D 67 
0B238E 2C 
0B238F 0B 
0B2390 CD    0557** CALL    OP              ;SQUARE
0B2391 47 
0B2392 20 
0B2393 0B 
0B2394 F1    0558** POP     AF
0B2395 CD    0559** CALL    DLOAD5
0B2396 93 
0B2397 29 
0B2398 0B 
0B2399 DC    0560** CALL    C,OP            ;MULTIPLY BY X
0B239A 47 
0B239B 20 
0B239C 0B 
0B239D D1    0561** IPOW5:			POP     DE
0B239E D9    0562** EXX
0B239F D1    0563** POP     DE
0B23A0 D9    0564** EXX
0B23A1 79    0565** LD      A,C
0B23A2 C1    0566** POP     BC
0B23A3 4F    0567** LD      C,A
0B23A4 10    0568** IPOW4:			DJNZ    IPOW3
0B23A5 D6 
0B23A6 F1    0569** POP     AF
0B23A7 F1    0570** POP     AF
0B23A8 F1    0571** POP     AF
0B23A9 C9    0572** RET
             0573** ;
0B23AA F1    0574** FPOW0:			POP     AF
0B23AB F1    0575** POP     AF
0B23AC F1    0576** POP     AF
0B23AD 18    0577** JR      IPOW0
0B23AE 8B 
             0578** ;
             0579** ;FPOW - Floating-point involution.
             0580** ;
0B23AF CB    0581** FPOW:			BIT     7,D
0B23B0 7A 
0B23B1 F5    0582** PUSH    AF
0B23B2 CD    0583** CALL    SWAP_FP
0B23B3 9B 
0B23B4 2B 
0B23B5 0B 
0B23B6 CD    0584** CALL    PUSH5
0B23B7 77 
0B23B8 2C 
0B23B9 0B 
0B23BA 0D    0585** DEC     C
0B23BB 0C    0586** INC     C
0B23BC 28    0587** JR      Z,FPOW0
0B23BD EC 
0B23BE 3E    0588** LD      A,158
0B23BF 9E 
0B23C0 B9    0589** CP      C
0B23C1 38    0590** JR      C,FPOW1
0B23C2 0A 
0B23C3 3C    0591** INC     A
0B23C4 CD    0592** CALL    FIX
0B23C5 6F 
0B23C6 2A 
0B23C7 0B 
0B23C8 08    0593** EX      AF,AF'
0B23C9 F2    0594** JP      P,FPOW0
0B23CA AA 
0B23CB 23 
0B23CC 0B 
0B23CD CD    0595** FPOW1:			CALL    SWAP_FP
0B23CE 9B 
0B23CF 2B 
0B23D0 0B 
0B23D1 CD    0596** CALL    LN0
0B23D2 BB 
0B23D3 26 
0B23D4 0B 
0B23D5 CD    0597** CALL    POP5
0B23D6 80 
0B23D7 2C 
0B23D8 0B 
0B23D9 F1    0598** POP     AF
0B23DA CD    0599** CALL    FMUL
0B23DB D2 
0B23DC 22 
0B23DD 0B 
0B23DE C3    0600** JP      EXP0
0B23DF 1D 
0B23E0 26 
0B23E1 0B 
             0601** ;
             0602** ;Integer and floating-point compare.
             0603** ;Result is TRUE (-1) or FALSE (0).
             0604** ;
0B23E2 CD    0605** FLT:			CALL    FCP
0B23E3 F1 
0B23E4 2B 
0B23E5 0B 
0B23E6 18    0606** JR      ILT1
0B23E7 04 
0B23E8 CD    0607** ILT:			CALL    ICP
0B23E9 E3 
0B23EA 2B 
0B23EB 0B 
0B23EC D0    0608** ILT1:			RET     NC
0B23ED 18    0609** JR      TRUE_FP
0B23EE 42 
             0610** ;
0B23EF CD    0611** FGT:			CALL    FCP
0B23F0 F1 
0B23F1 2B 
0B23F2 0B 
0B23F3 18    0612** JR      IGT1
0B23F4 04 
0B23F5 CD    0613** IGT:			CALL    ICP
0B23F6 E3 
0B23F7 2B 
0B23F8 0B 
0B23F9 C8    0614** IGT1:			RET     Z
0B23FA D8    0615** RET     C
0B23FB 18    0616** JR      TRUE_FP
0B23FC 34 
             0617** ;
0B23FD CD    0618** FGE:			CALL    FCP
0B23FE F1 
0B23FF 2B 
0B2400 0B 
0B2401 18    0619** JR      IGE1
0B2402 04 
0B2403 CD    0620** IGE:			CALL    ICP
0B2404 E3 
0B2405 2B 
0B2406 0B 
0B2407 D8    0621** IGE1:			RET     C
0B2408 18    0622** JR      TRUE_FP
0B2409 27 
             0623** ;
0B240A CD    0624** FLE:			CALL    FCP
0B240B F1 
0B240C 2B 
0B240D 0B 
0B240E 18    0625** JR      ILE1
0B240F 04 
0B2410 CD    0626** ILE:			CALL    ICP
0B2411 E3 
0B2412 2B 
0B2413 0B 
0B2414 28    0627** ILE1:			JR      Z,TRUE_FP
0B2415 1B 
0B2416 D0    0628** RET     NC
0B2417 18    0629** JR      TRUE_FP
0B2418 18 
             0630** ;
0B2419 CD    0631** FNE:			CALL    FCP
0B241A F1 
0B241B 2B 
0B241C 0B 
0B241D 18    0632** JR      INE1
0B241E 04 
0B241F CD    0633** INE:			CALL    ICP
0B2420 E3 
0B2421 2B 
0B2422 0B 
0B2423 C8    0634** INE1:			RET     Z
0B2424 18    0635** JR      TRUE_FP
0B2425 0B 
             0636** ;
0B2426 CD    0637** FEQ:			CALL    FCP
0B2427 F1 
0B2428 2B 
0B2429 0B 
0B242A 18    0638** JR      IEQ1
0B242B 04 
0B242C CD    0639** IEQ:			CALL    ICP
0B242D E3 
0B242E 2B 
0B242F 0B 
0B2430 C0    0640** IEQ1:			RET     NZ
0B2431 21    0641** TRUE_FP:			LD      HL,-1
0B2432 FF 
0B2433 FF 
0B2434 FF 
0B2435 D9    0642** EXX
0B2436 21    0643** LD      HL,-1
0B2437 FF 
0B2438 FF 
0B2439 FF 
0B243A D9    0644** EXX
0B243B AF    0645** XOR     A
0B243C 4F    0646** LD      C,A
0B243D C9    0647** RET
             0648** ;
             0649** ;FUNCTIONS:
             0650** ;
             0651** ;Result returned in HLH'L'C (floating point)
             0652** ;Result returned in HLH'L' (C=0) (integer)
             0653** ;All registers except IY destroyed.
             0654** ;
             0655** ;ABS - Absolute value
             0656** ;Result is numeric, variable type.
             0657** ;
0B243E CB    0658** ABSV_FP:			BIT     7,H
0B243F 7C 
0B2440 C8    0659** RET     Z               ;POSITIVE/ZERO
0B2441 0D    0660** DEC     C
0B2442 0C    0661** INC     C
0B2443 CA    0662** JP      Z,NEGATE        ;INTEGER
0B2444 9E 
0B2445 2A 
0B2446 0B 
0B2447 CB    0663** RES     7,H
0B2448 BC 
0B2449 C9    0664** RET
             0665** ;
             0666** ;NOT - Complement integer.
             0667** ;Result is integer numeric.
             0668** ;
0B244A CD    0669** NOTK_FP:			CALL    SFIX_FP
0B244B 8E 
0B244C 2A 
0B244D 0B 
0B244E 7C    0670** LD      A,H
0B244F 2F    0671** CPL
0B2450 67    0672** LD      H,A
0B2451 7D    0673** LD      A,L
0B2452 2F    0674** CPL
0B2453 6F    0675** LD      L,A
0B2454 D9    0676** EXX
0B2455 7C    0677** LD      A,H
0B2456 2F    0678** CPL
0B2457 67    0679** LD      H,A
0B2458 7D    0680** LD      A,L
0B2459 2F    0681** CPL
0B245A 6F    0682** LD      L,A
0B245B D9    0683** EXX
0B245C AF    0684** XOR     A               ;NUMERIC MARKER
0B245D C9    0685** RET
             0686** ;
             0687** ;PI - Return PI (3.141592654)
             0688** ;Result is floating-point numeric.
             0689** ;
0B245E 21    0690** PI_FP:			LD      HL,490FH
0B245F 0F 
0B2460 49 
0B2461 00 
0B2462 D9    0691** EXX
0B2463 21    0692** LD      HL,0DAA2H
0B2464 A2 
0B2465 DA 
0B2466 00 
0B2467 D9    0693** EXX
0B2468 0E    0694** LD      C,81H
0B2469 81 
0B246A AF    0695** XOR     A               ;NUMERIC MARKER
0B246B C9    0696** RET
             0697** ;
             0698** ;DEG - Convert radians to degrees
             0699** ;Result is floating-point numeric.
             0700** ;
0B246C CD    0701** DEG_FP:			CALL    FPI180
0B246D 80 
0B246E 24 
0B246F 0B 
0B2470 CD    0702** CALL    FMUL
0B2471 D2 
0B2472 22 
0B2473 0B 
0B2474 AF    0703** XOR     A
0B2475 C9    0704** RET
             0705** ;
             0706** ;RAD - Convert degrees to radians
             0707** ;Result is floating-point numeric.
             0708** ;
0B2476 CD    0709** RAD_FP:			CALL    FPI180
0B2477 80 
0B2478 24 
0B2479 0B 
0B247A CD    0710** CALL    FDIV
0B247B 29 
0B247C 22 
0B247D 0B 
0B247E AF    0711** XOR     A
0B247F C9    0712** RET
             0713** ;
             0714** ;180/PI
             0715** ;
0B2480 CD    0716** FPI180:			CALL    SFLOAT_FP
0B2481 6A 
0B2482 2B 
0B2483 0B 
0B2484 11    0717** LD      DE,652EH
0B2485 2E 
0B2486 65 
0B2487 00 
0B2488 D9    0718** EXX
0B2489 11    0719** LD      DE,0E0D3H
0B248A D3 
0B248B E0 
0B248C 00 
0B248D D9    0720** EXX
0B248E 06    0721** LD      B,85H
0B248F 85 
0B2490 C9    0722** RET
             0723** ;
             0724** ;SGN - Return -1, 0 or +1
             0725** ;Result is integer numeric.
             0726** ;
0B2491 CD    0727** SGN_FP:			CALL    TEST_FP
0B2492 C3 
0B2493 2B 
0B2494 0B 
0B2495 B1    0728** OR      C
0B2496 C8    0729** RET     Z               ;ZERO
0B2497 CB    0730** BIT     7,H
0B2498 7C 
0B2499 C2    0731** JP      NZ,TRUE_FP         ;-1
0B249A 31 
0B249B 24 
0B249C 0B 
0B249D CD    0732** CALL    ZERO_FP
0B249E E7 
0B249F 2B 
0B24A0 0B 
0B24A1 C3    0733** JP      ADD1_FP            ;1
0B24A2 83 
0B24A3 2B 
0B24A4 0B 
             0734** ;
             0735** ;VAL - Return numeric value of string.
             0736** ;Input: ASCII string at IX
             0737** ;Result is variable type numeric.
             0738** ;
0B24A5 CD    0739** VAL_FP:			CALL    SIGNQ
0B24A6 01 
0B24A7 2E 
0B24A8 0B 
0B24A9 F5    0740** PUSH    AF
0B24AA CD    0741** CALL    CON_FP
0B24AB B1 
0B24AC 29 
0B24AD 0B 
0B24AE F1    0742** POP     AF
0B24AF FE    0743** CP      '-'
0B24B0 2D 
0B24B1 3E    0744** LD      A,0             ;NUMERIC MARKER
0B24B2 00 
0B24B3 C0    0745** RET     NZ
0B24B4 0D    0746** DEC     C
0B24B5 0C    0747** INC     C
0B24B6 CA    0748** JP      Z,NEGATE        ;ZERO/INTEGER
0B24B7 9E 
0B24B8 2A 
0B24B9 0B 
0B24BA 7C    0749** LD      A,H
0B24BB EE    0750** XOR     80H             ;CHANGE SIGN (FP)
0B24BC 80 
0B24BD 67    0751** LD      H,A
0B24BE AF    0752** XOR     A
0B24BF C9    0753** RET
             0754** ;
             0755** ;INT - Floor function
             0756** ;Result is integer numeric.
             0757** ;
0B24C0 0D    0758** INT_FP_:			DEC     C
0B24C1 0C    0759** INC     C
0B24C2 C8    0760** RET     Z               ;ZERO/INTEGER
0B24C3 3E    0761** LD      A,159
0B24C4 9F 
0B24C5 44    0762** LD      B,H             ;B7=SIGN BIT
0B24C6 CD    0763** CALL    FIX
0B24C7 6F 
0B24C8 2A 
0B24C9 0B 
0B24CA 08    0764** EX      AF,AF'
0B24CB A0    0765** AND     B
0B24CC FC    0766** CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B24CD 83 
0B24CE 2B 
0B24CF 0B 
0B24D0 78    0767** LD      A,B
0B24D1 B7    0768** OR      A
0B24D2 FC    0769** CALL    M,NEGATE
0B24D3 9E 
0B24D4 2A 
0B24D5 0B 
0B24D6 AF    0770** XOR     A
0B24D7 4F    0771** LD      C,A
0B24D8 C9    0772** RET
             0773** ;
             0774** ;SQR - square root
             0775** ;Result is floating-point numeric.
             0776** ;
0B24D9 CD    0777** SQR_FP:			CALL    SFLOAT_FP
0B24DA 6A 
0B24DB 2B 
0B24DC 0B 
0B24DD CB    0778** SQR0:			BIT     7,H
0B24DE 7C 
0B24DF 3E    0779** LD      A,NGROOT
0B24E0 15 
0B24E1 C2    0780** JP      NZ,ERROR_FP_        ;"-ve root"
0B24E2 41 
0B24E3 20 
0B24E4 0B 
0B24E5 0D    0781** DEC     C
0B24E6 0C    0782** INC     C
0B24E7 C8    0783** RET     Z               ;ZERO
0B24E8 CB    0784** SET     7,H             ;IMPLIED 1
0B24E9 FC 
0B24EA CB    0785** BIT     0,C
0B24EB 41 
0B24EC CC    0786** CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B24ED A3 
0B24EE 2B 
0B24EF 0B 
0B24F0 79    0787** LD      A,C
0B24F1 D6    0788** SUB     80H
0B24F2 80 
0B24F3 CB    0789** SRA     A               ;HALVE EXPONENT
0B24F4 2F 
0B24F5 C6    0790** ADD     A,80H
0B24F6 80 
0B24F7 4F    0791** LD      C,A
0B24F8 C5    0792** PUSH    BC              ;SAVE EXPONENT
0B24F9 EB    0793** EX      DE,HL
0B24FA 21    0794** LD      HL,0
0B24FB 00 
0B24FC 00 
0B24FD 00 
0B24FE 44    0795** LD      B,H
0B24FF 4D    0796** LD      C,L
0B2500 D9    0797** EXX
0B2501 EB    0798** EX      DE,HL
0B2502 21    0799** LD      HL,0
0B2503 00 
0B2504 00 
0B2505 00 
0B2506 44    0800** LD      B,H
0B2507 4D    0801** LD      C,L
0B2508 3E    0802** LD      A,-31
0B2509 E1 
0B250A CD    0803** CALL    SQRA            ;ROOT
0B250B 99 
0B250C 2D 
0B250D 0B 
0B250E D9    0804** EXX
0B250F CB    0805** BIT     7,B
0B2510 78 
0B2511 D9    0806** EXX
0B2512 CC    0807** CALL    Z,SQRA          ;NORMALISE & INC A
0B2513 99 
0B2514 2D 
0B2515 0B 
0B2516 CD    0808** CALL    SQRB
0B2517 DA 
0B2518 2D 
0B2519 0B 
0B251A B7    0809** OR      A               ;CLEAR CARRY
0B251B CD    0810** CALL    DIVB
0B251C 47 
0B251D 2D 
0B251E 0B 
0B251F CB    0811** RR      E               ;LSB TO CARRY
0B2520 1B 
0B2521 60    0812** LD      H,B
0B2522 69    0813** LD      L,C
0B2523 D9    0814** EXX
0B2524 60    0815** LD      H,B
0B2525 69    0816** LD      L,C
0B2526 DC    0817** CALL    C,ADD1_FP          ;ROUND UP
0B2527 83 
0B2528 2B 
0B2529 0B 
0B252A C1    0818** POP     BC              ;RESTORE EXPONENT
0B252B DC    0819** CALL    C,INCC
0B252C B0 
0B252D 2B 
0B252E 0B 
0B252F 1F    0820** RRA
0B2530 9F    0821** SBC     A,A
0B2531 81    0822** ADD     A,C
0B2532 4F    0823** LD      C,A
0B2533 CB    0824** RES     7,H             ;POSITIVE
0B2534 BC 
0B2535 AF    0825** XOR     A
0B2536 C9    0826** RET
             0827** ;
             0828** ;TAN - Tangent function
             0829** ;Result is floating-point numeric.
             0830** ;
0B2537 CD    0831** TAN_FP:			CALL    SFLOAT_FP
0B2538 6A 
0B2539 2B 
0B253A 0B 
0B253B CD    0832** CALL    PUSH5
0B253C 77 
0B253D 2C 
0B253E 0B 
0B253F CD    0833** CALL    COS0
0B2540 61 
0B2541 25 
0B2542 0B 
0B2543 CD    0834** CALL    POP5
0B2544 80 
0B2545 2C 
0B2546 0B 
0B2547 CD    0835** CALL    PUSH5
0B2548 77 
0B2549 2C 
0B254A 0B 
0B254B CD    0836** CALL    SWAP_FP
0B254C 9B 
0B254D 2B 
0B254E 0B 
0B254F CD    0837** CALL    SIN0
0B2550 6E 
0B2551 25 
0B2552 0B 
0B2553 CD    0838** CALL    POP5
0B2554 80 
0B2555 2C 
0B2556 0B 
0B2557 CD    0839** CALL    FDIV
0B2558 29 
0B2559 22 
0B255A 0B 
0B255B AF    0840** XOR     A               ;NUMERIC MARKER
0B255C C9    0841** RET
             0842** ;
             0843** ;COS - Cosine function
             0844** ;Result is floating-point numeric.
             0845** ;
0B255D CD    0846** COS_FP:			CALL    SFLOAT_FP
0B255E 6A 
0B255F 2B 
0B2560 0B 
0B2561 CD    0847** COS0:			CALL    SCALE
0B2562 C6 
0B2563 2A 
0B2564 0B 
0B2565 1C    0848** INC     E
0B2566 1C    0849** INC     E
0B2567 7B    0850** LD      A,E
0B2568 18    0851** JR      SIN1
0B2569 10 
             0852** ;
             0853** ;SIN - Sine function
             0854** ;Result is floating-point numeric.
             0855** ;
0B256A CD    0856** SIN_FP:			CALL    SFLOAT_FP
0B256B 6A 
0B256C 2B 
0B256D 0B 
0B256E E5    0857** SIN0:			PUSH    HL              ;H7=SIGN
0B256F CD    0858** CALL    SCALE
0B2570 C6 
0B2571 2A 
0B2572 0B 
0B2573 F1    0859** POP     AF
0B2574 07    0860** RLCA
0B2575 07    0861** RLCA
0B2576 07    0862** RLCA
0B2577 E6    0863** AND     4
0B2578 04 
0B2579 AB    0864** XOR     E
0B257A F5    0865** SIN1:			PUSH    AF              ;OCTANT
0B257B CB    0866** RES     7,H
0B257C BC 
0B257D 1F    0867** RRA
0B257E CD    0868** CALL    PIBY4
0B257F 0C 
0B2580 26 
0B2581 0B 
0B2582 DC    0869** CALL    C,RSUB          ;X=(PI/4)-X
0B2583 AD 
0B2584 21 
0B2585 0B 
0B2586 F1    0870** POP     AF
0B2587 F5    0871** PUSH    AF
0B2588 E6    0872** AND     3
0B2589 03 
0B258A E2    0873** JP      PO,SIN2         ;USE COSINE APPROX.
0B258B C3 
0B258C 25 
0B258D 0B 
0B258E CD    0874** CALL    PUSH5           ;SAVE X
0B258F 77 
0B2590 2C 
0B2591 0B 
0B2592 CD    0875** CALL    SQUARE          ;PUSH X*X
0B2593 6F 
0B2594 2C 
0B2595 0B 
0B2596 CD    0876** CALL    POLY
0B2597 B4 
0B2598 2C 
0B2599 0B 
0B259A B7    0877** DW	0A8B7H          ;a(8)
0B259B A8 
0B259C 11    0878** DW	3611H
0B259D 36 
0B259E 6D    0879** DB	6DH
0B259F 26    0880** DW	0DE26H          ;a(6)
0B25A0 DE 
0B25A1 05    0881** DW	0D005H
0B25A2 D0 
0B25A3 73    0882** DB	73H
0B25A4 C0    0883** DW	80C0H           ;a(4)
0B25A5 80 
0B25A6 88    0884** DW	888H
0B25A7 08 
0B25A8 79    0885** DB	79H
0B25A9 9D    0886** DW	0AA9DH          ;a(2)
0B25AA AA 
0B25AB AA    0887** DW	0AAAAH
0B25AC AA 
0B25AD 7D    0888** DB	7DH
0B25AE 00    0889** DW	0               ;a(0)
0B25AF 00 
0B25B0 00    0890** DW	0
0B25B1 00 
0B25B2 80    0891** DB	80H
0B25B3 CD    0892** CALL    POP5
0B25B4 80 
0B25B5 2C 
0B25B6 0B 
0B25B7 CD    0893** CALL    POP5
0B25B8 80 
0B25B9 2C 
0B25BA 0B 
0B25BB CD    0894** CALL    FMUL
0B25BC D2 
0B25BD 22 
0B25BE 0B 
0B25BF C3    0895** JP      SIN3
0B25C0 E8 
0B25C1 25 
0B25C2 0B 
             0896** ;
0B25C3 CD    0897** SIN2:			CALL    SQUARE          ;PUSH X*X
0B25C4 6F 
0B25C5 2C 
0B25C6 0B 
0B25C7 CD    0898** CALL    POLY
0B25C8 B4 
0B25C9 2C 
0B25CA 0B 
0B25CB 71    0899** DW	0D571H          ;b(8)
0B25CC D5 
0B25CD 78    0900** DW	4C78H
0B25CE 4C 
0B25CF 70    0901** DB	70H
0B25D0 AF    0902** DW	94AFH           ;b(6)
0B25D1 94 
0B25D2 03    0903** DW	0B603H
0B25D3 B6 
0B25D4 76    0904** DB	76H
0B25D5 C8    0905** DW	9CC8H           ;b(4)
0B25D6 9C 
0B25D7 AA    0906** DW	2AAAH
0B25D8 2A 
0B25D9 7B    0907** DB	7BH
0B25DA DD    0908** DW	0FFDDH          ;b(2)
0B25DB FF 
0B25DC FF    0909** DW	0FFFFH
0B25DD FF 
0B25DE 7E    0910** DB	7EH
0B25DF 00    0911** DW	0               ;b(0)
0B25E0 00 
0B25E1 00    0912** DW	0
0B25E2 00 
0B25E3 80    0913** DB	80H
0B25E4 CD    0914** CALL    POP5
0B25E5 80 
0B25E6 2C 
0B25E7 0B 
0B25E8 F1    0915** SIN3:			POP     AF
0B25E9 E6    0916** AND     4
0B25EA 04 
0B25EB C8    0917** RET     Z
0B25EC 0D    0918** DEC     C
0B25ED 0C    0919** INC     C
0B25EE C8    0920** RET     Z               ;ZERO
0B25EF CB    0921** SET     7,H             ;MAKE NEGATIVE
0B25F0 FC 
0B25F1 C9    0922** RET
             0923** ;
             0924** ;Floating-point one:
             0925** ;
0B25F2 21    0926** FONE_FP:			LD      HL,0
0B25F3 00 
0B25F4 00 
0B25F5 00 
0B25F6 D9    0927** EXX
0B25F7 21    0928** LD      HL,0
0B25F8 00 
0B25F9 00 
0B25FA 00 
0B25FB D9    0929** EXX
0B25FC 0E    0930** LD      C,80H
0B25FD 80 
0B25FE C9    0931** RET
             0932** ;
0B25FF 11    0933** DONE:			LD      DE,0
0B2600 00 
0B2601 00 
0B2602 00 
0B2603 D9    0934** EXX
0B2604 11    0935** LD      DE,0
0B2605 00 
0B2606 00 
0B2607 00 
0B2608 D9    0936** EXX
0B2609 06    0937** LD      B,80H
0B260A 80 
0B260B C9    0938** RET
             0939** ;
0B260C 11    0940** PIBY4:			LD      DE,490FH
0B260D 0F 
0B260E 49 
0B260F 00 
0B2610 D9    0941** EXX
0B2611 11    0942** LD      DE,0DAA2H
0B2612 A2 
0B2613 DA 
0B2614 00 
0B2615 D9    0943** EXX
0B2616 06    0944** LD      B,7FH
0B2617 7F 
0B2618 C9    0945** RET
             0946** ;
             0947** ;EXP - Exponential function
             0948** ;Result is floating-point numeric.
             0949** ;
0B2619 CD    0950** EXP_FP:			CALL    SFLOAT_FP
0B261A 6A 
0B261B 2B 
0B261C 0B 
0B261D CD    0951** EXP0:			CALL    LN2             ;LN(2)
0B261E AA 
0B261F 26 
0B2620 0B 
0B2621 D9    0952** EXX
0B2622 1D    0953** DEC     E
0B2623 01    0954** LD      BC,0D1CFH       ;0.6931471805599453
0B2624 CF 
0B2625 D1 
0B2626 00 
0B2627 D9    0955** EXX
0B2628 E5    0956** PUSH    HL              ;H7=SIGN
0B2629 CD    0957** CALL    MOD48           ;"MODULUS"
0B262A D9 
0B262B 2A 
0B262C 0B 
0B262D F1    0958** POP     AF
0B262E CB    0959** BIT     7,E
0B262F 7B 
0B2630 28    0960** JR      Z,EXP1
0B2631 0B 
0B2632 17    0961** RLA
0B2633 DA    0962** JP      C,ZERO_FP
0B2634 E7 
0B2635 2B 
0B2636 0B 
0B2637 3E    0963** LD      A,EXPRNG
0B2638 18 
0B2639 C3    0964** JP      ERROR_FP_           ;"Exp range"
0B263A 41 
0B263B 20 
0B263C 0B 
             0965** ;
0B263D E6    0966** EXP1:			AND     80H
0B263E 80 
0B263F B3    0967** OR      E
0B2640 F5    0968** PUSH    AF              ;INTEGER PART
0B2641 CB    0969** RES     7,H
0B2642 BC 
0B2643 CD    0970** CALL    PUSH5           ;PUSH X*LN(2)
0B2644 77 
0B2645 2C 
0B2646 0B 
0B2647 CD    0971** CALL    POLY
0B2648 B4 
0B2649 2C 
0B264A 0B 
0B264B 72    0972** DW	4072H           ;a(7)
0B264C 40 
0B264D 2E    0973** DW	942EH
0B264E 94 
0B264F 73    0974** DB	73H
0B2650 65    0975** DW	6F65H           ;a(6)
0B2651 6F 
0B2652 4F    0976** DW	2E4FH
0B2653 2E 
0B2654 76    0977** DB	76H
0B2655 37    0978** DW	6D37H           ;a(5)
0B2656 6D 
0B2657 02    0979** DW	8802H
0B2658 88 
0B2659 79    0980** DB	79H
0B265A 12    0981** DW	0E512H          ;a(4)
0B265B E5 
0B265C A0    0982** DW	2AA0H
0B265D 2A 
0B265E 7B    0983** DB	7BH
0B265F 14    0984** DW	4F14H           ;a(3)
0B2660 4F 
0B2661 AA    0985** DW	0AAAAH
0B2662 AA 
0B2663 7D    0986** DB	7DH
0B2664 56    0987** DW	0FD56H          ;a(2)
0B2665 FD 
0B2666 FF    0988** DW	7FFFH
0B2667 7F 
0B2668 7E    0989** DB	7EH
0B2669 FE    0990** DW	0FFFEH          ;a(1)
0B266A FF 
0B266B FF    0991** DW	0FFFFH
0B266C FF 
0B266D 7F    0992** DB	7FH
0B266E 00    0993** DW	0               ;a(0)
0B266F 00 
0B2670 00    0994** DW	0
0B2671 00 
0B2672 80    0995** DB	80H
0B2673 CD    0996** CALL    POP5
0B2674 80 
0B2675 2C 
0B2676 0B 
0B2677 F1    0997** POP     AF
0B2678 F5    0998** PUSH    AF
0B2679 F4    0999** CALL    P,RECIP         ;X=1/X
0B267A 9E 
0B267B 26 
0B267C 0B 
0B267D F1    1000** POP     AF
0B267E F2    1001** JP      P,EXP4
0B267F 86 
0B2680 26 
0B2681 0B 
0B2682 E6    1002** AND     7FH
0B2683 7F 
0B2684 ED    1003** NEG
0B2685 44 
0B2686 C6    1004** EXP4:			ADD     A,80H
0B2687 80 
0B2688 81    1005** ADD     A,C
0B2689 38    1006** JR      C,EXP2
0B268A 06 
0B268B F2    1007** JP      P,ZERO_FP          ;UNDERFLOW
0B268C E7 
0B268D 2B 
0B268E 0B 
0B268F 18    1008** JR      EXP3
0B2690 04 
0B2691 FA    1009** EXP2:			JP      M,OFLOW         ;OVERFLOW
0B2692 B2 
0B2693 2B 
0B2694 0B 
0B2695 C6    1010** EXP3:			ADD     A,80H
0B2696 80 
0B2697 CA    1011** JP      Z,ZERO_FP
0B2698 E7 
0B2699 2B 
0B269A 0B 
0B269B 4F    1012** LD      C,A
0B269C AF    1013** XOR     A               ;NUMERIC MARKER
0B269D C9    1014** RET
             1015** ;
0B269E CD    1016** RECIP:			CALL    DONE
0B269F FF 
0B26A0 25 
0B26A1 0B 
0B26A2 CD    1017** RDIV:			CALL    SWAP_FP
0B26A3 9B 
0B26A4 2B 
0B26A5 0B 
0B26A6 C3    1018** JP      FDIV            ;RECIPROCAL
0B26A7 29 
0B26A8 22 
0B26A9 0B 
             1019** ;
0B26AA 11    1020** LN2:			LD      DE,3172H        ;LN(2)
0B26AB 72 
0B26AC 31 
0B26AD 00 
0B26AE D9    1021** EXX
0B26AF 11    1022** LD      DE,17F8H
0B26B0 F8 
0B26B1 17 
0B26B2 00 
0B26B3 D9    1023** EXX
0B26B4 06    1024** LD      B,7FH
0B26B5 7F 
0B26B6 C9    1025** RET
             1026** ;
             1027** ;LN - Natural log.
             1028** ;Result is floating-point numeric.
             1029** ;
0B26B7 CD    1030** LN_FP:			CALL    SFLOAT_FP
0B26B8 6A 
0B26B9 2B 
0B26BA 0B 
0B26BB 3E    1031** LN0:			LD      A,LOGRNG
0B26BC 16 
0B26BD CB    1032** BIT     7,H
0B26BE 7C 
0B26BF C2    1033** JP      NZ,ERROR_FP_        ;"Log range"
0B26C0 41 
0B26C1 20 
0B26C2 0B 
0B26C3 0C    1034** INC     C
0B26C4 0D    1035** DEC     C
0B26C5 CA    1036** JP      Z,ERROR_FP_
0B26C6 41 
0B26C7 20 
0B26C8 0B 
0B26C9 11    1037** LD      DE,3504H        ;SQR(2)
0B26CA 04 
0B26CB 35 
0B26CC 00 
0B26CD D9    1038** EXX
0B26CE 11    1039** LD      DE,0F333H       ;1.41421356237
0B26CF 33 
0B26D0 F3 
0B26D1 00 
0B26D2 D9    1040** EXX
0B26D3 CD    1041** CALL    ICP0            ;MANTISSA>SQR(2)?
0B26D4 FA 
0B26D5 2B 
0B26D6 0B 
0B26D7 79    1042** LD      A,C             ;EXPONENT
0B26D8 0E    1043** LD      C,80H           ;1 <= X < 2
0B26D9 80 
0B26DA 38    1044** JR      C,LN4
0B26DB 02 
0B26DC 0D    1045** DEC     C
0B26DD 3C    1046** INC     A
0B26DE F5    1047** LN4:			PUSH    AF              ;SAVE EXPONENT
0B26DF CD    1048** CALL    RATIO           ;X=(X-1)/(X+1)
0B26E0 8C 
0B26E1 2C 
0B26E2 0B 
0B26E3 CD    1049** CALL    PUSH5
0B26E4 77 
0B26E5 2C 
0B26E6 0B 
0B26E7 CD    1050** CALL    SQUARE          ;PUSH X*X
0B26E8 6F 
0B26E9 2C 
0B26EA 0B 
0B26EB CD    1051** CALL    POLY
0B26EC B4 
0B26ED 2C 
0B26EE 0B 
0B26EF 48    1052** DW	0CC48H          ;a(9)
0B26F0 CC 
0B26F1 FB    1053** DW	74FBH
0B26F2 74 
0B26F3 7D    1054** DB	7DH
0B26F4 AF    1055** DW	0AEAFH          ;a(7)
0B26F5 AE 
0B26F6 FF    1056** DW	11FFH
0B26F7 11 
0B26F8 7E    1057** DB	7EH
0B26F9 8C    1058** DW	0D98CH          ;a(5)
0B26FA D9 
0B26FB CD    1059** DW	4CCDH
0B26FC 4C 
0B26FD 7E    1060** DB	7EH
0B26FE E3    1061** DW	0A9E3H          ;a(3)
0B26FF A9 
0B2700 AA    1062** DW	2AAAH
0B2701 2A 
0B2702 7F    1063** DB	7FH
0B2703 00    1064** DW	0               ;a(1)
0B2704 00 
0B2705 00    1065** DW	0
0B2706 00 
0B2707 81    1066** DB	81H
0B2708 CD    1067** CALL    POP5
0B2709 80 
0B270A 2C 
0B270B 0B 
0B270C CD    1068** CALL    POP5
0B270D 80 
0B270E 2C 
0B270F 0B 
0B2710 CD    1069** CALL    FMUL
0B2711 D2 
0B2712 22 
0B2713 0B 
0B2714 F1    1070** POP     AF              ;EXPONENT
0B2715 CD    1071** CALL    PUSH5
0B2716 77 
0B2717 2C 
0B2718 0B 
0B2719 08    1072** EX      AF,AF'
0B271A CD    1073** CALL    ZERO_FP
0B271B E7 
0B271C 2B 
0B271D 0B 
0B271E 08    1074** EX      AF,AF'
0B271F D6    1075** SUB     80H
0B2720 80 
0B2721 28    1076** JR      Z,LN3
0B2722 1F 
0B2723 30    1077** JR      NC,LN1
0B2724 02 
0B2725 2F    1078** CPL
0B2726 3C    1079** INC     A
0B2727 67    1080** LN1:			LD      H,A
0B2728 0E    1081** LD      C,87H
0B2729 87 
0B272A F5    1082** PUSH    AF
0B272B CD    1083** CALL    FLOAT_
0B272C 4A 
0B272D 2B 
0B272E 0B 
0B272F CB    1084** RES     7,H
0B2730 BC 
0B2731 CD    1085** CALL    LN2
0B2732 AA 
0B2733 26 
0B2734 0B 
0B2735 CD    1086** CALL    FMUL
0B2736 D2 
0B2737 22 
0B2738 0B 
0B2739 F1    1087** POP     AF
0B273A 30    1088** JR      NC,LN3
0B273B 06 
0B273C FA    1089** JP      M,LN3
0B273D 42 
0B273E 27 
0B273F 0B 
0B2740 CB    1090** SET     7,H
0B2741 FC 
0B2742 CD    1091** LN3:			CALL    POP5
0B2743 80 
0B2744 2C 
0B2745 0B 
0B2746 CD    1092** CALL    FADD
0B2747 C0 
0B2748 21 
0B2749 0B 
0B274A AF    1093** XOR     A
0B274B C9    1094** RET
             1095** ;
             1096** ;LOG - base-10 logarithm.
             1097** ;Result is floating-point numeric.
             1098** ;
0B274C CD    1099** LOG_FP:			CALL    LN_FP
0B274D B7 
0B274E 26 
0B274F 0B 
0B2750 11    1100** LD      DE,5E5BH        ;LOG(e)
0B2751 5B 
0B2752 5E 
0B2753 00 
0B2754 D9    1101** EXX
0B2755 11    1102** LD      DE,0D8A9H
0B2756 A9 
0B2757 D8 
0B2758 00 
0B2759 D9    1103** EXX
0B275A 06    1104** LD      B,7EH
0B275B 7E 
0B275C CD    1105** CALL    FMUL
0B275D D2 
0B275E 22 
0B275F 0B 
0B2760 AF    1106** XOR     A
0B2761 C9    1107** RET
             1108** ;
             1109** ;ASN - Arc-sine
             1110** ;Result is floating-point numeric.
             1111** ;
0B2762 CD    1112** ASN_FP:			CALL    SFLOAT_FP
0B2763 6A 
0B2764 2B 
0B2765 0B 
0B2766 CD    1113** CALL    PUSH5
0B2767 77 
0B2768 2C 
0B2769 0B 
0B276A CD    1114** CALL    COPY_
0B276B 67 
0B276C 2C 
0B276D 0B 
0B276E CD    1115** CALL    FMUL
0B276F D2 
0B2770 22 
0B2771 0B 
0B2772 CD    1116** CALL    DONE
0B2773 FF 
0B2774 25 
0B2775 0B 
0B2776 CD    1117** CALL    RSUB
0B2777 AD 
0B2778 21 
0B2779 0B 
0B277A CD    1118** CALL    SQR0
0B277B DD 
0B277C 24 
0B277D 0B 
0B277E CD    1119** CALL    POP5
0B277F 80 
0B2780 2C 
0B2781 0B 
0B2782 0C    1120** INC     C
0B2783 0D    1121** DEC     C
0B2784 3E    1122** LD      A,2
0B2785 02 
0B2786 D5    1123** PUSH    DE
0B2787 CA    1124** JP      Z,ACS1
0B2788 0C 
0B2789 28 
0B278A 0B 
0B278B D1    1125** POP     DE
0B278C CD    1126** CALL    RDIV
0B278D A2 
0B278E 26 
0B278F 0B 
0B2790 18    1127** JR      ATN0
0B2791 04 
             1128** ;
             1129** ;ATN - arc-tangent
             1130** ;Result is floating-point numeric.
             1131** ;
0B2792 CD    1132** ATN_FP:			CALL    SFLOAT_FP
0B2793 6A 
0B2794 2B 
0B2795 0B 
0B2796 E5    1133** ATN0:			PUSH    HL              ;SAVE SIGN
0B2797 CB    1134** RES     7,H
0B2798 BC 
0B2799 11    1135** LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B279A 13 
0B279B 54 
0B279C 00 
0B279D D9    1136** EXX
0B279E 11    1137** LD      DE,0CCD0H
0B279F D0 
0B27A0 CC 
0B27A1 00 
0B27A2 D9    1138** EXX
0B27A3 06    1139** LD      B,7EH
0B27A4 7E 
0B27A5 CD    1140** CALL    FCP0            ;COMPARE
0B27A6 F7 
0B27A7 2B 
0B27A8 0B 
0B27A9 06    1141** LD      B,0
0B27AA 00 
0B27AB 38    1142** JR      C,ATN2
0B27AC 22 
0B27AD 11    1143** LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B27AE 82 
0B27AF 1A 
0B27B0 00 
0B27B1 D9    1144** EXX
0B27B2 11    1145** LD      DE,799AH
0B27B3 9A 
0B27B4 79 
0B27B5 00 
0B27B6 D9    1146** EXX
0B27B7 06    1147** LD      B,81H
0B27B8 81 
0B27B9 CD    1148** CALL    FCP0            ;COMPARE
0B27BA F7 
0B27BB 2B 
0B27BC 0B 
0B27BD 38    1149** JR      C,ATN1
0B27BE 0A 
0B27BF CD    1150** CALL    RECIP           ;X=1/X
0B27C0 9E 
0B27C1 26 
0B27C2 0B 
0B27C3 06    1151** LD      B,2
0B27C4 02 
0B27C5 C3    1152** JP      ATN2
0B27C6 CF 
0B27C7 27 
0B27C8 0B 
0B27C9 CD    1153** ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B27CA 8C 
0B27CB 2C 
0B27CC 0B 
0B27CD 06    1154** LD      B,1
0B27CE 01 
0B27CF C5    1155** ATN2:			PUSH    BC              ;SAVE FLAG
0B27D0 CD    1156** CALL    PUSH5
0B27D1 77 
0B27D2 2C 
0B27D3 0B 
0B27D4 CD    1157** CALL    SQUARE          ;PUSH X*X
0B27D5 6F 
0B27D6 2C 
0B27D7 0B 
0B27D8 CD    1158** CALL    POLY
0B27D9 B4 
0B27DA 2C 
0B27DB 0B 
0B27DC 35    1159** DW	0F335H          ;a(13)
0B27DD F3 
0B27DE D8    1160** DW	37D8H
0B27DF 37 
0B27E0 7B    1161** DB	7BH
0B27E1 91    1162** DW	6B91H           ;a(11)
0B27E2 6B 
0B27E3 B9    1163** DW	0AAB9H
0B27E4 AA 
0B27E5 7C    1164** DB	7CH
0B27E6 DE    1165** DW	41DEH           ;a(9)
0B27E7 41 
0B27E8 97    1166** DW	6197H
0B27E9 61 
0B27EA 7C    1167** DB	7CH
0B27EB 7B    1168** DW	9D7BH           ;a(7)
0B27EC 9D 
0B27ED 37    1169** DW	9237H
0B27EE 92 
0B27EF 7D    1170** DB	7DH
0B27F0 5A    1171** DW	2A5AH           ;a(5)
0B27F1 2A 
0B27F2 CC    1172** DW	4CCCH
0B27F3 4C 
0B27F4 7D    1173** DB	7DH
0B27F5 5C    1174** DW	0A95CH          ;a(3)
0B27F6 A9 
0B27F7 AA    1175** DW	0AAAAH
0B27F8 AA 
0B27F9 7E    1176** DB	7EH
0B27FA 00    1177** DW	0               ;a(1)
0B27FB 00 
0B27FC 00    1178** DW	0
0B27FD 00 
0B27FE 80    1179** DB	80H
0B27FF CD    1180** CALL    POP5
0B2800 80 
0B2801 2C 
0B2802 0B 
0B2803 CD    1181** CALL    POP5
0B2804 80 
0B2805 2C 
0B2806 0B 
0B2807 CD    1182** CALL    FMUL
0B2808 D2 
0B2809 22 
0B280A 0B 
0B280B F1    1183** POP     AF
0B280C CD    1184** ACS1:			CALL    PIBY4           ;PI/4
0B280D 0C 
0B280E 26 
0B280F 0B 
0B2810 1F    1185** RRA
0B2811 F5    1186** PUSH    AF
0B2812 DC    1187** CALL    C,FADD
0B2813 C0 
0B2814 21 
0B2815 0B 
0B2816 F1    1188** POP     AF
0B2817 04    1189** INC     B
0B2818 1F    1190** RRA
0B2819 DC    1191** CALL    C,RSUB
0B281A AD 
0B281B 21 
0B281C 0B 
0B281D F1    1192** POP     AF
0B281E B7    1193** OR      A
0B281F F0    1194** RET     P
0B2820 CB    1195** SET     7,H             ;MAKE NEGATIVE
0B2821 FC 
0B2822 AF    1196** XOR     A
0B2823 C9    1197** RET
             1198** ;
             1199** ;ACS - Arc cosine=PI/2-ASN.
             1200** ;Result is floating point numeric.
             1201** ;
0B2824 CD    1202** ACS_FP:			CALL    ASN_FP
0B2825 62 
0B2826 27 
0B2827 0B 
0B2828 3E    1203** LD      A,2
0B2829 02 
0B282A F5    1204** PUSH    AF
0B282B 18    1205** JR      ACS1
0B282C DF 
             1206** ;
             1207** ;Function STR - convert numeric value to ASCII string.
             1208** ;   Inputs: HLH'L'C = integer or floating-point number
             1209** ;           DE = address at which to store string
             1210** ;           IX = address of @% format control
             1211** ;  Outputs: String stored, with NUL terminator
             1212** ;
             1213** ;First normalise for decimal output:
             1214** ;
0B282D CD    1215** STR_FP:			CALL    SFLOAT_FP
0B282E 6A 
0B282F 2B 
0B2830 0B 
0B2831 06    1216** LD      B,0             ;DEFAULT PT. POSITION
0B2832 00 
0B2833 CB    1217** BIT     7,H             ;NEGATIVE?
0B2834 7C 
0B2835 28    1218** JR      Z,STR10
0B2836 06 
0B2837 CB    1219** RES     7,H
0B2838 BC 
0B2839 3E    1220** LD      A,'-'
0B283A 2D 
0B283B 12    1221** LD      (DE),A          ;STORE SIGN
0B283C 13    1222** INC     DE
0B283D AF    1223** STR10:			XOR     A               ;CLEAR A
0B283E B9    1224** CP      C
0B283F 28    1225** JR      Z,STR02          ;ZERO
0B2840 4E 
0B2841 D5    1226** PUSH    DE              ;SAVE TEXT POINTER
0B2842 78    1227** LD      A,B
0B2843 F5    1228** STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B2844 79    1229** LD      A,C             ;BINARY EXPONENT
0B2845 FE    1230** CP      161
0B2846 A1 
0B2847 30    1231** JR      NC,STR14
0B2848 1C 
0B2849 FE    1232** CP      155
0B284A 9B 
0B284B 30    1233** JR      NC,STR15
0B284C 29 
0B284D 2F    1234** CPL
0B284E FE    1235** CP      225
0B284F E1 
0B2850 38    1236** JR      C,STR13
0B2851 02 
0B2852 3E    1237** LD      A,-8
0B2853 F8 
0B2854 C6    1238** STR13:			ADD     A,28
0B2855 1C 
0B2856 CD    1239** CALL    POWR10
0B2857 E3 
0B2858 2C 
0B2859 0B 
0B285A F5    1240** PUSH    AF
0B285B CD    1241** CALL    FMUL
0B285C D2 
0B285D 22 
0B285E 0B 
0B285F F1    1242** POP     AF
0B2860 47    1243** LD      B,A
0B2861 F1    1244** POP     AF
0B2862 90    1245** SUB     B
0B2863 18    1246** JR      STR11
0B2864 DE 
0B2865 D6    1247** STR14:			SUB     32
0B2866 20 
0B2867 CD    1248** CALL    POWR10
0B2868 E3 
0B2869 2C 
0B286A 0B 
0B286B F5    1249** PUSH    AF
0B286C CD    1250** CALL    FDIV
0B286D 29 
0B286E 22 
0B286F 0B 
0B2870 F1    1251** POP     AF
0B2871 47    1252** LD      B,A
0B2872 F1    1253** POP     AF
0B2873 80    1254** ADD     A,B
0B2874 18    1255** JR      STR11
0B2875 CD 
0B2876 3E    1256** STR15:			LD      A,9
0B2877 09 
0B2878 CD    1257** CALL    POWR10          ;10^9
0B2879 E3 
0B287A 2C 
0B287B 0B 
0B287C CD    1258** CALL    FCP0
0B287D F7 
0B287E 2B 
0B287F 0B 
0B2880 79    1259** LD      A,C
0B2881 C1    1260** POP     BC
0B2882 4F    1261** LD      C,A
0B2883 CB    1262** SET     7,H             ;IMPLIED 1
0B2884 FC 
0B2885 DC    1263** CALL    C,X10B          ;X10, DEC B
0B2886 1F 
0B2887 2C 
0B2888 0B 
0B2889 D1    1264** POP     DE              ;RESTORE TEXT POINTER
0B288A CB    1265** RES     7,C
0B288B B9 
0B288C 3E    1266** LD      A,0
0B288D 00 
0B288E 17    1267** RLA                     ;PUT CARRY IN LSB
             1268** ;
             1269** ;At this point decimal normalisation has been done,
             1270** ;now convert to decimal digits:
             1271** ;      AHLH'L' = number in normalised integer form
             1272** ;            B = decimal place adjustment
             1273** ;            C = binary place adjustment (29-33)
             1274** ;
0B288F 0C    1275** STR02:			INC     C
0B2890 08    1276** EX      AF,AF'          ;SAVE A
0B2891 78    1277** LD      A,B
0B2892 DD    1278** BIT     1,(IX+2)
0B2893 CB 
0B2894 02 
0B2895 4E 
0B2896 20    1279** JR      NZ,STR20
0B2897 08 
0B2898 AF    1280** XOR     A
0B2899 DD    1281** CP      (IX+1)
0B289A BE 
0B289B 01 
0B289C 28    1282** JR      Z,STR21
0B289D 0B 
0B289E 3E    1283** LD      A,-10
0B289F F6 
0B28A0 DD    1284** STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B28A1 86 
0B28A2 01 
0B28A3 B7    1285** OR      A               ;CLEAR CARRY
0B28A4 FA    1286** JP      M,STR21
0B28A5 A9 
0B28A6 28 
0B28A7 0B 
0B28A8 AF    1287** XOR     A
0B28A9 F5    1288** STR21:			PUSH    AF
0B28AA 08    1289** EX      AF,AF'          ;RESTORE A
0B28AB CD    1290** STR22:			CALL    X2              ;RL AHLH'L'
0B28AC 53 
0B28AD 2C 
0B28AE 0B 
0B28AF 8F    1291** ADC     A,A
0B28B0 FE    1292** CP      10
0B28B1 0A 
0B28B2 38    1293** JR      C,STR23
0B28B3 05 
0B28B4 D6    1294** SUB     10
0B28B5 0A 
0B28B6 D9    1295** EXX
0B28B7 2C    1296** INC     L               ;SET RESULT BIT
0B28B8 D9    1297** EXX
0B28B9 0D    1298** STR23:			DEC     C
0B28BA 20    1299** JR      NZ,STR22        ;32 TIMES
0B28BB EF 
0B28BC 4F    1300** LD      C,A             ;REMAINDER
0B28BD 7C    1301** LD      A,H
0B28BE E6    1302** AND     3FH             ;CLEAR OUT JUNK
0B28BF 3F 
0B28C0 67    1303** LD      H,A
0B28C1 F1    1304** POP     AF
0B28C2 F2    1305** JP      P,STR24
0B28C3 D0 
0B28C4 28 
0B28C5 0B 
0B28C6 3C    1306** INC     A
0B28C7 20    1307** JR      NZ,STR26
0B28C8 1C 
0B28C9 3E    1308** LD      A,4
0B28CA 04 
0B28CB B9    1309** CP      C               ;ROUND UP?
0B28CC 3E    1310** LD      A,0
0B28CD 00 
0B28CE 18    1311** JR      STR26
0B28CF 15 
0B28D0 F5    1312** STR24:			PUSH    AF
0B28D1 79    1313** LD      A,C
0B28D2 CE    1314** ADC     A,'0'           ;ADD CARRY
0B28D3 30 
0B28D4 FE    1315** CP      '0'
0B28D5 30 
0B28D6 28    1316** JR      Z,STR25         ;SUPPRESS ZERO
0B28D7 05 
0B28D8 FE    1317** CP      '9'+1
0B28D9 3A 
0B28DA 3F    1318** CCF
0B28DB 30    1319** JR      NC,STR26
0B28DC 08 
0B28DD E3    1320** STR25:			EX      (SP),HL
0B28DE CB    1321** BIT     6,L             ;ZERO FLAG
0B28DF 75 
0B28E0 E3    1322** EX      (SP),HL
0B28E1 20    1323** JR      NZ,STR27
0B28E2 05 
0B28E3 3E    1324** LD      A,'0'
0B28E4 30 
0B28E5 3C    1325** STR26:			INC     A               ;SET +VE
0B28E6 3D    1326** DEC     A
0B28E7 F5    1327** PUSH    AF              ;PUT ON STACK + CARRY
0B28E8 04    1328** STR27:			INC     B
0B28E9 CD    1329** CALL    TEST_FP            ;IS HLH'L' ZERO?
0B28EA C3 
0B28EB 2B 
0B28EC 0B 
0B28ED 0E    1330** LD      C,32
0B28EE 20 
0B28EF 3E    1331** LD      A,0
0B28F0 00 
0B28F1 20    1332** JR      NZ,STR22
0B28F2 B8 
0B28F3 F1    1333** POP     AF
0B28F4 F5    1334** PUSH    AF
0B28F5 3E    1335** LD      A,0
0B28F6 00 
0B28F7 38    1336** JR      C,STR22
0B28F8 B2 
             1337** ;
             1338** ;At this point, the decimal character string is stored
             1339** ; on the stack. Trailing zeroes are suppressed and may
             1340** ; need to be replaced.
             1341** ;B register holds decimal point position.
             1342** ;Now format number and store as ASCII string:
             1343** ;
0B28F9 EB    1344** STR3:			EX      DE,HL           ;STRING POINTER
0B28FA 0E    1345** LD      C,-1            ;FLAG "E"
0B28FB FF 
0B28FC 16    1346** LD      D,1
0B28FD 01 
0B28FE DD    1347** LD      E,(IX+1)        ;f2
0B28FF 5E 
0B2900 01 
0B2901 DD    1348** BIT     0,(IX+2)
0B2902 CB 
0B2903 02 
0B2904 46 
0B2905 20    1349** JR      NZ,STR34        ;E MODE
0B2906 35 
0B2907 DD    1350** BIT     1,(IX+2)
0B2908 CB 
0B2909 02 
0B290A 4E 
0B290B 28    1351** JR      Z,STR31
0B290C 12 
0B290D 78    1352** LD      A,B             ;F MODE
0B290E B7    1353** OR      A
0B290F 28    1354** JR      Z,STR30
0B2910 05 
0B2911 FA    1355** JP      M,STR30
0B2912 16 
0B2913 29 
0B2914 0B 
0B2915 50    1356** LD      D,B
0B2916 7A    1357** STR30:			LD      A,D
0B2917 DD    1358** ADD     A,(IX+1)
0B2918 86 
0B2919 01 
0B291A 5F    1359** LD      E,A
0B291B FE    1360** CP      11
0B291C 0B 
0B291D 38    1361** JR      C,STR32
0B291E 19 
0B291F 78    1362** STR31:			LD      A,B             ;G MODE
0B2920 11    1363** LD      DE,101H
0B2921 01 
0B2922 01 
0B2923 00 
0B2924 B7    1364** OR      A
0B2925 FA    1365** JP      M,STR34
0B2926 3C 
0B2927 29 
0B2928 0B 
0B2929 28    1366** JR      Z,STR32
0B292A 0D 
0B292B DD    1367** LD      A,(IX+1)
0B292C 7E 
0B292D 01 
0B292E B7    1368** OR      A
0B292F 20    1369** JR      NZ,STR3A
0B2930 02 
0B2931 3E    1370** LD      A,10
0B2932 0A 
0B2933 B8    1371** STR3A:			CP      B
0B2934 38    1372** JR      C,STR34
0B2935 06 
0B2936 50    1373** LD      D,B
0B2937 58    1374** LD      E,B
0B2938 78    1375** STR32:			LD      A,B
0B2939 C6    1376** ADD     A,129
0B293A 81 
0B293B 4F    1377** LD      C,A
0B293C CB    1378** STR34:			SET     7,D
0B293D FA 
0B293E 1D    1379** DEC     E
0B293F 7A    1380** STR35:			LD      A,D
0B2940 B9    1381** CP      C
0B2941 30    1382** JR      NC,STR33
0B2942 0E 
0B2943 F1    1383** STR36:			POP     AF
0B2944 28    1384** JR      Z,STR37
0B2945 04 
0B2946 F2    1385** JP      P,STR38
0B2947 53 
0B2948 29 
0B2949 0B 
0B294A F5    1386** STR37:			PUSH    AF
0B294B 1C    1387** INC     E
0B294C 1D    1388** DEC     E
0B294D FA    1389** JP      M,STR4
0B294E 64 
0B294F 29 
0B2950 0B 
0B2951 3E    1390** STR33:			LD      A,'0'
0B2952 30 
0B2953 15    1391** STR38:			DEC     D
0B2954 E2    1392** JP      PO,STR39
0B2955 5B 
0B2956 29 
0B2957 0B 
0B2958 36    1393** LD      (HL),'.'
0B2959 2E 
0B295A 23    1394** INC     HL
0B295B 77    1395** STR39:			LD      (HL),A
0B295C 23    1396** INC     HL
0B295D 1D    1397** DEC     E
0B295E F2    1398** JP      P,STR35
0B295F 3F 
0B2960 29 
0B2961 0B 
0B2962 18    1399** JR      STR36
0B2963 DF 
             1400** ;
0B2964 F1    1401** STR4:			POP     AF
0B2965 0C    1402** STR40:			INC     C
0B2966 4D    1403** LD      C,L
0B2967 20    1404** JR      NZ,STR44
0B2968 28 
0B2969 36    1405** LD      (HL),'E'        ;EXPONENT
0B296A 45 
0B296B 23    1406** INC     HL
0B296C 78    1407** LD      A,B
0B296D 3D    1408** DEC     A
0B296E F2    1409** JP      P,STR41
0B296F 77 
0B2970 29 
0B2971 0B 
0B2972 36    1410** LD      (HL),'-'
0B2973 2D 
0B2974 23    1411** INC     HL
0B2975 ED    1412** NEG
0B2976 44 
0B2977 36    1413** STR41:			LD      (HL),'0'
0B2978 30 
0B2979 28    1414** JR      Z,STR47
0B297A 15 
0B297B FE    1415** CP      10
0B297C 0A 
0B297D 47    1416** LD      B,A
0B297E 3E    1417** LD      A,':'
0B297F 3A 
0B2980 38    1418** JR      C,STR42
0B2981 03 
0B2982 23    1419** INC     HL
0B2983 36    1420** LD      (HL),'0'
0B2984 30 
0B2985 34    1421** STR42:			INC     (HL)
0B2986 BE    1422** CP      (HL)
0B2987 20    1423** JR      NZ,STR43
0B2988 05 
0B2989 36    1424** LD      (HL),'0'
0B298A 30 
0B298B 2B    1425** DEC     HL
0B298C 34    1426** INC     (HL)
0B298D 23    1427** INC     HL
0B298E 10    1428** STR43:			DJNZ    STR42
0B298F F5 
0B2990 23    1429** STR47:			INC     HL
0B2991 EB    1430** STR44:			EX      DE,HL
0B2992 C9    1431** RET
             1432** ;
             1433** ;Support subroutines:
             1434** ;
0B2993 DD    1435** DLOAD5:			LD      B,(IX+4)
0B2994 46 
0B2995 04 
0B2996 D9    1436** EXX
0B2997 DD    1437** LD      E,(IX+0)
0B2998 5E 
0B2999 00 
0B299A DD    1438** LD      D,(IX+1)
0B299B 56 
0B299C 01 
0B299D D9    1439** EXX
0B299E DD    1440** LD      E,(IX+2)
0B299F 5E 
0B29A0 02 
0B29A1 DD    1441** LD      D,(IX+3)
0B29A2 56 
0B29A3 03 
0B29A4 C9    1442** RET
             1443** ;
0B29A5 DD    1444** DLOAD5_SPL:		LD      B,(IX+6)
0B29A6 46 
0B29A7 06 
0B29A8 D9    1445** EXX
0B29A9 DD    1446** LD	DE, (IX+0)
0B29AA 17 
0B29AB 00 
0B29AC D9    1447** EXX
0B29AD DD    1448** LD	DE, (IX+3)
0B29AE 17 
0B29AF 03 
0B29B0 C9    1449** RET
             1450** ;
             1451** ;CON_FP - Get unsigned numeric constant from ASCII string.
             1452** ;   Inputs: ASCII string at (IX).
             1453** ;  Outputs: Variable-type result in HLH'L'C
             1454** ;           IX updated (points to delimiter)
             1455** ;           A7 = 0 (numeric marker)
             1456** ;
0B29B1 CD    1457** CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B29B2 E7 
0B29B3 2B 
0B29B4 0B 
0B29B5 0E    1458** LD      C,0             ;TRUNCATION COUNTER
0B29B6 00 
0B29B7 CD    1459** CALL    UINT          ;GET INTEGER PART
0B29B8 45 
0B29B9 2A 
0B29BA 0B 
0B29BB FE    1460** CP      '.'
0B29BC 2E 
0B29BD 06    1461** LD      B,0             ;DECL. PLACE COUNTER
0B29BE 00 
0B29BF CC    1462** CALL    Z,NUMBIX        ;GET FRACTION PART
0B29C0 43 
0B29C1 2A 
0B29C2 0B 
0B29C3 FE    1463** CP      'E'
0B29C4 45 
0B29C5 3E    1464** LD      A,0             ;INITIALISE EXPONENT
0B29C6 00 
0B29C7 CC    1465** CALL    Z,GETEXP        ;GET EXPONENT
0B29C8 11 
0B29C9 2A 
0B29CA 0B 
0B29CB CB    1466** BIT     7,H
0B29CC 7C 
0B29CD 20    1467** JR      NZ,CON0         ;INTEGER OVERFLOW
0B29CE 08 
0B29CF B7    1468** OR      A
0B29D0 20    1469** JR      NZ,CON0         ;EXPONENT NON-ZERO
0B29D1 05 
0B29D2 B8    1470** CP      B
0B29D3 20    1471** JR      NZ,CON0         ;DECIMAL POINT
0B29D4 02 
0B29D5 B9    1472** CP      C
0B29D6 C8    1473** RET     Z               ;INTEGER
0B29D7 90    1474** CON0:			SUB     B
0B29D8 81    1475** ADD     A,C
0B29D9 0E    1476** LD      C,159
0B29DA 9F 
0B29DB CD    1477** CALL    FLOAT_
0B29DC 4A 
0B29DD 2B 
0B29DE 0B 
0B29DF CB    1478** RES     7,H             ;DITCH IMPLIED 1
0B29E0 BC 
0B29E1 B7    1479** OR      A
0B29E2 C8    1480** RET     Z               ;DONE
0B29E3 FA    1481** JP      M,CON2          ;NEGATIVE EXPONENT
0B29E4 F1 
0B29E5 29 
0B29E6 0B 
0B29E7 CD    1482** CALL    POWR10
0B29E8 E3 
0B29E9 2C 
0B29EA 0B 
0B29EB CD    1483** CALL    FMUL            ;SCALE
0B29EC D2 
0B29ED 22 
0B29EE 0B 
0B29EF AF    1484** XOR     A
0B29F0 C9    1485** RET
0B29F1 FE    1486** CON2:			CP      -38
0B29F2 DA 
0B29F3 38    1487** JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B29F4 0C 
0B29F5 ED    1488** NEG
0B29F6 44 
0B29F7 CD    1489** CALL    POWR10
0B29F8 E3 
0B29F9 2C 
0B29FA 0B 
0B29FB CD    1490** CALL    FDIV            ;SCALE
0B29FC 29 
0B29FD 22 
0B29FE 0B 
0B29FF AF    1491** XOR     A
0B2A00 C9    1492** RET
0B2A01 F5    1493** CON3:			PUSH    AF
0B2A02 3E    1494** LD      A,38
0B2A03 26 
0B2A04 CD    1495** CALL    POWR10
0B2A05 E3 
0B2A06 2C 
0B2A07 0B 
0B2A08 CD    1496** CALL    FDIV
0B2A09 29 
0B2A0A 22 
0B2A0B 0B 
0B2A0C F1    1497** POP     AF
0B2A0D C6    1498** ADD     A,38
0B2A0E 26 
0B2A0F 18    1499** JR      CON2
0B2A10 E0 
             1500** ;
             1501** ;GETEXP - Get decimal exponent from string
             1502** ;     Inputs: ASCII string at (IX)
             1503** ;             (IX points at 'E')
             1504** ;             A = initial value
             1505** ;    Outputs: A = new exponent
             1506** ;             IX updated.
             1507** ;   Destroys: A,A',IX,F,F'
             1508** ;
0B2A11 C5    1509** GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B2A12 47    1510** LD      B,A             ;INITIAL VALUE
0B2A13 0E    1511** LD      C,2             ;2 DIGITS MAX
0B2A14 02 
0B2A15 DD    1512** INC     IX              ;BUMP PAST 'E'
0B2A16 23 
0B2A17 CD    1513** CALL    SIGNQ
0B2A18 01 
0B2A19 2E 
0B2A1A 0B 
0B2A1B 08    1514** EX      AF,AF'          ;SAVE EXPONENT SIGN
0B2A1C CD    1515** GETEX1:			CALL    DIGITQ
0B2A1D F7 
0B2A1E 2D 
0B2A1F 0B 
0B2A20 38    1516** JR      C,GETEX2
0B2A21 18 
0B2A22 78    1517** LD      A,B             ;B=B*10
0B2A23 87    1518** ADD     A,A
0B2A24 87    1519** ADD     A,A
0B2A25 80    1520** ADD     A,B
0B2A26 87    1521** ADD     A,A
0B2A27 47    1522** LD      B,A
0B2A28 DD    1523** LD      A,(IX)          ;GET BACK DIGIT
0B2A29 7E 
0B2A2A 00 
0B2A2B DD    1524** INC     IX
0B2A2C 23 
0B2A2D E6    1525** AND     0FH             ;MASK UNWANTED BITS
0B2A2E 0F 
0B2A2F 80    1526** ADD     A,B             ;ADD IN DIGIT
0B2A30 47    1527** LD      B,A
0B2A31 0D    1528** DEC     C
0B2A32 F2    1529** JP      P,GETEX1
0B2A33 1C 
0B2A34 2A 
0B2A35 0B 
0B2A36 06    1530** LD      B,100           ;FORCE OVERFLOW
0B2A37 64 
0B2A38 18    1531** JR      GETEX1
0B2A39 E2 
0B2A3A 08    1532** GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B2A3B FE    1533** CP      '-'
0B2A3C 2D 
0B2A3D 78    1534** LD      A,B
0B2A3E C1    1535** POP     BC              ;RESTORE
0B2A3F C0    1536** RET     NZ
0B2A40 ED    1537** NEG                     ;NEGATE EXPONENT
0B2A41 44 
0B2A42 C9    1538** RET
             1539** ;
             1540** ;UINT: Get unsigned integer from string.
             1541** ;    Inputs: string at (IX)
             1542** ;            C = truncated digit count
             1543** ;                (initially zero)
             1544** ;            B = total digit count
             1545** ;            HLH'L' = initial value
             1546** ;   Outputs: HLH'L' = number (binary integer)
             1547** ;            A = delimiter.
             1548** ;            B, C & IX updated
             1549** ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
             1550** ;
0B2A43 DD    1551** NUMBIX:			INC     IX
0B2A44 23 
0B2A45 CD    1552** UINT:			CALL    DIGITQ
0B2A46 F7 
0B2A47 2D 
0B2A48 0B 
0B2A49 D8    1553** RET     C
0B2A4A 04    1554** INC     B               ;INCREMENT DIGIT COUNT
0B2A4B DD    1555** INC     IX
0B2A4C 23 
0B2A4D CD    1556** CALL    X10             ;*10 & COPY OLD VALUE
0B2A4E 40 
0B2A4F 2C 
0B2A50 0B 
0B2A51 38    1557** JR      C,NUMB1         ;OVERFLOW
0B2A52 15 
0B2A53 0D    1558** DEC     C               ;SEE IF TRUNCATED
0B2A54 0C    1559** INC     C
0B2A55 20    1560** JR      NZ,NUMB1        ;IMPORTANT!
0B2A56 11 
0B2A57 E6    1561** AND     0FH
0B2A58 0F 
0B2A59 D9    1562** EXX
0B2A5A 06    1563** LD      B,0
0B2A5B 00 
0B2A5C 4F    1564** LD      C,A
0B2A5D 52    1565** ADD.S   HL,BC           ;ADD IN DIGIT
0B2A5E 09 
0B2A5F D9    1566** EXX
0B2A60 30    1567** JR      NC,UINT
0B2A61 E3 
0B2A62 52    1568** INC.S   HL              ;CARRY
0B2A63 23 
0B2A64 7C    1569** LD      A,H
0B2A65 B5    1570** OR      L
0B2A66 20    1571** JR      NZ,UINT
0B2A67 DD 
0B2A68 0C    1572** NUMB1:			INC     C               ;TRUNCATION COUNTER
0B2A69 CD    1573** CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B2A6A 9E 
0B2A6B 2B 
0B2A6C 0B 
0B2A6D 18    1574** JR      UINT
0B2A6E D6 
             1575** ;
             1576** ;FIX - Fix number to specified exponent value.
             1577** ;    Inputs: HLH'L'C = +ve non-zero number (floated)
             1578** ;            A = desired exponent (A>C)
             1579** ;   Outputs: HLH'L'C = fixed number (unsigned)
             1580** ;            fraction shifted into B'C'
             1581** ;            A'F' positive if integer input
             1582** ;  Destroys: C,H,L,A',B',C',H',L',F,F'
             1583** ;
0B2A6F 08    1584** FIX:			EX      AF,AF'
0B2A70 AF    1585** XOR     A
0B2A71 08    1586** EX      AF,AF'
0B2A72 CB    1587** SET     7,H             ;IMPLIED 1
0B2A73 FC 
0B2A74 CD    1588** FIX1:			CALL    DIV2
0B2A75 A3 
0B2A76 2B 
0B2A77 0B 
0B2A78 B9    1589** CP      C
0B2A79 C8    1590** RET     Z
0B2A7A D2    1591** JP      NC,FIX1
0B2A7B 74 
0B2A7C 2A 
0B2A7D 0B 
0B2A7E C3    1592** JP      OFLOW
0B2A7F B2 
0B2A80 2B 
0B2A81 0B 
             1593** ;
             1594** ;SFIX - Convert to integer if necessary.
             1595** ;    Input: Variable-type number in HLH'L'C
             1596** ;   Output: Integer in HLH'L', C=0
             1597** ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
             1598** ;
             1599** ;NEGATE - Negate HLH'L'
             1600** ;    Destroys: H,L,H',L',F
             1601** ;
0B2A82 CD    1602** FIX2:			CALL    SWAP_FP
0B2A83 9B 
0B2A84 2B 
0B2A85 0B 
0B2A86 CD    1603** CALL    SFIX_FP
0B2A87 8E 
0B2A88 2A 
0B2A89 0B 
0B2A8A CD    1604** CALL    SWAP_FP
0B2A8B 9B 
0B2A8C 2B 
0B2A8D 0B 
0B2A8E 0D    1605** SFIX_FP:			DEC     C
0B2A8F 0C    1606** INC     C
0B2A90 C8    1607** RET     Z               ;INTEGER/ZERO
0B2A91 CB    1608** BIT     7,H             ;SIGN
0B2A92 7C 
0B2A93 F5    1609** PUSH    AF
0B2A94 3E    1610** LD      A,159
0B2A95 9F 
0B2A96 CD    1611** CALL    FIX
0B2A97 6F 
0B2A98 2A 
0B2A99 0B 
0B2A9A F1    1612** POP     AF
0B2A9B 0E    1613** LD      C,0
0B2A9C 00 
0B2A9D C8    1614** RET     Z
0B2A9E B7    1615** NEGATE:			OR      A               ;CLEAR CARRY
0B2A9F D9    1616** EXX
0B2AA0 D5    1617** NEG0:			PUSH    DE
0B2AA1 EB    1618** EX      DE,HL
0B2AA2 21    1619** LD      HL,0
0B2AA3 00 
0B2AA4 00 
0B2AA5 00 
0B2AA6 52    1620** SBC.S   HL,DE
0B2AA7 ED 
0B2AA8 52 
0B2AA9 D1    1621** POP     DE
0B2AAA D9    1622** EXX
0B2AAB D5    1623** PUSH    DE
0B2AAC EB    1624** EX      DE,HL
0B2AAD 21    1625** LD      HL,0
0B2AAE 00 
0B2AAF 00 
0B2AB0 00 
0B2AB1 52    1626** SBC.S   HL,DE
0B2AB2 ED 
0B2AB3 52 
0B2AB4 D1    1627** POP     DE
0B2AB5 C9    1628** RET
             1629** ;
             1630** ;NEG - Negate HLH'L'B'C'
             1631** ;    Also complements A (used in FADD)
             1632** ;    Destroys: A,H,L,B',C',H',L',F
             1633** ;
0B2AB6 D9    1634** NEG_:			EXX
0B2AB7 2F    1635** CPL
0B2AB8 E5    1636** PUSH    HL
0B2AB9 B7    1637** OR      A               ;CLEAR CARRY
0B2ABA 21    1638** LD      HL,0
0B2ABB 00 
0B2ABC 00 
0B2ABD 00 
0B2ABE 52    1639** SBC.S   HL,BC
0B2ABF ED 
0B2AC0 42 
0B2AC1 44    1640** LD      B,H
0B2AC2 4D    1641** LD      C,L
0B2AC3 E1    1642** POP     HL
0B2AC4 18    1643** JR      NEG0
0B2AC5 DA 
             1644** ;
             1645** ;SCALE - Trig scaling.
             1646** ;MOD48 - 48-bit floating-point "modulus" (remainder).
             1647** ;   Inputs: HLH'L'C unsigned floating-point dividend
             1648** ;           DED'E'B'C'B unsigned 48-bit FP divisor
             1649** ;  Outputs: HLH'L'C floating point remainder (H7=1)
             1650** ;           E = quotient (bit 7 is sticky)
             1651** ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
             1652** ;FLO48 - Float unsigned number (48 bits)
             1653** ;    Input/output in HLH'L'B'C'C
             1654** ;   Destroys: C,H,L,B',C',H',L',F
             1655** ;
0B2AC6 3E    1656** SCALE:			LD      A,150
0B2AC7 96 
0B2AC8 B9    1657** CP      C
0B2AC9 3E    1658** LD      A,ACLOST
0B2ACA 17 
0B2ACB DA    1659** JP      C,ERROR_FP_         ;"Accuracy lost"
0B2ACC 41 
0B2ACD 20 
0B2ACE 0B 
0B2ACF CD    1660** CALL    PIBY4
0B2AD0 0C 
0B2AD1 26 
0B2AD2 0B 
0B2AD3 D9    1661** EXX
0B2AD4 01    1662** LD      BC,2169H        ;3.141592653589793238
0B2AD5 69 
0B2AD6 21 
0B2AD7 00 
0B2AD8 D9    1663** EXX
0B2AD9 CB    1664** MOD48:			SET     7,D             ;IMPLIED 1
0B2ADA FA 
0B2ADB CB    1665** SET     7,H
0B2ADC FC 
0B2ADD 79    1666** LD      A,C
0B2ADE 0E    1667** LD      C,0             ;INIT QUOTIENT
0B2ADF 00 
0B2AE0 DD    1668** LD      IX,0
0B2AE1 21 
0B2AE2 00 
0B2AE3 00 
0B2AE3 00   
0B2AE5 DD    1669** PUSH    IX              ;PUT ZERO ON STACK
0B2AE6 E5 
0B2AE7 B8    1670** CP      B
0B2AE8 38    1671** JR      C,MOD485        ;DIVIDEND<DIVISOR
0B2AE9 46 
0B2AEA D9    1672** MOD481:			EXX                     ;CARRY=0 HERE
0B2AEB E3    1673** EX      (SP),HL
0B2AEC 52    1674** SBC.S   HL,BC
0B2AED ED 
0B2AEE 42 
0B2AEF E3    1675** EX      (SP),HL
0B2AF0 52    1676** SBC.S   HL,DE
0B2AF1 ED 
0B2AF2 52 
0B2AF3 D9    1677** EXX
0B2AF4 52    1678** SBC.S   HL,DE
0B2AF5 ED 
0B2AF6 52 
0B2AF7 30    1679** JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B2AF8 0C 
0B2AF9 D9    1680** EXX
0B2AFA E3    1681** EX      (SP),HL
0B2AFB 52    1682** ADD.S   HL,BC
0B2AFC 09 
0B2AFD E3    1683** EX      (SP),HL
0B2AFE 52    1684** ADC.S   HL,DE
0B2AFF ED 
0B2B00 5A 
0B2B01 D9    1685** EXX
0B2B02 52    1686** ADC.S   HL,DE
0B2B03 ED 
0B2B04 5A 
0B2B05 3F    1687** MOD482:			CCF
0B2B06 CB    1688** RL      C               ;QUOTIENT
0B2B07 11 
0B2B08 30    1689** JR      NC,MOD483
0B2B09 02 
0B2B0A CB    1690** SET     7,C             ;STICKY BIT
0B2B0B F9 
0B2B0C 3D    1691** MOD483:			DEC     A
0B2B0D B8    1692** CP      B
0B2B0E 38    1693** JR      C,MOD484        ;DIVIDEND<DIVISOR
0B2B0F 1F 
0B2B10 E3    1694** EX      (SP),HL
0B2B11 52    1695** ADD.S   HL,HL           ;DIVIDEND * 2
0B2B12 29 
0B2B13 E3    1696** EX      (SP),HL
0B2B14 D9    1697** EXX
0B2B15 52    1698** ADC.S   HL,HL
0B2B16 ED 
0B2B17 6A 
0B2B18 D9    1699** EXX
0B2B19 52    1700** ADC.S   HL,HL
0B2B1A ED 
0B2B1B 6A 
0B2B1C 30    1701** JR      NC,MOD481       ;AGAIN
0B2B1D CC 
0B2B1E B7    1702** OR      A
0B2B1F D9    1703** EXX
0B2B20 E3    1704** EX      (SP),HL
0B2B21 52    1705** SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B2B22 ED 
0B2B23 42 
0B2B24 E3    1706** EX      (SP),HL
0B2B25 52    1707** SBC.S   HL,DE
0B2B26 ED 
0B2B27 52 
0B2B28 D9    1708** EXX
0B2B29 52    1709** SBC.S   HL,DE
0B2B2A ED 
0B2B2B 52 
0B2B2C B7    1710** OR      A
0B2B2D 18    1711** JR      MOD482
0B2B2E D6 
             1712** ;
0B2B2F 3C    1713** MOD484:			INC     A
0B2B30 59    1714** MOD485:			LD      E,C             ;QUOTIENT
0B2B31 4F    1715** LD      C,A             ;REMAINDER EXPONENT
0B2B32 D9    1716** EXX
0B2B33 C1    1717** POP     BC
0B2B34 D9    1718** EXX
0B2B35 CB    1719** FLO48:			BIT     7,H
0B2B36 7C 
0B2B37 C0    1720** RET     NZ
0B2B38 D9    1721** EXX
0B2B39 CB    1722** SLA     C
0B2B3A 21 
0B2B3B CB    1723** RL      B
0B2B3C 10 
0B2B3D 52    1724** ADC.S   HL,HL
0B2B3E ED 
0B2B3F 6A 
0B2B40 D9    1725** EXX
0B2B41 52    1726** ADC.S   HL,HL
0B2B42 ED 
0B2B43 6A 
0B2B44 0D    1727** DEC     C
0B2B45 C2    1728** JP      NZ,FLO48
0B2B46 35 
0B2B47 2B 
0B2B48 0B 
0B2B49 C9    1729** RET
             1730** ;
             1731** ;Float unsigned number
             1732** ;    Input/output in HLH'L'C
             1733** ;   Destroys: C,H,L,H',L',F
             1734** ;
0B2B4A CB    1735** FLOAT_:			BIT     7,H
0B2B4B 7C 
0B2B4C C0    1736** RET     NZ
0B2B4D D9    1737** EXX                     ;SAME AS "X2"
0B2B4E 52    1738** ADD.S   HL,HL           ;TIME-CRITICAL
0B2B4F 29 
0B2B50 D9    1739** EXX                     ;REGION
0B2B51 52    1740** ADC.S   HL,HL           ;(BENCHMARKS)
0B2B52 ED 
0B2B53 6A 
0B2B54 0D    1741** DEC     C
0B2B55 C2    1742** JP      NZ,FLOAT_
0B2B56 4A 
0B2B57 2B 
0B2B58 0B 
0B2B59 C9    1743** RET
             1744** ;
             1745** ;SFLOAT - Convert to floating-point if necessary.
             1746** ;    Input: Variable-type number in HLH'L'C
             1747** ;    Output: Floating-point in HLH'L'C
             1748** ;    Destroys: A,C,H,L,H',L',F
             1749** ;
0B2B5A 08    1750** FLOATA:			EX      AF,AF'
             1751** ; ADD     A,(RTABLE-DTABLE)/3
0B2B5B C6    1752** ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2B5C 2A 
0B2B5D 08    1753** EX      AF,AF'
0B2B5E CD    1754** FLOAT2:			CALL    SWAP_FP
0B2B5F 9B 
0B2B60 2B 
0B2B61 0B 
0B2B62 CD    1755** CALL    SFLOAT_FP
0B2B63 6A 
0B2B64 2B 
0B2B65 0B 
0B2B66 CD    1756** CALL    SWAP_FP
0B2B67 9B 
0B2B68 2B 
0B2B69 0B 
0B2B6A 0D    1757** SFLOAT_FP:			DEC     C
0B2B6B 0C    1758** INC     C
0B2B6C C0    1759** RET     NZ              ;ALREADY FLOATING-POINT
0B2B6D CD    1760** CALL    TEST_FP
0B2B6E C3 
0B2B6F 2B 
0B2B70 0B 
0B2B71 C8    1761** RET     Z               ;ZERO
0B2B72 7C    1762** LD      A,H
0B2B73 B7    1763** OR      A
0B2B74 FC    1764** CALL    M,NEGATE
0B2B75 9E 
0B2B76 2A 
0B2B77 0B 
0B2B78 0E    1765** LD      C,159
0B2B79 9F 
0B2B7A CD    1766** CALL    FLOAT_
0B2B7B 4A 
0B2B7C 2B 
0B2B7D 0B 
0B2B7E B7    1767** OR      A
0B2B7F F8    1768** RET     M               ;NEGATIVE
0B2B80 CB    1769** RES     7,H
0B2B81 BC 
0B2B82 C9    1770** RET
             1771** ;
             1772** ;ROUND UP
             1773** ;Return with carry set if 32-bit overflow
             1774** ;   Destroys: H,L,B',C',H',L',F
             1775** ;
0B2B83 D9    1776** ADD1_FP:			EXX
0B2B84 01    1777** LD      BC,1
0B2B85 01 
0B2B86 00 
0B2B87 00 
0B2B88 52    1778** ADD.S   HL,BC
0B2B89 09 
0B2B8A D9    1779** EXX
0B2B8B D0    1780** RET     NC
0B2B8C C5    1781** PUSH    BC
0B2B8D 01    1782** LD      BC,1
0B2B8E 01 
0B2B8F 00 
0B2B90 00 
0B2B91 52    1783** ADD.S   HL,BC
0B2B92 09 
0B2B93 C1    1784** POP     BC
0B2B94 C9    1785** RET
             1786** ;
             1787** ;ODD - Add one if even, leave alone if odd.
             1788** ; (Used to perform unbiassed rounding, i.e.
             1789** ;  number is rounded up half the time)
             1790** ;    Destroys: L',F (carry cleared)
             1791** ;
0B2B95 B7    1792** ODD:			OR      A               ;CLEAR CARRY
0B2B96 D9    1793** EXX
0B2B97 CB    1794** SET     0,L             ;MAKE ODD
0B2B98 C5 
0B2B99 D9    1795** EXX
0B2B9A C9    1796** RET
             1797** ;
             1798** ;SWAP_FP - Swap arguments.
             1799** ;    Exchanges DE,HL D'E',H'L' and B,C
             1800** ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
             1801** ;SWAP1 - Swap DEHL with D'E'H'L'
             1802** ;    Destroys: D,E,H,L,D',E',H',L'
             1803** ;
0B2B9B 79    1804** SWAP_FP:			LD      A,C
0B2B9C 48    1805** LD      C,B
0B2B9D 47    1806** LD      B,A
0B2B9E EB    1807** SWAP1:			EX      DE,HL
0B2B9F D9    1808** EXX
0B2BA0 EB    1809** EX      DE,HL
0B2BA1 D9    1810** EXX
0B2BA2 C9    1811** RET
             1812** ;
             1813** ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
             1814** ; INCC - destroys C,F
             1815** ; OFLOW
             1816** ;
0B2BA3 CD    1817** DIV2:			CALL    D2
0B2BA4 5C 
0B2BA5 2C 
0B2BA6 0B 
0B2BA7 D9    1818** EXX
0B2BA8 CB    1819** RR      B
0B2BA9 18 
0B2BAA CB    1820** RR      C
0B2BAB 19 
0B2BAC 08    1821** EX      AF,AF'
0B2BAD B0    1822** OR      B
0B2BAE 08    1823** EX      AF,AF'
0B2BAF D9    1824** EXX
0B2BB0 0C    1825** INCC:			INC     C
0B2BB1 C0    1826** RET     NZ
0B2BB2 3E    1827** OFLOW:			LD      A,TOOBIG_FP
0B2BB3 14 
0B2BB4 C3    1828** JP      ERROR_FP_           ;"Too big"
0B2BB5 41 
0B2BB6 20 
0B2BB7 0B 
             1829** ;
             1830** ; FTEST - Test for zero & sign
             1831** ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
             1832** ;
0B2BB8 CD    1833** FTEST_FP:			CALL    TEST_FP
0B2BB9 C3 
0B2BBA 2B 
0B2BBB 0B 
0B2BBC C8    1834** RET     Z
0B2BBD 7C    1835** LD      A,H
0B2BBE E6    1836** AND     10000000B
0B2BBF 80 
0B2BC0 F6    1837** OR      01000000B
0B2BC1 40 
0B2BC2 C9    1838** RET
             1839** ;
             1840** ; TEST_FP - Test HLH'L' for zero.
             1841** ;     Output: Z-flag set & A=0 if HLH'L'=0
             1842** ;     Destroys: A,F
             1843** ;
0B2BC3 7C    1844** TEST_FP:			LD      A,H
0B2BC4 B5    1845** OR      L
0B2BC5 D9    1846** EXX
0B2BC6 B4    1847** OR      H
0B2BC7 B5    1848** OR      L
0B2BC8 D9    1849** EXX
0B2BC9 C9    1850** RET
             1851** ;
             1852** ; FCOMP - Compare two numbers
             1853** ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
             1854** ;
0B2BCA 78    1855** FCOMP_FP:			LD      A,B
0B2BCB B1    1856** OR      C               ;Both integer?
0B2BCC 20    1857** JR      NZ,FCOMP1
0B2BCD 0B 
0B2BCE CD    1858** CALL    ICP
0B2BCF E3 
0B2BD0 2B 
0B2BD1 0B 
0B2BD2 3E    1859** FCOMP0:			LD      A,0
0B2BD3 00 
0B2BD4 C8    1860** RET     Z               ;Equal
0B2BD5 3E    1861** LD      A,80H
0B2BD6 80 
0B2BD7 1F    1862** RRA
0B2BD8 C9    1863** RET
             1864** ;
0B2BD9 CD    1865** FCOMP1:			CALL    FLOAT2          ;Float both
0B2BDA 5E 
0B2BDB 2B 
0B2BDC 0B 
0B2BDD CD    1866** CALL    FCP
0B2BDE F1 
0B2BDF 2B 
0B2BE0 0B 
0B2BE1 18    1867** JR      FCOMP0
0B2BE2 EF 
             1868** ;
             1869** ; Integer and floating point compare.
             1870** ; Sets carry & zero flags according to HLH'L'C-DED'E'B
             1871** ; Result pre-set to FALSE
             1872** ; ICP1, FCP1 destroy A,F
             1873** ;
             1874** ; ZERO - Return zero.
             1875** ;  Destroys: A,C,H,L,H',L'
             1876** ;
0B2BE3 CD    1877** ICP:			CALL    ICP1
0B2BE4 16 
0B2BE5 2C 
0B2BE6 0B 
0B2BE7 3E    1878** ZERO_FP:			LD      A,0
0B2BE8 00 
0B2BE9 D9    1879** EXX
0B2BEA 67    1880** LD      H,A
0B2BEB 6F    1881** LD      L,A
0B2BEC D9    1882** EXX
0B2BED 67    1883** LD      H,A
0B2BEE 6F    1884** LD      L,A
0B2BEF 4F    1885** LD      C,A
0B2BF0 C9    1886** RET
             1887** ;
0B2BF1 CD    1888** FCP:			CALL    FCP1
0B2BF2 08 
0B2BF3 2C 
0B2BF4 0B 
0B2BF5 18    1889** JR      ZERO_FP            ;PRESET FALSE
0B2BF6 F0 
             1890** ;
0B2BF7 79    1891** FCP0:			LD      A,C
0B2BF8 B8    1892** CP      B               ;COMPARE EXPONENTS
0B2BF9 C0    1893** RET     NZ
             1894** ICP0:
0B2BFA 52    1895** SBC.S   HL,DE           ;COMP MANTISSA MSB
0B2BFB ED 
0B2BFC 52 
0B2BFD 52    1896** ADD.S   HL,DE
0B2BFE 19 
0B2BFF C0    1897** RET     NZ
0B2C00 D9    1898** EXX
0B2C01 52    1899** SBC.S   HL,DE           ;COMP MANTISSA LSB
0B2C02 ED 
0B2C03 52 
0B2C04 52    1900** ADD.S   HL,DE
0B2C05 19 
0B2C06 D9    1901** EXX
0B2C07 C9    1902** RET
             1903** ;
0B2C08 7C    1904** FCP1:			LD      A,H
0B2C09 AA    1905** XOR     D
0B2C0A 7C    1906** LD      A,H
0B2C0B 17    1907** RLA
0B2C0C F8    1908** RET     M
0B2C0D 30    1909** JR      NC,FCP0
0B2C0E E8 
0B2C0F CD    1910** CALL    FCP0
0B2C10 F7 
0B2C11 2B 
0B2C12 0B 
0B2C13 C8    1911** RET     Z               ;** V0.1 BUG FIX
0B2C14 3F    1912** CCF
0B2C15 C9    1913** RET
             1914** ;
0B2C16 7C    1915** ICP1:			LD      A,H
0B2C17 AA    1916** XOR     D
0B2C18 F2    1917** JP      P,ICP0
0B2C19 FA 
0B2C1A 2B 
0B2C1B 0B 
0B2C1C 7C    1918** LD      A,H
0B2C1D 17    1919** RLA
0B2C1E C9    1920** RET
             1921** ;
             1922** ; ADD - Integer add.
             1923** ; Carry, sign & zero flags valid on exit
             1924** ;     Destroys: H,L,H',L',F
             1925** ;
0B2C1F 05    1926** X10B:			DEC     B
0B2C20 0C    1927** INC     C
0B2C21 CD    1928** X5:			CALL    COPY0
0B2C22 68 
0B2C23 2C 
0B2C24 0B 
0B2C25 CD    1929** CALL    D2C
0B2C26 5B 
0B2C27 2C 
0B2C28 0B 
0B2C29 CD    1930** CALL    D2C
0B2C2A 5B 
0B2C2B 2C 
0B2C2C 0B 
0B2C2D 08    1931** EX      AF,AF'          ;SAVE CARRY
0B2C2E D9    1932** ADD_:			EXX
0B2C2F 52    1933** ADD.S   HL,DE
0B2C30 19 
0B2C31 D9    1934** EXX
0B2C32 52    1935** ADC.S   HL,DE
0B2C33 ED 
0B2C34 5A 
0B2C35 C9    1936** RET
             1937** ;
             1938** ; SUB - Integer subtract.
             1939** ; Carry, sign & zero flags valid on exit
             1940** ;     Destroys: H,L,H',L',F
             1941** ;
0B2C36 D9    1942** SUB_:			EXX
0B2C37 B7    1943** OR      A
0B2C38 52    1944** SBC.S   HL,DE
0B2C39 ED 
0B2C3A 52 
0B2C3B D9    1945** EXX
0B2C3C 52    1946** SBC.S   HL,DE
0B2C3D ED 
0B2C3E 52 
0B2C3F C9    1947** RET
             1948** ;
             1949** ; X10 - unsigned integer * 10
             1950** ;    Inputs: HLH'L' initial value
             1951** ;   Outputs: DED'E' = initial HLH'L'
             1952** ;            Carry bit set if overflow
             1953** ;            If carry not set HLH'L'=result
             1954** ;  Destroys: D,E,H,L,D',E',H',L',F
             1955** ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
             1956** ;     Carry set if MSB=1 before shift.
             1957** ;     Sign set if MSB=1 after shift.
             1958** ;     Destroys: H,L,H',L',F
             1959** ;
0B2C40 CD    1960** X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B2C41 68 
0B2C42 2C 
0B2C43 0B 
0B2C44 CD    1961** CALL    X2
0B2C45 53 
0B2C46 2C 
0B2C47 0B 
0B2C48 D8    1962** RET     C               ;TOO BIG
0B2C49 CD    1963** CALL    X2
0B2C4A 53 
0B2C4B 2C 
0B2C4C 0B 
0B2C4D D8    1964** RET     C
0B2C4E CD    1965** CALL    ADD_
0B2C4F 2E 
0B2C50 2C 
0B2C51 0B 
0B2C52 D8    1966** RET     C
0B2C53 D9    1967** X2:			EXX
0B2C54 52    1968** ADD.S   HL,HL
0B2C55 29 
0B2C56 D9    1969** EXX
0B2C57 52    1970** ADC.S   HL,HL
0B2C58 ED 
0B2C59 6A 
0B2C5A C9    1971** RET
             1972** ;
             1973** ; D2 - Divide HLH'L' by 2 as 32-bit integer.
             1974** ;     Carry set if LSB=1 before shift.
             1975** ;     Destroys: H,L,H',L',F
             1976** ;
0B2C5B 0C    1977** D2C:			INC     C
0B2C5C CB    1978** D2:			SRL     H
0B2C5D 3C 
0B2C5E CB    1979** RR      L
0B2C5F 1D 
0B2C60 D9    1980** EXX
0B2C61 CB    1981** RR      H
0B2C62 1C 
0B2C63 CB    1982** RR      L
0B2C64 1D 
0B2C65 D9    1983** EXX
0B2C66 C9    1984** RET
             1985** ;
             1986** ; COPY - COPY HLH'L'C INTO DED'E'B
             1987** ;   Destroys: B,C,D,E,H,L,D',E',H',L'
             1988** ;
0B2C67 41    1989** COPY_:			LD      B,C
0B2C68 54    1990** COPY0:			LD      D,H
0B2C69 5D    1991** LD      E,L
0B2C6A D9    1992** EXX
0B2C6B 54    1993** LD      D,H
0B2C6C 5D    1994** LD      E,L
0B2C6D D9    1995** EXX
0B2C6E C9    1996** RET
             1997** ;
             1998** ; SQUARE - PUSH X*X
             1999** ; PUSH5 - PUSH HLH'L'C ONTO STACK.
             2000** ;   Destroys: SP,IX
             2001** ;
0B2C6F CD    2002** SQUARE:			CALL    COPY_
0B2C70 67 
0B2C71 2C 
0B2C72 0B 
0B2C73 CD    2003** CALL    FMUL
0B2C74 D2 
0B2C75 22 
0B2C76 0B 
0B2C77 DD    2004** PUSH5:			POP     IX              ;RETURN ADDRESS
0B2C78 E1 
0B2C79 C5    2005** PUSH    BC
0B2C7A E5    2006** PUSH    HL
0B2C7B D9    2007** EXX
0B2C7C E5    2008** PUSH    HL
0B2C7D D9    2009** EXX
0B2C7E DD    2010** JP      (IX)            ;"RETURN"
0B2C7F E9 
             2011** ;
             2012** ; POP5 - POP DED'E'B OFF STACK.
             2013** ;   Destroys: A,B,D,E,D',E',SP,IX
             2014** ;
0B2C80 DD    2015** POP5:			POP     IX              ;RETURN ADDRESS
0B2C81 E1 
0B2C82 D9    2016** EXX
0B2C83 D1    2017** POP     DE
0B2C84 D9    2018** EXX
0B2C85 D1    2019** POP     DE
0B2C86 79    2020** LD      A,C
0B2C87 C1    2021** POP     BC
0B2C88 41    2022** LD      B,C
0B2C89 4F    2023** LD      C,A
0B2C8A DD    2024** JP      (IX)            ;"RETURN"
0B2C8B E9 
             2025** ;
             2026** ; RATIO - Calculate (X-1)/(X+1)
             2027** ;     Inputs: X in HLH'L'C
             2028** ;    Outputs: (X-1)/(X+1) in HLH'L'C
             2029** ;   Destroys: Everything except IY,SP,I
             2030** ;
0B2C8C CD    2031** RATIO:			CALL    PUSH5           ;SAVE X
0B2C8D 77 
0B2C8E 2C 
0B2C8F 0B 
0B2C90 CD    2032** CALL    DONE
0B2C91 FF 
0B2C92 25 
0B2C93 0B 
0B2C94 CD    2033** CALL    FADD
0B2C95 C0 
0B2C96 21 
0B2C97 0B 
0B2C98 CD    2034** CALL    POP5            ;RESTORE X
0B2C99 80 
0B2C9A 2C 
0B2C9B 0B 
0B2C9C CD    2035** CALL    PUSH5           ;SAVE X+1
0B2C9D 77 
0B2C9E 2C 
0B2C9F 0B 
0B2CA0 CD    2036** CALL    SWAP_FP
0B2CA1 9B 
0B2CA2 2B 
0B2CA3 0B 
0B2CA4 CD    2037** CALL    DONE
0B2CA5 FF 
0B2CA6 25 
0B2CA7 0B 
0B2CA8 CD    2038** CALL    FSUB
0B2CA9 A7 
0B2CAA 21 
0B2CAB 0B 
0B2CAC CD    2039** CALL    POP5            ;RESTORE X+1
0B2CAD 80 
0B2CAE 2C 
0B2CAF 0B 
0B2CB0 C3    2040** JP      FDIV
0B2CB1 29 
0B2CB2 22 
0B2CB3 0B 
             2041** ;
             2042** ; POLY - Evaluate a polynomial.
             2043** ;     Inputs: X in HLH'L'C and also stored at (SP+2)
             2044** ;             Polynomial coefficients follow call.
             2045** ;    Outputs: Result in HLH'L'C
             2046** ;   Destroys: Everything except IY,SP,I
             2047** ; Routine terminates on finding a coefficient >=1.
             2048** ; Note: The last coefficient is EXECUTED on return
             2049** ;       so must contain only innocuous bytes!
             2050** ;
0B2CB4 DD    2051** POLY:			LD      IX, 3				; Advance the SP to the return address
0B2CB5 21 
0B2CB6 03 
0B2CB7 00 
0B2CB7 00   
0B2CB9 DD    2052** ADD     IX, SP
0B2CBA 39 
0B2CBB DD    2053** EX      (SP), IX			; IX: Points to the inline list of coefficients
0B2CBC E3 
             2054** ;
0B2CBD CD    2055** CALL    DLOAD5          		; Load the first coefficient from (IX)
0B2CBE 93 
0B2CBF 29 
0B2CC0 0B 
0B2CC1 CD    2056** POLY1:			CALL    FMUL
0B2CC2 D2 
0B2CC3 22 
0B2CC4 0B 
0B2CC5 11    2057** LD      DE, 5				; Skip to the next coefficient
0B2CC6 05 
0B2CC7 00 
0B2CC8 00 
0B2CC9 DD    2058** ADD     IX, DE
0B2CCA 19 
0B2CCB CD    2059** CALL    DLOAD5          		; Load the second coefficient from (IX)
0B2CCC 93 
0B2CCD 29 
0B2CCE 0B 
0B2CCF DD    2060** EX      (SP), IX			; Restore the SP just in case we need to return
0B2CD0 E3 
0B2CD1 04    2061** INC     B
0B2CD2 05    2062** DEC     B               		; Test B for end byte (80h)
0B2CD3 FA    2063** JP      M,FADD				; Yes, so add and return
0B2CD4 C0 
0B2CD5 21 
0B2CD6 0B 
0B2CD7 CD    2064** CALL    FADD				; No, so add
0B2CD8 C0 
0B2CD9 21 
0B2CDA 0B 
0B2CDB CD    2065** CALL    DLOAD5_SPL			; Load X from SP
0B2CDC A5 
0B2CDD 29 
0B2CDE 0B 
0B2CDF DD    2066** EX      (SP), IX			; IX: Points to the inline list of coefficients
0B2CE0 E3 
0B2CE1 18    2067** JR      POLY1				; And loop
0B2CE2 DE 
             2068** ;
             2069** ; POWR10 - Calculate power of ten.
             2070** ;     Inputs: A=power of 10 required (A<128)
             2071** ;             A=binary exponent to be exceeded (A>=128)
             2072** ;    Outputs: DED'E'B = result
             2073** ;             A = actual power of ten returned
             2074** ;   Destroys: A,B,D,E,A',D',E',F,F'
             2075** ;
0B2CE3 3C    2076** POWR10:			INC     A
0B2CE4 08    2077** EX      AF,AF'
0B2CE5 E5    2078** PUSH    HL
0B2CE6 D9    2079** EXX
0B2CE7 E5    2080** PUSH    HL
0B2CE8 D9    2081** EXX
0B2CE9 CD    2082** CALL    DONE
0B2CEA FF 
0B2CEB 25 
0B2CEC 0B 
0B2CED CD    2083** CALL    SWAP_FP
0B2CEE 9B 
0B2CEF 2B 
0B2CF0 0B 
0B2CF1 AF    2084** XOR     A
0B2CF2 08    2085** POWR11:			EX      AF,AF'
0B2CF3 3D    2086** DEC     A
0B2CF4 28    2087** JR      Z,POWR14        ;EXIT TYPE 1
0B2CF5 26 
0B2CF6 F2    2088** JP      P,POWR13
0B2CF7 FE 
0B2CF8 2C 
0B2CF9 0B 
0B2CFA B9    2089** CP      C
0B2CFB 38    2090** JR      C,POWR14        ;EXIT TYPE 2
0B2CFC 1F 
0B2CFD 3C    2091** INC     A
0B2CFE 08    2092** POWR13:			EX      AF,AF'
0B2CFF 3C    2093** INC     A
0B2D00 CB    2094** SET     7,H
0B2D01 FC 
0B2D02 CD    2095** CALL    X5
0B2D03 21 
0B2D04 2C 
0B2D05 0B 
0B2D06 30    2096** JR      NC,POWR12
0B2D07 06 
0B2D08 08    2097** EX      AF,AF'
0B2D09 CD    2098** CALL    D2C
0B2D0A 5B 
0B2D0B 2C 
0B2D0C 0B 
0B2D0D 08    2099** EX      AF,AF'
0B2D0E 08    2100** POWR12:			EX      AF,AF'
0B2D0F DC    2101** CALL    C,ADD1_FP          ;ROUND UP
0B2D10 83 
0B2D11 2B 
0B2D12 0B 
0B2D13 0C    2102** INC     C
0B2D14 FA    2103** JP      M,POWR11
0B2D15 F2 
0B2D16 2C 
0B2D17 0B 
0B2D18 C3    2104** JP      OFLOW
0B2D19 B2 
0B2D1A 2B 
0B2D1B 0B 
0B2D1C CD    2105** POWR14:			CALL    SWAP_FP
0B2D1D 9B 
0B2D1E 2B 
0B2D1F 0B 
0B2D20 CB    2106** RES     7,D
0B2D21 BA 
0B2D22 D9    2107** EXX
0B2D23 E1    2108** POP     HL
0B2D24 D9    2109** EXX
0B2D25 E1    2110** POP     HL
0B2D26 08    2111** EX      AF,AF'
0B2D27 C9    2112** RET
             2113** ;
             2114** ; DIVA, DIVB - DIVISION PRIMITIVE.
             2115** ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
             2116** ;               Remainder in H'L'HL
             2117** ;     Inputs: A = loop counter (normally -32)
             2118** ;     Destroys: A,D,E,H,L,D',E',H',L',F
             2119** ;
0B2D28 B7    2120** DIVA:			OR      A               ;CLEAR CARRY
             2121** DIV0:
0B2D29 52    2122** SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B2D2A ED 
0B2D2B 42 
0B2D2C D9    2123** EXX
0B2D2D 52    2124** SBC.S   HL,BC
0B2D2E ED 
0B2D2F 42 
0B2D30 D9    2125** EXX
0B2D31 30    2126** JR      NC,DIV1
0B2D32 07 
0B2D33 52    2127** ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B2D34 09 
0B2D35 D9    2128** EXX
0B2D36 52    2129** ADC.S   HL,BC
0B2D37 ED 
0B2D38 4A 
0B2D39 D9    2130** EXX
0B2D3A 3F    2131** DIV1:			CCF
0B2D3B CB    2132** DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B2D3C 13 
0B2D3D CB    2133** RL      D
0B2D3E 12 
0B2D3F D9    2134** EXX
0B2D40 CB    2135** RL      E
0B2D41 13 
0B2D42 CB    2136** RL      D
0B2D43 12 
0B2D44 D9    2137** EXX
0B2D45 3C    2138** INC     A
0B2D46 F0    2139** RET     P
             2140** DIVB:
0B2D47 52    2141** ADC.S   HL,HL           ;DIVIDEND*2
0B2D48 ED 
0B2D49 6A 
0B2D4A D9    2142** EXX
0B2D4B 52    2143** ADC.S   HL,HL
0B2D4C ED 
0B2D4D 6A 
0B2D4E D9    2144** EXX
0B2D4F 30    2145** JR      NC,DIV0
0B2D50 D8 
0B2D51 B7    2146** OR      A
0B2D52 52    2147** SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B2D53 ED 
0B2D54 42 
0B2D55 D9    2148** EXX
0B2D56 52    2149** SBC.S   HL,BC
0B2D57 ED 
0B2D58 42 
0B2D59 D9    2150** EXX
0B2D5A 37    2151** SCF
0B2D5B C3    2152** JP      DIVC
0B2D5C 3B 
0B2D5D 2D 
0B2D5E 0B 
             2153** ;
             2154** ;MULA, MULB - MULTIPLICATION PRIMITIVE.
             2155** ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
             2156** ;    Inputs: A = loop counter (usually -32)
             2157** ;            H'L'HL = 0
             2158** ;    Destroys: D,E,H,L,D',E',H',L',A,F
             2159** ;
0B2D5F B7    2160** MULA:			OR      A               ;CLEAR CARRY
0B2D60 D9    2161** MUL0:			EXX
0B2D61 CB    2162** RR      D               ;MULTIPLIER/2
0B2D62 1A 
0B2D63 CB    2163** RR      E
0B2D64 1B 
0B2D65 D9    2164** EXX
0B2D66 CB    2165** RR      D
0B2D67 1A 
0B2D68 CB    2166** RR      E
0B2D69 1B 
0B2D6A 30    2167** JR      NC,MUL1
0B2D6B 07 
0B2D6C 52    2168** ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B2D6D 09 
0B2D6E D9    2169** EXX
0B2D6F 52    2170** ADC.S   HL,BC
0B2D70 ED 
0B2D71 4A 
0B2D72 D9    2171** EXX
0B2D73 3C    2172** MUL1:			INC     A
0B2D74 F0    2173** RET     P
0B2D75 D9    2174** MULB:			EXX
0B2D76 CB    2175** RR      H               ;PRODUCT/2
0B2D77 1C 
0B2D78 CB    2176** RR      L
0B2D79 1D 
0B2D7A D9    2177** EXX
0B2D7B CB    2178** RR      H
0B2D7C 1C 
0B2D7D CB    2179** RR      L
0B2D7E 1D 
0B2D7F C3    2180** JP      MUL0
0B2D80 60 
0B2D81 2D 
0B2D82 0B 
             2181** ;
             2182** ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
             2183** ;     Function: B'C'BC = SQR (D'E'DE)
             2184** ;     Inputs: A = loop counter (normally -31)
             2185** ;             B'C'BCH'L'HL initialised to 0
             2186** ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
             2187** ;
             2188** SQR1:
0B2D83 52    2189** SBC.S   HL,BC
0B2D84 ED 
0B2D85 42 
0B2D86 D9    2190** EXX
0B2D87 52    2191** SBC.S   HL,BC
0B2D88 ED 
0B2D89 42 
0B2D8A D9    2192** EXX
0B2D8B 0C    2193** INC     C
0B2D8C 30    2194** JR      NC,SQR2
0B2D8D 09 
0B2D8E 0D    2195** DEC     C
0B2D8F 52    2196** ADD.S   HL,BC
0B2D90 09 
0B2D91 D9    2197** EXX
0B2D92 52    2198** ADC.S   HL,BC
0B2D93 ED 
0B2D94 4A 
0B2D95 D9    2199** EXX
0B2D96 0D    2200** DEC     C
0B2D97 3C    2201** SQR2:			INC     A
0B2D98 F0    2202** RET     P
0B2D99 CB    2203** SQRA:			SLA     C
0B2D9A 21 
0B2D9B CB    2204** RL      B
0B2D9C 10 
0B2D9D D9    2205** EXX
0B2D9E CB    2206** RL      C
0B2D9F 11 
0B2DA0 CB    2207** RL      B
0B2DA1 10 
0B2DA2 D9    2208** EXX
0B2DA3 0C    2209** INC     C
0B2DA4 CB    2210** SLA     E
0B2DA5 23 
0B2DA6 CB    2211** RL      D
0B2DA7 12 
0B2DA8 D9    2212** EXX
0B2DA9 CB    2213** RL      E
0B2DAA 13 
0B2DAB CB    2214** RL      D
0B2DAC 12 
0B2DAD D9    2215** EXX
0B2DAE 52    2216** ADC.S   HL,HL
0B2DAF ED 
0B2DB0 6A 
0B2DB1 D9    2217** EXX
0B2DB2 52    2218** ADC.S   HL,HL
0B2DB3 ED 
0B2DB4 6A 
0B2DB5 D9    2219** EXX
0B2DB6 CB    2220** SLA     E
0B2DB7 23 
0B2DB8 CB    2221** RL      D
0B2DB9 12 
0B2DBA D9    2222** EXX
0B2DBB CB    2223** RL      E
0B2DBC 13 
0B2DBD CB    2224** RL      D
0B2DBE 12 
0B2DBF D9    2225** EXX
0B2DC0 52    2226** ADC.S   HL,HL
0B2DC1 ED 
0B2DC2 6A 
0B2DC3 D9    2227** EXX
0B2DC4 52    2228** ADC.S   HL,HL
0B2DC5 ED 
0B2DC6 6A 
0B2DC7 D9    2229** EXX
0B2DC8 D2    2230** JP      NC,SQR1
0B2DC9 83 
0B2DCA 2D 
0B2DCB 0B 
0B2DCC B7    2231** SQR3:			OR      A
0B2DCD 52    2232** SBC.S   HL,BC
0B2DCE ED 
0B2DCF 42 
0B2DD0 D9    2233** EXX
0B2DD1 52    2234** SBC.S   HL,BC
0B2DD2 ED 
0B2DD3 42 
0B2DD4 D9    2235** EXX
0B2DD5 0C    2236** INC     C
0B2DD6 C3    2237** JP      SQR2
0B2DD7 97 
0B2DD8 2D 
0B2DD9 0B 
             2238** ;
             2239** SQRB:
0B2DDA 52    2240** ADD.S   HL,HL
0B2DDB 29 
0B2DDC D9    2241** EXX
0B2DDD 52    2242** ADC.S   HL,HL
0B2DDE ED 
0B2DDF 6A 
0B2DE0 D9    2243** EXX
0B2DE1 38    2244** JR      C,SQR3
0B2DE2 E9 
0B2DE3 3C    2245** INC     A
0B2DE4 0C    2246** INC     C
0B2DE5 52    2247** SBC.S   HL,BC
0B2DE6 ED 
0B2DE7 42 
0B2DE8 D9    2248** EXX
0B2DE9 52    2249** SBC.S   HL,BC
0B2DEA ED 
0B2DEB 42 
0B2DEC D9    2250** EXX
0B2DED D0    2251** RET     NC
0B2DEE 52    2252** ADD.S   HL,BC
0B2DEF 09 
0B2DF0 D9    2253** EXX
0B2DF1 52    2254** ADC.S   HL,BC
0B2DF2 ED 
0B2DF3 4A 
0B2DF4 D9    2255** EXX
0B2DF5 0D    2256** DEC     C
0B2DF6 C9    2257** RET
             2258** ;
0B2DF7 DD    2259** DIGITQ:			LD      A,(IX)
0B2DF8 7E 
0B2DF9 00 
0B2DFA FE    2260** CP      '9'+1
0B2DFB 3A 
0B2DFC 3F    2261** CCF
0B2DFD D8    2262** RET     C
0B2DFE FE    2263** CP      '0'
0B2DFF 30 
0B2E00 C9    2264** RET
             2265** ;
0B2E01 DD    2266** SIGNQ:			LD      A,(IX)
0B2E02 7E 
0B2E03 00 
0B2E04 DD    2267** INC     IX
0B2E05 23 
0B2E06 FE    2268** CP      ' '
0B2E07 20 
0B2E08 28    2269** JR      Z,SIGNQ
0B2E09 F7 
0B2E0A FE    2270** CP      '+'
0B2E0B 2B 
0B2E0C C8    2271** RET     Z
0B2E0D FE    2272** CP      '-'
0B2E0E 2D 
0B2E0F C8    2273** RET     Z
0B2E10 DD    2274** DEC     IX
0B2E11 2B 
0B2E12 C9    2275** RET
              0006* include "basic/gpio.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - GPIO functions
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	12/05/2023
             0006** ;
             0007** ; Modinfo:
             0008** 
             0009** ; INCLUDE	"macros.inc"
             0010** ; INCLUDE	"equs.inc"
             0011** 
             0012** ; .ASSUME	ADL = 1
             0013** 
             0014** ; SEGMENT CODE
             0015** 
             0016** ; XDEF	GPIOB_SETMODE
             0017** 
             0018** ; XREF	SWITCH_A
             0019** 
             0020** ;  A: Mode
             0021** ;  B: Pins
             0022** ;
0B2E13 CD    0023** GPIOB_SETMODE:		CALL	SWITCH_A
0B2E14 B8 
0B2E15 3D 
0B2E16 0B 
0B2E17 2B    0024** DW	GPIOB_M0	; Output
0B2E18 2E 
0B2E19 50    0025** DW	GPIOB_M1	; Input
0B2E1A 2E 
0B2E1B 70    0026** DW	GPIOB_M2	; Open Drain IO
0B2E1C 2E 
0B2E1D 90    0027** DW	GPIOB_M3	; Open Source IO
0B2E1E 2E 
0B2E1F AB    0028** DW	GPIOB_M4	; Interrupt, Dual Edge
0B2E20 2E 
0B2E21 D7    0029** DW	GPIOB_M5	; Alt Function
0B2E22 2E 
0B2E23 F2    0030** DW	GPIOB_M6	; Interrupt, Active Low
0B2E24 2E 
0B2E25 19    0031** DW	GPIOB_M7	; Interrupt, Active High
0B2E26 2F 
0B2E27 3B    0032** DW	GPIOB_M8	; Interrupt, Falling Edge
0B2E28 2F 
0B2E29 5D    0033** DW	GPIOB_M9	; Interrupt, Rising Edge
0B2E2A 2F 
             0034** 
             0035** ; Output
             0036** ;
             0037** GPIOB_M0:		RES_GPIO PB_DDR,  B
0B2E2B C5   0001**M PUSH	BC
0B2E2C 78   0002**M LD	A, val
0B2E2D 2F   0003**M CPL
0B2E2E 4F   0004**M LD	C, A
0B2E2F ED   0005**M IN0	A, (reg)
0B2E30 38 
0B2E31 9B 
0B2E32 A1   0006**M AND	C
0B2E33 ED   0007**M OUT0	(reg), A
0B2E34 39 
0B2E35 9B 
0B2E36 C1   0008**M POP	BC
             0038** RES_GPIO PB_ALT1, B
0B2E37 C5   0001**M PUSH	BC
0B2E38 78   0002**M LD	A, val
0B2E39 2F   0003**M CPL
0B2E3A 4F   0004**M LD	C, A
0B2E3B ED   0005**M IN0	A, (reg)
0B2E3C 38 
0B2E3D 9C 
0B2E3E A1   0006**M AND	C
0B2E3F ED   0007**M OUT0	(reg), A
0B2E40 39 
0B2E41 9C 
0B2E42 C1   0008**M POP	BC
             0039** RES_GPIO PB_ALT2, B
0B2E43 C5   0001**M PUSH	BC
0B2E44 78   0002**M LD	A, val
0B2E45 2F   0003**M CPL
0B2E46 4F   0004**M LD	C, A
0B2E47 ED   0005**M IN0	A, (reg)
0B2E48 38 
0B2E49 9D 
0B2E4A A1   0006**M AND	C
0B2E4B ED   0007**M OUT0	(reg), A
0B2E4C 39 
0B2E4D 9D 
0B2E4E C1   0008**M POP	BC
0B2E4F C9    0040** RET
             0041** 
             0042** ; Input
             0043** ;
             0044** GPIOB_M1:		SET_GPIO PB_DDR,  B
0B2E50 ED   0001**M IN0	A, (reg)
0B2E51 38 
0B2E52 9B 
0B2E53 B0   0002**M OR	val
0B2E54 ED   0003**M OUT0	(reg), A
0B2E55 39 
0B2E56 9B 
             0045** RES_GPIO PB_ALT1, B
0B2E57 C5   0001**M PUSH	BC
0B2E58 78   0002**M LD	A, val
0B2E59 2F   0003**M CPL
0B2E5A 4F   0004**M LD	C, A
0B2E5B ED   0005**M IN0	A, (reg)
0B2E5C 38 
0B2E5D 9C 
0B2E5E A1   0006**M AND	C
0B2E5F ED   0007**M OUT0	(reg), A
0B2E60 39 
0B2E61 9C 
0B2E62 C1   0008**M POP	BC
             0046** RES_GPIO PB_ALT2, B
0B2E63 C5   0001**M PUSH	BC
0B2E64 78   0002**M LD	A, val
0B2E65 2F   0003**M CPL
0B2E66 4F   0004**M LD	C, A
0B2E67 ED   0005**M IN0	A, (reg)
0B2E68 38 
0B2E69 9D 
0B2E6A A1   0006**M AND	C
0B2E6B ED   0007**M OUT0	(reg), A
0B2E6C 39 
0B2E6D 9D 
0B2E6E C1   0008**M POP	BC
0B2E6F C9    0047** RET
             0048** 
             0049** ; Open Drain IO
             0050** ;
             0051** GPIOB_M2:		RES_GPIO PB_DDR,  B
0B2E70 C5   0001**M PUSH	BC
0B2E71 78   0002**M LD	A, val
0B2E72 2F   0003**M CPL
0B2E73 4F   0004**M LD	C, A
0B2E74 ED   0005**M IN0	A, (reg)
0B2E75 38 
0B2E76 9B 
0B2E77 A1   0006**M AND	C
0B2E78 ED   0007**M OUT0	(reg), A
0B2E79 39 
0B2E7A 9B 
0B2E7B C1   0008**M POP	BC
             0052** SET_GPIO PB_ALT1, B
0B2E7C ED   0001**M IN0	A, (reg)
0B2E7D 38 
0B2E7E 9C 
0B2E7F B0   0002**M OR	val
0B2E80 ED   0003**M OUT0	(reg), A
0B2E81 39 
0B2E82 9C 
             0053** RES_GPIO PB_ALT2, B
0B2E83 C5   0001**M PUSH	BC
0B2E84 78   0002**M LD	A, val
0B2E85 2F   0003**M CPL
0B2E86 4F   0004**M LD	C, A
0B2E87 ED   0005**M IN0	A, (reg)
0B2E88 38 
0B2E89 9D 
0B2E8A A1   0006**M AND	C
0B2E8B ED   0007**M OUT0	(reg), A
0B2E8C 39 
0B2E8D 9D 
0B2E8E C1   0008**M POP	BC
0B2E8F C9    0054** RET
             0055** 
             0056** ; Open Source IO
             0057** ;
             0058** GPIOB_M3:		SET_GPIO PB_DDR,  B
0B2E90 ED   0001**M IN0	A, (reg)
0B2E91 38 
0B2E92 9B 
0B2E93 B0   0002**M OR	val
0B2E94 ED   0003**M OUT0	(reg), A
0B2E95 39 
0B2E96 9B 
             0059** SET_GPIO PB_ALT1, B
0B2E97 ED   0001**M IN0	A, (reg)
0B2E98 38 
0B2E99 9C 
0B2E9A B0   0002**M OR	val
0B2E9B ED   0003**M OUT0	(reg), A
0B2E9C 39 
0B2E9D 9C 
             0060** RES_GPIO PB_ALT2, B
0B2E9E C5   0001**M PUSH	BC
0B2E9F 78   0002**M LD	A, val
0B2EA0 2F   0003**M CPL
0B2EA1 4F   0004**M LD	C, A
0B2EA2 ED   0005**M IN0	A, (reg)
0B2EA3 38 
0B2EA4 9D 
0B2EA5 A1   0006**M AND	C
0B2EA6 ED   0007**M OUT0	(reg), A
0B2EA7 39 
0B2EA8 9D 
0B2EA9 C1   0008**M POP	BC
0B2EAA C9    0061** RET
             0062** 
             0063** ; Interrupt, Dual Edge
             0064** ;
             0065** GPIOB_M4:		SET_GPIO PB_DR,   B
0B2EAB ED   0001**M IN0	A, (reg)
0B2EAC 38 
0B2EAD 9A 
0B2EAE B0   0002**M OR	val
0B2EAF ED   0003**M OUT0	(reg), A
0B2EB0 39 
0B2EB1 9A 
             0066** RES_GPIO PB_DDR,  B
0B2EB2 C5   0001**M PUSH	BC
0B2EB3 78   0002**M LD	A, val
0B2EB4 2F   0003**M CPL
0B2EB5 4F   0004**M LD	C, A
0B2EB6 ED   0005**M IN0	A, (reg)
0B2EB7 38 
0B2EB8 9B 
0B2EB9 A1   0006**M AND	C
0B2EBA ED   0007**M OUT0	(reg), A
0B2EBB 39 
0B2EBC 9B 
0B2EBD C1   0008**M POP	BC
             0067** RES_GPIO PB_ALT1, B
0B2EBE C5   0001**M PUSH	BC
0B2EBF 78   0002**M LD	A, val
0B2EC0 2F   0003**M CPL
0B2EC1 4F   0004**M LD	C, A
0B2EC2 ED   0005**M IN0	A, (reg)
0B2EC3 38 
0B2EC4 9C 
0B2EC5 A1   0006**M AND	C
0B2EC6 ED   0007**M OUT0	(reg), A
0B2EC7 39 
0B2EC8 9C 
0B2EC9 C1   0008**M POP	BC
             0068** RES_GPIO PB_ALT2, B
0B2ECA C5   0001**M PUSH	BC
0B2ECB 78   0002**M LD	A, val
0B2ECC 2F   0003**M CPL
0B2ECD 4F   0004**M LD	C, A
0B2ECE ED   0005**M IN0	A, (reg)
0B2ECF 38 
0B2ED0 9D 
0B2ED1 A1   0006**M AND	C
0B2ED2 ED   0007**M OUT0	(reg), A
0B2ED3 39 
0B2ED4 9D 
0B2ED5 C1   0008**M POP	BC
0B2ED6 C9    0069** RET
             0070** 
             0071** ; Alt Function
             0072** ;
             0073** GPIOB_M5:		SET_GPIO PB_DDR,  B
0B2ED7 ED   0001**M IN0	A, (reg)
0B2ED8 38 
0B2ED9 9B 
0B2EDA B0   0002**M OR	val
0B2EDB ED   0003**M OUT0	(reg), A
0B2EDC 39 
0B2EDD 9B 
             0074** RES_GPIO PB_ALT1, B
0B2EDE C5   0001**M PUSH	BC
0B2EDF 78   0002**M LD	A, val
0B2EE0 2F   0003**M CPL
0B2EE1 4F   0004**M LD	C, A
0B2EE2 ED   0005**M IN0	A, (reg)
0B2EE3 38 
0B2EE4 9C 
0B2EE5 A1   0006**M AND	C
0B2EE6 ED   0007**M OUT0	(reg), A
0B2EE7 39 
0B2EE8 9C 
0B2EE9 C1   0008**M POP	BC
             0075** SET_GPIO PB_ALT2, B
0B2EEA ED   0001**M IN0	A, (reg)
0B2EEB 38 
0B2EEC 9D 
0B2EED B0   0002**M OR	val
0B2EEE ED   0003**M OUT0	(reg), A
0B2EEF 39 
0B2EF0 9D 
0B2EF1 C9    0076** RET
             0077** 
             0078** ; Interrupt, Active Low
             0079** ;
             0080** GPIOB_M6:		RES_GPIO PB_DR,   B
0B2EF2 C5   0001**M PUSH	BC
0B2EF3 78   0002**M LD	A, val
0B2EF4 2F   0003**M CPL
0B2EF5 4F   0004**M LD	C, A
0B2EF6 ED   0005**M IN0	A, (reg)
0B2EF7 38 
0B2EF8 9A 
0B2EF9 A1   0006**M AND	C
0B2EFA ED   0007**M OUT0	(reg), A
0B2EFB 39 
0B2EFC 9A 
0B2EFD C1   0008**M POP	BC
             0081** RES_GPIO PB_DDR,  B
0B2EFE C5   0001**M PUSH	BC
0B2EFF 78   0002**M LD	A, val
0B2F00 2F   0003**M CPL
0B2F01 4F   0004**M LD	C, A
0B2F02 ED   0005**M IN0	A, (reg)
0B2F03 38 
0B2F04 9B 
0B2F05 A1   0006**M AND	C
0B2F06 ED   0007**M OUT0	(reg), A
0B2F07 39 
0B2F08 9B 
0B2F09 C1   0008**M POP	BC
             0082** SET_GPIO PB_ALT1, B
0B2F0A ED   0001**M IN0	A, (reg)
0B2F0B 38 
0B2F0C 9C 
0B2F0D B0   0002**M OR	val
0B2F0E ED   0003**M OUT0	(reg), A
0B2F0F 39 
0B2F10 9C 
             0083** SET_GPIO PB_ALT2, B
0B2F11 ED   0001**M IN0	A, (reg)
0B2F12 38 
0B2F13 9D 
0B2F14 B0   0002**M OR	val
0B2F15 ED   0003**M OUT0	(reg), A
0B2F16 39 
0B2F17 9D 
0B2F18 C9    0084** RET
             0085** 
             0086** 
             0087** ; Interrupt, Active High
             0088** ;
             0089** GPIOB_M7:		SET_GPIO PB_DR,   B
0B2F19 ED   0001**M IN0	A, (reg)
0B2F1A 38 
0B2F1B 9A 
0B2F1C B0   0002**M OR	val
0B2F1D ED   0003**M OUT0	(reg), A
0B2F1E 39 
0B2F1F 9A 
             0090** RES_GPIO PB_DDR,  B
0B2F20 C5   0001**M PUSH	BC
0B2F21 78   0002**M LD	A, val
0B2F22 2F   0003**M CPL
0B2F23 4F   0004**M LD	C, A
0B2F24 ED   0005**M IN0	A, (reg)
0B2F25 38 
0B2F26 9B 
0B2F27 A1   0006**M AND	C
0B2F28 ED   0007**M OUT0	(reg), A
0B2F29 39 
0B2F2A 9B 
0B2F2B C1   0008**M POP	BC
             0091** SET_GPIO PB_ALT1, B
0B2F2C ED   0001**M IN0	A, (reg)
0B2F2D 38 
0B2F2E 9C 
0B2F2F B0   0002**M OR	val
0B2F30 ED   0003**M OUT0	(reg), A
0B2F31 39 
0B2F32 9C 
             0092** SET_GPIO PB_ALT2, B
0B2F33 ED   0001**M IN0	A, (reg)
0B2F34 38 
0B2F35 9D 
0B2F36 B0   0002**M OR	val
0B2F37 ED   0003**M OUT0	(reg), A
0B2F38 39 
0B2F39 9D 
0B2F3A C9    0093** RET
             0094** 
             0095** 
             0096** ; Interrupt, Falling Edge
             0097** ;
             0098** GPIOB_M8:		RES_GPIO PB_DR,   B
0B2F3B C5   0001**M PUSH	BC
0B2F3C 78   0002**M LD	A, val
0B2F3D 2F   0003**M CPL
0B2F3E 4F   0004**M LD	C, A
0B2F3F ED   0005**M IN0	A, (reg)
0B2F40 38 
0B2F41 9A 
0B2F42 A1   0006**M AND	C
0B2F43 ED   0007**M OUT0	(reg), A
0B2F44 39 
0B2F45 9A 
0B2F46 C1   0008**M POP	BC
             0099** SET_GPIO PB_DDR,  B
0B2F47 ED   0001**M IN0	A, (reg)
0B2F48 38 
0B2F49 9B 
0B2F4A B0   0002**M OR	val
0B2F4B ED   0003**M OUT0	(reg), A
0B2F4C 39 
0B2F4D 9B 
             0100** SET_GPIO PB_ALT1, B
0B2F4E ED   0001**M IN0	A, (reg)
0B2F4F 38 
0B2F50 9C 
0B2F51 B0   0002**M OR	val
0B2F52 ED   0003**M OUT0	(reg), A
0B2F53 39 
0B2F54 9C 
             0101** SET_GPIO PB_ALT2, B
0B2F55 ED   0001**M IN0	A, (reg)
0B2F56 38 
0B2F57 9D 
0B2F58 B0   0002**M OR	val
0B2F59 ED   0003**M OUT0	(reg), A
0B2F5A 39 
0B2F5B 9D 
0B2F5C C9    0102** RET
             0103** 
             0104** ; Interrupt, Rising Edge
             0105** ;
             0106** GPIOB_M9:		SET_GPIO PB_DR,   B
0B2F5D ED   0001**M IN0	A, (reg)
0B2F5E 38 
0B2F5F 9A 
0B2F60 B0   0002**M OR	val
0B2F61 ED   0003**M OUT0	(reg), A
0B2F62 39 
0B2F63 9A 
             0107** SET_GPIO PB_DDR,  B
0B2F64 ED   0001**M IN0	A, (reg)
0B2F65 38 
0B2F66 9B 
0B2F67 B0   0002**M OR	val
0B2F68 ED   0003**M OUT0	(reg), A
0B2F69 39 
0B2F6A 9B 
             0108** SET_GPIO PB_ALT1, B
0B2F6B ED   0001**M IN0	A, (reg)
0B2F6C 38 
0B2F6D 9C 
0B2F6E B0   0002**M OR	val
0B2F6F ED   0003**M OUT0	(reg), A
0B2F70 39 
0B2F71 9C 
             0109** SET_GPIO PB_ALT2, B
0B2F72 ED   0001**M IN0	A, (reg)
0B2F73 38 
0B2F74 9D 
0B2F75 B0   0002**M OR	val
0B2F76 ED   0003**M OUT0	(reg), A
0B2F77 39 
0B2F78 9D 
0B2F79 C9    0110** RET
              0007* include "basic/main.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Command, Error and Lexical Analysis Module - "MAIN"
             0004** ; Author:	(C) Copyright  R.T.Russell  1984
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	12/05/2023
             0007** ; Last Updated:	26/11/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 07/05/1984:	Version 2.3
             0011** ; 01/03/1987:	Version 3.0
             0012** ; 03/05/2022:	Modified by Dean Belfield
             0013** ; 06/06/2023:	Modified to run in ADL mode
             0014** ; 26/06/2023:	Fixed binary and unary indirection
             0015** ; 17/08/2023:	Added binary constants
             0016** ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
             0017** ; 26/11/2023:	Fixed bug in AUTOLOAD
             0018** 
             0019** ; .ASSUME	ADL = 1
             0020** 
             0021** ; INCLUDE	"equs.inc"
             0022** 
             0023** ; SEGMENT CODE
             0024** 
             0025** ; XDEF	_main
             0026** 
             0027** ; XDEF	COLD
             0028** ; XDEF	WARM
             0029** ; XDEF	CLOOP
             0030** ; XDEF	DELETE
             0031** ; XDEF	LIST_
             0032** ; XDEF	RENUM
             0033** ; XDEF	AUTO
             0034** ; XDEF	NEW
             0035** ; XDEF	OLD
             0036** ; XDEF	LOAD
             0037** ; XDEF	SAVE
             0038** ; XDEF	ERROR_
             0039** ; XDEF	EXTERR
             0040** ; XDEF	LOAD0
             0041** ; XDEF	CLEAR
             0042** ; XDEF	CRLF
             0043** ; XDEF	OUTCHR
             0044** ; XDEF	OUT_
             0045** ; XDEF	FINDL
             0046** ; XDEF	SETLIN
             0047** ; XDEF	PBCDL
             0048** ; XDEF	SAYLN
             0049** ; XDEF	PUTVAR
             0050** ; XDEF	GETVAR
             0051** ; XDEF	GETDEF
             0052** ; XDEF	CREATE
             0053** ; XDEF	RANGE
             0054** ; XDEF	LEXAN2
             0055** ; XDEF	REPORT
             0056** ; XDEF	TELL
             0057** ; XDEF	SPACE_
             0058** ; XDEF	KEYWDS
             0059** ; XDEF	KEYWDL
             0060** ; XDEF	ONEDIT
             0061** ; XDEF	ONEDIT1
             0062** ; XDEF	LISTIT
             0063** ; XDEF	CLEAN
             0064** 
             0065** ; XREF	LISTON
             0066** ; XREF	ERRTXT
             0067** ; XREF	OSINIT
             0068** ; XREF	HIMEM
             0069** ; XREF	PAGE_
             0070** ; XREF	CHAIN0
             0071** ; XREF	PROMPT
             0072** ; XREF	ERRTRP
             0073** ; XREF	ERRLIN
             0074** ; XREF	AUTONO
             0075** ; XREF	LINENO
             0076** ; XREF	INCREM
             0077** ; XREF	OSLINE
             0078** ; XREF	COUNT
             0079** ; XREF	NXT
             0080** ; XREF	BUFFER
             0081** ; XREF	XEQ
             0082** ; XREF	TOP
             0083** ; XREF	EXPRI
             0084** ; XREF	SEARCH
             0085** ; XREF	LTRAP
             0086** ; XREF	LOMEM
             0087** ; XREF	DECODE
             0088** ; XREF	EXPRS
             0089** ; XREF	OSSAVE
             0090** ; XREF	ERR
             0091** ; XREF	ERL
             0092** ; XREF	TRACEN
             0093** ; XREF	RESET
             0094** ; XREF	OSSHUT
             0095** ; XREF	OSLOAD
             0096** ; XREF	FREE
             0097** ; XREF	DYNVAR
             0098** ; XREF	FILL
             0099** ; XREF	OSWRCH
             0100** ; XREF	WIDTH
             0101** ; XREF	COMMA
             0102** ; XREF	MUL16
             0103** ; XREF	BRAKET
             0104** ; XREF	X4OR5
             0105** ; XREF	LOADN
             0106** ; XREF	SFIX
             0107** ; XREF	ITEMI
             0108** ; XREF	FNPTR
             0109** ; XREF	PROPTR
             0110** ; XREF	CHECK
             0111** ; XREF	TERMQ
             0112** ; XREF	OSWRCHCH
             0113** ; XREF	NEWIT
             0114** ; XREF	BAD
             0115** ; XREF	RAM_START
             0116** ; XREF	RAM_END
             0117** ; XREF	R0
             0118** ; XREF	STAR_VERSION
             0119** 
             0120** ; XREF	_end			; In init.asm
             0121** ;
             0122** ; A handful of common token IDs
             0123** ;
             0124** TERROR_MN:			EQU     85H
             0125** LINE_MN_:			EQU     86H
             0126** ELSE_MN_:			EQU     8BH
             0127** THEN_MN_:			EQU     8CH
             0128** LINO_MN:			EQU     8DH
             0129** FN:			EQU     A4H
             0130** TO_MN:			EQU     B8H
             0131** REN:			EQU     CCH
             0132** DATA_MN_:			EQU     DCH
             0133** DIM:			EQU     DEH
             0134** FOR:			EQU     E3H
             0135** GOSUB:			EQU     E4H
             0136** GOTO:			EQU     E5H
             0137** TIF:			EQU     E7H
             0138** LOCAL_:			EQU     EAH
             0139** NEXT:			EQU     EDH
             0140** ON_:			EQU     EEH
             0141** PROC:			EQU     F2H
             0142** REM:			EQU     F4H
             0143** REPEAT:			EQU     F5H
             0144** RESTOR:			EQU     F7H
             0145** TRACE:			EQU     FCH
             0146** UNTIL:			EQU     FDH
             0147** ;
             0148** ; This defines the block of tokens that are pseudo-variables.
             0149** ; There are two versions of each token, a GET and a SET
             0150** 
             0151** ; Name  : GET : SET
             0152** ; ------:-----:----
             0153** ; PTR   : 8Fh : CFh
             0154** ; PAGE  : 90h : D0h
             0155** ; TIME  : 91h : D1h
             0156** ; LOMEM : 92h : D2h
             0157** ; HIMEM : 93h : D3h
             0158** ;
             0159** ; Examples:
             0160** ;   LET A% = PAGE : REM This is the GET version
             0161** ;   PAGE = 40000  : REM This is the SET version
             0162** ;
             0163** TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
             0164** TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
             0165** OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
             0166** 
             0167** ; The main routine
             0168** ; IXU: argv - pointer to array of parameters
             0169** ;   C: argc - number of parameters
             0170** ; Returns:
             0171** ;  HL: Error code, or 0 if OK
             0172** ;
0B2F7A 21    0173** _main:			LD	HL, ACCS		; Clear the ACCS
0B2F7B 00 
0B2F7C 5B 
0B2F7D 0B 
0B2F7E 36    0174** LD	(HL), 0
0B2F7F 00 
0B2F80 79    0175** LD	A, C
0B2F81 FE    0176** CP	2
0B2F82 02 
0B2F83 28    0177** JR	Z, AUTOLOAD		; 2 parameters = autoload
0B2F84 2D 
0B2F85 38    0178** JR	C, COLD			; 1 parameter = normal start
0B2F86 3F 
0B2F87 CD    0179** CALL	STAR_VERSION
0B2F88 FC 
0B2F89 3F 
0B2F8A 0B 
0B2F8B CD    0180** CALL	TELL
0B2F8C 54 
0B2F8D 3D 
0B2F8E 0B 
0B2F8F 55    0181** DB	"Usage:\n\r"
0B2F90 73 
0B2F91 61 
0B2F92 67 
0B2F92 65   
0B2F93 3A 
0B2F94 0A 
0B2F95 0D 
0B2F97 52    0182** DB	"RUN . <filename>\n\r", 0
0B2F98 55 
0B2F99 4E 
0B2F9A 20 
0B2F9A 2E   
0B2F9B 20 
0B2F9C 3C 
0B2F9D 66 
0B2F9D 69   
0B2F9E 6C 
0B2F9F 65 
0B2FA0 6E 
0B2FA0 61   
0B2FA1 6D 
0B2FA2 65 
0B2FA3 3E 
0B2FA3 0A   
0B2FA4 0D 
0B2FA5 00 
0B2FAA 21    0183** LD	HL, 0			; The error code
0B2FAB 00 
0B2FAC 00 
0B2FAD 00 
0B2FAE C3    0184** JP	_end
0B2FAF 59 
0B2FB0 57 
0B2FB1 0B 
             0185** ;
0B2FB2 DD    0186** AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
0B2FB3 27 
0B2FB4 03 
0B2FB5 11    0187** LD	DE, ACCS		;  DE: Destination address
0B2FB6 00 
0B2FB7 5B 
0B2FB8 0B 
0B2FB9 7E    0188** AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
0B2FBA 12    0189** LD	(DE), A			;
0B2FBB 23    0190** INC	HL			; Increase the source pointer
0B2FBC 1C    0191** INC	E			; We only need to increase E as ACCS is on a page boundary
0B2FBD 28    0192** JR	Z, AUTOLOAD_2		; End if we hit the page boundary
0B2FBE 03 
0B2FBF B7    0193** OR	A
0B2FC0 20    0194** JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
0B2FC1 F7 
0B2FC2 1D    0195** AUTOLOAD_2:		DEC	E
0B2FC3 3E    0196** LD	A, CR
0B2FC4 0D 
0B2FC5 12    0197** LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
             0198** ;
0B2FC6 E1    0199** COLD:			POP	HL			; Pop the return address to init off SPS
0B2FC7 E5    0200** PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
0B2FC8 21    0201** LD	HL, STAVAR		; Cold start
0B2FC9 00 
0B2FCA 5D 
0B2FCB 0B 
0B2FCC F9    0202** LD	SP, HL
0B2FCD 36    0203** LD	(HL), 10
0B2FCE 0A 
0B2FCF 23    0204** INC	HL
0B2FD0 36    0205** LD	(HL),9
0B2FD1 09 
0B2FD2 CD    0206** CALL    OSINIT			; Call the machine specific OS initialisation routines
0B2FD3 45 
0B2FD4 3F 
0B2FD5 0B 
0B2FD6 ED    0207** LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
0B2FD7 53 
0B2FD8 20 
0B2FD9 5E 
0B2FD9 0B   
0B2FDB 22    0208** LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
0B2FDC 14 
0B2FDD 5E 
0B2FDE 0B 
0B2FDF 3E    0209** LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
0B2FE0 B7 
0B2FE1 32    0210** LD      (LISTON),A
0B2FE2 40 
0B2FE3 5E 
0B2FE4 0B 
0B2FE5 21    0211** LD      HL,NOTICE
0B2FE6 20 
0B2FE7 30 
0B2FE8 0B 
0B2FE9 22    0212** LD      (ERRTXT),HL
0B2FEA 2F 
0B2FEB 5E 
0B2FEC 0B 
0B2FED CD    0213** CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
0B2FEE 30 
0B2FEF 38 
0B2FF0 0B 
0B2FF1 3A    0214** LD	A,(ACCS)		; Check if there is a filename in ACCS
0B2FF2 00 
0B2FF3 5B 
0B2FF4 0B 
0B2FF5 B7    0215** OR	A
0B2FF6 C2    0216** JP	NZ,CHAIN0		; Yes, so load and run
0B2FF7 17 
0B2FF8 0B 
0B2FF9 0B 
0B2FFA CD    0217** CALL	STAR_VERSION		;
0B2FFB FC 
0B2FFC 3F 
0B2FFD 0B 
0B2FFE CD    0218** CALL    TELL			; Output the welcome message
0B2FFF 54 
0B3000 3D 
0B3001 0B 
0B3002 42    0219** DB    	"BBC BASIC (Z80) Version 3.00\n\r"
0B3003 42 
0B3004 43 
0B3005 20 
0B3005 42   
0B3006 41 
0B3007 53 
0B3008 49 
0B3008 43   
0B3009 20 
0B300A 28 
0B300B 5A 
0B300B 38   
0B300C 30 
0B300D 29 
0B300E 20 
0B300E 56   
0B300F 65 
0B3010 72 
0B3011 73 
0B3011 69   
0B3012 6F 
0B3013 6E 
0B3014 20 
0B3014 33   
0B3015 2E 
0B3016 30 
0B3017 30 
0B3017 0A   
0B3018 0D 
0B3020 28    0220** NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
0B3021 43 
0B3022 29 
0B3023 20 
0B3023 43   
0B3024 6F 
0B3025 70 
0B3026 79 
0B3026 72   
0B3027 69 
0B3028 67 
0B3029 68 
0B3029 74   
0B302A 20 
0B302B 52 
0B302C 2E 
0B302C 54   
0B302D 2E 
0B302E 52 
0B302F 75 
0B302F 73   
0B3030 73 
0B3031 65 
0B3032 6C 
0B3032 6C   
0B3033 20 
0B3034 31 
0B3035 39 
0B3035 38   
0B3036 37 
0B3037 0A 
0B3038 0D 
0B3040 0A    0221** DB	"\n\r", 0
0B3041 0D 
0B3042 00 
             0222** ;
0B3043 F6    0223** WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
             0224** ;
             0225** ; This is the main entry point for BASIC
             0226** ;
0B3044 37    0227** CLOOP:			SCF				; See above - not sure why this is here!
0B3045 ED    0228** LD      SP,(HIMEM)
0B3046 7B 
0B3047 20 
0B3048 5E 
0B3048 0B   
0B304A CD    0229** CALL    PROMPT          	; Prompt user
0B304B BE 
0B304C 3E 
0B304D 0B 
0B304E 21    0230** LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0B304F 40 
0B3050 5E 
0B3051 0B 
0B3052 7E    0231** LD      A,(HL)			; Fetch the value
0B3053 E6    0232** AND     0FH             	; Bottom nibble: LISTO
0B3054 0F 
0B3055 F6    0233** OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0B3056 B0 
0B3057 77    0234** LD      (HL),A			; Store back in
0B3058 ED    0235** SBC     HL,HL           	; HL: 0
0B3059 62 
0B305A 22    0236** LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0B305B 2C 
0B305C 5E 
0B305D 0B 
0B305E 22    0237** LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0B305F 35 
0B3060 5E 
0B3061 0B 
             0238** ;
0B3062 2A    0239** LD      HL,(AUTONO)		; Get the auto line number
0B3063 29 
0B3064 5E 
0B3065 0B 
0B3066 22    0240** LD      (LINENO),HL		; Store in line number
0B3067 23 
0B3068 5E 
0B3069 0B 
0B306A 7C    0241** LD      A,H			; If the auto line number is zero then
0B306B B5    0242** OR      L
0B306C 28    0243** JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0B306D 1E 
             0244** ;
             0245** ; This section handles auto line numbering
             0246** ;
0B306E E5    0247** PUSH    HL			; Stack the line number
0B306F CD    0248** CALL    PBCD           	 	; Output the line number
0B3070 BF 
0B3071 39 
0B3072 0B 
0B3073 E1    0249** POP     HL			; Pop the line number back off the stack
             0250** ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
             0251** ;			LD      B,0			; So clear B
0B3074 01    0252** LD	BC, 0			; Load BC with Increment
0B3075 00 
0B3076 00 
0B3077 00 
0B3078 3A    0253** LD	A,(INCREM)
0B3079 41 
0B307A 5E 
0B307B 0B 
0B307C 4F    0254** LD	C, A
0B307D 09    0255** ADD     HL,BC			; Add the increment to the line number
0B307E DA    0256** JP      C,TOOBIG		; And error if we wrap
0B307F E9 
0B3080 3B 
0B3081 0B 
0B3082 22    0257** LD      (AUTONO),HL		; Store the new auto line number
0B3083 29 
0B3084 5E 
0B3085 0B 
0B3086 3E    0258** LD      A,' '			; Print a space
0B3087 20 
0B3088 CD    0259** CALL    OUTCHR
0B3089 13 
0B308A 39 
0B308B 0B 
             0260** ;
             0261** ; This section invokes the line editor
             0262** ;
0B308C 21    0263** NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0B308D 00 
0B308E 5B 
0B308F 0B 
0B3090 CD    0264** CALL    OSLINE          	; Call the line editor in MOS
0B3091 23 
0B3092 3E 
0B3093 0B 
0B3094 CD    0265** ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0B3095 A0 
0B3096 30 
0B3097 0B 
0B3098 DC    0266** CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0B3099 03 
0B309A 38 
0B309B 0B 
0B309C C3    0267** JP      CLOOP			; Jump back to immediate mode
0B309D 44 
0B309E 30 
0B309F 0B 
             0268** ;
             0269** ; This bit enters the line into memory
             0270** ; Also called from OSLOAD_TXT
             0271** ; Returns:
             0272** ; F: C if a new line has been entered (CLEAN will need to be called)
             0273** ;
0B30A0 AF    0274** ONEDIT1:		XOR     A			; Entry point after *EDIT
0B30A1 32    0275** LD      (COUNT),A
0B30A2 3D 
0B30A3 5E 
0B30A4 0B 
0B30A5 FD    0276** LD      IY,ACCS
0B30A6 21 
0B30A7 00 
0B30A8 5B 
0B30A8 0B   
0B30AA CD    0277** CALL    LINNUM			; HL: The line number from the input buffer
0B30AB BD 
0B30AC 3B 
0B30AD 0B 
0B30AE CD    0278** CALL    NXT			; Skip spaces
0B30AF 34 
0B30B0 0A 
0B30B1 0B 
0B30B2 7C    0279** LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0B30B3 B5    0280** OR      L
0B30B4 28    0281** JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0B30B5 04 
0B30B6 22    0282** LD      (LINENO),HL		; Otherwise store it
0B30B7 23 
0B30B8 5E 
0B30B9 0B 
             0283** ;
             0284** ; This bit does the lexical analysis and tokenisation
             0285** ;
0B30BA 0E    0286** LNZERO:			LD	C,1			; Left mode
0B30BB 01 
0B30BC 11    0287** LD      DE,BUFFER		; Buffer for tokenised BASIC
0B30BD 00 
0B30BE 5C 
0B30BF 0B 
0B30C0 CD    0288** CALL    LEXAN2          	; Lexical analysis on the user input
0B30C1 63 
0B30C2 3C 
0B30C3 0B 
0B30C4 12    0289** LD      (DE),A          	; Terminator
0B30C5 AF    0290** XOR     A
             0291** ;			LD      B,A
             0292** ;			LD      C,E             	; BC: Line length
0B30C6 01    0293** LD	BC,0
0B30C7 00 
0B30C8 00 
0B30C9 00 
0B30CA 4B    0294** LD	C,E			; BC: Line length
0B30CB 13    0295** INC     DE
0B30CC 12    0296** LD      (DE),A          	; Zero next
0B30CD 2A    0297** LD      HL,(LINENO)		; Get the line number
0B30CE 23 
0B30CF 5E 
0B30D0 0B 
0B30D1 7C    0298** LD      A,H			; Is it zero, i.e. a command with no line number?
0B30D2 B5    0299** OR      L
0B30D3 FD    0300** LD      IY,BUFFER       	; Yes, so we're in immediate mode
0B30D4 21 
0B30D5 00 
0B30D6 5C 
0B30D6 0B   
0B30D8 CA    0301** JP      Z,XEQ           	; Execute it
0B30D9 5A 
0B30DA 0B 
0B30DB 0B 
             0302** ;
             0303** ; This section stores the BASIC line in memory
             0304** ;
0B30DC C5    0305** PUSH    BC
0B30DD E5    0306** PUSH    HL
0B30DE CD    0307** CALL    SETTOP          	; Set TOP sysvar
0B30DF 0F 
0B30E0 38 
0B30E1 0B 
0B30E2 E1    0308** POP     HL
0B30E3 CD    0309** CALL    FINDL			; Find the address of the line
0B30E4 53 
0B30E5 39 
0B30E6 0B 
0B30E7 CC    0310** CALL    Z,DEL			; Delete the existing line if found
0B30E8 C6 
0B30E9 37 
0B30EA 0B 
0B30EB C1    0311** POP     BC
0B30EC 79    0312** LD      A,C			; Check for the line length being zero, i.e.
0B30ED B7    0313** OR      A			; the user has just entered a line number in the command line
0B30EE C8    0314** RET	Z 	         	; If so, then don't do anything else
0B30EF C6    0315** ADD     A,4
0B30F0 04 
0B30F1 4F    0316** LD      C,A             	; Length inclusive
0B30F2 D5    0317** PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
0B30F3 C5    0318** PUSH    BC              	; BC: Line length
0B30F4 EB    0319** EX      DE,HL			; DE: Address of the line in memory
0B30F5 2A    0320** LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
0B30F6 17 
0B30F7 5E 
0B30F8 0B 
0B30F9 E5    0321** PUSH    HL			; Stack TOP (current TOP value)
0B30FA 09    0322** ADD     HL,BC			; Add the line length to HL, the new TOP value
0B30FB E5    0323** PUSH    HL			; Stack HL (new TOP value)
0B30FC 24    0324** INC     H			; Add 256 to HL
0B30FD AF    0325** XOR     A
0B30FE ED    0326** SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
0B30FF 72 
0B3100 E1    0327** POP     HL			; Pop HL (new TOP value)
0B3101 D2    0328** JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0B3102 24 
0B3103 37 
0B3104 0B 
0B3105 22    0329** LD      (TOP),HL		; Store new value of TOP
0B3106 17 
0B3107 5E 
0B3108 0B 
0B3109 E3    0330** EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0B310A E5    0331** PUSH    HL			; PUSH current TOP value
0B310B 23    0332** INC     HL
0B310C B7    0333** OR      A
0B310D ED    0334** SBC     HL,DE			; DE: Address of the line in memory
0B310E 52 
0B310F 44    0335** LD      B,H             	; BC: Amount to move
0B3110 4D    0336** LD      C,L
0B3111 E1    0337** POP     HL			; HL: Destination (current TOP value)
0B3112 D1    0338** POP     DE			; DE: Source (new TOP value)
0B3113 28    0339** JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0B3114 02 
0B3115 ED    0340** LDDR                    	; Otherwise, make space for the new line in the program
0B3116 B8 
0B3117 C1    0341** ATEND:			POP     BC              	; BC: Line length
0B3118 D1    0342** POP     DE              	; DE: Line number
0B3119 23    0343** INC     HL			; HL: Destination address
0B311A 71    0344** LD      (HL),C          	; Store length
0B311B 23    0345** INC     HL
0B311C 73    0346** LD      (HL),E          	; Store line number
0B311D 23    0347** INC     HL
0B311E 72    0348** LD      (HL),D
0B311F 23    0349** INC     HL
0B3120 11    0350** LD      DE,BUFFER		; DE: Location of the new, tokenised line
0B3121 00 
0B3122 5C 
0B3123 0B 
0B3124 EB    0351** EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0B3125 0D    0352** DEC     C			; Subtract 3 from the number of bytes to copy to
0B3126 0D    0353** DEC     C			; compensate for the 3 bytes stored above (length and line number)
0B3127 0D    0354** DEC     C
0B3128 ED    0355** LDIR                    	; Add the line to the BASIC program
0B3129 B0 
0B312A 37    0356** SCF				; To flag we need to call CLEAN
0B312B C9    0357** RET
             0358** ;
             0359** ; List of tokens and keywords. If a keyword is followed by 0 then
             0360** ; it will only match with the keyword followed immediately by
             0361** ; a delimiter
             0362** ;
0B312C 80    0363** KEYWDS:			DB    80H, "AND"
0B312D 41 
0B312E 4E 
0B312F 44 
0B3130 94    0364** DB    94H, "ABS"
0B3131 41 
0B3132 42 
0B3133 53 
0B3134 95    0365** DB    95H, "ACS"
0B3135 41 
0B3136 43 
0B3137 53 
0B3138 96    0366** DB    96H, "ADVAL"
0B3139 41 
0B313A 44 
0B313B 56 
0B313B 41   
0B313C 4C 
0B313E 97    0367** DB    97H, "ASC"
0B313F 41 
0B3140 53 
0B3141 43 
0B3142 98    0368** DB    98H, "ASN"
0B3143 41 
0B3144 53 
0B3145 4E 
0B3146 99    0369** DB    99H, "ATN"
0B3147 41 
0B3148 54 
0B3149 4E 
0B314A C6    0370** DB    C6H, "AUTO"
0B314B 41 
0B314C 55 
0B314D 54 
0B314D 4F   
0B314F 9A    0371** DB    9AH, "BGET", 0
0B3150 42 
0B3151 47 
0B3152 45 
0B3152 54   
0B3153 00 
0B3155 D5    0372** DB    D5H, "BPUT", 0
0B3156 42 
0B3157 50 
0B3158 55 
0B3158 54   
0B3159 00 
0B315B FB    0373** DB    FBH, "COLOUR"
0B315C 43 
0B315D 4F 
0B315E 4C 
0B315E 4F   
0B315F 55 
0B3160 52 
0B3162 FB    0374** DB    FBH, "COLOR"
0B3163 43 
0B3164 4F 
0B3165 4C 
0B3165 4F   
0B3166 52 
0B3168 D6    0375** DB    D6H, "CALL"
0B3169 43 
0B316A 41 
0B316B 4C 
0B316B 4C   
0B316D D7    0376** DB    D7H, "CHAIN"
0B316E 43 
0B316F 48 
0B3170 41 
0B3170 49   
0B3171 4E 
0B3173 BD    0377** DB    BDH, "CHR$"
0B3174 43 
0B3175 48 
0B3176 52 
0B3176 24   
0B3178 D8    0378** DB    D8H, "CLEAR", 0
0B3179 43 
0B317A 4C 
0B317B 45 
0B317B 41   
0B317C 52 
0B317D 00 
0B317F D9    0379** DB    D9H, "CLOSE", 0
0B3180 43 
0B3181 4C 
0B3182 4F 
0B3182 53   
0B3183 45 
0B3184 00 
0B3186 DA    0380** DB    DAH, "CLG", 0
0B3187 43 
0B3188 4C 
0B3189 47 
0B3189 00   
0B318B DB    0381** DB    DBH, "CLS", 0
0B318C 43 
0B318D 4C 
0B318E 53 
0B318E 00   
0B3190 9B    0382** DB    9BH, "COS"
0B3191 43 
0B3192 4F 
0B3193 53 
0B3194 9C    0383** DB    9CH, "COUNT", 0
0B3195 43 
0B3196 4F 
0B3197 55 
0B3197 4E   
0B3198 54 
0B3199 00 
0B319B DC    0384** DB    DCH, "DATA"
0B319C 44 
0B319D 41 
0B319E 54 
0B319E 41   
0B31A0 9D    0385** DB    9DH, "DEG"
0B31A1 44 
0B31A2 45 
0B31A3 47 
0B31A4 DD    0386** DB    DDH, "DEF"
0B31A5 44 
0B31A6 45 
0B31A7 46 
0B31A8 C7    0387** DB    C7H, "DELETE"
0B31A9 44 
0B31AA 45 
0B31AB 4C 
0B31AB 45   
0B31AC 54 
0B31AD 45 
0B31AF 81    0388** DB    81H, "DIV"
0B31B0 44 
0B31B1 49 
0B31B2 56 
0B31B3 DE    0389** DB    DEH, "DIM"
0B31B4 44 
0B31B5 49 
0B31B6 4D 
0B31B7 DF    0390** DB    DFH, "DRAW"
0B31B8 44 
0B31B9 52 
0B31BA 41 
0B31BA 57   
0B31BC E1    0391** DB    E1H, "ENDPROC", 0
0B31BD 45 
0B31BE 4E 
0B31BF 44 
0B31BF 50   
0B31C0 52 
0B31C1 4F 
0B31C2 43 
0B31C2 00   
0B31C5 E0    0392** DB    E0H, "END", 0
0B31C6 45 
0B31C7 4E 
0B31C8 44 
0B31C8 00   
0B31CA E2    0393** DB    E2H, "ENVELOPE"
0B31CB 45 
0B31CC 4E 
0B31CD 56 
0B31CD 45   
0B31CE 4C 
0B31CF 4F 
0B31D0 50 
0B31D0 45   
0B31D3 8B    0394** DB    8BH, "ELSE"
0B31D4 45 
0B31D5 4C 
0B31D6 53 
0B31D6 45   
0B31D8 A0    0395** DB    A0H, "EVAL"
0B31D9 45 
0B31DA 56 
0B31DB 41 
0B31DB 4C   
0B31DD 9E    0396** DB    9EH, "ERL", 0
0B31DE 45 
0B31DF 52 
0B31E0 4C 
0B31E0 00   
0B31E2 85    0397** DB    85H, "ERROR"
0B31E3 45 
0B31E4 52 
0B31E5 52 
0B31E5 4F   
0B31E6 52 
0B31E8 C5    0398** DB    C5H, "EOF", 0
0B31E9 45 
0B31EA 4F 
0B31EB 46 
0B31EB 00   
0B31ED 82    0399** DB    82H, "EOR"
0B31EE 45 
0B31EF 4F 
0B31F0 52 
0B31F1 9F    0400** DB    9FH, "ERR", 0
0B31F2 45 
0B31F3 52 
0B31F4 52 
0B31F4 00   
0B31F6 A1    0401** DB    A1H, "EXP"
0B31F7 45 
0B31F8 58 
0B31F9 50 
0B31FA A2    0402** DB    A2H, "EXT", 0
0B31FB 45 
0B31FC 58 
0B31FD 54 
0B31FD 00   
0B31FF E3    0403** DB    E3H, "FOR"
0B3200 46 
0B3201 4F 
0B3202 52 
0B3203 A3    0404** DB    A3H, "FALSE", 0
0B3204 46 
0B3205 41 
0B3206 4C 
0B3206 53   
0B3207 45 
0B3208 00 
0B320A A4    0405** DB    A4H, "FN"
0B320B 46 
0B320C 4E 
0B320D E5    0406** DB    E5H, "GOTO"
0B320E 47 
0B320F 4F 
0B3210 54 
0B3210 4F   
0B3212 BE    0407** DB    BEH, "GET$"
0B3213 47 
0B3214 45 
0B3215 54 
0B3215 24   
0B3217 A5    0408** DB    A5H, "GET"
0B3218 47 
0B3219 45 
0B321A 54 
0B321B E4    0409** DB    E4H, "GOSUB"
0B321C 47 
0B321D 4F 
0B321E 53 
0B321E 55   
0B321F 42 
0B3221 E6    0410** DB    E6H, "GCOL"
0B3222 47 
0B3223 43 
0B3224 4F 
0B3224 4C   
0B3226 93    0411** DB    93H, "HIMEM", 0
0B3227 48 
0B3228 49 
0B3229 4D 
0B3229 45   
0B322A 4D 
0B322B 00 
0B322D E8    0412** DB    E8H, "INPUT"
0B322E 49 
0B322F 4E 
0B3230 50 
0B3230 55   
0B3231 54 
0B3233 E7    0413** DB    E7H, "IF"
0B3234 49 
0B3235 46 
0B3236 BF    0414** DB    BFH, "INKEY$"
0B3237 49 
0B3238 4E 
0B3239 4B 
0B3239 45   
0B323A 59 
0B323B 24 
0B323D A6    0415** DB    A6H, "INKEY"
0B323E 49 
0B323F 4E 
0B3240 4B 
0B3240 45   
0B3241 59 
0B3243 A8    0416** DB    A8H, "INT"
0B3244 49 
0B3245 4E 
0B3246 54 
0B3247 A7    0417** DB    A7H, "INSTR("
0B3248 49 
0B3249 4E 
0B324A 53 
0B324A 54   
0B324B 52 
0B324C 28 
0B324E C9    0418** DB    C9H, "LIST"
0B324F 4C 
0B3250 49 
0B3251 53 
0B3251 54   
0B3253 86    0419** DB    86H, "LINE"
0B3254 4C 
0B3255 49 
0B3256 4E 
0B3256 45   
0B3258 C8    0420** DB    C8H, "LOAD"
0B3259 4C 
0B325A 4F 
0B325B 41 
0B325B 44   
0B325D 92    0421** DB    92H, "LOMEM", 0
0B325E 4C 
0B325F 4F 
0B3260 4D 
0B3260 45   
0B3261 4D 
0B3262 00 
0B3264 EA    0422** DB    EAH, "LOCAL"
0B3265 4C 
0B3266 4F 
0B3267 43 
0B3267 41   
0B3268 4C 
0B326A C0    0423** DB    C0H, "LEFT$("
0B326B 4C 
0B326C 45 
0B326D 46 
0B326D 54   
0B326E 24 
0B326F 28 
0B3271 A9    0424** DB    A9H, "LEN"
0B3272 4C 
0B3273 45 
0B3274 4E 
0B3275 E9    0425** DB    E9H, "LET"
0B3276 4C 
0B3277 45 
0B3278 54 
0B3279 AB    0426** DB    ABH, "LOG"
0B327A 4C 
0B327B 4F 
0B327C 47 
0B327D AA    0427** DB    AAH, "LN"
0B327E 4C 
0B327F 4E 
0B3280 C1    0428** DB    C1H, "MID$("
0B3281 4D 
0B3282 49 
0B3283 44 
0B3283 24   
0B3284 28 
0B3286 EB    0429** DB    EBH, "MODE"
0B3287 4D 
0B3288 4F 
0B3289 44 
0B3289 45   
0B328B 83    0430** DB    83H, "MOD"
0B328C 4D 
0B328D 4F 
0B328E 44 
0B328F EC    0431** DB    ECH, "MOVE"
0B3290 4D 
0B3291 4F 
0B3292 56 
0B3292 45   
0B3294 ED    0432** DB    EDH, "NEXT"
0B3295 4E 
0B3296 45 
0B3297 58 
0B3297 54   
0B3299 CA    0433** DB    CAH, "NEW", 0
0B329A 4E 
0B329B 45 
0B329C 57 
0B329C 00   
0B329E AC    0434** DB    ACH, "NOT"
0B329F 4E 
0B32A0 4F 
0B32A1 54 
0B32A2 CB    0435** DB    CBH, "OLD", 0
0B32A3 4F 
0B32A4 4C 
0B32A5 44 
0B32A5 00   
0B32A7 EE    0436** DB    EEH, "ON"
0B32A8 4F 
0B32A9 4E 
0B32AA 87    0437** DB    87H, "OFF"
0B32AB 4F 
0B32AC 46 
0B32AD 46 
0B32AE 84    0438** DB    84H, "OR"
0B32AF 4F 
0B32B0 52 
0B32B1 8E    0439** DB    8EH, "OPENIN"
0B32B2 4F 
0B32B3 50 
0B32B4 45 
0B32B4 4E   
0B32B5 49 
0B32B6 4E 
0B32B8 AE    0440** DB    AEH, "OPENOUT"
0B32B9 4F 
0B32BA 50 
0B32BB 45 
0B32BB 4E   
0B32BC 4F 
0B32BD 55 
0B32BE 54 
0B32C0 AD    0441** DB    ADH, "OPENUP"
0B32C1 4F 
0B32C2 50 
0B32C3 45 
0B32C3 4E   
0B32C4 55 
0B32C5 50 
0B32C7 FF    0442** DB    FFH, "OSCLI"
0B32C8 4F 
0B32C9 53 
0B32CA 43 
0B32CA 4C   
0B32CB 49 
0B32CD F1    0443** DB    F1H, "PRINT"
0B32CE 50 
0B32CF 52 
0B32D0 49 
0B32D0 4E   
0B32D1 54 
0B32D3 90    0444** DB    90H, "PAGE", 0
0B32D4 50 
0B32D5 41 
0B32D6 47 
0B32D6 45   
0B32D7 00 
0B32D9 8F    0445** DB    8FH, "PTR", 0
0B32DA 50 
0B32DB 54 
0B32DC 52 
0B32DC 00   
0B32DE AF    0446** DB    AFH, "PI", 0
0B32DF 50 
0B32E0 49 
0B32E1 00 
0B32E2 F0    0447** DB    F0H, "PLOT"
0B32E3 50 
0B32E4 4C 
0B32E5 4F 
0B32E5 54   
0B32E7 B0    0448** DB    B0H, "POINT("
0B32E8 50 
0B32E9 4F 
0B32EA 49 
0B32EA 4E   
0B32EB 54 
0B32EC 28 
0B32EE F2    0449** DB    F2H, "PROC"
0B32EF 50 
0B32F0 52 
0B32F1 4F 
0B32F1 43   
0B32F3 B1    0450** DB    B1H, "POS", 0
0B32F4 50 
0B32F5 4F 
0B32F6 53 
0B32F6 00   
0B32F8 CE    0451** DB    CEH, "PUT"
0B32F9 50 
0B32FA 55 
0B32FB 54 
0B32FC F8    0452** DB    F8H, "RETURN", 0
0B32FD 52 
0B32FE 45 
0B32FF 54 
0B32FF 55   
0B3300 52 
0B3301 4E 
0B3302 00 
0B3304 F5    0453** DB    F5H, "REPEAT"
0B3305 52 
0B3306 45 
0B3307 50 
0B3307 45   
0B3308 41 
0B3309 54 
0B330B F6    0454** DB    F6H, "REPORT", 0
0B330C 52 
0B330D 45 
0B330E 50 
0B330E 4F   
0B330F 52 
0B3310 54 
0B3311 00 
0B3313 F3    0455** DB    F3H, "READ"
0B3314 52 
0B3315 45 
0B3316 41 
0B3316 44   
0B3318 F4    0456** DB    F4H, "REM"
0B3319 52 
0B331A 45 
0B331B 4D 
0B331C F9    0457** DB    F9H, "RUN", 0
0B331D 52 
0B331E 55 
0B331F 4E 
0B331F 00   
0B3321 B2    0458** DB    B2H, "RAD"
0B3322 52 
0B3323 41 
0B3324 44 
0B3325 F7    0459** DB    F7H, "RESTORE"
0B3326 52 
0B3327 45 
0B3328 53 
0B3328 54   
0B3329 4F 
0B332A 52 
0B332B 45 
0B332D C2    0460** DB    C2H, "RIGHT$("
0B332E 52 
0B332F 49 
0B3330 47 
0B3330 48   
0B3331 54 
0B3332 24 
0B3333 28 
0B3335 B3    0461** DB    B3H, "RND", 0
0B3336 52 
0B3337 4E 
0B3338 44 
0B3338 00   
0B333A CC    0462** DB    CCH, "RENUMBER"
0B333B 52 
0B333C 45 
0B333D 4E 
0B333D 55   
0B333E 4D 
0B333F 42 
0B3340 45 
0B3340 52   
0B3343 88    0463** DB    88H, "STEP"
0B3344 53 
0B3345 54 
0B3346 45 
0B3346 50   
0B3348 CD    0464** DB    CDH, "SAVE"
0B3349 53 
0B334A 41 
0B334B 56 
0B334B 45   
0B334D B4    0465** DB    B4H, "SGN"
0B334E 53 
0B334F 47 
0B3350 4E 
0B3351 B5    0466** DB    B5H, "SIN"
0B3352 53 
0B3353 49 
0B3354 4E 
0B3355 B6    0467** DB    B6H, "SQR"
0B3356 53 
0B3357 51 
0B3358 52 
0B3359 89    0468** DB    89H, "SPC"
0B335A 53 
0B335B 50 
0B335C 43 
0B335D C3    0469** DB    C3H, "STR$"
0B335E 53 
0B335F 54 
0B3360 52 
0B3360 24   
0B3362 C4    0470** DB    C4H, "STRING$("
0B3363 53 
0B3364 54 
0B3365 52 
0B3365 49   
0B3366 4E 
0B3367 47 
0B3368 24 
0B3368 28   
0B336B D4    0471** DB    D4H, "SOUND"
0B336C 53 
0B336D 4F 
0B336E 55 
0B336E 4E   
0B336F 44 
0B3371 FA    0472** DB    FAH, "STOP", 0
0B3372 53 
0B3373 54 
0B3374 4F 
0B3374 50   
0B3375 00 
0B3377 B7    0473** DB    B7H, "TAN"
0B3378 54 
0B3379 41 
0B337A 4E 
0B337B 8C    0474** DB    8CH, "THEN"
0B337C 54 
0B337D 48 
0B337E 45 
0B337E 4E   
0B3380 B8    0475** DB    B8H, "TO"
0B3381 54 
0B3382 4F 
0B3383 8A    0476** DB    8AH, "TAB("
0B3384 54 
0B3385 41 
0B3386 42 
0B3386 28   
0B3388 FC    0477** DB    FCH, "TRACE"
0B3389 54 
0B338A 52 
0B338B 41 
0B338B 43   
0B338C 45 
0B338E 91    0478** DB    91H, "TIME", 0
0B338F 54 
0B3390 49 
0B3391 4D 
0B3391 45   
0B3392 00 
0B3394 B9    0479** DB    B9H, "TRUE", 0
0B3395 54 
0B3396 52 
0B3397 55 
0B3397 45   
0B3398 00 
0B339A FD    0480** DB    FDH, "UNTIL"
0B339B 55 
0B339C 4E 
0B339D 54 
0B339D 49   
0B339E 4C 
0B33A0 BA    0481** DB    BAH, "USR"
0B33A1 55 
0B33A2 53 
0B33A3 52 
0B33A4 EF    0482** DB    EFH, "VDU"
0B33A5 56 
0B33A6 44 
0B33A7 55 
0B33A8 BB    0483** DB    BBH, "VAL"
0B33A9 56 
0B33AA 41 
0B33AB 4C 
0B33AC BC    0484** DB    BCH, "VPOS", 0
0B33AD 56 
0B33AE 50 
0B33AF 4F 
0B33AF 53   
0B33B0 00 
0B33B2 FE    0485** DB    FEH, "WIDTH"
0B33B3 57 
0B33B4 49 
0B33B5 44 
0B33B5 54   
0B33B6 48 
0B33B8 D3    0486** DB    D3H, "HIMEM"
0B33B9 48 
0B33BA 49 
0B33BB 4D 
0B33BB 45   
0B33BC 4D 
0B33BE D2    0487** DB    D2H, "LOMEM"
0B33BF 4C 
0B33C0 4F 
0B33C1 4D 
0B33C1 45   
0B33C2 4D 
0B33C4 D0    0488** DB    D0H, "PAGE"
0B33C5 50 
0B33C6 41 
0B33C7 47 
0B33C7 45   
0B33C9 CF    0489** DB    CFH, "PTR"
0B33CA 50 
0B33CB 54 
0B33CC 52 
0B33CD D1    0490** DB    D1H, "TIME"
0B33CE 54 
0B33CF 49 
0B33D0 4D 
0B33D0 45   
             0491** ;
             0492** ; These are indexed from the ERRWDS table
             0493** ;
0B33D2 01    0494** DB    01H, "Missing "
0B33D3 4D 
0B33D4 69 
0B33D5 73 
0B33D5 73   
0B33D6 69 
0B33D7 6E 
0B33D8 67 
0B33D8 20   
0B33DB 02    0495** DB    02H, "No such "
0B33DC 4E 
0B33DD 6F 
0B33DE 20 
0B33DE 73   
0B33DF 75 
0B33E0 63 
0B33E1 68 
0B33E1 20   
0B33E4 03    0496** DB    03H, "Bad "
0B33E5 42 
0B33E6 61 
0B33E7 64 
0B33E7 20   
0B33E9 04    0497** DB    04H, " range"
0B33EA 20 
0B33EB 72 
0B33EC 61 
0B33EC 6E   
0B33ED 67 
0B33EE 65 
0B33F0 05    0498** DB    05H, "variable"
0B33F1 76 
0B33F2 61 
0B33F3 72 
0B33F3 69   
0B33F4 61 
0B33F5 62 
0B33F6 6C 
0B33F6 65   
0B33F9 06    0499** DB    06H, "Out of"
0B33FA 4F 
0B33FB 75 
0B33FC 74 
0B33FC 20   
0B33FD 6F 
0B33FE 66 
0B3400 07    0500** DB    07H, "No "
0B3401 4E 
0B3402 6F 
0B3403 20 
0B3404 08    0501** DB    08H, " space"
0B3405 20 
0B3406 73 
0B3407 70 
0B3407 61   
0B3408 63 
0B3409 65 
             0502** 
             0503** KEYWDL:			EQU     $-KEYWDS
0B340B FF    0504** DW    -1
0B340C FF 
             0505** ;
             0506** ; Error messages
             0507** ;
0B340D 07    0508** ERRWDS:			DB    7, "room", 0		;  0: No room
0B340E 72 
0B340F 6F 
0B3410 6F 
0B3410 6D   
0B3411 00 
0B3413 06    0509** DB    6, 4, 0			;  1: Out of range
0B3414 04 
0B3415 00 
0B3416 00    0510** DB    0				;  2: *
0B3417 00    0511** DB    0				;  3: *
0B3418 4D    0512** DB    "Mistake", 0		;  4: Mistake
0B3419 69 
0B341A 73 
0B341B 74 
0B341B 61   
0B341C 6B 
0B341D 65 
0B341E 00 
0B3420 01    0513** DB    1, ",", 0			;  5: Missing ,
0B3421 2C 
0B3422 00 
0B3423 54    0514** DB    "Type mismatch", 0	;  6: Type mismatch
0B3424 79 
0B3425 70 
0B3426 65 
0B3426 20   
0B3427 6D 
0B3428 69 
0B3429 73 
0B3429 6D   
0B342A 61 
0B342B 74 
0B342C 63 
0B342C 68   
0B342D 00 
0B3431 07    0515** DB    7, FN, 0			;  7: No FN
0B3432 A4 
0B3433 00 
0B3434 00    0516** DB    0				;  8: *
0B3435 01    0517** DB    1, 34, 0			;  9: Missing "
0B3436 22 
0B3437 00 
0B3438 03    0518** DB    3, DIM, 0			; 10: Bad DIM
0B3439 DE 
0B343A 00 
0B343B DE    0519** DB    DIM, 8, 0			; 11: DIM space
0B343C 08 
0B343D 00 
0B343E 4E    0520** DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
0B343F 6F 
0B3440 74 
0B3441 20 
0B3441 EA   
0B3442 00 
0B3444 07    0521** DB    7, PROC, 0		; 13: No PROC
0B3445 F2 
0B3446 00 
0B3447 41    0522** DB    "Array", 0		; 14: Array
0B3448 72 
0B3449 72 
0B344A 61 
0B344A 79   
0B344B 00 
0B344D 53    0523** DB    "Subscript", 0		; 15: Subscript
0B344E 75 
0B344F 62 
0B3450 73 
0B3450 63   
0B3451 72 
0B3452 69 
0B3453 70 
0B3453 74   
0B3454 00 
0B3457 53    0524** DB    "Syntax error", 0		; 16: Syntax error
0B3458 79 
0B3459 6E 
0B345A 74 
0B345A 61   
0B345B 78 
0B345C 20 
0B345D 65 
0B345D 72   
0B345E 72 
0B345F 6F 
0B3460 72 
0B3460 00   
0B3464 45    0525** DB    "Escape", 0		; 17: Escape
0B3465 73 
0B3466 63 
0B3467 61 
0B3467 70   
0B3468 65 
0B3469 00 
0B346B 44    0526** DB    "Division by zero", 0	; 18: Division by zero
0B346C 69 
0B346D 76 
0B346E 69 
0B346E 73   
0B346F 69 
0B3470 6F 
0B3471 6E 
0B3471 20   
0B3472 62 
0B3473 79 
0B3474 20 
0B3474 7A   
0B3475 65 
0B3476 72 
0B3477 6F 
0B3477 00   
0B347C 53    0527** DB    "String too long", 0	; 19: String too long
0B347D 74 
0B347E 72 
0B347F 69 
0B347F 6E   
0B3480 67 
0B3481 20 
0B3482 74 
0B3482 6F   
0B3483 6F 
0B3484 20 
0B3485 6C 
0B3485 6F   
0B3486 6E 
0B3487 67 
0B3488 00 
0B348C 54    0528** DB    "Too big", 0		; 20: Too big
0B348D 6F 
0B348E 6F 
0B348F 20 
0B348F 62   
0B3490 69 
0B3491 67 
0B3492 00 
0B3494 2D    0529** DB    "-ve root", 0		; 21: -ve root
0B3495 76 
0B3496 65 
0B3497 20 
0B3497 72   
0B3498 6F 
0B3499 6F 
0B349A 74 
0B349A 00   
0B349D 4C    0530** DB    "Log", 4, 0		; 22: Log range
0B349E 6F 
0B349F 67 
0B34A0 04 
0B34A0 00   
0B34A2 41    0531** DB    "Accuracy lost", 0	; 23: Accuracy lost
0B34A3 63 
0B34A4 63 
0B34A5 75 
0B34A5 72   
0B34A6 61 
0B34A7 63 
0B34A8 79 
0B34A8 20   
0B34A9 6C 
0B34AA 6F 
0B34AB 73 
0B34AB 74   
0B34AC 00 
0B34B0 45    0532** DB    "Exp", 4, 0		; 24: Exp range
0B34B1 78 
0B34B2 70 
0B34B3 04 
0B34B3 00   
0B34B5 00    0533** DB    0				; 25: *
0B34B6 02    0534** DB    2, 5, 0			; 26: No such variable
0B34B7 05 
0B34B8 00 
0B34B9 01    0535** DB    1, ")", 0			; 27: Missing )
0B34BA 29 
0B34BB 00 
0B34BC 03    0536** DB    3, "HEX", 0		; 28: Bad HEX
0B34BD 48 
0B34BE 45 
0B34BF 58 
0B34BF 00   
0B34C1 02    0537** DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
0B34C2 A4 
0B34C3 2F 
0B34C4 F2 
0B34C4 00   
0B34C6 03    0538** DB    3, "call", 0		; 30: Bad call
0B34C7 63 
0B34C8 61 
0B34C9 6C 
0B34C9 6C   
0B34CA 00 
0B34CC 41    0539** DB    "Arguments", 0		; 31: Arguments
0B34CD 72 
0B34CE 67 
0B34CF 75 
0B34CF 6D   
0B34D0 65 
0B34D1 6E 
0B34D2 74 
0B34D2 73   
0B34D3 00 
0B34D6 07    0540** DB    7, FOR, 0			; 32: No FOR
0B34D7 E3 
0B34D8 00 
0B34D9 43    0541** DB    "Can't match ", FOR, 0	; 33: Can't match FOR
0B34DA 61 
0B34DB 6E 
0B34DC 27 
0B34DC 74   
0B34DD 20 
0B34DE 6D 
0B34DF 61 
0B34DF 74   
0B34E0 63 
0B34E1 68 
0B34E2 20 
0B34E2 E3   
0B34E3 00 
0B34E7 E3    0542** DB    FOR, " ", 5, 0		; 34: FOR variable
0B34E8 20 
0B34E9 05 
0B34EA 00 
0B34EB 00    0543** DB    0				; 35: *
0B34EC 07    0544** DB    7, TO_MN, 0			; 36: No TO
0B34ED B8 
0B34EE 00 
0B34EF 00    0545** DB    0				; 37: *
0B34F0 07    0546** DB    7, GOSUB, 0		; 38: No GOSUB
0B34F1 E4 
0B34F2 00 
0B34F3 EE    0547** DB    ON_, " syntax", 0		; 39: ON syntax
0B34F4 20 
0B34F5 73 
0B34F6 79 
0B34F6 6E   
0B34F7 74 
0B34F8 61 
0B34F9 78 
0B34F9 00   
0B34FC EE    0548** DB    ON_, 4, 0			; 40: ON range
0B34FD 04 
0B34FE 00 
0B34FF 02    0549** DB    2, "line", 0		; 41: No such line
0B3500 6C 
0B3501 69 
0B3502 6E 
0B3502 65   
0B3503 00 
0B3505 06    0550** DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
0B3506 20 
0B3507 DC 
0B3508 00 
0B3509 07    0551** DB    7, REPEAT, 0		; 43: No REPEAT
0B350A F5 
0B350B 00 
0B350C 00    0552** DB    0				; 44: *
0B350D 01    0553** DB    1, "#", 0			; 45: Missing #
0B350E 23 
0B350F 00 
             0554** ;
             0555** ; COMMANDS:
             0556** ;
             0557** ; DELETE line,line
             0558** ;
0B3510 CD    0559** DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0B3511 0F 
0B3512 38 
0B3513 0B 
0B3514 CD    0560** CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B3515 17 
0B3516 3C 
0B3517 0B 
0B3518 7E    0561** DELET1:			LD      A,(HL)			; Check whether it's the last line
0B3519 B7    0562** OR      A
0B351A CA    0563** JP      Z,WARMNC		; Yes, so do nothing
0B351B A1 
0B351C 35 
0B351D 0B 
0B351E 23    0564** INC     HL			; Skip the line length byte
0B351F 11    0565** LD	DE, 0			; Clear DE
0B3520 00 
0B3521 00 
0B3522 00 
0B3523 5E    0566** LD      E,(HL)			; Fetch the line number in DE
0B3524 23    0567** INC     HL
0B3525 56    0568** LD      D,(HL)
0B3526 7A    0569** LD      A,D			; If the line number is zero then
0B3527 B3    0570** OR      E
0B3528 28    0571** JR      Z,CLOOP1        	; Do nothing
0B3529 1D 
0B352A 2B    0572** DEC     HL			; Decrement BASIC program pointer back to length
0B352B 2B    0573** DEC     HL
0B352C EB    0574** EX      DE,HL			; Check if we've gone past the terminating line
0B352D 37    0575** SCF
0B352E ED    0576** SBC     HL,BC
0B352F 42 
0B3530 EB    0577** EX      DE,HL
0B3531 30    0578** JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0B3532 6E 
0B3533 C5    0579** PUSH    BC
0B3534 CD    0580** CALL    DEL			; Delete the line pointed to by HL
0B3535 C6 
0B3536 37 
0B3537 0B 
0B3538 C1    0581** POP     BC
0B3539 18    0582** JR      DELET1			; And loop round to the next line
0B353A DD 
             0583** ;
             0584** ; LISTO expr
             0585** ;
0B353B FD    0586** LISTO:			INC     IY              	; Skip "O" byte
0B353C 23 
0B353D CD    0587** CALL    EXPRI			; Get expr
0B353E CE 
0B353F 02 
0B3540 0B 
0B3541 D9    0588** EXX
0B3542 7D    0589** LD      A,L
0B3543 32    0590** LD      (LISTON),A		; Store in LISTON sysvar
0B3544 40 
0B3545 5E 
0B3546 0B 
0B3547 C3    0591** CLOOP1:			JP      CLOOP
0B3548 44 
0B3549 30 
0B354A 0B 
             0592** ;
             0593** ; LIST
             0594** ; LIST line
             0595** ; LIST line,line [IF string]
             0596** ; LIST ,line
             0597** ; LIST line,
             0598** ;
0B354B FE    0599** LIST_:			CP      'O'			; Check for O (LISTO)
0B354C 4F 
0B354D 28    0600** JR      Z,LISTO			; and jump to LISTO if zero
0B354E EC 
0B354F CD    0601** CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B3550 17 
0B3551 3C 
0B3552 0B 
0B3553 CD    0602** CALL    NXT			; Skip space
0B3554 34 
0B3555 0A 
0B3556 0B 
0B3557 FE    0603** CP      TIF             	; Check for IF clause (token IF)
0B3558 E7 
0B3559 3E    0604** LD      A,0             	; Initialise the IF clause string length
0B355A 00 
0B355B 20    0605** JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0B355C 17 
             0606** ;
0B355D FD    0607** INC     IY              	; Skip the IF token
0B355E 23 
0B355F CD    0608** CALL    NXT             	; And skip any spaces
0B3560 34 
0B3561 0A 
0B3562 0B 
0B3563 EB    0609** EX      DE,HL			; DE: Address in memory
0B3564 FD    0610** PUSH    IY			; LD IY, HL
0B3565 E5 
0B3566 E1    0611** POP     HL              	; HL is now the address of the tokenised line
0B3567 3E    0612** LD      A,CR
0B3568 0D 
0B3569 C5    0613** PUSH    BC			; Stack the second line number arg
0B356A 01    0614** LD      BC,256
0B356B 00 
0B356C 01 
0B356D 00 
0B356E ED    0615** CPIR                    	; Locate CR byte
0B356F B1 
0B3570 79    0616** LD      A,C
0B3571 2F    0617** CPL                    	 	; A: Substring length (of IF clause)
0B3572 C1    0618** POP     BC			; Restore the second line number arg
0B3573 EB    0619** EX      DE,HL			; HL: Address in memory
             0620** ;
0B3574 5F    0621** LISTB:			LD      E,A             	; E: IF clause string length
0B3575 78    0622** LD      A,B			; Check whether a second line number was passed (BC!=0)
0B3576 B1    0623** OR      C
0B3577 20    0624** JR      NZ,LISTA		; If there isn't a second line number
0B3578 01 
0B3579 0B    0625** DEC     BC			; then we set it to the maximum of 65535
             0626** ;
0B357A D9    0627** LISTA:			EXX
0B357B DD    0628** LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
0B357C 21 
0B357D 40 
0B357E 5E 
0B357E 0B   
0B3580 01    0629** LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0B3581 00 
0B3582 00 
0B3583 00 
0B3584 D9    0630** EXX
0B3585 3E    0631** LD      A,20			; Number of lines to list
0B3586 14 
             0632** ;
0B3587 C5    0633** LISTC:			PUSH    BC              	; Save second line number
0B3588 D5    0634** PUSH    DE              	; Save IF clause length
0B3589 E5    0635** PUSH    HL              	; Save BASIC program counter
0B358A 08    0636** EX      AF,AF'
             0637** ;
             0638** ; BBC BASIC for Z80 lines are stored as follows:
             0639** ;
             0640** ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
             0641** ; - [&00] [&FF] [&FF]: End of program marker
             0642** ;
             0643** ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
             0644** ;
0B358B 7E    0645** LD      A,(HL)			; Check for end of program marker
0B358C B7    0646** OR      A			; If found
0B358D 28    0647** JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0B358E 12 
             0648** ;
             0649** ; Check if past terminating line number
             0650** ;
0B358F 7B    0651** LD      A,E             	; A: IF clause length
0B3590 23    0652** INC     HL			; Skip the length byte
0B3591 11    0653** LD	DE,0			; Clear DE
0B3592 00 
0B3593 00 
0B3594 00 
0B3595 5E    0654** LD      E,(HL)			; Fetch the line number in DE
0B3596 23    0655** INC     HL
0B3597 56    0656** LD      D,(HL)
0B3598 2B    0657** DEC     HL			; Step HL back to the length byte
0B3599 2B    0658** DEC     HL
0B359A D5    0659** PUSH    DE             	 	; Push the line number on the stack
0B359B EB    0660** EX      DE,HL			; HL: line number
0B359C 37    0661** SCF				; Do a 16-bit compare of HL and DE
0B359D ED    0662** SBC     HL,BC
0B359E 42 
0B359F EB    0663** EX      DE,HL
0B35A0 D1    0664** POP     DE              	; Restore the line number
0B35A1 D2    0665** WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0B35A2 43 
0B35A3 30 
0B35A4 0B 
0B35A5 4E    0666** LD      C,(HL)          	; C: Line length + 4
0B35A6 47    0667** LD      B,A             	; B: IF clause length
             0668** ;
             0669** ; Check if "UNLISTABLE":
             0670** ;
0B35A7 7A    0671** LD      A,D			; TODO: What is "UNLISTABLE?"
0B35A8 B3    0672** OR      E
0B35A9 CA    0673** JP      Z,CLOOP
0B35AA 44 
0B35AB 30 
0B35AC 0B 
             0674** ;
             0675** ; Check for IF clause:
             0676** ;
0B35AD 23    0677** INC     HL			; Skip the length
0B35AE 23    0678** INC     HL			; Skip the line number
0B35AF 23    0679** INC     HL              	; HL: Address of the tokenised BASIC line
0B35B0 0D    0680** DEC     C			;  C: Line length
0B35B1 0D    0681** DEC     C
0B35B2 0D    0682** DEC     C
0B35B3 0D    0683** DEC     C
0B35B4 D5    0684** PUSH    DE              	; Save the line number
0B35B5 E5    0685** PUSH    HL              	; Save the BASIC program address
0B35B6 AF    0686** XOR     A               	;
0B35B7 B8    0687** CP      B              	 	; Check for an IF clause (B!=0)
0B35B8 FD    0688** PUSH    IY			; LD IY, DE
0B35B9 E5 
0B35BA D1    0689** POP     DE              	; DE: Address of the IF clause string in the input buffer
0B35BB C4    0690** CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0B35BC 49 
0B35BD 07 
0B35BE 0B 
0B35BF E1    0691** POP     HL              	; Restore BASIC program address
0B35C0 D1    0692** POP     DE              	; Restore line number
0B35C1 FD    0693** PUSH    IY
0B35C2 E5 
0B35C3 CC    0694** CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
0B35C4 56 
0B35C5 38 
0B35C6 0B 
0B35C7 FD    0695** POP     IY
0B35C8 E1 
             0696** ;
0B35C9 08    0697** EX      AF,AF'
0B35CA 3D    0698** DEC     A			; Decrement line list counter
0B35CB CD    0699** CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
0B35CC 35 
0B35CD 3F 
0B35CE 0B 
0B35CF E1    0700** POP     HL             	 	; Restore BASIC program address to beginning of line
0B35D0 11    0701** LD	DE,0
0B35D1 00 
0B35D2 00 
0B35D3 00 
0B35D4 5E    0702** LD      E,(HL)			; Fetch the length of line in DE
0B35D5 19    0703** ADD     HL,DE           	; Go to the next line
0B35D6 D1    0704** POP     DE              	; Restore IF clause length
0B35D7 C1    0705** POP     BC              	; Restore second line number
0B35D8 18    0706** JR      LISTC			; Loop back to do next line
0B35D9 AD 
             0707** ;
             0708** ; RENUMBER
             0709** ; RENUMBER start
             0710** ; RENUMBER start,increment
             0711** ; RENUMBER ,increment
             0712** ;
0B35DA CD    0713** RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
0B35DB 3A 
0B35DC 38 
0B35DD 0B 
0B35DE CD    0714** CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
0B35DF EF 
0B35E0 3B 
0B35E1 0B 
0B35E2 D9    0715** EXX
0B35E3 2A    0716** LD      HL,(PAGE_)		; HL: Top of program
0B35E4 14 
0B35E5 5E 
0B35E6 0B 
0B35E7 ED    0717** LD      DE,(LOMEM)		; DE: Start address of the heap
0B35E8 5B 
0B35E9 1A 
0B35EA 5E 
0B35EA 0B   
             0718** ;
             0719** ; Build the table
             0720** ;
0B35EC 7E    0721** RENUM1:			LD      A,(HL)          	; Fetch the line length byte
0B35ED B7    0722** OR      A			; Is it zero, i.e. the end of program marker?
0B35EE 28    0723** JR      Z,RENUM2		; Yes, so skip to the next part
0B35EF 36 
0B35F0 23    0724** INC     HL
0B35F1 4E    0725** LD      C,(HL)          	; BC: The OLD line number
0B35F2 23    0726** INC     HL
0B35F3 46    0727** LD      B,(HL)
0B35F4 78    0728** LD      A,B			; Check whether the line number is zero - we only need to check the LSW
0B35F5 B1    0729** OR      C
0B35F6 CA    0730** JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
0B35F7 44 
0B35F8 30 
0B35F9 0B 
0B35FA EB    0731** EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B35FB 71    0732** LD      (HL),C			; Store the OLD line number in the heap
0B35FC 23    0733** INC     HL
0B35FD 70    0734** LD      (HL),B
0B35FE 23    0735** INC     HL
0B35FF D9    0736** EXX				; HL: line number, BC: increment (16-bit values)
0B3600 E5    0737** PUSH    HL			; HL: Stack the NEW line number value
0B3601 52    0738** ADD.S   HL,BC           	; Add the increment
0B3602 09 
0B3603 DA    0739** JP      C,TOOBIG        	; If > 65535, then error: "Too big"
0B3604 E9 
0B3605 3B 
0B3606 0B 
0B3607 D9    0740** EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
0B3608 C1    0741** POP     BC			; BC: Pop the NEW line number value off the stack
0B3609 71    0742** LD      (HL),C			; Store the NEW line number in the heap
0B360A 23    0743** INC     HL
0B360B 70    0744** LD      (HL),B
0B360C 23    0745** INC     HL
0B360D EB    0746** EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B360E 2B    0747** DEC     HL			; Back up to the line length byte
0B360F 2B    0748** DEC     HL
0B3610 01    0749** LD	BC, 0
0B3611 00 
0B3612 00 
0B3613 00 
0B3614 4E    0750** LD      C,(HL)			; BC: Line length
0B3615 09    0751** ADD	HL,BC           	; Advance HL to next line
0B3616 EB    0752** EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B3617 E5    0753** PUSH    HL
0B3618 24    0754** INC     H			; Increment to next page
0B3619 ED    0755** SBC     HL,SP			; Subtract from SP
0B361A 72 
0B361B E1    0756** POP     HL
0B361C EB    0757** EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B361D 38    0758** JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0B361E CD 
0B361F CD    0759** CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0B3620 3B 
0B3621 37 
0B3622 0B 
0B3623 CC    0760** DB    	REN
0B3624 08    0761** DB    	8
0B3625 00    0762** DB    	0
             0763** ;
             0764** ; At this point a list of BASIC line numbers have been written to the heap
             0765** ; as word pairs:
             0766** ; - DW: The OLD line number
             0767** ; - DW: The NEW line number
             0768** ;
0B3626 EB    0769** RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0B3627 36    0770** LD      (HL),-1			; Mark the end with FFFFh
0B3628 FF 
0B3629 23    0771** INC     HL
0B362A 36    0772** LD      (HL),-1
0B362B FF 
0B362C ED    0773** LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
0B362D 5B 
0B362E 1A 
0B362F 5E 
0B362F 0B   
0B3631 D9    0774** EXX
0B3632 2A    0775** LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0B3633 14 
0B3634 5E 
0B3635 0B 
0B3636 4E    0776** RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0B3637 79    0777** LD      A,C			; If it is zero, then no program, so...
0B3638 B7    0778** OR      A
0B3639 CA    0779** JP      Z,WARM			; Jump to warm start
0B363A 43 
0B363B 30 
0B363C 0B 
0B363D D9    0780** EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0B363E EB    0781** EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0B363F 23    0782** INC     HL			; Skip to the NEW line number
0B3640 23    0783** INC     HL
0B3641 5E    0784** LD      E,(HL)			; DE: The NEW line number
0B3642 23    0785** INC     HL
0B3643 56    0786** LD      D,(HL)
0B3644 23    0787** INC     HL
0B3645 D5    0788** PUSH    DE			; Stack the NEW line number
0B3646 EB    0789** EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0B3647 22    0790** LD      (LINENO),HL		; Store the line number in LINENO
0B3648 23 
0B3649 5E 
0B364A 0B 
0B364B D9    0791** EXX				; HL: Pointer to the BASIC program area
0B364C D1    0792** POP     DE			; DE: The NEW line number
0B364D 23    0793** INC     HL
0B364E 73    0794** LD      (HL),E          	; Write out the NEW line number to the BASIC program
0B364F 23    0795** INC     HL
0B3650 72    0796** LD      (HL),D
0B3651 23    0797** INC     HL
0B3652 0D    0798** DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0B3653 0D    0799** DEC     C
0B3654 0D    0800** DEC     C
0B3655 79    0801** LD	A,C
0B3656 01    0802** LD	BC,0
0B3657 00 
0B3658 00 
0B3659 00 
0B365A 4F    0803** LD	C,A			; BC: Line length
             0804** ;
0B365B 3E    0805** RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0B365C 8D 
0B365D ED    0806** CPIR                    	; Search for the token
0B365E B1 
0B365F 20    0807** JR      NZ,RENUM3		; If not found, then loop to process the next line
0B3660 D5 
             0808** ;
             0809** ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
             0810** ;
0B3661 C5    0811** PUSH    BC			; Stack everything
0B3662 E5    0812** PUSH    HL
0B3663 E5    0813** PUSH    HL			; HL: Pointer to encoded line number
0B3664 FD    0814** POP     IY			; IY: Pointer to encoded line number
0B3665 E1 
0B3666 D9    0815** EXX
0B3667 CD    0816** CALL    DECODE			; Decode the encoded line number (in HL')
0B3668 AA 
0B3669 08 
0B366A 0B 
0B366B D9    0817** EXX				; HL: Decoded line number
0B366C 44    0818** LD      B,H			; BC: Decoded line number
0B366D 4D    0819** LD      C,L
0B366E 2A    0820** LD      HL,(LOMEM)		; HL: Pointer to heap
0B366F 1A 
0B3670 5E 
0B3671 0B 
             0821** ;
             0822** ; This section of code cross-references the decoded (OLD) line number with the list
             0823** ; created previously in the global heap
             0824** ;
0B3672 5E    0825** RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0B3673 23    0826** INC     HL
0B3674 56    0827** LD      D,(HL)
0B3675 23    0828** INC     HL
0B3676 EB    0829** EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0B3677 B7    0830** OR      A               	; Clear the carry and...
0B3678 52    0831** SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0B3679 ED 
0B367A 42 
0B367B EB    0832** EX      DE,HL			; HL: Pointer in the global heap
0B367C 5E    0833** LD      E,(HL)          	; DE: The NEW line number
0B367D 23    0834** INC     HL
0B367E 56    0835** LD      D,(HL)
0B367F 23    0836** INC     HL
0B3680 38    0837** JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0B3681 F0 
0B3682 EB    0838** EX      DE,HL			; DE: Pointer in the global heap
0B3683 28    0839** JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0B3684 1D 
             0840** ;
0B3685 CD    0841** CALL    TELL			; Display this error if the line number is not found
0B3686 54 
0B3687 3D 
0B3688 0B 
0B3689 46    0842** DB    	"Failed at "
0B368A 61 
0B368B 69 
0B368C 6C 
0B368C 65   
0B368D 64 
0B368E 20 
0B368F 61 
0B368F 74   
0B3690 20 
0B3693 00    0843** DB    	0
0B3694 2A    0844** LD      HL,(LINENO)
0B3695 23 
0B3696 5E 
0B3697 0B 
0B3698 CD    0845** CALL    PBCDL
0B3699 BB 
0B369A 39 
0B369B 0B 
0B369C CD    0846** CALL    CRLF
0B369D 0B 
0B369E 39 
0B369F 0B 
0B36A0 18    0847** JR      RENUM6			; And carry on renumbering
0B36A1 07 
             0848** ;
             0849** ; This snippet re-encodes the line number in the BASIC program
             0850** ;
0B36A2 D1    0851** RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0B36A3 D5    0852** PUSH    DE
0B36A4 1B    0853** DEC     DE			; Back up a byte to the LINO token
0B36A5 CD    0854** CALL    ENCODE          	; Re-write the new line number out
0B36A6 20 
0B36A7 3D 
0B36A8 0B 
0B36A9 E1    0855** RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0B36AA C1    0856** POP     BC			; BC: The remaining line length
0B36AB 18    0857** JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0B36AC AE 
             0858** ;
             0859** ; AUTO
             0860** ; AUTO start,increment
             0861** ; AUTO start
             0862** ; AUTO ,increment
             0863** ;
0B36AD CD    0864** AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0B36AE EF 
0B36AF 3B 
0B36B0 0B 
0B36B1 22    0865** LD      (AUTONO),HL		; Store the start in AUTONO
0B36B2 29 
0B36B3 5E 
0B36B4 0B 
0B36B5 79    0866** LD      A,C			; Increment is 8 bit (0-255)
0B36B6 32    0867** LD      (INCREM),A		; Store that in INCREM
0B36B7 41 
0B36B8 5E 
0B36B9 0B 
0B36BA 18    0868** JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B36BB 2E 
             0869** ;
             0870** ; BAD
             0871** ; NEW
             0872** ;
0B36BC CD    0873** BAD:			CALL    TELL            	; Output "Bad program" error
0B36BD 54 
0B36BE 3D 
0B36BF 0B 
0B36C0 03    0874** DB    3				; Token for "BAD"
0B36C1 70    0875** DB    "program"
0B36C2 72 
0B36C3 6F 
0B36C4 67 
0B36C4 72   
0B36C5 61 
0B36C6 6D 
0B36C8 0D    0876** DB    CR
0B36C9 0A    0877** DB    LF
0B36CA 00    0878** DB    0				; Falls through to NEW
             0879** ;
0B36CB CD    0880** NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
0B36CC 30 
0B36CD 38 
0B36CE 0B 
0B36CF 18    0881** JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B36D0 19 
             0882** ;
             0883** ; OLD
             0884** ;
0B36D1 2A    0885** OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
0B36D2 14 
0B36D3 5E 
0B36D4 0B 
0B36D5 E5    0886** PUSH    HL			; Stack it
0B36D6 23    0887** INC     HL			; Skip the potential length byte of first line of code
0B36D7 23    0888** INC     HL			; And the line number word
0B36D8 23    0889** INC     HL
0B36D9 01    0890** LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
0B36DA FC 
0B36DB 00 
0B36DC 00 
0B36DD 3E    0891** LD      A,CR
0B36DE 0D 
0B36DF ED    0892** CPIR
0B36E0 B1 
0B36E1 20    0893** JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
0B36E2 D9 
0B36E3 7D    0894** LD      A,L			; It could still be garbage though! Store the position in A; this requires
0B36E4 E1    0895** POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
0B36E5 77    0896** LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
0B36E6 CD    0897** CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B36E7 03 
0B36E8 38 
0B36E9 0B 
0B36EA C3    0898** CLOOP0:			JP      CLOOP			; Jump back to the command loop
0B36EB 44 
0B36EC 30 
0B36ED 0B 
             0899** ;
             0900** ; LOAD filename
             0901** ;
0B36EE CD    0902** LOAD:			CALL    EXPRS           	; Get the filename
0B36EF D9 
0B36F0 02 
0B36F1 0B 
0B36F2 3E    0903** LD      A,CR			; DE points to the last byte of filename in ACCS
0B36F3 0D 
0B36F4 12    0904** LD      (DE),A			; Terminate filename with a CR
0B36F5 CD    0905** CALL    LOAD0			; Load the file in, then CLEAN
0B36F6 E3 
0B36F7 37 
0B36F8 0B 
0B36F9 CD    0906** CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B36FA 3A 
0B36FB 38 
0B36FC 0B 
0B36FD 18    0907** JR      WARM0			; Jump back to the command loop
0B36FE 21 
             0908** ;
             0909** ; SAVE filename
             0910** ;
0B36FF CD    0911** SAVE:			CALL    SETTOP          	; Set TOP sysvar
0B3700 0F 
0B3701 38 
0B3702 0B 
0B3703 CD    0912** CALL    EXPRS           	; Get the filename
0B3704 D9 
0B3705 02 
0B3706 0B 
0B3707 3E    0913** LD      A,CR			; Terminate the filename with a CR
0B3708 0D 
0B3709 12    0914** LD      (DE),A
0B370A ED    0915** LD      DE,(PAGE_)		; DE: Start of program memory
0B370B 5B 
0B370C 14 
0B370D 5E 
0B370D 0B   
0B370F 2A    0916** LD      HL,(TOP)		; HL: Top of program memory
0B3710 17 
0B3711 5E 
0B3712 0B 
0B3713 B7    0917** OR      A			; Calculate program size (TOP-PAGE)
0B3714 ED    0918** SBC     HL,DE
0B3715 52 
0B3716 44    0919** LD      B,H             	; BC: Length of program in bytes
0B3717 4D    0920** LD      C,L
0B3718 21    0921** LD      HL,ACCS			; HL: Address of the filename
0B3719 00 
0B371A 5B 
0B371B 0B 
0B371C CD    0922** CALL    OSSAVE			; Call the SAVE routine in patch.asm
0B371D F1 
0B371E 41 
0B371F 0B 
0B3720 C3    0923** WARM0:			JP      WARM			; Jump back to the command loop
0B3721 43 
0B3722 30 
0B3723 0B 
             0924** 
             0925** ;
             0926** ; ERROR
             0927** ; Called whenever BASIC needs to halt with an error
             0928** ; Error messages are indexed from 0
             0929** ; Inputs:
             0930** ;  A: Error number
             0931** ;
0B3724 ED    0932** ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
0B3725 7B 
0B3726 20 
0B3727 5E 
0B3727 0B   
0B3729 21    0933** LD      HL,ERRWDS		; Index into the error string table
0B372A 0D 
0B372B 34 
0B372C 0B 
0B372D B7    0934** OR      A			; We don't need to search for the first error
0B372E 28    0935** JR      Z,ERROR1		; So skip the search routine
0B372F 0A 
             0936** ;
             0937** ; Search the error table for error #A
             0938** ; HL will end up being the pointer into the correct error
             0939** ; There is no bounds checking on this, so invalid error numbers will probably output garbage
             0940** ;
0B3730 47    0941** LD      B,A             	; Store error number in B
0B3731 08    0942** EX      AF,AF'			; Store error number in AF'
0B3732 AF    0943** XOR     A
0B3733 BE    0944** ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0B3734 23    0945** INC     HL			; Increment the string pointer
0B3735 20    0946** JR      NZ,ERROR0		; Loop until with hit a 0
0B3736 FC 
0B3737 10    0947** DJNZ    ERROR0			; Decrements the error number and loop until 0
0B3738 FA 
0B3739 08    0948** EX      AF,AF'			; Restore the error number from AF'
             0949** ;
             0950** ; At this point HL points to the tokenised error string
             0951** ;
0B373A E5    0952** ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
             0953** 
             0954** ;
             0955** ; EXTERR
             0956** ; Inputs:
             0957** ;  A: Error number
             0958** ;
             0959** ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
             0960** ; The error text immediately follows the CALL to EXTERR, for example:
             0961** ; > CALL  EXTERR
             0962** ; > DB    "Silly", 0
             0963** ; So we can get the address of the string by popping the return address off the stack
             0964** ;
0B373B E1    0965** EXTERR:			POP     HL			; Pop the error string pointer
0B373C 22    0966** LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0B373D 2F 
0B373E 5E 
0B373F 0B 
0B3740 ED    0967** LD      SP,(HIMEM)		; Set SP to HIMEM
0B3741 7B 
0B3742 20 
0B3743 5E 
0B3743 0B   
0B3745 32    0968** LD      (ERR),A			; Store error number in ERR sysvar
0B3746 3F 
0B3747 5E 
0B3748 0B 
0B3749 CD    0969** CALL    SETLIN			; Get line number
0B374A 72 
0B374B 39 
0B374C 0B 
0B374D 22    0970** LD      (ERL),HL		; Store in ERL sysvar
0B374E 33 
0B374F 5E 
0B3750 0B 
0B3751 B7    0971** OR      A			; Is error number 0?
0B3752 28    0972** JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0B3753 0D 
             0973** ;
0B3754 2A    0974** LD      HL,(ERRTRP)		; Check whether the error is trapped
0B3755 2C 
0B3756 5E 
0B3757 0B 
0B3758 7C    0975** LD      A,H
0B3759 B5    0976** OR      L
0B375A E5    0977** PUSH    HL			; HL: Error line
0B375B FD    0978** POP     IY			; IY: HL
0B375C E1 
0B375D C2    0979** JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0B375E 5A 
0B375F 0B 
0B3760 0B 
             0980** ;
0B3761 21    0981** ERROR2:			LD      HL,0
0B3762 00 
0B3763 00 
0B3764 00 
0B3765 22    0982** LD      (AUTONO),HL		; Cancel AUTO
0B3766 29 
0B3767 5E 
0B3768 0B 
0B3769 22    0983** LD      (TRACEN),HL     	; Cancel TRACE
0B376A 26 
0B376B 5E 
0B376C 0B 
0B376D CD    0984** CALL    RESET           	; Reset OPSYS
0B376E 7A 
0B376F 43 
0B3770 0B 
0B3771 CD    0985** CALL    CRLF			; Output newline
0B3772 0B 
0B3773 39 
0B3774 0B 
0B3775 CD    0986** CALL    REPORT          	; Output the error message
0B3776 46 
0B3777 3D 
0B3778 0B 
0B3779 CD    0987** CALL    SAYLN			; Output " at line nnnn" message.
0B377A A6 
0B377B 39 
0B377C 0B 
0B377D 1E    0988** LD      E,0			; Close all files
0B377E 00 
0B377F DC    0989** CALL    C,OSSHUT
0B3780 EF 
0B3781 42 
0B3782 0B 
0B3783 CD    0990** CALL    CRLF			; Output newline
0B3784 0B 
0B3785 39 
0B3786 0B 
0B3787 C3    0991** JP      CLOOP			; Back to CLOOP
0B3788 44 
0B3789 30 
0B378A 0B 
             0992** ;
             0993** ; SUBROUTINES:
             0994** ;
             0995** ; LEX - SEARCH FOR KEYWORDS
             0996** ;   Inputs: HL = start of keyword table
             0997** ;           IY = start of match text
             0998** ;  Outputs: If found, Z-flag set, A=token.
             0999** ;           If not found, Z-flag reset, A=(IY).
             1000** ;           IY updated (if NZ, IY unchanged).
             1001** ; Destroys: A,B,H,L,IY,F
             1002** ;
0B378B 21    1003** LEX:			LD      HL,KEYWDS		; Address of the keywords table
0B378C 2C 
0B378D 31 
0B378E 0B 
             1004** ;
0B378F FD    1005** LEX0:			LD      A,(IY)			; Fetch the character to match
0B3790 7E 
0B3791 00 
0B3792 46    1006** LD      B,(HL)			; B: The token from the keywords table
0B3793 23    1007** INC     HL			; Increment the pointer in the keywords table
0B3794 BE    1008** CP      (HL)			; Compare the first characters
0B3795 28    1009** JR      Z,LEX2			; If there is a match, then skip to LEX2
0B3796 08 
0B3797 D8    1010** RET     C               	; No match, so fail
             1011** ;
             1012** ; This snippet of code skips to the next token in the KEYWDS table
             1013** ;
0B3798 23    1014** LEX1:			INC     HL			; Increment the pointer
0B3799 CB    1015** BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0B379A 7E 
0B379B 28    1016** JR      Z,LEX1			; No, so loop
0B379C FB 
0B379D 18    1017** JR      LEX0			; At this point HL is pointing to the start of the next keyword
0B379E F0 
             1018** ;
0B379F FD    1019** LEX2:			PUSH    IY              	; Save the input pointer
0B37A0 E5 
0B37A1 23    1020** LEX3:			INC     HL			; Increment the keyword pointer
0B37A2 CB    1021** BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0B37A3 7E 
0B37A4 20    1022** JR      NZ,LEX6         	; Jump to here as we've found a token
0B37A5 1C 
0B37A6 FD    1023** INC     IY			; Increment the text pointer
0B37A7 23 
0B37A8 FD    1024** LD      A,(IY)			; Fetch the character
0B37A9 7E 
0B37AA 00 
0B37AB FE    1025** CP      '.'			; Is it an abbreviated keyword?
0B37AC 2E 
0B37AD 28    1026** JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0B37AE 13 
0B37AF BE    1027** CP      (HL)			; Compare with the keywords list
0B37B0 28    1028** JR      Z,LEX3			; It's a match, so continue checking this keyword
0B37B1 EF 
0B37B2 CD    1029** CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B37B3 3F 
0B37B4 3C 
0B37B5 0B 
0B37B6 38    1030** JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0B37B7 04 
             1031** ;
0B37B8 FD    1032** LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0B37B9 E1 
0B37BA 18    1033** JR      LEX1			; And loop back to start again
0B37BB DC 
             1034** ;
             1035** ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
             1036** ; immediately delimited
             1037** ;
0B37BC 7E    1038** LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0B37BD B7    1039** OR      A			; If it is not zero, then...
0B37BE 20    1040** JR      NZ,LEX4			; Keep searching
0B37BF F8 
0B37C0 FD    1041** DEC     IY			; If it is zero, then skip the input pointer back one byte
0B37C1 2B 
             1042** ;
             1043** ; We've found a token at this point
             1044** ;
0B37C2 F1    1045** LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0B37C3 AF    1046** XOR     A			; Set the Z flag
0B37C4 78    1047** LD      A,B			; A: The token
0B37C5 C9    1048** RET
             1049** ;
             1050** ; DEL - DELETE A PROGRAM LINE.
             1051** ;   Inputs: HL addresses program line.
             1052** ; Destroys: B,C,F
             1053** ;
             1054** ; This simply erases the line by moving all of the code after the line to be deleted back over
             1055** ; it using an LDIR
             1056** ;
0B37C6 D5    1057** DEL:			PUSH    DE
0B37C7 E5    1058** PUSH    HL
0B37C8 E5    1059** PUSH    HL			; HL: Address of the program line
0B37C9 06    1060** LD      B,0			; BC: Length of the line
0B37CA 00 
0B37CB 4E    1061** LD      C,(HL)
0B37CC 09    1062** ADD     HL,BC			; HL: Advanced to the start of the next line
0B37CD E5    1063** PUSH    HL
0B37CE EB    1064** EX      DE,HL			; DE: Pointer to the next line
0B37CF 2A    1065** LD      HL,(TOP)		; HL: Pointer to the end of the program
0B37D0 17 
0B37D1 5E 
0B37D2 0B 
0B37D3 ED    1066** SBC     HL,DE
0B37D4 52 
0B37D5 44    1067** LD      B,H			; BC: Size of block to move
0B37D6 4D    1068** LD      C,L
0B37D7 E1    1069** POP     HL			; HL: Pointer to next line
0B37D8 D1    1070** POP     DE			; DE: Pointer to this line
0B37D9 ED    1071** LDIR                    	; Delete the line
0B37DA B0 
0B37DB ED    1072** LD      (TOP),DE		; Adjust TOP
0B37DC 53 
0B37DD 17 
0B37DE 5E 
0B37DE 0B   
0B37E0 E1    1073** POP     HL
0B37E1 D1    1074** POP     DE
0B37E2 C9    1075** RET
             1076** ;
             1077** ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
             1078** ;   Inputs: Filename in ACCS (term CR)
             1079** ; Destroys: A,B,C,D,E,H,L,F
             1080** ;
             1081** ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
             1082** ; AND WRITE FF FF, THEN LOAD (TOP).
             1083** ; Destroys: A,B,C,H,L,F
             1084** ;
0B37E3 ED    1085** LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
0B37E4 5B 
0B37E5 14 
0B37E6 5E 
0B37E6 0B   
0B37E8 21    1086** LD      HL,-256
0B37E9 00 
0B37EA FF 
0B37EB FF 
0B37EC 39    1087** ADD     HL,SP
0B37ED ED    1088** SBC     HL,DE           	; Find available space
0B37EE 52 
0B37EF 44    1089** LD      B,H
0B37F0 4D    1090** LD      C,L
0B37F1 21    1091** LD      HL,ACCS
0B37F2 00 
0B37F3 5B 
0B37F4 0B 
0B37F5 CD    1092** CALL    OSLOAD          	; Call the OSLOAD function in patch
0B37F6 58 
0B37F7 41 
0B37F8 0B 
0B37F9 D4    1093** CALL    NC,NEWIT		; If NC then NEW
0B37FA 30 
0B37FB 38 
0B37FC 0B 
0B37FD 3E    1094** LD      A,0
0B37FE 00 
0B37FF D2    1095** JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
0B3800 24 
0B3801 37 
0B3802 0B 
             1096** ;
0B3803 CD    1097** CLEAN:			CALL    SETTOP			; Set TOP sysvar
0B3804 0F 
0B3805 38 
0B3806 0B 
0B3807 2B    1098** DEC     HL			; Write out the end of program markers
0B3808 36    1099** LD      (HL),-1
0B3809 FF 
0B380A 2B    1100** DEC     HL
0B380B 36    1101** LD      (HL),-1
0B380C FF 
0B380D 18    1102** JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0B380E 2B 
             1103** ;
             1104** ; Set the TOP sysvar; the first free location after the end of the current program
             1105** ; Returns:
             1106** ; - HL: TOP
             1107** ;
0B380F 2A    1108** SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0B3810 14 
0B3811 5E 
0B3812 0B 
0B3813 01    1109** LD	BC, 0			; BC: 0
0B3814 00 
0B3815 00 
0B3816 00 
0B3817 3E    1110** LD      A,CR			; End of line marker
0B3818 0D 
0B3819 4E    1111** SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0B381A 0C    1112** INC     C			; Check for zero
0B381B 0D    1113** DEC     C
0B381C 28    1114** JR      Z,SETOP2		; If it is zero, we've reached the end
0B381D 0A 
0B381E 09    1115** ADD     HL,BC			; Skip to next line
0B381F 2B    1116** DEC     HL			; Check end of previous line
0B3820 BE    1117** CP      (HL)
0B3821 23    1118** INC     HL
0B3822 28    1119** JR      Z,SETOP1		; If CR then loop
0B3823 F5 
0B3824 C3    1120** JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0B3825 BC 
0B3826 36 
0B3827 0B 
             1121** ;
0B3828 23    1122** SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0B3829 23    1123** INC     HL			; NB: Called from NEWIT
0B382A 23    1124** INC     HL
0B382B 22    1125** LD      (TOP),HL		; Store in TOP sysvar
0B382C 17 
0B382D 5E 
0B382E 0B 
0B382F C9    1126** RET
             1127** ;
             1128** ; NEWIT - NEW PROGRAM THEN CLEAR
             1129** ;   Destroys: H,L
             1130** ;
             1131** ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
             1132** ; FUNCTION AND PROCEDURE POINTERS.
             1133** ;   Destroys: Nothing
             1134** ;
0B3830 2A    1135** NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0B3831 14 
0B3832 5E 
0B3833 0B 
0B3834 36    1136** LD      (HL),0			; Stick a 0 in there
0B3835 00 
0B3836 CD    1137** CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0B3837 28 
0B3838 38 
0B3839 0B 
             1138** ;
0B383A E5    1139** CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0B383B 2A    1140** LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0B383C 17 
0B383D 5E 
0B383E 0B 
0B383F 22    1141** LD      (LOMEM),HL		; Set the LOMEM sysvar
0B3840 1A 
0B3841 5E 
0B3842 0B 
0B3843 22    1142** LD      (FREE),HL		; And the FREE sysvar with that value
0B3844 1D 
0B3845 5E 
0B3846 0B 
0B3847 21    1143** LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0B3848 6C 
0B3849 5D 
0B384A 0B 
0B384B C5    1144** PUSH    BC
             1145** ; LD      B,3*(54+2)		; Loop counter
0B384C 06    1146** LD      B,54+2*3		; ez80asm doesn't do () in expressions
0B384D A8 
0B384E 36    1147** CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0B384F 00 
0B3850 23    1148** INC     HL
0B3851 10    1149** DJNZ    CLEAR1
0B3852 FB 
0B3853 C1    1150** POP     BC
0B3854 E1    1151** POP     HL			; Restore the BASIC program pointer
0B3855 C9    1152** RET
             1153** ;
             1154** ;LISTIT - LIST A PROGRAM LINE.
             1155** ;    Inputs: HL addresses line
             1156** ;            DE = line number (binary)
             1157** ;            IX = Pointer to LISTON
             1158** ;             B = FOR/NEXT indent level
             1159** ;             C = REPEAT/UNTIL indent level
             1160** ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
             1161** ;
0B3856 E5    1162** LISTIT:			PUSH    HL			; Stack the address of the line
0B3857 EB    1163** EX      DE,HL			; HL: Line number
0B3858 C5    1164** PUSH    BC
0B3859 CD    1165** CALL    PBCD			; Print the line number
0B385A BF 
0B385B 39 
0B385C 0B 
0B385D C1    1166** POP     BC
0B385E E1    1167** POP     HL			; HL: Address of the first token/character
0B385F 7E    1168** LD      A,(HL)			; Fetch the token
0B3860 FE    1169** CP      NEXT			; Is it NEXT...
0B3861 ED 
0B3862 CC    1170** CALL    Z,INDENT		; Yes, so indent in
0B3863 EC 
0B3864 38 
0B3865 0B 
0B3866 FE    1171** CP      UNTIL			; Or is it UNTIL...
0B3867 FD 
0B3868 CC    1172** CALL    Z,INDENT		; Yes, so indent in
0B3869 EC 
0B386A 38 
0B386B 0B 
0B386C D9    1173** EXX
0B386D 3E    1174** LD      A,' '
0B386E 20 
0B386F DD    1175** BIT     0,(IX)			; If BIT 0 of LISTON is set
0B3870 CB 
0B3871 00 
0B3872 46 
0B3873 C4    1176** CALL    NZ,OUTCHR		; Then print a space after the line number
0B3874 13 
0B3875 39 
0B3876 0B 
0B3877 78    1177** LD      A,B			; Fetch the FOR/NEXT indent level
0B3878 87    1178** ADD     A,A			; Multiply by 2
0B3879 DD    1179** BIT     1,(IX)			; If BIT 1 of LISTON is set
0B387A CB 
0B387B 00 
0B387C 4E 
0B387D C4    1180** CALL    NZ,FILL			; Then print the FOR/NEXT indent
0B387E B3 
0B387F 17 
0B3880 0B 
0B3881 79    1181** LD      A,C			; Fetch the REPEAT/UNTIL indent level
0B3882 87    1182** ADD     A,A			; Multiply by 2
0B3883 DD    1183** BIT     2,(IX)			; If BIT 2 of LISTON is set
0B3884 CB 
0B3885 00 
0B3886 56 
0B3887 C4    1184** CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0B3888 B3 
0B3889 17 
0B388A 0B 
0B388B D9    1185** EXX
0B388C 7E    1186** LD      A,(HL)			; Fetch the token
0B388D FE    1187** CP      FOR			; Is it FOR?
0B388E E3 
0B388F CC    1188** CALL    Z,INDENT		; Yes, so indent
0B3890 EC 
0B3891 38 
0B3892 0B 
0B3893 FE    1189** CP      REPEAT			; Is it REPEAT?
0B3894 F5 
0B3895 CC    1190** CALL    Z,INDENT		; Yes, so indent
0B3896 EC 
0B3897 38 
0B3898 0B 
0B3899 1E    1191** LD      E,0			; E: The quote counter - reset to 0
0B389A 00 
0B389B 7E    1192** LIST8:			LD      A,(HL)			; Fetch a character / token byte
0B389C 23    1193** INC     HL
0B389D FE    1194** CP      CR			; Is it end of line?
0B389E 0D 
0B389F 28    1195** JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0B38A0 0B 
0B38A1 FE    1196** CP      34			; Is it a quote character?
0B38A2 22 
0B38A3 20    1197** JR      NZ,LIST7		; No, so skip to next bit
0B38A4 01 
0B38A5 1C    1198** INC     E			; Otherwise increment quote counter
0B38A6 CD    1199** LIST7:			CALL    LOUT			; Output the character / token
0B38A7 DB 
0B38A8 38 
0B38A9 0B 
0B38AA 18    1200** JR      LIST8			; And repeat
0B38AB EF 
             1201** ;
             1202** ; DB: Modification for *EDIT
             1203** ; Terminate the line with either a CRLF or a NUL character
             1204** ;
0B38AC DD    1205** LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0B38AD CB 
0B38AE 00 
0B38AF 5E 
0B38B0 28    1206** JR	Z, CRLF			; Yes, so print a CRLF
0B38B1 59 
0B38B2 AF    1207** XOR	A			; Otherwise print a NUL (0)
0B38B3 C3    1208** JP	OSWRCH
0B38B4 C4 
0B38B5 3E 
0B38B6 0B 
             1209** ;
             1210** ; Decode the 3 byte GOTO type line number
             1211** ;
0B38B7 E5    1212** PRLINO:			PUSH    HL			; Swap HL and IY
0B38B8 FD    1213** POP     IY			; IY: Pointer to the line number
0B38B9 E1 
0B38BA C5    1214** PUSH    BC
0B38BB CD    1215** CALL    DECODE			; Decode
0B38BC AA 
0B38BD 08 
0B38BE 0B 
0B38BF C1    1216** POP     BC
0B38C0 D9    1217** EXX
0B38C1 C5    1218** PUSH    BC
0B38C2 CD    1219** CALL    PBCDL			; Output the line number
0B38C3 BB 
0B38C4 39 
0B38C5 0B 
0B38C6 C1    1220** POP     BC
0B38C7 D9    1221** EXX
0B38C8 FD    1222** PUSH    IY			; Swap HL and IY
0B38C9 E5 
0B38CA E1    1223** POP     HL			; HL: Pointer to the next character in the line
0B38CB C9    1224** RET
             1225** ;
             1226** ; DB: Modification for internationalisation
             1227** ;
0B38CC CD    1228** PRREM:			CALL	OUT_			; Output the REM token
0B38CD 30 
0B38CE 39 
0B38CF 0B 
0B38D0 7E    1229** @@:			LD	A, (HL)			; Fetch the character
0B38D1 FE    1230** CP	CR			; If it is end of line, then
0B38D2 0D 
0B38D3 C8    1231** RET	Z			; we have finished
0B38D4 CD    1232** CALL	OUTCHR			; Ouput the character
0B38D5 13 
0B38D6 39 
0B38D7 0B 
0B38D8 23    1233** INC	HL
0B38D9 18    1234** JR	@B			; And loop
0B38DA F5 
             1235** ;
             1236** ; DB: End of modification
             1237** ;
0B38DB CB    1238** LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
0B38DC 43 
0B38DD 20    1239** JR      NZ,OUTCHR		; don't tokenise, just output the character
0B38DE 34 
0B38DF FE    1240** CP	REM			; DB: Is it REM
0B38E0 F4 
0B38E1 28    1241** JR	Z, PRREM		; DB: Yes so jump to the special case for REM
0B38E2 E9 
0B38E3 FE    1242** CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
0B38E4 8D 
0B38E5 28    1243** JR      Z,PRLINO		; Yes, so decode and print the line number
0B38E6 D0 
0B38E7 CD    1244** CALL    OUT_			; Output a character / keyword
0B38E8 30 
0B38E9 39 
0B38EA 0B 
0B38EB 7E    1245** LD      A,(HL)			; Fetch the next character
             1246** ;
             1247** ; This block of code handles the indentation
             1248** ; B: Counter for FOR/NEXT indent
             1249** ; C: Counter for REPEAT/UNTIL indent
             1250** ;
0B38EC D9    1251** INDENT:			EXX
0B38ED FE    1252** CP      FOR			; If the token is FOR
0B38EE E3 
0B38EF 28    1253** JR      Z,IND1			; Then INC B
0B38F0 09 
0B38F1 FE    1254** CP      NEXT			; If it is NEXT
0B38F2 ED 
0B38F3 20    1255** JR      NZ,IND2_		; Then...
0B38F4 06 
0B38F5 05    1256** DEC     B			; DEC B
0B38F6 F2    1257** JP      P,IND2_			; If we have gone below 0 then
0B38F7 FB 
0B38F8 38 
0B38F9 0B 
0B38FA 04    1258** IND1:			INC     B			; Increment back to 0
             1259** ;
0B38FB FE    1260** IND2_:			CP      REPEAT			; If the token is REPEAT
0B38FC F5 
0B38FD 28    1261** JR      Z,IND3			; Then INC C
0B38FE 09 
0B38FF FE    1262** CP      UNTIL			; If it is UNTIL
0B3900 FD 
0B3901 20    1263** JR      NZ,IND4			; Then...
0B3902 06 
0B3903 0D    1264** DEC     C			; DEC C
0B3904 F2    1265** JP      P,IND4			; If we have gone below 0 then
0B3905 09 
0B3906 39 
0B3907 0B 
0B3908 0C    1266** IND3:			INC     C			; Incremet back to 0
0B3909 D9    1267** IND4:			EXX
0B390A C9    1268** RET
             1269** ;
             1270** ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
             1271** ;  Destroys: A,F
             1272** ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
             1273** ;    Inputs: A = character
             1274** ;  Destroys: A,F
             1275** ;
0B390B 3E    1276** CRLF:			LD      A,CR			; Output CR
0B390C 0D 
0B390D CD    1277** CALL    OUTCHR
0B390E 13 
0B390F 39 
0B3910 0B 
0B3911 3E    1278** LD      A,LF			; Output LF
0B3912 0A 
             1279** ;
0B3913 CD    1280** OUTCHR:			CALL    OSWRCH			; Output the character in A
0B3914 C4 
0B3915 3E 
0B3916 0B 
0B3917 D6    1281** SUB     CR			; Check for CR
0B3918 0D 
0B3919 28    1282** JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0B391A 06 
0B391B D8    1283** RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0B391C 3A    1284** LD      A,(COUNT)		; Increment the count
0B391D 3D 
0B391E 5E 
0B391F 0B 
0B3920 3C    1285** INC     A
             1286** ;
0B3921 32    1287** CARRET:			LD      (COUNT),A		; Store the new count value
0B3922 3D 
0B3923 5E 
0B3924 0B 
0B3925 C8    1288** RET     Z			; Return if the count has wrapped to 0
0B3926 E5    1289** PUSH    HL			; Now check if count = print width
0B3927 2A    1290** LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0B3928 3E 
0B3929 5E 
0B392A 0B 
0B392B BD    1291** CP      L			; L is the width. Compare it with count.
0B392C E1    1292** POP     HL
0B392D C0    1293** RET     NZ			; If we've not hit print width, then just return
0B392E 18    1294** JR      CRLF			; Otherwise output CRLF
0B392F DB 
             1295** ;
             1296** ; OUT - SEND CHARACTER OR KEYWORD
             1297** ;   Inputs: A = character (>=10, <128)
             1298** ;           A = Token (<10, >=128)
             1299** ;  Destroys: A,F
             1300** ;
0B3930 FE    1301** OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0B3931 8A 
0B3932 EA    1302** JP      PE,OUTCHR		; If so, then it's a character, so just output it
0B3933 13 
0B3934 39 
0B3935 0B 
             1303** ;
             1304** ; This bit looks up the character in the KEYWDS token table and expands it
             1305** ; Note the CP 138; this sets the overflow flag as follows:
             1306** ;
             1307** ; NB:
             1308** ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
             1309** ;  2. CP is effectively a SUB; sets the flags without affecting A
             1310** ;  3. The operation n - -118 ~ n + 118
             1311** ;
             1312** ; So:
             1313** ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
             1314** ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
             1315** ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
             1316** ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
             1317** ;
0B3936 C5    1318** PUSH    BC			; Preserve BC and HL
0B3937 E5    1319** PUSH    HL
0B3938 21    1320** LD      HL,KEYWDS		; The list of tokens and keywords
0B3939 2C 
0B393A 31 
0B393B 0B 
0B393C 01    1321** LD      BC,KEYWDL		; The length of the keyword list
0B393D DF 
0B393E 02 
0B393F 00 
0B3940 ED    1322** CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0B3941 B1 
             1323** ;							; At this point HL points to the next byte, the first character of the token
0B3942 7E    1324** TOKEN1:			LD      A,(HL)			; Fetch the character
0B3943 23    1325** INC     HL			; Increment to the next byte in the token table
0B3944 FE    1326** CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0B3945 8A 
0B3946 F5    1327** PUSH    AF			; Then...
0B3947 EC    1328** CALL    PE,OUTCHR		; Output the character...
0B3948 13 
0B3949 39 
0B394A 0B 
0B394B F1    1329** POP     AF			;
0B394C EA    1330** JP      PE,TOKEN1		; And loop to the next character
0B394D 42 
0B394E 39 
0B394F 0B 
0B3950 E1    1331** POP     HL			; Done, so tidy up the stack and exit
0B3951 C1    1332** POP     BC
0B3952 C9    1333** RET
             1334** ;
             1335** ; FINDL - FIND PROGRAM LINE
             1336** ;   Inputs: HL = line number (binary)
             1337** ;  Outputs: HL addresses line (if found)
             1338** ;           DE = line number
             1339** ;           Z-flag set if found.
             1340** ; Destroys: A,B,C,D,E,H,L,F
             1341** ;
0B3953 EB    1342** FINDL:			EX      DE,HL			; DE: Line number (binary)
0B3954 2A    1343** LD      HL,(PAGE_)		; HL: Top of BASIC program area
0B3955 14 
0B3956 5E 
0B3957 0B 
0B3958 AF    1344** XOR     A               	;  A: 0
0B3959 BE    1345** CP      (HL)			; Check for end of program marker
0B395A 3C    1346** INC     A			;  A: 1
0B395B D0    1347** RET     NC			; Return with 1 if 0
0B395C AF    1348** XOR     A               	; Clear the carry flag
             1349** ;			LD      B,A			;  B: 0
0B395D 01    1350** LD	BC, 0			; BC: 0
0B395E 00 
0B395F 00 
0B3960 00 
             1351** ;
0B3961 4E    1352** FINDL1:			LD      C,(HL)			;  C: The line length
0B3962 E5    1353** PUSH    HL			; Stack the current program counter
0B3963 23    1354** INC     HL			; Skip to the line number bytes
0B3964 7E    1355** LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0B3965 23    1356** INC     HL
0B3966 66    1357** LD      H,(HL)
0B3967 6F    1358** LD      L,A
0B3968 52    1359** SBC.S   HL,DE			; Compare with the line number we're searching for
0B3969 ED 
0B396A 52 
0B396B E1    1360** POP     HL			; Get the current program counter
0B396C D0    1361** RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0B396D 09    1362** ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0B396E C3    1363** JP      FINDL1			; And loop
0B396F 61 
0B3970 39 
0B3971 0B 
             1364** ;
             1365** ; SETLIN - Search program for line containing address
             1366** ;          Update (LINENO)
             1367** ;   Inputs: Address in (ERRLIN)
             1368** ;  Outputs: Line number in HL and (LINENO)
             1369** ; Destroys: B,C,D,E,H,L,F
             1370** ;
0B3972 01    1371** SETLIN:			LD	BC, 0			; Zero BC for later
0B3973 00 
0B3974 00 
0B3975 00 
             1372** ;			LD      B, 0			; Zero B for later
0B3976 ED    1373** LD      DE, (ERRLIN)		; DE: Address of line
0B3977 5B 
0B3978 35 
0B3979 5E 
0B3979 0B   
0B397B 2A    1374** LD      HL, (PAGE_)		; HL: Start of user program area
0B397C 14 
0B397D 5E 
0B397E 0B 
0B397F B7    1375** OR      A			; Do a 24 bit compare without destroying HL
0B3980 ED    1376** SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0B3981 52 
0B3982 19    1377** ADD     HL, DE			;  C: DE > HL
0B3983 30    1378** JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0B3984 1B 
             1379** ;
0B3985 4E    1380** SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0B3986 0C    1381** INC     C			; This is a way to check for zero without using the accumulator
0B3987 0D    1382** DEC     C			; If it is zero, then...
0B3988 28    1383** JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0B3989 16 
0B398A 09    1384** ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0B398B ED    1385** SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0B398C 52 
0B398D 19    1386** ADD     HL, DE
0B398E 38    1387** JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0B398F F5 
0B3990 ED    1388** SBC     HL, BC			; We've found it, so back up to the beginning of the line
0B3991 42 
0B3992 23    1389** INC     HL			; Skip the length counter
0B3993 11    1390** LD	DE, 0			; Zero DE
0B3994 00 
0B3995 00 
0B3996 00 
0B3997 5E    1391** LD      E, (HL)          	; Fetch the line number
0B3998 23    1392** INC     HL
0B3999 56    1393** LD      D, (HL)
0B399A EB    1394** EX      DE, HL			; HL: The line number
0B399B 22    1395** SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0B399C 23 
0B399D 5E 
0B399E 0B 
0B399F C9    1396** RET
             1397** ;
0B39A0 21    1398** SET3:			LD      HL, 0			; We've not found the line at this point so
0B39A1 00 
0B39A2 00 
0B39A3 00 
0B39A4 18    1399** JR      SET2			; Set LINENO to 0
0B39A5 F5 
             1400** ;
             1401** ;SAYLN - PRINT " at line nnnn" MESSAGE.
             1402** ;  Outputs: Carry=0 if line number is zero.
             1403** ;           Carry=1 if line number is non-zero.
             1404** ; Destroys: A,B,C,D,E,H,L,F
             1405** ;
0B39A6 2A    1406** SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0B39A7 23 
0B39A8 5E 
0B39A9 0B 
0B39AA 7C    1407** LD      A,H			; If it is zero then
0B39AB B5    1408** OR      L
0B39AC C8    1409** RET     Z			; Don't need to do anything; return with F:C set to 0
0B39AD CD    1410** CALL    TELL			; Output the error message
0B39AE 54 
0B39AF 3D 
0B39B0 0B 
0B39B1 20    1411** DB    	" at line ", 0
0B39B2 61 
0B39B3 74 
0B39B4 20 
0B39B4 6C   
0B39B5 69 
0B39B6 6E 
0B39B7 65 
0B39B7 20   
0B39B8 00 
0B39BB 0E    1412** PBCDL:			LD      C,0			; C: Leading character (NUL)
0B39BC 00 
0B39BD 18    1413** JR      PBCD0			; Output the line number; return with F:C set to 1
0B39BE 02 
             1414** ;
             1415** ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
             1416** ;   Inputs: HL = number (binary).
             1417** ;  Outputs: Carry = 1
             1418** ; Destroys: A,B,C,D,E,H,L,F
             1419** ;
0B39BF 0E    1420** PBCD:			LD      C,' '			; C: Leading character (" ")
0B39C0 20 
0B39C1 06    1421** PBCD0:			LD      B,5			; Number of digits in result
0B39C2 05 
0B39C3 11    1422** LD      DE,10000		; Start off with the 10,000 column
0B39C4 10 
0B39C5 27 
0B39C6 00 
0B39C7 AF    1423** PBCD1:			XOR     A			; Counter
0B39C8 ED    1424** PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
0B39C9 52 
0B39CA 3C    1425** INC     A
0B39CB 30    1426** JR      NC,PBCD2
0B39CC FB 
0B39CD 19    1427** ADD     HL,DE			; The loop overruns by one, so adjust here
0B39CE 3D    1428** DEC     A			; A: Number of 10,000s
0B39CF 28    1429** JR      Z,PBCD3			; If it is 0, then skip the next bit
0B39D0 04 
0B39D1 CB    1430** SET     4,C			; C: Set to '0' ASCII (30h)
0B39D2 E1 
0B39D3 CB    1431** SET     5,C
0B39D4 E9 
0B39D5 B1    1432** PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
0B39D6 C4    1433** CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
0B39D7 13 
0B39D8 39 
0B39D9 0B 
0B39DA 78    1434** LD      A,B			; If on first transition, skip this
0B39DB FE    1435** CP      5			; TODO: Need to find out why
0B39DC 05 
0B39DD 28    1436** JR      Z,PBCD4
0B39DE 06 
0B39DF 29    1437** ADD     HL,HL			; HL x  2 : We shift the number being tested left,
0B39E0 54    1438** LD      D,H			;         : rather than shifting DE right
0B39E1 5D    1439** LD      E,L			;         : This makes a lot of sense
0B39E2 29    1440** ADD     HL,HL			; HL x  4
0B39E3 29    1441** ADD     HL,HL			; HL x  8
0B39E4 19    1442** ADD     HL,DE			; HL x 10
0B39E5 11    1443** PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
0B39E6 E8 
0B39E7 03 
0B39E8 00 
0B39E9 10    1444** DJNZ    PBCD1			; Loop until done
0B39EA DC 
0B39EB 37    1445** SCF				; SCF set for SAYLN in this module
0B39EC C9    1446** RET
             1447** ;
             1448** ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
             1449** ;   Inputs: HL, IY as returned from GETVAR (NZ).
             1450** ;  Outputs: As GETVAR.
             1451** ; Destroys: everything
             1452** ;
0B39ED CD    1453** PUTVAR:			CALL    CREATE			; Create the variable
0B39EE 72 
0B39EF 3B 
0B39F0 0B 
0B39F1 FD    1454** LD      A,(IY)			; Fetch the next character
0B39F2 7E 
0B39F3 00 
0B39F4 FE    1455** CP      '('			; Check for bad use of array
0B39F5 28 
0B39F6 20    1456** JR      NZ,GETVZ        	; It's fine, so set the exit conditions
0B39F7 70 
0B39F8 3E    1457** ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
0B39F9 0E 
0B39FA C3    1458** ERROR3:			JP      ERROR_
0B39FB 24 
0B39FC 37 
0B39FD 0B 
             1459** ;
             1460** ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
             1461** ;   Inputs: IY addresses first character.
             1462** ;  Outputs: Carry set and NZ if illegal character.
             1463** ;           Z-flag set if variable found, then:
             1464** ;            A = variable type (0,4,5,128 or 129)
             1465** ;            HL = IX = variable pointer.
             1466** ;            IY updated
             1467** ;           If Z-flag & carry reset, then:
             1468** ;            HL, IY set for subsequent PUTVAR call.
             1469** ; Destroys: everything
             1470** ;
0B39FE FD    1471** GETVAR:			LD      A,(IY)			; Get the first character
0B39FF 7E 
0B3A00 00 
0B3A01 FE    1472** CP      '$'			; Is it a string?
0B3A02 24 
0B3A03 28    1473** JR      Z,GETV4			; Yes, so branch here
0B3A04 69 
0B3A05 FE    1474** CP      '!'			; Is it indirection (32-bit)?
0B3A06 21 
0B3A07 28    1475** JR      Z,GETV5			; Yes, so branch here
0B3A08 69 
0B3A09 FE    1476** CP      '?'			; Is it indirection (8-bit)?
0B3A0A 3F 
0B3A0B 28    1477** JR      Z,GETV6			; Yes, so branch here
0B3A0C 69 
             1478** ;
0B3A0D CD    1479** CALL    LOCATE			; Locate the variable
0B3A0E DC 
0B3A0F 3A 
0B3A10 0B 
0B3A11 C0    1480** RET     NZ			; And exit here if not found
             1481** ;
             1482** ; At this point:
             1483** ;  HL: Address of variable in memory
             1484** ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
             1485** ;
0B3A12 FD    1486** LD      A,(IY)			; Further checks
0B3A13 7E 
0B3A14 00 
0B3A15 FE    1487** CP      '('             	; Is it an array?
0B3A16 28 
0B3A17 20    1488** JR      NZ,GETVX        	; No, so exit
0B3A18 47 
             1489** ;
             1490** ; We are processing an array at this point
             1491** ;
0B3A19 D5    1492** PUSH    DE              	; Save the variable type (in D)
0B3A1A 7E    1493** LD      A,(HL)          	; Fetch the number of dimensions
0B3A1B B7    1494** OR      A
0B3A1C 28    1495** JR      Z,ARRAY			; If there are none, then Error: 'Array'
0B3A1D DA 
0B3A1E 23    1496** INC     HL			;
0B3A1F 11    1497** LD      DE,0            	; Accumulator
0B3A20 00 
0B3A21 00 
0B3A22 00 
0B3A23 F5    1498** PUSH    AF
0B3A24 FD    1499** INC     IY              	; Skip "("
0B3A25 23 
0B3A26 18    1500** JR      GETV3
0B3A27 05 
             1501** ;
0B3A28 F5    1502** GETV2:			PUSH    AF
0B3A29 CD    1503** CALL    COMMA
0B3A2A E6 
0B3A2B 09 
0B3A2C 0B 
0B3A2D E5    1504** GETV3:			PUSH    HL
0B3A2E D5    1505** PUSH    DE
0B3A2F CD    1506** CALL    EXPRI			; Get the subscript
0B3A30 CE 
0B3A31 02 
0B3A32 0B 
0B3A33 D9    1507** EXX
0B3A34 D1    1508** POP     DE
0B3A35 E3    1509** EX      (SP),HL
0B3A36 4E    1510** LD      C,(HL)
0B3A37 23    1511** INC     HL
0B3A38 46    1512** LD      B,(HL)
0B3A39 23    1513** INC     HL
0B3A3A E3    1514** EX      (SP),HL
0B3A3B EB    1515** EX      DE,HL
0B3A3C D5    1516** PUSH    DE
0B3A3D CD    1517** CALL    MUL16			; HL=HL*BC
0B3A3E 36 
0B3A3F 18 
0B3A40 0B 
0B3A41 D1    1518** POP     DE
0B3A42 19    1519** ADD     HL,DE
0B3A43 EB    1520** EX      DE,HL
0B3A44 B7    1521** OR      A
0B3A45 ED    1522** SBC     HL,BC
0B3A46 42 
0B3A47 3E    1523** LD      A,15
0B3A48 0F 
0B3A49 30    1524** JR      NC,ERROR3		; Throw a "Subscript" error
0B3A4A AF 
0B3A4B E1    1525** POP     HL
0B3A4C F1    1526** POP     AF
0B3A4D 3D    1527** DEC     A               	; Dimension counter
0B3A4E 20    1528** JR      NZ,GETV2
0B3A4F D8 
0B3A50 CD    1529** CALL    BRAKET          	; Check for closing bracket
0B3A51 F3 
0B3A52 09 
0B3A53 0B 
0B3A54 F1    1530** POP     AF              	; Restore the type
0B3A55 E5    1531** PUSH    HL
0B3A56 CD    1532** CALL    X4OR5           	; DE=DE*n
0B3A57 29 
0B3A58 18 
0B3A59 0B 
0B3A5A E1    1533** POP     HL
0B3A5B 19    1534** ADD     HL,DE
0B3A5C 57    1535** LD      D,A             	; The type
0B3A5D FD    1536** LD      A,(IY)
0B3A5E 7E 
0B3A5F 00 
0B3A60 FE    1537** GETVX:			CP      '?'
0B3A61 3F 
0B3A62 28    1538** JR      Z,GETV9
0B3A63 1E 
0B3A64 FE    1539** CP      '!'
0B3A65 21 
0B3A66 28    1540** JR      Z,GETV8
0B3A67 16 
0B3A68 E5    1541** GETVZ:			PUSH    HL              	; Set exit conditions
0B3A69 DD    1542** POP     IX
0B3A6A E1 
0B3A6B 7A    1543** LD      A,D
0B3A6C BF    1544** CP      A
0B3A6D C9    1545** RET
             1546** ;
             1547** ; Process strings, unary & binary indirection:
             1548** ;
0B3A6E 3E    1549** GETV4:			LD      A,128           	; Static strings
0B3A6F 80 
0B3A70 18    1550** JR      GETV7
0B3A71 05 
             1551** ;
0B3A72 3E    1552** GETV5:			LD      A,4             	; Unary 32-bit indirection
0B3A73 04 
0B3A74 18    1553** JR      GETV7
0B3A75 01 
             1554** ;
0B3A76 AF    1555** GETV6:			XOR     A               	; Unary 8-bit indirection
             1556** ;
0B3A77 21    1557** GETV7:			LD      HL,0
0B3A78 00 
0B3A79 00 
0B3A7A 00 
0B3A7B F5    1558** PUSH    AF
0B3A7C 18    1559** JR      GETV0
0B3A7D 24 
             1560** ;
0B3A7E 06    1561** GETV8:			LD      B,4             	; Binary 32-bt indirection
0B3A7F 04 
0B3A80 18    1562** JR      GETVA
0B3A81 02 
             1563** ;
0B3A82 06    1564** GETV9:			LD      B,0             	; Binary 8-bit indirection
0B3A83 00 
             1565** ;
0B3A84 E5    1566** GETVA:			PUSH    HL
0B3A85 DD    1567** POP     IX
0B3A86 E1 
0B3A87 7A    1568** LD      A,D            		; Fetch the variable type
0B3A88 FE    1569** CP      129			; Is it a string?
0B3A89 81 
0B3A8A C8    1570** RET     Z               	; Yes, so exit here
0B3A8B C5    1571** PUSH    BC
0B3A8C CD    1572** CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
0B3A8D DA 
0B3A8E 03 
0B3A8F 0B 
0B3A90 CD    1573** CALL    SFIX
0B3A91 26 
0B3A92 06 
0B3A93 0B 
0B3A94 7D    1574** LD	A,L
0B3A95 D9    1575** EXX
0B3A96 22    1576** LD	(R0+0),HL
0B3A97 4A 
0B3A98 5E 
0B3A99 0B 
0B3A9A 32    1577** LD	(R0+2),A
0B3A9B 4C 
0B3A9C 5E 
0B3A9D 0B 
0B3A9E 2A    1578** LD	HL,(R0)			; HL: 24-bit address of the variable in memory
0B3A9F 4A 
0B3AA0 5E 
0B3AA1 0B 
             1579** ;
0B3AA2 E5    1580** GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
0B3AA3 FD    1581** INC     IY
0B3AA4 23 
0B3AA5 CD    1582** CALL    ITEMI
0B3AA6 E9 
0B3AA7 02 
0B3AA8 0B 
0B3AA9 7D    1583** LD	A,L			;  A: The MSB of the address
0B3AAA D9    1584** EXX
0B3AAB 22    1585** LD	(R0+0),HL		; HL: The LSW of the address
0B3AAC 4A 
0B3AAD 5E 
0B3AAE 0B 
0B3AAF 32    1586** LD	(R0+2),A		; R0: L'HL or the 24-bit address
0B3AB0 4C 
0B3AB1 5E 
0B3AB2 0B 
0B3AB3 D1    1587** POP     DE
0B3AB4 F1    1588** POP     AF
0B3AB5 2A    1589** LD	HL,(R0)			; HL: L'HL
0B3AB6 4A 
0B3AB7 5E 
0B3AB8 0B 
0B3AB9 19    1590** ADD     HL,DE
0B3ABA E5    1591** PUSH    HL
0B3ABB DD    1592** POP     IX
0B3ABC E1 
0B3ABD BF    1593** CP      A
0B3ABE C9    1594** RET
             1595** ;
             1596** ;GETDEF - Find entry for FN or PROC in dynamic area.
             1597** ;   Inputs: IY addresses byte following "DEF" token.
             1598** ;  Outputs: Z flag set if found
             1599** ;           Carry set if neither FN or PROC first.
             1600** ;           If Z: HL points to entry
             1601** ;                 IY addresses delimiter
             1602** ; Destroys: A,D,E,H,L,IY,F
             1603** ;
0B3ABF FD    1604** GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
0B3AC0 7E 
0B3AC1 01 
0B3AC2 CD    1605** CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
0B3AC3 3F 
0B3AC4 3C 
0B3AC5 0B 
0B3AC6 D8    1606** RET     C			; No so return with C set
0B3AC7 FD    1607** LD      A,(IY)			; Fetch the current character from the tokenised line
0B3AC8 7E 
0B3AC9 00 
0B3ACA 21    1608** LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
0B3ACB 0E 
0B3ACC 5E 
0B3ACD 0B 
0B3ACE FE    1609** CP      FN			; Is it the token FN?
0B3ACF A4 
0B3AD0 28    1610** JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3AD1 4A 
0B3AD2 21    1611** LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
0B3AD3 11 
0B3AD4 5E 
0B3AD5 0B 
0B3AD6 FE    1612** CP      PROC			; Is it the token PROC?
0B3AD7 F2 
0B3AD8 28    1613** JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3AD9 42 
0B3ADA 37    1614** SCF				; No, so just return with C set
0B3ADB C9    1615** RET
             1616** ;
             1617** ; LOCATE - Try to locate variable name in static or dynamic variables.
             1618** ; If illegal first character return carry, non-zero.
             1619** ; If found, return no-carry, zero.
             1620** ; If not found, return no-carry, non-zero.
             1621** ;   Inputs: IY=Addresses first character of name.
             1622** ;            A=(IY)
             1623** ;  Outputs:  F=Z set if found, then:
             1624** ;           IY=addresses terminator
             1625** ;           HL=addresses location of variable
             1626** ;            D=type of variable: 4 = integer
             1627** ;                                5 = floating point
             1628** ;                              129 = string
             1629** ; Destroys: A,D,E,H,L,IY,F
             1630** ;
             1631** ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
             1632** ; They can contain any alphanumeric character and underscore (_)
             1633** ; String variables are postfixed with the dollar ($) character
             1634** ; Integer variables are postfixed with the percent (%) character
             1635** ; Static integer variables are named @%, A% to Z%
             1636** ; All other variables are dynamic
             1637** ;
0B3ADC D6    1638** LOCATE:			SUB     '@'			; Check for valid range
0B3ADD 40 
0B3ADE D8    1639** RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
0B3ADF 21    1640** LD      HL, 0			; Clear HL
0B3AE0 00 
0B3AE1 00 
0B3AE2 00 
0B3AE3 FE    1641** CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
0B3AE4 1B 
0B3AE5 30    1642** JR      NC,LOC0         	; Then branch here
0B3AE6 1E 
0B3AE7 6F    1643** LD	L, A			; HL = A
0B3AE8 FD    1644** LD      A,(IY+1)        	; Check the 2nd character
0B3AE9 7E 
0B3AEA 01 
0B3AEB FE    1645** CP      '%'			; If not "%" then it is not static...
0B3AEC 25 
0B3AED 20    1646** JR      NZ,LOC1         	; Branch here
0B3AEE 21 
0B3AEF FD    1647** LD      A,(IY+2)		; Check the 3rd character
0B3AF0 7E 
0B3AF1 02 
0B3AF2 FE    1648** CP      '('			; If it is "(" (array) then it is not static...
0B3AF3 28 
0B3AF4 28    1649** JR      Z,LOC1          	; Branch here
0B3AF5 1A 
             1650** ;
             1651** ; At this point we're dealing with a static variable
             1652** ;
0B3AF6 29    1653** ADD     HL,HL			; HL: Variable index * 4
0B3AF7 29    1654** ADD	HL,HL
0B3AF8 11    1655** LD      DE,STAVAR       	; The static variable area in memory
0B3AF9 00 
0B3AFA 5D 
0B3AFB 0B 
0B3AFC 19    1656** ADD     HL,DE			; HL: The address of the static variable
0B3AFD FD    1657** INC     IY			; Skip the program pointer past the static variable name
0B3AFE 23 
0B3AFF FD    1658** INC     IY
0B3B00 23 
0B3B01 16    1659** LD      D,4             	; Set the type to be integer
0B3B02 04 
0B3B03 AF    1660** XOR     A			; Set the Z flag
0B3B04 C9    1661** RET
             1662** ;
             1663** ; At this point it's potentially a dynamic variable, just need to do a few more checks
             1664** ;
0B3B05 FE    1665** LOC0:			CP      '_'-'@'			; Check the first character is in
0B3B06 1F 
0B3B07 D8    1666** RET     C			; the range "_" to
0B3B08 FE    1667** CP      'z'-'@'+1		; "z" (lowercase characters only)
0B3B09 3B 
0B3B0A 3F    1668** CCF				; If it is not in range then
0B3B0B 3D    1669** DEC     A               	; Set NZ flag and
0B3B0C D8    1670** RET     C			; Exit here
0B3B0D D6    1671** SUB     3			; This brings it in the range of 27 upwards (need to confirm)
0B3B0E 03 
0B3B0F 6F    1672** LD	L, A			; HL = A
             1673** ;
             1674** ; Yes, it's definitely a dynamic variable at this point...
             1675** ;
0B3B10 7D    1676** LOC1:			LD	A, L			; Fetch variable index
0B3B11 87    1677** ADD	A, A			; x 2
0B3B12 85    1678** ADD	A, L			; x 3
0B3B13 D6    1679** SUB	3			; Subtract 2 TODO: Should be 3
0B3B14 03 
0B3B15 6F    1680** LD	L, A
0B3B16 11    1681** LD      DE, DYNVAR       	; The dynamic variable storage
0B3B17 6C 
0B3B18 5D 
0B3B19 0B 
0B3B1A D8    1682** RET	C			; Bounds check to trap for variable '@'
0B3B1B 19    1683** ADD     HL, DE			; HL: Address of first entry
             1684** ;
             1685** ; Loop through the linked list of variables to find a match
             1686** ;
0B3B1C ED    1687** LOC2:			LD	DE, (HL)		; Fetch the original pointer
0B3B1D 17 
0B3B1E E5    1688** PUSH	HL			; Need to preserve HL for LOC6
0B3B1F AF    1689** XOR	A			; Reset carry flag
0B3B20 ED    1690** SBC	HL, HL			; Set HL to 0
0B3B21 62 
0B3B22 ED    1691** SBC	HL, DE			; Compare with 0
0B3B23 52 
0B3B24 E1    1692** POP	HL			; Restore the original pointer
0B3B25 28    1693** JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
0B3B26 49 
             1694** ; LD	HL, DE			; Make a copy of this pointer in HL
0B3B27 D5    1695** push de
0B3B28 E1    1696** pop hl ; how was that even possible?
0B3B29 23    1697** INC     HL              	; Skip the link (24-bits)
0B3B2A 23    1698** INC     HL
0B3B2B 23    1699** INC	HL			; HL: Address of the variable name in DYNVARS
0B3B2C FD    1700** PUSH    IY			; IY: Address of the variable name in the program
0B3B2D E5 
             1701** ;
0B3B2E 7E    1702** LOC3:			LD      A,(HL)         		; Compare
0B3B2F 23    1703** INC     HL
0B3B30 FD    1704** INC     IY
0B3B31 23 
0B3B32 FD    1705** CP      (IY)
0B3B33 BE 
0B3B34 00 
0B3B35 28    1706** JR      Z, LOC3			; Keep looping whilst we've got a match...
0B3B36 F7 
0B3B37 B7    1707** OR      A               	; Have we hit a terminator?
0B3B38 28    1708** JR      Z,LOC5          	; Yes, so maybe we've found a variable
0B3B39 07 
             1709** ;
0B3B3A FD    1710** LOC4:			POP     IY			; Restore the pointer in the program
0B3B3B E1 
0B3B3C EB    1711** EX      DE, HL			; HL: New pointer in DYNVARS
0B3B3D C3    1712** JP      LOC2            	; Loop round and try again
0B3B3E 1C 
0B3B3F 3B 
0B3B40 0B 
             1713** ;
             1714** ; We might have located a variable at this point, just need to do a few more tests
             1715** ;
0B3B41 FD    1716** LOC5:			DEC     IY
0B3B42 2B 
0B3B43 FD    1717** LD      A,(IY)
0B3B44 7E 
0B3B45 00 
0B3B46 FE    1718** CP      '('
0B3B47 28 
0B3B48 28    1719** JR      Z,LOC5A         	; FOUND
0B3B49 15 
0B3B4A FD    1720** INC     IY
0B3B4B 23 
0B3B4C CD    1721** CALL    RANGE
0B3B4D 33 
0B3B4E 3C 
0B3B4F 0B 
0B3B50 38    1722** JR      C,LOC5A         	; FOUND
0B3B51 0D 
0B3B52 FE    1723** CP      '('
0B3B53 28 
0B3B54 28    1724** JR      Z,LOC4          	; KEEP LOOKING
0B3B55 E4 
0B3B56 FD    1725** LD      A,(IY-1)
0B3B57 7E 
0B3B58 FF 
0B3B59 CD    1726** CALL    RANGE1
0B3B5A 3F 
0B3B5B 3C 
0B3B5C 0B 
0B3B5D 30    1727** JR      NC,LOC4         	; KEEP LOOKING
0B3B5E DB 
0B3B5F D1    1728** LOC5A:			POP     DE
0B3B60 FD    1729** TYPE_:			LD      A,(IY-1)		; Check the string type postfix
0B3B61 7E 
0B3B62 FF 
0B3B63 FE    1730** CP      '$'			; Is it a string?
0B3B64 24 
0B3B65 16    1731** LD      D,129			; Yes, so return D = 129
0B3B66 81 
0B3B67 C8    1732** RET     Z
0B3B68 FE    1733** CP      '%'			; Is it an integer?
0B3B69 25 
0B3B6A 16    1734** LD      D,4			; Yes, so return D = 4
0B3B6B 04 
0B3B6C C8    1735** RET     Z
0B3B6D 14    1736** INC     D			; At this point it must be a float
0B3B6E BF    1737** CP      A			; Set the flags
0B3B6F C9    1738** RET
             1739** ;
             1740** ; The variable is undefined at this point; HL will be zero
             1741** ;
0B3B70 3C    1742** LOC6:			INC     A               	; Set NZ flag
0B3B71 C9    1743** RET
             1744** ;
             1745** ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
             1746** ;   Inputs: HL, IY as returned from LOCATE (NZ).
             1747** ;  Outputs: As LOCATE, GETDEF.
             1748** ; Destroys: As LOCATE, GETDEF.
             1749** ;
0B3B72 AF    1750** CREATE:			XOR     A
0B3B73 ED    1751** LD      DE,(FREE)		; Get the last byte of available RAM
0B3B74 5B 
0B3B75 1D 
0B3B76 5E 
0B3B76 0B   
0B3B78 ED    1752** LD	(HL), DE		; Store
0B3B79 1F 
0B3B7A EB    1753** EX      DE,HL
0B3B7B 77    1754** LD      (HL),A			; Clear the link of the new entity
0B3B7C 23    1755** INC     HL
0B3B7D 77    1756** LD      (HL),A
0B3B7E 23    1757** INC     HL
0B3B7F 77    1758** LD      (HL),A
0B3B80 23    1759** INC     HL
0B3B81 FD    1760** LOC7:			INC     IY
0B3B82 23 
0B3B83 CD    1761** CALL    RANGE           	; END OF VARIABLE?
0B3B84 33 
0B3B85 3C 
0B3B86 0B 
0B3B87 38    1762** JR      C,LOC8
0B3B88 15 
0B3B89 77    1763** LD      (HL),A
0B3B8A 23    1764** INC     HL
0B3B8B CD    1765** CALL    RANGE1
0B3B8C 3F 
0B3B8D 3C 
0B3B8E 0B 
0B3B8F 30    1766** JR      NC,LOC7
0B3B90 F0 
0B3B91 FE    1767** CP      '('
0B3B92 28 
0B3B93 28    1768** JR      Z,LOC8
0B3B94 09 
0B3B95 FD    1769** LD      A,(IY+1)
0B3B96 7E 
0B3B97 01 
0B3B98 FE    1770** CP      '('
0B3B99 28 
0B3B9A 28    1771** JR      Z,LOC7
0B3B9B E5 
0B3B9C FD    1772** INC     IY
0B3B9D 23 
0B3B9E 36    1773** LOC8:			LD      (HL),0          	; TERMINATOR
0B3B9F 00 
0B3BA0 23    1774** INC     HL
0B3BA1 E5    1775** PUSH    HL
0B3BA2 CD    1776** CALL    TYPE_			; Get the variable type in D
0B3BA3 60 
0B3BA4 3B 
0B3BA5 0B 
0B3BA6 3E    1777** LD      A,4			; If it is an integer then it takes up 4 bytes
0B3BA7 04 
0B3BA8 BA    1778** CP      D
0B3BA9 28    1779** JR      Z,LOC9			; So skip the next bit
0B3BAA 01 
0B3BAB 3C    1780** INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0B3BAC 36    1781** LOC9:			LD      (HL),0          	; Initialise the memory to zero
0B3BAD 00 
0B3BAE 23    1782** INC     HL
0B3BAF 3D    1783** DEC     A
0B3BB0 20    1784** JR      NZ,LOC9
0B3BB1 FA 
0B3BB2 22    1785** LD      (FREE),HL		; Adjust the stack
0B3BB3 1D 
0B3BB4 5E 
0B3BB5 0B 
0B3BB6 CD    1786** CALL    CHECK			; Check whether we are out of space
0B3BB7 13 
0B3BB8 16 
0B3BB9 0B 
0B3BBA E1    1787** POP     HL
0B3BBB AF    1788** XOR     A
0B3BBC C9    1789** RET
             1790** ;
             1791** ; LINNUM - GET LINE NUMBER FROM TEXT STRING
             1792** ;   Inputs: IY = Text Pointer
             1793** ;  Outputs: HL = Line number (zero if none)
             1794** ;           IY updated
             1795** ; Destroys: A,D,E,H,L,IY,F
             1796** ;
             1797** ; This bit of code performs a BASE 10 shift to build up the number
             1798** ; So if the string passed is "345", the algorithm does this:
             1799** ;
             1800** ;    HL : Digit	: Operation
             1801** ; ----- : ----- : ---------
             1802** ; 00000 :	:
             1803** ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
             1804** ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
             1805** ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
             1806** ;
             1807** ; The multiply by 10 is done by an unrolled shift and add loop
             1808** ;
0B3BBD CD    1809** LINNUM:			CALL    NXT			; Skip whitespace to the first character
0B3BBE 34 
0B3BBF 0A 
0B3BC0 0B 
0B3BC1 40    1810** LD.SIS  HL,0			; The running total
0B3BC2 21 
0B3BC3 00 
0B3BC4 00 
0B3BC5 FD    1811** LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
0B3BC6 7E 
0B3BC7 00 
0B3BC8 D6    1812** SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
0B3BC9 30 
0B3BCA D8    1813** RET     C			; And return if less than 0
0B3BCB FE    1814** CP      10			; Or greater than or equal to 10
0B3BCC 0A 
0B3BCD D0    1815** RET     NC			; As we've hit a non-numeric character (end of number) at this point
0B3BCE FD    1816** INC     IY			; Increment the string pointer
0B3BCF 23 
0B3BD0 54    1817** LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
0B3BD1 5D    1818** LD      E,L			; Store the original number in DE
0B3BD2 52    1819** ADD.S   HL,HL           	; *2
0B3BD3 29 
0B3BD4 38    1820** JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
0B3BD5 13 
0B3BD6 52    1821** ADD.S   HL,HL           	; *4S
0B3BD7 29 
0B3BD8 38    1822** JR      C,TOOBIG
0B3BD9 0F 
0B3BDA 52    1823** ADD.S   HL,DE           	; *5
0B3BDB 19 
0B3BDC 38    1824** JR      C,TOOBIG
0B3BDD 0B 
0B3BDE 52    1825** ADD.S   HL,HL           	; *10
0B3BDF 29 
0B3BE0 38    1826** JR      C,TOOBIG
0B3BE1 07 
0B3BE2 5F    1827** LD      E,A			; A->DE: the digit to add in
0B3BE3 16    1828** LD      D,0
0B3BE4 00 
0B3BE5 52    1829** ADD.S   HL,DE           	; Add in the digit to the running total
0B3BE6 19 
0B3BE7 30    1830** JR      NC,LINNM1       	; And if it is still <= 65535, loop
0B3BE8 DC 
             1831** ;
0B3BE9 3E    1832** TOOBIG:			LD      A,20
0B3BEA 14 
0B3BEB C3    1833** JP      ERROR_           	; Error: "Too big"
0B3BEC 24 
0B3BED 37 
0B3BEE 0B 
             1834** ;
             1835** ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
             1836** ;   Inputs: IY = text pointer
             1837** ;  Outputs: HL = first number (10 by default)
             1838** ;           BC = second number (10 by default)
             1839** ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
             1840** ;
0B3BEF CD    1841** PAIR:			CALL    LINNUM          	; Parse the first line number
0B3BF0 BD 
0B3BF1 3B 
0B3BF2 0B 
0B3BF3 7C    1842** LD      A,H			; If it is not zero, then...
0B3BF4 B5    1843** OR      L
0B3BF5 20    1844** JR      NZ,PAIR1		; Skip...
0B3BF6 02 
0B3BF7 2E    1845** LD      L,10			; HL: the default value (10)
0B3BF8 0A 
             1846** ;
0B3BF9 CD    1847** PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
0B3BFA 3E 
0B3BFB 17 
0B3BFC 0B 
0B3BFD FD    1848** INC     IY			; Skip to next character
0B3BFE 23 
0B3BFF E5    1849** PUSH    HL			; Stack the first line number
0B3C00 21    1850** LD      HL,10			; HL: the second default (10)
0B3C01 0A 
0B3C02 00 
0B3C03 00 
0B3C04 C4    1851** CALL    NZ,LINNUM       	; Parse the second line number
0B3C05 BD 
0B3C06 3B 
0B3C07 0B 
0B3C08 E3    1852** EX      (SP),HL			; HL: The first line number (off the stack)
0B3C09 C1    1853** POP     BC			; BC: Second line number
0B3C0A 78    1854** LD      A,B			; If the second line number is not zero then...
0B3C0B B1    1855** OR      C			; We're good...
0B3C0C C0    1856** RET     NZ			; Exit, otherwise...
0B3C0D CD    1857** CALL    EXTERR			; Throw error: "Silly"
0B3C0E 3B 
0B3C0F 37 
0B3C10 0B 
0B3C11 53    1858** DB    	"Silly", 0
0B3C12 69 
0B3C13 6C 
0B3C14 6C 
0B3C14 79   
0B3C15 00 
             1859** ;
             1860** ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
             1861** ;   Inputs: IY = text pointer
             1862** ;  Outputs: HL = points to program text
             1863** ;           BC = second number (0 by default)
             1864** ; Destroys: A,B,C,D,E,H,L,IY,F
             1865** ;
0B3C17 CD    1866** DLPAIR:			CALL    LINNUM			; Parse the first line number
0B3C18 BD 
0B3C19 3B 
0B3C1A 0B 
0B3C1B E5    1867** PUSH    HL			; Stack it
0B3C1C CD    1868** CALL    TERMQ			; Check for ELSE, : or CR
0B3C1D 3E 
0B3C1E 17 
0B3C1F 0B 
0B3C20 28    1869** JR      Z,DLP1			; And exit if so
0B3C21 0A 
0B3C22 FE    1870** CP      TIF			; Is the token IF?
0B3C23 E7 
0B3C24 28    1871** JR      Z,DLP1			; Yes, so skip the next bit...
0B3C25 06 
0B3C26 FD    1872** INC     IY			; Otherwise...
0B3C27 23 
0B3C28 CD    1873** CALL    LINNUM			; Fetch the second line number
0B3C29 BD 
0B3C2A 3B 
0B3C2B 0B 
0B3C2C E3    1874** DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
0B3C2D CD    1875** CALL    FINDL			; HL: Find the address of the line
0B3C2E 53 
0B3C2F 39 
0B3C30 0B 
0B3C31 C1    1876** POP     BC			; BC: The second number
0B3C32 C9    1877** RET
             1878** ;
             1879** ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
             1880** ;   Inputs: IY addresses character
             1881** ;  Outputs: Carry set if out-of-range.
             1882** ; Destroys: A,F
             1883** ;
             1884** ; It is called here to check the following
             1885** ; In range: "$", "%" and "("
             1886** ;   Plus all characters in RANGE1 and RANGE2
             1887** ;
0B3C33 FD    1888** RANGE:			LD      A,(IY)			; Fetch the character
0B3C34 7E 
0B3C35 00 
0B3C36 FE    1889** CP      '$'			; Postfix for string variable is valid
0B3C37 24 
0B3C38 C8    1890** RET     Z
0B3C39 FE    1891** CP      '%'			; Postfix for integer variable is valid
0B3C3A 25 
0B3C3B C8    1892** RET     Z
0B3C3C FE    1893** CP      '('			; Postfix for array is valid
0B3C3D 28 
0B3C3E C8    1894** RET     Z
             1895** ;
             1896** ; It is called here to check the following
             1897** ; In range: "0" to "9" and "@"
             1898** ;   Plus all characters in RANGE2
             1899** ;
0B3C3F FE    1900** RANGE1:			CP      '0'			; If it is between '0'...
0B3C40 30 
0B3C41 D8    1901** RET     C
0B3C42 FE    1902** CP      '9'+1			; And '9'...
0B3C43 3A 
0B3C44 3F    1903** CCF
0B3C45 D0    1904** RET     NC			; Then it is valid
0B3C46 FE    1905** CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
0B3C47 40 
0B3C48 C8    1906** RET     Z
             1907** ;
             1908** ; It is called here to check the following
             1909** ; In range: "A" to "Z", "a' to "z", "_" and "`"
             1910** ;
0B3C49 FE    1911** RANGE2:			CP      'A'			; If it is between 'A'...
0B3C4A 41 
0B3C4B D8    1912** RET     C
0B3C4C FE    1913** CP      'Z'+1			; And 'Z'...
0B3C4D 5B 
0B3C4E 3F    1914** CCF
0B3C4F D0    1915** RET     NC			; Then it is valid
0B3C50 FE    1916** CP      '_'			; If it is underscore, grave, or between 'a'
0B3C51 5F 
0B3C52 D8    1917** RET     C
0B3C53 FE    1918** CP      'z'+1			; And 'z'
0B3C54 7B 
0B3C55 3F    1919** CCF				; Then it is valid
0B3C56 C9    1920** RET
             1921** ;
             1922** ; Throw a 'LINE space' error (line too long)
             1923** ; This is called from LEXAN
             1924** ;
0B3C57 AF    1925** SPACE_: 		XOR     A
0B3C58 CD    1926** CALL    EXTERR          	; "LINE space"
0B3C59 3B 
0B3C5A 37 
0B3C5B 0B 
0B3C5C 86    1927** DB    	LINE_MN_, 8, 0
0B3C5D 08 
0B3C5E 00 
             1928** ;
             1929** ; LEXAN - LEXICAL ANALYSIS.
             1930** ;  Bit 0,C: 1=left, 0=right
             1931** ;  Bit 2,C: 1=in BINARY
             1932** ;  Bit 3,C: 1=in HEX
             1933** ;  Bit 4,C: 1=accept line number
             1934** ;  Bit 5,C: 1=in variable, FN, PROC
             1935** ;  Bit 6,C: 1=in REM, DATA, *
             1936** ;  Bit 7,C: 1=in quotes
             1937** ;   Inputs: IY addresses source string
             1938** ;           DE addresses destination string (must be page boundary)
             1939** ;            C sets initial mode
             1940** ;  Outputs: DE, IY updated
             1941** ;            A holds carriage return
             1942** ;
0B3C5F 12    1943** LEXAN1:			LD      (DE),A          	; Transfer to buffer
0B3C60 13    1944** INC     DE              	; Increment the pointers
0B3C61 FD    1945** INC     IY			; And fall through to the main function
0B3C62 23 
             1946** ;
             1947** ; This is the main entry point
             1948** ;
0B3C63 7B    1949** LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
0B3C64 FE    1950** CP      252             	; If it is >= 252 bytes, then...
0B3C65 FC 
0B3C66 30    1951** JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0B3C67 EF 
0B3C68 FD    1952** LD      A,(IY)			; Fetch character from source string
0B3C69 7E 
0B3C6A 00 
0B3C6B FE    1953** CP      CR			; If it is a CR
0B3C6C 0D 
0B3C6D C8    1954** RET     Z               	; Then it is end of line; we're done parsing
0B3C6E CD    1955** CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B3C6F 3F 
0B3C70 3C 
0B3C71 0B 
0B3C72 30    1956** JR      NC,LEXAN3		; Yes, so skip
0B3C73 06 
0B3C74 CB    1957** RES     5,C             	; FLAG: NOT IN VARIABLE
0B3C75 A9 
0B3C76 CB    1958** RES     3,C             	; FLAG: NOT IN HEX
0B3C77 99 
0B3C78 CB    1959** RES	2,C			; FLAG: NOT IN BINARY
0B3C79 91 
             1960** ;
0B3C7A FE    1961** LEXAN3:			CP      ' '			; Ignore spaces
0B3C7B 20 
0B3C7C 28    1962** JR      Z,LEXAN1
0B3C7D E1 
0B3C7E FE    1963** CP      ','			; Ignore commas
0B3C7F 2C 
0B3C80 28    1964** JR      Z,LEXAN1
0B3C81 DD 
0B3C82 FE    1965** CP	'2'			; If less than '2'
0B3C83 32 
0B3C84 30    1966** JR	NC, @F			; No, so skip
0B3C85 02 
0B3C86 CB    1967** RES	2,C			; FLAG: NOT IN BINARY
0B3C87 91 
0B3C88 FE    1968** @@:			CP      'G'			; If less then 'G'
0B3C89 47 
0B3C8A 38    1969** JR      C,LEXAN4		; Yes, so skip
0B3C8B 02 
0B3C8C CB    1970** RES     3,C             	; FLAG: NOT IN HEX
0B3C8D 99 
             1971** ;
0B3C8E FE    1972** LEXAN4:			CP      34			; Is it a quote character?
0B3C8F 22 
0B3C90 20    1973** JR      NZ,LEXAN5		; No, so skip
0B3C91 05 
0B3C92 CB    1974** RL      C			; Toggle bit 7 of C by shifting it into carry flag
0B3C93 11 
0B3C94 3F    1975** CCF                     	; Toggle the carry
0B3C95 CB    1976** RR      C			; And then shifting it back into bit 7 of C
0B3C96 19 
             1977** ;
0B3C97 CB    1978** LEXAN5:			BIT     4,C			; Accept line number?
0B3C98 61 
0B3C99 28    1979** JR      Z,LEXAN6		; No, so skip
0B3C9A 12 
0B3C9B CB    1980** RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
0B3C9C A1 
0B3C9D C5    1981** PUSH    BC
0B3C9E D5    1982** PUSH    DE
0B3C9F CD    1983** CALL    LINNUM         		; Parse the line number to HL
0B3CA0 BD 
0B3CA1 3B 
0B3CA2 0B 
0B3CA3 D1    1984** POP     DE
0B3CA4 C1    1985** POP     BC
0B3CA5 7C    1986** LD      A,H			; If it is not zero
0B3CA6 B5    1987** OR      L
0B3CA7 C4    1988** CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
0B3CA8 20 
0B3CA9 3D 
0B3CAA 0B 
0B3CAB 18    1989** JR      LEXAN2          	; And loop
0B3CAC B6 
             1990** ;
0B3CAD 0D    1991** LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0B3CAE 28    1992** JR      Z,LEXAN7        	; If so, skip
0B3CAF 0A 
0B3CB0 0C    1993** INC     C			; Otherwise restore C
0B3CB1 20    1994** JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0B3CB2 AC 
0B3CB3 B7    1995** OR      A			; Set the flags based on the character
0B3CB4 F4    1996** CALL    P,LEX           	; Tokenise if A < 128
0B3CB5 8B 
0B3CB6 37 
0B3CB7 0B 
0B3CB8 18    1997** JR      LEXAN8			; And skip
0B3CB9 13 
             1998** ;
             1999** ; Processing the LEFT hand side here
             2000** ;
0B3CBA FE    2001** LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0B3CBB 2A 
0B3CBC 28    2002** JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0B3CBD 17 
0B3CBE B7    2003** OR      A			; Set the flags based on the character
0B3CBF F4    2004** CALL    P,LEX           	; Tokenise if A < 128
0B3CC0 8B 
0B3CC1 37 
0B3CC2 0B 
             2005** ;
             2006** ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
             2007** ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
             2008** ; Examples:
             2009** ;   LET A% = PAGE : REM This is the GET version
             2010** ;   PAGE = 40000  : REM This is the SET version
             2011** ;
0B3CC3 FE    2012** CP      TOKLO			; TOKLO is 8Fh
0B3CC4 8F 
0B3CC5 38    2013** JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
0B3CC6 06 
0B3CC7 FE    2014** CP      TOKHI+1			; TOKHI is 93h
0B3CC8 94 
0B3CC9 30    2015** JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
0B3CCA 02 
0B3CCB C6    2016** ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
0B3CCC 40 
             2017** ;
0B3CCD FE    2018** LEXAN8:			CP      REM			; If the token is REM
0B3CCE F4 
0B3CCF 28    2019** JR      Z,LEXAN9		; Then stop tokenising
0B3CD0 04 
0B3CD1 FE    2020** CP      DATA_MN_			; If it is not DATA then
0B3CD2 DC 
0B3CD3 20    2021** JR      NZ,LEXANA		; Skip
0B3CD4 02 
0B3CD5 CB    2022** LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
0B3CD6 F1 
             2023** ;
0B3CD7 FE    2024** LEXANA:			CP      FN			; If the token is FN
0B3CD8 A4 
0B3CD9 28    2025** JR      Z,LEXANB
0B3CDA 0A 
0B3CDB FE    2026** CP      PROC			; Or the token is PROC
0B3CDC F2 
0B3CDD 28    2027** JR      Z,LEXANB		; Then jump to here
0B3CDE 06 
0B3CDF CD    2028** CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
0B3CE0 49 
0B3CE1 3C 
0B3CE2 0B 
0B3CE3 38    2029** JR      C,LEXANC		; Jump here if out of range
0B3CE4 02 
             2030** ;
0B3CE5 CB    2031** LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
0B3CE6 E9 
0B3CE7 FE    2032** LEXANC:			CP      '&'			; Check for hex prefix
0B3CE8 26 
0B3CE9 20    2033** JR      NZ,LEXAND		; If not, skip
0B3CEA 02 
0B3CEB CB    2034** SET     3,C             	; FLAG: IN HEX
0B3CEC D9 
             2035** ;
0B3CED FE    2036** LEXAND:			CP	'%'			; Check for binary prefix
0B3CEE 25 
0B3CEF 20    2037** JR	NZ,LEXANE		; If not, skip
0B3CF0 02 
0B3CF1 CB    2038** SET	2,C			; FLAG: IN BINARY
0B3CF2 D1 
             2039** ;
0B3CF3 21    2040** LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
0B3CF4 17 
0B3CF5 3D 
0B3CF6 0B 
0B3CF7 C5    2041** PUSH    BC
0B3CF8 01    2042** LD      BC,LIST1L		; The list length
0B3CF9 06 
0B3CFA 00 
0B3CFB 00 
0B3CFC ED    2043** CPIR				; Check if the token is in this list
0B3CFD B1 
0B3CFE C1    2044** POP     BC
0B3CFF 20    2045** JR      NZ,LEXANF		; If not, then skip
0B3D00 02 
0B3D01 CB    2046** SET     4,C             	; FLAG: ACCEPT LINE NUMBER
0B3D02 E1 
             2047** ;
0B3D03 21    2048** LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
0B3D04 1B 
0B3D05 3D 
0B3D06 0B 
0B3D07 C5    2049** PUSH    BC
0B3D08 01    2050** LD      BC,LIST2L		; The list length
0B3D09 05 
0B3D0A 00 
0B3D0B 00 
0B3D0C ED    2051** CPIR				; Check if the token is in this list
0B3D0D B1 
0B3D0E C1    2052** POP     BC
0B3D0F 20    2053** JR      NZ,LEXANG		; If not, then skip
0B3D10 02 
0B3D11 CB    2054** SET     0,C             	; FLAG: ENTER LEFT MODE
0B3D12 C1 
0B3D13 C3    2055** LEXANG:			JP      LEXAN1			; And loop
0B3D14 5F 
0B3D15 3C 
0B3D16 0B 
             2056** 
             2057** ;
             2058** ; LIST1: List of tokens that must be followed by line numbers
             2059** ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
             2060** ;
0B3D17 E5    2061** LIST1:			DB	GOTO
0B3D18 E4    2062** DB	GOSUB
0B3D19 F7    2063** DB	RESTOR
0B3D1A FC    2064** DB	TRACE
0B3D1B 8C    2065** LIST2:			DB	THEN_MN_
0B3D1C 8B    2066** DB	ELSE_MN_
             2067** LIST1L:			EQU     $-LIST1
0B3D1D F5    2068** DB	REPEAT
0B3D1E 85    2069** DB	TERROR_MN
0B3D1F 3A    2070** DB    	':'
             2071** LIST2L:			EQU     $-LIST2
             2072** ;
             2073** ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
             2074** ;   Inputs: HL=line number, DE=string pointer
             2075** ;  Outputs: DE updated, BIT 4,C set.
             2076** ; Destroys: A,B,C,D,E,F
             2077** ;
             2078** ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
             2079** ;
             2080** ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
             2081** ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
             2082** ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
             2083** ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
             2084** ; each byte are then stored, in LO/HI order, ORred with 0x40.
             2085** ;
0B3D20 CB    2086** ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
0B3D21 E1 
0B3D22 EB    2087** EX      DE, HL			; HL: string pointer, DE: line number
0B3D23 36    2088** LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
0B3D24 8D 
0B3D25 23    2089** INC     HL
0B3D26 7A    2090** LD      A,D			; Get the high byte
0B3D27 E6    2091** AND     0C0H			; Get the top two bits	DD000000
0B3D28 C0 
0B3D29 0F    2092** RRCA				; Shift right		00DD0000
0B3D2A 0F    2093** RRCA
0B3D2B 47    2094** LD      B,A			; Store in B
0B3D2C 7B    2095** LD      A,E			; Get the low byte
0B3D2D E6    2096** AND     0C0H			; Get the top two bits	EE000000
0B3D2E C0 
0B3D2F B0    2097** OR      B			; Combine with D	EEDD0000
0B3D30 0F    2098** RRCA				; Shift right		00EEDD00
0B3D31 0F    2099** RRCA
0B3D32 EE    2100** XOR     01010100B		; XOR with 54h
0B3D33 54 
0B3D34 77    2101** LD      (HL),A			; Store this as the second byte
0B3D35 23    2102** INC     HL
0B3D36 7B    2103** LD      A,E			; Get the low byte
0B3D37 E6    2104** AND     3FH			; Strip the top two bits off
0B3D38 3F 
0B3D39 F6    2105** OR      '@'			; OR with 40h
0B3D3A 40 
0B3D3B 77    2106** LD      (HL),A			; Store
0B3D3C 23    2107** INC     HL
0B3D3D 7A    2108** LD      A,D			; Get the high byte
0B3D3E E6    2109** AND     3FH			; Strip the top two bits off
0B3D3F 3F 
0B3D40 F6    2110** OR      '@'			; OR with 40h
0B3D41 40 
0B3D42 77    2111** LD      (HL),A			; Store
0B3D43 23    2112** INC     HL
0B3D44 EB    2113** EX      DE,HL			; DE: string pointer, HL: line number
0B3D45 C9    2114** RET
             2115** ;
             2116** ; TEXT - OUTPUT MESSAGE.
             2117** ;   Inputs: HL addresses text (terminated by nul)
             2118** ;  Outputs: HL addresses character following nul.
             2119** ; Destroys: A,H,L,F
             2120** ;
0B3D46 2A    2121** REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
0B3D47 2F 
0B3D48 5E 
0B3D49 0B 
             2122** ;
0B3D4A 7E    2123** TEXT_:			LD      A, (HL)			; Fetch the character
0B3D4B 23    2124** INC     HL			; Increment pointer to next character
0B3D4C B7    2125** OR      A			; Check for the nul (0) string terminator
0B3D4D C8    2126** RET     Z			; And return if so
0B3D4E CD    2127** CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
0B3D4F 30 
0B3D50 39 
0B3D51 0B 
0B3D52 18    2128** JR      TEXT_			; And loop
0B3D53 F6 
             2129** ;
             2130** ; TELL - OUTPUT MESSAGE.
             2131** ;   Inputs: Text follows subroutine call (term=nul)
             2132** ; Destroys: A,F
             2133** ;
             2134** ; Example usage:
             2135** ;
             2136** ;	CALL	TELL			Call the function
             2137** ;	DB	"Hello World", 0	Followed by a zero terminated string
             2138** ;	LD	A, (1234H)		Program execution will carry on here after the message is output
             2139** ;
0B3D54 E3    2140** TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
0B3D55 CD    2141** CALL    TEXT_			; first byte of the string that follows it. Print it, then
0B3D56 4A 
0B3D57 3D 
0B3D58 0B 
0B3D59 E3    2142** EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
0B3D5A C9    2143** RET				; at this point we'll return to the first instruction after the message
              0008* include "basic/misc.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Miscellaneous helper functions
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	12/05/2023
             0006** ;
             0007** ; Modinfo:
             0008** 
             0009** ; INCLUDE	"equs.inc"
             0010** ; INCLUDE	"macros.inc"
             0011** 
             0012** ; .ASSUME	ADL = 1
             0013** 
             0014** ; SEGMENT CODE
             0015** 
             0016** ; XDEF	ASC_TO_NUMBER
             0017** ; XDEF	SWITCH_A
             0018** ; XDEF	NULLTOCR
             0019** ; XDEF	CRTONULL
             0020** ; XDEF	CSTR_FNAME
             0021** ; XDEF	CSTR_LINE
             0022** ; XDEF	CSTR_FINDCH
             0023** ; XDEF	CSTR_ENDSWITH
             0024** ; XDEF	CSTR_CAT
             0025** 
             0026** ; XREF	OSWRCH
             0027** ; XREF	KEYWDS
             0028** ; XREF	KEYWDL
             0029** 
             0030** ; Read a number and convert to binary
             0031** ; If prefixed with &, will read as hex, otherwise decimal
             0032** ;   Inputs: HL: Pointer in string buffer
             0033** ;  Outputs: HL: Updated text pointer
             0034** ;           DE: Value
             0035** ;            A: Terminator (spaces skipped)
             0036** ; Destroys: A,D,E,H,L,F
             0037** ;
0B3D5B C5    0038** ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0B3D5C 11    0039** LD	DE, 0			; Initialise DE
0B3D5D 00 
0B3D5E 00 
0B3D5F 00 
0B3D60 CD    0040** CALL	SKIPSPC			; Skip whitespace
0B3D61 A2 
0B3D62 3D 
0B3D63 0B 
0B3D64 7E    0041** LD	A, (HL)			; Read first character
0B3D65 FE    0042** CP	'&'			; Is it prefixed with '&' (HEX number)?
0B3D66 26 
0B3D67 20    0043** JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B3D68 1F 
0B3D69 23    0044** INC	HL			; Otherwise fall through to ASC_TO_HEX
             0045** ;
0B3D6A 7E    0046** ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0B3D6B CD    0047** CALL    UPPERC			; Convert to uppercase
0B3D6C B0 
0B3D6D 3D 
0B3D6E 0B 
0B3D6F D6    0048** SUB	'0'			; Normalise to 0
0B3D70 30 
0B3D71 38    0049** JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B3D72 2E 
0B3D73 FE    0050** CP 	10			; Check if >= 10
0B3D74 0A 
0B3D75 38    0051** JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0B3D76 06 
0B3D77 D6    0052** SUB 	7			; Adjust ASCII A-F to nibble
0B3D78 07 
0B3D79 FE    0053** CP 	16			; Check for > F
0B3D7A 10 
0B3D7B 30    0054** JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0B3D7C 24 
0B3D7D EB    0055** ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0B3D7E 29    0056** ADD	HL, HL
0B3D7F 29    0057** ADD	HL, HL
0B3D80 29    0058** ADD	HL, HL
0B3D81 29    0059** ADD	HL, HL
0B3D82 EB    0060** EX	DE, HL
0B3D83 B3    0061** OR      E			; OR the new digit in to the least significant nibble
0B3D84 5F    0062** LD      E, A
0B3D85 23    0063** INC     HL			; Onto the next character
0B3D86 18    0064** JR      ASC_TO_NUMBER1		; And loop
0B3D87 E2 
             0065** ;
0B3D88 7E    0066** ASC_TO_NUMBER3:		LD	A, (HL)
0B3D89 D6    0067** SUB	'0'			; Normalise to 0
0B3D8A 30 
0B3D8B 38    0068** JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B3D8C 14 
0B3D8D FE    0069** CP	10			; Check if >= 10
0B3D8E 0A 
0B3D8F 30    0070** JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0B3D90 10 
0B3D91 EB    0071** EX 	DE, HL 			; Stick DE in HL
0B3D92 44    0072** LD	B, H 			; And copy HL into BC
0B3D93 4D    0073** LD	C, L
0B3D94 29    0074** ADD	HL, HL 			; x 2
0B3D95 29    0075** ADD	HL, HL 			; x 4
0B3D96 09    0076** ADD	HL, BC 			; x 5
0B3D97 29    0077** ADD	HL, HL 			; x 10
0B3D98 EB    0078** EX	DE, HL
             0079** ADD8U_DE 			; Add A to DE (macro)
0B3D99 83   0001**M ADD	A, E
0B3D9A 5F   0002**M LD	E, A
0B3D9B 8A   0003**M ADC	A, D
0B3D9C 93   0004**M SUB	E
0B3D9D 57   0005**M LD	D, A
0B3D9E 23    0080** INC	HL
0B3D9F 18    0081** JR	ASC_TO_NUMBER3
0B3DA0 E7 
0B3DA1 C1    0082** ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
             0083** 
             0084** ; Skip a space
             0085** ; HL: Pointer in string buffer
             0086** ;
0B3DA2 7E    0087** SKIPSPC:			LD      A, (HL)
0B3DA3 FE    0088** CP      ' '
0B3DA4 20 
0B3DA5 C0    0089** RET     NZ
0B3DA6 23    0090** INC     HL
0B3DA7 18    0091** JR      SKIPSPC
0B3DA8 F9 
             0092** 
             0093** ; Skip a string
             0094** ; HL: Pointer in string buffer
             0095** ;
0B3DA9 7E    0096** SKIPNOTSP:		LD	A, (HL)
0B3DAA FE    0097** CP	' '
0B3DAB 20 
0B3DAC C8    0098** RET	Z
0B3DAD 23    0099** INC	HL
0B3DAE 18    0100** JR	SKIPNOTSP
0B3DAF F9 
             0101** 
             0102** ; Convert a character to upper case
             0103** ;  A: Character to convert
             0104** ;
0B3DB0 E6    0105** UPPERC:  		AND     7FH
0B3DB1 7F 
0B3DB2 FE    0106** CP      '`'
0B3DB3 60 
0B3DB4 D8    0107** RET     C
0B3DB5 E6    0108** AND     5FH			; Convert to upper case
0B3DB6 5F 
0B3DB7 C9    0109** RET
             0110** 
             0111** ; Switch on A - lookup table immediately after call
             0112** ;  A: Index into lookup table
             0113** ;
0B3DB8 E3    0114** SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
0B3DB9 87    0115** ADD	A, A			; Multiply A by two
             0116** ADD8U_HL 			; Add to HL (macro)
0B3DBA 85   0001**M ADD	A, L
0B3DBB 6F   0002**M LD	L, A
0B3DBC 8C   0003**M ADC	A, H
0B3DBD 95   0004**M SUB	L
0B3DBE 67   0005**M LD	H, A
0B3DBF 7E    0117** LD	A, (HL)			; follow the call. Fetch an address from the
0B3DC0 23    0118** INC	HL 			; table.
0B3DC1 66    0119** LD	H, (HL)
0B3DC2 6F    0120** LD	L, A
0B3DC3 E3    0121** EX	(SP), HL		; Swap this new address back, restores HL
0B3DC4 C9    0122** RET				; Return program control to this new address
             0123** 
             0124** ; Convert the buffer to a null terminated string and back
             0125** ; HL: Buffer address
             0126** ;
0B3DC5 C5    0127** NULLTOCR:		PUSH 	BC
0B3DC6 06    0128** LD	B, 0
0B3DC7 00 
0B3DC8 0E    0129** LD	C, CR
0B3DC9 0D 
0B3DCA 18    0130** JR	CRTONULL0
0B3DCB 05 
             0131** ;
0B3DCC C5    0132** CRTONULL:		PUSH	BC
0B3DCD 06    0133** LD	B, CR
0B3DCE 0D 
0B3DCF 0E    0134** LD	C, 0
0B3DD0 00 
             0135** ;
0B3DD1 E5    0136** CRTONULL0:		PUSH	HL
0B3DD2 7E    0137** CRTONULL1:		LD	A, (HL)
0B3DD3 B8    0138** CP 	B
0B3DD4 28    0139** JR	Z, CRTONULL2
0B3DD5 03 
0B3DD6 23    0140** INC	HL
0B3DD7 18    0141** JR	CRTONULL1
0B3DD8 F9 
0B3DD9 71    0142** CRTONULL2:		LD	(HL), C
0B3DDA E1    0143** POP 	HL
0B3DDB C1    0144** POP	BC
0B3DDC C9    0145** RET
             0146** 
             0147** ; Copy a filename to DE and zero terminate it
             0148** ; HL: Source
             0149** ; DE: Destination (ACCS)
             0150** ;
0B3DDD 7E    0151** CSTR_FNAME:		LD	A, (HL)			; Get source
0B3DDE FE    0152** CP	32			; Is it space
0B3DDF 20 
0B3DE0 28    0153** JR	Z, @F
0B3DE1 09 
0B3DE2 FE    0154** CP	CR			; Or is it CR
0B3DE3 0D 
0B3DE4 28    0155** JR	Z, @F
0B3DE5 05 
0B3DE6 12    0156** LD	(DE), A			; No, so store
0B3DE7 23    0157** INC	HL			; Increment
0B3DE8 13    0158** INC	DE
0B3DE9 18    0159** JR	CSTR_FNAME		; And loop
0B3DEA F2 
0B3DEB AF    0160** @@:			XOR	A			; Zero terminate the target string
0B3DEC 12    0161** LD	(DE), A
0B3DED 13    0162** INC	DE			; And point to next free address
0B3DEE C9    0163** RET
             0164** 
             0165** ; Copy a CR terminated line to DE and zero terminate it
             0166** ; HL: Source
             0167** ; DE: Destination (ACCS)
             0168** ;
0B3DEF 7E    0169** CSTR_LINE:		LD	A, (HL)			; Get source
0B3DF0 FE    0170** CP	CR			; Is it CR
0B3DF1 0D 
0B3DF2 28    0171** JR	Z, @F
0B3DF3 05 
0B3DF4 12    0172** LD	(DE), A			; No, so store
0B3DF5 23    0173** INC	HL			; Increment
0B3DF6 13    0174** INC	DE
0B3DF7 18    0175** JR	CSTR_LINE		; And loop
0B3DF8 F6 
0B3DF9 AF    0176** @@:			XOR	A			; Zero terminate the target string
0B3DFA 12    0177** LD	(DE), A
0B3DFB 13    0178** INC	DE			; And point to next free address
0B3DFC C9    0179** RET
             0180** 
             0181** ; Find the first occurrence of a character (case sensitive)
             0182** ; HL: Source
             0183** ;  C: Character to find
             0184** ; Returns:
             0185** ; HL: Pointer to character, or end of string marker
             0186** ;
0B3DFD 7E    0187** CSTR_FINDCH:		LD	A, (HL)			; Get source
0B3DFE B9    0188** CP	C			; Is it our character?
0B3DFF C8    0189** RET	Z			; Yes, so exit
0B3E00 B7    0190** OR	A			; Is it the end of string?
0B3E01 C8    0191** RET	Z			; Yes, so exit
0B3E02 23    0192** INC	HL
0B3E03 18    0193** JR	CSTR_FINDCH
0B3E04 F8 
             0194** 
             0195** ; Check whether a string ends with another string (case insensitive)
             0196** ; HL: Source
             0197** ; DE: The substring we want to test with
             0198** ; Returns:
             0199** ;  F: Z if HL ends with DE, otherwise NZ
             0200** ;
0B3E05 7E    0201** CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
0B3E06 CD    0202** CALL	UPPERC			; Convert to upper case
0B3E07 B0 
0B3E08 3D 
0B3E09 0B 
0B3E0A 4F    0203** LD	C, A
0B3E0B 1A    0204** LD	A, (DE)			; Get the substring byte
0B3E0C B9    0205** CP	C
0B3E0D C0    0206** RET	NZ			; Return NZ if at any point the strings don't match
0B3E0E B1    0207** OR	C			; Check whether both bytes are zero
0B3E0F C8    0208** RET	Z			; If so, return, as we have reached the end of both strings
0B3E10 23    0209** INC	HL
0B3E11 13    0210** INC	DE
0B3E12 18    0211** JR	CSTR_ENDSWITH		; And loop
0B3E13 F1 
             0212** 
             0213** ; Concatenate a string onto the end of another string
             0214** ; HL: Source
             0215** ; DE: Second string
             0216** ;
0B3E14 7E    0217** CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
0B3E15 B7    0218** OR	A
0B3E16 28    0219** JR	Z, CSTR_CAT_1
0B3E17 03 
0B3E18 23    0220** INC	HL
0B3E19 18    0221** JR	CSTR_CAT
0B3E1A F9 
             0222** ;
0B3E1B 1A    0223** CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
0B3E1C 77    0224** LD	(HL), A
0B3E1D B7    0225** OR	A			; Check for end of string
0B3E1E C8    0226** RET	Z			; And return
0B3E1F 23    0227** INC	HL
0B3E20 13    0228** INC	DE
0B3E21 18    0229** JR	CSTR_CAT_1		; Loop until finished
0B3E22 F8 
              0009* include "basic/patch.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	15/11/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 11/07/2023:	Fixed *BYE for ADL mode
             0009** ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
             0010** 
             0011** ; .ASSUME	ADL = 1
             0012** 
             0013** ; INCLUDE	"equs.inc"
             0014** ; INCLUDE "macros.inc"
             0015** ; INCLUDE "mos_api.inc"	; In MOS/src
             0016** 
             0017** ; SEGMENT CODE
             0018** 
             0019** ; XDEF	OSWRCH
             0020** ; XDEF	OSLINE
             0021** ; XDEF	ESCSET
             0022** ; XDEF	PUTIME
             0023** ; XDEF	GETIME
             0024** ; XDEF	PUTCSR
             0025** ; XDEF 	GETCSR
             0026** ; XDEF	OSRDCH
             0027** ; XDEF	PROMPT
             0028** ; XDEF	OSKEY
             0029** ; XDEF	TRAP
             0030** ; XDEF	LTRAP
             0031** ; XDEF	OSINIT
             0032** ; XDEF	OSCLI
             0033** ; XDEF	OSBPUT
             0034** ; XDEF	OSBGET
             0035** ; XDEF	OSSTAT
             0036** ; XDEF	OSSHUT
             0037** ; XDEF	OSOPEN
             0038** ; XDEF	OSCALL
             0039** ; XDEF	GETPTR
             0040** ; XDEF	PUTPTR
             0041** ; XDEF	GETEXT
             0042** ; XDEF	GETIMS
             0043** ; XDEF	RESET
             0044** ; XDEF	OSLOAD
             0045** ; XDEF	OSSAVE
             0046** ; XDEF	EXPR_W2
             0047** ; XDEF	STAR_VERSION
             0048** 
             0049** ; XREF	_end			; In init.asm
             0050** 
             0051** ; XREF	ASC_TO_NUMBER
             0052** ; XREF	RAM_START
             0053** ; XREF	RAM_END
             0054** ; XREF	FLAGS
             0055** ; XREF	ESCAPE
             0056** ; XREF	USER
             0057** ; XREF	RAM_Top
             0058** ; XREF	EXTERR
             0059** ; XREF	COUNT0
             0060** ; XREF	EXPRI
             0061** ; XREF	COMMA
             0062** ; XREF	XEQ
             0063** ; XREF	NXT
             0064** ; XREF	NULLTOCR
             0065** ; XREF	CRLF
             0066** ; XREF	CSTR_FNAME
             0067** ; XREF	CSTR_LINE
             0068** ; XREF	CSTR_FINDCH
             0069** ; XREF	CSTR_ENDSWITH
             0070** ; XREF	CSTR_CAT
             0071** ; XREF	FINDL
             0072** ; XREF	OUT_
             0073** ; XREF	ERROR_
             0074** ; XREF	ONEDIT
             0075** ; XREF	TELL
             0076** ; XREF	OSWRCHPT
             0077** ; XREF	OSWRCHCH
             0078** ; XREF	OSWRCHFH
             0079** ; XREF	LISTON
             0080** ; XREF	LISTIT
             0081** ; XREF	PAGE_
             0082** ; XREF	ONEDIT1
             0083** ; XREF	CLEAN
             0084** ; XREF	NEWIT
             0085** ; XREF	BAD
             0086** ; XREF	VBLANK_INIT
             0087** ; XREF	VBLANK_STOP
             0088** ; XREF	KEYDOWN
             0089** ; XREF	KEYASCII
             0090** ; XREF	WIDTH
             0091** ; XREF	ASSEM
             0092** 
             0093** ; OSLINE: Invoke the line editor
             0094** ;
0B3E23 1E    0095** OSLINE:			LD 	E, 1			; Default is to clear the buffer
0B3E24 01 
             0096** 
             0097** ; Entry point to line editor that does not clear the buffer
             0098** ;
0B3E25 FD    0099** OSLINE1:		PUSH	IY
0B3E26 E5 
0B3E27 E5    0100** PUSH	HL			; Buffer address
0B3E28 01    0101** LD	BC, 256			; Buffer length
0B3E29 00 
0B3E2A 01 
0B3E2B 00 
             0102** MOSCALL	mos_editline		; Call the MOS line editor
0B3E2C 3E   0001**M LD	A, function
0B3E2D 09 
0B3E2E 49   0002**M RST.LIS	08h
0B3E2F CF 
0B3E30 E1    0103** POP	HL			; Pop the address
0B3E31 FD    0104** POP	IY
0B3E32 E1 
0B3E33 F5    0105** PUSH	AF			; Stack the return value (key pressed)
0B3E34 CD    0106** CALL	NULLTOCR		; Turn the 0 character to a CR
0B3E35 C5 
0B3E36 3D 
0B3E37 0B 
0B3E38 CD    0107** CALL	CRLF			; Display CRLF
0B3E39 0B 
0B3E3A 39 
0B3E3B 0B 
0B3E3C F1    0108** POP	AF
0B3E3D FE    0109** CP	1Bh 			; Check if ESC terminated the input
0B3E3E 1B 
0B3E3F CA    0110** JP	Z, LTRAP1 		; Yes, so do the ESC thing
0B3E40 3B 
0B3E41 3F 
0B3E42 0B 
0B3E43 3A    0111** LD	A, (FLAGS)		; Otherwise
0B3E44 42 
0B3E45 5E 
0B3E46 0B 
0B3E47 CB    0112** RES	7, A 			; Clear the escape flag
0B3E48 BF 
0B3E49 32    0113** LD	(FLAGS), A
0B3E4A 42 
0B3E4B 5E 
0B3E4C 0B 
0B3E4D CD    0114** CALL	WAIT_VBLANK 		; Wait a frame
0B3E4E 01 
0B3E4F 41 
0B3E50 0B 
0B3E51 AF    0115** XOR	A			; Return A = 0
0B3E52 32    0116** LD	(KEYDOWN), A
0B3E53 47 
0B3E54 5E 
0B3E55 0B 
0B3E56 32    0117** LD	(KEYASCII), A
0B3E57 48 
0B3E58 5E 
0B3E59 0B 
0B3E5A C9    0118** RET
             0119** 
             0120** ; PUTIME: set current time to DE:HL, in centiseconds.
             0121** ;
0B3E5B DD    0122** PUTIME:			PUSH 	IX
0B3E5C E5 
             0123** MOSCALL	mos_sysvars
0B3E5D 3E   0001**M LD	A, function
0B3E5E 08 
0B3E5F 49   0002**M RST.LIS	08h
0B3E60 CF 
0B3E61 DD    0124** LD	(IX + sysvar_time + 0), L
0B3E62 75 
0B3E63 00 
0B3E64 DD    0125** LD	(IX + sysvar_time + 1), H
0B3E65 74 
0B3E66 01 
0B3E67 DD    0126** LD	(IX + sysvar_time + 2), E
0B3E68 73 
0B3E69 02 
0B3E6A DD    0127** LD	(IX + sysvar_time + 3), D
0B3E6B 72 
0B3E6C 03 
0B3E6D DD    0128** POP	IX
0B3E6E E1 
0B3E6F C9    0129** RET
             0130** 
             0131** ; GETIME: return current time in DE:HL, in centiseconds
             0132** ;
0B3E70 DD    0133** GETIME:			PUSH 	IX
0B3E71 E5 
             0134** MOSCALL	mos_sysvars
0B3E72 3E   0001**M LD	A, function
0B3E73 08 
0B3E74 49   0002**M RST.LIS	08h
0B3E75 CF 
0B3E76 DD    0135** LD	L, (IX + sysvar_time + 0)
0B3E77 6E 
0B3E78 00 
0B3E79 DD    0136** LD	H, (IX + sysvar_time + 1)
0B3E7A 66 
0B3E7B 01 
0B3E7C DD    0137** LD	E, (IX + sysvar_time + 2)
0B3E7D 5E 
0B3E7E 02 
0B3E7F DD    0138** LD	D, (IX + sysvar_time + 3)
0B3E80 56 
0B3E81 03 
0B3E82 DD    0139** POP	IX
0B3E83 E1 
0B3E84 C9    0140** RET
             0141** 
             0142** ; PUTCSR: move to cursor to x=DE, y=HL
             0143** ;
0B3E85 3E    0144** PUTCSR:			LD	A, 1Fh			; TAB
0B3E86 1F 
0B3E87 5B    0145** RST.LIL	10h
0B3E88 D7 
0B3E89 7B    0146** LD	A, E			; X
0B3E8A 5B    0147** RST.LIL 10h
0B3E8B D7 
0B3E8C 7D    0148** LD	A, L			; Y
0B3E8D 5B    0149** RST.LIL 10h
0B3E8E D7 
0B3E8F C9    0150** RET
             0151** 
             0152** ; GETCSR: return cursor position in x=DE, y=HL
             0153** ;
0B3E90 DD    0154** GETCSR:			PUSH	IX			; Get the system vars in IX
0B3E91 E5 
             0155** MOSCALL	mos_sysvars		; Reset the semaphore
0B3E92 3E   0001**M LD	A, function
0B3E93 08 
0B3E94 49   0002**M RST.LIS	08h
0B3E95 CF 
0B3E96 DD    0156** RES	0, (IX+sysvar_vpd_pflags)
0B3E97 CB 
0B3E98 04 
0B3E99 86 
             0157** VDU	23
0B3E9A 3E   0001**M LD	A, val
0B3E9B 17 
0B3E9C CD   0002**M CALL	OSWRCH
0B3E9D C4 
0B3E9E 3E 
0B3E9F 0B 
             0158** VDU	0
0B3EA0 3E   0001**M LD	A, val
0B3EA1 00 
0B3EA2 CD   0002**M CALL	OSWRCH
0B3EA3 C4 
0B3EA4 3E 
0B3EA5 0B 
             0159** VDU	vdp_cursor
0B3EA6 3E   0001**M LD	A, val
0B3EA7 82 
0B3EA8 CD   0002**M CALL	OSWRCH
0B3EA9 C4 
0B3EAA 3E 
0B3EAB 0B 
0B3EAC DD    0160** @@:			BIT	0, (IX+sysvar_vpd_pflags)
0B3EAD CB 
0B3EAE 04 
0B3EAF 46 
0B3EB0 28    0161** JR	Z, @B			; Wait for the result
0B3EB1 FA 
0B3EB2 16    0162** LD 	D, 0
0B3EB3 00 
0B3EB4 62    0163** LD	H, D
0B3EB5 DD    0164** LD	E, (IX + sysvar_cursorX)
0B3EB6 5E 
0B3EB7 07 
0B3EB8 DD    0165** LD	L, (IX + sysvar_cursorY)
0B3EB9 6E 
0B3EBA 08 
0B3EBB DD    0166** POP	IX
0B3EBC E1 
0B3EBD C9    0167** RET
             0168** 
             0169** ; PROMPT: output the input prompt
             0170** ;
0B3EBE 3E    0171** PROMPT: 		LD	A,'>'
0B3EBF 3E 
0B3EC0 C3    0172** JP	OSWRCH
0B3EC1 C4 
0B3EC2 3E 
0B3EC3 0B 
             0173** 
             0174** ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
             0175** ; A: Character to write
             0176** ;
0B3EC4 E5    0177** OSWRCH:			PUSH	HL
0B3EC5 21    0178** LD	HL, LISTON		; Fetch the LISTON variable
0B3EC6 40 
0B3EC7 5E 
0B3EC8 0B 
0B3EC9 CB    0179** BIT	3, (HL)			; Check whether we are in *EDIT mode
0B3ECA 5E 
0B3ECB 20    0180** JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0B3ECC 0B 
             0181** ;
0B3ECD 2A    0182** LD	HL, (OSWRCHCH)		; L: Channel #
0B3ECE 45 
0B3ECF 5E 
0B3ED0 0B 
0B3ED1 2D    0183** DEC	L			; If it is 1
0B3ED2 28    0184** JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0B3ED3 10 
             0185** ;
0B3ED4 E1    0186** POP	HL			; Otherwise
0B3ED5 5B    0187** RST.LIL	10h			; Output the character to MOS
0B3ED6 D7 
0B3ED7 C9    0188** RET
             0189** ;
0B3ED8 2A    0190** OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0B3ED9 43 
0B3EDA 5E 
0B3EDB 0B 
0B3EDC 77    0191** LD	(HL), A			; Echo the character into the buffer
0B3EDD 23    0192** INC	HL			; Increment pointer
0B3EDE 22    0193** LD	(OSWRCHPT), HL		; Write pointer back
0B3EDF 43 
0B3EE0 5E 
0B3EE1 0B 
0B3EE2 E1    0194** POP	HL
0B3EE3 C9    0195** RET
             0196** ;
0B3EE4 D5    0197** OSWRCH_FILE:		PUSH	DE
0B3EE5 5C    0198** LD	E, H			; Filehandle to E
0B3EE6 CD    0199** CALL	OSBPUT			; Write the byte out
0B3EE7 FF 
0B3EE8 42 
0B3EE9 0B 
0B3EEA D1    0200** POP	DE
0B3EEB E1    0201** POP	HL
0B3EEC C9    0202** RET
             0203** 
             0204** ; OSRDCH: Read a character in from the ESP32 keyboard handler
             0205** ; This is only called in GETS (eval.asm)
             0206** ;
             0207** OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0B3EED 3E   0001**M LD	A, function
0B3EEE 00 
0B3EEF 49   0002**M RST.LIS	08h
0B3EF0 CF 
0B3EF1 FE    0208** CP	1Bh
0B3EF2 1B 
0B3EF3 28    0209** JR	Z, LTRAP1
0B3EF4 46 
0B3EF5 C9    0210** RET
             0211** 
             0212** 
             0213** ;OSKEY - Read key with time-limit, test for ESCape.
             0214** ;Main function is carried out in user patch.
             0215** ;   Inputs: HL = time limit (centiseconds)
             0216** ;  Outputs: Carry reset if time-out
             0217** ;           If carry set A = character
             0218** ; Destroys: A,H,L,F
             0219** ;
0B3EF6 CD    0220** OSKEY:			CALL	READKEY			; Read the keyboard
0B3EF7 27 
0B3EF8 3F 
0B3EF9 0B 
0B3EFA 28    0221** JR	Z, @F 			; Skip if we have a key
0B3EFB 0A 
0B3EFC 7C    0222** LD	A, H 			; Check loop counter
0B3EFD B5    0223** OR 	L
0B3EFE C8    0224** RET 	Z 			; Return, we've not got a key at this point
0B3EFF CD    0225** CALL	WAIT_VBLANK 		; Wait a frame
0B3F00 01 
0B3F01 41 
0B3F02 0B 
0B3F03 2B    0226** DEC 	HL			; Decrement
0B3F04 18    0227** JR	OSKEY 			; And loop
0B3F05 F0 
             0228** ;
0B3F06 21    0229** @@:			LD	HL, KEYDOWN		; We have a key, so
0B3F07 47 
0B3F08 5E 
0B3F09 0B 
0B3F0A 36    0230** LD	(HL), 0			; clear the keydown flag
0B3F0B 00 
0B3F0C FE    0231** CP	1BH			; If we are not pressing ESC,
0B3F0D 1B 
0B3F0E 37    0232** SCF 				; then flag we've got a character
0B3F0F C0    0233** RET	NZ
             0234** ;
             0235** ; ESCSET
             0236** ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
             0237** ;
0B3F10 E5    0238** ESCSET: 		PUSH    HL
0B3F11 21    0239** LD      HL,FLAGS		; Pointer to FLAGS
0B3F12 42 
0B3F13 5E 
0B3F14 0B 
0B3F15 CB    0240** BIT     6,(HL)			; If bit 6 is set, then
0B3F16 76 
0B3F17 20    0241** JR      NZ,ESCDIS		; escape is disabled, so skip
0B3F18 02 
0B3F19 CB    0242** SET     7,(HL)			; Set bit 7, the escape flag
0B3F1A FE 
0B3F1B E1    0243** ESCDIS: 		POP     HL
0B3F1C C9    0244** RET
             0245** ;
             0246** ; ESCTEST
             0247** ; Test for ESC key
             0248** ;
0B3F1D CD    0249** ESCTEST:		CALL	READKEY			; Read the keyboard
0B3F1E 27 
0B3F1F 3F 
0B3F20 0B 
0B3F21 C0    0250** RET	NZ			; Skip if no key is pressed
0B3F22 FE    0251** CP	1BH			; If ESC pressed then
0B3F23 1B 
0B3F24 28    0252** JR	Z,ESCSET		; jump to the escape set routine
0B3F25 EA 
0B3F26 C9    0253** RET
             0254** 
             0255** ; Read the keyboard
             0256** ; Returns:
             0257** ; - A: ASCII of the pressed key
             0258** ; - F: Z if the key is pressed, otherwise NZ
             0259** ;
0B3F27 3A    0260** READKEY:		LD	A, (KEYDOWN)		; Get key down
0B3F28 47 
0B3F29 5E 
0B3F2A 0B 
0B3F2B 3D    0261** DEC	A 			; Set Z flag if keydown is 1
0B3F2C 3A    0262** LD	A, (KEYASCII)		; Get key ASCII value
0B3F2D 48 
0B3F2E 5E 
0B3F2F 0B 
0B3F30 C9    0263** RET
             0264** ;
             0265** ; TRAP
             0266** ; This is called whenever BASIC needs to check for ESC
             0267** ;
0B3F31 CD    0268** TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
0B3F32 1D 
0B3F33 3F 
0B3F34 0B 
             0269** ;
0B3F35 3A    0270** LTRAP:			LD	A,(FLAGS)		; Get FLAGS
0B3F36 42 
0B3F37 5E 
0B3F38 0B 
0B3F39 B7    0271** OR	A			; This checks for bit 7; if it is not set then the result will
0B3F3A F0    0272** RET	P			; be positive (bit 7 is the sign bit in Z80), so return
0B3F3B 21    0273** LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
0B3F3C 42 
0B3F3D 5E 
0B3F3E 0B 
0B3F3F CB    0274** RES	7,(HL)			; Clear the escape pressed flag and
0B3F40 BE 
0B3F41 C3    0275** JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
0B3F42 5F 
0B3F43 0C 
0B3F44 0B 
             0276** 
             0277** ;OSINIT - Initialise RAM mapping etc.
             0278** ;If BASIC is entered by BBCBASIC FILENAME then file
             0279** ;FILENAME.BBC is automatically CHAINed.
             0280** ;   Outputs: DE = initial value of HIMEM (top of RAM)
             0281** ;            HL = initial value of PAGE (user program)
             0282** ;            Z-flag reset indicates AUTO-RUN.
             0283** ;  Destroys: A,D,E,H,L,F
             0284** ;
0B3F45 CD    0285** OSINIT:			CALL	VBLANK_INIT
0B3F46 A4 
0B3F47 48 
0B3F48 0B 
0B3F49 AF    0286** XOR	A
0B3F4A 21    0287** LD 	HL, USER
0B3F4B 00 
0B3F4C 5F 
0B3F4D 0B 
0B3F4E 11    0288** LD	DE, RAM_Top
0B3F4F 00 
0B3F50 00 
0B3F51 0B 
0B3F52 5F    0289** LD	E, A			; Page boundary
0B3F53 C9    0290** RET
             0291** 
             0292** ;
             0293** ;OSCLI - Process a MOS command
             0294** ;
0B3F54 CD    0295** OSCLI: 			CALL    SKIPSP
0B3F55 C8 
0B3F56 3F 
0B3F57 0B 
0B3F58 FE    0296** CP      CR
0B3F59 0D 
0B3F5A C8    0297** RET     Z
0B3F5B FE    0298** CP      '|'
0B3F5C 7C 
0B3F5D C8    0299** RET     Z
0B3F5E EB    0300** EX      DE,HL
0B3F5F 21    0301** LD      HL,COMDS
0B3F60 D7 
0B3F61 3F 
0B3F62 0B 
0B3F63 1A    0302** OSCLI0:			LD      A,(DE)
0B3F64 CD    0303** CALL    UPPRC
0B3F65 CF 
0B3F66 3F 
0B3F67 0B 
0B3F68 BE    0304** CP      (HL)
0B3F69 28    0305** JR      Z,OSCLI2
0B3F6A 0B 
0B3F6B 38    0306** JR      C,OSCLI6
0B3F6C 30 
0B3F6D CB    0307** OSCLI1:			BIT     7,(HL)
0B3F6E 7E 
0B3F6F 23    0308** INC     HL
0B3F70 28    0309** JR      Z,OSCLI1
0B3F71 FB 
0B3F72 23    0310** INC     HL
0B3F73 23    0311** INC     HL
0B3F74 18    0312** JR      OSCLI0
0B3F75 ED 
             0313** ;
0B3F76 D5    0314** OSCLI2:			PUSH    DE
0B3F77 13    0315** OSCLI3:			INC     DE
0B3F78 23    0316** INC     HL
0B3F79 1A    0317** LD      A,(DE)
0B3F7A CD    0318** CALL    UPPRC
0B3F7B CF 
0B3F7C 3F 
0B3F7D 0B 
0B3F7E FE    0319** CP      '.'			; ABBREVIATED?
0B3F7F 2E 
0B3F80 28    0320** JR      Z,OSCLI4
0B3F81 0A 
0B3F82 AE    0321** XOR     (HL)
0B3F83 28    0322** JR      Z,OSCLI3
0B3F84 F2 
0B3F85 FE    0323** CP      80H
0B3F86 80 
0B3F87 28    0324** JR      Z,OSCLI4
0B3F88 03 
0B3F89 D1    0325** POP     DE
0B3F8A 18    0326** JR      OSCLI1
0B3F8B E1 
             0327** ;
0B3F8C F1    0328** OSCLI4:			POP     AF
0B3F8D 13    0329** INC     DE
0B3F8E CB    0330** OSCLI5:			BIT     7,(HL)
0B3F8F 7E 
0B3F90 23    0331** INC     HL
0B3F91 28    0332** JR      Z,OSCLI5
0B3F92 FB 
0B3F93 7E    0333** LD      A,(HL)
0B3F94 23    0334** INC     HL
0B3F95 66    0335** LD      H,(HL)
0B3F96 6F    0336** LD      L,A
0B3F97 E5    0337** PUSH    HL
0B3F98 EB    0338** EX      DE,HL
0B3F99 C3    0339** JP      SKIPSP
0B3F9A C8 
0B3F9B 3F 
0B3F9C 0B 
             0340** ;
0B3F9D EB    0341** OSCLI6:			EX	DE, HL			; HL: Buffer for command
0B3F9E 11    0342** LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0B3F9F 00 
0B3FA0 5B 
0B3FA1 0B 
0B3FA2 D5    0343** PUSH	DE			; Store buffer address
0B3FA3 CD    0344** CALL	CSTR_LINE		; Fetch the line
0B3FA4 EF 
0B3FA5 3D 
0B3FA6 0B 
0B3FA7 E1    0345** POP	HL			; HL: Pointer to command string in ACCS
0B3FA8 FD    0346** PUSH	IY
0B3FA9 E5 
             0347** MOSCALL	mos_oscli		; Returns OSCLI error in A
0B3FAA 3E   0001**M LD	A, function
0B3FAB 10 
0B3FAC 49   0002**M RST.LIS	08h
0B3FAD CF 
0B3FAE FD    0348** POP	IY
0B3FAF E1 
0B3FB0 B7    0349** OR	A			; 0 means MOS returned OK
0B3FB1 C8    0350** RET	Z			; So don't do anything
0B3FB2 C3    0351** JP 	OSERROR			; Otherwise it's a MOS error
0B3FB3 DB 
0B3FB4 41 
0B3FB5 0B 
             0352** 
0B3FB6 3E    0353** HUH:    		LD      A,254			; Bad command error
0B3FB7 FE 
0B3FB8 CD    0354** CALL    EXTERR
0B3FB9 3B 
0B3FBA 37 
0B3FBB 0B 
0B3FBC 42    0355** DB    	"Bad command"
0B3FBD 61 
0B3FBE 64 
0B3FBF 20 
0B3FBF 63   
0B3FC0 6F 
0B3FC1 6D 
0B3FC2 6D 
0B3FC2 61   
0B3FC3 6E 
0B3FC4 64 
0B3FC7 00    0356** DEFB    0
             0357** 
0B3FC8 7E    0358** SKIPSP:			LD      A,(HL)
0B3FC9 FE    0359** CP      ' '
0B3FCA 20 
0B3FCB C0    0360** RET     NZ
0B3FCC 23    0361** INC     HL
0B3FCD 18    0362** JR      SKIPSP
0B3FCE F9 
             0363** 
0B3FCF E6    0364** UPPRC:  		AND     7FH
0B3FD0 7F 
0B3FD1 FE    0365** CP      '`'
0B3FD2 60 
0B3FD3 D8    0366** RET     C
0B3FD4 E6    0367** AND     5FH			; CONVERT TO UPPER CASE
0B3FD5 5F 
0B3FD6 C9    0368** RET
             0369** 
             0370** ; Each command has bit 7 of the last character set, and is followed by the address of the handler
             0371** ; These must be in alphabetical order
             0372** ;
             0373** ; BEGIN NOT FOUND IN BINARY
             0374** ; COMDS:  		DB	"AS","M"+80h		; ASM
             0375** ; 			DW	STAR_ASM
             0376** ; 			DB	"BY","E"+80h		; BYE
             0377** ; 			DW	STAR_BYE
             0378** ; 			DB	"EDI","T"+80h		; EDIT
             0379** ; 			DW	STAR_EDIT
             0380** ; 			DB	"F","X"+80h		; FX
             0381** ; 			DW	STAR_FX
             0382** ; 			DB	"VERSIO","N"+80h	; VERSION
             0383** ; 			DW	STAR_VERSION
             0384** ; 			DB	FFh
             0385** ; END NOT FOUND IN BINARY
             0386** ; BEGIN INSERTED FROM BINARY
             0387** ; Each command has bit 7 of the last character set, and is followed by the address of the handler
             0388** ; These must be in alphabetical order
             0389** ;
             0390** COMDS:
0B3FD7 42    0391** db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
0B3FD8 59    0392** db 0x59 ; 044014
0B3FD9 C5    0393** db 0xc5 ; 044015
0B3FDA 2C    0394** db 0x2c ; 044016 31     11405 DW	STAR_ASM
0B3FDB 40    0395** db 0x40 ; 044017
0B3FDC 45    0396** db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
0B3FDD 44    0397** db 0x44 ; 044019
0B3FDE 49    0398** db 0x49 ; 04401A
0B3FDF D4    0399** db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
0B3FE0 61    0400** db 0x61 ; 04401C
0B3FE1 40    0401** db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
0B3FE2 46    0402** db 0x46 ; 04401E
0B3FE3 D8    0403** db 0xd8 ; 04401F
0B3FE4 A1    0404** db 0xa1 ; 044020
0B3FE5 40    0405** db 0x40 ; 044021 72     11409 DW	STAR_EDIT
0B3FE6 56    0406** db 0x56 ; 044022
0B3FE7 45    0407** db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
0B3FE8 52    0408** db 0x52 ; 044024
0B3FE9 53    0409** db 0x53 ; 044025 B2     11411 DW	STAR_FX
0B3FEA 49    0410** db 0x49 ; 044026
0B3FEB 4F    0411** db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
0B3FEC CE    0412** db 0xce ; 044028
0B3FED 38    0413** db 0x38 ; 044029
0B3FEE 40    0414** db 0x40 ; 04402A
0B3FEF FF    0415** db 0xff ; 04402B
             0416** ; END INSERTED FROM BINARY
             0417** 
             0418** ; BEGIN NOT FOUND IN BINARY
             0419** ; ; *ASM string
             0420** ; ;
             0421** ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
             0422** ; 			PUSH	HL			; HL = IY
             0423** ; 			POP	IY
             0424** ; 			CALL	ASSEM			; Invoke the assembler
             0425** ; 			POP	IY
             0426** ; 			RET
             0427** ; END NOT FOUND IN BINARY
             0428** 
             0429** ; *BYE
             0430** ;
0B3FF0 CD    0431** STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
0B3FF1 B8 
0B3FF2 48 
0B3FF3 0B 
0B3FF4 21    0432** LD	HL, 0			; The return value
0B3FF5 00 
0B3FF6 00 
0B3FF7 00 
0B3FF8 C3    0433** JP	_end 			; Jump back to the end routine in init.asm
0B3FF9 59 
0B3FFA 57 
0B3FFB 0B 
             0434** 
             0435** ; *VERSION
             0436** ;
0B3FFC CD    0437** STAR_VERSION:		CALL    TELL			; Output the welcome message
0B3FFD 54 
0B3FFE 3D 
0B3FFF 0B 
0B4000 42    0438** DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
0B4001 42 
0B4002 43 
0B4003 20 
0B4003 42   
0B4004 41 
0B4005 53 
0B4006 49 
0B4006 43   
0B4007 20 
0B4008 28 
0B4009 41 
0B4009 67   
0B400A 6F 
0B400B 6E 
0B400C 20 
0B400C 41   
0B400D 44 
0B400E 4C 
0B400F 29 
0B400F 20   
0B4010 56 
0B4011 65 
0B4012 72 
0B4012 73   
0B4013 69 
0B4014 6F 
0B4015 6E 
0B4015 20   
0B4016 31 
0B4017 2E 
0B4018 30 
0B4018 33   
0B4019 0A 
0B401A 0D 
0B401B 00 
0B4024 C9    0439** RET
             0440** 
             0441** ; *EDIT linenum
             0442** ;
0B4025 CD    0443** STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0B4026 5B 
0B4027 3D 
0B4028 0B 
0B4029 EB    0444** EX	DE, HL			; HL: Line number
0B402A CD    0445** CALL	FINDL			; HL: Address in RAM of tokenised line
0B402B 53 
0B402C 39 
0B402D 0B 
0B402E 3E    0446** LD	A, 41			; F:NZ If the line is not found
0B402F 29 
0B4030 C2    0447** JP	NZ, ERROR_		; Do error 41: No such line in that case
0B4031 24 
0B4032 37 
0B4033 0B 
             0448** ;
             0449** ; Use LISTIT to output the line to the ACCS buffer
             0450** ;
0B4034 23    0451** INC	HL			; Skip the length byte
0B4035 5E    0452** LD	E, (HL)			; Fetch the line number
0B4036 23    0453** INC	HL
0B4037 56    0454** LD	D, (HL)
0B4038 23    0455** INC	HL
0B4039 DD    0456** LD	IX, ACCS		; Pointer to where the copy is to be stored
0B403A 21 
0B403B 00 
0B403C 5B 
0B403C 0B   
0B403E DD    0457** LD	(OSWRCHPT), IX
0B403F 22 
0B4040 43 
0B4041 5E 
0B4041 0B   
0B4043 DD    0458** LD	IX, LISTON		; Pointer to LISTON variable in RAM
0B4044 21 
0B4045 40 
0B4046 5E 
0B4046 0B   
0B4048 DD    0459** LD	A, (IX)			; Store that variable
0B4049 7E 
0B404A 00 
0B404B F5    0460** PUSH	AF
0B404C DD    0461** LD	(IX), 09h		; Set to echo to buffer
0B404D 36 
0B404E 00 
0B404F 09 
0B4050 CD    0462** CALL	LISTIT
0B4051 56 
0B4052 38 
0B4053 0B 
0B4054 F1    0463** POP	AF
0B4055 DD    0464** LD	(IX), A			; Restore the original LISTON variable
0B4056 77 
0B4057 00 
0B4058 21    0465** LD	HL, ACCS		; HL: ACCS
0B4059 00 
0B405A 5B 
0B405B 0B 
0B405C 5D    0466** LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0B405D CD    0467** CALL	OSLINE1			; Invoke the editor
0B405E 25 
0B405F 3E 
0B4060 0B 
0B4061 C3    0468** JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0B4062 94 
0B4063 30 
0B4064 0B 
             0469** 
             0470** ; OSCLI FX n
             0471** ;
0B4065 CD    0472** STAR_FX:		CALL	ASC_TO_NUMBER
0B4066 5B 
0B4067 3D 
0B4068 0B 
0B4069 4B    0473** LD	C, E			; C: Save FX #
0B406A CD    0474** CALL	ASC_TO_NUMBER
0B406B 5B 
0B406C 3D 
0B406D 0B 
0B406E 7A    0475** LD	A, D  			; Is first parameter > 255?
0B406F B7    0476** OR 	A
0B4070 28    0477** JR	Z, STAR_FX1		; Yes, so skip next bit
0B4071 03 
0B4072 EB    0478** EX	DE, HL 			; Parameter is 16-bit
0B4073 18    0479** JR	STAR_FX2
0B4074 07 
             0480** ;
0B4075 43    0481** STAR_FX1:		LD	B, E 			; B: Save First parameter
0B4076 CD    0482** CALL	ASC_TO_NUMBER		; Fetch second parameter
0B4077 5B 
0B4078 3D 
0B4079 0B 
0B407A 68    0483** LD	L, B 			; L: First parameter
0B407B 63    0484** LD	H, E 			; H: Second parameter
             0485** ;
0B407C 79    0486** STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
             0487** ;
             0488** ; OSBYTE
             0489** ;  A: FX #
             0490** ;  L: First parameter
             0491** ;  H: Second parameter
             0492** ;
0B407D FE    0493** OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0B407E 0B 
0B407F 28    0494** JR	Z, OSBYTE_0B
0B4080 18 
0B4081 FE    0495** CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0B4082 0C 
0B4083 28    0496** JR	Z, OSBYTE_0C
0B4084 43 
0B4085 FE    0497** CP	13H			; *FX 19: Wait for vblank
0B4086 13 
0B4087 28    0498** JR	Z, OSBYTE_13
0B4088 6E 
0B4089 FE    0499** CP	76H			; *FX 118, n: Set keyboard LED
0B408A 76 
0B408B CA    0500** JP	Z, OSBYTE_76
0B408C 12 
0B408D 41 
0B408E 0B 
0B408F FE    0501** CP	A0H
0B4090 A0 
0B4091 CA    0502** JP	Z, OSBYTE_A0
0B4092 42 
0B4093 41 
0B4094 0B 
0B4095 C3    0503** JP	HUH			; Anything else trips an error
0B4096 B6 
0B4097 3F 
0B4098 0B 
             0504** 
             0505** ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
             0506** ; Parameters:
             0507** ; - HL: Repeat delay
             0508** ;
             0509** OSBYTE_0B:		VDU	23
0B4099 3E   0001**M LD	A, val
0B409A 17 
0B409B CD   0002**M CALL	OSWRCH
0B409C C4 
0B409D 3E 
0B409E 0B 
             0510** VDU	0
0B409F 3E   0001**M LD	A, val
0B40A0 00 
0B40A1 CD   0002**M CALL	OSWRCH
0B40A2 C4 
0B40A3 3E 
0B40A4 0B 
             0511** VDU	vdp_keystate
0B40A5 3E   0001**M LD	A, val
0B40A6 88 
0B40A7 CD   0002**M CALL	OSWRCH
0B40A8 C4 
0B40A9 3E 
0B40AA 0B 
             0512** VDU	L
0B40AB 7D   0001**M LD	A, val
0B40AC CD   0002**M CALL	OSWRCH
0B40AD C4 
0B40AE 3E 
0B40AF 0B 
             0513** VDU	H
0B40B0 7C   0001**M LD	A, val
0B40B1 CD   0002**M CALL	OSWRCH
0B40B2 C4 
0B40B3 3E 
0B40B4 0B 
             0514** VDU	0
0B40B5 3E   0001**M LD	A, val
0B40B6 00 
0B40B7 CD   0002**M CALL	OSWRCH
0B40B8 C4 
0B40B9 3E 
0B40BA 0B 
             0515** VDU 	0
0B40BB 3E   0001**M LD	A, val
0B40BC 00 
0B40BD CD   0002**M CALL	OSWRCH
0B40BE C4 
0B40BF 3E 
0B40C0 0B 
             0516** VDU	255
0B40C1 3E   0001**M LD	A, val
0B40C2 FF 
0B40C3 CD   0002**M CALL	OSWRCH
0B40C4 C4 
0B40C5 3E 
0B40C6 0B 
0B40C7 C9    0517** RET
             0518** 
             0519** ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
             0520** ; Parameters:
             0521** ; - HL: Repeat rate
             0522** ;
             0523** OSBYTE_0C:		VDU	23
0B40C8 3E   0001**M LD	A, val
0B40C9 17 
0B40CA CD   0002**M CALL	OSWRCH
0B40CB C4 
0B40CC 3E 
0B40CD 0B 
             0524** VDU	0
0B40CE 3E   0001**M LD	A, val
0B40CF 00 
0B40D0 CD   0002**M CALL	OSWRCH
0B40D1 C4 
0B40D2 3E 
0B40D3 0B 
             0525** VDU	vdp_keystate
0B40D4 3E   0001**M LD	A, val
0B40D5 88 
0B40D6 CD   0002**M CALL	OSWRCH
0B40D7 C4 
0B40D8 3E 
0B40D9 0B 
             0526** VDU	0
0B40DA 3E   0001**M LD	A, val
0B40DB 00 
0B40DC CD   0002**M CALL	OSWRCH
0B40DD C4 
0B40DE 3E 
0B40DF 0B 
             0527** VDU 	0
0B40E0 3E   0001**M LD	A, val
0B40E1 00 
0B40E2 CD   0002**M CALL	OSWRCH
0B40E3 C4 
0B40E4 3E 
0B40E5 0B 
             0528** VDU	L
0B40E6 7D   0001**M LD	A, val
0B40E7 CD   0002**M CALL	OSWRCH
0B40E8 C4 
0B40E9 3E 
0B40EA 0B 
             0529** VDU	H
0B40EB 7C   0001**M LD	A, val
0B40EC CD   0002**M CALL	OSWRCH
0B40ED C4 
0B40EE 3E 
0B40EF 0B 
             0530** VDU	255
0B40F0 3E   0001**M LD	A, val
0B40F1 FF 
0B40F2 CD   0002**M CALL	OSWRCH
0B40F3 C4 
0B40F4 3E 
0B40F5 0B 
0B40F6 C9    0531** RET
             0532** 
             0533** ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
             0534** ;
0B40F7 CD    0535** OSBYTE_13:		CALL	WAIT_VBLANK
0B40F8 01 
0B40F9 41 
0B40FA 0B 
0B40FB 2E    0536** LD	L, 0			; Returns 0
0B40FC 00 
0B40FD C3    0537** JP	COUNT0
0B40FE 43 
0B40FF 05 
0B4100 0B 
             0538** ;
0B4101 DD    0539** WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0B4102 E5 
             0540** MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B4103 3E   0001**M LD	A, function
0B4104 08 
0B4105 49   0002**M RST.LIS	08h
0B4106 CF 
0B4107 DD    0541** LD	A, (IX + sysvar_time + 0)
0B4108 7E 
0B4109 00 
0B410A DD    0542** @@:			CP 	A, (IX + sysvar_time + 0)
0B410B BE 
0B410C 00 
0B410D 28    0543** JR	Z, @B
0B410E FB 
0B410F DD    0544** POP	IX
0B4110 E1 
0B4111 C9    0545** RET
             0546** 
             0547** ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
             0548** ; Parameters:
             0549** ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
             0550** ;
             0551** OSBYTE_76:		VDU	23
0B4112 3E   0001**M LD	A, val
0B4113 17 
0B4114 CD   0002**M CALL	OSWRCH
0B4115 C4 
0B4116 3E 
0B4117 0B 
             0552** VDU	0
0B4118 3E   0001**M LD	A, val
0B4119 00 
0B411A CD   0002**M CALL	OSWRCH
0B411B C4 
0B411C 3E 
0B411D 0B 
             0553** VDU	vdp_keystate
0B411E 3E   0001**M LD	A, val
0B411F 88 
0B4120 CD   0002**M CALL	OSWRCH
0B4121 C4 
0B4122 3E 
0B4123 0B 
             0554** VDU	0
0B4124 3E   0001**M LD	A, val
0B4125 00 
0B4126 CD   0002**M CALL	OSWRCH
0B4127 C4 
0B4128 3E 
0B4129 0B 
             0555** VDU 	0
0B412A 3E   0001**M LD	A, val
0B412B 00 
0B412C CD   0002**M CALL	OSWRCH
0B412D C4 
0B412E 3E 
0B412F 0B 
             0556** VDU	0
0B4130 3E   0001**M LD	A, val
0B4131 00 
0B4132 CD   0002**M CALL	OSWRCH
0B4133 C4 
0B4134 3E 
0B4135 0B 
             0557** VDU	0
0B4136 3E   0001**M LD	A, val
0B4137 00 
0B4138 CD   0002**M CALL	OSWRCH
0B4139 C4 
0B413A 3E 
0B413B 0B 
             0558** VDU	L
0B413C 7D   0001**M LD	A, val
0B413D CD   0002**M CALL	OSWRCH
0B413E C4 
0B413F 3E 
0B4140 0B 
0B4141 C9    0559** RET
             0560** 
             0561** ; OSBYTE 0xA0: Fetch system variable
             0562** ; Parameters:
             0563** ; - L: The system variable to fetch
             0564** ;
0B4142 DD    0565** OSBYTE_A0:		PUSH	IX
0B4143 E5 
             0566** MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B4144 3E   0001**M LD	A, function
0B4145 08 
0B4146 49   0002**M RST.LIS	08h
0B4147 CF 
0B4148 01    0567** LD	BC, 0
0B4149 00 
0B414A 00 
0B414B 00 
0B414C 4D    0568** LD	C, L			; BCU = L
0B414D DD    0569** ADD	IX, BC			; Add to IX
0B414E 09 
0B414F DD    0570** LD	L, (IX + 0)		; Fetch the return value
0B4150 6E 
0B4151 00 
0B4152 DD    0571** POP	IX
0B4153 E1 
0B4154 C3    0572** JP 	COUNT0
0B4155 43 
0B4156 05 
0B4157 0B 
             0573** 
             0574** ;OSLOAD - Load an area of memory from a file.
             0575** ;   Inputs: HL addresses filename (CR terminated)
             0576** ;           DE = address at which to load
             0577** ;           BC = maximum allowed size (bytes)
             0578** ;  Outputs: Carry reset indicates no room for file.
             0579** ; Destroys: A,B,C,D,E,H,L,F
             0580** ;
0B4158 C5    0581** OSLOAD:			PUSH	BC			; Stack the size
0B4159 D5    0582** PUSH	DE			; Stack the load address
0B415A 11    0583** LD	DE, ACCS		; Buffer address for filename
0B415B 00 
0B415C 5B 
0B415D 0B 
0B415E CD    0584** CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B415F DD 
0B4160 3D 
0B4161 0B 
0B4162 21    0585** LD	HL, ACCS		; HL: Filename
0B4163 00 
0B4164 5B 
0B4165 0B 
0B4166 CD    0586** CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B4167 58 
0B4168 42 
0B4169 0B 
0B416A CD    0587** CALL	EXT_HANDLER		; Get the default handler
0B416B 6C 
0B416C 42 
0B416D 0B 
0B416E D1    0588** POP	DE			; Restore the load address
0B416F C1    0589** POP	BC			; Restore the size
0B4170 B7    0590** OR	A
0B4171 28    0591** JR 	Z, OSLOAD_BBC
0B4172 60 
             0592** ;
             0593** ; Load the file in as a text file
             0594** ;
0B4173 AF    0595** OSLOAD_TXT:		XOR	A			; Set file attributes to read
0B4174 CD    0596** CALL	OSOPEN			; Open the file
0B4175 E0 
0B4176 42 
0B4177 0B 
0B4178 5F    0597** LD 	E, A 			; The filehandle
0B4179 B7    0598** OR	A
0B417A 3E    0599** LD	A, 4			; File not found error
0B417B 04 
0B417C 28    0600** JR	Z, OSERROR		; Jump to error handler
0B417D 5D 
0B417E CD    0601** CALL	NEWIT			; Call NEW to clear the program space
0B417F 30 
0B4180 38 
0B4181 0B 
             0602** ;
0B4182 21    0603** OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0B4183 00 
0B4184 5B 
0B4185 0B 
             0604** ;
             0605** ; First skip any whitespace (indents) at the beginning of the input
             0606** ;
0B4186 CD    0607** @@:			CALL	OSBGET			; Read the byte into A
0B4187 F7 
0B4188 42 
0B4189 0B 
0B418A 38    0608** JR	C, OSLOAD_TXT3		; Is it EOF?
0B418B 1E 
0B418C FE    0609** CP	LF 			; Is it LF?
0B418D 0A 
0B418E 28    0610** JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0B418F 1A 
0B4190 FE    0611** CP	21h			; Is it less than or equal to ASCII space?
0B4191 21 
0B4192 38    0612** JR	C, @B 			; Yes, so keep looping
0B4193 F2 
0B4194 77    0613** LD	(HL), A 		; Store the first character
0B4195 2C    0614** INC	L
             0615** ;
             0616** ; Now read the rest of the line in
             0617** ;
0B4196 CD    0618** OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0B4197 F7 
0B4198 42 
0B4199 0B 
0B419A 38    0619** JR	C, OSLOAD_TXT4		; Is it EOF?
0B419B 2B 
0B419C FE    0620** CP	20h			; Skip if not an ASCII character
0B419D 20 
0B419E 38    0621** JR	C, @F
0B419F 06 
0B41A0 77    0622** LD	(HL), A 		; Store in the input buffer
0B41A1 2C    0623** INC	L			; Increment the buffer pointer
0B41A2 CA    0624** JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0B41A3 BC 
0B41A4 36 
0B41A5 0B 
0B41A6 FE    0625** @@:			CP	LF			; Check for LF
0B41A7 0A 
0B41A8 20    0626** JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0B41A9 EC 
             0627** ;
             0628** ; Finally, handle EOL/EOF
             0629** ;
0B41AA 36    0630** OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0B41AB 0D 
0B41AC 7D    0631** LD	A, L			; Check for minimum line length
0B41AD FE    0632** CP	2			; If it is 2 characters or less (including CR)
0B41AE 02 
0B41AF 38    0633** JR	C, @F			; Then don't bother entering it
0B41B0 0A 
0B41B1 D5    0634** PUSH	DE			; Preserve the filehandle
0B41B2 CD    0635** CALL	ONEDIT1			; Enter the line in memory
0B41B3 A0 
0B41B4 30 
0B41B5 0B 
0B41B6 DC    0636** CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0B41B7 03 
0B41B8 38 
0B41B9 0B 
0B41BA D1    0637** POP	DE
0B41BB CD    0638** @@:			CALL	OSSTAT			; End of file?
0B41BC 08 
0B41BD 43 
0B41BE 0B 
0B41BF 20    0639** JR	NZ, OSLOAD_TXT1		; No, so loop
0B41C0 C1 
0B41C1 CD    0640** CALL	OSSHUT			; Close the file
0B41C2 EF 
0B41C3 42 
0B41C4 0B 
0B41C5 37    0641** SCF				; Flag to BASIC that we're good
0B41C6 C9    0642** RET
             0643** ;
             0644** ; Special case for BASIC programs with no blank line at the end
             0645** ;
0B41C7 FE    0646** OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0B41C8 20 
0B41C9 38    0647** JR	C, @F
0B41CA 06 
0B41CB 77    0648** LD	(HL), A			; Store the character
0B41CC 2C    0649** INC	L
0B41CD CA    0650** JP	Z, BAD
0B41CE BC 
0B41CF 36 
0B41D0 0B 
0B41D1 18    0651** @@:			JR	OSLOAD_TXT3
0B41D2 D7 
             0652** 
             0653** ;
             0654** ; Load the file in as a tokenised binary blob
             0655** ;
             0656** OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0B41D3 3E   0001**M LD	A, function
0B41D4 01 
0B41D5 49   0002**M RST.LIS	08h
0B41D6 CF 
0B41D7 D0    0657** RET	NC			; If load returns with carry reset - NO ROOM
0B41D8 B7    0658** OR	A			; If there is no error (A=0)
0B41D9 37    0659** SCF				; Need to set carry indicating there was room
0B41DA C8    0660** RET	Z			; Return
             0661** ;
0B41DB F5    0662** OSERROR:		PUSH	AF			; Handle the MOS error
0B41DC 21    0663** LD	HL, ACCS		; Address of the buffer
0B41DD 00 
0B41DE 5B 
0B41DF 0B 
0B41E0 01    0664** LD	BC, 256			; Length of the buffer
0B41E1 00 
0B41E2 01 
0B41E3 00 
0B41E4 5F    0665** LD	E, A			; The error code
             0666** MOSCALL	mos_getError		; Copy the error message into the buffer
0B41E5 3E   0001**M LD	A, function
0B41E6 0F 
0B41E7 49   0002**M RST.LIS	08h
0B41E8 CF 
0B41E9 F1    0667** POP	AF
0B41EA E5    0668** PUSH	HL			; Stack the address of the error (now in ACCS)
0B41EB C6    0669** ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0B41EC 7F 
0B41ED C3    0670** JP	EXTERR			; Trigger an external error
0B41EE 3B 
0B41EF 37 
0B41F0 0B 
             0671** 
             0672** ;OSSAVE - Save an area of memory to a file.
             0673** ;   Inputs: HL addresses filename (term CR)
             0674** ;           DE = start address of data to save
             0675** ;           BC = length of data to save (bytes)
             0676** ; Destroys: A,B,C,D,E,H,L,F
             0677** ;
0B41F1 C5    0678** OSSAVE:			PUSH	BC			; Stack the size
0B41F2 D5    0679** PUSH	DE			; Stack the save address
0B41F3 11    0680** LD	DE, ACCS		; Buffer address for filename
0B41F4 00 
0B41F5 5B 
0B41F6 0B 
0B41F7 CD    0681** CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B41F8 DD 
0B41F9 3D 
0B41FA 0B 
0B41FB 21    0682** LD	HL, ACCS		; HL: Filename
0B41FC 00 
0B41FD 5B 
0B41FE 0B 
0B41FF CD    0683** CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B4200 58 
0B4201 42 
0B4202 0B 
0B4203 CD    0684** CALL	EXT_HANDLER		; Get the default handler
0B4204 6C 
0B4205 42 
0B4206 0B 
0B4207 D1    0685** POP	DE			; Restore the save address
0B4208 C1    0686** POP	BC			; Restore the size
0B4209 B7    0687** OR	A			; Is the extension .BBC
0B420A 28    0688** JR	Z, OSSAVE_BBC		; Yes, so use that
0B420B 44 
             0689** ;
             0690** ; Save the file out as a text file
             0691** ;
0B420C 3A    0692** OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0B420D 45 
0B420E 5E 
0B420F 0B 
0B4210 F5    0693** PUSH	AF
0B4211 AF    0694** XOR	A
0B4212 3C    0695** INC	A			; Make sure C is clear, A is 1, for OPENOUT
0B4213 32    0696** LD	(OSWRCHCH), A
0B4214 45 
0B4215 5E 
0B4216 0B 
0B4217 CD    0697** CALL	OSOPEN			; Open the file
0B4218 E0 
0B4219 42 
0B421A 0B 
0B421B 32    0698** LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0B421C 46 
0B421D 5E 
0B421E 0B 
0B421F DD    0699** LD	IX, LISTON		; Required for LISTIT
0B4220 21 
0B4221 40 
0B4222 5E 
0B4222 0B   
0B4224 2A    0700** LD	HL, (PAGE_)		; Get start of program area
0B4225 14 
0B4226 5E 
0B4227 0B 
0B4228 D9    0701** EXX
0B4229 01    0702** LD	BC, 0			; Set the initial indent counters
0B422A 00 
0B422B 00 
0B422C 00 
0B422D D9    0703** EXX
0B422E 7E    0704** OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0B422F B7    0705** OR	A
0B4230 28    0706** JR	Z, OSSAVE_TXT2
0B4231 0F 
0B4232 23    0707** INC	HL			; Skip the length byte
0B4233 11    0708** LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0B4234 00 
0B4235 00 
0B4236 00 
0B4237 5E    0709** LD	E, (HL)			; Get the line number
0B4238 23    0710** INC	HL
0B4239 56    0711** LD	D, (HL)
0B423A 23    0712** INC	HL
0B423B CD    0713** CALL	LISTIT			; List the line
0B423C 56 
0B423D 38 
0B423E 0B 
0B423F 18    0714** JR	OSSAVE_TXT1
0B4240 ED 
0B4241 3A    0715** OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0B4242 46 
0B4243 5E 
0B4244 0B 
0B4245 5F    0716** LD	E, A
0B4246 CD    0717** CALL	OSSHUT			; Close it
0B4247 EF 
0B4248 42 
0B4249 0B 
0B424A F1    0718** POP	AF			; Restore the channel
0B424B 32    0719** LD	(OSWRCHCH), A
0B424C 45 
0B424D 5E 
0B424E 0B 
0B424F C9    0720** RET
             0721** ;
             0722** ; Save the file out as a tokenised binary blob
             0723** ;
             0724** OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0B4250 3E   0001**M LD	A, function
0B4251 02 
0B4252 49   0002**M RST.LIS	08h
0B4253 CF 
0B4254 B7    0725** OR	A			; If there is no error (A=0)
0B4255 C8    0726** RET	Z			; Just return
0B4256 18    0727** JR	OSERROR			; Trip an error
0B4257 83 
             0728** 
             0729** ; Check if an extension is specified in the filename
             0730** ; Add a default if not specified
             0731** ; HL: Filename (CSTR format)
             0732** ;
0B4258 E5    0733** EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0B4259 0E    0734** LD	C, '.'			; Search for dot (marks start of extension)
0B425A 2E 
0B425B CD    0735** CALL	CSTR_FINDCH
0B425C FD 
0B425D 3D 
0B425E 0B 
0B425F B7    0736** OR	A			; Check for end of string marker
0B4260 20    0737** JR	NZ, @F			; No, so skip as we have an extension at this point
0B4261 08 
0B4262 11    0738** LD	DE, EXT_LOOKUP		; Get the first (default extension)
0B4263 9C 
0B4264 42 
0B4265 0B 
0B4266 CD    0739** CALL	CSTR_CAT		; Concat it to string pointed to by HL
0B4267 14 
0B4268 3E 
0B4269 0B 
0B426A E1    0740** @@:			POP	HL			; Restore the filename pointer
0B426B C9    0741** RET
             0742** 
             0743** ; Check if an extension is valid and, if so, provide a pointer to a handler
             0744** ; HL: Filename (CSTR format)
             0745** ; Returns:
             0746** ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
             0747** ;
0B426C E5    0748** EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0B426D 0E    0749** LD	C, '.'			; Find the '.'
0B426E 2E 
0B426F CD    0750** CALL	CSTR_FINDCH
0B4270 FD 
0B4271 3D 
0B4272 0B 
0B4273 11    0751** LD	DE, EXT_LOOKUP		; The lookup table
0B4274 9C 
0B4275 42 
0B4276 0B 
             0752** ;
0B4277 E5    0753** EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0B4278 CD    0754** CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0B4279 05 
0B427A 3E 
0B427B 0B 
0B427C E1    0755** POP	HL			; Restore the pointer to the extension
0B427D 28    0756** JR	Z, EXT_HANDLER_2	; We have a match!
0B427E 19 
             0757** ;
0B427F 1A    0758** @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0B4280 13    0759** INC	DE
0B4281 B7    0760** OR	A
0B4282 20    0761** JR	NZ, @B
0B4283 FB 
0B4284 13    0762** INC	DE			; Skip the file extension # byte
             0763** ;
0B4285 1A    0764** LD	A, (DE)			; Are we at the end of the table?
0B4286 B7    0765** OR	A
0B4287 20    0766** JR	NZ, EXT_HANDLER_1	; No, so loop
0B4288 EE 
             0767** ;
0B4289 3E    0768** LD      A,204			; Throw a "Bad name" error
0B428A CC 
0B428B CD    0769** CALL    EXTERR
0B428C 3B 
0B428D 37 
0B428E 0B 
0B428F 42    0770** DB    	"Bad name", 0
0B4290 61 
0B4291 64 
0B4292 20 
0B4292 6E   
0B4293 61 
0B4294 6D 
0B4295 65 
0B4295 00   
             0771** ;
0B4298 13    0772** EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0B4299 1A    0773** LD	A, (DE)
0B429A E1    0774** POP	HL			; Restore the filename pointer
0B429B C9    0775** RET
             0776** ;
             0777** 
             0778** 
             0779** ; Extension lookup table
             0780** ; CSTR, TYPE
             0781** ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
             0782** ; 	- 1: Human readable plain text
             0783** ;
0B429C 2E    0784** EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
0B429D 42 
0B429E 42 
0B429F 43 
0B429F 00   
0B42A0 00 
0B42A2 2E    0785** DB	".TXT", 0, 1
0B42A3 54 
0B42A4 58 
0B42A5 54 
0B42A5 00   
0B42A6 01 
0B42A8 2E    0786** DB	".ASC", 0, 1
0B42A9 41 
0B42AA 53 
0B42AB 43 
0B42AB 00   
0B42AC 01 
0B42AE 2E    0787** DB	".BAS", 0, 1
0B42AF 42 
0B42B0 41 
0B42B1 53 
0B42B1 00   
0B42B2 01 
0B42B4 00    0788** DB	0			; End of table
             0789** 
             0790** ;OSCALL - Intercept page &FF calls and provide an alternative address
             0791** ;
             0792** ;&FFF7:	OSCLI	Execute *command.
             0793** ;&FFF4:	OSBYTE	Various byte-wide functions.
             0794** ;&FFF1:	OSWORD	Various control block functions.
             0795** ;&FFEE:	OSWRCH	Write character to output stream.
             0796** ;&FFE7:	OSNEWL	Write NewLine to output stream.
             0797** ;&FFE3:	OSASCI	Write character or NewLine to output stream.
             0798** ;&FFE0:	OSRDCH	Wait for character from input stream.
             0799** ;&FFDD:	OSFILE	Perform actions on whole files or directories.
             0800** ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
             0801** ;&FFD7:	OSBGET	Read a byte from an a channel.
             0802** ;&FFD4:	OSBPUT	Write a byte to a channel.
             0803** ;&FFD1:	OSGBPB	Read and write blocks of data.
             0804** ;&FFCE:	OSFIND	Open or close a file.
             0805** ;
0B42B5 21    0806** OSCALL:			LD	HL, OSCALL_TABLE
0B42B6 CB 
0B42B7 42 
0B42B8 0B 
0B42B9 7E    0807** OSCALL_1:		LD	A, (HL)
0B42BA 23    0808** INC	HL
0B42BB FE    0809** CP	FFh
0B42BC FF 
0B42BD C8    0810** RET	Z
0B42BE FD    0811** CP	A, IYL
0B42BF BD 
0B42C0 28    0812** JR	Z, OSCALL_2
0B42C1 06 
0B42C2 D0    0813** RET	NC
0B42C3 23    0814** INC	HL
0B42C4 23    0815** INC	HL
0B42C5 23    0816** INC	HL
0B42C6 18    0817** JR	OSCALL_1
0B42C7 F1 
0B42C8 ED    0818** OSCALL_2:		LD	IY,(HL)
0B42C9 31 
0B42CA C9    0819** RET
0B42CB D4    0820** OSCALL_TABLE:		DB 	D4h
0B42CC FF    0821** DW24 	OSBPUT
0B42CD 42 
0B42CE 0B 
0B42CF D7    0822** DB 	D7h
0B42D0 F7    0823** DW24 	OSBGET
0B42D1 42 
0B42D2 0B 
0B42D3 EE    0824** DB 	EEh
0B42D4 C4    0825** DW24 	OSWRCH
0B42D5 3E 
0B42D6 0B 
0B42D7 F4    0826** DB	F4h
0B42D8 7D    0827** DW24 	OSBYTE
0B42D9 40 
0B42DA 0B 
0B42DB F7    0828** DB	F7h
0B42DC 54    0829** DW24	OSCLI
0B42DD 3F 
0B42DE 0B 
0B42DF FF    0830** DB	FFh
             0831** 
             0832** ; OSOPEN
             0833** ; HL: Pointer to path
             0834** ;  F: C Z
             0835** ;     x x OPENIN
             0836** ; 	  OPENOUT
             0837** ;     x	  OPENUP
             0838** ; Returns:
             0839** ;  A: Filehandle, 0 if cannot open
             0840** ;
0B42E0 0E    0841** OSOPEN:			LD	C, fa_read
0B42E1 01 
0B42E2 28    0842** JR	Z, @F
0B42E3 06 
0B42E4 0E    0843** LD	C, fa_write | fa_open_append
0B42E5 32 
0B42E6 38    0844** JR	C, @F
0B42E7 02 
0B42E8 0E    0845** LD	C, fa_write | fa_create_always
0B42E9 0A 
             0846** @@:			MOSCALL	mos_fopen
0B42EA 3E   0001**M LD	A, function
0B42EB 0A 
0B42EC 49   0002**M RST.LIS	08h
0B42ED CF 
0B42EE C9    0847** RET
             0848** 
             0849** ;OSSHUT - Close disk file(s).
             0850** ; E = file channel
             0851** ;  If E=0 all files are closed (except SPOOL)
             0852** ; Destroys: A,B,C,D,E,H,L,F
             0853** ;
0B42EF C5    0854** OSSHUT:			PUSH	BC
0B42F0 4B    0855** LD	C, E
             0856** MOSCALL	mos_fclose
0B42F1 3E   0001**M LD	A, function
0B42F2 0B 
0B42F3 49   0002**M RST.LIS	08h
0B42F4 CF 
0B42F5 C1    0857** POP	BC
0B42F6 C9    0858** RET
             0859** 
             0860** ; OSBGET - Read a byte from a random disk file.
             0861** ;  E = file channel
             0862** ; Returns
             0863** ;  A = byte read
             0864** ;  Carry set if LAST BYTE of file
             0865** ; Destroys: A,B,C,F
             0866** ;
0B42F7 C5    0867** OSBGET:			PUSH	BC
0B42F8 4B    0868** LD	C, E
             0869** MOSCALL	mos_fgetc
0B42F9 3E   0001**M LD	A, function
0B42FA 0C 
0B42FB 49   0002**M RST.LIS	08h
0B42FC CF 
0B42FD C1    0870** POP	BC
0B42FE C9    0871** RET
             0872** 
             0873** ; OSBPUT - Write a byte to a random disk file.
             0874** ;  E = file channel
             0875** ;  A = byte to write
             0876** ; Destroys: A,B,C,F
             0877** ;
0B42FF C5    0878** OSBPUT:			PUSH	BC
0B4300 4B    0879** LD	C, E
0B4301 47    0880** LD	B, A
             0881** MOSCALL	mos_fputc
0B4302 3E   0001**M LD	A, function
0B4303 0D 
0B4304 49   0002**M RST.LIS	08h
0B4305 CF 
0B4306 C1    0882** POP	BC
0B4307 C9    0883** RET
             0884** 
             0885** ; OSSTAT - Read file status
             0886** ;  E = file channel
             0887** ; Returns
             0888** ;  F: Z flag set - EOF
             0889** ;  A: If Z then A = 0
             0890** ; Destroys: A,D,E,H,L,F
             0891** ;
0B4308 C5    0892** OSSTAT:			PUSH	BC
0B4309 4B    0893** LD	C, E
             0894** MOSCALL	mos_feof
0B430A 3E   0001**M LD	A, function
0B430B 0E 
0B430C 49   0002**M RST.LIS	08h
0B430D CF 
0B430E C1    0895** POP	BC
0B430F FE    0896** CP	1
0B4310 01 
0B4311 C9    0897** RET
             0898** 
             0899** ; GETPTR - Return file pointer.
             0900** ;    E = file channel
             0901** ; Returns:
             0902** ; DEHL = pointer (0-&7FFFFF)
             0903** ; Destroys: A,B,C,D,E,H,L,F
             0904** ;
0B4312 FD    0905** GETPTR:			PUSH		IY
0B4313 E5 
0B4314 4B    0906** LD		C, E
             0907** MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0B4315 3E   0001**M LD	A, function
0B4316 19 
0B4317 49   0002**M RST.LIS	08h
0B4318 CF 
0B4319 E5    0908** PUSH		HL
0B431A FD    0909** POP		IY		; IYU: Pointer to FIL structure
0B431B E1 
0B431C FD    0910** LD		L, (IY + FIL.fptr + 0)
0B431D 6E 
0B431E 11 
0B431F FD    0911** LD		H, (IY + FIL.fptr + 1)
0B4320 66 
0B4321 12 
0B4322 FD    0912** LD		E, (IY + FIL.fptr + 2)
0B4323 5E 
0B4324 13 
0B4325 FD    0913** LD		D, (IY + FIL.fptr + 3)
0B4326 56 
0B4327 14 
0B4328 FD    0914** POP		IY
0B4329 E1 
0B432A C9    0915** RET
             0916** 
             0917** ; PUTPTR - Update file pointer.
             0918** ;    A = file channel
             0919** ; DEHL = new pointer (0-&7FFFFF)
             0920** ; Destroys: A,B,C,D,E,H,L,F
             0921** ;
0B432B FD    0922** PUTPTR:			PUSH		IY
0B432C E5 
0B432D 4F    0923** LD		C, A  		; C: Filehandle
0B432E E5    0924** PUSH		HL
0B432F 21    0925** LD		HL, 2
0B4330 02 
0B4331 00 
0B4332 00 
0B4333 39    0926** ADD		HL, SP
0B4334 73    0927** LD		(HL), E 	; 3rd byte of DWORD set to E
0B4335 E1    0928** POP		HL
0B4336 5A    0929** LD		E, D  		; 4th byte passed as E
             0930** MOSCALL		mos_flseek
0B4337 3E   0001**M LD	A, function
0B4338 1C 
0B4339 49   0002**M RST.LIS	08h
0B433A CF 
0B433B FD    0931** POP		IY
0B433C E1 
0B433D C9    0932** RET
             0933** 
             0934** ; GETEXT - Find file size.
             0935** ;    E = file channel
             0936** ; Returns:
             0937** ; DEHL = file size (0-&800000)
             0938** ; Destroys: A,B,C,D,E,H,L,F
             0939** ;
0B433E FD    0940** GETEXT:         PUSH    IY
0B433F E5 
0B4340 4B    0941** LD      C, E
             0942** MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0B4341 3E   0001**M LD	A, function
0B4342 19 
0B4343 49   0002**M RST.LIS	08h
0B4344 CF 
0B4345 E5    0943** PUSH    HL
0B4346 FD    0944** POP     IY          ; IYU: Pointer to FIL structure
0B4347 E1 
             0945** ; Access the obj.objsize field using the offset values
0B4348 FD    0946** LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0B4349 6E 
0B434A 0B 
0B434B FD    0947** LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0B434C 66 
0B434D 0C 
0B434E FD    0948** LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0B434F 5E 
0B4350 0D 
0B4351 FD    0949** LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0B4352 56 
0B4353 0E 
             0950** 
0B4354 FD    0951** POP     IY
0B4355 E1 
0B4356 C9    0952** RET
             0953** 
             0954** ; GETIMS - Get time from RTC
             0955** ;
0B4357 FD    0956** GETIMS:			PUSH	IY
0B4358 E5 
0B4359 21    0957** LD	HL, ACCS 		; Where to store the time string
0B435A 00 
0B435B 5B 
0B435C 0B 
             0958** MOSCALL	mos_getrtc
0B435D 3E   0001**M LD	A, function
0B435E 12 
0B435F 49   0002**M RST.LIS	08h
0B4360 CF 
0B4361 11    0959** LD	DE, ACCS		; DE: pointer to start of string accumulator
0B4362 00 
0B4363 5B 
0B4364 0B 
0B4365 5F    0960** LD	E, A 			;  E: now points to the end of the string
0B4366 FD    0961** POP	IY
0B4367 E1 
0B4368 C9    0962** RET
             0963** 
             0964** ; Get two word values from EXPR in DE, HL
             0965** ; IY: Pointer to expression string
             0966** ; Returns:
             0967** ; DE: P1
             0968** ; HL: P2
             0969** ;
0B4369 CD    0970** EXPR_W2:		CALL	EXPRI			; Get first parameter
0B436A CE 
0B436B 02 
0B436C 0B 
0B436D D9    0971** EXX
0B436E E5    0972** PUSH	HL
0B436F CD    0973** CALL	COMMA
0B4370 E6 
0B4371 09 
0B4372 0B 
0B4373 CD    0974** CALL	EXPRI			; Get second parameter
0B4374 CE 
0B4375 02 
0B4376 0B 
0B4377 D9    0975** EXX
0B4378 D1    0976** POP	DE
0B4379 C9    0977** RET
             0978** 
             0979** ; Stuff not implemented yet
             0980** ;
0B437A C9    0981** RESET:			RET
              0010* include "basic/sorry.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Catch-all for unimplemented functionality
             0004** ; Author:	Dean Belfield
             0005** ; Created:	12/05/2023
             0006** ; Last Updated:	12/05/2023
             0007** ;
             0008** ; Modinfo:
             0009** 
             0010** ; .ASSUME	ADL = 1
             0011** 
             0012** ; SEGMENT CODE
             0013** 
             0014** ; XDEF	ENVEL
             0015** ; XDEF	ADVAL
             0016** ; XDEF	PUTIMS
             0017** 
             0018** ; XREF	EXTERR
             0019** 
             0020** ENVEL:
             0021** ADVAL:
             0022** PUTIMS:
0B437B AF    0023** XOR     A
0B437C CD    0024** CALL    EXTERR
0B437D 3B 
0B437E 37 
0B437F 0B 
0B4380 53    0025** DEFB    "Sorry"
0B4381 6F 
0B4382 72 
0B4383 72 
0B4383 79   
0B4385 00    0026** DEFB    0
              0011* include "basic/agon_graphics.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Graphics stuff
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	07/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 07/06/2023:	Modified to run in ADL mode
             0009** 
             0010** ; .ASSUME	ADL = 1
             0011** 
             0012** ; INCLUDE	"equs.inc"
             0013** ; INCLUDE "macros.inc"
             0014** ; INCLUDE "mos_api.inc"	; In MOS/src
             0015** 
             0016** ; SEGMENT CODE
             0017** 
             0018** ; XDEF	CLG
             0019** ; XDEF	CLRSCN
             0020** ; XDEF	MODE
             0021** ; XDEF	COLOUR
             0022** ; XDEF	GCOL
             0023** ; XDEF	MOVE
             0024** ; XDEF	PLOT
             0025** ; XDEF	DRAW
             0026** ; XDEF	POINT
             0027** ; XDEF	GETSCHR
             0028** 
             0029** ; XREF	OSWRCH
             0030** ; XREF	ASC_TO_NUMBER
             0031** ; XREF	EXTERR
             0032** ; XREF	EXPRI
             0033** ; XREF	COMMA
             0034** ; XREF	XEQ
             0035** ; XREF	NXT
             0036** ; XREF	BRAKET
             0037** ; XREF	COUNT0
             0038** ; XREF	CRTONULL
             0039** ; XREF	NULLTOCR
             0040** ; XREF	CRLF
             0041** ; XREF	EXPR_W2
             0042** ; XREF	INKEY1
             0043** 
             0044** ; CLG: clears the graphics area
             0045** ;
             0046** CLG:
             0047** 
             0048** VDU	10h
0B4386 3E   0001**M LD	A, val
0B4387 10 
0B4388 CD   0002**M CALL	OSWRCH
0B4389 C4 
0B438A 3E 
0B438B 0B 
0B438C C3    0049** JP	XEQ
0B438D 5A 
0B438E 0B 
0B438F 0B 
             0050** 
             0051** ; CLS: clears the text area
             0052** ;
0B4390 3E    0053** CLRSCN:			LD	A, 0Ch
0B4391 0C 
0B4392 C3    0054** JP	OSWRCH
0B4393 C4 
0B4394 3E 
0B4395 0B 
             0055** 
             0056** ; MODE n: Set video mode
             0057** ;
0B4396 DD    0058** MODE:			PUSH	IX			; Get the system vars in IX
0B4397 E5 
             0059** MOSCALL	mos_sysvars		; Reset the semaphore
0B4398 3E   0001**M LD	A, function
0B4399 08 
0B439A 49   0002**M RST.LIS	08h
0B439B CF 
0B439C DD    0060** RES	4, (IX+sysvar_vpd_pflags)
0B439D CB 
0B439E 04 
0B439F A6 
0B43A0 CD    0061** CALL    EXPRI
0B43A1 CE 
0B43A2 02 
0B43A3 0B 
0B43A4 D9    0062** EXX
             0063** VDU	16H			; Mode change
0B43A5 3E   0001**M LD	A, val
0B43A6 16 
0B43A7 CD   0002**M CALL	OSWRCH
0B43A8 C4 
0B43A9 3E 
0B43AA 0B 
             0064** VDU	L
0B43AB 7D   0001**M LD	A, val
0B43AC CD   0002**M CALL	OSWRCH
0B43AD C4 
0B43AE 3E 
0B43AF 0B 
             0065** MOSCALL	mos_sysvars
0B43B0 3E   0001**M LD	A, function
0B43B1 08 
0B43B2 49   0002**M RST.LIS	08h
0B43B3 CF 
0B43B4 DD    0066** @@:			BIT	4, (IX+sysvar_vpd_pflags)
0B43B5 CB 
0B43B6 04 
0B43B7 66 
0B43B8 28    0067** JR	Z, @B			; Wait for the result
0B43B9 FA 
0B43BA DD    0068** POP	IX
0B43BB E1 
0B43BC C3    0069** JP	XEQ
0B43BD 5A 
0B43BE 0B 
0B43BF 0B 
             0070** 
             0071** ; GET(x,y): Get the ASCII code of a character on screen
             0072** ;
0B43C0 FD    0073** GETSCHR:		INC	IY
0B43C1 23 
0B43C2 CD    0074** CALL    EXPRI      		; Get X coordinate
0B43C3 CE 
0B43C4 02 
0B43C5 0B 
0B43C6 D9    0075** EXX
0B43C7 22    0076** LD	(VDU_BUFFER+0), HL
0B43C8 00 
0B43C9 5B 
0B43CA 0B 
0B43CB CD    0077** CALL	COMMA
0B43CC E6 
0B43CD 09 
0B43CE 0B 
0B43CF CD    0078** CALL	EXPRI			; Get Y coordinate
0B43D0 CE 
0B43D1 02 
0B43D2 0B 
0B43D3 D9    0079** EXX
0B43D4 22    0080** LD	(VDU_BUFFER+2), HL
0B43D5 02 
0B43D6 5B 
0B43D7 0B 
0B43D8 CD    0081** CALL	BRAKET			; Closing bracket
0B43D9 F3 
0B43DA 09 
0B43DB 0B 
             0082** ;
0B43DC DD    0083** PUSH	IX			; Get the system vars in IX
0B43DD E5 
             0084** MOSCALL	mos_sysvars		; Reset the semaphore
0B43DE 3E   0001**M LD	A, function
0B43DF 08 
0B43E0 49   0002**M RST.LIS	08h
0B43E1 CF 
0B43E2 DD    0085** RES	1, (IX+sysvar_vpd_pflags)
0B43E3 CB 
0B43E4 04 
0B43E5 8E 
             0086** VDU	23
0B43E6 3E   0001**M LD	A, val
0B43E7 17 
0B43E8 CD   0002**M CALL	OSWRCH
0B43E9 C4 
0B43EA 3E 
0B43EB 0B 
             0087** VDU	0
0B43EC 3E   0001**M LD	A, val
0B43ED 00 
0B43EE CD   0002**M CALL	OSWRCH
0B43EF C4 
0B43F0 3E 
0B43F1 0B 
             0088** VDU	vdp_scrchar
0B43F2 3E   0001**M LD	A, val
0B43F3 83 
0B43F4 CD   0002**M CALL	OSWRCH
0B43F5 C4 
0B43F6 3E 
0B43F7 0B 
             0089** VDU	(VDU_BUFFER+0)
0B43F8 3A   0001**M LD	A, val
0B43F9 00 
0B43FA 5B 
0B43FB 0B 
0B43FC CD   0002**M CALL	OSWRCH
0B43FD C4 
0B43FE 3E 
0B43FF 0B 
             0090** VDU	(VDU_BUFFER+1)
0B4400 3A   0001**M LD	A, val
0B4401 01 
0B4402 5B 
0B4403 0B 
0B4404 CD   0002**M CALL	OSWRCH
0B4405 C4 
0B4406 3E 
0B4407 0B 
             0091** VDU	(VDU_BUFFER+2)
0B4408 3A   0001**M LD	A, val
0B4409 02 
0B440A 5B 
0B440B 0B 
0B440C CD   0002**M CALL	OSWRCH
0B440D C4 
0B440E 3E 
0B440F 0B 
             0092** VDU	(VDU_BUFFER+3)
0B4410 3A   0001**M LD	A, val
0B4411 03 
0B4412 5B 
0B4413 0B 
0B4414 CD   0002**M CALL	OSWRCH
0B4415 C4 
0B4416 3E 
0B4417 0B 
0B4418 DD    0093** @@:			BIT	1, (IX+sysvar_vpd_pflags)
0B4419 CB 
0B441A 04 
0B441B 4E 
0B441C 28    0094** JR	Z, @B			; Wait for the result
0B441D FA 
0B441E DD    0095** LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0B441F 7E 
0B4420 09 
0B4421 B7    0096** OR	A			; Check for 00h
0B4422 37    0097** SCF				; C = character map
0B4423 20    0098** JR	NZ, @F			; We have a character, so skip next bit
0B4424 02 
0B4425 AF    0099** XOR	A			; Clear carry
0B4426 3D    0100** DEC	A			; Set A to FFh
0B4427 DD    0101** @@:			POP	IX
0B4428 E1 
0B4429 C3    0102** JP	INKEY1			; Jump back to the GET command
0B442A A5 
0B442B 07 
0B442C 0B 
             0103** 
             0104** ; POINT(x,y): Get the pixel colour of a point on screen
             0105** ;
0B442D CD    0106** POINT:			CALL    EXPRI      		; Get X coordinate
0B442E CE 
0B442F 02 
0B4430 0B 
0B4431 D9    0107** EXX
0B4432 22    0108** LD	(VDU_BUFFER+0), HL
0B4433 00 
0B4434 5B 
0B4435 0B 
0B4436 CD    0109** CALL	COMMA
0B4437 E6 
0B4438 09 
0B4439 0B 
0B443A CD    0110** CALL	EXPRI			; Get Y coordinate
0B443B CE 
0B443C 02 
0B443D 0B 
0B443E D9    0111** EXX
0B443F 22    0112** LD	(VDU_BUFFER+2), HL
0B4440 02 
0B4441 5B 
0B4442 0B 
0B4443 CD    0113** CALL	BRAKET			; Closing bracket
0B4444 F3 
0B4445 09 
0B4446 0B 
             0114** ;
0B4447 DD    0115** PUSH	IX			; Get the system vars in IX
0B4448 E5 
             0116** MOSCALL	mos_sysvars		; Reset the semaphore
0B4449 3E   0001**M LD	A, function
0B444A 08 
0B444B 49   0002**M RST.LIS	08h
0B444C CF 
0B444D DD    0117** RES	2, (IX+sysvar_vpd_pflags)
0B444E CB 
0B444F 04 
0B4450 96 
             0118** VDU	23
0B4451 3E   0001**M LD	A, val
0B4452 17 
0B4453 CD   0002**M CALL	OSWRCH
0B4454 C4 
0B4455 3E 
0B4456 0B 
             0119** VDU	0
0B4457 3E   0001**M LD	A, val
0B4458 00 
0B4459 CD   0002**M CALL	OSWRCH
0B445A C4 
0B445B 3E 
0B445C 0B 
             0120** VDU	vdp_scrpixel
0B445D 3E   0001**M LD	A, val
0B445E 84 
0B445F CD   0002**M CALL	OSWRCH
0B4460 C4 
0B4461 3E 
0B4462 0B 
             0121** VDU	(VDU_BUFFER+0)
0B4463 3A   0001**M LD	A, val
0B4464 00 
0B4465 5B 
0B4466 0B 
0B4467 CD   0002**M CALL	OSWRCH
0B4468 C4 
0B4469 3E 
0B446A 0B 
             0122** VDU	(VDU_BUFFER+1)
0B446B 3A   0001**M LD	A, val
0B446C 01 
0B446D 5B 
0B446E 0B 
0B446F CD   0002**M CALL	OSWRCH
0B4470 C4 
0B4471 3E 
0B4472 0B 
             0123** VDU	(VDU_BUFFER+2)
0B4473 3A   0001**M LD	A, val
0B4474 02 
0B4475 5B 
0B4476 0B 
0B4477 CD   0002**M CALL	OSWRCH
0B4478 C4 
0B4479 3E 
0B447A 0B 
             0124** VDU	(VDU_BUFFER+3)
0B447B 3A   0001**M LD	A, val
0B447C 03 
0B447D 5B 
0B447E 0B 
0B447F CD   0002**M CALL	OSWRCH
0B4480 C4 
0B4481 3E 
0B4482 0B 
0B4483 DD    0125** @@:			BIT	2, (IX+sysvar_vpd_pflags)
0B4484 CB 
0B4485 04 
0B4486 56 
0B4487 28    0126** JR	Z, @B			; Wait for the result
0B4488 FA 
             0127** ;
             0128** ; Return the data as a 1 byte index
             0129** ;
0B4489 DD    0130** LD	L, (IX+sysvar_scrpixelIndex)
0B448A 6E 
0B448B 16 
0B448C DD    0131** POP	IX
0B448D E1 
0B448E C3    0132** JP	COUNT0
0B448F 43 
0B4490 05 
0B4491 0B 
             0133** 
             0134** 
             0135** ; COLOUR colour
             0136** ; COLOUR L,P
             0137** ; COLOUR L,R,G,B
             0138** ;
0B4492 CD    0139** COLOUR:			CALL	EXPRI			; The colour / mode
0B4493 CE 
0B4494 02 
0B4495 0B 
0B4496 D9    0140** EXX
0B4497 7D    0141** LD	A, L
0B4498 32    0142** LD	(VDU_BUFFER+0), A	; Store first parameter
0B4499 00 
0B449A 5B 
0B449B 0B 
0B449C CD    0143** CALL	NXT			; Are there any more parameters?
0B449D 34 
0B449E 0A 
0B449F 0B 
0B44A0 FE    0144** CP	','
0B44A1 2C 
0B44A2 28    0145** JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0B44A3 12 
             0146** ;
             0147** VDU	11h			; Just set the colour
0B44A4 3E   0001**M LD	A, val
0B44A5 11 
0B44A6 CD   0002**M CALL	OSWRCH
0B44A7 C4 
0B44A8 3E 
0B44A9 0B 
             0148** VDU	(VDU_BUFFER+0)
0B44AA 3A   0001**M LD	A, val
0B44AB 00 
0B44AC 5B 
0B44AD 0B 
0B44AE CD   0002**M CALL	OSWRCH
0B44AF C4 
0B44B0 3E 
0B44B1 0B 
0B44B2 C3    0149** JP	XEQ
0B44B3 5A 
0B44B4 0B 
0B44B5 0B 
             0150** ;
0B44B6 CD    0151** COLOUR_1:		CALL	COMMA
0B44B7 E6 
0B44B8 09 
0B44B9 0B 
0B44BA CD    0152** CALL	EXPRI			; Parse R (OR P)
0B44BB CE 
0B44BC 02 
0B44BD 0B 
0B44BE D9    0153** EXX
0B44BF 7D    0154** LD	A, L
0B44C0 32    0155** LD	(VDU_BUFFER+1), A
0B44C1 01 
0B44C2 5B 
0B44C3 0B 
0B44C4 CD    0156** CALL	NXT			; Are there any more parameters?
0B44C5 34 
0B44C6 0A 
0B44C7 0B 
0B44C8 FE    0157** CP	','
0B44C9 2C 
0B44CA 28    0158** JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
0B44CB 2C 
             0159** ;
             0160** VDU	13h			; VDU:COLOUR
0B44CC 3E   0001**M LD	A, val
0B44CD 13 
0B44CE CD   0002**M CALL	OSWRCH
0B44CF C4 
0B44D0 3E 
0B44D1 0B 
             0161** VDU	(VDU_BUFFER+0)		; Logical Colour
0B44D2 3A   0001**M LD	A, val
0B44D3 00 
0B44D4 5B 
0B44D5 0B 
0B44D6 CD   0002**M CALL	OSWRCH
0B44D7 C4 
0B44D8 3E 
0B44D9 0B 
             0162** VDU	(VDU_BUFFER+1)		; Palette Colour
0B44DA 3A   0001**M LD	A, val
0B44DB 01 
0B44DC 5B 
0B44DD 0B 
0B44DE CD   0002**M CALL	OSWRCH
0B44DF C4 
0B44E0 3E 
0B44E1 0B 
             0163** VDU	0			; RGB set to 0
0B44E2 3E   0001**M LD	A, val
0B44E3 00 
0B44E4 CD   0002**M CALL	OSWRCH
0B44E5 C4 
0B44E6 3E 
0B44E7 0B 
             0164** VDU	0
0B44E8 3E   0001**M LD	A, val
0B44E9 00 
0B44EA CD   0002**M CALL	OSWRCH
0B44EB C4 
0B44EC 3E 
0B44ED 0B 
             0165** VDU	0
0B44EE 3E   0001**M LD	A, val
0B44EF 00 
0B44F0 CD   0002**M CALL	OSWRCH
0B44F1 C4 
0B44F2 3E 
0B44F3 0B 
0B44F4 C3    0166** JP	XEQ
0B44F5 5A 
0B44F6 0B 
0B44F7 0B 
             0167** ;
0B44F8 CD    0168** COLOUR_2:		CALL	COMMA
0B44F9 E6 
0B44FA 09 
0B44FB 0B 
0B44FC CD    0169** CALL	EXPRI			; Parse G
0B44FD CE 
0B44FE 02 
0B44FF 0B 
0B4500 D9    0170** EXX
0B4501 7D    0171** LD	A, L
0B4502 32    0172** LD	(VDU_BUFFER+2), A
0B4503 02 
0B4504 5B 
0B4505 0B 
0B4506 CD    0173** CALL	COMMA
0B4507 E6 
0B4508 09 
0B4509 0B 
0B450A CD    0174** CALL	EXPRI			; Parse B
0B450B CE 
0B450C 02 
0B450D 0B 
0B450E D9    0175** EXX
0B450F 7D    0176** LD	A, L
0B4510 32    0177** LD	(VDU_BUFFER+3), A
0B4511 03 
0B4512 5B 
0B4513 0B 
             0178** VDU	13h			; VDU:COLOUR
0B4514 3E   0001**M LD	A, val
0B4515 13 
0B4516 CD   0002**M CALL	OSWRCH
0B4517 C4 
0B4518 3E 
0B4519 0B 
             0179** VDU	(VDU_BUFFER+0)		; Logical Colour
0B451A 3A   0001**M LD	A, val
0B451B 00 
0B451C 5B 
0B451D 0B 
0B451E CD   0002**M CALL	OSWRCH
0B451F C4 
0B4520 3E 
0B4521 0B 
             0180** VDU	FFh			; Physical Colour (-1 for RGB mode)
0B4522 3E   0001**M LD	A, val
0B4523 FF 
0B4524 CD   0002**M CALL	OSWRCH
0B4525 C4 
0B4526 3E 
0B4527 0B 
             0181** VDU	(VDU_BUFFER+1)		; R
0B4528 3A   0001**M LD	A, val
0B4529 01 
0B452A 5B 
0B452B 0B 
0B452C CD   0002**M CALL	OSWRCH
0B452D C4 
0B452E 3E 
0B452F 0B 
             0182** VDU	(VDU_BUFFER+2)		; G
0B4530 3A   0001**M LD	A, val
0B4531 02 
0B4532 5B 
0B4533 0B 
0B4534 CD   0002**M CALL	OSWRCH
0B4535 C4 
0B4536 3E 
0B4537 0B 
             0183** VDU	(VDU_BUFFER+3)		; B
0B4538 3A   0001**M LD	A, val
0B4539 03 
0B453A 5B 
0B453B 0B 
0B453C CD   0002**M CALL	OSWRCH
0B453D C4 
0B453E 3E 
0B453F 0B 
0B4540 C3    0184** JP	XEQ
0B4541 5A 
0B4542 0B 
0B4543 0B 
             0185** 
             0186** ; GCOL mode,colour
             0187** ;
0B4544 CD    0188** GCOL:			CALL	EXPRI			; Parse MODE
0B4545 CE 
0B4546 02 
0B4547 0B 
0B4548 D9    0189** EXX
0B4549 7D    0190** LD	A, L
0B454A 32    0191** LD	(VDU_BUFFER+0), A
0B454B 00 
0B454C 5B 
0B454D 0B 
0B454E CD    0192** CALL	COMMA
0B454F E6 
0B4550 09 
0B4551 0B 
             0193** ;
0B4552 CD    0194** CALL	EXPRI			; Parse Colour
0B4553 CE 
0B4554 02 
0B4555 0B 
0B4556 D9    0195** EXX
0B4557 7D    0196** LD	A, L
0B4558 32    0197** LD	(VDU_BUFFER+1), A
0B4559 01 
0B455A 5B 
0B455B 0B 
             0198** ;
             0199** VDU	12h			; VDU:GCOL
0B455C 3E   0001**M LD	A, val
0B455D 12 
0B455E CD   0002**M CALL	OSWRCH
0B455F C4 
0B4560 3E 
0B4561 0B 
             0200** VDU	(VDU_BUFFER+0)		; Mode
0B4562 3A   0001**M LD	A, val
0B4563 00 
0B4564 5B 
0B4565 0B 
0B4566 CD   0002**M CALL	OSWRCH
0B4567 C4 
0B4568 3E 
0B4569 0B 
             0201** VDU	(VDU_BUFFER+1)		; Colour
0B456A 3A   0001**M LD	A, val
0B456B 01 
0B456C 5B 
0B456D 0B 
0B456E CD   0002**M CALL	OSWRCH
0B456F C4 
0B4570 3E 
0B4571 0B 
0B4572 C3    0202** JP	XEQ
0B4573 5A 
0B4574 0B 
0B4575 0B 
             0203** 
             0204** ; PLOT mode,x,y
             0205** ;
0B4576 CD    0206** PLOT:			CALL	EXPRI		; Parse mode
0B4577 CE 
0B4578 02 
0B4579 0B 
0B457A D9    0207** EXX
0B457B E5    0208** PUSH	HL		; Push mode (L) onto stack
0B457C CD    0209** CALL	COMMA
0B457D E6 
0B457E 09 
0B457F 0B 
0B4580 CD    0210** CALL	EXPR_W2		; Parse X and Y
0B4581 69 
0B4582 43 
0B4583 0B 
0B4584 C1    0211** POP	BC		; Pop mode (C) off stack
             0212** PLOT_1:			VDU	19H		; VDU code for PLOT
0B4585 3E   0001**M LD	A, val
0B4586 19 
0B4587 CD   0002**M CALL	OSWRCH
0B4588 C4 
0B4589 3E 
0B458A 0B 
             0213** VDU	C		;  C: Mode
0B458B 79   0001**M LD	A, val
0B458C CD   0002**M CALL	OSWRCH
0B458D C4 
0B458E 3E 
0B458F 0B 
             0214** VDU	E		; DE: X
0B4590 7B   0001**M LD	A, val
0B4591 CD   0002**M CALL	OSWRCH
0B4592 C4 
0B4593 3E 
0B4594 0B 
             0215** VDU	D
0B4595 7A   0001**M LD	A, val
0B4596 CD   0002**M CALL	OSWRCH
0B4597 C4 
0B4598 3E 
0B4599 0B 
             0216** VDU	L		; HL: Y
0B459A 7D   0001**M LD	A, val
0B459B CD   0002**M CALL	OSWRCH
0B459C C4 
0B459D 3E 
0B459E 0B 
             0217** VDU	H
0B459F 7C   0001**M LD	A, val
0B45A0 CD   0002**M CALL	OSWRCH
0B45A1 C4 
0B45A2 3E 
0B45A3 0B 
0B45A4 C3    0218** JP	XEQ
0B45A5 5A 
0B45A6 0B 
0B45A7 0B 
             0219** 
             0220** ; MOVE x,y
             0221** ;
0B45A8 CD    0222** MOVE:			CALL	EXPR_W2		; Parse X and Y
0B45A9 69 
0B45AA 43 
0B45AB 0B 
0B45AC 0E    0223** LD	C, 04H		; Plot mode 04H (Move)
0B45AD 04 
0B45AE 18    0224** JR	PLOT_1		; Plot
0B45AF D5 
             0225** 
             0226** ; DRAW x1,y1
             0227** ; DRAW x1,y1,x2,y2
             0228** ;
0B45B0 CD    0229** DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0B45B1 69 
0B45B2 43 
0B45B3 0B 
0B45B4 CD    0230** CALL	NXT		; Are there any more parameters?
0B45B5 34 
0B45B6 0A 
0B45B7 0B 
0B45B8 FE    0231** CP	','
0B45B9 2C 
0B45BA 0E    0232** LD	C, 05h		; Code for LINE
0B45BB 05 
0B45BC 20    0233** JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0B45BD C7 
             0234** VDU	19h		; Move to the first coordinates
0B45BE 3E   0001**M LD	A, val
0B45BF 19 
0B45C0 CD   0002**M CALL	OSWRCH
0B45C1 C4 
0B45C2 3E 
0B45C3 0B 
             0235** VDU	04h
0B45C4 3E   0001**M LD	A, val
0B45C5 04 
0B45C6 CD   0002**M CALL	OSWRCH
0B45C7 C4 
0B45C8 3E 
0B45C9 0B 
             0236** VDU	E
0B45CA 7B   0001**M LD	A, val
0B45CB CD   0002**M CALL	OSWRCH
0B45CC C4 
0B45CD 3E 
0B45CE 0B 
             0237** VDU	D
0B45CF 7A   0001**M LD	A, val
0B45D0 CD   0002**M CALL	OSWRCH
0B45D1 C4 
0B45D2 3E 
0B45D3 0B 
             0238** VDU	L
0B45D4 7D   0001**M LD	A, val
0B45D5 CD   0002**M CALL	OSWRCH
0B45D6 C4 
0B45D7 3E 
0B45D8 0B 
             0239** VDU	H
0B45D9 7C   0001**M LD	A, val
0B45DA CD   0002**M CALL	OSWRCH
0B45DB C4 
0B45DC 3E 
0B45DD 0B 
0B45DE CD    0240** CALL	COMMA
0B45DF E6 
0B45E0 09 
0B45E1 0B 
0B45E2 C5    0241** PUSH	BC
0B45E3 CD    0242** CALL	EXPR_W2		; Get X2 and Y2
0B45E4 69 
0B45E5 43 
0B45E6 0B 
0B45E7 C1    0243** POP	BC
0B45E8 18    0244** JR	PLOT_1		; Now DRAW the line to those positions
0B45E9 9B 
             0245** 
             0246** 
             0247** 
              0012* include "basic/agon_sound.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Audio stuff
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	12/05/2023
             0006** ;
             0007** ; Modinfo:
             0008** 
             0009** ; .ASSUME	ADL = 1
             0010** 
             0011** ; INCLUDE	"equs.inc"
             0012** ; INCLUDE "macros.inc"
             0013** ; INCLUDE "mos_api.inc"	; In MOS/src
             0014** 
             0015** ; SEGMENT CODE
             0016** 
             0017** ; XDEF	SOUND
             0018** 
             0019** ; XREF	COMMA
             0020** ; XREF	EXPR_W2
             0021** ; XREF	XEQ
             0022** ; XREF	LTRAP
             0023** ; XREF	OSWRCH
             0024** ; XREF	VDU_BUFFER
             0025** 
             0026** 
             0027** ; SOUND channel,volume,pitch,duration
             0028** ; volume: 0 (off) to -15 (full volume)
             0029** ; pitch: 0 - 255
             0030** ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
             0031** ;
0B45EA CD    0032** SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
0B45EB 69 
0B45EC 43 
0B45ED 0B 
0B45EE 7D    0033** LD	A, L 			;  A: Volume
0B45EF F5    0034** PUSH	AF
0B45F0 D5    0035** PUSH	DE
0B45F1 CD    0036** CALL	COMMA
0B45F2 E6 
0B45F3 09 
0B45F4 0B 
0B45F5 CD    0037** CALL	EXPR_W2			; DE: Pitch, HL: Duration
0B45F6 69 
0B45F7 43 
0B45F8 0B 
0B45F9 53    0038** LD	D, E			;  D: Pitch
0B45FA 5D    0039** LD	E, L 			;  E: Duration
0B45FB E1    0040** POP	HL 			; HL: Channel/Control
0B45FC F1    0041** POP	AF
0B45FD ED    0042** NEG
0B45FE 44 
0B45FF FE    0043** CP	16			; Check volume is in bounds
0B4600 10 
0B4601 D2    0044** JP	NC, XEQ			; Out of bounds, do nothing
0B4602 5A 
0B4603 0B 
0B4604 0B 
             0045** ;
             0046** ; Store	in VDU vars
             0047** ;
0B4605 4F    0048** LD	C, A			; Store Volume in C
0B4606 7D    0049** LD	A, L
0B4607 32    0050** LD	(VDU_BUFFER+0), A	; Channel
0B4608 00 
0B4609 5B 
0B460A 0B 
0B460B AF    0051** XOR	A
0B460C 32    0052** LD	(VDU_BUFFER+1), A	; Waveform
0B460D 01 
0B460E 5B 
0B460F 0B 
             0053** ;
             0054** ; Calculate the volume
             0055** ;
0B4610 06    0056** LD	B, 6			; C already contains the volume
0B4611 06 
0B4612 ED    0057** MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0B4613 4C 
0B4614 79    0058** LD	A, C
0B4615 32    0059** LD	(VDU_BUFFER+2), A
0B4616 02 
0B4617 5B 
0B4618 0B 
             0060** ;
             0061** ; And the frequency
             0062** ;
0B4619 4B    0063** LD	C, E			; Store duration in C
0B461A 26    0064** LD	H, 0			; Lookup the frequency
0B461B 00 
0B461C 6A    0065** LD	L, D
0B461D 11    0066** LD	DE, SOUND_FREQ_LOOKUP
0B461E A4 
0B461F 46 
0B4620 0B 
0B4621 29    0067** ADD	HL, HL
0B4622 19    0068** ADD	HL, DE
0B4623 7E    0069** LD	A, (HL)
0B4624 32    0070** LD	(VDU_BUFFER+3), A
0B4625 03 
0B4626 5B 
0B4627 0B 
0B4628 23    0071** INC	HL
0B4629 7E    0072** LD	A, (HL)
0B462A 32    0073** LD	(VDU_BUFFER+4), A
0B462B 04 
0B462C 5B 
0B462D 0B 
             0074** ;
             0075** ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
             0076** ;
0B462E 06    0077** LD	B, 50			; C contains the duration, so MLT by 50
0B462F 32 
0B4630 ED    0078** MLT	BC
0B4631 4C 
0B4632 ED    0079** LD	(VDU_BUFFER+5), BC
0B4633 43 
0B4634 05 
0B4635 5B 
0B4635 0B   
             0080** ;
0B4637 DD    0081** PUSH	IX			; Get the system vars in IX
0B4638 E5 
             0082** MOSCALL	mos_sysvars		; Reset the semaphore
0B4639 3E   0001**M LD	A, function
0B463A 08 
0B463B 49   0002**M RST.LIS	08h
0B463C CF 
0B463D 5B    0083** SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
0B463E DD 
0B463F CB 
0B4640 04 
0B4640 9E   
             0084** ;
             0085** VDU	23			; Send the sound command
0B4642 3E   0001**M LD	A, val
0B4643 17 
0B4644 CD   0002**M CALL	OSWRCH
0B4645 C4 
0B4646 3E 
0B4647 0B 
             0086** VDU	0
0B4648 3E   0001**M LD	A, val
0B4649 00 
0B464A CD   0002**M CALL	OSWRCH
0B464B C4 
0B464C 3E 
0B464D 0B 
             0087** VDU	vdp_audio
0B464E 3E   0001**M LD	A, val
0B464F 85 
0B4650 CD   0002**M CALL	OSWRCH
0B4651 C4 
0B4652 3E 
0B4653 0B 
             0088** VDU	(VDU_BUFFER+0)		; 0: Channel
0B4654 3A   0001**M LD	A, val
0B4655 00 
0B4656 5B 
0B4657 0B 
0B4658 CD   0002**M CALL	OSWRCH
0B4659 C4 
0B465A 3E 
0B465B 0B 
             0089** VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0B465C 3A   0001**M LD	A, val
0B465D 01 
0B465E 5B 
0B465F 0B 
0B4660 CD   0002**M CALL	OSWRCH
0B4661 C4 
0B4662 3E 
0B4663 0B 
             0090** VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0B4664 3A   0001**M LD	A, val
0B4665 02 
0B4666 5B 
0B4667 0B 
0B4668 CD   0002**M CALL	OSWRCH
0B4669 C4 
0B466A 3E 
0B466B 0B 
             0091** VDU	(VDU_BUFFER+3)		; 3: Frequency L
0B466C 3A   0001**M LD	A, val
0B466D 03 
0B466E 5B 
0B466F 0B 
0B4670 CD   0002**M CALL	OSWRCH
0B4671 C4 
0B4672 3E 
0B4673 0B 
             0092** VDU	(VDU_BUFFER+4)		; 4: Frequency H
0B4674 3A   0001**M LD	A, val
0B4675 04 
0B4676 5B 
0B4677 0B 
0B4678 CD   0002**M CALL	OSWRCH
0B4679 C4 
0B467A 3E 
0B467B 0B 
             0093** VDU	(VDU_BUFFER+5)		; 5: Duration L
0B467C 3A   0001**M LD	A, val
0B467D 05 
0B467E 5B 
0B467F 0B 
0B4680 CD   0002**M CALL	OSWRCH
0B4681 C4 
0B4682 3E 
0B4683 0B 
             0094** VDU	(VDU_BUFFER+6)		; 6: Duration H
0B4684 3A   0001**M LD	A, val
0B4685 06 
0B4686 5B 
0B4687 0B 
0B4688 CD   0002**M CALL	OSWRCH
0B4689 C4 
0B468A 3E 
0B468B 0B 
             0095** ;
             0096** ; Wait for acknowledgement
             0097** ;
0B468C 5B    0098** @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
0B468D DD 
0B468E CB 
0B468F 04 
0B468F 5E   
0B4691 28    0099** JR	Z, @B			; Wait for the result
0B4692 F9 
0B4693 CD    0100** CALL	LTRAP			; Check for ESC
0B4694 35 
0B4695 3F 
0B4696 0B 
0B4697 5B    0101** LD.LIL	A, (IX+sysvar_audioSuccess)
0B4698 DD 
0B4699 7E 
0B469A 0E 
0B469B A7    0102** AND	A			; Check if VDP has queued the note
0B469C 28    0103** JR	Z, SOUND0		; No, so loop back and send again
0B469D 9F 
             0104** ;
0B469E DD    0105** POP	IX
0B469F E1 
0B46A0 C3    0106** JP	XEQ
0B46A1 5A 
0B46A2 0B 
0B46A3 0B 
             0107** 
             0108** ; Frequency Lookup Table
             0109** ; Set up to replicate the BBC Micro audio frequencies
             0110** ;
             0111** ; Split over 5 complete octaves, with 53 being middle C
             0112** ; * C4: 262hz
             0113** ; + A4: 440hz
             0114** ;
             0115** ;	2	3	4	5	6	7	8
             0116** ;
             0117** ; B	1	49	97	145	193	241
             0118** ; A#	0	45	93	141	189	237
             0119** ; A		41	89+	137	185	233
             0120** ; G#		37	85	133	181	229
             0121** ; G		33	81	129	177	225
             0122** ; F#		29	77	125	173	221
             0123** ; F		25	73	121	169	217
             0124** ; E		21	69	117	165	213
             0125** ; D#		17	65	113	161	209
             0126** ; D		13	61	109	157	205	253
             0127** ; C#		9	57	105	153	201	249
             0128** ; C		5	53*	101	149	197	245
             0129** ;
0B46A4 75    0130** SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
0B46A5 00 
0B46A6 76 
0B46A7 00 
0B46A7 78   
0B46A8 00 
0B46A9 7A 
0B46AA 00 
0B46AA 7B   
0B46AB 00 
0B46AC 83 
0B46AD 00 
0B46AD 85   
0B46AE 00 
0B46AF 87 
0B46B0 00 
0B46B4 89    0131** DW	 137,  139,  141,  143,  145,  147,  149,  151
0B46B5 00 
0B46B6 8B 
0B46B7 00 
0B46B7 8D   
0B46B8 00 
0B46B9 8F 
0B46BA 00 
0B46BA 91   
0B46BB 00 
0B46BC 93 
0B46BD 00 
0B46BD 95   
0B46BE 00 
0B46BF 97 
0B46C0 00 
0B46C4 99    0132** DW	 153,  156,  158,  160,  162,  165,  167,  170
0B46C5 00 
0B46C6 9C 
0B46C7 00 
0B46C7 9E   
0B46C8 00 
0B46C9 A0 
0B46CA 00 
0B46CA A2   
0B46CB 00 
0B46CC A5 
0B46CD 00 
0B46CD A7   
0B46CE 00 
0B46CF AA 
0B46D0 00 
0B46D4 AC    0133** DW	 172,  175,  177,  180,  182,  185,  188,  190
0B46D5 00 
0B46D6 AF 
0B46D7 00 
0B46D7 B1   
0B46D8 00 
0B46D9 B4 
0B46DA 00 
0B46DA B6   
0B46DB 00 
0B46DC B9 
0B46DD 00 
0B46DD BC   
0B46DE 00 
0B46DF BE 
0B46E0 00 
0B46E4 C1    0134** DW	 193,  196,  199,  202,  205,  208,  211,  214
0B46E5 00 
0B46E6 C4 
0B46E7 00 
0B46E7 C7   
0B46E8 00 
0B46E9 CA 
0B46EA 00 
0B46EA CD   
0B46EB 00 
0B46EC D0 
0B46ED 00 
0B46ED D3   
0B46EE 00 
0B46EF D6 
0B46F0 00 
0B46F4 D9    0135** DW	 217,  220,  223,  226,  230,  233,  236,  240
0B46F5 00 
0B46F6 DC 
0B46F7 00 
0B46F7 DF   
0B46F8 00 
0B46F9 E2 
0B46FA 00 
0B46FA E6   
0B46FB 00 
0B46FC E9 
0B46FD 00 
0B46FD EC   
0B46FE 00 
0B46FF F0 
0B4700 00 
0B4704 F3    0136** DW	 243,  247,  251,  254,  258,  262,  265,  269
0B4705 00 
0B4706 F7 
0B4707 00 
0B4707 FB   
0B4708 00 
0B4709 FE 
0B470A 00 
0B470A 02   
0B470B 01 
0B470C 06 
0B470D 01 
0B470D 09   
0B470E 01 
0B470F 0D 
0B4710 01 
0B4714 11    0137** DW	 273,  277,  281,  285,  289,  294,  298,  302
0B4715 01 
0B4716 15 
0B4717 01 
0B4717 19   
0B4718 01 
0B4719 1D 
0B471A 01 
0B471A 21   
0B471B 01 
0B471C 26 
0B471D 01 
0B471D 2A   
0B471E 01 
0B471F 2E 
0B4720 01 
0B4724 33    0138** DW	 307,  311,  316,  320,  325,  330,  334,  339
0B4725 01 
0B4726 37 
0B4727 01 
0B4727 3C   
0B4728 01 
0B4729 40 
0B472A 01 
0B472A 45   
0B472B 01 
0B472C 4A 
0B472D 01 
0B472D 4E   
0B472E 01 
0B472F 53 
0B4730 01 
0B4734 58    0139** DW	 344,  349,  354,  359,  365,  370,  375,  381
0B4735 01 
0B4736 5D 
0B4737 01 
0B4737 62   
0B4738 01 
0B4739 67 
0B473A 01 
0B473A 6D   
0B473B 01 
0B473C 72 
0B473D 01 
0B473D 77   
0B473E 01 
0B473F 7D 
0B4740 01 
0B4744 82    0140** DW	 386,  392,  398,  403,  409,  415,  421,  427
0B4745 01 
0B4746 88 
0B4747 01 
0B4747 8E   
0B4748 01 
0B4749 93 
0B474A 01 
0B474A 99   
0B474B 01 
0B474C 9F 
0B474D 01 
0B474D A5   
0B474E 01 
0B474F AB 
0B4750 01 
0B4754 B2    0141** DW	 434,  440,  446,  453,  459,  466,  473,  480
0B4755 01 
0B4756 B8 
0B4757 01 
0B4757 BE   
0B4758 01 
0B4759 C5 
0B475A 01 
0B475A CB   
0B475B 01 
0B475C D2 
0B475D 01 
0B475D D9   
0B475E 01 
0B475F E0 
0B4760 01 
0B4764 E7    0142** DW	 487,  494,  501,  508,  516,  523,  531,  539
0B4765 01 
0B4766 EE 
0B4767 01 
0B4767 F5   
0B4768 01 
0B4769 FC 
0B476A 01 
0B476A 04   
0B476B 02 
0B476C 0B 
0B476D 02 
0B476D 13   
0B476E 02 
0B476F 1B 
0B4770 02 
0B4774 22    0143** DW	 546,  554,  562,  571,  579,  587,  596,  605
0B4775 02 
0B4776 2A 
0B4777 02 
0B4777 32   
0B4778 02 
0B4779 3B 
0B477A 02 
0B477A 43   
0B477B 02 
0B477C 4B 
0B477D 02 
0B477D 54   
0B477E 02 
0B477F 5D 
0B4780 02 
0B4784 65    0144** DW	 613,  622,  631,  641,  650,  659,  669,  679
0B4785 02 
0B4786 6E 
0B4787 02 
0B4787 77   
0B4788 02 
0B4789 81 
0B478A 02 
0B478A 8A   
0B478B 02 
0B478C 93 
0B478D 02 
0B478D 9D   
0B478E 02 
0B478F A7 
0B4790 02 
0B4794 B1    0145** DW	 689,  699,  709,  719,  729,  740,  751,  762
0B4795 02 
0B4796 BB 
0B4797 02 
0B4797 C5   
0B4798 02 
0B4799 CF 
0B479A 02 
0B479A D9   
0B479B 02 
0B479C E4 
0B479D 02 
0B479D EF   
0B479E 02 
0B479F FA 
0B47A0 02 
0B47A4 05    0146** DW	 773,  784,  795,  807,  819,  831,  843,  855
0B47A5 03 
0B47A6 10 
0B47A7 03 
0B47A7 1B   
0B47A8 03 
0B47A9 27 
0B47AA 03 
0B47AA 33   
0B47AB 03 
0B47AC 3F 
0B47AD 03 
0B47AD 4B   
0B47AE 03 
0B47AF 57 
0B47B0 03 
0B47B4 63    0147** DW	 867,  880,  893,  906,  919,  932,  946,  960
0B47B5 03 
0B47B6 70 
0B47B7 03 
0B47B7 7D   
0B47B8 03 
0B47B9 8A 
0B47BA 03 
0B47BA 97   
0B47BB 03 
0B47BC A4 
0B47BD 03 
0B47BD B2   
0B47BE 03 
0B47BF C0 
0B47C0 03 
0B47C4 CE    0148** DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
0B47C5 03 
0B47C6 DC 
0B47C7 03 
0B47C7 EA   
0B47C8 03 
0B47C9 F9 
0B47CA 03 
0B47CA 08   
0B47CB 04 
0B47CC 17 
0B47CD 04 
0B47CD 26   
0B47CE 04 
0B47CF 36 
0B47D0 04 
0B47D4 45    0149** DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
0B47D5 04 
0B47D6 55 
0B47D7 04 
0B47D7 65   
0B47D8 04 
0B47D9 76 
0B47DA 04 
0B47DA 86   
0B47DB 04 
0B47DC 97 
0B47DD 04 
0B47DD A8   
0B47DE 04 
0B47DF BA 
0B47E0 04 
0B47E4 CB    0150** DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
0B47E5 04 
0B47E6 DD 
0B47E7 04 
0B47E7 EF   
0B47E8 04 
0B47E9 02 
0B47EA 05 
0B47EA 14   
0B47EB 05 
0B47EC 27 
0B47ED 05 
0B47ED 3A   
0B47EE 05 
0B47EF 4E 
0B47F0 05 
0B47F4 62    0151** DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
0B47F5 05 
0B47F6 76 
0B47F7 05 
0B47F7 8A   
0B47F8 05 
0B47F9 9F 
0B47FA 05 
0B47FA B3   
0B47FB 05 
0B47FC C9 
0B47FD 05 
0B47FD DE   
0B47FE 05 
0B47FF F4 
0B4800 05 
0B4804 0A    0152** DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
0B4805 06 
0B4806 21 
0B4807 06 
0B4807 38   
0B4808 06 
0B4809 4F 
0B480A 06 
0B480A 66   
0B480B 06 
0B480C 7E 
0B480D 06 
0B480D 96   
0B480E 06 
0B480F AF 
0B4810 06 
0B4814 C8    0153** DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
0B4815 06 
0B4816 E1 
0B4817 06 
0B4817 FA   
0B4818 06 
0B4819 14 
0B481A 07 
0B481A 2F   
0B481B 07 
0B481C 4A 
0B481D 07 
0B481D 65   
0B481E 07 
0B481F 80 
0B4820 07 
0B4824 9C    0154** DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
0B4825 07 
0B4826 B8 
0B4827 07 
0B4827 D5   
0B4828 07 
0B4829 F2 
0B482A 07 
0B482A 10   
0B482B 08 
0B482C 2D 
0B482D 08 
0B482D 4B   
0B482E 08 
0B482F 6A 
0B4830 08 
0B4834 8A    0155** DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
0B4835 08 
0B4836 A9 
0B4837 08 
0B4837 CA   
0B4838 08 
0B4839 EA 
0B483A 08 
0B483A 0C   
0B483B 09 
0B483C 2D 
0B483D 09 
0B483D 4F   
0B483E 09 
0B483F 72 
0B4840 09 
0B4844 95    0156** DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
0B4845 09 
0B4846 B9 
0B4847 09 
0B4847 DD   
0B4848 09 
0B4849 02 
0B484A 0A 
0B484A 27   
0B484B 0A 
0B484C 4D 
0B484D 0A 
0B484D 73   
0B484E 0A 
0B484F 9A 
0B4850 0A 
0B4854 C2    0157** DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
0B4855 0A 
0B4856 EA 
0B4857 0A 
0B4857 12   
0B4858 0B 
0B4859 3C 
0B485A 0B 
0B485A 66   
0B485B 0B 
0B485C 90 
0B485D 0B 
0B485D BB   
0B485E 0B 
0B485F E7 
0B4860 0B 
0B4864 13    0158** DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
0B4865 0C 
0B4866 40 
0B4867 0C 
0B4867 6E   
0B4868 0C 
0B4869 9C 
0B486A 0C 
0B486A CB   
0B486B 0C 
0B486C FA 
0B486D 0C 
0B486D 2B   
0B486E 0D 
0B486F 5C 
0B4870 0D 
0B4874 8E    0159** DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
0B4875 0D 
0B4876 C0 
0B4877 0D 
0B4877 F3   
0B4878 0D 
0B4879 27 
0B487A 0E 
0B487A 5C   
0B487B 0E 
0B487C 91 
0B487D 0E 
0B487D C8   
0B487E 0E 
0B487F FF 
0B4880 0E 
0B4884 36    0160** DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
0B4885 0F 
0B4886 6F 
0B4887 0F 
0B4887 A9   
0B4888 0F 
0B4889 E3 
0B488A 0F 
0B488A 1E   
0B488B 10 
0B488C 5A 
0B488D 10 
0B488D 97   
0B488E 10 
0B488F D5 
0B4890 10 
0B4894 13    0161** DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
0B4895 11 
0B4896 53 
0B4897 11 
0B4897 93   
0B4898 11 
0B4899 D5 
0B489A 11 
0B489A 17   
0B489B 12 
0B489C 5B 
0B489D 12 
0B489D 9F   
0B489E 12 
0B489F E4 
0B48A0 12 
             0162** 
             0163** 
              0013* include "basic/interrupts.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Interrupts
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	07/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 07/06/2023:	Modified to run in ADL mode
             0009** 
             0010** ; .ASSUME	ADL = 1
             0011** 
             0012** ; INCLUDE	"macros.inc"
             0013** ; INCLUDE	"equs.inc"
             0014** ; INCLUDE "mos_api.inc"	; In MOS/src
             0015** 
             0016** ; SEGMENT CODE
             0017** 
             0018** ; XDEF	VBLANK_INIT
             0019** ; XDEF	VBLANK_STOP
             0020** ; XDEF	VBLANK_HANDLER
             0021** 
             0022** ; XREF	ESCSET
             0023** ; XREF	KEYDOWN		; In ram.asm
             0024** ; XREF	KEYASCII 	; In ram.asm
             0025** ; XREF	KEYCOUNT	; In ram.asm
             0026** 
             0027** ; Hook into the MOS VBLANK interrupt
             0028** ;
0B48A4 F3    0029** VBLANK_INIT:		DI
0B48A5 21    0030** LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0B48A6 F9 
0B48A7 48 
0B48A8 0B 
0B48A9 1E    0031** LD		E, 32h				; Set up the VBlank Interrupt Vector
0B48AA 32 
             0032** MOSCALL		mos_setintvector
0B48AB 3E   0001**M LD	A, function
0B48AC 14 
0B48AD 49   0002**M RST.LIS	08h
0B48AE CF 
             0033** ; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0B48AF EB    0034** ex de,hl
0B48B0 21    0035** LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B48B1 07 
0B48B2 49 
0B48B3 0B 
0B48B4 ED    0036** LD		(HL), DE			; Self-modify the code
0B48B5 1F 
0B48B6 FB    0037** EI
0B48B7 C9    0038** RET
             0039** 
             0040** ; Unhook the custom VBLANK interrupt
             0041** ;
0B48B8 F3    0042** VBLANK_STOP:		DI
0B48B9 21    0043** LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B48BA 07 
0B48BB 49 
0B48BC 0B 
0B48BD ED    0044** LD		DE, (HL)
0B48BE 17 
0B48BF EB    0045** EX		DE, HL 				; HLU: Address of MOS interrupt vector
0B48C0 1E    0046** LD		E, 32h
0B48C1 32 
             0047** MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0B48C2 3E   0001**M LD	A, function
0B48C3 14 
0B48C4 49   0002**M RST.LIS	08h
0B48C5 CF 
0B48C6 FB    0048** EI
0B48C7 C9    0049** RET
             0050** 
             0051** ; A safe LIS call to ESCSET
             0052** ;
             0053** DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
0B48C8 3E   0001**M LD	A, function
0B48C9 08 
0B48CA 49   0002**M RST.LIS	08h
0B48CB CF 
0B48CC 21    0054** LD		HL, KEYCOUNT 			; Check whether the keycount has changed
0B48CD 49 
0B48CE 5E 
0B48CF 0B 
0B48D0 DD    0055** LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
0B48D1 7E 
0B48D2 19 
0B48D3 BE    0056** CP 		(HL)				; with our local copy
0B48D4 20    0057** JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
0B48D5 0A 
             0058** ;
0B48D6 AF    0059** DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
0B48D7 32    0060** LD		(KEYASCII), A
0B48D8 48 
0B48D9 5E 
0B48DA 0B 
0B48DB 32    0061** LD		(KEYDOWN), A
0B48DC 47 
0B48DD 5E 
0B48DE 0B 
0B48DF C9    0062** RET	 					; And return
             0063** ;
0B48E0 77    0064** DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
0B48E1 DD    0065** LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
0B48E2 7E 
0B48E3 18 
0B48E4 B7    0066** OR		A
0B48E5 28    0067** JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
0B48E6 EF 
             0068** ;
0B48E7 32    0069** LD		(KEYDOWN), A 			; Store the keydown value
0B48E8 47 
0B48E9 5E 
0B48EA 0B 
0B48EB DD    0070** LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
0B48EC 7E 
0B48ED 05 
0B48EE 32    0071** LD		(KEYASCII), A 			; Store locally
0B48EF 48 
0B48F0 5E 
0B48F1 0B 
0B48F2 FE    0072** CP		1Bh				; Is it escape?
0B48F3 1B 
0B48F4 CC    0073** CALL		Z, ESCSET			; Yes, so set the escape flags
0B48F5 10 
0B48F6 3F 
0B48F7 0B 
0B48F8 C9    0074** RET						; Return to the interrupt handler
             0075** 
0B48F9 F3    0076** VBLANK_HANDLER:		DI
0B48FA F5    0077** PUSH		AF
0B48FB E5    0078** PUSH		HL
0B48FC DD    0079** PUSH		IX
0B48FD E5 
0B48FE CD    0080** CALL		DO_KEYBOARD
0B48FF C8 
0B4900 48 
0B4901 0B 
0B4902 DD    0081** POP		IX
0B4903 E1 
0B4904 E1    0082** POP		HL
0B4905 F1    0083** POP		AF
             0084** ;
             0085** ; Finally jump to the MOS interrupt
             0086** ;
0B4906 C3    0087** VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0B4907 00 
0B4908 00 
0B4909 00 
               0187 include "functions.inc"
              0001* MACRO LOAD_FLOAT ARG
              0002* ld ix,$+11
              0003* call VAL_FP
              0004* jp (ix)
              0005* asciz ARG
              0006* ENDMACRO
              0007* 
              0008* MACRO printChar char
              0009* LD A, char
              0010* RST.LIL 10h
              0011* ENDMACRO
              0012* 
              0013* ; test the sign of HL
              0014* ; inputs: HL obviously
              0015* ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
              0016* ; destroys: flags
              0017* MACRO sign_hlu
              0018* add hl,de
              0019* or a
              0020* sbc hl,de
              0021* ENDMACRO
              0022* 
              0023* ; Simulated call to subroutine at HL
              0024* ; inputs: HL pointing to the subroutine address plus whatever the called function expects
              0025* ; outputs: whatever the subroutine does, including HL and BC
              0026* ; destroys: only what the subroutine does, but always BC
              0027* MACRO callHL
              0028* ld bc,$+7     ; Address of first instruction after the jump
              0029* push bc       ; which constitutes the return address
              0030* jp   (hl)     ; Jump to the address in HL
              0031* ENDMACRO
              0032* 
              0033* ; Simulated call to subroutine at IX
              0034* ; inputs: IX pointing to the subroutine address plus whatever the called function expects
              0035* ; outputs: whatever the subroutine does, including IX and BC
              0036* ; destroys: only what the subroutine does, but always BC
              0037* MACRO callIX
              0038* ld bc,$+7     ; Address of first instruction after the jump
              0039* push bc       ; which constitutes the return address
              0040* jp   (ix)     ; Jump to the address in IX
              0041* ENDMACRO
              0042* 
              0043* ; Simulated call to soubroutinte at IY
              0044* ; inputs: IY pointing to the subroutine address plus whatever the called function expects
              0045* ; outputs: whatever the subroutine does, including IY and BC
              0046* ; destroys: only what the subroutine does, but always BC
              0047* MACRO callIY
              0048* ld bc,$+7     ; Address of first instruction after the jump
              0049* push bc       ; which constitutes the return address
              0050* jp   (iy)     ; Jump to the address in IY
              0051* ENDMACRO
              0052* 
              0053* ; put the value in HLU into the accumulator
              0054* ; destroys: af
              0055* MACRO HLU_TO_A
              0056* push hl ; 4 cycles
              0057* inc sp ; 1 cycle
              0058* pop af  ; 4 cycles
              0059* dec sp ; 1 cycle
              0060* ; 10 cycles total
              0061* ENDMACRO
              0062* 
              0063* A_TO_HLU:
              0064* ; call is 7 cycles
0B490A 22     0065* ld (@scratch),hl ; 7 cycles
0B490B 17 
0B490C 49 
0B490D 0B 
0B490E 32     0066* ld (@scratch+2),a ; 5 cycles
0B490F 19 
0B4910 49 
0B4911 0B 
0B4912 2A     0067* ld hl,(@scratch) ; 7 cycles
0B4913 17 
0B4914 49 
0B4915 0B 
0B4916 C9     0068* ret ; 6 cycles
              0069* ; 25 cycles total
0B4917 00     0070* @scratch: dl 0
0B4918 00 
0B4919 00 
              0071* 
              0072* ; TODO: implement this
              0073* ; MACRO A_TO_HLU
              0074* ;     push.s af
              0075* ;     inc sp
              0076* ;     push.s hl
              0077* ;     pop hl
              0078* ;     inc sp
              0079* ;     inc sp
              0080* ; ENDMACRO
              0081* 
              0082* MACRO PUSH_ALL
              0083* ex af,af'
              0084* exx
              0085* push af
              0086* push hl
              0087* push bc
              0088* push de
              0089* 
              0090* ex af,af'
              0091* exx
              0092* push af
              0093* push hl
              0094* push bc
              0095* push de
              0096* push ix
              0097* push iy
              0098* ENDMACRO
              0099* 
              0100* MACRO POP_ALL
              0101* pop iy
              0102* pop ix
              0103* pop de
              0104* pop bc
              0105* pop hl
              0106* pop af
              0107* ex af,af'
              0108* exx
              0109* 
              0110* pop de
              0111* pop bc
              0112* pop hl
              0113* pop af
              0114* ex af,af'
              0115* exx
              0116* ENDMACRO
              0117* 
              0118* ; Print a zero-terminated string inline with code, e.g.:
              0119* ;
              0120* ;    call printInline
              0121* ;    ASCIZ "Hello, world!\r\n"
              0122* ;
              0123* ; Destroys: HL,AF
              0124* printInline:
0B491A E1     0125* pop hl ; get the return address = pointer to start of string
0B491B CD     0126* call printString ; HL advances to end of string
0B491C 21 
0B491D 49 
0B491E 0B 
0B491F E5     0127* push hl ; restore the return address = pointer to end of string
0B4920 C9     0128* ret
              0129* 
              0130* ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
              0131* ; Print a zero-terminated string
              0132* ; HL: Pointer to string
              0133* printString:
0B4921 C5     0134* PUSH	BC
0B4922 01     0135* LD		BC,0
0B4923 00 
0B4924 00 
0B4925 00 
0B4926 3E     0136* LD 	 	A,0
0B4927 00 
0B4928 5B     0137* RST.LIL 18h
0B4929 DF 
0B492A C1     0138* POP		BC
0B492B C9     0139* RET
              0140* ; print a VDU sequence
              0141* ; HL: Pointer to VDU sequence - <1 byte length> <data>
              0142* sendVDUsequence:
0B492C C5     0143* PUSH	BC
0B492D 01     0144* LD		BC, 0
0B492E 00 
0B492F 00 
0B4930 00 
0B4931 4E     0145* LD		C, (HL)
0B4932 5B     0146* RST.LIL	18h
0B4933 DF 
0B4934 C1     0147* POP		BC
0B4935 C9     0148* RET
              0149* ; Print Newline sequence to VDP
              0150* printNewLine:
0B4936 F5     0151* push af ; for some reason rst.lil 10h sets carry flag
0B4937 3E     0152* LD	A, '\r'
0B4938 0D 
0B4939 5B     0153* RST.LIL 10h
0B493A D7 
0B493B 3E     0154* LD	A, '\n'
0B493C 0A 
0B493D 5B     0155* RST.LIL 10h
0B493E D7 
0B493F F1     0156* pop af
0B4940 C9     0157* RET
              0158* 
              0159* ; Print a 24-bit HEX number
              0160* ; HLU: Number to print
              0161* printHex24:
              0162* HLU_TO_A
0B4941 E5    0001*M push hl ; 4 cycles
0B4942 33    0002*M inc sp ; 1 cycle
0B4943 F1    0003*M pop af  ; 4 cycles
0B4944 3B    0004*M dec sp ; 1 cycle
             0005*M ; 10 cycles total
0B4945 CD     0163* CALL	printHex8
0B4946 4F 
0B4947 49 
0B4948 0B 
              0164* ; Print a 16-bit HEX number
              0165* ; HL: Number to print
              0166* printHex16:
0B4949 7C     0167* LD		A,H
0B494A CD     0168* CALL	printHex8
0B494B 4F 
0B494C 49 
0B494D 0B 
0B494E 7D     0169* LD		A,L
              0170* ; Print an 8-bit HEX number
              0171* ; A: Number to print
              0172* printHex8:
0B494F 4F     0173* LD		C,A
0B4950 1F     0174* RRA
0B4951 1F     0175* RRA
0B4952 1F     0176* RRA
0B4953 1F     0177* RRA
0B4954 CD     0178* CALL	@F
0B4955 59 
0B4956 49 
0B4957 0B 
0B4958 79     0179* LD		A,C
              0180* @@:
0B4959 E6     0181* AND		0Fh
0B495A 0F 
0B495B C6     0182* ADD		A,90h
0B495C 90 
0B495D 27     0183* DAA
0B495E CE     0184* ADC		A,40h
0B495F 40 
0B4960 27     0185* DAA
0B4961 5B     0186* RST.LIL	10h
0B4962 D7 
0B4963 C9     0187* RET
              0188* 
              0189* printHexA:
0B4964 F5     0190* push af
0B4965 C5     0191* push bc
0B4966 CD     0192* call printHex8
0B4967 4F 
0B4968 49 
0B4969 0B 
0B496A 3E     0193* ld a,' '
0B496B 20 
0B496C 5B     0194* rst.lil 10h
0B496D D7 
0B496E C1     0195* pop bc
0B496F F1     0196* pop af
0B4970 C9     0197* ret
              0198* 
              0199* printHexHL:
0B4971 F5     0200* push af
0B4972 C5     0201* push bc
0B4973 CD     0202* call printHex16
0B4974 49 
0B4975 49 
0B4976 0B 
0B4977 3E     0203* ld a,' '
0B4978 20 
0B4979 5B     0204* rst.lil 10h
0B497A D7 
0B497B C1     0205* pop bc
0B497C F1     0206* pop af
0B497D C9     0207* ret
              0208* 
              0209* printHexUHL:
0B497E F5     0210* push af
0B497F C5     0211* push bc
0B4980 CD     0212* call printHex24
0B4981 41 
0B4982 49 
0B4983 0B 
0B4984 3E     0213* ld a,' '
0B4985 20 
0B4986 5B     0214* rst.lil 10h
0B4987 D7 
0B4988 C1     0215* pop bc
0B4989 F1     0216* pop af
0B498A C9     0217* ret
              0218* 
              0219* printHexAUHL:
0B498B F5     0220* push af
0B498C C5     0221* push bc
0B498D CD     0222* call printHex8
0B498E 4F 
0B498F 49 
0B4990 0B 
0B4991 3E     0223* ld a,'.'
0B4992 2E 
0B4993 5B     0224* rst.lil 10h
0B4994 D7 
0B4995 CD     0225* call printHex24
0B4996 41 
0B4997 49 
0B4998 0B 
0B4999 3E     0226* ld a,' '
0B499A 20 
0B499B 5B     0227* rst.lil 10h
0B499C D7 
0B499D C1     0228* pop bc
0B499E F1     0229* pop af
0B499F C9     0230* ret
              0231* 
              0232* printHexABHL:
              0233* ; preserve registers
0B49A0 C5     0234* push bc ; b will be ok c will not
0B49A1 F5     0235* push af ; will get totally destroyed
              0236* ; print a
0B49A2 CD     0237* call printHex8
0B49A3 4F 
0B49A4 49 
0B49A5 0B 
              0238* ; print b
0B49A6 78     0239* ld a,b
0B49A7 CD     0240* call printHex8
0B49A8 4F 
0B49A9 49 
0B49AA 0B 
              0241* ; print hl
0B49AB CD     0242* call printHex16
0B49AC 49 
0B49AD 49 
0B49AE 0B 
              0243* ; restore registers
0B49AF F1     0244* pop af
0B49B0 C1     0245* pop bc
0B49B1 C9     0246* ret
              0247* 
              0248* printHexBHL:
              0249* ; preserve registers
0B49B2 C5     0250* push bc ; b will be ok c will not
0B49B3 F5     0251* push af ; will get totally destroyed
              0252* ; print b
0B49B4 78     0253* ld a,b
0B49B5 CD     0254* call printHex8
0B49B6 4F 
0B49B7 49 
0B49B8 0B 
              0255* ; print hl
0B49B9 CD     0256* call printHex16
0B49BA 49 
0B49BB 49 
0B49BC 0B 
              0257* ; restore registers
0B49BD F1     0258* pop af
0B49BE C1     0259* pop bc
0B49BF C9     0260* ret
              0261* 
              0262* printHexCDE:
              0263* ; preserve registers
0B49C0 C5     0264* push bc ; b will be ok c will not
0B49C1 F5     0265* push af ; will get totally destroyed
              0266* ; print c
0B49C2 79     0267* ld a,c
0B49C3 CD     0268* call printHex8
0B49C4 4F 
0B49C5 49 
0B49C6 0B 
              0269* ; print de
0B49C7 EB     0270* ex de,hl
0B49C8 CD     0271* call printHex16
0B49C9 49 
0B49CA 49 
0B49CB 0B 
0B49CC EB     0272* ex de,hl
              0273* ; restore registers
0B49CD F1     0274* pop af
0B49CE C1     0275* pop bc
0B49CF C9     0276* ret
              0277* 
              0278* printHexUIX:
              0279* ; store everything in scratch
0B49D0 22     0280* ld (uhl),hl
0B49D1 49 
0B49D2 4E 
0B49D3 0B 
0B49D4 ED     0281* ld (ubc),bc
0B49D5 43 
0B49D6 4C 
0B49D7 4E 
0B49D7 0B   
0B49D9 ED     0282* ld (ude),de
0B49DA 53 
0B49DB 4F 
0B49DC 4E 
0B49DC 0B   
0B49DE DD     0283* ld (uix),ix
0B49DF 22 
0B49E0 52 
0B49E1 4E 
0B49E1 0B   
0B49E3 FD     0284* ld (uiy),iy
0B49E4 22 
0B49E5 55 
0B49E6 4E 
0B49E6 0B   
0B49E8 F5     0285* push af ; fml
              0286* 
0B49E9 21     0287* ld hl,str_ixu
0B49EA E0 
0B49EB 4D 
0B49EC 0B 
0B49ED CD     0288* call printString
0B49EE 21 
0B49EF 49 
0B49F0 0B 
0B49F1 2A     0289* ld hl,(uix)
0B49F2 52 
0B49F3 4E 
0B49F4 0B 
0B49F5 CD     0290* call printHex24
0B49F6 41 
0B49F7 49 
0B49F8 0B 
0B49F9 CD     0291* call printNewLine
0B49FA 36 
0B49FB 49 
0B49FC 0B 
              0292* 
              0293* ; restore everything
0B49FD 2A     0294* ld hl, (uhl)
0B49FE 49 
0B49FF 4E 
0B4A00 0B 
0B4A01 ED     0295* ld bc, (ubc)
0B4A02 4B 
0B4A03 4C 
0B4A04 4E 
0B4A04 0B   
0B4A06 ED     0296* ld de, (ude)
0B4A07 5B 
0B4A08 4F 
0B4A09 4E 
0B4A09 0B   
0B4A0B DD     0297* ld ix, (uix)
0B4A0C 2A 
0B4A0D 52 
0B4A0E 4E 
0B4A0E 0B   
0B4A10 FD     0298* ld iy, (uiy)
0B4A11 2A 
0B4A12 55 
0B4A13 4E 
0B4A13 0B   
0B4A15 F1     0299* pop af
              0300* ; all done
0B4A16 C9     0301* ret
              0302* 
              0303* ; Print a 0x HEX prefix
              0304* DisplayHexPrefix:
0B4A17 3E     0305* LD	A, '0'
0B4A18 30 
0B4A19 5B     0306* RST.LIL 10h
0B4A1A D7 
0B4A1B 3E     0307* LD	A, 'x'
0B4A1C 78 
0B4A1D 5B     0308* RST.LIL 10h
0B4A1E D7 
0B4A1F C9     0309* RET
              0310* 
              0311* MACRO printDecBC
              0312* push hl
              0313* push bc
              0314* pop hl
              0315* call printDec
              0316* pop hl
              0317* ENDMACRO
              0318* 
              0319* MACRO printDecDE
              0320* push hl
              0321* push de
              0322* pop hl
              0323* call printDec
              0324* pop hl
              0325* ENDMACRO
              0326* 
              0327* MACRO printDecHL
              0328* call printDec
              0329* ENDMACRO
              0330* 
              0331* MACRO printDecIX
              0332* push hl
              0333* push ix
              0334* pop hl
              0335* call printDec
              0336* pop hl
              0337* ENDMACRO
              0338* 
              0339* MACRO printDecIY
              0340* push hl
              0341* push iy
              0342* pop hl
              0343* call printDec
              0344* pop hl
              0345* ENDMACRO
              0346* 
              0347* 
              0348* ; Prints the right justified decimal value in HL without leading zeroes
              0349* ; HL : Value to print
              0350* ; preserves all registers and flags
              0351* printDec:
              0352* ; BEGIN MY CODE
              0353* ; back up all the things
0B4A20 F5     0354* push af
0B4A21 C5     0355* push bc
0B4A22 D5     0356* push de
0B4A23 E5     0357* push hl
              0358* ; END MY CODE
0B4A24 11     0359* LD	 DE, _printDecBuffer
0B4A25 4C 
0B4A26 4A 
0B4A27 0B 
0B4A28 CD     0360* CALL u24_to_ascii
0B4A29 5C 
0B4A2A 4A 
0B4A2B 0B 
              0361* ; BEGIN MY CODE
              0362* ; replace leading zeroes with spaces
0B4A2C 21     0363* LD	 HL, _printDecBuffer
0B4A2D 4C 
0B4A2E 4A 
0B4A2F 0B 
0B4A30 06     0364* ld   B, 7 ; if HL was 0, we want to keep the final zero
0B4A31 07 
              0365* @loop:
0B4A32 7E     0366* LD	 A, (HL)
0B4A33 FE     0367* CP	 '0'
0B4A34 30 
0B4A35 C2     0368* JP	 NZ, @done
0B4A36 3F 
0B4A37 4A 
0B4A38 0B 
0B4A39 3E     0369* LD   A, ' '
0B4A3A 20 
0B4A3B 77     0370* LD	 (HL), A
0B4A3C 23     0371* INC	 HL
              0372* ; CALL vdu_cursor_forward
0B4A3D 10     0373* DJNZ @loop
0B4A3E F3 
              0374* @done:
              0375* ; END MY CODE
0B4A3F 21     0376* LD	 HL, _printDecBuffer
0B4A40 4C 
0B4A41 4A 
0B4A42 0B 
0B4A43 CD     0377* CALL printString
0B4A44 21 
0B4A45 49 
0B4A46 0B 
              0378* ; BEGIN MY CODE
              0379* ; restore all the things
0B4A47 E1     0380* pop hl
0B4A48 D1     0381* pop de
0B4A49 C1     0382* pop bc
0B4A4A F1     0383* pop af
              0384* ; END MY CODE
0B4A4B C9     0385* RET
0B4A4C 00     0386* _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
0B4A4D 00 
0B4A4E 00 
0B4A4F 00 
0B4A4F 00   
0B4A50 00 
0B4A51 00 
0B4A52 00 
0B4A52 00   
0B4A53 00 
0B4A54 00 
0B4A55 00 
0B4A55 00   
0B4A56 00 
0B4A57 00 
0B4A58 00 
              0387* 
              0388* ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
              0389* ; starting to memory location pointing by DE, in decimal form and with leading zeroes
              0390* ; so it will allways be 8 characters length
              0391* ; HL : Value to convert to string
              0392* ; DE : pointer to buffer, at least 8 byte + 0
              0393* u24_to_ascii:
0B4A5C 01     0394* LD	 BC,-10000000
0B4A5D 80 
0B4A5E 69 
0B4A5F 67 
0B4A60 CD     0395* CALL @one_digit
0B4A61 93 
0B4A62 4A 
0B4A63 0B 
0B4A64 01     0396* LD	 BC,-1000000
0B4A65 C0 
0B4A66 BD 
0B4A67 F0 
0B4A68 CD     0397* CALL @one_digit
0B4A69 93 
0B4A6A 4A 
0B4A6B 0B 
0B4A6C 01     0398* LD	 BC,-100000
0B4A6D 60 
0B4A6E 79 
0B4A6F FE 
0B4A70 CD     0399* CALL @one_digit
0B4A71 93 
0B4A72 4A 
0B4A73 0B 
0B4A74 01     0400* LD   BC,-10000
0B4A75 F0 
0B4A76 D8 
0B4A77 FF 
0B4A78 CD     0401* CALL @one_digit
0B4A79 93 
0B4A7A 4A 
0B4A7B 0B 
0B4A7C 01     0402* LD   BC,-1000
0B4A7D 18 
0B4A7E FC 
0B4A7F FF 
0B4A80 CD     0403* CALL @one_digit
0B4A81 93 
0B4A82 4A 
0B4A83 0B 
0B4A84 01     0404* LD   BC,-100
0B4A85 9C 
0B4A86 FF 
0B4A87 FF 
0B4A88 CD     0405* CALL @one_digit
0B4A89 93 
0B4A8A 4A 
0B4A8B 0B 
0B4A8C 0E     0406* LD   C,-10
0B4A8D F6 
0B4A8E CD     0407* CALL @one_digit
0B4A8F 93 
0B4A90 4A 
0B4A91 0B 
0B4A92 48     0408* LD   C,B
              0409* @one_digit:
0B4A93 3E     0410* LD   A,'0'-1
0B4A94 2F 
              0411* @divide_me:
0B4A95 3C     0412* INC  A
0B4A96 09     0413* ADD  HL,BC
0B4A97 38     0414* JR   C,@divide_me
0B4A98 FC 
0B4A99 ED     0415* SBC  HL,BC
0B4A9A 42 
0B4A9B 12     0416* LD   (DE),A
0B4A9C 13     0417* INC  DE
0B4A9D C9     0418* RET
              0419* 
              0420* print_u24:
0B4A9E D5     0421* push de
0B4A9F E5     0422* push hl
0B4AA0 11     0423* ld de,_printDecBuffer
0B4AA1 4C 
0B4AA2 4A 
0B4AA3 0B 
0B4AA4 CD     0424* call u24_to_ascii
0B4AA5 5C 
0B4AA6 4A 
0B4AA7 0B 
0B4AA8 21     0425* ld hl,_printDecBuffer
0B4AA9 4C 
0B4AAA 4A 
0B4AAB 0B 
0B4AAC CD     0426* call printString
0B4AAD 21 
0B4AAE 49 
0B4AAF 0B 
0B4AB0 3E     0427* ld a,' '
0B4AB1 20 
0B4AB2 5B     0428* rst.lil 10h
0B4AB3 D7 
0B4AB4 E1     0429* pop hl
0B4AB5 D1     0430* pop de
0B4AB6 C9     0431* ret
              0432* 
              0433* ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
              0434* ; HL : Value to convert to string (integer part in H, fractional part in L)
              0435* ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
              0436* u168_to_ascii:
              0437* ; add a leading space to make room for sign flag if needed
0B4AB7 3E     0438* ld a,' '
0B4AB8 20 
0B4AB9 12     0439* ld (de),a
0B4ABA 13     0440* inc de
              0441* ; Convert integer part
0B4ABB E5     0442* push hl               ; Save HL (we’ll need the fractional part later)
0B4ABC CD     0443* call hlu_udiv256    ; Shift to get integer portion in HL
0B4ABD AF 
0B4ABE 4F 
0B4ABF 0B 
0B4AC0 01     0444* ld   bc, -10000
0B4AC1 F0 
0B4AC2 D8 
0B4AC3 FF 
0B4AC4 CD     0445* call @one_int
0B4AC5 E7 
0B4AC6 4A 
0B4AC7 0B 
0B4AC8 01     0446* ld   bc, -1000
0B4AC9 18 
0B4ACA FC 
0B4ACB FF 
0B4ACC CD     0447* call @one_int
0B4ACD E7 
0B4ACE 4A 
0B4ACF 0B 
0B4AD0 01     0448* ld   bc, -100
0B4AD1 9C 
0B4AD2 FF 
0B4AD3 FF 
0B4AD4 CD     0449* call @one_int
0B4AD5 E7 
0B4AD6 4A 
0B4AD7 0B 
0B4AD8 0E     0450* ld   c, -10
0B4AD9 F6 
0B4ADA CD     0451* call @one_int
0B4ADB E7 
0B4ADC 4A 
0B4ADD 0B 
0B4ADE 48     0452* ld   c, b
0B4ADF CD     0453* call @one_int
0B4AE0 E7 
0B4AE1 4A 
0B4AE2 0B 
0B4AE3 C3     0454* jp   @frac            ; Jump to fractional part conversion
0B4AE4 F2 
0B4AE5 4A 
0B4AE6 0B 
              0455* @one_int:
0B4AE7 3E     0456* ld   a, '0' - 1       ; Start ASCII character at '0'
0B4AE8 2F 
              0457* @divide_me:
0B4AE9 3C     0458* inc  a
0B4AEA 09     0459* add  hl, bc           ; Accumulate until overflow
0B4AEB 38     0460* jr   c, @divide_me
0B4AEC FC 
0B4AED ED     0461* sbc  hl, bc           ; Remove excess after overflow
0B4AEE 42 
0B4AEF 12     0462* ld   (de), a          ; Store ASCII digit
0B4AF0 13     0463* inc  de
0B4AF1 C9     0464* ret
              0465* ; Convert fractional part
              0466* @frac:
0B4AF2 3E     0467* ld   a, '.'           ; Decimal point
0B4AF3 2E 
0B4AF4 12     0468* ld   (de), a
0B4AF5 13     0469* inc  de
0B4AF6 E1     0470* pop  hl               ; Restore HL with original fraction
0B4AF7 06     0471* ld   b, 3             ; Loop counter for 3 fractional digits
0B4AF8 03 
              0472* @frac_loop:
0B4AF9 26     0473* ld   h, 10            ; Load multiplier for fractional part
0B4AFA 0A 
0B4AFB ED     0474* mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B4AFC 6C 
0B4AFD 3E     0475* ld   a, '0'
0B4AFE 30 
0B4AFF 84     0476* add  a, h             ; Convert integer part to ASCII
0B4B00 12     0477* ld   (de), a
0B4B01 13     0478* inc  de
0B4B02 10     0479* djnz @frac_loop       ; Repeat for each fractional digit
0B4B03 F5 
              0480* ; Add null terminator
0B4B04 AF     0481* xor  a                ; Null terminator
0B4B05 12     0482* ld   (de), a
0B4B06 C9     0483* ret
              0484* 
              0485* print_u168:
0B4B07 D5     0486* push de
0B4B08 E5     0487* push hl
0B4B09 11     0488* ld de,_printDecBuffer
0B4B0A 4C 
0B4B0B 4A 
0B4B0C 0B 
0B4B0D CD     0489* call u168_to_ascii
0B4B0E B7 
0B4B0F 4A 
0B4B10 0B 
0B4B11 21     0490* ld hl,_printDecBuffer
0B4B12 4C 
0B4B13 4A 
0B4B14 0B 
0B4B15 CD     0491* call printString
0B4B16 21 
0B4B17 49 
0B4B18 0B 
0B4B19 E1     0492* pop hl
0B4B1A D1     0493* pop de
0B4B1B C9     0494* ret
              0495* 
              0496* ; signed version of u168_to_ascii
              0497* s168_to_ascii:
0B4B1C D5     0498* push de ; save starting address of buffer
0B4B1D CD     0499* call hlu_abs
0B4B1E 48 
0B4B1F 4F 
0B4B20 0B 
0B4B21 F5     0500* push af ; save sign flag
0B4B22 CD     0501* call u168_to_ascii
0B4B23 B7 
0B4B24 4A 
0B4B25 0B 
0B4B26 F1     0502* pop af ; restore sign flag
0B4B27 D1     0503* pop de ; restore starting address of buffer
0B4B28 F0     0504* ret p ; hlu was positive so nothing to do
0B4B29 3E     0505* ld a,'-'
0B4B2A 2D 
0B4B2B 12     0506* ld (de),a
0B4B2C C9     0507* ret
              0508* 
              0509* print_s168:
0B4B2D D5     0510* push de
0B4B2E E5     0511* push hl
0B4B2F 11     0512* ld de,_printDecBuffer
0B4B30 4C 
0B4B31 4A 
0B4B32 0B 
0B4B33 CD     0513* call s168_to_ascii
0B4B34 1C 
0B4B35 4B 
0B4B36 0B 
0B4B37 21     0514* ld hl,_printDecBuffer
0B4B38 4C 
0B4B39 4A 
0B4B3A 0B 
0B4B3B CD     0515* call printString
0B4B3C 21 
0B4B3D 49 
0B4B3E 0B 
0B4B3F E1     0516* pop hl
0B4B40 D1     0517* pop de
0B4B41 C9     0518* ret
              0519* 
              0520* print_s168_hl:
0B4B42 F5     0521* push af
0B4B43 E5     0522* push hl
0B4B44 CD     0523* call print_s168
0B4B45 2D 
0B4B46 4B 
0B4B47 0B 
0B4B48 3E     0524* ld a,' '
0B4B49 20 
0B4B4A 5B     0525* rst.lil 10h
0B4B4B D7 
0B4B4C E1     0526* pop hl
0B4B4D F1     0527* pop af
0B4B4E C9     0528* ret
              0529* 
              0530* print_s168_bc:
0B4B4F F5     0531* push af
0B4B50 C5     0532* push bc
0B4B51 E5     0533* push hl
0B4B52 C5     0534* push bc
0B4B53 E1     0535* pop hl
0B4B54 CD     0536* call print_s168
0B4B55 2D 
0B4B56 4B 
0B4B57 0B 
0B4B58 3E     0537* ld a,' '
0B4B59 20 
0B4B5A 5B     0538* rst.lil 10h
0B4B5B D7 
0B4B5C E1     0539* pop hl
0B4B5D C1     0540* pop bc
0B4B5E F1     0541* pop af
0B4B5F C9     0542* ret
              0543* 
              0544* print_s168_de:
0B4B60 F5     0545* push af
0B4B61 D5     0546* push de
0B4B62 E5     0547* push hl
0B4B63 EB     0548* ex de,hl
0B4B64 CD     0549* call print_s168
0B4B65 2D 
0B4B66 4B 
0B4B67 0B 
0B4B68 3E     0550* ld a,' '
0B4B69 20 
0B4B6A 5B     0551* rst.lil 10h
0B4B6B D7 
0B4B6C E1     0552* pop hl
0B4B6D D1     0553* pop de
0B4B6E F1     0554* pop af
0B4B6F C9     0555* ret
              0556* 
              0557* print_s168_hl_bc_de:
0B4B70 F5     0558* push af
0B4B71 C5     0559* push bc
0B4B72 D5     0560* push de
0B4B73 E5     0561* push hl
0B4B74 CD     0562* call print_s168
0B4B75 2D 
0B4B76 4B 
0B4B77 0B 
0B4B78 3E     0563* ld a,' '
0B4B79 20 
0B4B7A 5B     0564* rst.lil 10h
0B4B7B D7 
0B4B7C C5     0565* push bc
0B4B7D E1     0566* pop hl
0B4B7E CD     0567* call print_s168
0B4B7F 2D 
0B4B80 4B 
0B4B81 0B 
0B4B82 3E     0568* ld a,' '
0B4B83 20 
0B4B84 5B     0569* rst.lil 10h
0B4B85 D7 
0B4B86 EB     0570* ex de,hl
0B4B87 CD     0571* call print_s168
0B4B88 2D 
0B4B89 4B 
0B4B8A 0B 
0B4B8B 3E     0572* ld a,' '
0B4B8C 20 
0B4B8D 5B     0573* rst.lil 10h
0B4B8E D7 
0B4B8F E1     0574* pop hl
0B4B90 D1     0575* pop de
0B4B91 C1     0576* pop bc
0B4B92 F1     0577* pop af
0B4B93 C9     0578* ret
              0579* 
              0580* print_s168_bc_de:
0B4B94 F5     0581* push af
0B4B95 C5     0582* push bc
0B4B96 D5     0583* push de
0B4B97 C5     0584* push bc
0B4B98 E1     0585* pop hl
0B4B99 CD     0586* call print_s168
0B4B9A 2D 
0B4B9B 4B 
0B4B9C 0B 
0B4B9D 3E     0587* ld a,' '
0B4B9E 20 
0B4B9F 5B     0588* rst.lil 10h
0B4BA0 D7 
0B4BA1 EB     0589* ex de,hl
0B4BA2 CD     0590* call print_s168
0B4BA3 2D 
0B4BA4 4B 
0B4BA5 0B 
0B4BA6 3E     0591* ld a,' '
0B4BA7 20 
0B4BA8 5B     0592* rst.lil 10h
0B4BA9 D7 
0B4BAA E1     0593* pop hl
0B4BAB D1     0594* pop de
0B4BAC C1     0595* pop bc
0B4BAD F1     0596* pop af
0B4BAE C9     0597* ret
              0598* 
              0599* print_s168_a:
0B4BAF F5     0600* push af
0B4BB0 C5     0601* push bc
0B4BB1 E5     0602* push hl
0B4BB2 21     0603* ld hl,0
0B4BB3 00 
0B4BB4 00 
0B4BB5 00 
0B4BB6 6F     0604* ld l,a
0B4BB7 CD     0605* call print_s168_hl
0B4BB8 42 
0B4BB9 4B 
0B4BBA 0B 
0B4BBB E1     0606* pop hl
0B4BBC C1     0607* pop bc
0B4BBD F1     0608* pop af
0B4BBE C9     0609* ret
              0610* 
              0611* ; #### new functions added by Brandon R. Gates ####
              0612* 
              0613* ; print the binary representation of the 8-bit value in a
              0614* ; destroys a, hl, bc
              0615* printBin8:
0B4BBF 06     0616* ld b,8      ; loop counter for 8 bits
0B4BC0 08 
0B4BC1 21     0617* ld hl,@cmd  ; set hl to the low byte of the output string
0B4BC2 DC 
0B4BC3 4B 
0B4BC4 0B 
              0618* ; (which will be the high bit of the value in a)
              0619* @loop:
0B4BC5 07     0620* rlca ; put the next highest bit into carry
0B4BC6 38     0621* jr c,@one
0B4BC7 04 
0B4BC8 36     0622* ld (hl),'0'
0B4BC9 30 
0B4BCA 18     0623* jr @next_bit
0B4BCB 02 
              0624* @one:
0B4BCC 36     0625* ld (hl),'1'
0B4BCD 31 
              0626* @next_bit:
0B4BCE 23     0627* inc hl
0B4BCF 10     0628* djnz @loop
0B4BD0 F4 
              0629* ; print it
0B4BD1 21     0630* ld hl,@cmd
0B4BD2 DC 
0B4BD3 4B 
0B4BD4 0B 
0B4BD5 01     0631* ld bc,@end-@cmd
0B4BD6 08 
0B4BD7 00 
0B4BD8 00 
0B4BD9 5B     0632* rst.lil $18
0B4BDA DF 
0B4BDB C9     0633* ret
              0634* @cmd: ds 8 ; eight bytes for eight bits
              0635* @end:
              0636* 
              0637* ; print the binary representation of the 8-bit value in a
              0638* ; in reverse order (lsb first)
              0639* ; destroys a, hl, bc
              0640* printBin8Rev:
0B4BE4 06     0641* ld b,8      ; loop counter for 8 bits
0B4BE5 08 
0B4BE6 21     0642* ld hl,@cmd  ; set hl to the low byte of the output string
0B4BE7 01 
0B4BE8 4C 
0B4BE9 0B 
              0643* ; (which will be the high bit of the value in a)
              0644* @loop:
0B4BEA 0F     0645* rrca ; put the next lowest bit into carry
0B4BEB 38     0646* jr c,@one
0B4BEC 04 
0B4BED 36     0647* ld (hl),'0'
0B4BEE 30 
0B4BEF 18     0648* jr @next_bit
0B4BF0 02 
              0649* @one:
0B4BF1 36     0650* ld (hl),'1'
0B4BF2 31 
              0651* @next_bit:
0B4BF3 23     0652* inc hl
0B4BF4 10     0653* djnz @loop
0B4BF5 F4 
              0654* ; print it
0B4BF6 21     0655* ld hl,@cmd
0B4BF7 01 
0B4BF8 4C 
0B4BF9 0B 
0B4BFA 01     0656* ld bc,@end-@cmd
0B4BFB 08 
0B4BFC 00 
0B4BFD 00 
0B4BFE 5B     0657* rst.lil $18
0B4BFF DF 
0B4C00 C9     0658* ret
              0659* @cmd: ds 8 ; eight bytes for eight bits
              0660* @end:
              0661* 
              0662* ; print registers to screen in hexidecimal format
              0663* ; inputs: none
              0664* ; outputs: values of every register printed to screen
              0665* ;    values of each register in global scratch memory
              0666* ; destroys: nothing
              0667* stepRegistersHex:
              0668* ; store everything in scratch
0B4C09 22     0669* ld (uhl),hl
0B4C0A 49 
0B4C0B 4E 
0B4C0C 0B 
0B4C0D ED     0670* ld (ubc),bc
0B4C0E 43 
0B4C0F 4C 
0B4C10 4E 
0B4C10 0B   
0B4C12 ED     0671* ld (ude),de
0B4C13 53 
0B4C14 4F 
0B4C15 4E 
0B4C15 0B   
0B4C17 DD     0672* ld (uix),ix
0B4C18 22 
0B4C19 52 
0B4C1A 4E 
0B4C1A 0B   
0B4C1C FD     0673* ld (uiy),iy
0B4C1D 22 
0B4C1E 55 
0B4C1F 4E 
0B4C1F 0B   
0B4C21 F5     0674* push af ; fml
0B4C22 E1     0675* pop hl  ; thanks, zilog
0B4C23 22     0676* ld (uaf),hl
0B4C24 46 
0B4C25 4E 
0B4C26 0B 
0B4C27 F5     0677* push af ; dammit
              0678* 
              0679* ; home the cursor
              0680* ; call vdu_home_cursor
              0681* 
              0682* ; print each register
0B4C28 21     0683* ld hl,str_afu
0B4C29 CC 
0B4C2A 4D 
0B4C2B 0B 
0B4C2C CD     0684* call printString
0B4C2D 21 
0B4C2E 49 
0B4C2F 0B 
0B4C30 2A     0685* ld hl,(uaf)
0B4C31 46 
0B4C32 4E 
0B4C33 0B 
0B4C34 CD     0686* call printHex24
0B4C35 41 
0B4C36 49 
0B4C37 0B 
0B4C38 CD     0687* call printNewLine
0B4C39 36 
0B4C3A 49 
0B4C3B 0B 
              0688* 
0B4C3C 21     0689* ld hl,str_hlu
0B4C3D D1 
0B4C3E 4D 
0B4C3F 0B 
0B4C40 CD     0690* call printString
0B4C41 21 
0B4C42 49 
0B4C43 0B 
0B4C44 2A     0691* ld hl,(uhl)
0B4C45 49 
0B4C46 4E 
0B4C47 0B 
0B4C48 CD     0692* call printHex24
0B4C49 41 
0B4C4A 49 
0B4C4B 0B 
0B4C4C CD     0693* call printNewLine
0B4C4D 36 
0B4C4E 49 
0B4C4F 0B 
              0694* 
0B4C50 21     0695* ld hl,str_bcu
0B4C51 D6 
0B4C52 4D 
0B4C53 0B 
0B4C54 CD     0696* call printString
0B4C55 21 
0B4C56 49 
0B4C57 0B 
0B4C58 2A     0697* ld hl,(ubc)
0B4C59 4C 
0B4C5A 4E 
0B4C5B 0B 
0B4C5C CD     0698* call printHex24
0B4C5D 41 
0B4C5E 49 
0B4C5F 0B 
0B4C60 CD     0699* call printNewLine
0B4C61 36 
0B4C62 49 
0B4C63 0B 
              0700* 
0B4C64 21     0701* ld hl,str_deu
0B4C65 DB 
0B4C66 4D 
0B4C67 0B 
0B4C68 CD     0702* call printString
0B4C69 21 
0B4C6A 49 
0B4C6B 0B 
0B4C6C 2A     0703* ld hl,(ude)
0B4C6D 4F 
0B4C6E 4E 
0B4C6F 0B 
0B4C70 CD     0704* call printHex24
0B4C71 41 
0B4C72 49 
0B4C73 0B 
0B4C74 CD     0705* call printNewLine
0B4C75 36 
0B4C76 49 
0B4C77 0B 
              0706* 
0B4C78 21     0707* ld hl,str_ixu
0B4C79 E0 
0B4C7A 4D 
0B4C7B 0B 
0B4C7C CD     0708* call printString
0B4C7D 21 
0B4C7E 49 
0B4C7F 0B 
0B4C80 2A     0709* ld hl,(uix)
0B4C81 52 
0B4C82 4E 
0B4C83 0B 
0B4C84 CD     0710* call printHex24
0B4C85 41 
0B4C86 49 
0B4C87 0B 
0B4C88 CD     0711* call printNewLine
0B4C89 36 
0B4C8A 49 
0B4C8B 0B 
              0712* 
0B4C8C 21     0713* ld hl,str_iyu
0B4C8D E5 
0B4C8E 4D 
0B4C8F 0B 
0B4C90 CD     0714* call printString
0B4C91 21 
0B4C92 49 
0B4C93 0B 
0B4C94 2A     0715* ld hl,(uiy)
0B4C95 55 
0B4C96 4E 
0B4C97 0B 
0B4C98 CD     0716* call printHex24
0B4C99 41 
0B4C9A 49 
0B4C9B 0B 
0B4C9C CD     0717* call printNewLine
0B4C9D 36 
0B4C9E 49 
0B4C9F 0B 
              0718* 
              0719* ; call vsync
              0720* 
0B4CA0 CD     0721* call printNewLine
0B4CA1 36 
0B4CA2 49 
0B4CA3 0B 
              0722* 
              0723* ; check for right shift key and quit if pressed
              0724* MOSCALL mos_getkbmap
0B4CA4 3E    0001*M LD	A, function
0B4CA5 1E 
0B4CA6 49    0002*M RST.LIS	08h
0B4CA7 CF 
              0725* @stayhere:
              0726* ; 7 RightShift
0B4CA8 DD     0727* bit 6,(ix+0)
0B4CA9 CB 
0B4CAA 00 
0B4CAB 76 
0B4CAC 20     0728* jr nz,@RightShift
0B4CAD 02 
0B4CAE 18     0729* jr @stayhere
0B4CAF F8 
              0730* @RightShift:
0B4CB0 DD     0731* res 0,(ix+14) ; debounce the key (hopefully)
0B4CB1 CB 
0B4CB2 0E 
0B4CB3 86 
0B4CB4 3E     0732* ld a,%10000000
0B4CB5 80 
              0733* ; call multiPurposeDelay
              0734* 
              0735* ; restore everything
0B4CB6 2A     0736* ld hl, (uhl)
0B4CB7 49 
0B4CB8 4E 
0B4CB9 0B 
0B4CBA ED     0737* ld bc, (ubc)
0B4CBB 4B 
0B4CBC 4C 
0B4CBD 4E 
0B4CBD 0B   
0B4CBF ED     0738* ld de, (ude)
0B4CC0 5B 
0B4CC1 4F 
0B4CC2 4E 
0B4CC2 0B   
0B4CC4 DD     0739* ld ix, (uix)
0B4CC5 2A 
0B4CC6 52 
0B4CC7 4E 
0B4CC7 0B   
0B4CC9 FD     0740* ld iy, (uiy)
0B4CCA 2A 
0B4CCB 55 
0B4CCC 4E 
0B4CCC 0B   
0B4CCE F1     0741* pop af
              0742* ; all done
0B4CCF C9     0743* ret
              0744* 
              0745* ; print registers to screen in hexidecimal format
              0746* ; inputs: none
              0747* ; outputs: values of every register printed to screen
              0748* ;    values of each register in global scratch memory
              0749* ; destroys: nothing
              0750* dumpRegistersHex:
              0751* ; store everything in scratch
0B4CD0 22     0752* ld (uhl),hl
0B4CD1 49 
0B4CD2 4E 
0B4CD3 0B 
0B4CD4 ED     0753* ld (ubc),bc
0B4CD5 43 
0B4CD6 4C 
0B4CD7 4E 
0B4CD7 0B   
0B4CD9 ED     0754* ld (ude),de
0B4CDA 53 
0B4CDB 4F 
0B4CDC 4E 
0B4CDC 0B   
0B4CDE DD     0755* ld (uix),ix
0B4CDF 22 
0B4CE0 52 
0B4CE1 4E 
0B4CE1 0B   
0B4CE3 FD     0756* ld (uiy),iy
0B4CE4 22 
0B4CE5 55 
0B4CE6 4E 
0B4CE6 0B   
0B4CE8 F5     0757* push af ; fml
0B4CE9 E1     0758* pop hl  ; thanks, zilog
0B4CEA 22     0759* ld (uaf),hl
0B4CEB 46 
0B4CEC 4E 
0B4CED 0B 
0B4CEE F5     0760* push af ; dammit
              0761* 
              0762* ; home the cursor
              0763* ; call vdu_home_cursor
              0764* ; call printNewLine
              0765* 
              0766* ; print each register
0B4CEF 21     0767* ld hl,str_afu
0B4CF0 CC 
0B4CF1 4D 
0B4CF2 0B 
0B4CF3 CD     0768* call printString
0B4CF4 21 
0B4CF5 49 
0B4CF6 0B 
0B4CF7 2A     0769* ld hl,(uaf)
0B4CF8 46 
0B4CF9 4E 
0B4CFA 0B 
0B4CFB CD     0770* call printHex24
0B4CFC 41 
0B4CFD 49 
0B4CFE 0B 
              0771* ; call printNewLine
              0772* 
0B4CFF 21     0773* ld hl,str_hlu
0B4D00 D1 
0B4D01 4D 
0B4D02 0B 
0B4D03 CD     0774* call printString
0B4D04 21 
0B4D05 49 
0B4D06 0B 
0B4D07 2A     0775* ld hl,(uhl)
0B4D08 49 
0B4D09 4E 
0B4D0A 0B 
0B4D0B CD     0776* call printHex24
0B4D0C 41 
0B4D0D 49 
0B4D0E 0B 
              0777* ; call printNewLine
              0778* 
0B4D0F 21     0779* ld hl,str_bcu
0B4D10 D6 
0B4D11 4D 
0B4D12 0B 
0B4D13 CD     0780* call printString
0B4D14 21 
0B4D15 49 
0B4D16 0B 
0B4D17 2A     0781* ld hl,(ubc)
0B4D18 4C 
0B4D19 4E 
0B4D1A 0B 
0B4D1B CD     0782* call printHex24
0B4D1C 41 
0B4D1D 49 
0B4D1E 0B 
              0783* ; call printNewLine
              0784* 
0B4D1F 21     0785* ld hl,str_deu
0B4D20 DB 
0B4D21 4D 
0B4D22 0B 
0B4D23 CD     0786* call printString
0B4D24 21 
0B4D25 49 
0B4D26 0B 
0B4D27 2A     0787* ld hl,(ude)
0B4D28 4F 
0B4D29 4E 
0B4D2A 0B 
0B4D2B CD     0788* call printHex24
0B4D2C 41 
0B4D2D 49 
0B4D2E 0B 
              0789* ; call printNewLine
              0790* 
0B4D2F 21     0791* ld hl,str_ixu
0B4D30 E0 
0B4D31 4D 
0B4D32 0B 
0B4D33 CD     0792* call printString
0B4D34 21 
0B4D35 49 
0B4D36 0B 
0B4D37 2A     0793* ld hl,(uix)
0B4D38 52 
0B4D39 4E 
0B4D3A 0B 
0B4D3B CD     0794* call printHex24
0B4D3C 41 
0B4D3D 49 
0B4D3E 0B 
              0795* ; call printNewLine
              0796* 
0B4D3F 21     0797* ld hl,str_iyu
0B4D40 E5 
0B4D41 4D 
0B4D42 0B 
0B4D43 CD     0798* call printString
0B4D44 21 
0B4D45 49 
0B4D46 0B 
0B4D47 2A     0799* ld hl,(uiy)
0B4D48 55 
0B4D49 4E 
0B4D4A 0B 
0B4D4B CD     0800* call printHex24
0B4D4C 41 
0B4D4D 49 
0B4D4E 0B 
              0801* ; call printNewLine
              0802* 
              0803* ; call vdu_vblank
              0804* 
0B4D4F CD     0805* call printNewLine
0B4D50 36 
0B4D51 49 
0B4D52 0B 
              0806* ; restore everything
0B4D53 2A     0807* ld hl, (uhl)
0B4D54 49 
0B4D55 4E 
0B4D56 0B 
0B4D57 ED     0808* ld bc, (ubc)
0B4D58 4B 
0B4D59 4C 
0B4D5A 4E 
0B4D5A 0B   
0B4D5C ED     0809* ld de, (ude)
0B4D5D 5B 
0B4D5E 4F 
0B4D5F 4E 
0B4D5F 0B   
0B4D61 DD     0810* ld ix, (uix)
0B4D62 2A 
0B4D63 52 
0B4D64 4E 
0B4D64 0B   
0B4D66 FD     0811* ld iy, (uiy)
0B4D67 2A 
0B4D68 55 
0B4D69 4E 
0B4D69 0B   
0B4D6B F1     0812* pop af
              0813* ; all done
0B4D6C C9     0814* ret
              0815* 
              0816* dumpRegistersHexPrime:
0B4D6D D9     0817* exx
0B4D6E 08     0818* ex af,af'
0B4D6F CD     0819* call dumpRegistersHex
0B4D70 D0 
0B4D71 4C 
0B4D72 0B 
0B4D73 08     0820* ex af,af'
0B4D74 D9     0821* exx
0B4D75 C9     0822* ret
              0823* 
              0824* ; additionally dump prime registers
              0825* ; inputs: none
              0826* ; outputs: values of every register printed to screen
              0827* ; destroys: nothing
              0828* dumpRegistersHexAll:
0B4D76 CD     0829* call dumpRegistersHex
0B4D77 D0 
0B4D78 4C 
0B4D79 0B 
0B4D7A 08     0830* ex af,af'
0B4D7B D9     0831* exx
0B4D7C CD     0832* call dumpRegistersHex
0B4D7D D0 
0B4D7E 4C 
0B4D7F 0B 
0B4D80 08     0833* ex af,af'
0B4D81 D9     0834* exx
0B4D82 C9     0835* ret
              0836* 
              0837* ; print hlu to screen in hexidecimal format
              0838* ; inputs: none
              0839* ; destroys: nothing
              0840* print_hex_hl:
0B4D83 F5     0841* push af
0B4D84 E5     0842* push hl
0B4D85 21     0843* ld hl,str_hlu
0B4D86 D1 
0B4D87 4D 
0B4D88 0B 
0B4D89 CD     0844* call printString
0B4D8A 21 
0B4D8B 49 
0B4D8C 0B 
0B4D8D E1     0845* pop hl
0B4D8E E5     0846* push hl
0B4D8F CD     0847* call printHex24
0B4D90 41 
0B4D91 49 
0B4D92 0B 
0B4D93 3E     0848* ld a,' '
0B4D94 20 
0B4D95 5B     0849* rst.lil 10h
0B4D96 D7 
0B4D97 E1     0850* pop hl
0B4D98 F1     0851* pop af
0B4D99 C9     0852* ret
              0853* 
              0854* ; print bcu to screen in hexidecimal format
              0855* ; inputs: none
              0856* ; destroys: nothing
              0857* print_hex_bc:
0B4D9A F5     0858* push af
0B4D9B E5     0859* push hl
0B4D9C C5     0860* push bc
0B4D9D 21     0861* ld hl,str_bcu
0B4D9E D6 
0B4D9F 4D 
0B4DA0 0B 
0B4DA1 CD     0862* call printString
0B4DA2 21 
0B4DA3 49 
0B4DA4 0B 
0B4DA5 E1     0863* pop hl
0B4DA6 E5     0864* push hl
0B4DA7 CD     0865* call printHex24
0B4DA8 41 
0B4DA9 49 
0B4DAA 0B 
0B4DAB 3E     0866* ld a,' '
0B4DAC 20 
0B4DAD 5B     0867* rst.lil 10h
0B4DAE D7 
0B4DAF C1     0868* pop bc
0B4DB0 E1     0869* pop hl
0B4DB1 F1     0870* pop af
0B4DB2 C9     0871* ret
              0872* 
              0873* ; print deu to screen in hexidecimal format
              0874* ; inputs: none
              0875* ; destroys: nothing
              0876* print_hex_de:
0B4DB3 F5     0877* push af
0B4DB4 E5     0878* push hl
0B4DB5 D5     0879* push de
0B4DB6 21     0880* ld hl,str_deu
0B4DB7 DB 
0B4DB8 4D 
0B4DB9 0B 
0B4DBA CD     0881* call printString
0B4DBB 21 
0B4DBC 49 
0B4DBD 0B 
0B4DBE E1     0882* pop hl
0B4DBF E5     0883* push hl
0B4DC0 CD     0884* call printHex24
0B4DC1 41 
0B4DC2 49 
0B4DC3 0B 
0B4DC4 3E     0885* ld a,' '
0B4DC5 20 
0B4DC6 5B     0886* rst.lil 10h
0B4DC7 D7 
0B4DC8 D1     0887* pop de
0B4DC9 E1     0888* pop hl
0B4DCA F1     0889* pop af
0B4DCB C9     0890* ret
              0891* 
0B4DCC 20     0892* str_afu: db " af=",0
0B4DCD 61 
0B4DCE 66 
0B4DCF 3D 
0B4DCF 00   
0B4DD1 20     0893* str_hlu: db " hl=",0
0B4DD2 68 
0B4DD3 6C 
0B4DD4 3D 
0B4DD4 00   
0B4DD6 20     0894* str_bcu: db " bc=",0
0B4DD7 62 
0B4DD8 63 
0B4DD9 3D 
0B4DD9 00   
0B4DDB 20     0895* str_deu: db " de=",0
0B4DDC 64 
0B4DDD 65 
0B4DDE 3D 
0B4DDE 00   
0B4DE0 20     0896* str_ixu: db " ix=",0
0B4DE1 69 
0B4DE2 78 
0B4DE3 3D 
0B4DE3 00   
0B4DE5 20     0897* str_iyu: db " iy=",0
0B4DE6 69 
0B4DE7 79 
0B4DE8 3D 
0B4DE8 00   
              0898* 
              0899* ; print udeuhl to screen in hexidecimal format
              0900* ; inputs: none
              0901* ; outputs: concatenated hexidecimal udeuhl
              0902* ; destroys: nothing
              0903* dumpUDEUHLHex:
              0904* ; store everything in scratch
0B4DEA 22     0905* ld (uhl),hl
0B4DEB 49 
0B4DEC 4E 
0B4DED 0B 
0B4DEE ED     0906* ld (ubc),bc
0B4DEF 43 
0B4DF0 4C 
0B4DF1 4E 
0B4DF1 0B   
0B4DF3 ED     0907* ld (ude),de
0B4DF4 53 
0B4DF5 4F 
0B4DF6 4E 
0B4DF6 0B   
0B4DF8 DD     0908* ld (uix),ix
0B4DF9 22 
0B4DFA 52 
0B4DFB 4E 
0B4DFB 0B   
0B4DFD FD     0909* ld (uiy),iy
0B4DFE 22 
0B4DFF 55 
0B4E00 4E 
0B4E00 0B   
0B4E02 F5     0910* push af
              0911* 
              0912* ; print each register
              0913* 
0B4E03 21     0914* ld hl,str_udeuhl
0B4E04 3D 
0B4E05 4E 
0B4E06 0B 
0B4E07 CD     0915* call printString
0B4E08 21 
0B4E09 49 
0B4E0A 0B 
0B4E0B 2A     0916* ld hl,(ude)
0B4E0C 4F 
0B4E0D 4E 
0B4E0E 0B 
0B4E0F CD     0917* call printHex24
0B4E10 41 
0B4E11 49 
0B4E12 0B 
0B4E13 3E     0918* ld a,'.'	; print a dot to separate the values
0B4E14 2E 
0B4E15 5B     0919* rst.lil 10h
0B4E16 D7 
0B4E17 2A     0920* ld hl,(uhl)
0B4E18 49 
0B4E19 4E 
0B4E1A 0B 
0B4E1B CD     0921* call printHex24
0B4E1C 41 
0B4E1D 49 
0B4E1E 0B 
0B4E1F CD     0922* call printNewLine
0B4E20 36 
0B4E21 49 
0B4E22 0B 
              0923* 
              0924* ; restore everything
0B4E23 2A     0925* ld hl, (uhl)
0B4E24 49 
0B4E25 4E 
0B4E26 0B 
0B4E27 ED     0926* ld bc, (ubc)
0B4E28 4B 
0B4E29 4C 
0B4E2A 4E 
0B4E2A 0B   
0B4E2C ED     0927* ld de, (ude)
0B4E2D 5B 
0B4E2E 4F 
0B4E2F 4E 
0B4E2F 0B   
0B4E31 DD     0928* ld ix, (uix)
0B4E32 2A 
0B4E33 52 
0B4E34 4E 
0B4E34 0B   
0B4E36 FD     0929* ld iy, (uiy)
0B4E37 2A 
0B4E38 55 
0B4E39 4E 
0B4E39 0B   
0B4E3B F1     0930* pop af
              0931* ; all done
0B4E3C C9     0932* ret
              0933* 
0B4E3D 75     0934* str_udeuhl: db "ude.uhl=",0
0B4E3E 64 
0B4E3F 65 
0B4E40 2E 
0B4E40 75   
0B4E41 68 
0B4E42 6C 
0B4E43 3D 
0B4E43 00   
              0935* 
              0936* ; global scratch memory for registers
0B4E46 00     0937* uaf: dl 0
0B4E47 00 
0B4E48 00 
0B4E49 00     0938* uhl: dl 0
0B4E4A 00 
0B4E4B 00 
0B4E4C 00     0939* ubc: dl 0
0B4E4D 00 
0B4E4E 00 
0B4E4F 00     0940* ude: dl 0
0B4E50 00 
0B4E51 00 
0B4E52 00     0941* uix: dl 0
0B4E53 00 
0B4E54 00 
0B4E55 00     0942* uiy: dl 0
0B4E56 00 
0B4E57 00 
0B4E58 00     0943* usp: dl 0
0B4E59 00 
0B4E5A 00 
0B4E5B 00     0944* upc: dl 0
0B4E5C 00 
0B4E5D 00 
              0945* 
              0946* ; inputs: whatever is in the flags register
              0947* ; outputs: binary representation of flags
              0948* ;          with a header so we know which is what
              0949* ; destroys: nothing
              0950* ; preserves: everything
              0951* dumpFlags:
              0952* ; first we curse zilog for not giving direct access to flags
0B4E5E F5     0953* push af ; this is so we can send it back unharmed
0B4E5F F5     0954* push af ; this is so we can pop it to hl
              0955* ; store everything in scratch
0B4E60 22     0956* ld (uhl),hl
0B4E61 49 
0B4E62 4E 
0B4E63 0B 
0B4E64 ED     0957* ld (ubc),bc
0B4E65 43 
0B4E66 4C 
0B4E67 4E 
0B4E67 0B   
0B4E69 ED     0958* ld (ude),de
0B4E6A 53 
0B4E6B 4F 
0B4E6C 4E 
0B4E6C 0B   
0B4E6E DD     0959* ld (uix),ix
0B4E6F 22 
0B4E70 52 
0B4E71 4E 
0B4E71 0B   
0B4E73 FD     0960* ld (uiy),iy
0B4E74 22 
0B4E75 55 
0B4E76 4E 
0B4E76 0B   
              0961* ; next we print the header
0B4E78 21     0962* ld hl,@header
0B4E79 A4 
0B4E7A 4E 
0B4E7B 0B 
0B4E7C CD     0963* call printString
0B4E7D 21 
0B4E7E 49 
0B4E7F 0B 
0B4E80 E1     0964* pop hl ; flags are now in l
0B4E81 7D     0965* ld a,l ; flags are now in a
0B4E82 CD     0966* call printBin8
0B4E83 BF 
0B4E84 4B 
0B4E85 0B 
0B4E86 CD     0967* call printNewLine
0B4E87 36 
0B4E88 49 
0B4E89 0B 
              0968* ; restore everything
0B4E8A 2A     0969* ld hl, (uhl)
0B4E8B 49 
0B4E8C 4E 
0B4E8D 0B 
0B4E8E ED     0970* ld bc, (ubc)
0B4E8F 4B 
0B4E90 4C 
0B4E91 4E 
0B4E91 0B   
0B4E93 ED     0971* ld de, (ude)
0B4E94 5B 
0B4E95 4F 
0B4E96 4E 
0B4E96 0B   
0B4E98 DD     0972* ld ix, (uix)
0B4E99 2A 
0B4E9A 52 
0B4E9B 4E 
0B4E9B 0B   
0B4E9D FD     0973* ld iy, (uiy)
0B4E9E 2A 
0B4E9F 55 
0B4EA0 4E 
0B4EA0 0B   
0B4EA2 F1     0974* pop af ; send her home the way she came
0B4EA3 C9     0975* ret
              0976* ; Bit 7 (S): Sign flag
              0977* ; Bit 6 (Z): Zero flag
              0978* ; Bit 5 (5): Reserved (copy of bit 5 of the result)
              0979* ; Bit 4 (H): Half Carry flag
              0980* ; Bit 3 (3): Reserved (copy of bit 3 of the result)
              0981* ; Bit 2 (PV): Parity/Overflow flag
              0982* ; Bit 1 (N): Subtract flag
              0983* ; Bit 0 (C): Carry flag
0B4EA4 53     0984* @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
0B4EA5 5A 
0B4EA6 78 
0B4EA7 48 
0B4EA7 78   
0B4EA8 50 
0B4EA9 4E 
0B4EAA 43 
0B4EAA 0D   
0B4EAB 0A 
0B4EAC 00 
              0985* 
              0986* ; set all the bits in the flag register
              0987* ; more of an academic exercise than anything useful
              0988* ; inputs; none
              0989* ; outputs; a=0,f=255
              0990* ; destroys: flags, hl
              0991* ; preserves: a, because why not
              0992* setAllFlags:
0B4EAF 21     0993* ld hl,255
0B4EB0 FF 
0B4EB1 00 
0B4EB2 00 
0B4EB3 67     0994* ld h,a ; four cycles to preserve a is cheap
0B4EB4 E5     0995* push hl
0B4EB5 F1     0996* pop af
0B4EB6 C9     0997* ret
              0998* 
              0999* ; reset all the bits in the flag register
              1000* ; unlike its inverse counterpart, this may actually be useful
              1001* ; inputs; none
              1002* ; outputs; a=0,f=0
              1003* ; destroys: flags, hl
              1004* ; preserves: a, because why not
              1005* resetAllFlags:
0B4EB7 21     1006* ld hl,0
0B4EB8 00 
0B4EB9 00 
0B4EBA 00 
0B4EBB 67     1007* ld h,a ; four cycles to preserve a is cheap
0B4EBC E5     1008* push hl
0B4EBD F1     1009* pop af
0B4EBE C9     1010* ret
              1011* 
              1012* ; wait until user presses a key
              1013* ; inputs: none
              1014* ; outputs: none
              1015* ; destroys: af,ix
              1016* waitKeypress:
              1017* MOSCALL mos_sysvars
0B4EBF 3E    0001*M LD	A, function
0B4EC0 08 
0B4EC1 49    0002*M RST.LIS	08h
0B4EC2 CF 
0B4EC3 AF     1018* xor a ; zero out any prior keypresses
0B4EC4 DD     1019* ld (ix+sysvar_keyascii),a
0B4EC5 77 
0B4EC6 05 
              1020* @loop:
0B4EC7 DD     1021* ld a,(ix+sysvar_keyascii)
0B4EC8 7E 
0B4EC9 05 
0B4ECA A7     1022* and a
0B4ECB C0     1023* ret nz
0B4ECC 18     1024* jr @loop
0B4ECD F9 
              1025* 
              1026* 
              1027* ; print bytes from an address to the screen in hexidecimal format
              1028* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1029* ; outputs: values of each byte printed to screen separated by spaces
              1030* ; destroys: nothing
              1031* dumpMemoryHex:
              1032* ; save registers to the stack
0B4ECE C5     1033* push bc
0B4ECF E5     1034* push hl
0B4ED0 F5     1035* push af
              1036* 
              1037* ; print the address and separator
0B4ED1 CD     1038* call printHex24
0B4ED2 41 
0B4ED3 49 
0B4ED4 0B 
0B4ED5 3E     1039* ld a,':'
0B4ED6 3A 
0B4ED7 5B     1040* rst.lil 10h
0B4ED8 D7 
0B4ED9 3E     1041* ld a,' '
0B4EDA 20 
0B4EDB 5B     1042* rst.lil 10h
0B4EDC D7 
              1043* 
              1044* ; set b to be our loop counter
0B4EDD F1     1045* pop af
0B4EDE 47     1046* ld b,a
0B4EDF E1     1047* pop hl
0B4EE0 E5     1048* push hl
0B4EE1 F5     1049* push af
              1050* @loop:
              1051* ; print the byte
0B4EE2 7E     1052* ld a,(hl)
0B4EE3 CD     1053* call printHex8
0B4EE4 4F 
0B4EE5 49 
0B4EE6 0B 
              1054* ; print a space
0B4EE7 3E     1055* ld a,' '
0B4EE8 20 
0B4EE9 5B     1056* rst.lil 10h
0B4EEA D7 
0B4EEB 23     1057* inc hl
0B4EEC 10     1058* djnz @loop
0B4EED F4 
0B4EEE CD     1059* call printNewLine
0B4EEF 36 
0B4EF0 49 
0B4EF1 0B 
              1060* 
              1061* ; restore everything
0B4EF2 F1     1062* pop af
0B4EF3 E1     1063* pop hl
0B4EF4 C1     1064* pop bc
              1065* 
              1066* ; all done
0B4EF5 C9     1067* ret
              1068* 
              1069* 
              1070* ; print bytes from an address to the screen in binary format
              1071* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1072* ; outputs: values of each byte printed to screen separated by spaces
              1073* ; destroys: nothing
              1074* dumpMemoryBin:
              1075* ; save all registers to the stack
0B4EF6 F5     1076* push af
0B4EF7 C5     1077* push bc
0B4EF8 D5     1078* push de
0B4EF9 E5     1079* push hl
0B4EFA DD     1080* push ix
0B4EFB E5 
0B4EFC FD     1081* push iy
0B4EFD E5 
              1082* 
              1083* ; set b to be our loop counter
0B4EFE 47     1084* ld b,a
              1085* @loop:
              1086* ; print the byte
0B4EFF 7E     1087* ld a,(hl)
0B4F00 E5     1088* push hl
0B4F01 C5     1089* push bc
0B4F02 CD     1090* call printBin8
0B4F03 BF 
0B4F04 4B 
0B4F05 0B 
0B4F06 C1     1091* pop bc
              1092* ; print a space
0B4F07 3E     1093* ld a,' '
0B4F08 20 
0B4F09 5B     1094* rst.lil 10h
0B4F0A D7 
0B4F0B E1     1095* pop hl
0B4F0C 23     1096* inc hl
0B4F0D 10     1097* djnz @loop
0B4F0E F0 
0B4F0F CD     1098* call printNewLine
0B4F10 36 
0B4F11 49 
0B4F12 0B 
              1099* 
              1100* ; restore everything
0B4F13 FD     1101* pop iy
0B4F14 E1 
0B4F15 DD     1102* pop ix
0B4F16 E1 
0B4F17 E1     1103* pop hl
0B4F18 D1     1104* pop de
0B4F19 C1     1105* pop bc
0B4F1A F1     1106* pop af
              1107* ; all done
0B4F1B C9     1108* ret
              1109* 
              1110* ; print bytes from an address to the screen in binary format
              1111* ; with the bits of each byte in reverse order (lsb first)
              1112* ; inputs: hl = address of first byte to print, a = number of bytes to print
              1113* ; outputs: values of each byte printed to screen separated by spaces
              1114* ; destroys: nothing
              1115* dumpMemoryBinRev:
              1116* ; save all registers to the stack
0B4F1C F5     1117* push af
0B4F1D C5     1118* push bc
0B4F1E D5     1119* push de
0B4F1F E5     1120* push hl
0B4F20 DD     1121* push ix
0B4F21 E5 
0B4F22 FD     1122* push iy
0B4F23 E5 
              1123* 
              1124* ; set b to be our loop counter
0B4F24 47     1125* ld b,a
              1126* @loop:
              1127* ; print the byte
0B4F25 7E     1128* ld a,(hl)
0B4F26 E5     1129* push hl
0B4F27 C5     1130* push bc
0B4F28 CD     1131* call printBin8Rev
0B4F29 E4 
0B4F2A 4B 
0B4F2B 0B 
0B4F2C C1     1132* pop bc
              1133* ; print a space
0B4F2D 3E     1134* ld a,' '
0B4F2E 20 
0B4F2F 5B     1135* rst.lil 10h
0B4F30 D7 
0B4F31 E1     1136* pop hl
0B4F32 23     1137* inc hl
0B4F33 10     1138* djnz @loop
0B4F34 F0 
0B4F35 CD     1139* call printNewLine
0B4F36 36 
0B4F37 49 
0B4F38 0B 
              1140* 
              1141* ; restore everything
0B4F39 FD     1142* pop iy
0B4F3A E1 
0B4F3B DD     1143* pop ix
0B4F3C E1 
0B4F3D E1     1144* pop hl
0B4F3E D1     1145* pop de
0B4F3F C1     1146* pop bc
0B4F40 F1     1147* pop af
              1148* ; all done
0B4F41 C9     1149* ret
               0188 include "maths.inc"
              0001* ;------------------------------------------------------------------------
              0002* ; Scratch area for calculations
              0003* ;------------------------------------------------------------------------
0B4F42 00     0004* scratch1:	dw24	0	;bit manipulation buffer 1
0B4F43 00 
0B4F44 00 
0B4F45 00     0005* scratch2:	dw24	0	;bit manipulation buffer 2
0B4F46 00 
0B4F47 00 
              0006* 
              0007* ; absolute value of hlu
              0008* ; returns: abs(hlu), flags set according to the incoming sign of hlu:
              0009* ;         s1,z0,pv0,n1,c0 if hlu was negative
              0010* ;         s0,z1,pv0,n1,c0 if hlu was zero
              0011* ;         s0,z0,pv0,n1,c0 if hlu was positive
              0012* ; destroys: a
              0013* hlu_abs:
0B4F48 19     0014* add hl,de
0B4F49 B7     0015* or a
0B4F4A ED     0016* sbc hl,de
0B4F4B 52 
0B4F4C FA     0017* jp m,@is_neg
0B4F4D 51 
0B4F4E 4F 
0B4F4F 0B 
0B4F50 C9     0018* ret         ; hlu is positive or zero so we're done
              0019* @is_neg:
0B4F51 F5     0020* push af     ; otherwise, save current flags for return
0B4F52 CD     0021* call neg_hlu ; negate hlu
0B4F53 58 
0B4F54 4F 
0B4F55 0B 
0B4F56 F1     0022* pop af      ; get back flags
0B4F57 C9     0023* ret
              0024* 
              0025* ; flip the sign of hlu
              0026* ; inputs: hlu
              0027* ; returns: 0-hlu, flags set appropriately for the result:
              0028* ;         s1,z0,pv0,n1,c1 if result is negative
              0029* ;         s0,z1,pv0,n1,c0 if result is zero
              0030* ;         s0,z0,pv0,n1,c1 if result is positive
              0031* ; destroys a
              0032* neg_hlu:
0B4F58 D5     0033* push de     ; save de
0B4F59 EB     0034* ex de,hl    ; put hl into de
0B4F5A 21     0035* ld hl,0     ; clear hl
0B4F5B 00 
0B4F5C 00 
0B4F5D 00 
0B4F5E AF     0036* xor a       ; clear carry
0B4F5F ED     0037* sbc hl,de   ; 0-hlu = -hlu
0B4F60 52 
0B4F61 D1     0038* pop de      ; get de back
0B4F62 C9     0039* ret         ; easy peasy
              0040* 
              0041* ;------------------------------------------------------------------------
              0042* ; divide hlu by 2, inspired by above
              0043* ;------------------------------------------------------------------------
              0044* hlu_div2:
0B4F63 22     0045* ld		(scratch1),hl
0B4F64 42 
0B4F65 4F 
0B4F66 0B 
0B4F67 21     0046* ld		hl,scratch1+2
0B4F68 44 
0B4F69 4F 
0B4F6A 0B 
0B4F6B CB     0047* rr		(hl)
0B4F6C 1E 
0B4F6D 2B     0048* dec		hl
0B4F6E CB     0049* rr		(hl)
0B4F6F 1E 
0B4F70 2B     0050* dec		hl
0B4F71 CB     0051* rr		(hl)
0B4F72 1E 
0B4F73 23     0052* inc		hl
0B4F74 23     0053* inc		hl
0B4F75 2A     0054* ld hl,(scratch1)
0B4F76 42 
0B4F77 4F 
0B4F78 0B 
0B4F79 C9     0055* ret
              0056* 
              0057* ; this is my little hack to divide by 16
              0058* hlu_div16:
0B4F7A AF     0059* xor a
0B4F7B 29     0060* add hl,hl
0B4F7C 17     0061* rla
0B4F7D 29     0062* add hl,hl
0B4F7E 17     0063* rla
0B4F7F 29     0064* add hl,hl
0B4F80 17     0065* rla
0B4F81 29     0066* add hl,hl
0B4F82 17     0067* rla
0B4F83 22     0068* ld (@scratch),hl
0B4F84 90 
0B4F85 4F 
0B4F86 0B 
0B4F87 32     0069* ld (@scratch+3),a
0B4F88 93 
0B4F89 4F 
0B4F8A 0B 
0B4F8B 2A     0070* ld hl,(@scratch+1)
0B4F8C 91 
0B4F8D 4F 
0B4F8E 0B 
0B4F8F C9     0071* ret
              0072* @scratch: ds 4
              0073* 
              0074* ; hlu signed division by 256
              0075* ; returns: hlu / 256
              0076* ; destroys: af
              0077* hlu_sdiv256:
0B4F94 AF     0078* xor a ; assume hl is positive
0B4F95 22     0079* ld (@buffer),hl
0B4F96 AB 
0B4F97 4F 
0B4F98 0B 
              0080* sign_hlu
0B4F99 19    0001*M add hl,de
0B4F9A B7    0002*M or a
0B4F9B ED    0003*M sbc hl,de
0B4F9C 52 
0B4F9D F2     0081* jp p,@hl_pos
0B4F9E A2 
0B4F9F 4F 
0B4FA0 0B 
0B4FA1 3D     0082* dec a
              0083* @hl_pos:
0B4FA2 32     0084* ld (@buffer+3),a
0B4FA3 AE 
0B4FA4 4F 
0B4FA5 0B 
0B4FA6 2A     0085* ld hl,(@buffer+1)
0B4FA7 AC 
0B4FA8 4F 
0B4FA9 0B 
0B4FAA C9     0086* ret
              0087* @buffer: ds 4
              0088* 
              0089* ; hlu 1 byte right shift, unsigned
              0090* ; returns: hlu / 256, fractional portion in a
              0091* ; destroys: af
              0092* hlu_udiv256:
0B4FAF AF     0093* xor a
0B4FB0 32     0094* ld (@buffer+3),a
0B4FB1 C1 
0B4FB2 4F 
0B4FB3 0B 
0B4FB4 7D     0095* ld a,l ; save the fractional portion
0B4FB5 22     0096* ld (@buffer),hl
0B4FB6 BE 
0B4FB7 4F 
0B4FB8 0B 
0B4FB9 2A     0097* ld hl,(@buffer+1)
0B4FBA BF 
0B4FBB 4F 
0B4FBC 0B 
0B4FBD C9     0098* ret
              0099* @buffer: ds 4
              0100* 
              0101* MACRO hlu_mul256
              0102* add hl,hl ; * 2
              0103* add hl,hl ; * 4
              0104* add hl,hl ; * 8
              0105* add hl,hl ; * 16
              0106* add hl,hl ; * 32
              0107* add hl,hl ; * 64
              0108* add hl,hl ; * 128
              0109* add hl,hl ; * 256
              0110* ENDMACRO
              0111* 
              0112* ; compute the modulo of hlu by deu
              0113* ; outputs: hlu = hlu % deu
              0114* ; destroys: f, hl
              0115* hlu_mod:
0B4FC2 B7     0116* or a ; clear carry
              0117* @loop:
0B4FC3 ED     0118* sbc hl,de
0B4FC4 52 
0B4FC5 DA     0119* jp c, @end
0B4FC6 CD 
0B4FC7 4F 
0B4FC8 0B 
0B4FC9 C3     0120* jp @loop
0B4FCA C3 
0B4FCB 4F 
0B4FCC 0B 
              0121* @end:
0B4FCD 19     0122* add hl,de
0B4FCE C9     0123* ret
              0124* 
              0125* 
0B4FCF 00     0126* add_bcd_arg1: db #00,#00,#00,#00
0B4FD0 00 
0B4FD1 00 
0B4FD2 00 
0B4FD3 00     0127* add_bcd_arg2: db #00,#00,#00,#00
0B4FD4 00 
0B4FD5 00 
0B4FD6 00 
              0128* 
              0129* ; set bcd values in a scratch memory address from registers bcde
              0130* ; input: hl; scratch address,bcde; 8-place bcd number
              0131* ; destroys ; hl
              0132* set_bcd:
0B4FD7 73     0133* ld (hl),e
0B4FD8 23     0134* inc hl
0B4FD9 72     0135* ld (hl),d
0B4FDA 23     0136* inc hl
0B4FDB 71     0137* ld (hl),c
0B4FDC 23     0138* inc hl
0B4FDD 70     0139* ld (hl),b
0B4FDE C9     0140* ret
              0141* 
              0142* ; load bcd values from a scratch memory address to bcde
              0143* ; input: hl; scratch address
              0144* ; output: bcde; 8-place bcd number
              0145* ; destroys: hl
              0146* get_bcd:
0B4FDF 5E     0147* ld e,(hl)
0B4FE0 23     0148* inc hl
0B4FE1 56     0149* ld d,(hl)
0B4FE2 23     0150* inc hl
0B4FE3 4E     0151* ld c,(hl)
0B4FE4 23     0152* inc hl
0B4FE5 46     0153* ld b,(hl)
0B4FE6 C9     0154* ret
              0155* 
              0156* ; BCD addition
              0157* ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
              0158* ;       a is the number of bytes holding each number (number of places/2)
              0159* ; outputs: (hl) + (de) --> (hl)
              0160* ; destroys: a,b,de,hl
              0161* add_bcd:
0B4FE7 47     0162* ld b,a ; loop counter
0B4FE8 AF     0163* xor a ; reset a, clear carry flag
              0164* adcec:
0B4FE9 1A     0165* ld a,(de) ; addend to acc
0B4FEA 8E     0166* adc a,(hl) ; add (hl) to acc
0B4FEB 27     0167* daa ; adjust result to bcd
0B4FEC 77     0168* ld (hl),a ; store result
0B4FED 23     0169* inc hl ; advance memory pointers
0B4FEE 13     0170* inc de
0B4FEF 10     0171* djnz adcec ; loop until b == 0
0B4FF0 F8 
0B4FF1 C9     0172* ret
              0173* 
              0174* ; BCD subtraction
              0175* ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
              0176* ;       a is the number of bytes holding each number (number of places/2)
              0177* ; outputs: (hl) - (de) --> (hl)
              0178* ; destroys: a,b,de,hl
              0179* sub_bcd:
0B4FF2 47     0180* ld b,a ; loop counter
0B4FF3 AF     0181* xor a ; reset a,clear carry flag
              0182* subdec:
0B4FF4 1A     0183* ld a,(de) ; subtrahend to acc
0B4FF5 9E     0184* sbc a,(hl) ; subtract (hl) from acc
0B4FF6 27     0185* daa ; adjust result to bcd
0B4FF7 77     0186* ld (hl),a ; store result
0B4FF8 23     0187* inc hl ; advance memory pointers
0B4FF9 13     0188* inc de
0B4FFA 10     0189* djnz subdec ; loop until b == 0
0B4FFB F8 
0B4FFC C9     0190* ret
              0191* 
              0192* ; http://www.z80.info/pseudo-random.txt
              0193* rand_8:
0B4FFD C5     0194* push bc
0B4FFE 3A     0195* ld a,(r_seed)
0B4FFF 11 
0B5000 50 
0B5001 0B 
0B5002 4F     0196* ld c,a
              0197* 
0B5003 0F     0198* rrca ; multiply by 32
0B5004 0F     0199* rrca
0B5005 0F     0200* rrca
0B5006 EE     0201* xor 0x1f
0B5007 1F 
              0202* 
0B5008 81     0203* add a,c
0B5009 DE     0204* sbc a,255 ; carry
0B500A FF 
              0205* 
0B500B 32     0206* ld (r_seed),a
0B500C 11 
0B500D 50 
0B500E 0B 
0B500F C1     0207* pop bc
0B5010 C9     0208* ret
0B5011 50     0209* r_seed: defb $50
               0189 include "mathfpp.inc"
              0001* ; integer operations
              0002* iand:	EQU 58	; AND (INTEGER)
              0003* ibdiv:	EQU 59	; DIV
              0004* ieor:	EQU 60	; EOR
              0005* imod:	EQU 61	; MOD
              0006* ior:	EQU 62	; OR
              0007* ile:	EQU 63	; <=
              0008* ine:	EQU 64	; <>
              0009* ige:	EQU 65	; >=
              0010* ilt:	EQU 66	; <
              0011* ieq:	EQU 67	; =
              0012* imul:	EQU 68	; *
              0013* iadd:	EQU 69	; +
              0014* igt:	EQU 70	; >
              0015* isub:	EQU 71	; -
              0016* ipow:	EQU 72	; ^
              0017* idiv:	EQU 73	; /
              0018* ;
              0019* ; floating point functions
              0020* absv:	EQU 16	; ABS
              0021* acs:	EQU 17	; ACS
              0022* asn:	EQU 18	; ASN
              0023* atn:	EQU 19	; ATN
              0024* cos:	EQU 20	; COS
              0025* deg:	EQU 21	; DEG
              0026* exp:	EQU 22	; EXP
              0027* int_:	EQU 23	; INT
              0028* ln:	EQU 24	; LN
              0029* log:	EQU 25	; LOG
              0030* notk:	EQU 26	; NOT
              0031* rad:	EQU 27	; RAD
              0032* sgn:	EQU 28	; SGN
              0033* sin:	EQU 29	; SIN
              0034* sqr:	EQU 30	; SQR
              0035* tan:	EQU 31	; TAN
              0036* zero:	EQU 32	; ZERO
              0037* fone:	EQU 33	; FONE
              0038* true:	EQU 34	; TRUE
              0039* pi:	EQU 35	; PI
              0040* val:	EQU 36	; VAL
              0041* str:	EQU 37	; STR$
              0042* sfix:	EQU 38	; FIX
              0043* sfloat:	EQU 39	; FLOAT
              0044* ftest:	EQU 40	; TEST
              0045* fcomp:	EQU 41	; COMPARE
              0046* ;
              0047* ; floating point operations
              0048* fand:	EQU  0	; AND (FLOATING-POINT)
              0049* fbdiv:	EQU  1	; DIV
              0050* feor:	EQU  2	; EOR
              0051* fmod:	EQU  3	; MOD
              0052* ffor:	EQU  4	; OR
              0053* fle:	EQU  5	; <=
              0054* fne:	EQU  6	; <>
              0055* fge:	EQU  7	; >=
              0056* flt:	EQU  8	; <
              0057* feq:	EQU  9	; =
              0058* fmul:	EQU 10	; *
              0059* fadd:	EQU 11	; +
              0060* fgt:	EQU 12	; >
              0061* fsub:	EQU 13	; -
              0062* fpow:	EQU 14	; ^
              0063* fdiv:	EQU 15	; /
              0064* 
              0065* ; convert floating point number to integer and store it in HLU
              0066* ; inputs: HLH'L'C = floating point number
              0067* ; outputs: HLU = integer part of the number
              0068* ; destroys: all except DEU and U'D'E', index registers
              0069* int2hlu:
0B5012 3E     0070* ld a,int_
0B5013 17 
0B5014 CD     0071* call FPP
0B5015 2E 
0B5016 20 
0B5017 0B 
0B5018 7D     0072* ld a,l
0B5019 F5     0073* push af
0B501A D9     0074* exx
0B501B E5     0075* push hl
0B501C D9     0076* exx
0B501D E1     0077* pop hl
0B501E F1     0078* pop af
0B501F CD     0079* call A_TO_HLU
0B5020 0A 
0B5021 49 
0B5022 0B 
0B5023 C9     0080* ret
              0081* 
              0082* ; convert polar coordinates to cartesian coordinates as deltas from the origin
              0083* ; inputs: HLH'L'C = angle in radians
              0084* ;         DED'E'B = radius
              0085* ; outputs: HLH'L'C = dx
              0086* ;          DED'E'B = dy
              0087* polar_to_cartesian_fpp:
              0088* ; store input parameters in scratch
0B5024 FD     0089* ld iy,@angle
0B5025 21 
0B5026 7C 
0B5027 50 
0B5027 0B   
0B5029 CD     0090* call store_float_iy_nor
0B502A D3 
0B502B 50 
0B502C 0B 
0B502D FD     0091* ld iy,@radius
0B502E 21 
0B502F 81 
0B5030 50 
0B5030 0B   
0B5032 CD     0092* call store_float_iy_alt
0B5033 F7 
0B5034 50 
0B5035 0B 
              0093* ; compute dy = sin(angle) * radius
0B5036 3E     0094* ld a,sin
0B5037 1D 
0B5038 CD     0095* call FPP ; HLH'L'C = sin(angle)
0B5039 2E 
0B503A 20 
0B503B 0B 
0B503C FD     0096* ld iy,@radius
0B503D 21 
0B503E 81 
0B503F 50 
0B503F 0B   
0B5041 CD     0097* call fetch_float_iy_alt ; DED'E'B = radius
0B5042 09 
0B5043 51 
0B5044 0B 
0B5045 3E     0098* ld a,fmul
0B5046 0A 
0B5047 CD     0099* call FPP ; HLH'L'C = sin(angle) * radius
0B5048 2E 
0B5049 20 
0B504A 0B 
0B504B FD     0100* ld iy,@scratch
0B504C 21 
0B504D 86 
0B504E 50 
0B504E 0B   
0B5050 CD     0101* call store_float_iy_nor ; @scratch = dy
0B5051 D3 
0B5052 50 
0B5053 0B 
              0102* ; compute dx = cos(angle) * radius
0B5054 FD     0103* ld iy,@angle
0B5055 21 
0B5056 7C 
0B5057 50 
0B5057 0B   
0B5059 CD     0104* call fetch_float_iy_nor
0B505A E5 
0B505B 50 
0B505C 0B 
0B505D 3E     0105* ld a,cos
0B505E 14 
0B505F CD     0106* call FPP ; HLH'L'C = cos(angle)
0B5060 2E 
0B5061 20 
0B5062 0B 
0B5063 FD     0107* ld iy,@radius
0B5064 21 
0B5065 81 
0B5066 50 
0B5066 0B   
0B5068 CD     0108* call fetch_float_iy_alt ; DED'E'B = radius
0B5069 09 
0B506A 51 
0B506B 0B 
0B506C 3E     0109* ld a,fmul
0B506D 0A 
0B506E CD     0110* call FPP ; HLH'L'C = cos(angle) * radius
0B506F 2E 
0B5070 20 
0B5071 0B 
              0111* ; restore dy from @scratch
0B5072 FD     0112* ld iy,@scratch
0B5073 21 
0B5074 86 
0B5075 50 
0B5075 0B   
0B5077 CD     0113* call fetch_float_iy_alt
0B5078 09 
0B5079 51 
0B507A 0B 
0B507B C9     0114* ret
              0115* 
              0116* @angle: ds 5
              0117* @radius: ds 5
              0118* @scratch: ds 5
              0119* 
              0120* ; store HLH'L'C floating point number in a 40-bit buffer
              0121* ; inputs: HLH'L'C = floating point number
              0122* ;         ix = buffer address
              0123* ; outputs: buffer filled with floating point number
              0124* ; destroys: nothing
              0125* store_float_nor:
0B508B DD     0126* ld (ix+0),c
0B508C 71 
0B508D 00 
0B508E DD     0127* ld (ix+3),l
0B508F 75 
0B5090 03 
0B5091 DD     0128* ld (ix+4),h
0B5092 74 
0B5093 04 
0B5094 D9     0129* exx
0B5095 DD     0130* ld (ix+1),l
0B5096 75 
0B5097 01 
0B5098 DD     0131* ld (ix+2),h
0B5099 74 
0B509A 02 
0B509B D9     0132* exx
0B509C C9     0133* ret
              0134* 
              0135* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0136* ; inputs: ix = buffer address
              0137* ; outputs: HLH'L'C = floating point number
              0138* ; destroys: HLH'L'C
              0139* fetch_float_nor:
0B509D DD     0140* ld c,(ix+0)
0B509E 4E 
0B509F 00 
0B50A0 DD     0141* ld l,(ix+3)
0B50A1 6E 
0B50A2 03 
0B50A3 DD     0142* ld h,(ix+4)
0B50A4 66 
0B50A5 04 
0B50A6 D9     0143* exx
0B50A7 DD     0144* ld l,(ix+1)
0B50A8 6E 
0B50A9 01 
0B50AA DD     0145* ld h,(ix+2)
0B50AB 66 
0B50AC 02 
0B50AD D9     0146* exx
0B50AE C9     0147* ret
              0148* 
              0149* ; store DED'E'B floating point number in a 40-bit buffer
              0150* ; inputs: DED'E'B = floating point number
              0151* ;         ix = buffer address
              0152* ; outputs: buffer filled with floating point number
              0153* ; destroys: nothing
              0154* store_float_alt:
0B50AF DD     0155* ld (ix+0),b
0B50B0 70 
0B50B1 00 
0B50B2 DD     0156* ld (ix+3),e
0B50B3 73 
0B50B4 03 
0B50B5 DD     0157* ld (ix+4),d
0B50B6 72 
0B50B7 04 
0B50B8 D9     0158* exx
0B50B9 DD     0159* ld (ix+1),e
0B50BA 73 
0B50BB 01 
0B50BC DD     0160* ld (ix+2),d
0B50BD 72 
0B50BE 02 
0B50BF D9     0161* exx
0B50C0 C9     0162* ret
              0163* 
              0164* ; fetch DED'E'B floating point number from a 40-bit buffer
              0165* ; inputs: ix = buffer address
              0166* ; outputs: DED'E'B = floating point number
              0167* ; destroys: DED'E'B
              0168* fetch_float_alt:
0B50C1 DD     0169* ld b,(ix+0)
0B50C2 46 
0B50C3 00 
0B50C4 DD     0170* ld e,(ix+3)
0B50C5 5E 
0B50C6 03 
0B50C7 DD     0171* ld d,(ix+4)
0B50C8 56 
0B50C9 04 
0B50CA D9     0172* exx
0B50CB DD     0173* ld e,(ix+1)
0B50CC 5E 
0B50CD 01 
0B50CE DD     0174* ld d,(ix+2)
0B50CF 56 
0B50D0 02 
0B50D1 D9     0175* exx
0B50D2 C9     0176* ret
              0177* 
              0178* 
              0179* ; store HLH'L'C floating point number in a 40-bit buffer
              0180* ; inputs: HLH'L'C = floating point number
              0181* ;         iy = buffer address
              0182* ; outputs: buffer filled with floating point number
              0183* ; destroys: nothing
              0184* store_float_iy_nor:
0B50D3 FD     0185* ld (iy+0),c
0B50D4 71 
0B50D5 00 
0B50D6 FD     0186* ld (iy+3),l
0B50D7 75 
0B50D8 03 
0B50D9 FD     0187* ld (iy+4),h
0B50DA 74 
0B50DB 04 
0B50DC D9     0188* exx
0B50DD FD     0189* ld (iy+1),l
0B50DE 75 
0B50DF 01 
0B50E0 FD     0190* ld (iy+2),h
0B50E1 74 
0B50E2 02 
0B50E3 D9     0191* exx
0B50E4 C9     0192* ret
              0193* 
              0194* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0195* ; inputs: iy = buffer address
              0196* ; outputs: HLH'L'C = floating point number
              0197* ; destroys: HLH'L'C
              0198* fetch_float_iy_nor:
0B50E5 FD     0199* ld c,(iy+0)
0B50E6 4E 
0B50E7 00 
0B50E8 FD     0200* ld l,(iy+3)
0B50E9 6E 
0B50EA 03 
0B50EB FD     0201* ld h,(iy+4)
0B50EC 66 
0B50ED 04 
0B50EE D9     0202* exx
0B50EF FD     0203* ld l,(iy+1)
0B50F0 6E 
0B50F1 01 
0B50F2 FD     0204* ld h,(iy+2)
0B50F3 66 
0B50F4 02 
0B50F5 D9     0205* exx
0B50F6 C9     0206* ret
              0207* 
              0208* ; store DED'E'B floating point number in a 40-bit buffer
              0209* ; inputs: DED'E'B = floating point number
              0210* ;         iy = buffer address
              0211* ; outputs: buffer filled with floating point number
              0212* ; destroys: nothing
              0213* store_float_iy_alt:
0B50F7 FD     0214* ld (iy+0),b
0B50F8 70 
0B50F9 00 
0B50FA FD     0215* ld (iy+3),e
0B50FB 73 
0B50FC 03 
0B50FD FD     0216* ld (iy+4),d
0B50FE 72 
0B50FF 04 
0B5100 D9     0217* exx
0B5101 FD     0218* ld (iy+1),e
0B5102 73 
0B5103 01 
0B5104 FD     0219* ld (iy+2),d
0B5105 72 
0B5106 02 
0B5107 D9     0220* exx
0B5108 C9     0221* ret
              0222* 
              0223* ; fetch DED'E'B floating point number from a 40-bit buffer
              0224* ; inputs: iy = buffer address
              0225* ; outputs: DED'E'B = floating point number
              0226* ; destroys: DED'E'B
              0227* fetch_float_iy_alt:
0B5109 FD     0228* ld b,(iy+0)
0B510A 46 
0B510B 00 
0B510C FD     0229* ld e,(iy+3)
0B510D 5E 
0B510E 03 
0B510F FD     0230* ld d,(iy+4)
0B5110 56 
0B5111 04 
0B5112 D9     0231* exx
0B5113 FD     0232* ld e,(iy+1)
0B5114 5E 
0B5115 01 
0B5116 FD     0233* ld d,(iy+2)
0B5117 56 
0B5118 02 
0B5119 D9     0234* exx
0B511A C9     0235* ret
              0236* 
              0237* ; print HLH'L'C floating point number in hex format
              0238* ; inputs: HLH'L'C = floating point number
              0239* print_float_hex_nor:
              0240* PUSH_ALL
0B511B 08    0001*M ex af,af'
0B511C D9    0002*M exx
0B511D F5    0003*M push af
0B511E E5    0004*M push hl
0B511F C5    0005*M push bc
0B5120 D5    0006*M push de
             0007*M 
0B5121 08    0008*M ex af,af'
0B5122 D9    0009*M exx
0B5123 F5    0010*M push af
0B5124 E5    0011*M push hl
0B5125 C5    0012*M push bc
0B5126 D5    0013*M push de
0B5127 DD    0014*M push ix
0B5128 E5 
0B5129 FD    0015*M push iy
0B512A E5 
0B512B CD     0241* call printHex16
0B512C 49 
0B512D 49 
0B512E 0B 
0B512F 3E     0242* ld a,'.'
0B5130 2E 
0B5131 5B     0243* rst.lil 10h
0B5132 D7 
0B5133 D9     0244* exx
0B5134 CD     0245* call printHex16
0B5135 49 
0B5136 49 
0B5137 0B 
0B5138 D9     0246* exx
0B5139 3E     0247* ld a,'^'
0B513A 5E 
0B513B 5B     0248* rst.lil 10h
0B513C D7 
0B513D 79     0249* ld a,c
0B513E CD     0250* call printHex8
0B513F 4F 
0B5140 49 
0B5141 0B 
              0251* POP_ALL
0B5142 FD    0001*M pop iy
0B5143 E1 
0B5144 DD    0002*M pop ix
0B5145 E1 
0B5146 D1    0003*M pop de
0B5147 C1    0004*M pop bc
0B5148 E1    0005*M pop hl
0B5149 F1    0006*M pop af
0B514A 08    0007*M ex af,af'
0B514B D9    0008*M exx
             0009*M 
0B514C D1    0010*M pop de
0B514D C1    0011*M pop bc
0B514E E1    0012*M pop hl
0B514F F1    0013*M pop af
0B5150 08    0014*M ex af,af'
0B5151 D9    0015*M exx
0B5152 C9     0252* ret
              0253* 
              0254* ; print DED'E'B floating point number in hex format
              0255* ; inputs: DED'E'B = floating point number
              0256* print_float_hex_alt:
              0257* PUSH_ALL
0B5153 08    0001*M ex af,af'
0B5154 D9    0002*M exx
0B5155 F5    0003*M push af
0B5156 E5    0004*M push hl
0B5157 C5    0005*M push bc
0B5158 D5    0006*M push de
             0007*M 
0B5159 08    0008*M ex af,af'
0B515A D9    0009*M exx
0B515B F5    0010*M push af
0B515C E5    0011*M push hl
0B515D C5    0012*M push bc
0B515E D5    0013*M push de
0B515F DD    0014*M push ix
0B5160 E5 
0B5161 FD    0015*M push iy
0B5162 E5 
0B5163 EB     0258* ex de,hl
0B5164 CD     0259* call printHex16
0B5165 49 
0B5166 49 
0B5167 0B 
0B5168 EB     0260* ex de,hl
0B5169 3E     0261* ld a,'.'
0B516A 2E 
0B516B 5B     0262* rst.lil 10h
0B516C D7 
0B516D D9     0263* exx
0B516E EB     0264* ex de,hl
0B516F CD     0265* call printHex16
0B5170 49 
0B5171 49 
0B5172 0B 
0B5173 EB     0266* ex de,hl
0B5174 D9     0267* exx
0B5175 3E     0268* ld a,'^'
0B5176 5E 
0B5177 5B     0269* rst.lil 10h
0B5178 D7 
0B5179 78     0270* ld a,b
0B517A CD     0271* call printHex8
0B517B 4F 
0B517C 49 
0B517D 0B 
              0272* POP_ALL
0B517E FD    0001*M pop iy
0B517F E1 
0B5180 DD    0002*M pop ix
0B5181 E1 
0B5182 D1    0003*M pop de
0B5183 C1    0004*M pop bc
0B5184 E1    0005*M pop hl
0B5185 F1    0006*M pop af
0B5186 08    0007*M ex af,af'
0B5187 D9    0008*M exx
             0009*M 
0B5188 D1    0010*M pop de
0B5189 C1    0011*M pop bc
0B518A E1    0012*M pop hl
0B518B F1    0013*M pop af
0B518C 08    0014*M ex af,af'
0B518D D9    0015*M exx
0B518E C9     0273* ret
              0274* 
              0275* print_floats_hex:
0B518F CD     0276* call print_float_hex_nor
0B5190 1B 
0B5191 51 
0B5192 0B 
0B5193 3E     0277* ld a,' '
0B5194 20 
0B5195 5B     0278* rst.lil 10h
0B5196 D7 
0B5197 CD     0279* call print_float_hex_alt
0B5198 53 
0B5199 51 
0B519A 0B 
0B519B C9     0280* ret
              0281* 
              0282* ; print a floating point number in decimal format
              0283* ; inputs: HL'H'L'C is the number to print
              0284* ; outputs: number printed to screen
              0285* ;          ACCS null-terminated string representation of the number
              0286* ; destroys: everything except ix
              0287* print_float_dec:
              0288* print_float_dec_nor:
0B519C DD     0289* push ix             ; preserve
0B519D E5 
              0290* 
              0291* ; back up floats in normal and alternate registers
0B519E DD     0292* ld ix,@float_nor
0B519F 21 
0B51A0 DF 
0B51A1 51 
0B51A1 0B   
0B51A3 CD     0293* call store_float_nor
0B51A4 8B 
0B51A5 50 
0B51A6 0B 
0B51A7 DD     0294* ld ix,@float_alt
0B51A8 21 
0B51A9 E4 
0B51AA 51 
0B51AA 0B   
0B51AC CD     0295* call store_float_alt
0B51AD AF 
0B51AE 50 
0B51AF 0B 
              0296* 
              0297* ; convert the number to a string
0B51B0 11     0298* ld de,ACCS          ; point to the string accumulator
0B51B1 00 
0B51B2 5B 
0B51B3 0B 
0B51B4 DD     0299* ld ix,@G9-1         ; get the format code for the number
0B51B5 21 
0B51B6 DC 
0B51B7 51 
0B51B7 0B   
0B51B9 CD     0300* call STR_FP         ; convert the number to a string
0B51BA 2D 
0B51BB 28 
0B51BC 0B 
0B51BD EB     0301* ex de,hl            ; point to end of the string
0B51BE 36     0302* ld (hl),0           ; null-terminate the string
0B51BF 00 
0B51C0 21     0303* ld hl,ACCS          ; point to the string accumulator
0B51C1 00 
0B51C2 5B 
0B51C3 0B 
0B51C4 CD     0304* call printString
0B51C5 21 
0B51C6 49 
0B51C7 0B 
              0305* 
              0306* ; restore floats in normal and alternate registers
0B51C8 DD     0307* ld ix,@float_nor
0B51C9 21 
0B51CA DF 
0B51CB 51 
0B51CB 0B   
0B51CD CD     0308* call fetch_float_nor
0B51CE 9D 
0B51CF 50 
0B51D0 0B 
0B51D1 DD     0309* ld ix,@float_alt
0B51D2 21 
0B51D3 E4 
0B51D4 51 
0B51D4 0B   
0B51D6 CD     0310* call fetch_float_alt
0B51D7 C1 
0B51D8 50 
0B51D9 0B 
              0311* 
              0312* ; cleanup and go home
0B51DA DD     0313* pop ix              ; restore
0B51DB E1 
0B51DC C9     0314* ret
0B51DD 09     0315* @G9:			DW    9
0B51DE 00 
              0316* @float_nor: ds 5
              0317* @float_alt: ds 5
              0318* 
              0319* print_float_dec_alt:
0B51E9 CD     0320* CALL SWAP
0B51EA 9B 
0B51EB 08 
0B51EC 0B 
0B51ED CD     0321* CALL print_float_dec_nor
0B51EE 9C 
0B51EF 51 
0B51F0 0B 
0B51F1 CD     0322* CALL SWAP
0B51F2 9B 
0B51F3 08 
0B51F4 0B 
0B51F5 C9     0323* ret
              0324* 
              0325* ;PI - Return PI (3.14159265)
              0326* ;Result is floating-point numeric.
              0327* ;
0B51F6 11     0328* pi_alt:			LD      DE,0x490F
0B51F7 0F 
0B51F8 49 
0B51F9 00 
0B51FA D9     0329* EXX
0B51FB 11     0330* LD      DE,0xDAA2
0B51FC A2 
0B51FD DA 
0B51FE 00 
0B51FF D9     0331* EXX
0B5200 06     0332* LD      B,0x81
0B5201 81 
0B5202 AF     0333* XOR     A               ;NUMERIC MARKER
0B5203 C9     0334* RET
              0335* 
              0336* ;PI - Return PI * 2 (6.28318531)
              0337* ;Result is floating-point numeric.
              0338* ;
0B5204 11     0339* pi2_alt:		LD      DE,0x490F
0B5205 0F 
0B5206 49 
0B5207 00 
0B5208 D9     0340* EXX
0B5209 11     0341* LD      DE,0xDAA3
0B520A A3 
0B520B DA 
0B520C 00 
0B520D D9     0342* EXX
0B520E 06     0343* LD      B,0x82
0B520F 82 
0B5210 AF     0344* XOR     A               ;NUMERIC MARKER
0B5211 C9     0345* RET
               0190 include "vdu.inc"
              0001* 
              0002* ; VDU 30: Home cursor
              0003* vdu_home_cursor:
0B5212 3E     0004* ld a,30
0B5213 1E 
0B5214 5B     0005* rst.lil $10
0B5215 D7 
0B5216 C9     0006* ret
              0007* 
              0008* cursor_on:
0B5217 21     0009* ld hl,@cmd
0B5218 22 
0B5219 52 
0B521A 0B 
0B521B 01     0010* ld bc,@end-@cmd
0B521C 03 
0B521D 00 
0B521E 00 
0B521F 5B     0011* rst.lil $18
0B5220 DF 
0B5221 C9     0012* ret
              0013* @cmd:
0B5222 17     0014* db 23,1,1
0B5223 01 
0B5224 01 
              0015* @end:
              0016* 
              0017* cursor_off:
0B5225 21     0018* ld hl,@cmd
0B5226 30 
0B5227 52 
0B5228 0B 
0B5229 01     0019* ld bc,@end-@cmd
0B522A 03 
0B522B 00 
0B522C 00 
0B522D 5B     0020* rst.lil $18
0B522E DF 
0B522F C9     0021* ret
              0022* @cmd:
0B5230 17     0023* db 23,1,0
0B5231 01 
0B5232 00 
              0024* @end:
              0025* 
              0026* ; VDU 9: Move cursor forward one character
              0027* vdu_cursor_forward:
0B5233 3E     0028* ld a,9
0B5234 09 
0B5235 5B     0029* rst.lil $10
0B5236 D7 
0B5237 C9     0030* ret
              0031* 
              0032* ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
              0033* ; inputs: c=x, b=y 8-bit unsigned integers
              0034* vdu_move_cursor:
0B5238 ED     0035* ld (@x0),bc
0B5239 43 
0B523A 49 
0B523B 52 
0B523B 0B   
0B523D 21     0036* ld hl,@cmd
0B523E 48 
0B523F 52 
0B5240 0B 
0B5241 01     0037* ld bc,@end-@cmd
0B5242 03 
0B5243 00 
0B5244 00 
0B5245 5B     0038* rst.lil $18
0B5246 DF 
0B5247 C9     0039* ret
0B5248 1F     0040* @cmd: 	db 31
0B5249 00     0041* @x0:	db 0
0B524A 00     0042* @y0: 	db 0
0B524B 00     0043* @end: 	db 0 ; padding
              0044* 
              0045* ; VDU 12: Clear text area (CLS)
              0046* vdu_cls:
0B524C 3E     0047* ld a,12
0B524D 0C 
0B524E 5B     0048* rst.lil $10
0B524F D7 
0B5250 C9     0049* ret
              0050* 
              0051* vdu_flip:
0B5251 21     0052* ld hl,@cmd
0B5252 5C 
0B5253 52 
0B5254 0B 
0B5255 01     0053* ld bc,@end-@cmd
0B5256 03 
0B5257 00 
0B5258 00 
0B5259 5B     0054* rst.lil $18
0B525A DF 
0B525B C9     0055* ret
0B525C 17     0056* @cmd: db 23,0,0xC3
0B525D 00 
0B525E C3 
              0057* @end:
              0058* 
              0059* ; VDU 16: Clear graphics area (CLG)
              0060* vdu_clg:
0B525F 3E     0061* ld a,16
0B5260 10 
0B5261 5B     0062* rst.lil $10
0B5262 D7 
0B5263 C9     0063* ret
              0064* 
              0065* ; COLOUR MODES
              0066* ; Mode	Effect
              0067* ; 0	Set on-screen pixel to target colour value
              0068* ; 1	OR value with the on-screen pixel
              0069* ; 2	AND value with the on-screen pixel
              0070* ; 3	XOR value with the on-screen pixel
              0071* ; 4	Invert the on-screen pixel
              0072* ; 5	No operation
              0073* ; 6	AND the inverse of the specified colour with the on-screen pixel
              0074* ; 7	OR the inverse of the specified colour with the on-screen pixel
              0075* 
              0076* ; VDU 17, colour: Define text colour (COLOUR)
              0077* vdu_colour_text:
0B5264 32     0078* ld (@arg),a
0B5265 74 
0B5266 52 
0B5267 0B 
0B5268 21     0079* ld hl,@cmd
0B5269 73 
0B526A 52 
0B526B 0B 
0B526C 01     0080* ld bc,@end-@cmd
0B526D 02 
0B526E 00 
0B526F 00 
0B5270 5B     0081* rst.lil $18
0B5271 DF 
0B5272 C9     0082* ret
0B5273 11     0083* @cmd: db 17
0B5274 00     0084* @arg: db 0
              0085* @end:
              0086* 
              0087* ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
              0088* ; inputs: a=mode, c=colour (add 128 to set background colour)
              0089* vdu_gcol:
0B5275 32     0090* ld (@mode),a
0B5276 8A 
0B5277 52 
0B5278 0B 
0B5279 79     0091* ld a,c
0B527A 32     0092* ld (@col),a
0B527B 8B 
0B527C 52 
0B527D 0B 
0B527E 21     0093* ld hl,@cmd
0B527F 89 
0B5280 52 
0B5281 0B 
0B5282 01     0094* ld bc,@end-@cmd
0B5283 03 
0B5284 00 
0B5285 00 
0B5286 5B     0095* rst.lil $18
0B5287 DF 
0B5288 C9     0096* ret
0B5289 12     0097* @cmd:  db 18
0B528A 00     0098* @mode: db 0
0B528B 00     0099* @col:  db 0
              0100* @end:
              0101* 
              0102* 
              0103* ; VDU 28, left, bottom, right, top: Set text viewport **
              0104* ; MIND THE LITTLE-ENDIANESS
              0105* ; inputs: c=left,b=bottom,e=right,d=top
              0106* ; outputs; nothing
              0107* ; destroys: a might make it out alive
              0108* vdu_set_txt_viewport:
0B528C ED     0109* ld (@lb),bc
0B528D 43 
0B528E A2 
0B528F 52 
0B528F 0B   
0B5291 ED     0110* ld (@rt),de
0B5292 53 
0B5293 A4 
0B5294 52 
0B5294 0B   
0B5296 21     0111* ld hl,@cmd
0B5297 A1 
0B5298 52 
0B5299 0B 
0B529A 01     0112* ld bc,@end-@cmd
0B529B 05 
0B529C 00 
0B529D 00 
0B529E 5B     0113* rst.lil $18
0B529F DF 
0B52A0 C9     0114* ret
0B52A1 1C     0115* @cmd:   db 28 ; set text viewport command
0B52A2 00     0116* @lb: 	dw 0x0000 ; set by bc
0B52A3 00 
0B52A4 00     0117* @rt: 	dw 0x0000 ; set by de
0B52A5 00 
0B52A6 00     0118* @end:   db 0x00	  ; padding
              0119* 
              0120* ; Wait for VBLANK interrupt
              0121* vdu_vblank:
0B52A7 DD     0122* PUSH 	IX
0B52A8 E5 
              0123* MOSCALL	mos_sysvars
0B52A9 3E    0001*M LD	A, function
0B52AA 08 
0B52AB 49    0002*M RST.LIS	08h
0B52AC CF 
0B52AD DD     0124* LD	A, (IX + sysvar_time + 0)
0B52AE 7E 
0B52AF 00 
              0125* @wait:
0B52B0 DD     0126* CP 	A, (IX + sysvar_time + 0)
0B52B1 BE 
0B52B2 00 
0B52B3 28     0127* JR	Z, @wait
0B52B4 FB 
0B52B5 DD     0128* POP	IX
0B52B6 E1 
0B52B7 C9     0129* RET
              0130* 
              0131* ; VDU 29, x; y;: Set graphics origin
              0132* ; This command sets the graphics origin.
              0133* ; The origin is the point on the screen where the coordinates (0,0) are located.
              0134* ; inputs: bc=x0,de=y0
              0135* ; outputs; nothing
              0136* ; destroys: a might make it out alive
              0137* vdu_set_gfx_origin:
0B52B8 ED     0138* ld (@x0),bc
0B52B9 43 
0B52BA CE 
0B52BB 52 
0B52BB 0B   
0B52BD ED     0139* ld (@y0),de
0B52BE 53 
0B52BF D0 
0B52C0 52 
0B52C0 0B   
0B52C2 21     0140* ld hl,@cmd
0B52C3 CD 
0B52C4 52 
0B52C5 0B 
0B52C6 01     0141* ld bc,@end-@cmd
0B52C7 05 
0B52C8 00 
0B52C9 00 
0B52CA 5B     0142* rst.lil $18
0B52CB DF 
0B52CC C9     0143* ret
0B52CD 1D     0144* @cmd:   db 29 ; set graphics origin command
0B52CE 00     0145* @x0: 	dw 0x0000 ; set by bc
0B52CF 00 
0B52D0 00     0146* @y0: 	dw 0x0000 ; set by de
0B52D1 00 
0B52D2 00     0147* @end:   db 0x00	  ; padding
              0148* 
              0149* ; VDU 24, left; bottom; right; top;: Set graphics viewport
              0150* ; NOTE: the order of the y-coordinate parameters are inverted
              0151* ; 	because we have turned off logical screen scaling
              0152* ; inputs: bc=x0,de=y0,ix=x1,iy=y1
              0153* ; outputs; nothing
              0154* ; destroys: a might make it out alive
              0155* vdu_set_gfx_viewport:
0B52D3 ED     0156* ld (@x0),bc
0B52D4 43 
0B52D5 F3 
0B52D6 52 
0B52D6 0B   
0B52D8 FD     0157* ld (@y1),iy
0B52D9 22 
0B52DA F5 
0B52DB 52 
0B52DB 0B   
0B52DD DD     0158* ld (@x1),ix
0B52DE 22 
0B52DF F7 
0B52E0 52 
0B52E0 0B   
0B52E2 ED     0159* ld (@y0),de
0B52E3 53 
0B52E4 F9 
0B52E5 52 
0B52E5 0B   
0B52E7 21     0160* ld hl,@cmd
0B52E8 F2 
0B52E9 52 
0B52EA 0B 
0B52EB 01     0161* ld bc,@end-@cmd
0B52EC 09 
0B52ED 00 
0B52EE 00 
0B52EF 5B     0162* rst.lil $18
0B52F0 DF 
0B52F1 C9     0163* ret
0B52F2 18     0164* @cmd:   db 24 ; set graphics viewport command
0B52F3 00     0165* @x0: 	dw 0x0000 ; set by bc
0B52F4 00 
0B52F5 00     0166* @y1: 	dw 0x0000 ; set by iy
0B52F6 00 
0B52F7 00     0167* @x1: 	dw 0x0000 ; set by ix
0B52F8 00 
0B52F9 00     0168* @y0: 	dw 0x0000 ; set by de
0B52FA 00 
0B52FB 00     0169* @end:   db 0x00	  ; padding
              0170* 
              0171* ; SCREEN MODES
              0172* ; ===============================
              0173* ; Mode  Horz  Vert  Cols  Refresh
              0174* ; ---   ----  ----  ----  -------
              0175* ; 11    320   240   2     60hz
              0176* ; 139   320   240   2     60hz
              0177* ; 23    512   384   2     60hz
              0178* ; 151   512   384   2     60hz
              0179* ; 6     640   240   2     60hz
              0180* ; 134   640   240   2     60hz
              0181* ; 2     640   480   2     60hz
              0182* ; 130   640   480   2     60hz
              0183* ; 17    800   600   2     60hz
              0184* ; 145   800   600   2     60hz
              0185* ; 18    1024  768   2     60hz
              0186* ; 146   1024  768   2     60hz
              0187* ; ---   ----  ----  ----  -------
              0188* ; 10    320   240   4     60hz
              0189* ; 138   320   240   4     60hz
              0190* ; 22    512   384   4     60hz
              0191* ; 150   512   384   4     60hz
              0192* ; 5     640   240   4     60hz
              0193* ; 133   640   240   4     60hz
              0194* ; 1     640   480   4     60hz
              0195* ; 129   640   480   4     60hz
              0196* ; 16    800   600   4     60hz
              0197* ; 19    1024  768   4     60hz
              0198* ; ---   ----  ----  ----  -------
              0199* ; 9     320   240   16    60hz
              0200* ; 137   320   240   16    60hz
              0201* ; 21    512   384   16    60hz
              0202* ; 149   512   384   16    60hz
              0203* ; 4     640   240   16    60hz
              0204* ; 132   640   240   16    60hz
              0205* ; 0     640   480   16    60hz
              0206* ; 7     n/a   n/a   16    60hz
              0207* ; ---   ----  ----  ----  -------
              0208* ; 8     320   240   64    60hz
              0209* ; 136   320   240   64    60hz
              0210* ; 20    512   384   64    60hz
              0211* ; 3     640   240   64    60hz
              0212* ; ---   ----  ----  ----  -------
              0213* vdu_set_screen_mode:
0B52FC 32     0214* ld (@arg),a
0B52FD 0C 
0B52FE 53 
0B52FF 0B 
0B5300 21     0215* ld hl,@cmd
0B5301 0B 
0B5302 53 
0B5303 0B 
0B5304 01     0216* ld bc,@end-@cmd
0B5305 02 
0B5306 00 
0B5307 00 
0B5308 5B     0217* rst.lil $18
0B5309 DF 
0B530A C9     0218* ret
0B530B 16     0219* @cmd: db 22 ; set screen mode
0B530C 00     0220* @arg: db 0  ; screen mode parameter
              0221* @end:
              0222* 
              0223* ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
              0224* ; inputs: a is scaling mode, 1=on, 0=off
              0225* ; note: default setting on boot is scaling ON
              0226* vdu_set_scaling:
0B530D 32     0227* ld (@arg),a
0B530E 1F 
0B530F 53 
0B5310 0B 
0B5311 21     0228* ld hl,@cmd
0B5312 1C 
0B5313 53 
0B5314 0B 
0B5315 01     0229* ld bc,@end-@cmd
0B5316 04 
0B5317 00 
0B5318 00 
0B5319 5B     0230* rst.lil $18
0B531A DF 
0B531B C9     0231* ret
0B531C 17     0232* @cmd: db 23,0,0xC0
0B531D 00 
0B531E C0 
0B531F 00     0233* @arg: db 0  ; scaling on/off
              0234* @end:
              0235* 
              0236* ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
              0237* ; inputs: hl=bufferId
              0238* vdu_buff_select:
0B5320 22     0239* ld (@bufferId),hl
0B5321 32 
0B5322 53 
0B5323 0B 
0B5324 21     0240* ld hl,@cmd
0B5325 2F 
0B5326 53 
0B5327 0B 
0B5328 01     0241* ld bc,@end-@cmd
0B5329 05 
0B532A 00 
0B532B 00 
0B532C 5B     0242* rst.lil $18
0B532D DF 
0B532E C9     0243* ret
0B532F 17     0244* @cmd: db 23,27,0x20
0B5330 1B 
0B5331 20 
0B5332 00     0245* @bufferId: dw 0x0000
0B5333 00 
0B5334 00     0246* @end: db 0x00 ; padding
              0247* 
              0248* ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
              0249* ; inputs: a=format; bc=width; de=height
              0250* ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
              0251* ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
              0252* ; 0 	RGBA8888 (4-bytes per pixel)
              0253* ; 1 	RGBA2222 (1-bytes per pixel)
              0254* ; 2 	Mono/Mask (1-bit per pixel)
              0255* ; 3 	Reserved for internal use by VDP (“native” format)
              0256* vdu_bmp_create:
0B5335 ED     0257* ld (@width),bc
0B5336 43 
0B5337 51 
0B5338 53 
0B5338 0B   
0B533A ED     0258* ld (@height),de
0B533B 53 
0B533C 53 
0B533D 53 
0B533D 0B   
0B533F 32     0259* ld (@fmt),a
0B5340 55 
0B5341 53 
0B5342 0B 
0B5343 21     0260* ld hl,@cmd
0B5344 4E 
0B5345 53 
0B5346 0B 
0B5347 01     0261* ld bc,@end-@cmd
0B5348 08 
0B5349 00 
0B534A 00 
0B534B 5B     0262* rst.lil $18
0B534C DF 
0B534D C9     0263* ret
0B534E 17     0264* @cmd:       db 23,27,0x21
0B534F 1B 
0B5350 21 
0B5351 00     0265* @width:     dw 0x0000
0B5352 00 
0B5353 00     0266* @height:    dw 0x0000
0B5354 00 
0B5355 00     0267* @fmt:       db 0x00
              0268* @end:
              0269* 
              0270* ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
              0271* ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
              0272* vdu_load_img_rgba2_to_8:
              0273* ; backup the target buffer id and image dimensions
0B5356 E5     0274* push hl
0B5357 D5     0275* push de
0B5358 C5     0276* push bc
              0277* ; load the rgba2 image to working buffer 65534
0B5359 21     0278* ld hl,65534 ; temporary working buffer id
0B535A FE 
0B535B FF 
0B535C 00 
0B535D CD     0279* call vdu_load_buffer_from_file
0B535E 60 
0B535F 54 
0B5360 0B 
              0280* ; restore the image dimensions and target buffer id
0B5361 C1     0281* pop bc
0B5362 D1     0282* pop de
0B5363 E1     0283* pop hl
              0284* ; fall through to vdu_rgba2_to_8
              0285* 
              0286* ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
              0287* ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
              0288* ; the "expand bitmap" command is:
              0289* ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
              0290* ; and then to reverse the byte order to fix endian-ness:
              0291* ; VDU 23,0,&A0,targetBufferID%;24,4,4;
              0292* ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
              0293* ; VDU 23,27,&20,targetBufferID%;
              0294* ; VDU 23,27,&21,width%;height%;0
              0295* ; -------------------------------------------------------------------
              0296* ; inputs: bc,de image width,height ; hl = targetBufferId
              0297* ; prerequisites: rgba2 image data loaded into workingBufferId 65534
              0298* vdu_rgba2_to_8:
              0299* ; load the image dimensions and buffer id parameters
0B5364 ED     0300* ld (@width),bc
0B5365 43 
0B5366 C0 
0B5367 53 
0B5367 0B   
0B5369 ED     0301* ld (@height),de
0B536A 53 
0B536B C2 
0B536C 53 
0B536C 0B   
0B536E 22     0302* ld (@bufferId0),hl
0B536F A5 
0B5370 53 
0B5371 0B 
0B5372 22     0303* ld (@bufferId2),hl
0B5373 B2 
0B5374 53 
0B5375 0B 
0B5376 22     0304* ld (@bufferId1),hl
0B5377 BB 
0B5378 53 
0B5379 0B 
              0305* ; clean up bytes that got stomped on by the ID loads
0B537A 3E     0306* ld a,0x48
0B537B 48 
0B537C 32     0307* ld (@bufferId0+2),a
0B537D A7 
0B537E 53 
0B537F 0B 
0B5380 3E     0308* ld a,23
0B5381 17 
0B5382 32     0309* ld (@bufferId1+2),a
0B5383 BD 
0B5384 53 
0B5385 0B 
0B5386 3E     0310* ld a,24
0B5387 18 
0B5388 32     0311* ld (@bufferId2+2),a
0B5389 B4 
0B538A 53 
0B538B 0B 
0B538C AF     0312* xor a
0B538D 32     0313* ld (@height+2),a
0B538E C4 
0B538F 53 
0B5390 0B 
              0314* ; send the vdu command strings
0B5391 21     0315* ld hl,@beg
0B5392 9C 
0B5393 53 
0B5394 0B 
0B5395 01     0316* ld bc,@end-@beg
0B5396 29 
0B5397 00 
0B5398 00 
0B5399 5B     0317* rst.lil $18
0B539A DF 
0B539B C9     0318* ret
              0319* @beg:
              0320* ; Command 14: Consolidate blocks in a buffer
              0321* ; VDU 23, 0, &A0, bufferId; 14
0B539C 17     0322* db 23,0,0xA0
0B539D 00 
0B539E A0 
0B539F FE     0323* dw 65534 ; workingBufferId
0B53A0 FF 
0B53A1 0E     0324* db 14 ; consolidate blocks
              0325* ; the "expand bitmap" command is:
              0326* ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B53A2 17     0327* db 23,0,0xA0
0B53A3 00 
0B53A4 A0 
0B53A5 00     0328* @bufferId0: dw 0x0000 ; targetBufferId
0B53A6 00 
0B53A7 48     0329* db 0x48 ; given as decimal command 72 in the docs
0B53A8 02     0330* db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B53A9 FE     0331* dw 65534 ; sourceBufferId
0B53AA FF 
0B53AB 00     0332* db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B53AC 7F 
0B53AD BF 
0B53AE FF 
              0333* ; reverse the byte order to fix endian-ness:
              0334* ; Command 24: Reverse the order of data of blocks within a buffer
              0335* ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
              0336* ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B53AF 17     0337* db 23,0,0xA0
0B53B0 00 
0B53B1 A0 
0B53B2 00     0338* @bufferId2:    dw 0x0000 ; targetBufferId
0B53B3 00 
0B53B4 18     0339* db 24 ; reverse byte order
0B53B5 04     0340* db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B53B6 04     0341* dw 4 ; size (4 bytes)
0B53B7 00 
              0342* ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
              0343* ; VDU 23,27,&20,targetBufferID%;
0B53B8 17     0344* db 23,27,0x20 ; select bitmap
0B53B9 1B 
0B53BA 20 
0B53BB 00     0345* @bufferId1: dw 0x0000 ; targetBufferId
0B53BC 00 
              0346* ; VDU 23,27,&21,width%;height%;0
0B53BD 17     0347* db 23,27,0x21 ; create bitmap from buffer
0B53BE 1B 
0B53BF 21 
0B53C0 00     0348* @width: dw 0x0000
0B53C1 00 
0B53C2 00     0349* @height: dw 0x0000
0B53C3 00 
0B53C4 00     0350* db 0x00 ; rgba8888 format
              0351* @end:
              0352* 
              0353* ; scratch variables
0B53C5 00     0354* bufferId0: dl 0x000000
0B53C6 00 
0B53C7 00 
0B53C8 00     0355* bufferId1: dl 0x000000
0B53C9 00 
0B53CA 00 
              0356* 
              0357* ; load a vdu buffer from local memory
              0358* ; inputs: hl = bufferId ; bc = length ; de = pointer to data
              0359* vdu_load_buffer:
0B53CB ED     0360* ld (@length),bc
0B53CC 43 
0B53CD F4 
0B53CE 53 
0B53CE 0B   
0B53D0 D5     0361* push de ; save data pointer
              0362* ; send the vdu command string
0B53D1 7D     0363* ld a,l
0B53D2 32     0364* ld (@bufferId),a
0B53D3 F1 
0B53D4 53 
0B53D5 0B 
0B53D6 7C     0365* ld a,h
0B53D7 32     0366* ld (@bufferId+1),a
0B53D8 F2 
0B53D9 53 
0B53DA 0B 
0B53DB 21     0367* ld hl,@cmd
0B53DC EE 
0B53DD 53 
0B53DE 0B 
0B53DF 01     0368* ld bc,@end-@cmd
0B53E0 08 
0B53E1 00 
0B53E2 00 
0B53E3 5B     0369* rst.lil $18
0B53E4 DF 
              0370* ; send the buffer data
0B53E5 E1     0371* pop hl ; pointer to data
0B53E6 ED     0372* ld bc,(@length)
0B53E7 4B 
0B53E8 F4 
0B53E9 53 
0B53E9 0B   
0B53EB 5B     0373* rst.lil $18 ; send it
0B53EC DF 
0B53ED C9     0374* ret
              0375* ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B53EE 17     0376* @cmd:       db 23,0,0xA0
0B53EF 00 
0B53F0 A0 
0B53F1 00     0377* @bufferId:	dw 0x0000
0B53F2 00 
0B53F3 00     0378* db 0 ; load buffer
0B53F4 00     0379* @length:	dw 0x0000
0B53F5 00 
0B53F6 00     0380* @end: db 0 ; padding
              0381* 
              0382* ; clear a buffer
              0383* ; inputs: hl = bufferId
              0384* vdu_clear_buffer:
0B53F7 7D     0385* ld a,l
0B53F8 32     0386* ld (@bufferId),a
0B53F9 0F 
0B53FA 54 
0B53FB 0B 
0B53FC 7C     0387* ld a,h
0B53FD 32     0388* ld (@bufferId+1),a
0B53FE 10 
0B53FF 54 
0B5400 0B 
0B5401 21     0389* ld hl,@cmd
0B5402 0C 
0B5403 54 
0B5404 0B 
0B5405 01     0390* ld bc,@end-@cmd
0B5406 06 
0B5407 00 
0B5408 00 
0B5409 5B     0391* rst.lil $18
0B540A DF 
0B540B C9     0392* ret
0B540C 17     0393* @cmd:       db 23,0,0xA0
0B540D 00 
0B540E A0 
0B540F 00     0394* @bufferId:	dw 0x0000
0B5410 00 
0B5411 02     0395* db 2 ; clear buffer
              0396* @end:
              0397* 
              0398* vdu_clear_all_buffers:
              0399* ; clear all buffers
0B5412 21     0400* ld hl,@beg
0B5413 1D 
0B5414 54 
0B5415 0B 
0B5416 01     0401* ld bc,@end-@beg
0B5417 06 
0B5418 00 
0B5419 00 
0B541A 5B     0402* rst.lil $18
0B541B DF 
0B541C C9     0403* ret
0B541D 17     0404* @beg: db 23,0,$A0
0B541E 00 
0B541F A0 
0B5420 FF     0405* dw -1 ; clear all buffers
0B5421 FF 
0B5422 02     0406* db 2  ; command 2: clear a buffer
              0407* @end:
              0408* 
              0409* ; Command 14: Consolidate blocks in a buffer
              0410* vdu_consolidate_buffer:
              0411* ; set parameters for vdu call
0B5423 7D     0412* ld a,l
0B5424 32     0413* ld (@bufferId),a
0B5425 3B 
0B5426 54 
0B5427 0B 
0B5428 7C     0414* ld a,h
0B5429 32     0415* ld (@bufferId+1),a
0B542A 3C 
0B542B 54 
0B542C 0B 
0B542D 21     0416* ld hl,@beg
0B542E 38 
0B542F 54 
0B5430 0B 
0B5431 01     0417* ld bc,@end-@beg
0B5432 06 
0B5433 00 
0B5434 00 
0B5435 5B     0418* rst.lil $18
0B5436 DF 
0B5437 C9     0419* ret
              0420* ; VDU 23, 0, &A0, bufferId; 14
0B5438 17     0421* @beg: db 23,0,0xA0
0B5439 00 
0B543A A0 
0B543B 00     0422* @bufferId: dw 0x0000
0B543C 00 
0B543D 0E     0423* db 14
              0424* @end:
              0425* 
              0426* ; load an image file to a buffer and make it a bitmap
              0427* ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
              0428* vdu_load_img:
              0429* ; back up image type and dimension parameters
0B543E 22     0430* ld (bufferId0),hl
0B543F C5 
0B5440 53 
0B5441 0B 
0B5442 F5     0431* push af
0B5443 C5     0432* push bc
0B5444 D5     0433* push de
              0434* ; load the image
0B5445 CD     0435* call vdu_load_buffer_from_file
0B5446 60 
0B5447 54 
0B5448 0B 
              0436* ; now make it a bitmap
0B5449 2A     0437* ld hl,(bufferId0)
0B544A C5 
0B544B 53 
0B544C 0B 
0B544D CD     0438* call vdu_consolidate_buffer
0B544E 23 
0B544F 54 
0B5450 0B 
0B5451 2A     0439* ld hl,(bufferId0)
0B5452 C5 
0B5453 53 
0B5454 0B 
0B5455 CD     0440* call vdu_buff_select
0B5456 20 
0B5457 53 
0B5458 0B 
0B5459 D1     0441* pop de ; image height
0B545A C1     0442* pop bc ; image width
0B545B F1     0443* pop af ; image type
0B545C C3     0444* jp vdu_bmp_create ; will return to caller from there
0B545D 35 
0B545E 53 
0B545F 0B 
              0445* 
              0446* ; inputs: hl = bufferId; iy = pointer to filename
              0447* vdu_load_buffer_from_file:
0B5460 22     0448* ld (bufferId0),hl
0B5461 C5 
0B5462 53 
0B5463 0B 
              0449* 
              0450* ; clear target buffer
0B5464 CD     0451* call vdu_clear_buffer
0B5465 F7 
0B5466 53 
0B5467 0B 
              0452* 
              0453* ; open the file in read mode
              0454* ; Open a file
              0455* ; HLU: Filename
              0456* ;   C: Mode
              0457* ; Returns:
              0458* ;   A: Filehandle, or 0 if couldn't open
0B5468 FD     0459* push iy ; pointer to filename
0B5469 E5 
0B546A E1     0460* pop hl
0B546B 0E     0461* ld c,fa_read
0B546C 01 
              0462* MOSCALL mos_fopen
0B546D 3E    0001*M LD	A, function
0B546E 0A 
0B546F 49    0002*M RST.LIS	08h
0B5470 CF 
0B5471 32     0463* ld (@filehandle),a
0B5472 AC 
0B5473 54 
0B5474 0B 
              0464* 
              0465* @read_file:
              0466* ; Read a block of data from a file
              0467* ;   C: Filehandle
              0468* ; HLU: Pointer to where to write the data to
              0469* ; DEU: Number of bytes to read
              0470* ; Returns:
              0471* ; DEU: Number of bytes read
0B5475 3A     0472* ld a,(@filehandle)
0B5476 AC 
0B5477 54 
0B5478 0B 
0B5479 4F     0473* ld c,a
0B547A 21     0474* ld hl,filedata
0B547B 00 
0B547C E0 
0B547D B7 
0B547E 11     0475* ld de,8192 ; max we can read into onboard sram at one time
0B547F 00 
0B5480 20 
0B5481 00 
              0476* MOSCALL mos_fread
0B5482 3E    0001*M LD	A, function
0B5483 1A 
0B5484 49    0002*M RST.LIS	08h
0B5485 CF 
              0477* 
              0478* ; ; DEBUG: print chunk size
              0479* ;     push de
              0480* ;     pop hl
              0481* ;     call printDec
              0482* ;     call printNewLine
              0483* 
              0484* ; test de for zero bytes read
0B5486 21     0485* ld hl,0
0B5487 00 
0B5488 00 
0B5489 00 
0B548A AF     0486* xor a ; clear carry
0B548B ED     0487* sbc hl,de
0B548C 52 
0B548D CA     0488* jp z,@close_file
0B548E A3 
0B548F 54 
0B5490 0B 
              0489* 
              0490* ; load a vdu buffer from local memory
              0491* ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B5491 2A     0492* ld hl,(bufferId0)
0B5492 C5 
0B5493 53 
0B5494 0B 
0B5495 D5     0493* push de ; chunksize
0B5496 C1     0494* pop bc
0B5497 11     0495* ld de,filedata
0B5498 00 
0B5499 E0 
0B549A B7 
0B549B CD     0496* call vdu_load_buffer
0B549C CB 
0B549D 53 
0B549E 0B 
              0497* 
              0498* ; ; print progress breadcrumbs
              0499* ;     ld a,'.'
              0500* ;     rst.lil 10h
              0501* 
              0502* ; read the next block
0B549F C3     0503* jp @read_file
0B54A0 75 
0B54A1 54 
0B54A2 0B 
              0504* 
              0505* ; close the file
              0506* @close_file:
0B54A3 3A     0507* ld a,(@filehandle)
0B54A4 AC 
0B54A5 54 
0B54A6 0B 
              0508* MOSCALL mos_fclose
0B54A7 3E    0001*M LD	A, function
0B54A8 0B 
0B54A9 49    0002*M RST.LIS	08h
0B54AA CF 
0B54AB C9     0509* ret ; vdu_load_buffer_from_file
              0510* 
0B54AC 00     0511* @filehandle: db 0 ; file handle
0B54AD 00     0512* @fil: dl 0 ; pointer to FIL struct
0B54AE 00 
0B54AF 00 
              0513* 
0B54B0 00     0514* @chunkpointer: dl 0 ; pointer to current chunk
0B54B1 00 
0B54B2 00 
              0515* 
              0516* ; File information structure (FILINFO)
              0517* @filinfo:
0B54B3 00     0518* @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B54B4 00 
0B54B5 00 
0B54B6 00 
0B54B7 00     0519* @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B54B8 00 
0B54B9 00     0520* @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B54BA 00 
0B54BB 00     0521* @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B54BC 00     0522* @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
0B54BD 00 
0B54BE 00 
0B54BF 00 
0B54BF 00   
0B54C0 00 
0B54C1 00 
0B54C2 00 
0B54C2 00   
0B54C3 00 
0B54C4 00 
0B54C5 00 
0B54C5 00   
0B54C9 00     0523* @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
0B54CA 00 
0B54CB 00 
0B54CC 00 
0B54CC 00   
0B54CD 00 
0B54CE 00 
0B54CF 00 
0B54CF 00   
0B54D0 00 
0B54D1 00 
0B54D2 00 
0B54D2 00   
0B54D3 00 
0B54D4 00 
0B54D5 00 
0B54D5 00   
0B54D6 00 
0B54D7 00 
0B54D8 00 
0B54D8 00   
0B54D9 00 
0B54DA 00 
0B54DB 00 
0B54DB 00   
0B54DC 00 
0B54DD 00 
0B54DE 00 
0B54DE 00   
0B54DF 00 
0B54E0 00 
0B54E1 00 
0B54E1 00   
0B54E2 00 
0B54E3 00 
0B54E4 00 
0B54E4 00   
0B54E5 00 
0B54E6 00 
0B54E7 00 
0B54E7 00   
0B54E8 00 
0B54E9 00 
0B54EA 00 
0B54EA 00   
0B54EB 00 
0B54EC 00 
0B54ED 00 
0B54ED 00   
0B54EE 00 
0B54EF 00 
0B54F0 00 
0B54F0 00   
0B54F1 00 
0B54F2 00 
0B54F3 00 
0B54F3 00   
0B54F4 00 
0B54F5 00 
0B54F6 00 
0B54F6 00   
0B54F7 00 
0B54F8 00 
0B54F9 00 
0B54F9 00   
0B54FA 00 
0B54FB 00 
0B54FC 00 
0B54FC 00   
0B54FD 00 
0B54FE 00 
0B54FF 00 
0B54FF 00   
0B5500 00 
0B5501 00 
0B5502 00 
0B5502 00   
0B5503 00 
0B5504 00 
0B5505 00 
0B5505 00   
0B5506 00 
0B5507 00 
0B5508 00 
0B5508 00   
0B5509 00 
0B550A 00 
0B550B 00 
0B550B 00   
0B550C 00 
0B550D 00 
0B550E 00 
0B550E 00   
0B550F 00 
0B5510 00 
0B5511 00 
0B5511 00   
0B5512 00 
0B5513 00 
0B5514 00 
0B5514 00   
0B5515 00 
0B5516 00 
0B5517 00 
0B5517 00   
0B5518 00 
0B5519 00 
0B551A 00 
0B551A 00   
0B551B 00 
0B551C 00 
0B551D 00 
0B551D 00   
0B551E 00 
0B551F 00 
0B5520 00 
0B5520 00   
0B5521 00 
0B5522 00 
0B5523 00 
0B5523 00   
0B5524 00 
0B5525 00 
0B5526 00 
0B5526 00   
0B5527 00 
0B5528 00 
0B5529 00 
0B5529 00   
0B552A 00 
0B552B 00 
0B552C 00 
0B552C 00   
0B552D 00 
0B552E 00 
0B552F 00 
0B552F 00   
0B5530 00 
0B5531 00 
0B5532 00 
0B5532 00   
0B5533 00 
0B5534 00 
0B5535 00 
0B5535 00   
0B5536 00 
0B5537 00 
0B5538 00 
0B5538 00   
0B5539 00 
0B553A 00 
0B553B 00 
0B553B 00   
0B553C 00 
0B553D 00 
0B553E 00 
0B553E 00   
0B553F 00 
0B5540 00 
0B5541 00 
0B5541 00   
0B5542 00 
0B5543 00 
0B5544 00 
0B5544 00   
0B5545 00 
0B5546 00 
0B5547 00 
0B5547 00   
0B5548 00 
0B5549 00 
0B554A 00 
0B554A 00   
0B554B 00 
0B554C 00 
0B554D 00 
0B554D 00   
0B554E 00 
0B554F 00 
0B5550 00 
0B5550 00   
0B5551 00 
0B5552 00 
0B5553 00 
0B5553 00   
0B5554 00 
0B5555 00 
0B5556 00 
0B5556 00   
0B5557 00 
0B5558 00 
0B5559 00 
0B5559 00   
0B555A 00 
0B555B 00 
0B555C 00 
0B555C 00   
0B555D 00 
0B555E 00 
0B555F 00 
0B555F 00   
0B5560 00 
0B5561 00 
0B5562 00 
0B5562 00   
0B5563 00 
0B5564 00 
0B5565 00 
0B5565 00   
0B5566 00 
0B5567 00 
0B5568 00 
0B5568 00   
0B5569 00 
0B556A 00 
0B556B 00 
0B556B 00   
0B556C 00 
0B556D 00 
0B556E 00 
0B556E 00   
0B556F 00 
0B5570 00 
0B5571 00 
0B5571 00   
0B5572 00 
0B5573 00 
0B5574 00 
0B5574 00   
0B5575 00 
0B5576 00 
0B5577 00 
0B5577 00   
0B5578 00 
0B5579 00 
0B557A 00 
0B557A 00   
0B557B 00 
0B557C 00 
0B557D 00 
0B557D 00   
0B557E 00 
0B557F 00 
0B5580 00 
0B5580 00   
0B5581 00 
0B5582 00 
0B5583 00 
0B5583 00   
0B5584 00 
0B5585 00 
0B5586 00 
0B5586 00   
0B5587 00 
0B5588 00 
0B5589 00 
               0191 include "vdu_plot.inc"
              0001* ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
              0002* ; PLOT code 	(Decimal) 	Effect
              0003* ; &00-&07 	0-7 	Solid line, includes both ends
              0004* plot_sl_both: equ 0x00
              0005* 
              0006* ; &08-&0F 	8-15 	Solid line, final point omitted
              0007* plot_sl_first: equ 0x08
              0008* 
              0009* ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
              0010* ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
              0011* 
              0012* ; &20-&27 	32-39 	Solid line, first point omitted
              0013* plot_sl_last: equ 0x20
              0014* 
              0015* ; &28-&2F 	40-47 	Solid line, both points omitted
              0016* plot_sl_none: equ 0x28
              0017* 
              0018* ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
              0019* ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
              0020* 
              0021* ; &40-&47 	64-71 	Point plot
              0022* plot_pt: equ 0x40
              0023* 
              0024* ; &48-&4F 	72-79 	Line fill left and right to non-background §§
              0025* plot_lf_lr_non_bg: equ 0x48
              0026* 
              0027* ; &50-&57 	80-87 	Triangle fill
              0028* plot_tf: equ 0x50
              0029* 
              0030* ; &58-&5F 	88-95 	Line fill right to background §§
              0031* plot_lf_r_bg: equ 0x58
              0032* 
              0033* ; &60-&67 	96-103 	Rectangle fill
              0034* plot_rf: equ 0x60
              0035* 
              0036* ; &68-&6F 	104-111 	Line fill left and right to foreground §§
              0037* plot_lf_lr_fg: equ 0x60
              0038* 
              0039* ; &70-&77 	112-119 	Parallelogram fill
              0040* plot_pf: equ 0x70
              0041* 
              0042* ; &78-&7F 	120-127 	Line fill right to non-foreground §§
              0043* plot_lf_r_non_fg: equ 0x78
              0044* 
              0045* ; &80-&87 	128-135 	Not supported (Flood until non-background)
              0046* ; &88-&8F 	136-143 	Not supported (Flood until foreground)
              0047* 
              0048* ; &90-&97 	144-151 	Circle outline
              0049* plot_co: equ 0x90
              0050* 
              0051* ; &98-&9F 	152-159 	Circle fill
              0052* plot_cf: equ 0x98
              0053* 
              0054* ; &A0-&A7 	160-167 	Not supported (Circular arc)
              0055* ; &A8-&AF 	168-175 	Not supported (Circular segment)
              0056* ; &B0-&B7 	176-183 	Not supported (Circular sector)
              0057* 
              0058* ; &B8-&BF 	184-191 	Rectangle copy/move
              0059* plot_rcm: equ 0xB8
              0060* 
              0061* ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
              0062* ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
              0063* ; &D0-&D7 	208-215 	Not defined
              0064* ; &D8-&DF 	216-223 	Not defined
              0065* ; &E0-&E7 	224-231 	Not defined
              0066* 
              0067* ; &E8-&EF 	232-239 	Bitmap plot §
              0068* plot_bmp: equ 0xE8
              0069* 
              0070* ; &F0-&F7 	240-247 	Not defined
              0071* ; &F8-&FF 	248-255 	Not defined
              0072* 
              0073* ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
              0074* ; Agon Console8 VDP 2.2.0
              0075* 
              0076* ; Within each group of eight plot codes, the effects are as follows:
              0077* ; Plot code 	Effect
              0078* ; 0 	Move relative
              0079* mv_rel: equ 0
              0080* 
              0081* ; 1 	Plot relative in current foreground colour
              0082* dr_rel_fg: equ 1
              0083* 
              0084* ; 2 	Not supported (Plot relative in logical inverse colour)
              0085* ; 3 	Plot relative in current background colour
              0086* dr_rel_bg: equ 3
              0087* 
              0088* ; 4 	Move absolute
              0089* mv_abs: equ 4
              0090* 
              0091* ; 5 	Plot absolute in current foreground colour
              0092* dr_abs_fg: equ 5
              0093* 
              0094* ; 6 	Not supported (Plot absolute in logical inverse colour)
              0095* ; 7 	Plot absolute in current background colour
              0096* dr_abs_bg: equ 7
              0097* 
              0098* ; Codes 0-3 use the position data provided as part of the command
              0099* ; as a relative position, adding the position given to the current
              0100* ; graphical cursor position. Codes 4-7 use the position data provided
              0101* ; as part of the command as an absolute position, setting the current
              0102* ; graphical cursor position to the position given.
              0103* 
              0104* ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
              0105* ; current pixel colour. These operations cannot currently be supported
              0106* ; by the graphics system the Agon VDP uses, so these codes are not
              0107* ; supported. Support for these codes may be added in a future version
              0108* ; of the VDP firmware.
              0109* 
              0110* ; 16 colour palette constants
              0111* c_black: equ 0
              0112* c_red_dk: equ 1
              0113* c_green_dk: equ 2
              0114* c_yellow_dk: equ 3
              0115* c_blue_dk: equ 4
              0116* c_magenta_dk: equ 5
              0117* c_cyan_dk: equ 6
              0118* c_grey: equ 7
              0119* c_grey_dk: equ 8
              0120* c_red: equ 9
              0121* c_green: equ 10
              0122* c_yellow: equ 11
              0123* c_blue: equ 12
              0124* c_magenta: equ 13
              0125* c_cyan: equ 14
              0126* c_white: equ 15
              0127* 
              0128* ; VDU 25, mode, x; y;: PLOT command
              0129* ; inputs: a=mode, bc=x0, de=y0
              0130* vdu_plot:
0B55C9 32     0131* ld (@mode),a
0B55CA E3 
0B55CB 55 
0B55CC 0B 
0B55CD ED     0132* ld (@x0),bc
0B55CE 43 
0B55CF E4 
0B55D0 55 
0B55D0 0B   
0B55D2 ED     0133* ld (@y0),de
0B55D3 53 
0B55D4 E6 
0B55D5 55 
0B55D5 0B   
0B55D7 21     0134* ld hl,@cmd
0B55D8 E2 
0B55D9 55 
0B55DA 0B 
0B55DB 01     0135* ld bc,@end-@cmd
0B55DC 06 
0B55DD 00 
0B55DE 00 
0B55DF 5B     0136* rst.lil $18
0B55E0 DF 
0B55E1 C9     0137* ret
0B55E2 19     0138* @cmd:   db 25
0B55E3 00     0139* @mode:  db 0
0B55E4 00     0140* @x0: 	dw 0
0B55E5 00 
0B55E6 00     0141* @y0: 	dw 0
0B55E7 00 
0B55E8 00     0142* @end:   db 0 ; extra byte to soak up deu
              0143* 
              0144* ; VDU 25, mode, x; y;: PLOT command
              0145* ; USING 16.8 FIXED POINT COORDINATES
              0146* ; inputs: a=mode, ub.c=x0, ud.e=y0
              0147* vdu_plot_168:
0B55E9 ED     0148* ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
0B55EA 53 
0B55EB 05 
0B55EC 56 
0B55EC 0B   
0B55EE ED     0149* ld (@x0-1),bc ; integer portion only
0B55EF 43 
0B55F0 03 
0B55F1 56 
0B55F1 0B   
0B55F3 32     0150* ld (@mode),a  ; load this order b/c we shifted bc right
0B55F4 03 
0B55F5 56 
0B55F6 0B 
0B55F7 21     0151* ld hl,@cmd
0B55F8 02 
0B55F9 56 
0B55FA 0B 
0B55FB 01     0152* ld bc,@end-@cmd
0B55FC 06 
0B55FD 00 
0B55FE 00 
0B55FF 5B     0153* rst.lil $18
0B5600 DF 
              0154* ; ld hl,@cmd
              0155* ; ld a,6
              0156* ; call dumpMemoryHex
              0157* ; call printNewLine
0B5601 C9     0158* ret
0B5602 19     0159* @cmd:   db 25
0B5603 00     0160* @mode:  db 0
0B5604 00     0161* @x0: 	dw 0
0B5605 00 
0B5606 00     0162* @y0: 	dw 0
0B5607 00 
              0163* @end:  ; no padding required b/c we shifted de right
              0164* 
              0165* ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
              0166* ; &E8-&EF 	232-239 	Bitmap plot §
              0167* ; VDU 25, mode, x; y;: PLOT command
              0168* ; inputs: bc=x0, de=y0
              0169* ; prerequisites: vdu_buff_select
              0170* vdu_plot_bmp:
0B5608 ED     0171* ld (@x0),bc
0B5609 43 
0B560A 1F 
0B560B 56 
0B560B 0B   
0B560D ED     0172* ld (@y0),de
0B560E 53 
0B560F 21 
0B5610 56 
0B5610 0B   
0B5612 21     0173* ld hl,@cmd
0B5613 1D 
0B5614 56 
0B5615 0B 
0B5616 01     0174* ld bc,@end-@cmd
0B5617 06 
0B5618 00 
0B5619 00 
0B561A 5B     0175* rst.lil $18
0B561B DF 
0B561C C9     0176* ret
0B561D 19     0177* @cmd:   db 25
0B561E ED     0178* @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B561F 00     0179* @x0: 	dw 0x0000
0B5620 00 
0B5621 00     0180* @y0: 	dw 0x0000
0B5622 00 
0B5623 00     0181* @end:   db 0x00 ; padding
              0182* 
              0183* ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
              0184* ; &E8-&EF 	232-239 	Bitmap plot §
              0185* ; VDU 25, mode, x; y;: PLOT command
              0186* ; inputs: bc=x0, de=y0
              0187* ; USING 16.8 FIXED POINT COORDINATES
              0188* ; inputs: ub.c is x coordinate, ud.e is y coordinate
              0189* ;   the fractional portiion of the inputs are truncated
              0190* ;   leaving only the 16-bit integer portion
              0191* ; prerequisites: vdu_buff_select
              0192* vdu_plot_bmp168:
              0193* ; populate in the reverse of normal to keep the
              0194* ; inputs from stomping on each other
0B5624 ED     0195* ld (@y0-1),de
0B5625 53 
0B5626 42 
0B5627 56 
0B5627 0B   
0B5629 ED     0196* ld (@x0-1),bc
0B562A 43 
0B562B 40 
0B562C 56 
0B562C 0B   
0B562E 3E     0197* ld a,plot_bmp+dr_abs_fg ; 0xED
0B562F ED 
0B5630 32     0198* ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B5631 40 
0B5632 56 
0B5633 0B 
0B5634 21     0199* ld hl,@cmd
0B5635 3F 
0B5636 56 
0B5637 0B 
0B5638 01     0200* ld bc,@end-@cmd
0B5639 06 
0B563A 00 
0B563B 00 
0B563C 5B     0201* rst.lil $18
0B563D DF 
0B563E C9     0202* ret
0B563F 19     0203* @cmd:   db 25
0B5640 ED     0204* @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B5641 00     0205* @x0: 	dw 0x0000
0B5642 00 
0B5643 00     0206* @y0: 	dw 0x0000
0B5644 00 
              0207* @end:  ; no padding required b/c we shifted de right
              0208* 
              0209* ; draw a filled rectangle
              0210* vdu_plot_rf:
0B5645 ED     0211* ld (@x0),bc
0B5646 43 
0B5647 6C 
0B5648 56 
0B5648 0B   
0B564A ED     0212* ld (@y0),de
0B564B 53 
0B564C 6E 
0B564D 56 
0B564D 0B   
0B564F DD     0213* ld (@x1),ix
0B5650 22 
0B5651 72 
0B5652 56 
0B5652 0B   
0B5654 FD     0214* ld (@y1),iy
0B5655 22 
0B5656 74 
0B5657 56 
0B5657 0B   
0B5659 3E     0215* ld a,25 ; we have to reload the 2nd plot command
0B565A 19 
0B565B 32     0216* ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B565C 70 
0B565D 56 
0B565E 0B 
0B565F 21     0217* ld hl,@cmd0
0B5660 6A 
0B5661 56 
0B5662 0B 
0B5663 01     0218* ld bc,@end-@cmd0
0B5664 0C 
0B5665 00 
0B5666 00 
0B5667 5B     0219* rst.lil $18
0B5668 DF 
0B5669 C9     0220* ret
0B566A 19     0221* @cmd0:  db 25 ; plot
0B566B 04     0222* @arg0:  db plot_sl_both+mv_abs
0B566C 00     0223* @x0:    dw 0x0000
0B566D 00 
0B566E 00     0224* @y0:    dw 0x0000
0B566F 00 
0B5670 19     0225* @cmd1:  db 25 ; plot
0B5671 65     0226* @arg1:  db plot_rf+dr_abs_fg
0B5672 00     0227* @x1:    dw 0x0000
0B5673 00 
0B5674 00     0228* @y1:    dw 0x0000
0B5675 00 
0B5676 00     0229* @end:   db 0x00 ; padding
              0230* 
              0231* ; draw a filled circle
              0232* vdu_plot_cf:
0B5677 ED     0233* ld (@x0),bc
0B5678 43 
0B5679 9E 
0B567A 56 
0B567A 0B   
0B567C ED     0234* ld (@y0),de
0B567D 53 
0B567E A0 
0B567F 56 
0B567F 0B   
0B5681 DD     0235* ld (@x1),ix
0B5682 22 
0B5683 A4 
0B5684 56 
0B5684 0B   
0B5686 FD     0236* ld (@y1),iy
0B5687 22 
0B5688 A6 
0B5689 56 
0B5689 0B   
0B568B 3E     0237* ld a,25 ; we have to reload the 2nd plot command
0B568C 19 
0B568D 32     0238* ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B568E A2 
0B568F 56 
0B5690 0B 
0B5691 21     0239* ld hl,@cmd0
0B5692 9C 
0B5693 56 
0B5694 0B 
0B5695 01     0240* ld bc,@end-@cmd0
0B5696 0C 
0B5697 00 
0B5698 00 
0B5699 5B     0241* rst.lil $18
0B569A DF 
0B569B C9     0242* ret
0B569C 19     0243* @cmd0:  db 25 ; plot
0B569D 04     0244* @arg0:  db plot_sl_both+mv_abs
0B569E 00     0245* @x0:    dw 0x0000
0B569F 00 
0B56A0 00     0246* @y0:    dw 0x0000
0B56A1 00 
0B56A2 19     0247* @cmd1:  db 25 ; plot
0B56A3 9D     0248* @arg1:  db plot_cf+dr_abs_fg
0B56A4 00     0249* @x1:    dw 0x0000
0B56A5 00 
0B56A6 00     0250* @y1:    dw 0x0000
0B56A7 00 
0B56A8 00     0251* @end:   db 0x00 ; padding
              0252* 
              0253* ; VDU 25, mode, x; y;: PLOT command
              0254* ; inputs: a=mode, ix=x0, iy=y0
              0255* plot:
0B56A9 32     0256* ld (@mode),a
0B56AA C3 
0B56AB 56 
0B56AC 0B 
0B56AD DD     0257* ld (@x0),ix
0B56AE 22 
0B56AF C4 
0B56B0 56 
0B56B0 0B   
0B56B2 FD     0258* ld (@y0),iy
0B56B3 22 
0B56B4 C6 
0B56B5 56 
0B56B5 0B   
0B56B7 21     0259* ld hl,@cmd
0B56B8 C2 
0B56B9 56 
0B56BA 0B 
0B56BB 01     0260* ld bc,@end-@cmd
0B56BC 06 
0B56BD 00 
0B56BE 00 
0B56BF 5B     0261* rst.lil $18
0B56C0 DF 
0B56C1 C9     0262* ret
0B56C2 19     0263* @cmd:   db 25
0B56C3 00     0264* @mode:  db 0
0B56C4 00     0265* @x0: 	dw 0
0B56C5 00 
0B56C6 00     0266* @y0: 	dw 0
0B56C7 00 
0B56C8 00     0267* @end:   db 0 ; padding
              0268* 
              0269* ; VDU 5: Write text at graphics cursor
              0270* ; inputs: hl = pointer to text, ix=x0, iy=y0
              0271* ; prerequisites: gcol foreground set, VDU 5 set
              0272* plot_text:
0B56C9 E5     0273* push hl ; save text pointer
              0274* ; move graphics cursor to x0, y0
0B56CA 3E     0275* ld a,plot_pt+mv_abs
0B56CB 44 
0B56CC CD     0276* call plot
0B56CD A9 
0B56CE 56 
0B56CF 0B 
              0277* ; write text
0B56D0 E1     0278* pop hl ; restore text pointer
0B56D1 CD     0279* call printString
0B56D2 21 
0B56D3 49 
0B56D4 0B 
0B56D5 C9     0280* ret
               0192 include "files.inc"
              0001* ; load to onboard 8k sram
              0002* filedata: equ 0xB7E000; Directory object structure (DIR)
               0193 
               0194 ; APPLICATION INCLUDES
               0195 
               0196 ; Storage for the argv array pointers
               0197 min_args: equ 2
               0198 argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B56D6 00      0199 argv_ptrs:		    BLKP	argv_ptrs_max, 0
0B56D7 00 
0B56D8 00 
0B56D9 00 
0B56D9 00   
0B56DA 00 
0B56DB 00 
0B56DC 00 
0B56DC 00   
0B56DD 00 
0B56DE 00 
0B56DF 00 
0B56DF 00   
0B56E0 00 
0B56E1 00 
0B56E2 00 
0B56E2 00   
0B56E3 00 
0B56E4 00 
0B56E5 00 
0B56E5 00   
0B56E6 00 
0B56E7 00 
0B56E8 00 
0B56E8 00   
0B56E9 00 
0B56EA 00 
0B56EB 00 
0B56EB 00   
0B56EC 00 
0B56ED 00 
0B56EE 00 
0B56EE 00   
0B56EF 00 
0B56F0 00 
0B56F1 00 
0B56F1 00   
0B56F2 00 
0B56F3 00 
0B56F4 00 
0B56F4 00   
0B56F5 00 
0B56F6 00 
0B56F7 00 
0B56F7 00   
0B56F8 00 
0B56F9 00 
0B56FA 00 
               0200 _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
               0201 
               0202 ; Storage for the arguments, ORDER MATTERS
               0203 arg1: ds 5
               0204 arg2: ds 5
               0205 
               0206 ; GLOBAL MESSAGE STRINGS
0B5713 55      0207 str_usage: ASCIZ "Usage: scratch <args>\r\n"
0B5714 73 
0B5715 61 
0B5716 67 
0B5716 65   
0B5717 3A 
0B5718 20 
0B5719 73 
0B5719 63   
0B571A 72 
0B571B 61 
0B571C 74 
0B571C 63   
0B571D 68 
0B571E 20 
0B571F 3C 
0B571F 61   
0B5720 72 
0B5721 67 
0B5722 73 
0B5722 3E   
0B5723 0D 
0B5724 0A 
0B5725 00 
0B572B 45      0208 str_error: ASCIZ "Error!\r\n"
0B572C 72 
0B572D 72 
0B572E 6F 
0B572E 72   
0B572F 21 
0B5730 0D 
0B5731 0A 
0B5731 00   
0B5734 53      0209 str_success: ASCIZ "Success!\r\n"
0B5735 75 
0B5736 63 
0B5737 63 
0B5737 65   
0B5738 73 
0B5739 73 
0B573A 21 
0B573A 0D   
0B573B 0A 
0B573C 00 
               0210 
               0211 ; ========= MAIN LOOP =========
               0212 ; The main routine
               0213 ; IXU: argv - pointer to array of parameters
               0214 ;   C: argc - number of parameters
               0215 ; Returns:
               0216 ;  HL: Error code, or 0 if OK
               0217 
               0218 _main_init:
0B573F 79      0219 ld a,c              ; how many arguments?
0B5740 FE      0220 cp min_args         ; not enough?
0B5741 02 
0B5742 30      0221 jr nc,main          ; if enough, go to main loop
0B5743 23 
0B5744 21      0222 ld hl,str_usage     ; if not enough, print usage
0B5745 13 
0B5746 57 
0B5747 0B 
0B5748 CD      0223 call printString
0B5749 21 
0B574A 49 
0B574B 0B 
               0224 ; fall through to _main_end_error
               0225 
               0226 _main_end_error:
0B574C 21      0227 ld hl,str_error     ; print error message
0B574D 2B 
0B574E 57 
0B574F 0B 
0B5750 CD      0228 call printString
0B5751 21 
0B5752 49 
0B5753 0B 
0B5754 21      0229 ld hl,19            ; return error code 19
0B5755 13 
0B5756 00 
0B5757 00 
0B5758 C9      0230 ret
               0231 
               0232 ; begin BASIC-specific end code
               0233 ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B5759 ED      0234 _end:			LD		SP, (_sps)		; Restore the stack pointer
0B575A 7B 
0B575B 06 
0B575C 57 
0B575C 0B   
               0235 ; fall through to _main_end_ok
               0236 ; end BASIC-specific end code
               0237 
               0238 _main_end_ok:
               0239 ; ld hl,str_success   ; print success message
               0240 ; call printString
0B575E CD      0241 call printNewLine
0B575F 36 
0B5760 49 
0B5761 0B 
0B5762 21      0242 ld hl,0             ; return 0 for success
0B5763 00 
0B5764 00 
0B5765 00 
0B5766 C9      0243 ret
               0244 
               0245 ; ========= BEGIN CUSTOM MAIN LOOP =========
               0246 main:
0B5767 0D      0247 dec c               ; decrement the argument count to skip the program name
0B5768 CD      0248 call load_input     ; load the input arguments
0B5769 31 
0B576A 59 
0B576B 0B 
0B576C CD      0249 call print_input    ; print the input arguments
0B576D 48 
0B576E 59 
0B576F 0B 
0B5770 CD      0250 call main_loop      ; run the main loop
0B5771 D9 
0B5772 57 
0B5773 0B 
0B5774 C3      0251 jp _main_end_ok     ; exit with success
0B5775 5E 
0B5776 57 
0B5777 0B 
               0252 
               0253 ; GLOBAL VARIABLES / DEFAULTS
               0254 ; ---- input arguments (float) ----
               0255 input_params_num: equ 5
               0256 input_params:               ; label so we can traverse the table in loops
0B5778 81      0257 petals:             db   0x81           ; 3.03
0B5779 1E      0258 dw32 0x41EB851E
0B577A 85 
0B577B EB 
0B577C 41 
0B577D 80      0259 vectors:            db   0x80           ; 1.98
0B577E D7      0260 dw32 0x7D70A3D7
0B577F A3 
0B5780 70 
0B5781 7D 
0B5782 7F      0261 depth:              db   0x7F           ; 0.6
0B5783 99      0262 dw32 0x19999999
0B5784 99 
0B5785 99 
0B5786 19 
0B5787 86      0263 periods:            db   0x86           ; 66
0B5788 00      0264 dw32 0x04000000
0B5789 00 
0B578A 00 
0B578B 04 
0B578C 7F      0265 shrink:             db   0x7F           ; 0.8
0B578D CC      0266 dw32 0x4CCCCCCC
0B578E CC 
0B578F CC 
0B5790 4C 
0B5791 00      0267 clock_prime:        db   0x00           ; 1     not used
0B5792 00      0268 dw32 0x00000000
0B5793 00 
0B5794 00 
0B5795 00 
0B5796 00      0269 clock_petal: 	    db   0x00           ; 1     not used
0B5797 00      0270 dw32 0x00000000
0B5798 00 
0B5799 00 
0B579A 00 
0B579B 88      0271 radius_scale: 	    db   0x88           ; 256
0B579C 00      0272 dw32 0x00000000
0B579D 00 
0B579E 00 
0B579F 00 
               0273 
               0274 ; ---- main loop parameters (float unless noted otherwise) ----
0B57A0 00      0275 db   0x00
0B57A1 00      0276 step_theta_prime:   dw32 0x00000000   ; Step increment for theta_prime in each loop iteration
0B57A2 00 
0B57A3 00 
0B57A4 00 
0B57A5 00      0277 db   0x00
0B57A6 00      0278 step_theta_petal:   dw32 0x00000000   ; Step increment for theta_petal in each loop iteration
0B57A7 00 
0B57A8 00 
0B57A9 00 
0B57AA 00      0279 db   0x00
0B57AB 00      0280 total_steps:        dw32 0x00000000   ; Total number of iterations based on periods and step_theta_prime
0B57AC 00 
0B57AD 00 
0B57AE 00 
0B57AF 00      0281 db   0x00
0B57B0 00      0282 step_shrink:        dw32 0x00000000   ; Step decrement applied to radius in each iteration
0B57B1 00 
0B57B2 00 
0B57B3 00 
0B57B4 00      0283 db   0x00
               0284 
               0285 ; ---- main loop state variables (float) ----
0B57B5 00      0286 db   0x00
0B57B6 00      0287 theta_prime: 	    dw32 0x00000000   ;
0B57B7 00 
0B57B8 00 
0B57B9 00 
0B57BA 00      0288 db   0x00
0B57BB 00      0289 theta_petal: 	    dw32 0x00000000   ;
0B57BC 00 
0B57BD 00 
0B57BE 00 
0B57BF 00      0290 db   0x00
0B57C0 00      0291 radius_prime:       dw32 0x00000000   ; Initial radius before shrink factor is applied
0B57C1 00 
0B57C2 00 
0B57C3 00 
0B57C4 00      0292 db   0x00
0B57C5 00      0293 radius_petal:       dw32 0x00000000   ; Radius of the petal circle
0B57C6 00 
0B57C7 00 
0B57C8 00 
0B57C9 00      0294 db   0x00
0B57CA 00      0295 radius:             dw32 0x00000000   ; Total radius of the curve
0B57CB 00 
0B57CC 00 
0B57CD 00 
0B57CE 00      0296 db   0x00
0B57CF 00      0297 x_prev:             dw32 0x00000000   ; Previous x coordinate
0B57D0 00 
0B57D1 00 
0B57D2 00 
0B57D3 00      0298 db   0x00
0B57D4 00      0299 y_prev:             dw32 0x00000000   ; Previous y coordinate
0B57D5 00 
0B57D6 00 
0B57D7 00 
0B57D8 00      0300 db   0x00
               0301 
               0302 main_loop:
               0303 ; --- clear the screen ---
0B57D9 CD      0304 call vdu_cls
0B57DA 4C 
0B57DB 52 
0B57DC 0B 
               0305 
               0306 ; --- convert input thetas to radians
0B57DD FD      0307 ld iy,theta_prime
0B57DE 21 
0B57DF B6 
0B57E0 57 
0B57E0 0B   
0B57E2 CD      0308 call fetch_float_iy_nor
0B57E3 E5 
0B57E4 50 
0B57E5 0B 
0B57E6 3E      0309 ld a,rad
0B57E7 1B 
0B57E8 CD      0310 call FPP
0B57E9 2E 
0B57EA 20 
0B57EB 0B 
0B57EC CD      0311 call store_float_iy_nor
0B57ED D3 
0B57EE 50 
0B57EF 0B 
               0312 
0B57F0 FD      0313 ld iy,theta_petal
0B57F1 21 
0B57F2 BB 
0B57F3 57 
0B57F3 0B   
0B57F5 CD      0314 call fetch_float_iy_nor
0B57F6 E5 
0B57F7 50 
0B57F8 0B 
0B57F9 3E      0315 ld a,rad
0B57FA 1B 
0B57FB CD      0316 call FPP
0B57FC 2E 
0B57FD 20 
0B57FE 0B 
0B57FF CD      0317 call store_float_iy_nor
0B5800 D3 
0B5801 50 
0B5802 0B 
               0318 
               0319 ; --- compute the main loop parameters ---
               0320 ; step_theta_prime = 360 degrees / (petals * vectors)
0B5803 FD      0321 ld iy,petals
0B5804 21 
0B5805 78 
0B5806 57 
0B5806 0B   
0B5808 CD      0322 call fetch_float_iy_nor
0B5809 E5 
0B580A 50 
0B580B 0B 
0B580C FD      0323 ld iy,vectors
0B580D 21 
0B580E 7D 
0B580F 57 
0B580F 0B   
0B5811 CD      0324 call fetch_float_iy_alt
0B5812 09 
0B5813 51 
0B5814 0B 
0B5815 3E      0325 ld a,fmul
0B5816 0A 
0B5817 CD      0326 call FPP ; HLH'L'C = petals * vectors
0B5818 2E 
0B5819 20 
0B581A 0B 
0B581B CD      0327 call pi2_alt ; DED'E'B = 2 * pi
0B581C 04 
0B581D 52 
0B581E 0B 
0B581F CD      0328 call SWAP ; HLH'L'C <--> DED'E'B
0B5820 9B 
0B5821 08 
0B5822 0B 
0B5823 3E      0329 ld a,fdiv
0B5824 0F 
0B5825 CD      0330 call FPP ; HLH'L'C = 2 * pi / (petals * vectors)
0B5826 2E 
0B5827 20 
0B5828 0B 
0B5829 FD      0331 ld iy,step_theta_prime
0B582A 21 
0B582B A1 
0B582C 57 
0B582C 0B   
0B582E CD      0332 call store_float_iy_nor
0B582F D3 
0B5830 50 
0B5831 0B 
               0333 
               0334 ; step_theta_petal = 360 degrees / vectors
0B5832 FD      0335 ld iy,vectors
0B5833 21 
0B5834 7D 
0B5835 57 
0B5835 0B   
0B5837 CD      0336 call fetch_float_iy_nor
0B5838 E5 
0B5839 50 
0B583A 0B 
0B583B CD      0337 call pi2_alt ; DED'E'B = 2 * pi
0B583C 04 
0B583D 52 
0B583E 0B 
0B583F CD      0338 call SWAP ; HLH'L'C <--> DED'E'B
0B5840 9B 
0B5841 08 
0B5842 0B 
0B5843 3E      0339 ld a,fdiv
0B5844 0F 
0B5845 CD      0340 call FPP ; HLH'L'C = 2 * pi / vectors
0B5846 2E 
0B5847 20 
0B5848 0B 
0B5849 FD      0341 ld iy,step_theta_petal
0B584A 21 
0B584B A6 
0B584C 57 
0B584C 0B   
0B584E CD      0342 call store_float_iy_nor
0B584F D3 
0B5850 50 
0B5851 0B 
               0343 
               0344 ; total_steps = int(petals * vectors * periods)
0B5852 FD      0345 ld iy,petals
0B5853 21 
0B5854 78 
0B5855 57 
0B5855 0B   
0B5857 CD      0346 call fetch_float_iy_nor
0B5858 E5 
0B5859 50 
0B585A 0B 
0B585B FD      0347 ld iy,vectors
0B585C 21 
0B585D 7D 
0B585E 57 
0B585E 0B   
0B5860 CD      0348 call fetch_float_iy_alt
0B5861 09 
0B5862 51 
0B5863 0B 
0B5864 3E      0349 ld a,fmul
0B5865 0A 
0B5866 CD      0350 call FPP ; HLH'L'C = petals * vectors
0B5867 2E 
0B5868 20 
0B5869 0B 
0B586A FD      0351 ld iy,periods
0B586B 21 
0B586C 87 
0B586D 57 
0B586D 0B   
0B586F CD      0352 call fetch_float_iy_alt
0B5870 09 
0B5871 51 
0B5872 0B 
0B5873 3E      0353 ld a,fmul
0B5874 0A 
0B5875 CD      0354 call FPP ; HLH'L'C = petals * vectors * periods
0B5876 2E 
0B5877 20 
0B5878 0B 
0B5879 FD      0355 ld iy,total_steps
0B587A 21 
0B587B AB 
0B587C 57 
0B587C 0B   
0B587E CD      0356 call store_float_iy_nor ; we'll make it an integer after computing step_shrink
0B587F D3 
0B5880 50 
0B5881 0B 
               0357 
               0358 ; Calculate shrink per step (linear)
               0359 ; step_shrink = -shrink * radius_scale / total_steps
0B5882 FD      0360 ld iy,shrink
0B5883 21 
0B5884 8C 
0B5885 57 
0B5885 0B   
0B5887 CD      0361 call fetch_float_iy_nor
0B5888 E5 
0B5889 50 
0B588A 0B 
0B588B FD      0362 ld iy,radius_scale
0B588C 21 
0B588D 9B 
0B588E 57 
0B588E 0B   
0B5890 CD      0363 call fetch_float_iy_alt
0B5891 09 
0B5892 51 
0B5893 0B 
0B5894 3E      0364 ld a,fmul
0B5895 0A 
0B5896 CD      0365 call FPP ; HLH'L'C = shrink * radius_scale
0B5897 2E 
0B5898 20 
0B5899 0B 
0B589A FD      0366 ld iy,total_steps
0B589B 21 
0B589C AB 
0B589D 57 
0B589D 0B   
0B589F CD      0367 call fetch_float_iy_alt
0B58A0 09 
0B58A1 51 
0B58A2 0B 
0B58A3 3E      0368 ld a,fdiv
0B58A4 0F 
0B58A5 CD      0369 call FPP ; HLH'L'C = shrink * radius_scale / total_steps
0B58A6 2E 
0B58A7 20 
0B58A8 0B 
0B58A9 CD      0370 call NEGATE ; HLH'L'C = -shrink * radius_scale / total_steps
0B58AA 9E 
0B58AB 2A 
0B58AC 0B 
0B58AD FD      0371 ld iy,step_shrink
0B58AE 21 
0B58AF B0 
0B58B0 57 
0B58B0 0B   
0B58B2 CD      0372 call store_float_iy_nor
0B58B3 D3 
0B58B4 50 
0B58B5 0B 
               0373 
               0374 ; Make total_steps an integer and store it in uhl
0B58B6 FD      0375 ld iy,total_steps
0B58B7 21 
0B58B8 AB 
0B58B9 57 
0B58B9 0B   
0B58BB CD      0376 call fetch_float_iy_nor
0B58BC E5 
0B58BD 50 
0B58BE 0B 
0B58BF CD      0377 call int2hlu ; HLH'L'C = int(total_steps)
0B58C0 12 
0B58C1 50 
0B58C2 0B 
0B58C3 FD      0378 ld (iy),hl ; uhl = int(total_steps)
0B58C4 2F 
0B58C5 00 
               0379 
               0380 ; Initialize radius_prime
0B58C6 FD      0381 ld iy,radius_scale
0B58C7 21 
0B58C8 9B 
0B58C9 57 
0B58C9 0B   
0B58CB CD      0382 call fetch_float_iy_nor
0B58CC E5 
0B58CD 50 
0B58CE 0B 
0B58CF FD      0383 ld iy,radius_prime
0B58D0 21 
0B58D1 C0 
0B58D2 57 
0B58D2 0B   
0B58D4 CD      0384 call store_float_iy_nor
0B58D5 D3 
0B58D6 50 
0B58D7 0B 
               0385 
               0386 ; Set screen origin to the center
0B58D8 01      0387 ld bc,1280/2 ; x
0B58D9 80 
0B58DA 02 
0B58DB 00 
0B58DC 11      0388 ld de,1024/2 ; y
0B58DD 00 
0B58DE 02 
0B58DF 00 
0B58E0 CD      0389 call vdu_set_gfx_origin
0B58E1 B8 
0B58E2 52 
0B58E3 0B 
               0390 
               0391 ; set initial point and move graphics cursor to it
0B58E4 CD      0392 call calc_point ; ubc = x, ude = y
0B58E5 EF 
0B58E6 58 
0B58E7 0B 
0B58E8 3E      0393 ld a,plot_pt+mv_abs ; plot mode
0B58E9 44 
0B58EA CD      0394 call vdu_plot
0B58EB C9 
0B58EC 55 
0B58ED 0B 
               0395 ; fall through to main loop
               0396 
               0397 @loop:
               0398 ; ; Advance theta values
               0399 ;     ; theta_prime += step_theta_prime
               0400 ;     ld hl,(theta_prime)
               0401 ;     ld de,(step_theta_prime)
               0402 ;     add hl,de
               0403 ;     ld (theta_prime),hl
               0404 
               0405 ;     ; theta_petal += step_theta_petal
               0406 ;     ld hl,(theta_petal)
               0407 ;     ld de,(step_theta_petal)
               0408 ;     add hl,de
               0409 ;     ld (theta_petal),hl
               0410 
               0411 ; ; Update radius_prime
               0412 ;     ; radius_prime += step_shrink
               0413 ;     ld hl,(radius_prime)
               0414 ;     ld de,(step_shrink)
               0415 ;     add hl,de
               0416 ;     ld (radius_prime),hl
               0417 
               0418 ; ; Calculate new coordinates and draw a line from the previous point
               0419 ;     call calc_point ; ub.c = x, ud.e = y
               0420 ;     ld a,plot_sl_both+dr_abs_fg ; plot mode
               0421 ;     call vdu_plot_168
               0422 
               0423 ;     ; call printNewLine
               0424 ;     ; call print_theta_prime
               0425 ;     ; call print_theta_petal
               0426 ;     ; ; call print_radius_prime
               0427 ;     ; ; call print_radius_petal
               0428 ;     ; call print_radius
               0429 ;     ; call print_xy
               0430 
               0431 ; ; Decrement the loop counter
               0432 ;     ld hl,total_steps
               0433 ;     dec (hl)
               0434 ;     jp nz,@loop
0B58EE C9      0435 ret
               0436 
               0437 ; compute the Cartesian coordinates of the next point on the curve
               0438 ; inputs: theta_prime, theta_petal, radius_prime, depth
               0439 ; outputs: ub.c = x, ud.e = y
               0440 calc_point:
               0441 ; Calculate the petal radius and total radius
               0442 ; radius_petal = math.cos(theta_petal) * depth
               0443 ; ld hl,(theta_petal)
               0444 ; call cos168 ; uh.l = cos(theta_petal)
               0445 ; ld de,(depth)
               0446 ; call smul168 ; uh.l = radius_petal
               0447 ; ld (radius_petal),hl
0B58EF FD      0448 ld iy,theta_petal
0B58F0 21 
0B58F1 BB 
0B58F2 57 
0B58F2 0B   
0B58F4 3E      0449 ld a,cos
0B58F5 14 
0B58F6 CD      0450 call FPP ; HLH'L'C = cos(theta_petal)
0B58F7 2E 
0B58F8 20 
0B58F9 0B 
0B58FA FD      0451 ld iy,depth
0B58FB 21 
0B58FC 82 
0B58FD 57 
0B58FD 0B   
0B58FF CD      0452 call fetch_float_iy_alt
0B5900 09 
0B5901 51 
0B5902 0B 
0B5903 3E      0453 ld a,fmul
0B5904 0A 
0B5905 CD      0454 call FPP ; HLH'L'C = cos(theta_petal) * depth
0B5906 2E 
0B5907 20 
0B5908 0B 
0B5909 CD      0455 call SWAP ; HLH'L'C <--> DED'E'B
0B590A 9B 
0B590B 08 
0B590C 0B 
               0456 
               0457 ;     ; radius = radius_prime + radius_petal * radius_prime
               0458 ;     ld de,(radius_prime)
               0459 ;     call smul168 ; uh.l = radius_petal * radius_prime
               0460 ;     add hl,de ; uh.l = radius_prime + radius_petal * radius_prime
               0461 ;     ex de,hl ; de = radius
               0462 ;     ld (radius),de
0B590D FD      0463 ld iy,radius_prime
0B590E 21 
0B590F C0 
0B5910 57 
0B5910 0B   
0B5912 3E      0464 ld a,fmul
0B5913 0A 
0B5914 CD      0465 call FPP ; HLH'L'C = radius_petal * radius_prime
0B5915 2E 
0B5916 20 
0B5917 0B 
0B5918 FD      0466 ld iy,radius_prime
0B5919 21 
0B591A C0 
0B591B 57 
0B591B 0B   
0B591D CD      0467 call fetch_float_iy_alt
0B591E 09 
0B591F 51 
0B5920 0B 
0B5921 3E      0468 ld a,fadd
0B5922 0B 
0B5923 CD      0469 call FPP ; HLH'L'C = radius_prime + radius_petal * radius_prime
0B5924 2E 
0B5925 20 
0B5926 0B 
0B5927 FD      0470 ld iy,radius
0B5928 21 
0B5929 CA 
0B592A 57 
0B592A 0B   
0B592C CD      0471 call store_float_iy_nor
0B592D D3 
0B592E 50 
0B592F 0B 
               0472 
               0473 ; ; Convert polar to Cartesian coordinates
               0474 ;     ; x, y = polar_to_cartesian(radius, theta_prime)
               0475 ;     ld hl,(theta_prime)
               0476 ;     call polar_to_cartesian ; ub.c = x, ud.e = y
               0477 ;     ld (x_prev),bc
               0478 ;     ld (y_prev),de
               0479 
               0480 ; ; ; Debug print
               0481 ; ;     call print_hex_bc
               0482 ; ;     call print_s168_bc
               0483 ; ;     call print_hex_de
               0484 ; ;     call print_s168_de
               0485 ; ;     ; call printNewLine
               0486 
               0487 ; ; all done
0B5930 C9      0488 ret
               0489 
               0490 
               0491 ; --- Load arguments ---
               0492 ; --------------------------------
               0493 load_input:
0B5931 79      0494 ld a,c ; put the number of entered arguments in a
0B5932 06      0495 ld b,input_params_num ; loop counter = number of arguments
0B5933 05 
0B5934 B8      0496 cp b ; compare the number of arguments to the number of arguments
0B5935 C4      0497 call nz,args_count_off ; handle discrepancies
0B5936 63 
0B5937 59 
0B5938 0B 
               0498 ; TODO: we may want to branch here according to the result
0B5939 FD      0499 ld iy,input_params  ; point to the arguments table
0B593A 21 
0B593B 78 
0B593C 57 
0B593C 0B   
               0500 @loop:
0B593E CD      0501 call store_arg_iy_float ; get the next argument and store it
0B593F 22 
0B5940 5A 
0B5941 0B 
0B5942 ED      0502 lea iy,iy+5  ; point to the next parameter
0B5943 33 
0B5944 05 
0B5945 10      0503 djnz @loop ; loop until done
0B5946 F7 
0B5947 C9      0504 ret
               0505 
               0506 print_input:
0B5948 06      0507 ld b,input_params_num ; loop counter = number of arguments
0B5949 05 
0B594A FD      0508 ld iy,input_params  ; point to the arguments table
0B594B 21 
0B594C 78 
0B594D 57 
0B594D 0B   
               0509 @loop:
0B594F C5      0510 push bc ; save the loop counter
0B5950 CD      0511 call fetch_float_iy_nor ; fetch the next parameter into HLH'L'C
0B5951 E5 
0B5952 50 
0B5953 0B 
0B5954 CD      0512 call print_float_dec_nor ; print the parameter
0B5955 9C 
0B5956 51 
0B5957 0B 
0B5958 3E      0513 ld a,' ' ; print a space separator
0B5959 20 
0B595A 5B      0514 rst.lil $10
0B595B D7 
0B595C ED      0515 lea iy,iy+5  ; point to the next parameter
0B595D 33 
0B595E 05 
0B595F C1      0516 pop bc ; get back the loop counter
0B5960 10      0517 djnz @loop ; loop until done
0B5961 ED 
0B5962 C9      0518 ret
               0519 
               0520 ; --- Specific parameter processing functions ---
               0521 args_count_off:
0B5963 21      0522 ld hl,@str_args_count_off
0B5964 6C 
0B5965 59 
0B5966 0B 
0B5967 CD      0523 call printString
0B5968 21 
0B5969 49 
0B596A 0B 
0B596B C9      0524 ret
0B596C 41      0525 @str_args_count_off: db "Argument counts mismatch!\r\n",0
0B596D 72 
0B596E 67 
0B596F 75 
0B596F 6D   
0B5970 65 
0B5971 6E 
0B5972 74 
0B5972 20   
0B5973 63 
0B5974 6F 
0B5975 75 
0B5975 6E   
0B5976 74 
0B5977 73 
0B5978 20 
0B5978 6D   
0B5979 69 
0B597A 73 
0B597B 6D 
0B597B 61   
0B597C 74 
0B597D 63 
0B597E 68 
0B597E 21   
0B597F 0D 
0B5980 0A 
0B5981 00 
               0526 
               0527 ; ---- text strings ----
0B5988 73      0528 str_step_theta_prime: ASCIZ "step_theta_prime: "
0B5989 74 
0B598A 65 
0B598B 70 
0B598B 5F   
0B598C 74 
0B598D 68 
0B598E 65 
0B598E 74   
0B598F 61 
0B5990 5F 
0B5991 70 
0B5991 72   
0B5992 69 
0B5993 6D 
0B5994 65 
0B5994 3A   
0B5995 20 
0B5996 00 
0B599B 73      0529 str_step_theta_petal: ASCIZ "step_theta_petal: "
0B599C 74 
0B599D 65 
0B599E 70 
0B599E 5F   
0B599F 74 
0B59A0 68 
0B59A1 65 
0B59A1 74   
0B59A2 61 
0B59A3 5F 
0B59A4 70 
0B59A4 65   
0B59A5 74 
0B59A6 61 
0B59A7 6C 
0B59A7 3A   
0B59A8 20 
0B59A9 00 
0B59AE 74      0530 str_total_steps: ASCIZ "total_steps: "
0B59AF 6F 
0B59B0 74 
0B59B1 61 
0B59B1 6C   
0B59B2 5F 
0B59B3 73 
0B59B4 74 
0B59B4 65   
0B59B5 70 
0B59B6 73 
0B59B7 3A 
0B59B7 20   
0B59B8 00 
0B59BC 73      0531 str_step_shrink: ASCIZ "step_shrink: "
0B59BD 74 
0B59BE 65 
0B59BF 70 
0B59BF 5F   
0B59C0 73 
0B59C1 68 
0B59C2 72 
0B59C2 69   
0B59C3 6E 
0B59C4 6B 
0B59C5 3A 
0B59C5 20   
0B59C6 00 
               0532 
0B59CA 74      0533 str_theta_prime: ASCIZ "theta_prime: "
0B59CB 68 
0B59CC 65 
0B59CD 74 
0B59CD 61   
0B59CE 5F 
0B59CF 70 
0B59D0 72 
0B59D0 69   
0B59D1 6D 
0B59D2 65 
0B59D3 3A 
0B59D3 20   
0B59D4 00 
0B59D8 72      0534 str_radius_prime: ASCIZ "radius_prime: "
0B59D9 61 
0B59DA 64 
0B59DB 69 
0B59DB 75   
0B59DC 73 
0B59DD 5F 
0B59DE 70 
0B59DE 72   
0B59DF 69 
0B59E0 6D 
0B59E1 65 
0B59E1 3A   
0B59E2 20 
0B59E3 00 
0B59E7 72      0535 str_radius_petal: ASCIZ "radius_petal: "
0B59E8 61 
0B59E9 64 
0B59EA 69 
0B59EA 75   
0B59EB 73 
0B59EC 5F 
0B59ED 70 
0B59ED 65   
0B59EE 74 
0B59EF 61 
0B59F0 6C 
0B59F0 3A   
0B59F1 20 
0B59F2 00 
0B59F6 74      0536 str_theta_petal: ASCIZ "theta_petal: "
0B59F7 68 
0B59F8 65 
0B59F9 74 
0B59F9 61   
0B59FA 5F 
0B59FB 70 
0B59FC 65 
0B59FC 74   
0B59FD 61 
0B59FE 6C 
0B59FF 3A 
0B59FF 20   
0B5A00 00 
               0537 
0B5A04 72      0538 str_radius: ASCIZ "radius: "
0B5A05 61 
0B5A06 64 
0B5A07 69 
0B5A07 75   
0B5A08 73 
0B5A09 3A 
0B5A0A 20 
0B5A0A 00   
0B5A0D 78      0539 str_xy: ASCIZ "x,y: "
0B5A0E 2C 
0B5A0F 79 
0B5A10 3A 
0B5A10 20   
0B5A11 00 
               0540 
               0541 ; ========== HELPER FUNCTIONS ==========
               0542 ;
               0543 ; get the next argument after ix as a floating point number
               0544 ; inputs: ix = pointer to the argument string
               0545 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0546 ; destroys: everything except iy, including prime registers
               0547 get_arg_float:
0B5A13 ED      0548 lea ix,ix+3 ; point to the next argument
0B5A14 32 
0B5A15 03 
0B5A16 DD      0549 push ix ; preserve
0B5A17 E5 
0B5A18 DD      0550 ld ix,(ix)  ; point to argument string
0B5A19 37 
0B5A1A 00 
0B5A1B CD      0551 call VAL_FP ; convert the string to a float
0B5A1C A5 
0B5A1D 24 
0B5A1E 0B 
0B5A1F DD      0552 pop ix ; restore
0B5A20 E1 
0B5A21 C9      0553 ret ; return with the value in HLH'L'C
               0554 
               0555 ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
               0556 ; inputs: ix = pointer to the argument string
               0557 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0558 ; destroys: everything except iy, including prime registers
               0559 store_arg_iy_float:
0B5A22 ED      0560 lea ix,ix+3 ; point to the next argument
0B5A23 32 
0B5A24 03 
0B5A25 DD      0561 push ix ; preserve
0B5A26 E5 
0B5A27 DD      0562 ld ix,(ix)  ; point to argument string
0B5A28 37 
0B5A29 00 
0B5A2A CD      0563 call VAL_FP ; convert the string to a float
0B5A2B A5 
0B5A2C 24 
0B5A2D 0B 
0B5A2E CD      0564 call store_float_iy_nor ; save the float in buffer
0B5A2F D3 
0B5A30 50 
0B5A31 0B 
0B5A32 DD      0565 pop ix ; restore
0B5A33 E1 
0B5A34 C9      0566 ret ; return with the value in HLH'L'C
               0567 ;
               0568 ; get the next argument after ix as a string
               0569 ; inputs: ix = pointer to the argument string
               0570 ; outputs: HL = pointer to the argument string, ix points to the next argument
               0571 ; destroys: a, h, l, f
               0572 get_arg_text:
0B5A35 ED      0573 lea ix,ix+3 ; point to the next argument
0B5A36 32 
0B5A37 03 
0B5A38 DD      0574 ld hl,(ix)  ; get the argument string
0B5A39 27 
0B5A3A 00 
0B5A3B C9      0575 ret
               0576 ;
               0577 ; match the next argument after ix to the dispatch table at iy
               0578 ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
               0579 ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
               0580 ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
               0581 ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
               0582 ; destroys: a, hl, de, ix, iy, flags
               0583 match_next:
0B5A3C ED      0584 lea ix,ix+3         ; point to the next argument
0B5A3D 32 
0B5A3E 03 
               0585 @loop:
0B5A3F FD      0586 ld hl,(iy)          ; pointer argument dispatch record
0B5A40 27 
0B5A41 00 
               0587 sign_hlu            ; check for list terminator
0B5A42 19     0001M add hl,de
0B5A43 B7     0002M or a
0B5A44 ED     0003M sbc hl,de
0B5A45 52 
0B5A46 CA      0588 jp z,@no_match      ; if a=0, return error
0B5A47 5E 
0B5A48 5A 
0B5A49 0B 
0B5A4A 23      0589 inc hl              ; skip over jp instruction
0B5A4B 23      0590 inc hl
0B5A4C DD      0591 ld de,(ix)          ; pointer to the argument string
0B5A4D 17 
0B5A4E 00 
0B5A4F CD      0592 call str_equal      ; compare the argument to the dispatch table entry
0B5A50 75 
0B5A51 5A 
0B5A52 0B 
0B5A53 CA      0593 jp z,@match         ; if equal, return success
0B5A54 60 
0B5A55 5A 
0B5A56 0B 
0B5A57 ED      0594 lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B5A58 33 
0B5A59 03 
0B5A5A C3      0595 jp @loop            ; and loop
0B5A5B 3F 
0B5A5C 5A 
0B5A5D 0B 
               0596 @no_match:
0B5A5E 3C      0597 inc a               ; no match so return a=1 and zero flag reset
0B5A5F C9      0598 ret
               0599 @match:
0B5A60 FD      0600 ld iy,(iy)          ; get the function pointer
0B5A61 37 
0B5A62 00 
0B5A63 C9      0601 ret                 ; return a=0 and zero flag set
               0602 
               0603 ; same as match_next, but prints the parameter if a match is found
               0604 match_next_and_print:
0B5A64 CD      0605 call match_next
0B5A65 3C 
0B5A66 5A 
0B5A67 0B 
0B5A68 C0      0606 ret nz ; no match found
0B5A69 ED      0607 lea ix,ix-3
0B5A6A 32 
0B5A6B FD 
0B5A6C CD      0608 call get_arg_text ; hl points to the operator string
0B5A6D 35 
0B5A6E 5A 
0B5A6F 0B 
0B5A70 CD      0609 call print_param
0B5A71 80 
0B5A72 5A 
0B5A73 0B 
0B5A74 C9      0610 ret
               0611 
               0612 ; compare two zero-terminated strings for equality, case-sensitive
               0613 ; hl: pointer to first string, de: pointer to second string
               0614 ; returns: z if equal, nz if not equal
               0615 ; destroys: a, hl, de
               0616 str_equal:
0B5A75 1A      0617 ld a,(de)           ; get the first character
0B5A76 BE      0618 cp (hl)             ; compare to the second character
0B5A77 C0      0619 ret nz              ; if not equal, return
0B5A78 B7      0620 or a
0B5A79 C8      0621 ret z               ; if equal and zero, return
0B5A7A 23      0622 inc hl              ; next character
0B5A7B 13      0623 inc de
0B5A7C C3      0624 jp str_equal        ; loop until end of string
0B5A7D 75 
0B5A7E 5A 
0B5A7F 0B 
               0625 
               0626 ; print the parameter string pointed to by ix
               0627 ; destroys: a, hl
               0628 print_param:
0B5A80 DD      0629 ld hl,(ix)          ; get the parameter pointer
0B5A81 27 
0B5A82 00 
0B5A83 CD      0630 call printString    ; print the parameter string
0B5A84 21 
0B5A85 49 
0B5A86 0B 
0B5A87 3E      0631 ld a,' '            ; print a space separator
0B5A88 20 
0B5A89 5B      0632 rst.lil $10
0B5A8A D7 
0B5A8B C9      0633 ret
               0634 
               0635 ; print the parameters
               0636 ; inputs: b = number of parameters, ix = pointer to the parameters
               0637 ; destroys: a, hl, bc
               0638 print_params:
0B5A8C 41      0639 ld b,c              ; loop counter = number of parameters
0B5A8D DD      0640 push ix             ; save the pointer to the parameters
0B5A8E E5 
               0641 @loop:
0B5A8F C5      0642 push bc             ; save the loop counter
0B5A90 CD      0643 call print_param    ; print the parameter
0B5A91 80 
0B5A92 5A 
0B5A93 0B 
0B5A94 ED      0644 lea ix,ix+3         ; next parameter pointer
0B5A95 32 
0B5A96 03 
0B5A97 C1      0645 pop bc              ; get back the loop counter
0B5A98 10      0646 djnz @loop          ; loop until done
0B5A99 F5 
0B5A9A DD      0647 pop ix              ; restore the pointer to the parameters
0B5A9B E1 
0B5A9C C9      0648 ret
               0649 
               0650 debug_print:
0B5A9D CD      0651 call printNewLine
0B5A9E 36 
0B5A9F 49 
0B5AA0 0B 
0B5AA1 CD      0652 call dumpRegistersHexAll
0B5AA2 76 
0B5AA3 4D 
0B5AA4 0B 
0B5AA5 CD      0653 call printNewLine
0B5AA6 36 
0B5AA7 49 
0B5AA8 0B 
0B5AA9 C9      0654 ret
               0655 
               0656 include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
              0001* ;
              0002* ; Title:	BBC Basic Interpreter - Z80 version
              0003* ;		RAM Module for BBC Basic Interpreter
              0004* ;		For use with Version 2.0 of BBC BASIC
              0005* ;		Standard CP/M Distribution Version
              0006* ; Author:	(C) Copyright  R.T.Russell 31-12-1983
              0007* ; Modified By:	Dean Belfield
              0008* ; Created:	12/05/2023
              0009* ; Last Updated:	26/06/2023
              0010* ;
              0011* ; Modinfo:
              0012* ; 06/06/2023:	Modified to run in ADL mode
              0013* ; 26/06/2023:	Added temporary stores R0 and R1
              0014* 
              0015* ; .ASSUME	ADL = 1
              0016* 
              0017* ; DEFINE	LORAM, SPACE = ROM
              0018* ; SEGMENT LORAM
              0019* 
              0020* ; XDEF	ACCS
              0021* ; XDEF	BUFFER
              0022* ; XDEF	STAVAR
              0023* ; XDEF	DYNVAR
              0024* ; XDEF	FNPTR
              0025* ; XDEF	PROPTR
              0026* ; XDEF	PAGE_
              0027* ; XDEF	TOP
              0028* ; XDEF	LOMEM
              0029* ; XDEF 	FREE
              0030* ; XDEF	HIMEM
              0031* ; XDEF	LINENO
              0032* ; XDEF	TRACEN
              0033* ; XDEF	AUTONO
              0034* ; XDEF	ERRTRP
              0035* ; XDEF	ERRTXT
              0036* ; XDEF	DATPTR
              0037* ; XDEF	ERL
              0038* ; XDEF	ERRLIN
              0039* ; XDEF	RANDOM
              0040* ; XDEF	COUNT
              0041* ; XDEF	WIDTH
              0042* ; XDEF	ERR
              0043* ; XDEF	LISTON
              0044* ; XDEF	INCREM
              0045* 
              0046* ; XDEF	FLAGS
              0047* ; XDEF	OSWRCHPT
              0048* ; XDEF	OSWRCHCH
              0049* ; XDEF	OSWRCHFH
              0050* ; XDEF	KEYDOWN
              0051* ; XDEF	KEYASCII
              0052* ; XDEF	KEYCOUNT
              0053* 
              0054* ; XDEF	R0
              0055* ; XDEF	R1
              0056* 
              0057* ; XDEF	RAM_START
              0058* ; XDEF	RAM_END
              0059* ; XDEF	USER
              0060* 
              0061* end_binary: ;  for assemble.py to know where to truncate the binary file
0B5AAA FF     0062* ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
0B5AAB FF 
0B5AAC FF 
0B5AAD FF 
0B5AAD FF   
0B5AAE FF 
0B5AAF FF 
0B5AB0 FF 
0B5AB0 FF   
0B5AB1 FF 
0B5AB2 FF 
0B5AB3 FF 
0B5AB3 FF   
0B5AB4 FF 
0B5AB5 FF 
0B5AB6 FF 
0B5AB6 FF   
0B5AB7 FF 
0B5AB8 FF 
0B5AB9 FF 
0B5AB9 FF   
0B5ABA FF 
0B5ABB FF 
0B5ABC FF 
0B5ABC FF   
0B5ABD FF 
0B5ABE FF 
0B5ABF FF 
0B5ABF FF   
0B5AC0 FF 
0B5AC1 FF 
0B5AC2 FF 
0B5AC2 FF   
0B5AC3 FF 
0B5AC4 FF 
0B5AC5 FF 
0B5AC5 FF   
0B5AC6 FF 
0B5AC7 FF 
0B5AC8 FF 
0B5AC8 FF   
0B5AC9 FF 
0B5ACA FF 
0B5ACB FF 
0B5ACB FF   
0B5ACC FF 
0B5ACD FF 
0B5ACE FF 
0B5ACE FF   
0B5ACF FF 
0B5AD0 FF 
0B5AD1 FF 
0B5AD1 FF   
0B5AD2 FF 
0B5AD3 FF 
0B5AD4 FF 
0B5AD4 FF   
0B5AD5 FF 
0B5AD6 FF 
0B5AD7 FF 
0B5AD7 FF   
0B5AD8 FF 
0B5AD9 FF 
0B5ADA FF 
0B5ADA FF   
0B5ADB FF 
0B5ADC FF 
0B5ADD FF 
0B5ADD FF   
0B5ADE FF 
0B5ADF FF 
0B5AE0 FF 
0B5AE0 FF   
0B5AE1 FF 
0B5AE2 FF 
0B5AE3 FF 
0B5AE3 FF   
0B5AE4 FF 
0B5AE5 FF 
0B5AE6 FF 
0B5AE6 FF   
0B5AE7 FF 
0B5AE8 FF 
0B5AE9 FF 
0B5AE9 FF   
0B5AEA FF 
              0063* RAM_START:
              0064* ;
0B5B00 00     0065* ACCS:           BLKB    256,0             ; String Accumulator
0B5B01 00 
0B5B02 00 
0B5B03 00 
0B5B03 00   
0B5B04 00 
0B5B05 00 
0B5B06 00 
0B5B06 00   
0B5B07 00 
0B5B08 00 
0B5B09 00 
0B5B09 00   
0B5B0A 00 
0B5B0B 00 
0B5B0C 00 
0B5B0C 00   
0B5B0D 00 
0B5B0E 00 
0B5B0F 00 
0B5B0F 00   
0B5B10 00 
0B5B11 00 
0B5B12 00 
0B5B12 00   
0B5B13 00 
0B5B14 00 
0B5B15 00 
0B5B15 00   
0B5B16 00 
0B5B17 00 
0B5B18 00 
0B5B18 00   
0B5B19 00 
0B5B1A 00 
0B5B1B 00 
0B5B1B 00   
0B5B1C 00 
0B5B1D 00 
0B5B1E 00 
0B5B1E 00   
0B5B1F 00 
0B5B20 00 
0B5B21 00 
0B5B21 00   
0B5B22 00 
0B5B23 00 
0B5B24 00 
0B5B24 00   
0B5B25 00 
0B5B26 00 
0B5B27 00 
0B5B27 00   
0B5B28 00 
0B5B29 00 
0B5B2A 00 
0B5B2A 00   
0B5B2B 00 
0B5B2C 00 
0B5B2D 00 
0B5B2D 00   
0B5B2E 00 
0B5B2F 00 
0B5B30 00 
0B5B30 00   
0B5B31 00 
0B5B32 00 
0B5B33 00 
0B5B33 00   
0B5B34 00 
0B5B35 00 
0B5B36 00 
0B5B36 00   
0B5B37 00 
0B5B38 00 
0B5B39 00 
0B5B39 00   
0B5B3A 00 
0B5B3B 00 
0B5B3C 00 
0B5B3C 00   
0B5B3D 00 
0B5B3E 00 
0B5B3F 00 
0B5B3F 00   
0B5B40 00 
0B5B41 00 
0B5B42 00 
0B5B42 00   
0B5B43 00 
0B5B44 00 
0B5B45 00 
0B5B45 00   
0B5B46 00 
0B5B47 00 
0B5B48 00 
0B5B48 00   
0B5B49 00 
0B5B4A 00 
0B5B4B 00 
0B5B4B 00   
0B5B4C 00 
0B5B4D 00 
0B5B4E 00 
0B5B4E 00   
0B5B4F 00 
0B5B50 00 
0B5B51 00 
0B5B51 00   
0B5B52 00 
0B5B53 00 
0B5B54 00 
0B5B54 00   
0B5B55 00 
0B5B56 00 
0B5B57 00 
0B5B57 00   
0B5B58 00 
0B5B59 00 
0B5B5A 00 
0B5B5A 00   
0B5B5B 00 
0B5B5C 00 
0B5B5D 00 
0B5B5D 00   
0B5B5E 00 
0B5B5F 00 
0B5B60 00 
0B5B60 00   
0B5B61 00 
0B5B62 00 
0B5B63 00 
0B5B63 00   
0B5B64 00 
0B5B65 00 
0B5B66 00 
0B5B66 00   
0B5B67 00 
0B5B68 00 
0B5B69 00 
0B5B69 00   
0B5B6A 00 
0B5B6B 00 
0B5B6C 00 
0B5B6C 00   
0B5B6D 00 
0B5B6E 00 
0B5B6F 00 
0B5B6F 00   
0B5B70 00 
0B5B71 00 
0B5B72 00 
0B5B72 00   
0B5B73 00 
0B5B74 00 
0B5B75 00 
0B5B75 00   
0B5B76 00 
0B5B77 00 
0B5B78 00 
0B5B78 00   
0B5B79 00 
0B5B7A 00 
0B5B7B 00 
0B5B7B 00   
0B5B7C 00 
0B5B7D 00 
0B5B7E 00 
0B5B7E 00   
0B5B7F 00 
0B5B80 00 
0B5B81 00 
0B5B81 00   
0B5B82 00 
0B5B83 00 
0B5B84 00 
0B5B84 00   
0B5B85 00 
0B5B86 00 
0B5B87 00 
0B5B87 00   
0B5B88 00 
0B5B89 00 
0B5B8A 00 
0B5B8A 00   
0B5B8B 00 
0B5B8C 00 
0B5B8D 00 
0B5B8D 00   
0B5B8E 00 
0B5B8F 00 
0B5B90 00 
0B5B90 00   
0B5B91 00 
0B5B92 00 
0B5B93 00 
0B5B93 00   
0B5B94 00 
0B5B95 00 
0B5B96 00 
0B5B96 00   
0B5B97 00 
0B5B98 00 
0B5B99 00 
0B5B99 00   
0B5B9A 00 
0B5B9B 00 
0B5B9C 00 
0B5B9C 00   
0B5B9D 00 
0B5B9E 00 
0B5B9F 00 
0B5B9F 00   
0B5BA0 00 
0B5BA1 00 
0B5BA2 00 
0B5BA2 00   
0B5BA3 00 
0B5BA4 00 
0B5BA5 00 
0B5BA5 00   
0B5BA6 00 
0B5BA7 00 
0B5BA8 00 
0B5BA8 00   
0B5BA9 00 
0B5BAA 00 
0B5BAB 00 
0B5BAB 00   
0B5BAC 00 
0B5BAD 00 
0B5BAE 00 
0B5BAE 00   
0B5BAF 00 
0B5BB0 00 
0B5BB1 00 
0B5BB1 00   
0B5BB2 00 
0B5BB3 00 
0B5BB4 00 
0B5BB4 00   
0B5BB5 00 
0B5BB6 00 
0B5BB7 00 
0B5BB7 00   
0B5BB8 00 
0B5BB9 00 
0B5BBA 00 
0B5BBA 00   
0B5BBB 00 
0B5BBC 00 
0B5BBD 00 
0B5BBD 00   
0B5BBE 00 
0B5BBF 00 
0B5BC0 00 
0B5C00 00     0066* BUFFER:         BLKB    256,0             ; String Input Buffer
0B5C01 00 
0B5C02 00 
0B5C03 00 
0B5C03 00   
0B5C04 00 
0B5C05 00 
0B5C06 00 
0B5C06 00   
0B5C07 00 
0B5C08 00 
0B5C09 00 
0B5C09 00   
0B5C0A 00 
0B5C0B 00 
0B5C0C 00 
0B5C0C 00   
0B5C0D 00 
0B5C0E 00 
0B5C0F 00 
0B5C0F 00   
0B5C10 00 
0B5C11 00 
0B5C12 00 
0B5C12 00   
0B5C13 00 
0B5C14 00 
0B5C15 00 
0B5C15 00   
0B5C16 00 
0B5C17 00 
0B5C18 00 
0B5C18 00   
0B5C19 00 
0B5C1A 00 
0B5C1B 00 
0B5C1B 00   
0B5C1C 00 
0B5C1D 00 
0B5C1E 00 
0B5C1E 00   
0B5C1F 00 
0B5C20 00 
0B5C21 00 
0B5C21 00   
0B5C22 00 
0B5C23 00 
0B5C24 00 
0B5C24 00   
0B5C25 00 
0B5C26 00 
0B5C27 00 
0B5C27 00   
0B5C28 00 
0B5C29 00 
0B5C2A 00 
0B5C2A 00   
0B5C2B 00 
0B5C2C 00 
0B5C2D 00 
0B5C2D 00   
0B5C2E 00 
0B5C2F 00 
0B5C30 00 
0B5C30 00   
0B5C31 00 
0B5C32 00 
0B5C33 00 
0B5C33 00   
0B5C34 00 
0B5C35 00 
0B5C36 00 
0B5C36 00   
0B5C37 00 
0B5C38 00 
0B5C39 00 
0B5C39 00   
0B5C3A 00 
0B5C3B 00 
0B5C3C 00 
0B5C3C 00   
0B5C3D 00 
0B5C3E 00 
0B5C3F 00 
0B5C3F 00   
0B5C40 00 
0B5C41 00 
0B5C42 00 
0B5C42 00   
0B5C43 00 
0B5C44 00 
0B5C45 00 
0B5C45 00   
0B5C46 00 
0B5C47 00 
0B5C48 00 
0B5C48 00   
0B5C49 00 
0B5C4A 00 
0B5C4B 00 
0B5C4B 00   
0B5C4C 00 
0B5C4D 00 
0B5C4E 00 
0B5C4E 00   
0B5C4F 00 
0B5C50 00 
0B5C51 00 
0B5C51 00   
0B5C52 00 
0B5C53 00 
0B5C54 00 
0B5C54 00   
0B5C55 00 
0B5C56 00 
0B5C57 00 
0B5C57 00   
0B5C58 00 
0B5C59 00 
0B5C5A 00 
0B5C5A 00   
0B5C5B 00 
0B5C5C 00 
0B5C5D 00 
0B5C5D 00   
0B5C5E 00 
0B5C5F 00 
0B5C60 00 
0B5C60 00   
0B5C61 00 
0B5C62 00 
0B5C63 00 
0B5C63 00   
0B5C64 00 
0B5C65 00 
0B5C66 00 
0B5C66 00   
0B5C67 00 
0B5C68 00 
0B5C69 00 
0B5C69 00   
0B5C6A 00 
0B5C6B 00 
0B5C6C 00 
0B5C6C 00   
0B5C6D 00 
0B5C6E 00 
0B5C6F 00 
0B5C6F 00   
0B5C70 00 
0B5C71 00 
0B5C72 00 
0B5C72 00   
0B5C73 00 
0B5C74 00 
0B5C75 00 
0B5C75 00   
0B5C76 00 
0B5C77 00 
0B5C78 00 
0B5C78 00   
0B5C79 00 
0B5C7A 00 
0B5C7B 00 
0B5C7B 00   
0B5C7C 00 
0B5C7D 00 
0B5C7E 00 
0B5C7E 00   
0B5C7F 00 
0B5C80 00 
0B5C81 00 
0B5C81 00   
0B5C82 00 
0B5C83 00 
0B5C84 00 
0B5C84 00   
0B5C85 00 
0B5C86 00 
0B5C87 00 
0B5C87 00   
0B5C88 00 
0B5C89 00 
0B5C8A 00 
0B5C8A 00   
0B5C8B 00 
0B5C8C 00 
0B5C8D 00 
0B5C8D 00   
0B5C8E 00 
0B5C8F 00 
0B5C90 00 
0B5C90 00   
0B5C91 00 
0B5C92 00 
0B5C93 00 
0B5C93 00   
0B5C94 00 
0B5C95 00 
0B5C96 00 
0B5C96 00   
0B5C97 00 
0B5C98 00 
0B5C99 00 
0B5C99 00   
0B5C9A 00 
0B5C9B 00 
0B5C9C 00 
0B5C9C 00   
0B5C9D 00 
0B5C9E 00 
0B5C9F 00 
0B5C9F 00   
0B5CA0 00 
0B5CA1 00 
0B5CA2 00 
0B5CA2 00   
0B5CA3 00 
0B5CA4 00 
0B5CA5 00 
0B5CA5 00   
0B5CA6 00 
0B5CA7 00 
0B5CA8 00 
0B5CA8 00   
0B5CA9 00 
0B5CAA 00 
0B5CAB 00 
0B5CAB 00   
0B5CAC 00 
0B5CAD 00 
0B5CAE 00 
0B5CAE 00   
0B5CAF 00 
0B5CB0 00 
0B5CB1 00 
0B5CB1 00   
0B5CB2 00 
0B5CB3 00 
0B5CB4 00 
0B5CB4 00   
0B5CB5 00 
0B5CB6 00 
0B5CB7 00 
0B5CB7 00   
0B5CB8 00 
0B5CB9 00 
0B5CBA 00 
0B5CBA 00   
0B5CBB 00 
0B5CBC 00 
0B5CBD 00 
0B5CBD 00   
0B5CBE 00 
0B5CBF 00 
0B5CC0 00 
0B5D00 00     0067* STAVAR:         BLKB    27*4,0            ; Static Variables
0B5D01 00 
0B5D02 00 
0B5D03 00 
0B5D03 00   
0B5D04 00 
0B5D05 00 
0B5D06 00 
0B5D06 00   
0B5D07 00 
0B5D08 00 
0B5D09 00 
0B5D09 00   
0B5D0A 00 
0B5D0B 00 
0B5D0C 00 
0B5D0C 00   
0B5D0D 00 
0B5D0E 00 
0B5D0F 00 
0B5D0F 00   
0B5D10 00 
0B5D11 00 
0B5D12 00 
0B5D12 00   
0B5D13 00 
0B5D14 00 
0B5D15 00 
0B5D15 00   
0B5D16 00 
0B5D17 00 
0B5D18 00 
0B5D18 00   
0B5D19 00 
0B5D1A 00 
0B5D1B 00 
0B5D1B 00   
0B5D1C 00 
0B5D1D 00 
0B5D1E 00 
0B5D1E 00   
0B5D1F 00 
0B5D20 00 
0B5D21 00 
0B5D21 00   
0B5D22 00 
0B5D23 00 
0B5D24 00 
0B5D24 00   
0B5D25 00 
0B5D26 00 
0B5D27 00 
0B5D27 00   
0B5D28 00 
0B5D29 00 
0B5D2A 00 
0B5D2A 00   
0B5D2B 00 
0B5D2C 00 
0B5D2D 00 
0B5D2D 00   
0B5D2E 00 
0B5D2F 00 
0B5D30 00 
0B5D30 00   
0B5D31 00 
0B5D32 00 
0B5D33 00 
0B5D33 00   
0B5D34 00 
0B5D35 00 
0B5D36 00 
0B5D36 00   
0B5D37 00 
0B5D38 00 
0B5D39 00 
0B5D39 00   
0B5D3A 00 
0B5D3B 00 
0B5D3C 00 
0B5D3C 00   
0B5D3D 00 
0B5D3E 00 
0B5D3F 00 
0B5D3F 00   
0B5D40 00 
0B5D41 00 
0B5D42 00 
0B5D42 00   
0B5D43 00 
0B5D44 00 
0B5D45 00 
0B5D45 00   
0B5D46 00 
0B5D47 00 
0B5D48 00 
0B5D48 00   
0B5D49 00 
0B5D4A 00 
0B5D4B 00 
0B5D4B 00   
0B5D4C 00 
0B5D4D 00 
0B5D4E 00 
0B5D4E 00   
0B5D4F 00 
0B5D50 00 
0B5D51 00 
0B5D6C 00     0068* DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
0B5D6D 00 
0B5D6E 00 
0B5D6F 00 
0B5D6F 00   
0B5D70 00 
0B5D71 00 
0B5D72 00 
0B5D72 00   
0B5D73 00 
0B5D74 00 
0B5D75 00 
0B5D75 00   
0B5D76 00 
0B5D77 00 
0B5D78 00 
0B5D78 00   
0B5D79 00 
0B5D7A 00 
0B5D7B 00 
0B5D7B 00   
0B5D7C 00 
0B5D7D 00 
0B5D7E 00 
0B5D7E 00   
0B5D7F 00 
0B5D80 00 
0B5D81 00 
0B5D81 00   
0B5D82 00 
0B5D83 00 
0B5D84 00 
0B5D84 00   
0B5D85 00 
0B5D86 00 
0B5D87 00 
0B5D87 00   
0B5D88 00 
0B5D89 00 
0B5D8A 00 
0B5D8A 00   
0B5D8B 00 
0B5D8C 00 
0B5D8D 00 
0B5D8D 00   
0B5D8E 00 
0B5D8F 00 
0B5D90 00 
0B5D90 00   
0B5D91 00 
0B5D92 00 
0B5D93 00 
0B5D93 00   
0B5D94 00 
0B5D95 00 
0B5D96 00 
0B5D96 00   
0B5D97 00 
0B5D98 00 
0B5D99 00 
0B5D99 00   
0B5D9A 00 
0B5D9B 00 
0B5D9C 00 
0B5D9C 00   
0B5D9D 00 
0B5D9E 00 
0B5D9F 00 
0B5D9F 00   
0B5DA0 00 
0B5DA1 00 
0B5DA2 00 
0B5DA2 00   
0B5DA3 00 
0B5DA4 00 
0B5DA5 00 
0B5DA5 00   
0B5DA6 00 
0B5DA7 00 
0B5DA8 00 
0B5DA8 00   
0B5DA9 00 
0B5DAA 00 
0B5DAB 00 
0B5DAB 00   
0B5DAC 00 
0B5DAD 00 
0B5DAE 00 
0B5DAE 00   
0B5DAF 00 
0B5DB0 00 
0B5DB1 00 
0B5DB1 00   
0B5DB2 00 
0B5DB3 00 
0B5DB4 00 
0B5DB4 00   
0B5DB5 00 
0B5DB6 00 
0B5DB7 00 
0B5DB7 00   
0B5DB8 00 
0B5DB9 00 
0B5DBA 00 
0B5DBA 00   
0B5DBB 00 
0B5DBC 00 
0B5DBD 00 
0B5DBD 00   
0B5DBE 00 
0B5DBF 00 
0B5DC0 00 
0B5DC0 00   
0B5DC1 00 
0B5DC2 00 
0B5DC3 00 
0B5DC3 00   
0B5DC4 00 
0B5DC5 00 
0B5DC6 00 
0B5DC6 00   
0B5DC7 00 
0B5DC8 00 
0B5DC9 00 
0B5DC9 00   
0B5DCA 00 
0B5DCB 00 
0B5DCC 00 
0B5DCC 00   
0B5DCD 00 
0B5DCE 00 
0B5DCF 00 
0B5DCF 00   
0B5DD0 00 
0B5DD1 00 
0B5DD2 00 
0B5DD2 00   
0B5DD3 00 
0B5DD4 00 
0B5DD5 00 
0B5DD5 00   
0B5DD6 00 
0B5DD7 00 
0B5DD8 00 
0B5DD8 00   
0B5DD9 00 
0B5DDA 00 
0B5DDB 00 
0B5DDB 00   
0B5DDC 00 
0B5DDD 00 
0B5DDE 00 
0B5DDE 00   
0B5DDF 00 
0B5DE0 00 
0B5DE1 00 
0B5DE1 00   
0B5DE2 00 
0B5DE3 00 
0B5DE4 00 
0B5DE4 00   
0B5DE5 00 
0B5E0E 00     0069* FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B5E0F 00 
0B5E10 00 
0B5E11 00     0070* PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B5E12 00 
0B5E13 00 
              0071* ;
0B5E14 00     0072* PAGE_:          BLKB    3,0               ; Start of User Program
0B5E15 00 
0B5E16 00 
0B5E17 00     0073* TOP:            BLKB    3,0               ; First Location after User Program
0B5E18 00 
0B5E19 00 
0B5E1A 00     0074* LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B5E1B 00 
0B5E1C 00 
0B5E1D 00     0075* FREE:           BLKB    3,0               ; First Free Space Byte
0B5E1E 00 
0B5E1F 00 
0B5E20 00     0076* HIMEM:          BLKB    3,0               ; First Protected Byte
0B5E21 00 
0B5E22 00 
              0077* ;
0B5E23 00     0078* LINENO:         BLKB    3,0               ; Line Number
0B5E24 00 
0B5E25 00 
0B5E26 00     0079* TRACEN:         BLKB    3,0               ; Trace Flag
0B5E27 00 
0B5E28 00 
0B5E29 00     0080* AUTONO:         BLKB    3,0               ; Auto Flag
0B5E2A 00 
0B5E2B 00 
0B5E2C 00     0081* ERRTRP:         BLKB    3,0               ; Error Trap
0B5E2D 00 
0B5E2E 00 
0B5E2F 00     0082* ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B5E30 00 
0B5E31 00     0083* DATPTR:         BLKB    2,0               ; Data Pointer
0B5E32 00 
0B5E33 00     0084* ERL:            BLKB    2,0               ; Error Line
0B5E34 00 
0B5E35 00     0085* ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B5E36 00 
0B5E37 00 
0B5E38 00     0086* RANDOM:         BLKB    5,0               ; Random Number
0B5E39 00 
0B5E3A 00 
0B5E3B 00 
0B5E3B 00   
0B5E3D 00     0087* COUNT:          BLKB    1,0               ; Print Position
0B5E3E 00     0088* WIDTH:          BLKB    1,0               ; Print Width
0B5E3F 00     0089* ERR:            BLKB    1,0               ; Error Number
0B5E40 00     0090* LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
              0091* ; - BIT 0: If set, output a space after the line number
              0092* ; - BIT 1: If set, then indent FOR/NEXT loops
              0093* ; - BIT 2: If set, then indent REPEAT/UNTIL loops
              0094* ; - BIT 3: If set, then output to buffer for *EDIT
              0095* ; OPT FLAG (top nibble)
              0096* ; - BIT 4: If set, then list whilst assembling
              0097* ; - BIT 5: If set, then assembler errors are reported
              0098* ; - BIT 6: If set, then place the code starting at address pointed to by O%
              0099* ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B5E41 00     0100* INCREM:         BLKB    1,0               ; Auto-Increment Value
              0101* ;
              0102* ; --------------------------------------------------------------------------------------------
              0103* ; BEGIN MODIFIED CODE
              0104* ; --------------------------------------------------------------------------------------------
              0105* ; Originally in equs.inc
              0106* ;
              0107* OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
              0108* PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
              0109* VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
              0110* ; --------------------------------------------------------------------------------------------
              0111* ; END MODIFIED CODE
              0112* ; --------------------------------------------------------------------------------------------
              0113* 
              0114* ; Extra Agon-implementation specific system variables
              0115* ;
0B5E42 00     0116* FLAGS:          BLKB    1,0       ; Miscellaneous flags
              0117* ; - BIT 7: Set if ESC pressed
              0118* ; - BIT 6: Set to disable ESC
0B5E43 00     0119* OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B5E44 00 
0B5E45 00     0120* OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
              0121* ; - 0: Console
              0122* ; - 1: File
0B5E46 00     0123* OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B5E47 00     0124* KEYDOWN:        BLKB    1,0       ; Keydown flag
0B5E48 00     0125* KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B5E49 00     0126* KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B5E4A 00     0127* R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B5E4B 00 
0B5E4C 00 
0B5E4D 00     0128* R1:             BLKB    3,0
0B5E4E 00 
0B5E4F 00 
              0129* 
              0130* ;
              0131* ; This must be at the end
              0132* ;
              0133* RAM_END:
0B5E50 FF     0134* ALIGN	256
0B5E51 FF 
0B5E52 FF 
0B5E53 FF 
0B5E53 FF   
0B5E54 FF 
0B5E55 FF 
0B5E56 FF 
0B5E56 FF   
0B5E57 FF 
0B5E58 FF 
0B5E59 FF 
0B5E59 FF   
0B5E5A FF 
0B5E5B FF 
0B5E5C FF 
0B5E5C FF   
0B5E5D FF 
0B5E5E FF 
0B5E5F FF 
0B5E5F FF   
0B5E60 FF 
0B5E61 FF 
0B5E62 FF 
0B5E62 FF   
0B5E63 FF 
0B5E64 FF 
0B5E65 FF 
0B5E65 FF   
0B5E66 FF 
0B5E67 FF 
0B5E68 FF 
0B5E68 FF   
0B5E69 FF 
0B5E6A FF 
0B5E6B FF 
0B5E6B FF   
0B5E6C FF 
0B5E6D FF 
0B5E6E FF 
0B5E6E FF   
0B5E6F FF 
0B5E70 FF 
0B5E71 FF 
0B5E71 FF   
0B5E72 FF 
0B5E73 FF 
0B5E74 FF 
0B5E74 FF   
0B5E75 FF 
0B5E76 FF 
0B5E77 FF 
0B5E77 FF   
0B5E78 FF 
0B5E79 FF 
0B5E7A FF 
0B5E7A FF   
0B5E7B FF 
0B5E7C FF 
0B5E7D FF 
0B5E7D FF   
0B5E7E FF 
0B5E7F FF 
0B5E80 FF 
0B5E80 FF   
0B5E81 FF 
0B5E82 FF 
0B5E83 FF 
0B5E83 FF   
0B5E84 FF 
0B5E85 FF 
0B5E86 FF 
0B5E86 FF   
0B5E87 FF 
0B5E88 FF 
0B5E89 FF 
0B5E89 FF   
0B5E8A FF 
0B5E8B FF 
0B5E8C FF 
0B5E8C FF   
0B5E8D FF 
0B5E8E FF 
0B5E8F FF 
0B5E8F FF   
0B5E90 FF 
0B5E91 FF 
0B5E92 FF 
0B5E92 FF   
0B5E93 FF 
0B5E94 FF 
0B5E95 FF 
0B5E95 FF   
0B5E96 FF 
0B5E97 FF 
0B5E98 FF 
0B5E98 FF   
0B5E99 FF 
0B5E9A FF 
0B5E9B FF 
0B5E9B FF   
0B5E9C FF 
0B5E9D FF 
0B5E9E FF 
0B5E9E FF   
0B5E9F FF 
0B5EA0 FF 
0B5EA1 FF 
0B5EA1 FF   
0B5EA2 FF 
0B5EA3 FF 
0B5EA4 FF 
0B5EA4 FF   
0B5EA5 FF 
0B5EA6 FF 
0B5EA7 FF 
0B5EA7 FF   
0B5EA8 FF 
0B5EA9 FF 
0B5EAA FF 
0B5EAA FF   
0B5EAB FF 
0B5EAC FF 
0B5EAD FF 
0B5EAD FF   
0B5EAE FF 
0B5EAF FF 
0B5EB0 FF 
0B5EB0 FF   
0B5EB1 FF 
0B5EB2 FF 
0B5EB3 FF 
0B5EB3 FF   
0B5EB4 FF 
0B5EB5 FF 
0B5EB6 FF 
0B5EB6 FF   
0B5EB7 FF 
0B5EB8 FF 
0B5EB9 FF 
0B5EB9 FF   
0B5EBA FF 
0B5EBB FF 
0B5EBC FF 
0B5EBC FF   
0B5EBD FF 
0B5EBE FF 
0B5EBF FF 
0B5EBF FF   
0B5EC0 FF 
0B5EC1 FF 
0B5EC2 FF 
0B5EC2 FF   
0B5EC3 FF 
0B5EC4 FF 
0B5EC5 FF 
0B5EC5 FF   
0B5EC6 FF 
0B5EC7 FF 
0B5EC8 FF 
0B5EC8 FF   
0B5EC9 FF 
0B5ECA FF 
0B5ECB FF 
0B5ECB FF   
0B5ECC FF 
0B5ECD FF 
0B5ECE FF 
0B5ECE FF   
0B5ECF FF 
0B5ED0 FF 
0B5ED1 FF 
0B5ED1 FF   
0B5ED2 FF 
0B5ED3 FF 
0B5ED4 FF 
              0135* USER:							; Must be aligned on a page boundary
              0136* 
