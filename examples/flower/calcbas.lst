PC     Output      Line
040000             0001    ;
040000             0002    ; Title:	calcbas
040000             0003    ; Author:	Brandon R. Gates
040000             0004    ; Created:	29/10/2024
040000             0005    
040000             0006    ; ========================================
040000             0007    ; MODIFIED MOSLET INITIALIZATION CODE
040000             0008    ; ========================================
040000             0009    ;
040000             0010    ; Title:	Copy - Initialisation Code
040000             0011    ; Author:	Dean Belfield, Lennart Benschop
040000             0012    ; Created:	06/11/2022
040000             0013    ; Last Updated:	26/12/2022
040000             0014    ;
040000             0015    ; Modinfo:
040000             0016    ; 17/12/2022:	Added parameter processing
040000             0017    ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
040000             0018    ; Changed:      08/04/2924 adapt to ez80asm
040000             0019    ;
040000             0020        ASSUME	ADL = 1
040000             0021        INCLUDE "mos_api.inc"
040000             0001*   ;
040000             0002*   ; Title:	AGON MOS - API for user projects
040000             0003*   ; Author:	Dean Belfield
040000             0004*   ; Created:	03/08/2022
040000             0005*   ; Last Updated:	11/11/2023
040000             0006*   ;
040000             0007*   ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0008*   ;
040000             0009*   ; Modinfo:
040000             0010*   ; 05/08/2022:	Added mos_feof
040000             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*   ; 13/10/2022:	Added mos_oscli
040000             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*   ; 19/05/2023:	Added sysvar_scrMode
040000             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*   ; 03/08/2023:	Added mos_setkbvector
040000             0028*   ; 10/08/2023:	Added mos_getkbmap
040000             0029*   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0030*   ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0031*   ;
040000             0032*   ; VDP control (VDU 23, 0, n)
040000             0033*   ;
040000             0034*   vdp_gp:			EQU 	80h
040000             0035*   vdp_keycode:		EQU 	81h
040000             0036*   vdp_cursor:		EQU	82h
040000             0037*   vdp_scrchar:		EQU	83h
040000             0038*   vdp_scrpixel:		EQU	84h
040000             0039*   vdp_audio:		EQU	85h
040000             0040*   vdp_mode:		EQU	86h
040000             0041*   vdp_rtc:		EQU	87h
040000             0042*   vdp_keystate:		EQU	88h
040000             0043*   vdp_logicalcoords:	EQU	C0h
040000             0044*   vdp_terminalmode:	EQU	FFh
040000             0045*   
040000             0046*   ; MOS high level functions
040000             0047*   ;
040000             0048*   mos_getkey:		EQU	00h
040000             0049*   mos_load:		EQU	01h
040000             0050*   mos_save:		EQU	02h
040000             0051*   mos_cd:			EQU	03h
040000             0052*   mos_dir:		EQU	04h
040000             0053*   mos_del:		EQU	05h
040000             0054*   mos_ren:		EQU	06h
040000             0055*   mos_mkdir:		EQU	07h
040000             0056*   mos_sysvars:		EQU	08h
040000             0057*   mos_editline:		EQU	09h
040000             0058*   mos_fopen:		EQU	0Ah
040000             0059*   mos_fclose:		EQU	0Bh
040000             0060*   mos_fgetc:		EQU	0Ch
040000             0061*   mos_fputc:		EQU	0Dh
040000             0062*   mos_feof:		EQU	0Eh
040000             0063*   mos_getError:		EQU	0Fh
040000             0064*   mos_oscli:		EQU	10h
040000             0065*   mos_copy:		EQU	11h
040000             0066*   mos_getrtc:		EQU	12h
040000             0067*   mos_setrtc:		EQU	13h
040000             0068*   mos_setintvector:	EQU	14h
040000             0069*   mos_uopen:		EQU	15h
040000             0070*   mos_uclose:		EQU	16h
040000             0071*   mos_ugetc:		EQU	17h
040000             0072*   mos_uputc:		EQU 	18h
040000             0073*   mos_getfil:		EQU	19h
040000             0074*   mos_fread:		EQU	1Ah
040000             0075*   mos_fwrite:		EQU	1Bh
040000             0076*   mos_flseek:		EQU	1Ch
040000             0077*   mos_setkbvector:	EQU	1Dh
040000             0078*   mos_getkbmap:		EQU	1Eh
040000             0079*   mos_i2c_open:		EQU	1Fh
040000             0080*   mos_i2c_close:		EQU	20h
040000             0081*   mos_i2c_write:		EQU	21h
040000             0082*   mos_i2c_read:		EQU	22h
040000             0083*   
040000             0084*   
040000             0085*   ; FatFS file access functions
040000             0086*   ;
040000             0087*   ffs_fopen:		EQU	80h
040000             0088*   ffs_fclose:		EQU	81h
040000             0089*   ffs_fread:		EQU	82h
040000             0090*   ffs_fwrite:		EQU	83h
040000             0091*   ffs_flseek:		EQU	84h
040000             0092*   ffs_ftruncate:		EQU	85h
040000             0093*   ffs_fsync:		EQU	86h
040000             0094*   ffs_fforward:		EQU	87h
040000             0095*   ffs_fexpand:		EQU	88h
040000             0096*   ffs_fgets:		EQU	89h
040000             0097*   ffs_fputc:		EQU	8Ah
040000             0098*   ffs_fputs:		EQU	8Bh
040000             0099*   ffs_fprintf:		EQU	8Ch
040000             0100*   ffs_ftell:		EQU	8Dh
040000             0101*   ffs_feof:		EQU	8Eh
040000             0102*   ffs_fsize:		EQU	8Fh
040000             0103*   ffs_ferror:		EQU	90h
040000             0104*   
040000             0105*   ; FatFS directory access functions
040000             0106*   ;
040000             0107*   ffs_dopen:		EQU	91h
040000             0108*   ffs_dclose:		EQU	92h
040000             0109*   ffs_dread:		EQU	93h
040000             0110*   ffs_dfindfirst:		EQU	94h
040000             0111*   ffs_dfindnext:		EQU	95h
040000             0112*   
040000             0113*   ; FatFS file and directory management functions
040000             0114*   ;
040000             0115*   ffs_stat:		EQU	96h
040000             0116*   ffs_unlink:		EQU	97h
040000             0117*   ffs_rename:		EQU	98h
040000             0118*   ffs_chmod:		EQU	99h
040000             0119*   ffs_utime:		EQU	9Ah
040000             0120*   ffs_mkdir:		EQU	9Bh
040000             0121*   ffs_chdir:		EQU	9Ch
040000             0122*   ffs_chdrive:		EQU	9Dh
040000             0123*   ffs_getcwd:		EQU	9Eh
040000             0124*   
040000             0125*   ; FatFS volume management and system configuration functions
040000             0126*   ;
040000             0127*   ffs_mount:		EQU	9Fh
040000             0128*   ffs_mkfs:		EQU	A0h
040000             0129*   ffs_fdisk:		EQU	A1h
040000             0130*   ffs_getfree:		EQU	A2h
040000             0131*   ffs_getlabel:		EQU	A3h
040000             0132*   ffs_setlabel:		EQU	A4h
040000             0133*   ffs_setcp:		EQU	A5h
040000             0134*   
040000             0135*   ; File access modes
040000             0136*   ;
040000             0137*   fa_read:		EQU	01h
040000             0138*   fa_write:		EQU	02h
040000             0139*   fa_open_existing:	EQU	00h
040000             0140*   fa_create_new:		EQU	04h
040000             0141*   fa_create_always:	EQU	08h
040000             0142*   fa_open_always:		EQU	10h
040000             0143*   fa_open_append:		EQU	30h
040000             0144*   
040000             0145*   ; System variable indexes for api_sysvars
040000             0146*   ; Index into _sysvars in globals.asm
040000             0147*   ;
040000             0148*   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0149*   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0150*   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0151*   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0152*   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0153*   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0154*   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0155*   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0156*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0157*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0158*   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0159*   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0160*   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0161*   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0162*   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0163*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0164*   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0165*   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0166*   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0167*   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0168*   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0169*   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0170*   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0171*   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0172*   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0173*   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0174*   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0175*   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0176*   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0177*   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0178*   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0179*   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0180*   ;
040000             0181*   ; Flags for the VPD protocol
040000             0182*   ;
040000             0183*   vdp_pflag_cursor:	EQU	00000001b
040000             0184*   vdp_pflag_scrchar:	EQU	00000010b
040000             0185*   vdp_pflag_point:	EQU	00000100b
040000             0186*   vdp_pflag_audio:	EQU	00001000b
040000             0187*   vdp_pflag_mode:		EQU	00010000b
040000             0188*   vdp_pflag_rtc:		EQU	00100000b
040000             0189*   vdp_pflag_mouse:	EQU	01000000b
040000             0190*   ; vdp_pflag_buffered:	EQU	10000000b
040000             0191*   
040000             0192*   
040000             0193*   ; FatFS structures
040000             0194*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0195*   ;
040000             0196*   ; Object ID and allocation information (FFOBJID)
040000             0197*   FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0198*   FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0199*   FFOBJID.attr:     EQU 5    ; Object attribute
040000             0200*   FFOBJID.stat:     EQU 6    ; Object chain status
040000             0201*   FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0202*   FFOBJID.objsize:  EQU 11   ; Object size
040000             0203*   FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0204*   ;
040000             0205*   ; File object structure (FIL)
040000             0206*   ;
040000             0207*   FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0208*   FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0209*   FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0210*   FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0211*   FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0212*   FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0213*   FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0214*   FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0215*   FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0216*   ;
040000             0217*   ; Directory object structure (DIR)
040000             0218*   ;
040000             0219*   DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0220*   DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0221*   DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0222*   DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0223*   DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0224*   DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0225*   DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0226*   DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0227*   ;
040000             0228*   ; File information structure (FILINFO)
040000             0229*   ;
040000             0230*   FILINFO.fsize:    EQU 0    ; File size
040000             0231*   FILINFO.fdate:    EQU 4    ; Modified date
040000             0232*   FILINFO.ftime:    EQU 6    ; Modified time
040000             0233*   FILINFO.fattrib:  EQU 8    ; File attribute
040000             0234*   FILINFO.altname:  EQU 9    ; Alternative file name
040000             0235*   FILINFO.fname:    EQU 22   ; Primary file name
040000             0236*   FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0237*   ;
040000             0238*   ; Macro for calling the API
040000             0239*   ; Parameters:
040000             0240*   ; - function: One of the function numbers listed above
040000             0241*   ;
040000             0242*   			MACRO MOSCALL	function
040000             0243*   			LD	A, function
040000             0244*   			RST.LIS	08h
040000             0245*   			ENDMACRO
040000             0022        ORG 0x0B0000 ; Is a moslet
0B0000             0023    
0B0000             0024        MACRO PROGNAME
0B0000             0025        ASCIZ "calcbas"
0B0000             0026        ENDMACRO
0B0000             0027    ;
0B0000             0028    ; Start in ADL mode
0B0000             0029    ;
0B0000 C3 45 00 0B 0030    			JP	_start
0B0004             0031    ;
0B0004             0032    ; The header stuff is from byte 64 onwards
0B0004             0033    ;
0B0004             0034    _exec_name:
0B0004             0035    			PROGNAME			; The executable name, only used in argv
0B0004 63 61 6C 63 0001M       ASCIZ "calcbas"
       62 61 73 00 
0B000C             0036    
0B000C FF FF FF FF 0037    			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0038    
0B0040 4D 4F 53    0039    			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0040    			DB	00h			; MOS header version 0
0B0044 01          0041    			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0042    ;
0B0045             0043    ; And the code follows on immediately after the header
0B0045             0044    ;
0B0045             0045    _start:
0B0045 F5          0046                PUSH	AF			; Preserve the registers
0B0046 C5          0047    			PUSH	BC
0B0047 D5          0048    			PUSH	DE
0B0048 DD E5       0049    			PUSH	IX
0B004A FD E5       0050    			PUSH	IY
0B004C ED 6E       0051    			LD	A, MB			; Save MB
0B004E F5          0052    			PUSH 	AF
0B004F AF          0053    			XOR 	A
0B0050 ED 6D       0054    			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0055    
0B0052             0056    ; intialize BASIC-specific stuff
0B0052 ED 73 30 4F 0057    			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       0B          
0B0057 CD A8 00 0B 0058    			CALL		_clear_ram
0B005B             0059    ; end of BASIC-specific initialization
0B005B             0060    
0B005B DD 21 00 4F 0061    			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0060 DD E5       0062    			PUSH	IX
0B0062 CD 79 00 0B 0063    			CALL	_parse_params		; Parse the parameters
0B0066 DD E1       0064    			POP	IX			; IX: argv
0B0068 06 00       0065    			LD	B, 0			;  C: argc
0B006A CD 5F 4F 0B 0066    			CALL	_main			; Start user code
0B006E             0067    
0B006E F1          0068    			POP 	AF
0B006F ED 6D       0069    			LD	MB, A
0B0071 FD E1       0070    			POP	IY			; Restore registers
0B0073 DD E1       0071    			POP	IX
0B0075 D1          0072    			POP	DE
0B0076 C1          0073    			POP	BC
0B0077 F1          0074    			POP	AF
0B0078 C9          0075    			RET
0B0079             0076    
0B0079             0077    ; Parse the parameter string into a C array
0B0079             0078    ; Parameters
0B0079             0079    ; - HL: Address of parameter string
0B0079             0080    ; - IX: Address for array pointer storage
0B0079             0081    ; Returns:
0B0079             0082    ; -  C: Number of parameters parsed
0B0079             0083    ;
0B0079 01 04 00 0B 0084    _parse_params:		LD	BC, _exec_name
0B007D DD 0F 00    0085    			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0080 ED 32 03    0086    			LEA     IX, IX+3
0B0083 CD A1 00 0B 0087    			CALL	_skip_spaces		; Skip HL past any leading spaces
0B0087             0088    ;
0B0087 01 01 00 00 0089    			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B008B 06 0F       0090    			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B008D             0091    
0B008D             0092    ; drop hl into (ix) leaving two parameters:
0B008D             0093    ; - the app name
0B008D             0094    ; - whatever the user entered
0B008D DD 2F 00    0095                ld (ix),hl
0B0090 0C          0096    			INC	C			; Increment ARGC
0B0091 C9          0097                ret
0B0092             0098    
0B0092             0099    ; Get the next token
0B0092             0100    ; Parameters:
0B0092             0101    ; - HL: Address of parameter string
0B0092             0102    ; Returns:
0B0092             0103    ; - HL: Address of first character after token
0B0092             0104    ; -  C: Length of token (in characters)
0B0092             0105    ;
0B0092 0E 00       0106    _get_token:		LD	C, 0			; Initialise length
0B0094 7E          0107    @@:			LD	A, (HL)			; Get the character from the parameter string
0B0095 B7          0108    			OR	A			; Exit if 0 (end of parameter string in MOS)
0B0096 C8          0109    			RET 	Z
0B0097 FE 0D       0110    			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B0099 C8          0111    			RET	Z
0B009A FE 20       0112    			CP	' '			; Exit if space (end of token)
0B009C C8          0113    			RET	Z
0B009D 23          0114    			INC	HL			; Advance to next character
0B009E 0C          0115    			INC 	C			; Increment length
0B009F 18 F3       0116    			JR	@B
0B00A1             0117    
0B00A1             0118    ; Skip spaces in the parameter string
0B00A1             0119    ; Parameters:
0B00A1             0120    ; - HL: Address of parameter string
0B00A1             0121    ; Returns:
0B00A1             0122    ; - HL: Address of next none-space character
0B00A1             0123    ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00A1             0124    ;
0B00A1 7E          0125    _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00A2 FE 20       0126    			CP	' '			; Exit if not space
0B00A4 C0          0127    			RET	NZ
0B00A5 23          0128    			INC	HL			; Advance to next character
0B00A6 18 F9       0129    			JR	_skip_spaces		; Increment length
0B00A8             0130    
0B00A8             0131    ; ========================================
0B00A8             0132    ; BASIC INITIALIZATION CODE FROM basic/init.asm
0B00A8             0133    ; ========================================
0B00A8             0134    ;
0B00A8             0135    ;Clear the application memory
0B00A8             0136    ;
0B00A8             0137    _clear_ram:
0B00A8 E5          0138                push hl
0B00A9 C5          0139                PUSH		BC
0B00AA 21 00 4B 0B 0140    			LD		HL, RAM_START
0B00AE 11 01 4B 0B 0141    			LD		DE, RAM_START + 1
0B00B2 01 4F 03 00 0142    			LD		BC, RAM_END - RAM_START - 1
0B00B6 AF          0143    			XOR		A
0B00B7 77          0144    			LD		(HL), A
0B00B8 ED B0       0145    			LDIR
0B00BA C1          0146    			POP		BC
0B00BB E1          0147                pop hl
0B00BC C9          0148    			RET
0B00BD             0149    
0B00BD             0150    ; ========================================
0B00BD             0151    ; BEGIN APPLICATION CODE
0B00BD             0152    ; ========================================
0B00BD             0153    
0B00BD             0154    ; API INCLUDES
0B00BD             0155    
0B00BD             0156    ; APPLICATION INCLUDES
0B00BD             0157        include "calcbas.inc"
0B00BD             0001*   ; global scratch memory for registers
0B00BD 00 00 00    0002*   uaf: dl 0
0B00C0 00 00 00    0003*   uhl: dl 0
0B00C3 00 00 00    0004*   ubc: dl 0
0B00C6 00 00 00    0005*   ude: dl 0
0B00C9 00 00 00    0006*   uix: dl 0
0B00CC 00 00 00    0007*   uiy: dl 0
0B00CF 00 00 00    0008*   usp: dl 0
0B00D2 00 00 00    0009*   upc: dl 0
0B00D5             0010*   
0B00D5 20 61 66 3D 0011*   str_afu: db " af=",0
       00          
0B00DA 20 68 6C 3D 0012*   str_hlu: db " hl=",0
       00          
0B00DF 20 62 63 3D 0013*   str_bcu: db " bc=",0
       00          
0B00E4 20 64 65 3D 0014*   str_deu: db " de=",0
       00          
0B00E9 20 69 78 3D 0015*   str_ixu: db " ix=",0
       00          
0B00EE 20 69 79 3D 0016*   str_iyu: db " iy=",0
       00          
0B00F3             0017*   
0B00F3             0018*   
0B00F3             0019*       MACRO PUSH_ALL
0B00F3             0020*           ex af,af'
0B00F3             0021*           exx
0B00F3             0022*           push af
0B00F3             0023*           push hl
0B00F3             0024*           push bc
0B00F3             0025*           push de
0B00F3             0026*   
0B00F3             0027*           ex af,af'
0B00F3             0028*           exx
0B00F3             0029*           push af
0B00F3             0030*           push hl
0B00F3             0031*           push bc
0B00F3             0032*           push de
0B00F3             0033*           push ix
0B00F3             0034*           push iy
0B00F3             0035*       ENDMACRO
0B00F3             0036*   
0B00F3             0037*       MACRO POP_ALL
0B00F3             0038*           pop iy
0B00F3             0039*           pop ix
0B00F3             0040*           pop de
0B00F3             0041*           pop bc
0B00F3             0042*           pop hl
0B00F3             0043*           pop af
0B00F3             0044*           ex af,af'
0B00F3             0045*           exx
0B00F3             0046*   
0B00F3             0047*           pop de
0B00F3             0048*           pop bc
0B00F3             0049*           pop hl
0B00F3             0050*           pop af
0B00F3             0051*           ex af,af'
0B00F3             0052*           exx
0B00F3             0053*       ENDMACRO
0B00F3             0054*   
0B00F3             0055*   ; Print a 24-bit HEX number
0B00F3             0056*   ; HLU: Number to print
0B00F3             0057*   printHex24:
0B00F3             0058*   	; PUSH	HL      ; 4 cycles
0B00F3             0059*   	; LD		HL, 2   ; 4 cycles
0B00F3             0060*   	; ADD		HL, SP  ; 1 cycle
0B00F3             0061*   	; LD		A, (HL) ; 2 cycles
0B00F3             0062*   	; POP		HL      ; 4 cycles
0B00F3             0063*       ;                 ; 15 cycles total
0B00F3 E5          0064*       push hl ; 4 cycles
0B00F4 33          0065*       inc sp ; 1 cycle
0B00F5 F1          0066*       pop af  ; 4 cycles
0B00F6 3B          0067*       dec sp ; 1 cycle
0B00F7             0068*               ; 10 cycles total
0B00F7 CD 01 01 0B 0069*   	CALL	printHex8
0B00FB             0070*   ; Print a 16-bit HEX number
0B00FB             0071*   ; HL: Number to print
0B00FB             0072*   printHex16:
0B00FB 7C          0073*   	LD		A,H
0B00FC CD 01 01 0B 0074*   	CALL	printHex8
0B0100 7D          0075*   	LD		A,L
0B0101             0076*   ; Print an 8-bit HEX number
0B0101             0077*   ; A: Number to print
0B0101             0078*   printHex8:
0B0101 4F          0079*   	LD		C,A
0B0102 1F          0080*   	RRA
0B0103 1F          0081*   	RRA
0B0104 1F          0082*   	RRA
0B0105 1F          0083*   	RRA
0B0106 CD 0B 01 0B 0084*   	CALL	@F
0B010A 79          0085*   	LD		A,C
0B010B             0086*   @@:
0B010B E6 0F       0087*   	AND		0Fh
0B010D C6 90       0088*   	ADD		A,90h
0B010F 27          0089*   	DAA
0B0110 CE 40       0090*   	ADC		A,40h
0B0112 27          0091*   	DAA
0B0113 5B D7       0092*   	RST.LIL	10h
0B0115 C9          0093*   	RET
0B0116             0094*   
0B0116             0095*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0116             0096*   ; Print a zero-terminated string
0B0116             0097*   ; HL: Pointer to string
0B0116             0098*   printString:
0B0116 C5          0099*   	PUSH	BC
0B0117 01 00 00 00 0100*   	LD		BC,0
0B011B 3E 00       0101*   	LD 	 	A,0
0B011D 5B DF       0102*   	RST.LIL 18h
0B011F C1          0103*   	POP		BC
0B0120 C9          0104*   	RET
0B0121             0105*   ; print a VDU sequence
0B0121             0106*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0121             0107*   sendVDUsequence:
0B0121 C5          0108*   	PUSH	BC
0B0122 01 00 00 00 0109*   	LD		BC, 0
0B0126 4E          0110*   	LD		C, (HL)
0B0127 5B DF       0111*   	RST.LIL	18h
0B0129 C1          0112*   	POP		BC
0B012A C9          0113*   	RET
0B012B             0114*   ; Print Newline sequence to VDP
0B012B             0115*   printNewLine:
0B012B F5          0116*       push af ; for some reason rst.lil 10h sets carry flag
0B012C 3E 0D       0117*   	LD	A, '\r'
0B012E 5B D7       0118*   	RST.LIL 10h
0B0130 3E 0A       0119*   	LD	A, '\n'
0B0132 5B D7       0120*   	RST.LIL 10h
0B0134 F1          0121*       pop af
0B0135 C9          0122*   	RET
0B0136             0123*   
0B0136             0124*   ; print registers to screen in hexidecimal format
0B0136             0125*   ; inputs: none
0B0136             0126*   ; outputs: values of every register printed to screen
0B0136             0127*   ;    values of each register in global scratch memory
0B0136             0128*   ; destroys: nothing
0B0136             0129*   dumpRegistersHex:
0B0136             0130*   ; store everything in scratch
0B0136 22 C0 00 0B 0131*       ld (uhl),hl
0B013A ED 43 C3 00 0132*       ld (ubc),bc
       0B          
0B013F ED 53 C6 00 0133*       ld (ude),de
       0B          
0B0144 DD 22 C9 00 0134*       ld (uix),ix
       0B          
0B0149 FD 22 CC 00 0135*       ld (uiy),iy
       0B          
0B014E F5          0136*       push af ; fml
0B014F E1          0137*       pop hl  ; thanks, zilog
0B0150 22 BD 00 0B 0138*       ld (uaf),hl
0B0154 F5          0139*       push af ; dammit
0B0155             0140*   
0B0155             0141*   ; home the cursor
0B0155             0142*       ; call vdu_home_cursor
0B0155             0143*       ; call printNewLine
0B0155             0144*   
0B0155             0145*   ; print each register
0B0155 21 D5 00 0B 0146*       ld hl,str_afu
0B0159 CD 16 01 0B 0147*       call printString
0B015D 2A BD 00 0B 0148*       ld hl,(uaf)
0B0161 CD F3 00 0B 0149*       call printHex24
0B0165             0150*       ; call printNewLine
0B0165             0151*   
0B0165 21 DA 00 0B 0152*       ld hl,str_hlu
0B0169 CD 16 01 0B 0153*       call printString
0B016D 2A C0 00 0B 0154*       ld hl,(uhl)
0B0171 CD F3 00 0B 0155*       call printHex24
0B0175             0156*       ; call printNewLine
0B0175             0157*   
0B0175 21 DF 00 0B 0158*       ld hl,str_bcu
0B0179 CD 16 01 0B 0159*       call printString
0B017D 2A C3 00 0B 0160*       ld hl,(ubc)
0B0181 CD F3 00 0B 0161*       call printHex24
0B0185             0162*       ; call printNewLine
0B0185             0163*   
0B0185 21 E4 00 0B 0164*       ld hl,str_deu
0B0189 CD 16 01 0B 0165*       call printString
0B018D 2A C6 00 0B 0166*       ld hl,(ude)
0B0191 CD F3 00 0B 0167*       call printHex24
0B0195             0168*       ; call printNewLine
0B0195             0169*   
0B0195 21 E9 00 0B 0170*       ld hl,str_ixu
0B0199 CD 16 01 0B 0171*       call printString
0B019D 2A C9 00 0B 0172*       ld hl,(uix)
0B01A1 CD F3 00 0B 0173*       call printHex24
0B01A5             0174*       ; call printNewLine
0B01A5             0175*   
0B01A5 21 EE 00 0B 0176*       ld hl,str_iyu
0B01A9 CD 16 01 0B 0177*       call printString
0B01AD 2A CC 00 0B 0178*       ld hl,(uiy)
0B01B1 CD F3 00 0B 0179*       call printHex24
0B01B5             0180*       ; call printNewLine
0B01B5             0181*   
0B01B5             0182*       ; call vdu_vblank
0B01B5             0183*   
0B01B5 CD 2B 01 0B 0184*       call printNewLine
0B01B9             0185*   ; restore everything
0B01B9 2A C0 00 0B 0186*       ld hl, (uhl)
0B01BD ED 4B C3 00 0187*       ld bc, (ubc)
       0B          
0B01C2 ED 5B C6 00 0188*       ld de, (ude)
       0B          
0B01C7 DD 2A C9 00 0189*       ld ix, (uix)
       0B          
0B01CC FD 2A CC 00 0190*       ld iy, (uiy)
       0B          
0B01D1 F1          0191*       pop af
0B01D2             0192*   ; all done
0B01D2 C9          0193*       ret
0B01D3             0194*   
0B01D3             0195*   
0B01D3             0196*   ; print bytes from an address to the screen in hexidecimal format
0B01D3             0197*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B01D3             0198*   ; outputs: values of each byte printed to screen separated by spaces
0B01D3             0199*   ; destroys: nothing
0B01D3             0200*   dumpMemoryHex:
0B01D3             0201*   ; save registers to the stack
0B01D3 C5          0202*       push bc
0B01D4 E5          0203*       push hl
0B01D5 F5          0204*       push af
0B01D6             0205*   
0B01D6             0206*   ; print the address and separator
0B01D6 CD F3 00 0B 0207*       call printHex24
0B01DA 3E 3A       0208*       ld a,':'
0B01DC 5B D7       0209*       rst.lil 10h
0B01DE 3E 20       0210*       ld a,' '
0B01E0 5B D7       0211*       rst.lil 10h
0B01E2             0212*   
0B01E2             0213*   ; set b to be our loop counter
0B01E2 F1          0214*       pop af
0B01E3 47          0215*       ld b,a
0B01E4 E1          0216*       pop hl
0B01E5 E5          0217*       push hl
0B01E6 F5          0218*       push af
0B01E7             0219*   @loop:
0B01E7             0220*   ; print the byte
0B01E7 7E          0221*       ld a,(hl)
0B01E8 CD 01 01 0B 0222*       call printHex8
0B01EC             0223*   ; print a space
0B01EC 3E 20       0224*       ld a,' '
0B01EE 5B D7       0225*       rst.lil 10h
0B01F0 23          0226*       inc hl
0B01F1 10 F4       0227*       djnz @loop
0B01F3 CD 2B 01 0B 0228*       call printNewLine
0B01F7             0229*   
0B01F7             0230*   ; restore everything
0B01F7 F1          0231*       pop af
0B01F8 E1          0232*       pop hl
0B01F9 C1          0233*       pop bc
0B01FA             0234*   
0B01FA             0235*   ; all done
0B01FA C9          0236*       ret
0B01FB             0158        include "mathfpp.inc"
0B01FB             0001*   ;
0B01FB             0002*   ; print a floating point number in decimal format
0B01FB             0003*   ; inputs: HL'H'L'C is the number to print
0B01FB             0004*   ; outputs: number printed to screen
0B01FB             0005*   ;          STROUT null-terminated string representation of the number
0B01FB             0006*   ; destroys: everything
0B01FB             0007*   print_float_dec:
0B01FB CD 64 0A 0B 0008*       call STR ; convert the number to a string
0B01FF 21 00 4B 0B 0009*       ld hl,ACCS ; point to the string accumulator
0B0203 CD 16 01 0B 0010*       call printString
0B0207 C9          0011*       ret
0B0208             0159        include "basic/basic.asm" ; must be last so that RAM has room for BASIC operations
0B0208             0001*       ; include "basic/mos_api.inc"
0B0208             0002*       include "basic/macros.inc"
0B0208             0001**  	; Title:	BBC Basic Interpreter - Z80 version
0B0208             0002**  	;		Useful macros
0B0208             0003**  	; Author:	Dean Belfield
0B0208             0004**  	; Created:	12/05/2023
0B0208             0005**  	; Last Updated:	11/06/2023
0B0208             0006**  	;
0B0208             0007**  	; Modinfo:
0B0208             0008**  	; 11/06/2023:	Modified to run in ADL mode
0B0208             0009**  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
0B0208             0010**  
0B0208             0011**  	MACRO EXREG	rp1, rp2
0B0208             0012**  		PUSH	rp1
0B0208             0013**  		POP	rp2
0B0208             0014**  	ENDMACRO
0B0208             0015**  
0B0208             0016**  	; MACRO ADD8U_DE	reg
0B0208             0017**  		MACRO ADD8U_DE
0B0208             0018**  		ADD	A, E
0B0208             0019**  		LD	E, A
0B0208             0020**  		ADC	A, D
0B0208             0021**  		SUB	E
0B0208             0022**  		LD	D, A
0B0208             0023**  	ENDMACRO
0B0208             0024**  
0B0208             0025**  	; MACRO ADD8U_HL	reg
0B0208             0026**  	MACRO ADD8U_HL
0B0208             0027**  		ADD	A, L
0B0208             0028**  		LD	L, A
0B0208             0029**  		ADC	A, H
0B0208             0030**  		SUB	L
0B0208             0031**  		LD	H, A
0B0208             0032**  	ENDMACRO
0B0208             0033**  
0B0208             0034**  	MACRO VDU	val
0B0208             0035**  		LD	A, val
0B0208             0036**  		CALL	OSWRCH
0B0208             0037**  	ENDMACRO
0B0208             0038**  
0B0208             0039**  	MACRO SET_GPIO	reg, val
0B0208             0040**  		IN0	A, (reg)
0B0208             0041**  		OR	val
0B0208             0042**  		OUT0	(reg), A
0B0208             0043**  	ENDMACRO
0B0208             0044**  
0B0208             0045**  	MACRO RES_GPIO	reg, val
0B0208             0046**  		PUSH	BC
0B0208             0047**  		LD	A, val
0B0208             0048**  		CPL
0B0208             0049**  		LD	C, A
0B0208             0050**  		IN0	A, (reg)
0B0208             0051**  		AND	C
0B0208             0052**  		OUT0	(reg), A
0B0208             0053**  		POP	BC
0B0208             0054**  	ENDMACRO
0B0208             0003*       include "basic/equs.inc"
0B0208             0001**  ;
0B0208             0002**  ; Title:	BBC Basic for AGON - Equs
0B0208             0003**  ; Author:	Dean Belfield
0B0208             0004**  ; Created:	12/05/2023
0B0208             0005**  ; Last Updated:	08/06/2023
0B0208             0006**  ;
0B0208             0007**  ; Modinfo:
0B0208             0008**  ; 08/06/2023:	Added SIZEW
0B0208             0009**  
0B0208             0010**  			; XREF		STAVAR
0B0208             0011**  			; XREF		ACCS
0B0208             0012**  
0B0208             0013**  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
0B0208             0014**  ;Stack_Top:		EQU		0000h	; Stack at top
0B0208             0015**  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
0B0208             0016**  
0B0208             0017**  ; For GPIO
0B0208             0018**  ; PA not available on eZ80L92
0B0208             0019**  ;
0B0208             0020**  PA_DR:			EQU		96h
0B0208             0021**  PA_DDR:			EQU		97h
0B0208             0022**  PA_ALT1:		EQU		98h
0B0208             0023**  PA_ALT2:		EQU		99h
0B0208             0024**  PB_DR:          	EQU		9Ah
0B0208             0025**  PB_DDR:        	 	EQU		9Bh
0B0208             0026**  PB_ALT1:        	EQU		9Ch
0B0208             0027**  PB_ALT2:        	EQU		9Dh
0B0208             0028**  PC_DR:          	EQU		9Eh
0B0208             0029**  PC_DDR:         	EQU		9Fh
0B0208             0030**  PC_ALT1:        	EQU		A0h
0B0208             0031**  PC_ALT2:        	EQU		A1h
0B0208             0032**  PD_DR:          	EQU		A2h
0B0208             0033**  PD_DDR:			EQU		A3h
0B0208             0034**  PD_ALT1:		EQU		A4h
0B0208             0035**  PD_ALT2:		EQU		A5h
0B0208             0036**  
0B0208             0037**  GPIOMODE_OUT:		EQU		0	; Output
0B0208             0038**  GPIOMODE_IN:		EQU		1	; Input
0B0208             0039**  GPIOMODE_DIO:		EQU		2	; Open Drain IO
0B0208             0040**  GPIOMODE_SIO:		EQU		3	; Open Source IO
0B0208             0041**  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
0B0208             0042**  GPIOMODE_ALTF:		EQU		5;	; Alt Function
0B0208             0043**  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
0B0208             0044**  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
0B0208             0045**  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
0B0208             0046**  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
0B0208             0047**  
0B0208             0048**  ; ; Originally in ram.asm
0B0208             0049**  ; ;
0B0208             0050**  ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
0B0208             0051**  ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
0B0208             0052**  ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
0B0208             0053**  
0B0208             0054**  ; Originally in main.asm
0B0208             0055**  ;
0B0208             0056**  CR:			EQU     0DH
0B0208             0057**  LF:			EQU     0AH
0B0208             0058**  ESC:			EQU     1BH
0B0208             0004*       ; include "basic/init.asm" ; relevant bits folded into calcbas.asm
0B0208             0005*       include "basic/eval.asm"
0B0208             0001**  ;
0B0208             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B0208             0003**  ;		Expression Evaluation & Arithmetic Module - "EVAL"
0B0208             0004**  ; Author:	(C) Copyright  R.T.Russell  1984
0B0208             0005**  ; Modified By:	Dean Belfield
0B0208             0006**  ; Created:	12/05/2023
0B0208             0007**  ; Last Updated:	17/08/2023
0B0208             0008**  ;
0B0208             0009**  ; Modinfo:
0B0208             0010**  ; 07/06/2023:	Modified to run in ADL mode
0B0208             0011**  ; 26/06/2023:	Fixed HEX and HEXSTR
0B0208             0012**  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
0B0208             0013**  ; 17/08/2023:	Added binary constants
0B0208             0014**  
0B0208             0015**  			; .ASSUME	ADL = 1
0B0208             0016**  
0B0208             0017**  			; INCLUDE	"equs.inc"
0B0208             0018**  			; INCLUDE "macros.inc"
0B0208             0019**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B0208             0020**  
0B0208             0021**  			; SEGMENT CODE
0B0208             0022**  
0B0208             0023**  			; XDEF	EXPR
0B0208             0024**  			; XDEF	EXPRN
0B0208             0025**  			; XDEF	EXPRI
0B0208             0026**  			; XDEF	EXPRS
0B0208             0027**  			; XDEF	ITEMI
0B0208             0028**  			; XDEF	LOADN
0B0208             0029**  			; XDEF	LOAD4
0B0208             0030**  			; XDEF	CONS
0B0208             0031**  			; XDEF	LOADS
0B0208             0032**  			; XDEF	SFIX
0B0208             0033**  			; XDEF	VAL0
0B0208             0034**  			; XDEF	SEARCH
0B0208             0035**  			; XDEF	SWAP
0B0208             0036**  			; XDEF	TEST
0B0208             0037**  			; XDEF	DECODE
0B0208             0038**  			; XDEF	HEXSTR
0B0208             0039**  			; XDEF	STR
0B0208             0040**  			; XDEF	ZERO
0B0208             0041**  			; XDEF	PUSHS
0B0208             0042**  			; XDEF	POPS
0B0208             0043**  			; XDEF	COMMA
0B0208             0044**  			; XDEF	BRAKET
0B0208             0045**  			; XDEF	NXT
0B0208             0046**  			; XDEF	COUNT0
0B0208             0047**  
0B0208             0048**  			; XREF	ADVAL
0B0208             0049**  			; XREF	FN_EX
0B0208             0050**  			; XREF	POINT
0B0208             0051**  			; XREF	USR
0B0208             0052**  			; XREF	SYNTAX
0B0208             0053**  			; XREF	ERROR_
0B0208             0054**  			; XREF	CHECK
0B0208             0055**  			; XREF	GETVAR
0B0208             0056**  			; XREF	LISTON
0B0208             0057**  			; XREF	RANGE
0B0208             0058**  			; XREF	FPP
0B0208             0059**  			; XREF	GETCSR
0B0208             0060**  			; XREF	CHANEL
0B0208             0061**  			; XREF	OSSTAT
0B0208             0062**  			; XREF	OSBGET
0B0208             0063**  			; XREF	LOMEM
0B0208             0064**  			; XREF	HIMEM
0B0208             0065**  			; XREF	PAGE_
0B0208             0066**  			; XREF	TOP
0B0208             0067**  			; XREF	ERL
0B0208             0068**  			; XREF	ERR
0B0208             0069**  			; XREF	COUNT
0B0208             0070**  			; XREF	OSOPEN
0B0208             0071**  			; XREF	GETEXT
0B0208             0072**  			; XREF	GETPTR
0B0208             0073**  			; XREF	GETIME
0B0208             0074**  			; XREF	GETIMS
0B0208             0075**  			; XREF	LEXAN2
0B0208             0076**  			; XREF	RANDOM
0B0208             0077**  			; XREF	STORE5
0B0208             0078**  			; XREF	GETSCHR
0B0208             0079**  			; XREF	OSRDCH
0B0208             0080**  			; XREF	OSKEY
0B0208             0081**  			; XREF	INKEY1
0B0208             0082**  			; XREF	EXTERR
0B0208             0083**  ;
0B0208             0084**  ; BINARY FLOATING POINT REPRESENTATION:
0B0208             0085**  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B0208             0086**  ;     8 BIT EXCESS-128 SIGNED EXPONENT
0B0208             0087**  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B0208             0088**  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B0208             0089**  ;
0B0208             0090**  ; BINARY INTEGER REPRESENTATION:
0B0208             0091**  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B0208             0092**  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B0208             0093**  ;
0B0208             0094**  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B0208             0095**  ;                             EXPONENT - C
0B0208             0096**  ;
0B0208             0097**  
0B0208             0098**  ;
0B0208             0099**  ; Table of addresses for functions
0B0208             0100**  ;
0B0208             0101**  FUNTOK:			EQU	8DH			; First token number
0B0208             0102**  ;
0B0208 E4 09 0B    0103**  FUNTBL:			DW24	DECODE			; Line number
0B020B 92 06 0B    0104**  			DW24	OPENIN			; OPENIN
0B020E B4 06 0B    0105**  			DW24	PTR_EV			; PTR
0B0211 4E 06 0B    0106**  			DW24	PAGEV			; PAGE
0B0214 BE 06 0B    0107**  			DW24	TIMEV			; TIME
0B0217 3A 06 0B    0108**  			DW24	LOMEMV			; LOMEM
0B021A 44 06 0B    0109**  			DW24	HIMEMV			; HIMEM
0B021D 12 07 0B    0110**  			DW24	ABSV			; ABS
0B0220 4E 07 0B    0111**  			DW24	ACS			; ACS
0B0223 B5 44 0B    0112**  			DW24	ADVAL			; ADVAL
0B0226 23 06 0B    0113**  			DW24	ASC			; ASC
0B0229 46 07 0B    0114**  			DW24	ASN			; ASN
0B022C 4A 07 0B    0115**  			DW24	ATN			; ATN
0B022F EC 05 0B    0116**  			DW24	BGET			; BGET
0B0232 32 07 0B    0117**  			DW24	COS			; COS
0B0235 79 06 0B    0118**  			DW24	COUNTV			; COUNT
0B0238 1A 07 0B    0119**  			DW24	DEG			; DEG
0B023B 6D 06 0B    0120**  			DW24	ERLV			; ERL
0B023E 73 06 0B    0121**  			DW24	ERRV			; ERR
0B0241 77 07 0B    0122**  			DW24	EVAL_			; EVAL
0B0244 3A 07 0B    0123**  			DW24	EXP			; EXP
0B0247 AA 06 0B    0124**  			DW24	EXT			; EXT
0B024A 91 0A 0B    0125**  			DW24	ZERO			; FALSE
0B024D 7D 11 0B    0126**  			DW24	FN_EX			; FN
0B0250 0A 06 0B    0127**  			DW24	GET			; GET
0B0253 F9 05 0B    0128**  			DW24	INKEY			; INKEY
0B0256 29 08 0B    0129**  			DW24	INSTR			; INSTR(
0B0259 26 07 0B    0130**  			DW24	INT_			; INT
0B025C 33 06 0B    0131**  			DW24	LEN			; LEN
0B025F 3E 07 0B    0132**  			DW24	LN			; LN
0B0262 42 07 0B    0133**  			DW24	LOG			; LOG
0B0265 16 07 0B    0134**  			DW24	NOTK			; NOT
0B0268 8E 06 0B    0135**  			DW24	OPENUP			; OPENUP
0B026B 8B 06 0B    0136**  			DW24	OPENOT			; OPENOUT
0B026E 0E 07 0B    0137**  			DW24	PI			; PI
0B0271 67 45 0B    0138**  			DW24	POINT			; POINT(
0B0274 CB 05 0B    0139**  			DW24	POS			; POS
0B0277 1E 07 0B    0140**  			DW24	RAD			; RAD
0B027A AB 07 0B    0141**  			DW24	RND			; RND
0B027D 22 07 0B    0142**  			DW24	SGN			; SGN
0B0280 36 07 0B    0143**  			DW24	SIN			; SIN
0B0283 2A 07 0B    0144**  			DW24	SQR			; SQR
0B0286 2E 07 0B    0145**  			DW24	TAN			; TAN
0B0289 58 06 0B    0146**  			DW24	TOPV			; TO(P)
0B028C 03 07 0B    0147**  			DW24	TRUE			; TRUE
0B028F 20 16 0B    0148**  			DW24	USR			; USR
0B0292 68 07 0B    0149**  			DW24	VAL			; VAL
0B0295 D4 05 0B    0150**  			DW24	VPOS			; VPOS
0B0298 BD 08 0B    0151**  			DW24	CHRS			; CHRS
0B029B C5 08 0B    0152**  			DW24	GETS			; GETS
0B029E D6 08 0B    0153**  			DW24	INKEYS			; INKEYS
0B02A1 5B 09 0B    0154**  			DW24	LEFTS			; LEFTS(
0B02A4 23 09 0B    0155**  			DW24	MIDS			; MIDS(
0B02A7 7B 09 0B    0156**  			DW24	RIGHTS			; RIGHTS(
0B02AA 48 0A 0B    0157**  			DW24	STRS			; STR$
0B02AD 9C 09 0B    0158**  			DW24	STRING_			; STRINGS(
0B02B0 DC 05 0B    0159**  			DW24	EOF			; EOF
0B02B3             0160**  ;
0B02B3             0161**  FUNTBL_END:		EQU	$
0B02B3             0162**  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0B02B3             0163**  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0B02B3             0164**  
0B02B3             0165**  ANDK:			EQU     80H
0B02B3             0166**  DIVK:			EQU     81H
0B02B3             0167**  EORK:			EQU     82H
0B02B3             0168**  MODK:			EQU     83H
0B02B3             0169**  ORK:			EQU     84H
0B02B3             0170**  ;
0B02B3 EE 06 0B    0171**  SOPTBL:			DW24	SLE			; <= (STRING)
0B02B6 F7 06 0B    0172**  			DW24	SNE			; <>
0B02B9 E7 06 0B    0173**  			DW24	SGE			; >=
0B02BC D8 06 0B    0174**  			DW24	SLT			; <
0B02BF FE 06 0B    0175**  			DW24	SEQ			; =
0B02C2 DF 06 0B    0176**  			DW24	SGT			; >
0B02C5             0177**  ;
0B02C5             0178**  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0B02C5             0179**  ;     Expression type is returned in A'F':
0B02C5             0180**  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0B02C5             0181**  ;         String - A' bit 7=1, F' sign bit set.
0B02C5             0182**  ; Floating-point or integer result returned in HLH'L'C
0B02C5             0183**  ; Integer result denoted by C=0 and HLH'L' non-zero.
0B02C5             0184**  ; String result returned in string accumulator, DE set.
0B02C5             0185**  ;
0B02C5             0186**  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0B02C5             0187**  ;               (2) ^
0B02C5             0188**  ;               (3) * / MOD DIV
0B02C5             0189**  ;               (4) + -
0B02C5             0190**  ;               (5) = <> <= >= > <
0B02C5             0191**  ;               (6) AND
0B02C5             0192**  ;               (7) EOR OR
0B02C5             0193**  
0B02C5             0194**  ;
0B02C5             0195**  ; Level 7: EOR and OR
0B02C5             0196**  ;
0B02C5 CD DE 02 0B 0197**  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0B02C9 FE 82       0198**  EXPR0A:			CP      EORK            	; Is operator EOR?
0B02CB 28 03       0199**  			JR      Z,EXPR0B		; Yes, so skip to next bit
0B02CD FE 84       0200**  			CP      ORK			; Is operator OR
0B02CF C0          0201**  			RET     NZ			; No, so return
0B02D0             0202**  ;
0B02D0 CD 3C 0B 0B 0203**  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0B02D4 CD DE 02 0B 0204**  			CALL    EXPR1           	; Get second operand
0B02D8 CD 4B 0B 0B 0205**  			CALL    DOIT            	; Do the operation
0B02DC 18 EB       0206**  			JR      EXPR0A          	; And continue
0B02DE             0207**  ;
0B02DE             0208**  ; Level 6: AND
0B02DE             0209**  ;
0B02DE CD F3 02 0B 0210**  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0B02E2 FE 80       0211**  EXPR1A:			CP      ANDK			; Is operator AND?
0B02E4 C0          0212**  			RET     NZ			; No, so return
0B02E5 CD 3C 0B 0B 0213**  			CALL    SAVE_EV			; Save first operand
0B02E9 CD F3 02 0B 0214**  			CALL    EXPR2			; Get second operand
0B02ED CD 4B 0B 0B 0215**  			CALL    DOIT			; Do the operation
0B02F1 18 EF       0216**  			JR      EXPR1A			; And continue
0B02F3             0217**  ;
0B02F3             0218**  ; Level 5: Comparisons
0B02F3             0219**  ;
0B02F3 CD 65 03 0B 0220**  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0B02F7 CD 13 0B 0B 0221**  			CALL    RELOP?			; Is it ">", "=" or "<"?
0B02FB C0          0222**  			RET     NZ			; No, so return
0B02FC 47          0223**  			LD      B,A			; Store the first operator in B
0B02FD FD 23       0224**  			INC     IY              	; Bump over operator
0B02FF CD 6E 0B 0B 0225**  			CALL    NXT			;
0B0303 CD 13 0B 0B 0226**  			CALL    RELOP?          	; Is it a compound operator?
0B0307 20 09       0227**  			JR      NZ,EXPR2B		; No, so skip next bit
0B0309 FD 23       0228**  			INC     IY			; Bump over operator
0B030B B8          0229**  			CP      B			; Compare with first
0B030C CA 95 0D 0B 0230**  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
0B0310 80          0231**  			ADD     A,B
0B0311 47          0232**  			LD      B,A			; B: Unique code for the compound operator
0B0312 78          0233**  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
0B0313 08          0234**  			EX      AF,AF'
0B0314 FA 2E 03 0B 0235**  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
0B0318 08          0236**  			EX      AF,AF'
0B0319 D6 04       0237**  			SUB     4
0B031B FE 3A       0238**  			CP      '>'-4
0B031D 20 02       0239**  			JR      NZ,EXPR2C
0B031F C6 02       0240**  			ADD     A,2
0B0321 CD 3E 0B 0B 0241**  EXPR2C:			CALL    SAVE1
0B0325 CD 65 03 0B 0242**  			CALL    EXPR3
0B0329 CD 4B 0B 0B 0243**  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
0B032D C9          0244**  			RET
0B032E             0245**  ;
0B032E 08          0246**  EXPR2S:			EX      AF,AF'			; Handle string comparisons
0B032F 3D          0247**  			DEC     A
0B0330 E6 07       0248**  			AND     7
0B0332 CD B2 0A 0B 0249**  			CALL    PUSHS           	; Save string on the stack
0B0336 F5          0250**  			PUSH    AF              	; Save the operator
0B0337 CD 65 03 0B 0251**  			CALL    EXPR3           	; Get the second string
0B033B 08          0252**  			EX      AF,AF'
0B033C F2 34 04 0B 0253**  			JP      P,TYPE_EV_
0B0340 F1          0254**  			POP     AF
0B0341 4B          0255**  			LD      C,E             	; Length of string #2
0B0342 D1          0256**  			POP     DE
0B0343 21 00 00 00 0257**  			LD      HL,0
0B0347 39          0258**  			ADD     HL,SP
0B0348 43          0259**  			LD      B,E             	; Length of string #1
0B0349 D5          0260**  			PUSH    DE
0B034A 11 00 4B 0B 0261**  			LD      DE,ACCS
0B034E EB          0262**  			EX      DE,HL
0B034F CD 7A 0B 0B 0263**  			CALL    DISPT2
0B0353 D1          0264**  			POP     DE
0B0354 EB          0265**  			EX      DE,HL
0B0355 7D          0266**  			LD	A,L
0B0356 21 00 00 00 0267**  			LD	HL,0
0B035A 6F          0268**  			LD	L,A
0B035B 39          0269**  			ADD     HL,SP
0B035C F9          0270**  			LD      SP,HL
0B035D EB          0271**  			EX      DE,HL
0B035E AF          0272**  			XOR     A               	; Numeric marker
0B035F 4F          0273**  			LD      C,A             	; Integer marker
0B0360 08          0274**  			EX      AF,AF'
0B0361 FD 7E 00    0275**  			LD      A,(IY)
0B0364 C9          0276**  			RET
0B0365             0277**  ;
0B0365             0278**  ; Level 4: + and -
0B0365             0279**  ;
0B0365 CD C2 03 0B 0280**  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
0B0369 FE 2D       0281**  EXPR3A:			CP      '-'			; Is it "-"?
0B036B 28 09       0282**  			JR      Z,EXPR3B		; Yes, so skip the next bit
0B036D FE 2B       0283**  			CP      '+'			; Is it "+"?
0B036F C0          0284**  			RET     NZ			; No, so return
0B0370 08          0285**  			EX      AF,AF'			; Get the type
0B0371 FA 84 03 0B 0286**  			JP      M,EXPR3S		; Branch here if string
0B0375 08          0287**  			EX      AF,AF'
0B0376 CD 3C 0B 0B 0288**  EXPR3B:			CALL    SAVE_EV			; Save the first operator
0B037A CD C2 03 0B 0289**  			CALL    EXPR4			; Fetch the second operator
0B037E CD 4B 0B 0B 0290**  			CALL    DOIT			; Do the operation
0B0382 18 E5       0291**  			JR      EXPR3A			; And continue
0B0384             0292**  ;
0B0384 08          0293**  EXPR3S:			EX      AF,AF'			; Handle string concatenation
0B0385 FD 23       0294**  			INC     IY              	; Bump past the "+"
0B0387 CD B2 0A 0B 0295**  			CALL    PUSHS           	; Save the string on the stack
0B038B CD C2 03 0B 0296**  			CALL    EXPR4           	; Fetch the second operator
0B038F 08          0297**  			EX      AF,AF'
0B0390 F2 34 04 0B 0298**  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0B0394 01 00 00 00 0299**  			LD	BC, 0			; Clear BC
0B0398 4B          0300**  			LD      C,E             	; C: Length of the second string
0B0399 D1          0301**  			POP     DE
0B039A D5          0302**  			PUSH    DE
0B039B 21 00 4B 0B 0303**  			LD      HL,ACCS
0B039F             0304**  ; BEGIN MISSING FROM BINARY
0B039F             0305**  			; LD	A,E			;  E: Length of the first string
0B039F             0306**  			; LD      DE,ACCS
0B039F             0307**  			; LD	E,A 			; DE: Pointer to the end of the first string
0B039F             0308**  ; END MISSING FROM BINARY
0B039F 54          0309**  			LD		D,H ; ADDED FROM BINARY
0B03A0 79          0310**  			LD      A,C
0B03A1 B7          0311**  			OR      A
0B03A2 28 0F       0312**  			JR      Z,EXP3S3
0B03A4 6F          0313**  			LD      L,A             	; Source
0B03A5 83          0314**  			ADD     A,E
0B03A6 5F          0315**  			LD      E,A             	; Destination
0B03A7 3E 13       0316**  			LD      A,19
0B03A9 DA 5E 38 0B 0317**  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0B03AD D5          0318**  			PUSH    DE
0B03AE 1D          0319**  			DEC     E
0B03AF 2D          0320**  			DEC     L
0B03B0 ED B8       0321**  			LDDR                    	; Copy
0B03B2 D1          0322**  			POP     DE
0B03B3 D9          0323**  EXP3S3:			EXX
0B03B4 C1          0324**  			POP     BC
0B03B5 CD DC 0A 0B 0325**  			CALL    POPS            	; Restore from stack
0B03B9 D9          0326**  			EXX
0B03BA F6 80       0327**  			OR      80H             	; Flag as a string
0B03BC 08          0328**  			EX      AF,AF'
0B03BD FD 7E 00    0329**  			LD      A,(IY)			; Fetch the next character
0B03C0 18 A7       0330**  			JR      EXPR3A			; And continue
0B03C2             0331**  ;
0B03C2             0332**  ; Level 3: * / MOD DIV
0B03C2             0333**  ;
0B03C2 CD E3 03 0B 0334**  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0B03C6 FE 2A       0335**  EXPR4A:			CP      '*'			; "*" is valid
0B03C8 28 0B       0336**  			JR      Z,EXPR4B
0B03CA FE 2F       0337**  			CP      '/'			; "/" is valid
0B03CC 28 07       0338**  			JR      Z,EXPR4B
0B03CE FE 83       0339**  			CP      MODK			; MOD token is valid
0B03D0 28 03       0340**  			JR      Z,EXPR4B
0B03D2 FE 81       0341**  			CP      DIVK			; DIV token is valid
0B03D4 C0          0342**  			RET     NZ			; And return if it is anything else
0B03D5 CD 3C 0B 0B 0343**  EXPR4B:			CALL    SAVE_EV
0B03D9 CD E3 03 0B 0344**  			CALL    EXPR5
0B03DD CD 4B 0B 0B 0345**  			CALL    DOIT
0B03E1 18 E3       0346**  			JR      EXPR4A
0B03E3             0347**  ;
0B03E3             0348**  ; Level 2: ^
0B03E3             0349**  ;
0B03E3 CD C3 04 0B 0350**  EXPR5:			CALL    ITEM			; Get variable
0B03E7 B7          0351**  			OR      A               	; Test type
0B03E8 08          0352**  			EX      AF,AF'          	; Save type
0B03E9 CD 6E 0B 0B 0353**  EXPR5A:			CALL    NXT			; Skip spaces
0B03ED FE 5E       0354**  			CP      '^'			; Is the operator "^"?
0B03EF C0          0355**  			RET     NZ			; No, so return
0B03F0 CD 3C 0B 0B 0356**  			CALL    SAVE_EV			; Save first operand
0B03F4 CD C3 04 0B 0357**  			CALL    ITEM			; Get second operand
0B03F8 B7          0358**  			OR      A			; Test type
0B03F9 08          0359**  			EX      AF,AF'			; Save type
0B03FA CD 4B 0B 0B 0360**  			CALL    DOIT			; Do the operation
0B03FE 18 E9       0361**  			JR      EXPR5A			; And continue
0B0400             0362**  ;
0B0400             0363**  ; Evaluate a numeric expression
0B0400             0364**  ;
0B0400 CD C5 02 0B 0365**  EXPRN:			CALL    EXPR			; Evaluate expression
0B0404 08          0366**  			EX      AF,AF'			; Get the type
0B0405 F0          0367**  			RET     P			; And return if it is a number
0B0406 18 2C       0368**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B0408             0369**  ;
0B0408             0370**  ; Evaluate a fixed-point expression
0B0408             0371**  ;
0B0408 CD C5 02 0B 0372**  EXPRI:			CALL    EXPR			; Evaluate the expression
0B040C 08          0373**  			EX      AF,AF'			; Get the type
0B040D F2 60 07 0B 0374**  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B0411 18 21       0375**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B0413             0376**  ;
0B0413             0377**  ; Evaluate a string expression
0B0413             0378**  ;
0B0413 CD C5 02 0B 0379**  EXPRS:			CALL    EXPR			; Evaluate the expression
0B0417 08          0380**  			EX      AF,AF'			; Get the type
0B0418 F8          0381**  			RET     M			; And return if it is a string
0B0419 18 19       0382**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B041B             0383**  ;
0B041B             0384**  ; Get a numeric variable
0B041B             0385**  ;
0B041B CD C3 04 0B 0386**  ITEMN:			CALL    ITEM			; Get the variable
0B041F B7          0387**  			OR      A			; Test the type
0B0420 F0          0388**  			RET     P			; And return if it is a number
0B0421 18 11       0389**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B0423             0390**  ;
0B0423             0391**  ; Get a fixed-point variable
0B0423             0392**  ;
0B0423 CD C3 04 0B 0393**  ITEMI:			CALL    ITEM			; Get the variable
0B0427 B7          0394**  			OR      A			; Test the type
0B0428 F2 60 07 0B 0395**  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B042C 18 06       0396**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B042E             0397**  ;
0B042E             0398**  ; Get a string variable
0B042E             0399**  ;
0B042E CD C3 04 0B 0400**  ITEMS:			CALL    ITEM			; Get the variable
0B0432 B7          0401**  			OR      A			; Test the type
0B0433 F8          0402**  			RET     M			; If it is a string, then return
0B0434             0403**  ;							; Otherwise
0B0434 3E 06       0404**  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
0B0436 C3 5E 38 0B 0405**  			JP      ERROR_
0B043A             0406**  ;
0B043A             0407**  ; Evaluate a bracketed expression
0B043A             0408**  ;
0B043A CD C5 02 0B 0409**  ITEM1:			CALL    EXPR            	; Evaluate the expression
0B043E CD 2D 0B 0B 0410**  			CALL    BRAKET			; Check for closing bracket
0B0442 08          0411**  			EX      AF,AF'
0B0443 C9          0412**  			RET
0B0444             0413**  ;
0B0444             0414**  ; HEX - Get hexadecimal constant.
0B0444             0415**  ;   Inputs: ASCII string at (IY)
0B0444             0416**  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0B0444             0417**  ;           IY updated (points to delimiter)
0B0444             0418**  ;
0B0444 CD 91 0A 0B 0419**  HEX:			CALL    ZERO			; Set result to 0
0B0448 CD F6 0A 0B 0420**  			CALL    HEXDIG			; Fetch the character from IY
0B044C 38 1B       0421**  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
0B044E FD 23       0422**  HEX1:			INC     IY			; Move pointer to next character
0B0450 E6 0F       0423**  			AND     0FH			; Clear the top nibble
0B0452 06 04       0424**  			LD      B,4			; Loop counter
0B0454             0425**  ;
0B0454 D9          0426**  HEX2:			EXX				; Shift the result left B (4) times. This makes
0B0455 52 29       0427**  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
0B0457 D9          0428**  			EXX				; .
0B0458 52 ED 6A    0429**  			ADC.S   HL,HL			; .
0B045B 10 F7       0430**  			DJNZ    HEX2			; And loop
0B045D D9          0431**  			EXX
0B045E B5          0432**  			OR      L			; OR in the digit
0B045F 6F          0433**  			LD      L,A
0B0460 D9          0434**  			EXX
0B0461             0435**  ;
0B0461 CD F6 0A 0B 0436**  			CALL    HEXDIG			; Fetch the next character
0B0465 30 E7       0437**  			JR      NC,HEX1			; If it is a HEX digit then loop
0B0467 AF          0438**  			XOR     A			; Clear A
0B0468 C9          0439**  			RET
0B0469             0440**  ;
0B0469 3E 1C       0441**  BADHEX:			LD      A,28
0B046B C3 5E 38 0B 0442**  			JP      ERROR_          	; Error: "Bad HEX"
0B046F             0443**  ;
0B046F             0444**  ; BIN - Get binary constant.
0B046F             0445**  ;   Inputs: ASCII string at (IY)
0B046F             0446**  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0B046F             0447**  ;           IY updated (points to delimiter)
0B046F             0448**  ;
0B046F CD 91 0A 0B 0449**  BIN:			CALL    ZERO			; Set result to 0
0B0473 CD 09 0B 0B 0450**  			CALL	BINDIG			; Fetch the character from IY
0B0477 38 13       0451**  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
0B0479 FD 23       0452**  BIN1:			INC	IY			; Move pointer to next character
0B047B 0F          0453**  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
0B047C D9          0454**  			EXX				;
0B047D 52 ED 6A    0455**  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
0B0480 D9          0456**  			EXX
0B0481 52 ED 6A    0457**  			ADC.S	HL,HL
0B0484 CD 09 0B 0B 0458**  			CALL	BINDIG			; Fetch the next character
0B0488 30 EF       0459**  			JR	NC,BIN1
0B048A AF          0460**  			XOR	A			; Clear A
0B048B C9          0461**  			RET
0B048C             0462**  ;
0B048C 3E 1C       0463**  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0B048E CD 75 38 0B 0464**  			CALL	EXTERR
0B0492 42 61 64 20 0465**  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0B049D             0466**  ;
0B049D             0467**  ; MINUS - Unary minus.
0B049D             0468**  ;   Inputs: IY = text pointer
0B049D             0469**  ;  Outputs: Numeric result, same type as argument.
0B049D             0470**  ;           Result in H'L'HLC
0B049D             0471**  ;
0B049D CD 1B 04 0B 0472**  MINUS:			CALL    ITEMN			; Get the numeric argument
0B04A1 0D          0473**  MINUS0:			DEC     C			; Check exponent (C)
0B04A2 0C          0474**  			INC     C			; If it is zero, then it's either a FP zero or an integer
0B04A3 28 06       0475**  			JR      Z,NEGATE_EV        	; So do an integer negation
0B04A5             0476**  ;
0B04A5 7C          0477**  			LD      A,H			; Do a FP negation by
0B04A6 EE 80       0478**  			XOR     80H             	; Toggling the sign bit (H)
0B04A8 67          0479**  			LD      H,A
0B04A9 AF          0480**  			XOR     A               	; Numeric marker
0B04AA C9          0481**  			RET
0B04AB             0482**  ;
0B04AB D9          0483**  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0B04AC 7C          0484**  			LD      A,H			; First do a one's complement by negating all the bytes
0B04AD 2F          0485**  			CPL
0B04AE 67          0486**  			LD      H,A
0B04AF 7D          0487**  			LD      A,L
0B04B0 2F          0488**  			CPL
0B04B1 6F          0489**  			LD      L,A
0B04B2 D9          0490**  			EXX
0B04B3 7C          0491**  			LD      A,H
0B04B4 2F          0492**  			CPL
0B04B5 67          0493**  			LD      H,A
0B04B6 7D          0494**  			LD      A,L
0B04B7 2F          0495**  			CPL
0B04B8 6F          0496**  			LD      L,A
0B04B9 D9          0497**  ADD1:			EXX				; Then add 1
0B04BA 23          0498**  			INC     HL
0B04BB 7C          0499**  			LD      A,H
0B04BC B5          0500**  			OR      L
0B04BD D9          0501**  			EXX
0B04BE 3E 00       0502**  			LD      A,0             	; Numeric marker
0B04C0 C0          0503**  			RET     NZ
0B04C1 23          0504**  			INC     HL
0B04C2 C9          0505**  			RET
0B04C3             0506**  ;
0B04C3             0507**  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0B04C3             0508**  ; Item type is returned in A:  Bit 7=0 numeric.
0B04C3             0509**  ;                              Bit 7=1 string.
0B04C3             0510**  ; Numeric item returned in HLH'L'C.
0B04C3             0511**  ; String item returned in string accumulator,
0B04C3             0512**  ;   DE addresses byte after last (E=length).
0B04C3             0513**  ;
0B04C3 CD 4D 17 0B 0514**  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0B04C7 CD 6E 0B 0B 0515**  			CALL    NXT			; Skip spaces
0B04CB FD 23       0516**  			INC     IY			; Move to the prefix character
0B04CD FE 26       0517**  			CP      '&'			; If `&`
0B04CF CA 44 04 0B 0518**  			JP      Z,HEX           	; Then get a HEX constant
0B04D3 FE 25       0519**  			CP	'%'			; If '%'
0B04D5 28 98       0520**  			JR	Z,BIN			; Then get a BINARY constant
0B04D7 FE 2D       0521**  			CP      '-'			; If `-`
0B04D9 28 C2       0522**  			JR      Z,MINUS         	; Then get a negative number
0B04DB FE 2B       0523**  			CP      '+'			; If `+`
0B04DD CA 1B 04 0B 0524**  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0B04E1 FE 28       0525**  			CP      '('			; If `(`
0B04E3 CA 3A 04 0B 0526**  			JP      Z,ITEM1         	; Start of a bracketed expression
0B04E7 FE 22       0527**  			CP      34			; If `"`
0B04E9 28 7A       0528**  			JR      Z,CONS          	; Start of a string constant
0B04EB FE C6       0529**  			CP      TCMD_EV			; Is it out of range of the function table?
0B04ED D2 95 0D 0B 0530**  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0B04F1 FE 8D       0531**  			CP      FUNTOK			; If it is in range, then
0B04F3 D2 81 0B 0B 0532**  			JP      NC,DISPAT       	; It's a function
0B04F7 FD 2B       0533**  			DEC     IY
0B04F9 FE 3A       0534**  			CP      ':'
0B04FB 30 0C       0535**  			JR      NC,ITEM2		; VARIABLE?
0B04FD FE 30       0536**  			CP      '0'
0B04FF D2 8C 05 0B 0537**  			JP      NC,CON			; NUMERIC CONSTANT
0B0503 FE 2E       0538**  			CP      '.'
0B0505 CA 8C 05 0B 0539**  			JP      Z,CON			; NUMERIC CONSTANT
0B0509 CD 38 3B 0B 0540**  ITEM2:			CALL    GETVAR			; VARIABLE
0B050D 20 37       0541**  			JR      NZ,NOSUCH
0B050F B7          0542**  			OR      A
0B0510 FA 9E 05 0B 0543**  			JP      M,LOADS			; STRING VARIABLE
0B0514 B7          0544**  LOADN:			OR      A
0B0515 28 20       0545**  			JR      Z,LOAD1			; BYTE VARIABLE
0B0517 0E 00       0546**  			LD      C,0
0B0519 CB 47       0547**  			BIT     0,A
0B051B 28 03       0548**  			JR      Z,LOAD4			; INTEGER VARIABLE
0B051D DD 4E 04    0549**  LOAD5:			LD      C,(IX+4)
0B0520 D9          0550**  LOAD4:			EXX
0B0521 21 00 00 00 0551**  			LD	HL, 0			; TODO: Optimise
0B0525 DD 6E 00    0552**  			LD      L,(IX+0)
0B0528 DD 66 01    0553**  			LD      H,(IX+1)
0B052B D9          0554**  			EXX
0B052C 21 00 00 00 0555**  			LD	HL, 0			; TODO: Optimise
0B0530 DD 6E 02    0556**  			LD      L,(IX+2)
0B0533 DD 66 03    0557**  			LD      H,(IX+3)
0B0536 C9          0558**  			RET
0B0537             0559**  ;
0B0537 21 00 00 00 0560**  LOAD1:			LD      HL,0
0B053B D9          0561**  			EXX
0B053C 21 00 00 00 0562**  			LD      HL,0			; TODO: Optimise
0B0540 DD 6E 00    0563**  			LD      L,(IX+0)
0B0543 D9          0564**  			EXX
0B0544 4C          0565**  			LD      C,H
0B0545 C9          0566**  			RET
0B0546             0567**  ;
0B0546 DA 95 0D 0B 0568**  NOSUCH:			JP      C,SYNTAX
0B054A 3A 40 4E 0B 0569**  			LD      A,(LISTON)
0B054E CB 6F       0570**  			BIT     5,A
0B0550 3E 1A       0571**  			LD      A,26
0B0552 20 26       0572**  			JR      NZ,ERROR0_EV		; Throw "No such variable"
0B0554 FD 23       0573**  NOS1:			INC     IY
0B0556 CD 6D 3D 0B 0574**  			CALL    RANGE
0B055A 30 F8       0575**  			JR      NC,NOS1
0B055C DD 21 40 4D 0576**  			LD      IX,PC
       0B          
0B0561 AF          0577**  			XOR     A
0B0562 4F          0578**  			LD      C,A
0B0563 18 BB       0579**  			JR      LOAD4
0B0565             0580**  ;
0B0565             0581**  ;CONS - Get string constant from ASCII string.
0B0565             0582**  ;   Inputs: ASCII string at (IY)
0B0565             0583**  ;  Outputs: Result in string accumulator.
0B0565             0584**  ;           D = MS byte of ACCS, E = string length
0B0565             0585**  ;           A7 = 1 (string marker)
0B0565             0586**  ;           IY updated
0B0565             0587**  ;
0B0565 11 00 4B 0B 0588**  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
0B0569 FD 7E 00    0589**  CONS3:			LD      A,(IY)			; Fetch the first character and
0B056C FD 23       0590**  			INC     IY			; Increment the pointer
0B056E FE 22       0591**  			CP      '"'			; Check for start quote
0B0570 28 0C       0592**  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
0B0572             0593**  ;
0B0572 12          0594**  CONS1:			LD      (DE),A			; Store the character in the string accumulator
0B0573 1C          0595**  			INC     E			; Increment the string accumulator pointer
0B0574 FE 0D       0596**  			CP      CR			; Is it CR
0B0576 20 F1       0597**  			JR      NZ,CONS3		; No, so keep looping
0B0578             0598**  ;
0B0578 3E 09       0599**  			LD      A,9
0B057A C3 5E 38 0B 0600**  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
0B057E             0601**  ;
0B057E FD 7E 00    0602**  CONS2:			LD      A,(IY)			; Fetch the next character
0B0581 FE 22       0603**  			CP      '"'			; Check for end quote?
0B0583 FD 23       0604**  			INC     IY			; Increment the pointer
0B0585 28 EB       0605**  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
0B0587 FD 2B       0606**  			DEC     IY			;
0B0589 3E 80       0607**  			LD      A,80H           	; String marker
0B058B C9          0608**  			RET
0B058C             0609**  ;
0B058C             0610**  ;CON - Get unsigned numeric constant from ASCII string.
0B058C             0611**  ;   Inputs: ASCII string at (IY).
0B058C             0612**  ;  Outputs: Variable-type result in HLH'L'C
0B058C             0613**  ;           IY updated (points to delimiter)
0B058C             0614**  ;           A7 = 0 (numeric marker)
0B058C             0615**  ;
0B058C FD E5       0616**  CON:			PUSH    IY
0B058E DD E1       0617**  			POP     IX
0B0590 3E 24       0618**  			LD      A,36
0B0592 CD 68 21 0B 0619**  			CALL    FPP
0B0596 38 E2       0620**  			JR      C,ERROR0_EV
0B0598 DD E5       0621**  			PUSH    IX
0B059A FD E1       0622**  			POP     IY
0B059C AF          0623**  			XOR     A
0B059D C9          0624**  			RET
0B059E             0625**  ;
0B059E 11 00 4B 0B 0626**  LOADS:			LD      DE,ACCS			; Where to store the string
0B05A2 1F          0627**  			RRA
0B05A3 30 1A       0628**  			JR      NC,LOADS2       	; Skip if it is a fixed string
0B05A5             0629**  ;
0B05A5 D9          0630**  			EXX				; This block was a call to LOAD4
0B05A6 DD 6E 00    0631**  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B05A9 DD 66 01    0632**  			LD      H,(IX+1)		; The maximum original string length
0B05AC D9          0633**  			EXX
0B05AD DD 27 02    0634**  			LD	HL,(IX+2)		; Address of the string (24-bit)
0B05B0             0635**  ;
0B05B0 D9          0636**  			EXX
0B05B1 7D          0637**  			LD      A,L
0B05B2 D9          0638**  			EXX
0B05B3 B7          0639**  			OR      A
0B05B4 01 00 00 00 0640**  			LD	BC,0			; BC: Number of bytes to copy
0B05B8 4F          0641**  			LD      C,A
0B05B9 3E 80       0642**  			LD      A,80H           	; String marker
0B05BB C8          0643**  			RET     Z
0B05BC ED B0       0644**  			LDIR
0B05BE C9          0645**  			RET
0B05BF 7E          0646**  LOADS2:			LD      A,(HL)
0B05C0 12          0647**  			LD      (DE),A
0B05C1 23          0648**  			INC     HL
0B05C2 FE 0D       0649**  			CP      CR
0B05C4 3E 80       0650**  			LD      A,80H           	; String marker
0B05C6 C8          0651**  			RET     Z
0B05C7 1C          0652**  			INC     E
0B05C8 20 F5       0653**  			JR      NZ,LOADS2
0B05CA C9          0654**  			RET                     	; Return null string
0B05CB             0655**  ;
0B05CB             0656**  ;VARIABLE-TYPE FUNCTIONS:
0B05CB             0657**  ;
0B05CB             0658**  ;Result returned in HLH'L'C (floating point)
0B05CB             0659**  ;Result returned in HLH'L' (C=0) (integer)
0B05CB             0660**  ;Result returned in string accumulator & DE (string)
0B05CB             0661**  ;All registers destroyed.
0B05CB             0662**  ;IY (text pointer) updated.
0B05CB             0663**  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0B05CB             0664**  ;
0B05CB             0665**  ;POS - horizontal cursor position.
0B05CB             0666**  ;VPOS - vertical cursor position.
0B05CB             0667**  ;EOF - return status of file.
0B05CB             0668**  ;BGET - read byte from file.
0B05CB             0669**  ;INKEY - as GET but wait only n centiseconds.
0B05CB             0670**  ;GET - wait for keypress and return ASCII value.
0B05CB             0671**  ;GET(n) - input from Z80 port n.
0B05CB             0672**  ;ASC - ASCII value of string.
0B05CB             0673**  ;LEN - length of string.
0B05CB             0674**  ;LOMEM - location of dynamic variables.
0B05CB             0675**  ;HIMEM - top of available RAM.
0B05CB             0676**  ;PAGE - start of current text page.
0B05CB             0677**  ;TOP - address of first free byte after program.
0B05CB             0678**  ;ERL - line number where last error occurred.
0B05CB             0679**  ;ERR - number of last error.
0B05CB             0680**  ;COUNT - number of printing characters since CR.
0B05CB             0681**  ;Results are integer numeric.
0B05CB             0682**  ;
0B05CB CD CA 3F 0B 0683**  POS:			CALL    GETCSR			; Return the horizontal cursor position
0B05CF EB          0684**  			EX      DE,HL			;  L: The X cursor position
0B05D0 C3 7F 06 0B 0685**  			JP      COUNT1			; Return an 8-bit value
0B05D4             0686**  ;
0B05D4 CD CA 3F 0B 0687**  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0B05D8 C3 7F 06 0B 0688**  			JP      COUNT1			; Return an 8-bit value
0B05DC             0689**  ;
0B05DC CD 84 19 0B 0690**  EOF:			CALL    CHANEL			; Check for EOF
0B05E0 CD 42 44 0B 0691**  			CALL    OSSTAT
0B05E4 CA 03 07 0B 0692**  			JP      Z,TRUE			; Yes, so return true
0B05E8 C3 91 0A 0B 0693**  			JP      ZERO			; Otherwise return false (zero)
0B05EC             0694**  ;
0B05EC CD 84 19 0B 0695**  BGET:			CALL    CHANEL          	; Channel number
0B05F0 CD 31 44 0B 0696**  			CALL    OSBGET
0B05F4 6F          0697**  			LD      L,A
0B05F5 C3 7D 06 0B 0698**  			JP      COUNT0			; Return an 8-bit value
0B05F9             0699**  ;
0B05F9 CD 23 04 0B 0700**  INKEY:			CALL    ITEMI			; Get the argument
0B05FD CB 7C       0701**  			BIT	7, H			; Check the sign
0B05FF D9          0702**  			EXX				; HL: The argument
0B0600 C2 E9 08 0B 0703**  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
0B0604 CD DB 08 0B 0704**  			CALL	INKEY0 			; Do INKEY(n)
0B0608 18 1D       0705**  			JR      ASC0			; Return a numeric value
0B060A             0706**  ;
0B060A CD 6E 0B 0B 0707**  GET:			CALL    NXT			; Skip whitespace
0B060E FE 28       0708**  			CP      '('			; Is it GET(
0B0610 20 0B       0709**  			JR      NZ,GET0			; No, so get a keyboard character
0B0612 CD 23 04 0B 0710**  			CALL    ITEMI           	; Yes, so fetch the port address
0B0616 D9          0711**  			EXX
0B0617 44          0712**  			LD      B,H			; BC: The port address
0B0618 4D          0713**  			LD      C,L
0B0619 ED 68       0714**  			IN      L,(C)           	;  L: Input from port BC
0B061B 18 60       0715**  			JR      COUNT0			; Return an 8-bit value
0B061D             0716**  ;
0B061D CD C5 08 0B 0717**  GET0:			CALL    GETS			; Read the keyboard character
0B0621 18 0A       0718**  			JR      ASC1			; And return the value
0B0623             0719**  ;
0B0623 CD 2E 04 0B 0720**  ASC:			CALL    ITEMS			; Get the string argument argument
0B0627 AF          0721**  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
0B0628 BB          0722**  			CP      E			; Is the pointer 0
0B0629 CA 03 07 0B 0723**  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
0B062D 2A 00 4B 0B 0724**  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
0B0631 18 4A       0725**  			JR      COUNT0			; An 8-bit value
0B0633             0726**  ;
0B0633 CD 2E 04 0B 0727**  LEN:			CALL    ITEMS			; Get the string argument
0B0637 EB          0728**  			EX      DE,HL			; HL: Pointer into ACCS
0B0638 18 43       0729**  			JR      COUNT0			; Return L
0B063A             0730**  ;
0B063A 2A 1A 4E 0B 0731**  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
0B063E 3A 1C 4E 0B 0732**  			LD	A, (LOMEM+2)
0B0642 18 41       0733**  			JR      COUNT2			; A 24-bit value
0B0644             0734**  ;
0B0644 2A 20 4E 0B 0735**  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
0B0648 3A 22 4E 0B 0736**  			LD	A, (HIMEM+2)
0B064C 18 37       0737**  			JR      COUNT2			; A 24-bit value
0B064E             0738**  ;
0B064E 2A 14 4E 0B 0739**  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
0B0652 3A 16 4E 0B 0740**  			LD	A, (PAGE_+2)		; A 24-bit value
0B0656 18 2D       0741**  			JR      COUNT2
0B0658             0742**  ;
0B0658 FD 7E 00    0743**  TOPV:			LD      A,(IY)			; Return the TOP system variable
0B065B FD 23       0744**  			INC     IY              	; Skip "P"
0B065D FE 50       0745**  			CP      'P'
0B065F C2 95 0D 0B 0746**  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
0B0663 2A 17 4E 0B 0747**  			LD      HL,(TOP)
0B0667 3A 19 4E 0B 0748**  			LD	A, (TOP+2)
0B066B 18 18       0749**  			JR      COUNT2
0B066D             0750**  ;
0B066D 2A 33 4E 0B 0751**  ERLV:			LD      HL,(ERL)		; Return the error line
0B0671 18 0C       0752**  			JR      COUNT1			; A 16-bit value
0B0673             0753**  ;
0B0673 2A 3F 4E 0B 0754**  ERRV:			LD      HL,(ERR)		; Return the error value
0B0677 18 04       0755**  			JR      COUNT0			; An 8-bit value
0B0679             0756**  ;
0B0679 2A 3D 4E 0B 0757**  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
0B067D             0758**  
0B067D 26 00       0759**  COUNT0:			LD      H,0			; Return L
0B067F D9          0760**  COUNT1:			EXX				; Return HL
0B0680 AF          0761**  			XOR     A
0B0681 4F          0762**  			LD      C,A             	; Integer marker
0B0682 67          0763**  			LD      H,A
0B0683 6F          0764**  			LD      L,A
0B0684 C9          0765**  			RET
0B0685 D9          0766**  COUNT2:			EXX
0B0686 6F          0767**  			LD	L,A
0B0687 AF          0768**  			XOR	A
0B0688 4F          0769**  			LD	C,A			; Integer marker
0B0689 67          0770**  			LD	H,A
0B068A C9          0771**  			RET
0B068B             0772**  ;
0B068B             0773**  ;OPENIN - Open a file for reading.
0B068B             0774**  ;OPENOT - Open a file for writing.
0B068B             0775**  ;OPENUP - Open a file for reading or writing.
0B068B             0776**  ;Result is integer channel number (0 if error)
0B068B             0777**  ;
0B068B AF          0778**  OPENOT:			XOR     A			; Open for writing
0B068C 18 06       0779**  			JR	OPENIN_1
0B068E             0780**  ;
0B068E 3E 02       0781**  OPENUP:			LD      A,2			; Open for reading / writing
0B0690 18 02       0782**  			JR	OPENIN_1
0B0692             0783**  ;
0B0692 3E 01       0784**  OPENIN:			LD      A,1			; Open for reading
0B0694             0785**  ;
0B0694 F5          0786**  OPENIN_1:		PUSH    AF              	; Save OPEN type
0B0695 CD 2E 04 0B 0787**  			CALL    ITEMS           	; Fetch the filename
0B0699 3E 0D       0788**  			LD      A,CR
0B069B 12          0789**  			LD      (DE),A
0B069C F1          0790**  			POP     AF              	; Restore the OPEN type
0B069D C6 FF       0791**  			ADD     A,-1            	; Affect the flags
0B069F 21 00 4B 0B 0792**  			LD      HL,ACCS
0B06A3 CD 1A 44 0B 0793**  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0B06A7 6F          0794**  			LD      L,A			; L: Channel number
0B06A8 18 D3       0795**  			JR      COUNT0			; Return channel number to BASIC
0B06AA             0796**  ;
0B06AA             0797**  ;EXT - Return length of file.
0B06AA             0798**  ;PTR_EV - Return current file pointer.
0B06AA             0799**  ;Results are integer numeric.
0B06AA             0800**  ;
0B06AA CD 84 19 0B 0801**  EXT:			CALL    CHANEL
0B06AE CD 78 44 0B 0802**  			CALL    GETEXT
0B06B2 18 15       0803**  			JR      TIME0
0B06B4             0804**  ;
0B06B4 CD 84 19 0B 0805**  PTR_EV:			CALL    CHANEL
0B06B8 CD 4C 44 0B 0806**  			CALL    GETPTR
0B06BC 18 0B       0807**  			JR      TIME0
0B06BE             0808**  ;
0B06BE             0809**  ;TIME - Return current value of elapsed time.
0B06BE             0810**  ;Result is integer numeric.
0B06BE             0811**  ;
0B06BE FD 7E 00    0812**  TIMEV:			LD      A,(IY)
0B06C1 FE 24       0813**  			CP      '$'
0B06C3 28 0A       0814**  			JR      Z,TIMEVS
0B06C5 CD AA 3F 0B 0815**  			CALL    GETIME
0B06C9 D5          0816**  TIME0:			PUSH    DE
0B06CA D9          0817**  			EXX
0B06CB E1          0818**  			POP     HL
0B06CC AF          0819**  			XOR     A
0B06CD 4F          0820**  			LD      C,A
0B06CE C9          0821**  			RET
0B06CF             0822**  ;
0B06CF             0823**  ;TIME$ - Return date/time string.
0B06CF             0824**  ;Result is string
0B06CF             0825**  ;
0B06CF FD 23       0826**  TIMEVS:			INC     IY              ;SKIP $
0B06D1 CD 91 44 0B 0827**  			CALL    GETIMS
0B06D5 3E 80       0828**  			LD      A,80H           ;MARK STRING
0B06D7 C9          0829**  			RET
0B06D8             0830**  ;
0B06D8             0831**  ;String comparison:
0B06D8             0832**  ;
0B06D8 CD 8D 0A 0B 0833**  SLT:			CALL    SCP
0B06DC D0          0834**  			RET     NC
0B06DD 18 24       0835**  			JR      TRUE
0B06DF             0836**  ;
0B06DF CD 8D 0A 0B 0837**  SGT:			CALL    SCP
0B06E3 C8          0838**  			RET     Z
0B06E4 D8          0839**  			RET     C
0B06E5 18 1C       0840**  			JR      TRUE
0B06E7             0841**  ;
0B06E7 CD 8D 0A 0B 0842**  SGE:			CALL    SCP
0B06EB D8          0843**  			RET     C
0B06EC 18 15       0844**  			JR      TRUE
0B06EE             0845**  ;
0B06EE CD 8D 0A 0B 0846**  SLE:			CALL    SCP
0B06F2 28 0F       0847**  			JR      Z,TRUE
0B06F4 D0          0848**  			RET     NC
0B06F5 18 0C       0849**  			JR      TRUE
0B06F7             0850**  ;
0B06F7 CD 8D 0A 0B 0851**  SNE:			CALL    SCP
0B06FB C8          0852**  			RET     Z
0B06FC 18 05       0853**  			JR      TRUE
0B06FE             0854**  ;
0B06FE CD 8D 0A 0B 0855**  SEQ:			CALL    SCP
0B0702 C0          0856**  			RET     NZ
0B0703 3E FF       0857**  TRUE:			LD      A,-1
0B0705 D9          0858**  			EXX
0B0706 67          0859**  			LD      H,A
0B0707 6F          0860**  			LD      L,A
0B0708 D9          0861**  			EXX
0B0709 67          0862**  			LD      H,A
0B070A 6F          0863**  			LD      L,A
0B070B 3C          0864**  			INC     A
0B070C 4F          0865**  			LD      C,A
0B070D C9          0866**  			RET
0B070E             0867**  ;
0B070E             0868**  ;PI - Return PI (3.141592654)
0B070E             0869**  ;Result is floating-point numeric.
0B070E             0870**  ;
0B070E 3E 23       0871**  PI:			LD      A,35
0B0710 18 44       0872**  			JR      FPP1
0B0712             0873**  ;
0B0712             0874**  ;ABS - Absolute value
0B0712             0875**  ;Result is numeric, variable type.
0B0712             0876**  ;
0B0712 3E 10       0877**  ABSV:			LD      A,16
0B0714 18 3A       0878**  			JR      FPPN
0B0716             0879**  ;
0B0716             0880**  ;NOT - Complement integer.
0B0716             0881**  ;Result is integer numeric.
0B0716             0882**  ;
0B0716 3E 1A       0883**  NOTK:			LD      A,26
0B0718 18 36       0884**  			JR      FPPN
0B071A             0885**  ;
0B071A             0886**  ;DEG - Convert radians to degrees
0B071A             0887**  ;Result is floating-point numeric.
0B071A             0888**  ;
0B071A 3E 15       0889**  DEG:			LD      A,21
0B071C 18 32       0890**  			JR      FPPN
0B071E             0891**  ;
0B071E             0892**  ;RAD - Convert degrees to radians
0B071E             0893**  ;Result is floating-point numeric.
0B071E             0894**  ;
0B071E 3E 1B       0895**  RAD:			LD      A,27
0B0720 18 2E       0896**  			JR      FPPN
0B0722             0897**  ;
0B0722             0898**  ;SGN - Return -1, 0 or +1
0B0722             0899**  ;Result is integer numeric.
0B0722             0900**  ;
0B0722 3E 1C       0901**  SGN:			LD      A,28
0B0724 18 2A       0902**  			JR      FPPN
0B0726             0903**  ;
0B0726             0904**  ;INT - Floor function
0B0726             0905**  ;Result is integer numeric.
0B0726             0906**  ;
0B0726 3E 17       0907**  INT_:			LD      A,23
0B0728 18 26       0908**  			JR      FPPN
0B072A             0909**  ;
0B072A             0910**  ;SQR - square root
0B072A             0911**  ;Result is floating-point numeric.
0B072A             0912**  ;
0B072A 3E 1E       0913**  SQR:			LD      A,30
0B072C 18 22       0914**  			JR      FPPN
0B072E             0915**  ;
0B072E             0916**  ;TAN - Tangent function
0B072E             0917**  ;Result is floating-point numeric.
0B072E             0918**  ;
0B072E 3E 1F       0919**  TAN:			LD      A,31
0B0730 18 1E       0920**  			JR      FPPN
0B0732             0921**  ;
0B0732             0922**  ;COS - Cosine function
0B0732             0923**  ;Result is floating-point numeric.
0B0732             0924**  ;
0B0732 3E 14       0925**  COS:			LD      A,20
0B0734 18 1A       0926**  			JR      FPPN
0B0736             0927**  ;
0B0736             0928**  ;SIN - Sine function
0B0736             0929**  ;Result is floating-point numeric.
0B0736             0930**  ;
0B0736 3E 1D       0931**  SIN:			LD      A,29
0B0738 18 16       0932**  			JR      FPPN
0B073A             0933**  ;
0B073A             0934**  ;EXP - Exponential function
0B073A             0935**  ;Result is floating-point numeric.
0B073A             0936**  ;
0B073A 3E 16       0937**  EXP:			LD      A,22
0B073C 18 12       0938**  			JR      FPPN
0B073E             0939**  ;
0B073E             0940**  ;LN - Natural log.
0B073E             0941**  ;Result is floating-point numeric.
0B073E             0942**  ;
0B073E 3E 18       0943**  LN:			LD      A,24
0B0740 18 0E       0944**  			JR      FPPN
0B0742             0945**  ;
0B0742             0946**  ;LOG - base-10 logarithm.
0B0742             0947**  ;Result is floating-point numeric.
0B0742             0948**  ;
0B0742 3E 19       0949**  LOG:			LD      A,25
0B0744 18 0A       0950**  			JR      FPPN
0B0746             0951**  ;
0B0746             0952**  ;ASN - Arc-sine
0B0746             0953**  ;Result is floating-point numeric.
0B0746             0954**  ;
0B0746 3E 12       0955**  ASN:			LD      A,18
0B0748 18 06       0956**  			JR      FPPN
0B074A             0957**  ;
0B074A             0958**  ;ATN - arc-tangent
0B074A             0959**  ;Result is floating-point numeric.
0B074A             0960**  ;
0B074A 3E 13       0961**  ATN:			LD      A,19
0B074C 18 02       0962**  			JR      FPPN
0B074E             0963**  ;
0B074E             0964**  ;ACS - arc-cosine
0B074E             0965**  ;Result is floating point numeric.
0B074E             0966**  ;
0B074E 3E 11       0967**  ACS:			LD      A,17
0B0750 F5          0968**  FPPN:			PUSH    AF
0B0751 CD 1B 04 0B 0969**  			CALL    ITEMN
0B0755 F1          0970**  			POP     AF
0B0756 CD 68 21 0B 0971**  FPP1:			CALL    FPP
0B075A DA 5E 38 0B 0972**  			JP      C,ERROR_
0B075E AF          0973**  			XOR     A
0B075F C9          0974**  			RET
0B0760             0975**  ;
0B0760             0976**  ;SFIX - Convert to fixed-point notation
0B0760             0977**  ;
0B0760 3E 26       0978**  SFIX:			LD      A,38
0B0762 18 F2       0979**  			JR      FPP1
0B0764             0980**  ;
0B0764             0981**  ;SFLOAT - Convert to floating-point notation
0B0764             0982**  ;
0B0764 3E 27       0983**  SFLOAT:			LD      A,39
0B0766 18 EE       0984**  			JR      FPP1
0B0768             0985**  ;
0B0768             0986**  ;VAL - Return numeric value of string.
0B0768             0987**  ;Result is variable type numeric.
0B0768             0988**  ;
0B0768 CD 2E 04 0B 0989**  VAL:			CALL    ITEMS
0B076C AF          0990**  VAL0:			XOR     A
0B076D 12          0991**  			LD      (DE),A
0B076E DD 21 00 4B 0992**  			LD      IX,ACCS
       0B          
0B0773 3E 24       0993**  			LD      A,36
0B0775 18 DF       0994**  			JR      FPP1
0B0777             0995**  ;
0B0777             0996**  ;EVAL - Pass string to expression evaluator.
0B0777             0997**  ;Result is variable type (numeric or string).
0B0777             0998**  ;
0B0777 CD 2E 04 0B 0999**  EVAL_:			CALL    ITEMS
0B077B 3E 0D       1000**  			LD      A,CR
0B077D 12          1001**  			LD      (DE),A
0B077E FD E5       1002**  			PUSH    IY
0B0780 11 00 4B 0B 1003**  			LD      DE,ACCS
0B0784 FD 21 00 4B 1004**  			LD      IY,ACCS
       0B          
0B0789 0E 00       1005**  			LD      C,0
0B078B CD 9D 3D 0B 1006**  			CALL    LEXAN2          ;TOKENISE
0B078F 12          1007**  			LD      (DE),A
0B0790 13          1008**  			INC     DE
0B0791 AF          1009**  			XOR     A
0B0792 CD B2 0A 0B 1010**  			CALL    PUSHS           ;PUT ON STACK
0B0796 FD 21 03 00 1011**  			LD      IY,SIZEW	;WAS 2
       00          
0B079B FD 39       1012**  			ADD     IY,SP
0B079D CD C5 02 0B 1013**  			CALL    EXPR
0B07A1 FD E1       1014**  			POP     IY
0B07A3 FD 39       1015**  			ADD     IY,SP
0B07A5 FD F9       1016**  			LD      SP,IY           ;ADJUST STACK POINTER
0B07A7 FD E1       1017**  			POP     IY
0B07A9 08          1018**  			EX      AF,AF'
0B07AA C9          1019**  			RET
0B07AB             1020**  ;
0B07AB             1021**  ;RND - Random number function.
0B07AB             1022**  ; RND gives random integer 0-&FFFFFFFF
0B07AB             1023**  ; RND(-n) seeds random number & returns -n.
0B07AB             1024**  ; RND(0) returns last value in RND(1) form.
0B07AB             1025**  ; RND(1) returns floating-point 0-0.99999999.
0B07AB             1026**  ; RND(n) returns random integer 1-n.
0B07AB             1027**  ;
0B07AB DD 21 38 4E 1028**  RND:			LD      IX,RANDOM
       0B          
0B07B0 CD 6E 0B 0B 1029**  			CALL    NXT
0B07B4 FE 28       1030**  			CP      '('
0B07B6 28 20       1031**  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0B07B8 CD 1D 05 0B 1032**  			CALL    LOAD5
0B07BC CB 19       1033**  RND1:			RR      C
0B07BE 06 20       1034**  			LD      B,32
0B07C0 D9          1035**  RND2:			EXX                     ;CALCULATE NEXT
0B07C1 52 ED 6A    1036**  			ADC.S   HL,HL
0B07C4 D9          1037**  			EXX
0B07C5 52 ED 6A    1038**  			ADC.S   HL,HL
0B07C8 CB 5D       1039**  			BIT     3,L
0B07CA 28 01       1040**  			JR      Z,RND3
0B07CC 3F          1041**  			CCF
0B07CD 10 F1       1042**  RND3:			DJNZ    RND2
0B07CF CB 11       1043**  RND4:			RL      C               ;SAVE CARRY
0B07D1 CD D9 16 0B 1044**  			CALL    STORE5          ;STORE NEW NUMBER
0B07D5 AF          1045**  			XOR     A
0B07D6 4F          1046**  			LD      C,A
0B07D7 C9          1047**  			RET
0B07D8 CD 23 04 0B 1048**  RND5:			CALL    ITEMI
0B07DC DD 21 38 4E 1049**  			LD      IX,RANDOM
       0B          
0B07E1 CB 7C       1050**  			BIT     7,H             ;NEGATIVE?
0B07E3 37          1051**  			SCF
0B07E4 20 E9       1052**  			JR      NZ,RND4         ;SEED
0B07E6 CD DD 09 0B 1053**  			CALL    TEST
0B07EA F5          1054**  			PUSH    AF
0B07EB CD D5 09 0B 1055**  			CALL    SWAP
0B07EF D9          1056**  			EXX
0B07F0 CD 1D 05 0B 1057**  			CALL    LOAD5
0B07F4 C4 BC 07 0B 1058**  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0B07F8 D9          1059**  			EXX                     ;SCRAMBLE (CARE!)
0B07F9 0E 7F       1060**  			LD      C,7FH
0B07FB CB 7C       1061**  RND6:			BIT     7,H             ;FLOAT
0B07FD 20 0A       1062**  			JR      NZ,RND7
0B07FF D9          1063**  			EXX
0B0800 52 29       1064**  			ADD.S   HL,HL
0B0802 D9          1065**  			EXX
0B0803 52 ED 6A    1066**  			ADC.S   HL,HL
0B0806 0D          1067**  			DEC     C
0B0807 20 F2       1068**  			JR      NZ,RND6
0B0809 CB BC       1069**  RND7:			RES     7,H             ;POSITIVE 0-0.999999
0B080B F1          1070**  			POP     AF
0B080C C8          1071**  			RET     Z               ;ZERO ARGUMENT
0B080D D9          1072**  			EXX
0B080E 7B          1073**  			LD      A,E
0B080F 3D          1074**  			DEC     A
0B0810 B2          1075**  			OR      D
0B0811 D9          1076**  			EXX
0B0812 B3          1077**  			OR      E
0B0813 B2          1078**  			OR      D
0B0814 C8          1079**  			RET     Z               ;ARGUMENT=1
0B0815 06 00       1080**  			LD      B,0             ;INTEGER MARKER
0B0817 3E 0A       1081**  			LD      A,10
0B0819 CD 68 21 0B 1082**  			CALL    FPP             ;MULTIPLY
0B081D DA 5E 38 0B 1083**  			JP      C,ERROR_
0B0821 CD 60 07 0B 1084**  			CALL    SFIX
0B0825 C3 B9 04 0B 1085**  			JP      ADD1
0B0829             1086**  ;
0B0829             1087**  ; INSTR - String search.
0B0829             1088**  ; Result is integer numeric.
0B0829             1089**  ;
0B0829 CD 1C 0B 0B 1090**  INSTR:			CALL    EXPRSC			; Get the first string expression
0B082D CD B2 0A 0B 1091**  			CALL    PUSHS           	; Push the string onto the stack
0B0831 CD 13 04 0B 1092**  			CALL    EXPRS           	; Get the second string expression
0B0835 C1          1093**  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
0B0836 21 00 00 00 1094**  			LD      HL,0
0B083A 39          1095**  			ADD     HL,SP           	; HL: Pointer to main string
0B083B C5          1096**  			PUSH    BC              	;  C: Main string length
0B083C 43          1097**  			LD      B,E             	;  B: Sub-string length
0B083D CD 6E 0B 0B 1098**  			CALL    NXT			; Skip whitespace
0B0841 FE 2C       1099**  			CP      ','			; Check if there is a comma for the third parameter
0B0843 3E 00       1100**  			LD      A,0			;  A: Default start position in string
0B0845 20 1A       1101**  			JR      NZ,INSTR1		; No, so skip the next bit
0B0847 FD 23       1102**  			INC     IY              	; Skip the comma
0B0849 C5          1103**  			PUSH    BC              	; Save the lengths
0B084A E5          1104**  			PUSH    HL              	; Save the pointer to the main string
0B084B CD B2 0A 0B 1105**  			CALL    PUSHS			; Push the string onto the stack
0B084F CD 08 04 0B 1106**  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
0B0853 C1          1107**  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
0B0854 CD DC 0A 0B 1108**  			CALL    POPS			; Pop the string off the stack
0B0858 E1          1109**  			POP     HL              	; Restore the pointer to the main string
0B0859 C1          1110**  			POP     BC              	; Restore the lengths
0B085A D9          1111**  			EXX
0B085B 7D          1112**  			LD      A,L			; A: The start position in the  string
0B085C D9          1113**  			EXX
0B085D B7          1114**  			OR      A			; Set the flags
0B085E 28 01       1115**  			JR      Z,INSTR1		; If it is zero, then skip
0B0860 3D          1116**  			DEC     A
0B0861 11 00 4B 0B 1117**  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
0B0865 CD 83 08 0B 1118**  			CALL    SEARCH			; Do the search
0B0869 D1          1119**  			POP     DE
0B086A 28 03       1120**  			JR      Z,INSTR2        	; NB: Carry cleared
0B086C ED 62       1121**  			SBC     HL,HL
0B086E 39          1122**  			ADD     HL,SP
0B086F ED 72       1123**  INSTR2:			SBC     HL,SP
0B0871 EB          1124**  			EX      DE,HL
0B0872 7D          1125**  			LD	A,L
0B0873 21 00 00 00 1126**  			LD      HL,0
0B0877 6F          1127**  			LD	L,A
0B0878 39          1128**  			ADD     HL,SP
0B0879 F9          1129**  			LD      SP,HL
0B087A EB          1130**  			EX      DE,HL
0B087B CD 2D 0B 0B 1131**  			CALL    BRAKET			; Check for closing bracket
0B087F C3 7F 06 0B 1132**  			JP      COUNT1			; Return a numeric integer
0B0883             1133**  ;
0B0883             1134**  ; SEARCH - Search string for sub-string
0B0883             1135**  ;    Inputs: Main string at HL length C
0B0883             1136**  ;            Sub-string  at DE length B
0B0883             1137**  ;            Starting offset A
0B0883             1138**  ;   Outputs: NZ - not found
0B0883             1139**  ;            Z - found at location HL-1
0B0883             1140**  ;            Carry always cleared
0B0883             1141**  ;
0B0883 C5          1142**  SEARCH:			PUSH    BC			; Add the starting offset to HL
0B0884 01 00 00 00 1143**  			LD      BC,0
0B0888 4F          1144**  			LD      C,A
0B0889 09          1145**  			ADD     HL,BC           	; New start address
0B088A C1          1146**  			POP     BC
0B088B 91          1147**  			SUB     C			; If the starting offset > main string length, then do nothing
0B088C 30 2C       1148**  			JR      NC,SRCH4
0B088E ED 44       1149**  			NEG
0B0890 4F          1150**  			LD      C,A             	; Remaining length
0B0891             1151**  ;
0B0891 C5          1152**  SRCH1:			PUSH    BC
0B0892 79          1153**  			LD	A,C
0B0893 01 00 00 00 1154**  			LD	BC,0
0B0897 4F          1155**  			LD	C,A
0B0898 1A          1156**  			LD      A,(DE)
0B0899 ED B1       1157**  			CPIR                    	; Find the first character
0B089B 79          1158**  			LD      A,C
0B089C C1          1159**  			POP     BC
0B089D 20 1B       1160**  			JR      NZ,SRCH4
0B089F 4F          1161**  			LD      C,A
0B08A0             1162**  ;
0B08A0             1163**  ; This block of four instructions was commented as a bug fix by R.T.Russell
0B08A0             1164**  ;
0B08A0 05          1165**  			DEC     B			; Bug fix
0B08A1 B8          1166**  			CP      B			; Bug fix
0B08A2 04          1167**  			INC     B			; Bug fix
0B08A3 38 15       1168**  			JR      C,SRCH4			; Bug fix
0B08A5             1169**  ;
0B08A5 C5          1170**  			PUSH    BC
0B08A6 D5          1171**  			PUSH    DE
0B08A7 E5          1172**  			PUSH    HL
0B08A8 05          1173**  			DEC     B
0B08A9 28 08       1174**  			JR      Z,SRCH3         	; Found!
0B08AB 13          1175**  SRCH2:			INC     DE
0B08AC 1A          1176**  			LD      A,(DE)
0B08AD BE          1177**  			CP      (HL)
0B08AE 20 03       1178**  			JR      NZ,SRCH3
0B08B0 23          1179**  			INC     HL
0B08B1 10 F8       1180**  			DJNZ    SRCH2
0B08B3 E1          1181**  SRCH3:			POP     HL
0B08B4 D1          1182**  			POP     DE
0B08B5 C1          1183**  			POP     BC
0B08B6 20 D9       1184**  			JR      NZ,SRCH1
0B08B8 AF          1185**  			XOR     A               	; Flags: Z, NC
0B08B9 C9          1186**  			RET                     	; Found
0B08BA             1187**  ;
0B08BA F6 FF       1188**  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0B08BC C9          1189**  			RET                     	; Not found
0B08BD             1190**  ;
0B08BD             1191**  ;CHRS - Return character with given ASCII value.
0B08BD             1192**  ;Result is string.
0B08BD             1193**  ;
0B08BD CD 23 04 0B 1194**  CHRS:			CALL    ITEMI
0B08C1 D9          1195**  			EXX
0B08C2 7D          1196**  			LD      A,L
0B08C3 18 0E       1197**  			JR      GET1
0B08C5             1198**  ;
0B08C5             1199**  ;GETS - Return key pressed as stringor character at position (X,Y).
0B08C5             1200**  ;Result is string.
0B08C5             1201**  ;
0B08C5 CD 6E 0B 0B 1202**  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0B08C9 FE 28       1203**  			CP	'('
0B08CB CA FA 44 0B 1204**  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0B08CF CD 27 40 0B 1205**  			CALL    OSRDCH
0B08D3 37          1206**  GET1:			SCF
0B08D4 18 09       1207**  			JR      INKEY1
0B08D6             1208**  ;
0B08D6             1209**  ; INKEYS - Wait up to n centiseconds for keypress.
0B08D6             1210**  ;          Return key pressed as string or null
0B08D6             1211**  ;          string if time elapsed.
0B08D6             1212**  ; Result is string.
0B08D6             1213**  ;
0B08D6 CD 23 04 0B 1214**  INKEYS:			CALL    ITEMI			; Fetch the argument
0B08DA D9          1215**  			EXX
0B08DB CD 30 40 0B 1216**  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0B08DF 11 00 4B 0B 1217**  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0B08E3 12          1218**  			LD      (DE),A
0B08E4 3E 80       1219**  			LD      A,80H
0B08E6 D0          1220**  			RET     NC
0B08E7 1C          1221**  			INC     E
0B08E8 C9          1222**  			RET
0B08E9             1223**  ;
0B08E9             1224**  ; INKEYM - Check immediately whether a given key is being pressed
0B08E9             1225**  ; Result is integer numeric
0B08E9             1226**  ;
0B08E9             1227**  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0B08E9 3E 1E       0001**M 			LD	A, function
0B08EB 49 CF       0002**M 			RST.LIS	08h
0B08ED 23          1228**  			INC	HL			; Index from 0
0B08EE 7D          1229**  			LD	A, L			; Negate the LSB of the answer
0B08EF ED 44       1230**  			NEG
0B08F1 4F          1231**  			LD	C, A			;  E: The positive keycode value
0B08F2 3E 01       1232**  			LD	A, 1			; Throw an "Out of range" error
0B08F4 FA 5E 38 0B 1233**  			JP	M, ERROR_		; if the argument < - 128
0B08F8             1234**  ;
0B08F8 21 1B 09 0B 1235**  			LD	HL, BITLOOKUP		; HL: The bit lookup table
0B08FC 11 00 00 00 1236**  			LD	DE, 0
0B0900 79          1237**  			LD	A, C
0B0901 E6 07       1238**  			AND	00000111b		; Just need the first three bits
0B0903 5F          1239**  			LD	E, A			; DE: The bit number
0B0904 19          1240**  			ADD	HL, DE
0B0905 46          1241**  			LD	B, (HL)			;  B: The mask
0B0906             1242**  ;
0B0906 79          1243**  			LD	A, C			; Fetch the keycode again
0B0907 E6 78       1244**  			AND	01111000b		; And divide by 8
0B0909 0F          1245**  			RRCA
0B090A 0F          1246**  			RRCA
0B090B 0F          1247**  			RRCA
0B090C 5F          1248**  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
0B090D DD 19       1249**  			ADD	IX, DE			; IX: The address
0B090F 78          1250**  			LD	A, B			;  B: The mask
0B0910 DD A6 00    1251**  			AND	(IX+0)			; Check whether the bit is set
0B0913 CA 91 0A 0B 1252**  			JP	Z, ZERO			; No, so return 0
0B0917 C3 03 07 0B 1253**  			JP	TRUE			; Otherwise return -1
0B091B             1254**  ;
0B091B             1255**  ; A bit lookup table
0B091B             1256**  ;
0B091B 01 02 04 08 1257**  BITLOOKUP:		DB	01h, 02h, 04h, 08h
0B091F 10 20 40 80 1258**  			DB	10h, 20h, 40h, 80h
0B0923             1259**  ;
0B0923             1260**  ; MID$ - Return sub-string.
0B0923             1261**  ; Result is string.
0B0923             1262**  ;
0B0923 CD 1C 0B 0B 1263**  MIDS:			CALL    EXPRSC			; Get the first string expression
0B0927 CD B2 0A 0B 1264**  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B092B CD 08 04 0B 1265**  			CALL    EXPRI			; Get the second expression
0B092F C1          1266**  			POP     BC			; C: String length, B: Value of A before PUSHS was called
0B0930 CD DC 0A 0B 1267**  			CALL    POPS			; Pop the string back off the stack to the string accumulator
0B0934 D9          1268**  			EXX
0B0935 7D          1269**  			LD      A,L			; A: The start index
0B0936 D9          1270**  			EXX
0B0937 B7          1271**  			OR      A			; If the start index is 0, then we don't need to do the next bit
0B0938 28 0E       1272**  			JR      Z,MIDS1
0B093A 3D          1273**  			DEC     A
0B093B 6F          1274**  			LD      L,A			; L: The start index - 1
0B093C 93          1275**  			SUB     E			; Subtract from the string length
0B093D 1E 00       1276**  			LD      E,0			; Preemptively set the string length to 0
0B093F 30 07       1277**  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
0B0941 ED 44       1278**  			NEG				; Negate the answer and
0B0943 4F          1279**  			LD      C,A			; C: Number of bytes to copy
0B0944 CD 87 09 0B 1280**  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
0B0948 CD 6E 0B 0B 1281**  MIDS1:			CALL    NXT			; Skip whitespace
0B094C FE 2C       1282**  			CP      ','			; Check for a comma
0B094E FD 23       1283**  			INC     IY			; Advance to the next character in the BASIC line
0B0950 28 0D       1284**  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
0B0952 FD 2B       1285**  			DEC     IY			; Restore the BASIC program pointer
0B0954 CD 2D 0B 0B 1286**  			CALL    BRAKET			; Check for a bracket
0B0958 3E 80       1287**  			LD      A,80H			; String marker
0B095A C9          1288**  			RET
0B095B             1289**  ;
0B095B             1290**  ; LEFT$ - Return left part of string.
0B095B             1291**  ; Carry cleared if entire string returned.
0B095B             1292**  ; Result is string.
0B095B             1293**  ;
0B095B CD 1C 0B 0B 1294**  LEFTS:			CALL    EXPRSC			; Get the first string expression
0B095F CD B2 0A 0B 1295**  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B0963 CD 08 04 0B 1296**  			CALL    EXPRI			; Get the second expression
0B0967 C1          1297**  			POP     BC			; C: String length, B: Value of A before PUSHS was called
0B0968 CD DC 0A 0B 1298**  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
0B096C CD 2D 0B 0B 1299**  			CALL    BRAKET			; Check for closing bracket
0B0970 D9          1300**  			EXX
0B0971 7D          1301**  			LD      A,L			; L: The second parameter
0B0972 D9          1302**  			EXX
0B0973 BB          1303**  			CP      E			; Compare with the string length
0B0974 30 02       1304**  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
0B0976 6B          1305**  			LD      L,E             	; For RIGHTS, no effect in LEFTS
0B0977 5F          1306**  LEFT2:			LD      E,A			; E: The new length of string
0B0978 3E 80       1307**  LEFT3:			LD      A,80H           	; String marker
0B097A C9          1308**  			RET
0B097B             1309**  ;
0B097B             1310**  ; RIGHT$ - Return right part of string.
0B097B             1311**  ; Result is string.
0B097B             1312**  ;
0B097B CD 5B 09 0B 1313**  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
0B097F D0          1314**  			RET     NC			; Do nothing if the second parameter is >= string length
0B0980 1C          1315**  			INC     E			; Check for a zero length string
0B0981 1D          1316**  			DEC     E
0B0982 C8          1317**  			RET     Z			; Yes, so do nothing
0B0983 4B          1318**  			LD      C,E			;  C: Number of bytes to copy
0B0984 7D          1319**  			LD      A,L
0B0985 93          1320**  			SUB     E
0B0986 6F          1321**  			LD      L,A			;  L: Index into the string
0B0987 79          1322**  RIGHT1:			LD	A,C
0B0988 01 00 00 00 1323**  			LD	BC,0
0B098C 4F          1324**  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
0B098D 7D          1325**  			LD	A,L
0B098E 21 00 4B 0B 1326**  			LD	HL,ACCS
0B0992 6F          1327**  			LD	L,A			; HL: Source (in ACCS)
0B0993 11 00 4B 0B 1328**  			LD      DE,ACCS			; DE: Destination (start of ACCS)
0B0997 ED B0       1329**  			LDIR                    	; Copy
0B0999 3E 80       1330**  			LD      A,80H			; String marker
0B099B C9          1331**  			RET
0B099C             1332**  ;
0B099C             1333**  ; STRINGS - Return n concatenations of a string.
0B099C             1334**  ; Result is string.
0B099C             1335**  ;
0B099C CD 08 04 0B 1336**  STRING_:		CALL    EXPRI			; Get number of times to replicate
0B09A0 CD 20 0B 0B 1337**  			CALL    COMMA			; Check for comma
0B09A4 D9          1338**  			EXX
0B09A5 7D          1339**  			LD      A,L			; L: Number of iterations of string
0B09A6 D9          1340**  			EXX
0B09A7 F5          1341**  			PUSH    AF
0B09A8 CD 13 04 0B 1342**  			CALL    EXPRS			; Get the string
0B09AC CD 2D 0B 0B 1343**  			CALL    BRAKET			; Check for closing bracket
0B09B0 F1          1344**  			POP     AF			; A: Number of iterations of string
0B09B1 B7          1345**  			OR      A			; Set flags
0B09B2 28 C3       1346**  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0B09B4 3D          1347**  			DEC     A
0B09B5 4F          1348**  			LD      C,A			; C: Loop counter
0B09B6 3E 80       1349**  			LD      A,80H			; String marker
0B09B8 C8          1350**  			RET     Z
0B09B9 1C          1351**  			INC     E			; Check for empty string
0B09BA 1D          1352**  			DEC     E
0B09BB C8          1353**  			RET     Z              		; And return
0B09BC 43          1354**  			LD      B,E			; B: String length tally
0B09BD 21 00 4B 0B 1355**  			LD	HL,ACCS
0B09C1 C5          1356**  STRIN1:			PUSH    BC
0B09C2 7E          1357**  STRIN2:			LD      A,(HL)
0B09C3 23          1358**  			INC     HL
0B09C4 12          1359**  			LD      (DE),A
0B09C5 1C          1360**  			INC     E
0B09C6 3E 13       1361**  			LD      A,19
0B09C8 CA 5E 38 0B 1362**  			JP      Z,ERROR_         	; Throw a "String too long" error
0B09CC 10 F4       1363**  			DJNZ    STRIN2
0B09CE C1          1364**  			POP     BC
0B09CF 0D          1365**  			DEC     C
0B09D0 20 EF       1366**  			JR      NZ,STRIN1
0B09D2 3E 80       1367**  			LD      A,80H
0B09D4 C9          1368**  			RET
0B09D5             1369**  ;
0B09D5             1370**  ;SUBROUTINES
0B09D5             1371**  ;
0B09D5             1372**  ;SWAP - Swap arguments
0B09D5             1373**  ;Exchanges DE,HL D'E',H'L' and B,C
0B09D5             1374**  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B09D5             1375**  ;
0B09D5 79          1376**  SWAP:			LD      A,C
0B09D6 48          1377**  			LD      C,B
0B09D7 47          1378**  			LD      B,A
0B09D8 EB          1379**  			EX      DE,HL
0B09D9 D9          1380**  			EXX
0B09DA EB          1381**  			EX      DE,HL
0B09DB D9          1382**  			EXX
0B09DC C9          1383**  			RET
0B09DD             1384**  ;
0B09DD             1385**  ;TEST - Test HLH'L' for zero
0B09DD             1386**  ;Outputs: Z-flag set & A=0 if zero
0B09DD             1387**  ;Destroys: A,F
0B09DD             1388**  ;
0B09DD 7C          1389**  TEST:			LD      A,H
0B09DE B5          1390**  			OR      L
0B09DF D9          1391**  			EXX
0B09E0 B4          1392**  			OR      H
0B09E1 B5          1393**  			OR      L
0B09E2 D9          1394**  			EXX
0B09E3 C9          1395**  			RET
0B09E4             1396**  ;
0B09E4             1397**  ;DECODE - Decode line number in pseudo-binary.
0B09E4             1398**  ;   Inputs: IY = Text pointer.
0B09E4             1399**  ;   Outputs: HL=0, H'L'=line number, C=0.
0B09E4             1400**  ;   Destroys: A,C,H,L,H',L',IY,F
0B09E4             1401**  ;
0B09E4 D9          1402**  DECODE:			EXX
0B09E5 21 00 00 00 1403**  			LD	HL, 0
0B09E9 FD 7E 00    1404**  			LD      A,(IY)
0B09EC FD 23       1405**  			INC     IY
0B09EE 17          1406**  			RLA
0B09EF 17          1407**  			RLA
0B09F0 67          1408**  			LD      H,A
0B09F1 E6 C0       1409**  			AND     0C0H
0B09F3 FD AE 00    1410**  			XOR     (IY)
0B09F6 FD 23       1411**  			INC     IY
0B09F8 6F          1412**  			LD      L,A
0B09F9 7C          1413**  			LD      A,H
0B09FA 17          1414**  			RLA
0B09FB 17          1415**  			RLA
0B09FC E6 C0       1416**  			AND     0C0H
0B09FE FD AE 00    1417**  			XOR     (IY)
0B0A01 FD 23       1418**  			INC     IY
0B0A03 67          1419**  			LD      H,A
0B0A04 D9          1420**  			EXX
0B0A05             1421**  ;			XOR     A
0B0A05             1422**  ;			LD      C,A
0B0A05             1423**  ;			LD      H,A
0B0A05             1424**  ;			LD      L,A
0B0A05 21 00 00 00 1425**  			LD	HL, 0
0B0A09 4D          1426**  			LD	C, L
0B0A0A C9          1427**  			RET
0B0A0B             1428**  ;
0B0A0B             1429**  ;HEXSTR - convert numeric value to HEX string.
0B0A0B             1430**  ;   Inputs: HLH'L'C = integer or floating-point number
0B0A0B             1431**  ;  Outputs: String in string accumulator.
0B0A0B             1432**  ;           E = string length.  D = ACCS/256
0B0A0B             1433**  ;
0B0A0B FD 23       1434**  HEXSTS:			INC     IY              ;SKIP TILDE
0B0A0D CD 1B 04 0B 1435**  			CALL    ITEMN
0B0A11 CD 18 0A 0B 1436**  			CALL    HEXSTR
0B0A15 3E 80       1437**  			LD      A,80H
0B0A17 C9          1438**  			RET
0B0A18             1439**  ;
0B0A18 CD 60 07 0B 1440**  HEXSTR:			CALL    SFIX
0B0A1C 01 08 00 00 1441**  			LD      BC,8
0B0A20 11 00 4B 0B 1442**  			LD      DE,ACCS
0B0A24 C5          1443**  HEXST1:			PUSH    BC
0B0A25 06 04       1444**  			LD      B,4
0B0A27 AF          1445**  			XOR     A
0B0A28 D9          1446**  HEXST2:			EXX
0B0A29 52 29       1447**  			ADD.S	HL,HL
0B0A2B D9          1448**  			EXX
0B0A2C 52 ED 6A    1449**  			ADC.S	HL,HL
0B0A2F 17          1450**  			RLA
0B0A30 10 F6       1451**  			DJNZ    HEXST2
0B0A32 C1          1452**  			POP     BC
0B0A33 0D          1453**  			DEC     C
0B0A34 F8          1454**  			RET     M
0B0A35 28 06       1455**  			JR      Z,HEXST3
0B0A37 B7          1456**  			OR      A
0B0A38 20 03       1457**  			JR      NZ,HEXST3
0B0A3A B8          1458**  			CP      B
0B0A3B 28 E7       1459**  			JR      Z,HEXST1
0B0A3D C6 90       1460**  HEXST3:			ADD     A,90H
0B0A3F 27          1461**  			DAA
0B0A40 CE 40       1462**  			ADC     A,40H
0B0A42 27          1463**  			DAA
0B0A43 12          1464**  			LD      (DE),A
0B0A44 13          1465**  			INC     DE
0B0A45 47          1466**  			LD      B,A
0B0A46 18 DC       1467**  			JR      HEXST1
0B0A48             1468**  ;
0B0A48             1469**  ;Function STR - convert numeric value to ASCII string.
0B0A48             1470**  ;   Inputs: HLH'L'C = integer or floating-point number.
0B0A48             1471**  ;  Outputs: String in string accumulator.
0B0A48             1472**  ;           E = length, D = ACCS/256
0B0A48             1473**  ;           A = 80H (type=string)
0B0A48             1474**  ;
0B0A48             1475**  ;First normalise for decimal output:
0B0A48             1476**  ;
0B0A48 CD 6E 0B 0B 1477**  STRS:			CALL    NXT
0B0A4C FE 7E       1478**  			CP      '~'
0B0A4E 28 BB       1479**  			JR      Z,HEXSTS
0B0A50 CD 1B 04 0B 1480**  			CALL    ITEMN
0B0A54 DD 21 00 4D 1481**  			LD      IX,STAVAR
       0B          
0B0A59 DD 7E 03    1482**  			LD      A,(IX+3)
0B0A5C B7          1483**  			OR      A
0B0A5D DD 21 8A 0A 1484**  			LD      IX,G9-1         ;G9 FORMAT
       0B          
0B0A62 28 05       1485**  			JR      Z,STR0
0B0A64 DD 21 00 4D 1486**  STR:			LD      IX,STAVAR
       0B          
0B0A69 11 00 4B 0B 1487**  STR0:			LD      DE,ACCS
0B0A6D 3E 25       1488**  			LD      A,37
0B0A6F CD 68 21 0B 1489**  			CALL    FPP
0B0A73 DA 5E 38 0B 1490**  			JP      C,ERROR_
0B0A77 DD CB 02 46 1491**  			BIT     0,(IX+2)
0B0A7B 3E 80       1492**  STR1:			LD      A,80H           ;STRING MARKER
0B0A7D C8          1493**  			RET     Z
0B0A7E 79          1494**  			LD      A,C
0B0A7F C6 04       1495**  			ADD     A,4
0B0A81 BB          1496**  STR2:			CP      E
0B0A82 28 F7       1497**  			JR      Z,STR1
0B0A84 EB          1498**  			EX      DE,HL
0B0A85 36 20       1499**  			LD      (HL),' '        ;TRAILING SPACE
0B0A87 23          1500**  			INC     HL
0B0A88 EB          1501**  			EX      DE,HL
0B0A89 18 F6       1502**  			JR      STR2
0B0A8B             1503**  ;
0B0A8B 09 00       1504**  G9:			DW    9
0B0A8D             1505**  ;
0B0A8D             1506**  ;STRING COMPARE
0B0A8D             1507**  ;Compare string (DE) length B with string (HL) length C.
0B0A8D             1508**  ;Result preset to false.
0B0A8D             1509**  ;
0B0A8D CD 9B 0A 0B 1510**  SCP:			CALL	SCP0
0B0A91             1511**  ;
0B0A91 3E 00       1512**  ZERO:			LD      A,0
0B0A93 D9          1513**  			EXX
0B0A94 67          1514**  			LD      H,A
0B0A95 6F          1515**  			LD      L,A
0B0A96 D9          1516**  			EXX
0B0A97 67          1517**  			LD      H,A
0B0A98 6F          1518**  			LD      L,A
0B0A99 4F          1519**  			LD      C,A
0B0A9A C9          1520**  			RET
0B0A9B             1521**  ;
0B0A9B 04          1522**  SCP0:			INC     B
0B0A9C 0C          1523**  			INC     C
0B0A9D 05          1524**  SCP1:			DEC     B
0B0A9E 28 0A       1525**  			JR      Z,SCP2
0B0AA0 0D          1526**  			DEC     C
0B0AA1 28 0C       1527**  			JR      Z,SCP3
0B0AA3 1A          1528**  			LD      A,(DE)
0B0AA4 BE          1529**  			CP      (HL)
0B0AA5 C0          1530**  			RET     NZ
0B0AA6 13          1531**  			INC     DE
0B0AA7 23          1532**  			INC     HL
0B0AA8 18 F3       1533**  			JR      SCP1
0B0AAA B7          1534**  SCP2:			OR      A
0B0AAB 0D          1535**  			DEC     C
0B0AAC C8          1536**  			RET     Z
0B0AAD 37          1537**  			SCF
0B0AAE C9          1538**  			RET
0B0AAF B7          1539**  SCP3:			OR      A
0B0AB0 0C          1540**  			INC     C
0B0AB1 C9          1541**  			RET
0B0AB2             1542**  ;
0B0AB2             1543**  ; PUSHS - SAVE STRING ON STACK.
0B0AB2             1544**  ;     Inputs: String in string accumulator.
0B0AB2             1545**  ;             E = string length.
0B0AB2             1546**  ;             A - saved on stack.
0B0AB2             1547**  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0B0AB2             1548**  ;
0B0AB2 CD 4D 17 0B 1549**  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0B0AB6 DD E1       1550**  			POP     IX              	; IX: Return address
0B0AB8 B7          1551**  			OR      A               	; Clear the carry flag
0B0AB9 01 00 00 00 1552**  			LD	BC,0			; BC: Length of the string
0B0ABD 4B          1553**  			LD	C,E
0B0ABE 21 00 4B 0B 1554**  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B0AC2 11 00 4B 0B 1555**  			LD	DE,ACCS
0B0AC6 59          1556**  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0B0AC7 ED 52       1557**  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0B0AC9 39          1558**  			ADD     HL,SP			; Grow the stack
0B0ACA F9          1559**  			LD      SP,HL
0B0ACB 57          1560**  			LD      D,A			;  D: This needs to be set to A for some functions
0B0ACC             1561**  ; BEGIN MISSING FROM BINARY
0B0ACC             1562**  			; LD	B,A			; Stack A and C (the string length)
0B0ACC             1563**  			; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0B0ACC             1564**  			; LD	B,0			; Reset B to 0 for the LDIR in this function
0B0ACC             1565**  ; END MISSING FROM BINARY
0B0ACC D5          1566**  			PUSH 	DE ; ADDED FROM BINARY
0B0ACD 28 0B       1567**  			JR      Z,PUSHS1        	; Is it zero length?
0B0ACF 11 00 4B 0B 1568**  			LD      DE,ACCS			; DE: Destination
0B0AD3 EB          1569**  			EX      DE,HL			; HL: Destination, DE: Address on stack
0B0AD4 ED B0       1570**  			LDIR	                    	; Copy to stack
0B0AD6 CD 4D 17 0B 1571**  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0B0ADA DD E9       1572**  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B0ADC             1573**  ;
0B0ADC             1574**  ; POPS - RESTORE STRING FROM STACK.
0B0ADC             1575**  ;     Inputs: C = string length.
0B0ADC             1576**  ;    Outputs: String in string accumulator.
0B0ADC             1577**  ;             E = string length.
0B0ADC             1578**  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0B0ADC             1579**  ;
0B0ADC DD E1       1580**  POPS:			POP     IX              	; IX: Return address
0B0ADE 69          1581**  			LD	L,C			; Temporarily store string length in L
0B0ADF 01 00 00 00 1582**  			LD	BC,0
0B0AE3 4D          1583**  			LD	C,L			; BC: Number of bytes to copy
0B0AE4 21 00 00 00 1584**  			LD      HL,0			; HL: 0
0B0AE8 39          1585**  			ADD     HL,SP			; HL: Stack address
0B0AE9 11 00 4B 0B 1586**  			LD      DE,ACCS			; DE: Destination
0B0AED 0C          1587**  			INC     C			; Quick check to see if this is a zero length string
0B0AEE 0D          1588**  			DEC     C
0B0AEF 28 02       1589**  			JR      Z,POPS1         	; Yes it is, so skip
0B0AF1 ED B0       1590**  			LDIR                    	; No, so copy from the stack
0B0AF3 F9          1591**  POPS1:			LD      SP,HL			; Shrink the stack
0B0AF4 DD E9       1592**  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B0AF6             1593**  ;
0B0AF6 FD 7E 00    1594**  HEXDIG:			LD      A,(IY)
0B0AF9 FE 30       1595**  			CP      '0'
0B0AFB D8          1596**  			RET     C
0B0AFC FE 3A       1597**  			CP      '9'+1
0B0AFE 3F          1598**  			CCF
0B0AFF D0          1599**  			RET     NC
0B0B00 FE 41       1600**  			CP      'A'
0B0B02 D8          1601**  			RET     C
0B0B03 D6 37       1602**  			SUB     'A'-10
0B0B05 FE 10       1603**  			CP      16
0B0B07 3F          1604**  			CCF
0B0B08 C9          1605**  			RET
0B0B09             1606**  ;
0B0B09 FD 7E 00    1607**  BINDIG:			LD	A,(IY)
0B0B0C FE 30       1608**  			CP	'0'
0B0B0E D8          1609**  			RET	C
0B0B0F FE 32       1610**  			CP	'1'+1
0B0B11 3F          1611**  			CCF
0B0B12 C9          1612**  			RET
0B0B13             1613**  ;
0B0B13 FE 3E       1614**  RELOP?:			CP      '>'
0B0B15 D0          1615**  			RET     NC
0B0B16 FE 3D       1616**  			CP      '='
0B0B18 D0          1617**  			RET     NC
0B0B19 FE 3C       1618**  			CP      '<'
0B0B1B C9          1619**  			RET
0B0B1C             1620**  ;
0B0B1C CD 13 04 0B 1621**  EXPRSC:			CALL    EXPRS
0B0B20 CD 6E 0B 0B 1622**  COMMA:			CALL    NXT
0B0B24 FD 23       1623**  			INC     IY
0B0B26 FE 2C       1624**  			CP      ','
0B0B28 C8          1625**  			RET     Z
0B0B29 3E 05       1626**  			LD      A,5
0B0B2B 18 0B       1627**  			JR      ERROR1_EV          ;"Missing ,"
0B0B2D             1628**  ;
0B0B2D CD 6E 0B 0B 1629**  BRAKET:			CALL    NXT
0B0B31 FD 23       1630**  			INC     IY
0B0B33 FE 29       1631**  			CP      ')'
0B0B35 C8          1632**  			RET     Z
0B0B36 3E 1B       1633**  			LD      A,27
0B0B38 C3 5E 38 0B 1634**  ERROR1_EV:			JP      ERROR_           ;"Missing )"
0B0B3C             1635**  ;
0B0B3C FD 23       1636**  SAVE_EV:			INC     IY
0B0B3E 08          1637**  SAVE1:			EX      AF,AF'
0B0B3F FA 34 04 0B 1638**  			JP      M,TYPE_EV_
0B0B43 08          1639**  			EX      AF,AF'
0B0B44 E3          1640**  			EX      (SP),HL
0B0B45 D9          1641**  			EXX
0B0B46 E5          1642**  			PUSH    HL
0B0B47 D9          1643**  			EXX
0B0B48 F5          1644**  			PUSH    AF
0B0B49 C5          1645**  			PUSH    BC
0B0B4A E9          1646**  			JP      (HL)
0B0B4B             1647**  ;
0B0B4B 08          1648**  DOIT:			EX      AF,AF'
0B0B4C FA 34 04 0B 1649**  			JP      M,TYPE_EV_
0B0B50 D9          1650**  			EXX
0B0B51 C1          1651**  			POP     BC              ;RETURN ADDRESS
0B0B52 D9          1652**  			EXX
0B0B53 79          1653**  			LD      A,C
0B0B54 C1          1654**  			POP     BC
0B0B55 47          1655**  			LD      B,A
0B0B56 F1          1656**  			POP     AF              ;OPERATOR
0B0B57 D9          1657**  			EXX
0B0B58 EB          1658**  			EX      DE,HL
0B0B59 E1          1659**  			POP     HL
0B0B5A D9          1660**  			EXX
0B0B5B EB          1661**  			EX      DE,HL
0B0B5C E1          1662**  			POP     HL
0B0B5D D9          1663**  			EXX
0B0B5E C5          1664**  			PUSH    BC
0B0B5F D9          1665**  			EXX
0B0B60 E6 0F       1666**  			AND     0FH
0B0B62 CD 68 21 0B 1667**  			CALL    FPP
0B0B66 38 D0       1668**  			JR      C,ERROR1_EV
0B0B68 AF          1669**  			XOR     A
0B0B69 08          1670**  			EX      AF,AF'          ;TYPE
0B0B6A FD 7E 00    1671**  			LD      A,(IY)
0B0B6D C9          1672**  			RET
0B0B6E             1673**  ;
0B0B6E             1674**  ; Skip spaces
0B0B6E             1675**  ; - IY: String pointer
0B0B6E             1676**  ; Returns:
0B0B6E             1677**  ;  - A: The non-space character found
0B0B6E             1678**  ; - IY: Points to the character before that
0B0B6E             1679**  ;
0B0B6E FD 7E 00    1680**  NXT:			LD      A,(IY)			; Fetch the character
0B0B71 FE 20       1681**  			CP      ' '			; If it is space, then return
0B0B73 C0          1682**  			RET     NZ
0B0B74 FD 23       1683**  			INC     IY			; Increment the pointer and
0B0B76 C3 6E 0B 0B 1684**  			JP      NXT			; Loop
0B0B7A             1685**  ;
0B0B7A E5          1686**  DISPT2:			PUSH    HL
0B0B7B 21 B3 02 0B 1687**  			LD      HL,SOPTBL
0B0B7F 18 07       1688**  			JR      DISPT0
0B0B81             1689**  ;
0B0B81 E5          1690**  DISPAT:			PUSH    HL
0B0B82 D6 8D       1691**  			SUB     FUNTOK
0B0B84 21 08 02 0B 1692**  			LD      HL,FUNTBL
0B0B88 C5          1693**  DISPT0:			PUSH    BC
0B0B89             1694**  
0B0B89 01 03 00 00 1695**  			LD	BC, 3
0B0B8D 47          1696**  			LD	B, A
0B0B8E ED 4C       1697**  			MLT	BC
0B0B90 09          1698**  			ADD	HL, BC
0B0B91 ED 27       1699**  			LD	HL, (HL)
0B0B93             1700**  
0B0B93             1701**  ;			ADD     A,A
0B0B93             1702**  ;			LD      C,A
0B0B93             1703**  ;			LD      B,0
0B0B93             1704**  ;			ADD     HL,BC
0B0B93             1705**  ;			LD      A,(HL)
0B0B93             1706**  ;			INC     HL
0B0B93             1707**  ;			LD      H,(HL)
0B0B93             1708**  ;			LD      L,A
0B0B93             1709**  
0B0B93 C1          1710**  			POP     BC
0B0B94 E3          1711**  			EX      (SP),HL
0B0B95 C9          1712**  			RET                     ;OFF TO ROUTINE
0B0B96             1713**  
0B0B96             0006*       include "basic/exec.asm"
0B0B96             0001**  ;
0B0B96             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B0B96             0003**  ;		Statement Execution & Assembler Module - "EXEC"
0B0B96             0004**  ; Author:	(C) Copyright  R.T.Russell  1984
0B0B96             0005**  ; Modified By:	Dean Belfield
0B0B96             0006**  ; Created:	12/05/2023
0B0B96             0007**  ; Last Updated:	26/06/2023
0B0B96             0008**  ;
0B0B96             0009**  ; Modinfo:
0B0B96             0010**  ; 27/01/1984:	Version 2.1
0B0B96             0011**  ; 02/03/1987:	Version 3.0
0B0B96             0012**  ; 11/06/1987:	Version 3.1
0B0B96             0013**  ; 12/05/2023:	Modified by Dean Belfield
0B0B96             0014**  ; 07/06/2023:	Modified to run in ADL mode
0B0B96             0015**  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
0B0B96             0016**  
0B0B96             0017**  			; .ASSUME	ADL = 1
0B0B96             0018**  
0B0B96             0019**  			; INCLUDE	"equs.inc"
0B0B96             0020**  
0B0B96             0021**  			; SEGMENT CODE
0B0B96             0022**  
0B0B96             0023**  			; XDEF	XEQ
0B0B96             0024**  			; XDEF	CHAIN0
0B0B96             0025**  			; XDEF	RUN
0B0B96             0026**  			; XDEF	SYNTAX
0B0B96             0027**  			; XDEF	ESCAPE
0B0B96             0028**  			; XDEF	FN_EX
0B0B96             0029**  			; XDEF	USR
0B0B96             0030**  			; XDEF	STORE5
0B0B96             0031**  			; XDEF	STORE4
0B0B96             0032**  			; XDEF	CHECK
0B0B96             0033**  			; XDEF	TERMQ
0B0B96             0034**  			; XDEF	FILL
0B0B96             0035**  			; XDEF	X4OR5
0B0B96             0036**  			; XDEF	MUL16
0B0B96             0037**  			; XDEF	CHANEL
0B0B96             0038**  			; XDEF	ASSEM
0B0B96             0039**  
0B0B96             0040**  			; XREF	AUTO
0B0B96             0041**  			; XREF	DELETE
0B0B96             0042**  			; XREF	LOAD
0B0B96             0043**  			; XREF	LIST_
0B0B96             0044**  			; XREF	NEW
0B0B96             0045**  			; XREF	OLD
0B0B96             0046**  			; XREF	RENUM
0B0B96             0047**  			; XREF	SAVE
0B0B96             0048**  			; XREF	SOUND
0B0B96             0049**  			; XREF	CLG
0B0B96             0050**  			; XREF	DRAW
0B0B96             0051**  			; XREF	ENVEL
0B0B96             0052**  			; XREF	GCOL
0B0B96             0053**  			; XREF	MODE
0B0B96             0054**  			; XREF	MOVE
0B0B96             0055**  			; XREF	PLOT
0B0B96             0056**  			; XREF	COLOUR
0B0B96             0057**  			; XREF	EXPRS
0B0B96             0058**  			; XREF	HIMEM
0B0B96             0059**  			; XREF	LOAD0
0B0B96             0060**  			; XREF	RANDOM
0B0B96             0061**  			; XREF	CLEAR
0B0B96             0062**  			; XREF	ERRTRP
0B0B96             0063**  			; XREF	PAGE_
0B0B96             0064**  			; XREF	DATAPTR
0B0B96             0065**  			; XREF	ERRLIN
0B0B96             0066**  			; XREF	TRAP
0B0B96             0067**  			; XREF	NXT
0B0B96             0068**  			; XREF	SETLIN
0B0B96             0069**  			; XREF	CLOOP
0B0B96             0070**  			; XREF	OSSHUT
0B0B96             0071**  			; XREF	WARM
0B0B96             0072**  			; XREF	TRACEN
0B0B96             0073**  			; XREF	OUTCHR
0B0B96             0074**  			; XREF	PBCDL
0B0B96             0075**  			; XREF	OSCLI
0B0B96             0076**  			; XREF	LISTON
0B0B96             0077**  			; XREF	GETVAR
0B0B96             0078**  			; XREF	PUTVAR
0B0B96             0079**  			; XREF	DATPTR
0B0B96             0080**  			; XREF	ERROR_
0B0B96             0081**  			; XREF	EXPR
0B0B96             0082**  			; XREF	CREATE
0B0B96             0083**  			; XREF	EXPRI
0B0B96             0084**  			; XREF	BRAKET
0B0B96             0085**  			; XREF	FREE
0B0B96             0086**  			; XREF	OSBPUT
0B0B96             0087**  			; XREF	COUNT
0B0B96             0088**  			; XREF	STR
0B0B96             0089**  			; XREF	HEXSTR
0B0B96             0090**  			; XREF	CRLF
0B0B96             0091**  			; XREF	ITEMI
0B0B96             0092**  			; XREF	FINDL
0B0B96             0093**  			; XREF	TEST
0B0B96             0094**  			; XREF	EXPRN
0B0B96             0095**  			; XREF	DLOAD5
0B0B96             0096**  			; XREF	DLOAD5_SPL
0B0B96             0097**  			; XREF	LOADN
0B0B96             0098**  			; XREF	FPP
0B0B96             0099**  			; XREF	SWAP
0B0B96             0100**  			; XREF	GETDEF
0B0B96             0101**  			; XREF	ZERO
0B0B96             0102**  			; XREF	OSBGET
0B0B96             0103**  			; XREF	BUFFER
0B0B96             0104**  			; XREF	CONS
0B0B96             0105**  			; XREF	VAL0
0B0B96             0106**  			; XREF	OSLINE
0B0B96             0107**  			; XREF	CLRSCN
0B0B96             0108**  			; XREF	TELL
0B0B96             0109**  			; XREF	SAYLN
0B0B96             0110**  			; XREF	REPORT
0B0B96             0111**  			; XREF	PUTPTR
0B0B96             0112**  			; XREF	PUTIME
0B0B96             0113**  			; XREF	PUTIMS
0B0B96             0114**  			; XREF	LOMEM
0B0B96             0115**  			; XREF	WIDTH
0B0B96             0116**  			; XREF	OSWRCH
0B0B96             0117**  			; XREF	COMMA
0B0B96             0118**  			; XREF	OSCALL
0B0B96             0119**  			; XREF	SFIX
0B0B96             0120**  			; XREF	LOAD4
0B0B96             0121**  			; XREF	PUSHS
0B0B96             0122**  			; XREF	POPS
0B0B96             0123**  			; XREF	LOADS
0B0B96             0124**  			; XREF	PUTCSR
0B0B96             0125**  			; XREF	OUT_
0B0B96             0126**  			; XREF	R0
0B0B96             0127**  ;
0B0B96             0128**  ; List of token values used in this module
0B0B96             0129**  ;
0B0B96             0130**  TAND:			EQU     80H
0B0B96             0131**  TOR:			EQU     84H
0B0B96             0132**  TERROR_EX:			EQU     85H
0B0B96             0133**  LINE_EX_:			EQU     86H
0B0B96             0134**  OFF_:			EQU     87H
0B0B96             0135**  STEP:			EQU     88H
0B0B96             0136**  SPC:			EQU     89H
0B0B96             0137**  TAB:			EQU     8AH
0B0B96             0138**  ELSE_EX_:			EQU     8BH
0B0B96             0139**  THEN_EX_:			EQU     8CH
0B0B96             0140**  LINO_EX:			EQU     8DH
0B0B96             0141**  TO_EX:			EQU     B8H
0B0B96             0142**  TCMD_EX:			EQU     C6H
0B0B96             0143**  TCALL:			EQU     D6H
0B0B96             0144**  DATA_EX_:			EQU     DCH
0B0B96             0145**  DEF_:			EQU     DDH
0B0B96             0146**  TGOSUB:			EQU     E4H
0B0B96             0147**  TGOTO:			EQU     E5H
0B0B96             0148**  TON:			EQU     EEH
0B0B96             0149**  TPROC:			EQU     F2H
0B0B96             0150**  TSTOP:			EQU     FAH
0B0B96             0151**  
0B0B96             0152**  ; The command table
0B0B96             0153**  ; Commands are tokens from C6H onwards; this lookup table is used to
0B0B96             0154**  ; run the corresponding function; Note that DATA and DEF both use the same
0B0B96             0155**  ; code as REM
0B0B96             0156**  ;
0B0B96 E7 37 0B    0157**  CMDTAB:			DW24  AUTO			; C6H
0B0B99 4A 36 0B    0158**  			DW24  DELETE			; C7H
0B0B9C 28 38 0B    0159**  			DW24  LOAD			; C8H
0B0B9F 85 36 0B    0160**  			DW24  LIST_			; C9H
0B0BA2 05 38 0B    0161**  			DW24  NEW			; CAH
0B0BA5 0B 38 0B    0162**  			DW24  OLD			; CBH
0B0BA8 14 37 0B    0163**  			DW24  RENUM			; CCH
0B0BAB 39 38 0B    0164**  			DW24  SAVE			; CDH
0B0BAE A6 16 0B    0165**  			DW24  PUT			; CEH
0B0BB1 C6 14 0B    0166**  			DW24  PTR_EX			; CFH
0B0BB4 E0 14 0B    0167**  			DW24  PAGEV_EX			; D0H
0B0BB7 F3 14 0B    0168**  			DW24  TIMEV_EX			; D1H
0B0BBA 1C 15 0B    0169**  			DW24  LOMEMV_EX			; D2H
0B0BBD 35 15 0B    0170**  			DW24  HIMEMV_EX			; D3H
0B0BC0 24 47 0B    0171**  			DW24  SOUND			; D4H
0B0BC3 C0 15 0B    0172**  			DW24  BPUT			; D5H
0B0BC6 D8 15 0B    0173**  			DW24  CALL_			; D6H
0B0BC9 4A 0C 0B    0174**  			DW24  CHAIN			; D7H
0B0BCC 95 14 0B    0175**  			DW24  CLR			; D8H
0B0BCF B4 15 0B    0176**  			DW24  CLOSE			; D9H
0B0BD2 C0 44 0B    0177**  			DW24  CLG			; DAH
0B0BD5 68 14 0B    0178**  			DW24  CLS			; DBH
0B0BD8 29 0D 0B    0179**  			DW24  REM_EX             		; DCH: DATA
0B0BDB 29 0D 0B    0180**  			DW24  REM_EX             		; DDH: DEF
0B0BDE EF 0D 0B    0181**  			DW24  DIM_EX			; DEH
0B0BE1 EA 46 0B    0182**  			DW24  DRAW			; DFH
0B0BE4 C4 0C 0B    0183**  			DW24  END_			; E0H
0B0BE7 80 12 0B    0184**  			DW24  ENDPRO			; E1H
0B0BEA B5 44 0B    0185**  			DW24  ENVEL			; E2H
0B0BED 95 10 0B    0186**  			DW24  FOR_EX			; E3H
0B0BF0 45 10 0B    0187**  			DW24  GOSUB_EX			; E4H
0B0BF3 29 10 0B    0188**  			DW24  GOTO_EX			; E5H
0B0BF6 7E 46 0B    0189**  			DW24  GCOL			; E6H
0B0BF9 34 14 0B    0190**  			DW24  IF_			; E7H
0B0BFC 22 13 0B    0191**  			DW24  INPUT			; E8H
0B0BFF 4A 0D 0B    0192**  			DW24  LET			; E9H
0B0C02 25 12 0B    0193**  			DW24  LOCAL_EX_			; EAH
0B0C05 D0 44 0B    0194**  			DW24  MODE			; EBH
0B0C08 E2 46 0B    0195**  			DW24  MOVE			; ECH
0B0C0B E3 10 0B    0196**  			DW24  NEXT_EX			; EDH
0B0C0E BC 0F 0B    0197**  			DW24  ON_EX_			; EEH
0B0C11 8E 15 0B    0198**  			DW24  VDU			; EFH
0B0C14 B0 46 0B    0199**  			DW24  PLOT			; F0H
0B0C17 C5 0E 0B    0200**  			DW24  PRINT_			; F1H
0B0C1A 82 11 0B    0201**  			DW24  PROC_EX			; F2H
0B0C1D D4 13 0B    0202**  			DW24  READ			; F3H
0B0C20 29 0D 0B    0203**  			DW24  REM_EX			; F4H
0B0C23 65 10 0B    0204**  			DW24  REPEAT_EX			; F5H
0B0C26 8D 14 0B    0205**  			DW24  REPOR			; F6H
0B0C29 9F 14 0B    0206**  			DW24  RESTOR_EX			; F7H
0B0C2C 53 10 0B    0207**  			DW24  RETURN			; F8H
0B0C2F 44 0C 0B    0208**  			DW24  RUN			; F9H
0B0C32 75 14 0B    0209**  			DW24  STOP			; FAH
0B0C35 CC 45 0B    0210**  			DW24  COLOUR			; FBH
0B0C38 70 15 0B    0211**  			DW24  TRACE_EX			; FCH
0B0C3B 6F 10 0B    0212**  			DW24  UNTIL_EX			; FDH
0B0C3E 62 15 0B    0213**  			DW24  WIDTHV			; FEH
0B0C41 0F 0D 0B    0214**  			DW24  CLI             		; FFH: OSCLI
0B0C44             0215**  
0B0C44             0216**  ; RUN
0B0C44             0217**  ; RUN "filename"
0B0C44             0218**  ;
0B0C44 CD 78 18 0B 0219**  RUN:			CALL    TERMQ			; Standalone RUN command?
0B0C48 28 10       0220**  			JR      Z,RUN0			; Yes, so just RUN the code
0B0C4A             0221**  
0B0C4A             0222**  ; CHAIN "filename"
0B0C4A             0223**  ;
0B0C4A CD 13 04 0B 0224**  CHAIN:			CALL    EXPRS			; Get the filename
0B0C4E 3E 0D       0225**  			LD      A,CR			; Terminate it with a CR
0B0C50 12          0226**  			LD      (DE),A
0B0C51 ED 7B 20 4E 0227**  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       0B          
0B0C56 CD 1D 39 0B 0228**  			CALL    LOAD0			; And load the file in
0B0C5A             0229**  ;
0B0C5A ED 7B 20 4E 0230**  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       0B          
0B0C5F DD 21 38 4E 0231**  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       0B          
0B0C64 ED 5F       0232**  @@:			LD      A, R			; Use the R register to seed the random number generator
0B0C66 28 FC       0233**  			JR      Z, @B			; Loop unti we get a non-zero value in A
0B0C68 07          0234**  			RLCA				; Rotate it
0B0C69 07          0235**  			RLCA
0B0C6A DD 77 03    0236**  			LD      (IX+3),A		; And store
0B0C6D 9F          0237**  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
0B0C6E DD 77 04    0238**  			LD      (IX+4),A		; And store
0B0C71 CD 74 39 0B 0239**  			CALL    CLEAR
0B0C75 21 00 00 00 0240**  			LD      HL,0			; Clear the error trap sysvar
0B0C79 22 2C 4E 0B 0241**  			LD      (ERRTRP),HL
0B0C7D 2A 14 4E 0B 0242**  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
0B0C81 3E DC       0243**  			LD      A,DATA_EX_			; The DATA token value
0B0C83 CD 4C 19 0B 0244**  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
0B0C87 22 31 4E 0B 0245**  			LD      (DATPTR),HL     	; Set data pointer
0B0C8B FD 2A 14 4E 0246**  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       0B          
0B0C90             0247**  ;
0B0C90 CD D8 0C 0B 0248**  XEQ0:			CALL    NEWLIN
0B0C94 FD 22 35 4E 0249**  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       0B          
0B0C99 CD 6B 40 0B 0250**  			CALL    TRAP           		; Check keyboard
0B0C9D CD 6E 0B 0B 0251**  XEQ1:			CALL    NXT
0B0CA1 FD 23       0252**  			INC     IY
0B0CA3 FE 3A       0253**  			CP      ':'             	; Seperator
0B0CA5 28 F6       0254**  			JR      Z,XEQ1
0B0CA7 FE 0D       0255**  			CP      CR
0B0CA9 28 E5       0256**  			JR      Z,XEQ0          	; New program line
0B0CAB D6 C6       0257**  			SUB     TCMD_EX
0B0CAD DA 38 0D 0B 0258**  			JP      C,LET0          	; Implied "LET"
0B0CB1             0259**  
0B0CB1 01 03 00 00 0260**  			LD	BC, 3
0B0CB5 47          0261**  			LD	B, A
0B0CB6 ED 4C       0262**  			MLT	BC
0B0CB8 21 96 0B 0B 0263**  			LD	HL,CMDTAB
0B0CBC 09          0264**  			ADD	HL, BC
0B0CBD ED 27       0265**  			LD	HL, (HL)		; Table entry
0B0CBF             0266**  
0B0CBF             0267**  ;			ADD     A,A
0B0CBF             0268**  ;			LD      C,A
0B0CBF             0269**  ;			LD      B,0
0B0CBF             0270**  ;			LD      HL,CMDTAB
0B0CBF             0271**  ;			ADD     HL,BC
0B0CBF             0272**  ;			LD      A,(HL)          	; Table entry
0B0CBF             0273**  ;			INC     HL
0B0CBF             0274**  ;			LD      H,(HL)
0B0CBF             0275**  ;			LD      L,A
0B0CBF             0276**  
0B0CBF CD 6E 0B 0B 0277**  			CALL    NXT
0B0CC3 E9          0278**  			JP      (HL)            	; Execute the statement
0B0CC4             0279**  
0B0CC4             0280**  ;END
0B0CC4             0281**  ;
0B0CC4 CD AC 3A 0B 0282**  END_:			CALL    SETLIN          ;FIND CURRENT LINE
0B0CC8 7C          0283**  			LD      A,H
0B0CC9 B5          0284**  			OR      L               ;DIRECT?
0B0CCA CA 7E 31 0B 0285**  			JP      Z,CLOOP
0B0CCE 1E 00       0286**  			LD      E,0
0B0CD0 CD 29 44 0B 0287**  			CALL    OSSHUT          ;CLOSE ALL FILES
0B0CD4 C3 7D 31 0B 0288**  			JP      WARM            ;"Ready"
0B0CD8             0289**  ;
0B0CD8 FD 7E 00    0290**  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
0B0CDB 01 03 00 00 0291**  			LD      BC,3
0B0CDF FD 09       0292**  			ADD     IY,BC
0B0CE1 B7          0293**  			OR      A
0B0CE2 28 E0       0294**  			JR      Z,END_           ;LENGTH=0, EXIT
0B0CE4 2A 26 4E 0B 0295**  			LD      HL,(TRACEN)
0B0CE8 7C          0296**  			LD      A,H
0B0CE9 B5          0297**  			OR      L
0B0CEA C8          0298**  			RET     Z
0B0CEB 11 00 00 00 0299**  			LD	DE, 0		;Clear DE
0B0CEF FD 56 FF    0300**  			LD      D,(IY-1)        ;DE = LINE NUMBER
0B0CF2 FD 5E FE    0301**  			LD      E,(IY-2)
0B0CF5 ED 52       0302**  			SBC     HL,DE
0B0CF7 D8          0303**  			RET     C
0B0CF8 EB          0304**  			EX      DE,HL
0B0CF9 3E 5B       0305**  			LD      A,'['           ;TRACE
0B0CFB CD 4D 3A 0B 0306**  			CALL    OUTCHR
0B0CFF CD F5 3A 0B 0307**  			CALL    PBCDL
0B0D03 3E 5D       0308**  			LD      A,']'
0B0D05 CD 4D 3A 0B 0309**  			CALL    OUTCHR
0B0D09 3E 20       0310**  			LD      A,' '
0B0D0B C3 4D 3A 0B 0311**  			JP      OUTCHR
0B0D0F             0312**  
0B0D0F             0313**  ; Routines for each statement -------------------------------------------------
0B0D0F             0314**  
0B0D0F             0315**  ; OSCLI
0B0D0F             0316**  ;
0B0D0F CD 13 04 0B 0317**  CLI:			CALL    EXPRS
0B0D13 3E 0D       0318**  			LD      A,CR
0B0D15 12          0319**  			LD      (DE),A
0B0D16 21 00 4B 0B 0320**  			LD      HL,ACCS
0B0D1A CD 8E 40 0B 0321**  			CALL    OSCLI
0B0D1E C3 94 0C 0B 0322**  			JP      XEQ
0B0D22             0323**  
0B0D22             0324**  ; REM, *
0B0D22             0325**  ;
0B0D22 FD E5       0326**  EXT_EX:			PUSH    IY
0B0D24 E1          0327**  			POP     HL
0B0D25 CD 8E 40 0B 0328**  			CALL    OSCLI
0B0D29 FD E5       0329**  REM_EX:			PUSH    IY
0B0D2B E1          0330**  			POP     HL
0B0D2C 3E 0D       0331**  			LD      A,CR
0B0D2E 47          0332**  			LD      B,A
0B0D2F ED B1       0333**  			CPIR                    ;FIND LINE END
0B0D31 E5          0334**  			PUSH    HL
0B0D32 FD E1       0335**  			POP     IY
0B0D34 C3 90 0C 0B 0336**  			JP      XEQ0
0B0D38             0337**  
0B0D38             0338**  ; [LET] var = expr
0B0D38             0339**  ;
0B0D38 FE C5       0340**  LET0:			CP      ELSE_EX_-TCMD_EX
0B0D3A 28 ED       0341**  			JR      Z,REM_EX
0B0D3C             0342**  			; CP      ('*'-TCMD) & 0FFH
0B0D3C             0343**  			; JR      Z,EXT_EX
0B0D3C             0344**  			; CP      ('='-TCMD) & 0FFH
0B0D3C             0345**  			; JR      Z,FNEND
0B0D3C             0346**  			; CP      ('['-TCMD) & 0FFH
0B0D3C             0347**  			; ez80asm doesn't like () in expressions
0B0D3C FE 64       0348**  			CP      '*'-TCMD_EX & 0FFH
0B0D3E 28 E2       0349**  			JR      Z,EXT_EX
0B0D40 FE 77       0350**  			CP      '='-TCMD_EX & 0FFH
0B0D42 28 5B       0351**  			JR      Z,FNEND
0B0D44 FE 95       0352**  			CP      '['-TCMD_EX & 0FFH
0B0D46 28 25       0353**  			JR      Z,ASM
0B0D48 FD 2B       0354**  			DEC     IY
0B0D4A CD BC 16 0B 0355**  LET:			CALL    ASSIGN			; Assign the variable
0B0D4E CA 94 0C 0B 0356**  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
0B0D52 38 41       0357**  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
0B0D54             0358**  ;
0B0D54 F5          0359**  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
0B0D55 CD 8E 18 0B 0360**  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B0D59 E5          0361**  			PUSH    HL			; HL: Address of the variable
0B0D5A CD 13 04 0B 0362**  			CALL    EXPRS
0B0D5E DD E1       0363**  			POP     IX			; IX: Address of the variable
0B0D60 F1          0364**  			POP     AF			; AF: The variable type
0B0D61 CD FE 16 0B 0365**  			CALL    STACCS			; Copy the string from ACCS to the variable area
0B0D65 C3 94 0C 0B 0366**  XEQR:			JP      XEQ
0B0D69             0367**  ;
0B0D69 CD D8 0C 0B 0368**  ASM0:			CALL    NEWLIN
0B0D6D FD 22 35 4E 0369**  ASM:			LD      (ERRLIN),IY
       0B          
0B0D72 CD 6B 40 0B 0370**  			CALL    TRAP
0B0D76 CD 99 19 0B 0371**  			CALL    ASSEM
0B0D7A 38 19       0372**  			JR      C,SYNTAX
0B0D7C FE 0D       0373**  			CP      CR
0B0D7E 28 E9       0374**  			JR      Z,ASM0
0B0D80 21 40 4E 0B 0375**  			LD      HL,LISTON
0B0D84 7E          0376**  			LD      A,(HL)
0B0D85 E6 0F       0377**  			AND     0FH
0B0D87 F6 B0       0378**  			OR      B0H
0B0D89 77          0379**  			LD      (HL),A
0B0D8A 18 D9       0380**  			JR      XEQR
0B0D8C             0381**  ;
0B0D8C CD 38 3B 0B 0382**  VAR_:			CALL    GETVAR
0B0D90 C8          0383**  			RET     Z
0B0D91 D2 27 3B 0B 0384**  			JP      NC,PUTVAR
0B0D95 3E 10       0385**  SYNTAX:			LD      A,16            ;"Syntax error"
0B0D97 18 02       0386**  			JR	ERROR0_EX
0B0D99 3E 11       0387**  ESCAPE:			LD      A,17            ;"Escape"
0B0D9B C3 5E 38 0B 0388**  ERROR0_EX:			JP      ERROR_
0B0D9F             0389**  
0B0D9F             0390**  ; =
0B0D9F             0391**  ;
0B0D9F CD C5 02 0B 0392**  FNEND:			CALL    EXPR            ;FUNCTION RESULT
0B0DA3 43          0393**  			LD      B,E
0B0DA4 EB          0394**  			EX      DE,HL
0B0DA5 D9          0395**  			EXX                     ;SAVE RESULT
0B0DA6 EB          0396**  			EX      DE,HL           ; IN DEB'C'D'E'
0B0DA7 C1          0397**  FNEND5:			POP     BC
0B0DA8 21 56 18 0B 0398**  			LD      HL,LOCCHK
0B0DAC B7          0399**  			OR      A
0B0DAD ED 42       0400**  			SBC     HL,BC
0B0DAF 28 1C       0401**  			JR      Z,FNEND0        ;LOCAL VARIABLE
0B0DB1 21 82 11 0B 0402**  			LD      HL,FNCHK
0B0DB5 B7          0403**  			OR      A
0B0DB6 ED 42       0404**  			SBC     HL,BC
0B0DB8 3E 07       0405**  			LD      A,7
0B0DBA 20 DF       0406**  			JR      NZ,ERROR0_EX       ;"No FN"
0B0DBC FD E1       0407**  			POP     IY
0B0DBE FD 22 35 4E 0408**  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       0B          
0B0DC3 EB          0409**  			EX      DE,HL
0B0DC4 D9          0410**  			EXX
0B0DC5 EB          0411**  			EX      DE,HL
0B0DC6 11 00 4B 0B 0412**  			LD      DE,ACCS
0B0DCA 58          0413**  			LD      E,B
0B0DCB 08          0414**  			EX      AF,AF'
0B0DCC C9          0415**  			RET
0B0DCD             0416**  ;
0B0DCD DD E1       0417**  FNEND0:			POP     IX
0B0DCF C1          0418**  			POP     BC
0B0DD0 78          0419**  			LD      A,B
0B0DD1 B7          0420**  			OR      A
0B0DD2 FA E0 0D 0B 0421**  			JP      M,FNEND1        ;STRING
0B0DD6 E1          0422**  			POP     HL
0B0DD7 D9          0423**  			EXX
0B0DD8 E1          0424**  			POP     HL
0B0DD9 D9          0425**  			EXX
0B0DDA CD D4 16 0B 0426**  			CALL    STORE
0B0DDE 18 C7       0427**  			JR      FNEND5
0B0DE0 21 00 00 00 0428**  FNEND1:			LD      HL,0
0B0DE4 39          0429**  			ADD     HL,SP
0B0DE5 D5          0430**  			PUSH    DE
0B0DE6 59          0431**  			LD      E,C
0B0DE7 CD 02 17 0B 0432**  			CALL    STORES
0B0DEB D1          0433**  			POP     DE
0B0DEC F9          0434**  			LD      SP,HL
0B0DED 18 B8       0435**  			JR      FNEND5
0B0DEF             0436**  
0B0DEF             0437**  ; DIM var(dim1[,dim2[,...]])[,var(...]
0B0DEF             0438**  ; DIM var expr[,var expr...]
0B0DEF             0439**  ;
0B0DEF CD 38 3B 0B 0440**  DIM_EX:			CALL    GETVAR          	; Get the variable
0B0DF3 DA 7F 0E 0B 0441**  			JP      C,BADDIM		; Throw a "Bad Dim" error
0B0DF7 CA 89 0E 0B 0442**  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
0B0DFB CD AC 3C 0B 0443**  			CALL    CREATE			; Create a new entity
0B0DFF E5          0444**  			PUSH    HL			; HL: Address of the entity
0B0E00 DD E1       0445**  			POP     IX			; IX: Address of the entity
0B0E02 FD 7E 00    0446**  			LD      A,(IY)			; Fetch the next character from the tokenised string
0B0E05 FE 28       0447**  			CP      '('			; Check for opening brackets
0B0E07 7A          0448**  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
0B0E08 20 7F       0449**  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
0B0E0A             0450**  ;
0B0E0A             0451**  ; At this point we're reserving a variable array
0B0E0A             0452**  ;
0B0E0A E5          0453**  			PUSH    HL			; HL: Address of the entity
0B0E0B F5          0454**  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
0B0E0C 11 01 00 00 0455**  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
0B0E10 42          0456**  			LD      B,D			;  B: The number of dimensions in the array
0B0E11             0457**  ;
0B0E11 FD 23       0458**  DIM1:			INC     IY			; Skip to the next token
0B0E13 C5          0459**  			PUSH    BC			; Stack the dimension counter
0B0E14 D5          0460**  			PUSH    DE			; Stack the total size of array accumulator
0B0E15 DD E5       0461**  			PUSH    IX			; Stack the entity address
0B0E17 CD 08 04 0B 0462**  			CALL    EXPRI           	; Fetch the size of this dimension
0B0E1B CB 7C       0463**  			BIT     7,H			; If it is negative then
0B0E1D 20 60       0464**  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
0B0E1F D9          0465**  			EXX
0B0E20 23          0466**  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
0B0E21 DD E1       0467**  			POP     IX			; IX: The entity address
0B0E23 DD 23       0468**  			INC     IX
0B0E25 DD 75 00    0469**  			LD      (IX),L          	; Save the size of this dimension in the entity
0B0E28 DD 23       0470**  			INC     IX
0B0E2A DD 74 00    0471**  			LD      (IX),H
0B0E2D C1          0472**  			POP     BC
0B0E2E CD 70 19 0B 0473**  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
0B0E32 38 4F       0474**  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
0B0E34 EB          0475**  			EX      DE,HL           	; DE: The new total size of array accumulator
0B0E35 C1          0476**  			POP     BC
0B0E36 04          0477**  			INC     B               	;  B: The dimension counter; increment
0B0E37 FD 7E 00    0478**  			LD      A,(IY)			; Fetch the nex token
0B0E3A FE 2C       0479**  			CP      ','             	; Check for another dimension in the array
0B0E3C 28 D3       0480**  			JR      Z,DIM1			; And loop
0B0E3E             0481**  ;
0B0E3E CD 2D 0B 0B 0482**  			CALL    BRAKET          	; Check for closing bracket
0B0E42 F1          0483**  			POP     AF              	; Restore the type
0B0E43 DD 23       0484**  			INC     IX
0B0E45 DD E3       0485**  			EX      (SP),IX
0B0E47 DD 70 00    0486**  			LD      (IX),B          	; Number of dimensions
0B0E4A CD 63 19 0B 0487**  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
0B0E4E E1          0488**  			POP     HL			; Restore the entity address
0B0E4F 38 32       0489**  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
0B0E51             0490**  ;
0B0E51             0491**  ; We now allocate the memory for the array
0B0E51             0492**  ;
0B0E51 19          0493**  DIM3:			ADD     HL,DE
0B0E52 38 2F       0494**  			JR      C,NOROOM
0B0E54 E5          0495**  			PUSH    HL
0B0E55 24          0496**  			INC     H
0B0E56 28 2B       0497**  			JR      Z,NOROOM
0B0E58 ED 72       0498**  			SBC     HL,SP
0B0E5A 30 27       0499**  			JR      NC,NOROOM       	; Throw an "Out of Space" error
0B0E5C E1          0500**  			POP     HL
0B0E5D 22 1D 4E 0B 0501**  			LD      (FREE),HL
0B0E61 7A          0502**  DIM2:			LD      A,D
0B0E62 B3          0503**  			OR      E
0B0E63 28 06       0504**  			JR      Z,DIM5
0B0E65 2B          0505**  			DEC     HL
0B0E66 36 00       0506**  			LD      (HL),0         		; Initialise the array
0B0E68 1B          0507**  			DEC     DE
0B0E69 18 F6       0508**  			JR      DIM2
0B0E6B CD 6E 0B 0B 0509**  DIM5:			CALL    NXT
0B0E6F FE 2C       0510**  			CP      ','            		; Another variable?
0B0E71 C2 94 0C 0B 0511**  			JP      NZ,XEQ
0B0E75 FD 23       0512**  			INC     IY
0B0E77 CD 6E 0B 0B 0513**  			CALL    NXT
0B0E7B C3 EF 0D 0B 0514**  			JP      DIM_EX
0B0E7F             0515**  ;
0B0E7F             0516**  ; DIM errors
0B0E7F             0517**  ;
0B0E7F 3E 0A       0518**  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
0B0E81 18 02       0519**  			JR	ERROR1_EX
0B0E83 3E 0B       0520**  NOROOM:			LD      A,11            	; Throw a "DIM space" error
0B0E85 C3 5E 38 0B 0521**  ERROR1_EX:			JP      ERROR_
0B0E89             0522**  ;
0B0E89             0523**  ; At this point we're reserving a block of memory, i.e.
0B0E89             0524**  ; DIM var expr[,var expr...]
0B0E89             0525**  ;
0B0E89 B7          0526**  DIM4:			OR      A			;  A: The dimension variable type
0B0E8A 28 F3       0527**  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
0B0E8C FA 7F 0E 0B 0528**  			JP      M,BADDIM        	; or a string
0B0E90 47          0529**  			LD      B,A			; Temporarily store the dimension variable type in B
0B0E91 FD 7E FF    0530**  			LD      A,(IY-1)		; Get the last character but one
0B0E94 FE 29       0531**  			CP      ')'			; Check if it is a trailing bracket
0B0E96 28 E7       0532**  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
0B0E98             0533**  ;
0B0E98 21 00 00 00 0534**  			LD	HL,0			; Clear HL
0B0E9C 3A 1D 4E 0B 0535**  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
0B0EA0 6F          0536**  			LD	L,A
0B0EA1 3A 1E 4E 0B 0537**  			LD	A,(FREE+1)
0B0EA5 67          0538**  			LD	H,A
0B0EA6 78          0539**  			LD	A,B			; Restore the dimension variable type
0B0EA7 D9          0540**  			EXX
0B0EA8 21 00 00 00 0541**  			LD	HL,0			; Clear HL
0B0EAC 47          0542**  			LD	B,A			; Temporarily store the dimension variable type in B
0B0EAD 3A 1F 4E 0B 0543**  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
0B0EB1 6F          0544**  			LD	L,A
0B0EB2 78          0545**  			LD	A,B			; Restore the dimension variable type
0B0EB3 4C          0546**  			LD	C,H
0B0EB4 CD D4 16 0B 0547**  			CALL    STORE           	; Store the address
0B0EB8 CD 08 04 0B 0548**  			CALL    EXPRI			; Get the number of bytes to store
0B0EBC D9          0549**  			EXX
0B0EBD 23          0550**  			INC     HL			; Add one to it
0B0EBE EB          0551**  			EX      DE,HL
0B0EBF 2A 1D 4E 0B 0552**  			LD      HL,(FREE)
0B0EC3 18 8C       0553**  			JR      DIM3			; Continue with the DIM
0B0EC5             0554**  
0B0EC5             0555**  ; PRINT list...
0B0EC5             0556**  ; PRINT #channel,list...
0B0EC5             0557**  ;
0B0EC5 FE 23       0558**  PRINT_:			CP      '#'
0B0EC7 20 7C       0559**  			JR      NZ,PRINT0
0B0EC9 CD 90 19 0B 0560**  			CALL    CHNL            ;CHANNEL NO. = E
0B0ECD CD 6E 0B 0B 0561**  PRNTN1:			CALL    NXT
0B0ED1 FE 2C       0562**  			CP      ','
0B0ED3 C2 94 0C 0B 0563**  			JP      NZ,XEQ
0B0ED7 FD 23       0564**  			INC     IY
0B0ED9 D5          0565**  			PUSH    DE
0B0EDA CD C5 02 0B 0566**  			CALL    EXPR            ;ITEM TO PRINT
0B0EDE 08          0567**  			EX      AF,AF'
0B0EDF FA 05 0F 0B 0568**  			JP      M,PRNTN2        ;STRING
0B0EE3 D1          0569**  			POP     DE
0B0EE4 C5          0570**  			PUSH    BC
0B0EE5 D9          0571**  			EXX
0B0EE6 7D          0572**  			LD      A,L
0B0EE7 D9          0573**  			EXX
0B0EE8 CD 39 44 0B 0574**  			CALL    OSBPUT
0B0EEC D9          0575**  			EXX
0B0EED 7C          0576**  			LD      A,H
0B0EEE D9          0577**  			EXX
0B0EEF CD 39 44 0B 0578**  			CALL    OSBPUT
0B0EF3 7D          0579**  			LD      A,L
0B0EF4 CD 39 44 0B 0580**  			CALL    OSBPUT
0B0EF8 7C          0581**  			LD      A,H
0B0EF9 CD 39 44 0B 0582**  			CALL    OSBPUT
0B0EFD C1          0583**  			POP     BC
0B0EFE 79          0584**  			LD      A,C
0B0EFF CD 39 44 0B 0585**  			CALL    OSBPUT
0B0F03 18 C8       0586**  			JR      PRNTN1
0B0F05 4B          0587**  PRNTN2:			LD      C,E
0B0F06 D1          0588**  			POP     DE
0B0F07 21 00 4B 0B 0589**  			LD      HL,ACCS
0B0F0B 0C          0590**  			INC     C
0B0F0C 0D          0591**  PRNTN3:			DEC     C
0B0F0D 28 0A       0592**  			JR      Z,PRNTN4
0B0F0F 7E          0593**  			LD      A,(HL)
0B0F10 23          0594**  			INC     HL
0B0F11 C5          0595**  			PUSH    BC
0B0F12 CD 39 44 0B 0596**  			CALL    OSBPUT
0B0F16 C1          0597**  			POP     BC
0B0F17 18 F3       0598**  			JR      PRNTN3
0B0F19 3E 0D       0599**  PRNTN4:			LD      A,CR
0B0F1B CD 39 44 0B 0600**  			CALL    OSBPUT
0B0F1F 18 AC       0601**  			JR      PRNTN1
0B0F21             0602**  ;
0B0F21 06 02       0603**  PRINT6:			LD      B,2
0B0F23 18 27       0604**  			JR      PRINTC
0B0F25 01 00 01 00 0605**  PRINT8:			LD      BC,100H
0B0F29 18 21       0606**  			JR      PRINTC
0B0F2B 21 00 4D 0B 0607**  PRINT9:			LD      HL,STAVAR
0B0F2F AF          0608**  			XOR     A
0B0F30 BE          0609**  			CP      (HL)
0B0F31 28 12       0610**  			JR      Z,PRINT0
0B0F33 3A 3D 4E 0B 0611**  			LD      A,(COUNT)
0B0F37 B7          0612**  			OR      A
0B0F38 28 0B       0613**  			JR      Z,PRINT0
0B0F3A 96          0614**  PRINTA:			SUB     (HL)
0B0F3B 28 08       0615**  			JR      Z,PRINT0
0B0F3D 30 FB       0616**  			JR      NC,PRINTA
0B0F3F ED 44       0617**  			NEG
0B0F41 CD ED 18 0B 0618**  			CALL    FILL
0B0F45 3A 00 4D 0B 0619**  PRINT0:			LD      A,(STAVAR)
0B0F49 4F          0620**  			LD      C,A             ;PRINTS
0B0F4A 06 00       0621**  			LD      B,0             ;PRINTF
0B0F4C CD 78 18 0B 0622**  PRINTC:			CALL    TERMQ
0B0F50 28 3F       0623**  			JR      Z,PRINT4
0B0F52 CB 80       0624**  			RES     0,B
0B0F54 FD 23       0625**  			INC     IY
0B0F56 FE 7E       0626**  			CP      '~'
0B0F58 28 C7       0627**  			JR      Z,PRINT6
0B0F5A FE 3B       0628**  			CP      ';'
0B0F5C 28 C7       0629**  			JR      Z,PRINT8
0B0F5E FE 2C       0630**  			CP      ','
0B0F60 28 C9       0631**  			JR      Z,PRINT9
0B0F62 CD 9D 18 0B 0632**  			CALL    FORMAT          ;SPC, TAB, '
0B0F66 28 E4       0633**  			JR      Z,PRINTC
0B0F68 FD 2B       0634**  			DEC     IY
0B0F6A C5          0635**  			PUSH    BC
0B0F6B CD C5 02 0B 0636**  			CALL    EXPR            ;VARIABLE TYPE
0B0F6F 08          0637**  			EX      AF,AF'
0B0F70 FA 8A 0F 0B 0638**  			JP      M,PRINT3        ;STRING
0B0F74 D1          0639**  			POP     DE
0B0F75 D5          0640**  			PUSH    DE
0B0F76 CB 4A       0641**  			BIT     1,D
0B0F78 F5          0642**  			PUSH    AF
0B0F79 CC 64 0A 0B 0643**  			CALL    Z,STR           ;DECIMAL
0B0F7D F1          0644**  			POP     AF
0B0F7E C4 18 0A 0B 0645**  			CALL    NZ,HEXSTR       ;HEX
0B0F82 C1          0646**  			POP     BC
0B0F83 C5          0647**  			PUSH    BC
0B0F84 79          0648**  			LD      A,C
0B0F85 93          0649**  			SUB     E
0B0F86 D4 ED 18 0B 0650**  			CALL    NC,FILL         ;RIGHT JUSTIFY
0B0F8A C1          0651**  PRINT3:			POP     BC
0B0F8B CD FC 18 0B 0652**  			CALL    PTEXT           ;PRINT
0B0F8F 18 BB       0653**  			JR      PRINTC
0B0F91 CB 40       0654**  PRINT4:			BIT     0,B
0B0F93 CC 45 3A 0B 0655**  			CALL    Z,CRLF
0B0F97 C3 94 0C 0B 0656**  			JP      XEQ
0B0F9B             0657**  
0B0F9B             0658**  ; ON ERROR statement [:statement...]
0B0F9B             0659**  ; ON ERROR OFF
0B0F9B             0660**  ;
0B0F9B FD 23       0661**  ONERR:			INC     IY              ;SKIP "ERROR"
0B0F9D 21 00 00 00 0662**  			LD      HL,0
0B0FA1 22 2C 4E 0B 0663**  			LD      (ERRTRP),HL
0B0FA5 CD 6E 0B 0B 0664**  			CALL    NXT
0B0FA9 FE 87       0665**  			CP      OFF_
0B0FAB FD 23       0666**  			INC     IY
0B0FAD CA 94 0C 0B 0667**  			JP      Z,XEQ
0B0FB1 FD 2B       0668**  			DEC     IY
0B0FB3 FD 22 2C 4E 0669**  			LD      (ERRTRP),IY
       0B          
0B0FB8 C3 29 0D 0B 0670**  			JP      REM_EX
0B0FBC             0671**  
0B0FBC             0672**  ; ON expr GOTO line[,line...] [ELSE statement]
0B0FBC             0673**  ; ON expr GOTO line[,line...] [ELSE line]
0B0FBC             0674**  ; ON expr GOSUB line[,line...] [ELSE statement]
0B0FBC             0675**  ; ON expr GOSUB line[,line...] [ELSE line]
0B0FBC             0676**  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
0B0FBC             0677**  ;
0B0FBC FE 85       0678**  ON_EX_:			CP      TERROR_EX
0B0FBE 28 DB       0679**  			JR      Z,ONERR         ;"ON ERROR"
0B0FC0 CD 08 04 0B 0680**  			CALL    EXPRI
0B0FC4 FD 7E 00    0681**  			LD      A,(IY)
0B0FC7 FD 23       0682**  			INC     IY
0B0FC9 1E 2C       0683**  			LD      E,','           ;SEPARATOR
0B0FCB FE E5       0684**  			CP      TGOTO
0B0FCD 28 0B       0685**  			JR      Z,ON1
0B0FCF FE E4       0686**  			CP      TGOSUB
0B0FD1 28 07       0687**  			JR      Z,ON1
0B0FD3 1E F2       0688**  			LD      E,TPROC
0B0FD5 BB          0689**  			CP      E
0B0FD6 3E 27       0690**  			LD      A,39
0B0FD8 20 45       0691**  			JR      NZ,ERROR2_EX       ;"ON syntax"
0B0FDA 57          0692**  ON1:			LD      D,A
0B0FDB D9          0693**  			EXX
0B0FDC E5          0694**  			PUSH    HL
0B0FDD D9          0695**  			EXX
0B0FDE C1          0696**  			POP     BC              ;ON INDEX
0B0FDF 78          0697**  			LD      A,B
0B0FE0 B4          0698**  			OR      H
0B0FE1 B5          0699**  			OR      L
0B0FE2 20 2A       0700**  			JR      NZ,ON4          ;OUT OF RANGE
0B0FE4 B1          0701**  			OR      C
0B0FE5 28 27       0702**  			JR      Z,ON4
0B0FE7 0D          0703**  			DEC     C
0B0FE8 28 0E       0704**  			JR      Z,ON3           ;INDEX=1
0B0FEA CD 78 18 0B 0705**  ON2:			CALL    TERMQ
0B0FEE 28 1E       0706**  			JR      Z,ON4           ;OUT OF RANGE
0B0FF0 FD 23       0707**  			INC     IY              ;SKIP DELIMITER
0B0FF2 BB          0708**  			CP      E
0B0FF3 20 F5       0709**  			JR      NZ,ON2
0B0FF5 0D          0710**  			DEC     C
0B0FF6 20 F2       0711**  			JR      NZ,ON2
0B0FF8 7B          0712**  ON3:			LD      A,E
0B0FF9 FE F2       0713**  			CP      TPROC
0B0FFB 28 26       0714**  			JR      Z,ONPROC
0B0FFD D5          0715**  			PUSH    DE
0B0FFE CD 23 04 0B 0716**  			CALL    ITEMI           ;LINE NUMBER
0B1002 D1          0717**  			POP     DE
0B1003 7A          0718**  			LD      A,D
0B1004 FE E5       0719**  			CP      TGOTO
0B1006 28 2D       0720**  			JR      Z,GOTO2
0B1008 CD 85 18 0B 0721**  			CALL    SPAN            ;SKIP REST OF LIST
0B100C 18 3B       0722**  			JR      GOSUB1
0B100E             0723**  ;
0B100E FD 7E 00    0724**  ON4:			LD      A,(IY)
0B1011 FD 23       0725**  			INC     IY
0B1013 FE 8B       0726**  			CP      ELSE_EX_
0B1015 CA 49 14 0B 0727**  			JP      Z,IF1           ;ELSE CLAUSE
0B1019 FE 0D       0728**  			CP      CR
0B101B 20 F1       0729**  			JR      NZ,ON4
0B101D 3E 28       0730**  			LD      A,40
0B101F C3 5E 38 0B 0731**  ERROR2_EX:			JP      ERROR_           ;"ON range"
0B1023             0732**  ;
0B1023 3E EE       0733**  ONPROC:			LD      A,TON
0B1025 C3 82 11 0B 0734**  			JP      PROC_EX
0B1029             0735**  
0B1029             0736**  ; GOTO line
0B1029             0737**  ;
0B1029 CD 23 04 0B 0738**  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
0B102D CD 78 18 0B 0739**  GOTO1:			CALL    TERMQ			; Check for terminator
0B1031 C2 95 0D 0B 0740**  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
0B1035 D9          0741**  GOTO2:			EXX
0B1036 CD 8D 3A 0B 0742**  			CALL    FINDL			; HL: Line number - Find the line
0B103A E5          0743**  			PUSH    HL			; HL: Address of the line
0B103B FD E1       0744**  			POP     IY			; IY = HL
0B103D CA 90 0C 0B 0745**  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
0B1041 3E 29       0746**  			LD      A,41			; Otherwise throw a "No such line" error
0B1043 18 DA       0747**  			JR      ERROR2_EX
0B1045             0748**  
0B1045             0749**  ; GOSUB line
0B1045             0750**  ; This pushes the following data onto the execution stack
0B1045             0751**  ; - 3 bytes: Current execution address
0B1045             0752**  ; - 3 bytes: Marker (the address of label GOSCHK)
0B1045             0753**  ;
0B1045 CD 23 04 0B 0754**  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
0B1049 FD E5       0755**  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
0B104B CD 4D 17 0B 0756**  			CALL    CHECK           	; Check there is enough room
0B104F CD 2D 10 0B 0757**  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
0B1053             0758**  GOSCHK:			EQU     $
0B1053             0759**  
0B1053             0760**  ; RETURN
0B1053             0761**  ; This pops the following data off the execution stack as pushed by GOSUB
0B1053             0762**  ; - 3 bytes: Marker (should be the address of label GOSCHK)
0B1053             0763**  ; - 3 bytes: The return execution address
0B1053             0764**  ;
0B1053 D1          0765**  RETURN:			POP     DE			; Pop the marker off the execution stack
0B1054 21 53 10 0B 0766**  			LD      HL,GOSCHK		; Compare with GOSCHK
0B1058 B7          0767**  			OR      A
0B1059 ED 52       0768**  			SBC     HL,DE
0B105B FD E1       0769**  			POP     IY			; Pop the return address off the execution stack
0B105D CA 94 0C 0B 0770**  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
0B1061 3E 26       0771**  			LD      A,38			; Otherwise throw a "No GOSUB" error
0B1063 18 BA       0772**  			JR      ERROR2_EX
0B1065             0773**  
0B1065             0774**  ; REPEAT
0B1065             0775**  ; This pushes the following data onto the execution stack
0B1065             0776**  ; - 3 bytes: Current execution address
0B1065             0777**  ; - 3 bytes: Marker (the address of label REPCHK)
0B1065             0778**  ;
0B1065 FD E5       0779**  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
0B1067 CD 4D 17 0B 0780**  			CALL    CHECK			; Check if there is enough room
0B106B CD 94 0C 0B 0781**  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
0B106F             0782**  REPCHK:			EQU     $
0B106F             0783**  
0B106F             0784**  ; UNTIL expr
0B106F             0785**  ; This pops the following data off the execution stack
0B106F             0786**  ; - 3 bytes: Marker (should be the address of label REPCHK)
0B106F             0787**  ; - 3 bytes: The address of the REPEAT instruction
0B106F             0788**  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
0B106F             0789**  ;
0B106F C1          0790**  UNTIL_EX:			POP     BC			; Fetch the marker
0B1070 C5          0791**  			PUSH    BC			; And push it back onto the execution stack
0B1071 21 6F 10 0B 0792**  			LD      HL,REPCHK		; Compare with REPCHK
0B1075 B7          0793**  			OR      A
0B1076 ED 42       0794**  			SBC     HL,BC
0B1078 3E 2B       0795**  			LD      A,43
0B107A 20 A3       0796**  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
0B107C CD 08 04 0B 0797**  			CALL    EXPRI			; Fetch the expression
0B1080 CD DD 09 0B 0798**  			CALL    TEST			; Test if the expression evaluates to zero
0B1084 C1          0799**  			POP     BC			; Pop the marker
0B1085 D1          0800**  			POP     DE			; Pop the address of the REPEAT instruction
0B1086 20 05       0801**  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
0B1088 D5          0802**  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
0B1089 C5          0803**  			PUSH    BC			; Push the marker back on the stack
0B108A D5          0804**  			PUSH    DE			; IY = DE
0B108B FD E1       0805**  			POP     IY			; This sets the execution address back to the REPEAT instruction
0B108D C3 94 0C 0B 0806**  XEQ2:			JP      XEQ			; Continue execution
0B1091             0807**  
0B1091             0808**  ; FOR var = expr TO expr [STEP expr]
0B1091             0809**  ; This pushes the following data onto the execution stack
0B1091             0810**  ; - 3 bytes: The limit value
0B1091             0811**  ; - 3 bytes: The step value
0B1091             0812**  ; - 3 bytes: The current execution address
0B1091             0813**  ; - 3 bytes: The address of the loop variable
0B1091             0814**  ; - 3 bytes: Marker (the address of FORCHK)
0B1091             0815**  ;
0B1091 3E 22       0816**  FORVAR:			LD      A,34
0B1093 18 8A       0817**  			JR      ERROR2_EX          	; Throw "FOR variable" error
0B1095             0818**  ;
0B1095 CD BC 16 0B 0819**  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
0B1099 20 F6       0820**  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
0B109B F5          0821**  			PUSH    AF              	; Save the variable type
0B109C FD 7E 00    0822**  			LD      A,(IY)			; Check the next token
0B109F FE B8       0823**  			CP      TO_EX			; Compare with the token value for "TO"
0B10A1 3E 24       0824**  			LD      A,36			; Set the error code to 36 ("No TO")
0B10A3 C2 1F 10 0B 0825**  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
0B10A7 FD 23       0826**  			INC     IY			; Skip to the next token
0B10A9             0827**  ;
0B10A9 DD E5       0828**  			PUSH    IX
0B10AB CD 00 04 0B 0829**  			CALL    EXPRN           	; Fetch the LIMIT expression value
0B10AF DD E1       0830**  			POP     IX
0B10B1 F1          0831**  			POP     AF
0B10B2 47          0832**  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
0B10B3 C5          0833**  			PUSH    BC              	; Stack the LIMIT value
0B10B4 E5          0834**  			PUSH    HL
0B10B5 21 00 00 00 0835**  			LD      HL,0
0B10B9 4C          0836**  			LD      C,H
0B10BA D9          0837**  			EXX
0B10BB E5          0838**  			PUSH    HL
0B10BC             0839**  ;
0B10BC 21 01 00 00 0840**  			LD      HL,1            	; The preset STEP value is 1
0B10C0 D9          0841**  			EXX
0B10C1 FD 7E 00    0842**  			LD      A,(IY)			; Fetch the next token
0B10C4 FE 88       0843**  			CP      STEP			; Compare with the token value for "STEP"
0B10C6 20 0A       0844**  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
0B10C8             0845**  ;
0B10C8 FD 23       0846**  			INC     IY			; Skip past the STEP token
0B10CA DD E5       0847**  			PUSH    IX
0B10CC CD 00 04 0B 0848**  			CALL    EXPRN          		; Fetch the STEP expression value
0B10D0 DD E1       0849**  			POP     IX
0B10D2             0850**  ;
0B10D2 C5          0851**  FOR1:			PUSH    BC			; Stack the STEP value
0B10D3 E5          0852**  			PUSH    HL
0B10D4 D9          0853**  			EXX
0B10D5 E5          0854**  			PUSH    HL
0B10D6 D9          0855**  			EXX
0B10D7             0856**  ;
0B10D7 FD E5       0857**  			PUSH    IY              	; Stack the current execution address
0B10D9 DD E5       0858**  			PUSH    IX              	; Stack the loop variable
0B10DB CD 4D 17 0B 0859**  			CALL    CHECK
0B10DF CD 94 0C 0B 0860**  			CALL    XEQ
0B10E3             0861**  FORCHK:			EQU     $
0B10E3             0862**  
0B10E3             0863**  ; NEXT [var[,var...]]
0B10E3             0864**  ; This pops the following data off the execution stack
0B10E3             0865**  ; - 3 bytes: Marker (the address of FORCHK)
0B10E3             0866**  ; - 3 bytes: The address of the loop variable
0B10E3             0867**  ; - 3 bytes: The current execution address
0B10E3             0868**  ; - 3 bytes: The step value
0B10E3             0869**  ; - 3 bytes: The limit value
0B10E3             0870**  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
0B10E3             0871**  ;
0B10E3 C1          0872**  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
0B10E4 21 E3 10 0B 0873**  			LD      HL,FORCHK		; Compare with FORCHK
0B10E8 B7          0874**  			OR      A
0B10E9 ED 42       0875**  			SBC     HL,BC
0B10EB 3E 20       0876**  			LD      A,32
0B10ED C2 79 11 0B 0877**  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
0B10F1 CD 78 18 0B 0878**  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
0B10F5 E1          0879**  			POP     HL			; Pop the address of the loop variable off the execution stack
0B10F6 E5          0880**  			PUSH    HL			; Push it back onto the execution stack
0B10F7 C5          0881**  			PUSH    BC			; Push the marker back onto the execution stack
0B10F8 E5          0882**  			PUSH    HL			; HL: Address of the loop variable off the stack
0B10F9 C4 38 3B 0B 0883**  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
0B10FD D1          0884**  			POP     DE			; DE: Address of the loop variable off the stack
0B10FE EB          0885**  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
0B10FF B7          0886**  			OR      A
0B1100 ED 52       0887**  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
0B1102 20 61       0888**  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
0B1104 D5          0889**  			PUSH    DE
0B1105 DD 21 0C 00 0890**  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
0B110A DD 39       0891**  			ADD     IX,SP
0B110C CD DF 2A 0B 0892**  			CALL    DLOAD5_SPL      	; Load the STEP value
0B1110 DD 7E 10    0893**  			LD      A,(IX+16)       	; Get the STEP type
0B1113 DD E1       0894**  			POP     IX
0B1115 CD 14 05 0B 0895**  			CALL    LOADN           	; Load the LOOP variable
0B1119 CB 7A       0896**  			BIT     7,D             	; Check the sign
0B111B F5          0897**  			PUSH    AF
0B111C 3E 0B       0898**  			LD      A,'+' & 0FH
0B111E CD 68 21 0B 0899**  			CALL    FPP             	; Add the STEP
0B1122 38 55       0900**  			JR      C,ERROR3_EX
0B1124 F1          0901**  			POP     AF              	; Restore TYPE
0B1125 F5          0902**  			PUSH    AF
0B1126 CD D4 16 0B 0903**  			CALL    STORE           	; Update the variable
0B112A DD 21 15 00 0904**  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
0B112F DD 39       0905**  			ADD     IX,SP
0B1131 CD DF 2A 0B 0906**  			CALL    DLOAD5_SPL      	; Load the LIMIT value
0B1135 F1          0907**  			POP     AF
0B1136 CC D5 09 0B 0908**  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
0B113A             0909**  			; LD      A,0+('<'-4) & 0FH
0B113A 3E 08       0910**  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
0B113C CD 68 21 0B 0911**  			CALL    FPP             	; Test against the limit
0B1140 38 37       0912**  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
0B1142 24          0913**  			INC     H
0B1143 20 14       0914**  			JR      NZ,LOOP_        	; Keep looping
0B1145 21 1B 00 00 0915**  			LD      HL,27			; Adjust the stack
0B1149 39          0916**  			ADD     HL,SP
0B114A F9          0917**  			LD      SP,HL
0B114B CD 6E 0B 0B 0918**  			CALL    NXT
0B114F FE 2C       0919**  			CP      ','			; Check for multiple variables
0B1151 C2 94 0C 0B 0920**  			JP      NZ,XEQ			; No, so we are done at ths point
0B1155 FD 23       0921**  			INC     IY			; Increment to the next variable
0B1157 18 8A       0922**  			JR      NEXT_EX			; And continue
0B1159             0923**  ;
0B1159 C1          0924**  LOOP_:			POP     BC
0B115A D1          0925**  			POP     DE
0B115B FD E1       0926**  			POP     IY
0B115D FD E5       0927**  			PUSH    IY
0B115F D5          0928**  			PUSH    DE
0B1160 C5          0929**  			PUSH    BC
0B1161 C3 94 0C 0B 0930**  			JP      XEQ
0B1165             0931**  ;
0B1165 21 1B 00 00 0932**  NEXT1:			LD      HL,27			; TODO: What does this do?
0B1169 39          0933**  			ADD     HL,SP
0B116A F9          0934**  			LD      SP,HL			; Adjust the stack
0B116B C1          0935**  			POP     BC
0B116C 21 E3 10 0B 0936**  			LD      HL,FORCHK
0B1170 ED 42       0937**  			SBC     HL,BC
0B1172 E1          0938**  			POP     HL              	; Variable pointer
0B1173 E5          0939**  			PUSH    HL
0B1174 C5          0940**  			PUSH    BC
0B1175 28 89       0941**  			JR      Z,NEXT0
0B1177             0942**  ;
0B1177 3E 21       0943**  			LD      A,33
0B1179 C3 5E 38 0B 0944**  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
0B117D             0945**  
0B117D             0946**  ; FNname
0B117D             0947**  ; N.B. ENTERED WITH A <> TON
0B117D             0948**  ;
0B117D F5          0949**  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0B117E CD 87 11 0B 0950**  			CALL    PROC1
0B1182             0951**  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0B1182             0952**  
0B1182             0953**  ; PROCname
0B1182             0954**  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
0B1182             0955**  ; This pushes the following data onto the execution stack
0B1182             0956**  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
0B1182             0957**  ; - 3 bytes: Marker (the address of PROCHK)
0B1182             0958**  ;
0B1182 F5          0959**  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0B1183 CD 87 11 0B 0960**  			CALL    PROC1			; and is also space reserved on the stack for the return address
0B1187             0961**  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0B1187             0962**  ;
0B1187 CD 4D 17 0B 0963**  PROC1:			CALL    CHECK			; Check there is space for this
0B118B FD 2B       0964**  			DEC     IY			; Decrement IY to the PROC token
0B118D FD E5       0965**  			PUSH    IY			; Stack the pointer
0B118F CD F9 3B 0B 0966**  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1193 C1          0967**  			POP     BC			; BC = IY
0B1194 28 41       0968**  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0B1196 3E 1E       0969**  			LD      A,30
0B1198 38 DF       0970**  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0B119A             0971**  ;
0B119A             0972**  ; At this point the PROC/FN has not yet been registered in the dynamic area
0B119A             0973**  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0B119A             0974**  ;
0B119A C5          0975**  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0B119B 2A 14 4E 0B 0976**  			LD      HL,(PAGE_)		; HL: Start of program memory
0B119F             0977**  ;
0B119F 3E DD       0978**  PROC2:			LD      A,DEF_			;  A: The token to search for
0B11A1 CD 4C 19 0B 0979**  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0B11A5 38 26       0980**  			JR      C,PROC3			; Not found, so jump to PROC3
0B11A7 E5          0981**  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0B11A8 FD E1       0982**  			POP     IY			; IY = HL
0B11AA FD 23       0983**  			INC     IY              	; Skip the DEF token
0B11AC CD 6E 0B 0B 0984**  			CALL    NXT			; And any whitespace
0B11B0 CD F9 3B 0B 0985**  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B11B4 FD E5       0986**  			PUSH    IY
0B11B6 D1          0987**  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0B11B7 38 09       0988**  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0B11B9 C4 AC 3C 0B 0989**  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0B11BD FD E5       0990**  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0B11BF D1          0991**  			POP     DE			; DE = IY
0B11C0 ED 1F       0992**  			LD	(HL),DE			; Save address
0B11C2             0993**  ;
0B11C2 EB          0994**  PROC6:			EX      DE,HL			; HL: Address of the procedure
0B11C3 3E 0D       0995**  			LD      A,CR			; The character to search for
0B11C5 01 00 01 00 0996**  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0B11C9 ED B1       0997**  			CPIR                    	; Skip to next line
0B11CB 18 D2       0998**  			JR      PROC2			; Rinse, lather and repeat
0B11CD             0999**  ;
0B11CD             1000**  ; At this point a DEF has not been found for the PROC/FN
0B11CD             1001**  ;
0B11CD FD E1       1002**  PROC3:			POP     IY              	; Restore the execution address
0B11CF CD F9 3B 0B 1003**  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B11D3 3E 1D       1004**  			LD      A,29
0B11D5 20 A2       1005**  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0B11D7             1006**  ;
0B11D7             1007**  ; At this point we have a PROC/FN entry in the dynamic area
0B11D7             1008**  ;
0B11D7 ED 17       1009**  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0B11D9 21 03 00 00 1010**  			LD	HL,3
0B11DD 39          1011**  			ADD     HL,SP
0B11DE CD 6E 0B 0B 1012**  			CALL    NXT             	; Allow space before "("
0B11E2 D5          1013**  			PUSH    DE              	; Exchange DE and IY
0B11E3 FD E3       1014**  			EX      (SP),IY
0B11E5 FE 28       1015**  			CP      '('             	; Arguments?
0B11E7 D1          1016**  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0B11E8 20 20       1017**  			JR      NZ,PROC5
0B11EA CD 6E 0B 0B 1018**  			CALL    NXT             	; Allow space before "("
0B11EE FE 28       1019**  			CP      '('
0B11F0 C2 95 0D 0B 1020**  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0B11F4 FD E5       1021**  			PUSH    IY
0B11F6 C1          1022**  			POP     BC              	; Save IY in BC
0B11F7 D9          1023**  			EXX
0B11F8 CD F8 17 0B 1024**  			CALL    SAVLOC          	; Save local parameters
0B11FC CD 2D 0B 0B 1025**  			CALL    BRAKET          	; Closing bracket
0B1200 D9          1026**  			EXX
0B1201 C5          1027**  			PUSH    BC
0B1202 FD E1       1028**  			POP     IY              	; Restore IY
0B1204 E5          1029**  			PUSH    HL
0B1205 CD 74 17 0B 1030**  			CALL    ARGUE           	; Transfer arguments
0B1209 E1          1031**  			POP     HL
0B120A             1032**  ;
0B120A 23          1033**  PROC5:			INC	HL			; Increment to the ON PROC flag address
0B120B 7E          1034**  			LD	A, (HL)			; And fetch the value
0B120C 2B          1035**  			DEC 	HL
0B120D ED 1F       1036**  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
0B120F FE EE       1037**  			CP	TON			; Was it "ON PROC"?
0B1211 C2 94 0C 0B 1038**  			JP	NZ, XEQ			; No, so back to XEQ
0B1215 D5          1039**  			PUSH    DE			; Exchange DE and IY
0B1216 FD E3       1040**  			EX      (SP),IY
0B1218 CD 85 18 0B 1041**  			CALL    SPAN            	; Skip rest of ON list
0B121C FD E3       1042**  			EX      (SP),IY			; Exchange DE and IY
0B121E D1          1043**  			POP     DE
0B121F ED 1F       1044**  			LD	(HL), DE		; Save the return address
0B1221 C3 94 0C 0B 1045**  			JP      XEQ
0B1225             1046**  
0B1225             1047**  ; LOCAL var[,var...]
0B1225             1048**  ;
0B1225 C1          1049**  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
0B1226 C5          1050**  			PUSH    BC
0B1227 21 82 11 0B 1051**  			LD      HL,FNCHK		; Check if we are in a FN
0B122B B7          1052**  			OR      A
0B122C ED 42       1053**  			SBC     HL,BC
0B122E 28 16       1054**  			JR      Z,LOCAL1		; Yes, so all good, we can use local
0B1230 21 87 11 0B 1055**  			LD      HL,PROCHK		; Now check if we are in a PROC
0B1234 B7          1056**  			OR      A
0B1235 ED 42       1057**  			SBC     HL,BC
0B1237 28 0D       1058**  			JR      Z,LOCAL1		; Again, all good, we can use local
0B1239 21 56 18 0B 1059**  			LD      HL,LOCCHK		; Finally check for the local parameters marker
0B123D B7          1060**  			OR      A
0B123E ED 42       1061**  			SBC     HL,BC			; If it is not present, then
0B1240 3E 0C       1062**  			LD      A,12
0B1242 C2 5E 38 0B 1063**  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
0B1246             1064**  ;
0B1246             1065**  ; At this point we are adding a local variable into a PROC or FN
0B1246             1066**  ;
0B1246 FD E5       1067**  LOCAL1:			PUSH    IY			; IY: BASIC pointer
0B1248 C1          1068**  			POP     BC			; BC: Copy of the BASIC pointer
0B1249 D9          1069**  			EXX
0B124A FD 2B       1070**  			DEC     IY
0B124C CD F8 17 0B 1071**  			CALL    SAVLOC
0B1250 D9          1072**  			EXX
0B1251 C5          1073**  			PUSH    BC
0B1252 FD E1       1074**  			POP     IY
0B1254             1075**  ;
0B1254 CD 38 3B 0B 1076**  LOCAL2:			CALL    GETVAR			; Get the variable location
0B1258 C2 95 0D 0B 1077**  			JP      NZ,SYNTAX
0B125C B7          1078**  			OR      A               	; Check the variable type (80h = string)
0B125D 08          1079**  			EX      AF,AF'
0B125E CD 91 0A 0B 1080**  			CALL    ZERO			; Zero the variable anyway
0B1262 08          1081**  			EX      AF,AF'
0B1263 F5          1082**  			PUSH    AF
0B1264 F4 D4 16 0B 1083**  			CALL    P,STORE         	; Call STORE if it is not a string
0B1268 F1          1084**  			POP     AF
0B1269 59          1085**  			LD      E,C
0B126A FC 02 17 0B 1086**  			CALL    M,STORES		; Call STORES if it is a string
0B126E CD 6E 0B 0B 1087**  			CALL    NXT			; Skip to the next character in the expression
0B1272 FE 2C       1088**  			CP      ','			; Is it a comma?
0B1274 C2 94 0C 0B 1089**  			JP      NZ,XEQ			; No, so we're done, carry on executing
0B1278 FD 23       1090**  			INC     IY			; Yes, so skip the comma
0B127A CD 6E 0B 0B 1091**  			CALL    NXT			; And any whitespace
0B127E 18 D4       1092**  			JR      LOCAL2			; Then loop back and handle any further local variables
0B1280             1093**  
0B1280             1094**  ; ENDPROC
0B1280             1095**  ;
0B1280 C1          1096**  ENDPRO:			POP     BC			; Pop the check value off the stack
0B1281 21 56 18 0B 1097**  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
0B1285 B7          1098**  			OR      A
0B1286 ED 42       1099**  			SBC     HL,BC
0B1288 28 13       1100**  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
0B128A             1101**  ;
0B128A 21 87 11 0B 1102**  			LD      HL,PROCHK       	; Check if it is the PROC marker
0B128E B7          1103**  			OR      A
0B128F ED 42       1104**  			SBC     HL,BC
0B1291 FD E1       1105**  			POP     IY
0B1293 CA 94 0C 0B 1106**  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0B1297 3E 0D       1107**  			LD      A,13			; Otherwise throw the "No PROC" error
0B1299 C3 5E 38 0B 1108**  			JP      ERROR_
0B129D             1109**  ;
0B129D DD E1       1110**  UNSTK:			POP     IX			; Unstack a single local variable
0B129F C1          1111**  			POP     BC
0B12A0 78          1112**  			LD      A,B
0B12A1 B7          1113**  			OR      A
0B12A2 FA B0 12 0B 1114**  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0B12A6 E1          1115**  			POP     HL			; Unstack a normal variable
0B12A7 D9          1116**  			EXX
0B12A8 E1          1117**  			POP     HL
0B12A9 D9          1118**  			EXX
0B12AA CD D4 16 0B 1119**  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0B12AE 18 D0       1120**  			JR      ENDPRO			; And loop back to ENDPRO
0B12B0             1121**  ;
0B12B0 21 00 00 00 1122**  UNSTK1:			LD      HL,0			; Unstack a string
0B12B4 39          1123**  			ADD     HL,SP
0B12B5 59          1124**  			LD      E,C
0B12B6 CD 02 17 0B 1125**  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0B12BA F9          1126**  			LD      SP,HL
0B12BB 18 C3       1127**  			JR      ENDPRO
0B12BD             1128**  
0B12BD             1129**  ; INPUT #channel,var,var...
0B12BD             1130**  ;
0B12BD CD 90 19 0B 1131**  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0B12C1 CD 6E 0B 0B 1132**  INPN1:			CALL    NXT
0B12C5 FE 2C       1133**  			CP      ','
0B12C7 C2 94 0C 0B 1134**  			JP      NZ,XEQ
0B12CB FD 23       1135**  			INC     IY
0B12CD CD 6E 0B 0B 1136**  			CALL    NXT
0B12D1 D5          1137**  			PUSH    DE
0B12D2 CD 8C 0D 0B 1138**  			CALL    VAR_
0B12D6 D1          1139**  			POP     DE
0B12D7 F5          1140**  			PUSH    AF              ;SAVE TYPE
0B12D8 E5          1141**  			PUSH    HL              ;VARPTR
0B12D9 B7          1142**  			OR      A
0B12DA FA 06 13 0B 1143**  			JP      M,INPN2         ;STRING
0B12DE CD 31 44 0B 1144**  			CALL    OSBGET
0B12E2 D9          1145**  			EXX
0B12E3 6F          1146**  			LD      L,A
0B12E4 D9          1147**  			EXX
0B12E5 CD 31 44 0B 1148**  			CALL    OSBGET
0B12E9 D9          1149**  			EXX
0B12EA 67          1150**  			LD      H,A
0B12EB D9          1151**  			EXX
0B12EC CD 31 44 0B 1152**  			CALL    OSBGET
0B12F0 6F          1153**  			LD      L,A
0B12F1 CD 31 44 0B 1154**  			CALL    OSBGET
0B12F5 67          1155**  			LD      H,A
0B12F6 CD 31 44 0B 1156**  			CALL    OSBGET
0B12FA 4F          1157**  			LD      C,A
0B12FB DD E1       1158**  			POP     IX
0B12FD F1          1159**  			POP     AF              ;RESTORE TYPE
0B12FE D5          1160**  			PUSH    DE              ;SAVE CHANNEL
0B12FF CD D4 16 0B 1161**  			CALL    STORE
0B1303 D1          1162**  			POP     DE
0B1304 18 BB       1163**  			JR      INPN1
0B1306 21 00 4B 0B 1164**  INPN2:			LD      HL,ACCS
0B130A CD 31 44 0B 1165**  INPN3:			CALL    OSBGET
0B130E FE 0D       1166**  			CP      CR
0B1310 28 04       1167**  			JR      Z,INPN4
0B1312 77          1168**  			LD      (HL),A
0B1313 2C          1169**  			INC     L
0B1314 20 F4       1170**  			JR      NZ,INPN3
0B1316 DD E1       1171**  INPN4:			POP     IX
0B1318 F1          1172**  			POP     AF
0B1319 D5          1173**  			PUSH    DE
0B131A EB          1174**  			EX      DE,HL
0B131B CD FE 16 0B 1175**  			CALL    STACCS
0B131F D1          1176**  			POP     DE
0B1320 18 9F       1177**  			JR      INPN1
0B1322             1178**  
0B1322             1179**  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
0B1322             1180**  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
0B1322             1181**  ;
0B1322 FE 23       1182**  INPUT:			CP      '#'
0B1324 28 97       1183**  			JR      Z,INPUTN
0B1326 0E 00       1184**  			LD      C,0             ;FLAG PROMPT
0B1328 FE 86       1185**  			CP      LINE_EX_
0B132A 20 04       1186**  			JR      NZ,INPUT0
0B132C FD 23       1187**  			INC     IY              ;SKIP "LINE"
0B132E 0E 80       1188**  			LD      C,80H
0B1330 21 00 4C 0B 1189**  INPUT0:			LD      HL,BUFFER
0B1334 36 0D       1190**  			LD      (HL),CR         ;INITIALISE EMPTY
0B1336 CD 78 18 0B 1191**  INPUT1:			CALL    TERMQ
0B133A CA 94 0C 0B 1192**  			JP      Z,XEQ           ;DONE
0B133E FD 23       1193**  			INC     IY
0B1340 FE 2C       1194**  			CP      ','
0B1342 28 5C       1195**  			JR      Z,INPUT3        ;SKIP COMMA
0B1344 FE 3B       1196**  			CP      ';'
0B1346 28 58       1197**  			JR      Z,INPUT3
0B1348 E5          1198**  			PUSH    HL              ;SAVE BUFFER POINTER
0B1349 FE 22       1199**  			CP      34		;ASCII ""
0B134B 20 0C       1200**  			JR      NZ,INPUT6
0B134D C5          1201**  			PUSH    BC
0B134E CD 65 05 0B 1202**  			CALL    CONS
0B1352 C1          1203**  			POP     BC
0B1353 CD FC 18 0B 1204**  			CALL    PTEXT           ;PRINT PROMPT
0B1357 18 06       1205**  			JR      INPUT9
0B1359 CD 9D 18 0B 1206**  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
0B135D 20 05       1207**  			JR      NZ,INPUT2
0B135F E1          1208**  INPUT9:			POP     HL
0B1360 CB C1       1209**  			SET     0,C             ;FLAG NO PROMPT
0B1362 18 CC       1210**  			JR      INPUT0
0B1364 FD 2B       1211**  INPUT2:			DEC     IY
0B1366 C5          1212**  			PUSH    BC
0B1367 CD 8C 0D 0B 1213**  			CALL    VAR_
0B136B C1          1214**  			POP     BC
0B136C E1          1215**  			POP     HL
0B136D F5          1216**  			PUSH    AF              ;SAVE TYPE
0B136E 7E          1217**  			LD      A,(HL)
0B136F 23          1218**  			INC     HL
0B1370 FE 0D       1219**  			CP      CR              ;BUFFER EMPTY?
0B1372 CC A4 13 0B 1220**  			CALL    Z,REFILL
0B1376 CB 79       1221**  			BIT     7,C
0B1378 F5          1222**  			PUSH    AF
0B1379 C4 1E 19 0B 1223**  			CALL    NZ,LINES
0B137D F1          1224**  			POP     AF
0B137E CC 0B 19 0B 1225**  			CALL    Z,FETCHS
0B1382 F1          1226**  			POP     AF              ;RESTORE TYPE
0B1383 C5          1227**  			PUSH    BC
0B1384 E5          1228**  			PUSH    HL
0B1385 B7          1229**  			OR      A
0B1386 FA 9A 13 0B 1230**  			JP      M,INPUT4        ;STRING
0B138A F5          1231**  			PUSH    AF
0B138B DD E5       1232**  			PUSH    IX
0B138D CD 6C 07 0B 1233**  			CALL    VAL0
0B1391 DD E1       1234**  			POP     IX
0B1393 F1          1235**  			POP     AF
0B1394 CD D4 16 0B 1236**  			CALL    STORE
0B1398 18 04       1237**  			JR      INPUT5
0B139A CD FE 16 0B 1238**  INPUT4:			CALL    STACCS
0B139E E1          1239**  INPUT5:			POP     HL
0B139F C1          1240**  			POP     BC
0B13A0 CB 81       1241**  INPUT3:			RES     0,C
0B13A2 18 92       1242**  			JR      INPUT1
0B13A4             1243**  ;
0B13A4 CB 41       1244**  REFILL:			BIT     0,C
0B13A6 20 0C       1245**  			JR      NZ,REFIL0       ;NO PROMPT
0B13A8 3E 3F       1246**  			LD      A,'?'
0B13AA CD 4D 3A 0B 1247**  			CALL    OUTCHR          ;PROMPT
0B13AE 3E 20       1248**  			LD      A,' '
0B13B0 CD 4D 3A 0B 1249**  			CALL    OUTCHR
0B13B4 21 00 4C 0B 1250**  REFIL0:			LD      HL,BUFFER
0B13B8 C5          1251**  			PUSH    BC
0B13B9 E5          1252**  			PUSH    HL
0B13BA DD E5       1253**  			PUSH    IX
0B13BC CD 5D 3F 0B 1254**  			CALL    OSLINE
0B13C0 DD E1       1255**  			POP     IX
0B13C2 E1          1256**  			POP     HL
0B13C3 C1          1257**  			POP     BC
0B13C4 47          1258**  			LD      B,A             ;POS AT ENTRY
0B13C5 AF          1259**  			XOR     A
0B13C6 32 3D 4E 0B 1260**  			LD      (COUNT),A
0B13CA B8          1261**  			CP      B
0B13CB C8          1262**  			RET     Z
0B13CC 7E          1263**  REFIL1:			LD      A,(HL)
0B13CD FE 0D       1264**  			CP      CR
0B13CF C8          1265**  			RET     Z
0B13D0 23          1266**  			INC     HL
0B13D1 10 F9       1267**  			DJNZ    REFIL1
0B13D3 C9          1268**  			RET
0B13D4             1269**  
0B13D4             1270**  ; READ var[,var...]
0B13D4             1271**  ;
0B13D4 FE 23       1272**  READ:			CP      '#'
0B13D6 CA BD 12 0B 1273**  			JP      Z,INPUTN
0B13DA 2A 31 4E 0B 1274**  			LD      HL,(DATPTR)
0B13DE 7E          1275**  READ0:			LD      A,(HL)
0B13DF 23          1276**  			INC     HL              ;SKIP COMMA OR "DATA"
0B13E0 FE 0D       1277**  			CP      CR              ;END OF DATA STMT?
0B13E2 CC 26 14 0B 1278**  			CALL    Z,GETDAT
0B13E6 E5          1279**  			PUSH    HL
0B13E7 CD 8C 0D 0B 1280**  			CALL    VAR_
0B13EB E1          1281**  			POP     HL
0B13EC B7          1282**  			OR      A
0B13ED FA 06 14 0B 1283**  			JP      M,READ1         ;STRING
0B13F1 E5          1284**  			PUSH    HL
0B13F2 FD E3       1285**  			EX      (SP),IY
0B13F4 F5          1286**  			PUSH    AF              ;SAVE TYPE
0B13F5 DD E5       1287**  			PUSH    IX
0B13F7 CD 00 04 0B 1288**  			CALL    EXPRN
0B13FB DD E1       1289**  			POP     IX
0B13FD F1          1290**  			POP     AF
0B13FE CD D4 16 0B 1291**  			CALL    STORE
0B1402 FD E3       1292**  			EX      (SP),IY
0B1404 18 09       1293**  			JR      READ2
0B1406 CD 0B 19 0B 1294**  READ1:			CALL    FETCHS
0B140A E5          1295**  			PUSH    HL
0B140B CD FE 16 0B 1296**  			CALL    STACCS
0B140F E1          1297**  READ2:			POP     HL
0B1410 22 31 4E 0B 1298**  			LD      (DATPTR),HL
0B1414 CD 6E 0B 0B 1299**  			CALL    NXT
0B1418 FE 2C       1300**  			CP      ','
0B141A C2 94 0C 0B 1301**  			JP      NZ,XEQ
0B141E FD 23       1302**  			INC     IY
0B1420 CD 6E 0B 0B 1303**  			CALL    NXT
0B1424 18 B8       1304**  			JR      READ0
0B1426             1305**  ;
0B1426 3E DC       1306**  GETDAT:			LD      A,DATA_EX_
0B1428 CD 4C 19 0B 1307**  			CALL    SEARCH_EX
0B142C 23          1308**  			INC     HL
0B142D D0          1309**  			RET     NC
0B142E 3E 2A       1310**  			LD      A,42
0B1430 C3 5E 38 0B 1311**  ERROR4:			JP      ERROR_           ;"Out of DATA"
0B1434             1312**  
0B1434             1313**  ; IF expr statement
0B1434             1314**  ; IF expr THEN statement [ELSE statement]
0B1434             1315**  ; IF expr THEN line [ELSE line]
0B1434             1316**  ;
0B1434 CD 08 04 0B 1317**  IF_:			CALL    EXPRI
0B1438 CD DD 09 0B 1318**  			CALL    TEST
0B143C 28 19       1319**  			JR      Z,IFNOT         ;FALSE
0B143E FD 7E 00    1320**  			LD      A,(IY)
0B1441 FE 8C       1321**  			CP      THEN_EX_
0B1443 C2 94 0C 0B 1322**  			JP      NZ,XEQ
0B1447 FD 23       1323**  			INC     IY              ;SKIP "THEN"
0B1449 CD 6E 0B 0B 1324**  IF1:			CALL    NXT
0B144D FE 8D       1325**  			CP      LINO_EX
0B144F C2 94 0C 0B 1326**  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
0B1453 C3 29 10 0B 1327**  			JP      GOTO_EX            ;LINE NO. FOLLOWS
0B1457 FD 7E 00    1328**  IFNOT:			LD      A,(IY)
0B145A FE 0D       1329**  			CP      CR
0B145C FD 23       1330**  			INC     IY
0B145E CA 90 0C 0B 1331**  			JP      Z,XEQ0          ;END OF LINE
0B1462 FE 8B       1332**  			CP      ELSE_EX_
0B1464 20 F1       1333**  			JR      NZ,IFNOT
0B1466 18 E1       1334**  			JR      IF1
0B1468             1335**  
0B1468             1336**  ; CLS
0B1468             1337**  ;
0B1468 CD CA 44 0B 1338**  CLS:		CALL    CLRSCN
0B146C AF          1339**  			XOR     A
0B146D 32 3D 4E 0B 1340**  			LD      (COUNT),A
0B1471 C3 94 0C 0B 1341**  			JP      XEQ
0B1475             1342**  
0B1475             1343**  ; STOP
0B1475             1344**  ;
0B1475 CD 8E 3E 0B 1345**  STOP:			CALL    TELL
0B1479 0D          1346**  			DB	CR
0B147A 0A          1347**  			DB	LF
0B147B FA          1348**  			DB	TSTOP
0B147C 00          1349**  			DB	0
0B147D CD AC 3A 0B 1350**  			CALL    SETLIN          ;FIND CURRENT LINE
0B1481 CD E0 3A 0B 1351**  			CALL    SAYLN
0B1485 CD 45 3A 0B 1352**  			CALL    CRLF
0B1489 C3 7E 31 0B 1353**  			JP      CLOOP
0B148D             1354**  
0B148D             1355**  ; REPORT
0B148D             1356**  ;
0B148D CD 80 3E 0B 1357**  REPOR:			CALL    REPORT
0B1491 C3 94 0C 0B 1358**  			JP      XEQ
0B1495             1359**  
0B1495             1360**  ; CLEAR
0B1495             1361**  ;
0B1495 CD 74 39 0B 1362**  CLR:			CALL    CLEAR
0B1499 2A 14 4E 0B 1363**  			LD      HL,(PAGE_)
0B149D 18 19       1364**  			JR      RESTR1
0B149F             1365**  
0B149F             1366**  ; RESTORE [line]
0B149F             1367**  ;
0B149F 2A 14 4E 0B 1368**  RESTOR_EX:			LD      HL,(PAGE_)
0B14A3 CD 78 18 0B 1369**  			CALL    TERMQ
0B14A7 28 0F       1370**  			JR      Z,RESTR1
0B14A9 CD 23 04 0B 1371**  			CALL    ITEMI
0B14AD D9          1372**  			EXX
0B14AE CD 8D 3A 0B 1373**  			CALL    FINDL           ;SEARCH FOR LINE
0B14B2 3E 29       1374**  			LD      A,41
0B14B4 C2 30 14 0B 1375**  			JP      NZ,ERROR4       ;"No such line"
0B14B8 3E DC       1376**  RESTR1:			LD      A,DATA_EX_
0B14BA CD 4C 19 0B 1377**  			CALL    SEARCH_EX
0B14BE 22 31 4E 0B 1378**  			LD      (DATPTR),HL
0B14C2 C3 94 0C 0B 1379**  			JP      XEQ
0B14C6             1380**  
0B14C6             1381**  ; PTR#channel=expr
0B14C6             1382**  ; PAGE=expr
0B14C6             1383**  ; TIME=expr
0B14C6             1384**  ; LOMEM=expr
0B14C6             1385**  ; HIMEM=expr
0B14C6             1386**  ;
0B14C6 CD 84 19 0B 1387**  PTR_EX:			CALL    CHANEL
0B14CA CD 8E 18 0B 1388**  			CALL    EQUALS
0B14CE 7B          1389**  			LD      A,E
0B14CF F5          1390**  			PUSH    AF
0B14D0 CD 08 04 0B 1391**  			CALL    EXPRI
0B14D4 E5          1392**  			PUSH    HL
0B14D5 D9          1393**  			EXX
0B14D6 D1          1394**  			POP     DE
0B14D7 F1          1395**  			POP     AF
0B14D8 CD 65 44 0B 1396**  			CALL    PUTPTR
0B14DC C3 94 0C 0B 1397**  			JP      XEQ
0B14E0             1398**  ;
0B14E0 CD 8E 18 0B 1399**  PAGEV_EX:			CALL    EQUALS
0B14E4 CD 08 04 0B 1400**  			CALL    EXPRI
0B14E8 D9          1401**  			EXX
0B14E9 2E 00       1402**  			LD      L,0
0B14EB 22 14 4E 0B 1403**  			LD      (PAGE_),HL
0B14EF C3 94 0C 0B 1404**  			JP      XEQ
0B14F3             1405**  ;
0B14F3 FE 24       1406**  TIMEV_EX:			CP      '$'
0B14F5 28 13       1407**  			JR      Z,TIMEVS_EX
0B14F7 CD 8E 18 0B 1408**  			CALL    EQUALS
0B14FB CD 08 04 0B 1409**  			CALL    EXPRI
0B14FF E5          1410**  			PUSH    HL
0B1500 D9          1411**  			EXX
0B1501 D1          1412**  			POP     DE
0B1502 CD 95 3F 0B 1413**  			CALL    PUTIME
0B1506 C3 94 0C 0B 1414**  			JP      XEQ
0B150A             1415**  ;
0B150A FD 23       1416**  TIMEVS_EX:			INC     IY              ;SKIP '$'
0B150C CD 8E 18 0B 1417**  			CALL    EQUALS
0B1510 CD 13 04 0B 1418**  			CALL    EXPRS
0B1514 CD B5 44 0B 1419**  			CALL    PUTIMS
0B1518 C3 94 0C 0B 1420**  			JP      XEQ
0B151C             1421**  ;
0B151C CD 8E 18 0B 1422**  LOMEMV_EX:			CALL    EQUALS
0B1520 CD 08 04 0B 1423**  			CALL    EXPRI
0B1524 CD 74 39 0B 1424**  			CALL    CLEAR
0B1528 D9          1425**  			EXX
0B1529 22 1A 4E 0B 1426**  			LD      (LOMEM),HL
0B152D 22 1D 4E 0B 1427**  			LD      (FREE),HL
0B1531 C3 94 0C 0B 1428**  			JP      XEQ
0B1535             1429**  ;
0B1535 CD 8E 18 0B 1430**  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
0B1539 CD 08 04 0B 1431**  			CALL    EXPRI			; Load the expression into registers
0B153D             1432**  ; BEGIN MISSING FROM BINARY
0B153D             1433**  			; LD	A,L			;  A: The MSB of the 24-bit value
0B153D             1434**  			; EXX				; HL: The LSW of the 24-bit value
0B153D             1435**  			; LD	(R0),HL
0B153D             1436**  			; LD	(R0+2),A
0B153D             1437**  			; LD	HL,(FREE)
0B153D             1438**  			; LD      DE,256
0B153D             1439**  			; ADD	HL,DE
0B153D             1440**  			; EX	DE,HL			; DE: FREE + 256
0B153D             1441**  			; LD	HL,(R0)			; HL: The passed expression
0B153D             1442**  ; END MISSING FROM BINARY
0B153D             1443**  ; BEGIN ADDED FROM BINARY
0B153D D9          1444**  			exx
0B153E ED 5B 1D 4E 1445**  			ld de,(FREE)
       0B          
0B1543 14          1446**  			inc d
0B1544             1447**  ; END ADDED FROM BINARY
0B1544 AF          1448**  			XOR     A
0B1545 ED 52       1449**  			SBC     HL,DE
0B1547 19          1450**  			ADD     HL,DE			; Do a bounds check
0B1548 DA 5E 38 0B 1451**  			JP      C,ERROR_         	; Throw the error: "No room"
0B154C ED 5B 20 4E 1452**  			LD      DE,(HIMEM)
       0B          
0B1551 22 20 4E 0B 1453**  			LD      (HIMEM),HL
0B1555 EB          1454**  			EX      DE,HL
0B1556 ED 72       1455**  			SBC     HL,SP			; Adjust the stack
0B1558 C2 94 0C 0B 1456**  			JP      NZ,XEQ
0B155C EB          1457**  			EX      DE,HL
0B155D F9          1458**  			LD      SP,HL           	; Load the SP
0B155E C3 94 0C 0B 1459**  			JP      XEQ
0B1562             1460**  
0B1562             1461**  ; WIDTH expr
0B1562             1462**  ;
0B1562 CD 08 04 0B 1463**  WIDTHV:			CALL    EXPRI
0B1566 D9          1464**  			EXX
0B1567 7D          1465**  			LD      A,L
0B1568 32 3E 4E 0B 1466**  			LD      (WIDTH),A
0B156C C3 94 0C 0B 1467**  			JP      XEQ
0B1570             1468**  
0B1570             1469**  ; TRACE ON
0B1570             1470**  ; TRACE OFF
0B1570             1471**  ; TRACE line
0B1570             1472**  ;
0B1570 FD 23       1473**  TRACE_EX:			INC     IY
0B1572 21 00 00 00 1474**  			LD      HL,0
0B1576 FE EE       1475**  			CP      TON
0B1578 28 0B       1476**  			JR      Z,TRACE0
0B157A FE 87       1477**  			CP      OFF_
0B157C 28 08       1478**  			JR      Z,TRACE1
0B157E FD 2B       1479**  			DEC     IY
0B1580 CD 08 04 0B 1480**  			CALL    EXPRI
0B1584 D9          1481**  			EXX
0B1585 2B          1482**  TRACE0:			DEC     HL
0B1586 22 26 4E 0B 1483**  TRACE1:			LD      (TRACEN),HL
0B158A C3 94 0C 0B 1484**  			JP      XEQ
0B158E             1485**  
0B158E             1486**  ; VDU expr,expr;....
0B158E             1487**  ;
0B158E             1488**  ; BEGIN MISSING FROM BINARY
0B158E             1489**  ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
0B158E             1490**  ; VDU1:			PUSH	IX
0B158E             1491**  ; 			CALL    EXPRI			; Fetch the VDU character
0B158E             1492**  ; 			POP	IX
0B158E             1493**  ; 			EXX
0B158E             1494**  ; 			LD	(IX+0),L		; Write out the character to the buffer
0B158E             1495**  ; 			INC	IX
0B158E             1496**  ; 			LD      A,(IY)			;  A: The separator character
0B158E             1497**  ; 			CP      ','			; Is it a comma?
0B158E             1498**  ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0B158E             1499**  ; 			CP      ';'			; Is it a semicolon?
0B158E             1500**  ; 			JR      NZ,VDU3			; No, so skip to the next expression
0B158E             1501**  ; 			LD	(IX+0),H		; Write out the high byte to the buffer
0B158E             1502**  ; 			INC	IX
0B158E             1503**  ; VDU2:			INC     IY			; Skip to the next character
0B158E             1504**  ; VDU3:			CALL    TERMQ			; Skip past white space
0B158E             1505**  ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0B158E             1506**  ; 			LD	A,IXL			;  A: Number of bytes to write out
0B158E             1507**  ; 			OR	A
0B158E             1508**  ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0B158E             1509**  ; 			LD	HL,BUFFER		; HL: Start of stream
0B158E             1510**  ; 			LD	BC,0
0B158E             1511**  ; 			LD	C,A			; BC: Number of bytes to write out
0B158E             1512**  ; 			RST.LIL	18h			; Output the buffer to MOS
0B158E             1513**  ; END MISSING FROM BINARY
0B158E             1514**  ; BEGIN ADDED FROM BINARY
0B158E             1515**  VDU:
0B158E CD 08 04 0B 1516**  			call EXPRI
0B1592 D9          1517**  			exx
0B1593 7D          1518**  			ld a,l
0B1594 CD FE 3F 0B 1519**  			call OSWRCH
0B1598 FD 7E 00    1520**  			ld a,(iy)
0B159B FE 2C       1521**  			cp $2c
0B159D 28 09       1522**  			jr z,$+$0b
0B159F FE 3B       1523**  			cp $3b
0B15A1 20 07       1524**  			jr nz,$+$09
0B15A3 7C          1525**  			ld a,h
0B15A4 CD FE 3F 0B 1526**  			call OSWRCH
0B15A8 FD 23       1527**  			inc iy
0B15AA CD 78 18 0B 1528**  			call TERMQ
0B15AE 20 DE       1529**  			jr nz,$-$20
0B15B0             1530**  ; END ADDED FROM BINARY
0B15B0 C3 94 0C 0B 1531**  VDU4:			JP      XEQ
0B15B4             1532**  
0B15B4             1533**  ; CLOSE channel number
0B15B4             1534**  ;
0B15B4 CD 84 19 0B 1535**  CLOSE:			CALL    CHANEL			; Fetch the channel number
0B15B8 CD 29 44 0B 1536**  			CALL    OSSHUT			; Close the channel
0B15BC C3 94 0C 0B 1537**  			JP      XEQ
0B15C0             1538**  
0B15C0             1539**  ; BPUT channel,byte
0B15C0             1540**  ;
0B15C0 CD 84 19 0B 1541**  BPUT:			CALL    CHANEL          	; Fetch the channel number
0B15C4 D5          1542**  			PUSH    DE			; DE: Channel number
0B15C5 CD 20 0B 0B 1543**  			CALL    COMMA			; Skip to the next expression
0B15C9 CD 08 04 0B 1544**  			CALL    EXPRI           	; Feth the data
0B15CD D9          1545**  			EXX
0B15CE 7D          1546**  			LD      A,L			; A: The byte to write
0B15CF D1          1547**  			POP     DE
0B15D0 CD 39 44 0B 1548**  			CALL    OSBPUT			; Write the byte out
0B15D4 C3 94 0C 0B 1549**  			JP      XEQ
0B15D8             1550**  
0B15D8             1551**  ; CALL address[,var[,var...]]
0B15D8             1552**  ;
0B15D8             1553**  ; Note that the parameter table differs from the Z80 version
0B15D8             1554**  ; Each entry now takes up 4 bytes, not 3, so the table is now:
0B15D8             1555**  ;  -1 byte:  Number of parameters
0B15D8             1556**  ; Then, for each parameter:
0B15D8             1557**  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
0B15D8             1558**  ;  -3 bytes: Parameter address
0B15D8             1559**  ;
0B15D8             1560**  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
0B15D8             1561**  ;
0B15D8 CD 08 04 0B 1562**  CALL_:			CALL    EXPRI           	; Fetch the address
0B15DC 7D          1563**  			LD	A,L			;  A: MSB of address
0B15DD D9          1564**  			EXX
0B15DE 22 4A 4E 0B 1565**  			LD	(R0+0),HL		; HL: LSW of address
0B15E2 32 4C 4E 0B 1566**  			LD	(R0+2),A
0B15E6 06 00       1567**  			LD      B,0             	;  B: The parameter counter
0B15E8 11 00 4C 0B 1568**  			LD      DE,BUFFER       	; DE: Vector
0B15EC             1569**  ;
0B15EC CD 6E 0B 0B 1570**  CALL1:			CALL    NXT			; Skip whitespace
0B15F0 FE 2C       1571**  			CP      ','			; Check for comma
0B15F2 20 1B       1572**  			JR      NZ,CALL2		; If no more parameters, then jump here
0B15F4 FD 23       1573**  			INC     IY			; Skip to the next character
0B15F6 04          1574**  			INC     B			; Increment the parameter count
0B15F7 CD 6E 0B 0B 1575**  			CALL    NXT			; Skip whitespace
0B15FB C5          1576**  			PUSH    BC
0B15FC D5          1577**  			PUSH    DE
0B15FD CD 8C 0D 0B 1578**  			CALL    VAR_
0B1601 D1          1579**  			POP     DE
0B1602 C1          1580**  			POP     BC
0B1603 13          1581**  			INC     DE
0B1604 12          1582**  			LD      (DE),A			; Save the parameter type
0B1605 13          1583**  			INC     DE
0B1606 EB          1584**  			EX      DE,HL
0B1607 ED 1F       1585**  			LD	(HL),DE			; Save the parameter address (3 bytes)
0B1609 23          1586**  			INC	HL
0B160A 23          1587**  			INC	HL
0B160B 23          1588**  			INC	HL
0B160C EB          1589**  			EX      DE,HL
0B160D 18 DD       1590**  			JR      CALL1
0B160F             1591**  ;
0B160F 78          1592**  CALL2:			LD      A,B
0B1610 32 00 4C 0B 1593**  			LD      (BUFFER),A      	; Save the parameter count
0B1614 2A 4A 4E 0B 1594**  			LD	HL,(R0)			; HL: Address of the code
0B1618 CD 32 16 0B 1595**  			CALL    USR1			; And call it
0B161C C3 94 0C 0B 1596**  			JP      XEQ
0B1620             1597**  
0B1620             1598**  ; USR(address)
0B1620             1599**  ;
0B1620 CD 23 04 0B 1600**  USR:			CALL    ITEMI			; Evaluate the expression
0B1624 7D          1601**  			LD	A,L			;  A: MSB of address
0B1625 D9          1602**  			EXX
0B1626 22 4A 4E 0B 1603**  			LD	(R0+0),HL		; HL: LSW of address
0B162A 32 4C 4E 0B 1604**  			LD	(R0+2),A
0B162E 2A 4A 4E 0B 1605**  			LD	HL,(R0)			; Get the 24-bit address in HL
0B1632             1606**  ;
0B1632 E5          1607**  USR1:			PUSH    HL              	; Address on stack
0B1633 FD E3       1608**  			EX      (SP),IY
0B1635 24          1609**  			INC     H               	; Check for PAGE &00FFxx
0B1636 B4          1610**  			OR	H
0B1637 21 A1 16 0B 1611**  			LD      HL,USR2         	; Return address
0B163B E5          1612**  			PUSH    HL
0B163C DD 21 00 4D 1613**  			LD      IX,STAVAR
       0B          
0B1641 CC EF 43 0B 1614**  			CALL    Z,OSCALL        	; Intercept &00FFxx
0B1645             1615**  ;
0B1645 DD 4E 18    1616**  			LD      C, (IX+24)		; F%
0B1648 C5          1617**  			PUSH    BC
0B1649             1618**  ;
0B1649 DD 7E 08    1619**  			LD	A, (IX+8)		; B% -> MSW
0B164C 32 4B 4E 0B 1620**  			LD	(R0+1), A
0B1650 DD 7E 09    1621**  			LD	A, (IX+9)
0B1653 32 4C 4E 0B 1622**  			LD	(R0+2), A
0B1657 DD 7E 0C    1623**  			LD	A, (IX+12)		; C% -> LSB
0B165A 32 4A 4E 0B 1624**  			LD	(R0+0), A
0B165E ED 4B 4A 4E 1625**  			LD	BC, (R0)
       0B          
0B1663             1626**  ;
0B1663 DD 7E 10    1627**  			LD	A, (IX+16)		; D% -> MSW
0B1666 32 4B 4E 0B 1628**  			LD	(R0+1), A
0B166A DD 7E 11    1629**  			LD	A, (IX+17)
0B166D 32 4C 4E 0B 1630**  			LD	(R0+2), A
0B1671 DD 7E 14    1631**  			LD	A, (IX+20)		; E% -> LSB
0B1674 32 4A 4E 0B 1632**  			LD	(R0+0), A
0B1678 ED 5B 4A 4E 1633**  			LD	DE, (R0)
       0B          
0B167D             1634**  ;
0B167D DD 7E 20    1635**  			LD	A, (IX+32)		; H% -> MSW
0B1680 32 4B 4E 0B 1636**  			LD	(R0+1), A
0B1684 DD 7E 21    1637**  			LD	A, (IX+33)
0B1687 32 4C 4E 0B 1638**  			LD	(R0+2), A
0B168B DD 7E 30    1639**  			LD	A, (IX+48)		; L% -> LSB
0B168E 32 4A 4E 0B 1640**  			LD	(R0+0), A
0B1692 2A 4A 4E 0B 1641**  			LD	HL, (R0)
0B1696             1642**  ;
0B1696 F1          1643**  			POP     AF			; F%
0B1697 DD 7E 04    1644**  			LD      A, (IX+4)        	; A%
0B169A             1645**  
0B169A DD 21 00 4C 1646**  			LD      IX,BUFFER
       0B          
0B169F FD E9       1647**  			JP      (IY)            	; Off to user routine
0B16A1             1648**  ;
0B16A1 FD E1       1649**  USR2:			POP     IY
0B16A3 AF          1650**  			XOR     A
0B16A4 4F          1651**  			LD      C,A
0B16A5 C9          1652**  			RET
0B16A6             1653**  
0B16A6             1654**  ; PUT port,data
0B16A6             1655**  ;
0B16A6 CD 08 04 0B 1656**  PUT:			CALL    EXPRI           ;PORT ADDRESS
0B16AA D9          1657**  			EXX
0B16AB E5          1658**  			PUSH    HL
0B16AC CD 20 0B 0B 1659**  			CALL    COMMA
0B16B0 CD 08 04 0B 1660**  			CALL    EXPRI           ;DATA
0B16B4 D9          1661**  			EXX
0B16B5 C1          1662**  			POP     BC
0B16B6 ED 69       1663**  			OUT     (C),L           ;OUTPUT TO PORT BC
0B16B8 C3 94 0C 0B 1664**  			JP      XEQ
0B16BC             1665**  
0B16BC             1666**  ; SUBROUTINES -----------------------------------------------------------------
0B16BC             1667**  
0B16BC             1668**  ; ASSIGN - Assign a numeric value to a variable.
0B16BC             1669**  ; Outputs: NC,  Z - OK, numeric.
0B16BC             1670**  ;          NC, NZ - OK, string.
0B16BC             1671**  ;           C, NZ - illegal
0B16BC             1672**  ;
0B16BC CD 38 3B 0B 1673**  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0B16C0 D8          1674**  			RET     C               	; Return with C if it is an illegal variable
0B16C1 C4 27 3B 0B 1675**  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0B16C5 B7          1676**  			OR      A
0B16C6 F8          1677**  			RET     M               	; Return if type is string (81h)
0B16C7 F5          1678**  			PUSH    AF              	; It's a numeric type from this point on
0B16C8 CD 8E 18 0B 1679**  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B16CC E5          1680**  			PUSH    HL
0B16CD CD 00 04 0B 1681**  			CALL    EXPRN
0B16D1 DD E1       1682**  			POP     IX
0B16D3 F1          1683**  			POP     AF
0B16D4 CB 47       1684**  STORE:			BIT     0,A
0B16D6 28 13       1685**  			JR      Z,STOREI
0B16D8 BF          1686**  			CP      A               	; Set the variable to 0
0B16D9 DD 71 04    1687**  STORE5:			LD      (IX+4),C
0B16DC D9          1688**  STORE4:			EXX
0B16DD DD 75 00    1689**  			LD      (IX+0),L
0B16E0 DD 74 01    1690**  			LD      (IX+1),H
0B16E3 D9          1691**  			EXX
0B16E4 DD 75 02    1692**  			LD      (IX+2),L
0B16E7 DD 74 03    1693**  			LD      (IX+3),H
0B16EA C9          1694**  			RET
0B16EB F5          1695**  STOREI:			PUSH    AF
0B16EC 0C          1696**  			INC     C               ;SPEED - & PRESERVE F'
0B16ED 0D          1697**  			DEC     C               ; WHEN CALLED BY FNEND0
0B16EE C4 60 07 0B 1698**  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
0B16F2 F1          1699**  			POP     AF
0B16F3 FE 04       1700**  			CP      4
0B16F5 28 E5       1701**  			JR      Z,STORE4
0B16F7 BF          1702**  			CP      A               ;SET ZERO
0B16F8 D9          1703**  STORE1:			EXX
0B16F9 DD 75 00    1704**  			LD      (IX+0),L
0B16FC D9          1705**  			EXX
0B16FD C9          1706**  			RET
0B16FE             1707**  ;
0B16FE             1708**  ; Copy a string from the string accumulator to variable storage on the stack
0B16FE             1709**  ; Parameters:
0B16FE             1710**  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
0B16FE             1711**  ; - IX: Address of the variable storage on the stack
0B16FE             1712**  ;
0B16FE 21 00 4B 0B 1713**  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B1702             1714**  ;
0B1702             1715**  ; Parameters:
0B1702             1716**  ; As above, but:
0B1702             1717**  ; - HL: Address of the string to be stored
0B1702             1718**  ; -  E: The string length
0B1702             1719**  ; NB:
0B1702             1720**  ; Strings are mutable
0B1702             1721**  ; Strings are stored in the following format in the variable:
0B1702             1722**  ; - Address of the next variable (3 bytes)
0B1702             1723**  ; - The rest of the variable name - this is zero terminated
0B1702             1724**  ; - Current string length (byte)
0B1702             1725**  ; - Maximum (original) string length (byte)
0B1702             1726**  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
0B1702             1727**  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
0B1702             1728**  ;
0B1702 1F          1729**  STORES:			RRA				; Rotate right to shift bit 0 into carry
0B1703 30 5D       1730**  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
0B1705 E5          1731**  			PUSH    HL			; Stack ACCS
0B1706             1732**  ;
0B1706             1733**  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
0B1706             1734**  ;
0B1706 D9          1735**  			EXX				; This block was a call to LOAD4
0B1707 DD 6E 00    1736**  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B170A DD 66 01    1737**  			LD      H,(IX+1)		; The maximum original string length
0B170D D9          1738**  			EXX
0B170E DD 27 02    1739**  			LD	HL,(IX+2)		; Address of the string (24-bit)
0B1711             1740**  ;
0B1711 7B          1741**  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
0B1712 D9          1742**  			EXX
0B1713 6F          1743**  			LD      L,A			; L': Length of string currently stored on the stack
0B1714 7C          1744**  			LD      A,H             	; H': The maximum (original) string length
0B1715 D9          1745**  			EXX
0B1716 BB          1746**  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
0B1717 30 17       1747**  			JR      NC,STORS1       	; Yes there is, so skip the next bit
0B1719             1748**  ;
0B1719             1749**  ; At this point we're either initialising a new string or assigning more memory to an existing string
0B1719             1750**  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
0B1719             1751**  ; then the existing and new strings may both exist in memory.
0B1719             1752**  ;
0B1719 D9          1753**  			EXX
0B171A 65          1754**  			LD      H,L			; H: Set the maximum string length to the string length
0B171B D9          1755**  			EXX
0B171C E5          1756**  			PUSH    HL
0B171D 01 00 00 00 1757**  			LD	BC, 0
0B1721 4F          1758**  			LD      C,A			; BC: The maximum (original) string length
0B1722 09          1759**  			ADD     HL,BC			; Work out whether this is the last string in memory
0B1723 ED 4B 1D 4E 1760**  			LD      BC,(FREE)
       0B          
0B1728 ED 42       1761**  			SBC     HL,BC			; Is string last?
0B172A E1          1762**  			POP     HL
0B172B 37          1763**  			SCF
0B172C 28 02       1764**  			JR      Z,STORS1
0B172E             1765**  			; LD	HL, BC			; HL=BC
0B172E C5          1766**  			push bc
0B172F E1          1767**  			pop hl
0B1730             1768**  ;
0B1730             1769**  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
0B1730             1770**  ; - H': The maximum (original) string length
0B1730             1771**  ; - L': The actual string length (must be less than H')
0B1730             1772**  ; - HL: Address of the string in memory
0B1730             1773**  ;
0B1730 D9          1774**  STORS1:			EXX				; This block was a call to STORE4
0B1731 DD 75 00    1775**  			LD      (IX+0),L		; The actual string length (must be less then H')
0B1734 DD 74 01    1776**  			LD      (IX+1),H		; The maximum (original) string length
0B1737 D9          1777**  			EXX
0B1738 DD 2F 02    1778**  			LD	(IX+2),HL		; The pointer to the original string
0B173B             1779**  ;
0B173B 01 00 00 00 1780**  			LD	BC, 0
0B173F 4B          1781**  			LD      C,E			; BC: The new string length
0B1740 EB          1782**  			EX      DE,HL
0B1741 E1          1783**  			POP     HL
0B1742 0D          1784**  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
0B1743 0C          1785**  			INC     C			; check whether BC is 0 without affecting the carry flag
0B1744 C8          1786**  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
0B1745 ED B0       1787**  			LDIR				; Replace the string in memory
0B1747 D0          1788**  			RET     NC
0B1748 ED 53 1D 4E 1789**  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       0B          
0B174D             1790**  ;
0B174D             1791**  ; Check whether the stack is full
0B174D             1792**  ;
0B174D E5          1793**  CHECK:			PUSH    HL
0B174E C5          1794**  			PUSH	BC
0B174F 2A 1D 4E 0B 1795**  			LD      HL,(FREE)		; HL: Address of first free space byte
0B1753 01 00 01 00 1796**  			LD	BC,100h			; BC: One page of memory
0B1757 09          1797**  			ADD	HL,BC			; Add a page to FREE
0B1758 ED 72       1798**  			SBC     HL,SP			; And subtract the current SP
0B175A C1          1799**  			POP	BC
0B175B E1          1800**  			POP     HL
0B175C D8          1801**  			RET     C			; The SP is not in the same page, so just return
0B175D AF          1802**  			XOR     A			; Otherwise
0B175E C3 5E 38 0B 1803**  			JP      ERROR_			; Throw error "No room"
0B1762             1804**  ;
0B1762 01 00 00 00 1805**  STORS3:			LD	BC,0
0B1766 4B          1806**  			LD      C,E			; BC: String length
0B1767 DD E5       1807**  			PUSH    IX
0B1769 D1          1808**  			POP     DE			; DE: Destination
0B176A AF          1809**  			XOR     A			; Check if string length is 0
0B176B B9          1810**  			CP      C
0B176C 28 02       1811**  			JR      Z,STORS5		; Yes, so don't copy
0B176E ED B0       1812**  			LDIR
0B1770 3E 0D       1813**  STORS5:			LD      A,CR			; Finally add the terminator
0B1772 12          1814**  			LD      (DE),A
0B1773 C9          1815**  			RET
0B1774             1816**  
0B1774             1817**  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0B1774             1818**  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0B1774             1819**  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0B1774             1820**  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0B1774             1821**  ;    Inputs: DE addresses parameter list
0B1774             1822**  ;            IY addresses dummy variable list
0B1774             1823**  ;   Outputs: DE,IY updated
0B1774             1824**  ;  Destroys: Everything
0B1774             1825**  ;
0B1774 3E FF       1826**  ARGUE:			LD      A,-1
0B1776 F5          1827**  			PUSH    AF              	; Put marker on the stack
0B1777 FD 23       1828**  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0B1779 13          1829**  			INC     DE
0B177A D5          1830**  			PUSH    DE
0B177B CD 6E 0B 0B 1831**  			CALL    NXT			; Skip any whitespace
0B177F CD 38 3B 0B 1832**  			CALL    GETVAR			; Get the location of the variable in HL/IX
0B1783 38 3F       1833**  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0B1785 C4 27 3B 0B 1834**  			CALL    NZ,PUTVAR
0B1789 D1          1835**  			POP     DE
0B178A E5          1836**  			PUSH    HL              	; VARPTR
0B178B B7          1837**  			OR      A               	; Check the variable type
0B178C F5          1838**  			PUSH    AF
0B178D D5          1839**  			PUSH    DE
0B178E FD E3       1840**  			EX      (SP),IY
0B1790 FA A8 17 0B 1841**  			JP      M,ARGUE2        	; Jump here if it is a string
0B1794             1842**  ;
0B1794 CD 00 04 0B 1843**  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0B1798 FD E3       1844**  			EX      (SP),IY
0B179A D1          1845**  			POP     DE
0B179B F1          1846**  			POP     AF
0B179C D9          1847**  			EXX
0B179D E5          1848**  			PUSH    HL
0B179E D9          1849**  			EXX
0B179F E5          1850**  			PUSH    HL
0B17A0 47          1851**  			LD      B,A
0B17A1 C5          1852**  			PUSH    BC
0B17A2 CD 4D 17 0B 1853**  			CALL    CHECK           	; Check room
0B17A6 18 0F       1854**  			JR      ARGUE4
0B17A8             1855**  ;
0B17A8 CD 13 04 0B 1856**  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0B17AC FD E3       1857**  			EX      (SP),IY
0B17AE D9          1858**  			EXX
0B17AF D1          1859**  			POP     DE
0B17B0 D9          1860**  			EXX
0B17B1 F1          1861**  			POP     AF
0B17B2 CD B2 0A 0B 1862**  			CALL    PUSHS
0B17B6 D9          1863**  			EXX
0B17B7             1864**  ;
0B17B7 CD 6E 0B 0B 1865**  ARGUE4:			CALL    NXT			; Skip whitespace
0B17BB FE 2C       1866**  			CP      ','			; Check to see if the next value is a comma
0B17BD 20 0B       1867**  			JR      NZ,ARGUE5		; No, so jump here
0B17BF 1A          1868**  			LD      A,(DE)
0B17C0 FE 2C       1869**  			CP      ','			; Are there any more arguments?
0B17C2 28 B3       1870**  			JR      Z,ARGUE1        	; Yes, so loop
0B17C4             1871**  ;
0B17C4 3E 1F       1872**  ARGERR:			LD      A,31
0B17C6 C3 5E 38 0B 1873**  			JP      ERROR_           	; Throw error "Arguments"
0B17CA             1874**  ;
0B17CA CD 2D 0B 0B 1875**  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0B17CE 1A          1876**  			LD      A,(DE)
0B17CF FE 29       1877**  			CP      ')'
0B17D1 20 F1       1878**  			JR      NZ,ARGERR
0B17D3 13          1879**  			INC     DE
0B17D4 D9          1880**  			EXX
0B17D5 C1          1881**  ARGUE6:			POP     BC
0B17D6 78          1882**  			LD      A,B
0B17D7 3C          1883**  			INC     A
0B17D8 D9          1884**  			EXX
0B17D9 C8          1885**  			RET     Z               	; Marker popped
0B17DA D9          1886**  			EXX
0B17DB 3D          1887**  			DEC     A
0B17DC FA EC 17 0B 1888**  			JP      M,ARGUE7        	; If it is a string, then jump here
0B17E0 E1          1889**  			POP     HL
0B17E1 D9          1890**  			EXX
0B17E2 E1          1891**  			POP     HL
0B17E3 D9          1892**  			EXX
0B17E4 DD E1       1893**  			POP     IX
0B17E6 CD D4 16 0B 1894**  			CALL    STORE	           	; Write to dummy variable
0B17EA 18 E9       1895**  			JR      ARGUE6
0B17EC             1896**  ;
0B17EC CD DC 0A 0B 1897**  ARGUE7:			CALL    POPS
0B17F0 DD E1       1898**  			POP     IX
0B17F2 CD FE 16 0B 1899**  			CALL    STACCS
0B17F6 18 DD       1900**  			JR      ARGUE6
0B17F8             1901**  
0B17F8             1902**  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
0B17F8             1903**  ;   OF A FUNCTION OR PROCEDURE.
0B17F8             1904**  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
0B17F8             1905**  ;    Inputs: IY is parameters pointer
0B17F8             1906**  ;   Outputs: IY updated
0B17F8             1907**  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
0B17F8             1908**  ;
0B17F8 D1          1909**  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
0B17F9             1910**  ;
0B17F9 FD 23       1911**  SAVLO1:			INC     IY              	; Bump past '(' or ','
0B17FB CD 6E 0B 0B 1912**  			CALL    NXT			; And also any whitespace
0B17FF D5          1913**  			PUSH    DE			; Push the return address back onto the stack
0B1800 D9          1914**  			EXX
0B1801 C5          1915**  			PUSH    BC
0B1802 D5          1916**  			PUSH    DE
0B1803 E5          1917**  			PUSH    HL
0B1804 D9          1918**  			EXX
0B1805 CD 8C 0D 0B 1919**  			CALL    VAR_             	; Dummy variable
0B1809 D9          1920**  			EXX
0B180A E1          1921**  			POP     HL
0B180B D1          1922**  			POP     DE
0B180C C1          1923**  			POP     BC
0B180D D9          1924**  			EXX
0B180E D1          1925**  			POP     DE
0B180F B7          1926**  			OR      A               	; Check the variable type
0B1810 FA 23 18 0B 1927**  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
0B1814 D9          1928**  			EXX
0B1815 E5          1929**  			PUSH    HL              	; Save H'L'
0B1816 D9          1930**  			EXX
0B1817 47          1931**  			LD      B,A             	;  B: Variable type
0B1818 CD 14 05 0B 1932**  			CALL    LOADN
0B181C D9          1933**  			EXX
0B181D E3          1934**  			EX      (SP),HL
0B181E D9          1935**  			EXX
0B181F E5          1936**  			PUSH    HL
0B1820 C5          1937**  			PUSH    BC
0B1821 18 2D       1938**  			JR      SAVLO4
0B1823             1939**  ;
0B1823 F5          1940**  SAVLO2:			PUSH    AF              	; Save the type (string)
0B1824 D5          1941**  			PUSH    DE
0B1825 D9          1942**  			EXX
0B1826 E5          1943**  			PUSH    HL
0B1827 D9          1944**  			EXX
0B1828 CD 9E 05 0B 1945**  			CALL    LOADS
0B182C D9          1946**  			EXX
0B182D E1          1947**  			POP     HL
0B182E D9          1948**  			EXX
0B182F 01 00 00 00 1949**  			LD	BC,0
0B1833 4B          1950**  			LD      C,E			; BC: String length
0B1834 D1          1951**  			POP     DE
0B1835 CD 4D 17 0B 1952**  			CALL    CHECK			; Check if there is space on the stack
0B1839 F1          1953**  			POP     AF              	; Level stack
0B183A 21 00 00 00 1954**  			LD      HL,0
0B183E ED 42       1955**  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
0B1840 39          1956**  			ADD     HL,SP			; Make space for the string on the stack
0B1841 F9          1957**  			LD      SP,HL
0B1842 47          1958**  			LD      B,A             	;  B: Variable type
0B1843 C5          1959**  			PUSH    BC
0B1844 28 0A       1960**  			JR      Z,SAVLO4
0B1846 D5          1961**  			PUSH    DE
0B1847 11 00 4B 0B 1962**  			LD      DE,ACCS
0B184B EB          1963**  			EX      DE,HL
0B184C 45          1964**  			LD      B,L
0B184D ED B0       1965**  			LDIR                    	; Save the string onto the stack
0B184F D1          1966**  			POP     DE
0B1850             1967**  ;
0B1850 DD E5       1968**  SAVLO4:			PUSH    IX			; VARPTR
0B1852 CD 56 18 0B 1969**  			CALL    SAVLO5
0B1856             1970**  LOCCHK:			EQU     $
0B1856 CD 4D 17 0B 1971**  SAVLO5:			CALL    CHECK
0B185A CD 6E 0B 0B 1972**  			CALL    NXT
0B185E FE 2C       1973**  			CP      ','             	; Are there any more local variables?
0B1860 28 97       1974**  			JR      Z,SAVLO1		; Yes, so loop
0B1862 EB          1975**  			EX      DE,HL			; DE -> HL: The return address
0B1863 E9          1976**  			JP      (HL)            	; And effectvely return
0B1864             1977**  ;
0B1864 FD 7E 00    1978**  DELIM:			LD      A,(IY)          	; Assembler delimiter
0B1867 FE 20       1979**  			CP      ' '
0B1869 C8          1980**  			RET     Z
0B186A FE 2C       1981**  			CP      ','
0B186C C8          1982**  			RET     Z
0B186D FE 29       1983**  			CP      ')'
0B186F C8          1984**  			RET     Z
0B1870 FE 3B       1985**  TERM:			CP      ';'             	; Assembler terminator
0B1872 C8          1986**  			RET     Z
0B1873 FE 5C       1987**  			CP      '\'
0B1875 C8          1988**  			RET     Z
0B1876 18 07       1989**  			JR      TERM0
0B1878             1990**  ;
0B1878 CD 6E 0B 0B 1991**  TERMQ:			CALL    NXT
0B187C FE 8B       1992**  			CP      ELSE_EX_
0B187E D0          1993**  			RET     NC
0B187F FE 3A       1994**  TERM0:			CP      ':'             	; Assembler seperator
0B1881 D0          1995**  			RET     NC
0B1882 FE 0D       1996**  			CP      CR
0B1884 C9          1997**  			RET
0B1885             1998**  ;
0B1885 CD 78 18 0B 1999**  SPAN:			CALL    TERMQ
0B1889 C8          2000**  			RET     Z
0B188A FD 23       2001**  			INC     IY
0B188C 18 F7       2002**  			JR      SPAN
0B188E             2003**  ;
0B188E             2004**  ; This snippet is used to check whether an expression is followed by an '=' symbol
0B188E             2005**  ;
0B188E CD 6E 0B 0B 2006**  EQUALS:			CALL    NXT			; Skip whitespace
0B1892 FD 23       2007**  			INC     IY			; Skip past the character in question
0B1894 FE 3D       2008**  			CP      '='			; Is it '='
0B1896 C8          2009**  			RET     Z			; Yes, so return
0B1897 3E 04       2010**  			LD      A,4			; Otherwise
0B1899 C3 5E 38 0B 2011**  			JP      ERROR_           	; Throw error "Mistake"
0B189D             2012**  ;
0B189D FE 8A       2013**  FORMAT:			CP      TAB
0B189F 28 0D       2014**  			JR      Z,DOTAB
0B18A1 FE 89       2015**  			CP      SPC
0B18A3 28 40       2016**  			JR      Z,DOSPC
0B18A5 FE 27       2017**  			CP      '''
0B18A7 C0          2018**  			RET     NZ
0B18A8 CD 45 3A 0B 2019**  			CALL    CRLF
0B18AC AF          2020**  			XOR     A
0B18AD C9          2021**  			RET
0B18AE             2022**  ;
0B18AE C5          2023**  DOTAB:			PUSH    BC
0B18AF CD 08 04 0B 2024**  			CALL    EXPRI
0B18B3 D9          2025**  			EXX
0B18B4 C1          2026**  			POP     BC
0B18B5 FD 7E 00    2027**  			LD      A,(IY)
0B18B8 FE 2C       2028**  			CP      ','
0B18BA 28 14       2029**  			JR      Z,DOTAB1
0B18BC CD 2D 0B 0B 2030**  			CALL    BRAKET
0B18C0 7D          2031**  			LD      A,L
0B18C1 21 3D 4E 0B 2032**  TABIT:			LD      HL,COUNT
0B18C5 BE          2033**  			CP      (HL)
0B18C6 C8          2034**  			RET     Z
0B18C7 F5          2035**  			PUSH    AF
0B18C8 DC 45 3A 0B 2036**  			CALL    C,CRLF
0B18CC F1          2037**  			POP     AF
0B18CD 96          2038**  			SUB     (HL)
0B18CE 18 1D       2039**  			JR      FILL
0B18D0 FD 23       2040**  DOTAB1:			INC     IY
0B18D2 C5          2041**  			PUSH    BC
0B18D3 E5          2042**  			PUSH    HL
0B18D4 CD 08 04 0B 2043**  			CALL    EXPRI
0B18D8 D9          2044**  			EXX
0B18D9 D1          2045**  			POP     DE
0B18DA C1          2046**  			POP     BC
0B18DB CD 2D 0B 0B 2047**  			CALL    BRAKET
0B18DF CD BF 3F 0B 2048**  			CALL    PUTCSR
0B18E3 AF          2049**  			XOR     A
0B18E4 C9          2050**  			RET
0B18E5             2051**  ;
0B18E5 C5          2052**  DOSPC:			PUSH    BC
0B18E6 CD 23 04 0B 2053**  			CALL    ITEMI
0B18EA D9          2054**  			EXX
0B18EB 7D          2055**  			LD      A,L
0B18EC C1          2056**  			POP     BC
0B18ED B7          2057**  FILL:			OR      A
0B18EE C8          2058**  			RET     Z
0B18EF C5          2059**  			PUSH    BC
0B18F0 47          2060**  			LD      B,A
0B18F1 3E 20       2061**  FILL1:			LD      A,' '
0B18F3 CD 4D 3A 0B 2062**  			CALL    OUTCHR
0B18F7 10 F8       2063**  			DJNZ    FILL1
0B18F9 C1          2064**  			POP     BC
0B18FA AF          2065**  			XOR     A
0B18FB C9          2066**  			RET
0B18FC             2067**  ;
0B18FC 21 00 4B 0B 2068**  PTEXT:			LD      HL,ACCS
0B1900 1C          2069**  			INC     E
0B1901 1D          2070**  PTEXT1:			DEC     E
0B1902 C8          2071**  			RET     Z
0B1903 7E          2072**  			LD      A,(HL)
0B1904 23          2073**  			INC     HL
0B1905 CD 4D 3A 0B 2074**  			CALL    OUTCHR
0B1909 18 F6       2075**  			JR      PTEXT1
0B190B             2076**  ;
0B190B F5          2077**  FETCHS:			PUSH    AF
0B190C C5          2078**  			PUSH    BC
0B190D E5          2079**  			PUSH    HL
0B190E FD E3       2080**  			EX      (SP),IY
0B1910 CD 2B 19 0B 2081**  			CALL    XTRACT
0B1914 CD 6E 0B 0B 2082**  			CALL    NXT
0B1918 FD E3       2083**  			EX      (SP),IY
0B191A E1          2084**  			POP     HL
0B191B C1          2085**  			POP     BC
0B191C F1          2086**  			POP     AF
0B191D C9          2087**  			RET
0B191E             2088**  ;
0B191E 11 00 4B 0B 2089**  LINES:			LD      DE,ACCS
0B1922 7E          2090**  LINE1S:			LD      A,(HL)
0B1923 12          2091**  			LD      (DE),A
0B1924 FE 0D       2092**  			CP      CR
0B1926 C8          2093**  			RET     Z
0B1927 23          2094**  			INC     HL
0B1928 1C          2095**  			INC     E
0B1929 18 F7       2096**  			JR      LINE1S
0B192B             2097**  ;
0B192B CD 6E 0B 0B 2098**  XTRACT:			CALL    NXT
0B192F FE 22       2099**  			CP      '"'
0B1931 FD 23       2100**  			INC     IY
0B1933 CA 65 05 0B 2101**  			JP      Z,CONS
0B1937 FD 2B       2102**  			DEC     IY
0B1939 11 00 4B 0B 2103**  			LD      DE,ACCS
0B193D FD 7E 00    2104**  XTRAC1:			LD      A,(IY)
0B1940 12          2105**  			LD      (DE),A
0B1941 FE 2C       2106**  			CP      ','
0B1943 C8          2107**  			RET     Z
0B1944 FE 0D       2108**  			CP      CR
0B1946 C8          2109**  			RET     Z
0B1947 FD 23       2110**  			INC     IY
0B1949 1C          2111**  			INC     E
0B194A 18 F1       2112**  			JR      XTRAC1
0B194C             2113**  
0B194C             2114**  ; Search for a token at the start of a program line
0B194C             2115**  ; - HL: Pointer to the start of a tokenised line in the program area
0B194C             2116**  ; Returns:
0B194C             2117**  ; - HL: Pointer to the
0B194C             2118**  ; -  F: Carry set if not found
0B194C             2119**  ; Corrupts:
0B194C             2120**  ; - BC
0B194C             2121**  ;
0B194C 01 00 00 00 2122**  SEARCH_EX:			LD      BC,0			; Clear BC
0B1950             2123**  ;
0B1950 4E          2124**  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
0B1951 0C          2125**  			INC     C			; Check for 0, i.e. end of program marker
0B1952 0D          2126**  			DEC     C
0B1953 28 0B       2127**  			JR      Z,SRCH2_EX         	; Not found the token, so end
0B1955 23          2128**  			INC     HL			; Skip the line length and line number
0B1956 23          2129**  			INC     HL
0B1957 23          2130**  			INC     HL
0B1958 BE          2131**  			CP      (HL)			; Compare with the token
0B1959 C8          2132**  			RET     Z			; Found it, so return with carry not set
0B195A 0D          2133**  			DEC     C			; Skip to the next line
0B195B 0D          2134**  			DEC     C
0B195C 0D          2135**  			DEC     C
0B195D 09          2136**  			ADD     HL,BC
0B195E 18 F0       2137**  			JR      SRCH1_EX			; Rinse, lather and repeat
0B1960             2138**  ;
0B1960 2B          2139**  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0B1961 37          2140**  			SCF				; And set the carry flag
0B1962 C9          2141**  			RET
0B1963             2142**  
0B1963             2143**  ; Multiply by 4 or 5
0B1963             2144**  ; This function is used to allocate space for dimensioned variables
0B1963             2145**  ; This is a 24-bit operation
0B1963             2146**  ; - DE: Number to multiple
0B1963             2147**  ; -  A: 04h (Integer) - takes up 4 bytes
0B1963             2148**  ;       05h (Float)   - takes up 5 bytes
0B1963             2149**  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
0B1963             2150**  ; Returns:
0B1963             2151**  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
0B1963             2152**  ; -  F: Carry if overflow
0B1963             2153**  ; Corrupts:
0B1963             2154**  ; - HL
0B1963 FE 04       2155**  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0B1965             2156**  			; LD	HL,DE
0B1965 D5          2157**  			push de
0B1966 E1          2158**  			pop hl
0B1967 29          2159**  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0B1968 D8          2160**  			RET     C			; Exit if overflow
0B1969 29          2161**  			ADD     HL,HL			; Multiply by 2 again
0B196A D8          2162**  			RET     C			; Exit if overflow
0B196B EB          2163**  			EX      DE,HL			; DE: Product
0B196C C8          2164**  			RET     Z			; Exit if A = 4
0B196D 19          2165**  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0B196E EB          2166**  			EX      DE,HL			; DE: Product
0B196F C9          2167**  			RET
0B1970             2168**  
0B1970             2169**  ; 16-bit unsigned multiply
0B1970             2170**  ; - HL: Operand 1
0B1970             2171**  ; - BC: Operand 2
0B1970             2172**  ; Returns:
0B1970             2173**  ; - HL: Result
0B1970             2174**  ; -  F: C if overflow
0B1970             2175**  ;
0B1970 C5          2176**  MUL16:			PUSH	BC
0B1971 51          2177**  			LD	D, C			; Set up the registers for the multiplies
0B1972 5D          2178**  			LD	E, L
0B1973 69          2179**  			LD	L, C
0B1974 4B          2180**  			LD	C, E
0B1975 ED 6C       2181**  			MLT	HL			; HL = H * C (*256)
0B1977 ED 5C       2182**  			MLT	DE			; DE = L * C
0B1979 ED 4C       2183**  			MLT	BC			; BC = B * L (*256)
0B197B 09          2184**  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0B197C C1          2185**  			POP	BC
0B197D AF          2186**  			XOR	A
0B197E 9C          2187**  			SBC	H			; If H is not zero then it's an overflow
0B197F D8          2188**  			RET	C
0B1980 65          2189**  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0B1981 6F          2190**  			LD	L, A
0B1982 19          2191**  			ADD	HL, DE
0B1983 C9          2192**  			RET
0B1984             2193**  ;
0B1984 CD 6E 0B 0B 2194**  CHANEL:			CALL    NXT			; Skip whitespace
0B1988 FE 23       2195**  			CP      '#'			; Check for the '#' symbol
0B198A 3E 2D       2196**  			LD      A,45
0B198C C2 5E 38 0B 2197**  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0B1990 FD 23       2198**  CHNL:			INC     IY             		; Bump past the '#'
0B1992 CD 23 04 0B 2199**  			CALL    ITEMI			; Get the channel number
0B1996 D9          2200**  			EXX
0B1997 EB          2201**  			EX      DE,HL			; DE: The channel number
0B1998 C9          2202**  			RET
0B1999             2203**  
0B1999             2204**  ; ASSEMBLER -------------------------------------------------------------------
0B1999             2205**  
0B1999             2206**  ; Language independant control section:
0B1999             2207**  ;  Outputs: A=delimiter, carry set if syntax error.
0B1999             2208**  ;
0B1999 CD B3 1E 0B 2209**  ASSEM:			CALL    SKIP
0B199D FD 23       2210**  			INC     IY
0B199F FE 3A       2211**  			CP      ':'
0B19A1 28 F6       2212**  			JR      Z,ASSEM
0B19A3 FE 5D       2213**  			CP      ']'
0B19A5 C8          2214**  			RET     Z
0B19A6 FE 0D       2215**  			CP      CR
0B19A8 C8          2216**  			RET     Z
0B19A9 FD 2B       2217**  			DEC     IY
0B19AB DD 2A 40 4D 2218**  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       0B          
0B19B0 21 40 4E 0B 2219**  			LD      HL,LISTON
0B19B4 CB 76       2220**  			BIT     6,(HL)
0B19B6 28 05       2221**  			JR      Z,ASSEM0
0B19B8 DD 2A 3C 4D 2222**  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       0B          
0B19BD DD E5       2223**  ASSEM0:			PUSH    IX
0B19BF FD E5       2224**  			PUSH    IY
0B19C1 CD 71 1A 0B 2225**  			CALL    ASMB
0B19C5 C1          2226**  			POP     BC
0B19C6 D1          2227**  			POP     DE
0B19C7 D8          2228**  			RET     C
0B19C8 CD B3 1E 0B 2229**  			CALL    SKIP
0B19CC 37          2230**  			SCF
0B19CD C0          2231**  			RET     NZ
0B19CE FD 2B       2232**  			DEC     IY
0B19D0 FD 23       2233**  ASSEM3:			INC     IY
0B19D2 FD 7E 00    2234**  			LD      A,(IY)
0B19D5 CD 7F 18 0B 2235**  			CALL    TERM0
0B19D9 20 F5       2236**  			JR      NZ,ASSEM3
0B19DB 3A 40 4E 0B 2237**  			LD      A,(LISTON)
0B19DF DD E5       2238**  			PUSH    IX
0B19E1 E1          2239**  			POP     HL
0B19E2 B7          2240**  			OR      A
0B19E3 ED 52       2241**  			SBC     HL,DE
0B19E5 EB          2242**  			EX      DE,HL           	; DE: Number of bytes
0B19E6 E5          2243**  			PUSH    HL
0B19E7 2A 40 4D 0B 2244**  			LD      HL,(PC)
0B19EB E5          2245**  			PUSH    HL
0B19EC 19          2246**  			ADD     HL,DE
0B19ED 22 40 4D 0B 2247**  			LD      (PC),HL         	; Update PC
0B19F1 CB 77       2248**  			BIT     6,A
0B19F3 28 09       2249**  			JR      Z,ASSEM5
0B19F5 2A 3C 4D 0B 2250**  			LD      HL,(OC)
0B19F9 19          2251**  			ADD     HL,DE
0B19FA 22 3C 4D 0B 2252**  			LD      (OC),HL         	; Update OC
0B19FE E1          2253**  ASSEM5:			POP     HL              	; Old PC
0B19FF DD E1       2254**  			POP     IX              	; Code here
0B1A01 CB 67       2255**  			BIT     4,A
0B1A03 28 94       2256**  			JR      Z,ASSEM
0B1A05 22 4A 4E 0B 2257**  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
0B1A09 3A 4C 4E 0B 2258**  			LD	A,(R0+2)		; Print out the address
0B1A0D CD 5B 1A 0B 2259**  			CALL	HEX_EX
0B1A11 7C          2260**  			LD      A,H
0B1A12 CD 5B 1A 0B 2261**  			CALL    HEX_EX
0B1A16 7D          2262**  			LD      A,L
0B1A17 CD 53 1A 0B 2263**  			CALL    HEXSP
0B1A1B AF          2264**  			XOR     A
0B1A1C BB          2265**  			CP      E
0B1A1D 28 18       2266**  			JR      Z,ASSEM2
0B1A1F             2267**  ;
0B1A1F 3A 3D 4E 0B 2268**  ASSEM1:			LD      A,(COUNT)
0B1A23 FE 14       2269**  			CP      20
0B1A25 3E 07       2270**  			LD      A,7
0B1A27 D4 C1 18 0B 2271**  			CALL    NC,TABIT        	; Next line
0B1A2B DD 7E 00    2272**  			LD      A,(IX)
0B1A2E CD 53 1A 0B 2273**  			CALL    HEXSP
0B1A32 DD 23       2274**  			INC     IX
0B1A34 1D          2275**  			DEC     E
0B1A35 20 E8       2276**  			JR      NZ,ASSEM1
0B1A37             2277**  ;
0B1A37 3E 16       2278**  ASSEM2:			LD      A,22			; Tab to the disassembly field
0B1A39 CD C1 18 0B 2279**  			CALL    TABIT
0B1A3D FD E5       2280**  			PUSH    IY
0B1A3F E1          2281**  			POP     HL
0B1A40 ED 42       2282**  			SBC     HL,BC
0B1A42 0A          2283**  ASSEM4:			LD      A,(BC)
0B1A43 CD 6A 3A 0B 2284**  			CALL    OUT_
0B1A47 03          2285**  			INC     BC
0B1A48 2D          2286**  			DEC     L
0B1A49 20 F7       2287**  			JR      NZ,ASSEM4
0B1A4B CD 45 3A 0B 2288**  			CALL    CRLF
0B1A4F C3 99 19 0B 2289**  			JP      ASSEM
0B1A53             2290**  ;
0B1A53 CD 5B 1A 0B 2291**  HEXSP:			CALL    HEX_EX
0B1A57 3E 20       2292**  			LD      A,' '
0B1A59 18 12       2293**  			JR      OUTCH1
0B1A5B F5          2294**  HEX_EX:			PUSH    AF
0B1A5C 0F          2295**  			RRCA
0B1A5D 0F          2296**  			RRCA
0B1A5E 0F          2297**  			RRCA
0B1A5F 0F          2298**  			RRCA
0B1A60 CD 65 1A 0B 2299**  			CALL    HEXOUT
0B1A64 F1          2300**  			POP     AF
0B1A65 E6 0F       2301**  HEXOUT:			AND     0FH
0B1A67 C6 90       2302**  			ADD     A,90H
0B1A69 27          2303**  			DAA
0B1A6A CE 40       2304**  			ADC     A,40H
0B1A6C 27          2305**  			DAA
0B1A6D C3 6A 3A 0B 2306**  OUTCH1:			JP      OUT_
0B1A71             2307**  
0B1A71             2308**  ; Processor Specific Translation Section:
0B1A71             2309**  ;
0B1A71             2310**  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0B1A71             2311**  ;                 C: Opcode beig built
0B1A71             2312**  ;                 D: Flags
0B1A71             2313**  ;			Bit 7: Set to 1 if the instruction uses long addressing
0B1A71             2314**  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0B1A71             2315**  ;                 E: Offset from IX or IY
0B1A71             2316**  ;                HL: Numeric operand value
0B1A71             2317**  ;                IX: Code destination pointer
0B1A71             2318**  ;                IY: Source text pointer
0B1A71             2319**  ;    Inputs: A = initial character
0B1A71             2320**  ;   Outputs: Carry set if syntax error.
0B1A71             2321**  ;
0B1A71 FE 2E       2322**  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0B1A73 20 1F       2323**  			JR      NZ,ASMB1		; No, so just process the instruction
0B1A75 FD 23       2324**  			INC     IY			; Skip past the dot to the label name
0B1A77 DD E5       2325**  			PUSH    IX			; Store the code destination pointer
0B1A79 CD 8C 0D 0B 2326**  			CALL    VAR_			; Create a variable
0B1A7D F5          2327**  			PUSH    AF
0B1A7E CD 91 0A 0B 2328**  			CALL    ZERO			; Zero it
0B1A82 3A 42 4D 0B 2329**  			LD	A,(PC+2)
0B1A86 6F          2330**  			LD	L,A			; The MSB of the 24-bit address
0B1A87 D9          2331**  			EXX
0B1A88 2A 40 4D 0B 2332**  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0B1A8C D9          2333**  			EXX
0B1A8D F1          2334**  			POP     AF
0B1A8E CD D4 16 0B 2335**  			CALL    STORE			; Store the program counter
0B1A92 DD E1       2336**  			POP     IX			; Restore the code destination pointer
0B1A94             2337**  ;
0B1A94 3A 40 4E 0B 2338**  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0B1A98 E6 80       2339**  			AND	80H
0B1A9A 57          2340**  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0B1A9B CD B3 1E 0B 2341**  			CALL    SKIP			; Skip any whitespace
0B1A9F C8          2342**  			RET     Z			; And return if there is nothing further to process
0B1AA0 FE D6       2343**  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0B1AA2 0E C4       2344**  			LD      C,0C4H			;  A: The base operand
0B1AA4 FD 23       2345**  			INC     IY			; Skip past the token
0B1AA6 CA E8 1B 0B 2346**  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0B1AAA FD 2B       2347**  			DEC     IY			; Skip back, as we're not doing the above at this point
0B1AAC 21 CA 1E 0B 2348**  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0B1AB0 CD 62 1E 0B 2349**  			CALL    FIND			; Find the opcode
0B1AB4 D8          2350**  			RET     C			; If not found, then return; carry indicates an error condition
0B1AB5 48          2351**  			LD      C,B     		;  C: A copy of the opcode
0B1AB6             2352**  ;
0B1AB6             2353**  ; GROUP 0: Trivial cases requiring no computation
0B1AB6             2354**  ; GROUP 1: As Group 0, but with "ED" prefix
0B1AB6             2355**  ;
0B1AB6 D6 44       2356**  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0B1AB8 30 08       2357**  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0B1ABA FE CB       2358**  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0B1ABC D4 BB 1D 0B 2359**  			CALL    NC,ED			; Needs to be prefixed with ED
0B1AC0 18 76       2360**  			JR      BYTE0			; Then write the opcode byte
0B1AC2             2361**  ;
0B1AC2             2362**  ; GROUP 2: BIT, RES, SET
0B1AC2             2363**  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0B1AC2             2364**  ;
0B1AC2 D6 0A       2365**  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0B1AC4 30 12       2366**  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0B1AC6 FE F9       2367**  			CP      3-10			;
0B1AC8 DC 50 1E 0B 2368**  			CALL    C,BIT_
0B1ACC D8          2369**  			RET     C
0B1ACD CD 21 1E 0B 2370**  			CALL    REGLO
0B1AD1 D8          2371**  			RET     C
0B1AD2 CD BF 1D 0B 2372**  			CALL    CB
0B1AD6 18 60       2373**  			JR      BYTE0
0B1AD8             2374**  ;
0B1AD8             2375**  ; GROUP 4 - PUSH, POP, EX (SP)
0B1AD8             2376**  ;
0B1AD8 D6 03       2377**  GROUP04:		SUB     3			; The number of opcodes in GROUP4
0B1ADA 30 07       2378**  			JR      NC,GROUP05		; If not in that range, then check GROUP5
0B1ADC CD 43 1E 0B 2379**  GROUP04_1:		CALL    PAIR_EX
0B1AE0 D8          2380**  			RET     C
0B1AE1 18 55       2381**  			JR      BYTE0
0B1AE3             2382**  ;
0B1AE3             2383**  ; GROUP 5 - SUB, AND, XOR, OR, CP
0B1AE3             2384**  ; GROUP 6 - ADD, ADC, SBC
0B1AE3             2385**  ;
0B1AE3 D6 0A       2386**  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0B1AE5 30 39       2387**  			JR      NC,GROUP07
0B1AE7 FE FD       2388**  			CP      5-8
0B1AE9 06 07       2389**  			LD      B,7
0B1AEB D4 CF 1D 0B 2390**  			CALL    NC,OPND			; Get the first operand
0B1AEF 78          2391**  			LD      A,B
0B1AF0 FE 07       2392**  			CP      7			; Is the operand 'A'?
0B1AF2 20 15       2393**  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0B1AF4             2394**  ;
0B1AF4 CD 21 1E 0B 2395**  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0B1AF8 79          2396**  			LD      A,C
0B1AF9 30 2E       2397**  			JR      NC,BIND1		; If it is a register, then write that out
0B1AFB EE 46       2398**  			XOR     46H			; Handle ADD A,n
0B1AFD CD C1 1D 0B 2399**  			CALL    BIND
0B1B01 CD 01 1E 0B 2400**  DB_:			CALL    NUMBER
0B1B05 C3 BA 1B 0B 2401**  			JP      VAL8
0B1B09             2402**  ;
0B1B09 E6 3F       2403**  GROUP05_HL:		AND     3FH
0B1B0B FE 0C       2404**  			CP      12
0B1B0D 37          2405**  			SCF
0B1B0E C0          2406**  			RET     NZ
0B1B0F 79          2407**  			LD      A,C
0B1B10 FE 80       2408**  			CP      80H
0B1B12 0E 09       2409**  			LD      C,9
0B1B14 28 C6       2410**  			JR      Z,GROUP04_1
0B1B16 EE 1C       2411**  			XOR     1CH
0B1B18 0F          2412**  			RRCA
0B1B19 4F          2413**  			LD      C,A
0B1B1A CD BB 1D 0B 2414**  			CALL    ED
0B1B1E 18 BC       2415**  			JR      GROUP04_1
0B1B20             2416**  ;
0B1B20             2417**  ; GROUP 7 - INC, DEC
0B1B20             2418**  ;
0B1B20 D6 02       2419**  GROUP07:		SUB     2			; The number of opcodes in GROUP7
0B1B22 30 19       2420**  			JR      NC,GROUP08
0B1B24 CD 28 1E 0B 2421**  			CALL    REGHI
0B1B28 79          2422**  			LD      A,C
0B1B29 D2 C1 1D 0B 2423**  BIND1:			JP      NC,BIND
0B1B2D EE 64       2424**  			XOR     64H
0B1B2F 07          2425**  			RLCA
0B1B30 07          2426**  			RLCA
0B1B31 07          2427**  			RLCA
0B1B32 4F          2428**  			LD      C,A
0B1B33 CD 48 1E 0B 2429**  			CALL    PAIR1_EX
0B1B37 D8          2430**  			RET     C
0B1B38 79          2431**  BYTE0:			LD      A,C
0B1B39 C3 F0 1D 0B 2432**  			JP      BYTE_
0B1B3D             2433**  ;
0B1B3D             2434**  ; Group 8: IN0, OUT0
0B1B3D             2435**  ;
0B1B3D D6 02       2436**  GROUP08:		SUB	2			; The number of opcodes in GROUP8
0B1B3F 30 26       2437**  			JR	NC,GROUP09
0B1B41 FE FF       2438**  			CP	1-2
0B1B43 CC 01 1E 0B 2439**  			CALL    Z,NUMBER		; Fetch number first if OUT
0B1B47 08          2440**  			EX      AF,AF'			; Save flags
0B1B48 CD 15 1E 0B 2441**  			CALL    REG			; Get the register value regardless
0B1B4C D8          2442**  			RET     C			; Return if not a register
0B1B4D 08          2443**  			EX      AF,AF'			; Restore the flags
0B1B4E DC 01 1E 0B 2444**  			CALL    C,NUMBER		; Fetch number last if IN
0B1B52 78          2445**  			LD	A,B			; Get the register number
0B1B53 FE 06       2446**  			CP	6			; Fail on (HL)
0B1B55 37          2447**  			SCF
0B1B56 C8          2448**  			RET	Z
0B1B57 FE 08       2449**  			CP	8			; Check it is just single pairs only
0B1B59 3F          2450**  			CCF
0B1B5A D8          2451**  			RET	C			; And return if it is an invalid register
0B1B5B 07          2452**  			RLCA				; Bind with the operand
0B1B5C 07          2453**  			RLCA
0B1B5D 07          2454**  			RLCA
0B1B5E 81          2455**  			ADD	A,C
0B1B5F             2456**  ; BEGIN NOT IN BINARY
0B1B5F             2457**  			; LD	C,A
0B1B5F             2458**  			; CALL	ED			; Prefix with ED
0B1B5F             2459**  			; LD	A,C
0B1B5F             2460**  ; END NOT IN BINARY
0B1B5F CD F0 1D 0B 2461**  			CALL	BYTE_			; Write out the operand
0B1B63 C3 BA 1B 0B 2462**  			JP	VAL8			; Write out the value
0B1B67             2463**  ;
0B1B67             2464**  ; GROUP 9 - IN
0B1B67             2465**  ; GROUP 10 - OUT
0B1B67             2466**  ;
0B1B67 D6 02       2467**  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
0B1B69 30 25       2468**  			JR      NC,GROUP11
0B1B6B FE FF       2469**  			CP      1-2			; Check if Group 9 or Group 1
0B1B6D CC AF 1D 0B 2470**  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
0B1B71 08          2471**  			EX      AF,AF'			; Save flags
0B1B72 CD 28 1E 0B 2472**  			CALL    REGHI			; Get the register value regardless
0B1B76 D8          2473**  			RET     C			; Return if not a register
0B1B77 08          2474**  			EX      AF,AF'			; Restore the flags
0B1B78 DC AF 1D 0B 2475**  			CALL    C,CORN			; Call CORN if Group 9 (IN)
0B1B7C 24          2476**  			INC     H			; If it is IN r,(C) or OUT (C),r then
0B1B7D 28 B9       2477**  			JR      Z,BYTE0			; Just write the operand out
0B1B7F             2478**  ;
0B1B7F 78          2479**  			LD      A,B			; Check the register
0B1B80 FE 07       2480**  			CP      7
0B1B82 37          2481**  			SCF
0B1B83 C0          2482**  			RET     NZ			; If it is not A, then return
0B1B84             2483**  ;
0B1B84 79          2484**  			LD      A,C			; Bind the register with the operand
0B1B85 EE 03       2485**  			XOR     3
0B1B87 07          2486**  			RLCA
0B1B88 07          2487**  			RLCA
0B1B89 07          2488**  			RLCA
0B1B8A CD F0 1D 0B 2489**  			CALL    BYTE_			; Write out the operand
0B1B8E 18 2A       2490**  			JR      VAL8			; And the value
0B1B90             2491**  ;
0B1B90             2492**  ; GROUP 11 - JR, DJNZ
0B1B90             2493**  ;
0B1B90 D6 02       2494**  GROUP11:		SUB     2			; The number of opcodes in GROUP11
0B1B92 30 2B       2495**  			JR      NC,GROUP12
0B1B94 FE FF       2496**  			CP      1-2
0B1B96 C4 2F 1E 0B 2497**  			CALL    NZ,COND_
0B1B9A 79          2498**  			LD      A,C
0B1B9B 30 02       2499**  			JR      NC,@F
0B1B9D 3E 18       2500**  			LD      A,18H
0B1B9F CD F0 1D 0B 2501**  @@:			CALL    BYTE_
0B1BA3 CD 01 1E 0B 2502**  			CALL    NUMBER
0B1BA7 ED 5B 40 4D 2503**  			LD      DE,(PC)
       0B          
0B1BAC 13          2504**  			INC     DE
0B1BAD 37          2505**  			SCF
0B1BAE ED 52       2506**  			SBC     HL,DE
0B1BB0 7D          2507**  			LD      A,L
0B1BB1 17          2508**  			RLA
0B1BB2 9F          2509**  			SBC     A,A
0B1BB3 BC          2510**  			CP      H
0B1BB4 3E 01       2511**  TOOFAR:			LD      A,1
0B1BB6 C2 5E 38 0B 2512**  			JP      NZ,ERROR_		; Throw an "Out of range" error
0B1BBA 7D          2513**  VAL8:			LD      A,L
0B1BBB C3 F0 1D 0B 2514**  			JP      BYTE_
0B1BBF             2515**  ;
0B1BBF             2516**  ; GROUP 12 - JP
0B1BBF             2517**  ;
0B1BBF D6 01       2518**  GROUP12:		SUB	1			; The number of opcodes in GROUP12
0B1BC1 30 21       2519**  			JR	NC,GROUP13
0B1BC3 CD 15 1D 0B 2520**  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
0B1BC7 D8          2521**  			RET	C			; Exit if an invalid suffix is provided
0B1BC8 CD 2F 1E 0B 2522**  			CALL    COND_			; Evaluate the conditions
0B1BCC 79          2523**  			LD      A,C
0B1BCD 30 0D       2524**  			JR      NC,GROUP12_1
0B1BCF 78          2525**  			LD      A,B
0B1BD0 E6 3F       2526**  			AND     3FH
0B1BD2 FE 06       2527**  			CP      6
0B1BD4 3E E9       2528**  			LD      A,0E9H
0B1BD6 CA F0 1D 0B 2529**  			JP      Z,BYTE_
0B1BDA 3E C3       2530**  			LD      A,0C3H
0B1BDC CD F0 1D 0B 2531**  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
0B1BE0 C3 6A 1D 0B 2532**  			JP	ADDR_			; Output the address
0B1BE4             2533**  ;
0B1BE4             2534**  ; GROUP 13 - CALL
0B1BE4             2535**  ;
0B1BE4 D6 01       2536**  GROUP13:		SUB	1			; The number of opcodes in GROUP13
0B1BE6 30 0C       2537**  			JR	NC,GROUP14
0B1BE8 CD 2D 1D 0B 2538**  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
0B1BEC CD 0F 1C 0B 2539**  			CALL    GROUP15_1		; Output the opcode (with conditions)
0B1BF0 C3 6A 1D 0B 2540**  			JP	ADDR_			; Output the address
0B1BF4             2541**  ;
0B1BF4             2542**  ; GROUP 14 - RST
0B1BF4             2543**  ;
0B1BF4 D6 01       2544**  GROUP14:		SUB	1			; The number of opcodes in GROUP14
0B1BF6 30 13       2545**  			JR	NC,GROUP15
0B1BF8 CD 2D 1D 0B 2546**  			CALL	EZ80SF_FULL		; Evaluate the suffix
0B1BFC D8          2547**  			RET	C			; Exit if an invalid suffix provided
0B1BFD CD 01 1E 0B 2548**  			CALL    NUMBER
0B1C01 A1          2549**  			AND     C
0B1C02 B4          2550**  			OR      H
0B1C03 20 AF       2551**  			JR      NZ,TOOFAR
0B1C05 7D          2552**  			LD      A,L
0B1C06 B1          2553**  			OR      C
0B1C07 C3 F0 1D 0B 2554**  	  		JP      BYTE_
0B1C0B             2555**  ;
0B1C0B             2556**  ; GROUP 15 - RET
0B1C0B             2557**  ;
0B1C0B D6 01       2558**  GROUP15:		SUB	1			; The number of opcodes in GROUP15
0B1C0D 30 0F       2559**  			JR	NC,GROUP16
0B1C0F CD 2F 1E 0B 2560**  GROUP15_1:		CALL    COND_
0B1C13 79          2561**  			LD      A,C
0B1C14 D2 F0 1D 0B 2562**  			JP      NC,BYTE_
0B1C18 F6 09       2563**  			OR      9
0B1C1A C3 F0 1D 0B 2564**  			JP      BYTE_
0B1C1E             2565**  ;
0B1C1E             2566**  ; GROUP 16 - LD
0B1C1E             2567**  ;
0B1C1E D6 01       2568**  GROUP16:		SUB	1			; The number of opcodes in GROUP16
0B1C20 30 74       2569**  			JR	NC,GROUP17
0B1C22 CD 2D 1D 0B 2570**  			CALL	EZ80SF_FULL		; Evaluate the suffix
0B1C26 CD 5E 1E 0B 2571**  			CALL    LDOP			; Check for accumulator loads
0B1C2A D2 8A 1D 0B 2572**  			JP      NC,LDA			; Yes, so jump here
0B1C2E CD 28 1E 0B 2573**  			CALL    REGHI
0B1C32 08          2574**  			EX      AF,AF'
0B1C33 CD B3 1E 0B 2575**  			CALL    SKIP
0B1C37 FE 28       2576**  			CP      '('			; Check for bracket
0B1C39 28 24       2577**  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
0B1C3B 08          2578**  			EX      AF,AF'
0B1C3C D2 F4 1A 0B 2579**  			JP      NC,GROUP05_1		; Load single register direct; go here
0B1C40 0E 01       2580**  			LD      C,1
0B1C42 CD 48 1E 0B 2581**  			CALL    PAIR1_EX
0B1C46 D8          2582**  			RET     C
0B1C47 3E 0E       2583**  			LD      A,14
0B1C49 B8          2584**  			CP      B
0B1C4A 47          2585**  			LD      B,A
0B1C4B CC 43 1E 0B 2586**  			CALL    Z,PAIR_EX
0B1C4F 78          2587**  			LD      A,B
0B1C50 E6 3F       2588**  			AND     3FH
0B1C52 FE 0C       2589**  			CP      12
0B1C54 79          2590**  			LD      A,C
0B1C55 C2 DC 1B 0B 2591**  			JP      NZ,GROUP12_1		; Load register pair direct; go here
0B1C59 3E F9       2592**  			LD      A,0F9H
0B1C5B C3 F0 1D 0B 2593**  			JP      BYTE_
0B1C5F             2594**  ;
0B1C5F 08          2595**  LDIN:			EX      AF,AF'
0B1C60 C5          2596**  			PUSH    BC
0B1C61 D4 21 1E 0B 2597**  			CALL    NC,REGLO
0B1C65 79          2598**  			LD      A,C
0B1C66 C1          2599**  			POP     BC
0B1C67 D2 C1 1D 0B 2600**  			JP      NC,BIND
0B1C6B 0E 0A       2601**  			LD      C,0AH
0B1C6D CD 48 1E 0B 2602**  			CALL    PAIR1_EX
0B1C71 CD 95 1D 0B 2603**  			CALL    LD16
0B1C75 D2 DC 1B 0B 2604**  			JP      NC,GROUP12_1
0B1C79 CD 01 1E 0B 2605**  			CALL    NUMBER
0B1C7D 0E 02       2606**  			LD      C,2
0B1C7F CD 43 1E 0B 2607**  			CALL    PAIR_EX
0B1C83 CD 95 1D 0B 2608**  			CALL    LD16
0B1C87 D8          2609**  			RET     C
0B1C88 CD F0 1D 0B 2610**  			CALL    BYTE_
0B1C8C CB 7A       2611**  			BIT	7,D			; Check the ADL flag
0B1C8E C2 7F 1D 0B 2612**  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
0B1C92 C3 72 1D 0B 2613**  			JP      VAL16			; Otherwise use 16-bit addresses
0B1C96             2614**  ;
0B1C96             2615**  ; Group 17 - TST
0B1C96             2616**  ;
0B1C96 D6 01       2617**  GROUP17:		SUB	1			; The number of opcodes in GROUP17
0B1C98 30 25       2618**  			JR	NC,OPTS
0B1C9A CD BB 1D 0B 2619**  			CALL	ED			; Needs to be prefixed with ED
0B1C9E CD 15 1E 0B 2620**  			CALL	REG			; Fetch the register
0B1CA2 30 0E       2621**  			JR	NC,GROUP17_1		; It's just a register
0B1CA4             2622**  ;
0B1CA4 3E 64       2623**  			LD	A,64H			; Opcode for TST n
0B1CA6 CD F0 1D 0B 2624**  			CALL	BYTE_			; Write out the opcode
0B1CAA CD 01 1E 0B 2625**  			CALL	NUMBER			; Get the number
0B1CAE C3 BA 1B 0B 2626**  			JP	VAL8			; And write that out
0B1CB2             2627**  ;
0B1CB2 78          2628**  GROUP17_1:		LD	A,B			; Check the register rangs
0B1CB3 FE 08       2629**  			CP	8
0B1CB5 3F          2630**  			CCF
0B1CB6 D8          2631**  			RET	C			; Ret with carry flag set for error if out of range
0B1CB7 07          2632**  			RLCA				; Get the opcode value
0B1CB8 07          2633**  			RLCA
0B1CB9 07          2634**  			RLCA
0B1CBA 81          2635**  			ADD	A,C			; Add the opcode base in
0B1CBB C3 F0 1D 0B 2636**  			JP	BYTE_
0B1CBF             2637**  
0B1CBF             2638**  ;
0B1CBF             2639**  ; Assembler directives - OPT, ADL
0B1CBF             2640**  ;
0B1CBF D6 02       2641**  OPTS:			SUB	2
0B1CC1 30 2B       2642**  			JR	NC, DEFS
0B1CC3 FE FF       2643**  			CP	1-2			; Check for ADL opcode
0B1CC5 28 13       2644**  			JR	Z, ADL_
0B1CC7             2645**  ;
0B1CC7 CD 01 1E 0B 2646**  OPT:			CALL    NUMBER			; Fetch the OPT value
0B1CCB 21 40 4E 0B 2647**  			LD      HL,LISTON		; Address of the LISTON/OPT flag
0B1CCF E6 07       2648**  			AND	7			; Only interested in the first three bits
0B1CD1 4F          2649**  			LD      C,A			; Store the new OPT value in C
0B1CD2 ED 6F       2650**  			RLD				; Shift the top nibble of LISTON (OPT) into A
0B1CD4 E6 08       2651**  			AND	8			; Clear the bottom three bits, preserving the ADL bit
0B1CD6 B1          2652**  			OR	C			; OR in the new value
0B1CD7 ED 67       2653**  			RRD				; And shift the nibble back in
0B1CD9 C9          2654**  			RET
0B1CDA             2655**  ;
0B1CDA CD 01 1E 0B 2656**  ADL_:			CALL	NUMBER			; Fetch the ADL value
0B1CDE E6 01       2657**  			AND	1			; Only interested if it is 0 or 1
0B1CE0 0F          2658**  			RRCA				; Rotate to bit 7
0B1CE1 4F          2659**  			LD	C,A			; Store in C
0B1CE2 3A 40 4E 0B 2660**  			LD	A,(LISTON)		; Get the LISTON system variable
0B1CE6 E6 7F       2661**  			AND	7Fh			; Clear bit 7
0B1CE8 B1          2662**  			OR	C			; OR in the ADL value
0B1CE9 32 40 4E 0B 2663**  			LD	(LISTON),A		; Store
0B1CED C9          2664**  			RET
0B1CEE             2665**  ;
0B1CEE             2666**  ; DEFB, DEFW, DEFL, DEFM
0B1CEE             2667**  ;
0B1CEE B7          2668**  DEFS:			OR	A			; Handle DEFB
0B1CEF CA 01 1B 0B 2669**  			JP	Z, DB_
0B1CF3 3D          2670**  			DEC	A			; Handle DEFW
0B1CF4 CA 6E 1D 0B 2671**  			JP	Z, ADDR16
0B1CF8 3D          2672**  			DEC	A			; Handle DEFL
0B1CF9 CA 7B 1D 0B 2673**  			JP	Z, ADDR24
0B1CFD             2674**  ;
0B1CFD DD E5       2675**  			PUSH    IX			; Handle DEFM
0B1CFF CD 13 04 0B 2676**  			CALL    EXPRS
0B1D03 DD E1       2677**  			POP     IX
0B1D05 21 00 4B 0B 2678**  			LD      HL,ACCS
0B1D09 AF          2679**  @@:			XOR     A
0B1D0A BB          2680**  			CP      E
0B1D0B C8          2681**  			RET     Z
0B1D0C 7E          2682**  			LD      A,(HL)
0B1D0D 23          2683**  			INC     HL
0B1D0E CD F0 1D 0B 2684**  			CALL    BYTE_
0B1D12 1D          2685**  			DEC     E
0B1D13 18 F4       2686**  			JR      @B
0B1D15             2687**  
0B1D15             2688**  ;
0B1D15             2689**  ;SUBROUTINES:
0B1D15             2690**  ;
0B1D15 FD 7E 00    2691**  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
0B1D18 FE 2E       2692**  			CP	'.'
0B1D1A 28 02       2693**  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
0B1D1C B7          2694**  			OR	A			; Reset the carry flag (no error)
0B1D1D C9          2695**  			RET				; And return
0B1D1E FD 23       2696**  @@:			INC	IY			; Skip the dot
0B1D20 C5          2697**  			PUSH	BC			; Push the operand
0B1D21 21 49 21 0B 2698**  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
0B1D25 CD 62 1E 0B 2699**  			CALL	FIND			; Look up the operand
0B1D29 30 24       2700**  			JR	NC,EZ80SF_OK
0B1D2B C1          2701**  			POP	BC			; Not found at this point, so will return with a C (error)
0B1D2C C9          2702**  			RET
0B1D2D             2703**  ;
0B1D2D FD 7E 00    2704**  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
0B1D30 FE 2E       2705**  			CP	'.'
0B1D32 28 02       2706**  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
0B1D34 B7          2707**  			OR	A			; Reset the carry flag (no error)
0B1D35 C9          2708**  			RET				; And return
0B1D36 FD 23       2709**  @@:			INC	IY 			; Skip the dot
0B1D38 C5          2710**  			PUSH	BC			; Push the operand
0B1D39 21 41 21 0B 2711**  			LD	HL,EZ80SFS_1		; First check the fully qualified table
0B1D3D CD 62 1E 0B 2712**  			CALL	FIND 			; Look up the operand
0B1D41 30 0C       2713**  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
0B1D43 CD 5E 1D 0B 2714**  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
0B1D47 CD 62 1E 0B 2715**  			CALL	FIND
0B1D4B 30 02       2716**  			JR	NC,EZ80SF_OK
0B1D4D C1          2717**  			POP	BC			; Not found at this point, so will return with a C (error)
0B1D4E C9          2718**  			RET
0B1D4F             2719**  ;
0B1D4F 78          2720**  EZ80SF_OK:		LD	A,B			; The operand value
0B1D50 D4 F0 1D 0B 2721**  			CALL	NC,BYTE_ 		; Write it out if found
0B1D54 CB BA       2722**  			RES	7,D			; Clear the default ADL mode from the flags
0B1D56 E6 02       2723**  			AND	2			; Check the second half of the suffix (.xxL)
0B1D58 0F          2724**  			RRCA				; Shift into bit 7
0B1D59 0F          2725**  			RRCA
0B1D5A B2          2726**  			OR	D			; Or into bit 7 of D
0B1D5B 57          2727**  			LD	D,A
0B1D5C C1          2728**  			POP	BC 			; Restore the operand
0B1D5D C9          2729**  			RET
0B1D5E             2730**  ;
0B1D5E 21 52 21 0B 2731**  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
0B1D62 CB 7A       2732**  			BIT 	7,D			; if bit 7 of D is 0
0B1D64 C8          2733**  			RET	Z
0B1D65 21 5D 21 0B 2734**  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
0B1D69 C9          2735**  			RET
0B1D6A             2736**  ;
0B1D6A CB 7A       2737**  ADDR_:			BIT	7,D			; Check the ADL flag
0B1D6C 20 0D       2738**  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
0B1D6E             2739**  ;
0B1D6E CD 01 1E 0B 2740**  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
0B1D72 CD BA 1B 0B 2741**  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
0B1D76 7C          2742**  			LD      A,H
0B1D77 C3 F0 1D 0B 2743**  			JP      BYTE_
0B1D7B             2744**  ;
0B1D7B CD 01 1E 0B 2745**  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
0B1D7F CD 72 1D 0B 2746**  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
0B1D83 D9          2747**  			EXX
0B1D84 7D          2748**  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
0B1D85 D9          2749**  			EXX
0B1D86 C3 F0 1D 0B 2750**  			JP	BYTE_
0B1D8A             2751**  ;
0B1D8A FE 04       2752**  LDA:			CP      4
0B1D8C DC BB 1D 0B 2753**  			CALL    C,ED
0B1D90 78          2754**  			LD      A,B
0B1D91 C3 F0 1D 0B 2755**  			JP      BYTE_
0B1D95             2756**  ;
0B1D95 78          2757**  LD16:			LD      A,B
0B1D96 38 0F       2758**  			JR      C,LD8
0B1D98 78          2759**  			LD      A,B
0B1D99 E6 3F       2760**  			AND     3FH
0B1D9B FE 0C       2761**  			CP      12
0B1D9D 79          2762**  			LD      A,C
0B1D9E C8          2763**  			RET     Z
0B1D9F CD BB 1D 0B 2764**  			CALL    ED
0B1DA3 79          2765**  			LD      A,C
0B1DA4 F6 43       2766**  			OR      43H
0B1DA6 C9          2767**  			RET
0B1DA7             2768**  ;
0B1DA7 FE 07       2769**  LD8:			CP      7
0B1DA9 37          2770**  			SCF
0B1DAA C0          2771**  			RET     NZ
0B1DAB 79          2772**  			LD      A,C
0B1DAC F6 30       2773**  			OR      30H
0B1DAE C9          2774**  			RET
0B1DAF             2775**  ;
0B1DAF             2776**  ; Used in IN and OUT to handle whether the operand is C or a number
0B1DAF             2777**  ;
0B1DAF C5          2778**  CORN:			PUSH    BC
0B1DB0 CD CF 1D 0B 2779**  			CALL    OPND			; Get the operand
0B1DB4 CB 68       2780**  			BIT     5,B
0B1DB6 C1          2781**  			POP     BC
0B1DB7 28 48       2782**  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
0B1DB9 26 FF       2783**  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
0B1DBB             2784**  ;
0B1DBB 3E ED       2785**  ED:			LD      A,0EDH			; Write an ED prefix out
0B1DBD 18 31       2786**  			JR      BYTE_
0B1DBF             2787**  ;
0B1DBF 3E CB       2788**  CB:			LD      A,0CBH
0B1DC1 FE 76       2789**  BIND:			CP      76H
0B1DC3 37          2790**  			SCF
0B1DC4 C8          2791**  			RET     Z               	; Reject LD (HL),(HL)
0B1DC5 CD F0 1D 0B 2792**  			CALL    BYTE_
0B1DC9 CB 72       2793**  			BIT	6,D			; Check the index bit in flags
0B1DCB C8          2794**  			RET     Z
0B1DCC 7B          2795**  			LD      A,E			; If there is an index, output the offset
0B1DCD 18 21       2796**  			JR      BYTE_
0B1DCF             2797**  ;
0B1DCF             2798**  ; Search through the operand table
0B1DCF             2799**  ; Returns:
0B1DCF             2800**  ; - B: The operand type
0B1DCF             2801**  ; - D: Bit 7: 0 = no prefix, 1 = prefix
0B1DCF             2802**  ; - E: The IX/IY offset
0B1DCF             2803**  ; - F: Carry if not found
0B1DCF             2804**  ;
0B1DCF E5          2805**  OPND:			PUSH    HL			; Preserve HL
0B1DD0 21 D3 20 0B 2806**  			LD      HL,OPRNDS		; The operands table
0B1DD4 CD 62 1E 0B 2807**  			CALL    FIND			; Find the operand
0B1DD8 E1          2808**  			POP     HL
0B1DD9 D8          2809**  			RET     C			; Return if not found
0B1DDA CB 78       2810**  			BIT     7,B			; Check if it is an index register (IX, IY)
0B1DDC C8          2811**  			RET     Z			; Return if it isn't
0B1DDD CB F2       2812**  			SET	6,D			; Set flag to indicate we've got an index
0B1DDF CB 58       2813**  			BIT     3,B			; Check if an offset is required
0B1DE1 E5          2814**  			PUSH    HL
0B1DE2 CC F7 1D 0B 2815**  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
0B1DE6 5D          2816**  			LD      E,L			; E: The offset
0B1DE7 E1          2817**  			POP     HL
0B1DE8 3E DD       2818**  			LD	A,DDH			; IX prefix
0B1DEA CB 70       2819**  			BIT     6,B			; If bit 6 is reset then
0B1DEC 28 02       2820**  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
0B1DEE 3E FD       2821**  			LD	A,FDH			; IY prefix
0B1DF0             2822**  ;
0B1DF0 DD 77 00    2823**  BYTE_:			LD      (IX),A			; Write a byte out
0B1DF3 DD 23       2824**  			INC     IX
0B1DF5 B7          2825**  			OR      A
0B1DF6 C9          2826**  			RET
0B1DF7             2827**  ;
0B1DF7 FD 7E 00    2828**  OFFSET_EX:			LD      A,(IY)
0B1DFA FE 29       2829**  			CP      ')'
0B1DFC 21 00 00 00 2830**  			LD      HL,0
0B1E00 C8          2831**  			RET     Z
0B1E01 CD B3 1E 0B 2832**  NUMBER:			CALL    SKIP
0B1E05 C5          2833**  			PUSH    BC
0B1E06 D5          2834**  			PUSH    DE
0B1E07 DD E5       2835**  			PUSH    IX
0B1E09 CD 08 04 0B 2836**  			CALL    EXPRI
0B1E0D DD E1       2837**  			POP     IX
0B1E0F D9          2838**  			EXX
0B1E10 D1          2839**  			POP     DE
0B1E11 C1          2840**  			POP     BC
0B1E12 7D          2841**  			LD      A,L
0B1E13 B7          2842**  			OR      A
0B1E14 C9          2843**  			RET
0B1E15             2844**  ;
0B1E15 CD CF 1D 0B 2845**  REG:			CALL    OPND
0B1E19 D8          2846**  			RET     C
0B1E1A 78          2847**  			LD      A,B
0B1E1B E6 3F       2848**  			AND     3FH
0B1E1D FE 08       2849**  			CP      8
0B1E1F 3F          2850**  			CCF
0B1E20 C9          2851**  			RET
0B1E21             2852**  ;
0B1E21 CD 15 1E 0B 2853**  REGLO:			CALL    REG
0B1E25 D8          2854**  			RET     C
0B1E26 18 33       2855**  			JR      ORC
0B1E28             2856**  ;
0B1E28 CD 15 1E 0B 2857**  REGHI:			CALL    REG
0B1E2C D8          2858**  			RET     C
0B1E2D 18 29       2859**  			JR      SHL3
0B1E2F             2860**  ;
0B1E2F CD CF 1D 0B 2861**  COND_:			CALL    OPND
0B1E33 D8          2862**  			RET     C
0B1E34 78          2863**  			LD      A,B
0B1E35 E6 1F       2864**  			AND     1FH
0B1E37 D6 10       2865**  			SUB     16
0B1E39 30 1D       2866**  			JR      NC,SHL3
0B1E3B FE F1       2867**  			CP      -15
0B1E3D 37          2868**  			SCF
0B1E3E C0          2869**  			RET     NZ
0B1E3F 3E 03       2870**  			LD      A,3
0B1E41 18 15       2871**  			JR      SHL3
0B1E43             2872**  ;
0B1E43 CD CF 1D 0B 2873**  PAIR_EX:			CALL    OPND
0B1E47 D8          2874**  			RET     C
0B1E48 78          2875**  PAIR1_EX:			LD      A,B
0B1E49 E6 0F       2876**  			AND     0FH
0B1E4B D6 08       2877**  			SUB     8
0B1E4D D8          2878**  			RET     C
0B1E4E 18 08       2879**  			JR      SHL3
0B1E50             2880**  ;
0B1E50 CD 01 1E 0B 2881**  BIT_:			CALL    NUMBER
0B1E54 FE 08       2882**  			CP      8
0B1E56 3F          2883**  			CCF
0B1E57 D8          2884**  			RET     C
0B1E58 07          2885**  SHL3:			RLCA
0B1E59 07          2886**  			RLCA
0B1E5A 07          2887**  			RLCA
0B1E5B B1          2888**  ORC:			OR      C
0B1E5C 4F          2889**  			LD      C,A
0B1E5D C9          2890**  			RET
0B1E5E             2891**  ;
0B1E5E 21 18 21 0B 2892**  LDOP:			LD      HL,LDOPS
0B1E62             2893**  
0B1E62             2894**  ;
0B1E62             2895**  ; Look up a value in a table
0B1E62             2896**  ; Parameters:
0B1E62             2897**  ; - IY: Address of the assembly language line in the BASIC program area
0B1E62             2898**  ; - HL: Address of the table
0B1E62             2899**  ; Returns:
0B1E62             2900**  ; - B: The operand code
0B1E62             2901**  ; - F: Carry set if not found
0B1E62             2902**  ;
0B1E62 CD B3 1E 0B 2903**  FIND:			CALL    SKIP			; Skip delimiters
0B1E66             2904**  ;
0B1E66 06 00       2905**  EXIT_:			LD      B,0			; Set B to 0
0B1E68 37          2906**  			SCF				; Set the carry flag
0B1E69 C8          2907**  			RET     Z			; Returns if Z
0B1E6A             2908**  ;
0B1E6A FE DD       2909**  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
0B1E6C 28 04       2910**  			JR      Z,FIND0
0B1E6E FE 85       2911**  			CP      TOR+1			; Special case for tokens AND and OR
0B1E70 3F          2912**  			CCF
0B1E71 D8          2913**  			RET     C
0B1E72 7E          2914**  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
0B1E73 B7          2915**  			OR      A
0B1E74 28 F0       2916**  			JR      Z,EXIT_			; Exit
0B1E76 FD AE 00    2917**  			XOR     (IY)
0B1E79 E6 5F       2918**  			AND     01011111B
0B1E7B 28 09       2919**  			JR      Z,FIND2
0B1E7D CB 7E       2920**  FIND1:			BIT     7,(HL)
0B1E7F 23          2921**  			INC     HL
0B1E80 28 FB       2922**  			JR      Z,FIND1
0B1E82 23          2923**  			INC     HL
0B1E83 04          2924**  			INC     B
0B1E84 18 EC       2925**  			JR      FIND0
0B1E86             2926**  ;
0B1E86 FD E5       2927**  FIND2:			PUSH    IY
0B1E88 CB 7E       2928**  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
0B1E8A FD 23       2929**  			INC     IY
0B1E8C 23          2930**  			INC     HL
0B1E8D 20 11       2931**  			JR      NZ,FIND5		; Yes
0B1E8F BE          2932**  			CP      (HL)
0B1E90 CC B2 1E 0B 2933**  			CALL    Z,SKIP0
0B1E94 7E          2934**  			LD      A,(HL)
0B1E95 FD AE 00    2935**  			XOR     (IY)
0B1E98 E6 5F       2936**  			AND     01011111B
0B1E9A 28 EC       2937**  			JR      Z,FIND3
0B1E9C FD E1       2938**  FIND4:			POP     IY
0B1E9E 18 DD       2939**  			JR      FIND1
0B1EA0             2940**  ;
0B1EA0 CD 64 18 0B 2941**  FIND5:			CALL    DELIM			; Is it a delimiter?
0B1EA4 C4 C7 1E 0B 2942**  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
0B1EA8 C4 C1 1E 0B 2943**  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
0B1EAC 20 EE       2944**  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
0B1EAE             2945**  ;
0B1EAE 78          2946**  FIND6:			LD      A,B			; At this point we have a token
0B1EAF 46          2947**  			LD      B,(HL)			; Fetch the token type code
0B1EB0 E1          2948**  			POP     HL			; Restore the stack
0B1EB1 C9          2949**  			RET
0B1EB2             2950**  ;
0B1EB2 23          2951**  SKIP0:			INC     HL
0B1EB3 CD 64 18 0B 2952**  SKIP:			CALL    DELIM			; Is it a delimiter?
0B1EB7 C0          2953**  			RET     NZ			; No, so return
0B1EB8 CD 70 18 0B 2954**  			CALL    TERM			; Is it a terminator?
0B1EBC C8          2955**  			RET     Z			; Yes, so return
0B1EBD FD 23       2956**  			INC     IY			; Increment the basic program counter
0B1EBF 18 F2       2957**  			JR      SKIP			; And loop
0B1EC1             2958**  ;
0B1EC1 FE 2B       2959**  SIGN:			CP      '+'			; Check whether the character is a sign symbol
0B1EC3 C8          2960**  			RET     Z
0B1EC4 FE 2D       2961**  			CP      '-'
0B1EC6 C9          2962**  			RET
0B1EC7             2963**  ;
0B1EC7 FE 2E       2964**  DOT:			CP	'.'			; Check if it is a dot character
0B1EC9 C9          2965**  			RET
0B1ECA             2966**  ; Z80 opcode list
0B1ECA             2967**  ;
0B1ECA             2968**  ; Group 0: (15 opcodes)
0B1ECA             2969**  ; Trivial cases requiring no computation
0B1ECA             2970**  ;
0B1ECA             2971**  ; BEGIN REFACTOR FROM BINARY
0B1ECA             2972**  ; OPCODS:
0B1ECA             2973**  ; 			DB	"NO","P"+80H,00h	; # 00h
0B1ECA             2974**  ; 			DB	"RLC","A"+80H,07h
0B1ECA             2975**  ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
0B1ECA             2976**  ; 			DB	"RRC","A"+80H,0FH
0B1ECA             2977**  ; 			DB	"RL","A"+80H,17H
0B1ECA             2978**  ; 			DB	"RR","A"+80H,1FH
0B1ECA             2979**  ; 			DB	"DA","A"+80H,27H
0B1ECA             2980**  ; 			DB	"CP","L"+80H,2FH
0B1ECA             2981**  ; 			DB	"SC","F"+80H,37H
0B1ECA             2982**  ; 			DB	"CC","F"+80H,3FH
0B1ECA             2983**  ; 			DB	"HAL","T"+80H,76H
0B1ECA             2984**  ; 			DB	"EX","X"+80H,D9H
0B1ECA             2985**  ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
0B1ECA             2986**  ; 			DB	"D","I"+80H,F3H
0B1ECA             2987**  ; 			DB	"E","I"+80H,FBH
0B1ECA             2988**  ; ;
0B1ECA             2989**  ; ; Group 1: (53 opcodes)
0B1ECA             2990**  ; ; As Group 0, but with an ED prefix
0B1ECA             2991**  ; ;
0B1ECA             2992**  ; 			DB	"NE","G"+80H,44H	; 0Fh
0B1ECA             2993**  ; 			DB	"IM",0,"0"+80H,46H
0B1ECA             2994**  ; 			DB	"RET","N"+80H,45H
0B1ECA             2995**  ; 			DB	"MLT",0,"B","C"+80H,4CH
0B1ECA             2996**  ; 			DB	"RET","I"+80H,4DH
0B1ECA             2997**  ; 			DB	"IM",0,"1"+80H,56H
0B1ECA             2998**  ; 			DB	"MLT",0,"D","E"+80H,5CH
0B1ECA             2999**  ; 			DB	"IM",0,"2"+80H,5EH
0B1ECA             3000**  ; 			DB	"RR","D"+80H,67H
0B1ECA             3001**  ; 			DB	"MLT",0,"H","L"+80H,6CH
0B1ECA             3002**  ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
0B1ECA             3003**  ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
0B1ECA             3004**  ; 			DB	"RL","D"+80H,6FH
0B1ECA             3005**  ; 			DB	"SL","P"+80H,76H
0B1ECA             3006**  ; 			DB	"MLT",0,"S","P"+80H,7CH
0B1ECA             3007**  ; 			DB	"STMI","X"+80H,7DH
0B1ECA             3008**  ; 			DB	"RSMI","X"+80H,7EH
0B1ECA             3009**  ; 			DB	"INI","M"+80H,82H
0B1ECA             3010**  ; 			DB	"OTI","M"+80H,83H
0B1ECA             3011**  ; 			DB	"INI","2"+80H,84H
0B1ECA             3012**  ; 			DB	"IND","M"+80H,8AH
0B1ECA             3013**  ; 			DB	"OTD","M"+80H,8BH
0B1ECA             3014**  ; 			DB	"IND","2"+80H,8CH
0B1ECA             3015**  ; 			DB	"INIM","R"+80H,92H
0B1ECA             3016**  ; 			DB	"OTIM","R"+80H,93H
0B1ECA             3017**  ; 			DB	"INI2","R"+80H,94H
0B1ECA             3018**  ; 			DB	"INDM","R"+80H,9AH
0B1ECA             3019**  ; 			DB	"OTDM","R"+80H,9BH
0B1ECA             3020**  ; 			DB	"IND2","R"+80H,9CH
0B1ECA             3021**  ; 			DB	"LD","I"+80H,A0H
0B1ECA             3022**  ; 			DB	"CP","I"+80H,A1H
0B1ECA             3023**  ; 			DB	"IN","I"+80H,A2H
0B1ECA             3024**  ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
0B1ECA             3025**  ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
0B1ECA             3026**  ; 			DB	"LD","D"+80H,A8H
0B1ECA             3027**  ; 			DB	"CP","D"+80H,A9H
0B1ECA             3028**  ; 			DB	"IN","D"+80H,AAH
0B1ECA             3029**  ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
0B1ECA             3030**  ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
0B1ECA             3031**  ; 			DB	"LDI","R"+80H,B0H
0B1ECA             3032**  ; 			DB	"CPI","R"+80H,B1H
0B1ECA             3033**  ; 			DB	"INI","R"+80H,B2H
0B1ECA             3034**  ; 			DB	"OTI","R"+80H,B3H
0B1ECA             3035**  ; 			DB	"OTI2","R"+80H,B4H
0B1ECA             3036**  ; 			DB	"LDD","R"+80H,B8H
0B1ECA             3037**  ; 			DB	"CPD","R"+80H,B9H
0B1ECA             3038**  ; 			DB	"IND","R"+80H,BAH
0B1ECA             3039**  ; 			DB	"OTD","R"+80H,BBH
0B1ECA             3040**  ; 			DB	"OTD2","R"+80H,BCH
0B1ECA             3041**  ; 			DB	"INIR","X"+80H,C2H
0B1ECA             3042**  ; 			DB	"OTIR","X"+80H,C3H
0B1ECA             3043**  ; 			DB	"INDR","X"+80H,CAH
0B1ECA             3044**  ; 			DB	"OTDR","X"+80H,CBH
0B1ECA             3045**  ; ;
0B1ECA             3046**  ; ; Group 2: (3 opcodes)
0B1ECA             3047**  ; ;
0B1ECA             3048**  ; 			DB	"BI","T"+80H,40H	; 44h
0B1ECA             3049**  ; 			DB	"RE","S"+80H,80H
0B1ECA             3050**  ; 			DB	"SE","T"+80H,C0H
0B1ECA             3051**  ; ;
0B1ECA             3052**  ; ; Group 3: (7 opcodes)
0B1ECA             3053**  ; ;
0B1ECA             3054**  ; 			DB	"RL","C"+80H,00H	; 47h
0B1ECA             3055**  ; 			DB	"RR","C"+80H,08H
0B1ECA             3056**  ; 			DB	"R","L"+80H,10H
0B1ECA             3057**  ; 			DB	"R","R"+80H,18H
0B1ECA             3058**  ; 			DB	"SL","A"+80H,20H
0B1ECA             3059**  ; 			DB	"SR","A"+80H,28H
0B1ECA             3060**  ; 			DB	"SR","L"+80H,38H
0B1ECA             3061**  ; ;
0B1ECA             3062**  ; ; Group 4: (3 opcodes)
0B1ECA             3063**  ; ;
0B1ECA             3064**  ; 			DB	"PO","P"+80H,C1H	; 4Eh
0B1ECA             3065**  ; 			DB	"PUS","H"+80H,C5H
0B1ECA             3066**  ; 			DB	"EX",0,"(S","P"+80H,E3H
0B1ECA             3067**  ; ;
0B1ECA             3068**  ; ; Group 5: (7 opcodes)
0B1ECA             3069**  ; ;
0B1ECA             3070**  ; 			DB	"SU","B"+80H,90H	; 51h
0B1ECA             3071**  ; 			DB	"AN","D"+80H,A0H
0B1ECA             3072**  ; 			DB	"XO","R"+80H,A8H
0B1ECA             3073**  ; 			DB	"O","R"+80H,B0H
0B1ECA             3074**  ; 			DB	"C","P"+80H,B8H
0B1ECA             3075**  ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
0B1ECA             3076**  ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
0B1ECA             3077**  ; ;
0B1ECA             3078**  ; ; Group 6 (3 opcodes)
0B1ECA             3079**  ; ;
0B1ECA             3080**  ; 			DB	"AD","D"+80H,80H	; 58h
0B1ECA             3081**  ; 			DB	"AD","C"+80H,88H
0B1ECA             3082**  ; 			DB	"SB","C"+80H,98H
0B1ECA             3083**  ; ;
0B1ECA             3084**  ; ; Group 7: (2 opcodes)
0B1ECA             3085**  ; ;
0B1ECA             3086**  ; 			DB	"IN","C"+80H,04H	; 5Bh
0B1ECA             3087**  ; 			DB	"DE","C"+80H,05H
0B1ECA             3088**  ; ;
0B1ECA             3089**  ; ; Group 8: (2 opcodes)
0B1ECA             3090**  ; ;
0B1ECA             3091**  ; 			DB	"IN","0"+80H,00H	; 5Dh
0B1ECA             3092**  ; 			DB	"OUT","0"+80H,01H
0B1ECA             3093**  ; ;
0B1ECA             3094**  ; ; Group 9: (1 opcode)
0B1ECA             3095**  ; ;
0B1ECA             3096**  ; 			DB	"I","N"+80H,40H		; 5Fh
0B1ECA             3097**  ; ;
0B1ECA             3098**  ; ; Group 10: (1 opcode)
0B1ECA             3099**  ; ;
0B1ECA             3100**  ; 			DB	"OU","T"+80H,41H	; 60h
0B1ECA             3101**  ; ;
0B1ECA             3102**  ; ; Group 11: (2 opcodes)
0B1ECA             3103**  ; ;
0B1ECA             3104**  ; 			DB	"J","R"+80H,20H		; 61h
0B1ECA             3105**  ; 			DB	"DJN","Z"+80H,10H
0B1ECA             3106**  ; ;
0B1ECA             3107**  ; ; Group 12: (1 opcode)
0B1ECA             3108**  ; ;
0B1ECA             3109**  ; 			DB	"J","P"+80H,C2H		; 63h
0B1ECA             3110**  ; ;
0B1ECA             3111**  ; ; Group 13: (1 opcode)
0B1ECA             3112**  ; ;
0B1ECA             3113**  ; 			DB	"CAL","L"+80H,C4H	; 64h
0B1ECA             3114**  ; ;
0B1ECA             3115**  ; ; Group 14: (1 opcode)
0B1ECA             3116**  ; ;
0B1ECA             3117**  ; 			DB	"RS","T"+80H,C7H	; 65h
0B1ECA             3118**  ; ;
0B1ECA             3119**  ; ; Group 15: (1 opcode)
0B1ECA             3120**  ; ;
0B1ECA             3121**  ; 			DB	"RE","T"+80H,C0H	; 66h
0B1ECA             3122**  ; ;
0B1ECA             3123**  ; ; Group 16: (1 opcode)
0B1ECA             3124**  ; ;
0B1ECA             3125**  ; 			DB	"L","D"+80H,40H		; 67h
0B1ECA             3126**  ; ;
0B1ECA             3127**  ; ; Group 17: (1 opcode)
0B1ECA             3128**  ; ;
0B1ECA             3129**  ; 			DB	"TS","T"+80H,04H	; 68h
0B1ECA             3130**  
0B1ECA             3131**  ; ;
0B1ECA             3132**  ; ; Assembler Directives
0B1ECA             3133**  ; ;
0B1ECA             3134**  ; 			DB	"OP","T"+80H,00H	; 69h OPT
0B1ECA             3135**  ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
0B1ECA             3136**  ; ;
0B1ECA             3137**  ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
0B1ECA             3138**  ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
0B1ECA             3139**  ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
0B1ECA             3140**  ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
0B1ECA             3141**  ; ;
0B1ECA             3142**  ; 			DB	0
0B1ECA             3143**  ; ;
0B1ECA             3144**  ; ; Operands
0B1ECA             3145**  ; ;
0B1ECA             3146**  ; OPRNDS:			DB	"B"+80H, 00H
0B1ECA             3147**  ; 			DB	"C"+80H, 01H
0B1ECA             3148**  ; 			DB	"D"+80H, 02H
0B1ECA             3149**  ; 			DB	"E"+80H, 03H
0B1ECA             3150**  ; 			DB	"H"+80H, 04H
0B1ECA             3151**  ; 			DB	"L"+80H, 05H
0B1ECA             3152**  ; 			DB	"(H","L"+80H,06H
0B1ECA             3153**  ; 			DB	"A"+80H, 07H
0B1ECA             3154**  ; 			DB	"(I","X"+80H,86H
0B1ECA             3155**  ; 			DB	"(I","Y"+80H,C6H
0B1ECA             3156**  ; ;
0B1ECA             3157**  ; 			DB	"B","C"+80H,08H
0B1ECA             3158**  ; 			DB	"D","E"+80H,0AH
0B1ECA             3159**  ; 			DB	"H","L"+80H,0CH
0B1ECA             3160**  ; 			DB	"I","X"+80H,8CH
0B1ECA             3161**  ; 			DB	"I","Y"+80H,CCH
0B1ECA             3162**  ; 			DB	"A","F"+80H,0EH
0B1ECA             3163**  ; 			DB	"S","P"+80H,0EH
0B1ECA             3164**  ; ;
0B1ECA             3165**  ; 			DB	"N","Z"+80H,10H
0B1ECA             3166**  ; 			DB	"Z"+80H,11H
0B1ECA             3167**  ; 			DB	"N","C"+80H,12H
0B1ECA             3168**  ; 			DB	"P","O"+80H,14H
0B1ECA             3169**  ; 			DB	"P","E"+80H,15H
0B1ECA             3170**  ; 			DB	"P"+80H,16H
0B1ECA             3171**  ; 			DB	"M"+80H,17H
0B1ECA             3172**  ; ;
0B1ECA             3173**  ; 			DB	"(","C"+80H,20H
0B1ECA             3174**  ; ;
0B1ECA             3175**  ; 			DB	0
0B1ECA             3176**  ; ;
0B1ECA             3177**  ; ; Load operations
0B1ECA             3178**  ; ;
0B1ECA             3179**  ; LDOPS:			DB	"I",0,"A"+80H,47H
0B1ECA             3180**  ; 			DB	"R",0,"A"+80H,4FH
0B1ECA             3181**  ; 			DB	"A",0,"I"+80H,57H
0B1ECA             3182**  ; 			DB	"A",0,"R"+80H,5FH
0B1ECA             3183**  ; 			DB	"(BC",0,"A"+80H,02h
0B1ECA             3184**  ; 			DB	"(DE",0,"A"+80H,12H
0B1ECA             3185**  ; 			DB	"A",0,"(B","C"+80H,0AH
0B1ECA             3186**  ; 			DB	"A",0,"(D","E"+80H,1AH
0B1ECA             3187**  ; ;
0B1ECA             3188**  ; 			DB	0
0B1ECA             3189**  ; ;
0B1ECA             3190**  ; ; eZ80 addressing mode suffixes
0B1ECA             3191**  ; ;
0B1ECA             3192**  ; ; Fully qualified suffixes
0B1ECA             3193**  ; ;
0B1ECA             3194**  ; EZ80SFS_1:		DB	"LI","S"+80H,49H
0B1ECA             3195**  ; 			DB	"SI","L"+80H,52H
0B1ECA             3196**  ; EZ80SFS_2:		DB	"SI","S"+80H,40H
0B1ECA             3197**  ; 			DB	"LI","L"+80H,5BH
0B1ECA             3198**  ; ;
0B1ECA             3199**  ; 			DB	0
0B1ECA             3200**  ; ;
0B1ECA             3201**  ; ; Shortcuts when ADL mode is 0
0B1ECA             3202**  ; ;
0B1ECA             3203**  ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0B1ECA             3204**  ; 			DB	"L"+80H,49H		; Equivalent to .LIS
0B1ECA             3205**  ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
0B1ECA             3206**  ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
0B1ECA             3207**  ; ;
0B1ECA             3208**  ; 			DB	0
0B1ECA             3209**  ; ;
0B1ECA             3210**  ; ; Shortcuts when ADL mode is 1
0B1ECA             3211**  ; ;
0B1ECA             3212**  ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0B1ECA             3213**  ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
0B1ECA             3214**  ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
0B1ECA             3215**  ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0B1ECA             3216**  ; ;
0B1ECA             3217**  ; 			DB	0
0B1ECA             3218**  ; END REFACTOR FROM BINARY
0B1ECA             3219**  ; BEGIN INSERT FROM BINARY
0B1ECA             3220**  ;
0B1ECA             3221**  ; Trivial cases requiring no computation
0B1ECA             3222**  OPCODS:
0B1ECA 4E          3223**  	db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
0B1ECB 4F          3224**  	db 0x4f ; 041DCD
0B1ECC D0          3225**  	db 0xd0 ; 041DCE
0B1ECD 00          3226**  	db 0x00 ; 041DCF
0B1ECE 52          3227**  	db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
0B1ECF 4C          3228**  	db 0x4c ; 041DD1
0B1ED0 43          3229**  	db 0x43 ; 041DD2
0B1ED1 C1          3230**  	db 0xc1 ; 041DD3
0B1ED2 07          3231**  	db 0x07 ; 041DD4
0B1ED3 45          3232**  	db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
0B1ED4 58          3233**  	db 0x58 ; 041DD6
0B1ED5 00          3234**  	db 0x00 ; 041DD7
0B1ED6 41          3235**  	db 0x41 ; 041DD8
0B1ED7 46          3236**  	db 0x46 ; 041DD9
0B1ED8 00          3237**  	db 0x00 ; 041DDA
0B1ED9 41          3238**  	db 0x41 ; 041DDB
0B1EDA 46          3239**  	db 0x46 ; 041DDC
0B1EDB A7          3240**  	db 0xa7 ; 041DDD
0B1EDC 08          3241**  	db 0x08 ; 041DDE
0B1EDD 52          3242**  	db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
0B1EDE 52          3243**  	db 0x52 ; 041DE0
0B1EDF 43          3244**  	db 0x43 ; 041DE1
0B1EE0 C1          3245**  	db 0xc1 ; 041DE2
0B1EE1 0F          3246**  	db 0x0f ; 041DE3
0B1EE2 52          3247**  	db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
0B1EE3 4C          3248**  	db 0x4c ; 041DE5
0B1EE4 C1          3249**  	db 0xc1 ; 041DE6
0B1EE5 17          3250**  	db 0x17 ; 041DE7
0B1EE6 52          3251**  	db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
0B1EE7 52          3252**  	db 0x52 ; 041DE9
0B1EE8 C1          3253**  	db 0xc1 ; 041DEA
0B1EE9 1F          3254**  	db 0x1f ; 041DEB
0B1EEA 44          3255**  	db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
0B1EEB 41          3256**  	db 0x41 ; 041DED
0B1EEC C1          3257**  	db 0xc1 ; 041DEE
0B1EED 27          3258**  	db 0x27 ; 041DEF
0B1EEE 43          3259**  	db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
0B1EEF 50          3260**  	db 0x50 ; 041DF1
0B1EF0 CC          3261**  	db 0xcc ; 041DF2
0B1EF1 2F          3262**  	db 0x2f ; 041DF3
0B1EF2 53          3263**  	db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
0B1EF3 43          3264**  	db 0x43 ; 041DF5
0B1EF4 C6          3265**  	db 0xc6 ; 041DF6
0B1EF5 37          3266**  	db 0x37 ; 041DF7
0B1EF6 43          3267**  	db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
0B1EF7 43          3268**  	db 0x43 ; 041DF9
0B1EF8 C6          3269**  	db 0xc6 ; 041DFA
0B1EF9 3F          3270**  	db 0x3f ; 041DFB
0B1EFA 48          3271**  	db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
0B1EFB 41          3272**  	db 0x41 ; 041DFD
0B1EFC 4C          3273**  	db 0x4c ; 041DFE
0B1EFD D4          3274**  	db 0xd4 ; 041DFF
0B1EFE 76          3275**  	db 0x76 ; 041E00
0B1EFF 45          3276**  	db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
0B1F00 58          3277**  	db 0x58 ; 041E02
0B1F01 D8          3278**  	db 0xd8 ; 041E03
0B1F02 D9          3279**  	db 0xd9 ; 041E04
0B1F03 45          3280**  	db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
0B1F04 58          3281**  	db 0x58 ; 041E06
0B1F05 00          3282**  	db 0x00 ; 041E07
0B1F06 44          3283**  	db 0x44 ; 041E08
0B1F07 45          3284**  	db 0x45 ; 041E09
0B1F08 00          3285**  	db 0x00 ; 041E0A
0B1F09 48          3286**  	db 0x48 ; 041E0B
0B1F0A CC          3287**  	db 0xcc ; 041E0C
0B1F0B EB          3288**  	db 0xeb ; 041E0D
0B1F0C 44          3289**  	db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
0B1F0D C9          3290**  	db 0xc9 ; 041E0F
0B1F0E F3          3291**  	db 0xf3 ; 041E10
0B1F0F 45          3292**  	db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
0B1F10 C9          3293**  	db 0xc9 ; 041E12
0B1F11 FB          3294**  	db 0xfb ; 041E13
0B1F12             3295**  ;
0B1F12             3296**  ; Group 1: (53 opcodes)
0B1F12             3297**  ; As Group 0, but with an ED prefix
0B1F12             3298**  ;
0B1F12 4E          3299**  	db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
0B1F13 45          3300**  	db 0x45 ; 041E15
0B1F14 C7          3301**  	db 0xc7 ; 041E16
0B1F15 44          3302**  	db 0x44 ; 041E17
0B1F16 49          3303**  	db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
0B1F17 4D          3304**  	db 0x4d ; 041E19
0B1F18 00          3305**  	db 0x00 ; 041E1A
0B1F19 B0          3306**  	db 0xb0 ; 041E1B
0B1F1A 46          3307**  	db 0x46 ; 041E1C
0B1F1B 52          3308**  	db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
0B1F1C 45          3309**  	db 0x45 ; 041E1E
0B1F1D 54          3310**  	db 0x54 ; 041E1F
0B1F1E CE          3311**  	db 0xce ; 041E20
0B1F1F 45          3312**  	db 0x45 ; 041E21
0B1F20 4D          3313**  	db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
0B1F21 4C          3314**  	db 0x4c ; 041E23
0B1F22 54          3315**  	db 0x54 ; 041E24
0B1F23 00          3316**  	db 0x00 ; 041E25
0B1F24 42          3317**  	db 0x42 ; 041E26
0B1F25 C3          3318**  	db 0xc3 ; 041E27
0B1F26 4C          3319**  	db 0x4c ; 041E28
0B1F27 52          3320**  	db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
0B1F28 45          3321**  	db 0x45 ; 041E2A
0B1F29 54          3322**  	db 0x54 ; 041E2B
0B1F2A C9          3323**  	db 0xc9 ; 041E2C
0B1F2B 4D          3324**  	db 0x4d ; 041E2D
0B1F2C 49          3325**  	db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
0B1F2D 4D          3326**  	db 0x4d ; 041E2F
0B1F2E 00          3327**  	db 0x00 ; 041E30
0B1F2F B1          3328**  	db 0xb1 ; 041E31
0B1F30 56          3329**  	db 0x56 ; 041E32
0B1F31 4D          3330**  	db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
0B1F32 4C          3331**  	db 0x4c ; 041E34
0B1F33 54          3332**  	db 0x54 ; 041E35
0B1F34 00          3333**  	db 0x00 ; 041E36
0B1F35 44          3334**  	db 0x44 ; 041E37
0B1F36 C5          3335**  	db 0xc5 ; 041E38
0B1F37 5C          3336**  	db 0x5c ; 041E39
0B1F38 49          3337**  	db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
0B1F39 4D          3338**  	db 0x4d ; 041E3B
0B1F3A 00          3339**  	db 0x00 ; 041E3C
0B1F3B B2          3340**  	db 0xb2 ; 041E3D
0B1F3C 5E          3341**  	db 0x5e ; 041E3E
0B1F3D 52          3342**  	db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
0B1F3E 52          3343**  	db 0x52 ; 041E40
0B1F3F C4          3344**  	db 0xc4 ; 041E41
0B1F40 67          3345**  	db 0x67 ; 041E42
0B1F41 4D          3346**  	db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
0B1F42 4C          3347**  	db 0x4c ; 041E44
0B1F43 54          3348**  	db 0x54 ; 041E45
0B1F44 00          3349**  	db 0x00 ; 041E46
0B1F45 48          3350**  	db 0x48 ; 041E47
0B1F46 CC          3351**  	db 0xcc ; 041E48
0B1F47 6C          3352**  	db 0x6c ; 041E49
0B1F48 4C          3353**  	db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
0B1F49 44          3354**  	db 0x44 ; 041E4B
0B1F4A 00          3355**  	db 0x00 ; 041E4C
0B1F4B 4D          3356**  	db 0x4d ; 041E4D
0B1F4C 42          3357**  	db 0x42 ; 041E4E
0B1F4D 00          3358**  	db 0x00 ; 041E4F
0B1F4E C1          3359**  	db 0xc1 ; 041E50
0B1F4F 6D          3360**  	db 0x6d ; 041E51
0B1F50 4C          3361**  	db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
0B1F51 44          3362**  	db 0x44 ; 041E53
0B1F52 00          3363**  	db 0x00 ; 041E54
0B1F53 41          3364**  	db 0x41 ; 041E55
0B1F54 00          3365**  	db 0x00 ; 041E56
0B1F55 4D          3366**  	db 0x4d ; 041E57
0B1F56 C2          3367**  	db 0xc2 ; 041E58
0B1F57 6E          3368**  	db 0x6e ; 041E59
0B1F58 52          3369**  	db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
0B1F59 4C          3370**  	db 0x4c ; 041E5B
0B1F5A C4          3371**  	db 0xc4 ; 041E5C
0B1F5B 6F          3372**  	db 0x6f ; 041E5D
0B1F5C 53          3373**  	db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
0B1F5D 4C          3374**  	db 0x4c ; 041E5F
0B1F5E D0          3375**  	db 0xd0 ; 041E60
0B1F5F 76          3376**  	db 0x76 ; 041E61
0B1F60 4D          3377**  	db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
0B1F61 4C          3378**  	db 0x4c ; 041E63
0B1F62 54          3379**  	db 0x54 ; 041E64
0B1F63 00          3380**  	db 0x00 ; 041E65
0B1F64 53          3381**  	db 0x53 ; 041E66
0B1F65 D0          3382**  	db 0xd0 ; 041E67
0B1F66 7C          3383**  	db 0x7c ; 041E68
0B1F67 53          3384**  	db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
0B1F68 54          3385**  	db 0x54 ; 041E6A
0B1F69 4D          3386**  	db 0x4d ; 041E6B
0B1F6A 49          3387**  	db 0x49 ; 041E6C
0B1F6B D8          3388**  	db 0xd8 ; 041E6D
0B1F6C 7D          3389**  	db 0x7d ; 041E6E
0B1F6D 52          3390**  	db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
0B1F6E 53          3391**  	db 0x53 ; 041E70
0B1F6F 4D          3392**  	db 0x4d ; 041E71
0B1F70 49          3393**  	db 0x49 ; 041E72
0B1F71 D8          3394**  	db 0xd8 ; 041E73
0B1F72 7E          3395**  	db 0x7e ; 041E74
0B1F73 49          3396**  	db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
0B1F74 4E          3397**  	db 0x4e ; 041E76
0B1F75 49          3398**  	db 0x49 ; 041E77
0B1F76 CD          3399**  	db 0xcd ; 041E78
0B1F77 82          3400**  	db 0x82 ; 041E79
0B1F78 4F          3401**  	db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
0B1F79 54          3402**  	db 0x54 ; 041E7B
0B1F7A 49          3403**  	db 0x49 ; 041E7C
0B1F7B CD          3404**  	db 0xcd ; 041E7D
0B1F7C 83          3405**  	db 0x83 ; 041E7E
0B1F7D 49          3406**  	db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
0B1F7E 4E          3407**  	db 0x4e ; 041E80
0B1F7F 49          3408**  	db 0x49 ; 041E81
0B1F80 B2          3409**  	db 0xb2 ; 041E82
0B1F81 84          3410**  	db 0x84 ; 041E83
0B1F82 49          3411**  	db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
0B1F83 4E          3412**  	db 0x4e ; 041E85
0B1F84 44          3413**  	db 0x44 ; 041E86
0B1F85 CD          3414**  	db 0xcd ; 041E87
0B1F86 8A          3415**  	db 0x8a ; 041E88
0B1F87 4F          3416**  	db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
0B1F88 54          3417**  	db 0x54 ; 041E8A
0B1F89 44          3418**  	db 0x44 ; 041E8B
0B1F8A CD          3419**  	db 0xcd ; 041E8C
0B1F8B 8B          3420**  	db 0x8b ; 041E8D
0B1F8C 49          3421**  	db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
0B1F8D 4E          3422**  	db 0x4e ; 041E8F
0B1F8E 44          3423**  	db 0x44 ; 041E90
0B1F8F B2          3424**  	db 0xb2 ; 041E91
0B1F90 8C          3425**  	db 0x8c ; 041E92
0B1F91 49          3426**  	db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
0B1F92 4E          3427**  	db 0x4e ; 041E94
0B1F93 49          3428**  	db 0x49 ; 041E95
0B1F94 4D          3429**  	db 0x4d ; 041E96
0B1F95 D2          3430**  	db 0xd2 ; 041E97
0B1F96 92          3431**  	db 0x92 ; 041E98
0B1F97 4F          3432**  	db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
0B1F98 54          3433**  	db 0x54 ; 041E9A
0B1F99 49          3434**  	db 0x49 ; 041E9B
0B1F9A 4D          3435**  	db 0x4d ; 041E9C
0B1F9B D2          3436**  	db 0xd2 ; 041E9D
0B1F9C 93          3437**  	db 0x93 ; 041E9E
0B1F9D 49          3438**  	db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
0B1F9E 4E          3439**  	db 0x4e ; 041EA0
0B1F9F 49          3440**  	db 0x49 ; 041EA1
0B1FA0 32          3441**  	db 0x32 ; 041EA2
0B1FA1 D2          3442**  	db 0xd2 ; 041EA3
0B1FA2 94          3443**  	db 0x94 ; 041EA4
0B1FA3 49          3444**  	db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
0B1FA4 4E          3445**  	db 0x4e ; 041EA6
0B1FA5 44          3446**  	db 0x44 ; 041EA7
0B1FA6 4D          3447**  	db 0x4d ; 041EA8
0B1FA7 D2          3448**  	db 0xd2 ; 041EA9
0B1FA8 9A          3449**  	db 0x9a ; 041EAA
0B1FA9 4F          3450**  	db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
0B1FAA 54          3451**  	db 0x54 ; 041EAC
0B1FAB 44          3452**  	db 0x44 ; 041EAD
0B1FAC 4D          3453**  	db 0x4d ; 041EAE
0B1FAD D2          3454**  	db 0xd2 ; 041EAF
0B1FAE 9B          3455**  	db 0x9b ; 041EB0
0B1FAF 49          3456**  	db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
0B1FB0 4E          3457**  	db 0x4e ; 041EB2
0B1FB1 44          3458**  	db 0x44 ; 041EB3
0B1FB2 32          3459**  	db 0x32 ; 041EB4
0B1FB3 D2          3460**  	db 0xd2 ; 041EB5
0B1FB4 9C          3461**  	db 0x9c ; 041EB6
0B1FB5 4C          3462**  	db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
0B1FB6 44          3463**  	db 0x44 ; 041EB8
0B1FB7 C9          3464**  	db 0xc9 ; 041EB9
0B1FB8 A0          3465**  	db 0xa0 ; 041EBA
0B1FB9 43          3466**  	db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
0B1FBA 50          3467**  	db 0x50 ; 041EBC
0B1FBB C9          3468**  	db 0xc9 ; 041EBD
0B1FBC A1          3469**  	db 0xa1 ; 041EBE
0B1FBD 49          3470**  	db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
0B1FBE 4E          3471**  	db 0x4e ; 041EC0
0B1FBF C9          3472**  	db 0xc9 ; 041EC1
0B1FC0 A2          3473**  	db 0xa2 ; 041EC2
0B1FC1 4F          3474**  	db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
0B1FC2 55          3475**  	db 0x55 ; 041EC4
0B1FC3 54          3476**  	db 0x54 ; 041EC5
0B1FC4 49          3477**  	db 0x49 ; 041EC6
0B1FC5 B2          3478**  	db 0xb2 ; 041EC7
0B1FC6 A4          3479**  	db 0xa4 ; 041EC8
0B1FC7 4F          3480**  	db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
0B1FC8 55          3481**  	db 0x55 ; 041ECA
0B1FC9 54          3482**  	db 0x54 ; 041ECB
0B1FCA C9          3483**  	db 0xc9 ; 041ECC
0B1FCB A3          3484**  	db 0xa3 ; 041ECD
0B1FCC 4C          3485**  	db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
0B1FCD 44          3486**  	db 0x44 ; 041ECF
0B1FCE C4          3487**  	db 0xc4 ; 041ED0
0B1FCF A8          3488**  	db 0xa8 ; 041ED1
0B1FD0 43          3489**  	db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
0B1FD1 50          3490**  	db 0x50 ; 041ED3
0B1FD2 C4          3491**  	db 0xc4 ; 041ED4
0B1FD3 A9          3492**  	db 0xa9 ; 041ED5
0B1FD4 49          3493**  	db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
0B1FD5 4E          3494**  	db 0x4e ; 041ED7
0B1FD6 C4          3495**  	db 0xc4 ; 041ED8
0B1FD7 AA          3496**  	db 0xaa ; 041ED9
0B1FD8 4F          3497**  	db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
0B1FD9 55          3498**  	db 0x55 ; 041EDB
0B1FDA 54          3499**  	db 0x54 ; 041EDC
0B1FDB 44          3500**  	db 0x44 ; 041EDD
0B1FDC B2          3501**  	db 0xb2 ; 041EDE
0B1FDD AC          3502**  	db 0xac ; 041EDF
0B1FDE 4F          3503**  	db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
0B1FDF 55          3504**  	db 0x55 ; 041EE1
0B1FE0 54          3505**  	db 0x54 ; 041EE2
0B1FE1 C4          3506**  	db 0xc4 ; 041EE3
0B1FE2 AB          3507**  	db 0xab ; 041EE4
0B1FE3 4C          3508**  	db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
0B1FE4 44          3509**  	db 0x44 ; 041EE6
0B1FE5 49          3510**  	db 0x49 ; 041EE7
0B1FE6 D2          3511**  	db 0xd2 ; 041EE8
0B1FE7 B0          3512**  	db 0xb0 ; 041EE9
0B1FE8 43          3513**  	db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
0B1FE9 50          3514**  	db 0x50 ; 041EEB
0B1FEA 49          3515**  	db 0x49 ; 041EEC
0B1FEB D2          3516**  	db 0xd2 ; 041EED
0B1FEC B1          3517**  	db 0xb1 ; 041EEE
0B1FED 49          3518**  	db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
0B1FEE 4E          3519**  	db 0x4e ; 041EF0
0B1FEF 49          3520**  	db 0x49 ; 041EF1
0B1FF0 D2          3521**  	db 0xd2 ; 041EF2
0B1FF1 B2          3522**  	db 0xb2 ; 041EF3
0B1FF2 4F          3523**  	db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
0B1FF3 54          3524**  	db 0x54 ; 041EF5
0B1FF4 49          3525**  	db 0x49 ; 041EF6
0B1FF5 D2          3526**  	db 0xd2 ; 041EF7
0B1FF6 B3          3527**  	db 0xb3 ; 041EF8
0B1FF7 4F          3528**  	db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
0B1FF8 54          3529**  	db 0x54 ; 041EFA
0B1FF9 49          3530**  	db 0x49 ; 041EFB
0B1FFA 32          3531**  	db 0x32 ; 041EFC
0B1FFB D2          3532**  	db 0xd2 ; 041EFD
0B1FFC B4          3533**  	db 0xb4 ; 041EFE
0B1FFD 4C          3534**  	db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
0B1FFE 44          3535**  	db 0x44 ; 041F00
0B1FFF 44          3536**  	db 0x44 ; 041F01
0B2000 D2          3537**  	db 0xd2 ; 041F02
0B2001 B8          3538**  	db 0xb8 ; 041F03
0B2002 43          3539**  	db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
0B2003 50          3540**  	db 0x50 ; 041F05
0B2004 44          3541**  	db 0x44 ; 041F06
0B2005 D2          3542**  	db 0xd2 ; 041F07
0B2006 B9          3543**  	db 0xb9 ; 041F08
0B2007 49          3544**  	db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
0B2008 4E          3545**  	db 0x4e ; 041F0A
0B2009 44          3546**  	db 0x44 ; 041F0B
0B200A D2          3547**  	db 0xd2 ; 041F0C
0B200B BA          3548**  	db 0xba ; 041F0D
0B200C 4F          3549**  	db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
0B200D 54          3550**  	db 0x54 ; 041F0F
0B200E 44          3551**  	db 0x44 ; 041F10
0B200F D2          3552**  	db 0xd2 ; 041F11
0B2010 BB          3553**  	db 0xbb ; 041F12
0B2011 4F          3554**  	db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
0B2012 54          3555**  	db 0x54 ; 041F14
0B2013 44          3556**  	db 0x44 ; 041F15
0B2014 32          3557**  	db 0x32 ; 041F16
0B2015 D2          3558**  	db 0xd2 ; 041F17
0B2016 BC          3559**  	db 0xbc ; 041F18
0B2017 49          3560**  	db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
0B2018 4E          3561**  	db 0x4e ; 041F1A
0B2019 49          3562**  	db 0x49 ; 041F1B
0B201A 52          3563**  	db 0x52 ; 041F1C
0B201B D8          3564**  	db 0xd8 ; 041F1D
0B201C C2          3565**  	db 0xc2 ; 041F1E
0B201D 4F          3566**  	db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
0B201E 54          3567**  	db 0x54 ; 041F20
0B201F 49          3568**  	db 0x49 ; 041F21
0B2020 52          3569**  	db 0x52 ; 041F22
0B2021 D8          3570**  	db 0xd8 ; 041F23
0B2022 C3          3571**  	db 0xc3 ; 041F24
0B2023 49          3572**  	db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
0B2024 4E          3573**  	db 0x4e ; 041F26
0B2025 44          3574**  	db 0x44 ; 041F27
0B2026 52          3575**  	db 0x52 ; 041F28
0B2027 D8          3576**  	db 0xd8 ; 041F29
0B2028 CA          3577**  	db 0xca ; 041F2A
0B2029 4F          3578**  	db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
0B202A 54          3579**  	db 0x54 ; 041F2C
0B202B 44          3580**  	db 0x44 ; 041F2D
0B202C 52          3581**  	db 0x52 ; 041F2E
0B202D D8          3582**  	db 0xd8 ; 041F2F
0B202E CB          3583**  	db 0xcb ; 041F30
0B202F             3584**  ;
0B202F             3585**  ; Group 2: (3 opcodes)
0B202F             3586**  ;
0B202F 42          3587**  	db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
0B2030 49          3588**  	db 0x49 ; 041F32
0B2031 D4          3589**  	db 0xd4 ; 041F33
0B2032 40          3590**  	db 0x40 ; 041F34
0B2033 52          3591**  	db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
0B2034 45          3592**  	db 0x45 ; 041F36
0B2035 D3          3593**  	db 0xd3 ; 041F37
0B2036 80          3594**  	db 0x80 ; 041F38
0B2037 53          3595**  	db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
0B2038 45          3596**  	db 0x45 ; 041F3A
0B2039 D4          3597**  	db 0xd4 ; 041F3B
0B203A C0          3598**  	db 0xc0 ; 041F3C
0B203B             3599**  ;
0B203B             3600**  ; Group 3: (7 opcodes)
0B203B             3601**  ;
0B203B 52          3602**  	db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
0B203C 4C          3603**  	db 0x4c ; 041F3E
0B203D C3          3604**  	db 0xc3 ; 041F3F
0B203E 00          3605**  	db 0x00 ; 041F40
0B203F 52          3606**  	db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
0B2040 52          3607**  	db 0x52 ; 041F42
0B2041 C3          3608**  	db 0xc3 ; 041F43
0B2042 08          3609**  	db 0x08 ; 041F44
0B2043 52          3610**  	db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
0B2044 CC          3611**  	db 0xcc ; 041F46
0B2045 10          3612**  	db 0x10 ; 041F47
0B2046 52          3613**  	db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
0B2047 D2          3614**  	db 0xd2 ; 041F49
0B2048 18          3615**  	db 0x18 ; 041F4A
0B2049 53          3616**  	db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
0B204A 4C          3617**  	db 0x4c ; 041F4C
0B204B C1          3618**  	db 0xc1 ; 041F4D
0B204C 20          3619**  	db 0x20 ; 041F4E
0B204D 53          3620**  	db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
0B204E 52          3621**  	db 0x52 ; 041F50
0B204F C1          3622**  	db 0xc1 ; 041F51
0B2050 28          3623**  	db 0x28 ; 041F52
0B2051 53          3624**  	db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
0B2052 52          3625**  	db 0x52 ; 041F54
0B2053 CC          3626**  	db 0xcc ; 041F55
0B2054 38          3627**  	db 0x38 ; 041F56
0B2055             3628**  ;
0B2055             3629**  ; Group 4: (3 opcodes)
0B2055             3630**  ;
0B2055 50          3631**  	db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
0B2056 4F          3632**  	db 0x4f ; 041F58
0B2057 D0          3633**  	db 0xd0 ; 041F59
0B2058 C1          3634**  	db 0xc1 ; 041F5A
0B2059 50          3635**  	db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
0B205A 55          3636**  	db 0x55 ; 041F5C
0B205B 53          3637**  	db 0x53 ; 041F5D
0B205C C8          3638**  	db 0xc8 ; 041F5E
0B205D C5          3639**  	db 0xc5 ; 041F5F
0B205E 45          3640**  	db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
0B205F 58          3641**  	db 0x58 ; 041F61
0B2060 00          3642**  	db 0x00 ; 041F62
0B2061 28          3643**  	db 0x28 ; 041F63
0B2062 53          3644**  	db 0x53 ; 041F64
0B2063 D0          3645**  	db 0xd0 ; 041F65
0B2064 E3          3646**  	db 0xe3 ; 041F66
0B2065             3647**  ;
0B2065             3648**  ; Group 5: (7 opcodes)
0B2065             3649**  ;
0B2065 53          3650**  	db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
0B2066 55          3651**  	db 0x55 ; 041F68
0B2067 C2          3652**  	db 0xc2 ; 041F69
0B2068 90          3653**  	db 0x90 ; 041F6A
0B2069 41          3654**  	db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
0B206A 4E          3655**  	db 0x4e ; 041F6C
0B206B C4          3656**  	db 0xc4 ; 041F6D
0B206C A0          3657**  	db 0xa0 ; 041F6E
0B206D 58          3658**  	db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
0B206E 4F          3659**  	db 0x4f ; 041F70
0B206F D2          3660**  	db 0xd2 ; 041F71
0B2070 A8          3661**  	db 0xa8 ; 041F72
0B2071 4F          3662**  	db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
0B2072 D2          3663**  	db 0xd2 ; 041F74
0B2073 B0          3664**  	db 0xb0 ; 041F75
0B2074 43          3665**  	db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
0B2075 D0          3666**  	db 0xd0 ; 041F77
0B2076 B8          3667**  	db 0xb8 ; 041F78
0B2077 80          3668**  	db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
0B2078 A0          3669**  	db 0xa0 ; 041F7A
0B2079 84          3670**  	db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
0B207A B0          3671**  	db 0xb0 ; 041F7C
0B207B             3672**  ;
0B207B             3673**  ; Group 6 (3 opcodes)
0B207B             3674**  ;
0B207B 41          3675**  	db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
0B207C 44          3676**  	db 0x44 ; 041F7E
0B207D C4          3677**  	db 0xc4 ; 041F7F
0B207E 80          3678**  	db 0x80 ; 041F80
0B207F 41          3679**  	db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
0B2080 44          3680**  	db 0x44 ; 041F82
0B2081 C3          3681**  	db 0xc3 ; 041F83
0B2082 88          3682**  	db 0x88 ; 041F84
0B2083 53          3683**  	db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
0B2084 42          3684**  	db 0x42 ; 041F86
0B2085 C3          3685**  	db 0xc3 ; 041F87
0B2086 98          3686**  	db 0x98 ; 041F88
0B2087             3687**  ;
0B2087             3688**  ; Group 7: (2 opcodes)
0B2087             3689**  ;
0B2087 49          3690**  	db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
0B2088 4E          3691**  	db 0x4e ; 041F8A
0B2089 C3          3692**  	db 0xc3 ; 041F8B
0B208A 04          3693**  	db 0x04 ; 041F8C
0B208B 44          3694**  	db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
0B208C 45          3695**  	db 0x45 ; 041F8E
0B208D C3          3696**  	db 0xc3 ; 041F8F
0B208E 05          3697**  	db 0x05 ; 041F90
0B208F             3698**  ;
0B208F             3699**  ; Group 8: (2 opcodes)
0B208F             3700**  ;
0B208F 49          3701**  	db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
0B2090 4E          3702**  	db 0x4e ; 041F92
0B2091 B0          3703**  	db 0xb0 ; 041F93
0B2092 00          3704**  	db 0x00 ; 041F94
0B2093 4F          3705**  	db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
0B2094 55          3706**  	db 0x55 ; 041F96
0B2095 54          3707**  	db 0x54 ; 041F97
0B2096 B0          3708**  	db 0xb0 ; 041F98
0B2097 01          3709**  	db 0x01 ; 041F99
0B2098             3710**  ;
0B2098             3711**  ; Group 9: (1 opcode)
0B2098             3712**  ;
0B2098 49          3713**  	db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
0B2099 CE          3714**  	db 0xce ; 041F9B
0B209A 40          3715**  	db 0x40 ; 041F9C
0B209B             3716**  ;
0B209B             3717**  ; Group 10: (1 opcode)
0B209B             3718**  ;
0B209B 4F          3719**  	db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
0B209C 55          3720**  	db 0x55 ; 041F9E
0B209D D4          3721**  	db 0xd4 ; 041F9F
0B209E 41          3722**  	db 0x41 ; 041FA0
0B209F             3723**  ;
0B209F             3724**  ; Group 11: (2 opcodes)
0B209F             3725**  ;
0B209F 4A          3726**  	db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
0B20A0 D2          3727**  	db 0xd2 ; 041FA2
0B20A1 20          3728**  	db 0x20 ; 041FA3
0B20A2 44          3729**  	db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
0B20A3 4A          3730**  	db 0x4a ; 041FA5
0B20A4 4E          3731**  	db 0x4e ; 041FA6
0B20A5 DA          3732**  	db 0xda ; 041FA7
0B20A6 10          3733**  	db 0x10 ; 041FA8
0B20A7             3734**  ;
0B20A7             3735**  ; Group 12: (1 opcode)
0B20A7             3736**  ;
0B20A7 4A          3737**  	db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
0B20A8 D0          3738**  	db 0xd0 ; 041FAA
0B20A9 C2          3739**  	db 0xc2 ; 041FAB
0B20AA             3740**  ;
0B20AA             3741**  ; Group 13: (1 opcode)
0B20AA             3742**  ;
0B20AA 43          3743**  	db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
0B20AB 41          3744**  	db 0x41 ; 041FAD
0B20AC 4C          3745**  	db 0x4c ; 041FAE
0B20AD CC          3746**  	db 0xcc ; 041FAF
0B20AE C4          3747**  	db 0xc4 ; 041FB0
0B20AF             3748**  ;
0B20AF             3749**  ; Group 14: (1 opcode)
0B20AF             3750**  ;
0B20AF 52          3751**  	db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
0B20B0 53          3752**  	db 0x53 ; 041FB2
0B20B1 D4          3753**  	db 0xd4 ; 041FB3
0B20B2 C7          3754**  	db 0xc7 ; 041FB4
0B20B3             3755**  ;
0B20B3             3756**  ; Group 15: (1 opcode)
0B20B3             3757**  ;
0B20B3 52          3758**  	db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
0B20B4 45          3759**  	db 0x45 ; 041FB6
0B20B5 D4          3760**  	db 0xd4 ; 041FB7
0B20B6 C0          3761**  	db 0xc0 ; 041FB8
0B20B7             3762**  ;
0B20B7             3763**  ; Group 16: (1 opcode)
0B20B7             3764**  ;
0B20B7 4C          3765**  	db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
0B20B8 C4          3766**  	db 0xc4 ; 041FBA
0B20B9 40          3767**  	db 0x40 ; 041FBB
0B20BA             3768**  ;
0B20BA             3769**  ; Group 17: (1 opcode)
0B20BA             3770**  ;
0B20BA 54          3771**  	db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
0B20BB 53          3772**  	db 0x53 ; 041FBD
0B20BC D4          3773**  	db 0xd4 ; 041FBE
0B20BD 04          3774**  	db 0x04 ; 041FBF
0B20BE             3775**  ;
0B20BE             3776**  ; Assembler Directives
0B20BE             3777**  ;
0B20BE 4F          3778**  	db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
0B20BF 50          3779**  	db 0x50 ; 041FC1
0B20C0 D4          3780**  	db 0xd4 ; 041FC2
0B20C1 00          3781**  	db 0x00 ; 041FC3
0B20C2 41          3782**  	db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
0B20C3 44          3783**  	db 0x44 ; 041FC5
0B20C4 CC          3784**  	db 0xcc ; 041FC6
0B20C5 00          3785**  	db 0x00 ; 041FC7
0B20C6 5D          3786**  	db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
0B20C7 C2          3787**  	db 0xc2 ; 041FC9
0B20C8 00          3788**  	db 0x00 ; 041FCA
0B20C9 5D          3789**  	db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
0B20CA D7          3790**  	db 0xd7 ; 041FCC
0B20CB 00          3791**  	db 0x00 ; 041FCD
0B20CC 5D          3792**  	db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
0B20CD CC          3793**  	db 0xcc ; 041FCF
0B20CE 00          3794**  	db 0x00 ; 041FD0
0B20CF 5D          3795**  	db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
0B20D0 CD          3796**  	db 0xcd ; 041FD2
0B20D1 00          3797**  	db 0x00 ; 041FD3
0B20D2 00          3798**  	db 0x00 ; 041FD4 00      5426 DB	0
0B20D3             3799**  ;
0B20D3             3800**  ; Operands
0B20D3             3801**  ;
0B20D3             3802**  OPRNDS:
0B20D3 C2          3803**  	db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
0B20D4 00          3804**  	db 0x00 ; 041FD6
0B20D5 C3          3805**  	db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
0B20D6 01          3806**  	db 0x01 ; 041FD8
0B20D7 C4          3807**  	db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
0B20D8 02          3808**  	db 0x02 ; 041FDA
0B20D9 C5          3809**  	db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
0B20DA 03          3810**  	db 0x03 ; 041FDC
0B20DB C8          3811**  	db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
0B20DC 04          3812**  	db 0x04 ; 041FDE
0B20DD CC          3813**  	db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
0B20DE 05          3814**  	db 0x05 ; 041FE0
0B20DF 28          3815**  	db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
0B20E0 48          3816**  	db 0x48 ; 041FE2
0B20E1 CC          3817**  	db 0xcc ; 041FE3
0B20E2 06          3818**  	db 0x06 ; 041FE4
0B20E3 C1          3819**  	db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
0B20E4 07          3820**  	db 0x07 ; 041FE6
0B20E5 28          3821**  	db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
0B20E6 49          3822**  	db 0x49 ; 041FE8
0B20E7 D8          3823**  	db 0xd8 ; 041FE9
0B20E8 86          3824**  	db 0x86 ; 041FEA
0B20E9 28          3825**  	db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
0B20EA 49          3826**  	db 0x49 ; 041FEC
0B20EB D9          3827**  	db 0xd9 ; 041FED
0B20EC C6          3828**  	db 0xc6 ; 041FEE
0B20ED 42          3829**  	db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
0B20EE C3          3830**  	db 0xc3 ; 041FF0
0B20EF 08          3831**  	db 0x08 ; 041FF1
0B20F0 44          3832**  	db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
0B20F1 C5          3833**  	db 0xc5 ; 041FF3
0B20F2 0A          3834**  	db 0x0a ; 041FF4
0B20F3 48          3835**  	db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
0B20F4 CC          3836**  	db 0xcc ; 041FF6
0B20F5 0C          3837**  	db 0x0c ; 041FF7
0B20F6 49          3838**  	db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
0B20F7 D8          3839**  	db 0xd8 ; 041FF9
0B20F8 8C          3840**  	db 0x8c ; 041FFA
0B20F9 49          3841**  	db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
0B20FA D9          3842**  	db 0xd9 ; 041FFC
0B20FB CC          3843**  	db 0xcc ; 041FFD
0B20FC 41          3844**  	db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
0B20FD C6          3845**  	db 0xc6 ; 041FFF
0B20FE 0E          3846**  	db 0x0e ; 042000
0B20FF 53          3847**  	db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
0B2100 D0          3848**  	db 0xd0 ; 042002
0B2101 0E          3849**  	db 0x0e ; 042003
0B2102 4E          3850**  	db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
0B2103 DA          3851**  	db 0xda ; 042005
0B2104 10          3852**  	db 0x10 ; 042006
0B2105 DA          3853**  	db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
0B2106 11          3854**  	db 0x11 ; 042008
0B2107 4E          3855**  	db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
0B2108 C3          3856**  	db 0xc3 ; 04200A
0B2109 12          3857**  	db 0x12 ; 04200B
0B210A 50          3858**  	db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
0B210B CF          3859**  	db 0xcf ; 04200D
0B210C 14          3860**  	db 0x14 ; 04200E
0B210D 50          3861**  	db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
0B210E C5          3862**  	db 0xc5 ; 042010
0B210F 15          3863**  	db 0x15 ; 042011
0B2110 D0          3864**  	db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
0B2111 16          3865**  	db 0x16 ; 042013
0B2112 CD          3866**  	db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
0B2113 17          3867**  	db 0x17 ; 042015
0B2114 28          3868**  	db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
0B2115 C3          3869**  	db 0xc3 ; 042017
0B2116 20          3870**  	db 0x20 ; 042018
0B2117 00          3871**  	db 0x00 ; 042019 00      5459 DB	0
0B2118             3872**  ;
0B2118             3873**  ; Load operations
0B2118             3874**  ;
0B2118             3875**  LDOPS:
0B2118 49          3876**  	db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
0B2119 00          3877**  	db 0x00 ; 04201B
0B211A C1          3878**  	db 0xc1 ; 04201C
0B211B 47          3879**  	db 0x47 ; 04201D
0B211C 52          3880**  	db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
0B211D 00          3881**  	db 0x00 ; 04201F
0B211E C1          3882**  	db 0xc1 ; 042020
0B211F 4F          3883**  	db 0x4f ; 042021
0B2120 41          3884**  	db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
0B2121 00          3885**  	db 0x00 ; 042023
0B2122 C9          3886**  	db 0xc9 ; 042024
0B2123 57          3887**  	db 0x57 ; 042025
0B2124 41          3888**  	db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
0B2125 00          3889**  	db 0x00 ; 042027
0B2126 D2          3890**  	db 0xd2 ; 042028
0B2127 5F          3891**  	db 0x5f ; 042029
0B2128 28          3892**  	db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
0B2129 42          3893**  	db 0x42 ; 04202B
0B212A 43          3894**  	db 0x43 ; 04202C
0B212B 00          3895**  	db 0x00 ; 04202D
0B212C C1          3896**  	db 0xc1 ; 04202E
0B212D 02          3897**  	db 0x02 ; 04202F
0B212E 28          3898**  	db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
0B212F 44          3899**  	db 0x44 ; 042031
0B2130 45          3900**  	db 0x45 ; 042032
0B2131 00          3901**  	db 0x00 ; 042033
0B2132 C1          3902**  	db 0xc1 ; 042034
0B2133 12          3903**  	db 0x12 ; 042035
0B2134 41          3904**  	db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
0B2135 00          3905**  	db 0x00 ; 042037
0B2136 28          3906**  	db 0x28 ; 042038
0B2137 42          3907**  	db 0x42 ; 042039
0B2138 C3          3908**  	db 0xc3 ; 04203A
0B2139 0A          3909**  	db 0x0a ; 04203B
0B213A 41          3910**  	db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
0B213B 00          3911**  	db 0x00 ; 04203D
0B213C 28          3912**  	db 0x28 ; 04203E
0B213D 44          3913**  	db 0x44 ; 04203F
0B213E C5          3914**  	db 0xc5 ; 042040
0B213F 1A          3915**  	db 0x1a ; 042041
0B2140 00          3916**  	db 0x00 ; 042042 00      5472 DB	0
0B2141             3917**  ;
0B2141             3918**  ; eZ80 addressing mode suffixes
0B2141             3919**  ;
0B2141             3920**  ; Fully qualified suffixes
0B2141             3921**  ;
0B2141             3922**  EZ80SFS_1:
0B2141 4C          3923**  	db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
0B2142 49          3924**  	db 0x49 ; 042044
0B2143 D3          3925**  	db 0xd3 ; 042045
0B2144 49          3926**  	db 0x49 ; 042046
0B2145 53          3927**  	db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
0B2146 49          3928**  	db 0x49 ; 042048
0B2147 CC          3929**  	db 0xcc ; 042049
0B2148 52          3930**  	db 0x52 ; 04204A
0B2149             3931**  
0B2149             3932**  EZ80SFS_2:
0B2149 53          3933**  	db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
0B214A 49          3934**  	db 0x49 ; 04204C
0B214B D3          3935**  	db 0xd3 ; 04204D
0B214C 40          3936**  	db 0x40 ; 04204E
0B214D 4C          3937**  	db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
0B214E 49          3938**  	db 0x49 ; 042050
0B214F CC          3939**  	db 0xcc ; 042051
0B2150 5B          3940**  	db 0x5b ; 042052
0B2151 00          3941**  	db 0x00 ; 042053 00      5483 DB	0
0B2152             3942**  ;
0B2152             3943**  ; Shortcuts when ADL mode is 0
0B2152             3944**  ;
0B2152             3945**  EZ80SFS_ADL0:
0B2152 D3          3946**  	db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0B2153 40          3947**  	db 0x40 ; 042055
0B2154 CC          3948**  	db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
0B2155 49          3949**  	db 0x49 ; 042057
0B2156 49          3950**  	db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
0B2157 D3          3951**  	db 0xd3 ; 042059
0B2158 40          3952**  	db 0x40 ; 04205A
0B2159 49          3953**  	db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
0B215A CC          3954**  	db 0xcc ; 04205C
0B215B 52          3955**  	db 0x52 ; 04205D
0B215C 00          3956**  	db 0x00 ; 04205E 00      5492 DB	0
0B215D             3957**  ;
0B215D             3958**  ; Shortcuts when ADL mode is 1
0B215D             3959**  ;
0B215D             3960**  EZ80SFS_ADL1:
0B215D D3          3961**  	db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0B215E 52          3962**  	db 0x52 ; 042060
0B215F CC          3963**  	db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
0B2160 5B          3964**  	db 0x5b ; 042062
0B2161 49          3965**  	db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
0B2162 D3          3966**  	db 0xd3 ; 042064
0B2163 49          3967**  	db 0x49 ; 042065
0B2164 49          3968**  	db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
0B2165 CC          3969**  	db 0xcc ; 042067
0B2166 5B          3970**  	db 0x5b ; 042068
0B2167 00          3971**  	db 0x00 ; 042069 00      5501 DB	0
0B2168             3972**  ; END INSERT FROM BINARY
0B2168             3973**  ;
0B2168             3974**  ; .LIST
0B2168             3975**  ;
0B2168             3976**  ; already defined in equs.inc
0B2168             3977**  ; LF:			EQU     0AH
0B2168             3978**  ; CR:			EQU     0DH
0B2168             0007*       include "basic/fpp.asm"
0B2168             0001**  ;
0B2168             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B2168             0003**  ;		Z80 Floating Point Package
0B2168             0004**  ; Author:	(C) Copyright  R.T.Russell  1986
0B2168             0005**  ; Modified By:	Dean Belfield
0B2168             0006**  ; Created:	03/05/2022
0B2168             0007**  ; Last Updated:	07/06/2023
0B2168             0008**  ;
0B2168             0009**  ; Modinfo:
0B2168             0010**  ; 26/10/1986:	Version 0.0
0B2168             0011**  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0B2168             0012**  ; 12/05/2023:	Modified by Dean Belfield
0B2168             0013**  ; 07/06/2023:	Modified to run in ADL mode
0B2168             0014**  
0B2168             0015**  			; .ASSUME	ADL = 1
0B2168             0016**  
0B2168             0017**  			; SEGMENT CODE
0B2168             0018**  
0B2168             0019**  			; XDEF	FPP
0B2168             0020**  			; XDEF	DLOAD5
0B2168             0021**  			; XDEF	DLOAD5_SPL
0B2168             0022**  ;
0B2168             0023**  ;BINARY FLOATING POINT REPRESENTATION:
0B2168             0024**  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B2168             0025**  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0B2168             0026**  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B2168             0027**  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B2168             0028**  ;
0B2168             0029**  ;BINARY INTEGER REPRESENTATION:
0B2168             0030**  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B2168             0031**  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B2168             0032**  ;
0B2168             0033**  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B2168             0034**  ;                            EXPONENT - C
0B2168             0035**  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0B2168             0036**  ;                               EXPONENT - B
0B2168             0037**  
0B2168             0038**  ;
0B2168             0039**  ;Error codes:
0B2168             0040**  ;
0B2168             0041**  
0B2168             0042**  BADOP:			EQU     1               ;Bad operation code
0B2168             0043**  DIVBY0:			EQU     18              ;Division by zero
0B2168             0044**  TOOBIG_FP:			EQU     20              ;Too big
0B2168             0045**  NGROOT:			EQU     21              ;Negative root
0B2168             0046**  LOGRNG:			EQU     22              ;Log range
0B2168             0047**  ACLOST:			EQU     23              ;Accuracy lost
0B2168             0048**  EXPRNG:			EQU     24              ;Exp range
0B2168             0049**  ;
0B2168             0050**  ;Call entry and despatch code:
0B2168             0051**  ;
0B2168 FD E5       0052**  FPP:			PUSH    IY              ;Save IY
0B216A FD 21 00 00 0053**          		LD      IY,0
       00          
0B216F FD 39       0054**          		ADD     IY,SP           ;Save SP in IY
0B2171 CD 81 21 0B 0055**          		CALL    OP              ;Perform operation
0B2175 BF          0056**          		CP      A               ;Good return (Z, NC)
0B2176 FD E1       0057**  EXIT_FP_:			POP     IY              ;Restore IY
0B2178 C9          0058**          		RET                     ;Return to caller
0B2179             0059**  ;
0B2179             0060**  ;Error exit:
0B2179             0061**  ;
0B2179 3E 01       0062**  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B217B FD F9       0063**  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B217D B7          0064**          		OR      A               ;Set NZ
0B217E 37          0065**          		SCF                     ;Set C
0B217F 18 F5       0066**          		JR      EXIT_FP_
0B2181             0067**  ;
0B2181             0068**  ;Perform operation or function:
0B2181             0069**  ;
0B2181             0070**  ; OP:			CP      (RTABLE-DTABLE)/3
0B2181 FE 2A       0071**  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2183             0072**  
0B2183 30 F4       0073**          		JR      NC,BAD_FP
0B2185             0074**          		; CP      (FTABLE-DTABLE)/3
0B2185 FE 10       0075**  				CP      FTABLE-DTABLE/3 ; ditto
0B2187 30 08       0076**          		JR      NC,DISPAT_FP
0B2189 08          0077**          		EX      AF,AF'
0B218A 78          0078**          		LD      A,B
0B218B B1          0079**          		OR      C               ;Both integer?
0B218C C4 94 2C 0B 0080**          		CALL    NZ,FLOATA       ;No, so float both
0B2190 08          0081**          		EX      AF,AF'
0B2191 E5          0082**  DISPAT_FP:			PUSH    HL
0B2192 21 A4 21 0B 0083**          		LD      HL,DTABLE
0B2196 C5          0084**          		PUSH    BC
0B2197 01 03 00 00 0085**  			LD	BC, 3		; C = 3
0B219B 47          0086**  			LD	B, A 		; B = op-code
0B219C ED 4C       0087**  			MLT 	BC 		;BC = op-code * 3
0B219E 09          0088**  			ADD	HL, BC 		;Add to table base
0B219F ED 27       0089**  			LD	HL, (HL)	;Get the routine address (24-bit)
0B21A1             0090**  
0B21A1             0091**  ;        		ADD     A, A            ;A = op-code * 2
0B21A1             0092**  ;        		LD      C,A
0B21A1             0093**  ;        		LD      B,0             ;BC = op-code * 2
0B21A1             0094**  ;        		ADD     HL,BC
0B21A1             0095**  ;        		LD      A,(HL)          ;Get low byte
0B21A1             0096**  ;        		INC     HL
0B21A1             0097**  ;        		LD      H,(HL)          ;Get high byte
0B21A1             0098**  ;        		LD      L,A
0B21A1             0099**  
0B21A1 C1          0100**          		POP     BC
0B21A2 E3          0101**          		EX      (SP),HL
0B21A3 C9          0102**          		RET                     ;Off to routine
0B21A4             0103**  ;
0B21A4             0104**  ;Despatch table:
0B21A4             0105**  ;
0B21A4 56 22 0B    0106**  DTABLE:			DW24  IAND            ;AND (INTEGER)
0B21A7 C4 22 0B    0107**          		DW24  IBDIV           ;DIV
0B21AA 69 22 0B    0108**          		DW24  IEOR            ;EOR
0B21AD 8F 22 0B    0109**          		DW24  IMOD            ;MOD
0B21B0 7C 22 0B    0110**          		DW24  IOR             ;OR
0B21B3 4A 25 0B    0111**          		DW24  ILE             ;<=
0B21B6 59 25 0B    0112**          		DW24  INE             ;<>
0B21B9 3D 25 0B    0113**          		DW24  IGE             ;>=
0B21BC 22 25 0B    0114**          		DW24  ILT             ;<
0B21BF 66 25 0B    0115**          		DW24  IEQ             ;=
0B21C2 B2 23 0B    0116**          		DW24  IMUL            ;*
0B21C5 ED 22 0B    0117**          		DW24  IADD            ;+
0B21C8 2F 25 0B    0118**          		DW24  IGT             ;>
0B21CB D4 22 0B    0119**          		DW24  ISUB            ;-
0B21CE 69 24 0B    0120**          		DW24  IPOW            ;^
0B21D1 5F 23 0B    0121**          		DW24  IDIV            ;/
0B21D4             0122**  ;
0B21D4             0123**  FTABLE:
0B21D4 78 25 0B    0124**  				DW24  ABSV_FP            ;ABS
0B21D7 5E 29 0B    0125**          		DW24  ACS_FP             ;ACS
0B21DA 9C 28 0B    0126**          		DW24  ASN_FP             ;ASN
0B21DD CC 28 0B    0127**          		DW24  ATN_FP             ;ATN
0B21E0 97 26 0B    0128**          		DW24  COS_FP             ;COS
0B21E3 A6 25 0B    0129**          		DW24  DEG_FP             ;DEG
0B21E6 53 27 0B    0130**          		DW24  EXP_FP             ;EXP
0B21E9 FA 25 0B    0131**          		DW24  INT_FP_            ;INT
0B21EC F1 27 0B    0132**          		DW24  LN_FP              ;LN
0B21EF 86 28 0B    0133**          		DW24  LOG_FP             ;LOG
0B21F2 84 25 0B    0134**          		DW24  NOTK_FP            ;NOT
0B21F5 B0 25 0B    0135**          		DW24  RAD_FP             ;RAD
0B21F8 CB 25 0B    0136**          		DW24  SGN_FP             ;SGN
0B21FB A4 26 0B    0137**          		DW24  SIN_FP             ;SIN
0B21FE 13 26 0B    0138**          		DW24  SQR_FP             ;SQR
0B2201 71 26 0B    0139**          		DW24  TAN_FP             ;TAN
0B2204             0140**  ;
0B2204 21 2D 0B    0141**  		        DW24  ZERO_FP            ;ZERO
0B2207 2C 27 0B    0142**          		DW24  FONE_FP            ;FONE
0B220A 6B 25 0B    0143**          		DW24  TRUE_FP            ;TRUE
0B220D 98 25 0B    0144**          		DW24  PI_FP              ;PI
0B2210             0145**  ;
0B2210 DF 25 0B    0146**  		        DW24  VAL_FP             ;VAL
0B2213 67 29 0B    0147**          		DW24  STR_FP             ;STR$
0B2216             0148**  ;
0B2216 C8 2B 0B    0149**          		DW24  SFIX_FP            ;FIX
0B2219 A4 2C 0B    0150**          		DW24  SFLOAT_FP          ;FLOAT
0B221C             0151**  ;
0B221C F2 2C 0B    0152**  		        DW24  FTEST_FP           ;TEST
0B221F 04 2D 0B    0153**          		DW24  FCOMP_FP           ;COMPARE
0B2222             0154**  ;
0B2222 52 22 0B    0155**  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B2225 C0 22 0B    0156**          		DW24  FBDIV           ;DIV
0B2228 65 22 0B    0157**          		DW24  FEOR            ;EOR
0B222B 8B 22 0B    0158**          		DW24  FMOD            ;MOD
0B222E 78 22 0B    0159**          		DW24  FFOR             ;OR
0B2231 44 25 0B    0160**          		DW24  FLE             ;<=
0B2234 53 25 0B    0161**          		DW24  FNE             ;<>
0B2237 37 25 0B    0162**          		DW24  FGE             ;>=
0B223A 1C 25 0B    0163**          		DW24  FLT             ;<
0B223D 60 25 0B    0164**          		DW24  FEQ             ;=
0B2240 0C 24 0B    0165**          		DW24  FMUL            ;*
0B2243 FA 22 0B    0166**          		DW24  FADD            ;+
0B2246 29 25 0B    0167**          		DW24  FGT             ;>
0B2249 E1 22 0B    0168**          		DW24  FSUB            ;-
0B224C E9 24 0B    0169**          		DW24  FPOW            ;^
0B224F 63 23 0B    0170**          		DW24  FDIV            ;/
0B2252             0171**  ;
0B2252             0172**  ;       PAGE
0B2252             0173**  ;
0B2252             0174**  ;ARITHMETIC AND LOGICAL OPERATORS:
0B2252             0175**  ;All take two arguments, in HLH'L'C & DED'E'B.
0B2252             0176**  ;Output in HLH'L'C
0B2252             0177**  ;All registers except IX, IY destroyed.
0B2252             0178**  ; (N.B. FPOW destroys IX).
0B2252             0179**  ;
0B2252             0180**  ;FAND - Floating-point AND.
0B2252             0181**  ;IAND - Integer AND.
0B2252             0182**  ;
0B2252 CD BC 2B 0B 0183**  FAND:			CALL    FIX2
0B2256 7C          0184**  IAND:			LD      A,H
0B2257 A2          0185**          		AND     D
0B2258 67          0186**          		LD      H,A
0B2259 7D          0187**          		LD      A,L
0B225A A3          0188**          		AND     E
0B225B 6F          0189**          		LD      L,A
0B225C D9          0190**          		EXX
0B225D 7C          0191**          		LD      A,H
0B225E A2          0192**          		AND     D
0B225F 67          0193**          		LD      H,A
0B2260 7D          0194**          		LD      A,L
0B2261 A3          0195**          		AND     E
0B2262 6F          0196**          		LD      L,A
0B2263 D9          0197**          		EXX
0B2264 C9          0198**          		RET
0B2265             0199**  ;
0B2265             0200**  ;FEOR - Floating-point exclusive-OR.
0B2265             0201**  ;IEOR - Integer exclusive-OR.
0B2265             0202**  ;
0B2265 CD BC 2B 0B 0203**  FEOR:			CALL    FIX2
0B2269 7C          0204**  IEOR:			LD      A,H
0B226A AA          0205**          		XOR     D
0B226B 67          0206**          		LD      H,A
0B226C 7D          0207**          		LD      A,L
0B226D AB          0208**          		XOR     E
0B226E 6F          0209**          		LD      L,A
0B226F D9          0210**          		EXX
0B2270 7C          0211**          		LD      A,H
0B2271 AA          0212**          		XOR     D
0B2272 67          0213**          		LD      H,A
0B2273 7D          0214**          		LD      A,L
0B2274 AB          0215**          		XOR     E
0B2275 6F          0216**          		LD      L,A
0B2276 D9          0217**          		EXX
0B2277 C9          0218**          		RET
0B2278             0219**  ;
0B2278             0220**  ;FOR - Floating-point OR.
0B2278             0221**  ;IOR - Integer OR.
0B2278             0222**  ;
0B2278 CD BC 2B 0B 0223**  FFOR:			CALL    FIX2
0B227C 7C          0224**  IOR:			LD      A,H
0B227D B2          0225**          		OR      D
0B227E 67          0226**          		LD      H,A
0B227F 7D          0227**          		LD      A,L
0B2280 B3          0228**          		OR      E
0B2281 6F          0229**          		LD      L,A
0B2282 D9          0230**          		EXX
0B2283 7C          0231**          		LD      A,H
0B2284 B2          0232**          		OR      D
0B2285 67          0233**          		LD      H,A
0B2286 7D          0234**          		LD      A,L
0B2287 B3          0235**          		OR      E
0B2288 6F          0236**          		LD      L,A
0B2289 D9          0237**          		EXX
0B228A C9          0238**          		RET
0B228B             0239**  ;
0B228B             0240**  ;FMOD - Floating-point remainder.
0B228B             0241**  ;IMOD - Integer remainder.
0B228B             0242**  ;
0B228B CD BC 2B 0B 0243**  FMOD:			CALL    FIX2
0B228F 7C          0244**  IMOD:			LD      A,H
0B2290 AA          0245**          		XOR     D               ;DIV RESULT SIGN
0B2291 CB 7C       0246**          		BIT     7,H
0B2293 08          0247**          		EX      AF,AF'
0B2294 CB 7C       0248**          		BIT     7,H
0B2296 C4 D8 2B 0B 0249**          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B229A CD D5 2C 0B 0250**          		CALL    SWAP_FP
0B229E CB 7C       0251**          		BIT     7,H
0B22A0 C4 D8 2B 0B 0252**          		CALL    NZ,NEGATE
0B22A4 44          0253**          		LD      B,H
0B22A5 4D          0254**          		LD      C,L
0B22A6 21 00 00 00 0255**          		LD      HL,0
0B22AA D9          0256**          		EXX
0B22AB 44          0257**          		LD      B,H
0B22AC 4D          0258**          		LD      C,L
0B22AD 21 00 00 00 0259**          		LD      HL,0
0B22B1 3E DF       0260**          		LD      A,-33
0B22B3 CD 62 2E 0B 0261**          		CALL    DIVA            ;DIVIDE
0B22B7 D9          0262**          		EXX
0B22B8 0E 00       0263**          		LD      C,0             ;INTEGER MARKER
0B22BA 08          0264**          		EX      AF,AF'
0B22BB C8          0265**          		RET     Z
0B22BC C3 D8 2B 0B 0266**          		JP      NEGATE
0B22C0             0267**  ;
0B22C0             0268**  ;BDIV - Integer division.
0B22C0             0269**  ;
0B22C0 CD BC 2B 0B 0270**  FBDIV:			CALL    FIX2
0B22C4 CD 8F 22 0B 0271**  IBDIV:			CALL    IMOD
0B22C8 B7          0272**          		OR      A
0B22C9 CD D5 2C 0B 0273**          		CALL    SWAP_FP
0B22CD 0E 00       0274**          		LD      C,0
0B22CF F0          0275**          		RET     P
0B22D0 C3 D8 2B 0B 0276**          		JP      NEGATE
0B22D4             0277**  ;
0B22D4             0278**  ;ISUB - Integer subtraction.
0B22D4             0279**  ;FSUB - Floating point subtraction with rounding.
0B22D4             0280**  ;
0B22D4 CD 70 2D 0B 0281**  ISUB:			CALL    SUB_
0B22D8 E0          0282**          		RET     PO
0B22D9 CD 68 2D 0B 0283**          		CALL    ADD_
0B22DD CD 98 2C 0B 0284**          		CALL    FLOAT2
0B22E1 7A          0285**  FSUB:			LD      A,D
0B22E2 EE 80       0286**          		XOR     80H             ;CHANGE SIGN THEN ADD
0B22E4 57          0287**          		LD      D,A
0B22E5 18 13       0288**          		JR      FADD
0B22E7             0289**  ;
0B22E7             0290**  ;Reverse subtract.
0B22E7             0291**  ;
0B22E7 7C          0292**  RSUB:			LD      A,H
0B22E8 EE 80       0293**          		XOR     80H
0B22EA 67          0294**          		LD      H,A
0B22EB 18 0D       0295**          		JR      FADD
0B22ED             0296**  ;
0B22ED             0297**  ;IADD - Integer addition.
0B22ED             0298**  ;FADD - Floating point addition with rounding.
0B22ED             0299**  ;
0B22ED CD 68 2D 0B 0300**  IADD:			CALL    ADD_
0B22F1 E0          0301**          		RET     PO
0B22F2 CD 70 2D 0B 0302**          		CALL    SUB_
0B22F6 CD 98 2C 0B 0303**          		CALL    FLOAT2
0B22FA 05          0304**  FADD:			DEC     B
0B22FB 04          0305**          		INC     B
0B22FC C8          0306**          		RET     Z               ;ARG 2 ZERO
0B22FD 0D          0307**          		DEC     C
0B22FE 0C          0308**          		INC     C
0B22FF CA D5 2C 0B 0309**          		JP      Z,SWAP_FP          ;ARG 1 ZERO
0B2303 D9          0310**          		EXX
0B2304 01 00 00 00 0311**          		LD      BC,0            ;INITIALISE
0B2308 D9          0312**          		EXX
0B2309 7C          0313**          		LD      A,H
0B230A AA          0314**          		XOR     D               ;XOR SIGNS
0B230B F5          0315**          		PUSH    AF
0B230C 78          0316**          		LD      A,B
0B230D B9          0317**          		CP      C               ;COMPARE EXPONENTS
0B230E DC D5 2C 0B 0318**          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B2312 78          0319**          		LD      A,B
0B2313 CB FC       0320**          		SET     7,H             ;IMPLIED 1
0B2315 C4 A9 2B 0B 0321**          		CALL    NZ,FIX          ;ALIGN
0B2319 F1          0322**          		POP     AF
0B231A 7A          0323**          		LD      A,D             ;SIGN OF LARGER
0B231B CB FA       0324**          		SET     7,D             ;IMPLIED 1
0B231D FA 2D 23 0B 0325**          		JP      M,FADD3         ;SIGNS DIFFERENT
0B2321 CD 68 2D 0B 0326**          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B2325 DC DD 2C 0B 0327**          		CALL    C,DIV2          ;NORMALISE
0B2329 CB FC       0328**          		SET     7,H
0B232B 18 0D       0329**          		JR      FADD4
0B232D             0330**  ;
0B232D CD 70 2D 0B 0331**  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B2331 DC F0 2B 0B 0332**          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B2335 CD 6F 2C 0B 0333**          		CALL    FLO48
0B2339 2F          0334**          		CPL                     ;CHANGE RESULT SIGN
0B233A D9          0335**  FADD4:			EXX
0B233B EB          0336**          		EX      DE,HL
0B233C 21 00 80 00 0337**          		LD      HL,8000H
0B2340 B7          0338**          		OR      A               ;CLEAR CARRY
0B2341 52 ED 42    0339**          		SBC.S   HL,BC
0B2344 EB          0340**          		EX      DE,HL
0B2345 D9          0341**          		EXX
0B2346 CC CF 2C 0B 0342**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B234A DC BD 2C 0B 0343**          		CALL    C,ADD1_FP          ;ROUND UP
0B234E DC EA 2C 0B 0344**          		CALL    C,INCC
0B2352 CB BC       0345**          		RES     7,H
0B2354 0D          0346**          		DEC     C
0B2355 0C          0347**          		INC     C
0B2356 CA 21 2D 0B 0348**          		JP      Z,ZERO_FP
0B235A B7          0349**          		OR      A               ;RESULT SIGNQ
0B235B F0          0350**          		RET     P               ;POSITIVE
0B235C CB FC       0351**          		SET     7,H             ;NEGATIVE
0B235E C9          0352**          		RET
0B235F             0353**  ;
0B235F             0354**  ;IDIV - Integer division.
0B235F             0355**  ;FDIV - Floating point division with rounding.
0B235F             0356**  ;
0B235F CD 98 2C 0B 0357**  IDIV:			CALL    FLOAT2
0B2363 05          0358**  FDIV:			DEC     B               ;TEST FOR ZERO
0B2364 04          0359**          		INC     B
0B2365 3E 12       0360**          		LD      A,DIVBY0
0B2367 CA 7B 21 0B 0361**          		JP      Z,ERROR_FP_         ;"Division by zero"
0B236B 0D          0362**          		DEC     C               ;TEST FOR ZERO
0B236C 0C          0363**          		INC     C
0B236D C8          0364**          		RET     Z
0B236E 7C          0365**          		LD      A,H
0B236F AA          0366**          		XOR     D               ;CALC. RESULT SIGN
0B2370 08          0367**          		EX      AF,AF'          ;SAVE SIGN
0B2371 CB FA       0368**          		SET     7,D             ;REPLACE IMPLIED 1's
0B2373 CB FC       0369**          		SET     7,H
0B2375 C5          0370**          		PUSH    BC              ;SAVE EXPONENTS
0B2376 42          0371**          		LD      B,D             ;LOAD REGISTERS
0B2377 4B          0372**          		LD      C,E
0B2378 11 00 00 00 0373**          		LD      DE,0
0B237C D9          0374**          		EXX
0B237D 42          0375**          		LD      B,D
0B237E 4B          0376**          		LD      C,E
0B237F 11 00 00 00 0377**          		LD      DE,0
0B2383 3E E0       0378**          		LD      A,-32           ;LOOP COUNTER
0B2385 CD 62 2E 0B 0379**          		CALL    DIVA            ;DIVIDE
0B2389 D9          0380**          		EXX
0B238A CB 7A       0381**          		BIT     7,D
0B238C D9          0382**          		EXX
0B238D CC 81 2E 0B 0383**          		CALL    Z,DIVB          ;NORMALISE & INC A
0B2391 EB          0384**          		EX      DE,HL
0B2392 D9          0385**          		EXX
0B2393 CB 38       0386**          		SRL     B               ;DIVISOR/2
0B2395 CB 19       0387**          		RR      C
0B2397 B7          0388**          		OR      A               ;CLEAR CARRY
0B2398 52 ED 42    0389**          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B239B 3F          0390**          		CCF
0B239C EB          0391**          		EX      DE,HL           ;RESULT IN HLH'L'
0B239D CC CF 2C 0B 0392**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B23A1 DC BD 2C 0B 0393**          		CALL    C,ADD1_FP          ;ROUND UP
0B23A5 C1          0394**          		POP     BC              ;RESTORE EXPONENTS
0B23A6 DC EA 2C 0B 0395**          		CALL    C,INCC
0B23AA 1F          0396**          		RRA                     ;LSB OF A TO CARRY
0B23AB 79          0397**          		LD      A,C             ;COMPUTE NEW EXPONENT
0B23AC 98          0398**          		SBC     A,B
0B23AD 3F          0399**          		CCF
0B23AE C3 4F 24 0B 0400**          		JP      CHKOVF
0B23B2             0401**  ;
0B23B2             0402**  ;IMUL - Integer multiplication.
0B23B2             0403**  ;
0B23B2 7C          0404**  IMUL:			LD      A,H
0B23B3 AA          0405**          		XOR     D
0B23B4 08          0406**          		EX      AF,AF'          ;SAVE RESULT SIGN
0B23B5 CB 7C       0407**          		BIT     7,H
0B23B7 C4 D8 2B 0B 0408**          		CALL    NZ,NEGATE
0B23BB CD D5 2C 0B 0409**          		CALL    SWAP_FP
0B23BF CB 7C       0410**          		BIT     7,H
0B23C1 C4 D8 2B 0B 0411**          		CALL    NZ,NEGATE
0B23C5 44          0412**          		LD      B,H
0B23C6 4D          0413**          		LD      C,L
0B23C7 21 00 00 00 0414**          		LD      HL,0
0B23CB D9          0415**          		EXX
0B23CC 44          0416**          		LD      B,H
0B23CD 4D          0417**          		LD      C,L
0B23CE 21 00 00 00 0418**          		LD      HL,0
0B23D2 3E DF       0419**          		LD      A,-33
0B23D4 CD 99 2E 0B 0420**          		CALL    MULA            ;MULTIPLY
0B23D8 D9          0421**          		EXX
0B23D9 0E BF       0422**          		LD      C,191           ;PRESET EXPONENT
0B23DB CD FD 2C 0B 0423**          		CALL    TEST_FP            ;TEST RANGE
0B23DF 20 0F       0424**          		JR      NZ,IMUL1        ;TOO BIG
0B23E1 CB 7A       0425**          		BIT     7,D
0B23E3 20 0B       0426**          		JR      NZ,IMUL1
0B23E5 CD D5 2C 0B 0427**          		CALL    SWAP_FP
0B23E9 4A          0428**          		LD      C,D             ;INTEGER MARKER
0B23EA 08          0429**          		EX      AF,AF'
0B23EB F0          0430**          		RET     P
0B23EC C3 D8 2B 0B 0431**          		JP      NEGATE
0B23F0             0432**  ;
0B23F0 0D          0433**  IMUL1:			DEC     C
0B23F1 D9          0434**          		EXX
0B23F2 CB 23       0435**          		SLA     E
0B23F4 CB 12       0436**          		RL      D
0B23F6 D9          0437**          		EXX
0B23F7 CB 13       0438**          		RL      E
0B23F9 CB 12       0439**          		RL      D
0B23FB D9          0440**          		EXX
0B23FC 52 ED 6A    0441**          		ADC.S   HL,HL
0B23FF D9          0442**          		EXX
0B2400 52 ED 6A    0443**          		ADC.S   HL,HL
0B2403 F2 F0 23 0B 0444**          		JP      P,IMUL1         ;NORMALISE
0B2407 08          0445**          		EX      AF,AF'
0B2408 F8          0446**          		RET     M
0B2409 CB BC       0447**          		RES     7,H             ;POSITIVE
0B240B C9          0448**          		RET
0B240C             0449**  ;
0B240C             0450**  ;FMUL - Floating point multiplication with rounding.
0B240C             0451**  ;
0B240C 05          0452**  FMUL:			DEC     B               ;TEST FOR ZERO
0B240D 04          0453**          		INC     B
0B240E CA 21 2D 0B 0454**          		JP      Z,ZERO_FP
0B2412 0D          0455**          		DEC     C               ;TEST FOR ZERO
0B2413 0C          0456**          		INC     C
0B2414 C8          0457**          		RET     Z
0B2415 7C          0458**          		LD      A,H
0B2416 AA          0459**          		XOR     D               ;CALC. RESULT SIGN
0B2417 08          0460**          		EX      AF,AF'
0B2418 CB FA       0461**          		SET     7,D             ;REPLACE IMPLIED 1's
0B241A CB FC       0462**          		SET     7,H
0B241C C5          0463**          		PUSH    BC              ;SAVE EXPONENTS
0B241D 44          0464**          		LD      B,H             ;LOAD REGISTERS
0B241E 4D          0465**          		LD      C,L
0B241F 21 00 00 00 0466**          		LD      HL,0
0B2423 D9          0467**          		EXX
0B2424 44          0468**          		LD      B,H
0B2425 4D          0469**          		LD      C,L
0B2426 21 00 00 00 0470**          		LD      HL,0
0B242A 3E E0       0471**          		LD      A,-32           ;LOOP COUNTER
0B242C CD 99 2E 0B 0472**          		CALL    MULA            ;MULTIPLY
0B2430 DC AF 2E 0B 0473**          		CALL    C,MULB          ;NORMALISE & INC A
0B2434 D9          0474**          		EXX
0B2435 E5          0475**          		PUSH    HL
0B2436 21 00 80 00 0476**          		LD      HL,8000H
0B243A B7          0477**          		OR      A               ;CLEAR CARRY
0B243B 52 ED 52    0478**          		SBC.S   HL,DE
0B243E E1          0479**          		POP     HL
0B243F CC CF 2C 0B 0480**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B2443 DC BD 2C 0B 0481**          		CALL    C,ADD1_FP          ;ROUND UP
0B2447 C1          0482**          		POP     BC              ;RESTORE EXPONENTS
0B2448 DC EA 2C 0B 0483**          		CALL    C,INCC
0B244C 1F          0484**          		RRA                     ;LSB OF A TO CARRY
0B244D 79          0485**          		LD      A,C             ;COMPUTE NEW EXPONENT
0B244E 88          0486**          		ADC     A,B
0B244F 38 06       0487**  CHKOVF:			JR      C,CHKO1
0B2451 F2 21 2D 0B 0488**          		JP      P,ZERO_FP          ;UNDERFLOW
0B2455 18 04       0489**          		JR      CHKO2
0B2457 FA EC 2C 0B 0490**  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B245B C6 80       0491**  CHKO2:			ADD     A,80H
0B245D 4F          0492**          		LD      C,A
0B245E CA 21 2D 0B 0493**          		JP      Z,ZERO_FP
0B2462 08          0494**          		EX      AF,AF'          ;RESTORE SIGN BIT
0B2463 CB BC       0495**          		RES     7,H
0B2465 F0          0496**          		RET     P
0B2466 CB FC       0497**          		SET     7,H
0B2468 C9          0498**          		RET
0B2469             0499**  ;
0B2469             0500**  ;IPOW - Integer involution.
0B2469             0501**  ;
0B2469 CD D5 2C 0B 0502**  IPOW:			CALL    SWAP_FP
0B246D CB 7C       0503**          		BIT     7,H
0B246F F5          0504**          		PUSH    AF              ;SAVE SIGN
0B2470 C4 D8 2B 0B 0505**          		CALL    NZ,NEGATE
0B2474 48          0506**  IPOW0:			LD      C,B
0B2475 06 20       0507**          		LD      B,32            ;LOOP COUNTER
0B2477 CD 8D 2D 0B 0508**  IPOW1:			CALL    X2
0B247B 38 08       0509**          		JR      C,IPOW2
0B247D 10 F8       0510**          		DJNZ    IPOW1
0B247F F1          0511**          		POP     AF
0B2480 D9          0512**          		EXX
0B2481 2C          0513**          		INC     L               ;RESULT=1
0B2482 D9          0514**          		EXX
0B2483 4C          0515**          		LD      C,H
0B2484 C9          0516**          		RET
0B2485             0517**  ;
0B2485 F1          0518**  IPOW2:			POP     AF
0B2486 C5          0519**          		PUSH    BC
0B2487 EB          0520**          		EX      DE,HL
0B2488 E5          0521**          		PUSH    HL
0B2489 D9          0522**          		EXX
0B248A EB          0523**          		EX      DE,HL
0B248B E5          0524**          		PUSH    HL
0B248C D9          0525**          		EXX
0B248D DD 21 00 00 0526**          		LD      IX,0
       00          
0B2492 DD 39       0527**          		ADD     IX,SP
0B2494 28 48       0528**          		JR      Z,IPOW4
0B2496 C5          0529**          		PUSH    BC
0B2497 D9          0530**          		EXX
0B2498 D5          0531**          		PUSH    DE
0B2499 D9          0532**          		EXX
0B249A D5          0533**          		PUSH    DE
0B249B CD A4 2C 0B 0534**          		CALL    SFLOAT_FP
0B249F CD D8 27 0B 0535**          		CALL    RECIP
0B24A3 DD 71 04    0536**          		LD      (IX+4),C
0B24A6 D9          0537**          		EXX
0B24A7 DD 75 00    0538**          		LD      (IX+0),L
0B24AA DD 74 01    0539**          		LD      (IX+1),H
0B24AD D9          0540**          		EXX
0B24AE DD 75 02    0541**          		LD      (IX+2),L
0B24B1 DD 74 03    0542**          		LD      (IX+3),H
0B24B4 18 21       0543**          		JR      IPOW5
0B24B6             0544**  ;
0B24B6 C5          0545**  IPOW3:			PUSH    BC
0B24B7 D9          0546**          		EXX
0B24B8 CB 23       0547**          		SLA     E
0B24BA CB 12       0548**          		RL      D
0B24BC D5          0549**          		PUSH    DE
0B24BD D9          0550**          		EXX
0B24BE CB 13       0551**          		RL      E
0B24C0 CB 12       0552**          		RL      D
0B24C2 D5          0553**          		PUSH    DE
0B24C3 3E 0A       0554**          		LD      A,'*' & 0FH
0B24C5 F5          0555**          		PUSH    AF
0B24C6 CD A1 2D 0B 0556**          		CALL    COPY_
0B24CA CD 81 21 0B 0557**          		CALL    OP              ;SQUARE
0B24CE F1          0558**          		POP     AF
0B24CF CD CD 2A 0B 0559**          		CALL    DLOAD5
0B24D3 DC 81 21 0B 0560**          		CALL    C,OP            ;MULTIPLY BY X
0B24D7 D1          0561**  IPOW5:			POP     DE
0B24D8 D9          0562**          		EXX
0B24D9 D1          0563**          		POP     DE
0B24DA D9          0564**          		EXX
0B24DB 79          0565**          		LD      A,C
0B24DC C1          0566**          		POP     BC
0B24DD 4F          0567**          		LD      C,A
0B24DE 10 D6       0568**  IPOW4:			DJNZ    IPOW3
0B24E0 F1          0569**          		POP     AF
0B24E1 F1          0570**          		POP     AF
0B24E2 F1          0571**          		POP     AF
0B24E3 C9          0572**          		RET
0B24E4             0573**  ;
0B24E4 F1          0574**  FPOW0:			POP     AF
0B24E5 F1          0575**          		POP     AF
0B24E6 F1          0576**          		POP     AF
0B24E7 18 8B       0577**          		JR      IPOW0
0B24E9             0578**  ;
0B24E9             0579**  ;FPOW - Floating-point involution.
0B24E9             0580**  ;
0B24E9 CB 7A       0581**  FPOW:			BIT     7,D
0B24EB F5          0582**          		PUSH    AF
0B24EC CD D5 2C 0B 0583**          		CALL    SWAP_FP
0B24F0 CD B1 2D 0B 0584**          		CALL    PUSH5
0B24F4 0D          0585**          		DEC     C
0B24F5 0C          0586**          		INC     C
0B24F6 28 EC       0587**          		JR      Z,FPOW0
0B24F8 3E 9E       0588**          		LD      A,158
0B24FA B9          0589**          		CP      C
0B24FB 38 0A       0590**          		JR      C,FPOW1
0B24FD 3C          0591**          		INC     A
0B24FE CD A9 2B 0B 0592**          		CALL    FIX
0B2502 08          0593**          		EX      AF,AF'
0B2503 F2 E4 24 0B 0594**          		JP      P,FPOW0
0B2507 CD D5 2C 0B 0595**  FPOW1:			CALL    SWAP_FP
0B250B CD F5 27 0B 0596**          		CALL    LN0
0B250F CD BA 2D 0B 0597**          		CALL    POP5
0B2513 F1          0598**          		POP     AF
0B2514 CD 0C 24 0B 0599**          		CALL    FMUL
0B2518 C3 57 27 0B 0600**          		JP      EXP0
0B251C             0601**  ;
0B251C             0602**  ;Integer and floating-point compare.
0B251C             0603**  ;Result is TRUE (-1) or FALSE (0).
0B251C             0604**  ;
0B251C CD 2B 2D 0B 0605**  FLT:			CALL    FCP
0B2520 18 04       0606**          		JR      ILT1
0B2522 CD 1D 2D 0B 0607**  ILT:			CALL    ICP
0B2526 D0          0608**  ILT1:			RET     NC
0B2527 18 42       0609**          		JR      TRUE_FP
0B2529             0610**  ;
0B2529 CD 2B 2D 0B 0611**  FGT:			CALL    FCP
0B252D 18 04       0612**          		JR      IGT1
0B252F CD 1D 2D 0B 0613**  IGT:			CALL    ICP
0B2533 C8          0614**  IGT1:			RET     Z
0B2534 D8          0615**          		RET     C
0B2535 18 34       0616**          		JR      TRUE_FP
0B2537             0617**  ;
0B2537 CD 2B 2D 0B 0618**  FGE:			CALL    FCP
0B253B 18 04       0619**          		JR      IGE1
0B253D CD 1D 2D 0B 0620**  IGE:			CALL    ICP
0B2541 D8          0621**  IGE1:			RET     C
0B2542 18 27       0622**          		JR      TRUE_FP
0B2544             0623**  ;
0B2544 CD 2B 2D 0B 0624**  FLE:			CALL    FCP
0B2548 18 04       0625**          		JR      ILE1
0B254A CD 1D 2D 0B 0626**  ILE:			CALL    ICP
0B254E 28 1B       0627**  ILE1:			JR      Z,TRUE_FP
0B2550 D0          0628**          		RET     NC
0B2551 18 18       0629**          		JR      TRUE_FP
0B2553             0630**  ;
0B2553 CD 2B 2D 0B 0631**  FNE:			CALL    FCP
0B2557 18 04       0632**          		JR      INE1
0B2559 CD 1D 2D 0B 0633**  INE:			CALL    ICP
0B255D C8          0634**  INE1:			RET     Z
0B255E 18 0B       0635**          		JR      TRUE_FP
0B2560             0636**  ;
0B2560 CD 2B 2D 0B 0637**  FEQ:			CALL    FCP
0B2564 18 04       0638**          		JR      IEQ1
0B2566 CD 1D 2D 0B 0639**  IEQ:			CALL    ICP
0B256A C0          0640**  IEQ1:			RET     NZ
0B256B 21 FF FF FF 0641**  TRUE_FP:			LD      HL,-1
0B256F D9          0642**          		EXX
0B2570 21 FF FF FF 0643**          		LD      HL,-1
0B2574 D9          0644**          		EXX
0B2575 AF          0645**          		XOR     A
0B2576 4F          0646**          		LD      C,A
0B2577 C9          0647**          		RET
0B2578             0648**  ;
0B2578             0649**  ;FUNCTIONS:
0B2578             0650**  ;
0B2578             0651**  ;Result returned in HLH'L'C (floating point)
0B2578             0652**  ;Result returned in HLH'L' (C=0) (integer)
0B2578             0653**  ;All registers except IY destroyed.
0B2578             0654**  ;
0B2578             0655**  ;ABS - Absolute value
0B2578             0656**  ;Result is numeric, variable type.
0B2578             0657**  ;
0B2578 CB 7C       0658**  ABSV_FP:			BIT     7,H
0B257A C8          0659**          		RET     Z               ;POSITIVE/ZERO
0B257B 0D          0660**          		DEC     C
0B257C 0C          0661**          		INC     C
0B257D CA D8 2B 0B 0662**          		JP      Z,NEGATE        ;INTEGER
0B2581 CB BC       0663**          		RES     7,H
0B2583 C9          0664**          		RET
0B2584             0665**  ;
0B2584             0666**  ;NOT - Complement integer.
0B2584             0667**  ;Result is integer numeric.
0B2584             0668**  ;
0B2584 CD C8 2B 0B 0669**  NOTK_FP:			CALL    SFIX_FP
0B2588 7C          0670**          		LD      A,H
0B2589 2F          0671**          		CPL
0B258A 67          0672**          		LD      H,A
0B258B 7D          0673**          		LD      A,L
0B258C 2F          0674**          		CPL
0B258D 6F          0675**          		LD      L,A
0B258E D9          0676**          		EXX
0B258F 7C          0677**          		LD      A,H
0B2590 2F          0678**          		CPL
0B2591 67          0679**          		LD      H,A
0B2592 7D          0680**          		LD      A,L
0B2593 2F          0681**          		CPL
0B2594 6F          0682**          		LD      L,A
0B2595 D9          0683**          		EXX
0B2596 AF          0684**          		XOR     A               ;NUMERIC MARKER
0B2597 C9          0685**          		RET
0B2598             0686**  ;
0B2598             0687**  ;PI - Return PI (3.141592654)
0B2598             0688**  ;Result is floating-point numeric.
0B2598             0689**  ;
0B2598 21 0F 49 00 0690**  PI_FP:			LD      HL,490FH
0B259C D9          0691**          		EXX
0B259D 21 A2 DA 00 0692**          		LD      HL,0DAA2H
0B25A1 D9          0693**          		EXX
0B25A2 0E 81       0694**          		LD      C,81H
0B25A4 AF          0695**          		XOR     A               ;NUMERIC MARKER
0B25A5 C9          0696**          		RET
0B25A6             0697**  ;
0B25A6             0698**  ;DEG - Convert radians to degrees
0B25A6             0699**  ;Result is floating-point numeric.
0B25A6             0700**  ;
0B25A6 CD BA 25 0B 0701**  DEG_FP:			CALL    FPI180
0B25AA CD 0C 24 0B 0702**          		CALL    FMUL
0B25AE AF          0703**          		XOR     A
0B25AF C9          0704**          		RET
0B25B0             0705**  ;
0B25B0             0706**  ;RAD - Convert degrees to radians
0B25B0             0707**  ;Result is floating-point numeric.
0B25B0             0708**  ;
0B25B0 CD BA 25 0B 0709**  RAD_FP:			CALL    FPI180
0B25B4 CD 63 23 0B 0710**          		CALL    FDIV
0B25B8 AF          0711**          		XOR     A
0B25B9 C9          0712**          		RET
0B25BA             0713**  ;
0B25BA             0714**  ;180/PI
0B25BA             0715**  ;
0B25BA CD A4 2C 0B 0716**  FPI180:			CALL    SFLOAT_FP
0B25BE 11 2E 65 00 0717**          		LD      DE,652EH
0B25C2 D9          0718**          		EXX
0B25C3 11 D3 E0 00 0719**          		LD      DE,0E0D3H
0B25C7 D9          0720**          		EXX
0B25C8 06 85       0721**          		LD      B,85H
0B25CA C9          0722**          		RET
0B25CB             0723**  ;
0B25CB             0724**  ;SGN - Return -1, 0 or +1
0B25CB             0725**  ;Result is integer numeric.
0B25CB             0726**  ;
0B25CB CD FD 2C 0B 0727**  SGN_FP:			CALL    TEST_FP
0B25CF B1          0728**          		OR      C
0B25D0 C8          0729**          		RET     Z               ;ZERO
0B25D1 CB 7C       0730**          		BIT     7,H
0B25D3 C2 6B 25 0B 0731**          		JP      NZ,TRUE_FP         ;-1
0B25D7 CD 21 2D 0B 0732**          		CALL    ZERO_FP
0B25DB C3 BD 2C 0B 0733**          		JP      ADD1_FP            ;1
0B25DF             0734**  ;
0B25DF             0735**  ;VAL - Return numeric value of string.
0B25DF             0736**  ;Input: ASCII string at IX
0B25DF             0737**  ;Result is variable type numeric.
0B25DF             0738**  ;
0B25DF CD 3B 2F 0B 0739**  VAL_FP:			CALL    SIGNQ
0B25E3 F5          0740**          		PUSH    AF
0B25E4 CD EB 2A 0B 0741**          		CALL    CON_FP
0B25E8 F1          0742**          		POP     AF
0B25E9 FE 2D       0743**          		CP      '-'
0B25EB 3E 00       0744**          		LD      A,0             ;NUMERIC MARKER
0B25ED C0          0745**          		RET     NZ
0B25EE 0D          0746**          		DEC     C
0B25EF 0C          0747**          		INC     C
0B25F0 CA D8 2B 0B 0748**          		JP      Z,NEGATE        ;ZERO/INTEGER
0B25F4 7C          0749**          		LD      A,H
0B25F5 EE 80       0750**          		XOR     80H             ;CHANGE SIGN (FP)
0B25F7 67          0751**          		LD      H,A
0B25F8 AF          0752**          		XOR     A
0B25F9 C9          0753**          		RET
0B25FA             0754**  ;
0B25FA             0755**  ;INT - Floor function
0B25FA             0756**  ;Result is integer numeric.
0B25FA             0757**  ;
0B25FA 0D          0758**  INT_FP_:			DEC     C
0B25FB 0C          0759**          		INC     C
0B25FC C8          0760**          		RET     Z               ;ZERO/INTEGER
0B25FD 3E 9F       0761**          		LD      A,159
0B25FF 44          0762**          		LD      B,H             ;B7=SIGN BIT
0B2600 CD A9 2B 0B 0763**          		CALL    FIX
0B2604 08          0764**          		EX      AF,AF'
0B2605 A0          0765**          		AND     B
0B2606 FC BD 2C 0B 0766**          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B260A 78          0767**          		LD      A,B
0B260B B7          0768**          		OR      A
0B260C FC D8 2B 0B 0769**          		CALL    M,NEGATE
0B2610 AF          0770**          		XOR     A
0B2611 4F          0771**          		LD      C,A
0B2612 C9          0772**          		RET
0B2613             0773**  ;
0B2613             0774**  ;SQR - square root
0B2613             0775**  ;Result is floating-point numeric.
0B2613             0776**  ;
0B2613 CD A4 2C 0B 0777**  SQR_FP:			CALL    SFLOAT_FP
0B2617 CB 7C       0778**  SQR0:			BIT     7,H
0B2619 3E 15       0779**          		LD      A,NGROOT
0B261B C2 7B 21 0B 0780**          		JP      NZ,ERROR_FP_        ;"-ve root"
0B261F 0D          0781**          		DEC     C
0B2620 0C          0782**          		INC     C
0B2621 C8          0783**          		RET     Z               ;ZERO
0B2622 CB FC       0784**          		SET     7,H             ;IMPLIED 1
0B2624 CB 41       0785**          		BIT     0,C
0B2626 CC DD 2C 0B 0786**          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B262A 79          0787**          		LD      A,C
0B262B D6 80       0788**          		SUB     80H
0B262D CB 2F       0789**          		SRA     A               ;HALVE EXPONENT
0B262F C6 80       0790**          		ADD     A,80H
0B2631 4F          0791**          		LD      C,A
0B2632 C5          0792**          		PUSH    BC              ;SAVE EXPONENT
0B2633 EB          0793**          		EX      DE,HL
0B2634 21 00 00 00 0794**          		LD      HL,0
0B2638 44          0795**          		LD      B,H
0B2639 4D          0796**          		LD      C,L
0B263A D9          0797**          		EXX
0B263B EB          0798**          		EX      DE,HL
0B263C 21 00 00 00 0799**          		LD      HL,0
0B2640 44          0800**          		LD      B,H
0B2641 4D          0801**          		LD      C,L
0B2642 3E E1       0802**          		LD      A,-31
0B2644 CD D3 2E 0B 0803**          		CALL    SQRA            ;ROOT
0B2648 D9          0804**          		EXX
0B2649 CB 78       0805**          		BIT     7,B
0B264B D9          0806**          		EXX
0B264C CC D3 2E 0B 0807**          		CALL    Z,SQRA          ;NORMALISE & INC A
0B2650 CD 14 2F 0B 0808**          		CALL    SQRB
0B2654 B7          0809**          		OR      A               ;CLEAR CARRY
0B2655 CD 81 2E 0B 0810**          		CALL    DIVB
0B2659 CB 1B       0811**          		RR      E               ;LSB TO CARRY
0B265B 60          0812**          		LD      H,B
0B265C 69          0813**          		LD      L,C
0B265D D9          0814**          		EXX
0B265E 60          0815**          		LD      H,B
0B265F 69          0816**          		LD      L,C
0B2660 DC BD 2C 0B 0817**          		CALL    C,ADD1_FP          ;ROUND UP
0B2664 C1          0818**          		POP     BC              ;RESTORE EXPONENT
0B2665 DC EA 2C 0B 0819**          		CALL    C,INCC
0B2669 1F          0820**          		RRA
0B266A 9F          0821**          		SBC     A,A
0B266B 81          0822**          		ADD     A,C
0B266C 4F          0823**          		LD      C,A
0B266D CB BC       0824**          		RES     7,H             ;POSITIVE
0B266F AF          0825**          		XOR     A
0B2670 C9          0826**          		RET
0B2671             0827**  ;
0B2671             0828**  ;TAN - Tangent function
0B2671             0829**  ;Result is floating-point numeric.
0B2671             0830**  ;
0B2671 CD A4 2C 0B 0831**  TAN_FP:			CALL    SFLOAT_FP
0B2675 CD B1 2D 0B 0832**          		CALL    PUSH5
0B2679 CD 9B 26 0B 0833**          		CALL    COS0
0B267D CD BA 2D 0B 0834**          		CALL    POP5
0B2681 CD B1 2D 0B 0835**          		CALL    PUSH5
0B2685 CD D5 2C 0B 0836**          		CALL    SWAP_FP
0B2689 CD A8 26 0B 0837**          		CALL    SIN0
0B268D CD BA 2D 0B 0838**          		CALL    POP5
0B2691 CD 63 23 0B 0839**          		CALL    FDIV
0B2695 AF          0840**          		XOR     A               ;NUMERIC MARKER
0B2696 C9          0841**          		RET
0B2697             0842**  ;
0B2697             0843**  ;COS - Cosine function
0B2697             0844**  ;Result is floating-point numeric.
0B2697             0845**  ;
0B2697 CD A4 2C 0B 0846**  COS_FP:			CALL    SFLOAT_FP
0B269B CD 00 2C 0B 0847**  COS0:			CALL    SCALE
0B269F 1C          0848**          		INC     E
0B26A0 1C          0849**          		INC     E
0B26A1 7B          0850**          		LD      A,E
0B26A2 18 10       0851**          		JR      SIN1
0B26A4             0852**  ;
0B26A4             0853**  ;SIN - Sine function
0B26A4             0854**  ;Result is floating-point numeric.
0B26A4             0855**  ;
0B26A4 CD A4 2C 0B 0856**  SIN_FP:			CALL    SFLOAT_FP
0B26A8 E5          0857**  SIN0:			PUSH    HL              ;H7=SIGN
0B26A9 CD 00 2C 0B 0858**          		CALL    SCALE
0B26AD F1          0859**          		POP     AF
0B26AE 07          0860**          		RLCA
0B26AF 07          0861**          		RLCA
0B26B0 07          0862**          		RLCA
0B26B1 E6 04       0863**          		AND     4
0B26B3 AB          0864**          		XOR     E
0B26B4 F5          0865**  SIN1:			PUSH    AF              ;OCTANT
0B26B5 CB BC       0866**          		RES     7,H
0B26B7 1F          0867**          		RRA
0B26B8 CD 46 27 0B 0868**          		CALL    PIBY4
0B26BC DC E7 22 0B 0869**          		CALL    C,RSUB          ;X=(PI/4)-X
0B26C0 F1          0870**          		POP     AF
0B26C1 F5          0871**          		PUSH    AF
0B26C2 E6 03       0872**          		AND     3
0B26C4 E2 FD 26 0B 0873**          		JP      PO,SIN2         ;USE COSINE APPROX.
0B26C8 CD B1 2D 0B 0874**          		CALL    PUSH5           ;SAVE X
0B26CC CD A9 2D 0B 0875**          		CALL    SQUARE          ;PUSH X*X
0B26D0 CD EE 2D 0B 0876**          		CALL    POLY
0B26D4 B7 A8       0877**          		DW	0A8B7H          ;a(8)
0B26D6 11 36       0878**          		DW	3611H
0B26D8 6D          0879**          		DB	6DH
0B26D9 26 DE       0880**          		DW	0DE26H          ;a(6)
0B26DB 05 D0       0881**          		DW	0D005H
0B26DD 73          0882**          		DB	73H
0B26DE C0 80       0883**          		DW	80C0H           ;a(4)
0B26E0 88 08       0884**          		DW	888H
0B26E2 79          0885**          		DB	79H
0B26E3 9D AA       0886**          		DW	0AA9DH          ;a(2)
0B26E5 AA AA       0887**          		DW	0AAAAH
0B26E7 7D          0888**          		DB	7DH
0B26E8 00 00       0889**          		DW	0               ;a(0)
0B26EA 00 00       0890**          		DW	0
0B26EC 80          0891**          		DB	80H
0B26ED CD BA 2D 0B 0892**          		CALL    POP5
0B26F1 CD BA 2D 0B 0893**          		CALL    POP5
0B26F5 CD 0C 24 0B 0894**          		CALL    FMUL
0B26F9 C3 22 27 0B 0895**          		JP      SIN3
0B26FD             0896**  ;
0B26FD CD A9 2D 0B 0897**  SIN2:			CALL    SQUARE          ;PUSH X*X
0B2701 CD EE 2D 0B 0898**          		CALL    POLY
0B2705 71 D5       0899**          		DW	0D571H          ;b(8)
0B2707 78 4C       0900**          		DW	4C78H
0B2709 70          0901**          		DB	70H
0B270A AF 94       0902**          		DW	94AFH           ;b(6)
0B270C 03 B6       0903**          		DW	0B603H
0B270E 76          0904**          		DB	76H
0B270F C8 9C       0905**          		DW	9CC8H           ;b(4)
0B2711 AA 2A       0906**          		DW	2AAAH
0B2713 7B          0907**          		DB	7BH
0B2714 DD FF       0908**          		DW	0FFDDH          ;b(2)
0B2716 FF FF       0909**          		DW	0FFFFH
0B2718 7E          0910**          		DB	7EH
0B2719 00 00       0911**          		DW	0               ;b(0)
0B271B 00 00       0912**          		DW	0
0B271D 80          0913**          		DB	80H
0B271E CD BA 2D 0B 0914**          		CALL    POP5
0B2722 F1          0915**  SIN3:			POP     AF
0B2723 E6 04       0916**          		AND     4
0B2725 C8          0917**          		RET     Z
0B2726 0D          0918**          		DEC     C
0B2727 0C          0919**          		INC     C
0B2728 C8          0920**          		RET     Z               ;ZERO
0B2729 CB FC       0921**          		SET     7,H             ;MAKE NEGATIVE
0B272B C9          0922**          		RET
0B272C             0923**  ;
0B272C             0924**  ;Floating-point one:
0B272C             0925**  ;
0B272C 21 00 00 00 0926**  FONE_FP:			LD      HL,0
0B2730 D9          0927**          		EXX
0B2731 21 00 00 00 0928**          		LD      HL,0
0B2735 D9          0929**          		EXX
0B2736 0E 80       0930**          		LD      C,80H
0B2738 C9          0931**          		RET
0B2739             0932**  ;
0B2739 11 00 00 00 0933**  DONE:			LD      DE,0
0B273D D9          0934**          		EXX
0B273E 11 00 00 00 0935**          		LD      DE,0
0B2742 D9          0936**          		EXX
0B2743 06 80       0937**          		LD      B,80H
0B2745 C9          0938**          		RET
0B2746             0939**  ;
0B2746 11 0F 49 00 0940**  PIBY4:			LD      DE,490FH
0B274A D9          0941**          		EXX
0B274B 11 A2 DA 00 0942**          		LD      DE,0DAA2H
0B274F D9          0943**          		EXX
0B2750 06 7F       0944**          		LD      B,7FH
0B2752 C9          0945**          		RET
0B2753             0946**  ;
0B2753             0947**  ;EXP - Exponential function
0B2753             0948**  ;Result is floating-point numeric.
0B2753             0949**  ;
0B2753 CD A4 2C 0B 0950**  EXP_FP:			CALL    SFLOAT_FP
0B2757 CD E4 27 0B 0951**  EXP0:			CALL    LN2             ;LN(2)
0B275B D9          0952**          		EXX
0B275C 1D          0953**  	        	DEC     E
0B275D 01 CF D1 00 0954**  		        LD      BC,0D1CFH       ;0.6931471805599453
0B2761 D9          0955**          		EXX
0B2762 E5          0956**          		PUSH    HL              ;H7=SIGN
0B2763 CD 13 2C 0B 0957**          		CALL    MOD48           ;"MODULUS"
0B2767 F1          0958**          		POP     AF
0B2768 CB 7B       0959**          		BIT     7,E
0B276A 28 0B       0960**          		JR      Z,EXP1
0B276C 17          0961**          		RLA
0B276D DA 21 2D 0B 0962**          		JP      C,ZERO_FP
0B2771 3E 18       0963**          		LD      A,EXPRNG
0B2773 C3 7B 21 0B 0964**          		JP      ERROR_FP_           ;"Exp range"
0B2777             0965**  ;
0B2777 E6 80       0966**  EXP1:			AND     80H
0B2779 B3          0967**          		OR      E
0B277A F5          0968**          		PUSH    AF              ;INTEGER PART
0B277B CB BC       0969**          		RES     7,H
0B277D CD B1 2D 0B 0970**          		CALL    PUSH5           ;PUSH X*LN(2)
0B2781 CD EE 2D 0B 0971**          		CALL    POLY
0B2785 72 40       0972**          		DW	4072H           ;a(7)
0B2787 2E 94       0973**          		DW	942EH
0B2789 73          0974**          		DB	73H
0B278A 65 6F       0975**          		DW	6F65H           ;a(6)
0B278C 4F 2E       0976**          		DW	2E4FH
0B278E 76          0977**          		DB	76H
0B278F 37 6D       0978**          		DW	6D37H           ;a(5)
0B2791 02 88       0979**          		DW	8802H
0B2793 79          0980**          		DB	79H
0B2794 12 E5       0981**          		DW	0E512H          ;a(4)
0B2796 A0 2A       0982**          		DW	2AA0H
0B2798 7B          0983**          		DB	7BH
0B2799 14 4F       0984**          		DW	4F14H           ;a(3)
0B279B AA AA       0985**          		DW	0AAAAH
0B279D 7D          0986**          		DB	7DH
0B279E 56 FD       0987**          		DW	0FD56H          ;a(2)
0B27A0 FF 7F       0988**          		DW	7FFFH
0B27A2 7E          0989**          		DB	7EH
0B27A3 FE FF       0990**          		DW	0FFFEH          ;a(1)
0B27A5 FF FF       0991**          		DW	0FFFFH
0B27A7 7F          0992**          		DB	7FH
0B27A8 00 00       0993**          		DW	0               ;a(0)
0B27AA 00 00       0994**          		DW	0
0B27AC 80          0995**          		DB	80H
0B27AD CD BA 2D 0B 0996**          		CALL    POP5
0B27B1 F1          0997**          		POP     AF
0B27B2 F5          0998**          		PUSH    AF
0B27B3 F4 D8 27 0B 0999**          		CALL    P,RECIP         ;X=1/X
0B27B7 F1          1000**          		POP     AF
0B27B8 F2 C0 27 0B 1001**          		JP      P,EXP4
0B27BC E6 7F       1002**          		AND     7FH
0B27BE ED 44       1003**          		NEG
0B27C0 C6 80       1004**  EXP4:			ADD     A,80H
0B27C2 81          1005**          		ADD     A,C
0B27C3 38 06       1006**          		JR      C,EXP2
0B27C5 F2 21 2D 0B 1007**          		JP      P,ZERO_FP          ;UNDERFLOW
0B27C9 18 04       1008**          		JR      EXP3
0B27CB FA EC 2C 0B 1009**  EXP2:			JP      M,OFLOW         ;OVERFLOW
0B27CF C6 80       1010**  EXP3:			ADD     A,80H
0B27D1 CA 21 2D 0B 1011**          		JP      Z,ZERO_FP
0B27D5 4F          1012**          		LD      C,A
0B27D6 AF          1013**          		XOR     A               ;NUMERIC MARKER
0B27D7 C9          1014**          		RET
0B27D8             1015**  ;
0B27D8 CD 39 27 0B 1016**  RECIP:			CALL    DONE
0B27DC CD D5 2C 0B 1017**  RDIV:			CALL    SWAP_FP
0B27E0 C3 63 23 0B 1018**          		JP      FDIV            ;RECIPROCAL
0B27E4             1019**  ;
0B27E4 11 72 31 00 1020**  LN2:			LD      DE,3172H        ;LN(2)
0B27E8 D9          1021**          		EXX
0B27E9 11 F8 17 00 1022**          		LD      DE,17F8H
0B27ED D9          1023**          		EXX
0B27EE 06 7F       1024**          		LD      B,7FH
0B27F0 C9          1025**          		RET
0B27F1             1026**  ;
0B27F1             1027**  ;LN - Natural log.
0B27F1             1028**  ;Result is floating-point numeric.
0B27F1             1029**  ;
0B27F1 CD A4 2C 0B 1030**  LN_FP:			CALL    SFLOAT_FP
0B27F5 3E 16       1031**  LN0:			LD      A,LOGRNG
0B27F7 CB 7C       1032**          		BIT     7,H
0B27F9 C2 7B 21 0B 1033**          		JP      NZ,ERROR_FP_        ;"Log range"
0B27FD 0C          1034**          		INC     C
0B27FE 0D          1035**          		DEC     C
0B27FF CA 7B 21 0B 1036**          		JP      Z,ERROR_FP_
0B2803 11 04 35 00 1037**          		LD      DE,3504H        ;SQR(2)
0B2807 D9          1038**          		EXX
0B2808 11 33 F3 00 1039**          		LD      DE,0F333H       ;1.41421356237
0B280C D9          1040**          		EXX
0B280D CD 34 2D 0B 1041**          		CALL    ICP0            ;MANTISSA>SQR(2)?
0B2811 79          1042**          		LD      A,C             ;EXPONENT
0B2812 0E 80       1043**          		LD      C,80H           ;1 <= X < 2
0B2814 38 02       1044**          		JR      C,LN4
0B2816 0D          1045**          		DEC     C
0B2817 3C          1046**          		INC     A
0B2818 F5          1047**  LN4:			PUSH    AF              ;SAVE EXPONENT
0B2819 CD C6 2D 0B 1048**          		CALL    RATIO           ;X=(X-1)/(X+1)
0B281D CD B1 2D 0B 1049**          		CALL    PUSH5
0B2821 CD A9 2D 0B 1050**  		        CALL    SQUARE          ;PUSH X*X
0B2825 CD EE 2D 0B 1051**          		CALL    POLY
0B2829 48 CC       1052**          		DW	0CC48H          ;a(9)
0B282B FB 74       1053**          		DW	74FBH
0B282D 7D          1054**          		DB	7DH
0B282E AF AE       1055**          		DW	0AEAFH          ;a(7)
0B2830 FF 11       1056**          		DW	11FFH
0B2832 7E          1057**          		DB	7EH
0B2833 8C D9       1058**          		DW	0D98CH          ;a(5)
0B2835 CD 4C       1059**          		DW	4CCDH
0B2837 7E          1060**          		DB	7EH
0B2838 E3 A9       1061**          		DW	0A9E3H          ;a(3)
0B283A AA 2A       1062**          		DW	2AAAH
0B283C 7F          1063**          		DB	7FH
0B283D 00 00       1064**          		DW	0               ;a(1)
0B283F 00 00       1065**          		DW	0
0B2841 81          1066**          		DB	81H
0B2842 CD BA 2D 0B 1067**          		CALL    POP5
0B2846 CD BA 2D 0B 1068**          		CALL    POP5
0B284A CD 0C 24 0B 1069**          		CALL    FMUL
0B284E F1          1070**          		POP     AF              ;EXPONENT
0B284F CD B1 2D 0B 1071**          		CALL    PUSH5
0B2853 08          1072**          		EX      AF,AF'
0B2854 CD 21 2D 0B 1073**          		CALL    ZERO_FP
0B2858 08          1074**          		EX      AF,AF'
0B2859 D6 80       1075**          		SUB     80H
0B285B 28 1F       1076**          		JR      Z,LN3
0B285D 30 02       1077**          		JR      NC,LN1
0B285F 2F          1078**          		CPL
0B2860 3C          1079**          		INC     A
0B2861 67          1080**  LN1:			LD      H,A
0B2862 0E 87       1081**          		LD      C,87H
0B2864 F5          1082**          		PUSH    AF
0B2865 CD 84 2C 0B 1083**          		CALL    FLOAT_
0B2869 CB BC       1084**          		RES     7,H
0B286B CD E4 27 0B 1085**          		CALL    LN2
0B286F CD 0C 24 0B 1086**          		CALL    FMUL
0B2873 F1          1087**          		POP     AF
0B2874 30 06       1088**          		JR      NC,LN3
0B2876 FA 7C 28 0B 1089**          		JP      M,LN3
0B287A CB FC       1090**          		SET     7,H
0B287C CD BA 2D 0B 1091**  LN3:			CALL    POP5
0B2880 CD FA 22 0B 1092**          		CALL    FADD
0B2884 AF          1093**          		XOR     A
0B2885 C9          1094**          		RET
0B2886             1095**  ;
0B2886             1096**  ;LOG - base-10 logarithm.
0B2886             1097**  ;Result is floating-point numeric.
0B2886             1098**  ;
0B2886 CD F1 27 0B 1099**  LOG_FP:			CALL    LN_FP
0B288A 11 5B 5E 00 1100**          		LD      DE,5E5BH        ;LOG(e)
0B288E D9          1101**          		EXX
0B288F 11 A9 D8 00 1102**          		LD      DE,0D8A9H
0B2893 D9          1103**          		EXX
0B2894 06 7E       1104**          		LD      B,7EH
0B2896 CD 0C 24 0B 1105**          		CALL    FMUL
0B289A AF          1106**          		XOR     A
0B289B C9          1107**          		RET
0B289C             1108**  ;
0B289C             1109**  ;ASN - Arc-sine
0B289C             1110**  ;Result is floating-point numeric.
0B289C             1111**  ;
0B289C CD A4 2C 0B 1112**  ASN_FP:			CALL    SFLOAT_FP
0B28A0 CD B1 2D 0B 1113**          		CALL    PUSH5
0B28A4 CD A1 2D 0B 1114**          		CALL    COPY_
0B28A8 CD 0C 24 0B 1115**          		CALL    FMUL
0B28AC CD 39 27 0B 1116**          		CALL    DONE
0B28B0 CD E7 22 0B 1117**          		CALL    RSUB
0B28B4 CD 17 26 0B 1118**          		CALL    SQR0
0B28B8 CD BA 2D 0B 1119**          		CALL    POP5
0B28BC 0C          1120**          		INC     C
0B28BD 0D          1121**          		DEC     C
0B28BE 3E 02       1122**          		LD      A,2
0B28C0 D5          1123**          		PUSH    DE
0B28C1 CA 46 29 0B 1124**          		JP      Z,ACS1
0B28C5 D1          1125**          		POP     DE
0B28C6 CD DC 27 0B 1126**          		CALL    RDIV
0B28CA 18 04       1127**          		JR      ATN0
0B28CC             1128**  ;
0B28CC             1129**  ;ATN - arc-tangent
0B28CC             1130**  ;Result is floating-point numeric.
0B28CC             1131**  ;
0B28CC CD A4 2C 0B 1132**  ATN_FP:			CALL    SFLOAT_FP
0B28D0 E5          1133**  ATN0:			PUSH    HL              ;SAVE SIGN
0B28D1 CB BC       1134**          		RES     7,H
0B28D3 11 13 54 00 1135**          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B28D7 D9          1136**          		EXX
0B28D8 11 D0 CC 00 1137**          		LD      DE,0CCD0H
0B28DC D9          1138**          		EXX
0B28DD 06 7E       1139**          		LD      B,7EH
0B28DF CD 31 2D 0B 1140**          		CALL    FCP0            ;COMPARE
0B28E3 06 00       1141**          		LD      B,0
0B28E5 38 22       1142**          		JR      C,ATN2
0B28E7 11 82 1A 00 1143**          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B28EB D9          1144**          		EXX
0B28EC 11 9A 79 00 1145**          		LD      DE,799AH
0B28F0 D9          1146**          		EXX
0B28F1 06 81       1147**          		LD      B,81H
0B28F3 CD 31 2D 0B 1148**          		CALL    FCP0            ;COMPARE
0B28F7 38 0A       1149**          		JR      C,ATN1
0B28F9 CD D8 27 0B 1150**          		CALL    RECIP           ;X=1/X
0B28FD 06 02       1151**          		LD      B,2
0B28FF C3 09 29 0B 1152**          		JP      ATN2
0B2903 CD C6 2D 0B 1153**  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B2907 06 01       1154**          		LD      B,1
0B2909 C5          1155**  ATN2:			PUSH    BC              ;SAVE FLAG
0B290A CD B1 2D 0B 1156**          		CALL    PUSH5
0B290E CD A9 2D 0B 1157**          		CALL    SQUARE          ;PUSH X*X
0B2912 CD EE 2D 0B 1158**          		CALL    POLY
0B2916 35 F3       1159**          		DW	0F335H          ;a(13)
0B2918 D8 37       1160**          		DW	37D8H
0B291A 7B          1161**          		DB	7BH
0B291B 91 6B       1162**          		DW	6B91H           ;a(11)
0B291D B9 AA       1163**          		DW	0AAB9H
0B291F 7C          1164**          		DB	7CH
0B2920 DE 41       1165**          		DW	41DEH           ;a(9)
0B2922 97 61       1166**          		DW	6197H
0B2924 7C          1167**          		DB	7CH
0B2925 7B 9D       1168**          		DW	9D7BH           ;a(7)
0B2927 37 92       1169**          		DW	9237H
0B2929 7D          1170**          		DB	7DH
0B292A 5A 2A       1171**          		DW	2A5AH           ;a(5)
0B292C CC 4C       1172**          		DW	4CCCH
0B292E 7D          1173**          		DB	7DH
0B292F 5C A9       1174**          		DW	0A95CH          ;a(3)
0B2931 AA AA       1175**          		DW	0AAAAH
0B2933 7E          1176**          		DB	7EH
0B2934 00 00       1177**          		DW	0               ;a(1)
0B2936 00 00       1178**          		DW	0
0B2938 80          1179**          		DB	80H
0B2939 CD BA 2D 0B 1180**          		CALL    POP5
0B293D CD BA 2D 0B 1181**          		CALL    POP5
0B2941 CD 0C 24 0B 1182**          		CALL    FMUL
0B2945 F1          1183**          		POP     AF
0B2946 CD 46 27 0B 1184**  ACS1:			CALL    PIBY4           ;PI/4
0B294A 1F          1185**          		RRA
0B294B F5          1186**          		PUSH    AF
0B294C DC FA 22 0B 1187**          		CALL    C,FADD
0B2950 F1          1188**          		POP     AF
0B2951 04          1189**          		INC     B
0B2952 1F          1190**          		RRA
0B2953 DC E7 22 0B 1191**          		CALL    C,RSUB
0B2957 F1          1192**          		POP     AF
0B2958 B7          1193**          		OR      A
0B2959 F0          1194**          		RET     P
0B295A CB FC       1195**          		SET     7,H             ;MAKE NEGATIVE
0B295C AF          1196**          		XOR     A
0B295D C9          1197**          		RET
0B295E             1198**  ;
0B295E             1199**  ;ACS - Arc cosine=PI/2-ASN.
0B295E             1200**  ;Result is floating point numeric.
0B295E             1201**  ;
0B295E CD 9C 28 0B 1202**  ACS_FP:			CALL    ASN_FP
0B2962 3E 02       1203**          		LD      A,2
0B2964 F5          1204**          		PUSH    AF
0B2965 18 DF       1205**          		JR      ACS1
0B2967             1206**  ;
0B2967             1207**  ;Function STR - convert numeric value to ASCII string.
0B2967             1208**  ;   Inputs: HLH'L'C = integer or floating-point number
0B2967             1209**  ;           DE = address at which to store string
0B2967             1210**  ;           IX = address of @% format control
0B2967             1211**  ;  Outputs: String stored, with NUL terminator
0B2967             1212**  ;
0B2967             1213**  ;First normalise for decimal output:
0B2967             1214**  ;
0B2967 CD A4 2C 0B 1215**  STR_FP:			CALL    SFLOAT_FP
0B296B 06 00       1216**          		LD      B,0             ;DEFAULT PT. POSITION
0B296D CB 7C       1217**          		BIT     7,H             ;NEGATIVE?
0B296F 28 06       1218**          		JR      Z,STR10
0B2971 CB BC       1219**          		RES     7,H
0B2973 3E 2D       1220**          		LD      A,'-'
0B2975 12          1221**          		LD      (DE),A          ;STORE SIGN
0B2976 13          1222**          		INC     DE
0B2977 AF          1223**  STR10:			XOR     A               ;CLEAR A
0B2978 B9          1224**          		CP      C
0B2979 28 4E       1225**          		JR      Z,STR02          ;ZERO
0B297B D5          1226**          		PUSH    DE              ;SAVE TEXT POINTER
0B297C 78          1227**          		LD      A,B
0B297D F5          1228**  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B297E 79          1229**          		LD      A,C             ;BINARY EXPONENT
0B297F FE A1       1230**          		CP      161
0B2981 30 1C       1231**          		JR      NC,STR14
0B2983 FE 9B       1232**          		CP      155
0B2985 30 29       1233**          		JR      NC,STR15
0B2987 2F          1234**          		CPL
0B2988 FE E1       1235**          		CP      225
0B298A 38 02       1236**          		JR      C,STR13
0B298C 3E F8       1237**          		LD      A,-8
0B298E C6 1C       1238**  STR13:			ADD     A,28
0B2990 CD 1D 2E 0B 1239**          		CALL    POWR10
0B2994 F5          1240**          		PUSH    AF
0B2995 CD 0C 24 0B 1241**          		CALL    FMUL
0B2999 F1          1242**          		POP     AF
0B299A 47          1243**          		LD      B,A
0B299B F1          1244**          		POP     AF
0B299C 90          1245**          		SUB     B
0B299D 18 DE       1246**          		JR      STR11
0B299F D6 20       1247**  STR14:			SUB     32
0B29A1 CD 1D 2E 0B 1248**          		CALL    POWR10
0B29A5 F5          1249**          		PUSH    AF
0B29A6 CD 63 23 0B 1250**          		CALL    FDIV
0B29AA F1          1251**          		POP     AF
0B29AB 47          1252**          		LD      B,A
0B29AC F1          1253**          		POP     AF
0B29AD 80          1254**          		ADD     A,B
0B29AE 18 CD       1255**          		JR      STR11
0B29B0 3E 09       1256**  STR15:			LD      A,9
0B29B2 CD 1D 2E 0B 1257**          		CALL    POWR10          ;10^9
0B29B6 CD 31 2D 0B 1258**          		CALL    FCP0
0B29BA 79          1259**          		LD      A,C
0B29BB C1          1260**          		POP     BC
0B29BC 4F          1261**          		LD      C,A
0B29BD CB FC       1262**          		SET     7,H             ;IMPLIED 1
0B29BF DC 59 2D 0B 1263**          		CALL    C,X10B          ;X10, DEC B
0B29C3 D1          1264**          		POP     DE              ;RESTORE TEXT POINTER
0B29C4 CB B9       1265**          		RES     7,C
0B29C6 3E 00       1266**          		LD      A,0
0B29C8 17          1267**          		RLA                     ;PUT CARRY IN LSB
0B29C9             1268**  ;
0B29C9             1269**  ;At this point decimal normalisation has been done,
0B29C9             1270**  ;now convert to decimal digits:
0B29C9             1271**  ;      AHLH'L' = number in normalised integer form
0B29C9             1272**  ;            B = decimal place adjustment
0B29C9             1273**  ;            C = binary place adjustment (29-33)
0B29C9             1274**  ;
0B29C9 0C          1275**  STR02:			INC     C
0B29CA 08          1276**          		EX      AF,AF'          ;SAVE A
0B29CB 78          1277**          		LD      A,B
0B29CC DD CB 02 4E 1278**          		BIT     1,(IX+2)
0B29D0 20 08       1279**          		JR      NZ,STR20
0B29D2 AF          1280**          		XOR     A
0B29D3 DD BE 01    1281**          		CP      (IX+1)
0B29D6 28 0B       1282**          		JR      Z,STR21
0B29D8 3E F6       1283**          		LD      A,-10
0B29DA DD 86 01    1284**  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B29DD B7          1285**          		OR      A               ;CLEAR CARRY
0B29DE FA E3 29 0B 1286**          		JP      M,STR21
0B29E2 AF          1287**          		XOR     A
0B29E3 F5          1288**  STR21:			PUSH    AF
0B29E4 08          1289**          		EX      AF,AF'          ;RESTORE A
0B29E5 CD 8D 2D 0B 1290**  STR22:			CALL    X2              ;RL AHLH'L'
0B29E9 8F          1291**          		ADC     A,A
0B29EA FE 0A       1292**          		CP      10
0B29EC 38 05       1293**          		JR      C,STR23
0B29EE D6 0A       1294**          		SUB     10
0B29F0 D9          1295**          		EXX
0B29F1 2C          1296**          		INC     L               ;SET RESULT BIT
0B29F2 D9          1297**          		EXX
0B29F3 0D          1298**  STR23:			DEC     C
0B29F4 20 EF       1299**          		JR      NZ,STR22        ;32 TIMES
0B29F6 4F          1300**          		LD      C,A             ;REMAINDER
0B29F7 7C          1301**          		LD      A,H
0B29F8 E6 3F       1302**          		AND     3FH             ;CLEAR OUT JUNK
0B29FA 67          1303**          		LD      H,A
0B29FB F1          1304**          		POP     AF
0B29FC F2 0A 2A 0B 1305**          		JP      P,STR24
0B2A00 3C          1306**          		INC     A
0B2A01 20 1C       1307**          		JR      NZ,STR26
0B2A03 3E 04       1308**          		LD      A,4
0B2A05 B9          1309**          		CP      C               ;ROUND UP?
0B2A06 3E 00       1310**          		LD      A,0
0B2A08 18 15       1311**          		JR      STR26
0B2A0A F5          1312**  STR24:			PUSH    AF
0B2A0B 79          1313**          		LD      A,C
0B2A0C CE 30       1314**          		ADC     A,'0'           ;ADD CARRY
0B2A0E FE 30       1315**          		CP      '0'
0B2A10 28 05       1316**          		JR      Z,STR25         ;SUPPRESS ZERO
0B2A12 FE 3A       1317**          		CP      '9'+1
0B2A14 3F          1318**          		CCF
0B2A15 30 08       1319**          		JR      NC,STR26
0B2A17 E3          1320**  STR25:			EX      (SP),HL
0B2A18 CB 75       1321**          		BIT     6,L             ;ZERO FLAG
0B2A1A E3          1322**  		        EX      (SP),HL
0B2A1B 20 05       1323**          		JR      NZ,STR27
0B2A1D 3E 30       1324**          		LD      A,'0'
0B2A1F 3C          1325**  STR26:			INC     A               ;SET +VE
0B2A20 3D          1326**          		DEC     A
0B2A21 F5          1327**          		PUSH    AF              ;PUT ON STACK + CARRY
0B2A22 04          1328**  STR27:			INC     B
0B2A23 CD FD 2C 0B 1329**          		CALL    TEST_FP            ;IS HLH'L' ZERO?
0B2A27 0E 20       1330**          		LD      C,32
0B2A29 3E 00       1331**          		LD      A,0
0B2A2B 20 B8       1332**          		JR      NZ,STR22
0B2A2D F1          1333**          		POP     AF
0B2A2E F5          1334**          		PUSH    AF
0B2A2F 3E 00       1335**          		LD      A,0
0B2A31 38 B2       1336**          		JR      C,STR22
0B2A33             1337**  ;
0B2A33             1338**  ;At this point, the decimal character string is stored
0B2A33             1339**  ; on the stack. Trailing zeroes are suppressed and may
0B2A33             1340**  ; need to be replaced.
0B2A33             1341**  ;B register holds decimal point position.
0B2A33             1342**  ;Now format number and store as ASCII string:
0B2A33             1343**  ;
0B2A33 EB          1344**  STR3:			EX      DE,HL           ;STRING POINTER
0B2A34 0E FF       1345**          		LD      C,-1            ;FLAG "E"
0B2A36 16 01       1346**          		LD      D,1
0B2A38 DD 5E 01    1347**          		LD      E,(IX+1)        ;f2
0B2A3B DD CB 02 46 1348**          		BIT     0,(IX+2)
0B2A3F 20 35       1349**          		JR      NZ,STR34        ;E MODE
0B2A41 DD CB 02 4E 1350**          		BIT     1,(IX+2)
0B2A45 28 12       1351**          		JR      Z,STR31
0B2A47 78          1352**          		LD      A,B             ;F MODE
0B2A48 B7          1353**          		OR      A
0B2A49 28 05       1354**          		JR      Z,STR30
0B2A4B FA 50 2A 0B 1355**          		JP      M,STR30
0B2A4F 50          1356**          		LD      D,B
0B2A50 7A          1357**  STR30:			LD      A,D
0B2A51 DD 86 01    1358**          		ADD     A,(IX+1)
0B2A54 5F          1359**          		LD      E,A
0B2A55 FE 0B       1360**          		CP      11
0B2A57 38 19       1361**          		JR      C,STR32
0B2A59 78          1362**  STR31:			LD      A,B             ;G MODE
0B2A5A 11 01 01 00 1363**          		LD      DE,101H
0B2A5E B7          1364**          		OR      A
0B2A5F FA 76 2A 0B 1365**          		JP      M,STR34
0B2A63 28 0D       1366**          		JR      Z,STR32
0B2A65 DD 7E 01    1367**          		LD      A,(IX+1)
0B2A68 B7          1368**          		OR      A
0B2A69 20 02       1369**          		JR      NZ,STR3A
0B2A6B 3E 0A       1370**          		LD      A,10
0B2A6D B8          1371**  STR3A:			CP      B
0B2A6E 38 06       1372**          		JR      C,STR34
0B2A70 50          1373**          		LD      D,B
0B2A71 58          1374**          		LD      E,B
0B2A72 78          1375**  STR32:			LD      A,B
0B2A73 C6 81       1376**          		ADD     A,129
0B2A75 4F          1377**          		LD      C,A
0B2A76 CB FA       1378**  STR34:			SET     7,D
0B2A78 1D          1379**          		DEC     E
0B2A79 7A          1380**  STR35:			LD      A,D
0B2A7A B9          1381**          		CP      C
0B2A7B 30 0E       1382**          		JR      NC,STR33
0B2A7D F1          1383**  STR36:			POP     AF
0B2A7E 28 04       1384**          		JR      Z,STR37
0B2A80 F2 8D 2A 0B 1385**          		JP      P,STR38
0B2A84 F5          1386**  STR37:			PUSH    AF
0B2A85 1C          1387**          		INC     E
0B2A86 1D          1388**          		DEC     E
0B2A87 FA 9E 2A 0B 1389**          		JP      M,STR4
0B2A8B 3E 30       1390**  STR33:			LD      A,'0'
0B2A8D 15          1391**  STR38:			DEC     D
0B2A8E E2 95 2A 0B 1392**          		JP      PO,STR39
0B2A92 36 2E       1393**          		LD      (HL),'.'
0B2A94 23          1394**          		INC     HL
0B2A95 77          1395**  STR39:			LD      (HL),A
0B2A96 23          1396**          		INC     HL
0B2A97 1D          1397**          		DEC     E
0B2A98 F2 79 2A 0B 1398**          		JP      P,STR35
0B2A9C 18 DF       1399**          		JR      STR36
0B2A9E             1400**  ;
0B2A9E F1          1401**  STR4:			POP     AF
0B2A9F 0C          1402**  STR40:			INC     C
0B2AA0 4D          1403**          		LD      C,L
0B2AA1 20 28       1404**          		JR      NZ,STR44
0B2AA3 36 45       1405**          		LD      (HL),'E'        ;EXPONENT
0B2AA5 23          1406**          		INC     HL
0B2AA6 78          1407**          		LD      A,B
0B2AA7 3D          1408**          		DEC     A
0B2AA8 F2 B1 2A 0B 1409**          		JP      P,STR41
0B2AAC 36 2D       1410**          		LD      (HL),'-'
0B2AAE 23          1411**          		INC     HL
0B2AAF ED 44       1412**          		NEG
0B2AB1 36 30       1413**  STR41:			LD      (HL),'0'
0B2AB3 28 15       1414**          		JR      Z,STR47
0B2AB5 FE 0A       1415**          		CP      10
0B2AB7 47          1416**          		LD      B,A
0B2AB8 3E 3A       1417**          		LD      A,':'
0B2ABA 38 03       1418**          		JR      C,STR42
0B2ABC 23          1419**          		INC     HL
0B2ABD 36 30       1420**          		LD      (HL),'0'
0B2ABF 34          1421**  STR42:			INC     (HL)
0B2AC0 BE          1422**          		CP      (HL)
0B2AC1 20 05       1423**          		JR      NZ,STR43
0B2AC3 36 30       1424**          		LD      (HL),'0'
0B2AC5 2B          1425**          		DEC     HL
0B2AC6 34          1426**          		INC     (HL)
0B2AC7 23          1427**          		INC     HL
0B2AC8 10 F5       1428**  STR43:			DJNZ    STR42
0B2ACA 23          1429**  STR47:			INC     HL
0B2ACB EB          1430**  STR44:			EX      DE,HL
0B2ACC C9          1431**        			RET
0B2ACD             1432**  ;
0B2ACD             1433**  ;Support subroutines:
0B2ACD             1434**  ;
0B2ACD DD 46 04    1435**  DLOAD5:			LD      B,(IX+4)
0B2AD0 D9          1436**          		EXX
0B2AD1 DD 5E 00    1437**          		LD      E,(IX+0)
0B2AD4 DD 56 01    1438**          		LD      D,(IX+1)
0B2AD7 D9          1439**          		EXX
0B2AD8 DD 5E 02    1440**          		LD      E,(IX+2)
0B2ADB DD 56 03    1441**          		LD      D,(IX+3)
0B2ADE C9          1442**          		RET
0B2ADF             1443**  ;
0B2ADF DD 46 06    1444**  DLOAD5_SPL:		LD      B,(IX+6)
0B2AE2 D9          1445**  			EXX
0B2AE3 DD 17 00    1446**  			LD	DE, (IX+0)
0B2AE6 D9          1447**  			EXX
0B2AE7 DD 17 03    1448**  			LD	DE, (IX+3)
0B2AEA C9          1449**  			RET
0B2AEB             1450**  ;
0B2AEB             1451**  ;CON_FP - Get unsigned numeric constant from ASCII string.
0B2AEB             1452**  ;   Inputs: ASCII string at (IX).
0B2AEB             1453**  ;  Outputs: Variable-type result in HLH'L'C
0B2AEB             1454**  ;           IX updated (points to delimiter)
0B2AEB             1455**  ;           A7 = 0 (numeric marker)
0B2AEB             1456**  ;
0B2AEB CD 21 2D 0B 1457**  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B2AEF 0E 00       1458**          		LD      C,0             ;TRUNCATION COUNTER
0B2AF1 CD 7F 2B 0B 1459**          		CALL    UINT          ;GET INTEGER PART
0B2AF5 FE 2E       1460**          		CP      '.'
0B2AF7 06 00       1461**          		LD      B,0             ;DECL. PLACE COUNTER
0B2AF9 CC 7D 2B 0B 1462**          		CALL    Z,NUMBIX        ;GET FRACTION PART
0B2AFD FE 45       1463**          		CP      'E'
0B2AFF 3E 00       1464**          		LD      A,0             ;INITIALISE EXPONENT
0B2B01 CC 4B 2B 0B 1465**          		CALL    Z,GETEXP        ;GET EXPONENT
0B2B05 CB 7C       1466**          		BIT     7,H
0B2B07 20 08       1467**          		JR      NZ,CON0         ;INTEGER OVERFLOW
0B2B09 B7          1468**          		OR      A
0B2B0A 20 05       1469**          		JR      NZ,CON0         ;EXPONENT NON-ZERO
0B2B0C B8          1470**          		CP      B
0B2B0D 20 02       1471**          		JR      NZ,CON0         ;DECIMAL POINT
0B2B0F B9          1472**          		CP      C
0B2B10 C8          1473**          		RET     Z               ;INTEGER
0B2B11 90          1474**  CON0:			SUB     B
0B2B12 81          1475**          		ADD     A,C
0B2B13 0E 9F       1476**          		LD      C,159
0B2B15 CD 84 2C 0B 1477**          		CALL    FLOAT_
0B2B19 CB BC       1478**          		RES     7,H             ;DITCH IMPLIED 1
0B2B1B B7          1479**          		OR      A
0B2B1C C8          1480**          		RET     Z               ;DONE
0B2B1D FA 2B 2B 0B 1481**          		JP      M,CON2          ;NEGATIVE EXPONENT
0B2B21 CD 1D 2E 0B 1482**          		CALL    POWR10
0B2B25 CD 0C 24 0B 1483**          		CALL    FMUL            ;SCALE
0B2B29 AF          1484**          		XOR     A
0B2B2A C9          1485**          		RET
0B2B2B FE DA       1486**  CON2:			CP      -38
0B2B2D 38 0C       1487**          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B2B2F ED 44       1488**          		NEG
0B2B31 CD 1D 2E 0B 1489**          		CALL    POWR10
0B2B35 CD 63 23 0B 1490**          		CALL    FDIV            ;SCALE
0B2B39 AF          1491**          		XOR     A
0B2B3A C9          1492**          		RET
0B2B3B F5          1493**  CON3:			PUSH    AF
0B2B3C 3E 26       1494**          		LD      A,38
0B2B3E CD 1D 2E 0B 1495**          		CALL    POWR10
0B2B42 CD 63 23 0B 1496**          		CALL    FDIV
0B2B46 F1          1497**          		POP     AF
0B2B47 C6 26       1498**          		ADD     A,38
0B2B49 18 E0       1499**          		JR      CON2
0B2B4B             1500**  ;
0B2B4B             1501**  ;GETEXP - Get decimal exponent from string
0B2B4B             1502**  ;     Inputs: ASCII string at (IX)
0B2B4B             1503**  ;             (IX points at 'E')
0B2B4B             1504**  ;             A = initial value
0B2B4B             1505**  ;    Outputs: A = new exponent
0B2B4B             1506**  ;             IX updated.
0B2B4B             1507**  ;   Destroys: A,A',IX,F,F'
0B2B4B             1508**  ;
0B2B4B C5          1509**  GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B2B4C 47          1510**          		LD      B,A             ;INITIAL VALUE
0B2B4D 0E 02       1511**          		LD      C,2             ;2 DIGITS MAX
0B2B4F DD 23       1512**          		INC     IX              ;BUMP PAST 'E'
0B2B51 CD 3B 2F 0B 1513**          		CALL    SIGNQ
0B2B55 08          1514**          		EX      AF,AF'          ;SAVE EXPONENT SIGN
0B2B56 CD 31 2F 0B 1515**  GETEX1:			CALL    DIGITQ
0B2B5A 38 18       1516**          		JR      C,GETEX2
0B2B5C 78          1517**          		LD      A,B             ;B=B*10
0B2B5D 87          1518**          		ADD     A,A
0B2B5E 87          1519**          		ADD     A,A
0B2B5F 80          1520**          		ADD     A,B
0B2B60 87          1521**          		ADD     A,A
0B2B61 47          1522**          		LD      B,A
0B2B62 DD 7E 00    1523**          		LD      A,(IX)          ;GET BACK DIGIT
0B2B65 DD 23       1524**          		INC     IX
0B2B67 E6 0F       1525**          		AND     0FH             ;MASK UNWANTED BITS
0B2B69 80          1526**          		ADD     A,B             ;ADD IN DIGIT
0B2B6A 47          1527**          		LD      B,A
0B2B6B 0D          1528**          		DEC     C
0B2B6C F2 56 2B 0B 1529**          		JP      P,GETEX1
0B2B70 06 64       1530**          		LD      B,100           ;FORCE OVERFLOW
0B2B72 18 E2       1531**          		JR      GETEX1
0B2B74 08          1532**  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B2B75 FE 2D       1533**          		CP      '-'
0B2B77 78          1534**          		LD      A,B
0B2B78 C1          1535**          		POP     BC              ;RESTORE
0B2B79 C0          1536**          		RET     NZ
0B2B7A ED 44       1537**          		NEG                     ;NEGATE EXPONENT
0B2B7C C9          1538**          		RET
0B2B7D             1539**  ;
0B2B7D             1540**  ;UINT: Get unsigned integer from string.
0B2B7D             1541**  ;    Inputs: string at (IX)
0B2B7D             1542**  ;            C = truncated digit count
0B2B7D             1543**  ;                (initially zero)
0B2B7D             1544**  ;            B = total digit count
0B2B7D             1545**  ;            HLH'L' = initial value
0B2B7D             1546**  ;   Outputs: HLH'L' = number (binary integer)
0B2B7D             1547**  ;            A = delimiter.
0B2B7D             1548**  ;            B, C & IX updated
0B2B7D             1549**  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B2B7D             1550**  ;
0B2B7D DD 23       1551**  NUMBIX:			INC     IX
0B2B7F CD 31 2F 0B 1552**  UINT:			CALL    DIGITQ
0B2B83 D8          1553**          		RET     C
0B2B84 04          1554**          		INC     B               ;INCREMENT DIGIT COUNT
0B2B85 DD 23       1555**          		INC     IX
0B2B87 CD 7A 2D 0B 1556**          		CALL    X10             ;*10 & COPY OLD VALUE
0B2B8B 38 15       1557**          		JR      C,NUMB1         ;OVERFLOW
0B2B8D 0D          1558**          		DEC     C               ;SEE IF TRUNCATED
0B2B8E 0C          1559**          		INC     C
0B2B8F 20 11       1560**          		JR      NZ,NUMB1        ;IMPORTANT!
0B2B91 E6 0F       1561**          		AND     0FH
0B2B93 D9          1562**          		EXX
0B2B94 06 00       1563**          		LD      B,0
0B2B96 4F          1564**          		LD      C,A
0B2B97 52 09       1565**          		ADD.S   HL,BC           ;ADD IN DIGIT
0B2B99 D9          1566**          		EXX
0B2B9A 30 E3       1567**          		JR      NC,UINT
0B2B9C 52 23       1568**          		INC.S   HL              ;CARRY
0B2B9E 7C          1569**          		LD      A,H
0B2B9F B5          1570**          		OR      L
0B2BA0 20 DD       1571**          		JR      NZ,UINT
0B2BA2 0C          1572**  NUMB1:			INC     C               ;TRUNCATION COUNTER
0B2BA3 CD D8 2C 0B 1573**          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B2BA7 18 D6       1574**          		JR      UINT
0B2BA9             1575**  ;
0B2BA9             1576**  ;FIX - Fix number to specified exponent value.
0B2BA9             1577**  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
0B2BA9             1578**  ;            A = desired exponent (A>C)
0B2BA9             1579**  ;   Outputs: HLH'L'C = fixed number (unsigned)
0B2BA9             1580**  ;            fraction shifted into B'C'
0B2BA9             1581**  ;            A'F' positive if integer input
0B2BA9             1582**  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
0B2BA9             1583**  ;
0B2BA9 08          1584**  FIX:			EX      AF,AF'
0B2BAA AF          1585**          		XOR     A
0B2BAB 08          1586**          		EX      AF,AF'
0B2BAC CB FC       1587**          		SET     7,H             ;IMPLIED 1
0B2BAE CD DD 2C 0B 1588**  FIX1:			CALL    DIV2
0B2BB2 B9          1589**          		CP      C
0B2BB3 C8          1590**          		RET     Z
0B2BB4 D2 AE 2B 0B 1591**          		JP      NC,FIX1
0B2BB8 C3 EC 2C 0B 1592**          		JP      OFLOW
0B2BBC             1593**  ;
0B2BBC             1594**  ;SFIX - Convert to integer if necessary.
0B2BBC             1595**  ;    Input: Variable-type number in HLH'L'C
0B2BBC             1596**  ;   Output: Integer in HLH'L', C=0
0B2BBC             1597**  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
0B2BBC             1598**  ;
0B2BBC             1599**  ;NEGATE - Negate HLH'L'
0B2BBC             1600**  ;    Destroys: H,L,H',L',F
0B2BBC             1601**  ;
0B2BBC CD D5 2C 0B 1602**  FIX2:			CALL    SWAP_FP
0B2BC0 CD C8 2B 0B 1603**          		CALL    SFIX_FP
0B2BC4 CD D5 2C 0B 1604**          		CALL    SWAP_FP
0B2BC8 0D          1605**  SFIX_FP:			DEC     C
0B2BC9 0C          1606**          		INC     C
0B2BCA C8          1607**          		RET     Z               ;INTEGER/ZERO
0B2BCB CB 7C       1608**          		BIT     7,H             ;SIGN
0B2BCD F5          1609**          		PUSH    AF
0B2BCE 3E 9F       1610**          		LD      A,159
0B2BD0 CD A9 2B 0B 1611**          		CALL    FIX
0B2BD4 F1          1612**          		POP     AF
0B2BD5 0E 00       1613**          		LD      C,0
0B2BD7 C8          1614**          		RET     Z
0B2BD8 B7          1615**  NEGATE:			OR      A               ;CLEAR CARRY
0B2BD9 D9          1616**          		EXX
0B2BDA D5          1617**  NEG0:			PUSH    DE
0B2BDB EB          1618**          		EX      DE,HL
0B2BDC 21 00 00 00 1619**          		LD      HL,0
0B2BE0 52 ED 52    1620**          		SBC.S   HL,DE
0B2BE3 D1          1621**          		POP     DE
0B2BE4 D9          1622**          		EXX
0B2BE5 D5          1623**          		PUSH    DE
0B2BE6 EB          1624**          		EX      DE,HL
0B2BE7 21 00 00 00 1625**          		LD      HL,0
0B2BEB 52 ED 52    1626**          		SBC.S   HL,DE
0B2BEE D1          1627**          		POP     DE
0B2BEF C9          1628**          		RET
0B2BF0             1629**  ;
0B2BF0             1630**  ;NEG - Negate HLH'L'B'C'
0B2BF0             1631**  ;    Also complements A (used in FADD)
0B2BF0             1632**  ;    Destroys: A,H,L,B',C',H',L',F
0B2BF0             1633**  ;
0B2BF0 D9          1634**  NEG_:			EXX
0B2BF1 2F          1635**          		CPL
0B2BF2 E5          1636**          		PUSH    HL
0B2BF3 B7          1637**          		OR      A               ;CLEAR CARRY
0B2BF4 21 00 00 00 1638**          		LD      HL,0
0B2BF8 52 ED 42    1639**          		SBC.S   HL,BC
0B2BFB 44          1640**          		LD      B,H
0B2BFC 4D          1641**          		LD      C,L
0B2BFD E1          1642**          		POP     HL
0B2BFE 18 DA       1643**          		JR      NEG0
0B2C00             1644**  ;
0B2C00             1645**  ;SCALE - Trig scaling.
0B2C00             1646**  ;MOD48 - 48-bit floating-point "modulus" (remainder).
0B2C00             1647**  ;   Inputs: HLH'L'C unsigned floating-point dividend
0B2C00             1648**  ;           DED'E'B'C'B unsigned 48-bit FP divisor
0B2C00             1649**  ;  Outputs: HLH'L'C floating point remainder (H7=1)
0B2C00             1650**  ;           E = quotient (bit 7 is sticky)
0B2C00             1651**  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B2C00             1652**  ;FLO48 - Float unsigned number (48 bits)
0B2C00             1653**  ;    Input/output in HLH'L'B'C'C
0B2C00             1654**  ;   Destroys: C,H,L,B',C',H',L',F
0B2C00             1655**  ;
0B2C00 3E 96       1656**  SCALE:			LD      A,150
0B2C02 B9          1657**          		CP      C
0B2C03 3E 17       1658**          		LD      A,ACLOST
0B2C05 DA 7B 21 0B 1659**          		JP      C,ERROR_FP_         ;"Accuracy lost"
0B2C09 CD 46 27 0B 1660**          		CALL    PIBY4
0B2C0D D9          1661**          		EXX
0B2C0E 01 69 21 00 1662**          		LD      BC,2169H        ;3.141592653589793238
0B2C12 D9          1663**          		EXX
0B2C13 CB FA       1664**  MOD48:			SET     7,D             ;IMPLIED 1
0B2C15 CB FC       1665**          		SET     7,H
0B2C17 79          1666**          		LD      A,C
0B2C18 0E 00       1667**          		LD      C,0             ;INIT QUOTIENT
0B2C1A DD 21 00 00 1668**          		LD      IX,0
       00          
0B2C1F DD E5       1669**          		PUSH    IX              ;PUT ZERO ON STACK
0B2C21 B8          1670**          		CP      B
0B2C22 38 46       1671**          		JR      C,MOD485        ;DIVIDEND<DIVISOR
0B2C24 D9          1672**  MOD481:			EXX                     ;CARRY=0 HERE
0B2C25 E3          1673**          		EX      (SP),HL
0B2C26 52 ED 42    1674**          		SBC.S   HL,BC
0B2C29 E3          1675**          		EX      (SP),HL
0B2C2A 52 ED 52    1676**          		SBC.S   HL,DE
0B2C2D D9          1677**          		EXX
0B2C2E 52 ED 52    1678**          		SBC.S   HL,DE
0B2C31 30 0C       1679**          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B2C33 D9          1680**          		EXX
0B2C34 E3          1681**          		EX      (SP),HL
0B2C35 52 09       1682**          		ADD.S   HL,BC
0B2C37 E3          1683**          		EX      (SP),HL
0B2C38 52 ED 5A    1684**          		ADC.S   HL,DE
0B2C3B D9          1685**          		EXX
0B2C3C 52 ED 5A    1686**          		ADC.S   HL,DE
0B2C3F 3F          1687**  MOD482:			CCF
0B2C40 CB 11       1688**          		RL      C               ;QUOTIENT
0B2C42 30 02       1689**          		JR      NC,MOD483
0B2C44 CB F9       1690**          		SET     7,C             ;STICKY BIT
0B2C46 3D          1691**  MOD483:			DEC     A
0B2C47 B8          1692**          		CP      B
0B2C48 38 1F       1693**          		JR      C,MOD484        ;DIVIDEND<DIVISOR
0B2C4A E3          1694**          		EX      (SP),HL
0B2C4B 52 29       1695**          		ADD.S   HL,HL           ;DIVIDEND * 2
0B2C4D E3          1696**          		EX      (SP),HL
0B2C4E D9          1697**          		EXX
0B2C4F 52 ED 6A    1698**          		ADC.S   HL,HL
0B2C52 D9          1699**          		EXX
0B2C53 52 ED 6A    1700**          		ADC.S   HL,HL
0B2C56 30 CC       1701**          		JR      NC,MOD481       ;AGAIN
0B2C58 B7          1702**          		OR      A
0B2C59 D9          1703**          		EXX
0B2C5A E3          1704**          		EX      (SP),HL
0B2C5B 52 ED 42    1705**          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B2C5E E3          1706**          		EX      (SP),HL
0B2C5F 52 ED 52    1707**          		SBC.S   HL,DE
0B2C62 D9          1708**          		EXX
0B2C63 52 ED 52    1709**          		SBC.S   HL,DE
0B2C66 B7          1710**          		OR      A
0B2C67 18 D6       1711**          		JR      MOD482
0B2C69             1712**  ;
0B2C69 3C          1713**  MOD484:			INC     A
0B2C6A 59          1714**  MOD485:			LD      E,C             ;QUOTIENT
0B2C6B 4F          1715**          		LD      C,A             ;REMAINDER EXPONENT
0B2C6C D9          1716**          		EXX
0B2C6D C1          1717**          		POP     BC
0B2C6E D9          1718**          		EXX
0B2C6F CB 7C       1719**  FLO48:			BIT     7,H
0B2C71 C0          1720**          		RET     NZ
0B2C72 D9          1721**          		EXX
0B2C73 CB 21       1722**          		SLA     C
0B2C75 CB 10       1723**          		RL      B
0B2C77 52 ED 6A    1724**          		ADC.S   HL,HL
0B2C7A D9          1725**          		EXX
0B2C7B 52 ED 6A    1726**          		ADC.S   HL,HL
0B2C7E 0D          1727**          		DEC     C
0B2C7F C2 6F 2C 0B 1728**          		JP      NZ,FLO48
0B2C83 C9          1729**          		RET
0B2C84             1730**  ;
0B2C84             1731**  ;Float unsigned number
0B2C84             1732**  ;    Input/output in HLH'L'C
0B2C84             1733**  ;   Destroys: C,H,L,H',L',F
0B2C84             1734**  ;
0B2C84 CB 7C       1735**  FLOAT_:			BIT     7,H
0B2C86 C0          1736**          		RET     NZ
0B2C87 D9          1737**          		EXX                     ;SAME AS "X2"
0B2C88 52 29       1738**          		ADD.S   HL,HL           ;TIME-CRITICAL
0B2C8A D9          1739**          		EXX                     ;REGION
0B2C8B 52 ED 6A    1740**          		ADC.S   HL,HL           ;(BENCHMARKS)
0B2C8E 0D          1741**          		DEC     C
0B2C8F C2 84 2C 0B 1742**          		JP      NZ,FLOAT_
0B2C93 C9          1743**          		RET
0B2C94             1744**  ;
0B2C94             1745**  ;SFLOAT - Convert to floating-point if necessary.
0B2C94             1746**  ;    Input: Variable-type number in HLH'L'C
0B2C94             1747**  ;    Output: Floating-point in HLH'L'C
0B2C94             1748**  ;    Destroys: A,C,H,L,H',L',F
0B2C94             1749**  ;
0B2C94 08          1750**  FLOATA:			EX      AF,AF'
0B2C95             1751**          		; ADD     A,(RTABLE-DTABLE)/3
0B2C95 C6 2A       1752**          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2C97 08          1753**          		EX      AF,AF'
0B2C98 CD D5 2C 0B 1754**  FLOAT2:			CALL    SWAP_FP
0B2C9C CD A4 2C 0B 1755**          		CALL    SFLOAT_FP
0B2CA0 CD D5 2C 0B 1756**          		CALL    SWAP_FP
0B2CA4 0D          1757**  SFLOAT_FP:			DEC     C
0B2CA5 0C          1758**          		INC     C
0B2CA6 C0          1759**          		RET     NZ              ;ALREADY FLOATING-POINT
0B2CA7 CD FD 2C 0B 1760**          		CALL    TEST_FP
0B2CAB C8          1761**          		RET     Z               ;ZERO
0B2CAC 7C          1762**          		LD      A,H
0B2CAD B7          1763**          		OR      A
0B2CAE FC D8 2B 0B 1764**          		CALL    M,NEGATE
0B2CB2 0E 9F       1765**          		LD      C,159
0B2CB4 CD 84 2C 0B 1766**          		CALL    FLOAT_
0B2CB8 B7          1767**          		OR      A
0B2CB9 F8          1768**          		RET     M               ;NEGATIVE
0B2CBA CB BC       1769**          		RES     7,H
0B2CBC C9          1770**          		RET
0B2CBD             1771**  ;
0B2CBD             1772**  ;ROUND UP
0B2CBD             1773**  ;Return with carry set if 32-bit overflow
0B2CBD             1774**  ;   Destroys: H,L,B',C',H',L',F
0B2CBD             1775**  ;
0B2CBD D9          1776**  ADD1_FP:			EXX
0B2CBE 01 01 00 00 1777**          		LD      BC,1
0B2CC2 52 09       1778**          		ADD.S   HL,BC
0B2CC4 D9          1779**          		EXX
0B2CC5 D0          1780**          		RET     NC
0B2CC6 C5          1781**          		PUSH    BC
0B2CC7 01 01 00 00 1782**          		LD      BC,1
0B2CCB 52 09       1783**          		ADD.S   HL,BC
0B2CCD C1          1784**          		POP     BC
0B2CCE C9          1785**          		RET
0B2CCF             1786**  ;
0B2CCF             1787**  ;ODD - Add one if even, leave alone if odd.
0B2CCF             1788**  ; (Used to perform unbiassed rounding, i.e.
0B2CCF             1789**  ;  number is rounded up half the time)
0B2CCF             1790**  ;    Destroys: L',F (carry cleared)
0B2CCF             1791**  ;
0B2CCF B7          1792**  ODD:			OR      A               ;CLEAR CARRY
0B2CD0 D9          1793**          		EXX
0B2CD1 CB C5       1794**          		SET     0,L             ;MAKE ODD
0B2CD3 D9          1795**          		EXX
0B2CD4 C9          1796**          		RET
0B2CD5             1797**  ;
0B2CD5             1798**  ;SWAP_FP - Swap arguments.
0B2CD5             1799**  ;    Exchanges DE,HL D'E',H'L' and B,C
0B2CD5             1800**  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B2CD5             1801**  ;SWAP1 - Swap DEHL with D'E'H'L'
0B2CD5             1802**  ;    Destroys: D,E,H,L,D',E',H',L'
0B2CD5             1803**  ;
0B2CD5 79          1804**  SWAP_FP:			LD      A,C
0B2CD6 48          1805**          		LD      C,B
0B2CD7 47          1806**          		LD      B,A
0B2CD8 EB          1807**  SWAP1:			EX      DE,HL
0B2CD9 D9          1808**          		EXX
0B2CDA EB          1809**          		EX      DE,HL
0B2CDB D9          1810**          		EXX
0B2CDC C9          1811**          		RET
0B2CDD             1812**  ;
0B2CDD             1813**  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
0B2CDD             1814**  ; INCC - destroys C,F
0B2CDD             1815**  ; OFLOW
0B2CDD             1816**  ;
0B2CDD CD 96 2D 0B 1817**  DIV2:			CALL    D2
0B2CE1 D9          1818**          		EXX
0B2CE2 CB 18       1819**          		RR      B
0B2CE4 CB 19       1820**          		RR      C
0B2CE6 08          1821**          		EX      AF,AF'
0B2CE7 B0          1822**          		OR      B
0B2CE8 08          1823**          		EX      AF,AF'
0B2CE9 D9          1824**          		EXX
0B2CEA 0C          1825**  INCC:			INC     C
0B2CEB C0          1826**          		RET     NZ
0B2CEC 3E 14       1827**  OFLOW:			LD      A,TOOBIG_FP
0B2CEE C3 7B 21 0B 1828**          		JP      ERROR_FP_           ;"Too big"
0B2CF2             1829**  ;
0B2CF2             1830**  ; FTEST - Test for zero & sign
0B2CF2             1831**  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
0B2CF2             1832**  ;
0B2CF2 CD FD 2C 0B 1833**  FTEST_FP:			CALL    TEST_FP
0B2CF6 C8          1834**          		RET     Z
0B2CF7 7C          1835**          		LD      A,H
0B2CF8 E6 80       1836**          		AND     10000000B
0B2CFA F6 40       1837**          		OR      01000000B
0B2CFC C9          1838**          		RET
0B2CFD             1839**  ;
0B2CFD             1840**  ; TEST_FP - Test HLH'L' for zero.
0B2CFD             1841**  ;     Output: Z-flag set & A=0 if HLH'L'=0
0B2CFD             1842**  ;     Destroys: A,F
0B2CFD             1843**  ;
0B2CFD 7C          1844**  TEST_FP:			LD      A,H
0B2CFE B5          1845**          		OR      L
0B2CFF D9          1846**          		EXX
0B2D00 B4          1847**          		OR      H
0B2D01 B5          1848**          		OR      L
0B2D02 D9          1849**          		EXX
0B2D03 C9          1850**          		RET
0B2D04             1851**  ;
0B2D04             1852**  ; FCOMP - Compare two numbers
0B2D04             1853**  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
0B2D04             1854**  ;
0B2D04 78          1855**  FCOMP_FP:			LD      A,B
0B2D05 B1          1856**          		OR      C               ;Both integer?
0B2D06 20 0B       1857**          		JR      NZ,FCOMP1
0B2D08 CD 1D 2D 0B 1858**          		CALL    ICP
0B2D0C 3E 00       1859**  FCOMP0:			LD      A,0
0B2D0E C8          1860**          		RET     Z               ;Equal
0B2D0F 3E 80       1861**          		LD      A,80H
0B2D11 1F          1862**          		RRA
0B2D12 C9          1863**          		RET
0B2D13             1864**  ;
0B2D13 CD 98 2C 0B 1865**  FCOMP1:			CALL    FLOAT2          ;Float both
0B2D17 CD 2B 2D 0B 1866**          		CALL    FCP
0B2D1B 18 EF       1867**          		JR      FCOMP0
0B2D1D             1868**  ;
0B2D1D             1869**  ; Integer and floating point compare.
0B2D1D             1870**  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
0B2D1D             1871**  ; Result pre-set to FALSE
0B2D1D             1872**  ; ICP1, FCP1 destroy A,F
0B2D1D             1873**  ;
0B2D1D             1874**  ; ZERO - Return zero.
0B2D1D             1875**  ;  Destroys: A,C,H,L,H',L'
0B2D1D             1876**  ;
0B2D1D CD 50 2D 0B 1877**  ICP:			CALL    ICP1
0B2D21 3E 00       1878**  ZERO_FP:			LD      A,0
0B2D23 D9          1879**          		EXX
0B2D24 67          1880**          		LD      H,A
0B2D25 6F          1881**  	       		LD      L,A
0B2D26 D9          1882**          		EXX
0B2D27 67          1883**        			LD      H,A
0B2D28 6F          1884**       			LD      L,A
0B2D29 4F          1885**  	    		LD      C,A
0B2D2A C9          1886**          		RET
0B2D2B             1887**  ;
0B2D2B CD 42 2D 0B 1888**  FCP:			CALL    FCP1
0B2D2F 18 F0       1889**          		JR      ZERO_FP            ;PRESET FALSE
0B2D31             1890**  ;
0B2D31 79          1891**  FCP0:			LD      A,C
0B2D32 B8          1892**          		CP      B               ;COMPARE EXPONENTS
0B2D33 C0          1893**          		RET     NZ
0B2D34             1894**  ICP0:
0B2D34 52 ED 52    1895**  			SBC.S   HL,DE           ;COMP MANTISSA MSB
0B2D37 52 19       1896**          		ADD.S   HL,DE
0B2D39 C0          1897**          		RET     NZ
0B2D3A D9          1898**          		EXX
0B2D3B 52 ED 52    1899**          		SBC.S   HL,DE           ;COMP MANTISSA LSB
0B2D3E 52 19       1900**          		ADD.S   HL,DE
0B2D40 D9          1901**          		EXX
0B2D41 C9          1902**          		RET
0B2D42             1903**  ;
0B2D42 7C          1904**  FCP1:			LD      A,H
0B2D43 AA          1905**          		XOR     D
0B2D44 7C          1906**          		LD      A,H
0B2D45 17          1907**          		RLA
0B2D46 F8          1908**          		RET     M
0B2D47 30 E8       1909**          		JR      NC,FCP0
0B2D49 CD 31 2D 0B 1910**          		CALL    FCP0
0B2D4D C8          1911**          		RET     Z               ;** V0.1 BUG FIX
0B2D4E 3F          1912**          		CCF
0B2D4F C9          1913**          		RET
0B2D50             1914**  ;
0B2D50 7C          1915**  ICP1:			LD      A,H
0B2D51 AA          1916**          		XOR     D
0B2D52 F2 34 2D 0B 1917**          		JP      P,ICP0
0B2D56 7C          1918**          		LD      A,H
0B2D57 17          1919**          		RLA
0B2D58 C9          1920**          		RET
0B2D59             1921**  ;
0B2D59             1922**  ; ADD - Integer add.
0B2D59             1923**  ; Carry, sign & zero flags valid on exit
0B2D59             1924**  ;     Destroys: H,L,H',L',F
0B2D59             1925**  ;
0B2D59 05          1926**  X10B:			DEC     B
0B2D5A 0C          1927**          		INC     C
0B2D5B CD A2 2D 0B 1928**  X5:			CALL    COPY0
0B2D5F CD 95 2D 0B 1929**          		CALL    D2C
0B2D63 CD 95 2D 0B 1930**          		CALL    D2C
0B2D67 08          1931**          		EX      AF,AF'          ;SAVE CARRY
0B2D68 D9          1932**  ADD_:			EXX
0B2D69 52 19       1933**          		ADD.S   HL,DE
0B2D6B D9          1934**          		EXX
0B2D6C 52 ED 5A    1935**          		ADC.S   HL,DE
0B2D6F C9          1936**          		RET
0B2D70             1937**  ;
0B2D70             1938**  ; SUB - Integer subtract.
0B2D70             1939**  ; Carry, sign & zero flags valid on exit
0B2D70             1940**  ;     Destroys: H,L,H',L',F
0B2D70             1941**  ;
0B2D70 D9          1942**  SUB_:			EXX
0B2D71 B7          1943**          		OR      A
0B2D72 52 ED 52    1944**          		SBC.S   HL,DE
0B2D75 D9          1945**          		EXX
0B2D76 52 ED 52    1946**          		SBC.S   HL,DE
0B2D79 C9          1947**          		RET
0B2D7A             1948**  ;
0B2D7A             1949**  ; X10 - unsigned integer * 10
0B2D7A             1950**  ;    Inputs: HLH'L' initial value
0B2D7A             1951**  ;   Outputs: DED'E' = initial HLH'L'
0B2D7A             1952**  ;            Carry bit set if overflow
0B2D7A             1953**  ;            If carry not set HLH'L'=result
0B2D7A             1954**  ;  Destroys: D,E,H,L,D',E',H',L',F
0B2D7A             1955**  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
0B2D7A             1956**  ;     Carry set if MSB=1 before shift.
0B2D7A             1957**  ;     Sign set if MSB=1 after shift.
0B2D7A             1958**  ;     Destroys: H,L,H',L',F
0B2D7A             1959**  ;
0B2D7A CD A2 2D 0B 1960**  X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B2D7E CD 8D 2D 0B 1961**          		CALL    X2
0B2D82 D8          1962**          		RET     C               ;TOO BIG
0B2D83 CD 8D 2D 0B 1963**          		CALL    X2
0B2D87 D8          1964**          		RET     C
0B2D88 CD 68 2D 0B 1965**          		CALL    ADD_
0B2D8C D8          1966**          		RET     C
0B2D8D D9          1967**  X2:			EXX
0B2D8E 52 29       1968**          		ADD.S   HL,HL
0B2D90 D9          1969**          		EXX
0B2D91 52 ED 6A    1970**          		ADC.S   HL,HL
0B2D94 C9          1971**          		RET
0B2D95             1972**  ;
0B2D95             1973**  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
0B2D95             1974**  ;     Carry set if LSB=1 before shift.
0B2D95             1975**  ;     Destroys: H,L,H',L',F
0B2D95             1976**  ;
0B2D95 0C          1977**  D2C:			INC     C
0B2D96 CB 3C       1978**  D2:			SRL     H
0B2D98 CB 1D       1979**          		RR      L
0B2D9A D9          1980**          		EXX
0B2D9B CB 1C       1981**          		RR      H
0B2D9D CB 1D       1982**          		RR      L
0B2D9F D9          1983**          		EXX
0B2DA0 C9          1984**          		RET
0B2DA1             1985**  ;
0B2DA1             1986**  ; COPY - COPY HLH'L'C INTO DED'E'B
0B2DA1             1987**  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
0B2DA1             1988**  ;
0B2DA1 41          1989**  COPY_:			LD      B,C
0B2DA2 54          1990**  COPY0:			LD      D,H
0B2DA3 5D          1991**          		LD      E,L
0B2DA4 D9          1992**          		EXX
0B2DA5 54          1993**          		LD      D,H
0B2DA6 5D          1994**          		LD      E,L
0B2DA7 D9          1995**          		EXX
0B2DA8 C9          1996**          		RET
0B2DA9             1997**  ;
0B2DA9             1998**  ; SQUARE - PUSH X*X
0B2DA9             1999**  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
0B2DA9             2000**  ;   Destroys: SP,IX
0B2DA9             2001**  ;
0B2DA9 CD A1 2D 0B 2002**  SQUARE:			CALL    COPY_
0B2DAD CD 0C 24 0B 2003**          		CALL    FMUL
0B2DB1 DD E1       2004**  PUSH5:			POP     IX              ;RETURN ADDRESS
0B2DB3 C5          2005**          		PUSH    BC
0B2DB4 E5          2006**          		PUSH    HL
0B2DB5 D9          2007**          		EXX
0B2DB6 E5          2008**          		PUSH    HL
0B2DB7 D9          2009**          		EXX
0B2DB8 DD E9       2010**          		JP      (IX)            ;"RETURN"
0B2DBA             2011**  ;
0B2DBA             2012**  ; POP5 - POP DED'E'B OFF STACK.
0B2DBA             2013**  ;   Destroys: A,B,D,E,D',E',SP,IX
0B2DBA             2014**  ;
0B2DBA DD E1       2015**  POP5:			POP     IX              ;RETURN ADDRESS
0B2DBC D9          2016**          		EXX
0B2DBD D1          2017**          		POP     DE
0B2DBE D9          2018**          		EXX
0B2DBF D1          2019**          		POP     DE
0B2DC0 79          2020**          		LD      A,C
0B2DC1 C1          2021**          		POP     BC
0B2DC2 41          2022**          		LD      B,C
0B2DC3 4F          2023**          		LD      C,A
0B2DC4 DD E9       2024**          		JP      (IX)            ;"RETURN"
0B2DC6             2025**  ;
0B2DC6             2026**  ; RATIO - Calculate (X-1)/(X+1)
0B2DC6             2027**  ;     Inputs: X in HLH'L'C
0B2DC6             2028**  ;    Outputs: (X-1)/(X+1) in HLH'L'C
0B2DC6             2029**  ;   Destroys: Everything except IY,SP,I
0B2DC6             2030**  ;
0B2DC6 CD B1 2D 0B 2031**  RATIO:			CALL    PUSH5           ;SAVE X
0B2DCA CD 39 27 0B 2032**          		CALL    DONE
0B2DCE CD FA 22 0B 2033**          		CALL    FADD
0B2DD2 CD BA 2D 0B 2034**          		CALL    POP5            ;RESTORE X
0B2DD6 CD B1 2D 0B 2035**          		CALL    PUSH5           ;SAVE X+1
0B2DDA CD D5 2C 0B 2036**          		CALL    SWAP_FP
0B2DDE CD 39 27 0B 2037**          		CALL    DONE
0B2DE2 CD E1 22 0B 2038**          		CALL    FSUB
0B2DE6 CD BA 2D 0B 2039**          		CALL    POP5            ;RESTORE X+1
0B2DEA C3 63 23 0B 2040**          		JP      FDIV
0B2DEE             2041**  ;
0B2DEE             2042**  ; POLY - Evaluate a polynomial.
0B2DEE             2043**  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
0B2DEE             2044**  ;             Polynomial coefficients follow call.
0B2DEE             2045**  ;    Outputs: Result in HLH'L'C
0B2DEE             2046**  ;   Destroys: Everything except IY,SP,I
0B2DEE             2047**  ; Routine terminates on finding a coefficient >=1.
0B2DEE             2048**  ; Note: The last coefficient is EXECUTED on return
0B2DEE             2049**  ;       so must contain only innocuous bytes!
0B2DEE             2050**  ;
0B2DEE DD 21 03 00 2051**  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
0B2DF3 DD 39       2052**          		ADD     IX, SP
0B2DF5 DD E3       2053**          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B2DF7             2054**  ;
0B2DF7 CD CD 2A 0B 2055**          		CALL    DLOAD5          		; Load the first coefficient from (IX)
0B2DFB CD 0C 24 0B 2056**  POLY1:			CALL    FMUL
0B2DFF 11 05 00 00 2057**          		LD      DE, 5				; Skip to the next coefficient
0B2E03 DD 19       2058**          		ADD     IX, DE
0B2E05 CD CD 2A 0B 2059**          		CALL    DLOAD5          		; Load the second coefficient from (IX)
0B2E09 DD E3       2060**          		EX      (SP), IX			; Restore the SP just in case we need to return
0B2E0B 04          2061**          		INC     B
0B2E0C 05          2062**          		DEC     B               		; Test B for end byte (80h)
0B2E0D FA FA 22 0B 2063**          		JP      M,FADD				; Yes, so add and return
0B2E11 CD FA 22 0B 2064**          		CALL    FADD				; No, so add
0B2E15 CD DF 2A 0B 2065**          		CALL    DLOAD5_SPL			; Load X from SP
0B2E19 DD E3       2066**          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B2E1B 18 DE       2067**          		JR      POLY1				; And loop
0B2E1D             2068**  ;
0B2E1D             2069**  ; POWR10 - Calculate power of ten.
0B2E1D             2070**  ;     Inputs: A=power of 10 required (A<128)
0B2E1D             2071**  ;             A=binary exponent to be exceeded (A>=128)
0B2E1D             2072**  ;    Outputs: DED'E'B = result
0B2E1D             2073**  ;             A = actual power of ten returned
0B2E1D             2074**  ;   Destroys: A,B,D,E,A',D',E',F,F'
0B2E1D             2075**  ;
0B2E1D 3C          2076**  POWR10:			INC     A
0B2E1E 08          2077**          		EX      AF,AF'
0B2E1F E5          2078**          		PUSH    HL
0B2E20 D9          2079**          		EXX
0B2E21 E5          2080**          		PUSH    HL
0B2E22 D9          2081**          		EXX
0B2E23 CD 39 27 0B 2082**          		CALL    DONE
0B2E27 CD D5 2C 0B 2083**          		CALL    SWAP_FP
0B2E2B AF          2084**          		XOR     A
0B2E2C 08          2085**  POWR11:			EX      AF,AF'
0B2E2D 3D          2086**          		DEC     A
0B2E2E 28 26       2087**          		JR      Z,POWR14        ;EXIT TYPE 1
0B2E30 F2 38 2E 0B 2088**          		JP      P,POWR13
0B2E34 B9          2089**          		CP      C
0B2E35 38 1F       2090**          		JR      C,POWR14        ;EXIT TYPE 2
0B2E37 3C          2091**          		INC     A
0B2E38 08          2092**  POWR13:			EX      AF,AF'
0B2E39 3C          2093**          		INC     A
0B2E3A CB FC       2094**          		SET     7,H
0B2E3C CD 5B 2D 0B 2095**          		CALL    X5
0B2E40 30 06       2096**          		JR      NC,POWR12
0B2E42 08          2097**          		EX      AF,AF'
0B2E43 CD 95 2D 0B 2098**          		CALL    D2C
0B2E47 08          2099**          		EX      AF,AF'
0B2E48 08          2100**  POWR12:			EX      AF,AF'
0B2E49 DC BD 2C 0B 2101**          		CALL    C,ADD1_FP          ;ROUND UP
0B2E4D 0C          2102**          		INC     C
0B2E4E FA 2C 2E 0B 2103**          		JP      M,POWR11
0B2E52 C3 EC 2C 0B 2104**          		JP      OFLOW
0B2E56 CD D5 2C 0B 2105**  POWR14:			CALL    SWAP_FP
0B2E5A CB BA       2106**          		RES     7,D
0B2E5C D9          2107**          		EXX
0B2E5D E1          2108**          		POP     HL
0B2E5E D9          2109**          		EXX
0B2E5F E1          2110**          		POP     HL
0B2E60 08          2111**          		EX      AF,AF'
0B2E61 C9          2112**          		RET
0B2E62             2113**  ;
0B2E62             2114**  ; DIVA, DIVB - DIVISION PRIMITIVE.
0B2E62             2115**  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
0B2E62             2116**  ;               Remainder in H'L'HL
0B2E62             2117**  ;     Inputs: A = loop counter (normally -32)
0B2E62             2118**  ;     Destroys: A,D,E,H,L,D',E',H',L',F
0B2E62             2119**  ;
0B2E62 B7          2120**  DIVA:			OR      A               ;CLEAR CARRY
0B2E63             2121**  DIV0:
0B2E63 52 ED 42    2122**  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B2E66 D9          2123**          		EXX
0B2E67 52 ED 42    2124**          		SBC.S   HL,BC
0B2E6A D9          2125**          		EXX
0B2E6B 30 07       2126**          		JR      NC,DIV1
0B2E6D 52 09       2127**          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B2E6F D9          2128**          		EXX
0B2E70 52 ED 4A    2129**          		ADC.S   HL,BC
0B2E73 D9          2130**          		EXX
0B2E74 3F          2131**  DIV1:			CCF
0B2E75 CB 13       2132**  DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B2E77 CB 12       2133**          		RL      D
0B2E79 D9          2134**          		EXX
0B2E7A CB 13       2135**          		RL      E
0B2E7C CB 12       2136**          		RL      D
0B2E7E D9          2137**          		EXX
0B2E7F 3C          2138**          		INC     A
0B2E80 F0          2139**          		RET     P
0B2E81             2140**  DIVB:
0B2E81 52 ED 6A    2141**  			ADC.S   HL,HL           ;DIVIDEND*2
0B2E84 D9          2142**          		EXX
0B2E85 52 ED 6A    2143**          		ADC.S   HL,HL
0B2E88 D9          2144**          		EXX
0B2E89 30 D8       2145**          		JR      NC,DIV0
0B2E8B B7          2146**          		OR      A
0B2E8C 52 ED 42    2147**          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B2E8F D9          2148**          		EXX
0B2E90 52 ED 42    2149**          		SBC.S   HL,BC
0B2E93 D9          2150**          		EXX
0B2E94 37          2151**          		SCF
0B2E95 C3 75 2E 0B 2152**          		JP      DIVC
0B2E99             2153**  ;
0B2E99             2154**  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
0B2E99             2155**  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
0B2E99             2156**  ;    Inputs: A = loop counter (usually -32)
0B2E99             2157**  ;            H'L'HL = 0
0B2E99             2158**  ;    Destroys: D,E,H,L,D',E',H',L',A,F
0B2E99             2159**  ;
0B2E99 B7          2160**  MULA:			OR      A               ;CLEAR CARRY
0B2E9A D9          2161**  MUL0:			EXX
0B2E9B CB 1A       2162**          		RR      D               ;MULTIPLIER/2
0B2E9D CB 1B       2163**          		RR      E
0B2E9F D9          2164**          		EXX
0B2EA0 CB 1A       2165**          		RR      D
0B2EA2 CB 1B       2166**          		RR      E
0B2EA4 30 07       2167**          		JR      NC,MUL1
0B2EA6 52 09       2168**          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B2EA8 D9          2169**          		EXX
0B2EA9 52 ED 4A    2170**          		ADC.S   HL,BC
0B2EAC D9          2171**          		EXX
0B2EAD 3C          2172**  MUL1:			INC     A
0B2EAE F0          2173**          		RET     P
0B2EAF D9          2174**  MULB:			EXX
0B2EB0 CB 1C       2175**          		RR      H               ;PRODUCT/2
0B2EB2 CB 1D       2176**          		RR      L
0B2EB4 D9          2177**          		EXX
0B2EB5 CB 1C       2178**          		RR      H
0B2EB7 CB 1D       2179**          		RR      L
0B2EB9 C3 9A 2E 0B 2180**          		JP      MUL0
0B2EBD             2181**  ;
0B2EBD             2182**  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
0B2EBD             2183**  ;     Function: B'C'BC = SQR (D'E'DE)
0B2EBD             2184**  ;     Inputs: A = loop counter (normally -31)
0B2EBD             2185**  ;             B'C'BCH'L'HL initialised to 0
0B2EBD             2186**  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
0B2EBD             2187**  ;
0B2EBD             2188**  SQR1:
0B2EBD 52 ED 42    2189**  			SBC.S   HL,BC
0B2EC0 D9          2190**          		EXX
0B2EC1 52 ED 42    2191**          		SBC.S   HL,BC
0B2EC4 D9          2192**          		EXX
0B2EC5 0C          2193**          		INC     C
0B2EC6 30 09       2194**          		JR      NC,SQR2
0B2EC8 0D          2195**          		DEC     C
0B2EC9 52 09       2196**          		ADD.S   HL,BC
0B2ECB D9          2197**          		EXX
0B2ECC 52 ED 4A    2198**          		ADC.S   HL,BC
0B2ECF D9          2199**          		EXX
0B2ED0 0D          2200**          		DEC     C
0B2ED1 3C          2201**  SQR2:			INC     A
0B2ED2 F0          2202**          		RET     P
0B2ED3 CB 21       2203**  SQRA:			SLA     C
0B2ED5 CB 10       2204**          		RL      B
0B2ED7 D9          2205**          		EXX
0B2ED8 CB 11       2206**          		RL      C
0B2EDA CB 10       2207**          		RL      B
0B2EDC D9          2208**          		EXX
0B2EDD 0C          2209**          		INC     C
0B2EDE CB 23       2210**          		SLA     E
0B2EE0 CB 12       2211**          		RL      D
0B2EE2 D9          2212**          		EXX
0B2EE3 CB 13       2213**          		RL      E
0B2EE5 CB 12       2214**          		RL      D
0B2EE7 D9          2215**          		EXX
0B2EE8 52 ED 6A    2216**          		ADC.S   HL,HL
0B2EEB D9          2217**          		EXX
0B2EEC 52 ED 6A    2218**          		ADC.S   HL,HL
0B2EEF D9          2219**          		EXX
0B2EF0 CB 23       2220**          		SLA     E
0B2EF2 CB 12       2221**          		RL      D
0B2EF4 D9          2222**          		EXX
0B2EF5 CB 13       2223**          		RL      E
0B2EF7 CB 12       2224**          		RL      D
0B2EF9 D9          2225**          		EXX
0B2EFA 52 ED 6A    2226**          		ADC.S   HL,HL
0B2EFD D9          2227**          		EXX
0B2EFE 52 ED 6A    2228**          		ADC.S   HL,HL
0B2F01 D9          2229**          		EXX
0B2F02 D2 BD 2E 0B 2230**          		JP      NC,SQR1
0B2F06 B7          2231**  SQR3:			OR      A
0B2F07 52 ED 42    2232**          		SBC.S   HL,BC
0B2F0A D9          2233**          		EXX
0B2F0B 52 ED 42    2234**          		SBC.S   HL,BC
0B2F0E D9          2235**          		EXX
0B2F0F 0C          2236**          		INC     C
0B2F10 C3 D1 2E 0B 2237**          		JP      SQR2
0B2F14             2238**  ;
0B2F14             2239**  SQRB:
0B2F14 52 29       2240**  			ADD.S   HL,HL
0B2F16 D9          2241**          		EXX
0B2F17 52 ED 6A    2242**          		ADC.S   HL,HL
0B2F1A D9          2243**          		EXX
0B2F1B 38 E9       2244**          		JR      C,SQR3
0B2F1D 3C          2245**          		INC     A
0B2F1E 0C          2246**          		INC     C
0B2F1F 52 ED 42    2247**          		SBC.S   HL,BC
0B2F22 D9          2248**          		EXX
0B2F23 52 ED 42    2249**          		SBC.S   HL,BC
0B2F26 D9          2250**          		EXX
0B2F27 D0          2251**          		RET     NC
0B2F28 52 09       2252**          		ADD.S   HL,BC
0B2F2A D9          2253**          		EXX
0B2F2B 52 ED 4A    2254**          		ADC.S   HL,BC
0B2F2E D9          2255**          		EXX
0B2F2F 0D          2256**          		DEC     C
0B2F30 C9          2257**          		RET
0B2F31             2258**  ;
0B2F31 DD 7E 00    2259**  DIGITQ:			LD      A,(IX)
0B2F34 FE 3A       2260**          		CP      '9'+1
0B2F36 3F          2261**          		CCF
0B2F37 D8          2262**          		RET     C
0B2F38 FE 30       2263**          		CP      '0'
0B2F3A C9          2264**          		RET
0B2F3B             2265**  ;
0B2F3B DD 7E 00    2266**  SIGNQ:			LD      A,(IX)
0B2F3E DD 23       2267**          		INC     IX
0B2F40 FE 20       2268**          		CP      ' '
0B2F42 28 F7       2269**          		JR      Z,SIGNQ
0B2F44 FE 2B       2270**          		CP      '+'
0B2F46 C8          2271**          		RET     Z
0B2F47 FE 2D       2272**          		CP      '-'
0B2F49 C8          2273**          		RET     Z
0B2F4A DD 2B       2274**          		DEC     IX
0B2F4C C9          2275**          		RET
0B2F4D             0008*       include "basic/gpio.asm"
0B2F4D             0001**  ;
0B2F4D             0002**  ; Title:	BBC Basic for AGON - GPIO functions
0B2F4D             0003**  ; Author:	Dean Belfield
0B2F4D             0004**  ; Created:	12/05/2023
0B2F4D             0005**  ; Last Updated:	12/05/2023
0B2F4D             0006**  ;
0B2F4D             0007**  ; Modinfo:
0B2F4D             0008**  
0B2F4D             0009**  			; INCLUDE	"macros.inc"
0B2F4D             0010**  			; INCLUDE	"equs.inc"
0B2F4D             0011**  
0B2F4D             0012**  			; .ASSUME	ADL = 1
0B2F4D             0013**  
0B2F4D             0014**  			; SEGMENT CODE
0B2F4D             0015**  
0B2F4D             0016**  			; XDEF	GPIOB_SETMODE
0B2F4D             0017**  
0B2F4D             0018**  			; XREF	SWITCH_A
0B2F4D             0019**  
0B2F4D             0020**  ;  A: Mode
0B2F4D             0021**  ;  B: Pins
0B2F4D             0022**  ;
0B2F4D CD F2 3E 0B 0023**  GPIOB_SETMODE:		CALL	SWITCH_A
0B2F51 65 2F       0024**  			DW	GPIOB_M0	; Output
0B2F53 8A 2F       0025**  			DW	GPIOB_M1	; Input
0B2F55 AA 2F       0026**  			DW	GPIOB_M2	; Open Drain IO
0B2F57 CA 2F       0027**  			DW	GPIOB_M3	; Open Source IO
0B2F59 E5 2F       0028**  			DW	GPIOB_M4	; Interrupt, Dual Edge
0B2F5B 11 30       0029**  			DW	GPIOB_M5	; Alt Function
0B2F5D 2C 30       0030**  			DW	GPIOB_M6	; Interrupt, Active Low
0B2F5F 53 30       0031**  			DW	GPIOB_M7	; Interrupt, Active High
0B2F61 75 30       0032**  			DW	GPIOB_M8	; Interrupt, Falling Edge
0B2F63 97 30       0033**  			DW	GPIOB_M9	; Interrupt, Rising Edge
0B2F65             0034**  
0B2F65             0035**  ; Output
0B2F65             0036**  ;
0B2F65             0037**  GPIOB_M0:		RES_GPIO PB_DDR,  B
0B2F65 C5          0001**M 		PUSH	BC
0B2F66 78          0002**M 		LD	A, val
0B2F67 2F          0003**M 		CPL
0B2F68 4F          0004**M 		LD	C, A
0B2F69 ED 38 9B    0005**M 		IN0	A, (reg)
0B2F6C A1          0006**M 		AND	C
0B2F6D ED 39 9B    0007**M 		OUT0	(reg), A
0B2F70 C1          0008**M 		POP	BC
0B2F71             0038**  			RES_GPIO PB_ALT1, B
0B2F71 C5          0001**M 		PUSH	BC
0B2F72 78          0002**M 		LD	A, val
0B2F73 2F          0003**M 		CPL
0B2F74 4F          0004**M 		LD	C, A
0B2F75 ED 38 9C    0005**M 		IN0	A, (reg)
0B2F78 A1          0006**M 		AND	C
0B2F79 ED 39 9C    0007**M 		OUT0	(reg), A
0B2F7C C1          0008**M 		POP	BC
0B2F7D             0039**  			RES_GPIO PB_ALT2, B
0B2F7D C5          0001**M 		PUSH	BC
0B2F7E 78          0002**M 		LD	A, val
0B2F7F 2F          0003**M 		CPL
0B2F80 4F          0004**M 		LD	C, A
0B2F81 ED 38 9D    0005**M 		IN0	A, (reg)
0B2F84 A1          0006**M 		AND	C
0B2F85 ED 39 9D    0007**M 		OUT0	(reg), A
0B2F88 C1          0008**M 		POP	BC
0B2F89 C9          0040**  			RET
0B2F8A             0041**  
0B2F8A             0042**  ; Input
0B2F8A             0043**  ;
0B2F8A             0044**  GPIOB_M1:		SET_GPIO PB_DDR,  B
0B2F8A ED 38 9B    0001**M 		IN0	A, (reg)
0B2F8D B0          0002**M 		OR	val
0B2F8E ED 39 9B    0003**M 		OUT0	(reg), A
0B2F91             0045**  			RES_GPIO PB_ALT1, B
0B2F91 C5          0001**M 		PUSH	BC
0B2F92 78          0002**M 		LD	A, val
0B2F93 2F          0003**M 		CPL
0B2F94 4F          0004**M 		LD	C, A
0B2F95 ED 38 9C    0005**M 		IN0	A, (reg)
0B2F98 A1          0006**M 		AND	C
0B2F99 ED 39 9C    0007**M 		OUT0	(reg), A
0B2F9C C1          0008**M 		POP	BC
0B2F9D             0046**  			RES_GPIO PB_ALT2, B
0B2F9D C5          0001**M 		PUSH	BC
0B2F9E 78          0002**M 		LD	A, val
0B2F9F 2F          0003**M 		CPL
0B2FA0 4F          0004**M 		LD	C, A
0B2FA1 ED 38 9D    0005**M 		IN0	A, (reg)
0B2FA4 A1          0006**M 		AND	C
0B2FA5 ED 39 9D    0007**M 		OUT0	(reg), A
0B2FA8 C1          0008**M 		POP	BC
0B2FA9 C9          0047**  			RET
0B2FAA             0048**  
0B2FAA             0049**  ; Open Drain IO
0B2FAA             0050**  ;
0B2FAA             0051**  GPIOB_M2:		RES_GPIO PB_DDR,  B
0B2FAA C5          0001**M 		PUSH	BC
0B2FAB 78          0002**M 		LD	A, val
0B2FAC 2F          0003**M 		CPL
0B2FAD 4F          0004**M 		LD	C, A
0B2FAE ED 38 9B    0005**M 		IN0	A, (reg)
0B2FB1 A1          0006**M 		AND	C
0B2FB2 ED 39 9B    0007**M 		OUT0	(reg), A
0B2FB5 C1          0008**M 		POP	BC
0B2FB6             0052**  			SET_GPIO PB_ALT1, B
0B2FB6 ED 38 9C    0001**M 		IN0	A, (reg)
0B2FB9 B0          0002**M 		OR	val
0B2FBA ED 39 9C    0003**M 		OUT0	(reg), A
0B2FBD             0053**  			RES_GPIO PB_ALT2, B
0B2FBD C5          0001**M 		PUSH	BC
0B2FBE 78          0002**M 		LD	A, val
0B2FBF 2F          0003**M 		CPL
0B2FC0 4F          0004**M 		LD	C, A
0B2FC1 ED 38 9D    0005**M 		IN0	A, (reg)
0B2FC4 A1          0006**M 		AND	C
0B2FC5 ED 39 9D    0007**M 		OUT0	(reg), A
0B2FC8 C1          0008**M 		POP	BC
0B2FC9 C9          0054**  			RET
0B2FCA             0055**  
0B2FCA             0056**  ; Open Source IO
0B2FCA             0057**  ;
0B2FCA             0058**  GPIOB_M3:		SET_GPIO PB_DDR,  B
0B2FCA ED 38 9B    0001**M 		IN0	A, (reg)
0B2FCD B0          0002**M 		OR	val
0B2FCE ED 39 9B    0003**M 		OUT0	(reg), A
0B2FD1             0059**  			SET_GPIO PB_ALT1, B
0B2FD1 ED 38 9C    0001**M 		IN0	A, (reg)
0B2FD4 B0          0002**M 		OR	val
0B2FD5 ED 39 9C    0003**M 		OUT0	(reg), A
0B2FD8             0060**  			RES_GPIO PB_ALT2, B
0B2FD8 C5          0001**M 		PUSH	BC
0B2FD9 78          0002**M 		LD	A, val
0B2FDA 2F          0003**M 		CPL
0B2FDB 4F          0004**M 		LD	C, A
0B2FDC ED 38 9D    0005**M 		IN0	A, (reg)
0B2FDF A1          0006**M 		AND	C
0B2FE0 ED 39 9D    0007**M 		OUT0	(reg), A
0B2FE3 C1          0008**M 		POP	BC
0B2FE4 C9          0061**  			RET
0B2FE5             0062**  
0B2FE5             0063**  ; Interrupt, Dual Edge
0B2FE5             0064**  ;
0B2FE5             0065**  GPIOB_M4:		SET_GPIO PB_DR,   B
0B2FE5 ED 38 9A    0001**M 		IN0	A, (reg)
0B2FE8 B0          0002**M 		OR	val
0B2FE9 ED 39 9A    0003**M 		OUT0	(reg), A
0B2FEC             0066**  			RES_GPIO PB_DDR,  B
0B2FEC C5          0001**M 		PUSH	BC
0B2FED 78          0002**M 		LD	A, val
0B2FEE 2F          0003**M 		CPL
0B2FEF 4F          0004**M 		LD	C, A
0B2FF0 ED 38 9B    0005**M 		IN0	A, (reg)
0B2FF3 A1          0006**M 		AND	C
0B2FF4 ED 39 9B    0007**M 		OUT0	(reg), A
0B2FF7 C1          0008**M 		POP	BC
0B2FF8             0067**  			RES_GPIO PB_ALT1, B
0B2FF8 C5          0001**M 		PUSH	BC
0B2FF9 78          0002**M 		LD	A, val
0B2FFA 2F          0003**M 		CPL
0B2FFB 4F          0004**M 		LD	C, A
0B2FFC ED 38 9C    0005**M 		IN0	A, (reg)
0B2FFF A1          0006**M 		AND	C
0B3000 ED 39 9C    0007**M 		OUT0	(reg), A
0B3003 C1          0008**M 		POP	BC
0B3004             0068**  			RES_GPIO PB_ALT2, B
0B3004 C5          0001**M 		PUSH	BC
0B3005 78          0002**M 		LD	A, val
0B3006 2F          0003**M 		CPL
0B3007 4F          0004**M 		LD	C, A
0B3008 ED 38 9D    0005**M 		IN0	A, (reg)
0B300B A1          0006**M 		AND	C
0B300C ED 39 9D    0007**M 		OUT0	(reg), A
0B300F C1          0008**M 		POP	BC
0B3010 C9          0069**  			RET
0B3011             0070**  
0B3011             0071**  ; Alt Function
0B3011             0072**  ;
0B3011             0073**  GPIOB_M5:		SET_GPIO PB_DDR,  B
0B3011 ED 38 9B    0001**M 		IN0	A, (reg)
0B3014 B0          0002**M 		OR	val
0B3015 ED 39 9B    0003**M 		OUT0	(reg), A
0B3018             0074**  			RES_GPIO PB_ALT1, B
0B3018 C5          0001**M 		PUSH	BC
0B3019 78          0002**M 		LD	A, val
0B301A 2F          0003**M 		CPL
0B301B 4F          0004**M 		LD	C, A
0B301C ED 38 9C    0005**M 		IN0	A, (reg)
0B301F A1          0006**M 		AND	C
0B3020 ED 39 9C    0007**M 		OUT0	(reg), A
0B3023 C1          0008**M 		POP	BC
0B3024             0075**  			SET_GPIO PB_ALT2, B
0B3024 ED 38 9D    0001**M 		IN0	A, (reg)
0B3027 B0          0002**M 		OR	val
0B3028 ED 39 9D    0003**M 		OUT0	(reg), A
0B302B C9          0076**  			RET
0B302C             0077**  
0B302C             0078**  ; Interrupt, Active Low
0B302C             0079**  ;
0B302C             0080**  GPIOB_M6:		RES_GPIO PB_DR,   B
0B302C C5          0001**M 		PUSH	BC
0B302D 78          0002**M 		LD	A, val
0B302E 2F          0003**M 		CPL
0B302F 4F          0004**M 		LD	C, A
0B3030 ED 38 9A    0005**M 		IN0	A, (reg)
0B3033 A1          0006**M 		AND	C
0B3034 ED 39 9A    0007**M 		OUT0	(reg), A
0B3037 C1          0008**M 		POP	BC
0B3038             0081**  			RES_GPIO PB_DDR,  B
0B3038 C5          0001**M 		PUSH	BC
0B3039 78          0002**M 		LD	A, val
0B303A 2F          0003**M 		CPL
0B303B 4F          0004**M 		LD	C, A
0B303C ED 38 9B    0005**M 		IN0	A, (reg)
0B303F A1          0006**M 		AND	C
0B3040 ED 39 9B    0007**M 		OUT0	(reg), A
0B3043 C1          0008**M 		POP	BC
0B3044             0082**  			SET_GPIO PB_ALT1, B
0B3044 ED 38 9C    0001**M 		IN0	A, (reg)
0B3047 B0          0002**M 		OR	val
0B3048 ED 39 9C    0003**M 		OUT0	(reg), A
0B304B             0083**  			SET_GPIO PB_ALT2, B
0B304B ED 38 9D    0001**M 		IN0	A, (reg)
0B304E B0          0002**M 		OR	val
0B304F ED 39 9D    0003**M 		OUT0	(reg), A
0B3052 C9          0084**  			RET
0B3053             0085**  
0B3053             0086**  
0B3053             0087**  ; Interrupt, Active High
0B3053             0088**  ;
0B3053             0089**  GPIOB_M7:		SET_GPIO PB_DR,   B
0B3053 ED 38 9A    0001**M 		IN0	A, (reg)
0B3056 B0          0002**M 		OR	val
0B3057 ED 39 9A    0003**M 		OUT0	(reg), A
0B305A             0090**  			RES_GPIO PB_DDR,  B
0B305A C5          0001**M 		PUSH	BC
0B305B 78          0002**M 		LD	A, val
0B305C 2F          0003**M 		CPL
0B305D 4F          0004**M 		LD	C, A
0B305E ED 38 9B    0005**M 		IN0	A, (reg)
0B3061 A1          0006**M 		AND	C
0B3062 ED 39 9B    0007**M 		OUT0	(reg), A
0B3065 C1          0008**M 		POP	BC
0B3066             0091**  			SET_GPIO PB_ALT1, B
0B3066 ED 38 9C    0001**M 		IN0	A, (reg)
0B3069 B0          0002**M 		OR	val
0B306A ED 39 9C    0003**M 		OUT0	(reg), A
0B306D             0092**  			SET_GPIO PB_ALT2, B
0B306D ED 38 9D    0001**M 		IN0	A, (reg)
0B3070 B0          0002**M 		OR	val
0B3071 ED 39 9D    0003**M 		OUT0	(reg), A
0B3074 C9          0093**  			RET
0B3075             0094**  
0B3075             0095**  
0B3075             0096**  ; Interrupt, Falling Edge
0B3075             0097**  ;
0B3075             0098**  GPIOB_M8:		RES_GPIO PB_DR,   B
0B3075 C5          0001**M 		PUSH	BC
0B3076 78          0002**M 		LD	A, val
0B3077 2F          0003**M 		CPL
0B3078 4F          0004**M 		LD	C, A
0B3079 ED 38 9A    0005**M 		IN0	A, (reg)
0B307C A1          0006**M 		AND	C
0B307D ED 39 9A    0007**M 		OUT0	(reg), A
0B3080 C1          0008**M 		POP	BC
0B3081             0099**  			SET_GPIO PB_DDR,  B
0B3081 ED 38 9B    0001**M 		IN0	A, (reg)
0B3084 B0          0002**M 		OR	val
0B3085 ED 39 9B    0003**M 		OUT0	(reg), A
0B3088             0100**  			SET_GPIO PB_ALT1, B
0B3088 ED 38 9C    0001**M 		IN0	A, (reg)
0B308B B0          0002**M 		OR	val
0B308C ED 39 9C    0003**M 		OUT0	(reg), A
0B308F             0101**  			SET_GPIO PB_ALT2, B
0B308F ED 38 9D    0001**M 		IN0	A, (reg)
0B3092 B0          0002**M 		OR	val
0B3093 ED 39 9D    0003**M 		OUT0	(reg), A
0B3096 C9          0102**  			RET
0B3097             0103**  
0B3097             0104**  ; Interrupt, Rising Edge
0B3097             0105**  ;
0B3097             0106**  GPIOB_M9:		SET_GPIO PB_DR,   B
0B3097 ED 38 9A    0001**M 		IN0	A, (reg)
0B309A B0          0002**M 		OR	val
0B309B ED 39 9A    0003**M 		OUT0	(reg), A
0B309E             0107**  			SET_GPIO PB_DDR,  B
0B309E ED 38 9B    0001**M 		IN0	A, (reg)
0B30A1 B0          0002**M 		OR	val
0B30A2 ED 39 9B    0003**M 		OUT0	(reg), A
0B30A5             0108**  			SET_GPIO PB_ALT1, B
0B30A5 ED 38 9C    0001**M 		IN0	A, (reg)
0B30A8 B0          0002**M 		OR	val
0B30A9 ED 39 9C    0003**M 		OUT0	(reg), A
0B30AC             0109**  			SET_GPIO PB_ALT2, B
0B30AC ED 38 9D    0001**M 		IN0	A, (reg)
0B30AF B0          0002**M 		OR	val
0B30B0 ED 39 9D    0003**M 		OUT0	(reg), A
0B30B3 C9          0110**  			RET
0B30B4             0009*       include "basic/main.asm"
0B30B4             0001**  ;
0B30B4             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B30B4             0003**  ;		Command, Error and Lexical Analysis Module - "MAIN"
0B30B4             0004**  ; Author:	(C) Copyright  R.T.Russell  1984
0B30B4             0005**  ; Modified By:	Dean Belfield
0B30B4             0006**  ; Created:	12/05/2023
0B30B4             0007**  ; Last Updated:	26/11/2023
0B30B4             0008**  ;
0B30B4             0009**  ; Modinfo:
0B30B4             0010**  ; 07/05/1984:	Version 2.3
0B30B4             0011**  ; 01/03/1987:	Version 3.0
0B30B4             0012**  ; 03/05/2022:	Modified by Dean Belfield
0B30B4             0013**  ; 06/06/2023:	Modified to run in ADL mode
0B30B4             0014**  ; 26/06/2023:	Fixed binary and unary indirection
0B30B4             0015**  ; 17/08/2023:	Added binary constants
0B30B4             0016**  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
0B30B4             0017**  ; 26/11/2023:	Fixed bug in AUTOLOAD
0B30B4             0018**  
0B30B4             0019**  			; .ASSUME	ADL = 1
0B30B4             0020**  
0B30B4             0021**  			; INCLUDE	"equs.inc"
0B30B4             0022**  
0B30B4             0023**  			; SEGMENT CODE
0B30B4             0024**  
0B30B4             0025**  			; XDEF	_basic_main
0B30B4             0026**  
0B30B4             0027**  			; XDEF	COLD
0B30B4             0028**  			; XDEF	WARM
0B30B4             0029**  			; XDEF	CLOOP
0B30B4             0030**  			; XDEF	DELETE
0B30B4             0031**  			; XDEF	LIST_
0B30B4             0032**  			; XDEF	RENUM
0B30B4             0033**  			; XDEF	AUTO
0B30B4             0034**  			; XDEF	NEW
0B30B4             0035**  			; XDEF	OLD
0B30B4             0036**  			; XDEF	LOAD
0B30B4             0037**  			; XDEF	SAVE
0B30B4             0038**  			; XDEF	ERROR_
0B30B4             0039**  			; XDEF	EXTERR
0B30B4             0040**  			; XDEF	LOAD0
0B30B4             0041**  			; XDEF	CLEAR
0B30B4             0042**  			; XDEF	CRLF
0B30B4             0043**  			; XDEF	OUTCHR
0B30B4             0044**  			; XDEF	OUT_
0B30B4             0045**  			; XDEF	FINDL
0B30B4             0046**  			; XDEF	SETLIN
0B30B4             0047**  			; XDEF	PBCDL
0B30B4             0048**  			; XDEF	SAYLN
0B30B4             0049**  			; XDEF	PUTVAR
0B30B4             0050**  			; XDEF	GETVAR
0B30B4             0051**  			; XDEF	GETDEF
0B30B4             0052**  			; XDEF	CREATE
0B30B4             0053**  			; XDEF	RANGE
0B30B4             0054**  			; XDEF	LEXAN2
0B30B4             0055**  			; XDEF	REPORT
0B30B4             0056**  			; XDEF	TELL
0B30B4             0057**  			; XDEF	SPACE_
0B30B4             0058**  			; XDEF	KEYWDS
0B30B4             0059**  			; XDEF	KEYWDL
0B30B4             0060**  			; XDEF	ONEDIT
0B30B4             0061**  			; XDEF	ONEDIT1
0B30B4             0062**  			; XDEF	LISTIT
0B30B4             0063**  			; XDEF	CLEAN
0B30B4             0064**  
0B30B4             0065**  			; XREF	LISTON
0B30B4             0066**  			; XREF	ERRTXT
0B30B4             0067**  			; XREF	OSINIT
0B30B4             0068**  			; XREF	HIMEM
0B30B4             0069**  			; XREF	PAGE_
0B30B4             0070**  			; XREF	CHAIN0
0B30B4             0071**  			; XREF	PROMPT
0B30B4             0072**  			; XREF	ERRTRP
0B30B4             0073**  			; XREF	ERRLIN
0B30B4             0074**  			; XREF	AUTONO
0B30B4             0075**  			; XREF	LINENO
0B30B4             0076**  			; XREF	INCREM
0B30B4             0077**  			; XREF	OSLINE
0B30B4             0078**  			; XREF	COUNT
0B30B4             0079**  			; XREF	NXT
0B30B4             0080**  			; XREF	BUFFER
0B30B4             0081**  			; XREF	XEQ
0B30B4             0082**  			; XREF	TOP
0B30B4             0083**  			; XREF	EXPRI
0B30B4             0084**  			; XREF	SEARCH
0B30B4             0085**  			; XREF	LTRAP
0B30B4             0086**  			; XREF	LOMEM
0B30B4             0087**  			; XREF	DECODE
0B30B4             0088**  			; XREF	EXPRS
0B30B4             0089**  			; XREF	OSSAVE
0B30B4             0090**  			; XREF	ERR
0B30B4             0091**  			; XREF	ERL
0B30B4             0092**  			; XREF	TRACEN
0B30B4             0093**  			; XREF	RESET
0B30B4             0094**  			; XREF	OSSHUT
0B30B4             0095**  			; XREF	OSLOAD
0B30B4             0096**  			; XREF	FREE
0B30B4             0097**  			; XREF	DYNVAR
0B30B4             0098**  			; XREF	FILL
0B30B4             0099**  			; XREF	OSWRCH
0B30B4             0100**  			; XREF	WIDTH
0B30B4             0101**  			; XREF	COMMA
0B30B4             0102**  			; XREF	MUL16
0B30B4             0103**  			; XREF	BRAKET
0B30B4             0104**  			; XREF	X4OR5
0B30B4             0105**  			; XREF	LOADN
0B30B4             0106**  			; XREF	SFIX
0B30B4             0107**  			; XREF	ITEMI
0B30B4             0108**  			; XREF	FNPTR
0B30B4             0109**  			; XREF	PROPTR
0B30B4             0110**  			; XREF	CHECK
0B30B4             0111**  			; XREF	TERMQ
0B30B4             0112**  			; XREF	OSWRCHCH
0B30B4             0113**  			; XREF	NEWIT
0B30B4             0114**  			; XREF	BAD
0B30B4             0115**  			; XREF	RAM_START
0B30B4             0116**  			; XREF	RAM_END
0B30B4             0117**  			; XREF	R0
0B30B4             0118**  			; XREF	STAR_VERSION
0B30B4             0119**  
0B30B4             0120**  			; XREF	_basic_end			; In init.asm
0B30B4             0121**  ;
0B30B4             0122**  ; A handful of common token IDs
0B30B4             0123**  ;
0B30B4             0124**  TERROR_MN:			EQU     85H
0B30B4             0125**  LINE_MN_:			EQU     86H
0B30B4             0126**  ELSE_MN_:			EQU     8BH
0B30B4             0127**  THEN_MN_:			EQU     8CH
0B30B4             0128**  LINO_MN:			EQU     8DH
0B30B4             0129**  FN:			EQU     A4H
0B30B4             0130**  TO_MN:			EQU     B8H
0B30B4             0131**  REN:			EQU     CCH
0B30B4             0132**  DATA_MN_:			EQU     DCH
0B30B4             0133**  DIM:			EQU     DEH
0B30B4             0134**  FOR:			EQU     E3H
0B30B4             0135**  GOSUB:			EQU     E4H
0B30B4             0136**  GOTO:			EQU     E5H
0B30B4             0137**  TIF:			EQU     E7H
0B30B4             0138**  LOCAL_:			EQU     EAH
0B30B4             0139**  NEXT:			EQU     EDH
0B30B4             0140**  ON_:			EQU     EEH
0B30B4             0141**  PROC:			EQU     F2H
0B30B4             0142**  REM:			EQU     F4H
0B30B4             0143**  REPEAT:			EQU     F5H
0B30B4             0144**  RESTOR:			EQU     F7H
0B30B4             0145**  TRACE:			EQU     FCH
0B30B4             0146**  UNTIL:			EQU     FDH
0B30B4             0147**  ;
0B30B4             0148**  ; This defines the block of tokens that are pseudo-variables.
0B30B4             0149**  ; There are two versions of each token, a GET and a SET
0B30B4             0150**  
0B30B4             0151**  ; Name  : GET : SET
0B30B4             0152**  ; ------:-----:----
0B30B4             0153**  ; PTR   : 8Fh : CFh
0B30B4             0154**  ; PAGE  : 90h : D0h
0B30B4             0155**  ; TIME  : 91h : D1h
0B30B4             0156**  ; LOMEM : 92h : D2h
0B30B4             0157**  ; HIMEM : 93h : D3h
0B30B4             0158**  ;
0B30B4             0159**  ; Examples:
0B30B4             0160**  ;   LET A% = PAGE : REM This is the GET version
0B30B4             0161**  ;   PAGE = 40000  : REM This is the SET version
0B30B4             0162**  ;
0B30B4             0163**  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
0B30B4             0164**  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
0B30B4             0165**  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
0B30B4             0166**  
0B30B4             0167**  ; The main routine
0B30B4             0168**  ; IXU: argv - pointer to array of parameters
0B30B4             0169**  ;   C: argc - number of parameters
0B30B4             0170**  ; Returns:
0B30B4             0171**  ;  HL: Error code, or 0 if OK
0B30B4             0172**  ;
0B30B4 21 00 4B 0B 0173**  _basic_main:			LD	HL, ACCS		; Clear the ACCS
0B30B8 36 00       0174**  			LD	(HL), 0
0B30BA 79          0175**  			LD	A, C
0B30BB FE 02       0176**  			CP	2
0B30BD 28 2D       0177**  			JR	Z, AUTOLOAD		; 2 parameters = autoload
0B30BF 38 3F       0178**  			JR	C, COLD			; 1 parameter = normal start
0B30C1 CD 36 41 0B 0179**  			CALL	STAR_VERSION
0B30C5 CD 8E 3E 0B 0180**  			CALL	TELL
0B30C9 55 73 61 67 0181**  			DB	"Usage:\n\r"
       65 3A 0A 0D 
0B30D1 52 55 4E 20 0182**  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
0B30E4 21 00 00 00 0183**  			LD	HL, 0			; The error code
0B30E8 C3 79 4F 0B 0184**  			JP	_basic_end
0B30EC             0185**  ;
0B30EC DD 27 03    0186**  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
0B30EF 11 00 4B 0B 0187**  			LD	DE, ACCS		;  DE: Destination address
0B30F3 7E          0188**  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
0B30F4 12          0189**  			LD	(DE), A			;
0B30F5 23          0190**  			INC	HL			; Increase the source pointer
0B30F6 1C          0191**  			INC	E			; We only need to increase E as ACCS is on a page boundary
0B30F7 28 03       0192**  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
0B30F9 B7          0193**  			OR	A
0B30FA 20 F7       0194**  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
0B30FC 1D          0195**  AUTOLOAD_2:		DEC	E
0B30FD 3E 0D       0196**  			LD	A, CR
0B30FF 12          0197**  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
0B3100             0198**  ;
0B3100 E1          0199**  COLD:			POP	HL			; Pop the return address to init off SPS
0B3101 E5          0200**  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
0B3102 21 00 4D 0B 0201**  			LD	HL, STAVAR		; Cold start
0B3106 F9          0202**  			LD	SP, HL
0B3107 36 0A       0203**  			LD	(HL), 10
0B3109 23          0204**  			INC	HL
0B310A 36 09       0205**  			LD	(HL),9
0B310C CD 7F 40 0B 0206**  			CALL    OSINIT			; Call the machine specific OS initialisation routines
0B3110 ED 53 20 4E 0207**  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       0B          
0B3115 22 14 4E 0B 0208**  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
0B3119 3E B7       0209**  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
0B311B 32 40 4E 0B 0210**  			LD      (LISTON),A
0B311F 21 5A 31 0B 0211**  			LD      HL,NOTICE
0B3123 22 2F 4E 0B 0212**  			LD      (ERRTXT),HL
0B3127 CD 6A 39 0B 0213**  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
0B312B 3A 00 4B 0B 0214**  			LD	A,(ACCS)		; Check if there is a filename in ACCS
0B312F B7          0215**  			OR	A
0B3130 C2 51 0C 0B 0216**  			JP	NZ,CHAIN0		; Yes, so load and run
0B3134 CD 36 41 0B 0217**  			CALL	STAR_VERSION		;
0B3138 CD 8E 3E 0B 0218**  			CALL    TELL			; Output the welcome message
0B313C 42 42 43 20 0219**  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
0B315A 28 43 29 20 0220**  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0B317A 0A 0D 00    0221**  			DB	"\n\r", 0
0B317D             0222**  ;
0B317D F6          0223**  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0B317E             0224**  ;
0B317E             0225**  ; This is the main entry point for BASIC
0B317E             0226**  ;
0B317E 37          0227**  CLOOP:			SCF				; See above - not sure why this is here!
0B317F ED 7B 20 4E 0228**  			LD      SP,(HIMEM)
       0B          
0B3184 CD F8 3F 0B 0229**  			CALL    PROMPT          	; Prompt user
0B3188 21 40 4E 0B 0230**  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0B318C 7E          0231**  			LD      A,(HL)			; Fetch the value
0B318D E6 0F       0232**  			AND     0FH             	; Bottom nibble: LISTO
0B318F F6 B0       0233**  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0B3191 77          0234**  			LD      (HL),A			; Store back in
0B3192 ED 62       0235**  			SBC     HL,HL           	; HL: 0
0B3194 22 2C 4E 0B 0236**  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0B3198 22 35 4E 0B 0237**  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0B319C             0238**  ;
0B319C 2A 29 4E 0B 0239**  			LD      HL,(AUTONO)		; Get the auto line number
0B31A0 22 23 4E 0B 0240**  			LD      (LINENO),HL		; Store in line number
0B31A4 7C          0241**  			LD      A,H			; If the auto line number is zero then
0B31A5 B5          0242**  			OR      L
0B31A6 28 1E       0243**  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0B31A8             0244**  ;
0B31A8             0245**  ; This section handles auto line numbering
0B31A8             0246**  ;
0B31A8 E5          0247**  			PUSH    HL			; Stack the line number
0B31A9 CD F9 3A 0B 0248**  			CALL    PBCD           	 	; Output the line number
0B31AD E1          0249**  			POP     HL			; Pop the line number back off the stack
0B31AE             0250**  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0B31AE             0251**  ;			LD      B,0			; So clear B
0B31AE 01 00 00 00 0252**  			LD	BC, 0			; Load BC with Increment
0B31B2 3A 41 4E 0B 0253**  			LD	A,(INCREM)
0B31B6 4F          0254**  			LD	C, A
0B31B7 09          0255**  			ADD     HL,BC			; Add the increment to the line number
0B31B8 DA 23 3D 0B 0256**  			JP      C,TOOBIG		; And error if we wrap
0B31BC 22 29 4E 0B 0257**  			LD      (AUTONO),HL		; Store the new auto line number
0B31C0 3E 20       0258**  			LD      A,' '			; Print a space
0B31C2 CD 4D 3A 0B 0259**  			CALL    OUTCHR
0B31C6             0260**  ;
0B31C6             0261**  ; This section invokes the line editor
0B31C6             0262**  ;
0B31C6 21 00 4B 0B 0263**  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0B31CA CD 5D 3F 0B 0264**  			CALL    OSLINE          	; Call the line editor in MOS
0B31CE CD DA 31 0B 0265**  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0B31D2 DC 3D 39 0B 0266**  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0B31D6 C3 7E 31 0B 0267**  			JP      CLOOP			; Jump back to immediate mode
0B31DA             0268**  ;
0B31DA             0269**  ; This bit enters the line into memory
0B31DA             0270**  ; Also called from OSLOAD_TXT
0B31DA             0271**  ; Returns:
0B31DA             0272**  ; F: C if a new line has been entered (CLEAN will need to be called)
0B31DA             0273**  ;
0B31DA AF          0274**  ONEDIT1:		XOR     A			; Entry point after *EDIT
0B31DB 32 3D 4E 0B 0275**  			LD      (COUNT),A
0B31DF FD 21 00 4B 0276**  			LD      IY,ACCS
       0B          
0B31E4 CD F7 3C 0B 0277**  			CALL    LINNUM			; HL: The line number from the input buffer
0B31E8 CD 6E 0B 0B 0278**  			CALL    NXT			; Skip spaces
0B31EC 7C          0279**  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0B31ED B5          0280**  			OR      L
0B31EE 28 04       0281**  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0B31F0 22 23 4E 0B 0282**  			LD      (LINENO),HL		; Otherwise store it
0B31F4             0283**  ;
0B31F4             0284**  ; This bit does the lexical analysis and tokenisation
0B31F4             0285**  ;
0B31F4 0E 01       0286**  LNZERO:			LD	C,1			; Left mode
0B31F6 11 00 4C 0B 0287**  			LD      DE,BUFFER		; Buffer for tokenised BASIC
0B31FA CD 9D 3D 0B 0288**  			CALL    LEXAN2          	; Lexical analysis on the user input
0B31FE 12          0289**  			LD      (DE),A          	; Terminator
0B31FF AF          0290**  			XOR     A
0B3200             0291**  ;			LD      B,A
0B3200             0292**  ;			LD      C,E             	; BC: Line length
0B3200 01 00 00 00 0293**  			LD	BC,0
0B3204 4B          0294**  			LD	C,E			; BC: Line length
0B3205 13          0295**  			INC     DE
0B3206 12          0296**  			LD      (DE),A          	; Zero next
0B3207 2A 23 4E 0B 0297**  			LD      HL,(LINENO)		; Get the line number
0B320B 7C          0298**  			LD      A,H			; Is it zero, i.e. a command with no line number?
0B320C B5          0299**  			OR      L
0B320D FD 21 00 4C 0300**  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       0B          
0B3212 CA 94 0C 0B 0301**  			JP      Z,XEQ           	; Execute it
0B3216             0302**  ;
0B3216             0303**  ; This section stores the BASIC line in memory
0B3216             0304**  ;
0B3216 C5          0305**  			PUSH    BC
0B3217 E5          0306**  			PUSH    HL
0B3218 CD 49 39 0B 0307**  			CALL    SETTOP          	; Set TOP sysvar
0B321C E1          0308**  			POP     HL
0B321D CD 8D 3A 0B 0309**  			CALL    FINDL			; Find the address of the line
0B3221 CC 00 39 0B 0310**  			CALL    Z,DEL			; Delete the existing line if found
0B3225 C1          0311**  			POP     BC
0B3226 79          0312**  			LD      A,C			; Check for the line length being zero, i.e.
0B3227 B7          0313**  			OR      A			; the user has just entered a line number in the command line
0B3228 C8          0314**  			RET	Z 	         	; If so, then don't do anything else
0B3229 C6 04       0315**  			ADD     A,4
0B322B 4F          0316**  			LD      C,A             	; Length inclusive
0B322C D5          0317**  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
0B322D C5          0318**  			PUSH    BC              	; BC: Line length
0B322E EB          0319**  			EX      DE,HL			; DE: Address of the line in memory
0B322F 2A 17 4E 0B 0320**  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
0B3233 E5          0321**  			PUSH    HL			; Stack TOP (current TOP value)
0B3234 09          0322**  			ADD     HL,BC			; Add the line length to HL, the new TOP value
0B3235 E5          0323**  			PUSH    HL			; Stack HL (new TOP value)
0B3236 24          0324**  			INC     H			; Add 256 to HL
0B3237 AF          0325**  			XOR     A
0B3238 ED 72       0326**  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
0B323A E1          0327**  			POP     HL			; Pop HL (new TOP value)
0B323B D2 5E 38 0B 0328**  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0B323F 22 17 4E 0B 0329**  			LD      (TOP),HL		; Store new value of TOP
0B3243 E3          0330**  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0B3244 E5          0331**  			PUSH    HL			; PUSH current TOP value
0B3245 23          0332**  			INC     HL
0B3246 B7          0333**  			OR      A
0B3247 ED 52       0334**  			SBC     HL,DE			; DE: Address of the line in memory
0B3249 44          0335**  			LD      B,H             	; BC: Amount to move
0B324A 4D          0336**  			LD      C,L
0B324B E1          0337**  			POP     HL			; HL: Destination (current TOP value)
0B324C D1          0338**  			POP     DE			; DE: Source (new TOP value)
0B324D 28 02       0339**  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0B324F ED B8       0340**  			LDDR                    	; Otherwise, make space for the new line in the program
0B3251 C1          0341**  ATEND:			POP     BC              	; BC: Line length
0B3252 D1          0342**  			POP     DE              	; DE: Line number
0B3253 23          0343**  			INC     HL			; HL: Destination address
0B3254 71          0344**  			LD      (HL),C          	; Store length
0B3255 23          0345**  			INC     HL
0B3256 73          0346**  			LD      (HL),E          	; Store line number
0B3257 23          0347**  			INC     HL
0B3258 72          0348**  			LD      (HL),D
0B3259 23          0349**  			INC     HL
0B325A 11 00 4C 0B 0350**  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0B325E EB          0351**  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0B325F 0D          0352**  			DEC     C			; Subtract 3 from the number of bytes to copy to
0B3260 0D          0353**  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0B3261 0D          0354**  			DEC     C
0B3262 ED B0       0355**  			LDIR                    	; Add the line to the BASIC program
0B3264 37          0356**  			SCF				; To flag we need to call CLEAN
0B3265 C9          0357**  			RET
0B3266             0358**  ;
0B3266             0359**  ; List of tokens and keywords. If a keyword is followed by 0 then
0B3266             0360**  ; it will only match with the keyword followed immediately by
0B3266             0361**  ; a delimiter
0B3266             0362**  ;
0B3266 80 41 4E 44 0363**  KEYWDS:			DB    80H, "AND"
0B326A 94 41 42 53 0364**  			DB    94H, "ABS"
0B326E 95 41 43 53 0365**  			DB    95H, "ACS"
0B3272 96 41 44 56 0366**  			DB    96H, "ADVAL"
       41 4C       
0B3278 97 41 53 43 0367**  			DB    97H, "ASC"
0B327C 98 41 53 4E 0368**  			DB    98H, "ASN"
0B3280 99 41 54 4E 0369**  			DB    99H, "ATN"
0B3284 C6 41 55 54 0370**  			DB    C6H, "AUTO"
       4F          
0B3289 9A 42 47 45 0371**  			DB    9AH, "BGET", 0
       54 00       
0B328F D5 42 50 55 0372**  			DB    D5H, "BPUT", 0
       54 00       
0B3295 FB 43 4F 4C 0373**  			DB    FBH, "COLOUR"
       4F 55 52    
0B329C FB 43 4F 4C 0374**  			DB    FBH, "COLOR"
       4F 52       
0B32A2 D6 43 41 4C 0375**  			DB    D6H, "CALL"
       4C          
0B32A7 D7 43 48 41 0376**  			DB    D7H, "CHAIN"
       49 4E       
0B32AD BD 43 48 52 0377**  			DB    BDH, "CHR$"
       24          
0B32B2 D8 43 4C 45 0378**  			DB    D8H, "CLEAR", 0
       41 52 00    
0B32B9 D9 43 4C 4F 0379**  			DB    D9H, "CLOSE", 0
       53 45 00    
0B32C0 DA 43 4C 47 0380**  			DB    DAH, "CLG", 0
       00          
0B32C5 DB 43 4C 53 0381**  			DB    DBH, "CLS", 0
       00          
0B32CA 9B 43 4F 53 0382**  			DB    9BH, "COS"
0B32CE 9C 43 4F 55 0383**  			DB    9CH, "COUNT", 0
       4E 54 00    
0B32D5 DC 44 41 54 0384**  			DB    DCH, "DATA"
       41          
0B32DA 9D 44 45 47 0385**  			DB    9DH, "DEG"
0B32DE DD 44 45 46 0386**  			DB    DDH, "DEF"
0B32E2 C7 44 45 4C 0387**  			DB    C7H, "DELETE"
       45 54 45    
0B32E9 81 44 49 56 0388**  			DB    81H, "DIV"
0B32ED DE 44 49 4D 0389**  			DB    DEH, "DIM"
0B32F1 DF 44 52 41 0390**  			DB    DFH, "DRAW"
       57          
0B32F6 E1 45 4E 44 0391**  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
0B32FF E0 45 4E 44 0392**  			DB    E0H, "END", 0
       00          
0B3304 E2 45 4E 56 0393**  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
0B330D 8B 45 4C 53 0394**  			DB    8BH, "ELSE"
       45          
0B3312 A0 45 56 41 0395**  			DB    A0H, "EVAL"
       4C          
0B3317 9E 45 52 4C 0396**  			DB    9EH, "ERL", 0
       00          
0B331C 85 45 52 52 0397**  			DB    85H, "ERROR"
       4F 52       
0B3322 C5 45 4F 46 0398**  			DB    C5H, "EOF", 0
       00          
0B3327 82 45 4F 52 0399**  			DB    82H, "EOR"
0B332B 9F 45 52 52 0400**  			DB    9FH, "ERR", 0
       00          
0B3330 A1 45 58 50 0401**  			DB    A1H, "EXP"
0B3334 A2 45 58 54 0402**  			DB    A2H, "EXT", 0
       00          
0B3339 E3 46 4F 52 0403**  			DB    E3H, "FOR"
0B333D A3 46 41 4C 0404**  			DB    A3H, "FALSE", 0
       53 45 00    
0B3344 A4 46 4E    0405**  			DB    A4H, "FN"
0B3347 E5 47 4F 54 0406**  			DB    E5H, "GOTO"
       4F          
0B334C BE 47 45 54 0407**  			DB    BEH, "GET$"
       24          
0B3351 A5 47 45 54 0408**  			DB    A5H, "GET"
0B3355 E4 47 4F 53 0409**  			DB    E4H, "GOSUB"
       55 42       
0B335B E6 47 43 4F 0410**  			DB    E6H, "GCOL"
       4C          
0B3360 93 48 49 4D 0411**  			DB    93H, "HIMEM", 0
       45 4D 00    
0B3367 E8 49 4E 50 0412**  			DB    E8H, "INPUT"
       55 54       
0B336D E7 49 46    0413**  			DB    E7H, "IF"
0B3370 BF 49 4E 4B 0414**  			DB    BFH, "INKEY$"
       45 59 24    
0B3377 A6 49 4E 4B 0415**  			DB    A6H, "INKEY"
       45 59       
0B337D A8 49 4E 54 0416**  			DB    A8H, "INT"
0B3381 A7 49 4E 53 0417**  			DB    A7H, "INSTR("
       54 52 28    
0B3388 C9 4C 49 53 0418**  			DB    C9H, "LIST"
       54          
0B338D 86 4C 49 4E 0419**  			DB    86H, "LINE"
       45          
0B3392 C8 4C 4F 41 0420**  			DB    C8H, "LOAD"
       44          
0B3397 92 4C 4F 4D 0421**  			DB    92H, "LOMEM", 0
       45 4D 00    
0B339E EA 4C 4F 43 0422**  			DB    EAH, "LOCAL"
       41 4C       
0B33A4 C0 4C 45 46 0423**  			DB    C0H, "LEFT$("
       54 24 28    
0B33AB A9 4C 45 4E 0424**  			DB    A9H, "LEN"
0B33AF E9 4C 45 54 0425**  			DB    E9H, "LET"
0B33B3 AB 4C 4F 47 0426**  			DB    ABH, "LOG"
0B33B7 AA 4C 4E    0427**  			DB    AAH, "LN"
0B33BA C1 4D 49 44 0428**  			DB    C1H, "MID$("
       24 28       
0B33C0 EB 4D 4F 44 0429**  			DB    EBH, "MODE"
       45          
0B33C5 83 4D 4F 44 0430**  			DB    83H, "MOD"
0B33C9 EC 4D 4F 56 0431**  			DB    ECH, "MOVE"
       45          
0B33CE ED 4E 45 58 0432**  			DB    EDH, "NEXT"
       54          
0B33D3 CA 4E 45 57 0433**  			DB    CAH, "NEW", 0
       00          
0B33D8 AC 4E 4F 54 0434**  			DB    ACH, "NOT"
0B33DC CB 4F 4C 44 0435**  			DB    CBH, "OLD", 0
       00          
0B33E1 EE 4F 4E    0436**  			DB    EEH, "ON"
0B33E4 87 4F 46 46 0437**  			DB    87H, "OFF"
0B33E8 84 4F 52    0438**  			DB    84H, "OR"
0B33EB 8E 4F 50 45 0439**  			DB    8EH, "OPENIN"
       4E 49 4E    
0B33F2 AE 4F 50 45 0440**  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
0B33FA AD 4F 50 45 0441**  			DB    ADH, "OPENUP"
       4E 55 50    
0B3401 FF 4F 53 43 0442**  			DB    FFH, "OSCLI"
       4C 49       
0B3407 F1 50 52 49 0443**  			DB    F1H, "PRINT"
       4E 54       
0B340D 90 50 41 47 0444**  			DB    90H, "PAGE", 0
       45 00       
0B3413 8F 50 54 52 0445**  			DB    8FH, "PTR", 0
       00          
0B3418 AF 50 49 00 0446**  			DB    AFH, "PI", 0
0B341C F0 50 4C 4F 0447**  			DB    F0H, "PLOT"
       54          
0B3421 B0 50 4F 49 0448**  			DB    B0H, "POINT("
       4E 54 28    
0B3428 F2 50 52 4F 0449**  			DB    F2H, "PROC"
       43          
0B342D B1 50 4F 53 0450**  			DB    B1H, "POS", 0
       00          
0B3432 CE 50 55 54 0451**  			DB    CEH, "PUT"
0B3436 F8 52 45 54 0452**  			DB    F8H, "RETURN", 0
       55 52 4E 00 
0B343E F5 52 45 50 0453**  			DB    F5H, "REPEAT"
       45 41 54    
0B3445 F6 52 45 50 0454**  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0B344D F3 52 45 41 0455**  			DB    F3H, "READ"
       44          
0B3452 F4 52 45 4D 0456**  			DB    F4H, "REM"
0B3456 F9 52 55 4E 0457**  			DB    F9H, "RUN", 0
       00          
0B345B B2 52 41 44 0458**  			DB    B2H, "RAD"
0B345F F7 52 45 53 0459**  			DB    F7H, "RESTORE"
       54 4F 52 45 
0B3467 C2 52 49 47 0460**  			DB    C2H, "RIGHT$("
       48 54 24 28 
0B346F B3 52 4E 44 0461**  			DB    B3H, "RND", 0
       00          
0B3474 CC 52 45 4E 0462**  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0B347D 88 53 54 45 0463**  			DB    88H, "STEP"
       50          
0B3482 CD 53 41 56 0464**  			DB    CDH, "SAVE"
       45          
0B3487 B4 53 47 4E 0465**  			DB    B4H, "SGN"
0B348B B5 53 49 4E 0466**  			DB    B5H, "SIN"
0B348F B6 53 51 52 0467**  			DB    B6H, "SQR"
0B3493 89 53 50 43 0468**  			DB    89H, "SPC"
0B3497 C3 53 54 52 0469**  			DB    C3H, "STR$"
       24          
0B349C C4 53 54 52 0470**  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0B34A5 D4 53 4F 55 0471**  			DB    D4H, "SOUND"
       4E 44       
0B34AB FA 53 54 4F 0472**  			DB    FAH, "STOP", 0
       50 00       
0B34B1 B7 54 41 4E 0473**  			DB    B7H, "TAN"
0B34B5 8C 54 48 45 0474**  			DB    8CH, "THEN"
       4E          
0B34BA B8 54 4F    0475**  			DB    B8H, "TO"
0B34BD 8A 54 41 42 0476**  			DB    8AH, "TAB("
       28          
0B34C2 FC 54 52 41 0477**  			DB    FCH, "TRACE"
       43 45       
0B34C8 91 54 49 4D 0478**  			DB    91H, "TIME", 0
       45 00       
0B34CE B9 54 52 55 0479**  			DB    B9H, "TRUE", 0
       45 00       
0B34D4 FD 55 4E 54 0480**  			DB    FDH, "UNTIL"
       49 4C       
0B34DA BA 55 53 52 0481**  			DB    BAH, "USR"
0B34DE EF 56 44 55 0482**  			DB    EFH, "VDU"
0B34E2 BB 56 41 4C 0483**  			DB    BBH, "VAL"
0B34E6 BC 56 50 4F 0484**  			DB    BCH, "VPOS", 0
       53 00       
0B34EC FE 57 49 44 0485**  			DB    FEH, "WIDTH"
       54 48       
0B34F2 D3 48 49 4D 0486**  			DB    D3H, "HIMEM"
       45 4D       
0B34F8 D2 4C 4F 4D 0487**  			DB    D2H, "LOMEM"
       45 4D       
0B34FE D0 50 41 47 0488**  			DB    D0H, "PAGE"
       45          
0B3503 CF 50 54 52 0489**  			DB    CFH, "PTR"
0B3507 D1 54 49 4D 0490**  			DB    D1H, "TIME"
       45          
0B350C             0491**  ;
0B350C             0492**  ; These are indexed from the ERRWDS table
0B350C             0493**  ;
0B350C 01 4D 69 73 0494**  			DB    01H, "Missing "
       73 69 6E 67 
       20          
0B3515 02 4E 6F 20 0495**  			DB    02H, "No such "
       73 75 63 68 
       20          
0B351E 03 42 61 64 0496**  			DB    03H, "Bad "
       20          
0B3523 04 20 72 61 0497**  			DB    04H, " range"
       6E 67 65    
0B352A 05 76 61 72 0498**  			DB    05H, "variable"
       69 61 62 6C 
       65          
0B3533 06 4F 75 74 0499**  			DB    06H, "Out of"
       20 6F 66    
0B353A 07 4E 6F 20 0500**  			DB    07H, "No "
0B353E 08 20 73 70 0501**  			DB    08H, " space"
       61 63 65    
0B3545             0502**  
0B3545             0503**  KEYWDL:			EQU     $-KEYWDS
0B3545 FF FF       0504**  			DW    -1
0B3547             0505**  ;
0B3547             0506**  ; Error messages
0B3547             0507**  ;
0B3547 07 72 6F 6F 0508**  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
0B354D 06 04 00    0509**  			DB    6, 4, 0			;  1: Out of range
0B3550 00          0510**  			DB    0				;  2: *
0B3551 00          0511**  			DB    0				;  3: *
0B3552 4D 69 73 74 0512**  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0B355A 01 2C 00    0513**  			DB    1, ",", 0			;  5: Missing ,
0B355D 54 79 70 65 0514**  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0B356B 07 A4 00    0515**  			DB    7, FN, 0			;  7: No FN
0B356E 00          0516**  			DB    0				;  8: *
0B356F 01 22 00    0517**  			DB    1, 34, 0			;  9: Missing "
0B3572 03 DE 00    0518**  			DB    3, DIM, 0			; 10: Bad DIM
0B3575 DE 08 00    0519**  			DB    DIM, 8, 0			; 11: DIM space
0B3578 4E 6F 74 20 0520**  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0B357E 07 F2 00    0521**  			DB    7, PROC, 0		; 13: No PROC
0B3581 41 72 72 61 0522**  			DB    "Array", 0		; 14: Array
       79 00       
0B3587 53 75 62 73 0523**  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0B3591 53 79 6E 74 0524**  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0B359E 45 73 63 61 0525**  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0B35A5 44 69 76 69 0526**  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0B35B6 53 74 72 69 0527**  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
0B35C6 54 6F 6F 20 0528**  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
0B35CE 2D 76 65 20 0529**  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
0B35D7 4C 6F 67 04 0530**  			DB    "Log", 4, 0		; 22: Log range
       00          
0B35DC 41 63 63 75 0531**  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
0B35EA 45 78 70 04 0532**  			DB    "Exp", 4, 0		; 24: Exp range
       00          
0B35EF 00          0533**  			DB    0				; 25: *
0B35F0 02 05 00    0534**  			DB    2, 5, 0			; 26: No such variable
0B35F3 01 29 00    0535**  			DB    1, ")", 0			; 27: Missing )
0B35F6 03 48 45 58 0536**  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
0B35FB 02 A4 2F F2 0537**  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
0B3600 03 63 61 6C 0538**  			DB    3, "call", 0		; 30: Bad call
       6C 00       
0B3606 41 72 67 75 0539**  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
0B3610 07 E3 00    0540**  			DB    7, FOR, 0			; 32: No FOR
0B3613 43 61 6E 27 0541**  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
0B3621 E3 20 05 00 0542**  			DB    FOR, " ", 5, 0		; 34: FOR variable
0B3625 00          0543**  			DB    0				; 35: *
0B3626 07 B8 00    0544**  			DB    7, TO_MN, 0			; 36: No TO
0B3629 00          0545**  			DB    0				; 37: *
0B362A 07 E4 00    0546**  			DB    7, GOSUB, 0		; 38: No GOSUB
0B362D EE 20 73 79 0547**  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
0B3636 EE 04 00    0548**  			DB    ON_, 4, 0			; 40: ON range
0B3639 02 6C 69 6E 0549**  			DB    2, "line", 0		; 41: No such line
       65 00       
0B363F 06 20 DC 00 0550**  			DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
0B3643 07 F5 00    0551**  			DB    7, REPEAT, 0		; 43: No REPEAT
0B3646 00          0552**  			DB    0				; 44: *
0B3647 01 23 00    0553**  			DB    1, "#", 0			; 45: Missing #
0B364A             0554**  ;
0B364A             0555**  ; COMMANDS:
0B364A             0556**  ;
0B364A             0557**  ; DELETE line,line
0B364A             0558**  ;
0B364A CD 49 39 0B 0559**  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0B364E CD 51 3D 0B 0560**  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B3652 7E          0561**  DELET1:			LD      A,(HL)			; Check whether it's the last line
0B3653 B7          0562**  			OR      A
0B3654 CA DB 36 0B 0563**  			JP      Z,WARMNC		; Yes, so do nothing
0B3658 23          0564**  			INC     HL			; Skip the line length byte
0B3659 11 00 00 00 0565**  			LD	DE, 0			; Clear DE
0B365D 5E          0566**  			LD      E,(HL)			; Fetch the line number in DE
0B365E 23          0567**  			INC     HL
0B365F 56          0568**  			LD      D,(HL)
0B3660 7A          0569**  			LD      A,D			; If the line number is zero then
0B3661 B3          0570**  			OR      E
0B3662 28 1D       0571**  			JR      Z,CLOOP1        	; Do nothing
0B3664 2B          0572**  			DEC     HL			; Decrement BASIC program pointer back to length
0B3665 2B          0573**  			DEC     HL
0B3666 EB          0574**  			EX      DE,HL			; Check if we've gone past the terminating line
0B3667 37          0575**  			SCF
0B3668 ED 42       0576**  			SBC     HL,BC
0B366A EB          0577**  			EX      DE,HL
0B366B 30 6E       0578**  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0B366D C5          0579**  			PUSH    BC
0B366E CD 00 39 0B 0580**  			CALL    DEL			; Delete the line pointed to by HL
0B3672 C1          0581**  			POP     BC
0B3673 18 DD       0582**  			JR      DELET1			; And loop round to the next line
0B3675             0583**  ;
0B3675             0584**  ; LISTO expr
0B3675             0585**  ;
0B3675 FD 23       0586**  LISTO:			INC     IY              	; Skip "O" byte
0B3677 CD 08 04 0B 0587**  			CALL    EXPRI			; Get expr
0B367B D9          0588**  			EXX
0B367C 7D          0589**  			LD      A,L
0B367D 32 40 4E 0B 0590**  			LD      (LISTON),A		; Store in LISTON sysvar
0B3681 C3 7E 31 0B 0591**  CLOOP1:			JP      CLOOP
0B3685             0592**  ;
0B3685             0593**  ; LIST
0B3685             0594**  ; LIST line
0B3685             0595**  ; LIST line,line [IF string]
0B3685             0596**  ; LIST ,line
0B3685             0597**  ; LIST line,
0B3685             0598**  ;
0B3685 FE 4F       0599**  LIST_:			CP      'O'			; Check for O (LISTO)
0B3687 28 EC       0600**  			JR      Z,LISTO			; and jump to LISTO if zero
0B3689 CD 51 3D 0B 0601**  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B368D CD 6E 0B 0B 0602**  			CALL    NXT			; Skip space
0B3691 FE E7       0603**  			CP      TIF             	; Check for IF clause (token IF)
0B3693 3E 00       0604**  			LD      A,0             	; Initialise the IF clause string length
0B3695 20 17       0605**  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0B3697             0606**  ;
0B3697 FD 23       0607**  			INC     IY              	; Skip the IF token
0B3699 CD 6E 0B 0B 0608**  			CALL    NXT             	; And skip any spaces
0B369D EB          0609**  			EX      DE,HL			; DE: Address in memory
0B369E FD E5       0610**  			PUSH    IY			; LD IY, HL
0B36A0 E1          0611**  			POP     HL              	; HL is now the address of the tokenised line
0B36A1 3E 0D       0612**  			LD      A,CR
0B36A3 C5          0613**  			PUSH    BC			; Stack the second line number arg
0B36A4 01 00 01 00 0614**  			LD      BC,256
0B36A8 ED B1       0615**  			CPIR                    	; Locate CR byte
0B36AA 79          0616**  			LD      A,C
0B36AB 2F          0617**  			CPL                    	 	; A: Substring length (of IF clause)
0B36AC C1          0618**  			POP     BC			; Restore the second line number arg
0B36AD EB          0619**  			EX      DE,HL			; HL: Address in memory
0B36AE             0620**  ;
0B36AE 5F          0621**  LISTB:			LD      E,A             	; E: IF clause string length
0B36AF 78          0622**  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0B36B0 B1          0623**  			OR      C
0B36B1 20 01       0624**  			JR      NZ,LISTA		; If there isn't a second line number
0B36B3 0B          0625**  			DEC     BC			; then we set it to the maximum of 65535
0B36B4             0626**  ;
0B36B4 D9          0627**  LISTA:			EXX
0B36B5 DD 21 40 4E 0628**  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       0B          
0B36BA 01 00 00 00 0629**  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0B36BE D9          0630**  			EXX
0B36BF 3E 14       0631**  			LD      A,20			; Number of lines to list
0B36C1             0632**  ;
0B36C1 C5          0633**  LISTC:			PUSH    BC              	; Save second line number
0B36C2 D5          0634**  			PUSH    DE              	; Save IF clause length
0B36C3 E5          0635**  			PUSH    HL              	; Save BASIC program counter
0B36C4 08          0636**  			EX      AF,AF'
0B36C5             0637**  ;
0B36C5             0638**  ; BBC BASIC for Z80 lines are stored as follows:
0B36C5             0639**  ;
0B36C5             0640**  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0B36C5             0641**  ; - [&00] [&FF] [&FF]: End of program marker
0B36C5             0642**  ;
0B36C5             0643**  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0B36C5             0644**  ;
0B36C5 7E          0645**  			LD      A,(HL)			; Check for end of program marker
0B36C6 B7          0646**  			OR      A			; If found
0B36C7 28 12       0647**  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0B36C9             0648**  ;
0B36C9             0649**  ; Check if past terminating line number
0B36C9             0650**  ;
0B36C9 7B          0651**  			LD      A,E             	; A: IF clause length
0B36CA 23          0652**  			INC     HL			; Skip the length byte
0B36CB 11 00 00 00 0653**  			LD	DE,0			; Clear DE
0B36CF 5E          0654**  			LD      E,(HL)			; Fetch the line number in DE
0B36D0 23          0655**  			INC     HL
0B36D1 56          0656**  			LD      D,(HL)
0B36D2 2B          0657**  			DEC     HL			; Step HL back to the length byte
0B36D3 2B          0658**  			DEC     HL
0B36D4 D5          0659**  			PUSH    DE             	 	; Push the line number on the stack
0B36D5 EB          0660**  			EX      DE,HL			; HL: line number
0B36D6 37          0661**  			SCF				; Do a 16-bit compare of HL and DE
0B36D7 ED 42       0662**  			SBC     HL,BC
0B36D9 EB          0663**  			EX      DE,HL
0B36DA D1          0664**  			POP     DE              	; Restore the line number
0B36DB D2 7D 31 0B 0665**  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0B36DF 4E          0666**  			LD      C,(HL)          	; C: Line length + 4
0B36E0 47          0667**  			LD      B,A             	; B: IF clause length
0B36E1             0668**  ;
0B36E1             0669**  ; Check if "UNLISTABLE":
0B36E1             0670**  ;
0B36E1 7A          0671**  			LD      A,D			; TODO: What is "UNLISTABLE?"
0B36E2 B3          0672**  			OR      E
0B36E3 CA 7E 31 0B 0673**  			JP      Z,CLOOP
0B36E7             0674**  ;
0B36E7             0675**  ; Check for IF clause:
0B36E7             0676**  ;
0B36E7 23          0677**  			INC     HL			; Skip the length
0B36E8 23          0678**  			INC     HL			; Skip the line number
0B36E9 23          0679**  			INC     HL              	; HL: Address of the tokenised BASIC line
0B36EA 0D          0680**  			DEC     C			;  C: Line length
0B36EB 0D          0681**  			DEC     C
0B36EC 0D          0682**  			DEC     C
0B36ED 0D          0683**  			DEC     C
0B36EE D5          0684**  			PUSH    DE              	; Save the line number
0B36EF E5          0685**  			PUSH    HL              	; Save the BASIC program address
0B36F0 AF          0686**  			XOR     A               	;
0B36F1 B8          0687**  			CP      B              	 	; Check for an IF clause (B!=0)
0B36F2 FD E5       0688**  			PUSH    IY			; LD IY, DE
0B36F4 D1          0689**  			POP     DE              	; DE: Address of the IF clause string in the input buffer
0B36F5 C4 83 08 0B 0690**  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0B36F9 E1          0691**  			POP     HL              	; Restore BASIC program address
0B36FA D1          0692**  			POP     DE              	; Restore line number
0B36FB FD E5       0693**  			PUSH    IY
0B36FD CC 90 39 0B 0694**  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
0B3701 FD E1       0695**  			POP     IY
0B3703             0696**  ;
0B3703 08          0697**  			EX      AF,AF'
0B3704 3D          0698**  			DEC     A			; Decrement line list counter
0B3705 CD 6F 40 0B 0699**  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
0B3709 E1          0700**  			POP     HL             	 	; Restore BASIC program address to beginning of line
0B370A 11 00 00 00 0701**  			LD	DE,0
0B370E 5E          0702**  			LD      E,(HL)			; Fetch the length of line in DE
0B370F 19          0703**  			ADD     HL,DE           	; Go to the next line
0B3710 D1          0704**  			POP     DE              	; Restore IF clause length
0B3711 C1          0705**  			POP     BC              	; Restore second line number
0B3712 18 AD       0706**  			JR      LISTC			; Loop back to do next line
0B3714             0707**  ;
0B3714             0708**  ; RENUMBER
0B3714             0709**  ; RENUMBER start
0B3714             0710**  ; RENUMBER start,increment
0B3714             0711**  ; RENUMBER ,increment
0B3714             0712**  ;
0B3714 CD 74 39 0B 0713**  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
0B3718 CD 29 3D 0B 0714**  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
0B371C D9          0715**  			EXX
0B371D 2A 14 4E 0B 0716**  			LD      HL,(PAGE_)		; HL: Top of program
0B3721 ED 5B 1A 4E 0717**  			LD      DE,(LOMEM)		; DE: Start address of the heap
       0B          
0B3726             0718**  ;
0B3726             0719**  ; Build the table
0B3726             0720**  ;
0B3726 7E          0721**  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
0B3727 B7          0722**  			OR      A			; Is it zero, i.e. the end of program marker?
0B3728 28 36       0723**  			JR      Z,RENUM2		; Yes, so skip to the next part
0B372A 23          0724**  			INC     HL
0B372B 4E          0725**  			LD      C,(HL)          	; BC: The OLD line number
0B372C 23          0726**  			INC     HL
0B372D 46          0727**  			LD      B,(HL)
0B372E 78          0728**  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
0B372F B1          0729**  			OR      C
0B3730 CA 7E 31 0B 0730**  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
0B3734 EB          0731**  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B3735 71          0732**  			LD      (HL),C			; Store the OLD line number in the heap
0B3736 23          0733**  			INC     HL
0B3737 70          0734**  			LD      (HL),B
0B3738 23          0735**  			INC     HL
0B3739 D9          0736**  			EXX				; HL: line number, BC: increment (16-bit values)
0B373A E5          0737**  			PUSH    HL			; HL: Stack the NEW line number value
0B373B 52 09       0738**  			ADD.S   HL,BC           	; Add the increment
0B373D DA 23 3D 0B 0739**  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
0B3741 D9          0740**  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
0B3742 C1          0741**  			POP     BC			; BC: Pop the NEW line number value off the stack
0B3743 71          0742**  			LD      (HL),C			; Store the NEW line number in the heap
0B3744 23          0743**  			INC     HL
0B3745 70          0744**  			LD      (HL),B
0B3746 23          0745**  			INC     HL
0B3747 EB          0746**  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B3748 2B          0747**  			DEC     HL			; Back up to the line length byte
0B3749 2B          0748**  			DEC     HL
0B374A 01 00 00 00 0749**  			LD	BC, 0
0B374E 4E          0750**  			LD      C,(HL)			; BC: Line length
0B374F 09          0751**  			ADD	HL,BC           	; Advance HL to next line
0B3750 EB          0752**  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B3751 E5          0753**  			PUSH    HL
0B3752 24          0754**  			INC     H			; Increment to next page
0B3753 ED 72       0755**  			SBC     HL,SP			; Subtract from SP
0B3755 E1          0756**  			POP     HL
0B3756 EB          0757**  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B3757 38 CD       0758**  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0B3759 CD 75 38 0B 0759**  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0B375D CC          0760**  			DB    	REN
0B375E 08          0761**  			DB    	8
0B375F 00          0762**  			DB    	0
0B3760             0763**  ;
0B3760             0764**  ; At this point a list of BASIC line numbers have been written to the heap
0B3760             0765**  ; as word pairs:
0B3760             0766**  ; - DW: The OLD line number
0B3760             0767**  ; - DW: The NEW line number
0B3760             0768**  ;
0B3760 EB          0769**  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0B3761 36 FF       0770**  			LD      (HL),-1			; Mark the end with FFFFh
0B3763 23          0771**  			INC     HL
0B3764 36 FF       0772**  			LD      (HL),-1
0B3766 ED 5B 1A 4E 0773**  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       0B          
0B376B D9          0774**  			EXX
0B376C 2A 14 4E 0B 0775**  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0B3770 4E          0776**  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0B3771 79          0777**  			LD      A,C			; If it is zero, then no program, so...
0B3772 B7          0778**  			OR      A
0B3773 CA 7D 31 0B 0779**  			JP      Z,WARM			; Jump to warm start
0B3777 D9          0780**  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0B3778 EB          0781**  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0B3779 23          0782**  			INC     HL			; Skip to the NEW line number
0B377A 23          0783**  			INC     HL
0B377B 5E          0784**  			LD      E,(HL)			; DE: The NEW line number
0B377C 23          0785**  			INC     HL
0B377D 56          0786**  			LD      D,(HL)
0B377E 23          0787**  			INC     HL
0B377F D5          0788**  			PUSH    DE			; Stack the NEW line number
0B3780 EB          0789**  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0B3781 22 23 4E 0B 0790**  			LD      (LINENO),HL		; Store the line number in LINENO
0B3785 D9          0791**  			EXX				; HL: Pointer to the BASIC program area
0B3786 D1          0792**  			POP     DE			; DE: The NEW line number
0B3787 23          0793**  			INC     HL
0B3788 73          0794**  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0B3789 23          0795**  			INC     HL
0B378A 72          0796**  			LD      (HL),D
0B378B 23          0797**  			INC     HL
0B378C 0D          0798**  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0B378D 0D          0799**  			DEC     C
0B378E 0D          0800**  			DEC     C
0B378F 79          0801**  			LD	A,C
0B3790 01 00 00 00 0802**  			LD	BC,0
0B3794 4F          0803**  			LD	C,A			; BC: Line length
0B3795             0804**  ;
0B3795 3E 8D       0805**  RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0B3797 ED B1       0806**  			CPIR                    	; Search for the token
0B3799 20 D5       0807**  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0B379B             0808**  ;
0B379B             0809**  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0B379B             0810**  ;
0B379B C5          0811**  			PUSH    BC			; Stack everything
0B379C E5          0812**  			PUSH    HL
0B379D E5          0813**  			PUSH    HL			; HL: Pointer to encoded line number
0B379E FD E1       0814**  			POP     IY			; IY: Pointer to encoded line number
0B37A0 D9          0815**  			EXX
0B37A1 CD E4 09 0B 0816**  			CALL    DECODE			; Decode the encoded line number (in HL')
0B37A5 D9          0817**  			EXX				; HL: Decoded line number
0B37A6 44          0818**  			LD      B,H			; BC: Decoded line number
0B37A7 4D          0819**  			LD      C,L
0B37A8 2A 1A 4E 0B 0820**  			LD      HL,(LOMEM)		; HL: Pointer to heap
0B37AC             0821**  ;
0B37AC             0822**  ; This section of code cross-references the decoded (OLD) line number with the list
0B37AC             0823**  ; created previously in the global heap
0B37AC             0824**  ;
0B37AC 5E          0825**  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0B37AD 23          0826**  			INC     HL
0B37AE 56          0827**  			LD      D,(HL)
0B37AF 23          0828**  			INC     HL
0B37B0 EB          0829**  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0B37B1 B7          0830**  			OR      A               	; Clear the carry and...
0B37B2 52 ED 42    0831**  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0B37B5 EB          0832**  			EX      DE,HL			; HL: Pointer in the global heap
0B37B6 5E          0833**  			LD      E,(HL)          	; DE: The NEW line number
0B37B7 23          0834**  			INC     HL
0B37B8 56          0835**  			LD      D,(HL)
0B37B9 23          0836**  			INC     HL
0B37BA 38 F0       0837**  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0B37BC EB          0838**  			EX      DE,HL			; DE: Pointer in the global heap
0B37BD 28 1D       0839**  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0B37BF             0840**  ;
0B37BF CD 8E 3E 0B 0841**  			CALL    TELL			; Display this error if the line number is not found
0B37C3 46 61 69 6C 0842**  			DB    	"Failed at "
       65 64 20 61 
       74 20       
0B37CD 00          0843**  			DB    	0
0B37CE 2A 23 4E 0B 0844**  			LD      HL,(LINENO)
0B37D2 CD F5 3A 0B 0845**  			CALL    PBCDL
0B37D6 CD 45 3A 0B 0846**  			CALL    CRLF
0B37DA 18 07       0847**  			JR      RENUM6			; And carry on renumbering
0B37DC             0848**  ;
0B37DC             0849**  ; This snippet re-encodes the line number in the BASIC program
0B37DC             0850**  ;
0B37DC D1          0851**  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0B37DD D5          0852**  			PUSH    DE
0B37DE 1B          0853**  			DEC     DE			; Back up a byte to the LINO token
0B37DF CD 5A 3E 0B 0854**  			CALL    ENCODE          	; Re-write the new line number out
0B37E3 E1          0855**  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0B37E4 C1          0856**  			POP     BC			; BC: The remaining line length
0B37E5 18 AE       0857**  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0B37E7             0858**  ;
0B37E7             0859**  ; AUTO
0B37E7             0860**  ; AUTO start,increment
0B37E7             0861**  ; AUTO start
0B37E7             0862**  ; AUTO ,increment
0B37E7             0863**  ;
0B37E7 CD 29 3D 0B 0864**  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0B37EB 22 29 4E 0B 0865**  			LD      (AUTONO),HL		; Store the start in AUTONO
0B37EF 79          0866**  			LD      A,C			; Increment is 8 bit (0-255)
0B37F0 32 41 4E 0B 0867**  			LD      (INCREM),A		; Store that in INCREM
0B37F4 18 2E       0868**  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B37F6             0869**  ;
0B37F6             0870**  ; BAD
0B37F6             0871**  ; NEW
0B37F6             0872**  ;
0B37F6 CD 8E 3E 0B 0873**  BAD:			CALL    TELL            	; Output "Bad program" error
0B37FA 03          0874**  			DB    3				; Token for "BAD"
0B37FB 70 72 6F 67 0875**  			DB    "program"
       72 61 6D    
0B3802 0D          0876**  			DB    CR
0B3803 0A          0877**  			DB    LF
0B3804 00          0878**  			DB    0				; Falls through to NEW
0B3805             0879**  ;
0B3805 CD 6A 39 0B 0880**  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
0B3809 18 19       0881**  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B380B             0882**  ;
0B380B             0883**  ; OLD
0B380B             0884**  ;
0B380B 2A 14 4E 0B 0885**  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
0B380F E5          0886**  			PUSH    HL			; Stack it
0B3810 23          0887**  			INC     HL			; Skip the potential length byte of first line of code
0B3811 23          0888**  			INC     HL			; And the line number word
0B3812 23          0889**  			INC     HL
0B3813 01 FC 00 00 0890**  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
0B3817 3E 0D       0891**  			LD      A,CR
0B3819 ED B1       0892**  			CPIR
0B381B 20 D9       0893**  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
0B381D 7D          0894**  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
0B381E E1          0895**  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
0B381F 77          0896**  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
0B3820 CD 3D 39 0B 0897**  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B3824 C3 7E 31 0B 0898**  CLOOP0:			JP      CLOOP			; Jump back to the command loop
0B3828             0899**  ;
0B3828             0900**  ; LOAD filename
0B3828             0901**  ;
0B3828 CD 13 04 0B 0902**  LOAD:			CALL    EXPRS           	; Get the filename
0B382C 3E 0D       0903**  			LD      A,CR			; DE points to the last byte of filename in ACCS
0B382E 12          0904**  			LD      (DE),A			; Terminate filename with a CR
0B382F CD 1D 39 0B 0905**  			CALL    LOAD0			; Load the file in, then CLEAN
0B3833 CD 74 39 0B 0906**  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B3837 18 21       0907**  			JR      WARM0			; Jump back to the command loop
0B3839             0908**  ;
0B3839             0909**  ; SAVE filename
0B3839             0910**  ;
0B3839 CD 49 39 0B 0911**  SAVE:			CALL    SETTOP          	; Set TOP sysvar
0B383D CD 13 04 0B 0912**  			CALL    EXPRS           	; Get the filename
0B3841 3E 0D       0913**  			LD      A,CR			; Terminate the filename with a CR
0B3843 12          0914**  			LD      (DE),A
0B3844 ED 5B 14 4E 0915**  			LD      DE,(PAGE_)		; DE: Start of program memory
       0B          
0B3849 2A 17 4E 0B 0916**  			LD      HL,(TOP)		; HL: Top of program memory
0B384D B7          0917**  			OR      A			; Calculate program size (TOP-PAGE)
0B384E ED 52       0918**  			SBC     HL,DE
0B3850 44          0919**  			LD      B,H             	; BC: Length of program in bytes
0B3851 4D          0920**  			LD      C,L
0B3852 21 00 4B 0B 0921**  			LD      HL,ACCS			; HL: Address of the filename
0B3856 CD 2B 43 0B 0922**  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
0B385A C3 7D 31 0B 0923**  WARM0:			JP      WARM			; Jump back to the command loop
0B385E             0924**  
0B385E             0925**  ;
0B385E             0926**  ; ERROR
0B385E             0927**  ; Called whenever BASIC needs to halt with an error
0B385E             0928**  ; Error messages are indexed from 0
0B385E             0929**  ; Inputs:
0B385E             0930**  ;  A: Error number
0B385E             0931**  ;
0B385E ED 7B 20 4E 0932**  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       0B          
0B3863 21 47 35 0B 0933**  			LD      HL,ERRWDS		; Index into the error string table
0B3867 B7          0934**  			OR      A			; We don't need to search for the first error
0B3868 28 0A       0935**  			JR      Z,ERROR1		; So skip the search routine
0B386A             0936**  ;
0B386A             0937**  ; Search the error table for error #A
0B386A             0938**  ; HL will end up being the pointer into the correct error
0B386A             0939**  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0B386A             0940**  ;
0B386A 47          0941**  			LD      B,A             	; Store error number in B
0B386B 08          0942**  			EX      AF,AF'			; Store error number in AF'
0B386C AF          0943**  			XOR     A
0B386D BE          0944**  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0B386E 23          0945**  			INC     HL			; Increment the string pointer
0B386F 20 FC       0946**  			JR      NZ,ERROR0		; Loop until with hit a 0
0B3871 10 FA       0947**  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0B3873 08          0948**  			EX      AF,AF'			; Restore the error number from AF'
0B3874             0949**  ;
0B3874             0950**  ; At this point HL points to the tokenised error string
0B3874             0951**  ;
0B3874 E5          0952**  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0B3875             0953**  
0B3875             0954**  ;
0B3875             0955**  ; EXTERR
0B3875             0956**  ; Inputs:
0B3875             0957**  ;  A: Error number
0B3875             0958**  ;
0B3875             0959**  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0B3875             0960**  ; The error text immediately follows the CALL to EXTERR, for example:
0B3875             0961**  ; > CALL  EXTERR
0B3875             0962**  ; > DB    "Silly", 0
0B3875             0963**  ; So we can get the address of the string by popping the return address off the stack
0B3875             0964**  ;
0B3875 E1          0965**  EXTERR:			POP     HL			; Pop the error string pointer
0B3876 22 2F 4E 0B 0966**  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0B387A ED 7B 20 4E 0967**  			LD      SP,(HIMEM)		; Set SP to HIMEM
       0B          
0B387F 32 3F 4E 0B 0968**  			LD      (ERR),A			; Store error number in ERR sysvar
0B3883 CD AC 3A 0B 0969**  			CALL    SETLIN			; Get line number
0B3887 22 33 4E 0B 0970**  			LD      (ERL),HL		; Store in ERL sysvar
0B388B B7          0971**  			OR      A			; Is error number 0?
0B388C 28 0D       0972**  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0B388E             0973**  ;
0B388E 2A 2C 4E 0B 0974**  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0B3892 7C          0975**  			LD      A,H
0B3893 B5          0976**  			OR      L
0B3894 E5          0977**  			PUSH    HL			; HL: Error line
0B3895 FD E1       0978**  			POP     IY			; IY: HL
0B3897 C2 94 0C 0B 0979**  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0B389B             0980**  ;
0B389B 21 00 00 00 0981**  ERROR2:			LD      HL,0
0B389F 22 29 4E 0B 0982**  			LD      (AUTONO),HL		; Cancel AUTO
0B38A3 22 26 4E 0B 0983**  			LD      (TRACEN),HL     	; Cancel TRACE
0B38A7 CD B4 44 0B 0984**  			CALL    RESET           	; Reset OPSYS
0B38AB CD 45 3A 0B 0985**  			CALL    CRLF			; Output newline
0B38AF CD 80 3E 0B 0986**  			CALL    REPORT          	; Output the error message
0B38B3 CD E0 3A 0B 0987**  			CALL    SAYLN			; Output " at line nnnn" message.
0B38B7 1E 00       0988**  			LD      E,0			; Close all files
0B38B9 DC 29 44 0B 0989**  			CALL    C,OSSHUT
0B38BD CD 45 3A 0B 0990**  			CALL    CRLF			; Output newline
0B38C1 C3 7E 31 0B 0991**  			JP      CLOOP			; Back to CLOOP
0B38C5             0992**  ;
0B38C5             0993**  ; SUBROUTINES:
0B38C5             0994**  ;
0B38C5             0995**  ; LEX - SEARCH FOR KEYWORDS
0B38C5             0996**  ;   Inputs: HL = start of keyword table
0B38C5             0997**  ;           IY = start of match text
0B38C5             0998**  ;  Outputs: If found, Z-flag set, A=token.
0B38C5             0999**  ;           If not found, Z-flag reset, A=(IY).
0B38C5             1000**  ;           IY updated (if NZ, IY unchanged).
0B38C5             1001**  ; Destroys: A,B,H,L,IY,F
0B38C5             1002**  ;
0B38C5 21 66 32 0B 1003**  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0B38C9             1004**  ;
0B38C9 FD 7E 00    1005**  LEX0:			LD      A,(IY)			; Fetch the character to match
0B38CC 46          1006**  			LD      B,(HL)			; B: The token from the keywords table
0B38CD 23          1007**  			INC     HL			; Increment the pointer in the keywords table
0B38CE BE          1008**  			CP      (HL)			; Compare the first characters
0B38CF 28 08       1009**  			JR      Z,LEX2			; If there is a match, then skip to LEX2
0B38D1 D8          1010**  			RET     C               	; No match, so fail
0B38D2             1011**  ;
0B38D2             1012**  ; This snippet of code skips to the next token in the KEYWDS table
0B38D2             1013**  ;
0B38D2 23          1014**  LEX1:			INC     HL			; Increment the pointer
0B38D3 CB 7E       1015**  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0B38D5 28 FB       1016**  			JR      Z,LEX1			; No, so loop
0B38D7 18 F0       1017**  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
0B38D9             1018**  ;
0B38D9 FD E5       1019**  LEX2:			PUSH    IY              	; Save the input pointer
0B38DB 23          1020**  LEX3:			INC     HL			; Increment the keyword pointer
0B38DC CB 7E       1021**  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0B38DE 20 1C       1022**  			JR      NZ,LEX6         	; Jump to here as we've found a token
0B38E0 FD 23       1023**  			INC     IY			; Increment the text pointer
0B38E2 FD 7E 00    1024**  			LD      A,(IY)			; Fetch the character
0B38E5 FE 2E       1025**  			CP      '.'			; Is it an abbreviated keyword?
0B38E7 28 13       1026**  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0B38E9 BE          1027**  			CP      (HL)			; Compare with the keywords list
0B38EA 28 EF       1028**  			JR      Z,LEX3			; It's a match, so continue checking this keyword
0B38EC CD 79 3D 0B 1029**  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B38F0 38 04       1030**  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0B38F2             1031**  ;
0B38F2 FD E1       1032**  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0B38F4 18 DC       1033**  			JR      LEX1			; And loop back to start again
0B38F6             1034**  ;
0B38F6             1035**  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
0B38F6             1036**  ; immediately delimited
0B38F6             1037**  ;
0B38F6 7E          1038**  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0B38F7 B7          1039**  			OR      A			; If it is not zero, then...
0B38F8 20 F8       1040**  			JR      NZ,LEX4			; Keep searching
0B38FA FD 2B       1041**  			DEC     IY			; If it is zero, then skip the input pointer back one byte
0B38FC             1042**  ;
0B38FC             1043**  ; We've found a token at this point
0B38FC             1044**  ;
0B38FC F1          1045**  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0B38FD AF          1046**  			XOR     A			; Set the Z flag
0B38FE 78          1047**  			LD      A,B			; A: The token
0B38FF C9          1048**  			RET
0B3900             1049**  ;
0B3900             1050**  ; DEL - DELETE A PROGRAM LINE.
0B3900             1051**  ;   Inputs: HL addresses program line.
0B3900             1052**  ; Destroys: B,C,F
0B3900             1053**  ;
0B3900             1054**  ; This simply erases the line by moving all of the code after the line to be deleted back over
0B3900             1055**  ; it using an LDIR
0B3900             1056**  ;
0B3900 D5          1057**  DEL:			PUSH    DE
0B3901 E5          1058**  			PUSH    HL
0B3902 E5          1059**  			PUSH    HL			; HL: Address of the program line
0B3903 06 00       1060**  			LD      B,0			; BC: Length of the line
0B3905 4E          1061**  			LD      C,(HL)
0B3906 09          1062**  			ADD     HL,BC			; HL: Advanced to the start of the next line
0B3907 E5          1063**  			PUSH    HL
0B3908 EB          1064**  			EX      DE,HL			; DE: Pointer to the next line
0B3909 2A 17 4E 0B 1065**  			LD      HL,(TOP)		; HL: Pointer to the end of the program
0B390D ED 52       1066**  			SBC     HL,DE
0B390F 44          1067**  			LD      B,H			; BC: Size of block to move
0B3910 4D          1068**  			LD      C,L
0B3911 E1          1069**  			POP     HL			; HL: Pointer to next line
0B3912 D1          1070**  			POP     DE			; DE: Pointer to this line
0B3913 ED B0       1071**  			LDIR                    	; Delete the line
0B3915 ED 53 17 4E 1072**  			LD      (TOP),DE		; Adjust TOP
       0B          
0B391A E1          1073**  			POP     HL
0B391B D1          1074**  			POP     DE
0B391C C9          1075**  			RET
0B391D             1076**  ;
0B391D             1077**  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
0B391D             1078**  ;   Inputs: Filename in ACCS (term CR)
0B391D             1079**  ; Destroys: A,B,C,D,E,H,L,F
0B391D             1080**  ;
0B391D             1081**  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
0B391D             1082**  ; AND WRITE FF FF, THEN LOAD (TOP).
0B391D             1083**  ; Destroys: A,B,C,H,L,F
0B391D             1084**  ;
0B391D ED 5B 14 4E 1085**  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       0B          
0B3922 21 00 FF FF 1086**  			LD      HL,-256
0B3926 39          1087**  			ADD     HL,SP
0B3927 ED 52       1088**  			SBC     HL,DE           	; Find available space
0B3929 44          1089**  			LD      B,H
0B392A 4D          1090**  			LD      C,L
0B392B 21 00 4B 0B 1091**  			LD      HL,ACCS
0B392F CD 92 42 0B 1092**  			CALL    OSLOAD          	; Call the OSLOAD function in patch
0B3933 D4 6A 39 0B 1093**  			CALL    NC,NEWIT		; If NC then NEW
0B3937 3E 00       1094**  			LD      A,0
0B3939 D2 5E 38 0B 1095**  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
0B393D             1096**  ;
0B393D CD 49 39 0B 1097**  CLEAN:			CALL    SETTOP			; Set TOP sysvar
0B3941 2B          1098**  			DEC     HL			; Write out the end of program markers
0B3942 36 FF       1099**  			LD      (HL),-1
0B3944 2B          1100**  			DEC     HL
0B3945 36 FF       1101**  			LD      (HL),-1
0B3947 18 2B       1102**  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0B3949             1103**  ;
0B3949             1104**  ; Set the TOP sysvar; the first free location after the end of the current program
0B3949             1105**  ; Returns:
0B3949             1106**  ; - HL: TOP
0B3949             1107**  ;
0B3949 2A 14 4E 0B 1108**  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0B394D 01 00 00 00 1109**  			LD	BC, 0			; BC: 0
0B3951 3E 0D       1110**  			LD      A,CR			; End of line marker
0B3953 4E          1111**  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0B3954 0C          1112**  			INC     C			; Check for zero
0B3955 0D          1113**  			DEC     C
0B3956 28 0A       1114**  			JR      Z,SETOP2		; If it is zero, we've reached the end
0B3958 09          1115**  			ADD     HL,BC			; Skip to next line
0B3959 2B          1116**  			DEC     HL			; Check end of previous line
0B395A BE          1117**  			CP      (HL)
0B395B 23          1118**  			INC     HL
0B395C 28 F5       1119**  			JR      Z,SETOP1		; If CR then loop
0B395E C3 F6 37 0B 1120**  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0B3962             1121**  ;
0B3962 23          1122**  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0B3963 23          1123**  			INC     HL			; NB: Called from NEWIT
0B3964 23          1124**  			INC     HL
0B3965 22 17 4E 0B 1125**  			LD      (TOP),HL		; Store in TOP sysvar
0B3969 C9          1126**  			RET
0B396A             1127**  ;
0B396A             1128**  ; NEWIT - NEW PROGRAM THEN CLEAR
0B396A             1129**  ;   Destroys: H,L
0B396A             1130**  ;
0B396A             1131**  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0B396A             1132**  ; FUNCTION AND PROCEDURE POINTERS.
0B396A             1133**  ;   Destroys: Nothing
0B396A             1134**  ;
0B396A 2A 14 4E 0B 1135**  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0B396E 36 00       1136**  			LD      (HL),0			; Stick a 0 in there
0B3970 CD 62 39 0B 1137**  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0B3974             1138**  ;
0B3974 E5          1139**  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0B3975 2A 17 4E 0B 1140**  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0B3979 22 1A 4E 0B 1141**  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0B397D 22 1D 4E 0B 1142**  			LD      (FREE),HL		; And the FREE sysvar with that value
0B3981 21 6C 4D 0B 1143**  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0B3985 C5          1144**  			PUSH    BC
0B3986             1145**  			; LD      B,3*(54+2)		; Loop counter
0B3986 06 A8       1146**  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0B3988 36 00       1147**  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0B398A 23          1148**  			INC     HL
0B398B 10 FB       1149**  			DJNZ    CLEAR1
0B398D C1          1150**  			POP     BC
0B398E E1          1151**  			POP     HL			; Restore the BASIC program pointer
0B398F C9          1152**  			RET
0B3990             1153**  ;
0B3990             1154**  ;LISTIT - LIST A PROGRAM LINE.
0B3990             1155**  ;    Inputs: HL addresses line
0B3990             1156**  ;            DE = line number (binary)
0B3990             1157**  ;            IX = Pointer to LISTON
0B3990             1158**  ;             B = FOR/NEXT indent level
0B3990             1159**  ;             C = REPEAT/UNTIL indent level
0B3990             1160**  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0B3990             1161**  ;
0B3990 E5          1162**  LISTIT:			PUSH    HL			; Stack the address of the line
0B3991 EB          1163**  			EX      DE,HL			; HL: Line number
0B3992 C5          1164**  			PUSH    BC
0B3993 CD F9 3A 0B 1165**  			CALL    PBCD			; Print the line number
0B3997 C1          1166**  			POP     BC
0B3998 E1          1167**  			POP     HL			; HL: Address of the first token/character
0B3999 7E          1168**  			LD      A,(HL)			; Fetch the token
0B399A FE ED       1169**  			CP      NEXT			; Is it NEXT...
0B399C CC 26 3A 0B 1170**  			CALL    Z,INDENT		; Yes, so indent in
0B39A0 FE FD       1171**  			CP      UNTIL			; Or is it UNTIL...
0B39A2 CC 26 3A 0B 1172**  			CALL    Z,INDENT		; Yes, so indent in
0B39A6 D9          1173**  			EXX
0B39A7 3E 20       1174**  			LD      A,' '
0B39A9 DD CB 00 46 1175**  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0B39AD C4 4D 3A 0B 1176**  			CALL    NZ,OUTCHR		; Then print a space after the line number
0B39B1 78          1177**  			LD      A,B			; Fetch the FOR/NEXT indent level
0B39B2 87          1178**  			ADD     A,A			; Multiply by 2
0B39B3 DD CB 00 4E 1179**  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0B39B7 C4 ED 18 0B 1180**  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
0B39BB 79          1181**  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
0B39BC 87          1182**  			ADD     A,A			; Multiply by 2
0B39BD DD CB 00 56 1183**  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0B39C1 C4 ED 18 0B 1184**  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0B39C5 D9          1185**  			EXX
0B39C6 7E          1186**  			LD      A,(HL)			; Fetch the token
0B39C7 FE E3       1187**  			CP      FOR			; Is it FOR?
0B39C9 CC 26 3A 0B 1188**  			CALL    Z,INDENT		; Yes, so indent
0B39CD FE F5       1189**  			CP      REPEAT			; Is it REPEAT?
0B39CF CC 26 3A 0B 1190**  			CALL    Z,INDENT		; Yes, so indent
0B39D3 1E 00       1191**  			LD      E,0			; E: The quote counter - reset to 0
0B39D5 7E          1192**  LIST8:			LD      A,(HL)			; Fetch a character / token byte
0B39D6 23          1193**  			INC     HL
0B39D7 FE 0D       1194**  			CP      CR			; Is it end of line?
0B39D9 28 0B       1195**  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0B39DB FE 22       1196**  			CP      34			; Is it a quote character?
0B39DD 20 01       1197**  			JR      NZ,LIST7		; No, so skip to next bit
0B39DF 1C          1198**  			INC     E			; Otherwise increment quote counter
0B39E0 CD 15 3A 0B 1199**  LIST7:			CALL    LOUT			; Output the character / token
0B39E4 18 EF       1200**  			JR      LIST8			; And repeat
0B39E6             1201**  ;
0B39E6             1202**  ; DB: Modification for *EDIT
0B39E6             1203**  ; Terminate the line with either a CRLF or a NUL character
0B39E6             1204**  ;
0B39E6 DD CB 00 5E 1205**  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0B39EA 28 59       1206**  			JR	Z, CRLF			; Yes, so print a CRLF
0B39EC AF          1207**  			XOR	A			; Otherwise print a NUL (0)
0B39ED C3 FE 3F 0B 1208**  			JP	OSWRCH
0B39F1             1209**  ;
0B39F1             1210**  ; Decode the 3 byte GOTO type line number
0B39F1             1211**  ;
0B39F1 E5          1212**  PRLINO:			PUSH    HL			; Swap HL and IY
0B39F2 FD E1       1213**  			POP     IY			; IY: Pointer to the line number
0B39F4 C5          1214**  			PUSH    BC
0B39F5 CD E4 09 0B 1215**  			CALL    DECODE			; Decode
0B39F9 C1          1216**  			POP     BC
0B39FA D9          1217**  			EXX
0B39FB C5          1218**  			PUSH    BC
0B39FC CD F5 3A 0B 1219**  			CALL    PBCDL			; Output the line number
0B3A00 C1          1220**  			POP     BC
0B3A01 D9          1221**  			EXX
0B3A02 FD E5       1222**  			PUSH    IY			; Swap HL and IY
0B3A04 E1          1223**  			POP     HL			; HL: Pointer to the next character in the line
0B3A05 C9          1224**  			RET
0B3A06             1225**  ;
0B3A06             1226**  ; DB: Modification for internationalisation
0B3A06             1227**  ;
0B3A06 CD 6A 3A 0B 1228**  PRREM:			CALL	OUT_			; Output the REM token
0B3A0A 7E          1229**  @@:			LD	A, (HL)			; Fetch the character
0B3A0B FE 0D       1230**  			CP	CR			; If it is end of line, then
0B3A0D C8          1231**  			RET	Z			; we have finished
0B3A0E CD 4D 3A 0B 1232**  			CALL	OUTCHR			; Ouput the character
0B3A12 23          1233**  			INC	HL
0B3A13 18 F5       1234**  			JR	@B			; And loop
0B3A15             1235**  ;
0B3A15             1236**  ; DB: End of modification
0B3A15             1237**  ;
0B3A15 CB 43       1238**  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
0B3A17 20 34       1239**  			JR      NZ,OUTCHR		; don't tokenise, just output the character
0B3A19 FE F4       1240**  			CP	REM			; DB: Is it REM
0B3A1B 28 E9       1241**  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
0B3A1D FE 8D       1242**  			CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
0B3A1F 28 D0       1243**  			JR      Z,PRLINO		; Yes, so decode and print the line number
0B3A21 CD 6A 3A 0B 1244**  			CALL    OUT_			; Output a character / keyword
0B3A25 7E          1245**  			LD      A,(HL)			; Fetch the next character
0B3A26             1246**  ;
0B3A26             1247**  ; This block of code handles the indentation
0B3A26             1248**  ; B: Counter for FOR/NEXT indent
0B3A26             1249**  ; C: Counter for REPEAT/UNTIL indent
0B3A26             1250**  ;
0B3A26 D9          1251**  INDENT:			EXX
0B3A27 FE E3       1252**  			CP      FOR			; If the token is FOR
0B3A29 28 09       1253**  			JR      Z,IND1			; Then INC B
0B3A2B FE ED       1254**  			CP      NEXT			; If it is NEXT
0B3A2D 20 06       1255**  			JR      NZ,IND2_		; Then...
0B3A2F 05          1256**  			DEC     B			; DEC B
0B3A30 F2 35 3A 0B 1257**  			JP      P,IND2_			; If we have gone below 0 then
0B3A34 04          1258**  IND1:			INC     B			; Increment back to 0
0B3A35             1259**  ;
0B3A35 FE F5       1260**  IND2_:			CP      REPEAT			; If the token is REPEAT
0B3A37 28 09       1261**  			JR      Z,IND3			; Then INC C
0B3A39 FE FD       1262**  			CP      UNTIL			; If it is UNTIL
0B3A3B 20 06       1263**  			JR      NZ,IND4			; Then...
0B3A3D 0D          1264**  			DEC     C			; DEC C
0B3A3E F2 43 3A 0B 1265**  			JP      P,IND4			; If we have gone below 0 then
0B3A42 0C          1266**  IND3:			INC     C			; Incremet back to 0
0B3A43 D9          1267**  IND4:			EXX
0B3A44 C9          1268**  			RET
0B3A45             1269**  ;
0B3A45             1270**  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
0B3A45             1271**  ;  Destroys: A,F
0B3A45             1272**  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
0B3A45             1273**  ;    Inputs: A = character
0B3A45             1274**  ;  Destroys: A,F
0B3A45             1275**  ;
0B3A45 3E 0D       1276**  CRLF:			LD      A,CR			; Output CR
0B3A47 CD 4D 3A 0B 1277**  			CALL    OUTCHR
0B3A4B 3E 0A       1278**  			LD      A,LF			; Output LF
0B3A4D             1279**  ;
0B3A4D CD FE 3F 0B 1280**  OUTCHR:			CALL    OSWRCH			; Output the character in A
0B3A51 D6 0D       1281**  			SUB     CR			; Check for CR
0B3A53 28 06       1282**  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0B3A55 D8          1283**  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0B3A56 3A 3D 4E 0B 1284**  			LD      A,(COUNT)		; Increment the count
0B3A5A 3C          1285**  			INC     A
0B3A5B             1286**  ;
0B3A5B 32 3D 4E 0B 1287**  CARRET:			LD      (COUNT),A		; Store the new count value
0B3A5F C8          1288**  			RET     Z			; Return if the count has wrapped to 0
0B3A60 E5          1289**  			PUSH    HL			; Now check if count = print width
0B3A61 2A 3E 4E 0B 1290**  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0B3A65 BD          1291**  			CP      L			; L is the width. Compare it with count.
0B3A66 E1          1292**  			POP     HL
0B3A67 C0          1293**  			RET     NZ			; If we've not hit print width, then just return
0B3A68 18 DB       1294**  			JR      CRLF			; Otherwise output CRLF
0B3A6A             1295**  ;
0B3A6A             1296**  ; OUT - SEND CHARACTER OR KEYWORD
0B3A6A             1297**  ;   Inputs: A = character (>=10, <128)
0B3A6A             1298**  ;           A = Token (<10, >=128)
0B3A6A             1299**  ;  Destroys: A,F
0B3A6A             1300**  ;
0B3A6A FE 8A       1301**  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0B3A6C EA 4D 3A 0B 1302**  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0B3A70             1303**  ;
0B3A70             1304**  ; This bit looks up the character in the KEYWDS token table and expands it
0B3A70             1305**  ; Note the CP 138; this sets the overflow flag as follows:
0B3A70             1306**  ;
0B3A70             1307**  ; NB:
0B3A70             1308**  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0B3A70             1309**  ;  2. CP is effectively a SUB; sets the flags without affecting A
0B3A70             1310**  ;  3. The operation n - -118 ~ n + 118
0B3A70             1311**  ;
0B3A70             1312**  ; So:
0B3A70             1313**  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0B3A70             1314**  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0B3A70             1315**  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0B3A70             1316**  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0B3A70             1317**  ;
0B3A70 C5          1318**  			PUSH    BC			; Preserve BC and HL
0B3A71 E5          1319**  			PUSH    HL
0B3A72 21 66 32 0B 1320**  			LD      HL,KEYWDS		; The list of tokens and keywords
0B3A76 01 DF 02 00 1321**  			LD      BC,KEYWDL		; The length of the keyword list
0B3A7A ED B1       1322**  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0B3A7C             1323**  ;							; At this point HL points to the next byte, the first character of the token
0B3A7C 7E          1324**  TOKEN1:			LD      A,(HL)			; Fetch the character
0B3A7D 23          1325**  			INC     HL			; Increment to the next byte in the token table
0B3A7E FE 8A       1326**  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0B3A80 F5          1327**  			PUSH    AF			; Then...
0B3A81 EC 4D 3A 0B 1328**  			CALL    PE,OUTCHR		; Output the character...
0B3A85 F1          1329**  			POP     AF			;
0B3A86 EA 7C 3A 0B 1330**  			JP      PE,TOKEN1		; And loop to the next character
0B3A8A E1          1331**  			POP     HL			; Done, so tidy up the stack and exit
0B3A8B C1          1332**  			POP     BC
0B3A8C C9          1333**  			RET
0B3A8D             1334**  ;
0B3A8D             1335**  ; FINDL - FIND PROGRAM LINE
0B3A8D             1336**  ;   Inputs: HL = line number (binary)
0B3A8D             1337**  ;  Outputs: HL addresses line (if found)
0B3A8D             1338**  ;           DE = line number
0B3A8D             1339**  ;           Z-flag set if found.
0B3A8D             1340**  ; Destroys: A,B,C,D,E,H,L,F
0B3A8D             1341**  ;
0B3A8D EB          1342**  FINDL:			EX      DE,HL			; DE: Line number (binary)
0B3A8E 2A 14 4E 0B 1343**  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0B3A92 AF          1344**  			XOR     A               	;  A: 0
0B3A93 BE          1345**  			CP      (HL)			; Check for end of program marker
0B3A94 3C          1346**  			INC     A			;  A: 1
0B3A95 D0          1347**  			RET     NC			; Return with 1 if 0
0B3A96 AF          1348**  			XOR     A               	; Clear the carry flag
0B3A97             1349**  ;			LD      B,A			;  B: 0
0B3A97 01 00 00 00 1350**  			LD	BC, 0			; BC: 0
0B3A9B             1351**  ;
0B3A9B 4E          1352**  FINDL1:			LD      C,(HL)			;  C: The line length
0B3A9C E5          1353**  			PUSH    HL			; Stack the current program counter
0B3A9D 23          1354**  			INC     HL			; Skip to the line number bytes
0B3A9E 7E          1355**  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0B3A9F 23          1356**  			INC     HL
0B3AA0 66          1357**  			LD      H,(HL)
0B3AA1 6F          1358**  			LD      L,A
0B3AA2 52 ED 52    1359**  			SBC.S   HL,DE			; Compare with the line number we're searching for
0B3AA5 E1          1360**  			POP     HL			; Get the current program counter
0B3AA6 D0          1361**  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0B3AA7 09          1362**  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0B3AA8 C3 9B 3A 0B 1363**  			JP      FINDL1			; And loop
0B3AAC             1364**  ;
0B3AAC             1365**  ; SETLIN - Search program for line containing address
0B3AAC             1366**  ;          Update (LINENO)
0B3AAC             1367**  ;   Inputs: Address in (ERRLIN)
0B3AAC             1368**  ;  Outputs: Line number in HL and (LINENO)
0B3AAC             1369**  ; Destroys: B,C,D,E,H,L,F
0B3AAC             1370**  ;
0B3AAC 01 00 00 00 1371**  SETLIN:			LD	BC, 0			; Zero BC for later
0B3AB0             1372**  ;			LD      B, 0			; Zero B for later
0B3AB0 ED 5B 35 4E 1373**  			LD      DE, (ERRLIN)		; DE: Address of line
       0B          
0B3AB5 2A 14 4E 0B 1374**  			LD      HL, (PAGE_)		; HL: Start of user program area
0B3AB9 B7          1375**  			OR      A			; Do a 24 bit compare without destroying HL
0B3ABA ED 52       1376**  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0B3ABC 19          1377**  			ADD     HL, DE			;  C: DE > HL
0B3ABD 30 1B       1378**  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0B3ABF             1379**  ;
0B3ABF 4E          1380**  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0B3AC0 0C          1381**  			INC     C			; This is a way to check for zero without using the accumulator
0B3AC1 0D          1382**  			DEC     C			; If it is zero, then...
0B3AC2 28 16       1383**  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0B3AC4 09          1384**  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0B3AC5 ED 52       1385**  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0B3AC7 19          1386**  			ADD     HL, DE
0B3AC8 38 F5       1387**  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0B3ACA ED 42       1388**  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
0B3ACC 23          1389**  			INC     HL			; Skip the length counter
0B3ACD 11 00 00 00 1390**  			LD	DE, 0			; Zero DE
0B3AD1 5E          1391**  			LD      E, (HL)          	; Fetch the line number
0B3AD2 23          1392**  			INC     HL
0B3AD3 56          1393**  			LD      D, (HL)
0B3AD4 EB          1394**  			EX      DE, HL			; HL: The line number
0B3AD5 22 23 4E 0B 1395**  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0B3AD9 C9          1396**  			RET
0B3ADA             1397**  ;
0B3ADA 21 00 00 00 1398**  SET3:			LD      HL, 0			; We've not found the line at this point so
0B3ADE 18 F5       1399**  			JR      SET2			; Set LINENO to 0
0B3AE0             1400**  ;
0B3AE0             1401**  ;SAYLN - PRINT " at line nnnn" MESSAGE.
0B3AE0             1402**  ;  Outputs: Carry=0 if line number is zero.
0B3AE0             1403**  ;           Carry=1 if line number is non-zero.
0B3AE0             1404**  ; Destroys: A,B,C,D,E,H,L,F
0B3AE0             1405**  ;
0B3AE0 2A 23 4E 0B 1406**  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0B3AE4 7C          1407**  			LD      A,H			; If it is zero then
0B3AE5 B5          1408**  			OR      L
0B3AE6 C8          1409**  			RET     Z			; Don't need to do anything; return with F:C set to 0
0B3AE7 CD 8E 3E 0B 1410**  			CALL    TELL			; Output the error message
0B3AEB 20 61 74 20 1411**  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
0B3AF5 0E 00       1412**  PBCDL:			LD      C,0			; C: Leading character (NUL)
0B3AF7 18 02       1413**  			JR      PBCD0			; Output the line number; return with F:C set to 1
0B3AF9             1414**  ;
0B3AF9             1415**  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
0B3AF9             1416**  ;   Inputs: HL = number (binary).
0B3AF9             1417**  ;  Outputs: Carry = 1
0B3AF9             1418**  ; Destroys: A,B,C,D,E,H,L,F
0B3AF9             1419**  ;
0B3AF9 0E 20       1420**  PBCD:			LD      C,' '			; C: Leading character (" ")
0B3AFB 06 05       1421**  PBCD0:			LD      B,5			; Number of digits in result
0B3AFD 11 10 27 00 1422**  			LD      DE,10000		; Start off with the 10,000 column
0B3B01 AF          1423**  PBCD1:			XOR     A			; Counter
0B3B02 ED 52       1424**  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
0B3B04 3C          1425**  			INC     A
0B3B05 30 FB       1426**  			JR      NC,PBCD2
0B3B07 19          1427**  			ADD     HL,DE			; The loop overruns by one, so adjust here
0B3B08 3D          1428**  			DEC     A			; A: Number of 10,000s
0B3B09 28 04       1429**  			JR      Z,PBCD3			; If it is 0, then skip the next bit
0B3B0B CB E1       1430**  			SET     4,C			; C: Set to '0' ASCII (30h)
0B3B0D CB E9       1431**  			SET     5,C
0B3B0F B1          1432**  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
0B3B10 C4 4D 3A 0B 1433**  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
0B3B14 78          1434**  			LD      A,B			; If on first transition, skip this
0B3B15 FE 05       1435**  			CP      5			; TODO: Need to find out why
0B3B17 28 06       1436**  			JR      Z,PBCD4
0B3B19 29          1437**  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
0B3B1A 54          1438**  			LD      D,H			;         : rather than shifting DE right
0B3B1B 5D          1439**  			LD      E,L			;         : This makes a lot of sense
0B3B1C 29          1440**  			ADD     HL,HL			; HL x  4
0B3B1D 29          1441**  			ADD     HL,HL			; HL x  8
0B3B1E 19          1442**  			ADD     HL,DE			; HL x 10
0B3B1F 11 E8 03 00 1443**  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
0B3B23 10 DC       1444**  			DJNZ    PBCD1			; Loop until done
0B3B25 37          1445**  			SCF				; SCF set for SAYLN in this module
0B3B26 C9          1446**  			RET
0B3B27             1447**  ;
0B3B27             1448**  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
0B3B27             1449**  ;   Inputs: HL, IY as returned from GETVAR (NZ).
0B3B27             1450**  ;  Outputs: As GETVAR.
0B3B27             1451**  ; Destroys: everything
0B3B27             1452**  ;
0B3B27 CD AC 3C 0B 1453**  PUTVAR:			CALL    CREATE			; Create the variable
0B3B2B FD 7E 00    1454**  			LD      A,(IY)			; Fetch the next character
0B3B2E FE 28       1455**  			CP      '('			; Check for bad use of array
0B3B30 20 70       1456**  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
0B3B32 3E 0E       1457**  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
0B3B34 C3 5E 38 0B 1458**  ERROR3:			JP      ERROR_
0B3B38             1459**  ;
0B3B38             1460**  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
0B3B38             1461**  ;   Inputs: IY addresses first character.
0B3B38             1462**  ;  Outputs: Carry set and NZ if illegal character.
0B3B38             1463**  ;           Z-flag set if variable found, then:
0B3B38             1464**  ;            A = variable type (0,4,5,128 or 129)
0B3B38             1465**  ;            HL = IX = variable pointer.
0B3B38             1466**  ;            IY updated
0B3B38             1467**  ;           If Z-flag & carry reset, then:
0B3B38             1468**  ;            HL, IY set for subsequent PUTVAR call.
0B3B38             1469**  ; Destroys: everything
0B3B38             1470**  ;
0B3B38 FD 7E 00    1471**  GETVAR:			LD      A,(IY)			; Get the first character
0B3B3B FE 24       1472**  			CP      '$'			; Is it a string?
0B3B3D 28 69       1473**  			JR      Z,GETV4			; Yes, so branch here
0B3B3F FE 21       1474**  			CP      '!'			; Is it indirection (32-bit)?
0B3B41 28 69       1475**  			JR      Z,GETV5			; Yes, so branch here
0B3B43 FE 3F       1476**  			CP      '?'			; Is it indirection (8-bit)?
0B3B45 28 69       1477**  			JR      Z,GETV6			; Yes, so branch here
0B3B47             1478**  ;
0B3B47 CD 16 3C 0B 1479**  			CALL    LOCATE			; Locate the variable
0B3B4B C0          1480**  			RET     NZ			; And exit here if not found
0B3B4C             1481**  ;
0B3B4C             1482**  ; At this point:
0B3B4C             1483**  ;  HL: Address of variable in memory
0B3B4C             1484**  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
0B3B4C             1485**  ;
0B3B4C FD 7E 00    1486**  			LD      A,(IY)			; Further checks
0B3B4F FE 28       1487**  			CP      '('             	; Is it an array?
0B3B51 20 47       1488**  			JR      NZ,GETVX        	; No, so exit
0B3B53             1489**  ;
0B3B53             1490**  ; We are processing an array at this point
0B3B53             1491**  ;
0B3B53 D5          1492**  			PUSH    DE              	; Save the variable type (in D)
0B3B54 7E          1493**  			LD      A,(HL)          	; Fetch the number of dimensions
0B3B55 B7          1494**  			OR      A
0B3B56 28 DA       1495**  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
0B3B58 23          1496**  			INC     HL			;
0B3B59 11 00 00 00 1497**  			LD      DE,0            	; Accumulator
0B3B5D F5          1498**  			PUSH    AF
0B3B5E FD 23       1499**  			INC     IY              	; Skip "("
0B3B60 18 05       1500**  			JR      GETV3
0B3B62             1501**  ;
0B3B62 F5          1502**  GETV2:			PUSH    AF
0B3B63 CD 20 0B 0B 1503**  			CALL    COMMA
0B3B67 E5          1504**  GETV3:			PUSH    HL
0B3B68 D5          1505**  			PUSH    DE
0B3B69 CD 08 04 0B 1506**  			CALL    EXPRI			; Get the subscript
0B3B6D D9          1507**  			EXX
0B3B6E D1          1508**  			POP     DE
0B3B6F E3          1509**  			EX      (SP),HL
0B3B70 4E          1510**  			LD      C,(HL)
0B3B71 23          1511**  			INC     HL
0B3B72 46          1512**  			LD      B,(HL)
0B3B73 23          1513**  			INC     HL
0B3B74 E3          1514**  			EX      (SP),HL
0B3B75 EB          1515**  			EX      DE,HL
0B3B76 D5          1516**  			PUSH    DE
0B3B77 CD 70 19 0B 1517**  			CALL    MUL16			; HL=HL*BC
0B3B7B D1          1518**  			POP     DE
0B3B7C 19          1519**  			ADD     HL,DE
0B3B7D EB          1520**  			EX      DE,HL
0B3B7E B7          1521**  			OR      A
0B3B7F ED 42       1522**  			SBC     HL,BC
0B3B81 3E 0F       1523**  			LD      A,15
0B3B83 30 AF       1524**  			JR      NC,ERROR3		; Throw a "Subscript" error
0B3B85 E1          1525**  			POP     HL
0B3B86 F1          1526**  			POP     AF
0B3B87 3D          1527**  			DEC     A               	; Dimension counter
0B3B88 20 D8       1528**  			JR      NZ,GETV2
0B3B8A CD 2D 0B 0B 1529**  			CALL    BRAKET          	; Check for closing bracket
0B3B8E F1          1530**  			POP     AF              	; Restore the type
0B3B8F E5          1531**  			PUSH    HL
0B3B90 CD 63 19 0B 1532**  			CALL    X4OR5           	; DE=DE*n
0B3B94 E1          1533**  			POP     HL
0B3B95 19          1534**  			ADD     HL,DE
0B3B96 57          1535**  			LD      D,A             	; The type
0B3B97 FD 7E 00    1536**  			LD      A,(IY)
0B3B9A FE 3F       1537**  GETVX:			CP      '?'
0B3B9C 28 1E       1538**  			JR      Z,GETV9
0B3B9E FE 21       1539**  			CP      '!'
0B3BA0 28 16       1540**  			JR      Z,GETV8
0B3BA2 E5          1541**  GETVZ:			PUSH    HL              	; Set exit conditions
0B3BA3 DD E1       1542**  			POP     IX
0B3BA5 7A          1543**  			LD      A,D
0B3BA6 BF          1544**  			CP      A
0B3BA7 C9          1545**  			RET
0B3BA8             1546**  ;
0B3BA8             1547**  ; Process strings, unary & binary indirection:
0B3BA8             1548**  ;
0B3BA8 3E 80       1549**  GETV4:			LD      A,128           	; Static strings
0B3BAA 18 05       1550**  			JR      GETV7
0B3BAC             1551**  ;
0B3BAC 3E 04       1552**  GETV5:			LD      A,4             	; Unary 32-bit indirection
0B3BAE 18 01       1553**  			JR      GETV7
0B3BB0             1554**  ;
0B3BB0 AF          1555**  GETV6:			XOR     A               	; Unary 8-bit indirection
0B3BB1             1556**  ;
0B3BB1 21 00 00 00 1557**  GETV7:			LD      HL,0
0B3BB5 F5          1558**  			PUSH    AF
0B3BB6 18 24       1559**  			JR      GETV0
0B3BB8             1560**  ;
0B3BB8 06 04       1561**  GETV8:			LD      B,4             	; Binary 32-bt indirection
0B3BBA 18 02       1562**  			JR      GETVA
0B3BBC             1563**  ;
0B3BBC 06 00       1564**  GETV9:			LD      B,0             	; Binary 8-bit indirection
0B3BBE             1565**  ;
0B3BBE E5          1566**  GETVA:			PUSH    HL
0B3BBF DD E1       1567**  			POP     IX
0B3BC1 7A          1568**  			LD      A,D            		; Fetch the variable type
0B3BC2 FE 81       1569**  			CP      129			; Is it a string?
0B3BC4 C8          1570**  			RET     Z               	; Yes, so exit here
0B3BC5 C5          1571**  			PUSH    BC
0B3BC6 CD 14 05 0B 1572**  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
0B3BCA CD 60 07 0B 1573**  			CALL    SFIX
0B3BCE 7D          1574**  			LD	A,L
0B3BCF D9          1575**  			EXX
0B3BD0 22 4A 4E 0B 1576**  			LD	(R0+0),HL
0B3BD4 32 4C 4E 0B 1577**  			LD	(R0+2),A
0B3BD8 2A 4A 4E 0B 1578**  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
0B3BDC             1579**  ;
0B3BDC E5          1580**  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
0B3BDD FD 23       1581**  			INC     IY
0B3BDF CD 23 04 0B 1582**  			CALL    ITEMI
0B3BE3 7D          1583**  			LD	A,L			;  A: The MSB of the address
0B3BE4 D9          1584**  			EXX
0B3BE5 22 4A 4E 0B 1585**  			LD	(R0+0),HL		; HL: The LSW of the address
0B3BE9 32 4C 4E 0B 1586**  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
0B3BED D1          1587**  			POP     DE
0B3BEE F1          1588**  			POP     AF
0B3BEF 2A 4A 4E 0B 1589**  			LD	HL,(R0)			; HL: L'HL
0B3BF3 19          1590**  			ADD     HL,DE
0B3BF4 E5          1591**  			PUSH    HL
0B3BF5 DD E1       1592**  			POP     IX
0B3BF7 BF          1593**  			CP      A
0B3BF8 C9          1594**  			RET
0B3BF9             1595**  ;
0B3BF9             1596**  ;GETDEF - Find entry for FN or PROC in dynamic area.
0B3BF9             1597**  ;   Inputs: IY addresses byte following "DEF" token.
0B3BF9             1598**  ;  Outputs: Z flag set if found
0B3BF9             1599**  ;           Carry set if neither FN or PROC first.
0B3BF9             1600**  ;           If Z: HL points to entry
0B3BF9             1601**  ;                 IY addresses delimiter
0B3BF9             1602**  ; Destroys: A,D,E,H,L,IY,F
0B3BF9             1603**  ;
0B3BF9 FD 7E 01    1604**  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
0B3BFC CD 79 3D 0B 1605**  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
0B3C00 D8          1606**  			RET     C			; No so return with C set
0B3C01 FD 7E 00    1607**  			LD      A,(IY)			; Fetch the current character from the tokenised line
0B3C04 21 0E 4E 0B 1608**  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
0B3C08 FE A4       1609**  			CP      FN			; Is it the token FN?
0B3C0A 28 4A       1610**  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3C0C 21 11 4E 0B 1611**  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
0B3C10 FE F2       1612**  			CP      PROC			; Is it the token PROC?
0B3C12 28 42       1613**  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3C14 37          1614**  			SCF				; No, so just return with C set
0B3C15 C9          1615**  			RET
0B3C16             1616**  ;
0B3C16             1617**  ; LOCATE - Try to locate variable name in static or dynamic variables.
0B3C16             1618**  ; If illegal first character return carry, non-zero.
0B3C16             1619**  ; If found, return no-carry, zero.
0B3C16             1620**  ; If not found, return no-carry, non-zero.
0B3C16             1621**  ;   Inputs: IY=Addresses first character of name.
0B3C16             1622**  ;            A=(IY)
0B3C16             1623**  ;  Outputs:  F=Z set if found, then:
0B3C16             1624**  ;           IY=addresses terminator
0B3C16             1625**  ;           HL=addresses location of variable
0B3C16             1626**  ;            D=type of variable: 4 = integer
0B3C16             1627**  ;                                5 = floating point
0B3C16             1628**  ;                              129 = string
0B3C16             1629**  ; Destroys: A,D,E,H,L,IY,F
0B3C16             1630**  ;
0B3C16             1631**  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
0B3C16             1632**  ; They can contain any alphanumeric character and underscore (_)
0B3C16             1633**  ; String variables are postfixed with the dollar ($) character
0B3C16             1634**  ; Integer variables are postfixed with the percent (%) character
0B3C16             1635**  ; Static integer variables are named @%, A% to Z%
0B3C16             1636**  ; All other variables are dynamic
0B3C16             1637**  ;
0B3C16 D6 40       1638**  LOCATE:			SUB     '@'			; Check for valid range
0B3C18 D8          1639**  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
0B3C19 21 00 00 00 1640**  			LD      HL, 0			; Clear HL
0B3C1D FE 1B       1641**  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
0B3C1F 30 1E       1642**  			JR      NC,LOC0         	; Then branch here
0B3C21 6F          1643**  			LD	L, A			; HL = A
0B3C22 FD 7E 01    1644**  			LD      A,(IY+1)        	; Check the 2nd character
0B3C25 FE 25       1645**  			CP      '%'			; If not "%" then it is not static...
0B3C27 20 21       1646**  			JR      NZ,LOC1         	; Branch here
0B3C29 FD 7E 02    1647**  			LD      A,(IY+2)		; Check the 3rd character
0B3C2C FE 28       1648**  			CP      '('			; If it is "(" (array) then it is not static...
0B3C2E 28 1A       1649**  			JR      Z,LOC1          	; Branch here
0B3C30             1650**  ;
0B3C30             1651**  ; At this point we're dealing with a static variable
0B3C30             1652**  ;
0B3C30 29          1653**  			ADD     HL,HL			; HL: Variable index * 4
0B3C31 29          1654**  			ADD	HL,HL
0B3C32 11 00 4D 0B 1655**  			LD      DE,STAVAR       	; The static variable area in memory
0B3C36 19          1656**  			ADD     HL,DE			; HL: The address of the static variable
0B3C37 FD 23       1657**  			INC     IY			; Skip the program pointer past the static variable name
0B3C39 FD 23       1658**  			INC     IY
0B3C3B 16 04       1659**  			LD      D,4             	; Set the type to be integer
0B3C3D AF          1660**  			XOR     A			; Set the Z flag
0B3C3E C9          1661**  			RET
0B3C3F             1662**  ;
0B3C3F             1663**  ; At this point it's potentially a dynamic variable, just need to do a few more checks
0B3C3F             1664**  ;
0B3C3F FE 1F       1665**  LOC0:			CP      '_'-'@'			; Check the first character is in
0B3C41 D8          1666**  			RET     C			; the range "_" to
0B3C42 FE 3B       1667**  			CP      'z'-'@'+1		; "z" (lowercase characters only)
0B3C44 3F          1668**  			CCF				; If it is not in range then
0B3C45 3D          1669**  			DEC     A               	; Set NZ flag and
0B3C46 D8          1670**  			RET     C			; Exit here
0B3C47 D6 03       1671**  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
0B3C49 6F          1672**  			LD	L, A			; HL = A
0B3C4A             1673**  ;
0B3C4A             1674**  ; Yes, it's definitely a dynamic variable at this point...
0B3C4A             1675**  ;
0B3C4A 7D          1676**  LOC1:			LD	A, L			; Fetch variable index
0B3C4B 87          1677**  			ADD	A, A			; x 2
0B3C4C 85          1678**  			ADD	A, L			; x 3
0B3C4D D6 03       1679**  			SUB	3			; Subtract 2 TODO: Should be 3
0B3C4F 6F          1680**  			LD	L, A
0B3C50 11 6C 4D 0B 1681**  			LD      DE, DYNVAR       	; The dynamic variable storage
0B3C54 D8          1682**  			RET	C			; Bounds check to trap for variable '@'
0B3C55 19          1683**  			ADD     HL, DE			; HL: Address of first entry
0B3C56             1684**  ;
0B3C56             1685**  ; Loop through the linked list of variables to find a match
0B3C56             1686**  ;
0B3C56 ED 17       1687**  LOC2:			LD	DE, (HL)		; Fetch the original pointer
0B3C58 E5          1688**  			PUSH	HL			; Need to preserve HL for LOC6
0B3C59 AF          1689**  			XOR	A			; Reset carry flag
0B3C5A ED 62       1690**  			SBC	HL, HL			; Set HL to 0
0B3C5C ED 52       1691**  			SBC	HL, DE			; Compare with 0
0B3C5E E1          1692**  			POP	HL			; Restore the original pointer
0B3C5F 28 49       1693**  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
0B3C61             1694**  			; LD	HL, DE			; Make a copy of this pointer in HL
0B3C61 D5          1695**  			push de
0B3C62 E1          1696**  			pop hl ; how was that even possible?
0B3C63 23          1697**  			INC     HL              	; Skip the link (24-bits)
0B3C64 23          1698**  			INC     HL
0B3C65 23          1699**  			INC	HL			; HL: Address of the variable name in DYNVARS
0B3C66 FD E5       1700**  			PUSH    IY			; IY: Address of the variable name in the program
0B3C68             1701**  ;
0B3C68 7E          1702**  LOC3:			LD      A,(HL)         		; Compare
0B3C69 23          1703**  			INC     HL
0B3C6A FD 23       1704**  			INC     IY
0B3C6C FD BE 00    1705**  			CP      (IY)
0B3C6F 28 F7       1706**  			JR      Z, LOC3			; Keep looping whilst we've got a match...
0B3C71 B7          1707**  			OR      A               	; Have we hit a terminator?
0B3C72 28 07       1708**  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
0B3C74             1709**  ;
0B3C74 FD E1       1710**  LOC4:			POP     IY			; Restore the pointer in the program
0B3C76 EB          1711**  			EX      DE, HL			; HL: New pointer in DYNVARS
0B3C77 C3 56 3C 0B 1712**  			JP      LOC2            	; Loop round and try again
0B3C7B             1713**  ;
0B3C7B             1714**  ; We might have located a variable at this point, just need to do a few more tests
0B3C7B             1715**  ;
0B3C7B FD 2B       1716**  LOC5:			DEC     IY
0B3C7D FD 7E 00    1717**  			LD      A,(IY)
0B3C80 FE 28       1718**  			CP      '('
0B3C82 28 15       1719**  			JR      Z,LOC5A         	; FOUND
0B3C84 FD 23       1720**  			INC     IY
0B3C86 CD 6D 3D 0B 1721**  			CALL    RANGE
0B3C8A 38 0D       1722**  			JR      C,LOC5A         	; FOUND
0B3C8C FE 28       1723**  			CP      '('
0B3C8E 28 E4       1724**  			JR      Z,LOC4          	; KEEP LOOKING
0B3C90 FD 7E FF    1725**  			LD      A,(IY-1)
0B3C93 CD 79 3D 0B 1726**  			CALL    RANGE1
0B3C97 30 DB       1727**  			JR      NC,LOC4         	; KEEP LOOKING
0B3C99 D1          1728**  LOC5A:			POP     DE
0B3C9A FD 7E FF    1729**  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
0B3C9D FE 24       1730**  			CP      '$'			; Is it a string?
0B3C9F 16 81       1731**  			LD      D,129			; Yes, so return D = 129
0B3CA1 C8          1732**  			RET     Z
0B3CA2 FE 25       1733**  			CP      '%'			; Is it an integer?
0B3CA4 16 04       1734**  			LD      D,4			; Yes, so return D = 4
0B3CA6 C8          1735**  			RET     Z
0B3CA7 14          1736**  			INC     D			; At this point it must be a float
0B3CA8 BF          1737**  			CP      A			; Set the flags
0B3CA9 C9          1738**  			RET
0B3CAA             1739**  ;
0B3CAA             1740**  ; The variable is undefined at this point; HL will be zero
0B3CAA             1741**  ;
0B3CAA 3C          1742**  LOC6:			INC     A               	; Set NZ flag
0B3CAB C9          1743**  			RET
0B3CAC             1744**  ;
0B3CAC             1745**  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
0B3CAC             1746**  ;   Inputs: HL, IY as returned from LOCATE (NZ).
0B3CAC             1747**  ;  Outputs: As LOCATE, GETDEF.
0B3CAC             1748**  ; Destroys: As LOCATE, GETDEF.
0B3CAC             1749**  ;
0B3CAC AF          1750**  CREATE:			XOR     A
0B3CAD ED 5B 1D 4E 1751**  			LD      DE,(FREE)		; Get the last byte of available RAM
       0B          
0B3CB2 ED 1F       1752**  			LD	(HL), DE		; Store
0B3CB4 EB          1753**  			EX      DE,HL
0B3CB5 77          1754**  			LD      (HL),A			; Clear the link of the new entity
0B3CB6 23          1755**  			INC     HL
0B3CB7 77          1756**  			LD      (HL),A
0B3CB8 23          1757**  			INC     HL
0B3CB9 77          1758**  			LD      (HL),A
0B3CBA 23          1759**  			INC     HL
0B3CBB FD 23       1760**  LOC7:			INC     IY
0B3CBD CD 6D 3D 0B 1761**  			CALL    RANGE           	; END OF VARIABLE?
0B3CC1 38 15       1762**  			JR      C,LOC8
0B3CC3 77          1763**  			LD      (HL),A
0B3CC4 23          1764**  			INC     HL
0B3CC5 CD 79 3D 0B 1765**  			CALL    RANGE1
0B3CC9 30 F0       1766**  			JR      NC,LOC7
0B3CCB FE 28       1767**  			CP      '('
0B3CCD 28 09       1768**  			JR      Z,LOC8
0B3CCF FD 7E 01    1769**  			LD      A,(IY+1)
0B3CD2 FE 28       1770**  			CP      '('
0B3CD4 28 E5       1771**  			JR      Z,LOC7
0B3CD6 FD 23       1772**  			INC     IY
0B3CD8 36 00       1773**  LOC8:			LD      (HL),0          	; TERMINATOR
0B3CDA 23          1774**  			INC     HL
0B3CDB E5          1775**  			PUSH    HL
0B3CDC CD 9A 3C 0B 1776**  			CALL    TYPE_			; Get the variable type in D
0B3CE0 3E 04       1777**  			LD      A,4			; If it is an integer then it takes up 4 bytes
0B3CE2 BA          1778**  			CP      D
0B3CE3 28 01       1779**  			JR      Z,LOC9			; So skip the next bit
0B3CE5 3C          1780**  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0B3CE6 36 00       1781**  LOC9:			LD      (HL),0          	; Initialise the memory to zero
0B3CE8 23          1782**  			INC     HL
0B3CE9 3D          1783**  			DEC     A
0B3CEA 20 FA       1784**  			JR      NZ,LOC9
0B3CEC 22 1D 4E 0B 1785**  			LD      (FREE),HL		; Adjust the stack
0B3CF0 CD 4D 17 0B 1786**  			CALL    CHECK			; Check whether we are out of space
0B3CF4 E1          1787**  			POP     HL
0B3CF5 AF          1788**  			XOR     A
0B3CF6 C9          1789**  			RET
0B3CF7             1790**  ;
0B3CF7             1791**  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
0B3CF7             1792**  ;   Inputs: IY = Text Pointer
0B3CF7             1793**  ;  Outputs: HL = Line number (zero if none)
0B3CF7             1794**  ;           IY updated
0B3CF7             1795**  ; Destroys: A,D,E,H,L,IY,F
0B3CF7             1796**  ;
0B3CF7             1797**  ; This bit of code performs a BASE 10 shift to build up the number
0B3CF7             1798**  ; So if the string passed is "345", the algorithm does this:
0B3CF7             1799**  ;
0B3CF7             1800**  ;    HL : Digit	: Operation
0B3CF7             1801**  ; ----- : ----- : ---------
0B3CF7             1802**  ; 00000 :	:
0B3CF7             1803**  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
0B3CF7             1804**  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
0B3CF7             1805**  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
0B3CF7             1806**  ;
0B3CF7             1807**  ; The multiply by 10 is done by an unrolled shift and add loop
0B3CF7             1808**  ;
0B3CF7 CD 6E 0B 0B 1809**  LINNUM:			CALL    NXT			; Skip whitespace to the first character
0B3CFB 40 21 00 00 1810**  			LD.SIS  HL,0			; The running total
0B3CFF FD 7E 00    1811**  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
0B3D02 D6 30       1812**  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
0B3D04 D8          1813**  			RET     C			; And return if less than 0
0B3D05 FE 0A       1814**  			CP      10			; Or greater than or equal to 10
0B3D07 D0          1815**  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
0B3D08 FD 23       1816**  			INC     IY			; Increment the string pointer
0B3D0A 54          1817**  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
0B3D0B 5D          1818**  			LD      E,L			; Store the original number in DE
0B3D0C 52 29       1819**  			ADD.S   HL,HL           	; *2
0B3D0E 38 13       1820**  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
0B3D10 52 29       1821**  			ADD.S   HL,HL           	; *4S
0B3D12 38 0F       1822**  			JR      C,TOOBIG
0B3D14 52 19       1823**  			ADD.S   HL,DE           	; *5
0B3D16 38 0B       1824**  			JR      C,TOOBIG
0B3D18 52 29       1825**  			ADD.S   HL,HL           	; *10
0B3D1A 38 07       1826**  			JR      C,TOOBIG
0B3D1C 5F          1827**  			LD      E,A			; A->DE: the digit to add in
0B3D1D 16 00       1828**  			LD      D,0
0B3D1F 52 19       1829**  			ADD.S   HL,DE           	; Add in the digit to the running total
0B3D21 30 DC       1830**  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
0B3D23             1831**  ;
0B3D23 3E 14       1832**  TOOBIG:			LD      A,20
0B3D25 C3 5E 38 0B 1833**  			JP      ERROR_           	; Error: "Too big"
0B3D29             1834**  ;
0B3D29             1835**  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
0B3D29             1836**  ;   Inputs: IY = text pointer
0B3D29             1837**  ;  Outputs: HL = first number (10 by default)
0B3D29             1838**  ;           BC = second number (10 by default)
0B3D29             1839**  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
0B3D29             1840**  ;
0B3D29 CD F7 3C 0B 1841**  PAIR:			CALL    LINNUM          	; Parse the first line number
0B3D2D 7C          1842**  			LD      A,H			; If it is not zero, then...
0B3D2E B5          1843**  			OR      L
0B3D2F 20 02       1844**  			JR      NZ,PAIR1		; Skip...
0B3D31 2E 0A       1845**  			LD      L,10			; HL: the default value (10)
0B3D33             1846**  ;
0B3D33 CD 78 18 0B 1847**  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
0B3D37 FD 23       1848**  			INC     IY			; Skip to next character
0B3D39 E5          1849**  			PUSH    HL			; Stack the first line number
0B3D3A 21 0A 00 00 1850**  			LD      HL,10			; HL: the second default (10)
0B3D3E C4 F7 3C 0B 1851**  			CALL    NZ,LINNUM       	; Parse the second line number
0B3D42 E3          1852**  			EX      (SP),HL			; HL: The first line number (off the stack)
0B3D43 C1          1853**  			POP     BC			; BC: Second line number
0B3D44 78          1854**  			LD      A,B			; If the second line number is not zero then...
0B3D45 B1          1855**  			OR      C			; We're good...
0B3D46 C0          1856**  			RET     NZ			; Exit, otherwise...
0B3D47 CD 75 38 0B 1857**  			CALL    EXTERR			; Throw error: "Silly"
0B3D4B 53 69 6C 6C 1858**  			DB    	"Silly", 0
       79 00       
0B3D51             1859**  ;
0B3D51             1860**  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
0B3D51             1861**  ;   Inputs: IY = text pointer
0B3D51             1862**  ;  Outputs: HL = points to program text
0B3D51             1863**  ;           BC = second number (0 by default)
0B3D51             1864**  ; Destroys: A,B,C,D,E,H,L,IY,F
0B3D51             1865**  ;
0B3D51 CD F7 3C 0B 1866**  DLPAIR:			CALL    LINNUM			; Parse the first line number
0B3D55 E5          1867**  			PUSH    HL			; Stack it
0B3D56 CD 78 18 0B 1868**  			CALL    TERMQ			; Check for ELSE, : or CR
0B3D5A 28 0A       1869**  			JR      Z,DLP1			; And exit if so
0B3D5C FE E7       1870**  			CP      TIF			; Is the token IF?
0B3D5E 28 06       1871**  			JR      Z,DLP1			; Yes, so skip the next bit...
0B3D60 FD 23       1872**  			INC     IY			; Otherwise...
0B3D62 CD F7 3C 0B 1873**  			CALL    LINNUM			; Fetch the second line number
0B3D66 E3          1874**  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
0B3D67 CD 8D 3A 0B 1875**  			CALL    FINDL			; HL: Find the address of the line
0B3D6B C1          1876**  			POP     BC			; BC: The second number
0B3D6C C9          1877**  			RET
0B3D6D             1878**  ;
0B3D6D             1879**  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
0B3D6D             1880**  ;   Inputs: IY addresses character
0B3D6D             1881**  ;  Outputs: Carry set if out-of-range.
0B3D6D             1882**  ; Destroys: A,F
0B3D6D             1883**  ;
0B3D6D             1884**  ; It is called here to check the following
0B3D6D             1885**  ; In range: "$", "%" and "("
0B3D6D             1886**  ;   Plus all characters in RANGE1 and RANGE2
0B3D6D             1887**  ;
0B3D6D FD 7E 00    1888**  RANGE:			LD      A,(IY)			; Fetch the character
0B3D70 FE 24       1889**  			CP      '$'			; Postfix for string variable is valid
0B3D72 C8          1890**  			RET     Z
0B3D73 FE 25       1891**  			CP      '%'			; Postfix for integer variable is valid
0B3D75 C8          1892**  			RET     Z
0B3D76 FE 28       1893**  			CP      '('			; Postfix for array is valid
0B3D78 C8          1894**  			RET     Z
0B3D79             1895**  ;
0B3D79             1896**  ; It is called here to check the following
0B3D79             1897**  ; In range: "0" to "9" and "@"
0B3D79             1898**  ;   Plus all characters in RANGE2
0B3D79             1899**  ;
0B3D79 FE 30       1900**  RANGE1:			CP      '0'			; If it is between '0'...
0B3D7B D8          1901**  			RET     C
0B3D7C FE 3A       1902**  			CP      '9'+1			; And '9'...
0B3D7E 3F          1903**  			CCF
0B3D7F D0          1904**  			RET     NC			; Then it is valid
0B3D80 FE 40       1905**  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
0B3D82 C8          1906**  			RET     Z
0B3D83             1907**  ;
0B3D83             1908**  ; It is called here to check the following
0B3D83             1909**  ; In range: "A" to "Z", "a' to "z", "_" and "`"
0B3D83             1910**  ;
0B3D83 FE 41       1911**  RANGE2:			CP      'A'			; If it is between 'A'...
0B3D85 D8          1912**  			RET     C
0B3D86 FE 5B       1913**  			CP      'Z'+1			; And 'Z'...
0B3D88 3F          1914**  			CCF
0B3D89 D0          1915**  			RET     NC			; Then it is valid
0B3D8A FE 5F       1916**  			CP      '_'			; If it is underscore, grave, or between 'a'
0B3D8C D8          1917**  			RET     C
0B3D8D FE 7B       1918**  			CP      'z'+1			; And 'z'
0B3D8F 3F          1919**  			CCF				; Then it is valid
0B3D90 C9          1920**  			RET
0B3D91             1921**  ;
0B3D91             1922**  ; Throw a 'LINE space' error (line too long)
0B3D91             1923**  ; This is called from LEXAN
0B3D91             1924**  ;
0B3D91 AF          1925**  SPACE_: 		XOR     A
0B3D92 CD 75 38 0B 1926**  			CALL    EXTERR          	; "LINE space"
0B3D96 86 08 00    1927**  			DB    	LINE_MN_, 8, 0
0B3D99             1928**  ;
0B3D99             1929**  ; LEXAN - LEXICAL ANALYSIS.
0B3D99             1930**  ;  Bit 0,C: 1=left, 0=right
0B3D99             1931**  ;  Bit 2,C: 1=in BINARY
0B3D99             1932**  ;  Bit 3,C: 1=in HEX
0B3D99             1933**  ;  Bit 4,C: 1=accept line number
0B3D99             1934**  ;  Bit 5,C: 1=in variable, FN, PROC
0B3D99             1935**  ;  Bit 6,C: 1=in REM, DATA, *
0B3D99             1936**  ;  Bit 7,C: 1=in quotes
0B3D99             1937**  ;   Inputs: IY addresses source string
0B3D99             1938**  ;           DE addresses destination string (must be page boundary)
0B3D99             1939**  ;            C sets initial mode
0B3D99             1940**  ;  Outputs: DE, IY updated
0B3D99             1941**  ;            A holds carriage return
0B3D99             1942**  ;
0B3D99 12          1943**  LEXAN1:			LD      (DE),A          	; Transfer to buffer
0B3D9A 13          1944**  			INC     DE              	; Increment the pointers
0B3D9B FD 23       1945**  			INC     IY			; And fall through to the main function
0B3D9D             1946**  ;
0B3D9D             1947**  ; This is the main entry point
0B3D9D             1948**  ;
0B3D9D 7B          1949**  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
0B3D9E FE FC       1950**  			CP      252             	; If it is >= 252 bytes, then...
0B3DA0 30 EF       1951**  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0B3DA2 FD 7E 00    1952**  			LD      A,(IY)			; Fetch character from source string
0B3DA5 FE 0D       1953**  			CP      CR			; If it is a CR
0B3DA7 C8          1954**  			RET     Z               	; Then it is end of line; we're done parsing
0B3DA8 CD 79 3D 0B 1955**  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B3DAC 30 06       1956**  			JR      NC,LEXAN3		; Yes, so skip
0B3DAE CB A9       1957**  			RES     5,C             	; FLAG: NOT IN VARIABLE
0B3DB0 CB 99       1958**  			RES     3,C             	; FLAG: NOT IN HEX
0B3DB2 CB 91       1959**  			RES	2,C			; FLAG: NOT IN BINARY
0B3DB4             1960**  ;
0B3DB4 FE 20       1961**  LEXAN3:			CP      ' '			; Ignore spaces
0B3DB6 28 E1       1962**  			JR      Z,LEXAN1
0B3DB8 FE 2C       1963**  			CP      ','			; Ignore commas
0B3DBA 28 DD       1964**  			JR      Z,LEXAN1
0B3DBC FE 32       1965**  			CP	'2'			; If less than '2'
0B3DBE 30 02       1966**  			JR	NC, @F			; No, so skip
0B3DC0 CB 91       1967**  			RES	2,C			; FLAG: NOT IN BINARY
0B3DC2 FE 47       1968**  @@:			CP      'G'			; If less then 'G'
0B3DC4 38 02       1969**  			JR      C,LEXAN4		; Yes, so skip
0B3DC6 CB 99       1970**  			RES     3,C             	; FLAG: NOT IN HEX
0B3DC8             1971**  ;
0B3DC8 FE 22       1972**  LEXAN4:			CP      34			; Is it a quote character?
0B3DCA 20 05       1973**  			JR      NZ,LEXAN5		; No, so skip
0B3DCC CB 11       1974**  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
0B3DCE 3F          1975**  			CCF                     	; Toggle the carry
0B3DCF CB 19       1976**  			RR      C			; And then shifting it back into bit 7 of C
0B3DD1             1977**  ;
0B3DD1 CB 61       1978**  LEXAN5:			BIT     4,C			; Accept line number?
0B3DD3 28 12       1979**  			JR      Z,LEXAN6		; No, so skip
0B3DD5 CB A1       1980**  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
0B3DD7 C5          1981**  			PUSH    BC
0B3DD8 D5          1982**  			PUSH    DE
0B3DD9 CD F7 3C 0B 1983**  			CALL    LINNUM         		; Parse the line number to HL
0B3DDD D1          1984**  			POP     DE
0B3DDE C1          1985**  			POP     BC
0B3DDF 7C          1986**  			LD      A,H			; If it is not zero
0B3DE0 B5          1987**  			OR      L
0B3DE1 C4 5A 3E 0B 1988**  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
0B3DE5 18 B6       1989**  			JR      LEXAN2          	; And loop
0B3DE7             1990**  ;
0B3DE7 0D          1991**  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0B3DE8 28 0A       1992**  			JR      Z,LEXAN7        	; If so, skip
0B3DEA 0C          1993**  			INC     C			; Otherwise restore C
0B3DEB 20 AC       1994**  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0B3DED B7          1995**  			OR      A			; Set the flags based on the character
0B3DEE F4 C5 38 0B 1996**  			CALL    P,LEX           	; Tokenise if A < 128
0B3DF2 18 13       1997**  			JR      LEXAN8			; And skip
0B3DF4             1998**  ;
0B3DF4             1999**  ; Processing the LEFT hand side here
0B3DF4             2000**  ;
0B3DF4 FE 2A       2001**  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0B3DF6 28 17       2002**  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0B3DF8 B7          2003**  			OR      A			; Set the flags based on the character
0B3DF9 F4 C5 38 0B 2004**  			CALL    P,LEX           	; Tokenise if A < 128
0B3DFD             2005**  ;
0B3DFD             2006**  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
0B3DFD             2007**  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
0B3DFD             2008**  ; Examples:
0B3DFD             2009**  ;   LET A% = PAGE : REM This is the GET version
0B3DFD             2010**  ;   PAGE = 40000  : REM This is the SET version
0B3DFD             2011**  ;
0B3DFD FE 8F       2012**  			CP      TOKLO			; TOKLO is 8Fh
0B3DFF 38 06       2013**  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
0B3E01 FE 94       2014**  			CP      TOKHI+1			; TOKHI is 93h
0B3E03 30 02       2015**  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
0B3E05 C6 40       2016**  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
0B3E07             2017**  ;
0B3E07 FE F4       2018**  LEXAN8:			CP      REM			; If the token is REM
0B3E09 28 04       2019**  			JR      Z,LEXAN9		; Then stop tokenising
0B3E0B FE DC       2020**  			CP      DATA_MN_			; If it is not DATA then
0B3E0D 20 02       2021**  			JR      NZ,LEXANA		; Skip
0B3E0F CB F1       2022**  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
0B3E11             2023**  ;
0B3E11 FE A4       2024**  LEXANA:			CP      FN			; If the token is FN
0B3E13 28 0A       2025**  			JR      Z,LEXANB
0B3E15 FE F2       2026**  			CP      PROC			; Or the token is PROC
0B3E17 28 06       2027**  			JR      Z,LEXANB		; Then jump to here
0B3E19 CD 83 3D 0B 2028**  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
0B3E1D 38 02       2029**  			JR      C,LEXANC		; Jump here if out of range
0B3E1F             2030**  ;
0B3E1F CB E9       2031**  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
0B3E21 FE 26       2032**  LEXANC:			CP      '&'			; Check for hex prefix
0B3E23 20 02       2033**  			JR      NZ,LEXAND		; If not, skip
0B3E25 CB D9       2034**  			SET     3,C             	; FLAG: IN HEX
0B3E27             2035**  ;
0B3E27 FE 25       2036**  LEXAND:			CP	'%'			; Check for binary prefix
0B3E29 20 02       2037**  			JR	NZ,LEXANE		; If not, skip
0B3E2B CB D1       2038**  			SET	2,C			; FLAG: IN BINARY
0B3E2D             2039**  ;
0B3E2D 21 51 3E 0B 2040**  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
0B3E31 C5          2041**  			PUSH    BC
0B3E32 01 06 00 00 2042**  			LD      BC,LIST1L		; The list length
0B3E36 ED B1       2043**  			CPIR				; Check if the token is in this list
0B3E38 C1          2044**  			POP     BC
0B3E39 20 02       2045**  			JR      NZ,LEXANF		; If not, then skip
0B3E3B CB E1       2046**  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
0B3E3D             2047**  ;
0B3E3D 21 55 3E 0B 2048**  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
0B3E41 C5          2049**  			PUSH    BC
0B3E42 01 05 00 00 2050**  			LD      BC,LIST2L		; The list length
0B3E46 ED B1       2051**  			CPIR				; Check if the token is in this list
0B3E48 C1          2052**  			POP     BC
0B3E49 20 02       2053**  			JR      NZ,LEXANG		; If not, then skip
0B3E4B CB C1       2054**  			SET     0,C             	; FLAG: ENTER LEFT MODE
0B3E4D C3 99 3D 0B 2055**  LEXANG:			JP      LEXAN1			; And loop
0B3E51             2056**  
0B3E51             2057**  ;
0B3E51             2058**  ; LIST1: List of tokens that must be followed by line numbers
0B3E51             2059**  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
0B3E51             2060**  ;
0B3E51 E5          2061**  LIST1:			DB	GOTO
0B3E52 E4          2062**  			DB	GOSUB
0B3E53 F7          2063**  			DB	RESTOR
0B3E54 FC          2064**  			DB	TRACE
0B3E55 8C          2065**  LIST2:			DB	THEN_MN_
0B3E56 8B          2066**  			DB	ELSE_MN_
0B3E57             2067**  LIST1L:			EQU     $-LIST1
0B3E57 F5          2068**  			DB	REPEAT
0B3E58 85          2069**  			DB	TERROR_MN
0B3E59 3A          2070**  			DB    	':'
0B3E5A             2071**  LIST2L:			EQU     $-LIST2
0B3E5A             2072**  ;
0B3E5A             2073**  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
0B3E5A             2074**  ;   Inputs: HL=line number, DE=string pointer
0B3E5A             2075**  ;  Outputs: DE updated, BIT 4,C set.
0B3E5A             2076**  ; Destroys: A,B,C,D,E,F
0B3E5A             2077**  ;
0B3E5A             2078**  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
0B3E5A             2079**  ;
0B3E5A             2080**  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
0B3E5A             2081**  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
0B3E5A             2082**  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
0B3E5A             2083**  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
0B3E5A             2084**  ; each byte are then stored, in LO/HI order, ORred with 0x40.
0B3E5A             2085**  ;
0B3E5A CB E1       2086**  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
0B3E5C EB          2087**  			EX      DE, HL			; HL: string pointer, DE: line number
0B3E5D 36 8D       2088**  			LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
0B3E5F 23          2089**  			INC     HL
0B3E60 7A          2090**  			LD      A,D			; Get the high byte
0B3E61 E6 C0       2091**  			AND     0C0H			; Get the top two bits	DD000000
0B3E63 0F          2092**  			RRCA				; Shift right		00DD0000
0B3E64 0F          2093**  			RRCA
0B3E65 47          2094**  			LD      B,A			; Store in B
0B3E66 7B          2095**  			LD      A,E			; Get the low byte
0B3E67 E6 C0       2096**  			AND     0C0H			; Get the top two bits	EE000000
0B3E69 B0          2097**  			OR      B			; Combine with D	EEDD0000
0B3E6A 0F          2098**  			RRCA				; Shift right		00EEDD00
0B3E6B 0F          2099**  			RRCA
0B3E6C EE 54       2100**  			XOR     01010100B		; XOR with 54h
0B3E6E 77          2101**  			LD      (HL),A			; Store this as the second byte
0B3E6F 23          2102**  			INC     HL
0B3E70 7B          2103**  			LD      A,E			; Get the low byte
0B3E71 E6 3F       2104**  			AND     3FH			; Strip the top two bits off
0B3E73 F6 40       2105**  			OR      '@'			; OR with 40h
0B3E75 77          2106**  			LD      (HL),A			; Store
0B3E76 23          2107**  			INC     HL
0B3E77 7A          2108**  			LD      A,D			; Get the high byte
0B3E78 E6 3F       2109**  			AND     3FH			; Strip the top two bits off
0B3E7A F6 40       2110**  			OR      '@'			; OR with 40h
0B3E7C 77          2111**  			LD      (HL),A			; Store
0B3E7D 23          2112**  			INC     HL
0B3E7E EB          2113**  			EX      DE,HL			; DE: string pointer, HL: line number
0B3E7F C9          2114**  			RET
0B3E80             2115**  ;
0B3E80             2116**  ; TEXT - OUTPUT MESSAGE.
0B3E80             2117**  ;   Inputs: HL addresses text (terminated by nul)
0B3E80             2118**  ;  Outputs: HL addresses character following nul.
0B3E80             2119**  ; Destroys: A,H,L,F
0B3E80             2120**  ;
0B3E80 2A 2F 4E 0B 2121**  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
0B3E84             2122**  ;
0B3E84 7E          2123**  TEXT_:			LD      A, (HL)			; Fetch the character
0B3E85 23          2124**  			INC     HL			; Increment pointer to next character
0B3E86 B7          2125**  			OR      A			; Check for the nul (0) string terminator
0B3E87 C8          2126**  			RET     Z			; And return if so
0B3E88 CD 6A 3A 0B 2127**  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
0B3E8C 18 F6       2128**  			JR      TEXT_			; And loop
0B3E8E             2129**  ;
0B3E8E             2130**  ; TELL - OUTPUT MESSAGE.
0B3E8E             2131**  ;   Inputs: Text follows subroutine call (term=nul)
0B3E8E             2132**  ; Destroys: A,F
0B3E8E             2133**  ;
0B3E8E             2134**  ; Example usage:
0B3E8E             2135**  ;
0B3E8E             2136**  ;	CALL	TELL			Call the function
0B3E8E             2137**  ;	DB	"Hello World", 0	Followed by a zero terminated string
0B3E8E             2138**  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
0B3E8E             2139**  ;
0B3E8E E3          2140**  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
0B3E8F CD 84 3E 0B 2141**  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
0B3E93 E3          2142**  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
0B3E94 C9          2143**  			RET				; at this point we'll return to the first instruction after the message
0B3E95             0010*       include "basic/misc.asm"
0B3E95             0001**  ;
0B3E95             0002**  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
0B3E95             0003**  ; Author:	Dean Belfield
0B3E95             0004**  ; Created:	12/05/2023
0B3E95             0005**  ; Last Updated:	12/05/2023
0B3E95             0006**  ;
0B3E95             0007**  ; Modinfo:
0B3E95             0008**  
0B3E95             0009**  			; INCLUDE	"equs.inc"
0B3E95             0010**  			; INCLUDE	"macros.inc"
0B3E95             0011**  
0B3E95             0012**  			; .ASSUME	ADL = 1
0B3E95             0013**  
0B3E95             0014**  			; SEGMENT CODE
0B3E95             0015**  
0B3E95             0016**  			; XDEF	ASC_TO_NUMBER
0B3E95             0017**  			; XDEF	SWITCH_A
0B3E95             0018**  			; XDEF	NULLTOCR
0B3E95             0019**  			; XDEF	CRTONULL
0B3E95             0020**  			; XDEF	CSTR_FNAME
0B3E95             0021**  			; XDEF	CSTR_LINE
0B3E95             0022**  			; XDEF	CSTR_FINDCH
0B3E95             0023**  			; XDEF	CSTR_ENDSWITH
0B3E95             0024**  			; XDEF	CSTR_CAT
0B3E95             0025**  
0B3E95             0026**  			; XREF	OSWRCH
0B3E95             0027**  			; XREF	KEYWDS
0B3E95             0028**  			; XREF	KEYWDL
0B3E95             0029**  
0B3E95             0030**  ; Read a number and convert to binary
0B3E95             0031**  ; If prefixed with &, will read as hex, otherwise decimal
0B3E95             0032**  ;   Inputs: HL: Pointer in string buffer
0B3E95             0033**  ;  Outputs: HL: Updated text pointer
0B3E95             0034**  ;           DE: Value
0B3E95             0035**  ;            A: Terminator (spaces skipped)
0B3E95             0036**  ; Destroys: A,D,E,H,L,F
0B3E95             0037**  ;
0B3E95 C5          0038**  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0B3E96 11 00 00 00 0039**  			LD	DE, 0			; Initialise DE
0B3E9A CD DC 3E 0B 0040**  			CALL	SKIPSPC			; Skip whitespace
0B3E9E 7E          0041**  			LD	A, (HL)			; Read first character
0B3E9F FE 26       0042**  			CP	'&'			; Is it prefixed with '&' (HEX number)?
0B3EA1 20 1F       0043**  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B3EA3 23          0044**  			INC	HL			; Otherwise fall through to ASC_TO_HEX
0B3EA4             0045**  ;
0B3EA4 7E          0046**  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0B3EA5 CD EA 3E 0B 0047**  			CALL    UPPERC			; Convert to uppercase
0B3EA9 D6 30       0048**  			SUB	'0'			; Normalise to 0
0B3EAB 38 2E       0049**  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B3EAD FE 0A       0050**  			CP 	10			; Check if >= 10
0B3EAF 38 06       0051**  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0B3EB1 D6 07       0052**  			SUB 	7			; Adjust ASCII A-F to nibble
0B3EB3 FE 10       0053**  			CP 	16			; Check for > F
0B3EB5 30 24       0054**  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0B3EB7 EB          0055**  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0B3EB8 29          0056**  			ADD	HL, HL
0B3EB9 29          0057**  			ADD	HL, HL
0B3EBA 29          0058**  			ADD	HL, HL
0B3EBB 29          0059**  			ADD	HL, HL
0B3EBC EB          0060**  			EX	DE, HL
0B3EBD B3          0061**  			OR      E			; OR the new digit in to the least significant nibble
0B3EBE 5F          0062**  			LD      E, A
0B3EBF 23          0063**  			INC     HL			; Onto the next character
0B3EC0 18 E2       0064**  			JR      ASC_TO_NUMBER1		; And loop
0B3EC2             0065**  ;
0B3EC2 7E          0066**  ASC_TO_NUMBER3:		LD	A, (HL)
0B3EC3 D6 30       0067**  			SUB	'0'			; Normalise to 0
0B3EC5 38 14       0068**  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B3EC7 FE 0A       0069**  			CP	10			; Check if >= 10
0B3EC9 30 10       0070**  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0B3ECB EB          0071**  			EX 	DE, HL 			; Stick DE in HL
0B3ECC 44          0072**  			LD	B, H 			; And copy HL into BC
0B3ECD 4D          0073**  			LD	C, L
0B3ECE 29          0074**  			ADD	HL, HL 			; x 2
0B3ECF 29          0075**  			ADD	HL, HL 			; x 4
0B3ED0 09          0076**  			ADD	HL, BC 			; x 5
0B3ED1 29          0077**  			ADD	HL, HL 			; x 10
0B3ED2 EB          0078**  			EX	DE, HL
0B3ED3             0079**  			ADD8U_DE 			; Add A to DE (macro)
0B3ED3 83          0001**M 		ADD	A, E
0B3ED4 5F          0002**M 		LD	E, A
0B3ED5 8A          0003**M 		ADC	A, D
0B3ED6 93          0004**M 		SUB	E
0B3ED7 57          0005**M 		LD	D, A
0B3ED8 23          0080**  			INC	HL
0B3ED9 18 E7       0081**  			JR	ASC_TO_NUMBER3
0B3EDB C1          0082**  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
0B3EDC             0083**  
0B3EDC             0084**  ; Skip a space
0B3EDC             0085**  ; HL: Pointer in string buffer
0B3EDC             0086**  ;
0B3EDC 7E          0087**  SKIPSPC:			LD      A, (HL)
0B3EDD FE 20       0088**  			CP      ' '
0B3EDF C0          0089**  			RET     NZ
0B3EE0 23          0090**  			INC     HL
0B3EE1 18 F9       0091**  			JR      SKIPSPC
0B3EE3             0092**  
0B3EE3             0093**  ; Skip a string
0B3EE3             0094**  ; HL: Pointer in string buffer
0B3EE3             0095**  ;
0B3EE3 7E          0096**  SKIPNOTSP:		LD	A, (HL)
0B3EE4 FE 20       0097**  			CP	' '
0B3EE6 C8          0098**  			RET	Z
0B3EE7 23          0099**  			INC	HL
0B3EE8 18 F9       0100**  			JR	SKIPNOTSP
0B3EEA             0101**  
0B3EEA             0102**  ; Convert a character to upper case
0B3EEA             0103**  ;  A: Character to convert
0B3EEA             0104**  ;
0B3EEA E6 7F       0105**  UPPERC:  		AND     7FH
0B3EEC FE 60       0106**  			CP      '`'
0B3EEE D8          0107**  			RET     C
0B3EEF E6 5F       0108**  			AND     5FH			; Convert to upper case
0B3EF1 C9          0109**  			RET
0B3EF2             0110**  
0B3EF2             0111**  ; Switch on A - lookup table immediately after call
0B3EF2             0112**  ;  A: Index into lookup table
0B3EF2             0113**  ;
0B3EF2 E3          0114**  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
0B3EF3 87          0115**  			ADD	A, A			; Multiply A by two
0B3EF4             0116**  			ADD8U_HL 			; Add to HL (macro)
0B3EF4 85          0001**M 		ADD	A, L
0B3EF5 6F          0002**M 		LD	L, A
0B3EF6 8C          0003**M 		ADC	A, H
0B3EF7 95          0004**M 		SUB	L
0B3EF8 67          0005**M 		LD	H, A
0B3EF9 7E          0117**  			LD	A, (HL)			; follow the call. Fetch an address from the
0B3EFA 23          0118**  			INC	HL 			; table.
0B3EFB 66          0119**  			LD	H, (HL)
0B3EFC 6F          0120**  			LD	L, A
0B3EFD E3          0121**  			EX	(SP), HL		; Swap this new address back, restores HL
0B3EFE C9          0122**  			RET				; Return program control to this new address
0B3EFF             0123**  
0B3EFF             0124**  ; Convert the buffer to a null terminated string and back
0B3EFF             0125**  ; HL: Buffer address
0B3EFF             0126**  ;
0B3EFF C5          0127**  NULLTOCR:		PUSH 	BC
0B3F00 06 00       0128**  			LD	B, 0
0B3F02 0E 0D       0129**  			LD	C, CR
0B3F04 18 05       0130**  			JR	CRTONULL0
0B3F06             0131**  ;
0B3F06 C5          0132**  CRTONULL:		PUSH	BC
0B3F07 06 0D       0133**  			LD	B, CR
0B3F09 0E 00       0134**  			LD	C, 0
0B3F0B             0135**  ;
0B3F0B E5          0136**  CRTONULL0:		PUSH	HL
0B3F0C 7E          0137**  CRTONULL1:		LD	A, (HL)
0B3F0D B8          0138**  			CP 	B
0B3F0E 28 03       0139**  			JR	Z, CRTONULL2
0B3F10 23          0140**  			INC	HL
0B3F11 18 F9       0141**  			JR	CRTONULL1
0B3F13 71          0142**  CRTONULL2:		LD	(HL), C
0B3F14 E1          0143**  			POP 	HL
0B3F15 C1          0144**  			POP	BC
0B3F16 C9          0145**  			RET
0B3F17             0146**  
0B3F17             0147**  ; Copy a filename to DE and zero terminate it
0B3F17             0148**  ; HL: Source
0B3F17             0149**  ; DE: Destination (ACCS)
0B3F17             0150**  ;
0B3F17 7E          0151**  CSTR_FNAME:		LD	A, (HL)			; Get source
0B3F18 FE 20       0152**  			CP	32			; Is it space
0B3F1A 28 09       0153**  			JR	Z, @F
0B3F1C FE 0D       0154**  			CP	CR			; Or is it CR
0B3F1E 28 05       0155**  			JR	Z, @F
0B3F20 12          0156**  			LD	(DE), A			; No, so store
0B3F21 23          0157**  			INC	HL			; Increment
0B3F22 13          0158**  			INC	DE
0B3F23 18 F2       0159**  			JR	CSTR_FNAME		; And loop
0B3F25 AF          0160**  @@:			XOR	A			; Zero terminate the target string
0B3F26 12          0161**  			LD	(DE), A
0B3F27 13          0162**  			INC	DE			; And point to next free address
0B3F28 C9          0163**  			RET
0B3F29             0164**  
0B3F29             0165**  ; Copy a CR terminated line to DE and zero terminate it
0B3F29             0166**  ; HL: Source
0B3F29             0167**  ; DE: Destination (ACCS)
0B3F29             0168**  ;
0B3F29 7E          0169**  CSTR_LINE:		LD	A, (HL)			; Get source
0B3F2A FE 0D       0170**  			CP	CR			; Is it CR
0B3F2C 28 05       0171**  			JR	Z, @F
0B3F2E 12          0172**  			LD	(DE), A			; No, so store
0B3F2F 23          0173**  			INC	HL			; Increment
0B3F30 13          0174**  			INC	DE
0B3F31 18 F6       0175**  			JR	CSTR_LINE		; And loop
0B3F33 AF          0176**  @@:			XOR	A			; Zero terminate the target string
0B3F34 12          0177**  			LD	(DE), A
0B3F35 13          0178**  			INC	DE			; And point to next free address
0B3F36 C9          0179**  			RET
0B3F37             0180**  
0B3F37             0181**  ; Find the first occurrence of a character (case sensitive)
0B3F37             0182**  ; HL: Source
0B3F37             0183**  ;  C: Character to find
0B3F37             0184**  ; Returns:
0B3F37             0185**  ; HL: Pointer to character, or end of string marker
0B3F37             0186**  ;
0B3F37 7E          0187**  CSTR_FINDCH:		LD	A, (HL)			; Get source
0B3F38 B9          0188**  			CP	C			; Is it our character?
0B3F39 C8          0189**  			RET	Z			; Yes, so exit
0B3F3A B7          0190**  			OR	A			; Is it the end of string?
0B3F3B C8          0191**  			RET	Z			; Yes, so exit
0B3F3C 23          0192**  			INC	HL
0B3F3D 18 F8       0193**  			JR	CSTR_FINDCH
0B3F3F             0194**  
0B3F3F             0195**  ; Check whether a string ends with another string (case insensitive)
0B3F3F             0196**  ; HL: Source
0B3F3F             0197**  ; DE: The substring we want to test with
0B3F3F             0198**  ; Returns:
0B3F3F             0199**  ;  F: Z if HL ends with DE, otherwise NZ
0B3F3F             0200**  ;
0B3F3F 7E          0201**  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
0B3F40 CD EA 3E 0B 0202**  			CALL	UPPERC			; Convert to upper case
0B3F44 4F          0203**  			LD	C, A
0B3F45 1A          0204**  			LD	A, (DE)			; Get the substring byte
0B3F46 B9          0205**  			CP	C
0B3F47 C0          0206**  			RET	NZ			; Return NZ if at any point the strings don't match
0B3F48 B1          0207**  			OR	C			; Check whether both bytes are zero
0B3F49 C8          0208**  			RET	Z			; If so, return, as we have reached the end of both strings
0B3F4A 23          0209**  			INC	HL
0B3F4B 13          0210**  			INC	DE
0B3F4C 18 F1       0211**  			JR	CSTR_ENDSWITH		; And loop
0B3F4E             0212**  
0B3F4E             0213**  ; Concatenate a string onto the end of another string
0B3F4E             0214**  ; HL: Source
0B3F4E             0215**  ; DE: Second string
0B3F4E             0216**  ;
0B3F4E 7E          0217**  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
0B3F4F B7          0218**  			OR	A
0B3F50 28 03       0219**  			JR	Z, CSTR_CAT_1
0B3F52 23          0220**  			INC	HL
0B3F53 18 F9       0221**  			JR	CSTR_CAT
0B3F55             0222**  ;
0B3F55 1A          0223**  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
0B3F56 77          0224**  			LD	(HL), A
0B3F57 B7          0225**  			OR	A			; Check for end of string
0B3F58 C8          0226**  			RET	Z			; And return
0B3F59 23          0227**  			INC	HL
0B3F5A 13          0228**  			INC	DE
0B3F5B 18 F8       0229**  			JR	CSTR_CAT_1		; Loop until finished
0B3F5D             0011*       include "basic/patch.asm"
0B3F5D             0001**  ;
0B3F5D             0002**  ; Title:	BBC Basic for AGON
0B3F5D             0003**  ; Author:	Dean Belfield
0B3F5D             0004**  ; Created:	12/05/2023
0B3F5D             0005**  ; Last Updated:	15/11/2023
0B3F5D             0006**  ;
0B3F5D             0007**  ; Modinfo:
0B3F5D             0008**  ; 11/07/2023:	Fixed *BYE for ADL mode
0B3F5D             0009**  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
0B3F5D             0010**  
0B3F5D             0011**  			; .ASSUME	ADL = 1
0B3F5D             0012**  
0B3F5D             0013**  			; INCLUDE	"equs.inc"
0B3F5D             0014**  			; INCLUDE "macros.inc"
0B3F5D             0015**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B3F5D             0016**  
0B3F5D             0017**  			; SEGMENT CODE
0B3F5D             0018**  
0B3F5D             0019**  			; XDEF	OSWRCH
0B3F5D             0020**  			; XDEF	OSLINE
0B3F5D             0021**  			; XDEF	ESCSET
0B3F5D             0022**  			; XDEF	PUTIME
0B3F5D             0023**  			; XDEF	GETIME
0B3F5D             0024**  			; XDEF	PUTCSR
0B3F5D             0025**  			; XDEF 	GETCSR
0B3F5D             0026**  			; XDEF	OSRDCH
0B3F5D             0027**  			; XDEF	PROMPT
0B3F5D             0028**  			; XDEF	OSKEY
0B3F5D             0029**  			; XDEF	TRAP
0B3F5D             0030**  			; XDEF	LTRAP
0B3F5D             0031**  			; XDEF	OSINIT
0B3F5D             0032**  			; XDEF	OSCLI
0B3F5D             0033**  			; XDEF	OSBPUT
0B3F5D             0034**  			; XDEF	OSBGET
0B3F5D             0035**  			; XDEF	OSSTAT
0B3F5D             0036**  			; XDEF	OSSHUT
0B3F5D             0037**  			; XDEF	OSOPEN
0B3F5D             0038**  			; XDEF	OSCALL
0B3F5D             0039**  			; XDEF	GETPTR
0B3F5D             0040**  			; XDEF	PUTPTR
0B3F5D             0041**  			; XDEF	GETEXT
0B3F5D             0042**  			; XDEF	GETIMS
0B3F5D             0043**  			; XDEF	RESET
0B3F5D             0044**  			; XDEF	OSLOAD
0B3F5D             0045**  			; XDEF	OSSAVE
0B3F5D             0046**  			; XDEF	EXPR_W2
0B3F5D             0047**  			; XDEF	STAR_VERSION
0B3F5D             0048**  
0B3F5D             0049**  			; XREF	_basic_end			; In init.asm
0B3F5D             0050**  
0B3F5D             0051**  			; XREF	ASC_TO_NUMBER
0B3F5D             0052**  			; XREF	RAM_START
0B3F5D             0053**  			; XREF	RAM_END
0B3F5D             0054**  			; XREF	FLAGS
0B3F5D             0055**  			; XREF	ESCAPE
0B3F5D             0056**  			; XREF	USER
0B3F5D             0057**  			; XREF	RAM_Top
0B3F5D             0058**  			; XREF	EXTERR
0B3F5D             0059**  			; XREF	COUNT0
0B3F5D             0060**  			; XREF	EXPRI
0B3F5D             0061**  			; XREF	COMMA
0B3F5D             0062**  			; XREF	XEQ
0B3F5D             0063**  			; XREF	NXT
0B3F5D             0064**  			; XREF	NULLTOCR
0B3F5D             0065**  			; XREF	CRLF
0B3F5D             0066**  			; XREF	CSTR_FNAME
0B3F5D             0067**  			; XREF	CSTR_LINE
0B3F5D             0068**  			; XREF	CSTR_FINDCH
0B3F5D             0069**  			; XREF	CSTR_ENDSWITH
0B3F5D             0070**  			; XREF	CSTR_CAT
0B3F5D             0071**  			; XREF	FINDL
0B3F5D             0072**  			; XREF	OUT_
0B3F5D             0073**  			; XREF	ERROR_
0B3F5D             0074**  			; XREF	ONEDIT
0B3F5D             0075**  			; XREF	TELL
0B3F5D             0076**  			; XREF	OSWRCHPT
0B3F5D             0077**  			; XREF	OSWRCHCH
0B3F5D             0078**  			; XREF	OSWRCHFH
0B3F5D             0079**  			; XREF	LISTON
0B3F5D             0080**  			; XREF	LISTIT
0B3F5D             0081**  			; XREF	PAGE_
0B3F5D             0082**  			; XREF	ONEDIT1
0B3F5D             0083**  			; XREF	CLEAN
0B3F5D             0084**  			; XREF	NEWIT
0B3F5D             0085**  			; XREF	BAD
0B3F5D             0086**  			; XREF	VBLANK_INIT
0B3F5D             0087**  			; XREF	VBLANK_STOP
0B3F5D             0088**  			; XREF	KEYDOWN
0B3F5D             0089**  			; XREF	KEYASCII
0B3F5D             0090**  			; XREF	WIDTH
0B3F5D             0091**  			; XREF	ASSEM
0B3F5D             0092**  
0B3F5D             0093**  ; OSLINE: Invoke the line editor
0B3F5D             0094**  ;
0B3F5D 1E 01       0095**  OSLINE:			LD 	E, 1			; Default is to clear the buffer
0B3F5F             0096**  
0B3F5F             0097**  ; Entry point to line editor that does not clear the buffer
0B3F5F             0098**  ;
0B3F5F FD E5       0099**  OSLINE1:		PUSH	IY
0B3F61 E5          0100**  			PUSH	HL			; Buffer address
0B3F62 01 00 01 00 0101**  			LD	BC, 256			; Buffer length
0B3F66             0102**  			MOSCALL	mos_editline		; Call the MOS line editor
0B3F66 3E 09       0001**M 			LD	A, function
0B3F68 49 CF       0002**M 			RST.LIS	08h
0B3F6A E1          0103**  			POP	HL			; Pop the address
0B3F6B FD E1       0104**  			POP	IY
0B3F6D F5          0105**  			PUSH	AF			; Stack the return value (key pressed)
0B3F6E CD FF 3E 0B 0106**  			CALL	NULLTOCR		; Turn the 0 character to a CR
0B3F72 CD 45 3A 0B 0107**  			CALL	CRLF			; Display CRLF
0B3F76 F1          0108**  			POP	AF
0B3F77 FE 1B       0109**  			CP	1Bh 			; Check if ESC terminated the input
0B3F79 CA 75 40 0B 0110**  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
0B3F7D 3A 42 4E 0B 0111**  			LD	A, (FLAGS)		; Otherwise
0B3F81 CB BF       0112**  			RES	7, A 			; Clear the escape flag
0B3F83 32 42 4E 0B 0113**  			LD	(FLAGS), A
0B3F87 CD 3B 42 0B 0114**  			CALL	WAIT_VBLANK 		; Wait a frame
0B3F8B AF          0115**   			XOR	A			; Return A = 0
0B3F8C 32 47 4E 0B 0116**  			LD	(KEYDOWN), A
0B3F90 32 48 4E 0B 0117**  			LD	(KEYASCII), A
0B3F94 C9          0118**  			RET
0B3F95             0119**  
0B3F95             0120**  ; PUTIME: set current time to DE:HL, in centiseconds.
0B3F95             0121**  ;
0B3F95 DD E5       0122**  PUTIME:			PUSH 	IX
0B3F97             0123**  			MOSCALL	mos_sysvars
0B3F97 3E 08       0001**M 			LD	A, function
0B3F99 49 CF       0002**M 			RST.LIS	08h
0B3F9B DD 75 00    0124**  			LD	(IX + sysvar_time + 0), L
0B3F9E DD 74 01    0125**  			LD	(IX + sysvar_time + 1), H
0B3FA1 DD 73 02    0126**  			LD	(IX + sysvar_time + 2), E
0B3FA4 DD 72 03    0127**  			LD	(IX + sysvar_time + 3), D
0B3FA7 DD E1       0128**  			POP	IX
0B3FA9 C9          0129**  			RET
0B3FAA             0130**  
0B3FAA             0131**  ; GETIME: return current time in DE:HL, in centiseconds
0B3FAA             0132**  ;
0B3FAA DD E5       0133**  GETIME:			PUSH 	IX
0B3FAC             0134**  			MOSCALL	mos_sysvars
0B3FAC 3E 08       0001**M 			LD	A, function
0B3FAE 49 CF       0002**M 			RST.LIS	08h
0B3FB0 DD 6E 00    0135**  			LD	L, (IX + sysvar_time + 0)
0B3FB3 DD 66 01    0136**  			LD	H, (IX + sysvar_time + 1)
0B3FB6 DD 5E 02    0137**  			LD	E, (IX + sysvar_time + 2)
0B3FB9 DD 56 03    0138**  			LD	D, (IX + sysvar_time + 3)
0B3FBC DD E1       0139**  			POP	IX
0B3FBE C9          0140**  			RET
0B3FBF             0141**  
0B3FBF             0142**  ; PUTCSR: move to cursor to x=DE, y=HL
0B3FBF             0143**  ;
0B3FBF 3E 1F       0144**  PUTCSR:			LD	A, 1Fh			; TAB
0B3FC1 5B D7       0145**  			RST.LIL	10h
0B3FC3 7B          0146**  			LD	A, E			; X
0B3FC4 5B D7       0147**  			RST.LIL 10h
0B3FC6 7D          0148**  			LD	A, L			; Y
0B3FC7 5B D7       0149**  			RST.LIL 10h
0B3FC9 C9          0150**  			RET
0B3FCA             0151**  
0B3FCA             0152**  ; GETCSR: return cursor position in x=DE, y=HL
0B3FCA             0153**  ;
0B3FCA DD E5       0154**  GETCSR:			PUSH	IX			; Get the system vars in IX
0B3FCC             0155**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B3FCC 3E 08       0001**M 			LD	A, function
0B3FCE 49 CF       0002**M 			RST.LIS	08h
0B3FD0 DD CB 04 86 0156**  			RES	0, (IX+sysvar_vpd_pflags)
0B3FD4             0157**  			VDU	23
0B3FD4 3E 17       0001**M 		LD	A, val
0B3FD6 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B3FDA             0158**  			VDU	0
0B3FDA 3E 00       0001**M 		LD	A, val
0B3FDC CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B3FE0             0159**  			VDU	vdp_cursor
0B3FE0 3E 82       0001**M 		LD	A, val
0B3FE2 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B3FE6 DD CB 04 46 0160**  @@:			BIT	0, (IX+sysvar_vpd_pflags)
0B3FEA 28 FA       0161**  			JR	Z, @B			; Wait for the result
0B3FEC 16 00       0162**  			LD 	D, 0
0B3FEE 62          0163**  			LD	H, D
0B3FEF DD 5E 07    0164**  			LD	E, (IX + sysvar_cursorX)
0B3FF2 DD 6E 08    0165**  			LD	L, (IX + sysvar_cursorY)
0B3FF5 DD E1       0166**  			POP	IX
0B3FF7 C9          0167**  			RET
0B3FF8             0168**  
0B3FF8             0169**  ; PROMPT: output the input prompt
0B3FF8             0170**  ;
0B3FF8 3E 3E       0171**  PROMPT: 		LD	A,'>'
0B3FFA C3 FE 3F 0B 0172**  			JP	OSWRCH
0B3FFE             0173**  
0B3FFE             0174**  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
0B3FFE             0175**  ; A: Character to write
0B3FFE             0176**  ;
0B3FFE E5          0177**  OSWRCH:			PUSH	HL
0B3FFF 21 40 4E 0B 0178**  			LD	HL, LISTON		; Fetch the LISTON variable
0B4003 CB 5E       0179**  			BIT	3, (HL)			; Check whether we are in *EDIT mode
0B4005 20 0B       0180**  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0B4007             0181**  ;
0B4007 2A 45 4E 0B 0182**  			LD	HL, (OSWRCHCH)		; L: Channel #
0B400B 2D          0183**  			DEC	L			; If it is 1
0B400C 28 10       0184**  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0B400E             0185**  ;
0B400E E1          0186**  			POP	HL			; Otherwise
0B400F 5B D7       0187**  			RST.LIL	10h			; Output the character to MOS
0B4011 C9          0188**  			RET
0B4012             0189**  ;
0B4012 2A 43 4E 0B 0190**  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0B4016 77          0191**  			LD	(HL), A			; Echo the character into the buffer
0B4017 23          0192**  			INC	HL			; Increment pointer
0B4018 22 43 4E 0B 0193**  			LD	(OSWRCHPT), HL		; Write pointer back
0B401C E1          0194**  			POP	HL
0B401D C9          0195**  			RET
0B401E             0196**  ;
0B401E D5          0197**  OSWRCH_FILE:		PUSH	DE
0B401F 5C          0198**  			LD	E, H			; Filehandle to E
0B4020 CD 39 44 0B 0199**  			CALL	OSBPUT			; Write the byte out
0B4024 D1          0200**  			POP	DE
0B4025 E1          0201**  			POP	HL
0B4026 C9          0202**  			RET
0B4027             0203**  
0B4027             0204**  ; OSRDCH: Read a character in from the ESP32 keyboard handler
0B4027             0205**  ; This is only called in GETS (eval.asm)
0B4027             0206**  ;
0B4027             0207**  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0B4027 3E 00       0001**M 			LD	A, function
0B4029 49 CF       0002**M 			RST.LIS	08h
0B402B FE 1B       0208**  			CP	1Bh
0B402D 28 46       0209**  			JR	Z, LTRAP1
0B402F C9          0210**  			RET
0B4030             0211**  
0B4030             0212**  
0B4030             0213**  ;OSKEY - Read key with time-limit, test for ESCape.
0B4030             0214**  ;Main function is carried out in user patch.
0B4030             0215**  ;   Inputs: HL = time limit (centiseconds)
0B4030             0216**  ;  Outputs: Carry reset if time-out
0B4030             0217**  ;           If carry set A = character
0B4030             0218**  ; Destroys: A,H,L,F
0B4030             0219**  ;
0B4030 CD 61 40 0B 0220**  OSKEY:			CALL	READKEY			; Read the keyboard
0B4034 28 0A       0221**  			JR	Z, @F 			; Skip if we have a key
0B4036 7C          0222**  			LD	A, H 			; Check loop counter
0B4037 B5          0223**  			OR 	L
0B4038 C8          0224**  			RET 	Z 			; Return, we've not got a key at this point
0B4039 CD 3B 42 0B 0225**  			CALL	WAIT_VBLANK 		; Wait a frame
0B403D 2B          0226**  			DEC 	HL			; Decrement
0B403E 18 F0       0227**  			JR	OSKEY 			; And loop
0B4040             0228**  ;
0B4040 21 47 4E 0B 0229**  @@:			LD	HL, KEYDOWN		; We have a key, so
0B4044 36 00       0230**  			LD	(HL), 0			; clear the keydown flag
0B4046 FE 1B       0231**  			CP	1BH			; If we are not pressing ESC,
0B4048 37          0232**  			SCF 				; then flag we've got a character
0B4049 C0          0233**  			RET	NZ
0B404A             0234**  ;
0B404A             0235**  ; ESCSET
0B404A             0236**  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
0B404A             0237**  ;
0B404A E5          0238**  ESCSET: 		PUSH    HL
0B404B 21 42 4E 0B 0239**          		LD      HL,FLAGS		; Pointer to FLAGS
0B404F CB 76       0240**          		BIT     6,(HL)			; If bit 6 is set, then
0B4051 20 02       0241**          		JR      NZ,ESCDIS		; escape is disabled, so skip
0B4053 CB FE       0242**          		SET     7,(HL)			; Set bit 7, the escape flag
0B4055 E1          0243**  ESCDIS: 		POP     HL
0B4056 C9          0244**          		RET
0B4057             0245**  ;
0B4057             0246**  ; ESCTEST
0B4057             0247**  ; Test for ESC key
0B4057             0248**  ;
0B4057 CD 61 40 0B 0249**  ESCTEST:		CALL	READKEY			; Read the keyboard
0B405B C0          0250**  			RET	NZ			; Skip if no key is pressed
0B405C FE 1B       0251**  			CP	1BH			; If ESC pressed then
0B405E 28 EA       0252**  			JR	Z,ESCSET		; jump to the escape set routine
0B4060 C9          0253**  			RET
0B4061             0254**  
0B4061             0255**  ; Read the keyboard
0B4061             0256**  ; Returns:
0B4061             0257**  ; - A: ASCII of the pressed key
0B4061             0258**  ; - F: Z if the key is pressed, otherwise NZ
0B4061             0259**  ;
0B4061 3A 47 4E 0B 0260**  READKEY:		LD	A, (KEYDOWN)		; Get key down
0B4065 3D          0261**  			DEC	A 			; Set Z flag if keydown is 1
0B4066 3A 48 4E 0B 0262**  			LD	A, (KEYASCII)		; Get key ASCII value
0B406A C9          0263**  			RET
0B406B             0264**  ;
0B406B             0265**  ; TRAP
0B406B             0266**  ; This is called whenever BASIC needs to check for ESC
0B406B             0267**  ;
0B406B CD 57 40 0B 0268**  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
0B406F             0269**  ;
0B406F 3A 42 4E 0B 0270**  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
0B4073 B7          0271**  			OR	A			; This checks for bit 7; if it is not set then the result will
0B4074 F0          0272**  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
0B4075 21 42 4E 0B 0273**  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
0B4079 CB BE       0274**  			RES	7,(HL)			; Clear the escape pressed flag and
0B407B C3 99 0D 0B 0275**  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
0B407F             0276**  
0B407F             0277**  ;OSINIT - Initialise RAM mapping etc.
0B407F             0278**  ;If BASIC is entered by BBCBASIC FILENAME then file
0B407F             0279**  ;FILENAME.BBC is automatically CHAINed.
0B407F             0280**  ;   Outputs: DE = initial value of HIMEM (top of RAM)
0B407F             0281**  ;            HL = initial value of PAGE (user program)
0B407F             0282**  ;            Z-flag reset indicates AUTO-RUN.
0B407F             0283**  ;  Destroys: A,D,E,H,L,F
0B407F             0284**  ;
0B407F CD DE 49 0B 0285**  OSINIT:			CALL	VBLANK_INIT
0B4083 AF          0286**  			XOR	A
0B4084 21 00 4F 0B 0287**  			LD 	HL, USER
0B4088 11 00 00 0B 0288**  			LD	DE, RAM_Top
0B408C 5F          0289**  			LD	E, A			; Page boundary
0B408D C9          0290**  			RET
0B408E             0291**  
0B408E             0292**  ;
0B408E             0293**  ;OSCLI - Process a MOS command
0B408E             0294**  ;
0B408E CD 02 41 0B 0295**  OSCLI: 			CALL    SKIPSP
0B4092 FE 0D       0296**  			CP      CR
0B4094 C8          0297**  			RET     Z
0B4095 FE 7C       0298**  			CP      '|'
0B4097 C8          0299**  			RET     Z
0B4098 EB          0300**  			EX      DE,HL
0B4099 21 11 41 0B 0301**  			LD      HL,COMDS
0B409D 1A          0302**  OSCLI0:			LD      A,(DE)
0B409E CD 09 41 0B 0303**  			CALL    UPPRC
0B40A2 BE          0304**  			CP      (HL)
0B40A3 28 0B       0305**  			JR      Z,OSCLI2
0B40A5 38 30       0306**  			JR      C,OSCLI6
0B40A7 CB 7E       0307**  OSCLI1:			BIT     7,(HL)
0B40A9 23          0308**  			INC     HL
0B40AA 28 FB       0309**  			JR      Z,OSCLI1
0B40AC 23          0310**  			INC     HL
0B40AD 23          0311**  			INC     HL
0B40AE 18 ED       0312**  			JR      OSCLI0
0B40B0             0313**  ;
0B40B0 D5          0314**  OSCLI2:			PUSH    DE
0B40B1 13          0315**  OSCLI3:			INC     DE
0B40B2 23          0316**  			INC     HL
0B40B3 1A          0317**  			LD      A,(DE)
0B40B4 CD 09 41 0B 0318**  			CALL    UPPRC
0B40B8 FE 2E       0319**  			CP      '.'			; ABBREVIATED?
0B40BA 28 0A       0320**  			JR      Z,OSCLI4
0B40BC AE          0321**  			XOR     (HL)
0B40BD 28 F2       0322**  			JR      Z,OSCLI3
0B40BF FE 80       0323**  			CP      80H
0B40C1 28 03       0324**  			JR      Z,OSCLI4
0B40C3 D1          0325**  			POP     DE
0B40C4 18 E1       0326**  			JR      OSCLI1
0B40C6             0327**  ;
0B40C6 F1          0328**  OSCLI4:			POP     AF
0B40C7 13          0329**  		        INC     DE
0B40C8 CB 7E       0330**  OSCLI5:			BIT     7,(HL)
0B40CA 23          0331**  			INC     HL
0B40CB 28 FB       0332**  			JR      Z,OSCLI5
0B40CD 7E          0333**  			LD      A,(HL)
0B40CE 23          0334**  			INC     HL
0B40CF 66          0335**  			LD      H,(HL)
0B40D0 6F          0336**  			LD      L,A
0B40D1 E5          0337**  			PUSH    HL
0B40D2 EB          0338**  			EX      DE,HL
0B40D3 C3 02 41 0B 0339**  			JP      SKIPSP
0B40D7             0340**  ;
0B40D7 EB          0341**  OSCLI6:			EX	DE, HL			; HL: Buffer for command
0B40D8 11 00 4B 0B 0342**  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0B40DC D5          0343**  			PUSH	DE			; Store buffer address
0B40DD CD 29 3F 0B 0344**  			CALL	CSTR_LINE		; Fetch the line
0B40E1 E1          0345**  			POP	HL			; HL: Pointer to command string in ACCS
0B40E2 FD E5       0346**  			PUSH	IY
0B40E4             0347**  			MOSCALL	mos_oscli		; Returns OSCLI error in A
0B40E4 3E 10       0001**M 			LD	A, function
0B40E6 49 CF       0002**M 			RST.LIS	08h
0B40E8 FD E1       0348**  			POP	IY
0B40EA B7          0349**  			OR	A			; 0 means MOS returned OK
0B40EB C8          0350**  			RET	Z			; So don't do anything
0B40EC C3 15 43 0B 0351**  			JP 	OSERROR			; Otherwise it's a MOS error
0B40F0             0352**  
0B40F0 3E FE       0353**  HUH:    		LD      A,254			; Bad command error
0B40F2 CD 75 38 0B 0354**          		CALL    EXTERR
0B40F6 42 61 64 20 0355**          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0B4101 00          0356**          		DEFB    0
0B4102             0357**  
0B4102 7E          0358**  SKIPSP:			LD      A,(HL)
0B4103 FE 20       0359**          		CP      ' '
0B4105 C0          0360**          		RET     NZ
0B4106 23          0361**          		INC     HL
0B4107 18 F9       0362**          		JR      SKIPSP
0B4109             0363**  
0B4109 E6 7F       0364**  UPPRC:  		AND     7FH
0B410B FE 60       0365**  			CP      '`'
0B410D D8          0366**  			RET     C
0B410E E6 5F       0367**  			AND     5FH			; CONVERT TO UPPER CASE
0B4110 C9          0368**  			RET
0B4111             0369**  
0B4111             0370**  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0B4111             0371**  ; These must be in alphabetical order
0B4111             0372**  ;
0B4111             0373**  ; BEGIN NOT FOUND IN BINARY
0B4111             0374**  ; COMDS:  		DB	"AS","M"+80h		; ASM
0B4111             0375**  ; 			DW	STAR_ASM
0B4111             0376**  ; 			DB	"BY","E"+80h		; BYE
0B4111             0377**  ; 			DW	STAR_BYE
0B4111             0378**  ; 			DB	"EDI","T"+80h		; EDIT
0B4111             0379**  ; 			DW	STAR_EDIT
0B4111             0380**  ; 			DB	"F","X"+80h		; FX
0B4111             0381**  ; 			DW	STAR_FX
0B4111             0382**  ; 			DB	"VERSIO","N"+80h	; VERSION
0B4111             0383**  ; 			DW	STAR_VERSION
0B4111             0384**  ; 			DB	FFh
0B4111             0385**  ; END NOT FOUND IN BINARY
0B4111             0386**  ; BEGIN INSERTED FROM BINARY
0B4111             0387**  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0B4111             0388**  ; These must be in alphabetical order
0B4111             0389**  ;
0B4111             0390**  COMDS:
0B4111 42          0391**  	db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
0B4112 59          0392**  	db 0x59 ; 044014
0B4113 C5          0393**  	db 0xc5 ; 044015
0B4114 2C          0394**  	db 0x2c ; 044016 31     11405 DW	STAR_ASM
0B4115 40          0395**  	db 0x40 ; 044017
0B4116 45          0396**  	db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
0B4117 44          0397**  	db 0x44 ; 044019
0B4118 49          0398**  	db 0x49 ; 04401A
0B4119 D4          0399**  	db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
0B411A 61          0400**  	db 0x61 ; 04401C
0B411B 40          0401**  	db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
0B411C 46          0402**  	db 0x46 ; 04401E
0B411D D8          0403**  	db 0xd8 ; 04401F
0B411E A1          0404**  	db 0xa1 ; 044020
0B411F 40          0405**  	db 0x40 ; 044021 72     11409 DW	STAR_EDIT
0B4120 56          0406**  	db 0x56 ; 044022
0B4121 45          0407**  	db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
0B4122 52          0408**  	db 0x52 ; 044024
0B4123 53          0409**  	db 0x53 ; 044025 B2     11411 DW	STAR_FX
0B4124 49          0410**  	db 0x49 ; 044026
0B4125 4F          0411**  	db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
0B4126 CE          0412**  	db 0xce ; 044028
0B4127 38          0413**  	db 0x38 ; 044029
0B4128 40          0414**  	db 0x40 ; 04402A
0B4129 FF          0415**  	db 0xff ; 04402B
0B412A             0416**  ; END INSERTED FROM BINARY
0B412A             0417**  
0B412A             0418**  ; BEGIN NOT FOUND IN BINARY
0B412A             0419**  ; ; *ASM string
0B412A             0420**  ; ;
0B412A             0421**  ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
0B412A             0422**  ; 			PUSH	HL			; HL = IY
0B412A             0423**  ; 			POP	IY
0B412A             0424**  ; 			CALL	ASSEM			; Invoke the assembler
0B412A             0425**  ; 			POP	IY
0B412A             0426**  ; 			RET
0B412A             0427**  ; END NOT FOUND IN BINARY
0B412A             0428**  
0B412A             0429**  ; *BYE
0B412A             0430**  ;
0B412A CD F2 49 0B 0431**  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
0B412E 21 00 00 00 0432**  			LD	HL, 0			; The return value
0B4132 C3 79 4F 0B 0433**  			JP	_basic_end 			; Jump back to the end routine in init.asm
0B4136             0434**  
0B4136             0435**  ; *VERSION
0B4136             0436**  ;
0B4136 CD 8E 3E 0B 0437**  STAR_VERSION:		CALL    TELL			; Output the welcome message
0B413A 42 42 43 20 0438**  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0B415E C9          0439**  			RET
0B415F             0440**  
0B415F             0441**  ; *EDIT linenum
0B415F             0442**  ;
0B415F CD 95 3E 0B 0443**  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0B4163 EB          0444**  			EX	DE, HL			; HL: Line number
0B4164 CD 8D 3A 0B 0445**  			CALL	FINDL			; HL: Address in RAM of tokenised line
0B4168 3E 29       0446**  			LD	A, 41			; F:NZ If the line is not found
0B416A C2 5E 38 0B 0447**  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0B416E             0448**  ;
0B416E             0449**  ; Use LISTIT to output the line to the ACCS buffer
0B416E             0450**  ;
0B416E 23          0451**  			INC	HL			; Skip the length byte
0B416F 5E          0452**  			LD	E, (HL)			; Fetch the line number
0B4170 23          0453**  			INC	HL
0B4171 56          0454**  			LD	D, (HL)
0B4172 23          0455**  			INC	HL
0B4173 DD 21 00 4B 0456**  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       0B          
0B4178 DD 22 43 4E 0457**  			LD	(OSWRCHPT), IX
       0B          
0B417D DD 21 40 4E 0458**  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       0B          
0B4182 DD 7E 00    0459**  			LD	A, (IX)			; Store that variable
0B4185 F5          0460**  			PUSH	AF
0B4186 DD 36 00 09 0461**  			LD	(IX), 09h		; Set to echo to buffer
0B418A CD 90 39 0B 0462**  			CALL	LISTIT
0B418E F1          0463**  			POP	AF
0B418F DD 77 00    0464**  			LD	(IX), A			; Restore the original LISTON variable
0B4192 21 00 4B 0B 0465**  			LD	HL, ACCS		; HL: ACCS
0B4196 5D          0466**  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0B4197 CD 5F 3F 0B 0467**  			CALL	OSLINE1			; Invoke the editor
0B419B C3 CE 31 0B 0468**  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0B419F             0469**  
0B419F             0470**  ; OSCLI FX n
0B419F             0471**  ;
0B419F CD 95 3E 0B 0472**  STAR_FX:		CALL	ASC_TO_NUMBER
0B41A3 4B          0473**  			LD	C, E			; C: Save FX #
0B41A4 CD 95 3E 0B 0474**  			CALL	ASC_TO_NUMBER
0B41A8 7A          0475**  			LD	A, D  			; Is first parameter > 255?
0B41A9 B7          0476**  			OR 	A
0B41AA 28 03       0477**  			JR	Z, STAR_FX1		; Yes, so skip next bit
0B41AC EB          0478**  			EX	DE, HL 			; Parameter is 16-bit
0B41AD 18 07       0479**  			JR	STAR_FX2
0B41AF             0480**  ;
0B41AF 43          0481**  STAR_FX1:		LD	B, E 			; B: Save First parameter
0B41B0 CD 95 3E 0B 0482**  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0B41B4 68          0483**  			LD	L, B 			; L: First parameter
0B41B5 63          0484**  			LD	H, E 			; H: Second parameter
0B41B6             0485**  ;
0B41B6 79          0486**  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0B41B7             0487**  ;
0B41B7             0488**  ; OSBYTE
0B41B7             0489**  ;  A: FX #
0B41B7             0490**  ;  L: First parameter
0B41B7             0491**  ;  H: Second parameter
0B41B7             0492**  ;
0B41B7 FE 0B       0493**  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0B41B9 28 18       0494**  			JR	Z, OSBYTE_0B
0B41BB FE 0C       0495**  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0B41BD 28 43       0496**  			JR	Z, OSBYTE_0C
0B41BF FE 13       0497**  			CP	13H			; *FX 19: Wait for vblank
0B41C1 28 6E       0498**  			JR	Z, OSBYTE_13
0B41C3 FE 76       0499**  			CP	76H			; *FX 118, n: Set keyboard LED
0B41C5 CA 4C 42 0B 0500**  			JP	Z, OSBYTE_76
0B41C9 FE A0       0501**  			CP	A0H
0B41CB CA 7C 42 0B 0502**  			JP	Z, OSBYTE_A0
0B41CF C3 F0 40 0B 0503**  			JP	HUH			; Anything else trips an error
0B41D3             0504**  
0B41D3             0505**  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0B41D3             0506**  ; Parameters:
0B41D3             0507**  ; - HL: Repeat delay
0B41D3             0508**  ;
0B41D3             0509**  OSBYTE_0B:		VDU	23
0B41D3 3E 17       0001**M 		LD	A, val
0B41D5 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41D9             0510**  			VDU	0
0B41D9 3E 00       0001**M 		LD	A, val
0B41DB CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41DF             0511**  			VDU	vdp_keystate
0B41DF 3E 88       0001**M 		LD	A, val
0B41E1 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41E5             0512**  			VDU	L
0B41E5 7D          0001**M 		LD	A, val
0B41E6 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41EA             0513**  			VDU	H
0B41EA 7C          0001**M 		LD	A, val
0B41EB CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41EF             0514**  			VDU	0
0B41EF 3E 00       0001**M 		LD	A, val
0B41F1 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41F5             0515**  			VDU 	0
0B41F5 3E 00       0001**M 		LD	A, val
0B41F7 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B41FB             0516**  			VDU	255
0B41FB 3E FF       0001**M 		LD	A, val
0B41FD CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4201 C9          0517**  			RET
0B4202             0518**  
0B4202             0519**  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
0B4202             0520**  ; Parameters:
0B4202             0521**  ; - HL: Repeat rate
0B4202             0522**  ;
0B4202             0523**  OSBYTE_0C:		VDU	23
0B4202 3E 17       0001**M 		LD	A, val
0B4204 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4208             0524**  			VDU	0
0B4208 3E 00       0001**M 		LD	A, val
0B420A CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B420E             0525**  			VDU	vdp_keystate
0B420E 3E 88       0001**M 		LD	A, val
0B4210 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4214             0526**  			VDU	0
0B4214 3E 00       0001**M 		LD	A, val
0B4216 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B421A             0527**  			VDU 	0
0B421A 3E 00       0001**M 		LD	A, val
0B421C CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4220             0528**  			VDU	L
0B4220 7D          0001**M 		LD	A, val
0B4221 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4225             0529**  			VDU	H
0B4225 7C          0001**M 		LD	A, val
0B4226 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B422A             0530**  			VDU	255
0B422A 3E FF       0001**M 		LD	A, val
0B422C CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4230 C9          0531**  			RET
0B4231             0532**  
0B4231             0533**  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
0B4231             0534**  ;
0B4231 CD 3B 42 0B 0535**  OSBYTE_13:		CALL	WAIT_VBLANK
0B4235 2E 00       0536**  			LD	L, 0			; Returns 0
0B4237 C3 7D 06 0B 0537**  			JP	COUNT0
0B423B             0538**  ;
0B423B DD E5       0539**  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0B423D             0540**  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B423D 3E 08       0001**M 			LD	A, function
0B423F 49 CF       0002**M 			RST.LIS	08h
0B4241 DD 7E 00    0541**  			LD	A, (IX + sysvar_time + 0)
0B4244 DD BE 00    0542**  @@:			CP 	A, (IX + sysvar_time + 0)
0B4247 28 FB       0543**  			JR	Z, @B
0B4249 DD E1       0544**  			POP	IX
0B424B C9          0545**  			RET
0B424C             0546**  
0B424C             0547**  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0B424C             0548**  ; Parameters:
0B424C             0549**  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0B424C             0550**  ;
0B424C             0551**  OSBYTE_76:		VDU	23
0B424C 3E 17       0001**M 		LD	A, val
0B424E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4252             0552**  			VDU	0
0B4252 3E 00       0001**M 		LD	A, val
0B4254 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4258             0553**  			VDU	vdp_keystate
0B4258 3E 88       0001**M 		LD	A, val
0B425A CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B425E             0554**  			VDU	0
0B425E 3E 00       0001**M 		LD	A, val
0B4260 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4264             0555**  			VDU 	0
0B4264 3E 00       0001**M 		LD	A, val
0B4266 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B426A             0556**  			VDU	0
0B426A 3E 00       0001**M 		LD	A, val
0B426C CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4270             0557**  			VDU	0
0B4270 3E 00       0001**M 		LD	A, val
0B4272 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4276             0558**  			VDU	L
0B4276 7D          0001**M 		LD	A, val
0B4277 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B427B C9          0559**  			RET
0B427C             0560**  
0B427C             0561**  ; OSBYTE 0xA0: Fetch system variable
0B427C             0562**  ; Parameters:
0B427C             0563**  ; - L: The system variable to fetch
0B427C             0564**  ;
0B427C DD E5       0565**  OSBYTE_A0:		PUSH	IX
0B427E             0566**  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B427E 3E 08       0001**M 			LD	A, function
0B4280 49 CF       0002**M 			RST.LIS	08h
0B4282 01 00 00 00 0567**  			LD	BC, 0
0B4286 4D          0568**  			LD	C, L			; BCU = L
0B4287 DD 09       0569**  			ADD	IX, BC			; Add to IX
0B4289 DD 6E 00    0570**  			LD	L, (IX + 0)		; Fetch the return value
0B428C DD E1       0571**  			POP	IX
0B428E C3 7D 06 0B 0572**  			JP 	COUNT0
0B4292             0573**  
0B4292             0574**  ;OSLOAD - Load an area of memory from a file.
0B4292             0575**  ;   Inputs: HL addresses filename (CR terminated)
0B4292             0576**  ;           DE = address at which to load
0B4292             0577**  ;           BC = maximum allowed size (bytes)
0B4292             0578**  ;  Outputs: Carry reset indicates no room for file.
0B4292             0579**  ; Destroys: A,B,C,D,E,H,L,F
0B4292             0580**  ;
0B4292 C5          0581**  OSLOAD:			PUSH	BC			; Stack the size
0B4293 D5          0582**  			PUSH	DE			; Stack the load address
0B4294 11 00 4B 0B 0583**  			LD	DE, ACCS		; Buffer address for filename
0B4298 CD 17 3F 0B 0584**  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B429C 21 00 4B 0B 0585**  			LD	HL, ACCS		; HL: Filename
0B42A0 CD 92 43 0B 0586**  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B42A4 CD A6 43 0B 0587**  			CALL	EXT_HANDLER		; Get the default handler
0B42A8 D1          0588**  			POP	DE			; Restore the load address
0B42A9 C1          0589**  			POP	BC			; Restore the size
0B42AA B7          0590**  			OR	A
0B42AB 28 60       0591**  			JR 	Z, OSLOAD_BBC
0B42AD             0592**  ;
0B42AD             0593**  ; Load the file in as a text file
0B42AD             0594**  ;
0B42AD AF          0595**  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0B42AE CD 1A 44 0B 0596**  			CALL	OSOPEN			; Open the file
0B42B2 5F          0597**  			LD 	E, A 			; The filehandle
0B42B3 B7          0598**  			OR	A
0B42B4 3E 04       0599**  			LD	A, 4			; File not found error
0B42B6 28 5D       0600**  			JR	Z, OSERROR		; Jump to error handler
0B42B8 CD 6A 39 0B 0601**  			CALL	NEWIT			; Call NEW to clear the program space
0B42BC             0602**  ;
0B42BC 21 00 4B 0B 0603**  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0B42C0             0604**  ;
0B42C0             0605**  ; First skip any whitespace (indents) at the beginning of the input
0B42C0             0606**  ;
0B42C0 CD 31 44 0B 0607**  @@:			CALL	OSBGET			; Read the byte into A
0B42C4 38 1E       0608**  			JR	C, OSLOAD_TXT3		; Is it EOF?
0B42C6 FE 0A       0609**  			CP	LF 			; Is it LF?
0B42C8 28 1A       0610**  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0B42CA FE 21       0611**  			CP	21h			; Is it less than or equal to ASCII space?
0B42CC 38 F2       0612**  			JR	C, @B 			; Yes, so keep looping
0B42CE 77          0613**  			LD	(HL), A 		; Store the first character
0B42CF 2C          0614**  			INC	L
0B42D0             0615**  ;
0B42D0             0616**  ; Now read the rest of the line in
0B42D0             0617**  ;
0B42D0 CD 31 44 0B 0618**  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0B42D4 38 2B       0619**  			JR	C, OSLOAD_TXT4		; Is it EOF?
0B42D6 FE 20       0620**  			CP	20h			; Skip if not an ASCII character
0B42D8 38 06       0621**  			JR	C, @F
0B42DA 77          0622**  			LD	(HL), A 		; Store in the input buffer
0B42DB 2C          0623**  			INC	L			; Increment the buffer pointer
0B42DC CA F6 37 0B 0624**  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0B42E0 FE 0A       0625**  @@:			CP	LF			; Check for LF
0B42E2 20 EC       0626**  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0B42E4             0627**  ;
0B42E4             0628**  ; Finally, handle EOL/EOF
0B42E4             0629**  ;
0B42E4 36 0D       0630**  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0B42E6 7D          0631**  			LD	A, L			; Check for minimum line length
0B42E7 FE 02       0632**  			CP	2			; If it is 2 characters or less (including CR)
0B42E9 38 0A       0633**  			JR	C, @F			; Then don't bother entering it
0B42EB D5          0634**  			PUSH	DE			; Preserve the filehandle
0B42EC CD DA 31 0B 0635**  			CALL	ONEDIT1			; Enter the line in memory
0B42F0 DC 3D 39 0B 0636**  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0B42F4 D1          0637**  			POP	DE
0B42F5 CD 42 44 0B 0638**  @@:			CALL	OSSTAT			; End of file?
0B42F9 20 C1       0639**  			JR	NZ, OSLOAD_TXT1		; No, so loop
0B42FB CD 29 44 0B 0640**  			CALL	OSSHUT			; Close the file
0B42FF 37          0641**  			SCF				; Flag to BASIC that we're good
0B4300 C9          0642**  			RET
0B4301             0643**  ;
0B4301             0644**  ; Special case for BASIC programs with no blank line at the end
0B4301             0645**  ;
0B4301 FE 20       0646**  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0B4303 38 06       0647**  			JR	C, @F
0B4305 77          0648**  			LD	(HL), A			; Store the character
0B4306 2C          0649**  			INC	L
0B4307 CA F6 37 0B 0650**  			JP	Z, BAD
0B430B 18 D7       0651**  @@:			JR	OSLOAD_TXT3
0B430D             0652**  
0B430D             0653**  ;
0B430D             0654**  ; Load the file in as a tokenised binary blob
0B430D             0655**  ;
0B430D             0656**  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0B430D 3E 01       0001**M 			LD	A, function
0B430F 49 CF       0002**M 			RST.LIS	08h
0B4311 D0          0657**  			RET	NC			; If load returns with carry reset - NO ROOM
0B4312 B7          0658**  			OR	A			; If there is no error (A=0)
0B4313 37          0659**  			SCF				; Need to set carry indicating there was room
0B4314 C8          0660**  			RET	Z			; Return
0B4315             0661**  ;
0B4315 F5          0662**  OSERROR:		PUSH	AF			; Handle the MOS error
0B4316 21 00 4B 0B 0663**  			LD	HL, ACCS		; Address of the buffer
0B431A 01 00 01 00 0664**  			LD	BC, 256			; Length of the buffer
0B431E 5F          0665**  			LD	E, A			; The error code
0B431F             0666**  			MOSCALL	mos_getError		; Copy the error message into the buffer
0B431F 3E 0F       0001**M 			LD	A, function
0B4321 49 CF       0002**M 			RST.LIS	08h
0B4323 F1          0667**  			POP	AF
0B4324 E5          0668**  			PUSH	HL			; Stack the address of the error (now in ACCS)
0B4325 C6 7F       0669**  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0B4327 C3 75 38 0B 0670**  			JP	EXTERR			; Trigger an external error
0B432B             0671**  
0B432B             0672**  ;OSSAVE - Save an area of memory to a file.
0B432B             0673**  ;   Inputs: HL addresses filename (term CR)
0B432B             0674**  ;           DE = start address of data to save
0B432B             0675**  ;           BC = length of data to save (bytes)
0B432B             0676**  ; Destroys: A,B,C,D,E,H,L,F
0B432B             0677**  ;
0B432B C5          0678**  OSSAVE:			PUSH	BC			; Stack the size
0B432C D5          0679**  			PUSH	DE			; Stack the save address
0B432D 11 00 4B 0B 0680**  			LD	DE, ACCS		; Buffer address for filename
0B4331 CD 17 3F 0B 0681**  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B4335 21 00 4B 0B 0682**  			LD	HL, ACCS		; HL: Filename
0B4339 CD 92 43 0B 0683**  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B433D CD A6 43 0B 0684**  			CALL	EXT_HANDLER		; Get the default handler
0B4341 D1          0685**  			POP	DE			; Restore the save address
0B4342 C1          0686**  			POP	BC			; Restore the size
0B4343 B7          0687**  			OR	A			; Is the extension .BBC
0B4344 28 44       0688**  			JR	Z, OSSAVE_BBC		; Yes, so use that
0B4346             0689**  ;
0B4346             0690**  ; Save the file out as a text file
0B4346             0691**  ;
0B4346 3A 45 4E 0B 0692**  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0B434A F5          0693**  			PUSH	AF
0B434B AF          0694**  			XOR	A
0B434C 3C          0695**  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0B434D 32 45 4E 0B 0696**  			LD	(OSWRCHCH), A
0B4351 CD 1A 44 0B 0697**  			CALL	OSOPEN			; Open the file
0B4355 32 46 4E 0B 0698**  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0B4359 DD 21 40 4E 0699**  			LD	IX, LISTON		; Required for LISTIT
       0B          
0B435E 2A 14 4E 0B 0700**  			LD	HL, (PAGE_)		; Get start of program area
0B4362 D9          0701**  			EXX
0B4363 01 00 00 00 0702**  			LD	BC, 0			; Set the initial indent counters
0B4367 D9          0703**  			EXX
0B4368 7E          0704**  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0B4369 B7          0705**  			OR	A
0B436A 28 0F       0706**  			JR	Z, OSSAVE_TXT2
0B436C 23          0707**  			INC	HL			; Skip the length byte
0B436D 11 00 00 00 0708**  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0B4371 5E          0709**  			LD	E, (HL)			; Get the line number
0B4372 23          0710**  			INC	HL
0B4373 56          0711**  			LD	D, (HL)
0B4374 23          0712**  			INC	HL
0B4375 CD 90 39 0B 0713**  			CALL	LISTIT			; List the line
0B4379 18 ED       0714**  			JR	OSSAVE_TXT1
0B437B 3A 46 4E 0B 0715**  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0B437F 5F          0716**  			LD	E, A
0B4380 CD 29 44 0B 0717**  			CALL	OSSHUT			; Close it
0B4384 F1          0718**  			POP	AF			; Restore the channel
0B4385 32 45 4E 0B 0719**  			LD	(OSWRCHCH), A
0B4389 C9          0720**  			RET
0B438A             0721**  ;
0B438A             0722**  ; Save the file out as a tokenised binary blob
0B438A             0723**  ;
0B438A             0724**  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0B438A 3E 02       0001**M 			LD	A, function
0B438C 49 CF       0002**M 			RST.LIS	08h
0B438E B7          0725**  			OR	A			; If there is no error (A=0)
0B438F C8          0726**  			RET	Z			; Just return
0B4390 18 83       0727**  			JR	OSERROR			; Trip an error
0B4392             0728**  
0B4392             0729**  ; Check if an extension is specified in the filename
0B4392             0730**  ; Add a default if not specified
0B4392             0731**  ; HL: Filename (CSTR format)
0B4392             0732**  ;
0B4392 E5          0733**  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0B4393 0E 2E       0734**  			LD	C, '.'			; Search for dot (marks start of extension)
0B4395 CD 37 3F 0B 0735**  			CALL	CSTR_FINDCH
0B4399 B7          0736**  			OR	A			; Check for end of string marker
0B439A 20 08       0737**  			JR	NZ, @F			; No, so skip as we have an extension at this point
0B439C 11 D6 43 0B 0738**  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0B43A0 CD 4E 3F 0B 0739**  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0B43A4 E1          0740**  @@:			POP	HL			; Restore the filename pointer
0B43A5 C9          0741**  			RET
0B43A6             0742**  
0B43A6             0743**  ; Check if an extension is valid and, if so, provide a pointer to a handler
0B43A6             0744**  ; HL: Filename (CSTR format)
0B43A6             0745**  ; Returns:
0B43A6             0746**  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0B43A6             0747**  ;
0B43A6 E5          0748**  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0B43A7 0E 2E       0749**  			LD	C, '.'			; Find the '.'
0B43A9 CD 37 3F 0B 0750**  			CALL	CSTR_FINDCH
0B43AD 11 D6 43 0B 0751**  			LD	DE, EXT_LOOKUP		; The lookup table
0B43B1             0752**  ;
0B43B1 E5          0753**  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0B43B2 CD 3F 3F 0B 0754**  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0B43B6 E1          0755**  			POP	HL			; Restore the pointer to the extension
0B43B7 28 19       0756**  			JR	Z, EXT_HANDLER_2	; We have a match!
0B43B9             0757**  ;
0B43B9 1A          0758**  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0B43BA 13          0759**  			INC	DE
0B43BB B7          0760**  			OR	A
0B43BC 20 FB       0761**  			JR	NZ, @B
0B43BE 13          0762**  			INC	DE			; Skip the file extension # byte
0B43BF             0763**  ;
0B43BF 1A          0764**  			LD	A, (DE)			; Are we at the end of the table?
0B43C0 B7          0765**  			OR	A
0B43C1 20 EE       0766**  			JR	NZ, EXT_HANDLER_1	; No, so loop
0B43C3             0767**  ;
0B43C3 3E CC       0768**  			LD      A,204			; Throw a "Bad name" error
0B43C5 CD 75 38 0B 0769**          		CALL    EXTERR
0B43C9 42 61 64 20 0770**          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
0B43D2             0771**  ;
0B43D2 13          0772**  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0B43D3 1A          0773**  			LD	A, (DE)
0B43D4 E1          0774**  			POP	HL			; Restore the filename pointer
0B43D5 C9          0775**  			RET
0B43D6             0776**  ;
0B43D6             0777**  
0B43D6             0778**  
0B43D6             0779**  ; Extension lookup table
0B43D6             0780**  ; CSTR, TYPE
0B43D6             0781**  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
0B43D6             0782**  ; 	- 1: Human readable plain text
0B43D6             0783**  ;
0B43D6 2E 42 42 43 0784**  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
0B43DC 2E 54 58 54 0785**  			DB	".TXT", 0, 1
       00 01       
0B43E2 2E 41 53 43 0786**  			DB	".ASC", 0, 1
       00 01       
0B43E8 2E 42 41 53 0787**  			DB	".BAS", 0, 1
       00 01       
0B43EE 00          0788**  			DB	0			; End of table
0B43EF             0789**  
0B43EF             0790**  ;OSCALL - Intercept page &FF calls and provide an alternative address
0B43EF             0791**  ;
0B43EF             0792**  ;&FFF7:	OSCLI	Execute *command.
0B43EF             0793**  ;&FFF4:	OSBYTE	Various byte-wide functions.
0B43EF             0794**  ;&FFF1:	OSWORD	Various control block functions.
0B43EF             0795**  ;&FFEE:	OSWRCH	Write character to output stream.
0B43EF             0796**  ;&FFE7:	OSNEWL	Write NewLine to output stream.
0B43EF             0797**  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0B43EF             0798**  ;&FFE0:	OSRDCH	Wait for character from input stream.
0B43EF             0799**  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0B43EF             0800**  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0B43EF             0801**  ;&FFD7:	OSBGET	Read a byte from an a channel.
0B43EF             0802**  ;&FFD4:	OSBPUT	Write a byte to a channel.
0B43EF             0803**  ;&FFD1:	OSGBPB	Read and write blocks of data.
0B43EF             0804**  ;&FFCE:	OSFIND	Open or close a file.
0B43EF             0805**  ;
0B43EF 21 05 44 0B 0806**  OSCALL:			LD	HL, OSCALL_TABLE
0B43F3 7E          0807**  OSCALL_1:		LD	A, (HL)
0B43F4 23          0808**  			INC	HL
0B43F5 FE FF       0809**  			CP	FFh
0B43F7 C8          0810**  			RET	Z
0B43F8 FD BD       0811**  			CP	A, IYL
0B43FA 28 06       0812**  			JR	Z, OSCALL_2
0B43FC D0          0813**  			RET	NC
0B43FD 23          0814**  			INC	HL
0B43FE 23          0815**  			INC	HL
0B43FF 23          0816**  			INC	HL
0B4400 18 F1       0817**  			JR	OSCALL_1
0B4402 ED 31       0818**  OSCALL_2:		LD	IY,(HL)
0B4404 C9          0819**  			RET
0B4405 D4          0820**  OSCALL_TABLE:		DB 	D4h
0B4406 39 44 0B    0821**  			DW24 	OSBPUT
0B4409 D7          0822**  			DB 	D7h
0B440A 31 44 0B    0823**  			DW24 	OSBGET
0B440D EE          0824**  			DB 	EEh
0B440E FE 3F 0B    0825**  			DW24 	OSWRCH
0B4411 F4          0826**  			DB	F4h
0B4412 B7 41 0B    0827**  			DW24 	OSBYTE
0B4415 F7          0828**  			DB	F7h
0B4416 8E 40 0B    0829**  			DW24	OSCLI
0B4419 FF          0830**  			DB	FFh
0B441A             0831**  
0B441A             0832**  ; OSOPEN
0B441A             0833**  ; HL: Pointer to path
0B441A             0834**  ;  F: C Z
0B441A             0835**  ;     x x OPENIN
0B441A             0836**  ; 	  OPENOUT
0B441A             0837**  ;     x	  OPENUP
0B441A             0838**  ; Returns:
0B441A             0839**  ;  A: Filehandle, 0 if cannot open
0B441A             0840**  ;
0B441A 0E 01       0841**  OSOPEN:			LD	C, fa_read
0B441C 28 06       0842**  			JR	Z, @F
0B441E 0E 32       0843**  			LD	C, fa_write | fa_open_append
0B4420 38 02       0844**  			JR	C, @F
0B4422 0E 0A       0845**  			LD	C, fa_write | fa_create_always
0B4424             0846**  @@:			MOSCALL	mos_fopen
0B4424 3E 0A       0001**M 			LD	A, function
0B4426 49 CF       0002**M 			RST.LIS	08h
0B4428 C9          0847**  			RET
0B4429             0848**  
0B4429             0849**  ;OSSHUT - Close disk file(s).
0B4429             0850**  ; E = file channel
0B4429             0851**  ;  If E=0 all files are closed (except SPOOL)
0B4429             0852**  ; Destroys: A,B,C,D,E,H,L,F
0B4429             0853**  ;
0B4429 C5          0854**  OSSHUT:			PUSH	BC
0B442A 4B          0855**  			LD	C, E
0B442B             0856**  			MOSCALL	mos_fclose
0B442B 3E 0B       0001**M 			LD	A, function
0B442D 49 CF       0002**M 			RST.LIS	08h
0B442F C1          0857**  			POP	BC
0B4430 C9          0858**  			RET
0B4431             0859**  
0B4431             0860**  ; OSBGET - Read a byte from a random disk file.
0B4431             0861**  ;  E = file channel
0B4431             0862**  ; Returns
0B4431             0863**  ;  A = byte read
0B4431             0864**  ;  Carry set if LAST BYTE of file
0B4431             0865**  ; Destroys: A,B,C,F
0B4431             0866**  ;
0B4431 C5          0867**  OSBGET:			PUSH	BC
0B4432 4B          0868**  			LD	C, E
0B4433             0869**  			MOSCALL	mos_fgetc
0B4433 3E 0C       0001**M 			LD	A, function
0B4435 49 CF       0002**M 			RST.LIS	08h
0B4437 C1          0870**  			POP	BC
0B4438 C9          0871**  			RET
0B4439             0872**  
0B4439             0873**  ; OSBPUT - Write a byte to a random disk file.
0B4439             0874**  ;  E = file channel
0B4439             0875**  ;  A = byte to write
0B4439             0876**  ; Destroys: A,B,C,F
0B4439             0877**  ;
0B4439 C5          0878**  OSBPUT:			PUSH	BC
0B443A 4B          0879**  			LD	C, E
0B443B 47          0880**  			LD	B, A
0B443C             0881**  			MOSCALL	mos_fputc
0B443C 3E 0D       0001**M 			LD	A, function
0B443E 49 CF       0002**M 			RST.LIS	08h
0B4440 C1          0882**  			POP	BC
0B4441 C9          0883**  			RET
0B4442             0884**  
0B4442             0885**  ; OSSTAT - Read file status
0B4442             0886**  ;  E = file channel
0B4442             0887**  ; Returns
0B4442             0888**  ;  F: Z flag set - EOF
0B4442             0889**  ;  A: If Z then A = 0
0B4442             0890**  ; Destroys: A,D,E,H,L,F
0B4442             0891**  ;
0B4442 C5          0892**  OSSTAT:			PUSH	BC
0B4443 4B          0893**  			LD	C, E
0B4444             0894**  			MOSCALL	mos_feof
0B4444 3E 0E       0001**M 			LD	A, function
0B4446 49 CF       0002**M 			RST.LIS	08h
0B4448 C1          0895**  			POP	BC
0B4449 FE 01       0896**  			CP	1
0B444B C9          0897**  			RET
0B444C             0898**  
0B444C             0899**  ; GETPTR - Return file pointer.
0B444C             0900**  ;    E = file channel
0B444C             0901**  ; Returns:
0B444C             0902**  ; DEHL = pointer (0-&7FFFFF)
0B444C             0903**  ; Destroys: A,B,C,D,E,H,L,F
0B444C             0904**  ;
0B444C FD E5       0905**  GETPTR:			PUSH		IY
0B444E 4B          0906**  			LD		C, E
0B444F             0907**  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0B444F 3E 19       0001**M 			LD	A, function
0B4451 49 CF       0002**M 			RST.LIS	08h
0B4453 E5          0908**  			PUSH		HL
0B4454 FD E1       0909**  			POP		IY		; IYU: Pointer to FIL structure
0B4456 FD 6E 11    0910**  			LD		L, (IY + FIL.fptr + 0)
0B4459 FD 66 12    0911**  			LD		H, (IY + FIL.fptr + 1)
0B445C FD 5E 13    0912**  			LD		E, (IY + FIL.fptr + 2)
0B445F FD 56 14    0913**  			LD		D, (IY + FIL.fptr + 3)
0B4462 FD E1       0914**  			POP		IY
0B4464 C9          0915**  			RET
0B4465             0916**  
0B4465             0917**  ; PUTPTR - Update file pointer.
0B4465             0918**  ;    A = file channel
0B4465             0919**  ; DEHL = new pointer (0-&7FFFFF)
0B4465             0920**  ; Destroys: A,B,C,D,E,H,L,F
0B4465             0921**  ;
0B4465 FD E5       0922**  PUTPTR:			PUSH		IY
0B4467 4F          0923**  			LD		C, A  		; C: Filehandle
0B4468 E5          0924**  			PUSH		HL
0B4469 21 02 00 00 0925**  			LD		HL, 2
0B446D 39          0926**  			ADD		HL, SP
0B446E 73          0927**  			LD		(HL), E 	; 3rd byte of DWORD set to E
0B446F E1          0928**  			POP		HL
0B4470 5A          0929**  			LD		E, D  		; 4th byte passed as E
0B4471             0930**  			MOSCALL		mos_flseek
0B4471 3E 1C       0001**M 			LD	A, function
0B4473 49 CF       0002**M 			RST.LIS	08h
0B4475 FD E1       0931**  			POP		IY
0B4477 C9          0932**  			RET
0B4478             0933**  
0B4478             0934**  ; GETEXT - Find file size.
0B4478             0935**  ;    E = file channel
0B4478             0936**  ; Returns:
0B4478             0937**  ; DEHL = file size (0-&800000)
0B4478             0938**  ; Destroys: A,B,C,D,E,H,L,F
0B4478             0939**  ;
0B4478 FD E5       0940**  GETEXT:         PUSH    IY
0B447A 4B          0941**                  LD      C, E
0B447B             0942**                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0B447B 3E 19       0001**M 			LD	A, function
0B447D 49 CF       0002**M 			RST.LIS	08h
0B447F E5          0943**                  PUSH    HL
0B4480 FD E1       0944**                  POP     IY          ; IYU: Pointer to FIL structure
0B4482             0945**                  ; Access the obj.objsize field using the offset values
0B4482 FD 6E 0B    0946**                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0B4485 FD 66 0C    0947**                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0B4488 FD 5E 0D    0948**                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0B448B FD 56 0E    0949**                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0B448E             0950**  
0B448E FD E1       0951**                  POP     IY
0B4490 C9          0952**  			RET
0B4491             0953**  
0B4491             0954**  ; GETIMS - Get time from RTC
0B4491             0955**  ;
0B4491 FD E5       0956**  GETIMS:			PUSH	IY
0B4493 21 00 4B 0B 0957**  			LD	HL, ACCS 		; Where to store the time string
0B4497             0958**  			MOSCALL	mos_getrtc
0B4497 3E 12       0001**M 			LD	A, function
0B4499 49 CF       0002**M 			RST.LIS	08h
0B449B 11 00 4B 0B 0959**  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0B449F 5F          0960**  			LD	E, A 			;  E: now points to the end of the string
0B44A0 FD E1       0961**  			POP	IY
0B44A2 C9          0962**  			RET
0B44A3             0963**  
0B44A3             0964**  ; Get two word values from EXPR in DE, HL
0B44A3             0965**  ; IY: Pointer to expression string
0B44A3             0966**  ; Returns:
0B44A3             0967**  ; DE: P1
0B44A3             0968**  ; HL: P2
0B44A3             0969**  ;
0B44A3 CD 08 04 0B 0970**  EXPR_W2:		CALL	EXPRI			; Get first parameter
0B44A7 D9          0971**  			EXX
0B44A8 E5          0972**  			PUSH	HL
0B44A9 CD 20 0B 0B 0973**  			CALL	COMMA
0B44AD CD 08 04 0B 0974**  			CALL	EXPRI			; Get second parameter
0B44B1 D9          0975**  			EXX
0B44B2 D1          0976**  			POP	DE
0B44B3 C9          0977**  			RET
0B44B4             0978**  
0B44B4             0979**  ; Stuff not implemented yet
0B44B4             0980**  ;
0B44B4 C9          0981**  RESET:			RET
0B44B5             0012*       include "basic/sorry.asm"
0B44B5             0001**  ;
0B44B5             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B44B5             0003**  ;		Catch-all for unimplemented functionality
0B44B5             0004**  ; Author:	Dean Belfield
0B44B5             0005**  ; Created:	12/05/2023
0B44B5             0006**  ; Last Updated:	12/05/2023
0B44B5             0007**  ;
0B44B5             0008**  ; Modinfo:
0B44B5             0009**  
0B44B5             0010**  			; .ASSUME	ADL = 1
0B44B5             0011**  
0B44B5             0012**  			; SEGMENT CODE
0B44B5             0013**  
0B44B5             0014**  			; XDEF	ENVEL
0B44B5             0015**  			; XDEF	ADVAL
0B44B5             0016**  			; XDEF	PUTIMS
0B44B5             0017**  
0B44B5             0018**  			; XREF	EXTERR
0B44B5             0019**  
0B44B5             0020**  ENVEL:
0B44B5             0021**  ADVAL:
0B44B5             0022**  PUTIMS:
0B44B5 AF          0023**  			XOR     A
0B44B6 CD 75 38 0B 0024**  			CALL    EXTERR
0B44BA 53 6F 72 72 0025**  			DEFB    "Sorry"
       79          
0B44BF 00          0026**  			DEFB    0
0B44C0             0013*       include "basic/agon_graphics.asm"
0B44C0             0001**  ;
0B44C0             0002**  ; Title:	BBC Basic for AGON - Graphics stuff
0B44C0             0003**  ; Author:	Dean Belfield
0B44C0             0004**  ; Created:	12/05/2023
0B44C0             0005**  ; Last Updated:	07/06/2023
0B44C0             0006**  ;
0B44C0             0007**  ; Modinfo:
0B44C0             0008**  ; 07/06/2023:	Modified to run in ADL mode
0B44C0             0009**  
0B44C0             0010**  			; .ASSUME	ADL = 1
0B44C0             0011**  
0B44C0             0012**  			; INCLUDE	"equs.inc"
0B44C0             0013**  			; INCLUDE "macros.inc"
0B44C0             0014**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B44C0             0015**  
0B44C0             0016**  			; SEGMENT CODE
0B44C0             0017**  
0B44C0             0018**  			; XDEF	CLG
0B44C0             0019**  			; XDEF	CLRSCN
0B44C0             0020**  			; XDEF	MODE
0B44C0             0021**  			; XDEF	COLOUR
0B44C0             0022**  			; XDEF	GCOL
0B44C0             0023**  			; XDEF	MOVE
0B44C0             0024**  			; XDEF	PLOT
0B44C0             0025**  			; XDEF	DRAW
0B44C0             0026**  			; XDEF	POINT
0B44C0             0027**  			; XDEF	GETSCHR
0B44C0             0028**  
0B44C0             0029**  			; XREF	OSWRCH
0B44C0             0030**  			; XREF	ASC_TO_NUMBER
0B44C0             0031**  			; XREF	EXTERR
0B44C0             0032**  			; XREF	EXPRI
0B44C0             0033**  			; XREF	COMMA
0B44C0             0034**  			; XREF	XEQ
0B44C0             0035**  			; XREF	NXT
0B44C0             0036**  			; XREF	BRAKET
0B44C0             0037**  			; XREF	COUNT0
0B44C0             0038**  			; XREF	CRTONULL
0B44C0             0039**  			; XREF	NULLTOCR
0B44C0             0040**  			; XREF	CRLF
0B44C0             0041**  			; XREF	EXPR_W2
0B44C0             0042**  			; XREF	INKEY1
0B44C0             0043**  
0B44C0             0044**  ; CLG: clears the graphics area
0B44C0             0045**  ;
0B44C0             0046**  CLG:
0B44C0             0047**  
0B44C0             0048**  			VDU	10h
0B44C0 3E 10       0001**M 		LD	A, val
0B44C2 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B44C6 C3 94 0C 0B 0049**  			JP	XEQ
0B44CA             0050**  
0B44CA             0051**  ; CLS: clears the text area
0B44CA             0052**  ;
0B44CA 3E 0C       0053**  CLRSCN:			LD	A, 0Ch
0B44CC C3 FE 3F 0B 0054**  			JP	OSWRCH
0B44D0             0055**  
0B44D0             0056**  ; MODE n: Set video mode
0B44D0             0057**  ;
0B44D0 DD E5       0058**  MODE:			PUSH	IX			; Get the system vars in IX
0B44D2             0059**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B44D2 3E 08       0001**M 			LD	A, function
0B44D4 49 CF       0002**M 			RST.LIS	08h
0B44D6 DD CB 04 A6 0060**  			RES	4, (IX+sysvar_vpd_pflags)
0B44DA CD 08 04 0B 0061**  			CALL    EXPRI
0B44DE D9          0062**  			EXX
0B44DF             0063**  			VDU	16H			; Mode change
0B44DF 3E 16       0001**M 		LD	A, val
0B44E1 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B44E5             0064**  			VDU	L
0B44E5 7D          0001**M 		LD	A, val
0B44E6 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B44EA             0065**  			MOSCALL	mos_sysvars
0B44EA 3E 08       0001**M 			LD	A, function
0B44EC 49 CF       0002**M 			RST.LIS	08h
0B44EE DD CB 04 66 0066**  @@:			BIT	4, (IX+sysvar_vpd_pflags)
0B44F2 28 FA       0067**  			JR	Z, @B			; Wait for the result
0B44F4 DD E1       0068**  			POP	IX
0B44F6 C3 94 0C 0B 0069**  			JP	XEQ
0B44FA             0070**  
0B44FA             0071**  ; GET(x,y): Get the ASCII code of a character on screen
0B44FA             0072**  ;
0B44FA FD 23       0073**  GETSCHR:		INC	IY
0B44FC CD 08 04 0B 0074**  			CALL    EXPRI      		; Get X coordinate
0B4500 D9          0075**  			EXX
0B4501 22 00 4B 0B 0076**  			LD	(VDU_BUFFER+0), HL
0B4505 CD 20 0B 0B 0077**  			CALL	COMMA
0B4509 CD 08 04 0B 0078**  			CALL	EXPRI			; Get Y coordinate
0B450D D9          0079**  			EXX
0B450E 22 02 4B 0B 0080**  			LD	(VDU_BUFFER+2), HL
0B4512 CD 2D 0B 0B 0081**  			CALL	BRAKET			; Closing bracket
0B4516             0082**  ;
0B4516 DD E5       0083**  			PUSH	IX			; Get the system vars in IX
0B4518             0084**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B4518 3E 08       0001**M 			LD	A, function
0B451A 49 CF       0002**M 			RST.LIS	08h
0B451C DD CB 04 8E 0085**  			RES	1, (IX+sysvar_vpd_pflags)
0B4520             0086**  			VDU	23
0B4520 3E 17       0001**M 		LD	A, val
0B4522 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4526             0087**  			VDU	0
0B4526 3E 00       0001**M 		LD	A, val
0B4528 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B452C             0088**  			VDU	vdp_scrchar
0B452C 3E 83       0001**M 		LD	A, val
0B452E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4532             0089**  			VDU	(VDU_BUFFER+0)
0B4532 3A 00 4B 0B 0001**M 		LD	A, val
0B4536 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B453A             0090**  			VDU	(VDU_BUFFER+1)
0B453A 3A 01 4B 0B 0001**M 		LD	A, val
0B453E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4542             0091**  			VDU	(VDU_BUFFER+2)
0B4542 3A 02 4B 0B 0001**M 		LD	A, val
0B4546 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B454A             0092**  			VDU	(VDU_BUFFER+3)
0B454A 3A 03 4B 0B 0001**M 		LD	A, val
0B454E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4552 DD CB 04 4E 0093**  @@:			BIT	1, (IX+sysvar_vpd_pflags)
0B4556 28 FA       0094**  			JR	Z, @B			; Wait for the result
0B4558 DD 7E 09    0095**  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0B455B B7          0096**  			OR	A			; Check for 00h
0B455C 37          0097**  			SCF				; C = character map
0B455D 20 02       0098**  			JR	NZ, @F			; We have a character, so skip next bit
0B455F AF          0099**  			XOR	A			; Clear carry
0B4560 3D          0100**  			DEC	A			; Set A to FFh
0B4561 DD E1       0101**  @@:			POP	IX
0B4563 C3 DF 08 0B 0102**  			JP	INKEY1			; Jump back to the GET command
0B4567             0103**  
0B4567             0104**  ; POINT(x,y): Get the pixel colour of a point on screen
0B4567             0105**  ;
0B4567 CD 08 04 0B 0106**  POINT:			CALL    EXPRI      		; Get X coordinate
0B456B D9          0107**  			EXX
0B456C 22 00 4B 0B 0108**  			LD	(VDU_BUFFER+0), HL
0B4570 CD 20 0B 0B 0109**  			CALL	COMMA
0B4574 CD 08 04 0B 0110**  			CALL	EXPRI			; Get Y coordinate
0B4578 D9          0111**  			EXX
0B4579 22 02 4B 0B 0112**  			LD	(VDU_BUFFER+2), HL
0B457D CD 2D 0B 0B 0113**  			CALL	BRAKET			; Closing bracket
0B4581             0114**  ;
0B4581 DD E5       0115**  			PUSH	IX			; Get the system vars in IX
0B4583             0116**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B4583 3E 08       0001**M 			LD	A, function
0B4585 49 CF       0002**M 			RST.LIS	08h
0B4587 DD CB 04 96 0117**  			RES	2, (IX+sysvar_vpd_pflags)
0B458B             0118**  			VDU	23
0B458B 3E 17       0001**M 		LD	A, val
0B458D CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4591             0119**  			VDU	0
0B4591 3E 00       0001**M 		LD	A, val
0B4593 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4597             0120**  			VDU	vdp_scrpixel
0B4597 3E 84       0001**M 		LD	A, val
0B4599 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B459D             0121**  			VDU	(VDU_BUFFER+0)
0B459D 3A 00 4B 0B 0001**M 		LD	A, val
0B45A1 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B45A5             0122**  			VDU	(VDU_BUFFER+1)
0B45A5 3A 01 4B 0B 0001**M 		LD	A, val
0B45A9 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B45AD             0123**  			VDU	(VDU_BUFFER+2)
0B45AD 3A 02 4B 0B 0001**M 		LD	A, val
0B45B1 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B45B5             0124**  			VDU	(VDU_BUFFER+3)
0B45B5 3A 03 4B 0B 0001**M 		LD	A, val
0B45B9 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B45BD DD CB 04 56 0125**  @@:			BIT	2, (IX+sysvar_vpd_pflags)
0B45C1 28 FA       0126**  			JR	Z, @B			; Wait for the result
0B45C3             0127**  ;
0B45C3             0128**  ; Return the data as a 1 byte index
0B45C3             0129**  ;
0B45C3 DD 6E 16    0130**  			LD	L, (IX+sysvar_scrpixelIndex)
0B45C6 DD E1       0131**  			POP	IX
0B45C8 C3 7D 06 0B 0132**  			JP	COUNT0
0B45CC             0133**  
0B45CC             0134**  
0B45CC             0135**  ; COLOUR colour
0B45CC             0136**  ; COLOUR L,P
0B45CC             0137**  ; COLOUR L,R,G,B
0B45CC             0138**  ;
0B45CC CD 08 04 0B 0139**  COLOUR:			CALL	EXPRI			; The colour / mode
0B45D0 D9          0140**  			EXX
0B45D1 7D          0141**  			LD	A, L
0B45D2 32 00 4B 0B 0142**  			LD	(VDU_BUFFER+0), A	; Store first parameter
0B45D6 CD 6E 0B 0B 0143**  			CALL	NXT			; Are there any more parameters?
0B45DA FE 2C       0144**  			CP	','
0B45DC 28 12       0145**  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0B45DE             0146**  ;
0B45DE             0147**  			VDU	11h			; Just set the colour
0B45DE 3E 11       0001**M 		LD	A, val
0B45E0 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B45E4             0148**  			VDU	(VDU_BUFFER+0)
0B45E4 3A 00 4B 0B 0001**M 		LD	A, val
0B45E8 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B45EC C3 94 0C 0B 0149**  			JP	XEQ
0B45F0             0150**  ;
0B45F0 CD 20 0B 0B 0151**  COLOUR_1:		CALL	COMMA
0B45F4 CD 08 04 0B 0152**  			CALL	EXPRI			; Parse R (OR P)
0B45F8 D9          0153**  			EXX
0B45F9 7D          0154**  			LD	A, L
0B45FA 32 01 4B 0B 0155**  			LD	(VDU_BUFFER+1), A
0B45FE CD 6E 0B 0B 0156**  			CALL	NXT			; Are there any more parameters?
0B4602 FE 2C       0157**  			CP	','
0B4604 28 2C       0158**  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
0B4606             0159**  ;
0B4606             0160**  			VDU	13h			; VDU:COLOUR
0B4606 3E 13       0001**M 		LD	A, val
0B4608 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B460C             0161**  			VDU	(VDU_BUFFER+0)		; Logical Colour
0B460C 3A 00 4B 0B 0001**M 		LD	A, val
0B4610 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4614             0162**  			VDU	(VDU_BUFFER+1)		; Palette Colour
0B4614 3A 01 4B 0B 0001**M 		LD	A, val
0B4618 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B461C             0163**  			VDU	0			; RGB set to 0
0B461C 3E 00       0001**M 		LD	A, val
0B461E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4622             0164**  			VDU	0
0B4622 3E 00       0001**M 		LD	A, val
0B4624 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4628             0165**  			VDU	0
0B4628 3E 00       0001**M 		LD	A, val
0B462A CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B462E C3 94 0C 0B 0166**  			JP	XEQ
0B4632             0167**  ;
0B4632 CD 20 0B 0B 0168**  COLOUR_2:		CALL	COMMA
0B4636 CD 08 04 0B 0169**  			CALL	EXPRI			; Parse G
0B463A D9          0170**  			EXX
0B463B 7D          0171**  			LD	A, L
0B463C 32 02 4B 0B 0172**  			LD	(VDU_BUFFER+2), A
0B4640 CD 20 0B 0B 0173**  			CALL	COMMA
0B4644 CD 08 04 0B 0174**  			CALL	EXPRI			; Parse B
0B4648 D9          0175**  			EXX
0B4649 7D          0176**  			LD	A, L
0B464A 32 03 4B 0B 0177**  			LD	(VDU_BUFFER+3), A
0B464E             0178**  			VDU	13h			; VDU:COLOUR
0B464E 3E 13       0001**M 		LD	A, val
0B4650 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4654             0179**  			VDU	(VDU_BUFFER+0)		; Logical Colour
0B4654 3A 00 4B 0B 0001**M 		LD	A, val
0B4658 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B465C             0180**  			VDU	FFh			; Physical Colour (-1 for RGB mode)
0B465C 3E FF       0001**M 		LD	A, val
0B465E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4662             0181**  			VDU	(VDU_BUFFER+1)		; R
0B4662 3A 01 4B 0B 0001**M 		LD	A, val
0B4666 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B466A             0182**  			VDU	(VDU_BUFFER+2)		; G
0B466A 3A 02 4B 0B 0001**M 		LD	A, val
0B466E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4672             0183**  			VDU	(VDU_BUFFER+3)		; B
0B4672 3A 03 4B 0B 0001**M 		LD	A, val
0B4676 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B467A C3 94 0C 0B 0184**  			JP	XEQ
0B467E             0185**  
0B467E             0186**  ; GCOL mode,colour
0B467E             0187**  ;
0B467E CD 08 04 0B 0188**  GCOL:			CALL	EXPRI			; Parse MODE
0B4682 D9          0189**  			EXX
0B4683 7D          0190**  			LD	A, L
0B4684 32 00 4B 0B 0191**  			LD	(VDU_BUFFER+0), A
0B4688 CD 20 0B 0B 0192**  			CALL	COMMA
0B468C             0193**  ;
0B468C CD 08 04 0B 0194**  			CALL	EXPRI			; Parse Colour
0B4690 D9          0195**  			EXX
0B4691 7D          0196**  			LD	A, L
0B4692 32 01 4B 0B 0197**  			LD	(VDU_BUFFER+1), A
0B4696             0198**  ;
0B4696             0199**  			VDU	12h			; VDU:GCOL
0B4696 3E 12       0001**M 		LD	A, val
0B4698 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B469C             0200**  			VDU	(VDU_BUFFER+0)		; Mode
0B469C 3A 00 4B 0B 0001**M 		LD	A, val
0B46A0 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46A4             0201**  			VDU	(VDU_BUFFER+1)		; Colour
0B46A4 3A 01 4B 0B 0001**M 		LD	A, val
0B46A8 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46AC C3 94 0C 0B 0202**  			JP	XEQ
0B46B0             0203**  
0B46B0             0204**  ; PLOT mode,x,y
0B46B0             0205**  ;
0B46B0 CD 08 04 0B 0206**  PLOT:			CALL	EXPRI		; Parse mode
0B46B4 D9          0207**  			EXX
0B46B5 E5          0208**  			PUSH	HL		; Push mode (L) onto stack
0B46B6 CD 20 0B 0B 0209**  			CALL	COMMA
0B46BA CD A3 44 0B 0210**  			CALL	EXPR_W2		; Parse X and Y
0B46BE C1          0211**  			POP	BC		; Pop mode (C) off stack
0B46BF             0212**  PLOT_1:			VDU	19H		; VDU code for PLOT
0B46BF 3E 19       0001**M 		LD	A, val
0B46C1 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46C5             0213**  			VDU	C		;  C: Mode
0B46C5 79          0001**M 		LD	A, val
0B46C6 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46CA             0214**  			VDU	E		; DE: X
0B46CA 7B          0001**M 		LD	A, val
0B46CB CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46CF             0215**  			VDU	D
0B46CF 7A          0001**M 		LD	A, val
0B46D0 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46D4             0216**  			VDU	L		; HL: Y
0B46D4 7D          0001**M 		LD	A, val
0B46D5 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46D9             0217**  			VDU	H
0B46D9 7C          0001**M 		LD	A, val
0B46DA CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46DE C3 94 0C 0B 0218**  			JP	XEQ
0B46E2             0219**  
0B46E2             0220**  ; MOVE x,y
0B46E2             0221**  ;
0B46E2 CD A3 44 0B 0222**  MOVE:			CALL	EXPR_W2		; Parse X and Y
0B46E6 0E 04       0223**  			LD	C, 04H		; Plot mode 04H (Move)
0B46E8 18 D5       0224**  			JR	PLOT_1		; Plot
0B46EA             0225**  
0B46EA             0226**  ; DRAW x1,y1
0B46EA             0227**  ; DRAW x1,y1,x2,y2
0B46EA             0228**  ;
0B46EA CD A3 44 0B 0229**  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0B46EE CD 6E 0B 0B 0230**  			CALL	NXT		; Are there any more parameters?
0B46F2 FE 2C       0231**  			CP	','
0B46F4 0E 05       0232**  			LD	C, 05h		; Code for LINE
0B46F6 20 C7       0233**  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0B46F8             0234**  			VDU	19h		; Move to the first coordinates
0B46F8 3E 19       0001**M 		LD	A, val
0B46FA CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B46FE             0235**  			VDU	04h
0B46FE 3E 04       0001**M 		LD	A, val
0B4700 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4704             0236**  			VDU	E
0B4704 7B          0001**M 		LD	A, val
0B4705 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4709             0237**  			VDU	D
0B4709 7A          0001**M 		LD	A, val
0B470A CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B470E             0238**  			VDU	L
0B470E 7D          0001**M 		LD	A, val
0B470F CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4713             0239**  			VDU	H
0B4713 7C          0001**M 		LD	A, val
0B4714 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4718 CD 20 0B 0B 0240**  			CALL	COMMA
0B471C C5          0241**  			PUSH	BC
0B471D CD A3 44 0B 0242**  			CALL	EXPR_W2		; Get X2 and Y2
0B4721 C1          0243**  			POP	BC
0B4722 18 9B       0244**  			JR	PLOT_1		; Now DRAW the line to those positions
0B4724             0245**  
0B4724             0246**  
0B4724             0247**  
0B4724             0014*       include "basic/agon_sound.asm"
0B4724             0001**  ;
0B4724             0002**  ; Title:	BBC Basic for AGON - Audio stuff
0B4724             0003**  ; Author:	Dean Belfield
0B4724             0004**  ; Created:	12/05/2023
0B4724             0005**  ; Last Updated:	12/05/2023
0B4724             0006**  ;
0B4724             0007**  ; Modinfo:
0B4724             0008**  
0B4724             0009**  			; .ASSUME	ADL = 1
0B4724             0010**  
0B4724             0011**  			; INCLUDE	"equs.inc"
0B4724             0012**  			; INCLUDE "macros.inc"
0B4724             0013**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B4724             0014**  
0B4724             0015**  			; SEGMENT CODE
0B4724             0016**  
0B4724             0017**  			; XDEF	SOUND
0B4724             0018**  
0B4724             0019**  			; XREF	COMMA
0B4724             0020**  			; XREF	EXPR_W2
0B4724             0021**  			; XREF	XEQ
0B4724             0022**  			; XREF	LTRAP
0B4724             0023**  			; XREF	OSWRCH
0B4724             0024**  			; XREF	VDU_BUFFER
0B4724             0025**  
0B4724             0026**  
0B4724             0027**  ; SOUND channel,volume,pitch,duration
0B4724             0028**  ; volume: 0 (off) to -15 (full volume)
0B4724             0029**  ; pitch: 0 - 255
0B4724             0030**  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
0B4724             0031**  ;
0B4724 CD A3 44 0B 0032**  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
0B4728 7D          0033**  			LD	A, L 			;  A: Volume
0B4729 F5          0034**  			PUSH	AF
0B472A D5          0035**  			PUSH	DE
0B472B CD 20 0B 0B 0036**  			CALL	COMMA
0B472F CD A3 44 0B 0037**  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
0B4733 53          0038**  			LD	D, E			;  D: Pitch
0B4734 5D          0039**  			LD	E, L 			;  E: Duration
0B4735 E1          0040**  			POP	HL 			; HL: Channel/Control
0B4736 F1          0041**  			POP	AF
0B4737 ED 44       0042**  			NEG
0B4739 FE 10       0043**  			CP	16			; Check volume is in bounds
0B473B D2 94 0C 0B 0044**  			JP	NC, XEQ			; Out of bounds, do nothing
0B473F             0045**  ;
0B473F             0046**  ; Store	in VDU vars
0B473F             0047**  ;
0B473F 4F          0048**  			LD	C, A			; Store Volume in C
0B4740 7D          0049**  			LD	A, L
0B4741 32 00 4B 0B 0050**  			LD	(VDU_BUFFER+0), A	; Channel
0B4745 AF          0051**  			XOR	A
0B4746 32 01 4B 0B 0052**  			LD	(VDU_BUFFER+1), A	; Waveform
0B474A             0053**  ;
0B474A             0054**  ; Calculate the volume
0B474A             0055**  ;
0B474A 06 06       0056**  			LD	B, 6			; C already contains the volume
0B474C ED 4C       0057**  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0B474E 79          0058**  			LD	A, C
0B474F 32 02 4B 0B 0059**  			LD	(VDU_BUFFER+2), A
0B4753             0060**  ;
0B4753             0061**  ; And the frequency
0B4753             0062**  ;
0B4753 4B          0063**  			LD	C, E			; Store duration in C
0B4754 26 00       0064**  			LD	H, 0			; Lookup the frequency
0B4756 6A          0065**  			LD	L, D
0B4757 11 DE 47 0B 0066**  			LD	DE, SOUND_FREQ_LOOKUP
0B475B 29          0067**  			ADD	HL, HL
0B475C 19          0068**  			ADD	HL, DE
0B475D 7E          0069**  			LD	A, (HL)
0B475E 32 03 4B 0B 0070**  			LD	(VDU_BUFFER+3), A
0B4762 23          0071**  			INC	HL
0B4763 7E          0072**  			LD	A, (HL)
0B4764 32 04 4B 0B 0073**  			LD	(VDU_BUFFER+4), A
0B4768             0074**  ;
0B4768             0075**  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0B4768             0076**  ;
0B4768 06 32       0077**  			LD	B, 50			; C contains the duration, so MLT by 50
0B476A ED 4C       0078**  			MLT	BC
0B476C ED 43 05 4B 0079**  			LD	(VDU_BUFFER+5), BC
       0B          
0B4771             0080**  ;
0B4771 DD E5       0081**  			PUSH	IX			; Get the system vars in IX
0B4773             0082**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B4773 3E 08       0001**M 			LD	A, function
0B4775 49 CF       0002**M 			RST.LIS	08h
0B4777 5B DD CB 04 0083**  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0B477C             0084**  ;
0B477C             0085**  			VDU	23			; Send the sound command
0B477C 3E 17       0001**M 		LD	A, val
0B477E CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4782             0086**  			VDU	0
0B4782 3E 00       0001**M 		LD	A, val
0B4784 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4788             0087**  			VDU	vdp_audio
0B4788 3E 85       0001**M 		LD	A, val
0B478A CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B478E             0088**  			VDU	(VDU_BUFFER+0)		; 0: Channel
0B478E 3A 00 4B 0B 0001**M 		LD	A, val
0B4792 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B4796             0089**  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0B4796 3A 01 4B 0B 0001**M 		LD	A, val
0B479A CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B479E             0090**  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0B479E 3A 02 4B 0B 0001**M 		LD	A, val
0B47A2 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B47A6             0091**  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0B47A6 3A 03 4B 0B 0001**M 		LD	A, val
0B47AA CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B47AE             0092**  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0B47AE 3A 04 4B 0B 0001**M 		LD	A, val
0B47B2 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B47B6             0093**  			VDU	(VDU_BUFFER+5)		; 5: Duration L
0B47B6 3A 05 4B 0B 0001**M 		LD	A, val
0B47BA CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B47BE             0094**  			VDU	(VDU_BUFFER+6)		; 6: Duration H
0B47BE 3A 06 4B 0B 0001**M 		LD	A, val
0B47C2 CD FE 3F 0B 0002**M 		CALL	OSWRCH
0B47C6             0095**  ;
0B47C6             0096**  ; Wait for acknowledgement
0B47C6             0097**  ;
0B47C6 5B DD CB 04 0098**  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
0B47CB 28 F9       0099**  			JR	Z, @B			; Wait for the result
0B47CD CD 6F 40 0B 0100**  			CALL	LTRAP			; Check for ESC
0B47D1 5B DD 7E 0E 0101**  			LD.LIL	A, (IX+sysvar_audioSuccess)
0B47D5 A7          0102**  			AND	A			; Check if VDP has queued the note
0B47D6 28 9F       0103**  			JR	Z, SOUND0		; No, so loop back and send again
0B47D8             0104**  ;
0B47D8 DD E1       0105**  			POP	IX
0B47DA C3 94 0C 0B 0106**  			JP	XEQ
0B47DE             0107**  
0B47DE             0108**  ; Frequency Lookup Table
0B47DE             0109**  ; Set up to replicate the BBC Micro audio frequencies
0B47DE             0110**  ;
0B47DE             0111**  ; Split over 5 complete octaves, with 53 being middle C
0B47DE             0112**  ; * C4: 262hz
0B47DE             0113**  ; + A4: 440hz
0B47DE             0114**  ;
0B47DE             0115**  ;	2	3	4	5	6	7	8
0B47DE             0116**  ;
0B47DE             0117**  ; B	1	49	97	145	193	241
0B47DE             0118**  ; A#	0	45	93	141	189	237
0B47DE             0119**  ; A		41	89+	137	185	233
0B47DE             0120**  ; G#		37	85	133	181	229
0B47DE             0121**  ; G		33	81	129	177	225
0B47DE             0122**  ; F#		29	77	125	173	221
0B47DE             0123**  ; F		25	73	121	169	217
0B47DE             0124**  ; E		21	69	117	165	213
0B47DE             0125**  ; D#		17	65	113	161	209
0B47DE             0126**  ; D		13	61	109	157	205	253
0B47DE             0127**  ; C#		9	57	105	153	201	249
0B47DE             0128**  ; C		5	53*	101	149	197	245
0B47DE             0129**  ;
0B47DE 75 00 76 00 0130**  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
0B47EE 89 00 8B 00 0131**  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
0B47FE 99 00 9C 00 0132**  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
0B480E AC 00 AF 00 0133**  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
0B481E C1 00 C4 00 0134**  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
0B482E D9 00 DC 00 0135**  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
0B483E F3 00 F7 00 0136**  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
0B484E 11 01 15 01 0137**  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0B485E 33 01 37 01 0138**  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0B486E 58 01 5D 01 0139**  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0B487E 82 01 88 01 0140**  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0B488E B2 01 B8 01 0141**  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0B489E E7 01 EE 01 0142**  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0B48AE 22 02 2A 02 0143**  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
0B48BE 65 02 6E 02 0144**  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
0B48CE B1 02 BB 02 0145**  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
0B48DE 05 03 10 03 0146**  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
0B48EE 63 03 70 03 0147**  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
0B48FE CE 03 DC 03 0148**  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
0B490E 45 04 55 04 0149**  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
0B491E CB 04 DD 04 0150**  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
0B492E 62 05 76 05 0151**  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
0B493E 0A 06 21 06 0152**  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
0B494E C8 06 E1 06 0153**  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0B495E 9C 07 B8 07 0154**  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0B496E 8A 08 A9 08 0155**  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0B497E 95 09 B9 09 0156**  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0B498E C2 0A EA 0A 0157**  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0B499E 13 0C 40 0C 0158**  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0B49AE 8E 0D C0 0D 0159**  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
0B49BE 36 0F 6F 0F 0160**  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
0B49CE 13 11 53 11 0161**  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
0B49DE             0162**  
0B49DE             0163**  
0B49DE             0015*       include "basic/interrupts.asm"
0B49DE             0001**  ;
0B49DE             0002**  ; Title:	BBC Basic for AGON - Interrupts
0B49DE             0003**  ; Author:	Dean Belfield
0B49DE             0004**  ; Created:	12/05/2023
0B49DE             0005**  ; Last Updated:	07/06/2023
0B49DE             0006**  ;
0B49DE             0007**  ; Modinfo:
0B49DE             0008**  ; 07/06/2023:	Modified to run in ADL mode
0B49DE             0009**  
0B49DE             0010**  			; .ASSUME	ADL = 1
0B49DE             0011**  
0B49DE             0012**  			; INCLUDE	"macros.inc"
0B49DE             0013**  			; INCLUDE	"equs.inc"
0B49DE             0014**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B49DE             0015**  
0B49DE             0016**  			; SEGMENT CODE
0B49DE             0017**  
0B49DE             0018**  			; XDEF	VBLANK_INIT
0B49DE             0019**  			; XDEF	VBLANK_STOP
0B49DE             0020**  			; XDEF	VBLANK_HANDLER
0B49DE             0021**  
0B49DE             0022**  			; XREF	ESCSET
0B49DE             0023**  			; XREF	KEYDOWN		; In ram.asm
0B49DE             0024**  			; XREF	KEYASCII 	; In ram.asm
0B49DE             0025**  			; XREF	KEYCOUNT	; In ram.asm
0B49DE             0026**  
0B49DE             0027**  ; Hook into the MOS VBLANK interrupt
0B49DE             0028**  ;
0B49DE F3          0029**  VBLANK_INIT:		DI
0B49DF 21 33 4A 0B 0030**  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0B49E3 1E 32       0031**  			LD		E, 32h				; Set up the VBlank Interrupt Vector
0B49E5             0032**  			MOSCALL		mos_setintvector
0B49E5 3E 14       0001**M 			LD	A, function
0B49E7 49 CF       0002**M 			RST.LIS	08h
0B49E9             0033**  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0B49E9 EB          0034**  			ex de,hl
0B49EA 21 41 4A 0B 0035**  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B49EE ED 1F       0036**  			LD		(HL), DE			; Self-modify the code
0B49F0 FB          0037**  			EI
0B49F1 C9          0038**  			RET
0B49F2             0039**  
0B49F2             0040**  ; Unhook the custom VBLANK interrupt
0B49F2             0041**  ;
0B49F2 F3          0042**  VBLANK_STOP:		DI
0B49F3 21 41 4A 0B 0043**  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B49F7 ED 17       0044**  			LD		DE, (HL)
0B49F9 EB          0045**  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
0B49FA 1E 32       0046**  			LD		E, 32h
0B49FC             0047**  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0B49FC 3E 14       0001**M 			LD	A, function
0B49FE 49 CF       0002**M 			RST.LIS	08h
0B4A00 FB          0048**  			EI
0B4A01 C9          0049**  			RET
0B4A02             0050**  
0B4A02             0051**  ; A safe LIS call to ESCSET
0B4A02             0052**  ;
0B4A02             0053**  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
0B4A02 3E 08       0001**M 			LD	A, function
0B4A04 49 CF       0002**M 			RST.LIS	08h
0B4A06 21 49 4E 0B 0054**  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
0B4A0A DD 7E 19    0055**  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
0B4A0D BE          0056**  			CP 		(HL)				; with our local copy
0B4A0E 20 0A       0057**  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
0B4A10             0058**  ;
0B4A10 AF          0059**  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
0B4A11 32 48 4E 0B 0060**  			LD		(KEYASCII), A
0B4A15 32 47 4E 0B 0061**  			LD		(KEYDOWN), A
0B4A19 C9          0062**  			RET	 					; And return
0B4A1A             0063**  ;
0B4A1A 77          0064**  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
0B4A1B DD 7E 18    0065**  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
0B4A1E B7          0066**  			OR		A
0B4A1F 28 EF       0067**  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
0B4A21             0068**  ;
0B4A21 32 47 4E 0B 0069**  			LD		(KEYDOWN), A 			; Store the keydown value
0B4A25 DD 7E 05    0070**  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
0B4A28 32 48 4E 0B 0071**  			LD		(KEYASCII), A 			; Store locally
0B4A2C FE 1B       0072**  			CP		1Bh				; Is it escape?
0B4A2E CC 4A 40 0B 0073**  			CALL		Z, ESCSET			; Yes, so set the escape flags
0B4A32 C9          0074**  			RET						; Return to the interrupt handler
0B4A33             0075**  
0B4A33 F3          0076**  VBLANK_HANDLER:		DI
0B4A34 F5          0077**  			PUSH		AF
0B4A35 E5          0078**  			PUSH		HL
0B4A36 DD E5       0079**  			PUSH		IX
0B4A38 CD 02 4A 0B 0080**  			CALL		DO_KEYBOARD
0B4A3C DD E1       0081**  			POP		IX
0B4A3E E1          0082**  			POP		HL
0B4A3F F1          0083**  			POP		AF
0B4A40             0084**  ;
0B4A40             0085**  ; Finally jump to the MOS interrupt
0B4A40             0086**  ;
0B4A40 C3 00 00 00 0087**  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0B4A44             0016*       include "basic/ram.asm"
0B4A44             0001**  ;
0B4A44             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B4A44             0003**  ;		RAM Module for BBC Basic Interpreter
0B4A44             0004**  ;		For use with Version 2.0 of BBC BASIC
0B4A44             0005**  ;		Standard CP/M Distribution Version
0B4A44             0006**  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0B4A44             0007**  ; Modified By:	Dean Belfield
0B4A44             0008**  ; Created:	12/05/2023
0B4A44             0009**  ; Last Updated:	26/06/2023
0B4A44             0010**  ;
0B4A44             0011**  ; Modinfo:
0B4A44             0012**  ; 06/06/2023:	Modified to run in ADL mode
0B4A44             0013**  ; 26/06/2023:	Added temporary stores R0 and R1
0B4A44             0014**  
0B4A44             0015**  			; .ASSUME	ADL = 1
0B4A44             0016**  
0B4A44             0017**  			; DEFINE	LORAM, SPACE = ROM
0B4A44             0018**  			; SEGMENT LORAM
0B4A44             0019**  
0B4A44             0020**  			; XDEF	ACCS
0B4A44             0021**  			; XDEF	BUFFER
0B4A44             0022**  			; XDEF	STAVAR
0B4A44             0023**  			; XDEF	DYNVAR
0B4A44             0024**  			; XDEF	FNPTR
0B4A44             0025**  			; XDEF	PROPTR
0B4A44             0026**  			; XDEF	PAGE_
0B4A44             0027**  			; XDEF	TOP
0B4A44             0028**  			; XDEF	LOMEM
0B4A44             0029**  			; XDEF 	FREE
0B4A44             0030**  			; XDEF	HIMEM
0B4A44             0031**  			; XDEF	LINENO
0B4A44             0032**  			; XDEF	TRACEN
0B4A44             0033**  			; XDEF	AUTONO
0B4A44             0034**  			; XDEF	ERRTRP
0B4A44             0035**  			; XDEF	ERRTXT
0B4A44             0036**  			; XDEF	DATPTR
0B4A44             0037**  			; XDEF	ERL
0B4A44             0038**  			; XDEF	ERRLIN
0B4A44             0039**  			; XDEF	RANDOM
0B4A44             0040**  			; XDEF	COUNT
0B4A44             0041**  			; XDEF	WIDTH
0B4A44             0042**  			; XDEF	ERR
0B4A44             0043**  			; XDEF	LISTON
0B4A44             0044**  			; XDEF	INCREM
0B4A44             0045**  
0B4A44             0046**  			; XDEF	FLAGS
0B4A44             0047**  			; XDEF	OSWRCHPT
0B4A44             0048**  			; XDEF	OSWRCHCH
0B4A44             0049**  			; XDEF	OSWRCHFH
0B4A44             0050**  			; XDEF	KEYDOWN
0B4A44             0051**  			; XDEF	KEYASCII
0B4A44             0052**  			; XDEF	KEYCOUNT
0B4A44             0053**  
0B4A44             0054**  			; XDEF	R0
0B4A44             0055**  			; XDEF	R1
0B4A44             0056**  
0B4A44             0057**  			; XDEF	RAM_START
0B4A44             0058**  			; XDEF	RAM_END
0B4A44             0059**  			; XDEF	USER
0B4A44             0060**  
0B4A44             0061**  end_binary: ;  for assemble.py to know where to truncate the binary file
0B4A44 FF FF FF FF 0062**  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B4B00             0063**  RAM_START:
0B4B00             0064**  ;
0B4B00 00 00 00 00 0065**  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4C00 00 00 00 00 0066**  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4D00 00 00 00 00 0067**  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4D6C 00 00 00 00 0068**  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
0B4E0E 00 00 00    0069**  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B4E11 00 00 00    0070**  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B4E14             0071**  ;
0B4E14 00 00 00    0072**  PAGE_:          BLKB    3,0               ; Start of User Program
0B4E17 00 00 00    0073**  TOP:            BLKB    3,0               ; First Location after User Program
0B4E1A 00 00 00    0074**  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B4E1D 00 00 00    0075**  FREE:           BLKB    3,0               ; First Free Space Byte
0B4E20 00 00 00    0076**  HIMEM:          BLKB    3,0               ; First Protected Byte
0B4E23             0077**  ;
0B4E23 00 00 00    0078**  LINENO:         BLKB    3,0               ; Line Number
0B4E26 00 00 00    0079**  TRACEN:         BLKB    3,0               ; Trace Flag
0B4E29 00 00 00    0080**  AUTONO:         BLKB    3,0               ; Auto Flag
0B4E2C 00 00 00    0081**  ERRTRP:         BLKB    3,0               ; Error Trap
0B4E2F 00 00       0082**  ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B4E31 00 00       0083**  DATPTR:         BLKB    2,0               ; Data Pointer
0B4E33 00 00       0084**  ERL:            BLKB    2,0               ; Error Line
0B4E35 00 00 00    0085**  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B4E38 00 00 00 00 0086**  RANDOM:         BLKB    5,0               ; Random Number
       00          
0B4E3D 00          0087**  COUNT:          BLKB    1,0               ; Print Position
0B4E3E 00          0088**  WIDTH:          BLKB    1,0               ; Print Width
0B4E3F 00          0089**  ERR:            BLKB    1,0               ; Error Number
0B4E40 00          0090**  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
0B4E41             0091**                                  ; - BIT 0: If set, output a space after the line number
0B4E41             0092**                                  ; - BIT 1: If set, then indent FOR/NEXT loops
0B4E41             0093**                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
0B4E41             0094**                                  ; - BIT 3: If set, then output to buffer for *EDIT
0B4E41             0095**                                  ; OPT FLAG (top nibble)
0B4E41             0096**                                  ; - BIT 4: If set, then list whilst assembling
0B4E41             0097**                                  ; - BIT 5: If set, then assembler errors are reported
0B4E41             0098**                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
0B4E41             0099**                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B4E41 00          0100**  INCREM:         BLKB    1,0               ; Auto-Increment Value
0B4E42             0101**  ;
0B4E42             0102**  ; --------------------------------------------------------------------------------------------
0B4E42             0103**  ; BEGIN MODIFIED CODE
0B4E42             0104**  ; --------------------------------------------------------------------------------------------
0B4E42             0105**  ; Originally in equs.inc
0B4E42             0106**  ;
0B4E42             0107**  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
0B4E42             0108**  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
0B4E42             0109**  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
0B4E42             0110**  ; --------------------------------------------------------------------------------------------
0B4E42             0111**  ; END MODIFIED CODE
0B4E42             0112**  ; --------------------------------------------------------------------------------------------
0B4E42             0113**  
0B4E42             0114**  ; Extra Agon-implementation specific system variables
0B4E42             0115**  ;
0B4E42 00          0116**  FLAGS:          BLKB    1,0       ; Miscellaneous flags
0B4E43             0117**                                  ; - BIT 7: Set if ESC pressed
0B4E43             0118**                                  ; - BIT 6: Set to disable ESC
0B4E43 00 00       0119**  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B4E45 00          0120**  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
0B4E46             0121**                                  ; - 0: Console
0B4E46             0122**                                  ; - 1: File
0B4E46 00          0123**  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B4E47 00          0124**  KEYDOWN:        BLKB    1,0       ; Keydown flag
0B4E48 00          0125**  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B4E49 00          0126**  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B4E4A 00 00 00    0127**  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B4E4D 00 00 00    0128**  R1:             BLKB    3,0
0B4E50             0129**  
0B4E50             0130**  ;
0B4E50             0131**  ; This must be at the end
0B4E50             0132**  ;
0B4E50             0133**  RAM_END:
0B4E50 FF FF FF FF 0134**  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B4F00             0135**  USER:							; Must be aligned on a page boundary
0B4F00             0136**  
0B4F00             0160    
0B4F00             0161    ; Storage for the argv array pointers
0B4F00             0162    min_args: equ 2
0B4F00             0163    argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B4F00 00 00 00 00 0164    argv_ptrs:		    BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4F30             0165    _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
0B4F33             0166    
0B4F33             0167    ; GLOBAL MESSAGE STRINGS
0B4F33 55 73 61 67 0168    str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B4F4B 45 72 72 6F 0169    str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B4F54 53 75 63 63 0170    str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B4F5F             0171    
0B4F5F             0172    ; ========= MAIN LOOP =========
0B4F5F             0173    ; The main routine
0B4F5F             0174    ; IXU: argv - pointer to array of parameters
0B4F5F             0175    ;   C: argc - number of parameters
0B4F5F             0176    ; Returns:
0B4F5F             0177    ;  HL: Error code, or 0 if OK
0B4F5F             0178    
0B4F5F             0179    _main:
0B4F5F 79          0180        ld a,c              ; how many arguments?
0B4F60 FE 02       0181        cp min_args         ; not enough?
0B4F62 30 27       0182        jr nc,main          ; if enough, go to main loop
0B4F64 21 33 4F 0B 0183        ld hl,str_usage     ; if not enough, print usage
0B4F68 CD 16 01 0B 0184        call printString
0B4F6C             0185                            ; fall through to _main_end_error
0B4F6C             0186    
0B4F6C             0187    _main_end_error:
0B4F6C 21 4B 4F 0B 0188        ld hl,str_error     ; print error message
0B4F70 CD 16 01 0B 0189        call printString
0B4F74 21 13 00 00 0190        ld hl,19            ; return error code 19
0B4F78 C9          0191        ret
0B4F79             0192    
0B4F79             0193    ; begin BASIC-specific end code
0B4F79             0194    ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B4F79 ED 7B 30 4F 0195    _basic_end:			LD		SP, (_sps)		; Restore the stack pointer
       0B          
0B4F7E             0196    ; fall through to _main_end_ok
0B4F7E             0197    ; end BASIC-specific end code
0B4F7E             0198    
0B4F7E             0199    _main_end_ok:
0B4F7E 21 54 4F 0B 0200        ld hl,str_success   ; print success message
0B4F82 CD 16 01 0B 0201        call printString
0B4F86 21 00 00 00 0202        ld hl,0             ; return 0 for success
0B4F8A C9          0203        ret
0B4F8B             0204    
0B4F8B             0205    ; ========= BEGIN CUSTOM MAIN LOOP =========
0B4F8B             0206    main:
0B4F8B 0D          0207        dec c               ; decrement the argument count to skip the program name
0B4F8C ED 32 03    0208        lea ix,ix+3         ; point to the first real argument (argv_ptrs+3)
0B4F8F DD 27 00    0209        ld hl,(ix)          ; get the first argument in case hl doesn't land here with it
0B4F92             0210    
0B4F92 3E 00       0211        ld a,0 ; DEBUG
0B4F94             0212        ; call dumpMemoryHex ; DEBUG
0B4F94             0213        ; call dumpRegistersHex ; DEBUG
0B4F94 CD 16 01 0B 0214        call printString  ; DEBUG
0B4F98 CD 2B 01 0B 0215        call printNewLine ; DEBUG
0B4F9C             0216        ; call print_params   ; DEBUG
0B4F9C             0217    
0B4F9C DD 31 00    0218        ld iy,(ix)           ; point to the expression
0B4F9F CD C5 02 0B 0219        call EXPR ; send the expression to the BASIC interpreter for evaluation and execution
0B4FA3 F2 B7 4F 0B 0220        jp p,@print_dec
0B4FA7 21 00 4B 0B 0221        ld hl,ACCS ; result is a string
0B4FAB CD 16 01 0B 0222        call printString
0B4FAF CD 2B 01 0B 0223        call printNewLine
0B4FB3 C3 7E 4F 0B 0224        jp _main_end_ok     ; return success
0B4FB7             0225    
0B4FB7             0226    @print_dec:
0B4FB7 CD FB 01 0B 0227        call print_float_dec ; print the result
0B4FBB CD 2B 01 0B 0228        call printNewLine
0B4FBF C3 7E 4F 0B 0229        jp _main_end_ok     ; return success
0B4FC3             0230    
0B4FC3             0231        ; call dumpRegistersHex ; DEBUG
0B4FC3             0232        ; call printNewLine
0B4FC3             0233        ; call dumpRegistersHex ; DEBUG
0B4FC3             0234    
0B4FC3             0235    
0B4FC3             0236    ; ========== HELPER FUNCTIONS ==========
0B4FC3             0237    ;
0B4FC3             0238    ; ; get the next argument after ix as a floating point number
0B4FC3             0239    ; ; inputs: ix = pointer to the argument string
0B4FC3             0240    ; ; outputs: HLH'L'C = floating point number, ix points to the next argument
0B4FC3             0241    ; ; destroys: everything except iy, including prime registers
0B4FC3             0242    ; get_arg_float:
0B4FC3             0243    ;     lea ix,ix+3 ; point to the next argument
0B4FC3             0244    ;     push ix ; preserve
0B4FC3             0245    ;     ld ix,(ix)  ; point to argument string
0B4FC3             0246    ;     call VAL ; convert the string to a float
0B4FC3             0247    ;     pop ix ; restore
0B4FC3             0248    ;     ret ; return with the value in HLH'L'C
0B4FC3             0249    ;
0B4FC3             0250    ; get the next argument after ix as a string
0B4FC3             0251    ; inputs: ix = pointer to the argument string
0B4FC3             0252    ; outputs: HL = pointer to the argument string, ix points to the next argument
0B4FC3             0253    ; destroys: a, h, l, f
0B4FC3             0254    get_arg_text:
0B4FC3 ED 32 03    0255        lea ix,ix+3 ; point to the next argument
0B4FC6 DD 27 00    0256        ld hl,(ix)  ; get the argument string
0B4FC9 C9          0257        ret
0B4FCA             0258    ;
0B4FCA             0259    ; ; match the next argument after ix to the dispatch table at iy
0B4FCA             0260    ; ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B4FCA             0261    ; ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B4FCA             0262    ; ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B4FCA             0263    ; ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B4FCA             0264    ; ; destroys: a, hl, de, ix, iy, flags
0B4FCA             0265    ; match_next:
0B4FCA             0266    ;     lea ix,ix+3         ; point to the next argument
0B4FCA             0267    ; @loop:
0B4FCA             0268    ;     ld hl,(iy)          ; pointer argument dispatch record
0B4FCA             0269    ;     sign_hlu            ; check for list terminator
0B4FCA             0270    ;     jp z,@no_match      ; if a=0, return error
0B4FCA             0271    ;     inc hl              ; skip over jp instruction
0B4FCA             0272    ;     inc hl
0B4FCA             0273    ;     ld de,(ix)          ; pointer to the argument string
0B4FCA             0274    ;     call str_equal      ; compare the argument to the dispatch table entry
0B4FCA             0275    ;     jp z,@match         ; if equal, return success
0B4FCA             0276    ;     lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B4FCA             0277    ;     jp @loop            ; and loop
0B4FCA             0278    ; @no_match:
0B4FCA             0279    ;     inc a               ; no match so return a=1 and zero flag reset
0B4FCA             0280    ;     ret
0B4FCA             0281    ; @match:
0B4FCA             0282    ;     ld iy,(iy)          ; get the function pointer
0B4FCA             0283    ;     ret                 ; return a=0 and zero flag set
0B4FCA             0284    
0B4FCA             0285    ; ; same as match_next, but prints the parameter if a match is found
0B4FCA             0286    ; match_next_and_print:
0B4FCA             0287    ;     call match_next
0B4FCA             0288    ;     ret nz ; no match found
0B4FCA             0289    ;     lea ix,ix-3
0B4FCA             0290    ;     call get_arg_text ; hl points to the operator string
0B4FCA             0291    ;     call print_param
0B4FCA             0292    ;     ret
0B4FCA             0293    
0B4FCA             0294    ; ; compare two zero-terminated strings for equality, case-sensitive
0B4FCA             0295    ; ; hl: pointer to first string, de: pointer to second string
0B4FCA             0296    ; ; returns: z if equal, nz if not equal
0B4FCA             0297    ; ; destroys: a, hl, de
0B4FCA             0298    ; str_equal:
0B4FCA             0299    ;     ld a,(de)           ; get the first character
0B4FCA             0300    ;     cp (hl)             ; compare to the second character
0B4FCA             0301    ;     ret nz              ; if not equal, return
0B4FCA             0302    ;     or a
0B4FCA             0303    ;     ret z               ; if equal and zero, return
0B4FCA             0304    ;     inc hl              ; next character
0B4FCA             0305    ;     inc de
0B4FCA             0306    ;     jp str_equal        ; loop until end of string
0B4FCA             0307    
0B4FCA             0308    ; ; print the parameter string pointed to by ix
0B4FCA             0309    ; ; destroys: a, hl
0B4FCA             0310    ; print_param:
0B4FCA             0311    ;     ld hl,(ix)          ; get the parameter pointer
0B4FCA             0312    ;     call printString    ; print the parameter string
0B4FCA             0313    ;     ld a,' '            ; print a space separator
0B4FCA             0314    ;     rst.lil $10
0B4FCA             0315    ;     ret
0B4FCA             0316    
0B4FCA             0317    ; ; print the parameters
0B4FCA             0318    ; ; inputs: b = number of parameters, ix = pointer to the parameters
0B4FCA             0319    ; ; destroys: a, hl, bc
0B4FCA             0320    ; print_params:
0B4FCA             0321    ;     ld b,c              ; loop counter = number of parameters
0B4FCA             0322    ;     push ix             ; save the pointer to the parameters
0B4FCA             0323    ; @loop:
0B4FCA             0324    ;     push bc             ; save the loop counter
0B4FCA             0325    ;     call print_param    ; print the parameter
0B4FCA             0326    ;     lea ix,ix+3         ; next parameter pointer
0B4FCA             0327    ;     pop bc              ; get back the loop counter
0B4FCA             0328    ;     djnz @loop          ; loop until done
0B4FCA             0329    ;     pop ix              ; restore the pointer to the parameters
0B4FCA             0330    ;     ret
0B4FCA             0331    
0B4FCA             0332    ; debug_print:
0B4FCA             0333    ;     call printNewLine
0B4FCA             0334    ;     call dumpRegistersHexAll
0B4FCA             0335    ;     call printNewLine
0B4FCA             0336    ;     ret
0B4FCA             0337    
