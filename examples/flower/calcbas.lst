PC     Output      Line
040000             0001    ;
040000             0002    ; Title:	calcbas
040000             0003    ; Author:	Brandon R. Gates
040000             0004    ; Created:	29/10/2024
040000             0005    
040000             0006    ; ========================================
040000             0007    ; MODIFIED MOSLET INITIALIZATION CODE
040000             0008    ; ========================================
040000             0009    ;
040000             0010    ; Title:	Copy - Initialisation Code
040000             0011    ; Author:	Dean Belfield, Lennart Benschop
040000             0012    ; Created:	06/11/2022
040000             0013    ; Last Updated:	26/12/2022
040000             0014    ;
040000             0015    ; Modinfo:
040000             0016    ; 17/12/2022:	Added parameter processing
040000             0017    ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
040000             0018    ; Changed:      08/04/2924 adapt to ez80asm
040000             0019    ;
040000             0020        ASSUME	ADL = 1
040000             0021        INCLUDE "mos_api.inc"
040000             0001*   ;
040000             0002*   ; Title:	AGON MOS - API for user projects
040000             0003*   ; Author:	Dean Belfield
040000             0004*   ; Created:	03/08/2022
040000             0005*   ; Last Updated:	11/11/2023
040000             0006*   ;
040000             0007*   ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0008*   ;
040000             0009*   ; Modinfo:
040000             0010*   ; 05/08/2022:	Added mos_feof
040000             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*   ; 13/10/2022:	Added mos_oscli
040000             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*   ; 19/05/2023:	Added sysvar_scrMode
040000             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*   ; 03/08/2023:	Added mos_setkbvector
040000             0028*   ; 10/08/2023:	Added mos_getkbmap
040000             0029*   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0030*   ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0031*   ;
040000             0032*   ; VDP control (VDU 23, 0, n)
040000             0033*   ;
040000             0034*   vdp_gp:			EQU 	80h
040000             0035*   vdp_keycode:		EQU 	81h
040000             0036*   vdp_cursor:		EQU	82h
040000             0037*   vdp_scrchar:		EQU	83h
040000             0038*   vdp_scrpixel:		EQU	84h
040000             0039*   vdp_audio:		EQU	85h
040000             0040*   vdp_mode:		EQU	86h
040000             0041*   vdp_rtc:		EQU	87h
040000             0042*   vdp_keystate:		EQU	88h
040000             0043*   vdp_logicalcoords:	EQU	C0h
040000             0044*   vdp_terminalmode:	EQU	FFh
040000             0045*   
040000             0046*   ; MOS high level functions
040000             0047*   ;
040000             0048*   mos_getkey:		EQU	00h
040000             0049*   mos_load:		EQU	01h
040000             0050*   mos_save:		EQU	02h
040000             0051*   mos_cd:			EQU	03h
040000             0052*   mos_dir:		EQU	04h
040000             0053*   mos_del:		EQU	05h
040000             0054*   mos_ren:		EQU	06h
040000             0055*   mos_mkdir:		EQU	07h
040000             0056*   mos_sysvars:		EQU	08h
040000             0057*   mos_editline:		EQU	09h
040000             0058*   mos_fopen:		EQU	0Ah
040000             0059*   mos_fclose:		EQU	0Bh
040000             0060*   mos_fgetc:		EQU	0Ch
040000             0061*   mos_fputc:		EQU	0Dh
040000             0062*   mos_feof:		EQU	0Eh
040000             0063*   mos_getError:		EQU	0Fh
040000             0064*   mos_oscli:		EQU	10h
040000             0065*   mos_copy:		EQU	11h
040000             0066*   mos_getrtc:		EQU	12h
040000             0067*   mos_setrtc:		EQU	13h
040000             0068*   mos_setintvector:	EQU	14h
040000             0069*   mos_uopen:		EQU	15h
040000             0070*   mos_uclose:		EQU	16h
040000             0071*   mos_ugetc:		EQU	17h
040000             0072*   mos_uputc:		EQU 	18h
040000             0073*   mos_getfil:		EQU	19h
040000             0074*   mos_fread:		EQU	1Ah
040000             0075*   mos_fwrite:		EQU	1Bh
040000             0076*   mos_flseek:		EQU	1Ch
040000             0077*   mos_setkbvector:	EQU	1Dh
040000             0078*   mos_getkbmap:		EQU	1Eh
040000             0079*   mos_i2c_open:		EQU	1Fh
040000             0080*   mos_i2c_close:		EQU	20h
040000             0081*   mos_i2c_write:		EQU	21h
040000             0082*   mos_i2c_read:		EQU	22h
040000             0083*   
040000             0084*   
040000             0085*   ; FatFS file access functions
040000             0086*   ;
040000             0087*   ffs_fopen:		EQU	80h
040000             0088*   ffs_fclose:		EQU	81h
040000             0089*   ffs_fread:		EQU	82h
040000             0090*   ffs_fwrite:		EQU	83h
040000             0091*   ffs_flseek:		EQU	84h
040000             0092*   ffs_ftruncate:		EQU	85h
040000             0093*   ffs_fsync:		EQU	86h
040000             0094*   ffs_fforward:		EQU	87h
040000             0095*   ffs_fexpand:		EQU	88h
040000             0096*   ffs_fgets:		EQU	89h
040000             0097*   ffs_fputc:		EQU	8Ah
040000             0098*   ffs_fputs:		EQU	8Bh
040000             0099*   ffs_fprintf:		EQU	8Ch
040000             0100*   ffs_ftell:		EQU	8Dh
040000             0101*   ffs_feof:		EQU	8Eh
040000             0102*   ffs_fsize:		EQU	8Fh
040000             0103*   ffs_ferror:		EQU	90h
040000             0104*   
040000             0105*   ; FatFS directory access functions
040000             0106*   ;
040000             0107*   ffs_dopen:		EQU	91h
040000             0108*   ffs_dclose:		EQU	92h
040000             0109*   ffs_dread:		EQU	93h
040000             0110*   ffs_dfindfirst:		EQU	94h
040000             0111*   ffs_dfindnext:		EQU	95h
040000             0112*   
040000             0113*   ; FatFS file and directory management functions
040000             0114*   ;
040000             0115*   ffs_stat:		EQU	96h
040000             0116*   ffs_unlink:		EQU	97h
040000             0117*   ffs_rename:		EQU	98h
040000             0118*   ffs_chmod:		EQU	99h
040000             0119*   ffs_utime:		EQU	9Ah
040000             0120*   ffs_mkdir:		EQU	9Bh
040000             0121*   ffs_chdir:		EQU	9Ch
040000             0122*   ffs_chdrive:		EQU	9Dh
040000             0123*   ffs_getcwd:		EQU	9Eh
040000             0124*   
040000             0125*   ; FatFS volume management and system configuration functions
040000             0126*   ;
040000             0127*   ffs_mount:		EQU	9Fh
040000             0128*   ffs_mkfs:		EQU	A0h
040000             0129*   ffs_fdisk:		EQU	A1h
040000             0130*   ffs_getfree:		EQU	A2h
040000             0131*   ffs_getlabel:		EQU	A3h
040000             0132*   ffs_setlabel:		EQU	A4h
040000             0133*   ffs_setcp:		EQU	A5h
040000             0134*   
040000             0135*   ; File access modes
040000             0136*   ;
040000             0137*   fa_read:		EQU	01h
040000             0138*   fa_write:		EQU	02h
040000             0139*   fa_open_existing:	EQU	00h
040000             0140*   fa_create_new:		EQU	04h
040000             0141*   fa_create_always:	EQU	08h
040000             0142*   fa_open_always:		EQU	10h
040000             0143*   fa_open_append:		EQU	30h
040000             0144*   
040000             0145*   ; System variable indexes for api_sysvars
040000             0146*   ; Index into _sysvars in globals.asm
040000             0147*   ;
040000             0148*   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0149*   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0150*   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0151*   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0152*   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0153*   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0154*   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0155*   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0156*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0157*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0158*   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0159*   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0160*   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0161*   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0162*   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0163*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0164*   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0165*   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0166*   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0167*   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0168*   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0169*   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0170*   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0171*   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0172*   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0173*   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0174*   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0175*   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0176*   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0177*   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0178*   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0179*   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0180*   ;
040000             0181*   ; Flags for the VPD protocol
040000             0182*   ;
040000             0183*   vdp_pflag_cursor:	EQU	00000001b
040000             0184*   vdp_pflag_scrchar:	EQU	00000010b
040000             0185*   vdp_pflag_point:	EQU	00000100b
040000             0186*   vdp_pflag_audio:	EQU	00001000b
040000             0187*   vdp_pflag_mode:		EQU	00010000b
040000             0188*   vdp_pflag_rtc:		EQU	00100000b
040000             0189*   vdp_pflag_mouse:	EQU	01000000b
040000             0190*   ; vdp_pflag_buffered:	EQU	10000000b
040000             0191*   
040000             0192*   
040000             0193*   ; FatFS structures
040000             0194*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0195*   ;
040000             0196*   ; Object ID and allocation information (FFOBJID)
040000             0197*   FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0198*   FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0199*   FFOBJID.attr:     EQU 5    ; Object attribute
040000             0200*   FFOBJID.stat:     EQU 6    ; Object chain status
040000             0201*   FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0202*   FFOBJID.objsize:  EQU 11   ; Object size
040000             0203*   FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0204*   ;
040000             0205*   ; File object structure (FIL)
040000             0206*   ;
040000             0207*   FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0208*   FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0209*   FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0210*   FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0211*   FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0212*   FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0213*   FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0214*   FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0215*   FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0216*   ;
040000             0217*   ; Directory object structure (DIR)
040000             0218*   ;
040000             0219*   DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0220*   DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0221*   DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0222*   DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0223*   DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0224*   DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0225*   DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0226*   DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0227*   ;
040000             0228*   ; File information structure (FILINFO)
040000             0229*   ;
040000             0230*   FILINFO.fsize:    EQU 0    ; File size
040000             0231*   FILINFO.fdate:    EQU 4    ; Modified date
040000             0232*   FILINFO.ftime:    EQU 6    ; Modified time
040000             0233*   FILINFO.fattrib:  EQU 8    ; File attribute
040000             0234*   FILINFO.altname:  EQU 9    ; Alternative file name
040000             0235*   FILINFO.fname:    EQU 22   ; Primary file name
040000             0236*   FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0237*   ;
040000             0238*   ; Macro for calling the API
040000             0239*   ; Parameters:
040000             0240*   ; - function: One of the function numbers listed above
040000             0241*   ;
040000             0242*   			MACRO MOSCALL	function
040000             0243*   			LD	A, function
040000             0244*   			RST.LIS	08h
040000             0245*   			ENDMACRO
040000             0022        ORG 0x0B0000 ; Is a moslet
0B0000             0023    
0B0000             0024        MACRO PROGNAME
0B0000             0025        ASCIZ "calcbas"
0B0000             0026        ENDMACRO
0B0000             0027    ;
0B0000             0028    ; Start in ADL mode
0B0000             0029    ;
0B0000 C3 45 00 0B 0030    			JP	_start
0B0004             0031    ;
0B0004             0032    ; The header stuff is from byte 64 onwards
0B0004             0033    ;
0B0004             0034    _exec_name:
0B0004             0035    			PROGNAME			; The executable name, only used in argv
0B0004 63 61 6C 63 0001M       ASCIZ "calcbas"
       62 61 73 00 
0B000C             0036    
0B000C FF FF FF FF 0037    			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0038    
0B0040 4D 4F 53    0039    			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0040    			DB	00h			; MOS header version 0
0B0044 01          0041    			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0042    ;
0B0045             0043    ; And the code follows on immediately after the header
0B0045             0044    ;
0B0045             0045    _start:
0B0045 F5          0046                PUSH	AF			; Preserve the registers
0B0046 C5          0047    			PUSH	BC
0B0047 D5          0048    			PUSH	DE
0B0048 DD E5       0049    			PUSH	IX
0B004A FD E5       0050    			PUSH	IY
0B004C ED 6E       0051    			LD	A, MB			; Save MB
0B004E F5          0052    			PUSH 	AF
0B004F AF          0053    			XOR 	A
0B0050 ED 6D       0054    			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0055    
0B0052             0056    ; intialize BASIC-specific stuff
0B0052 ED 73 30 4D 0057    			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
       0B          
0B0057 CD A8 00 0B 0058    			CALL		_clear_ram
0B005B             0059    ; end of BASIC-specific initialization
0B005B             0060    
0B005B DD 21 00 4D 0061    			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0060 DD E5       0062    			PUSH	IX
0B0062 CD 79 00 0B 0063    			CALL	_parse_params		; Parse the parameters
0B0066 DD E1       0064    			POP	IX			; IX: argv
0B0068 06 00       0065    			LD	B, 0			;  C: argc
0B006A CD 5F 4D 0B 0066    			CALL	_main			; Start user code
0B006E             0067    
0B006E F1          0068    			POP 	AF
0B006F ED 6D       0069    			LD	MB, A
0B0071 FD E1       0070    			POP	IY			; Restore registers
0B0073 DD E1       0071    			POP	IX
0B0075 D1          0072    			POP	DE
0B0076 C1          0073    			POP	BC
0B0077 F1          0074    			POP	AF
0B0078 C9          0075    			RET
0B0079             0076    
0B0079             0077    ; Parse the parameter string into a C array
0B0079             0078    ; Parameters
0B0079             0079    ; - HL: Address of parameter string
0B0079             0080    ; - IX: Address for array pointer storage
0B0079             0081    ; Returns:
0B0079             0082    ; -  C: Number of parameters parsed
0B0079             0083    ;
0B0079 01 04 00 0B 0084    _parse_params:		LD	BC, _exec_name
0B007D DD 0F 00    0085    			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0080 ED 32 03    0086    			LEA     IX, IX+3
0B0083 CD A1 00 0B 0087    			CALL	_skip_spaces		; Skip HL past any leading spaces
0B0087             0088    ;
0B0087 01 01 00 00 0089    			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B008B 06 0F       0090    			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B008D             0091    
0B008D             0092    ; drop hl into (ix) leaving two parameters:
0B008D             0093    ; - the app name
0B008D             0094    ; - whatever the user entered
0B008D DD 2F 00    0095                ld (ix),hl
0B0090 0C          0096    			INC	C			; Increment ARGC
0B0091 C9          0097                ret
0B0092             0098    
0B0092             0099    ; Get the next token
0B0092             0100    ; Parameters:
0B0092             0101    ; - HL: Address of parameter string
0B0092             0102    ; Returns:
0B0092             0103    ; - HL: Address of first character after token
0B0092             0104    ; -  C: Length of token (in characters)
0B0092             0105    ;
0B0092 0E 00       0106    _get_token:		LD	C, 0			; Initialise length
0B0094 7E          0107    @@:			LD	A, (HL)			; Get the character from the parameter string
0B0095 B7          0108    			OR	A			; Exit if 0 (end of parameter string in MOS)
0B0096 C8          0109    			RET 	Z
0B0097 FE 0D       0110    			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B0099 C8          0111    			RET	Z
0B009A FE 20       0112    			CP	' '			; Exit if space (end of token)
0B009C C8          0113    			RET	Z
0B009D 23          0114    			INC	HL			; Advance to next character
0B009E 0C          0115    			INC 	C			; Increment length
0B009F 18 F3       0116    			JR	@B
0B00A1             0117    
0B00A1             0118    ; Skip spaces in the parameter string
0B00A1             0119    ; Parameters:
0B00A1             0120    ; - HL: Address of parameter string
0B00A1             0121    ; Returns:
0B00A1             0122    ; - HL: Address of next none-space character
0B00A1             0123    ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00A1             0124    ;
0B00A1 7E          0125    _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00A2 FE 20       0126    			CP	' '			; Exit if not space
0B00A4 C0          0127    			RET	NZ
0B00A5 23          0128    			INC	HL			; Advance to next character
0B00A6 18 F9       0129    			JR	_skip_spaces		; Increment length
0B00A8             0130    
0B00A8             0131    ; ========================================
0B00A8             0132    ; BASIC INITIALIZATION CODE FROM basic/init.asm
0B00A8             0133    ; ========================================
0B00A8             0134    ;
0B00A8             0135    ;Clear the application memory
0B00A8             0136    ;
0B00A8 C5          0137    _clear_ram:		PUSH		BC
0B00A9 21 00 49 0B 0138    			LD		HL, RAM_START
0B00AD 11 01 49 0B 0139    			LD		DE, RAM_START + 1
0B00B1 01 4F 03 00 0140    			LD		BC, RAM_END - RAM_START - 1
0B00B5 AF          0141    			XOR		A
0B00B6 77          0142    			LD		(HL), A
0B00B7 ED B0       0143    			LDIR
0B00B9 C1          0144    			POP		BC
0B00BA C9          0145    			RET
0B00BB             0146    
0B00BB             0147    ; ========================================
0B00BB             0148    ; BEGIN APPLICATION CODE
0B00BB             0149    ; ========================================
0B00BB             0150    
0B00BB             0151    ; API INCLUDES
0B00BB             0152        include "basic/basic.asm"
0B00BB             0001*       ; include "basic/mos_api.inc"
0B00BB             0002*       include "basic/macros.inc"
0B00BB             0001**  	; Title:	BBC Basic Interpreter - Z80 version
0B00BB             0002**  	;		Useful macros
0B00BB             0003**  	; Author:	Dean Belfield
0B00BB             0004**  	; Created:	12/05/2023
0B00BB             0005**  	; Last Updated:	11/06/2023
0B00BB             0006**  	;
0B00BB             0007**  	; Modinfo:
0B00BB             0008**  	; 11/06/2023:	Modified to run in ADL mode
0B00BB             0009**  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
0B00BB             0010**  
0B00BB             0011**  	MACRO EXREG	rp1, rp2
0B00BB             0012**  		PUSH	rp1
0B00BB             0013**  		POP	rp2
0B00BB             0014**  	ENDMACRO
0B00BB             0015**  
0B00BB             0016**  	; MACRO ADD8U_DE	reg
0B00BB             0017**  		MACRO ADD8U_DE
0B00BB             0018**  		ADD	A, E
0B00BB             0019**  		LD	E, A
0B00BB             0020**  		ADC	A, D
0B00BB             0021**  		SUB	E
0B00BB             0022**  		LD	D, A
0B00BB             0023**  	ENDMACRO
0B00BB             0024**  
0B00BB             0025**  	; MACRO ADD8U_HL	reg
0B00BB             0026**  	MACRO ADD8U_HL
0B00BB             0027**  		ADD	A, L
0B00BB             0028**  		LD	L, A
0B00BB             0029**  		ADC	A, H
0B00BB             0030**  		SUB	L
0B00BB             0031**  		LD	H, A
0B00BB             0032**  	ENDMACRO
0B00BB             0033**  
0B00BB             0034**  	MACRO VDU	val
0B00BB             0035**  		LD	A, val
0B00BB             0036**  		CALL	OSWRCH
0B00BB             0037**  	ENDMACRO
0B00BB             0038**  
0B00BB             0039**  	MACRO SET_GPIO	reg, val
0B00BB             0040**  		IN0	A, (reg)
0B00BB             0041**  		OR	val
0B00BB             0042**  		OUT0	(reg), A
0B00BB             0043**  	ENDMACRO
0B00BB             0044**  
0B00BB             0045**  	MACRO RES_GPIO	reg, val
0B00BB             0046**  		PUSH	BC
0B00BB             0047**  		LD	A, val
0B00BB             0048**  		CPL
0B00BB             0049**  		LD	C, A
0B00BB             0050**  		IN0	A, (reg)
0B00BB             0051**  		AND	C
0B00BB             0052**  		OUT0	(reg), A
0B00BB             0053**  		POP	BC
0B00BB             0054**  	ENDMACRO
0B00BB             0003*       include "basic/equs.inc"
0B00BB             0001**  ;
0B00BB             0002**  ; Title:	BBC Basic for AGON - Equs
0B00BB             0003**  ; Author:	Dean Belfield
0B00BB             0004**  ; Created:	12/05/2023
0B00BB             0005**  ; Last Updated:	08/06/2023
0B00BB             0006**  ;
0B00BB             0007**  ; Modinfo:
0B00BB             0008**  ; 08/06/2023:	Added SIZEW
0B00BB             0009**  
0B00BB             0010**  			; XREF		STAVAR
0B00BB             0011**  			; XREF		ACCS
0B00BB             0012**  
0B00BB             0013**  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
0B00BB             0014**  ;Stack_Top:		EQU		0000h	; Stack at top
0B00BB             0015**  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
0B00BB             0016**  
0B00BB             0017**  ; For GPIO
0B00BB             0018**  ; PA not available on eZ80L92
0B00BB             0019**  ;
0B00BB             0020**  PA_DR:			EQU		96h
0B00BB             0021**  PA_DDR:			EQU		97h
0B00BB             0022**  PA_ALT1:		EQU		98h
0B00BB             0023**  PA_ALT2:		EQU		99h
0B00BB             0024**  PB_DR:          	EQU		9Ah
0B00BB             0025**  PB_DDR:        	 	EQU		9Bh
0B00BB             0026**  PB_ALT1:        	EQU		9Ch
0B00BB             0027**  PB_ALT2:        	EQU		9Dh
0B00BB             0028**  PC_DR:          	EQU		9Eh
0B00BB             0029**  PC_DDR:         	EQU		9Fh
0B00BB             0030**  PC_ALT1:        	EQU		A0h
0B00BB             0031**  PC_ALT2:        	EQU		A1h
0B00BB             0032**  PD_DR:          	EQU		A2h
0B00BB             0033**  PD_DDR:			EQU		A3h
0B00BB             0034**  PD_ALT1:		EQU		A4h
0B00BB             0035**  PD_ALT2:		EQU		A5h
0B00BB             0036**  
0B00BB             0037**  GPIOMODE_OUT:		EQU		0	; Output
0B00BB             0038**  GPIOMODE_IN:		EQU		1	; Input
0B00BB             0039**  GPIOMODE_DIO:		EQU		2	; Open Drain IO
0B00BB             0040**  GPIOMODE_SIO:		EQU		3	; Open Source IO
0B00BB             0041**  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
0B00BB             0042**  GPIOMODE_ALTF:		EQU		5;	; Alt Function
0B00BB             0043**  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
0B00BB             0044**  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
0B00BB             0045**  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
0B00BB             0046**  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
0B00BB             0047**  
0B00BB             0048**  ; ; Originally in ram.asm
0B00BB             0049**  ; ;
0B00BB             0050**  ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
0B00BB             0051**  ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
0B00BB             0052**  ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
0B00BB             0053**  
0B00BB             0054**  ; Originally in main.asm
0B00BB             0055**  ;
0B00BB             0056**  CR:			EQU     0DH
0B00BB             0057**  LF:			EQU     0AH
0B00BB             0058**  ESC:			EQU     1BH
0B00BB             0004*       ; include "basic/init.asm" ; relevant bits folded into calcbas.asm
0B00BB             0005*       include "basic/eval.asm"
0B00BB             0001**  ;
0B00BB             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B00BB             0003**  ;		Expression Evaluation & Arithmetic Module - "EVAL"
0B00BB             0004**  ; Author:	(C) Copyright  R.T.Russell  1984
0B00BB             0005**  ; Modified By:	Dean Belfield
0B00BB             0006**  ; Created:	12/05/2023
0B00BB             0007**  ; Last Updated:	17/08/2023
0B00BB             0008**  ;
0B00BB             0009**  ; Modinfo:
0B00BB             0010**  ; 07/06/2023:	Modified to run in ADL mode
0B00BB             0011**  ; 26/06/2023:	Fixed HEX and HEXSTR
0B00BB             0012**  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
0B00BB             0013**  ; 17/08/2023:	Added binary constants
0B00BB             0014**  
0B00BB             0015**  			; .ASSUME	ADL = 1
0B00BB             0016**  
0B00BB             0017**  			; INCLUDE	"equs.inc"
0B00BB             0018**  			; INCLUDE "macros.inc"
0B00BB             0019**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B00BB             0020**  
0B00BB             0021**  			; SEGMENT CODE
0B00BB             0022**  
0B00BB             0023**  			; XDEF	EXPR
0B00BB             0024**  			; XDEF	EXPRN
0B00BB             0025**  			; XDEF	EXPRI
0B00BB             0026**  			; XDEF	EXPRS
0B00BB             0027**  			; XDEF	ITEMI
0B00BB             0028**  			; XDEF	LOADN
0B00BB             0029**  			; XDEF	LOAD4
0B00BB             0030**  			; XDEF	CONS
0B00BB             0031**  			; XDEF	LOADS
0B00BB             0032**  			; XDEF	SFIX
0B00BB             0033**  			; XDEF	VAL0
0B00BB             0034**  			; XDEF	SEARCH
0B00BB             0035**  			; XDEF	SWAP
0B00BB             0036**  			; XDEF	TEST
0B00BB             0037**  			; XDEF	DECODE
0B00BB             0038**  			; XDEF	HEXSTR
0B00BB             0039**  			; XDEF	STR
0B00BB             0040**  			; XDEF	ZERO
0B00BB             0041**  			; XDEF	PUSHS
0B00BB             0042**  			; XDEF	POPS
0B00BB             0043**  			; XDEF	COMMA
0B00BB             0044**  			; XDEF	BRAKET
0B00BB             0045**  			; XDEF	NXT
0B00BB             0046**  			; XDEF	COUNT0
0B00BB             0047**  
0B00BB             0048**  			; XREF	ADVAL
0B00BB             0049**  			; XREF	FN_EX
0B00BB             0050**  			; XREF	POINT
0B00BB             0051**  			; XREF	USR
0B00BB             0052**  			; XREF	SYNTAX
0B00BB             0053**  			; XREF	ERROR_
0B00BB             0054**  			; XREF	CHECK
0B00BB             0055**  			; XREF	GETVAR
0B00BB             0056**  			; XREF	LISTON
0B00BB             0057**  			; XREF	RANGE
0B00BB             0058**  			; XREF	FPP
0B00BB             0059**  			; XREF	GETCSR
0B00BB             0060**  			; XREF	CHANEL
0B00BB             0061**  			; XREF	OSSTAT
0B00BB             0062**  			; XREF	OSBGET
0B00BB             0063**  			; XREF	LOMEM
0B00BB             0064**  			; XREF	HIMEM
0B00BB             0065**  			; XREF	PAGE_
0B00BB             0066**  			; XREF	TOP
0B00BB             0067**  			; XREF	ERL
0B00BB             0068**  			; XREF	ERR
0B00BB             0069**  			; XREF	COUNT
0B00BB             0070**  			; XREF	OSOPEN
0B00BB             0071**  			; XREF	GETEXT
0B00BB             0072**  			; XREF	GETPTR
0B00BB             0073**  			; XREF	GETIME
0B00BB             0074**  			; XREF	GETIMS
0B00BB             0075**  			; XREF	LEXAN2
0B00BB             0076**  			; XREF	RANDOM
0B00BB             0077**  			; XREF	STORE5
0B00BB             0078**  			; XREF	GETSCHR
0B00BB             0079**  			; XREF	OSRDCH
0B00BB             0080**  			; XREF	OSKEY
0B00BB             0081**  			; XREF	INKEY1
0B00BB             0082**  			; XREF	EXTERR
0B00BB             0083**  ;
0B00BB             0084**  ; BINARY FLOATING POINT REPRESENTATION:
0B00BB             0085**  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B00BB             0086**  ;     8 BIT EXCESS-128 SIGNED EXPONENT
0B00BB             0087**  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B00BB             0088**  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B00BB             0089**  ;
0B00BB             0090**  ; BINARY INTEGER REPRESENTATION:
0B00BB             0091**  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B00BB             0092**  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B00BB             0093**  ;
0B00BB             0094**  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B00BB             0095**  ;                             EXPONENT - C
0B00BB             0096**  ;
0B00BB             0097**  
0B00BB             0098**  ;
0B00BB             0099**  ; Table of addresses for functions
0B00BB             0100**  ;
0B00BB             0101**  FUNTOK:			EQU	8DH			; First token number
0B00BB             0102**  ;
0B00BB 97 08 0B    0103**  FUNTBL:			DW24	DECODE			; Line number
0B00BE 45 05 0B    0104**  			DW24	OPENIN			; OPENIN
0B00C1 67 05 0B    0105**  			DW24	PTR_EV			; PTR
0B00C4 01 05 0B    0106**  			DW24	PAGEV			; PAGE
0B00C7 71 05 0B    0107**  			DW24	TIMEV			; TIME
0B00CA ED 04 0B    0108**  			DW24	LOMEMV			; LOMEM
0B00CD F7 04 0B    0109**  			DW24	HIMEMV			; HIMEM
0B00D0 C5 05 0B    0110**  			DW24	ABSV			; ABS
0B00D3 01 06 0B    0111**  			DW24	ACS			; ACS
0B00D6 68 43 0B    0112**  			DW24	ADVAL			; ADVAL
0B00D9 D6 04 0B    0113**  			DW24	ASC			; ASC
0B00DC F9 05 0B    0114**  			DW24	ASN			; ASN
0B00DF FD 05 0B    0115**  			DW24	ATN			; ATN
0B00E2 9F 04 0B    0116**  			DW24	BGET			; BGET
0B00E5 E5 05 0B    0117**  			DW24	COS			; COS
0B00E8 2C 05 0B    0118**  			DW24	COUNTV			; COUNT
0B00EB CD 05 0B    0119**  			DW24	DEG			; DEG
0B00EE 20 05 0B    0120**  			DW24	ERLV			; ERL
0B00F1 26 05 0B    0121**  			DW24	ERRV			; ERR
0B00F4 2A 06 0B    0122**  			DW24	EVAL_			; EVAL
0B00F7 ED 05 0B    0123**  			DW24	EXP			; EXP
0B00FA 5D 05 0B    0124**  			DW24	EXT			; EXT
0B00FD 44 09 0B    0125**  			DW24	ZERO			; FALSE
0B0100 30 10 0B    0126**  			DW24	FN_EX			; FN
0B0103 BD 04 0B    0127**  			DW24	GET			; GET
0B0106 AC 04 0B    0128**  			DW24	INKEY			; INKEY
0B0109 DC 06 0B    0129**  			DW24	INSTR			; INSTR(
0B010C D9 05 0B    0130**  			DW24	INT_			; INT
0B010F E6 04 0B    0131**  			DW24	LEN			; LEN
0B0112 F1 05 0B    0132**  			DW24	LN			; LN
0B0115 F5 05 0B    0133**  			DW24	LOG			; LOG
0B0118 C9 05 0B    0134**  			DW24	NOTK			; NOT
0B011B 41 05 0B    0135**  			DW24	OPENUP			; OPENUP
0B011E 3E 05 0B    0136**  			DW24	OPENOT			; OPENOUT
0B0121 C1 05 0B    0137**  			DW24	PI			; PI
0B0124 1A 44 0B    0138**  			DW24	POINT			; POINT(
0B0127 7E 04 0B    0139**  			DW24	POS			; POS
0B012A D1 05 0B    0140**  			DW24	RAD			; RAD
0B012D 5E 06 0B    0141**  			DW24	RND			; RND
0B0130 D5 05 0B    0142**  			DW24	SGN			; SGN
0B0133 E9 05 0B    0143**  			DW24	SIN			; SIN
0B0136 DD 05 0B    0144**  			DW24	SQR			; SQR
0B0139 E1 05 0B    0145**  			DW24	TAN			; TAN
0B013C 0B 05 0B    0146**  			DW24	TOPV			; TO(P)
0B013F B6 05 0B    0147**  			DW24	TRUE			; TRUE
0B0142 D3 14 0B    0148**  			DW24	USR			; USR
0B0145 1B 06 0B    0149**  			DW24	VAL			; VAL
0B0148 87 04 0B    0150**  			DW24	VPOS			; VPOS
0B014B 70 07 0B    0151**  			DW24	CHRS			; CHRS
0B014E 78 07 0B    0152**  			DW24	GETS			; GETS
0B0151 89 07 0B    0153**  			DW24	INKEYS			; INKEYS
0B0154 0E 08 0B    0154**  			DW24	LEFTS			; LEFTS(
0B0157 D6 07 0B    0155**  			DW24	MIDS			; MIDS(
0B015A 2E 08 0B    0156**  			DW24	RIGHTS			; RIGHTS(
0B015D FB 08 0B    0157**  			DW24	STRS			; STR$
0B0160 4F 08 0B    0158**  			DW24	STRING_			; STRINGS(
0B0163 8F 04 0B    0159**  			DW24	EOF			; EOF
0B0166             0160**  ;
0B0166             0161**  FUNTBL_END:		EQU	$
0B0166             0162**  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0B0166             0163**  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0B0166             0164**  
0B0166             0165**  ANDK:			EQU     80H
0B0166             0166**  DIVK:			EQU     81H
0B0166             0167**  EORK:			EQU     82H
0B0166             0168**  MODK:			EQU     83H
0B0166             0169**  ORK:			EQU     84H
0B0166             0170**  ;
0B0166 A1 05 0B    0171**  SOPTBL:			DW24	SLE			; <= (STRING)
0B0169 AA 05 0B    0172**  			DW24	SNE			; <>
0B016C 9A 05 0B    0173**  			DW24	SGE			; >=
0B016F 8B 05 0B    0174**  			DW24	SLT			; <
0B0172 B1 05 0B    0175**  			DW24	SEQ			; =
0B0175 92 05 0B    0176**  			DW24	SGT			; >
0B0178             0177**  ;
0B0178             0178**  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0B0178             0179**  ;     Expression type is returned in A'F':
0B0178             0180**  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0B0178             0181**  ;         String - A' bit 7=1, F' sign bit set.
0B0178             0182**  ; Floating-point or integer result returned in HLH'L'C
0B0178             0183**  ; Integer result denoted by C=0 and HLH'L' non-zero.
0B0178             0184**  ; String result returned in string accumulator, DE set.
0B0178             0185**  ;
0B0178             0186**  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0B0178             0187**  ;               (2) ^
0B0178             0188**  ;               (3) * / MOD DIV
0B0178             0189**  ;               (4) + -
0B0178             0190**  ;               (5) = <> <= >= > <
0B0178             0191**  ;               (6) AND
0B0178             0192**  ;               (7) EOR OR
0B0178             0193**  
0B0178             0194**  ;
0B0178             0195**  ; Level 7: EOR and OR
0B0178             0196**  ;
0B0178 CD 91 01 0B 0197**  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0B017C FE 82       0198**  EXPR0A:			CP      EORK            	; Is operator EOR?
0B017E 28 03       0199**  			JR      Z,EXPR0B		; Yes, so skip to next bit
0B0180 FE 84       0200**  			CP      ORK			; Is operator OR
0B0182 C0          0201**  			RET     NZ			; No, so return
0B0183             0202**  ;
0B0183 CD EF 09 0B 0203**  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0B0187 CD 91 01 0B 0204**  			CALL    EXPR1           	; Get second operand
0B018B CD FE 09 0B 0205**  			CALL    DOIT            	; Do the operation
0B018F 18 EB       0206**  			JR      EXPR0A          	; And continue
0B0191             0207**  ;
0B0191             0208**  ; Level 6: AND
0B0191             0209**  ;
0B0191 CD A6 01 0B 0210**  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0B0195 FE 80       0211**  EXPR1A:			CP      ANDK			; Is operator AND?
0B0197 C0          0212**  			RET     NZ			; No, so return
0B0198 CD EF 09 0B 0213**  			CALL    SAVE_EV			; Save first operand
0B019C CD A6 01 0B 0214**  			CALL    EXPR2			; Get second operand
0B01A0 CD FE 09 0B 0215**  			CALL    DOIT			; Do the operation
0B01A4 18 EF       0216**  			JR      EXPR1A			; And continue
0B01A6             0217**  ;
0B01A6             0218**  ; Level 5: Comparisons
0B01A6             0219**  ;
0B01A6 CD 18 02 0B 0220**  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0B01AA CD C6 09 0B 0221**  			CALL    RELOP?			; Is it ">", "=" or "<"?
0B01AE C0          0222**  			RET     NZ			; No, so return
0B01AF 47          0223**  			LD      B,A			; Store the first operator in B
0B01B0 FD 23       0224**  			INC     IY              	; Bump over operator
0B01B2 CD 21 0A 0B 0225**  			CALL    NXT			;
0B01B6 CD C6 09 0B 0226**  			CALL    RELOP?          	; Is it a compound operator?
0B01BA 20 09       0227**  			JR      NZ,EXPR2B		; No, so skip next bit
0B01BC FD 23       0228**  			INC     IY			; Bump over operator
0B01BE B8          0229**  			CP      B			; Compare with first
0B01BF CA 48 0C 0B 0230**  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
0B01C3 80          0231**  			ADD     A,B
0B01C4 47          0232**  			LD      B,A			; B: Unique code for the compound operator
0B01C5 78          0233**  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
0B01C6 08          0234**  			EX      AF,AF'
0B01C7 FA E1 01 0B 0235**  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
0B01CB 08          0236**  			EX      AF,AF'
0B01CC D6 04       0237**  			SUB     4
0B01CE FE 3A       0238**  			CP      '>'-4
0B01D0 20 02       0239**  			JR      NZ,EXPR2C
0B01D2 C6 02       0240**  			ADD     A,2
0B01D4 CD F1 09 0B 0241**  EXPR2C:			CALL    SAVE1
0B01D8 CD 18 02 0B 0242**  			CALL    EXPR3
0B01DC CD FE 09 0B 0243**  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
0B01E0 C9          0244**  			RET
0B01E1             0245**  ;
0B01E1 08          0246**  EXPR2S:			EX      AF,AF'			; Handle string comparisons
0B01E2 3D          0247**  			DEC     A
0B01E3 E6 07       0248**  			AND     7
0B01E5 CD 65 09 0B 0249**  			CALL    PUSHS           	; Save string on the stack
0B01E9 F5          0250**  			PUSH    AF              	; Save the operator
0B01EA CD 18 02 0B 0251**  			CALL    EXPR3           	; Get the second string
0B01EE 08          0252**  			EX      AF,AF'
0B01EF F2 E7 02 0B 0253**  			JP      P,TYPE_EV_
0B01F3 F1          0254**  			POP     AF
0B01F4 4B          0255**  			LD      C,E             	; Length of string #2
0B01F5 D1          0256**  			POP     DE
0B01F6 21 00 00 00 0257**  			LD      HL,0
0B01FA 39          0258**  			ADD     HL,SP
0B01FB 43          0259**  			LD      B,E             	; Length of string #1
0B01FC D5          0260**  			PUSH    DE
0B01FD 11 00 49 0B 0261**  			LD      DE,ACCS
0B0201 EB          0262**  			EX      DE,HL
0B0202 CD 2D 0A 0B 0263**  			CALL    DISPT2
0B0206 D1          0264**  			POP     DE
0B0207 EB          0265**  			EX      DE,HL
0B0208 7D          0266**  			LD	A,L
0B0209 21 00 00 00 0267**  			LD	HL,0
0B020D 6F          0268**  			LD	L,A
0B020E 39          0269**  			ADD     HL,SP
0B020F F9          0270**  			LD      SP,HL
0B0210 EB          0271**  			EX      DE,HL
0B0211 AF          0272**  			XOR     A               	; Numeric marker
0B0212 4F          0273**  			LD      C,A             	; Integer marker
0B0213 08          0274**  			EX      AF,AF'
0B0214 FD 7E 00    0275**  			LD      A,(IY)
0B0217 C9          0276**  			RET
0B0218             0277**  ;
0B0218             0278**  ; Level 4: + and -
0B0218             0279**  ;
0B0218 CD 75 02 0B 0280**  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
0B021C FE 2D       0281**  EXPR3A:			CP      '-'			; Is it "-"?
0B021E 28 09       0282**  			JR      Z,EXPR3B		; Yes, so skip the next bit
0B0220 FE 2B       0283**  			CP      '+'			; Is it "+"?
0B0222 C0          0284**  			RET     NZ			; No, so return
0B0223 08          0285**  			EX      AF,AF'			; Get the type
0B0224 FA 37 02 0B 0286**  			JP      M,EXPR3S		; Branch here if string
0B0228 08          0287**  			EX      AF,AF'
0B0229 CD EF 09 0B 0288**  EXPR3B:			CALL    SAVE_EV			; Save the first operator
0B022D CD 75 02 0B 0289**  			CALL    EXPR4			; Fetch the second operator
0B0231 CD FE 09 0B 0290**  			CALL    DOIT			; Do the operation
0B0235 18 E5       0291**  			JR      EXPR3A			; And continue
0B0237             0292**  ;
0B0237 08          0293**  EXPR3S:			EX      AF,AF'			; Handle string concatenation
0B0238 FD 23       0294**  			INC     IY              	; Bump past the "+"
0B023A CD 65 09 0B 0295**  			CALL    PUSHS           	; Save the string on the stack
0B023E CD 75 02 0B 0296**  			CALL    EXPR4           	; Fetch the second operator
0B0242 08          0297**  			EX      AF,AF'
0B0243 F2 E7 02 0B 0298**  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0B0247 01 00 00 00 0299**  			LD	BC, 0			; Clear BC
0B024B 4B          0300**  			LD      C,E             	; C: Length of the second string
0B024C D1          0301**  			POP     DE
0B024D D5          0302**  			PUSH    DE
0B024E 21 00 49 0B 0303**  			LD      HL,ACCS
0B0252             0304**  ; BEGIN MISSING FROM BINARY
0B0252             0305**  			; LD	A,E			;  E: Length of the first string
0B0252             0306**  			; LD      DE,ACCS
0B0252             0307**  			; LD	E,A 			; DE: Pointer to the end of the first string
0B0252             0308**  ; END MISSING FROM BINARY
0B0252 54          0309**  			LD		D,H ; ADDED FROM BINARY
0B0253 79          0310**  			LD      A,C
0B0254 B7          0311**  			OR      A
0B0255 28 0F       0312**  			JR      Z,EXP3S3
0B0257 6F          0313**  			LD      L,A             	; Source
0B0258 83          0314**  			ADD     A,E
0B0259 5F          0315**  			LD      E,A             	; Destination
0B025A 3E 13       0316**  			LD      A,19
0B025C DA 11 37 0B 0317**  			JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0B0260 D5          0318**  			PUSH    DE
0B0261 1D          0319**  			DEC     E
0B0262 2D          0320**  			DEC     L
0B0263 ED B8       0321**  			LDDR                    	; Copy
0B0265 D1          0322**  			POP     DE
0B0266 D9          0323**  EXP3S3:			EXX
0B0267 C1          0324**  			POP     BC
0B0268 CD 8F 09 0B 0325**  			CALL    POPS            	; Restore from stack
0B026C D9          0326**  			EXX
0B026D F6 80       0327**  			OR      80H             	; Flag as a string
0B026F 08          0328**  			EX      AF,AF'
0B0270 FD 7E 00    0329**  			LD      A,(IY)			; Fetch the next character
0B0273 18 A7       0330**  			JR      EXPR3A			; And continue
0B0275             0331**  ;
0B0275             0332**  ; Level 3: * / MOD DIV
0B0275             0333**  ;
0B0275 CD 96 02 0B 0334**  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0B0279 FE 2A       0335**  EXPR4A:			CP      '*'			; "*" is valid
0B027B 28 0B       0336**  			JR      Z,EXPR4B
0B027D FE 2F       0337**  			CP      '/'			; "/" is valid
0B027F 28 07       0338**  			JR      Z,EXPR4B
0B0281 FE 83       0339**  			CP      MODK			; MOD token is valid
0B0283 28 03       0340**  			JR      Z,EXPR4B
0B0285 FE 81       0341**  			CP      DIVK			; DIV token is valid
0B0287 C0          0342**  			RET     NZ			; And return if it is anything else
0B0288 CD EF 09 0B 0343**  EXPR4B:			CALL    SAVE_EV
0B028C CD 96 02 0B 0344**  			CALL    EXPR5
0B0290 CD FE 09 0B 0345**  			CALL    DOIT
0B0294 18 E3       0346**  			JR      EXPR4A
0B0296             0347**  ;
0B0296             0348**  ; Level 2: ^
0B0296             0349**  ;
0B0296 CD 76 03 0B 0350**  EXPR5:			CALL    ITEM			; Get variable
0B029A B7          0351**  			OR      A               	; Test type
0B029B 08          0352**  			EX      AF,AF'          	; Save type
0B029C CD 21 0A 0B 0353**  EXPR5A:			CALL    NXT			; Skip spaces
0B02A0 FE 5E       0354**  			CP      '^'			; Is the operator "^"?
0B02A2 C0          0355**  			RET     NZ			; No, so return
0B02A3 CD EF 09 0B 0356**  			CALL    SAVE_EV			; Save first operand
0B02A7 CD 76 03 0B 0357**  			CALL    ITEM			; Get second operand
0B02AB B7          0358**  			OR      A			; Test type
0B02AC 08          0359**  			EX      AF,AF'			; Save type
0B02AD CD FE 09 0B 0360**  			CALL    DOIT			; Do the operation
0B02B1 18 E9       0361**  			JR      EXPR5A			; And continue
0B02B3             0362**  ;
0B02B3             0363**  ; Evaluate a numeric expression
0B02B3             0364**  ;
0B02B3 CD 78 01 0B 0365**  EXPRN:			CALL    EXPR			; Evaluate expression
0B02B7 08          0366**  			EX      AF,AF'			; Get the type
0B02B8 F0          0367**  			RET     P			; And return if it is a number
0B02B9 18 2C       0368**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02BB             0369**  ;
0B02BB             0370**  ; Evaluate a fixed-point expression
0B02BB             0371**  ;
0B02BB CD 78 01 0B 0372**  EXPRI:			CALL    EXPR			; Evaluate the expression
0B02BF 08          0373**  			EX      AF,AF'			; Get the type
0B02C0 F2 13 06 0B 0374**  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B02C4 18 21       0375**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02C6             0376**  ;
0B02C6             0377**  ; Evaluate a string expression
0B02C6             0378**  ;
0B02C6 CD 78 01 0B 0379**  EXPRS:			CALL    EXPR			; Evaluate the expression
0B02CA 08          0380**  			EX      AF,AF'			; Get the type
0B02CB F8          0381**  			RET     M			; And return if it is a string
0B02CC 18 19       0382**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02CE             0383**  ;
0B02CE             0384**  ; Get a numeric variable
0B02CE             0385**  ;
0B02CE CD 76 03 0B 0386**  ITEMN:			CALL    ITEM			; Get the variable
0B02D2 B7          0387**  			OR      A			; Test the type
0B02D3 F0          0388**  			RET     P			; And return if it is a number
0B02D4 18 11       0389**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02D6             0390**  ;
0B02D6             0391**  ; Get a fixed-point variable
0B02D6             0392**  ;
0B02D6 CD 76 03 0B 0393**  ITEMI:			CALL    ITEM			; Get the variable
0B02DA B7          0394**  			OR      A			; Test the type
0B02DB F2 13 06 0B 0395**  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B02DF 18 06       0396**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B02E1             0397**  ;
0B02E1             0398**  ; Get a string variable
0B02E1             0399**  ;
0B02E1 CD 76 03 0B 0400**  ITEMS:			CALL    ITEM			; Get the variable
0B02E5 B7          0401**  			OR      A			; Test the type
0B02E6 F8          0402**  			RET     M			; If it is a string, then return
0B02E7             0403**  ;							; Otherwise
0B02E7 3E 06       0404**  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
0B02E9 C3 11 37 0B 0405**  			JP      ERROR_
0B02ED             0406**  ;
0B02ED             0407**  ; Evaluate a bracketed expression
0B02ED             0408**  ;
0B02ED CD 78 01 0B 0409**  ITEM1:			CALL    EXPR            	; Evaluate the expression
0B02F1 CD E0 09 0B 0410**  			CALL    BRAKET			; Check for closing bracket
0B02F5 08          0411**  			EX      AF,AF'
0B02F6 C9          0412**  			RET
0B02F7             0413**  ;
0B02F7             0414**  ; HEX - Get hexadecimal constant.
0B02F7             0415**  ;   Inputs: ASCII string at (IY)
0B02F7             0416**  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0B02F7             0417**  ;           IY updated (points to delimiter)
0B02F7             0418**  ;
0B02F7 CD 44 09 0B 0419**  HEX:			CALL    ZERO			; Set result to 0
0B02FB CD A9 09 0B 0420**  			CALL    HEXDIG			; Fetch the character from IY
0B02FF 38 1B       0421**  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
0B0301 FD 23       0422**  HEX1:			INC     IY			; Move pointer to next character
0B0303 E6 0F       0423**  			AND     0FH			; Clear the top nibble
0B0305 06 04       0424**  			LD      B,4			; Loop counter
0B0307             0425**  ;
0B0307 D9          0426**  HEX2:			EXX				; Shift the result left B (4) times. This makes
0B0308 52 29       0427**  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
0B030A D9          0428**  			EXX				; .
0B030B 52 ED 6A    0429**  			ADC.S   HL,HL			; .
0B030E 10 F7       0430**  			DJNZ    HEX2			; And loop
0B0310 D9          0431**  			EXX
0B0311 B5          0432**  			OR      L			; OR in the digit
0B0312 6F          0433**  			LD      L,A
0B0313 D9          0434**  			EXX
0B0314             0435**  ;
0B0314 CD A9 09 0B 0436**  			CALL    HEXDIG			; Fetch the next character
0B0318 30 E7       0437**  			JR      NC,HEX1			; If it is a HEX digit then loop
0B031A AF          0438**  			XOR     A			; Clear A
0B031B C9          0439**  			RET
0B031C             0440**  ;
0B031C 3E 1C       0441**  BADHEX:			LD      A,28
0B031E C3 11 37 0B 0442**  			JP      ERROR_          	; Error: "Bad HEX"
0B0322             0443**  ;
0B0322             0444**  ; BIN - Get binary constant.
0B0322             0445**  ;   Inputs: ASCII string at (IY)
0B0322             0446**  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0B0322             0447**  ;           IY updated (points to delimiter)
0B0322             0448**  ;
0B0322 CD 44 09 0B 0449**  BIN:			CALL    ZERO			; Set result to 0
0B0326 CD BC 09 0B 0450**  			CALL	BINDIG			; Fetch the character from IY
0B032A 38 13       0451**  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
0B032C FD 23       0452**  BIN1:			INC	IY			; Move pointer to next character
0B032E 0F          0453**  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
0B032F D9          0454**  			EXX				;
0B0330 52 ED 6A    0455**  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
0B0333 D9          0456**  			EXX
0B0334 52 ED 6A    0457**  			ADC.S	HL,HL
0B0337 CD BC 09 0B 0458**  			CALL	BINDIG			; Fetch the next character
0B033B 30 EF       0459**  			JR	NC,BIN1
0B033D AF          0460**  			XOR	A			; Clear A
0B033E C9          0461**  			RET
0B033F             0462**  ;
0B033F 3E 1C       0463**  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0B0341 CD 28 37 0B 0464**  			CALL	EXTERR
0B0345 42 61 64 20 0465**  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0B0350             0466**  ;
0B0350             0467**  ; MINUS - Unary minus.
0B0350             0468**  ;   Inputs: IY = text pointer
0B0350             0469**  ;  Outputs: Numeric result, same type as argument.
0B0350             0470**  ;           Result in H'L'HLC
0B0350             0471**  ;
0B0350 CD CE 02 0B 0472**  MINUS:			CALL    ITEMN			; Get the numeric argument
0B0354 0D          0473**  MINUS0:			DEC     C			; Check exponent (C)
0B0355 0C          0474**  			INC     C			; If it is zero, then it's either a FP zero or an integer
0B0356 28 06       0475**  			JR      Z,NEGATE_EV        	; So do an integer negation
0B0358             0476**  ;
0B0358 7C          0477**  			LD      A,H			; Do a FP negation by
0B0359 EE 80       0478**  			XOR     80H             	; Toggling the sign bit (H)
0B035B 67          0479**  			LD      H,A
0B035C AF          0480**  			XOR     A               	; Numeric marker
0B035D C9          0481**  			RET
0B035E             0482**  ;
0B035E D9          0483**  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0B035F 7C          0484**  			LD      A,H			; First do a one's complement by negating all the bytes
0B0360 2F          0485**  			CPL
0B0361 67          0486**  			LD      H,A
0B0362 7D          0487**  			LD      A,L
0B0363 2F          0488**  			CPL
0B0364 6F          0489**  			LD      L,A
0B0365 D9          0490**  			EXX
0B0366 7C          0491**  			LD      A,H
0B0367 2F          0492**  			CPL
0B0368 67          0493**  			LD      H,A
0B0369 7D          0494**  			LD      A,L
0B036A 2F          0495**  			CPL
0B036B 6F          0496**  			LD      L,A
0B036C D9          0497**  ADD1:			EXX				; Then add 1
0B036D 23          0498**  			INC     HL
0B036E 7C          0499**  			LD      A,H
0B036F B5          0500**  			OR      L
0B0370 D9          0501**  			EXX
0B0371 3E 00       0502**  			LD      A,0             	; Numeric marker
0B0373 C0          0503**  			RET     NZ
0B0374 23          0504**  			INC     HL
0B0375 C9          0505**  			RET
0B0376             0506**  ;
0B0376             0507**  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0B0376             0508**  ; Item type is returned in A:  Bit 7=0 numeric.
0B0376             0509**  ;                              Bit 7=1 string.
0B0376             0510**  ; Numeric item returned in HLH'L'C.
0B0376             0511**  ; String item returned in string accumulator,
0B0376             0512**  ;   DE addresses byte after last (E=length).
0B0376             0513**  ;
0B0376 CD 00 16 0B 0514**  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0B037A CD 21 0A 0B 0515**  			CALL    NXT			; Skip spaces
0B037E FD 23       0516**  			INC     IY			; Move to the prefix character
0B0380 FE 26       0517**  			CP      '&'			; If `&`
0B0382 CA F7 02 0B 0518**  			JP      Z,HEX           	; Then get a HEX constant
0B0386 FE 25       0519**  			CP	'%'			; If '%'
0B0388 28 98       0520**  			JR	Z,BIN			; Then get a BINARY constant
0B038A FE 2D       0521**  			CP      '-'			; If `-`
0B038C 28 C2       0522**  			JR      Z,MINUS         	; Then get a negative number
0B038E FE 2B       0523**  			CP      '+'			; If `+`
0B0390 CA CE 02 0B 0524**  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0B0394 FE 28       0525**  			CP      '('			; If `(`
0B0396 CA ED 02 0B 0526**  			JP      Z,ITEM1         	; Start of a bracketed expression
0B039A FE 22       0527**  			CP      34			; If `"`
0B039C 28 7A       0528**  			JR      Z,CONS          	; Start of a string constant
0B039E FE C6       0529**  			CP      TCMD_EV			; Is it out of range of the function table?
0B03A0 D2 48 0C 0B 0530**  			JP      NC,SYNTAX       	; Error: "Syntax Error"
0B03A4 FE 8D       0531**  			CP      FUNTOK			; If it is in range, then
0B03A6 D2 34 0A 0B 0532**  			JP      NC,DISPAT       	; It's a function
0B03AA FD 2B       0533**  			DEC     IY
0B03AC FE 3A       0534**  			CP      ':'
0B03AE 30 0C       0535**  			JR      NC,ITEM2		; VARIABLE?
0B03B0 FE 30       0536**  			CP      '0'
0B03B2 D2 3F 04 0B 0537**  			JP      NC,CON			; NUMERIC CONSTANT
0B03B6 FE 2E       0538**  			CP      '.'
0B03B8 CA 3F 04 0B 0539**  			JP      Z,CON			; NUMERIC CONSTANT
0B03BC CD EB 39 0B 0540**  ITEM2:			CALL    GETVAR			; VARIABLE
0B03C0 20 37       0541**  			JR      NZ,NOSUCH
0B03C2 B7          0542**  			OR      A
0B03C3 FA 51 04 0B 0543**  			JP      M,LOADS			; STRING VARIABLE
0B03C7 B7          0544**  LOADN:			OR      A
0B03C8 28 20       0545**  			JR      Z,LOAD1			; BYTE VARIABLE
0B03CA 0E 00       0546**  			LD      C,0
0B03CC CB 47       0547**  			BIT     0,A
0B03CE 28 03       0548**  			JR      Z,LOAD4			; INTEGER VARIABLE
0B03D0 DD 4E 04    0549**  LOAD5:			LD      C,(IX+4)
0B03D3 D9          0550**  LOAD4:			EXX
0B03D4 21 00 00 00 0551**  			LD	HL, 0			; TODO: Optimise
0B03D8 DD 6E 00    0552**  			LD      L,(IX+0)
0B03DB DD 66 01    0553**  			LD      H,(IX+1)
0B03DE D9          0554**  			EXX
0B03DF 21 00 00 00 0555**  			LD	HL, 0			; TODO: Optimise
0B03E3 DD 6E 02    0556**  			LD      L,(IX+2)
0B03E6 DD 66 03    0557**  			LD      H,(IX+3)
0B03E9 C9          0558**  			RET
0B03EA             0559**  ;
0B03EA 21 00 00 00 0560**  LOAD1:			LD      HL,0
0B03EE D9          0561**  			EXX
0B03EF 21 00 00 00 0562**  			LD      HL,0			; TODO: Optimise
0B03F3 DD 6E 00    0563**  			LD      L,(IX+0)
0B03F6 D9          0564**  			EXX
0B03F7 4C          0565**  			LD      C,H
0B03F8 C9          0566**  			RET
0B03F9             0567**  ;
0B03F9 DA 48 0C 0B 0568**  NOSUCH:			JP      C,SYNTAX
0B03FD 3A 40 4C 0B 0569**  			LD      A,(LISTON)
0B0401 CB 6F       0570**  			BIT     5,A
0B0403 3E 1A       0571**  			LD      A,26
0B0405 20 26       0572**  			JR      NZ,ERROR0_EV		; Throw "No such variable"
0B0407 FD 23       0573**  NOS1:			INC     IY
0B0409 CD 20 3C 0B 0574**  			CALL    RANGE
0B040D 30 F8       0575**  			JR      NC,NOS1
0B040F DD 21 40 4B 0576**  			LD      IX,PC
       0B          
0B0414 AF          0577**  			XOR     A
0B0415 4F          0578**  			LD      C,A
0B0416 18 BB       0579**  			JR      LOAD4
0B0418             0580**  ;
0B0418             0581**  ;CONS - Get string constant from ASCII string.
0B0418             0582**  ;   Inputs: ASCII string at (IY)
0B0418             0583**  ;  Outputs: Result in string accumulator.
0B0418             0584**  ;           D = MS byte of ACCS, E = string length
0B0418             0585**  ;           A7 = 1 (string marker)
0B0418             0586**  ;           IY updated
0B0418             0587**  ;
0B0418 11 00 49 0B 0588**  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
0B041C FD 7E 00    0589**  CONS3:			LD      A,(IY)			; Fetch the first character and
0B041F FD 23       0590**  			INC     IY			; Increment the pointer
0B0421 FE 22       0591**  			CP      '"'			; Check for start quote
0B0423 28 0C       0592**  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
0B0425             0593**  ;
0B0425 12          0594**  CONS1:			LD      (DE),A			; Store the character in the string accumulator
0B0426 1C          0595**  			INC     E			; Increment the string accumulator pointer
0B0427 FE 0D       0596**  			CP      CR			; Is it CR
0B0429 20 F1       0597**  			JR      NZ,CONS3		; No, so keep looping
0B042B             0598**  ;
0B042B 3E 09       0599**  			LD      A,9
0B042D C3 11 37 0B 0600**  ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
0B0431             0601**  ;
0B0431 FD 7E 00    0602**  CONS2:			LD      A,(IY)			; Fetch the next character
0B0434 FE 22       0603**  			CP      '"'			; Check for end quote?
0B0436 FD 23       0604**  			INC     IY			; Increment the pointer
0B0438 28 EB       0605**  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
0B043A FD 2B       0606**  			DEC     IY			;
0B043C 3E 80       0607**  			LD      A,80H           	; String marker
0B043E C9          0608**  			RET
0B043F             0609**  ;
0B043F             0610**  ;CON - Get unsigned numeric constant from ASCII string.
0B043F             0611**  ;   Inputs: ASCII string at (IY).
0B043F             0612**  ;  Outputs: Variable-type result in HLH'L'C
0B043F             0613**  ;           IY updated (points to delimiter)
0B043F             0614**  ;           A7 = 0 (numeric marker)
0B043F             0615**  ;
0B043F FD E5       0616**  CON:			PUSH    IY
0B0441 DD E1       0617**  			POP     IX
0B0443 3E 24       0618**  			LD      A,36
0B0445 CD 1B 20 0B 0619**  			CALL    FPP
0B0449 38 E2       0620**  			JR      C,ERROR0_EV
0B044B DD E5       0621**  			PUSH    IX
0B044D FD E1       0622**  			POP     IY
0B044F AF          0623**  			XOR     A
0B0450 C9          0624**  			RET
0B0451             0625**  ;
0B0451 11 00 49 0B 0626**  LOADS:			LD      DE,ACCS			; Where to store the string
0B0455 1F          0627**  			RRA
0B0456 30 1A       0628**  			JR      NC,LOADS2       	; Skip if it is a fixed string
0B0458             0629**  ;
0B0458 D9          0630**  			EXX				; This block was a call to LOAD4
0B0459 DD 6E 00    0631**  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B045C DD 66 01    0632**  			LD      H,(IX+1)		; The maximum original string length
0B045F D9          0633**  			EXX
0B0460 DD 27 02    0634**  			LD	HL,(IX+2)		; Address of the string (24-bit)
0B0463             0635**  ;
0B0463 D9          0636**  			EXX
0B0464 7D          0637**  			LD      A,L
0B0465 D9          0638**  			EXX
0B0466 B7          0639**  			OR      A
0B0467 01 00 00 00 0640**  			LD	BC,0			; BC: Number of bytes to copy
0B046B 4F          0641**  			LD      C,A
0B046C 3E 80       0642**  			LD      A,80H           	; String marker
0B046E C8          0643**  			RET     Z
0B046F ED B0       0644**  			LDIR
0B0471 C9          0645**  			RET
0B0472 7E          0646**  LOADS2:			LD      A,(HL)
0B0473 12          0647**  			LD      (DE),A
0B0474 23          0648**  			INC     HL
0B0475 FE 0D       0649**  			CP      CR
0B0477 3E 80       0650**  			LD      A,80H           	; String marker
0B0479 C8          0651**  			RET     Z
0B047A 1C          0652**  			INC     E
0B047B 20 F5       0653**  			JR      NZ,LOADS2
0B047D C9          0654**  			RET                     	; Return null string
0B047E             0655**  ;
0B047E             0656**  ;VARIABLE-TYPE FUNCTIONS:
0B047E             0657**  ;
0B047E             0658**  ;Result returned in HLH'L'C (floating point)
0B047E             0659**  ;Result returned in HLH'L' (C=0) (integer)
0B047E             0660**  ;Result returned in string accumulator & DE (string)
0B047E             0661**  ;All registers destroyed.
0B047E             0662**  ;IY (text pointer) updated.
0B047E             0663**  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0B047E             0664**  ;
0B047E             0665**  ;POS - horizontal cursor position.
0B047E             0666**  ;VPOS - vertical cursor position.
0B047E             0667**  ;EOF - return status of file.
0B047E             0668**  ;BGET - read byte from file.
0B047E             0669**  ;INKEY - as GET but wait only n centiseconds.
0B047E             0670**  ;GET - wait for keypress and return ASCII value.
0B047E             0671**  ;GET(n) - input from Z80 port n.
0B047E             0672**  ;ASC - ASCII value of string.
0B047E             0673**  ;LEN - length of string.
0B047E             0674**  ;LOMEM - location of dynamic variables.
0B047E             0675**  ;HIMEM - top of available RAM.
0B047E             0676**  ;PAGE - start of current text page.
0B047E             0677**  ;TOP - address of first free byte after program.
0B047E             0678**  ;ERL - line number where last error occurred.
0B047E             0679**  ;ERR - number of last error.
0B047E             0680**  ;COUNT - number of printing characters since CR.
0B047E             0681**  ;Results are integer numeric.
0B047E             0682**  ;
0B047E CD 7D 3E 0B 0683**  POS:			CALL    GETCSR			; Return the horizontal cursor position
0B0482 EB          0684**  			EX      DE,HL			;  L: The X cursor position
0B0483 C3 32 05 0B 0685**  			JP      COUNT1			; Return an 8-bit value
0B0487             0686**  ;
0B0487 CD 7D 3E 0B 0687**  VPOS:			CALL    GETCSR			; Return the vertical cursor position
0B048B C3 32 05 0B 0688**  			JP      COUNT1			; Return an 8-bit value
0B048F             0689**  ;
0B048F CD 37 18 0B 0690**  EOF:			CALL    CHANEL			; Check for EOF
0B0493 CD F5 42 0B 0691**  			CALL    OSSTAT
0B0497 CA B6 05 0B 0692**  			JP      Z,TRUE			; Yes, so return true
0B049B C3 44 09 0B 0693**  			JP      ZERO			; Otherwise return false (zero)
0B049F             0694**  ;
0B049F CD 37 18 0B 0695**  BGET:			CALL    CHANEL          	; Channel number
0B04A3 CD E4 42 0B 0696**  			CALL    OSBGET
0B04A7 6F          0697**  			LD      L,A
0B04A8 C3 30 05 0B 0698**  			JP      COUNT0			; Return an 8-bit value
0B04AC             0699**  ;
0B04AC CD D6 02 0B 0700**  INKEY:			CALL    ITEMI			; Get the argument
0B04B0 CB 7C       0701**  			BIT	7, H			; Check the sign
0B04B2 D9          0702**  			EXX				; HL: The argument
0B04B3 C2 9C 07 0B 0703**  			JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
0B04B7 CD 8E 07 0B 0704**  			CALL	INKEY0 			; Do INKEY(n)
0B04BB 18 1D       0705**  			JR      ASC0			; Return a numeric value
0B04BD             0706**  ;
0B04BD CD 21 0A 0B 0707**  GET:			CALL    NXT			; Skip whitespace
0B04C1 FE 28       0708**  			CP      '('			; Is it GET(
0B04C3 20 0B       0709**  			JR      NZ,GET0			; No, so get a keyboard character
0B04C5 CD D6 02 0B 0710**  			CALL    ITEMI           	; Yes, so fetch the port address
0B04C9 D9          0711**  			EXX
0B04CA 44          0712**  			LD      B,H			; BC: The port address
0B04CB 4D          0713**  			LD      C,L
0B04CC ED 68       0714**  			IN      L,(C)           	;  L: Input from port BC
0B04CE 18 60       0715**  			JR      COUNT0			; Return an 8-bit value
0B04D0             0716**  ;
0B04D0 CD 78 07 0B 0717**  GET0:			CALL    GETS			; Read the keyboard character
0B04D4 18 0A       0718**  			JR      ASC1			; And return the value
0B04D6             0719**  ;
0B04D6 CD E1 02 0B 0720**  ASC:			CALL    ITEMS			; Get the string argument argument
0B04DA AF          0721**  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
0B04DB BB          0722**  			CP      E			; Is the pointer 0
0B04DC CA B6 05 0B 0723**  			JP      Z,TRUE          	; Yes, so return -1 as it is a null string
0B04E0 2A 00 49 0B 0724**  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
0B04E4 18 4A       0725**  			JR      COUNT0			; An 8-bit value
0B04E6             0726**  ;
0B04E6 CD E1 02 0B 0727**  LEN:			CALL    ITEMS			; Get the string argument
0B04EA EB          0728**  			EX      DE,HL			; HL: Pointer into ACCS
0B04EB 18 43       0729**  			JR      COUNT0			; Return L
0B04ED             0730**  ;
0B04ED 2A 1A 4C 0B 0731**  LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
0B04F1 3A 1C 4C 0B 0732**  			LD	A, (LOMEM+2)
0B04F5 18 41       0733**  			JR      COUNT2			; A 24-bit value
0B04F7             0734**  ;
0B04F7 2A 20 4C 0B 0735**  HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
0B04FB 3A 22 4C 0B 0736**  			LD	A, (HIMEM+2)
0B04FF 18 37       0737**  			JR      COUNT2			; A 24-bit value
0B0501             0738**  ;
0B0501 2A 14 4C 0B 0739**  PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
0B0505 3A 16 4C 0B 0740**  			LD	A, (PAGE_+2)		; A 24-bit value
0B0509 18 2D       0741**  			JR      COUNT2
0B050B             0742**  ;
0B050B FD 7E 00    0743**  TOPV:			LD      A,(IY)			; Return the TOP system variable
0B050E FD 23       0744**  			INC     IY              	; Skip "P"
0B0510 FE 50       0745**  			CP      'P'
0B0512 C2 48 0C 0B 0746**  			JP      NZ,SYNTAX       	; Throw "Syntax Error"
0B0516 2A 17 4C 0B 0747**  			LD      HL,(TOP)
0B051A 3A 19 4C 0B 0748**  			LD	A, (TOP+2)
0B051E 18 18       0749**  			JR      COUNT2
0B0520             0750**  ;
0B0520 2A 33 4C 0B 0751**  ERLV:			LD      HL,(ERL)		; Return the error line
0B0524 18 0C       0752**  			JR      COUNT1			; A 16-bit value
0B0526             0753**  ;
0B0526 2A 3F 4C 0B 0754**  ERRV:			LD      HL,(ERR)		; Return the error value
0B052A 18 04       0755**  			JR      COUNT0			; An 8-bit value
0B052C             0756**  ;
0B052C 2A 3D 4C 0B 0757**  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
0B0530             0758**  
0B0530 26 00       0759**  COUNT0:			LD      H,0			; Return L
0B0532 D9          0760**  COUNT1:			EXX				; Return HL
0B0533 AF          0761**  			XOR     A
0B0534 4F          0762**  			LD      C,A             	; Integer marker
0B0535 67          0763**  			LD      H,A
0B0536 6F          0764**  			LD      L,A
0B0537 C9          0765**  			RET
0B0538 D9          0766**  COUNT2:			EXX
0B0539 6F          0767**  			LD	L,A
0B053A AF          0768**  			XOR	A
0B053B 4F          0769**  			LD	C,A			; Integer marker
0B053C 67          0770**  			LD	H,A
0B053D C9          0771**  			RET
0B053E             0772**  ;
0B053E             0773**  ;OPENIN - Open a file for reading.
0B053E             0774**  ;OPENOT - Open a file for writing.
0B053E             0775**  ;OPENUP - Open a file for reading or writing.
0B053E             0776**  ;Result is integer channel number (0 if error)
0B053E             0777**  ;
0B053E AF          0778**  OPENOT:			XOR     A			; Open for writing
0B053F 18 06       0779**  			JR	OPENIN_1
0B0541             0780**  ;
0B0541 3E 02       0781**  OPENUP:			LD      A,2			; Open for reading / writing
0B0543 18 02       0782**  			JR	OPENIN_1
0B0545             0783**  ;
0B0545 3E 01       0784**  OPENIN:			LD      A,1			; Open for reading
0B0547             0785**  ;
0B0547 F5          0786**  OPENIN_1:		PUSH    AF              	; Save OPEN type
0B0548 CD E1 02 0B 0787**  			CALL    ITEMS           	; Fetch the filename
0B054C 3E 0D       0788**  			LD      A,CR
0B054E 12          0789**  			LD      (DE),A
0B054F F1          0790**  			POP     AF              	; Restore the OPEN type
0B0550 C6 FF       0791**  			ADD     A,-1            	; Affect the flags
0B0552 21 00 49 0B 0792**  			LD      HL,ACCS
0B0556 CD CD 42 0B 0793**  			CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0B055A 6F          0794**  			LD      L,A			; L: Channel number
0B055B 18 D3       0795**  			JR      COUNT0			; Return channel number to BASIC
0B055D             0796**  ;
0B055D             0797**  ;EXT - Return length of file.
0B055D             0798**  ;PTR_EV - Return current file pointer.
0B055D             0799**  ;Results are integer numeric.
0B055D             0800**  ;
0B055D CD 37 18 0B 0801**  EXT:			CALL    CHANEL
0B0561 CD 2B 43 0B 0802**  			CALL    GETEXT
0B0565 18 15       0803**  			JR      TIME0
0B0567             0804**  ;
0B0567 CD 37 18 0B 0805**  PTR_EV:			CALL    CHANEL
0B056B CD FF 42 0B 0806**  			CALL    GETPTR
0B056F 18 0B       0807**  			JR      TIME0
0B0571             0808**  ;
0B0571             0809**  ;TIME - Return current value of elapsed time.
0B0571             0810**  ;Result is integer numeric.
0B0571             0811**  ;
0B0571 FD 7E 00    0812**  TIMEV:			LD      A,(IY)
0B0574 FE 24       0813**  			CP      '$'
0B0576 28 0A       0814**  			JR      Z,TIMEVS
0B0578 CD 5D 3E 0B 0815**  			CALL    GETIME
0B057C D5          0816**  TIME0:			PUSH    DE
0B057D D9          0817**  			EXX
0B057E E1          0818**  			POP     HL
0B057F AF          0819**  			XOR     A
0B0580 4F          0820**  			LD      C,A
0B0581 C9          0821**  			RET
0B0582             0822**  ;
0B0582             0823**  ;TIME$ - Return date/time string.
0B0582             0824**  ;Result is string
0B0582             0825**  ;
0B0582 FD 23       0826**  TIMEVS:			INC     IY              ;SKIP $
0B0584 CD 44 43 0B 0827**  			CALL    GETIMS
0B0588 3E 80       0828**  			LD      A,80H           ;MARK STRING
0B058A C9          0829**  			RET
0B058B             0830**  ;
0B058B             0831**  ;String comparison:
0B058B             0832**  ;
0B058B CD 40 09 0B 0833**  SLT:			CALL    SCP
0B058F D0          0834**  			RET     NC
0B0590 18 24       0835**  			JR      TRUE
0B0592             0836**  ;
0B0592 CD 40 09 0B 0837**  SGT:			CALL    SCP
0B0596 C8          0838**  			RET     Z
0B0597 D8          0839**  			RET     C
0B0598 18 1C       0840**  			JR      TRUE
0B059A             0841**  ;
0B059A CD 40 09 0B 0842**  SGE:			CALL    SCP
0B059E D8          0843**  			RET     C
0B059F 18 15       0844**  			JR      TRUE
0B05A1             0845**  ;
0B05A1 CD 40 09 0B 0846**  SLE:			CALL    SCP
0B05A5 28 0F       0847**  			JR      Z,TRUE
0B05A7 D0          0848**  			RET     NC
0B05A8 18 0C       0849**  			JR      TRUE
0B05AA             0850**  ;
0B05AA CD 40 09 0B 0851**  SNE:			CALL    SCP
0B05AE C8          0852**  			RET     Z
0B05AF 18 05       0853**  			JR      TRUE
0B05B1             0854**  ;
0B05B1 CD 40 09 0B 0855**  SEQ:			CALL    SCP
0B05B5 C0          0856**  			RET     NZ
0B05B6 3E FF       0857**  TRUE:			LD      A,-1
0B05B8 D9          0858**  			EXX
0B05B9 67          0859**  			LD      H,A
0B05BA 6F          0860**  			LD      L,A
0B05BB D9          0861**  			EXX
0B05BC 67          0862**  			LD      H,A
0B05BD 6F          0863**  			LD      L,A
0B05BE 3C          0864**  			INC     A
0B05BF 4F          0865**  			LD      C,A
0B05C0 C9          0866**  			RET
0B05C1             0867**  ;
0B05C1             0868**  ;PI - Return PI (3.141592654)
0B05C1             0869**  ;Result is floating-point numeric.
0B05C1             0870**  ;
0B05C1 3E 23       0871**  PI:			LD      A,35
0B05C3 18 44       0872**  			JR      FPP1
0B05C5             0873**  ;
0B05C5             0874**  ;ABS - Absolute value
0B05C5             0875**  ;Result is numeric, variable type.
0B05C5             0876**  ;
0B05C5 3E 10       0877**  ABSV:			LD      A,16
0B05C7 18 3A       0878**  			JR      FPPN
0B05C9             0879**  ;
0B05C9             0880**  ;NOT - Complement integer.
0B05C9             0881**  ;Result is integer numeric.
0B05C9             0882**  ;
0B05C9 3E 1A       0883**  NOTK:			LD      A,26
0B05CB 18 36       0884**  			JR      FPPN
0B05CD             0885**  ;
0B05CD             0886**  ;DEG - Convert radians to degrees
0B05CD             0887**  ;Result is floating-point numeric.
0B05CD             0888**  ;
0B05CD 3E 15       0889**  DEG:			LD      A,21
0B05CF 18 32       0890**  			JR      FPPN
0B05D1             0891**  ;
0B05D1             0892**  ;RAD - Convert degrees to radians
0B05D1             0893**  ;Result is floating-point numeric.
0B05D1             0894**  ;
0B05D1 3E 1B       0895**  RAD:			LD      A,27
0B05D3 18 2E       0896**  			JR      FPPN
0B05D5             0897**  ;
0B05D5             0898**  ;SGN - Return -1, 0 or +1
0B05D5             0899**  ;Result is integer numeric.
0B05D5             0900**  ;
0B05D5 3E 1C       0901**  SGN:			LD      A,28
0B05D7 18 2A       0902**  			JR      FPPN
0B05D9             0903**  ;
0B05D9             0904**  ;INT - Floor function
0B05D9             0905**  ;Result is integer numeric.
0B05D9             0906**  ;
0B05D9 3E 17       0907**  INT_:			LD      A,23
0B05DB 18 26       0908**  			JR      FPPN
0B05DD             0909**  ;
0B05DD             0910**  ;SQR - square root
0B05DD             0911**  ;Result is floating-point numeric.
0B05DD             0912**  ;
0B05DD 3E 1E       0913**  SQR:			LD      A,30
0B05DF 18 22       0914**  			JR      FPPN
0B05E1             0915**  ;
0B05E1             0916**  ;TAN - Tangent function
0B05E1             0917**  ;Result is floating-point numeric.
0B05E1             0918**  ;
0B05E1 3E 1F       0919**  TAN:			LD      A,31
0B05E3 18 1E       0920**  			JR      FPPN
0B05E5             0921**  ;
0B05E5             0922**  ;COS - Cosine function
0B05E5             0923**  ;Result is floating-point numeric.
0B05E5             0924**  ;
0B05E5 3E 14       0925**  COS:			LD      A,20
0B05E7 18 1A       0926**  			JR      FPPN
0B05E9             0927**  ;
0B05E9             0928**  ;SIN - Sine function
0B05E9             0929**  ;Result is floating-point numeric.
0B05E9             0930**  ;
0B05E9 3E 1D       0931**  SIN:			LD      A,29
0B05EB 18 16       0932**  			JR      FPPN
0B05ED             0933**  ;
0B05ED             0934**  ;EXP - Exponential function
0B05ED             0935**  ;Result is floating-point numeric.
0B05ED             0936**  ;
0B05ED 3E 16       0937**  EXP:			LD      A,22
0B05EF 18 12       0938**  			JR      FPPN
0B05F1             0939**  ;
0B05F1             0940**  ;LN - Natural log.
0B05F1             0941**  ;Result is floating-point numeric.
0B05F1             0942**  ;
0B05F1 3E 18       0943**  LN:			LD      A,24
0B05F3 18 0E       0944**  			JR      FPPN
0B05F5             0945**  ;
0B05F5             0946**  ;LOG - base-10 logarithm.
0B05F5             0947**  ;Result is floating-point numeric.
0B05F5             0948**  ;
0B05F5 3E 19       0949**  LOG:			LD      A,25
0B05F7 18 0A       0950**  			JR      FPPN
0B05F9             0951**  ;
0B05F9             0952**  ;ASN - Arc-sine
0B05F9             0953**  ;Result is floating-point numeric.
0B05F9             0954**  ;
0B05F9 3E 12       0955**  ASN:			LD      A,18
0B05FB 18 06       0956**  			JR      FPPN
0B05FD             0957**  ;
0B05FD             0958**  ;ATN - arc-tangent
0B05FD             0959**  ;Result is floating-point numeric.
0B05FD             0960**  ;
0B05FD 3E 13       0961**  ATN:			LD      A,19
0B05FF 18 02       0962**  			JR      FPPN
0B0601             0963**  ;
0B0601             0964**  ;ACS - arc-cosine
0B0601             0965**  ;Result is floating point numeric.
0B0601             0966**  ;
0B0601 3E 11       0967**  ACS:			LD      A,17
0B0603 F5          0968**  FPPN:			PUSH    AF
0B0604 CD CE 02 0B 0969**  			CALL    ITEMN
0B0608 F1          0970**  			POP     AF
0B0609 CD 1B 20 0B 0971**  FPP1:			CALL    FPP
0B060D DA 11 37 0B 0972**  			JP      C,ERROR_
0B0611 AF          0973**  			XOR     A
0B0612 C9          0974**  			RET
0B0613             0975**  ;
0B0613             0976**  ;SFIX - Convert to fixed-point notation
0B0613             0977**  ;
0B0613 3E 26       0978**  SFIX:			LD      A,38
0B0615 18 F2       0979**  			JR      FPP1
0B0617             0980**  ;
0B0617             0981**  ;SFLOAT - Convert to floating-point notation
0B0617             0982**  ;
0B0617 3E 27       0983**  SFLOAT:			LD      A,39
0B0619 18 EE       0984**  			JR      FPP1
0B061B             0985**  ;
0B061B             0986**  ;VAL - Return numeric value of string.
0B061B             0987**  ;Result is variable type numeric.
0B061B             0988**  ;
0B061B CD E1 02 0B 0989**  VAL:			CALL    ITEMS
0B061F AF          0990**  VAL0:			XOR     A
0B0620 12          0991**  			LD      (DE),A
0B0621 DD 21 00 49 0992**  			LD      IX,ACCS
       0B          
0B0626 3E 24       0993**  			LD      A,36
0B0628 18 DF       0994**  			JR      FPP1
0B062A             0995**  ;
0B062A             0996**  ;EVAL - Pass string to expression evaluator.
0B062A             0997**  ;Result is variable type (numeric or string).
0B062A             0998**  ;
0B062A CD E1 02 0B 0999**  EVAL_:			CALL    ITEMS
0B062E 3E 0D       1000**  			LD      A,CR
0B0630 12          1001**  			LD      (DE),A
0B0631 FD E5       1002**  			PUSH    IY
0B0633 11 00 49 0B 1003**  			LD      DE,ACCS
0B0637 FD 21 00 49 1004**  			LD      IY,ACCS
       0B          
0B063C 0E 00       1005**  			LD      C,0
0B063E CD 50 3C 0B 1006**  			CALL    LEXAN2          ;TOKENISE
0B0642 12          1007**  			LD      (DE),A
0B0643 13          1008**  			INC     DE
0B0644 AF          1009**  			XOR     A
0B0645 CD 65 09 0B 1010**  			CALL    PUSHS           ;PUT ON STACK
0B0649 FD 21 03 00 1011**  			LD      IY,SIZEW	;WAS 2
       00          
0B064E FD 39       1012**  			ADD     IY,SP
0B0650 CD 78 01 0B 1013**  			CALL    EXPR
0B0654 FD E1       1014**  			POP     IY
0B0656 FD 39       1015**  			ADD     IY,SP
0B0658 FD F9       1016**  			LD      SP,IY           ;ADJUST STACK POINTER
0B065A FD E1       1017**  			POP     IY
0B065C 08          1018**  			EX      AF,AF'
0B065D C9          1019**  			RET
0B065E             1020**  ;
0B065E             1021**  ;RND - Random number function.
0B065E             1022**  ; RND gives random integer 0-&FFFFFFFF
0B065E             1023**  ; RND(-n) seeds random number & returns -n.
0B065E             1024**  ; RND(0) returns last value in RND(1) form.
0B065E             1025**  ; RND(1) returns floating-point 0-0.99999999.
0B065E             1026**  ; RND(n) returns random integer 1-n.
0B065E             1027**  ;
0B065E DD 21 38 4C 1028**  RND:			LD      IX,RANDOM
       0B          
0B0663 CD 21 0A 0B 1029**  			CALL    NXT
0B0667 FE 28       1030**  			CP      '('
0B0669 28 20       1031**  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0B066B CD D0 03 0B 1032**  			CALL    LOAD5
0B066F CB 19       1033**  RND1:			RR      C
0B0671 06 20       1034**  			LD      B,32
0B0673 D9          1035**  RND2:			EXX                     ;CALCULATE NEXT
0B0674 52 ED 6A    1036**  			ADC.S   HL,HL
0B0677 D9          1037**  			EXX
0B0678 52 ED 6A    1038**  			ADC.S   HL,HL
0B067B CB 5D       1039**  			BIT     3,L
0B067D 28 01       1040**  			JR      Z,RND3
0B067F 3F          1041**  			CCF
0B0680 10 F1       1042**  RND3:			DJNZ    RND2
0B0682 CB 11       1043**  RND4:			RL      C               ;SAVE CARRY
0B0684 CD 8C 15 0B 1044**  			CALL    STORE5          ;STORE NEW NUMBER
0B0688 AF          1045**  			XOR     A
0B0689 4F          1046**  			LD      C,A
0B068A C9          1047**  			RET
0B068B CD D6 02 0B 1048**  RND5:			CALL    ITEMI
0B068F DD 21 38 4C 1049**  			LD      IX,RANDOM
       0B          
0B0694 CB 7C       1050**  			BIT     7,H             ;NEGATIVE?
0B0696 37          1051**  			SCF
0B0697 20 E9       1052**  			JR      NZ,RND4         ;SEED
0B0699 CD 90 08 0B 1053**  			CALL    TEST
0B069D F5          1054**  			PUSH    AF
0B069E CD 88 08 0B 1055**  			CALL    SWAP
0B06A2 D9          1056**  			EXX
0B06A3 CD D0 03 0B 1057**  			CALL    LOAD5
0B06A7 C4 6F 06 0B 1058**  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0B06AB D9          1059**  			EXX                     ;SCRAMBLE (CARE!)
0B06AC 0E 7F       1060**  			LD      C,7FH
0B06AE CB 7C       1061**  RND6:			BIT     7,H             ;FLOAT
0B06B0 20 0A       1062**  			JR      NZ,RND7
0B06B2 D9          1063**  			EXX
0B06B3 52 29       1064**  			ADD.S   HL,HL
0B06B5 D9          1065**  			EXX
0B06B6 52 ED 6A    1066**  			ADC.S   HL,HL
0B06B9 0D          1067**  			DEC     C
0B06BA 20 F2       1068**  			JR      NZ,RND6
0B06BC CB BC       1069**  RND7:			RES     7,H             ;POSITIVE 0-0.999999
0B06BE F1          1070**  			POP     AF
0B06BF C8          1071**  			RET     Z               ;ZERO ARGUMENT
0B06C0 D9          1072**  			EXX
0B06C1 7B          1073**  			LD      A,E
0B06C2 3D          1074**  			DEC     A
0B06C3 B2          1075**  			OR      D
0B06C4 D9          1076**  			EXX
0B06C5 B3          1077**  			OR      E
0B06C6 B2          1078**  			OR      D
0B06C7 C8          1079**  			RET     Z               ;ARGUMENT=1
0B06C8 06 00       1080**  			LD      B,0             ;INTEGER MARKER
0B06CA 3E 0A       1081**  			LD      A,10
0B06CC CD 1B 20 0B 1082**  			CALL    FPP             ;MULTIPLY
0B06D0 DA 11 37 0B 1083**  			JP      C,ERROR_
0B06D4 CD 13 06 0B 1084**  			CALL    SFIX
0B06D8 C3 6C 03 0B 1085**  			JP      ADD1
0B06DC             1086**  ;
0B06DC             1087**  ; INSTR - String search.
0B06DC             1088**  ; Result is integer numeric.
0B06DC             1089**  ;
0B06DC CD CF 09 0B 1090**  INSTR:			CALL    EXPRSC			; Get the first string expression
0B06E0 CD 65 09 0B 1091**  			CALL    PUSHS           	; Push the string onto the stack
0B06E4 CD C6 02 0B 1092**  			CALL    EXPRS           	; Get the second string expression
0B06E8 C1          1093**  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
0B06E9 21 00 00 00 1094**  			LD      HL,0
0B06ED 39          1095**  			ADD     HL,SP           	; HL: Pointer to main string
0B06EE C5          1096**  			PUSH    BC              	;  C: Main string length
0B06EF 43          1097**  			LD      B,E             	;  B: Sub-string length
0B06F0 CD 21 0A 0B 1098**  			CALL    NXT			; Skip whitespace
0B06F4 FE 2C       1099**  			CP      ','			; Check if there is a comma for the third parameter
0B06F6 3E 00       1100**  			LD      A,0			;  A: Default start position in string
0B06F8 20 1A       1101**  			JR      NZ,INSTR1		; No, so skip the next bit
0B06FA FD 23       1102**  			INC     IY              	; Skip the comma
0B06FC C5          1103**  			PUSH    BC              	; Save the lengths
0B06FD E5          1104**  			PUSH    HL              	; Save the pointer to the main string
0B06FE CD 65 09 0B 1105**  			CALL    PUSHS			; Push the string onto the stack
0B0702 CD BB 02 0B 1106**  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
0B0706 C1          1107**  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
0B0707 CD 8F 09 0B 1108**  			CALL    POPS			; Pop the string off the stack
0B070B E1          1109**  			POP     HL              	; Restore the pointer to the main string
0B070C C1          1110**  			POP     BC              	; Restore the lengths
0B070D D9          1111**  			EXX
0B070E 7D          1112**  			LD      A,L			; A: The start position in the  string
0B070F D9          1113**  			EXX
0B0710 B7          1114**  			OR      A			; Set the flags
0B0711 28 01       1115**  			JR      Z,INSTR1		; If it is zero, then skip
0B0713 3D          1116**  			DEC     A
0B0714 11 00 49 0B 1117**  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
0B0718 CD 36 07 0B 1118**  			CALL    SEARCH			; Do the search
0B071C D1          1119**  			POP     DE
0B071D 28 03       1120**  			JR      Z,INSTR2        	; NB: Carry cleared
0B071F ED 62       1121**  			SBC     HL,HL
0B0721 39          1122**  			ADD     HL,SP
0B0722 ED 72       1123**  INSTR2:			SBC     HL,SP
0B0724 EB          1124**  			EX      DE,HL
0B0725 7D          1125**  			LD	A,L
0B0726 21 00 00 00 1126**  			LD      HL,0
0B072A 6F          1127**  			LD	L,A
0B072B 39          1128**  			ADD     HL,SP
0B072C F9          1129**  			LD      SP,HL
0B072D EB          1130**  			EX      DE,HL
0B072E CD E0 09 0B 1131**  			CALL    BRAKET			; Check for closing bracket
0B0732 C3 32 05 0B 1132**  			JP      COUNT1			; Return a numeric integer
0B0736             1133**  ;
0B0736             1134**  ; SEARCH - Search string for sub-string
0B0736             1135**  ;    Inputs: Main string at HL length C
0B0736             1136**  ;            Sub-string  at DE length B
0B0736             1137**  ;            Starting offset A
0B0736             1138**  ;   Outputs: NZ - not found
0B0736             1139**  ;            Z - found at location HL-1
0B0736             1140**  ;            Carry always cleared
0B0736             1141**  ;
0B0736 C5          1142**  SEARCH:			PUSH    BC			; Add the starting offset to HL
0B0737 01 00 00 00 1143**  			LD      BC,0
0B073B 4F          1144**  			LD      C,A
0B073C 09          1145**  			ADD     HL,BC           	; New start address
0B073D C1          1146**  			POP     BC
0B073E 91          1147**  			SUB     C			; If the starting offset > main string length, then do nothing
0B073F 30 2C       1148**  			JR      NC,SRCH4
0B0741 ED 44       1149**  			NEG
0B0743 4F          1150**  			LD      C,A             	; Remaining length
0B0744             1151**  ;
0B0744 C5          1152**  SRCH1:			PUSH    BC
0B0745 79          1153**  			LD	A,C
0B0746 01 00 00 00 1154**  			LD	BC,0
0B074A 4F          1155**  			LD	C,A
0B074B 1A          1156**  			LD      A,(DE)
0B074C ED B1       1157**  			CPIR                    	; Find the first character
0B074E 79          1158**  			LD      A,C
0B074F C1          1159**  			POP     BC
0B0750 20 1B       1160**  			JR      NZ,SRCH4
0B0752 4F          1161**  			LD      C,A
0B0753             1162**  ;
0B0753             1163**  ; This block of four instructions was commented as a bug fix by R.T.Russell
0B0753             1164**  ;
0B0753 05          1165**  			DEC     B			; Bug fix
0B0754 B8          1166**  			CP      B			; Bug fix
0B0755 04          1167**  			INC     B			; Bug fix
0B0756 38 15       1168**  			JR      C,SRCH4			; Bug fix
0B0758             1169**  ;
0B0758 C5          1170**  			PUSH    BC
0B0759 D5          1171**  			PUSH    DE
0B075A E5          1172**  			PUSH    HL
0B075B 05          1173**  			DEC     B
0B075C 28 08       1174**  			JR      Z,SRCH3         	; Found!
0B075E 13          1175**  SRCH2:			INC     DE
0B075F 1A          1176**  			LD      A,(DE)
0B0760 BE          1177**  			CP      (HL)
0B0761 20 03       1178**  			JR      NZ,SRCH3
0B0763 23          1179**  			INC     HL
0B0764 10 F8       1180**  			DJNZ    SRCH2
0B0766 E1          1181**  SRCH3:			POP     HL
0B0767 D1          1182**  			POP     DE
0B0768 C1          1183**  			POP     BC
0B0769 20 D9       1184**  			JR      NZ,SRCH1
0B076B AF          1185**  			XOR     A               	; Flags: Z, NC
0B076C C9          1186**  			RET                     	; Found
0B076D             1187**  ;
0B076D F6 FF       1188**  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0B076F C9          1189**  			RET                     	; Not found
0B0770             1190**  ;
0B0770             1191**  ;CHRS - Return character with given ASCII value.
0B0770             1192**  ;Result is string.
0B0770             1193**  ;
0B0770 CD D6 02 0B 1194**  CHRS:			CALL    ITEMI
0B0774 D9          1195**  			EXX
0B0775 7D          1196**  			LD      A,L
0B0776 18 0E       1197**  			JR      GET1
0B0778             1198**  ;
0B0778             1199**  ;GETS - Return key pressed as stringor character at position (X,Y).
0B0778             1200**  ;Result is string.
0B0778             1201**  ;
0B0778 CD 21 0A 0B 1202**  GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0B077C FE 28       1203**  			CP	'('
0B077E CA AD 43 0B 1204**  			JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0B0782 CD DA 3E 0B 1205**  			CALL    OSRDCH
0B0786 37          1206**  GET1:			SCF
0B0787 18 09       1207**  			JR      INKEY1
0B0789             1208**  ;
0B0789             1209**  ; INKEYS - Wait up to n centiseconds for keypress.
0B0789             1210**  ;          Return key pressed as string or null
0B0789             1211**  ;          string if time elapsed.
0B0789             1212**  ; Result is string.
0B0789             1213**  ;
0B0789 CD D6 02 0B 1214**  INKEYS:			CALL    ITEMI			; Fetch the argument
0B078D D9          1215**  			EXX
0B078E CD E3 3E 0B 1216**  INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0B0792 11 00 49 0B 1217**  INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0B0796 12          1218**  			LD      (DE),A
0B0797 3E 80       1219**  			LD      A,80H
0B0799 D0          1220**  			RET     NC
0B079A 1C          1221**  			INC     E
0B079B C9          1222**  			RET
0B079C             1223**  ;
0B079C             1224**  ; INKEYM - Check immediately whether a given key is being pressed
0B079C             1225**  ; Result is integer numeric
0B079C             1226**  ;
0B079C             1227**  INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0B079C 3E 1E       0001**M 			LD	A, function
0B079E 49 CF       0002**M 			RST.LIS	08h
0B07A0 23          1228**  			INC	HL			; Index from 0
0B07A1 7D          1229**  			LD	A, L			; Negate the LSB of the answer
0B07A2 ED 44       1230**  			NEG
0B07A4 4F          1231**  			LD	C, A			;  E: The positive keycode value
0B07A5 3E 01       1232**  			LD	A, 1			; Throw an "Out of range" error
0B07A7 FA 11 37 0B 1233**  			JP	M, ERROR_		; if the argument < - 128
0B07AB             1234**  ;
0B07AB 21 CE 07 0B 1235**  			LD	HL, BITLOOKUP		; HL: The bit lookup table
0B07AF 11 00 00 00 1236**  			LD	DE, 0
0B07B3 79          1237**  			LD	A, C
0B07B4 E6 07       1238**  			AND	00000111b		; Just need the first three bits
0B07B6 5F          1239**  			LD	E, A			; DE: The bit number
0B07B7 19          1240**  			ADD	HL, DE
0B07B8 46          1241**  			LD	B, (HL)			;  B: The mask
0B07B9             1242**  ;
0B07B9 79          1243**  			LD	A, C			; Fetch the keycode again
0B07BA E6 78       1244**  			AND	01111000b		; And divide by 8
0B07BC 0F          1245**  			RRCA
0B07BD 0F          1246**  			RRCA
0B07BE 0F          1247**  			RRCA
0B07BF 5F          1248**  			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
0B07C0 DD 19       1249**  			ADD	IX, DE			; IX: The address
0B07C2 78          1250**  			LD	A, B			;  B: The mask
0B07C3 DD A6 00    1251**  			AND	(IX+0)			; Check whether the bit is set
0B07C6 CA 44 09 0B 1252**  			JP	Z, ZERO			; No, so return 0
0B07CA C3 B6 05 0B 1253**  			JP	TRUE			; Otherwise return -1
0B07CE             1254**  ;
0B07CE             1255**  ; A bit lookup table
0B07CE             1256**  ;
0B07CE 01 02 04 08 1257**  BITLOOKUP:		DB	01h, 02h, 04h, 08h
0B07D2 10 20 40 80 1258**  			DB	10h, 20h, 40h, 80h
0B07D6             1259**  ;
0B07D6             1260**  ; MID$ - Return sub-string.
0B07D6             1261**  ; Result is string.
0B07D6             1262**  ;
0B07D6 CD CF 09 0B 1263**  MIDS:			CALL    EXPRSC			; Get the first string expression
0B07DA CD 65 09 0B 1264**  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B07DE CD BB 02 0B 1265**  			CALL    EXPRI			; Get the second expression
0B07E2 C1          1266**  			POP     BC			; C: String length, B: Value of A before PUSHS was called
0B07E3 CD 8F 09 0B 1267**  			CALL    POPS			; Pop the string back off the stack to the string accumulator
0B07E7 D9          1268**  			EXX
0B07E8 7D          1269**  			LD      A,L			; A: The start index
0B07E9 D9          1270**  			EXX
0B07EA B7          1271**  			OR      A			; If the start index is 0, then we don't need to do the next bit
0B07EB 28 0E       1272**  			JR      Z,MIDS1
0B07ED 3D          1273**  			DEC     A
0B07EE 6F          1274**  			LD      L,A			; L: The start index - 1
0B07EF 93          1275**  			SUB     E			; Subtract from the string length
0B07F0 1E 00       1276**  			LD      E,0			; Preemptively set the string length to 0
0B07F2 30 07       1277**  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
0B07F4 ED 44       1278**  			NEG				; Negate the answer and
0B07F6 4F          1279**  			LD      C,A			; C: Number of bytes to copy
0B07F7 CD 3A 08 0B 1280**  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
0B07FB CD 21 0A 0B 1281**  MIDS1:			CALL    NXT			; Skip whitespace
0B07FF FE 2C       1282**  			CP      ','			; Check for a comma
0B0801 FD 23       1283**  			INC     IY			; Advance to the next character in the BASIC line
0B0803 28 0D       1284**  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
0B0805 FD 2B       1285**  			DEC     IY			; Restore the BASIC program pointer
0B0807 CD E0 09 0B 1286**  			CALL    BRAKET			; Check for a bracket
0B080B 3E 80       1287**  			LD      A,80H			; String marker
0B080D C9          1288**  			RET
0B080E             1289**  ;
0B080E             1290**  ; LEFT$ - Return left part of string.
0B080E             1291**  ; Carry cleared if entire string returned.
0B080E             1292**  ; Result is string.
0B080E             1293**  ;
0B080E CD CF 09 0B 1294**  LEFTS:			CALL    EXPRSC			; Get the first string expression
0B0812 CD 65 09 0B 1295**  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B0816 CD BB 02 0B 1296**  			CALL    EXPRI			; Get the second expression
0B081A C1          1297**  			POP     BC			; C: String length, B: Value of A before PUSHS was called
0B081B CD 8F 09 0B 1298**  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
0B081F CD E0 09 0B 1299**  			CALL    BRAKET			; Check for closing bracket
0B0823 D9          1300**  			EXX
0B0824 7D          1301**  			LD      A,L			; L: The second parameter
0B0825 D9          1302**  			EXX
0B0826 BB          1303**  			CP      E			; Compare with the string length
0B0827 30 02       1304**  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
0B0829 6B          1305**  			LD      L,E             	; For RIGHTS, no effect in LEFTS
0B082A 5F          1306**  LEFT2:			LD      E,A			; E: The new length of string
0B082B 3E 80       1307**  LEFT3:			LD      A,80H           	; String marker
0B082D C9          1308**  			RET
0B082E             1309**  ;
0B082E             1310**  ; RIGHT$ - Return right part of string.
0B082E             1311**  ; Result is string.
0B082E             1312**  ;
0B082E CD 0E 08 0B 1313**  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
0B0832 D0          1314**  			RET     NC			; Do nothing if the second parameter is >= string length
0B0833 1C          1315**  			INC     E			; Check for a zero length string
0B0834 1D          1316**  			DEC     E
0B0835 C8          1317**  			RET     Z			; Yes, so do nothing
0B0836 4B          1318**  			LD      C,E			;  C: Number of bytes to copy
0B0837 7D          1319**  			LD      A,L
0B0838 93          1320**  			SUB     E
0B0839 6F          1321**  			LD      L,A			;  L: Index into the string
0B083A 79          1322**  RIGHT1:			LD	A,C
0B083B 01 00 00 00 1323**  			LD	BC,0
0B083F 4F          1324**  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
0B0840 7D          1325**  			LD	A,L
0B0841 21 00 49 0B 1326**  			LD	HL,ACCS
0B0845 6F          1327**  			LD	L,A			; HL: Source (in ACCS)
0B0846 11 00 49 0B 1328**  			LD      DE,ACCS			; DE: Destination (start of ACCS)
0B084A ED B0       1329**  			LDIR                    	; Copy
0B084C 3E 80       1330**  			LD      A,80H			; String marker
0B084E C9          1331**  			RET
0B084F             1332**  ;
0B084F             1333**  ; STRINGS - Return n concatenations of a string.
0B084F             1334**  ; Result is string.
0B084F             1335**  ;
0B084F CD BB 02 0B 1336**  STRING_:		CALL    EXPRI			; Get number of times to replicate
0B0853 CD D3 09 0B 1337**  			CALL    COMMA			; Check for comma
0B0857 D9          1338**  			EXX
0B0858 7D          1339**  			LD      A,L			; L: Number of iterations of string
0B0859 D9          1340**  			EXX
0B085A F5          1341**  			PUSH    AF
0B085B CD C6 02 0B 1342**  			CALL    EXPRS			; Get the string
0B085F CD E0 09 0B 1343**  			CALL    BRAKET			; Check for closing bracket
0B0863 F1          1344**  			POP     AF			; A: Number of iterations of string
0B0864 B7          1345**  			OR      A			; Set flags
0B0865 28 C3       1346**  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0B0867 3D          1347**  			DEC     A
0B0868 4F          1348**  			LD      C,A			; C: Loop counter
0B0869 3E 80       1349**  			LD      A,80H			; String marker
0B086B C8          1350**  			RET     Z
0B086C 1C          1351**  			INC     E			; Check for empty string
0B086D 1D          1352**  			DEC     E
0B086E C8          1353**  			RET     Z              		; And return
0B086F 43          1354**  			LD      B,E			; B: String length tally
0B0870 21 00 49 0B 1355**  			LD	HL,ACCS
0B0874 C5          1356**  STRIN1:			PUSH    BC
0B0875 7E          1357**  STRIN2:			LD      A,(HL)
0B0876 23          1358**  			INC     HL
0B0877 12          1359**  			LD      (DE),A
0B0878 1C          1360**  			INC     E
0B0879 3E 13       1361**  			LD      A,19
0B087B CA 11 37 0B 1362**  			JP      Z,ERROR_         	; Throw a "String too long" error
0B087F 10 F4       1363**  			DJNZ    STRIN2
0B0881 C1          1364**  			POP     BC
0B0882 0D          1365**  			DEC     C
0B0883 20 EF       1366**  			JR      NZ,STRIN1
0B0885 3E 80       1367**  			LD      A,80H
0B0887 C9          1368**  			RET
0B0888             1369**  ;
0B0888             1370**  ;SUBROUTINES
0B0888             1371**  ;
0B0888             1372**  ;SWAP - Swap arguments
0B0888             1373**  ;Exchanges DE,HL D'E',H'L' and B,C
0B0888             1374**  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B0888             1375**  ;
0B0888 79          1376**  SWAP:			LD      A,C
0B0889 48          1377**  			LD      C,B
0B088A 47          1378**  			LD      B,A
0B088B EB          1379**  			EX      DE,HL
0B088C D9          1380**  			EXX
0B088D EB          1381**  			EX      DE,HL
0B088E D9          1382**  			EXX
0B088F C9          1383**  			RET
0B0890             1384**  ;
0B0890             1385**  ;TEST - Test HLH'L' for zero
0B0890             1386**  ;Outputs: Z-flag set & A=0 if zero
0B0890             1387**  ;Destroys: A,F
0B0890             1388**  ;
0B0890 7C          1389**  TEST:			LD      A,H
0B0891 B5          1390**  			OR      L
0B0892 D9          1391**  			EXX
0B0893 B4          1392**  			OR      H
0B0894 B5          1393**  			OR      L
0B0895 D9          1394**  			EXX
0B0896 C9          1395**  			RET
0B0897             1396**  ;
0B0897             1397**  ;DECODE - Decode line number in pseudo-binary.
0B0897             1398**  ;   Inputs: IY = Text pointer.
0B0897             1399**  ;   Outputs: HL=0, H'L'=line number, C=0.
0B0897             1400**  ;   Destroys: A,C,H,L,H',L',IY,F
0B0897             1401**  ;
0B0897 D9          1402**  DECODE:			EXX
0B0898 21 00 00 00 1403**  			LD	HL, 0
0B089C FD 7E 00    1404**  			LD      A,(IY)
0B089F FD 23       1405**  			INC     IY
0B08A1 17          1406**  			RLA
0B08A2 17          1407**  			RLA
0B08A3 67          1408**  			LD      H,A
0B08A4 E6 C0       1409**  			AND     0C0H
0B08A6 FD AE 00    1410**  			XOR     (IY)
0B08A9 FD 23       1411**  			INC     IY
0B08AB 6F          1412**  			LD      L,A
0B08AC 7C          1413**  			LD      A,H
0B08AD 17          1414**  			RLA
0B08AE 17          1415**  			RLA
0B08AF E6 C0       1416**  			AND     0C0H
0B08B1 FD AE 00    1417**  			XOR     (IY)
0B08B4 FD 23       1418**  			INC     IY
0B08B6 67          1419**  			LD      H,A
0B08B7 D9          1420**  			EXX
0B08B8             1421**  ;			XOR     A
0B08B8             1422**  ;			LD      C,A
0B08B8             1423**  ;			LD      H,A
0B08B8             1424**  ;			LD      L,A
0B08B8 21 00 00 00 1425**  			LD	HL, 0
0B08BC 4D          1426**  			LD	C, L
0B08BD C9          1427**  			RET
0B08BE             1428**  ;
0B08BE             1429**  ;HEXSTR - convert numeric value to HEX string.
0B08BE             1430**  ;   Inputs: HLH'L'C = integer or floating-point number
0B08BE             1431**  ;  Outputs: String in string accumulator.
0B08BE             1432**  ;           E = string length.  D = ACCS/256
0B08BE             1433**  ;
0B08BE FD 23       1434**  HEXSTS:			INC     IY              ;SKIP TILDE
0B08C0 CD CE 02 0B 1435**  			CALL    ITEMN
0B08C4 CD CB 08 0B 1436**  			CALL    HEXSTR
0B08C8 3E 80       1437**  			LD      A,80H
0B08CA C9          1438**  			RET
0B08CB             1439**  ;
0B08CB CD 13 06 0B 1440**  HEXSTR:			CALL    SFIX
0B08CF 01 08 00 00 1441**  			LD      BC,8
0B08D3 11 00 49 0B 1442**  			LD      DE,ACCS
0B08D7 C5          1443**  HEXST1:			PUSH    BC
0B08D8 06 04       1444**  			LD      B,4
0B08DA AF          1445**  			XOR     A
0B08DB D9          1446**  HEXST2:			EXX
0B08DC 52 29       1447**  			ADD.S	HL,HL
0B08DE D9          1448**  			EXX
0B08DF 52 ED 6A    1449**  			ADC.S	HL,HL
0B08E2 17          1450**  			RLA
0B08E3 10 F6       1451**  			DJNZ    HEXST2
0B08E5 C1          1452**  			POP     BC
0B08E6 0D          1453**  			DEC     C
0B08E7 F8          1454**  			RET     M
0B08E8 28 06       1455**  			JR      Z,HEXST3
0B08EA B7          1456**  			OR      A
0B08EB 20 03       1457**  			JR      NZ,HEXST3
0B08ED B8          1458**  			CP      B
0B08EE 28 E7       1459**  			JR      Z,HEXST1
0B08F0 C6 90       1460**  HEXST3:			ADD     A,90H
0B08F2 27          1461**  			DAA
0B08F3 CE 40       1462**  			ADC     A,40H
0B08F5 27          1463**  			DAA
0B08F6 12          1464**  			LD      (DE),A
0B08F7 13          1465**  			INC     DE
0B08F8 47          1466**  			LD      B,A
0B08F9 18 DC       1467**  			JR      HEXST1
0B08FB             1468**  ;
0B08FB             1469**  ;Function STR - convert numeric value to ASCII string.
0B08FB             1470**  ;   Inputs: HLH'L'C = integer or floating-point number.
0B08FB             1471**  ;  Outputs: String in string accumulator.
0B08FB             1472**  ;           E = length, D = ACCS/256
0B08FB             1473**  ;           A = 80H (type=string)
0B08FB             1474**  ;
0B08FB             1475**  ;First normalise for decimal output:
0B08FB             1476**  ;
0B08FB CD 21 0A 0B 1477**  STRS:			CALL    NXT
0B08FF FE 7E       1478**  			CP      '~'
0B0901 28 BB       1479**  			JR      Z,HEXSTS
0B0903 CD CE 02 0B 1480**  			CALL    ITEMN
0B0907 DD 21 00 4B 1481**  			LD      IX,STAVAR
       0B          
0B090C DD 7E 03    1482**  			LD      A,(IX+3)
0B090F B7          1483**  			OR      A
0B0910 DD 21 3D 09 1484**  			LD      IX,G9-1         ;G9 FORMAT
       0B          
0B0915 28 05       1485**  			JR      Z,STR0
0B0917 DD 21 00 4B 1486**  STR:			LD      IX,STAVAR
       0B          
0B091C 11 00 49 0B 1487**  STR0:			LD      DE,ACCS
0B0920 3E 25       1488**  			LD      A,37
0B0922 CD 1B 20 0B 1489**  			CALL    FPP
0B0926 DA 11 37 0B 1490**  			JP      C,ERROR_
0B092A DD CB 02 46 1491**  			BIT     0,(IX+2)
0B092E 3E 80       1492**  STR1:			LD      A,80H           ;STRING MARKER
0B0930 C8          1493**  			RET     Z
0B0931 79          1494**  			LD      A,C
0B0932 C6 04       1495**  			ADD     A,4
0B0934 BB          1496**  STR2:			CP      E
0B0935 28 F7       1497**  			JR      Z,STR1
0B0937 EB          1498**  			EX      DE,HL
0B0938 36 20       1499**  			LD      (HL),' '        ;TRAILING SPACE
0B093A 23          1500**  			INC     HL
0B093B EB          1501**  			EX      DE,HL
0B093C 18 F6       1502**  			JR      STR2
0B093E             1503**  ;
0B093E 09 00       1504**  G9:			DW    9
0B0940             1505**  ;
0B0940             1506**  ;STRING COMPARE
0B0940             1507**  ;Compare string (DE) length B with string (HL) length C.
0B0940             1508**  ;Result preset to false.
0B0940             1509**  ;
0B0940 CD 4E 09 0B 1510**  SCP:			CALL	SCP0
0B0944             1511**  ;
0B0944 3E 00       1512**  ZERO:			LD      A,0
0B0946 D9          1513**  			EXX
0B0947 67          1514**  			LD      H,A
0B0948 6F          1515**  			LD      L,A
0B0949 D9          1516**  			EXX
0B094A 67          1517**  			LD      H,A
0B094B 6F          1518**  			LD      L,A
0B094C 4F          1519**  			LD      C,A
0B094D C9          1520**  			RET
0B094E             1521**  ;
0B094E 04          1522**  SCP0:			INC     B
0B094F 0C          1523**  			INC     C
0B0950 05          1524**  SCP1:			DEC     B
0B0951 28 0A       1525**  			JR      Z,SCP2
0B0953 0D          1526**  			DEC     C
0B0954 28 0C       1527**  			JR      Z,SCP3
0B0956 1A          1528**  			LD      A,(DE)
0B0957 BE          1529**  			CP      (HL)
0B0958 C0          1530**  			RET     NZ
0B0959 13          1531**  			INC     DE
0B095A 23          1532**  			INC     HL
0B095B 18 F3       1533**  			JR      SCP1
0B095D B7          1534**  SCP2:			OR      A
0B095E 0D          1535**  			DEC     C
0B095F C8          1536**  			RET     Z
0B0960 37          1537**  			SCF
0B0961 C9          1538**  			RET
0B0962 B7          1539**  SCP3:			OR      A
0B0963 0C          1540**  			INC     C
0B0964 C9          1541**  			RET
0B0965             1542**  ;
0B0965             1543**  ; PUSHS - SAVE STRING ON STACK.
0B0965             1544**  ;     Inputs: String in string accumulator.
0B0965             1545**  ;             E = string length.
0B0965             1546**  ;             A - saved on stack.
0B0965             1547**  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0B0965             1548**  ;
0B0965 CD 00 16 0B 1549**  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0B0969 DD E1       1550**  			POP     IX              	; IX: Return address
0B096B B7          1551**  			OR      A               	; Clear the carry flag
0B096C 01 00 00 00 1552**  			LD	BC,0			; BC: Length of the string
0B0970 4B          1553**  			LD	C,E
0B0971 21 00 49 0B 1554**  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B0975 11 00 49 0B 1555**  			LD	DE,ACCS
0B0979 59          1556**  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0B097A ED 52       1557**  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0B097C 39          1558**  			ADD     HL,SP			; Grow the stack
0B097D F9          1559**  			LD      SP,HL
0B097E 57          1560**  			LD      D,A			;  D: This needs to be set to A for some functions
0B097F             1561**  ; BEGIN MISSING FROM BINARY
0B097F             1562**  			; LD	B,A			; Stack A and C (the string length)
0B097F             1563**  			; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0B097F             1564**  			; LD	B,0			; Reset B to 0 for the LDIR in this function
0B097F             1565**  ; END MISSING FROM BINARY
0B097F D5          1566**  			PUSH 	DE ; ADDED FROM BINARY
0B0980 28 0B       1567**  			JR      Z,PUSHS1        	; Is it zero length?
0B0982 11 00 49 0B 1568**  			LD      DE,ACCS			; DE: Destination
0B0986 EB          1569**  			EX      DE,HL			; HL: Destination, DE: Address on stack
0B0987 ED B0       1570**  			LDIR	                    	; Copy to stack
0B0989 CD 00 16 0B 1571**  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0B098D DD E9       1572**  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B098F             1573**  ;
0B098F             1574**  ; POPS - RESTORE STRING FROM STACK.
0B098F             1575**  ;     Inputs: C = string length.
0B098F             1576**  ;    Outputs: String in string accumulator.
0B098F             1577**  ;             E = string length.
0B098F             1578**  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0B098F             1579**  ;
0B098F DD E1       1580**  POPS:			POP     IX              	; IX: Return address
0B0991 69          1581**  			LD	L,C			; Temporarily store string length in L
0B0992 01 00 00 00 1582**  			LD	BC,0
0B0996 4D          1583**  			LD	C,L			; BC: Number of bytes to copy
0B0997 21 00 00 00 1584**  			LD      HL,0			; HL: 0
0B099B 39          1585**  			ADD     HL,SP			; HL: Stack address
0B099C 11 00 49 0B 1586**  			LD      DE,ACCS			; DE: Destination
0B09A0 0C          1587**  			INC     C			; Quick check to see if this is a zero length string
0B09A1 0D          1588**  			DEC     C
0B09A2 28 02       1589**  			JR      Z,POPS1         	; Yes it is, so skip
0B09A4 ED B0       1590**  			LDIR                    	; No, so copy from the stack
0B09A6 F9          1591**  POPS1:			LD      SP,HL			; Shrink the stack
0B09A7 DD E9       1592**  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B09A9             1593**  ;
0B09A9 FD 7E 00    1594**  HEXDIG:			LD      A,(IY)
0B09AC FE 30       1595**  			CP      '0'
0B09AE D8          1596**  			RET     C
0B09AF FE 3A       1597**  			CP      '9'+1
0B09B1 3F          1598**  			CCF
0B09B2 D0          1599**  			RET     NC
0B09B3 FE 41       1600**  			CP      'A'
0B09B5 D8          1601**  			RET     C
0B09B6 D6 37       1602**  			SUB     'A'-10
0B09B8 FE 10       1603**  			CP      16
0B09BA 3F          1604**  			CCF
0B09BB C9          1605**  			RET
0B09BC             1606**  ;
0B09BC FD 7E 00    1607**  BINDIG:			LD	A,(IY)
0B09BF FE 30       1608**  			CP	'0'
0B09C1 D8          1609**  			RET	C
0B09C2 FE 32       1610**  			CP	'1'+1
0B09C4 3F          1611**  			CCF
0B09C5 C9          1612**  			RET
0B09C6             1613**  ;
0B09C6 FE 3E       1614**  RELOP?:			CP      '>'
0B09C8 D0          1615**  			RET     NC
0B09C9 FE 3D       1616**  			CP      '='
0B09CB D0          1617**  			RET     NC
0B09CC FE 3C       1618**  			CP      '<'
0B09CE C9          1619**  			RET
0B09CF             1620**  ;
0B09CF CD C6 02 0B 1621**  EXPRSC:			CALL    EXPRS
0B09D3 CD 21 0A 0B 1622**  COMMA:			CALL    NXT
0B09D7 FD 23       1623**  			INC     IY
0B09D9 FE 2C       1624**  			CP      ','
0B09DB C8          1625**  			RET     Z
0B09DC 3E 05       1626**  			LD      A,5
0B09DE 18 0B       1627**  			JR      ERROR1_EV          ;"Missing ,"
0B09E0             1628**  ;
0B09E0 CD 21 0A 0B 1629**  BRAKET:			CALL    NXT
0B09E4 FD 23       1630**  			INC     IY
0B09E6 FE 29       1631**  			CP      ')'
0B09E8 C8          1632**  			RET     Z
0B09E9 3E 1B       1633**  			LD      A,27
0B09EB C3 11 37 0B 1634**  ERROR1_EV:			JP      ERROR_           ;"Missing )"
0B09EF             1635**  ;
0B09EF FD 23       1636**  SAVE_EV:			INC     IY
0B09F1 08          1637**  SAVE1:			EX      AF,AF'
0B09F2 FA E7 02 0B 1638**  			JP      M,TYPE_EV_
0B09F6 08          1639**  			EX      AF,AF'
0B09F7 E3          1640**  			EX      (SP),HL
0B09F8 D9          1641**  			EXX
0B09F9 E5          1642**  			PUSH    HL
0B09FA D9          1643**  			EXX
0B09FB F5          1644**  			PUSH    AF
0B09FC C5          1645**  			PUSH    BC
0B09FD E9          1646**  			JP      (HL)
0B09FE             1647**  ;
0B09FE 08          1648**  DOIT:			EX      AF,AF'
0B09FF FA E7 02 0B 1649**  			JP      M,TYPE_EV_
0B0A03 D9          1650**  			EXX
0B0A04 C1          1651**  			POP     BC              ;RETURN ADDRESS
0B0A05 D9          1652**  			EXX
0B0A06 79          1653**  			LD      A,C
0B0A07 C1          1654**  			POP     BC
0B0A08 47          1655**  			LD      B,A
0B0A09 F1          1656**  			POP     AF              ;OPERATOR
0B0A0A D9          1657**  			EXX
0B0A0B EB          1658**  			EX      DE,HL
0B0A0C E1          1659**  			POP     HL
0B0A0D D9          1660**  			EXX
0B0A0E EB          1661**  			EX      DE,HL
0B0A0F E1          1662**  			POP     HL
0B0A10 D9          1663**  			EXX
0B0A11 C5          1664**  			PUSH    BC
0B0A12 D9          1665**  			EXX
0B0A13 E6 0F       1666**  			AND     0FH
0B0A15 CD 1B 20 0B 1667**  			CALL    FPP
0B0A19 38 D0       1668**  			JR      C,ERROR1_EV
0B0A1B AF          1669**  			XOR     A
0B0A1C 08          1670**  			EX      AF,AF'          ;TYPE
0B0A1D FD 7E 00    1671**  			LD      A,(IY)
0B0A20 C9          1672**  			RET
0B0A21             1673**  ;
0B0A21             1674**  ; Skip spaces
0B0A21             1675**  ; - IY: String pointer
0B0A21             1676**  ; Returns:
0B0A21             1677**  ;  - A: The non-space character found
0B0A21             1678**  ; - IY: Points to the character before that
0B0A21             1679**  ;
0B0A21 FD 7E 00    1680**  NXT:			LD      A,(IY)			; Fetch the character
0B0A24 FE 20       1681**  			CP      ' '			; If it is space, then return
0B0A26 C0          1682**  			RET     NZ
0B0A27 FD 23       1683**  			INC     IY			; Increment the pointer and
0B0A29 C3 21 0A 0B 1684**  			JP      NXT			; Loop
0B0A2D             1685**  ;
0B0A2D E5          1686**  DISPT2:			PUSH    HL
0B0A2E 21 66 01 0B 1687**  			LD      HL,SOPTBL
0B0A32 18 07       1688**  			JR      DISPT0
0B0A34             1689**  ;
0B0A34 E5          1690**  DISPAT:			PUSH    HL
0B0A35 D6 8D       1691**  			SUB     FUNTOK
0B0A37 21 BB 00 0B 1692**  			LD      HL,FUNTBL
0B0A3B C5          1693**  DISPT0:			PUSH    BC
0B0A3C             1694**  
0B0A3C 01 03 00 00 1695**  			LD	BC, 3
0B0A40 47          1696**  			LD	B, A
0B0A41 ED 4C       1697**  			MLT	BC
0B0A43 09          1698**  			ADD	HL, BC
0B0A44 ED 27       1699**  			LD	HL, (HL)
0B0A46             1700**  
0B0A46             1701**  ;			ADD     A,A
0B0A46             1702**  ;			LD      C,A
0B0A46             1703**  ;			LD      B,0
0B0A46             1704**  ;			ADD     HL,BC
0B0A46             1705**  ;			LD      A,(HL)
0B0A46             1706**  ;			INC     HL
0B0A46             1707**  ;			LD      H,(HL)
0B0A46             1708**  ;			LD      L,A
0B0A46             1709**  
0B0A46 C1          1710**  			POP     BC
0B0A47 E3          1711**  			EX      (SP),HL
0B0A48 C9          1712**  			RET                     ;OFF TO ROUTINE
0B0A49             1713**  
0B0A49             0006*       include "basic/exec.asm"
0B0A49             0001**  ;
0B0A49             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B0A49             0003**  ;		Statement Execution & Assembler Module - "EXEC"
0B0A49             0004**  ; Author:	(C) Copyright  R.T.Russell  1984
0B0A49             0005**  ; Modified By:	Dean Belfield
0B0A49             0006**  ; Created:	12/05/2023
0B0A49             0007**  ; Last Updated:	26/06/2023
0B0A49             0008**  ;
0B0A49             0009**  ; Modinfo:
0B0A49             0010**  ; 27/01/1984:	Version 2.1
0B0A49             0011**  ; 02/03/1987:	Version 3.0
0B0A49             0012**  ; 11/06/1987:	Version 3.1
0B0A49             0013**  ; 12/05/2023:	Modified by Dean Belfield
0B0A49             0014**  ; 07/06/2023:	Modified to run in ADL mode
0B0A49             0015**  ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
0B0A49             0016**  
0B0A49             0017**  			; .ASSUME	ADL = 1
0B0A49             0018**  
0B0A49             0019**  			; INCLUDE	"equs.inc"
0B0A49             0020**  
0B0A49             0021**  			; SEGMENT CODE
0B0A49             0022**  
0B0A49             0023**  			; XDEF	XEQ
0B0A49             0024**  			; XDEF	CHAIN0
0B0A49             0025**  			; XDEF	RUN
0B0A49             0026**  			; XDEF	SYNTAX
0B0A49             0027**  			; XDEF	ESCAPE
0B0A49             0028**  			; XDEF	FN_EX
0B0A49             0029**  			; XDEF	USR
0B0A49             0030**  			; XDEF	STORE5
0B0A49             0031**  			; XDEF	STORE4
0B0A49             0032**  			; XDEF	CHECK
0B0A49             0033**  			; XDEF	TERMQ
0B0A49             0034**  			; XDEF	FILL
0B0A49             0035**  			; XDEF	X4OR5
0B0A49             0036**  			; XDEF	MUL16
0B0A49             0037**  			; XDEF	CHANEL
0B0A49             0038**  			; XDEF	ASSEM
0B0A49             0039**  
0B0A49             0040**  			; XREF	AUTO
0B0A49             0041**  			; XREF	DELETE
0B0A49             0042**  			; XREF	LOAD
0B0A49             0043**  			; XREF	LIST_
0B0A49             0044**  			; XREF	NEW
0B0A49             0045**  			; XREF	OLD
0B0A49             0046**  			; XREF	RENUM
0B0A49             0047**  			; XREF	SAVE
0B0A49             0048**  			; XREF	SOUND
0B0A49             0049**  			; XREF	CLG
0B0A49             0050**  			; XREF	DRAW
0B0A49             0051**  			; XREF	ENVEL
0B0A49             0052**  			; XREF	GCOL
0B0A49             0053**  			; XREF	MODE
0B0A49             0054**  			; XREF	MOVE
0B0A49             0055**  			; XREF	PLOT
0B0A49             0056**  			; XREF	COLOUR
0B0A49             0057**  			; XREF	EXPRS
0B0A49             0058**  			; XREF	HIMEM
0B0A49             0059**  			; XREF	LOAD0
0B0A49             0060**  			; XREF	RANDOM
0B0A49             0061**  			; XREF	CLEAR
0B0A49             0062**  			; XREF	ERRTRP
0B0A49             0063**  			; XREF	PAGE_
0B0A49             0064**  			; XREF	DATAPTR
0B0A49             0065**  			; XREF	ERRLIN
0B0A49             0066**  			; XREF	TRAP
0B0A49             0067**  			; XREF	NXT
0B0A49             0068**  			; XREF	SETLIN
0B0A49             0069**  			; XREF	CLOOP
0B0A49             0070**  			; XREF	OSSHUT
0B0A49             0071**  			; XREF	WARM
0B0A49             0072**  			; XREF	TRACEN
0B0A49             0073**  			; XREF	OUTCHR
0B0A49             0074**  			; XREF	PBCDL
0B0A49             0075**  			; XREF	OSCLI
0B0A49             0076**  			; XREF	LISTON
0B0A49             0077**  			; XREF	GETVAR
0B0A49             0078**  			; XREF	PUTVAR
0B0A49             0079**  			; XREF	DATPTR
0B0A49             0080**  			; XREF	ERROR_
0B0A49             0081**  			; XREF	EXPR
0B0A49             0082**  			; XREF	CREATE
0B0A49             0083**  			; XREF	EXPRI
0B0A49             0084**  			; XREF	BRAKET
0B0A49             0085**  			; XREF	FREE
0B0A49             0086**  			; XREF	OSBPUT
0B0A49             0087**  			; XREF	COUNT
0B0A49             0088**  			; XREF	STR
0B0A49             0089**  			; XREF	HEXSTR
0B0A49             0090**  			; XREF	CRLF
0B0A49             0091**  			; XREF	ITEMI
0B0A49             0092**  			; XREF	FINDL
0B0A49             0093**  			; XREF	TEST
0B0A49             0094**  			; XREF	EXPRN
0B0A49             0095**  			; XREF	DLOAD5
0B0A49             0096**  			; XREF	DLOAD5_SPL
0B0A49             0097**  			; XREF	LOADN
0B0A49             0098**  			; XREF	FPP
0B0A49             0099**  			; XREF	SWAP
0B0A49             0100**  			; XREF	GETDEF
0B0A49             0101**  			; XREF	ZERO
0B0A49             0102**  			; XREF	OSBGET
0B0A49             0103**  			; XREF	BUFFER
0B0A49             0104**  			; XREF	CONS
0B0A49             0105**  			; XREF	VAL0
0B0A49             0106**  			; XREF	OSLINE
0B0A49             0107**  			; XREF	CLRSCN
0B0A49             0108**  			; XREF	TELL
0B0A49             0109**  			; XREF	SAYLN
0B0A49             0110**  			; XREF	REPORT
0B0A49             0111**  			; XREF	PUTPTR
0B0A49             0112**  			; XREF	PUTIME
0B0A49             0113**  			; XREF	PUTIMS
0B0A49             0114**  			; XREF	LOMEM
0B0A49             0115**  			; XREF	WIDTH
0B0A49             0116**  			; XREF	OSWRCH
0B0A49             0117**  			; XREF	COMMA
0B0A49             0118**  			; XREF	OSCALL
0B0A49             0119**  			; XREF	SFIX
0B0A49             0120**  			; XREF	LOAD4
0B0A49             0121**  			; XREF	PUSHS
0B0A49             0122**  			; XREF	POPS
0B0A49             0123**  			; XREF	LOADS
0B0A49             0124**  			; XREF	PUTCSR
0B0A49             0125**  			; XREF	OUT_
0B0A49             0126**  			; XREF	R0
0B0A49             0127**  ;
0B0A49             0128**  ; List of token values used in this module
0B0A49             0129**  ;
0B0A49             0130**  TAND:			EQU     80H
0B0A49             0131**  TOR:			EQU     84H
0B0A49             0132**  TERROR_EX:			EQU     85H
0B0A49             0133**  LINE_EX_:			EQU     86H
0B0A49             0134**  OFF_:			EQU     87H
0B0A49             0135**  STEP:			EQU     88H
0B0A49             0136**  SPC:			EQU     89H
0B0A49             0137**  TAB:			EQU     8AH
0B0A49             0138**  ELSE_EX_:			EQU     8BH
0B0A49             0139**  THEN_EX_:			EQU     8CH
0B0A49             0140**  LINO_EX:			EQU     8DH
0B0A49             0141**  TO_EX:			EQU     B8H
0B0A49             0142**  TCMD_EX:			EQU     C6H
0B0A49             0143**  TCALL:			EQU     D6H
0B0A49             0144**  DATA_EX_:			EQU     DCH
0B0A49             0145**  DEF_:			EQU     DDH
0B0A49             0146**  TGOSUB:			EQU     E4H
0B0A49             0147**  TGOTO:			EQU     E5H
0B0A49             0148**  TON:			EQU     EEH
0B0A49             0149**  TPROC:			EQU     F2H
0B0A49             0150**  TSTOP:			EQU     FAH
0B0A49             0151**  
0B0A49             0152**  ; The command table
0B0A49             0153**  ; Commands are tokens from C6H onwards; this lookup table is used to
0B0A49             0154**  ; run the corresponding function; Note that DATA and DEF both use the same
0B0A49             0155**  ; code as REM
0B0A49             0156**  ;
0B0A49 9A 36 0B    0157**  CMDTAB:			DW24  AUTO			; C6H
0B0A4C FD 34 0B    0158**  			DW24  DELETE			; C7H
0B0A4F DB 36 0B    0159**  			DW24  LOAD			; C8H
0B0A52 38 35 0B    0160**  			DW24  LIST_			; C9H
0B0A55 B8 36 0B    0161**  			DW24  NEW			; CAH
0B0A58 BE 36 0B    0162**  			DW24  OLD			; CBH
0B0A5B C7 35 0B    0163**  			DW24  RENUM			; CCH
0B0A5E EC 36 0B    0164**  			DW24  SAVE			; CDH
0B0A61 59 15 0B    0165**  			DW24  PUT			; CEH
0B0A64 79 13 0B    0166**  			DW24  PTR_EX			; CFH
0B0A67 93 13 0B    0167**  			DW24  PAGEV_EX			; D0H
0B0A6A A6 13 0B    0168**  			DW24  TIMEV_EX			; D1H
0B0A6D CF 13 0B    0169**  			DW24  LOMEMV_EX			; D2H
0B0A70 E8 13 0B    0170**  			DW24  HIMEMV_EX			; D3H
0B0A73 D7 45 0B    0171**  			DW24  SOUND			; D4H
0B0A76 73 14 0B    0172**  			DW24  BPUT			; D5H
0B0A79 8B 14 0B    0173**  			DW24  CALL_			; D6H
0B0A7C FD 0A 0B    0174**  			DW24  CHAIN			; D7H
0B0A7F 48 13 0B    0175**  			DW24  CLR			; D8H
0B0A82 67 14 0B    0176**  			DW24  CLOSE			; D9H
0B0A85 73 43 0B    0177**  			DW24  CLG			; DAH
0B0A88 1B 13 0B    0178**  			DW24  CLS			; DBH
0B0A8B DC 0B 0B    0179**  			DW24  REM_EX             		; DCH: DATA
0B0A8E DC 0B 0B    0180**  			DW24  REM_EX             		; DDH: DEF
0B0A91 A2 0C 0B    0181**  			DW24  DIM_EX			; DEH
0B0A94 9D 45 0B    0182**  			DW24  DRAW			; DFH
0B0A97 77 0B 0B    0183**  			DW24  END_			; E0H
0B0A9A 33 11 0B    0184**  			DW24  ENDPRO			; E1H
0B0A9D 68 43 0B    0185**  			DW24  ENVEL			; E2H
0B0AA0 48 0F 0B    0186**  			DW24  FOR_EX			; E3H
0B0AA3 F8 0E 0B    0187**  			DW24  GOSUB_EX			; E4H
0B0AA6 DC 0E 0B    0188**  			DW24  GOTO_EX			; E5H
0B0AA9 31 45 0B    0189**  			DW24  GCOL			; E6H
0B0AAC E7 12 0B    0190**  			DW24  IF_			; E7H
0B0AAF D5 11 0B    0191**  			DW24  INPUT			; E8H
0B0AB2 FD 0B 0B    0192**  			DW24  LET			; E9H
0B0AB5 D8 10 0B    0193**  			DW24  LOCAL_EX_			; EAH
0B0AB8 83 43 0B    0194**  			DW24  MODE			; EBH
0B0ABB 95 45 0B    0195**  			DW24  MOVE			; ECH
0B0ABE 96 0F 0B    0196**  			DW24  NEXT_EX			; EDH
0B0AC1 6F 0E 0B    0197**  			DW24  ON_EX_			; EEH
0B0AC4 41 14 0B    0198**  			DW24  VDU			; EFH
0B0AC7 63 45 0B    0199**  			DW24  PLOT			; F0H
0B0ACA 78 0D 0B    0200**  			DW24  PRINT_			; F1H
0B0ACD 35 10 0B    0201**  			DW24  PROC_EX			; F2H
0B0AD0 87 12 0B    0202**  			DW24  READ			; F3H
0B0AD3 DC 0B 0B    0203**  			DW24  REM_EX			; F4H
0B0AD6 18 0F 0B    0204**  			DW24  REPEAT_EX			; F5H
0B0AD9 40 13 0B    0205**  			DW24  REPOR			; F6H
0B0ADC 52 13 0B    0206**  			DW24  RESTOR_EX			; F7H
0B0ADF 06 0F 0B    0207**  			DW24  RETURN			; F8H
0B0AE2 F7 0A 0B    0208**  			DW24  RUN			; F9H
0B0AE5 28 13 0B    0209**  			DW24  STOP			; FAH
0B0AE8 7F 44 0B    0210**  			DW24  COLOUR			; FBH
0B0AEB 23 14 0B    0211**  			DW24  TRACE_EX			; FCH
0B0AEE 22 0F 0B    0212**  			DW24  UNTIL_EX			; FDH
0B0AF1 15 14 0B    0213**  			DW24  WIDTHV			; FEH
0B0AF4 C2 0B 0B    0214**  			DW24  CLI             		; FFH: OSCLI
0B0AF7             0215**  
0B0AF7             0216**  ; RUN
0B0AF7             0217**  ; RUN "filename"
0B0AF7             0218**  ;
0B0AF7 CD 2B 17 0B 0219**  RUN:			CALL    TERMQ			; Standalone RUN command?
0B0AFB 28 10       0220**  			JR      Z,RUN0			; Yes, so just RUN the code
0B0AFD             0221**  
0B0AFD             0222**  ; CHAIN "filename"
0B0AFD             0223**  ;
0B0AFD CD C6 02 0B 0224**  CHAIN:			CALL    EXPRS			; Get the filename
0B0B01 3E 0D       0225**  			LD      A,CR			; Terminate it with a CR
0B0B03 12          0226**  			LD      (DE),A
0B0B04 ED 7B 20 4C 0227**  CHAIN0:			LD      SP,(HIMEM)		; Reset SP
       0B          
0B0B09 CD D0 37 0B 0228**  			CALL    LOAD0			; And load the file in
0B0B0D             0229**  ;
0B0B0D ED 7B 20 4C 0230**  RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
       0B          
0B0B12 DD 21 38 4C 0231**  			LD      IX,RANDOM		; Pointer to the RANDOM sysvar
       0B          
0B0B17 ED 5F       0232**  @@:			LD      A, R			; Use the R register to seed the random number generator
0B0B19 28 FC       0233**  			JR      Z, @B			; Loop unti we get a non-zero value in A
0B0B1B 07          0234**  			RLCA				; Rotate it
0B0B1C 07          0235**  			RLCA
0B0B1D DD 77 03    0236**  			LD      (IX+3),A		; And store
0B0B20 9F          0237**  			SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
0B0B21 DD 77 04    0238**  			LD      (IX+4),A		; And store
0B0B24 CD 27 38 0B 0239**  			CALL    CLEAR
0B0B28 21 00 00 00 0240**  			LD      HL,0			; Clear the error trap sysvar
0B0B2C 22 2C 4C 0B 0241**  			LD      (ERRTRP),HL
0B0B30 2A 14 4C 0B 0242**  			LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
0B0B34 3E DC       0243**  			LD      A,DATA_EX_			; The DATA token value
0B0B36 CD FF 17 0B 0244**  			CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
0B0B3A 22 31 4C 0B 0245**  			LD      (DATPTR),HL     	; Set data pointer
0B0B3E FD 2A 14 4C 0246**  			LD      IY,(PAGE_)		; Load IY with the start of program memory
       0B          
0B0B43             0247**  ;
0B0B43 CD 8B 0B 0B 0248**  XEQ0:			CALL    NEWLIN
0B0B47 FD 22 35 4C 0249**  XEQ:			LD      (ERRLIN),IY     	; Error pointer
       0B          
0B0B4C CD 1E 3F 0B 0250**  			CALL    TRAP           		; Check keyboard
0B0B50 CD 21 0A 0B 0251**  XEQ1:			CALL    NXT
0B0B54 FD 23       0252**  			INC     IY
0B0B56 FE 3A       0253**  			CP      ':'             	; Seperator
0B0B58 28 F6       0254**  			JR      Z,XEQ1
0B0B5A FE 0D       0255**  			CP      CR
0B0B5C 28 E5       0256**  			JR      Z,XEQ0          	; New program line
0B0B5E D6 C6       0257**  			SUB     TCMD_EX
0B0B60 DA EB 0B 0B 0258**  			JP      C,LET0          	; Implied "LET"
0B0B64             0259**  
0B0B64 01 03 00 00 0260**  			LD	BC, 3
0B0B68 47          0261**  			LD	B, A
0B0B69 ED 4C       0262**  			MLT	BC
0B0B6B 21 49 0A 0B 0263**  			LD	HL,CMDTAB
0B0B6F 09          0264**  			ADD	HL, BC
0B0B70 ED 27       0265**  			LD	HL, (HL)		; Table entry
0B0B72             0266**  
0B0B72             0267**  ;			ADD     A,A
0B0B72             0268**  ;			LD      C,A
0B0B72             0269**  ;			LD      B,0
0B0B72             0270**  ;			LD      HL,CMDTAB
0B0B72             0271**  ;			ADD     HL,BC
0B0B72             0272**  ;			LD      A,(HL)          	; Table entry
0B0B72             0273**  ;			INC     HL
0B0B72             0274**  ;			LD      H,(HL)
0B0B72             0275**  ;			LD      L,A
0B0B72             0276**  
0B0B72 CD 21 0A 0B 0277**  			CALL    NXT
0B0B76 E9          0278**  			JP      (HL)            	; Execute the statement
0B0B77             0279**  
0B0B77             0280**  ;END
0B0B77             0281**  ;
0B0B77 CD 5F 39 0B 0282**  END_:			CALL    SETLIN          ;FIND CURRENT LINE
0B0B7B 7C          0283**  			LD      A,H
0B0B7C B5          0284**  			OR      L               ;DIRECT?
0B0B7D CA 31 30 0B 0285**  			JP      Z,CLOOP
0B0B81 1E 00       0286**  			LD      E,0
0B0B83 CD DC 42 0B 0287**  			CALL    OSSHUT          ;CLOSE ALL FILES
0B0B87 C3 30 30 0B 0288**  			JP      WARM            ;"Ready"
0B0B8B             0289**  ;
0B0B8B FD 7E 00    0290**  NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
0B0B8E 01 03 00 00 0291**  			LD      BC,3
0B0B92 FD 09       0292**  			ADD     IY,BC
0B0B94 B7          0293**  			OR      A
0B0B95 28 E0       0294**  			JR      Z,END_           ;LENGTH=0, EXIT
0B0B97 2A 26 4C 0B 0295**  			LD      HL,(TRACEN)
0B0B9B 7C          0296**  			LD      A,H
0B0B9C B5          0297**  			OR      L
0B0B9D C8          0298**  			RET     Z
0B0B9E 11 00 00 00 0299**  			LD	DE, 0		;Clear DE
0B0BA2 FD 56 FF    0300**  			LD      D,(IY-1)        ;DE = LINE NUMBER
0B0BA5 FD 5E FE    0301**  			LD      E,(IY-2)
0B0BA8 ED 52       0302**  			SBC     HL,DE
0B0BAA D8          0303**  			RET     C
0B0BAB EB          0304**  			EX      DE,HL
0B0BAC 3E 5B       0305**  			LD      A,'['           ;TRACE
0B0BAE CD 00 39 0B 0306**  			CALL    OUTCHR
0B0BB2 CD A8 39 0B 0307**  			CALL    PBCDL
0B0BB6 3E 5D       0308**  			LD      A,']'
0B0BB8 CD 00 39 0B 0309**  			CALL    OUTCHR
0B0BBC 3E 20       0310**  			LD      A,' '
0B0BBE C3 00 39 0B 0311**  			JP      OUTCHR
0B0BC2             0312**  
0B0BC2             0313**  ; Routines for each statement -------------------------------------------------
0B0BC2             0314**  
0B0BC2             0315**  ; OSCLI
0B0BC2             0316**  ;
0B0BC2 CD C6 02 0B 0317**  CLI:			CALL    EXPRS
0B0BC6 3E 0D       0318**  			LD      A,CR
0B0BC8 12          0319**  			LD      (DE),A
0B0BC9 21 00 49 0B 0320**  			LD      HL,ACCS
0B0BCD CD 41 3F 0B 0321**  			CALL    OSCLI
0B0BD1 C3 47 0B 0B 0322**  			JP      XEQ
0B0BD5             0323**  
0B0BD5             0324**  ; REM, *
0B0BD5             0325**  ;
0B0BD5 FD E5       0326**  EXT_EX:			PUSH    IY
0B0BD7 E1          0327**  			POP     HL
0B0BD8 CD 41 3F 0B 0328**  			CALL    OSCLI
0B0BDC FD E5       0329**  REM_EX:			PUSH    IY
0B0BDE E1          0330**  			POP     HL
0B0BDF 3E 0D       0331**  			LD      A,CR
0B0BE1 47          0332**  			LD      B,A
0B0BE2 ED B1       0333**  			CPIR                    ;FIND LINE END
0B0BE4 E5          0334**  			PUSH    HL
0B0BE5 FD E1       0335**  			POP     IY
0B0BE7 C3 43 0B 0B 0336**  			JP      XEQ0
0B0BEB             0337**  
0B0BEB             0338**  ; [LET] var = expr
0B0BEB             0339**  ;
0B0BEB FE C5       0340**  LET0:			CP      ELSE_EX_-TCMD_EX
0B0BED 28 ED       0341**  			JR      Z,REM_EX
0B0BEF             0342**  			; CP      ('*'-TCMD) & 0FFH
0B0BEF             0343**  			; JR      Z,EXT_EX
0B0BEF             0344**  			; CP      ('='-TCMD) & 0FFH
0B0BEF             0345**  			; JR      Z,FNEND
0B0BEF             0346**  			; CP      ('['-TCMD) & 0FFH
0B0BEF             0347**  			; ez80asm doesn't like () in expressions
0B0BEF FE 64       0348**  			CP      '*'-TCMD_EX & 0FFH
0B0BF1 28 E2       0349**  			JR      Z,EXT_EX
0B0BF3 FE 77       0350**  			CP      '='-TCMD_EX & 0FFH
0B0BF5 28 5B       0351**  			JR      Z,FNEND
0B0BF7 FE 95       0352**  			CP      '['-TCMD_EX & 0FFH
0B0BF9 28 25       0353**  			JR      Z,ASM
0B0BFB FD 2B       0354**  			DEC     IY
0B0BFD CD 6F 15 0B 0355**  LET:			CALL    ASSIGN			; Assign the variable
0B0C01 CA 47 0B 0B 0356**  			JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
0B0C05 38 41       0357**  			JR      C,SYNTAX        	; Return if C as it is an illegal variable
0B0C07             0358**  ;
0B0C07 F5          0359**  			PUSH    AF              	; At this point we're dealing with a string type (A=81h)
0B0C08 CD 41 17 0B 0360**  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B0C0C E5          0361**  			PUSH    HL			; HL: Address of the variable
0B0C0D CD C6 02 0B 0362**  			CALL    EXPRS
0B0C11 DD E1       0363**  			POP     IX			; IX: Address of the variable
0B0C13 F1          0364**  			POP     AF			; AF: The variable type
0B0C14 CD B1 15 0B 0365**  			CALL    STACCS			; Copy the string from ACCS to the variable area
0B0C18 C3 47 0B 0B 0366**  XEQR:			JP      XEQ
0B0C1C             0367**  ;
0B0C1C CD 8B 0B 0B 0368**  ASM0:			CALL    NEWLIN
0B0C20 FD 22 35 4C 0369**  ASM:			LD      (ERRLIN),IY
       0B          
0B0C25 CD 1E 3F 0B 0370**  			CALL    TRAP
0B0C29 CD 4C 18 0B 0371**  			CALL    ASSEM
0B0C2D 38 19       0372**  			JR      C,SYNTAX
0B0C2F FE 0D       0373**  			CP      CR
0B0C31 28 E9       0374**  			JR      Z,ASM0
0B0C33 21 40 4C 0B 0375**  			LD      HL,LISTON
0B0C37 7E          0376**  			LD      A,(HL)
0B0C38 E6 0F       0377**  			AND     0FH
0B0C3A F6 B0       0378**  			OR      B0H
0B0C3C 77          0379**  			LD      (HL),A
0B0C3D 18 D9       0380**  			JR      XEQR
0B0C3F             0381**  ;
0B0C3F CD EB 39 0B 0382**  VAR_:			CALL    GETVAR
0B0C43 C8          0383**  			RET     Z
0B0C44 D2 DA 39 0B 0384**  			JP      NC,PUTVAR
0B0C48 3E 10       0385**  SYNTAX:			LD      A,16            ;"Syntax error"
0B0C4A 18 02       0386**  			JR	ERROR0_EX
0B0C4C 3E 11       0387**  ESCAPE:			LD      A,17            ;"Escape"
0B0C4E C3 11 37 0B 0388**  ERROR0_EX:			JP      ERROR_
0B0C52             0389**  
0B0C52             0390**  ; =
0B0C52             0391**  ;
0B0C52 CD 78 01 0B 0392**  FNEND:			CALL    EXPR            ;FUNCTION RESULT
0B0C56 43          0393**  			LD      B,E
0B0C57 EB          0394**  			EX      DE,HL
0B0C58 D9          0395**  			EXX                     ;SAVE RESULT
0B0C59 EB          0396**  			EX      DE,HL           ; IN DEB'C'D'E'
0B0C5A C1          0397**  FNEND5:			POP     BC
0B0C5B 21 09 17 0B 0398**  			LD      HL,LOCCHK
0B0C5F B7          0399**  			OR      A
0B0C60 ED 42       0400**  			SBC     HL,BC
0B0C62 28 1C       0401**  			JR      Z,FNEND0        ;LOCAL VARIABLE
0B0C64 21 35 10 0B 0402**  			LD      HL,FNCHK
0B0C68 B7          0403**  			OR      A
0B0C69 ED 42       0404**  			SBC     HL,BC
0B0C6B 3E 07       0405**  			LD      A,7
0B0C6D 20 DF       0406**  			JR      NZ,ERROR0_EX       ;"No FN"
0B0C6F FD E1       0407**  			POP     IY
0B0C71 FD 22 35 4C 0408**  			LD      (ERRLIN),IY     ;IN CASE OF ERROR
       0B          
0B0C76 EB          0409**  			EX      DE,HL
0B0C77 D9          0410**  			EXX
0B0C78 EB          0411**  			EX      DE,HL
0B0C79 11 00 49 0B 0412**  			LD      DE,ACCS
0B0C7D 58          0413**  			LD      E,B
0B0C7E 08          0414**  			EX      AF,AF'
0B0C7F C9          0415**  			RET
0B0C80             0416**  ;
0B0C80 DD E1       0417**  FNEND0:			POP     IX
0B0C82 C1          0418**  			POP     BC
0B0C83 78          0419**  			LD      A,B
0B0C84 B7          0420**  			OR      A
0B0C85 FA 93 0C 0B 0421**  			JP      M,FNEND1        ;STRING
0B0C89 E1          0422**  			POP     HL
0B0C8A D9          0423**  			EXX
0B0C8B E1          0424**  			POP     HL
0B0C8C D9          0425**  			EXX
0B0C8D CD 87 15 0B 0426**  			CALL    STORE
0B0C91 18 C7       0427**  			JR      FNEND5
0B0C93 21 00 00 00 0428**  FNEND1:			LD      HL,0
0B0C97 39          0429**  			ADD     HL,SP
0B0C98 D5          0430**  			PUSH    DE
0B0C99 59          0431**  			LD      E,C
0B0C9A CD B5 15 0B 0432**  			CALL    STORES
0B0C9E D1          0433**  			POP     DE
0B0C9F F9          0434**  			LD      SP,HL
0B0CA0 18 B8       0435**  			JR      FNEND5
0B0CA2             0436**  
0B0CA2             0437**  ; DIM var(dim1[,dim2[,...]])[,var(...]
0B0CA2             0438**  ; DIM var expr[,var expr...]
0B0CA2             0439**  ;
0B0CA2 CD EB 39 0B 0440**  DIM_EX:			CALL    GETVAR          	; Get the variable
0B0CA6 DA 32 0D 0B 0441**  			JP      C,BADDIM		; Throw a "Bad Dim" error
0B0CAA CA 3C 0D 0B 0442**  			JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
0B0CAE CD 5F 3B 0B 0443**  			CALL    CREATE			; Create a new entity
0B0CB2 E5          0444**  			PUSH    HL			; HL: Address of the entity
0B0CB3 DD E1       0445**  			POP     IX			; IX: Address of the entity
0B0CB5 FD 7E 00    0446**  			LD      A,(IY)			; Fetch the next character from the tokenised string
0B0CB8 FE 28       0447**  			CP      '('			; Check for opening brackets
0B0CBA 7A          0448**  			LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
0B0CBB 20 7F       0449**  			JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
0B0CBD             0450**  ;
0B0CBD             0451**  ; At this point we're reserving a variable array
0B0CBD             0452**  ;
0B0CBD E5          0453**  			PUSH    HL			; HL: Address of the entity
0B0CBE F5          0454**  			PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
0B0CBF 11 01 00 00 0455**  			LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
0B0CC3 42          0456**  			LD      B,D			;  B: The number of dimensions in the array
0B0CC4             0457**  ;
0B0CC4 FD 23       0458**  DIM1:			INC     IY			; Skip to the next token
0B0CC6 C5          0459**  			PUSH    BC			; Stack the dimension counter
0B0CC7 D5          0460**  			PUSH    DE			; Stack the total size of array accumulator
0B0CC8 DD E5       0461**  			PUSH    IX			; Stack the entity address
0B0CCA CD BB 02 0B 0462**  			CALL    EXPRI           	; Fetch the size of this dimension
0B0CCE CB 7C       0463**  			BIT     7,H			; If it is negative then
0B0CD0 20 60       0464**  			JR      NZ,BADDIM		; Throw a "Bad Dim" error
0B0CD2 D9          0465**  			EXX
0B0CD3 23          0466**  			INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
0B0CD4 DD E1       0467**  			POP     IX			; IX: The entity address
0B0CD6 DD 23       0468**  			INC     IX
0B0CD8 DD 75 00    0469**  			LD      (IX),L          	; Save the size of this dimension in the entity
0B0CDB DD 23       0470**  			INC     IX
0B0CDD DD 74 00    0471**  			LD      (IX),H
0B0CE0 C1          0472**  			POP     BC
0B0CE1 CD 23 18 0B 0473**  			CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
0B0CE5 38 4F       0474**  			JR      C,NOROOM        	; Throw a "No Room" error if overflow
0B0CE7 EB          0475**  			EX      DE,HL           	; DE: The new total size of array accumulator
0B0CE8 C1          0476**  			POP     BC
0B0CE9 04          0477**  			INC     B               	;  B: The dimension counter; increment
0B0CEA FD 7E 00    0478**  			LD      A,(IY)			; Fetch the nex token
0B0CED FE 2C       0479**  			CP      ','             	; Check for another dimension in the array
0B0CEF 28 D3       0480**  			JR      Z,DIM1			; And loop
0B0CF1             0481**  ;
0B0CF1 CD E0 09 0B 0482**  			CALL    BRAKET          	; Check for closing bracket
0B0CF5 F1          0483**  			POP     AF              	; Restore the type
0B0CF6 DD 23       0484**  			INC     IX
0B0CF8 DD E3       0485**  			EX      (SP),IX
0B0CFA DD 70 00    0486**  			LD      (IX),B          	; Number of dimensions
0B0CFD CD 16 18 0B 0487**  			CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
0B0D01 E1          0488**  			POP     HL			; Restore the entity address
0B0D02 38 32       0489**  			JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
0B0D04             0490**  ;
0B0D04             0491**  ; We now allocate the memory for the array
0B0D04             0492**  ;
0B0D04 19          0493**  DIM3:			ADD     HL,DE
0B0D05 38 2F       0494**  			JR      C,NOROOM
0B0D07 E5          0495**  			PUSH    HL
0B0D08 24          0496**  			INC     H
0B0D09 28 2B       0497**  			JR      Z,NOROOM
0B0D0B ED 72       0498**  			SBC     HL,SP
0B0D0D 30 27       0499**  			JR      NC,NOROOM       	; Throw an "Out of Space" error
0B0D0F E1          0500**  			POP     HL
0B0D10 22 1D 4C 0B 0501**  			LD      (FREE),HL
0B0D14 7A          0502**  DIM2:			LD      A,D
0B0D15 B3          0503**  			OR      E
0B0D16 28 06       0504**  			JR      Z,DIM5
0B0D18 2B          0505**  			DEC     HL
0B0D19 36 00       0506**  			LD      (HL),0         		; Initialise the array
0B0D1B 1B          0507**  			DEC     DE
0B0D1C 18 F6       0508**  			JR      DIM2
0B0D1E CD 21 0A 0B 0509**  DIM5:			CALL    NXT
0B0D22 FE 2C       0510**  			CP      ','            		; Another variable?
0B0D24 C2 47 0B 0B 0511**  			JP      NZ,XEQ
0B0D28 FD 23       0512**  			INC     IY
0B0D2A CD 21 0A 0B 0513**  			CALL    NXT
0B0D2E C3 A2 0C 0B 0514**  			JP      DIM_EX
0B0D32             0515**  ;
0B0D32             0516**  ; DIM errors
0B0D32             0517**  ;
0B0D32 3E 0A       0518**  BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
0B0D34 18 02       0519**  			JR	ERROR1_EX
0B0D36 3E 0B       0520**  NOROOM:			LD      A,11            	; Throw a "DIM space" error
0B0D38 C3 11 37 0B 0521**  ERROR1_EX:			JP      ERROR_
0B0D3C             0522**  ;
0B0D3C             0523**  ; At this point we're reserving a block of memory, i.e.
0B0D3C             0524**  ; DIM var expr[,var expr...]
0B0D3C             0525**  ;
0B0D3C B7          0526**  DIM4:			OR      A			;  A: The dimension variable type
0B0D3D 28 F3       0527**  			JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
0B0D3F FA 32 0D 0B 0528**  			JP      M,BADDIM        	; or a string
0B0D43 47          0529**  			LD      B,A			; Temporarily store the dimension variable type in B
0B0D44 FD 7E FF    0530**  			LD      A,(IY-1)		; Get the last character but one
0B0D47 FE 29       0531**  			CP      ')'			; Check if it is a trailing bracket
0B0D49 28 E7       0532**  			JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
0B0D4B             0533**  ;
0B0D4B 21 00 00 00 0534**  			LD	HL,0			; Clear HL
0B0D4F 3A 1D 4C 0B 0535**  			LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
0B0D53 6F          0536**  			LD	L,A
0B0D54 3A 1E 4C 0B 0537**  			LD	A,(FREE+1)
0B0D58 67          0538**  			LD	H,A
0B0D59 78          0539**  			LD	A,B			; Restore the dimension variable type
0B0D5A D9          0540**  			EXX
0B0D5B 21 00 00 00 0541**  			LD	HL,0			; Clear HL
0B0D5F 47          0542**  			LD	B,A			; Temporarily store the dimension variable type in B
0B0D60 3A 1F 4C 0B 0543**  			LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
0B0D64 6F          0544**  			LD	L,A
0B0D65 78          0545**  			LD	A,B			; Restore the dimension variable type
0B0D66 4C          0546**  			LD	C,H
0B0D67 CD 87 15 0B 0547**  			CALL    STORE           	; Store the address
0B0D6B CD BB 02 0B 0548**  			CALL    EXPRI			; Get the number of bytes to store
0B0D6F D9          0549**  			EXX
0B0D70 23          0550**  			INC     HL			; Add one to it
0B0D71 EB          0551**  			EX      DE,HL
0B0D72 2A 1D 4C 0B 0552**  			LD      HL,(FREE)
0B0D76 18 8C       0553**  			JR      DIM3			; Continue with the DIM
0B0D78             0554**  
0B0D78             0555**  ; PRINT list...
0B0D78             0556**  ; PRINT #channel,list...
0B0D78             0557**  ;
0B0D78 FE 23       0558**  PRINT_:			CP      '#'
0B0D7A 20 7C       0559**  			JR      NZ,PRINT0
0B0D7C CD 43 18 0B 0560**  			CALL    CHNL            ;CHANNEL NO. = E
0B0D80 CD 21 0A 0B 0561**  PRNTN1:			CALL    NXT
0B0D84 FE 2C       0562**  			CP      ','
0B0D86 C2 47 0B 0B 0563**  			JP      NZ,XEQ
0B0D8A FD 23       0564**  			INC     IY
0B0D8C D5          0565**  			PUSH    DE
0B0D8D CD 78 01 0B 0566**  			CALL    EXPR            ;ITEM TO PRINT
0B0D91 08          0567**  			EX      AF,AF'
0B0D92 FA B8 0D 0B 0568**  			JP      M,PRNTN2        ;STRING
0B0D96 D1          0569**  			POP     DE
0B0D97 C5          0570**  			PUSH    BC
0B0D98 D9          0571**  			EXX
0B0D99 7D          0572**  			LD      A,L
0B0D9A D9          0573**  			EXX
0B0D9B CD EC 42 0B 0574**  			CALL    OSBPUT
0B0D9F D9          0575**  			EXX
0B0DA0 7C          0576**  			LD      A,H
0B0DA1 D9          0577**  			EXX
0B0DA2 CD EC 42 0B 0578**  			CALL    OSBPUT
0B0DA6 7D          0579**  			LD      A,L
0B0DA7 CD EC 42 0B 0580**  			CALL    OSBPUT
0B0DAB 7C          0581**  			LD      A,H
0B0DAC CD EC 42 0B 0582**  			CALL    OSBPUT
0B0DB0 C1          0583**  			POP     BC
0B0DB1 79          0584**  			LD      A,C
0B0DB2 CD EC 42 0B 0585**  			CALL    OSBPUT
0B0DB6 18 C8       0586**  			JR      PRNTN1
0B0DB8 4B          0587**  PRNTN2:			LD      C,E
0B0DB9 D1          0588**  			POP     DE
0B0DBA 21 00 49 0B 0589**  			LD      HL,ACCS
0B0DBE 0C          0590**  			INC     C
0B0DBF 0D          0591**  PRNTN3:			DEC     C
0B0DC0 28 0A       0592**  			JR      Z,PRNTN4
0B0DC2 7E          0593**  			LD      A,(HL)
0B0DC3 23          0594**  			INC     HL
0B0DC4 C5          0595**  			PUSH    BC
0B0DC5 CD EC 42 0B 0596**  			CALL    OSBPUT
0B0DC9 C1          0597**  			POP     BC
0B0DCA 18 F3       0598**  			JR      PRNTN3
0B0DCC 3E 0D       0599**  PRNTN4:			LD      A,CR
0B0DCE CD EC 42 0B 0600**  			CALL    OSBPUT
0B0DD2 18 AC       0601**  			JR      PRNTN1
0B0DD4             0602**  ;
0B0DD4 06 02       0603**  PRINT6:			LD      B,2
0B0DD6 18 27       0604**  			JR      PRINTC
0B0DD8 01 00 01 00 0605**  PRINT8:			LD      BC,100H
0B0DDC 18 21       0606**  			JR      PRINTC
0B0DDE 21 00 4B 0B 0607**  PRINT9:			LD      HL,STAVAR
0B0DE2 AF          0608**  			XOR     A
0B0DE3 BE          0609**  			CP      (HL)
0B0DE4 28 12       0610**  			JR      Z,PRINT0
0B0DE6 3A 3D 4C 0B 0611**  			LD      A,(COUNT)
0B0DEA B7          0612**  			OR      A
0B0DEB 28 0B       0613**  			JR      Z,PRINT0
0B0DED 96          0614**  PRINTA:			SUB     (HL)
0B0DEE 28 08       0615**  			JR      Z,PRINT0
0B0DF0 30 FB       0616**  			JR      NC,PRINTA
0B0DF2 ED 44       0617**  			NEG
0B0DF4 CD A0 17 0B 0618**  			CALL    FILL
0B0DF8 3A 00 4B 0B 0619**  PRINT0:			LD      A,(STAVAR)
0B0DFC 4F          0620**  			LD      C,A             ;PRINTS
0B0DFD 06 00       0621**  			LD      B,0             ;PRINTF
0B0DFF CD 2B 17 0B 0622**  PRINTC:			CALL    TERMQ
0B0E03 28 3F       0623**  			JR      Z,PRINT4
0B0E05 CB 80       0624**  			RES     0,B
0B0E07 FD 23       0625**  			INC     IY
0B0E09 FE 7E       0626**  			CP      '~'
0B0E0B 28 C7       0627**  			JR      Z,PRINT6
0B0E0D FE 3B       0628**  			CP      ';'
0B0E0F 28 C7       0629**  			JR      Z,PRINT8
0B0E11 FE 2C       0630**  			CP      ','
0B0E13 28 C9       0631**  			JR      Z,PRINT9
0B0E15 CD 50 17 0B 0632**  			CALL    FORMAT          ;SPC, TAB, '
0B0E19 28 E4       0633**  			JR      Z,PRINTC
0B0E1B FD 2B       0634**  			DEC     IY
0B0E1D C5          0635**  			PUSH    BC
0B0E1E CD 78 01 0B 0636**  			CALL    EXPR            ;VARIABLE TYPE
0B0E22 08          0637**  			EX      AF,AF'
0B0E23 FA 3D 0E 0B 0638**  			JP      M,PRINT3        ;STRING
0B0E27 D1          0639**  			POP     DE
0B0E28 D5          0640**  			PUSH    DE
0B0E29 CB 4A       0641**  			BIT     1,D
0B0E2B F5          0642**  			PUSH    AF
0B0E2C CC 17 09 0B 0643**  			CALL    Z,STR           ;DECIMAL
0B0E30 F1          0644**  			POP     AF
0B0E31 C4 CB 08 0B 0645**  			CALL    NZ,HEXSTR       ;HEX
0B0E35 C1          0646**  			POP     BC
0B0E36 C5          0647**  			PUSH    BC
0B0E37 79          0648**  			LD      A,C
0B0E38 93          0649**  			SUB     E
0B0E39 D4 A0 17 0B 0650**  			CALL    NC,FILL         ;RIGHT JUSTIFY
0B0E3D C1          0651**  PRINT3:			POP     BC
0B0E3E CD AF 17 0B 0652**  			CALL    PTEXT           ;PRINT
0B0E42 18 BB       0653**  			JR      PRINTC
0B0E44 CB 40       0654**  PRINT4:			BIT     0,B
0B0E46 CC F8 38 0B 0655**  			CALL    Z,CRLF
0B0E4A C3 47 0B 0B 0656**  			JP      XEQ
0B0E4E             0657**  
0B0E4E             0658**  ; ON ERROR statement [:statement...]
0B0E4E             0659**  ; ON ERROR OFF
0B0E4E             0660**  ;
0B0E4E FD 23       0661**  ONERR:			INC     IY              ;SKIP "ERROR"
0B0E50 21 00 00 00 0662**  			LD      HL,0
0B0E54 22 2C 4C 0B 0663**  			LD      (ERRTRP),HL
0B0E58 CD 21 0A 0B 0664**  			CALL    NXT
0B0E5C FE 87       0665**  			CP      OFF_
0B0E5E FD 23       0666**  			INC     IY
0B0E60 CA 47 0B 0B 0667**  			JP      Z,XEQ
0B0E64 FD 2B       0668**  			DEC     IY
0B0E66 FD 22 2C 4C 0669**  			LD      (ERRTRP),IY
       0B          
0B0E6B C3 DC 0B 0B 0670**  			JP      REM_EX
0B0E6F             0671**  
0B0E6F             0672**  ; ON expr GOTO line[,line...] [ELSE statement]
0B0E6F             0673**  ; ON expr GOTO line[,line...] [ELSE line]
0B0E6F             0674**  ; ON expr GOSUB line[,line...] [ELSE statement]
0B0E6F             0675**  ; ON expr GOSUB line[,line...] [ELSE line]
0B0E6F             0676**  ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
0B0E6F             0677**  ;
0B0E6F FE 85       0678**  ON_EX_:			CP      TERROR_EX
0B0E71 28 DB       0679**  			JR      Z,ONERR         ;"ON ERROR"
0B0E73 CD BB 02 0B 0680**  			CALL    EXPRI
0B0E77 FD 7E 00    0681**  			LD      A,(IY)
0B0E7A FD 23       0682**  			INC     IY
0B0E7C 1E 2C       0683**  			LD      E,','           ;SEPARATOR
0B0E7E FE E5       0684**  			CP      TGOTO
0B0E80 28 0B       0685**  			JR      Z,ON1
0B0E82 FE E4       0686**  			CP      TGOSUB
0B0E84 28 07       0687**  			JR      Z,ON1
0B0E86 1E F2       0688**  			LD      E,TPROC
0B0E88 BB          0689**  			CP      E
0B0E89 3E 27       0690**  			LD      A,39
0B0E8B 20 45       0691**  			JR      NZ,ERROR2_EX       ;"ON syntax"
0B0E8D 57          0692**  ON1:			LD      D,A
0B0E8E D9          0693**  			EXX
0B0E8F E5          0694**  			PUSH    HL
0B0E90 D9          0695**  			EXX
0B0E91 C1          0696**  			POP     BC              ;ON INDEX
0B0E92 78          0697**  			LD      A,B
0B0E93 B4          0698**  			OR      H
0B0E94 B5          0699**  			OR      L
0B0E95 20 2A       0700**  			JR      NZ,ON4          ;OUT OF RANGE
0B0E97 B1          0701**  			OR      C
0B0E98 28 27       0702**  			JR      Z,ON4
0B0E9A 0D          0703**  			DEC     C
0B0E9B 28 0E       0704**  			JR      Z,ON3           ;INDEX=1
0B0E9D CD 2B 17 0B 0705**  ON2:			CALL    TERMQ
0B0EA1 28 1E       0706**  			JR      Z,ON4           ;OUT OF RANGE
0B0EA3 FD 23       0707**  			INC     IY              ;SKIP DELIMITER
0B0EA5 BB          0708**  			CP      E
0B0EA6 20 F5       0709**  			JR      NZ,ON2
0B0EA8 0D          0710**  			DEC     C
0B0EA9 20 F2       0711**  			JR      NZ,ON2
0B0EAB 7B          0712**  ON3:			LD      A,E
0B0EAC FE F2       0713**  			CP      TPROC
0B0EAE 28 26       0714**  			JR      Z,ONPROC
0B0EB0 D5          0715**  			PUSH    DE
0B0EB1 CD D6 02 0B 0716**  			CALL    ITEMI           ;LINE NUMBER
0B0EB5 D1          0717**  			POP     DE
0B0EB6 7A          0718**  			LD      A,D
0B0EB7 FE E5       0719**  			CP      TGOTO
0B0EB9 28 2D       0720**  			JR      Z,GOTO2
0B0EBB CD 38 17 0B 0721**  			CALL    SPAN            ;SKIP REST OF LIST
0B0EBF 18 3B       0722**  			JR      GOSUB1
0B0EC1             0723**  ;
0B0EC1 FD 7E 00    0724**  ON4:			LD      A,(IY)
0B0EC4 FD 23       0725**  			INC     IY
0B0EC6 FE 8B       0726**  			CP      ELSE_EX_
0B0EC8 CA FC 12 0B 0727**  			JP      Z,IF1           ;ELSE CLAUSE
0B0ECC FE 0D       0728**  			CP      CR
0B0ECE 20 F1       0729**  			JR      NZ,ON4
0B0ED0 3E 28       0730**  			LD      A,40
0B0ED2 C3 11 37 0B 0731**  ERROR2_EX:			JP      ERROR_           ;"ON range"
0B0ED6             0732**  ;
0B0ED6 3E EE       0733**  ONPROC:			LD      A,TON
0B0ED8 C3 35 10 0B 0734**  			JP      PROC_EX
0B0EDC             0735**  
0B0EDC             0736**  ; GOTO line
0B0EDC             0737**  ;
0B0EDC CD D6 02 0B 0738**  GOTO_EX:			CALL    ITEMI           	; Fetch the line number
0B0EE0 CD 2B 17 0B 0739**  GOTO1:			CALL    TERMQ			; Check for terminator
0B0EE4 C2 48 0C 0B 0740**  			JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
0B0EE8 D9          0741**  GOTO2:			EXX
0B0EE9 CD 40 39 0B 0742**  			CALL    FINDL			; HL: Line number - Find the line
0B0EED E5          0743**  			PUSH    HL			; HL: Address of the line
0B0EEE FD E1       0744**  			POP     IY			; IY = HL
0B0EF0 CA 43 0B 0B 0745**  			JP      Z,XEQ0			; If the line is found, then continue execution at that point
0B0EF4 3E 29       0746**  			LD      A,41			; Otherwise throw a "No such line" error
0B0EF6 18 DA       0747**  			JR      ERROR2_EX
0B0EF8             0748**  
0B0EF8             0749**  ; GOSUB line
0B0EF8             0750**  ; This pushes the following data onto the execution stack
0B0EF8             0751**  ; - 3 bytes: Current execution address
0B0EF8             0752**  ; - 3 bytes: Marker (the address of label GOSCHK)
0B0EF8             0753**  ;
0B0EF8 CD D6 02 0B 0754**  GOSUB_EX:			CALL    ITEMI			; Fetch the line number
0B0EFC FD E5       0755**  GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
0B0EFE CD 00 16 0B 0756**  			CALL    CHECK           	; Check there is enough room
0B0F02 CD E0 0E 0B 0757**  			CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
0B0F06             0758**  GOSCHK:			EQU     $
0B0F06             0759**  
0B0F06             0760**  ; RETURN
0B0F06             0761**  ; This pops the following data off the execution stack as pushed by GOSUB
0B0F06             0762**  ; - 3 bytes: Marker (should be the address of label GOSCHK)
0B0F06             0763**  ; - 3 bytes: The return execution address
0B0F06             0764**  ;
0B0F06 D1          0765**  RETURN:			POP     DE			; Pop the marker off the execution stack
0B0F07 21 06 0F 0B 0766**  			LD      HL,GOSCHK		; Compare with GOSCHK
0B0F0B B7          0767**  			OR      A
0B0F0C ED 52       0768**  			SBC     HL,DE
0B0F0E FD E1       0769**  			POP     IY			; Pop the return address off the execution stack
0B0F10 CA 47 0B 0B 0770**  			JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
0B0F14 3E 26       0771**  			LD      A,38			; Otherwise throw a "No GOSUB" error
0B0F16 18 BA       0772**  			JR      ERROR2_EX
0B0F18             0773**  
0B0F18             0774**  ; REPEAT
0B0F18             0775**  ; This pushes the following data onto the execution stack
0B0F18             0776**  ; - 3 bytes: Current execution address
0B0F18             0777**  ; - 3 bytes: Marker (the address of label REPCHK)
0B0F18             0778**  ;
0B0F18 FD E5       0779**  REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
0B0F1A CD 00 16 0B 0780**  			CALL    CHECK			; Check if there is enough room
0B0F1E CD 47 0B 0B 0781**  			CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
0B0F22             0782**  REPCHK:			EQU     $
0B0F22             0783**  
0B0F22             0784**  ; UNTIL expr
0B0F22             0785**  ; This pops the following data off the execution stack
0B0F22             0786**  ; - 3 bytes: Marker (should be the address of label REPCHK)
0B0F22             0787**  ; - 3 bytes: The address of the REPEAT instruction
0B0F22             0788**  ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
0B0F22             0789**  ;
0B0F22 C1          0790**  UNTIL_EX:			POP     BC			; Fetch the marker
0B0F23 C5          0791**  			PUSH    BC			; And push it back onto the execution stack
0B0F24 21 22 0F 0B 0792**  			LD      HL,REPCHK		; Compare with REPCHK
0B0F28 B7          0793**  			OR      A
0B0F29 ED 42       0794**  			SBC     HL,BC
0B0F2B 3E 2B       0795**  			LD      A,43
0B0F2D 20 A3       0796**  			JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
0B0F2F CD BB 02 0B 0797**  			CALL    EXPRI			; Fetch the expression
0B0F33 CD 90 08 0B 0798**  			CALL    TEST			; Test if the expression evaluates to zero
0B0F37 C1          0799**  			POP     BC			; Pop the marker
0B0F38 D1          0800**  			POP     DE			; Pop the address of the REPEAT instruction
0B0F39 20 05       0801**  			JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
0B0F3B D5          0802**  			PUSH    DE			; Push the address of the REPEAT instruction back on the stack
0B0F3C C5          0803**  			PUSH    BC			; Push the marker back on the stack
0B0F3D D5          0804**  			PUSH    DE			; IY = DE
0B0F3E FD E1       0805**  			POP     IY			; This sets the execution address back to the REPEAT instruction
0B0F40 C3 47 0B 0B 0806**  XEQ2:			JP      XEQ			; Continue execution
0B0F44             0807**  
0B0F44             0808**  ; FOR var = expr TO expr [STEP expr]
0B0F44             0809**  ; This pushes the following data onto the execution stack
0B0F44             0810**  ; - 3 bytes: The limit value
0B0F44             0811**  ; - 3 bytes: The step value
0B0F44             0812**  ; - 3 bytes: The current execution address
0B0F44             0813**  ; - 3 bytes: The address of the loop variable
0B0F44             0814**  ; - 3 bytes: Marker (the address of FORCHK)
0B0F44             0815**  ;
0B0F44 3E 22       0816**  FORVAR:			LD      A,34
0B0F46 18 8A       0817**  			JR      ERROR2_EX          	; Throw "FOR variable" error
0B0F48             0818**  ;
0B0F48 CD 6F 15 0B 0819**  FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
0B0F4C 20 F6       0820**  			JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
0B0F4E F5          0821**  			PUSH    AF              	; Save the variable type
0B0F4F FD 7E 00    0822**  			LD      A,(IY)			; Check the next token
0B0F52 FE B8       0823**  			CP      TO_EX			; Compare with the token value for "TO"
0B0F54 3E 24       0824**  			LD      A,36			; Set the error code to 36 ("No TO")
0B0F56 C2 D2 0E 0B 0825**  			JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
0B0F5A FD 23       0826**  			INC     IY			; Skip to the next token
0B0F5C             0827**  ;
0B0F5C DD E5       0828**  			PUSH    IX
0B0F5E CD B3 02 0B 0829**  			CALL    EXPRN           	; Fetch the LIMIT expression value
0B0F62 DD E1       0830**  			POP     IX
0B0F64 F1          0831**  			POP     AF
0B0F65 47          0832**  			LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
0B0F66 C5          0833**  			PUSH    BC              	; Stack the LIMIT value
0B0F67 E5          0834**  			PUSH    HL
0B0F68 21 00 00 00 0835**  			LD      HL,0
0B0F6C 4C          0836**  			LD      C,H
0B0F6D D9          0837**  			EXX
0B0F6E E5          0838**  			PUSH    HL
0B0F6F             0839**  ;
0B0F6F 21 01 00 00 0840**  			LD      HL,1            	; The preset STEP value is 1
0B0F73 D9          0841**  			EXX
0B0F74 FD 7E 00    0842**  			LD      A,(IY)			; Fetch the next token
0B0F77 FE 88       0843**  			CP      STEP			; Compare with the token value for "STEP"
0B0F79 20 0A       0844**  			JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
0B0F7B             0845**  ;
0B0F7B FD 23       0846**  			INC     IY			; Skip past the STEP token
0B0F7D DD E5       0847**  			PUSH    IX
0B0F7F CD B3 02 0B 0848**  			CALL    EXPRN          		; Fetch the STEP expression value
0B0F83 DD E1       0849**  			POP     IX
0B0F85             0850**  ;
0B0F85 C5          0851**  FOR1:			PUSH    BC			; Stack the STEP value
0B0F86 E5          0852**  			PUSH    HL
0B0F87 D9          0853**  			EXX
0B0F88 E5          0854**  			PUSH    HL
0B0F89 D9          0855**  			EXX
0B0F8A             0856**  ;
0B0F8A FD E5       0857**  			PUSH    IY              	; Stack the current execution address
0B0F8C DD E5       0858**  			PUSH    IX              	; Stack the loop variable
0B0F8E CD 00 16 0B 0859**  			CALL    CHECK
0B0F92 CD 47 0B 0B 0860**  			CALL    XEQ
0B0F96             0861**  FORCHK:			EQU     $
0B0F96             0862**  
0B0F96             0863**  ; NEXT [var[,var...]]
0B0F96             0864**  ; This pops the following data off the execution stack
0B0F96             0865**  ; - 3 bytes: Marker (the address of FORCHK)
0B0F96             0866**  ; - 3 bytes: The address of the loop variable
0B0F96             0867**  ; - 3 bytes: The current execution address
0B0F96             0868**  ; - 3 bytes: The step value
0B0F96             0869**  ; - 3 bytes: The limit value
0B0F96             0870**  ; It also ensures that the data is pushed back on for subsequent NEXT instructions
0B0F96             0871**  ;
0B0F96 C1          0872**  NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
0B0F97 21 96 0F 0B 0873**  			LD      HL,FORCHK		; Compare with FORCHK
0B0F9B B7          0874**  			OR      A
0B0F9C ED 42       0875**  			SBC     HL,BC
0B0F9E 3E 20       0876**  			LD      A,32
0B0FA0 C2 2C 10 0B 0877**  			JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
0B0FA4 CD 2B 17 0B 0878**  			CALL    TERMQ			; Check for terminator (a NEXT without a variable)
0B0FA8 E1          0879**  			POP     HL			; Pop the address of the loop variable off the execution stack
0B0FA9 E5          0880**  			PUSH    HL			; Push it back onto the execution stack
0B0FAA C5          0881**  			PUSH    BC			; Push the marker back onto the execution stack
0B0FAB E5          0882**  			PUSH    HL			; HL: Address of the loop variable off the stack
0B0FAC C4 EB 39 0B 0883**  			CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
0B0FB0 D1          0884**  			POP     DE			; DE: Address of the loop variable off the stack
0B0FB1 EB          0885**  			EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
0B0FB2 B7          0886**  			OR      A
0B0FB3 ED 52       0887**  NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
0B0FB5 20 61       0888**  			JR      NZ,NEXT1		; They don't, so jump to NEXT1
0B0FB7 D5          0889**  			PUSH    DE
0B0FB8 DD 21 0C 00 0890**  			LD      IX,9+3			; IX: Address of the STEP value on the execution stack
       00          
0B0FBD DD 39       0891**  			ADD     IX,SP
0B0FBF CD 92 29 0B 0892**  			CALL    DLOAD5_SPL      	; Load the STEP value
0B0FC3 DD 7E 10    0893**  			LD      A,(IX+16)       	; Get the STEP type
0B0FC6 DD E1       0894**  			POP     IX
0B0FC8 CD C7 03 0B 0895**  			CALL    LOADN           	; Load the LOOP variable
0B0FCC CB 7A       0896**  			BIT     7,D             	; Check the sign
0B0FCE F5          0897**  			PUSH    AF
0B0FCF 3E 0B       0898**  			LD      A,'+' & 0FH
0B0FD1 CD 1B 20 0B 0899**  			CALL    FPP             	; Add the STEP
0B0FD5 38 55       0900**  			JR      C,ERROR3_EX
0B0FD7 F1          0901**  			POP     AF              	; Restore TYPE
0B0FD8 F5          0902**  			PUSH    AF
0B0FD9 CD 87 15 0B 0903**  			CALL    STORE           	; Update the variable
0B0FDD DD 21 15 00 0904**  			LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
       00          
0B0FE2 DD 39       0905**  			ADD     IX,SP
0B0FE4 CD 92 29 0B 0906**  			CALL    DLOAD5_SPL      	; Load the LIMIT value
0B0FE8 F1          0907**  			POP     AF
0B0FE9 CC 88 08 0B 0908**  			CALL    Z,SWAP			; Swap the arguments if the sign is ?
0B0FED             0909**  			; LD      A,0+('<'-4) & 0FH
0B0FED 3E 08       0910**  			LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
0B0FEF CD 1B 20 0B 0911**  			CALL    FPP             	; Test against the limit
0B0FF3 38 37       0912**  			JR      C,ERROR3_EX		; Throw an error if FPP returns bad
0B0FF5 24          0913**  			INC     H
0B0FF6 20 14       0914**  			JR      NZ,LOOP_        	; Keep looping
0B0FF8 21 1B 00 00 0915**  			LD      HL,27			; Adjust the stack
0B0FFC 39          0916**  			ADD     HL,SP
0B0FFD F9          0917**  			LD      SP,HL
0B0FFE CD 21 0A 0B 0918**  			CALL    NXT
0B1002 FE 2C       0919**  			CP      ','			; Check for multiple variables
0B1004 C2 47 0B 0B 0920**  			JP      NZ,XEQ			; No, so we are done at ths point
0B1008 FD 23       0921**  			INC     IY			; Increment to the next variable
0B100A 18 8A       0922**  			JR      NEXT_EX			; And continue
0B100C             0923**  ;
0B100C C1          0924**  LOOP_:			POP     BC
0B100D D1          0925**  			POP     DE
0B100E FD E1       0926**  			POP     IY
0B1010 FD E5       0927**  			PUSH    IY
0B1012 D5          0928**  			PUSH    DE
0B1013 C5          0929**  			PUSH    BC
0B1014 C3 47 0B 0B 0930**  			JP      XEQ
0B1018             0931**  ;
0B1018 21 1B 00 00 0932**  NEXT1:			LD      HL,27			; TODO: What does this do?
0B101C 39          0933**  			ADD     HL,SP
0B101D F9          0934**  			LD      SP,HL			; Adjust the stack
0B101E C1          0935**  			POP     BC
0B101F 21 96 0F 0B 0936**  			LD      HL,FORCHK
0B1023 ED 42       0937**  			SBC     HL,BC
0B1025 E1          0938**  			POP     HL              	; Variable pointer
0B1026 E5          0939**  			PUSH    HL
0B1027 C5          0940**  			PUSH    BC
0B1028 28 89       0941**  			JR      Z,NEXT0
0B102A             0942**  ;
0B102A 3E 21       0943**  			LD      A,33
0B102C C3 11 37 0B 0944**  ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
0B1030             0945**  
0B1030             0946**  ; FNname
0B1030             0947**  ; N.B. ENTERED WITH A <> TON
0B1030             0948**  ;
0B1030 F5          0949**  FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0B1031 CD 3A 10 0B 0950**  			CALL    PROC1
0B1035             0951**  FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0B1035             0952**  
0B1035             0953**  ; PROCname
0B1035             0954**  ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
0B1035             0955**  ; This pushes the following data onto the execution stack
0B1035             0956**  ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
0B1035             0957**  ; - 3 bytes: Marker (the address of PROCHK)
0B1035             0958**  ;
0B1035 F5          0959**  PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0B1036 CD 3A 10 0B 0960**  			CALL    PROC1			; and is also space reserved on the stack for the return address
0B103A             0961**  PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
0B103A             0962**  ;
0B103A CD 00 16 0B 0963**  PROC1:			CALL    CHECK			; Check there is space for this
0B103E FD 2B       0964**  			DEC     IY			; Decrement IY to the PROC token
0B1040 FD E5       0965**  			PUSH    IY			; Stack the pointer
0B1042 CD AC 3A 0B 0966**  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1046 C1          0967**  			POP     BC			; BC = IY
0B1047 28 41       0968**  			JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0B1049 3E 1E       0969**  			LD      A,30
0B104B 38 DF       0970**  			JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0B104D             0971**  ;
0B104D             0972**  ; At this point the PROC/FN has not yet been registered in the dynamic area
0B104D             0973**  ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
0B104D             0974**  ;
0B104D C5          0975**  			PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0B104E 2A 14 4C 0B 0976**  			LD      HL,(PAGE_)		; HL: Start of program memory
0B1052             0977**  ;
0B1052 3E DD       0978**  PROC2:			LD      A,DEF_			;  A: The token to search for
0B1054 CD FF 17 0B 0979**  			CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0B1058 38 26       0980**  			JR      C,PROC3			; Not found, so jump to PROC3
0B105A E5          0981**  			PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0B105B FD E1       0982**  			POP     IY			; IY = HL
0B105D FD 23       0983**  			INC     IY              	; Skip the DEF token
0B105F CD 21 0A 0B 0984**  			CALL    NXT			; And any whitespace
0B1063 CD AC 3A 0B 0985**  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1067 FD E5       0986**  			PUSH    IY
0B1069 D1          0987**  			POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0B106A 38 09       0988**  			JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0B106C C4 5F 3B 0B 0989**  			CALL    NZ,CREATE		; Create an entity in the dynamic area
0B1070 FD E5       0990**  			PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0B1072 D1          0991**  			POP     DE			; DE = IY
0B1073 ED 1F       0992**  			LD	(HL),DE			; Save address
0B1075             0993**  ;
0B1075 EB          0994**  PROC6:			EX      DE,HL			; HL: Address of the procedure
0B1076 3E 0D       0995**  			LD      A,CR			; The character to search for
0B1078 01 00 01 00 0996**  			LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0B107C ED B1       0997**  			CPIR                    	; Skip to next line
0B107E 18 D2       0998**  			JR      PROC2			; Rinse, lather and repeat
0B1080             0999**  ;
0B1080             1000**  ; At this point a DEF has not been found for the PROC/FN
0B1080             1001**  ;
0B1080 FD E1       1002**  PROC3:			POP     IY              	; Restore the execution address
0B1082 CD AC 3A 0B 1003**  			CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B1086 3E 1D       1004**  			LD      A,29
0B1088 20 A2       1005**  			JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0B108A             1006**  ;
0B108A             1007**  ; At this point we have a PROC/FN entry in the dynamic area
0B108A             1008**  ;
0B108A ED 17       1009**  PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0B108C 21 03 00 00 1010**  			LD	HL,3
0B1090 39          1011**  			ADD     HL,SP
0B1091 CD 21 0A 0B 1012**  			CALL    NXT             	; Allow space before "("
0B1095 D5          1013**  			PUSH    DE              	; Exchange DE and IY
0B1096 FD E3       1014**  			EX      (SP),IY
0B1098 FE 28       1015**  			CP      '('             	; Arguments?
0B109A D1          1016**  			POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0B109B 20 20       1017**  			JR      NZ,PROC5
0B109D CD 21 0A 0B 1018**  			CALL    NXT             	; Allow space before "("
0B10A1 FE 28       1019**  			CP      '('
0B10A3 C2 48 0C 0B 1020**  			JP      NZ,SYNTAX       	; Throw "Syntax error"
0B10A7 FD E5       1021**  			PUSH    IY
0B10A9 C1          1022**  			POP     BC              	; Save IY in BC
0B10AA D9          1023**  			EXX
0B10AB CD AB 16 0B 1024**  			CALL    SAVLOC          	; Save local parameters
0B10AF CD E0 09 0B 1025**  			CALL    BRAKET          	; Closing bracket
0B10B3 D9          1026**  			EXX
0B10B4 C5          1027**  			PUSH    BC
0B10B5 FD E1       1028**  			POP     IY              	; Restore IY
0B10B7 E5          1029**  			PUSH    HL
0B10B8 CD 27 16 0B 1030**  			CALL    ARGUE           	; Transfer arguments
0B10BC E1          1031**  			POP     HL
0B10BD             1032**  ;
0B10BD 23          1033**  PROC5:			INC	HL			; Increment to the ON PROC flag address
0B10BE 7E          1034**  			LD	A, (HL)			; And fetch the value
0B10BF 2B          1035**  			DEC 	HL
0B10C0 ED 1F       1036**  			LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
0B10C2 FE EE       1037**  			CP	TON			; Was it "ON PROC"?
0B10C4 C2 47 0B 0B 1038**  			JP	NZ, XEQ			; No, so back to XEQ
0B10C8 D5          1039**  			PUSH    DE			; Exchange DE and IY
0B10C9 FD E3       1040**  			EX      (SP),IY
0B10CB CD 38 17 0B 1041**  			CALL    SPAN            	; Skip rest of ON list
0B10CF FD E3       1042**  			EX      (SP),IY			; Exchange DE and IY
0B10D1 D1          1043**  			POP     DE
0B10D2 ED 1F       1044**  			LD	(HL), DE		; Save the return address
0B10D4 C3 47 0B 0B 1045**  			JP      XEQ
0B10D8             1046**  
0B10D8             1047**  ; LOCAL var[,var...]
0B10D8             1048**  ;
0B10D8 C1          1049**  LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
0B10D9 C5          1050**  			PUSH    BC
0B10DA 21 35 10 0B 1051**  			LD      HL,FNCHK		; Check if we are in a FN
0B10DE B7          1052**  			OR      A
0B10DF ED 42       1053**  			SBC     HL,BC
0B10E1 28 16       1054**  			JR      Z,LOCAL1		; Yes, so all good, we can use local
0B10E3 21 3A 10 0B 1055**  			LD      HL,PROCHK		; Now check if we are in a PROC
0B10E7 B7          1056**  			OR      A
0B10E8 ED 42       1057**  			SBC     HL,BC
0B10EA 28 0D       1058**  			JR      Z,LOCAL1		; Again, all good, we can use local
0B10EC 21 09 17 0B 1059**  			LD      HL,LOCCHK		; Finally check for the local parameters marker
0B10F0 B7          1060**  			OR      A
0B10F1 ED 42       1061**  			SBC     HL,BC			; If it is not present, then
0B10F3 3E 0C       1062**  			LD      A,12
0B10F5 C2 11 37 0B 1063**  			JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
0B10F9             1064**  ;
0B10F9             1065**  ; At this point we are adding a local variable into a PROC or FN
0B10F9             1066**  ;
0B10F9 FD E5       1067**  LOCAL1:			PUSH    IY			; IY: BASIC pointer
0B10FB C1          1068**  			POP     BC			; BC: Copy of the BASIC pointer
0B10FC D9          1069**  			EXX
0B10FD FD 2B       1070**  			DEC     IY
0B10FF CD AB 16 0B 1071**  			CALL    SAVLOC
0B1103 D9          1072**  			EXX
0B1104 C5          1073**  			PUSH    BC
0B1105 FD E1       1074**  			POP     IY
0B1107             1075**  ;
0B1107 CD EB 39 0B 1076**  LOCAL2:			CALL    GETVAR			; Get the variable location
0B110B C2 48 0C 0B 1077**  			JP      NZ,SYNTAX
0B110F B7          1078**  			OR      A               	; Check the variable type (80h = string)
0B1110 08          1079**  			EX      AF,AF'
0B1111 CD 44 09 0B 1080**  			CALL    ZERO			; Zero the variable anyway
0B1115 08          1081**  			EX      AF,AF'
0B1116 F5          1082**  			PUSH    AF
0B1117 F4 87 15 0B 1083**  			CALL    P,STORE         	; Call STORE if it is not a string
0B111B F1          1084**  			POP     AF
0B111C 59          1085**  			LD      E,C
0B111D FC B5 15 0B 1086**  			CALL    M,STORES		; Call STORES if it is a string
0B1121 CD 21 0A 0B 1087**  			CALL    NXT			; Skip to the next character in the expression
0B1125 FE 2C       1088**  			CP      ','			; Is it a comma?
0B1127 C2 47 0B 0B 1089**  			JP      NZ,XEQ			; No, so we're done, carry on executing
0B112B FD 23       1090**  			INC     IY			; Yes, so skip the comma
0B112D CD 21 0A 0B 1091**  			CALL    NXT			; And any whitespace
0B1131 18 D4       1092**  			JR      LOCAL2			; Then loop back and handle any further local variables
0B1133             1093**  
0B1133             1094**  ; ENDPROC
0B1133             1095**  ;
0B1133 C1          1096**  ENDPRO:			POP     BC			; Pop the check value off the stack
0B1134 21 09 17 0B 1097**  			LD      HL,LOCCHK		; Check if it is the LOCAL Marker
0B1138 B7          1098**  			OR      A
0B1139 ED 42       1099**  			SBC     HL,BC
0B113B 28 13       1100**  			JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
0B113D             1101**  ;
0B113D 21 3A 10 0B 1102**  			LD      HL,PROCHK       	; Check if it is the PROC marker
0B1141 B7          1103**  			OR      A
0B1142 ED 42       1104**  			SBC     HL,BC
0B1144 FD E1       1105**  			POP     IY
0B1146 CA 47 0B 0B 1106**  			JP      Z,XEQ			; Yes, it is, so carry on, all is good
0B114A 3E 0D       1107**  			LD      A,13			; Otherwise throw the "No PROC" error
0B114C C3 11 37 0B 1108**  			JP      ERROR_
0B1150             1109**  ;
0B1150 DD E1       1110**  UNSTK:			POP     IX			; Unstack a single local variable
0B1152 C1          1111**  			POP     BC
0B1153 78          1112**  			LD      A,B
0B1154 B7          1113**  			OR      A
0B1155 FA 63 11 0B 1114**  			JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0B1159 E1          1115**  			POP     HL			; Unstack a normal variable
0B115A D9          1116**  			EXX
0B115B E1          1117**  			POP     HL
0B115C D9          1118**  			EXX
0B115D CD 87 15 0B 1119**  			CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0B1161 18 D0       1120**  			JR      ENDPRO			; And loop back to ENDPRO
0B1163             1121**  ;
0B1163 21 00 00 00 1122**  UNSTK1:			LD      HL,0			; Unstack a string
0B1167 39          1123**  			ADD     HL,SP
0B1168 59          1124**  			LD      E,C
0B1169 CD B5 15 0B 1125**  			CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0B116D F9          1126**  			LD      SP,HL
0B116E 18 C3       1127**  			JR      ENDPRO
0B1170             1128**  
0B1170             1129**  ; INPUT #channel,var,var...
0B1170             1130**  ;
0B1170 CD 43 18 0B 1131**  INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0B1174 CD 21 0A 0B 1132**  INPN1:			CALL    NXT
0B1178 FE 2C       1133**  			CP      ','
0B117A C2 47 0B 0B 1134**  			JP      NZ,XEQ
0B117E FD 23       1135**  			INC     IY
0B1180 CD 21 0A 0B 1136**  			CALL    NXT
0B1184 D5          1137**  			PUSH    DE
0B1185 CD 3F 0C 0B 1138**  			CALL    VAR_
0B1189 D1          1139**  			POP     DE
0B118A F5          1140**  			PUSH    AF              ;SAVE TYPE
0B118B E5          1141**  			PUSH    HL              ;VARPTR
0B118C B7          1142**  			OR      A
0B118D FA B9 11 0B 1143**  			JP      M,INPN2         ;STRING
0B1191 CD E4 42 0B 1144**  			CALL    OSBGET
0B1195 D9          1145**  			EXX
0B1196 6F          1146**  			LD      L,A
0B1197 D9          1147**  			EXX
0B1198 CD E4 42 0B 1148**  			CALL    OSBGET
0B119C D9          1149**  			EXX
0B119D 67          1150**  			LD      H,A
0B119E D9          1151**  			EXX
0B119F CD E4 42 0B 1152**  			CALL    OSBGET
0B11A3 6F          1153**  			LD      L,A
0B11A4 CD E4 42 0B 1154**  			CALL    OSBGET
0B11A8 67          1155**  			LD      H,A
0B11A9 CD E4 42 0B 1156**  			CALL    OSBGET
0B11AD 4F          1157**  			LD      C,A
0B11AE DD E1       1158**  			POP     IX
0B11B0 F1          1159**  			POP     AF              ;RESTORE TYPE
0B11B1 D5          1160**  			PUSH    DE              ;SAVE CHANNEL
0B11B2 CD 87 15 0B 1161**  			CALL    STORE
0B11B6 D1          1162**  			POP     DE
0B11B7 18 BB       1163**  			JR      INPN1
0B11B9 21 00 49 0B 1164**  INPN2:			LD      HL,ACCS
0B11BD CD E4 42 0B 1165**  INPN3:			CALL    OSBGET
0B11C1 FE 0D       1166**  			CP      CR
0B11C3 28 04       1167**  			JR      Z,INPN4
0B11C5 77          1168**  			LD      (HL),A
0B11C6 2C          1169**  			INC     L
0B11C7 20 F4       1170**  			JR      NZ,INPN3
0B11C9 DD E1       1171**  INPN4:			POP     IX
0B11CB F1          1172**  			POP     AF
0B11CC D5          1173**  			PUSH    DE
0B11CD EB          1174**  			EX      DE,HL
0B11CE CD B1 15 0B 1175**  			CALL    STACCS
0B11D2 D1          1176**  			POP     DE
0B11D3 18 9F       1177**  			JR      INPN1
0B11D5             1178**  
0B11D5             1179**  ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
0B11D5             1180**  ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
0B11D5             1181**  ;
0B11D5 FE 23       1182**  INPUT:			CP      '#'
0B11D7 28 97       1183**  			JR      Z,INPUTN
0B11D9 0E 00       1184**  			LD      C,0             ;FLAG PROMPT
0B11DB FE 86       1185**  			CP      LINE_EX_
0B11DD 20 04       1186**  			JR      NZ,INPUT0
0B11DF FD 23       1187**  			INC     IY              ;SKIP "LINE"
0B11E1 0E 80       1188**  			LD      C,80H
0B11E3 21 00 4A 0B 1189**  INPUT0:			LD      HL,BUFFER
0B11E7 36 0D       1190**  			LD      (HL),CR         ;INITIALISE EMPTY
0B11E9 CD 2B 17 0B 1191**  INPUT1:			CALL    TERMQ
0B11ED CA 47 0B 0B 1192**  			JP      Z,XEQ           ;DONE
0B11F1 FD 23       1193**  			INC     IY
0B11F3 FE 2C       1194**  			CP      ','
0B11F5 28 5C       1195**  			JR      Z,INPUT3        ;SKIP COMMA
0B11F7 FE 3B       1196**  			CP      ';'
0B11F9 28 58       1197**  			JR      Z,INPUT3
0B11FB E5          1198**  			PUSH    HL              ;SAVE BUFFER POINTER
0B11FC FE 22       1199**  			CP      34		;ASCII ""
0B11FE 20 0C       1200**  			JR      NZ,INPUT6
0B1200 C5          1201**  			PUSH    BC
0B1201 CD 18 04 0B 1202**  			CALL    CONS
0B1205 C1          1203**  			POP     BC
0B1206 CD AF 17 0B 1204**  			CALL    PTEXT           ;PRINT PROMPT
0B120A 18 06       1205**  			JR      INPUT9
0B120C CD 50 17 0B 1206**  INPUT6:			CALL    FORMAT          ;SPC, TAB, '
0B1210 20 05       1207**  			JR      NZ,INPUT2
0B1212 E1          1208**  INPUT9:			POP     HL
0B1213 CB C1       1209**  			SET     0,C             ;FLAG NO PROMPT
0B1215 18 CC       1210**  			JR      INPUT0
0B1217 FD 2B       1211**  INPUT2:			DEC     IY
0B1219 C5          1212**  			PUSH    BC
0B121A CD 3F 0C 0B 1213**  			CALL    VAR_
0B121E C1          1214**  			POP     BC
0B121F E1          1215**  			POP     HL
0B1220 F5          1216**  			PUSH    AF              ;SAVE TYPE
0B1221 7E          1217**  			LD      A,(HL)
0B1222 23          1218**  			INC     HL
0B1223 FE 0D       1219**  			CP      CR              ;BUFFER EMPTY?
0B1225 CC 57 12 0B 1220**  			CALL    Z,REFILL
0B1229 CB 79       1221**  			BIT     7,C
0B122B F5          1222**  			PUSH    AF
0B122C C4 D1 17 0B 1223**  			CALL    NZ,LINES
0B1230 F1          1224**  			POP     AF
0B1231 CC BE 17 0B 1225**  			CALL    Z,FETCHS
0B1235 F1          1226**  			POP     AF              ;RESTORE TYPE
0B1236 C5          1227**  			PUSH    BC
0B1237 E5          1228**  			PUSH    HL
0B1238 B7          1229**  			OR      A
0B1239 FA 4D 12 0B 1230**  			JP      M,INPUT4        ;STRING
0B123D F5          1231**  			PUSH    AF
0B123E DD E5       1232**  			PUSH    IX
0B1240 CD 1F 06 0B 1233**  			CALL    VAL0
0B1244 DD E1       1234**  			POP     IX
0B1246 F1          1235**  			POP     AF
0B1247 CD 87 15 0B 1236**  			CALL    STORE
0B124B 18 04       1237**  			JR      INPUT5
0B124D CD B1 15 0B 1238**  INPUT4:			CALL    STACCS
0B1251 E1          1239**  INPUT5:			POP     HL
0B1252 C1          1240**  			POP     BC
0B1253 CB 81       1241**  INPUT3:			RES     0,C
0B1255 18 92       1242**  			JR      INPUT1
0B1257             1243**  ;
0B1257 CB 41       1244**  REFILL:			BIT     0,C
0B1259 20 0C       1245**  			JR      NZ,REFIL0       ;NO PROMPT
0B125B 3E 3F       1246**  			LD      A,'?'
0B125D CD 00 39 0B 1247**  			CALL    OUTCHR          ;PROMPT
0B1261 3E 20       1248**  			LD      A,' '
0B1263 CD 00 39 0B 1249**  			CALL    OUTCHR
0B1267 21 00 4A 0B 1250**  REFIL0:			LD      HL,BUFFER
0B126B C5          1251**  			PUSH    BC
0B126C E5          1252**  			PUSH    HL
0B126D DD E5       1253**  			PUSH    IX
0B126F CD 10 3E 0B 1254**  			CALL    OSLINE
0B1273 DD E1       1255**  			POP     IX
0B1275 E1          1256**  			POP     HL
0B1276 C1          1257**  			POP     BC
0B1277 47          1258**  			LD      B,A             ;POS AT ENTRY
0B1278 AF          1259**  			XOR     A
0B1279 32 3D 4C 0B 1260**  			LD      (COUNT),A
0B127D B8          1261**  			CP      B
0B127E C8          1262**  			RET     Z
0B127F 7E          1263**  REFIL1:			LD      A,(HL)
0B1280 FE 0D       1264**  			CP      CR
0B1282 C8          1265**  			RET     Z
0B1283 23          1266**  			INC     HL
0B1284 10 F9       1267**  			DJNZ    REFIL1
0B1286 C9          1268**  			RET
0B1287             1269**  
0B1287             1270**  ; READ var[,var...]
0B1287             1271**  ;
0B1287 FE 23       1272**  READ:			CP      '#'
0B1289 CA 70 11 0B 1273**  			JP      Z,INPUTN
0B128D 2A 31 4C 0B 1274**  			LD      HL,(DATPTR)
0B1291 7E          1275**  READ0:			LD      A,(HL)
0B1292 23          1276**  			INC     HL              ;SKIP COMMA OR "DATA"
0B1293 FE 0D       1277**  			CP      CR              ;END OF DATA STMT?
0B1295 CC D9 12 0B 1278**  			CALL    Z,GETDAT
0B1299 E5          1279**  			PUSH    HL
0B129A CD 3F 0C 0B 1280**  			CALL    VAR_
0B129E E1          1281**  			POP     HL
0B129F B7          1282**  			OR      A
0B12A0 FA B9 12 0B 1283**  			JP      M,READ1         ;STRING
0B12A4 E5          1284**  			PUSH    HL
0B12A5 FD E3       1285**  			EX      (SP),IY
0B12A7 F5          1286**  			PUSH    AF              ;SAVE TYPE
0B12A8 DD E5       1287**  			PUSH    IX
0B12AA CD B3 02 0B 1288**  			CALL    EXPRN
0B12AE DD E1       1289**  			POP     IX
0B12B0 F1          1290**  			POP     AF
0B12B1 CD 87 15 0B 1291**  			CALL    STORE
0B12B5 FD E3       1292**  			EX      (SP),IY
0B12B7 18 09       1293**  			JR      READ2
0B12B9 CD BE 17 0B 1294**  READ1:			CALL    FETCHS
0B12BD E5          1295**  			PUSH    HL
0B12BE CD B1 15 0B 1296**  			CALL    STACCS
0B12C2 E1          1297**  READ2:			POP     HL
0B12C3 22 31 4C 0B 1298**  			LD      (DATPTR),HL
0B12C7 CD 21 0A 0B 1299**  			CALL    NXT
0B12CB FE 2C       1300**  			CP      ','
0B12CD C2 47 0B 0B 1301**  			JP      NZ,XEQ
0B12D1 FD 23       1302**  			INC     IY
0B12D3 CD 21 0A 0B 1303**  			CALL    NXT
0B12D7 18 B8       1304**  			JR      READ0
0B12D9             1305**  ;
0B12D9 3E DC       1306**  GETDAT:			LD      A,DATA_EX_
0B12DB CD FF 17 0B 1307**  			CALL    SEARCH_EX
0B12DF 23          1308**  			INC     HL
0B12E0 D0          1309**  			RET     NC
0B12E1 3E 2A       1310**  			LD      A,42
0B12E3 C3 11 37 0B 1311**  ERROR4:			JP      ERROR_           ;"Out of DATA"
0B12E7             1312**  
0B12E7             1313**  ; IF expr statement
0B12E7             1314**  ; IF expr THEN statement [ELSE statement]
0B12E7             1315**  ; IF expr THEN line [ELSE line]
0B12E7             1316**  ;
0B12E7 CD BB 02 0B 1317**  IF_:			CALL    EXPRI
0B12EB CD 90 08 0B 1318**  			CALL    TEST
0B12EF 28 19       1319**  			JR      Z,IFNOT         ;FALSE
0B12F1 FD 7E 00    1320**  			LD      A,(IY)
0B12F4 FE 8C       1321**  			CP      THEN_EX_
0B12F6 C2 47 0B 0B 1322**  			JP      NZ,XEQ
0B12FA FD 23       1323**  			INC     IY              ;SKIP "THEN"
0B12FC CD 21 0A 0B 1324**  IF1:			CALL    NXT
0B1300 FE 8D       1325**  			CP      LINO_EX
0B1302 C2 47 0B 0B 1326**  			JP      NZ,XEQ          ;STATEMENT FOLLOWS
0B1306 C3 DC 0E 0B 1327**  			JP      GOTO_EX            ;LINE NO. FOLLOWS
0B130A FD 7E 00    1328**  IFNOT:			LD      A,(IY)
0B130D FE 0D       1329**  			CP      CR
0B130F FD 23       1330**  			INC     IY
0B1311 CA 43 0B 0B 1331**  			JP      Z,XEQ0          ;END OF LINE
0B1315 FE 8B       1332**  			CP      ELSE_EX_
0B1317 20 F1       1333**  			JR      NZ,IFNOT
0B1319 18 E1       1334**  			JR      IF1
0B131B             1335**  
0B131B             1336**  ; CLS
0B131B             1337**  ;
0B131B CD 7D 43 0B 1338**  CLS:		CALL    CLRSCN
0B131F AF          1339**  			XOR     A
0B1320 32 3D 4C 0B 1340**  			LD      (COUNT),A
0B1324 C3 47 0B 0B 1341**  			JP      XEQ
0B1328             1342**  
0B1328             1343**  ; STOP
0B1328             1344**  ;
0B1328 CD 41 3D 0B 1345**  STOP:			CALL    TELL
0B132C 0D          1346**  			DB	CR
0B132D 0A          1347**  			DB	LF
0B132E FA          1348**  			DB	TSTOP
0B132F 00          1349**  			DB	0
0B1330 CD 5F 39 0B 1350**  			CALL    SETLIN          ;FIND CURRENT LINE
0B1334 CD 93 39 0B 1351**  			CALL    SAYLN
0B1338 CD F8 38 0B 1352**  			CALL    CRLF
0B133C C3 31 30 0B 1353**  			JP      CLOOP
0B1340             1354**  
0B1340             1355**  ; REPORT
0B1340             1356**  ;
0B1340 CD 33 3D 0B 1357**  REPOR:			CALL    REPORT
0B1344 C3 47 0B 0B 1358**  			JP      XEQ
0B1348             1359**  
0B1348             1360**  ; CLEAR
0B1348             1361**  ;
0B1348 CD 27 38 0B 1362**  CLR:			CALL    CLEAR
0B134C 2A 14 4C 0B 1363**  			LD      HL,(PAGE_)
0B1350 18 19       1364**  			JR      RESTR1
0B1352             1365**  
0B1352             1366**  ; RESTORE [line]
0B1352             1367**  ;
0B1352 2A 14 4C 0B 1368**  RESTOR_EX:			LD      HL,(PAGE_)
0B1356 CD 2B 17 0B 1369**  			CALL    TERMQ
0B135A 28 0F       1370**  			JR      Z,RESTR1
0B135C CD D6 02 0B 1371**  			CALL    ITEMI
0B1360 D9          1372**  			EXX
0B1361 CD 40 39 0B 1373**  			CALL    FINDL           ;SEARCH FOR LINE
0B1365 3E 29       1374**  			LD      A,41
0B1367 C2 E3 12 0B 1375**  			JP      NZ,ERROR4       ;"No such line"
0B136B 3E DC       1376**  RESTR1:			LD      A,DATA_EX_
0B136D CD FF 17 0B 1377**  			CALL    SEARCH_EX
0B1371 22 31 4C 0B 1378**  			LD      (DATPTR),HL
0B1375 C3 47 0B 0B 1379**  			JP      XEQ
0B1379             1380**  
0B1379             1381**  ; PTR#channel=expr
0B1379             1382**  ; PAGE=expr
0B1379             1383**  ; TIME=expr
0B1379             1384**  ; LOMEM=expr
0B1379             1385**  ; HIMEM=expr
0B1379             1386**  ;
0B1379 CD 37 18 0B 1387**  PTR_EX:			CALL    CHANEL
0B137D CD 41 17 0B 1388**  			CALL    EQUALS
0B1381 7B          1389**  			LD      A,E
0B1382 F5          1390**  			PUSH    AF
0B1383 CD BB 02 0B 1391**  			CALL    EXPRI
0B1387 E5          1392**  			PUSH    HL
0B1388 D9          1393**  			EXX
0B1389 D1          1394**  			POP     DE
0B138A F1          1395**  			POP     AF
0B138B CD 18 43 0B 1396**  			CALL    PUTPTR
0B138F C3 47 0B 0B 1397**  			JP      XEQ
0B1393             1398**  ;
0B1393 CD 41 17 0B 1399**  PAGEV_EX:			CALL    EQUALS
0B1397 CD BB 02 0B 1400**  			CALL    EXPRI
0B139B D9          1401**  			EXX
0B139C 2E 00       1402**  			LD      L,0
0B139E 22 14 4C 0B 1403**  			LD      (PAGE_),HL
0B13A2 C3 47 0B 0B 1404**  			JP      XEQ
0B13A6             1405**  ;
0B13A6 FE 24       1406**  TIMEV_EX:			CP      '$'
0B13A8 28 13       1407**  			JR      Z,TIMEVS_EX
0B13AA CD 41 17 0B 1408**  			CALL    EQUALS
0B13AE CD BB 02 0B 1409**  			CALL    EXPRI
0B13B2 E5          1410**  			PUSH    HL
0B13B3 D9          1411**  			EXX
0B13B4 D1          1412**  			POP     DE
0B13B5 CD 48 3E 0B 1413**  			CALL    PUTIME
0B13B9 C3 47 0B 0B 1414**  			JP      XEQ
0B13BD             1415**  ;
0B13BD FD 23       1416**  TIMEVS_EX:			INC     IY              ;SKIP '$'
0B13BF CD 41 17 0B 1417**  			CALL    EQUALS
0B13C3 CD C6 02 0B 1418**  			CALL    EXPRS
0B13C7 CD 68 43 0B 1419**  			CALL    PUTIMS
0B13CB C3 47 0B 0B 1420**  			JP      XEQ
0B13CF             1421**  ;
0B13CF CD 41 17 0B 1422**  LOMEMV_EX:			CALL    EQUALS
0B13D3 CD BB 02 0B 1423**  			CALL    EXPRI
0B13D7 CD 27 38 0B 1424**  			CALL    CLEAR
0B13DB D9          1425**  			EXX
0B13DC 22 1A 4C 0B 1426**  			LD      (LOMEM),HL
0B13E0 22 1D 4C 0B 1427**  			LD      (FREE),HL
0B13E4 C3 47 0B 0B 1428**  			JP      XEQ
0B13E8             1429**  ;
0B13E8 CD 41 17 0B 1430**  HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
0B13EC CD BB 02 0B 1431**  			CALL    EXPRI			; Load the expression into registers
0B13F0             1432**  ; BEGIN MISSING FROM BINARY
0B13F0             1433**  			; LD	A,L			;  A: The MSB of the 24-bit value
0B13F0             1434**  			; EXX				; HL: The LSW of the 24-bit value
0B13F0             1435**  			; LD	(R0),HL
0B13F0             1436**  			; LD	(R0+2),A
0B13F0             1437**  			; LD	HL,(FREE)
0B13F0             1438**  			; LD      DE,256
0B13F0             1439**  			; ADD	HL,DE
0B13F0             1440**  			; EX	DE,HL			; DE: FREE + 256
0B13F0             1441**  			; LD	HL,(R0)			; HL: The passed expression
0B13F0             1442**  ; END MISSING FROM BINARY
0B13F0             1443**  ; BEGIN ADDED FROM BINARY
0B13F0 D9          1444**  			exx
0B13F1 ED 5B 1D 4C 1445**  			ld de,(FREE)
       0B          
0B13F6 14          1446**  			inc d
0B13F7             1447**  ; END ADDED FROM BINARY
0B13F7 AF          1448**  			XOR     A
0B13F8 ED 52       1449**  			SBC     HL,DE
0B13FA 19          1450**  			ADD     HL,DE			; Do a bounds check
0B13FB DA 11 37 0B 1451**  			JP      C,ERROR_         	; Throw the error: "No room"
0B13FF ED 5B 20 4C 1452**  			LD      DE,(HIMEM)
       0B          
0B1404 22 20 4C 0B 1453**  			LD      (HIMEM),HL
0B1408 EB          1454**  			EX      DE,HL
0B1409 ED 72       1455**  			SBC     HL,SP			; Adjust the stack
0B140B C2 47 0B 0B 1456**  			JP      NZ,XEQ
0B140F EB          1457**  			EX      DE,HL
0B1410 F9          1458**  			LD      SP,HL           	; Load the SP
0B1411 C3 47 0B 0B 1459**  			JP      XEQ
0B1415             1460**  
0B1415             1461**  ; WIDTH expr
0B1415             1462**  ;
0B1415 CD BB 02 0B 1463**  WIDTHV:			CALL    EXPRI
0B1419 D9          1464**  			EXX
0B141A 7D          1465**  			LD      A,L
0B141B 32 3E 4C 0B 1466**  			LD      (WIDTH),A
0B141F C3 47 0B 0B 1467**  			JP      XEQ
0B1423             1468**  
0B1423             1469**  ; TRACE ON
0B1423             1470**  ; TRACE OFF
0B1423             1471**  ; TRACE line
0B1423             1472**  ;
0B1423 FD 23       1473**  TRACE_EX:			INC     IY
0B1425 21 00 00 00 1474**  			LD      HL,0
0B1429 FE EE       1475**  			CP      TON
0B142B 28 0B       1476**  			JR      Z,TRACE0
0B142D FE 87       1477**  			CP      OFF_
0B142F 28 08       1478**  			JR      Z,TRACE1
0B1431 FD 2B       1479**  			DEC     IY
0B1433 CD BB 02 0B 1480**  			CALL    EXPRI
0B1437 D9          1481**  			EXX
0B1438 2B          1482**  TRACE0:			DEC     HL
0B1439 22 26 4C 0B 1483**  TRACE1:			LD      (TRACEN),HL
0B143D C3 47 0B 0B 1484**  			JP      XEQ
0B1441             1485**  
0B1441             1486**  ; VDU expr,expr;....
0B1441             1487**  ;
0B1441             1488**  ; BEGIN MISSING FROM BINARY
0B1441             1489**  ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
0B1441             1490**  ; VDU1:			PUSH	IX
0B1441             1491**  ; 			CALL    EXPRI			; Fetch the VDU character
0B1441             1492**  ; 			POP	IX
0B1441             1493**  ; 			EXX
0B1441             1494**  ; 			LD	(IX+0),L		; Write out the character to the buffer
0B1441             1495**  ; 			INC	IX
0B1441             1496**  ; 			LD      A,(IY)			;  A: The separator character
0B1441             1497**  ; 			CP      ','			; Is it a comma?
0B1441             1498**  ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
0B1441             1499**  ; 			CP      ';'			; Is it a semicolon?
0B1441             1500**  ; 			JR      NZ,VDU3			; No, so skip to the next expression
0B1441             1501**  ; 			LD	(IX+0),H		; Write out the high byte to the buffer
0B1441             1502**  ; 			INC	IX
0B1441             1503**  ; VDU2:			INC     IY			; Skip to the next character
0B1441             1504**  ; VDU3:			CALL    TERMQ			; Skip past white space
0B1441             1505**  ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
0B1441             1506**  ; 			LD	A,IXL			;  A: Number of bytes to write out
0B1441             1507**  ; 			OR	A
0B1441             1508**  ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
0B1441             1509**  ; 			LD	HL,BUFFER		; HL: Start of stream
0B1441             1510**  ; 			LD	BC,0
0B1441             1511**  ; 			LD	C,A			; BC: Number of bytes to write out
0B1441             1512**  ; 			RST.LIL	18h			; Output the buffer to MOS
0B1441             1513**  ; END MISSING FROM BINARY
0B1441             1514**  ; BEGIN ADDED FROM BINARY
0B1441             1515**  VDU:
0B1441 CD BB 02 0B 1516**  			call EXPRI
0B1445 D9          1517**  			exx
0B1446 7D          1518**  			ld a,l
0B1447 CD B1 3E 0B 1519**  			call OSWRCH
0B144B FD 7E 00    1520**  			ld a,(iy)
0B144E FE 2C       1521**  			cp $2c
0B1450 28 09       1522**  			jr z,$+$0b
0B1452 FE 3B       1523**  			cp $3b
0B1454 20 07       1524**  			jr nz,$+$09
0B1456 7C          1525**  			ld a,h
0B1457 CD B1 3E 0B 1526**  			call OSWRCH
0B145B FD 23       1527**  			inc iy
0B145D CD 2B 17 0B 1528**  			call TERMQ
0B1461 20 DE       1529**  			jr nz,$-$20
0B1463             1530**  ; END ADDED FROM BINARY
0B1463 C3 47 0B 0B 1531**  VDU4:			JP      XEQ
0B1467             1532**  
0B1467             1533**  ; CLOSE channel number
0B1467             1534**  ;
0B1467 CD 37 18 0B 1535**  CLOSE:			CALL    CHANEL			; Fetch the channel number
0B146B CD DC 42 0B 1536**  			CALL    OSSHUT			; Close the channel
0B146F C3 47 0B 0B 1537**  			JP      XEQ
0B1473             1538**  
0B1473             1539**  ; BPUT channel,byte
0B1473             1540**  ;
0B1473 CD 37 18 0B 1541**  BPUT:			CALL    CHANEL          	; Fetch the channel number
0B1477 D5          1542**  			PUSH    DE			; DE: Channel number
0B1478 CD D3 09 0B 1543**  			CALL    COMMA			; Skip to the next expression
0B147C CD BB 02 0B 1544**  			CALL    EXPRI           	; Feth the data
0B1480 D9          1545**  			EXX
0B1481 7D          1546**  			LD      A,L			; A: The byte to write
0B1482 D1          1547**  			POP     DE
0B1483 CD EC 42 0B 1548**  			CALL    OSBPUT			; Write the byte out
0B1487 C3 47 0B 0B 1549**  			JP      XEQ
0B148B             1550**  
0B148B             1551**  ; CALL address[,var[,var...]]
0B148B             1552**  ;
0B148B             1553**  ; Note that the parameter table differs from the Z80 version
0B148B             1554**  ; Each entry now takes up 4 bytes, not 3, so the table is now:
0B148B             1555**  ;  -1 byte:  Number of parameters
0B148B             1556**  ; Then, for each parameter:
0B148B             1557**  ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
0B148B             1558**  ;  -3 bytes: Parameter address
0B148B             1559**  ;
0B148B             1560**  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
0B148B             1561**  ;
0B148B CD BB 02 0B 1562**  CALL_:			CALL    EXPRI           	; Fetch the address
0B148F 7D          1563**  			LD	A,L			;  A: MSB of address
0B1490 D9          1564**  			EXX
0B1491 22 4A 4C 0B 1565**  			LD	(R0+0),HL		; HL: LSW of address
0B1495 32 4C 4C 0B 1566**  			LD	(R0+2),A
0B1499 06 00       1567**  			LD      B,0             	;  B: The parameter counter
0B149B 11 00 4A 0B 1568**  			LD      DE,BUFFER       	; DE: Vector
0B149F             1569**  ;
0B149F CD 21 0A 0B 1570**  CALL1:			CALL    NXT			; Skip whitespace
0B14A3 FE 2C       1571**  			CP      ','			; Check for comma
0B14A5 20 1B       1572**  			JR      NZ,CALL2		; If no more parameters, then jump here
0B14A7 FD 23       1573**  			INC     IY			; Skip to the next character
0B14A9 04          1574**  			INC     B			; Increment the parameter count
0B14AA CD 21 0A 0B 1575**  			CALL    NXT			; Skip whitespace
0B14AE C5          1576**  			PUSH    BC
0B14AF D5          1577**  			PUSH    DE
0B14B0 CD 3F 0C 0B 1578**  			CALL    VAR_
0B14B4 D1          1579**  			POP     DE
0B14B5 C1          1580**  			POP     BC
0B14B6 13          1581**  			INC     DE
0B14B7 12          1582**  			LD      (DE),A			; Save the parameter type
0B14B8 13          1583**  			INC     DE
0B14B9 EB          1584**  			EX      DE,HL
0B14BA ED 1F       1585**  			LD	(HL),DE			; Save the parameter address (3 bytes)
0B14BC 23          1586**  			INC	HL
0B14BD 23          1587**  			INC	HL
0B14BE 23          1588**  			INC	HL
0B14BF EB          1589**  			EX      DE,HL
0B14C0 18 DD       1590**  			JR      CALL1
0B14C2             1591**  ;
0B14C2 78          1592**  CALL2:			LD      A,B
0B14C3 32 00 4A 0B 1593**  			LD      (BUFFER),A      	; Save the parameter count
0B14C7 2A 4A 4C 0B 1594**  			LD	HL,(R0)			; HL: Address of the code
0B14CB CD E5 14 0B 1595**  			CALL    USR1			; And call it
0B14CF C3 47 0B 0B 1596**  			JP      XEQ
0B14D3             1597**  
0B14D3             1598**  ; USR(address)
0B14D3             1599**  ;
0B14D3 CD D6 02 0B 1600**  USR:			CALL    ITEMI			; Evaluate the expression
0B14D7 7D          1601**  			LD	A,L			;  A: MSB of address
0B14D8 D9          1602**  			EXX
0B14D9 22 4A 4C 0B 1603**  			LD	(R0+0),HL		; HL: LSW of address
0B14DD 32 4C 4C 0B 1604**  			LD	(R0+2),A
0B14E1 2A 4A 4C 0B 1605**  			LD	HL,(R0)			; Get the 24-bit address in HL
0B14E5             1606**  ;
0B14E5 E5          1607**  USR1:			PUSH    HL              	; Address on stack
0B14E6 FD E3       1608**  			EX      (SP),IY
0B14E8 24          1609**  			INC     H               	; Check for PAGE &00FFxx
0B14E9 B4          1610**  			OR	H
0B14EA 21 54 15 0B 1611**  			LD      HL,USR2         	; Return address
0B14EE E5          1612**  			PUSH    HL
0B14EF DD 21 00 4B 1613**  			LD      IX,STAVAR
       0B          
0B14F4 CC A2 42 0B 1614**  			CALL    Z,OSCALL        	; Intercept &00FFxx
0B14F8             1615**  ;
0B14F8 DD 4E 18    1616**  			LD      C, (IX+24)		; F%
0B14FB C5          1617**  			PUSH    BC
0B14FC             1618**  ;
0B14FC DD 7E 08    1619**  			LD	A, (IX+8)		; B% -> MSW
0B14FF 32 4B 4C 0B 1620**  			LD	(R0+1), A
0B1503 DD 7E 09    1621**  			LD	A, (IX+9)
0B1506 32 4C 4C 0B 1622**  			LD	(R0+2), A
0B150A DD 7E 0C    1623**  			LD	A, (IX+12)		; C% -> LSB
0B150D 32 4A 4C 0B 1624**  			LD	(R0+0), A
0B1511 ED 4B 4A 4C 1625**  			LD	BC, (R0)
       0B          
0B1516             1626**  ;
0B1516 DD 7E 10    1627**  			LD	A, (IX+16)		; D% -> MSW
0B1519 32 4B 4C 0B 1628**  			LD	(R0+1), A
0B151D DD 7E 11    1629**  			LD	A, (IX+17)
0B1520 32 4C 4C 0B 1630**  			LD	(R0+2), A
0B1524 DD 7E 14    1631**  			LD	A, (IX+20)		; E% -> LSB
0B1527 32 4A 4C 0B 1632**  			LD	(R0+0), A
0B152B ED 5B 4A 4C 1633**  			LD	DE, (R0)
       0B          
0B1530             1634**  ;
0B1530 DD 7E 20    1635**  			LD	A, (IX+32)		; H% -> MSW
0B1533 32 4B 4C 0B 1636**  			LD	(R0+1), A
0B1537 DD 7E 21    1637**  			LD	A, (IX+33)
0B153A 32 4C 4C 0B 1638**  			LD	(R0+2), A
0B153E DD 7E 30    1639**  			LD	A, (IX+48)		; L% -> LSB
0B1541 32 4A 4C 0B 1640**  			LD	(R0+0), A
0B1545 2A 4A 4C 0B 1641**  			LD	HL, (R0)
0B1549             1642**  ;
0B1549 F1          1643**  			POP     AF			; F%
0B154A DD 7E 04    1644**  			LD      A, (IX+4)        	; A%
0B154D             1645**  
0B154D DD 21 00 4A 1646**  			LD      IX,BUFFER
       0B          
0B1552 FD E9       1647**  			JP      (IY)            	; Off to user routine
0B1554             1648**  ;
0B1554 FD E1       1649**  USR2:			POP     IY
0B1556 AF          1650**  			XOR     A
0B1557 4F          1651**  			LD      C,A
0B1558 C9          1652**  			RET
0B1559             1653**  
0B1559             1654**  ; PUT port,data
0B1559             1655**  ;
0B1559 CD BB 02 0B 1656**  PUT:			CALL    EXPRI           ;PORT ADDRESS
0B155D D9          1657**  			EXX
0B155E E5          1658**  			PUSH    HL
0B155F CD D3 09 0B 1659**  			CALL    COMMA
0B1563 CD BB 02 0B 1660**  			CALL    EXPRI           ;DATA
0B1567 D9          1661**  			EXX
0B1568 C1          1662**  			POP     BC
0B1569 ED 69       1663**  			OUT     (C),L           ;OUTPUT TO PORT BC
0B156B C3 47 0B 0B 1664**  			JP      XEQ
0B156F             1665**  
0B156F             1666**  ; SUBROUTINES -----------------------------------------------------------------
0B156F             1667**  
0B156F             1668**  ; ASSIGN - Assign a numeric value to a variable.
0B156F             1669**  ; Outputs: NC,  Z - OK, numeric.
0B156F             1670**  ;          NC, NZ - OK, string.
0B156F             1671**  ;           C, NZ - illegal
0B156F             1672**  ;
0B156F CD EB 39 0B 1673**  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0B1573 D8          1674**  			RET     C               	; Return with C if it is an illegal variable
0B1574 C4 DA 39 0B 1675**  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0B1578 B7          1676**  			OR      A
0B1579 F8          1677**  			RET     M               	; Return if type is string (81h)
0B157A F5          1678**  			PUSH    AF              	; It's a numeric type from this point on
0B157B CD 41 17 0B 1679**  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B157F E5          1680**  			PUSH    HL
0B1580 CD B3 02 0B 1681**  			CALL    EXPRN
0B1584 DD E1       1682**  			POP     IX
0B1586 F1          1683**  			POP     AF
0B1587 CB 47       1684**  STORE:			BIT     0,A
0B1589 28 13       1685**  			JR      Z,STOREI
0B158B BF          1686**  			CP      A               	; Set the variable to 0
0B158C DD 71 04    1687**  STORE5:			LD      (IX+4),C
0B158F D9          1688**  STORE4:			EXX
0B1590 DD 75 00    1689**  			LD      (IX+0),L
0B1593 DD 74 01    1690**  			LD      (IX+1),H
0B1596 D9          1691**  			EXX
0B1597 DD 75 02    1692**  			LD      (IX+2),L
0B159A DD 74 03    1693**  			LD      (IX+3),H
0B159D C9          1694**  			RET
0B159E F5          1695**  STOREI:			PUSH    AF
0B159F 0C          1696**  			INC     C               ;SPEED - & PRESERVE F'
0B15A0 0D          1697**  			DEC     C               ; WHEN CALLED BY FNEND0
0B15A1 C4 13 06 0B 1698**  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
0B15A5 F1          1699**  			POP     AF
0B15A6 FE 04       1700**  			CP      4
0B15A8 28 E5       1701**  			JR      Z,STORE4
0B15AA BF          1702**  			CP      A               ;SET ZERO
0B15AB D9          1703**  STORE1:			EXX
0B15AC DD 75 00    1704**  			LD      (IX+0),L
0B15AF D9          1705**  			EXX
0B15B0 C9          1706**  			RET
0B15B1             1707**  ;
0B15B1             1708**  ; Copy a string from the string accumulator to variable storage on the stack
0B15B1             1709**  ; Parameters:
0B15B1             1710**  ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
0B15B1             1711**  ; - IX: Address of the variable storage on the stack
0B15B1             1712**  ;
0B15B1 21 00 49 0B 1713**  STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B15B5             1714**  ;
0B15B5             1715**  ; Parameters:
0B15B5             1716**  ; As above, but:
0B15B5             1717**  ; - HL: Address of the string to be stored
0B15B5             1718**  ; -  E: The string length
0B15B5             1719**  ; NB:
0B15B5             1720**  ; Strings are mutable
0B15B5             1721**  ; Strings are stored in the following format in the variable:
0B15B5             1722**  ; - Address of the next variable (3 bytes)
0B15B5             1723**  ; - The rest of the variable name - this is zero terminated
0B15B5             1724**  ; - Current string length (byte)
0B15B5             1725**  ; - Maximum (original) string length (byte)
0B15B5             1726**  ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
0B15B5             1727**  ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
0B15B5             1728**  ;
0B15B5 1F          1729**  STORES:			RRA				; Rotate right to shift bit 0 into carry
0B15B6 30 5D       1730**  			JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
0B15B8 E5          1731**  			PUSH    HL			; Stack ACCS
0B15B9             1732**  ;
0B15B9             1733**  ; Load the string pointer and lengths into registers - these are all zeroed for new strings
0B15B9             1734**  ;
0B15B9 D9          1735**  			EXX				; This block was a call to LOAD4
0B15BA DD 6E 00    1736**  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B15BD DD 66 01    1737**  			LD      H,(IX+1)		; The maximum original string length
0B15C0 D9          1738**  			EXX
0B15C1 DD 27 02    1739**  			LD	HL,(IX+2)		; Address of the string (24-bit)
0B15C4             1740**  ;
0B15C4 7B          1741**  			LD      A,E             	; E : Length of string in ACCS (as passed to the function)
0B15C5 D9          1742**  			EXX
0B15C6 6F          1743**  			LD      L,A			; L': Length of string currently stored on the stack
0B15C7 7C          1744**  			LD      A,H             	; H': The maximum (original) string length
0B15C8 D9          1745**  			EXX
0B15C9 BB          1746**  			CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
0B15CA 30 17       1747**  			JR      NC,STORS1       	; Yes there is, so skip the next bit
0B15CC             1748**  ;
0B15CC             1749**  ; At this point we're either initialising a new string or assigning more memory to an existing string
0B15CC             1750**  ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
0B15CC             1751**  ; then the existing and new strings may both exist in memory.
0B15CC             1752**  ;
0B15CC D9          1753**  			EXX
0B15CD 65          1754**  			LD      H,L			; H: Set the maximum string length to the string length
0B15CE D9          1755**  			EXX
0B15CF E5          1756**  			PUSH    HL
0B15D0 01 00 00 00 1757**  			LD	BC, 0
0B15D4 4F          1758**  			LD      C,A			; BC: The maximum (original) string length
0B15D5 09          1759**  			ADD     HL,BC			; Work out whether this is the last string in memory
0B15D6 ED 4B 1D 4C 1760**  			LD      BC,(FREE)
       0B          
0B15DB ED 42       1761**  			SBC     HL,BC			; Is string last?
0B15DD E1          1762**  			POP     HL
0B15DE 37          1763**  			SCF
0B15DF 28 02       1764**  			JR      Z,STORS1
0B15E1             1765**  			; LD	HL, BC			; HL=BC
0B15E1 C5          1766**  			push bc
0B15E2 E1          1767**  			pop hl
0B15E3             1768**  ;
0B15E3             1769**  ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
0B15E3             1770**  ; - H': The maximum (original) string length
0B15E3             1771**  ; - L': The actual string length (must be less than H')
0B15E3             1772**  ; - HL: Address of the string in memory
0B15E3             1773**  ;
0B15E3 D9          1774**  STORS1:			EXX				; This block was a call to STORE4
0B15E4 DD 75 00    1775**  			LD      (IX+0),L		; The actual string length (must be less then H')
0B15E7 DD 74 01    1776**  			LD      (IX+1),H		; The maximum (original) string length
0B15EA D9          1777**  			EXX
0B15EB DD 2F 02    1778**  			LD	(IX+2),HL		; The pointer to the original string
0B15EE             1779**  ;
0B15EE 01 00 00 00 1780**  			LD	BC, 0
0B15F2 4B          1781**  			LD      C,E			; BC: The new string length
0B15F3 EB          1782**  			EX      DE,HL
0B15F4 E1          1783**  			POP     HL
0B15F5 0D          1784**  			DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
0B15F6 0C          1785**  			INC     C			; check whether BC is 0 without affecting the carry flag
0B15F7 C8          1786**  			RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
0B15F8 ED B0       1787**  			LDIR				; Replace the string in memory
0B15FA D0          1788**  			RET     NC
0B15FB ED 53 1D 4C 1789**  			LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
       0B          
0B1600             1790**  ;
0B1600             1791**  ; Check whether the stack is full
0B1600             1792**  ;
0B1600 E5          1793**  CHECK:			PUSH    HL
0B1601 C5          1794**  			PUSH	BC
0B1602 2A 1D 4C 0B 1795**  			LD      HL,(FREE)		; HL: Address of first free space byte
0B1606 01 00 01 00 1796**  			LD	BC,100h			; BC: One page of memory
0B160A 09          1797**  			ADD	HL,BC			; Add a page to FREE
0B160B ED 72       1798**  			SBC     HL,SP			; And subtract the current SP
0B160D C1          1799**  			POP	BC
0B160E E1          1800**  			POP     HL
0B160F D8          1801**  			RET     C			; The SP is not in the same page, so just return
0B1610 AF          1802**  			XOR     A			; Otherwise
0B1611 C3 11 37 0B 1803**  			JP      ERROR_			; Throw error "No room"
0B1615             1804**  ;
0B1615 01 00 00 00 1805**  STORS3:			LD	BC,0
0B1619 4B          1806**  			LD      C,E			; BC: String length
0B161A DD E5       1807**  			PUSH    IX
0B161C D1          1808**  			POP     DE			; DE: Destination
0B161D AF          1809**  			XOR     A			; Check if string length is 0
0B161E B9          1810**  			CP      C
0B161F 28 02       1811**  			JR      Z,STORS5		; Yes, so don't copy
0B1621 ED B0       1812**  			LDIR
0B1623 3E 0D       1813**  STORS5:			LD      A,CR			; Finally add the terminator
0B1625 12          1814**  			LD      (DE),A
0B1626 C9          1815**  			RET
0B1627             1816**  
0B1627             1817**  ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
0B1627             1818**  ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
0B1627             1819**  ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
0B1627             1820**  ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
0B1627             1821**  ;    Inputs: DE addresses parameter list
0B1627             1822**  ;            IY addresses dummy variable list
0B1627             1823**  ;   Outputs: DE,IY updated
0B1627             1824**  ;  Destroys: Everything
0B1627             1825**  ;
0B1627 3E FF       1826**  ARGUE:			LD      A,-1
0B1629 F5          1827**  			PUSH    AF              	; Put marker on the stack
0B162A FD 23       1828**  ARGUE1:			INC     IY              	; Bump past '(' or ',''
0B162C 13          1829**  			INC     DE
0B162D D5          1830**  			PUSH    DE
0B162E CD 21 0A 0B 1831**  			CALL    NXT			; Skip any whitespace
0B1632 CD EB 39 0B 1832**  			CALL    GETVAR			; Get the location of the variable in HL/IX
0B1636 38 3F       1833**  			JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0B1638 C4 DA 39 0B 1834**  			CALL    NZ,PUTVAR
0B163C D1          1835**  			POP     DE
0B163D E5          1836**  			PUSH    HL              	; VARPTR
0B163E B7          1837**  			OR      A               	; Check the variable type
0B163F F5          1838**  			PUSH    AF
0B1640 D5          1839**  			PUSH    DE
0B1641 FD E3       1840**  			EX      (SP),IY
0B1643 FA 5B 16 0B 1841**  			JP      M,ARGUE2        	; Jump here if it is a string
0B1647             1842**  ;
0B1647 CD B3 02 0B 1843**  			CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0B164B FD E3       1844**  			EX      (SP),IY
0B164D D1          1845**  			POP     DE
0B164E F1          1846**  			POP     AF
0B164F D9          1847**  			EXX
0B1650 E5          1848**  			PUSH    HL
0B1651 D9          1849**  			EXX
0B1652 E5          1850**  			PUSH    HL
0B1653 47          1851**  			LD      B,A
0B1654 C5          1852**  			PUSH    BC
0B1655 CD 00 16 0B 1853**  			CALL    CHECK           	; Check room
0B1659 18 0F       1854**  			JR      ARGUE4
0B165B             1855**  ;
0B165B CD C6 02 0B 1856**  ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0B165F FD E3       1857**  			EX      (SP),IY
0B1661 D9          1858**  			EXX
0B1662 D1          1859**  			POP     DE
0B1663 D9          1860**  			EXX
0B1664 F1          1861**  			POP     AF
0B1665 CD 65 09 0B 1862**  			CALL    PUSHS
0B1669 D9          1863**  			EXX
0B166A             1864**  ;
0B166A CD 21 0A 0B 1865**  ARGUE4:			CALL    NXT			; Skip whitespace
0B166E FE 2C       1866**  			CP      ','			; Check to see if the next value is a comma
0B1670 20 0B       1867**  			JR      NZ,ARGUE5		; No, so jump here
0B1672 1A          1868**  			LD      A,(DE)
0B1673 FE 2C       1869**  			CP      ','			; Are there any more arguments?
0B1675 28 B3       1870**  			JR      Z,ARGUE1        	; Yes, so loop
0B1677             1871**  ;
0B1677 3E 1F       1872**  ARGERR:			LD      A,31
0B1679 C3 11 37 0B 1873**  			JP      ERROR_           	; Throw error "Arguments"
0B167D             1874**  ;
0B167D CD E0 09 0B 1875**  ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0B1681 1A          1876**  			LD      A,(DE)
0B1682 FE 29       1877**  			CP      ')'
0B1684 20 F1       1878**  			JR      NZ,ARGERR
0B1686 13          1879**  			INC     DE
0B1687 D9          1880**  			EXX
0B1688 C1          1881**  ARGUE6:			POP     BC
0B1689 78          1882**  			LD      A,B
0B168A 3C          1883**  			INC     A
0B168B D9          1884**  			EXX
0B168C C8          1885**  			RET     Z               	; Marker popped
0B168D D9          1886**  			EXX
0B168E 3D          1887**  			DEC     A
0B168F FA 9F 16 0B 1888**  			JP      M,ARGUE7        	; If it is a string, then jump here
0B1693 E1          1889**  			POP     HL
0B1694 D9          1890**  			EXX
0B1695 E1          1891**  			POP     HL
0B1696 D9          1892**  			EXX
0B1697 DD E1       1893**  			POP     IX
0B1699 CD 87 15 0B 1894**  			CALL    STORE	           	; Write to dummy variable
0B169D 18 E9       1895**  			JR      ARGUE6
0B169F             1896**  ;
0B169F CD 8F 09 0B 1897**  ARGUE7:			CALL    POPS
0B16A3 DD E1       1898**  			POP     IX
0B16A5 CD B1 15 0B 1899**  			CALL    STACCS
0B16A9 18 DD       1900**  			JR      ARGUE6
0B16AB             1901**  
0B16AB             1902**  ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
0B16AB             1903**  ;   OF A FUNCTION OR PROCEDURE.
0B16AB             1904**  ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
0B16AB             1905**  ;    Inputs: IY is parameters pointer
0B16AB             1906**  ;   Outputs: IY updated
0B16AB             1907**  ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
0B16AB             1908**  ;
0B16AB D1          1909**  SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
0B16AC             1910**  ;
0B16AC FD 23       1911**  SAVLO1:			INC     IY              	; Bump past '(' or ','
0B16AE CD 21 0A 0B 1912**  			CALL    NXT			; And also any whitespace
0B16B2 D5          1913**  			PUSH    DE			; Push the return address back onto the stack
0B16B3 D9          1914**  			EXX
0B16B4 C5          1915**  			PUSH    BC
0B16B5 D5          1916**  			PUSH    DE
0B16B6 E5          1917**  			PUSH    HL
0B16B7 D9          1918**  			EXX
0B16B8 CD 3F 0C 0B 1919**  			CALL    VAR_             	; Dummy variable
0B16BC D9          1920**  			EXX
0B16BD E1          1921**  			POP     HL
0B16BE D1          1922**  			POP     DE
0B16BF C1          1923**  			POP     BC
0B16C0 D9          1924**  			EXX
0B16C1 D1          1925**  			POP     DE
0B16C2 B7          1926**  			OR      A               	; Check the variable type
0B16C3 FA D6 16 0B 1927**  			JP      M,SAVLO2        	; 80h = string, so jump to save a local string
0B16C7 D9          1928**  			EXX
0B16C8 E5          1929**  			PUSH    HL              	; Save H'L'
0B16C9 D9          1930**  			EXX
0B16CA 47          1931**  			LD      B,A             	;  B: Variable type
0B16CB CD C7 03 0B 1932**  			CALL    LOADN
0B16CF D9          1933**  			EXX
0B16D0 E3          1934**  			EX      (SP),HL
0B16D1 D9          1935**  			EXX
0B16D2 E5          1936**  			PUSH    HL
0B16D3 C5          1937**  			PUSH    BC
0B16D4 18 2D       1938**  			JR      SAVLO4
0B16D6             1939**  ;
0B16D6 F5          1940**  SAVLO2:			PUSH    AF              	; Save the type (string)
0B16D7 D5          1941**  			PUSH    DE
0B16D8 D9          1942**  			EXX
0B16D9 E5          1943**  			PUSH    HL
0B16DA D9          1944**  			EXX
0B16DB CD 51 04 0B 1945**  			CALL    LOADS
0B16DF D9          1946**  			EXX
0B16E0 E1          1947**  			POP     HL
0B16E1 D9          1948**  			EXX
0B16E2 01 00 00 00 1949**  			LD	BC,0
0B16E6 4B          1950**  			LD      C,E			; BC: String length
0B16E7 D1          1951**  			POP     DE
0B16E8 CD 00 16 0B 1952**  			CALL    CHECK			; Check if there is space on the stack
0B16EC F1          1953**  			POP     AF              	; Level stack
0B16ED 21 00 00 00 1954**  			LD      HL,0
0B16F1 ED 42       1955**  			SBC     HL,BC			; HL: Number of bytes required on the stack for the string
0B16F3 39          1956**  			ADD     HL,SP			; Make space for the string on the stack
0B16F4 F9          1957**  			LD      SP,HL
0B16F5 47          1958**  			LD      B,A             	;  B: Variable type
0B16F6 C5          1959**  			PUSH    BC
0B16F7 28 0A       1960**  			JR      Z,SAVLO4
0B16F9 D5          1961**  			PUSH    DE
0B16FA 11 00 49 0B 1962**  			LD      DE,ACCS
0B16FE EB          1963**  			EX      DE,HL
0B16FF 45          1964**  			LD      B,L
0B1700 ED B0       1965**  			LDIR                    	; Save the string onto the stack
0B1702 D1          1966**  			POP     DE
0B1703             1967**  ;
0B1703 DD E5       1968**  SAVLO4:			PUSH    IX			; VARPTR
0B1705 CD 09 17 0B 1969**  			CALL    SAVLO5
0B1709             1970**  LOCCHK:			EQU     $
0B1709 CD 00 16 0B 1971**  SAVLO5:			CALL    CHECK
0B170D CD 21 0A 0B 1972**  			CALL    NXT
0B1711 FE 2C       1973**  			CP      ','             	; Are there any more local variables?
0B1713 28 97       1974**  			JR      Z,SAVLO1		; Yes, so loop
0B1715 EB          1975**  			EX      DE,HL			; DE -> HL: The return address
0B1716 E9          1976**  			JP      (HL)            	; And effectvely return
0B1717             1977**  ;
0B1717 FD 7E 00    1978**  DELIM:			LD      A,(IY)          	; Assembler delimiter
0B171A FE 20       1979**  			CP      ' '
0B171C C8          1980**  			RET     Z
0B171D FE 2C       1981**  			CP      ','
0B171F C8          1982**  			RET     Z
0B1720 FE 29       1983**  			CP      ')'
0B1722 C8          1984**  			RET     Z
0B1723 FE 3B       1985**  TERM:			CP      ';'             	; Assembler terminator
0B1725 C8          1986**  			RET     Z
0B1726 FE 5C       1987**  			CP      '\'
0B1728 C8          1988**  			RET     Z
0B1729 18 07       1989**  			JR      TERM0
0B172B             1990**  ;
0B172B CD 21 0A 0B 1991**  TERMQ:			CALL    NXT
0B172F FE 8B       1992**  			CP      ELSE_EX_
0B1731 D0          1993**  			RET     NC
0B1732 FE 3A       1994**  TERM0:			CP      ':'             	; Assembler seperator
0B1734 D0          1995**  			RET     NC
0B1735 FE 0D       1996**  			CP      CR
0B1737 C9          1997**  			RET
0B1738             1998**  ;
0B1738 CD 2B 17 0B 1999**  SPAN:			CALL    TERMQ
0B173C C8          2000**  			RET     Z
0B173D FD 23       2001**  			INC     IY
0B173F 18 F7       2002**  			JR      SPAN
0B1741             2003**  ;
0B1741             2004**  ; This snippet is used to check whether an expression is followed by an '=' symbol
0B1741             2005**  ;
0B1741 CD 21 0A 0B 2006**  EQUALS:			CALL    NXT			; Skip whitespace
0B1745 FD 23       2007**  			INC     IY			; Skip past the character in question
0B1747 FE 3D       2008**  			CP      '='			; Is it '='
0B1749 C8          2009**  			RET     Z			; Yes, so return
0B174A 3E 04       2010**  			LD      A,4			; Otherwise
0B174C C3 11 37 0B 2011**  			JP      ERROR_           	; Throw error "Mistake"
0B1750             2012**  ;
0B1750 FE 8A       2013**  FORMAT:			CP      TAB
0B1752 28 0D       2014**  			JR      Z,DOTAB
0B1754 FE 89       2015**  			CP      SPC
0B1756 28 40       2016**  			JR      Z,DOSPC
0B1758 FE 27       2017**  			CP      '''
0B175A C0          2018**  			RET     NZ
0B175B CD F8 38 0B 2019**  			CALL    CRLF
0B175F AF          2020**  			XOR     A
0B1760 C9          2021**  			RET
0B1761             2022**  ;
0B1761 C5          2023**  DOTAB:			PUSH    BC
0B1762 CD BB 02 0B 2024**  			CALL    EXPRI
0B1766 D9          2025**  			EXX
0B1767 C1          2026**  			POP     BC
0B1768 FD 7E 00    2027**  			LD      A,(IY)
0B176B FE 2C       2028**  			CP      ','
0B176D 28 14       2029**  			JR      Z,DOTAB1
0B176F CD E0 09 0B 2030**  			CALL    BRAKET
0B1773 7D          2031**  			LD      A,L
0B1774 21 3D 4C 0B 2032**  TABIT:			LD      HL,COUNT
0B1778 BE          2033**  			CP      (HL)
0B1779 C8          2034**  			RET     Z
0B177A F5          2035**  			PUSH    AF
0B177B DC F8 38 0B 2036**  			CALL    C,CRLF
0B177F F1          2037**  			POP     AF
0B1780 96          2038**  			SUB     (HL)
0B1781 18 1D       2039**  			JR      FILL
0B1783 FD 23       2040**  DOTAB1:			INC     IY
0B1785 C5          2041**  			PUSH    BC
0B1786 E5          2042**  			PUSH    HL
0B1787 CD BB 02 0B 2043**  			CALL    EXPRI
0B178B D9          2044**  			EXX
0B178C D1          2045**  			POP     DE
0B178D C1          2046**  			POP     BC
0B178E CD E0 09 0B 2047**  			CALL    BRAKET
0B1792 CD 72 3E 0B 2048**  			CALL    PUTCSR
0B1796 AF          2049**  			XOR     A
0B1797 C9          2050**  			RET
0B1798             2051**  ;
0B1798 C5          2052**  DOSPC:			PUSH    BC
0B1799 CD D6 02 0B 2053**  			CALL    ITEMI
0B179D D9          2054**  			EXX
0B179E 7D          2055**  			LD      A,L
0B179F C1          2056**  			POP     BC
0B17A0 B7          2057**  FILL:			OR      A
0B17A1 C8          2058**  			RET     Z
0B17A2 C5          2059**  			PUSH    BC
0B17A3 47          2060**  			LD      B,A
0B17A4 3E 20       2061**  FILL1:			LD      A,' '
0B17A6 CD 00 39 0B 2062**  			CALL    OUTCHR
0B17AA 10 F8       2063**  			DJNZ    FILL1
0B17AC C1          2064**  			POP     BC
0B17AD AF          2065**  			XOR     A
0B17AE C9          2066**  			RET
0B17AF             2067**  ;
0B17AF 21 00 49 0B 2068**  PTEXT:			LD      HL,ACCS
0B17B3 1C          2069**  			INC     E
0B17B4 1D          2070**  PTEXT1:			DEC     E
0B17B5 C8          2071**  			RET     Z
0B17B6 7E          2072**  			LD      A,(HL)
0B17B7 23          2073**  			INC     HL
0B17B8 CD 00 39 0B 2074**  			CALL    OUTCHR
0B17BC 18 F6       2075**  			JR      PTEXT1
0B17BE             2076**  ;
0B17BE F5          2077**  FETCHS:			PUSH    AF
0B17BF C5          2078**  			PUSH    BC
0B17C0 E5          2079**  			PUSH    HL
0B17C1 FD E3       2080**  			EX      (SP),IY
0B17C3 CD DE 17 0B 2081**  			CALL    XTRACT
0B17C7 CD 21 0A 0B 2082**  			CALL    NXT
0B17CB FD E3       2083**  			EX      (SP),IY
0B17CD E1          2084**  			POP     HL
0B17CE C1          2085**  			POP     BC
0B17CF F1          2086**  			POP     AF
0B17D0 C9          2087**  			RET
0B17D1             2088**  ;
0B17D1 11 00 49 0B 2089**  LINES:			LD      DE,ACCS
0B17D5 7E          2090**  LINE1S:			LD      A,(HL)
0B17D6 12          2091**  			LD      (DE),A
0B17D7 FE 0D       2092**  			CP      CR
0B17D9 C8          2093**  			RET     Z
0B17DA 23          2094**  			INC     HL
0B17DB 1C          2095**  			INC     E
0B17DC 18 F7       2096**  			JR      LINE1S
0B17DE             2097**  ;
0B17DE CD 21 0A 0B 2098**  XTRACT:			CALL    NXT
0B17E2 FE 22       2099**  			CP      '"'
0B17E4 FD 23       2100**  			INC     IY
0B17E6 CA 18 04 0B 2101**  			JP      Z,CONS
0B17EA FD 2B       2102**  			DEC     IY
0B17EC 11 00 49 0B 2103**  			LD      DE,ACCS
0B17F0 FD 7E 00    2104**  XTRAC1:			LD      A,(IY)
0B17F3 12          2105**  			LD      (DE),A
0B17F4 FE 2C       2106**  			CP      ','
0B17F6 C8          2107**  			RET     Z
0B17F7 FE 0D       2108**  			CP      CR
0B17F9 C8          2109**  			RET     Z
0B17FA FD 23       2110**  			INC     IY
0B17FC 1C          2111**  			INC     E
0B17FD 18 F1       2112**  			JR      XTRAC1
0B17FF             2113**  
0B17FF             2114**  ; Search for a token at the start of a program line
0B17FF             2115**  ; - HL: Pointer to the start of a tokenised line in the program area
0B17FF             2116**  ; Returns:
0B17FF             2117**  ; - HL: Pointer to the
0B17FF             2118**  ; -  F: Carry set if not found
0B17FF             2119**  ; Corrupts:
0B17FF             2120**  ; - BC
0B17FF             2121**  ;
0B17FF 01 00 00 00 2122**  SEARCH_EX:			LD      BC,0			; Clear BC
0B1803             2123**  ;
0B1803 4E          2124**  SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
0B1804 0C          2125**  			INC     C			; Check for 0, i.e. end of program marker
0B1805 0D          2126**  			DEC     C
0B1806 28 0B       2127**  			JR      Z,SRCH2_EX         	; Not found the token, so end
0B1808 23          2128**  			INC     HL			; Skip the line length and line number
0B1809 23          2129**  			INC     HL
0B180A 23          2130**  			INC     HL
0B180B BE          2131**  			CP      (HL)			; Compare with the token
0B180C C8          2132**  			RET     Z			; Found it, so return with carry not set
0B180D 0D          2133**  			DEC     C			; Skip to the next line
0B180E 0D          2134**  			DEC     C
0B180F 0D          2135**  			DEC     C
0B1810 09          2136**  			ADD     HL,BC
0B1811 18 F0       2137**  			JR      SRCH1_EX			; Rinse, lather and repeat
0B1813             2138**  ;
0B1813 2B          2139**  SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0B1814 37          2140**  			SCF				; And set the carry flag
0B1815 C9          2141**  			RET
0B1816             2142**  
0B1816             2143**  ; Multiply by 4 or 5
0B1816             2144**  ; This function is used to allocate space for dimensioned variables
0B1816             2145**  ; This is a 24-bit operation
0B1816             2146**  ; - DE: Number to multiple
0B1816             2147**  ; -  A: 04h (Integer) - takes up 4 bytes
0B1816             2148**  ;       05h (Float)   - takes up 5 bytes
0B1816             2149**  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
0B1816             2150**  ; Returns:
0B1816             2151**  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
0B1816             2152**  ; -  F: Carry if overflow
0B1816             2153**  ; Corrupts:
0B1816             2154**  ; - HL
0B1816 FE 04       2155**  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0B1818             2156**  			; LD	HL,DE
0B1818 D5          2157**  			push de
0B1819 E1          2158**  			pop hl
0B181A 29          2159**  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0B181B D8          2160**  			RET     C			; Exit if overflow
0B181C 29          2161**  			ADD     HL,HL			; Multiply by 2 again
0B181D D8          2162**  			RET     C			; Exit if overflow
0B181E EB          2163**  			EX      DE,HL			; DE: Product
0B181F C8          2164**  			RET     Z			; Exit if A = 4
0B1820 19          2165**  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0B1821 EB          2166**  			EX      DE,HL			; DE: Product
0B1822 C9          2167**  			RET
0B1823             2168**  
0B1823             2169**  ; 16-bit unsigned multiply
0B1823             2170**  ; - HL: Operand 1
0B1823             2171**  ; - BC: Operand 2
0B1823             2172**  ; Returns:
0B1823             2173**  ; - HL: Result
0B1823             2174**  ; -  F: C if overflow
0B1823             2175**  ;
0B1823 C5          2176**  MUL16:			PUSH	BC
0B1824 51          2177**  			LD	D, C			; Set up the registers for the multiplies
0B1825 5D          2178**  			LD	E, L
0B1826 69          2179**  			LD	L, C
0B1827 4B          2180**  			LD	C, E
0B1828 ED 6C       2181**  			MLT	HL			; HL = H * C (*256)
0B182A ED 5C       2182**  			MLT	DE			; DE = L * C
0B182C ED 4C       2183**  			MLT	BC			; BC = B * L (*256)
0B182E 09          2184**  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0B182F C1          2185**  			POP	BC
0B1830 AF          2186**  			XOR	A
0B1831 9C          2187**  			SBC	H			; If H is not zero then it's an overflow
0B1832 D8          2188**  			RET	C
0B1833 65          2189**  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0B1834 6F          2190**  			LD	L, A
0B1835 19          2191**  			ADD	HL, DE
0B1836 C9          2192**  			RET
0B1837             2193**  ;
0B1837 CD 21 0A 0B 2194**  CHANEL:			CALL    NXT			; Skip whitespace
0B183B FE 23       2195**  			CP      '#'			; Check for the '#' symbol
0B183D 3E 2D       2196**  			LD      A,45
0B183F C2 11 37 0B 2197**  			JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0B1843 FD 23       2198**  CHNL:			INC     IY             		; Bump past the '#'
0B1845 CD D6 02 0B 2199**  			CALL    ITEMI			; Get the channel number
0B1849 D9          2200**  			EXX
0B184A EB          2201**  			EX      DE,HL			; DE: The channel number
0B184B C9          2202**  			RET
0B184C             2203**  
0B184C             2204**  ; ASSEMBLER -------------------------------------------------------------------
0B184C             2205**  
0B184C             2206**  ; Language independant control section:
0B184C             2207**  ;  Outputs: A=delimiter, carry set if syntax error.
0B184C             2208**  ;
0B184C CD 66 1D 0B 2209**  ASSEM:			CALL    SKIP
0B1850 FD 23       2210**  			INC     IY
0B1852 FE 3A       2211**  			CP      ':'
0B1854 28 F6       2212**  			JR      Z,ASSEM
0B1856 FE 5D       2213**  			CP      ']'
0B1858 C8          2214**  			RET     Z
0B1859 FE 0D       2215**  			CP      CR
0B185B C8          2216**  			RET     Z
0B185C FD 2B       2217**  			DEC     IY
0B185E DD 2A 40 4B 2218**  			LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
       0B          
0B1863 21 40 4C 0B 2219**  			LD      HL,LISTON
0B1867 CB 76       2220**  			BIT     6,(HL)
0B1869 28 05       2221**  			JR      Z,ASSEM0
0B186B DD 2A 3C 4B 2222**  			LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
       0B          
0B1870 DD E5       2223**  ASSEM0:			PUSH    IX
0B1872 FD E5       2224**  			PUSH    IY
0B1874 CD 24 19 0B 2225**  			CALL    ASMB
0B1878 C1          2226**  			POP     BC
0B1879 D1          2227**  			POP     DE
0B187A D8          2228**  			RET     C
0B187B CD 66 1D 0B 2229**  			CALL    SKIP
0B187F 37          2230**  			SCF
0B1880 C0          2231**  			RET     NZ
0B1881 FD 2B       2232**  			DEC     IY
0B1883 FD 23       2233**  ASSEM3:			INC     IY
0B1885 FD 7E 00    2234**  			LD      A,(IY)
0B1888 CD 32 17 0B 2235**  			CALL    TERM0
0B188C 20 F5       2236**  			JR      NZ,ASSEM3
0B188E 3A 40 4C 0B 2237**  			LD      A,(LISTON)
0B1892 DD E5       2238**  			PUSH    IX
0B1894 E1          2239**  			POP     HL
0B1895 B7          2240**  			OR      A
0B1896 ED 52       2241**  			SBC     HL,DE
0B1898 EB          2242**  			EX      DE,HL           	; DE: Number of bytes
0B1899 E5          2243**  			PUSH    HL
0B189A 2A 40 4B 0B 2244**  			LD      HL,(PC)
0B189E E5          2245**  			PUSH    HL
0B189F 19          2246**  			ADD     HL,DE
0B18A0 22 40 4B 0B 2247**  			LD      (PC),HL         	; Update PC
0B18A4 CB 77       2248**  			BIT     6,A
0B18A6 28 09       2249**  			JR      Z,ASSEM5
0B18A8 2A 3C 4B 0B 2250**  			LD      HL,(OC)
0B18AC 19          2251**  			ADD     HL,DE
0B18AD 22 3C 4B 0B 2252**  			LD      (OC),HL         	; Update OC
0B18B1 E1          2253**  ASSEM5:			POP     HL              	; Old PC
0B18B2 DD E1       2254**  			POP     IX              	; Code here
0B18B4 CB 67       2255**  			BIT     4,A
0B18B6 28 94       2256**  			JR      Z,ASSEM
0B18B8 22 4A 4C 0B 2257**  			LD	(R0),HL			; Store HL in R0 so we can access the MSB
0B18BC 3A 4C 4C 0B 2258**  			LD	A,(R0+2)		; Print out the address
0B18C0 CD 0E 19 0B 2259**  			CALL	HEX_EX
0B18C4 7C          2260**  			LD      A,H
0B18C5 CD 0E 19 0B 2261**  			CALL    HEX_EX
0B18C9 7D          2262**  			LD      A,L
0B18CA CD 06 19 0B 2263**  			CALL    HEXSP
0B18CE AF          2264**  			XOR     A
0B18CF BB          2265**  			CP      E
0B18D0 28 18       2266**  			JR      Z,ASSEM2
0B18D2             2267**  ;
0B18D2 3A 3D 4C 0B 2268**  ASSEM1:			LD      A,(COUNT)
0B18D6 FE 14       2269**  			CP      20
0B18D8 3E 07       2270**  			LD      A,7
0B18DA D4 74 17 0B 2271**  			CALL    NC,TABIT        	; Next line
0B18DE DD 7E 00    2272**  			LD      A,(IX)
0B18E1 CD 06 19 0B 2273**  			CALL    HEXSP
0B18E5 DD 23       2274**  			INC     IX
0B18E7 1D          2275**  			DEC     E
0B18E8 20 E8       2276**  			JR      NZ,ASSEM1
0B18EA             2277**  ;
0B18EA 3E 16       2278**  ASSEM2:			LD      A,22			; Tab to the disassembly field
0B18EC CD 74 17 0B 2279**  			CALL    TABIT
0B18F0 FD E5       2280**  			PUSH    IY
0B18F2 E1          2281**  			POP     HL
0B18F3 ED 42       2282**  			SBC     HL,BC
0B18F5 0A          2283**  ASSEM4:			LD      A,(BC)
0B18F6 CD 1D 39 0B 2284**  			CALL    OUT_
0B18FA 03          2285**  			INC     BC
0B18FB 2D          2286**  			DEC     L
0B18FC 20 F7       2287**  			JR      NZ,ASSEM4
0B18FE CD F8 38 0B 2288**  			CALL    CRLF
0B1902 C3 4C 18 0B 2289**  			JP      ASSEM
0B1906             2290**  ;
0B1906 CD 0E 19 0B 2291**  HEXSP:			CALL    HEX_EX
0B190A 3E 20       2292**  			LD      A,' '
0B190C 18 12       2293**  			JR      OUTCH1
0B190E F5          2294**  HEX_EX:			PUSH    AF
0B190F 0F          2295**  			RRCA
0B1910 0F          2296**  			RRCA
0B1911 0F          2297**  			RRCA
0B1912 0F          2298**  			RRCA
0B1913 CD 18 19 0B 2299**  			CALL    HEXOUT
0B1917 F1          2300**  			POP     AF
0B1918 E6 0F       2301**  HEXOUT:			AND     0FH
0B191A C6 90       2302**  			ADD     A,90H
0B191C 27          2303**  			DAA
0B191D CE 40       2304**  			ADC     A,40H
0B191F 27          2305**  			DAA
0B1920 C3 1D 39 0B 2306**  OUTCH1:			JP      OUT_
0B1924             2307**  
0B1924             2308**  ; Processor Specific Translation Section:
0B1924             2309**  ;
0B1924             2310**  ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
0B1924             2311**  ;                 C: Opcode beig built
0B1924             2312**  ;                 D: Flags
0B1924             2313**  ;			Bit 7: Set to 1 if the instruction uses long addressing
0B1924             2314**  ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
0B1924             2315**  ;                 E: Offset from IX or IY
0B1924             2316**  ;                HL: Numeric operand value
0B1924             2317**  ;                IX: Code destination pointer
0B1924             2318**  ;                IY: Source text pointer
0B1924             2319**  ;    Inputs: A = initial character
0B1924             2320**  ;   Outputs: Carry set if syntax error.
0B1924             2321**  ;
0B1924 FE 2E       2322**  ASMB:			CP      '.'			; Check for a dot; this indicates a label
0B1926 20 1F       2323**  			JR      NZ,ASMB1		; No, so just process the instruction
0B1928 FD 23       2324**  			INC     IY			; Skip past the dot to the label name
0B192A DD E5       2325**  			PUSH    IX			; Store the code destination pointer
0B192C CD 3F 0C 0B 2326**  			CALL    VAR_			; Create a variable
0B1930 F5          2327**  			PUSH    AF
0B1931 CD 44 09 0B 2328**  			CALL    ZERO			; Zero it
0B1935 3A 42 4B 0B 2329**  			LD	A,(PC+2)
0B1939 6F          2330**  			LD	L,A			; The MSB of the 24-bit address
0B193A D9          2331**  			EXX
0B193B 2A 40 4B 0B 2332**  			LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0B193F D9          2333**  			EXX
0B1940 F1          2334**  			POP     AF
0B1941 CD 87 15 0B 2335**  			CALL    STORE			; Store the program counter
0B1945 DD E1       2336**  			POP     IX			; Restore the code destination pointer
0B1947             2337**  ;
0B1947 3A 40 4C 0B 2338**  ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0B194B E6 80       2339**  			AND	80H
0B194D 57          2340**  			LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0B194E CD 66 1D 0B 2341**  			CALL    SKIP			; Skip any whitespace
0B1952 C8          2342**  			RET     Z			; And return if there is nothing further to process
0B1953 FE D6       2343**  			CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0B1955 0E C4       2344**  			LD      C,0C4H			;  A: The base operand
0B1957 FD 23       2345**  			INC     IY			; Skip past the token
0B1959 CA 9B 1A 0B 2346**  			JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0B195D FD 2B       2347**  			DEC     IY			; Skip back, as we're not doing the above at this point
0B195F 21 7D 1D 0B 2348**  			LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0B1963 CD 15 1D 0B 2349**  			CALL    FIND			; Find the opcode
0B1967 D8          2350**  			RET     C			; If not found, then return; carry indicates an error condition
0B1968 48          2351**  			LD      C,B     		;  C: A copy of the opcode
0B1969             2352**  ;
0B1969             2353**  ; GROUP 0: Trivial cases requiring no computation
0B1969             2354**  ; GROUP 1: As Group 0, but with "ED" prefix
0B1969             2355**  ;
0B1969 D6 44       2356**  			SUB     68			; The number of opcodes in GROUP0 and GROUP1
0B196B 30 08       2357**  			JR      NC,GROUP02		; If not in that range, then check GROUP2
0B196D FE CB       2358**  			CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0B196F D4 6E 1C 0B 2359**  			CALL    NC,ED			; Needs to be prefixed with ED
0B1973 18 76       2360**  			JR      BYTE0			; Then write the opcode byte
0B1975             2361**  ;
0B1975             2362**  ; GROUP 2: BIT, RES, SET
0B1975             2363**  ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
0B1975             2364**  ;
0B1975 D6 0A       2365**  GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0B1977 30 12       2366**  			JR      NC,GROUP04		; If not in that range, then check GROUP4
0B1979 FE F9       2367**  			CP      3-10			;
0B197B DC 03 1D 0B 2368**  			CALL    C,BIT_
0B197F D8          2369**  			RET     C
0B1980 CD D4 1C 0B 2370**  			CALL    REGLO
0B1984 D8          2371**  			RET     C
0B1985 CD 72 1C 0B 2372**  			CALL    CB
0B1989 18 60       2373**  			JR      BYTE0
0B198B             2374**  ;
0B198B             2375**  ; GROUP 4 - PUSH, POP, EX (SP)
0B198B             2376**  ;
0B198B D6 03       2377**  GROUP04:		SUB     3			; The number of opcodes in GROUP4
0B198D 30 07       2378**  			JR      NC,GROUP05		; If not in that range, then check GROUP5
0B198F CD F6 1C 0B 2379**  GROUP04_1:		CALL    PAIR_EX
0B1993 D8          2380**  			RET     C
0B1994 18 55       2381**  			JR      BYTE0
0B1996             2382**  ;
0B1996             2383**  ; GROUP 5 - SUB, AND, XOR, OR, CP
0B1996             2384**  ; GROUP 6 - ADD, ADC, SBC
0B1996             2385**  ;
0B1996 D6 0A       2386**  GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0B1998 30 39       2387**  			JR      NC,GROUP07
0B199A FE FD       2388**  			CP      5-8
0B199C 06 07       2389**  			LD      B,7
0B199E D4 82 1C 0B 2390**  			CALL    NC,OPND			; Get the first operand
0B19A2 78          2391**  			LD      A,B
0B19A3 FE 07       2392**  			CP      7			; Is the operand 'A'?
0B19A5 20 15       2393**  			JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0B19A7             2394**  ;
0B19A7 CD D4 1C 0B 2395**  GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0B19AB 79          2396**  			LD      A,C
0B19AC 30 2E       2397**  			JR      NC,BIND1		; If it is a register, then write that out
0B19AE EE 46       2398**  			XOR     46H			; Handle ADD A,n
0B19B0 CD 74 1C 0B 2399**  			CALL    BIND
0B19B4 CD B4 1C 0B 2400**  DB_:			CALL    NUMBER
0B19B8 C3 6D 1A 0B 2401**  			JP      VAL8
0B19BC             2402**  ;
0B19BC E6 3F       2403**  GROUP05_HL:		AND     3FH
0B19BE FE 0C       2404**  			CP      12
0B19C0 37          2405**  			SCF
0B19C1 C0          2406**  			RET     NZ
0B19C2 79          2407**  			LD      A,C
0B19C3 FE 80       2408**  			CP      80H
0B19C5 0E 09       2409**  			LD      C,9
0B19C7 28 C6       2410**  			JR      Z,GROUP04_1
0B19C9 EE 1C       2411**  			XOR     1CH
0B19CB 0F          2412**  			RRCA
0B19CC 4F          2413**  			LD      C,A
0B19CD CD 6E 1C 0B 2414**  			CALL    ED
0B19D1 18 BC       2415**  			JR      GROUP04_1
0B19D3             2416**  ;
0B19D3             2417**  ; GROUP 7 - INC, DEC
0B19D3             2418**  ;
0B19D3 D6 02       2419**  GROUP07:		SUB     2			; The number of opcodes in GROUP7
0B19D5 30 19       2420**  			JR      NC,GROUP08
0B19D7 CD DB 1C 0B 2421**  			CALL    REGHI
0B19DB 79          2422**  			LD      A,C
0B19DC D2 74 1C 0B 2423**  BIND1:			JP      NC,BIND
0B19E0 EE 64       2424**  			XOR     64H
0B19E2 07          2425**  			RLCA
0B19E3 07          2426**  			RLCA
0B19E4 07          2427**  			RLCA
0B19E5 4F          2428**  			LD      C,A
0B19E6 CD FB 1C 0B 2429**  			CALL    PAIR1_EX
0B19EA D8          2430**  			RET     C
0B19EB 79          2431**  BYTE0:			LD      A,C
0B19EC C3 A3 1C 0B 2432**  			JP      BYTE_
0B19F0             2433**  ;
0B19F0             2434**  ; Group 8: IN0, OUT0
0B19F0             2435**  ;
0B19F0 D6 02       2436**  GROUP08:		SUB	2			; The number of opcodes in GROUP8
0B19F2 30 26       2437**  			JR	NC,GROUP09
0B19F4 FE FF       2438**  			CP	1-2
0B19F6 CC B4 1C 0B 2439**  			CALL    Z,NUMBER		; Fetch number first if OUT
0B19FA 08          2440**  			EX      AF,AF'			; Save flags
0B19FB CD C8 1C 0B 2441**  			CALL    REG			; Get the register value regardless
0B19FF D8          2442**  			RET     C			; Return if not a register
0B1A00 08          2443**  			EX      AF,AF'			; Restore the flags
0B1A01 DC B4 1C 0B 2444**  			CALL    C,NUMBER		; Fetch number last if IN
0B1A05 78          2445**  			LD	A,B			; Get the register number
0B1A06 FE 06       2446**  			CP	6			; Fail on (HL)
0B1A08 37          2447**  			SCF
0B1A09 C8          2448**  			RET	Z
0B1A0A FE 08       2449**  			CP	8			; Check it is just single pairs only
0B1A0C 3F          2450**  			CCF
0B1A0D D8          2451**  			RET	C			; And return if it is an invalid register
0B1A0E 07          2452**  			RLCA				; Bind with the operand
0B1A0F 07          2453**  			RLCA
0B1A10 07          2454**  			RLCA
0B1A11 81          2455**  			ADD	A,C
0B1A12             2456**  ; BEGIN NOT IN BINARY
0B1A12             2457**  			; LD	C,A
0B1A12             2458**  			; CALL	ED			; Prefix with ED
0B1A12             2459**  			; LD	A,C
0B1A12             2460**  ; END NOT IN BINARY
0B1A12 CD A3 1C 0B 2461**  			CALL	BYTE_			; Write out the operand
0B1A16 C3 6D 1A 0B 2462**  			JP	VAL8			; Write out the value
0B1A1A             2463**  ;
0B1A1A             2464**  ; GROUP 9 - IN
0B1A1A             2465**  ; GROUP 10 - OUT
0B1A1A             2466**  ;
0B1A1A D6 02       2467**  GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
0B1A1C 30 25       2468**  			JR      NC,GROUP11
0B1A1E FE FF       2469**  			CP      1-2			; Check if Group 9 or Group 1
0B1A20 CC 62 1C 0B 2470**  			CALL    Z,CORN			; Call CORN if Group 10 (OUT)
0B1A24 08          2471**  			EX      AF,AF'			; Save flags
0B1A25 CD DB 1C 0B 2472**  			CALL    REGHI			; Get the register value regardless
0B1A29 D8          2473**  			RET     C			; Return if not a register
0B1A2A 08          2474**  			EX      AF,AF'			; Restore the flags
0B1A2B DC 62 1C 0B 2475**  			CALL    C,CORN			; Call CORN if Group 9 (IN)
0B1A2F 24          2476**  			INC     H			; If it is IN r,(C) or OUT (C),r then
0B1A30 28 B9       2477**  			JR      Z,BYTE0			; Just write the operand out
0B1A32             2478**  ;
0B1A32 78          2479**  			LD      A,B			; Check the register
0B1A33 FE 07       2480**  			CP      7
0B1A35 37          2481**  			SCF
0B1A36 C0          2482**  			RET     NZ			; If it is not A, then return
0B1A37             2483**  ;
0B1A37 79          2484**  			LD      A,C			; Bind the register with the operand
0B1A38 EE 03       2485**  			XOR     3
0B1A3A 07          2486**  			RLCA
0B1A3B 07          2487**  			RLCA
0B1A3C 07          2488**  			RLCA
0B1A3D CD A3 1C 0B 2489**  			CALL    BYTE_			; Write out the operand
0B1A41 18 2A       2490**  			JR      VAL8			; And the value
0B1A43             2491**  ;
0B1A43             2492**  ; GROUP 11 - JR, DJNZ
0B1A43             2493**  ;
0B1A43 D6 02       2494**  GROUP11:		SUB     2			; The number of opcodes in GROUP11
0B1A45 30 2B       2495**  			JR      NC,GROUP12
0B1A47 FE FF       2496**  			CP      1-2
0B1A49 C4 E2 1C 0B 2497**  			CALL    NZ,COND_
0B1A4D 79          2498**  			LD      A,C
0B1A4E 30 02       2499**  			JR      NC,@F
0B1A50 3E 18       2500**  			LD      A,18H
0B1A52 CD A3 1C 0B 2501**  @@:			CALL    BYTE_
0B1A56 CD B4 1C 0B 2502**  			CALL    NUMBER
0B1A5A ED 5B 40 4B 2503**  			LD      DE,(PC)
       0B          
0B1A5F 13          2504**  			INC     DE
0B1A60 37          2505**  			SCF
0B1A61 ED 52       2506**  			SBC     HL,DE
0B1A63 7D          2507**  			LD      A,L
0B1A64 17          2508**  			RLA
0B1A65 9F          2509**  			SBC     A,A
0B1A66 BC          2510**  			CP      H
0B1A67 3E 01       2511**  TOOFAR:			LD      A,1
0B1A69 C2 11 37 0B 2512**  			JP      NZ,ERROR_		; Throw an "Out of range" error
0B1A6D 7D          2513**  VAL8:			LD      A,L
0B1A6E C3 A3 1C 0B 2514**  			JP      BYTE_
0B1A72             2515**  ;
0B1A72             2516**  ; GROUP 12 - JP
0B1A72             2517**  ;
0B1A72 D6 01       2518**  GROUP12:		SUB	1			; The number of opcodes in GROUP12
0B1A74 30 21       2519**  			JR	NC,GROUP13
0B1A76 CD C8 1B 0B 2520**  			CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
0B1A7A D8          2521**  			RET	C			; Exit if an invalid suffix is provided
0B1A7B CD E2 1C 0B 2522**  			CALL    COND_			; Evaluate the conditions
0B1A7F 79          2523**  			LD      A,C
0B1A80 30 0D       2524**  			JR      NC,GROUP12_1
0B1A82 78          2525**  			LD      A,B
0B1A83 E6 3F       2526**  			AND     3FH
0B1A85 FE 06       2527**  			CP      6
0B1A87 3E E9       2528**  			LD      A,0E9H
0B1A89 CA A3 1C 0B 2529**  			JP      Z,BYTE_
0B1A8D 3E C3       2530**  			LD      A,0C3H
0B1A8F CD A3 1C 0B 2531**  GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
0B1A93 C3 1D 1C 0B 2532**  			JP	ADDR_			; Output the address
0B1A97             2533**  ;
0B1A97             2534**  ; GROUP 13 - CALL
0B1A97             2535**  ;
0B1A97 D6 01       2536**  GROUP13:		SUB	1			; The number of opcodes in GROUP13
0B1A99 30 0C       2537**  			JR	NC,GROUP14
0B1A9B CD E0 1B 0B 2538**  GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
0B1A9F CD C2 1A 0B 2539**  			CALL    GROUP15_1		; Output the opcode (with conditions)
0B1AA3 C3 1D 1C 0B 2540**  			JP	ADDR_			; Output the address
0B1AA7             2541**  ;
0B1AA7             2542**  ; GROUP 14 - RST
0B1AA7             2543**  ;
0B1AA7 D6 01       2544**  GROUP14:		SUB	1			; The number of opcodes in GROUP14
0B1AA9 30 13       2545**  			JR	NC,GROUP15
0B1AAB CD E0 1B 0B 2546**  			CALL	EZ80SF_FULL		; Evaluate the suffix
0B1AAF D8          2547**  			RET	C			; Exit if an invalid suffix provided
0B1AB0 CD B4 1C 0B 2548**  			CALL    NUMBER
0B1AB4 A1          2549**  			AND     C
0B1AB5 B4          2550**  			OR      H
0B1AB6 20 AF       2551**  			JR      NZ,TOOFAR
0B1AB8 7D          2552**  			LD      A,L
0B1AB9 B1          2553**  			OR      C
0B1ABA C3 A3 1C 0B 2554**  	  		JP      BYTE_
0B1ABE             2555**  ;
0B1ABE             2556**  ; GROUP 15 - RET
0B1ABE             2557**  ;
0B1ABE D6 01       2558**  GROUP15:		SUB	1			; The number of opcodes in GROUP15
0B1AC0 30 0F       2559**  			JR	NC,GROUP16
0B1AC2 CD E2 1C 0B 2560**  GROUP15_1:		CALL    COND_
0B1AC6 79          2561**  			LD      A,C
0B1AC7 D2 A3 1C 0B 2562**  			JP      NC,BYTE_
0B1ACB F6 09       2563**  			OR      9
0B1ACD C3 A3 1C 0B 2564**  			JP      BYTE_
0B1AD1             2565**  ;
0B1AD1             2566**  ; GROUP 16 - LD
0B1AD1             2567**  ;
0B1AD1 D6 01       2568**  GROUP16:		SUB	1			; The number of opcodes in GROUP16
0B1AD3 30 74       2569**  			JR	NC,GROUP17
0B1AD5 CD E0 1B 0B 2570**  			CALL	EZ80SF_FULL		; Evaluate the suffix
0B1AD9 CD 11 1D 0B 2571**  			CALL    LDOP			; Check for accumulator loads
0B1ADD D2 3D 1C 0B 2572**  			JP      NC,LDA			; Yes, so jump here
0B1AE1 CD DB 1C 0B 2573**  			CALL    REGHI
0B1AE5 08          2574**  			EX      AF,AF'
0B1AE6 CD 66 1D 0B 2575**  			CALL    SKIP
0B1AEA FE 28       2576**  			CP      '('			; Check for bracket
0B1AEC 28 24       2577**  			JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
0B1AEE 08          2578**  			EX      AF,AF'
0B1AEF D2 A7 19 0B 2579**  			JP      NC,GROUP05_1		; Load single register direct; go here
0B1AF3 0E 01       2580**  			LD      C,1
0B1AF5 CD FB 1C 0B 2581**  			CALL    PAIR1_EX
0B1AF9 D8          2582**  			RET     C
0B1AFA 3E 0E       2583**  			LD      A,14
0B1AFC B8          2584**  			CP      B
0B1AFD 47          2585**  			LD      B,A
0B1AFE CC F6 1C 0B 2586**  			CALL    Z,PAIR_EX
0B1B02 78          2587**  			LD      A,B
0B1B03 E6 3F       2588**  			AND     3FH
0B1B05 FE 0C       2589**  			CP      12
0B1B07 79          2590**  			LD      A,C
0B1B08 C2 8F 1A 0B 2591**  			JP      NZ,GROUP12_1		; Load register pair direct; go here
0B1B0C 3E F9       2592**  			LD      A,0F9H
0B1B0E C3 A3 1C 0B 2593**  			JP      BYTE_
0B1B12             2594**  ;
0B1B12 08          2595**  LDIN:			EX      AF,AF'
0B1B13 C5          2596**  			PUSH    BC
0B1B14 D4 D4 1C 0B 2597**  			CALL    NC,REGLO
0B1B18 79          2598**  			LD      A,C
0B1B19 C1          2599**  			POP     BC
0B1B1A D2 74 1C 0B 2600**  			JP      NC,BIND
0B1B1E 0E 0A       2601**  			LD      C,0AH
0B1B20 CD FB 1C 0B 2602**  			CALL    PAIR1_EX
0B1B24 CD 48 1C 0B 2603**  			CALL    LD16
0B1B28 D2 8F 1A 0B 2604**  			JP      NC,GROUP12_1
0B1B2C CD B4 1C 0B 2605**  			CALL    NUMBER
0B1B30 0E 02       2606**  			LD      C,2
0B1B32 CD F6 1C 0B 2607**  			CALL    PAIR_EX
0B1B36 CD 48 1C 0B 2608**  			CALL    LD16
0B1B3A D8          2609**  			RET     C
0B1B3B CD A3 1C 0B 2610**  			CALL    BYTE_
0B1B3F CB 7A       2611**  			BIT	7,D			; Check the ADL flag
0B1B41 C2 32 1C 0B 2612**  			JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
0B1B45 C3 25 1C 0B 2613**  			JP      VAL16			; Otherwise use 16-bit addresses
0B1B49             2614**  ;
0B1B49             2615**  ; Group 17 - TST
0B1B49             2616**  ;
0B1B49 D6 01       2617**  GROUP17:		SUB	1			; The number of opcodes in GROUP17
0B1B4B 30 25       2618**  			JR	NC,OPTS
0B1B4D CD 6E 1C 0B 2619**  			CALL	ED			; Needs to be prefixed with ED
0B1B51 CD C8 1C 0B 2620**  			CALL	REG			; Fetch the register
0B1B55 30 0E       2621**  			JR	NC,GROUP17_1		; It's just a register
0B1B57             2622**  ;
0B1B57 3E 64       2623**  			LD	A,64H			; Opcode for TST n
0B1B59 CD A3 1C 0B 2624**  			CALL	BYTE_			; Write out the opcode
0B1B5D CD B4 1C 0B 2625**  			CALL	NUMBER			; Get the number
0B1B61 C3 6D 1A 0B 2626**  			JP	VAL8			; And write that out
0B1B65             2627**  ;
0B1B65 78          2628**  GROUP17_1:		LD	A,B			; Check the register rangs
0B1B66 FE 08       2629**  			CP	8
0B1B68 3F          2630**  			CCF
0B1B69 D8          2631**  			RET	C			; Ret with carry flag set for error if out of range
0B1B6A 07          2632**  			RLCA				; Get the opcode value
0B1B6B 07          2633**  			RLCA
0B1B6C 07          2634**  			RLCA
0B1B6D 81          2635**  			ADD	A,C			; Add the opcode base in
0B1B6E C3 A3 1C 0B 2636**  			JP	BYTE_
0B1B72             2637**  
0B1B72             2638**  ;
0B1B72             2639**  ; Assembler directives - OPT, ADL
0B1B72             2640**  ;
0B1B72 D6 02       2641**  OPTS:			SUB	2
0B1B74 30 2B       2642**  			JR	NC, DEFS
0B1B76 FE FF       2643**  			CP	1-2			; Check for ADL opcode
0B1B78 28 13       2644**  			JR	Z, ADL_
0B1B7A             2645**  ;
0B1B7A CD B4 1C 0B 2646**  OPT:			CALL    NUMBER			; Fetch the OPT value
0B1B7E 21 40 4C 0B 2647**  			LD      HL,LISTON		; Address of the LISTON/OPT flag
0B1B82 E6 07       2648**  			AND	7			; Only interested in the first three bits
0B1B84 4F          2649**  			LD      C,A			; Store the new OPT value in C
0B1B85 ED 6F       2650**  			RLD				; Shift the top nibble of LISTON (OPT) into A
0B1B87 E6 08       2651**  			AND	8			; Clear the bottom three bits, preserving the ADL bit
0B1B89 B1          2652**  			OR	C			; OR in the new value
0B1B8A ED 67       2653**  			RRD				; And shift the nibble back in
0B1B8C C9          2654**  			RET
0B1B8D             2655**  ;
0B1B8D CD B4 1C 0B 2656**  ADL_:			CALL	NUMBER			; Fetch the ADL value
0B1B91 E6 01       2657**  			AND	1			; Only interested if it is 0 or 1
0B1B93 0F          2658**  			RRCA				; Rotate to bit 7
0B1B94 4F          2659**  			LD	C,A			; Store in C
0B1B95 3A 40 4C 0B 2660**  			LD	A,(LISTON)		; Get the LISTON system variable
0B1B99 E6 7F       2661**  			AND	7Fh			; Clear bit 7
0B1B9B B1          2662**  			OR	C			; OR in the ADL value
0B1B9C 32 40 4C 0B 2663**  			LD	(LISTON),A		; Store
0B1BA0 C9          2664**  			RET
0B1BA1             2665**  ;
0B1BA1             2666**  ; DEFB, DEFW, DEFL, DEFM
0B1BA1             2667**  ;
0B1BA1 B7          2668**  DEFS:			OR	A			; Handle DEFB
0B1BA2 CA B4 19 0B 2669**  			JP	Z, DB_
0B1BA6 3D          2670**  			DEC	A			; Handle DEFW
0B1BA7 CA 21 1C 0B 2671**  			JP	Z, ADDR16
0B1BAB 3D          2672**  			DEC	A			; Handle DEFL
0B1BAC CA 2E 1C 0B 2673**  			JP	Z, ADDR24
0B1BB0             2674**  ;
0B1BB0 DD E5       2675**  			PUSH    IX			; Handle DEFM
0B1BB2 CD C6 02 0B 2676**  			CALL    EXPRS
0B1BB6 DD E1       2677**  			POP     IX
0B1BB8 21 00 49 0B 2678**  			LD      HL,ACCS
0B1BBC AF          2679**  @@:			XOR     A
0B1BBD BB          2680**  			CP      E
0B1BBE C8          2681**  			RET     Z
0B1BBF 7E          2682**  			LD      A,(HL)
0B1BC0 23          2683**  			INC     HL
0B1BC1 CD A3 1C 0B 2684**  			CALL    BYTE_
0B1BC5 1D          2685**  			DEC     E
0B1BC6 18 F4       2686**  			JR      @B
0B1BC8             2687**  
0B1BC8             2688**  ;
0B1BC8             2689**  ;SUBROUTINES:
0B1BC8             2690**  ;
0B1BC8 FD 7E 00    2691**  EZ80SF_PART:		LD	A,(IY)			; Check for a dot
0B1BCB FE 2E       2692**  			CP	'.'
0B1BCD 28 02       2693**  			JR	Z, @F			; If present, then carry on processing the eZ80 suffix
0B1BCF B7          2694**  			OR	A			; Reset the carry flag (no error)
0B1BD0 C9          2695**  			RET				; And return
0B1BD1 FD 23       2696**  @@:			INC	IY			; Skip the dot
0B1BD3 C5          2697**  			PUSH	BC			; Push the operand
0B1BD4 21 FC 1F 0B 2698**  			LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
0B1BD8 CD 15 1D 0B 2699**  			CALL	FIND			; Look up the operand
0B1BDC 30 24       2700**  			JR	NC,EZ80SF_OK
0B1BDE C1          2701**  			POP	BC			; Not found at this point, so will return with a C (error)
0B1BDF C9          2702**  			RET
0B1BE0             2703**  ;
0B1BE0 FD 7E 00    2704**  EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
0B1BE3 FE 2E       2705**  			CP	'.'
0B1BE5 28 02       2706**  			JR	Z,@F			; If present, then carry on processing the eZ80 suffix
0B1BE7 B7          2707**  			OR	A			; Reset the carry flag (no error)
0B1BE8 C9          2708**  			RET				; And return
0B1BE9 FD 23       2709**  @@:			INC	IY 			; Skip the dot
0B1BEB C5          2710**  			PUSH	BC			; Push the operand
0B1BEC 21 F4 1F 0B 2711**  			LD	HL,EZ80SFS_1		; First check the fully qualified table
0B1BF0 CD 15 1D 0B 2712**  			CALL	FIND 			; Look up the operand
0B1BF4 30 0C       2713**  			JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
0B1BF6 CD 11 1C 0B 2714**  			CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
0B1BFA CD 15 1D 0B 2715**  			CALL	FIND
0B1BFE 30 02       2716**  			JR	NC,EZ80SF_OK
0B1C00 C1          2717**  			POP	BC			; Not found at this point, so will return with a C (error)
0B1C01 C9          2718**  			RET
0B1C02             2719**  ;
0B1C02 78          2720**  EZ80SF_OK:		LD	A,B			; The operand value
0B1C03 D4 A3 1C 0B 2721**  			CALL	NC,BYTE_ 		; Write it out if found
0B1C07 CB BA       2722**  			RES	7,D			; Clear the default ADL mode from the flags
0B1C09 E6 02       2723**  			AND	2			; Check the second half of the suffix (.xxL)
0B1C0B 0F          2724**  			RRCA				; Shift into bit 7
0B1C0C 0F          2725**  			RRCA
0B1C0D B2          2726**  			OR	D			; Or into bit 7 of D
0B1C0E 57          2727**  			LD	D,A
0B1C0F C1          2728**  			POP	BC 			; Restore the operand
0B1C10 C9          2729**  			RET
0B1C11             2730**  ;
0B1C11 21 05 20 0B 2731**  EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
0B1C15 CB 7A       2732**  			BIT 	7,D			; if bit 7 of D is 0
0B1C17 C8          2733**  			RET	Z
0B1C18 21 10 20 0B 2734**  			LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
0B1C1C C9          2735**  			RET
0B1C1D             2736**  ;
0B1C1D CB 7A       2737**  ADDR_:			BIT	7,D			; Check the ADL flag
0B1C1F 20 0D       2738**  			JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
0B1C21             2739**  ;
0B1C21 CD B4 1C 0B 2740**  ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
0B1C25 CD 6D 1A 0B 2741**  VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
0B1C29 7C          2742**  			LD      A,H
0B1C2A C3 A3 1C 0B 2743**  			JP      BYTE_
0B1C2E             2744**  ;
0B1C2E CD B4 1C 0B 2745**  ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
0B1C32 CD 25 1C 0B 2746**  VAL24:			CALL	VAL16			; Lower 16-bits are in HL
0B1C36 D9          2747**  			EXX
0B1C37 7D          2748**  			LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
0B1C38 D9          2749**  			EXX
0B1C39 C3 A3 1C 0B 2750**  			JP	BYTE_
0B1C3D             2751**  ;
0B1C3D FE 04       2752**  LDA:			CP      4
0B1C3F DC 6E 1C 0B 2753**  			CALL    C,ED
0B1C43 78          2754**  			LD      A,B
0B1C44 C3 A3 1C 0B 2755**  			JP      BYTE_
0B1C48             2756**  ;
0B1C48 78          2757**  LD16:			LD      A,B
0B1C49 38 0F       2758**  			JR      C,LD8
0B1C4B 78          2759**  			LD      A,B
0B1C4C E6 3F       2760**  			AND     3FH
0B1C4E FE 0C       2761**  			CP      12
0B1C50 79          2762**  			LD      A,C
0B1C51 C8          2763**  			RET     Z
0B1C52 CD 6E 1C 0B 2764**  			CALL    ED
0B1C56 79          2765**  			LD      A,C
0B1C57 F6 43       2766**  			OR      43H
0B1C59 C9          2767**  			RET
0B1C5A             2768**  ;
0B1C5A FE 07       2769**  LD8:			CP      7
0B1C5C 37          2770**  			SCF
0B1C5D C0          2771**  			RET     NZ
0B1C5E 79          2772**  			LD      A,C
0B1C5F F6 30       2773**  			OR      30H
0B1C61 C9          2774**  			RET
0B1C62             2775**  ;
0B1C62             2776**  ; Used in IN and OUT to handle whether the operand is C or a number
0B1C62             2777**  ;
0B1C62 C5          2778**  CORN:			PUSH    BC
0B1C63 CD 82 1C 0B 2779**  			CALL    OPND			; Get the operand
0B1C67 CB 68       2780**  			BIT     5,B
0B1C69 C1          2781**  			POP     BC
0B1C6A 28 48       2782**  			JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
0B1C6C 26 FF       2783**  			LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
0B1C6E             2784**  ;
0B1C6E 3E ED       2785**  ED:			LD      A,0EDH			; Write an ED prefix out
0B1C70 18 31       2786**  			JR      BYTE_
0B1C72             2787**  ;
0B1C72 3E CB       2788**  CB:			LD      A,0CBH
0B1C74 FE 76       2789**  BIND:			CP      76H
0B1C76 37          2790**  			SCF
0B1C77 C8          2791**  			RET     Z               	; Reject LD (HL),(HL)
0B1C78 CD A3 1C 0B 2792**  			CALL    BYTE_
0B1C7C CB 72       2793**  			BIT	6,D			; Check the index bit in flags
0B1C7E C8          2794**  			RET     Z
0B1C7F 7B          2795**  			LD      A,E			; If there is an index, output the offset
0B1C80 18 21       2796**  			JR      BYTE_
0B1C82             2797**  ;
0B1C82             2798**  ; Search through the operand table
0B1C82             2799**  ; Returns:
0B1C82             2800**  ; - B: The operand type
0B1C82             2801**  ; - D: Bit 7: 0 = no prefix, 1 = prefix
0B1C82             2802**  ; - E: The IX/IY offset
0B1C82             2803**  ; - F: Carry if not found
0B1C82             2804**  ;
0B1C82 E5          2805**  OPND:			PUSH    HL			; Preserve HL
0B1C83 21 86 1F 0B 2806**  			LD      HL,OPRNDS		; The operands table
0B1C87 CD 15 1D 0B 2807**  			CALL    FIND			; Find the operand
0B1C8B E1          2808**  			POP     HL
0B1C8C D8          2809**  			RET     C			; Return if not found
0B1C8D CB 78       2810**  			BIT     7,B			; Check if it is an index register (IX, IY)
0B1C8F C8          2811**  			RET     Z			; Return if it isn't
0B1C90 CB F2       2812**  			SET	6,D			; Set flag to indicate we've got an index
0B1C92 CB 58       2813**  			BIT     3,B			; Check if an offset is required
0B1C94 E5          2814**  			PUSH    HL
0B1C95 CC AA 1C 0B 2815**  			CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
0B1C99 5D          2816**  			LD      E,L			; E: The offset
0B1C9A E1          2817**  			POP     HL
0B1C9B 3E DD       2818**  			LD	A,DDH			; IX prefix
0B1C9D CB 70       2819**  			BIT     6,B			; If bit 6 is reset then
0B1C9F 28 02       2820**  			JR      Z,BYTE_			; It's an IX instruction, otherwise set
0B1CA1 3E FD       2821**  			LD	A,FDH			; IY prefix
0B1CA3             2822**  ;
0B1CA3 DD 77 00    2823**  BYTE_:			LD      (IX),A			; Write a byte out
0B1CA6 DD 23       2824**  			INC     IX
0B1CA8 B7          2825**  			OR      A
0B1CA9 C9          2826**  			RET
0B1CAA             2827**  ;
0B1CAA FD 7E 00    2828**  OFFSET_EX:			LD      A,(IY)
0B1CAD FE 29       2829**  			CP      ')'
0B1CAF 21 00 00 00 2830**  			LD      HL,0
0B1CB3 C8          2831**  			RET     Z
0B1CB4 CD 66 1D 0B 2832**  NUMBER:			CALL    SKIP
0B1CB8 C5          2833**  			PUSH    BC
0B1CB9 D5          2834**  			PUSH    DE
0B1CBA DD E5       2835**  			PUSH    IX
0B1CBC CD BB 02 0B 2836**  			CALL    EXPRI
0B1CC0 DD E1       2837**  			POP     IX
0B1CC2 D9          2838**  			EXX
0B1CC3 D1          2839**  			POP     DE
0B1CC4 C1          2840**  			POP     BC
0B1CC5 7D          2841**  			LD      A,L
0B1CC6 B7          2842**  			OR      A
0B1CC7 C9          2843**  			RET
0B1CC8             2844**  ;
0B1CC8 CD 82 1C 0B 2845**  REG:			CALL    OPND
0B1CCC D8          2846**  			RET     C
0B1CCD 78          2847**  			LD      A,B
0B1CCE E6 3F       2848**  			AND     3FH
0B1CD0 FE 08       2849**  			CP      8
0B1CD2 3F          2850**  			CCF
0B1CD3 C9          2851**  			RET
0B1CD4             2852**  ;
0B1CD4 CD C8 1C 0B 2853**  REGLO:			CALL    REG
0B1CD8 D8          2854**  			RET     C
0B1CD9 18 33       2855**  			JR      ORC
0B1CDB             2856**  ;
0B1CDB CD C8 1C 0B 2857**  REGHI:			CALL    REG
0B1CDF D8          2858**  			RET     C
0B1CE0 18 29       2859**  			JR      SHL3
0B1CE2             2860**  ;
0B1CE2 CD 82 1C 0B 2861**  COND_:			CALL    OPND
0B1CE6 D8          2862**  			RET     C
0B1CE7 78          2863**  			LD      A,B
0B1CE8 E6 1F       2864**  			AND     1FH
0B1CEA D6 10       2865**  			SUB     16
0B1CEC 30 1D       2866**  			JR      NC,SHL3
0B1CEE FE F1       2867**  			CP      -15
0B1CF0 37          2868**  			SCF
0B1CF1 C0          2869**  			RET     NZ
0B1CF2 3E 03       2870**  			LD      A,3
0B1CF4 18 15       2871**  			JR      SHL3
0B1CF6             2872**  ;
0B1CF6 CD 82 1C 0B 2873**  PAIR_EX:			CALL    OPND
0B1CFA D8          2874**  			RET     C
0B1CFB 78          2875**  PAIR1_EX:			LD      A,B
0B1CFC E6 0F       2876**  			AND     0FH
0B1CFE D6 08       2877**  			SUB     8
0B1D00 D8          2878**  			RET     C
0B1D01 18 08       2879**  			JR      SHL3
0B1D03             2880**  ;
0B1D03 CD B4 1C 0B 2881**  BIT_:			CALL    NUMBER
0B1D07 FE 08       2882**  			CP      8
0B1D09 3F          2883**  			CCF
0B1D0A D8          2884**  			RET     C
0B1D0B 07          2885**  SHL3:			RLCA
0B1D0C 07          2886**  			RLCA
0B1D0D 07          2887**  			RLCA
0B1D0E B1          2888**  ORC:			OR      C
0B1D0F 4F          2889**  			LD      C,A
0B1D10 C9          2890**  			RET
0B1D11             2891**  ;
0B1D11 21 CB 1F 0B 2892**  LDOP:			LD      HL,LDOPS
0B1D15             2893**  
0B1D15             2894**  ;
0B1D15             2895**  ; Look up a value in a table
0B1D15             2896**  ; Parameters:
0B1D15             2897**  ; - IY: Address of the assembly language line in the BASIC program area
0B1D15             2898**  ; - HL: Address of the table
0B1D15             2899**  ; Returns:
0B1D15             2900**  ; - B: The operand code
0B1D15             2901**  ; - F: Carry set if not found
0B1D15             2902**  ;
0B1D15 CD 66 1D 0B 2903**  FIND:			CALL    SKIP			; Skip delimiters
0B1D19             2904**  ;
0B1D19 06 00       2905**  EXIT_:			LD      B,0			; Set B to 0
0B1D1B 37          2906**  			SCF				; Set the carry flag
0B1D1C C8          2907**  			RET     Z			; Returns if Z
0B1D1D             2908**  ;
0B1D1D FE DD       2909**  			CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
0B1D1F 28 04       2910**  			JR      Z,FIND0
0B1D21 FE 85       2911**  			CP      TOR+1			; Special case for tokens AND and OR
0B1D23 3F          2912**  			CCF
0B1D24 D8          2913**  			RET     C
0B1D25 7E          2914**  FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
0B1D26 B7          2915**  			OR      A
0B1D27 28 F0       2916**  			JR      Z,EXIT_			; Exit
0B1D29 FD AE 00    2917**  			XOR     (IY)
0B1D2C E6 5F       2918**  			AND     01011111B
0B1D2E 28 09       2919**  			JR      Z,FIND2
0B1D30 CB 7E       2920**  FIND1:			BIT     7,(HL)
0B1D32 23          2921**  			INC     HL
0B1D33 28 FB       2922**  			JR      Z,FIND1
0B1D35 23          2923**  			INC     HL
0B1D36 04          2924**  			INC     B
0B1D37 18 EC       2925**  			JR      FIND0
0B1D39             2926**  ;
0B1D39 FD E5       2927**  FIND2:			PUSH    IY
0B1D3B CB 7E       2928**  FIND3:			BIT     7,(HL)			; Is this the end of token marker?
0B1D3D FD 23       2929**  			INC     IY
0B1D3F 23          2930**  			INC     HL
0B1D40 20 11       2931**  			JR      NZ,FIND5		; Yes
0B1D42 BE          2932**  			CP      (HL)
0B1D43 CC 65 1D 0B 2933**  			CALL    Z,SKIP0
0B1D47 7E          2934**  			LD      A,(HL)
0B1D48 FD AE 00    2935**  			XOR     (IY)
0B1D4B E6 5F       2936**  			AND     01011111B
0B1D4D 28 EC       2937**  			JR      Z,FIND3
0B1D4F FD E1       2938**  FIND4:			POP     IY
0B1D51 18 DD       2939**  			JR      FIND1
0B1D53             2940**  ;
0B1D53 CD 17 17 0B 2941**  FIND5:			CALL    DELIM			; Is it a delimiter?
0B1D57 C4 7A 1D 0B 2942**  			CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
0B1D5B C4 74 1D 0B 2943**  			CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
0B1D5F 20 EE       2944**  			JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
0B1D61             2945**  ;
0B1D61 78          2946**  FIND6:			LD      A,B			; At this point we have a token
0B1D62 46          2947**  			LD      B,(HL)			; Fetch the token type code
0B1D63 E1          2948**  			POP     HL			; Restore the stack
0B1D64 C9          2949**  			RET
0B1D65             2950**  ;
0B1D65 23          2951**  SKIP0:			INC     HL
0B1D66 CD 17 17 0B 2952**  SKIP:			CALL    DELIM			; Is it a delimiter?
0B1D6A C0          2953**  			RET     NZ			; No, so return
0B1D6B CD 23 17 0B 2954**  			CALL    TERM			; Is it a terminator?
0B1D6F C8          2955**  			RET     Z			; Yes, so return
0B1D70 FD 23       2956**  			INC     IY			; Increment the basic program counter
0B1D72 18 F2       2957**  			JR      SKIP			; And loop
0B1D74             2958**  ;
0B1D74 FE 2B       2959**  SIGN:			CP      '+'			; Check whether the character is a sign symbol
0B1D76 C8          2960**  			RET     Z
0B1D77 FE 2D       2961**  			CP      '-'
0B1D79 C9          2962**  			RET
0B1D7A             2963**  ;
0B1D7A FE 2E       2964**  DOT:			CP	'.'			; Check if it is a dot character
0B1D7C C9          2965**  			RET
0B1D7D             2966**  ; Z80 opcode list
0B1D7D             2967**  ;
0B1D7D             2968**  ; Group 0: (15 opcodes)
0B1D7D             2969**  ; Trivial cases requiring no computation
0B1D7D             2970**  ;
0B1D7D             2971**  ; BEGIN REFACTOR FROM BINARY
0B1D7D             2972**  ; OPCODS:
0B1D7D             2973**  ; 			DB	"NO","P"+80H,00h	; # 00h
0B1D7D             2974**  ; 			DB	"RLC","A"+80H,07h
0B1D7D             2975**  ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
0B1D7D             2976**  ; 			DB	"RRC","A"+80H,0FH
0B1D7D             2977**  ; 			DB	"RL","A"+80H,17H
0B1D7D             2978**  ; 			DB	"RR","A"+80H,1FH
0B1D7D             2979**  ; 			DB	"DA","A"+80H,27H
0B1D7D             2980**  ; 			DB	"CP","L"+80H,2FH
0B1D7D             2981**  ; 			DB	"SC","F"+80H,37H
0B1D7D             2982**  ; 			DB	"CC","F"+80H,3FH
0B1D7D             2983**  ; 			DB	"HAL","T"+80H,76H
0B1D7D             2984**  ; 			DB	"EX","X"+80H,D9H
0B1D7D             2985**  ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
0B1D7D             2986**  ; 			DB	"D","I"+80H,F3H
0B1D7D             2987**  ; 			DB	"E","I"+80H,FBH
0B1D7D             2988**  ; ;
0B1D7D             2989**  ; ; Group 1: (53 opcodes)
0B1D7D             2990**  ; ; As Group 0, but with an ED prefix
0B1D7D             2991**  ; ;
0B1D7D             2992**  ; 			DB	"NE","G"+80H,44H	; 0Fh
0B1D7D             2993**  ; 			DB	"IM",0,"0"+80H,46H
0B1D7D             2994**  ; 			DB	"RET","N"+80H,45H
0B1D7D             2995**  ; 			DB	"MLT",0,"B","C"+80H,4CH
0B1D7D             2996**  ; 			DB	"RET","I"+80H,4DH
0B1D7D             2997**  ; 			DB	"IM",0,"1"+80H,56H
0B1D7D             2998**  ; 			DB	"MLT",0,"D","E"+80H,5CH
0B1D7D             2999**  ; 			DB	"IM",0,"2"+80H,5EH
0B1D7D             3000**  ; 			DB	"RR","D"+80H,67H
0B1D7D             3001**  ; 			DB	"MLT",0,"H","L"+80H,6CH
0B1D7D             3002**  ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
0B1D7D             3003**  ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
0B1D7D             3004**  ; 			DB	"RL","D"+80H,6FH
0B1D7D             3005**  ; 			DB	"SL","P"+80H,76H
0B1D7D             3006**  ; 			DB	"MLT",0,"S","P"+80H,7CH
0B1D7D             3007**  ; 			DB	"STMI","X"+80H,7DH
0B1D7D             3008**  ; 			DB	"RSMI","X"+80H,7EH
0B1D7D             3009**  ; 			DB	"INI","M"+80H,82H
0B1D7D             3010**  ; 			DB	"OTI","M"+80H,83H
0B1D7D             3011**  ; 			DB	"INI","2"+80H,84H
0B1D7D             3012**  ; 			DB	"IND","M"+80H,8AH
0B1D7D             3013**  ; 			DB	"OTD","M"+80H,8BH
0B1D7D             3014**  ; 			DB	"IND","2"+80H,8CH
0B1D7D             3015**  ; 			DB	"INIM","R"+80H,92H
0B1D7D             3016**  ; 			DB	"OTIM","R"+80H,93H
0B1D7D             3017**  ; 			DB	"INI2","R"+80H,94H
0B1D7D             3018**  ; 			DB	"INDM","R"+80H,9AH
0B1D7D             3019**  ; 			DB	"OTDM","R"+80H,9BH
0B1D7D             3020**  ; 			DB	"IND2","R"+80H,9CH
0B1D7D             3021**  ; 			DB	"LD","I"+80H,A0H
0B1D7D             3022**  ; 			DB	"CP","I"+80H,A1H
0B1D7D             3023**  ; 			DB	"IN","I"+80H,A2H
0B1D7D             3024**  ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
0B1D7D             3025**  ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
0B1D7D             3026**  ; 			DB	"LD","D"+80H,A8H
0B1D7D             3027**  ; 			DB	"CP","D"+80H,A9H
0B1D7D             3028**  ; 			DB	"IN","D"+80H,AAH
0B1D7D             3029**  ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
0B1D7D             3030**  ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
0B1D7D             3031**  ; 			DB	"LDI","R"+80H,B0H
0B1D7D             3032**  ; 			DB	"CPI","R"+80H,B1H
0B1D7D             3033**  ; 			DB	"INI","R"+80H,B2H
0B1D7D             3034**  ; 			DB	"OTI","R"+80H,B3H
0B1D7D             3035**  ; 			DB	"OTI2","R"+80H,B4H
0B1D7D             3036**  ; 			DB	"LDD","R"+80H,B8H
0B1D7D             3037**  ; 			DB	"CPD","R"+80H,B9H
0B1D7D             3038**  ; 			DB	"IND","R"+80H,BAH
0B1D7D             3039**  ; 			DB	"OTD","R"+80H,BBH
0B1D7D             3040**  ; 			DB	"OTD2","R"+80H,BCH
0B1D7D             3041**  ; 			DB	"INIR","X"+80H,C2H
0B1D7D             3042**  ; 			DB	"OTIR","X"+80H,C3H
0B1D7D             3043**  ; 			DB	"INDR","X"+80H,CAH
0B1D7D             3044**  ; 			DB	"OTDR","X"+80H,CBH
0B1D7D             3045**  ; ;
0B1D7D             3046**  ; ; Group 2: (3 opcodes)
0B1D7D             3047**  ; ;
0B1D7D             3048**  ; 			DB	"BI","T"+80H,40H	; 44h
0B1D7D             3049**  ; 			DB	"RE","S"+80H,80H
0B1D7D             3050**  ; 			DB	"SE","T"+80H,C0H
0B1D7D             3051**  ; ;
0B1D7D             3052**  ; ; Group 3: (7 opcodes)
0B1D7D             3053**  ; ;
0B1D7D             3054**  ; 			DB	"RL","C"+80H,00H	; 47h
0B1D7D             3055**  ; 			DB	"RR","C"+80H,08H
0B1D7D             3056**  ; 			DB	"R","L"+80H,10H
0B1D7D             3057**  ; 			DB	"R","R"+80H,18H
0B1D7D             3058**  ; 			DB	"SL","A"+80H,20H
0B1D7D             3059**  ; 			DB	"SR","A"+80H,28H
0B1D7D             3060**  ; 			DB	"SR","L"+80H,38H
0B1D7D             3061**  ; ;
0B1D7D             3062**  ; ; Group 4: (3 opcodes)
0B1D7D             3063**  ; ;
0B1D7D             3064**  ; 			DB	"PO","P"+80H,C1H	; 4Eh
0B1D7D             3065**  ; 			DB	"PUS","H"+80H,C5H
0B1D7D             3066**  ; 			DB	"EX",0,"(S","P"+80H,E3H
0B1D7D             3067**  ; ;
0B1D7D             3068**  ; ; Group 5: (7 opcodes)
0B1D7D             3069**  ; ;
0B1D7D             3070**  ; 			DB	"SU","B"+80H,90H	; 51h
0B1D7D             3071**  ; 			DB	"AN","D"+80H,A0H
0B1D7D             3072**  ; 			DB	"XO","R"+80H,A8H
0B1D7D             3073**  ; 			DB	"O","R"+80H,B0H
0B1D7D             3074**  ; 			DB	"C","P"+80H,B8H
0B1D7D             3075**  ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
0B1D7D             3076**  ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
0B1D7D             3077**  ; ;
0B1D7D             3078**  ; ; Group 6 (3 opcodes)
0B1D7D             3079**  ; ;
0B1D7D             3080**  ; 			DB	"AD","D"+80H,80H	; 58h
0B1D7D             3081**  ; 			DB	"AD","C"+80H,88H
0B1D7D             3082**  ; 			DB	"SB","C"+80H,98H
0B1D7D             3083**  ; ;
0B1D7D             3084**  ; ; Group 7: (2 opcodes)
0B1D7D             3085**  ; ;
0B1D7D             3086**  ; 			DB	"IN","C"+80H,04H	; 5Bh
0B1D7D             3087**  ; 			DB	"DE","C"+80H,05H
0B1D7D             3088**  ; ;
0B1D7D             3089**  ; ; Group 8: (2 opcodes)
0B1D7D             3090**  ; ;
0B1D7D             3091**  ; 			DB	"IN","0"+80H,00H	; 5Dh
0B1D7D             3092**  ; 			DB	"OUT","0"+80H,01H
0B1D7D             3093**  ; ;
0B1D7D             3094**  ; ; Group 9: (1 opcode)
0B1D7D             3095**  ; ;
0B1D7D             3096**  ; 			DB	"I","N"+80H,40H		; 5Fh
0B1D7D             3097**  ; ;
0B1D7D             3098**  ; ; Group 10: (1 opcode)
0B1D7D             3099**  ; ;
0B1D7D             3100**  ; 			DB	"OU","T"+80H,41H	; 60h
0B1D7D             3101**  ; ;
0B1D7D             3102**  ; ; Group 11: (2 opcodes)
0B1D7D             3103**  ; ;
0B1D7D             3104**  ; 			DB	"J","R"+80H,20H		; 61h
0B1D7D             3105**  ; 			DB	"DJN","Z"+80H,10H
0B1D7D             3106**  ; ;
0B1D7D             3107**  ; ; Group 12: (1 opcode)
0B1D7D             3108**  ; ;
0B1D7D             3109**  ; 			DB	"J","P"+80H,C2H		; 63h
0B1D7D             3110**  ; ;
0B1D7D             3111**  ; ; Group 13: (1 opcode)
0B1D7D             3112**  ; ;
0B1D7D             3113**  ; 			DB	"CAL","L"+80H,C4H	; 64h
0B1D7D             3114**  ; ;
0B1D7D             3115**  ; ; Group 14: (1 opcode)
0B1D7D             3116**  ; ;
0B1D7D             3117**  ; 			DB	"RS","T"+80H,C7H	; 65h
0B1D7D             3118**  ; ;
0B1D7D             3119**  ; ; Group 15: (1 opcode)
0B1D7D             3120**  ; ;
0B1D7D             3121**  ; 			DB	"RE","T"+80H,C0H	; 66h
0B1D7D             3122**  ; ;
0B1D7D             3123**  ; ; Group 16: (1 opcode)
0B1D7D             3124**  ; ;
0B1D7D             3125**  ; 			DB	"L","D"+80H,40H		; 67h
0B1D7D             3126**  ; ;
0B1D7D             3127**  ; ; Group 17: (1 opcode)
0B1D7D             3128**  ; ;
0B1D7D             3129**  ; 			DB	"TS","T"+80H,04H	; 68h
0B1D7D             3130**  
0B1D7D             3131**  ; ;
0B1D7D             3132**  ; ; Assembler Directives
0B1D7D             3133**  ; ;
0B1D7D             3134**  ; 			DB	"OP","T"+80H,00H	; 69h OPT
0B1D7D             3135**  ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
0B1D7D             3136**  ; ;
0B1D7D             3137**  ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
0B1D7D             3138**  ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
0B1D7D             3139**  ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
0B1D7D             3140**  ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
0B1D7D             3141**  ; ;
0B1D7D             3142**  ; 			DB	0
0B1D7D             3143**  ; ;
0B1D7D             3144**  ; ; Operands
0B1D7D             3145**  ; ;
0B1D7D             3146**  ; OPRNDS:			DB	"B"+80H, 00H
0B1D7D             3147**  ; 			DB	"C"+80H, 01H
0B1D7D             3148**  ; 			DB	"D"+80H, 02H
0B1D7D             3149**  ; 			DB	"E"+80H, 03H
0B1D7D             3150**  ; 			DB	"H"+80H, 04H
0B1D7D             3151**  ; 			DB	"L"+80H, 05H
0B1D7D             3152**  ; 			DB	"(H","L"+80H,06H
0B1D7D             3153**  ; 			DB	"A"+80H, 07H
0B1D7D             3154**  ; 			DB	"(I","X"+80H,86H
0B1D7D             3155**  ; 			DB	"(I","Y"+80H,C6H
0B1D7D             3156**  ; ;
0B1D7D             3157**  ; 			DB	"B","C"+80H,08H
0B1D7D             3158**  ; 			DB	"D","E"+80H,0AH
0B1D7D             3159**  ; 			DB	"H","L"+80H,0CH
0B1D7D             3160**  ; 			DB	"I","X"+80H,8CH
0B1D7D             3161**  ; 			DB	"I","Y"+80H,CCH
0B1D7D             3162**  ; 			DB	"A","F"+80H,0EH
0B1D7D             3163**  ; 			DB	"S","P"+80H,0EH
0B1D7D             3164**  ; ;
0B1D7D             3165**  ; 			DB	"N","Z"+80H,10H
0B1D7D             3166**  ; 			DB	"Z"+80H,11H
0B1D7D             3167**  ; 			DB	"N","C"+80H,12H
0B1D7D             3168**  ; 			DB	"P","O"+80H,14H
0B1D7D             3169**  ; 			DB	"P","E"+80H,15H
0B1D7D             3170**  ; 			DB	"P"+80H,16H
0B1D7D             3171**  ; 			DB	"M"+80H,17H
0B1D7D             3172**  ; ;
0B1D7D             3173**  ; 			DB	"(","C"+80H,20H
0B1D7D             3174**  ; ;
0B1D7D             3175**  ; 			DB	0
0B1D7D             3176**  ; ;
0B1D7D             3177**  ; ; Load operations
0B1D7D             3178**  ; ;
0B1D7D             3179**  ; LDOPS:			DB	"I",0,"A"+80H,47H
0B1D7D             3180**  ; 			DB	"R",0,"A"+80H,4FH
0B1D7D             3181**  ; 			DB	"A",0,"I"+80H,57H
0B1D7D             3182**  ; 			DB	"A",0,"R"+80H,5FH
0B1D7D             3183**  ; 			DB	"(BC",0,"A"+80H,02h
0B1D7D             3184**  ; 			DB	"(DE",0,"A"+80H,12H
0B1D7D             3185**  ; 			DB	"A",0,"(B","C"+80H,0AH
0B1D7D             3186**  ; 			DB	"A",0,"(D","E"+80H,1AH
0B1D7D             3187**  ; ;
0B1D7D             3188**  ; 			DB	0
0B1D7D             3189**  ; ;
0B1D7D             3190**  ; ; eZ80 addressing mode suffixes
0B1D7D             3191**  ; ;
0B1D7D             3192**  ; ; Fully qualified suffixes
0B1D7D             3193**  ; ;
0B1D7D             3194**  ; EZ80SFS_1:		DB	"LI","S"+80H,49H
0B1D7D             3195**  ; 			DB	"SI","L"+80H,52H
0B1D7D             3196**  ; EZ80SFS_2:		DB	"SI","S"+80H,40H
0B1D7D             3197**  ; 			DB	"LI","L"+80H,5BH
0B1D7D             3198**  ; ;
0B1D7D             3199**  ; 			DB	0
0B1D7D             3200**  ; ;
0B1D7D             3201**  ; ; Shortcuts when ADL mode is 0
0B1D7D             3202**  ; ;
0B1D7D             3203**  ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0B1D7D             3204**  ; 			DB	"L"+80H,49H		; Equivalent to .LIS
0B1D7D             3205**  ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
0B1D7D             3206**  ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
0B1D7D             3207**  ; ;
0B1D7D             3208**  ; 			DB	0
0B1D7D             3209**  ; ;
0B1D7D             3210**  ; ; Shortcuts when ADL mode is 1
0B1D7D             3211**  ; ;
0B1D7D             3212**  ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0B1D7D             3213**  ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
0B1D7D             3214**  ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
0B1D7D             3215**  ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
0B1D7D             3216**  ; ;
0B1D7D             3217**  ; 			DB	0
0B1D7D             3218**  ; END REFACTOR FROM BINARY
0B1D7D             3219**  ; BEGIN INSERT FROM BINARY
0B1D7D             3220**  ;
0B1D7D             3221**  ; Trivial cases requiring no computation
0B1D7D             3222**  OPCODS:
0B1D7D 4E          3223**  	db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
0B1D7E 4F          3224**  	db 0x4f ; 041DCD
0B1D7F D0          3225**  	db 0xd0 ; 041DCE
0B1D80 00          3226**  	db 0x00 ; 041DCF
0B1D81 52          3227**  	db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
0B1D82 4C          3228**  	db 0x4c ; 041DD1
0B1D83 43          3229**  	db 0x43 ; 041DD2
0B1D84 C1          3230**  	db 0xc1 ; 041DD3
0B1D85 07          3231**  	db 0x07 ; 041DD4
0B1D86 45          3232**  	db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
0B1D87 58          3233**  	db 0x58 ; 041DD6
0B1D88 00          3234**  	db 0x00 ; 041DD7
0B1D89 41          3235**  	db 0x41 ; 041DD8
0B1D8A 46          3236**  	db 0x46 ; 041DD9
0B1D8B 00          3237**  	db 0x00 ; 041DDA
0B1D8C 41          3238**  	db 0x41 ; 041DDB
0B1D8D 46          3239**  	db 0x46 ; 041DDC
0B1D8E A7          3240**  	db 0xa7 ; 041DDD
0B1D8F 08          3241**  	db 0x08 ; 041DDE
0B1D90 52          3242**  	db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
0B1D91 52          3243**  	db 0x52 ; 041DE0
0B1D92 43          3244**  	db 0x43 ; 041DE1
0B1D93 C1          3245**  	db 0xc1 ; 041DE2
0B1D94 0F          3246**  	db 0x0f ; 041DE3
0B1D95 52          3247**  	db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
0B1D96 4C          3248**  	db 0x4c ; 041DE5
0B1D97 C1          3249**  	db 0xc1 ; 041DE6
0B1D98 17          3250**  	db 0x17 ; 041DE7
0B1D99 52          3251**  	db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
0B1D9A 52          3252**  	db 0x52 ; 041DE9
0B1D9B C1          3253**  	db 0xc1 ; 041DEA
0B1D9C 1F          3254**  	db 0x1f ; 041DEB
0B1D9D 44          3255**  	db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
0B1D9E 41          3256**  	db 0x41 ; 041DED
0B1D9F C1          3257**  	db 0xc1 ; 041DEE
0B1DA0 27          3258**  	db 0x27 ; 041DEF
0B1DA1 43          3259**  	db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
0B1DA2 50          3260**  	db 0x50 ; 041DF1
0B1DA3 CC          3261**  	db 0xcc ; 041DF2
0B1DA4 2F          3262**  	db 0x2f ; 041DF3
0B1DA5 53          3263**  	db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
0B1DA6 43          3264**  	db 0x43 ; 041DF5
0B1DA7 C6          3265**  	db 0xc6 ; 041DF6
0B1DA8 37          3266**  	db 0x37 ; 041DF7
0B1DA9 43          3267**  	db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
0B1DAA 43          3268**  	db 0x43 ; 041DF9
0B1DAB C6          3269**  	db 0xc6 ; 041DFA
0B1DAC 3F          3270**  	db 0x3f ; 041DFB
0B1DAD 48          3271**  	db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
0B1DAE 41          3272**  	db 0x41 ; 041DFD
0B1DAF 4C          3273**  	db 0x4c ; 041DFE
0B1DB0 D4          3274**  	db 0xd4 ; 041DFF
0B1DB1 76          3275**  	db 0x76 ; 041E00
0B1DB2 45          3276**  	db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
0B1DB3 58          3277**  	db 0x58 ; 041E02
0B1DB4 D8          3278**  	db 0xd8 ; 041E03
0B1DB5 D9          3279**  	db 0xd9 ; 041E04
0B1DB6 45          3280**  	db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
0B1DB7 58          3281**  	db 0x58 ; 041E06
0B1DB8 00          3282**  	db 0x00 ; 041E07
0B1DB9 44          3283**  	db 0x44 ; 041E08
0B1DBA 45          3284**  	db 0x45 ; 041E09
0B1DBB 00          3285**  	db 0x00 ; 041E0A
0B1DBC 48          3286**  	db 0x48 ; 041E0B
0B1DBD CC          3287**  	db 0xcc ; 041E0C
0B1DBE EB          3288**  	db 0xeb ; 041E0D
0B1DBF 44          3289**  	db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
0B1DC0 C9          3290**  	db 0xc9 ; 041E0F
0B1DC1 F3          3291**  	db 0xf3 ; 041E10
0B1DC2 45          3292**  	db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
0B1DC3 C9          3293**  	db 0xc9 ; 041E12
0B1DC4 FB          3294**  	db 0xfb ; 041E13
0B1DC5             3295**  ;
0B1DC5             3296**  ; Group 1: (53 opcodes)
0B1DC5             3297**  ; As Group 0, but with an ED prefix
0B1DC5             3298**  ;
0B1DC5 4E          3299**  	db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
0B1DC6 45          3300**  	db 0x45 ; 041E15
0B1DC7 C7          3301**  	db 0xc7 ; 041E16
0B1DC8 44          3302**  	db 0x44 ; 041E17
0B1DC9 49          3303**  	db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
0B1DCA 4D          3304**  	db 0x4d ; 041E19
0B1DCB 00          3305**  	db 0x00 ; 041E1A
0B1DCC B0          3306**  	db 0xb0 ; 041E1B
0B1DCD 46          3307**  	db 0x46 ; 041E1C
0B1DCE 52          3308**  	db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
0B1DCF 45          3309**  	db 0x45 ; 041E1E
0B1DD0 54          3310**  	db 0x54 ; 041E1F
0B1DD1 CE          3311**  	db 0xce ; 041E20
0B1DD2 45          3312**  	db 0x45 ; 041E21
0B1DD3 4D          3313**  	db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
0B1DD4 4C          3314**  	db 0x4c ; 041E23
0B1DD5 54          3315**  	db 0x54 ; 041E24
0B1DD6 00          3316**  	db 0x00 ; 041E25
0B1DD7 42          3317**  	db 0x42 ; 041E26
0B1DD8 C3          3318**  	db 0xc3 ; 041E27
0B1DD9 4C          3319**  	db 0x4c ; 041E28
0B1DDA 52          3320**  	db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
0B1DDB 45          3321**  	db 0x45 ; 041E2A
0B1DDC 54          3322**  	db 0x54 ; 041E2B
0B1DDD C9          3323**  	db 0xc9 ; 041E2C
0B1DDE 4D          3324**  	db 0x4d ; 041E2D
0B1DDF 49          3325**  	db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
0B1DE0 4D          3326**  	db 0x4d ; 041E2F
0B1DE1 00          3327**  	db 0x00 ; 041E30
0B1DE2 B1          3328**  	db 0xb1 ; 041E31
0B1DE3 56          3329**  	db 0x56 ; 041E32
0B1DE4 4D          3330**  	db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
0B1DE5 4C          3331**  	db 0x4c ; 041E34
0B1DE6 54          3332**  	db 0x54 ; 041E35
0B1DE7 00          3333**  	db 0x00 ; 041E36
0B1DE8 44          3334**  	db 0x44 ; 041E37
0B1DE9 C5          3335**  	db 0xc5 ; 041E38
0B1DEA 5C          3336**  	db 0x5c ; 041E39
0B1DEB 49          3337**  	db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
0B1DEC 4D          3338**  	db 0x4d ; 041E3B
0B1DED 00          3339**  	db 0x00 ; 041E3C
0B1DEE B2          3340**  	db 0xb2 ; 041E3D
0B1DEF 5E          3341**  	db 0x5e ; 041E3E
0B1DF0 52          3342**  	db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
0B1DF1 52          3343**  	db 0x52 ; 041E40
0B1DF2 C4          3344**  	db 0xc4 ; 041E41
0B1DF3 67          3345**  	db 0x67 ; 041E42
0B1DF4 4D          3346**  	db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
0B1DF5 4C          3347**  	db 0x4c ; 041E44
0B1DF6 54          3348**  	db 0x54 ; 041E45
0B1DF7 00          3349**  	db 0x00 ; 041E46
0B1DF8 48          3350**  	db 0x48 ; 041E47
0B1DF9 CC          3351**  	db 0xcc ; 041E48
0B1DFA 6C          3352**  	db 0x6c ; 041E49
0B1DFB 4C          3353**  	db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
0B1DFC 44          3354**  	db 0x44 ; 041E4B
0B1DFD 00          3355**  	db 0x00 ; 041E4C
0B1DFE 4D          3356**  	db 0x4d ; 041E4D
0B1DFF 42          3357**  	db 0x42 ; 041E4E
0B1E00 00          3358**  	db 0x00 ; 041E4F
0B1E01 C1          3359**  	db 0xc1 ; 041E50
0B1E02 6D          3360**  	db 0x6d ; 041E51
0B1E03 4C          3361**  	db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
0B1E04 44          3362**  	db 0x44 ; 041E53
0B1E05 00          3363**  	db 0x00 ; 041E54
0B1E06 41          3364**  	db 0x41 ; 041E55
0B1E07 00          3365**  	db 0x00 ; 041E56
0B1E08 4D          3366**  	db 0x4d ; 041E57
0B1E09 C2          3367**  	db 0xc2 ; 041E58
0B1E0A 6E          3368**  	db 0x6e ; 041E59
0B1E0B 52          3369**  	db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
0B1E0C 4C          3370**  	db 0x4c ; 041E5B
0B1E0D C4          3371**  	db 0xc4 ; 041E5C
0B1E0E 6F          3372**  	db 0x6f ; 041E5D
0B1E0F 53          3373**  	db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
0B1E10 4C          3374**  	db 0x4c ; 041E5F
0B1E11 D0          3375**  	db 0xd0 ; 041E60
0B1E12 76          3376**  	db 0x76 ; 041E61
0B1E13 4D          3377**  	db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
0B1E14 4C          3378**  	db 0x4c ; 041E63
0B1E15 54          3379**  	db 0x54 ; 041E64
0B1E16 00          3380**  	db 0x00 ; 041E65
0B1E17 53          3381**  	db 0x53 ; 041E66
0B1E18 D0          3382**  	db 0xd0 ; 041E67
0B1E19 7C          3383**  	db 0x7c ; 041E68
0B1E1A 53          3384**  	db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
0B1E1B 54          3385**  	db 0x54 ; 041E6A
0B1E1C 4D          3386**  	db 0x4d ; 041E6B
0B1E1D 49          3387**  	db 0x49 ; 041E6C
0B1E1E D8          3388**  	db 0xd8 ; 041E6D
0B1E1F 7D          3389**  	db 0x7d ; 041E6E
0B1E20 52          3390**  	db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
0B1E21 53          3391**  	db 0x53 ; 041E70
0B1E22 4D          3392**  	db 0x4d ; 041E71
0B1E23 49          3393**  	db 0x49 ; 041E72
0B1E24 D8          3394**  	db 0xd8 ; 041E73
0B1E25 7E          3395**  	db 0x7e ; 041E74
0B1E26 49          3396**  	db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
0B1E27 4E          3397**  	db 0x4e ; 041E76
0B1E28 49          3398**  	db 0x49 ; 041E77
0B1E29 CD          3399**  	db 0xcd ; 041E78
0B1E2A 82          3400**  	db 0x82 ; 041E79
0B1E2B 4F          3401**  	db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
0B1E2C 54          3402**  	db 0x54 ; 041E7B
0B1E2D 49          3403**  	db 0x49 ; 041E7C
0B1E2E CD          3404**  	db 0xcd ; 041E7D
0B1E2F 83          3405**  	db 0x83 ; 041E7E
0B1E30 49          3406**  	db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
0B1E31 4E          3407**  	db 0x4e ; 041E80
0B1E32 49          3408**  	db 0x49 ; 041E81
0B1E33 B2          3409**  	db 0xb2 ; 041E82
0B1E34 84          3410**  	db 0x84 ; 041E83
0B1E35 49          3411**  	db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
0B1E36 4E          3412**  	db 0x4e ; 041E85
0B1E37 44          3413**  	db 0x44 ; 041E86
0B1E38 CD          3414**  	db 0xcd ; 041E87
0B1E39 8A          3415**  	db 0x8a ; 041E88
0B1E3A 4F          3416**  	db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
0B1E3B 54          3417**  	db 0x54 ; 041E8A
0B1E3C 44          3418**  	db 0x44 ; 041E8B
0B1E3D CD          3419**  	db 0xcd ; 041E8C
0B1E3E 8B          3420**  	db 0x8b ; 041E8D
0B1E3F 49          3421**  	db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
0B1E40 4E          3422**  	db 0x4e ; 041E8F
0B1E41 44          3423**  	db 0x44 ; 041E90
0B1E42 B2          3424**  	db 0xb2 ; 041E91
0B1E43 8C          3425**  	db 0x8c ; 041E92
0B1E44 49          3426**  	db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
0B1E45 4E          3427**  	db 0x4e ; 041E94
0B1E46 49          3428**  	db 0x49 ; 041E95
0B1E47 4D          3429**  	db 0x4d ; 041E96
0B1E48 D2          3430**  	db 0xd2 ; 041E97
0B1E49 92          3431**  	db 0x92 ; 041E98
0B1E4A 4F          3432**  	db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
0B1E4B 54          3433**  	db 0x54 ; 041E9A
0B1E4C 49          3434**  	db 0x49 ; 041E9B
0B1E4D 4D          3435**  	db 0x4d ; 041E9C
0B1E4E D2          3436**  	db 0xd2 ; 041E9D
0B1E4F 93          3437**  	db 0x93 ; 041E9E
0B1E50 49          3438**  	db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
0B1E51 4E          3439**  	db 0x4e ; 041EA0
0B1E52 49          3440**  	db 0x49 ; 041EA1
0B1E53 32          3441**  	db 0x32 ; 041EA2
0B1E54 D2          3442**  	db 0xd2 ; 041EA3
0B1E55 94          3443**  	db 0x94 ; 041EA4
0B1E56 49          3444**  	db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
0B1E57 4E          3445**  	db 0x4e ; 041EA6
0B1E58 44          3446**  	db 0x44 ; 041EA7
0B1E59 4D          3447**  	db 0x4d ; 041EA8
0B1E5A D2          3448**  	db 0xd2 ; 041EA9
0B1E5B 9A          3449**  	db 0x9a ; 041EAA
0B1E5C 4F          3450**  	db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
0B1E5D 54          3451**  	db 0x54 ; 041EAC
0B1E5E 44          3452**  	db 0x44 ; 041EAD
0B1E5F 4D          3453**  	db 0x4d ; 041EAE
0B1E60 D2          3454**  	db 0xd2 ; 041EAF
0B1E61 9B          3455**  	db 0x9b ; 041EB0
0B1E62 49          3456**  	db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
0B1E63 4E          3457**  	db 0x4e ; 041EB2
0B1E64 44          3458**  	db 0x44 ; 041EB3
0B1E65 32          3459**  	db 0x32 ; 041EB4
0B1E66 D2          3460**  	db 0xd2 ; 041EB5
0B1E67 9C          3461**  	db 0x9c ; 041EB6
0B1E68 4C          3462**  	db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
0B1E69 44          3463**  	db 0x44 ; 041EB8
0B1E6A C9          3464**  	db 0xc9 ; 041EB9
0B1E6B A0          3465**  	db 0xa0 ; 041EBA
0B1E6C 43          3466**  	db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
0B1E6D 50          3467**  	db 0x50 ; 041EBC
0B1E6E C9          3468**  	db 0xc9 ; 041EBD
0B1E6F A1          3469**  	db 0xa1 ; 041EBE
0B1E70 49          3470**  	db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
0B1E71 4E          3471**  	db 0x4e ; 041EC0
0B1E72 C9          3472**  	db 0xc9 ; 041EC1
0B1E73 A2          3473**  	db 0xa2 ; 041EC2
0B1E74 4F          3474**  	db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
0B1E75 55          3475**  	db 0x55 ; 041EC4
0B1E76 54          3476**  	db 0x54 ; 041EC5
0B1E77 49          3477**  	db 0x49 ; 041EC6
0B1E78 B2          3478**  	db 0xb2 ; 041EC7
0B1E79 A4          3479**  	db 0xa4 ; 041EC8
0B1E7A 4F          3480**  	db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
0B1E7B 55          3481**  	db 0x55 ; 041ECA
0B1E7C 54          3482**  	db 0x54 ; 041ECB
0B1E7D C9          3483**  	db 0xc9 ; 041ECC
0B1E7E A3          3484**  	db 0xa3 ; 041ECD
0B1E7F 4C          3485**  	db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
0B1E80 44          3486**  	db 0x44 ; 041ECF
0B1E81 C4          3487**  	db 0xc4 ; 041ED0
0B1E82 A8          3488**  	db 0xa8 ; 041ED1
0B1E83 43          3489**  	db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
0B1E84 50          3490**  	db 0x50 ; 041ED3
0B1E85 C4          3491**  	db 0xc4 ; 041ED4
0B1E86 A9          3492**  	db 0xa9 ; 041ED5
0B1E87 49          3493**  	db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
0B1E88 4E          3494**  	db 0x4e ; 041ED7
0B1E89 C4          3495**  	db 0xc4 ; 041ED8
0B1E8A AA          3496**  	db 0xaa ; 041ED9
0B1E8B 4F          3497**  	db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
0B1E8C 55          3498**  	db 0x55 ; 041EDB
0B1E8D 54          3499**  	db 0x54 ; 041EDC
0B1E8E 44          3500**  	db 0x44 ; 041EDD
0B1E8F B2          3501**  	db 0xb2 ; 041EDE
0B1E90 AC          3502**  	db 0xac ; 041EDF
0B1E91 4F          3503**  	db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
0B1E92 55          3504**  	db 0x55 ; 041EE1
0B1E93 54          3505**  	db 0x54 ; 041EE2
0B1E94 C4          3506**  	db 0xc4 ; 041EE3
0B1E95 AB          3507**  	db 0xab ; 041EE4
0B1E96 4C          3508**  	db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
0B1E97 44          3509**  	db 0x44 ; 041EE6
0B1E98 49          3510**  	db 0x49 ; 041EE7
0B1E99 D2          3511**  	db 0xd2 ; 041EE8
0B1E9A B0          3512**  	db 0xb0 ; 041EE9
0B1E9B 43          3513**  	db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
0B1E9C 50          3514**  	db 0x50 ; 041EEB
0B1E9D 49          3515**  	db 0x49 ; 041EEC
0B1E9E D2          3516**  	db 0xd2 ; 041EED
0B1E9F B1          3517**  	db 0xb1 ; 041EEE
0B1EA0 49          3518**  	db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
0B1EA1 4E          3519**  	db 0x4e ; 041EF0
0B1EA2 49          3520**  	db 0x49 ; 041EF1
0B1EA3 D2          3521**  	db 0xd2 ; 041EF2
0B1EA4 B2          3522**  	db 0xb2 ; 041EF3
0B1EA5 4F          3523**  	db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
0B1EA6 54          3524**  	db 0x54 ; 041EF5
0B1EA7 49          3525**  	db 0x49 ; 041EF6
0B1EA8 D2          3526**  	db 0xd2 ; 041EF7
0B1EA9 B3          3527**  	db 0xb3 ; 041EF8
0B1EAA 4F          3528**  	db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
0B1EAB 54          3529**  	db 0x54 ; 041EFA
0B1EAC 49          3530**  	db 0x49 ; 041EFB
0B1EAD 32          3531**  	db 0x32 ; 041EFC
0B1EAE D2          3532**  	db 0xd2 ; 041EFD
0B1EAF B4          3533**  	db 0xb4 ; 041EFE
0B1EB0 4C          3534**  	db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
0B1EB1 44          3535**  	db 0x44 ; 041F00
0B1EB2 44          3536**  	db 0x44 ; 041F01
0B1EB3 D2          3537**  	db 0xd2 ; 041F02
0B1EB4 B8          3538**  	db 0xb8 ; 041F03
0B1EB5 43          3539**  	db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
0B1EB6 50          3540**  	db 0x50 ; 041F05
0B1EB7 44          3541**  	db 0x44 ; 041F06
0B1EB8 D2          3542**  	db 0xd2 ; 041F07
0B1EB9 B9          3543**  	db 0xb9 ; 041F08
0B1EBA 49          3544**  	db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
0B1EBB 4E          3545**  	db 0x4e ; 041F0A
0B1EBC 44          3546**  	db 0x44 ; 041F0B
0B1EBD D2          3547**  	db 0xd2 ; 041F0C
0B1EBE BA          3548**  	db 0xba ; 041F0D
0B1EBF 4F          3549**  	db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
0B1EC0 54          3550**  	db 0x54 ; 041F0F
0B1EC1 44          3551**  	db 0x44 ; 041F10
0B1EC2 D2          3552**  	db 0xd2 ; 041F11
0B1EC3 BB          3553**  	db 0xbb ; 041F12
0B1EC4 4F          3554**  	db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
0B1EC5 54          3555**  	db 0x54 ; 041F14
0B1EC6 44          3556**  	db 0x44 ; 041F15
0B1EC7 32          3557**  	db 0x32 ; 041F16
0B1EC8 D2          3558**  	db 0xd2 ; 041F17
0B1EC9 BC          3559**  	db 0xbc ; 041F18
0B1ECA 49          3560**  	db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
0B1ECB 4E          3561**  	db 0x4e ; 041F1A
0B1ECC 49          3562**  	db 0x49 ; 041F1B
0B1ECD 52          3563**  	db 0x52 ; 041F1C
0B1ECE D8          3564**  	db 0xd8 ; 041F1D
0B1ECF C2          3565**  	db 0xc2 ; 041F1E
0B1ED0 4F          3566**  	db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
0B1ED1 54          3567**  	db 0x54 ; 041F20
0B1ED2 49          3568**  	db 0x49 ; 041F21
0B1ED3 52          3569**  	db 0x52 ; 041F22
0B1ED4 D8          3570**  	db 0xd8 ; 041F23
0B1ED5 C3          3571**  	db 0xc3 ; 041F24
0B1ED6 49          3572**  	db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
0B1ED7 4E          3573**  	db 0x4e ; 041F26
0B1ED8 44          3574**  	db 0x44 ; 041F27
0B1ED9 52          3575**  	db 0x52 ; 041F28
0B1EDA D8          3576**  	db 0xd8 ; 041F29
0B1EDB CA          3577**  	db 0xca ; 041F2A
0B1EDC 4F          3578**  	db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
0B1EDD 54          3579**  	db 0x54 ; 041F2C
0B1EDE 44          3580**  	db 0x44 ; 041F2D
0B1EDF 52          3581**  	db 0x52 ; 041F2E
0B1EE0 D8          3582**  	db 0xd8 ; 041F2F
0B1EE1 CB          3583**  	db 0xcb ; 041F30
0B1EE2             3584**  ;
0B1EE2             3585**  ; Group 2: (3 opcodes)
0B1EE2             3586**  ;
0B1EE2 42          3587**  	db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
0B1EE3 49          3588**  	db 0x49 ; 041F32
0B1EE4 D4          3589**  	db 0xd4 ; 041F33
0B1EE5 40          3590**  	db 0x40 ; 041F34
0B1EE6 52          3591**  	db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
0B1EE7 45          3592**  	db 0x45 ; 041F36
0B1EE8 D3          3593**  	db 0xd3 ; 041F37
0B1EE9 80          3594**  	db 0x80 ; 041F38
0B1EEA 53          3595**  	db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
0B1EEB 45          3596**  	db 0x45 ; 041F3A
0B1EEC D4          3597**  	db 0xd4 ; 041F3B
0B1EED C0          3598**  	db 0xc0 ; 041F3C
0B1EEE             3599**  ;
0B1EEE             3600**  ; Group 3: (7 opcodes)
0B1EEE             3601**  ;
0B1EEE 52          3602**  	db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
0B1EEF 4C          3603**  	db 0x4c ; 041F3E
0B1EF0 C3          3604**  	db 0xc3 ; 041F3F
0B1EF1 00          3605**  	db 0x00 ; 041F40
0B1EF2 52          3606**  	db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
0B1EF3 52          3607**  	db 0x52 ; 041F42
0B1EF4 C3          3608**  	db 0xc3 ; 041F43
0B1EF5 08          3609**  	db 0x08 ; 041F44
0B1EF6 52          3610**  	db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
0B1EF7 CC          3611**  	db 0xcc ; 041F46
0B1EF8 10          3612**  	db 0x10 ; 041F47
0B1EF9 52          3613**  	db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
0B1EFA D2          3614**  	db 0xd2 ; 041F49
0B1EFB 18          3615**  	db 0x18 ; 041F4A
0B1EFC 53          3616**  	db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
0B1EFD 4C          3617**  	db 0x4c ; 041F4C
0B1EFE C1          3618**  	db 0xc1 ; 041F4D
0B1EFF 20          3619**  	db 0x20 ; 041F4E
0B1F00 53          3620**  	db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
0B1F01 52          3621**  	db 0x52 ; 041F50
0B1F02 C1          3622**  	db 0xc1 ; 041F51
0B1F03 28          3623**  	db 0x28 ; 041F52
0B1F04 53          3624**  	db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
0B1F05 52          3625**  	db 0x52 ; 041F54
0B1F06 CC          3626**  	db 0xcc ; 041F55
0B1F07 38          3627**  	db 0x38 ; 041F56
0B1F08             3628**  ;
0B1F08             3629**  ; Group 4: (3 opcodes)
0B1F08             3630**  ;
0B1F08 50          3631**  	db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
0B1F09 4F          3632**  	db 0x4f ; 041F58
0B1F0A D0          3633**  	db 0xd0 ; 041F59
0B1F0B C1          3634**  	db 0xc1 ; 041F5A
0B1F0C 50          3635**  	db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
0B1F0D 55          3636**  	db 0x55 ; 041F5C
0B1F0E 53          3637**  	db 0x53 ; 041F5D
0B1F0F C8          3638**  	db 0xc8 ; 041F5E
0B1F10 C5          3639**  	db 0xc5 ; 041F5F
0B1F11 45          3640**  	db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
0B1F12 58          3641**  	db 0x58 ; 041F61
0B1F13 00          3642**  	db 0x00 ; 041F62
0B1F14 28          3643**  	db 0x28 ; 041F63
0B1F15 53          3644**  	db 0x53 ; 041F64
0B1F16 D0          3645**  	db 0xd0 ; 041F65
0B1F17 E3          3646**  	db 0xe3 ; 041F66
0B1F18             3647**  ;
0B1F18             3648**  ; Group 5: (7 opcodes)
0B1F18             3649**  ;
0B1F18 53          3650**  	db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
0B1F19 55          3651**  	db 0x55 ; 041F68
0B1F1A C2          3652**  	db 0xc2 ; 041F69
0B1F1B 90          3653**  	db 0x90 ; 041F6A
0B1F1C 41          3654**  	db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
0B1F1D 4E          3655**  	db 0x4e ; 041F6C
0B1F1E C4          3656**  	db 0xc4 ; 041F6D
0B1F1F A0          3657**  	db 0xa0 ; 041F6E
0B1F20 58          3658**  	db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
0B1F21 4F          3659**  	db 0x4f ; 041F70
0B1F22 D2          3660**  	db 0xd2 ; 041F71
0B1F23 A8          3661**  	db 0xa8 ; 041F72
0B1F24 4F          3662**  	db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
0B1F25 D2          3663**  	db 0xd2 ; 041F74
0B1F26 B0          3664**  	db 0xb0 ; 041F75
0B1F27 43          3665**  	db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
0B1F28 D0          3666**  	db 0xd0 ; 041F77
0B1F29 B8          3667**  	db 0xb8 ; 041F78
0B1F2A 80          3668**  	db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
0B1F2B A0          3669**  	db 0xa0 ; 041F7A
0B1F2C 84          3670**  	db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
0B1F2D B0          3671**  	db 0xb0 ; 041F7C
0B1F2E             3672**  ;
0B1F2E             3673**  ; Group 6 (3 opcodes)
0B1F2E             3674**  ;
0B1F2E 41          3675**  	db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
0B1F2F 44          3676**  	db 0x44 ; 041F7E
0B1F30 C4          3677**  	db 0xc4 ; 041F7F
0B1F31 80          3678**  	db 0x80 ; 041F80
0B1F32 41          3679**  	db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
0B1F33 44          3680**  	db 0x44 ; 041F82
0B1F34 C3          3681**  	db 0xc3 ; 041F83
0B1F35 88          3682**  	db 0x88 ; 041F84
0B1F36 53          3683**  	db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
0B1F37 42          3684**  	db 0x42 ; 041F86
0B1F38 C3          3685**  	db 0xc3 ; 041F87
0B1F39 98          3686**  	db 0x98 ; 041F88
0B1F3A             3687**  ;
0B1F3A             3688**  ; Group 7: (2 opcodes)
0B1F3A             3689**  ;
0B1F3A 49          3690**  	db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
0B1F3B 4E          3691**  	db 0x4e ; 041F8A
0B1F3C C3          3692**  	db 0xc3 ; 041F8B
0B1F3D 04          3693**  	db 0x04 ; 041F8C
0B1F3E 44          3694**  	db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
0B1F3F 45          3695**  	db 0x45 ; 041F8E
0B1F40 C3          3696**  	db 0xc3 ; 041F8F
0B1F41 05          3697**  	db 0x05 ; 041F90
0B1F42             3698**  ;
0B1F42             3699**  ; Group 8: (2 opcodes)
0B1F42             3700**  ;
0B1F42 49          3701**  	db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
0B1F43 4E          3702**  	db 0x4e ; 041F92
0B1F44 B0          3703**  	db 0xb0 ; 041F93
0B1F45 00          3704**  	db 0x00 ; 041F94
0B1F46 4F          3705**  	db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
0B1F47 55          3706**  	db 0x55 ; 041F96
0B1F48 54          3707**  	db 0x54 ; 041F97
0B1F49 B0          3708**  	db 0xb0 ; 041F98
0B1F4A 01          3709**  	db 0x01 ; 041F99
0B1F4B             3710**  ;
0B1F4B             3711**  ; Group 9: (1 opcode)
0B1F4B             3712**  ;
0B1F4B 49          3713**  	db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
0B1F4C CE          3714**  	db 0xce ; 041F9B
0B1F4D 40          3715**  	db 0x40 ; 041F9C
0B1F4E             3716**  ;
0B1F4E             3717**  ; Group 10: (1 opcode)
0B1F4E             3718**  ;
0B1F4E 4F          3719**  	db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
0B1F4F 55          3720**  	db 0x55 ; 041F9E
0B1F50 D4          3721**  	db 0xd4 ; 041F9F
0B1F51 41          3722**  	db 0x41 ; 041FA0
0B1F52             3723**  ;
0B1F52             3724**  ; Group 11: (2 opcodes)
0B1F52             3725**  ;
0B1F52 4A          3726**  	db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
0B1F53 D2          3727**  	db 0xd2 ; 041FA2
0B1F54 20          3728**  	db 0x20 ; 041FA3
0B1F55 44          3729**  	db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
0B1F56 4A          3730**  	db 0x4a ; 041FA5
0B1F57 4E          3731**  	db 0x4e ; 041FA6
0B1F58 DA          3732**  	db 0xda ; 041FA7
0B1F59 10          3733**  	db 0x10 ; 041FA8
0B1F5A             3734**  ;
0B1F5A             3735**  ; Group 12: (1 opcode)
0B1F5A             3736**  ;
0B1F5A 4A          3737**  	db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
0B1F5B D0          3738**  	db 0xd0 ; 041FAA
0B1F5C C2          3739**  	db 0xc2 ; 041FAB
0B1F5D             3740**  ;
0B1F5D             3741**  ; Group 13: (1 opcode)
0B1F5D             3742**  ;
0B1F5D 43          3743**  	db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
0B1F5E 41          3744**  	db 0x41 ; 041FAD
0B1F5F 4C          3745**  	db 0x4c ; 041FAE
0B1F60 CC          3746**  	db 0xcc ; 041FAF
0B1F61 C4          3747**  	db 0xc4 ; 041FB0
0B1F62             3748**  ;
0B1F62             3749**  ; Group 14: (1 opcode)
0B1F62             3750**  ;
0B1F62 52          3751**  	db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
0B1F63 53          3752**  	db 0x53 ; 041FB2
0B1F64 D4          3753**  	db 0xd4 ; 041FB3
0B1F65 C7          3754**  	db 0xc7 ; 041FB4
0B1F66             3755**  ;
0B1F66             3756**  ; Group 15: (1 opcode)
0B1F66             3757**  ;
0B1F66 52          3758**  	db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
0B1F67 45          3759**  	db 0x45 ; 041FB6
0B1F68 D4          3760**  	db 0xd4 ; 041FB7
0B1F69 C0          3761**  	db 0xc0 ; 041FB8
0B1F6A             3762**  ;
0B1F6A             3763**  ; Group 16: (1 opcode)
0B1F6A             3764**  ;
0B1F6A 4C          3765**  	db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
0B1F6B C4          3766**  	db 0xc4 ; 041FBA
0B1F6C 40          3767**  	db 0x40 ; 041FBB
0B1F6D             3768**  ;
0B1F6D             3769**  ; Group 17: (1 opcode)
0B1F6D             3770**  ;
0B1F6D 54          3771**  	db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
0B1F6E 53          3772**  	db 0x53 ; 041FBD
0B1F6F D4          3773**  	db 0xd4 ; 041FBE
0B1F70 04          3774**  	db 0x04 ; 041FBF
0B1F71             3775**  ;
0B1F71             3776**  ; Assembler Directives
0B1F71             3777**  ;
0B1F71 4F          3778**  	db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
0B1F72 50          3779**  	db 0x50 ; 041FC1
0B1F73 D4          3780**  	db 0xd4 ; 041FC2
0B1F74 00          3781**  	db 0x00 ; 041FC3
0B1F75 41          3782**  	db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
0B1F76 44          3783**  	db 0x44 ; 041FC5
0B1F77 CC          3784**  	db 0xcc ; 041FC6
0B1F78 00          3785**  	db 0x00 ; 041FC7
0B1F79 5D          3786**  	db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
0B1F7A C2          3787**  	db 0xc2 ; 041FC9
0B1F7B 00          3788**  	db 0x00 ; 041FCA
0B1F7C 5D          3789**  	db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
0B1F7D D7          3790**  	db 0xd7 ; 041FCC
0B1F7E 00          3791**  	db 0x00 ; 041FCD
0B1F7F 5D          3792**  	db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
0B1F80 CC          3793**  	db 0xcc ; 041FCF
0B1F81 00          3794**  	db 0x00 ; 041FD0
0B1F82 5D          3795**  	db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
0B1F83 CD          3796**  	db 0xcd ; 041FD2
0B1F84 00          3797**  	db 0x00 ; 041FD3
0B1F85 00          3798**  	db 0x00 ; 041FD4 00      5426 DB	0
0B1F86             3799**  ;
0B1F86             3800**  ; Operands
0B1F86             3801**  ;
0B1F86             3802**  OPRNDS:
0B1F86 C2          3803**  	db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
0B1F87 00          3804**  	db 0x00 ; 041FD6
0B1F88 C3          3805**  	db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
0B1F89 01          3806**  	db 0x01 ; 041FD8
0B1F8A C4          3807**  	db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
0B1F8B 02          3808**  	db 0x02 ; 041FDA
0B1F8C C5          3809**  	db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
0B1F8D 03          3810**  	db 0x03 ; 041FDC
0B1F8E C8          3811**  	db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
0B1F8F 04          3812**  	db 0x04 ; 041FDE
0B1F90 CC          3813**  	db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
0B1F91 05          3814**  	db 0x05 ; 041FE0
0B1F92 28          3815**  	db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
0B1F93 48          3816**  	db 0x48 ; 041FE2
0B1F94 CC          3817**  	db 0xcc ; 041FE3
0B1F95 06          3818**  	db 0x06 ; 041FE4
0B1F96 C1          3819**  	db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
0B1F97 07          3820**  	db 0x07 ; 041FE6
0B1F98 28          3821**  	db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
0B1F99 49          3822**  	db 0x49 ; 041FE8
0B1F9A D8          3823**  	db 0xd8 ; 041FE9
0B1F9B 86          3824**  	db 0x86 ; 041FEA
0B1F9C 28          3825**  	db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
0B1F9D 49          3826**  	db 0x49 ; 041FEC
0B1F9E D9          3827**  	db 0xd9 ; 041FED
0B1F9F C6          3828**  	db 0xc6 ; 041FEE
0B1FA0 42          3829**  	db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
0B1FA1 C3          3830**  	db 0xc3 ; 041FF0
0B1FA2 08          3831**  	db 0x08 ; 041FF1
0B1FA3 44          3832**  	db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
0B1FA4 C5          3833**  	db 0xc5 ; 041FF3
0B1FA5 0A          3834**  	db 0x0a ; 041FF4
0B1FA6 48          3835**  	db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
0B1FA7 CC          3836**  	db 0xcc ; 041FF6
0B1FA8 0C          3837**  	db 0x0c ; 041FF7
0B1FA9 49          3838**  	db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
0B1FAA D8          3839**  	db 0xd8 ; 041FF9
0B1FAB 8C          3840**  	db 0x8c ; 041FFA
0B1FAC 49          3841**  	db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
0B1FAD D9          3842**  	db 0xd9 ; 041FFC
0B1FAE CC          3843**  	db 0xcc ; 041FFD
0B1FAF 41          3844**  	db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
0B1FB0 C6          3845**  	db 0xc6 ; 041FFF
0B1FB1 0E          3846**  	db 0x0e ; 042000
0B1FB2 53          3847**  	db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
0B1FB3 D0          3848**  	db 0xd0 ; 042002
0B1FB4 0E          3849**  	db 0x0e ; 042003
0B1FB5 4E          3850**  	db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
0B1FB6 DA          3851**  	db 0xda ; 042005
0B1FB7 10          3852**  	db 0x10 ; 042006
0B1FB8 DA          3853**  	db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
0B1FB9 11          3854**  	db 0x11 ; 042008
0B1FBA 4E          3855**  	db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
0B1FBB C3          3856**  	db 0xc3 ; 04200A
0B1FBC 12          3857**  	db 0x12 ; 04200B
0B1FBD 50          3858**  	db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
0B1FBE CF          3859**  	db 0xcf ; 04200D
0B1FBF 14          3860**  	db 0x14 ; 04200E
0B1FC0 50          3861**  	db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
0B1FC1 C5          3862**  	db 0xc5 ; 042010
0B1FC2 15          3863**  	db 0x15 ; 042011
0B1FC3 D0          3864**  	db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
0B1FC4 16          3865**  	db 0x16 ; 042013
0B1FC5 CD          3866**  	db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
0B1FC6 17          3867**  	db 0x17 ; 042015
0B1FC7 28          3868**  	db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
0B1FC8 C3          3869**  	db 0xc3 ; 042017
0B1FC9 20          3870**  	db 0x20 ; 042018
0B1FCA 00          3871**  	db 0x00 ; 042019 00      5459 DB	0
0B1FCB             3872**  ;
0B1FCB             3873**  ; Load operations
0B1FCB             3874**  ;
0B1FCB             3875**  LDOPS:
0B1FCB 49          3876**  	db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
0B1FCC 00          3877**  	db 0x00 ; 04201B
0B1FCD C1          3878**  	db 0xc1 ; 04201C
0B1FCE 47          3879**  	db 0x47 ; 04201D
0B1FCF 52          3880**  	db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
0B1FD0 00          3881**  	db 0x00 ; 04201F
0B1FD1 C1          3882**  	db 0xc1 ; 042020
0B1FD2 4F          3883**  	db 0x4f ; 042021
0B1FD3 41          3884**  	db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
0B1FD4 00          3885**  	db 0x00 ; 042023
0B1FD5 C9          3886**  	db 0xc9 ; 042024
0B1FD6 57          3887**  	db 0x57 ; 042025
0B1FD7 41          3888**  	db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
0B1FD8 00          3889**  	db 0x00 ; 042027
0B1FD9 D2          3890**  	db 0xd2 ; 042028
0B1FDA 5F          3891**  	db 0x5f ; 042029
0B1FDB 28          3892**  	db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
0B1FDC 42          3893**  	db 0x42 ; 04202B
0B1FDD 43          3894**  	db 0x43 ; 04202C
0B1FDE 00          3895**  	db 0x00 ; 04202D
0B1FDF C1          3896**  	db 0xc1 ; 04202E
0B1FE0 02          3897**  	db 0x02 ; 04202F
0B1FE1 28          3898**  	db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
0B1FE2 44          3899**  	db 0x44 ; 042031
0B1FE3 45          3900**  	db 0x45 ; 042032
0B1FE4 00          3901**  	db 0x00 ; 042033
0B1FE5 C1          3902**  	db 0xc1 ; 042034
0B1FE6 12          3903**  	db 0x12 ; 042035
0B1FE7 41          3904**  	db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
0B1FE8 00          3905**  	db 0x00 ; 042037
0B1FE9 28          3906**  	db 0x28 ; 042038
0B1FEA 42          3907**  	db 0x42 ; 042039
0B1FEB C3          3908**  	db 0xc3 ; 04203A
0B1FEC 0A          3909**  	db 0x0a ; 04203B
0B1FED 41          3910**  	db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
0B1FEE 00          3911**  	db 0x00 ; 04203D
0B1FEF 28          3912**  	db 0x28 ; 04203E
0B1FF0 44          3913**  	db 0x44 ; 04203F
0B1FF1 C5          3914**  	db 0xc5 ; 042040
0B1FF2 1A          3915**  	db 0x1a ; 042041
0B1FF3 00          3916**  	db 0x00 ; 042042 00      5472 DB	0
0B1FF4             3917**  ;
0B1FF4             3918**  ; eZ80 addressing mode suffixes
0B1FF4             3919**  ;
0B1FF4             3920**  ; Fully qualified suffixes
0B1FF4             3921**  ;
0B1FF4             3922**  EZ80SFS_1:
0B1FF4 4C          3923**  	db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
0B1FF5 49          3924**  	db 0x49 ; 042044
0B1FF6 D3          3925**  	db 0xd3 ; 042045
0B1FF7 49          3926**  	db 0x49 ; 042046
0B1FF8 53          3927**  	db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
0B1FF9 49          3928**  	db 0x49 ; 042048
0B1FFA CC          3929**  	db 0xcc ; 042049
0B1FFB 52          3930**  	db 0x52 ; 04204A
0B1FFC             3931**  
0B1FFC             3932**  EZ80SFS_2:
0B1FFC 53          3933**  	db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
0B1FFD 49          3934**  	db 0x49 ; 04204C
0B1FFE D3          3935**  	db 0xd3 ; 04204D
0B1FFF 40          3936**  	db 0x40 ; 04204E
0B2000 4C          3937**  	db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
0B2001 49          3938**  	db 0x49 ; 042050
0B2002 CC          3939**  	db 0xcc ; 042051
0B2003 5B          3940**  	db 0x5b ; 042052
0B2004 00          3941**  	db 0x00 ; 042053 00      5483 DB	0
0B2005             3942**  ;
0B2005             3943**  ; Shortcuts when ADL mode is 0
0B2005             3944**  ;
0B2005             3945**  EZ80SFS_ADL0:
0B2005 D3          3946**  	db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0B2006 40          3947**  	db 0x40 ; 042055
0B2007 CC          3948**  	db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
0B2008 49          3949**  	db 0x49 ; 042057
0B2009 49          3950**  	db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
0B200A D3          3951**  	db 0xd3 ; 042059
0B200B 40          3952**  	db 0x40 ; 04205A
0B200C 49          3953**  	db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
0B200D CC          3954**  	db 0xcc ; 04205C
0B200E 52          3955**  	db 0x52 ; 04205D
0B200F 00          3956**  	db 0x00 ; 04205E 00      5492 DB	0
0B2010             3957**  ;
0B2010             3958**  ; Shortcuts when ADL mode is 1
0B2010             3959**  ;
0B2010             3960**  EZ80SFS_ADL1:
0B2010 D3          3961**  	db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0B2011 52          3962**  	db 0x52 ; 042060
0B2012 CC          3963**  	db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
0B2013 5B          3964**  	db 0x5b ; 042062
0B2014 49          3965**  	db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
0B2015 D3          3966**  	db 0xd3 ; 042064
0B2016 49          3967**  	db 0x49 ; 042065
0B2017 49          3968**  	db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
0B2018 CC          3969**  	db 0xcc ; 042067
0B2019 5B          3970**  	db 0x5b ; 042068
0B201A 00          3971**  	db 0x00 ; 042069 00      5501 DB	0
0B201B             3972**  ; END INSERT FROM BINARY
0B201B             3973**  ;
0B201B             3974**  ; .LIST
0B201B             3975**  ;
0B201B             3976**  ; already defined in equs.inc
0B201B             3977**  ; LF:			EQU     0AH
0B201B             3978**  ; CR:			EQU     0DH
0B201B             0007*       include "basic/fpp.asm"
0B201B             0001**  ;
0B201B             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B201B             0003**  ;		Z80 Floating Point Package
0B201B             0004**  ; Author:	(C) Copyright  R.T.Russell  1986
0B201B             0005**  ; Modified By:	Dean Belfield
0B201B             0006**  ; Created:	03/05/2022
0B201B             0007**  ; Last Updated:	07/06/2023
0B201B             0008**  ;
0B201B             0009**  ; Modinfo:
0B201B             0010**  ; 26/10/1986:	Version 0.0
0B201B             0011**  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0B201B             0012**  ; 12/05/2023:	Modified by Dean Belfield
0B201B             0013**  ; 07/06/2023:	Modified to run in ADL mode
0B201B             0014**  
0B201B             0015**  			; .ASSUME	ADL = 1
0B201B             0016**  
0B201B             0017**  			; SEGMENT CODE
0B201B             0018**  
0B201B             0019**  			; XDEF	FPP
0B201B             0020**  			; XDEF	DLOAD5
0B201B             0021**  			; XDEF	DLOAD5_SPL
0B201B             0022**  ;
0B201B             0023**  ;BINARY FLOATING POINT REPRESENTATION:
0B201B             0024**  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B201B             0025**  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0B201B             0026**  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B201B             0027**  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B201B             0028**  ;
0B201B             0029**  ;BINARY INTEGER REPRESENTATION:
0B201B             0030**  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B201B             0031**  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B201B             0032**  ;
0B201B             0033**  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B201B             0034**  ;                            EXPONENT - C
0B201B             0035**  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0B201B             0036**  ;                               EXPONENT - B
0B201B             0037**  
0B201B             0038**  ;
0B201B             0039**  ;Error codes:
0B201B             0040**  ;
0B201B             0041**  
0B201B             0042**  BADOP:			EQU     1               ;Bad operation code
0B201B             0043**  DIVBY0:			EQU     18              ;Division by zero
0B201B             0044**  TOOBIG_FP:			EQU     20              ;Too big
0B201B             0045**  NGROOT:			EQU     21              ;Negative root
0B201B             0046**  LOGRNG:			EQU     22              ;Log range
0B201B             0047**  ACLOST:			EQU     23              ;Accuracy lost
0B201B             0048**  EXPRNG:			EQU     24              ;Exp range
0B201B             0049**  ;
0B201B             0050**  ;Call entry and despatch code:
0B201B             0051**  ;
0B201B FD E5       0052**  FPP:			PUSH    IY              ;Save IY
0B201D FD 21 00 00 0053**          		LD      IY,0
       00          
0B2022 FD 39       0054**          		ADD     IY,SP           ;Save SP in IY
0B2024 CD 34 20 0B 0055**          		CALL    OP              ;Perform operation
0B2028 BF          0056**          		CP      A               ;Good return (Z, NC)
0B2029 FD E1       0057**  EXIT_FP_:			POP     IY              ;Restore IY
0B202B C9          0058**          		RET                     ;Return to caller
0B202C             0059**  ;
0B202C             0060**  ;Error exit:
0B202C             0061**  ;
0B202C 3E 01       0062**  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B202E FD F9       0063**  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B2030 B7          0064**          		OR      A               ;Set NZ
0B2031 37          0065**          		SCF                     ;Set C
0B2032 18 F5       0066**          		JR      EXIT_FP_
0B2034             0067**  ;
0B2034             0068**  ;Perform operation or function:
0B2034             0069**  ;
0B2034             0070**  ; OP:			CP      (RTABLE-DTABLE)/3
0B2034 FE 2A       0071**  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2036             0072**  
0B2036 30 F4       0073**          		JR      NC,BAD_FP
0B2038             0074**          		; CP      (FTABLE-DTABLE)/3
0B2038 FE 10       0075**  				CP      FTABLE-DTABLE/3 ; ditto
0B203A 30 08       0076**          		JR      NC,DISPAT_FP
0B203C 08          0077**          		EX      AF,AF'
0B203D 78          0078**          		LD      A,B
0B203E B1          0079**          		OR      C               ;Both integer?
0B203F C4 47 2B 0B 0080**          		CALL    NZ,FLOATA       ;No, so float both
0B2043 08          0081**          		EX      AF,AF'
0B2044 E5          0082**  DISPAT_FP:			PUSH    HL
0B2045 21 57 20 0B 0083**          		LD      HL,DTABLE
0B2049 C5          0084**          		PUSH    BC
0B204A 01 03 00 00 0085**  			LD	BC, 3		; C = 3
0B204E 47          0086**  			LD	B, A 		; B = op-code
0B204F ED 4C       0087**  			MLT 	BC 		;BC = op-code * 3
0B2051 09          0088**  			ADD	HL, BC 		;Add to table base
0B2052 ED 27       0089**  			LD	HL, (HL)	;Get the routine address (24-bit)
0B2054             0090**  
0B2054             0091**  ;        		ADD     A, A            ;A = op-code * 2
0B2054             0092**  ;        		LD      C,A
0B2054             0093**  ;        		LD      B,0             ;BC = op-code * 2
0B2054             0094**  ;        		ADD     HL,BC
0B2054             0095**  ;        		LD      A,(HL)          ;Get low byte
0B2054             0096**  ;        		INC     HL
0B2054             0097**  ;        		LD      H,(HL)          ;Get high byte
0B2054             0098**  ;        		LD      L,A
0B2054             0099**  
0B2054 C1          0100**          		POP     BC
0B2055 E3          0101**          		EX      (SP),HL
0B2056 C9          0102**          		RET                     ;Off to routine
0B2057             0103**  ;
0B2057             0104**  ;Despatch table:
0B2057             0105**  ;
0B2057 09 21 0B    0106**  DTABLE:			DW24  IAND            ;AND (INTEGER)
0B205A 77 21 0B    0107**          		DW24  IBDIV           ;DIV
0B205D 1C 21 0B    0108**          		DW24  IEOR            ;EOR
0B2060 42 21 0B    0109**          		DW24  IMOD            ;MOD
0B2063 2F 21 0B    0110**          		DW24  IOR             ;OR
0B2066 FD 23 0B    0111**          		DW24  ILE             ;<=
0B2069 0C 24 0B    0112**          		DW24  INE             ;<>
0B206C F0 23 0B    0113**          		DW24  IGE             ;>=
0B206F D5 23 0B    0114**          		DW24  ILT             ;<
0B2072 19 24 0B    0115**          		DW24  IEQ             ;=
0B2075 65 22 0B    0116**          		DW24  IMUL            ;*
0B2078 A0 21 0B    0117**          		DW24  IADD            ;+
0B207B E2 23 0B    0118**          		DW24  IGT             ;>
0B207E 87 21 0B    0119**          		DW24  ISUB            ;-
0B2081 1C 23 0B    0120**          		DW24  IPOW            ;^
0B2084 12 22 0B    0121**          		DW24  IDIV            ;/
0B2087             0122**  ;
0B2087             0123**  FTABLE:
0B2087 2B 24 0B    0124**  				DW24  ABSV_FP            ;ABS
0B208A 11 28 0B    0125**          		DW24  ACS_FP             ;ACS
0B208D 4F 27 0B    0126**          		DW24  ASN_FP             ;ASN
0B2090 7F 27 0B    0127**          		DW24  ATN_FP             ;ATN
0B2093 4A 25 0B    0128**          		DW24  COS_FP             ;COS
0B2096 59 24 0B    0129**          		DW24  DEG_FP             ;DEG
0B2099 06 26 0B    0130**          		DW24  EXP_FP             ;EXP
0B209C AD 24 0B    0131**          		DW24  INT_FP_            ;INT
0B209F A4 26 0B    0132**          		DW24  LN_FP              ;LN
0B20A2 39 27 0B    0133**          		DW24  LOG_FP             ;LOG
0B20A5 37 24 0B    0134**          		DW24  NOTK_FP            ;NOT
0B20A8 63 24 0B    0135**          		DW24  RAD_FP             ;RAD
0B20AB 7E 24 0B    0136**          		DW24  SGN_FP             ;SGN
0B20AE 57 25 0B    0137**          		DW24  SIN_FP             ;SIN
0B20B1 C6 24 0B    0138**          		DW24  SQR_FP             ;SQR
0B20B4 24 25 0B    0139**          		DW24  TAN_FP             ;TAN
0B20B7             0140**  ;
0B20B7 D4 2B 0B    0141**  		        DW24  ZERO_FP            ;ZERO
0B20BA DF 25 0B    0142**          		DW24  FONE_FP            ;FONE
0B20BD 1E 24 0B    0143**          		DW24  TRUE_FP            ;TRUE
0B20C0 4B 24 0B    0144**          		DW24  PI_FP              ;PI
0B20C3             0145**  ;
0B20C3 92 24 0B    0146**  		        DW24  VAL_FP             ;VAL
0B20C6 1A 28 0B    0147**          		DW24  STR_FP             ;STR$
0B20C9             0148**  ;
0B20C9 7B 2A 0B    0149**          		DW24  SFIX_FP            ;FIX
0B20CC 57 2B 0B    0150**          		DW24  SFLOAT_FP          ;FLOAT
0B20CF             0151**  ;
0B20CF A5 2B 0B    0152**  		        DW24  FTEST_FP           ;TEST
0B20D2 B7 2B 0B    0153**          		DW24  FCOMP_FP           ;COMPARE
0B20D5             0154**  ;
0B20D5 05 21 0B    0155**  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B20D8 73 21 0B    0156**          		DW24  FBDIV           ;DIV
0B20DB 18 21 0B    0157**          		DW24  FEOR            ;EOR
0B20DE 3E 21 0B    0158**          		DW24  FMOD            ;MOD
0B20E1 2B 21 0B    0159**          		DW24  FFOR             ;OR
0B20E4 F7 23 0B    0160**          		DW24  FLE             ;<=
0B20E7 06 24 0B    0161**          		DW24  FNE             ;<>
0B20EA EA 23 0B    0162**          		DW24  FGE             ;>=
0B20ED CF 23 0B    0163**          		DW24  FLT             ;<
0B20F0 13 24 0B    0164**          		DW24  FEQ             ;=
0B20F3 BF 22 0B    0165**          		DW24  FMUL            ;*
0B20F6 AD 21 0B    0166**          		DW24  FADD            ;+
0B20F9 DC 23 0B    0167**          		DW24  FGT             ;>
0B20FC 94 21 0B    0168**          		DW24  FSUB            ;-
0B20FF 9C 23 0B    0169**          		DW24  FPOW            ;^
0B2102 16 22 0B    0170**          		DW24  FDIV            ;/
0B2105             0171**  ;
0B2105             0172**  ;       PAGE
0B2105             0173**  ;
0B2105             0174**  ;ARITHMETIC AND LOGICAL OPERATORS:
0B2105             0175**  ;All take two arguments, in HLH'L'C & DED'E'B.
0B2105             0176**  ;Output in HLH'L'C
0B2105             0177**  ;All registers except IX, IY destroyed.
0B2105             0178**  ; (N.B. FPOW destroys IX).
0B2105             0179**  ;
0B2105             0180**  ;FAND - Floating-point AND.
0B2105             0181**  ;IAND - Integer AND.
0B2105             0182**  ;
0B2105 CD 6F 2A 0B 0183**  FAND:			CALL    FIX2
0B2109 7C          0184**  IAND:			LD      A,H
0B210A A2          0185**          		AND     D
0B210B 67          0186**          		LD      H,A
0B210C 7D          0187**          		LD      A,L
0B210D A3          0188**          		AND     E
0B210E 6F          0189**          		LD      L,A
0B210F D9          0190**          		EXX
0B2110 7C          0191**          		LD      A,H
0B2111 A2          0192**          		AND     D
0B2112 67          0193**          		LD      H,A
0B2113 7D          0194**          		LD      A,L
0B2114 A3          0195**          		AND     E
0B2115 6F          0196**          		LD      L,A
0B2116 D9          0197**          		EXX
0B2117 C9          0198**          		RET
0B2118             0199**  ;
0B2118             0200**  ;FEOR - Floating-point exclusive-OR.
0B2118             0201**  ;IEOR - Integer exclusive-OR.
0B2118             0202**  ;
0B2118 CD 6F 2A 0B 0203**  FEOR:			CALL    FIX2
0B211C 7C          0204**  IEOR:			LD      A,H
0B211D AA          0205**          		XOR     D
0B211E 67          0206**          		LD      H,A
0B211F 7D          0207**          		LD      A,L
0B2120 AB          0208**          		XOR     E
0B2121 6F          0209**          		LD      L,A
0B2122 D9          0210**          		EXX
0B2123 7C          0211**          		LD      A,H
0B2124 AA          0212**          		XOR     D
0B2125 67          0213**          		LD      H,A
0B2126 7D          0214**          		LD      A,L
0B2127 AB          0215**          		XOR     E
0B2128 6F          0216**          		LD      L,A
0B2129 D9          0217**          		EXX
0B212A C9          0218**          		RET
0B212B             0219**  ;
0B212B             0220**  ;FOR - Floating-point OR.
0B212B             0221**  ;IOR - Integer OR.
0B212B             0222**  ;
0B212B CD 6F 2A 0B 0223**  FFOR:			CALL    FIX2
0B212F 7C          0224**  IOR:			LD      A,H
0B2130 B2          0225**          		OR      D
0B2131 67          0226**          		LD      H,A
0B2132 7D          0227**          		LD      A,L
0B2133 B3          0228**          		OR      E
0B2134 6F          0229**          		LD      L,A
0B2135 D9          0230**          		EXX
0B2136 7C          0231**          		LD      A,H
0B2137 B2          0232**          		OR      D
0B2138 67          0233**          		LD      H,A
0B2139 7D          0234**          		LD      A,L
0B213A B3          0235**          		OR      E
0B213B 6F          0236**          		LD      L,A
0B213C D9          0237**          		EXX
0B213D C9          0238**          		RET
0B213E             0239**  ;
0B213E             0240**  ;FMOD - Floating-point remainder.
0B213E             0241**  ;IMOD - Integer remainder.
0B213E             0242**  ;
0B213E CD 6F 2A 0B 0243**  FMOD:			CALL    FIX2
0B2142 7C          0244**  IMOD:			LD      A,H
0B2143 AA          0245**          		XOR     D               ;DIV RESULT SIGN
0B2144 CB 7C       0246**          		BIT     7,H
0B2146 08          0247**          		EX      AF,AF'
0B2147 CB 7C       0248**          		BIT     7,H
0B2149 C4 8B 2A 0B 0249**          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B214D CD 88 2B 0B 0250**          		CALL    SWAP_FP
0B2151 CB 7C       0251**          		BIT     7,H
0B2153 C4 8B 2A 0B 0252**          		CALL    NZ,NEGATE
0B2157 44          0253**          		LD      B,H
0B2158 4D          0254**          		LD      C,L
0B2159 21 00 00 00 0255**          		LD      HL,0
0B215D D9          0256**          		EXX
0B215E 44          0257**          		LD      B,H
0B215F 4D          0258**          		LD      C,L
0B2160 21 00 00 00 0259**          		LD      HL,0
0B2164 3E DF       0260**          		LD      A,-33
0B2166 CD 15 2D 0B 0261**          		CALL    DIVA            ;DIVIDE
0B216A D9          0262**          		EXX
0B216B 0E 00       0263**          		LD      C,0             ;INTEGER MARKER
0B216D 08          0264**          		EX      AF,AF'
0B216E C8          0265**          		RET     Z
0B216F C3 8B 2A 0B 0266**          		JP      NEGATE
0B2173             0267**  ;
0B2173             0268**  ;BDIV - Integer division.
0B2173             0269**  ;
0B2173 CD 6F 2A 0B 0270**  FBDIV:			CALL    FIX2
0B2177 CD 42 21 0B 0271**  IBDIV:			CALL    IMOD
0B217B B7          0272**          		OR      A
0B217C CD 88 2B 0B 0273**          		CALL    SWAP_FP
0B2180 0E 00       0274**          		LD      C,0
0B2182 F0          0275**          		RET     P
0B2183 C3 8B 2A 0B 0276**          		JP      NEGATE
0B2187             0277**  ;
0B2187             0278**  ;ISUB - Integer subtraction.
0B2187             0279**  ;FSUB - Floating point subtraction with rounding.
0B2187             0280**  ;
0B2187 CD 23 2C 0B 0281**  ISUB:			CALL    SUB_
0B218B E0          0282**          		RET     PO
0B218C CD 1B 2C 0B 0283**          		CALL    ADD_
0B2190 CD 4B 2B 0B 0284**          		CALL    FLOAT2
0B2194 7A          0285**  FSUB:			LD      A,D
0B2195 EE 80       0286**          		XOR     80H             ;CHANGE SIGN THEN ADD
0B2197 57          0287**          		LD      D,A
0B2198 18 13       0288**          		JR      FADD
0B219A             0289**  ;
0B219A             0290**  ;Reverse subtract.
0B219A             0291**  ;
0B219A 7C          0292**  RSUB:			LD      A,H
0B219B EE 80       0293**          		XOR     80H
0B219D 67          0294**          		LD      H,A
0B219E 18 0D       0295**          		JR      FADD
0B21A0             0296**  ;
0B21A0             0297**  ;IADD - Integer addition.
0B21A0             0298**  ;FADD - Floating point addition with rounding.
0B21A0             0299**  ;
0B21A0 CD 1B 2C 0B 0300**  IADD:			CALL    ADD_
0B21A4 E0          0301**          		RET     PO
0B21A5 CD 23 2C 0B 0302**          		CALL    SUB_
0B21A9 CD 4B 2B 0B 0303**          		CALL    FLOAT2
0B21AD 05          0304**  FADD:			DEC     B
0B21AE 04          0305**          		INC     B
0B21AF C8          0306**          		RET     Z               ;ARG 2 ZERO
0B21B0 0D          0307**          		DEC     C
0B21B1 0C          0308**          		INC     C
0B21B2 CA 88 2B 0B 0309**          		JP      Z,SWAP_FP          ;ARG 1 ZERO
0B21B6 D9          0310**          		EXX
0B21B7 01 00 00 00 0311**          		LD      BC,0            ;INITIALISE
0B21BB D9          0312**          		EXX
0B21BC 7C          0313**          		LD      A,H
0B21BD AA          0314**          		XOR     D               ;XOR SIGNS
0B21BE F5          0315**          		PUSH    AF
0B21BF 78          0316**          		LD      A,B
0B21C0 B9          0317**          		CP      C               ;COMPARE EXPONENTS
0B21C1 DC 88 2B 0B 0318**          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B21C5 78          0319**          		LD      A,B
0B21C6 CB FC       0320**          		SET     7,H             ;IMPLIED 1
0B21C8 C4 5C 2A 0B 0321**          		CALL    NZ,FIX          ;ALIGN
0B21CC F1          0322**          		POP     AF
0B21CD 7A          0323**          		LD      A,D             ;SIGN OF LARGER
0B21CE CB FA       0324**          		SET     7,D             ;IMPLIED 1
0B21D0 FA E0 21 0B 0325**          		JP      M,FADD3         ;SIGNS DIFFERENT
0B21D4 CD 1B 2C 0B 0326**          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B21D8 DC 90 2B 0B 0327**          		CALL    C,DIV2          ;NORMALISE
0B21DC CB FC       0328**          		SET     7,H
0B21DE 18 0D       0329**          		JR      FADD4
0B21E0             0330**  ;
0B21E0 CD 23 2C 0B 0331**  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B21E4 DC A3 2A 0B 0332**          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B21E8 CD 22 2B 0B 0333**          		CALL    FLO48
0B21EC 2F          0334**          		CPL                     ;CHANGE RESULT SIGN
0B21ED D9          0335**  FADD4:			EXX
0B21EE EB          0336**          		EX      DE,HL
0B21EF 21 00 80 00 0337**          		LD      HL,8000H
0B21F3 B7          0338**          		OR      A               ;CLEAR CARRY
0B21F4 52 ED 42    0339**          		SBC.S   HL,BC
0B21F7 EB          0340**          		EX      DE,HL
0B21F8 D9          0341**          		EXX
0B21F9 CC 82 2B 0B 0342**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B21FD DC 70 2B 0B 0343**          		CALL    C,ADD1_FP          ;ROUND UP
0B2201 DC 9D 2B 0B 0344**          		CALL    C,INCC
0B2205 CB BC       0345**          		RES     7,H
0B2207 0D          0346**          		DEC     C
0B2208 0C          0347**          		INC     C
0B2209 CA D4 2B 0B 0348**          		JP      Z,ZERO_FP
0B220D B7          0349**          		OR      A               ;RESULT SIGNQ
0B220E F0          0350**          		RET     P               ;POSITIVE
0B220F CB FC       0351**          		SET     7,H             ;NEGATIVE
0B2211 C9          0352**          		RET
0B2212             0353**  ;
0B2212             0354**  ;IDIV - Integer division.
0B2212             0355**  ;FDIV - Floating point division with rounding.
0B2212             0356**  ;
0B2212 CD 4B 2B 0B 0357**  IDIV:			CALL    FLOAT2
0B2216 05          0358**  FDIV:			DEC     B               ;TEST FOR ZERO
0B2217 04          0359**          		INC     B
0B2218 3E 12       0360**          		LD      A,DIVBY0
0B221A CA 2E 20 0B 0361**          		JP      Z,ERROR_FP_         ;"Division by zero"
0B221E 0D          0362**          		DEC     C               ;TEST FOR ZERO
0B221F 0C          0363**          		INC     C
0B2220 C8          0364**          		RET     Z
0B2221 7C          0365**          		LD      A,H
0B2222 AA          0366**          		XOR     D               ;CALC. RESULT SIGN
0B2223 08          0367**          		EX      AF,AF'          ;SAVE SIGN
0B2224 CB FA       0368**          		SET     7,D             ;REPLACE IMPLIED 1's
0B2226 CB FC       0369**          		SET     7,H
0B2228 C5          0370**          		PUSH    BC              ;SAVE EXPONENTS
0B2229 42          0371**          		LD      B,D             ;LOAD REGISTERS
0B222A 4B          0372**          		LD      C,E
0B222B 11 00 00 00 0373**          		LD      DE,0
0B222F D9          0374**          		EXX
0B2230 42          0375**          		LD      B,D
0B2231 4B          0376**          		LD      C,E
0B2232 11 00 00 00 0377**          		LD      DE,0
0B2236 3E E0       0378**          		LD      A,-32           ;LOOP COUNTER
0B2238 CD 15 2D 0B 0379**          		CALL    DIVA            ;DIVIDE
0B223C D9          0380**          		EXX
0B223D CB 7A       0381**          		BIT     7,D
0B223F D9          0382**          		EXX
0B2240 CC 34 2D 0B 0383**          		CALL    Z,DIVB          ;NORMALISE & INC A
0B2244 EB          0384**          		EX      DE,HL
0B2245 D9          0385**          		EXX
0B2246 CB 38       0386**          		SRL     B               ;DIVISOR/2
0B2248 CB 19       0387**          		RR      C
0B224A B7          0388**          		OR      A               ;CLEAR CARRY
0B224B 52 ED 42    0389**          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B224E 3F          0390**          		CCF
0B224F EB          0391**          		EX      DE,HL           ;RESULT IN HLH'L'
0B2250 CC 82 2B 0B 0392**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B2254 DC 70 2B 0B 0393**          		CALL    C,ADD1_FP          ;ROUND UP
0B2258 C1          0394**          		POP     BC              ;RESTORE EXPONENTS
0B2259 DC 9D 2B 0B 0395**          		CALL    C,INCC
0B225D 1F          0396**          		RRA                     ;LSB OF A TO CARRY
0B225E 79          0397**          		LD      A,C             ;COMPUTE NEW EXPONENT
0B225F 98          0398**          		SBC     A,B
0B2260 3F          0399**          		CCF
0B2261 C3 02 23 0B 0400**          		JP      CHKOVF
0B2265             0401**  ;
0B2265             0402**  ;IMUL - Integer multiplication.
0B2265             0403**  ;
0B2265 7C          0404**  IMUL:			LD      A,H
0B2266 AA          0405**          		XOR     D
0B2267 08          0406**          		EX      AF,AF'          ;SAVE RESULT SIGN
0B2268 CB 7C       0407**          		BIT     7,H
0B226A C4 8B 2A 0B 0408**          		CALL    NZ,NEGATE
0B226E CD 88 2B 0B 0409**          		CALL    SWAP_FP
0B2272 CB 7C       0410**          		BIT     7,H
0B2274 C4 8B 2A 0B 0411**          		CALL    NZ,NEGATE
0B2278 44          0412**          		LD      B,H
0B2279 4D          0413**          		LD      C,L
0B227A 21 00 00 00 0414**          		LD      HL,0
0B227E D9          0415**          		EXX
0B227F 44          0416**          		LD      B,H
0B2280 4D          0417**          		LD      C,L
0B2281 21 00 00 00 0418**          		LD      HL,0
0B2285 3E DF       0419**          		LD      A,-33
0B2287 CD 4C 2D 0B 0420**          		CALL    MULA            ;MULTIPLY
0B228B D9          0421**          		EXX
0B228C 0E BF       0422**          		LD      C,191           ;PRESET EXPONENT
0B228E CD B0 2B 0B 0423**          		CALL    TEST_FP            ;TEST RANGE
0B2292 20 0F       0424**          		JR      NZ,IMUL1        ;TOO BIG
0B2294 CB 7A       0425**          		BIT     7,D
0B2296 20 0B       0426**          		JR      NZ,IMUL1
0B2298 CD 88 2B 0B 0427**          		CALL    SWAP_FP
0B229C 4A          0428**          		LD      C,D             ;INTEGER MARKER
0B229D 08          0429**          		EX      AF,AF'
0B229E F0          0430**          		RET     P
0B229F C3 8B 2A 0B 0431**          		JP      NEGATE
0B22A3             0432**  ;
0B22A3 0D          0433**  IMUL1:			DEC     C
0B22A4 D9          0434**          		EXX
0B22A5 CB 23       0435**          		SLA     E
0B22A7 CB 12       0436**          		RL      D
0B22A9 D9          0437**          		EXX
0B22AA CB 13       0438**          		RL      E
0B22AC CB 12       0439**          		RL      D
0B22AE D9          0440**          		EXX
0B22AF 52 ED 6A    0441**          		ADC.S   HL,HL
0B22B2 D9          0442**          		EXX
0B22B3 52 ED 6A    0443**          		ADC.S   HL,HL
0B22B6 F2 A3 22 0B 0444**          		JP      P,IMUL1         ;NORMALISE
0B22BA 08          0445**          		EX      AF,AF'
0B22BB F8          0446**          		RET     M
0B22BC CB BC       0447**          		RES     7,H             ;POSITIVE
0B22BE C9          0448**          		RET
0B22BF             0449**  ;
0B22BF             0450**  ;FMUL - Floating point multiplication with rounding.
0B22BF             0451**  ;
0B22BF 05          0452**  FMUL:			DEC     B               ;TEST FOR ZERO
0B22C0 04          0453**          		INC     B
0B22C1 CA D4 2B 0B 0454**          		JP      Z,ZERO_FP
0B22C5 0D          0455**          		DEC     C               ;TEST FOR ZERO
0B22C6 0C          0456**          		INC     C
0B22C7 C8          0457**          		RET     Z
0B22C8 7C          0458**          		LD      A,H
0B22C9 AA          0459**          		XOR     D               ;CALC. RESULT SIGN
0B22CA 08          0460**          		EX      AF,AF'
0B22CB CB FA       0461**          		SET     7,D             ;REPLACE IMPLIED 1's
0B22CD CB FC       0462**          		SET     7,H
0B22CF C5          0463**          		PUSH    BC              ;SAVE EXPONENTS
0B22D0 44          0464**          		LD      B,H             ;LOAD REGISTERS
0B22D1 4D          0465**          		LD      C,L
0B22D2 21 00 00 00 0466**          		LD      HL,0
0B22D6 D9          0467**          		EXX
0B22D7 44          0468**          		LD      B,H
0B22D8 4D          0469**          		LD      C,L
0B22D9 21 00 00 00 0470**          		LD      HL,0
0B22DD 3E E0       0471**          		LD      A,-32           ;LOOP COUNTER
0B22DF CD 4C 2D 0B 0472**          		CALL    MULA            ;MULTIPLY
0B22E3 DC 62 2D 0B 0473**          		CALL    C,MULB          ;NORMALISE & INC A
0B22E7 D9          0474**          		EXX
0B22E8 E5          0475**          		PUSH    HL
0B22E9 21 00 80 00 0476**          		LD      HL,8000H
0B22ED B7          0477**          		OR      A               ;CLEAR CARRY
0B22EE 52 ED 52    0478**          		SBC.S   HL,DE
0B22F1 E1          0479**          		POP     HL
0B22F2 CC 82 2B 0B 0480**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B22F6 DC 70 2B 0B 0481**          		CALL    C,ADD1_FP          ;ROUND UP
0B22FA C1          0482**          		POP     BC              ;RESTORE EXPONENTS
0B22FB DC 9D 2B 0B 0483**          		CALL    C,INCC
0B22FF 1F          0484**          		RRA                     ;LSB OF A TO CARRY
0B2300 79          0485**          		LD      A,C             ;COMPUTE NEW EXPONENT
0B2301 88          0486**          		ADC     A,B
0B2302 38 06       0487**  CHKOVF:			JR      C,CHKO1
0B2304 F2 D4 2B 0B 0488**          		JP      P,ZERO_FP          ;UNDERFLOW
0B2308 18 04       0489**          		JR      CHKO2
0B230A FA 9F 2B 0B 0490**  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B230E C6 80       0491**  CHKO2:			ADD     A,80H
0B2310 4F          0492**          		LD      C,A
0B2311 CA D4 2B 0B 0493**          		JP      Z,ZERO_FP
0B2315 08          0494**          		EX      AF,AF'          ;RESTORE SIGN BIT
0B2316 CB BC       0495**          		RES     7,H
0B2318 F0          0496**          		RET     P
0B2319 CB FC       0497**          		SET     7,H
0B231B C9          0498**          		RET
0B231C             0499**  ;
0B231C             0500**  ;IPOW - Integer involution.
0B231C             0501**  ;
0B231C CD 88 2B 0B 0502**  IPOW:			CALL    SWAP_FP
0B2320 CB 7C       0503**          		BIT     7,H
0B2322 F5          0504**          		PUSH    AF              ;SAVE SIGN
0B2323 C4 8B 2A 0B 0505**          		CALL    NZ,NEGATE
0B2327 48          0506**  IPOW0:			LD      C,B
0B2328 06 20       0507**          		LD      B,32            ;LOOP COUNTER
0B232A CD 40 2C 0B 0508**  IPOW1:			CALL    X2
0B232E 38 08       0509**          		JR      C,IPOW2
0B2330 10 F8       0510**          		DJNZ    IPOW1
0B2332 F1          0511**          		POP     AF
0B2333 D9          0512**          		EXX
0B2334 2C          0513**          		INC     L               ;RESULT=1
0B2335 D9          0514**          		EXX
0B2336 4C          0515**          		LD      C,H
0B2337 C9          0516**          		RET
0B2338             0517**  ;
0B2338 F1          0518**  IPOW2:			POP     AF
0B2339 C5          0519**          		PUSH    BC
0B233A EB          0520**          		EX      DE,HL
0B233B E5          0521**          		PUSH    HL
0B233C D9          0522**          		EXX
0B233D EB          0523**          		EX      DE,HL
0B233E E5          0524**          		PUSH    HL
0B233F D9          0525**          		EXX
0B2340 DD 21 00 00 0526**          		LD      IX,0
       00          
0B2345 DD 39       0527**          		ADD     IX,SP
0B2347 28 48       0528**          		JR      Z,IPOW4
0B2349 C5          0529**          		PUSH    BC
0B234A D9          0530**          		EXX
0B234B D5          0531**          		PUSH    DE
0B234C D9          0532**          		EXX
0B234D D5          0533**          		PUSH    DE
0B234E CD 57 2B 0B 0534**          		CALL    SFLOAT_FP
0B2352 CD 8B 26 0B 0535**          		CALL    RECIP
0B2356 DD 71 04    0536**          		LD      (IX+4),C
0B2359 D9          0537**          		EXX
0B235A DD 75 00    0538**          		LD      (IX+0),L
0B235D DD 74 01    0539**          		LD      (IX+1),H
0B2360 D9          0540**          		EXX
0B2361 DD 75 02    0541**          		LD      (IX+2),L
0B2364 DD 74 03    0542**          		LD      (IX+3),H
0B2367 18 21       0543**          		JR      IPOW5
0B2369             0544**  ;
0B2369 C5          0545**  IPOW3:			PUSH    BC
0B236A D9          0546**          		EXX
0B236B CB 23       0547**          		SLA     E
0B236D CB 12       0548**          		RL      D
0B236F D5          0549**          		PUSH    DE
0B2370 D9          0550**          		EXX
0B2371 CB 13       0551**          		RL      E
0B2373 CB 12       0552**          		RL      D
0B2375 D5          0553**          		PUSH    DE
0B2376 3E 0A       0554**          		LD      A,'*' & 0FH
0B2378 F5          0555**          		PUSH    AF
0B2379 CD 54 2C 0B 0556**          		CALL    COPY_
0B237D CD 34 20 0B 0557**          		CALL    OP              ;SQUARE
0B2381 F1          0558**          		POP     AF
0B2382 CD 80 29 0B 0559**          		CALL    DLOAD5
0B2386 DC 34 20 0B 0560**          		CALL    C,OP            ;MULTIPLY BY X
0B238A D1          0561**  IPOW5:			POP     DE
0B238B D9          0562**          		EXX
0B238C D1          0563**          		POP     DE
0B238D D9          0564**          		EXX
0B238E 79          0565**          		LD      A,C
0B238F C1          0566**          		POP     BC
0B2390 4F          0567**          		LD      C,A
0B2391 10 D6       0568**  IPOW4:			DJNZ    IPOW3
0B2393 F1          0569**          		POP     AF
0B2394 F1          0570**          		POP     AF
0B2395 F1          0571**          		POP     AF
0B2396 C9          0572**          		RET
0B2397             0573**  ;
0B2397 F1          0574**  FPOW0:			POP     AF
0B2398 F1          0575**          		POP     AF
0B2399 F1          0576**          		POP     AF
0B239A 18 8B       0577**          		JR      IPOW0
0B239C             0578**  ;
0B239C             0579**  ;FPOW - Floating-point involution.
0B239C             0580**  ;
0B239C CB 7A       0581**  FPOW:			BIT     7,D
0B239E F5          0582**          		PUSH    AF
0B239F CD 88 2B 0B 0583**          		CALL    SWAP_FP
0B23A3 CD 64 2C 0B 0584**          		CALL    PUSH5
0B23A7 0D          0585**          		DEC     C
0B23A8 0C          0586**          		INC     C
0B23A9 28 EC       0587**          		JR      Z,FPOW0
0B23AB 3E 9E       0588**          		LD      A,158
0B23AD B9          0589**          		CP      C
0B23AE 38 0A       0590**          		JR      C,FPOW1
0B23B0 3C          0591**          		INC     A
0B23B1 CD 5C 2A 0B 0592**          		CALL    FIX
0B23B5 08          0593**          		EX      AF,AF'
0B23B6 F2 97 23 0B 0594**          		JP      P,FPOW0
0B23BA CD 88 2B 0B 0595**  FPOW1:			CALL    SWAP_FP
0B23BE CD A8 26 0B 0596**          		CALL    LN0
0B23C2 CD 6D 2C 0B 0597**          		CALL    POP5
0B23C6 F1          0598**          		POP     AF
0B23C7 CD BF 22 0B 0599**          		CALL    FMUL
0B23CB C3 0A 26 0B 0600**          		JP      EXP0
0B23CF             0601**  ;
0B23CF             0602**  ;Integer and floating-point compare.
0B23CF             0603**  ;Result is TRUE (-1) or FALSE (0).
0B23CF             0604**  ;
0B23CF CD DE 2B 0B 0605**  FLT:			CALL    FCP
0B23D3 18 04       0606**          		JR      ILT1
0B23D5 CD D0 2B 0B 0607**  ILT:			CALL    ICP
0B23D9 D0          0608**  ILT1:			RET     NC
0B23DA 18 42       0609**          		JR      TRUE_FP
0B23DC             0610**  ;
0B23DC CD DE 2B 0B 0611**  FGT:			CALL    FCP
0B23E0 18 04       0612**          		JR      IGT1
0B23E2 CD D0 2B 0B 0613**  IGT:			CALL    ICP
0B23E6 C8          0614**  IGT1:			RET     Z
0B23E7 D8          0615**          		RET     C
0B23E8 18 34       0616**          		JR      TRUE_FP
0B23EA             0617**  ;
0B23EA CD DE 2B 0B 0618**  FGE:			CALL    FCP
0B23EE 18 04       0619**          		JR      IGE1
0B23F0 CD D0 2B 0B 0620**  IGE:			CALL    ICP
0B23F4 D8          0621**  IGE1:			RET     C
0B23F5 18 27       0622**          		JR      TRUE_FP
0B23F7             0623**  ;
0B23F7 CD DE 2B 0B 0624**  FLE:			CALL    FCP
0B23FB 18 04       0625**          		JR      ILE1
0B23FD CD D0 2B 0B 0626**  ILE:			CALL    ICP
0B2401 28 1B       0627**  ILE1:			JR      Z,TRUE_FP
0B2403 D0          0628**          		RET     NC
0B2404 18 18       0629**          		JR      TRUE_FP
0B2406             0630**  ;
0B2406 CD DE 2B 0B 0631**  FNE:			CALL    FCP
0B240A 18 04       0632**          		JR      INE1
0B240C CD D0 2B 0B 0633**  INE:			CALL    ICP
0B2410 C8          0634**  INE1:			RET     Z
0B2411 18 0B       0635**          		JR      TRUE_FP
0B2413             0636**  ;
0B2413 CD DE 2B 0B 0637**  FEQ:			CALL    FCP
0B2417 18 04       0638**          		JR      IEQ1
0B2419 CD D0 2B 0B 0639**  IEQ:			CALL    ICP
0B241D C0          0640**  IEQ1:			RET     NZ
0B241E 21 FF FF FF 0641**  TRUE_FP:			LD      HL,-1
0B2422 D9          0642**          		EXX
0B2423 21 FF FF FF 0643**          		LD      HL,-1
0B2427 D9          0644**          		EXX
0B2428 AF          0645**          		XOR     A
0B2429 4F          0646**          		LD      C,A
0B242A C9          0647**          		RET
0B242B             0648**  ;
0B242B             0649**  ;FUNCTIONS:
0B242B             0650**  ;
0B242B             0651**  ;Result returned in HLH'L'C (floating point)
0B242B             0652**  ;Result returned in HLH'L' (C=0) (integer)
0B242B             0653**  ;All registers except IY destroyed.
0B242B             0654**  ;
0B242B             0655**  ;ABS - Absolute value
0B242B             0656**  ;Result is numeric, variable type.
0B242B             0657**  ;
0B242B CB 7C       0658**  ABSV_FP:			BIT     7,H
0B242D C8          0659**          		RET     Z               ;POSITIVE/ZERO
0B242E 0D          0660**          		DEC     C
0B242F 0C          0661**          		INC     C
0B2430 CA 8B 2A 0B 0662**          		JP      Z,NEGATE        ;INTEGER
0B2434 CB BC       0663**          		RES     7,H
0B2436 C9          0664**          		RET
0B2437             0665**  ;
0B2437             0666**  ;NOT - Complement integer.
0B2437             0667**  ;Result is integer numeric.
0B2437             0668**  ;
0B2437 CD 7B 2A 0B 0669**  NOTK_FP:			CALL    SFIX_FP
0B243B 7C          0670**          		LD      A,H
0B243C 2F          0671**          		CPL
0B243D 67          0672**          		LD      H,A
0B243E 7D          0673**          		LD      A,L
0B243F 2F          0674**          		CPL
0B2440 6F          0675**          		LD      L,A
0B2441 D9          0676**          		EXX
0B2442 7C          0677**          		LD      A,H
0B2443 2F          0678**          		CPL
0B2444 67          0679**          		LD      H,A
0B2445 7D          0680**          		LD      A,L
0B2446 2F          0681**          		CPL
0B2447 6F          0682**          		LD      L,A
0B2448 D9          0683**          		EXX
0B2449 AF          0684**          		XOR     A               ;NUMERIC MARKER
0B244A C9          0685**          		RET
0B244B             0686**  ;
0B244B             0687**  ;PI - Return PI (3.141592654)
0B244B             0688**  ;Result is floating-point numeric.
0B244B             0689**  ;
0B244B 21 0F 49 00 0690**  PI_FP:			LD      HL,490FH
0B244F D9          0691**          		EXX
0B2450 21 A2 DA 00 0692**          		LD      HL,0DAA2H
0B2454 D9          0693**          		EXX
0B2455 0E 81       0694**          		LD      C,81H
0B2457 AF          0695**          		XOR     A               ;NUMERIC MARKER
0B2458 C9          0696**          		RET
0B2459             0697**  ;
0B2459             0698**  ;DEG - Convert radians to degrees
0B2459             0699**  ;Result is floating-point numeric.
0B2459             0700**  ;
0B2459 CD 6D 24 0B 0701**  DEG_FP:			CALL    FPI180
0B245D CD BF 22 0B 0702**          		CALL    FMUL
0B2461 AF          0703**          		XOR     A
0B2462 C9          0704**          		RET
0B2463             0705**  ;
0B2463             0706**  ;RAD - Convert degrees to radians
0B2463             0707**  ;Result is floating-point numeric.
0B2463             0708**  ;
0B2463 CD 6D 24 0B 0709**  RAD_FP:			CALL    FPI180
0B2467 CD 16 22 0B 0710**          		CALL    FDIV
0B246B AF          0711**          		XOR     A
0B246C C9          0712**          		RET
0B246D             0713**  ;
0B246D             0714**  ;180/PI
0B246D             0715**  ;
0B246D CD 57 2B 0B 0716**  FPI180:			CALL    SFLOAT_FP
0B2471 11 2E 65 00 0717**          		LD      DE,652EH
0B2475 D9          0718**          		EXX
0B2476 11 D3 E0 00 0719**          		LD      DE,0E0D3H
0B247A D9          0720**          		EXX
0B247B 06 85       0721**          		LD      B,85H
0B247D C9          0722**          		RET
0B247E             0723**  ;
0B247E             0724**  ;SGN - Return -1, 0 or +1
0B247E             0725**  ;Result is integer numeric.
0B247E             0726**  ;
0B247E CD B0 2B 0B 0727**  SGN_FP:			CALL    TEST_FP
0B2482 B1          0728**          		OR      C
0B2483 C8          0729**          		RET     Z               ;ZERO
0B2484 CB 7C       0730**          		BIT     7,H
0B2486 C2 1E 24 0B 0731**          		JP      NZ,TRUE_FP         ;-1
0B248A CD D4 2B 0B 0732**          		CALL    ZERO_FP
0B248E C3 70 2B 0B 0733**          		JP      ADD1_FP            ;1
0B2492             0734**  ;
0B2492             0735**  ;VAL - Return numeric value of string.
0B2492             0736**  ;Input: ASCII string at IX
0B2492             0737**  ;Result is variable type numeric.
0B2492             0738**  ;
0B2492 CD EE 2D 0B 0739**  VAL_FP:			CALL    SIGNQ
0B2496 F5          0740**          		PUSH    AF
0B2497 CD 9E 29 0B 0741**          		CALL    CON_FP
0B249B F1          0742**          		POP     AF
0B249C FE 2D       0743**          		CP      '-'
0B249E 3E 00       0744**          		LD      A,0             ;NUMERIC MARKER
0B24A0 C0          0745**          		RET     NZ
0B24A1 0D          0746**          		DEC     C
0B24A2 0C          0747**          		INC     C
0B24A3 CA 8B 2A 0B 0748**          		JP      Z,NEGATE        ;ZERO/INTEGER
0B24A7 7C          0749**          		LD      A,H
0B24A8 EE 80       0750**          		XOR     80H             ;CHANGE SIGN (FP)
0B24AA 67          0751**          		LD      H,A
0B24AB AF          0752**          		XOR     A
0B24AC C9          0753**          		RET
0B24AD             0754**  ;
0B24AD             0755**  ;INT - Floor function
0B24AD             0756**  ;Result is integer numeric.
0B24AD             0757**  ;
0B24AD 0D          0758**  INT_FP_:			DEC     C
0B24AE 0C          0759**          		INC     C
0B24AF C8          0760**          		RET     Z               ;ZERO/INTEGER
0B24B0 3E 9F       0761**          		LD      A,159
0B24B2 44          0762**          		LD      B,H             ;B7=SIGN BIT
0B24B3 CD 5C 2A 0B 0763**          		CALL    FIX
0B24B7 08          0764**          		EX      AF,AF'
0B24B8 A0          0765**          		AND     B
0B24B9 FC 70 2B 0B 0766**          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B24BD 78          0767**          		LD      A,B
0B24BE B7          0768**          		OR      A
0B24BF FC 8B 2A 0B 0769**          		CALL    M,NEGATE
0B24C3 AF          0770**          		XOR     A
0B24C4 4F          0771**          		LD      C,A
0B24C5 C9          0772**          		RET
0B24C6             0773**  ;
0B24C6             0774**  ;SQR - square root
0B24C6             0775**  ;Result is floating-point numeric.
0B24C6             0776**  ;
0B24C6 CD 57 2B 0B 0777**  SQR_FP:			CALL    SFLOAT_FP
0B24CA CB 7C       0778**  SQR0:			BIT     7,H
0B24CC 3E 15       0779**          		LD      A,NGROOT
0B24CE C2 2E 20 0B 0780**          		JP      NZ,ERROR_FP_        ;"-ve root"
0B24D2 0D          0781**          		DEC     C
0B24D3 0C          0782**          		INC     C
0B24D4 C8          0783**          		RET     Z               ;ZERO
0B24D5 CB FC       0784**          		SET     7,H             ;IMPLIED 1
0B24D7 CB 41       0785**          		BIT     0,C
0B24D9 CC 90 2B 0B 0786**          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B24DD 79          0787**          		LD      A,C
0B24DE D6 80       0788**          		SUB     80H
0B24E0 CB 2F       0789**          		SRA     A               ;HALVE EXPONENT
0B24E2 C6 80       0790**          		ADD     A,80H
0B24E4 4F          0791**          		LD      C,A
0B24E5 C5          0792**          		PUSH    BC              ;SAVE EXPONENT
0B24E6 EB          0793**          		EX      DE,HL
0B24E7 21 00 00 00 0794**          		LD      HL,0
0B24EB 44          0795**          		LD      B,H
0B24EC 4D          0796**          		LD      C,L
0B24ED D9          0797**          		EXX
0B24EE EB          0798**          		EX      DE,HL
0B24EF 21 00 00 00 0799**          		LD      HL,0
0B24F3 44          0800**          		LD      B,H
0B24F4 4D          0801**          		LD      C,L
0B24F5 3E E1       0802**          		LD      A,-31
0B24F7 CD 86 2D 0B 0803**          		CALL    SQRA            ;ROOT
0B24FB D9          0804**          		EXX
0B24FC CB 78       0805**          		BIT     7,B
0B24FE D9          0806**          		EXX
0B24FF CC 86 2D 0B 0807**          		CALL    Z,SQRA          ;NORMALISE & INC A
0B2503 CD C7 2D 0B 0808**          		CALL    SQRB
0B2507 B7          0809**          		OR      A               ;CLEAR CARRY
0B2508 CD 34 2D 0B 0810**          		CALL    DIVB
0B250C CB 1B       0811**          		RR      E               ;LSB TO CARRY
0B250E 60          0812**          		LD      H,B
0B250F 69          0813**          		LD      L,C
0B2510 D9          0814**          		EXX
0B2511 60          0815**          		LD      H,B
0B2512 69          0816**          		LD      L,C
0B2513 DC 70 2B 0B 0817**          		CALL    C,ADD1_FP          ;ROUND UP
0B2517 C1          0818**          		POP     BC              ;RESTORE EXPONENT
0B2518 DC 9D 2B 0B 0819**          		CALL    C,INCC
0B251C 1F          0820**          		RRA
0B251D 9F          0821**          		SBC     A,A
0B251E 81          0822**          		ADD     A,C
0B251F 4F          0823**          		LD      C,A
0B2520 CB BC       0824**          		RES     7,H             ;POSITIVE
0B2522 AF          0825**          		XOR     A
0B2523 C9          0826**          		RET
0B2524             0827**  ;
0B2524             0828**  ;TAN - Tangent function
0B2524             0829**  ;Result is floating-point numeric.
0B2524             0830**  ;
0B2524 CD 57 2B 0B 0831**  TAN_FP:			CALL    SFLOAT_FP
0B2528 CD 64 2C 0B 0832**          		CALL    PUSH5
0B252C CD 4E 25 0B 0833**          		CALL    COS0
0B2530 CD 6D 2C 0B 0834**          		CALL    POP5
0B2534 CD 64 2C 0B 0835**          		CALL    PUSH5
0B2538 CD 88 2B 0B 0836**          		CALL    SWAP_FP
0B253C CD 5B 25 0B 0837**          		CALL    SIN0
0B2540 CD 6D 2C 0B 0838**          		CALL    POP5
0B2544 CD 16 22 0B 0839**          		CALL    FDIV
0B2548 AF          0840**          		XOR     A               ;NUMERIC MARKER
0B2549 C9          0841**          		RET
0B254A             0842**  ;
0B254A             0843**  ;COS - Cosine function
0B254A             0844**  ;Result is floating-point numeric.
0B254A             0845**  ;
0B254A CD 57 2B 0B 0846**  COS_FP:			CALL    SFLOAT_FP
0B254E CD B3 2A 0B 0847**  COS0:			CALL    SCALE
0B2552 1C          0848**          		INC     E
0B2553 1C          0849**          		INC     E
0B2554 7B          0850**          		LD      A,E
0B2555 18 10       0851**          		JR      SIN1
0B2557             0852**  ;
0B2557             0853**  ;SIN - Sine function
0B2557             0854**  ;Result is floating-point numeric.
0B2557             0855**  ;
0B2557 CD 57 2B 0B 0856**  SIN_FP:			CALL    SFLOAT_FP
0B255B E5          0857**  SIN0:			PUSH    HL              ;H7=SIGN
0B255C CD B3 2A 0B 0858**          		CALL    SCALE
0B2560 F1          0859**          		POP     AF
0B2561 07          0860**          		RLCA
0B2562 07          0861**          		RLCA
0B2563 07          0862**          		RLCA
0B2564 E6 04       0863**          		AND     4
0B2566 AB          0864**          		XOR     E
0B2567 F5          0865**  SIN1:			PUSH    AF              ;OCTANT
0B2568 CB BC       0866**          		RES     7,H
0B256A 1F          0867**          		RRA
0B256B CD F9 25 0B 0868**          		CALL    PIBY4
0B256F DC 9A 21 0B 0869**          		CALL    C,RSUB          ;X=(PI/4)-X
0B2573 F1          0870**          		POP     AF
0B2574 F5          0871**          		PUSH    AF
0B2575 E6 03       0872**          		AND     3
0B2577 E2 B0 25 0B 0873**          		JP      PO,SIN2         ;USE COSINE APPROX.
0B257B CD 64 2C 0B 0874**          		CALL    PUSH5           ;SAVE X
0B257F CD 5C 2C 0B 0875**          		CALL    SQUARE          ;PUSH X*X
0B2583 CD A1 2C 0B 0876**          		CALL    POLY
0B2587 B7 A8       0877**          		DW	0A8B7H          ;a(8)
0B2589 11 36       0878**          		DW	3611H
0B258B 6D          0879**          		DB	6DH
0B258C 26 DE       0880**          		DW	0DE26H          ;a(6)
0B258E 05 D0       0881**          		DW	0D005H
0B2590 73          0882**          		DB	73H
0B2591 C0 80       0883**          		DW	80C0H           ;a(4)
0B2593 88 08       0884**          		DW	888H
0B2595 79          0885**          		DB	79H
0B2596 9D AA       0886**          		DW	0AA9DH          ;a(2)
0B2598 AA AA       0887**          		DW	0AAAAH
0B259A 7D          0888**          		DB	7DH
0B259B 00 00       0889**          		DW	0               ;a(0)
0B259D 00 00       0890**          		DW	0
0B259F 80          0891**          		DB	80H
0B25A0 CD 6D 2C 0B 0892**          		CALL    POP5
0B25A4 CD 6D 2C 0B 0893**          		CALL    POP5
0B25A8 CD BF 22 0B 0894**          		CALL    FMUL
0B25AC C3 D5 25 0B 0895**          		JP      SIN3
0B25B0             0896**  ;
0B25B0 CD 5C 2C 0B 0897**  SIN2:			CALL    SQUARE          ;PUSH X*X
0B25B4 CD A1 2C 0B 0898**          		CALL    POLY
0B25B8 71 D5       0899**          		DW	0D571H          ;b(8)
0B25BA 78 4C       0900**          		DW	4C78H
0B25BC 70          0901**          		DB	70H
0B25BD AF 94       0902**          		DW	94AFH           ;b(6)
0B25BF 03 B6       0903**          		DW	0B603H
0B25C1 76          0904**          		DB	76H
0B25C2 C8 9C       0905**          		DW	9CC8H           ;b(4)
0B25C4 AA 2A       0906**          		DW	2AAAH
0B25C6 7B          0907**          		DB	7BH
0B25C7 DD FF       0908**          		DW	0FFDDH          ;b(2)
0B25C9 FF FF       0909**          		DW	0FFFFH
0B25CB 7E          0910**          		DB	7EH
0B25CC 00 00       0911**          		DW	0               ;b(0)
0B25CE 00 00       0912**          		DW	0
0B25D0 80          0913**          		DB	80H
0B25D1 CD 6D 2C 0B 0914**          		CALL    POP5
0B25D5 F1          0915**  SIN3:			POP     AF
0B25D6 E6 04       0916**          		AND     4
0B25D8 C8          0917**          		RET     Z
0B25D9 0D          0918**          		DEC     C
0B25DA 0C          0919**          		INC     C
0B25DB C8          0920**          		RET     Z               ;ZERO
0B25DC CB FC       0921**          		SET     7,H             ;MAKE NEGATIVE
0B25DE C9          0922**          		RET
0B25DF             0923**  ;
0B25DF             0924**  ;Floating-point one:
0B25DF             0925**  ;
0B25DF 21 00 00 00 0926**  FONE_FP:			LD      HL,0
0B25E3 D9          0927**          		EXX
0B25E4 21 00 00 00 0928**          		LD      HL,0
0B25E8 D9          0929**          		EXX
0B25E9 0E 80       0930**          		LD      C,80H
0B25EB C9          0931**          		RET
0B25EC             0932**  ;
0B25EC 11 00 00 00 0933**  DONE:			LD      DE,0
0B25F0 D9          0934**          		EXX
0B25F1 11 00 00 00 0935**          		LD      DE,0
0B25F5 D9          0936**          		EXX
0B25F6 06 80       0937**          		LD      B,80H
0B25F8 C9          0938**          		RET
0B25F9             0939**  ;
0B25F9 11 0F 49 00 0940**  PIBY4:			LD      DE,490FH
0B25FD D9          0941**          		EXX
0B25FE 11 A2 DA 00 0942**          		LD      DE,0DAA2H
0B2602 D9          0943**          		EXX
0B2603 06 7F       0944**          		LD      B,7FH
0B2605 C9          0945**          		RET
0B2606             0946**  ;
0B2606             0947**  ;EXP - Exponential function
0B2606             0948**  ;Result is floating-point numeric.
0B2606             0949**  ;
0B2606 CD 57 2B 0B 0950**  EXP_FP:			CALL    SFLOAT_FP
0B260A CD 97 26 0B 0951**  EXP0:			CALL    LN2             ;LN(2)
0B260E D9          0952**          		EXX
0B260F 1D          0953**  	        	DEC     E
0B2610 01 CF D1 00 0954**  		        LD      BC,0D1CFH       ;0.6931471805599453
0B2614 D9          0955**          		EXX
0B2615 E5          0956**          		PUSH    HL              ;H7=SIGN
0B2616 CD C6 2A 0B 0957**          		CALL    MOD48           ;"MODULUS"
0B261A F1          0958**          		POP     AF
0B261B CB 7B       0959**          		BIT     7,E
0B261D 28 0B       0960**          		JR      Z,EXP1
0B261F 17          0961**          		RLA
0B2620 DA D4 2B 0B 0962**          		JP      C,ZERO_FP
0B2624 3E 18       0963**          		LD      A,EXPRNG
0B2626 C3 2E 20 0B 0964**          		JP      ERROR_FP_           ;"Exp range"
0B262A             0965**  ;
0B262A E6 80       0966**  EXP1:			AND     80H
0B262C B3          0967**          		OR      E
0B262D F5          0968**          		PUSH    AF              ;INTEGER PART
0B262E CB BC       0969**          		RES     7,H
0B2630 CD 64 2C 0B 0970**          		CALL    PUSH5           ;PUSH X*LN(2)
0B2634 CD A1 2C 0B 0971**          		CALL    POLY
0B2638 72 40       0972**          		DW	4072H           ;a(7)
0B263A 2E 94       0973**          		DW	942EH
0B263C 73          0974**          		DB	73H
0B263D 65 6F       0975**          		DW	6F65H           ;a(6)
0B263F 4F 2E       0976**          		DW	2E4FH
0B2641 76          0977**          		DB	76H
0B2642 37 6D       0978**          		DW	6D37H           ;a(5)
0B2644 02 88       0979**          		DW	8802H
0B2646 79          0980**          		DB	79H
0B2647 12 E5       0981**          		DW	0E512H          ;a(4)
0B2649 A0 2A       0982**          		DW	2AA0H
0B264B 7B          0983**          		DB	7BH
0B264C 14 4F       0984**          		DW	4F14H           ;a(3)
0B264E AA AA       0985**          		DW	0AAAAH
0B2650 7D          0986**          		DB	7DH
0B2651 56 FD       0987**          		DW	0FD56H          ;a(2)
0B2653 FF 7F       0988**          		DW	7FFFH
0B2655 7E          0989**          		DB	7EH
0B2656 FE FF       0990**          		DW	0FFFEH          ;a(1)
0B2658 FF FF       0991**          		DW	0FFFFH
0B265A 7F          0992**          		DB	7FH
0B265B 00 00       0993**          		DW	0               ;a(0)
0B265D 00 00       0994**          		DW	0
0B265F 80          0995**          		DB	80H
0B2660 CD 6D 2C 0B 0996**          		CALL    POP5
0B2664 F1          0997**          		POP     AF
0B2665 F5          0998**          		PUSH    AF
0B2666 F4 8B 26 0B 0999**          		CALL    P,RECIP         ;X=1/X
0B266A F1          1000**          		POP     AF
0B266B F2 73 26 0B 1001**          		JP      P,EXP4
0B266F E6 7F       1002**          		AND     7FH
0B2671 ED 44       1003**          		NEG
0B2673 C6 80       1004**  EXP4:			ADD     A,80H
0B2675 81          1005**          		ADD     A,C
0B2676 38 06       1006**          		JR      C,EXP2
0B2678 F2 D4 2B 0B 1007**          		JP      P,ZERO_FP          ;UNDERFLOW
0B267C 18 04       1008**          		JR      EXP3
0B267E FA 9F 2B 0B 1009**  EXP2:			JP      M,OFLOW         ;OVERFLOW
0B2682 C6 80       1010**  EXP3:			ADD     A,80H
0B2684 CA D4 2B 0B 1011**          		JP      Z,ZERO_FP
0B2688 4F          1012**          		LD      C,A
0B2689 AF          1013**          		XOR     A               ;NUMERIC MARKER
0B268A C9          1014**          		RET
0B268B             1015**  ;
0B268B CD EC 25 0B 1016**  RECIP:			CALL    DONE
0B268F CD 88 2B 0B 1017**  RDIV:			CALL    SWAP_FP
0B2693 C3 16 22 0B 1018**          		JP      FDIV            ;RECIPROCAL
0B2697             1019**  ;
0B2697 11 72 31 00 1020**  LN2:			LD      DE,3172H        ;LN(2)
0B269B D9          1021**          		EXX
0B269C 11 F8 17 00 1022**          		LD      DE,17F8H
0B26A0 D9          1023**          		EXX
0B26A1 06 7F       1024**          		LD      B,7FH
0B26A3 C9          1025**          		RET
0B26A4             1026**  ;
0B26A4             1027**  ;LN - Natural log.
0B26A4             1028**  ;Result is floating-point numeric.
0B26A4             1029**  ;
0B26A4 CD 57 2B 0B 1030**  LN_FP:			CALL    SFLOAT_FP
0B26A8 3E 16       1031**  LN0:			LD      A,LOGRNG
0B26AA CB 7C       1032**          		BIT     7,H
0B26AC C2 2E 20 0B 1033**          		JP      NZ,ERROR_FP_        ;"Log range"
0B26B0 0C          1034**          		INC     C
0B26B1 0D          1035**          		DEC     C
0B26B2 CA 2E 20 0B 1036**          		JP      Z,ERROR_FP_
0B26B6 11 04 35 00 1037**          		LD      DE,3504H        ;SQR(2)
0B26BA D9          1038**          		EXX
0B26BB 11 33 F3 00 1039**          		LD      DE,0F333H       ;1.41421356237
0B26BF D9          1040**          		EXX
0B26C0 CD E7 2B 0B 1041**          		CALL    ICP0            ;MANTISSA>SQR(2)?
0B26C4 79          1042**          		LD      A,C             ;EXPONENT
0B26C5 0E 80       1043**          		LD      C,80H           ;1 <= X < 2
0B26C7 38 02       1044**          		JR      C,LN4
0B26C9 0D          1045**          		DEC     C
0B26CA 3C          1046**          		INC     A
0B26CB F5          1047**  LN4:			PUSH    AF              ;SAVE EXPONENT
0B26CC CD 79 2C 0B 1048**          		CALL    RATIO           ;X=(X-1)/(X+1)
0B26D0 CD 64 2C 0B 1049**          		CALL    PUSH5
0B26D4 CD 5C 2C 0B 1050**  		        CALL    SQUARE          ;PUSH X*X
0B26D8 CD A1 2C 0B 1051**          		CALL    POLY
0B26DC 48 CC       1052**          		DW	0CC48H          ;a(9)
0B26DE FB 74       1053**          		DW	74FBH
0B26E0 7D          1054**          		DB	7DH
0B26E1 AF AE       1055**          		DW	0AEAFH          ;a(7)
0B26E3 FF 11       1056**          		DW	11FFH
0B26E5 7E          1057**          		DB	7EH
0B26E6 8C D9       1058**          		DW	0D98CH          ;a(5)
0B26E8 CD 4C       1059**          		DW	4CCDH
0B26EA 7E          1060**          		DB	7EH
0B26EB E3 A9       1061**          		DW	0A9E3H          ;a(3)
0B26ED AA 2A       1062**          		DW	2AAAH
0B26EF 7F          1063**          		DB	7FH
0B26F0 00 00       1064**          		DW	0               ;a(1)
0B26F2 00 00       1065**          		DW	0
0B26F4 81          1066**          		DB	81H
0B26F5 CD 6D 2C 0B 1067**          		CALL    POP5
0B26F9 CD 6D 2C 0B 1068**          		CALL    POP5
0B26FD CD BF 22 0B 1069**          		CALL    FMUL
0B2701 F1          1070**          		POP     AF              ;EXPONENT
0B2702 CD 64 2C 0B 1071**          		CALL    PUSH5
0B2706 08          1072**          		EX      AF,AF'
0B2707 CD D4 2B 0B 1073**          		CALL    ZERO_FP
0B270B 08          1074**          		EX      AF,AF'
0B270C D6 80       1075**          		SUB     80H
0B270E 28 1F       1076**          		JR      Z,LN3
0B2710 30 02       1077**          		JR      NC,LN1
0B2712 2F          1078**          		CPL
0B2713 3C          1079**          		INC     A
0B2714 67          1080**  LN1:			LD      H,A
0B2715 0E 87       1081**          		LD      C,87H
0B2717 F5          1082**          		PUSH    AF
0B2718 CD 37 2B 0B 1083**          		CALL    FLOAT_
0B271C CB BC       1084**          		RES     7,H
0B271E CD 97 26 0B 1085**          		CALL    LN2
0B2722 CD BF 22 0B 1086**          		CALL    FMUL
0B2726 F1          1087**          		POP     AF
0B2727 30 06       1088**          		JR      NC,LN3
0B2729 FA 2F 27 0B 1089**          		JP      M,LN3
0B272D CB FC       1090**          		SET     7,H
0B272F CD 6D 2C 0B 1091**  LN3:			CALL    POP5
0B2733 CD AD 21 0B 1092**          		CALL    FADD
0B2737 AF          1093**          		XOR     A
0B2738 C9          1094**          		RET
0B2739             1095**  ;
0B2739             1096**  ;LOG - base-10 logarithm.
0B2739             1097**  ;Result is floating-point numeric.
0B2739             1098**  ;
0B2739 CD A4 26 0B 1099**  LOG_FP:			CALL    LN_FP
0B273D 11 5B 5E 00 1100**          		LD      DE,5E5BH        ;LOG(e)
0B2741 D9          1101**          		EXX
0B2742 11 A9 D8 00 1102**          		LD      DE,0D8A9H
0B2746 D9          1103**          		EXX
0B2747 06 7E       1104**          		LD      B,7EH
0B2749 CD BF 22 0B 1105**          		CALL    FMUL
0B274D AF          1106**          		XOR     A
0B274E C9          1107**          		RET
0B274F             1108**  ;
0B274F             1109**  ;ASN - Arc-sine
0B274F             1110**  ;Result is floating-point numeric.
0B274F             1111**  ;
0B274F CD 57 2B 0B 1112**  ASN_FP:			CALL    SFLOAT_FP
0B2753 CD 64 2C 0B 1113**          		CALL    PUSH5
0B2757 CD 54 2C 0B 1114**          		CALL    COPY_
0B275B CD BF 22 0B 1115**          		CALL    FMUL
0B275F CD EC 25 0B 1116**          		CALL    DONE
0B2763 CD 9A 21 0B 1117**          		CALL    RSUB
0B2767 CD CA 24 0B 1118**          		CALL    SQR0
0B276B CD 6D 2C 0B 1119**          		CALL    POP5
0B276F 0C          1120**          		INC     C
0B2770 0D          1121**          		DEC     C
0B2771 3E 02       1122**          		LD      A,2
0B2773 D5          1123**          		PUSH    DE
0B2774 CA F9 27 0B 1124**          		JP      Z,ACS1
0B2778 D1          1125**          		POP     DE
0B2779 CD 8F 26 0B 1126**          		CALL    RDIV
0B277D 18 04       1127**          		JR      ATN0
0B277F             1128**  ;
0B277F             1129**  ;ATN - arc-tangent
0B277F             1130**  ;Result is floating-point numeric.
0B277F             1131**  ;
0B277F CD 57 2B 0B 1132**  ATN_FP:			CALL    SFLOAT_FP
0B2783 E5          1133**  ATN0:			PUSH    HL              ;SAVE SIGN
0B2784 CB BC       1134**          		RES     7,H
0B2786 11 13 54 00 1135**          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B278A D9          1136**          		EXX
0B278B 11 D0 CC 00 1137**          		LD      DE,0CCD0H
0B278F D9          1138**          		EXX
0B2790 06 7E       1139**          		LD      B,7EH
0B2792 CD E4 2B 0B 1140**          		CALL    FCP0            ;COMPARE
0B2796 06 00       1141**          		LD      B,0
0B2798 38 22       1142**          		JR      C,ATN2
0B279A 11 82 1A 00 1143**          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B279E D9          1144**          		EXX
0B279F 11 9A 79 00 1145**          		LD      DE,799AH
0B27A3 D9          1146**          		EXX
0B27A4 06 81       1147**          		LD      B,81H
0B27A6 CD E4 2B 0B 1148**          		CALL    FCP0            ;COMPARE
0B27AA 38 0A       1149**          		JR      C,ATN1
0B27AC CD 8B 26 0B 1150**          		CALL    RECIP           ;X=1/X
0B27B0 06 02       1151**          		LD      B,2
0B27B2 C3 BC 27 0B 1152**          		JP      ATN2
0B27B6 CD 79 2C 0B 1153**  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B27BA 06 01       1154**          		LD      B,1
0B27BC C5          1155**  ATN2:			PUSH    BC              ;SAVE FLAG
0B27BD CD 64 2C 0B 1156**          		CALL    PUSH5
0B27C1 CD 5C 2C 0B 1157**          		CALL    SQUARE          ;PUSH X*X
0B27C5 CD A1 2C 0B 1158**          		CALL    POLY
0B27C9 35 F3       1159**          		DW	0F335H          ;a(13)
0B27CB D8 37       1160**          		DW	37D8H
0B27CD 7B          1161**          		DB	7BH
0B27CE 91 6B       1162**          		DW	6B91H           ;a(11)
0B27D0 B9 AA       1163**          		DW	0AAB9H
0B27D2 7C          1164**          		DB	7CH
0B27D3 DE 41       1165**          		DW	41DEH           ;a(9)
0B27D5 97 61       1166**          		DW	6197H
0B27D7 7C          1167**          		DB	7CH
0B27D8 7B 9D       1168**          		DW	9D7BH           ;a(7)
0B27DA 37 92       1169**          		DW	9237H
0B27DC 7D          1170**          		DB	7DH
0B27DD 5A 2A       1171**          		DW	2A5AH           ;a(5)
0B27DF CC 4C       1172**          		DW	4CCCH
0B27E1 7D          1173**          		DB	7DH
0B27E2 5C A9       1174**          		DW	0A95CH          ;a(3)
0B27E4 AA AA       1175**          		DW	0AAAAH
0B27E6 7E          1176**          		DB	7EH
0B27E7 00 00       1177**          		DW	0               ;a(1)
0B27E9 00 00       1178**          		DW	0
0B27EB 80          1179**          		DB	80H
0B27EC CD 6D 2C 0B 1180**          		CALL    POP5
0B27F0 CD 6D 2C 0B 1181**          		CALL    POP5
0B27F4 CD BF 22 0B 1182**          		CALL    FMUL
0B27F8 F1          1183**          		POP     AF
0B27F9 CD F9 25 0B 1184**  ACS1:			CALL    PIBY4           ;PI/4
0B27FD 1F          1185**          		RRA
0B27FE F5          1186**          		PUSH    AF
0B27FF DC AD 21 0B 1187**          		CALL    C,FADD
0B2803 F1          1188**          		POP     AF
0B2804 04          1189**          		INC     B
0B2805 1F          1190**          		RRA
0B2806 DC 9A 21 0B 1191**          		CALL    C,RSUB
0B280A F1          1192**          		POP     AF
0B280B B7          1193**          		OR      A
0B280C F0          1194**          		RET     P
0B280D CB FC       1195**          		SET     7,H             ;MAKE NEGATIVE
0B280F AF          1196**          		XOR     A
0B2810 C9          1197**          		RET
0B2811             1198**  ;
0B2811             1199**  ;ACS - Arc cosine=PI/2-ASN.
0B2811             1200**  ;Result is floating point numeric.
0B2811             1201**  ;
0B2811 CD 4F 27 0B 1202**  ACS_FP:			CALL    ASN_FP
0B2815 3E 02       1203**          		LD      A,2
0B2817 F5          1204**          		PUSH    AF
0B2818 18 DF       1205**          		JR      ACS1
0B281A             1206**  ;
0B281A             1207**  ;Function STR - convert numeric value to ASCII string.
0B281A             1208**  ;   Inputs: HLH'L'C = integer or floating-point number
0B281A             1209**  ;           DE = address at which to store string
0B281A             1210**  ;           IX = address of @% format control
0B281A             1211**  ;  Outputs: String stored, with NUL terminator
0B281A             1212**  ;
0B281A             1213**  ;First normalise for decimal output:
0B281A             1214**  ;
0B281A CD 57 2B 0B 1215**  STR_FP:			CALL    SFLOAT_FP
0B281E 06 00       1216**          		LD      B,0             ;DEFAULT PT. POSITION
0B2820 CB 7C       1217**          		BIT     7,H             ;NEGATIVE?
0B2822 28 06       1218**          		JR      Z,STR10
0B2824 CB BC       1219**          		RES     7,H
0B2826 3E 2D       1220**          		LD      A,'-'
0B2828 12          1221**          		LD      (DE),A          ;STORE SIGN
0B2829 13          1222**          		INC     DE
0B282A AF          1223**  STR10:			XOR     A               ;CLEAR A
0B282B B9          1224**          		CP      C
0B282C 28 4E       1225**          		JR      Z,STR02          ;ZERO
0B282E D5          1226**          		PUSH    DE              ;SAVE TEXT POINTER
0B282F 78          1227**          		LD      A,B
0B2830 F5          1228**  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B2831 79          1229**          		LD      A,C             ;BINARY EXPONENT
0B2832 FE A1       1230**          		CP      161
0B2834 30 1C       1231**          		JR      NC,STR14
0B2836 FE 9B       1232**          		CP      155
0B2838 30 29       1233**          		JR      NC,STR15
0B283A 2F          1234**          		CPL
0B283B FE E1       1235**          		CP      225
0B283D 38 02       1236**          		JR      C,STR13
0B283F 3E F8       1237**          		LD      A,-8
0B2841 C6 1C       1238**  STR13:			ADD     A,28
0B2843 CD D0 2C 0B 1239**          		CALL    POWR10
0B2847 F5          1240**          		PUSH    AF
0B2848 CD BF 22 0B 1241**          		CALL    FMUL
0B284C F1          1242**          		POP     AF
0B284D 47          1243**          		LD      B,A
0B284E F1          1244**          		POP     AF
0B284F 90          1245**          		SUB     B
0B2850 18 DE       1246**          		JR      STR11
0B2852 D6 20       1247**  STR14:			SUB     32
0B2854 CD D0 2C 0B 1248**          		CALL    POWR10
0B2858 F5          1249**          		PUSH    AF
0B2859 CD 16 22 0B 1250**          		CALL    FDIV
0B285D F1          1251**          		POP     AF
0B285E 47          1252**          		LD      B,A
0B285F F1          1253**          		POP     AF
0B2860 80          1254**          		ADD     A,B
0B2861 18 CD       1255**          		JR      STR11
0B2863 3E 09       1256**  STR15:			LD      A,9
0B2865 CD D0 2C 0B 1257**          		CALL    POWR10          ;10^9
0B2869 CD E4 2B 0B 1258**          		CALL    FCP0
0B286D 79          1259**          		LD      A,C
0B286E C1          1260**          		POP     BC
0B286F 4F          1261**          		LD      C,A
0B2870 CB FC       1262**          		SET     7,H             ;IMPLIED 1
0B2872 DC 0C 2C 0B 1263**          		CALL    C,X10B          ;X10, DEC B
0B2876 D1          1264**          		POP     DE              ;RESTORE TEXT POINTER
0B2877 CB B9       1265**          		RES     7,C
0B2879 3E 00       1266**          		LD      A,0
0B287B 17          1267**          		RLA                     ;PUT CARRY IN LSB
0B287C             1268**  ;
0B287C             1269**  ;At this point decimal normalisation has been done,
0B287C             1270**  ;now convert to decimal digits:
0B287C             1271**  ;      AHLH'L' = number in normalised integer form
0B287C             1272**  ;            B = decimal place adjustment
0B287C             1273**  ;            C = binary place adjustment (29-33)
0B287C             1274**  ;
0B287C 0C          1275**  STR02:			INC     C
0B287D 08          1276**          		EX      AF,AF'          ;SAVE A
0B287E 78          1277**          		LD      A,B
0B287F DD CB 02 4E 1278**          		BIT     1,(IX+2)
0B2883 20 08       1279**          		JR      NZ,STR20
0B2885 AF          1280**          		XOR     A
0B2886 DD BE 01    1281**          		CP      (IX+1)
0B2889 28 0B       1282**          		JR      Z,STR21
0B288B 3E F6       1283**          		LD      A,-10
0B288D DD 86 01    1284**  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B2890 B7          1285**          		OR      A               ;CLEAR CARRY
0B2891 FA 96 28 0B 1286**          		JP      M,STR21
0B2895 AF          1287**          		XOR     A
0B2896 F5          1288**  STR21:			PUSH    AF
0B2897 08          1289**          		EX      AF,AF'          ;RESTORE A
0B2898 CD 40 2C 0B 1290**  STR22:			CALL    X2              ;RL AHLH'L'
0B289C 8F          1291**          		ADC     A,A
0B289D FE 0A       1292**          		CP      10
0B289F 38 05       1293**          		JR      C,STR23
0B28A1 D6 0A       1294**          		SUB     10
0B28A3 D9          1295**          		EXX
0B28A4 2C          1296**          		INC     L               ;SET RESULT BIT
0B28A5 D9          1297**          		EXX
0B28A6 0D          1298**  STR23:			DEC     C
0B28A7 20 EF       1299**          		JR      NZ,STR22        ;32 TIMES
0B28A9 4F          1300**          		LD      C,A             ;REMAINDER
0B28AA 7C          1301**          		LD      A,H
0B28AB E6 3F       1302**          		AND     3FH             ;CLEAR OUT JUNK
0B28AD 67          1303**          		LD      H,A
0B28AE F1          1304**          		POP     AF
0B28AF F2 BD 28 0B 1305**          		JP      P,STR24
0B28B3 3C          1306**          		INC     A
0B28B4 20 1C       1307**          		JR      NZ,STR26
0B28B6 3E 04       1308**          		LD      A,4
0B28B8 B9          1309**          		CP      C               ;ROUND UP?
0B28B9 3E 00       1310**          		LD      A,0
0B28BB 18 15       1311**          		JR      STR26
0B28BD F5          1312**  STR24:			PUSH    AF
0B28BE 79          1313**          		LD      A,C
0B28BF CE 30       1314**          		ADC     A,'0'           ;ADD CARRY
0B28C1 FE 30       1315**          		CP      '0'
0B28C3 28 05       1316**          		JR      Z,STR25         ;SUPPRESS ZERO
0B28C5 FE 3A       1317**          		CP      '9'+1
0B28C7 3F          1318**          		CCF
0B28C8 30 08       1319**          		JR      NC,STR26
0B28CA E3          1320**  STR25:			EX      (SP),HL
0B28CB CB 75       1321**          		BIT     6,L             ;ZERO FLAG
0B28CD E3          1322**  		        EX      (SP),HL
0B28CE 20 05       1323**          		JR      NZ,STR27
0B28D0 3E 30       1324**          		LD      A,'0'
0B28D2 3C          1325**  STR26:			INC     A               ;SET +VE
0B28D3 3D          1326**          		DEC     A
0B28D4 F5          1327**          		PUSH    AF              ;PUT ON STACK + CARRY
0B28D5 04          1328**  STR27:			INC     B
0B28D6 CD B0 2B 0B 1329**          		CALL    TEST_FP            ;IS HLH'L' ZERO?
0B28DA 0E 20       1330**          		LD      C,32
0B28DC 3E 00       1331**          		LD      A,0
0B28DE 20 B8       1332**          		JR      NZ,STR22
0B28E0 F1          1333**          		POP     AF
0B28E1 F5          1334**          		PUSH    AF
0B28E2 3E 00       1335**          		LD      A,0
0B28E4 38 B2       1336**          		JR      C,STR22
0B28E6             1337**  ;
0B28E6             1338**  ;At this point, the decimal character string is stored
0B28E6             1339**  ; on the stack. Trailing zeroes are suppressed and may
0B28E6             1340**  ; need to be replaced.
0B28E6             1341**  ;B register holds decimal point position.
0B28E6             1342**  ;Now format number and store as ASCII string:
0B28E6             1343**  ;
0B28E6 EB          1344**  STR3:			EX      DE,HL           ;STRING POINTER
0B28E7 0E FF       1345**          		LD      C,-1            ;FLAG "E"
0B28E9 16 01       1346**          		LD      D,1
0B28EB DD 5E 01    1347**          		LD      E,(IX+1)        ;f2
0B28EE DD CB 02 46 1348**          		BIT     0,(IX+2)
0B28F2 20 35       1349**          		JR      NZ,STR34        ;E MODE
0B28F4 DD CB 02 4E 1350**          		BIT     1,(IX+2)
0B28F8 28 12       1351**          		JR      Z,STR31
0B28FA 78          1352**          		LD      A,B             ;F MODE
0B28FB B7          1353**          		OR      A
0B28FC 28 05       1354**          		JR      Z,STR30
0B28FE FA 03 29 0B 1355**          		JP      M,STR30
0B2902 50          1356**          		LD      D,B
0B2903 7A          1357**  STR30:			LD      A,D
0B2904 DD 86 01    1358**          		ADD     A,(IX+1)
0B2907 5F          1359**          		LD      E,A
0B2908 FE 0B       1360**          		CP      11
0B290A 38 19       1361**          		JR      C,STR32
0B290C 78          1362**  STR31:			LD      A,B             ;G MODE
0B290D 11 01 01 00 1363**          		LD      DE,101H
0B2911 B7          1364**          		OR      A
0B2912 FA 29 29 0B 1365**          		JP      M,STR34
0B2916 28 0D       1366**          		JR      Z,STR32
0B2918 DD 7E 01    1367**          		LD      A,(IX+1)
0B291B B7          1368**          		OR      A
0B291C 20 02       1369**          		JR      NZ,STR3A
0B291E 3E 0A       1370**          		LD      A,10
0B2920 B8          1371**  STR3A:			CP      B
0B2921 38 06       1372**          		JR      C,STR34
0B2923 50          1373**          		LD      D,B
0B2924 58          1374**          		LD      E,B
0B2925 78          1375**  STR32:			LD      A,B
0B2926 C6 81       1376**          		ADD     A,129
0B2928 4F          1377**          		LD      C,A
0B2929 CB FA       1378**  STR34:			SET     7,D
0B292B 1D          1379**          		DEC     E
0B292C 7A          1380**  STR35:			LD      A,D
0B292D B9          1381**          		CP      C
0B292E 30 0E       1382**          		JR      NC,STR33
0B2930 F1          1383**  STR36:			POP     AF
0B2931 28 04       1384**          		JR      Z,STR37
0B2933 F2 40 29 0B 1385**          		JP      P,STR38
0B2937 F5          1386**  STR37:			PUSH    AF
0B2938 1C          1387**          		INC     E
0B2939 1D          1388**          		DEC     E
0B293A FA 51 29 0B 1389**          		JP      M,STR4
0B293E 3E 30       1390**  STR33:			LD      A,'0'
0B2940 15          1391**  STR38:			DEC     D
0B2941 E2 48 29 0B 1392**          		JP      PO,STR39
0B2945 36 2E       1393**          		LD      (HL),'.'
0B2947 23          1394**          		INC     HL
0B2948 77          1395**  STR39:			LD      (HL),A
0B2949 23          1396**          		INC     HL
0B294A 1D          1397**          		DEC     E
0B294B F2 2C 29 0B 1398**          		JP      P,STR35
0B294F 18 DF       1399**          		JR      STR36
0B2951             1400**  ;
0B2951 F1          1401**  STR4:			POP     AF
0B2952 0C          1402**  STR40:			INC     C
0B2953 4D          1403**          		LD      C,L
0B2954 20 28       1404**          		JR      NZ,STR44
0B2956 36 45       1405**          		LD      (HL),'E'        ;EXPONENT
0B2958 23          1406**          		INC     HL
0B2959 78          1407**          		LD      A,B
0B295A 3D          1408**          		DEC     A
0B295B F2 64 29 0B 1409**          		JP      P,STR41
0B295F 36 2D       1410**          		LD      (HL),'-'
0B2961 23          1411**          		INC     HL
0B2962 ED 44       1412**          		NEG
0B2964 36 30       1413**  STR41:			LD      (HL),'0'
0B2966 28 15       1414**          		JR      Z,STR47
0B2968 FE 0A       1415**          		CP      10
0B296A 47          1416**          		LD      B,A
0B296B 3E 3A       1417**          		LD      A,':'
0B296D 38 03       1418**          		JR      C,STR42
0B296F 23          1419**          		INC     HL
0B2970 36 30       1420**          		LD      (HL),'0'
0B2972 34          1421**  STR42:			INC     (HL)
0B2973 BE          1422**          		CP      (HL)
0B2974 20 05       1423**          		JR      NZ,STR43
0B2976 36 30       1424**          		LD      (HL),'0'
0B2978 2B          1425**          		DEC     HL
0B2979 34          1426**          		INC     (HL)
0B297A 23          1427**          		INC     HL
0B297B 10 F5       1428**  STR43:			DJNZ    STR42
0B297D 23          1429**  STR47:			INC     HL
0B297E EB          1430**  STR44:			EX      DE,HL
0B297F C9          1431**        			RET
0B2980             1432**  ;
0B2980             1433**  ;Support subroutines:
0B2980             1434**  ;
0B2980 DD 46 04    1435**  DLOAD5:			LD      B,(IX+4)
0B2983 D9          1436**          		EXX
0B2984 DD 5E 00    1437**          		LD      E,(IX+0)
0B2987 DD 56 01    1438**          		LD      D,(IX+1)
0B298A D9          1439**          		EXX
0B298B DD 5E 02    1440**          		LD      E,(IX+2)
0B298E DD 56 03    1441**          		LD      D,(IX+3)
0B2991 C9          1442**          		RET
0B2992             1443**  ;
0B2992 DD 46 06    1444**  DLOAD5_SPL:		LD      B,(IX+6)
0B2995 D9          1445**  			EXX
0B2996 DD 17 00    1446**  			LD	DE, (IX+0)
0B2999 D9          1447**  			EXX
0B299A DD 17 03    1448**  			LD	DE, (IX+3)
0B299D C9          1449**  			RET
0B299E             1450**  ;
0B299E             1451**  ;CON_FP - Get unsigned numeric constant from ASCII string.
0B299E             1452**  ;   Inputs: ASCII string at (IX).
0B299E             1453**  ;  Outputs: Variable-type result in HLH'L'C
0B299E             1454**  ;           IX updated (points to delimiter)
0B299E             1455**  ;           A7 = 0 (numeric marker)
0B299E             1456**  ;
0B299E CD D4 2B 0B 1457**  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B29A2 0E 00       1458**          		LD      C,0             ;TRUNCATION COUNTER
0B29A4 CD 32 2A 0B 1459**          		CALL    UINT          ;GET INTEGER PART
0B29A8 FE 2E       1460**          		CP      '.'
0B29AA 06 00       1461**          		LD      B,0             ;DECL. PLACE COUNTER
0B29AC CC 30 2A 0B 1462**          		CALL    Z,NUMBIX        ;GET FRACTION PART
0B29B0 FE 45       1463**          		CP      'E'
0B29B2 3E 00       1464**          		LD      A,0             ;INITIALISE EXPONENT
0B29B4 CC FE 29 0B 1465**          		CALL    Z,GETEXP        ;GET EXPONENT
0B29B8 CB 7C       1466**          		BIT     7,H
0B29BA 20 08       1467**          		JR      NZ,CON0         ;INTEGER OVERFLOW
0B29BC B7          1468**          		OR      A
0B29BD 20 05       1469**          		JR      NZ,CON0         ;EXPONENT NON-ZERO
0B29BF B8          1470**          		CP      B
0B29C0 20 02       1471**          		JR      NZ,CON0         ;DECIMAL POINT
0B29C2 B9          1472**          		CP      C
0B29C3 C8          1473**          		RET     Z               ;INTEGER
0B29C4 90          1474**  CON0:			SUB     B
0B29C5 81          1475**          		ADD     A,C
0B29C6 0E 9F       1476**          		LD      C,159
0B29C8 CD 37 2B 0B 1477**          		CALL    FLOAT_
0B29CC CB BC       1478**          		RES     7,H             ;DITCH IMPLIED 1
0B29CE B7          1479**          		OR      A
0B29CF C8          1480**          		RET     Z               ;DONE
0B29D0 FA DE 29 0B 1481**          		JP      M,CON2          ;NEGATIVE EXPONENT
0B29D4 CD D0 2C 0B 1482**          		CALL    POWR10
0B29D8 CD BF 22 0B 1483**          		CALL    FMUL            ;SCALE
0B29DC AF          1484**          		XOR     A
0B29DD C9          1485**          		RET
0B29DE FE DA       1486**  CON2:			CP      -38
0B29E0 38 0C       1487**          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B29E2 ED 44       1488**          		NEG
0B29E4 CD D0 2C 0B 1489**          		CALL    POWR10
0B29E8 CD 16 22 0B 1490**          		CALL    FDIV            ;SCALE
0B29EC AF          1491**          		XOR     A
0B29ED C9          1492**          		RET
0B29EE F5          1493**  CON3:			PUSH    AF
0B29EF 3E 26       1494**          		LD      A,38
0B29F1 CD D0 2C 0B 1495**          		CALL    POWR10
0B29F5 CD 16 22 0B 1496**          		CALL    FDIV
0B29F9 F1          1497**          		POP     AF
0B29FA C6 26       1498**          		ADD     A,38
0B29FC 18 E0       1499**          		JR      CON2
0B29FE             1500**  ;
0B29FE             1501**  ;GETEXP - Get decimal exponent from string
0B29FE             1502**  ;     Inputs: ASCII string at (IX)
0B29FE             1503**  ;             (IX points at 'E')
0B29FE             1504**  ;             A = initial value
0B29FE             1505**  ;    Outputs: A = new exponent
0B29FE             1506**  ;             IX updated.
0B29FE             1507**  ;   Destroys: A,A',IX,F,F'
0B29FE             1508**  ;
0B29FE C5          1509**  GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B29FF 47          1510**          		LD      B,A             ;INITIAL VALUE
0B2A00 0E 02       1511**          		LD      C,2             ;2 DIGITS MAX
0B2A02 DD 23       1512**          		INC     IX              ;BUMP PAST 'E'
0B2A04 CD EE 2D 0B 1513**          		CALL    SIGNQ
0B2A08 08          1514**          		EX      AF,AF'          ;SAVE EXPONENT SIGN
0B2A09 CD E4 2D 0B 1515**  GETEX1:			CALL    DIGITQ
0B2A0D 38 18       1516**          		JR      C,GETEX2
0B2A0F 78          1517**          		LD      A,B             ;B=B*10
0B2A10 87          1518**          		ADD     A,A
0B2A11 87          1519**          		ADD     A,A
0B2A12 80          1520**          		ADD     A,B
0B2A13 87          1521**          		ADD     A,A
0B2A14 47          1522**          		LD      B,A
0B2A15 DD 7E 00    1523**          		LD      A,(IX)          ;GET BACK DIGIT
0B2A18 DD 23       1524**          		INC     IX
0B2A1A E6 0F       1525**          		AND     0FH             ;MASK UNWANTED BITS
0B2A1C 80          1526**          		ADD     A,B             ;ADD IN DIGIT
0B2A1D 47          1527**          		LD      B,A
0B2A1E 0D          1528**          		DEC     C
0B2A1F F2 09 2A 0B 1529**          		JP      P,GETEX1
0B2A23 06 64       1530**          		LD      B,100           ;FORCE OVERFLOW
0B2A25 18 E2       1531**          		JR      GETEX1
0B2A27 08          1532**  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B2A28 FE 2D       1533**          		CP      '-'
0B2A2A 78          1534**          		LD      A,B
0B2A2B C1          1535**          		POP     BC              ;RESTORE
0B2A2C C0          1536**          		RET     NZ
0B2A2D ED 44       1537**          		NEG                     ;NEGATE EXPONENT
0B2A2F C9          1538**          		RET
0B2A30             1539**  ;
0B2A30             1540**  ;UINT: Get unsigned integer from string.
0B2A30             1541**  ;    Inputs: string at (IX)
0B2A30             1542**  ;            C = truncated digit count
0B2A30             1543**  ;                (initially zero)
0B2A30             1544**  ;            B = total digit count
0B2A30             1545**  ;            HLH'L' = initial value
0B2A30             1546**  ;   Outputs: HLH'L' = number (binary integer)
0B2A30             1547**  ;            A = delimiter.
0B2A30             1548**  ;            B, C & IX updated
0B2A30             1549**  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B2A30             1550**  ;
0B2A30 DD 23       1551**  NUMBIX:			INC     IX
0B2A32 CD E4 2D 0B 1552**  UINT:			CALL    DIGITQ
0B2A36 D8          1553**          		RET     C
0B2A37 04          1554**          		INC     B               ;INCREMENT DIGIT COUNT
0B2A38 DD 23       1555**          		INC     IX
0B2A3A CD 2D 2C 0B 1556**          		CALL    X10             ;*10 & COPY OLD VALUE
0B2A3E 38 15       1557**          		JR      C,NUMB1         ;OVERFLOW
0B2A40 0D          1558**          		DEC     C               ;SEE IF TRUNCATED
0B2A41 0C          1559**          		INC     C
0B2A42 20 11       1560**          		JR      NZ,NUMB1        ;IMPORTANT!
0B2A44 E6 0F       1561**          		AND     0FH
0B2A46 D9          1562**          		EXX
0B2A47 06 00       1563**          		LD      B,0
0B2A49 4F          1564**          		LD      C,A
0B2A4A 52 09       1565**          		ADD.S   HL,BC           ;ADD IN DIGIT
0B2A4C D9          1566**          		EXX
0B2A4D 30 E3       1567**          		JR      NC,UINT
0B2A4F 52 23       1568**          		INC.S   HL              ;CARRY
0B2A51 7C          1569**          		LD      A,H
0B2A52 B5          1570**          		OR      L
0B2A53 20 DD       1571**          		JR      NZ,UINT
0B2A55 0C          1572**  NUMB1:			INC     C               ;TRUNCATION COUNTER
0B2A56 CD 8B 2B 0B 1573**          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B2A5A 18 D6       1574**          		JR      UINT
0B2A5C             1575**  ;
0B2A5C             1576**  ;FIX - Fix number to specified exponent value.
0B2A5C             1577**  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
0B2A5C             1578**  ;            A = desired exponent (A>C)
0B2A5C             1579**  ;   Outputs: HLH'L'C = fixed number (unsigned)
0B2A5C             1580**  ;            fraction shifted into B'C'
0B2A5C             1581**  ;            A'F' positive if integer input
0B2A5C             1582**  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
0B2A5C             1583**  ;
0B2A5C 08          1584**  FIX:			EX      AF,AF'
0B2A5D AF          1585**          		XOR     A
0B2A5E 08          1586**          		EX      AF,AF'
0B2A5F CB FC       1587**          		SET     7,H             ;IMPLIED 1
0B2A61 CD 90 2B 0B 1588**  FIX1:			CALL    DIV2
0B2A65 B9          1589**          		CP      C
0B2A66 C8          1590**          		RET     Z
0B2A67 D2 61 2A 0B 1591**          		JP      NC,FIX1
0B2A6B C3 9F 2B 0B 1592**          		JP      OFLOW
0B2A6F             1593**  ;
0B2A6F             1594**  ;SFIX - Convert to integer if necessary.
0B2A6F             1595**  ;    Input: Variable-type number in HLH'L'C
0B2A6F             1596**  ;   Output: Integer in HLH'L', C=0
0B2A6F             1597**  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
0B2A6F             1598**  ;
0B2A6F             1599**  ;NEGATE - Negate HLH'L'
0B2A6F             1600**  ;    Destroys: H,L,H',L',F
0B2A6F             1601**  ;
0B2A6F CD 88 2B 0B 1602**  FIX2:			CALL    SWAP_FP
0B2A73 CD 7B 2A 0B 1603**          		CALL    SFIX_FP
0B2A77 CD 88 2B 0B 1604**          		CALL    SWAP_FP
0B2A7B 0D          1605**  SFIX_FP:			DEC     C
0B2A7C 0C          1606**          		INC     C
0B2A7D C8          1607**          		RET     Z               ;INTEGER/ZERO
0B2A7E CB 7C       1608**          		BIT     7,H             ;SIGN
0B2A80 F5          1609**          		PUSH    AF
0B2A81 3E 9F       1610**          		LD      A,159
0B2A83 CD 5C 2A 0B 1611**          		CALL    FIX
0B2A87 F1          1612**          		POP     AF
0B2A88 0E 00       1613**          		LD      C,0
0B2A8A C8          1614**          		RET     Z
0B2A8B B7          1615**  NEGATE:			OR      A               ;CLEAR CARRY
0B2A8C D9          1616**          		EXX
0B2A8D D5          1617**  NEG0:			PUSH    DE
0B2A8E EB          1618**          		EX      DE,HL
0B2A8F 21 00 00 00 1619**          		LD      HL,0
0B2A93 52 ED 52    1620**          		SBC.S   HL,DE
0B2A96 D1          1621**          		POP     DE
0B2A97 D9          1622**          		EXX
0B2A98 D5          1623**          		PUSH    DE
0B2A99 EB          1624**          		EX      DE,HL
0B2A9A 21 00 00 00 1625**          		LD      HL,0
0B2A9E 52 ED 52    1626**          		SBC.S   HL,DE
0B2AA1 D1          1627**          		POP     DE
0B2AA2 C9          1628**          		RET
0B2AA3             1629**  ;
0B2AA3             1630**  ;NEG - Negate HLH'L'B'C'
0B2AA3             1631**  ;    Also complements A (used in FADD)
0B2AA3             1632**  ;    Destroys: A,H,L,B',C',H',L',F
0B2AA3             1633**  ;
0B2AA3 D9          1634**  NEG_:			EXX
0B2AA4 2F          1635**          		CPL
0B2AA5 E5          1636**          		PUSH    HL
0B2AA6 B7          1637**          		OR      A               ;CLEAR CARRY
0B2AA7 21 00 00 00 1638**          		LD      HL,0
0B2AAB 52 ED 42    1639**          		SBC.S   HL,BC
0B2AAE 44          1640**          		LD      B,H
0B2AAF 4D          1641**          		LD      C,L
0B2AB0 E1          1642**          		POP     HL
0B2AB1 18 DA       1643**          		JR      NEG0
0B2AB3             1644**  ;
0B2AB3             1645**  ;SCALE - Trig scaling.
0B2AB3             1646**  ;MOD48 - 48-bit floating-point "modulus" (remainder).
0B2AB3             1647**  ;   Inputs: HLH'L'C unsigned floating-point dividend
0B2AB3             1648**  ;           DED'E'B'C'B unsigned 48-bit FP divisor
0B2AB3             1649**  ;  Outputs: HLH'L'C floating point remainder (H7=1)
0B2AB3             1650**  ;           E = quotient (bit 7 is sticky)
0B2AB3             1651**  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B2AB3             1652**  ;FLO48 - Float unsigned number (48 bits)
0B2AB3             1653**  ;    Input/output in HLH'L'B'C'C
0B2AB3             1654**  ;   Destroys: C,H,L,B',C',H',L',F
0B2AB3             1655**  ;
0B2AB3 3E 96       1656**  SCALE:			LD      A,150
0B2AB5 B9          1657**          		CP      C
0B2AB6 3E 17       1658**          		LD      A,ACLOST
0B2AB8 DA 2E 20 0B 1659**          		JP      C,ERROR_FP_         ;"Accuracy lost"
0B2ABC CD F9 25 0B 1660**          		CALL    PIBY4
0B2AC0 D9          1661**          		EXX
0B2AC1 01 69 21 00 1662**          		LD      BC,2169H        ;3.141592653589793238
0B2AC5 D9          1663**          		EXX
0B2AC6 CB FA       1664**  MOD48:			SET     7,D             ;IMPLIED 1
0B2AC8 CB FC       1665**          		SET     7,H
0B2ACA 79          1666**          		LD      A,C
0B2ACB 0E 00       1667**          		LD      C,0             ;INIT QUOTIENT
0B2ACD DD 21 00 00 1668**          		LD      IX,0
       00          
0B2AD2 DD E5       1669**          		PUSH    IX              ;PUT ZERO ON STACK
0B2AD4 B8          1670**          		CP      B
0B2AD5 38 46       1671**          		JR      C,MOD485        ;DIVIDEND<DIVISOR
0B2AD7 D9          1672**  MOD481:			EXX                     ;CARRY=0 HERE
0B2AD8 E3          1673**          		EX      (SP),HL
0B2AD9 52 ED 42    1674**          		SBC.S   HL,BC
0B2ADC E3          1675**          		EX      (SP),HL
0B2ADD 52 ED 52    1676**          		SBC.S   HL,DE
0B2AE0 D9          1677**          		EXX
0B2AE1 52 ED 52    1678**          		SBC.S   HL,DE
0B2AE4 30 0C       1679**          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B2AE6 D9          1680**          		EXX
0B2AE7 E3          1681**          		EX      (SP),HL
0B2AE8 52 09       1682**          		ADD.S   HL,BC
0B2AEA E3          1683**          		EX      (SP),HL
0B2AEB 52 ED 5A    1684**          		ADC.S   HL,DE
0B2AEE D9          1685**          		EXX
0B2AEF 52 ED 5A    1686**          		ADC.S   HL,DE
0B2AF2 3F          1687**  MOD482:			CCF
0B2AF3 CB 11       1688**          		RL      C               ;QUOTIENT
0B2AF5 30 02       1689**          		JR      NC,MOD483
0B2AF7 CB F9       1690**          		SET     7,C             ;STICKY BIT
0B2AF9 3D          1691**  MOD483:			DEC     A
0B2AFA B8          1692**          		CP      B
0B2AFB 38 1F       1693**          		JR      C,MOD484        ;DIVIDEND<DIVISOR
0B2AFD E3          1694**          		EX      (SP),HL
0B2AFE 52 29       1695**          		ADD.S   HL,HL           ;DIVIDEND * 2
0B2B00 E3          1696**          		EX      (SP),HL
0B2B01 D9          1697**          		EXX
0B2B02 52 ED 6A    1698**          		ADC.S   HL,HL
0B2B05 D9          1699**          		EXX
0B2B06 52 ED 6A    1700**          		ADC.S   HL,HL
0B2B09 30 CC       1701**          		JR      NC,MOD481       ;AGAIN
0B2B0B B7          1702**          		OR      A
0B2B0C D9          1703**          		EXX
0B2B0D E3          1704**          		EX      (SP),HL
0B2B0E 52 ED 42    1705**          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B2B11 E3          1706**          		EX      (SP),HL
0B2B12 52 ED 52    1707**          		SBC.S   HL,DE
0B2B15 D9          1708**          		EXX
0B2B16 52 ED 52    1709**          		SBC.S   HL,DE
0B2B19 B7          1710**          		OR      A
0B2B1A 18 D6       1711**          		JR      MOD482
0B2B1C             1712**  ;
0B2B1C 3C          1713**  MOD484:			INC     A
0B2B1D 59          1714**  MOD485:			LD      E,C             ;QUOTIENT
0B2B1E 4F          1715**          		LD      C,A             ;REMAINDER EXPONENT
0B2B1F D9          1716**          		EXX
0B2B20 C1          1717**          		POP     BC
0B2B21 D9          1718**          		EXX
0B2B22 CB 7C       1719**  FLO48:			BIT     7,H
0B2B24 C0          1720**          		RET     NZ
0B2B25 D9          1721**          		EXX
0B2B26 CB 21       1722**          		SLA     C
0B2B28 CB 10       1723**          		RL      B
0B2B2A 52 ED 6A    1724**          		ADC.S   HL,HL
0B2B2D D9          1725**          		EXX
0B2B2E 52 ED 6A    1726**          		ADC.S   HL,HL
0B2B31 0D          1727**          		DEC     C
0B2B32 C2 22 2B 0B 1728**          		JP      NZ,FLO48
0B2B36 C9          1729**          		RET
0B2B37             1730**  ;
0B2B37             1731**  ;Float unsigned number
0B2B37             1732**  ;    Input/output in HLH'L'C
0B2B37             1733**  ;   Destroys: C,H,L,H',L',F
0B2B37             1734**  ;
0B2B37 CB 7C       1735**  FLOAT_:			BIT     7,H
0B2B39 C0          1736**          		RET     NZ
0B2B3A D9          1737**          		EXX                     ;SAME AS "X2"
0B2B3B 52 29       1738**          		ADD.S   HL,HL           ;TIME-CRITICAL
0B2B3D D9          1739**          		EXX                     ;REGION
0B2B3E 52 ED 6A    1740**          		ADC.S   HL,HL           ;(BENCHMARKS)
0B2B41 0D          1741**          		DEC     C
0B2B42 C2 37 2B 0B 1742**          		JP      NZ,FLOAT_
0B2B46 C9          1743**          		RET
0B2B47             1744**  ;
0B2B47             1745**  ;SFLOAT - Convert to floating-point if necessary.
0B2B47             1746**  ;    Input: Variable-type number in HLH'L'C
0B2B47             1747**  ;    Output: Floating-point in HLH'L'C
0B2B47             1748**  ;    Destroys: A,C,H,L,H',L',F
0B2B47             1749**  ;
0B2B47 08          1750**  FLOATA:			EX      AF,AF'
0B2B48             1751**          		; ADD     A,(RTABLE-DTABLE)/3
0B2B48 C6 2A       1752**          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2B4A 08          1753**          		EX      AF,AF'
0B2B4B CD 88 2B 0B 1754**  FLOAT2:			CALL    SWAP_FP
0B2B4F CD 57 2B 0B 1755**          		CALL    SFLOAT_FP
0B2B53 CD 88 2B 0B 1756**          		CALL    SWAP_FP
0B2B57 0D          1757**  SFLOAT_FP:			DEC     C
0B2B58 0C          1758**          		INC     C
0B2B59 C0          1759**          		RET     NZ              ;ALREADY FLOATING-POINT
0B2B5A CD B0 2B 0B 1760**          		CALL    TEST_FP
0B2B5E C8          1761**          		RET     Z               ;ZERO
0B2B5F 7C          1762**          		LD      A,H
0B2B60 B7          1763**          		OR      A
0B2B61 FC 8B 2A 0B 1764**          		CALL    M,NEGATE
0B2B65 0E 9F       1765**          		LD      C,159
0B2B67 CD 37 2B 0B 1766**          		CALL    FLOAT_
0B2B6B B7          1767**          		OR      A
0B2B6C F8          1768**          		RET     M               ;NEGATIVE
0B2B6D CB BC       1769**          		RES     7,H
0B2B6F C9          1770**          		RET
0B2B70             1771**  ;
0B2B70             1772**  ;ROUND UP
0B2B70             1773**  ;Return with carry set if 32-bit overflow
0B2B70             1774**  ;   Destroys: H,L,B',C',H',L',F
0B2B70             1775**  ;
0B2B70 D9          1776**  ADD1_FP:			EXX
0B2B71 01 01 00 00 1777**          		LD      BC,1
0B2B75 52 09       1778**          		ADD.S   HL,BC
0B2B77 D9          1779**          		EXX
0B2B78 D0          1780**          		RET     NC
0B2B79 C5          1781**          		PUSH    BC
0B2B7A 01 01 00 00 1782**          		LD      BC,1
0B2B7E 52 09       1783**          		ADD.S   HL,BC
0B2B80 C1          1784**          		POP     BC
0B2B81 C9          1785**          		RET
0B2B82             1786**  ;
0B2B82             1787**  ;ODD - Add one if even, leave alone if odd.
0B2B82             1788**  ; (Used to perform unbiassed rounding, i.e.
0B2B82             1789**  ;  number is rounded up half the time)
0B2B82             1790**  ;    Destroys: L',F (carry cleared)
0B2B82             1791**  ;
0B2B82 B7          1792**  ODD:			OR      A               ;CLEAR CARRY
0B2B83 D9          1793**          		EXX
0B2B84 CB C5       1794**          		SET     0,L             ;MAKE ODD
0B2B86 D9          1795**          		EXX
0B2B87 C9          1796**          		RET
0B2B88             1797**  ;
0B2B88             1798**  ;SWAP_FP - Swap arguments.
0B2B88             1799**  ;    Exchanges DE,HL D'E',H'L' and B,C
0B2B88             1800**  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B2B88             1801**  ;SWAP1 - Swap DEHL with D'E'H'L'
0B2B88             1802**  ;    Destroys: D,E,H,L,D',E',H',L'
0B2B88             1803**  ;
0B2B88 79          1804**  SWAP_FP:			LD      A,C
0B2B89 48          1805**          		LD      C,B
0B2B8A 47          1806**          		LD      B,A
0B2B8B EB          1807**  SWAP1:			EX      DE,HL
0B2B8C D9          1808**          		EXX
0B2B8D EB          1809**          		EX      DE,HL
0B2B8E D9          1810**          		EXX
0B2B8F C9          1811**          		RET
0B2B90             1812**  ;
0B2B90             1813**  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
0B2B90             1814**  ; INCC - destroys C,F
0B2B90             1815**  ; OFLOW
0B2B90             1816**  ;
0B2B90 CD 49 2C 0B 1817**  DIV2:			CALL    D2
0B2B94 D9          1818**          		EXX
0B2B95 CB 18       1819**          		RR      B
0B2B97 CB 19       1820**          		RR      C
0B2B99 08          1821**          		EX      AF,AF'
0B2B9A B0          1822**          		OR      B
0B2B9B 08          1823**          		EX      AF,AF'
0B2B9C D9          1824**          		EXX
0B2B9D 0C          1825**  INCC:			INC     C
0B2B9E C0          1826**          		RET     NZ
0B2B9F 3E 14       1827**  OFLOW:			LD      A,TOOBIG_FP
0B2BA1 C3 2E 20 0B 1828**          		JP      ERROR_FP_           ;"Too big"
0B2BA5             1829**  ;
0B2BA5             1830**  ; FTEST - Test for zero & sign
0B2BA5             1831**  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
0B2BA5             1832**  ;
0B2BA5 CD B0 2B 0B 1833**  FTEST_FP:			CALL    TEST_FP
0B2BA9 C8          1834**          		RET     Z
0B2BAA 7C          1835**          		LD      A,H
0B2BAB E6 80       1836**          		AND     10000000B
0B2BAD F6 40       1837**          		OR      01000000B
0B2BAF C9          1838**          		RET
0B2BB0             1839**  ;
0B2BB0             1840**  ; TEST_FP - Test HLH'L' for zero.
0B2BB0             1841**  ;     Output: Z-flag set & A=0 if HLH'L'=0
0B2BB0             1842**  ;     Destroys: A,F
0B2BB0             1843**  ;
0B2BB0 7C          1844**  TEST_FP:			LD      A,H
0B2BB1 B5          1845**          		OR      L
0B2BB2 D9          1846**          		EXX
0B2BB3 B4          1847**          		OR      H
0B2BB4 B5          1848**          		OR      L
0B2BB5 D9          1849**          		EXX
0B2BB6 C9          1850**          		RET
0B2BB7             1851**  ;
0B2BB7             1852**  ; FCOMP - Compare two numbers
0B2BB7             1853**  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
0B2BB7             1854**  ;
0B2BB7 78          1855**  FCOMP_FP:			LD      A,B
0B2BB8 B1          1856**          		OR      C               ;Both integer?
0B2BB9 20 0B       1857**          		JR      NZ,FCOMP1
0B2BBB CD D0 2B 0B 1858**          		CALL    ICP
0B2BBF 3E 00       1859**  FCOMP0:			LD      A,0
0B2BC1 C8          1860**          		RET     Z               ;Equal
0B2BC2 3E 80       1861**          		LD      A,80H
0B2BC4 1F          1862**          		RRA
0B2BC5 C9          1863**          		RET
0B2BC6             1864**  ;
0B2BC6 CD 4B 2B 0B 1865**  FCOMP1:			CALL    FLOAT2          ;Float both
0B2BCA CD DE 2B 0B 1866**          		CALL    FCP
0B2BCE 18 EF       1867**          		JR      FCOMP0
0B2BD0             1868**  ;
0B2BD0             1869**  ; Integer and floating point compare.
0B2BD0             1870**  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
0B2BD0             1871**  ; Result pre-set to FALSE
0B2BD0             1872**  ; ICP1, FCP1 destroy A,F
0B2BD0             1873**  ;
0B2BD0             1874**  ; ZERO - Return zero.
0B2BD0             1875**  ;  Destroys: A,C,H,L,H',L'
0B2BD0             1876**  ;
0B2BD0 CD 03 2C 0B 1877**  ICP:			CALL    ICP1
0B2BD4 3E 00       1878**  ZERO_FP:			LD      A,0
0B2BD6 D9          1879**          		EXX
0B2BD7 67          1880**          		LD      H,A
0B2BD8 6F          1881**  	       		LD      L,A
0B2BD9 D9          1882**          		EXX
0B2BDA 67          1883**        			LD      H,A
0B2BDB 6F          1884**       			LD      L,A
0B2BDC 4F          1885**  	    		LD      C,A
0B2BDD C9          1886**          		RET
0B2BDE             1887**  ;
0B2BDE CD F5 2B 0B 1888**  FCP:			CALL    FCP1
0B2BE2 18 F0       1889**          		JR      ZERO_FP            ;PRESET FALSE
0B2BE4             1890**  ;
0B2BE4 79          1891**  FCP0:			LD      A,C
0B2BE5 B8          1892**          		CP      B               ;COMPARE EXPONENTS
0B2BE6 C0          1893**          		RET     NZ
0B2BE7             1894**  ICP0:
0B2BE7 52 ED 52    1895**  			SBC.S   HL,DE           ;COMP MANTISSA MSB
0B2BEA 52 19       1896**          		ADD.S   HL,DE
0B2BEC C0          1897**          		RET     NZ
0B2BED D9          1898**          		EXX
0B2BEE 52 ED 52    1899**          		SBC.S   HL,DE           ;COMP MANTISSA LSB
0B2BF1 52 19       1900**          		ADD.S   HL,DE
0B2BF3 D9          1901**          		EXX
0B2BF4 C9          1902**          		RET
0B2BF5             1903**  ;
0B2BF5 7C          1904**  FCP1:			LD      A,H
0B2BF6 AA          1905**          		XOR     D
0B2BF7 7C          1906**          		LD      A,H
0B2BF8 17          1907**          		RLA
0B2BF9 F8          1908**          		RET     M
0B2BFA 30 E8       1909**          		JR      NC,FCP0
0B2BFC CD E4 2B 0B 1910**          		CALL    FCP0
0B2C00 C8          1911**          		RET     Z               ;** V0.1 BUG FIX
0B2C01 3F          1912**          		CCF
0B2C02 C9          1913**          		RET
0B2C03             1914**  ;
0B2C03 7C          1915**  ICP1:			LD      A,H
0B2C04 AA          1916**          		XOR     D
0B2C05 F2 E7 2B 0B 1917**          		JP      P,ICP0
0B2C09 7C          1918**          		LD      A,H
0B2C0A 17          1919**          		RLA
0B2C0B C9          1920**          		RET
0B2C0C             1921**  ;
0B2C0C             1922**  ; ADD - Integer add.
0B2C0C             1923**  ; Carry, sign & zero flags valid on exit
0B2C0C             1924**  ;     Destroys: H,L,H',L',F
0B2C0C             1925**  ;
0B2C0C 05          1926**  X10B:			DEC     B
0B2C0D 0C          1927**          		INC     C
0B2C0E CD 55 2C 0B 1928**  X5:			CALL    COPY0
0B2C12 CD 48 2C 0B 1929**          		CALL    D2C
0B2C16 CD 48 2C 0B 1930**          		CALL    D2C
0B2C1A 08          1931**          		EX      AF,AF'          ;SAVE CARRY
0B2C1B D9          1932**  ADD_:			EXX
0B2C1C 52 19       1933**          		ADD.S   HL,DE
0B2C1E D9          1934**          		EXX
0B2C1F 52 ED 5A    1935**          		ADC.S   HL,DE
0B2C22 C9          1936**          		RET
0B2C23             1937**  ;
0B2C23             1938**  ; SUB - Integer subtract.
0B2C23             1939**  ; Carry, sign & zero flags valid on exit
0B2C23             1940**  ;     Destroys: H,L,H',L',F
0B2C23             1941**  ;
0B2C23 D9          1942**  SUB_:			EXX
0B2C24 B7          1943**          		OR      A
0B2C25 52 ED 52    1944**          		SBC.S   HL,DE
0B2C28 D9          1945**          		EXX
0B2C29 52 ED 52    1946**          		SBC.S   HL,DE
0B2C2C C9          1947**          		RET
0B2C2D             1948**  ;
0B2C2D             1949**  ; X10 - unsigned integer * 10
0B2C2D             1950**  ;    Inputs: HLH'L' initial value
0B2C2D             1951**  ;   Outputs: DED'E' = initial HLH'L'
0B2C2D             1952**  ;            Carry bit set if overflow
0B2C2D             1953**  ;            If carry not set HLH'L'=result
0B2C2D             1954**  ;  Destroys: D,E,H,L,D',E',H',L',F
0B2C2D             1955**  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
0B2C2D             1956**  ;     Carry set if MSB=1 before shift.
0B2C2D             1957**  ;     Sign set if MSB=1 after shift.
0B2C2D             1958**  ;     Destroys: H,L,H',L',F
0B2C2D             1959**  ;
0B2C2D CD 55 2C 0B 1960**  X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B2C31 CD 40 2C 0B 1961**          		CALL    X2
0B2C35 D8          1962**          		RET     C               ;TOO BIG
0B2C36 CD 40 2C 0B 1963**          		CALL    X2
0B2C3A D8          1964**          		RET     C
0B2C3B CD 1B 2C 0B 1965**          		CALL    ADD_
0B2C3F D8          1966**          		RET     C
0B2C40 D9          1967**  X2:			EXX
0B2C41 52 29       1968**          		ADD.S   HL,HL
0B2C43 D9          1969**          		EXX
0B2C44 52 ED 6A    1970**          		ADC.S   HL,HL
0B2C47 C9          1971**          		RET
0B2C48             1972**  ;
0B2C48             1973**  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
0B2C48             1974**  ;     Carry set if LSB=1 before shift.
0B2C48             1975**  ;     Destroys: H,L,H',L',F
0B2C48             1976**  ;
0B2C48 0C          1977**  D2C:			INC     C
0B2C49 CB 3C       1978**  D2:			SRL     H
0B2C4B CB 1D       1979**          		RR      L
0B2C4D D9          1980**          		EXX
0B2C4E CB 1C       1981**          		RR      H
0B2C50 CB 1D       1982**          		RR      L
0B2C52 D9          1983**          		EXX
0B2C53 C9          1984**          		RET
0B2C54             1985**  ;
0B2C54             1986**  ; COPY - COPY HLH'L'C INTO DED'E'B
0B2C54             1987**  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
0B2C54             1988**  ;
0B2C54 41          1989**  COPY_:			LD      B,C
0B2C55 54          1990**  COPY0:			LD      D,H
0B2C56 5D          1991**          		LD      E,L
0B2C57 D9          1992**          		EXX
0B2C58 54          1993**          		LD      D,H
0B2C59 5D          1994**          		LD      E,L
0B2C5A D9          1995**          		EXX
0B2C5B C9          1996**          		RET
0B2C5C             1997**  ;
0B2C5C             1998**  ; SQUARE - PUSH X*X
0B2C5C             1999**  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
0B2C5C             2000**  ;   Destroys: SP,IX
0B2C5C             2001**  ;
0B2C5C CD 54 2C 0B 2002**  SQUARE:			CALL    COPY_
0B2C60 CD BF 22 0B 2003**          		CALL    FMUL
0B2C64 DD E1       2004**  PUSH5:			POP     IX              ;RETURN ADDRESS
0B2C66 C5          2005**          		PUSH    BC
0B2C67 E5          2006**          		PUSH    HL
0B2C68 D9          2007**          		EXX
0B2C69 E5          2008**          		PUSH    HL
0B2C6A D9          2009**          		EXX
0B2C6B DD E9       2010**          		JP      (IX)            ;"RETURN"
0B2C6D             2011**  ;
0B2C6D             2012**  ; POP5 - POP DED'E'B OFF STACK.
0B2C6D             2013**  ;   Destroys: A,B,D,E,D',E',SP,IX
0B2C6D             2014**  ;
0B2C6D DD E1       2015**  POP5:			POP     IX              ;RETURN ADDRESS
0B2C6F D9          2016**          		EXX
0B2C70 D1          2017**          		POP     DE
0B2C71 D9          2018**          		EXX
0B2C72 D1          2019**          		POP     DE
0B2C73 79          2020**          		LD      A,C
0B2C74 C1          2021**          		POP     BC
0B2C75 41          2022**          		LD      B,C
0B2C76 4F          2023**          		LD      C,A
0B2C77 DD E9       2024**          		JP      (IX)            ;"RETURN"
0B2C79             2025**  ;
0B2C79             2026**  ; RATIO - Calculate (X-1)/(X+1)
0B2C79             2027**  ;     Inputs: X in HLH'L'C
0B2C79             2028**  ;    Outputs: (X-1)/(X+1) in HLH'L'C
0B2C79             2029**  ;   Destroys: Everything except IY,SP,I
0B2C79             2030**  ;
0B2C79 CD 64 2C 0B 2031**  RATIO:			CALL    PUSH5           ;SAVE X
0B2C7D CD EC 25 0B 2032**          		CALL    DONE
0B2C81 CD AD 21 0B 2033**          		CALL    FADD
0B2C85 CD 6D 2C 0B 2034**          		CALL    POP5            ;RESTORE X
0B2C89 CD 64 2C 0B 2035**          		CALL    PUSH5           ;SAVE X+1
0B2C8D CD 88 2B 0B 2036**          		CALL    SWAP_FP
0B2C91 CD EC 25 0B 2037**          		CALL    DONE
0B2C95 CD 94 21 0B 2038**          		CALL    FSUB
0B2C99 CD 6D 2C 0B 2039**          		CALL    POP5            ;RESTORE X+1
0B2C9D C3 16 22 0B 2040**          		JP      FDIV
0B2CA1             2041**  ;
0B2CA1             2042**  ; POLY - Evaluate a polynomial.
0B2CA1             2043**  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
0B2CA1             2044**  ;             Polynomial coefficients follow call.
0B2CA1             2045**  ;    Outputs: Result in HLH'L'C
0B2CA1             2046**  ;   Destroys: Everything except IY,SP,I
0B2CA1             2047**  ; Routine terminates on finding a coefficient >=1.
0B2CA1             2048**  ; Note: The last coefficient is EXECUTED on return
0B2CA1             2049**  ;       so must contain only innocuous bytes!
0B2CA1             2050**  ;
0B2CA1 DD 21 03 00 2051**  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
0B2CA6 DD 39       2052**          		ADD     IX, SP
0B2CA8 DD E3       2053**          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B2CAA             2054**  ;
0B2CAA CD 80 29 0B 2055**          		CALL    DLOAD5          		; Load the first coefficient from (IX)
0B2CAE CD BF 22 0B 2056**  POLY1:			CALL    FMUL
0B2CB2 11 05 00 00 2057**          		LD      DE, 5				; Skip to the next coefficient
0B2CB6 DD 19       2058**          		ADD     IX, DE
0B2CB8 CD 80 29 0B 2059**          		CALL    DLOAD5          		; Load the second coefficient from (IX)
0B2CBC DD E3       2060**          		EX      (SP), IX			; Restore the SP just in case we need to return
0B2CBE 04          2061**          		INC     B
0B2CBF 05          2062**          		DEC     B               		; Test B for end byte (80h)
0B2CC0 FA AD 21 0B 2063**          		JP      M,FADD				; Yes, so add and return
0B2CC4 CD AD 21 0B 2064**          		CALL    FADD				; No, so add
0B2CC8 CD 92 29 0B 2065**          		CALL    DLOAD5_SPL			; Load X from SP
0B2CCC DD E3       2066**          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B2CCE 18 DE       2067**          		JR      POLY1				; And loop
0B2CD0             2068**  ;
0B2CD0             2069**  ; POWR10 - Calculate power of ten.
0B2CD0             2070**  ;     Inputs: A=power of 10 required (A<128)
0B2CD0             2071**  ;             A=binary exponent to be exceeded (A>=128)
0B2CD0             2072**  ;    Outputs: DED'E'B = result
0B2CD0             2073**  ;             A = actual power of ten returned
0B2CD0             2074**  ;   Destroys: A,B,D,E,A',D',E',F,F'
0B2CD0             2075**  ;
0B2CD0 3C          2076**  POWR10:			INC     A
0B2CD1 08          2077**          		EX      AF,AF'
0B2CD2 E5          2078**          		PUSH    HL
0B2CD3 D9          2079**          		EXX
0B2CD4 E5          2080**          		PUSH    HL
0B2CD5 D9          2081**          		EXX
0B2CD6 CD EC 25 0B 2082**          		CALL    DONE
0B2CDA CD 88 2B 0B 2083**          		CALL    SWAP_FP
0B2CDE AF          2084**          		XOR     A
0B2CDF 08          2085**  POWR11:			EX      AF,AF'
0B2CE0 3D          2086**          		DEC     A
0B2CE1 28 26       2087**          		JR      Z,POWR14        ;EXIT TYPE 1
0B2CE3 F2 EB 2C 0B 2088**          		JP      P,POWR13
0B2CE7 B9          2089**          		CP      C
0B2CE8 38 1F       2090**          		JR      C,POWR14        ;EXIT TYPE 2
0B2CEA 3C          2091**          		INC     A
0B2CEB 08          2092**  POWR13:			EX      AF,AF'
0B2CEC 3C          2093**          		INC     A
0B2CED CB FC       2094**          		SET     7,H
0B2CEF CD 0E 2C 0B 2095**          		CALL    X5
0B2CF3 30 06       2096**          		JR      NC,POWR12
0B2CF5 08          2097**          		EX      AF,AF'
0B2CF6 CD 48 2C 0B 2098**          		CALL    D2C
0B2CFA 08          2099**          		EX      AF,AF'
0B2CFB 08          2100**  POWR12:			EX      AF,AF'
0B2CFC DC 70 2B 0B 2101**          		CALL    C,ADD1_FP          ;ROUND UP
0B2D00 0C          2102**          		INC     C
0B2D01 FA DF 2C 0B 2103**          		JP      M,POWR11
0B2D05 C3 9F 2B 0B 2104**          		JP      OFLOW
0B2D09 CD 88 2B 0B 2105**  POWR14:			CALL    SWAP_FP
0B2D0D CB BA       2106**          		RES     7,D
0B2D0F D9          2107**          		EXX
0B2D10 E1          2108**          		POP     HL
0B2D11 D9          2109**          		EXX
0B2D12 E1          2110**          		POP     HL
0B2D13 08          2111**          		EX      AF,AF'
0B2D14 C9          2112**          		RET
0B2D15             2113**  ;
0B2D15             2114**  ; DIVA, DIVB - DIVISION PRIMITIVE.
0B2D15             2115**  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
0B2D15             2116**  ;               Remainder in H'L'HL
0B2D15             2117**  ;     Inputs: A = loop counter (normally -32)
0B2D15             2118**  ;     Destroys: A,D,E,H,L,D',E',H',L',F
0B2D15             2119**  ;
0B2D15 B7          2120**  DIVA:			OR      A               ;CLEAR CARRY
0B2D16             2121**  DIV0:
0B2D16 52 ED 42    2122**  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B2D19 D9          2123**          		EXX
0B2D1A 52 ED 42    2124**          		SBC.S   HL,BC
0B2D1D D9          2125**          		EXX
0B2D1E 30 07       2126**          		JR      NC,DIV1
0B2D20 52 09       2127**          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B2D22 D9          2128**          		EXX
0B2D23 52 ED 4A    2129**          		ADC.S   HL,BC
0B2D26 D9          2130**          		EXX
0B2D27 3F          2131**  DIV1:			CCF
0B2D28 CB 13       2132**  DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B2D2A CB 12       2133**          		RL      D
0B2D2C D9          2134**          		EXX
0B2D2D CB 13       2135**          		RL      E
0B2D2F CB 12       2136**          		RL      D
0B2D31 D9          2137**          		EXX
0B2D32 3C          2138**          		INC     A
0B2D33 F0          2139**          		RET     P
0B2D34             2140**  DIVB:
0B2D34 52 ED 6A    2141**  			ADC.S   HL,HL           ;DIVIDEND*2
0B2D37 D9          2142**          		EXX
0B2D38 52 ED 6A    2143**          		ADC.S   HL,HL
0B2D3B D9          2144**          		EXX
0B2D3C 30 D8       2145**          		JR      NC,DIV0
0B2D3E B7          2146**          		OR      A
0B2D3F 52 ED 42    2147**          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B2D42 D9          2148**          		EXX
0B2D43 52 ED 42    2149**          		SBC.S   HL,BC
0B2D46 D9          2150**          		EXX
0B2D47 37          2151**          		SCF
0B2D48 C3 28 2D 0B 2152**          		JP      DIVC
0B2D4C             2153**  ;
0B2D4C             2154**  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
0B2D4C             2155**  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
0B2D4C             2156**  ;    Inputs: A = loop counter (usually -32)
0B2D4C             2157**  ;            H'L'HL = 0
0B2D4C             2158**  ;    Destroys: D,E,H,L,D',E',H',L',A,F
0B2D4C             2159**  ;
0B2D4C B7          2160**  MULA:			OR      A               ;CLEAR CARRY
0B2D4D D9          2161**  MUL0:			EXX
0B2D4E CB 1A       2162**          		RR      D               ;MULTIPLIER/2
0B2D50 CB 1B       2163**          		RR      E
0B2D52 D9          2164**          		EXX
0B2D53 CB 1A       2165**          		RR      D
0B2D55 CB 1B       2166**          		RR      E
0B2D57 30 07       2167**          		JR      NC,MUL1
0B2D59 52 09       2168**          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B2D5B D9          2169**          		EXX
0B2D5C 52 ED 4A    2170**          		ADC.S   HL,BC
0B2D5F D9          2171**          		EXX
0B2D60 3C          2172**  MUL1:			INC     A
0B2D61 F0          2173**          		RET     P
0B2D62 D9          2174**  MULB:			EXX
0B2D63 CB 1C       2175**          		RR      H               ;PRODUCT/2
0B2D65 CB 1D       2176**          		RR      L
0B2D67 D9          2177**          		EXX
0B2D68 CB 1C       2178**          		RR      H
0B2D6A CB 1D       2179**          		RR      L
0B2D6C C3 4D 2D 0B 2180**          		JP      MUL0
0B2D70             2181**  ;
0B2D70             2182**  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
0B2D70             2183**  ;     Function: B'C'BC = SQR (D'E'DE)
0B2D70             2184**  ;     Inputs: A = loop counter (normally -31)
0B2D70             2185**  ;             B'C'BCH'L'HL initialised to 0
0B2D70             2186**  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
0B2D70             2187**  ;
0B2D70             2188**  SQR1:
0B2D70 52 ED 42    2189**  			SBC.S   HL,BC
0B2D73 D9          2190**          		EXX
0B2D74 52 ED 42    2191**          		SBC.S   HL,BC
0B2D77 D9          2192**          		EXX
0B2D78 0C          2193**          		INC     C
0B2D79 30 09       2194**          		JR      NC,SQR2
0B2D7B 0D          2195**          		DEC     C
0B2D7C 52 09       2196**          		ADD.S   HL,BC
0B2D7E D9          2197**          		EXX
0B2D7F 52 ED 4A    2198**          		ADC.S   HL,BC
0B2D82 D9          2199**          		EXX
0B2D83 0D          2200**          		DEC     C
0B2D84 3C          2201**  SQR2:			INC     A
0B2D85 F0          2202**          		RET     P
0B2D86 CB 21       2203**  SQRA:			SLA     C
0B2D88 CB 10       2204**          		RL      B
0B2D8A D9          2205**          		EXX
0B2D8B CB 11       2206**          		RL      C
0B2D8D CB 10       2207**          		RL      B
0B2D8F D9          2208**          		EXX
0B2D90 0C          2209**          		INC     C
0B2D91 CB 23       2210**          		SLA     E
0B2D93 CB 12       2211**          		RL      D
0B2D95 D9          2212**          		EXX
0B2D96 CB 13       2213**          		RL      E
0B2D98 CB 12       2214**          		RL      D
0B2D9A D9          2215**          		EXX
0B2D9B 52 ED 6A    2216**          		ADC.S   HL,HL
0B2D9E D9          2217**          		EXX
0B2D9F 52 ED 6A    2218**          		ADC.S   HL,HL
0B2DA2 D9          2219**          		EXX
0B2DA3 CB 23       2220**          		SLA     E
0B2DA5 CB 12       2221**          		RL      D
0B2DA7 D9          2222**          		EXX
0B2DA8 CB 13       2223**          		RL      E
0B2DAA CB 12       2224**          		RL      D
0B2DAC D9          2225**          		EXX
0B2DAD 52 ED 6A    2226**          		ADC.S   HL,HL
0B2DB0 D9          2227**          		EXX
0B2DB1 52 ED 6A    2228**          		ADC.S   HL,HL
0B2DB4 D9          2229**          		EXX
0B2DB5 D2 70 2D 0B 2230**          		JP      NC,SQR1
0B2DB9 B7          2231**  SQR3:			OR      A
0B2DBA 52 ED 42    2232**          		SBC.S   HL,BC
0B2DBD D9          2233**          		EXX
0B2DBE 52 ED 42    2234**          		SBC.S   HL,BC
0B2DC1 D9          2235**          		EXX
0B2DC2 0C          2236**          		INC     C
0B2DC3 C3 84 2D 0B 2237**          		JP      SQR2
0B2DC7             2238**  ;
0B2DC7             2239**  SQRB:
0B2DC7 52 29       2240**  			ADD.S   HL,HL
0B2DC9 D9          2241**          		EXX
0B2DCA 52 ED 6A    2242**          		ADC.S   HL,HL
0B2DCD D9          2243**          		EXX
0B2DCE 38 E9       2244**          		JR      C,SQR3
0B2DD0 3C          2245**          		INC     A
0B2DD1 0C          2246**          		INC     C
0B2DD2 52 ED 42    2247**          		SBC.S   HL,BC
0B2DD5 D9          2248**          		EXX
0B2DD6 52 ED 42    2249**          		SBC.S   HL,BC
0B2DD9 D9          2250**          		EXX
0B2DDA D0          2251**          		RET     NC
0B2DDB 52 09       2252**          		ADD.S   HL,BC
0B2DDD D9          2253**          		EXX
0B2DDE 52 ED 4A    2254**          		ADC.S   HL,BC
0B2DE1 D9          2255**          		EXX
0B2DE2 0D          2256**          		DEC     C
0B2DE3 C9          2257**          		RET
0B2DE4             2258**  ;
0B2DE4 DD 7E 00    2259**  DIGITQ:			LD      A,(IX)
0B2DE7 FE 3A       2260**          		CP      '9'+1
0B2DE9 3F          2261**          		CCF
0B2DEA D8          2262**          		RET     C
0B2DEB FE 30       2263**          		CP      '0'
0B2DED C9          2264**          		RET
0B2DEE             2265**  ;
0B2DEE DD 7E 00    2266**  SIGNQ:			LD      A,(IX)
0B2DF1 DD 23       2267**          		INC     IX
0B2DF3 FE 20       2268**          		CP      ' '
0B2DF5 28 F7       2269**          		JR      Z,SIGNQ
0B2DF7 FE 2B       2270**          		CP      '+'
0B2DF9 C8          2271**          		RET     Z
0B2DFA FE 2D       2272**          		CP      '-'
0B2DFC C8          2273**          		RET     Z
0B2DFD DD 2B       2274**          		DEC     IX
0B2DFF C9          2275**          		RET
0B2E00             0008*       include "basic/gpio.asm"
0B2E00             0001**  ;
0B2E00             0002**  ; Title:	BBC Basic for AGON - GPIO functions
0B2E00             0003**  ; Author:	Dean Belfield
0B2E00             0004**  ; Created:	12/05/2023
0B2E00             0005**  ; Last Updated:	12/05/2023
0B2E00             0006**  ;
0B2E00             0007**  ; Modinfo:
0B2E00             0008**  
0B2E00             0009**  			; INCLUDE	"macros.inc"
0B2E00             0010**  			; INCLUDE	"equs.inc"
0B2E00             0011**  
0B2E00             0012**  			; .ASSUME	ADL = 1
0B2E00             0013**  
0B2E00             0014**  			; SEGMENT CODE
0B2E00             0015**  
0B2E00             0016**  			; XDEF	GPIOB_SETMODE
0B2E00             0017**  
0B2E00             0018**  			; XREF	SWITCH_A
0B2E00             0019**  
0B2E00             0020**  ;  A: Mode
0B2E00             0021**  ;  B: Pins
0B2E00             0022**  ;
0B2E00 CD A5 3D 0B 0023**  GPIOB_SETMODE:		CALL	SWITCH_A
0B2E04 18 2E       0024**  			DW	GPIOB_M0	; Output
0B2E06 3D 2E       0025**  			DW	GPIOB_M1	; Input
0B2E08 5D 2E       0026**  			DW	GPIOB_M2	; Open Drain IO
0B2E0A 7D 2E       0027**  			DW	GPIOB_M3	; Open Source IO
0B2E0C 98 2E       0028**  			DW	GPIOB_M4	; Interrupt, Dual Edge
0B2E0E C4 2E       0029**  			DW	GPIOB_M5	; Alt Function
0B2E10 DF 2E       0030**  			DW	GPIOB_M6	; Interrupt, Active Low
0B2E12 06 2F       0031**  			DW	GPIOB_M7	; Interrupt, Active High
0B2E14 28 2F       0032**  			DW	GPIOB_M8	; Interrupt, Falling Edge
0B2E16 4A 2F       0033**  			DW	GPIOB_M9	; Interrupt, Rising Edge
0B2E18             0034**  
0B2E18             0035**  ; Output
0B2E18             0036**  ;
0B2E18             0037**  GPIOB_M0:		RES_GPIO PB_DDR,  B
0B2E18 C5          0001**M 		PUSH	BC
0B2E19 78          0002**M 		LD	A, val
0B2E1A 2F          0003**M 		CPL
0B2E1B 4F          0004**M 		LD	C, A
0B2E1C ED 38 9B    0005**M 		IN0	A, (reg)
0B2E1F A1          0006**M 		AND	C
0B2E20 ED 39 9B    0007**M 		OUT0	(reg), A
0B2E23 C1          0008**M 		POP	BC
0B2E24             0038**  			RES_GPIO PB_ALT1, B
0B2E24 C5          0001**M 		PUSH	BC
0B2E25 78          0002**M 		LD	A, val
0B2E26 2F          0003**M 		CPL
0B2E27 4F          0004**M 		LD	C, A
0B2E28 ED 38 9C    0005**M 		IN0	A, (reg)
0B2E2B A1          0006**M 		AND	C
0B2E2C ED 39 9C    0007**M 		OUT0	(reg), A
0B2E2F C1          0008**M 		POP	BC
0B2E30             0039**  			RES_GPIO PB_ALT2, B
0B2E30 C5          0001**M 		PUSH	BC
0B2E31 78          0002**M 		LD	A, val
0B2E32 2F          0003**M 		CPL
0B2E33 4F          0004**M 		LD	C, A
0B2E34 ED 38 9D    0005**M 		IN0	A, (reg)
0B2E37 A1          0006**M 		AND	C
0B2E38 ED 39 9D    0007**M 		OUT0	(reg), A
0B2E3B C1          0008**M 		POP	BC
0B2E3C C9          0040**  			RET
0B2E3D             0041**  
0B2E3D             0042**  ; Input
0B2E3D             0043**  ;
0B2E3D             0044**  GPIOB_M1:		SET_GPIO PB_DDR,  B
0B2E3D ED 38 9B    0001**M 		IN0	A, (reg)
0B2E40 B0          0002**M 		OR	val
0B2E41 ED 39 9B    0003**M 		OUT0	(reg), A
0B2E44             0045**  			RES_GPIO PB_ALT1, B
0B2E44 C5          0001**M 		PUSH	BC
0B2E45 78          0002**M 		LD	A, val
0B2E46 2F          0003**M 		CPL
0B2E47 4F          0004**M 		LD	C, A
0B2E48 ED 38 9C    0005**M 		IN0	A, (reg)
0B2E4B A1          0006**M 		AND	C
0B2E4C ED 39 9C    0007**M 		OUT0	(reg), A
0B2E4F C1          0008**M 		POP	BC
0B2E50             0046**  			RES_GPIO PB_ALT2, B
0B2E50 C5          0001**M 		PUSH	BC
0B2E51 78          0002**M 		LD	A, val
0B2E52 2F          0003**M 		CPL
0B2E53 4F          0004**M 		LD	C, A
0B2E54 ED 38 9D    0005**M 		IN0	A, (reg)
0B2E57 A1          0006**M 		AND	C
0B2E58 ED 39 9D    0007**M 		OUT0	(reg), A
0B2E5B C1          0008**M 		POP	BC
0B2E5C C9          0047**  			RET
0B2E5D             0048**  
0B2E5D             0049**  ; Open Drain IO
0B2E5D             0050**  ;
0B2E5D             0051**  GPIOB_M2:		RES_GPIO PB_DDR,  B
0B2E5D C5          0001**M 		PUSH	BC
0B2E5E 78          0002**M 		LD	A, val
0B2E5F 2F          0003**M 		CPL
0B2E60 4F          0004**M 		LD	C, A
0B2E61 ED 38 9B    0005**M 		IN0	A, (reg)
0B2E64 A1          0006**M 		AND	C
0B2E65 ED 39 9B    0007**M 		OUT0	(reg), A
0B2E68 C1          0008**M 		POP	BC
0B2E69             0052**  			SET_GPIO PB_ALT1, B
0B2E69 ED 38 9C    0001**M 		IN0	A, (reg)
0B2E6C B0          0002**M 		OR	val
0B2E6D ED 39 9C    0003**M 		OUT0	(reg), A
0B2E70             0053**  			RES_GPIO PB_ALT2, B
0B2E70 C5          0001**M 		PUSH	BC
0B2E71 78          0002**M 		LD	A, val
0B2E72 2F          0003**M 		CPL
0B2E73 4F          0004**M 		LD	C, A
0B2E74 ED 38 9D    0005**M 		IN0	A, (reg)
0B2E77 A1          0006**M 		AND	C
0B2E78 ED 39 9D    0007**M 		OUT0	(reg), A
0B2E7B C1          0008**M 		POP	BC
0B2E7C C9          0054**  			RET
0B2E7D             0055**  
0B2E7D             0056**  ; Open Source IO
0B2E7D             0057**  ;
0B2E7D             0058**  GPIOB_M3:		SET_GPIO PB_DDR,  B
0B2E7D ED 38 9B    0001**M 		IN0	A, (reg)
0B2E80 B0          0002**M 		OR	val
0B2E81 ED 39 9B    0003**M 		OUT0	(reg), A
0B2E84             0059**  			SET_GPIO PB_ALT1, B
0B2E84 ED 38 9C    0001**M 		IN0	A, (reg)
0B2E87 B0          0002**M 		OR	val
0B2E88 ED 39 9C    0003**M 		OUT0	(reg), A
0B2E8B             0060**  			RES_GPIO PB_ALT2, B
0B2E8B C5          0001**M 		PUSH	BC
0B2E8C 78          0002**M 		LD	A, val
0B2E8D 2F          0003**M 		CPL
0B2E8E 4F          0004**M 		LD	C, A
0B2E8F ED 38 9D    0005**M 		IN0	A, (reg)
0B2E92 A1          0006**M 		AND	C
0B2E93 ED 39 9D    0007**M 		OUT0	(reg), A
0B2E96 C1          0008**M 		POP	BC
0B2E97 C9          0061**  			RET
0B2E98             0062**  
0B2E98             0063**  ; Interrupt, Dual Edge
0B2E98             0064**  ;
0B2E98             0065**  GPIOB_M4:		SET_GPIO PB_DR,   B
0B2E98 ED 38 9A    0001**M 		IN0	A, (reg)
0B2E9B B0          0002**M 		OR	val
0B2E9C ED 39 9A    0003**M 		OUT0	(reg), A
0B2E9F             0066**  			RES_GPIO PB_DDR,  B
0B2E9F C5          0001**M 		PUSH	BC
0B2EA0 78          0002**M 		LD	A, val
0B2EA1 2F          0003**M 		CPL
0B2EA2 4F          0004**M 		LD	C, A
0B2EA3 ED 38 9B    0005**M 		IN0	A, (reg)
0B2EA6 A1          0006**M 		AND	C
0B2EA7 ED 39 9B    0007**M 		OUT0	(reg), A
0B2EAA C1          0008**M 		POP	BC
0B2EAB             0067**  			RES_GPIO PB_ALT1, B
0B2EAB C5          0001**M 		PUSH	BC
0B2EAC 78          0002**M 		LD	A, val
0B2EAD 2F          0003**M 		CPL
0B2EAE 4F          0004**M 		LD	C, A
0B2EAF ED 38 9C    0005**M 		IN0	A, (reg)
0B2EB2 A1          0006**M 		AND	C
0B2EB3 ED 39 9C    0007**M 		OUT0	(reg), A
0B2EB6 C1          0008**M 		POP	BC
0B2EB7             0068**  			RES_GPIO PB_ALT2, B
0B2EB7 C5          0001**M 		PUSH	BC
0B2EB8 78          0002**M 		LD	A, val
0B2EB9 2F          0003**M 		CPL
0B2EBA 4F          0004**M 		LD	C, A
0B2EBB ED 38 9D    0005**M 		IN0	A, (reg)
0B2EBE A1          0006**M 		AND	C
0B2EBF ED 39 9D    0007**M 		OUT0	(reg), A
0B2EC2 C1          0008**M 		POP	BC
0B2EC3 C9          0069**  			RET
0B2EC4             0070**  
0B2EC4             0071**  ; Alt Function
0B2EC4             0072**  ;
0B2EC4             0073**  GPIOB_M5:		SET_GPIO PB_DDR,  B
0B2EC4 ED 38 9B    0001**M 		IN0	A, (reg)
0B2EC7 B0          0002**M 		OR	val
0B2EC8 ED 39 9B    0003**M 		OUT0	(reg), A
0B2ECB             0074**  			RES_GPIO PB_ALT1, B
0B2ECB C5          0001**M 		PUSH	BC
0B2ECC 78          0002**M 		LD	A, val
0B2ECD 2F          0003**M 		CPL
0B2ECE 4F          0004**M 		LD	C, A
0B2ECF ED 38 9C    0005**M 		IN0	A, (reg)
0B2ED2 A1          0006**M 		AND	C
0B2ED3 ED 39 9C    0007**M 		OUT0	(reg), A
0B2ED6 C1          0008**M 		POP	BC
0B2ED7             0075**  			SET_GPIO PB_ALT2, B
0B2ED7 ED 38 9D    0001**M 		IN0	A, (reg)
0B2EDA B0          0002**M 		OR	val
0B2EDB ED 39 9D    0003**M 		OUT0	(reg), A
0B2EDE C9          0076**  			RET
0B2EDF             0077**  
0B2EDF             0078**  ; Interrupt, Active Low
0B2EDF             0079**  ;
0B2EDF             0080**  GPIOB_M6:		RES_GPIO PB_DR,   B
0B2EDF C5          0001**M 		PUSH	BC
0B2EE0 78          0002**M 		LD	A, val
0B2EE1 2F          0003**M 		CPL
0B2EE2 4F          0004**M 		LD	C, A
0B2EE3 ED 38 9A    0005**M 		IN0	A, (reg)
0B2EE6 A1          0006**M 		AND	C
0B2EE7 ED 39 9A    0007**M 		OUT0	(reg), A
0B2EEA C1          0008**M 		POP	BC
0B2EEB             0081**  			RES_GPIO PB_DDR,  B
0B2EEB C5          0001**M 		PUSH	BC
0B2EEC 78          0002**M 		LD	A, val
0B2EED 2F          0003**M 		CPL
0B2EEE 4F          0004**M 		LD	C, A
0B2EEF ED 38 9B    0005**M 		IN0	A, (reg)
0B2EF2 A1          0006**M 		AND	C
0B2EF3 ED 39 9B    0007**M 		OUT0	(reg), A
0B2EF6 C1          0008**M 		POP	BC
0B2EF7             0082**  			SET_GPIO PB_ALT1, B
0B2EF7 ED 38 9C    0001**M 		IN0	A, (reg)
0B2EFA B0          0002**M 		OR	val
0B2EFB ED 39 9C    0003**M 		OUT0	(reg), A
0B2EFE             0083**  			SET_GPIO PB_ALT2, B
0B2EFE ED 38 9D    0001**M 		IN0	A, (reg)
0B2F01 B0          0002**M 		OR	val
0B2F02 ED 39 9D    0003**M 		OUT0	(reg), A
0B2F05 C9          0084**  			RET
0B2F06             0085**  
0B2F06             0086**  
0B2F06             0087**  ; Interrupt, Active High
0B2F06             0088**  ;
0B2F06             0089**  GPIOB_M7:		SET_GPIO PB_DR,   B
0B2F06 ED 38 9A    0001**M 		IN0	A, (reg)
0B2F09 B0          0002**M 		OR	val
0B2F0A ED 39 9A    0003**M 		OUT0	(reg), A
0B2F0D             0090**  			RES_GPIO PB_DDR,  B
0B2F0D C5          0001**M 		PUSH	BC
0B2F0E 78          0002**M 		LD	A, val
0B2F0F 2F          0003**M 		CPL
0B2F10 4F          0004**M 		LD	C, A
0B2F11 ED 38 9B    0005**M 		IN0	A, (reg)
0B2F14 A1          0006**M 		AND	C
0B2F15 ED 39 9B    0007**M 		OUT0	(reg), A
0B2F18 C1          0008**M 		POP	BC
0B2F19             0091**  			SET_GPIO PB_ALT1, B
0B2F19 ED 38 9C    0001**M 		IN0	A, (reg)
0B2F1C B0          0002**M 		OR	val
0B2F1D ED 39 9C    0003**M 		OUT0	(reg), A
0B2F20             0092**  			SET_GPIO PB_ALT2, B
0B2F20 ED 38 9D    0001**M 		IN0	A, (reg)
0B2F23 B0          0002**M 		OR	val
0B2F24 ED 39 9D    0003**M 		OUT0	(reg), A
0B2F27 C9          0093**  			RET
0B2F28             0094**  
0B2F28             0095**  
0B2F28             0096**  ; Interrupt, Falling Edge
0B2F28             0097**  ;
0B2F28             0098**  GPIOB_M8:		RES_GPIO PB_DR,   B
0B2F28 C5          0001**M 		PUSH	BC
0B2F29 78          0002**M 		LD	A, val
0B2F2A 2F          0003**M 		CPL
0B2F2B 4F          0004**M 		LD	C, A
0B2F2C ED 38 9A    0005**M 		IN0	A, (reg)
0B2F2F A1          0006**M 		AND	C
0B2F30 ED 39 9A    0007**M 		OUT0	(reg), A
0B2F33 C1          0008**M 		POP	BC
0B2F34             0099**  			SET_GPIO PB_DDR,  B
0B2F34 ED 38 9B    0001**M 		IN0	A, (reg)
0B2F37 B0          0002**M 		OR	val
0B2F38 ED 39 9B    0003**M 		OUT0	(reg), A
0B2F3B             0100**  			SET_GPIO PB_ALT1, B
0B2F3B ED 38 9C    0001**M 		IN0	A, (reg)
0B2F3E B0          0002**M 		OR	val
0B2F3F ED 39 9C    0003**M 		OUT0	(reg), A
0B2F42             0101**  			SET_GPIO PB_ALT2, B
0B2F42 ED 38 9D    0001**M 		IN0	A, (reg)
0B2F45 B0          0002**M 		OR	val
0B2F46 ED 39 9D    0003**M 		OUT0	(reg), A
0B2F49 C9          0102**  			RET
0B2F4A             0103**  
0B2F4A             0104**  ; Interrupt, Rising Edge
0B2F4A             0105**  ;
0B2F4A             0106**  GPIOB_M9:		SET_GPIO PB_DR,   B
0B2F4A ED 38 9A    0001**M 		IN0	A, (reg)
0B2F4D B0          0002**M 		OR	val
0B2F4E ED 39 9A    0003**M 		OUT0	(reg), A
0B2F51             0107**  			SET_GPIO PB_DDR,  B
0B2F51 ED 38 9B    0001**M 		IN0	A, (reg)
0B2F54 B0          0002**M 		OR	val
0B2F55 ED 39 9B    0003**M 		OUT0	(reg), A
0B2F58             0108**  			SET_GPIO PB_ALT1, B
0B2F58 ED 38 9C    0001**M 		IN0	A, (reg)
0B2F5B B0          0002**M 		OR	val
0B2F5C ED 39 9C    0003**M 		OUT0	(reg), A
0B2F5F             0109**  			SET_GPIO PB_ALT2, B
0B2F5F ED 38 9D    0001**M 		IN0	A, (reg)
0B2F62 B0          0002**M 		OR	val
0B2F63 ED 39 9D    0003**M 		OUT0	(reg), A
0B2F66 C9          0110**  			RET
0B2F67             0009*       include "basic/main.asm"
0B2F67             0001**  ;
0B2F67             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B2F67             0003**  ;		Command, Error and Lexical Analysis Module - "MAIN"
0B2F67             0004**  ; Author:	(C) Copyright  R.T.Russell  1984
0B2F67             0005**  ; Modified By:	Dean Belfield
0B2F67             0006**  ; Created:	12/05/2023
0B2F67             0007**  ; Last Updated:	26/11/2023
0B2F67             0008**  ;
0B2F67             0009**  ; Modinfo:
0B2F67             0010**  ; 07/05/1984:	Version 2.3
0B2F67             0011**  ; 01/03/1987:	Version 3.0
0B2F67             0012**  ; 03/05/2022:	Modified by Dean Belfield
0B2F67             0013**  ; 06/06/2023:	Modified to run in ADL mode
0B2F67             0014**  ; 26/06/2023:	Fixed binary and unary indirection
0B2F67             0015**  ; 17/08/2023:	Added binary constants
0B2F67             0016**  ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
0B2F67             0017**  ; 26/11/2023:	Fixed bug in AUTOLOAD
0B2F67             0018**  
0B2F67             0019**  			; .ASSUME	ADL = 1
0B2F67             0020**  
0B2F67             0021**  			; INCLUDE	"equs.inc"
0B2F67             0022**  
0B2F67             0023**  			; SEGMENT CODE
0B2F67             0024**  
0B2F67             0025**  			; XDEF	_basic_main
0B2F67             0026**  
0B2F67             0027**  			; XDEF	COLD
0B2F67             0028**  			; XDEF	WARM
0B2F67             0029**  			; XDEF	CLOOP
0B2F67             0030**  			; XDEF	DELETE
0B2F67             0031**  			; XDEF	LIST_
0B2F67             0032**  			; XDEF	RENUM
0B2F67             0033**  			; XDEF	AUTO
0B2F67             0034**  			; XDEF	NEW
0B2F67             0035**  			; XDEF	OLD
0B2F67             0036**  			; XDEF	LOAD
0B2F67             0037**  			; XDEF	SAVE
0B2F67             0038**  			; XDEF	ERROR_
0B2F67             0039**  			; XDEF	EXTERR
0B2F67             0040**  			; XDEF	LOAD0
0B2F67             0041**  			; XDEF	CLEAR
0B2F67             0042**  			; XDEF	CRLF
0B2F67             0043**  			; XDEF	OUTCHR
0B2F67             0044**  			; XDEF	OUT_
0B2F67             0045**  			; XDEF	FINDL
0B2F67             0046**  			; XDEF	SETLIN
0B2F67             0047**  			; XDEF	PBCDL
0B2F67             0048**  			; XDEF	SAYLN
0B2F67             0049**  			; XDEF	PUTVAR
0B2F67             0050**  			; XDEF	GETVAR
0B2F67             0051**  			; XDEF	GETDEF
0B2F67             0052**  			; XDEF	CREATE
0B2F67             0053**  			; XDEF	RANGE
0B2F67             0054**  			; XDEF	LEXAN2
0B2F67             0055**  			; XDEF	REPORT
0B2F67             0056**  			; XDEF	TELL
0B2F67             0057**  			; XDEF	SPACE_
0B2F67             0058**  			; XDEF	KEYWDS
0B2F67             0059**  			; XDEF	KEYWDL
0B2F67             0060**  			; XDEF	ONEDIT
0B2F67             0061**  			; XDEF	ONEDIT1
0B2F67             0062**  			; XDEF	LISTIT
0B2F67             0063**  			; XDEF	CLEAN
0B2F67             0064**  
0B2F67             0065**  			; XREF	LISTON
0B2F67             0066**  			; XREF	ERRTXT
0B2F67             0067**  			; XREF	OSINIT
0B2F67             0068**  			; XREF	HIMEM
0B2F67             0069**  			; XREF	PAGE_
0B2F67             0070**  			; XREF	CHAIN0
0B2F67             0071**  			; XREF	PROMPT
0B2F67             0072**  			; XREF	ERRTRP
0B2F67             0073**  			; XREF	ERRLIN
0B2F67             0074**  			; XREF	AUTONO
0B2F67             0075**  			; XREF	LINENO
0B2F67             0076**  			; XREF	INCREM
0B2F67             0077**  			; XREF	OSLINE
0B2F67             0078**  			; XREF	COUNT
0B2F67             0079**  			; XREF	NXT
0B2F67             0080**  			; XREF	BUFFER
0B2F67             0081**  			; XREF	XEQ
0B2F67             0082**  			; XREF	TOP
0B2F67             0083**  			; XREF	EXPRI
0B2F67             0084**  			; XREF	SEARCH
0B2F67             0085**  			; XREF	LTRAP
0B2F67             0086**  			; XREF	LOMEM
0B2F67             0087**  			; XREF	DECODE
0B2F67             0088**  			; XREF	EXPRS
0B2F67             0089**  			; XREF	OSSAVE
0B2F67             0090**  			; XREF	ERR
0B2F67             0091**  			; XREF	ERL
0B2F67             0092**  			; XREF	TRACEN
0B2F67             0093**  			; XREF	RESET
0B2F67             0094**  			; XREF	OSSHUT
0B2F67             0095**  			; XREF	OSLOAD
0B2F67             0096**  			; XREF	FREE
0B2F67             0097**  			; XREF	DYNVAR
0B2F67             0098**  			; XREF	FILL
0B2F67             0099**  			; XREF	OSWRCH
0B2F67             0100**  			; XREF	WIDTH
0B2F67             0101**  			; XREF	COMMA
0B2F67             0102**  			; XREF	MUL16
0B2F67             0103**  			; XREF	BRAKET
0B2F67             0104**  			; XREF	X4OR5
0B2F67             0105**  			; XREF	LOADN
0B2F67             0106**  			; XREF	SFIX
0B2F67             0107**  			; XREF	ITEMI
0B2F67             0108**  			; XREF	FNPTR
0B2F67             0109**  			; XREF	PROPTR
0B2F67             0110**  			; XREF	CHECK
0B2F67             0111**  			; XREF	TERMQ
0B2F67             0112**  			; XREF	OSWRCHCH
0B2F67             0113**  			; XREF	NEWIT
0B2F67             0114**  			; XREF	BAD
0B2F67             0115**  			; XREF	RAM_START
0B2F67             0116**  			; XREF	RAM_END
0B2F67             0117**  			; XREF	R0
0B2F67             0118**  			; XREF	STAR_VERSION
0B2F67             0119**  
0B2F67             0120**  			; XREF	_basic_end			; In init.asm
0B2F67             0121**  ;
0B2F67             0122**  ; A handful of common token IDs
0B2F67             0123**  ;
0B2F67             0124**  TERROR_MN:			EQU     85H
0B2F67             0125**  LINE_MN_:			EQU     86H
0B2F67             0126**  ELSE_MN_:			EQU     8BH
0B2F67             0127**  THEN_MN_:			EQU     8CH
0B2F67             0128**  LINO_MN:			EQU     8DH
0B2F67             0129**  FN:			EQU     A4H
0B2F67             0130**  TO_MN:			EQU     B8H
0B2F67             0131**  REN:			EQU     CCH
0B2F67             0132**  DATA_MN_:			EQU     DCH
0B2F67             0133**  DIM:			EQU     DEH
0B2F67             0134**  FOR:			EQU     E3H
0B2F67             0135**  GOSUB:			EQU     E4H
0B2F67             0136**  GOTO:			EQU     E5H
0B2F67             0137**  TIF:			EQU     E7H
0B2F67             0138**  LOCAL_:			EQU     EAH
0B2F67             0139**  NEXT:			EQU     EDH
0B2F67             0140**  ON_:			EQU     EEH
0B2F67             0141**  PROC:			EQU     F2H
0B2F67             0142**  REM:			EQU     F4H
0B2F67             0143**  REPEAT:			EQU     F5H
0B2F67             0144**  RESTOR:			EQU     F7H
0B2F67             0145**  TRACE:			EQU     FCH
0B2F67             0146**  UNTIL:			EQU     FDH
0B2F67             0147**  ;
0B2F67             0148**  ; This defines the block of tokens that are pseudo-variables.
0B2F67             0149**  ; There are two versions of each token, a GET and a SET
0B2F67             0150**  
0B2F67             0151**  ; Name  : GET : SET
0B2F67             0152**  ; ------:-----:----
0B2F67             0153**  ; PTR   : 8Fh : CFh
0B2F67             0154**  ; PAGE  : 90h : D0h
0B2F67             0155**  ; TIME  : 91h : D1h
0B2F67             0156**  ; LOMEM : 92h : D2h
0B2F67             0157**  ; HIMEM : 93h : D3h
0B2F67             0158**  ;
0B2F67             0159**  ; Examples:
0B2F67             0160**  ;   LET A% = PAGE : REM This is the GET version
0B2F67             0161**  ;   PAGE = 40000  : REM This is the SET version
0B2F67             0162**  ;
0B2F67             0163**  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
0B2F67             0164**  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
0B2F67             0165**  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
0B2F67             0166**  
0B2F67             0167**  ; The main routine
0B2F67             0168**  ; IXU: argv - pointer to array of parameters
0B2F67             0169**  ;   C: argc - number of parameters
0B2F67             0170**  ; Returns:
0B2F67             0171**  ;  HL: Error code, or 0 if OK
0B2F67             0172**  ;
0B2F67 21 00 49 0B 0173**  _basic_main:			LD	HL, ACCS		; Clear the ACCS
0B2F6B 36 00       0174**  			LD	(HL), 0
0B2F6D 79          0175**  			LD	A, C
0B2F6E FE 02       0176**  			CP	2
0B2F70 28 2D       0177**  			JR	Z, AUTOLOAD		; 2 parameters = autoload
0B2F72 38 3F       0178**  			JR	C, COLD			; 1 parameter = normal start
0B2F74 CD E9 3F 0B 0179**  			CALL	STAR_VERSION
0B2F78 CD 41 3D 0B 0180**  			CALL	TELL
0B2F7C 55 73 61 67 0181**  			DB	"Usage:\n\r"
       65 3A 0A 0D 
0B2F84 52 55 4E 20 0182**  			DB	"RUN . <filename>\n\r", 0
       2E 20 3C 66 
       69 6C 65 6E 
       61 6D 65 3E 
       0A 0D 00    
0B2F97 21 00 00 00 0183**  			LD	HL, 0			; The error code
0B2F9B C3 69 4D 0B 0184**  			JP	_basic_end
0B2F9F             0185**  ;
0B2F9F DD 27 03    0186**  AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
0B2FA2 11 00 49 0B 0187**  			LD	DE, ACCS		;  DE: Destination address
0B2FA6 7E          0188**  AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
0B2FA7 12          0189**  			LD	(DE), A			;
0B2FA8 23          0190**  			INC	HL			; Increase the source pointer
0B2FA9 1C          0191**  			INC	E			; We only need to increase E as ACCS is on a page boundary
0B2FAA 28 03       0192**  			JR	Z, AUTOLOAD_2		; End if we hit the page boundary
0B2FAC B7          0193**  			OR	A
0B2FAD 20 F7       0194**  			JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
0B2FAF 1D          0195**  AUTOLOAD_2:		DEC	E
0B2FB0 3E 0D       0196**  			LD	A, CR
0B2FB2 12          0197**  			LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
0B2FB3             0198**  ;
0B2FB3 E1          0199**  COLD:			POP	HL			; Pop the return address to init off SPS
0B2FB4 E5          0200**  			PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
0B2FB5 21 00 4B 0B 0201**  			LD	HL, STAVAR		; Cold start
0B2FB9 F9          0202**  			LD	SP, HL
0B2FBA 36 0A       0203**  			LD	(HL), 10
0B2FBC 23          0204**  			INC	HL
0B2FBD 36 09       0205**  			LD	(HL),9
0B2FBF CD 32 3F 0B 0206**  			CALL    OSINIT			; Call the machine specific OS initialisation routines
0B2FC3 ED 53 20 4C 0207**  			LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
       0B          
0B2FC8 22 14 4C 0B 0208**  			LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
0B2FCC 3E B7       0209**  			LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
0B2FCE 32 40 4C 0B 0210**  			LD      (LISTON),A
0B2FD2 21 0D 30 0B 0211**  			LD      HL,NOTICE
0B2FD6 22 2F 4C 0B 0212**  			LD      (ERRTXT),HL
0B2FDA CD 1D 38 0B 0213**  			CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
0B2FDE 3A 00 49 0B 0214**  			LD	A,(ACCS)		; Check if there is a filename in ACCS
0B2FE2 B7          0215**  			OR	A
0B2FE3 C2 04 0B 0B 0216**  			JP	NZ,CHAIN0		; Yes, so load and run
0B2FE7 CD E9 3F 0B 0217**  			CALL	STAR_VERSION		;
0B2FEB CD 41 3D 0B 0218**  			CALL    TELL			; Output the welcome message
0B2FEF 42 42 43 20 0219**  			DB    	"BBC BASIC (Z80) Version 3.00\n\r"
       42 41 53 49 
       43 20 28 5A 
       38 30 29 20 
       56 65 72 73 
       69 6F 6E 20 
       33 2E 30 30 
       0A 0D       
0B300D 28 43 29 20 0220**  NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
       43 6F 70 79 
       72 69 67 68 
       74 20 52 2E 
       54 2E 52 75 
       73 73 65 6C 
       6C 20 31 39 
       38 37 0A 0D 
0B302D 0A 0D 00    0221**  			DB	"\n\r", 0
0B3030             0222**  ;
0B3030 F6          0223**  WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
0B3031             0224**  ;
0B3031             0225**  ; This is the main entry point for BASIC
0B3031             0226**  ;
0B3031 37          0227**  CLOOP:			SCF				; See above - not sure why this is here!
0B3032 ED 7B 20 4C 0228**  			LD      SP,(HIMEM)
       0B          
0B3037 CD AB 3E 0B 0229**  			CALL    PROMPT          	; Prompt user
0B303B 21 40 4C 0B 0230**  			LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0B303F 7E          0231**  			LD      A,(HL)			; Fetch the value
0B3040 E6 0F       0232**  			AND     0FH             	; Bottom nibble: LISTO
0B3042 F6 B0       0233**  			OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0B3044 77          0234**  			LD      (HL),A			; Store back in
0B3045 ED 62       0235**  			SBC     HL,HL           	; HL: 0
0B3047 22 2C 4C 0B 0236**  			LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0B304B 22 35 4C 0B 0237**  			LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0B304F             0238**  ;
0B304F 2A 29 4C 0B 0239**  			LD      HL,(AUTONO)		; Get the auto line number
0B3053 22 23 4C 0B 0240**  			LD      (LINENO),HL		; Store in line number
0B3057 7C          0241**  			LD      A,H			; If the auto line number is zero then
0B3058 B5          0242**  			OR      L
0B3059 28 1E       0243**  			JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0B305B             0244**  ;
0B305B             0245**  ; This section handles auto line numbering
0B305B             0246**  ;
0B305B E5          0247**  			PUSH    HL			; Stack the line number
0B305C CD AC 39 0B 0248**  			CALL    PBCD           	 	; Output the line number
0B3060 E1          0249**  			POP     HL			; Pop the line number back off the stack
0B3061             0250**  ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
0B3061             0251**  ;			LD      B,0			; So clear B
0B3061 01 00 00 00 0252**  			LD	BC, 0			; Load BC with Increment
0B3065 3A 41 4C 0B 0253**  			LD	A,(INCREM)
0B3069 4F          0254**  			LD	C, A
0B306A 09          0255**  			ADD     HL,BC			; Add the increment to the line number
0B306B DA D6 3B 0B 0256**  			JP      C,TOOBIG		; And error if we wrap
0B306F 22 29 4C 0B 0257**  			LD      (AUTONO),HL		; Store the new auto line number
0B3073 3E 20       0258**  			LD      A,' '			; Print a space
0B3075 CD 00 39 0B 0259**  			CALL    OUTCHR
0B3079             0260**  ;
0B3079             0261**  ; This section invokes the line editor
0B3079             0262**  ;
0B3079 21 00 49 0B 0263**  NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0B307D CD 10 3E 0B 0264**  			CALL    OSLINE          	; Call the line editor in MOS
0B3081 CD 8D 30 0B 0265**  ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0B3085 DC F0 37 0B 0266**  			CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0B3089 C3 31 30 0B 0267**  			JP      CLOOP			; Jump back to immediate mode
0B308D             0268**  ;
0B308D             0269**  ; This bit enters the line into memory
0B308D             0270**  ; Also called from OSLOAD_TXT
0B308D             0271**  ; Returns:
0B308D             0272**  ; F: C if a new line has been entered (CLEAN will need to be called)
0B308D             0273**  ;
0B308D AF          0274**  ONEDIT1:		XOR     A			; Entry point after *EDIT
0B308E 32 3D 4C 0B 0275**  			LD      (COUNT),A
0B3092 FD 21 00 49 0276**  			LD      IY,ACCS
       0B          
0B3097 CD AA 3B 0B 0277**  			CALL    LINNUM			; HL: The line number from the input buffer
0B309B CD 21 0A 0B 0278**  			CALL    NXT			; Skip spaces
0B309F 7C          0279**  			LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0B30A0 B5          0280**  			OR      L
0B30A1 28 04       0281**  			JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0B30A3 22 23 4C 0B 0282**  			LD      (LINENO),HL		; Otherwise store it
0B30A7             0283**  ;
0B30A7             0284**  ; This bit does the lexical analysis and tokenisation
0B30A7             0285**  ;
0B30A7 0E 01       0286**  LNZERO:			LD	C,1			; Left mode
0B30A9 11 00 4A 0B 0287**  			LD      DE,BUFFER		; Buffer for tokenised BASIC
0B30AD CD 50 3C 0B 0288**  			CALL    LEXAN2          	; Lexical analysis on the user input
0B30B1 12          0289**  			LD      (DE),A          	; Terminator
0B30B2 AF          0290**  			XOR     A
0B30B3             0291**  ;			LD      B,A
0B30B3             0292**  ;			LD      C,E             	; BC: Line length
0B30B3 01 00 00 00 0293**  			LD	BC,0
0B30B7 4B          0294**  			LD	C,E			; BC: Line length
0B30B8 13          0295**  			INC     DE
0B30B9 12          0296**  			LD      (DE),A          	; Zero next
0B30BA 2A 23 4C 0B 0297**  			LD      HL,(LINENO)		; Get the line number
0B30BE 7C          0298**  			LD      A,H			; Is it zero, i.e. a command with no line number?
0B30BF B5          0299**  			OR      L
0B30C0 FD 21 00 4A 0300**  			LD      IY,BUFFER       	; Yes, so we're in immediate mode
       0B          
0B30C5 CA 47 0B 0B 0301**  			JP      Z,XEQ           	; Execute it
0B30C9             0302**  ;
0B30C9             0303**  ; This section stores the BASIC line in memory
0B30C9             0304**  ;
0B30C9 C5          0305**  			PUSH    BC
0B30CA E5          0306**  			PUSH    HL
0B30CB CD FC 37 0B 0307**  			CALL    SETTOP          	; Set TOP sysvar
0B30CF E1          0308**  			POP     HL
0B30D0 CD 40 39 0B 0309**  			CALL    FINDL			; Find the address of the line
0B30D4 CC B3 37 0B 0310**  			CALL    Z,DEL			; Delete the existing line if found
0B30D8 C1          0311**  			POP     BC
0B30D9 79          0312**  			LD      A,C			; Check for the line length being zero, i.e.
0B30DA B7          0313**  			OR      A			; the user has just entered a line number in the command line
0B30DB C8          0314**  			RET	Z 	         	; If so, then don't do anything else
0B30DC C6 04       0315**  			ADD     A,4
0B30DE 4F          0316**  			LD      C,A             	; Length inclusive
0B30DF D5          0317**  			PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
0B30E0 C5          0318**  			PUSH    BC              	; BC: Line length
0B30E1 EB          0319**  			EX      DE,HL			; DE: Address of the line in memory
0B30E2 2A 17 4C 0B 0320**  			LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
0B30E6 E5          0321**  			PUSH    HL			; Stack TOP (current TOP value)
0B30E7 09          0322**  			ADD     HL,BC			; Add the line length to HL, the new TOP value
0B30E8 E5          0323**  			PUSH    HL			; Stack HL (new TOP value)
0B30E9 24          0324**  			INC     H			; Add 256 to HL
0B30EA AF          0325**  			XOR     A
0B30EB ED 72       0326**  			SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
0B30ED E1          0327**  			POP     HL			; Pop HL (new TOP value)
0B30EE D2 11 37 0B 0328**  			JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0B30F2 22 17 4C 0B 0329**  			LD      (TOP),HL		; Store new value of TOP
0B30F6 E3          0330**  			EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0B30F7 E5          0331**  			PUSH    HL			; PUSH current TOP value
0B30F8 23          0332**  			INC     HL
0B30F9 B7          0333**  			OR      A
0B30FA ED 52       0334**  			SBC     HL,DE			; DE: Address of the line in memory
0B30FC 44          0335**  			LD      B,H             	; BC: Amount to move
0B30FD 4D          0336**  			LD      C,L
0B30FE E1          0337**  			POP     HL			; HL: Destination (current TOP value)
0B30FF D1          0338**  			POP     DE			; DE: Source (new TOP value)
0B3100 28 02       0339**  			JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0B3102 ED B8       0340**  			LDDR                    	; Otherwise, make space for the new line in the program
0B3104 C1          0341**  ATEND:			POP     BC              	; BC: Line length
0B3105 D1          0342**  			POP     DE              	; DE: Line number
0B3106 23          0343**  			INC     HL			; HL: Destination address
0B3107 71          0344**  			LD      (HL),C          	; Store length
0B3108 23          0345**  			INC     HL
0B3109 73          0346**  			LD      (HL),E          	; Store line number
0B310A 23          0347**  			INC     HL
0B310B 72          0348**  			LD      (HL),D
0B310C 23          0349**  			INC     HL
0B310D 11 00 4A 0B 0350**  			LD      DE,BUFFER		; DE: Location of the new, tokenised line
0B3111 EB          0351**  			EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0B3112 0D          0352**  			DEC     C			; Subtract 3 from the number of bytes to copy to
0B3113 0D          0353**  			DEC     C			; compensate for the 3 bytes stored above (length and line number)
0B3114 0D          0354**  			DEC     C
0B3115 ED B0       0355**  			LDIR                    	; Add the line to the BASIC program
0B3117 37          0356**  			SCF				; To flag we need to call CLEAN
0B3118 C9          0357**  			RET
0B3119             0358**  ;
0B3119             0359**  ; List of tokens and keywords. If a keyword is followed by 0 then
0B3119             0360**  ; it will only match with the keyword followed immediately by
0B3119             0361**  ; a delimiter
0B3119             0362**  ;
0B3119 80 41 4E 44 0363**  KEYWDS:			DB    80H, "AND"
0B311D 94 41 42 53 0364**  			DB    94H, "ABS"
0B3121 95 41 43 53 0365**  			DB    95H, "ACS"
0B3125 96 41 44 56 0366**  			DB    96H, "ADVAL"
       41 4C       
0B312B 97 41 53 43 0367**  			DB    97H, "ASC"
0B312F 98 41 53 4E 0368**  			DB    98H, "ASN"
0B3133 99 41 54 4E 0369**  			DB    99H, "ATN"
0B3137 C6 41 55 54 0370**  			DB    C6H, "AUTO"
       4F          
0B313C 9A 42 47 45 0371**  			DB    9AH, "BGET", 0
       54 00       
0B3142 D5 42 50 55 0372**  			DB    D5H, "BPUT", 0
       54 00       
0B3148 FB 43 4F 4C 0373**  			DB    FBH, "COLOUR"
       4F 55 52    
0B314F FB 43 4F 4C 0374**  			DB    FBH, "COLOR"
       4F 52       
0B3155 D6 43 41 4C 0375**  			DB    D6H, "CALL"
       4C          
0B315A D7 43 48 41 0376**  			DB    D7H, "CHAIN"
       49 4E       
0B3160 BD 43 48 52 0377**  			DB    BDH, "CHR$"
       24          
0B3165 D8 43 4C 45 0378**  			DB    D8H, "CLEAR", 0
       41 52 00    
0B316C D9 43 4C 4F 0379**  			DB    D9H, "CLOSE", 0
       53 45 00    
0B3173 DA 43 4C 47 0380**  			DB    DAH, "CLG", 0
       00          
0B3178 DB 43 4C 53 0381**  			DB    DBH, "CLS", 0
       00          
0B317D 9B 43 4F 53 0382**  			DB    9BH, "COS"
0B3181 9C 43 4F 55 0383**  			DB    9CH, "COUNT", 0
       4E 54 00    
0B3188 DC 44 41 54 0384**  			DB    DCH, "DATA"
       41          
0B318D 9D 44 45 47 0385**  			DB    9DH, "DEG"
0B3191 DD 44 45 46 0386**  			DB    DDH, "DEF"
0B3195 C7 44 45 4C 0387**  			DB    C7H, "DELETE"
       45 54 45    
0B319C 81 44 49 56 0388**  			DB    81H, "DIV"
0B31A0 DE 44 49 4D 0389**  			DB    DEH, "DIM"
0B31A4 DF 44 52 41 0390**  			DB    DFH, "DRAW"
       57          
0B31A9 E1 45 4E 44 0391**  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
0B31B2 E0 45 4E 44 0392**  			DB    E0H, "END", 0
       00          
0B31B7 E2 45 4E 56 0393**  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
0B31C0 8B 45 4C 53 0394**  			DB    8BH, "ELSE"
       45          
0B31C5 A0 45 56 41 0395**  			DB    A0H, "EVAL"
       4C          
0B31CA 9E 45 52 4C 0396**  			DB    9EH, "ERL", 0
       00          
0B31CF 85 45 52 52 0397**  			DB    85H, "ERROR"
       4F 52       
0B31D5 C5 45 4F 46 0398**  			DB    C5H, "EOF", 0
       00          
0B31DA 82 45 4F 52 0399**  			DB    82H, "EOR"
0B31DE 9F 45 52 52 0400**  			DB    9FH, "ERR", 0
       00          
0B31E3 A1 45 58 50 0401**  			DB    A1H, "EXP"
0B31E7 A2 45 58 54 0402**  			DB    A2H, "EXT", 0
       00          
0B31EC E3 46 4F 52 0403**  			DB    E3H, "FOR"
0B31F0 A3 46 41 4C 0404**  			DB    A3H, "FALSE", 0
       53 45 00    
0B31F7 A4 46 4E    0405**  			DB    A4H, "FN"
0B31FA E5 47 4F 54 0406**  			DB    E5H, "GOTO"
       4F          
0B31FF BE 47 45 54 0407**  			DB    BEH, "GET$"
       24          
0B3204 A5 47 45 54 0408**  			DB    A5H, "GET"
0B3208 E4 47 4F 53 0409**  			DB    E4H, "GOSUB"
       55 42       
0B320E E6 47 43 4F 0410**  			DB    E6H, "GCOL"
       4C          
0B3213 93 48 49 4D 0411**  			DB    93H, "HIMEM", 0
       45 4D 00    
0B321A E8 49 4E 50 0412**  			DB    E8H, "INPUT"
       55 54       
0B3220 E7 49 46    0413**  			DB    E7H, "IF"
0B3223 BF 49 4E 4B 0414**  			DB    BFH, "INKEY$"
       45 59 24    
0B322A A6 49 4E 4B 0415**  			DB    A6H, "INKEY"
       45 59       
0B3230 A8 49 4E 54 0416**  			DB    A8H, "INT"
0B3234 A7 49 4E 53 0417**  			DB    A7H, "INSTR("
       54 52 28    
0B323B C9 4C 49 53 0418**  			DB    C9H, "LIST"
       54          
0B3240 86 4C 49 4E 0419**  			DB    86H, "LINE"
       45          
0B3245 C8 4C 4F 41 0420**  			DB    C8H, "LOAD"
       44          
0B324A 92 4C 4F 4D 0421**  			DB    92H, "LOMEM", 0
       45 4D 00    
0B3251 EA 4C 4F 43 0422**  			DB    EAH, "LOCAL"
       41 4C       
0B3257 C0 4C 45 46 0423**  			DB    C0H, "LEFT$("
       54 24 28    
0B325E A9 4C 45 4E 0424**  			DB    A9H, "LEN"
0B3262 E9 4C 45 54 0425**  			DB    E9H, "LET"
0B3266 AB 4C 4F 47 0426**  			DB    ABH, "LOG"
0B326A AA 4C 4E    0427**  			DB    AAH, "LN"
0B326D C1 4D 49 44 0428**  			DB    C1H, "MID$("
       24 28       
0B3273 EB 4D 4F 44 0429**  			DB    EBH, "MODE"
       45          
0B3278 83 4D 4F 44 0430**  			DB    83H, "MOD"
0B327C EC 4D 4F 56 0431**  			DB    ECH, "MOVE"
       45          
0B3281 ED 4E 45 58 0432**  			DB    EDH, "NEXT"
       54          
0B3286 CA 4E 45 57 0433**  			DB    CAH, "NEW", 0
       00          
0B328B AC 4E 4F 54 0434**  			DB    ACH, "NOT"
0B328F CB 4F 4C 44 0435**  			DB    CBH, "OLD", 0
       00          
0B3294 EE 4F 4E    0436**  			DB    EEH, "ON"
0B3297 87 4F 46 46 0437**  			DB    87H, "OFF"
0B329B 84 4F 52    0438**  			DB    84H, "OR"
0B329E 8E 4F 50 45 0439**  			DB    8EH, "OPENIN"
       4E 49 4E    
0B32A5 AE 4F 50 45 0440**  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
0B32AD AD 4F 50 45 0441**  			DB    ADH, "OPENUP"
       4E 55 50    
0B32B4 FF 4F 53 43 0442**  			DB    FFH, "OSCLI"
       4C 49       
0B32BA F1 50 52 49 0443**  			DB    F1H, "PRINT"
       4E 54       
0B32C0 90 50 41 47 0444**  			DB    90H, "PAGE", 0
       45 00       
0B32C6 8F 50 54 52 0445**  			DB    8FH, "PTR", 0
       00          
0B32CB AF 50 49 00 0446**  			DB    AFH, "PI", 0
0B32CF F0 50 4C 4F 0447**  			DB    F0H, "PLOT"
       54          
0B32D4 B0 50 4F 49 0448**  			DB    B0H, "POINT("
       4E 54 28    
0B32DB F2 50 52 4F 0449**  			DB    F2H, "PROC"
       43          
0B32E0 B1 50 4F 53 0450**  			DB    B1H, "POS", 0
       00          
0B32E5 CE 50 55 54 0451**  			DB    CEH, "PUT"
0B32E9 F8 52 45 54 0452**  			DB    F8H, "RETURN", 0
       55 52 4E 00 
0B32F1 F5 52 45 50 0453**  			DB    F5H, "REPEAT"
       45 41 54    
0B32F8 F6 52 45 50 0454**  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0B3300 F3 52 45 41 0455**  			DB    F3H, "READ"
       44          
0B3305 F4 52 45 4D 0456**  			DB    F4H, "REM"
0B3309 F9 52 55 4E 0457**  			DB    F9H, "RUN", 0
       00          
0B330E B2 52 41 44 0458**  			DB    B2H, "RAD"
0B3312 F7 52 45 53 0459**  			DB    F7H, "RESTORE"
       54 4F 52 45 
0B331A C2 52 49 47 0460**  			DB    C2H, "RIGHT$("
       48 54 24 28 
0B3322 B3 52 4E 44 0461**  			DB    B3H, "RND", 0
       00          
0B3327 CC 52 45 4E 0462**  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0B3330 88 53 54 45 0463**  			DB    88H, "STEP"
       50          
0B3335 CD 53 41 56 0464**  			DB    CDH, "SAVE"
       45          
0B333A B4 53 47 4E 0465**  			DB    B4H, "SGN"
0B333E B5 53 49 4E 0466**  			DB    B5H, "SIN"
0B3342 B6 53 51 52 0467**  			DB    B6H, "SQR"
0B3346 89 53 50 43 0468**  			DB    89H, "SPC"
0B334A C3 53 54 52 0469**  			DB    C3H, "STR$"
       24          
0B334F C4 53 54 52 0470**  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0B3358 D4 53 4F 55 0471**  			DB    D4H, "SOUND"
       4E 44       
0B335E FA 53 54 4F 0472**  			DB    FAH, "STOP", 0
       50 00       
0B3364 B7 54 41 4E 0473**  			DB    B7H, "TAN"
0B3368 8C 54 48 45 0474**  			DB    8CH, "THEN"
       4E          
0B336D B8 54 4F    0475**  			DB    B8H, "TO"
0B3370 8A 54 41 42 0476**  			DB    8AH, "TAB("
       28          
0B3375 FC 54 52 41 0477**  			DB    FCH, "TRACE"
       43 45       
0B337B 91 54 49 4D 0478**  			DB    91H, "TIME", 0
       45 00       
0B3381 B9 54 52 55 0479**  			DB    B9H, "TRUE", 0
       45 00       
0B3387 FD 55 4E 54 0480**  			DB    FDH, "UNTIL"
       49 4C       
0B338D BA 55 53 52 0481**  			DB    BAH, "USR"
0B3391 EF 56 44 55 0482**  			DB    EFH, "VDU"
0B3395 BB 56 41 4C 0483**  			DB    BBH, "VAL"
0B3399 BC 56 50 4F 0484**  			DB    BCH, "VPOS", 0
       53 00       
0B339F FE 57 49 44 0485**  			DB    FEH, "WIDTH"
       54 48       
0B33A5 D3 48 49 4D 0486**  			DB    D3H, "HIMEM"
       45 4D       
0B33AB D2 4C 4F 4D 0487**  			DB    D2H, "LOMEM"
       45 4D       
0B33B1 D0 50 41 47 0488**  			DB    D0H, "PAGE"
       45          
0B33B6 CF 50 54 52 0489**  			DB    CFH, "PTR"
0B33BA D1 54 49 4D 0490**  			DB    D1H, "TIME"
       45          
0B33BF             0491**  ;
0B33BF             0492**  ; These are indexed from the ERRWDS table
0B33BF             0493**  ;
0B33BF 01 4D 69 73 0494**  			DB    01H, "Missing "
       73 69 6E 67 
       20          
0B33C8 02 4E 6F 20 0495**  			DB    02H, "No such "
       73 75 63 68 
       20          
0B33D1 03 42 61 64 0496**  			DB    03H, "Bad "
       20          
0B33D6 04 20 72 61 0497**  			DB    04H, " range"
       6E 67 65    
0B33DD 05 76 61 72 0498**  			DB    05H, "variable"
       69 61 62 6C 
       65          
0B33E6 06 4F 75 74 0499**  			DB    06H, "Out of"
       20 6F 66    
0B33ED 07 4E 6F 20 0500**  			DB    07H, "No "
0B33F1 08 20 73 70 0501**  			DB    08H, " space"
       61 63 65    
0B33F8             0502**  
0B33F8             0503**  KEYWDL:			EQU     $-KEYWDS
0B33F8 FF FF       0504**  			DW    -1
0B33FA             0505**  ;
0B33FA             0506**  ; Error messages
0B33FA             0507**  ;
0B33FA 07 72 6F 6F 0508**  ERRWDS:			DB    7, "room", 0		;  0: No room
       6D 00       
0B3400 06 04 00    0509**  			DB    6, 4, 0			;  1: Out of range
0B3403 00          0510**  			DB    0				;  2: *
0B3404 00          0511**  			DB    0				;  3: *
0B3405 4D 69 73 74 0512**  			DB    "Mistake", 0		;  4: Mistake
       61 6B 65 00 
0B340D 01 2C 00    0513**  			DB    1, ",", 0			;  5: Missing ,
0B3410 54 79 70 65 0514**  			DB    "Type mismatch", 0	;  6: Type mismatch
       20 6D 69 73 
       6D 61 74 63 
       68 00       
0B341E 07 A4 00    0515**  			DB    7, FN, 0			;  7: No FN
0B3421 00          0516**  			DB    0				;  8: *
0B3422 01 22 00    0517**  			DB    1, 34, 0			;  9: Missing "
0B3425 03 DE 00    0518**  			DB    3, DIM, 0			; 10: Bad DIM
0B3428 DE 08 00    0519**  			DB    DIM, 8, 0			; 11: DIM space
0B342B 4E 6F 74 20 0520**  			DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
       EA 00       
0B3431 07 F2 00    0521**  			DB    7, PROC, 0		; 13: No PROC
0B3434 41 72 72 61 0522**  			DB    "Array", 0		; 14: Array
       79 00       
0B343A 53 75 62 73 0523**  			DB    "Subscript", 0		; 15: Subscript
       63 72 69 70 
       74 00       
0B3444 53 79 6E 74 0524**  			DB    "Syntax error", 0		; 16: Syntax error
       61 78 20 65 
       72 72 6F 72 
       00          
0B3451 45 73 63 61 0525**  			DB    "Escape", 0		; 17: Escape
       70 65 00    
0B3458 44 69 76 69 0526**  			DB    "Division by zero", 0	; 18: Division by zero
       73 69 6F 6E 
       20 62 79 20 
       7A 65 72 6F 
       00          
0B3469 53 74 72 69 0527**  			DB    "String too long", 0	; 19: String too long
       6E 67 20 74 
       6F 6F 20 6C 
       6F 6E 67 00 
0B3479 54 6F 6F 20 0528**  			DB    "Too big", 0		; 20: Too big
       62 69 67 00 
0B3481 2D 76 65 20 0529**  			DB    "-ve root", 0		; 21: -ve root
       72 6F 6F 74 
       00          
0B348A 4C 6F 67 04 0530**  			DB    "Log", 4, 0		; 22: Log range
       00          
0B348F 41 63 63 75 0531**  			DB    "Accuracy lost", 0	; 23: Accuracy lost
       72 61 63 79 
       20 6C 6F 73 
       74 00       
0B349D 45 78 70 04 0532**  			DB    "Exp", 4, 0		; 24: Exp range
       00          
0B34A2 00          0533**  			DB    0				; 25: *
0B34A3 02 05 00    0534**  			DB    2, 5, 0			; 26: No such variable
0B34A6 01 29 00    0535**  			DB    1, ")", 0			; 27: Missing )
0B34A9 03 48 45 58 0536**  			DB    3, "HEX", 0		; 28: Bad HEX
       00          
0B34AE 02 A4 2F F2 0537**  			DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
       00          
0B34B3 03 63 61 6C 0538**  			DB    3, "call", 0		; 30: Bad call
       6C 00       
0B34B9 41 72 67 75 0539**  			DB    "Arguments", 0		; 31: Arguments
       6D 65 6E 74 
       73 00       
0B34C3 07 E3 00    0540**  			DB    7, FOR, 0			; 32: No FOR
0B34C6 43 61 6E 27 0541**  			DB    "Can't match ", FOR, 0	; 33: Can't match FOR
       74 20 6D 61 
       74 63 68 20 
       E3 00       
0B34D4 E3 20 05 00 0542**  			DB    FOR, " ", 5, 0		; 34: FOR variable
0B34D8 00          0543**  			DB    0				; 35: *
0B34D9 07 B8 00    0544**  			DB    7, TO_MN, 0			; 36: No TO
0B34DC 00          0545**  			DB    0				; 37: *
0B34DD 07 E4 00    0546**  			DB    7, GOSUB, 0		; 38: No GOSUB
0B34E0 EE 20 73 79 0547**  			DB    ON_, " syntax", 0		; 39: ON syntax
       6E 74 61 78 
       00          
0B34E9 EE 04 00    0548**  			DB    ON_, 4, 0			; 40: ON range
0B34EC 02 6C 69 6E 0549**  			DB    2, "line", 0		; 41: No such line
       65 00       
0B34F2 06 20 DC 00 0550**  			DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
0B34F6 07 F5 00    0551**  			DB    7, REPEAT, 0		; 43: No REPEAT
0B34F9 00          0552**  			DB    0				; 44: *
0B34FA 01 23 00    0553**  			DB    1, "#", 0			; 45: Missing #
0B34FD             0554**  ;
0B34FD             0555**  ; COMMANDS:
0B34FD             0556**  ;
0B34FD             0557**  ; DELETE line,line
0B34FD             0558**  ;
0B34FD CD FC 37 0B 0559**  DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0B3501 CD 04 3C 0B 0560**  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B3505 7E          0561**  DELET1:			LD      A,(HL)			; Check whether it's the last line
0B3506 B7          0562**  			OR      A
0B3507 CA 8E 35 0B 0563**  			JP      Z,WARMNC		; Yes, so do nothing
0B350B 23          0564**  			INC     HL			; Skip the line length byte
0B350C 11 00 00 00 0565**  			LD	DE, 0			; Clear DE
0B3510 5E          0566**  			LD      E,(HL)			; Fetch the line number in DE
0B3511 23          0567**  			INC     HL
0B3512 56          0568**  			LD      D,(HL)
0B3513 7A          0569**  			LD      A,D			; If the line number is zero then
0B3514 B3          0570**  			OR      E
0B3515 28 1D       0571**  			JR      Z,CLOOP1        	; Do nothing
0B3517 2B          0572**  			DEC     HL			; Decrement BASIC program pointer back to length
0B3518 2B          0573**  			DEC     HL
0B3519 EB          0574**  			EX      DE,HL			; Check if we've gone past the terminating line
0B351A 37          0575**  			SCF
0B351B ED 42       0576**  			SBC     HL,BC
0B351D EB          0577**  			EX      DE,HL
0B351E 30 6E       0578**  			JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0B3520 C5          0579**  			PUSH    BC
0B3521 CD B3 37 0B 0580**  			CALL    DEL			; Delete the line pointed to by HL
0B3525 C1          0581**  			POP     BC
0B3526 18 DD       0582**  			JR      DELET1			; And loop round to the next line
0B3528             0583**  ;
0B3528             0584**  ; LISTO expr
0B3528             0585**  ;
0B3528 FD 23       0586**  LISTO:			INC     IY              	; Skip "O" byte
0B352A CD BB 02 0B 0587**  			CALL    EXPRI			; Get expr
0B352E D9          0588**  			EXX
0B352F 7D          0589**  			LD      A,L
0B3530 32 40 4C 0B 0590**  			LD      (LISTON),A		; Store in LISTON sysvar
0B3534 C3 31 30 0B 0591**  CLOOP1:			JP      CLOOP
0B3538             0592**  ;
0B3538             0593**  ; LIST
0B3538             0594**  ; LIST line
0B3538             0595**  ; LIST line,line [IF string]
0B3538             0596**  ; LIST ,line
0B3538             0597**  ; LIST line,
0B3538             0598**  ;
0B3538 FE 4F       0599**  LIST_:			CP      'O'			; Check for O (LISTO)
0B353A 28 EC       0600**  			JR      Z,LISTO			; and jump to LISTO if zero
0B353C CD 04 3C 0B 0601**  			CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B3540 CD 21 0A 0B 0602**  			CALL    NXT			; Skip space
0B3544 FE E7       0603**  			CP      TIF             	; Check for IF clause (token IF)
0B3546 3E 00       0604**  			LD      A,0             	; Initialise the IF clause string length
0B3548 20 17       0605**  			JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0B354A             0606**  ;
0B354A FD 23       0607**  			INC     IY              	; Skip the IF token
0B354C CD 21 0A 0B 0608**  			CALL    NXT             	; And skip any spaces
0B3550 EB          0609**  			EX      DE,HL			; DE: Address in memory
0B3551 FD E5       0610**  			PUSH    IY			; LD IY, HL
0B3553 E1          0611**  			POP     HL              	; HL is now the address of the tokenised line
0B3554 3E 0D       0612**  			LD      A,CR
0B3556 C5          0613**  			PUSH    BC			; Stack the second line number arg
0B3557 01 00 01 00 0614**  			LD      BC,256
0B355B ED B1       0615**  			CPIR                    	; Locate CR byte
0B355D 79          0616**  			LD      A,C
0B355E 2F          0617**  			CPL                    	 	; A: Substring length (of IF clause)
0B355F C1          0618**  			POP     BC			; Restore the second line number arg
0B3560 EB          0619**  			EX      DE,HL			; HL: Address in memory
0B3561             0620**  ;
0B3561 5F          0621**  LISTB:			LD      E,A             	; E: IF clause string length
0B3562 78          0622**  			LD      A,B			; Check whether a second line number was passed (BC!=0)
0B3563 B1          0623**  			OR      C
0B3564 20 01       0624**  			JR      NZ,LISTA		; If there isn't a second line number
0B3566 0B          0625**  			DEC     BC			; then we set it to the maximum of 65535
0B3567             0626**  ;
0B3567 D9          0627**  LISTA:			EXX
0B3568 DD 21 40 4C 0628**  			LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
       0B          
0B356D 01 00 00 00 0629**  			LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0B3571 D9          0630**  			EXX
0B3572 3E 14       0631**  			LD      A,20			; Number of lines to list
0B3574             0632**  ;
0B3574 C5          0633**  LISTC:			PUSH    BC              	; Save second line number
0B3575 D5          0634**  			PUSH    DE              	; Save IF clause length
0B3576 E5          0635**  			PUSH    HL              	; Save BASIC program counter
0B3577 08          0636**  			EX      AF,AF'
0B3578             0637**  ;
0B3578             0638**  ; BBC BASIC for Z80 lines are stored as follows:
0B3578             0639**  ;
0B3578             0640**  ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
0B3578             0641**  ; - [&00] [&FF] [&FF]: End of program marker
0B3578             0642**  ;
0B3578             0643**  ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
0B3578             0644**  ;
0B3578 7E          0645**  			LD      A,(HL)			; Check for end of program marker
0B3579 B7          0646**  			OR      A			; If found
0B357A 28 12       0647**  			JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0B357C             0648**  ;
0B357C             0649**  ; Check if past terminating line number
0B357C             0650**  ;
0B357C 7B          0651**  			LD      A,E             	; A: IF clause length
0B357D 23          0652**  			INC     HL			; Skip the length byte
0B357E 11 00 00 00 0653**  			LD	DE,0			; Clear DE
0B3582 5E          0654**  			LD      E,(HL)			; Fetch the line number in DE
0B3583 23          0655**  			INC     HL
0B3584 56          0656**  			LD      D,(HL)
0B3585 2B          0657**  			DEC     HL			; Step HL back to the length byte
0B3586 2B          0658**  			DEC     HL
0B3587 D5          0659**  			PUSH    DE             	 	; Push the line number on the stack
0B3588 EB          0660**  			EX      DE,HL			; HL: line number
0B3589 37          0661**  			SCF				; Do a 16-bit compare of HL and DE
0B358A ED 42       0662**  			SBC     HL,BC
0B358C EB          0663**  			EX      DE,HL
0B358D D1          0664**  			POP     DE              	; Restore the line number
0B358E D2 30 30 0B 0665**  WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0B3592 4E          0666**  			LD      C,(HL)          	; C: Line length + 4
0B3593 47          0667**  			LD      B,A             	; B: IF clause length
0B3594             0668**  ;
0B3594             0669**  ; Check if "UNLISTABLE":
0B3594             0670**  ;
0B3594 7A          0671**  			LD      A,D			; TODO: What is "UNLISTABLE?"
0B3595 B3          0672**  			OR      E
0B3596 CA 31 30 0B 0673**  			JP      Z,CLOOP
0B359A             0674**  ;
0B359A             0675**  ; Check for IF clause:
0B359A             0676**  ;
0B359A 23          0677**  			INC     HL			; Skip the length
0B359B 23          0678**  			INC     HL			; Skip the line number
0B359C 23          0679**  			INC     HL              	; HL: Address of the tokenised BASIC line
0B359D 0D          0680**  			DEC     C			;  C: Line length
0B359E 0D          0681**  			DEC     C
0B359F 0D          0682**  			DEC     C
0B35A0 0D          0683**  			DEC     C
0B35A1 D5          0684**  			PUSH    DE              	; Save the line number
0B35A2 E5          0685**  			PUSH    HL              	; Save the BASIC program address
0B35A3 AF          0686**  			XOR     A               	;
0B35A4 B8          0687**  			CP      B              	 	; Check for an IF clause (B!=0)
0B35A5 FD E5       0688**  			PUSH    IY			; LD IY, DE
0B35A7 D1          0689**  			POP     DE              	; DE: Address of the IF clause string in the input buffer
0B35A8 C4 36 07 0B 0690**  			CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0B35AC E1          0691**  			POP     HL              	; Restore BASIC program address
0B35AD D1          0692**  			POP     DE              	; Restore line number
0B35AE FD E5       0693**  			PUSH    IY
0B35B0 CC 43 38 0B 0694**  			CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
0B35B4 FD E1       0695**  			POP     IY
0B35B6             0696**  ;
0B35B6 08          0697**  			EX      AF,AF'
0B35B7 3D          0698**  			DEC     A			; Decrement line list counter
0B35B8 CD 22 3F 0B 0699**  			CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
0B35BC E1          0700**  			POP     HL             	 	; Restore BASIC program address to beginning of line
0B35BD 11 00 00 00 0701**  			LD	DE,0
0B35C1 5E          0702**  			LD      E,(HL)			; Fetch the length of line in DE
0B35C2 19          0703**  			ADD     HL,DE           	; Go to the next line
0B35C3 D1          0704**  			POP     DE              	; Restore IF clause length
0B35C4 C1          0705**  			POP     BC              	; Restore second line number
0B35C5 18 AD       0706**  			JR      LISTC			; Loop back to do next line
0B35C7             0707**  ;
0B35C7             0708**  ; RENUMBER
0B35C7             0709**  ; RENUMBER start
0B35C7             0710**  ; RENUMBER start,increment
0B35C7             0711**  ; RENUMBER ,increment
0B35C7             0712**  ;
0B35C7 CD 27 38 0B 0713**  RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
0B35CB CD DC 3B 0B 0714**  			CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
0B35CF D9          0715**  			EXX
0B35D0 2A 14 4C 0B 0716**  			LD      HL,(PAGE_)		; HL: Top of program
0B35D4 ED 5B 1A 4C 0717**  			LD      DE,(LOMEM)		; DE: Start address of the heap
       0B          
0B35D9             0718**  ;
0B35D9             0719**  ; Build the table
0B35D9             0720**  ;
0B35D9 7E          0721**  RENUM1:			LD      A,(HL)          	; Fetch the line length byte
0B35DA B7          0722**  			OR      A			; Is it zero, i.e. the end of program marker?
0B35DB 28 36       0723**  			JR      Z,RENUM2		; Yes, so skip to the next part
0B35DD 23          0724**  			INC     HL
0B35DE 4E          0725**  			LD      C,(HL)          	; BC: The OLD line number
0B35DF 23          0726**  			INC     HL
0B35E0 46          0727**  			LD      B,(HL)
0B35E1 78          0728**  			LD      A,B			; Check whether the line number is zero - we only need to check the LSW
0B35E2 B1          0729**  			OR      C
0B35E3 CA 31 30 0B 0730**  			JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
0B35E7 EB          0731**  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B35E8 71          0732**  			LD      (HL),C			; Store the OLD line number in the heap
0B35E9 23          0733**  			INC     HL
0B35EA 70          0734**  			LD      (HL),B
0B35EB 23          0735**  			INC     HL
0B35EC D9          0736**  			EXX				; HL: line number, BC: increment (16-bit values)
0B35ED E5          0737**  			PUSH    HL			; HL: Stack the NEW line number value
0B35EE 52 09       0738**  			ADD.S   HL,BC           	; Add the increment
0B35F0 DA D6 3B 0B 0739**  			JP      C,TOOBIG        	; If > 65535, then error: "Too big"
0B35F4 D9          0740**  			EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
0B35F5 C1          0741**  			POP     BC			; BC: Pop the NEW line number value off the stack
0B35F6 71          0742**  			LD      (HL),C			; Store the NEW line number in the heap
0B35F7 23          0743**  			INC     HL
0B35F8 70          0744**  			LD      (HL),B
0B35F9 23          0745**  			INC     HL
0B35FA EB          0746**  			EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B35FB 2B          0747**  			DEC     HL			; Back up to the line length byte
0B35FC 2B          0748**  			DEC     HL
0B35FD 01 00 00 00 0749**  			LD	BC, 0
0B3601 4E          0750**  			LD      C,(HL)			; BC: Line length
0B3602 09          0751**  			ADD	HL,BC           	; Advance HL to next line
0B3603 EB          0752**  			EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B3604 E5          0753**  			PUSH    HL
0B3605 24          0754**  			INC     H			; Increment to next page
0B3606 ED 72       0755**  			SBC     HL,SP			; Subtract from SP
0B3608 E1          0756**  			POP     HL
0B3609 EB          0757**  			EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B360A 38 CD       0758**  			JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0B360C CD 28 37 0B 0759**  			CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0B3610 CC          0760**  			DB    	REN
0B3611 08          0761**  			DB    	8
0B3612 00          0762**  			DB    	0
0B3613             0763**  ;
0B3613             0764**  ; At this point a list of BASIC line numbers have been written to the heap
0B3613             0765**  ; as word pairs:
0B3613             0766**  ; - DW: The OLD line number
0B3613             0767**  ; - DW: The NEW line number
0B3613             0768**  ;
0B3613 EB          0769**  RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0B3614 36 FF       0770**  			LD      (HL),-1			; Mark the end with FFFFh
0B3616 23          0771**  			INC     HL
0B3617 36 FF       0772**  			LD      (HL),-1
0B3619 ED 5B 1A 4C 0773**  			LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
       0B          
0B361E D9          0774**  			EXX
0B361F 2A 14 4C 0B 0775**  			LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0B3623 4E          0776**  RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0B3624 79          0777**  			LD      A,C			; If it is zero, then no program, so...
0B3625 B7          0778**  			OR      A
0B3626 CA 30 30 0B 0779**  			JP      Z,WARM			; Jump to warm start
0B362A D9          0780**  			EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0B362B EB          0781**  			EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0B362C 23          0782**  			INC     HL			; Skip to the NEW line number
0B362D 23          0783**  			INC     HL
0B362E 5E          0784**  			LD      E,(HL)			; DE: The NEW line number
0B362F 23          0785**  			INC     HL
0B3630 56          0786**  			LD      D,(HL)
0B3631 23          0787**  			INC     HL
0B3632 D5          0788**  			PUSH    DE			; Stack the NEW line number
0B3633 EB          0789**  			EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0B3634 22 23 4C 0B 0790**  			LD      (LINENO),HL		; Store the line number in LINENO
0B3638 D9          0791**  			EXX				; HL: Pointer to the BASIC program area
0B3639 D1          0792**  			POP     DE			; DE: The NEW line number
0B363A 23          0793**  			INC     HL
0B363B 73          0794**  			LD      (HL),E          	; Write out the NEW line number to the BASIC program
0B363C 23          0795**  			INC     HL
0B363D 72          0796**  			LD      (HL),D
0B363E 23          0797**  			INC     HL
0B363F 0D          0798**  			DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0B3640 0D          0799**  			DEC     C
0B3641 0D          0800**  			DEC     C
0B3642 79          0801**  			LD	A,C
0B3643 01 00 00 00 0802**  			LD	BC,0
0B3647 4F          0803**  			LD	C,A			; BC: Line length
0B3648             0804**  ;
0B3648 3E 8D       0805**  RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0B364A ED B1       0806**  			CPIR                    	; Search for the token
0B364C 20 D5       0807**  			JR      NZ,RENUM3		; If not found, then loop to process the next line
0B364E             0808**  ;
0B364E             0809**  ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
0B364E             0810**  ;
0B364E C5          0811**  			PUSH    BC			; Stack everything
0B364F E5          0812**  			PUSH    HL
0B3650 E5          0813**  			PUSH    HL			; HL: Pointer to encoded line number
0B3651 FD E1       0814**  			POP     IY			; IY: Pointer to encoded line number
0B3653 D9          0815**  			EXX
0B3654 CD 97 08 0B 0816**  			CALL    DECODE			; Decode the encoded line number (in HL')
0B3658 D9          0817**  			EXX				; HL: Decoded line number
0B3659 44          0818**  			LD      B,H			; BC: Decoded line number
0B365A 4D          0819**  			LD      C,L
0B365B 2A 1A 4C 0B 0820**  			LD      HL,(LOMEM)		; HL: Pointer to heap
0B365F             0821**  ;
0B365F             0822**  ; This section of code cross-references the decoded (OLD) line number with the list
0B365F             0823**  ; created previously in the global heap
0B365F             0824**  ;
0B365F 5E          0825**  RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0B3660 23          0826**  			INC     HL
0B3661 56          0827**  			LD      D,(HL)
0B3662 23          0828**  			INC     HL
0B3663 EB          0829**  			EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0B3664 B7          0830**  			OR      A               	; Clear the carry and...
0B3665 52 ED 42    0831**  			SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0B3668 EB          0832**  			EX      DE,HL			; HL: Pointer in the global heap
0B3669 5E          0833**  			LD      E,(HL)          	; DE: The NEW line number
0B366A 23          0834**  			INC     HL
0B366B 56          0835**  			LD      D,(HL)
0B366C 23          0836**  			INC     HL
0B366D 38 F0       0837**  			JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0B366F EB          0838**  			EX      DE,HL			; DE: Pointer in the global heap
0B3670 28 1D       0839**  			JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0B3672             0840**  ;
0B3672 CD 41 3D 0B 0841**  			CALL    TELL			; Display this error if the line number is not found
0B3676 46 61 69 6C 0842**  			DB    	"Failed at "
       65 64 20 61 
       74 20       
0B3680 00          0843**  			DB    	0
0B3681 2A 23 4C 0B 0844**  			LD      HL,(LINENO)
0B3685 CD A8 39 0B 0845**  			CALL    PBCDL
0B3689 CD F8 38 0B 0846**  			CALL    CRLF
0B368D 18 07       0847**  			JR      RENUM6			; And carry on renumbering
0B368F             0848**  ;
0B368F             0849**  ; This snippet re-encodes the line number in the BASIC program
0B368F             0850**  ;
0B368F D1          0851**  RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0B3690 D5          0852**  			PUSH    DE
0B3691 1B          0853**  			DEC     DE			; Back up a byte to the LINO token
0B3692 CD 0D 3D 0B 0854**  			CALL    ENCODE          	; Re-write the new line number out
0B3696 E1          0855**  RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0B3697 C1          0856**  			POP     BC			; BC: The remaining line length
0B3698 18 AE       0857**  			JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0B369A             0858**  ;
0B369A             0859**  ; AUTO
0B369A             0860**  ; AUTO start,increment
0B369A             0861**  ; AUTO start
0B369A             0862**  ; AUTO ,increment
0B369A             0863**  ;
0B369A CD DC 3B 0B 0864**  AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0B369E 22 29 4C 0B 0865**  			LD      (AUTONO),HL		; Store the start in AUTONO
0B36A2 79          0866**  			LD      A,C			; Increment is 8 bit (0-255)
0B36A3 32 41 4C 0B 0867**  			LD      (INCREM),A		; Store that in INCREM
0B36A7 18 2E       0868**  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B36A9             0869**  ;
0B36A9             0870**  ; BAD
0B36A9             0871**  ; NEW
0B36A9             0872**  ;
0B36A9 CD 41 3D 0B 0873**  BAD:			CALL    TELL            	; Output "Bad program" error
0B36AD 03          0874**  			DB    3				; Token for "BAD"
0B36AE 70 72 6F 67 0875**  			DB    "program"
       72 61 6D    
0B36B5 0D          0876**  			DB    CR
0B36B6 0A          0877**  			DB    LF
0B36B7 00          0878**  			DB    0				; Falls through to NEW
0B36B8             0879**  ;
0B36B8 CD 1D 38 0B 0880**  NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
0B36BC 18 19       0881**  			JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B36BE             0882**  ;
0B36BE             0883**  ; OLD
0B36BE             0884**  ;
0B36BE 2A 14 4C 0B 0885**  OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
0B36C2 E5          0886**  			PUSH    HL			; Stack it
0B36C3 23          0887**  			INC     HL			; Skip the potential length byte of first line of code
0B36C4 23          0888**  			INC     HL			; And the line number word
0B36C5 23          0889**  			INC     HL
0B36C6 01 FC 00 00 0890**  			LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
0B36CA 3E 0D       0891**  			LD      A,CR
0B36CC ED B1       0892**  			CPIR
0B36CE 20 D9       0893**  			JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
0B36D0 7D          0894**  			LD      A,L			; It could still be garbage though! Store the position in A; this requires
0B36D1 E1          0895**  			POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
0B36D2 77          0896**  			LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
0B36D3 CD F0 37 0B 0897**  			CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B36D7 C3 31 30 0B 0898**  CLOOP0:			JP      CLOOP			; Jump back to the command loop
0B36DB             0899**  ;
0B36DB             0900**  ; LOAD filename
0B36DB             0901**  ;
0B36DB CD C6 02 0B 0902**  LOAD:			CALL    EXPRS           	; Get the filename
0B36DF 3E 0D       0903**  			LD      A,CR			; DE points to the last byte of filename in ACCS
0B36E1 12          0904**  			LD      (DE),A			; Terminate filename with a CR
0B36E2 CD D0 37 0B 0905**  			CALL    LOAD0			; Load the file in, then CLEAN
0B36E6 CD 27 38 0B 0906**  			CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B36EA 18 21       0907**  			JR      WARM0			; Jump back to the command loop
0B36EC             0908**  ;
0B36EC             0909**  ; SAVE filename
0B36EC             0910**  ;
0B36EC CD FC 37 0B 0911**  SAVE:			CALL    SETTOP          	; Set TOP sysvar
0B36F0 CD C6 02 0B 0912**  			CALL    EXPRS           	; Get the filename
0B36F4 3E 0D       0913**  			LD      A,CR			; Terminate the filename with a CR
0B36F6 12          0914**  			LD      (DE),A
0B36F7 ED 5B 14 4C 0915**  			LD      DE,(PAGE_)		; DE: Start of program memory
       0B          
0B36FC 2A 17 4C 0B 0916**  			LD      HL,(TOP)		; HL: Top of program memory
0B3700 B7          0917**  			OR      A			; Calculate program size (TOP-PAGE)
0B3701 ED 52       0918**  			SBC     HL,DE
0B3703 44          0919**  			LD      B,H             	; BC: Length of program in bytes
0B3704 4D          0920**  			LD      C,L
0B3705 21 00 49 0B 0921**  			LD      HL,ACCS			; HL: Address of the filename
0B3709 CD DE 41 0B 0922**  			CALL    OSSAVE			; Call the SAVE routine in patch.asm
0B370D C3 30 30 0B 0923**  WARM0:			JP      WARM			; Jump back to the command loop
0B3711             0924**  
0B3711             0925**  ;
0B3711             0926**  ; ERROR
0B3711             0927**  ; Called whenever BASIC needs to halt with an error
0B3711             0928**  ; Error messages are indexed from 0
0B3711             0929**  ; Inputs:
0B3711             0930**  ;  A: Error number
0B3711             0931**  ;
0B3711 ED 7B 20 4C 0932**  ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
       0B          
0B3716 21 FA 33 0B 0933**  			LD      HL,ERRWDS		; Index into the error string table
0B371A B7          0934**  			OR      A			; We don't need to search for the first error
0B371B 28 0A       0935**  			JR      Z,ERROR1		; So skip the search routine
0B371D             0936**  ;
0B371D             0937**  ; Search the error table for error #A
0B371D             0938**  ; HL will end up being the pointer into the correct error
0B371D             0939**  ; There is no bounds checking on this, so invalid error numbers will probably output garbage
0B371D             0940**  ;
0B371D 47          0941**  			LD      B,A             	; Store error number in B
0B371E 08          0942**  			EX      AF,AF'			; Store error number in AF'
0B371F AF          0943**  			XOR     A
0B3720 BE          0944**  ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0B3721 23          0945**  			INC     HL			; Increment the string pointer
0B3722 20 FC       0946**  			JR      NZ,ERROR0		; Loop until with hit a 0
0B3724 10 FA       0947**  			DJNZ    ERROR0			; Decrements the error number and loop until 0
0B3726 08          0948**  			EX      AF,AF'			; Restore the error number from AF'
0B3727             0949**  ;
0B3727             0950**  ; At this point HL points to the tokenised error string
0B3727             0951**  ;
0B3727 E5          0952**  ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
0B3728             0953**  
0B3728             0954**  ;
0B3728             0955**  ; EXTERR
0B3728             0956**  ; Inputs:
0B3728             0957**  ;  A: Error number
0B3728             0958**  ;
0B3728             0959**  ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
0B3728             0960**  ; The error text immediately follows the CALL to EXTERR, for example:
0B3728             0961**  ; > CALL  EXTERR
0B3728             0962**  ; > DB    "Silly", 0
0B3728             0963**  ; So we can get the address of the string by popping the return address off the stack
0B3728             0964**  ;
0B3728 E1          0965**  EXTERR:			POP     HL			; Pop the error string pointer
0B3729 22 2F 4C 0B 0966**  			LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0B372D ED 7B 20 4C 0967**  			LD      SP,(HIMEM)		; Set SP to HIMEM
       0B          
0B3732 32 3F 4C 0B 0968**  			LD      (ERR),A			; Store error number in ERR sysvar
0B3736 CD 5F 39 0B 0969**  			CALL    SETLIN			; Get line number
0B373A 22 33 4C 0B 0970**  			LD      (ERL),HL		; Store in ERL sysvar
0B373E B7          0971**  			OR      A			; Is error number 0?
0B373F 28 0D       0972**  			JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0B3741             0973**  ;
0B3741 2A 2C 4C 0B 0974**  			LD      HL,(ERRTRP)		; Check whether the error is trapped
0B3745 7C          0975**  			LD      A,H
0B3746 B5          0976**  			OR      L
0B3747 E5          0977**  			PUSH    HL			; HL: Error line
0B3748 FD E1       0978**  			POP     IY			; IY: HL
0B374A C2 47 0B 0B 0979**  			JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0B374E             0980**  ;
0B374E 21 00 00 00 0981**  ERROR2:			LD      HL,0
0B3752 22 29 4C 0B 0982**  			LD      (AUTONO),HL		; Cancel AUTO
0B3756 22 26 4C 0B 0983**  			LD      (TRACEN),HL     	; Cancel TRACE
0B375A CD 67 43 0B 0984**  			CALL    RESET           	; Reset OPSYS
0B375E CD F8 38 0B 0985**  			CALL    CRLF			; Output newline
0B3762 CD 33 3D 0B 0986**  			CALL    REPORT          	; Output the error message
0B3766 CD 93 39 0B 0987**  			CALL    SAYLN			; Output " at line nnnn" message.
0B376A 1E 00       0988**  			LD      E,0			; Close all files
0B376C DC DC 42 0B 0989**  			CALL    C,OSSHUT
0B3770 CD F8 38 0B 0990**  			CALL    CRLF			; Output newline
0B3774 C3 31 30 0B 0991**  			JP      CLOOP			; Back to CLOOP
0B3778             0992**  ;
0B3778             0993**  ; SUBROUTINES:
0B3778             0994**  ;
0B3778             0995**  ; LEX - SEARCH FOR KEYWORDS
0B3778             0996**  ;   Inputs: HL = start of keyword table
0B3778             0997**  ;           IY = start of match text
0B3778             0998**  ;  Outputs: If found, Z-flag set, A=token.
0B3778             0999**  ;           If not found, Z-flag reset, A=(IY).
0B3778             1000**  ;           IY updated (if NZ, IY unchanged).
0B3778             1001**  ; Destroys: A,B,H,L,IY,F
0B3778             1002**  ;
0B3778 21 19 31 0B 1003**  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0B377C             1004**  ;
0B377C FD 7E 00    1005**  LEX0:			LD      A,(IY)			; Fetch the character to match
0B377F 46          1006**  			LD      B,(HL)			; B: The token from the keywords table
0B3780 23          1007**  			INC     HL			; Increment the pointer in the keywords table
0B3781 BE          1008**  			CP      (HL)			; Compare the first characters
0B3782 28 08       1009**  			JR      Z,LEX2			; If there is a match, then skip to LEX2
0B3784 D8          1010**  			RET     C               	; No match, so fail
0B3785             1011**  ;
0B3785             1012**  ; This snippet of code skips to the next token in the KEYWDS table
0B3785             1013**  ;
0B3785 23          1014**  LEX1:			INC     HL			; Increment the pointer
0B3786 CB 7E       1015**  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0B3788 28 FB       1016**  			JR      Z,LEX1			; No, so loop
0B378A 18 F0       1017**  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
0B378C             1018**  ;
0B378C FD E5       1019**  LEX2:			PUSH    IY              	; Save the input pointer
0B378E 23          1020**  LEX3:			INC     HL			; Increment the keyword pointer
0B378F CB 7E       1021**  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0B3791 20 1C       1022**  			JR      NZ,LEX6         	; Jump to here as we've found a token
0B3793 FD 23       1023**  			INC     IY			; Increment the text pointer
0B3795 FD 7E 00    1024**  			LD      A,(IY)			; Fetch the character
0B3798 FE 2E       1025**  			CP      '.'			; Is it an abbreviated keyword?
0B379A 28 13       1026**  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0B379C BE          1027**  			CP      (HL)			; Compare with the keywords list
0B379D 28 EF       1028**  			JR      Z,LEX3			; It's a match, so continue checking this keyword
0B379F CD 2C 3C 0B 1029**  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B37A3 38 04       1030**  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0B37A5             1031**  ;
0B37A5 FD E1       1032**  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0B37A7 18 DC       1033**  			JR      LEX1			; And loop back to start again
0B37A9             1034**  ;
0B37A9             1035**  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
0B37A9             1036**  ; immediately delimited
0B37A9             1037**  ;
0B37A9 7E          1038**  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0B37AA B7          1039**  			OR      A			; If it is not zero, then...
0B37AB 20 F8       1040**  			JR      NZ,LEX4			; Keep searching
0B37AD FD 2B       1041**  			DEC     IY			; If it is zero, then skip the input pointer back one byte
0B37AF             1042**  ;
0B37AF             1043**  ; We've found a token at this point
0B37AF             1044**  ;
0B37AF F1          1045**  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0B37B0 AF          1046**  			XOR     A			; Set the Z flag
0B37B1 78          1047**  			LD      A,B			; A: The token
0B37B2 C9          1048**  			RET
0B37B3             1049**  ;
0B37B3             1050**  ; DEL - DELETE A PROGRAM LINE.
0B37B3             1051**  ;   Inputs: HL addresses program line.
0B37B3             1052**  ; Destroys: B,C,F
0B37B3             1053**  ;
0B37B3             1054**  ; This simply erases the line by moving all of the code after the line to be deleted back over
0B37B3             1055**  ; it using an LDIR
0B37B3             1056**  ;
0B37B3 D5          1057**  DEL:			PUSH    DE
0B37B4 E5          1058**  			PUSH    HL
0B37B5 E5          1059**  			PUSH    HL			; HL: Address of the program line
0B37B6 06 00       1060**  			LD      B,0			; BC: Length of the line
0B37B8 4E          1061**  			LD      C,(HL)
0B37B9 09          1062**  			ADD     HL,BC			; HL: Advanced to the start of the next line
0B37BA E5          1063**  			PUSH    HL
0B37BB EB          1064**  			EX      DE,HL			; DE: Pointer to the next line
0B37BC 2A 17 4C 0B 1065**  			LD      HL,(TOP)		; HL: Pointer to the end of the program
0B37C0 ED 52       1066**  			SBC     HL,DE
0B37C2 44          1067**  			LD      B,H			; BC: Size of block to move
0B37C3 4D          1068**  			LD      C,L
0B37C4 E1          1069**  			POP     HL			; HL: Pointer to next line
0B37C5 D1          1070**  			POP     DE			; DE: Pointer to this line
0B37C6 ED B0       1071**  			LDIR                    	; Delete the line
0B37C8 ED 53 17 4C 1072**  			LD      (TOP),DE		; Adjust TOP
       0B          
0B37CD E1          1073**  			POP     HL
0B37CE D1          1074**  			POP     DE
0B37CF C9          1075**  			RET
0B37D0             1076**  ;
0B37D0             1077**  ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
0B37D0             1078**  ;   Inputs: Filename in ACCS (term CR)
0B37D0             1079**  ; Destroys: A,B,C,D,E,H,L,F
0B37D0             1080**  ;
0B37D0             1081**  ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
0B37D0             1082**  ; AND WRITE FF FF, THEN LOAD (TOP).
0B37D0             1083**  ; Destroys: A,B,C,H,L,F
0B37D0             1084**  ;
0B37D0 ED 5B 14 4C 1085**  LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
       0B          
0B37D5 21 00 FF FF 1086**  			LD      HL,-256
0B37D9 39          1087**  			ADD     HL,SP
0B37DA ED 52       1088**  			SBC     HL,DE           	; Find available space
0B37DC 44          1089**  			LD      B,H
0B37DD 4D          1090**  			LD      C,L
0B37DE 21 00 49 0B 1091**  			LD      HL,ACCS
0B37E2 CD 45 41 0B 1092**  			CALL    OSLOAD          	; Call the OSLOAD function in patch
0B37E6 D4 1D 38 0B 1093**  			CALL    NC,NEWIT		; If NC then NEW
0B37EA 3E 00       1094**  			LD      A,0
0B37EC D2 11 37 0B 1095**  			JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
0B37F0             1096**  ;
0B37F0 CD FC 37 0B 1097**  CLEAN:			CALL    SETTOP			; Set TOP sysvar
0B37F4 2B          1098**  			DEC     HL			; Write out the end of program markers
0B37F5 36 FF       1099**  			LD      (HL),-1
0B37F7 2B          1100**  			DEC     HL
0B37F8 36 FF       1101**  			LD      (HL),-1
0B37FA 18 2B       1102**  			JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0B37FC             1103**  ;
0B37FC             1104**  ; Set the TOP sysvar; the first free location after the end of the current program
0B37FC             1105**  ; Returns:
0B37FC             1106**  ; - HL: TOP
0B37FC             1107**  ;
0B37FC 2A 14 4C 0B 1108**  SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0B3800 01 00 00 00 1109**  			LD	BC, 0			; BC: 0
0B3804 3E 0D       1110**  			LD      A,CR			; End of line marker
0B3806 4E          1111**  SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0B3807 0C          1112**  			INC     C			; Check for zero
0B3808 0D          1113**  			DEC     C
0B3809 28 0A       1114**  			JR      Z,SETOP2		; If it is zero, we've reached the end
0B380B 09          1115**  			ADD     HL,BC			; Skip to next line
0B380C 2B          1116**  			DEC     HL			; Check end of previous line
0B380D BE          1117**  			CP      (HL)
0B380E 23          1118**  			INC     HL
0B380F 28 F5       1119**  			JR      Z,SETOP1		; If CR then loop
0B3811 C3 A9 36 0B 1120**  			JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0B3815             1121**  ;
0B3815 23          1122**  SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0B3816 23          1123**  			INC     HL			; NB: Called from NEWIT
0B3817 23          1124**  			INC     HL
0B3818 22 17 4C 0B 1125**  			LD      (TOP),HL		; Store in TOP sysvar
0B381C C9          1126**  			RET
0B381D             1127**  ;
0B381D             1128**  ; NEWIT - NEW PROGRAM THEN CLEAR
0B381D             1129**  ;   Destroys: H,L
0B381D             1130**  ;
0B381D             1131**  ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
0B381D             1132**  ; FUNCTION AND PROCEDURE POINTERS.
0B381D             1133**  ;   Destroys: Nothing
0B381D             1134**  ;
0B381D 2A 14 4C 0B 1135**  NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0B3821 36 00       1136**  			LD      (HL),0			; Stick a 0 in there
0B3823 CD 15 38 0B 1137**  			CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0B3827             1138**  ;
0B3827 E5          1139**  CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0B3828 2A 17 4C 0B 1140**  			LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0B382C 22 1A 4C 0B 1141**  			LD      (LOMEM),HL		; Set the LOMEM sysvar
0B3830 22 1D 4C 0B 1142**  			LD      (FREE),HL		; And the FREE sysvar with that value
0B3834 21 6C 4B 0B 1143**  			LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0B3838 C5          1144**  			PUSH    BC
0B3839             1145**  			; LD      B,3*(54+2)		; Loop counter
0B3839 06 A8       1146**  			LD      B,54+2*3		; ez80asm doesn't do () in expressions
0B383B 36 00       1147**  CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0B383D 23          1148**  			INC     HL
0B383E 10 FB       1149**  			DJNZ    CLEAR1
0B3840 C1          1150**  			POP     BC
0B3841 E1          1151**  			POP     HL			; Restore the BASIC program pointer
0B3842 C9          1152**  			RET
0B3843             1153**  ;
0B3843             1154**  ;LISTIT - LIST A PROGRAM LINE.
0B3843             1155**  ;    Inputs: HL addresses line
0B3843             1156**  ;            DE = line number (binary)
0B3843             1157**  ;            IX = Pointer to LISTON
0B3843             1158**  ;             B = FOR/NEXT indent level
0B3843             1159**  ;             C = REPEAT/UNTIL indent level
0B3843             1160**  ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
0B3843             1161**  ;
0B3843 E5          1162**  LISTIT:			PUSH    HL			; Stack the address of the line
0B3844 EB          1163**  			EX      DE,HL			; HL: Line number
0B3845 C5          1164**  			PUSH    BC
0B3846 CD AC 39 0B 1165**  			CALL    PBCD			; Print the line number
0B384A C1          1166**  			POP     BC
0B384B E1          1167**  			POP     HL			; HL: Address of the first token/character
0B384C 7E          1168**  			LD      A,(HL)			; Fetch the token
0B384D FE ED       1169**  			CP      NEXT			; Is it NEXT...
0B384F CC D9 38 0B 1170**  			CALL    Z,INDENT		; Yes, so indent in
0B3853 FE FD       1171**  			CP      UNTIL			; Or is it UNTIL...
0B3855 CC D9 38 0B 1172**  			CALL    Z,INDENT		; Yes, so indent in
0B3859 D9          1173**  			EXX
0B385A 3E 20       1174**  			LD      A,' '
0B385C DD CB 00 46 1175**  			BIT     0,(IX)			; If BIT 0 of LISTON is set
0B3860 C4 00 39 0B 1176**  			CALL    NZ,OUTCHR		; Then print a space after the line number
0B3864 78          1177**  			LD      A,B			; Fetch the FOR/NEXT indent level
0B3865 87          1178**  			ADD     A,A			; Multiply by 2
0B3866 DD CB 00 4E 1179**  			BIT     1,(IX)			; If BIT 1 of LISTON is set
0B386A C4 A0 17 0B 1180**  			CALL    NZ,FILL			; Then print the FOR/NEXT indent
0B386E 79          1181**  			LD      A,C			; Fetch the REPEAT/UNTIL indent level
0B386F 87          1182**  			ADD     A,A			; Multiply by 2
0B3870 DD CB 00 56 1183**  			BIT     2,(IX)			; If BIT 2 of LISTON is set
0B3874 C4 A0 17 0B 1184**  			CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0B3878 D9          1185**  			EXX
0B3879 7E          1186**  			LD      A,(HL)			; Fetch the token
0B387A FE E3       1187**  			CP      FOR			; Is it FOR?
0B387C CC D9 38 0B 1188**  			CALL    Z,INDENT		; Yes, so indent
0B3880 FE F5       1189**  			CP      REPEAT			; Is it REPEAT?
0B3882 CC D9 38 0B 1190**  			CALL    Z,INDENT		; Yes, so indent
0B3886 1E 00       1191**  			LD      E,0			; E: The quote counter - reset to 0
0B3888 7E          1192**  LIST8:			LD      A,(HL)			; Fetch a character / token byte
0B3889 23          1193**  			INC     HL
0B388A FE 0D       1194**  			CP      CR			; Is it end of line?
0B388C 28 0B       1195**  			JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0B388E FE 22       1196**  			CP      34			; Is it a quote character?
0B3890 20 01       1197**  			JR      NZ,LIST7		; No, so skip to next bit
0B3892 1C          1198**  			INC     E			; Otherwise increment quote counter
0B3893 CD C8 38 0B 1199**  LIST7:			CALL    LOUT			; Output the character / token
0B3897 18 EF       1200**  			JR      LIST8			; And repeat
0B3899             1201**  ;
0B3899             1202**  ; DB: Modification for *EDIT
0B3899             1203**  ; Terminate the line with either a CRLF or a NUL character
0B3899             1204**  ;
0B3899 DD CB 00 5E 1205**  LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0B389D 28 59       1206**  			JR	Z, CRLF			; Yes, so print a CRLF
0B389F AF          1207**  			XOR	A			; Otherwise print a NUL (0)
0B38A0 C3 B1 3E 0B 1208**  			JP	OSWRCH
0B38A4             1209**  ;
0B38A4             1210**  ; Decode the 3 byte GOTO type line number
0B38A4             1211**  ;
0B38A4 E5          1212**  PRLINO:			PUSH    HL			; Swap HL and IY
0B38A5 FD E1       1213**  			POP     IY			; IY: Pointer to the line number
0B38A7 C5          1214**  			PUSH    BC
0B38A8 CD 97 08 0B 1215**  			CALL    DECODE			; Decode
0B38AC C1          1216**  			POP     BC
0B38AD D9          1217**  			EXX
0B38AE C5          1218**  			PUSH    BC
0B38AF CD A8 39 0B 1219**  			CALL    PBCDL			; Output the line number
0B38B3 C1          1220**  			POP     BC
0B38B4 D9          1221**  			EXX
0B38B5 FD E5       1222**  			PUSH    IY			; Swap HL and IY
0B38B7 E1          1223**  			POP     HL			; HL: Pointer to the next character in the line
0B38B8 C9          1224**  			RET
0B38B9             1225**  ;
0B38B9             1226**  ; DB: Modification for internationalisation
0B38B9             1227**  ;
0B38B9 CD 1D 39 0B 1228**  PRREM:			CALL	OUT_			; Output the REM token
0B38BD 7E          1229**  @@:			LD	A, (HL)			; Fetch the character
0B38BE FE 0D       1230**  			CP	CR			; If it is end of line, then
0B38C0 C8          1231**  			RET	Z			; we have finished
0B38C1 CD 00 39 0B 1232**  			CALL	OUTCHR			; Ouput the character
0B38C5 23          1233**  			INC	HL
0B38C6 18 F5       1234**  			JR	@B			; And loop
0B38C8             1235**  ;
0B38C8             1236**  ; DB: End of modification
0B38C8             1237**  ;
0B38C8 CB 43       1238**  LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
0B38CA 20 34       1239**  			JR      NZ,OUTCHR		; don't tokenise, just output the character
0B38CC FE F4       1240**  			CP	REM			; DB: Is it REM
0B38CE 28 E9       1241**  			JR	Z, PRREM		; DB: Yes so jump to the special case for REM
0B38D0 FE 8D       1242**  			CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
0B38D2 28 D0       1243**  			JR      Z,PRLINO		; Yes, so decode and print the line number
0B38D4 CD 1D 39 0B 1244**  			CALL    OUT_			; Output a character / keyword
0B38D8 7E          1245**  			LD      A,(HL)			; Fetch the next character
0B38D9             1246**  ;
0B38D9             1247**  ; This block of code handles the indentation
0B38D9             1248**  ; B: Counter for FOR/NEXT indent
0B38D9             1249**  ; C: Counter for REPEAT/UNTIL indent
0B38D9             1250**  ;
0B38D9 D9          1251**  INDENT:			EXX
0B38DA FE E3       1252**  			CP      FOR			; If the token is FOR
0B38DC 28 09       1253**  			JR      Z,IND1			; Then INC B
0B38DE FE ED       1254**  			CP      NEXT			; If it is NEXT
0B38E0 20 06       1255**  			JR      NZ,IND2_		; Then...
0B38E2 05          1256**  			DEC     B			; DEC B
0B38E3 F2 E8 38 0B 1257**  			JP      P,IND2_			; If we have gone below 0 then
0B38E7 04          1258**  IND1:			INC     B			; Increment back to 0
0B38E8             1259**  ;
0B38E8 FE F5       1260**  IND2_:			CP      REPEAT			; If the token is REPEAT
0B38EA 28 09       1261**  			JR      Z,IND3			; Then INC C
0B38EC FE FD       1262**  			CP      UNTIL			; If it is UNTIL
0B38EE 20 06       1263**  			JR      NZ,IND4			; Then...
0B38F0 0D          1264**  			DEC     C			; DEC C
0B38F1 F2 F6 38 0B 1265**  			JP      P,IND4			; If we have gone below 0 then
0B38F5 0C          1266**  IND3:			INC     C			; Incremet back to 0
0B38F6 D9          1267**  IND4:			EXX
0B38F7 C9          1268**  			RET
0B38F8             1269**  ;
0B38F8             1270**  ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
0B38F8             1271**  ;  Destroys: A,F
0B38F8             1272**  ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
0B38F8             1273**  ;    Inputs: A = character
0B38F8             1274**  ;  Destroys: A,F
0B38F8             1275**  ;
0B38F8 3E 0D       1276**  CRLF:			LD      A,CR			; Output CR
0B38FA CD 00 39 0B 1277**  			CALL    OUTCHR
0B38FE 3E 0A       1278**  			LD      A,LF			; Output LF
0B3900             1279**  ;
0B3900 CD B1 3E 0B 1280**  OUTCHR:			CALL    OSWRCH			; Output the character in A
0B3904 D6 0D       1281**  			SUB     CR			; Check for CR
0B3906 28 06       1282**  			JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0B3908 D8          1283**  			RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0B3909 3A 3D 4C 0B 1284**  			LD      A,(COUNT)		; Increment the count
0B390D 3C          1285**  			INC     A
0B390E             1286**  ;
0B390E 32 3D 4C 0B 1287**  CARRET:			LD      (COUNT),A		; Store the new count value
0B3912 C8          1288**  			RET     Z			; Return if the count has wrapped to 0
0B3913 E5          1289**  			PUSH    HL			; Now check if count = print width
0B3914 2A 3E 4C 0B 1290**  			LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0B3918 BD          1291**  			CP      L			; L is the width. Compare it with count.
0B3919 E1          1292**  			POP     HL
0B391A C0          1293**  			RET     NZ			; If we've not hit print width, then just return
0B391B 18 DB       1294**  			JR      CRLF			; Otherwise output CRLF
0B391D             1295**  ;
0B391D             1296**  ; OUT - SEND CHARACTER OR KEYWORD
0B391D             1297**  ;   Inputs: A = character (>=10, <128)
0B391D             1298**  ;           A = Token (<10, >=128)
0B391D             1299**  ;  Destroys: A,F
0B391D             1300**  ;
0B391D FE 8A       1301**  OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0B391F EA 00 39 0B 1302**  			JP      PE,OUTCHR		; If so, then it's a character, so just output it
0B3923             1303**  ;
0B3923             1304**  ; This bit looks up the character in the KEYWDS token table and expands it
0B3923             1305**  ; Note the CP 138; this sets the overflow flag as follows:
0B3923             1306**  ;
0B3923             1307**  ; NB:
0B3923             1308**  ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
0B3923             1309**  ;  2. CP is effectively a SUB; sets the flags without affecting A
0B3923             1310**  ;  3. The operation n - -118 ~ n + 118
0B3923             1311**  ;
0B3923             1312**  ; So:
0B3923             1313**  ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
0B3923             1314**  ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
0B3923             1315**  ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
0B3923             1316**  ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
0B3923             1317**  ;
0B3923 C5          1318**  			PUSH    BC			; Preserve BC and HL
0B3924 E5          1319**  			PUSH    HL
0B3925 21 19 31 0B 1320**  			LD      HL,KEYWDS		; The list of tokens and keywords
0B3929 01 DF 02 00 1321**  			LD      BC,KEYWDL		; The length of the keyword list
0B392D ED B1       1322**  			CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0B392F             1323**  ;							; At this point HL points to the next byte, the first character of the token
0B392F 7E          1324**  TOKEN1:			LD      A,(HL)			; Fetch the character
0B3930 23          1325**  			INC     HL			; Increment to the next byte in the token table
0B3931 FE 8A       1326**  			CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0B3933 F5          1327**  			PUSH    AF			; Then...
0B3934 EC 00 39 0B 1328**  			CALL    PE,OUTCHR		; Output the character...
0B3938 F1          1329**  			POP     AF			;
0B3939 EA 2F 39 0B 1330**  			JP      PE,TOKEN1		; And loop to the next character
0B393D E1          1331**  			POP     HL			; Done, so tidy up the stack and exit
0B393E C1          1332**  			POP     BC
0B393F C9          1333**  			RET
0B3940             1334**  ;
0B3940             1335**  ; FINDL - FIND PROGRAM LINE
0B3940             1336**  ;   Inputs: HL = line number (binary)
0B3940             1337**  ;  Outputs: HL addresses line (if found)
0B3940             1338**  ;           DE = line number
0B3940             1339**  ;           Z-flag set if found.
0B3940             1340**  ; Destroys: A,B,C,D,E,H,L,F
0B3940             1341**  ;
0B3940 EB          1342**  FINDL:			EX      DE,HL			; DE: Line number (binary)
0B3941 2A 14 4C 0B 1343**  			LD      HL,(PAGE_)		; HL: Top of BASIC program area
0B3945 AF          1344**  			XOR     A               	;  A: 0
0B3946 BE          1345**  			CP      (HL)			; Check for end of program marker
0B3947 3C          1346**  			INC     A			;  A: 1
0B3948 D0          1347**  			RET     NC			; Return with 1 if 0
0B3949 AF          1348**  			XOR     A               	; Clear the carry flag
0B394A             1349**  ;			LD      B,A			;  B: 0
0B394A 01 00 00 00 1350**  			LD	BC, 0			; BC: 0
0B394E             1351**  ;
0B394E 4E          1352**  FINDL1:			LD      C,(HL)			;  C: The line length
0B394F E5          1353**  			PUSH    HL			; Stack the current program counter
0B3950 23          1354**  			INC     HL			; Skip to the line number bytes
0B3951 7E          1355**  			LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0B3952 23          1356**  			INC     HL
0B3953 66          1357**  			LD      H,(HL)
0B3954 6F          1358**  			LD      L,A
0B3955 52 ED 52    1359**  			SBC.S   HL,DE			; Compare with the line number we're searching for
0B3958 E1          1360**  			POP     HL			; Get the current program counter
0B3959 D0          1361**  			RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0B395A 09          1362**  			ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0B395B C3 4E 39 0B 1363**  			JP      FINDL1			; And loop
0B395F             1364**  ;
0B395F             1365**  ; SETLIN - Search program for line containing address
0B395F             1366**  ;          Update (LINENO)
0B395F             1367**  ;   Inputs: Address in (ERRLIN)
0B395F             1368**  ;  Outputs: Line number in HL and (LINENO)
0B395F             1369**  ; Destroys: B,C,D,E,H,L,F
0B395F             1370**  ;
0B395F 01 00 00 00 1371**  SETLIN:			LD	BC, 0			; Zero BC for later
0B3963             1372**  ;			LD      B, 0			; Zero B for later
0B3963 ED 5B 35 4C 1373**  			LD      DE, (ERRLIN)		; DE: Address of line
       0B          
0B3968 2A 14 4C 0B 1374**  			LD      HL, (PAGE_)		; HL: Start of user program area
0B396C B7          1375**  			OR      A			; Do a 24 bit compare without destroying HL
0B396D ED 52       1376**  			SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0B396F 19          1377**  			ADD     HL, DE			;  C: DE > HL
0B3970 30 1B       1378**  			JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0B3972             1379**  ;
0B3972 4E          1380**  SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0B3973 0C          1381**  			INC     C			; This is a way to check for zero without using the accumulator
0B3974 0D          1382**  			DEC     C			; If it is zero, then...
0B3975 28 16       1383**  			JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0B3977 09          1384**  			ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0B3978 ED 52       1385**  			SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0B397A 19          1386**  			ADD     HL, DE
0B397B 38 F5       1387**  			JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0B397D ED 42       1388**  			SBC     HL, BC			; We've found it, so back up to the beginning of the line
0B397F 23          1389**  			INC     HL			; Skip the length counter
0B3980 11 00 00 00 1390**  			LD	DE, 0			; Zero DE
0B3984 5E          1391**  			LD      E, (HL)          	; Fetch the line number
0B3985 23          1392**  			INC     HL
0B3986 56          1393**  			LD      D, (HL)
0B3987 EB          1394**  			EX      DE, HL			; HL: The line number
0B3988 22 23 4C 0B 1395**  SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0B398C C9          1396**  			RET
0B398D             1397**  ;
0B398D 21 00 00 00 1398**  SET3:			LD      HL, 0			; We've not found the line at this point so
0B3991 18 F5       1399**  			JR      SET2			; Set LINENO to 0
0B3993             1400**  ;
0B3993             1401**  ;SAYLN - PRINT " at line nnnn" MESSAGE.
0B3993             1402**  ;  Outputs: Carry=0 if line number is zero.
0B3993             1403**  ;           Carry=1 if line number is non-zero.
0B3993             1404**  ; Destroys: A,B,C,D,E,H,L,F
0B3993             1405**  ;
0B3993 2A 23 4C 0B 1406**  SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0B3997 7C          1407**  			LD      A,H			; If it is zero then
0B3998 B5          1408**  			OR      L
0B3999 C8          1409**  			RET     Z			; Don't need to do anything; return with F:C set to 0
0B399A CD 41 3D 0B 1410**  			CALL    TELL			; Output the error message
0B399E 20 61 74 20 1411**  			DB    	" at line ", 0
       6C 69 6E 65 
       20 00       
0B39A8 0E 00       1412**  PBCDL:			LD      C,0			; C: Leading character (NUL)
0B39AA 18 02       1413**  			JR      PBCD0			; Output the line number; return with F:C set to 1
0B39AC             1414**  ;
0B39AC             1415**  ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
0B39AC             1416**  ;   Inputs: HL = number (binary).
0B39AC             1417**  ;  Outputs: Carry = 1
0B39AC             1418**  ; Destroys: A,B,C,D,E,H,L,F
0B39AC             1419**  ;
0B39AC 0E 20       1420**  PBCD:			LD      C,' '			; C: Leading character (" ")
0B39AE 06 05       1421**  PBCD0:			LD      B,5			; Number of digits in result
0B39B0 11 10 27 00 1422**  			LD      DE,10000		; Start off with the 10,000 column
0B39B4 AF          1423**  PBCD1:			XOR     A			; Counter
0B39B5 ED 52       1424**  PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
0B39B7 3C          1425**  			INC     A
0B39B8 30 FB       1426**  			JR      NC,PBCD2
0B39BA 19          1427**  			ADD     HL,DE			; The loop overruns by one, so adjust here
0B39BB 3D          1428**  			DEC     A			; A: Number of 10,000s
0B39BC 28 04       1429**  			JR      Z,PBCD3			; If it is 0, then skip the next bit
0B39BE CB E1       1430**  			SET     4,C			; C: Set to '0' ASCII (30h)
0B39C0 CB E9       1431**  			SET     5,C
0B39C2 B1          1432**  PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
0B39C3 C4 00 39 0B 1433**  			CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
0B39C7 78          1434**  			LD      A,B			; If on first transition, skip this
0B39C8 FE 05       1435**  			CP      5			; TODO: Need to find out why
0B39CA 28 06       1436**  			JR      Z,PBCD4
0B39CC 29          1437**  			ADD     HL,HL			; HL x  2 : We shift the number being tested left,
0B39CD 54          1438**  			LD      D,H			;         : rather than shifting DE right
0B39CE 5D          1439**  			LD      E,L			;         : This makes a lot of sense
0B39CF 29          1440**  			ADD     HL,HL			; HL x  4
0B39D0 29          1441**  			ADD     HL,HL			; HL x  8
0B39D1 19          1442**  			ADD     HL,DE			; HL x 10
0B39D2 11 E8 03 00 1443**  PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
0B39D6 10 DC       1444**  			DJNZ    PBCD1			; Loop until done
0B39D8 37          1445**  			SCF				; SCF set for SAYLN in this module
0B39D9 C9          1446**  			RET
0B39DA             1447**  ;
0B39DA             1448**  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
0B39DA             1449**  ;   Inputs: HL, IY as returned from GETVAR (NZ).
0B39DA             1450**  ;  Outputs: As GETVAR.
0B39DA             1451**  ; Destroys: everything
0B39DA             1452**  ;
0B39DA CD 5F 3B 0B 1453**  PUTVAR:			CALL    CREATE			; Create the variable
0B39DE FD 7E 00    1454**  			LD      A,(IY)			; Fetch the next character
0B39E1 FE 28       1455**  			CP      '('			; Check for bad use of array
0B39E3 20 70       1456**  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
0B39E5 3E 0E       1457**  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
0B39E7 C3 11 37 0B 1458**  ERROR3:			JP      ERROR_
0B39EB             1459**  ;
0B39EB             1460**  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
0B39EB             1461**  ;   Inputs: IY addresses first character.
0B39EB             1462**  ;  Outputs: Carry set and NZ if illegal character.
0B39EB             1463**  ;           Z-flag set if variable found, then:
0B39EB             1464**  ;            A = variable type (0,4,5,128 or 129)
0B39EB             1465**  ;            HL = IX = variable pointer.
0B39EB             1466**  ;            IY updated
0B39EB             1467**  ;           If Z-flag & carry reset, then:
0B39EB             1468**  ;            HL, IY set for subsequent PUTVAR call.
0B39EB             1469**  ; Destroys: everything
0B39EB             1470**  ;
0B39EB FD 7E 00    1471**  GETVAR:			LD      A,(IY)			; Get the first character
0B39EE FE 24       1472**  			CP      '$'			; Is it a string?
0B39F0 28 69       1473**  			JR      Z,GETV4			; Yes, so branch here
0B39F2 FE 21       1474**  			CP      '!'			; Is it indirection (32-bit)?
0B39F4 28 69       1475**  			JR      Z,GETV5			; Yes, so branch here
0B39F6 FE 3F       1476**  			CP      '?'			; Is it indirection (8-bit)?
0B39F8 28 69       1477**  			JR      Z,GETV6			; Yes, so branch here
0B39FA             1478**  ;
0B39FA CD C9 3A 0B 1479**  			CALL    LOCATE			; Locate the variable
0B39FE C0          1480**  			RET     NZ			; And exit here if not found
0B39FF             1481**  ;
0B39FF             1482**  ; At this point:
0B39FF             1483**  ;  HL: Address of variable in memory
0B39FF             1484**  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
0B39FF             1485**  ;
0B39FF FD 7E 00    1486**  			LD      A,(IY)			; Further checks
0B3A02 FE 28       1487**  			CP      '('             	; Is it an array?
0B3A04 20 47       1488**  			JR      NZ,GETVX        	; No, so exit
0B3A06             1489**  ;
0B3A06             1490**  ; We are processing an array at this point
0B3A06             1491**  ;
0B3A06 D5          1492**  			PUSH    DE              	; Save the variable type (in D)
0B3A07 7E          1493**  			LD      A,(HL)          	; Fetch the number of dimensions
0B3A08 B7          1494**  			OR      A
0B3A09 28 DA       1495**  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
0B3A0B 23          1496**  			INC     HL			;
0B3A0C 11 00 00 00 1497**  			LD      DE,0            	; Accumulator
0B3A10 F5          1498**  			PUSH    AF
0B3A11 FD 23       1499**  			INC     IY              	; Skip "("
0B3A13 18 05       1500**  			JR      GETV3
0B3A15             1501**  ;
0B3A15 F5          1502**  GETV2:			PUSH    AF
0B3A16 CD D3 09 0B 1503**  			CALL    COMMA
0B3A1A E5          1504**  GETV3:			PUSH    HL
0B3A1B D5          1505**  			PUSH    DE
0B3A1C CD BB 02 0B 1506**  			CALL    EXPRI			; Get the subscript
0B3A20 D9          1507**  			EXX
0B3A21 D1          1508**  			POP     DE
0B3A22 E3          1509**  			EX      (SP),HL
0B3A23 4E          1510**  			LD      C,(HL)
0B3A24 23          1511**  			INC     HL
0B3A25 46          1512**  			LD      B,(HL)
0B3A26 23          1513**  			INC     HL
0B3A27 E3          1514**  			EX      (SP),HL
0B3A28 EB          1515**  			EX      DE,HL
0B3A29 D5          1516**  			PUSH    DE
0B3A2A CD 23 18 0B 1517**  			CALL    MUL16			; HL=HL*BC
0B3A2E D1          1518**  			POP     DE
0B3A2F 19          1519**  			ADD     HL,DE
0B3A30 EB          1520**  			EX      DE,HL
0B3A31 B7          1521**  			OR      A
0B3A32 ED 42       1522**  			SBC     HL,BC
0B3A34 3E 0F       1523**  			LD      A,15
0B3A36 30 AF       1524**  			JR      NC,ERROR3		; Throw a "Subscript" error
0B3A38 E1          1525**  			POP     HL
0B3A39 F1          1526**  			POP     AF
0B3A3A 3D          1527**  			DEC     A               	; Dimension counter
0B3A3B 20 D8       1528**  			JR      NZ,GETV2
0B3A3D CD E0 09 0B 1529**  			CALL    BRAKET          	; Check for closing bracket
0B3A41 F1          1530**  			POP     AF              	; Restore the type
0B3A42 E5          1531**  			PUSH    HL
0B3A43 CD 16 18 0B 1532**  			CALL    X4OR5           	; DE=DE*n
0B3A47 E1          1533**  			POP     HL
0B3A48 19          1534**  			ADD     HL,DE
0B3A49 57          1535**  			LD      D,A             	; The type
0B3A4A FD 7E 00    1536**  			LD      A,(IY)
0B3A4D FE 3F       1537**  GETVX:			CP      '?'
0B3A4F 28 1E       1538**  			JR      Z,GETV9
0B3A51 FE 21       1539**  			CP      '!'
0B3A53 28 16       1540**  			JR      Z,GETV8
0B3A55 E5          1541**  GETVZ:			PUSH    HL              	; Set exit conditions
0B3A56 DD E1       1542**  			POP     IX
0B3A58 7A          1543**  			LD      A,D
0B3A59 BF          1544**  			CP      A
0B3A5A C9          1545**  			RET
0B3A5B             1546**  ;
0B3A5B             1547**  ; Process strings, unary & binary indirection:
0B3A5B             1548**  ;
0B3A5B 3E 80       1549**  GETV4:			LD      A,128           	; Static strings
0B3A5D 18 05       1550**  			JR      GETV7
0B3A5F             1551**  ;
0B3A5F 3E 04       1552**  GETV5:			LD      A,4             	; Unary 32-bit indirection
0B3A61 18 01       1553**  			JR      GETV7
0B3A63             1554**  ;
0B3A63 AF          1555**  GETV6:			XOR     A               	; Unary 8-bit indirection
0B3A64             1556**  ;
0B3A64 21 00 00 00 1557**  GETV7:			LD      HL,0
0B3A68 F5          1558**  			PUSH    AF
0B3A69 18 24       1559**  			JR      GETV0
0B3A6B             1560**  ;
0B3A6B 06 04       1561**  GETV8:			LD      B,4             	; Binary 32-bt indirection
0B3A6D 18 02       1562**  			JR      GETVA
0B3A6F             1563**  ;
0B3A6F 06 00       1564**  GETV9:			LD      B,0             	; Binary 8-bit indirection
0B3A71             1565**  ;
0B3A71 E5          1566**  GETVA:			PUSH    HL
0B3A72 DD E1       1567**  			POP     IX
0B3A74 7A          1568**  			LD      A,D            		; Fetch the variable type
0B3A75 FE 81       1569**  			CP      129			; Is it a string?
0B3A77 C8          1570**  			RET     Z               	; Yes, so exit here
0B3A78 C5          1571**  			PUSH    BC
0B3A79 CD C7 03 0B 1572**  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
0B3A7D CD 13 06 0B 1573**  			CALL    SFIX
0B3A81 7D          1574**  			LD	A,L
0B3A82 D9          1575**  			EXX
0B3A83 22 4A 4C 0B 1576**  			LD	(R0+0),HL
0B3A87 32 4C 4C 0B 1577**  			LD	(R0+2),A
0B3A8B 2A 4A 4C 0B 1578**  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
0B3A8F             1579**  ;
0B3A8F E5          1580**  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
0B3A90 FD 23       1581**  			INC     IY
0B3A92 CD D6 02 0B 1582**  			CALL    ITEMI
0B3A96 7D          1583**  			LD	A,L			;  A: The MSB of the address
0B3A97 D9          1584**  			EXX
0B3A98 22 4A 4C 0B 1585**  			LD	(R0+0),HL		; HL: The LSW of the address
0B3A9C 32 4C 4C 0B 1586**  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
0B3AA0 D1          1587**  			POP     DE
0B3AA1 F1          1588**  			POP     AF
0B3AA2 2A 4A 4C 0B 1589**  			LD	HL,(R0)			; HL: L'HL
0B3AA6 19          1590**  			ADD     HL,DE
0B3AA7 E5          1591**  			PUSH    HL
0B3AA8 DD E1       1592**  			POP     IX
0B3AAA BF          1593**  			CP      A
0B3AAB C9          1594**  			RET
0B3AAC             1595**  ;
0B3AAC             1596**  ;GETDEF - Find entry for FN or PROC in dynamic area.
0B3AAC             1597**  ;   Inputs: IY addresses byte following "DEF" token.
0B3AAC             1598**  ;  Outputs: Z flag set if found
0B3AAC             1599**  ;           Carry set if neither FN or PROC first.
0B3AAC             1600**  ;           If Z: HL points to entry
0B3AAC             1601**  ;                 IY addresses delimiter
0B3AAC             1602**  ; Destroys: A,D,E,H,L,IY,F
0B3AAC             1603**  ;
0B3AAC FD 7E 01    1604**  GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
0B3AAF CD 2C 3C 0B 1605**  			CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
0B3AB3 D8          1606**  			RET     C			; No so return with C set
0B3AB4 FD 7E 00    1607**  			LD      A,(IY)			; Fetch the current character from the tokenised line
0B3AB7 21 0E 4C 0B 1608**  			LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
0B3ABB FE A4       1609**  			CP      FN			; Is it the token FN?
0B3ABD 28 4A       1610**  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3ABF 21 11 4C 0B 1611**  			LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
0B3AC3 FE F2       1612**  			CP      PROC			; Is it the token PROC?
0B3AC5 28 42       1613**  			JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3AC7 37          1614**  			SCF				; No, so just return with C set
0B3AC8 C9          1615**  			RET
0B3AC9             1616**  ;
0B3AC9             1617**  ; LOCATE - Try to locate variable name in static or dynamic variables.
0B3AC9             1618**  ; If illegal first character return carry, non-zero.
0B3AC9             1619**  ; If found, return no-carry, zero.
0B3AC9             1620**  ; If not found, return no-carry, non-zero.
0B3AC9             1621**  ;   Inputs: IY=Addresses first character of name.
0B3AC9             1622**  ;            A=(IY)
0B3AC9             1623**  ;  Outputs:  F=Z set if found, then:
0B3AC9             1624**  ;           IY=addresses terminator
0B3AC9             1625**  ;           HL=addresses location of variable
0B3AC9             1626**  ;            D=type of variable: 4 = integer
0B3AC9             1627**  ;                                5 = floating point
0B3AC9             1628**  ;                              129 = string
0B3AC9             1629**  ; Destroys: A,D,E,H,L,IY,F
0B3AC9             1630**  ;
0B3AC9             1631**  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
0B3AC9             1632**  ; They can contain any alphanumeric character and underscore (_)
0B3AC9             1633**  ; String variables are postfixed with the dollar ($) character
0B3AC9             1634**  ; Integer variables are postfixed with the percent (%) character
0B3AC9             1635**  ; Static integer variables are named @%, A% to Z%
0B3AC9             1636**  ; All other variables are dynamic
0B3AC9             1637**  ;
0B3AC9 D6 40       1638**  LOCATE:			SUB     '@'			; Check for valid range
0B3ACB D8          1639**  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
0B3ACC 21 00 00 00 1640**  			LD      HL, 0			; Clear HL
0B3AD0 FE 1B       1641**  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
0B3AD2 30 1E       1642**  			JR      NC,LOC0         	; Then branch here
0B3AD4 6F          1643**  			LD	L, A			; HL = A
0B3AD5 FD 7E 01    1644**  			LD      A,(IY+1)        	; Check the 2nd character
0B3AD8 FE 25       1645**  			CP      '%'			; If not "%" then it is not static...
0B3ADA 20 21       1646**  			JR      NZ,LOC1         	; Branch here
0B3ADC FD 7E 02    1647**  			LD      A,(IY+2)		; Check the 3rd character
0B3ADF FE 28       1648**  			CP      '('			; If it is "(" (array) then it is not static...
0B3AE1 28 1A       1649**  			JR      Z,LOC1          	; Branch here
0B3AE3             1650**  ;
0B3AE3             1651**  ; At this point we're dealing with a static variable
0B3AE3             1652**  ;
0B3AE3 29          1653**  			ADD     HL,HL			; HL: Variable index * 4
0B3AE4 29          1654**  			ADD	HL,HL
0B3AE5 11 00 4B 0B 1655**  			LD      DE,STAVAR       	; The static variable area in memory
0B3AE9 19          1656**  			ADD     HL,DE			; HL: The address of the static variable
0B3AEA FD 23       1657**  			INC     IY			; Skip the program pointer past the static variable name
0B3AEC FD 23       1658**  			INC     IY
0B3AEE 16 04       1659**  			LD      D,4             	; Set the type to be integer
0B3AF0 AF          1660**  			XOR     A			; Set the Z flag
0B3AF1 C9          1661**  			RET
0B3AF2             1662**  ;
0B3AF2             1663**  ; At this point it's potentially a dynamic variable, just need to do a few more checks
0B3AF2             1664**  ;
0B3AF2 FE 1F       1665**  LOC0:			CP      '_'-'@'			; Check the first character is in
0B3AF4 D8          1666**  			RET     C			; the range "_" to
0B3AF5 FE 3B       1667**  			CP      'z'-'@'+1		; "z" (lowercase characters only)
0B3AF7 3F          1668**  			CCF				; If it is not in range then
0B3AF8 3D          1669**  			DEC     A               	; Set NZ flag and
0B3AF9 D8          1670**  			RET     C			; Exit here
0B3AFA D6 03       1671**  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
0B3AFC 6F          1672**  			LD	L, A			; HL = A
0B3AFD             1673**  ;
0B3AFD             1674**  ; Yes, it's definitely a dynamic variable at this point...
0B3AFD             1675**  ;
0B3AFD 7D          1676**  LOC1:			LD	A, L			; Fetch variable index
0B3AFE 87          1677**  			ADD	A, A			; x 2
0B3AFF 85          1678**  			ADD	A, L			; x 3
0B3B00 D6 03       1679**  			SUB	3			; Subtract 2 TODO: Should be 3
0B3B02 6F          1680**  			LD	L, A
0B3B03 11 6C 4B 0B 1681**  			LD      DE, DYNVAR       	; The dynamic variable storage
0B3B07 D8          1682**  			RET	C			; Bounds check to trap for variable '@'
0B3B08 19          1683**  			ADD     HL, DE			; HL: Address of first entry
0B3B09             1684**  ;
0B3B09             1685**  ; Loop through the linked list of variables to find a match
0B3B09             1686**  ;
0B3B09 ED 17       1687**  LOC2:			LD	DE, (HL)		; Fetch the original pointer
0B3B0B E5          1688**  			PUSH	HL			; Need to preserve HL for LOC6
0B3B0C AF          1689**  			XOR	A			; Reset carry flag
0B3B0D ED 62       1690**  			SBC	HL, HL			; Set HL to 0
0B3B0F ED 52       1691**  			SBC	HL, DE			; Compare with 0
0B3B11 E1          1692**  			POP	HL			; Restore the original pointer
0B3B12 28 49       1693**  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
0B3B14             1694**  			; LD	HL, DE			; Make a copy of this pointer in HL
0B3B14 D5          1695**  			push de
0B3B15 E1          1696**  			pop hl ; how was that even possible?
0B3B16 23          1697**  			INC     HL              	; Skip the link (24-bits)
0B3B17 23          1698**  			INC     HL
0B3B18 23          1699**  			INC	HL			; HL: Address of the variable name in DYNVARS
0B3B19 FD E5       1700**  			PUSH    IY			; IY: Address of the variable name in the program
0B3B1B             1701**  ;
0B3B1B 7E          1702**  LOC3:			LD      A,(HL)         		; Compare
0B3B1C 23          1703**  			INC     HL
0B3B1D FD 23       1704**  			INC     IY
0B3B1F FD BE 00    1705**  			CP      (IY)
0B3B22 28 F7       1706**  			JR      Z, LOC3			; Keep looping whilst we've got a match...
0B3B24 B7          1707**  			OR      A               	; Have we hit a terminator?
0B3B25 28 07       1708**  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
0B3B27             1709**  ;
0B3B27 FD E1       1710**  LOC4:			POP     IY			; Restore the pointer in the program
0B3B29 EB          1711**  			EX      DE, HL			; HL: New pointer in DYNVARS
0B3B2A C3 09 3B 0B 1712**  			JP      LOC2            	; Loop round and try again
0B3B2E             1713**  ;
0B3B2E             1714**  ; We might have located a variable at this point, just need to do a few more tests
0B3B2E             1715**  ;
0B3B2E FD 2B       1716**  LOC5:			DEC     IY
0B3B30 FD 7E 00    1717**  			LD      A,(IY)
0B3B33 FE 28       1718**  			CP      '('
0B3B35 28 15       1719**  			JR      Z,LOC5A         	; FOUND
0B3B37 FD 23       1720**  			INC     IY
0B3B39 CD 20 3C 0B 1721**  			CALL    RANGE
0B3B3D 38 0D       1722**  			JR      C,LOC5A         	; FOUND
0B3B3F FE 28       1723**  			CP      '('
0B3B41 28 E4       1724**  			JR      Z,LOC4          	; KEEP LOOKING
0B3B43 FD 7E FF    1725**  			LD      A,(IY-1)
0B3B46 CD 2C 3C 0B 1726**  			CALL    RANGE1
0B3B4A 30 DB       1727**  			JR      NC,LOC4         	; KEEP LOOKING
0B3B4C D1          1728**  LOC5A:			POP     DE
0B3B4D FD 7E FF    1729**  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
0B3B50 FE 24       1730**  			CP      '$'			; Is it a string?
0B3B52 16 81       1731**  			LD      D,129			; Yes, so return D = 129
0B3B54 C8          1732**  			RET     Z
0B3B55 FE 25       1733**  			CP      '%'			; Is it an integer?
0B3B57 16 04       1734**  			LD      D,4			; Yes, so return D = 4
0B3B59 C8          1735**  			RET     Z
0B3B5A 14          1736**  			INC     D			; At this point it must be a float
0B3B5B BF          1737**  			CP      A			; Set the flags
0B3B5C C9          1738**  			RET
0B3B5D             1739**  ;
0B3B5D             1740**  ; The variable is undefined at this point; HL will be zero
0B3B5D             1741**  ;
0B3B5D 3C          1742**  LOC6:			INC     A               	; Set NZ flag
0B3B5E C9          1743**  			RET
0B3B5F             1744**  ;
0B3B5F             1745**  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
0B3B5F             1746**  ;   Inputs: HL, IY as returned from LOCATE (NZ).
0B3B5F             1747**  ;  Outputs: As LOCATE, GETDEF.
0B3B5F             1748**  ; Destroys: As LOCATE, GETDEF.
0B3B5F             1749**  ;
0B3B5F AF          1750**  CREATE:			XOR     A
0B3B60 ED 5B 1D 4C 1751**  			LD      DE,(FREE)		; Get the last byte of available RAM
       0B          
0B3B65 ED 1F       1752**  			LD	(HL), DE		; Store
0B3B67 EB          1753**  			EX      DE,HL
0B3B68 77          1754**  			LD      (HL),A			; Clear the link of the new entity
0B3B69 23          1755**  			INC     HL
0B3B6A 77          1756**  			LD      (HL),A
0B3B6B 23          1757**  			INC     HL
0B3B6C 77          1758**  			LD      (HL),A
0B3B6D 23          1759**  			INC     HL
0B3B6E FD 23       1760**  LOC7:			INC     IY
0B3B70 CD 20 3C 0B 1761**  			CALL    RANGE           	; END OF VARIABLE?
0B3B74 38 15       1762**  			JR      C,LOC8
0B3B76 77          1763**  			LD      (HL),A
0B3B77 23          1764**  			INC     HL
0B3B78 CD 2C 3C 0B 1765**  			CALL    RANGE1
0B3B7C 30 F0       1766**  			JR      NC,LOC7
0B3B7E FE 28       1767**  			CP      '('
0B3B80 28 09       1768**  			JR      Z,LOC8
0B3B82 FD 7E 01    1769**  			LD      A,(IY+1)
0B3B85 FE 28       1770**  			CP      '('
0B3B87 28 E5       1771**  			JR      Z,LOC7
0B3B89 FD 23       1772**  			INC     IY
0B3B8B 36 00       1773**  LOC8:			LD      (HL),0          	; TERMINATOR
0B3B8D 23          1774**  			INC     HL
0B3B8E E5          1775**  			PUSH    HL
0B3B8F CD 4D 3B 0B 1776**  			CALL    TYPE_			; Get the variable type in D
0B3B93 3E 04       1777**  			LD      A,4			; If it is an integer then it takes up 4 bytes
0B3B95 BA          1778**  			CP      D
0B3B96 28 01       1779**  			JR      Z,LOC9			; So skip the next bit
0B3B98 3C          1780**  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0B3B99 36 00       1781**  LOC9:			LD      (HL),0          	; Initialise the memory to zero
0B3B9B 23          1782**  			INC     HL
0B3B9C 3D          1783**  			DEC     A
0B3B9D 20 FA       1784**  			JR      NZ,LOC9
0B3B9F 22 1D 4C 0B 1785**  			LD      (FREE),HL		; Adjust the stack
0B3BA3 CD 00 16 0B 1786**  			CALL    CHECK			; Check whether we are out of space
0B3BA7 E1          1787**  			POP     HL
0B3BA8 AF          1788**  			XOR     A
0B3BA9 C9          1789**  			RET
0B3BAA             1790**  ;
0B3BAA             1791**  ; LINNUM - GET LINE NUMBER FROM TEXT STRING
0B3BAA             1792**  ;   Inputs: IY = Text Pointer
0B3BAA             1793**  ;  Outputs: HL = Line number (zero if none)
0B3BAA             1794**  ;           IY updated
0B3BAA             1795**  ; Destroys: A,D,E,H,L,IY,F
0B3BAA             1796**  ;
0B3BAA             1797**  ; This bit of code performs a BASE 10 shift to build up the number
0B3BAA             1798**  ; So if the string passed is "345", the algorithm does this:
0B3BAA             1799**  ;
0B3BAA             1800**  ;    HL : Digit	: Operation
0B3BAA             1801**  ; ----- : ----- : ---------
0B3BAA             1802**  ; 00000 :	:
0B3BAA             1803**  ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
0B3BAA             1804**  ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
0B3BAA             1805**  ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
0B3BAA             1806**  ;
0B3BAA             1807**  ; The multiply by 10 is done by an unrolled shift and add loop
0B3BAA             1808**  ;
0B3BAA CD 21 0A 0B 1809**  LINNUM:			CALL    NXT			; Skip whitespace to the first character
0B3BAE 40 21 00 00 1810**  			LD.SIS  HL,0			; The running total
0B3BB2 FD 7E 00    1811**  LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
0B3BB5 D6 30       1812**  			SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
0B3BB7 D8          1813**  			RET     C			; And return if less than 0
0B3BB8 FE 0A       1814**  			CP      10			; Or greater than or equal to 10
0B3BBA D0          1815**  			RET     NC			; As we've hit a non-numeric character (end of number) at this point
0B3BBB FD 23       1816**  			INC     IY			; Increment the string pointer
0B3BBD 54          1817**  			LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
0B3BBE 5D          1818**  			LD      E,L			; Store the original number in DE
0B3BBF 52 29       1819**  			ADD.S   HL,HL           	; *2
0B3BC1 38 13       1820**  			JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
0B3BC3 52 29       1821**  			ADD.S   HL,HL           	; *4S
0B3BC5 38 0F       1822**  			JR      C,TOOBIG
0B3BC7 52 19       1823**  			ADD.S   HL,DE           	; *5
0B3BC9 38 0B       1824**  			JR      C,TOOBIG
0B3BCB 52 29       1825**  			ADD.S   HL,HL           	; *10
0B3BCD 38 07       1826**  			JR      C,TOOBIG
0B3BCF 5F          1827**  			LD      E,A			; A->DE: the digit to add in
0B3BD0 16 00       1828**  			LD      D,0
0B3BD2 52 19       1829**  			ADD.S   HL,DE           	; Add in the digit to the running total
0B3BD4 30 DC       1830**  			JR      NC,LINNM1       	; And if it is still <= 65535, loop
0B3BD6             1831**  ;
0B3BD6 3E 14       1832**  TOOBIG:			LD      A,20
0B3BD8 C3 11 37 0B 1833**  			JP      ERROR_           	; Error: "Too big"
0B3BDC             1834**  ;
0B3BDC             1835**  ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
0B3BDC             1836**  ;   Inputs: IY = text pointer
0B3BDC             1837**  ;  Outputs: HL = first number (10 by default)
0B3BDC             1838**  ;           BC = second number (10 by default)
0B3BDC             1839**  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
0B3BDC             1840**  ;
0B3BDC CD AA 3B 0B 1841**  PAIR:			CALL    LINNUM          	; Parse the first line number
0B3BE0 7C          1842**  			LD      A,H			; If it is not zero, then...
0B3BE1 B5          1843**  			OR      L
0B3BE2 20 02       1844**  			JR      NZ,PAIR1		; Skip...
0B3BE4 2E 0A       1845**  			LD      L,10			; HL: the default value (10)
0B3BE6             1846**  ;
0B3BE6 CD 2B 17 0B 1847**  PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
0B3BEA FD 23       1848**  			INC     IY			; Skip to next character
0B3BEC E5          1849**  			PUSH    HL			; Stack the first line number
0B3BED 21 0A 00 00 1850**  			LD      HL,10			; HL: the second default (10)
0B3BF1 C4 AA 3B 0B 1851**  			CALL    NZ,LINNUM       	; Parse the second line number
0B3BF5 E3          1852**  			EX      (SP),HL			; HL: The first line number (off the stack)
0B3BF6 C1          1853**  			POP     BC			; BC: Second line number
0B3BF7 78          1854**  			LD      A,B			; If the second line number is not zero then...
0B3BF8 B1          1855**  			OR      C			; We're good...
0B3BF9 C0          1856**  			RET     NZ			; Exit, otherwise...
0B3BFA CD 28 37 0B 1857**  			CALL    EXTERR			; Throw error: "Silly"
0B3BFE 53 69 6C 6C 1858**  			DB    	"Silly", 0
       79 00       
0B3C04             1859**  ;
0B3C04             1860**  ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
0B3C04             1861**  ;   Inputs: IY = text pointer
0B3C04             1862**  ;  Outputs: HL = points to program text
0B3C04             1863**  ;           BC = second number (0 by default)
0B3C04             1864**  ; Destroys: A,B,C,D,E,H,L,IY,F
0B3C04             1865**  ;
0B3C04 CD AA 3B 0B 1866**  DLPAIR:			CALL    LINNUM			; Parse the first line number
0B3C08 E5          1867**  			PUSH    HL			; Stack it
0B3C09 CD 2B 17 0B 1868**  			CALL    TERMQ			; Check for ELSE, : or CR
0B3C0D 28 0A       1869**  			JR      Z,DLP1			; And exit if so
0B3C0F FE E7       1870**  			CP      TIF			; Is the token IF?
0B3C11 28 06       1871**  			JR      Z,DLP1			; Yes, so skip the next bit...
0B3C13 FD 23       1872**  			INC     IY			; Otherwise...
0B3C15 CD AA 3B 0B 1873**  			CALL    LINNUM			; Fetch the second line number
0B3C19 E3          1874**  DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
0B3C1A CD 40 39 0B 1875**  			CALL    FINDL			; HL: Find the address of the line
0B3C1E C1          1876**  			POP     BC			; BC: The second number
0B3C1F C9          1877**  			RET
0B3C20             1878**  ;
0B3C20             1879**  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
0B3C20             1880**  ;   Inputs: IY addresses character
0B3C20             1881**  ;  Outputs: Carry set if out-of-range.
0B3C20             1882**  ; Destroys: A,F
0B3C20             1883**  ;
0B3C20             1884**  ; It is called here to check the following
0B3C20             1885**  ; In range: "$", "%" and "("
0B3C20             1886**  ;   Plus all characters in RANGE1 and RANGE2
0B3C20             1887**  ;
0B3C20 FD 7E 00    1888**  RANGE:			LD      A,(IY)			; Fetch the character
0B3C23 FE 24       1889**  			CP      '$'			; Postfix for string variable is valid
0B3C25 C8          1890**  			RET     Z
0B3C26 FE 25       1891**  			CP      '%'			; Postfix for integer variable is valid
0B3C28 C8          1892**  			RET     Z
0B3C29 FE 28       1893**  			CP      '('			; Postfix for array is valid
0B3C2B C8          1894**  			RET     Z
0B3C2C             1895**  ;
0B3C2C             1896**  ; It is called here to check the following
0B3C2C             1897**  ; In range: "0" to "9" and "@"
0B3C2C             1898**  ;   Plus all characters in RANGE2
0B3C2C             1899**  ;
0B3C2C FE 30       1900**  RANGE1:			CP      '0'			; If it is between '0'...
0B3C2E D8          1901**  			RET     C
0B3C2F FE 3A       1902**  			CP      '9'+1			; And '9'...
0B3C31 3F          1903**  			CCF
0B3C32 D0          1904**  			RET     NC			; Then it is valid
0B3C33 FE 40       1905**  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
0B3C35 C8          1906**  			RET     Z
0B3C36             1907**  ;
0B3C36             1908**  ; It is called here to check the following
0B3C36             1909**  ; In range: "A" to "Z", "a' to "z", "_" and "`"
0B3C36             1910**  ;
0B3C36 FE 41       1911**  RANGE2:			CP      'A'			; If it is between 'A'...
0B3C38 D8          1912**  			RET     C
0B3C39 FE 5B       1913**  			CP      'Z'+1			; And 'Z'...
0B3C3B 3F          1914**  			CCF
0B3C3C D0          1915**  			RET     NC			; Then it is valid
0B3C3D FE 5F       1916**  			CP      '_'			; If it is underscore, grave, or between 'a'
0B3C3F D8          1917**  			RET     C
0B3C40 FE 7B       1918**  			CP      'z'+1			; And 'z'
0B3C42 3F          1919**  			CCF				; Then it is valid
0B3C43 C9          1920**  			RET
0B3C44             1921**  ;
0B3C44             1922**  ; Throw a 'LINE space' error (line too long)
0B3C44             1923**  ; This is called from LEXAN
0B3C44             1924**  ;
0B3C44 AF          1925**  SPACE_: 		XOR     A
0B3C45 CD 28 37 0B 1926**  			CALL    EXTERR          	; "LINE space"
0B3C49 86 08 00    1927**  			DB    	LINE_MN_, 8, 0
0B3C4C             1928**  ;
0B3C4C             1929**  ; LEXAN - LEXICAL ANALYSIS.
0B3C4C             1930**  ;  Bit 0,C: 1=left, 0=right
0B3C4C             1931**  ;  Bit 2,C: 1=in BINARY
0B3C4C             1932**  ;  Bit 3,C: 1=in HEX
0B3C4C             1933**  ;  Bit 4,C: 1=accept line number
0B3C4C             1934**  ;  Bit 5,C: 1=in variable, FN, PROC
0B3C4C             1935**  ;  Bit 6,C: 1=in REM, DATA, *
0B3C4C             1936**  ;  Bit 7,C: 1=in quotes
0B3C4C             1937**  ;   Inputs: IY addresses source string
0B3C4C             1938**  ;           DE addresses destination string (must be page boundary)
0B3C4C             1939**  ;            C sets initial mode
0B3C4C             1940**  ;  Outputs: DE, IY updated
0B3C4C             1941**  ;            A holds carriage return
0B3C4C             1942**  ;
0B3C4C 12          1943**  LEXAN1:			LD      (DE),A          	; Transfer to buffer
0B3C4D 13          1944**  			INC     DE              	; Increment the pointers
0B3C4E FD 23       1945**  			INC     IY			; And fall through to the main function
0B3C50             1946**  ;
0B3C50             1947**  ; This is the main entry point
0B3C50             1948**  ;
0B3C50 7B          1949**  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
0B3C51 FE FC       1950**  			CP      252             	; If it is >= 252 bytes, then...
0B3C53 30 EF       1951**  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0B3C55 FD 7E 00    1952**  			LD      A,(IY)			; Fetch character from source string
0B3C58 FE 0D       1953**  			CP      CR			; If it is a CR
0B3C5A C8          1954**  			RET     Z               	; Then it is end of line; we're done parsing
0B3C5B CD 2C 3C 0B 1955**  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B3C5F 30 06       1956**  			JR      NC,LEXAN3		; Yes, so skip
0B3C61 CB A9       1957**  			RES     5,C             	; FLAG: NOT IN VARIABLE
0B3C63 CB 99       1958**  			RES     3,C             	; FLAG: NOT IN HEX
0B3C65 CB 91       1959**  			RES	2,C			; FLAG: NOT IN BINARY
0B3C67             1960**  ;
0B3C67 FE 20       1961**  LEXAN3:			CP      ' '			; Ignore spaces
0B3C69 28 E1       1962**  			JR      Z,LEXAN1
0B3C6B FE 2C       1963**  			CP      ','			; Ignore commas
0B3C6D 28 DD       1964**  			JR      Z,LEXAN1
0B3C6F FE 32       1965**  			CP	'2'			; If less than '2'
0B3C71 30 02       1966**  			JR	NC, @F			; No, so skip
0B3C73 CB 91       1967**  			RES	2,C			; FLAG: NOT IN BINARY
0B3C75 FE 47       1968**  @@:			CP      'G'			; If less then 'G'
0B3C77 38 02       1969**  			JR      C,LEXAN4		; Yes, so skip
0B3C79 CB 99       1970**  			RES     3,C             	; FLAG: NOT IN HEX
0B3C7B             1971**  ;
0B3C7B FE 22       1972**  LEXAN4:			CP      34			; Is it a quote character?
0B3C7D 20 05       1973**  			JR      NZ,LEXAN5		; No, so skip
0B3C7F CB 11       1974**  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
0B3C81 3F          1975**  			CCF                     	; Toggle the carry
0B3C82 CB 19       1976**  			RR      C			; And then shifting it back into bit 7 of C
0B3C84             1977**  ;
0B3C84 CB 61       1978**  LEXAN5:			BIT     4,C			; Accept line number?
0B3C86 28 12       1979**  			JR      Z,LEXAN6		; No, so skip
0B3C88 CB A1       1980**  			RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
0B3C8A C5          1981**  			PUSH    BC
0B3C8B D5          1982**  			PUSH    DE
0B3C8C CD AA 3B 0B 1983**  			CALL    LINNUM         		; Parse the line number to HL
0B3C90 D1          1984**  			POP     DE
0B3C91 C1          1985**  			POP     BC
0B3C92 7C          1986**  			LD      A,H			; If it is not zero
0B3C93 B5          1987**  			OR      L
0B3C94 C4 0D 3D 0B 1988**  			CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
0B3C98 18 B6       1989**  			JR      LEXAN2          	; And loop
0B3C9A             1990**  ;
0B3C9A 0D          1991**  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0B3C9B 28 0A       1992**  			JR      Z,LEXAN7        	; If so, skip
0B3C9D 0C          1993**  			INC     C			; Otherwise restore C
0B3C9E 20 AC       1994**  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0B3CA0 B7          1995**  			OR      A			; Set the flags based on the character
0B3CA1 F4 78 37 0B 1996**  			CALL    P,LEX           	; Tokenise if A < 128
0B3CA5 18 13       1997**  			JR      LEXAN8			; And skip
0B3CA7             1998**  ;
0B3CA7             1999**  ; Processing the LEFT hand side here
0B3CA7             2000**  ;
0B3CA7 FE 2A       2001**  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0B3CA9 28 17       2002**  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0B3CAB B7          2003**  			OR      A			; Set the flags based on the character
0B3CAC F4 78 37 0B 2004**  			CALL    P,LEX           	; Tokenise if A < 128
0B3CB0             2005**  ;
0B3CB0             2006**  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
0B3CB0             2007**  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
0B3CB0             2008**  ; Examples:
0B3CB0             2009**  ;   LET A% = PAGE : REM This is the GET version
0B3CB0             2010**  ;   PAGE = 40000  : REM This is the SET version
0B3CB0             2011**  ;
0B3CB0 FE 8F       2012**  			CP      TOKLO			; TOKLO is 8Fh
0B3CB2 38 06       2013**  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
0B3CB4 FE 94       2014**  			CP      TOKHI+1			; TOKHI is 93h
0B3CB6 30 02       2015**  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
0B3CB8 C6 40       2016**  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
0B3CBA             2017**  ;
0B3CBA FE F4       2018**  LEXAN8:			CP      REM			; If the token is REM
0B3CBC 28 04       2019**  			JR      Z,LEXAN9		; Then stop tokenising
0B3CBE FE DC       2020**  			CP      DATA_MN_			; If it is not DATA then
0B3CC0 20 02       2021**  			JR      NZ,LEXANA		; Skip
0B3CC2 CB F1       2022**  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
0B3CC4             2023**  ;
0B3CC4 FE A4       2024**  LEXANA:			CP      FN			; If the token is FN
0B3CC6 28 0A       2025**  			JR      Z,LEXANB
0B3CC8 FE F2       2026**  			CP      PROC			; Or the token is PROC
0B3CCA 28 06       2027**  			JR      Z,LEXANB		; Then jump to here
0B3CCC CD 36 3C 0B 2028**  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
0B3CD0 38 02       2029**  			JR      C,LEXANC		; Jump here if out of range
0B3CD2             2030**  ;
0B3CD2 CB E9       2031**  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
0B3CD4 FE 26       2032**  LEXANC:			CP      '&'			; Check for hex prefix
0B3CD6 20 02       2033**  			JR      NZ,LEXAND		; If not, skip
0B3CD8 CB D9       2034**  			SET     3,C             	; FLAG: IN HEX
0B3CDA             2035**  ;
0B3CDA FE 25       2036**  LEXAND:			CP	'%'			; Check for binary prefix
0B3CDC 20 02       2037**  			JR	NZ,LEXANE		; If not, skip
0B3CDE CB D1       2038**  			SET	2,C			; FLAG: IN BINARY
0B3CE0             2039**  ;
0B3CE0 21 04 3D 0B 2040**  LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
0B3CE4 C5          2041**  			PUSH    BC
0B3CE5 01 06 00 00 2042**  			LD      BC,LIST1L		; The list length
0B3CE9 ED B1       2043**  			CPIR				; Check if the token is in this list
0B3CEB C1          2044**  			POP     BC
0B3CEC 20 02       2045**  			JR      NZ,LEXANF		; If not, then skip
0B3CEE CB E1       2046**  			SET     4,C             	; FLAG: ACCEPT LINE NUMBER
0B3CF0             2047**  ;
0B3CF0 21 08 3D 0B 2048**  LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
0B3CF4 C5          2049**  			PUSH    BC
0B3CF5 01 05 00 00 2050**  			LD      BC,LIST2L		; The list length
0B3CF9 ED B1       2051**  			CPIR				; Check if the token is in this list
0B3CFB C1          2052**  			POP     BC
0B3CFC 20 02       2053**  			JR      NZ,LEXANG		; If not, then skip
0B3CFE CB C1       2054**  			SET     0,C             	; FLAG: ENTER LEFT MODE
0B3D00 C3 4C 3C 0B 2055**  LEXANG:			JP      LEXAN1			; And loop
0B3D04             2056**  
0B3D04             2057**  ;
0B3D04             2058**  ; LIST1: List of tokens that must be followed by line numbers
0B3D04             2059**  ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
0B3D04             2060**  ;
0B3D04 E5          2061**  LIST1:			DB	GOTO
0B3D05 E4          2062**  			DB	GOSUB
0B3D06 F7          2063**  			DB	RESTOR
0B3D07 FC          2064**  			DB	TRACE
0B3D08 8C          2065**  LIST2:			DB	THEN_MN_
0B3D09 8B          2066**  			DB	ELSE_MN_
0B3D0A             2067**  LIST1L:			EQU     $-LIST1
0B3D0A F5          2068**  			DB	REPEAT
0B3D0B 85          2069**  			DB	TERROR_MN
0B3D0C 3A          2070**  			DB    	':'
0B3D0D             2071**  LIST2L:			EQU     $-LIST2
0B3D0D             2072**  ;
0B3D0D             2073**  ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
0B3D0D             2074**  ;   Inputs: HL=line number, DE=string pointer
0B3D0D             2075**  ;  Outputs: DE updated, BIT 4,C set.
0B3D0D             2076**  ; Destroys: A,B,C,D,E,F
0B3D0D             2077**  ;
0B3D0D             2078**  ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
0B3D0D             2079**  ;
0B3D0D             2080**  ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
0B3D0D             2081**  ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
0B3D0D             2082**  ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
0B3D0D             2083**  ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
0B3D0D             2084**  ; each byte are then stored, in LO/HI order, ORred with 0x40.
0B3D0D             2085**  ;
0B3D0D CB E1       2086**  ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
0B3D0F EB          2087**  			EX      DE, HL			; HL: string pointer, DE: line number
0B3D10 36 8D       2088**  			LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
0B3D12 23          2089**  			INC     HL
0B3D13 7A          2090**  			LD      A,D			; Get the high byte
0B3D14 E6 C0       2091**  			AND     0C0H			; Get the top two bits	DD000000
0B3D16 0F          2092**  			RRCA				; Shift right		00DD0000
0B3D17 0F          2093**  			RRCA
0B3D18 47          2094**  			LD      B,A			; Store in B
0B3D19 7B          2095**  			LD      A,E			; Get the low byte
0B3D1A E6 C0       2096**  			AND     0C0H			; Get the top two bits	EE000000
0B3D1C B0          2097**  			OR      B			; Combine with D	EEDD0000
0B3D1D 0F          2098**  			RRCA				; Shift right		00EEDD00
0B3D1E 0F          2099**  			RRCA
0B3D1F EE 54       2100**  			XOR     01010100B		; XOR with 54h
0B3D21 77          2101**  			LD      (HL),A			; Store this as the second byte
0B3D22 23          2102**  			INC     HL
0B3D23 7B          2103**  			LD      A,E			; Get the low byte
0B3D24 E6 3F       2104**  			AND     3FH			; Strip the top two bits off
0B3D26 F6 40       2105**  			OR      '@'			; OR with 40h
0B3D28 77          2106**  			LD      (HL),A			; Store
0B3D29 23          2107**  			INC     HL
0B3D2A 7A          2108**  			LD      A,D			; Get the high byte
0B3D2B E6 3F       2109**  			AND     3FH			; Strip the top two bits off
0B3D2D F6 40       2110**  			OR      '@'			; OR with 40h
0B3D2F 77          2111**  			LD      (HL),A			; Store
0B3D30 23          2112**  			INC     HL
0B3D31 EB          2113**  			EX      DE,HL			; DE: string pointer, HL: line number
0B3D32 C9          2114**  			RET
0B3D33             2115**  ;
0B3D33             2116**  ; TEXT - OUTPUT MESSAGE.
0B3D33             2117**  ;   Inputs: HL addresses text (terminated by nul)
0B3D33             2118**  ;  Outputs: HL addresses character following nul.
0B3D33             2119**  ; Destroys: A,H,L,F
0B3D33             2120**  ;
0B3D33 2A 2F 4C 0B 2121**  REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
0B3D37             2122**  ;
0B3D37 7E          2123**  TEXT_:			LD      A, (HL)			; Fetch the character
0B3D38 23          2124**  			INC     HL			; Increment pointer to next character
0B3D39 B7          2125**  			OR      A			; Check for the nul (0) string terminator
0B3D3A C8          2126**  			RET     Z			; And return if so
0B3D3B CD 1D 39 0B 2127**  			CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
0B3D3F 18 F6       2128**  			JR      TEXT_			; And loop
0B3D41             2129**  ;
0B3D41             2130**  ; TELL - OUTPUT MESSAGE.
0B3D41             2131**  ;   Inputs: Text follows subroutine call (term=nul)
0B3D41             2132**  ; Destroys: A,F
0B3D41             2133**  ;
0B3D41             2134**  ; Example usage:
0B3D41             2135**  ;
0B3D41             2136**  ;	CALL	TELL			Call the function
0B3D41             2137**  ;	DB	"Hello World", 0	Followed by a zero terminated string
0B3D41             2138**  ;	LD	A, (1234H)		Program execution will carry on here after the message is output
0B3D41             2139**  ;
0B3D41 E3          2140**  TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
0B3D42 CD 37 3D 0B 2141**  			CALL    TEXT_			; first byte of the string that follows it. Print it, then
0B3D46 E3          2142**  			EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
0B3D47 C9          2143**  			RET				; at this point we'll return to the first instruction after the message
0B3D48             0010*       include "basic/misc.asm"
0B3D48             0001**  ;
0B3D48             0002**  ; Title:	BBC Basic for AGON - Miscellaneous helper functions
0B3D48             0003**  ; Author:	Dean Belfield
0B3D48             0004**  ; Created:	12/05/2023
0B3D48             0005**  ; Last Updated:	12/05/2023
0B3D48             0006**  ;
0B3D48             0007**  ; Modinfo:
0B3D48             0008**  
0B3D48             0009**  			; INCLUDE	"equs.inc"
0B3D48             0010**  			; INCLUDE	"macros.inc"
0B3D48             0011**  
0B3D48             0012**  			; .ASSUME	ADL = 1
0B3D48             0013**  
0B3D48             0014**  			; SEGMENT CODE
0B3D48             0015**  
0B3D48             0016**  			; XDEF	ASC_TO_NUMBER
0B3D48             0017**  			; XDEF	SWITCH_A
0B3D48             0018**  			; XDEF	NULLTOCR
0B3D48             0019**  			; XDEF	CRTONULL
0B3D48             0020**  			; XDEF	CSTR_FNAME
0B3D48             0021**  			; XDEF	CSTR_LINE
0B3D48             0022**  			; XDEF	CSTR_FINDCH
0B3D48             0023**  			; XDEF	CSTR_ENDSWITH
0B3D48             0024**  			; XDEF	CSTR_CAT
0B3D48             0025**  
0B3D48             0026**  			; XREF	OSWRCH
0B3D48             0027**  			; XREF	KEYWDS
0B3D48             0028**  			; XREF	KEYWDL
0B3D48             0029**  
0B3D48             0030**  ; Read a number and convert to binary
0B3D48             0031**  ; If prefixed with &, will read as hex, otherwise decimal
0B3D48             0032**  ;   Inputs: HL: Pointer in string buffer
0B3D48             0033**  ;  Outputs: HL: Updated text pointer
0B3D48             0034**  ;           DE: Value
0B3D48             0035**  ;            A: Terminator (spaces skipped)
0B3D48             0036**  ; Destroys: A,D,E,H,L,F
0B3D48             0037**  ;
0B3D48 C5          0038**  ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0B3D49 11 00 00 00 0039**  			LD	DE, 0			; Initialise DE
0B3D4D CD 8F 3D 0B 0040**  			CALL	SKIPSPC			; Skip whitespace
0B3D51 7E          0041**  			LD	A, (HL)			; Read first character
0B3D52 FE 26       0042**  			CP	'&'			; Is it prefixed with '&' (HEX number)?
0B3D54 20 1F       0043**  			JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B3D56 23          0044**  			INC	HL			; Otherwise fall through to ASC_TO_HEX
0B3D57             0045**  ;
0B3D57 7E          0046**  ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0B3D58 CD 9D 3D 0B 0047**  			CALL    UPPERC			; Convert to uppercase
0B3D5C D6 30       0048**  			SUB	'0'			; Normalise to 0
0B3D5E 38 2E       0049**  			JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B3D60 FE 0A       0050**  			CP 	10			; Check if >= 10
0B3D62 38 06       0051**  			JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0B3D64 D6 07       0052**  			SUB 	7			; Adjust ASCII A-F to nibble
0B3D66 FE 10       0053**  			CP 	16			; Check for > F
0B3D68 30 24       0054**  			JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0B3D6A EB          0055**  ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0B3D6B 29          0056**  			ADD	HL, HL
0B3D6C 29          0057**  			ADD	HL, HL
0B3D6D 29          0058**  			ADD	HL, HL
0B3D6E 29          0059**  			ADD	HL, HL
0B3D6F EB          0060**  			EX	DE, HL
0B3D70 B3          0061**  			OR      E			; OR the new digit in to the least significant nibble
0B3D71 5F          0062**  			LD      E, A
0B3D72 23          0063**  			INC     HL			; Onto the next character
0B3D73 18 E2       0064**  			JR      ASC_TO_NUMBER1		; And loop
0B3D75             0065**  ;
0B3D75 7E          0066**  ASC_TO_NUMBER3:		LD	A, (HL)
0B3D76 D6 30       0067**  			SUB	'0'			; Normalise to 0
0B3D78 38 14       0068**  			JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B3D7A FE 0A       0069**  			CP	10			; Check if >= 10
0B3D7C 30 10       0070**  			JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0B3D7E EB          0071**  			EX 	DE, HL 			; Stick DE in HL
0B3D7F 44          0072**  			LD	B, H 			; And copy HL into BC
0B3D80 4D          0073**  			LD	C, L
0B3D81 29          0074**  			ADD	HL, HL 			; x 2
0B3D82 29          0075**  			ADD	HL, HL 			; x 4
0B3D83 09          0076**  			ADD	HL, BC 			; x 5
0B3D84 29          0077**  			ADD	HL, HL 			; x 10
0B3D85 EB          0078**  			EX	DE, HL
0B3D86             0079**  			ADD8U_DE 			; Add A to DE (macro)
0B3D86 83          0001**M 		ADD	A, E
0B3D87 5F          0002**M 		LD	E, A
0B3D88 8A          0003**M 		ADC	A, D
0B3D89 93          0004**M 		SUB	E
0B3D8A 57          0005**M 		LD	D, A
0B3D8B 23          0080**  			INC	HL
0B3D8C 18 E7       0081**  			JR	ASC_TO_NUMBER3
0B3D8E C1          0082**  ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
0B3D8F             0083**  
0B3D8F             0084**  ; Skip a space
0B3D8F             0085**  ; HL: Pointer in string buffer
0B3D8F             0086**  ;
0B3D8F 7E          0087**  SKIPSPC:			LD      A, (HL)
0B3D90 FE 20       0088**  			CP      ' '
0B3D92 C0          0089**  			RET     NZ
0B3D93 23          0090**  			INC     HL
0B3D94 18 F9       0091**  			JR      SKIPSPC
0B3D96             0092**  
0B3D96             0093**  ; Skip a string
0B3D96             0094**  ; HL: Pointer in string buffer
0B3D96             0095**  ;
0B3D96 7E          0096**  SKIPNOTSP:		LD	A, (HL)
0B3D97 FE 20       0097**  			CP	' '
0B3D99 C8          0098**  			RET	Z
0B3D9A 23          0099**  			INC	HL
0B3D9B 18 F9       0100**  			JR	SKIPNOTSP
0B3D9D             0101**  
0B3D9D             0102**  ; Convert a character to upper case
0B3D9D             0103**  ;  A: Character to convert
0B3D9D             0104**  ;
0B3D9D E6 7F       0105**  UPPERC:  		AND     7FH
0B3D9F FE 60       0106**  			CP      '`'
0B3DA1 D8          0107**  			RET     C
0B3DA2 E6 5F       0108**  			AND     5FH			; Convert to upper case
0B3DA4 C9          0109**  			RET
0B3DA5             0110**  
0B3DA5             0111**  ; Switch on A - lookup table immediately after call
0B3DA5             0112**  ;  A: Index into lookup table
0B3DA5             0113**  ;
0B3DA5 E3          0114**  SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
0B3DA6 87          0115**  			ADD	A, A			; Multiply A by two
0B3DA7             0116**  			ADD8U_HL 			; Add to HL (macro)
0B3DA7 85          0001**M 		ADD	A, L
0B3DA8 6F          0002**M 		LD	L, A
0B3DA9 8C          0003**M 		ADC	A, H
0B3DAA 95          0004**M 		SUB	L
0B3DAB 67          0005**M 		LD	H, A
0B3DAC 7E          0117**  			LD	A, (HL)			; follow the call. Fetch an address from the
0B3DAD 23          0118**  			INC	HL 			; table.
0B3DAE 66          0119**  			LD	H, (HL)
0B3DAF 6F          0120**  			LD	L, A
0B3DB0 E3          0121**  			EX	(SP), HL		; Swap this new address back, restores HL
0B3DB1 C9          0122**  			RET				; Return program control to this new address
0B3DB2             0123**  
0B3DB2             0124**  ; Convert the buffer to a null terminated string and back
0B3DB2             0125**  ; HL: Buffer address
0B3DB2             0126**  ;
0B3DB2 C5          0127**  NULLTOCR:		PUSH 	BC
0B3DB3 06 00       0128**  			LD	B, 0
0B3DB5 0E 0D       0129**  			LD	C, CR
0B3DB7 18 05       0130**  			JR	CRTONULL0
0B3DB9             0131**  ;
0B3DB9 C5          0132**  CRTONULL:		PUSH	BC
0B3DBA 06 0D       0133**  			LD	B, CR
0B3DBC 0E 00       0134**  			LD	C, 0
0B3DBE             0135**  ;
0B3DBE E5          0136**  CRTONULL0:		PUSH	HL
0B3DBF 7E          0137**  CRTONULL1:		LD	A, (HL)
0B3DC0 B8          0138**  			CP 	B
0B3DC1 28 03       0139**  			JR	Z, CRTONULL2
0B3DC3 23          0140**  			INC	HL
0B3DC4 18 F9       0141**  			JR	CRTONULL1
0B3DC6 71          0142**  CRTONULL2:		LD	(HL), C
0B3DC7 E1          0143**  			POP 	HL
0B3DC8 C1          0144**  			POP	BC
0B3DC9 C9          0145**  			RET
0B3DCA             0146**  
0B3DCA             0147**  ; Copy a filename to DE and zero terminate it
0B3DCA             0148**  ; HL: Source
0B3DCA             0149**  ; DE: Destination (ACCS)
0B3DCA             0150**  ;
0B3DCA 7E          0151**  CSTR_FNAME:		LD	A, (HL)			; Get source
0B3DCB FE 20       0152**  			CP	32			; Is it space
0B3DCD 28 09       0153**  			JR	Z, @F
0B3DCF FE 0D       0154**  			CP	CR			; Or is it CR
0B3DD1 28 05       0155**  			JR	Z, @F
0B3DD3 12          0156**  			LD	(DE), A			; No, so store
0B3DD4 23          0157**  			INC	HL			; Increment
0B3DD5 13          0158**  			INC	DE
0B3DD6 18 F2       0159**  			JR	CSTR_FNAME		; And loop
0B3DD8 AF          0160**  @@:			XOR	A			; Zero terminate the target string
0B3DD9 12          0161**  			LD	(DE), A
0B3DDA 13          0162**  			INC	DE			; And point to next free address
0B3DDB C9          0163**  			RET
0B3DDC             0164**  
0B3DDC             0165**  ; Copy a CR terminated line to DE and zero terminate it
0B3DDC             0166**  ; HL: Source
0B3DDC             0167**  ; DE: Destination (ACCS)
0B3DDC             0168**  ;
0B3DDC 7E          0169**  CSTR_LINE:		LD	A, (HL)			; Get source
0B3DDD FE 0D       0170**  			CP	CR			; Is it CR
0B3DDF 28 05       0171**  			JR	Z, @F
0B3DE1 12          0172**  			LD	(DE), A			; No, so store
0B3DE2 23          0173**  			INC	HL			; Increment
0B3DE3 13          0174**  			INC	DE
0B3DE4 18 F6       0175**  			JR	CSTR_LINE		; And loop
0B3DE6 AF          0176**  @@:			XOR	A			; Zero terminate the target string
0B3DE7 12          0177**  			LD	(DE), A
0B3DE8 13          0178**  			INC	DE			; And point to next free address
0B3DE9 C9          0179**  			RET
0B3DEA             0180**  
0B3DEA             0181**  ; Find the first occurrence of a character (case sensitive)
0B3DEA             0182**  ; HL: Source
0B3DEA             0183**  ;  C: Character to find
0B3DEA             0184**  ; Returns:
0B3DEA             0185**  ; HL: Pointer to character, or end of string marker
0B3DEA             0186**  ;
0B3DEA 7E          0187**  CSTR_FINDCH:		LD	A, (HL)			; Get source
0B3DEB B9          0188**  			CP	C			; Is it our character?
0B3DEC C8          0189**  			RET	Z			; Yes, so exit
0B3DED B7          0190**  			OR	A			; Is it the end of string?
0B3DEE C8          0191**  			RET	Z			; Yes, so exit
0B3DEF 23          0192**  			INC	HL
0B3DF0 18 F8       0193**  			JR	CSTR_FINDCH
0B3DF2             0194**  
0B3DF2             0195**  ; Check whether a string ends with another string (case insensitive)
0B3DF2             0196**  ; HL: Source
0B3DF2             0197**  ; DE: The substring we want to test with
0B3DF2             0198**  ; Returns:
0B3DF2             0199**  ;  F: Z if HL ends with DE, otherwise NZ
0B3DF2             0200**  ;
0B3DF2 7E          0201**  CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
0B3DF3 CD 9D 3D 0B 0202**  			CALL	UPPERC			; Convert to upper case
0B3DF7 4F          0203**  			LD	C, A
0B3DF8 1A          0204**  			LD	A, (DE)			; Get the substring byte
0B3DF9 B9          0205**  			CP	C
0B3DFA C0          0206**  			RET	NZ			; Return NZ if at any point the strings don't match
0B3DFB B1          0207**  			OR	C			; Check whether both bytes are zero
0B3DFC C8          0208**  			RET	Z			; If so, return, as we have reached the end of both strings
0B3DFD 23          0209**  			INC	HL
0B3DFE 13          0210**  			INC	DE
0B3DFF 18 F1       0211**  			JR	CSTR_ENDSWITH		; And loop
0B3E01             0212**  
0B3E01             0213**  ; Concatenate a string onto the end of another string
0B3E01             0214**  ; HL: Source
0B3E01             0215**  ; DE: Second string
0B3E01             0216**  ;
0B3E01 7E          0217**  CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
0B3E02 B7          0218**  			OR	A
0B3E03 28 03       0219**  			JR	Z, CSTR_CAT_1
0B3E05 23          0220**  			INC	HL
0B3E06 18 F9       0221**  			JR	CSTR_CAT
0B3E08             0222**  ;
0B3E08 1A          0223**  CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
0B3E09 77          0224**  			LD	(HL), A
0B3E0A B7          0225**  			OR	A			; Check for end of string
0B3E0B C8          0226**  			RET	Z			; And return
0B3E0C 23          0227**  			INC	HL
0B3E0D 13          0228**  			INC	DE
0B3E0E 18 F8       0229**  			JR	CSTR_CAT_1		; Loop until finished
0B3E10             0011*       include "basic/patch.asm"
0B3E10             0001**  ;
0B3E10             0002**  ; Title:	BBC Basic for AGON
0B3E10             0003**  ; Author:	Dean Belfield
0B3E10             0004**  ; Created:	12/05/2023
0B3E10             0005**  ; Last Updated:	15/11/2023
0B3E10             0006**  ;
0B3E10             0007**  ; Modinfo:
0B3E10             0008**  ; 11/07/2023:	Fixed *BYE for ADL mode
0B3E10             0009**  ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
0B3E10             0010**  
0B3E10             0011**  			; .ASSUME	ADL = 1
0B3E10             0012**  
0B3E10             0013**  			; INCLUDE	"equs.inc"
0B3E10             0014**  			; INCLUDE "macros.inc"
0B3E10             0015**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B3E10             0016**  
0B3E10             0017**  			; SEGMENT CODE
0B3E10             0018**  
0B3E10             0019**  			; XDEF	OSWRCH
0B3E10             0020**  			; XDEF	OSLINE
0B3E10             0021**  			; XDEF	ESCSET
0B3E10             0022**  			; XDEF	PUTIME
0B3E10             0023**  			; XDEF	GETIME
0B3E10             0024**  			; XDEF	PUTCSR
0B3E10             0025**  			; XDEF 	GETCSR
0B3E10             0026**  			; XDEF	OSRDCH
0B3E10             0027**  			; XDEF	PROMPT
0B3E10             0028**  			; XDEF	OSKEY
0B3E10             0029**  			; XDEF	TRAP
0B3E10             0030**  			; XDEF	LTRAP
0B3E10             0031**  			; XDEF	OSINIT
0B3E10             0032**  			; XDEF	OSCLI
0B3E10             0033**  			; XDEF	OSBPUT
0B3E10             0034**  			; XDEF	OSBGET
0B3E10             0035**  			; XDEF	OSSTAT
0B3E10             0036**  			; XDEF	OSSHUT
0B3E10             0037**  			; XDEF	OSOPEN
0B3E10             0038**  			; XDEF	OSCALL
0B3E10             0039**  			; XDEF	GETPTR
0B3E10             0040**  			; XDEF	PUTPTR
0B3E10             0041**  			; XDEF	GETEXT
0B3E10             0042**  			; XDEF	GETIMS
0B3E10             0043**  			; XDEF	RESET
0B3E10             0044**  			; XDEF	OSLOAD
0B3E10             0045**  			; XDEF	OSSAVE
0B3E10             0046**  			; XDEF	EXPR_W2
0B3E10             0047**  			; XDEF	STAR_VERSION
0B3E10             0048**  
0B3E10             0049**  			; XREF	_basic_end			; In init.asm
0B3E10             0050**  
0B3E10             0051**  			; XREF	ASC_TO_NUMBER
0B3E10             0052**  			; XREF	RAM_START
0B3E10             0053**  			; XREF	RAM_END
0B3E10             0054**  			; XREF	FLAGS
0B3E10             0055**  			; XREF	ESCAPE
0B3E10             0056**  			; XREF	USER
0B3E10             0057**  			; XREF	RAM_Top
0B3E10             0058**  			; XREF	EXTERR
0B3E10             0059**  			; XREF	COUNT0
0B3E10             0060**  			; XREF	EXPRI
0B3E10             0061**  			; XREF	COMMA
0B3E10             0062**  			; XREF	XEQ
0B3E10             0063**  			; XREF	NXT
0B3E10             0064**  			; XREF	NULLTOCR
0B3E10             0065**  			; XREF	CRLF
0B3E10             0066**  			; XREF	CSTR_FNAME
0B3E10             0067**  			; XREF	CSTR_LINE
0B3E10             0068**  			; XREF	CSTR_FINDCH
0B3E10             0069**  			; XREF	CSTR_ENDSWITH
0B3E10             0070**  			; XREF	CSTR_CAT
0B3E10             0071**  			; XREF	FINDL
0B3E10             0072**  			; XREF	OUT_
0B3E10             0073**  			; XREF	ERROR_
0B3E10             0074**  			; XREF	ONEDIT
0B3E10             0075**  			; XREF	TELL
0B3E10             0076**  			; XREF	OSWRCHPT
0B3E10             0077**  			; XREF	OSWRCHCH
0B3E10             0078**  			; XREF	OSWRCHFH
0B3E10             0079**  			; XREF	LISTON
0B3E10             0080**  			; XREF	LISTIT
0B3E10             0081**  			; XREF	PAGE_
0B3E10             0082**  			; XREF	ONEDIT1
0B3E10             0083**  			; XREF	CLEAN
0B3E10             0084**  			; XREF	NEWIT
0B3E10             0085**  			; XREF	BAD
0B3E10             0086**  			; XREF	VBLANK_INIT
0B3E10             0087**  			; XREF	VBLANK_STOP
0B3E10             0088**  			; XREF	KEYDOWN
0B3E10             0089**  			; XREF	KEYASCII
0B3E10             0090**  			; XREF	WIDTH
0B3E10             0091**  			; XREF	ASSEM
0B3E10             0092**  
0B3E10             0093**  ; OSLINE: Invoke the line editor
0B3E10             0094**  ;
0B3E10 1E 01       0095**  OSLINE:			LD 	E, 1			; Default is to clear the buffer
0B3E12             0096**  
0B3E12             0097**  ; Entry point to line editor that does not clear the buffer
0B3E12             0098**  ;
0B3E12 FD E5       0099**  OSLINE1:		PUSH	IY
0B3E14 E5          0100**  			PUSH	HL			; Buffer address
0B3E15 01 00 01 00 0101**  			LD	BC, 256			; Buffer length
0B3E19             0102**  			MOSCALL	mos_editline		; Call the MOS line editor
0B3E19 3E 09       0001**M 			LD	A, function
0B3E1B 49 CF       0002**M 			RST.LIS	08h
0B3E1D E1          0103**  			POP	HL			; Pop the address
0B3E1E FD E1       0104**  			POP	IY
0B3E20 F5          0105**  			PUSH	AF			; Stack the return value (key pressed)
0B3E21 CD B2 3D 0B 0106**  			CALL	NULLTOCR		; Turn the 0 character to a CR
0B3E25 CD F8 38 0B 0107**  			CALL	CRLF			; Display CRLF
0B3E29 F1          0108**  			POP	AF
0B3E2A FE 1B       0109**  			CP	1Bh 			; Check if ESC terminated the input
0B3E2C CA 28 3F 0B 0110**  			JP	Z, LTRAP1 		; Yes, so do the ESC thing
0B3E30 3A 42 4C 0B 0111**  			LD	A, (FLAGS)		; Otherwise
0B3E34 CB BF       0112**  			RES	7, A 			; Clear the escape flag
0B3E36 32 42 4C 0B 0113**  			LD	(FLAGS), A
0B3E3A CD EE 40 0B 0114**  			CALL	WAIT_VBLANK 		; Wait a frame
0B3E3E AF          0115**   			XOR	A			; Return A = 0
0B3E3F 32 47 4C 0B 0116**  			LD	(KEYDOWN), A
0B3E43 32 48 4C 0B 0117**  			LD	(KEYASCII), A
0B3E47 C9          0118**  			RET
0B3E48             0119**  
0B3E48             0120**  ; PUTIME: set current time to DE:HL, in centiseconds.
0B3E48             0121**  ;
0B3E48 DD E5       0122**  PUTIME:			PUSH 	IX
0B3E4A             0123**  			MOSCALL	mos_sysvars
0B3E4A 3E 08       0001**M 			LD	A, function
0B3E4C 49 CF       0002**M 			RST.LIS	08h
0B3E4E DD 75 00    0124**  			LD	(IX + sysvar_time + 0), L
0B3E51 DD 74 01    0125**  			LD	(IX + sysvar_time + 1), H
0B3E54 DD 73 02    0126**  			LD	(IX + sysvar_time + 2), E
0B3E57 DD 72 03    0127**  			LD	(IX + sysvar_time + 3), D
0B3E5A DD E1       0128**  			POP	IX
0B3E5C C9          0129**  			RET
0B3E5D             0130**  
0B3E5D             0131**  ; GETIME: return current time in DE:HL, in centiseconds
0B3E5D             0132**  ;
0B3E5D DD E5       0133**  GETIME:			PUSH 	IX
0B3E5F             0134**  			MOSCALL	mos_sysvars
0B3E5F 3E 08       0001**M 			LD	A, function
0B3E61 49 CF       0002**M 			RST.LIS	08h
0B3E63 DD 6E 00    0135**  			LD	L, (IX + sysvar_time + 0)
0B3E66 DD 66 01    0136**  			LD	H, (IX + sysvar_time + 1)
0B3E69 DD 5E 02    0137**  			LD	E, (IX + sysvar_time + 2)
0B3E6C DD 56 03    0138**  			LD	D, (IX + sysvar_time + 3)
0B3E6F DD E1       0139**  			POP	IX
0B3E71 C9          0140**  			RET
0B3E72             0141**  
0B3E72             0142**  ; PUTCSR: move to cursor to x=DE, y=HL
0B3E72             0143**  ;
0B3E72 3E 1F       0144**  PUTCSR:			LD	A, 1Fh			; TAB
0B3E74 5B D7       0145**  			RST.LIL	10h
0B3E76 7B          0146**  			LD	A, E			; X
0B3E77 5B D7       0147**  			RST.LIL 10h
0B3E79 7D          0148**  			LD	A, L			; Y
0B3E7A 5B D7       0149**  			RST.LIL 10h
0B3E7C C9          0150**  			RET
0B3E7D             0151**  
0B3E7D             0152**  ; GETCSR: return cursor position in x=DE, y=HL
0B3E7D             0153**  ;
0B3E7D DD E5       0154**  GETCSR:			PUSH	IX			; Get the system vars in IX
0B3E7F             0155**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B3E7F 3E 08       0001**M 			LD	A, function
0B3E81 49 CF       0002**M 			RST.LIS	08h
0B3E83 DD CB 04 86 0156**  			RES	0, (IX+sysvar_vpd_pflags)
0B3E87             0157**  			VDU	23
0B3E87 3E 17       0001**M 		LD	A, val
0B3E89 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B3E8D             0158**  			VDU	0
0B3E8D 3E 00       0001**M 		LD	A, val
0B3E8F CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B3E93             0159**  			VDU	vdp_cursor
0B3E93 3E 82       0001**M 		LD	A, val
0B3E95 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B3E99 DD CB 04 46 0160**  @@:			BIT	0, (IX+sysvar_vpd_pflags)
0B3E9D 28 FA       0161**  			JR	Z, @B			; Wait for the result
0B3E9F 16 00       0162**  			LD 	D, 0
0B3EA1 62          0163**  			LD	H, D
0B3EA2 DD 5E 07    0164**  			LD	E, (IX + sysvar_cursorX)
0B3EA5 DD 6E 08    0165**  			LD	L, (IX + sysvar_cursorY)
0B3EA8 DD E1       0166**  			POP	IX
0B3EAA C9          0167**  			RET
0B3EAB             0168**  
0B3EAB             0169**  ; PROMPT: output the input prompt
0B3EAB             0170**  ;
0B3EAB 3E 3E       0171**  PROMPT: 		LD	A,'>'
0B3EAD C3 B1 3E 0B 0172**  			JP	OSWRCH
0B3EB1             0173**  
0B3EB1             0174**  ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
0B3EB1             0175**  ; A: Character to write
0B3EB1             0176**  ;
0B3EB1 E5          0177**  OSWRCH:			PUSH	HL
0B3EB2 21 40 4C 0B 0178**  			LD	HL, LISTON		; Fetch the LISTON variable
0B3EB6 CB 5E       0179**  			BIT	3, (HL)			; Check whether we are in *EDIT mode
0B3EB8 20 0B       0180**  			JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0B3EBA             0181**  ;
0B3EBA 2A 45 4C 0B 0182**  			LD	HL, (OSWRCHCH)		; L: Channel #
0B3EBE 2D          0183**  			DEC	L			; If it is 1
0B3EBF 28 10       0184**  			JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0B3EC1             0185**  ;
0B3EC1 E1          0186**  			POP	HL			; Otherwise
0B3EC2 5B D7       0187**  			RST.LIL	10h			; Output the character to MOS
0B3EC4 C9          0188**  			RET
0B3EC5             0189**  ;
0B3EC5 2A 43 4C 0B 0190**  OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0B3EC9 77          0191**  			LD	(HL), A			; Echo the character into the buffer
0B3ECA 23          0192**  			INC	HL			; Increment pointer
0B3ECB 22 43 4C 0B 0193**  			LD	(OSWRCHPT), HL		; Write pointer back
0B3ECF E1          0194**  			POP	HL
0B3ED0 C9          0195**  			RET
0B3ED1             0196**  ;
0B3ED1 D5          0197**  OSWRCH_FILE:		PUSH	DE
0B3ED2 5C          0198**  			LD	E, H			; Filehandle to E
0B3ED3 CD EC 42 0B 0199**  			CALL	OSBPUT			; Write the byte out
0B3ED7 D1          0200**  			POP	DE
0B3ED8 E1          0201**  			POP	HL
0B3ED9 C9          0202**  			RET
0B3EDA             0203**  
0B3EDA             0204**  ; OSRDCH: Read a character in from the ESP32 keyboard handler
0B3EDA             0205**  ; This is only called in GETS (eval.asm)
0B3EDA             0206**  ;
0B3EDA             0207**  OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0B3EDA 3E 00       0001**M 			LD	A, function
0B3EDC 49 CF       0002**M 			RST.LIS	08h
0B3EDE FE 1B       0208**  			CP	1Bh
0B3EE0 28 46       0209**  			JR	Z, LTRAP1
0B3EE2 C9          0210**  			RET
0B3EE3             0211**  
0B3EE3             0212**  
0B3EE3             0213**  ;OSKEY - Read key with time-limit, test for ESCape.
0B3EE3             0214**  ;Main function is carried out in user patch.
0B3EE3             0215**  ;   Inputs: HL = time limit (centiseconds)
0B3EE3             0216**  ;  Outputs: Carry reset if time-out
0B3EE3             0217**  ;           If carry set A = character
0B3EE3             0218**  ; Destroys: A,H,L,F
0B3EE3             0219**  ;
0B3EE3 CD 14 3F 0B 0220**  OSKEY:			CALL	READKEY			; Read the keyboard
0B3EE7 28 0A       0221**  			JR	Z, @F 			; Skip if we have a key
0B3EE9 7C          0222**  			LD	A, H 			; Check loop counter
0B3EEA B5          0223**  			OR 	L
0B3EEB C8          0224**  			RET 	Z 			; Return, we've not got a key at this point
0B3EEC CD EE 40 0B 0225**  			CALL	WAIT_VBLANK 		; Wait a frame
0B3EF0 2B          0226**  			DEC 	HL			; Decrement
0B3EF1 18 F0       0227**  			JR	OSKEY 			; And loop
0B3EF3             0228**  ;
0B3EF3 21 47 4C 0B 0229**  @@:			LD	HL, KEYDOWN		; We have a key, so
0B3EF7 36 00       0230**  			LD	(HL), 0			; clear the keydown flag
0B3EF9 FE 1B       0231**  			CP	1BH			; If we are not pressing ESC,
0B3EFB 37          0232**  			SCF 				; then flag we've got a character
0B3EFC C0          0233**  			RET	NZ
0B3EFD             0234**  ;
0B3EFD             0235**  ; ESCSET
0B3EFD             0236**  ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
0B3EFD             0237**  ;
0B3EFD E5          0238**  ESCSET: 		PUSH    HL
0B3EFE 21 42 4C 0B 0239**          		LD      HL,FLAGS		; Pointer to FLAGS
0B3F02 CB 76       0240**          		BIT     6,(HL)			; If bit 6 is set, then
0B3F04 20 02       0241**          		JR      NZ,ESCDIS		; escape is disabled, so skip
0B3F06 CB FE       0242**          		SET     7,(HL)			; Set bit 7, the escape flag
0B3F08 E1          0243**  ESCDIS: 		POP     HL
0B3F09 C9          0244**          		RET
0B3F0A             0245**  ;
0B3F0A             0246**  ; ESCTEST
0B3F0A             0247**  ; Test for ESC key
0B3F0A             0248**  ;
0B3F0A CD 14 3F 0B 0249**  ESCTEST:		CALL	READKEY			; Read the keyboard
0B3F0E C0          0250**  			RET	NZ			; Skip if no key is pressed
0B3F0F FE 1B       0251**  			CP	1BH			; If ESC pressed then
0B3F11 28 EA       0252**  			JR	Z,ESCSET		; jump to the escape set routine
0B3F13 C9          0253**  			RET
0B3F14             0254**  
0B3F14             0255**  ; Read the keyboard
0B3F14             0256**  ; Returns:
0B3F14             0257**  ; - A: ASCII of the pressed key
0B3F14             0258**  ; - F: Z if the key is pressed, otherwise NZ
0B3F14             0259**  ;
0B3F14 3A 47 4C 0B 0260**  READKEY:		LD	A, (KEYDOWN)		; Get key down
0B3F18 3D          0261**  			DEC	A 			; Set Z flag if keydown is 1
0B3F19 3A 48 4C 0B 0262**  			LD	A, (KEYASCII)		; Get key ASCII value
0B3F1D C9          0263**  			RET
0B3F1E             0264**  ;
0B3F1E             0265**  ; TRAP
0B3F1E             0266**  ; This is called whenever BASIC needs to check for ESC
0B3F1E             0267**  ;
0B3F1E CD 0A 3F 0B 0268**  TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
0B3F22             0269**  ;
0B3F22 3A 42 4C 0B 0270**  LTRAP:			LD	A,(FLAGS)		; Get FLAGS
0B3F26 B7          0271**  			OR	A			; This checks for bit 7; if it is not set then the result will
0B3F27 F0          0272**  			RET	P			; be positive (bit 7 is the sign bit in Z80), so return
0B3F28 21 42 4C 0B 0273**  LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
0B3F2C CB BE       0274**  			RES	7,(HL)			; Clear the escape pressed flag and
0B3F2E C3 4C 0C 0B 0275**  			JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
0B3F32             0276**  
0B3F32             0277**  ;OSINIT - Initialise RAM mapping etc.
0B3F32             0278**  ;If BASIC is entered by BBCBASIC FILENAME then file
0B3F32             0279**  ;FILENAME.BBC is automatically CHAINed.
0B3F32             0280**  ;   Outputs: DE = initial value of HIMEM (top of RAM)
0B3F32             0281**  ;            HL = initial value of PAGE (user program)
0B3F32             0282**  ;            Z-flag reset indicates AUTO-RUN.
0B3F32             0283**  ;  Destroys: A,D,E,H,L,F
0B3F32             0284**  ;
0B3F32 CD 91 48 0B 0285**  OSINIT:			CALL	VBLANK_INIT
0B3F36 AF          0286**  			XOR	A
0B3F37 21 00 4D 0B 0287**  			LD 	HL, USER
0B3F3B 11 00 00 0B 0288**  			LD	DE, RAM_Top
0B3F3F 5F          0289**  			LD	E, A			; Page boundary
0B3F40 C9          0290**  			RET
0B3F41             0291**  
0B3F41             0292**  ;
0B3F41             0293**  ;OSCLI - Process a MOS command
0B3F41             0294**  ;
0B3F41 CD B5 3F 0B 0295**  OSCLI: 			CALL    SKIPSP
0B3F45 FE 0D       0296**  			CP      CR
0B3F47 C8          0297**  			RET     Z
0B3F48 FE 7C       0298**  			CP      '|'
0B3F4A C8          0299**  			RET     Z
0B3F4B EB          0300**  			EX      DE,HL
0B3F4C 21 C4 3F 0B 0301**  			LD      HL,COMDS
0B3F50 1A          0302**  OSCLI0:			LD      A,(DE)
0B3F51 CD BC 3F 0B 0303**  			CALL    UPPRC
0B3F55 BE          0304**  			CP      (HL)
0B3F56 28 0B       0305**  			JR      Z,OSCLI2
0B3F58 38 30       0306**  			JR      C,OSCLI6
0B3F5A CB 7E       0307**  OSCLI1:			BIT     7,(HL)
0B3F5C 23          0308**  			INC     HL
0B3F5D 28 FB       0309**  			JR      Z,OSCLI1
0B3F5F 23          0310**  			INC     HL
0B3F60 23          0311**  			INC     HL
0B3F61 18 ED       0312**  			JR      OSCLI0
0B3F63             0313**  ;
0B3F63 D5          0314**  OSCLI2:			PUSH    DE
0B3F64 13          0315**  OSCLI3:			INC     DE
0B3F65 23          0316**  			INC     HL
0B3F66 1A          0317**  			LD      A,(DE)
0B3F67 CD BC 3F 0B 0318**  			CALL    UPPRC
0B3F6B FE 2E       0319**  			CP      '.'			; ABBREVIATED?
0B3F6D 28 0A       0320**  			JR      Z,OSCLI4
0B3F6F AE          0321**  			XOR     (HL)
0B3F70 28 F2       0322**  			JR      Z,OSCLI3
0B3F72 FE 80       0323**  			CP      80H
0B3F74 28 03       0324**  			JR      Z,OSCLI4
0B3F76 D1          0325**  			POP     DE
0B3F77 18 E1       0326**  			JR      OSCLI1
0B3F79             0327**  ;
0B3F79 F1          0328**  OSCLI4:			POP     AF
0B3F7A 13          0329**  		        INC     DE
0B3F7B CB 7E       0330**  OSCLI5:			BIT     7,(HL)
0B3F7D 23          0331**  			INC     HL
0B3F7E 28 FB       0332**  			JR      Z,OSCLI5
0B3F80 7E          0333**  			LD      A,(HL)
0B3F81 23          0334**  			INC     HL
0B3F82 66          0335**  			LD      H,(HL)
0B3F83 6F          0336**  			LD      L,A
0B3F84 E5          0337**  			PUSH    HL
0B3F85 EB          0338**  			EX      DE,HL
0B3F86 C3 B5 3F 0B 0339**  			JP      SKIPSP
0B3F8A             0340**  ;
0B3F8A EB          0341**  OSCLI6:			EX	DE, HL			; HL: Buffer for command
0B3F8B 11 00 49 0B 0342**  			LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0B3F8F D5          0343**  			PUSH	DE			; Store buffer address
0B3F90 CD DC 3D 0B 0344**  			CALL	CSTR_LINE		; Fetch the line
0B3F94 E1          0345**  			POP	HL			; HL: Pointer to command string in ACCS
0B3F95 FD E5       0346**  			PUSH	IY
0B3F97             0347**  			MOSCALL	mos_oscli		; Returns OSCLI error in A
0B3F97 3E 10       0001**M 			LD	A, function
0B3F99 49 CF       0002**M 			RST.LIS	08h
0B3F9B FD E1       0348**  			POP	IY
0B3F9D B7          0349**  			OR	A			; 0 means MOS returned OK
0B3F9E C8          0350**  			RET	Z			; So don't do anything
0B3F9F C3 C8 41 0B 0351**  			JP 	OSERROR			; Otherwise it's a MOS error
0B3FA3             0352**  
0B3FA3 3E FE       0353**  HUH:    		LD      A,254			; Bad command error
0B3FA5 CD 28 37 0B 0354**          		CALL    EXTERR
0B3FA9 42 61 64 20 0355**          		DB    	"Bad command"
       63 6F 6D 6D 
       61 6E 64    
0B3FB4 00          0356**          		DEFB    0
0B3FB5             0357**  
0B3FB5 7E          0358**  SKIPSP:			LD      A,(HL)
0B3FB6 FE 20       0359**          		CP      ' '
0B3FB8 C0          0360**          		RET     NZ
0B3FB9 23          0361**          		INC     HL
0B3FBA 18 F9       0362**          		JR      SKIPSP
0B3FBC             0363**  
0B3FBC E6 7F       0364**  UPPRC:  		AND     7FH
0B3FBE FE 60       0365**  			CP      '`'
0B3FC0 D8          0366**  			RET     C
0B3FC1 E6 5F       0367**  			AND     5FH			; CONVERT TO UPPER CASE
0B3FC3 C9          0368**  			RET
0B3FC4             0369**  
0B3FC4             0370**  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0B3FC4             0371**  ; These must be in alphabetical order
0B3FC4             0372**  ;
0B3FC4             0373**  ; BEGIN NOT FOUND IN BINARY
0B3FC4             0374**  ; COMDS:  		DB	"AS","M"+80h		; ASM
0B3FC4             0375**  ; 			DW	STAR_ASM
0B3FC4             0376**  ; 			DB	"BY","E"+80h		; BYE
0B3FC4             0377**  ; 			DW	STAR_BYE
0B3FC4             0378**  ; 			DB	"EDI","T"+80h		; EDIT
0B3FC4             0379**  ; 			DW	STAR_EDIT
0B3FC4             0380**  ; 			DB	"F","X"+80h		; FX
0B3FC4             0381**  ; 			DW	STAR_FX
0B3FC4             0382**  ; 			DB	"VERSIO","N"+80h	; VERSION
0B3FC4             0383**  ; 			DW	STAR_VERSION
0B3FC4             0384**  ; 			DB	FFh
0B3FC4             0385**  ; END NOT FOUND IN BINARY
0B3FC4             0386**  ; BEGIN INSERTED FROM BINARY
0B3FC4             0387**  ; Each command has bit 7 of the last character set, and is followed by the address of the handler
0B3FC4             0388**  ; These must be in alphabetical order
0B3FC4             0389**  ;
0B3FC4             0390**  COMDS:
0B3FC4 42          0391**  	db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
0B3FC5 59          0392**  	db 0x59 ; 044014
0B3FC6 C5          0393**  	db 0xc5 ; 044015
0B3FC7 2C          0394**  	db 0x2c ; 044016 31     11405 DW	STAR_ASM
0B3FC8 40          0395**  	db 0x40 ; 044017
0B3FC9 45          0396**  	db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
0B3FCA 44          0397**  	db 0x44 ; 044019
0B3FCB 49          0398**  	db 0x49 ; 04401A
0B3FCC D4          0399**  	db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
0B3FCD 61          0400**  	db 0x61 ; 04401C
0B3FCE 40          0401**  	db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
0B3FCF 46          0402**  	db 0x46 ; 04401E
0B3FD0 D8          0403**  	db 0xd8 ; 04401F
0B3FD1 A1          0404**  	db 0xa1 ; 044020
0B3FD2 40          0405**  	db 0x40 ; 044021 72     11409 DW	STAR_EDIT
0B3FD3 56          0406**  	db 0x56 ; 044022
0B3FD4 45          0407**  	db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
0B3FD5 52          0408**  	db 0x52 ; 044024
0B3FD6 53          0409**  	db 0x53 ; 044025 B2     11411 DW	STAR_FX
0B3FD7 49          0410**  	db 0x49 ; 044026
0B3FD8 4F          0411**  	db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
0B3FD9 CE          0412**  	db 0xce ; 044028
0B3FDA 38          0413**  	db 0x38 ; 044029
0B3FDB 40          0414**  	db 0x40 ; 04402A
0B3FDC FF          0415**  	db 0xff ; 04402B
0B3FDD             0416**  ; END INSERTED FROM BINARY
0B3FDD             0417**  
0B3FDD             0418**  ; BEGIN NOT FOUND IN BINARY
0B3FDD             0419**  ; ; *ASM string
0B3FDD             0420**  ; ;
0B3FDD             0421**  ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
0B3FDD             0422**  ; 			PUSH	HL			; HL = IY
0B3FDD             0423**  ; 			POP	IY
0B3FDD             0424**  ; 			CALL	ASSEM			; Invoke the assembler
0B3FDD             0425**  ; 			POP	IY
0B3FDD             0426**  ; 			RET
0B3FDD             0427**  ; END NOT FOUND IN BINARY
0B3FDD             0428**  
0B3FDD             0429**  ; *BYE
0B3FDD             0430**  ;
0B3FDD CD A5 48 0B 0431**  STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
0B3FE1 21 00 00 00 0432**  			LD	HL, 0			; The return value
0B3FE5 C3 69 4D 0B 0433**  			JP	_basic_end 			; Jump back to the end routine in init.asm
0B3FE9             0434**  
0B3FE9             0435**  ; *VERSION
0B3FE9             0436**  ;
0B3FE9 CD 41 3D 0B 0437**  STAR_VERSION:		CALL    TELL			; Output the welcome message
0B3FED 42 42 43 20 0438**  			DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
       42 41 53 49 
       43 20 28 41 
       67 6F 6E 20 
       41 44 4C 29 
       20 56 65 72 
       73 69 6F 6E 
       20 31 2E 30 
       33 0A 0D 00 
0B4011 C9          0439**  			RET
0B4012             0440**  
0B4012             0441**  ; *EDIT linenum
0B4012             0442**  ;
0B4012 CD 48 3D 0B 0443**  STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0B4016 EB          0444**  			EX	DE, HL			; HL: Line number
0B4017 CD 40 39 0B 0445**  			CALL	FINDL			; HL: Address in RAM of tokenised line
0B401B 3E 29       0446**  			LD	A, 41			; F:NZ If the line is not found
0B401D C2 11 37 0B 0447**  			JP	NZ, ERROR_		; Do error 41: No such line in that case
0B4021             0448**  ;
0B4021             0449**  ; Use LISTIT to output the line to the ACCS buffer
0B4021             0450**  ;
0B4021 23          0451**  			INC	HL			; Skip the length byte
0B4022 5E          0452**  			LD	E, (HL)			; Fetch the line number
0B4023 23          0453**  			INC	HL
0B4024 56          0454**  			LD	D, (HL)
0B4025 23          0455**  			INC	HL
0B4026 DD 21 00 49 0456**  			LD	IX, ACCS		; Pointer to where the copy is to be stored
       0B          
0B402B DD 22 43 4C 0457**  			LD	(OSWRCHPT), IX
       0B          
0B4030 DD 21 40 4C 0458**  			LD	IX, LISTON		; Pointer to LISTON variable in RAM
       0B          
0B4035 DD 7E 00    0459**  			LD	A, (IX)			; Store that variable
0B4038 F5          0460**  			PUSH	AF
0B4039 DD 36 00 09 0461**  			LD	(IX), 09h		; Set to echo to buffer
0B403D CD 43 38 0B 0462**  			CALL	LISTIT
0B4041 F1          0463**  			POP	AF
0B4042 DD 77 00    0464**  			LD	(IX), A			; Restore the original LISTON variable
0B4045 21 00 49 0B 0465**  			LD	HL, ACCS		; HL: ACCS
0B4049 5D          0466**  			LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0B404A CD 12 3E 0B 0467**  			CALL	OSLINE1			; Invoke the editor
0B404E C3 81 30 0B 0468**  			JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0B4052             0469**  
0B4052             0470**  ; OSCLI FX n
0B4052             0471**  ;
0B4052 CD 48 3D 0B 0472**  STAR_FX:		CALL	ASC_TO_NUMBER
0B4056 4B          0473**  			LD	C, E			; C: Save FX #
0B4057 CD 48 3D 0B 0474**  			CALL	ASC_TO_NUMBER
0B405B 7A          0475**  			LD	A, D  			; Is first parameter > 255?
0B405C B7          0476**  			OR 	A
0B405D 28 03       0477**  			JR	Z, STAR_FX1		; Yes, so skip next bit
0B405F EB          0478**  			EX	DE, HL 			; Parameter is 16-bit
0B4060 18 07       0479**  			JR	STAR_FX2
0B4062             0480**  ;
0B4062 43          0481**  STAR_FX1:		LD	B, E 			; B: Save First parameter
0B4063 CD 48 3D 0B 0482**  			CALL	ASC_TO_NUMBER		; Fetch second parameter
0B4067 68          0483**  			LD	L, B 			; L: First parameter
0B4068 63          0484**  			LD	H, E 			; H: Second parameter
0B4069             0485**  ;
0B4069 79          0486**  STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
0B406A             0487**  ;
0B406A             0488**  ; OSBYTE
0B406A             0489**  ;  A: FX #
0B406A             0490**  ;  L: First parameter
0B406A             0491**  ;  H: Second parameter
0B406A             0492**  ;
0B406A FE 0B       0493**  OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0B406C 28 18       0494**  			JR	Z, OSBYTE_0B
0B406E FE 0C       0495**  			CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0B4070 28 43       0496**  			JR	Z, OSBYTE_0C
0B4072 FE 13       0497**  			CP	13H			; *FX 19: Wait for vblank
0B4074 28 6E       0498**  			JR	Z, OSBYTE_13
0B4076 FE 76       0499**  			CP	76H			; *FX 118, n: Set keyboard LED
0B4078 CA FF 40 0B 0500**  			JP	Z, OSBYTE_76
0B407C FE A0       0501**  			CP	A0H
0B407E CA 2F 41 0B 0502**  			JP	Z, OSBYTE_A0
0B4082 C3 A3 3F 0B 0503**  			JP	HUH			; Anything else trips an error
0B4086             0504**  
0B4086             0505**  ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
0B4086             0506**  ; Parameters:
0B4086             0507**  ; - HL: Repeat delay
0B4086             0508**  ;
0B4086             0509**  OSBYTE_0B:		VDU	23
0B4086 3E 17       0001**M 		LD	A, val
0B4088 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B408C             0510**  			VDU	0
0B408C 3E 00       0001**M 		LD	A, val
0B408E CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4092             0511**  			VDU	vdp_keystate
0B4092 3E 88       0001**M 		LD	A, val
0B4094 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4098             0512**  			VDU	L
0B4098 7D          0001**M 		LD	A, val
0B4099 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B409D             0513**  			VDU	H
0B409D 7C          0001**M 		LD	A, val
0B409E CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40A2             0514**  			VDU	0
0B40A2 3E 00       0001**M 		LD	A, val
0B40A4 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40A8             0515**  			VDU 	0
0B40A8 3E 00       0001**M 		LD	A, val
0B40AA CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40AE             0516**  			VDU	255
0B40AE 3E FF       0001**M 		LD	A, val
0B40B0 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40B4 C9          0517**  			RET
0B40B5             0518**  
0B40B5             0519**  ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
0B40B5             0520**  ; Parameters:
0B40B5             0521**  ; - HL: Repeat rate
0B40B5             0522**  ;
0B40B5             0523**  OSBYTE_0C:		VDU	23
0B40B5 3E 17       0001**M 		LD	A, val
0B40B7 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40BB             0524**  			VDU	0
0B40BB 3E 00       0001**M 		LD	A, val
0B40BD CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40C1             0525**  			VDU	vdp_keystate
0B40C1 3E 88       0001**M 		LD	A, val
0B40C3 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40C7             0526**  			VDU	0
0B40C7 3E 00       0001**M 		LD	A, val
0B40C9 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40CD             0527**  			VDU 	0
0B40CD 3E 00       0001**M 		LD	A, val
0B40CF CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40D3             0528**  			VDU	L
0B40D3 7D          0001**M 		LD	A, val
0B40D4 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40D8             0529**  			VDU	H
0B40D8 7C          0001**M 		LD	A, val
0B40D9 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40DD             0530**  			VDU	255
0B40DD 3E FF       0001**M 		LD	A, val
0B40DF CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B40E3 C9          0531**  			RET
0B40E4             0532**  
0B40E4             0533**  ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
0B40E4             0534**  ;
0B40E4 CD EE 40 0B 0535**  OSBYTE_13:		CALL	WAIT_VBLANK
0B40E8 2E 00       0536**  			LD	L, 0			; Returns 0
0B40EA C3 30 05 0B 0537**  			JP	COUNT0
0B40EE             0538**  ;
0B40EE DD E5       0539**  WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0B40F0             0540**  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B40F0 3E 08       0001**M 			LD	A, function
0B40F2 49 CF       0002**M 			RST.LIS	08h
0B40F4 DD 7E 00    0541**  			LD	A, (IX + sysvar_time + 0)
0B40F7 DD BE 00    0542**  @@:			CP 	A, (IX + sysvar_time + 0)
0B40FA 28 FB       0543**  			JR	Z, @B
0B40FC DD E1       0544**  			POP	IX
0B40FE C9          0545**  			RET
0B40FF             0546**  
0B40FF             0547**  ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
0B40FF             0548**  ; Parameters:
0B40FF             0549**  ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
0B40FF             0550**  ;
0B40FF             0551**  OSBYTE_76:		VDU	23
0B40FF 3E 17       0001**M 		LD	A, val
0B4101 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4105             0552**  			VDU	0
0B4105 3E 00       0001**M 		LD	A, val
0B4107 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B410B             0553**  			VDU	vdp_keystate
0B410B 3E 88       0001**M 		LD	A, val
0B410D CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4111             0554**  			VDU	0
0B4111 3E 00       0001**M 		LD	A, val
0B4113 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4117             0555**  			VDU 	0
0B4117 3E 00       0001**M 		LD	A, val
0B4119 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B411D             0556**  			VDU	0
0B411D 3E 00       0001**M 		LD	A, val
0B411F CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4123             0557**  			VDU	0
0B4123 3E 00       0001**M 		LD	A, val
0B4125 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4129             0558**  			VDU	L
0B4129 7D          0001**M 		LD	A, val
0B412A CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B412E C9          0559**  			RET
0B412F             0560**  
0B412F             0561**  ; OSBYTE 0xA0: Fetch system variable
0B412F             0562**  ; Parameters:
0B412F             0563**  ; - L: The system variable to fetch
0B412F             0564**  ;
0B412F DD E5       0565**  OSBYTE_A0:		PUSH	IX
0B4131             0566**  			MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B4131 3E 08       0001**M 			LD	A, function
0B4133 49 CF       0002**M 			RST.LIS	08h
0B4135 01 00 00 00 0567**  			LD	BC, 0
0B4139 4D          0568**  			LD	C, L			; BCU = L
0B413A DD 09       0569**  			ADD	IX, BC			; Add to IX
0B413C DD 6E 00    0570**  			LD	L, (IX + 0)		; Fetch the return value
0B413F DD E1       0571**  			POP	IX
0B4141 C3 30 05 0B 0572**  			JP 	COUNT0
0B4145             0573**  
0B4145             0574**  ;OSLOAD - Load an area of memory from a file.
0B4145             0575**  ;   Inputs: HL addresses filename (CR terminated)
0B4145             0576**  ;           DE = address at which to load
0B4145             0577**  ;           BC = maximum allowed size (bytes)
0B4145             0578**  ;  Outputs: Carry reset indicates no room for file.
0B4145             0579**  ; Destroys: A,B,C,D,E,H,L,F
0B4145             0580**  ;
0B4145 C5          0581**  OSLOAD:			PUSH	BC			; Stack the size
0B4146 D5          0582**  			PUSH	DE			; Stack the load address
0B4147 11 00 49 0B 0583**  			LD	DE, ACCS		; Buffer address for filename
0B414B CD CA 3D 0B 0584**  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B414F 21 00 49 0B 0585**  			LD	HL, ACCS		; HL: Filename
0B4153 CD 45 42 0B 0586**  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B4157 CD 59 42 0B 0587**  			CALL	EXT_HANDLER		; Get the default handler
0B415B D1          0588**  			POP	DE			; Restore the load address
0B415C C1          0589**  			POP	BC			; Restore the size
0B415D B7          0590**  			OR	A
0B415E 28 60       0591**  			JR 	Z, OSLOAD_BBC
0B4160             0592**  ;
0B4160             0593**  ; Load the file in as a text file
0B4160             0594**  ;
0B4160 AF          0595**  OSLOAD_TXT:		XOR	A			; Set file attributes to read
0B4161 CD CD 42 0B 0596**  			CALL	OSOPEN			; Open the file
0B4165 5F          0597**  			LD 	E, A 			; The filehandle
0B4166 B7          0598**  			OR	A
0B4167 3E 04       0599**  			LD	A, 4			; File not found error
0B4169 28 5D       0600**  			JR	Z, OSERROR		; Jump to error handler
0B416B CD 1D 38 0B 0601**  			CALL	NEWIT			; Call NEW to clear the program space
0B416F             0602**  ;
0B416F 21 00 49 0B 0603**  OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0B4173             0604**  ;
0B4173             0605**  ; First skip any whitespace (indents) at the beginning of the input
0B4173             0606**  ;
0B4173 CD E4 42 0B 0607**  @@:			CALL	OSBGET			; Read the byte into A
0B4177 38 1E       0608**  			JR	C, OSLOAD_TXT3		; Is it EOF?
0B4179 FE 0A       0609**  			CP	LF 			; Is it LF?
0B417B 28 1A       0610**  			JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0B417D FE 21       0611**  			CP	21h			; Is it less than or equal to ASCII space?
0B417F 38 F2       0612**  			JR	C, @B 			; Yes, so keep looping
0B4181 77          0613**  			LD	(HL), A 		; Store the first character
0B4182 2C          0614**  			INC	L
0B4183             0615**  ;
0B4183             0616**  ; Now read the rest of the line in
0B4183             0617**  ;
0B4183 CD E4 42 0B 0618**  OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0B4187 38 2B       0619**  			JR	C, OSLOAD_TXT4		; Is it EOF?
0B4189 FE 20       0620**  			CP	20h			; Skip if not an ASCII character
0B418B 38 06       0621**  			JR	C, @F
0B418D 77          0622**  			LD	(HL), A 		; Store in the input buffer
0B418E 2C          0623**  			INC	L			; Increment the buffer pointer
0B418F CA A9 36 0B 0624**  			JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0B4193 FE 0A       0625**  @@:			CP	LF			; Check for LF
0B4195 20 EC       0626**  			JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0B4197             0627**  ;
0B4197             0628**  ; Finally, handle EOL/EOF
0B4197             0629**  ;
0B4197 36 0D       0630**  OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0B4199 7D          0631**  			LD	A, L			; Check for minimum line length
0B419A FE 02       0632**  			CP	2			; If it is 2 characters or less (including CR)
0B419C 38 0A       0633**  			JR	C, @F			; Then don't bother entering it
0B419E D5          0634**  			PUSH	DE			; Preserve the filehandle
0B419F CD 8D 30 0B 0635**  			CALL	ONEDIT1			; Enter the line in memory
0B41A3 DC F0 37 0B 0636**  			CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0B41A7 D1          0637**  			POP	DE
0B41A8 CD F5 42 0B 0638**  @@:			CALL	OSSTAT			; End of file?
0B41AC 20 C1       0639**  			JR	NZ, OSLOAD_TXT1		; No, so loop
0B41AE CD DC 42 0B 0640**  			CALL	OSSHUT			; Close the file
0B41B2 37          0641**  			SCF				; Flag to BASIC that we're good
0B41B3 C9          0642**  			RET
0B41B4             0643**  ;
0B41B4             0644**  ; Special case for BASIC programs with no blank line at the end
0B41B4             0645**  ;
0B41B4 FE 20       0646**  OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0B41B6 38 06       0647**  			JR	C, @F
0B41B8 77          0648**  			LD	(HL), A			; Store the character
0B41B9 2C          0649**  			INC	L
0B41BA CA A9 36 0B 0650**  			JP	Z, BAD
0B41BE 18 D7       0651**  @@:			JR	OSLOAD_TXT3
0B41C0             0652**  
0B41C0             0653**  ;
0B41C0             0654**  ; Load the file in as a tokenised binary blob
0B41C0             0655**  ;
0B41C0             0656**  OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0B41C0 3E 01       0001**M 			LD	A, function
0B41C2 49 CF       0002**M 			RST.LIS	08h
0B41C4 D0          0657**  			RET	NC			; If load returns with carry reset - NO ROOM
0B41C5 B7          0658**  			OR	A			; If there is no error (A=0)
0B41C6 37          0659**  			SCF				; Need to set carry indicating there was room
0B41C7 C8          0660**  			RET	Z			; Return
0B41C8             0661**  ;
0B41C8 F5          0662**  OSERROR:		PUSH	AF			; Handle the MOS error
0B41C9 21 00 49 0B 0663**  			LD	HL, ACCS		; Address of the buffer
0B41CD 01 00 01 00 0664**  			LD	BC, 256			; Length of the buffer
0B41D1 5F          0665**  			LD	E, A			; The error code
0B41D2             0666**  			MOSCALL	mos_getError		; Copy the error message into the buffer
0B41D2 3E 0F       0001**M 			LD	A, function
0B41D4 49 CF       0002**M 			RST.LIS	08h
0B41D6 F1          0667**  			POP	AF
0B41D7 E5          0668**  			PUSH	HL			; Stack the address of the error (now in ACCS)
0B41D8 C6 7F       0669**  			ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0B41DA C3 28 37 0B 0670**  			JP	EXTERR			; Trigger an external error
0B41DE             0671**  
0B41DE             0672**  ;OSSAVE - Save an area of memory to a file.
0B41DE             0673**  ;   Inputs: HL addresses filename (term CR)
0B41DE             0674**  ;           DE = start address of data to save
0B41DE             0675**  ;           BC = length of data to save (bytes)
0B41DE             0676**  ; Destroys: A,B,C,D,E,H,L,F
0B41DE             0677**  ;
0B41DE C5          0678**  OSSAVE:			PUSH	BC			; Stack the size
0B41DF D5          0679**  			PUSH	DE			; Stack the save address
0B41E0 11 00 49 0B 0680**  			LD	DE, ACCS		; Buffer address for filename
0B41E4 CD CA 3D 0B 0681**  			CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B41E8 21 00 49 0B 0682**  			LD	HL, ACCS		; HL: Filename
0B41EC CD 45 42 0B 0683**  			CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B41F0 CD 59 42 0B 0684**  			CALL	EXT_HANDLER		; Get the default handler
0B41F4 D1          0685**  			POP	DE			; Restore the save address
0B41F5 C1          0686**  			POP	BC			; Restore the size
0B41F6 B7          0687**  			OR	A			; Is the extension .BBC
0B41F7 28 44       0688**  			JR	Z, OSSAVE_BBC		; Yes, so use that
0B41F9             0689**  ;
0B41F9             0690**  ; Save the file out as a text file
0B41F9             0691**  ;
0B41F9 3A 45 4C 0B 0692**  OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0B41FD F5          0693**  			PUSH	AF
0B41FE AF          0694**  			XOR	A
0B41FF 3C          0695**  			INC	A			; Make sure C is clear, A is 1, for OPENOUT
0B4200 32 45 4C 0B 0696**  			LD	(OSWRCHCH), A
0B4204 CD CD 42 0B 0697**  			CALL	OSOPEN			; Open the file
0B4208 32 46 4C 0B 0698**  			LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0B420C DD 21 40 4C 0699**  			LD	IX, LISTON		; Required for LISTIT
       0B          
0B4211 2A 14 4C 0B 0700**  			LD	HL, (PAGE_)		; Get start of program area
0B4215 D9          0701**  			EXX
0B4216 01 00 00 00 0702**  			LD	BC, 0			; Set the initial indent counters
0B421A D9          0703**  			EXX
0B421B 7E          0704**  OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0B421C B7          0705**  			OR	A
0B421D 28 0F       0706**  			JR	Z, OSSAVE_TXT2
0B421F 23          0707**  			INC	HL			; Skip the length byte
0B4220 11 00 00 00 0708**  			LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0B4224 5E          0709**  			LD	E, (HL)			; Get the line number
0B4225 23          0710**  			INC	HL
0B4226 56          0711**  			LD	D, (HL)
0B4227 23          0712**  			INC	HL
0B4228 CD 43 38 0B 0713**  			CALL	LISTIT			; List the line
0B422C 18 ED       0714**  			JR	OSSAVE_TXT1
0B422E 3A 46 4C 0B 0715**  OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0B4232 5F          0716**  			LD	E, A
0B4233 CD DC 42 0B 0717**  			CALL	OSSHUT			; Close it
0B4237 F1          0718**  			POP	AF			; Restore the channel
0B4238 32 45 4C 0B 0719**  			LD	(OSWRCHCH), A
0B423C C9          0720**  			RET
0B423D             0721**  ;
0B423D             0722**  ; Save the file out as a tokenised binary blob
0B423D             0723**  ;
0B423D             0724**  OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0B423D 3E 02       0001**M 			LD	A, function
0B423F 49 CF       0002**M 			RST.LIS	08h
0B4241 B7          0725**  			OR	A			; If there is no error (A=0)
0B4242 C8          0726**  			RET	Z			; Just return
0B4243 18 83       0727**  			JR	OSERROR			; Trip an error
0B4245             0728**  
0B4245             0729**  ; Check if an extension is specified in the filename
0B4245             0730**  ; Add a default if not specified
0B4245             0731**  ; HL: Filename (CSTR format)
0B4245             0732**  ;
0B4245 E5          0733**  EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0B4246 0E 2E       0734**  			LD	C, '.'			; Search for dot (marks start of extension)
0B4248 CD EA 3D 0B 0735**  			CALL	CSTR_FINDCH
0B424C B7          0736**  			OR	A			; Check for end of string marker
0B424D 20 08       0737**  			JR	NZ, @F			; No, so skip as we have an extension at this point
0B424F 11 89 42 0B 0738**  			LD	DE, EXT_LOOKUP		; Get the first (default extension)
0B4253 CD 01 3E 0B 0739**  			CALL	CSTR_CAT		; Concat it to string pointed to by HL
0B4257 E1          0740**  @@:			POP	HL			; Restore the filename pointer
0B4258 C9          0741**  			RET
0B4259             0742**  
0B4259             0743**  ; Check if an extension is valid and, if so, provide a pointer to a handler
0B4259             0744**  ; HL: Filename (CSTR format)
0B4259             0745**  ; Returns:
0B4259             0746**  ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
0B4259             0747**  ;
0B4259 E5          0748**  EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0B425A 0E 2E       0749**  			LD	C, '.'			; Find the '.'
0B425C CD EA 3D 0B 0750**  			CALL	CSTR_FINDCH
0B4260 11 89 42 0B 0751**  			LD	DE, EXT_LOOKUP		; The lookup table
0B4264             0752**  ;
0B4264 E5          0753**  EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0B4265 CD F2 3D 0B 0754**  			CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0B4269 E1          0755**  			POP	HL			; Restore the pointer to the extension
0B426A 28 19       0756**  			JR	Z, EXT_HANDLER_2	; We have a match!
0B426C             0757**  ;
0B426C 1A          0758**  @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0B426D 13          0759**  			INC	DE
0B426E B7          0760**  			OR	A
0B426F 20 FB       0761**  			JR	NZ, @B
0B4271 13          0762**  			INC	DE			; Skip the file extension # byte
0B4272             0763**  ;
0B4272 1A          0764**  			LD	A, (DE)			; Are we at the end of the table?
0B4273 B7          0765**  			OR	A
0B4274 20 EE       0766**  			JR	NZ, EXT_HANDLER_1	; No, so loop
0B4276             0767**  ;
0B4276 3E CC       0768**  			LD      A,204			; Throw a "Bad name" error
0B4278 CD 28 37 0B 0769**          		CALL    EXTERR
0B427C 42 61 64 20 0770**          		DB    	"Bad name", 0
       6E 61 6D 65 
       00          
0B4285             0771**  ;
0B4285 13          0772**  EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0B4286 1A          0773**  			LD	A, (DE)
0B4287 E1          0774**  			POP	HL			; Restore the filename pointer
0B4288 C9          0775**  			RET
0B4289             0776**  ;
0B4289             0777**  
0B4289             0778**  
0B4289             0779**  ; Extension lookup table
0B4289             0780**  ; CSTR, TYPE
0B4289             0781**  ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
0B4289             0782**  ; 	- 1: Human readable plain text
0B4289             0783**  ;
0B4289 2E 42 42 43 0784**  EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
       00 00       
0B428F 2E 54 58 54 0785**  			DB	".TXT", 0, 1
       00 01       
0B4295 2E 41 53 43 0786**  			DB	".ASC", 0, 1
       00 01       
0B429B 2E 42 41 53 0787**  			DB	".BAS", 0, 1
       00 01       
0B42A1 00          0788**  			DB	0			; End of table
0B42A2             0789**  
0B42A2             0790**  ;OSCALL - Intercept page &FF calls and provide an alternative address
0B42A2             0791**  ;
0B42A2             0792**  ;&FFF7:	OSCLI	Execute *command.
0B42A2             0793**  ;&FFF4:	OSBYTE	Various byte-wide functions.
0B42A2             0794**  ;&FFF1:	OSWORD	Various control block functions.
0B42A2             0795**  ;&FFEE:	OSWRCH	Write character to output stream.
0B42A2             0796**  ;&FFE7:	OSNEWL	Write NewLine to output stream.
0B42A2             0797**  ;&FFE3:	OSASCI	Write character or NewLine to output stream.
0B42A2             0798**  ;&FFE0:	OSRDCH	Wait for character from input stream.
0B42A2             0799**  ;&FFDD:	OSFILE	Perform actions on whole files or directories.
0B42A2             0800**  ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
0B42A2             0801**  ;&FFD7:	OSBGET	Read a byte from an a channel.
0B42A2             0802**  ;&FFD4:	OSBPUT	Write a byte to a channel.
0B42A2             0803**  ;&FFD1:	OSGBPB	Read and write blocks of data.
0B42A2             0804**  ;&FFCE:	OSFIND	Open or close a file.
0B42A2             0805**  ;
0B42A2 21 B8 42 0B 0806**  OSCALL:			LD	HL, OSCALL_TABLE
0B42A6 7E          0807**  OSCALL_1:		LD	A, (HL)
0B42A7 23          0808**  			INC	HL
0B42A8 FE FF       0809**  			CP	FFh
0B42AA C8          0810**  			RET	Z
0B42AB FD BD       0811**  			CP	A, IYL
0B42AD 28 06       0812**  			JR	Z, OSCALL_2
0B42AF D0          0813**  			RET	NC
0B42B0 23          0814**  			INC	HL
0B42B1 23          0815**  			INC	HL
0B42B2 23          0816**  			INC	HL
0B42B3 18 F1       0817**  			JR	OSCALL_1
0B42B5 ED 31       0818**  OSCALL_2:		LD	IY,(HL)
0B42B7 C9          0819**  			RET
0B42B8 D4          0820**  OSCALL_TABLE:		DB 	D4h
0B42B9 EC 42 0B    0821**  			DW24 	OSBPUT
0B42BC D7          0822**  			DB 	D7h
0B42BD E4 42 0B    0823**  			DW24 	OSBGET
0B42C0 EE          0824**  			DB 	EEh
0B42C1 B1 3E 0B    0825**  			DW24 	OSWRCH
0B42C4 F4          0826**  			DB	F4h
0B42C5 6A 40 0B    0827**  			DW24 	OSBYTE
0B42C8 F7          0828**  			DB	F7h
0B42C9 41 3F 0B    0829**  			DW24	OSCLI
0B42CC FF          0830**  			DB	FFh
0B42CD             0831**  
0B42CD             0832**  ; OSOPEN
0B42CD             0833**  ; HL: Pointer to path
0B42CD             0834**  ;  F: C Z
0B42CD             0835**  ;     x x OPENIN
0B42CD             0836**  ; 	  OPENOUT
0B42CD             0837**  ;     x	  OPENUP
0B42CD             0838**  ; Returns:
0B42CD             0839**  ;  A: Filehandle, 0 if cannot open
0B42CD             0840**  ;
0B42CD 0E 01       0841**  OSOPEN:			LD	C, fa_read
0B42CF 28 06       0842**  			JR	Z, @F
0B42D1 0E 32       0843**  			LD	C, fa_write | fa_open_append
0B42D3 38 02       0844**  			JR	C, @F
0B42D5 0E 0A       0845**  			LD	C, fa_write | fa_create_always
0B42D7             0846**  @@:			MOSCALL	mos_fopen
0B42D7 3E 0A       0001**M 			LD	A, function
0B42D9 49 CF       0002**M 			RST.LIS	08h
0B42DB C9          0847**  			RET
0B42DC             0848**  
0B42DC             0849**  ;OSSHUT - Close disk file(s).
0B42DC             0850**  ; E = file channel
0B42DC             0851**  ;  If E=0 all files are closed (except SPOOL)
0B42DC             0852**  ; Destroys: A,B,C,D,E,H,L,F
0B42DC             0853**  ;
0B42DC C5          0854**  OSSHUT:			PUSH	BC
0B42DD 4B          0855**  			LD	C, E
0B42DE             0856**  			MOSCALL	mos_fclose
0B42DE 3E 0B       0001**M 			LD	A, function
0B42E0 49 CF       0002**M 			RST.LIS	08h
0B42E2 C1          0857**  			POP	BC
0B42E3 C9          0858**  			RET
0B42E4             0859**  
0B42E4             0860**  ; OSBGET - Read a byte from a random disk file.
0B42E4             0861**  ;  E = file channel
0B42E4             0862**  ; Returns
0B42E4             0863**  ;  A = byte read
0B42E4             0864**  ;  Carry set if LAST BYTE of file
0B42E4             0865**  ; Destroys: A,B,C,F
0B42E4             0866**  ;
0B42E4 C5          0867**  OSBGET:			PUSH	BC
0B42E5 4B          0868**  			LD	C, E
0B42E6             0869**  			MOSCALL	mos_fgetc
0B42E6 3E 0C       0001**M 			LD	A, function
0B42E8 49 CF       0002**M 			RST.LIS	08h
0B42EA C1          0870**  			POP	BC
0B42EB C9          0871**  			RET
0B42EC             0872**  
0B42EC             0873**  ; OSBPUT - Write a byte to a random disk file.
0B42EC             0874**  ;  E = file channel
0B42EC             0875**  ;  A = byte to write
0B42EC             0876**  ; Destroys: A,B,C,F
0B42EC             0877**  ;
0B42EC C5          0878**  OSBPUT:			PUSH	BC
0B42ED 4B          0879**  			LD	C, E
0B42EE 47          0880**  			LD	B, A
0B42EF             0881**  			MOSCALL	mos_fputc
0B42EF 3E 0D       0001**M 			LD	A, function
0B42F1 49 CF       0002**M 			RST.LIS	08h
0B42F3 C1          0882**  			POP	BC
0B42F4 C9          0883**  			RET
0B42F5             0884**  
0B42F5             0885**  ; OSSTAT - Read file status
0B42F5             0886**  ;  E = file channel
0B42F5             0887**  ; Returns
0B42F5             0888**  ;  F: Z flag set - EOF
0B42F5             0889**  ;  A: If Z then A = 0
0B42F5             0890**  ; Destroys: A,D,E,H,L,F
0B42F5             0891**  ;
0B42F5 C5          0892**  OSSTAT:			PUSH	BC
0B42F6 4B          0893**  			LD	C, E
0B42F7             0894**  			MOSCALL	mos_feof
0B42F7 3E 0E       0001**M 			LD	A, function
0B42F9 49 CF       0002**M 			RST.LIS	08h
0B42FB C1          0895**  			POP	BC
0B42FC FE 01       0896**  			CP	1
0B42FE C9          0897**  			RET
0B42FF             0898**  
0B42FF             0899**  ; GETPTR - Return file pointer.
0B42FF             0900**  ;    E = file channel
0B42FF             0901**  ; Returns:
0B42FF             0902**  ; DEHL = pointer (0-&7FFFFF)
0B42FF             0903**  ; Destroys: A,B,C,D,E,H,L,F
0B42FF             0904**  ;
0B42FF FD E5       0905**  GETPTR:			PUSH		IY
0B4301 4B          0906**  			LD		C, E
0B4302             0907**  			MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0B4302 3E 19       0001**M 			LD	A, function
0B4304 49 CF       0002**M 			RST.LIS	08h
0B4306 E5          0908**  			PUSH		HL
0B4307 FD E1       0909**  			POP		IY		; IYU: Pointer to FIL structure
0B4309 FD 6E 11    0910**  			LD		L, (IY + FIL.fptr + 0)
0B430C FD 66 12    0911**  			LD		H, (IY + FIL.fptr + 1)
0B430F FD 5E 13    0912**  			LD		E, (IY + FIL.fptr + 2)
0B4312 FD 56 14    0913**  			LD		D, (IY + FIL.fptr + 3)
0B4315 FD E1       0914**  			POP		IY
0B4317 C9          0915**  			RET
0B4318             0916**  
0B4318             0917**  ; PUTPTR - Update file pointer.
0B4318             0918**  ;    A = file channel
0B4318             0919**  ; DEHL = new pointer (0-&7FFFFF)
0B4318             0920**  ; Destroys: A,B,C,D,E,H,L,F
0B4318             0921**  ;
0B4318 FD E5       0922**  PUTPTR:			PUSH		IY
0B431A 4F          0923**  			LD		C, A  		; C: Filehandle
0B431B E5          0924**  			PUSH		HL
0B431C 21 02 00 00 0925**  			LD		HL, 2
0B4320 39          0926**  			ADD		HL, SP
0B4321 73          0927**  			LD		(HL), E 	; 3rd byte of DWORD set to E
0B4322 E1          0928**  			POP		HL
0B4323 5A          0929**  			LD		E, D  		; 4th byte passed as E
0B4324             0930**  			MOSCALL		mos_flseek
0B4324 3E 1C       0001**M 			LD	A, function
0B4326 49 CF       0002**M 			RST.LIS	08h
0B4328 FD E1       0931**  			POP		IY
0B432A C9          0932**  			RET
0B432B             0933**  
0B432B             0934**  ; GETEXT - Find file size.
0B432B             0935**  ;    E = file channel
0B432B             0936**  ; Returns:
0B432B             0937**  ; DEHL = file size (0-&800000)
0B432B             0938**  ; Destroys: A,B,C,D,E,H,L,F
0B432B             0939**  ;
0B432B FD E5       0940**  GETEXT:         PUSH    IY
0B432D 4B          0941**                  LD      C, E
0B432E             0942**                  MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0B432E 3E 19       0001**M 			LD	A, function
0B4330 49 CF       0002**M 			RST.LIS	08h
0B4332 E5          0943**                  PUSH    HL
0B4333 FD E1       0944**                  POP     IY          ; IYU: Pointer to FIL structure
0B4335             0945**                  ; Access the obj.objsize field using the offset values
0B4335 FD 6E 0B    0946**                  LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0B4338 FD 66 0C    0947**                  LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0B433B FD 5E 0D    0948**                  LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0B433E FD 56 0E    0949**                  LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0B4341             0950**  
0B4341 FD E1       0951**                  POP     IY
0B4343 C9          0952**  			RET
0B4344             0953**  
0B4344             0954**  ; GETIMS - Get time from RTC
0B4344             0955**  ;
0B4344 FD E5       0956**  GETIMS:			PUSH	IY
0B4346 21 00 49 0B 0957**  			LD	HL, ACCS 		; Where to store the time string
0B434A             0958**  			MOSCALL	mos_getrtc
0B434A 3E 12       0001**M 			LD	A, function
0B434C 49 CF       0002**M 			RST.LIS	08h
0B434E 11 00 49 0B 0959**  			LD	DE, ACCS		; DE: pointer to start of string accumulator
0B4352 5F          0960**  			LD	E, A 			;  E: now points to the end of the string
0B4353 FD E1       0961**  			POP	IY
0B4355 C9          0962**  			RET
0B4356             0963**  
0B4356             0964**  ; Get two word values from EXPR in DE, HL
0B4356             0965**  ; IY: Pointer to expression string
0B4356             0966**  ; Returns:
0B4356             0967**  ; DE: P1
0B4356             0968**  ; HL: P2
0B4356             0969**  ;
0B4356 CD BB 02 0B 0970**  EXPR_W2:		CALL	EXPRI			; Get first parameter
0B435A D9          0971**  			EXX
0B435B E5          0972**  			PUSH	HL
0B435C CD D3 09 0B 0973**  			CALL	COMMA
0B4360 CD BB 02 0B 0974**  			CALL	EXPRI			; Get second parameter
0B4364 D9          0975**  			EXX
0B4365 D1          0976**  			POP	DE
0B4366 C9          0977**  			RET
0B4367             0978**  
0B4367             0979**  ; Stuff not implemented yet
0B4367             0980**  ;
0B4367 C9          0981**  RESET:			RET
0B4368             0012*       include "basic/sorry.asm"
0B4368             0001**  ;
0B4368             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B4368             0003**  ;		Catch-all for unimplemented functionality
0B4368             0004**  ; Author:	Dean Belfield
0B4368             0005**  ; Created:	12/05/2023
0B4368             0006**  ; Last Updated:	12/05/2023
0B4368             0007**  ;
0B4368             0008**  ; Modinfo:
0B4368             0009**  
0B4368             0010**  			; .ASSUME	ADL = 1
0B4368             0011**  
0B4368             0012**  			; SEGMENT CODE
0B4368             0013**  
0B4368             0014**  			; XDEF	ENVEL
0B4368             0015**  			; XDEF	ADVAL
0B4368             0016**  			; XDEF	PUTIMS
0B4368             0017**  
0B4368             0018**  			; XREF	EXTERR
0B4368             0019**  
0B4368             0020**  ENVEL:
0B4368             0021**  ADVAL:
0B4368             0022**  PUTIMS:
0B4368 AF          0023**  			XOR     A
0B4369 CD 28 37 0B 0024**  			CALL    EXTERR
0B436D 53 6F 72 72 0025**  			DEFB    "Sorry"
       79          
0B4372 00          0026**  			DEFB    0
0B4373             0013*       include "basic/agon_graphics.asm"
0B4373             0001**  ;
0B4373             0002**  ; Title:	BBC Basic for AGON - Graphics stuff
0B4373             0003**  ; Author:	Dean Belfield
0B4373             0004**  ; Created:	12/05/2023
0B4373             0005**  ; Last Updated:	07/06/2023
0B4373             0006**  ;
0B4373             0007**  ; Modinfo:
0B4373             0008**  ; 07/06/2023:	Modified to run in ADL mode
0B4373             0009**  
0B4373             0010**  			; .ASSUME	ADL = 1
0B4373             0011**  
0B4373             0012**  			; INCLUDE	"equs.inc"
0B4373             0013**  			; INCLUDE "macros.inc"
0B4373             0014**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B4373             0015**  
0B4373             0016**  			; SEGMENT CODE
0B4373             0017**  
0B4373             0018**  			; XDEF	CLG
0B4373             0019**  			; XDEF	CLRSCN
0B4373             0020**  			; XDEF	MODE
0B4373             0021**  			; XDEF	COLOUR
0B4373             0022**  			; XDEF	GCOL
0B4373             0023**  			; XDEF	MOVE
0B4373             0024**  			; XDEF	PLOT
0B4373             0025**  			; XDEF	DRAW
0B4373             0026**  			; XDEF	POINT
0B4373             0027**  			; XDEF	GETSCHR
0B4373             0028**  
0B4373             0029**  			; XREF	OSWRCH
0B4373             0030**  			; XREF	ASC_TO_NUMBER
0B4373             0031**  			; XREF	EXTERR
0B4373             0032**  			; XREF	EXPRI
0B4373             0033**  			; XREF	COMMA
0B4373             0034**  			; XREF	XEQ
0B4373             0035**  			; XREF	NXT
0B4373             0036**  			; XREF	BRAKET
0B4373             0037**  			; XREF	COUNT0
0B4373             0038**  			; XREF	CRTONULL
0B4373             0039**  			; XREF	NULLTOCR
0B4373             0040**  			; XREF	CRLF
0B4373             0041**  			; XREF	EXPR_W2
0B4373             0042**  			; XREF	INKEY1
0B4373             0043**  
0B4373             0044**  ; CLG: clears the graphics area
0B4373             0045**  ;
0B4373             0046**  CLG:
0B4373             0047**  
0B4373             0048**  			VDU	10h
0B4373 3E 10       0001**M 		LD	A, val
0B4375 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4379 C3 47 0B 0B 0049**  			JP	XEQ
0B437D             0050**  
0B437D             0051**  ; CLS: clears the text area
0B437D             0052**  ;
0B437D 3E 0C       0053**  CLRSCN:			LD	A, 0Ch
0B437F C3 B1 3E 0B 0054**  			JP	OSWRCH
0B4383             0055**  
0B4383             0056**  ; MODE n: Set video mode
0B4383             0057**  ;
0B4383 DD E5       0058**  MODE:			PUSH	IX			; Get the system vars in IX
0B4385             0059**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B4385 3E 08       0001**M 			LD	A, function
0B4387 49 CF       0002**M 			RST.LIS	08h
0B4389 DD CB 04 A6 0060**  			RES	4, (IX+sysvar_vpd_pflags)
0B438D CD BB 02 0B 0061**  			CALL    EXPRI
0B4391 D9          0062**  			EXX
0B4392             0063**  			VDU	16H			; Mode change
0B4392 3E 16       0001**M 		LD	A, val
0B4394 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4398             0064**  			VDU	L
0B4398 7D          0001**M 		LD	A, val
0B4399 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B439D             0065**  			MOSCALL	mos_sysvars
0B439D 3E 08       0001**M 			LD	A, function
0B439F 49 CF       0002**M 			RST.LIS	08h
0B43A1 DD CB 04 66 0066**  @@:			BIT	4, (IX+sysvar_vpd_pflags)
0B43A5 28 FA       0067**  			JR	Z, @B			; Wait for the result
0B43A7 DD E1       0068**  			POP	IX
0B43A9 C3 47 0B 0B 0069**  			JP	XEQ
0B43AD             0070**  
0B43AD             0071**  ; GET(x,y): Get the ASCII code of a character on screen
0B43AD             0072**  ;
0B43AD FD 23       0073**  GETSCHR:		INC	IY
0B43AF CD BB 02 0B 0074**  			CALL    EXPRI      		; Get X coordinate
0B43B3 D9          0075**  			EXX
0B43B4 22 00 49 0B 0076**  			LD	(VDU_BUFFER+0), HL
0B43B8 CD D3 09 0B 0077**  			CALL	COMMA
0B43BC CD BB 02 0B 0078**  			CALL	EXPRI			; Get Y coordinate
0B43C0 D9          0079**  			EXX
0B43C1 22 02 49 0B 0080**  			LD	(VDU_BUFFER+2), HL
0B43C5 CD E0 09 0B 0081**  			CALL	BRAKET			; Closing bracket
0B43C9             0082**  ;
0B43C9 DD E5       0083**  			PUSH	IX			; Get the system vars in IX
0B43CB             0084**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B43CB 3E 08       0001**M 			LD	A, function
0B43CD 49 CF       0002**M 			RST.LIS	08h
0B43CF DD CB 04 8E 0085**  			RES	1, (IX+sysvar_vpd_pflags)
0B43D3             0086**  			VDU	23
0B43D3 3E 17       0001**M 		LD	A, val
0B43D5 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B43D9             0087**  			VDU	0
0B43D9 3E 00       0001**M 		LD	A, val
0B43DB CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B43DF             0088**  			VDU	vdp_scrchar
0B43DF 3E 83       0001**M 		LD	A, val
0B43E1 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B43E5             0089**  			VDU	(VDU_BUFFER+0)
0B43E5 3A 00 49 0B 0001**M 		LD	A, val
0B43E9 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B43ED             0090**  			VDU	(VDU_BUFFER+1)
0B43ED 3A 01 49 0B 0001**M 		LD	A, val
0B43F1 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B43F5             0091**  			VDU	(VDU_BUFFER+2)
0B43F5 3A 02 49 0B 0001**M 		LD	A, val
0B43F9 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B43FD             0092**  			VDU	(VDU_BUFFER+3)
0B43FD 3A 03 49 0B 0001**M 		LD	A, val
0B4401 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4405 DD CB 04 4E 0093**  @@:			BIT	1, (IX+sysvar_vpd_pflags)
0B4409 28 FA       0094**  			JR	Z, @B			; Wait for the result
0B440B DD 7E 09    0095**  			LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0B440E B7          0096**  			OR	A			; Check for 00h
0B440F 37          0097**  			SCF				; C = character map
0B4410 20 02       0098**  			JR	NZ, @F			; We have a character, so skip next bit
0B4412 AF          0099**  			XOR	A			; Clear carry
0B4413 3D          0100**  			DEC	A			; Set A to FFh
0B4414 DD E1       0101**  @@:			POP	IX
0B4416 C3 92 07 0B 0102**  			JP	INKEY1			; Jump back to the GET command
0B441A             0103**  
0B441A             0104**  ; POINT(x,y): Get the pixel colour of a point on screen
0B441A             0105**  ;
0B441A CD BB 02 0B 0106**  POINT:			CALL    EXPRI      		; Get X coordinate
0B441E D9          0107**  			EXX
0B441F 22 00 49 0B 0108**  			LD	(VDU_BUFFER+0), HL
0B4423 CD D3 09 0B 0109**  			CALL	COMMA
0B4427 CD BB 02 0B 0110**  			CALL	EXPRI			; Get Y coordinate
0B442B D9          0111**  			EXX
0B442C 22 02 49 0B 0112**  			LD	(VDU_BUFFER+2), HL
0B4430 CD E0 09 0B 0113**  			CALL	BRAKET			; Closing bracket
0B4434             0114**  ;
0B4434 DD E5       0115**  			PUSH	IX			; Get the system vars in IX
0B4436             0116**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B4436 3E 08       0001**M 			LD	A, function
0B4438 49 CF       0002**M 			RST.LIS	08h
0B443A DD CB 04 96 0117**  			RES	2, (IX+sysvar_vpd_pflags)
0B443E             0118**  			VDU	23
0B443E 3E 17       0001**M 		LD	A, val
0B4440 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4444             0119**  			VDU	0
0B4444 3E 00       0001**M 		LD	A, val
0B4446 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B444A             0120**  			VDU	vdp_scrpixel
0B444A 3E 84       0001**M 		LD	A, val
0B444C CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4450             0121**  			VDU	(VDU_BUFFER+0)
0B4450 3A 00 49 0B 0001**M 		LD	A, val
0B4454 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4458             0122**  			VDU	(VDU_BUFFER+1)
0B4458 3A 01 49 0B 0001**M 		LD	A, val
0B445C CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4460             0123**  			VDU	(VDU_BUFFER+2)
0B4460 3A 02 49 0B 0001**M 		LD	A, val
0B4464 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4468             0124**  			VDU	(VDU_BUFFER+3)
0B4468 3A 03 49 0B 0001**M 		LD	A, val
0B446C CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4470 DD CB 04 56 0125**  @@:			BIT	2, (IX+sysvar_vpd_pflags)
0B4474 28 FA       0126**  			JR	Z, @B			; Wait for the result
0B4476             0127**  ;
0B4476             0128**  ; Return the data as a 1 byte index
0B4476             0129**  ;
0B4476 DD 6E 16    0130**  			LD	L, (IX+sysvar_scrpixelIndex)
0B4479 DD E1       0131**  			POP	IX
0B447B C3 30 05 0B 0132**  			JP	COUNT0
0B447F             0133**  
0B447F             0134**  
0B447F             0135**  ; COLOUR colour
0B447F             0136**  ; COLOUR L,P
0B447F             0137**  ; COLOUR L,R,G,B
0B447F             0138**  ;
0B447F CD BB 02 0B 0139**  COLOUR:			CALL	EXPRI			; The colour / mode
0B4483 D9          0140**  			EXX
0B4484 7D          0141**  			LD	A, L
0B4485 32 00 49 0B 0142**  			LD	(VDU_BUFFER+0), A	; Store first parameter
0B4489 CD 21 0A 0B 0143**  			CALL	NXT			; Are there any more parameters?
0B448D FE 2C       0144**  			CP	','
0B448F 28 12       0145**  			JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0B4491             0146**  ;
0B4491             0147**  			VDU	11h			; Just set the colour
0B4491 3E 11       0001**M 		LD	A, val
0B4493 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4497             0148**  			VDU	(VDU_BUFFER+0)
0B4497 3A 00 49 0B 0001**M 		LD	A, val
0B449B CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B449F C3 47 0B 0B 0149**  			JP	XEQ
0B44A3             0150**  ;
0B44A3 CD D3 09 0B 0151**  COLOUR_1:		CALL	COMMA
0B44A7 CD BB 02 0B 0152**  			CALL	EXPRI			; Parse R (OR P)
0B44AB D9          0153**  			EXX
0B44AC 7D          0154**  			LD	A, L
0B44AD 32 01 49 0B 0155**  			LD	(VDU_BUFFER+1), A
0B44B1 CD 21 0A 0B 0156**  			CALL	NXT			; Are there any more parameters?
0B44B5 FE 2C       0157**  			CP	','
0B44B7 28 2C       0158**  			JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
0B44B9             0159**  ;
0B44B9             0160**  			VDU	13h			; VDU:COLOUR
0B44B9 3E 13       0001**M 		LD	A, val
0B44BB CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B44BF             0161**  			VDU	(VDU_BUFFER+0)		; Logical Colour
0B44BF 3A 00 49 0B 0001**M 		LD	A, val
0B44C3 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B44C7             0162**  			VDU	(VDU_BUFFER+1)		; Palette Colour
0B44C7 3A 01 49 0B 0001**M 		LD	A, val
0B44CB CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B44CF             0163**  			VDU	0			; RGB set to 0
0B44CF 3E 00       0001**M 		LD	A, val
0B44D1 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B44D5             0164**  			VDU	0
0B44D5 3E 00       0001**M 		LD	A, val
0B44D7 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B44DB             0165**  			VDU	0
0B44DB 3E 00       0001**M 		LD	A, val
0B44DD CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B44E1 C3 47 0B 0B 0166**  			JP	XEQ
0B44E5             0167**  ;
0B44E5 CD D3 09 0B 0168**  COLOUR_2:		CALL	COMMA
0B44E9 CD BB 02 0B 0169**  			CALL	EXPRI			; Parse G
0B44ED D9          0170**  			EXX
0B44EE 7D          0171**  			LD	A, L
0B44EF 32 02 49 0B 0172**  			LD	(VDU_BUFFER+2), A
0B44F3 CD D3 09 0B 0173**  			CALL	COMMA
0B44F7 CD BB 02 0B 0174**  			CALL	EXPRI			; Parse B
0B44FB D9          0175**  			EXX
0B44FC 7D          0176**  			LD	A, L
0B44FD 32 03 49 0B 0177**  			LD	(VDU_BUFFER+3), A
0B4501             0178**  			VDU	13h			; VDU:COLOUR
0B4501 3E 13       0001**M 		LD	A, val
0B4503 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4507             0179**  			VDU	(VDU_BUFFER+0)		; Logical Colour
0B4507 3A 00 49 0B 0001**M 		LD	A, val
0B450B CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B450F             0180**  			VDU	FFh			; Physical Colour (-1 for RGB mode)
0B450F 3E FF       0001**M 		LD	A, val
0B4511 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4515             0181**  			VDU	(VDU_BUFFER+1)		; R
0B4515 3A 01 49 0B 0001**M 		LD	A, val
0B4519 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B451D             0182**  			VDU	(VDU_BUFFER+2)		; G
0B451D 3A 02 49 0B 0001**M 		LD	A, val
0B4521 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4525             0183**  			VDU	(VDU_BUFFER+3)		; B
0B4525 3A 03 49 0B 0001**M 		LD	A, val
0B4529 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B452D C3 47 0B 0B 0184**  			JP	XEQ
0B4531             0185**  
0B4531             0186**  ; GCOL mode,colour
0B4531             0187**  ;
0B4531 CD BB 02 0B 0188**  GCOL:			CALL	EXPRI			; Parse MODE
0B4535 D9          0189**  			EXX
0B4536 7D          0190**  			LD	A, L
0B4537 32 00 49 0B 0191**  			LD	(VDU_BUFFER+0), A
0B453B CD D3 09 0B 0192**  			CALL	COMMA
0B453F             0193**  ;
0B453F CD BB 02 0B 0194**  			CALL	EXPRI			; Parse Colour
0B4543 D9          0195**  			EXX
0B4544 7D          0196**  			LD	A, L
0B4545 32 01 49 0B 0197**  			LD	(VDU_BUFFER+1), A
0B4549             0198**  ;
0B4549             0199**  			VDU	12h			; VDU:GCOL
0B4549 3E 12       0001**M 		LD	A, val
0B454B CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B454F             0200**  			VDU	(VDU_BUFFER+0)		; Mode
0B454F 3A 00 49 0B 0001**M 		LD	A, val
0B4553 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4557             0201**  			VDU	(VDU_BUFFER+1)		; Colour
0B4557 3A 01 49 0B 0001**M 		LD	A, val
0B455B CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B455F C3 47 0B 0B 0202**  			JP	XEQ
0B4563             0203**  
0B4563             0204**  ; PLOT mode,x,y
0B4563             0205**  ;
0B4563 CD BB 02 0B 0206**  PLOT:			CALL	EXPRI		; Parse mode
0B4567 D9          0207**  			EXX
0B4568 E5          0208**  			PUSH	HL		; Push mode (L) onto stack
0B4569 CD D3 09 0B 0209**  			CALL	COMMA
0B456D CD 56 43 0B 0210**  			CALL	EXPR_W2		; Parse X and Y
0B4571 C1          0211**  			POP	BC		; Pop mode (C) off stack
0B4572             0212**  PLOT_1:			VDU	19H		; VDU code for PLOT
0B4572 3E 19       0001**M 		LD	A, val
0B4574 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4578             0213**  			VDU	C		;  C: Mode
0B4578 79          0001**M 		LD	A, val
0B4579 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B457D             0214**  			VDU	E		; DE: X
0B457D 7B          0001**M 		LD	A, val
0B457E CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4582             0215**  			VDU	D
0B4582 7A          0001**M 		LD	A, val
0B4583 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4587             0216**  			VDU	L		; HL: Y
0B4587 7D          0001**M 		LD	A, val
0B4588 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B458C             0217**  			VDU	H
0B458C 7C          0001**M 		LD	A, val
0B458D CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4591 C3 47 0B 0B 0218**  			JP	XEQ
0B4595             0219**  
0B4595             0220**  ; MOVE x,y
0B4595             0221**  ;
0B4595 CD 56 43 0B 0222**  MOVE:			CALL	EXPR_W2		; Parse X and Y
0B4599 0E 04       0223**  			LD	C, 04H		; Plot mode 04H (Move)
0B459B 18 D5       0224**  			JR	PLOT_1		; Plot
0B459D             0225**  
0B459D             0226**  ; DRAW x1,y1
0B459D             0227**  ; DRAW x1,y1,x2,y2
0B459D             0228**  ;
0B459D CD 56 43 0B 0229**  DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0B45A1 CD 21 0A 0B 0230**  			CALL	NXT		; Are there any more parameters?
0B45A5 FE 2C       0231**  			CP	','
0B45A7 0E 05       0232**  			LD	C, 05h		; Code for LINE
0B45A9 20 C7       0233**  			JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0B45AB             0234**  			VDU	19h		; Move to the first coordinates
0B45AB 3E 19       0001**M 		LD	A, val
0B45AD CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B45B1             0235**  			VDU	04h
0B45B1 3E 04       0001**M 		LD	A, val
0B45B3 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B45B7             0236**  			VDU	E
0B45B7 7B          0001**M 		LD	A, val
0B45B8 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B45BC             0237**  			VDU	D
0B45BC 7A          0001**M 		LD	A, val
0B45BD CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B45C1             0238**  			VDU	L
0B45C1 7D          0001**M 		LD	A, val
0B45C2 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B45C6             0239**  			VDU	H
0B45C6 7C          0001**M 		LD	A, val
0B45C7 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B45CB CD D3 09 0B 0240**  			CALL	COMMA
0B45CF C5          0241**  			PUSH	BC
0B45D0 CD 56 43 0B 0242**  			CALL	EXPR_W2		; Get X2 and Y2
0B45D4 C1          0243**  			POP	BC
0B45D5 18 9B       0244**  			JR	PLOT_1		; Now DRAW the line to those positions
0B45D7             0245**  
0B45D7             0246**  
0B45D7             0247**  
0B45D7             0014*       include "basic/agon_sound.asm"
0B45D7             0001**  ;
0B45D7             0002**  ; Title:	BBC Basic for AGON - Audio stuff
0B45D7             0003**  ; Author:	Dean Belfield
0B45D7             0004**  ; Created:	12/05/2023
0B45D7             0005**  ; Last Updated:	12/05/2023
0B45D7             0006**  ;
0B45D7             0007**  ; Modinfo:
0B45D7             0008**  
0B45D7             0009**  			; .ASSUME	ADL = 1
0B45D7             0010**  
0B45D7             0011**  			; INCLUDE	"equs.inc"
0B45D7             0012**  			; INCLUDE "macros.inc"
0B45D7             0013**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B45D7             0014**  
0B45D7             0015**  			; SEGMENT CODE
0B45D7             0016**  
0B45D7             0017**  			; XDEF	SOUND
0B45D7             0018**  
0B45D7             0019**  			; XREF	COMMA
0B45D7             0020**  			; XREF	EXPR_W2
0B45D7             0021**  			; XREF	XEQ
0B45D7             0022**  			; XREF	LTRAP
0B45D7             0023**  			; XREF	OSWRCH
0B45D7             0024**  			; XREF	VDU_BUFFER
0B45D7             0025**  
0B45D7             0026**  
0B45D7             0027**  ; SOUND channel,volume,pitch,duration
0B45D7             0028**  ; volume: 0 (off) to -15 (full volume)
0B45D7             0029**  ; pitch: 0 - 255
0B45D7             0030**  ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
0B45D7             0031**  ;
0B45D7 CD 56 43 0B 0032**  SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
0B45DB 7D          0033**  			LD	A, L 			;  A: Volume
0B45DC F5          0034**  			PUSH	AF
0B45DD D5          0035**  			PUSH	DE
0B45DE CD D3 09 0B 0036**  			CALL	COMMA
0B45E2 CD 56 43 0B 0037**  			CALL	EXPR_W2			; DE: Pitch, HL: Duration
0B45E6 53          0038**  			LD	D, E			;  D: Pitch
0B45E7 5D          0039**  			LD	E, L 			;  E: Duration
0B45E8 E1          0040**  			POP	HL 			; HL: Channel/Control
0B45E9 F1          0041**  			POP	AF
0B45EA ED 44       0042**  			NEG
0B45EC FE 10       0043**  			CP	16			; Check volume is in bounds
0B45EE D2 47 0B 0B 0044**  			JP	NC, XEQ			; Out of bounds, do nothing
0B45F2             0045**  ;
0B45F2             0046**  ; Store	in VDU vars
0B45F2             0047**  ;
0B45F2 4F          0048**  			LD	C, A			; Store Volume in C
0B45F3 7D          0049**  			LD	A, L
0B45F4 32 00 49 0B 0050**  			LD	(VDU_BUFFER+0), A	; Channel
0B45F8 AF          0051**  			XOR	A
0B45F9 32 01 49 0B 0052**  			LD	(VDU_BUFFER+1), A	; Waveform
0B45FD             0053**  ;
0B45FD             0054**  ; Calculate the volume
0B45FD             0055**  ;
0B45FD 06 06       0056**  			LD	B, 6			; C already contains the volume
0B45FF ED 4C       0057**  			MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0B4601 79          0058**  			LD	A, C
0B4602 32 02 49 0B 0059**  			LD	(VDU_BUFFER+2), A
0B4606             0060**  ;
0B4606             0061**  ; And the frequency
0B4606             0062**  ;
0B4606 4B          0063**  			LD	C, E			; Store duration in C
0B4607 26 00       0064**  			LD	H, 0			; Lookup the frequency
0B4609 6A          0065**  			LD	L, D
0B460A 11 91 46 0B 0066**  			LD	DE, SOUND_FREQ_LOOKUP
0B460E 29          0067**  			ADD	HL, HL
0B460F 19          0068**  			ADD	HL, DE
0B4610 7E          0069**  			LD	A, (HL)
0B4611 32 03 49 0B 0070**  			LD	(VDU_BUFFER+3), A
0B4615 23          0071**  			INC	HL
0B4616 7E          0072**  			LD	A, (HL)
0B4617 32 04 49 0B 0073**  			LD	(VDU_BUFFER+4), A
0B461B             0074**  ;
0B461B             0075**  ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
0B461B             0076**  ;
0B461B 06 32       0077**  			LD	B, 50			; C contains the duration, so MLT by 50
0B461D ED 4C       0078**  			MLT	BC
0B461F ED 43 05 49 0079**  			LD	(VDU_BUFFER+5), BC
       0B          
0B4624             0080**  ;
0B4624 DD E5       0081**  			PUSH	IX			; Get the system vars in IX
0B4626             0082**  			MOSCALL	mos_sysvars		; Reset the semaphore
0B4626 3E 08       0001**M 			LD	A, function
0B4628 49 CF       0002**M 			RST.LIS	08h
0B462A 5B DD CB 04 0083**  SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
       9E          
0B462F             0084**  ;
0B462F             0085**  			VDU	23			; Send the sound command
0B462F 3E 17       0001**M 		LD	A, val
0B4631 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4635             0086**  			VDU	0
0B4635 3E 00       0001**M 		LD	A, val
0B4637 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B463B             0087**  			VDU	vdp_audio
0B463B 3E 85       0001**M 		LD	A, val
0B463D CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4641             0088**  			VDU	(VDU_BUFFER+0)		; 0: Channel
0B4641 3A 00 49 0B 0001**M 		LD	A, val
0B4645 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4649             0089**  			VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0B4649 3A 01 49 0B 0001**M 		LD	A, val
0B464D CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4651             0090**  			VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0B4651 3A 02 49 0B 0001**M 		LD	A, val
0B4655 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4659             0091**  			VDU	(VDU_BUFFER+3)		; 3: Frequency L
0B4659 3A 03 49 0B 0001**M 		LD	A, val
0B465D CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4661             0092**  			VDU	(VDU_BUFFER+4)		; 4: Frequency H
0B4661 3A 04 49 0B 0001**M 		LD	A, val
0B4665 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4669             0093**  			VDU	(VDU_BUFFER+5)		; 5: Duration L
0B4669 3A 05 49 0B 0001**M 		LD	A, val
0B466D CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4671             0094**  			VDU	(VDU_BUFFER+6)		; 6: Duration H
0B4671 3A 06 49 0B 0001**M 		LD	A, val
0B4675 CD B1 3E 0B 0002**M 		CALL	OSWRCH
0B4679             0095**  ;
0B4679             0096**  ; Wait for acknowledgement
0B4679             0097**  ;
0B4679 5B DD CB 04 0098**  @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
       5E          
0B467E 28 F9       0099**  			JR	Z, @B			; Wait for the result
0B4680 CD 22 3F 0B 0100**  			CALL	LTRAP			; Check for ESC
0B4684 5B DD 7E 0E 0101**  			LD.LIL	A, (IX+sysvar_audioSuccess)
0B4688 A7          0102**  			AND	A			; Check if VDP has queued the note
0B4689 28 9F       0103**  			JR	Z, SOUND0		; No, so loop back and send again
0B468B             0104**  ;
0B468B DD E1       0105**  			POP	IX
0B468D C3 47 0B 0B 0106**  			JP	XEQ
0B4691             0107**  
0B4691             0108**  ; Frequency Lookup Table
0B4691             0109**  ; Set up to replicate the BBC Micro audio frequencies
0B4691             0110**  ;
0B4691             0111**  ; Split over 5 complete octaves, with 53 being middle C
0B4691             0112**  ; * C4: 262hz
0B4691             0113**  ; + A4: 440hz
0B4691             0114**  ;
0B4691             0115**  ;	2	3	4	5	6	7	8
0B4691             0116**  ;
0B4691             0117**  ; B	1	49	97	145	193	241
0B4691             0118**  ; A#	0	45	93	141	189	237
0B4691             0119**  ; A		41	89+	137	185	233
0B4691             0120**  ; G#		37	85	133	181	229
0B4691             0121**  ; G		33	81	129	177	225
0B4691             0122**  ; F#		29	77	125	173	221
0B4691             0123**  ; F		25	73	121	169	217
0B4691             0124**  ; E		21	69	117	165	213
0B4691             0125**  ; D#		17	65	113	161	209
0B4691             0126**  ; D		13	61	109	157	205	253
0B4691             0127**  ; C#		9	57	105	153	201	249
0B4691             0128**  ; C		5	53*	101	149	197	245
0B4691             0129**  ;
0B4691 75 00 76 00 0130**  SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
       78 00 7A 00 
       7B 00 83 00 
       85 00 87 00 
0B46A1 89 00 8B 00 0131**  			DW	 137,  139,  141,  143,  145,  147,  149,  151
       8D 00 8F 00 
       91 00 93 00 
       95 00 97 00 
0B46B1 99 00 9C 00 0132**  			DW	 153,  156,  158,  160,  162,  165,  167,  170
       9E 00 A0 00 
       A2 00 A5 00 
       A7 00 AA 00 
0B46C1 AC 00 AF 00 0133**  			DW	 172,  175,  177,  180,  182,  185,  188,  190
       B1 00 B4 00 
       B6 00 B9 00 
       BC 00 BE 00 
0B46D1 C1 00 C4 00 0134**  			DW	 193,  196,  199,  202,  205,  208,  211,  214
       C7 00 CA 00 
       CD 00 D0 00 
       D3 00 D6 00 
0B46E1 D9 00 DC 00 0135**  			DW	 217,  220,  223,  226,  230,  233,  236,  240
       DF 00 E2 00 
       E6 00 E9 00 
       EC 00 F0 00 
0B46F1 F3 00 F7 00 0136**  			DW	 243,  247,  251,  254,  258,  262,  265,  269
       FB 00 FE 00 
       02 01 06 01 
       09 01 0D 01 
0B4701 11 01 15 01 0137**  			DW	 273,  277,  281,  285,  289,  294,  298,  302
       19 01 1D 01 
       21 01 26 01 
       2A 01 2E 01 
0B4711 33 01 37 01 0138**  			DW	 307,  311,  316,  320,  325,  330,  334,  339
       3C 01 40 01 
       45 01 4A 01 
       4E 01 53 01 
0B4721 58 01 5D 01 0139**  			DW	 344,  349,  354,  359,  365,  370,  375,  381
       62 01 67 01 
       6D 01 72 01 
       77 01 7D 01 
0B4731 82 01 88 01 0140**  			DW	 386,  392,  398,  403,  409,  415,  421,  427
       8E 01 93 01 
       99 01 9F 01 
       A5 01 AB 01 
0B4741 B2 01 B8 01 0141**  			DW	 434,  440,  446,  453,  459,  466,  473,  480
       BE 01 C5 01 
       CB 01 D2 01 
       D9 01 E0 01 
0B4751 E7 01 EE 01 0142**  			DW	 487,  494,  501,  508,  516,  523,  531,  539
       F5 01 FC 01 
       04 02 0B 02 
       13 02 1B 02 
0B4761 22 02 2A 02 0143**  			DW	 546,  554,  562,  571,  579,  587,  596,  605
       32 02 3B 02 
       43 02 4B 02 
       54 02 5D 02 
0B4771 65 02 6E 02 0144**  			DW	 613,  622,  631,  641,  650,  659,  669,  679
       77 02 81 02 
       8A 02 93 02 
       9D 02 A7 02 
0B4781 B1 02 BB 02 0145**  			DW	 689,  699,  709,  719,  729,  740,  751,  762
       C5 02 CF 02 
       D9 02 E4 02 
       EF 02 FA 02 
0B4791 05 03 10 03 0146**  			DW	 773,  784,  795,  807,  819,  831,  843,  855
       1B 03 27 03 
       33 03 3F 03 
       4B 03 57 03 
0B47A1 63 03 70 03 0147**  			DW	 867,  880,  893,  906,  919,  932,  946,  960
       7D 03 8A 03 
       97 03 A4 03 
       B2 03 C0 03 
0B47B1 CE 03 DC 03 0148**  			DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
       EA 03 F9 03 
       08 04 17 04 
       26 04 36 04 
0B47C1 45 04 55 04 0149**  			DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
       65 04 76 04 
       86 04 97 04 
       A8 04 BA 04 
0B47D1 CB 04 DD 04 0150**  			DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
       EF 04 02 05 
       14 05 27 05 
       3A 05 4E 05 
0B47E1 62 05 76 05 0151**  			DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
       8A 05 9F 05 
       B3 05 C9 05 
       DE 05 F4 05 
0B47F1 0A 06 21 06 0152**  			DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
       38 06 4F 06 
       66 06 7E 06 
       96 06 AF 06 
0B4801 C8 06 E1 06 0153**  			DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
       FA 06 14 07 
       2F 07 4A 07 
       65 07 80 07 
0B4811 9C 07 B8 07 0154**  			DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
       D5 07 F2 07 
       10 08 2D 08 
       4B 08 6A 08 
0B4821 8A 08 A9 08 0155**  			DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
       CA 08 EA 08 
       0C 09 2D 09 
       4F 09 72 09 
0B4831 95 09 B9 09 0156**  			DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
       DD 09 02 0A 
       27 0A 4D 0A 
       73 0A 9A 0A 
0B4841 C2 0A EA 0A 0157**  			DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
       12 0B 3C 0B 
       66 0B 90 0B 
       BB 0B E7 0B 
0B4851 13 0C 40 0C 0158**  			DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
       6E 0C 9C 0C 
       CB 0C FA 0C 
       2B 0D 5C 0D 
0B4861 8E 0D C0 0D 0159**  			DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
       F3 0D 27 0E 
       5C 0E 91 0E 
       C8 0E FF 0E 
0B4871 36 0F 6F 0F 0160**  			DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
       A9 0F E3 0F 
       1E 10 5A 10 
       97 10 D5 10 
0B4881 13 11 53 11 0161**  			DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
       93 11 D5 11 
       17 12 5B 12 
       9F 12 E4 12 
0B4891             0162**  
0B4891             0163**  
0B4891             0015*       include "basic/interrupts.asm"
0B4891             0001**  ;
0B4891             0002**  ; Title:	BBC Basic for AGON - Interrupts
0B4891             0003**  ; Author:	Dean Belfield
0B4891             0004**  ; Created:	12/05/2023
0B4891             0005**  ; Last Updated:	07/06/2023
0B4891             0006**  ;
0B4891             0007**  ; Modinfo:
0B4891             0008**  ; 07/06/2023:	Modified to run in ADL mode
0B4891             0009**  
0B4891             0010**  			; .ASSUME	ADL = 1
0B4891             0011**  
0B4891             0012**  			; INCLUDE	"macros.inc"
0B4891             0013**  			; INCLUDE	"equs.inc"
0B4891             0014**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B4891             0015**  
0B4891             0016**  			; SEGMENT CODE
0B4891             0017**  
0B4891             0018**  			; XDEF	VBLANK_INIT
0B4891             0019**  			; XDEF	VBLANK_STOP
0B4891             0020**  			; XDEF	VBLANK_HANDLER
0B4891             0021**  
0B4891             0022**  			; XREF	ESCSET
0B4891             0023**  			; XREF	KEYDOWN		; In ram.asm
0B4891             0024**  			; XREF	KEYASCII 	; In ram.asm
0B4891             0025**  			; XREF	KEYCOUNT	; In ram.asm
0B4891             0026**  
0B4891             0027**  ; Hook into the MOS VBLANK interrupt
0B4891             0028**  ;
0B4891 F3          0029**  VBLANK_INIT:		DI
0B4892 21 E6 48 0B 0030**  			LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0B4896 1E 32       0031**  			LD		E, 32h				; Set up the VBlank Interrupt Vector
0B4898             0032**  			MOSCALL		mos_setintvector
0B4898 3E 14       0001**M 			LD	A, function
0B489A 49 CF       0002**M 			RST.LIS	08h
0B489C             0033**  			; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0B489C EB          0034**  			ex de,hl
0B489D 21 F4 48 0B 0035**  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B48A1 ED 1F       0036**  			LD		(HL), DE			; Self-modify the code
0B48A3 FB          0037**  			EI
0B48A4 C9          0038**  			RET
0B48A5             0039**  
0B48A5             0040**  ; Unhook the custom VBLANK interrupt
0B48A5             0041**  ;
0B48A5 F3          0042**  VBLANK_STOP:		DI
0B48A6 21 F4 48 0B 0043**  			LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B48AA ED 17       0044**  			LD		DE, (HL)
0B48AC EB          0045**  			EX		DE, HL 				; HLU: Address of MOS interrupt vector
0B48AD 1E 32       0046**  			LD		E, 32h
0B48AF             0047**  			MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0B48AF 3E 14       0001**M 			LD	A, function
0B48B1 49 CF       0002**M 			RST.LIS	08h
0B48B3 FB          0048**  			EI
0B48B4 C9          0049**  			RET
0B48B5             0050**  
0B48B5             0051**  ; A safe LIS call to ESCSET
0B48B5             0052**  ;
0B48B5             0053**  DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
0B48B5 3E 08       0001**M 			LD	A, function
0B48B7 49 CF       0002**M 			RST.LIS	08h
0B48B9 21 49 4C 0B 0054**  			LD		HL, KEYCOUNT 			; Check whether the keycount has changed
0B48BD DD 7E 19    0055**  			LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
0B48C0 BE          0056**  			CP 		(HL)				; with our local copy
0B48C1 20 0A       0057**  			JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
0B48C3             0058**  ;
0B48C3 AF          0059**  DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
0B48C4 32 48 4C 0B 0060**  			LD		(KEYASCII), A
0B48C8 32 47 4C 0B 0061**  			LD		(KEYDOWN), A
0B48CC C9          0062**  			RET	 					; And return
0B48CD             0063**  ;
0B48CD 77          0064**  DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
0B48CE DD 7E 18    0065**  			LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
0B48D1 B7          0066**  			OR		A
0B48D2 28 EF       0067**  			JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
0B48D4             0068**  ;
0B48D4 32 47 4C 0B 0069**  			LD		(KEYDOWN), A 			; Store the keydown value
0B48D8 DD 7E 05    0070**  			LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
0B48DB 32 48 4C 0B 0071**  			LD		(KEYASCII), A 			; Store locally
0B48DF FE 1B       0072**  			CP		1Bh				; Is it escape?
0B48E1 CC FD 3E 0B 0073**  			CALL		Z, ESCSET			; Yes, so set the escape flags
0B48E5 C9          0074**  			RET						; Return to the interrupt handler
0B48E6             0075**  
0B48E6 F3          0076**  VBLANK_HANDLER:		DI
0B48E7 F5          0077**  			PUSH		AF
0B48E8 E5          0078**  			PUSH		HL
0B48E9 DD E5       0079**  			PUSH		IX
0B48EB CD B5 48 0B 0080**  			CALL		DO_KEYBOARD
0B48EF DD E1       0081**  			POP		IX
0B48F1 E1          0082**  			POP		HL
0B48F2 F1          0083**  			POP		AF
0B48F3             0084**  ;
0B48F3             0085**  ; Finally jump to the MOS interrupt
0B48F3             0086**  ;
0B48F3 C3 00 00 00 0087**  VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0B48F7             0016*       include "basic/ram.asm"
0B48F7             0001**  ;
0B48F7             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B48F7             0003**  ;		RAM Module for BBC Basic Interpreter
0B48F7             0004**  ;		For use with Version 2.0 of BBC BASIC
0B48F7             0005**  ;		Standard CP/M Distribution Version
0B48F7             0006**  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0B48F7             0007**  ; Modified By:	Dean Belfield
0B48F7             0008**  ; Created:	12/05/2023
0B48F7             0009**  ; Last Updated:	26/06/2023
0B48F7             0010**  ;
0B48F7             0011**  ; Modinfo:
0B48F7             0012**  ; 06/06/2023:	Modified to run in ADL mode
0B48F7             0013**  ; 26/06/2023:	Added temporary stores R0 and R1
0B48F7             0014**  
0B48F7             0015**  			; .ASSUME	ADL = 1
0B48F7             0016**  
0B48F7             0017**  			; DEFINE	LORAM, SPACE = ROM
0B48F7             0018**  			; SEGMENT LORAM
0B48F7             0019**  
0B48F7             0020**  			; XDEF	ACCS
0B48F7             0021**  			; XDEF	BUFFER
0B48F7             0022**  			; XDEF	STAVAR
0B48F7             0023**  			; XDEF	DYNVAR
0B48F7             0024**  			; XDEF	FNPTR
0B48F7             0025**  			; XDEF	PROPTR
0B48F7             0026**  			; XDEF	PAGE_
0B48F7             0027**  			; XDEF	TOP
0B48F7             0028**  			; XDEF	LOMEM
0B48F7             0029**  			; XDEF 	FREE
0B48F7             0030**  			; XDEF	HIMEM
0B48F7             0031**  			; XDEF	LINENO
0B48F7             0032**  			; XDEF	TRACEN
0B48F7             0033**  			; XDEF	AUTONO
0B48F7             0034**  			; XDEF	ERRTRP
0B48F7             0035**  			; XDEF	ERRTXT
0B48F7             0036**  			; XDEF	DATPTR
0B48F7             0037**  			; XDEF	ERL
0B48F7             0038**  			; XDEF	ERRLIN
0B48F7             0039**  			; XDEF	RANDOM
0B48F7             0040**  			; XDEF	COUNT
0B48F7             0041**  			; XDEF	WIDTH
0B48F7             0042**  			; XDEF	ERR
0B48F7             0043**  			; XDEF	LISTON
0B48F7             0044**  			; XDEF	INCREM
0B48F7             0045**  
0B48F7             0046**  			; XDEF	FLAGS
0B48F7             0047**  			; XDEF	OSWRCHPT
0B48F7             0048**  			; XDEF	OSWRCHCH
0B48F7             0049**  			; XDEF	OSWRCHFH
0B48F7             0050**  			; XDEF	KEYDOWN
0B48F7             0051**  			; XDEF	KEYASCII
0B48F7             0052**  			; XDEF	KEYCOUNT
0B48F7             0053**  
0B48F7             0054**  			; XDEF	R0
0B48F7             0055**  			; XDEF	R1
0B48F7             0056**  
0B48F7             0057**  			; XDEF	RAM_START
0B48F7             0058**  			; XDEF	RAM_END
0B48F7             0059**  			; XDEF	USER
0B48F7             0060**  
0B48F7             0061**  end_binary: ;  for assemble.py to know where to truncate the binary file
0B48F7 FF FF FF FF 0062**  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF          
0B4900             0063**  RAM_START:
0B4900             0064**  ;
0B4900 00 00 00 00 0065**  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4A00 00 00 00 00 0066**  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4B00 00 00 00 00 0067**  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4B6C 00 00 00 00 0068**  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
0B4C0E 00 00 00    0069**  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B4C11 00 00 00    0070**  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B4C14             0071**  ;
0B4C14 00 00 00    0072**  PAGE_:          BLKB    3,0               ; Start of User Program
0B4C17 00 00 00    0073**  TOP:            BLKB    3,0               ; First Location after User Program
0B4C1A 00 00 00    0074**  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B4C1D 00 00 00    0075**  FREE:           BLKB    3,0               ; First Free Space Byte
0B4C20 00 00 00    0076**  HIMEM:          BLKB    3,0               ; First Protected Byte
0B4C23             0077**  ;
0B4C23 00 00 00    0078**  LINENO:         BLKB    3,0               ; Line Number
0B4C26 00 00 00    0079**  TRACEN:         BLKB    3,0               ; Trace Flag
0B4C29 00 00 00    0080**  AUTONO:         BLKB    3,0               ; Auto Flag
0B4C2C 00 00 00    0081**  ERRTRP:         BLKB    3,0               ; Error Trap
0B4C2F 00 00       0082**  ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B4C31 00 00       0083**  DATPTR:         BLKB    2,0               ; Data Pointer
0B4C33 00 00       0084**  ERL:            BLKB    2,0               ; Error Line
0B4C35 00 00 00    0085**  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B4C38 00 00 00 00 0086**  RANDOM:         BLKB    5,0               ; Random Number
       00          
0B4C3D 00          0087**  COUNT:          BLKB    1,0               ; Print Position
0B4C3E 00          0088**  WIDTH:          BLKB    1,0               ; Print Width
0B4C3F 00          0089**  ERR:            BLKB    1,0               ; Error Number
0B4C40 00          0090**  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
0B4C41             0091**                                  ; - BIT 0: If set, output a space after the line number
0B4C41             0092**                                  ; - BIT 1: If set, then indent FOR/NEXT loops
0B4C41             0093**                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
0B4C41             0094**                                  ; - BIT 3: If set, then output to buffer for *EDIT
0B4C41             0095**                                  ; OPT FLAG (top nibble)
0B4C41             0096**                                  ; - BIT 4: If set, then list whilst assembling
0B4C41             0097**                                  ; - BIT 5: If set, then assembler errors are reported
0B4C41             0098**                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
0B4C41             0099**                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B4C41 00          0100**  INCREM:         BLKB    1,0               ; Auto-Increment Value
0B4C42             0101**  ;
0B4C42             0102**  ; --------------------------------------------------------------------------------------------
0B4C42             0103**  ; BEGIN MODIFIED CODE
0B4C42             0104**  ; --------------------------------------------------------------------------------------------
0B4C42             0105**  ; Originally in equs.inc
0B4C42             0106**  ;
0B4C42             0107**  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
0B4C42             0108**  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
0B4C42             0109**  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
0B4C42             0110**  ; --------------------------------------------------------------------------------------------
0B4C42             0111**  ; END MODIFIED CODE
0B4C42             0112**  ; --------------------------------------------------------------------------------------------
0B4C42             0113**  
0B4C42             0114**  ; Extra Agon-implementation specific system variables
0B4C42             0115**  ;
0B4C42 00          0116**  FLAGS:          BLKB    1,0       ; Miscellaneous flags
0B4C43             0117**                                  ; - BIT 7: Set if ESC pressed
0B4C43             0118**                                  ; - BIT 6: Set to disable ESC
0B4C43 00 00       0119**  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B4C45 00          0120**  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
0B4C46             0121**                                  ; - 0: Console
0B4C46             0122**                                  ; - 1: File
0B4C46 00          0123**  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B4C47 00          0124**  KEYDOWN:        BLKB    1,0       ; Keydown flag
0B4C48 00          0125**  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B4C49 00          0126**  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B4C4A 00 00 00    0127**  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B4C4D 00 00 00    0128**  R1:             BLKB    3,0
0B4C50             0129**  
0B4C50             0130**  ;
0B4C50             0131**  ; This must be at the end
0B4C50             0132**  ;
0B4C50             0133**  RAM_END:
0B4C50 FF FF FF FF 0134**  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B4D00             0135**  USER:							; Must be aligned on a page boundary
0B4D00             0136**  
0B4D00             0153    
0B4D00             0154    ; APPLICATION INCLUDES
0B4D00             0155        include "calcbas.inc"
0B4D00             0156    
0B4D00             0157    
0B4D00             0158    ; Storage for the argv array pointers
0B4D00             0159    min_args: equ 2
0B4D00             0160    argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B4D00 00 00 00 00 0161    argv_ptrs:		    BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B4D30             0162    _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
0B4D33             0163    
0B4D33             0164    ; GLOBAL MESSAGE STRINGS
0B4D33 55 73 61 67 0165    str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B4D4B 45 72 72 6F 0166    str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B4D54 53 75 63 63 0167    str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B4D5F             0168    
0B4D5F             0169    ; ========= MAIN LOOP =========
0B4D5F             0170    ; The main routine
0B4D5F             0171    ; IXU: argv - pointer to array of parameters
0B4D5F             0172    ;   C: argc - number of parameters
0B4D5F             0173    ; Returns:
0B4D5F             0174    ;  HL: Error code, or 0 if OK
0B4D5F             0175    
0B4D5F             0176    _main:
0B4D5F 79          0177        ld a,c              ; how many arguments?
0B4D60 FE 02       0178        cp min_args         ; not enough?
0B4D62 30 0F       0179        jr nc,main          ; if enough, go to main loop
0B4D64             0180        ; ld hl,str_usage     ; if not enough, print usage
0B4D64             0181        ; call printString
0B4D64             0182        ;                     ; fall through to _main_end_error
0B4D64             0183    
0B4D64             0184    _main_end_error:
0B4D64             0185        ; ld hl,str_error     ; print error message
0B4D64             0186        ; call printString
0B4D64 21 13 00 00 0187        ld hl,19            ; return error code 19
0B4D68 C9          0188        ret
0B4D69             0189    
0B4D69             0190    ; begin BASIC-specific end code
0B4D69             0191    ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B4D69 ED 7B 30 4D 0192    _basic_end:			LD		SP, (_sps)		; Restore the stack pointer
       0B          
0B4D6E             0193    ; fall through to _main_end_ok
0B4D6E             0194    ; end BASIC-specific end code
0B4D6E             0195    
0B4D6E             0196    _main_end_ok:
0B4D6E             0197        ; ld hl,str_success   ; print success message
0B4D6E             0198        ; call printString
0B4D6E 21 00 00 00 0199        ld hl,0             ; return 0 for success
0B4D72 C9          0200        ret
0B4D73             0201    
0B4D73             0202    ; ========= BEGIN CUSTOM MAIN LOOP =========
0B4D73             0203    main:
0B4D73 0D          0204        dec c               ; decrement the argument count to skip the program name
0B4D74 ED 32 03    0205        lea ix,ix+3         ; point to the first real argument
0B4D77 DD 27 00    0206        ld hl,(ix)          ; get the first argument in case hl doesn't land here with it
0B4D7A             0207        ; call printString  ; DEBUG: works
0B4D7A             0208        ; call print_params   ; DEBUG: works
0B4D7A             0209    
0B4D7A DD 31 00    0210        ld iy,(ix)           ; point to the expression
0B4D7D CD 78 01 0B 0211        call EXPR ; send the expression to the BASIC interpreter for evaluation and execution
0B4D81             0212        ; call print_float_dec ; print the result
0B4D81             0213    
0B4D81             0214        ; call printNewLine
0B4D81 C3 6E 4D 0B 0215        jp _main_end_ok     ; return success
0B4D85             0216    
0B4D85             0217    ; ========== HELPER FUNCTIONS ==========
0B4D85             0218    ;
0B4D85             0219    ; ; get the next argument after ix as a floating point number
0B4D85             0220    ; ; inputs: ix = pointer to the argument string
0B4D85             0221    ; ; outputs: HLH'L'C = floating point number, ix points to the next argument
0B4D85             0222    ; ; destroys: everything except iy, including prime registers
0B4D85             0223    ; get_arg_float:
0B4D85             0224    ;     lea ix,ix+3 ; point to the next argument
0B4D85             0225    ;     push ix ; preserve
0B4D85             0226    ;     ld ix,(ix)  ; point to argument string
0B4D85             0227    ;     call VAL ; convert the string to a float
0B4D85             0228    ;     pop ix ; restore
0B4D85             0229    ;     ret ; return with the value in HLH'L'C
0B4D85             0230    ;
0B4D85             0231    ; get the next argument after ix as a string
0B4D85             0232    ; inputs: ix = pointer to the argument string
0B4D85             0233    ; outputs: HL = pointer to the argument string, ix points to the next argument
0B4D85             0234    ; destroys: a, h, l, f
0B4D85             0235    get_arg_text:
0B4D85 ED 32 03    0236        lea ix,ix+3 ; point to the next argument
0B4D88 DD 27 00    0237        ld hl,(ix)  ; get the argument string
0B4D8B C9          0238        ret
0B4D8C             0239    ;
0B4D8C             0240    ; ; match the next argument after ix to the dispatch table at iy
0B4D8C             0241    ; ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B4D8C             0242    ; ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B4D8C             0243    ; ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B4D8C             0244    ; ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B4D8C             0245    ; ; destroys: a, hl, de, ix, iy, flags
0B4D8C             0246    ; match_next:
0B4D8C             0247    ;     lea ix,ix+3         ; point to the next argument
0B4D8C             0248    ; @loop:
0B4D8C             0249    ;     ld hl,(iy)          ; pointer argument dispatch record
0B4D8C             0250    ;     sign_hlu            ; check for list terminator
0B4D8C             0251    ;     jp z,@no_match      ; if a=0, return error
0B4D8C             0252    ;     inc hl              ; skip over jp instruction
0B4D8C             0253    ;     inc hl
0B4D8C             0254    ;     ld de,(ix)          ; pointer to the argument string
0B4D8C             0255    ;     call str_equal      ; compare the argument to the dispatch table entry
0B4D8C             0256    ;     jp z,@match         ; if equal, return success
0B4D8C             0257    ;     lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B4D8C             0258    ;     jp @loop            ; and loop
0B4D8C             0259    ; @no_match:
0B4D8C             0260    ;     inc a               ; no match so return a=1 and zero flag reset
0B4D8C             0261    ;     ret
0B4D8C             0262    ; @match:
0B4D8C             0263    ;     ld iy,(iy)          ; get the function pointer
0B4D8C             0264    ;     ret                 ; return a=0 and zero flag set
0B4D8C             0265    
0B4D8C             0266    ; ; same as match_next, but prints the parameter if a match is found
0B4D8C             0267    ; match_next_and_print:
0B4D8C             0268    ;     call match_next
0B4D8C             0269    ;     ret nz ; no match found
0B4D8C             0270    ;     lea ix,ix-3
0B4D8C             0271    ;     call get_arg_text ; hl points to the operator string
0B4D8C             0272    ;     call print_param
0B4D8C             0273    ;     ret
0B4D8C             0274    
0B4D8C             0275    ; ; compare two zero-terminated strings for equality, case-sensitive
0B4D8C             0276    ; ; hl: pointer to first string, de: pointer to second string
0B4D8C             0277    ; ; returns: z if equal, nz if not equal
0B4D8C             0278    ; ; destroys: a, hl, de
0B4D8C             0279    ; str_equal:
0B4D8C             0280    ;     ld a,(de)           ; get the first character
0B4D8C             0281    ;     cp (hl)             ; compare to the second character
0B4D8C             0282    ;     ret nz              ; if not equal, return
0B4D8C             0283    ;     or a
0B4D8C             0284    ;     ret z               ; if equal and zero, return
0B4D8C             0285    ;     inc hl              ; next character
0B4D8C             0286    ;     inc de
0B4D8C             0287    ;     jp str_equal        ; loop until end of string
0B4D8C             0288    
0B4D8C             0289    ; ; print the parameter string pointed to by ix
0B4D8C             0290    ; ; destroys: a, hl
0B4D8C             0291    ; print_param:
0B4D8C             0292    ;     ld hl,(ix)          ; get the parameter pointer
0B4D8C             0293    ;     call printString    ; print the parameter string
0B4D8C             0294    ;     ld a,' '            ; print a space separator
0B4D8C             0295    ;     rst.lil $10
0B4D8C             0296    ;     ret
0B4D8C             0297    
0B4D8C             0298    ; ; print the parameters
0B4D8C             0299    ; ; inputs: b = number of parameters, ix = pointer to the parameters
0B4D8C             0300    ; ; destroys: a, hl, bc
0B4D8C             0301    ; print_params:
0B4D8C             0302    ;     ld b,c              ; loop counter = number of parameters
0B4D8C             0303    ;     push ix             ; save the pointer to the parameters
0B4D8C             0304    ; @loop:
0B4D8C             0305    ;     push bc             ; save the loop counter
0B4D8C             0306    ;     call print_param    ; print the parameter
0B4D8C             0307    ;     lea ix,ix+3         ; next parameter pointer
0B4D8C             0308    ;     pop bc              ; get back the loop counter
0B4D8C             0309    ;     djnz @loop          ; loop until done
0B4D8C             0310    ;     pop ix              ; restore the pointer to the parameters
0B4D8C             0311    ;     ret
0B4D8C             0312    
0B4D8C             0313    ; debug_print:
0B4D8C             0314    ;     call printNewLine
0B4D8C             0315    ;     call dumpRegistersHexAll
0B4D8C             0316    ;     call printNewLine
0B4D8C             0317    ;     ret
0B4D8C             0318    
