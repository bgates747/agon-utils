PC     Output      Line
040000             0001    ;
040000             0002    ; Title:	test
040000             0003    ; Author:	Brandon Gates
040000             0004    ; Created:	29/10/2024
040000             0005    
040000             0006        ASSUME	ADL = 1
040000             0007        INCLUDE "mos_api.inc"
040000             0001*   ;
040000             0002*   ; Title:	AGON MOS - API for user projects
040000             0003*   ; Author:	Dean Belfield
040000             0004*   ; Created:	03/08/2022
040000             0005*   ; Last Updated:	11/11/2023
040000             0006*   ;
040000             0007*   ; Modinfo:
040000             0008*   ; 05/08/2022:	Added mos_feof
040000             0009*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*   ; 13/10/2022:	Added mos_oscli
040000             0014*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*   ; 19/05/2023:	Added sysvar_scrMode
040000             0024*   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*   ; 03/08/2023:	Added mos_setkbvector
040000             0026*   ; 10/08/2023:	Added mos_getkbmap
040000             0027*   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*   ; 09/04/2024:   Adapter to ez80asm
040000             0029*   ; VDP control (VDU 23, 0, n)
040000             0030*   ;
040000             0031*   vdp_gp:			EQU 	80h
040000             0032*   vdp_keycode:		EQU 	81h
040000             0033*   vdp_cursor:		EQU	82h
040000             0034*   vdp_scrchar:		EQU	83h
040000             0035*   vdp_scrpixel:		EQU	84h
040000             0036*   vdp_audio:		EQU	85h
040000             0037*   vdp_mode:		EQU	86h
040000             0038*   vdp_rtc:		EQU	87h
040000             0039*   vdp_keystate:		EQU	88h
040000             0040*   vdp_logicalcoords:	EQU	C0h
040000             0041*   vdp_terminalmode:	EQU	FFh
040000             0042*   
040000             0043*   ; MOS high level functions
040000             0044*   ;
040000             0045*   mos_getkey:		EQU	00h
040000             0046*   mos_load:		EQU	01h
040000             0047*   mos_save:		EQU	02h
040000             0048*   mos_cd:			EQU	03h
040000             0049*   mos_dir:		EQU	04h
040000             0050*   mos_del:		EQU	05h
040000             0051*   mos_ren:		EQU	06h
040000             0052*   mos_mkdir:		EQU	07h
040000             0053*   mos_sysvars:		EQU	08h
040000             0054*   mos_editline:		EQU	09h
040000             0055*   mos_fopen:		EQU	0Ah
040000             0056*   mos_fclose:		EQU	0Bh
040000             0057*   mos_fgetc:		EQU	0Ch
040000             0058*   mos_fputc:		EQU	0Dh
040000             0059*   mos_feof:		EQU	0Eh
040000             0060*   mos_getError:		EQU	0Fh
040000             0061*   mos_oscli:		EQU	10h
040000             0062*   mos_copy:		EQU	11h
040000             0063*   mos_getrtc:		EQU	12h
040000             0064*   mos_setrtc:		EQU	13h
040000             0065*   mos_setintvector:	EQU	14h
040000             0066*   mos_uopen:		EQU	15h
040000             0067*   mos_uclose:		EQU	16h
040000             0068*   mos_ugetc:		EQU	17h
040000             0069*   mos_uputc:		EQU 	18h
040000             0070*   mos_getfil:		EQU	19h
040000             0071*   mos_fread:		EQU	1Ah
040000             0072*   mos_fwrite:		EQU	1Bh
040000             0073*   mos_flseek:		EQU	1Ch
040000             0074*   mos_setkbvector:	EQU	1Dh
040000             0075*   mos_getkbmap:		EQU	1Eh
040000             0076*   mos_i2c_open:		EQU	1Fh
040000             0077*   mos_i2c_close:		EQU	20h
040000             0078*   mos_i2c_write:		EQU	21h
040000             0079*   mos_i2c_read:		EQU	22h
040000             0080*   
040000             0081*   
040000             0082*   ; FatFS file access functions
040000             0083*   ;
040000             0084*   ffs_fopen:		EQU	80h
040000             0085*   ffs_fclose:		EQU	81h
040000             0086*   ffs_fread:		EQU	82h
040000             0087*   ffs_fwrite:		EQU	83h
040000             0088*   ffs_flseek:		EQU	84h
040000             0089*   ffs_ftruncate:		EQU	85h
040000             0090*   ffs_fsync:		EQU	86h
040000             0091*   ffs_fforward:		EQU	87h
040000             0092*   ffs_fexpand:		EQU	88h
040000             0093*   ffs_fgets:		EQU	89h
040000             0094*   ffs_fputc:		EQU	8Ah
040000             0095*   ffs_fputs:		EQU	8Bh
040000             0096*   ffs_fprintf:		EQU	8Ch
040000             0097*   ffs_ftell:		EQU	8Dh
040000             0098*   ffs_feof:		EQU	8Eh
040000             0099*   ffs_fsize:		EQU	8Fh
040000             0100*   ffs_ferror:		EQU	90h
040000             0101*   
040000             0102*   ; FatFS directory access functions
040000             0103*   ;
040000             0104*   ffs_dopen:		EQU	91h
040000             0105*   ffs_dclose:		EQU	92h
040000             0106*   ffs_dread:		EQU	93h
040000             0107*   ffs_dfindfirst:		EQU	94h
040000             0108*   ffs_dfindnext:		EQU	95h
040000             0109*   
040000             0110*   ; FatFS file and directory management functions
040000             0111*   ;
040000             0112*   ffs_stat:		EQU	96h
040000             0113*   ffs_unlink:		EQU	97h
040000             0114*   ffs_rename:		EQU	98h
040000             0115*   ffs_chmod:		EQU	99h
040000             0116*   ffs_utime:		EQU	9Ah
040000             0117*   ffs_mkdir:		EQU	9Bh
040000             0118*   ffs_chdir:		EQU	9Ch
040000             0119*   ffs_chdrive:		EQU	9Dh
040000             0120*   ffs_getcwd:		EQU	9Eh
040000             0121*   
040000             0122*   ; FatFS volume management and system configuration functions
040000             0123*   ;
040000             0124*   ffs_mount:		EQU	9Fh
040000             0125*   ffs_mkfs:		EQU	A0h
040000             0126*   ffs_fdisk:		EQU	A1h
040000             0127*   ffs_getfree:		EQU	A2h
040000             0128*   ffs_getlabel:		EQU	A3h
040000             0129*   ffs_setlabel:		EQU	A4h
040000             0130*   ffs_setcp:		EQU	A5h
040000             0131*   
040000             0132*   ; File access modes
040000             0133*   ;
040000             0134*   fa_read:		EQU	01h
040000             0135*   fa_write:		EQU	02h
040000             0136*   fa_open_existing:	EQU	00h
040000             0137*   fa_create_new:		EQU	04h
040000             0138*   fa_create_always:	EQU	08h
040000             0139*   fa_open_always:		EQU	10h
040000             0140*   fa_open_append:		EQU	30h
040000             0141*   
040000             0142*   ; System variable indexes for api_sysvars
040000             0143*   ; Index into _sysvars in globals.asm
040000             0144*   ;
040000             0145*   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*   
040000             0178*   ; Flags for the VPD protocol
040000             0179*   ;
040000             0180*   vdp_pflag_cursor:	EQU	00000001b
040000             0181*   vdp_pflag_scrchar:	EQU	00000010b
040000             0182*   vdp_pflag_point:	EQU	00000100b
040000             0183*   vdp_pflag_audio:	EQU	00001000b
040000             0184*   vdp_pflag_mode:		EQU	00010000b
040000             0185*   vdp_pflag_rtc:		EQU	00100000b
040000             0186*   vdp_pflag_mouse:	EQU	01000000b
040000             0187*   ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*   
040000             0189*   ;
040000             0190*   ; FatFS structures
040000             0191*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*   ;
040000             0193*   ; Object ID and allocation information (FFOBJID)
040000             0194*   ;
040000             0195*   ;FFOBJID	.STRUCT
040000             0196*   ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*   ;	id:		DS	2	; Hosting volume mount ID
040000             0198*   ;	attr:		DS	1	; Object attribute;
040000             0199*   ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*   ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*   ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*   ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*   ;
040000             0204*   ; File object structure (FIL)
040000             0205*   ;
040000             0206*   ;FIL .STRUCT
040000             0207*   ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*   ;	flag:		DS	1	; File status flags
040000             0209*   ;	err:		DS	1	; Abort flag (error code)
040000             0210*   ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*   ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*   ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*   ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*   ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*   ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*   ;
040000             0217*   ; Directory object structure (DIR)
040000             0218*   ;
040000             0219*   ;DIR .STRUCT
040000             0220*   ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*   ;	dptr:		DS	4	; Current read/write offset
040000             0222*   ;	clust:		DS	4	; Current cluster
040000             0223*   ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*   ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*   ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*   ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*   ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*   ;
040000             0229*   ; File information structure (FILINFO)
040000             0230*   ;
040000             0231*   ;FILINFO .STRUCT
040000             0232*   ;	fsize:		DS 	4	; File size
040000             0233*   ;	fdate:		DS	2	; Modified date;
040000             0234*   ;	ftime:		DS	2	; Modified time
040000             0235*   ;	fattrib:	DS	1	; File attribute
040000             0236*   ;	altname:	DS	13	; Alternative file name
040000             0237*   ;	fname:		DS	256	; Primary file name
040000             0238*   ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*   
040000             0240*   ;
040000             0241*   ; Macro for calling the API
040000             0242*   ; Parameters:
040000             0243*   ; - function: One of the function numbers listed above
040000             0244*   ;
040000             0245*   			MACRO	MOSCALL function
040000             0246*   			LD	A, function
040000             0247*   			RST.L	08h
040000             0248*   			ENDMACRO
040000             0008        ORG 0x0B0000 ; Is a moslet
0B0000             0009    
0B0000             0010        MACRO PROGNAME
0B0000             0011        ASCIZ "calcbas"
0B0000             0012        ENDMACRO
0B0000             0013    
0B0000             0014    ; STANDARD MOSLET INCLUDES
0B0000             0015        include "calcbas.inc"
0B0000             0001*   ;
0B0000             0002*   ; Title:	Copy - Initialisation Code
0B0000             0003*   ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*   ; Created:	06/11/2022
0B0000             0005*   ; Last Updated:	26/12/2022
0B0000             0006*   ;
0B0000             0007*   ; Modinfo:
0B0000             0008*   ; 17/12/2022:	Added parameter processing
0B0000             0009*   ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*   ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*   ;
0B0000             0012*   ; Start in ADL mode
0B0000             0013*   ;
0B0000 C3 45 00 0B 0014*   			JP	_start			; Jump to start
0B0004             0015*   ;
0B0004             0016*   ; The header stuff is from byte 64 onwards
0B0004             0017*   ;
0B0004             0018*   
0B0004             0019*   _exec_name:
0B0004             0020*   			PROGNAME			; The executable name, only used in argv
0B0004 63 61 6C 63 0001*M      ASCIZ "calcbas"
       62 61 73 00 
0B000C             0021*   
0B000C FF FF FF FF 0022*   			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0023*   
0B0040 4D 4F 53    0024*   			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0025*   			DB	00h			; MOS header version 0
0B0044 01          0026*   			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0027*   ;
0B0045             0028*   ; And the code follows on immediately after the header
0B0045             0029*   ;
0B0045 F5          0030*   _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0031*   			PUSH	BC
0B0047 D5          0032*   			PUSH	DE
0B0048 DD E5       0033*   			PUSH	IX
0B004A FD E5       0034*   			PUSH	IY
0B004C ED 6E       0035*   			LD	A, MB			; Save MB
0B004E F5          0036*   			PUSH 	AF
0B004F AF          0037*   			XOR 	A
0B0050 ED 6D       0038*   			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0039*   
0B0052 DD 21 67 46 0040*   			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0041*   			PUSH	IX
0B0059 CD 70 00 0B 0042*   			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0043*   			POP	IX			; IX: argv
0B005F 06 00       0044*   			LD	B, 0			;  C: argc
0B0061 CD C3 46 0B 0045*   			CALL	_main			; Start user code
0B0065             0046*   
0B0065 F1          0047*   			POP 	AF
0B0066 ED 6D       0048*   			LD	MB, A
0B0068 FD E1       0049*   			POP	IY			; Restore registers
0B006A DD E1       0050*   			POP	IX
0B006C D1          0051*   			POP	DE
0B006D C1          0052*   			POP	BC
0B006E F1          0053*   			POP	AF
0B006F C9          0054*   			RET
0B0070             0055*   
0B0070             0056*   ; Parse the parameter string into a C array
0B0070             0057*   ; Parameters
0B0070             0058*   ; - HL: Address of parameter string
0B0070             0059*   ; - IX: Address for array pointer storage
0B0070             0060*   ; Returns:
0B0070             0061*   ; -  C: Number of parameters parsed
0B0070             0062*   ;
0B0070 01 04 00 0B 0063*   _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0064*   			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0065*   			LEA     IX, IX+3
0B007A CD 98 00 0B 0066*   			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0067*   ;
0B007E 01 01 00 00 0068*   			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0069*   			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0070*   ;
0B0084             0071*   ; _parse_params_1:
0B0084             0072*   ; 			PUSH	BC			; Stack ARGC
0B0084             0073*   ; 			PUSH	HL			; Stack start address of token
0B0084             0074*   ; 			CALL	_get_token		; Get the next token
0B0084             0075*   ; 			LD	A, C			; A: Length of the token in characters
0B0084             0076*   ; 			POP	DE			; Start address of token (was in HL)
0B0084             0077*   ; 			POP	BC			; ARGC
0B0084             0078*   ; 			OR	A			; Check for A=0 (no token found) OR at end of string
0B0084             0079*   ; 			RET	Z
0B0084             0080*   ; ;
0B0084             0081*   ; 			LD	(IX+0), DE		; Store the pointer to the token
0B0084             0082*   ; 			PUSH	HL			; DE=HL
0B0084             0083*   ; 			POP	DE
0B0084             0084*   ; 			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0084             0085*   ; 			XOR	A
0B0084             0086*   ; 			LD	(DE), A			; Zero-terminate the token
0B0084             0087*   ; 			LEA  	IX, IX+3			; Advance to next pointer position
0B0084             0088*   			; INC	C			; Increment ARGC
0B0084             0089*   			; LD	A, C			; Check for C >= A
0B0084             0090*   			; CP	B
0B0084             0091*   			; JR	C, _parse_params_1	; And loop
0B0084             0092*   			; RET
0B0084             0093*   
0B0084             0094*   ; instead of all that we drop hl into (ix) and return
0B0084             0095*   ; leaving us with two parameters:
0B0084             0096*   ; - the app name
0B0084             0097*   ; - whatever the user entered
0B0084 DD 2F 00    0098*               ld (ix),hl
0B0087 0C          0099*   			INC	C			; Increment ARGC
0B0088 C9          0100*               ret
0B0089             0101*   
0B0089             0102*   ; Get the next token
0B0089             0103*   ; Parameters:
0B0089             0104*   ; - HL: Address of parameter string
0B0089             0105*   ; Returns:
0B0089             0106*   ; - HL: Address of first character after token
0B0089             0107*   ; -  C: Length of token (in characters)
0B0089             0108*   ;
0B0089 0E 00       0109*   _get_token:		LD	C, 0			; Initialise length
0B008B 7E          0110*   @@:			LD	A, (HL)			; Get the character from the parameter string
0B008C B7          0111*   			OR	A			; Exit if 0 (end of parameter string in MOS)
0B008D C8          0112*   			RET 	Z
0B008E FE 0D       0113*   			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B0090 C8          0114*   			RET	Z
0B0091 FE 20       0115*   			CP	' '			; Exit if space (end of token)
0B0093 C8          0116*   			RET	Z
0B0094 23          0117*   			INC	HL			; Advance to next character
0B0095 0C          0118*   			INC 	C			; Increment length
0B0096 18 F3       0119*   			JR	@B
0B0098             0120*   
0B0098             0121*   ; Skip spaces in the parameter string
0B0098             0122*   ; Parameters:
0B0098             0123*   ; - HL: Address of parameter string
0B0098             0124*   ; Returns:
0B0098             0125*   ; - HL: Address of next none-space character
0B0098             0126*   ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B0098             0127*   ;
0B0098 7E          0128*   _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B0099 FE 20       0129*   			CP	' '			; Exit if not space
0B009B C0          0130*   			RET	NZ
0B009C 23          0131*   			INC	HL			; Advance to next character
0B009D 18 F9       0132*   			JR	_skip_spaces		; Increment length
0B009F             0016        include "parse.inc"
0B009F             0001*   ;
0B009F             0002*   ; Title:	Number Parsing Functions
0B009F             0003*   ; Author:	Dean Belfield
0B009F             0004*   ; Created:	15/11/2022
0B009F             0005*   ; Last Updated:	15/11/2022
0B009F             0006*   ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B009F             0007*   ; Modinfo:
0B009F             0008*   ; 2024/04/08    Adapt for ez80asm
0B009F             0009*   
0B009F             0010*   ; Read a number and convert to binary
0B009F             0011*   ; If prefixed with &, will read as hex, otherwise decimal
0B009F             0012*   ;   Inputs: HL: Pointer in string buffer
0B009F             0013*   ;  Outputs: HL: Updated text pointer
0B009F             0014*   ;           DE: Value
0B009F             0015*   ;            A: Terminator (spaces skipped)
0B009F             0016*   ;            F: Carry set if valid number, otherwise reset
0B009F             0017*   ; Destroys: A,D,E,H,L,F
0B009F             0018*   ;
0B009F 11 00 00 00 0019*   ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00A3 CD 98 00 0B 0020*   			CALL		_skip_spaces		; Skip whitespace
0B00A7 7E          0021*   			LD		A, (HL)			; Read first character
0B00A8 B7          0022*   			OR		A			; Check for end of string
0B00A9 C8          0023*   			RET		Z			; Return with no carry if not
0B00AA C5          0024*   			PUSH		BC			; Preserve BC
0B00AB FE 26       0025*   			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00AD 20 23       0026*   			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00AF 23          0027*   			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00B0             0028*   ;
0B00B0 7E          0029*   ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00B1 CD F3 00 0B 0030*   			CALL   	 	UPPRC			; Convert to uppercase
0B00B5 D6 30       0031*   			SUB		'0'			; Normalise to 0
0B00B7 38 37       0032*   			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B00B9 FE 0A       0033*   			CP 		10			; Check if >= 10
0B00BB 38 06       0034*   			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B00BD D6 07       0035*   			SUB 		7			; Adjust ASCII A-F to nibble
0B00BF FE 10       0036*   			CP 		16			; Check for > F
0B00C1 30 2D       0037*   			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B00C3             0038*   ;
0B00C3 E5          0039*   ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B00C4 D5          0040*   			PUSH		DE			; LD HL, DE
0B00C5 E1          0041*   			POP		HL
0B00C6 29          0042*   			ADD		HL, HL
0B00C7 29          0043*   			ADD		HL, HL
0B00C8 29          0044*   			ADD		HL, HL
0B00C9 29          0045*   			ADD		HL, HL
0B00CA E5          0046*   			PUSH		HL			; LD DE, HL
0B00CB D1          0047*   			POP		DE
0B00CC E1          0048*   			POP		HL			; Restore HL
0B00CD B3          0049*   			OR      	E			; OR the new digit in to the least significant nibble
0B00CE 5F          0050*   			LD      	E, A
0B00CF             0051*   ;
0B00CF 23          0052*   			INC		HL			; Onto the next character
0B00D0 18 DE       0053*   			JR      	ASC_TO_NUMBER1		; And loop
0B00D2             0054*   ;
0B00D2 7E          0055*   ASC_TO_NUMBER3:		LD		A, (HL)
0B00D3 D6 30       0056*   			SUB		'0'			; Normalise to 0
0B00D5 38 19       0057*   			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B00D7 FE 0A       0058*   			CP		10			; Check if >= 10
0B00D9 30 15       0059*   			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B00DB             0060*   ;
0B00DB E5          0061*   			PUSH		HL			; Stack HL
0B00DC D5          0062*   			PUSH		DE			; LD HL, DE
0B00DD E1          0063*   			POP		HL
0B00DE E5          0064*   			PUSH		HL			; LD BC, HL
0B00DF C1          0065*   			POP		BC
0B00E0 29          0066*   			ADD		HL, HL 			; x 2
0B00E1 29          0067*   			ADD		HL, HL 			; x 4
0B00E2 09          0068*   			ADD		HL, BC 			; x 5
0B00E3 29          0069*   			ADD		HL, HL 			; x 10
0B00E4 01 00 00 00 0070*   			LD		BC, 0
0B00E8 4F          0071*   			LD 		C, A			; LD BCU, A
0B00E9 09          0072*   			ADD		HL, BC			; Add BCU to HL
0B00EA E5          0073*   			PUSH		HL			; LD DE, HL
0B00EB D1          0074*   			POP		DE
0B00EC E1          0075*   			POP		HL			; Restore HL
0B00ED             0076*   ;
0B00ED 23          0077*   			INC		HL
0B00EE 18 E2       0078*   			JR		ASC_TO_NUMBER3
0B00F0 C1          0079*   ASC_TO_NUMBER4:		POP		BC
0B00F1 37          0080*   			SCF					; We have a valid number so set carry
0B00F2 C9          0081*   			RET
0B00F3             0082*   
0B00F3             0083*   
0B00F3             0084*   ; Convert a character to upper case
0B00F3             0085*   ;  A: Character to convert
0B00F3             0086*   ;
0B00F3 E6 7F       0087*   UPPRC:  		AND     	7FH
0B00F5 FE 60       0088*   			CP      	'`'
0B00F7 D8          0089*   			RET     	C
0B00F8 E6 5F       0090*   			AND     	5FH			; Convert to upper case
0B00FA C9          0091*   			RET
0B00FB             0092*   
0B00FB             0093*   
0B00FB             0094*   ;------------------------------------------------------------------------
0B00FB             0095*   ; Read a number and convert to binary (decimal only)
0B00FB             0096*   ; Inputs: hl: Pointer in string buffer
0B00FB             0097*   ; Outputs: hl: Updated text pointer
0B00FB             0098*   ;         de: Value
0B00FB             0099*   ;         a: Terminator (spaces skipped)
0B00FB             0100*   ;         f: Carry set if valid number, otherwise reset
0B00FB             0101*   ; Destroys: a, d, e, h, l, f
0B00FB             0102*   ;------------------------------------------------------------------------
0B00FB             0103*   asc_to_s24:
0B00FB 3E 01       0104*       ld a,1 ; set sign flag
0B00FD 32 49 01 0B 0105*       ld (@sign),a ; store sign flag
0B0101             0106*   
0B0101 11 00 00 00 0107*       ld de, 0 ; initialise de
0B0105             0108*       ; call _skip_spaces ; skip whitespace
0B0105             0109*   
0B0105 7E          0110*       ld a, (hl) ; read first character
0B0106 B7          0111*       or a ; check for end of string
0B0107 C8          0112*       ret z ; return with no carry if not
0B0108             0113*   
0B0108 C5          0114*       push bc ; preserve bc
0B0109             0115*   
0B0109 FE 2D       0116*       cp '-' ; check for negative number
0B010B C2 15 01 0B 0117*       jp nz,@loop ; number is positive, nothing more to do
0B010F AF          0118*       xor a ; sign flag to zero
0B0110 32 49 01 0B 0119*       ld (@sign),a ; store sign flag
0B0114 23          0120*       inc hl ; skip '-'
0B0115             0121*   
0B0115             0122*   @loop:
0B0115 7E          0123*       ld a, (hl)
0B0116 D6 30       0124*       sub '0' ; normalise to 0
0B0118 38 19       0125*       jr c, @integer_end ; return if < ascii '0'
0B011A FE 0A       0126*       cp 10 ; check if >= 10
0B011C 30 15       0127*       jr nc, @integer_end ; return if >= 10
0B011E E5          0128*       push hl ; stack hl
0B011F D5          0129*       push de ; ld hl, de
0B0120 E1          0130*       pop hl
0B0121 E5          0131*       push hl ; ld bc, hl
0B0122 C1          0132*       pop bc
0B0123 29          0133*       add hl, hl ; x 2
0B0124 29          0134*       add hl, hl ; x 4
0B0125 09          0135*       add hl, bc ; x 5
0B0126 29          0136*       add hl, hl ; x 10
0B0127 01 00 00 00 0137*       ld bc, 0
0B012B 4F          0138*       ld c, a ; ld bcu, a
0B012C 09          0139*       add hl, bc ; add bcu to hl
0B012D E5          0140*       push hl ; ld de, hl
0B012E D1          0141*       pop de
0B012F E1          0142*       pop hl ; restore hl
0B0130 23          0143*       inc hl
0B0131 18 E2       0144*       jr @loop
0B0133             0145*   
0B0133             0146*   @integer_end:
0B0133 C1          0147*       pop bc ; send bc back how she came in
0B0134 3A 49 01 0B 0148*       ld a, (@sign) ; get sign flag
0B0138 3D          0149*       dec a ; check if negative
0B0139 F2 47 01 0B 0150*       jp p,@pos ; positive number
0B013D             0151*   
0B013D             0152*   ; Negate de
0B013D E5          0153*       push hl ; save text pointer
0B013E 21 00 00 00 0154*       ld hl, 0
0B0142 AF          0155*       xor a ; clear carry
0B0143 ED 52       0156*       sbc hl, de ; subtract DE from HL
0B0145 EB          0157*       ex de, hl ; DE = 0-HL
0B0146 E1          0158*       pop hl ; restore text pointer
0B0147             0159*   
0B0147             0160*   @pos:
0B0147 37          0161*       scf ; we have a valid number so set carry
0B0148 C9          0162*       ret
0B0149             0163*   
0B0149 00          0164*   @sign: db 0 ; sign flag buffer
0B014A             0165*   
0B014A             0166*   
0B014A             0167*   ;------------------------------------------------------------------------
0B014A             0168*   ; Read a number and convert to binary (decimal only)
0B014A             0169*   ; Inputs: hl: Pointer in string buffer
0B014A             0170*   ; Outputs: hl: Updated text pointer
0B014A             0171*   ;         de: Value
0B014A             0172*   ;         a: Terminator (spaces skipped)
0B014A             0173*   ;         f: Carry set if valid number, otherwise reset
0B014A             0174*   ; Destroys: a, d, e, h, l, f
0B014A             0175*   ;------------------------------------------------------------------------
0B014A             0176*   asc_to_s168:
0B014A 3E 01       0177*       ld a,1 ; set sign flag
0B014C 32 09 02 0B 0178*       ld (@sign),a ; store sign flag
0B0150             0179*   
0B0150 11 00 00 00 0180*       ld de, 0 ; initialise de
0B0154 ED 53 01 02 0181*       ld (@result), de ; clear low bytes of result buffer
       0B          
0B0159 ED 53 05 02 0182*       ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B015E             0183*   
0B015E             0184*       ; call _skip_spaces ; skip whitespace
0B015E             0185*   
0B015E 7E          0186*       ld a, (hl) ; read first character
0B015F B7          0187*       or a ; check for end of string
0B0160 C8          0188*       ret z ; return with no carry if not
0B0161             0189*   
0B0161 C5          0190*       push bc ; preserve bc
0B0162             0191*   
0B0162 FE 2D       0192*       cp '-' ; check for negative number
0B0164 C2 6E 01 0B 0193*       jp nz,@loop ; number is positive, nothing more to do
0B0168 AF          0194*       xor a ; sign flag to zero
0B0169 32 09 02 0B 0195*       ld (@sign),a ; store sign flag
0B016D 23          0196*       inc hl ; skip '-'
0B016E             0197*   
0B016E             0198*   @loop:
0B016E 7E          0199*       ld a, (hl)
0B016F             0200*   
0B016F             0201*   ; chcek for decimal point
0B016F FE 2E       0202*       cp '.' ; check for decimal point
0B0171 CA B2 01 0B 0203*       jp z,@fractional_start ; jump to fractional part
0B0175             0204*   
0B0175             0205*   ; process integer part
0B0175 D6 30       0206*       sub '0' ; normalise to 0
0B0177 38 19       0207*       jr c, @integer_end ; return if < ascii '0'
0B0179 FE 0A       0208*       cp 10 ; check if >= 10
0B017B 30 15       0209*       jr nc, @integer_end ; return if >= 10
0B017D E5          0210*       push hl ; stack hl
0B017E D5          0211*       push de ; ld hl, de
0B017F E1          0212*       pop hl
0B0180 E5          0213*       push hl ; ld bc, hl
0B0181 C1          0214*       pop bc
0B0182 29          0215*       add hl, hl ; x 2
0B0183 29          0216*       add hl, hl ; x 4
0B0184 09          0217*       add hl, bc ; x 5
0B0185 29          0218*       add hl, hl ; x 10
0B0186 01 00 00 00 0219*       ld bc, 0
0B018A 4F          0220*       ld c, a ; ld bcu, a
0B018B 09          0221*       add hl, bc ; add bcu to hl
0B018C E5          0222*       push hl ; ld de, hl
0B018D D1          0223*       pop de
0B018E E1          0224*       pop hl ; restore hl
0B018F 23          0225*       inc hl
0B0190 18 DC       0226*       jr @loop
0B0192             0227*   
0B0192             0228*   @integer_end:
0B0192 ED 53 02 02 0229*       ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0197             0230*   
0B0197             0231*   @end:
0B0197 C1          0232*       pop bc ; send bc back how she came in
0B0198 ED 5B 01 02 0233*       ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B019D 3A 09 02 0B 0234*       ld a, (@sign) ; get sign flag
0B01A1 3D          0235*       dec a ; check if negative
0B01A2 F2 B0 01 0B 0236*       jp p,@pos ; positive number
0B01A6             0237*   
0B01A6             0238*   ; Negate de
0B01A6 E5          0239*       push hl ; save text pointer
0B01A7 21 00 00 00 0240*       ld hl, 0
0B01AB AF          0241*       xor a ; clear carry
0B01AC ED 52       0242*       sbc hl, de ; subtract DE from HL
0B01AE EB          0243*       ex de, hl ; DE = 0-HL
0B01AF E1          0244*       pop hl ; restore text pointer
0B01B0             0245*   
0B01B0             0246*   @pos:
0B01B0 37          0247*       scf ; we have a valid number so set carry
0B01B1 C9          0248*       ret
0B01B2             0249*   
0B01B2             0250*   @fractional_start:
0B01B2 DD E5       0251*       push ix                    ; preserve ix
0B01B4 ED 53 02 02 0252*       ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01B9 06 03       0253*       ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B01BB 11 00 00 00 0254*       ld de, 0                   ; Initialize DE as the fractional accumulator
0B01BF DD 21 0A 02 0255*       ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B01C4 23          0256*       inc hl                     ; Skip decimal point
0B01C5             0257*   
0B01C5             0258*   @fractional_loop:
0B01C5 7E          0259*       ld a, (hl)                 ; Load next character
0B01C6 D6 30       0260*       sub '0'                    ; Normalize ASCII to decimal
0B01C8 38 1C       0261*       jr c, @end_fraction        ; Exit if < '0'
0B01CA FE 0A       0262*       cp 10
0B01CC 30 18       0263*       jr nc, @end_fraction       ; Exit if >= 10
0B01CE             0264*   
0B01CE             0265*       ; Multiply the current fractional accumulator by 10
0B01CE E5          0266*       push hl                    ; Save char pointer
0B01CF F5          0267*       push af                    ; Save the digit
0B01D0 EB          0268*       ex de, hl
0B01D1 E5          0269*       push hl
0B01D2 29          0270*       add hl,hl ; * 2
0B01D3 29          0271*       add hl,hl ; * 4
0B01D4 D1          0272*       pop de
0B01D5 19          0273*       add hl,de ; * 5
0B01D6 29          0274*       add hl,hl ; * 10
0B01D7 11 00 00 00 0275*       ld de, 0                   ; Clear DEU
0B01DB F1          0276*       pop af                     ; Restore the current digit
0B01DC 5F          0277*       ld e, a                    ; Load the digit into E
0B01DD 19          0278*       add hl, de                 ; Add the digit to the accumulator
0B01DE EB          0279*       ex de, hl                  ; Result back to DE
0B01DF ED 32 03    0280*       lea ix,ix+3                ; Advance IX to the next scaling factor
0B01E2 E1          0281*       pop hl                     ; Restore char pointer
0B01E3 23          0282*       inc hl                     ; Move to the next character
0B01E4 10 DF       0283*       djnz @fractional_loop      ; Loop if more digits to process
0B01E6             0284*   
0B01E6             0285*   @end_fraction:
0B01E6             0286*   ; Final scaling based on number of fractional digits processed
0B01E6 ED 53 06 02 0287*       ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B01EB 2A 05 02 0B 0288*       ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B01EF             0289*   
0B01EF DD 17 00    0290*       ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B01F2 CD FD 08 0B 0291*       call udiv24                ; Perform 24-bit division to scale down
0B01F6 7B          0292*       ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B01F7 32 01 02 0B 0293*       ld (@result), a            ; Store fractional part in result buffer
0B01FB DD E1       0294*       pop ix                     ; Restore ix
0B01FD C3 97 01 0B 0295*       jp @end                    ; Final sign check and flag setup
0B0201             0296*   
0B0201             0297*   @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0205             0298*   @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0209 00          0299*   @sign: db 0                    ; Sign flag buffer
0B020A             0300*   
0B020A             0301*   powers_of_10:
0B020A 01 00 00    0302*       dl 1                       ; 10^0
0B020D 0A 00 00    0303*       dl 10                      ; 10^1
0B0210 64 00 00    0304*       dl 100                     ; 10^2
0B0213 E8 03 00    0305*       dl 1000                    ; 10^3
0B0216 10 27 00    0306*       dl 10000                   ; 10^4
0B0219             0017    
0B0219             0018    ; API INCLUDES
0B0219             0019        include "functions.inc"
0B0219             0001*       MACRO printChar char
0B0219             0002*           LD A, char
0B0219             0003*           RST.LIL 10h
0B0219             0004*       ENDMACRO
0B0219             0005*   
0B0219             0006*   ; test the sign of HL
0B0219             0007*   ; inputs: HL obviously
0B0219             0008*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0219             0009*   ; destroys: flags
0B0219             0010*       MACRO sign_hlu
0B0219             0011*           add hl,de
0B0219             0012*           or a
0B0219             0013*           sbc hl,de
0B0219             0014*       ENDMACRO
0B0219             0015*   
0B0219             0016*   ; Simulated call to subroutine at HL
0B0219             0017*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0219             0018*   ; outputs: whatever the subroutine does, including HL and BC
0B0219             0019*   ; destroys: only what the subroutine does, but always BC
0B0219             0020*       MACRO callHL
0B0219             0021*           ld bc,$+7     ; Address of first instruction after the jump
0B0219             0022*           push bc       ; which constitutes the return address
0B0219             0023*           jp   (hl)     ; Jump to the address in HL
0B0219             0024*       ENDMACRO
0B0219             0025*   
0B0219             0026*   ; Simulated call to subroutine at IX
0B0219             0027*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0219             0028*   ; outputs: whatever the subroutine does, including IX and BC
0B0219             0029*   ; destroys: only what the subroutine does, but always BC
0B0219             0030*       MACRO callIX
0B0219             0031*           ld bc,$+7     ; Address of first instruction after the jump
0B0219             0032*           push bc       ; which constitutes the return address
0B0219             0033*           jp   (ix)     ; Jump to the address in IX
0B0219             0034*       ENDMACRO
0B0219             0035*   
0B0219             0036*   ; Simulated call to soubroutinte at IY
0B0219             0037*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0219             0038*   ; outputs: whatever the subroutine does, including IY and BC
0B0219             0039*   ; destroys: only what the subroutine does, but always BC
0B0219             0040*       MACRO callIY
0B0219             0041*           ld bc,$+7     ; Address of first instruction after the jump
0B0219             0042*           push bc       ; which constitutes the return address
0B0219             0043*           jp   (iy)     ; Jump to the address in IY
0B0219             0044*       ENDMACRO
0B0219             0045*   
0B0219             0046*   ; put the value in HLU into the accumulator
0B0219             0047*   ; destroys: af
0B0219             0048*       MACRO HLU_TO_A
0B0219             0049*           push hl ; 4 cycles
0B0219             0050*           inc sp ; 1 cycle
0B0219             0051*           pop af  ; 4 cycles
0B0219             0052*           dec sp ; 1 cycle
0B0219             0053*                  ; 10 cycles total
0B0219             0054*       ENDMACRO
0B0219             0055*   
0B0219             0056*       MACRO PUSH_ALL
0B0219             0057*           ex af,af'
0B0219             0058*           exx
0B0219             0059*           push af
0B0219             0060*           push hl
0B0219             0061*           push bc
0B0219             0062*           push de
0B0219             0063*   
0B0219             0064*           ex af,af'
0B0219             0065*           exx
0B0219             0066*           push af
0B0219             0067*           push hl
0B0219             0068*           push bc
0B0219             0069*           push de
0B0219             0070*           push ix
0B0219             0071*           push iy
0B0219             0072*       ENDMACRO
0B0219             0073*   
0B0219             0074*       MACRO POP_ALL
0B0219             0075*           pop iy
0B0219             0076*           pop ix
0B0219             0077*           pop de
0B0219             0078*           pop bc
0B0219             0079*           pop hl
0B0219             0080*           pop af
0B0219             0081*           ex af,af'
0B0219             0082*           exx
0B0219             0083*   
0B0219             0084*           pop de
0B0219             0085*           pop bc
0B0219             0086*           pop hl
0B0219             0087*           pop af
0B0219             0088*           ex af,af'
0B0219             0089*           exx
0B0219             0090*       ENDMACRO
0B0219             0091*   
0B0219             0092*   A_TO_HLU:
0B0219             0093*       ; call is 7 cycles
0B0219 22 26 02 0B 0094*       ld (@scratch),hl ; 7 cycles
0B021D 32 28 02 0B 0095*       ld (@scratch+2),a ; 5 cycles
0B0221 2A 26 02 0B 0096*       ld hl,(@scratch) ; 7 cycles
0B0225 C9          0097*       ret ; 6 cycles
0B0226             0098*           ; 25 cycles total
0B0226 00 00 00    0099*   @scratch: dl 0
0B0229             0100*   
0B0229             0101*       ; TODO: implement this
0B0229             0102*       ; MACRO A_TO_HLU
0B0229             0103*       ;     push.s af
0B0229             0104*       ;     inc sp
0B0229             0105*       ;     push.s hl
0B0229             0106*       ;     pop hl
0B0229             0107*       ;     inc sp
0B0229             0108*       ;     inc sp
0B0229             0109*       ; ENDMACRO
0B0229             0110*   
0B0229             0111*   ; Print a zero-terminated string inline with code, e.g.:
0B0229             0112*   ;
0B0229             0113*   ;    call printInline
0B0229             0114*   ;    ASCIZ "Hello, world!\r\n"
0B0229             0115*   ;
0B0229             0116*   ; Destroys: HL,AF
0B0229             0117*   printInline:
0B0229 E1          0118*       pop hl ; get the return address = pointer to start of string
0B022A CD 30 02 0B 0119*       call printString ; HL advances to end of string
0B022E E5          0120*       push hl ; restore the return address = pointer to end of string
0B022F C9          0121*       ret
0B0230             0122*   
0B0230             0123*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0230             0124*   ; Print a zero-terminated string
0B0230             0125*   ; HL: Pointer to string
0B0230             0126*   printString:
0B0230 C5          0127*   	PUSH	BC
0B0231 01 00 00 00 0128*   	LD		BC,0
0B0235 3E 00       0129*   	LD 	 	A,0
0B0237 5B DF       0130*   	RST.LIL 18h
0B0239 C1          0131*   	POP		BC
0B023A C9          0132*   	RET
0B023B             0133*   ; print a VDU sequence
0B023B             0134*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B023B             0135*   sendVDUsequence:
0B023B C5          0136*   	PUSH	BC
0B023C 01 00 00 00 0137*   	LD		BC, 0
0B0240 4E          0138*   	LD		C, (HL)
0B0241 5B DF       0139*   	RST.LIL	18h
0B0243 C1          0140*   	POP		BC
0B0244 C9          0141*   	RET
0B0245             0142*   ; Print Newline sequence to VDP
0B0245             0143*   printNewLine:
0B0245 F5          0144*       push af ; for some reason rst.lil 10h sets carry flag
0B0246 3E 0D       0145*   	LD	A, '\r'
0B0248 5B D7       0146*   	RST.LIL 10h
0B024A 3E 0A       0147*   	LD	A, '\n'
0B024C 5B D7       0148*   	RST.LIL 10h
0B024E F1          0149*       pop af
0B024F C9          0150*   	RET
0B0250             0151*   
0B0250             0152*   ; Print a 24-bit HEX number
0B0250             0153*   ; HLU: Number to print
0B0250             0154*   printHex24:
0B0250             0155*   	; PUSH	HL      ; 4 cycles
0B0250             0156*   	; LD		HL, 2   ; 4 cycles
0B0250             0157*   	; ADD		HL, SP  ; 1 cycle
0B0250             0158*   	; LD		A, (HL) ; 2 cycles
0B0250             0159*   	; POP		HL      ; 4 cycles
0B0250             0160*       ;                 ; 15 cycles total
0B0250 E5          0161*       push hl ; 4 cycles
0B0251 33          0162*       inc sp ; 1 cycle
0B0252 F1          0163*       pop af  ; 4 cycles
0B0253 3B          0164*       dec sp ; 1 cycle
0B0254             0165*               ; 10 cycles total
0B0254 CD 5E 02 0B 0166*   	CALL	printHex8
0B0258             0167*   ; Print a 16-bit HEX number
0B0258             0168*   ; HL: Number to print
0B0258             0169*   printHex16:
0B0258 7C          0170*   	LD		A,H
0B0259 CD 5E 02 0B 0171*   	CALL	printHex8
0B025D 7D          0172*   	LD		A,L
0B025E             0173*   ; Print an 8-bit HEX number
0B025E             0174*   ; A: Number to print
0B025E             0175*   printHex8:
0B025E 4F          0176*   	LD		C,A
0B025F 1F          0177*   	RRA
0B0260 1F          0178*   	RRA
0B0261 1F          0179*   	RRA
0B0262 1F          0180*   	RRA
0B0263 CD 68 02 0B 0181*   	CALL	@F
0B0267 79          0182*   	LD		A,C
0B0268             0183*   @@:
0B0268 E6 0F       0184*   	AND		0Fh
0B026A C6 90       0185*   	ADD		A,90h
0B026C 27          0186*   	DAA
0B026D CE 40       0187*   	ADC		A,40h
0B026F 27          0188*   	DAA
0B0270 5B D7       0189*   	RST.LIL	10h
0B0272 C9          0190*   	RET
0B0273             0191*   
0B0273             0192*   printHexA:
0B0273 F5          0193*       push af
0B0274 C5          0194*       push bc
0B0275 CD 5E 02 0B 0195*       call printHex8
0B0279 3E 20       0196*       ld a,' '
0B027B 5B D7       0197*       rst.lil 10h
0B027D C1          0198*       pop bc
0B027E F1          0199*       pop af
0B027F C9          0200*       ret
0B0280             0201*   
0B0280             0202*   printHexHL:
0B0280 F5          0203*       push af
0B0281 C5          0204*       push bc
0B0282 CD 58 02 0B 0205*       call printHex16
0B0286 3E 20       0206*       ld a,' '
0B0288 5B D7       0207*       rst.lil 10h
0B028A C1          0208*       pop bc
0B028B F1          0209*       pop af
0B028C C9          0210*       ret
0B028D             0211*   
0B028D             0212*   printHexUHL:
0B028D F5          0213*       push af
0B028E C5          0214*       push bc
0B028F CD 50 02 0B 0215*       call printHex24
0B0293 3E 20       0216*       ld a,' '
0B0295 5B D7       0217*       rst.lil 10h
0B0297 C1          0218*       pop bc
0B0298 F1          0219*       pop af
0B0299 C9          0220*       ret
0B029A             0221*   
0B029A             0222*   printHexAUHL:
0B029A F5          0223*       push af
0B029B C5          0224*       push bc
0B029C CD 5E 02 0B 0225*       call printHex8
0B02A0 3E 2E       0226*       ld a,'.'
0B02A2 5B D7       0227*       rst.lil 10h
0B02A4 CD 50 02 0B 0228*       call printHex24
0B02A8 3E 20       0229*       ld a,' '
0B02AA 5B D7       0230*       rst.lil 10h
0B02AC C1          0231*       pop bc
0B02AD F1          0232*       pop af
0B02AE C9          0233*       ret
0B02AF             0234*   
0B02AF             0235*   printHexABHL:
0B02AF             0236*   ; preserve registers
0B02AF C5          0237*       push bc ; b will be ok c will not
0B02B0 F5          0238*       push af ; will get totally destroyed
0B02B1             0239*   ; print a
0B02B1 CD 5E 02 0B 0240*       call printHex8
0B02B5             0241*   ; print b
0B02B5 78          0242*       ld a,b
0B02B6 CD 5E 02 0B 0243*       call printHex8
0B02BA             0244*   ; print hl
0B02BA CD 58 02 0B 0245*       call printHex16
0B02BE             0246*   ; restore registers
0B02BE F1          0247*       pop af
0B02BF C1          0248*       pop bc
0B02C0 C9          0249*       ret
0B02C1             0250*   
0B02C1             0251*   printHexBHL:
0B02C1             0252*   ; preserve registers
0B02C1 C5          0253*       push bc ; b will be ok c will not
0B02C2 F5          0254*       push af ; will get totally destroyed
0B02C3             0255*   ; print b
0B02C3 78          0256*       ld a,b
0B02C4 CD 5E 02 0B 0257*       call printHex8
0B02C8             0258*   ; print hl
0B02C8 CD 58 02 0B 0259*       call printHex16
0B02CC             0260*   ; restore registers
0B02CC F1          0261*       pop af
0B02CD C1          0262*       pop bc
0B02CE C9          0263*       ret
0B02CF             0264*   
0B02CF             0265*   printHexCDE:
0B02CF             0266*   ; preserve registers
0B02CF C5          0267*       push bc ; b will be ok c will not
0B02D0 F5          0268*       push af ; will get totally destroyed
0B02D1             0269*   ; print c
0B02D1 79          0270*       ld a,c
0B02D2 CD 5E 02 0B 0271*       call printHex8
0B02D6             0272*   ; print de
0B02D6 EB          0273*       ex de,hl
0B02D7 CD 58 02 0B 0274*       call printHex16
0B02DB EB          0275*       ex de,hl
0B02DC             0276*   ; restore registers
0B02DC F1          0277*       pop af
0B02DD C1          0278*       pop bc
0B02DE C9          0279*       ret
0B02DF             0280*   
0B02DF             0281*   ; Print a 0x HEX prefix
0B02DF             0282*   DisplayHexPrefix:
0B02DF 3E 30       0283*   	LD	A, '0'
0B02E1 5B D7       0284*   	RST.LIL 10h
0B02E3 3E 78       0285*   	LD	A, 'x'
0B02E5 5B D7       0286*   	RST.LIL 10h
0B02E7 C9          0287*   	RET
0B02E8             0288*   
0B02E8             0289*       MACRO printDecBC
0B02E8             0290*           push hl
0B02E8             0291*           push bc
0B02E8             0292*           pop hl
0B02E8             0293*           call printDec
0B02E8             0294*           pop hl
0B02E8             0295*       ENDMACRO
0B02E8             0296*   
0B02E8             0297*       MACRO printDecDE
0B02E8             0298*           push hl
0B02E8             0299*           push de
0B02E8             0300*           pop hl
0B02E8             0301*           call printDec
0B02E8             0302*           pop hl
0B02E8             0303*       ENDMACRO
0B02E8             0304*   
0B02E8             0305*       MACRO printDecHL
0B02E8             0306*           call printDec
0B02E8             0307*       ENDMACRO
0B02E8             0308*   
0B02E8             0309*       MACRO printDecIX
0B02E8             0310*           push hl
0B02E8             0311*           push ix
0B02E8             0312*           pop hl
0B02E8             0313*           call printDec
0B02E8             0314*           pop hl
0B02E8             0315*       ENDMACRO
0B02E8             0316*   
0B02E8             0317*       MACRO printDecIY
0B02E8             0318*           push hl
0B02E8             0319*           push iy
0B02E8             0320*           pop hl
0B02E8             0321*           call printDec
0B02E8             0322*           pop hl
0B02E8             0323*       ENDMACRO
0B02E8             0324*   
0B02E8             0325*   
0B02E8             0326*   ; Prints the right justified decimal value in HL without leading zeroes
0B02E8             0327*   ; HL : Value to print
0B02E8             0328*   ; preserves all registers and flags
0B02E8             0329*   printDec:
0B02E8             0330*   ; BEGIN MY CODE
0B02E8             0331*   ; back up all the things
0B02E8 F5          0332*       push af
0B02E9 C5          0333*       push bc
0B02EA D5          0334*       push de
0B02EB E5          0335*       push hl
0B02EC             0336*   ; END MY CODE
0B02EC 11 14 03 0B 0337*   	LD	 DE, _printDecBuffer
0B02F0 CD 24 03 0B 0338*   	CALL u24_to_ascii
0B02F4             0339*   ; BEGIN MY CODE
0B02F4             0340*   ; replace leading zeroes with spaces
0B02F4 21 14 03 0B 0341*       LD	 HL, _printDecBuffer
0B02F8 06 07       0342*       ld   B, 7 ; if HL was 0, we want to keep the final zero
0B02FA             0343*   @loop:
0B02FA 7E          0344*       LD	 A, (HL)
0B02FB FE 30       0345*       CP	 '0'
0B02FD C2 07 03 0B 0346*       JP	 NZ, @done
0B0301 3E 20       0347*       LD   A, ' '
0B0303 77          0348*       LD	 (HL), A
0B0304 23          0349*       INC	 HL
0B0305             0350*       ; CALL vdu_cursor_forward
0B0305 10 F3       0351*       DJNZ @loop
0B0307             0352*   @done:
0B0307             0353*   ; END MY CODE
0B0307 21 14 03 0B 0354*   	LD	 HL, _printDecBuffer
0B030B CD 30 02 0B 0355*   	CALL printString
0B030F             0356*   ; BEGIN MY CODE
0B030F             0357*   ; restore all the things
0B030F E1          0358*       pop hl
0B0310 D1          0359*       pop de
0B0311 C1          0360*       pop bc
0B0312 F1          0361*       pop af
0B0313             0362*   ; END MY CODE
0B0313 C9          0363*   	RET
0B0314 00 00 00 00 0364*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0324             0365*   
0B0324             0366*   ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0324             0367*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0324             0368*   ; so it will allways be 8 characters length
0B0324             0369*   ; HL : Value to convert to string
0B0324             0370*   ; DE : pointer to buffer, at least 8 byte + 0
0B0324             0371*   u24_to_ascii:
0B0324 01 80 69 67 0372*   	LD	 BC,-10000000
0B0328 CD 5B 03 0B 0373*   	CALL @one_digit
0B032C 01 C0 BD F0 0374*   	LD	 BC,-1000000
0B0330 CD 5B 03 0B 0375*   	CALL @one_digit
0B0334 01 60 79 FE 0376*   	LD	 BC,-100000
0B0338 CD 5B 03 0B 0377*   	CALL @one_digit
0B033C 01 F0 D8 FF 0378*   	LD   BC,-10000
0B0340 CD 5B 03 0B 0379*   	CALL @one_digit
0B0344 01 18 FC FF 0380*   	LD   BC,-1000
0B0348 CD 5B 03 0B 0381*   	CALL @one_digit
0B034C 01 9C FF FF 0382*   	LD   BC,-100
0B0350 CD 5B 03 0B 0383*   	CALL @one_digit
0B0354 0E F6       0384*   	LD   C,-10
0B0356 CD 5B 03 0B 0385*   	CALL @one_digit
0B035A 48          0386*   	LD   C,B
0B035B             0387*   @one_digit:
0B035B 3E 2F       0388*   	LD   A,'0'-1
0B035D             0389*   @divide_me:
0B035D 3C          0390*   	INC  A
0B035E 09          0391*   	ADD  HL,BC
0B035F 38 FC       0392*   	JR   C,@divide_me
0B0361 ED 42       0393*   	SBC  HL,BC
0B0363 12          0394*   	LD   (DE),A
0B0364 13          0395*   	INC  DE
0B0365 C9          0396*   	RET
0B0366             0397*   
0B0366             0398*   print_u24:
0B0366 D5          0399*       push de
0B0367 E5          0400*       push hl
0B0368 11 14 03 0B 0401*       ld de,_printDecBuffer
0B036C CD 24 03 0B 0402*       call u24_to_ascii
0B0370 21 14 03 0B 0403*       ld hl,_printDecBuffer
0B0374 CD 30 02 0B 0404*       call printString
0B0378 3E 20       0405*       ld a,' '
0B037A 5B D7       0406*       rst.lil 10h
0B037C E1          0407*       pop hl
0B037D D1          0408*       pop de
0B037E C9          0409*       ret
0B037F             0410*   
0B037F             0411*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B037F             0412*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0B037F             0413*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B037F             0414*   u168_to_ascii:
0B037F             0415*   ; add a leading space to make room for sign flag if needed
0B037F 3E 20       0416*       ld a,' '
0B0381 12          0417*       ld (de),a
0B0382 13          0418*       inc de
0B0383             0419*   ; Convert integer part
0B0383 E5          0420*       push hl               ; Save HL (well need the fractional part later)
0B0384 CD 75 08 0B 0421*       call hlu_udiv256    ; Shift to get integer portion in HL
0B0388 01 F0 D8 FF 0422*       ld   bc, -10000
0B038C CD AF 03 0B 0423*       call @one_int
0B0390 01 18 FC FF 0424*       ld   bc, -1000
0B0394 CD AF 03 0B 0425*       call @one_int
0B0398 01 9C FF FF 0426*       ld   bc, -100
0B039C CD AF 03 0B 0427*       call @one_int
0B03A0 0E F6       0428*       ld   c, -10
0B03A2 CD AF 03 0B 0429*       call @one_int
0B03A6 48          0430*       ld   c, b
0B03A7 CD AF 03 0B 0431*       call @one_int
0B03AB C3 BA 03 0B 0432*       jp   @frac            ; Jump to fractional part conversion
0B03AF             0433*   @one_int:
0B03AF 3E 2F       0434*       ld   a, '0' - 1       ; Start ASCII character at '0'
0B03B1             0435*   @divide_me:
0B03B1 3C          0436*       inc  a
0B03B2 09          0437*       add  hl, bc           ; Accumulate until overflow
0B03B3 38 FC       0438*       jr   c, @divide_me
0B03B5 ED 42       0439*       sbc  hl, bc           ; Remove excess after overflow
0B03B7 12          0440*       ld   (de), a          ; Store ASCII digit
0B03B8 13          0441*       inc  de
0B03B9 C9          0442*       ret
0B03BA             0443*   ; Convert fractional part
0B03BA             0444*   @frac:
0B03BA 3E 2E       0445*       ld   a, '.'           ; Decimal point
0B03BC 12          0446*       ld   (de), a
0B03BD 13          0447*       inc  de
0B03BE E1          0448*       pop  hl               ; Restore HL with original fraction
0B03BF 06 03       0449*       ld   b, 3             ; Loop counter for 3 fractional digits
0B03C1             0450*   @frac_loop:
0B03C1 26 0A       0451*       ld   h, 10            ; Load multiplier for fractional part
0B03C3 ED 6C       0452*       mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B03C5 3E 30       0453*       ld   a, '0'
0B03C7 84          0454*       add  a, h             ; Convert integer part to ASCII
0B03C8 12          0455*       ld   (de), a
0B03C9 13          0456*       inc  de
0B03CA 10 F5       0457*       djnz @frac_loop       ; Repeat for each fractional digit
0B03CC             0458*   ; Add null terminator
0B03CC AF          0459*       xor  a                ; Null terminator
0B03CD 12          0460*       ld   (de), a
0B03CE C9          0461*       ret
0B03CF             0462*   
0B03CF             0463*   print_u168:
0B03CF D5          0464*       push de
0B03D0 E5          0465*       push hl
0B03D1 11 14 03 0B 0466*       ld de,_printDecBuffer
0B03D5 CD 7F 03 0B 0467*       call u168_to_ascii
0B03D9 21 14 03 0B 0468*       ld hl,_printDecBuffer
0B03DD CD 30 02 0B 0469*       call printString
0B03E1 E1          0470*       pop hl
0B03E2 D1          0471*       pop de
0B03E3 C9          0472*       ret
0B03E4             0473*   
0B03E4             0474*   ; signed version of u168_to_ascii
0B03E4             0475*   s168_to_ascii:
0B03E4 D5          0476*       push de ; save starting address of buffer
0B03E5 CD 0E 08 0B 0477*       call hlu_abs
0B03E9 F5          0478*       push af ; save sign flag
0B03EA CD 7F 03 0B 0479*       call u168_to_ascii
0B03EE F1          0480*       pop af ; restore sign flag
0B03EF D1          0481*       pop de ; restore starting address of buffer
0B03F0 F0          0482*       ret p ; hlu was positive so nothing to do
0B03F1 3E 2D       0483*       ld a,'-'
0B03F3 12          0484*       ld (de),a
0B03F4 C9          0485*       ret
0B03F5             0486*   
0B03F5             0487*   print_s168:
0B03F5 D5          0488*       push de
0B03F6 E5          0489*       push hl
0B03F7 11 14 03 0B 0490*       ld de,_printDecBuffer
0B03FB CD E4 03 0B 0491*       call s168_to_ascii
0B03FF 21 14 03 0B 0492*       ld hl,_printDecBuffer
0B0403 CD 30 02 0B 0493*       call printString
0B0407 E1          0494*       pop hl
0B0408 D1          0495*       pop de
0B0409 C9          0496*       ret
0B040A             0497*   
0B040A             0498*   print_s168_hl:
0B040A F5          0499*       push af
0B040B E5          0500*       push hl
0B040C CD F5 03 0B 0501*       call print_s168
0B0410 3E 20       0502*       ld a,' '
0B0412 5B D7       0503*       rst.lil 10h
0B0414 E1          0504*       pop hl
0B0415 F1          0505*       pop af
0B0416 C9          0506*       ret
0B0417             0507*   
0B0417             0508*   print_s168_bc:
0B0417 F5          0509*       push af
0B0418 C5          0510*       push bc
0B0419 E5          0511*       push hl
0B041A C5          0512*       push bc
0B041B E1          0513*       pop hl
0B041C CD F5 03 0B 0514*       call print_s168
0B0420 3E 20       0515*       ld a,' '
0B0422 5B D7       0516*       rst.lil 10h
0B0424 E1          0517*       pop hl
0B0425 C1          0518*       pop bc
0B0426 F1          0519*       pop af
0B0427 C9          0520*       ret
0B0428             0521*   
0B0428             0522*   print_s168_de:
0B0428 F5          0523*       push af
0B0429 D5          0524*       push de
0B042A E5          0525*       push hl
0B042B EB          0526*       ex de,hl
0B042C CD F5 03 0B 0527*       call print_s168
0B0430 3E 20       0528*       ld a,' '
0B0432 5B D7       0529*       rst.lil 10h
0B0434 E1          0530*       pop hl
0B0435 D1          0531*       pop de
0B0436 F1          0532*       pop af
0B0437 C9          0533*       ret
0B0438             0534*   
0B0438             0535*   print_s168_hl_bc_de:
0B0438 F5          0536*       push af
0B0439 C5          0537*       push bc
0B043A D5          0538*       push de
0B043B E5          0539*       push hl
0B043C CD F5 03 0B 0540*       call print_s168
0B0440 3E 20       0541*       ld a,' '
0B0442 5B D7       0542*       rst.lil 10h
0B0444 C5          0543*       push bc
0B0445 E1          0544*       pop hl
0B0446 CD F5 03 0B 0545*       call print_s168
0B044A 3E 20       0546*       ld a,' '
0B044C 5B D7       0547*       rst.lil 10h
0B044E EB          0548*       ex de,hl
0B044F CD F5 03 0B 0549*       call print_s168
0B0453 3E 20       0550*       ld a,' '
0B0455 5B D7       0551*       rst.lil 10h
0B0457 E1          0552*       pop hl
0B0458 D1          0553*       pop de
0B0459 C1          0554*       pop bc
0B045A F1          0555*       pop af
0B045B C9          0556*       ret
0B045C             0557*   
0B045C             0558*   print_s168_bc_de:
0B045C F5          0559*       push af
0B045D C5          0560*       push bc
0B045E D5          0561*       push de
0B045F C5          0562*       push bc
0B0460 E1          0563*       pop hl
0B0461 CD F5 03 0B 0564*       call print_s168
0B0465 3E 20       0565*       ld a,' '
0B0467 5B D7       0566*       rst.lil 10h
0B0469 EB          0567*       ex de,hl
0B046A CD F5 03 0B 0568*       call print_s168
0B046E 3E 20       0569*       ld a,' '
0B0470 5B D7       0570*       rst.lil 10h
0B0472 E1          0571*       pop hl
0B0473 D1          0572*       pop de
0B0474 C1          0573*       pop bc
0B0475 F1          0574*       pop af
0B0476 C9          0575*       ret
0B0477             0576*   
0B0477             0577*   print_s168_a:
0B0477 F5          0578*       push af
0B0478 C5          0579*       push bc
0B0479 E5          0580*       push hl
0B047A 21 00 00 00 0581*       ld hl,0
0B047E 6F          0582*       ld l,a
0B047F CD 0A 04 0B 0583*       call print_s168_hl
0B0483 E1          0584*       pop hl
0B0484 C1          0585*       pop bc
0B0485 F1          0586*       pop af
0B0486 C9          0587*       ret
0B0487             0588*   
0B0487             0589*   ; #### new functions added by Brandon R. Gates ####
0B0487             0590*   
0B0487             0591*   ; print the binary representation of the 8-bit value in a
0B0487             0592*   ; destroys a, hl, bc
0B0487             0593*   printBin8:
0B0487 06 08       0594*       ld b,8      ; loop counter for 8 bits
0B0489 21 A4 04 0B 0595*       ld hl,@cmd  ; set hl to the low byte of the output string
0B048D             0596*                   ; (which will be the high bit of the value in a)
0B048D             0597*   @loop:
0B048D 07          0598*       rlca ; put the next highest bit into carry
0B048E 38 04       0599*       jr c,@one
0B0490 36 30       0600*       ld (hl),'0'
0B0492 18 02       0601*       jr @next_bit
0B0494             0602*   @one:
0B0494 36 31       0603*       ld (hl),'1'
0B0496             0604*   @next_bit:
0B0496 23          0605*       inc hl
0B0497 10 F4       0606*       djnz @loop
0B0499             0607*   ; print it
0B0499 21 A4 04 0B 0608*   	ld hl,@cmd
0B049D 01 08 00 00 0609*   	ld bc,@end-@cmd
0B04A1 5B DF       0610*   	rst.lil $18
0B04A3 C9          0611*   	ret
0B04A4             0612*   @cmd: ds 8 ; eight bytes for eight bits
0B04AC             0613*   @end:
0B04AC             0614*   
0B04AC             0615*   ; print the binary representation of the 8-bit value in a
0B04AC             0616*   ; in reverse order (lsb first)
0B04AC             0617*   ; destroys a, hl, bc
0B04AC             0618*   printBin8Rev:
0B04AC 06 08       0619*       ld b,8      ; loop counter for 8 bits
0B04AE 21 C9 04 0B 0620*       ld hl,@cmd  ; set hl to the low byte of the output string
0B04B2             0621*                   ; (which will be the high bit of the value in a)
0B04B2             0622*   @loop:
0B04B2 0F          0623*       rrca ; put the next lowest bit into carry
0B04B3 38 04       0624*       jr c,@one
0B04B5 36 30       0625*       ld (hl),'0'
0B04B7 18 02       0626*       jr @next_bit
0B04B9             0627*   @one:
0B04B9 36 31       0628*       ld (hl),'1'
0B04BB             0629*   @next_bit:
0B04BB 23          0630*       inc hl
0B04BC 10 F4       0631*       djnz @loop
0B04BE             0632*   ; print it
0B04BE 21 C9 04 0B 0633*   	ld hl,@cmd
0B04C2 01 08 00 00 0634*   	ld bc,@end-@cmd
0B04C6 5B DF       0635*   	rst.lil $18
0B04C8 C9          0636*   	ret
0B04C9             0637*   @cmd: ds 8 ; eight bytes for eight bits
0B04D1             0638*   @end:
0B04D1             0639*   
0B04D1             0640*   ; print registers to screen in hexidecimal format
0B04D1             0641*   ; inputs: none
0B04D1             0642*   ; outputs: values of every register printed to screen
0B04D1             0643*   ;    values of each register in global scratch memory
0B04D1             0644*   ; destroys: nothing
0B04D1             0645*   stepRegistersHex:
0B04D1             0646*   ; store everything in scratch
0B04D1 22 15 07 0B 0647*       ld (uhl),hl
0B04D5 ED 43 18 07 0648*       ld (ubc),bc
       0B          
0B04DA ED 53 1B 07 0649*       ld (ude),de
       0B          
0B04DF DD 22 1E 07 0650*       ld (uix),ix
       0B          
0B04E4 FD 22 21 07 0651*       ld (uiy),iy
       0B          
0B04E9 F5          0652*       push af ; fml
0B04EA E1          0653*       pop hl  ; thanks, zilog
0B04EB 22 12 07 0B 0654*       ld (uaf),hl
0B04EF F5          0655*       push af ; dammit
0B04F0             0656*   
0B04F0             0657*   ; home the cursor
0B04F0             0658*       ; call vdu_home_cursor
0B04F0             0659*   
0B04F0             0660*   ; print each register
0B04F0 21 98 06 0B 0661*       ld hl,str_afu
0B04F4 CD 30 02 0B 0662*       call printString
0B04F8 2A 12 07 0B 0663*       ld hl,(uaf)
0B04FC CD 50 02 0B 0664*       call printHex24
0B0500 CD 45 02 0B 0665*       call printNewLine
0B0504             0666*   
0B0504 21 9D 06 0B 0667*       ld hl,str_hlu
0B0508 CD 30 02 0B 0668*       call printString
0B050C 2A 15 07 0B 0669*       ld hl,(uhl)
0B0510 CD 50 02 0B 0670*       call printHex24
0B0514 CD 45 02 0B 0671*       call printNewLine
0B0518             0672*   
0B0518 21 A2 06 0B 0673*       ld hl,str_bcu
0B051C CD 30 02 0B 0674*       call printString
0B0520 2A 18 07 0B 0675*       ld hl,(ubc)
0B0524 CD 50 02 0B 0676*       call printHex24
0B0528 CD 45 02 0B 0677*       call printNewLine
0B052C             0678*   
0B052C 21 A7 06 0B 0679*       ld hl,str_deu
0B0530 CD 30 02 0B 0680*       call printString
0B0534 2A 1B 07 0B 0681*       ld hl,(ude)
0B0538 CD 50 02 0B 0682*       call printHex24
0B053C CD 45 02 0B 0683*       call printNewLine
0B0540             0684*   
0B0540 21 AC 06 0B 0685*       ld hl,str_ixu
0B0544 CD 30 02 0B 0686*       call printString
0B0548 2A 1E 07 0B 0687*       ld hl,(uix)
0B054C CD 50 02 0B 0688*       call printHex24
0B0550 CD 45 02 0B 0689*       call printNewLine
0B0554             0690*   
0B0554 21 B1 06 0B 0691*       ld hl,str_iyu
0B0558 CD 30 02 0B 0692*       call printString
0B055C 2A 21 07 0B 0693*       ld hl,(uiy)
0B0560 CD 50 02 0B 0694*       call printHex24
0B0564 CD 45 02 0B 0695*       call printNewLine
0B0568             0696*   
0B0568             0697*       ; call vsync
0B0568             0698*   
0B0568 CD 45 02 0B 0699*       call printNewLine
0B056C             0700*   
0B056C             0701*   ; check for right shift key and quit if pressed
0B056C             0702*   	MOSCALL mos_getkbmap
0B056C 3E 1E       0001*M  			LD	A, function
0B056E 5B CF       0002*M  			RST.L	08h
0B0570             0703*   @stayhere:
0B0570             0704*   ; 7 RightShift
0B0570 DD CB 00 76 0705*       bit 6,(ix+0)
0B0574 20 02       0706*       jr nz,@RightShift
0B0576 18 F8       0707*       jr @stayhere
0B0578             0708*   @RightShift:
0B0578 DD CB 0E 86 0709*       res 0,(ix+14) ; debounce the key (hopefully)
0B057C 3E 80       0710*       ld a,%10000000
0B057E CD 17 1F 0B 0711*       call multiPurposeDelay
0B0582             0712*   
0B0582             0713*   ; restore everything
0B0582 2A 15 07 0B 0714*       ld hl, (uhl)
0B0586 ED 4B 18 07 0715*       ld bc, (ubc)
       0B          
0B058B ED 5B 1B 07 0716*       ld de, (ude)
       0B          
0B0590 DD 2A 1E 07 0717*       ld ix, (uix)
       0B          
0B0595 FD 2A 21 07 0718*       ld iy, (uiy)
       0B          
0B059A F1          0719*       pop af
0B059B             0720*   ; all done
0B059B C9          0721*       ret
0B059C             0722*   
0B059C             0723*   ; print registers to screen in hexidecimal format
0B059C             0724*   ; inputs: none
0B059C             0725*   ; outputs: values of every register printed to screen
0B059C             0726*   ;    values of each register in global scratch memory
0B059C             0727*   ; destroys: nothing
0B059C             0728*   dumpRegistersHex:
0B059C             0729*   ; store everything in scratch
0B059C 22 15 07 0B 0730*       ld (uhl),hl
0B05A0 ED 43 18 07 0731*       ld (ubc),bc
       0B          
0B05A5 ED 53 1B 07 0732*       ld (ude),de
       0B          
0B05AA DD 22 1E 07 0733*       ld (uix),ix
       0B          
0B05AF FD 22 21 07 0734*       ld (uiy),iy
       0B          
0B05B4 F5          0735*       push af ; fml
0B05B5 E1          0736*       pop hl  ; thanks, zilog
0B05B6 22 12 07 0B 0737*       ld (uaf),hl
0B05BA F5          0738*       push af ; dammit
0B05BB             0739*   
0B05BB             0740*   ; home the cursor
0B05BB             0741*       ; call vdu_home_cursor
0B05BB             0742*       ; call printNewLine
0B05BB             0743*   
0B05BB             0744*   ; print each register
0B05BB 21 98 06 0B 0745*       ld hl,str_afu
0B05BF CD 30 02 0B 0746*       call printString
0B05C3 2A 12 07 0B 0747*       ld hl,(uaf)
0B05C7 CD 50 02 0B 0748*       call printHex24
0B05CB             0749*       ; call printNewLine
0B05CB             0750*   
0B05CB 21 9D 06 0B 0751*       ld hl,str_hlu
0B05CF CD 30 02 0B 0752*       call printString
0B05D3 2A 15 07 0B 0753*       ld hl,(uhl)
0B05D7 CD 50 02 0B 0754*       call printHex24
0B05DB             0755*       ; call printNewLine
0B05DB             0756*   
0B05DB 21 A2 06 0B 0757*       ld hl,str_bcu
0B05DF CD 30 02 0B 0758*       call printString
0B05E3 2A 18 07 0B 0759*       ld hl,(ubc)
0B05E7 CD 50 02 0B 0760*       call printHex24
0B05EB             0761*       ; call printNewLine
0B05EB             0762*   
0B05EB 21 A7 06 0B 0763*       ld hl,str_deu
0B05EF CD 30 02 0B 0764*       call printString
0B05F3 2A 1B 07 0B 0765*       ld hl,(ude)
0B05F7 CD 50 02 0B 0766*       call printHex24
0B05FB             0767*       ; call printNewLine
0B05FB             0768*   
0B05FB 21 AC 06 0B 0769*       ld hl,str_ixu
0B05FF CD 30 02 0B 0770*       call printString
0B0603 2A 1E 07 0B 0771*       ld hl,(uix)
0B0607 CD 50 02 0B 0772*       call printHex24
0B060B             0773*       ; call printNewLine
0B060B             0774*   
0B060B 21 B1 06 0B 0775*       ld hl,str_iyu
0B060F CD 30 02 0B 0776*       call printString
0B0613 2A 21 07 0B 0777*       ld hl,(uiy)
0B0617 CD 50 02 0B 0778*       call printHex24
0B061B             0779*       ; call printNewLine
0B061B             0780*   
0B061B             0781*       ; call vdu_vblank
0B061B             0782*   
0B061B CD 45 02 0B 0783*       call printNewLine
0B061F             0784*   ; restore everything
0B061F 2A 15 07 0B 0785*       ld hl, (uhl)
0B0623 ED 4B 18 07 0786*       ld bc, (ubc)
       0B          
0B0628 ED 5B 1B 07 0787*       ld de, (ude)
       0B          
0B062D DD 2A 1E 07 0788*       ld ix, (uix)
       0B          
0B0632 FD 2A 21 07 0789*       ld iy, (uiy)
       0B          
0B0637 F1          0790*       pop af
0B0638             0791*   ; all done
0B0638 C9          0792*       ret
0B0639             0793*   
0B0639             0794*   dumpRegistersHexPrime:
0B0639 D9          0795*       exx
0B063A 08          0796*       ex af,af'
0B063B CD 9C 05 0B 0797*       call dumpRegistersHex
0B063F 08          0798*       ex af,af'
0B0640 D9          0799*       exx
0B0641 C9          0800*       ret
0B0642             0801*   
0B0642             0802*   ; additionally dump prime registers
0B0642             0803*   ; inputs: none
0B0642             0804*   ; outputs: values of every register printed to screen
0B0642             0805*   ; destroys: nothing
0B0642             0806*   dumpRegistersHexAll:
0B0642 CD 9C 05 0B 0807*       call dumpRegistersHex
0B0646 08          0808*       ex af,af'
0B0647 D9          0809*       exx
0B0648 CD 9C 05 0B 0810*       call dumpRegistersHex
0B064C 08          0811*       ex af,af'
0B064D D9          0812*       exx
0B064E C9          0813*       ret
0B064F             0814*   
0B064F             0815*   ; print hlu to screen in hexidecimal format
0B064F             0816*   ; inputs: none
0B064F             0817*   ; destroys: nothing
0B064F             0818*   print_hex_hl:
0B064F F5          0819*       push af
0B0650 E5          0820*       push hl
0B0651 21 9D 06 0B 0821*       ld hl,str_hlu
0B0655 CD 30 02 0B 0822*       call printString
0B0659 E1          0823*       pop hl
0B065A E5          0824*       push hl
0B065B CD 50 02 0B 0825*       call printHex24
0B065F 3E 20       0826*       ld a,' '
0B0661 5B D7       0827*       rst.lil 10h
0B0663 E1          0828*       pop hl
0B0664 F1          0829*       pop af
0B0665 C9          0830*       ret
0B0666             0831*   
0B0666             0832*   ; print bcu to screen in hexidecimal format
0B0666             0833*   ; inputs: none
0B0666             0834*   ; destroys: nothing
0B0666             0835*   print_hex_bc:
0B0666 F5          0836*       push af
0B0667 E5          0837*       push hl
0B0668 C5          0838*       push bc
0B0669 21 A2 06 0B 0839*       ld hl,str_bcu
0B066D CD 30 02 0B 0840*       call printString
0B0671 E1          0841*       pop hl
0B0672 E5          0842*       push hl
0B0673 CD 50 02 0B 0843*       call printHex24
0B0677 3E 20       0844*       ld a,' '
0B0679 5B D7       0845*       rst.lil 10h
0B067B C1          0846*       pop bc
0B067C E1          0847*       pop hl
0B067D F1          0848*       pop af
0B067E C9          0849*       ret
0B067F             0850*   
0B067F             0851*   ; print deu to screen in hexidecimal format
0B067F             0852*   ; inputs: none
0B067F             0853*   ; destroys: nothing
0B067F             0854*   print_hex_de:
0B067F F5          0855*       push af
0B0680 E5          0856*       push hl
0B0681 D5          0857*       push de
0B0682 21 A7 06 0B 0858*       ld hl,str_deu
0B0686 CD 30 02 0B 0859*       call printString
0B068A E1          0860*       pop hl
0B068B E5          0861*       push hl
0B068C CD 50 02 0B 0862*       call printHex24
0B0690 3E 20       0863*       ld a,' '
0B0692 5B D7       0864*       rst.lil 10h
0B0694 D1          0865*       pop de
0B0695 E1          0866*       pop hl
0B0696 F1          0867*       pop af
0B0697 C9          0868*       ret
0B0698             0869*   
0B0698 20 61 66 3D 0870*   str_afu: db " af=",0
       00          
0B069D 20 68 6C 3D 0871*   str_hlu: db " hl=",0
       00          
0B06A2 20 62 63 3D 0872*   str_bcu: db " bc=",0
       00          
0B06A7 20 64 65 3D 0873*   str_deu: db " de=",0
       00          
0B06AC 20 69 78 3D 0874*   str_ixu: db " ix=",0
       00          
0B06B1 20 69 79 3D 0875*   str_iyu: db " iy=",0
       00          
0B06B6             0876*   
0B06B6             0877*   ; print udeuhl to screen in hexidecimal format
0B06B6             0878*   ; inputs: none
0B06B6             0879*   ; outputs: concatenated hexidecimal udeuhl
0B06B6             0880*   ; destroys: nothing
0B06B6             0881*   dumpUDEUHLHex:
0B06B6             0882*   ; store everything in scratch
0B06B6 22 15 07 0B 0883*       ld (uhl),hl
0B06BA ED 43 18 07 0884*       ld (ubc),bc
       0B          
0B06BF ED 53 1B 07 0885*       ld (ude),de
       0B          
0B06C4 DD 22 1E 07 0886*       ld (uix),ix
       0B          
0B06C9 FD 22 21 07 0887*       ld (uiy),iy
       0B          
0B06CE F5          0888*       push af
0B06CF             0889*   
0B06CF             0890*   ; print each register
0B06CF             0891*   
0B06CF 21 09 07 0B 0892*       ld hl,str_udeuhl
0B06D3 CD 30 02 0B 0893*       call printString
0B06D7 2A 1B 07 0B 0894*       ld hl,(ude)
0B06DB CD 50 02 0B 0895*       call printHex24
0B06DF 3E 2E       0896*   	ld a,'.'	; print a dot to separate the values
0B06E1 5B D7       0897*   	rst.lil 10h
0B06E3 2A 15 07 0B 0898*       ld hl,(uhl)
0B06E7 CD 50 02 0B 0899*       call printHex24
0B06EB CD 45 02 0B 0900*       call printNewLine
0B06EF             0901*   
0B06EF             0902*   ; restore everything
0B06EF 2A 15 07 0B 0903*       ld hl, (uhl)
0B06F3 ED 4B 18 07 0904*       ld bc, (ubc)
       0B          
0B06F8 ED 5B 1B 07 0905*       ld de, (ude)
       0B          
0B06FD DD 2A 1E 07 0906*       ld ix, (uix)
       0B          
0B0702 FD 2A 21 07 0907*       ld iy, (uiy)
       0B          
0B0707 F1          0908*       pop af
0B0708             0909*   ; all done
0B0708 C9          0910*       ret
0B0709             0911*   
0B0709 75 64 65 2E 0912*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0712             0913*   
0B0712             0914*   ; global scratch memory for registers
0B0712 00 00 00    0915*   uaf: dl 0
0B0715 00 00 00    0916*   uhl: dl 0
0B0718 00 00 00    0917*   ubc: dl 0
0B071B 00 00 00    0918*   ude: dl 0
0B071E 00 00 00    0919*   uix: dl 0
0B0721 00 00 00    0920*   uiy: dl 0
0B0724 00 00 00    0921*   usp: dl 0
0B0727 00 00 00    0922*   upc: dl 0
0B072A             0923*   
0B072A             0924*   ; inputs: whatever is in the flags register
0B072A             0925*   ; outputs: binary representation of flags
0B072A             0926*   ;          with a header so we know which is what
0B072A             0927*   ; destroys: nothing
0B072A             0928*   ; preserves: everything
0B072A             0929*   dumpFlags:
0B072A             0930*   ; first we curse zilog for not giving direct access to flags
0B072A F5          0931*       push af ; this is so we can send it back unharmed
0B072B F5          0932*       push af ; this is so we can pop it to hl
0B072C             0933*   ; store everything in scratch
0B072C 22 15 07 0B 0934*       ld (uhl),hl
0B0730 ED 43 18 07 0935*       ld (ubc),bc
       0B          
0B0735 ED 53 1B 07 0936*       ld (ude),de
       0B          
0B073A DD 22 1E 07 0937*       ld (uix),ix
       0B          
0B073F FD 22 21 07 0938*       ld (uiy),iy
       0B          
0B0744             0939*   ; next we print the header
0B0744 21 70 07 0B 0940*       ld hl,@header
0B0748 CD 30 02 0B 0941*       call printString
0B074C E1          0942*       pop hl ; flags are now in l
0B074D 7D          0943*       ld a,l ; flags are now in a
0B074E CD 87 04 0B 0944*       call printBin8
0B0752 CD 45 02 0B 0945*   	call printNewLine
0B0756             0946*   ; restore everything
0B0756 2A 15 07 0B 0947*       ld hl, (uhl)
0B075A ED 4B 18 07 0948*       ld bc, (ubc)
       0B          
0B075F ED 5B 1B 07 0949*       ld de, (ude)
       0B          
0B0764 DD 2A 1E 07 0950*       ld ix, (uix)
       0B          
0B0769 FD 2A 21 07 0951*       ld iy, (uiy)
       0B          
0B076E F1          0952*       pop af ; send her home the way she came
0B076F C9          0953*       ret
0B0770             0954*   ; Bit 7 (S): Sign flag
0B0770             0955*   ; Bit 6 (Z): Zero flag
0B0770             0956*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B0770             0957*   ; Bit 4 (H): Half Carry flag
0B0770             0958*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B0770             0959*   ; Bit 2 (PV): Parity/Overflow flag
0B0770             0960*   ; Bit 1 (N): Subtract flag
0B0770             0961*   ; Bit 0 (C): Carry flag
0B0770 53 5A 78 48 0962*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B077B             0963*   
0B077B             0964*   ; set all the bits in the flag register
0B077B             0965*   ; more of an academic exercise than anything useful
0B077B             0966*   ; inputs; none
0B077B             0967*   ; outputs; a=0,f=255
0B077B             0968*   ; destroys: flags, hl
0B077B             0969*   ; preserves: a, because why not
0B077B             0970*   setAllFlags:
0B077B 21 FF 00 00 0971*       ld hl,255
0B077F 67          0972*       ld h,a ; four cycles to preserve a is cheap
0B0780 E5          0973*       push hl
0B0781 F1          0974*       pop af
0B0782 C9          0975*       ret
0B0783             0976*   
0B0783             0977*   ; reset all the bits in the flag register
0B0783             0978*   ; unlike its inverse counterpart, this may actually be useful
0B0783             0979*   ; inputs; none
0B0783             0980*   ; outputs; a=0,f=0
0B0783             0981*   ; destroys: flags, hl
0B0783             0982*   ; preserves: a, because why not
0B0783             0983*   resetAllFlags:
0B0783 21 00 00 00 0984*       ld hl,0
0B0787 67          0985*       ld h,a ; four cycles to preserve a is cheap
0B0788 E5          0986*       push hl
0B0789 F1          0987*       pop af
0B078A C9          0988*       ret
0B078B             0989*   
0B078B             0990*   ; wait until user presses a key
0B078B             0991*   ; inputs: none
0B078B             0992*   ; outputs: none
0B078B             0993*   ; destroys: af,ix
0B078B             0994*   waitKeypress:
0B078B             0995*       MOSCALL mos_sysvars
0B078B 3E 08       0001*M  			LD	A, function
0B078D 5B CF       0002*M  			RST.L	08h
0B078F AF          0996*       xor a ; zero out any prior keypresses
0B0790 DD 77 05    0997*       ld (ix+sysvar_keyascii),a
0B0793             0998*   @loop:
0B0793 DD 7E 05    0999*       ld a,(ix+sysvar_keyascii)
0B0796 A7          1000*       and a
0B0797 C0          1001*       ret nz
0B0798 18 F9       1002*       jr @loop
0B079A             1003*   
0B079A             1004*   
0B079A             1005*   ; print bytes from an address to the screen in hexidecimal format
0B079A             1006*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B079A             1007*   ; outputs: values of each byte printed to screen separated by spaces
0B079A             1008*   ; destroys: nothing
0B079A             1009*   dumpMemoryHex:
0B079A             1010*   ; save registers to the stack
0B079A C5          1011*       push bc
0B079B E5          1012*       push hl
0B079C F5          1013*       push af
0B079D             1014*   
0B079D             1015*   ; print the address and separator
0B079D CD 50 02 0B 1016*       call printHex24
0B07A1 3E 3A       1017*       ld a,':'
0B07A3 5B D7       1018*       rst.lil 10h
0B07A5 3E 20       1019*       ld a,' '
0B07A7 5B D7       1020*       rst.lil 10h
0B07A9             1021*   
0B07A9             1022*   ; set b to be our loop counter
0B07A9 F1          1023*       pop af
0B07AA 47          1024*       ld b,a
0B07AB E1          1025*       pop hl
0B07AC E5          1026*       push hl
0B07AD F5          1027*       push af
0B07AE             1028*   @loop:
0B07AE             1029*   ; print the byte
0B07AE 7E          1030*       ld a,(hl)
0B07AF CD 5E 02 0B 1031*       call printHex8
0B07B3             1032*   ; print a space
0B07B3 3E 20       1033*       ld a,' '
0B07B5 5B D7       1034*       rst.lil 10h
0B07B7 23          1035*       inc hl
0B07B8 10 F4       1036*       djnz @loop
0B07BA CD 45 02 0B 1037*       call printNewLine
0B07BE             1038*   
0B07BE             1039*   ; restore everything
0B07BE F1          1040*       pop af
0B07BF E1          1041*       pop hl
0B07C0 C1          1042*       pop bc
0B07C1             1043*   
0B07C1             1044*   ; all done
0B07C1 C9          1045*       ret
0B07C2             1046*   
0B07C2             1047*   
0B07C2             1048*   ; print bytes from an address to the screen in binary format
0B07C2             1049*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07C2             1050*   ; outputs: values of each byte printed to screen separated by spaces
0B07C2             1051*   ; destroys: nothing
0B07C2             1052*   dumpMemoryBin:
0B07C2             1053*   ; save all registers to the stack
0B07C2 F5          1054*       push af
0B07C3 C5          1055*       push bc
0B07C4 D5          1056*       push de
0B07C5 E5          1057*       push hl
0B07C6 DD E5       1058*       push ix
0B07C8 FD E5       1059*       push iy
0B07CA             1060*   
0B07CA             1061*   ; set b to be our loop counter
0B07CA 47          1062*       ld b,a
0B07CB             1063*   @loop:
0B07CB             1064*   ; print the byte
0B07CB 7E          1065*       ld a,(hl)
0B07CC E5          1066*       push hl
0B07CD C5          1067*       push bc
0B07CE CD 87 04 0B 1068*       call printBin8
0B07D2 C1          1069*       pop bc
0B07D3             1070*   ; print a space
0B07D3 3E 20       1071*       ld a,' '
0B07D5 5B D7       1072*       rst.lil 10h
0B07D7 E1          1073*       pop hl
0B07D8 23          1074*       inc hl
0B07D9 10 F0       1075*       djnz @loop
0B07DB CD 45 02 0B 1076*       call printNewLine
0B07DF             1077*   
0B07DF             1078*   ; restore everything
0B07DF FD E1       1079*       pop iy
0B07E1 DD E1       1080*       pop ix
0B07E3 E1          1081*       pop hl
0B07E4 D1          1082*       pop de
0B07E5 C1          1083*       pop bc
0B07E6 F1          1084*       pop af
0B07E7             1085*   ; all done
0B07E7 C9          1086*       ret
0B07E8             1087*   
0B07E8             1088*   ; print bytes from an address to the screen in binary format
0B07E8             1089*   ; with the bits of each byte in reverse order (lsb first)
0B07E8             1090*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07E8             1091*   ; outputs: values of each byte printed to screen separated by spaces
0B07E8             1092*   ; destroys: nothing
0B07E8             1093*   dumpMemoryBinRev:
0B07E8             1094*   ; save all registers to the stack
0B07E8 F5          1095*       push af
0B07E9 C5          1096*       push bc
0B07EA D5          1097*       push de
0B07EB E5          1098*       push hl
0B07EC DD E5       1099*       push ix
0B07EE FD E5       1100*       push iy
0B07F0             1101*   
0B07F0             1102*   ; set b to be our loop counter
0B07F0 47          1103*       ld b,a
0B07F1             1104*   @loop:
0B07F1             1105*   ; print the byte
0B07F1 7E          1106*       ld a,(hl)
0B07F2 E5          1107*       push hl
0B07F3 C5          1108*       push bc
0B07F4 CD AC 04 0B 1109*       call printBin8Rev
0B07F8 C1          1110*       pop bc
0B07F9             1111*   ; print a space
0B07F9 3E 20       1112*       ld a,' '
0B07FB 5B D7       1113*       rst.lil 10h
0B07FD E1          1114*       pop hl
0B07FE 23          1115*       inc hl
0B07FF 10 F0       1116*       djnz @loop
0B0801 CD 45 02 0B 1117*       call printNewLine
0B0805             1118*   
0B0805             1119*   ; restore everything
0B0805 FD E1       1120*       pop iy
0B0807 DD E1       1121*       pop ix
0B0809 E1          1122*       pop hl
0B080A D1          1123*       pop de
0B080B C1          1124*       pop bc
0B080C F1          1125*       pop af
0B080D             1126*   ; all done
0B080D C9          1127*       ret
0B080E             0020        include "maths.inc"
0B080E             0001*   ; absolute value of hlu
0B080E             0002*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B080E             0003*   ;         s1,z0,pv0,n1,c0 if hlu was negative
0B080E             0004*   ;         s0,z1,pv0,n1,c0 if hlu was zero
0B080E             0005*   ;         s0,z0,pv0,n1,c0 if hlu was positive
0B080E             0006*   ; destroys: a
0B080E             0007*   hlu_abs:
0B080E 19          0008*       add hl,de
0B080F B7          0009*       or a
0B0810 ED 52       0010*       sbc hl,de
0B0812 FA 17 08 0B 0011*       jp m,@is_neg
0B0816 C9          0012*       ret         ; hlu is positive or zero so we're done
0B0817             0013*   @is_neg:
0B0817 F5          0014*       push af     ; otherwise, save current flags for return
0B0818 CD 1E 08 0B 0015*       call neg_hlu ; negate hlu
0B081C F1          0016*       pop af      ; get back flags
0B081D C9          0017*       ret
0B081E             0018*   
0B081E             0019*   ; flip the sign of hlu
0B081E             0020*   ; inputs: hlu
0B081E             0021*   ; returns: 0-hlu, flags set appropriately for the result:
0B081E             0022*   ;         s1,z0,pv0,n1,c1 if result is negative
0B081E             0023*   ;         s0,z1,pv0,n1,c0 if result is zero
0B081E             0024*   ;         s0,z0,pv0,n1,c1 if result is positive
0B081E             0025*   ; destroys a
0B081E             0026*   neg_hlu:
0B081E D5          0027*       push de     ; save de
0B081F EB          0028*       ex de,hl    ; put hl into de
0B0820 21 00 00 00 0029*       ld hl,0     ; clear hl
0B0824 AF          0030*       xor a       ; clear carry
0B0825 ED 52       0031*       sbc hl,de   ; 0-hlu = -hlu
0B0827 D1          0032*       pop de      ; get de back
0B0828 C9          0033*       ret         ; easy peasy
0B0829             0034*   
0B0829             0035*   ;------------------------------------------------------------------------
0B0829             0036*   ; divide hlu by 2, inspired by above
0B0829             0037*   ;------------------------------------------------------------------------
0B0829             0038*   hlu_div2:
0B0829 22 B7 09 0B 0039*   	ld		(bitbuf1),hl
0B082D 21 B9 09 0B 0040*   	ld		hl,bitbuf1+2
0B0831 CB 1E       0041*   	rr		(hl)
0B0833 2B          0042*   	dec		hl
0B0834 CB 1E       0043*   	rr		(hl)
0B0836 2B          0044*   	dec		hl
0B0837 CB 1E       0045*   	rr		(hl)
0B0839 23          0046*   	inc		hl
0B083A 23          0047*   	inc		hl
0B083B 2A B7 09 0B 0048*       ld hl,(bitbuf1)
0B083F C9          0049*       ret
0B0840             0050*   
0B0840             0051*   ; this is my little hack to divide by 16
0B0840             0052*   hlu_div16:
0B0840 AF          0053*       xor a
0B0841 29          0054*       add hl,hl
0B0842 17          0055*       rla
0B0843 29          0056*       add hl,hl
0B0844 17          0057*       rla
0B0845 29          0058*       add hl,hl
0B0846 17          0059*       rla
0B0847 29          0060*       add hl,hl
0B0848 17          0061*       rla
0B0849 22 56 08 0B 0062*       ld (@scratch),hl
0B084D 32 59 08 0B 0063*       ld (@scratch+3),a
0B0851 2A 57 08 0B 0064*       ld hl,(@scratch+1)
0B0855 C9          0065*       ret
0B0856             0066*   @scratch: ds 4
0B085A             0067*   
0B085A             0068*   ; hlu signed division by 256
0B085A             0069*   ; returns: hlu / 256
0B085A             0070*   ; destroys: af
0B085A             0071*   hlu_sdiv256:
0B085A AF          0072*       xor a ; assume hl is positive
0B085B 22 71 08 0B 0073*       ld (@buffer),hl
0B085F             0074*       sign_hlu
0B085F 19          0001*M          add hl,de
0B0860 B7          0002*M          or a
0B0861 ED 52       0003*M          sbc hl,de
0B0863 F2 68 08 0B 0075*       jp p,@hl_pos
0B0867 3D          0076*       dec a
0B0868             0077*   @hl_pos:
0B0868 32 74 08 0B 0078*       ld (@buffer+3),a
0B086C 2A 72 08 0B 0079*       ld hl,(@buffer+1)
0B0870 C9          0080*       ret
0B0871             0081*   @buffer: ds 4
0B0875             0082*   
0B0875             0083*   ; hlu 1 byte right shift, unsigned
0B0875             0084*   ; returns: hlu / 256, fractional portion in a
0B0875             0085*   ; destroys: af
0B0875             0086*   hlu_udiv256:
0B0875 AF          0087*   	xor a
0B0876 32 87 08 0B 0088*   	ld (@buffer+3),a
0B087A 7D          0089*   	ld a,l ; save the fractional portion
0B087B 22 84 08 0B 0090*   	ld (@buffer),hl
0B087F 2A 85 08 0B 0091*   	ld hl,(@buffer+1)
0B0883 C9          0092*   	ret
0B0884             0093*   @buffer: ds 4
0B0888             0094*   
0B0888             0095*       MACRO hlu_mul256
0B0888             0096*           add hl,hl ; * 2
0B0888             0097*           add hl,hl ; * 4
0B0888             0098*           add hl,hl ; * 8
0B0888             0099*           add hl,hl ; * 16
0B0888             0100*           add hl,hl ; * 32
0B0888             0101*           add hl,hl ; * 64
0B0888             0102*           add hl,hl ; * 128
0B0888             0103*           add hl,hl ; * 256
0B0888             0104*       ENDMACRO
0B0888             0105*   
0B0888             0106*   ; compute the modulo of hlu by deu
0B0888             0107*   ; outputs: hlu = hlu % deu
0B0888             0108*   ; destroys: f, hl
0B0888             0109*   hlu_mod:
0B0888 B7          0110*   	or a ; clear carry
0B0889             0111*   @loop:
0B0889 ED 52       0112*       sbc hl,de
0B088B DA 93 08 0B 0113*       jp c, @end
0B088F C3 89 08 0B 0114*       jp @loop
0B0893             0115*   @end:
0B0893 19          0116*       add hl,de
0B0894 C9          0117*   	ret
0B0895             0118*   
0B0895             0119*   
0B0895 00 00 00 00 0120*   add_bcd_arg1: db #00,#00,#00,#00
0B0899 00 00 00 00 0121*   add_bcd_arg2: db #00,#00,#00,#00
0B089D             0122*   
0B089D             0123*   ; set bcd values in a scratch memory address from registers bcde
0B089D             0124*   ; input: hl; scratch address,bcde; 8-place bcd number
0B089D             0125*   ; destroys ; hl
0B089D             0126*   set_bcd:
0B089D 73          0127*       ld (hl),e
0B089E 23          0128*       inc hl
0B089F 72          0129*       ld (hl),d
0B08A0 23          0130*       inc hl
0B08A1 71          0131*       ld (hl),c
0B08A2 23          0132*       inc hl
0B08A3 70          0133*       ld (hl),b
0B08A4 C9          0134*       ret
0B08A5             0135*   
0B08A5             0136*   ; load bcd values from a scratch memory address to bcde
0B08A5             0137*   ; input: hl; scratch address
0B08A5             0138*   ; output: bcde; 8-place bcd number
0B08A5             0139*   ; destroys: hl
0B08A5             0140*   get_bcd:
0B08A5 5E          0141*       ld e,(hl)
0B08A6 23          0142*       inc hl
0B08A7 56          0143*       ld d,(hl)
0B08A8 23          0144*       inc hl
0B08A9 4E          0145*       ld c,(hl)
0B08AA 23          0146*       inc hl
0B08AB 46          0147*       ld b,(hl)
0B08AC C9          0148*       ret
0B08AD             0149*   
0B08AD             0150*   ; BCD addition
0B08AD             0151*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08AD             0152*   ;       a is the number of bytes holding each number (number of places/2)
0B08AD             0153*   ; outputs: (hl) + (de) --> (hl)
0B08AD             0154*   ; destroys: a,b,de,hl
0B08AD             0155*   add_bcd:
0B08AD 47          0156*       ld b,a ; loop counter
0B08AE AF          0157*       xor a ; reset a, clear carry flag
0B08AF             0158*   adcec:
0B08AF 1A          0159*       ld a,(de) ; addend to acc
0B08B0 8E          0160*       adc a,(hl) ; add (hl) to acc
0B08B1 27          0161*       daa ; adjust result to bcd
0B08B2 77          0162*       ld (hl),a ; store result
0B08B3 23          0163*       inc hl ; advance memory pointers
0B08B4 13          0164*       inc de
0B08B5 10 F8       0165*       djnz adcec ; loop until b == 0
0B08B7 C9          0166*       ret
0B08B8             0167*   
0B08B8             0168*   ; BCD subtraction
0B08B8             0169*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08B8             0170*   ;       a is the number of bytes holding each number (number of places/2)
0B08B8             0171*   ; outputs: (hl) - (de) --> (hl)
0B08B8             0172*   ; destroys: a,b,de,hl
0B08B8             0173*   sub_bcd:
0B08B8 47          0174*       ld b,a ; loop counter
0B08B9 AF          0175*       xor a ; reset a,clear carry flag
0B08BA             0176*   subdec:
0B08BA 1A          0177*       ld a,(de) ; subtrahend to acc
0B08BB 9E          0178*       sbc a,(hl) ; subtract (hl) from acc
0B08BC 27          0179*       daa ; adjust result to bcd
0B08BD 77          0180*       ld (hl),a ; store result
0B08BE 23          0181*       inc hl ; advance memory pointers
0B08BF 13          0182*       inc de
0B08C0 10 F8       0183*       djnz subdec ; loop until b == 0
0B08C2 C9          0184*       ret
0B08C3             0185*   
0B08C3             0186*   ; http://www.z80.info/pseudo-random.txt
0B08C3             0187*   rand_8:
0B08C3 C5          0188*       push bc
0B08C4 3A D7 08 0B 0189*       ld a,(r_seed)
0B08C8 4F          0190*       ld c,a
0B08C9             0191*   
0B08C9 0F          0192*       rrca ; multiply by 32
0B08CA 0F          0193*       rrca
0B08CB 0F          0194*       rrca
0B08CC EE 1F       0195*       xor 0x1f
0B08CE             0196*   
0B08CE 81          0197*       add a,c
0B08CF DE FF       0198*       sbc a,255 ; carry
0B08D1             0199*   
0B08D1 32 D7 08 0B 0200*       ld (r_seed),a
0B08D5 C1          0201*       pop bc
0B08D6 C9          0202*       ret
0B08D7 50          0203*   r_seed: defb $50
0B08D8             0204*   
0B08D8             0205*   ; linear interpolation between two 24-bit numbers
0B08D8             0206*   ; may be signed or unsigned, and treated as integers or fractional
0B08D8             0207*   ; inputs: bc = start value, de = end value, a = interpolation factor
0B08D8             0208*   ; outputs: hl = interpolated value, a = multiply overflow to 32 bits (0 if no overflow)
0B08D8             0209*   ; destroys: af, hl, de
0B08D8             0210*   interpolate24:
0B08D8 C5          0211*       push bc ; save start value
0B08D9 EB          0212*       ex de,hl ; end value to hl
0B08DA B7          0213*       or a ; clear carry
0B08DB ED 42       0214*       sbc hl,bc ; hl = end - start
0B08DD CD EC 0A 0B 0215*       call umul24x8 ; hl = (end - start) * interpolation factor
0B08E1 C1          0216*       pop bc ; get back start value (was hl)
0B08E2 09          0217*       add hl,bc ; hl = start + (end - start) * interpolation factor
0B08E3 C9          0218*       ret
0B08E4             0021    	INCLUDE	"arith24.inc"
0B08E4             0001*   ;------------------------------------------------------------------------
0B08E4             0002*   ;  arith24.asm
0B08E4             0003*   ;  24-bit ez80 arithmetic routines
0B08E4             0004*   ;  Copyright (c) Shawn Sijnstra 2024
0B08E4             0005*   ;  MIT license
0B08E4             0006*   ;
0B08E4             0007*   ;  This library was created as a tool to help make ez80
0B08E4             0008*   ;  24-bit native assembly routines for simple mathematical problems
0B08E4             0009*   ;  more widely available.
0B08E4             0010*   ;
0B08E4             0011*   ;------------------------------------------------------------------------
0B08E4             0012*   
0B08E4             0013*   ;------------------------------------------------------------------------
0B08E4             0014*   ; umul24:	HL = HL*DE (unsigned)
0B08E4             0015*   ; Preserves AF, BC, DE
0B08E4             0016*   ; Uses a fast multiply routine.
0B08E4             0017*   ;------------------------------------------------------------------------
0B08E4             0018*   umul24:
0B08E4 D5          0019*   	push	DE
0B08E5 C5          0020*   	push	BC
0B08E6 F5          0021*   	push	AF
0B08E7 E5          0022*   	push	HL
0B08E8 C1          0023*   	pop		BC
0B08E9 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
0B08EB 21 00 00 00 0025*       ld	 	hl, 0 ; Result
0B08EF             0026*   umul24_lp:
0B08EF 29          0027*   	add	hl,hl
0B08F0 EB          0028*   	ex	de,hl
0B08F1 29          0029*   	add	hl,hl
0B08F2 EB          0030*   	ex	de,hl
0B08F3 30 01       0031*   	jr	nc,umul24_nc
0B08F5 09          0032*   	add	hl,bc
0B08F6             0033*   umul24_nc:
0B08F6 3D          0034*   	dec	a
0B08F7 20 F6       0035*   	jr	nz,umul24_lp
0B08F9 F1          0036*   	pop	af
0B08FA C1          0037*   	pop	bc
0B08FB D1          0038*   	pop	de
0B08FC C9          0039*   	ret
0B08FD             0040*   
0B08FD             0041*   
0B08FD             0042*   ;------------------------------------------------------------------------
0B08FD             0043*   ; udiv24
0B08FD             0044*   ; Unsigned 24-bit division
0B08FD             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B08FD             0046*   ;
0B08FD             0047*   ; Uses AF BC DE HL
0B08FD             0048*   ; Uses Restoring Division algorithm
0B08FD             0049*   ;------------------------------------------------------------------------
0B08FD             0050*   
0B08FD             0051*   udiv24:
0B08FD E5          0052*   	push	hl
0B08FE C1          0053*   	pop		bc	;move dividend to BCU
0B08FF 21 00 00 00 0054*   	ld		hl,0	;result
0B0903 A7          0055*   	and		a
0B0904 ED 52       0056*   	sbc		hl,de	;test for div by 0
0B0906 C8          0057*   	ret		z		;it's zero, carry flag is clear
0B0907 19          0058*   	add		hl,de	;HL is 0 again
0B0908 3E 18       0059*   	ld		a,24	;number of loops through.
0B090A             0060*   udiv1:
0B090A C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
0B090B E3          0062*   	ex		(sp),hl
0B090C 37          0063*   	scf
0B090D ED 6A       0064*   	adc	hl,hl
0B090F E3          0065*   	ex	(sp),hl
0B0910 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
0B0911             0067*   
0B0911 ED 6A       0068*   	adc	hl,hl
0B0913 A7          0069*   	and	a		;is this the bug
0B0914 ED 52       0070*   	sbc	hl,de
0B0916 30 02       0071*   	jr	nc,udiv2
0B0918 19          0072*   	add	hl,de
0B0919             0073*   ;	dec	c
0B0919 0B          0074*   	dec	bc
0B091A             0075*   udiv2:
0B091A 3D          0076*   	dec	a
0B091B 20 ED       0077*   	jr	nz,udiv1
0B091D 37          0078*   	scf		;flag used for div0 error
0B091E C5          0079*   	push	bc
0B091F D1          0080*   	pop		de	;remainder
0B0920 C9          0081*   	ret
0B0921             0082*   
0B0921             0083*   
0B0921             0084*   
0B0921             0085*   ;------------------------------------------------------------------------
0B0921             0086*   ; neg24
0B0921             0087*   ; Returns: HLU = 0-HLU
0B0921             0088*   ; preserves all other registers
0B0921             0089*   ;------------------------------------------------------------------------
0B0921             0090*   neg24:
0B0921 D5          0091*   	push	de
0B0922 EB          0092*   	ex		de,hl
0B0923 21 00 00 00 0093*   	ld		hl,0
0B0927 B7          0094*   	or		a
0B0928 ED 52       0095*   	sbc		hl,de
0B092A D1          0096*   	pop		de
0B092B C9          0097*   	ret
0B092C             0098*   
0B092C             0099*   ;------------------------------------------------------------------------
0B092C             0100*   ; or_hlu_deu: 24 bit bitwise OR
0B092C             0101*   ; Returns: hlu = hlu OR deu
0B092C             0102*   ; preserves all other registers
0B092C             0103*   ;------------------------------------------------------------------------
0B092C             0104*   or_hlu_deu:
0B092C 22 B7 09 0B 0105*   	ld	(bitbuf1),hl
0B0930 ED 53 BA 09 0106*   	ld	(bitbuf2),de
       0B          
0B0935 D5          0107*   	push	de	;preserve DEU
0B0936 C5          0108*   	push	bc	;preserve BCU
0B0937 06 03       0109*   	ld		b,3
0B0939 21 B7 09 0B 0110*   	ld	hl,bitbuf1
0B093D 11 B7 09 0B 0111*   	ld	de,bitbuf1
0B0941             0112*   orloop_24:
0B0941 1A          0113*   	ld	a,(de)
0B0942 B6          0114*   	or	(hl)
0B0943 12          0115*   	ld	(de),a
0B0944 13          0116*   	inc	de
0B0945 23          0117*   	inc	hl
0B0946 10 F9       0118*   	djnz	orloop_24
0B0948 2A BA 09 0B 0119*   	ld	hl,(bitbuf2)
0B094C C1          0120*   	pop		bc	;restore BC
0B094D D1          0121*   	pop		de	;restore DE
0B094E             0122*   
0B094E             0123*   ;------------------------------------------------------------------------
0B094E             0124*   ; and_hlu_deu: 24 bit bitwise AND
0B094E             0125*   ; Returns: hlu = hlu AND deu
0B094E             0126*   ; preserves all other registers
0B094E             0127*   ;------------------------------------------------------------------------
0B094E             0128*   and_hlu_deu:
0B094E 22 B7 09 0B 0129*   	ld	(bitbuf1),hl
0B0952 ED 53 BA 09 0130*   	ld	(bitbuf2),de
       0B          
0B0957 D5          0131*   	push	de	;preserve DEU
0B0958 C5          0132*   	push	bc	;preserve BCU
0B0959 06 03       0133*   	ld		b,3
0B095B 21 B7 09 0B 0134*   	ld	hl,bitbuf1
0B095F 11 B7 09 0B 0135*   	ld	de,bitbuf1
0B0963             0136*   andloop_24:
0B0963 1A          0137*   	ld	a,(de)
0B0964 A6          0138*   	and	(hl)
0B0965 12          0139*   	ld	(de),a
0B0966 13          0140*   	inc	de
0B0967 23          0141*   	inc	hl
0B0968 10 F9       0142*   	djnz	andloop_24
0B096A 2A BA 09 0B 0143*   	ld	hl,(bitbuf2)
0B096E C1          0144*   	pop		bc	;restore BC
0B096F D1          0145*   	pop		de	;restore DE
0B0970             0146*   
0B0970             0147*   ;------------------------------------------------------------------------
0B0970             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0B0970             0149*   ; Returns: hlu = hlu XOR deu
0B0970             0150*   ; preserves all other registers
0B0970             0151*   ;------------------------------------------------------------------------
0B0970             0152*   xor_hlu_deu:
0B0970 22 B7 09 0B 0153*   	ld	(bitbuf1),hl
0B0974 ED 53 BA 09 0154*   	ld	(bitbuf2),de
       0B          
0B0979 D5          0155*   	push	de	;preserve DEU
0B097A C5          0156*   	push	bc	;preserve BCU
0B097B 06 03       0157*   	ld		b,3
0B097D 21 B7 09 0B 0158*   	ld	hl,bitbuf1
0B0981 11 B7 09 0B 0159*   	ld	de,bitbuf1
0B0985             0160*   xorloop_24:
0B0985 1A          0161*   	ld	a,(de)
0B0986 AE          0162*   	xor	(hl)
0B0987 12          0163*   	ld	(de),a
0B0988 13          0164*   	inc	de
0B0989 23          0165*   	inc	hl
0B098A 10 F9       0166*   	djnz	xorloop_24
0B098C 2A BA 09 0B 0167*   	ld	hl,(bitbuf2)
0B0990 C1          0168*   	pop		bc	;restore BC
0B0991 D1          0169*   	pop		de	;restore DE
0B0992             0170*   
0B0992             0171*   ;------------------------------------------------------------------------
0B0992             0172*   ; shl_hlu: 24 bit shift left hlu by deu positions
0B0992             0173*   ; Returns: hlu = hlu << deu
0B0992             0174*   ;		   de = 0
0B0992             0175*   ; NOTE: only considers deu up to 16 bits.
0B0992             0176*   ; preserves all other registers
0B0992             0177*   ;------------------------------------------------------------------------
0B0992             0178*   shl_hlu:
0B0992 7A          0179*   	ld		a,d		;up to 16 bit.
0B0993 B3          0180*   	or		e
0B0994 C8          0181*   	ret		z		;we're done
0B0995 29          0182*   	add		hl,hl	;shift HLU left
0B0996 1B          0183*   	dec		de
0B0997 18 F9       0184*   	jr		shl_hlu
0B0999             0185*   
0B0999             0186*   ;------------------------------------------------------------------------
0B0999             0187*   ; shr_hlu: 24 bit shift right hlu by deu positions
0B0999             0188*   ; Returns: hlu = hlu >> deu
0B0999             0189*   ;		   de = 0
0B0999             0190*   ; NOTE: only considers deu up to 16 bits.
0B0999             0191*   ; preserves all other registers
0B0999             0192*   ;------------------------------------------------------------------------
0B0999             0193*   shr_hlu:
0B0999 22 B7 09 0B 0194*   	ld		(bitbuf1),hl
0B099D 21 B9 09 0B 0195*   	ld		hl,bitbuf1+2
0B09A1             0196*   shr_loop:
0B09A1 7A          0197*   	ld		a,d		;up to 16 bit.
0B09A2 B3          0198*   	or		e
0B09A3 28 0D       0199*   	jr		z,shr_done		;we're done
0B09A5             0200*   ;carry is clear from or instruction
0B09A5 CB 1E       0201*   	rr		(hl)
0B09A7 2B          0202*   	dec		hl
0B09A8 CB 1E       0203*   	rr		(hl)
0B09AA 2B          0204*   	dec		hl
0B09AB CB 1E       0205*   	rr		(hl)
0B09AD 23          0206*   	inc		hl
0B09AE 23          0207*   	inc		hl
0B09AF 1B          0208*   	dec		de
0B09B0 18 EF       0209*   	jr		shr_loop
0B09B2             0210*   shr_done:
0B09B2 2A B7 09 0B 0211*   	ld		hl,(bitbuf1)	;collect result
0B09B6 C9          0212*   	ret
0B09B7             0213*   
0B09B7             0214*   ;------------------------------------------------------------------------
0B09B7             0215*   ; Scratch area for calculations
0B09B7             0216*   ;------------------------------------------------------------------------
0B09B7 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
0B09BA 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
0B09BD             0022        include "fixed24.inc"
0B09BD             0001*   arith24uaf: ds 6
0B09C3             0002*   arith24uhl: ds 6
0B09C9             0003*   arith24ubc: ds 6
0B09CF             0004*   arith24ude: ds 6
0B09D5             0005*   arith24uix: ds 6
0B09DB             0006*   arith24uiy: ds 6
0B09E1             0007*   arith24usp: ds 6
0B09E7             0008*   arith24upc: ds 6
0B09ED             0009*   
0B09ED             0010*   ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
0B09ED             0011*   ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
0B09ED             0012*   ; inputs: hlu = 24-bit number to shift
0B09ED             0013*   ;         a = signed number of bits to shift
0B09ED             0014*   ;         ix = output buffer address
0B09ED             0015*   ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
0B09ED             0016*   shift_hlu:
0B09ED C5          0017*       push bc ; preserve
0B09EE 47          0018*       ld b,a            ; store shift value in b for later
0B09EF             0019*   
0B09EF             0020*   ; Initialize DE to zero and clear output buffer
0B09EF 11 00 00 00 0021*       ld de, 0
0B09F3 DD 1F FD    0022*       ld (ix-3), de
0B09F6 DD 1F 03    0023*       ld (ix+3), de
0B09F9             0024*   
0B09F9             0025*   ; Get absolute value of a and save its original sign
0B09F9 B7          0026*       or a
0B09FA F5          0027*       push af ; save sign flag
0B09FB F2 01 0A 0B 0028*       jp p,@F ; If a is positive do nothing
0B09FF ED 44       0029*       neg ; If a is negative, negate it
0B0A01             0030*   @@:
0B0A01             0031*   
0B0A01             0032*   ; Write abs(HLU) to the output buffer and save its original sign
0B0A01 CD 0E 08 0B 0033*       call hlu_abs
0B0A05 F5          0034*       push af ; save sign of HLU
0B0A06 DD 2F 00    0035*       ld (ix), hl
0B0A09             0036*   
0B0A09             0037*   ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
0B0A09 78          0038*       ld a,b            ; Restore original shift value into 'a'
0B0A0A CB 3F       0039*       srl a             ; a = a / 2 (shift right 1 bit)
0B0A0C CB 3F       0040*       srl a             ; a = a / 4 (shift right another bit)
0B0A0E CB 3F       0041*       srl a             ; a = a / 8 (final shift for division by 8)
0B0A10 4F          0042*       ld c,a            ; c holds the number of whole bytes to shift
0B0A11             0043*   
0B0A11             0044*   ; Calculate remainder of a (original shift) mod 8
0B0A11 E6 07       0045*       and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0B0A13 47          0046*       ld b,a            ; 'b' now holds the number of bits to shift back up
0B0A14 11 00 00 00 0047*       ld de,0           ; Clear deu for computing the offset address later
0B0A18             0048*   
0B0A18             0049*       ; call dumpRegistersHex ; DEBUG
0B0A18             0050*   
0B0A18             0051*   ; Get back the original sign of the byte shift
0B0A18 F1          0052*       pop af            ; Restore sign flag
0B0A19 F2 27 0A 0B 0053*       jp p,@F           ; If a was positive, we're done
0B0A1D 79          0054*       ld a,c            ; 'a' now holds the number of whole bytes to shift
0B0A1E ED 44       0055*       neg               ; Negate the number of whole bytes to shift
0B0A20 3D          0056*       dec a             ; Subtract 1 because that's just how this works
0B0A21 4F          0057*       ld c,a            ; 'c' now holds the number of whole bytes to shift
0B0A22 1B          0058*       dec de            ; DE = -1 to make the signed addition below work
0B0A23 3E 08       0059*       ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0B0A25 90          0060*       sub b
0B0A26 47          0061*       ld b,a            ; b is the number of bits to shift back up
0B0A27             0062*   
0B0A27             0063*       ; call dumpRegistersHex ; DEBUG
0B0A27             0064*   
0B0A27             0065*   @@:
0B0A27             0066*   
0B0A27             0067*   ; Add the byte offset to the base address of output buffer
0B0A27 59          0068*       ld e,c            ; DEU and D were properly signed above
0B0A28 DD 19       0069*       add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
0B0A2A             0070*   
0B0A2A             0071*       ; call dumpRegistersHex ; DEBUG
0B0A2A             0072*   
0B0A2A             0073*   ; Read the byte-aligned result into HL and shift in the required number of bits
0B0A2A DD 27 00    0074*       ld hl,(ix)        ; Byte-aligned result
0B0A2D             0075*   
0B0A2D CD 9C 05 0B 0076*       call dumpRegistersHex ; DEBUG
0B0A31             0077*   
0B0A31             0078*   ; Check whether we're already byte-aligned
0B0A31 AF          0079*       xor a
0B0A32 B0          0080*       or b
0B0A33 28 10       0081*       jr z,@end         ; If no bits to shift, we're done
0B0A35             0082*   
0B0A35             0083*   ; Otherwise shiften zee bitzen
0B0A35 DD 7E FF    0084*       ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
0B0A38             0085*   @loop:
0B0A38 07          0086*       rlca              ; One bit to carry
0B0A39             0087*   
0B0A39 CD 2A 07 0B 0088*       call dumpFlags ; DEBUG
0B0A3D             0089*   
0B0A3D ED 6A       0090*       adc hl,hl         ; Shift the carry into the result
0B0A3F             0091*   
0B0A3F CD 9C 05 0B 0092*       call dumpRegistersHex ; DEBUG
0B0A43             0093*   
0B0A43 10 F3       0094*       djnz @loop        ; Loop until all bits are shifted up
0B0A45             0095*   
0B0A45             0096*   @end:
0B0A45             0097*   
0B0A45 CD 9C 05 0B 0098*       call dumpRegistersHex ; DEBUG
0B0A49             0099*   
0B0A49             0100*   ; get back HLU's original sign and negate if necessary
0B0A49 F1          0101*       pop af
0B0A4A F2 52 0A 0B 0102*       jp p,@F
0B0A4E CD 1E 08 0B 0103*       call neg_hlu
0B0A52             0104*   @@:
0B0A52             0105*   ; return the result
0B0A52 DD 2F 00    0106*       ld (ix),hl        ; Store the shifted result
0B0A55 C1          0107*       pop bc              ; Restore BC
0B0A56 C9          0108*       ret
0B0A57             0109*   
0B0A57             0110*   ; operation: UHL * UDE --> UHL
0B0A57             0111*   ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
0B0A57             0112*   ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0B0A57             0113*   ; inputs: hl = 24-bit number, de = 24-bit number,
0B0A57             0114*   ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0B0A57             0115*   ; outputs: umulfxout = 48-bit intermediate
0B0A57             0116*   ; destroys: af, hl, bc, de
0B0A57             0117*   umulfx:
0B0A57 DD E5       0118*       push ix ; preserve
0B0A59 F5          0119*       push af ; need later
0B0A5A             0120*   
0B0A5A             0121*   ; do the multiplication
0B0A5A CD 1B 0B 0B 0122*       call umul24x24
0B0A5E             0123*       ; DEBUG
0B0A5E 21 B0 0A 0B 0124*       ld hl,umulfxout ; point to output buffer
0B0A62 3E 06       0125*       ld a,6 ; 6 bytes to print
0B0A64 CD 9A 07 0B 0126*       call dumpMemoryHex ; print the result
0B0A68             0127*       ; END DEBUG
0B0A68             0128*   
0B0A68             0129*   ; shift the result to the required output precision
0B0A68 78          0130*       ld a,b
0B0A69 81          0131*       add a,c ; a is left shift from the multiplication
0B0A6A C1          0132*       pop bc ; b is the output precision (was a)
0B0A6B 90          0133*       sub b ; a is the net shift of the output
0B0A6C             0134*   
0B0A6C             0135*   ; Get absolute value of a and save its original sign
0B0A6C B7          0136*       or a
0B0A6D F5          0137*       push af ; save sign flag
0B0A6E F2 74 0A 0B 0138*       jp p,@F ; If a is positive do nothing
0B0A72 ED 44       0139*       neg ; If a is negative, negate it
0B0A74             0140*   @@:
0B0A74             0141*   
0B0A74             0142*   ; Divide a by 8 to get the whole byte shift and bit remainder
0B0A74 47          0143*       ld b,a            ; Store 'a' temporarily in 'b' (net shift)
0B0A75 CB 3F       0144*       srl a             ; a = a / 2 (shift right 1 bit)
0B0A77 CB 3F       0145*       srl a             ; a = a / 4 (shift right another bit)
0B0A79 CB 3F       0146*       srl a             ; a = a / 8 (final shift for division by 8)
0B0A7B 4F          0147*       ld c,a            ; c holds the number of whole bytes to shift
0B0A7C             0148*   
0B0A7C             0149*   ; Calculate remainder of a (original shift) mod 8
0B0A7C 78          0150*       ld a,b            ; Restore original shift value into 'a'
0B0A7D E6 07       0151*       and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0B0A7F 47          0152*       ld b,a            ; 'b' now holds the number of bits to shift back up
0B0A80 11 00 00 00 0153*       ld de,0           ; Clear deu for computing the offset address later
0B0A84             0154*   
0B0A84             0155*       ; call dumpRegistersHex ; DEBUG
0B0A84             0156*   
0B0A84             0157*   ; Get back the original sign of the byte shift
0B0A84 F1          0158*       pop af            ; Restore sign flag
0B0A85 F2 93 0A 0B 0159*       jp p,@F           ; If a was positive, we're done
0B0A89 79          0160*       ld a,c            ; 'a' now holds the number of whole bytes to shift
0B0A8A ED 44       0161*       neg               ; Negate the number of whole bytes to shift
0B0A8C 3D          0162*       dec a             ; Subtract 1 because that's just how this works
0B0A8D 4F          0163*       ld c,a            ; 'c' now holds the number of whole bytes to shift
0B0A8E 1B          0164*       dec de            ; DE = -1 to make the signed addition below work
0B0A8F 3E 08       0165*       ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0B0A91 90          0166*       sub b
0B0A92 47          0167*       ld b,a            ; b is the number of bits to shift back up
0B0A93             0168*   
0B0A93             0169*       ; call dumpRegistersHex ; DEBUG
0B0A93             0170*   
0B0A93             0171*   @@:
0B0A93             0172*   
0B0A93             0173*   ; Add the byte offset to the base address of umulfxout
0B0A93 59          0174*       ld e,c            ; DEU and D were properly signed above
0B0A94 DD 21 B0 0A 0175*       ld ix,umulfxout   ; Load base address of the output buffer
       0B          
0B0A99 DD 19       0176*       add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
0B0A9B             0177*   
0B0A9B             0178*       ; call dumpRegistersHex ; DEBUG
0B0A9B             0179*   
0B0A9B             0180*   ; Read the byte-aligned result into HL and shift in the required number of bits
0B0A9B DD 27 00    0181*       ld hl,(ix)        ; Byte-aligned result
0B0A9E DD 7E FF    0182*       ld a,(ix-1)       ; One byte below
0B0AA1             0183*   
0B0AA1             0184*   ; Check whether we're already byte-aligned
0B0AA1 AF          0185*       xor a
0B0AA2 B0          0186*       or b
0B0AA3 28 05       0187*       jr z,@end         ; If no bits to shift, we're done
0B0AA5             0188*   
0B0AA5             0189*   ; Otherwise shiften zee bitzen
0B0AA5             0190*   @loop:
0B0AA5             0191*   
0B0AA5             0192*       ; call dumpRegistersHex ; DEBUG
0B0AA5             0193*   
0B0AA5 07          0194*       rlca              ; One bit to carry
0B0AA6 ED 6A       0195*       adc hl,hl         ; Shift the carry into the result
0B0AA8             0196*   
0B0AA8 10 FB       0197*       djnz @loop        ; Loop until all bits are shifted up
0B0AAA             0198*   
0B0AAA             0199*   @end:
0B0AAA             0200*   ; return the result
0B0AAA DD E1       0201*       pop ix ; restore
0B0AAC C9          0202*       ret
0B0AAD             0203*   
0B0AAD 00 00 00    0204*       dl 0 ; padding
0B0AB0 00 00 00 00 0205*   umulfxout: blkb 6,0
       00 00       
0B0AB6 00 00 00    0206*       dl 0 ; padding
0B0AB9             0207*   
0B0AB9             0208*   ; operation: UHL * UDE --> UHL
0B0AB9             0209*   ; multiply signed 24-bit numbers and return a 48-bit intermediate
0B0AB9             0210*   ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0B0AB9             0211*   ; inputs: hl = 24-bit number, de = 24-bit number,
0B0AB9             0212*   ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0B0AB9             0213*   ; outputs: umulfxout = 48-bit intermediate
0B0AB9             0214*   ; destroys: af, hl, bc, de
0B0AB9             0215*   smulfx:
0B0AB9             0216*   ; make everything positive and store sign flags
0B0AB9 CD 0E 08 0B 0217*   	call hlu_abs
0B0ABD F5          0218*   	push af
0B0ABE EB          0219*   	ex de,hl
0B0ABF CD 0E 08 0B 0220*   	call hlu_abs
0B0AC3 EB          0221*   	ex de,hl
0B0AC4 F5          0222*   	push af
0B0AC5             0223*   ; do the division
0B0AC5 CD 57 0A 0B 0224*       call umulfx ; hl = product
0B0AC9             0225*   ; adjust sign of result
0B0AC9 F1          0226*   	pop af ; sign de
0B0ACA FA D5 0A 0B 0227*   	jp m,@de_neg
0B0ACE F1          0228*   	pop af ; sign hl
0B0ACF F0          0229*   	ret p ; both positive, nothing to do
0B0AD0             0230*   @hl_neg:
0B0AD0 CD 1E 08 0B 0231*       call neg_hlu ; de pos, hl neg, result is negative
0B0AD4 C9          0232*       ret
0B0AD5             0233*   @de_neg:
0B0AD5 F1          0234*   	pop af
0B0AD6 F8          0235*   	ret m ; both negative, nothing to do
0B0AD7 CD 1E 08 0B 0236*   	call neg_hlu ; result is negative
0B0ADB C9          0237*   	ret
0B0ADC             0238*   
0B0ADC             0239*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B0ADC             0240*   ; uses EZ80 MLT instruction for speed
0B0ADC             0241*   ; operation: UHL * A --> UHL
0B0ADC             0242*   ; destroys: AF, HL
0B0ADC             0243*   smul24x8:
0B0ADC             0244*   ; make hl positive and store sign flag
0B0ADC CD 0E 08 0B 0245*   	call hlu_abs
0B0AE0 F5          0246*   	push af
0B0AE1             0247*   ; do the division
0B0AE1 CD EC 0A 0B 0248*       call umul24x8 ; hl = product
0B0AE5             0249*   ; adjust sign of result
0B0AE5 F1          0250*   	pop af ; sign de
0B0AE6 F0          0251*   	ret p ; hl was positive, nothing to do
0B0AE7 CD 1E 08 0B 0252*   	call neg_hlu ; result is negative
0B0AEB C9          0253*   	ret
0B0AEC             0254*   
0B0AEC             0255*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0AEC             0256*   ; uses EZ80 MLT instruction for speed
0B0AEC             0257*   ; operation: UHL * A --> AUHL
0B0AEC             0258*   ; destroys: AF, HL
0B0AEC             0259*   umul24x8:
0B0AEC D5          0260*   	push de ; preserve de
0B0AED             0261*   ; low byte
0B0AED 5D          0262*   	ld e,l
0B0AEE 57          0263*   	ld d,a
0B0AEF ED 5C       0264*   	mlt de
0B0AF1 6B          0265*   	ld l,e ; product low byte
0B0AF2 08          0266*   	ex af,af' ; save multiplier
0B0AF3 7A          0267*   	ld a,d ; carry
0B0AF4 08          0268*   	ex af,af' ; save carry, restore multiplier
0B0AF5             0269*   ; high byte
0B0AF5 5C          0270*   	ld e,h
0B0AF6 57          0271*   	ld d,a
0B0AF7 ED 5C       0272*   	mlt de
0B0AF9 08          0273*   	ex af,af' ; save multiplier, restore carry
0B0AFA 83          0274*   	add a,e ; add carry
0B0AFB 67          0275*   	ld h,a ; product middle byte
0B0AFC 7A          0276*   	ld a,d ; carry
0B0AFD 08          0277*   	ex af,af' ; save carry, restore multiplier
0B0AFE             0278*   ; upper byte
0B0AFE E5          0279*   	push hl
0B0AFF 33          0280*   	inc sp
0B0B00 D1          0281*   	pop de ; d = hlu
0B0B01 3B          0282*   	dec sp
0B0B02 5F          0283*   	ld e,a
0B0B03 ED 5C       0284*   	mlt de
0B0B05 08          0285*   	ex af,af' ; restore carry
0B0B06 8B          0286*   	adc a,e ; add carry
0B0B07 22 18 0B 0B 0287*       ld (@scratch),hl ; 7 cycles
0B0B0B 32 1A 0B 0B 0288*       ld (@scratch+2),a ; 5 cycles
0B0B0F 2A 18 0B 0B 0289*       ld hl,(@scratch) ; 7 cycles
0B0B13             0290*   ; highest byte
0B0B13 3E 00       0291*   	ld a,0 ; preserve carry flag
0B0B15 8A          0292*   	adc a,d ; product highest byte
0B0B16 D1          0293*   	pop de ; restore de
0B0B17 C9          0294*   	ret
0B0B18             0295*   @scratch: ds 3
0B0B1B             0296*   
0B0B1B             0297*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0B1B             0298*   ; operation: UHL * UDE --> umulfxout
0B0B1B             0299*   umul24x24:
0B0B1B FD 21 B0 0A 0300*   	ld iy,umulfxout ; point to output buffer
       0B          
0B0B20 C5          0301*   	push bc
0B0B21 01 00 00 00 0302*   	ld bc,0
0B0B25 FD 0F 00    0303*   	ld (iy),bc
0B0B28 FD 0F 03    0304*   	ld (iy+3),bc
0B0B2B C1          0305*   	pop bc
0B0B2C             0306*   
0B0B2C             0307*   ; STEP 1: UHL * E
0B0B2C 7B          0308*   	ld a,e
0B0B2D E5          0309*   	push hl
0B0B2E CD EC 0A 0B 0310*   	call umul24x8
0B0B32 FD 2F 00    0311*   	ld (iy+0),hl
0B0B35 FD 77 03    0312*   	ld (iy+3),a
0B0B38             0313*   
0B0B38             0314*   ; STEP 2: UHL * D
0B0B38 E1          0315*   	pop hl
0B0B39 E5          0316*   	push hl
0B0B3A 7A          0317*   	ld a,d
0B0B3B CD EC 0A 0B 0318*   	call umul24x8
0B0B3F CD 4C 0B 0B 0319*   	call @accumulate
0B0B43             0320*   
0B0B43             0321*   ; STEP 3: UHL * DEU
0B0B43 E1          0322*   	pop hl
0B0B44 D5          0323*   	push de
0B0B45 33          0324*   	inc sp
0B0B46 F1          0325*   	pop af
0B0B47 3B          0326*   	dec sp
0B0B48 CD EC 0A 0B 0327*   	call umul24x8
0B0B4C             0328*   
0B0B4C             0329*   @accumulate:
0B0B4C FD 23       0330*   	inc iy
0B0B4E             0331*   ; highest byte of product to carry
0B0B4E FD 77 03    0332*   	ld (iy+3),a
0B0B51             0333*   ; low byte of product
0B0B51 7D          0334*   	ld a,l
0B0B52 FD 86 00    0335*   	add a,(iy+0)
0B0B55 FD 77 00    0336*   	ld (iy+0),a
0B0B58             0337*   ; high byte of product
0B0B58 7C          0338*   	ld a,h
0B0B59 FD 8E 01    0339*   	adc a,(iy+1)
0B0B5C FD 77 01    0340*   	ld (iy+1),a
0B0B5F             0341*   ; uppper byte of product
0B0B5F E5          0342*   	push hl
0B0B60 33          0343*   	inc sp
0B0B61 E1          0344*   	pop hl
0B0B62 3B          0345*   	dec sp
0B0B63 7C          0346*   	ld a,h
0B0B64 FD 8E 02    0347*   	adc a,(iy+2)
0B0B67 FD 77 02    0348*   	ld (iy+2),a
0B0B6A             0349*   ; carry
0B0B6A 3E 00       0350*   	ld a,0 ; preserve flags
0B0B6C FD 8E 03    0351*   	adc a,(iy+3)
0B0B6F FD 77 03    0352*   	ld (iy+3),a
0B0B72 C9          0353*   	ret
0B0B73             0354*   
0B0B73             0355*   ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B0B73             0356*   umul168:
0B0B73 CD 1B 0B 0B 0357*   	call umul24x24
0B0B77 FD 27 FF    0358*   	ld hl,(iy-1)
0B0B7A C9          0359*   	ret
0B0B7B             0360*   
0B0B7B             0361*   ; smul168:	UH.L * UD.E --> UH.L (signed)
0B0B7B             0362*   smul168:
0B0B7B             0363*   ; make everything positive and store sign flags
0B0B7B CD 0E 08 0B 0364*   	call hlu_abs
0B0B7F F5          0365*   	push af
0B0B80 EB          0366*   	ex de,hl
0B0B81 CD 0E 08 0B 0367*   	call hlu_abs
0B0B85 EB          0368*   	ex de,hl
0B0B86 F5          0369*   	push af
0B0B87             0370*   ; do the division
0B0B87 CD 73 0B 0B 0371*       call umul168 ; hl = product
0B0B8B             0372*   ; adjust sign of result
0B0B8B F1          0373*   	pop af ; sign de
0B0B8C FA 97 0B 0B 0374*   	jp m,@de_neg
0B0B90 F1          0375*   	pop af ; sign hl
0B0B91 F0          0376*   	ret p ; both positive, nothing to do
0B0B92             0377*   @hl_neg:
0B0B92 CD 1E 08 0B 0378*       call neg_hlu ; de pos, hl neg, result is negative
0B0B96 C9          0379*       ret
0B0B97             0380*   @de_neg:
0B0B97 F1          0381*   	pop af
0B0B98 F8          0382*   	ret m ; both negative, nothing to do
0B0B99 CD 1E 08 0B 0383*   	call neg_hlu ; result is negative
0B0B9D C9          0384*   	ret
0B0B9E             0385*   
0B0B9E             0386*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B0B9E             0387*   ; perform unsigned division of 16.8 fixed place values
0B0B9E             0388*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B0B9E             0389*   udiv168:
0B0B9E             0390*   ; back up divisor
0B0B9E ED 53 D5 0B 0391*   	ld (@ude),de
       0B          
0B0BA3             0392*   ; get the 16-bit integer part of the quotient
0B0BA3 CD FD 08 0B 0393*       call udiv24 ; de = quotient, hl = remainder
0B0BA7             0394*   ; load quotient to upper three bytes of output
0B0BA7 ED 53 DC 0B 0395*       ld (div168_out+1),de
       0B          
0B0BAC             0396*   @div256:
0B0BAC             0397*   ; multiply remainder by 256
0B0BAC             0398*   	hlu_mul256
0B0BAC 29          0001*M          add hl,hl ; * 2
0B0BAD 29          0002*M          add hl,hl ; * 4
0B0BAE 29          0003*M          add hl,hl ; * 8
0B0BAF 29          0004*M          add hl,hl ; * 16
0B0BB0 29          0005*M          add hl,hl ; * 32
0B0BB1 29          0006*M          add hl,hl ; * 64
0B0BB2 29          0007*M          add hl,hl ; * 128
0B0BB3 29          0008*M          add hl,hl ; * 256
0B0BB4             0399*   ; skip fractional computation if remainder is zero
0B0BB4             0400*       sign_hlu
0B0BB4 19          0001*M          add hl,de
0B0BB5 B7          0002*M          or a
0B0BB6 ED 52       0003*M          sbc hl,de
0B0BB8 20 03       0401*       jr nz,@div_frac
0B0BBA AF          0402*       xor a
0B0BBB 18 0A       0403*       jr @write_frac
0B0BBD             0404*   ; now divide the shifted remainder by the divisor
0B0BBD             0405*   @div_frac:
0B0BBD ED 5B D5 0B 0406*   	ld de,(@ude) ; get back divisor
       0B          
0B0BC2 CD FD 08 0B 0407*       call udiv24 ; de = quotient, hl = remainder
0B0BC6             0408*   ; load low byte of quotient to low byte of output
0B0BC6 7B          0409*       ld a,e
0B0BC7             0410*   @write_frac:
0B0BC7 32 DB 0B 0B 0411*       ld (div168_out),a
0B0BCB             0412*   ; load de with return value
0B0BCB ED 5B DB 0B 0413*       ld de,(div168_out)
       0B          
0B0BD0             0414*   ; load a with any overflow
0B0BD0 3A DE 0B 0B 0415*       ld a,(div168_out+3)
0B0BD4 C9          0416*       ret ; ud.e is the 16.8 result
0B0BD5             0417*   @ude: ds 6
0B0BDB             0418*   div168_out: ds 4 ; the extra byte is for overflow
0B0BDF             0419*   
0B0BDF             0420*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B0BDF             0421*   ; perform signed division of 16.8 fixed place values
0B0BDF             0422*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B0BDF             0423*   sdiv168:
0B0BDF             0424*   ; make everything positive and store sign flags
0B0BDF CD 0E 08 0B 0425*   	call hlu_abs
0B0BE3 F5          0426*   	push af
0B0BE4 EB          0427*   	ex de,hl
0B0BE5 CD 0E 08 0B 0428*   	call hlu_abs
0B0BE9 EB          0429*   	ex de,hl
0B0BEA F5          0430*   	push af
0B0BEB             0431*   ; do the division
0B0BEB CD 9E 0B 0B 0432*       call udiv168 ; de = quotient, hl = remainder
0B0BEF             0433*   ; adjust sign of result
0B0BEF F1          0434*   	pop af ; sign de
0B0BF0 FA FD 0B 0B 0435*   	jp m,@de_neg
0B0BF4 F1          0436*   	pop af ; sign hl
0B0BF5 F0          0437*   	ret p ; both positive, nothing to do
0B0BF6             0438*   @hl_neg:
0B0BF6 EB          0439*       ex de,hl ; hl = quotient, de = remainder
0B0BF7 CD 1E 08 0B 0440*       call neg_hlu ; de pos, hl neg, result is negative
0B0BFB EB          0441*       ex de,hl ; de = negated quotient, hl = remainder
0B0BFC C9          0442*       ret
0B0BFD             0443*   @de_neg:
0B0BFD F1          0444*   	pop af
0B0BFE F8          0445*   	ret m ; both negative, nothing to do
0B0BFF EB          0446*       ex de,hl ; hl = quotient, de = remainder
0B0C00 CD 1E 08 0B 0447*   	call neg_hlu ; result is negative
0B0C04 EB          0448*       ex de,hl ; de = negated quotient, hl = remainder
0B0C05 C9          0449*   	ret
0B0C06             0450*   ; ========== FROM maths24.inc ==========
0B0C06             0451*   
0B0C06             0452*   ; Expects  ADL mode
0B0C06             0453*   ; Inputs:  UH.L
0B0C06             0454*   ; Outputs: UH.L is the 16.8 square root
0B0C06             0455*   ;          UD.E is the difference inputHL-DE^2
0B0C06             0456*   ;          c flag reset
0B0C06             0457*   sqrt168:
0B0C06 CD 10 0C 0B 0458*       call sqrt24
0B0C0A EB          0459*       ex de,hl
0B0C0B 29          0460*       add hl,hl
0B0C0C 29          0461*       add hl,hl
0B0C0D 29          0462*       add hl,hl
0B0C0E 29          0463*       add hl,hl
0B0C0F C9          0464*       ret
0B0C10             0465*   
0B0C10             0466*   ; Expects  ADL mode
0B0C10             0467*   ; Inputs:  HL
0B0C10             0468*   ; Outputs: DE is the integer square root
0B0C10             0469*   ;          HL is the difference inputHL-DE^2
0B0C10             0470*   ;          c flag reset
0B0C10             0471*   sqrt24:
0B0C10 AF          0472*       xor a
0B0C11 45          0473*       ld b,l
0B0C12 C5          0474*       push bc
0B0C13 47          0475*       ld b,a
0B0C14 57          0476*       ld d,a
0B0C15 4F          0477*       ld c,a
0B0C16 6F          0478*       ld l,a
0B0C17 5F          0479*       ld e,a
0B0C18             0480*   
0B0C18             0481*       ;Iteration 1
0B0C18 29          0482*       add hl,hl
0B0C19 CB 11       0483*       rl c
0B0C1B 29          0484*       add hl,hl
0B0C1C CB 11       0485*       rl c
0B0C1E 91          0486*       sub c
0B0C1F 30 04       0487*       jr nc,$+6
0B0C21 1C          0488*       inc e
0B0C22 1C          0489*       inc e
0B0C23 2F          0490*       cpl
0B0C24 4F          0491*       ld c,a
0B0C25             0492*   
0B0C25             0493*       ;Iteration 2
0B0C25 29          0494*       add hl,hl
0B0C26 CB 11       0495*       rl c
0B0C28 29          0496*       add hl,hl
0B0C29 CB 11       0497*       rl c
0B0C2B CB 13       0498*       rl e
0B0C2D 7B          0499*       ld a,e
0B0C2E 91          0500*       sub c
0B0C2F 30 04       0501*       jr nc,$+6
0B0C31 1C          0502*       inc e
0B0C32 1C          0503*       inc e
0B0C33 2F          0504*       cpl
0B0C34 4F          0505*       ld c,a
0B0C35             0506*   
0B0C35             0507*       ;Iteration 3
0B0C35 29          0508*       add hl,hl
0B0C36 CB 11       0509*       rl c
0B0C38 29          0510*       add hl,hl
0B0C39 CB 11       0511*       rl c
0B0C3B CB 13       0512*       rl e
0B0C3D 7B          0513*       ld a,e
0B0C3E 91          0514*       sub c
0B0C3F 30 04       0515*       jr nc,$+6
0B0C41 1C          0516*       inc e
0B0C42 1C          0517*       inc e
0B0C43 2F          0518*       cpl
0B0C44 4F          0519*       ld c,a
0B0C45             0520*   
0B0C45             0521*       ;Iteration 4
0B0C45 29          0522*       add hl,hl
0B0C46 CB 11       0523*       rl c
0B0C48 29          0524*       add hl,hl
0B0C49 CB 11       0525*       rl c
0B0C4B CB 13       0526*       rl e
0B0C4D 7B          0527*       ld a,e
0B0C4E 91          0528*       sub c
0B0C4F 30 04       0529*       jr nc,$+6
0B0C51 1C          0530*       inc e
0B0C52 1C          0531*       inc e
0B0C53 2F          0532*       cpl
0B0C54 4F          0533*       ld c,a
0B0C55             0534*   
0B0C55             0535*       ;Iteration 5
0B0C55 29          0536*       add hl,hl
0B0C56 CB 11       0537*       rl c
0B0C58 29          0538*       add hl,hl
0B0C59 CB 11       0539*       rl c
0B0C5B CB 13       0540*       rl e
0B0C5D 7B          0541*       ld a,e
0B0C5E 91          0542*       sub c
0B0C5F 30 04       0543*       jr nc,$+6
0B0C61 1C          0544*       inc e
0B0C62 1C          0545*       inc e
0B0C63 2F          0546*       cpl
0B0C64 4F          0547*       ld c,a
0B0C65             0548*   
0B0C65             0549*       ;Iteration 6
0B0C65 29          0550*       add hl,hl
0B0C66 CB 11       0551*       rl c
0B0C68 29          0552*       add hl,hl
0B0C69 CB 11       0553*       rl c
0B0C6B CB 13       0554*       rl e
0B0C6D 7B          0555*       ld a,e
0B0C6E 91          0556*       sub c
0B0C6F 30 04       0557*       jr nc,$+6
0B0C71 1C          0558*       inc e
0B0C72 1C          0559*       inc e
0B0C73 2F          0560*       cpl
0B0C74 4F          0561*       ld c,a
0B0C75             0562*   
0B0C75             0563*       ;Iteration 7
0B0C75 29          0564*       add hl,hl
0B0C76 CB 11       0565*       rl c
0B0C78 29          0566*       add hl,hl
0B0C79 CB 11       0567*       rl c
0B0C7B CB 10       0568*       rl b
0B0C7D EB          0569*       ex de,hl
0B0C7E 29          0570*       add hl,hl
0B0C7F E5          0571*       push hl
0B0C80 ED 42       0572*       sbc hl,bc
0B0C82 30 06       0573*       jr nc,$+8
0B0C84 7C          0574*       ld a,h
0B0C85 2F          0575*       cpl
0B0C86 47          0576*       ld b,a
0B0C87 7D          0577*       ld a,l
0B0C88 2F          0578*       cpl
0B0C89 4F          0579*       ld c,a
0B0C8A E1          0580*       pop hl
0B0C8B 30 02       0581*       jr nc,$+4
0B0C8D 23          0582*       inc hl
0B0C8E 23          0583*       inc hl
0B0C8F EB          0584*       ex de,hl
0B0C90             0585*   
0B0C90             0586*       ;Iteration 8
0B0C90 29          0587*       add hl,hl
0B0C91 69          0588*       ld l,c
0B0C92 60          0589*       ld h,b
0B0C93 ED 6A       0590*       adc hl,hl
0B0C95 ED 6A       0591*       adc hl,hl
0B0C97 EB          0592*       ex de,hl
0B0C98 29          0593*       add hl,hl
0B0C99 ED 52       0594*       sbc hl,de
0B0C9B 19          0595*       add hl,de
0B0C9C EB          0596*       ex de,hl
0B0C9D 30 04       0597*       jr nc,$+6
0B0C9F ED 52       0598*       sbc hl,de
0B0CA1 13          0599*       inc de
0B0CA2 13          0600*       inc de
0B0CA3             0601*   
0B0CA3             0602*       ;Iteration 9
0B0CA3 F1          0603*       pop af
0B0CA4 17          0604*       rla
0B0CA5 ED 6A       0605*       adc hl,hl
0B0CA7 17          0606*       rla
0B0CA8 ED 6A       0607*       adc hl,hl
0B0CAA EB          0608*       ex de,hl
0B0CAB 29          0609*       add hl,hl
0B0CAC ED 52       0610*       sbc hl,de
0B0CAE 19          0611*       add hl,de
0B0CAF EB          0612*       ex de,hl
0B0CB0 30 04       0613*       jr nc,$+6
0B0CB2 ED 52       0614*       sbc hl,de
0B0CB4 13          0615*       inc de
0B0CB5 13          0616*       inc de
0B0CB6             0617*   
0B0CB6             0618*       ;Iteration 10
0B0CB6 17          0619*       rla
0B0CB7 ED 6A       0620*       adc hl,hl
0B0CB9 17          0621*       rla
0B0CBA ED 6A       0622*       adc hl,hl
0B0CBC EB          0623*       ex de,hl
0B0CBD 29          0624*       add hl,hl
0B0CBE ED 52       0625*       sbc hl,de
0B0CC0 19          0626*       add hl,de
0B0CC1 EB          0627*       ex de,hl
0B0CC2 30 04       0628*       jr nc,$+6
0B0CC4 ED 52       0629*       sbc hl,de
0B0CC6 13          0630*       inc de
0B0CC7 13          0631*       inc de
0B0CC8             0632*   
0B0CC8             0633*       ;Iteration 11
0B0CC8 17          0634*       rla
0B0CC9 ED 6A       0635*       adc hl,hl
0B0CCB 17          0636*       rla
0B0CCC ED 6A       0637*       adc hl,hl
0B0CCE EB          0638*       ex de,hl
0B0CCF 29          0639*       add hl,hl
0B0CD0 ED 52       0640*       sbc hl,de
0B0CD2 19          0641*       add hl,de
0B0CD3 EB          0642*       ex de,hl
0B0CD4 30 04       0643*       jr nc,$+6
0B0CD6 ED 52       0644*       sbc hl,de
0B0CD8 13          0645*       inc de
0B0CD9 13          0646*       inc de
0B0CDA             0647*   
0B0CDA             0648*       ;Iteration 11
0B0CDA 17          0649*       rla
0B0CDB ED 6A       0650*       adc hl,hl
0B0CDD 17          0651*       rla
0B0CDE ED 6A       0652*       adc hl,hl
0B0CE0 EB          0653*       ex de,hl
0B0CE1 29          0654*       add hl,hl
0B0CE2 ED 52       0655*       sbc hl,de
0B0CE4 19          0656*       add hl,de
0B0CE5 EB          0657*       ex de,hl
0B0CE6 30 04       0658*       jr nc,$+6
0B0CE8 ED 52       0659*       sbc hl,de
0B0CEA 13          0660*       inc de
0B0CEB 13          0661*       inc de
0B0CEC             0662*   
0B0CEC CB 1A       0663*       rr d
0B0CEE CB 1B       0664*       rr e
0B0CF0 C9          0665*       ret
0B0CF1             0023        include "trig24.inc"
0B0CF1             0001*   
0B0CF1             0002*   ; convert signed angles from a 360 to 256 degree circle
0B0CF1             0003*   ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0CF1             0004*   ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0CF1             0005*   ; destroys: TODO
0B0CF1             0006*   deg_360_to_256:
0B0CF1 D5          0007*   	push de ; preserve de
0B0CF2             0008*   ; make angle positive and store sign flag
0B0CF2 CD 0E 08 0B 0009*   	call hlu_abs
0B0CF6 F5          0010*   	push af
0B0CF7             0011*   ; multiply by 256 first to keep precision
0B0CF7             0012*   	hlu_mul256 ; uh.l = uh.l * 256
0B0CF7 29          0001*M          add hl,hl ; * 2
0B0CF8 29          0002*M          add hl,hl ; * 4
0B0CF9 29          0003*M          add hl,hl ; * 8
0B0CFA 29          0004*M          add hl,hl ; * 16
0B0CFB 29          0005*M          add hl,hl ; * 32
0B0CFC 29          0006*M          add hl,hl ; * 64
0B0CFD 29          0007*M          add hl,hl ; * 128
0B0CFE 29          0008*M          add hl,hl ; * 256
0B0CFF             0013*   ; divide uh.l by 360
0B0CFF 11 68 01 00 0014*   	ld de,360
0B0D03 CD FD 08 0B 0015*   	call udiv24 ; ud.e = degrees / 360
0B0D07 EB          0016*   	ex de,hl    ; uh.l = degrees / 360
0B0D08             0017*   ; restore sign flag and adjust output accordingly
0B0D08 F1          0018*   	pop af
0B0D09 F2 11 0D 0B 0019*   	jp p,@pos ; positive number
0B0D0D CD 1E 08 0B 0020*   	call neg_hlu
0B0D11             0021*   @pos:
0B0D11             0022*   ; restore de and return uh.l as the result
0B0D11 D1          0023*   	pop de
0B0D12 C9          0024*   	ret
0B0D13             0025*   
0B0D13             0026*   ; fixed 16.8 routine
0B0D13             0027*   ; cos(uh.l) --> uh.l
0B0D13             0028*   ; destroys: de
0B0D13             0029*   cos168:
0B0D13             0030*   ; for cos we simply increment the angle by 90 degrees
0B0D13             0031*   ; or 0x004000 in 16.8 degrees256
0B0D13             0032*   ; which makes it a sin problem
0B0D13 11 00 40 00 0033*       ld de,0x004000
0B0D17 19          0034*       add hl,de ; modulo 256 happens below
0B0D18             0035*   ; fall through to sin168
0B0D18             0036*   
0B0D18             0037*   ; ---------------------
0B0D18             0038*   ; fixed 16.8 routine
0B0D18             0039*   ; sin(uh.l) --> uh.l
0B0D18             0040*   ; destroys: af
0B0D18             0041*   sin168:
0B0D18 D5          0042*   	push de
0B0D19 DD E5       0043*   	push ix
0B0D1B             0044*   ; handle negative angles appropriately
0B0D1B CD 0E 08 0B 0045*   	call hlu_abs
0B0D1F F2 28 0D 0B 0046*   	jp p,@f
0B0D23 11 00 00 FF 0047*   	ld de,-256*256
0B0D27 19          0048*   	add hl,de
0B0D28             0049*   @@:
0B0D28             0050*   ; get the lookup value for the integer portion of the angle
0B0D28 7D          0051*   	ld a,l ; save fractional part of the angle
0B0D29 2E 06       0052*   	ld l,6 ; multiply by 6 to get our lookup index
0B0D2B EB          0053*   	ex de,hl ; can't add ix,hl
0B0D2C ED 5C       0054*   	mlt de ; gosh that is handy
0B0D2E DD 21 9A 11 0055*       ld ix,sin_lut_816 ; grab the lut address
       0B          
0B0D33 DD 19       0056*       add ix,de ; bump hl by the index
0B0D35 DD 27 00    0057*       ld hl,(ix) ; hl = sin(int(angle))
0B0D38 B7          0058*   	or a  ; check fractional part of the angle for zero
0B0D39 CA 4A 0D 0B 0059*   	jp z,@f ; no fractional part so skip interpolation
0B0D3D             0060*   ; interpolate the fractional part of the angle
0B0D3D DD 17 03    0061*   	ld de,(ix+3)
0B0D40 EB          0062*   	ex de,hl
0B0D41 CD DC 0A 0B 0063*   	call smul24x8
0B0D45 CD 5A 08 0B 0064*   	call hlu_sdiv256
0B0D49 19          0065*   	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle))
0B0D4A             0066*   @@:
0B0D4A CD 5A 08 0B 0067*   	call hlu_sdiv256
0B0D4E DD E1       0068*   	pop ix
0B0D50 D1          0069*   	pop de
0B0D51 C9          0070*       ret ; and out
0B0D52             0071*   
0B0D52             0072*   ; 16.8 fixed inputs / outputs
0B0D52             0073*   ; takes: uh.l as angle in degrees 256
0B0D52             0074*   ;        ud.e as radius
0B0D52             0075*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B0D52             0076*   ;        displacements from origin (0,0)
0B0D52             0077*   ; destroys: everything except indexes
0B0D52             0078*   polar_to_cartesian:
0B0D52             0079*   	; call printNewLine ; DEBUG
0B0D52             0080*   ; back up input parameters
0B0D52 22 7D 0D 0B 0081*       ld (@angle), hl
0B0D56 ED 53 80 0D 0082*       ld (@radius), de
       0B          
0B0D5B             0083*   ; compute dx = cos(uh.l) * ud.e
0B0D5B CD 13 0D 0B 0084*       call cos168 ; uh.l = cos(uh.l)
0B0D5F             0085*   	; call print_hex_hl ; DEBUG
0B0D5F             0086*   	; call print_s168_hl ; DEBUG
0B0D5F ED 5B 80 0D 0087*   	ld de,(@radius)
       0B          
0B0D64 CD 7B 0B 0B 0088*   	call smul168 ; uh.l = dx
0B0D68 E5          0089*       push hl
0B0D69             0090*   ; compute dy = sin(uh.l) * ud.e
0B0D69 2A 7D 0D 0B 0091*       ld hl,(@angle)
0B0D6D CD 18 0D 0B 0092*       call sin168 ; uh.l = sin(uh.l)
0B0D71             0093*   	; call print_hex_hl ; DEBUG
0B0D71             0094*   	; call print_s168_hl ; DEBUG
0B0D71 ED 5B 80 0D 0095*       ld de,(@radius)
       0B          
0B0D76 CD 7B 0B 0B 0096*       call smul168    ; uh.l = dy
0B0D7A EB          0097*       ex de,hl       ; de = dy for output
0B0D7B C1          0098*       pop bc          ; bc = dx for output
0B0D7C             0099*   ; and out
0B0D7C C9          0100*       ret
0B0D7D             0101*   @angle: ds 3
0B0D80             0102*   @radius: ds 3
0B0D83             0103*   
0B0D83             0104*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0D83             0105*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0D83             0106*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0D83             0107*   ;         also populates scratch locations dx168 and dy168
0B0D83             0108*   ; destroys: a,hl,bc,de
0B0D83             0109*   dxy168:
0B0D83             0110*   ; compute dx = x1-x0
0B0D83 AF          0111*       xor a ; clear carry
0B0D84 DD E5       0112*       push ix ; move ix to hl via the stack
0B0D86 E1          0113*       pop hl ; hl = x1
0B0D87 ED 42       0114*       sbc hl,bc ; hl = dx
0B0D89 22 DE 0D 0B 0115*       ld (dx168),hl ; dx to scratch
0B0D8D             0116*   ; compute dy = y1-y0
0B0D8D AF          0117*       xor a ; clear carry
0B0D8E FD E5       0118*       push iy ; move iy to hl via the stack
0B0D90 E1          0119*       pop hl ; hl = y1
0B0D91 ED 52       0120*       sbc hl,de ; hl = dy
0B0D93 22 E4 0D 0B 0121*       ld (dy168),hl ; dy to scratch
0B0D97             0122*   ; populate output registers and return
0B0D97 EB          0123*       ex de,hl        ; ud.e = dy
0B0D98 ED 4B DE 0D 0124*       ld bc,(dx168)   ; ub.c = dx
       0B          
0B0D9D C9          0125*       ret
0B0D9E             0126*   
0B0D9E             0127*   ; compute the euclidian distance between two cartesian coordinates
0B0D9E             0128*   ; using the formula d = sqrt(dx^2+dy^2
0B0D9E             0129*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0D9E             0130*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0D9E             0131*   ; output; uh.l is the 16.8 fixed format distance
0B0D9E             0132*   ;       dx168/y are the 16.8 fixed format dx and dy
0B0D9E             0133*   ; destroys: a,hl,bc,de
0B0D9E             0134*   distance168:
0B0D9E             0135*   ; compute dx = x1-x0
0B0D9E AF          0136*       xor a ; clear carry
0B0D9F DD E5       0137*       push ix ; move ix to hl via the stack
0B0DA1 E1          0138*       pop hl ; hl = x1
0B0DA2 ED 42       0139*       sbc hl,bc ; hl = dx
0B0DA4 22 DE 0D 0B 0140*       ld (dx168),hl ; dx to scratch
0B0DA8             0141*   ; ; test dx for overflow
0B0DA8             0142*   ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0DA8             0143*   ; 	ex de,hl
0B0DA8             0144*   ; 	sbc hl,de ; test for overflow
0B0DA8             0145*   ; 	push af ; carry indicates overflow
0B0DA8             0146*   ; compute dy = y1-y0
0B0DA8 AF          0147*       xor a ; clear carry
0B0DA9 FD E5       0148*       push iy ; move iy to hl via the stack
0B0DAB E1          0149*       pop hl ; hl = y1
0B0DAC ED 52       0150*       sbc hl,de ; hl = dy
0B0DAE 22 E4 0D 0B 0151*       ld (dy168),hl ; dy to scratch
0B0DB2             0152*   ; ; test dy for overflow
0B0DB2             0153*   ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0DB2             0154*   ; 	ex de,hl
0B0DB2             0155*   ; 	sbc hl,de ; test for overflow
0B0DB2             0156*   ; 	push af ; carry indicates overflow
0B0DB2             0157*   ; compute dy^2
0B0DB2 2A E4 0D 0B 0158*   	ld hl,(dy168)
0B0DB6 CD 0E 08 0B 0159*       call hlu_abs  ; make dy positive so we can use unsigned multiply
0B0DBA             0160*       ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0DBA E5          0161*       push hl ; load hl/2 to bc via the stack
0B0DBB C1          0162*       pop bc ; bc = dy/2
0B0DBC EB          0163*       ex de,hl ; de = dy/2
0B0DBD CD 73 0B 0B 0164*       call umul168 ; uh.l = dy^2/2
0B0DC1 E5          0165*       push hl ; dy^2/2 to the stack
0B0DC2             0166*   ; compute dx^2
0B0DC2 2A DE 0D 0B 0167*       ld hl,(dx168) ; get back dx
0B0DC6 CD 0E 08 0B 0168*       call hlu_abs  ; make dx positive so we can use unsigned multiply
0B0DCA             0169*       ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0DCA E5          0170*       push hl ; load hl/2 to bc via the stack
0B0DCB C1          0171*       pop bc ; bc = dx/2
0B0DCC EB          0172*       ex de,hl ; de = dx/2
0B0DCD CD 73 0B 0B 0173*       call umul168 ; uh.l = dx^2/2
0B0DD1             0174*   ; commpute dy^2+dx^2
0B0DD1 D1          0175*       pop de ; get back dx^2/2
0B0DD2 19          0176*       add hl,de ; hl = dx^2/2+dy^2/2
0B0DD3             0177*   ; compute sqrt(dx^2/2+dy^2/2)
0B0DD3 CD 06 0C 0B 0178*       call sqrt168 ; uh.l = distance/2
0B0DD7             0179*       ; add hl,hl ; hl = distance
0B0DD7             0180*   ; ; check for overflow
0B0DD7             0181*   ; 	pop af ; get back the overflow flags
0B0DD7             0182*   ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0DD7             0183*   ; 	ld b,a ; save the overflow flag
0B0DD7             0184*   ; 	pop af ; get back the overflow flags
0B0DD7             0185*   ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0DD7             0186*   ; 	add a,b ; if a != 0 then we had overflow
0B0DD7             0187*   ;     ret z ; no overflow we're done
0B0DD7             0188*   ; @overflow:
0B0DD7             0189*   ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0DD7 C9          0190*   	ret
0B0DD8             0191*   @scratch: ds 6
0B0DDE             0192*   dx168: ds 6
0B0DE4             0193*   dy168: ds 6
0B0DEA             0194*   
0B0DEA             0195*   ; atan2(ub.c,ud.e) --> uh.l
0B0DEA             0196*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0DEA             0197*   ;   whether inputs are integers or fractional doesn't matter
0B0DEA             0198*   ;   so long as the sign bit of the upper byte is correct
0B0DEA             0199*   ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0DEA             0200*   ; angles are COMPASS HEADINGS based on
0B0DEA             0201*   ; screen coordinate conventions,where the y axis is flipped
0B0DEA             0202*   ; #E0 315      0       45 #20
0B0DEA             0203*   ;        -x,-y | +x,-y
0B0DEA             0204*   ; #C0 270------+------ 90 #40
0B0DEA             0205*   ;        -x,+y | +x,+y
0B0DEA             0206*   ; #A0 225   180 #80   135 #60
0B0DEA             0207*   atan2_168game:
0B0DEA             0208*   ; get signs and make everything positive
0B0DEA             0209*   ; get abs(x) and store its original sign
0B0DEA C5          0210*       push bc
0B0DEB E1          0211*       pop hl
0B0DEC CD 0E 08 0B 0212*       call hlu_abs ; if x was negative this also sets the sign flag
0B0DF0 E5          0213*       push hl ; store abs(x)
0B0DF1 C1          0214*       pop bc ; bc = abs(x)
0B0DF2 F5          0215*       push af ; store sign of x
0B0DF3             0216*   ; get abs(y) and store its original sign
0B0DF3 EB          0217*       ex de,hl ; hl = y
0B0DF4 CD 0E 08 0B 0218*       call hlu_abs ; if y was negative this also sets the sign flag
0B0DF8 EB          0219*       ex de,hl ; de = abs(y)
0B0DF9 F5          0220*       push af ; store sign of y
0B0DFA             0221*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0DFA             0222*   ; this ensures that our lookup value is between 0 and 1 inclusive
0B0DFA AF          0223*       xor a ; clear the carry flag
0B0DFB D5          0224*       push de
0B0DFC E1          0225*       pop hl
0B0DFD ED 42       0226*       sbc hl,bc
0B0DFF F5          0227*       push af ; save sign of de - bc
0B0E00 F2 09 0E 0B 0228*       jp p,@1 ; bc <= de, so we skip ahead
0B0E04             0229*   ; otherwise we swap bc and de
0B0E04 C5          0230*       push bc
0B0E05 E1          0231*       pop hl
0B0E06 EB          0232*       ex de,hl
0B0E07 E5          0233*       push hl
0B0E08 C1          0234*       pop bc
0B0E09             0235*   @1:
0B0E09             0236*   ; now we're ready to snag our preliminary result
0B0E09 CD 77 0E 0B 0237*       call atan_168game ; uh.l comes back with prelim result
0B0E0D             0238*   ; now we adjust uh.l based on sign of de - bc
0B0E0D F1          0239*       pop af
0B0E0E F2 1A 0E 0B 0240*       jp p,@2 ; bc <= de,so we skip ahead
0B0E12 EB          0241*       ex de,hl
0B0E13 21 00 40 00 0242*       ld hl,0x004000 ; 90 degrees
0B0E17 AF          0243*       xor a ; clear the carry flag
0B0E18 ED 52       0244*       sbc hl,de ; subtract result from 90 degrees
0B0E1A             0245*       ; ld de,0 ; prep to clear hlu
0B0E1A             0246*       ; ld d,h
0B0E1A             0247*       ; ld e,l
0B0E1A             0248*       ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0E1A             0249*       ; fall through
0B0E1A             0250*   @2:
0B0E1A             0251*   ; now the fun part of adjusting the result
0B0E1A             0252*   ; based on which quadrant (x,y) is in
0B0E1A             0253*   ; #E0 315      0       45 #20
0B0E1A             0254*   ;        -x,-y | +x,-y
0B0E1A             0255*   ; #C0 270------+------ 90 #40
0B0E1A             0256*   ;        -x,+y | +x,+y
0B0E1A             0257*   ; #A0 225   180 #80   135 #60
0B0E1A F1          0258*       pop af ; sign of y
0B0E1B CA 58 0E 0B 0259*       jp z,@y_zero
0B0E1F F2 38 0E 0B 0260*       jp p,@y_pos
0B0E23             0261*   ; y neg,check x
0B0E23 F1          0262*       pop af ; sign of x
0B0E24 CA 32 0E 0B 0263*       jp z,@y_neg_x_zero
0B0E28 F2 37 0E 0B 0264*       jp p,@y_neg_x_pos
0B0E2C             0265*   ; y neg,x neg
0B0E2C             0266*   ; angle is 270-360
0B0E2C             0267*   ; negating the intermediate does the trick
0B0E2C CD 1E 08 0B 0268*       call neg_hlu
0B0E30 18 31       0269*       jr @zero_hlu
0B0E32             0270*   
0B0E32             0271*   @y_neg_x_zero:
0B0E32             0272*   ; y neg,x zero
0B0E32             0273*   ; angle is 0
0B0E32 21 00 00 00 0274*       ld hl,0
0B0E36 C9          0275*       ret
0B0E37             0276*   @y_neg_x_pos:
0B0E37             0277*   ; y neg,x pos
0B0E37             0278*   ; angle is 0 to 90
0B0E37             0279*   ; so we're good
0B0E37 C9          0280*       ret
0B0E38             0281*   
0B0E38             0282*   @y_pos:
0B0E38 F1          0283*       pop af ; sign of x
0B0E39 CA 48 0E 0B 0284*       jp z,@y_pos_x_zero
0B0E3D F2 4D 0E 0B 0285*       jp p,@y_pos_x_pos
0B0E41             0286*   ; y pos,x neg
0B0E41             0287*   ; angle is 180-270
0B0E41             0288*   ; so we add 180 to intermediate
0B0E41 11 00 80 00 0289*       ld de,0x008000
0B0E45 19          0290*       add hl,de
0B0E46 18 1B       0291*       jr @zero_hlu
0B0E48             0292*   @y_pos_x_zero:
0B0E48             0293*   ; y pos,x zero
0B0E48             0294*   ; angle is 180
0B0E48 21 00 80 00 0295*       ld hl,0x008000
0B0E4C C9          0296*       ret
0B0E4D             0297*   @y_pos_x_pos:
0B0E4D             0298*   ; y pos,x pos
0B0E4D             0299*   ; angle is 90-180
0B0E4D             0300*   ; neg the intermediate and add 180 degrees
0B0E4D CD 1E 08 0B 0301*       call neg_hlu
0B0E51 11 00 80 00 0302*       ld de,0x008000
0B0E55 19          0303*       add hl,de
0B0E56 18 0B       0304*       jr @zero_hlu
0B0E58             0305*   
0B0E58             0306*   @y_zero:
0B0E58 F1          0307*       pop af ; sign of x
0B0E59 FA 5E 0E 0B 0308*       jp m,@y_zero_x_neg
0B0E5D             0309*   ; y zero,x pos
0B0E5D             0310*   ; angle is 90,nothing to do
0B0E5D C9          0311*       ret
0B0E5E             0312*   @y_zero_x_neg:
0B0E5E             0313*   ; y zero ,x neg
0B0E5E             0314*   ; angle is 270
0B0E5E 21 00 C0 00 0315*       ld hl,0x00C000
0B0E62 C9          0316*       ret
0B0E63             0317*   @zero_hlu:
0B0E63 AF          0318*       xor a
0B0E64 22 71 0E 0B 0319*       ld (@scratch),hl
0B0E68 32 73 0E 0B 0320*       ld (@scratch+2),a
0B0E6C 2A 71 0E 0B 0321*       ld hl,(@scratch)
0B0E70 C9          0322*       ret
0B0E71             0323*   @scratch: ds 6
0B0E77             0324*   
0B0E77             0325*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0E77             0326*   ; output: uh.l is the 16.8 fixed format angle
0B0E77             0327*   ; destroys: a,hl,bc,de
0B0E77             0328*   ; the following note was written by github copilot:
0B0E77             0329*   ; note: this routine is a bit of a hack
0B0E77             0330*   ;      but it works
0B0E77             0331*   ;      and it's fast
0B0E77             0332*   ;      and it's small
0B0E77             0333*   ;      and it's accurate
0B0E77             0334*   ;      and it's easy to understand
0B0E77             0335*   ;      and it's easy to modify
0B0E77             0336*   ;      and it's easy to use
0B0E77             0337*   ;      and it's easy to remember
0B0E77             0338*   ;      and it's easy to love
0B0E77             0339*   ;      and it's easy to hate
0B0E77             0340*   ;      and it's easy to ignore
0B0E77             0341*   ;      and it's easy to forget
0B0E77             0342*   ;      and it's easy to remember
0B0E77             0343*   ;      and it's easy to forget
0B0E77             0344*   ;      and it's easy to remember
0B0E77             0345*   ;      (ok the bot is stuck in a loop)
0B0E77             0346*   ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0E77             0347*   ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0E77             0348*   atan_168game:
0B0E77             0349*   ; because we use compass headings instead of geometric angles
0B0E77             0350*   ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0E77             0351*   ; we can do faster unsigned division here because we know dx and dy are positive
0B0E77 CD 9E 0B 0B 0352*   	call udiv168 ; uh.l = dx/dy
0B0E7B             0353*   ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0E7B             0354*   ; ; test uh.l for 0
0B0E7B             0355*   ;     add hl,de
0B0E7B             0356*   ;     or a
0B0E7B             0357*   ;     sbc hl,de
0B0E7B             0358*   ;     jr z,@is_zero
0B0E7B             0359*   ; ; test uh.l for 1
0B0E7B             0360*   ;     xor a ; clear carry
0B0E7B             0361*   ;     ex de,hl
0B0E7B             0362*   ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0E7B             0363*   ;     sbc hl,de
0B0E7B             0364*   ;     jr z,@is_45
0B0E7B             0365*   ; ; END TODO
0B0E7B             0366*   
0B0E7B             0367*   ; no special cases so we move on
0B0E7B             0368*   ; l contains the fractional portion of tan(uh.l)
0B0E7B             0369*   ; we multiply it by three to get our lookup table index
0B0E7B 26 03       0370*       ld h,3
0B0E7D ED 6C       0371*       mlt hl ; gosh that is handy
0B0E7F 11 00 00 00 0372*       ld de,0 ; clear deu
0B0E83 54          0373*       ld d,h ; copy hl to de
0B0E84 5D          0374*       ld e,l ; de contains our index
0B0E85 21 A0 1A 0B 0375*       ld hl,atan_lut_168 ; grab the lut address
0B0E89 19          0376*       add hl,de ; bump hl by the index
0B0E8A ED 27       0377*       ld hl,(hl) ; don't try this on a z80!
0B0E8C C9          0378*       ret ; and out
0B0E8D             0379*   @is_45:
0B0E8D 21 00 20 00 0380*       ld hl,0x002000 ; 45 degrees decimal
0B0E91 C9          0381*       ret
0B0E92             0382*   ; for the case tan(0)
0B0E92             0383*   @is_zero:
0B0E92 21 00 00 00 0384*       ld hl,0x000000
0B0E96 C9          0385*       ret
0B0E97             0386*   
0B0E97             0387*   sin_lut_168:
0B0E97 00 00 00    0388*   	dl 0x000000 ; 0.000 00, 0.000
0B0E9A 06 00 00    0389*   	dl 0x000006 ; 1.406 01, 0.025
0B0E9D 0C 00 00    0390*   	dl 0x00000C ; 2.813 02, 0.049
0B0EA0 12 00 00    0391*   	dl 0x000012 ; 4.219 03, 0.074
0B0EA3 19 00 00    0392*   	dl 0x000019 ; 5.625 04, 0.098
0B0EA6 1F 00 00    0393*   	dl 0x00001F ; 7.031 05, 0.122
0B0EA9 25 00 00    0394*   	dl 0x000025 ; 8.438 06, 0.147
0B0EAC 2B 00 00    0395*   	dl 0x00002B ; 9.844 07, 0.171
0B0EAF 31 00 00    0396*   	dl 0x000031 ; 11.250 08, 0.195
0B0EB2 38 00 00    0397*   	dl 0x000038 ; 12.656 09, 0.219
0B0EB5 3E 00 00    0398*   	dl 0x00003E ; 14.063 0A, 0.243
0B0EB8 44 00 00    0399*   	dl 0x000044 ; 15.469 0B, 0.267
0B0EBB 4A 00 00    0400*   	dl 0x00004A ; 16.875 0C, 0.290
0B0EBE 50 00 00    0401*   	dl 0x000050 ; 18.281 0D, 0.314
0B0EC1 56 00 00    0402*   	dl 0x000056 ; 19.688 0E, 0.337
0B0EC4 5C 00 00    0403*   	dl 0x00005C ; 21.094 0F, 0.360
0B0EC7 61 00 00    0404*   	dl 0x000061 ; 22.500 10, 0.383
0B0ECA 67 00 00    0405*   	dl 0x000067 ; 23.906 11, 0.405
0B0ECD 6D 00 00    0406*   	dl 0x00006D ; 25.313 12, 0.428
0B0ED0 73 00 00    0407*   	dl 0x000073 ; 26.719 13, 0.450
0B0ED3 78 00 00    0408*   	dl 0x000078 ; 28.125 14, 0.471
0B0ED6 7E 00 00    0409*   	dl 0x00007E ; 29.531 15, 0.493
0B0ED9 83 00 00    0410*   	dl 0x000083 ; 30.938 16, 0.514
0B0EDC 88 00 00    0411*   	dl 0x000088 ; 32.344 17, 0.535
0B0EDF 8E 00 00    0412*   	dl 0x00008E ; 33.750 18, 0.556
0B0EE2 93 00 00    0413*   	dl 0x000093 ; 35.156 19, 0.576
0B0EE5 98 00 00    0414*   	dl 0x000098 ; 36.563 1A, 0.596
0B0EE8 9D 00 00    0415*   	dl 0x00009D ; 37.969 1B, 0.615
0B0EEB A2 00 00    0416*   	dl 0x0000A2 ; 39.375 1C, 0.634
0B0EEE A7 00 00    0417*   	dl 0x0000A7 ; 40.781 1D, 0.653
0B0EF1 AB 00 00    0418*   	dl 0x0000AB ; 42.188 1E, 0.672
0B0EF4 B0 00 00    0419*   	dl 0x0000B0 ; 43.594 1F, 0.690
0B0EF7 B5 00 00    0420*   	dl 0x0000B5 ; 45.000 20, 0.707
0B0EFA B9 00 00    0421*   	dl 0x0000B9 ; 46.406 21, 0.724
0B0EFD BD 00 00    0422*   	dl 0x0000BD ; 47.813 22, 0.741
0B0F00 C1 00 00    0423*   	dl 0x0000C1 ; 49.219 23, 0.757
0B0F03 C5 00 00    0424*   	dl 0x0000C5 ; 50.625 24, 0.773
0B0F06 C9 00 00    0425*   	dl 0x0000C9 ; 52.031 25, 0.788
0B0F09 CD 00 00    0426*   	dl 0x0000CD ; 53.438 26, 0.803
0B0F0C D1 00 00    0427*   	dl 0x0000D1 ; 54.844 27, 0.818
0B0F0F D4 00 00    0428*   	dl 0x0000D4 ; 56.250 28, 0.831
0B0F12 D8 00 00    0429*   	dl 0x0000D8 ; 57.656 29, 0.845
0B0F15 DB 00 00    0430*   	dl 0x0000DB ; 59.063 2A, 0.858
0B0F18 DE 00 00    0431*   	dl 0x0000DE ; 60.469 2B, 0.870
0B0F1B E1 00 00    0432*   	dl 0x0000E1 ; 61.875 2C, 0.882
0B0F1E E4 00 00    0433*   	dl 0x0000E4 ; 63.281 2D, 0.893
0B0F21 E7 00 00    0434*   	dl 0x0000E7 ; 64.688 2E, 0.904
0B0F24 EA 00 00    0435*   	dl 0x0000EA ; 66.094 2F, 0.914
0B0F27 EC 00 00    0436*   	dl 0x0000EC ; 67.500 30, 0.924
0B0F2A EE 00 00    0437*   	dl 0x0000EE ; 68.906 31, 0.933
0B0F2D F1 00 00    0438*   	dl 0x0000F1 ; 70.313 32, 0.942
0B0F30 F3 00 00    0439*   	dl 0x0000F3 ; 71.719 33, 0.950
0B0F33 F4 00 00    0440*   	dl 0x0000F4 ; 73.125 34, 0.957
0B0F36 F6 00 00    0441*   	dl 0x0000F6 ; 74.531 35, 0.964
0B0F39 F8 00 00    0442*   	dl 0x0000F8 ; 75.938 36, 0.970
0B0F3C F9 00 00    0443*   	dl 0x0000F9 ; 77.344 37, 0.976
0B0F3F FB 00 00    0444*   	dl 0x0000FB ; 78.750 38, 0.981
0B0F42 FC 00 00    0445*   	dl 0x0000FC ; 80.156 39, 0.985
0B0F45 FD 00 00    0446*   	dl 0x0000FD ; 81.563 3A, 0.989
0B0F48 FE 00 00    0447*   	dl 0x0000FE ; 82.969 3B, 0.992
0B0F4B FE 00 00    0448*   	dl 0x0000FE ; 84.375 3C, 0.995
0B0F4E FF 00 00    0449*   	dl 0x0000FF ; 85.781 3D, 0.997
0B0F51 FF 00 00    0450*   	dl 0x0000FF ; 87.188 3E, 0.999
0B0F54 FF 00 00    0451*   	dl 0x0000FF ; 88.594 3F, 1.000
0B0F57 00 01 00    0452*   	dl 0x000100 ; 90.000 40, 1.000
0B0F5A FF 00 00    0453*   	dl 0x0000FF ; 91.406 41, 1.000
0B0F5D FF 00 00    0454*   	dl 0x0000FF ; 92.813 42, 0.999
0B0F60 FF 00 00    0455*   	dl 0x0000FF ; 94.219 43, 0.997
0B0F63 FE 00 00    0456*   	dl 0x0000FE ; 95.625 44, 0.995
0B0F66 FE 00 00    0457*   	dl 0x0000FE ; 97.031 45, 0.992
0B0F69 FD 00 00    0458*   	dl 0x0000FD ; 98.438 46, 0.989
0B0F6C FC 00 00    0459*   	dl 0x0000FC ; 99.844 47, 0.985
0B0F6F FB 00 00    0460*   	dl 0x0000FB ; 101.250 48, 0.981
0B0F72 F9 00 00    0461*   	dl 0x0000F9 ; 102.656 49, 0.976
0B0F75 F8 00 00    0462*   	dl 0x0000F8 ; 104.063 4A, 0.970
0B0F78 F6 00 00    0463*   	dl 0x0000F6 ; 105.469 4B, 0.964
0B0F7B F4 00 00    0464*   	dl 0x0000F4 ; 106.875 4C, 0.957
0B0F7E F3 00 00    0465*   	dl 0x0000F3 ; 108.281 4D, 0.950
0B0F81 F1 00 00    0466*   	dl 0x0000F1 ; 109.688 4E, 0.942
0B0F84 EE 00 00    0467*   	dl 0x0000EE ; 111.094 4F, 0.933
0B0F87 EC 00 00    0468*   	dl 0x0000EC ; 112.500 50, 0.924
0B0F8A EA 00 00    0469*   	dl 0x0000EA ; 113.906 51, 0.914
0B0F8D E7 00 00    0470*   	dl 0x0000E7 ; 115.313 52, 0.904
0B0F90 E4 00 00    0471*   	dl 0x0000E4 ; 116.719 53, 0.893
0B0F93 E1 00 00    0472*   	dl 0x0000E1 ; 118.125 54, 0.882
0B0F96 DE 00 00    0473*   	dl 0x0000DE ; 119.531 55, 0.870
0B0F99 DB 00 00    0474*   	dl 0x0000DB ; 120.938 56, 0.858
0B0F9C D8 00 00    0475*   	dl 0x0000D8 ; 122.344 57, 0.845
0B0F9F D4 00 00    0476*   	dl 0x0000D4 ; 123.750 58, 0.831
0B0FA2 D1 00 00    0477*   	dl 0x0000D1 ; 125.156 59, 0.818
0B0FA5 CD 00 00    0478*   	dl 0x0000CD ; 126.563 5A, 0.803
0B0FA8 C9 00 00    0479*   	dl 0x0000C9 ; 127.969 5B, 0.788
0B0FAB C5 00 00    0480*   	dl 0x0000C5 ; 129.375 5C, 0.773
0B0FAE C1 00 00    0481*   	dl 0x0000C1 ; 130.781 5D, 0.757
0B0FB1 BD 00 00    0482*   	dl 0x0000BD ; 132.188 5E, 0.741
0B0FB4 B9 00 00    0483*   	dl 0x0000B9 ; 133.594 5F, 0.724
0B0FB7 B5 00 00    0484*   	dl 0x0000B5 ; 135.000 60, 0.707
0B0FBA B0 00 00    0485*   	dl 0x0000B0 ; 136.406 61, 0.690
0B0FBD AB 00 00    0486*   	dl 0x0000AB ; 137.813 62, 0.672
0B0FC0 A7 00 00    0487*   	dl 0x0000A7 ; 139.219 63, 0.653
0B0FC3 A2 00 00    0488*   	dl 0x0000A2 ; 140.625 64, 0.634
0B0FC6 9D 00 00    0489*   	dl 0x00009D ; 142.031 65, 0.615
0B0FC9 98 00 00    0490*   	dl 0x000098 ; 143.438 66, 0.596
0B0FCC 93 00 00    0491*   	dl 0x000093 ; 144.844 67, 0.576
0B0FCF 8E 00 00    0492*   	dl 0x00008E ; 146.250 68, 0.556
0B0FD2 88 00 00    0493*   	dl 0x000088 ; 147.656 69, 0.535
0B0FD5 83 00 00    0494*   	dl 0x000083 ; 149.063 6A, 0.514
0B0FD8 7E 00 00    0495*   	dl 0x00007E ; 150.469 6B, 0.493
0B0FDB 78 00 00    0496*   	dl 0x000078 ; 151.875 6C, 0.471
0B0FDE 73 00 00    0497*   	dl 0x000073 ; 153.281 6D, 0.450
0B0FE1 6D 00 00    0498*   	dl 0x00006D ; 154.688 6E, 0.428
0B0FE4 67 00 00    0499*   	dl 0x000067 ; 156.094 6F, 0.405
0B0FE7 61 00 00    0500*   	dl 0x000061 ; 157.500 70, 0.383
0B0FEA 5C 00 00    0501*   	dl 0x00005C ; 158.906 71, 0.360
0B0FED 56 00 00    0502*   	dl 0x000056 ; 160.313 72, 0.337
0B0FF0 50 00 00    0503*   	dl 0x000050 ; 161.719 73, 0.314
0B0FF3 4A 00 00    0504*   	dl 0x00004A ; 163.125 74, 0.290
0B0FF6 44 00 00    0505*   	dl 0x000044 ; 164.531 75, 0.267
0B0FF9 3E 00 00    0506*   	dl 0x00003E ; 165.938 76, 0.243
0B0FFC 38 00 00    0507*   	dl 0x000038 ; 167.344 77, 0.219
0B0FFF 31 00 00    0508*   	dl 0x000031 ; 168.750 78, 0.195
0B1002 2B 00 00    0509*   	dl 0x00002B ; 170.156 79, 0.171
0B1005 25 00 00    0510*   	dl 0x000025 ; 171.563 7A, 0.147
0B1008 1F 00 00    0511*   	dl 0x00001F ; 172.969 7B, 0.122
0B100B 19 00 00    0512*   	dl 0x000019 ; 174.375 7C, 0.098
0B100E 12 00 00    0513*   	dl 0x000012 ; 175.781 7D, 0.074
0B1011 0C 00 00    0514*   	dl 0x00000C ; 177.188 7E, 0.049
0B1014 06 00 00    0515*   	dl 0x000006 ; 178.594 7F, 0.025
0B1017 00 00 00    0516*   	dl 0x000000 ; 180.000 80, 0.000
0B101A FA FF FF    0517*   	dl 0xFFFFFA ; 181.406 81, -0.025
0B101D F4 FF FF    0518*   	dl 0xFFFFF4 ; 182.813 82, -0.049
0B1020 EE FF FF    0519*   	dl 0xFFFFEE ; 184.219 83, -0.074
0B1023 E7 FF FF    0520*   	dl 0xFFFFE7 ; 185.625 84, -0.098
0B1026 E1 FF FF    0521*   	dl 0xFFFFE1 ; 187.031 85, -0.122
0B1029 DB FF FF    0522*   	dl 0xFFFFDB ; 188.438 86, -0.147
0B102C D5 FF FF    0523*   	dl 0xFFFFD5 ; 189.844 87, -0.171
0B102F CF FF FF    0524*   	dl 0xFFFFCF ; 191.250 88, -0.195
0B1032 C8 FF FF    0525*   	dl 0xFFFFC8 ; 192.656 89, -0.219
0B1035 C2 FF FF    0526*   	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B1038 BC FF FF    0527*   	dl 0xFFFFBC ; 195.469 8B, -0.267
0B103B B6 FF FF    0528*   	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B103E B0 FF FF    0529*   	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B1041 AA FF FF    0530*   	dl 0xFFFFAA ; 199.688 8E, -0.337
0B1044 A4 FF FF    0531*   	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B1047 9F FF FF    0532*   	dl 0xFFFF9F ; 202.500 90, -0.383
0B104A 99 FF FF    0533*   	dl 0xFFFF99 ; 203.906 91, -0.405
0B104D 93 FF FF    0534*   	dl 0xFFFF93 ; 205.313 92, -0.428
0B1050 8D FF FF    0535*   	dl 0xFFFF8D ; 206.719 93, -0.450
0B1053 88 FF FF    0536*   	dl 0xFFFF88 ; 208.125 94, -0.471
0B1056 82 FF FF    0537*   	dl 0xFFFF82 ; 209.531 95, -0.493
0B1059 7D FF FF    0538*   	dl 0xFFFF7D ; 210.938 96, -0.514
0B105C 78 FF FF    0539*   	dl 0xFFFF78 ; 212.344 97, -0.535
0B105F 72 FF FF    0540*   	dl 0xFFFF72 ; 213.750 98, -0.556
0B1062 6D FF FF    0541*   	dl 0xFFFF6D ; 215.156 99, -0.576
0B1065 68 FF FF    0542*   	dl 0xFFFF68 ; 216.563 9A, -0.596
0B1068 63 FF FF    0543*   	dl 0xFFFF63 ; 217.969 9B, -0.615
0B106B 5E FF FF    0544*   	dl 0xFFFF5E ; 219.375 9C, -0.634
0B106E 59 FF FF    0545*   	dl 0xFFFF59 ; 220.781 9D, -0.653
0B1071 55 FF FF    0546*   	dl 0xFFFF55 ; 222.188 9E, -0.672
0B1074 50 FF FF    0547*   	dl 0xFFFF50 ; 223.594 9F, -0.690
0B1077 4B FF FF    0548*   	dl 0xFFFF4B ; 225.000 A0, -0.707
0B107A 47 FF FF    0549*   	dl 0xFFFF47 ; 226.406 A1, -0.724
0B107D 43 FF FF    0550*   	dl 0xFFFF43 ; 227.813 A2, -0.741
0B1080 3F FF FF    0551*   	dl 0xFFFF3F ; 229.219 A3, -0.757
0B1083 3B FF FF    0552*   	dl 0xFFFF3B ; 230.625 A4, -0.773
0B1086 37 FF FF    0553*   	dl 0xFFFF37 ; 232.031 A5, -0.788
0B1089 33 FF FF    0554*   	dl 0xFFFF33 ; 233.438 A6, -0.803
0B108C 2F FF FF    0555*   	dl 0xFFFF2F ; 234.844 A7, -0.818
0B108F 2C FF FF    0556*   	dl 0xFFFF2C ; 236.250 A8, -0.831
0B1092 28 FF FF    0557*   	dl 0xFFFF28 ; 237.656 A9, -0.845
0B1095 25 FF FF    0558*   	dl 0xFFFF25 ; 239.063 AA, -0.858
0B1098 22 FF FF    0559*   	dl 0xFFFF22 ; 240.469 AB, -0.870
0B109B 1F FF FF    0560*   	dl 0xFFFF1F ; 241.875 AC, -0.882
0B109E 1C FF FF    0561*   	dl 0xFFFF1C ; 243.281 AD, -0.893
0B10A1 19 FF FF    0562*   	dl 0xFFFF19 ; 244.688 AE, -0.904
0B10A4 16 FF FF    0563*   	dl 0xFFFF16 ; 246.094 AF, -0.914
0B10A7 14 FF FF    0564*   	dl 0xFFFF14 ; 247.500 B0, -0.924
0B10AA 12 FF FF    0565*   	dl 0xFFFF12 ; 248.906 B1, -0.933
0B10AD 0F FF FF    0566*   	dl 0xFFFF0F ; 250.313 B2, -0.942
0B10B0 0D FF FF    0567*   	dl 0xFFFF0D ; 251.719 B3, -0.950
0B10B3 0C FF FF    0568*   	dl 0xFFFF0C ; 253.125 B4, -0.957
0B10B6 0A FF FF    0569*   	dl 0xFFFF0A ; 254.531 B5, -0.964
0B10B9 08 FF FF    0570*   	dl 0xFFFF08 ; 255.938 B6, -0.970
0B10BC 07 FF FF    0571*   	dl 0xFFFF07 ; 257.344 B7, -0.976
0B10BF 05 FF FF    0572*   	dl 0xFFFF05 ; 258.750 B8, -0.981
0B10C2 04 FF FF    0573*   	dl 0xFFFF04 ; 260.156 B9, -0.985
0B10C5 03 FF FF    0574*   	dl 0xFFFF03 ; 261.563 BA, -0.989
0B10C8 02 FF FF    0575*   	dl 0xFFFF02 ; 262.969 BB, -0.992
0B10CB 02 FF FF    0576*   	dl 0xFFFF02 ; 264.375 BC, -0.995
0B10CE 01 FF FF    0577*   	dl 0xFFFF01 ; 265.781 BD, -0.997
0B10D1 01 FF FF    0578*   	dl 0xFFFF01 ; 267.188 BE, -0.999
0B10D4 01 FF FF    0579*   	dl 0xFFFF01 ; 268.594 BF, -1.000
0B10D7 00 FF FF    0580*   	dl 0xFFFF00 ; 270.000 C0, -1.000
0B10DA 01 FF FF    0581*   	dl 0xFFFF01 ; 271.406 C1, -1.000
0B10DD 01 FF FF    0582*   	dl 0xFFFF01 ; 272.813 C2, -0.999
0B10E0 01 FF FF    0583*   	dl 0xFFFF01 ; 274.219 C3, -0.997
0B10E3 02 FF FF    0584*   	dl 0xFFFF02 ; 275.625 C4, -0.995
0B10E6 02 FF FF    0585*   	dl 0xFFFF02 ; 277.031 C5, -0.992
0B10E9 03 FF FF    0586*   	dl 0xFFFF03 ; 278.438 C6, -0.989
0B10EC 04 FF FF    0587*   	dl 0xFFFF04 ; 279.844 C7, -0.985
0B10EF 05 FF FF    0588*   	dl 0xFFFF05 ; 281.250 C8, -0.981
0B10F2 07 FF FF    0589*   	dl 0xFFFF07 ; 282.656 C9, -0.976
0B10F5 08 FF FF    0590*   	dl 0xFFFF08 ; 284.063 CA, -0.970
0B10F8 0A FF FF    0591*   	dl 0xFFFF0A ; 285.469 CB, -0.964
0B10FB 0C FF FF    0592*   	dl 0xFFFF0C ; 286.875 CC, -0.957
0B10FE 0D FF FF    0593*   	dl 0xFFFF0D ; 288.281 CD, -0.950
0B1101 0F FF FF    0594*   	dl 0xFFFF0F ; 289.688 CE, -0.942
0B1104 12 FF FF    0595*   	dl 0xFFFF12 ; 291.094 CF, -0.933
0B1107 14 FF FF    0596*   	dl 0xFFFF14 ; 292.500 D0, -0.924
0B110A 16 FF FF    0597*   	dl 0xFFFF16 ; 293.906 D1, -0.914
0B110D 19 FF FF    0598*   	dl 0xFFFF19 ; 295.313 D2, -0.904
0B1110 1C FF FF    0599*   	dl 0xFFFF1C ; 296.719 D3, -0.893
0B1113 1F FF FF    0600*   	dl 0xFFFF1F ; 298.125 D4, -0.882
0B1116 22 FF FF    0601*   	dl 0xFFFF22 ; 299.531 D5, -0.870
0B1119 25 FF FF    0602*   	dl 0xFFFF25 ; 300.938 D6, -0.858
0B111C 28 FF FF    0603*   	dl 0xFFFF28 ; 302.344 D7, -0.845
0B111F 2C FF FF    0604*   	dl 0xFFFF2C ; 303.750 D8, -0.831
0B1122 2F FF FF    0605*   	dl 0xFFFF2F ; 305.156 D9, -0.818
0B1125 33 FF FF    0606*   	dl 0xFFFF33 ; 306.563 DA, -0.803
0B1128 37 FF FF    0607*   	dl 0xFFFF37 ; 307.969 DB, -0.788
0B112B 3B FF FF    0608*   	dl 0xFFFF3B ; 309.375 DC, -0.773
0B112E 3F FF FF    0609*   	dl 0xFFFF3F ; 310.781 DD, -0.757
0B1131 43 FF FF    0610*   	dl 0xFFFF43 ; 312.188 DE, -0.741
0B1134 47 FF FF    0611*   	dl 0xFFFF47 ; 313.594 DF, -0.724
0B1137 4B FF FF    0612*   	dl 0xFFFF4B ; 315.000 E0, -0.707
0B113A 50 FF FF    0613*   	dl 0xFFFF50 ; 316.406 E1, -0.690
0B113D 55 FF FF    0614*   	dl 0xFFFF55 ; 317.813 E2, -0.672
0B1140 59 FF FF    0615*   	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1143 5E FF FF    0616*   	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1146 63 FF FF    0617*   	dl 0xFFFF63 ; 322.031 E5, -0.615
0B1149 68 FF FF    0618*   	dl 0xFFFF68 ; 323.438 E6, -0.596
0B114C 6D FF FF    0619*   	dl 0xFFFF6D ; 324.844 E7, -0.576
0B114F 72 FF FF    0620*   	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1152 78 FF FF    0621*   	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1155 7D FF FF    0622*   	dl 0xFFFF7D ; 329.063 EA, -0.514
0B1158 82 FF FF    0623*   	dl 0xFFFF82 ; 330.469 EB, -0.493
0B115B 88 FF FF    0624*   	dl 0xFFFF88 ; 331.875 EC, -0.471
0B115E 8D FF FF    0625*   	dl 0xFFFF8D ; 333.281 ED, -0.450
0B1161 93 FF FF    0626*   	dl 0xFFFF93 ; 334.688 EE, -0.428
0B1164 99 FF FF    0627*   	dl 0xFFFF99 ; 336.094 EF, -0.405
0B1167 9F FF FF    0628*   	dl 0xFFFF9F ; 337.500 F0, -0.383
0B116A A4 FF FF    0629*   	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B116D AA FF FF    0630*   	dl 0xFFFFAA ; 340.313 F2, -0.337
0B1170 B0 FF FF    0631*   	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B1173 B6 FF FF    0632*   	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B1176 BC FF FF    0633*   	dl 0xFFFFBC ; 344.531 F5, -0.267
0B1179 C2 FF FF    0634*   	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B117C C8 FF FF    0635*   	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B117F CF FF FF    0636*   	dl 0xFFFFCF ; 348.750 F8, -0.195
0B1182 D5 FF FF    0637*   	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B1185 DB FF FF    0638*   	dl 0xFFFFDB ; 351.563 FA, -0.147
0B1188 E1 FF FF    0639*   	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B118B E7 FF FF    0640*   	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B118E EE FF FF    0641*   	dl 0xFFFFEE ; 355.781 FD, -0.074
0B1191 F4 FF FF    0642*   	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B1194 FA FF FF    0643*   	dl 0xFFFFFA ; 358.594 FF, -0.025
0B1197 00 00 00    0644*   	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B119A             0645*   
0B119A             0646*   sin_lut_816:
0B119A 00 00 00 48 0647*       dl 0x000000,0x000648 ; 00 000.000 0.000
       06 00       
0B11A0 48 06 00 48 0648*       dl 0x000648,0x000648 ; 01 001.406 0.025
       06 00       
0B11A6 90 0C 00 45 0649*       dl 0x000C90,0x000645 ; 02 002.813 0.049
       06 00       
0B11AC D5 12 00 42 0650*       dl 0x0012D5,0x000642 ; 03 004.219 0.074
       06 00       
0B11B2 17 19 00 3E 0651*       dl 0x001917,0x00063E ; 04 005.625 0.098
       06 00       
0B11B8 56 1F 00 3A 0652*       dl 0x001F56,0x00063A ; 05 007.031 0.122
       06 00       
0B11BE 90 25 00 33 0653*       dl 0x002590,0x000633 ; 06 008.438 0.147
       06 00       
0B11C4 C4 2B 00 2C 0654*       dl 0x002BC4,0x00062C ; 07 009.844 0.171
       06 00       
0B11CA F1 31 00 25 0655*       dl 0x0031F1,0x000625 ; 08 011.250 0.195
       06 00       
0B11D0 16 38 00 1D 0656*       dl 0x003816,0x00061D ; 09 012.656 0.219
       06 00       
0B11D6 34 3E 00 13 0657*       dl 0x003E34,0x000613 ; 0A 014.063 0.243
       06 00       
0B11DC 47 44 00 08 0658*       dl 0x004447,0x000608 ; 0B 015.469 0.267
       06 00       
0B11E2 50 4A 00 FD 0659*       dl 0x004A50,0x0005FD ; 0C 016.875 0.290
       05 00       
0B11E8 4D 50 00 F1 0660*       dl 0x00504D,0x0005F1 ; 0D 018.281 0.314
       05 00       
0B11EE 3E 56 00 E3 0661*       dl 0x00563E,0x0005E3 ; 0E 019.688 0.337
       05 00       
0B11F4 22 5C 00 D5 0662*       dl 0x005C22,0x0005D5 ; 0F 021.094 0.360
       05 00       
0B11FA F7 61 00 C6 0663*       dl 0x0061F7,0x0005C6 ; 10 022.500 0.383
       05 00       
0B1200 BD 67 00 B7 0664*       dl 0x0067BD,0x0005B7 ; 11 023.906 0.405
       05 00       
0B1206 74 6D 00 A5 0665*       dl 0x006D74,0x0005A5 ; 12 025.313 0.428
       05 00       
0B120C 19 73 00 93 0666*       dl 0x007319,0x000593 ; 13 026.719 0.450
       05 00       
0B1212 AD 78 00 80 0667*       dl 0x0078AD,0x000580 ; 14 028.125 0.471
       05 00       
0B1218 2E 7E 00 6E 0668*       dl 0x007E2E,0x00056E ; 15 029.531 0.493
       05 00       
0B121E 9C 83 00 59 0669*       dl 0x00839C,0x000559 ; 16 030.938 0.514
       05 00       
0B1224 F5 88 00 44 0670*       dl 0x0088F5,0x000544 ; 17 032.344 0.535
       05 00       
0B122A 39 8E 00 2E 0671*       dl 0x008E39,0x00052E ; 18 033.750 0.556
       05 00       
0B1230 67 93 00 18 0672*       dl 0x009367,0x000518 ; 19 035.156 0.576
       05 00       
0B1236 80 98 00 FF 0673*       dl 0x009880,0x0004FF ; 1A 036.563 0.596
       04 00       
0B123C 80 9D 00 E7 0674*       dl 0x009D80,0x0004E7 ; 1B 037.969 0.615
       04 00       
0B1242 67 A2 00 CE 0675*       dl 0x00A267,0x0004CE ; 1C 039.375 0.634
       04 00       
0B1248 36 A7 00 B5 0676*       dl 0x00A736,0x0004B5 ; 1D 040.781 0.653
       04 00       
0B124E EB AB 00 9A 0677*       dl 0x00ABEB,0x00049A ; 1E 042.188 0.672
       04 00       
0B1254 85 B0 00 7F 0678*       dl 0x00B085,0x00047F ; 1F 043.594 0.690
       04 00       
0B125A 04 B5 00 63 0679*       dl 0x00B504,0x000463 ; 20 045.000 0.707
       04 00       
0B1260 68 B9 00 47 0680*       dl 0x00B968,0x000447 ; 21 046.406 0.724
       04 00       
0B1266 AF BD 00 29 0681*       dl 0x00BDAF,0x000429 ; 22 047.813 0.741
       04 00       
0B126C D8 C1 00 0B 0682*       dl 0x00C1D8,0x00040B ; 23 049.219 0.757
       04 00       
0B1272 E4 C5 00 EC 0683*       dl 0x00C5E4,0x0003EC ; 24 050.625 0.773
       03 00       
0B1278 D0 C9 00 CE 0684*       dl 0x00C9D0,0x0003CE ; 25 052.031 0.788
       03 00       
0B127E 9F CD 00 AE 0685*       dl 0x00CD9F,0x0003AE ; 26 053.438 0.803
       03 00       
0B1284 4D D1 00 8D 0686*       dl 0x00D14D,0x00038D ; 27 054.844 0.818
       03 00       
0B128A DB D4 00 6C 0687*       dl 0x00D4DB,0x00036C ; 28 056.250 0.831
       03 00       
0B1290 48 D8 00 4C 0688*       dl 0x00D848,0x00034C ; 29 057.656 0.845
       03 00       
0B1296 94 DB 00 29 0689*       dl 0x00DB94,0x000329 ; 2A 059.063 0.858
       03 00       
0B129C BE DE 00 07 0690*       dl 0x00DEBE,0x000307 ; 2B 060.469 0.870
       03 00       
0B12A2 C5 E1 00 E4 0691*       dl 0x00E1C5,0x0002E4 ; 2C 061.875 0.882
       02 00       
0B12A8 AA E4 00 C1 0692*       dl 0x00E4AA,0x0002C1 ; 2D 063.281 0.893
       02 00       
0B12AE 6C E7 00 9D 0693*       dl 0x00E76C,0x00029D ; 2E 064.688 0.904
       02 00       
0B12B4 09 EA 00 79 0694*       dl 0x00EA09,0x000279 ; 2F 066.094 0.914
       02 00       
0B12BA 83 EC 00 55 0695*       dl 0x00EC83,0x000255 ; 30 067.500 0.924
       02 00       
0B12C0 D8 EE 00 30 0696*       dl 0x00EED8,0x000230 ; 31 068.906 0.933
       02 00       
0B12C6 09 F1 00 0B 0697*       dl 0x00F109,0x00020B ; 32 070.313 0.942
       02 00       
0B12CC 14 F3 00 E5 0698*       dl 0x00F314,0x0001E5 ; 33 071.719 0.950
       01 00       
0B12D2 FA F4 00 BF 0699*       dl 0x00F4FA,0x0001BF ; 34 073.125 0.957
       01 00       
0B12D8 B9 F6 00 9A 0700*       dl 0x00F6B9,0x00019A ; 35 074.531 0.964
       01 00       
0B12DE 54 F8 00 73 0701*       dl 0x00F854,0x000173 ; 36 075.938 0.970
       01 00       
0B12E4 C7 F9 00 4D 0702*       dl 0x00F9C7,0x00014D ; 37 077.344 0.976
       01 00       
0B12EA 14 FB 00 26 0703*       dl 0x00FB14,0x000126 ; 38 078.750 0.981
       01 00       
0B12F0 3B FC 00 FF 0704*       dl 0x00FC3B,0x0000FF ; 39 080.156 0.985
       00 00       
0B12F6 3A FD 00 D8 0705*       dl 0x00FD3A,0x0000D8 ; 3A 081.563 0.989
       00 00       
0B12FC 13 FE 00 B1 0706*       dl 0x00FE13,0x0000B1 ; 3B 082.969 0.992
       00 00       
0B1302 C4 FE 00 89 0707*       dl 0x00FEC4,0x000089 ; 3C 084.375 0.995
       00 00       
0B1308 4E FF 00 62 0708*       dl 0x00FF4E,0x000062 ; 3D 085.781 0.997
       00 00       
0B130E B1 FF 00 3B 0709*       dl 0x00FFB1,0x00003B ; 3E 087.188 0.999
       00 00       
0B1314 EC FF 00 13 0710*       dl 0x00FFEC,0x000013 ; 3F 088.594 1.000
       00 00       
0B131A 00 00 01 EC 0711*       dl 0x010000,0xFFFFEC ; 40 090.000 1.000
       FF FF       
0B1320 EC FF 00 C4 0712*       dl 0x00FFEC,0xFFFFC4 ; 41 091.406 1.000
       FF FF       
0B1326 B1 FF 00 9D 0713*       dl 0x00FFB1,0xFFFF9D ; 42 092.813 0.999
       FF FF       
0B132C 4E FF 00 76 0714*       dl 0x00FF4E,0xFFFF76 ; 43 094.219 0.997
       FF FF       
0B1332 C4 FE 00 4E 0715*       dl 0x00FEC4,0xFFFF4E ; 44 095.625 0.995
       FF FF       
0B1338 13 FE 00 27 0716*       dl 0x00FE13,0xFFFF27 ; 45 097.031 0.992
       FF FF       
0B133E 3A FD 00 00 0717*       dl 0x00FD3A,0xFFFF00 ; 46 098.438 0.989
       FF FF       
0B1344 3B FC 00 D9 0718*       dl 0x00FC3B,0xFFFED9 ; 47 099.844 0.985
       FE FF       
0B134A 14 FB 00 B2 0719*       dl 0x00FB14,0xFFFEB2 ; 48 101.250 0.981
       FE FF       
0B1350 C7 F9 00 8C 0720*       dl 0x00F9C7,0xFFFE8C ; 49 102.656 0.976
       FE FF       
0B1356 53 F8 00 66 0721*       dl 0x00F853,0xFFFE66 ; 4A 104.063 0.970
       FE FF       
0B135C B9 F6 00 40 0722*       dl 0x00F6B9,0xFFFE40 ; 4B 105.469 0.964
       FE FF       
0B1362 FA F4 00 1A 0723*       dl 0x00F4FA,0xFFFE1A ; 4C 106.875 0.957
       FE FF       
0B1368 14 F3 00 F4 0724*       dl 0x00F314,0xFFFDF4 ; 4D 108.281 0.950
       FD FF       
0B136E 08 F1 00 CF 0725*       dl 0x00F108,0xFFFDCF ; 4E 109.688 0.942
       FD FF       
0B1374 D8 EE 00 AA 0726*       dl 0x00EED8,0xFFFDAA ; 4F 111.094 0.933
       FD FF       
0B137A 83 EC 00 86 0727*       dl 0x00EC83,0xFFFD86 ; 50 112.500 0.924
       FD FF       
0B1380 09 EA 00 61 0728*       dl 0x00EA09,0xFFFD61 ; 51 113.906 0.914
       FD FF       
0B1386 6B E7 00 3E 0729*       dl 0x00E76B,0xFFFD3E ; 52 115.313 0.904
       FD FF       
0B138C AA E4 00 1B 0730*       dl 0x00E4AA,0xFFFD1B ; 53 116.719 0.893
       FD FF       
0B1392 C5 E1 00 F8 0731*       dl 0x00E1C5,0xFFFCF8 ; 54 118.125 0.882
       FC FF       
0B1398 BE DE 00 D5 0732*       dl 0x00DEBE,0xFFFCD5 ; 55 119.531 0.870
       FC FF       
0B139E 93 DB 00 B4 0733*       dl 0x00DB93,0xFFFCB4 ; 56 120.938 0.858
       FC FF       
0B13A4 48 D8 00 93 0734*       dl 0x00D848,0xFFFC93 ; 57 122.344 0.845
       FC FF       
0B13AA DB D4 00 72 0735*       dl 0x00D4DB,0xFFFC72 ; 58 123.750 0.831
       FC FF       
0B13B0 4D D1 00 51 0736*       dl 0x00D14D,0xFFFC51 ; 59 125.156 0.818
       FC FF       
0B13B6 9E CD 00 32 0737*       dl 0x00CD9E,0xFFFC32 ; 5A 126.563 0.803
       FC FF       
0B13BC D0 C9 00 13 0738*       dl 0x00C9D0,0xFFFC13 ; 5B 127.969 0.788
       FC FF       
0B13C2 E4 C5 00 F4 0739*       dl 0x00C5E4,0xFFFBF4 ; 5C 129.375 0.773
       FB FF       
0B13C8 D8 C1 00 D5 0740*       dl 0x00C1D8,0xFFFBD5 ; 5D 130.781 0.757
       FB FF       
0B13CE AE BD 00 B9 0741*       dl 0x00BDAE,0xFFFBB9 ; 5E 132.188 0.741
       FB FF       
0B13D4 68 B9 00 9C 0742*       dl 0x00B968,0xFFFB9C ; 5F 133.594 0.724
       FB FF       
0B13DA 04 B5 00 80 0743*       dl 0x00B504,0xFFFB80 ; 60 135.000 0.707
       FB FF       
0B13E0 85 B0 00 64 0744*       dl 0x00B085,0xFFFB64 ; 61 136.406 0.690
       FB FF       
0B13E6 EA AB 00 4B 0745*       dl 0x00ABEA,0xFFFB4B ; 62 137.813 0.672
       FB FF       
0B13EC 36 A7 00 31 0746*       dl 0x00A736,0xFFFB31 ; 63 139.219 0.653
       FB FF       
0B13F2 67 A2 00 18 0747*       dl 0x00A267,0xFFFB18 ; 64 140.625 0.634
       FB FF       
0B13F8 80 9D 00 FF 0748*       dl 0x009D80,0xFFFAFF ; 65 142.031 0.615
       FA FF       
0B13FE 7F 98 00 E8 0749*       dl 0x00987F,0xFFFAE8 ; 66 143.438 0.596
       FA FF       
0B1404 67 93 00 D1 0750*       dl 0x009367,0xFFFAD1 ; 67 144.844 0.576
       FA FF       
0B140A 39 8E 00 BB 0751*       dl 0x008E39,0xFFFABB ; 68 146.250 0.556
       FA FF       
0B1410 F5 88 00 A5 0752*       dl 0x0088F5,0xFFFAA5 ; 69 147.656 0.535
       FA FF       
0B1416 9B 83 00 92 0753*       dl 0x00839B,0xFFFA92 ; 6A 149.063 0.514
       FA FF       
0B141C 2E 7E 00 7F 0754*       dl 0x007E2E,0xFFFA7F ; 6B 150.469 0.493
       FA FF       
0B1422 AD 78 00 6C 0755*       dl 0x0078AD,0xFFFA6C ; 6C 151.875 0.471
       FA FF       
0B1428 19 73 00 59 0756*       dl 0x007319,0xFFFA59 ; 6D 153.281 0.450
       FA FF       
0B142E 73 6D 00 49 0757*       dl 0x006D73,0xFFFA49 ; 6E 154.688 0.428
       FA FF       
0B1434 BD 67 00 39 0758*       dl 0x0067BD,0xFFFA39 ; 6F 156.094 0.405
       FA FF       
0B143A F7 61 00 2A 0759*       dl 0x0061F7,0xFFFA2A ; 70 157.500 0.383
       FA FF       
0B1440 22 5C 00 1B 0760*       dl 0x005C22,0xFFFA1B ; 71 158.906 0.360
       FA FF       
0B1446 3D 56 00 0F 0761*       dl 0x00563D,0xFFFA0F ; 72 160.313 0.337
       FA FF       
0B144C 4D 50 00 02 0762*       dl 0x00504D,0xFFFA02 ; 73 161.719 0.314
       FA FF       
0B1452 50 4A 00 F7 0763*       dl 0x004A50,0xFFF9F7 ; 74 163.125 0.290
       F9 FF       
0B1458 47 44 00 EB 0764*       dl 0x004447,0xFFF9EB ; 75 164.531 0.267
       F9 FF       
0B145E 33 3E 00 E3 0765*       dl 0x003E33,0xFFF9E3 ; 76 165.938 0.243
       F9 FF       
0B1464 16 38 00 DA 0766*       dl 0x003816,0xFFF9DA ; 77 167.344 0.219
       F9 FF       
0B146A F1 31 00 D3 0767*       dl 0x0031F1,0xFFF9D3 ; 78 168.750 0.195
       F9 FF       
0B1470 C4 2B 00 CB 0768*       dl 0x002BC4,0xFFF9CB ; 79 170.156 0.171
       F9 FF       
0B1476 8F 25 00 C6 0769*       dl 0x00258F,0xFFF9C6 ; 7A 171.563 0.147
       F9 FF       
0B147C 56 1F 00 C1 0770*       dl 0x001F56,0xFFF9C1 ; 7B 172.969 0.122
       F9 FF       
0B1482 17 19 00 BD 0771*       dl 0x001917,0xFFF9BD ; 7C 174.375 0.098
       F9 FF       
0B1488 D5 12 00 B9 0772*       dl 0x0012D5,0xFFF9B9 ; 7D 175.781 0.074
       F9 FF       
0B148E 8F 0C 00 B8 0773*       dl 0x000C8F,0xFFF9B8 ; 7E 177.188 0.049
       F9 FF       
0B1494 48 06 00 B7 0774*       dl 0x000648,0xFFF9B7 ; 7F 178.594 0.025
       F9 FF       
0B149A 00 00 00 B7 0775*       dl 0x000000,0xFFF9B7 ; 80 180.000 0.000
       F9 FF       
0B14A0 B8 F9 FF B7 0776*       dl 0xFFF9B8,0xFFF9B7 ; 81 181.406 -0.025
       F9 FF       
0B14A6 70 F3 FF BA 0777*       dl 0xFFF370,0xFFF9BA ; 82 182.813 -0.049
       F9 FF       
0B14AC 2B ED FF BD 0778*       dl 0xFFED2B,0xFFF9BD ; 83 184.219 -0.074
       F9 FF       
0B14B2 E9 E6 FF C1 0779*       dl 0xFFE6E9,0xFFF9C1 ; 84 185.625 -0.098
       F9 FF       
0B14B8 AA E0 FF C5 0780*       dl 0xFFE0AA,0xFFF9C5 ; 85 187.031 -0.122
       F9 FF       
0B14BE 70 DA FF CC 0781*       dl 0xFFDA70,0xFFF9CC ; 86 188.438 -0.147
       F9 FF       
0B14C4 3C D4 FF D3 0782*       dl 0xFFD43C,0xFFF9D3 ; 87 189.844 -0.171
       F9 FF       
0B14CA 0F CE FF DA 0783*       dl 0xFFCE0F,0xFFF9DA ; 88 191.250 -0.195
       F9 FF       
0B14D0 EA C7 FF E2 0784*       dl 0xFFC7EA,0xFFF9E2 ; 89 192.656 -0.219
       F9 FF       
0B14D6 CC C1 FF EC 0785*       dl 0xFFC1CC,0xFFF9EC ; 8A 194.063 -0.243
       F9 FF       
0B14DC B9 BB FF F7 0786*       dl 0xFFBBB9,0xFFF9F7 ; 8B 195.469 -0.267
       F9 FF       
0B14E2 B0 B5 FF 02 0787*       dl 0xFFB5B0,0xFFFA02 ; 8C 196.875 -0.290
       FA FF       
0B14E8 B3 AF FF 0E 0788*       dl 0xFFAFB3,0xFFFA0E ; 8D 198.281 -0.314
       FA FF       
0B14EE C2 A9 FF 1C 0789*       dl 0xFFA9C2,0xFFFA1C ; 8E 199.688 -0.337
       FA FF       
0B14F4 DE A3 FF 2A 0790*       dl 0xFFA3DE,0xFFFA2A ; 8F 201.094 -0.360
       FA FF       
0B14FA 09 9E FF 39 0791*       dl 0xFF9E09,0xFFFA39 ; 90 202.500 -0.383
       FA FF       
0B1500 43 98 FF 48 0792*       dl 0xFF9843,0xFFFA48 ; 91 203.906 -0.405
       FA FF       
0B1506 8C 92 FF 5A 0793*       dl 0xFF928C,0xFFFA5A ; 92 205.313 -0.428
       FA FF       
0B150C E7 8C FF 6C 0794*       dl 0xFF8CE7,0xFFFA6C ; 93 206.719 -0.450
       FA FF       
0B1512 53 87 FF 7F 0795*       dl 0xFF8753,0xFFFA7F ; 94 208.125 -0.471
       FA FF       
0B1518 D2 81 FF 91 0796*       dl 0xFF81D2,0xFFFA91 ; 95 209.531 -0.493
       FA FF       
0B151E 64 7C FF A6 0797*       dl 0xFF7C64,0xFFFAA6 ; 96 210.938 -0.514
       FA FF       
0B1524 0B 77 FF BB 0798*       dl 0xFF770B,0xFFFABB ; 97 212.344 -0.535
       FA FF       
0B152A C7 71 FF D1 0799*       dl 0xFF71C7,0xFFFAD1 ; 98 213.750 -0.556
       FA FF       
0B1530 99 6C FF E7 0800*       dl 0xFF6C99,0xFFFAE7 ; 99 215.156 -0.576
       FA FF       
0B1536 80 67 FF 00 0801*       dl 0xFF6780,0xFFFB00 ; 9A 216.563 -0.596
       FB FF       
0B153C 80 62 FF 18 0802*       dl 0xFF6280,0xFFFB18 ; 9B 217.969 -0.615
       FB FF       
0B1542 99 5D FF 31 0803*       dl 0xFF5D99,0xFFFB31 ; 9C 219.375 -0.634
       FB FF       
0B1548 CA 58 FF 4A 0804*       dl 0xFF58CA,0xFFFB4A ; 9D 220.781 -0.653
       FB FF       
0B154E 15 54 FF 65 0805*       dl 0xFF5415,0xFFFB65 ; 9E 222.188 -0.672
       FB FF       
0B1554 7B 4F FF 80 0806*       dl 0xFF4F7B,0xFFFB80 ; 9F 223.594 -0.690
       FB FF       
0B155A FC 4A FF 9C 0807*       dl 0xFF4AFC,0xFFFB9C ; A0 225.000 -0.707
       FB FF       
0B1560 98 46 FF B8 0808*       dl 0xFF4698,0xFFFBB8 ; A1 226.406 -0.724
       FB FF       
0B1566 51 42 FF D6 0809*       dl 0xFF4251,0xFFFBD6 ; A2 227.813 -0.741
       FB FF       
0B156C 28 3E FF F4 0810*       dl 0xFF3E28,0xFFFBF4 ; A3 229.219 -0.757
       FB FF       
0B1572 1C 3A FF 13 0811*       dl 0xFF3A1C,0xFFFC13 ; A4 230.625 -0.773
       FC FF       
0B1578 30 36 FF 31 0812*       dl 0xFF3630,0xFFFC31 ; A5 232.031 -0.788
       FC FF       
0B157E 61 32 FF 51 0813*       dl 0xFF3261,0xFFFC51 ; A6 233.438 -0.803
       FC FF       
0B1584 B3 2E FF 72 0814*       dl 0xFF2EB3,0xFFFC72 ; A7 234.844 -0.818
       FC FF       
0B158A 25 2B FF 93 0815*       dl 0xFF2B25,0xFFFC93 ; A8 236.250 -0.831
       FC FF       
0B1590 B8 27 FF B3 0816*       dl 0xFF27B8,0xFFFCB3 ; A9 237.656 -0.845
       FC FF       
0B1596 6C 24 FF D6 0817*       dl 0xFF246C,0xFFFCD6 ; AA 239.063 -0.858
       FC FF       
0B159C 42 21 FF F8 0818*       dl 0xFF2142,0xFFFCF8 ; AB 240.469 -0.870
       FC FF       
0B15A2 3B 1E FF 1B 0819*       dl 0xFF1E3B,0xFFFD1B ; AC 241.875 -0.882
       FD FF       
0B15A8 56 1B FF 3E 0820*       dl 0xFF1B56,0xFFFD3E ; AD 243.281 -0.893
       FD FF       
0B15AE 94 18 FF 62 0821*       dl 0xFF1894,0xFFFD62 ; AE 244.688 -0.904
       FD FF       
0B15B4 F7 15 FF 86 0822*       dl 0xFF15F7,0xFFFD86 ; AF 246.094 -0.914
       FD FF       
0B15BA 7D 13 FF AA 0823*       dl 0xFF137D,0xFFFDAA ; B0 247.500 -0.924
       FD FF       
0B15C0 28 11 FF CF 0824*       dl 0xFF1128,0xFFFDCF ; B1 248.906 -0.933
       FD FF       
0B15C6 F7 0E FF F4 0825*       dl 0xFF0EF7,0xFFFDF4 ; B2 250.313 -0.942
       FD FF       
0B15CC EC 0C FF 1A 0826*       dl 0xFF0CEC,0xFFFE1A ; B3 251.719 -0.950
       FE FF       
0B15D2 06 0B FF 40 0827*       dl 0xFF0B06,0xFFFE40 ; B4 253.125 -0.957
       FE FF       
0B15D8 47 09 FF 65 0828*       dl 0xFF0947,0xFFFE65 ; B5 254.531 -0.964
       FE FF       
0B15DE AC 07 FF 8C 0829*       dl 0xFF07AC,0xFFFE8C ; B6 255.938 -0.970
       FE FF       
0B15E4 39 06 FF B2 0830*       dl 0xFF0639,0xFFFEB2 ; B7 257.344 -0.976
       FE FF       
0B15EA EC 04 FF D9 0831*       dl 0xFF04EC,0xFFFED9 ; B8 258.750 -0.981
       FE FF       
0B15F0 C5 03 FF 00 0832*       dl 0xFF03C5,0xFFFF00 ; B9 260.156 -0.985
       FF FF       
0B15F6 C6 02 FF 27 0833*       dl 0xFF02C6,0xFFFF27 ; BA 261.563 -0.989
       FF FF       
0B15FC ED 01 FF 4E 0834*       dl 0xFF01ED,0xFFFF4E ; BB 262.969 -0.992
       FF FF       
0B1602 3C 01 FF 76 0835*       dl 0xFF013C,0xFFFF76 ; BC 264.375 -0.995
       FF FF       
0B1608 B2 00 FF 9D 0836*       dl 0xFF00B2,0xFFFF9D ; BD 265.781 -0.997
       FF FF       
0B160E 4F 00 FF C4 0837*       dl 0xFF004F,0xFFFFC4 ; BE 267.188 -0.999
       FF FF       
0B1614 14 00 FF EC 0838*       dl 0xFF0014,0xFFFFEC ; BF 268.594 -1.000
       FF FF       
0B161A 00 00 FF 13 0839*       dl 0xFF0000,0x000013 ; C0 270.000 -1.000
       00 00       
0B1620 14 00 FF 3B 0840*       dl 0xFF0014,0x00003B ; C1 271.406 -1.000
       00 00       
0B1626 4F 00 FF 62 0841*       dl 0xFF004F,0x000062 ; C2 272.813 -0.999
       00 00       
0B162C B2 00 FF 89 0842*       dl 0xFF00B2,0x000089 ; C3 274.219 -0.997
       00 00       
0B1632 3C 01 FF B1 0843*       dl 0xFF013C,0x0000B1 ; C4 275.625 -0.995
       00 00       
0B1638 ED 01 FF D8 0844*       dl 0xFF01ED,0x0000D8 ; C5 277.031 -0.992
       00 00       
0B163E C6 02 FF FF 0845*       dl 0xFF02C6,0x0000FF ; C6 278.438 -0.989
       00 00       
0B1644 C5 03 FF 26 0846*       dl 0xFF03C5,0x000126 ; C7 279.844 -0.985
       01 00       
0B164A EC 04 FF 4D 0847*       dl 0xFF04EC,0x00014D ; C8 281.250 -0.981
       01 00       
0B1650 39 06 FF 73 0848*       dl 0xFF0639,0x000173 ; C9 282.656 -0.976
       01 00       
0B1656 AD 07 FF 99 0849*       dl 0xFF07AD,0x000199 ; CA 284.063 -0.970
       01 00       
0B165C 47 09 FF BF 0850*       dl 0xFF0947,0x0001BF ; CB 285.469 -0.964
       01 00       
0B1662 06 0B FF E5 0851*       dl 0xFF0B06,0x0001E5 ; CC 286.875 -0.957
       01 00       
0B1668 EC 0C FF 0B 0852*       dl 0xFF0CEC,0x00020B ; CD 288.281 -0.950
       02 00       
0B166E F8 0E FF 30 0853*       dl 0xFF0EF8,0x000230 ; CE 289.688 -0.942
       02 00       
0B1674 28 11 FF 55 0854*       dl 0xFF1128,0x000255 ; CF 291.094 -0.933
       02 00       
0B167A 7D 13 FF 79 0855*       dl 0xFF137D,0x000279 ; D0 292.500 -0.924
       02 00       
0B1680 F7 15 FF 9E 0856*       dl 0xFF15F7,0x00029E ; D1 293.906 -0.914
       02 00       
0B1686 95 18 FF C1 0857*       dl 0xFF1895,0x0002C1 ; D2 295.313 -0.904
       02 00       
0B168C 56 1B FF E4 0858*       dl 0xFF1B56,0x0002E4 ; D3 296.719 -0.893
       02 00       
0B1692 3B 1E FF 07 0859*       dl 0xFF1E3B,0x000307 ; D4 298.125 -0.882
       03 00       
0B1698 42 21 FF 2A 0860*       dl 0xFF2142,0x00032A ; D5 299.531 -0.870
       03 00       
0B169E 6D 24 FF 4B 0861*       dl 0xFF246D,0x00034B ; D6 300.938 -0.858
       03 00       
0B16A4 B8 27 FF 6C 0862*       dl 0xFF27B8,0x00036C ; D7 302.344 -0.845
       03 00       
0B16AA 25 2B FF 8D 0863*       dl 0xFF2B25,0x00038D ; D8 303.750 -0.831
       03 00       
0B16B0 B3 2E FF AE 0864*       dl 0xFF2EB3,0x0003AE ; D9 305.156 -0.818
       03 00       
0B16B6 62 32 FF CD 0865*       dl 0xFF3262,0x0003CD ; DA 306.563 -0.803
       03 00       
0B16BC 30 36 FF EC 0866*       dl 0xFF3630,0x0003EC ; DB 307.969 -0.788
       03 00       
0B16C2 1C 3A FF 0B 0867*       dl 0xFF3A1C,0x00040B ; DC 309.375 -0.773
       04 00       
0B16C8 28 3E FF 2A 0868*       dl 0xFF3E28,0x00042A ; DD 310.781 -0.757
       04 00       
0B16CE 52 42 FF 46 0869*       dl 0xFF4252,0x000446 ; DE 312.188 -0.741
       04 00       
0B16D4 98 46 FF 63 0870*       dl 0xFF4698,0x000463 ; DF 313.594 -0.724
       04 00       
0B16DA FC 4A FF 7F 0871*       dl 0xFF4AFC,0x00047F ; E0 315.000 -0.707
       04 00       
0B16E0 7B 4F FF 9B 0872*       dl 0xFF4F7B,0x00049B ; E1 316.406 -0.690
       04 00       
0B16E6 16 54 FF B4 0873*       dl 0xFF5416,0x0004B4 ; E2 317.813 -0.672
       04 00       
0B16EC CA 58 FF CE 0874*       dl 0xFF58CA,0x0004CE ; E3 319.219 -0.653
       04 00       
0B16F2 99 5D FF E7 0875*       dl 0xFF5D99,0x0004E7 ; E4 320.625 -0.634
       04 00       
0B16F8 80 62 FF 00 0876*       dl 0xFF6280,0x000500 ; E5 322.031 -0.615
       05 00       
0B16FE 81 67 FF 17 0877*       dl 0xFF6781,0x000517 ; E6 323.438 -0.596
       05 00       
0B1704 99 6C FF 2E 0878*       dl 0xFF6C99,0x00052E ; E7 324.844 -0.576
       05 00       
0B170A C7 71 FF 44 0879*       dl 0xFF71C7,0x000544 ; E8 326.250 -0.556
       05 00       
0B1710 0B 77 FF 5A 0880*       dl 0xFF770B,0x00055A ; E9 327.656 -0.535
       05 00       
0B1716 65 7C FF 6D 0881*       dl 0xFF7C65,0x00056D ; EA 329.063 -0.514
       05 00       
0B171C D2 81 FF 80 0882*       dl 0xFF81D2,0x000580 ; EB 330.469 -0.493
       05 00       
0B1722 53 87 FF 93 0883*       dl 0xFF8753,0x000593 ; EC 331.875 -0.471
       05 00       
0B1728 E7 8C FF A6 0884*       dl 0xFF8CE7,0x0005A6 ; ED 333.281 -0.450
       05 00       
0B172E 8D 92 FF B6 0885*       dl 0xFF928D,0x0005B6 ; EE 334.688 -0.428
       05 00       
0B1734 43 98 FF C6 0886*       dl 0xFF9843,0x0005C6 ; EF 336.094 -0.405
       05 00       
0B173A 09 9E FF D5 0887*       dl 0xFF9E09,0x0005D5 ; F0 337.500 -0.383
       05 00       
0B1740 DE A3 FF E4 0888*       dl 0xFFA3DE,0x0005E4 ; F1 338.906 -0.360
       05 00       
0B1746 C3 A9 FF F0 0889*       dl 0xFFA9C3,0x0005F0 ; F2 340.313 -0.337
       05 00       
0B174C B3 AF FF FD 0890*       dl 0xFFAFB3,0x0005FD ; F3 341.719 -0.314
       05 00       
0B1752 B0 B5 FF 08 0891*       dl 0xFFB5B0,0x000608 ; F4 343.125 -0.290
       06 00       
0B1758 B9 BB FF 14 0892*       dl 0xFFBBB9,0x000614 ; F5 344.531 -0.267
       06 00       
0B175E CD C1 FF 1C 0893*       dl 0xFFC1CD,0x00061C ; F6 345.938 -0.243
       06 00       
0B1764 EA C7 FF 25 0894*       dl 0xFFC7EA,0x000625 ; F7 347.344 -0.219
       06 00       
0B176A 0F CE FF 2C 0895*       dl 0xFFCE0F,0x00062C ; F8 348.750 -0.195
       06 00       
0B1770 3C D4 FF 34 0896*       dl 0xFFD43C,0x000634 ; F9 350.156 -0.171
       06 00       
0B1776 71 DA FF 39 0897*       dl 0xFFDA71,0x000639 ; FA 351.563 -0.147
       06 00       
0B177C AA E0 FF 3E 0898*       dl 0xFFE0AA,0x00063E ; FB 352.969 -0.122
       06 00       
0B1782 E9 E6 FF 42 0899*       dl 0xFFE6E9,0x000642 ; FC 354.375 -0.098
       06 00       
0B1788 2B ED FF 46 0900*       dl 0xFFED2B,0x000646 ; FD 355.781 -0.074
       06 00       
0B178E 71 F3 FF 47 0901*       dl 0xFFF371,0x000647 ; FE 357.188 -0.049
       06 00       
0B1794 B8 F9 FF 48 0902*       dl 0xFFF9B8,0x000648 ; FF 358.594 -0.025
       06 00       
0B179A 00 00 00 48 0903*       dl 0x000000,0x000648 ; 00 360.000 0.000
       06 00       
0B17A0             0904*   
0B17A0             0905*   sin_lut_1212:
0B17A0 00 00 00    0906*       dl 0x000000 ; 00, 00.000, +0.000000
0B17A3 65 00 00    0907*       dl 0x000065 ; 01, 01.406, +0.024541
0B17A6 C9 00 00    0908*       dl 0x0000C9 ; 02, 02.812, +0.049068
0B17A9 2D 01 00    0909*       dl 0x00012D ; 03, 04.219, +0.073565
0B17AC 91 01 00    0910*       dl 0x000191 ; 04, 05.625, +0.098017
0B17AF F5 01 00    0911*       dl 0x0001F5 ; 05, 07.031, +0.122411
0B17B2 59 02 00    0912*       dl 0x000259 ; 06, 08.438, +0.146730
0B17B5 BC 02 00    0913*       dl 0x0002BC ; 07, 09.844, +0.170962
0B17B8 1F 03 00    0914*       dl 0x00031F ; 08, 11.250, +0.195090
0B17BB 81 03 00    0915*       dl 0x000381 ; 09, 12.656, +0.219101
0B17BE E3 03 00    0916*       dl 0x0003E3 ; 0A, 14.062, +0.242980
0B17C1 44 04 00    0917*       dl 0x000444 ; 0B, 15.469, +0.266713
0B17C4 A5 04 00    0918*       dl 0x0004A5 ; 0C, 16.875, +0.290285
0B17C7 05 05 00    0919*       dl 0x000505 ; 0D, 18.281, +0.313682
0B17CA 64 05 00    0920*       dl 0x000564 ; 0E, 19.688, +0.336890
0B17CD C2 05 00    0921*       dl 0x0005C2 ; 0F, 21.094, +0.359895
0B17D0 1F 06 00    0922*       dl 0x00061F ; 10, 22.500, +0.382683
0B17D3 7C 06 00    0923*       dl 0x00067C ; 11, 23.906, +0.405241
0B17D6 D7 06 00    0924*       dl 0x0006D7 ; 12, 25.312, +0.427555
0B17D9 32 07 00    0925*       dl 0x000732 ; 13, 26.719, +0.449611
0B17DC 8B 07 00    0926*       dl 0x00078B ; 14, 28.125, +0.471397
0B17DF E3 07 00    0927*       dl 0x0007E3 ; 15, 29.531, +0.492898
0B17E2 3A 08 00    0928*       dl 0x00083A ; 16, 30.938, +0.514103
0B17E5 8F 08 00    0929*       dl 0x00088F ; 17, 32.344, +0.534998
0B17E8 E4 08 00    0930*       dl 0x0008E4 ; 18, 33.750, +0.555570
0B17EB 37 09 00    0931*       dl 0x000937 ; 19, 35.156, +0.575808
0B17EE 88 09 00    0932*       dl 0x000988 ; 1A, 36.562, +0.595699
0B17F1 D8 09 00    0933*       dl 0x0009D8 ; 1B, 37.969, +0.615232
0B17F4 26 0A 00    0934*       dl 0x000A26 ; 1C, 39.375, +0.634393
0B17F7 73 0A 00    0935*       dl 0x000A73 ; 1D, 40.781, +0.653173
0B17FA BF 0A 00    0936*       dl 0x000ABF ; 1E, 42.188, +0.671559
0B17FD 08 0B 00    0937*       dl 0x000B08 ; 1F, 43.594, +0.689541
0B1800 50 0B 00    0938*       dl 0x000B50 ; 20, 45.000, +0.707107
0B1803 97 0B 00    0939*       dl 0x000B97 ; 21, 46.406, +0.724247
0B1806 DB 0B 00    0940*       dl 0x000BDB ; 22, 47.812, +0.740951
0B1809 1E 0C 00    0941*       dl 0x000C1E ; 23, 49.219, +0.757209
0B180C 5E 0C 00    0942*       dl 0x000C5E ; 24, 50.625, +0.773010
0B180F 9D 0C 00    0943*       dl 0x000C9D ; 25, 52.031, +0.788346
0B1812 DA 0C 00    0944*       dl 0x000CDA ; 26, 53.438, +0.803208
0B1815 15 0D 00    0945*       dl 0x000D15 ; 27, 54.844, +0.817585
0B1818 4E 0D 00    0946*       dl 0x000D4E ; 28, 56.250, +0.831470
0B181B 85 0D 00    0947*       dl 0x000D85 ; 29, 57.656, +0.844854
0B181E B9 0D 00    0948*       dl 0x000DB9 ; 2A, 59.062, +0.857729
0B1821 EC 0D 00    0949*       dl 0x000DEC ; 2B, 60.469, +0.870087
0B1824 1C 0E 00    0950*       dl 0x000E1C ; 2C, 61.875, +0.881921
0B1827 4B 0E 00    0951*       dl 0x000E4B ; 2D, 63.281, +0.893224
0B182A 77 0E 00    0952*       dl 0x000E77 ; 2E, 64.688, +0.903989
0B182D A1 0E 00    0953*       dl 0x000EA1 ; 2F, 66.094, +0.914210
0B1830 C8 0E 00    0954*       dl 0x000EC8 ; 30, 67.500, +0.923880
0B1833 EE 0E 00    0955*       dl 0x000EEE ; 31, 68.906, +0.932993
0B1836 11 0F 00    0956*       dl 0x000F11 ; 32, 70.312, +0.941544
0B1839 31 0F 00    0957*       dl 0x000F31 ; 33, 71.719, +0.949528
0B183C 50 0F 00    0958*       dl 0x000F50 ; 34, 73.125, +0.956940
0B183F 6C 0F 00    0959*       dl 0x000F6C ; 35, 74.531, +0.963776
0B1842 85 0F 00    0960*       dl 0x000F85 ; 36, 75.938, +0.970031
0B1845 9C 0F 00    0961*       dl 0x000F9C ; 37, 77.344, +0.975702
0B1848 B1 0F 00    0962*       dl 0x000FB1 ; 38, 78.750, +0.980785
0B184B C4 0F 00    0963*       dl 0x000FC4 ; 39, 80.156, +0.985278
0B184E D4 0F 00    0964*       dl 0x000FD4 ; 3A, 81.562, +0.989177
0B1851 E1 0F 00    0965*       dl 0x000FE1 ; 3B, 82.969, +0.992480
0B1854 EC 0F 00    0966*       dl 0x000FEC ; 3C, 84.375, +0.995185
0B1857 F5 0F 00    0967*       dl 0x000FF5 ; 3D, 85.781, +0.997290
0B185A FB 0F 00    0968*       dl 0x000FFB ; 3E, 87.188, +0.998795
0B185D FF 0F 00    0969*       dl 0x000FFF ; 3F, 88.594, +0.999699
0B1860 00 10 00    0970*       dl 0x001000 ; 40, 90.000, +1.000000
0B1863 FF 0F 00    0971*       dl 0x000FFF ; 41, 91.406, +0.999699
0B1866 FB 0F 00    0972*       dl 0x000FFB ; 42, 92.812, +0.998795
0B1869 F5 0F 00    0973*       dl 0x000FF5 ; 43, 94.219, +0.997290
0B186C EC 0F 00    0974*       dl 0x000FEC ; 44, 95.625, +0.995185
0B186F E1 0F 00    0975*       dl 0x000FE1 ; 45, 97.031, +0.992480
0B1872 D4 0F 00    0976*       dl 0x000FD4 ; 46, 98.438, +0.989177
0B1875 C4 0F 00    0977*       dl 0x000FC4 ; 47, 99.844, +0.985278
0B1878 B1 0F 00    0978*       dl 0x000FB1 ; 48, 101.250, +0.980785
0B187B 9C 0F 00    0979*       dl 0x000F9C ; 49, 102.656, +0.975702
0B187E 85 0F 00    0980*       dl 0x000F85 ; 4A, 104.062, +0.970031
0B1881 6C 0F 00    0981*       dl 0x000F6C ; 4B, 105.469, +0.963776
0B1884 50 0F 00    0982*       dl 0x000F50 ; 4C, 106.875, +0.956940
0B1887 31 0F 00    0983*       dl 0x000F31 ; 4D, 108.281, +0.949528
0B188A 11 0F 00    0984*       dl 0x000F11 ; 4E, 109.688, +0.941544
0B188D EE 0E 00    0985*       dl 0x000EEE ; 4F, 111.094, +0.932993
0B1890 C8 0E 00    0986*       dl 0x000EC8 ; 50, 112.500, +0.923880
0B1893 A1 0E 00    0987*       dl 0x000EA1 ; 51, 113.906, +0.914210
0B1896 77 0E 00    0988*       dl 0x000E77 ; 52, 115.312, +0.903989
0B1899 4B 0E 00    0989*       dl 0x000E4B ; 53, 116.719, +0.893224
0B189C 1C 0E 00    0990*       dl 0x000E1C ; 54, 118.125, +0.881921
0B189F EC 0D 00    0991*       dl 0x000DEC ; 55, 119.531, +0.870087
0B18A2 B9 0D 00    0992*       dl 0x000DB9 ; 56, 120.938, +0.857729
0B18A5 85 0D 00    0993*       dl 0x000D85 ; 57, 122.344, +0.844854
0B18A8 4E 0D 00    0994*       dl 0x000D4E ; 58, 123.750, +0.831470
0B18AB 15 0D 00    0995*       dl 0x000D15 ; 59, 125.156, +0.817585
0B18AE DA 0C 00    0996*       dl 0x000CDA ; 5A, 126.562, +0.803208
0B18B1 9D 0C 00    0997*       dl 0x000C9D ; 5B, 127.969, +0.788346
0B18B4 5E 0C 00    0998*       dl 0x000C5E ; 5C, 129.375, +0.773010
0B18B7 1E 0C 00    0999*       dl 0x000C1E ; 5D, 130.781, +0.757209
0B18BA DB 0B 00    1000*       dl 0x000BDB ; 5E, 132.188, +0.740951
0B18BD 97 0B 00    1001*       dl 0x000B97 ; 5F, 133.594, +0.724247
0B18C0 50 0B 00    1002*       dl 0x000B50 ; 60, 135.000, +0.707107
0B18C3 08 0B 00    1003*       dl 0x000B08 ; 61, 136.406, +0.689541
0B18C6 BF 0A 00    1004*       dl 0x000ABF ; 62, 137.812, +0.671559
0B18C9 73 0A 00    1005*       dl 0x000A73 ; 63, 139.219, +0.653173
0B18CC 26 0A 00    1006*       dl 0x000A26 ; 64, 140.625, +0.634393
0B18CF D8 09 00    1007*       dl 0x0009D8 ; 65, 142.031, +0.615232
0B18D2 88 09 00    1008*       dl 0x000988 ; 66, 143.438, +0.595699
0B18D5 37 09 00    1009*       dl 0x000937 ; 67, 144.844, +0.575808
0B18D8 E4 08 00    1010*       dl 0x0008E4 ; 68, 146.250, +0.555570
0B18DB 8F 08 00    1011*       dl 0x00088F ; 69, 147.656, +0.534998
0B18DE 3A 08 00    1012*       dl 0x00083A ; 6A, 149.062, +0.514103
0B18E1 E3 07 00    1013*       dl 0x0007E3 ; 6B, 150.469, +0.492898
0B18E4 8B 07 00    1014*       dl 0x00078B ; 6C, 151.875, +0.471397
0B18E7 32 07 00    1015*       dl 0x000732 ; 6D, 153.281, +0.449611
0B18EA D7 06 00    1016*       dl 0x0006D7 ; 6E, 154.688, +0.427555
0B18ED 7C 06 00    1017*       dl 0x00067C ; 6F, 156.094, +0.405241
0B18F0 1F 06 00    1018*       dl 0x00061F ; 70, 157.500, +0.382683
0B18F3 C2 05 00    1019*       dl 0x0005C2 ; 71, 158.906, +0.359895
0B18F6 64 05 00    1020*       dl 0x000564 ; 72, 160.312, +0.336890
0B18F9 05 05 00    1021*       dl 0x000505 ; 73, 161.719, +0.313682
0B18FC A5 04 00    1022*       dl 0x0004A5 ; 74, 163.125, +0.290285
0B18FF 44 04 00    1023*       dl 0x000444 ; 75, 164.531, +0.266713
0B1902 E3 03 00    1024*       dl 0x0003E3 ; 76, 165.938, +0.242980
0B1905 81 03 00    1025*       dl 0x000381 ; 77, 167.344, +0.219101
0B1908 1F 03 00    1026*       dl 0x00031F ; 78, 168.750, +0.195090
0B190B BC 02 00    1027*       dl 0x0002BC ; 79, 170.156, +0.170962
0B190E 59 02 00    1028*       dl 0x000259 ; 7A, 171.562, +0.146730
0B1911 F5 01 00    1029*       dl 0x0001F5 ; 7B, 172.969, +0.122411
0B1914 91 01 00    1030*       dl 0x000191 ; 7C, 174.375, +0.098017
0B1917 2D 01 00    1031*       dl 0x00012D ; 7D, 175.781, +0.073565
0B191A C9 00 00    1032*       dl 0x0000C9 ; 7E, 177.188, +0.049068
0B191D 65 00 00    1033*       dl 0x000065 ; 7F, 178.594, +0.024541
0B1920 00 00 00    1034*       dl 0x000000 ; 80, 180.000, +0.000000
0B1923 9B FF FF    1035*       dl 0xFFFF9B ; 81, 181.406, -0.024541
0B1926 37 FF FF    1036*       dl 0xFFFF37 ; 82, 182.812, -0.049068
0B1929 D3 FE FF    1037*       dl 0xFFFED3 ; 83, 184.219, -0.073565
0B192C 6F FE FF    1038*       dl 0xFFFE6F ; 84, 185.625, -0.098017
0B192F 0B FE FF    1039*       dl 0xFFFE0B ; 85, 187.031, -0.122411
0B1932 A7 FD FF    1040*       dl 0xFFFDA7 ; 86, 188.438, -0.146730
0B1935 44 FD FF    1041*       dl 0xFFFD44 ; 87, 189.844, -0.170962
0B1938 E1 FC FF    1042*       dl 0xFFFCE1 ; 88, 191.250, -0.195090
0B193B 7F FC FF    1043*       dl 0xFFFC7F ; 89, 192.656, -0.219101
0B193E 1D FC FF    1044*       dl 0xFFFC1D ; 8A, 194.062, -0.242980
0B1941 BC FB FF    1045*       dl 0xFFFBBC ; 8B, 195.469, -0.266713
0B1944 5B FB FF    1046*       dl 0xFFFB5B ; 8C, 196.875, -0.290285
0B1947 FB FA FF    1047*       dl 0xFFFAFB ; 8D, 198.281, -0.313682
0B194A 9C FA FF    1048*       dl 0xFFFA9C ; 8E, 199.688, -0.336890
0B194D 3E FA FF    1049*       dl 0xFFFA3E ; 8F, 201.094, -0.359895
0B1950 E1 F9 FF    1050*       dl 0xFFF9E1 ; 90, 202.500, -0.382683
0B1953 84 F9 FF    1051*       dl 0xFFF984 ; 91, 203.906, -0.405241
0B1956 29 F9 FF    1052*       dl 0xFFF929 ; 92, 205.312, -0.427555
0B1959 CE F8 FF    1053*       dl 0xFFF8CE ; 93, 206.719, -0.449611
0B195C 75 F8 FF    1054*       dl 0xFFF875 ; 94, 208.125, -0.471397
0B195F 1D F8 FF    1055*       dl 0xFFF81D ; 95, 209.531, -0.492898
0B1962 C6 F7 FF    1056*       dl 0xFFF7C6 ; 96, 210.938, -0.514103
0B1965 71 F7 FF    1057*       dl 0xFFF771 ; 97, 212.344, -0.534998
0B1968 1C F7 FF    1058*       dl 0xFFF71C ; 98, 213.750, -0.555570
0B196B C9 F6 FF    1059*       dl 0xFFF6C9 ; 99, 215.156, -0.575808
0B196E 78 F6 FF    1060*       dl 0xFFF678 ; 9A, 216.562, -0.595699
0B1971 28 F6 FF    1061*       dl 0xFFF628 ; 9B, 217.969, -0.615232
0B1974 DA F5 FF    1062*       dl 0xFFF5DA ; 9C, 219.375, -0.634393
0B1977 8D F5 FF    1063*       dl 0xFFF58D ; 9D, 220.781, -0.653173
0B197A 41 F5 FF    1064*       dl 0xFFF541 ; 9E, 222.188, -0.671559
0B197D F8 F4 FF    1065*       dl 0xFFF4F8 ; 9F, 223.594, -0.689541
0B1980 B0 F4 FF    1066*       dl 0xFFF4B0 ; A0, 225.000, -0.707107
0B1983 69 F4 FF    1067*       dl 0xFFF469 ; A1, 226.406, -0.724247
0B1986 25 F4 FF    1068*       dl 0xFFF425 ; A2, 227.812, -0.740951
0B1989 E2 F3 FF    1069*       dl 0xFFF3E2 ; A3, 229.219, -0.757209
0B198C A2 F3 FF    1070*       dl 0xFFF3A2 ; A4, 230.625, -0.773010
0B198F 63 F3 FF    1071*       dl 0xFFF363 ; A5, 232.031, -0.788346
0B1992 26 F3 FF    1072*       dl 0xFFF326 ; A6, 233.438, -0.803208
0B1995 EB F2 FF    1073*       dl 0xFFF2EB ; A7, 234.844, -0.817585
0B1998 B2 F2 FF    1074*       dl 0xFFF2B2 ; A8, 236.250, -0.831470
0B199B 7B F2 FF    1075*       dl 0xFFF27B ; A9, 237.656, -0.844854
0B199E 47 F2 FF    1076*       dl 0xFFF247 ; AA, 239.062, -0.857729
0B19A1 14 F2 FF    1077*       dl 0xFFF214 ; AB, 240.469, -0.870087
0B19A4 E4 F1 FF    1078*       dl 0xFFF1E4 ; AC, 241.875, -0.881921
0B19A7 B5 F1 FF    1079*       dl 0xFFF1B5 ; AD, 243.281, -0.893224
0B19AA 89 F1 FF    1080*       dl 0xFFF189 ; AE, 244.688, -0.903989
0B19AD 5F F1 FF    1081*       dl 0xFFF15F ; AF, 246.094, -0.914210
0B19B0 38 F1 FF    1082*       dl 0xFFF138 ; B0, 247.500, -0.923880
0B19B3 12 F1 FF    1083*       dl 0xFFF112 ; B1, 248.906, -0.932993
0B19B6 EF F0 FF    1084*       dl 0xFFF0EF ; B2, 250.312, -0.941544
0B19B9 CF F0 FF    1085*       dl 0xFFF0CF ; B3, 251.719, -0.949528
0B19BC B0 F0 FF    1086*       dl 0xFFF0B0 ; B4, 253.125, -0.956940
0B19BF 94 F0 FF    1087*       dl 0xFFF094 ; B5, 254.531, -0.963776
0B19C2 7B F0 FF    1088*       dl 0xFFF07B ; B6, 255.938, -0.970031
0B19C5 64 F0 FF    1089*       dl 0xFFF064 ; B7, 257.344, -0.975702
0B19C8 4F F0 FF    1090*       dl 0xFFF04F ; B8, 258.750, -0.980785
0B19CB 3C F0 FF    1091*       dl 0xFFF03C ; B9, 260.156, -0.985278
0B19CE 2C F0 FF    1092*       dl 0xFFF02C ; BA, 261.562, -0.989177
0B19D1 1F F0 FF    1093*       dl 0xFFF01F ; BB, 262.969, -0.992480
0B19D4 14 F0 FF    1094*       dl 0xFFF014 ; BC, 264.375, -0.995185
0B19D7 0B F0 FF    1095*       dl 0xFFF00B ; BD, 265.781, -0.997290
0B19DA 05 F0 FF    1096*       dl 0xFFF005 ; BE, 267.188, -0.998795
0B19DD 01 F0 FF    1097*       dl 0xFFF001 ; BF, 268.594, -0.999699
0B19E0 00 F0 FF    1098*       dl 0xFFF000 ; C0, 270.000, -1.000000
0B19E3 01 F0 FF    1099*       dl 0xFFF001 ; C1, 271.406, -0.999699
0B19E6 05 F0 FF    1100*       dl 0xFFF005 ; C2, 272.812, -0.998795
0B19E9 0B F0 FF    1101*       dl 0xFFF00B ; C3, 274.219, -0.997290
0B19EC 14 F0 FF    1102*       dl 0xFFF014 ; C4, 275.625, -0.995185
0B19EF 1F F0 FF    1103*       dl 0xFFF01F ; C5, 277.031, -0.992480
0B19F2 2C F0 FF    1104*       dl 0xFFF02C ; C6, 278.438, -0.989177
0B19F5 3C F0 FF    1105*       dl 0xFFF03C ; C7, 279.844, -0.985278
0B19F8 4F F0 FF    1106*       dl 0xFFF04F ; C8, 281.250, -0.980785
0B19FB 64 F0 FF    1107*       dl 0xFFF064 ; C9, 282.656, -0.975702
0B19FE 7B F0 FF    1108*       dl 0xFFF07B ; CA, 284.062, -0.970031
0B1A01 94 F0 FF    1109*       dl 0xFFF094 ; CB, 285.469, -0.963776
0B1A04 B0 F0 FF    1110*       dl 0xFFF0B0 ; CC, 286.875, -0.956940
0B1A07 CF F0 FF    1111*       dl 0xFFF0CF ; CD, 288.281, -0.949528
0B1A0A EF F0 FF    1112*       dl 0xFFF0EF ; CE, 289.688, -0.941544
0B1A0D 12 F1 FF    1113*       dl 0xFFF112 ; CF, 291.094, -0.932993
0B1A10 38 F1 FF    1114*       dl 0xFFF138 ; D0, 292.500, -0.923880
0B1A13 5F F1 FF    1115*       dl 0xFFF15F ; D1, 293.906, -0.914210
0B1A16 89 F1 FF    1116*       dl 0xFFF189 ; D2, 295.312, -0.903989
0B1A19 B5 F1 FF    1117*       dl 0xFFF1B5 ; D3, 296.719, -0.893224
0B1A1C E4 F1 FF    1118*       dl 0xFFF1E4 ; D4, 298.125, -0.881921
0B1A1F 14 F2 FF    1119*       dl 0xFFF214 ; D5, 299.531, -0.870087
0B1A22 47 F2 FF    1120*       dl 0xFFF247 ; D6, 300.938, -0.857729
0B1A25 7B F2 FF    1121*       dl 0xFFF27B ; D7, 302.344, -0.844854
0B1A28 B2 F2 FF    1122*       dl 0xFFF2B2 ; D8, 303.750, -0.831470
0B1A2B EB F2 FF    1123*       dl 0xFFF2EB ; D9, 305.156, -0.817585
0B1A2E 26 F3 FF    1124*       dl 0xFFF326 ; DA, 306.562, -0.803208
0B1A31 63 F3 FF    1125*       dl 0xFFF363 ; DB, 307.969, -0.788346
0B1A34 A2 F3 FF    1126*       dl 0xFFF3A2 ; DC, 309.375, -0.773010
0B1A37 E2 F3 FF    1127*       dl 0xFFF3E2 ; DD, 310.781, -0.757209
0B1A3A 25 F4 FF    1128*       dl 0xFFF425 ; DE, 312.188, -0.740951
0B1A3D 69 F4 FF    1129*       dl 0xFFF469 ; DF, 313.594, -0.724247
0B1A40 B0 F4 FF    1130*       dl 0xFFF4B0 ; E0, 315.000, -0.707107
0B1A43 F8 F4 FF    1131*       dl 0xFFF4F8 ; E1, 316.406, -0.689541
0B1A46 41 F5 FF    1132*       dl 0xFFF541 ; E2, 317.812, -0.671559
0B1A49 8D F5 FF    1133*       dl 0xFFF58D ; E3, 319.219, -0.653173
0B1A4C DA F5 FF    1134*       dl 0xFFF5DA ; E4, 320.625, -0.634393
0B1A4F 28 F6 FF    1135*       dl 0xFFF628 ; E5, 322.031, -0.615232
0B1A52 78 F6 FF    1136*       dl 0xFFF678 ; E6, 323.438, -0.595699
0B1A55 C9 F6 FF    1137*       dl 0xFFF6C9 ; E7, 324.844, -0.575808
0B1A58 1C F7 FF    1138*       dl 0xFFF71C ; E8, 326.250, -0.555570
0B1A5B 71 F7 FF    1139*       dl 0xFFF771 ; E9, 327.656, -0.534998
0B1A5E C6 F7 FF    1140*       dl 0xFFF7C6 ; EA, 329.062, -0.514103
0B1A61 1D F8 FF    1141*       dl 0xFFF81D ; EB, 330.469, -0.492898
0B1A64 75 F8 FF    1142*       dl 0xFFF875 ; EC, 331.875, -0.471397
0B1A67 CE F8 FF    1143*       dl 0xFFF8CE ; ED, 333.281, -0.449611
0B1A6A 29 F9 FF    1144*       dl 0xFFF929 ; EE, 334.688, -0.427555
0B1A6D 84 F9 FF    1145*       dl 0xFFF984 ; EF, 336.094, -0.405241
0B1A70 E1 F9 FF    1146*       dl 0xFFF9E1 ; F0, 337.500, -0.382683
0B1A73 3E FA FF    1147*       dl 0xFFFA3E ; F1, 338.906, -0.359895
0B1A76 9C FA FF    1148*       dl 0xFFFA9C ; F2, 340.312, -0.336890
0B1A79 FB FA FF    1149*       dl 0xFFFAFB ; F3, 341.719, -0.313682
0B1A7C 5B FB FF    1150*       dl 0xFFFB5B ; F4, 343.125, -0.290285
0B1A7F BC FB FF    1151*       dl 0xFFFBBC ; F5, 344.531, -0.266713
0B1A82 1D FC FF    1152*       dl 0xFFFC1D ; F6, 345.938, -0.242980
0B1A85 7F FC FF    1153*       dl 0xFFFC7F ; F7, 347.344, -0.219101
0B1A88 E1 FC FF    1154*       dl 0xFFFCE1 ; F8, 348.750, -0.195090
0B1A8B 44 FD FF    1155*       dl 0xFFFD44 ; F9, 350.156, -0.170962
0B1A8E A7 FD FF    1156*       dl 0xFFFDA7 ; FA, 351.562, -0.146730
0B1A91 0B FE FF    1157*       dl 0xFFFE0B ; FB, 352.969, -0.122411
0B1A94 6F FE FF    1158*       dl 0xFFFE6F ; FC, 354.375, -0.098017
0B1A97 D3 FE FF    1159*       dl 0xFFFED3 ; FD, 355.781, -0.073565
0B1A9A 37 FF FF    1160*       dl 0xFFFF37 ; FE, 357.188, -0.049068
0B1A9D 9B FF FF    1161*       dl 0xFFFF9B ; FF, 358.594, -0.024541
0B1AA0             1162*   
0B1AA0             1163*   atan_lut_168:
0B1AA0 00 00 00    1164*   	dl 0x000000 ; 000000, 0.000
0B1AA3 28 00 00    1165*   	dl 0x000028 ; 000001, 0.224
0B1AA6 51 00 00    1166*   	dl 0x000051 ; 000002, 0.448
0B1AA9 7A 00 00    1167*   	dl 0x00007A ; 000003, 0.671
0B1AAC A2 00 00    1168*   	dl 0x0000A2 ; 000004, 0.895
0B1AAF CB 00 00    1169*   	dl 0x0000CB ; 000005, 1.119
0B1AB2 F4 00 00    1170*   	dl 0x0000F4 ; 000006, 1.343
0B1AB5 1D 01 00    1171*   	dl 0x00011D ; 000007, 1.566
0B1AB8 45 01 00    1172*   	dl 0x000145 ; 000008, 1.790
0B1ABB 6E 01 00    1173*   	dl 0x00016E ; 000009, 2.013
0B1ABE 97 01 00    1174*   	dl 0x000197 ; 00000A, 2.237
0B1AC1 BF 01 00    1175*   	dl 0x0001BF ; 00000B, 2.460
0B1AC4 E8 01 00    1176*   	dl 0x0001E8 ; 00000C, 2.684
0B1AC7 11 02 00    1177*   	dl 0x000211 ; 00000D, 2.907
0B1ACA 39 02 00    1178*   	dl 0x000239 ; 00000E, 3.130
0B1ACD 62 02 00    1179*   	dl 0x000262 ; 00000F, 3.353
0B1AD0 8B 02 00    1180*   	dl 0x00028B ; 000010, 3.576
0B1AD3 B3 02 00    1181*   	dl 0x0002B3 ; 000011, 3.799
0B1AD6 DC 02 00    1182*   	dl 0x0002DC ; 000012, 4.022
0B1AD9 04 03 00    1183*   	dl 0x000304 ; 000013, 4.245
0B1ADC 2D 03 00    1184*   	dl 0x00032D ; 000014, 4.467
0B1ADF 55 03 00    1185*   	dl 0x000355 ; 000015, 4.690
0B1AE2 7E 03 00    1186*   	dl 0x00037E ; 000016, 4.912
0B1AE5 A6 03 00    1187*   	dl 0x0003A6 ; 000017, 5.134
0B1AE8 CE 03 00    1188*   	dl 0x0003CE ; 000018, 5.356
0B1AEB F7 03 00    1189*   	dl 0x0003F7 ; 000019, 5.578
0B1AEE 1F 04 00    1190*   	dl 0x00041F ; 00001A, 5.799
0B1AF1 48 04 00    1191*   	dl 0x000448 ; 00001B, 6.021
0B1AF4 70 04 00    1192*   	dl 0x000470 ; 00001C, 6.242
0B1AF7 98 04 00    1193*   	dl 0x000498 ; 00001D, 6.463
0B1AFA C0 04 00    1194*   	dl 0x0004C0 ; 00001E, 6.684
0B1AFD E8 04 00    1195*   	dl 0x0004E8 ; 00001F, 6.905
0B1B00 11 05 00    1196*   	dl 0x000511 ; 000020, 7.125
0B1B03 39 05 00    1197*   	dl 0x000539 ; 000021, 7.345
0B1B06 61 05 00    1198*   	dl 0x000561 ; 000022, 7.565
0B1B09 89 05 00    1199*   	dl 0x000589 ; 000023, 7.785
0B1B0C B1 05 00    1200*   	dl 0x0005B1 ; 000024, 8.005
0B1B0F D9 05 00    1201*   	dl 0x0005D9 ; 000025, 8.224
0B1B12 01 06 00    1202*   	dl 0x000601 ; 000026, 8.443
0B1B15 28 06 00    1203*   	dl 0x000628 ; 000027, 8.662
0B1B18 50 06 00    1204*   	dl 0x000650 ; 000028, 8.881
0B1B1B 78 06 00    1205*   	dl 0x000678 ; 000029, 9.099
0B1B1E A0 06 00    1206*   	dl 0x0006A0 ; 00002A, 9.317
0B1B21 C7 06 00    1207*   	dl 0x0006C7 ; 00002B, 9.535
0B1B24 EF 06 00    1208*   	dl 0x0006EF ; 00002C, 9.752
0B1B27 16 07 00    1209*   	dl 0x000716 ; 00002D, 9.970
0B1B2A 3E 07 00    1210*   	dl 0x00073E ; 00002E, 10.187
0B1B2D 65 07 00    1211*   	dl 0x000765 ; 00002F, 10.403
0B1B30 8D 07 00    1212*   	dl 0x00078D ; 000030, 10.620
0B1B33 B4 07 00    1213*   	dl 0x0007B4 ; 000031, 10.836
0B1B36 DB 07 00    1214*   	dl 0x0007DB ; 000032, 11.051
0B1B39 03 08 00    1215*   	dl 0x000803 ; 000033, 11.267
0B1B3C 2A 08 00    1216*   	dl 0x00082A ; 000034, 11.482
0B1B3F 51 08 00    1217*   	dl 0x000851 ; 000035, 11.697
0B1B42 78 08 00    1218*   	dl 0x000878 ; 000036, 11.911
0B1B45 9F 08 00    1219*   	dl 0x00089F ; 000037, 12.125
0B1B48 C6 08 00    1220*   	dl 0x0008C6 ; 000038, 12.339
0B1B4B ED 08 00    1221*   	dl 0x0008ED ; 000039, 12.553
0B1B4E 13 09 00    1222*   	dl 0x000913 ; 00003A, 12.766
0B1B51 3A 09 00    1223*   	dl 0x00093A ; 00003B, 12.978
0B1B54 61 09 00    1224*   	dl 0x000961 ; 00003C, 13.191
0B1B57 87 09 00    1225*   	dl 0x000987 ; 00003D, 13.403
0B1B5A AE 09 00    1226*   	dl 0x0009AE ; 00003E, 13.614
0B1B5D D4 09 00    1227*   	dl 0x0009D4 ; 00003F, 13.825
0B1B60 FB 09 00    1228*   	dl 0x0009FB ; 000040, 14.036
0B1B63 21 0A 00    1229*   	dl 0x000A21 ; 000041, 14.247
0B1B66 47 0A 00    1230*   	dl 0x000A47 ; 000042, 14.457
0B1B69 6D 0A 00    1231*   	dl 0x000A6D ; 000043, 14.666
0B1B6C 94 0A 00    1232*   	dl 0x000A94 ; 000044, 14.876
0B1B6F BA 0A 00    1233*   	dl 0x000ABA ; 000045, 15.085
0B1B72 E0 0A 00    1234*   	dl 0x000AE0 ; 000046, 15.293
0B1B75 05 0B 00    1235*   	dl 0x000B05 ; 000047, 15.501
0B1B78 2B 0B 00    1236*   	dl 0x000B2B ; 000048, 15.709
0B1B7B 51 0B 00    1237*   	dl 0x000B51 ; 000049, 15.916
0B1B7E 77 0B 00    1238*   	dl 0x000B77 ; 00004A, 16.123
0B1B81 9C 0B 00    1239*   	dl 0x000B9C ; 00004B, 16.329
0B1B84 C2 0B 00    1240*   	dl 0x000BC2 ; 00004C, 16.535
0B1B87 E7 0B 00    1241*   	dl 0x000BE7 ; 00004D, 16.740
0B1B8A 0C 0C 00    1242*   	dl 0x000C0C ; 00004E, 16.945
0B1B8D 32 0C 00    1243*   	dl 0x000C32 ; 00004F, 17.150
0B1B90 57 0C 00    1244*   	dl 0x000C57 ; 000050, 17.354
0B1B93 7C 0C 00    1245*   	dl 0x000C7C ; 000051, 17.558
0B1B96 A1 0C 00    1246*   	dl 0x000CA1 ; 000052, 17.761
0B1B99 C6 0C 00    1247*   	dl 0x000CC6 ; 000053, 17.964
0B1B9C EB 0C 00    1248*   	dl 0x000CEB ; 000054, 18.166
0B1B9F 0F 0D 00    1249*   	dl 0x000D0F ; 000055, 18.368
0B1BA2 34 0D 00    1250*   	dl 0x000D34 ; 000056, 18.569
0B1BA5 58 0D 00    1251*   	dl 0x000D58 ; 000057, 18.770
0B1BA8 7D 0D 00    1252*   	dl 0x000D7D ; 000058, 18.970
0B1BAB A1 0D 00    1253*   	dl 0x000DA1 ; 000059, 19.170
0B1BAE C6 0D 00    1254*   	dl 0x000DC6 ; 00005A, 19.370
0B1BB1 EA 0D 00    1255*   	dl 0x000DEA ; 00005B, 19.569
0B1BB4 0E 0E 00    1256*   	dl 0x000E0E ; 00005C, 19.767
0B1BB7 32 0E 00    1257*   	dl 0x000E32 ; 00005D, 19.965
0B1BBA 56 0E 00    1258*   	dl 0x000E56 ; 00005E, 20.163
0B1BBD 7A 0E 00    1259*   	dl 0x000E7A ; 00005F, 20.360
0B1BC0 9E 0E 00    1260*   	dl 0x000E9E ; 000060, 20.556
0B1BC3 C1 0E 00    1261*   	dl 0x000EC1 ; 000061, 20.752
0B1BC6 E5 0E 00    1262*   	dl 0x000EE5 ; 000062, 20.947
0B1BC9 08 0F 00    1263*   	dl 0x000F08 ; 000063, 21.142
0B1BCC 2C 0F 00    1264*   	dl 0x000F2C ; 000064, 21.337
0B1BCF 4F 0F 00    1265*   	dl 0x000F4F ; 000065, 21.531
0B1BD2 72 0F 00    1266*   	dl 0x000F72 ; 000066, 21.724
0B1BD5 95 0F 00    1267*   	dl 0x000F95 ; 000067, 21.917
0B1BD8 B8 0F 00    1268*   	dl 0x000FB8 ; 000068, 22.109
0B1BDB DB 0F 00    1269*   	dl 0x000FDB ; 000069, 22.301
0B1BDE FE 0F 00    1270*   	dl 0x000FFE ; 00006A, 22.493
0B1BE1 21 10 00    1271*   	dl 0x001021 ; 00006B, 22.683
0B1BE4 44 10 00    1272*   	dl 0x001044 ; 00006C, 22.874
0B1BE7 66 10 00    1273*   	dl 0x001066 ; 00006D, 23.063
0B1BEA 89 10 00    1274*   	dl 0x001089 ; 00006E, 23.253
0B1BED AB 10 00    1275*   	dl 0x0010AB ; 00006F, 23.441
0B1BF0 CD 10 00    1276*   	dl 0x0010CD ; 000070, 23.629
0B1BF3 EF 10 00    1277*   	dl 0x0010EF ; 000071, 23.817
0B1BF6 11 11 00    1278*   	dl 0x001111 ; 000072, 24.004
0B1BF9 33 11 00    1279*   	dl 0x001133 ; 000073, 24.191
0B1BFC 55 11 00    1280*   	dl 0x001155 ; 000074, 24.376
0B1BFF 77 11 00    1281*   	dl 0x001177 ; 000075, 24.562
0B1C02 99 11 00    1282*   	dl 0x001199 ; 000076, 24.747
0B1C05 BA 11 00    1283*   	dl 0x0011BA ; 000077, 24.931
0B1C08 DC 11 00    1284*   	dl 0x0011DC ; 000078, 25.115
0B1C0B FD 11 00    1285*   	dl 0x0011FD ; 000079, 25.298
0B1C0E 1E 12 00    1286*   	dl 0x00121E ; 00007A, 25.481
0B1C11 3F 12 00    1287*   	dl 0x00123F ; 00007B, 25.663
0B1C14 60 12 00    1288*   	dl 0x001260 ; 00007C, 25.844
0B1C17 81 12 00    1289*   	dl 0x001281 ; 00007D, 26.025
0B1C1A A2 12 00    1290*   	dl 0x0012A2 ; 00007E, 26.206
0B1C1D C3 12 00    1291*   	dl 0x0012C3 ; 00007F, 26.386
0B1C20 E4 12 00    1292*   	dl 0x0012E4 ; 000080, 26.565
0B1C23 04 13 00    1293*   	dl 0x001304 ; 000081, 26.744
0B1C26 25 13 00    1294*   	dl 0x001325 ; 000082, 26.922
0B1C29 45 13 00    1295*   	dl 0x001345 ; 000083, 27.100
0B1C2C 65 13 00    1296*   	dl 0x001365 ; 000084, 27.277
0B1C2F 85 13 00    1297*   	dl 0x001385 ; 000085, 27.453
0B1C32 A5 13 00    1298*   	dl 0x0013A5 ; 000086, 27.629
0B1C35 C5 13 00    1299*   	dl 0x0013C5 ; 000087, 27.805
0B1C38 E5 13 00    1300*   	dl 0x0013E5 ; 000088, 27.979
0B1C3B 05 14 00    1301*   	dl 0x001405 ; 000089, 28.154
0B1C3E 24 14 00    1302*   	dl 0x001424 ; 00008A, 28.327
0B1C41 44 14 00    1303*   	dl 0x001444 ; 00008B, 28.501
0B1C44 63 14 00    1304*   	dl 0x001463 ; 00008C, 28.673
0B1C47 83 14 00    1305*   	dl 0x001483 ; 00008D, 28.845
0B1C4A A2 14 00    1306*   	dl 0x0014A2 ; 00008E, 29.017
0B1C4D C1 14 00    1307*   	dl 0x0014C1 ; 00008F, 29.187
0B1C50 E0 14 00    1308*   	dl 0x0014E0 ; 000090, 29.358
0B1C53 FF 14 00    1309*   	dl 0x0014FF ; 000091, 29.527
0B1C56 1E 15 00    1310*   	dl 0x00151E ; 000092, 29.697
0B1C59 3C 15 00    1311*   	dl 0x00153C ; 000093, 29.865
0B1C5C 5B 15 00    1312*   	dl 0x00155B ; 000094, 30.033
0B1C5F 79 15 00    1313*   	dl 0x001579 ; 000095, 30.201
0B1C62 98 15 00    1314*   	dl 0x001598 ; 000096, 30.368
0B1C65 B6 15 00    1315*   	dl 0x0015B6 ; 000097, 30.534
0B1C68 D4 15 00    1316*   	dl 0x0015D4 ; 000098, 30.700
0B1C6B F2 15 00    1317*   	dl 0x0015F2 ; 000099, 30.865
0B1C6E 10 16 00    1318*   	dl 0x001610 ; 00009A, 31.030
0B1C71 2E 16 00    1319*   	dl 0x00162E ; 00009B, 31.194
0B1C74 4C 16 00    1320*   	dl 0x00164C ; 00009C, 31.357
0B1C77 6A 16 00    1321*   	dl 0x00166A ; 00009D, 31.520
0B1C7A 87 16 00    1322*   	dl 0x001687 ; 00009E, 31.682
0B1C7D A5 16 00    1323*   	dl 0x0016A5 ; 00009F, 31.844
0B1C80 C2 16 00    1324*   	dl 0x0016C2 ; 0000A0, 32.005
0B1C83 DF 16 00    1325*   	dl 0x0016DF ; 0000A1, 32.166
0B1C86 FC 16 00    1326*   	dl 0x0016FC ; 0000A2, 32.326
0B1C89 19 17 00    1327*   	dl 0x001719 ; 0000A3, 32.486
0B1C8C 36 17 00    1328*   	dl 0x001736 ; 0000A4, 32.645
0B1C8F 53 17 00    1329*   	dl 0x001753 ; 0000A5, 32.803
0B1C92 70 17 00    1330*   	dl 0x001770 ; 0000A6, 32.961
0B1C95 8C 17 00    1331*   	dl 0x00178C ; 0000A7, 33.118
0B1C98 A9 17 00    1332*   	dl 0x0017A9 ; 0000A8, 33.275
0B1C9B C5 17 00    1333*   	dl 0x0017C5 ; 0000A9, 33.431
0B1C9E E2 17 00    1334*   	dl 0x0017E2 ; 0000AA, 33.587
0B1CA1 FE 17 00    1335*   	dl 0x0017FE ; 0000AB, 33.742
0B1CA4 1A 18 00    1336*   	dl 0x00181A ; 0000AC, 33.896
0B1CA7 36 18 00    1337*   	dl 0x001836 ; 0000AD, 34.050
0B1CAA 52 18 00    1338*   	dl 0x001852 ; 0000AE, 34.203
0B1CAD 6E 18 00    1339*   	dl 0x00186E ; 0000AF, 34.356
0B1CB0 8A 18 00    1340*   	dl 0x00188A ; 0000B0, 34.509
0B1CB3 A5 18 00    1341*   	dl 0x0018A5 ; 0000B1, 34.660
0B1CB6 C1 18 00    1342*   	dl 0x0018C1 ; 0000B2, 34.811
0B1CB9 DC 18 00    1343*   	dl 0x0018DC ; 0000B3, 34.962
0B1CBC F7 18 00    1344*   	dl 0x0018F7 ; 0000B4, 35.112
0B1CBF 13 19 00    1345*   	dl 0x001913 ; 0000B5, 35.262
0B1CC2 2E 19 00    1346*   	dl 0x00192E ; 0000B6, 35.410
0B1CC5 49 19 00    1347*   	dl 0x001949 ; 0000B7, 35.559
0B1CC8 64 19 00    1348*   	dl 0x001964 ; 0000B8, 35.707
0B1CCB 7F 19 00    1349*   	dl 0x00197F ; 0000B9, 35.854
0B1CCE 99 19 00    1350*   	dl 0x001999 ; 0000BA, 36.001
0B1CD1 B4 19 00    1351*   	dl 0x0019B4 ; 0000BB, 36.147
0B1CD4 CE 19 00    1352*   	dl 0x0019CE ; 0000BC, 36.293
0B1CD7 E9 19 00    1353*   	dl 0x0019E9 ; 0000BD, 36.438
0B1CDA 03 1A 00    1354*   	dl 0x001A03 ; 0000BE, 36.582
0B1CDD 1D 1A 00    1355*   	dl 0x001A1D ; 0000BF, 36.726
0B1CE0 37 1A 00    1356*   	dl 0x001A37 ; 0000C0, 36.870
0B1CE3 51 1A 00    1357*   	dl 0x001A51 ; 0000C1, 37.013
0B1CE6 6B 1A 00    1358*   	dl 0x001A6B ; 0000C2, 37.155
0B1CE9 85 1A 00    1359*   	dl 0x001A85 ; 0000C3, 37.297
0B1CEC 9F 1A 00    1360*   	dl 0x001A9F ; 0000C4, 37.439
0B1CEF B9 1A 00    1361*   	dl 0x001AB9 ; 0000C5, 37.579
0B1CF2 D2 1A 00    1362*   	dl 0x001AD2 ; 0000C6, 37.720
0B1CF5 EC 1A 00    1363*   	dl 0x001AEC ; 0000C7, 37.859
0B1CF8 05 1B 00    1364*   	dl 0x001B05 ; 0000C8, 37.999
0B1CFB 1E 1B 00    1365*   	dl 0x001B1E ; 0000C9, 38.137
0B1CFE 37 1B 00    1366*   	dl 0x001B37 ; 0000CA, 38.276
0B1D01 50 1B 00    1367*   	dl 0x001B50 ; 0000CB, 38.413
0B1D04 69 1B 00    1368*   	dl 0x001B69 ; 0000CC, 38.550
0B1D07 82 1B 00    1369*   	dl 0x001B82 ; 0000CD, 38.687
0B1D0A 9B 1B 00    1370*   	dl 0x001B9B ; 0000CE, 38.823
0B1D0D B4 1B 00    1371*   	dl 0x001BB4 ; 0000CF, 38.959
0B1D10 CC 1B 00    1372*   	dl 0x001BCC ; 0000D0, 39.094
0B1D13 E5 1B 00    1373*   	dl 0x001BE5 ; 0000D1, 39.228
0B1D16 FD 1B 00    1374*   	dl 0x001BFD ; 0000D2, 39.362
0B1D19 16 1C 00    1375*   	dl 0x001C16 ; 0000D3, 39.496
0B1D1C 2E 1C 00    1376*   	dl 0x001C2E ; 0000D4, 39.629
0B1D1F 46 1C 00    1377*   	dl 0x001C46 ; 0000D5, 39.762
0B1D22 5E 1C 00    1378*   	dl 0x001C5E ; 0000D6, 39.894
0B1D25 76 1C 00    1379*   	dl 0x001C76 ; 0000D7, 40.025
0B1D28 8E 1C 00    1380*   	dl 0x001C8E ; 0000D8, 40.156
0B1D2B A5 1C 00    1381*   	dl 0x001CA5 ; 0000D9, 40.286
0B1D2E BD 1C 00    1382*   	dl 0x001CBD ; 0000DA, 40.416
0B1D31 D5 1C 00    1383*   	dl 0x001CD5 ; 0000DB, 40.546
0B1D34 EC 1C 00    1384*   	dl 0x001CEC ; 0000DC, 40.675
0B1D37 04 1D 00    1385*   	dl 0x001D04 ; 0000DD, 40.803
0B1D3A 1B 1D 00    1386*   	dl 0x001D1B ; 0000DE, 40.931
0B1D3D 32 1D 00    1387*   	dl 0x001D32 ; 0000DF, 41.059
0B1D40 49 1D 00    1388*   	dl 0x001D49 ; 0000E0, 41.186
0B1D43 60 1D 00    1389*   	dl 0x001D60 ; 0000E1, 41.312
0B1D46 77 1D 00    1390*   	dl 0x001D77 ; 0000E2, 41.438
0B1D49 8E 1D 00    1391*   	dl 0x001D8E ; 0000E3, 41.564
0B1D4C A5 1D 00    1392*   	dl 0x001DA5 ; 0000E4, 41.689
0B1D4F BB 1D 00    1393*   	dl 0x001DBB ; 0000E5, 41.814
0B1D52 D2 1D 00    1394*   	dl 0x001DD2 ; 0000E6, 41.938
0B1D55 E9 1D 00    1395*   	dl 0x001DE9 ; 0000E7, 42.061
0B1D58 FF 1D 00    1396*   	dl 0x001DFF ; 0000E8, 42.184
0B1D5B 15 1E 00    1397*   	dl 0x001E15 ; 0000E9, 42.307
0B1D5E 2C 1E 00    1398*   	dl 0x001E2C ; 0000EA, 42.429
0B1D61 42 1E 00    1399*   	dl 0x001E42 ; 0000EB, 42.551
0B1D64 58 1E 00    1400*   	dl 0x001E58 ; 0000EC, 42.672
0B1D67 6E 1E 00    1401*   	dl 0x001E6E ; 0000ED, 42.793
0B1D6A 84 1E 00    1402*   	dl 0x001E84 ; 0000EE, 42.913
0B1D6D 99 1E 00    1403*   	dl 0x001E99 ; 0000EF, 43.033
0B1D70 AF 1E 00    1404*   	dl 0x001EAF ; 0000F0, 43.152
0B1D73 C5 1E 00    1405*   	dl 0x001EC5 ; 0000F1, 43.271
0B1D76 DA 1E 00    1406*   	dl 0x001EDA ; 0000F2, 43.390
0B1D79 F0 1E 00    1407*   	dl 0x001EF0 ; 0000F3, 43.508
0B1D7C 05 1F 00    1408*   	dl 0x001F05 ; 0000F4, 43.625
0B1D7F 1B 1F 00    1409*   	dl 0x001F1B ; 0000F5, 43.742
0B1D82 30 1F 00    1410*   	dl 0x001F30 ; 0000F6, 43.859
0B1D85 45 1F 00    1411*   	dl 0x001F45 ; 0000F7, 43.975
0B1D88 5A 1F 00    1412*   	dl 0x001F5A ; 0000F8, 44.091
0B1D8B 6F 1F 00    1413*   	dl 0x001F6F ; 0000F9, 44.206
0B1D8E 84 1F 00    1414*   	dl 0x001F84 ; 0000FA, 44.321
0B1D91 99 1F 00    1415*   	dl 0x001F99 ; 0000FB, 44.435
0B1D94 AD 1F 00    1416*   	dl 0x001FAD ; 0000FC, 44.549
0B1D97 C2 1F 00    1417*   	dl 0x001FC2 ; 0000FD, 44.662
0B1D9A D7 1F 00    1418*   	dl 0x001FD7 ; 0000FE, 44.775
0B1D9D EB 1F 00    1419*   	dl 0x001FEB ; 0000FF, 44.888
0B1DA0 00 20 00    1420*   	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B1DA3             0024        include "files.inc"
0B1DA3             0001*   ; load to onboard 8k sram
0B1DA3             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
0B1DA3             0025        include "timer.inc"
0B1DA3             0001*   ; Table 32. Timer Control Registers
0B1DA3             0002*   ; this constant is the base address of the timer control registers
0B1DA3             0003*   ; each timer takes three bytes:
0B1DA3             0004*   ;   0: control register
0B1DA3             0005*   ;   1: low byte of timer reset value
0B1DA3             0006*   ;   2: high byte of timer reset value
0B1DA3             0007*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B1DA3             0008*   ; which correctly force the high and upper bytes of the address bus to zero
0B1DA3             0009*   TMR_CTL:     equ 80h
0B1DA3             0010*   
0B1DA3             0011*   ; Timer Control Register Bit Definitions
0B1DA3             0012*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B1DA3             0013*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B1DA3             0014*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B1DA3             0015*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B1DA3             0016*                               ; the TMRx_CTL register is read.
0B1DA3             0017*   
0B1DA3             0018*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B1DA3             0019*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B1DA3             0020*   
0B1DA3             0021*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B1DA3             0022*                               ;  0,and counting stops when the end-of-count value is reached.
0B1DA3             0023*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B1DA3             0024*                               ; written to the counter when the end-of-count value is reached.
0B1DA3             0025*   
0B1DA3             0026*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B1DA3             0027*   CLK_DIV_256:  equ %00001100 ;
0B1DA3             0028*   CLK_DIV_64:   equ %00001000 ;
0B1DA3             0029*   CLK_DIV_16:   equ %00000100 ;
0B1DA3             0030*   CLK_DIV_4:    equ %00000000 ;
0B1DA3             0031*   
0B1DA3             0032*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B1DA3             0033*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B1DA3             0034*                               ; When a 1 is written to this bit,the values in the reload registers
0B1DA3             0035*                               ;  are loaded into the downcounter when the timer restarts. The
0B1DA3             0036*                               ; programmer must ensure that this bit is set to 1 each time
0B1DA3             0037*                               ; SINGLE-PASS mode is used.
0B1DA3             0038*   
0B1DA3             0039*   ; disable/enable the programmable reload timer
0B1DA3             0040*   PRT_EN_0:     equ %00000000 ;
0B1DA3             0041*   PRT_EN_1:     equ %00000001 ;
0B1DA3             0042*   
0B1DA3             0043*   ; Table 37. Timer Input Source Select Register
0B1DA3             0044*   ; Each of the 4 timers are allocated two bits of the 8-bit register
0B1DA3             0045*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B1DA3             0046*   ;   00: System clock / CLK_DIV
0B1DA3             0047*   ;   01: RTC / CLK_DIV
0B1DA3             0048*   ;   NOTE: these are the values given in the manual,but it may be a typo
0B1DA3             0049*   ;   10: GPIO port B pin 1.
0B1DA3             0050*   ;   11: GPIO port B pin 1.
0B1DA3             0051*   TMR_ISS:   equ 92h ; register address
0B1DA3             0052*   
0B1DA3             0053*   ; Table 51. Real-Time Clock Control Register
0B1DA3             0054*   RTC_CTRL: equ EDh ; register address
0B1DA3             0055*   
0B1DA3             0056*   ; alarm interrupt disable/enable
0B1DA3             0057*   RTC_ALARM_0:    equ %00000000
0B1DA3             0058*   RTC_ALARM_1:    equ %10000000
0B1DA3             0059*   
0B1DA3             0060*   ; interrupt on alarm disable/enable
0B1DA3             0061*   RTC_INT_ENT_0:  equ %00000000
0B1DA3             0062*   RTC_INT_ENT_1:  equ %01000000
0B1DA3             0063*   
0B1DA3             0064*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B1DA3             0065*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B1DA3             0066*   
0B1DA3             0067*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B1DA3             0068*                                   ; On-chip 32768 Hz oscillator is enabled.
0B1DA3             0069*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B1DA3             0070*                                   ; On-chip 32768 Hz oscillator is disabled.
0B1DA3             0071*   
0B1DA3             0072*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B1DA3             0073*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B1DA3             0074*   
0B1DA3             0075*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B1DA3             0076*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B1DA3             0077*   
0B1DA3             0078*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B1DA3             0079*                                   ; RTC counter is enabled.
0B1DA3             0080*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B1DA3             0081*                                   ; RTC counter is disabled.
0B1DA3             0082*   
0B1DA3             0083*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B1DA3             0084*   
0B1DA3             0085*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B1DA3             0086*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B1DA3 00 00 00    0087*   prt_reload: dl 0x000000
0B1DA6             0088*   
0B1DA6             0089*   ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B1DA6             0090*   ; ;          de = number PRT interrupts during test interval
0B1DA6             0091*   ; prt_calibrate:
0B1DA6             0092*   ;     call vdu_vblank
0B1DA6             0093*   ; ; set a MOS timer
0B1DA6             0094*   ;     ld hl,120*1 ; 1 second
0B1DA6             0095*   ;     ld iy,tmr_test
0B1DA6             0096*   ;     call tmr_set
0B1DA6             0097*   ; ; set a PRT timer
0B1DA6             0098*   ;     ; ld hl,prt_reload_hardware
0B1DA6             0099*   ;     ; ld hl,prt_reload_emulator
0B1DA6             0100*   ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B1DA6             0101*   ;     ld (prt_reload),hl
0B1DA6             0102*   ;     call prt_set
0B1DA6             0103*   ; @loop:
0B1DA6             0104*   ; ; check time remaining on MOS timer
0B1DA6             0105*   ;     call tmr_get
0B1DA6             0106*   ;     jp z,@done ; time expired,so quit
0B1DA6             0107*   ;     jp m,@done ; time past expiration (negative),so quit
0B1DA6             0108*   ;     jr @loop
0B1DA6             0109*   ; @done:
0B1DA6             0110*   ;     ld de,(prt_irq_counter)
0B1DA6             0111*   ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B1DA6             0112*   ;     ld (prt_reload),bc
0B1DA6             0113*   ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B1DA6             0114*   ;     xor a ; clear carry,zero is default value for running on hardware
0B1DA6             0115*   ;     ld (is_emulator),a
0B1DA6             0116*   ;     sbc hl,de
0B1DA6             0117*   ;     ld hl,on_hardware ; default message for running on hardware
0B1DA6             0118*   ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B1DA6             0119*   ;     ret m ; negative result means we're on hardware
0B1DA6             0120*   ;     inc a ; we're on emulator
0B1DA6             0121*   ;     ld (is_emulator),a
0B1DA6             0122*   ;     ld bc,prt_reload_emulator
0B1DA6             0123*   ;     ld (prt_reload),bc
0B1DA6             0124*   ;     ld hl,on_emulator
0B1DA6             0125*   ;     ret
0B1DA6             0126*   
0B1DA6             0127*   ; calibrating_timer: defb "Calibrating timer\r\n",0
0B1DA6             0128*   
0B1DA6             0129*   ; set PRT timer
0B1DA6             0130*   prt_set:
0B1DA6 21 00 00 00 0131*       ld hl,0
0B1DAA 22 F4 1D 0B 0132*       ld (prt_irq_counter),hl
0B1DAE 2A A3 1D 0B 0133*       ld hl,(prt_reload)
0B1DB2 ED 29 84    0134*       out0 ($84),l
0B1DB5 ED 21 85    0135*   	out0 ($85),h
0B1DB8             0136*   ; disable timer
0B1DB8 3E 06       0137*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B1DBA ED 39 83    0138*   	out0 ($83),a
0B1DBD             0139*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B1DBD 3E 57       0140*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B1DBF ED 39 83    0141*   	out0 ($83),a
0B1DC2 C9          0142*       ret
0B1DC3             0143*   
0B1DC3             0144*   ; ===============================================
0B1DC3             0145*   ; PRT Timer Interrupt Handling
0B1DC3             0146*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B1DC3             0147*   ; -----------------------------------------------
0B1DC3             0148*   prt_irq_init:
0B1DC3             0149*       ; set up interrupt vector table 2
0B1DC3 21 00 00 00 0150*   	ld hl,0
0B1DC7 3A 0C 01 00 0151*   	ld a,($10c)
0B1DCB 6F          0152*   	ld l,a
0B1DCC 3A 0D 01 00 0153*   	ld a,($10d)
0B1DD0 67          0154*   	ld h,a
0B1DD1             0155*   
0B1DD1             0156*   	; skip over CALL ($c3)
0B1DD1 23          0157*   	inc hl
0B1DD2             0158*   	; load address of jump into vector table 2 (in ram)
0B1DD2 ED 27       0159*   	ld hl,(hl)
0B1DD4             0160*   
0B1DD4             0161*   	; write CALL prt_irq_handler to vector table 2
0B1DD4 3E C3       0162*   	ld a,$c3
0B1DD6 77          0163*   	ld (hl),a
0B1DD7 23          0164*   	inc hl
0B1DD8 11 DF 1D 0B 0165*   	ld de,prt_irq_handler
0B1DDC ED 1F       0166*   	ld (hl),de
0B1DDE             0167*   
0B1DDE C9          0168*       ret
0B1DDF             0169*   
0B1DDF             0170*   prt_irq_handler:
0B1DDF F3          0171*   	di
0B1DE0 F5          0172*   	push af
0B1DE1 E5          0173*       push hl
0B1DE2 ED 38 83    0174*   	in0 a,($83)
0B1DE5 2A F4 1D 0B 0175*   	ld hl,(prt_irq_counter)
0B1DE9 23          0176*   	inc hl
0B1DEA 22 F4 1D 0B 0177*   	ld (prt_irq_counter),hl
0B1DEE E1          0178*       pop hl
0B1DEF F1          0179*   	pop af
0B1DF0 FB          0180*   	ei
0B1DF1 5B ED 4D    0181*   	reti.l
0B1DF4             0182*   
0B1DF4             0183*   prt_irq_counter:
0B1DF4 00 00 00    0184*   	.dl 0
0B1DF7             0185*   prt_irq_counter_saved:
0B1DF7 00 00 00    0186*       .dl 0
0B1DFA             0187*   
0B1DFA             0188*   prt_loop_reset:
0B1DFA E5          0189*       push hl
0B1DFB 21 00 00 00 0190*   	ld hl,0
0B1DFF 22 F4 1D 0B 0191*   	ld (prt_irq_counter),hl
0B1E03 22 65 1E 0B 0192*       ld (prt_loop_counter),hl
0B1E07 22 68 1E 0B 0193*       ld (prt_loops),hl
0B1E0B CD A6 1D 0B 0194*       call prt_set
0B1E0F E1          0195*       pop hl
0B1E10 C9          0196*       ret
0B1E11             0197*   
0B1E11             0198*   prt_loop_start:
0B1E11 E5          0199*       push hl
0B1E12 21 00 00 00 0200*   	ld hl,0
0B1E16 22 F4 1D 0B 0201*   	ld (prt_irq_counter),hl
0B1E1A E1          0202*       pop hl
0B1E1B C9          0203*       ret
0B1E1C             0204*   
0B1E1C             0205*   prt_loop_stop:
0B1E1C E5          0206*       push hl
0B1E1D D5          0207*       push de
0B1E1E 2A F4 1D 0B 0208*       ld hl,(prt_irq_counter)
0B1E22 ED 5B 65 1E 0209*       ld de,(prt_loop_counter)
       0B          
0B1E27 19          0210*       add hl,de
0B1E28 22 65 1E 0B 0211*       ld (prt_loop_counter),hl
0B1E2C 21 00 00 00 0212*       ld hl,0
0B1E30 22 F4 1D 0B 0213*       ld (prt_irq_counter),hl
0B1E34 2A 68 1E 0B 0214*       ld hl,(prt_loops)
0B1E38 23          0215*       inc hl
0B1E39 22 68 1E 0B 0216*       ld (prt_loops),hl
0B1E3D D1          0217*       pop de
0B1E3E E1          0218*       pop hl
0B1E3F C9          0219*       ret
0B1E40             0220*   
0B1E40             0221*   ; inputs: bc = y,x text coordinates to print
0B1E40             0222*   prt_loop_print:
0B1E40 F5          0223*       push af
0B1E41 E5          0224*       push hl
0B1E42 C5          0225*       push bc
0B1E43 D5          0226*       push de
0B1E44 DD E5       0227*       push ix
0B1E46 FD E5       0228*       push iy
0B1E48 CD 5D 1F 0B 0229*       call vdu_move_cursor
0B1E4C             0230*   
0B1E4C 2A 65 1E 0B 0231*       ld hl,(prt_loop_counter)
0B1E50 CD E8 02 0B 0232*       call printDec
0B1E54             0233*   
0B1E54 2A 68 1E 0B 0234*       ld hl,(prt_loops)
0B1E58 CD E8 02 0B 0235*       call printDec
0B1E5C             0236*   
0B1E5C FD E1       0237*       pop iy
0B1E5E DD E1       0238*       pop ix
0B1E60 D1          0239*       pop de
0B1E61 C1          0240*       pop bc
0B1E62 E1          0241*       pop hl
0B1E63 F1          0242*       pop af
0B1E64 C9          0243*       ret
0B1E65             0244*   
0B1E65             0245*   prt_loop_counter:
0B1E65 00 00 00    0246*       .dl 0
0B1E68             0247*   prt_loops:
0B1E68 00 00 00    0248*       .dl 0
0B1E6B             0249*   
0B1E6B             0250*   ; ===============================================
0B1E6B             0251*   ; Timer functions
0B1E6B             0252*   ; -----------------------------------------------
0B1E6B             0253*   ; set a countdown timer
0B1E6B             0254*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1E6B             0255*   ; returns: hl = current time
0B1E6B             0256*   tmr_set:
0B1E6B FD 2F 03    0257*       ld (iy+3),hl            ; set time remaining
0B1E6E             0258*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1E6E 3E 08       0001*M  			LD	A, function
0B1E70 5B CF       0002*M  			RST.L	08h
0B1E72 DD 27 00    0259*       ld hl,(ix+sysvar_time)  ; get current time
0B1E75 FD 2F 00    0260*       ld (iy+0),hl            ; set start time
0B1E78 C9          0261*       ret
0B1E79             0262*   
0B1E79             0263*   ; gets time remaining on a countdown timer
0B1E79             0264*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1E79             0265*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1E79             0266*   ;          sign flags: pos = time not expired,zero or neg = time expired
0B1E79             0267*   tmr_get:
0B1E79             0268*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1E79 3E 08       0001*M  			LD	A, function
0B1E7B 5B CF       0002*M  			RST.L	08h
0B1E7D DD 17 00    0269*       ld de,(ix+sysvar_time)  ; get current time
0B1E80 FD 27 00    0270*       ld hl,(iy+0)            ; get start time
0B1E83 AF          0271*       xor a                   ; clear carry
0B1E84 ED 52       0272*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1E86 FD 17 03    0273*       ld de,(iy+3)            ; get timer set value
0B1E89 AF          0274*       xor a                   ; clear carry
0B1E8A ED 5A       0275*       adc hl,de               ; hl = time remaining
0B1E8C             0276*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1E8C C9          0277*       ret
0B1E8D             0278*   
0B1E8D 00 00 00    0279*   timestamp_now: dl 0
0B1E90 00 00 00    0280*   timestamp_old: dl 0
0B1E93 00 00 00    0281*   timestamp_chg: dl 0
0B1E96             0282*   
0B1E96             0283*   ; update the global timestamp from the system clock
0B1E96             0284*   ; inputs: none
0B1E96             0285*   ; returns: hl = time elapsed in 1/120ths of a second
0B1E96             0286*   ;          de = current time
0B1E96             0287*   ;          ix = pointer to syvars table
0B1E96             0288*   ; destroys: af,hl,de,ix
0B1E96             0289*   timestamp_tick:
0B1E96 ED 5B 8D 1E 0290*       ld de,(timestamp_now)   ; get previous time
       0B          
0B1E9B ED 53 90 1E 0291*       ld (timestamp_old),de   ; save previous time
       0B          
0B1EA0             0292*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1EA0 3E 08       0001*M  			LD	A, function
0B1EA2 5B CF       0002*M  			RST.L	08h
0B1EA4 DD 27 00    0293*       ld hl,(ix+sysvar_time)  ; get current time
0B1EA7 22 8D 1E 0B 0294*       ld (timestamp_now),hl   ; save current time
0B1EAB AF          0295*       xor a                   ; clear carry
0B1EAC ED 52       0296*       sbc hl,de               ; hl = time elapsed
0B1EAE 22 93 1E 0B 0297*       ld (timestamp_chg),hl   ; save elapsed time
0B1EB2 C9          0298*       ret
0B1EB3             0299*   
0B1EB3             0300*   ; set a countdown timer
0B1EB3             0301*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1EB3             0302*   ; requires: timestamp_tick to be called at least once before this function
0B1EB3             0303*   ; returns: hl = current time
0B1EB3             0304*   ; destroys: hl
0B1EB3             0305*   timestamp_tmr_set:
0B1EB3 FD 2F 03    0306*       ld (iy+3),hl            ; set time remaining
0B1EB6 2A 8D 1E 0B 0307*       ld hl,(timestamp_now)   ; get current timestamp
0B1EBA FD 2F 00    0308*       ld (iy+0),hl            ; set start time
0B1EBD C9          0309*       ret
0B1EBE             0310*   
0B1EBE             0311*   ; gets time remaining on a countdown timer following the global timestamp
0B1EBE             0312*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1EBE             0313*   ; requires: timestamp_tick to be called at least once before this function
0B1EBE             0314*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1EBE             0315*   ;          sign flags: pos = time not expired,zero or neg = time expired
0B1EBE             0316*   ; destroys: af,hl,de
0B1EBE             0317*   timestamp_tmr_get:
0B1EBE ED 5B 8D 1E 0318*       ld de,(timestamp_now)   ; get current timestamp
       0B          
0B1EC3 FD 27 00    0319*       ld hl,(iy+0)            ; get start time
0B1EC6 AF          0320*       xor a                   ; clear carry
0B1EC7 ED 52       0321*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1EC9 FD 17 03    0322*       ld de,(iy+3)            ; get timer set value
0B1ECC AF          0323*       xor a                   ; clear carry
0B1ECD ED 5A       0324*       adc hl,de               ; hl = time remaining
0B1ECF             0325*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1ECF C9          0326*       ret
0B1ED0             0327*   
0B1ED0             0328*   ; main loop timer functions
0B1ED0             0329*   tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B1ED6             0330*   
0B1ED6             0331*   ; set a countdown timer for the main loop using the timestamp timer
0B1ED6             0332*   ; inputs: hl = time to set in 1/120ths of a second
0B1ED6             0333*   ; returns: hl = current time
0B1ED6             0334*   ; destroys: af,hl,de,ix,iy
0B1ED6             0335*   tmr_main_loop_set:
0B1ED6 FD 21 D0 1E 0336*       ld iy,tmr_main_loop
       0B          
0B1EDB FD 2F 03    0337*       ld (iy+3),hl ; set time remaining
0B1EDE CD 96 1E 0B 0338*       call timestamp_tick
0B1EE2 2A 8D 1E 0B 0339*       ld hl,(timestamp_now)   ; get current timestamp
0B1EE6 FD 2F 00    0340*       ld (iy+0),hl ; set start time
0B1EE9 C9          0341*       ret
0B1EEA             0342*   
0B1EEA             0343*   ; gets time remaining on the main loop countdown timer following the global timestamp
0B1EEA             0344*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1EEA             0345*   ;          sign flags: pos = time not expired,zero or neg = time expired
0B1EEA             0346*   ; destroys: af,hl,de,ix,iy
0B1EEA             0347*   tmr_main_loop_get:
0B1EEA CD 96 1E 0B 0348*       call timestamp_tick
0B1EEE FD 21 D0 1E 0349*       ld iy,tmr_main_loop
       0B          
0B1EF3 CD BE 1E 0B 0350*       call timestamp_tmr_get
0B1EF7 C9          0351*       ret
0B1EF8             0352*   
0B1EF8             0353*   ; set a stopwatch
0B1EF8             0354*   ; returns: hl = start time
0B1EF8             0355*   ; destroys: hl,ix
0B1EF8             0356*   stopwatch_set:
0B1EF8             0357*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1EF8 3E 08       0001*M  			LD	A, function
0B1EFA 5B CF       0002*M  			RST.L	08h
0B1EFC DD 27 00    0358*       ld hl,(ix+sysvar_time)  ; get current time
0B1EFF 22 14 1F 0B 0359*       ld (stopwatch_started),hl            ; set start time
0B1F03 C9          0360*       ret
0B1F04             0361*   
0B1F04             0362*   ; gets time elapsed on a stopwatch
0B1F04             0363*   ; returns: hl = time elapsed in 1/120ths of a second
0B1F04             0364*   ; destroys: af,hl,de,ix
0B1F04             0365*   stopwatch_get:
0B1F04             0366*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1F04 3E 08       0001*M  			LD	A, function
0B1F06 5B CF       0002*M  			RST.L	08h
0B1F08 DD 27 00    0367*       ld hl,(ix+sysvar_time)  ; get current time
0B1F0B ED 5B 14 1F 0368*       ld de,(stopwatch_started)            ; get start time
       0B          
0B1F10 AF          0369*       xor a                   ; clear carry
0B1F11 ED 52       0370*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B1F13 C9          0371*       ret
0B1F14             0372*   
0B1F14             0373*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B1F17             0374*   
0B1F17             0375*   ; ------------------
0B1F17             0376*   ; delay routine
0B1F17             0377*   ; Author: Richard Turrnidge
0B1F17             0378*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B1F17             0379*   ; routine waits a fixed time,then returns
0B1F17             0380*   ; arrive with A =  the delay byte. One bit to be set only.
0B1F17             0381*   ; eg. ld A,00000100b
0B1F17             0382*   
0B1F17             0383*   multiPurposeDelay:
0B1F17 F5          0384*       push af
0B1F18 C5          0385*       push bc
0B1F19 DD E5       0386*       push ix
0B1F1B 47          0387*       ld b,a
0B1F1C 3E 08       0388*       ld a,$08
0B1F1E 5B CF       0389*       RST.LIL	08h                 ; get IX pointer to sysvars
0B1F20             0390*   
0B1F20             0391*   waitLoop:
0B1F20             0392*   
0B1F20 DD 7E 00    0393*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B1F23             0394*   
0B1F23             0395*                                   ;   we check if bit set is same as last time we checked.
0B1F23             0396*                                   ;   bit 0 - don't use
0B1F23             0397*                                   ;   bit 1 - changes 64 times per second
0B1F23             0398*                                   ;   bit 2 - changes 32 times per second
0B1F23             0399*                                   ;   bit 3 - changes 16 times per second
0B1F23             0400*   
0B1F23             0401*                                   ;   bit 4 - changes 8 times per second
0B1F23             0402*                                   ;   bit 5 - changes 4 times per second
0B1F23             0403*                                   ;   bit 6 - changes 2 times per second
0B1F23             0404*                                   ;   bit 7 - changes 1 times per second
0B1F23 A0          0405*       and b
0B1F24 4F          0406*       ld c,a
0B1F25 3A 36 1F 0B 0407*       ld a,(oldTimeStamp)
0B1F29 B9          0408*       cp c                        ; is A same as last value?
0B1F2A 28 F4       0409*       jr z,waitLoop              ; loop here if it is
0B1F2C 79          0410*       ld a,c
0B1F2D 32 36 1F 0B 0411*       ld (oldTimeStamp),a        ; set new value
0B1F31             0412*   
0B1F31 DD E1       0413*       pop ix
0B1F33 C1          0414*       pop bc
0B1F34 F1          0415*       pop af
0B1F35 C9          0416*       ret
0B1F36             0417*   
0B1F36 00          0418*   oldTimeStamp:   .db 00h
0B1F37             0026        include "vdu.inc"
0B1F37             0001*   
0B1F37             0002*   ; VDU 30: Home cursor
0B1F37             0003*   vdu_home_cursor:
0B1F37 3E 1E       0004*       ld a,30
0B1F39 5B D7       0005*   	rst.lil $10
0B1F3B C9          0006*   	ret
0B1F3C             0007*   
0B1F3C             0008*   cursor_on:
0B1F3C 21 47 1F 0B 0009*   	ld hl,@cmd
0B1F40 01 03 00 00 0010*   	ld bc,@end-@cmd
0B1F44 5B DF       0011*   	rst.lil $18
0B1F46 C9          0012*   	ret
0B1F47             0013*   @cmd:
0B1F47 17 01 01    0014*   	db 23,1,1
0B1F4A             0015*   @end:
0B1F4A             0016*   
0B1F4A             0017*   cursor_off:
0B1F4A 21 55 1F 0B 0018*   	ld hl,@cmd
0B1F4E 01 03 00 00 0019*   	ld bc,@end-@cmd
0B1F52 5B DF       0020*   	rst.lil $18
0B1F54 C9          0021*   	ret
0B1F55             0022*   @cmd:
0B1F55 17 01 00    0023*   	db 23,1,0
0B1F58             0024*   @end:
0B1F58             0025*   
0B1F58             0026*   ; VDU 9: Move cursor forward one character
0B1F58             0027*   vdu_cursor_forward:
0B1F58 3E 09       0028*       ld a,9
0B1F5A 5B D7       0029*   	rst.lil $10
0B1F5C C9          0030*   	ret
0B1F5D             0031*   
0B1F5D             0032*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B1F5D             0033*   ; inputs: c=x, b=y 8-bit unsigned integers
0B1F5D             0034*   vdu_move_cursor:
0B1F5D ED 43 6E 1F 0035*       ld (@x0),bc
       0B          
0B1F62 21 6D 1F 0B 0036*   	ld hl,@cmd
0B1F66 01 03 00 00 0037*   	ld bc,@end-@cmd
0B1F6A 5B DF       0038*   	rst.lil $18
0B1F6C C9          0039*   	ret
0B1F6D 1F          0040*   @cmd: 	db 31
0B1F6E 00          0041*   @x0:	db 0
0B1F6F 00          0042*   @y0: 	db 0
0B1F70 00          0043*   @end: 	db 0 ; padding
0B1F71             0044*   
0B1F71             0045*   ; VDU 12: Clear text area (CLS)
0B1F71             0046*   vdu_cls:
0B1F71 3E 0C       0047*       ld a,12
0B1F73 5B D7       0048*   	rst.lil $10
0B1F75 C9          0049*   	ret
0B1F76             0050*   
0B1F76             0051*   vdu_flip:
0B1F76 21 81 1F 0B 0052*   	ld hl,@cmd
0B1F7A 01 03 00 00 0053*   	ld bc,@end-@cmd
0B1F7E 5B DF       0054*   	rst.lil $18
0B1F80 C9          0055*   	ret
0B1F81 17 00 C3    0056*   @cmd: db 23,0,0xC3
0B1F84             0057*   @end:
0B1F84             0058*   
0B1F84             0059*   ; VDU 16: Clear graphics area (CLG)
0B1F84             0060*   vdu_clg:
0B1F84 3E 10       0061*       ld a,16
0B1F86 5B D7       0062*   	rst.lil $10
0B1F88 C9          0063*   	ret
0B1F89             0064*   
0B1F89             0065*   ; COLOUR MODES
0B1F89             0066*   ; Mode	Effect
0B1F89             0067*   ; 0	Set on-screen pixel to target colour value
0B1F89             0068*   ; 1	OR value with the on-screen pixel
0B1F89             0069*   ; 2	AND value with the on-screen pixel
0B1F89             0070*   ; 3	XOR value with the on-screen pixel
0B1F89             0071*   ; 4	Invert the on-screen pixel
0B1F89             0072*   ; 5	No operation
0B1F89             0073*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0B1F89             0074*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0B1F89             0075*   
0B1F89             0076*   ; VDU 17, colour: Define text colour (COLOUR)
0B1F89             0077*   vdu_colour_text:
0B1F89 32 99 1F 0B 0078*   	ld (@arg),a
0B1F8D 21 98 1F 0B 0079*   	ld hl,@cmd
0B1F91 01 02 00 00 0080*   	ld bc,@end-@cmd
0B1F95 5B DF       0081*   	rst.lil $18
0B1F97 C9          0082*   	ret
0B1F98 11          0083*   @cmd: db 17
0B1F99 00          0084*   @arg: db 0
0B1F9A             0085*   @end:
0B1F9A             0086*   
0B1F9A             0087*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B1F9A             0088*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0B1F9A             0089*   vdu_gcol:
0B1F9A 32 AF 1F 0B 0090*   	ld (@mode),a
0B1F9E 79          0091*       ld a,c
0B1F9F 32 B0 1F 0B 0092*       ld (@col),a
0B1FA3 21 AE 1F 0B 0093*   	ld hl,@cmd
0B1FA7 01 03 00 00 0094*   	ld bc,@end-@cmd
0B1FAB 5B DF       0095*   	rst.lil $18
0B1FAD C9          0096*   	ret
0B1FAE 12          0097*   @cmd:  db 18
0B1FAF 00          0098*   @mode: db 0
0B1FB0 00          0099*   @col:  db 0
0B1FB1             0100*   @end:
0B1FB1             0101*   
0B1FB1             0102*   
0B1FB1             0103*   ; VDU 28, left, bottom, right, top: Set text viewport **
0B1FB1             0104*   ; MIND THE LITTLE-ENDIANESS
0B1FB1             0105*   ; inputs: c=left,b=bottom,e=right,d=top
0B1FB1             0106*   ; outputs; nothing
0B1FB1             0107*   ; destroys: a might make it out alive
0B1FB1             0108*   vdu_set_txt_viewport:
0B1FB1 ED 43 C7 1F 0109*       ld (@lb),bc
       0B          
0B1FB6 ED 53 C9 1F 0110*   	ld (@rt),de
       0B          
0B1FBB 21 C6 1F 0B 0111*   	ld hl,@cmd
0B1FBF 01 05 00 00 0112*   	ld bc,@end-@cmd
0B1FC3 5B DF       0113*   	rst.lil $18
0B1FC5 C9          0114*   	ret
0B1FC6 1C          0115*   @cmd:   db 28 ; set text viewport command
0B1FC7 00 00       0116*   @lb: 	dw 0x0000 ; set by bc
0B1FC9 00 00       0117*   @rt: 	dw 0x0000 ; set by de
0B1FCB 00          0118*   @end:   db 0x00	  ; padding
0B1FCC             0119*   
0B1FCC             0120*   ; Wait for VBLANK interrupt
0B1FCC             0121*   vdu_vblank:
0B1FCC DD E5       0122*       PUSH 	IX
0B1FCE             0123*   	MOSCALL	mos_sysvars
0B1FCE 3E 08       0001*M  			LD	A, function
0B1FD0 5B CF       0002*M  			RST.L	08h
0B1FD2 DD 7E 00    0124*   	LD	A, (IX + sysvar_time + 0)
0B1FD5             0125*   @wait:
0B1FD5 DD BE 00    0126*       CP 	A, (IX + sysvar_time + 0)
0B1FD8 28 FB       0127*       JR	Z, @wait
0B1FDA DD E1       0128*       POP	IX
0B1FDC C9          0129*       RET
0B1FDD             0130*   
0B1FDD             0131*   ; VDU 29, x; y;: Set graphics origin
0B1FDD             0132*   ; This command sets the graphics origin.
0B1FDD             0133*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0B1FDD             0134*   ; inputs: bc=x0,de=y0
0B1FDD             0135*   ; outputs; nothing
0B1FDD             0136*   ; destroys: a might make it out alive
0B1FDD             0137*   vdu_set_gfx_origin:
0B1FDD ED 43 F3 1F 0138*       ld (@x0),bc
       0B          
0B1FE2 ED 53 F5 1F 0139*       ld (@y0),de
       0B          
0B1FE7 21 F2 1F 0B 0140*       ld hl,@cmd
0B1FEB 01 05 00 00 0141*       ld bc,@end-@cmd
0B1FEF 5B DF       0142*       rst.lil $18
0B1FF1 C9          0143*       ret
0B1FF2 1D          0144*   @cmd:   db 29 ; set graphics origin command
0B1FF3 00 00       0145*   @x0: 	dw 0x0000 ; set by bc
0B1FF5 00 00       0146*   @y0: 	dw 0x0000 ; set by de
0B1FF7 00          0147*   @end:   db 0x00	  ; padding
0B1FF8             0148*   
0B1FF8             0149*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B1FF8             0150*   ; NOTE: the order of the y-coordinate parameters are inverted
0B1FF8             0151*   ; 	because we have turned off logical screen scaling
0B1FF8             0152*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B1FF8             0153*   ; outputs; nothing
0B1FF8             0154*   ; destroys: a might make it out alive
0B1FF8             0155*   vdu_set_gfx_viewport:
0B1FF8 ED 43 18 20 0156*       ld (@x0),bc
       0B          
0B1FFD FD 22 1A 20 0157*       ld (@y1),iy
       0B          
0B2002 DD 22 1C 20 0158*   	ld (@x1),ix
       0B          
0B2007 ED 53 1E 20 0159*   	ld (@y0),de
       0B          
0B200C 21 17 20 0B 0160*   	ld hl,@cmd
0B2010 01 09 00 00 0161*   	ld bc,@end-@cmd
0B2014 5B DF       0162*   	rst.lil $18
0B2016 C9          0163*   	ret
0B2017 18          0164*   @cmd:   db 24 ; set graphics viewport command
0B2018 00 00       0165*   @x0: 	dw 0x0000 ; set by bc
0B201A 00 00       0166*   @y1: 	dw 0x0000 ; set by iy
0B201C 00 00       0167*   @x1: 	dw 0x0000 ; set by ix
0B201E 00 00       0168*   @y0: 	dw 0x0000 ; set by de
0B2020 00          0169*   @end:   db 0x00	  ; padding
0B2021             0170*   
0B2021             0171*   ; SCREEN MODES
0B2021             0172*   ; ===============================
0B2021             0173*   ; Mode  Horz  Vert  Cols  Refresh
0B2021             0174*   ; ---   ----  ----  ----  -------
0B2021             0175*   ; 11    320   240   2     60hz
0B2021             0176*   ; 139   320   240   2     60hz
0B2021             0177*   ; 23    512   384   2     60hz
0B2021             0178*   ; 151   512   384   2     60hz
0B2021             0179*   ; 6     640   240   2     60hz
0B2021             0180*   ; 134   640   240   2     60hz
0B2021             0181*   ; 2     640   480   2     60hz
0B2021             0182*   ; 130   640   480   2     60hz
0B2021             0183*   ; 17    800   600   2     60hz
0B2021             0184*   ; 145   800   600   2     60hz
0B2021             0185*   ; 18    1024  768   2     60hz
0B2021             0186*   ; 146   1024  768   2     60hz
0B2021             0187*   ; ---   ----  ----  ----  -------
0B2021             0188*   ; 10    320   240   4     60hz
0B2021             0189*   ; 138   320   240   4     60hz
0B2021             0190*   ; 22    512   384   4     60hz
0B2021             0191*   ; 150   512   384   4     60hz
0B2021             0192*   ; 5     640   240   4     60hz
0B2021             0193*   ; 133   640   240   4     60hz
0B2021             0194*   ; 1     640   480   4     60hz
0B2021             0195*   ; 129   640   480   4     60hz
0B2021             0196*   ; 16    800   600   4     60hz
0B2021             0197*   ; 19    1024  768   4     60hz
0B2021             0198*   ; ---   ----  ----  ----  -------
0B2021             0199*   ; 9     320   240   16    60hz
0B2021             0200*   ; 137   320   240   16    60hz
0B2021             0201*   ; 21    512   384   16    60hz
0B2021             0202*   ; 149   512   384   16    60hz
0B2021             0203*   ; 4     640   240   16    60hz
0B2021             0204*   ; 132   640   240   16    60hz
0B2021             0205*   ; 0     640   480   16    60hz
0B2021             0206*   ; 7     n/a   n/a   16    60hz
0B2021             0207*   ; ---   ----  ----  ----  -------
0B2021             0208*   ; 8     320   240   64    60hz
0B2021             0209*   ; 136   320   240   64    60hz
0B2021             0210*   ; 20    512   384   64    60hz
0B2021             0211*   ; 3     640   240   64    60hz
0B2021             0212*   ; ---   ----  ----  ----  -------
0B2021             0213*   vdu_set_screen_mode:
0B2021 32 31 20 0B 0214*   	ld (@arg),a
0B2025 21 30 20 0B 0215*   	ld hl,@cmd
0B2029 01 02 00 00 0216*   	ld bc,@end-@cmd
0B202D 5B DF       0217*   	rst.lil $18
0B202F C9          0218*   	ret
0B2030 16          0219*   @cmd: db 22 ; set screen mode
0B2031 00          0220*   @arg: db 0  ; screen mode parameter
0B2032             0221*   @end:
0B2032             0222*   
0B2032             0223*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B2032             0224*   ; inputs: a is scaling mode, 1=on, 0=off
0B2032             0225*   ; note: default setting on boot is scaling ON
0B2032             0226*   vdu_set_scaling:
0B2032 32 44 20 0B 0227*   	ld (@arg),a
0B2036 21 41 20 0B 0228*   	ld hl,@cmd
0B203A 01 04 00 00 0229*   	ld bc,@end-@cmd
0B203E 5B DF       0230*   	rst.lil $18
0B2040 C9          0231*   	ret
0B2041 17 00 C0    0232*   @cmd: db 23,0,0xC0
0B2044 00          0233*   @arg: db 0  ; scaling on/off
0B2045             0234*   @end:
0B2045             0235*   
0B2045             0236*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B2045             0237*   ; inputs: hl=bufferId
0B2045             0238*   vdu_buff_select:
0B2045 22 57 20 0B 0239*   	ld (@bufferId),hl
0B2049 21 54 20 0B 0240*   	ld hl,@cmd
0B204D 01 05 00 00 0241*   	ld bc,@end-@cmd
0B2051 5B DF       0242*   	rst.lil $18
0B2053 C9          0243*   	ret
0B2054 17 1B 20    0244*   @cmd: db 23,27,0x20
0B2057 00 00       0245*   @bufferId: dw 0x0000
0B2059 00          0246*   @end: db 0x00 ; padding
0B205A             0247*   
0B205A             0248*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B205A             0249*   ; inputs: a=format; bc=width; de=height
0B205A             0250*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B205A             0251*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B205A             0252*   ; 0 	RGBA8888 (4-bytes per pixel)
0B205A             0253*   ; 1 	RGBA2222 (1-bytes per pixel)
0B205A             0254*   ; 2 	Mono/Mask (1-bit per pixel)
0B205A             0255*   ; 3 	Reserved for internal use by VDP (native format)
0B205A             0256*   vdu_bmp_create:
0B205A ED 43 76 20 0257*       ld (@width),bc
       0B          
0B205F ED 53 78 20 0258*       ld (@height),de
       0B          
0B2064 32 7A 20 0B 0259*       ld (@fmt),a
0B2068 21 73 20 0B 0260*   	ld hl,@cmd
0B206C 01 08 00 00 0261*   	ld bc,@end-@cmd
0B2070 5B DF       0262*   	rst.lil $18
0B2072 C9          0263*   	ret
0B2073 17 1B 21    0264*   @cmd:       db 23,27,0x21
0B2076 00 00       0265*   @width:     dw 0x0000
0B2078 00 00       0266*   @height:    dw 0x0000
0B207A 00          0267*   @fmt:       db 0x00
0B207B             0268*   @end:
0B207B             0269*   
0B207B             0270*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B207B             0271*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B207B             0272*   vdu_load_img_rgba2_to_8:
0B207B             0273*   ; backup the target buffer id and image dimensions
0B207B E5          0274*       push hl
0B207C D5          0275*       push de
0B207D C5          0276*       push bc
0B207E             0277*   ; load the rgba2 image to working buffer 65534
0B207E 21 FE FF 00 0278*       ld hl,65534 ; temporary working buffer id
0B2082 CD 85 21 0B 0279*   	call vdu_load_buffer_from_file
0B2086             0280*   ; restore the image dimensions and target buffer id
0B2086 C1          0281*       pop bc
0B2087 D1          0282*       pop de
0B2088 E1          0283*       pop hl
0B2089             0284*   ; fall through to vdu_rgba2_to_8
0B2089             0285*   
0B2089             0286*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B2089             0287*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B2089             0288*   ; the "expand bitmap" command is:
0B2089             0289*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B2089             0290*   ; and then to reverse the byte order to fix endian-ness:
0B2089             0291*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B2089             0292*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B2089             0293*   ; VDU 23,27,&20,targetBufferID%;
0B2089             0294*   ; VDU 23,27,&21,width%;height%;0
0B2089             0295*   ; -------------------------------------------------------------------
0B2089             0296*   ; inputs: bc,de image width,height ; hl = targetBufferId
0B2089             0297*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B2089             0298*   vdu_rgba2_to_8:
0B2089             0299*   ; load the image dimensions and buffer id parameters
0B2089 ED 43 E5 20 0300*       ld (@width),bc
       0B          
0B208E ED 53 E7 20 0301*       ld (@height),de
       0B          
0B2093 22 CA 20 0B 0302*       ld (@bufferId0),hl
0B2097 22 D7 20 0B 0303*       ld (@bufferId2),hl
0B209B 22 E0 20 0B 0304*       ld (@bufferId1),hl
0B209F             0305*   ; clean up bytes that got stomped on by the ID loads
0B209F 3E 48       0306*       ld a,0x48
0B20A1 32 CC 20 0B 0307*       ld (@bufferId0+2),a
0B20A5 3E 17       0308*       ld a,23
0B20A7 32 E2 20 0B 0309*       ld (@bufferId1+2),a
0B20AB 3E 18       0310*       ld a,24
0B20AD 32 D9 20 0B 0311*       ld (@bufferId2+2),a
0B20B1 AF          0312*       xor a
0B20B2 32 E9 20 0B 0313*       ld (@height+2),a
0B20B6             0314*   ; send the vdu command strings
0B20B6 21 C1 20 0B 0315*       ld hl,@beg
0B20BA 01 29 00 00 0316*       ld bc,@end-@beg
0B20BE 5B DF       0317*       rst.lil $18
0B20C0 C9          0318*       ret
0B20C1             0319*   @beg:
0B20C1             0320*   ; Command 14: Consolidate blocks in a buffer
0B20C1             0321*   ; VDU 23, 0, &A0, bufferId; 14
0B20C1 17 00 A0    0322*       db 23,0,0xA0
0B20C4 FE FF       0323*       dw 65534 ; workingBufferId
0B20C6 0E          0324*       db 14 ; consolidate blocks
0B20C7             0325*   ; the "expand bitmap" command is:
0B20C7             0326*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B20C7 17 00 A0    0327*       db 23,0,0xA0
0B20CA 00 00       0328*   @bufferId0: dw 0x0000 ; targetBufferId
0B20CC 48          0329*       db 0x48 ; given as decimal command 72 in the docs
0B20CD 02          0330*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B20CE FE FF       0331*       dw 65534 ; sourceBufferId
0B20D0 00 7F BF FF 0332*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B20D4             0333*   ; reverse the byte order to fix endian-ness:
0B20D4             0334*   ; Command 24: Reverse the order of data of blocks within a buffer
0B20D4             0335*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B20D4             0336*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B20D4 17 00 A0    0337*       db 23,0,0xA0
0B20D7 00 00       0338*   @bufferId2:    dw 0x0000 ; targetBufferId
0B20D9 18          0339*       db 24 ; reverse byte order
0B20DA 04          0340*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B20DB 04 00       0341*       dw 4 ; size (4 bytes)
0B20DD             0342*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B20DD             0343*   ; VDU 23,27,&20,targetBufferID%;
0B20DD 17 1B 20    0344*       db 23,27,0x20 ; select bitmap
0B20E0 00 00       0345*   @bufferId1: dw 0x0000 ; targetBufferId
0B20E2             0346*   ; VDU 23,27,&21,width%;height%;0
0B20E2 17 1B 21    0347*       db 23,27,0x21 ; create bitmap from buffer
0B20E5 00 00       0348*   @width: dw 0x0000
0B20E7 00 00       0349*   @height: dw 0x0000
0B20E9 00          0350*       db 0x00 ; rgba8888 format
0B20EA             0351*   @end:
0B20EA             0352*   
0B20EA             0353*   ; scratch variables
0B20EA 00 00 00    0354*   bufferId0: dl 0x000000
0B20ED 00 00 00    0355*   bufferId1: dl 0x000000
0B20F0             0356*   
0B20F0             0357*   ; load a vdu buffer from local memory
0B20F0             0358*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B20F0             0359*   vdu_load_buffer:
0B20F0 ED 43 19 21 0360*       ld (@length),bc
       0B          
0B20F5 D5          0361*       push de ; save data pointer
0B20F6             0362*   ; send the vdu command string
0B20F6 7D          0363*       ld a,l
0B20F7 32 16 21 0B 0364*       ld (@bufferId),a
0B20FB 7C          0365*       ld a,h
0B20FC 32 17 21 0B 0366*       ld (@bufferId+1),a
0B2100 21 13 21 0B 0367*       ld hl,@cmd
0B2104 01 08 00 00 0368*       ld bc,@end-@cmd
0B2108 5B DF       0369*       rst.lil $18
0B210A             0370*   ; send the buffer data
0B210A E1          0371*       pop hl ; pointer to data
0B210B ED 4B 19 21 0372*       ld bc,(@length)
       0B          
0B2110 5B DF       0373*       rst.lil $18 ; send it
0B2112 C9          0374*       ret
0B2113             0375*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B2113 17 00 A0    0376*   @cmd:       db 23,0,0xA0
0B2116 00 00       0377*   @bufferId:	dw 0x0000
0B2118 00          0378*   		    db 0 ; load buffer
0B2119 00 00       0379*   @length:	dw 0x0000
0B211B 00          0380*   @end: db 0 ; padding
0B211C             0381*   
0B211C             0382*   ; clear a buffer
0B211C             0383*   ; inputs: hl = bufferId
0B211C             0384*   vdu_clear_buffer:
0B211C 7D          0385*       ld a,l
0B211D 32 34 21 0B 0386*       ld (@bufferId),a
0B2121 7C          0387*       ld a,h
0B2122 32 35 21 0B 0388*       ld (@bufferId+1),a
0B2126 21 31 21 0B 0389*       ld hl,@cmd
0B212A 01 06 00 00 0390*       ld bc,@end-@cmd
0B212E 5B DF       0391*       rst.lil $18
0B2130 C9          0392*       ret
0B2131 17 00 A0    0393*   @cmd:       db 23,0,0xA0
0B2134 00 00       0394*   @bufferId:	dw 0x0000
0B2136 02          0395*   		    db 2 ; clear buffer
0B2137             0396*   @end:
0B2137             0397*   
0B2137             0398*   vdu_clear_all_buffers:
0B2137             0399*   ; clear all buffers
0B2137 21 42 21 0B 0400*       ld hl,@beg
0B213B 01 06 00 00 0401*       ld bc,@end-@beg
0B213F 5B DF       0402*       rst.lil $18
0B2141 C9          0403*       ret
0B2142 17 00 A0    0404*   @beg: db 23,0,$A0
0B2145 FF FF       0405*         dw -1 ; clear all buffers
0B2147 02          0406*         db 2  ; command 2: clear a buffer
0B2148             0407*   @end:
0B2148             0408*   
0B2148             0409*   ; Command 14: Consolidate blocks in a buffer
0B2148             0410*   vdu_consolidate_buffer:
0B2148             0411*   ; set parameters for vdu call
0B2148 7D          0412*       ld a,l
0B2149 32 60 21 0B 0413*       ld (@bufferId),a
0B214D 7C          0414*       ld a,h
0B214E 32 61 21 0B 0415*       ld (@bufferId+1),a
0B2152 21 5D 21 0B 0416*       ld hl,@beg
0B2156 01 06 00 00 0417*       ld bc,@end-@beg
0B215A 5B DF       0418*       rst.lil $18
0B215C C9          0419*       ret
0B215D             0420*   ; VDU 23, 0, &A0, bufferId; 14
0B215D 17 00 A0    0421*   @beg: db 23,0,0xA0
0B2160 00 00       0422*   @bufferId: dw 0x0000
0B2162 0E          0423*              db 14
0B2163             0424*   @end:
0B2163             0425*   
0B2163             0426*   ; load an image file to a buffer and make it a bitmap
0B2163             0427*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B2163             0428*   vdu_load_img:
0B2163             0429*   ; back up image type and dimension parameters
0B2163 22 EA 20 0B 0430*       ld (bufferId0),hl
0B2167 F5          0431*       push af
0B2168 C5          0432*   	push bc
0B2169 D5          0433*   	push de
0B216A             0434*   ; load the image
0B216A CD 85 21 0B 0435*   	call vdu_load_buffer_from_file
0B216E             0436*   ; now make it a bitmap
0B216E 2A EA 20 0B 0437*       ld hl,(bufferId0)
0B2172 CD 48 21 0B 0438*       call vdu_consolidate_buffer
0B2176 2A EA 20 0B 0439*       ld hl,(bufferId0)
0B217A CD 45 20 0B 0440*       call vdu_buff_select
0B217E D1          0441*   	pop de ; image height
0B217F C1          0442*   	pop bc ; image width
0B2180 F1          0443*   	pop af ; image type
0B2181 C3 5A 20 0B 0444*   	jp vdu_bmp_create ; will return to caller from there
0B2185             0445*   
0B2185             0446*   ; inputs: hl = bufferId; iy = pointer to filename
0B2185             0447*   vdu_load_buffer_from_file:
0B2185 22 EA 20 0B 0448*       ld (bufferId0),hl
0B2189             0449*   
0B2189             0450*   ; clear target buffer
0B2189 CD 1C 21 0B 0451*       call vdu_clear_buffer
0B218D             0452*   
0B218D             0453*   ; open the file in read mode
0B218D             0454*   ; Open a file
0B218D             0455*   ; HLU: Filename
0B218D             0456*   ;   C: Mode
0B218D             0457*   ; Returns:
0B218D             0458*   ;   A: Filehandle, or 0 if couldn't open
0B218D FD E5       0459*   	push iy ; pointer to filename
0B218F E1          0460*   	pop hl
0B2190 0E 01       0461*   	ld c,fa_read
0B2192             0462*       MOSCALL mos_fopen
0B2192 3E 0A       0001*M  			LD	A, function
0B2194 5B CF       0002*M  			RST.L	08h
0B2196 32 D1 21 0B 0463*       ld (@filehandle),a
0B219A             0464*   
0B219A             0465*   @read_file:
0B219A             0466*   ; Read a block of data from a file
0B219A             0467*   ;   C: Filehandle
0B219A             0468*   ; HLU: Pointer to where to write the data to
0B219A             0469*   ; DEU: Number of bytes to read
0B219A             0470*   ; Returns:
0B219A             0471*   ; DEU: Number of bytes read
0B219A 3A D1 21 0B 0472*       ld a,(@filehandle)
0B219E 4F          0473*       ld c,a
0B219F 21 00 E0 B7 0474*       ld hl,filedata
0B21A3 11 00 20 00 0475*       ld de,8192 ; max we can read into onboard sram at one time
0B21A7             0476*       MOSCALL mos_fread
0B21A7 3E 1A       0001*M  			LD	A, function
0B21A9 5B CF       0002*M  			RST.L	08h
0B21AB             0477*   
0B21AB             0478*   ; ; DEBUG: print chunk size
0B21AB             0479*   ;     push de
0B21AB             0480*   ;     pop hl
0B21AB             0481*   ;     call printDec
0B21AB             0482*   ;     call printNewLine
0B21AB             0483*   
0B21AB             0484*   ; test de for zero bytes read
0B21AB 21 00 00 00 0485*       ld hl,0
0B21AF AF          0486*       xor a ; clear carry
0B21B0 ED 52       0487*       sbc hl,de
0B21B2 CA C8 21 0B 0488*       jp z,@close_file
0B21B6             0489*   
0B21B6             0490*   ; load a vdu buffer from local memory
0B21B6             0491*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B21B6 2A EA 20 0B 0492*       ld hl,(bufferId0)
0B21BA D5          0493*       push de ; chunksize
0B21BB C1          0494*       pop bc
0B21BC 11 00 E0 B7 0495*       ld de,filedata
0B21C0 CD F0 20 0B 0496*       call vdu_load_buffer
0B21C4             0497*   
0B21C4             0498*   ; ; print progress breadcrumbs
0B21C4             0499*   ;     ld a,'.'
0B21C4             0500*   ;     rst.lil 10h
0B21C4             0501*   
0B21C4             0502*   ; read the next block
0B21C4 C3 9A 21 0B 0503*       jp @read_file
0B21C8             0504*   
0B21C8             0505*   ; close the file
0B21C8             0506*   @close_file:
0B21C8 3A D1 21 0B 0507*       ld a,(@filehandle)
0B21CC             0508*       MOSCALL mos_fclose
0B21CC 3E 0B       0001*M  			LD	A, function
0B21CE 5B CF       0002*M  			RST.L	08h
0B21D0 C9          0509*       ret ; vdu_load_buffer_from_file
0B21D1             0510*   
0B21D1 00          0511*   @filehandle: db 0 ; file handle
0B21D2 00 00 00    0512*   @fil: dl 0 ; pointer to FIL struct
0B21D5             0513*   
0B21D5 00 00 00    0514*   @chunkpointer: dl 0 ; pointer to current chunk
0B21D8             0515*   
0B21D8             0516*   ; File information structure (FILINFO)
0B21D8             0517*   @filinfo:
0B21D8 00 00 00 00 0518*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B21DC 00 00       0519*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B21DE 00 00       0520*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B21E0 00          0521*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B21E1 00 00 00 00 0522*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B21EE 00 00 00 00 0523*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B22EE             0027        ; include "vdu_fonts.inc"
0B22EE             0028        include "vdu_plot.inc"
0B22EE             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B22EE             0002*   ; PLOT code 	(Decimal) 	Effect
0B22EE             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
0B22EE             0004*   plot_sl_both: equ 0x00
0B22EE             0005*   
0B22EE             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
0B22EE             0007*   plot_sl_first: equ 0x08
0B22EE             0008*   
0B22EE             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B22EE             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B22EE             0011*   
0B22EE             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
0B22EE             0013*   plot_sl_last: equ 0x20
0B22EE             0014*   
0B22EE             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
0B22EE             0016*   plot_sl_none: equ 0x28
0B22EE             0017*   
0B22EE             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B22EE             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B22EE             0020*   
0B22EE             0021*   ; &40-&47 	64-71 	Point plot
0B22EE             0022*   plot_pt: equ 0x40
0B22EE             0023*   
0B22EE             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B22EE             0025*   plot_lf_lr_non_bg: equ 0x48
0B22EE             0026*   
0B22EE             0027*   ; &50-&57 	80-87 	Triangle fill
0B22EE             0028*   plot_tf: equ 0x50
0B22EE             0029*   
0B22EE             0030*   ; &58-&5F 	88-95 	Line fill right to background 
0B22EE             0031*   plot_lf_r_bg: equ 0x58
0B22EE             0032*   
0B22EE             0033*   ; &60-&67 	96-103 	Rectangle fill
0B22EE             0034*   plot_rf: equ 0x60
0B22EE             0035*   
0B22EE             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B22EE             0037*   plot_lf_lr_fg: equ 0x60
0B22EE             0038*   
0B22EE             0039*   ; &70-&77 	112-119 	Parallelogram fill
0B22EE             0040*   plot_pf: equ 0x70
0B22EE             0041*   
0B22EE             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B22EE             0043*   plot_lf_r_non_fg: equ 0x78
0B22EE             0044*   
0B22EE             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B22EE             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B22EE             0047*   
0B22EE             0048*   ; &90-&97 	144-151 	Circle outline
0B22EE             0049*   plot_co: equ 0x90
0B22EE             0050*   
0B22EE             0051*   ; &98-&9F 	152-159 	Circle fill
0B22EE             0052*   plot_cf: equ 0x98
0B22EE             0053*   
0B22EE             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B22EE             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B22EE             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B22EE             0057*   
0B22EE             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
0B22EE             0059*   plot_rcm: equ 0xB8
0B22EE             0060*   
0B22EE             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B22EE             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B22EE             0063*   ; &D0-&D7 	208-215 	Not defined
0B22EE             0064*   ; &D8-&DF 	216-223 	Not defined
0B22EE             0065*   ; &E0-&E7 	224-231 	Not defined
0B22EE             0066*   
0B22EE             0067*   ; &E8-&EF 	232-239 	Bitmap plot 
0B22EE             0068*   plot_bmp: equ 0xE8
0B22EE             0069*   
0B22EE             0070*   ; &F0-&F7 	240-247 	Not defined
0B22EE             0071*   ; &F8-&FF 	248-255 	Not defined
0B22EE             0072*   
0B22EE             0073*   ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B22EE             0074*   ; Agon Console8 VDP 2.2.0
0B22EE             0075*   
0B22EE             0076*   ; Within each group of eight plot codes, the effects are as follows:
0B22EE             0077*   ; Plot code 	Effect
0B22EE             0078*   ; 0 	Move relative
0B22EE             0079*   mv_rel: equ 0
0B22EE             0080*   
0B22EE             0081*   ; 1 	Plot relative in current foreground colour
0B22EE             0082*   dr_rel_fg: equ 1
0B22EE             0083*   
0B22EE             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
0B22EE             0085*   ; 3 	Plot relative in current background colour
0B22EE             0086*   dr_rel_bg: equ 3
0B22EE             0087*   
0B22EE             0088*   ; 4 	Move absolute
0B22EE             0089*   mv_abs: equ 4
0B22EE             0090*   
0B22EE             0091*   ; 5 	Plot absolute in current foreground colour
0B22EE             0092*   dr_abs_fg: equ 5
0B22EE             0093*   
0B22EE             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
0B22EE             0095*   ; 7 	Plot absolute in current background colour
0B22EE             0096*   dr_abs_bg: equ 7
0B22EE             0097*   
0B22EE             0098*   ; Codes 0-3 use the position data provided as part of the command
0B22EE             0099*   ; as a relative position, adding the position given to the current
0B22EE             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
0B22EE             0101*   ; as part of the command as an absolute position, setting the current
0B22EE             0102*   ; graphical cursor position to the position given.
0B22EE             0103*   
0B22EE             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B22EE             0105*   ; current pixel colour. These operations cannot currently be supported
0B22EE             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
0B22EE             0107*   ; supported. Support for these codes may be added in a future version
0B22EE             0108*   ; of the VDP firmware.
0B22EE             0109*   
0B22EE             0110*   ; 16 colour palette constants
0B22EE             0111*   c_black: equ 0
0B22EE             0112*   c_red_dk: equ 1
0B22EE             0113*   c_green_dk: equ 2
0B22EE             0114*   c_yellow_dk: equ 3
0B22EE             0115*   c_blue_dk: equ 4
0B22EE             0116*   c_magenta_dk: equ 5
0B22EE             0117*   c_cyan_dk: equ 6
0B22EE             0118*   c_grey: equ 7
0B22EE             0119*   c_grey_dk: equ 8
0B22EE             0120*   c_red: equ 9
0B22EE             0121*   c_green: equ 10
0B22EE             0122*   c_yellow: equ 11
0B22EE             0123*   c_blue: equ 12
0B22EE             0124*   c_magenta: equ 13
0B22EE             0125*   c_cyan: equ 14
0B22EE             0126*   c_white: equ 15
0B22EE             0127*   
0B22EE             0128*   ; VDU 25, mode, x; y;: PLOT command
0B22EE             0129*   ; inputs: a=mode, bc=x0, de=y0
0B22EE             0130*   vdu_plot:
0B22EE 32 08 23 0B 0131*       ld (@mode),a
0B22F2 ED 43 09 23 0132*       ld (@x0),bc
       0B          
0B22F7 ED 53 0B 23 0133*       ld (@y0),de
       0B          
0B22FC 21 07 23 0B 0134*   	ld hl,@cmd
0B2300 01 06 00 00 0135*   	ld bc,@end-@cmd
0B2304 5B DF       0136*   	rst.lil $18
0B2306 C9          0137*   	ret
0B2307 19          0138*   @cmd:   db 25
0B2308 00          0139*   @mode:  db 0
0B2309 00 00       0140*   @x0: 	dw 0
0B230B 00 00       0141*   @y0: 	dw 0
0B230D 00          0142*   @end:   db 0 ; extra byte to soak up deu
0B230E             0143*   
0B230E             0144*   ; VDU 25, mode, x; y;: PLOT command
0B230E             0145*   ; USING 16.8 FIXED POINT COORDINATES
0B230E             0146*   ; inputs: a=mode, ub.c=x0, ud.e=y0
0B230E             0147*   vdu_plot_168:
0B230E ED 53 2A 23 0148*       ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
       0B          
0B2313 ED 43 28 23 0149*       ld (@x0-1),bc ; integer portion only
       0B          
0B2318 32 28 23 0B 0150*       ld (@mode),a  ; load this order b/c we shifted bc right
0B231C 21 27 23 0B 0151*   	ld hl,@cmd
0B2320 01 06 00 00 0152*   	ld bc,@end-@cmd
0B2324 5B DF       0153*   	rst.lil $18
0B2326             0154*       ; ld hl,@cmd
0B2326             0155*       ; ld a,6
0B2326             0156*       ; call dumpMemoryHex
0B2326             0157*       ; call printNewLine
0B2326 C9          0158*   	ret
0B2327 19          0159*   @cmd:   db 25
0B2328 00          0160*   @mode:  db 0
0B2329 00 00       0161*   @x0: 	dw 0
0B232B 00 00       0162*   @y0: 	dw 0
0B232D             0163*   @end:  ; no padding required b/c we shifted de right
0B232D             0164*   
0B232D             0165*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B232D             0166*   ; &E8-&EF 	232-239 	Bitmap plot 
0B232D             0167*   ; VDU 25, mode, x; y;: PLOT command
0B232D             0168*   ; inputs: bc=x0, de=y0
0B232D             0169*   ; prerequisites: vdu_buff_select
0B232D             0170*   vdu_plot_bmp:
0B232D ED 43 44 23 0171*       ld (@x0),bc
       0B          
0B2332 ED 53 46 23 0172*       ld (@y0),de
       0B          
0B2337 21 42 23 0B 0173*   	ld hl,@cmd
0B233B 01 06 00 00 0174*   	ld bc,@end-@cmd
0B233F 5B DF       0175*   	rst.lil $18
0B2341 C9          0176*   	ret
0B2342 19          0177*   @cmd:   db 25
0B2343 ED          0178*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B2344 00 00       0179*   @x0: 	dw 0x0000
0B2346 00 00       0180*   @y0: 	dw 0x0000
0B2348 00          0181*   @end:   db 0x00 ; padding
0B2349             0182*   
0B2349             0183*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B2349             0184*   ; &E8-&EF 	232-239 	Bitmap plot 
0B2349             0185*   ; VDU 25, mode, x; y;: PLOT command
0B2349             0186*   ; inputs: bc=x0, de=y0
0B2349             0187*   ; USING 16.8 FIXED POINT COORDINATES
0B2349             0188*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B2349             0189*   ;   the fractional portiion of the inputs are truncated
0B2349             0190*   ;   leaving only the 16-bit integer portion
0B2349             0191*   ; prerequisites: vdu_buff_select
0B2349             0192*   vdu_plot_bmp168:
0B2349             0193*   ; populate in the reverse of normal to keep the
0B2349             0194*   ; inputs from stomping on each other
0B2349 ED 53 67 23 0195*       ld (@y0-1),de
       0B          
0B234E ED 43 65 23 0196*       ld (@x0-1),bc
       0B          
0B2353 3E ED       0197*       ld a,plot_bmp+dr_abs_fg ; 0xED
0B2355 32 65 23 0B 0198*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B2359 21 64 23 0B 0199*   	ld hl,@cmd
0B235D 01 06 00 00 0200*   	ld bc,@end-@cmd
0B2361 5B DF       0201*   	rst.lil $18
0B2363 C9          0202*   	ret
0B2364 19          0203*   @cmd:   db 25
0B2365 ED          0204*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B2366 00 00       0205*   @x0: 	dw 0x0000
0B2368 00 00       0206*   @y0: 	dw 0x0000
0B236A             0207*   @end:  ; no padding required b/c we shifted de right
0B236A             0208*   
0B236A             0209*   ; draw a filled rectangle
0B236A             0210*   vdu_plot_rf:
0B236A ED 43 91 23 0211*       ld (@x0),bc
       0B          
0B236F ED 53 93 23 0212*       ld (@y0),de
       0B          
0B2374 DD 22 97 23 0213*       ld (@x1),ix
       0B          
0B2379 FD 22 99 23 0214*       ld (@y1),iy
       0B          
0B237E 3E 19       0215*       ld a,25 ; we have to reload the 2nd plot command
0B2380 32 95 23 0B 0216*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B2384 21 8F 23 0B 0217*   	ld hl,@cmd0
0B2388 01 0C 00 00 0218*   	ld bc,@end-@cmd0
0B238C 5B DF       0219*   	rst.lil $18
0B238E C9          0220*       ret
0B238F 19          0221*   @cmd0:  db 25 ; plot
0B2390 04          0222*   @arg0:  db plot_sl_both+mv_abs
0B2391 00 00       0223*   @x0:    dw 0x0000
0B2393 00 00       0224*   @y0:    dw 0x0000
0B2395 19          0225*   @cmd1:  db 25 ; plot
0B2396 65          0226*   @arg1:  db plot_rf+dr_abs_fg
0B2397 00 00       0227*   @x1:    dw 0x0000
0B2399 00 00       0228*   @y1:    dw 0x0000
0B239B 00          0229*   @end:   db 0x00 ; padding
0B239C             0230*   
0B239C             0231*   ; draw a filled circle
0B239C             0232*   vdu_plot_cf:
0B239C ED 43 C3 23 0233*       ld (@x0),bc
       0B          
0B23A1 ED 53 C5 23 0234*       ld (@y0),de
       0B          
0B23A6 DD 22 C9 23 0235*       ld (@x1),ix
       0B          
0B23AB FD 22 CB 23 0236*       ld (@y1),iy
       0B          
0B23B0 3E 19       0237*       ld a,25 ; we have to reload the 2nd plot command
0B23B2 32 C7 23 0B 0238*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B23B6 21 C1 23 0B 0239*   	ld hl,@cmd0
0B23BA 01 0C 00 00 0240*   	ld bc,@end-@cmd0
0B23BE 5B DF       0241*   	rst.lil $18
0B23C0 C9          0242*       ret
0B23C1 19          0243*   @cmd0:  db 25 ; plot
0B23C2 04          0244*   @arg0:  db plot_sl_both+mv_abs
0B23C3 00 00       0245*   @x0:    dw 0x0000
0B23C5 00 00       0246*   @y0:    dw 0x0000
0B23C7 19          0247*   @cmd1:  db 25 ; plot
0B23C8 9D          0248*   @arg1:  db plot_cf+dr_abs_fg
0B23C9 00 00       0249*   @x1:    dw 0x0000
0B23CB 00 00       0250*   @y1:    dw 0x0000
0B23CD 00          0251*   @end:   db 0x00 ; padding
0B23CE             0252*   
0B23CE             0253*   ; VDU 25, mode, x; y;: PLOT command
0B23CE             0254*   ; inputs: a=mode, ix=x0, iy=y0
0B23CE             0255*   plot:
0B23CE 32 E8 23 0B 0256*       ld (@mode),a
0B23D2 DD 22 E9 23 0257*       ld (@x0),ix
       0B          
0B23D7 FD 22 EB 23 0258*       ld (@y0),iy
       0B          
0B23DC 21 E7 23 0B 0259*   	ld hl,@cmd
0B23E0 01 06 00 00 0260*   	ld bc,@end-@cmd
0B23E4 5B DF       0261*   	rst.lil $18
0B23E6 C9          0262*   	ret
0B23E7 19          0263*   @cmd:   db 25
0B23E8 00          0264*   @mode:  db 0
0B23E9 00 00       0265*   @x0: 	dw 0
0B23EB 00 00       0266*   @y0: 	dw 0
0B23ED 00          0267*   @end:   db 0 ; padding
0B23EE             0268*   
0B23EE             0269*   ; VDU 5: Write text at graphics cursor
0B23EE             0270*   ; inputs: hl = pointer to text, ix=x0, iy=y0
0B23EE             0271*   ; prerequisites: gcol foreground set, VDU 5 set
0B23EE             0272*   plot_text:
0B23EE E5          0273*       push hl ; save text pointer
0B23EF             0274*   ; move graphics cursor to x0, y0
0B23EF 3E 44       0275*       ld a,plot_pt+mv_abs
0B23F1 CD CE 23 0B 0276*       call plot
0B23F5             0277*   ; write text
0B23F5 E1          0278*       pop hl ; restore text pointer
0B23F6 CD 30 02 0B 0279*       call printString
0B23FA C9          0280*       ret
0B23FB             0029    
0B23FB             0030    ; SHAWN'S INCLUDES
0B23FB             0031    	INCLUDE	"strings24.asm"
0B23FB             0001*   ;------------------------------------------------------------------------
0B23FB             0002*   ;  strings24.asm
0B23FB             0003*   ;
0B23FB             0004*   ; 24-bit native ez80 strings routines for numerical processing
0B23FB             0005*   ;  Copyright (c) Shawn Sijnstra 2024
0B23FB             0006*   ;  MIT license
0B23FB             0007*   ;------------------------------------------------------------------------
0B23FB             0008*   
0B23FB             0009*   ;Print signed value in HLU in decimal with leading 0s removed
0B23FB             0010*   ; and postpended with a minus sign if was negative
0B23FB             0011*   ; Uses HLU, DEU, BCU
0B23FB             0012*   print_HLU_s24:
0B23FB CD 0E 08 0B 0013*   	call hlu_abs
0B23FF F5          0014*   	push af ; save the sign and zero flags
0B2400 CD 0B 24 0B 0015*   	call print_HLU_u24
0B2404 F1          0016*   	pop af
0B2405 F0          0017*   	ret p ; HLU was positive so nothig more to do
0B2406 3E 2D       0018*   	ld a,'-'
0B2408 5B D7       0019*   	rst.lil 10h
0B240A C9          0020*   	ret
0B240B             0021*   
0B240B             0022*   ;------------------------------------------------------------------------
0B240B             0023*   ;Full print and buffer routine so you can adjust behaviour
0B240B             0024*   ; Double-Dabble AKA shift-and-add-3 algorithm
0B240B             0025*   ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B240B             0026*   ;Print value in HLU in decimal with leading 0s removed
0B240B             0027*   ; Uses HLU, DEU, BCU
0B240B             0028*   ;------------------------------------------------------------------------
0B240B             0029*   
0B240B             0030*   print_HLU_u24:
0B240B 22 E8 24 0B 0031*   	ld	(hex_temp),hl
0B240F 06 08       0032*   	ld	b,8	;8 digits max here with 24 bit unsigned
0B2411 11 EB 24 0B 0033*   	ld	de,outbuf
0B2415 D5          0034*   	push	de
0B2416 21 07 00 00 0035*   	ld	hl,7
0B241A 19          0036*   	add	hl,de
0B241B E5          0037*   	push	hl
0B241C D1          0038*   	pop	de	;copy HLU to DEU
0B241D AF          0039*   	xor	a
0B241E             0040*   _pde_u_zerobuf:
0B241E 77          0041*   	ld	(hl),a	;zero out the output
0B241F 2B          0042*   	dec	hl
0B2420 10 FC       0043*   	djnz	_pde_u_zerobuf
0B2422             0044*   
0B2422 0E 18       0045*   	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B2424             0046*   _bcd_Convert:
0B2424             0047*   
0B2424 21 E8 24 0B 0048*   	ld hl,hex_temp
0B2428             0049*   ;
0B2428 CB 26       0050*   	sla (hl)
0B242A 23          0051*   	inc hl
0B242B CB 16       0052*   	rl (hl)
0B242D 23          0053*   	inc hl
0B242E CB 16       0054*   	rl (hl)		;24 bits rolled right
0B2430             0055*   
0B2430             0056*   
0B2430 06 08       0057*           ld	b,8	;8 digits max for 24 bit decimal output
0B2432 D5          0058*   	push	de
0B2433 E1          0059*   	pop	hl
0B2434             0060*   
0B2434             0061*   _bcd_Add3:
0B2434 7E          0062*   	ld	a,(hl)
0B2435 8F          0063*   	adc	a
0B2436 27          0064*           daa		;this is add 3 after shifting left; i.e. add 6.
0B2437 FE 10       0065*   	cp	10h	;did we roll over nibble?
0B2439 3F          0066*   	ccf
0B243A CB A7       0067*   	res	4,a
0B243C             0068*   
0B243C 77          0069*           ld (hl),a
0B243D 2B          0070*   	dec	hl
0B243E 10 F4       0071*           djnz	_bcd_Add3	;loop for decimal digits
0B2440 0D          0072*           dec c
0B2441 20 E1       0073*           jr nz, _bcd_Convert	;loop around
0B2443             0074*   
0B2443             0075*   
0B2443 E1          0076*   	pop	hl
0B2444 E5          0077*   	push	hl
0B2445 06 07       0078*           ld	b,8-1		;one less than total in case output is '0'
0B2447             0079*   _pde_u_make_ascii:
0B2447 7E          0080*   	ld	a,(hl)
0B2448 B7          0081*   	or	a
0B2449 20 05       0082*   	jr	nz,_pde_u_make_ascii2
0B244B 36 20       0083*   	ld	(hl),' '
0B244D 23          0084*   	inc	hl
0B244E 10 F7       0085*   	djnz	_pde_u_make_ascii
0B2450             0086*   _pde_u_make_ascii2:
0B2450 04          0087*   	inc	b
0B2451             0088*   _pde_u_make_ascii3:
0B2451 7E          0089*   	ld	a,(hl)
0B2452 F6 30       0090*   	or	30h
0B2454 77          0091*   	ld	(hl),a
0B2455 23          0092*   	inc	hl
0B2456 10 F9       0093*   	djnz	_pde_u_make_ascii3
0B2458             0094*   
0B2458 E1          0095*   	pop	hl
0B2459 06 08       0096*   	ld	b,8
0B245B             0097*   _pde_u_final_out:
0B245B 7E          0098*   	ld	a,(hl)
0B245C 23          0099*   	inc	hl
0B245D FE 20       0100*   	cp	' '
0B245F 28 02       0101*   	jr	z,_pde_u_final_out_strip
0B2461 5B D7       0102*   	rst.lil	10h
0B2463             0103*   _pde_u_final_out_strip:
0B2463 10 F6       0104*   	djnz	_pde_u_final_out
0B2465 C9          0105*   	ret
0B2466             0106*   
0B2466             0107*   ;------------------------------------------------------------------------
0B2466             0108*   ; is_digit
0B2466             0109*   ; C flag set if A is a digit
0B2466             0110*   ; preserves all registers
0B2466             0111*   ;------------------------------------------------------------------------
0B2466             0112*   is_digit:
0B2466 FE 30       0113*   	cp	'0'
0B2468 3F          0114*   	ccf
0B2469 D0          0115*   	ret	nc	;less that '0'
0B246A FE 3A       0116*   	cp	'9' + 1
0B246C C9          0117*   	ret
0B246D             0118*   
0B246D             0119*   
0B246D             0120*   ;------------------------------------------------------------------------
0B246D             0121*   ; char2hex
0B246D             0122*   ; Input: ASCII nibble in A
0B246D             0123*   ; Returns: if valid nibble value in A; else 0FFh in A
0B246D             0124*   ;------------------------------------------------------------------------
0B246D             0125*   char2hex:
0B246D FE 30       0126*   	CP	'0'
0B246F 38 1D       0127*   	JR	C, char_not_hex
0B2471 FE 3A       0128*   	CP	'9' + 1
0B2473 30 03       0129*   	JR	NC, char_not_09
0B2475 D6 30       0130*   	sub	'0'
0B2477 C9          0131*   	ret
0B2478             0132*   
0B2478             0133*   char_not_09:
0B2478             0134*   	; char is not 0 to 9. Try upper case
0B2478 FE 41       0135*   	CP	'A'
0B247A 38 12       0136*   	JR	C, char_not_hex
0B247C FE 47       0137*   	CP	'F' + 1
0B247E 30 03       0138*   	JR	NC, char_not_AF
0B2480 D6 37       0139*   	sub	'A'-10
0B2482 C9          0140*   	ret
0B2483             0141*   
0B2483             0142*   char_not_AF:
0B2483             0143*   	; char is not upper case A-F. Try lower
0B2483 FE 61       0144*   	CP	'a'
0B2485 38 07       0145*   	JR	C, char_not_hex
0B2487 FE 67       0146*   	CP	'f' + 1
0B2489 30 03       0147*   	JR	NC, char_not_hex
0B248B D6 57       0148*   	sub	'a' - 10
0B248D C9          0149*   	RET
0B248E             0150*   
0B248E             0151*   char_not_hex:
0B248E 3E FF       0152*    	ld	a,0FFh	;return -1 for not a valid hex digit
0B2490 C9          0153*   	RET
0B2491             0154*   
0B2491             0155*   ;------------------------------------------------------------------------
0B2491             0156*   ;  newline
0B2491             0157*   ;  Output CR+LF; all registers preserved
0B2491             0158*   ;------------------------------------------------------------------------
0B2491             0159*   newline:
0B2491 F5          0160*          push   AF
0B2492 3E 0D       0161*          LD     A, 13
0B2494 5B D7       0162*          RST.LIL    10h
0B2496 3E 0A       0163*          LD     A, 10
0B2498 5B D7       0164*          RST.LIL    10h
0B249A F1          0165*          POP    AF
0B249B C9          0166*          RET
0B249C             0167*   
0B249C             0168*   ;------------------------------------------------------------------------
0B249C             0169*   ;  put_nibble
0B249C             0170*   ;  Output a single hex nibble in A
0B249C             0171*   ;  All registers preserved
0B249C             0172*   ;------------------------------------------------------------------------
0B249C             0173*   put_nibble:
0B249C F5          0174*   	push   AF
0B249D C6 90       0175*   	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B249F 27          0176*   	daa
0B24A0 CE 40       0177*   	adc    a,040h
0B24A2 27          0178*   	daa
0B24A3 5B D7       0179*   	RST.LIL    10h	;output character in A
0B24A5 F1          0180*   	pop    AF
0B24A6 C9          0181*   	ret
0B24A7             0182*   
0B24A7             0183*   ;------------------------------------------------------------------------
0B24A7             0184*   ;  print_A
0B24A7             0185*   ;  Output the 8-bit hex number A
0B24A7             0186*   ;  All registers preserved
0B24A7             0187*   ;------------------------------------------------------------------------
0B24A7             0188*   print_A:
0B24A7 F5          0189*   	push 	AF
0B24A8 F5          0190*   	push 	AF	;save for second nibble
0B24A9 0F          0191*   	rrca
0B24AA 0F          0192*   	rrca
0B24AB 0F          0193*   	rrca
0B24AC 0F          0194*   	rrca
0B24AD E6 0F       0195*   	and	0Fh	;first nibble
0B24AF CD 9C 24 0B 0196*   	call	put_nibble
0B24B3 F1          0197*   	pop 	AF
0B24B4 E6 0F       0198*   	and	0Fh	;second nibble
0B24B6 CD 9C 24 0B 0199*   	call	put_nibble
0B24BA F1          0200*   	pop 	AF
0B24BB C9          0201*   	ret
0B24BC             0202*   
0B24BC             0203*   ;------------------------------------------------------------------------
0B24BC             0204*   ;  print_HLU_hex
0B24BC             0205*   ;  Output the 24-bit hex number HLU; other registers preserved
0B24BC             0206*   ;------------------------------------------------------------------------
0B24BC             0207*   print_HLU_hex:
0B24BC F5          0208*          push   AF
0B24BD 22 E8 24 0B 0209*          ld     (hex_temp),hl
0B24C1 3A EA 24 0B 0210*          ld     a,(hex_temp+2)
0B24C5 CD A7 24 0B 0211*          call   print_A
0B24C9 3A E9 24 0B 0212*          ld     a,(hex_temp+1)
0B24CD CD A7 24 0B 0213*          call   print_A
0B24D1 3A E8 24 0B 0214*          ld     a,(hex_temp)
0B24D5 CD A7 24 0B 0215*          call   print_A
0B24D9 F1          0216*          POP    AF
0B24DA C9          0217*          RET
0B24DB             0218*   
0B24DB             0219*   ;------------------------------------------------------------------------
0B24DB             0220*   ;  puts
0B24DB             0221*   ;  Output a zero-terminated string whose address is in HL; all
0B24DB             0222*   ;  registers preserved.
0B24DB             0223*   ;------------------------------------------------------------------------
0B24DB             0224*   puts:
0B24DB F5          0225*          push   AF
0B24DC C5          0226*          push   BC
0B24DD 01 00 00 00 0227*          ld     BC, 0                ; Set to 0, so length ignored...
0B24E1 3E 00       0228*          ld     A, 0                 ; Use character in A as delimiter
0B24E3 5B DF       0229*          RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B24E5 C1          0230*          pop    BC
0B24E6 F1          0231*          pop    AF
0B24E7 C9          0232*          ret
0B24E8             0233*   
0B24E8             0234*   ;------------------------------------------------------------------------
0B24E8             0235*   ; Data area
0B24E8             0236*   ; Storage for 24 bit conversion
0B24E8             0237*   ;------------------------------------------------------------------------
0B24E8             0238*   hex_temp:
0B24E8 00 00 00    0239*          dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B24EB             0240*   
0B24EB             0241*   outbuf:
0B24EB 31 36 37 37 0242*   	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B24F4             0032    
0B24F4             0033    ; BASIC FLOATING POINT FUNCTIONS
0B24F4             0034        include "mathfpp.inc"
0B24F4             0001*       include "basic/ram.asm"
0B24F4             0001**  ;
0B24F4             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B24F4             0003**  ;		RAM Module for BBC Basic Interpreter
0B24F4             0004**  ;		For use with Version 2.0 of BBC BASIC
0B24F4             0005**  ;		Standard CP/M Distribution Version
0B24F4             0006**  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0B24F4             0007**  ; Modified By:	Dean Belfield
0B24F4             0008**  ; Created:	12/05/2023
0B24F4             0009**  ; Last Updated:	26/06/2023
0B24F4             0010**  ;
0B24F4             0011**  ; Modinfo:
0B24F4             0012**  ; 06/06/2023:	Modified to run in ADL mode
0B24F4             0013**  ; 26/06/2023:	Added temporary stores R0 and R1
0B24F4             0014**  
0B24F4             0015**  			.ASSUME	ADL = 1
0B24F4             0016**  
0B24F4             0017**  			; DEFINE	LORAM, SPACE = ROM
0B24F4             0018**  			; SEGMENT LORAM
0B24F4             0019**  
0B24F4             0020**  			; XDEF	ACCS
0B24F4             0021**  			; XDEF	BUFFER
0B24F4             0022**  			; XDEF	STAVAR
0B24F4             0023**  			; XDEF	DYNVAR
0B24F4             0024**  			; XDEF	FNPTR
0B24F4             0025**  			; XDEF	PROPTR
0B24F4             0026**  			; XDEF	PAGE_
0B24F4             0027**  			; XDEF	TOP
0B24F4             0028**  			; XDEF	LOMEM
0B24F4             0029**  			; XDEF 	FREE
0B24F4             0030**  			; XDEF	HIMEM
0B24F4             0031**  			; XDEF	LINENO
0B24F4             0032**  			; XDEF	TRACEN
0B24F4             0033**  			; XDEF	AUTONO
0B24F4             0034**  			; XDEF	ERRTRP
0B24F4             0035**  			; XDEF	ERRTXT
0B24F4             0036**  			; XDEF	DATPTR
0B24F4             0037**  			; XDEF	ERL
0B24F4             0038**  			; XDEF	ERRLIN
0B24F4             0039**  			; XDEF	RANDOM
0B24F4             0040**  			; XDEF	COUNT
0B24F4             0041**  			; XDEF	WIDTH
0B24F4             0042**  			; XDEF	ERR
0B24F4             0043**  			; XDEF	LISTON
0B24F4             0044**  			; XDEF	INCREM
0B24F4             0045**  
0B24F4             0046**  			; XDEF	FLAGS
0B24F4             0047**  			; XDEF	OSWRCHPT
0B24F4             0048**  			; XDEF	OSWRCHCH
0B24F4             0049**  			; XDEF	OSWRCHFH
0B24F4             0050**  			; XDEF	KEYDOWN
0B24F4             0051**  			; XDEF	KEYASCII
0B24F4             0052**  			; XDEF	KEYCOUNT
0B24F4             0053**  
0B24F4             0054**  			; XDEF	R0
0B24F4             0055**  			; XDEF	R1
0B24F4             0056**  
0B24F4             0057**  			; XDEF	RAM_START
0B24F4             0058**  			; XDEF	RAM_END
0B24F4             0059**  			; XDEF	USER
0B24F4             0060**  
0B24F4 FF FF FF FF 0061**  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
0B2500             0062**  RAM_START:
0B2500             0063**  ;
0B2500             0064**  ACCS:			DS		256             ; String Accumulator
0B2600             0065**  BUFFER:			DS		256             ; String Input Buffer
0B2700             0066**  STAVAR:			DS	 	27*4            ; Static Variables
0B276C             0067**  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
0B280E             0068**  FNPTR:  		DS    		3               ; Dynamic Function Pointers
0B2811             0069**  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
0B2814             0070**  ;
0B2814             0071**  PAGE_:   		DS		3               ; Start of User Program
0B2817             0072**  TOP:    		DS		3               ; First Location after User Program
0B281A             0073**  LOMEM:  		DS		3               ; Start of Dynamic Storage
0B281D             0074**  FREE:   		DS		3               ; First Free Space Byte
0B2820             0075**  HIMEM:  		DS		3               ; First Protected Byte
0B2823             0076**  ;
0B2823             0077**  LINENO: 		DS		3               ; Line Number
0B2826             0078**  TRACEN:			DS		3               ; Trace Flag
0B2829             0079**  AUTONO:			DS		3               ; Auto Flag
0B282C             0080**  ERRTRP:			DS		3               ; Error Trap
0B282F             0081**  ERRTXT:			DS		2               ; Error Message Pointer
0B2831             0082**  DATPTR:			DS		2               ; Data Pointer
0B2833             0083**  ERL:			DS		2               ; Error Line
0B2835             0084**  ERRLIN:			DS		3               ; The "ON ERROR" Line
0B2838             0085**  RANDOM:			DS		5               ; Random Number
0B283D             0086**  COUNT:			DS		1               ; Print Position
0B283E             0087**  WIDTH:			DS		1               ; Print Width
0B283F             0088**  ERR:			DS		1               ; Error Number
0B2840             0089**  LISTON:			DS		1               ; LISTO (bottom nibble)
0B2841             0090**  							; - BIT 0: If set, output a space after the line number
0B2841             0091**  							; - BIT 1: If set, then indent FOR/NEXT loops
0B2841             0092**  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
0B2841             0093**  							; - BIT 3: If set, then output to buffer for *EDIT
0B2841             0094**  							; OPT FLAG (top nibble)
0B2841             0095**  							; - BIT 4: If set, then list whilst assembling
0B2841             0096**  							; - BIT 5: If set, then assembler errors are reported
0B2841             0097**  							; - BIT 6: If set, then place the code starting at address pointed to by O%
0B2841             0098**  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B2841             0099**  INCREM:			DS		1               ; Auto-Increment Value
0B2842             0100**  ;
0B2842             0101**  ; Extra Agon-implementation specific system variables
0B2842             0102**  ;
0B2842             0103**  FLAGS:			DS		1		; Miscellaneous flags
0B2843             0104**  							; - BIT 7: Set if ESC pressed
0B2843             0105**  							; - BIT 6: Set to disable ESC
0B2843             0106**  OSWRCHPT:		DS		2		; Pointer for *EDIT
0B2845             0107**  OSWRCHCH:		DS		1		; Channel of OSWRCH
0B2846             0108**  							; - 0: Console
0B2846             0109**  							; - 1: File
0B2846             0110**  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
0B2847             0111**  KEYDOWN:		DS		1		; Keydown flag
0B2848             0112**  KEYASCII:		DS		1		; ASCII code of pressed key
0B2849             0113**  KEYCOUNT:		DS		1		; Counts every time a key is pressed
0B284A             0114**  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
0B284D             0115**  R1:			DS		3		;
0B2850             0116**  ;
0B2850             0117**  ; This must be at the end
0B2850             0118**  ;
0B2850             0119**  RAM_END:
0B2850 FF FF FF FF 0120**  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B2900             0121**  USER:							; Must be aligned on a page boundary
0B2900             0122**  
0B2900             0002*       include "basic/eval.asm"
0B2900             0001**  
0B2900             0002**  ; ========================================
0B2900             0003**  ; FROM eval.asm
0B2900             0004**  ; ----------------------------------------
0B2900             0005**  
0B2900             0006**  ;
0B2900             0007**  ; Title:	BBC Basic Interpreter - Z80 version
0B2900             0008**  ;		Expression Evaluation & Arithmetic Module - "EVAL"
0B2900             0009**  ; Author:	(C) Copyright  R.T.Russell  1984
0B2900             0010**  ; Modified By:	Dean Belfield
0B2900             0011**  ; Created:	12/05/2023
0B2900             0012**  ; Last Updated:	17/08/2023
0B2900             0013**  ;
0B2900             0014**  ; Modinfo:
0B2900             0015**  ; 07/06/2023:	Modified to run in ADL mode
0B2900             0016**  ; 26/06/2023:	Fixed HEX and HEXSTR
0B2900             0017**  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
0B2900             0018**  ; 17/08/2023:	Added binary constants
0B2900             0019**  
0B2900             0020**  			; .ASSUME	ADL = 1
0B2900             0021**  
0B2900             0022**  			; include "ram.asm"
0B2900             0023**  
0B2900             0024**  			; INCLUDE	"equs.inc"
0B2900             0025**  			; INCLUDE "macros.inc"
0B2900             0026**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B2900             0027**  
0B2900             0028**  			; include "fpp.asm"
0B2900             0029**  			; include "snippets.asm"
0B2900             0030**  
0B2900             0031**  			; SEGMENT CODE
0B2900             0032**  
0B2900             0033**  ; 			XDEF	EXPR
0B2900             0034**  ; 			XDEF	EXPRN
0B2900             0035**  ; 			XDEF	EXPRI
0B2900             0036**  ; 			XDEF	EXPRS
0B2900             0037**  ; 			XDEF	ITEMI
0B2900             0038**  ; 			XDEF	LOADN
0B2900             0039**  ; 			XDEF	LOAD4
0B2900             0040**  ; 			XDEF	CONS
0B2900             0041**  ; 			XDEF	LOADS
0B2900             0042**  ; 			XDEF	SFIX
0B2900             0043**  ; 			XDEF	VAL0
0B2900             0044**  ; 			XDEF	SEARCH
0B2900             0045**  ; 			XDEF	SWAP
0B2900             0046**  ; 			XDEF	TEST
0B2900             0047**  ; 			XDEF	DECODE
0B2900             0048**  ; 			XDEF	HEXSTR
0B2900             0049**  ; 			XDEF	STR
0B2900             0050**  ; 			XDEF	ZERO
0B2900             0051**  ; 			XDEF	PUSHS
0B2900             0052**  ; 			XDEF	POPS
0B2900             0053**  ; 			XDEF	COMMA
0B2900             0054**  ; 			XDEF	BRAKET
0B2900             0055**  ; 			XDEF	NXT
0B2900             0056**  ; 			XDEF	COUNT0
0B2900             0057**  
0B2900             0058**  ; 			XREF	ADVAL
0B2900             0059**  ; 			XREF	FN
0B2900             0060**  ; 			XREF	POINT
0B2900             0061**  ; 			XREF	USR
0B2900             0062**  ; 			XREF	SYNTAX
0B2900             0063**  ; 			XREF	ERROR_
0B2900             0064**  ; 			XREF	CHECK
0B2900             0065**  ; 			XREF	GETVAR
0B2900             0066**  ; 			XREF	LISTON
0B2900             0067**  ; 			XREF	RANGE
0B2900             0068**  ; 			XREF	FPP
0B2900             0069**  ; 			XREF	GETCSR
0B2900             0070**  ; 			XREF	CHANEL
0B2900             0071**  ; 			XREF	OSSTAT
0B2900             0072**  ; 			XREF	OSBGET
0B2900             0073**  ; 			XREF	LOMEM
0B2900             0074**  ; 			XREF	HIMEM
0B2900             0075**  ; 			XREF	PAGE_
0B2900             0076**  ; 			XREF	TOP
0B2900             0077**  ; 			XREF	ERL
0B2900             0078**  ; 			XREF	ERR
0B2900             0079**  ; 			XREF	COUNT
0B2900             0080**  ; 			XREF	OSOPEN
0B2900             0081**  ; 			XREF	GETEXT
0B2900             0082**  ; 			XREF	GETPTR
0B2900             0083**  ; 			XREF	GETIME
0B2900             0084**  ; 			XREF	GETIMS
0B2900             0085**  ; 			XREF	LEXAN2
0B2900             0086**  ; 			XREF	RANDOM
0B2900             0087**  ; 			XREF	STORE5
0B2900             0088**  ; 			XREF	GETSCHR
0B2900             0089**  ; 			XREF	OSRDCH
0B2900             0090**  ; 			XREF	OSKEY
0B2900             0091**  ; 			XREF	INKEY1
0B2900             0092**  ; 			XREF	EXTERR
0B2900             0093**  ;
0B2900             0094**  ; BINARY FLOATING POINT REPRESENTATION:
0B2900             0095**  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B2900             0096**  ;     8 BIT EXCESS-128 SIGNED EXPONENT
0B2900             0097**  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B2900             0098**  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B2900             0099**  ;
0B2900             0100**  ; BINARY INTEGER REPRESENTATION:
0B2900             0101**  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B2900             0102**  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B2900             0103**  ;
0B2900             0104**  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B2900             0105**  ;                             EXPONENT - C
0B2900             0106**  ;
0B2900             0107**  
0B2900             0108**  ;
0B2900             0109**  ; Table of addresses for functions
0B2900             0110**  ;
0B2900             0111**  FUNTOK:			EQU	8DH			; First token number
0B2900             0112**  ;
0B2900 CA 2F 0B    0113**  FUNTBL:			DW24	DECODE			; Line number
0B2903 1A 2D 0B    0114**  			DW24	OPENIN			; OPENIN ; opening a file, we won't be using
0B2906 1D 2D 0B    0115**  			DW24	PTR_EV			; PTR ; related to file handling, we won't be using
0B2909 AB 29 0B    0116**  			DW24	PAGE			; PAGE
0B290C 1E 2D 0B    0117**  			DW24	TIMEV_EV			; TIME ; related to time handling, we won't be using
0B290F CB 2C 0B    0118**  			DW24	LOMEMV_EV			; LOMEM
0B2912 D5 2C 0B    0119**  			DW24	HIMEMV_EV			; HIMEM
0B2915 5B 2D 0B    0120**  			DW24	ABSV_EV			; ABS
0B2918 97 2D 0B    0121**  			DW24	ACS_EV			; ACS
0B291B 23 45 0B    0122**  			DW24	ADVAL			; ADVAL ; IN sorry.asm, don't need
0B291E B4 2C 0B    0123**  			DW24	ASC			; ASC
0B2921 8F 2D 0B    0124**  			DW24	ASN_EV			; ASN
0B2924 93 2D 0B    0125**  			DW24	ATN_EV			; ATN
0B2927 B0 2C 0B    0126**  			DW24	BGET			; BGET ; get a byte from a file, we won't be using
0B292A 7B 2D 0B    0127**  			DW24	COS_EV			; COS
0B292D 06 2D 0B    0128**  			DW24	COUNTV			; COUNT
0B2930 63 2D 0B    0129**  			DW24	DEG_EV			; DEG
0B2933 FA 2C 0B    0130**  			DW24	ERLV			; ERL
0B2936 00 2D 0B    0131**  			DW24	ERRV			; ERR
0B2939 BC 2D 0B    0132**  			DW24	EVAL_			; EVAL
0B293C 83 2D 0B    0133**  			DW24	EXP_EV			; EXP
0B293F 1C 2D 0B    0134**  			DW24	EXT_EV			; EXT ; related to file handling, we won't be using
0B2942 73 30 0B    0135**  			DW24	ZERO			; FALSE
0B2945 A4 00 00    0136**  			DW24	FN			; FN
0B2948 B2 2C 0B    0137**  			DW24	GET			; GET ; reading from keyboard, we won't be using
0B294B B1 2C 0B    0138**  			DW24	INKEY			; INKEY ; reading from keyboard, we won't be using
0B294E 6A 2E 0B    0139**  			DW24	INSTR			; INSTR(
0B2951 6F 2D 0B    0140**  			DW24	INT_EV_			; INT
0B2954 C4 2C 0B    0141**  			DW24	LEN			; LEN
0B2957 87 2D 0B    0142**  			DW24	LN_EV			; LN
0B295A 8B 2D 0B    0143**  			DW24	LOG_EV			; LOG
0B295D 5F 2D 0B    0144**  			DW24	NOTK_EV			; NOT
0B2960 19 2D 0B    0145**  			DW24	OPENUP			; OPENUP ; related to file handling, we won't be using
0B2963 18 2D 0B    0146**  			DW24	OPENOT			; OPENOUT ; related to file handling, we won't be using
0B2966 57 2D 0B    0147**  			DW24	PI_EV			; PI
0B2969 21 45 0B    0148**  			DW24	POINT			; POINT( ; in agon_graphics.asm we won't be using
0B296C AD 2C 0B    0149**  			DW24	POS			; POS ; related to cursor position, we won't be using
0B296F 67 2D 0B    0150**  			DW24	RAD_EV			; RAD
0B2972 F0 2D 0B    0151**  			DW24	RND			; RND
0B2975 6B 2D 0B    0152**  			DW24	SGN_EV			; SGN
0B2978 7F 2D 0B    0153**  			DW24	SIN_EV			; SIN
0B297B 73 2D 0B    0154**  			DW24	SQR_EV			; SQR
0B297E 77 2D 0B    0155**  			DW24	TAN_EV			; TAN
0B2981 E9 2C 0B    0156**  			DW24	TOPV			; TO(P)
0B2984 4C 2D 0B    0157**  			DW24	FOR_EV			; FOR
0B2987 22 45 0B    0158**  			DW24	USR			; USR ; in exec.asm
0B298A AD 2D 0B    0159**  			DW24	VAL_EV			; VAL
0B298D AE 2C 0B    0160**  			DW24	VPOS			; VPOS ; related to cursor position, we won't be using
0B2990 FE 2E 0B    0161**  			DW24	CHRS			; CHRS ; reading from keyboard, we won't be using
0B2993 FF 2E 0B    0162**  			DW24	GETS			; GETS ; reading from keyboard, we won't be using
0B2996 01 2F 0B    0163**  			DW24	INKEYS			; INKEYS ; reading from keyboard, we won't be using
0B2999 45 2F 0B    0164**  			DW24	LEFTS			; LEFTS(
0B299C 0D 2F 0B    0165**  			DW24	MIDS			; MIDS(
0B299F 65 2F 0B    0166**  			DW24	RIGHTS			; RIGHTS(
0B29A2 2E 30 0B    0167**  			DW24	STRS			; STR$
0B29A5 86 2F 0B    0168**  			DW24	STRING_			; STRINGS(
0B29A8 AF 2C 0B    0169**  			DW24	EOF			; EOF ; reading from file, we won't be using
0B29AB             0170**  
0B29AB C9          0171**  PAGE: ret ; stub function for an item in FUNTBL which doesn't exist
0B29AC             0172**  ;
0B29AC             0173**  FUNTBL_END:		EQU	$
0B29AC             0174**  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0B29AC             0175**  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0B29AC             0176**  ;
0B29AC             0177**  ANDK:			EQU     80H
0B29AC             0178**  DIVK:			EQU     81H
0B29AC             0179**  EORK:			EQU     82H
0B29AC             0180**  MODK:			EQU     83H
0B29AC             0181**  ORK:			EQU     84H
0B29AC             0182**  ;
0B29AC 37 2D 0B    0183**  SOPTBL:			DW24	SLE			; <= (STRING)
0B29AF 40 2D 0B    0184**  			DW24	SNE			; <>
0B29B2 30 2D 0B    0185**  			DW24	SGE			; >=
0B29B5 21 2D 0B    0186**  			DW24	SLT			; <
0B29B8 47 2D 0B    0187**  			DW24	SEQ			; =
0B29BB 28 2D 0B    0188**  			DW24	SGT			; >
0B29BE             0189**  ;
0B29BE             0190**  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0B29BE             0191**  ;     Expression type is returned in A'F':
0B29BE             0192**  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0B29BE             0193**  ;         String - A' bit 7=1, F' sign bit set.
0B29BE             0194**  ; Floating-point or integer result returned in HLH'L'C
0B29BE             0195**  ; Integer result denoted by C=0 and HLH'L' non-zero.
0B29BE             0196**  ; String result returned in string accumulator, DE set.
0B29BE             0197**  ;
0B29BE             0198**  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0B29BE             0199**  ;               (2) ^
0B29BE             0200**  ;               (3) * / MOD DIV
0B29BE             0201**  ;               (4) + -
0B29BE             0202**  ;               (5) = <> <= >= > <
0B29BE             0203**  ;               (6) AND
0B29BE             0204**  ;               (7) EOR OR
0B29BE             0205**  
0B29BE             0206**  ;
0B29BE             0207**  ; Level 7: EOR and OR
0B29BE             0208**  ;
0B29BE CD D7 29 0B 0209**  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0B29C2 FE 82       0210**  EXPR0A:			CP      EORK            	; Is operator EOR?
0B29C4 28 03       0211**  			JR      Z,EXPR0B		; Yes, so skip to next bit
0B29C6 FE 84       0212**  			CP      ORK			; Is operator OR
0B29C8 C0          0213**  			RET     NZ			; No, so return
0B29C9             0214**  ;
0B29C9 CD 1D 31 0B 0215**  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0B29CD CD D7 29 0B 0216**  			CALL    EXPR1           	; Get second operand
0B29D1 CD 2C 31 0B 0217**  			CALL    DOIT            	; Do the operation
0B29D5 18 EB       0218**  			JR      EXPR0A          	; And continue
0B29D7             0219**  ;
0B29D7             0220**  ; Level 6: AND
0B29D7             0221**  ;
0B29D7 CD EC 29 0B 0222**  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0B29DB FE 80       0223**  EXPR1A:			CP      ANDK			; Is operator AND?
0B29DD C0          0224**  			RET     NZ			; No, so return
0B29DE CD 1D 31 0B 0225**  			CALL    SAVE_EV			; Save first operand
0B29E2 CD EC 29 0B 0226**  			CALL    EXPR2			; Get second operand
0B29E6 CD 2C 31 0B 0227**  			CALL    DOIT			; Do the operation
0B29EA 18 EF       0228**  			JR      EXPR1A			; And continue
0B29EC             0229**  ;
0B29EC             0230**  ; Level 5: Comparisons
0B29EC             0231**  ;
0B29EC CD 5E 2A 0B 0232**  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0B29F0 CD F8 30 0B 0233**  			CALL    RELOP?			; Is it ">", "=" or "<"?
0B29F4 C0          0234**  			RET     NZ			; No, so return
0B29F5 47          0235**  			LD      B,A			; Store the first operator in B
0B29F6 FD 23       0236**  			INC     IY              	; Bump over operator
0B29F8 CD 4F 31 0B 0237**  			CALL    NXT			;
0B29FC CD F8 30 0B 0238**  			CALL    RELOP?          	; Is it a compound operator?
0B2A00 20 09       0239**  			JR      NZ,EXPR2B		; No, so skip next bit
0B2A02 FD 23       0240**  			INC     IY			; Bump over operator
0B2A04 B8          0241**  			CP      B			; Compare with first
0B2A05 CA 00 00 00 0242**  			JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
