PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "calc.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 63 61 6C 63 0001*M     ASCIZ "calc.bin"
       2E 62 69 6E 
       00          
0B000D             0025*  
0B000D FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD 40 1E 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 93 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F             0108*      ; call _skip_spaces ; skip whitespace
0B014F             0109*  
0B014F 7E          0110*      ld a, (hl) ; read first character
0B0150 B7          0111*      or a ; check for end of string
0B0151 C8          0112*      ret z ; return with no carry if not
0B0152             0113*  
0B0152 C5          0114*      push bc ; preserve bc
0B0153             0115*  
0B0153 FE 2D       0116*      cp '-' ; check for negative number
0B0155 C2 5F 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B0159 AF          0118*      xor a ; sign flag to zero
0B015A 32 93 01 0B 0119*      ld (@sign),a ; store sign flag
0B015E 23          0120*      inc hl ; skip '-'
0B015F             0121*  
0B015F             0122*  @loop:
0B015F 7E          0123*      ld a, (hl)
0B0160 D6 30       0124*      sub '0' ; normalise to 0
0B0162 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0164 FE 0A       0126*      cp 10 ; check if >= 10
0B0166 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B0168 E5          0128*      push hl ; stack hl
0B0169 D5          0129*      push de ; ld hl, de
0B016A E1          0130*      pop hl
0B016B E5          0131*      push hl ; ld bc, hl
0B016C C1          0132*      pop bc
0B016D 29          0133*      add hl, hl ; x 2
0B016E 29          0134*      add hl, hl ; x 4
0B016F 09          0135*      add hl, bc ; x 5
0B0170 29          0136*      add hl, hl ; x 10
0B0171 01 00 00 00 0137*      ld bc, 0
0B0175 4F          0138*      ld c, a ; ld bcu, a
0B0176 09          0139*      add hl, bc ; add bcu to hl
0B0177 E5          0140*      push hl ; ld de, hl
0B0178 D1          0141*      pop de
0B0179 E1          0142*      pop hl ; restore hl
0B017A 23          0143*      inc hl
0B017B 18 E2       0144*      jr @loop
0B017D             0145*  
0B017D             0146*  @integer_end:
0B017D C1          0147*      pop bc ; send bc back how she came in
0B017E 3A 93 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0182 3D          0149*      dec a ; check if negative
0B0183 F2 91 01 0B 0150*      jp p,@pos ; positive number
0B0187             0151*  
0B0187             0152*  ; Negate de
0B0187 E5          0153*      push hl ; save text pointer
0B0188 21 00 00 00 0154*      ld hl, 0
0B018C AF          0155*      xor a ; clear carry
0B018D ED 52       0156*      sbc hl, de ; subtract DE from HL
0B018F EB          0157*      ex de, hl ; DE = 0-HL
0B0190 E1          0158*      pop hl ; restore text pointer
0B0191             0159*  
0B0191             0160*  @pos:
0B0191 37          0161*      scf ; we have a valid number so set carry
0B0192 C9          0162*      ret
0B0193             0163*  
0B0193 00          0164*  @sign: db 0 ; sign flag buffer
0B0194             0165*  
0B0194             0166*  
0B0194             0167*  ;------------------------------------------------------------------------
0B0194             0168*  ; Read a number and convert to binary (decimal only)
0B0194             0169*  ; Inputs: hl: Pointer in string buffer
0B0194             0170*  ; Outputs: hl: Updated text pointer
0B0194             0171*  ;         de: Value
0B0194             0172*  ;         a: Terminator (spaces skipped)
0B0194             0173*  ;         f: Carry set if valid number, otherwise reset
0B0194             0174*  ; Destroys: a, d, e, h, l, f
0B0194             0175*  ;------------------------------------------------------------------------
0B0194             0176*  asc_to_s168:
0B0194 3E 01       0177*      ld a,1 ; set sign flag
0B0196 32 53 02 0B 0178*      ld (@sign),a ; store sign flag
0B019A             0179*  
0B019A 11 00 00 00 0180*      ld de, 0 ; initialise de
0B019E ED 53 4B 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A3 ED 53 4F 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01A8             0183*  
0B01A8             0184*      ; call _skip_spaces ; skip whitespace
0B01A8             0185*  
0B01A8 7E          0186*      ld a, (hl) ; read first character
0B01A9 B7          0187*      or a ; check for end of string
0B01AA C8          0188*      ret z ; return with no carry if not
0B01AB             0189*  
0B01AB C5          0190*      push bc ; preserve bc
0B01AC             0191*  
0B01AC FE 2D       0192*      cp '-' ; check for negative number
0B01AE C2 B8 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01B2 AF          0194*      xor a ; sign flag to zero
0B01B3 32 53 02 0B 0195*      ld (@sign),a ; store sign flag
0B01B7 23          0196*      inc hl ; skip '-'
0B01B8             0197*  
0B01B8             0198*  @loop:
0B01B8 7E          0199*      ld a, (hl)
0B01B9             0200*  
0B01B9             0201*  ; chcek for decimal point
0B01B9 FE 2E       0202*      cp '.' ; check for decimal point
0B01BB CA FC 01 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01BF             0204*  
0B01BF             0205*  ; process integer part
0B01BF D6 30       0206*      sub '0' ; normalise to 0
0B01C1 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01C3 FE 0A       0208*      cp 10 ; check if >= 10
0B01C5 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01C7 E5          0210*      push hl ; stack hl
0B01C8 D5          0211*      push de ; ld hl, de
0B01C9 E1          0212*      pop hl
0B01CA E5          0213*      push hl ; ld bc, hl
0B01CB C1          0214*      pop bc
0B01CC 29          0215*      add hl, hl ; x 2
0B01CD 29          0216*      add hl, hl ; x 4
0B01CE 09          0217*      add hl, bc ; x 5
0B01CF 29          0218*      add hl, hl ; x 10
0B01D0 01 00 00 00 0219*      ld bc, 0
0B01D4 4F          0220*      ld c, a ; ld bcu, a
0B01D5 09          0221*      add hl, bc ; add bcu to hl
0B01D6 E5          0222*      push hl ; ld de, hl
0B01D7 D1          0223*      pop de
0B01D8 E1          0224*      pop hl ; restore hl
0B01D9 23          0225*      inc hl
0B01DA 18 DC       0226*      jr @loop
0B01DC             0227*  
0B01DC             0228*  @integer_end:
0B01DC ED 53 4C 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E1             0230*  
0B01E1             0231*  @end:
0B01E1 C1          0232*      pop bc ; send bc back how she came in
0B01E2 ED 5B 4B 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01E7 3A 53 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01EB 3D          0235*      dec a ; check if negative
0B01EC F2 FA 01 0B 0236*      jp p,@pos ; positive number
0B01F0             0237*  
0B01F0             0238*  ; Negate de
0B01F0 E5          0239*      push hl ; save text pointer
0B01F1 21 00 00 00 0240*      ld hl, 0
0B01F5 AF          0241*      xor a ; clear carry
0B01F6 ED 52       0242*      sbc hl, de ; subtract DE from HL
0B01F8 EB          0243*      ex de, hl ; DE = 0-HL
0B01F9 E1          0244*      pop hl ; restore text pointer
0B01FA             0245*  
0B01FA             0246*  @pos:
0B01FA 37          0247*      scf ; we have a valid number so set carry
0B01FB C9          0248*      ret
0B01FC             0249*  
0B01FC             0250*  @fractional_start:
0B01FC DD E5       0251*      push ix                    ; preserve ix
0B01FE ED 53 4C 02 0252*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0203 06 03       0253*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0205 11 00 00 00 0254*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0209 DD 21 54 02 0255*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B020E 23          0256*      inc hl                     ; Skip decimal point
0B020F             0257*  
0B020F             0258*  @fractional_loop:
0B020F 7E          0259*      ld a, (hl)                 ; Load next character
0B0210 D6 30       0260*      sub '0'                    ; Normalize ASCII to decimal
0B0212 38 1C       0261*      jr c, @end_fraction        ; Exit if < '0'
0B0214 FE 0A       0262*      cp 10
0B0216 30 18       0263*      jr nc, @end_fraction       ; Exit if >= 10
0B0218             0264*  
0B0218             0265*      ; Multiply the current fractional accumulator by 10
0B0218 E5          0266*      push hl                    ; Save char pointer
0B0219 F5          0267*      push af                    ; Save the digit
0B021A EB          0268*      ex de, hl
0B021B E5          0269*      push hl
0B021C 29          0270*      add hl,hl ; * 2
0B021D 29          0271*      add hl,hl ; * 4
0B021E D1          0272*      pop de
0B021F 19          0273*      add hl,de ; * 5
0B0220 29          0274*      add hl,hl ; * 10
0B0221 11 00 00 00 0275*      ld de, 0                   ; Clear DEU
0B0225 F1          0276*      pop af                     ; Restore the current digit
0B0226 5F          0277*      ld e, a                    ; Load the digit into E
0B0227 19          0278*      add hl, de                 ; Add the digit to the accumulator
0B0228 EB          0279*      ex de, hl                  ; Result back to DE
0B0229 ED 32 03    0280*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B022C E1          0281*      pop hl                     ; Restore char pointer
0B022D 23          0282*      inc hl                     ; Move to the next character
0B022E 10 DF       0283*      djnz @fractional_loop      ; Loop if more digits to process
0B0230             0284*  
0B0230             0285*  @end_fraction:
0B0230             0286*  ; Final scaling based on number of fractional digits processed
0B0230 ED 53 50 02 0287*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0235 2A 4F 02 0B 0288*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0239             0289*  
0B0239 DD 17 00    0290*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B023C CD 1A 0A 0B 0291*      call udiv24                ; Perform 24-bit division to scale down
0B0240 7B          0292*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0241 32 4B 02 0B 0293*      ld (@result), a            ; Store fractional part in result buffer
0B0245 DD E1       0294*      pop ix                     ; Restore ix
0B0247 C3 E1 01 0B 0295*      jp @end                    ; Final sign check and flag setup
0B024B             0296*  
0B024B             0297*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B024F             0298*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0253 00          0299*  @sign: db 0                    ; Sign flag buffer
0B0254             0300*  
0B0254             0301*  powers_of_10:
0B0254 01 00 00    0302*      dl 1                       ; 10^0
0B0257 0A 00 00    0303*      dl 10                      ; 10^1
0B025A 64 00 00    0304*      dl 100                     ; 10^2
0B025D E8 03 00    0305*      dl 1000                    ; 10^3
0B0260 10 27 00    0306*      dl 10000                   ; 10^4
0B0263             0017   
0B0263             0018   ; API INCLUDES
0B0263             0019       include "functions.inc"
0B0263             0001*      MACRO printChar char
0B0263             0002*          LD A, char
0B0263             0003*          RST.LIL 10h
0B0263             0004*      ENDMACRO
0B0263             0005*  
0B0263             0006*  ; test the sign of HL
0B0263             0007*  ; inputs: HL obviously
0B0263             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0263             0009*  ; destroys: flags
0B0263             0010*      MACRO sign_hlu
0B0263             0011*          add hl,de
0B0263             0012*          or a
0B0263             0013*          sbc hl,de
0B0263             0014*      ENDMACRO
0B0263             0015*  
0B0263             0016*  ; Simulated call to subroutine at HL
0B0263             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0263             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0263             0019*  ; destroys: only what the subroutine does, but always BC
0B0263             0020*      MACRO callHL
0B0263             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0022*          push bc       ; which constitutes the return address
0B0263             0023*          jp   (hl)     ; Jump to the address in HL
0B0263             0024*      ENDMACRO
0B0263             0025*  
0B0263             0026*  ; Simulated call to subroutine at IX
0B0263             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0263             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0263             0029*  ; destroys: only what the subroutine does, but always BC
0B0263             0030*      MACRO callIX
0B0263             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0032*          push bc       ; which constitutes the return address
0B0263             0033*          jp   (ix)     ; Jump to the address in IX
0B0263             0034*      ENDMACRO
0B0263             0035*  
0B0263             0036*  ; Simulated call to soubroutinte at IY
0B0263             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0263             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0263             0039*  ; destroys: only what the subroutine does, but always BC
0B0263             0040*      MACRO callIY
0B0263             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0042*          push bc       ; which constitutes the return address
0B0263             0043*          jp   (iy)     ; Jump to the address in IY
0B0263             0044*      ENDMACRO
0B0263             0045*  
0B0263             0046*  ; put the value in HLU into the accumulator
0B0263             0047*  ; destroys: af
0B0263             0048*      MACRO HLU_TO_A
0B0263             0049*          push hl ; 4 cycles
0B0263             0050*          inc sp ; 1 cycle
0B0263             0051*          pop af  ; 4 cycles
0B0263             0052*          dec sp ; 1 cycle
0B0263             0053*                 ; 10 cycles total
0B0263             0054*      ENDMACRO
0B0263             0055*  
0B0263             0056*  A_TO_HLU:
0B0263             0057*      ; call is 7 cycles
0B0263 22 70 02 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0267 32 72 02 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B026B 2A 70 02 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B026F C9          0061*      ret ; 6 cycles
0B0270             0062*          ; 25 cycles total
0B0270 00 00 00    0063*  @scratch: dl 0
0B0273             0064*  
0B0273             0065*      ; TODO: implement this
0B0273             0066*      ; MACRO A_TO_HLU
0B0273             0067*      ;     push.s af
0B0273             0068*      ;     inc sp
0B0273             0069*      ;     push.s hl
0B0273             0070*      ;     pop hl
0B0273             0071*      ;     inc sp
0B0273             0072*      ;     inc sp
0B0273             0073*      ; ENDMACRO
0B0273             0074*  
0B0273             0075*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0273             0076*  ; Print a zero-terminated string
0B0273             0077*  ; HL: Pointer to string
0B0273             0078*  printString:
0B0273 C5          0079*  	PUSH	BC
0B0274 01 00 00 00 0080*  	LD		BC,0
0B0278 3E 00       0081*  	LD 	 	A,0
0B027A 5B DF       0082*  	RST.LIL 18h
0B027C C1          0083*  	POP		BC
0B027D C9          0084*  	RET
0B027E             0085*  ; print a VDU sequence
0B027E             0086*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B027E             0087*  sendVDUsequence:
0B027E C5          0088*  	PUSH	BC
0B027F 01 00 00 00 0089*  	LD		BC, 0
0B0283 4E          0090*  	LD		C, (HL)
0B0284 5B DF       0091*  	RST.LIL	18h
0B0286 C1          0092*  	POP		BC
0B0287 C9          0093*  	RET
0B0288             0094*  ; Print Newline sequence to VDP
0B0288             0095*  printNewLine:
0B0288 F5          0096*      push af ; for some reason rst.lil 10h sets carry flag
0B0289 3E 0D       0097*  	LD	A, '\r'
0B028B 5B D7       0098*  	RST.LIL 10h
0B028D 3E 0A       0099*  	LD	A, '\n'
0B028F 5B D7       0100*  	RST.LIL 10h
0B0291 F1          0101*      pop af
0B0292 C9          0102*  	RET
0B0293             0103*  
0B0293             0104*  ; Print a 24-bit HEX number
0B0293             0105*  ; HLU: Number to print
0B0293             0106*  printHex24:
0B0293             0107*  	; PUSH	HL      ; 4 cycles
0B0293             0108*  	; LD		HL, 2   ; 4 cycles
0B0293             0109*  	; ADD		HL, SP  ; 1 cycle
0B0293             0110*  	; LD		A, (HL) ; 2 cycles
0B0293             0111*  	; POP		HL      ; 4 cycles
0B0293             0112*      ;                 ; 15 cycles total
0B0293 E5          0113*      push hl ; 4 cycles
0B0294 33          0114*      inc sp ; 1 cycle
0B0295 F1          0115*      pop af  ; 4 cycles
0B0296 3B          0116*      dec sp ; 1 cycle
0B0297             0117*              ; 10 cycles total
0B0297 CD A1 02 0B 0118*  	CALL	printHex8
0B029B             0119*  ; Print a 16-bit HEX number
0B029B             0120*  ; HL: Number to print
0B029B             0121*  printHex16:
0B029B 7C          0122*  	LD		A,H
0B029C CD A1 02 0B 0123*  	CALL	printHex8
0B02A0 7D          0124*  	LD		A,L
0B02A1             0125*  ; Print an 8-bit HEX number
0B02A1             0126*  ; A: Number to print
0B02A1             0127*  printHex8:
0B02A1 4F          0128*  	LD		C,A
0B02A2 1F          0129*  	RRA
0B02A3 1F          0130*  	RRA
0B02A4 1F          0131*  	RRA
0B02A5 1F          0132*  	RRA
0B02A6 CD AB 02 0B 0133*  	CALL	@F
0B02AA 79          0134*  	LD		A,C
0B02AB             0135*  @@:
0B02AB E6 0F       0136*  	AND		0Fh
0B02AD C6 90       0137*  	ADD		A,90h
0B02AF 27          0138*  	DAA
0B02B0 CE 40       0139*  	ADC		A,40h
0B02B2 27          0140*  	DAA
0B02B3 5B D7       0141*  	RST.LIL	10h
0B02B5 C9          0142*  	RET
0B02B6             0143*  
0B02B6             0144*  printHexA:
0B02B6 F5          0145*      push af
0B02B7 C5          0146*      push bc
0B02B8 CD A1 02 0B 0147*      call printHex8
0B02BC 3E 20       0148*      ld a,' '
0B02BE 5B D7       0149*      rst.lil 10h
0B02C0 C1          0150*      pop bc
0B02C1 F1          0151*      pop af
0B02C2 C9          0152*      ret
0B02C3             0153*  
0B02C3             0154*  printHexHL:
0B02C3 F5          0155*      push af
0B02C4 C5          0156*      push bc
0B02C5 CD 9B 02 0B 0157*      call printHex16
0B02C9 3E 20       0158*      ld a,' '
0B02CB 5B D7       0159*      rst.lil 10h
0B02CD C1          0160*      pop bc
0B02CE F1          0161*      pop af
0B02CF C9          0162*      ret
0B02D0             0163*  
0B02D0             0164*  printHexUHL:
0B02D0 F5          0165*      push af
0B02D1 C5          0166*      push bc
0B02D2 CD 93 02 0B 0167*      call printHex24
0B02D6 3E 20       0168*      ld a,' '
0B02D8 5B D7       0169*      rst.lil 10h
0B02DA C1          0170*      pop bc
0B02DB F1          0171*      pop af
0B02DC C9          0172*      ret
0B02DD             0173*  
0B02DD             0174*  printHexAUHL:
0B02DD F5          0175*      push af
0B02DE C5          0176*      push bc
0B02DF CD A1 02 0B 0177*      call printHex8
0B02E3 3E 2E       0178*      ld a,'.'
0B02E5 5B D7       0179*      rst.lil 10h
0B02E7 CD 93 02 0B 0180*      call printHex24
0B02EB 3E 20       0181*      ld a,' '
0B02ED 5B D7       0182*      rst.lil 10h
0B02EF C1          0183*      pop bc
0B02F0 F1          0184*      pop af
0B02F1 C9          0185*      ret
0B02F2             0186*  
0B02F2             0187*  printHexABHL:
0B02F2             0188*  ; preserve registers
0B02F2 C5          0189*      push bc ; b will be ok c will not
0B02F3 F5          0190*      push af ; will get totally destroyed
0B02F4             0191*  ; print a
0B02F4 CD A1 02 0B 0192*      call printHex8
0B02F8             0193*  ; print b
0B02F8 78          0194*      ld a,b
0B02F9 CD A1 02 0B 0195*      call printHex8
0B02FD             0196*  ; print hl
0B02FD CD 9B 02 0B 0197*      call printHex16
0B0301             0198*  ; restore registers
0B0301 F1          0199*      pop af
0B0302 C1          0200*      pop bc
0B0303 C9          0201*      ret
0B0304             0202*  
0B0304             0203*  printHexBHL:
0B0304             0204*  ; preserve registers
0B0304 C5          0205*      push bc ; b will be ok c will not
0B0305 F5          0206*      push af ; will get totally destroyed
0B0306             0207*  ; print b
0B0306 78          0208*      ld a,b
0B0307 CD A1 02 0B 0209*      call printHex8
0B030B             0210*  ; print hl
0B030B CD 9B 02 0B 0211*      call printHex16
0B030F             0212*  ; restore registers
0B030F F1          0213*      pop af
0B0310 C1          0214*      pop bc
0B0311 C9          0215*      ret
0B0312             0216*  
0B0312             0217*  printHexCDE:
0B0312             0218*  ; preserve registers
0B0312 C5          0219*      push bc ; b will be ok c will not
0B0313 F5          0220*      push af ; will get totally destroyed
0B0314             0221*  ; print c
0B0314 79          0222*      ld a,c
0B0315 CD A1 02 0B 0223*      call printHex8
0B0319             0224*  ; print de
0B0319 EB          0225*      ex de,hl
0B031A CD 9B 02 0B 0226*      call printHex16
0B031E EB          0227*      ex de,hl
0B031F             0228*  ; restore registers
0B031F F1          0229*      pop af
0B0320 C1          0230*      pop bc
0B0321 C9          0231*      ret
0B0322             0232*  
0B0322             0233*  ; Print a 0x HEX prefix
0B0322             0234*  DisplayHexPrefix:
0B0322 3E 30       0235*  	LD	A, '0'
0B0324 5B D7       0236*  	RST.LIL 10h
0B0326 3E 78       0237*  	LD	A, 'x'
0B0328 5B D7       0238*  	RST.LIL 10h
0B032A C9          0239*  	RET
0B032B             0240*  
0B032B             0241*      MACRO printDecBC
0B032B             0242*          push hl
0B032B             0243*          push bc
0B032B             0244*          pop hl
0B032B             0245*          call printDec
0B032B             0246*          pop hl
0B032B             0247*      ENDMACRO
0B032B             0248*  
0B032B             0249*      MACRO printDecDE
0B032B             0250*          push hl
0B032B             0251*          push de
0B032B             0252*          pop hl
0B032B             0253*          call printDec
0B032B             0254*          pop hl
0B032B             0255*      ENDMACRO
0B032B             0256*  
0B032B             0257*      MACRO printDecHL
0B032B             0258*          call printDec
0B032B             0259*      ENDMACRO
0B032B             0260*  
0B032B             0261*      MACRO printDecIX
0B032B             0262*          push hl
0B032B             0263*          push ix
0B032B             0264*          pop hl
0B032B             0265*          call printDec
0B032B             0266*          pop hl
0B032B             0267*      ENDMACRO
0B032B             0268*  
0B032B             0269*      MACRO printDecIY
0B032B             0270*          push hl
0B032B             0271*          push iy
0B032B             0272*          pop hl
0B032B             0273*          call printDec
0B032B             0274*          pop hl
0B032B             0275*      ENDMACRO
0B032B             0276*  
0B032B             0277*  
0B032B             0278*  ; Prints the right justified decimal value in HL without leading zeroes
0B032B             0279*  ; HL : Value to print
0B032B             0280*  ; preserves all registers and flags
0B032B             0281*  printDec:
0B032B             0282*  ; BEGIN MY CODE
0B032B             0283*  ; back up all the things
0B032B F5          0284*      push af
0B032C C5          0285*      push bc
0B032D D5          0286*      push de
0B032E E5          0287*      push hl
0B032F             0288*  ; END MY CODE
0B032F 11 53 03 0B 0289*  	LD	 DE, _printDecBuffer
0B0333 CD 63 03 0B 0290*  	CALL u24_to_ascii
0B0337             0291*  ; BEGIN MY CODE
0B0337             0292*  ; replace leading zeroes with spaces
0B0337 21 53 03 0B 0293*      LD	 HL, _printDecBuffer
0B033B 06 07       0294*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B033D             0295*  @loop:
0B033D 7E          0296*      LD	 A, (HL)
0B033E FE 30       0297*      CP	 '0'
0B0340 C2 4A 03 0B 0298*      JP	 NZ, @done
0B0344 3E 20       0299*      LD   A, ' '
0B0346 77          0300*      LD	 (HL), A
0B0347 23          0301*      INC	 HL
0B0348             0302*      ; CALL vdu_cursor_forward
0B0348 10 F3       0303*      DJNZ @loop
0B034A             0304*  @done:
0B034A             0305*  ; END MY CODE
0B034A             0306*  	; LD	 HL, _printDecBuffer
0B034A CD 73 02 0B 0307*  	CALL printString
0B034E             0308*  ; BEGIN MY CODE
0B034E             0309*  ; restore all the things
0B034E E1          0310*      pop hl
0B034F D1          0311*      pop de
0B0350 C1          0312*      pop bc
0B0351 F1          0313*      pop af
0B0352             0314*  ; END MY CODE
0B0352 C9          0315*  	RET
0B0353 00 00 00 00 0316*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0363             0317*  
0B0363             0318*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0363             0319*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0363             0320*  ; so it will allways be 8 characters length
0B0363             0321*  ; HL : Value to convert to string
0B0363             0322*  ; DE : pointer to buffer, at least 8 byte + 0
0B0363             0323*  u24_to_ascii:
0B0363 01 80 69 67 0324*  	LD	 BC,-10000000
0B0367 CD 9A 03 0B 0325*  	CALL @one_digit
0B036B 01 C0 BD F0 0326*  	LD	 BC,-1000000
0B036F CD 9A 03 0B 0327*  	CALL @one_digit
0B0373 01 60 79 FE 0328*  	LD	 BC,-100000
0B0377 CD 9A 03 0B 0329*  	CALL @one_digit
0B037B 01 F0 D8 FF 0330*  	LD   BC,-10000
0B037F CD 9A 03 0B 0331*  	CALL @one_digit
0B0383 01 18 FC FF 0332*  	LD   BC,-1000
0B0387 CD 9A 03 0B 0333*  	CALL @one_digit
0B038B 01 9C FF FF 0334*  	LD   BC,-100
0B038F CD 9A 03 0B 0335*  	CALL @one_digit
0B0393 0E F6       0336*  	LD   C,-10
0B0395 CD 9A 03 0B 0337*  	CALL @one_digit
0B0399 48          0338*  	LD   C,B
0B039A             0339*  @one_digit:
0B039A 3E 2F       0340*  	LD   A,'0'-1
0B039C             0341*  @divide_me:
0B039C 3C          0342*  	INC  A
0B039D 09          0343*  	ADD  HL,BC
0B039E 38 FC       0344*  	JR   C,@divide_me
0B03A0 ED 42       0345*  	SBC  HL,BC
0B03A2 12          0346*  	LD   (DE),A
0B03A3 13          0347*  	INC  DE
0B03A4 C9          0348*  	RET
0B03A5             0349*  
0B03A5             0350*  print_u24:
0B03A5 D5          0351*      push de
0B03A6 E5          0352*      push hl
0B03A7 11 53 03 0B 0353*      ld de,_printDecBuffer
0B03AB CD 63 03 0B 0354*      call u24_to_ascii
0B03AF 21 53 03 0B 0355*      ld hl,_printDecBuffer
0B03B3 CD 73 02 0B 0356*      call printString
0B03B7 3E 20       0357*      ld a,' '
0B03B9 5B D7       0358*      rst.lil 10h
0B03BB E1          0359*      pop hl
0B03BC D1          0360*      pop de
0B03BD C9          0361*      ret
0B03BE             0362*  
0B03BE             0363*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03BE             0364*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03BE             0365*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03BE             0366*  u168_to_ascii:
0B03BE             0367*  ; add a leading space to make room for sign flag if needed
0B03BE 3E 20       0368*      ld a,' '
0B03C0 12          0369*      ld (de),a
0B03C1 13          0370*      inc de
0B03C2             0371*  ; Convert integer part
0B03C2 E5          0372*      push hl               ; Save HL (well need the fractional part later)
0B03C3 CD 9A 08 0B 0373*      call hlu_udiv256    ; Shift to get integer portion in HL
0B03C7 01 F0 D8 FF 0374*      ld   bc, -10000
0B03CB CD EE 03 0B 0375*      call @one_int
0B03CF 01 18 FC FF 0376*      ld   bc, -1000
0B03D3 CD EE 03 0B 0377*      call @one_int
0B03D7 01 9C FF FF 0378*      ld   bc, -100
0B03DB CD EE 03 0B 0379*      call @one_int
0B03DF 0E F6       0380*      ld   c, -10
0B03E1 CD EE 03 0B 0381*      call @one_int
0B03E5 48          0382*      ld   c, b
0B03E6 CD EE 03 0B 0383*      call @one_int
0B03EA C3 F9 03 0B 0384*      jp   @frac            ; Jump to fractional part conversion
0B03EE             0385*  @one_int:
0B03EE 3E 2F       0386*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F0             0387*  @divide_me:
0B03F0 3C          0388*      inc  a
0B03F1 09          0389*      add  hl, bc           ; Accumulate until overflow
0B03F2 38 FC       0390*      jr   c, @divide_me
0B03F4 ED 42       0391*      sbc  hl, bc           ; Remove excess after overflow
0B03F6 12          0392*      ld   (de), a          ; Store ASCII digit
0B03F7 13          0393*      inc  de
0B03F8 C9          0394*      ret
0B03F9             0395*  ; Convert fractional part
0B03F9             0396*  @frac:
0B03F9 3E 2E       0397*      ld   a, '.'           ; Decimal point
0B03FB 12          0398*      ld   (de), a
0B03FC 13          0399*      inc  de
0B03FD E1          0400*      pop  hl               ; Restore HL with original fraction
0B03FE 06 03       0401*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0400             0402*  @frac_loop:
0B0400 26 0A       0403*      ld   h, 10            ; Load multiplier for fractional part
0B0402 ED 6C       0404*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0404 3E 30       0405*      ld   a, '0'
0B0406 84          0406*      add  a, h             ; Convert integer part to ASCII
0B0407 12          0407*      ld   (de), a
0B0408 13          0408*      inc  de
0B0409 10 F5       0409*      djnz @frac_loop       ; Repeat for each fractional digit
0B040B             0410*  ; Add null terminator
0B040B AF          0411*      xor  a                ; Null terminator
0B040C 12          0412*      ld   (de), a
0B040D C9          0413*      ret
0B040E             0414*  
0B040E             0415*  print_u168:
0B040E D5          0416*      push de
0B040F E5          0417*      push hl
0B0410 11 53 03 0B 0418*      ld de,_printDecBuffer
0B0414 CD BE 03 0B 0419*      call u168_to_ascii
0B0418 21 53 03 0B 0420*      ld hl,_printDecBuffer
0B041C CD 73 02 0B 0421*      call printString
0B0420 E1          0422*      pop hl
0B0421 D1          0423*      pop de
0B0422 C9          0424*      ret
0B0423             0425*  
0B0423             0426*  ; signed version of u168_to_ascii
0B0423             0427*  s168_to_ascii:
0B0423 D5          0428*      push de ; save starting address of buffer
0B0424 CD 33 08 0B 0429*      call hlu_abs
0B0428 F5          0430*      push af ; save sign flag
0B0429 CD BE 03 0B 0431*      call u168_to_ascii
0B042D F1          0432*      pop af ; restore sign flag
0B042E D1          0433*      pop de ; restore starting address of buffer
0B042F F0          0434*      ret p ; hlu was positive so nothing to do
0B0430 3E 2D       0435*      ld a,'-'
0B0432 12          0436*      ld (de),a
0B0433 C9          0437*      ret
0B0434             0438*  
0B0434             0439*  print_s168:
0B0434 D5          0440*      push de
0B0435 E5          0441*      push hl
0B0436 11 53 03 0B 0442*      ld de,_printDecBuffer
0B043A CD 23 04 0B 0443*      call s168_to_ascii
0B043E 21 53 03 0B 0444*      ld hl,_printDecBuffer
0B0442 CD 73 02 0B 0445*      call printString
0B0446 E1          0446*      pop hl
0B0447 D1          0447*      pop de
0B0448 C9          0448*      ret
0B0449             0449*  
0B0449             0450*  print_s168_hl:
0B0449 F5          0451*      push af
0B044A E5          0452*      push hl
0B044B CD 34 04 0B 0453*      call print_s168
0B044F 3E 20       0454*      ld a,' '
0B0451 5B D7       0455*      rst.lil 10h
0B0453 E1          0456*      pop hl
0B0454 F1          0457*      pop af
0B0455 C9          0458*      ret
0B0456             0459*  
0B0456             0460*  print_s168_bc:
0B0456 F5          0461*      push af
0B0457 C5          0462*      push bc
0B0458 E5          0463*      push hl
0B0459 C5          0464*      push bc
0B045A E1          0465*      pop hl
0B045B CD 34 04 0B 0466*      call print_s168
0B045F 3E 20       0467*      ld a,' '
0B0461 5B D7       0468*      rst.lil 10h
0B0463 E1          0469*      pop hl
0B0464 C1          0470*      pop bc
0B0465 F1          0471*      pop af
0B0466 C9          0472*      ret
0B0467             0473*  
0B0467             0474*  print_s168_de:
0B0467 F5          0475*      push af
0B0468 D5          0476*      push de
0B0469 E5          0477*      push hl
0B046A EB          0478*      ex de,hl
0B046B CD 34 04 0B 0479*      call print_s168
0B046F 3E 20       0480*      ld a,' '
0B0471 5B D7       0481*      rst.lil 10h
0B0473 E1          0482*      pop hl
0B0474 D1          0483*      pop de
0B0475 F1          0484*      pop af
0B0476 C9          0485*      ret
0B0477             0486*  
0B0477             0487*  print_s168_hl_bc_de:
0B0477 F5          0488*      push af
0B0478 C5          0489*      push bc
0B0479 D5          0490*      push de
0B047A E5          0491*      push hl
0B047B CD 34 04 0B 0492*      call print_s168
0B047F 3E 20       0493*      ld a,' '
0B0481 5B D7       0494*      rst.lil 10h
0B0483 C5          0495*      push bc
0B0484 E1          0496*      pop hl
0B0485 CD 34 04 0B 0497*      call print_s168
0B0489 3E 20       0498*      ld a,' '
0B048B 5B D7       0499*      rst.lil 10h
0B048D EB          0500*      ex de,hl
0B048E CD 34 04 0B 0501*      call print_s168
0B0492 3E 20       0502*      ld a,' '
0B0494 5B D7       0503*      rst.lil 10h
0B0496 E1          0504*      pop hl
0B0497 D1          0505*      pop de
0B0498 C1          0506*      pop bc
0B0499 F1          0507*      pop af
0B049A C9          0508*      ret
0B049B             0509*  
0B049B             0510*  print_s168_bc_de:
0B049B F5          0511*      push af
0B049C C5          0512*      push bc
0B049D D5          0513*      push de
0B049E C5          0514*      push bc
0B049F E1          0515*      pop hl
0B04A0 CD 34 04 0B 0516*      call print_s168
0B04A4 3E 20       0517*      ld a,' '
0B04A6 5B D7       0518*      rst.lil 10h
0B04A8 EB          0519*      ex de,hl
0B04A9 CD 34 04 0B 0520*      call print_s168
0B04AD 3E 20       0521*      ld a,' '
0B04AF 5B D7       0522*      rst.lil 10h
0B04B1 E1          0523*      pop hl
0B04B2 D1          0524*      pop de
0B04B3 C1          0525*      pop bc
0B04B4 F1          0526*      pop af
0B04B5 C9          0527*      ret
0B04B6             0528*  
0B04B6             0529*  print_s168_a:
0B04B6 F5          0530*      push af
0B04B7 C5          0531*      push bc
0B04B8 E5          0532*      push hl
0B04B9 21 00 00 00 0533*      ld hl,0
0B04BD 6F          0534*      ld l,a
0B04BE CD 49 04 0B 0535*      call print_s168_hl
0B04C2 E1          0536*      pop hl
0B04C3 C1          0537*      pop bc
0B04C4 F1          0538*      pop af
0B04C5 C9          0539*      ret
0B04C6             0540*  
0B04C6             0541*  ; #### new functions added by Brandon R. Gates ####
0B04C6             0542*  
0B04C6             0543*  ; print the binary representation of the 8-bit value in a
0B04C6             0544*  ; destroys a, hl, bc
0B04C6             0545*  printBin8:
0B04C6 06 08       0546*      ld b,8      ; loop counter for 8 bits
0B04C8 21 E3 04 0B 0547*      ld hl,@cmd  ; set hl to the low byte of the output string
0B04CC             0548*                  ; (which will be the high bit of the value in a)
0B04CC             0549*  @loop:
0B04CC 07          0550*      rlca ; put the next highest bit into carry
0B04CD 38 04       0551*      jr c,@one
0B04CF 36 30       0552*      ld (hl),'0'
0B04D1 18 02       0553*      jr @next_bit
0B04D3             0554*  @one:
0B04D3 36 31       0555*      ld (hl),'1'
0B04D5             0556*  @next_bit:
0B04D5 23          0557*      inc hl
0B04D6 10 F4       0558*      djnz @loop
0B04D8             0559*  ; print it
0B04D8 21 E3 04 0B 0560*  	ld hl,@cmd
0B04DC 01 08 00 00 0561*  	ld bc,@end-@cmd
0B04E0 5B DF       0562*  	rst.lil $18
0B04E2 C9          0563*  	ret
0B04E3             0564*  @cmd: ds 8 ; eight bytes for eight bits
0B04EB             0565*  @end:
0B04EB             0566*  
0B04EB             0567*  ; print the binary representation of the 8-bit value in a
0B04EB             0568*  ; in reverse order (lsb first)
0B04EB             0569*  ; destroys a, hl, bc
0B04EB             0570*  printBin8Rev:
0B04EB 06 08       0571*      ld b,8      ; loop counter for 8 bits
0B04ED 21 08 05 0B 0572*      ld hl,@cmd  ; set hl to the low byte of the output string
0B04F1             0573*                  ; (which will be the high bit of the value in a)
0B04F1             0574*  @loop:
0B04F1 0F          0575*      rrca ; put the next lowest bit into carry
0B04F2 38 04       0576*      jr c,@one
0B04F4 36 30       0577*      ld (hl),'0'
0B04F6 18 02       0578*      jr @next_bit
0B04F8             0579*  @one:
0B04F8 36 31       0580*      ld (hl),'1'
0B04FA             0581*  @next_bit:
0B04FA 23          0582*      inc hl
0B04FB 10 F4       0583*      djnz @loop
0B04FD             0584*  ; print it
0B04FD 21 08 05 0B 0585*  	ld hl,@cmd
0B0501 01 08 00 00 0586*  	ld bc,@end-@cmd
0B0505 5B DF       0587*  	rst.lil $18
0B0507 C9          0588*  	ret
0B0508             0589*  @cmd: ds 8 ; eight bytes for eight bits
0B0510             0590*  @end:
0B0510             0591*  
0B0510             0592*  ; print registers to screen in hexidecimal format
0B0510             0593*  ; inputs: none
0B0510             0594*  ; outputs: values of every register printed to screen
0B0510             0595*  ;    values of each register in global scratch memory
0B0510             0596*  ; destroys: nothing
0B0510             0597*  stepRegistersHex:
0B0510             0598*  ; store everything in scratch
0B0510 22 3E 07 0B 0599*      ld (uhl),hl
0B0514 ED 43 41 07 0600*      ld (ubc),bc
       0B          
0B0519 ED 53 44 07 0601*      ld (ude),de
       0B          
0B051E DD 22 47 07 0602*      ld (uix),ix
       0B          
0B0523 FD 22 4A 07 0603*      ld (uiy),iy
       0B          
0B0528 F5          0604*      push af ; fml
0B0529 E1          0605*      pop hl  ; thanks, zilog
0B052A 22 3B 07 0B 0606*      ld (uaf),hl
0B052E F5          0607*      push af ; dammit
0B052F             0608*  
0B052F             0609*  ; home the cursor
0B052F             0610*      ; call vdu_home_cursor
0B052F             0611*  
0B052F             0612*  ; print each register
0B052F 21 C1 06 0B 0613*      ld hl,str_afu
0B0533 CD 73 02 0B 0614*      call printString
0B0537 2A 3B 07 0B 0615*      ld hl,(uaf)
0B053B CD 93 02 0B 0616*      call printHex24
0B053F CD 88 02 0B 0617*      call printNewLine
0B0543             0618*  
0B0543 21 C6 06 0B 0619*      ld hl,str_hlu
0B0547 CD 73 02 0B 0620*      call printString
0B054B 2A 3E 07 0B 0621*      ld hl,(uhl)
0B054F CD 93 02 0B 0622*      call printHex24
0B0553 CD 88 02 0B 0623*      call printNewLine
0B0557             0624*  
0B0557 21 CB 06 0B 0625*      ld hl,str_bcu
0B055B CD 73 02 0B 0626*      call printString
0B055F 2A 41 07 0B 0627*      ld hl,(ubc)
0B0563 CD 93 02 0B 0628*      call printHex24
0B0567 CD 88 02 0B 0629*      call printNewLine
0B056B             0630*  
0B056B 21 D0 06 0B 0631*      ld hl,str_deu
0B056F CD 73 02 0B 0632*      call printString
0B0573 2A 44 07 0B 0633*      ld hl,(ude)
0B0577 CD 93 02 0B 0634*      call printHex24
0B057B CD 88 02 0B 0635*      call printNewLine
0B057F             0636*  
0B057F 21 D5 06 0B 0637*      ld hl,str_ixu
0B0583 CD 73 02 0B 0638*      call printString
0B0587 2A 47 07 0B 0639*      ld hl,(uix)
0B058B CD 93 02 0B 0640*      call printHex24
0B058F CD 88 02 0B 0641*      call printNewLine
0B0593             0642*  
0B0593 21 DA 06 0B 0643*      ld hl,str_iyu
0B0597 CD 73 02 0B 0644*      call printString
0B059B 2A 4A 07 0B 0645*      ld hl,(uiy)
0B059F CD 93 02 0B 0646*      call printHex24
0B05A3 CD 88 02 0B 0647*      call printNewLine
0B05A7             0648*  
0B05A7             0649*      ; call vsync
0B05A7             0650*  
0B05A7 CD 88 02 0B 0651*      call printNewLine
0B05AB             0652*  
0B05AB             0653*  ; check for right shift key and quit if pressed
0B05AB             0654*  	MOSCALL mos_getkbmap
0B05AB 3E 1E       0001*M 			LD	A, function
0B05AD 5B CF       0002*M 			RST.L	08h
0B05AF             0655*  @stayhere:
0B05AF             0656*  ; 7 RightShift
0B05AF DD CB 00 76 0657*      bit 6,(ix+0)
0B05B3 20 02       0658*      jr nz,@RightShift
0B05B5 18 F8       0659*      jr @stayhere
0B05B7             0660*  @RightShift:
0B05B7 DD CB 0E 86 0661*      res 0,(ix+14) ; debounce the key (hopefully)
0B05BB 3E 80       0662*      ld a,%10000000
0B05BD CD 52 18 0B 0663*      call multiPurposeDelay
0B05C1             0664*  
0B05C1             0665*  ; restore everything
0B05C1 2A 3E 07 0B 0666*      ld hl, (uhl)
0B05C5 ED 4B 41 07 0667*      ld bc, (ubc)
       0B          
0B05CA ED 5B 44 07 0668*      ld de, (ude)
       0B          
0B05CF DD 2A 47 07 0669*      ld ix, (uix)
       0B          
0B05D4 FD 2A 4A 07 0670*      ld iy, (uiy)
       0B          
0B05D9 F1          0671*      pop af
0B05DA             0672*  ; all done
0B05DA C9          0673*      ret
0B05DB             0674*  
0B05DB             0675*  ; print registers to screen in hexidecimal format
0B05DB             0676*  ; inputs: none
0B05DB             0677*  ; outputs: values of every register printed to screen
0B05DB             0678*  ;    values of each register in global scratch memory
0B05DB             0679*  ; destroys: nothing
0B05DB             0680*  dumpRegistersHex:
0B05DB             0681*  ; store everything in scratch
0B05DB 22 3E 07 0B 0682*      ld (uhl),hl
0B05DF ED 43 41 07 0683*      ld (ubc),bc
       0B          
0B05E4 ED 53 44 07 0684*      ld (ude),de
       0B          
0B05E9 DD 22 47 07 0685*      ld (uix),ix
       0B          
0B05EE FD 22 4A 07 0686*      ld (uiy),iy
       0B          
0B05F3 F5          0687*      push af ; fml
0B05F4 E1          0688*      pop hl  ; thanks, zilog
0B05F5 22 3B 07 0B 0689*      ld (uaf),hl
0B05F9 F5          0690*      push af ; dammit
0B05FA             0691*  
0B05FA             0692*  ; home the cursor
0B05FA             0693*      ; call vdu_home_cursor
0B05FA             0694*      ; call printNewLine
0B05FA             0695*  
0B05FA             0696*  ; print each register
0B05FA 21 C1 06 0B 0697*      ld hl,str_afu
0B05FE CD 73 02 0B 0698*      call printString
0B0602 2A 3B 07 0B 0699*      ld hl,(uaf)
0B0606 CD 93 02 0B 0700*      call printHex24
0B060A             0701*      ; call printNewLine
0B060A             0702*  
0B060A 21 C6 06 0B 0703*      ld hl,str_hlu
0B060E CD 73 02 0B 0704*      call printString
0B0612 2A 3E 07 0B 0705*      ld hl,(uhl)
0B0616 CD 93 02 0B 0706*      call printHex24
0B061A             0707*      ; call printNewLine
0B061A             0708*  
0B061A 21 CB 06 0B 0709*      ld hl,str_bcu
0B061E CD 73 02 0B 0710*      call printString
0B0622 2A 41 07 0B 0711*      ld hl,(ubc)
0B0626 CD 93 02 0B 0712*      call printHex24
0B062A             0713*      ; call printNewLine
0B062A             0714*  
0B062A 21 D0 06 0B 0715*      ld hl,str_deu
0B062E CD 73 02 0B 0716*      call printString
0B0632 2A 44 07 0B 0717*      ld hl,(ude)
0B0636 CD 93 02 0B 0718*      call printHex24
0B063A             0719*      ; call printNewLine
0B063A             0720*  
0B063A 21 D5 06 0B 0721*      ld hl,str_ixu
0B063E CD 73 02 0B 0722*      call printString
0B0642 2A 47 07 0B 0723*      ld hl,(uix)
0B0646 CD 93 02 0B 0724*      call printHex24
0B064A             0725*      ; call printNewLine
0B064A             0726*  
0B064A 21 DA 06 0B 0727*      ld hl,str_iyu
0B064E CD 73 02 0B 0728*      call printString
0B0652 2A 4A 07 0B 0729*      ld hl,(uiy)
0B0656 CD 93 02 0B 0730*      call printHex24
0B065A             0731*      ; call printNewLine
0B065A             0732*  
0B065A             0733*      ; call vdu_vblank
0B065A             0734*  
0B065A CD 88 02 0B 0735*      call printNewLine
0B065E             0736*  ; restore everything
0B065E 2A 3E 07 0B 0737*      ld hl, (uhl)
0B0662 ED 4B 41 07 0738*      ld bc, (ubc)
       0B          
0B0667 ED 5B 44 07 0739*      ld de, (ude)
       0B          
0B066C DD 2A 47 07 0740*      ld ix, (uix)
       0B          
0B0671 FD 2A 4A 07 0741*      ld iy, (uiy)
       0B          
0B0676 F1          0742*      pop af
0B0677             0743*  ; all done
0B0677 C9          0744*      ret
0B0678             0745*  
0B0678             0746*  ; print hlu to screen in hexidecimal format
0B0678             0747*  ; inputs: none
0B0678             0748*  ; destroys: nothing
0B0678             0749*  print_hex_hl:
0B0678 F5          0750*      push af
0B0679 E5          0751*      push hl
0B067A 21 C6 06 0B 0752*      ld hl,str_hlu
0B067E CD 73 02 0B 0753*      call printString
0B0682 E1          0754*      pop hl
0B0683 E5          0755*      push hl
0B0684 CD 93 02 0B 0756*      call printHex24
0B0688 3E 20       0757*      ld a,' '
0B068A 5B D7       0758*      rst.lil 10h
0B068C E1          0759*      pop hl
0B068D F1          0760*      pop af
0B068E C9          0761*      ret
0B068F             0762*  
0B068F             0763*  ; print bcu to screen in hexidecimal format
0B068F             0764*  ; inputs: none
0B068F             0765*  ; destroys: nothing
0B068F             0766*  print_hex_bc:
0B068F F5          0767*      push af
0B0690 E5          0768*      push hl
0B0691 C5          0769*      push bc
0B0692 21 CB 06 0B 0770*      ld hl,str_bcu
0B0696 CD 73 02 0B 0771*      call printString
0B069A E1          0772*      pop hl
0B069B E5          0773*      push hl
0B069C CD 93 02 0B 0774*      call printHex24
0B06A0 3E 20       0775*      ld a,' '
0B06A2 5B D7       0776*      rst.lil 10h
0B06A4 C1          0777*      pop bc
0B06A5 E1          0778*      pop hl
0B06A6 F1          0779*      pop af
0B06A7 C9          0780*      ret
0B06A8             0781*  
0B06A8             0782*  ; print deu to screen in hexidecimal format
0B06A8             0783*  ; inputs: none
0B06A8             0784*  ; destroys: nothing
0B06A8             0785*  print_hex_de:
0B06A8 F5          0786*      push af
0B06A9 E5          0787*      push hl
0B06AA D5          0788*      push de
0B06AB 21 D0 06 0B 0789*      ld hl,str_deu
0B06AF CD 73 02 0B 0790*      call printString
0B06B3 E1          0791*      pop hl
0B06B4 E5          0792*      push hl
0B06B5 CD 93 02 0B 0793*      call printHex24
0B06B9 3E 20       0794*      ld a,' '
0B06BB 5B D7       0795*      rst.lil 10h
0B06BD D1          0796*      pop de
0B06BE E1          0797*      pop hl
0B06BF F1          0798*      pop af
0B06C0 C9          0799*      ret
0B06C1             0800*  
0B06C1 20 61 66 3D 0801*  str_afu: db " af=",0
       00          
0B06C6 20 68 6C 3D 0802*  str_hlu: db " hl=",0
       00          
0B06CB 20 62 63 3D 0803*  str_bcu: db " bc=",0
       00          
0B06D0 20 64 65 3D 0804*  str_deu: db " de=",0
       00          
0B06D5 20 69 78 3D 0805*  str_ixu: db " ix=",0
       00          
0B06DA 20 69 79 3D 0806*  str_iyu: db " iy=",0
       00          
0B06DF             0807*  
0B06DF             0808*  ; print udeuhl to screen in hexidecimal format
0B06DF             0809*  ; inputs: none
0B06DF             0810*  ; outputs: concatenated hexidecimal udeuhl
0B06DF             0811*  ; destroys: nothing
0B06DF             0812*  dumpUDEUHLHex:
0B06DF             0813*  ; store everything in scratch
0B06DF 22 3E 07 0B 0814*      ld (uhl),hl
0B06E3 ED 43 41 07 0815*      ld (ubc),bc
       0B          
0B06E8 ED 53 44 07 0816*      ld (ude),de
       0B          
0B06ED DD 22 47 07 0817*      ld (uix),ix
       0B          
0B06F2 FD 22 4A 07 0818*      ld (uiy),iy
       0B          
0B06F7 F5          0819*      push af
0B06F8             0820*  
0B06F8             0821*  ; print each register
0B06F8             0822*  
0B06F8 21 32 07 0B 0823*      ld hl,str_udeuhl
0B06FC CD 73 02 0B 0824*      call printString
0B0700 2A 44 07 0B 0825*      ld hl,(ude)
0B0704 CD 93 02 0B 0826*      call printHex24
0B0708 3E 2E       0827*  	ld a,'.'	; print a dot to separate the values
0B070A 5B D7       0828*  	rst.lil 10h
0B070C 2A 3E 07 0B 0829*      ld hl,(uhl)
0B0710 CD 93 02 0B 0830*      call printHex24
0B0714 CD 88 02 0B 0831*      call printNewLine
0B0718             0832*  
0B0718             0833*  ; restore everything
0B0718 2A 3E 07 0B 0834*      ld hl, (uhl)
0B071C ED 4B 41 07 0835*      ld bc, (ubc)
       0B          
0B0721 ED 5B 44 07 0836*      ld de, (ude)
       0B          
0B0726 DD 2A 47 07 0837*      ld ix, (uix)
       0B          
0B072B FD 2A 4A 07 0838*      ld iy, (uiy)
       0B          
0B0730 F1          0839*      pop af
0B0731             0840*  ; all done
0B0731 C9          0841*      ret
0B0732             0842*  
0B0732 75 64 65 2E 0843*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B073B             0844*  
0B073B             0845*  ; global scratch memory for registers
0B073B 00 00 00    0846*  uaf: dl 0
0B073E 00 00 00    0847*  uhl: dl 0
0B0741 00 00 00    0848*  ubc: dl 0
0B0744 00 00 00    0849*  ude: dl 0
0B0747 00 00 00    0850*  uix: dl 0
0B074A 00 00 00    0851*  uiy: dl 0
0B074D 00 00 00    0852*  usp: dl 0
0B0750 00 00 00    0853*  upc: dl 0
0B0753             0854*  
0B0753             0855*  ; inputs: whatever is in the flags register
0B0753             0856*  ; outputs: binary representation of flags
0B0753             0857*  ;          with a header so we know which is what
0B0753             0858*  ; destroys: nothing
0B0753             0859*  ; preserves: everything
0B0753             0860*  dumpFlags:
0B0753             0861*  ; first we curse zilog for not giving direct access to flags
0B0753 F5          0862*      push af ; this is so we can send it back unharmed
0B0754 F5          0863*      push af ; this is so we can pop it to hl
0B0755             0864*  ; store everything in scratch
0B0755 22 3E 07 0B 0865*      ld (uhl),hl
0B0759 ED 43 41 07 0866*      ld (ubc),bc
       0B          
0B075E ED 53 44 07 0867*      ld (ude),de
       0B          
0B0763 DD 22 47 07 0868*      ld (uix),ix
       0B          
0B0768 FD 22 4A 07 0869*      ld (uiy),iy
       0B          
0B076D             0870*  ; next we print the header
0B076D 21 99 07 0B 0871*      ld hl,@header
0B0771 CD 73 02 0B 0872*      call printString
0B0775 E1          0873*      pop hl ; flags are now in l
0B0776 7D          0874*      ld a,l ; flags are now in a
0B0777 CD C6 04 0B 0875*      call printBin8
0B077B CD 88 02 0B 0876*  	call printNewLine
0B077F             0877*  ; restore everything
0B077F 2A 3E 07 0B 0878*      ld hl, (uhl)
0B0783 ED 4B 41 07 0879*      ld bc, (ubc)
       0B          
0B0788 ED 5B 44 07 0880*      ld de, (ude)
       0B          
0B078D DD 2A 47 07 0881*      ld ix, (uix)
       0B          
0B0792 FD 2A 4A 07 0882*      ld iy, (uiy)
       0B          
0B0797 F1          0883*      pop af ; send her home the way she came
0B0798 C9          0884*      ret
0B0799             0885*  ; Bit 7 (S): Sign flag
0B0799             0886*  ; Bit 6 (Z): Zero flag
0B0799             0887*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B0799             0888*  ; Bit 4 (H): Half Carry flag
0B0799             0889*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B0799             0890*  ; Bit 2 (PV): Parity/Overflow flag
0B0799             0891*  ; Bit 1 (N): Subtract flag
0B0799             0892*  ; Bit 0 (C): Carry flag
0B0799 53 5A 78 48 0893*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B07A4             0894*  
0B07A4             0895*  ; set all the bits in the flag register
0B07A4             0896*  ; more of an academic exercise than anything useful
0B07A4             0897*  ; inputs; none
0B07A4             0898*  ; outputs; a=0,f=255
0B07A4             0899*  ; destroys: flags, hl
0B07A4             0900*  ; preserves: a, because why not
0B07A4             0901*  setAllFlags:
0B07A4 21 FF 00 00 0902*      ld hl,255
0B07A8 67          0903*      ld h,a ; four cycles to preserve a is cheap
0B07A9 E5          0904*      push hl
0B07AA F1          0905*      pop af
0B07AB C9          0906*      ret
0B07AC             0907*  
0B07AC             0908*  ; reset all the bits in the flag register
0B07AC             0909*  ; unlike its inverse counterpart, this may actually be useful
0B07AC             0910*  ; inputs; none
0B07AC             0911*  ; outputs; a=0,f=0
0B07AC             0912*  ; destroys: flags, hl
0B07AC             0913*  ; preserves: a, because why not
0B07AC             0914*  resetAllFlags:
0B07AC 21 00 00 00 0915*      ld hl,0
0B07B0 67          0916*      ld h,a ; four cycles to preserve a is cheap
0B07B1 E5          0917*      push hl
0B07B2 F1          0918*      pop af
0B07B3 C9          0919*      ret
0B07B4             0920*  
0B07B4             0921*  ; wait until user presses a key
0B07B4             0922*  ; inputs: none
0B07B4             0923*  ; outputs: none
0B07B4             0924*  ; destroys: af,ix
0B07B4             0925*  waitKeypress:
0B07B4             0926*      MOSCALL mos_sysvars
0B07B4 3E 08       0001*M 			LD	A, function
0B07B6 5B CF       0002*M 			RST.L	08h
0B07B8 AF          0927*      xor a ; zero out any prior keypresses
0B07B9 DD 77 05    0928*      ld (ix+sysvar_keyascii),a
0B07BC             0929*  @loop:
0B07BC DD 7E 05    0930*      ld a,(ix+sysvar_keyascii)
0B07BF A7          0931*      and a
0B07C0 C0          0932*      ret nz
0B07C1 18 F9       0933*      jr @loop
0B07C3             0934*  
0B07C3             0935*  
0B07C3             0936*  ; print bytes from an address to the screen in hexidecimal format
0B07C3             0937*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07C3             0938*  ; outputs: values of each byte printed to screen separated by spaces
0B07C3             0939*  ; destroys: nothing
0B07C3             0940*  dumpMemoryHex:
0B07C3             0941*  ; save registers to the stack
0B07C3 C5          0942*      push bc
0B07C4 E5          0943*      push hl
0B07C5 F5          0944*      push af
0B07C6             0945*  
0B07C6             0946*  ; print the address and separator
0B07C6 CD 93 02 0B 0947*      call printHex24
0B07CA 3E 3A       0948*      ld a,':'
0B07CC 5B D7       0949*      rst.lil 10h
0B07CE 3E 20       0950*      ld a,' '
0B07D0 5B D7       0951*      rst.lil 10h
0B07D2             0952*  
0B07D2             0953*  ; set b to be our loop counter
0B07D2 F1          0954*      pop af
0B07D3 47          0955*      ld b,a
0B07D4 E1          0956*      pop hl
0B07D5 E5          0957*      push hl
0B07D6 F5          0958*      push af
0B07D7             0959*  @loop:
0B07D7             0960*  ; print the byte
0B07D7 7E          0961*      ld a,(hl)
0B07D8 CD A1 02 0B 0962*      call printHex8
0B07DC             0963*  ; print a space
0B07DC 3E 20       0964*      ld a,' '
0B07DE 5B D7       0965*      rst.lil 10h
0B07E0 23          0966*      inc hl
0B07E1 10 F4       0967*      djnz @loop
0B07E3             0968*      ; call printNewLine
0B07E3             0969*  
0B07E3             0970*  ; restore everything
0B07E3 F1          0971*      pop af
0B07E4 E1          0972*      pop hl
0B07E5 C1          0973*      pop bc
0B07E6             0974*  
0B07E6             0975*  ; all done
0B07E6 C9          0976*      ret
0B07E7             0977*  
0B07E7             0978*  
0B07E7             0979*  ; print bytes from an address to the screen in binary format
0B07E7             0980*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07E7             0981*  ; outputs: values of each byte printed to screen separated by spaces
0B07E7             0982*  ; destroys: nothing
0B07E7             0983*  dumpMemoryBin:
0B07E7             0984*  ; save all registers to the stack
0B07E7 F5          0985*      push af
0B07E8 C5          0986*      push bc
0B07E9 D5          0987*      push de
0B07EA E5          0988*      push hl
0B07EB DD E5       0989*      push ix
0B07ED FD E5       0990*      push iy
0B07EF             0991*  
0B07EF             0992*  ; set b to be our loop counter
0B07EF 47          0993*      ld b,a
0B07F0             0994*  @loop:
0B07F0             0995*  ; print the byte
0B07F0 7E          0996*      ld a,(hl)
0B07F1 E5          0997*      push hl
0B07F2 C5          0998*      push bc
0B07F3 CD C6 04 0B 0999*      call printBin8
0B07F7 C1          1000*      pop bc
0B07F8             1001*  ; print a space
0B07F8 3E 20       1002*      ld a,' '
0B07FA 5B D7       1003*      rst.lil 10h
0B07FC E1          1004*      pop hl
0B07FD 23          1005*      inc hl
0B07FE 10 F0       1006*      djnz @loop
0B0800 CD 88 02 0B 1007*      call printNewLine
0B0804             1008*  
0B0804             1009*  ; restore everything
0B0804 FD E1       1010*      pop iy
0B0806 DD E1       1011*      pop ix
0B0808 E1          1012*      pop hl
0B0809 D1          1013*      pop de
0B080A C1          1014*      pop bc
0B080B F1          1015*      pop af
0B080C             1016*  ; all done
0B080C C9          1017*      ret
0B080D             1018*  
0B080D             1019*  ; print bytes from an address to the screen in binary format
0B080D             1020*  ; with the bits of each byte in reverse order (lsb first)
0B080D             1021*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B080D             1022*  ; outputs: values of each byte printed to screen separated by spaces
0B080D             1023*  ; destroys: nothing
0B080D             1024*  dumpMemoryBinRev:
0B080D             1025*  ; save all registers to the stack
0B080D F5          1026*      push af
0B080E C5          1027*      push bc
0B080F D5          1028*      push de
0B0810 E5          1029*      push hl
0B0811 DD E5       1030*      push ix
0B0813 FD E5       1031*      push iy
0B0815             1032*  
0B0815             1033*  ; set b to be our loop counter
0B0815 47          1034*      ld b,a
0B0816             1035*  @loop:
0B0816             1036*  ; print the byte
0B0816 7E          1037*      ld a,(hl)
0B0817 E5          1038*      push hl
0B0818 C5          1039*      push bc
0B0819 CD EB 04 0B 1040*      call printBin8Rev
0B081D C1          1041*      pop bc
0B081E             1042*  ; print a space
0B081E 3E 20       1043*      ld a,' '
0B0820 5B D7       1044*      rst.lil 10h
0B0822 E1          1045*      pop hl
0B0823 23          1046*      inc hl
0B0824 10 F0       1047*      djnz @loop
0B0826 CD 88 02 0B 1048*      call printNewLine
0B082A             1049*  
0B082A             1050*  ; restore everything
0B082A FD E1       1051*      pop iy
0B082C DD E1       1052*      pop ix
0B082E E1          1053*      pop hl
0B082F D1          1054*      pop de
0B0830 C1          1055*      pop bc
0B0831 F1          1056*      pop af
0B0832             1057*  ; all done
0B0832 C9          1058*      ret
0B0833             0020       include "maths.inc"
0B0833             0001*  ; absolute value of hlu
0B0833             0002*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B0833             0003*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B0833             0004*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B0833             0005*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B0833             0006*  ; destroys: a
0B0833             0007*  hlu_abs:
0B0833 19          0008*      add hl,de
0B0834 B7          0009*      or a
0B0835 ED 52       0010*      sbc hl,de
0B0837 FA 3C 08 0B 0011*      jp m,@is_neg
0B083B C9          0012*      ret         ; hlu is positive or zero so we're done
0B083C             0013*  @is_neg:
0B083C F5          0014*      push af     ; otherwise, save current flags for return
0B083D CD 43 08 0B 0015*      call neg_hlu ; negate hlu
0B0841 F1          0016*      pop af      ; get back flags
0B0842 C9          0017*      ret
0B0843             0018*  
0B0843             0019*  ; flip the sign of hlu
0B0843             0020*  ; inputs: hlu
0B0843             0021*  ; returns: 0-hlu, flags set appropriately for the result:
0B0843             0022*  ;         s1,z0,pv0,n1,c1 if result is negative
0B0843             0023*  ;         s0,z1,pv0,n1,c0 if result is zero
0B0843             0024*  ;         s0,z0,pv0,n1,c1 if result is positive
0B0843             0025*  ; destroys a
0B0843             0026*  neg_hlu:
0B0843 D5          0027*      push de     ; save de
0B0844 EB          0028*      ex de,hl    ; put hl into de
0B0845 21 00 00 00 0029*      ld hl,0     ; clear hl
0B0849 AF          0030*      xor a       ; clear carry
0B084A ED 52       0031*      sbc hl,de   ; 0-hlu = -hlu
0B084C D1          0032*      pop de      ; get de back
0B084D C9          0033*      ret         ; easy peasy
0B084E             0034*  
0B084E             0035*  ;------------------------------------------------------------------------
0B084E             0036*  ; divide hlu by 2, inspired by above
0B084E             0037*  ;------------------------------------------------------------------------
0B084E             0038*  hlu_div2:
0B084E 22 3C 0B 0B 0039*  	ld		(bitbuf1),hl
0B0852 21 3E 0B 0B 0040*  	ld		hl,bitbuf1+2
0B0856 CB 1E       0041*  	rr		(hl)
0B0858 2B          0042*  	dec		hl
0B0859 CB 1E       0043*  	rr		(hl)
0B085B 2B          0044*  	dec		hl
0B085C CB 1E       0045*  	rr		(hl)
0B085E 23          0046*  	inc		hl
0B085F 23          0047*  	inc		hl
0B0860 2A 3C 0B 0B 0048*      ld hl,(bitbuf1)
0B0864 C9          0049*      ret
0B0865             0050*  
0B0865             0051*  ; this is my little hack to divide by 16
0B0865             0052*  hlu_div16:
0B0865 AF          0053*      xor a
0B0866 29          0054*      add hl,hl
0B0867 17          0055*      rla
0B0868 29          0056*      add hl,hl
0B0869 17          0057*      rla
0B086A 29          0058*      add hl,hl
0B086B 17          0059*      rla
0B086C 29          0060*      add hl,hl
0B086D 17          0061*      rla
0B086E 22 7B 08 0B 0062*      ld (@scratch),hl
0B0872 32 7E 08 0B 0063*      ld (@scratch+3),a
0B0876 2A 7C 08 0B 0064*      ld hl,(@scratch+1)
0B087A C9          0065*      ret
0B087B             0066*  @scratch: ds 4
0B087F             0067*  
0B087F             0068*  ; hlu signed division by 256
0B087F             0069*  ; returns: hlu / 256
0B087F             0070*  ; destroys: af
0B087F             0071*  hlu_sdiv256:
0B087F AF          0072*      xor a ; assume hl is positive
0B0880 22 96 08 0B 0073*      ld (@buffer),hl
0B0884             0074*      sign_hlu
0B0884 19          0001*M         add hl,de
0B0885 B7          0002*M         or a
0B0886 ED 52       0003*M         sbc hl,de
0B0888 F2 8D 08 0B 0075*      jp p,@hl_pos
0B088C 3D          0076*      dec a
0B088D             0077*  @hl_pos:
0B088D 32 99 08 0B 0078*      ld (@buffer+3),a
0B0891 2A 97 08 0B 0079*      ld hl,(@buffer+1)
0B0895 C9          0080*      ret
0B0896             0081*  @buffer: ds 4
0B089A             0082*  
0B089A             0083*  ; hlu 1 byte right shift, unsigned
0B089A             0084*  ; returns: hlu / 256, fractional portion in a
0B089A             0085*  ; destroys: af
0B089A             0086*  hlu_udiv256:
0B089A AF          0087*  	xor a
0B089B 32 AC 08 0B 0088*  	ld (@buffer+3),a
0B089F 7D          0089*  	ld a,l ; save the fractional portion
0B08A0 22 A9 08 0B 0090*  	ld (@buffer),hl
0B08A4 2A AA 08 0B 0091*  	ld hl,(@buffer+1)
0B08A8 C9          0092*  	ret
0B08A9             0093*  @buffer: ds 4
0B08AD             0094*  
0B08AD             0095*      MACRO hlu_mul256
0B08AD             0096*          add hl,hl ; * 2
0B08AD             0097*          add hl,hl ; * 4
0B08AD             0098*          add hl,hl ; * 8
0B08AD             0099*          add hl,hl ; * 16
0B08AD             0100*          add hl,hl ; * 32
0B08AD             0101*          add hl,hl ; * 64
0B08AD             0102*          add hl,hl ; * 128
0B08AD             0103*          add hl,hl ; * 256
0B08AD             0104*      ENDMACRO
0B08AD             0105*  
0B08AD             0106*  ; compute the modulo of hlu by deu
0B08AD             0107*  ; outputs: hlu = hlu % deu
0B08AD             0108*  ; destroys: f, hl
0B08AD             0109*  hlu_mod:
0B08AD B7          0110*  	or a ; clear carry
0B08AE             0111*  @loop:
0B08AE ED 52       0112*      sbc hl,de
0B08B0 DA B8 08 0B 0113*      jp c, @end
0B08B4 C3 AE 08 0B 0114*      jp @loop
0B08B8             0115*  @end:
0B08B8 19          0116*      add hl,de
0B08B9 C9          0117*  	ret
0B08BA             0118*  
0B08BA             0119*  
0B08BA 00 00 00 00 0120*  add_bcd_arg1: db #00,#00,#00,#00
0B08BE 00 00 00 00 0121*  add_bcd_arg2: db #00,#00,#00,#00
0B08C2             0122*  
0B08C2             0123*  ; set bcd values in a scratch memory address from registers bcde
0B08C2             0124*  ; input: hl; scratch address,bcde; 8-place bcd number
0B08C2             0125*  ; destroys ; hl
0B08C2             0126*  set_bcd:
0B08C2 73          0127*      ld (hl),e
0B08C3 23          0128*      inc hl
0B08C4 72          0129*      ld (hl),d
0B08C5 23          0130*      inc hl
0B08C6 71          0131*      ld (hl),c
0B08C7 23          0132*      inc hl
0B08C8 70          0133*      ld (hl),b
0B08C9 C9          0134*      ret
0B08CA             0135*  
0B08CA             0136*  ; load bcd values from a scratch memory address to bcde
0B08CA             0137*  ; input: hl; scratch address
0B08CA             0138*  ; output: bcde; 8-place bcd number
0B08CA             0139*  ; destroys: hl
0B08CA             0140*  get_bcd:
0B08CA 5E          0141*      ld e,(hl)
0B08CB 23          0142*      inc hl
0B08CC 56          0143*      ld d,(hl)
0B08CD 23          0144*      inc hl
0B08CE 4E          0145*      ld c,(hl)
0B08CF 23          0146*      inc hl
0B08D0 46          0147*      ld b,(hl)
0B08D1 C9          0148*      ret
0B08D2             0149*  
0B08D2             0150*  ; BCD addition
0B08D2             0151*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08D2             0152*  ;       a is the number of bytes holding each number (number of places/2)
0B08D2             0153*  ; outputs: (hl) + (de) --> (hl)
0B08D2             0154*  ; destroys: a,b,de,hl
0B08D2             0155*  add_bcd:
0B08D2 47          0156*      ld b,a ; loop counter
0B08D3 AF          0157*      xor a ; reset a, clear carry flag
0B08D4             0158*  adcec:
0B08D4 1A          0159*      ld a,(de) ; addend to acc
0B08D5 8E          0160*      adc a,(hl) ; add (hl) to acc
0B08D6 27          0161*      daa ; adjust result to bcd
0B08D7 77          0162*      ld (hl),a ; store result
0B08D8 23          0163*      inc hl ; advance memory pointers
0B08D9 13          0164*      inc de
0B08DA 10 F8       0165*      djnz adcec ; loop until b == 0
0B08DC C9          0166*      ret
0B08DD             0167*  
0B08DD             0168*  ; BCD subtraction
0B08DD             0169*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08DD             0170*  ;       a is the number of bytes holding each number (number of places/2)
0B08DD             0171*  ; outputs: (hl) - (de) --> (hl)
0B08DD             0172*  ; destroys: a,b,de,hl
0B08DD             0173*  sub_bcd:
0B08DD 47          0174*      ld b,a ; loop counter
0B08DE AF          0175*      xor a ; reset a,clear carry flag
0B08DF             0176*  subdec:
0B08DF 1A          0177*      ld a,(de) ; subtrahend to acc
0B08E0 9E          0178*      sbc a,(hl) ; subtract (hl) from acc
0B08E1 27          0179*      daa ; adjust result to bcd
0B08E2 77          0180*      ld (hl),a ; store result
0B08E3 23          0181*      inc hl ; advance memory pointers
0B08E4 13          0182*      inc de
0B08E5 10 F8       0183*      djnz subdec ; loop until b == 0
0B08E7 C9          0184*      ret
0B08E8             0185*  
0B08E8             0186*  ; http://www.z80.info/pseudo-random.txt
0B08E8             0187*  rand_8:
0B08E8 C5          0188*      push bc
0B08E9 3A FC 08 0B 0189*      ld a,(r_seed)
0B08ED 4F          0190*      ld c,a
0B08EE             0191*  
0B08EE 0F          0192*      rrca ; multiply by 32
0B08EF 0F          0193*      rrca
0B08F0 0F          0194*      rrca
0B08F1 EE 1F       0195*      xor 0x1f
0B08F3             0196*  
0B08F3 81          0197*      add a,c
0B08F4 DE FF       0198*      sbc a,255 ; carry
0B08F6             0199*  
0B08F6 32 FC 08 0B 0200*      ld (r_seed),a
0B08FA C1          0201*      pop bc
0B08FB C9          0202*      ret
0B08FC 50          0203*  r_seed: defb $50
0B08FD             0204*  
0B08FD             0205*  ; linear interpolation between two 24-bit numbers
0B08FD             0206*  ; may be signed or unsigned, and treated as integers or fractional
0B08FD             0207*  ; inputs: bc = start value, de = end value, a = interpolation factor
0B08FD             0208*  ; outputs: hl = interpolated value, a = multiply overflow to 32 bits (0 if no overflow)
0B08FD             0209*  ; destroys: af, hl, de
0B08FD             0210*  interpolate24:
0B08FD C5          0211*      push bc ; save start value
0B08FE EB          0212*      ex de,hl ; end value to hl
0B08FF B7          0213*      or a ; clear carry
0B0900 ED 42       0214*      sbc hl,bc ; hl = end - start
0B0902 CD 49 09 0B 0215*      call umul24x8 ; hl = (end - start) * interpolation factor
0B0906 C1          0216*      pop bc ; get back start value (was hl)
0B0907 09          0217*      add hl,bc ; hl = start + (end - start) * interpolation factor
0B0908 C9          0218*      ret
0B0909             0021   	INCLUDE	"arith24.inc"
0B0909             0001*  arith24uaf: ds 6
0B090F             0002*  arith24uhl: ds 6
0B0915             0003*  arith24ubc: ds 6
0B091B             0004*  arith24ude: ds 6
0B0921             0005*  arith24uix: ds 6
0B0927             0006*  arith24uiy: ds 6
0B092D             0007*  arith24usp: ds 6
0B0933             0008*  arith24upc: ds 6
0B0939             0009*  
0B0939             0010*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B0939             0011*  ; uses EZ80 MLT instruction for speed
0B0939             0012*  ; operation: UHL * A --> UHL
0B0939             0013*  ; destroys: AF, HL
0B0939             0014*  smul24x8:
0B0939             0015*  ; make hl positive and store sign flag
0B0939 CD 33 08 0B 0016*  	call hlu_abs
0B093D F5          0017*  	push af
0B093E             0018*  ; do the division
0B093E CD 49 09 0B 0019*      call umul24x8 ; hl = product
0B0942             0020*  ; adjust sign of result
0B0942 F1          0021*  	pop af ; sign de
0B0943 F0          0022*  	ret p ; hl was positive, nothing to do
0B0944 CD 43 08 0B 0023*  	call neg_hlu ; result is negative
0B0948 C9          0024*  	ret
0B0949             0025*  
0B0949             0026*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0949             0027*  ; uses EZ80 MLT instruction for speed
0B0949             0028*  ; operation: UHL * A --> AUHL
0B0949             0029*  ; destroys: AF, HL
0B0949             0030*  umul24x8:
0B0949 D5          0031*  	push de ; preserve de
0B094A             0032*  ; low byte
0B094A 5D          0033*  	ld e,l
0B094B 57          0034*  	ld d,a
0B094C ED 5C       0035*  	mlt de
0B094E 6B          0036*  	ld l,e ; product low byte
0B094F 08          0037*  	ex af,af' ; save multiplier
0B0950 7A          0038*  	ld a,d ; carry
0B0951 08          0039*  	ex af,af' ; save carry, restore multiplier
0B0952             0040*  ; high byte
0B0952 5C          0041*  	ld e,h
0B0953 57          0042*  	ld d,a
0B0954 ED 5C       0043*  	mlt de
0B0956 08          0044*  	ex af,af' ; save multiplier, restore carry
0B0957 83          0045*  	add a,e ; add carry
0B0958 67          0046*  	ld h,a ; product middle byte
0B0959 7A          0047*  	ld a,d ; carry
0B095A 08          0048*  	ex af,af' ; save carry, restore multiplier
0B095B             0049*  ; upper byte
0B095B E5          0050*  	push hl
0B095C 33          0051*  	inc sp
0B095D D1          0052*  	pop de ; d = hlu
0B095E 3B          0053*  	dec sp
0B095F 5F          0054*  	ld e,a
0B0960 ED 5C       0055*  	mlt de
0B0962 08          0056*  	ex af,af' ; restore carry
0B0963 8B          0057*  	adc a,e ; add carry
0B0964 22 75 09 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0968 32 77 09 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B096C 2A 75 09 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B0970             0061*  ; highest byte
0B0970 3E 00       0062*  	ld a,0 ; preserve carry flag
0B0972 8A          0063*  	adc a,d ; product highest byte
0B0973 D1          0064*  	pop de ; restore de
0B0974 C9          0065*  	ret
0B0975             0066*  @scratch: ds 3
0B0978             0067*  
0B0978             0068*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0978             0069*  ; operation: UHL * UDE --> umul24x24out
0B0978             0070*  umul24x24:
0B0978 FD 21 D0 09 0071*  	ld iy,umul24x24out ; point to output buffer
       0B          
0B097D C5          0072*  	push bc
0B097E 01 00 00 00 0073*  	ld bc,0
0B0982 FD 0F 00    0074*  	ld (iy),bc
0B0985 FD 0F 03    0075*  	ld (iy+3),bc
0B0988 C1          0076*  	pop bc
0B0989             0077*  
0B0989             0078*  ; STEP 1: UHL * E
0B0989 7B          0079*  	ld a,e
0B098A E5          0080*  	push hl
0B098B CD 49 09 0B 0081*  	call umul24x8
0B098F FD 2F 00    0082*  	ld (iy+0),hl
0B0992 FD 77 03    0083*  	ld (iy+3),a
0B0995             0084*  
0B0995             0085*  ; STEP 2: UHL * D
0B0995 E1          0086*  	pop hl
0B0996 E5          0087*  	push hl
0B0997 7A          0088*  	ld a,d
0B0998 CD 49 09 0B 0089*  	call umul24x8
0B099C CD A9 09 0B 0090*  	call @accumulate
0B09A0             0091*  
0B09A0             0092*  ; STEP 3: UHL * DEU
0B09A0 E1          0093*  	pop hl
0B09A1 D5          0094*  	push de
0B09A2 33          0095*  	inc sp
0B09A3 F1          0096*  	pop af
0B09A4 3B          0097*  	dec sp
0B09A5 CD 49 09 0B 0098*  	call umul24x8
0B09A9             0099*  
0B09A9             0100*  @accumulate:
0B09A9 FD 23       0101*  	inc iy
0B09AB             0102*  ; highest byte of product to carry
0B09AB FD 77 03    0103*  	ld (iy+3),a
0B09AE             0104*  ; low byte of product
0B09AE 7D          0105*  	ld a,l
0B09AF FD 86 00    0106*  	add a,(iy+0)
0B09B2 FD 77 00    0107*  	ld (iy+0),a
0B09B5             0108*  ; high byte of product
0B09B5 7C          0109*  	ld a,h
0B09B6 FD 8E 01    0110*  	adc a,(iy+1)
0B09B9 FD 77 01    0111*  	ld (iy+1),a
0B09BC             0112*  ; uppper byte of product
0B09BC E5          0113*  	push hl
0B09BD 33          0114*  	inc sp
0B09BE E1          0115*  	pop hl
0B09BF 3B          0116*  	dec sp
0B09C0 7C          0117*  	ld a,h
0B09C1 FD 8E 02    0118*  	adc a,(iy+2)
0B09C4 FD 77 02    0119*  	ld (iy+2),a
0B09C7             0120*  ; carry
0B09C7 3E 00       0121*  	ld a,0 ; preserve flags
0B09C9 FD 8E 03    0122*  	adc a,(iy+3)
0B09CC FD 77 03    0123*  	ld (iy+3),a
0B09CF C9          0124*  	ret
0B09D0             0125*  umul24x24out: ds 6 ; output buffer
0B09D6             0126*  
0B09D6             0127*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B09D6             0128*  umul168:
0B09D6 CD 78 09 0B 0129*  	call umul24x24
0B09DA FD 27 FF    0130*  	ld hl,(iy-1)
0B09DD C9          0131*  	ret
0B09DE             0132*  
0B09DE             0133*  ; smul168:	UH.L * UD.E --> UH.L (signed)
0B09DE             0134*  smul168:
0B09DE             0135*  ; make everything positive and store sign flags
0B09DE CD 33 08 0B 0136*  	call hlu_abs
0B09E2 F5          0137*  	push af
0B09E3 EB          0138*  	ex de,hl
0B09E4 CD 33 08 0B 0139*  	call hlu_abs
0B09E8 EB          0140*  	ex de,hl
0B09E9 F5          0141*  	push af
0B09EA             0142*  ; do the division
0B09EA CD D6 09 0B 0143*      call umul168 ; hl = product
0B09EE             0144*  ; adjust sign of result
0B09EE F1          0145*  	pop af ; sign de
0B09EF FA FA 09 0B 0146*  	jp m,@de_neg
0B09F3 F1          0147*  	pop af ; sign hl
0B09F4 F0          0148*  	ret p ; both positive, nothing to do
0B09F5             0149*  @hl_neg:
0B09F5 CD 43 08 0B 0150*      call neg_hlu ; de pos, hl neg, result is negative
0B09F9 C9          0151*      ret
0B09FA             0152*  @de_neg:
0B09FA F1          0153*  	pop af
0B09FB F8          0154*  	ret m ; both negative, nothing to do
0B09FC CD 43 08 0B 0155*  	call neg_hlu ; result is negative
0B0A00 C9          0156*  	ret
0B0A01             0157*  
0B0A01             0158*  ;------------------------------------------------------------------------
0B0A01             0159*  ;  arith24.inc
0B0A01             0160*  ;  24-bit ez80 arithmetic routines
0B0A01             0161*  ;  Copyright (c) Shawn Sijnstra 2024
0B0A01             0162*  ;  MIT license
0B0A01             0163*  ;
0B0A01             0164*  ;  This library was created as a tool to help make ez80
0B0A01             0165*  ;  24-bit native assembly routines for simple mathematical problems
0B0A01             0166*  ;  more widely available.
0B0A01             0167*  ;
0B0A01             0168*  ;------------------------------------------------------------------------
0B0A01             0169*  
0B0A01             0170*  ;------------------------------------------------------------------------
0B0A01             0171*  ; umul24:	HL = HL*DE (unsigned)
0B0A01             0172*  ; Preserves AF, BC, DE
0B0A01             0173*  ; Uses a fast multiply routine.
0B0A01             0174*  ;------------------------------------------------------------------------
0B0A01             0175*  umul24:
0B0A01 D5          0176*  	push	DE
0B0A02 C5          0177*  	push	BC
0B0A03 F5          0178*  	push	AF
0B0A04 E5          0179*  	push	HL
0B0A05 C1          0180*  	pop		BC
0B0A06 3E 18       0181*      ld	 	a, 24 ; No. of bits to process
0B0A08 21 00 00 00 0182*      ld	 	hl, 0 ; Result
0B0A0C             0183*  umul24_lp:
0B0A0C 29          0184*  	add	hl,hl
0B0A0D EB          0185*  	ex	de,hl
0B0A0E 29          0186*  	add	hl,hl
0B0A0F EB          0187*  	ex	de,hl
0B0A10 30 01       0188*  	jr	nc,umul24_nc
0B0A12 09          0189*  	add	hl,bc
0B0A13             0190*  umul24_nc:
0B0A13 3D          0191*  	dec	a
0B0A14 20 F6       0192*  	jr	nz,umul24_lp
0B0A16 F1          0193*  	pop	af
0B0A17 C1          0194*  	pop	bc
0B0A18 D1          0195*  	pop	de
0B0A19 C9          0196*  	ret
0B0A1A             0197*  
0B0A1A             0198*  ;------------------------------------------------------------------------
0B0A1A             0199*  ; udiv24
0B0A1A             0200*  ; Unsigned 24-bit division
0B0A1A             0201*  ; HLU / DEU --> DEU rem HLU
0B0A1A             0202*  ; Uses AF BC DE HL
0B0A1A             0203*  ; Uses Restoring Division algorithm
0B0A1A             0204*  ;------------------------------------------------------------------------
0B0A1A             0205*  
0B0A1A             0206*  udiv24:
0B0A1A E5          0207*  	push	hl
0B0A1B C1          0208*  	pop		bc	;move dividend to BCU
0B0A1C 21 00 00 00 0209*  	ld		hl,0	;result
0B0A20 A7          0210*  	and		a
0B0A21 ED 52       0211*  	sbc		hl,de	;test for div by 0
0B0A23 C8          0212*  	ret		z		;it's zero, carry flag is clear
0B0A24 19          0213*  	add		hl,de	;HL is 0 again
0B0A25 3E 18       0214*  	ld		a,24	;number of loops through.
0B0A27             0215*  udiv1:
0B0A27 C5          0216*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0A28 E3          0217*  	ex		(sp),hl
0B0A29 37          0218*  	scf
0B0A2A ED 6A       0219*  	adc	hl,hl
0B0A2C E3          0220*  	ex	(sp),hl
0B0A2D C1          0221*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0A2E             0222*  
0B0A2E ED 6A       0223*  	adc	hl,hl
0B0A30 A7          0224*  	and	a		;is this the bug
0B0A31 ED 52       0225*  	sbc	hl,de
0B0A33 30 02       0226*  	jr	nc,udiv2
0B0A35 19          0227*  	add	hl,de
0B0A36             0228*  ;	dec	c
0B0A36 0B          0229*  	dec	bc
0B0A37             0230*  udiv2:
0B0A37 3D          0231*  	dec	a
0B0A38 20 ED       0232*  	jr	nz,udiv1
0B0A3A 37          0233*  	scf		;flag used for div0 error
0B0A3B C5          0234*  	push	bc
0B0A3C D1          0235*  	pop		de	;remainder
0B0A3D C9          0236*  	ret
0B0A3E             0237*  
0B0A3E             0238*  
0B0A3E             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B0A3E             0240*  ; perform unsigned division of 16.8 fixed place values
0B0A3E             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B0A3E             0242*  udiv168:
0B0A3E             0243*  ; back up divisor
0B0A3E ED 53 75 0A 0244*  	ld (@ude),de
       0B          
0B0A43             0245*  ; get the 16-bit integer part of the quotient
0B0A43 CD 1A 0A 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B0A47             0247*  ; load quotient to upper three bytes of output
0B0A47 ED 53 7C 0A 0248*      ld (div168_out+1),de
       0B          
0B0A4C             0249*  @div256:
0B0A4C             0250*  ; multiply remainder by 256
0B0A4C             0251*  	hlu_mul256
0B0A4C 29          0001*M         add hl,hl ; * 2
0B0A4D 29          0002*M         add hl,hl ; * 4
0B0A4E 29          0003*M         add hl,hl ; * 8
0B0A4F 29          0004*M         add hl,hl ; * 16
0B0A50 29          0005*M         add hl,hl ; * 32
0B0A51 29          0006*M         add hl,hl ; * 64
0B0A52 29          0007*M         add hl,hl ; * 128
0B0A53 29          0008*M         add hl,hl ; * 256
0B0A54             0252*  ; skip fractional computation if remainder is zero
0B0A54             0253*      sign_hlu
0B0A54 19          0001*M         add hl,de
0B0A55 B7          0002*M         or a
0B0A56 ED 52       0003*M         sbc hl,de
0B0A58 20 03       0254*      jr nz,@div_frac
0B0A5A AF          0255*      xor a
0B0A5B 18 0A       0256*      jr @write_frac
0B0A5D             0257*  ; now divide the shifted remainder by the divisor
0B0A5D             0258*  @div_frac:
0B0A5D ED 5B 75 0A 0259*  	ld de,(@ude) ; get back divisor
       0B          
0B0A62 CD 1A 0A 0B 0260*      call udiv24 ; de = quotient, hl = remainder
0B0A66             0261*  ; load low byte of quotient to low byte of output
0B0A66 7B          0262*      ld a,e
0B0A67             0263*  @write_frac:
0B0A67 32 7B 0A 0B 0264*      ld (div168_out),a
0B0A6B             0265*  ; load de with return value
0B0A6B ED 5B 7B 0A 0266*      ld de,(div168_out)
       0B          
0B0A70             0267*  ; load a with any overflow
0B0A70 3A 7E 0A 0B 0268*      ld a,(div168_out+3)
0B0A74 C9          0269*      ret ; ud.e is the 16.8 result
0B0A75             0270*  @ude: ds 6
0B0A7B             0271*  div168_out: ds 4 ; the extra byte is for overflow
0B0A7F             0272*  
0B0A7F             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B0A7F             0274*  ; perform signed division of 16.8 fixed place values
0B0A7F             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B0A7F             0276*  sdiv168:
0B0A7F             0277*  ; make everything positive and store sign flags
0B0A7F CD 33 08 0B 0278*  	call hlu_abs
0B0A83 F5          0279*  	push af
0B0A84 EB          0280*  	ex de,hl
0B0A85 CD 33 08 0B 0281*  	call hlu_abs
0B0A89 EB          0282*  	ex de,hl
0B0A8A F5          0283*  	push af
0B0A8B             0284*  ; do the division
0B0A8B CD 3E 0A 0B 0285*      call udiv168 ; de = quotient, hl = remainder
0B0A8F             0286*  ; adjust sign of result
0B0A8F F1          0287*  	pop af ; sign de
0B0A90 FA 9D 0A 0B 0288*  	jp m,@de_neg
0B0A94 F1          0289*  	pop af ; sign hl
0B0A95 F0          0290*  	ret p ; both positive, nothing to do
0B0A96             0291*  @hl_neg:
0B0A96 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0B0A97 CD 43 08 0B 0293*      call neg_hlu ; de pos, hl neg, result is negative
0B0A9B EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0B0A9C C9          0295*      ret
0B0A9D             0296*  @de_neg:
0B0A9D F1          0297*  	pop af
0B0A9E F8          0298*  	ret m ; both negative, nothing to do
0B0A9F EB          0299*      ex de,hl ; hl = quotient, de = remainder
0B0AA0 CD 43 08 0B 0300*  	call neg_hlu ; result is negative
0B0AA4 EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0B0AA5 C9          0302*  	ret
0B0AA6             0303*  
0B0AA6             0304*  ;------------------------------------------------------------------------
0B0AA6             0305*  ; neg24
0B0AA6             0306*  ; Returns: HLU = 0-HLU
0B0AA6             0307*  ; preserves all other registers
0B0AA6             0308*  ;------------------------------------------------------------------------
0B0AA6             0309*  neg24:
0B0AA6 D5          0310*  	push	de
0B0AA7 EB          0311*  	ex		de,hl
0B0AA8 21 00 00 00 0312*  	ld		hl,0
0B0AAC B7          0313*  	or		a
0B0AAD ED 52       0314*  	sbc		hl,de
0B0AAF D1          0315*  	pop		de
0B0AB0 C9          0316*  	ret
0B0AB1             0317*  
0B0AB1             0318*  ;------------------------------------------------------------------------
0B0AB1             0319*  ; or_hlu_deu: 24 bit bitwise OR
0B0AB1             0320*  ; Returns: hlu = hlu OR deu
0B0AB1             0321*  ; preserves all other registers
0B0AB1             0322*  ;------------------------------------------------------------------------
0B0AB1             0323*  or_hlu_deu:
0B0AB1 22 3C 0B 0B 0324*  	ld	(bitbuf1),hl
0B0AB5 ED 53 3F 0B 0325*  	ld	(bitbuf2),de
       0B          
0B0ABA D5          0326*  	push	de	;preserve DEU
0B0ABB C5          0327*  	push	bc	;preserve BCU
0B0ABC 06 03       0328*  	ld		b,3
0B0ABE 21 3C 0B 0B 0329*  	ld	hl,bitbuf1
0B0AC2 11 3C 0B 0B 0330*  	ld	de,bitbuf1
0B0AC6             0331*  orloop_24:
0B0AC6 1A          0332*  	ld	a,(de)
0B0AC7 B6          0333*  	or	(hl)
0B0AC8 12          0334*  	ld	(de),a
0B0AC9 13          0335*  	inc	de
0B0ACA 23          0336*  	inc	hl
0B0ACB 10 F9       0337*  	djnz	orloop_24
0B0ACD 2A 3F 0B 0B 0338*  	ld	hl,(bitbuf2)
0B0AD1 C1          0339*  	pop		bc	;restore BC
0B0AD2 D1          0340*  	pop		de	;restore DE
0B0AD3             0341*  
0B0AD3             0342*  ;------------------------------------------------------------------------
0B0AD3             0343*  ; and_hlu_deu: 24 bit bitwise AND
0B0AD3             0344*  ; Returns: hlu = hlu AND deu
0B0AD3             0345*  ; preserves all other registers
0B0AD3             0346*  ;------------------------------------------------------------------------
0B0AD3             0347*  and_hlu_deu:
0B0AD3 22 3C 0B 0B 0348*  	ld	(bitbuf1),hl
0B0AD7 ED 53 3F 0B 0349*  	ld	(bitbuf2),de
       0B          
0B0ADC D5          0350*  	push	de	;preserve DEU
0B0ADD C5          0351*  	push	bc	;preserve BCU
0B0ADE 06 03       0352*  	ld		b,3
0B0AE0 21 3C 0B 0B 0353*  	ld	hl,bitbuf1
0B0AE4 11 3C 0B 0B 0354*  	ld	de,bitbuf1
0B0AE8             0355*  andloop_24:
0B0AE8 1A          0356*  	ld	a,(de)
0B0AE9 A6          0357*  	and	(hl)
0B0AEA 12          0358*  	ld	(de),a
0B0AEB 13          0359*  	inc	de
0B0AEC 23          0360*  	inc	hl
0B0AED 10 F9       0361*  	djnz	andloop_24
0B0AEF 2A 3F 0B 0B 0362*  	ld	hl,(bitbuf2)
0B0AF3 C1          0363*  	pop		bc	;restore BC
0B0AF4 D1          0364*  	pop		de	;restore DE
0B0AF5             0365*  
0B0AF5             0366*  ;------------------------------------------------------------------------
0B0AF5             0367*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0AF5             0368*  ; Returns: hlu = hlu XOR deu
0B0AF5             0369*  ; preserves all other registers
0B0AF5             0370*  ;------------------------------------------------------------------------
0B0AF5             0371*  xor_hlu_deu:
0B0AF5 22 3C 0B 0B 0372*  	ld	(bitbuf1),hl
0B0AF9 ED 53 3F 0B 0373*  	ld	(bitbuf2),de
       0B          
0B0AFE D5          0374*  	push	de	;preserve DEU
0B0AFF C5          0375*  	push	bc	;preserve BCU
0B0B00 06 03       0376*  	ld		b,3
0B0B02 21 3C 0B 0B 0377*  	ld	hl,bitbuf1
0B0B06 11 3C 0B 0B 0378*  	ld	de,bitbuf1
0B0B0A             0379*  xorloop_24:
0B0B0A 1A          0380*  	ld	a,(de)
0B0B0B AE          0381*  	xor	(hl)
0B0B0C 12          0382*  	ld	(de),a
0B0B0D 13          0383*  	inc	de
0B0B0E 23          0384*  	inc	hl
0B0B0F 10 F9       0385*  	djnz	xorloop_24
0B0B11 2A 3F 0B 0B 0386*  	ld	hl,(bitbuf2)
0B0B15 C1          0387*  	pop		bc	;restore BC
0B0B16 D1          0388*  	pop		de	;restore DE
0B0B17             0389*  
0B0B17             0390*  ;------------------------------------------------------------------------
0B0B17             0391*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B0B17             0392*  ; Returns: hlu = hlu << deu
0B0B17             0393*  ;		   de = 0
0B0B17             0394*  ; NOTE: only considers deu up to 16 bits.
0B0B17             0395*  ; preserves all other registers
0B0B17             0396*  ;------------------------------------------------------------------------
0B0B17             0397*  shl_hlu:
0B0B17 7A          0398*  	ld		a,d		;up to 16 bit.
0B0B18 B3          0399*  	or		e
0B0B19 C8          0400*  	ret		z		;we're done
0B0B1A 29          0401*  	add		hl,hl	;shift HLU left
0B0B1B 1B          0402*  	dec		de
0B0B1C 18 F9       0403*  	jr		shl_hlu
0B0B1E             0404*  
0B0B1E             0405*  ;------------------------------------------------------------------------
0B0B1E             0406*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B0B1E             0407*  ; Returns: hlu = hlu >> deu
0B0B1E             0408*  ;		   de = 0
0B0B1E             0409*  ; NOTE: only considers deu up to 16 bits.
0B0B1E             0410*  ; preserves all other registers
0B0B1E             0411*  ;------------------------------------------------------------------------
0B0B1E             0412*  shr_hlu:
0B0B1E 22 3C 0B 0B 0413*  	ld		(bitbuf1),hl
0B0B22 21 3E 0B 0B 0414*  	ld		hl,bitbuf1+2
0B0B26             0415*  shr_loop:
0B0B26 7A          0416*  	ld		a,d		;up to 16 bit.
0B0B27 B3          0417*  	or		e
0B0B28 28 0D       0418*  	jr		z,shr_done		;we're done
0B0B2A             0419*  ;carry is clear from or instruction
0B0B2A CB 1E       0420*  	rr		(hl)
0B0B2C 2B          0421*  	dec		hl
0B0B2D CB 1E       0422*  	rr		(hl)
0B0B2F 2B          0423*  	dec		hl
0B0B30 CB 1E       0424*  	rr		(hl)
0B0B32 23          0425*  	inc		hl
0B0B33 23          0426*  	inc		hl
0B0B34 1B          0427*  	dec		de
0B0B35 18 EF       0428*  	jr		shr_loop
0B0B37             0429*  shr_done:
0B0B37 2A 3C 0B 0B 0430*  	ld		hl,(bitbuf1)	;collect result
0B0B3B C9          0431*  	ret
0B0B3C             0432*  
0B0B3C             0433*  ;------------------------------------------------------------------------
0B0B3C             0434*  ; Scratch area for calculations
0B0B3C             0435*  ;------------------------------------------------------------------------
0B0B3C 00 00 00    0436*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B0B3F 00 00 00    0437*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0B42             0438*  
0B0B42             0439*  ; ========== FROM maths24.inc ==========
0B0B42             0440*  
0B0B42             0441*  ; Expects  ADL mode
0B0B42             0442*  ; Inputs:  UH.L
0B0B42             0443*  ; Outputs: UH.L is the 16.8 square root
0B0B42             0444*  ;          UD.E is the difference inputHL-DE^2
0B0B42             0445*  ;          c flag reset
0B0B42             0446*  sqrt168:
0B0B42 CD 4C 0B 0B 0447*      call sqrt24
0B0B46 EB          0448*      ex de,hl
0B0B47 29          0449*      add hl,hl
0B0B48 29          0450*      add hl,hl
0B0B49 29          0451*      add hl,hl
0B0B4A 29          0452*      add hl,hl
0B0B4B C9          0453*      ret
0B0B4C             0454*  
0B0B4C             0455*  ; Expects  ADL mode
0B0B4C             0456*  ; Inputs:  HL
0B0B4C             0457*  ; Outputs: DE is the integer square root
0B0B4C             0458*  ;          HL is the difference inputHL-DE^2
0B0B4C             0459*  ;          c flag reset
0B0B4C             0460*  sqrt24:
0B0B4C AF          0461*      xor a
0B0B4D 45          0462*      ld b,l
0B0B4E C5          0463*      push bc
0B0B4F 47          0464*      ld b,a
0B0B50 57          0465*      ld d,a
0B0B51 4F          0466*      ld c,a
0B0B52 6F          0467*      ld l,a
0B0B53 5F          0468*      ld e,a
0B0B54             0469*  
0B0B54             0470*      ;Iteration 1
0B0B54 29          0471*      add hl,hl
0B0B55 CB 11       0472*      rl c
0B0B57 29          0473*      add hl,hl
0B0B58 CB 11       0474*      rl c
0B0B5A 91          0475*      sub c
0B0B5B 30 04       0476*      jr nc,$+6
0B0B5D 1C          0477*      inc e
0B0B5E 1C          0478*      inc e
0B0B5F 2F          0479*      cpl
0B0B60 4F          0480*      ld c,a
0B0B61             0481*  
0B0B61             0482*      ;Iteration 2
0B0B61 29          0483*      add hl,hl
0B0B62 CB 11       0484*      rl c
0B0B64 29          0485*      add hl,hl
0B0B65 CB 11       0486*      rl c
0B0B67 CB 13       0487*      rl e
0B0B69 7B          0488*      ld a,e
0B0B6A 91          0489*      sub c
0B0B6B 30 04       0490*      jr nc,$+6
0B0B6D 1C          0491*      inc e
0B0B6E 1C          0492*      inc e
0B0B6F 2F          0493*      cpl
0B0B70 4F          0494*      ld c,a
0B0B71             0495*  
0B0B71             0496*      ;Iteration 3
0B0B71 29          0497*      add hl,hl
0B0B72 CB 11       0498*      rl c
0B0B74 29          0499*      add hl,hl
0B0B75 CB 11       0500*      rl c
0B0B77 CB 13       0501*      rl e
0B0B79 7B          0502*      ld a,e
0B0B7A 91          0503*      sub c
0B0B7B 30 04       0504*      jr nc,$+6
0B0B7D 1C          0505*      inc e
0B0B7E 1C          0506*      inc e
0B0B7F 2F          0507*      cpl
0B0B80 4F          0508*      ld c,a
0B0B81             0509*  
0B0B81             0510*      ;Iteration 4
0B0B81 29          0511*      add hl,hl
0B0B82 CB 11       0512*      rl c
0B0B84 29          0513*      add hl,hl
0B0B85 CB 11       0514*      rl c
0B0B87 CB 13       0515*      rl e
0B0B89 7B          0516*      ld a,e
0B0B8A 91          0517*      sub c
0B0B8B 30 04       0518*      jr nc,$+6
0B0B8D 1C          0519*      inc e
0B0B8E 1C          0520*      inc e
0B0B8F 2F          0521*      cpl
0B0B90 4F          0522*      ld c,a
0B0B91             0523*  
0B0B91             0524*      ;Iteration 5
0B0B91 29          0525*      add hl,hl
0B0B92 CB 11       0526*      rl c
0B0B94 29          0527*      add hl,hl
0B0B95 CB 11       0528*      rl c
0B0B97 CB 13       0529*      rl e
0B0B99 7B          0530*      ld a,e
0B0B9A 91          0531*      sub c
0B0B9B 30 04       0532*      jr nc,$+6
0B0B9D 1C          0533*      inc e
0B0B9E 1C          0534*      inc e
0B0B9F 2F          0535*      cpl
0B0BA0 4F          0536*      ld c,a
0B0BA1             0537*  
0B0BA1             0538*      ;Iteration 6
0B0BA1 29          0539*      add hl,hl
0B0BA2 CB 11       0540*      rl c
0B0BA4 29          0541*      add hl,hl
0B0BA5 CB 11       0542*      rl c
0B0BA7 CB 13       0543*      rl e
0B0BA9 7B          0544*      ld a,e
0B0BAA 91          0545*      sub c
0B0BAB 30 04       0546*      jr nc,$+6
0B0BAD 1C          0547*      inc e
0B0BAE 1C          0548*      inc e
0B0BAF 2F          0549*      cpl
0B0BB0 4F          0550*      ld c,a
0B0BB1             0551*  
0B0BB1             0552*      ;Iteration 7
0B0BB1 29          0553*      add hl,hl
0B0BB2 CB 11       0554*      rl c
0B0BB4 29          0555*      add hl,hl
0B0BB5 CB 11       0556*      rl c
0B0BB7 CB 10       0557*      rl b
0B0BB9 EB          0558*      ex de,hl
0B0BBA 29          0559*      add hl,hl
0B0BBB E5          0560*      push hl
0B0BBC ED 42       0561*      sbc hl,bc
0B0BBE 30 06       0562*      jr nc,$+8
0B0BC0 7C          0563*      ld a,h
0B0BC1 2F          0564*      cpl
0B0BC2 47          0565*      ld b,a
0B0BC3 7D          0566*      ld a,l
0B0BC4 2F          0567*      cpl
0B0BC5 4F          0568*      ld c,a
0B0BC6 E1          0569*      pop hl
0B0BC7 30 02       0570*      jr nc,$+4
0B0BC9 23          0571*      inc hl
0B0BCA 23          0572*      inc hl
0B0BCB EB          0573*      ex de,hl
0B0BCC             0574*  
0B0BCC             0575*      ;Iteration 8
0B0BCC 29          0576*      add hl,hl
0B0BCD 69          0577*      ld l,c
0B0BCE 60          0578*      ld h,b
0B0BCF ED 6A       0579*      adc hl,hl
0B0BD1 ED 6A       0580*      adc hl,hl
0B0BD3 EB          0581*      ex de,hl
0B0BD4 29          0582*      add hl,hl
0B0BD5 ED 52       0583*      sbc hl,de
0B0BD7 19          0584*      add hl,de
0B0BD8 EB          0585*      ex de,hl
0B0BD9 30 04       0586*      jr nc,$+6
0B0BDB ED 52       0587*      sbc hl,de
0B0BDD 13          0588*      inc de
0B0BDE 13          0589*      inc de
0B0BDF             0590*  
0B0BDF             0591*      ;Iteration 9
0B0BDF F1          0592*      pop af
0B0BE0 17          0593*      rla
0B0BE1 ED 6A       0594*      adc hl,hl
0B0BE3 17          0595*      rla
0B0BE4 ED 6A       0596*      adc hl,hl
0B0BE6 EB          0597*      ex de,hl
0B0BE7 29          0598*      add hl,hl
0B0BE8 ED 52       0599*      sbc hl,de
0B0BEA 19          0600*      add hl,de
0B0BEB EB          0601*      ex de,hl
0B0BEC 30 04       0602*      jr nc,$+6
0B0BEE ED 52       0603*      sbc hl,de
0B0BF0 13          0604*      inc de
0B0BF1 13          0605*      inc de
0B0BF2             0606*  
0B0BF2             0607*      ;Iteration 10
0B0BF2 17          0608*      rla
0B0BF3 ED 6A       0609*      adc hl,hl
0B0BF5 17          0610*      rla
0B0BF6 ED 6A       0611*      adc hl,hl
0B0BF8 EB          0612*      ex de,hl
0B0BF9 29          0613*      add hl,hl
0B0BFA ED 52       0614*      sbc hl,de
0B0BFC 19          0615*      add hl,de
0B0BFD EB          0616*      ex de,hl
0B0BFE 30 04       0617*      jr nc,$+6
0B0C00 ED 52       0618*      sbc hl,de
0B0C02 13          0619*      inc de
0B0C03 13          0620*      inc de
0B0C04             0621*  
0B0C04             0622*      ;Iteration 11
0B0C04 17          0623*      rla
0B0C05 ED 6A       0624*      adc hl,hl
0B0C07 17          0625*      rla
0B0C08 ED 6A       0626*      adc hl,hl
0B0C0A EB          0627*      ex de,hl
0B0C0B 29          0628*      add hl,hl
0B0C0C ED 52       0629*      sbc hl,de
0B0C0E 19          0630*      add hl,de
0B0C0F EB          0631*      ex de,hl
0B0C10 30 04       0632*      jr nc,$+6
0B0C12 ED 52       0633*      sbc hl,de
0B0C14 13          0634*      inc de
0B0C15 13          0635*      inc de
0B0C16             0636*  
0B0C16             0637*      ;Iteration 11
0B0C16 17          0638*      rla
0B0C17 ED 6A       0639*      adc hl,hl
0B0C19 17          0640*      rla
0B0C1A ED 6A       0641*      adc hl,hl
0B0C1C EB          0642*      ex de,hl
0B0C1D 29          0643*      add hl,hl
0B0C1E ED 52       0644*      sbc hl,de
0B0C20 19          0645*      add hl,de
0B0C21 EB          0646*      ex de,hl
0B0C22 30 04       0647*      jr nc,$+6
0B0C24 ED 52       0648*      sbc hl,de
0B0C26 13          0649*      inc de
0B0C27 13          0650*      inc de
0B0C28             0651*  
0B0C28 CB 1A       0652*      rr d
0B0C2A CB 1B       0653*      rr e
0B0C2C C9          0654*      ret
0B0C2D             0022       include "trig24.inc"
0B0C2D             0001*  
0B0C2D             0002*  ; convert signed angles from a 360 to 256 degree circle
0B0C2D             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0C2D             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0C2D             0005*  ; destroys: TODO
0B0C2D             0006*  deg_360_to_256:
0B0C2D D5          0007*  	push de ; preserve de
0B0C2E             0008*  ; make angle positive and store sign flag
0B0C2E CD 33 08 0B 0009*  	call hlu_abs
0B0C32 F5          0010*  	push af
0B0C33             0011*  ; multiply by 256 first to keep precision
0B0C33             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0B0C33 29          0001*M         add hl,hl ; * 2
0B0C34 29          0002*M         add hl,hl ; * 4
0B0C35 29          0003*M         add hl,hl ; * 8
0B0C36 29          0004*M         add hl,hl ; * 16
0B0C37 29          0005*M         add hl,hl ; * 32
0B0C38 29          0006*M         add hl,hl ; * 64
0B0C39 29          0007*M         add hl,hl ; * 128
0B0C3A 29          0008*M         add hl,hl ; * 256
0B0C3B             0013*  ; divide uh.l by 360
0B0C3B 11 68 01 00 0014*  	ld de,360
0B0C3F CD 1A 0A 0B 0015*  	call udiv24 ; ud.e = degrees / 360
0B0C43 EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0B0C44             0017*  ; restore sign flag and adjust output accordingly
0B0C44 F1          0018*  	pop af
0B0C45 F2 4D 0C 0B 0019*  	jp p,@pos ; positive number
0B0C49 CD 43 08 0B 0020*  	call neg_hlu
0B0C4D             0021*  @pos:
0B0C4D             0022*  ; restore de and return uh.l as the result
0B0C4D D1          0023*  	pop de
0B0C4E C9          0024*  	ret
0B0C4F             0025*  
0B0C4F             0026*  ; ; convert signed angles from a 360 to 256 degree circle
0B0C4F             0027*  ; ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0C4F             0028*  ; ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0C4F             0029*  ; ; destroys: TODO
0B0C4F             0030*  ; deg_360_to_256:
0B0C4F             0031*  ; 	push de ; preserve de
0B0C4F             0032*  ; ; make angle positive and store sign flag
0B0C4F             0033*  ; 	call hlu_abs
0B0C4F             0034*  ; 	push af
0B0C4F             0035*  ; ; ; modulo uh by 360*256 (360 degrees in 16.8 fixed format)
0B0C4F             0036*  ; ; 	ld de,360*256
0B0C4F             0037*  ; ; 	call hlu_mod
0B0C4F             0038*  ; ; multiply by 256 first to keep precision
0B0C4F             0039*  ; 	hlu_mul256 ; uh.l = uh.l * 256
0B0C4F             0040*  ; ; divide uh.l by 360
0B0C4F             0041*  ; 	ld de,360
0B0C4F             0042*  ; 	call udiv24 ; ud.e = degrees / 360
0B0C4F             0043*  ; 	ex de,hl    ; uh.l = degrees / 360
0B0C4F             0044*  ; ; restore sign flag and adjust output accordingly
0B0C4F             0045*  ; 	pop af
0B0C4F             0046*  ; 	jp p,@pos ; positive number
0B0C4F             0047*  ; 	call neg_hlu
0B0C4F             0048*  ; @pos:
0B0C4F             0049*  ; ; restore de and return uh.l as the result
0B0C4F             0050*  ; 	pop de
0B0C4F             0051*  ; 	ret
0B0C4F             0052*  
0B0C4F             0053*  ; fixed 16.8 routine
0B0C4F             0054*  ; cos(uh.l) --> uh.l
0B0C4F             0055*  ; destroys: de
0B0C4F             0056*  cos168:
0B0C4F             0057*  ; for cos we simply increment the angle by 90 degrees
0B0C4F             0058*  ; or 0x004000 in 16.8 degrees256
0B0C4F             0059*  ; which makes it a sin problem
0B0C4F 11 00 40 00 0060*      ld de,0x004000
0B0C53 19          0061*      add hl,de ; modulo 256 happens below
0B0C54             0062*  ; fall through to sin168
0B0C54             0063*  
0B0C54             0064*  ; ---------------------
0B0C54             0065*  ; fixed 16.8 routine
0B0C54             0066*  ; sin(uh.l) --> uh.l
0B0C54             0067*  ; destroys: af
0B0C54             0068*  sin168:
0B0C54             0069*  	; push de ; to be nice
0B0C54             0070*  ; handle negative angles appropriately
0B0C54 CD 33 08 0B 0071*  	call hlu_abs
0B0C58 F2 61 0C 0B 0072*  	jp p,@hlu_pos
0B0C5C 11 00 FF FF 0073*  	ld de,-256
0B0C60 19          0074*  	add hl,de
0B0C61             0075*  @hlu_pos:
0B0C61             0076*  ; get the lookup value for the integer portion of the angle
0B0C61 7D          0077*  	ld a,l ; save fractional part of the angle
0B0C62 2E 03       0078*  	ld l,3 ; multiply by 3 to get our lookup index
0B0C64 ED 6C       0079*  	mlt hl ; gosh that is handy
0B0C66 11 D8 0D 0B 0080*      ld de,sin_lut_168 ; grab the lut address
0B0C6A 19          0081*      add hl,de ; bump hl by the index
0B0C6B E5          0082*  	push hl
0B0C6C D1          0083*  	pop de ; save lut address to de
0B0C6D ED 27       0084*      ld hl,(hl) ; hl = sin(int(angle))
0B0C6F             0085*  ; interpolate the fractional part of the angle
0B0C6F B7          0086*  	or a  ; check for zero and clear carry
0B0C70 C8          0087*  	ret z ; return if no fractional part
0B0C71 EB          0088*  	ex de,hl ; hl = lut address, de = sin(int(angle))
0B0C72 23          0089*  	inc hl
0B0C73 23          0090*  	inc hl
0B0C74 23          0091*  	inc hl ; hl = lut address of next value in table
0B0C75 ED 27       0092*  	ld hl,(hl) ; hl = sin(int(angle+1))
0B0C77 ED 52       0093*  	sbc hl,de ; hl = sin(int(angle+1)0 - sin(int(angle)), de = sin(int(angle))
0B0C79 CD DE 09 0B 0094*  	call smul168 ; hl = interpolation factor * (sin(int(angle+1)) - sin(int(angle)))
0B0C7D 19          0095*  	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle)))
0B0C7E             0096*  	; pop de ; send her home unmolested
0B0C7E C9          0097*      ret ; and out
0B0C7F             0098*  
0B0C7F             0099*  ; ; 16.8 fixed inputs / outputs
0B0C7F             0100*  ; ; takes: uh.l as angle in degrees 256
0B0C7F             0101*  ; ;        ud.e as radius
0B0C7F             0102*  ; ; returns ub.c as dx, ud.e as dy
0B0C7F             0103*  ; ;        displacements from origin (0,0)
0B0C7F             0104*  ; ; destroys: everything except indexes
0B0C7F             0105*  ; polar_to_cartesian:
0B0C7F             0106*  ; ; back up input parameters
0B0C7F             0107*  ;     ld (arith24uhl), hl
0B0C7F             0108*  ;     ld (arith24ude), de
0B0C7F             0109*  ; ; compute dx = sin(uh.l) * ud.e
0B0C7F             0110*  ;     call sin168
0B0C7F             0111*  ;     push hl
0B0C7F             0112*  ;     pop bc          ; ub.c = sin(uh.l)
0B0C7F             0113*  ; 	ld de, (arith24ude)   ; get radius back
0B0C7F             0114*  ; 	call smul168    ; uh.l = ub.c * ud.e = dx
0B0C7F             0115*  ;     push hl         ; store dx for output
0B0C7F             0116*  ; ; compute dy = -cos(uh.l) * ud.e
0B0C7F             0117*  ;     ld hl, (arith24uhl)
0B0C7F             0118*  ;     call cos168
0B0C7F             0119*  ; 	call neg_hlu    ; invert dy for screen coords convention
0B0C7F             0120*  ;     push hl
0B0C7F             0121*  ;     pop bc          ; ub.c = -cos(uh.l)
0B0C7F             0122*  ;     ld de, (arith24ude)   ; get radius back
0B0C7F             0123*  ;     call smul168    ; uh.l = ub.c * ud.e = dy
0B0C7F             0124*  ;     ex de, hl       ; de = dy for output
0B0C7F             0125*  ;     pop bc          ; bc = dx for output
0B0C7F             0126*  ; ; and out
0B0C7F             0127*  ;     ret
0B0C7F             0128*  
0B0C7F             0129*  ; 16.8 fixed inputs / outputs
0B0C7F             0130*  ; takes: uh.l as angle in degrees 256
0B0C7F             0131*  ;        ud.e as radius
0B0C7F             0132*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B0C7F             0133*  ;        displacements from origin (0,0)
0B0C7F             0134*  ; destroys: everything except indexes
0B0C7F             0135*  polar_to_cartesian:
0B0C7F CD 88 02 0B 0136*  	call printNewLine ; DEBUG
0B0C83             0137*  ; back up input parameters
0B0C83 22 BE 0C 0B 0138*      ld (@angle), hl
0B0C87 ED 53 C1 0C 0139*      ld (@radius), de
       0B          
0B0C8C             0140*  ; compute dx = cos(uh.l) * ud.e
0B0C8C CD 4F 0C 0B 0141*      call cos168 ; uh.l = cos(uh.l)
0B0C90 CD 78 06 0B 0142*  	call print_hex_hl ; DEBUG
0B0C94 CD 49 04 0B 0143*  	call print_s168_hl ; DEBUG
0B0C98 ED 5B C1 0C 0144*  	ld de,(@radius)
       0B          
0B0C9D CD DE 09 0B 0145*  	call smul168 ; uh.l = dx
0B0CA1 E5          0146*      push hl
0B0CA2             0147*  ; compute dy = sin(uh.l) * ud.e
0B0CA2 2A BE 0C 0B 0148*      ld hl,(@angle)
0B0CA6 CD 54 0C 0B 0149*      call sin168 ; uh.l = sin(uh.l)
0B0CAA CD 78 06 0B 0150*  	call print_hex_hl ; DEBUG
0B0CAE CD 49 04 0B 0151*  	call print_s168_hl ; DEBUG
0B0CB2 ED 5B C1 0C 0152*      ld de,(@radius)
       0B          
0B0CB7 CD DE 09 0B 0153*      call smul168    ; uh.l = dy
0B0CBB EB          0154*      ex de,hl       ; de = dy for output
0B0CBC C1          0155*      pop bc          ; bc = dx for output
0B0CBD             0156*  ; and out
0B0CBD C9          0157*      ret
0B0CBE             0158*  @angle: ds 3
0B0CC1             0159*  @radius: ds 3
0B0CC4             0160*  
0B0CC4             0161*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0CC4             0162*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0CC4             0163*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0CC4             0164*  ;         also populates scratch locations dx168 and dy168
0B0CC4             0165*  ; destroys: a,hl,bc,de
0B0CC4             0166*  dxy168:
0B0CC4             0167*  ; compute dx = x1-x0
0B0CC4 AF          0168*      xor a ; clear carry
0B0CC5 DD E5       0169*      push ix ; move ix to hl via the stack
0B0CC7 E1          0170*      pop hl ; hl = x1
0B0CC8 ED 42       0171*      sbc hl,bc ; hl = dx
0B0CCA 22 1F 0D 0B 0172*      ld (dx168),hl ; dx to scratch
0B0CCE             0173*  ; compute dy = y1-y0
0B0CCE AF          0174*      xor a ; clear carry
0B0CCF FD E5       0175*      push iy ; move iy to hl via the stack
0B0CD1 E1          0176*      pop hl ; hl = y1
0B0CD2 ED 52       0177*      sbc hl,de ; hl = dy
0B0CD4 22 25 0D 0B 0178*      ld (dy168),hl ; dy to scratch
0B0CD8             0179*  ; populate output registers and return
0B0CD8 EB          0180*      ex de,hl        ; ud.e = dy
0B0CD9 ED 4B 1F 0D 0181*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0CDE C9          0182*      ret
0B0CDF             0183*  
0B0CDF             0184*  ; compute the euclidian distance between two cartesian coordinates
0B0CDF             0185*  ; using the formula d = sqrt(dx^2+dy^2
0B0CDF             0186*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0CDF             0187*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0CDF             0188*  ; output; uh.l is the 16.8 fixed format distance
0B0CDF             0189*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0CDF             0190*  ; destroys: a,hl,bc,de
0B0CDF             0191*  distance168:
0B0CDF             0192*  ; compute dx = x1-x0
0B0CDF AF          0193*      xor a ; clear carry
0B0CE0 DD E5       0194*      push ix ; move ix to hl via the stack
0B0CE2 E1          0195*      pop hl ; hl = x1
0B0CE3 ED 42       0196*      sbc hl,bc ; hl = dx
0B0CE5 22 1F 0D 0B 0197*      ld (dx168),hl ; dx to scratch
0B0CE9             0198*  ; ; test dx for overflow
0B0CE9             0199*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0CE9             0200*  ; 	ex de,hl
0B0CE9             0201*  ; 	sbc hl,de ; test for overflow
0B0CE9             0202*  ; 	push af ; carry indicates overflow
0B0CE9             0203*  ; compute dy = y1-y0
0B0CE9 AF          0204*      xor a ; clear carry
0B0CEA FD E5       0205*      push iy ; move iy to hl via the stack
0B0CEC E1          0206*      pop hl ; hl = y1
0B0CED ED 52       0207*      sbc hl,de ; hl = dy
0B0CEF 22 25 0D 0B 0208*      ld (dy168),hl ; dy to scratch
0B0CF3             0209*  ; ; test dy for overflow
0B0CF3             0210*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0CF3             0211*  ; 	ex de,hl
0B0CF3             0212*  ; 	sbc hl,de ; test for overflow
0B0CF3             0213*  ; 	push af ; carry indicates overflow
0B0CF3             0214*  ; compute dy^2
0B0CF3 2A 25 0D 0B 0215*  	ld hl,(dy168)
0B0CF7 CD 33 08 0B 0216*      call hlu_abs  ; make dy positive so we can use unsigned multiply
0B0CFB             0217*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0CFB E5          0218*      push hl ; load hl/2 to bc via the stack
0B0CFC C1          0219*      pop bc ; bc = dy/2
0B0CFD EB          0220*      ex de,hl ; de = dy/2
0B0CFE CD D6 09 0B 0221*      call umul168 ; uh.l = dy^2/2
0B0D02 E5          0222*      push hl ; dy^2/2 to the stack
0B0D03             0223*  ; compute dx^2
0B0D03 2A 1F 0D 0B 0224*      ld hl,(dx168) ; get back dx
0B0D07 CD 33 08 0B 0225*      call hlu_abs  ; make dx positive so we can use unsigned multiply
0B0D0B             0226*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0D0B E5          0227*      push hl ; load hl/2 to bc via the stack
0B0D0C C1          0228*      pop bc ; bc = dx/2
0B0D0D EB          0229*      ex de,hl ; de = dx/2
0B0D0E CD D6 09 0B 0230*      call umul168 ; uh.l = dx^2/2
0B0D12             0231*  ; commpute dy^2+dx^2
0B0D12 D1          0232*      pop de ; get back dx^2/2
0B0D13 19          0233*      add hl,de ; hl = dx^2/2+dy^2/2
0B0D14             0234*  ; compute sqrt(dx^2/2+dy^2/2)
0B0D14 CD 42 0B 0B 0235*      call sqrt168 ; uh.l = distance/2
0B0D18             0236*      ; add hl,hl ; hl = distance
0B0D18             0237*  ; ; check for overflow
0B0D18             0238*  ; 	pop af ; get back the overflow flags
0B0D18             0239*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0D18             0240*  ; 	ld b,a ; save the overflow flag
0B0D18             0241*  ; 	pop af ; get back the overflow flags
0B0D18             0242*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0D18             0243*  ; 	add a,b ; if a != 0 then we had overflow
0B0D18             0244*  ;     ret z ; no overflow we're done
0B0D18             0245*  ; @overflow:
0B0D18             0246*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0D18 C9          0247*  	ret
0B0D19             0248*  @scratch: ds 6
0B0D1F             0249*  dx168: ds 6
0B0D25             0250*  dy168: ds 6
0B0D2B             0251*  
0B0D2B             0252*  ; atan2(ub.c,ud.e) --> uh.l
0B0D2B             0253*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0D2B             0254*  ;   whether inputs are integers or fractional doesn't matter
0B0D2B             0255*  ;   so long as the sign bit of the upper byte is correct
0B0D2B             0256*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0D2B             0257*  ; angles are COMPASS HEADINGS based on
0B0D2B             0258*  ; screen coordinate conventions,where the y axis is flipped
0B0D2B             0259*  ; #E0 315      0       45 #20
0B0D2B             0260*  ;        -x,-y | +x,-y
0B0D2B             0261*  ; #C0 270------+------ 90 #40
0B0D2B             0262*  ;        -x,+y | +x,+y
0B0D2B             0263*  ; #A0 225   180 #80   135 #60
0B0D2B             0264*  atan2_168game:
0B0D2B             0265*  ; get signs and make everything positive
0B0D2B             0266*  ; get abs(x) and store its original sign
0B0D2B C5          0267*      push bc
0B0D2C E1          0268*      pop hl
0B0D2D CD 33 08 0B 0269*      call hlu_abs ; if x was negative this also sets the sign flag
0B0D31 E5          0270*      push hl ; store abs(x)
0B0D32 C1          0271*      pop bc ; bc = abs(x)
0B0D33 F5          0272*      push af ; store sign of x
0B0D34             0273*  ; get abs(y) and store its original sign
0B0D34 EB          0274*      ex de,hl ; hl = y
0B0D35 CD 33 08 0B 0275*      call hlu_abs ; if y was negative this also sets the sign flag
0B0D39 EB          0276*      ex de,hl ; de = abs(y)
0B0D3A F5          0277*      push af ; store sign of y
0B0D3B             0278*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0D3B             0279*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B0D3B AF          0280*      xor a ; clear the carry flag
0B0D3C D5          0281*      push de
0B0D3D E1          0282*      pop hl
0B0D3E ED 42       0283*      sbc hl,bc
0B0D40 F5          0284*      push af ; save sign of de - bc
0B0D41 F2 4A 0D 0B 0285*      jp p,@1 ; bc <= de, so we skip ahead
0B0D45             0286*  ; otherwise we swap bc and de
0B0D45 C5          0287*      push bc
0B0D46 E1          0288*      pop hl
0B0D47 EB          0289*      ex de,hl
0B0D48 E5          0290*      push hl
0B0D49 C1          0291*      pop bc
0B0D4A             0292*  @1:
0B0D4A             0293*  ; now we're ready to snag our preliminary result
0B0D4A CD B8 0D 0B 0294*      call atan_168game ; uh.l comes back with prelim result
0B0D4E             0295*  ; now we adjust uh.l based on sign of de - bc
0B0D4E F1          0296*      pop af
0B0D4F F2 5B 0D 0B 0297*      jp p,@2 ; bc <= de,so we skip ahead
0B0D53 EB          0298*      ex de,hl
0B0D54 21 00 40 00 0299*      ld hl,0x004000 ; 90 degrees
0B0D58 AF          0300*      xor a ; clear the carry flag
0B0D59 ED 52       0301*      sbc hl,de ; subtract result from 90 degrees
0B0D5B             0302*      ; ld de,0 ; prep to clear hlu
0B0D5B             0303*      ; ld d,h
0B0D5B             0304*      ; ld e,l
0B0D5B             0305*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0D5B             0306*      ; fall through
0B0D5B             0307*  @2:
0B0D5B             0308*  ; now the fun part of adjusting the result
0B0D5B             0309*  ; based on which quadrant (x,y) is in
0B0D5B             0310*  ; #E0 315      0       45 #20
0B0D5B             0311*  ;        -x,-y | +x,-y
0B0D5B             0312*  ; #C0 270------+------ 90 #40
0B0D5B             0313*  ;        -x,+y | +x,+y
0B0D5B             0314*  ; #A0 225   180 #80   135 #60
0B0D5B F1          0315*      pop af ; sign of y
0B0D5C CA 99 0D 0B 0316*      jp z,@y_zero
0B0D60 F2 79 0D 0B 0317*      jp p,@y_pos
0B0D64             0318*  ; y neg,check x
0B0D64 F1          0319*      pop af ; sign of x
0B0D65 CA 73 0D 0B 0320*      jp z,@y_neg_x_zero
0B0D69 F2 78 0D 0B 0321*      jp p,@y_neg_x_pos
0B0D6D             0322*  ; y neg,x neg
0B0D6D             0323*  ; angle is 270-360
0B0D6D             0324*  ; negating the intermediate does the trick
0B0D6D CD 43 08 0B 0325*      call neg_hlu
0B0D71 18 31       0326*      jr @zero_hlu
0B0D73             0327*  
0B0D73             0328*  @y_neg_x_zero:
0B0D73             0329*  ; y neg,x zero
0B0D73             0330*  ; angle is 0
0B0D73 21 00 00 00 0331*      ld hl,0
0B0D77 C9          0332*      ret
0B0D78             0333*  @y_neg_x_pos:
0B0D78             0334*  ; y neg,x pos
0B0D78             0335*  ; angle is 0 to 90
0B0D78             0336*  ; so we're good
0B0D78 C9          0337*      ret
0B0D79             0338*  
0B0D79             0339*  @y_pos:
0B0D79 F1          0340*      pop af ; sign of x
0B0D7A CA 89 0D 0B 0341*      jp z,@y_pos_x_zero
0B0D7E F2 8E 0D 0B 0342*      jp p,@y_pos_x_pos
0B0D82             0343*  ; y pos,x neg
0B0D82             0344*  ; angle is 180-270
0B0D82             0345*  ; so we add 180 to intermediate
0B0D82 11 00 80 00 0346*      ld de,0x008000
0B0D86 19          0347*      add hl,de
0B0D87 18 1B       0348*      jr @zero_hlu
0B0D89             0349*  @y_pos_x_zero:
0B0D89             0350*  ; y pos,x zero
0B0D89             0351*  ; angle is 180
0B0D89 21 00 80 00 0352*      ld hl,0x008000
0B0D8D C9          0353*      ret
0B0D8E             0354*  @y_pos_x_pos:
0B0D8E             0355*  ; y pos,x pos
0B0D8E             0356*  ; angle is 90-180
0B0D8E             0357*  ; neg the intermediate and add 180 degrees
0B0D8E CD 43 08 0B 0358*      call neg_hlu
0B0D92 11 00 80 00 0359*      ld de,0x008000
0B0D96 19          0360*      add hl,de
0B0D97 18 0B       0361*      jr @zero_hlu
0B0D99             0362*  
0B0D99             0363*  @y_zero:
0B0D99 F1          0364*      pop af ; sign of x
0B0D9A FA 9F 0D 0B 0365*      jp m,@y_zero_x_neg
0B0D9E             0366*  ; y zero,x pos
0B0D9E             0367*  ; angle is 90,nothing to do
0B0D9E C9          0368*      ret
0B0D9F             0369*  @y_zero_x_neg:
0B0D9F             0370*  ; y zero ,x neg
0B0D9F             0371*  ; angle is 270
0B0D9F 21 00 C0 00 0372*      ld hl,0x00C000
0B0DA3 C9          0373*      ret
0B0DA4             0374*  @zero_hlu:
0B0DA4 AF          0375*      xor a
0B0DA5 22 B2 0D 0B 0376*      ld (@scratch),hl
0B0DA9 32 B4 0D 0B 0377*      ld (@scratch+2),a
0B0DAD 2A B2 0D 0B 0378*      ld hl,(@scratch)
0B0DB1 C9          0379*      ret
0B0DB2             0380*  @scratch: ds 6
0B0DB8             0381*  
0B0DB8             0382*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0DB8             0383*  ; output: uh.l is the 16.8 fixed format angle
0B0DB8             0384*  ; destroys: a,hl,bc,de
0B0DB8             0385*  ; the following note was written by github copilot:
0B0DB8             0386*  ; note: this routine is a bit of a hack
0B0DB8             0387*  ;      but it works
0B0DB8             0388*  ;      and it's fast
0B0DB8             0389*  ;      and it's small
0B0DB8             0390*  ;      and it's accurate
0B0DB8             0391*  ;      and it's easy to understand
0B0DB8             0392*  ;      and it's easy to modify
0B0DB8             0393*  ;      and it's easy to use
0B0DB8             0394*  ;      and it's easy to remember
0B0DB8             0395*  ;      and it's easy to love
0B0DB8             0396*  ;      and it's easy to hate
0B0DB8             0397*  ;      and it's easy to ignore
0B0DB8             0398*  ;      and it's easy to forget
0B0DB8             0399*  ;      and it's easy to remember
0B0DB8             0400*  ;      and it's easy to forget
0B0DB8             0401*  ;      and it's easy to remember
0B0DB8             0402*  ;      (ok the bot is stuck in a loop)
0B0DB8             0403*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0DB8             0404*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0DB8             0405*  atan_168game:
0B0DB8             0406*  ; because we use compass headings instead of geometric angles
0B0DB8             0407*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0DB8             0408*  ; we can do faster unsigned division here because we know dx and dy are positive
0B0DB8 CD 3E 0A 0B 0409*  	call udiv168 ; uh.l = dx/dy
0B0DBC             0410*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0DBC             0411*  ; ; test uh.l for 0
0B0DBC             0412*  ;     add hl,de
0B0DBC             0413*  ;     or a
0B0DBC             0414*  ;     sbc hl,de
0B0DBC             0415*  ;     jr z,@is_zero
0B0DBC             0416*  ; ; test uh.l for 1
0B0DBC             0417*  ;     xor a ; clear carry
0B0DBC             0418*  ;     ex de,hl
0B0DBC             0419*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0DBC             0420*  ;     sbc hl,de
0B0DBC             0421*  ;     jr z,@is_45
0B0DBC             0422*  ; ; END TODO
0B0DBC             0423*  
0B0DBC             0424*  ; no special cases so we move on
0B0DBC             0425*  ; l contains the fractional portion of tan(uh.l)
0B0DBC             0426*  ; we multiply it by three to get our lookup table index
0B0DBC 26 03       0427*      ld h,3
0B0DBE ED 6C       0428*      mlt hl ; gosh that is handy
0B0DC0 11 00 00 00 0429*      ld de,0 ; clear deu
0B0DC4 54          0430*      ld d,h ; copy hl to de
0B0DC5 5D          0431*      ld e,l ; de contains our index
0B0DC6 21 DB 13 0B 0432*      ld hl,atan_lut_168 ; grab the lut address
0B0DCA 19          0433*      add hl,de ; bump hl by the index
0B0DCB ED 27       0434*      ld hl,(hl) ; don't try this on a z80!
0B0DCD C9          0435*      ret ; and out
0B0DCE             0436*  @is_45:
0B0DCE 21 00 20 00 0437*      ld hl,0x002000 ; 45 degrees decimal
0B0DD2 C9          0438*      ret
0B0DD3             0439*  ; for the case tan(0)
0B0DD3             0440*  @is_zero:
0B0DD3 21 00 00 00 0441*      ld hl,0x000000
0B0DD7 C9          0442*      ret
0B0DD8             0443*  
0B0DD8             0444*  sin_lut_168:
0B0DD8 00 00 00    0445*  	dl 0x000000 ; 0.000 00, 0.000
0B0DDB 06 00 00    0446*  	dl 0x000006 ; 1.406 01, 0.025
0B0DDE 0C 00 00    0447*  	dl 0x00000C ; 2.813 02, 0.049
0B0DE1 12 00 00    0448*  	dl 0x000012 ; 4.219 03, 0.074
0B0DE4 19 00 00    0449*  	dl 0x000019 ; 5.625 04, 0.098
0B0DE7 1F 00 00    0450*  	dl 0x00001F ; 7.031 05, 0.122
0B0DEA 25 00 00    0451*  	dl 0x000025 ; 8.438 06, 0.147
0B0DED 2B 00 00    0452*  	dl 0x00002B ; 9.844 07, 0.171
0B0DF0 31 00 00    0453*  	dl 0x000031 ; 11.250 08, 0.195
0B0DF3 38 00 00    0454*  	dl 0x000038 ; 12.656 09, 0.219
0B0DF6 3E 00 00    0455*  	dl 0x00003E ; 14.063 0A, 0.243
0B0DF9 44 00 00    0456*  	dl 0x000044 ; 15.469 0B, 0.267
0B0DFC 4A 00 00    0457*  	dl 0x00004A ; 16.875 0C, 0.290
0B0DFF 50 00 00    0458*  	dl 0x000050 ; 18.281 0D, 0.314
0B0E02 56 00 00    0459*  	dl 0x000056 ; 19.688 0E, 0.337
0B0E05 5C 00 00    0460*  	dl 0x00005C ; 21.094 0F, 0.360
0B0E08 61 00 00    0461*  	dl 0x000061 ; 22.500 10, 0.383
0B0E0B 67 00 00    0462*  	dl 0x000067 ; 23.906 11, 0.405
0B0E0E 6D 00 00    0463*  	dl 0x00006D ; 25.313 12, 0.428
0B0E11 73 00 00    0464*  	dl 0x000073 ; 26.719 13, 0.450
0B0E14 78 00 00    0465*  	dl 0x000078 ; 28.125 14, 0.471
0B0E17 7E 00 00    0466*  	dl 0x00007E ; 29.531 15, 0.493
0B0E1A 83 00 00    0467*  	dl 0x000083 ; 30.938 16, 0.514
0B0E1D 88 00 00    0468*  	dl 0x000088 ; 32.344 17, 0.535
0B0E20 8E 00 00    0469*  	dl 0x00008E ; 33.750 18, 0.556
0B0E23 93 00 00    0470*  	dl 0x000093 ; 35.156 19, 0.576
0B0E26 98 00 00    0471*  	dl 0x000098 ; 36.563 1A, 0.596
0B0E29 9D 00 00    0472*  	dl 0x00009D ; 37.969 1B, 0.615
0B0E2C A2 00 00    0473*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0E2F A7 00 00    0474*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0E32 AB 00 00    0475*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0E35 B0 00 00    0476*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B0E38 B5 00 00    0477*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0E3B B9 00 00    0478*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0E3E BD 00 00    0479*  	dl 0x0000BD ; 47.813 22, 0.741
0B0E41 C1 00 00    0480*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0E44 C5 00 00    0481*  	dl 0x0000C5 ; 50.625 24, 0.773
0B0E47 C9 00 00    0482*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0E4A CD 00 00    0483*  	dl 0x0000CD ; 53.438 26, 0.803
0B0E4D D1 00 00    0484*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0E50 D4 00 00    0485*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0E53 D8 00 00    0486*  	dl 0x0000D8 ; 57.656 29, 0.845
0B0E56 DB 00 00    0487*  	dl 0x0000DB ; 59.063 2A, 0.858
0B0E59 DE 00 00    0488*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0E5C E1 00 00    0489*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0E5F E4 00 00    0490*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0E62 E7 00 00    0491*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B0E65 EA 00 00    0492*  	dl 0x0000EA ; 66.094 2F, 0.914
0B0E68 EC 00 00    0493*  	dl 0x0000EC ; 67.500 30, 0.924
0B0E6B EE 00 00    0494*  	dl 0x0000EE ; 68.906 31, 0.933
0B0E6E F1 00 00    0495*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0E71 F3 00 00    0496*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0E74 F4 00 00    0497*  	dl 0x0000F4 ; 73.125 34, 0.957
0B0E77 F6 00 00    0498*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0E7A F8 00 00    0499*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0E7D F9 00 00    0500*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0E80 FB 00 00    0501*  	dl 0x0000FB ; 78.750 38, 0.981
0B0E83 FC 00 00    0502*  	dl 0x0000FC ; 80.156 39, 0.985
0B0E86 FD 00 00    0503*  	dl 0x0000FD ; 81.563 3A, 0.989
0B0E89 FE 00 00    0504*  	dl 0x0000FE ; 82.969 3B, 0.992
0B0E8C FE 00 00    0505*  	dl 0x0000FE ; 84.375 3C, 0.995
0B0E8F FF 00 00    0506*  	dl 0x0000FF ; 85.781 3D, 0.997
0B0E92 FF 00 00    0507*  	dl 0x0000FF ; 87.188 3E, 0.999
0B0E95 FF 00 00    0508*  	dl 0x0000FF ; 88.594 3F, 1.000
0B0E98 00 01 00    0509*  	dl 0x000100 ; 90.000 40, 1.000
0B0E9B FF 00 00    0510*  	dl 0x0000FF ; 91.406 41, 1.000
0B0E9E FF 00 00    0511*  	dl 0x0000FF ; 92.813 42, 0.999
0B0EA1 FF 00 00    0512*  	dl 0x0000FF ; 94.219 43, 0.997
0B0EA4 FE 00 00    0513*  	dl 0x0000FE ; 95.625 44, 0.995
0B0EA7 FE 00 00    0514*  	dl 0x0000FE ; 97.031 45, 0.992
0B0EAA FD 00 00    0515*  	dl 0x0000FD ; 98.438 46, 0.989
0B0EAD FC 00 00    0516*  	dl 0x0000FC ; 99.844 47, 0.985
0B0EB0 FB 00 00    0517*  	dl 0x0000FB ; 101.250 48, 0.981
0B0EB3 F9 00 00    0518*  	dl 0x0000F9 ; 102.656 49, 0.976
0B0EB6 F8 00 00    0519*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B0EB9 F6 00 00    0520*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B0EBC F4 00 00    0521*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B0EBF F3 00 00    0522*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B0EC2 F1 00 00    0523*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B0EC5 EE 00 00    0524*  	dl 0x0000EE ; 111.094 4F, 0.933
0B0EC8 EC 00 00    0525*  	dl 0x0000EC ; 112.500 50, 0.924
0B0ECB EA 00 00    0526*  	dl 0x0000EA ; 113.906 51, 0.914
0B0ECE E7 00 00    0527*  	dl 0x0000E7 ; 115.313 52, 0.904
0B0ED1 E4 00 00    0528*  	dl 0x0000E4 ; 116.719 53, 0.893
0B0ED4 E1 00 00    0529*  	dl 0x0000E1 ; 118.125 54, 0.882
0B0ED7 DE 00 00    0530*  	dl 0x0000DE ; 119.531 55, 0.870
0B0EDA DB 00 00    0531*  	dl 0x0000DB ; 120.938 56, 0.858
0B0EDD D8 00 00    0532*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0EE0 D4 00 00    0533*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0EE3 D1 00 00    0534*  	dl 0x0000D1 ; 125.156 59, 0.818
0B0EE6 CD 00 00    0535*  	dl 0x0000CD ; 126.563 5A, 0.803
0B0EE9 C9 00 00    0536*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0EEC C5 00 00    0537*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0EEF C1 00 00    0538*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0EF2 BD 00 00    0539*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0EF5 B9 00 00    0540*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B0EF8 B5 00 00    0541*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0EFB B0 00 00    0542*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0EFE AB 00 00    0543*  	dl 0x0000AB ; 137.813 62, 0.672
0B0F01 A7 00 00    0544*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0F04 A2 00 00    0545*  	dl 0x0000A2 ; 140.625 64, 0.634
0B0F07 9D 00 00    0546*  	dl 0x00009D ; 142.031 65, 0.615
0B0F0A 98 00 00    0547*  	dl 0x000098 ; 143.438 66, 0.596
0B0F0D 93 00 00    0548*  	dl 0x000093 ; 144.844 67, 0.576
0B0F10 8E 00 00    0549*  	dl 0x00008E ; 146.250 68, 0.556
0B0F13 88 00 00    0550*  	dl 0x000088 ; 147.656 69, 0.535
0B0F16 83 00 00    0551*  	dl 0x000083 ; 149.063 6A, 0.514
0B0F19 7E 00 00    0552*  	dl 0x00007E ; 150.469 6B, 0.493
0B0F1C 78 00 00    0553*  	dl 0x000078 ; 151.875 6C, 0.471
0B0F1F 73 00 00    0554*  	dl 0x000073 ; 153.281 6D, 0.450
0B0F22 6D 00 00    0555*  	dl 0x00006D ; 154.688 6E, 0.428
0B0F25 67 00 00    0556*  	dl 0x000067 ; 156.094 6F, 0.405
0B0F28 61 00 00    0557*  	dl 0x000061 ; 157.500 70, 0.383
0B0F2B 5C 00 00    0558*  	dl 0x00005C ; 158.906 71, 0.360
0B0F2E 56 00 00    0559*  	dl 0x000056 ; 160.313 72, 0.337
0B0F31 50 00 00    0560*  	dl 0x000050 ; 161.719 73, 0.314
0B0F34 4A 00 00    0561*  	dl 0x00004A ; 163.125 74, 0.290
0B0F37 44 00 00    0562*  	dl 0x000044 ; 164.531 75, 0.267
0B0F3A 3E 00 00    0563*  	dl 0x00003E ; 165.938 76, 0.243
0B0F3D 38 00 00    0564*  	dl 0x000038 ; 167.344 77, 0.219
0B0F40 31 00 00    0565*  	dl 0x000031 ; 168.750 78, 0.195
0B0F43 2B 00 00    0566*  	dl 0x00002B ; 170.156 79, 0.171
0B0F46 25 00 00    0567*  	dl 0x000025 ; 171.563 7A, 0.147
0B0F49 1F 00 00    0568*  	dl 0x00001F ; 172.969 7B, 0.122
0B0F4C 19 00 00    0569*  	dl 0x000019 ; 174.375 7C, 0.098
0B0F4F 12 00 00    0570*  	dl 0x000012 ; 175.781 7D, 0.074
0B0F52 0C 00 00    0571*  	dl 0x00000C ; 177.188 7E, 0.049
0B0F55 06 00 00    0572*  	dl 0x000006 ; 178.594 7F, 0.025
0B0F58 00 00 00    0573*  	dl 0x000000 ; 180.000 80, 0.000
0B0F5B FA FF FF    0574*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0F5E F4 FF FF    0575*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0F61 EE FF FF    0576*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0F64 E7 FF FF    0577*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B0F67 E1 FF FF    0578*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0F6A DB FF FF    0579*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0F6D D5 FF FF    0580*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0F70 CF FF FF    0581*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0F73 C8 FF FF    0582*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B0F76 C2 FF FF    0583*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B0F79 BC FF FF    0584*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0F7C B6 FF FF    0585*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0F7F B0 FF FF    0586*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0F82 AA FF FF    0587*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B0F85 A4 FF FF    0588*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B0F88 9F FF FF    0589*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B0F8B 99 FF FF    0590*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B0F8E 93 FF FF    0591*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B0F91 8D FF FF    0592*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B0F94 88 FF FF    0593*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B0F97 82 FF FF    0594*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B0F9A 7D FF FF    0595*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B0F9D 78 FF FF    0596*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B0FA0 72 FF FF    0597*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B0FA3 6D FF FF    0598*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B0FA6 68 FF FF    0599*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B0FA9 63 FF FF    0600*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B0FAC 5E FF FF    0601*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B0FAF 59 FF FF    0602*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B0FB2 55 FF FF    0603*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B0FB5 50 FF FF    0604*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B0FB8 4B FF FF    0605*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B0FBB 47 FF FF    0606*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B0FBE 43 FF FF    0607*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B0FC1 3F FF FF    0608*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B0FC4 3B FF FF    0609*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B0FC7 37 FF FF    0610*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B0FCA 33 FF FF    0611*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B0FCD 2F FF FF    0612*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B0FD0 2C FF FF    0613*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B0FD3 28 FF FF    0614*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B0FD6 25 FF FF    0615*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B0FD9 22 FF FF    0616*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B0FDC 1F FF FF    0617*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B0FDF 1C FF FF    0618*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B0FE2 19 FF FF    0619*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B0FE5 16 FF FF    0620*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B0FE8 14 FF FF    0621*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B0FEB 12 FF FF    0622*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0FEE 0F FF FF    0623*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0FF1 0D FF FF    0624*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B0FF4 0C FF FF    0625*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B0FF7 0A FF FF    0626*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B0FFA 08 FF FF    0627*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0FFD 07 FF FF    0628*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B1000 05 FF FF    0629*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B1003 04 FF FF    0630*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B1006 03 FF FF    0631*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B1009 02 FF FF    0632*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B100C 02 FF FF    0633*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B100F 01 FF FF    0634*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B1012 01 FF FF    0635*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B1015 01 FF FF    0636*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B1018 00 FF FF    0637*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B101B 01 FF FF    0638*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B101E 01 FF FF    0639*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B1021 01 FF FF    0640*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B1024 02 FF FF    0641*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B1027 02 FF FF    0642*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B102A 03 FF FF    0643*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B102D 04 FF FF    0644*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B1030 05 FF FF    0645*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B1033 07 FF FF    0646*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B1036 08 FF FF    0647*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B1039 0A FF FF    0648*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B103C 0C FF FF    0649*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B103F 0D FF FF    0650*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B1042 0F FF FF    0651*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B1045 12 FF FF    0652*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B1048 14 FF FF    0653*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B104B 16 FF FF    0654*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B104E 19 FF FF    0655*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B1051 1C FF FF    0656*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B1054 1F FF FF    0657*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B1057 22 FF FF    0658*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B105A 25 FF FF    0659*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B105D 28 FF FF    0660*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B1060 2C FF FF    0661*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B1063 2F FF FF    0662*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B1066 33 FF FF    0663*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B1069 37 FF FF    0664*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B106C 3B FF FF    0665*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B106F 3F FF FF    0666*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B1072 43 FF FF    0667*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B1075 47 FF FF    0668*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B1078 4B FF FF    0669*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B107B 50 FF FF    0670*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B107E 55 FF FF    0671*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B1081 59 FF FF    0672*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1084 5E FF FF    0673*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1087 63 FF FF    0674*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B108A 68 FF FF    0675*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B108D 6D FF FF    0676*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B1090 72 FF FF    0677*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1093 78 FF FF    0678*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1096 7D FF FF    0679*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B1099 82 FF FF    0680*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B109C 88 FF FF    0681*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B109F 8D FF FF    0682*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B10A2 93 FF FF    0683*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B10A5 99 FF FF    0684*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B10A8 9F FF FF    0685*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B10AB A4 FF FF    0686*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B10AE AA FF FF    0687*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B10B1 B0 FF FF    0688*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B10B4 B6 FF FF    0689*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B10B7 BC FF FF    0690*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B10BA C2 FF FF    0691*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B10BD C8 FF FF    0692*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B10C0 CF FF FF    0693*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B10C3 D5 FF FF    0694*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B10C6 DB FF FF    0695*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B10C9 E1 FF FF    0696*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B10CC E7 FF FF    0697*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B10CF EE FF FF    0698*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B10D2 F4 FF FF    0699*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B10D5 FA FF FF    0700*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B10D8 00 00 00    0701*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B10DB             0702*  
0B10DB             0703*  sin_lut_1212:
0B10DB 00 00 00    0704*      dl 0x000000 ; 00, 00.000, +0.000000
0B10DE 65 00 00    0705*      dl 0x000065 ; 01, 01.406, +0.024541
0B10E1 C9 00 00    0706*      dl 0x0000C9 ; 02, 02.812, +0.049068
0B10E4 2D 01 00    0707*      dl 0x00012D ; 03, 04.219, +0.073565
0B10E7 91 01 00    0708*      dl 0x000191 ; 04, 05.625, +0.098017
0B10EA F5 01 00    0709*      dl 0x0001F5 ; 05, 07.031, +0.122411
0B10ED 59 02 00    0710*      dl 0x000259 ; 06, 08.438, +0.146730
0B10F0 BC 02 00    0711*      dl 0x0002BC ; 07, 09.844, +0.170962
0B10F3 1F 03 00    0712*      dl 0x00031F ; 08, 11.250, +0.195090
0B10F6 81 03 00    0713*      dl 0x000381 ; 09, 12.656, +0.219101
0B10F9 E3 03 00    0714*      dl 0x0003E3 ; 0A, 14.062, +0.242980
0B10FC 44 04 00    0715*      dl 0x000444 ; 0B, 15.469, +0.266713
0B10FF A5 04 00    0716*      dl 0x0004A5 ; 0C, 16.875, +0.290285
0B1102 05 05 00    0717*      dl 0x000505 ; 0D, 18.281, +0.313682
0B1105 64 05 00    0718*      dl 0x000564 ; 0E, 19.688, +0.336890
0B1108 C2 05 00    0719*      dl 0x0005C2 ; 0F, 21.094, +0.359895
0B110B 1F 06 00    0720*      dl 0x00061F ; 10, 22.500, +0.382683
0B110E 7C 06 00    0721*      dl 0x00067C ; 11, 23.906, +0.405241
0B1111 D7 06 00    0722*      dl 0x0006D7 ; 12, 25.312, +0.427555
0B1114 32 07 00    0723*      dl 0x000732 ; 13, 26.719, +0.449611
0B1117 8B 07 00    0724*      dl 0x00078B ; 14, 28.125, +0.471397
0B111A E3 07 00    0725*      dl 0x0007E3 ; 15, 29.531, +0.492898
0B111D 3A 08 00    0726*      dl 0x00083A ; 16, 30.938, +0.514103
0B1120 8F 08 00    0727*      dl 0x00088F ; 17, 32.344, +0.534998
0B1123 E4 08 00    0728*      dl 0x0008E4 ; 18, 33.750, +0.555570
0B1126 37 09 00    0729*      dl 0x000937 ; 19, 35.156, +0.575808
0B1129 88 09 00    0730*      dl 0x000988 ; 1A, 36.562, +0.595699
0B112C D8 09 00    0731*      dl 0x0009D8 ; 1B, 37.969, +0.615232
0B112F 26 0A 00    0732*      dl 0x000A26 ; 1C, 39.375, +0.634393
0B1132 73 0A 00    0733*      dl 0x000A73 ; 1D, 40.781, +0.653173
0B1135 BF 0A 00    0734*      dl 0x000ABF ; 1E, 42.188, +0.671559
0B1138 08 0B 00    0735*      dl 0x000B08 ; 1F, 43.594, +0.689541
0B113B 50 0B 00    0736*      dl 0x000B50 ; 20, 45.000, +0.707107
0B113E 97 0B 00    0737*      dl 0x000B97 ; 21, 46.406, +0.724247
0B1141 DB 0B 00    0738*      dl 0x000BDB ; 22, 47.812, +0.740951
0B1144 1E 0C 00    0739*      dl 0x000C1E ; 23, 49.219, +0.757209
0B1147 5E 0C 00    0740*      dl 0x000C5E ; 24, 50.625, +0.773010
0B114A 9D 0C 00    0741*      dl 0x000C9D ; 25, 52.031, +0.788346
0B114D DA 0C 00    0742*      dl 0x000CDA ; 26, 53.438, +0.803208
0B1150 15 0D 00    0743*      dl 0x000D15 ; 27, 54.844, +0.817585
0B1153 4E 0D 00    0744*      dl 0x000D4E ; 28, 56.250, +0.831470
0B1156 85 0D 00    0745*      dl 0x000D85 ; 29, 57.656, +0.844854
0B1159 B9 0D 00    0746*      dl 0x000DB9 ; 2A, 59.062, +0.857729
0B115C EC 0D 00    0747*      dl 0x000DEC ; 2B, 60.469, +0.870087
0B115F 1C 0E 00    0748*      dl 0x000E1C ; 2C, 61.875, +0.881921
0B1162 4B 0E 00    0749*      dl 0x000E4B ; 2D, 63.281, +0.893224
0B1165 77 0E 00    0750*      dl 0x000E77 ; 2E, 64.688, +0.903989
0B1168 A1 0E 00    0751*      dl 0x000EA1 ; 2F, 66.094, +0.914210
0B116B C8 0E 00    0752*      dl 0x000EC8 ; 30, 67.500, +0.923880
0B116E EE 0E 00    0753*      dl 0x000EEE ; 31, 68.906, +0.932993
0B1171 11 0F 00    0754*      dl 0x000F11 ; 32, 70.312, +0.941544
0B1174 31 0F 00    0755*      dl 0x000F31 ; 33, 71.719, +0.949528
0B1177 50 0F 00    0756*      dl 0x000F50 ; 34, 73.125, +0.956940
0B117A 6C 0F 00    0757*      dl 0x000F6C ; 35, 74.531, +0.963776
0B117D 85 0F 00    0758*      dl 0x000F85 ; 36, 75.938, +0.970031
0B1180 9C 0F 00    0759*      dl 0x000F9C ; 37, 77.344, +0.975702
0B1183 B1 0F 00    0760*      dl 0x000FB1 ; 38, 78.750, +0.980785
0B1186 C4 0F 00    0761*      dl 0x000FC4 ; 39, 80.156, +0.985278
0B1189 D4 0F 00    0762*      dl 0x000FD4 ; 3A, 81.562, +0.989177
0B118C E1 0F 00    0763*      dl 0x000FE1 ; 3B, 82.969, +0.992480
0B118F EC 0F 00    0764*      dl 0x000FEC ; 3C, 84.375, +0.995185
0B1192 F5 0F 00    0765*      dl 0x000FF5 ; 3D, 85.781, +0.997290
0B1195 FB 0F 00    0766*      dl 0x000FFB ; 3E, 87.188, +0.998795
0B1198 FF 0F 00    0767*      dl 0x000FFF ; 3F, 88.594, +0.999699
0B119B 00 10 00    0768*      dl 0x001000 ; 40, 90.000, +1.000000
0B119E FF 0F 00    0769*      dl 0x000FFF ; 41, 91.406, +0.999699
0B11A1 FB 0F 00    0770*      dl 0x000FFB ; 42, 92.812, +0.998795
0B11A4 F5 0F 00    0771*      dl 0x000FF5 ; 43, 94.219, +0.997290
0B11A7 EC 0F 00    0772*      dl 0x000FEC ; 44, 95.625, +0.995185
0B11AA E1 0F 00    0773*      dl 0x000FE1 ; 45, 97.031, +0.992480
0B11AD D4 0F 00    0774*      dl 0x000FD4 ; 46, 98.438, +0.989177
0B11B0 C4 0F 00    0775*      dl 0x000FC4 ; 47, 99.844, +0.985278
0B11B3 B1 0F 00    0776*      dl 0x000FB1 ; 48, 101.250, +0.980785
0B11B6 9C 0F 00    0777*      dl 0x000F9C ; 49, 102.656, +0.975702
0B11B9 85 0F 00    0778*      dl 0x000F85 ; 4A, 104.062, +0.970031
0B11BC 6C 0F 00    0779*      dl 0x000F6C ; 4B, 105.469, +0.963776
0B11BF 50 0F 00    0780*      dl 0x000F50 ; 4C, 106.875, +0.956940
0B11C2 31 0F 00    0781*      dl 0x000F31 ; 4D, 108.281, +0.949528
0B11C5 11 0F 00    0782*      dl 0x000F11 ; 4E, 109.688, +0.941544
0B11C8 EE 0E 00    0783*      dl 0x000EEE ; 4F, 111.094, +0.932993
0B11CB C8 0E 00    0784*      dl 0x000EC8 ; 50, 112.500, +0.923880
0B11CE A1 0E 00    0785*      dl 0x000EA1 ; 51, 113.906, +0.914210
0B11D1 77 0E 00    0786*      dl 0x000E77 ; 52, 115.312, +0.903989
0B11D4 4B 0E 00    0787*      dl 0x000E4B ; 53, 116.719, +0.893224
0B11D7 1C 0E 00    0788*      dl 0x000E1C ; 54, 118.125, +0.881921
0B11DA EC 0D 00    0789*      dl 0x000DEC ; 55, 119.531, +0.870087
0B11DD B9 0D 00    0790*      dl 0x000DB9 ; 56, 120.938, +0.857729
0B11E0 85 0D 00    0791*      dl 0x000D85 ; 57, 122.344, +0.844854
0B11E3 4E 0D 00    0792*      dl 0x000D4E ; 58, 123.750, +0.831470
0B11E6 15 0D 00    0793*      dl 0x000D15 ; 59, 125.156, +0.817585
0B11E9 DA 0C 00    0794*      dl 0x000CDA ; 5A, 126.562, +0.803208
0B11EC 9D 0C 00    0795*      dl 0x000C9D ; 5B, 127.969, +0.788346
0B11EF 5E 0C 00    0796*      dl 0x000C5E ; 5C, 129.375, +0.773010
0B11F2 1E 0C 00    0797*      dl 0x000C1E ; 5D, 130.781, +0.757209
0B11F5 DB 0B 00    0798*      dl 0x000BDB ; 5E, 132.188, +0.740951
0B11F8 97 0B 00    0799*      dl 0x000B97 ; 5F, 133.594, +0.724247
0B11FB 50 0B 00    0800*      dl 0x000B50 ; 60, 135.000, +0.707107
0B11FE 08 0B 00    0801*      dl 0x000B08 ; 61, 136.406, +0.689541
0B1201 BF 0A 00    0802*      dl 0x000ABF ; 62, 137.812, +0.671559
0B1204 73 0A 00    0803*      dl 0x000A73 ; 63, 139.219, +0.653173
0B1207 26 0A 00    0804*      dl 0x000A26 ; 64, 140.625, +0.634393
0B120A D8 09 00    0805*      dl 0x0009D8 ; 65, 142.031, +0.615232
0B120D 88 09 00    0806*      dl 0x000988 ; 66, 143.438, +0.595699
0B1210 37 09 00    0807*      dl 0x000937 ; 67, 144.844, +0.575808
0B1213 E4 08 00    0808*      dl 0x0008E4 ; 68, 146.250, +0.555570
0B1216 8F 08 00    0809*      dl 0x00088F ; 69, 147.656, +0.534998
0B1219 3A 08 00    0810*      dl 0x00083A ; 6A, 149.062, +0.514103
0B121C E3 07 00    0811*      dl 0x0007E3 ; 6B, 150.469, +0.492898
0B121F 8B 07 00    0812*      dl 0x00078B ; 6C, 151.875, +0.471397
0B1222 32 07 00    0813*      dl 0x000732 ; 6D, 153.281, +0.449611
0B1225 D7 06 00    0814*      dl 0x0006D7 ; 6E, 154.688, +0.427555
0B1228 7C 06 00    0815*      dl 0x00067C ; 6F, 156.094, +0.405241
0B122B 1F 06 00    0816*      dl 0x00061F ; 70, 157.500, +0.382683
0B122E C2 05 00    0817*      dl 0x0005C2 ; 71, 158.906, +0.359895
0B1231 64 05 00    0818*      dl 0x000564 ; 72, 160.312, +0.336890
0B1234 05 05 00    0819*      dl 0x000505 ; 73, 161.719, +0.313682
0B1237 A5 04 00    0820*      dl 0x0004A5 ; 74, 163.125, +0.290285
0B123A 44 04 00    0821*      dl 0x000444 ; 75, 164.531, +0.266713
0B123D E3 03 00    0822*      dl 0x0003E3 ; 76, 165.938, +0.242980
0B1240 81 03 00    0823*      dl 0x000381 ; 77, 167.344, +0.219101
0B1243 1F 03 00    0824*      dl 0x00031F ; 78, 168.750, +0.195090
0B1246 BC 02 00    0825*      dl 0x0002BC ; 79, 170.156, +0.170962
0B1249 59 02 00    0826*      dl 0x000259 ; 7A, 171.562, +0.146730
0B124C F5 01 00    0827*      dl 0x0001F5 ; 7B, 172.969, +0.122411
0B124F 91 01 00    0828*      dl 0x000191 ; 7C, 174.375, +0.098017
0B1252 2D 01 00    0829*      dl 0x00012D ; 7D, 175.781, +0.073565
0B1255 C9 00 00    0830*      dl 0x0000C9 ; 7E, 177.188, +0.049068
0B1258 65 00 00    0831*      dl 0x000065 ; 7F, 178.594, +0.024541
0B125B 00 00 00    0832*      dl 0x000000 ; 80, 180.000, +0.000000
0B125E 9B FF FF    0833*      dl 0xFFFF9B ; 81, 181.406, -0.024541
0B1261 37 FF FF    0834*      dl 0xFFFF37 ; 82, 182.812, -0.049068
0B1264 D3 FE FF    0835*      dl 0xFFFED3 ; 83, 184.219, -0.073565
0B1267 6F FE FF    0836*      dl 0xFFFE6F ; 84, 185.625, -0.098017
0B126A 0B FE FF    0837*      dl 0xFFFE0B ; 85, 187.031, -0.122411
0B126D A7 FD FF    0838*      dl 0xFFFDA7 ; 86, 188.438, -0.146730
0B1270 44 FD FF    0839*      dl 0xFFFD44 ; 87, 189.844, -0.170962
0B1273 E1 FC FF    0840*      dl 0xFFFCE1 ; 88, 191.250, -0.195090
0B1276 7F FC FF    0841*      dl 0xFFFC7F ; 89, 192.656, -0.219101
0B1279 1D FC FF    0842*      dl 0xFFFC1D ; 8A, 194.062, -0.242980
0B127C BC FB FF    0843*      dl 0xFFFBBC ; 8B, 195.469, -0.266713
0B127F 5B FB FF    0844*      dl 0xFFFB5B ; 8C, 196.875, -0.290285
0B1282 FB FA FF    0845*      dl 0xFFFAFB ; 8D, 198.281, -0.313682
0B1285 9C FA FF    0846*      dl 0xFFFA9C ; 8E, 199.688, -0.336890
0B1288 3E FA FF    0847*      dl 0xFFFA3E ; 8F, 201.094, -0.359895
0B128B E1 F9 FF    0848*      dl 0xFFF9E1 ; 90, 202.500, -0.382683
0B128E 84 F9 FF    0849*      dl 0xFFF984 ; 91, 203.906, -0.405241
0B1291 29 F9 FF    0850*      dl 0xFFF929 ; 92, 205.312, -0.427555
0B1294 CE F8 FF    0851*      dl 0xFFF8CE ; 93, 206.719, -0.449611
0B1297 75 F8 FF    0852*      dl 0xFFF875 ; 94, 208.125, -0.471397
0B129A 1D F8 FF    0853*      dl 0xFFF81D ; 95, 209.531, -0.492898
0B129D C6 F7 FF    0854*      dl 0xFFF7C6 ; 96, 210.938, -0.514103
0B12A0 71 F7 FF    0855*      dl 0xFFF771 ; 97, 212.344, -0.534998
0B12A3 1C F7 FF    0856*      dl 0xFFF71C ; 98, 213.750, -0.555570
0B12A6 C9 F6 FF    0857*      dl 0xFFF6C9 ; 99, 215.156, -0.575808
0B12A9 78 F6 FF    0858*      dl 0xFFF678 ; 9A, 216.562, -0.595699
0B12AC 28 F6 FF    0859*      dl 0xFFF628 ; 9B, 217.969, -0.615232
0B12AF DA F5 FF    0860*      dl 0xFFF5DA ; 9C, 219.375, -0.634393
0B12B2 8D F5 FF    0861*      dl 0xFFF58D ; 9D, 220.781, -0.653173
0B12B5 41 F5 FF    0862*      dl 0xFFF541 ; 9E, 222.188, -0.671559
0B12B8 F8 F4 FF    0863*      dl 0xFFF4F8 ; 9F, 223.594, -0.689541
0B12BB B0 F4 FF    0864*      dl 0xFFF4B0 ; A0, 225.000, -0.707107
0B12BE 69 F4 FF    0865*      dl 0xFFF469 ; A1, 226.406, -0.724247
0B12C1 25 F4 FF    0866*      dl 0xFFF425 ; A2, 227.812, -0.740951
0B12C4 E2 F3 FF    0867*      dl 0xFFF3E2 ; A3, 229.219, -0.757209
0B12C7 A2 F3 FF    0868*      dl 0xFFF3A2 ; A4, 230.625, -0.773010
0B12CA 63 F3 FF    0869*      dl 0xFFF363 ; A5, 232.031, -0.788346
0B12CD 26 F3 FF    0870*      dl 0xFFF326 ; A6, 233.438, -0.803208
0B12D0 EB F2 FF    0871*      dl 0xFFF2EB ; A7, 234.844, -0.817585
0B12D3 B2 F2 FF    0872*      dl 0xFFF2B2 ; A8, 236.250, -0.831470
0B12D6 7B F2 FF    0873*      dl 0xFFF27B ; A9, 237.656, -0.844854
0B12D9 47 F2 FF    0874*      dl 0xFFF247 ; AA, 239.062, -0.857729
0B12DC 14 F2 FF    0875*      dl 0xFFF214 ; AB, 240.469, -0.870087
0B12DF E4 F1 FF    0876*      dl 0xFFF1E4 ; AC, 241.875, -0.881921
0B12E2 B5 F1 FF    0877*      dl 0xFFF1B5 ; AD, 243.281, -0.893224
0B12E5 89 F1 FF    0878*      dl 0xFFF189 ; AE, 244.688, -0.903989
0B12E8 5F F1 FF    0879*      dl 0xFFF15F ; AF, 246.094, -0.914210
0B12EB 38 F1 FF    0880*      dl 0xFFF138 ; B0, 247.500, -0.923880
0B12EE 12 F1 FF    0881*      dl 0xFFF112 ; B1, 248.906, -0.932993
0B12F1 EF F0 FF    0882*      dl 0xFFF0EF ; B2, 250.312, -0.941544
0B12F4 CF F0 FF    0883*      dl 0xFFF0CF ; B3, 251.719, -0.949528
0B12F7 B0 F0 FF    0884*      dl 0xFFF0B0 ; B4, 253.125, -0.956940
0B12FA 94 F0 FF    0885*      dl 0xFFF094 ; B5, 254.531, -0.963776
0B12FD 7B F0 FF    0886*      dl 0xFFF07B ; B6, 255.938, -0.970031
0B1300 64 F0 FF    0887*      dl 0xFFF064 ; B7, 257.344, -0.975702
0B1303 4F F0 FF    0888*      dl 0xFFF04F ; B8, 258.750, -0.980785
0B1306 3C F0 FF    0889*      dl 0xFFF03C ; B9, 260.156, -0.985278
0B1309 2C F0 FF    0890*      dl 0xFFF02C ; BA, 261.562, -0.989177
0B130C 1F F0 FF    0891*      dl 0xFFF01F ; BB, 262.969, -0.992480
0B130F 14 F0 FF    0892*      dl 0xFFF014 ; BC, 264.375, -0.995185
0B1312 0B F0 FF    0893*      dl 0xFFF00B ; BD, 265.781, -0.997290
0B1315 05 F0 FF    0894*      dl 0xFFF005 ; BE, 267.188, -0.998795
0B1318 01 F0 FF    0895*      dl 0xFFF001 ; BF, 268.594, -0.999699
0B131B 00 F0 FF    0896*      dl 0xFFF000 ; C0, 270.000, -1.000000
0B131E 01 F0 FF    0897*      dl 0xFFF001 ; C1, 271.406, -0.999699
0B1321 05 F0 FF    0898*      dl 0xFFF005 ; C2, 272.812, -0.998795
0B1324 0B F0 FF    0899*      dl 0xFFF00B ; C3, 274.219, -0.997290
0B1327 14 F0 FF    0900*      dl 0xFFF014 ; C4, 275.625, -0.995185
0B132A 1F F0 FF    0901*      dl 0xFFF01F ; C5, 277.031, -0.992480
0B132D 2C F0 FF    0902*      dl 0xFFF02C ; C6, 278.438, -0.989177
0B1330 3C F0 FF    0903*      dl 0xFFF03C ; C7, 279.844, -0.985278
0B1333 4F F0 FF    0904*      dl 0xFFF04F ; C8, 281.250, -0.980785
0B1336 64 F0 FF    0905*      dl 0xFFF064 ; C9, 282.656, -0.975702
0B1339 7B F0 FF    0906*      dl 0xFFF07B ; CA, 284.062, -0.970031
0B133C 94 F0 FF    0907*      dl 0xFFF094 ; CB, 285.469, -0.963776
0B133F B0 F0 FF    0908*      dl 0xFFF0B0 ; CC, 286.875, -0.956940
0B1342 CF F0 FF    0909*      dl 0xFFF0CF ; CD, 288.281, -0.949528
0B1345 EF F0 FF    0910*      dl 0xFFF0EF ; CE, 289.688, -0.941544
0B1348 12 F1 FF    0911*      dl 0xFFF112 ; CF, 291.094, -0.932993
0B134B 38 F1 FF    0912*      dl 0xFFF138 ; D0, 292.500, -0.923880
0B134E 5F F1 FF    0913*      dl 0xFFF15F ; D1, 293.906, -0.914210
0B1351 89 F1 FF    0914*      dl 0xFFF189 ; D2, 295.312, -0.903989
0B1354 B5 F1 FF    0915*      dl 0xFFF1B5 ; D3, 296.719, -0.893224
0B1357 E4 F1 FF    0916*      dl 0xFFF1E4 ; D4, 298.125, -0.881921
0B135A 14 F2 FF    0917*      dl 0xFFF214 ; D5, 299.531, -0.870087
0B135D 47 F2 FF    0918*      dl 0xFFF247 ; D6, 300.938, -0.857729
0B1360 7B F2 FF    0919*      dl 0xFFF27B ; D7, 302.344, -0.844854
0B1363 B2 F2 FF    0920*      dl 0xFFF2B2 ; D8, 303.750, -0.831470
0B1366 EB F2 FF    0921*      dl 0xFFF2EB ; D9, 305.156, -0.817585
0B1369 26 F3 FF    0922*      dl 0xFFF326 ; DA, 306.562, -0.803208
0B136C 63 F3 FF    0923*      dl 0xFFF363 ; DB, 307.969, -0.788346
0B136F A2 F3 FF    0924*      dl 0xFFF3A2 ; DC, 309.375, -0.773010
0B1372 E2 F3 FF    0925*      dl 0xFFF3E2 ; DD, 310.781, -0.757209
0B1375 25 F4 FF    0926*      dl 0xFFF425 ; DE, 312.188, -0.740951
0B1378 69 F4 FF    0927*      dl 0xFFF469 ; DF, 313.594, -0.724247
0B137B B0 F4 FF    0928*      dl 0xFFF4B0 ; E0, 315.000, -0.707107
0B137E F8 F4 FF    0929*      dl 0xFFF4F8 ; E1, 316.406, -0.689541
0B1381 41 F5 FF    0930*      dl 0xFFF541 ; E2, 317.812, -0.671559
0B1384 8D F5 FF    0931*      dl 0xFFF58D ; E3, 319.219, -0.653173
0B1387 DA F5 FF    0932*      dl 0xFFF5DA ; E4, 320.625, -0.634393
0B138A 28 F6 FF    0933*      dl 0xFFF628 ; E5, 322.031, -0.615232
0B138D 78 F6 FF    0934*      dl 0xFFF678 ; E6, 323.438, -0.595699
0B1390 C9 F6 FF    0935*      dl 0xFFF6C9 ; E7, 324.844, -0.575808
0B1393 1C F7 FF    0936*      dl 0xFFF71C ; E8, 326.250, -0.555570
0B1396 71 F7 FF    0937*      dl 0xFFF771 ; E9, 327.656, -0.534998
0B1399 C6 F7 FF    0938*      dl 0xFFF7C6 ; EA, 329.062, -0.514103
0B139C 1D F8 FF    0939*      dl 0xFFF81D ; EB, 330.469, -0.492898
0B139F 75 F8 FF    0940*      dl 0xFFF875 ; EC, 331.875, -0.471397
0B13A2 CE F8 FF    0941*      dl 0xFFF8CE ; ED, 333.281, -0.449611
0B13A5 29 F9 FF    0942*      dl 0xFFF929 ; EE, 334.688, -0.427555
0B13A8 84 F9 FF    0943*      dl 0xFFF984 ; EF, 336.094, -0.405241
0B13AB E1 F9 FF    0944*      dl 0xFFF9E1 ; F0, 337.500, -0.382683
0B13AE 3E FA FF    0945*      dl 0xFFFA3E ; F1, 338.906, -0.359895
0B13B1 9C FA FF    0946*      dl 0xFFFA9C ; F2, 340.312, -0.336890
0B13B4 FB FA FF    0947*      dl 0xFFFAFB ; F3, 341.719, -0.313682
0B13B7 5B FB FF    0948*      dl 0xFFFB5B ; F4, 343.125, -0.290285
0B13BA BC FB FF    0949*      dl 0xFFFBBC ; F5, 344.531, -0.266713
0B13BD 1D FC FF    0950*      dl 0xFFFC1D ; F6, 345.938, -0.242980
0B13C0 7F FC FF    0951*      dl 0xFFFC7F ; F7, 347.344, -0.219101
0B13C3 E1 FC FF    0952*      dl 0xFFFCE1 ; F8, 348.750, -0.195090
0B13C6 44 FD FF    0953*      dl 0xFFFD44 ; F9, 350.156, -0.170962
0B13C9 A7 FD FF    0954*      dl 0xFFFDA7 ; FA, 351.562, -0.146730
0B13CC 0B FE FF    0955*      dl 0xFFFE0B ; FB, 352.969, -0.122411
0B13CF 6F FE FF    0956*      dl 0xFFFE6F ; FC, 354.375, -0.098017
0B13D2 D3 FE FF    0957*      dl 0xFFFED3 ; FD, 355.781, -0.073565
0B13D5 37 FF FF    0958*      dl 0xFFFF37 ; FE, 357.188, -0.049068
0B13D8 9B FF FF    0959*      dl 0xFFFF9B ; FF, 358.594, -0.024541
0B13DB             0960*  
0B13DB             0961*  atan_lut_168:
0B13DB 00 00 00    0962*  	dl 0x000000 ; 000000, 0.000
0B13DE 28 00 00    0963*  	dl 0x000028 ; 000001, 0.224
0B13E1 51 00 00    0964*  	dl 0x000051 ; 000002, 0.448
0B13E4 7A 00 00    0965*  	dl 0x00007A ; 000003, 0.671
0B13E7 A2 00 00    0966*  	dl 0x0000A2 ; 000004, 0.895
0B13EA CB 00 00    0967*  	dl 0x0000CB ; 000005, 1.119
0B13ED F4 00 00    0968*  	dl 0x0000F4 ; 000006, 1.343
0B13F0 1D 01 00    0969*  	dl 0x00011D ; 000007, 1.566
0B13F3 45 01 00    0970*  	dl 0x000145 ; 000008, 1.790
0B13F6 6E 01 00    0971*  	dl 0x00016E ; 000009, 2.013
0B13F9 97 01 00    0972*  	dl 0x000197 ; 00000A, 2.237
0B13FC BF 01 00    0973*  	dl 0x0001BF ; 00000B, 2.460
0B13FF E8 01 00    0974*  	dl 0x0001E8 ; 00000C, 2.684
0B1402 11 02 00    0975*  	dl 0x000211 ; 00000D, 2.907
0B1405 39 02 00    0976*  	dl 0x000239 ; 00000E, 3.130
0B1408 62 02 00    0977*  	dl 0x000262 ; 00000F, 3.353
0B140B 8B 02 00    0978*  	dl 0x00028B ; 000010, 3.576
0B140E B3 02 00    0979*  	dl 0x0002B3 ; 000011, 3.799
0B1411 DC 02 00    0980*  	dl 0x0002DC ; 000012, 4.022
0B1414 04 03 00    0981*  	dl 0x000304 ; 000013, 4.245
0B1417 2D 03 00    0982*  	dl 0x00032D ; 000014, 4.467
0B141A 55 03 00    0983*  	dl 0x000355 ; 000015, 4.690
0B141D 7E 03 00    0984*  	dl 0x00037E ; 000016, 4.912
0B1420 A6 03 00    0985*  	dl 0x0003A6 ; 000017, 5.134
0B1423 CE 03 00    0986*  	dl 0x0003CE ; 000018, 5.356
0B1426 F7 03 00    0987*  	dl 0x0003F7 ; 000019, 5.578
0B1429 1F 04 00    0988*  	dl 0x00041F ; 00001A, 5.799
0B142C 48 04 00    0989*  	dl 0x000448 ; 00001B, 6.021
0B142F 70 04 00    0990*  	dl 0x000470 ; 00001C, 6.242
0B1432 98 04 00    0991*  	dl 0x000498 ; 00001D, 6.463
0B1435 C0 04 00    0992*  	dl 0x0004C0 ; 00001E, 6.684
0B1438 E8 04 00    0993*  	dl 0x0004E8 ; 00001F, 6.905
0B143B 11 05 00    0994*  	dl 0x000511 ; 000020, 7.125
0B143E 39 05 00    0995*  	dl 0x000539 ; 000021, 7.345
0B1441 61 05 00    0996*  	dl 0x000561 ; 000022, 7.565
0B1444 89 05 00    0997*  	dl 0x000589 ; 000023, 7.785
0B1447 B1 05 00    0998*  	dl 0x0005B1 ; 000024, 8.005
0B144A D9 05 00    0999*  	dl 0x0005D9 ; 000025, 8.224
0B144D 01 06 00    1000*  	dl 0x000601 ; 000026, 8.443
0B1450 28 06 00    1001*  	dl 0x000628 ; 000027, 8.662
0B1453 50 06 00    1002*  	dl 0x000650 ; 000028, 8.881
0B1456 78 06 00    1003*  	dl 0x000678 ; 000029, 9.099
0B1459 A0 06 00    1004*  	dl 0x0006A0 ; 00002A, 9.317
0B145C C7 06 00    1005*  	dl 0x0006C7 ; 00002B, 9.535
0B145F EF 06 00    1006*  	dl 0x0006EF ; 00002C, 9.752
0B1462 16 07 00    1007*  	dl 0x000716 ; 00002D, 9.970
0B1465 3E 07 00    1008*  	dl 0x00073E ; 00002E, 10.187
0B1468 65 07 00    1009*  	dl 0x000765 ; 00002F, 10.403
0B146B 8D 07 00    1010*  	dl 0x00078D ; 000030, 10.620
0B146E B4 07 00    1011*  	dl 0x0007B4 ; 000031, 10.836
0B1471 DB 07 00    1012*  	dl 0x0007DB ; 000032, 11.051
0B1474 03 08 00    1013*  	dl 0x000803 ; 000033, 11.267
0B1477 2A 08 00    1014*  	dl 0x00082A ; 000034, 11.482
0B147A 51 08 00    1015*  	dl 0x000851 ; 000035, 11.697
0B147D 78 08 00    1016*  	dl 0x000878 ; 000036, 11.911
0B1480 9F 08 00    1017*  	dl 0x00089F ; 000037, 12.125
0B1483 C6 08 00    1018*  	dl 0x0008C6 ; 000038, 12.339
0B1486 ED 08 00    1019*  	dl 0x0008ED ; 000039, 12.553
0B1489 13 09 00    1020*  	dl 0x000913 ; 00003A, 12.766
0B148C 3A 09 00    1021*  	dl 0x00093A ; 00003B, 12.978
0B148F 61 09 00    1022*  	dl 0x000961 ; 00003C, 13.191
0B1492 87 09 00    1023*  	dl 0x000987 ; 00003D, 13.403
0B1495 AE 09 00    1024*  	dl 0x0009AE ; 00003E, 13.614
0B1498 D4 09 00    1025*  	dl 0x0009D4 ; 00003F, 13.825
0B149B FB 09 00    1026*  	dl 0x0009FB ; 000040, 14.036
0B149E 21 0A 00    1027*  	dl 0x000A21 ; 000041, 14.247
0B14A1 47 0A 00    1028*  	dl 0x000A47 ; 000042, 14.457
0B14A4 6D 0A 00    1029*  	dl 0x000A6D ; 000043, 14.666
0B14A7 94 0A 00    1030*  	dl 0x000A94 ; 000044, 14.876
0B14AA BA 0A 00    1031*  	dl 0x000ABA ; 000045, 15.085
0B14AD E0 0A 00    1032*  	dl 0x000AE0 ; 000046, 15.293
0B14B0 05 0B 00    1033*  	dl 0x000B05 ; 000047, 15.501
0B14B3 2B 0B 00    1034*  	dl 0x000B2B ; 000048, 15.709
0B14B6 51 0B 00    1035*  	dl 0x000B51 ; 000049, 15.916
0B14B9 77 0B 00    1036*  	dl 0x000B77 ; 00004A, 16.123
0B14BC 9C 0B 00    1037*  	dl 0x000B9C ; 00004B, 16.329
0B14BF C2 0B 00    1038*  	dl 0x000BC2 ; 00004C, 16.535
0B14C2 E7 0B 00    1039*  	dl 0x000BE7 ; 00004D, 16.740
0B14C5 0C 0C 00    1040*  	dl 0x000C0C ; 00004E, 16.945
0B14C8 32 0C 00    1041*  	dl 0x000C32 ; 00004F, 17.150
0B14CB 57 0C 00    1042*  	dl 0x000C57 ; 000050, 17.354
0B14CE 7C 0C 00    1043*  	dl 0x000C7C ; 000051, 17.558
0B14D1 A1 0C 00    1044*  	dl 0x000CA1 ; 000052, 17.761
0B14D4 C6 0C 00    1045*  	dl 0x000CC6 ; 000053, 17.964
0B14D7 EB 0C 00    1046*  	dl 0x000CEB ; 000054, 18.166
0B14DA 0F 0D 00    1047*  	dl 0x000D0F ; 000055, 18.368
0B14DD 34 0D 00    1048*  	dl 0x000D34 ; 000056, 18.569
0B14E0 58 0D 00    1049*  	dl 0x000D58 ; 000057, 18.770
0B14E3 7D 0D 00    1050*  	dl 0x000D7D ; 000058, 18.970
0B14E6 A1 0D 00    1051*  	dl 0x000DA1 ; 000059, 19.170
0B14E9 C6 0D 00    1052*  	dl 0x000DC6 ; 00005A, 19.370
0B14EC EA 0D 00    1053*  	dl 0x000DEA ; 00005B, 19.569
0B14EF 0E 0E 00    1054*  	dl 0x000E0E ; 00005C, 19.767
0B14F2 32 0E 00    1055*  	dl 0x000E32 ; 00005D, 19.965
0B14F5 56 0E 00    1056*  	dl 0x000E56 ; 00005E, 20.163
0B14F8 7A 0E 00    1057*  	dl 0x000E7A ; 00005F, 20.360
0B14FB 9E 0E 00    1058*  	dl 0x000E9E ; 000060, 20.556
0B14FE C1 0E 00    1059*  	dl 0x000EC1 ; 000061, 20.752
0B1501 E5 0E 00    1060*  	dl 0x000EE5 ; 000062, 20.947
0B1504 08 0F 00    1061*  	dl 0x000F08 ; 000063, 21.142
0B1507 2C 0F 00    1062*  	dl 0x000F2C ; 000064, 21.337
0B150A 4F 0F 00    1063*  	dl 0x000F4F ; 000065, 21.531
0B150D 72 0F 00    1064*  	dl 0x000F72 ; 000066, 21.724
0B1510 95 0F 00    1065*  	dl 0x000F95 ; 000067, 21.917
0B1513 B8 0F 00    1066*  	dl 0x000FB8 ; 000068, 22.109
0B1516 DB 0F 00    1067*  	dl 0x000FDB ; 000069, 22.301
0B1519 FE 0F 00    1068*  	dl 0x000FFE ; 00006A, 22.493
0B151C 21 10 00    1069*  	dl 0x001021 ; 00006B, 22.683
0B151F 44 10 00    1070*  	dl 0x001044 ; 00006C, 22.874
0B1522 66 10 00    1071*  	dl 0x001066 ; 00006D, 23.063
0B1525 89 10 00    1072*  	dl 0x001089 ; 00006E, 23.253
0B1528 AB 10 00    1073*  	dl 0x0010AB ; 00006F, 23.441
0B152B CD 10 00    1074*  	dl 0x0010CD ; 000070, 23.629
0B152E EF 10 00    1075*  	dl 0x0010EF ; 000071, 23.817
0B1531 11 11 00    1076*  	dl 0x001111 ; 000072, 24.004
0B1534 33 11 00    1077*  	dl 0x001133 ; 000073, 24.191
0B1537 55 11 00    1078*  	dl 0x001155 ; 000074, 24.376
0B153A 77 11 00    1079*  	dl 0x001177 ; 000075, 24.562
0B153D 99 11 00    1080*  	dl 0x001199 ; 000076, 24.747
0B1540 BA 11 00    1081*  	dl 0x0011BA ; 000077, 24.931
0B1543 DC 11 00    1082*  	dl 0x0011DC ; 000078, 25.115
0B1546 FD 11 00    1083*  	dl 0x0011FD ; 000079, 25.298
0B1549 1E 12 00    1084*  	dl 0x00121E ; 00007A, 25.481
0B154C 3F 12 00    1085*  	dl 0x00123F ; 00007B, 25.663
0B154F 60 12 00    1086*  	dl 0x001260 ; 00007C, 25.844
0B1552 81 12 00    1087*  	dl 0x001281 ; 00007D, 26.025
0B1555 A2 12 00    1088*  	dl 0x0012A2 ; 00007E, 26.206
0B1558 C3 12 00    1089*  	dl 0x0012C3 ; 00007F, 26.386
0B155B E4 12 00    1090*  	dl 0x0012E4 ; 000080, 26.565
0B155E 04 13 00    1091*  	dl 0x001304 ; 000081, 26.744
0B1561 25 13 00    1092*  	dl 0x001325 ; 000082, 26.922
0B1564 45 13 00    1093*  	dl 0x001345 ; 000083, 27.100
0B1567 65 13 00    1094*  	dl 0x001365 ; 000084, 27.277
0B156A 85 13 00    1095*  	dl 0x001385 ; 000085, 27.453
0B156D A5 13 00    1096*  	dl 0x0013A5 ; 000086, 27.629
0B1570 C5 13 00    1097*  	dl 0x0013C5 ; 000087, 27.805
0B1573 E5 13 00    1098*  	dl 0x0013E5 ; 000088, 27.979
0B1576 05 14 00    1099*  	dl 0x001405 ; 000089, 28.154
0B1579 24 14 00    1100*  	dl 0x001424 ; 00008A, 28.327
0B157C 44 14 00    1101*  	dl 0x001444 ; 00008B, 28.501
0B157F 63 14 00    1102*  	dl 0x001463 ; 00008C, 28.673
0B1582 83 14 00    1103*  	dl 0x001483 ; 00008D, 28.845
0B1585 A2 14 00    1104*  	dl 0x0014A2 ; 00008E, 29.017
0B1588 C1 14 00    1105*  	dl 0x0014C1 ; 00008F, 29.187
0B158B E0 14 00    1106*  	dl 0x0014E0 ; 000090, 29.358
0B158E FF 14 00    1107*  	dl 0x0014FF ; 000091, 29.527
0B1591 1E 15 00    1108*  	dl 0x00151E ; 000092, 29.697
0B1594 3C 15 00    1109*  	dl 0x00153C ; 000093, 29.865
0B1597 5B 15 00    1110*  	dl 0x00155B ; 000094, 30.033
0B159A 79 15 00    1111*  	dl 0x001579 ; 000095, 30.201
0B159D 98 15 00    1112*  	dl 0x001598 ; 000096, 30.368
0B15A0 B6 15 00    1113*  	dl 0x0015B6 ; 000097, 30.534
0B15A3 D4 15 00    1114*  	dl 0x0015D4 ; 000098, 30.700
0B15A6 F2 15 00    1115*  	dl 0x0015F2 ; 000099, 30.865
0B15A9 10 16 00    1116*  	dl 0x001610 ; 00009A, 31.030
0B15AC 2E 16 00    1117*  	dl 0x00162E ; 00009B, 31.194
0B15AF 4C 16 00    1118*  	dl 0x00164C ; 00009C, 31.357
0B15B2 6A 16 00    1119*  	dl 0x00166A ; 00009D, 31.520
0B15B5 87 16 00    1120*  	dl 0x001687 ; 00009E, 31.682
0B15B8 A5 16 00    1121*  	dl 0x0016A5 ; 00009F, 31.844
0B15BB C2 16 00    1122*  	dl 0x0016C2 ; 0000A0, 32.005
0B15BE DF 16 00    1123*  	dl 0x0016DF ; 0000A1, 32.166
0B15C1 FC 16 00    1124*  	dl 0x0016FC ; 0000A2, 32.326
0B15C4 19 17 00    1125*  	dl 0x001719 ; 0000A3, 32.486
0B15C7 36 17 00    1126*  	dl 0x001736 ; 0000A4, 32.645
0B15CA 53 17 00    1127*  	dl 0x001753 ; 0000A5, 32.803
0B15CD 70 17 00    1128*  	dl 0x001770 ; 0000A6, 32.961
0B15D0 8C 17 00    1129*  	dl 0x00178C ; 0000A7, 33.118
0B15D3 A9 17 00    1130*  	dl 0x0017A9 ; 0000A8, 33.275
0B15D6 C5 17 00    1131*  	dl 0x0017C5 ; 0000A9, 33.431
0B15D9 E2 17 00    1132*  	dl 0x0017E2 ; 0000AA, 33.587
0B15DC FE 17 00    1133*  	dl 0x0017FE ; 0000AB, 33.742
0B15DF 1A 18 00    1134*  	dl 0x00181A ; 0000AC, 33.896
0B15E2 36 18 00    1135*  	dl 0x001836 ; 0000AD, 34.050
0B15E5 52 18 00    1136*  	dl 0x001852 ; 0000AE, 34.203
0B15E8 6E 18 00    1137*  	dl 0x00186E ; 0000AF, 34.356
0B15EB 8A 18 00    1138*  	dl 0x00188A ; 0000B0, 34.509
0B15EE A5 18 00    1139*  	dl 0x0018A5 ; 0000B1, 34.660
0B15F1 C1 18 00    1140*  	dl 0x0018C1 ; 0000B2, 34.811
0B15F4 DC 18 00    1141*  	dl 0x0018DC ; 0000B3, 34.962
0B15F7 F7 18 00    1142*  	dl 0x0018F7 ; 0000B4, 35.112
0B15FA 13 19 00    1143*  	dl 0x001913 ; 0000B5, 35.262
0B15FD 2E 19 00    1144*  	dl 0x00192E ; 0000B6, 35.410
0B1600 49 19 00    1145*  	dl 0x001949 ; 0000B7, 35.559
0B1603 64 19 00    1146*  	dl 0x001964 ; 0000B8, 35.707
0B1606 7F 19 00    1147*  	dl 0x00197F ; 0000B9, 35.854
0B1609 99 19 00    1148*  	dl 0x001999 ; 0000BA, 36.001
0B160C B4 19 00    1149*  	dl 0x0019B4 ; 0000BB, 36.147
0B160F CE 19 00    1150*  	dl 0x0019CE ; 0000BC, 36.293
0B1612 E9 19 00    1151*  	dl 0x0019E9 ; 0000BD, 36.438
0B1615 03 1A 00    1152*  	dl 0x001A03 ; 0000BE, 36.582
0B1618 1D 1A 00    1153*  	dl 0x001A1D ; 0000BF, 36.726
0B161B 37 1A 00    1154*  	dl 0x001A37 ; 0000C0, 36.870
0B161E 51 1A 00    1155*  	dl 0x001A51 ; 0000C1, 37.013
0B1621 6B 1A 00    1156*  	dl 0x001A6B ; 0000C2, 37.155
0B1624 85 1A 00    1157*  	dl 0x001A85 ; 0000C3, 37.297
0B1627 9F 1A 00    1158*  	dl 0x001A9F ; 0000C4, 37.439
0B162A B9 1A 00    1159*  	dl 0x001AB9 ; 0000C5, 37.579
0B162D D2 1A 00    1160*  	dl 0x001AD2 ; 0000C6, 37.720
0B1630 EC 1A 00    1161*  	dl 0x001AEC ; 0000C7, 37.859
0B1633 05 1B 00    1162*  	dl 0x001B05 ; 0000C8, 37.999
0B1636 1E 1B 00    1163*  	dl 0x001B1E ; 0000C9, 38.137
0B1639 37 1B 00    1164*  	dl 0x001B37 ; 0000CA, 38.276
0B163C 50 1B 00    1165*  	dl 0x001B50 ; 0000CB, 38.413
0B163F 69 1B 00    1166*  	dl 0x001B69 ; 0000CC, 38.550
0B1642 82 1B 00    1167*  	dl 0x001B82 ; 0000CD, 38.687
0B1645 9B 1B 00    1168*  	dl 0x001B9B ; 0000CE, 38.823
0B1648 B4 1B 00    1169*  	dl 0x001BB4 ; 0000CF, 38.959
0B164B CC 1B 00    1170*  	dl 0x001BCC ; 0000D0, 39.094
0B164E E5 1B 00    1171*  	dl 0x001BE5 ; 0000D1, 39.228
0B1651 FD 1B 00    1172*  	dl 0x001BFD ; 0000D2, 39.362
0B1654 16 1C 00    1173*  	dl 0x001C16 ; 0000D3, 39.496
0B1657 2E 1C 00    1174*  	dl 0x001C2E ; 0000D4, 39.629
0B165A 46 1C 00    1175*  	dl 0x001C46 ; 0000D5, 39.762
0B165D 5E 1C 00    1176*  	dl 0x001C5E ; 0000D6, 39.894
0B1660 76 1C 00    1177*  	dl 0x001C76 ; 0000D7, 40.025
0B1663 8E 1C 00    1178*  	dl 0x001C8E ; 0000D8, 40.156
0B1666 A5 1C 00    1179*  	dl 0x001CA5 ; 0000D9, 40.286
0B1669 BD 1C 00    1180*  	dl 0x001CBD ; 0000DA, 40.416
0B166C D5 1C 00    1181*  	dl 0x001CD5 ; 0000DB, 40.546
0B166F EC 1C 00    1182*  	dl 0x001CEC ; 0000DC, 40.675
0B1672 04 1D 00    1183*  	dl 0x001D04 ; 0000DD, 40.803
0B1675 1B 1D 00    1184*  	dl 0x001D1B ; 0000DE, 40.931
0B1678 32 1D 00    1185*  	dl 0x001D32 ; 0000DF, 41.059
0B167B 49 1D 00    1186*  	dl 0x001D49 ; 0000E0, 41.186
0B167E 60 1D 00    1187*  	dl 0x001D60 ; 0000E1, 41.312
0B1681 77 1D 00    1188*  	dl 0x001D77 ; 0000E2, 41.438
0B1684 8E 1D 00    1189*  	dl 0x001D8E ; 0000E3, 41.564
0B1687 A5 1D 00    1190*  	dl 0x001DA5 ; 0000E4, 41.689
0B168A BB 1D 00    1191*  	dl 0x001DBB ; 0000E5, 41.814
0B168D D2 1D 00    1192*  	dl 0x001DD2 ; 0000E6, 41.938
0B1690 E9 1D 00    1193*  	dl 0x001DE9 ; 0000E7, 42.061
0B1693 FF 1D 00    1194*  	dl 0x001DFF ; 0000E8, 42.184
0B1696 15 1E 00    1195*  	dl 0x001E15 ; 0000E9, 42.307
0B1699 2C 1E 00    1196*  	dl 0x001E2C ; 0000EA, 42.429
0B169C 42 1E 00    1197*  	dl 0x001E42 ; 0000EB, 42.551
0B169F 58 1E 00    1198*  	dl 0x001E58 ; 0000EC, 42.672
0B16A2 6E 1E 00    1199*  	dl 0x001E6E ; 0000ED, 42.793
0B16A5 84 1E 00    1200*  	dl 0x001E84 ; 0000EE, 42.913
0B16A8 99 1E 00    1201*  	dl 0x001E99 ; 0000EF, 43.033
0B16AB AF 1E 00    1202*  	dl 0x001EAF ; 0000F0, 43.152
0B16AE C5 1E 00    1203*  	dl 0x001EC5 ; 0000F1, 43.271
0B16B1 DA 1E 00    1204*  	dl 0x001EDA ; 0000F2, 43.390
0B16B4 F0 1E 00    1205*  	dl 0x001EF0 ; 0000F3, 43.508
0B16B7 05 1F 00    1206*  	dl 0x001F05 ; 0000F4, 43.625
0B16BA 1B 1F 00    1207*  	dl 0x001F1B ; 0000F5, 43.742
0B16BD 30 1F 00    1208*  	dl 0x001F30 ; 0000F6, 43.859
0B16C0 45 1F 00    1209*  	dl 0x001F45 ; 0000F7, 43.975
0B16C3 5A 1F 00    1210*  	dl 0x001F5A ; 0000F8, 44.091
0B16C6 6F 1F 00    1211*  	dl 0x001F6F ; 0000F9, 44.206
0B16C9 84 1F 00    1212*  	dl 0x001F84 ; 0000FA, 44.321
0B16CC 99 1F 00    1213*  	dl 0x001F99 ; 0000FB, 44.435
0B16CF AD 1F 00    1214*  	dl 0x001FAD ; 0000FC, 44.549
0B16D2 C2 1F 00    1215*  	dl 0x001FC2 ; 0000FD, 44.662
0B16D5 D7 1F 00    1216*  	dl 0x001FD7 ; 0000FE, 44.775
0B16D8 EB 1F 00    1217*  	dl 0x001FEB ; 0000FF, 44.888
0B16DB 00 20 00    1218*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B16DE             0023       include "files.inc"
0B16DE             0001*  ; load to onboard 8k sram
0B16DE             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B16DE             0024       include "timer.inc"
0B16DE             0001*  ; Table 32. Timer Control Registers
0B16DE             0002*  ; this constant is the base address of the timer control registers
0B16DE             0003*  ; each timer takes three bytes:
0B16DE             0004*  ;   0: control register
0B16DE             0005*  ;   1: low byte of timer reset value
0B16DE             0006*  ;   2: high byte of timer reset value
0B16DE             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B16DE             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B16DE             0009*  TMR_CTL:     equ 80h
0B16DE             0010*  
0B16DE             0011*  ; Timer Control Register Bit Definitions
0B16DE             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B16DE             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B16DE             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B16DE             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B16DE             0016*                              ; the TMRx_CTL register is read.
0B16DE             0017*  
0B16DE             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B16DE             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B16DE             0020*  
0B16DE             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B16DE             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B16DE             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B16DE             0024*                              ; written to the counter when the end-of-count value is reached.
0B16DE             0025*  
0B16DE             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B16DE             0027*  CLK_DIV_256:  equ %00001100 ;
0B16DE             0028*  CLK_DIV_64:   equ %00001000 ;
0B16DE             0029*  CLK_DIV_16:   equ %00000100 ;
0B16DE             0030*  CLK_DIV_4:    equ %00000000 ;
0B16DE             0031*  
0B16DE             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B16DE             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B16DE             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B16DE             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B16DE             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B16DE             0037*                              ; SINGLE-PASS mode is used.
0B16DE             0038*  
0B16DE             0039*  ; disable/enable the programmable reload timer
0B16DE             0040*  PRT_EN_0:     equ %00000000 ;
0B16DE             0041*  PRT_EN_1:     equ %00000001 ;
0B16DE             0042*  
0B16DE             0043*  ; Table 37. Timer Input Source Select Register
0B16DE             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B16DE             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B16DE             0046*  ;   00: System clock / CLK_DIV
0B16DE             0047*  ;   01: RTC / CLK_DIV
0B16DE             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B16DE             0049*  ;   10: GPIO port B pin 1.
0B16DE             0050*  ;   11: GPIO port B pin 1.
0B16DE             0051*  TMR_ISS:   equ 92h ; register address
0B16DE             0052*  
0B16DE             0053*  ; Table 51. Real-Time Clock Control Register
0B16DE             0054*  RTC_CTRL: equ EDh ; register address
0B16DE             0055*  
0B16DE             0056*  ; alarm interrupt disable/enable
0B16DE             0057*  RTC_ALARM_0:    equ %00000000
0B16DE             0058*  RTC_ALARM_1:    equ %10000000
0B16DE             0059*  
0B16DE             0060*  ; interrupt on alarm disable/enable
0B16DE             0061*  RTC_INT_ENT_0:  equ %00000000
0B16DE             0062*  RTC_INT_ENT_1:  equ %01000000
0B16DE             0063*  
0B16DE             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B16DE             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B16DE             0066*  
0B16DE             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B16DE             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B16DE             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B16DE             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B16DE             0071*  
0B16DE             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B16DE             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B16DE             0074*  
0B16DE             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B16DE             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B16DE             0077*  
0B16DE             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B16DE             0079*                                  ; RTC counter is enabled.
0B16DE             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B16DE             0081*                                  ; RTC counter is disabled.
0B16DE             0082*  
0B16DE             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B16DE             0084*  
0B16DE             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B16DE             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B16DE 00 00 00    0087*  prt_reload: dl 0x000000
0B16E1             0088*  
0B16E1             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B16E1             0090*  ; ;          de = number PRT interrupts during test interval
0B16E1             0091*  ; prt_calibrate:
0B16E1             0092*  ;     call vdu_vblank
0B16E1             0093*  ; ; set a MOS timer
0B16E1             0094*  ;     ld hl,120*1 ; 1 second
0B16E1             0095*  ;     ld iy,tmr_test
0B16E1             0096*  ;     call tmr_set
0B16E1             0097*  ; ; set a PRT timer
0B16E1             0098*  ;     ; ld hl,prt_reload_hardware
0B16E1             0099*  ;     ; ld hl,prt_reload_emulator
0B16E1             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B16E1             0101*  ;     ld (prt_reload),hl
0B16E1             0102*  ;     call prt_set
0B16E1             0103*  ; @loop:
0B16E1             0104*  ; ; check time remaining on MOS timer
0B16E1             0105*  ;     call tmr_get
0B16E1             0106*  ;     jp z,@done ; time expired,so quit
0B16E1             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B16E1             0108*  ;     jr @loop
0B16E1             0109*  ; @done:
0B16E1             0110*  ;     ld de,(prt_irq_counter)
0B16E1             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B16E1             0112*  ;     ld (prt_reload),bc
0B16E1             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B16E1             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B16E1             0115*  ;     ld (is_emulator),a
0B16E1             0116*  ;     sbc hl,de
0B16E1             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B16E1             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B16E1             0119*  ;     ret m ; negative result means we're on hardware
0B16E1             0120*  ;     inc a ; we're on emulator
0B16E1             0121*  ;     ld (is_emulator),a
0B16E1             0122*  ;     ld bc,prt_reload_emulator
0B16E1             0123*  ;     ld (prt_reload),bc
0B16E1             0124*  ;     ld hl,on_emulator
0B16E1             0125*  ;     ret
0B16E1             0126*  
0B16E1             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B16E1             0128*  
0B16E1             0129*  ; set PRT timer
0B16E1             0130*  prt_set:
0B16E1 21 00 00 00 0131*      ld hl,0
0B16E5 22 2F 17 0B 0132*      ld (prt_irq_counter),hl
0B16E9 2A DE 16 0B 0133*      ld hl,(prt_reload)
0B16ED ED 29 84    0134*      out0 ($84),l
0B16F0 ED 21 85    0135*  	out0 ($85),h
0B16F3             0136*  ; disable timer
0B16F3 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B16F5 ED 39 83    0138*  	out0 ($83),a
0B16F8             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B16F8 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B16FA ED 39 83    0141*  	out0 ($83),a
0B16FD C9          0142*      ret
0B16FE             0143*  
0B16FE             0144*  ; ===============================================
0B16FE             0145*  ; PRT Timer Interrupt Handling
0B16FE             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B16FE             0147*  ; -----------------------------------------------
0B16FE             0148*  prt_irq_init:
0B16FE             0149*      ; set up interrupt vector table 2
0B16FE 21 00 00 00 0150*  	ld hl,0
0B1702 3A 0C 01 00 0151*  	ld a,($10c)
0B1706 6F          0152*  	ld l,a
0B1707 3A 0D 01 00 0153*  	ld a,($10d)
0B170B 67          0154*  	ld h,a
0B170C             0155*  
0B170C             0156*  	; skip over CALL ($c3)
0B170C 23          0157*  	inc hl
0B170D             0158*  	; load address of jump into vector table 2 (in ram)
0B170D ED 27       0159*  	ld hl,(hl)
0B170F             0160*  
0B170F             0161*  	; write CALL prt_irq_handler to vector table 2
0B170F 3E C3       0162*  	ld a,$c3
0B1711 77          0163*  	ld (hl),a
0B1712 23          0164*  	inc hl
0B1713 11 1A 17 0B 0165*  	ld de,prt_irq_handler
0B1717 ED 1F       0166*  	ld (hl),de
0B1719             0167*  
0B1719 C9          0168*      ret
0B171A             0169*  
0B171A             0170*  prt_irq_handler:
0B171A F3          0171*  	di
0B171B F5          0172*  	push af
0B171C E5          0173*      push hl
0B171D ED 38 83    0174*  	in0 a,($83)
0B1720 2A 2F 17 0B 0175*  	ld hl,(prt_irq_counter)
0B1724 23          0176*  	inc hl
0B1725 22 2F 17 0B 0177*  	ld (prt_irq_counter),hl
0B1729 E1          0178*      pop hl
0B172A F1          0179*  	pop af
0B172B FB          0180*  	ei
0B172C 5B ED 4D    0181*  	reti.l
0B172F             0182*  
0B172F             0183*  prt_irq_counter:
0B172F 00 00 00    0184*  	.dl 0
0B1732             0185*  prt_irq_counter_saved:
0B1732 00 00 00    0186*      .dl 0
0B1735             0187*  
0B1735             0188*  prt_loop_reset:
0B1735 E5          0189*      push hl
0B1736 21 00 00 00 0190*  	ld hl,0
0B173A 22 2F 17 0B 0191*  	ld (prt_irq_counter),hl
0B173E 22 A0 17 0B 0192*      ld (prt_loop_counter),hl
0B1742 22 A3 17 0B 0193*      ld (prt_loops),hl
0B1746 CD E1 16 0B 0194*      call prt_set
0B174A E1          0195*      pop hl
0B174B C9          0196*      ret
0B174C             0197*  
0B174C             0198*  prt_loop_start:
0B174C E5          0199*      push hl
0B174D 21 00 00 00 0200*  	ld hl,0
0B1751 22 2F 17 0B 0201*  	ld (prt_irq_counter),hl
0B1755 E1          0202*      pop hl
0B1756 C9          0203*      ret
0B1757             0204*  
0B1757             0205*  prt_loop_stop:
0B1757 E5          0206*      push hl
0B1758 D5          0207*      push de
0B1759 2A 2F 17 0B 0208*      ld hl,(prt_irq_counter)
0B175D ED 5B A0 17 0209*      ld de,(prt_loop_counter)
       0B          
0B1762 19          0210*      add hl,de
0B1763 22 A0 17 0B 0211*      ld (prt_loop_counter),hl
0B1767 21 00 00 00 0212*      ld hl,0
0B176B 22 2F 17 0B 0213*      ld (prt_irq_counter),hl
0B176F 2A A3 17 0B 0214*      ld hl,(prt_loops)
0B1773 23          0215*      inc hl
0B1774 22 A3 17 0B 0216*      ld (prt_loops),hl
0B1778 D1          0217*      pop de
0B1779 E1          0218*      pop hl
0B177A C9          0219*      ret
0B177B             0220*  
0B177B             0221*  ; inputs: bc = y,x text coordinates to print
0B177B             0222*  prt_loop_print:
0B177B F5          0223*      push af
0B177C E5          0224*      push hl
0B177D C5          0225*      push bc
0B177E D5          0226*      push de
0B177F DD E5       0227*      push ix
0B1781 FD E5       0228*      push iy
0B1783 CD 98 18 0B 0229*      call vdu_move_cursor
0B1787             0230*  
0B1787 2A A0 17 0B 0231*      ld hl,(prt_loop_counter)
0B178B CD 2B 03 0B 0232*      call printDec
0B178F             0233*  
0B178F 2A A3 17 0B 0234*      ld hl,(prt_loops)
0B1793 CD 2B 03 0B 0235*      call printDec
0B1797             0236*  
0B1797 FD E1       0237*      pop iy
0B1799 DD E1       0238*      pop ix
0B179B D1          0239*      pop de
0B179C C1          0240*      pop bc
0B179D E1          0241*      pop hl
0B179E F1          0242*      pop af
0B179F C9          0243*      ret
0B17A0             0244*  
0B17A0             0245*  prt_loop_counter:
0B17A0 00 00 00    0246*      .dl 0
0B17A3             0247*  prt_loops:
0B17A3 00 00 00    0248*      .dl 0
0B17A6             0249*  
0B17A6             0250*  ; ===============================================
0B17A6             0251*  ; Timer functions
0B17A6             0252*  ; -----------------------------------------------
0B17A6             0253*  ; set a countdown timer
0B17A6             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B17A6             0255*  ; returns: hl = current time
0B17A6             0256*  tmr_set:
0B17A6 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B17A9             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B17A9 3E 08       0001*M 			LD	A, function
0B17AB 5B CF       0002*M 			RST.L	08h
0B17AD DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B17B0 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B17B3 C9          0261*      ret
0B17B4             0262*  
0B17B4             0263*  ; gets time remaining on a countdown timer
0B17B4             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B17B4             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B17B4             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B17B4             0267*  tmr_get:
0B17B4             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B17B4 3E 08       0001*M 			LD	A, function
0B17B6 5B CF       0002*M 			RST.L	08h
0B17B8 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B17BB FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B17BE AF          0271*      xor a                   ; clear carry
0B17BF ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B17C1 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B17C4 AF          0274*      xor a                   ; clear carry
0B17C5 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B17C7             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B17C7 C9          0277*      ret
0B17C8             0278*  
0B17C8 00 00 00    0279*  timestamp_now: dl 0
0B17CB 00 00 00    0280*  timestamp_old: dl 0
0B17CE 00 00 00    0281*  timestamp_chg: dl 0
0B17D1             0282*  
0B17D1             0283*  ; update the global timestamp from the system clock
0B17D1             0284*  ; inputs: none
0B17D1             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B17D1             0286*  ;          de = current time
0B17D1             0287*  ;          ix = pointer to syvars table
0B17D1             0288*  ; destroys: af,hl,de,ix
0B17D1             0289*  timestamp_tick:
0B17D1 ED 5B C8 17 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B17D6 ED 53 CB 17 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B17DB             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B17DB 3E 08       0001*M 			LD	A, function
0B17DD 5B CF       0002*M 			RST.L	08h
0B17DF DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B17E2 22 C8 17 0B 0294*      ld (timestamp_now),hl   ; save current time
0B17E6 AF          0295*      xor a                   ; clear carry
0B17E7 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B17E9 22 CE 17 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B17ED C9          0298*      ret
0B17EE             0299*  
0B17EE             0300*  ; set a countdown timer
0B17EE             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B17EE             0302*  ; requires: timestamp_tick to be called at least once before this function
0B17EE             0303*  ; returns: hl = current time
0B17EE             0304*  ; destroys: hl
0B17EE             0305*  timestamp_tmr_set:
0B17EE FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B17F1 2A C8 17 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B17F5 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B17F8 C9          0309*      ret
0B17F9             0310*  
0B17F9             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B17F9             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B17F9             0313*  ; requires: timestamp_tick to be called at least once before this function
0B17F9             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B17F9             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B17F9             0316*  ; destroys: af,hl,de
0B17F9             0317*  timestamp_tmr_get:
0B17F9 ED 5B C8 17 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B17FE FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B1801 AF          0320*      xor a                   ; clear carry
0B1802 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1804 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B1807 AF          0323*      xor a                   ; clear carry
0B1808 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B180A             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B180A C9          0326*      ret
0B180B             0327*  
0B180B             0328*  ; main loop timer functions
0B180B             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B1811             0330*  
0B1811             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B1811             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B1811             0333*  ; returns: hl = current time
0B1811             0334*  ; destroys: af,hl,de,ix,iy
0B1811             0335*  tmr_main_loop_set:
0B1811 FD 21 0B 18 0336*      ld iy,tmr_main_loop
       0B          
0B1816 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B1819 CD D1 17 0B 0338*      call timestamp_tick
0B181D 2A C8 17 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B1821 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B1824 C9          0341*      ret
0B1825             0342*  
0B1825             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B1825             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1825             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1825             0346*  ; destroys: af,hl,de,ix,iy
0B1825             0347*  tmr_main_loop_get:
0B1825 CD D1 17 0B 0348*      call timestamp_tick
0B1829 FD 21 0B 18 0349*      ld iy,tmr_main_loop
       0B          
0B182E CD F9 17 0B 0350*      call timestamp_tmr_get
0B1832 C9          0351*      ret
0B1833             0352*  
0B1833             0353*  ; set a stopwatch
0B1833             0354*  ; returns: hl = start time
0B1833             0355*  ; destroys: hl,ix
0B1833             0356*  stopwatch_set:
0B1833             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1833 3E 08       0001*M 			LD	A, function
0B1835 5B CF       0002*M 			RST.L	08h
0B1837 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B183A 22 4F 18 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B183E C9          0360*      ret
0B183F             0361*  
0B183F             0362*  ; gets time elapsed on a stopwatch
0B183F             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B183F             0364*  ; destroys: af,hl,de,ix
0B183F             0365*  stopwatch_get:
0B183F             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B183F 3E 08       0001*M 			LD	A, function
0B1841 5B CF       0002*M 			RST.L	08h
0B1843 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B1846 ED 5B 4F 18 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B184B AF          0369*      xor a                   ; clear carry
0B184C ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B184E C9          0371*      ret
0B184F             0372*  
0B184F             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B1852             0374*  
0B1852             0375*  ; ------------------
0B1852             0376*  ; delay routine
0B1852             0377*  ; Author: Richard Turrnidge
0B1852             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B1852             0379*  ; routine waits a fixed time,then returns
0B1852             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B1852             0381*  ; eg. ld A,00000100b
0B1852             0382*  
0B1852             0383*  multiPurposeDelay:
0B1852 F5          0384*      push af
0B1853 C5          0385*      push bc
0B1854 DD E5       0386*      push ix
0B1856 47          0387*      ld b,a
0B1857 3E 08       0388*      ld a,$08
0B1859 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B185B             0390*  
0B185B             0391*  waitLoop:
0B185B             0392*  
0B185B DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B185E             0394*  
0B185E             0395*                                  ;   we check if bit set is same as last time we checked.
0B185E             0396*                                  ;   bit 0 - don't use
0B185E             0397*                                  ;   bit 1 - changes 64 times per second
0B185E             0398*                                  ;   bit 2 - changes 32 times per second
0B185E             0399*                                  ;   bit 3 - changes 16 times per second
0B185E             0400*  
0B185E             0401*                                  ;   bit 4 - changes 8 times per second
0B185E             0402*                                  ;   bit 5 - changes 4 times per second
0B185E             0403*                                  ;   bit 6 - changes 2 times per second
0B185E             0404*                                  ;   bit 7 - changes 1 times per second
0B185E A0          0405*      and b
0B185F 4F          0406*      ld c,a
0B1860 3A 71 18 0B 0407*      ld a,(oldTimeStamp)
0B1864 B9          0408*      cp c                        ; is A same as last value?
0B1865 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B1867 79          0410*      ld a,c
0B1868 32 71 18 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B186C             0412*  
0B186C DD E1       0413*      pop ix
0B186E C1          0414*      pop bc
0B186F F1          0415*      pop af
0B1870 C9          0416*      ret
0B1871             0417*  
0B1871 00          0418*  oldTimeStamp:   .db 00h
0B1872             0025       include "vdu.inc"
0B1872             0001*  
0B1872             0002*  ; VDU 30: Home cursor
0B1872             0003*  vdu_home_cursor:
0B1872 3E 1E       0004*      ld a,30
0B1874 5B D7       0005*  	rst.lil $10
0B1876 C9          0006*  	ret
0B1877             0007*  
0B1877             0008*  cursor_on:
0B1877 21 82 18 0B 0009*  	ld hl,@cmd
0B187B 01 03 00 00 0010*  	ld bc,@end-@cmd
0B187F 5B DF       0011*  	rst.lil $18
0B1881 C9          0012*  	ret
0B1882             0013*  @cmd:
0B1882 17 01 01    0014*  	db 23,1,1
0B1885             0015*  @end:
0B1885             0016*  
0B1885             0017*  cursor_off:
0B1885 21 90 18 0B 0018*  	ld hl,@cmd
0B1889 01 03 00 00 0019*  	ld bc,@end-@cmd
0B188D 5B DF       0020*  	rst.lil $18
0B188F C9          0021*  	ret
0B1890             0022*  @cmd:
0B1890 17 01 00    0023*  	db 23,1,0
0B1893             0024*  @end:
0B1893             0025*  
0B1893             0026*  ; VDU 9: Move cursor forward one character
0B1893             0027*  vdu_cursor_forward:
0B1893 3E 09       0028*      ld a,9
0B1895 5B D7       0029*  	rst.lil $10
0B1897 C9          0030*  	ret
0B1898             0031*  
0B1898             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B1898             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B1898             0034*  vdu_move_cursor:
0B1898 ED 43 A9 18 0035*      ld (@x0),bc
       0B          
0B189D 21 A8 18 0B 0036*  	ld hl,@cmd
0B18A1 01 03 00 00 0037*  	ld bc,@end-@cmd
0B18A5 5B DF       0038*  	rst.lil $18
0B18A7 C9          0039*  	ret
0B18A8 1F          0040*  @cmd: 	db 31
0B18A9 00          0041*  @x0:	db 0
0B18AA 00          0042*  @y0: 	db 0
0B18AB 00          0043*  @end: 	db 0 ; padding
0B18AC             0044*  
0B18AC             0045*  ; VDU 12: Clear text area (CLS)
0B18AC             0046*  vdu_cls:
0B18AC 3E 0C       0047*      ld a,12
0B18AE 5B D7       0048*  	rst.lil $10
0B18B0 C9          0049*  	ret
0B18B1             0050*  
0B18B1             0051*  vdu_flip:
0B18B1 21 BC 18 0B 0052*  	ld hl,@cmd
0B18B5 01 03 00 00 0053*  	ld bc,@end-@cmd
0B18B9 5B DF       0054*  	rst.lil $18
0B18BB C9          0055*  	ret
0B18BC 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B18BF             0057*  @end:
0B18BF             0058*  
0B18BF             0059*  ; VDU 16: Clear graphics area (CLG)
0B18BF             0060*  vdu_clg:
0B18BF 3E 10       0061*      ld a,16
0B18C1 5B D7       0062*  	rst.lil $10
0B18C3 C9          0063*  	ret
0B18C4             0064*  
0B18C4             0065*  ; COLOUR MODES
0B18C4             0066*  ; Mode	Effect
0B18C4             0067*  ; 0	Set on-screen pixel to target colour value
0B18C4             0068*  ; 1	OR value with the on-screen pixel
0B18C4             0069*  ; 2	AND value with the on-screen pixel
0B18C4             0070*  ; 3	XOR value with the on-screen pixel
0B18C4             0071*  ; 4	Invert the on-screen pixel
0B18C4             0072*  ; 5	No operation
0B18C4             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B18C4             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B18C4             0075*  
0B18C4             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B18C4             0077*  vdu_colour_text:
0B18C4 32 D4 18 0B 0078*  	ld (@arg),a
0B18C8 21 D3 18 0B 0079*  	ld hl,@cmd
0B18CC 01 02 00 00 0080*  	ld bc,@end-@cmd
0B18D0 5B DF       0081*  	rst.lil $18
0B18D2 C9          0082*  	ret
0B18D3 11          0083*  @cmd: db 17
0B18D4 00          0084*  @arg: db 0
0B18D5             0085*  @end:
0B18D5             0086*  
0B18D5             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B18D5             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B18D5             0089*  vdu_gcol:
0B18D5 32 EA 18 0B 0090*  	ld (@mode),a
0B18D9 79          0091*      ld a,c
0B18DA 32 EB 18 0B 0092*      ld (@col),a
0B18DE 21 E9 18 0B 0093*  	ld hl,@cmd
0B18E2 01 03 00 00 0094*  	ld bc,@end-@cmd
0B18E6 5B DF       0095*  	rst.lil $18
0B18E8 C9          0096*  	ret
0B18E9 12          0097*  @cmd:  db 18
0B18EA 00          0098*  @mode: db 0
0B18EB 00          0099*  @col:  db 0
0B18EC             0100*  @end:
0B18EC             0101*  
0B18EC             0102*  
0B18EC             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B18EC             0104*  ; MIND THE LITTLE-ENDIANESS
0B18EC             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B18EC             0106*  ; outputs; nothing
0B18EC             0107*  ; destroys: a might make it out alive
0B18EC             0108*  vdu_set_txt_viewport:
0B18EC ED 43 02 19 0109*      ld (@lb),bc
       0B          
0B18F1 ED 53 04 19 0110*  	ld (@rt),de
       0B          
0B18F6 21 01 19 0B 0111*  	ld hl,@cmd
0B18FA 01 05 00 00 0112*  	ld bc,@end-@cmd
0B18FE 5B DF       0113*  	rst.lil $18
0B1900 C9          0114*  	ret
0B1901 1C          0115*  @cmd:   db 28 ; set text viewport command
0B1902 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B1904 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B1906 00          0118*  @end:   db 0x00	  ; padding
0B1907             0119*  
0B1907             0120*  ; Wait for VBLANK interrupt
0B1907             0121*  vdu_vblank:
0B1907 DD E5       0122*      PUSH 	IX
0B1909             0123*  	MOSCALL	mos_sysvars
0B1909 3E 08       0001*M 			LD	A, function
0B190B 5B CF       0002*M 			RST.L	08h
0B190D DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B1910             0125*  @wait:
0B1910 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B1913 28 FB       0127*      JR	Z, @wait
0B1915 DD E1       0128*      POP	IX
0B1917 C9          0129*      RET
0B1918             0130*  
0B1918             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B1918             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B1918             0133*  ; 	because we have turned off logical screen scaling
0B1918             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B1918             0135*  ; outputs; nothing
0B1918             0136*  ; destroys: a might make it out alive
0B1918             0137*  vdu_set_gfx_viewport:
0B1918 ED 43 38 19 0138*      ld (@x0),bc
       0B          
0B191D FD 22 3A 19 0139*      ld (@y1),iy
       0B          
0B1922 DD 22 3C 19 0140*  	ld (@x1),ix
       0B          
0B1927 ED 53 3E 19 0141*  	ld (@y0),de
       0B          
0B192C 21 37 19 0B 0142*  	ld hl,@cmd
0B1930 01 09 00 00 0143*  	ld bc,@end-@cmd
0B1934 5B DF       0144*  	rst.lil $18
0B1936 C9          0145*  	ret
0B1937 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B1938 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B193A 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B193C 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B193E 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B1940 00          0151*  @end:   db 0x00	  ; padding
0B1941             0152*  
0B1941             0153*  ; SCREEN MODES
0B1941             0154*  ; ===============================
0B1941             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B1941             0156*  ; ---   ----  ----  ----  -------
0B1941             0157*  ; 11    320   240   2     60hz
0B1941             0158*  ; 139   320   240   2     60hz
0B1941             0159*  ; 23    512   384   2     60hz
0B1941             0160*  ; 151   512   384   2     60hz
0B1941             0161*  ; 6     640   240   2     60hz
0B1941             0162*  ; 134   640   240   2     60hz
0B1941             0163*  ; 2     640   480   2     60hz
0B1941             0164*  ; 130   640   480   2     60hz
0B1941             0165*  ; 17    800   600   2     60hz
0B1941             0166*  ; 145   800   600   2     60hz
0B1941             0167*  ; 18    1024  768   2     60hz
0B1941             0168*  ; 146   1024  768   2     60hz
0B1941             0169*  ; ---   ----  ----  ----  -------
0B1941             0170*  ; 10    320   240   4     60hz
0B1941             0171*  ; 138   320   240   4     60hz
0B1941             0172*  ; 22    512   384   4     60hz
0B1941             0173*  ; 150   512   384   4     60hz
0B1941             0174*  ; 5     640   240   4     60hz
0B1941             0175*  ; 133   640   240   4     60hz
0B1941             0176*  ; 1     640   480   4     60hz
0B1941             0177*  ; 129   640   480   4     60hz
0B1941             0178*  ; 16    800   600   4     60hz
0B1941             0179*  ; 19    1024  768   4     60hz
0B1941             0180*  ; ---   ----  ----  ----  -------
0B1941             0181*  ; 9     320   240   16    60hz
0B1941             0182*  ; 137   320   240   16    60hz
0B1941             0183*  ; 21    512   384   16    60hz
0B1941             0184*  ; 149   512   384   16    60hz
0B1941             0185*  ; 4     640   240   16    60hz
0B1941             0186*  ; 132   640   240   16    60hz
0B1941             0187*  ; 0     640   480   16    60hz
0B1941             0188*  ; 7     n/a   n/a   16    60hz
0B1941             0189*  ; ---   ----  ----  ----  -------
0B1941             0190*  ; 8     320   240   64    60hz
0B1941             0191*  ; 136   320   240   64    60hz
0B1941             0192*  ; 20    512   384   64    60hz
0B1941             0193*  ; 3     640   240   64    60hz
0B1941             0194*  ; ---   ----  ----  ----  -------
0B1941             0195*  vdu_set_screen_mode:
0B1941 32 51 19 0B 0196*  	ld (@arg),a
0B1945 21 50 19 0B 0197*  	ld hl,@cmd
0B1949 01 02 00 00 0198*  	ld bc,@end-@cmd
0B194D 5B DF       0199*  	rst.lil $18
0B194F C9          0200*  	ret
0B1950 16          0201*  @cmd: db 22 ; set screen mode
0B1951 00          0202*  @arg: db 0  ; screen mode parameter
0B1952             0203*  @end:
0B1952             0204*  
0B1952             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B1952             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B1952             0207*  ; note: default setting on boot is scaling ON
0B1952             0208*  vdu_set_scaling:
0B1952 32 64 19 0B 0209*  	ld (@arg),a
0B1956 21 61 19 0B 0210*  	ld hl,@cmd
0B195A 01 04 00 00 0211*  	ld bc,@end-@cmd
0B195E 5B DF       0212*  	rst.lil $18
0B1960 C9          0213*  	ret
0B1961 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B1964 00          0215*  @arg: db 0  ; scaling on/off
0B1965             0216*  @end:
0B1965             0217*  
0B1965             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B1965             0219*  ; inputs: hl=bufferId
0B1965             0220*  vdu_buff_select:
0B1965 22 77 19 0B 0221*  	ld (@bufferId),hl
0B1969 21 74 19 0B 0222*  	ld hl,@cmd
0B196D 01 05 00 00 0223*  	ld bc,@end-@cmd
0B1971 5B DF       0224*  	rst.lil $18
0B1973 C9          0225*  	ret
0B1974 17 1B 20    0226*  @cmd: db 23,27,0x20
0B1977 00 00       0227*  @bufferId: dw 0x0000
0B1979 00          0228*  @end: db 0x00 ; padding
0B197A             0229*  
0B197A             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B197A             0231*  ; inputs: a=format; bc=width; de=height
0B197A             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B197A             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B197A             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B197A             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B197A             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B197A             0237*  ; 3 	Reserved for internal use by VDP (native format)
0B197A             0238*  vdu_bmp_create:
0B197A ED 43 96 19 0239*      ld (@width),bc
       0B          
0B197F ED 53 98 19 0240*      ld (@height),de
       0B          
0B1984 32 9A 19 0B 0241*      ld (@fmt),a
0B1988 21 93 19 0B 0242*  	ld hl,@cmd
0B198C 01 08 00 00 0243*  	ld bc,@end-@cmd
0B1990 5B DF       0244*  	rst.lil $18
0B1992 C9          0245*  	ret
0B1993 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B1996 00 00       0247*  @width:     dw 0x0000
0B1998 00 00       0248*  @height:    dw 0x0000
0B199A 00          0249*  @fmt:       db 0x00
0B199B             0250*  @end:
0B199B             0251*  
0B199B             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B199B             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B199B             0254*  vdu_load_img_rgba2_to_8:
0B199B             0255*  ; backup the target buffer id and image dimensions
0B199B E5          0256*      push hl
0B199C D5          0257*      push de
0B199D C5          0258*      push bc
0B199E             0259*  ; load the rgba2 image to working buffer 65534
0B199E 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B19A2 CD A5 1A 0B 0261*  	call vdu_load_buffer_from_file
0B19A6             0262*  ; restore the image dimensions and target buffer id
0B19A6 C1          0263*      pop bc
0B19A7 D1          0264*      pop de
0B19A8 E1          0265*      pop hl
0B19A9             0266*  ; fall through to vdu_rgba2_to_8
0B19A9             0267*  
0B19A9             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B19A9             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B19A9             0270*  ; the "expand bitmap" command is:
0B19A9             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B19A9             0272*  ; and then to reverse the byte order to fix endian-ness:
0B19A9             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B19A9             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B19A9             0275*  ; VDU 23,27,&20,targetBufferID%;
0B19A9             0276*  ; VDU 23,27,&21,width%;height%;0
0B19A9             0277*  ; -------------------------------------------------------------------
0B19A9             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B19A9             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B19A9             0280*  vdu_rgba2_to_8:
0B19A9             0281*  ; load the image dimensions and buffer id parameters
0B19A9 ED 43 05 1A 0282*      ld (@width),bc
       0B          
0B19AE ED 53 07 1A 0283*      ld (@height),de
       0B          
0B19B3 22 EA 19 0B 0284*      ld (@bufferId0),hl
0B19B7 22 F7 19 0B 0285*      ld (@bufferId2),hl
0B19BB 22 00 1A 0B 0286*      ld (@bufferId1),hl
0B19BF             0287*  ; clean up bytes that got stomped on by the ID loads
0B19BF 3E 48       0288*      ld a,0x48
0B19C1 32 EC 19 0B 0289*      ld (@bufferId0+2),a
0B19C5 3E 17       0290*      ld a,23
0B19C7 32 02 1A 0B 0291*      ld (@bufferId1+2),a
0B19CB 3E 18       0292*      ld a,24
0B19CD 32 F9 19 0B 0293*      ld (@bufferId2+2),a
0B19D1 AF          0294*      xor a
0B19D2 32 09 1A 0B 0295*      ld (@height+2),a
0B19D6             0296*  ; send the vdu command strings
0B19D6 21 E1 19 0B 0297*      ld hl,@beg
0B19DA 01 29 00 00 0298*      ld bc,@end-@beg
0B19DE 5B DF       0299*      rst.lil $18
0B19E0 C9          0300*      ret
0B19E1             0301*  @beg:
0B19E1             0302*  ; Command 14: Consolidate blocks in a buffer
0B19E1             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B19E1 17 00 A0    0304*      db 23,0,0xA0
0B19E4 FE FF       0305*      dw 65534 ; workingBufferId
0B19E6 0E          0306*      db 14 ; consolidate blocks
0B19E7             0307*  ; the "expand bitmap" command is:
0B19E7             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B19E7 17 00 A0    0309*      db 23,0,0xA0
0B19EA 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B19EC 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B19ED 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B19EE FE FF       0313*      dw 65534 ; sourceBufferId
0B19F0 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B19F4             0315*  ; reverse the byte order to fix endian-ness:
0B19F4             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B19F4             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B19F4             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B19F4 17 00 A0    0319*      db 23,0,0xA0
0B19F7 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B19F9 18          0321*      db 24 ; reverse byte order
0B19FA 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B19FB 04 00       0323*      dw 4 ; size (4 bytes)
0B19FD             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B19FD             0325*  ; VDU 23,27,&20,targetBufferID%;
0B19FD 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B1A00 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B1A02             0328*  ; VDU 23,27,&21,width%;height%;0
0B1A02 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B1A05 00 00       0330*  @width: dw 0x0000
0B1A07 00 00       0331*  @height: dw 0x0000
0B1A09 00          0332*      db 0x00 ; rgba8888 format
0B1A0A             0333*  @end:
0B1A0A             0334*  
0B1A0A             0335*  ; scratch variables
0B1A0A 00 00 00    0336*  bufferId0: dl 0x000000
0B1A0D 00 00 00    0337*  bufferId1: dl 0x000000
0B1A10             0338*  
0B1A10             0339*  ; load a vdu buffer from local memory
0B1A10             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1A10             0341*  vdu_load_buffer:
0B1A10 ED 43 39 1A 0342*      ld (@length),bc
       0B          
0B1A15 D5          0343*      push de ; save data pointer
0B1A16             0344*  ; send the vdu command string
0B1A16 7D          0345*      ld a,l
0B1A17 32 36 1A 0B 0346*      ld (@bufferId),a
0B1A1B 7C          0347*      ld a,h
0B1A1C 32 37 1A 0B 0348*      ld (@bufferId+1),a
0B1A20 21 33 1A 0B 0349*      ld hl,@cmd
0B1A24 01 08 00 00 0350*      ld bc,@end-@cmd
0B1A28 5B DF       0351*      rst.lil $18
0B1A2A             0352*  ; send the buffer data
0B1A2A E1          0353*      pop hl ; pointer to data
0B1A2B ED 4B 39 1A 0354*      ld bc,(@length)
       0B          
0B1A30 5B DF       0355*      rst.lil $18 ; send it
0B1A32 C9          0356*      ret
0B1A33             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B1A33 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B1A36 00 00       0359*  @bufferId:	dw 0x0000
0B1A38 00          0360*  		    db 0 ; load buffer
0B1A39 00 00       0361*  @length:	dw 0x0000
0B1A3B 00          0362*  @end: db 0 ; padding
0B1A3C             0363*  
0B1A3C             0364*  ; clear a buffer
0B1A3C             0365*  ; inputs: hl = bufferId
0B1A3C             0366*  vdu_clear_buffer:
0B1A3C 7D          0367*      ld a,l
0B1A3D 32 54 1A 0B 0368*      ld (@bufferId),a
0B1A41 7C          0369*      ld a,h
0B1A42 32 55 1A 0B 0370*      ld (@bufferId+1),a
0B1A46 21 51 1A 0B 0371*      ld hl,@cmd
0B1A4A 01 06 00 00 0372*      ld bc,@end-@cmd
0B1A4E 5B DF       0373*      rst.lil $18
0B1A50 C9          0374*      ret
0B1A51 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B1A54 00 00       0376*  @bufferId:	dw 0x0000
0B1A56 02          0377*  		    db 2 ; clear buffer
0B1A57             0378*  @end:
0B1A57             0379*  
0B1A57             0380*  vdu_clear_all_buffers:
0B1A57             0381*  ; clear all buffers
0B1A57 21 62 1A 0B 0382*      ld hl,@beg
0B1A5B 01 06 00 00 0383*      ld bc,@end-@beg
0B1A5F 5B DF       0384*      rst.lil $18
0B1A61 C9          0385*      ret
0B1A62 17 00 A0    0386*  @beg: db 23,0,$A0
0B1A65 FF FF       0387*        dw -1 ; clear all buffers
0B1A67 02          0388*        db 2  ; command 2: clear a buffer
0B1A68             0389*  @end:
0B1A68             0390*  
0B1A68             0391*  ; Command 14: Consolidate blocks in a buffer
0B1A68             0392*  vdu_consolidate_buffer:
0B1A68             0393*  ; set parameters for vdu call
0B1A68 7D          0394*      ld a,l
0B1A69 32 80 1A 0B 0395*      ld (@bufferId),a
0B1A6D 7C          0396*      ld a,h
0B1A6E 32 81 1A 0B 0397*      ld (@bufferId+1),a
0B1A72 21 7D 1A 0B 0398*      ld hl,@beg
0B1A76 01 06 00 00 0399*      ld bc,@end-@beg
0B1A7A 5B DF       0400*      rst.lil $18
0B1A7C C9          0401*      ret
0B1A7D             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B1A7D 17 00 A0    0403*  @beg: db 23,0,0xA0
0B1A80 00 00       0404*  @bufferId: dw 0x0000
0B1A82 0E          0405*             db 14
0B1A83             0406*  @end:
0B1A83             0407*  
0B1A83             0408*  ; load an image file to a buffer and make it a bitmap
0B1A83             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B1A83             0410*  vdu_load_img:
0B1A83             0411*  ; back up image type and dimension parameters
0B1A83 22 0A 1A 0B 0412*      ld (bufferId0),hl
0B1A87 F5          0413*      push af
0B1A88 C5          0414*  	push bc
0B1A89 D5          0415*  	push de
0B1A8A             0416*  ; load the image
0B1A8A CD A5 1A 0B 0417*  	call vdu_load_buffer_from_file
0B1A8E             0418*  ; now make it a bitmap
0B1A8E 2A 0A 1A 0B 0419*      ld hl,(bufferId0)
0B1A92 CD 68 1A 0B 0420*      call vdu_consolidate_buffer
0B1A96 2A 0A 1A 0B 0421*      ld hl,(bufferId0)
0B1A9A CD 65 19 0B 0422*      call vdu_buff_select
0B1A9E D1          0423*  	pop de ; image height
0B1A9F C1          0424*  	pop bc ; image width
0B1AA0 F1          0425*  	pop af ; image type
0B1AA1 C3 7A 19 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B1AA5             0427*  
0B1AA5             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B1AA5             0429*  vdu_load_buffer_from_file:
0B1AA5 22 0A 1A 0B 0430*      ld (bufferId0),hl
0B1AA9             0431*  
0B1AA9             0432*  ; clear target buffer
0B1AA9 CD 3C 1A 0B 0433*      call vdu_clear_buffer
0B1AAD             0434*  
0B1AAD             0435*  ; open the file in read mode
0B1AAD             0436*  ; Open a file
0B1AAD             0437*  ; HLU: Filename
0B1AAD             0438*  ;   C: Mode
0B1AAD             0439*  ; Returns:
0B1AAD             0440*  ;   A: Filehandle, or 0 if couldn't open
0B1AAD FD E5       0441*  	push iy ; pointer to filename
0B1AAF E1          0442*  	pop hl
0B1AB0 0E 01       0443*  	ld c,fa_read
0B1AB2             0444*      MOSCALL mos_fopen
0B1AB2 3E 0A       0001*M 			LD	A, function
0B1AB4 5B CF       0002*M 			RST.L	08h
0B1AB6 32 F1 1A 0B 0445*      ld (@filehandle),a
0B1ABA             0446*  
0B1ABA             0447*  @read_file:
0B1ABA             0448*  ; Read a block of data from a file
0B1ABA             0449*  ;   C: Filehandle
0B1ABA             0450*  ; HLU: Pointer to where to write the data to
0B1ABA             0451*  ; DEU: Number of bytes to read
0B1ABA             0452*  ; Returns:
0B1ABA             0453*  ; DEU: Number of bytes read
0B1ABA 3A F1 1A 0B 0454*      ld a,(@filehandle)
0B1ABE 4F          0455*      ld c,a
0B1ABF 21 00 E0 B7 0456*      ld hl,filedata
0B1AC3 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B1AC7             0458*      MOSCALL mos_fread
0B1AC7 3E 1A       0001*M 			LD	A, function
0B1AC9 5B CF       0002*M 			RST.L	08h
0B1ACB             0459*  
0B1ACB             0460*  ; ; DEBUG: print chunk size
0B1ACB             0461*  ;     push de
0B1ACB             0462*  ;     pop hl
0B1ACB             0463*  ;     call printDec
0B1ACB             0464*  ;     call printNewLine
0B1ACB             0465*  
0B1ACB             0466*  ; test de for zero bytes read
0B1ACB 21 00 00 00 0467*      ld hl,0
0B1ACF AF          0468*      xor a ; clear carry
0B1AD0 ED 52       0469*      sbc hl,de
0B1AD2 CA E8 1A 0B 0470*      jp z,@close_file
0B1AD6             0471*  
0B1AD6             0472*  ; load a vdu buffer from local memory
0B1AD6             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1AD6 2A 0A 1A 0B 0474*      ld hl,(bufferId0)
0B1ADA D5          0475*      push de ; chunksize
0B1ADB C1          0476*      pop bc
0B1ADC 11 00 E0 B7 0477*      ld de,filedata
0B1AE0 CD 10 1A 0B 0478*      call vdu_load_buffer
0B1AE4             0479*  
0B1AE4             0480*  ; ; print progress breadcrumbs
0B1AE4             0481*  ;     ld a,'.'
0B1AE4             0482*  ;     rst.lil 10h
0B1AE4             0483*  
0B1AE4             0484*  ; read the next block
0B1AE4 C3 BA 1A 0B 0485*      jp @read_file
0B1AE8             0486*  
0B1AE8             0487*  ; close the file
0B1AE8             0488*  @close_file:
0B1AE8 3A F1 1A 0B 0489*      ld a,(@filehandle)
0B1AEC             0490*      MOSCALL mos_fclose
0B1AEC 3E 0B       0001*M 			LD	A, function
0B1AEE 5B CF       0002*M 			RST.L	08h
0B1AF0 C9          0491*      ret ; vdu_load_buffer_from_file
0B1AF1             0492*  
0B1AF1 00          0493*  @filehandle: db 0 ; file handle
0B1AF2 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B1AF5             0495*  
0B1AF5 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B1AF8             0497*  
0B1AF8             0498*  ; File information structure (FILINFO)
0B1AF8             0499*  @filinfo:
0B1AF8 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B1AFC 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B1AFE 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B1B00 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B1B01 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B1B0E 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B1C0E             0026       ; include "vdu_fonts.inc"
0B1C0E             0027       include "vdu_plot.inc"
0B1C0E             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1C0E             0002*  ; PLOT code 	(Decimal) 	Effect
0B1C0E             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B1C0E             0004*  plot_sl_both: equ 0x00
0B1C0E             0005*  
0B1C0E             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B1C0E             0007*  plot_sl_first: equ 0x08
0B1C0E             0008*  
0B1C0E             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B1C0E             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B1C0E             0011*  
0B1C0E             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B1C0E             0013*  plot_sl_last: equ 0x20
0B1C0E             0014*  
0B1C0E             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B1C0E             0016*  plot_sl_none: equ 0x28
0B1C0E             0017*  
0B1C0E             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B1C0E             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B1C0E             0020*  
0B1C0E             0021*  ; &40-&47 	64-71 	Point plot
0B1C0E             0022*  plot_pt: equ 0x40
0B1C0E             0023*  
0B1C0E             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B1C0E             0025*  plot_lf_lr_non_bg: equ 0x48
0B1C0E             0026*  
0B1C0E             0027*  ; &50-&57 	80-87 	Triangle fill
0B1C0E             0028*  plot_tf: equ 0x50
0B1C0E             0029*  
0B1C0E             0030*  ; &58-&5F 	88-95 	Line fill right to background 
0B1C0E             0031*  plot_lf_r_bg: equ 0x58
0B1C0E             0032*  
0B1C0E             0033*  ; &60-&67 	96-103 	Rectangle fill
0B1C0E             0034*  plot_rf: equ 0x60
0B1C0E             0035*  
0B1C0E             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B1C0E             0037*  plot_lf_lr_fg: equ 0x60
0B1C0E             0038*  
0B1C0E             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B1C0E             0040*  plot_pf: equ 0x70
0B1C0E             0041*  
0B1C0E             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B1C0E             0043*  plot_lf_r_non_fg: equ 0x78
0B1C0E             0044*  
0B1C0E             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B1C0E             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B1C0E             0047*  
0B1C0E             0048*  ; &90-&97 	144-151 	Circle outline
0B1C0E             0049*  plot_co: equ 0x90
0B1C0E             0050*  
0B1C0E             0051*  ; &98-&9F 	152-159 	Circle fill
0B1C0E             0052*  plot_cf: equ 0x98
0B1C0E             0053*  
0B1C0E             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B1C0E             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B1C0E             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B1C0E             0057*  
0B1C0E             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B1C0E             0059*  plot_rcm: equ 0xB8
0B1C0E             0060*  
0B1C0E             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B1C0E             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B1C0E             0063*  ; &D0-&D7 	208-215 	Not defined
0B1C0E             0064*  ; &D8-&DF 	216-223 	Not defined
0B1C0E             0065*  ; &E0-&E7 	224-231 	Not defined
0B1C0E             0066*  
0B1C0E             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
0B1C0E             0068*  plot_bmp: equ 0xE8
0B1C0E             0069*  
0B1C0E             0070*  ; &F0-&F7 	240-247 	Not defined
0B1C0E             0071*  ; &F8-&FF 	248-255 	Not defined
0B1C0E             0072*  
0B1C0E             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B1C0E             0074*  ; Agon Console8 VDP 2.2.0
0B1C0E             0075*  
0B1C0E             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B1C0E             0077*  ; Plot code 	Effect
0B1C0E             0078*  ; 0 	Move relative
0B1C0E             0079*  mv_rel: equ 0
0B1C0E             0080*  
0B1C0E             0081*  ; 1 	Plot relative in current foreground colour
0B1C0E             0082*  dr_rel_fg: equ 1
0B1C0E             0083*  
0B1C0E             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B1C0E             0085*  ; 3 	Plot relative in current background colour
0B1C0E             0086*  dr_rel_bg: equ 3
0B1C0E             0087*  
0B1C0E             0088*  ; 4 	Move absolute
0B1C0E             0089*  mv_abs: equ 4
0B1C0E             0090*  
0B1C0E             0091*  ; 5 	Plot absolute in current foreground colour
0B1C0E             0092*  dr_abs_fg: equ 5
0B1C0E             0093*  
0B1C0E             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B1C0E             0095*  ; 7 	Plot absolute in current background colour
0B1C0E             0096*  dr_abs_bg: equ 7
0B1C0E             0097*  
0B1C0E             0098*  ; Codes 0-3 use the position data provided as part of the command
0B1C0E             0099*  ; as a relative position, adding the position given to the current
0B1C0E             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B1C0E             0101*  ; as part of the command as an absolute position, setting the current
0B1C0E             0102*  ; graphical cursor position to the position given.
0B1C0E             0103*  
0B1C0E             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B1C0E             0105*  ; current pixel colour. These operations cannot currently be supported
0B1C0E             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B1C0E             0107*  ; supported. Support for these codes may be added in a future version
0B1C0E             0108*  ; of the VDP firmware.
0B1C0E             0109*  
0B1C0E             0110*  ; 16 colour palette constants
0B1C0E             0111*  c_black: equ 0
0B1C0E             0112*  c_red_dk: equ 1
0B1C0E             0113*  c_green_dk: equ 2
0B1C0E             0114*  c_yellow_dk: equ 3
0B1C0E             0115*  c_blue_dk: equ 4
0B1C0E             0116*  c_magenta_dk: equ 5
0B1C0E             0117*  c_cyan_dk: equ 6
0B1C0E             0118*  c_grey: equ 7
0B1C0E             0119*  c_grey_dk: equ 8
0B1C0E             0120*  c_red: equ 9
0B1C0E             0121*  c_green: equ 10
0B1C0E             0122*  c_yellow: equ 11
0B1C0E             0123*  c_blue: equ 12
0B1C0E             0124*  c_magenta: equ 13
0B1C0E             0125*  c_cyan: equ 14
0B1C0E             0126*  c_white: equ 15
0B1C0E             0127*  
0B1C0E             0128*  ; VDU 25, mode, x; y;: PLOT command
0B1C0E             0129*  ; inputs: a=mode, bc=x0, de=y0
0B1C0E             0130*  vdu_plot:
0B1C0E 32 28 1C 0B 0131*      ld (@mode),a
0B1C12 ED 43 29 1C 0132*      ld (@x0),bc
       0B          
0B1C17 ED 53 2B 1C 0133*      ld (@y0),de
       0B          
0B1C1C 21 27 1C 0B 0134*  	ld hl,@cmd
0B1C20 01 06 00 00 0135*  	ld bc,@end-@cmd
0B1C24 5B DF       0136*  	rst.lil $18
0B1C26 C9          0137*  	ret
0B1C27 19          0138*  @cmd:   db 25
0B1C28 00          0139*  @mode:  db 0
0B1C29 00 00       0140*  @x0: 	dw 0
0B1C2B 00 00       0141*  @y0: 	dw 0
0B1C2D 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B1C2E             0143*  
0B1C2E             0144*  ; VDU 25, mode, x; y;: PLOT command
0B1C2E             0145*  ; USING 16.8 FIXED POINT COORDINATES
0B1C2E             0146*  ; inputs: a=mode, ub.c=x0, ud.e=y0
0B1C2E             0147*  vdu_plot_168:
0B1C2E ED 43 48 1C 0148*      ld (@x0-1),bc ; integer portion only
       0B          
0B1C33 ED 53 4A 1C 0149*      ld (@y0-1),de ; ibid
       0B          
0B1C38 32 48 1C 0B 0150*      ld (@mode),a  ; load this order b/c we shifted bc right
0B1C3C 21 47 1C 0B 0151*  	ld hl,@cmd
0B1C40 01 06 00 00 0152*  	ld bc,@end-@cmd
0B1C44 5B DF       0153*  	rst.lil $18
0B1C46 C9          0154*  	ret
0B1C47 19          0155*  @cmd:   db 25
0B1C48 00          0156*  @mode:  db 0
0B1C49 00 00       0157*  @x0: 	dw 0
0B1C4B 00 00       0158*  @y0: 	dw 0
0B1C4D             0159*  @end:  ; no padding required b/c we shifted de right
0B1C4D             0160*  
0B1C4D             0161*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1C4D             0162*  ; &E8-&EF 	232-239 	Bitmap plot 
0B1C4D             0163*  ; VDU 25, mode, x; y;: PLOT command
0B1C4D             0164*  ; inputs: bc=x0, de=y0
0B1C4D             0165*  ; prerequisites: vdu_buff_select
0B1C4D             0166*  vdu_plot_bmp:
0B1C4D ED 43 64 1C 0167*      ld (@x0),bc
       0B          
0B1C52 ED 53 66 1C 0168*      ld (@y0),de
       0B          
0B1C57 21 62 1C 0B 0169*  	ld hl,@cmd
0B1C5B 01 06 00 00 0170*  	ld bc,@end-@cmd
0B1C5F 5B DF       0171*  	rst.lil $18
0B1C61 C9          0172*  	ret
0B1C62 19          0173*  @cmd:   db 25
0B1C63 ED          0174*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1C64 00 00       0175*  @x0: 	dw 0x0000
0B1C66 00 00       0176*  @y0: 	dw 0x0000
0B1C68 00          0177*  @end:   db 0x00 ; padding
0B1C69             0178*  
0B1C69             0179*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1C69             0180*  ; &E8-&EF 	232-239 	Bitmap plot 
0B1C69             0181*  ; VDU 25, mode, x; y;: PLOT command
0B1C69             0182*  ; inputs: bc=x0, de=y0
0B1C69             0183*  ; USING 16.8 FIXED POINT COORDINATES
0B1C69             0184*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B1C69             0185*  ;   the fractional portiion of the inputs are truncated
0B1C69             0186*  ;   leaving only the 16-bit integer portion
0B1C69             0187*  ; prerequisites: vdu_buff_select
0B1C69             0188*  vdu_plot_bmp168:
0B1C69             0189*  ; populate in the reverse of normal to keep the
0B1C69             0190*  ; inputs from stomping on each other
0B1C69 ED 53 87 1C 0191*      ld (@y0-1),de
       0B          
0B1C6E ED 43 85 1C 0192*      ld (@x0-1),bc
       0B          
0B1C73 3E ED       0193*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B1C75 32 85 1C 0B 0194*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B1C79 21 84 1C 0B 0195*  	ld hl,@cmd
0B1C7D 01 06 00 00 0196*  	ld bc,@end-@cmd
0B1C81 5B DF       0197*  	rst.lil $18
0B1C83 C9          0198*  	ret
0B1C84 19          0199*  @cmd:   db 25
0B1C85 ED          0200*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1C86 00 00       0201*  @x0: 	dw 0x0000
0B1C88 00 00       0202*  @y0: 	dw 0x0000
0B1C8A             0203*  @end:  ; no padding required b/c we shifted de right
0B1C8A             0204*  
0B1C8A             0205*  ; draw a filled rectangle
0B1C8A             0206*  vdu_plot_rf:
0B1C8A ED 43 B1 1C 0207*      ld (@x0),bc
       0B          
0B1C8F ED 53 B3 1C 0208*      ld (@y0),de
       0B          
0B1C94 DD 22 B7 1C 0209*      ld (@x1),ix
       0B          
0B1C99 FD 22 B9 1C 0210*      ld (@y1),iy
       0B          
0B1C9E 3E 19       0211*      ld a,25 ; we have to reload the 2nd plot command
0B1CA0 32 B5 1C 0B 0212*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1CA4 21 AF 1C 0B 0213*  	ld hl,@cmd0
0B1CA8 01 0C 00 00 0214*  	ld bc,@end-@cmd0
0B1CAC 5B DF       0215*  	rst.lil $18
0B1CAE C9          0216*      ret
0B1CAF 19          0217*  @cmd0:  db 25 ; plot
0B1CB0 04          0218*  @arg0:  db plot_sl_both+mv_abs
0B1CB1 00 00       0219*  @x0:    dw 0x0000
0B1CB3 00 00       0220*  @y0:    dw 0x0000
0B1CB5 19          0221*  @cmd1:  db 25 ; plot
0B1CB6 65          0222*  @arg1:  db plot_rf+dr_abs_fg
0B1CB7 00 00       0223*  @x1:    dw 0x0000
0B1CB9 00 00       0224*  @y1:    dw 0x0000
0B1CBB 00          0225*  @end:   db 0x00 ; padding
0B1CBC             0226*  
0B1CBC             0227*  ; draw a filled circle
0B1CBC             0228*  vdu_plot_cf:
0B1CBC ED 43 E3 1C 0229*      ld (@x0),bc
       0B          
0B1CC1 ED 53 E5 1C 0230*      ld (@y0),de
       0B          
0B1CC6 DD 22 E9 1C 0231*      ld (@x1),ix
       0B          
0B1CCB FD 22 EB 1C 0232*      ld (@y1),iy
       0B          
0B1CD0 3E 19       0233*      ld a,25 ; we have to reload the 2nd plot command
0B1CD2 32 E7 1C 0B 0234*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1CD6 21 E1 1C 0B 0235*  	ld hl,@cmd0
0B1CDA 01 0C 00 00 0236*  	ld bc,@end-@cmd0
0B1CDE 5B DF       0237*  	rst.lil $18
0B1CE0 C9          0238*      ret
0B1CE1 19          0239*  @cmd0:  db 25 ; plot
0B1CE2 04          0240*  @arg0:  db plot_sl_both+mv_abs
0B1CE3 00 00       0241*  @x0:    dw 0x0000
0B1CE5 00 00       0242*  @y0:    dw 0x0000
0B1CE7 19          0243*  @cmd1:  db 25 ; plot
0B1CE8 9D          0244*  @arg1:  db plot_cf+dr_abs_fg
0B1CE9 00 00       0245*  @x1:    dw 0x0000
0B1CEB 00 00       0246*  @y1:    dw 0x0000
0B1CED 00          0247*  @end:   db 0x00 ; padding
0B1CEE             0248*  
0B1CEE             0249*  ; VDU 25, mode, x; y;: PLOT command
0B1CEE             0250*  ; inputs: a=mode, ix=x0, iy=y0
0B1CEE             0251*  plot:
0B1CEE 32 08 1D 0B 0252*      ld (@mode),a
0B1CF2 DD 22 09 1D 0253*      ld (@x0),ix
       0B          
0B1CF7 FD 22 0B 1D 0254*      ld (@y0),iy
       0B          
0B1CFC 21 07 1D 0B 0255*  	ld hl,@cmd
0B1D00 01 06 00 00 0256*  	ld bc,@end-@cmd
0B1D04 5B DF       0257*  	rst.lil $18
0B1D06 C9          0258*  	ret
0B1D07 19          0259*  @cmd:   db 25
0B1D08 00          0260*  @mode:  db 0
0B1D09 00 00       0261*  @x0: 	dw 0
0B1D0B 00 00       0262*  @y0: 	dw 0
0B1D0D 00          0263*  @end:   db 0 ; padding
0B1D0E             0264*  
0B1D0E             0265*  ; VDU 5: Write text at graphics cursor
0B1D0E             0266*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B1D0E             0267*  ; prerequisites: gcol foreground set, VDU 5 set
0B1D0E             0268*  plot_text:
0B1D0E E5          0269*      push hl ; save text pointer
0B1D0F             0270*  ; move graphics cursor to x0, y0
0B1D0F 3E 44       0271*      ld a,plot_pt+mv_abs
0B1D11 CD EE 1C 0B 0272*      call plot
0B1D15             0273*  ; write text
0B1D15 E1          0274*      pop hl ; restore text pointer
0B1D16 CD 73 02 0B 0275*      call printString
0B1D1A C9          0276*      ret
0B1D1B             0028   
0B1D1B             0029   ; SHAWN'S INCLUDES
0B1D1B             0030   	INCLUDE	"strings24.asm"
0B1D1B             0001*  ;------------------------------------------------------------------------
0B1D1B             0002*  ;  strings24.asm
0B1D1B             0003*  ;
0B1D1B             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B1D1B             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B1D1B             0006*  ;  MIT license
0B1D1B             0007*  ;------------------------------------------------------------------------
0B1D1B             0008*  
0B1D1B             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B1D1B             0010*  ; and postpended with a minus sign if was negative
0B1D1B             0011*  ; Uses HLU, DEU, BCU
0B1D1B             0012*  print_HLU_s24:
0B1D1B CD 33 08 0B 0013*  	call hlu_abs
0B1D1F F5          0014*  	push af ; save the sign and zero flags
0B1D20 CD 2B 1D 0B 0015*  	call print_HLU_u24
0B1D24 F1          0016*  	pop af
0B1D25 F0          0017*  	ret p ; HLU was positive so nothig more to do
0B1D26 3E 2D       0018*  	ld a,'-'
0B1D28 5B D7       0019*  	rst.lil 10h
0B1D2A C9          0020*  	ret
0B1D2B             0021*  
0B1D2B             0022*  ;------------------------------------------------------------------------
0B1D2B             0023*  ;Full print and buffer routine so you can adjust behaviour
0B1D2B             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B1D2B             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B1D2B             0026*  ;Print value in HLU in decimal with leading 0s removed
0B1D2B             0027*  ; Uses HLU, DEU, BCU
0B1D2B             0028*  ;------------------------------------------------------------------------
0B1D2B             0029*  
0B1D2B             0030*  print_HLU_u24:
0B1D2B 22 08 1E 0B 0031*  	ld	(hex_temp),hl
0B1D2F 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B1D31 11 0B 1E 0B 0033*  	ld	de,outbuf
0B1D35 D5          0034*  	push	de
0B1D36 21 07 00 00 0035*  	ld	hl,7
0B1D3A 19          0036*  	add	hl,de
0B1D3B E5          0037*  	push	hl
0B1D3C D1          0038*  	pop	de	;copy HLU to DEU
0B1D3D AF          0039*  	xor	a
0B1D3E             0040*  _pde_u_zerobuf:
0B1D3E 77          0041*  	ld	(hl),a	;zero out the output
0B1D3F 2B          0042*  	dec	hl
0B1D40 10 FC       0043*  	djnz	_pde_u_zerobuf
0B1D42             0044*  
0B1D42 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B1D44             0046*  _bcd_Convert:
0B1D44             0047*  
0B1D44 21 08 1E 0B 0048*  	ld hl,hex_temp
0B1D48             0049*  ;
0B1D48 CB 26       0050*  	sla (hl)
0B1D4A 23          0051*  	inc hl
0B1D4B CB 16       0052*  	rl (hl)
0B1D4D 23          0053*  	inc hl
0B1D4E CB 16       0054*  	rl (hl)		;24 bits rolled right
0B1D50             0055*  
0B1D50             0056*  
0B1D50 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B1D52 D5          0058*  	push	de
0B1D53 E1          0059*  	pop	hl
0B1D54             0060*  
0B1D54             0061*  _bcd_Add3:
0B1D54 7E          0062*  	ld	a,(hl)
0B1D55 8F          0063*  	adc	a
0B1D56 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B1D57 FE 10       0065*  	cp	10h	;did we roll over nibble?
0B1D59 3F          0066*  	ccf
0B1D5A CB A7       0067*  	res	4,a
0B1D5C             0068*  
0B1D5C 77          0069*          ld (hl),a
0B1D5D 2B          0070*  	dec	hl
0B1D5E 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B1D60 0D          0072*          dec c
0B1D61 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B1D63             0074*  
0B1D63             0075*  
0B1D63 E1          0076*  	pop	hl
0B1D64 E5          0077*  	push	hl
0B1D65 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B1D67             0079*  _pde_u_make_ascii:
0B1D67 7E          0080*  	ld	a,(hl)
0B1D68 B7          0081*  	or	a
0B1D69 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B1D6B 36 20       0083*  	ld	(hl),' '
0B1D6D 23          0084*  	inc	hl
0B1D6E 10 F7       0085*  	djnz	_pde_u_make_ascii
0B1D70             0086*  _pde_u_make_ascii2:
0B1D70 04          0087*  	inc	b
0B1D71             0088*  _pde_u_make_ascii3:
0B1D71 7E          0089*  	ld	a,(hl)
0B1D72 F6 30       0090*  	or	30h
0B1D74 77          0091*  	ld	(hl),a
0B1D75 23          0092*  	inc	hl
0B1D76 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B1D78             0094*  
0B1D78 E1          0095*  	pop	hl
0B1D79 06 08       0096*  	ld	b,8
0B1D7B             0097*  _pde_u_final_out:
0B1D7B 7E          0098*  	ld	a,(hl)
0B1D7C 23          0099*  	inc	hl
0B1D7D FE 20       0100*  	cp	' '
0B1D7F 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B1D81 5B D7       0102*  	rst.lil	10h
0B1D83             0103*  _pde_u_final_out_strip:
0B1D83 10 F6       0104*  	djnz	_pde_u_final_out
0B1D85 C9          0105*  	ret
0B1D86             0106*  
0B1D86             0107*  ;------------------------------------------------------------------------
0B1D86             0108*  ; is_digit
0B1D86             0109*  ; C flag set if A is a digit
0B1D86             0110*  ; preserves all registers
0B1D86             0111*  ;------------------------------------------------------------------------
0B1D86             0112*  is_digit:
0B1D86 FE 30       0113*  	cp	'0'
0B1D88 3F          0114*  	ccf
0B1D89 D0          0115*  	ret	nc	;less that '0'
0B1D8A FE 3A       0116*  	cp	'9' + 1
0B1D8C C9          0117*  	ret
0B1D8D             0118*  
0B1D8D             0119*  
0B1D8D             0120*  ;------------------------------------------------------------------------
0B1D8D             0121*  ; char2hex
0B1D8D             0122*  ; Input: ASCII nibble in A
0B1D8D             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B1D8D             0124*  ;------------------------------------------------------------------------
0B1D8D             0125*  char2hex:
0B1D8D FE 30       0126*  	CP	'0'
0B1D8F 38 1D       0127*  	JR	C, char_not_hex
0B1D91 FE 3A       0128*  	CP	'9' + 1
0B1D93 30 03       0129*  	JR	NC, char_not_09
0B1D95 D6 30       0130*  	sub	'0'
0B1D97 C9          0131*  	ret
0B1D98             0132*  
0B1D98             0133*  char_not_09:
0B1D98             0134*  	; char is not 0 to 9. Try upper case
0B1D98 FE 41       0135*  	CP	'A'
0B1D9A 38 12       0136*  	JR	C, char_not_hex
0B1D9C FE 47       0137*  	CP	'F' + 1
0B1D9E 30 03       0138*  	JR	NC, char_not_AF
0B1DA0 D6 37       0139*  	sub	'A'-10
0B1DA2 C9          0140*  	ret
0B1DA3             0141*  
0B1DA3             0142*  char_not_AF:
0B1DA3             0143*  	; char is not upper case A-F. Try lower
0B1DA3 FE 61       0144*  	CP	'a'
0B1DA5 38 07       0145*  	JR	C, char_not_hex
0B1DA7 FE 67       0146*  	CP	'f' + 1
0B1DA9 30 03       0147*  	JR	NC, char_not_hex
0B1DAB D6 57       0148*  	sub	'a' - 10
0B1DAD C9          0149*  	RET
0B1DAE             0150*  
0B1DAE             0151*  char_not_hex:
0B1DAE 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B1DB0 C9          0153*  	RET
0B1DB1             0154*  
0B1DB1             0155*  ;------------------------------------------------------------------------
0B1DB1             0156*  ;  newline
0B1DB1             0157*  ;  Output CR+LF; all registers preserved
0B1DB1             0158*  ;------------------------------------------------------------------------
0B1DB1             0159*  newline:
0B1DB1 F5          0160*         push   AF
0B1DB2 3E 0D       0161*         LD     A, 13
0B1DB4 5B D7       0162*         RST.LIL    10h
0B1DB6 3E 0A       0163*         LD     A, 10
0B1DB8 5B D7       0164*         RST.LIL    10h
0B1DBA F1          0165*         POP    AF
0B1DBB C9          0166*         RET
0B1DBC             0167*  
0B1DBC             0168*  ;------------------------------------------------------------------------
0B1DBC             0169*  ;  put_nibble
0B1DBC             0170*  ;  Output a single hex nibble in A
0B1DBC             0171*  ;  All registers preserved
0B1DBC             0172*  ;------------------------------------------------------------------------
0B1DBC             0173*  put_nibble:
0B1DBC F5          0174*  	push   AF
0B1DBD C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B1DBF 27          0176*  	daa
0B1DC0 CE 40       0177*  	adc    a,040h
0B1DC2 27          0178*  	daa
0B1DC3 5B D7       0179*  	RST.LIL    10h	;output character in A
0B1DC5 F1          0180*  	pop    AF
0B1DC6 C9          0181*  	ret
0B1DC7             0182*  
0B1DC7             0183*  ;------------------------------------------------------------------------
0B1DC7             0184*  ;  print_A
0B1DC7             0185*  ;  Output the 8-bit hex number A
0B1DC7             0186*  ;  All registers preserved
0B1DC7             0187*  ;------------------------------------------------------------------------
0B1DC7             0188*  print_A:
0B1DC7 F5          0189*  	push 	AF
0B1DC8 F5          0190*  	push 	AF	;save for second nibble
0B1DC9 0F          0191*  	rrca
0B1DCA 0F          0192*  	rrca
0B1DCB 0F          0193*  	rrca
0B1DCC 0F          0194*  	rrca
0B1DCD E6 0F       0195*  	and	0Fh	;first nibble
0B1DCF CD BC 1D 0B 0196*  	call	put_nibble
0B1DD3 F1          0197*  	pop 	AF
0B1DD4 E6 0F       0198*  	and	0Fh	;second nibble
0B1DD6 CD BC 1D 0B 0199*  	call	put_nibble
0B1DDA F1          0200*  	pop 	AF
0B1DDB C9          0201*  	ret
0B1DDC             0202*  
0B1DDC             0203*  ;------------------------------------------------------------------------
0B1DDC             0204*  ;  print_HLU_hex
0B1DDC             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B1DDC             0206*  ;------------------------------------------------------------------------
0B1DDC             0207*  print_HLU_hex:
0B1DDC F5          0208*         push   AF
0B1DDD 22 08 1E 0B 0209*         ld     (hex_temp),hl
0B1DE1 3A 0A 1E 0B 0210*         ld     a,(hex_temp+2)
0B1DE5 CD C7 1D 0B 0211*         call   print_A
0B1DE9 3A 09 1E 0B 0212*         ld     a,(hex_temp+1)
0B1DED CD C7 1D 0B 0213*         call   print_A
0B1DF1 3A 08 1E 0B 0214*         ld     a,(hex_temp)
0B1DF5 CD C7 1D 0B 0215*         call   print_A
0B1DF9 F1          0216*         POP    AF
0B1DFA C9          0217*         RET
0B1DFB             0218*  
0B1DFB             0219*  ;------------------------------------------------------------------------
0B1DFB             0220*  ;  puts
0B1DFB             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B1DFB             0222*  ;  registers preserved.
0B1DFB             0223*  ;------------------------------------------------------------------------
0B1DFB             0224*  puts:
0B1DFB F5          0225*         push   AF
0B1DFC C5          0226*         push   BC
0B1DFD 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B1E01 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B1E03 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B1E05 C1          0230*         pop    BC
0B1E06 F1          0231*         pop    AF
0B1E07 C9          0232*         ret
0B1E08             0233*  
0B1E08             0234*  ;------------------------------------------------------------------------
0B1E08             0235*  ; Data area
0B1E08             0236*  ; Storage for 24 bit conversion
0B1E08             0237*  ;------------------------------------------------------------------------
0B1E08             0238*  hex_temp:
0B1E08 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B1E0B             0240*  
0B1E0B             0241*  outbuf:
0B1E0B 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B1E14             0031   
0B1E14             0032   ; APPLICATION INCLUDES
0B1E14 55 73 61 67 0033   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B1E2C 45 72 72 6F 0034   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B1E35 53 75 63 63 0035   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1E40             0036   
0B1E40             0037   ; This is a scratch moslet for testing new features
0B1E40             0038   ; Parameters:
0B1E40             0039   ;
0B1E40             0040   
0B1E40             0041   ; ========= BOILERPLATE MAIN LOOP =========
0B1E40             0042   ; The main routine
0B1E40             0043   ; IXU: argv - pointer to array of parameters
0B1E40             0044   ;   C: argc - number of parameters
0B1E40             0045   ; Returns:
0B1E40             0046   ;  HL: Error code, or 0 if OK
0B1E40             0047   
0B1E40             0048   min_args: equ 3
0B1E40             0049   
0B1E40             0050   _main:
0B1E40 79          0051       ld a,c              ; how many arguments?
0B1E41 FE 03       0052       cp min_args         ; not enough?
0B1E43 30 1A       0053       jr nc,main          ; if enough, go to main loop
0B1E45 21 14 1E 0B 0054       ld hl,str_usage     ; if not enough, print usage
0B1E49 CD 73 02 0B 0055       call printString
0B1E4D             0056                           ; fall through to _main_end_error
0B1E4D             0057   
0B1E4D             0058   _main_end_error:
0B1E4D 21 2C 1E 0B 0059       ld hl,str_error     ; print error message
0B1E51 CD 73 02 0B 0060       call printString
0B1E55 21 13 00 00 0061       ld hl,19            ; return error code 19
0B1E59 C9          0062       ret
0B1E5A             0063   
0B1E5A             0064   _main_end_ok:
0B1E5A             0065       ; ld hl,str_success   ; print success message
0B1E5A             0066       ; call printString
0B1E5A 21 00 00 00 0067       ld hl,0             ; return 0 for success
0B1E5E C9          0068       ret
0B1E5F             0069   
0B1E5F             0070   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B1E5F             0071   main:
0B1E5F 0D          0072       dec c               ; decrement the argument count to skip the program name
0B1E60             0073   
0B1E60             0074   test_sdiv168:
0B1E60             0075   ; get first numeric argument
0B1E60 CD E2 1F 0B 0076       call get_arg_s168 ; de = first numeric argument
0B1E64 D5          0077       push de
0B1E65 EB          0078       ex de,hl
0B1E66 CD 78 06 0B 0079       call print_hex_hl
0B1E6A EB          0080       ex de,hl
0B1E6B CD 67 04 0B 0081       call print_s168_de
0B1E6F             0082   
0B1E6F             0083   ; match on single number functions
0B1E6F FD 21 6F 1F 0084       ld iy,function
       0B          
0B1E74 CD 3E 20 0B 0085       call match_next_and_print ; iy = function pointer, zero flag set if match
0B1E78 F5          0086       push af ; save zero flag
0B1E79 FD E5       0087       push iy ; save the function pointer
0B1E7B CA 9D 1E 0B 0088       jp z,@execute
0B1E7F             0089   
0B1E7F             0090   ; match on two-number operators
0B1E7F FD E1       0091       pop iy ; dummy pops
0B1E81 F1          0092       pop af ; to balance stack
0B1E82 ED 32 FD    0093       lea ix,ix-3
0B1E85 FD 21 BC 1E 0094       ld iy,operator
       0B          
0B1E8A CD 3E 20 0B 0095       call match_next_and_print ; iy = operator pointer, zero flag set if match
0B1E8E F5          0096       push af ; save zero flag
0B1E8F FD E5       0097       push iy ; save the operator pointer
0B1E91             0098   
0B1E91             0099   ; get second numeric argument if needed
0B1E91 CD E2 1F 0B 0100       call get_arg_s168 ; de = second argument
0B1E95 CD A8 06 0B 0101       call print_hex_de
0B1E99 CD 67 04 0B 0102       call print_s168_de
0B1E9D             0103   
0B1E9D             0104   @execute:
0B1E9D CD 88 02 0B 0105       call printNewLine
0B1EA1             0106   
0B1EA1 FD E1       0107       pop iy ; restore the function/operator pointer
0B1EA3 F1          0108       pop af ; restore zero flag
0B1EA4 E1          0109       pop hl ; restore first argument
0B1EA5             0110   
0B1EA5 C2 4D 1E 0B 0111       jp nz,_main_end_error
0B1EA9             0112   
0B1EA9             0113       callIY ; call the function
0B1EA9 01 B0 1E 0B 0001M          ld bc,$+7     ; Address of first instruction after the jump
0B1EAD C5          0002M          push bc       ; which constitutes the return address
0B1EAE FD E9       0003M          jp   (iy)     ; Jump to the address in IY
0B1EB0 CD 88 02 0B 0114       call printNewLine
0B1EB4 CD 88 02 0B 0115       call printNewLine
0B1EB8 C3 5A 1E 0B 0116       jp _main_end_ok
0B1EBC             0117   
0B1EBC             0118   ; ========== DISPATCH TABLES ==========
0B1EBC             0119   operator:
0B1EBC D7 1E 0B    0120       dl addition
0B1EBF E5 1E 0B    0121       dl subtract
0B1EC2 F5 1E 0B    0122       dl multiply
0B1EC5 06 1F 0B    0123       dl divide
0B1EC8 1F 1F 0B    0124       dl tan
0B1ECB 26 1F 0B    0125       dl atan2
0B1ECE 2F 1F 0B    0126       dl polar2cart
0B1ED1 61 1F 0B    0127       dl cart2polar
0B1ED4 00 00 00    0128       dl 0x000000 ; list terminator
0B1ED7             0129   addition:
0B1ED7 18 02       0130       jr @start
0B1ED9 2B 00       0131       asciz "+"
0B1EDB             0132   @start:
0B1EDB 19          0133       add hl,de
0B1EDC CD 78 06 0B 0134       call print_hex_hl
0B1EE0 CD 49 04 0B 0135       call print_s168_hl
0B1EE4 C9          0136       ret
0B1EE5             0137   subtract:
0B1EE5 18 02       0138       jr @start
0B1EE7 2D 00       0139       asciz "-"
0B1EE9             0140   @start:
0B1EE9 AF          0141       xor a ; clear carry
0B1EEA ED 52       0142       sbc hl,de
0B1EEC CD 78 06 0B 0143       call print_hex_hl
0B1EF0 CD 49 04 0B 0144       call print_s168_hl
0B1EF4 C9          0145       ret
0B1EF5             0146   multiply:
0B1EF5 18 02       0147       jr @start
0B1EF7 2A 00       0148       asciz "*"
0B1EF9             0149   @start:
0B1EF9 CD DE 09 0B 0150       call smul168
0B1EFD CD 78 06 0B 0151       call print_hex_hl
0B1F01 CD 49 04 0B 0152       call print_s168_hl
0B1F05 C9          0153       ret
0B1F06             0154   divide:
0B1F06 18 02       0155       jr @start
0B1F08 2F 00       0156       asciz "/"
0B1F0A             0157   @start:
0B1F0A CD 7F 0A 0B 0158       call sdiv168
0B1F0E CD A8 06 0B 0159       call print_hex_de
0B1F12 CD 67 04 0B 0160       call print_s168_de
0B1F16 CD 78 06 0B 0161       call print_hex_hl ; remainder
0B1F1A CD 49 04 0B 0162       call print_s168_hl ; remainder
0B1F1E C9          0163       ret
0B1F1F             0164   tan:
0B1F1F 18 04       0165       jr @start
0B1F21 74 61 6E 00 0166       asciz "tan"
0B1F25             0167   @start:
0B1F25             0168       ; call tan168
0B1F25 C9          0169       ret
0B1F26             0170   atan2:
0B1F26 18 06       0171       jr @start
0B1F28 61 74 61 6E 0172       asciz "atan2"
       32 00       
0B1F2E             0173   @start:
0B1F2E             0174       ; call atan2_168
0B1F2E C9          0175       ret
0B1F2F             0176   polar2cart:
0B1F2F 18 0B       0177       jr @start
0B1F31 70 6F 6C 61 0178       asciz "polar2cart"
       72 32 63 61 
       72 74 00    
0B1F3C             0179   @start:
0B1F3C CD 2D 0C 0B 0180       call deg_360_to_256
0B1F40 CD 78 06 0B 0181       call print_hex_hl
0B1F44 CD 49 04 0B 0182       call print_s168_hl
0B1F48 CD 7F 0C 0B 0183       call polar_to_cartesian
0B1F4C CD 88 02 0B 0184       call printNewLine
0B1F50 CD 8F 06 0B 0185       call print_hex_bc
0B1F54 CD 56 04 0B 0186       call print_s168_bc
0B1F58 CD A8 06 0B 0187       call print_hex_de
0B1F5C CD 67 04 0B 0188       call print_s168_de
0B1F60 C9          0189       ret
0B1F61             0190   cart2polar:
0B1F61 18 0B       0191       jr @start
0B1F63 63 61 72 74 0192       asciz "cart2polar"
       32 70 6F 6C 
       61 72 00    
0B1F6E             0193   @start:
0B1F6E             0194       ; call cartesian_to_polar
0B1F6E C9          0195       ret
0B1F6F             0196   
0B1F6F             0197   function:
0B1F6F 7E 1F 0B    0198       dl sin
0B1F72 9D 1F 0B    0199       dl cos
0B1F75 BC 1F 0B    0200       dl sqrt
0B1F78 CC 1F 0B    0201       dl deg256
0B1F7B 00 00 00    0202       dl 0x000000 ; list terminator
0B1F7E             0203   sin:
0B1F7E 18 04       0204       jr @start
0B1F80 73 69 6E 00 0205       asciz "sin"
0B1F84             0206   @start:
0B1F84 CD 2D 0C 0B 0207       call deg_360_to_256
0B1F88 CD 78 06 0B 0208       call print_hex_hl
0B1F8C CD 49 04 0B 0209       call print_s168_hl
0B1F90 CD 54 0C 0B 0210       call sin168
0B1F94 CD 78 06 0B 0211       call print_hex_hl
0B1F98 CD 49 04 0B 0212       call print_s168_hl
0B1F9C C9          0213       ret
0B1F9D             0214   cos:
0B1F9D 18 04       0215       jr @start
0B1F9F 63 6F 73 00 0216       asciz "cos"
0B1FA3             0217   @start:
0B1FA3 CD 2D 0C 0B 0218       call deg_360_to_256
0B1FA7 CD 78 06 0B 0219       call print_hex_hl
0B1FAB CD 49 04 0B 0220       call print_s168_hl
0B1FAF CD 4F 0C 0B 0221       call cos168
0B1FB3 CD 78 06 0B 0222       call print_hex_hl
0B1FB7 CD 49 04 0B 0223       call print_s168_hl
0B1FBB C9          0224       ret
0B1FBC             0225   sqrt:
0B1FBC 18 05       0226       jr @start
0B1FBE 73 71 72 74 0227       asciz "sqrt"
       00          
0B1FC3             0228   @start:
0B1FC3 CD 42 0B 0B 0229       call sqrt168
0B1FC7 CD 49 04 0B 0230       call print_s168_hl
0B1FCB C9          0231       ret
0B1FCC             0232   deg256:
0B1FCC 18 07       0233       jr @start
0B1FCE 64 65 67 32 0234       asciz "deg256"
       35 36 00    
0B1FD5             0235   @start:
0B1FD5 CD 2D 0C 0B 0236       call deg_360_to_256
0B1FD9 CD 78 06 0B 0237       call print_hex_hl
0B1FDD CD 49 04 0B 0238       call print_s168_hl
0B1FE1 C9          0239       ret
0B1FE2             0240   
0B1FE2             0241   ; ========== HELPER FUNCTIONS ==========
0B1FE2             0242   ; get the next argument after ix as a signed 16.8 fixed point number
0B1FE2             0243   ; inputs: ix = pointer to the argument string
0B1FE2             0244   ; outputs: ude = signed 16.8 fixed point number
0B1FE2             0245   ; destroys: a, d, e, h, l, f
0B1FE2             0246   get_arg_s168:
0B1FE2 ED 32 03    0247       lea ix,ix+3 ; point to the next argument
0B1FE5 DD 27 00    0248       ld hl,(ix)  ; get the argument string
0B1FE8 CD 94 01 0B 0249       call asc_to_s168 ; convert the string to a number
0B1FEC C9          0250       ret ; return with the value in DE
0B1FED             0251   
0B1FED             0252   ; Inputs: ix = pointer to the argument string
0B1FED             0253   ; Outputs: ude = signed 24-bit integer
0B1FED             0254   ; Destroys: a, d, e, h, l, f
0B1FED             0255   get_arg_s24:
0B1FED ED 32 03    0256       lea ix,ix+3 ; point to the next argument
0B1FF0 DD 27 00    0257       ld hl,(ix)  ; get the argument string
0B1FF3 CD 45 01 0B 0258       call asc_to_s24 ; convert the string to a number
0B1FF7 C9          0259       ret ; return with the value in DE
0B1FF8             0260   
0B1FF8             0261   get_plot_coords:
0B1FF8             0262   ; get the move coordinates
0B1FF8 ED 32 03    0263       lea ix,ix+3 ; pointer to next argument address
0B1FFB DD 27 00    0264       ld hl,(ix)  ; pointer to the x coordinate string
0B1FFE CD 94 01 0B 0265       call asc_to_s168 ; de = x coordinate
0B2002 D5          0266       push de
0B2003 C1          0267       pop bc ; bc = x coordinate
0B2004 ED 32 03    0268       lea ix,ix+3 ; pointer to next argument address
0B2007 DD 27 00    0269       ld hl,(ix)  ; pointer to the y coordinate string
0B200A CD 94 01 0B 0270       call asc_to_s168 ; de = y coordinate
0B200E C9          0271       ret
0B200F             0272   
0B200F             0273   get_arg_text:
0B200F ED 32 03    0274       lea ix,ix+3 ; point to the next argument
0B2012 DD 27 00    0275       ld hl,(ix)  ; get the argument string
0B2015 C9          0276       ret
0B2016             0277   
0B2016             0278   ; match the next argument after ix to the dispatch table at iy
0B2016             0279   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B2016             0280   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B2016             0281   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B2016             0282   ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B2016             0283   ; destroys: a, hl, de, ix, iy, flags
0B2016             0284   match_next:
0B2016 ED 32 03    0285       lea ix,ix+3         ; point to the next argument
0B2019             0286   @loop:
0B2019 FD 27 00    0287       ld hl,(iy)          ; pointer argument dispatch record
0B201C             0288       sign_hlu            ; check for list terminator
0B201C 19          0001M          add hl,de
0B201D B7          0002M          or a
0B201E ED 52       0003M          sbc hl,de
0B2020 CA 38 20 0B 0289       jp z,@no_match      ; if a=0, return error
0B2024 23          0290       inc hl              ; skip over jp instruction
0B2025 23          0291       inc hl
0B2026 DD 17 00    0292       ld de,(ix)          ; pointer to the argument string
0B2029 CD 4F 20 0B 0293       call str_equal      ; compare the argument to the dispatch table entry
0B202D CA 3A 20 0B 0294       jp z,@match         ; if equal, return success
0B2031 ED 33 03    0295       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B2034 C3 19 20 0B 0296       jp @loop            ; and loop
0B2038             0297   @no_match:
0B2038 3C          0298       inc a               ; no match so return a=1 and zero flag reset
0B2039 C9          0299       ret
0B203A             0300   @match:
0B203A FD 37 00    0301       ld iy,(iy)          ; get the function pointer
0B203D C9          0302       ret                 ; return a=0 and zero flag set
0B203E             0303   
0B203E             0304   ; same as match_next, but prints the parameter if a match is found
0B203E             0305   match_next_and_print:
0B203E CD 16 20 0B 0306       call match_next
0B2042 C0          0307       ret nz ; no match found
0B2043 ED 32 FD    0308       lea ix,ix-3
0B2046 CD 0F 20 0B 0309       call get_arg_text ; hl points to the operator string
0B204A CD 5A 20 0B 0310       call print_param
0B204E C9          0311       ret
0B204F             0312   
0B204F             0313   ; compare two zero-terminated strings for equality, case-sensitive
0B204F             0314   ; hl: pointer to first string, de: pointer to second string
0B204F             0315   ; returns: z if equal, nz if not equal
0B204F             0316   ; destroys: a, hl, de
0B204F             0317   str_equal:
0B204F 1A          0318       ld a,(de)           ; get the first character
0B2050 BE          0319       cp (hl)             ; compare to the second character
0B2051 C0          0320       ret nz              ; if not equal, return
0B2052 B7          0321       or a
0B2053 C8          0322       ret z               ; if equal and zero, return
0B2054 23          0323       inc hl              ; next character
0B2055 13          0324       inc de
0B2056 C3 4F 20 0B 0325       jp str_equal        ; loop until end of string
0B205A             0326   
0B205A             0327   ; print the parameter string pointed to by ix
0B205A             0328   ; destroys: a, hl
0B205A             0329   print_param:
0B205A DD 27 00    0330       ld hl,(ix)          ; get the parameter pointer
0B205D CD 73 02 0B 0331       call printString    ; print the parameter string
0B2061 3E 20       0332       ld a,' '            ; print a space separator
0B2063 5B D7       0333       rst.lil $10
0B2065 C9          0334       ret
0B2066             0335   
0B2066             0336   ; print the parameters
0B2066             0337   ; inputs: b = number of parameters, ix = pointer to the parameters
0B2066             0338   ; destroys: a, hl, bc
0B2066             0339   print_params:
0B2066 41          0340       ld b,c              ; loop counter = number of parameters
0B2067 DD E5       0341       push ix             ; save the pointer to the parameters
0B2069             0342   @loop:
0B2069 C5          0343       push bc             ; save the loop counter
0B206A CD 5A 20 0B 0344       call print_param    ; print the parameter
0B206E ED 32 03    0345       lea ix,ix+3         ; next parameter pointer
0B2071 C1          0346       pop bc              ; get back the loop counter
0B2072 10 F5       0347       djnz @loop          ; loop until done
0B2074 DD E1       0348       pop ix              ; restore the pointer to the parameters
0B2076 C9          0349       ret
0B2077             0350   
0B2077             0351   debug_print:
0B2077 CD 88 02 0B 0352       call printNewLine   ; DEBUG
0B207B CD 53 07 0B 0353       call dumpFlags      ; DEBUG
0B207F CD 5A 20 0B 0354       call print_param    ; DEBUG
0B2083 CD 88 02 0B 0355       call printNewLine   ; DEBUG
0B2087 CD 88 02 0B 0356       call printNewLine   ; DEBUG
0B208B C9          0357       ret
