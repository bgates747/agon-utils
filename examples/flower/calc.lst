PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "calc.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 63 61 6C 63 0001*M     ASCIZ "calc.bin"
       2E 62 69 6E 
       00          
0B000D             0025*  
0B000D FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD 5A 1A 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 93 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F             0108*      ; call _skip_spaces ; skip whitespace
0B014F             0109*  
0B014F 7E          0110*      ld a, (hl) ; read first character
0B0150 B7          0111*      or a ; check for end of string
0B0151 C8          0112*      ret z ; return with no carry if not
0B0152             0113*  
0B0152 C5          0114*      push bc ; preserve bc
0B0153             0115*  
0B0153 FE 2D       0116*      cp '-' ; check for negative number
0B0155 C2 5F 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B0159 AF          0118*      xor a ; sign flag to zero
0B015A 32 93 01 0B 0119*      ld (@sign),a ; store sign flag
0B015E 23          0120*      inc hl ; skip '-'
0B015F             0121*  
0B015F             0122*  @loop:
0B015F 7E          0123*      ld a, (hl)
0B0160 D6 30       0124*      sub '0' ; normalise to 0
0B0162 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0164 FE 0A       0126*      cp 10 ; check if >= 10
0B0166 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B0168 E5          0128*      push hl ; stack hl
0B0169 D5          0129*      push de ; ld hl, de
0B016A E1          0130*      pop hl
0B016B E5          0131*      push hl ; ld bc, hl
0B016C C1          0132*      pop bc
0B016D 29          0133*      add hl, hl ; x 2
0B016E 29          0134*      add hl, hl ; x 4
0B016F 09          0135*      add hl, bc ; x 5
0B0170 29          0136*      add hl, hl ; x 10
0B0171 01 00 00 00 0137*      ld bc, 0
0B0175 4F          0138*      ld c, a ; ld bcu, a
0B0176 09          0139*      add hl, bc ; add bcu to hl
0B0177 E5          0140*      push hl ; ld de, hl
0B0178 D1          0141*      pop de
0B0179 E1          0142*      pop hl ; restore hl
0B017A 23          0143*      inc hl
0B017B 18 E2       0144*      jr @loop
0B017D             0145*  
0B017D             0146*  @integer_end:
0B017D C1          0147*      pop bc ; send bc back how she came in
0B017E 3A 93 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0182 3D          0149*      dec a ; check if negative
0B0183 F2 91 01 0B 0150*      jp p,@pos ; positive number
0B0187             0151*  
0B0187             0152*  ; Negate de
0B0187 E5          0153*      push hl ; save text pointer
0B0188 21 00 00 00 0154*      ld hl, 0
0B018C AF          0155*      xor a ; clear carry
0B018D ED 52       0156*      sbc hl, de ; subtract DE from HL
0B018F EB          0157*      ex de, hl ; DE = 0-HL
0B0190 E1          0158*      pop hl ; restore text pointer
0B0191             0159*  
0B0191             0160*  @pos:
0B0191 37          0161*      scf ; we have a valid number so set carry
0B0192 C9          0162*      ret
0B0193             0163*  
0B0193 00          0164*  @sign: db 0 ; sign flag buffer
0B0194             0165*  
0B0194             0166*  
0B0194             0167*  ;------------------------------------------------------------------------
0B0194             0168*  ; Read a number and convert to binary (decimal only)
0B0194             0169*  ; Inputs: hl: Pointer in string buffer
0B0194             0170*  ; Outputs: hl: Updated text pointer
0B0194             0171*  ;         de: Value
0B0194             0172*  ;         a: Terminator (spaces skipped)
0B0194             0173*  ;         f: Carry set if valid number, otherwise reset
0B0194             0174*  ; Destroys: a, d, e, h, l, f
0B0194             0175*  ;------------------------------------------------------------------------
0B0194             0176*  asc_to_s168:
0B0194 3E 01       0177*      ld a,1 ; set sign flag
0B0196 32 53 02 0B 0178*      ld (@sign),a ; store sign flag
0B019A             0179*  
0B019A 11 00 00 00 0180*      ld de, 0 ; initialise de
0B019E ED 53 4B 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A3 ED 53 4F 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01A8             0183*  
0B01A8             0184*      ; call _skip_spaces ; skip whitespace
0B01A8             0185*  
0B01A8 7E          0186*      ld a, (hl) ; read first character
0B01A9 B7          0187*      or a ; check for end of string
0B01AA C8          0188*      ret z ; return with no carry if not
0B01AB             0189*  
0B01AB C5          0190*      push bc ; preserve bc
0B01AC             0191*  
0B01AC FE 2D       0192*      cp '-' ; check for negative number
0B01AE C2 B8 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01B2 AF          0194*      xor a ; sign flag to zero
0B01B3 32 53 02 0B 0195*      ld (@sign),a ; store sign flag
0B01B7 23          0196*      inc hl ; skip '-'
0B01B8             0197*  
0B01B8             0198*  @loop:
0B01B8 7E          0199*      ld a, (hl)
0B01B9             0200*  
0B01B9             0201*  ; chcek for decimal point
0B01B9 FE 2E       0202*      cp '.' ; check for decimal point
0B01BB CA FC 01 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01BF             0204*  
0B01BF             0205*  ; process integer part
0B01BF D6 30       0206*      sub '0' ; normalise to 0
0B01C1 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01C3 FE 0A       0208*      cp 10 ; check if >= 10
0B01C5 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01C7 E5          0210*      push hl ; stack hl
0B01C8 D5          0211*      push de ; ld hl, de
0B01C9 E1          0212*      pop hl
0B01CA E5          0213*      push hl ; ld bc, hl
0B01CB C1          0214*      pop bc
0B01CC 29          0215*      add hl, hl ; x 2
0B01CD 29          0216*      add hl, hl ; x 4
0B01CE 09          0217*      add hl, bc ; x 5
0B01CF 29          0218*      add hl, hl ; x 10
0B01D0 01 00 00 00 0219*      ld bc, 0
0B01D4 4F          0220*      ld c, a ; ld bcu, a
0B01D5 09          0221*      add hl, bc ; add bcu to hl
0B01D6 E5          0222*      push hl ; ld de, hl
0B01D7 D1          0223*      pop de
0B01D8 E1          0224*      pop hl ; restore hl
0B01D9 23          0225*      inc hl
0B01DA 18 DC       0226*      jr @loop
0B01DC             0227*  
0B01DC             0228*  @integer_end:
0B01DC ED 53 4C 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E1             0230*  
0B01E1             0231*  @end:
0B01E1 C1          0232*      pop bc ; send bc back how she came in
0B01E2 ED 5B 4B 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01E7 3A 53 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01EB 3D          0235*      dec a ; check if negative
0B01EC F2 FA 01 0B 0236*      jp p,@pos ; positive number
0B01F0             0237*  
0B01F0             0238*  ; Negate de
0B01F0 E5          0239*      push hl ; save text pointer
0B01F1 21 00 00 00 0240*      ld hl, 0
0B01F5 AF          0241*      xor a ; clear carry
0B01F6 ED 52       0242*      sbc hl, de ; subtract DE from HL
0B01F8 EB          0243*      ex de, hl ; DE = 0-HL
0B01F9 E1          0244*      pop hl ; restore text pointer
0B01FA             0245*  
0B01FA             0246*  @pos:
0B01FA 37          0247*      scf ; we have a valid number so set carry
0B01FB C9          0248*      ret
0B01FC             0249*  
0B01FC             0250*  @fractional_start:
0B01FC DD E5       0251*      push ix                    ; preserve ix
0B01FE ED 53 4C 02 0252*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0203 06 03       0253*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0205 11 00 00 00 0254*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0209 DD 21 54 02 0255*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B020E 23          0256*      inc hl                     ; Skip decimal point
0B020F             0257*  
0B020F             0258*  @fractional_loop:
0B020F 7E          0259*      ld a, (hl)                 ; Load next character
0B0210 D6 30       0260*      sub '0'                    ; Normalize ASCII to decimal
0B0212 38 1C       0261*      jr c, @end_fraction        ; Exit if < '0'
0B0214 FE 0A       0262*      cp 10
0B0216 30 18       0263*      jr nc, @end_fraction       ; Exit if >= 10
0B0218             0264*  
0B0218             0265*      ; Multiply the current fractional accumulator by 10
0B0218 E5          0266*      push hl                    ; Save char pointer
0B0219 F5          0267*      push af                    ; Save the digit
0B021A EB          0268*      ex de, hl
0B021B E5          0269*      push hl
0B021C 29          0270*      add hl,hl ; * 2
0B021D 29          0271*      add hl,hl ; * 4
0B021E D1          0272*      pop de
0B021F 19          0273*      add hl,de ; * 5
0B0220 29          0274*      add hl,hl ; * 10
0B0221 11 00 00 00 0275*      ld de, 0                   ; Clear DEU
0B0225 F1          0276*      pop af                     ; Restore the current digit
0B0226 5F          0277*      ld e, a                    ; Load the digit into E
0B0227 19          0278*      add hl, de                 ; Add the digit to the accumulator
0B0228 EB          0279*      ex de, hl                  ; Result back to DE
0B0229 ED 32 03    0280*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B022C E1          0281*      pop hl                     ; Restore char pointer
0B022D 23          0282*      inc hl                     ; Move to the next character
0B022E 10 DF       0283*      djnz @fractional_loop      ; Loop if more digits to process
0B0230             0284*  
0B0230             0285*  @end_fraction:
0B0230             0286*  ; Final scaling based on number of fractional digits processed
0B0230 ED 53 50 02 0287*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0235 2A 4F 02 0B 0288*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0239             0289*  
0B0239 DD 17 00    0290*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B023C CD 47 09 0B 0291*      call udiv24                ; Perform 24-bit division to scale down
0B0240 7B          0292*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0241 32 4B 02 0B 0293*      ld (@result), a            ; Store fractional part in result buffer
0B0245 DD E1       0294*      pop ix                     ; Restore ix
0B0247 C3 E1 01 0B 0295*      jp @end                    ; Final sign check and flag setup
0B024B             0296*  
0B024B             0297*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B024F             0298*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0253 00          0299*  @sign: db 0                    ; Sign flag buffer
0B0254             0300*  
0B0254             0301*  powers_of_10:
0B0254 01 00 00    0302*      dl 1                       ; 10^0
0B0257 0A 00 00    0303*      dl 10                      ; 10^1
0B025A 64 00 00    0304*      dl 100                     ; 10^2
0B025D E8 03 00    0305*      dl 1000                    ; 10^3
0B0260 10 27 00    0306*      dl 10000                   ; 10^4
0B0263             0017   
0B0263             0018   ; API INCLUDES
0B0263             0019       include "functions.inc"
0B0263             0001*      MACRO printChar char
0B0263             0002*          LD A, char
0B0263             0003*          RST.LIL 10h
0B0263             0004*      ENDMACRO
0B0263             0005*  
0B0263             0006*  ; test the sign of HL
0B0263             0007*  ; inputs: HL obviously
0B0263             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0263             0009*  ; destroys: flags
0B0263             0010*      MACRO sign_hlu
0B0263             0011*          add hl,de
0B0263             0012*          or a
0B0263             0013*          sbc hl,de
0B0263             0014*      ENDMACRO
0B0263             0015*  
0B0263             0016*  ; Simulated call to subroutine at HL
0B0263             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0263             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0263             0019*  ; destroys: only what the subroutine does, but always BC
0B0263             0020*      MACRO callHL
0B0263             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0022*          push bc       ; which constitutes the return address
0B0263             0023*          jp   (hl)     ; Jump to the address in HL
0B0263             0024*      ENDMACRO
0B0263             0025*  
0B0263             0026*  ; Simulated call to subroutine at IX
0B0263             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0263             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0263             0029*  ; destroys: only what the subroutine does, but always BC
0B0263             0030*      MACRO callIX
0B0263             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0032*          push bc       ; which constitutes the return address
0B0263             0033*          jp   (ix)     ; Jump to the address in IX
0B0263             0034*      ENDMACRO
0B0263             0035*  
0B0263             0036*  ; Simulated call to soubroutinte at IY
0B0263             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0263             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0263             0039*  ; destroys: only what the subroutine does, but always BC
0B0263             0040*      MACRO callIY
0B0263             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0042*          push bc       ; which constitutes the return address
0B0263             0043*          jp   (iy)     ; Jump to the address in IY
0B0263             0044*      ENDMACRO
0B0263             0045*  
0B0263             0046*  ; put the value in HLU into the accumulator
0B0263             0047*  ; destroys: af
0B0263             0048*      MACRO HLU_TO_A
0B0263             0049*          push hl ; 4 cycles
0B0263             0050*          inc sp ; 1 cycle
0B0263             0051*          pop af  ; 4 cycles
0B0263             0052*          dec sp ; 1 cycle
0B0263             0053*                 ; 10 cycles total
0B0263             0054*      ENDMACRO
0B0263             0055*  
0B0263             0056*  A_TO_HLU:
0B0263             0057*      ; call is 7 cycles
0B0263 22 70 02 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0267 32 72 02 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B026B 2A 70 02 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B026F C9          0061*      ret ; 6 cycles
0B0270             0062*          ; 25 cycles total
0B0270 00 00 00    0063*  @scratch: dl 0
0B0273             0064*  
0B0273             0065*      ; TODO: implement this
0B0273             0066*      ; MACRO A_TO_HLU
0B0273             0067*      ;     push.s af
0B0273             0068*      ;     inc sp
0B0273             0069*      ;     push.s hl
0B0273             0070*      ;     pop hl
0B0273             0071*      ;     inc sp
0B0273             0072*      ;     inc sp
0B0273             0073*      ; ENDMACRO
0B0273             0074*  
0B0273             0075*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0273             0076*  ; Print a zero-terminated string
0B0273             0077*  ; HL: Pointer to string
0B0273             0078*  printString:
0B0273 C5          0079*  	PUSH	BC
0B0274 01 00 00 00 0080*  	LD		BC,0
0B0278 3E 00       0081*  	LD 	 	A,0
0B027A 5B DF       0082*  	RST.LIL 18h
0B027C C1          0083*  	POP		BC
0B027D C9          0084*  	RET
0B027E             0085*  ; print a VDU sequence
0B027E             0086*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B027E             0087*  sendVDUsequence:
0B027E C5          0088*  	PUSH	BC
0B027F 01 00 00 00 0089*  	LD		BC, 0
0B0283 4E          0090*  	LD		C, (HL)
0B0284 5B DF       0091*  	RST.LIL	18h
0B0286 C1          0092*  	POP		BC
0B0287 C9          0093*  	RET
0B0288             0094*  ; Print Newline sequence to VDP
0B0288             0095*  printNewLine:
0B0288 F5          0096*      push af ; for some reason rst.lil 10h sets carry flag
0B0289 3E 0D       0097*  	LD	A, '\r'
0B028B 5B D7       0098*  	RST.LIL 10h
0B028D 3E 0A       0099*  	LD	A, '\n'
0B028F 5B D7       0100*  	RST.LIL 10h
0B0291 F1          0101*      pop af
0B0292 C9          0102*  	RET
0B0293             0103*  
0B0293             0104*  ; Print a 24-bit HEX number
0B0293             0105*  ; HLU: Number to print
0B0293             0106*  printHex24:
0B0293             0107*  	; PUSH	HL      ; 4 cycles
0B0293             0108*  	; LD		HL, 2   ; 4 cycles
0B0293             0109*  	; ADD		HL, SP  ; 1 cycle
0B0293             0110*  	; LD		A, (HL) ; 2 cycles
0B0293             0111*  	; POP		HL      ; 4 cycles
0B0293             0112*      ;                 ; 15 cycles total
0B0293 E5          0113*      push hl ; 4 cycles
0B0294 33          0114*      inc sp ; 1 cycle
0B0295 F1          0115*      pop af  ; 4 cycles
0B0296 3B          0116*      dec sp ; 1 cycle
0B0297             0117*              ; 10 cycles total
0B0297 CD A1 02 0B 0118*  	CALL	printHex8
0B029B             0119*  ; Print a 16-bit HEX number
0B029B             0120*  ; HL: Number to print
0B029B             0121*  printHex16:
0B029B 7C          0122*  	LD		A,H
0B029C CD A1 02 0B 0123*  	CALL	printHex8
0B02A0 7D          0124*  	LD		A,L
0B02A1             0125*  ; Print an 8-bit HEX number
0B02A1             0126*  ; A: Number to print
0B02A1             0127*  printHex8:
0B02A1 4F          0128*  	LD		C,A
0B02A2 1F          0129*  	RRA
0B02A3 1F          0130*  	RRA
0B02A4 1F          0131*  	RRA
0B02A5 1F          0132*  	RRA
0B02A6 CD AB 02 0B 0133*  	CALL	@F
0B02AA 79          0134*  	LD		A,C
0B02AB             0135*  @@:
0B02AB E6 0F       0136*  	AND		0Fh
0B02AD C6 90       0137*  	ADD		A,90h
0B02AF 27          0138*  	DAA
0B02B0 CE 40       0139*  	ADC		A,40h
0B02B2 27          0140*  	DAA
0B02B3 5B D7       0141*  	RST.LIL	10h
0B02B5 C9          0142*  	RET
0B02B6             0143*  
0B02B6             0144*  printHexA:
0B02B6 F5          0145*      push af
0B02B7 C5          0146*      push bc
0B02B8 CD A1 02 0B 0147*      call printHex8
0B02BC 3E 20       0148*      ld a,' '
0B02BE 5B D7       0149*      rst.lil 10h
0B02C0 C1          0150*      pop bc
0B02C1 F1          0151*      pop af
0B02C2 C9          0152*      ret
0B02C3             0153*  
0B02C3             0154*  printHexHL:
0B02C3 F5          0155*      push af
0B02C4 C5          0156*      push bc
0B02C5 CD 9B 02 0B 0157*      call printHex16
0B02C9 3E 20       0158*      ld a,' '
0B02CB 5B D7       0159*      rst.lil 10h
0B02CD C1          0160*      pop bc
0B02CE F1          0161*      pop af
0B02CF C9          0162*      ret
0B02D0             0163*  
0B02D0             0164*  printHexUHL:
0B02D0 F5          0165*      push af
0B02D1 C5          0166*      push bc
0B02D2 CD 93 02 0B 0167*      call printHex24
0B02D6 3E 20       0168*      ld a,' '
0B02D8 5B D7       0169*      rst.lil 10h
0B02DA C1          0170*      pop bc
0B02DB F1          0171*      pop af
0B02DC C9          0172*      ret
0B02DD             0173*  
0B02DD             0174*  printHexAUHL:
0B02DD F5          0175*      push af
0B02DE C5          0176*      push bc
0B02DF CD A1 02 0B 0177*      call printHex8
0B02E3 3E 2E       0178*      ld a,'.'
0B02E5 5B D7       0179*      rst.lil 10h
0B02E7 CD 93 02 0B 0180*      call printHex24
0B02EB 3E 20       0181*      ld a,' '
0B02ED 5B D7       0182*      rst.lil 10h
0B02EF C1          0183*      pop bc
0B02F0 F1          0184*      pop af
0B02F1 C9          0185*      ret
0B02F2             0186*  
0B02F2             0187*  printHexABHL:
0B02F2             0188*  ; preserve registers
0B02F2 C5          0189*      push bc ; b will be ok c will not
0B02F3 F5          0190*      push af ; will get totally destroyed
0B02F4             0191*  ; print a
0B02F4 CD A1 02 0B 0192*      call printHex8
0B02F8             0193*  ; print b
0B02F8 78          0194*      ld a,b
0B02F9 CD A1 02 0B 0195*      call printHex8
0B02FD             0196*  ; print hl
0B02FD CD 9B 02 0B 0197*      call printHex16
0B0301             0198*  ; restore registers
0B0301 F1          0199*      pop af
0B0302 C1          0200*      pop bc
0B0303 C9          0201*      ret
0B0304             0202*  
0B0304             0203*  printHexBHL:
0B0304             0204*  ; preserve registers
0B0304 C5          0205*      push bc ; b will be ok c will not
0B0305 F5          0206*      push af ; will get totally destroyed
0B0306             0207*  ; print b
0B0306 78          0208*      ld a,b
0B0307 CD A1 02 0B 0209*      call printHex8
0B030B             0210*  ; print hl
0B030B CD 9B 02 0B 0211*      call printHex16
0B030F             0212*  ; restore registers
0B030F F1          0213*      pop af
0B0310 C1          0214*      pop bc
0B0311 C9          0215*      ret
0B0312             0216*  
0B0312             0217*  printHexCDE:
0B0312             0218*  ; preserve registers
0B0312 C5          0219*      push bc ; b will be ok c will not
0B0313 F5          0220*      push af ; will get totally destroyed
0B0314             0221*  ; print c
0B0314 79          0222*      ld a,c
0B0315 CD A1 02 0B 0223*      call printHex8
0B0319             0224*  ; print de
0B0319 EB          0225*      ex de,hl
0B031A CD 9B 02 0B 0226*      call printHex16
0B031E EB          0227*      ex de,hl
0B031F             0228*  ; restore registers
0B031F F1          0229*      pop af
0B0320 C1          0230*      pop bc
0B0321 C9          0231*      ret
0B0322             0232*  
0B0322             0233*  ; Print a 0x HEX prefix
0B0322             0234*  DisplayHexPrefix:
0B0322 3E 30       0235*  	LD	A, '0'
0B0324 5B D7       0236*  	RST.LIL 10h
0B0326 3E 78       0237*  	LD	A, 'x'
0B0328 5B D7       0238*  	RST.LIL 10h
0B032A C9          0239*  	RET
0B032B             0240*  
0B032B             0241*      MACRO printDecBC
0B032B             0242*          push hl
0B032B             0243*          push bc
0B032B             0244*          pop hl
0B032B             0245*          call printDec
0B032B             0246*          pop hl
0B032B             0247*      ENDMACRO
0B032B             0248*  
0B032B             0249*      MACRO printDecDE
0B032B             0250*          push hl
0B032B             0251*          push de
0B032B             0252*          pop hl
0B032B             0253*          call printDec
0B032B             0254*          pop hl
0B032B             0255*      ENDMACRO
0B032B             0256*  
0B032B             0257*      MACRO printDecHL
0B032B             0258*          call printDec
0B032B             0259*      ENDMACRO
0B032B             0260*  
0B032B             0261*      MACRO printDecIX
0B032B             0262*          push hl
0B032B             0263*          push ix
0B032B             0264*          pop hl
0B032B             0265*          call printDec
0B032B             0266*          pop hl
0B032B             0267*      ENDMACRO
0B032B             0268*  
0B032B             0269*      MACRO printDecIY
0B032B             0270*          push hl
0B032B             0271*          push iy
0B032B             0272*          pop hl
0B032B             0273*          call printDec
0B032B             0274*          pop hl
0B032B             0275*      ENDMACRO
0B032B             0276*  
0B032B             0277*  
0B032B             0278*  ; Prints the right justified decimal value in HL without leading zeroes
0B032B             0279*  ; HL : Value to print
0B032B             0280*  ; preserves all registers and flags
0B032B             0281*  printDec:
0B032B             0282*  ; BEGIN MY CODE
0B032B             0283*  ; back up all the things
0B032B F5          0284*      push af
0B032C C5          0285*      push bc
0B032D D5          0286*      push de
0B032E E5          0287*      push hl
0B032F             0288*  ; END MY CODE
0B032F 11 53 03 0B 0289*  	LD	 DE, _printDecBuffer
0B0333 CD 63 03 0B 0290*  	CALL u24_to_ascii
0B0337             0291*  ; BEGIN MY CODE
0B0337             0292*  ; replace leading zeroes with spaces
0B0337 21 53 03 0B 0293*      LD	 HL, _printDecBuffer
0B033B 06 07       0294*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B033D             0295*  @loop:
0B033D 7E          0296*      LD	 A, (HL)
0B033E FE 30       0297*      CP	 '0'
0B0340 C2 4A 03 0B 0298*      JP	 NZ, @done
0B0344 3E 20       0299*      LD   A, ' '
0B0346 77          0300*      LD	 (HL), A
0B0347 23          0301*      INC	 HL
0B0348             0302*      ; CALL vdu_cursor_forward
0B0348 10 F3       0303*      DJNZ @loop
0B034A             0304*  @done:
0B034A             0305*  ; END MY CODE
0B034A             0306*  	; LD	 HL, _printDecBuffer
0B034A CD 73 02 0B 0307*  	CALL printString
0B034E             0308*  ; BEGIN MY CODE
0B034E             0309*  ; restore all the things
0B034E E1          0310*      pop hl
0B034F D1          0311*      pop de
0B0350 C1          0312*      pop bc
0B0351 F1          0313*      pop af
0B0352             0314*  ; END MY CODE
0B0352 C9          0315*  	RET
0B0353 00 00 00 00 0316*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0363             0317*  
0B0363             0318*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0363             0319*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0363             0320*  ; so it will allways be 8 characters length
0B0363             0321*  ; HL : Value to convert to string
0B0363             0322*  ; DE : pointer to buffer, at least 8 byte + 0
0B0363             0323*  u24_to_ascii:
0B0363 01 80 69 67 0324*  	LD	 BC,-10000000
0B0367 CD 9A 03 0B 0325*  	CALL @one_digit
0B036B 01 C0 BD F0 0326*  	LD	 BC,-1000000
0B036F CD 9A 03 0B 0327*  	CALL @one_digit
0B0373 01 60 79 FE 0328*  	LD	 BC,-100000
0B0377 CD 9A 03 0B 0329*  	CALL @one_digit
0B037B 01 F0 D8 FF 0330*  	LD   BC,-10000
0B037F CD 9A 03 0B 0331*  	CALL @one_digit
0B0383 01 18 FC FF 0332*  	LD   BC,-1000
0B0387 CD 9A 03 0B 0333*  	CALL @one_digit
0B038B 01 9C FF FF 0334*  	LD   BC,-100
0B038F CD 9A 03 0B 0335*  	CALL @one_digit
0B0393 0E F6       0336*  	LD   C,-10
0B0395 CD 9A 03 0B 0337*  	CALL @one_digit
0B0399 48          0338*  	LD   C,B
0B039A             0339*  @one_digit:
0B039A 3E 2F       0340*  	LD   A,'0'-1
0B039C             0341*  @divide_me:
0B039C 3C          0342*  	INC  A
0B039D 09          0343*  	ADD  HL,BC
0B039E 38 FC       0344*  	JR   C,@divide_me
0B03A0 ED 42       0345*  	SBC  HL,BC
0B03A2 12          0346*  	LD   (DE),A
0B03A3 13          0347*  	INC  DE
0B03A4 C9          0348*  	RET
0B03A5             0349*  
0B03A5             0350*  print_u24:
0B03A5 D5          0351*      push de
0B03A6 E5          0352*      push hl
0B03A7 11 53 03 0B 0353*      ld de,_printDecBuffer
0B03AB CD 63 03 0B 0354*      call u24_to_ascii
0B03AF 21 53 03 0B 0355*      ld hl,_printDecBuffer
0B03B3 CD 73 02 0B 0356*      call printString
0B03B7 3E 20       0357*      ld a,' '
0B03B9 5B D7       0358*      rst.lil 10h
0B03BB E1          0359*      pop hl
0B03BC D1          0360*      pop de
0B03BD C9          0361*      ret
0B03BE             0362*  
0B03BE             0363*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03BE             0364*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03BE             0365*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03BE             0366*  u168_to_ascii:
0B03BE             0367*  ; add a leading space to make room for sign flag if needed
0B03BE 3E 20       0368*      ld a,' '
0B03C0 12          0369*      ld (de),a
0B03C1 13          0370*      inc de
0B03C2             0371*  ; Convert integer part
0B03C2 E5          0372*      push hl               ; Save HL (we’ll need the fractional part later)
0B03C3 CD D4 07 0B 0373*      call hlu_udiv256    ; Shift to get integer portion in HL
0B03C7 01 F0 D8 FF 0374*      ld   bc, -10000
0B03CB CD EE 03 0B 0375*      call @one_int
0B03CF 01 18 FC FF 0376*      ld   bc, -1000
0B03D3 CD EE 03 0B 0377*      call @one_int
0B03D7 01 9C FF FF 0378*      ld   bc, -100
0B03DB CD EE 03 0B 0379*      call @one_int
0B03DF 0E F6       0380*      ld   c, -10
0B03E1 CD EE 03 0B 0381*      call @one_int
0B03E5 48          0382*      ld   c, b
0B03E6 CD EE 03 0B 0383*      call @one_int
0B03EA C3 F9 03 0B 0384*      jp   @frac            ; Jump to fractional part conversion
0B03EE             0385*  @one_int:
0B03EE 3E 2F       0386*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F0             0387*  @divide_me:
0B03F0 3C          0388*      inc  a
0B03F1 09          0389*      add  hl, bc           ; Accumulate until overflow
0B03F2 38 FC       0390*      jr   c, @divide_me
0B03F4 ED 42       0391*      sbc  hl, bc           ; Remove excess after overflow
0B03F6 12          0392*      ld   (de), a          ; Store ASCII digit
0B03F7 13          0393*      inc  de
0B03F8 C9          0394*      ret
0B03F9             0395*  ; Convert fractional part
0B03F9             0396*  @frac:
0B03F9 3E 2E       0397*      ld   a, '.'           ; Decimal point
0B03FB 12          0398*      ld   (de), a
0B03FC 13          0399*      inc  de
0B03FD E1          0400*      pop  hl               ; Restore HL with original fraction
0B03FE 06 03       0401*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0400             0402*  @frac_loop:
0B0400 26 0A       0403*      ld   h, 10            ; Load multiplier for fractional part
0B0402 ED 6C       0404*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0404 3E 30       0405*      ld   a, '0'
0B0406 84          0406*      add  a, h             ; Convert integer part to ASCII
0B0407 12          0407*      ld   (de), a
0B0408 13          0408*      inc  de
0B0409 10 F5       0409*      djnz @frac_loop       ; Repeat for each fractional digit
0B040B             0410*  ; Add null terminator
0B040B AF          0411*      xor  a                ; Null terminator
0B040C 12          0412*      ld   (de), a
0B040D C9          0413*      ret
0B040E             0414*  
0B040E             0415*  print_u168:
0B040E D5          0416*      push de
0B040F E5          0417*      push hl
0B0410 11 53 03 0B 0418*      ld de,_printDecBuffer
0B0414 CD BE 03 0B 0419*      call u168_to_ascii
0B0418 21 53 03 0B 0420*      ld hl,_printDecBuffer
0B041C CD 73 02 0B 0421*      call printString
0B0420 E1          0422*      pop hl
0B0421 D1          0423*      pop de
0B0422 C9          0424*      ret
0B0423             0425*  
0B0423             0426*  ; signed version of u168_to_ascii
0B0423             0427*  s168_to_ascii:
0B0423 D5          0428*      push de ; save starting address of buffer
0B0424 CD 6D 07 0B 0429*      call abs_hlu
0B0428 F5          0430*      push af ; save sign flag
0B0429 CD BE 03 0B 0431*      call u168_to_ascii
0B042D F1          0432*      pop af ; restore sign flag
0B042E D1          0433*      pop de ; restore starting address of buffer
0B042F F0          0434*      ret p ; hlu was positive so nothing to do
0B0430 3E 2D       0435*      ld a,'-'
0B0432 12          0436*      ld (de),a
0B0433 C9          0437*      ret
0B0434             0438*  
0B0434             0439*  print_s168:
0B0434 D5          0440*      push de
0B0435 E5          0441*      push hl
0B0436 11 53 03 0B 0442*      ld de,_printDecBuffer
0B043A CD 23 04 0B 0443*      call s168_to_ascii
0B043E 21 53 03 0B 0444*      ld hl,_printDecBuffer
0B0442 CD 73 02 0B 0445*      call printString
0B0446 E1          0446*      pop hl
0B0447 D1          0447*      pop de
0B0448 C9          0448*      ret
0B0449             0449*  
0B0449             0450*  ; #### new functions added by Brandon R. Gates ####
0B0449             0451*  
0B0449             0452*  ; print the binary representation of the 8-bit value in a
0B0449             0453*  ; destroys a, hl, bc
0B0449             0454*  printBin8:
0B0449 06 08       0455*      ld b,8      ; loop counter for 8 bits
0B044B 21 66 04 0B 0456*      ld hl,@cmd  ; set hl to the low byte of the output string
0B044F             0457*                  ; (which will be the high bit of the value in a)
0B044F             0458*  @loop:
0B044F 07          0459*      rlca ; put the next highest bit into carry
0B0450 38 04       0460*      jr c,@one
0B0452 36 30       0461*      ld (hl),'0'
0B0454 18 02       0462*      jr @next_bit
0B0456             0463*  @one:
0B0456 36 31       0464*      ld (hl),'1'
0B0458             0465*  @next_bit:
0B0458 23          0466*      inc hl
0B0459 10 F4       0467*      djnz @loop
0B045B             0468*  ; print it
0B045B 21 66 04 0B 0469*  	ld hl,@cmd
0B045F 01 08 00 00 0470*  	ld bc,@end-@cmd
0B0463 5B DF       0471*  	rst.lil $18
0B0465 C9          0472*  	ret
0B0466             0473*  @cmd: ds 8 ; eight bytes for eight bits
0B046E             0474*  @end:
0B046E             0475*  
0B046E             0476*  ; print the binary representation of the 8-bit value in a
0B046E             0477*  ; in reverse order (lsb first)
0B046E             0478*  ; destroys a, hl, bc
0B046E             0479*  printBin8Rev:
0B046E 06 08       0480*      ld b,8      ; loop counter for 8 bits
0B0470 21 8B 04 0B 0481*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0474             0482*                  ; (which will be the high bit of the value in a)
0B0474             0483*  @loop:
0B0474 0F          0484*      rrca ; put the next lowest bit into carry
0B0475 38 04       0485*      jr c,@one
0B0477 36 30       0486*      ld (hl),'0'
0B0479 18 02       0487*      jr @next_bit
0B047B             0488*  @one:
0B047B 36 31       0489*      ld (hl),'1'
0B047D             0490*  @next_bit:
0B047D 23          0491*      inc hl
0B047E 10 F4       0492*      djnz @loop
0B0480             0493*  ; print it
0B0480 21 8B 04 0B 0494*  	ld hl,@cmd
0B0484 01 08 00 00 0495*  	ld bc,@end-@cmd
0B0488 5B DF       0496*  	rst.lil $18
0B048A C9          0497*  	ret
0B048B             0498*  @cmd: ds 8 ; eight bytes for eight bits
0B0493             0499*  @end:
0B0493             0500*  
0B0493             0501*  ; print registers to screen in hexidecimal format
0B0493             0502*  ; inputs: none
0B0493             0503*  ; outputs: values of every register printed to screen
0B0493             0504*  ;    values of each register in global scratch memory
0B0493             0505*  ; destroys: nothing
0B0493             0506*  stepRegistersHex:
0B0493             0507*  ; store everything in scratch
0B0493 22 78 06 0B 0508*      ld (uhl),hl
0B0497 ED 43 7B 06 0509*      ld (ubc),bc
       0B          
0B049C ED 53 7E 06 0510*      ld (ude),de
       0B          
0B04A1 DD 22 81 06 0511*      ld (uix),ix
       0B          
0B04A6 FD 22 84 06 0512*      ld (uiy),iy
       0B          
0B04AB F5          0513*      push af ; fml
0B04AC E1          0514*      pop hl  ; thanks, zilog
0B04AD 22 75 06 0B 0515*      ld (uaf),hl
0B04B1 F5          0516*      push af ; dammit
0B04B2             0517*  
0B04B2             0518*  ; home the cursor
0B04B2             0519*      ; call vdu_home_cursor
0B04B2             0520*  
0B04B2             0521*  ; print each register
0B04B2 21 FB 05 0B 0522*      ld hl,str_afu
0B04B6 CD 73 02 0B 0523*      call printString
0B04BA 2A 75 06 0B 0524*      ld hl,(uaf)
0B04BE CD 93 02 0B 0525*      call printHex24
0B04C2 CD 88 02 0B 0526*      call printNewLine
0B04C6             0527*  
0B04C6 21 00 06 0B 0528*      ld hl,str_hlu
0B04CA CD 73 02 0B 0529*      call printString
0B04CE 2A 78 06 0B 0530*      ld hl,(uhl)
0B04D2 CD 93 02 0B 0531*      call printHex24
0B04D6 CD 88 02 0B 0532*      call printNewLine
0B04DA             0533*  
0B04DA 21 05 06 0B 0534*      ld hl,str_bcu
0B04DE CD 73 02 0B 0535*      call printString
0B04E2 2A 7B 06 0B 0536*      ld hl,(ubc)
0B04E6 CD 93 02 0B 0537*      call printHex24
0B04EA CD 88 02 0B 0538*      call printNewLine
0B04EE             0539*  
0B04EE 21 0A 06 0B 0540*      ld hl,str_deu
0B04F2 CD 73 02 0B 0541*      call printString
0B04F6 2A 7E 06 0B 0542*      ld hl,(ude)
0B04FA CD 93 02 0B 0543*      call printHex24
0B04FE CD 88 02 0B 0544*      call printNewLine
0B0502             0545*  
0B0502 21 0F 06 0B 0546*      ld hl,str_ixu
0B0506 CD 73 02 0B 0547*      call printString
0B050A 2A 81 06 0B 0548*      ld hl,(uix)
0B050E CD 93 02 0B 0549*      call printHex24
0B0512 CD 88 02 0B 0550*      call printNewLine
0B0516             0551*  
0B0516 21 14 06 0B 0552*      ld hl,str_iyu
0B051A CD 73 02 0B 0553*      call printString
0B051E 2A 84 06 0B 0554*      ld hl,(uiy)
0B0522 CD 93 02 0B 0555*      call printHex24
0B0526 CD 88 02 0B 0556*      call printNewLine
0B052A             0557*  
0B052A             0558*      ; call vsync
0B052A             0559*  
0B052A CD 88 02 0B 0560*      call printNewLine
0B052E             0561*  
0B052E             0562*  ; check for right shift key and quit if pressed
0B052E             0563*  	MOSCALL mos_getkbmap
0B052E 3E 1E       0001*M 			LD	A, function
0B0530 5B CF       0002*M 			RST.L	08h
0B0532             0564*  @stayhere:
0B0532             0565*  ; 7 RightShift
0B0532 DD CB 00 76 0566*      bit 6,(ix+0)
0B0536 20 02       0567*      jr nz,@RightShift
0B0538 18 F8       0568*      jr @stayhere
0B053A             0569*  @RightShift:
0B053A DD CB 0E 86 0570*      res 0,(ix+14) ; debounce the key (hopefully)
0B053E 3E 80       0571*      ld a,%10000000
0B0540 CD 8B 14 0B 0572*      call multiPurposeDelay
0B0544             0573*  
0B0544             0574*  ; restore everything
0B0544 2A 78 06 0B 0575*      ld hl, (uhl)
0B0548 ED 4B 7B 06 0576*      ld bc, (ubc)
       0B          
0B054D ED 5B 7E 06 0577*      ld de, (ude)
       0B          
0B0552 DD 2A 81 06 0578*      ld ix, (uix)
       0B          
0B0557 FD 2A 84 06 0579*      ld iy, (uiy)
       0B          
0B055C F1          0580*      pop af
0B055D             0581*  ; all done
0B055D C9          0582*      ret
0B055E             0583*  
0B055E             0584*  ; print registers to screen in hexidecimal format
0B055E             0585*  ; inputs: none
0B055E             0586*  ; outputs: values of every register printed to screen
0B055E             0587*  ;    values of each register in global scratch memory
0B055E             0588*  ; destroys: nothing
0B055E             0589*  dumpRegistersHex:
0B055E             0590*  ; store everything in scratch
0B055E 22 78 06 0B 0591*      ld (uhl),hl
0B0562 ED 43 7B 06 0592*      ld (ubc),bc
       0B          
0B0567 ED 53 7E 06 0593*      ld (ude),de
       0B          
0B056C DD 22 81 06 0594*      ld (uix),ix
       0B          
0B0571 FD 22 84 06 0595*      ld (uiy),iy
       0B          
0B0576 F5          0596*      push af ; fml
0B0577 E1          0597*      pop hl  ; thanks, zilog
0B0578 22 75 06 0B 0598*      ld (uaf),hl
0B057C F5          0599*      push af ; dammit
0B057D             0600*  
0B057D             0601*  ; home the cursor
0B057D             0602*      ; call vdu_home_cursor
0B057D             0603*      ; call printNewLine
0B057D             0604*  
0B057D             0605*  ; print each register
0B057D 21 FB 05 0B 0606*      ld hl,str_afu
0B0581 CD 73 02 0B 0607*      call printString
0B0585 2A 75 06 0B 0608*      ld hl,(uaf)
0B0589 CD 93 02 0B 0609*      call printHex24
0B058D             0610*      ; call printNewLine
0B058D             0611*  
0B058D 21 00 06 0B 0612*      ld hl,str_hlu
0B0591 CD 73 02 0B 0613*      call printString
0B0595 2A 78 06 0B 0614*      ld hl,(uhl)
0B0599 CD 93 02 0B 0615*      call printHex24
0B059D             0616*      ; call printNewLine
0B059D             0617*  
0B059D 21 05 06 0B 0618*      ld hl,str_bcu
0B05A1 CD 73 02 0B 0619*      call printString
0B05A5 2A 7B 06 0B 0620*      ld hl,(ubc)
0B05A9 CD 93 02 0B 0621*      call printHex24
0B05AD             0622*      ; call printNewLine
0B05AD             0623*  
0B05AD 21 0A 06 0B 0624*      ld hl,str_deu
0B05B1 CD 73 02 0B 0625*      call printString
0B05B5 2A 7E 06 0B 0626*      ld hl,(ude)
0B05B9 CD 93 02 0B 0627*      call printHex24
0B05BD             0628*      ; call printNewLine
0B05BD             0629*  
0B05BD 21 0F 06 0B 0630*      ld hl,str_ixu
0B05C1 CD 73 02 0B 0631*      call printString
0B05C5 2A 81 06 0B 0632*      ld hl,(uix)
0B05C9 CD 93 02 0B 0633*      call printHex24
0B05CD             0634*      ; call printNewLine
0B05CD             0635*  
0B05CD 21 14 06 0B 0636*      ld hl,str_iyu
0B05D1 CD 73 02 0B 0637*      call printString
0B05D5 2A 84 06 0B 0638*      ld hl,(uiy)
0B05D9 CD 93 02 0B 0639*      call printHex24
0B05DD             0640*      ; call printNewLine
0B05DD             0641*  
0B05DD             0642*      ; call vdu_vblank
0B05DD             0643*  
0B05DD CD 88 02 0B 0644*      call printNewLine
0B05E1             0645*  ; restore everything
0B05E1 2A 78 06 0B 0646*      ld hl, (uhl)
0B05E5 ED 4B 7B 06 0647*      ld bc, (ubc)
       0B          
0B05EA ED 5B 7E 06 0648*      ld de, (ude)
       0B          
0B05EF DD 2A 81 06 0649*      ld ix, (uix)
       0B          
0B05F4 FD 2A 84 06 0650*      ld iy, (uiy)
       0B          
0B05F9 F1          0651*      pop af
0B05FA             0652*  ; all done
0B05FA C9          0653*      ret
0B05FB             0654*  
0B05FB 20 61 66 3D 0655*  str_afu: db " af=",0
       00          
0B0600 20 68 6C 3D 0656*  str_hlu: db " hl=",0
       00          
0B0605 20 62 63 3D 0657*  str_bcu: db " bc=",0
       00          
0B060A 20 64 65 3D 0658*  str_deu: db " de=",0
       00          
0B060F 20 69 78 3D 0659*  str_ixu: db " ix=",0
       00          
0B0614 20 69 79 3D 0660*  str_iyu: db " iy=",0
       00          
0B0619             0661*  
0B0619             0662*  ; print udeuhl to screen in hexidecimal format
0B0619             0663*  ; inputs: none
0B0619             0664*  ; outputs: concatenated hexidecimal udeuhl
0B0619             0665*  ; destroys: nothing
0B0619             0666*  dumpUDEUHLHex:
0B0619             0667*  ; store everything in scratch
0B0619 22 78 06 0B 0668*      ld (uhl),hl
0B061D ED 43 7B 06 0669*      ld (ubc),bc
       0B          
0B0622 ED 53 7E 06 0670*      ld (ude),de
       0B          
0B0627 DD 22 81 06 0671*      ld (uix),ix
       0B          
0B062C FD 22 84 06 0672*      ld (uiy),iy
       0B          
0B0631 F5          0673*      push af
0B0632             0674*  
0B0632             0675*  ; print each register
0B0632             0676*  
0B0632 21 6C 06 0B 0677*      ld hl,str_udeuhl
0B0636 CD 73 02 0B 0678*      call printString
0B063A 2A 7E 06 0B 0679*      ld hl,(ude)
0B063E CD 93 02 0B 0680*      call printHex24
0B0642 3E 2E       0681*  	ld a,'.'	; print a dot to separate the values
0B0644 5B D7       0682*  	rst.lil 10h
0B0646 2A 78 06 0B 0683*      ld hl,(uhl)
0B064A CD 93 02 0B 0684*      call printHex24
0B064E CD 88 02 0B 0685*      call printNewLine
0B0652             0686*  
0B0652             0687*  ; restore everything
0B0652 2A 78 06 0B 0688*      ld hl, (uhl)
0B0656 ED 4B 7B 06 0689*      ld bc, (ubc)
       0B          
0B065B ED 5B 7E 06 0690*      ld de, (ude)
       0B          
0B0660 DD 2A 81 06 0691*      ld ix, (uix)
       0B          
0B0665 FD 2A 84 06 0692*      ld iy, (uiy)
       0B          
0B066A F1          0693*      pop af
0B066B             0694*  ; all done
0B066B C9          0695*      ret
0B066C             0696*  
0B066C 75 64 65 2E 0697*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0675             0698*  
0B0675             0699*  ; global scratch memory for registers
0B0675 00 00 00    0700*  uaf: dl 0
0B0678 00 00 00    0701*  uhl: dl 0
0B067B 00 00 00    0702*  ubc: dl 0
0B067E 00 00 00    0703*  ude: dl 0
0B0681 00 00 00    0704*  uix: dl 0
0B0684 00 00 00    0705*  uiy: dl 0
0B0687 00 00 00    0706*  usp: dl 0
0B068A 00 00 00    0707*  upc: dl 0
0B068D             0708*  
0B068D             0709*  ; inputs: whatever is in the flags register
0B068D             0710*  ; outputs: binary representation of flags
0B068D             0711*  ;          with a header so we know which is what
0B068D             0712*  ; destroys: nothing
0B068D             0713*  ; preserves: everything
0B068D             0714*  dumpFlags:
0B068D             0715*  ; first we curse zilog for not giving direct access to flags
0B068D F5          0716*      push af ; this is so we can send it back unharmed
0B068E F5          0717*      push af ; this is so we can pop it to hl
0B068F             0718*  ; store everything in scratch
0B068F 22 78 06 0B 0719*      ld (uhl),hl
0B0693 ED 43 7B 06 0720*      ld (ubc),bc
       0B          
0B0698 ED 53 7E 06 0721*      ld (ude),de
       0B          
0B069D DD 22 81 06 0722*      ld (uix),ix
       0B          
0B06A2 FD 22 84 06 0723*      ld (uiy),iy
       0B          
0B06A7             0724*  ; next we print the header
0B06A7 21 D3 06 0B 0725*      ld hl,@header
0B06AB CD 73 02 0B 0726*      call printString
0B06AF E1          0727*      pop hl ; flags are now in l
0B06B0 7D          0728*      ld a,l ; flags are now in a
0B06B1 CD 49 04 0B 0729*      call printBin8
0B06B5 CD 88 02 0B 0730*  	call printNewLine
0B06B9             0731*  ; restore everything
0B06B9 2A 78 06 0B 0732*      ld hl, (uhl)
0B06BD ED 4B 7B 06 0733*      ld bc, (ubc)
       0B          
0B06C2 ED 5B 7E 06 0734*      ld de, (ude)
       0B          
0B06C7 DD 2A 81 06 0735*      ld ix, (uix)
       0B          
0B06CC FD 2A 84 06 0736*      ld iy, (uiy)
       0B          
0B06D1 F1          0737*      pop af ; send her home the way she came
0B06D2 C9          0738*      ret
0B06D3             0739*  ; Bit 7 (S): Sign flag
0B06D3             0740*  ; Bit 6 (Z): Zero flag
0B06D3             0741*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B06D3             0742*  ; Bit 4 (H): Half Carry flag
0B06D3             0743*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B06D3             0744*  ; Bit 2 (PV): Parity/Overflow flag
0B06D3             0745*  ; Bit 1 (N): Subtract flag
0B06D3             0746*  ; Bit 0 (C): Carry flag
0B06D3 53 5A 78 48 0747*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B06DE             0748*  
0B06DE             0749*  ; set all the bits in the flag register
0B06DE             0750*  ; more of an academic exercise than anything useful
0B06DE             0751*  ; inputs; none
0B06DE             0752*  ; outputs; a=0,f=255
0B06DE             0753*  ; destroys: flags, hl
0B06DE             0754*  ; preserves: a, because why not
0B06DE             0755*  setAllFlags:
0B06DE 21 FF 00 00 0756*      ld hl,255
0B06E2 67          0757*      ld h,a ; four cycles to preserve a is cheap
0B06E3 E5          0758*      push hl
0B06E4 F1          0759*      pop af
0B06E5 C9          0760*      ret
0B06E6             0761*  
0B06E6             0762*  ; reset all the bits in the flag register
0B06E6             0763*  ; unlike its inverse counterpart, this may actually be useful
0B06E6             0764*  ; inputs; none
0B06E6             0765*  ; outputs; a=0,f=0
0B06E6             0766*  ; destroys: flags, hl
0B06E6             0767*  ; preserves: a, because why not
0B06E6             0768*  resetAllFlags:
0B06E6 21 00 00 00 0769*      ld hl,0
0B06EA 67          0770*      ld h,a ; four cycles to preserve a is cheap
0B06EB E5          0771*      push hl
0B06EC F1          0772*      pop af
0B06ED C9          0773*      ret
0B06EE             0774*  
0B06EE             0775*  ; wait until user presses a key
0B06EE             0776*  ; inputs: none
0B06EE             0777*  ; outputs: none
0B06EE             0778*  ; destroys: af,ix
0B06EE             0779*  waitKeypress:
0B06EE             0780*      MOSCALL mos_sysvars
0B06EE 3E 08       0001*M 			LD	A, function
0B06F0 5B CF       0002*M 			RST.L	08h
0B06F2 AF          0781*      xor a ; zero out any prior keypresses
0B06F3 DD 77 05    0782*      ld (ix+sysvar_keyascii),a
0B06F6             0783*  @loop:
0B06F6 DD 7E 05    0784*      ld a,(ix+sysvar_keyascii)
0B06F9 A7          0785*      and a
0B06FA C0          0786*      ret nz
0B06FB 18 F9       0787*      jr @loop
0B06FD             0788*  
0B06FD             0789*  
0B06FD             0790*  ; print bytes from an address to the screen in hexidecimal format
0B06FD             0791*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06FD             0792*  ; outputs: values of each byte printed to screen separated by spaces
0B06FD             0793*  ; destroys: nothing
0B06FD             0794*  dumpMemoryHex:
0B06FD             0795*  ; save registers to the stack
0B06FD C5          0796*      push bc
0B06FE E5          0797*      push hl
0B06FF F5          0798*      push af
0B0700             0799*  
0B0700             0800*  ; print the address and separator
0B0700 CD 93 02 0B 0801*      call printHex24
0B0704 3E 3A       0802*      ld a,':'
0B0706 5B D7       0803*      rst.lil 10h
0B0708 3E 20       0804*      ld a,' '
0B070A 5B D7       0805*      rst.lil 10h
0B070C             0806*  
0B070C             0807*  ; set b to be our loop counter
0B070C F1          0808*      pop af
0B070D 47          0809*      ld b,a
0B070E E1          0810*      pop hl
0B070F E5          0811*      push hl
0B0710 F5          0812*      push af
0B0711             0813*  @loop:
0B0711             0814*  ; print the byte
0B0711 7E          0815*      ld a,(hl)
0B0712 CD A1 02 0B 0816*      call printHex8
0B0716             0817*  ; print a space
0B0716 3E 20       0818*      ld a,' '
0B0718 5B D7       0819*      rst.lil 10h
0B071A 23          0820*      inc hl
0B071B 10 F4       0821*      djnz @loop
0B071D             0822*      ; call printNewLine
0B071D             0823*  
0B071D             0824*  ; restore everything
0B071D F1          0825*      pop af
0B071E E1          0826*      pop hl
0B071F C1          0827*      pop bc
0B0720             0828*  
0B0720             0829*  ; all done
0B0720 C9          0830*      ret
0B0721             0831*  
0B0721             0832*  
0B0721             0833*  ; print bytes from an address to the screen in binary format
0B0721             0834*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0721             0835*  ; outputs: values of each byte printed to screen separated by spaces
0B0721             0836*  ; destroys: nothing
0B0721             0837*  dumpMemoryBin:
0B0721             0838*  ; save all registers to the stack
0B0721 F5          0839*      push af
0B0722 C5          0840*      push bc
0B0723 D5          0841*      push de
0B0724 E5          0842*      push hl
0B0725 DD E5       0843*      push ix
0B0727 FD E5       0844*      push iy
0B0729             0845*  
0B0729             0846*  ; set b to be our loop counter
0B0729 47          0847*      ld b,a
0B072A             0848*  @loop:
0B072A             0849*  ; print the byte
0B072A 7E          0850*      ld a,(hl)
0B072B E5          0851*      push hl
0B072C C5          0852*      push bc
0B072D CD 49 04 0B 0853*      call printBin8
0B0731 C1          0854*      pop bc
0B0732             0855*  ; print a space
0B0732 3E 20       0856*      ld a,' '
0B0734 5B D7       0857*      rst.lil 10h
0B0736 E1          0858*      pop hl
0B0737 23          0859*      inc hl
0B0738 10 F0       0860*      djnz @loop
0B073A CD 88 02 0B 0861*      call printNewLine
0B073E             0862*  
0B073E             0863*  ; restore everything
0B073E FD E1       0864*      pop iy
0B0740 DD E1       0865*      pop ix
0B0742 E1          0866*      pop hl
0B0743 D1          0867*      pop de
0B0744 C1          0868*      pop bc
0B0745 F1          0869*      pop af
0B0746             0870*  ; all done
0B0746 C9          0871*      ret
0B0747             0872*  
0B0747             0873*  ; print bytes from an address to the screen in binary format
0B0747             0874*  ; with the bits of each byte in reverse order (lsb first)
0B0747             0875*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0747             0876*  ; outputs: values of each byte printed to screen separated by spaces
0B0747             0877*  ; destroys: nothing
0B0747             0878*  dumpMemoryBinRev:
0B0747             0879*  ; save all registers to the stack
0B0747 F5          0880*      push af
0B0748 C5          0881*      push bc
0B0749 D5          0882*      push de
0B074A E5          0883*      push hl
0B074B DD E5       0884*      push ix
0B074D FD E5       0885*      push iy
0B074F             0886*  
0B074F             0887*  ; set b to be our loop counter
0B074F 47          0888*      ld b,a
0B0750             0889*  @loop:
0B0750             0890*  ; print the byte
0B0750 7E          0891*      ld a,(hl)
0B0751 E5          0892*      push hl
0B0752 C5          0893*      push bc
0B0753 CD 6E 04 0B 0894*      call printBin8Rev
0B0757 C1          0895*      pop bc
0B0758             0896*  ; print a space
0B0758 3E 20       0897*      ld a,' '
0B075A 5B D7       0898*      rst.lil 10h
0B075C E1          0899*      pop hl
0B075D 23          0900*      inc hl
0B075E 10 F0       0901*      djnz @loop
0B0760 CD 88 02 0B 0902*      call printNewLine
0B0764             0903*  
0B0764             0904*  ; restore everything
0B0764 FD E1       0905*      pop iy
0B0766 DD E1       0906*      pop ix
0B0768 E1          0907*      pop hl
0B0769 D1          0908*      pop de
0B076A C1          0909*      pop bc
0B076B F1          0910*      pop af
0B076C             0911*  ; all done
0B076C C9          0912*      ret
0B076D             0020       include "maths.inc"
0B076D             0001*  ; absolute value of hlu
0B076D             0002*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B076D             0003*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B076D             0004*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B076D             0005*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B076D             0006*  ; destroys: a
0B076D             0007*  abs_hlu:
0B076D 19          0008*      add hl,de
0B076E B7          0009*      or a
0B076F ED 52       0010*      sbc hl,de
0B0771 FA 76 07 0B 0011*      jp m,@is_neg
0B0775 C9          0012*      ret         ; hlu is positive or zero so we're done
0B0776             0013*  @is_neg:
0B0776 F5          0014*      push af     ; otherwise, save current flags for return
0B0777 CD 7D 07 0B 0015*      call neg_hlu ; negate hlu
0B077B F1          0016*      pop af      ; get back flags
0B077C C9          0017*      ret
0B077D             0018*  
0B077D             0019*  ; flip the sign of hlu
0B077D             0020*  ; inputs: hlu
0B077D             0021*  ; returns: 0-hlu, flags set appropriately for the result:
0B077D             0022*  ;         s1,z0,pv0,n1,c1 if result is negative
0B077D             0023*  ;         s0,z1,pv0,n1,c0 if result is zero
0B077D             0024*  ;         s0,z0,pv0,n1,c1 if result is positive
0B077D             0025*  ; destroys a
0B077D             0026*  neg_hlu:
0B077D D5          0027*      push de     ; save de
0B077E EB          0028*      ex de,hl    ; put hl into de
0B077F 21 00 00 00 0029*      ld hl,0     ; clear hl
0B0783 AF          0030*      xor a       ; clear carry
0B0784 ED 52       0031*      sbc hl,de   ; 0-hlu = -hlu
0B0786 D1          0032*      pop de      ; get de back
0B0787 C9          0033*      ret         ; easy peasy
0B0788             0034*  
0B0788             0035*  ;------------------------------------------------------------------------
0B0788             0036*  ; divide hlu by 2, inspired by above
0B0788             0037*  ;------------------------------------------------------------------------
0B0788             0038*  hlu_div2:
0B0788 22 62 0A 0B 0039*  	ld		(bitbuf1),hl
0B078C 21 64 0A 0B 0040*  	ld		hl,bitbuf1+2
0B0790 CB 1E       0041*  	rr		(hl)
0B0792 2B          0042*  	dec		hl
0B0793 CB 1E       0043*  	rr		(hl)
0B0795 2B          0044*  	dec		hl
0B0796 CB 1E       0045*  	rr		(hl)
0B0798 23          0046*  	inc		hl
0B0799 23          0047*  	inc		hl
0B079A 2A 62 0A 0B 0048*      ld hl,(bitbuf1)
0B079E C9          0049*      ret
0B079F             0050*  
0B079F             0051*  ; this is my little hack to divide by 16
0B079F             0052*  hlu_div16:
0B079F AF          0053*      xor a
0B07A0 29          0054*      add hl,hl
0B07A1 17          0055*      rla
0B07A2 29          0056*      add hl,hl
0B07A3 17          0057*      rla
0B07A4 29          0058*      add hl,hl
0B07A5 17          0059*      rla
0B07A6 29          0060*      add hl,hl
0B07A7 17          0061*      rla
0B07A8 22 B5 07 0B 0062*      ld (@scratch),hl
0B07AC 32 B8 07 0B 0063*      ld (@scratch+3),a
0B07B0 2A B6 07 0B 0064*      ld hl,(@scratch+1)
0B07B4 C9          0065*      ret
0B07B5             0066*  @scratch: ds 4
0B07B9             0067*  
0B07B9             0068*  ; hlu signed division by 256
0B07B9             0069*  ; returns: hlu / 256
0B07B9             0070*  ; destroys: af
0B07B9             0071*  hlu_sdiv256:
0B07B9 AF          0072*      xor a ; assume hl is positive
0B07BA 22 D0 07 0B 0073*      ld (@buffer),hl
0B07BE             0074*      sign_hlu
0B07BE 19          0001*M         add hl,de
0B07BF B7          0002*M         or a
0B07C0 ED 52       0003*M         sbc hl,de
0B07C2 F2 C7 07 0B 0075*      jp p,@hl_pos
0B07C6 3D          0076*      dec a
0B07C7             0077*  @hl_pos:
0B07C7 32 D3 07 0B 0078*      ld (@buffer+3),a
0B07CB 2A D1 07 0B 0079*      ld hl,(@buffer+1)
0B07CF C9          0080*      ret
0B07D0             0081*  @buffer: ds 4
0B07D4             0082*  
0B07D4             0083*  ; hlu 1 byte right shift, unsigned
0B07D4             0084*  ; returns: hlu / 256, fractional portion in a
0B07D4             0085*  ; destroys: af
0B07D4             0086*  hlu_udiv256:
0B07D4 AF          0087*  	xor a
0B07D5 32 E6 07 0B 0088*  	ld (@buffer+3),a
0B07D9 7D          0089*  	ld a,l ; save the fractional portion
0B07DA 22 E3 07 0B 0090*  	ld (@buffer),hl
0B07DE 2A E4 07 0B 0091*  	ld hl,(@buffer+1)
0B07E2 C9          0092*  	ret
0B07E3             0093*  @buffer: ds 4
0B07E7             0094*  
0B07E7             0095*      MACRO hlu_mul256
0B07E7             0096*          add hl,hl ; * 2
0B07E7             0097*          add hl,hl ; * 4
0B07E7             0098*          add hl,hl ; * 8
0B07E7             0099*          add hl,hl ; * 16
0B07E7             0100*          add hl,hl ; * 32
0B07E7             0101*          add hl,hl ; * 64
0B07E7             0102*          add hl,hl ; * 128
0B07E7             0103*          add hl,hl ; * 256
0B07E7             0104*      ENDMACRO
0B07E7             0105*  
0B07E7 00 00 00 00 0106*  add_bcd_arg1: db #00,#00,#00,#00
0B07EB 00 00 00 00 0107*  add_bcd_arg2: db #00,#00,#00,#00
0B07EF             0108*  
0B07EF             0109*  ; set bcd values in a scratch memory address from registers bcde
0B07EF             0110*  ; input: hl; scratch address,bcde; 8-place bcd number
0B07EF             0111*  ; destroys ; hl
0B07EF             0112*  set_bcd:
0B07EF 73          0113*      ld (hl),e
0B07F0 23          0114*      inc hl
0B07F1 72          0115*      ld (hl),d
0B07F2 23          0116*      inc hl
0B07F3 71          0117*      ld (hl),c
0B07F4 23          0118*      inc hl
0B07F5 70          0119*      ld (hl),b
0B07F6 C9          0120*      ret
0B07F7             0121*  
0B07F7             0122*  ; load bcd values from a scratch memory address to bcde
0B07F7             0123*  ; input: hl; scratch address
0B07F7             0124*  ; output: bcde; 8-place bcd number
0B07F7             0125*  ; destroys: hl
0B07F7             0126*  get_bcd:
0B07F7 5E          0127*      ld e,(hl)
0B07F8 23          0128*      inc hl
0B07F9 56          0129*      ld d,(hl)
0B07FA 23          0130*      inc hl
0B07FB 4E          0131*      ld c,(hl)
0B07FC 23          0132*      inc hl
0B07FD 46          0133*      ld b,(hl)
0B07FE C9          0134*      ret
0B07FF             0135*  
0B07FF             0136*  ; BCD addition
0B07FF             0137*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B07FF             0138*  ;       a is the number of bytes holding each number (number of places/2)
0B07FF             0139*  ; outputs: (hl) + (de) --> (hl)
0B07FF             0140*  ; destroys: a,b,de,hl
0B07FF             0141*  add_bcd:
0B07FF 47          0142*      ld b,a ; loop counter
0B0800 AF          0143*      xor a ; reset a, clear carry flag
0B0801             0144*  adcec:
0B0801 1A          0145*      ld a,(de) ; addend to acc
0B0802 8E          0146*      adc a,(hl) ; add (hl) to acc
0B0803 27          0147*      daa ; adjust result to bcd
0B0804 77          0148*      ld (hl),a ; store result
0B0805 23          0149*      inc hl ; advance memory pointers
0B0806 13          0150*      inc de
0B0807 10 F8       0151*      djnz adcec ; loop until b == 0
0B0809 C9          0152*      ret
0B080A             0153*  
0B080A             0154*  ; BCD subtraction
0B080A             0155*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B080A             0156*  ;       a is the number of bytes holding each number (number of places/2)
0B080A             0157*  ; outputs: (hl) - (de) --> (hl)
0B080A             0158*  ; destroys: a,b,de,hl
0B080A             0159*  sub_bcd:
0B080A 47          0160*      ld b,a ; loop counter
0B080B AF          0161*      xor a ; reset a,clear carry flag
0B080C             0162*  subdec:
0B080C 1A          0163*      ld a,(de) ; subtrahend to acc
0B080D 9E          0164*      sbc a,(hl) ; subtract (hl) from acc
0B080E 27          0165*      daa ; adjust result to bcd
0B080F 77          0166*      ld (hl),a ; store result
0B0810 23          0167*      inc hl ; advance memory pointers
0B0811 13          0168*      inc de
0B0812 10 F8       0169*      djnz subdec ; loop until b == 0
0B0814 C9          0170*      ret
0B0815             0171*  
0B0815             0172*  ; http://www.z80.info/pseudo-random.txt
0B0815             0173*  rand_8:
0B0815 C5          0174*      push bc
0B0816 3A 29 08 0B 0175*      ld a,(r_seed)
0B081A 4F          0176*      ld c,a
0B081B             0177*  
0B081B 0F          0178*      rrca ; multiply by 32
0B081C 0F          0179*      rrca
0B081D 0F          0180*      rrca
0B081E EE 1F       0181*      xor 0x1f
0B0820             0182*  
0B0820 81          0183*      add a,c
0B0821 DE FF       0184*      sbc a,255 ; carry
0B0823             0185*  
0B0823 32 29 08 0B 0186*      ld (r_seed),a
0B0827 C1          0187*      pop bc
0B0828 C9          0188*      ret
0B0829 50          0189*  r_seed: defb $50
0B082A             0190*  
0B082A             0191*  ; linear interpolation between two 24-bit numbers
0B082A             0192*  ; may be signed or unsigned, and treated as integers or fractional
0B082A             0193*  ; inputs: bc = start value, de = end value, a = interpolation factor
0B082A             0194*  ; outputs: hl = interpolated value, a = multiply overflow to 32 bits (0 if no overflow)
0B082A             0195*  ; destroys: af, hl, de
0B082A             0196*  interpolate24:
0B082A C5          0197*      push bc ; save start value
0B082B EB          0198*      ex de,hl ; end value to hl
0B082C B7          0199*      or a ; clear carry
0B082D ED 42       0200*      sbc hl,bc ; hl = end - start
0B082F CD 76 08 0B 0201*      call umul24x8 ; hl = (end - start) * interpolation factor
0B0833 C1          0202*      pop bc ; get back start value (was hl)
0B0834 09          0203*      add hl,bc ; hl = start + (end - start) * interpolation factor
0B0835 C9          0204*      ret
0B0836             0021   	INCLUDE	"arith24.inc"
0B0836             0001*  arith24uaf: ds 6
0B083C             0002*  arith24uhl: ds 6
0B0842             0003*  arith24ubc: ds 6
0B0848             0004*  arith24ude: ds 6
0B084E             0005*  arith24uix: ds 6
0B0854             0006*  arith24uiy: ds 6
0B085A             0007*  arith24usp: ds 6
0B0860             0008*  arith24upc: ds 6
0B0866             0009*  
0B0866             0010*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B0866             0011*  ; uses EZ80 MLT instruction for speed
0B0866             0012*  ; operation: UHL * A --> UHL
0B0866             0013*  ; destroys: AF, HL
0B0866             0014*  smul24x8:
0B0866             0015*  ; make hl positive and store sign flag
0B0866 CD 6D 07 0B 0016*  	call abs_hlu
0B086A F5          0017*  	push af
0B086B             0018*  ; do the division
0B086B CD 76 08 0B 0019*      call umul24x8 ; hl = product
0B086F             0020*  ; adjust sign of result
0B086F F1          0021*  	pop af ; sign de
0B0870 F0          0022*  	ret p ; hl was positive, nothing to do
0B0871 CD 7D 07 0B 0023*  	call neg_hlu ; result is negative
0B0875 C9          0024*  	ret
0B0876             0025*  
0B0876             0026*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0876             0027*  ; uses EZ80 MLT instruction for speed
0B0876             0028*  ; operation: UHL * A --> AUHL
0B0876             0029*  ; destroys: AF, HL
0B0876             0030*  umul24x8:
0B0876 D5          0031*  	push de ; preserve de
0B0877             0032*  ; low byte
0B0877 5D          0033*  	ld e,l
0B0878 57          0034*  	ld d,a
0B0879 ED 5C       0035*  	mlt de
0B087B 6B          0036*  	ld l,e ; product low byte
0B087C 08          0037*  	ex af,af' ; save multiplier
0B087D 7A          0038*  	ld a,d ; carry
0B087E 08          0039*  	ex af,af' ; save carry, restore multiplier
0B087F             0040*  ; high byte
0B087F 5C          0041*  	ld e,h
0B0880 57          0042*  	ld d,a
0B0881 ED 5C       0043*  	mlt de
0B0883 08          0044*  	ex af,af' ; save multiplier, restore carry
0B0884 83          0045*  	add a,e ; add carry
0B0885 67          0046*  	ld h,a ; product middle byte
0B0886 7A          0047*  	ld a,d ; carry
0B0887 08          0048*  	ex af,af' ; save carry, restore multiplier
0B0888             0049*  ; upper byte
0B0888 E5          0050*  	push hl
0B0889 33          0051*  	inc sp
0B088A D1          0052*  	pop de ; d = hlu
0B088B 3B          0053*  	dec sp
0B088C 5F          0054*  	ld e,a
0B088D ED 5C       0055*  	mlt de
0B088F 08          0056*  	ex af,af' ; restore carry
0B0890 8B          0057*  	adc a,e ; add carry
0B0891 22 A2 08 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0895 32 A4 08 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B0899 2A A2 08 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B089D             0061*  ; highest byte
0B089D 3E 00       0062*  	ld a,0 ; preserve carry flag
0B089F 8A          0063*  	adc a,d ; product highest byte
0B08A0 D1          0064*  	pop de ; restore de
0B08A1 C9          0065*  	ret
0B08A2             0066*  @scratch: ds 3
0B08A5             0067*  
0B08A5             0068*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B08A5             0069*  ; operation: UHL * UDE --> umul24x24out
0B08A5             0070*  umul24x24:
0B08A5 FD 21 FD 08 0071*  	ld iy,umul24x24out ; point to output buffer
       0B          
0B08AA C5          0072*  	push bc
0B08AB 01 00 00 00 0073*  	ld bc,0
0B08AF FD 0F 00    0074*  	ld (iy),bc
0B08B2 FD 0F 03    0075*  	ld (iy+3),bc
0B08B5 C1          0076*  	pop bc
0B08B6             0077*  
0B08B6             0078*  ; STEP 1: UHL * E
0B08B6 7B          0079*  	ld a,e
0B08B7 E5          0080*  	push hl
0B08B8 CD 76 08 0B 0081*  	call umul24x8
0B08BC FD 2F 00    0082*  	ld (iy+0),hl
0B08BF FD 77 03    0083*  	ld (iy+3),a
0B08C2             0084*  
0B08C2             0085*  ; STEP 2: UHL * D
0B08C2 E1          0086*  	pop hl
0B08C3 E5          0087*  	push hl
0B08C4 7A          0088*  	ld a,d
0B08C5 CD 76 08 0B 0089*  	call umul24x8
0B08C9 CD D6 08 0B 0090*  	call @accumulate
0B08CD             0091*  
0B08CD             0092*  ; STEP 3: UHL * DEU
0B08CD E1          0093*  	pop hl
0B08CE D5          0094*  	push de
0B08CF 33          0095*  	inc sp
0B08D0 F1          0096*  	pop af
0B08D1 3B          0097*  	dec sp
0B08D2 CD 76 08 0B 0098*  	call umul24x8
0B08D6             0099*  
0B08D6             0100*  @accumulate:
0B08D6 FD 23       0101*  	inc iy
0B08D8             0102*  ; highest byte of product to carry
0B08D8 FD 77 03    0103*  	ld (iy+3),a
0B08DB             0104*  ; low byte of product
0B08DB 7D          0105*  	ld a,l
0B08DC FD 86 00    0106*  	add a,(iy+0)
0B08DF FD 77 00    0107*  	ld (iy+0),a
0B08E2             0108*  ; high byte of product
0B08E2 7C          0109*  	ld a,h
0B08E3 FD 8E 01    0110*  	adc a,(iy+1)
0B08E6 FD 77 01    0111*  	ld (iy+1),a
0B08E9             0112*  ; uppper byte of product
0B08E9 E5          0113*  	push hl
0B08EA 33          0114*  	inc sp
0B08EB E1          0115*  	pop hl
0B08EC 3B          0116*  	dec sp
0B08ED 7C          0117*  	ld a,h
0B08EE FD 8E 02    0118*  	adc a,(iy+2)
0B08F1 FD 77 02    0119*  	ld (iy+2),a
0B08F4             0120*  ; carry
0B08F4 3E 00       0121*  	ld a,0 ; preserve flags
0B08F6 FD 8E 03    0122*  	adc a,(iy+3)
0B08F9 FD 77 03    0123*  	ld (iy+3),a
0B08FC C9          0124*  	ret
0B08FD             0125*  umul24x24out: ds 6 ; output buffer
0B0903             0126*  
0B0903             0127*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B0903             0128*  umul168:
0B0903 CD A5 08 0B 0129*  	call umul24x24
0B0907 FD 27 FF    0130*  	ld hl,(iy-1)
0B090A C9          0131*  	ret
0B090B             0132*  
0B090B             0133*  ; smul168:	UH.L * UD.E --> UH.L (signed)
0B090B             0134*  smul168:
0B090B             0135*  ; make everything positive and store sign flags
0B090B CD 6D 07 0B 0136*  	call abs_hlu
0B090F F5          0137*  	push af
0B0910 EB          0138*  	ex de,hl
0B0911 CD 6D 07 0B 0139*  	call abs_hlu
0B0915 EB          0140*  	ex de,hl
0B0916 F5          0141*  	push af
0B0917             0142*  ; do the division
0B0917 CD 03 09 0B 0143*      call umul168 ; hl = product
0B091B             0144*  ; adjust sign of result
0B091B F1          0145*  	pop af ; sign de
0B091C FA 27 09 0B 0146*  	jp m,@de_neg
0B0920 F1          0147*  	pop af ; sign hl
0B0921 F0          0148*  	ret p ; both positive, nothing to do
0B0922             0149*  @hl_neg:
0B0922 CD 7D 07 0B 0150*      call neg_hlu ; de pos, hl neg, result is negative
0B0926 C9          0151*      ret
0B0927             0152*  @de_neg:
0B0927 F1          0153*  	pop af
0B0928 F8          0154*  	ret m ; both negative, nothing to do
0B0929 CD 7D 07 0B 0155*  	call neg_hlu ; result is negative
0B092D C9          0156*  	ret
0B092E             0157*  
0B092E             0158*  ;------------------------------------------------------------------------
0B092E             0159*  ;  arith24.inc
0B092E             0160*  ;  24-bit ez80 arithmetic routines
0B092E             0161*  ;  Copyright (c) Shawn Sijnstra 2024
0B092E             0162*  ;  MIT license
0B092E             0163*  ;
0B092E             0164*  ;  This library was created as a tool to help make ez80
0B092E             0165*  ;  24-bit native assembly routines for simple mathematical problems
0B092E             0166*  ;  more widely available.
0B092E             0167*  ;
0B092E             0168*  ;------------------------------------------------------------------------
0B092E             0169*  
0B092E             0170*  ;------------------------------------------------------------------------
0B092E             0171*  ; umul24:	HL = HL*DE (unsigned)
0B092E             0172*  ; Preserves AF, BC, DE
0B092E             0173*  ; Uses a fast multiply routine.
0B092E             0174*  ;------------------------------------------------------------------------
0B092E             0175*  umul24:
0B092E D5          0176*  	push	DE
0B092F C5          0177*  	push	BC
0B0930 F5          0178*  	push	AF
0B0931 E5          0179*  	push	HL
0B0932 C1          0180*  	pop		BC
0B0933 3E 18       0181*      ld	 	a, 24 ; No. of bits to process
0B0935 21 00 00 00 0182*      ld	 	hl, 0 ; Result
0B0939             0183*  umul24_lp:
0B0939 29          0184*  	add	hl,hl
0B093A EB          0185*  	ex	de,hl
0B093B 29          0186*  	add	hl,hl
0B093C EB          0187*  	ex	de,hl
0B093D 30 01       0188*  	jr	nc,umul24_nc
0B093F 09          0189*  	add	hl,bc
0B0940             0190*  umul24_nc:
0B0940 3D          0191*  	dec	a
0B0941 20 F6       0192*  	jr	nz,umul24_lp
0B0943 F1          0193*  	pop	af
0B0944 C1          0194*  	pop	bc
0B0945 D1          0195*  	pop	de
0B0946 C9          0196*  	ret
0B0947             0197*  
0B0947             0198*  ;------------------------------------------------------------------------
0B0947             0199*  ; udiv24
0B0947             0200*  ; Unsigned 24-bit division
0B0947             0201*  ; HLU / DEU --> DEU rem HLU
0B0947             0202*  ; Uses AF BC DE HL
0B0947             0203*  ; Uses Restoring Division algorithm
0B0947             0204*  ;------------------------------------------------------------------------
0B0947             0205*  
0B0947             0206*  udiv24:
0B0947 E5          0207*  	push	hl
0B0948 C1          0208*  	pop		bc	;move dividend to BCU
0B0949 21 00 00 00 0209*  	ld		hl,0	;result
0B094D A7          0210*  	and		a
0B094E ED 52       0211*  	sbc		hl,de	;test for div by 0
0B0950 C8          0212*  	ret		z		;it's zero, carry flag is clear
0B0951 19          0213*  	add		hl,de	;HL is 0 again
0B0952 3E 18       0214*  	ld		a,24	;number of loops through.
0B0954             0215*  udiv1:
0B0954 C5          0216*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0955 E3          0217*  	ex		(sp),hl
0B0956 37          0218*  	scf
0B0957 ED 6A       0219*  	adc	hl,hl
0B0959 E3          0220*  	ex	(sp),hl
0B095A C1          0221*  	pop	bc		;we now have bc = (bc * 2) + 1
0B095B             0222*  
0B095B ED 6A       0223*  	adc	hl,hl
0B095D A7          0224*  	and	a		;is this the bug
0B095E ED 52       0225*  	sbc	hl,de
0B0960 30 02       0226*  	jr	nc,udiv2
0B0962 19          0227*  	add	hl,de
0B0963             0228*  ;	dec	c
0B0963 0B          0229*  	dec	bc
0B0964             0230*  udiv2:
0B0964 3D          0231*  	dec	a
0B0965 20 ED       0232*  	jr	nz,udiv1
0B0967 37          0233*  	scf		;flag used for div0 error
0B0968 C5          0234*  	push	bc
0B0969 D1          0235*  	pop		de	;remainder
0B096A C9          0236*  	ret
0B096B             0237*  
0B096B             0238*  
0B096B             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B096B             0240*  ; perform unsigned division of 16.8 fixed place values
0B096B             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B096B             0242*  udiv168:
0B096B             0243*  	; call udiv24
0B096B             0244*  	; ret
0B096B             0245*  ; back up divisor
0B096B D5          0246*      push de
0B096C             0247*  ; get the 16-bit integer part of the quotient
0B096C CD 47 09 0B 0248*      call udiv24 ; de = quotient, hl = remainder
0B0970             0249*  ; load quotient to upper three bytes of output
0B0970 ED 53 A2 09 0250*      ld (div168_out+1),de
       0B          
0B0975             0251*  @div256:
0B0975             0252*  ; multiply remainder by 256
0B0975             0253*  	hlu_mul256
0B0975 29          0001*M         add hl,hl ; * 2
0B0976 29          0002*M         add hl,hl ; * 4
0B0977 29          0003*M         add hl,hl ; * 8
0B0978 29          0004*M         add hl,hl ; * 16
0B0979 29          0005*M         add hl,hl ; * 32
0B097A 29          0006*M         add hl,hl ; * 64
0B097B 29          0007*M         add hl,hl ; * 128
0B097C 29          0008*M         add hl,hl ; * 256
0B097D             0254*  ; skip fractional computation if remainder is zero
0B097D             0255*      sign_hlu
0B097D 19          0001*M         add hl,de
0B097E B7          0002*M         or a
0B097F ED 52       0003*M         sbc hl,de
0B0981 20 03       0256*      jr nz,@div_frac
0B0983 AF          0257*      xor a
0B0984 18 06       0258*      jr @write_frac
0B0986             0259*  ; now divide the shifted remainder by the divisor
0B0986             0260*  @div_frac:
0B0986 D1          0261*  	pop de ; get back divisor
0B0987 CD 47 09 0B 0262*      call udiv24 ; de = quotient, hl = remainder
0B098B             0263*  ; load low byte of quotient to low byte of output
0B098B 7B          0264*      ld a,e
0B098C             0265*  @write_frac:
0B098C D1          0266*  	pop de ; dummy pop to balance stack
0B098D 32 A1 09 0B 0267*      ld (div168_out),a
0B0991             0268*  ; load de with return value
0B0991 ED 5B A1 09 0269*      ld de,(div168_out)
       0B          
0B0996             0270*  ; load a with any overflow
0B0996 3A A4 09 0B 0271*      ld a,(div168_out+3)
0B099A C9          0272*      ret ; ud.e is the 16.8 result
0B099B             0273*  @ude: ds 6
0B09A1             0274*  div168_out: ds 4 ; the extra byte is for overflow
0B09A5             0275*  
0B09A5             0276*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B09A5             0277*  ; perform signed division of 16.8 fixed place values
0B09A5             0278*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B09A5             0279*  sdiv168:
0B09A5             0280*  	; call udiv168
0B09A5             0281*  	; ret
0B09A5             0282*  ; make everything positive and store sign flags
0B09A5 CD 6D 07 0B 0283*  	call abs_hlu
0B09A9 F5          0284*  	push af
0B09AA EB          0285*  	ex de,hl
0B09AB CD 6D 07 0B 0286*  	call abs_hlu
0B09AF EB          0287*  	ex de,hl
0B09B0 F5          0288*  	push af
0B09B1             0289*  ; do the division
0B09B1 CD 6B 09 0B 0290*      call udiv168 ; de = quotient, hl = remainder
0B09B5             0291*  ; adjust sign of result
0B09B5 F1          0292*  	pop af ; sign de
0B09B6 FA C3 09 0B 0293*  	jp m,@de_neg
0B09BA F1          0294*  	pop af ; sign hl
0B09BB F0          0295*  	ret p ; both positive, nothing to do
0B09BC             0296*  @hl_neg:
0B09BC EB          0297*      ex de,hl ; hl = quotient, de = remainder
0B09BD CD 7D 07 0B 0298*      call neg_hlu ; de pos, hl neg, result is negative
0B09C1 EB          0299*      ex de,hl ; de = negated quotient, hl = remainder
0B09C2 C9          0300*      ret
0B09C3             0301*  @de_neg:
0B09C3 F1          0302*  	pop af
0B09C4 F8          0303*  	ret m ; both negative, nothing to do
0B09C5 EB          0304*      ex de,hl ; hl = quotient, de = remainder
0B09C6 CD 7D 07 0B 0305*  	call neg_hlu ; result is negative
0B09CA EB          0306*      ex de,hl ; de = negated quotient, hl = remainder
0B09CB C9          0307*  	ret
0B09CC             0308*  
0B09CC             0309*  ;------------------------------------------------------------------------
0B09CC             0310*  ; neg24
0B09CC             0311*  ; Returns: HLU = 0-HLU
0B09CC             0312*  ; preserves all other registers
0B09CC             0313*  ;------------------------------------------------------------------------
0B09CC             0314*  neg24:
0B09CC D5          0315*  	push	de
0B09CD EB          0316*  	ex		de,hl
0B09CE 21 00 00 00 0317*  	ld		hl,0
0B09D2 B7          0318*  	or		a
0B09D3 ED 52       0319*  	sbc		hl,de
0B09D5 D1          0320*  	pop		de
0B09D6 C9          0321*  	ret
0B09D7             0322*  
0B09D7             0323*  ;------------------------------------------------------------------------
0B09D7             0324*  ; or_hlu_deu: 24 bit bitwise OR
0B09D7             0325*  ; Returns: hlu = hlu OR deu
0B09D7             0326*  ; preserves all other registers
0B09D7             0327*  ;------------------------------------------------------------------------
0B09D7             0328*  or_hlu_deu:
0B09D7 22 62 0A 0B 0329*  	ld	(bitbuf1),hl
0B09DB ED 53 65 0A 0330*  	ld	(bitbuf2),de
       0B          
0B09E0 D5          0331*  	push	de	;preserve DEU
0B09E1 C5          0332*  	push	bc	;preserve BCU
0B09E2 06 03       0333*  	ld		b,3
0B09E4 21 62 0A 0B 0334*  	ld	hl,bitbuf1
0B09E8 11 62 0A 0B 0335*  	ld	de,bitbuf1
0B09EC             0336*  orloop_24:
0B09EC 1A          0337*  	ld	a,(de)
0B09ED B6          0338*  	or	(hl)
0B09EE 12          0339*  	ld	(de),a
0B09EF 13          0340*  	inc	de
0B09F0 23          0341*  	inc	hl
0B09F1 10 F9       0342*  	djnz	orloop_24
0B09F3 2A 65 0A 0B 0343*  	ld	hl,(bitbuf2)
0B09F7 C1          0344*  	pop		bc	;restore BC
0B09F8 D1          0345*  	pop		de	;restore DE
0B09F9             0346*  
0B09F9             0347*  ;------------------------------------------------------------------------
0B09F9             0348*  ; and_hlu_deu: 24 bit bitwise AND
0B09F9             0349*  ; Returns: hlu = hlu AND deu
0B09F9             0350*  ; preserves all other registers
0B09F9             0351*  ;------------------------------------------------------------------------
0B09F9             0352*  and_hlu_deu:
0B09F9 22 62 0A 0B 0353*  	ld	(bitbuf1),hl
0B09FD ED 53 65 0A 0354*  	ld	(bitbuf2),de
       0B          
0B0A02 D5          0355*  	push	de	;preserve DEU
0B0A03 C5          0356*  	push	bc	;preserve BCU
0B0A04 06 03       0357*  	ld		b,3
0B0A06 21 62 0A 0B 0358*  	ld	hl,bitbuf1
0B0A0A 11 62 0A 0B 0359*  	ld	de,bitbuf1
0B0A0E             0360*  andloop_24:
0B0A0E 1A          0361*  	ld	a,(de)
0B0A0F A6          0362*  	and	(hl)
0B0A10 12          0363*  	ld	(de),a
0B0A11 13          0364*  	inc	de
0B0A12 23          0365*  	inc	hl
0B0A13 10 F9       0366*  	djnz	andloop_24
0B0A15 2A 65 0A 0B 0367*  	ld	hl,(bitbuf2)
0B0A19 C1          0368*  	pop		bc	;restore BC
0B0A1A D1          0369*  	pop		de	;restore DE
0B0A1B             0370*  
0B0A1B             0371*  ;------------------------------------------------------------------------
0B0A1B             0372*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0A1B             0373*  ; Returns: hlu = hlu XOR deu
0B0A1B             0374*  ; preserves all other registers
0B0A1B             0375*  ;------------------------------------------------------------------------
0B0A1B             0376*  xor_hlu_deu:
0B0A1B 22 62 0A 0B 0377*  	ld	(bitbuf1),hl
0B0A1F ED 53 65 0A 0378*  	ld	(bitbuf2),de
       0B          
0B0A24 D5          0379*  	push	de	;preserve DEU
0B0A25 C5          0380*  	push	bc	;preserve BCU
0B0A26 06 03       0381*  	ld		b,3
0B0A28 21 62 0A 0B 0382*  	ld	hl,bitbuf1
0B0A2C 11 62 0A 0B 0383*  	ld	de,bitbuf1
0B0A30             0384*  xorloop_24:
0B0A30 1A          0385*  	ld	a,(de)
0B0A31 AE          0386*  	xor	(hl)
0B0A32 12          0387*  	ld	(de),a
0B0A33 13          0388*  	inc	de
0B0A34 23          0389*  	inc	hl
0B0A35 10 F9       0390*  	djnz	xorloop_24
0B0A37 2A 65 0A 0B 0391*  	ld	hl,(bitbuf2)
0B0A3B C1          0392*  	pop		bc	;restore BC
0B0A3C D1          0393*  	pop		de	;restore DE
0B0A3D             0394*  
0B0A3D             0395*  ;------------------------------------------------------------------------
0B0A3D             0396*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B0A3D             0397*  ; Returns: hlu = hlu << deu
0B0A3D             0398*  ;		   de = 0
0B0A3D             0399*  ; NOTE: only considers deu up to 16 bits.
0B0A3D             0400*  ; preserves all other registers
0B0A3D             0401*  ;------------------------------------------------------------------------
0B0A3D             0402*  shl_hlu:
0B0A3D 7A          0403*  	ld		a,d		;up to 16 bit.
0B0A3E B3          0404*  	or		e
0B0A3F C8          0405*  	ret		z		;we're done
0B0A40 29          0406*  	add		hl,hl	;shift HLU left
0B0A41 1B          0407*  	dec		de
0B0A42 18 F9       0408*  	jr		shl_hlu
0B0A44             0409*  
0B0A44             0410*  ;------------------------------------------------------------------------
0B0A44             0411*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B0A44             0412*  ; Returns: hlu = hlu >> deu
0B0A44             0413*  ;		   de = 0
0B0A44             0414*  ; NOTE: only considers deu up to 16 bits.
0B0A44             0415*  ; preserves all other registers
0B0A44             0416*  ;------------------------------------------------------------------------
0B0A44             0417*  shr_hlu:
0B0A44 22 62 0A 0B 0418*  	ld		(bitbuf1),hl
0B0A48 21 64 0A 0B 0419*  	ld		hl,bitbuf1+2
0B0A4C             0420*  shr_loop:
0B0A4C 7A          0421*  	ld		a,d		;up to 16 bit.
0B0A4D B3          0422*  	or		e
0B0A4E 28 0D       0423*  	jr		z,shr_done		;we're done
0B0A50             0424*  ;carry is clear from or instruction
0B0A50 CB 1E       0425*  	rr		(hl)
0B0A52 2B          0426*  	dec		hl
0B0A53 CB 1E       0427*  	rr		(hl)
0B0A55 2B          0428*  	dec		hl
0B0A56 CB 1E       0429*  	rr		(hl)
0B0A58 23          0430*  	inc		hl
0B0A59 23          0431*  	inc		hl
0B0A5A 1B          0432*  	dec		de
0B0A5B 18 EF       0433*  	jr		shr_loop
0B0A5D             0434*  shr_done:
0B0A5D 2A 62 0A 0B 0435*  	ld		hl,(bitbuf1)	;collect result
0B0A61 C9          0436*  	ret
0B0A62             0437*  
0B0A62             0438*  ;------------------------------------------------------------------------
0B0A62             0439*  ; Scratch area for calculations
0B0A62             0440*  ;------------------------------------------------------------------------
0B0A62 00 00 00    0441*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B0A65 00 00 00    0442*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0A68             0443*  
0B0A68             0444*  ; ========== FROM maths24.inc ==========
0B0A68             0445*  
0B0A68             0446*  ; Expects  ADL mode
0B0A68             0447*  ; Inputs:  UH.L
0B0A68             0448*  ; Outputs: UH.L is the 16.8 square root
0B0A68             0449*  ;          UD.E is the difference inputHL-DE^2
0B0A68             0450*  ;          c flag reset
0B0A68             0451*  sqrt168:
0B0A68 CD 72 0A 0B 0452*      call sqrt24
0B0A6C EB          0453*      ex de,hl
0B0A6D 29          0454*      add hl,hl
0B0A6E 29          0455*      add hl,hl
0B0A6F 29          0456*      add hl,hl
0B0A70 29          0457*      add hl,hl
0B0A71 C9          0458*      ret
0B0A72             0459*  
0B0A72             0460*  ; Expects  ADL mode
0B0A72             0461*  ; Inputs:  HL
0B0A72             0462*  ; Outputs: DE is the integer square root
0B0A72             0463*  ;          HL is the difference inputHL-DE^2
0B0A72             0464*  ;          c flag reset
0B0A72             0465*  sqrt24:
0B0A72 AF          0466*      xor a
0B0A73 45          0467*      ld b,l
0B0A74 C5          0468*      push bc
0B0A75 47          0469*      ld b,a
0B0A76 57          0470*      ld d,a
0B0A77 4F          0471*      ld c,a
0B0A78 6F          0472*      ld l,a
0B0A79 5F          0473*      ld e,a
0B0A7A             0474*  
0B0A7A             0475*      ;Iteration 1
0B0A7A 29          0476*      add hl,hl
0B0A7B CB 11       0477*      rl c
0B0A7D 29          0478*      add hl,hl
0B0A7E CB 11       0479*      rl c
0B0A80 91          0480*      sub c
0B0A81 30 04       0481*      jr nc,$+6
0B0A83 1C          0482*      inc e
0B0A84 1C          0483*      inc e
0B0A85 2F          0484*      cpl
0B0A86 4F          0485*      ld c,a
0B0A87             0486*  
0B0A87             0487*      ;Iteration 2
0B0A87 29          0488*      add hl,hl
0B0A88 CB 11       0489*      rl c
0B0A8A 29          0490*      add hl,hl
0B0A8B CB 11       0491*      rl c
0B0A8D CB 13       0492*      rl e
0B0A8F 7B          0493*      ld a,e
0B0A90 91          0494*      sub c
0B0A91 30 04       0495*      jr nc,$+6
0B0A93 1C          0496*      inc e
0B0A94 1C          0497*      inc e
0B0A95 2F          0498*      cpl
0B0A96 4F          0499*      ld c,a
0B0A97             0500*  
0B0A97             0501*      ;Iteration 3
0B0A97 29          0502*      add hl,hl
0B0A98 CB 11       0503*      rl c
0B0A9A 29          0504*      add hl,hl
0B0A9B CB 11       0505*      rl c
0B0A9D CB 13       0506*      rl e
0B0A9F 7B          0507*      ld a,e
0B0AA0 91          0508*      sub c
0B0AA1 30 04       0509*      jr nc,$+6
0B0AA3 1C          0510*      inc e
0B0AA4 1C          0511*      inc e
0B0AA5 2F          0512*      cpl
0B0AA6 4F          0513*      ld c,a
0B0AA7             0514*  
0B0AA7             0515*      ;Iteration 4
0B0AA7 29          0516*      add hl,hl
0B0AA8 CB 11       0517*      rl c
0B0AAA 29          0518*      add hl,hl
0B0AAB CB 11       0519*      rl c
0B0AAD CB 13       0520*      rl e
0B0AAF 7B          0521*      ld a,e
0B0AB0 91          0522*      sub c
0B0AB1 30 04       0523*      jr nc,$+6
0B0AB3 1C          0524*      inc e
0B0AB4 1C          0525*      inc e
0B0AB5 2F          0526*      cpl
0B0AB6 4F          0527*      ld c,a
0B0AB7             0528*  
0B0AB7             0529*      ;Iteration 5
0B0AB7 29          0530*      add hl,hl
0B0AB8 CB 11       0531*      rl c
0B0ABA 29          0532*      add hl,hl
0B0ABB CB 11       0533*      rl c
0B0ABD CB 13       0534*      rl e
0B0ABF 7B          0535*      ld a,e
0B0AC0 91          0536*      sub c
0B0AC1 30 04       0537*      jr nc,$+6
0B0AC3 1C          0538*      inc e
0B0AC4 1C          0539*      inc e
0B0AC5 2F          0540*      cpl
0B0AC6 4F          0541*      ld c,a
0B0AC7             0542*  
0B0AC7             0543*      ;Iteration 6
0B0AC7 29          0544*      add hl,hl
0B0AC8 CB 11       0545*      rl c
0B0ACA 29          0546*      add hl,hl
0B0ACB CB 11       0547*      rl c
0B0ACD CB 13       0548*      rl e
0B0ACF 7B          0549*      ld a,e
0B0AD0 91          0550*      sub c
0B0AD1 30 04       0551*      jr nc,$+6
0B0AD3 1C          0552*      inc e
0B0AD4 1C          0553*      inc e
0B0AD5 2F          0554*      cpl
0B0AD6 4F          0555*      ld c,a
0B0AD7             0556*  
0B0AD7             0557*      ;Iteration 7
0B0AD7 29          0558*      add hl,hl
0B0AD8 CB 11       0559*      rl c
0B0ADA 29          0560*      add hl,hl
0B0ADB CB 11       0561*      rl c
0B0ADD CB 10       0562*      rl b
0B0ADF EB          0563*      ex de,hl
0B0AE0 29          0564*      add hl,hl
0B0AE1 E5          0565*      push hl
0B0AE2 ED 42       0566*      sbc hl,bc
0B0AE4 30 06       0567*      jr nc,$+8
0B0AE6 7C          0568*      ld a,h
0B0AE7 2F          0569*      cpl
0B0AE8 47          0570*      ld b,a
0B0AE9 7D          0571*      ld a,l
0B0AEA 2F          0572*      cpl
0B0AEB 4F          0573*      ld c,a
0B0AEC E1          0574*      pop hl
0B0AED 30 02       0575*      jr nc,$+4
0B0AEF 23          0576*      inc hl
0B0AF0 23          0577*      inc hl
0B0AF1 EB          0578*      ex de,hl
0B0AF2             0579*  
0B0AF2             0580*      ;Iteration 8
0B0AF2 29          0581*      add hl,hl
0B0AF3 69          0582*      ld l,c
0B0AF4 60          0583*      ld h,b
0B0AF5 ED 6A       0584*      adc hl,hl
0B0AF7 ED 6A       0585*      adc hl,hl
0B0AF9 EB          0586*      ex de,hl
0B0AFA 29          0587*      add hl,hl
0B0AFB ED 52       0588*      sbc hl,de
0B0AFD 19          0589*      add hl,de
0B0AFE EB          0590*      ex de,hl
0B0AFF 30 04       0591*      jr nc,$+6
0B0B01 ED 52       0592*      sbc hl,de
0B0B03 13          0593*      inc de
0B0B04 13          0594*      inc de
0B0B05             0595*  
0B0B05             0596*      ;Iteration 9
0B0B05 F1          0597*      pop af
0B0B06 17          0598*      rla
0B0B07 ED 6A       0599*      adc hl,hl
0B0B09 17          0600*      rla
0B0B0A ED 6A       0601*      adc hl,hl
0B0B0C EB          0602*      ex de,hl
0B0B0D 29          0603*      add hl,hl
0B0B0E ED 52       0604*      sbc hl,de
0B0B10 19          0605*      add hl,de
0B0B11 EB          0606*      ex de,hl
0B0B12 30 04       0607*      jr nc,$+6
0B0B14 ED 52       0608*      sbc hl,de
0B0B16 13          0609*      inc de
0B0B17 13          0610*      inc de
0B0B18             0611*  
0B0B18             0612*      ;Iteration 10
0B0B18 17          0613*      rla
0B0B19 ED 6A       0614*      adc hl,hl
0B0B1B 17          0615*      rla
0B0B1C ED 6A       0616*      adc hl,hl
0B0B1E EB          0617*      ex de,hl
0B0B1F 29          0618*      add hl,hl
0B0B20 ED 52       0619*      sbc hl,de
0B0B22 19          0620*      add hl,de
0B0B23 EB          0621*      ex de,hl
0B0B24 30 04       0622*      jr nc,$+6
0B0B26 ED 52       0623*      sbc hl,de
0B0B28 13          0624*      inc de
0B0B29 13          0625*      inc de
0B0B2A             0626*  
0B0B2A             0627*      ;Iteration 11
0B0B2A 17          0628*      rla
0B0B2B ED 6A       0629*      adc hl,hl
0B0B2D 17          0630*      rla
0B0B2E ED 6A       0631*      adc hl,hl
0B0B30 EB          0632*      ex de,hl
0B0B31 29          0633*      add hl,hl
0B0B32 ED 52       0634*      sbc hl,de
0B0B34 19          0635*      add hl,de
0B0B35 EB          0636*      ex de,hl
0B0B36 30 04       0637*      jr nc,$+6
0B0B38 ED 52       0638*      sbc hl,de
0B0B3A 13          0639*      inc de
0B0B3B 13          0640*      inc de
0B0B3C             0641*  
0B0B3C             0642*      ;Iteration 11
0B0B3C 17          0643*      rla
0B0B3D ED 6A       0644*      adc hl,hl
0B0B3F 17          0645*      rla
0B0B40 ED 6A       0646*      adc hl,hl
0B0B42 EB          0647*      ex de,hl
0B0B43 29          0648*      add hl,hl
0B0B44 ED 52       0649*      sbc hl,de
0B0B46 19          0650*      add hl,de
0B0B47 EB          0651*      ex de,hl
0B0B48 30 04       0652*      jr nc,$+6
0B0B4A ED 52       0653*      sbc hl,de
0B0B4C 13          0654*      inc de
0B0B4D 13          0655*      inc de
0B0B4E             0656*  
0B0B4E CB 1A       0657*      rr d
0B0B50 CB 1B       0658*      rr e
0B0B52 C9          0659*      ret
0B0B53             0022       include "trig24.inc"
0B0B53             0001*  
0B0B53             0002*  ; convert unsigned angles from a 360 to 255 degree circle
0B0B53             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0B53             0004*  ; outputs: uh.l is the angle255 in 16.8 fixed format
0B0B53             0005*  ; destroys: TODO
0B0B53             0006*  ; note: even though the inputs and outputs are 16.8 fixed format
0B0B53             0007*  ;       precision is effectively limited to 8.8 fixed format
0B0B53             0008*  deg_360_to_255:
0B0B53             0009*  	; call printNewLine
0B0B53             0010*  	; call dumpRegistersHex
0B0B53             0011*  ; clear scratch buffer
0B0B53 11 00 00 00 0012*  	ld de,0
0B0B57 ED 53 83 0B 0013*  	ld (@scratch),de
       0B          
0B0B5C             0014*  ; divide uh.l by 360
0B0B5C 11 68 01 00 0015*  	ld de,360
0B0B60             0016*  ; get integer portion
0B0B60 CD 47 09 0B 0017*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B0B64 ED 53 8A 0B 0018*  	ld (@output+1),de ; shift result up one byte
       0B          
0B0B69             0019*  ; get fractional portion
0B0B69 22 84 0B 0B 0020*  	ld (@scratch+1),hl ; shift remainder up one byte
0B0B6D 2A 83 0B 0B 0021*  	ld hl,(@scratch)
0B0B71 11 68 01 00 0022*  	ld de,360
0B0B75 CD 47 09 0B 0023*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B0B79 7B          0024*  	ld a,e ; lowest byte is all we need
0B0B7A 32 89 0B 0B 0025*  	ld (@output),a
0B0B7E             0026*  ; we want the low 3 bytes for 16.8 output
0B0B7E 2A 89 0B 0B 0027*  	ld hl,(@output)
0B0B82             0028*  	; call dumpRegistersHex
0B0B82 C9          0029*  	ret
0B0B83             0030*  @scratch: ds 6 ; scratch buffer for shifting bytes
0B0B89             0031*  @output: ds 6 ; scratch buffer to accumulate output
0B0B8F             0032*  
0B0B8F             0033*  ; fixed 16.8 routine
0B0B8F             0034*  ; cos(uh.l) --> uh.l
0B0B8F             0035*  ; destroys: de
0B0B8F             0036*  cos168:
0B0B8F             0037*  ; for cos we simply increment the angle by 90 degrees
0B0B8F             0038*  ; or 0x004000 in 16.8 degrees256
0B0B8F             0039*  ; which makes it a sin problem
0B0B8F 11 00 40 00 0040*      ld de,0x004000
0B0B93 19          0041*      add hl,de ; modulo 256 happens below
0B0B94             0042*  ; fall through to sin168
0B0B94             0043*  
0B0B94             0044*  ; ---------------------
0B0B94             0045*  ; fixed 16.8 routine
0B0B94             0046*  ; sin(uh.l) --> uh.l
0B0B94             0047*  ; destroys: de
0B0B94             0048*  sin168:
0B0B94 CD 88 02 0B 0049*  	call printNewLine
0B0B98             0050*  	; call dumpRegistersHex
0B0B98             0051*  ; get the lookup value for the integer portion of the angle
0B0B98 7D          0052*  	ld a,l ; save fractional part of the angle
0B0B99 2E 03       0053*  	ld l,3 ; multiply by 3 to get our lookup index
0B0B9B ED 6C       0054*  	mlt hl ; gosh that is handy
0B0B9D 11 11 0D 0B 0055*      ld de,sin_lut_168 ; grab the lut address
0B0BA1 19          0056*      add hl,de ; bump hl by the index
0B0BA2 E5          0057*  	push hl
0B0BA3 D1          0058*  	pop de ; de also has the lut address
0B0BA4 ED 27       0059*      ld hl,(hl) ; hl = sin(int(angle))
0B0BA6             0060*  
0B0BA6             0061*  ; interpolate the fractional part of the angle
0B0BA6 B7          0062*  	or a  ; check for zero and clear carry
0B0BA7 C8          0063*  	ret z ; return if no fractional part
0B0BA8 EB          0064*  	ex de,hl ; hl = lut address, de = sin(int(angle))
0B0BA9 23          0065*  	inc hl
0B0BAA 23          0066*  	inc hl
0B0BAB 23          0067*  	inc hl ; hl = lut address of next value in table
0B0BAC             0068*  	; call dumpRegistersHex
0B0BAC ED 27       0069*  	ld hl,(hl) ; hl = sin(int(angle+1))
0B0BAE CD 5E 05 0B 0070*  	call dumpRegistersHex
0B0BB2 ED 52       0071*  	sbc hl,de ; hl = sin(int(angle+1)0 - sin(int(angle)), de = sin(int(angle))
0B0BB4 CD 5E 05 0B 0072*  	call dumpRegistersHex
0B0BB8 CD 66 08 0B 0073*  	call smul24x8 ; hl = interpolation factor * (sin(int(angle+1)) - sin(int(angle))) * 256
0B0BBC CD B9 07 0B 0074*  	call hlu_sdiv256 ; hl = interpolation factor * (sin(int(angle+1)) - sin(int(angle)))
0B0BC0 CD 5E 05 0B 0075*  	call dumpRegistersHex
0B0BC4 19          0076*  	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle)))
0B0BC5 CD 5E 05 0B 0077*  	call dumpRegistersHex
0B0BC9 C9          0078*      ret ; and out
0B0BCA             0079*  
0B0BCA             0080*  ; 16.8 fixed inputs / outputs
0B0BCA             0081*  ; takes: uh.l as angle in degrees 256
0B0BCA             0082*  ;        ud.e as radius
0B0BCA             0083*  ; returns ub.c as dx, ud.e as dy
0B0BCA             0084*  ;        displacements from origin (0,0)
0B0BCA             0085*  ; destroys: everything except indexes
0B0BCA             0086*  polar_to_cartesian:
0B0BCA             0087*  ; back up input parameters
0B0BCA 22 3C 08 0B 0088*      ld (arith24uhl), hl
0B0BCE ED 53 48 08 0089*      ld (arith24ude), de
       0B          
0B0BD3             0090*  ; compute dx = sin(uh.l) * ud.e
0B0BD3 CD 94 0B 0B 0091*      call sin168
0B0BD7 E5          0092*      push hl
0B0BD8 C1          0093*      pop bc          ; ub.c = sin(uh.l)
0B0BD9 ED 5B 48 08 0094*  	ld de, (arith24ude)   ; get radius back
       0B          
0B0BDE CD 0B 09 0B 0095*  	call smul168    ; uh.l = ub.c * ud.e = dx
0B0BE2 E5          0096*      push hl         ; store dx for output
0B0BE3             0097*  ; compute dy = -cos(uh.l) * ud.e
0B0BE3 2A 3C 08 0B 0098*      ld hl, (arith24uhl)
0B0BE7 CD 8F 0B 0B 0099*      call cos168
0B0BEB CD 7D 07 0B 0100*  	call neg_hlu    ; invert dy for screen coords convention
0B0BEF E5          0101*      push hl
0B0BF0 C1          0102*      pop bc          ; ub.c = -cos(uh.l)
0B0BF1 ED 5B 48 08 0103*      ld de, (arith24ude)   ; get radius back
       0B          
0B0BF6 CD 0B 09 0B 0104*      call smul168    ; uh.l = ub.c * ud.e = dy
0B0BFA EB          0105*      ex de, hl       ; de = dy for output
0B0BFB C1          0106*      pop bc          ; bc = dx for output
0B0BFC             0107*  ; and out
0B0BFC C9          0108*      ret
0B0BFD             0109*  
0B0BFD             0110*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0BFD             0111*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0BFD             0112*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0BFD             0113*  ;         also populates scratch locations dx168 and dy168
0B0BFD             0114*  ; destroys: a,hl,bc,de
0B0BFD             0115*  dxy168:
0B0BFD             0116*  ; compute dx = x1-x0
0B0BFD AF          0117*      xor a ; clear carry
0B0BFE DD E5       0118*      push ix ; move ix to hl via the stack
0B0C00 E1          0119*      pop hl ; hl = x1
0B0C01 ED 42       0120*      sbc hl,bc ; hl = dx
0B0C03 22 58 0C 0B 0121*      ld (dx168),hl ; dx to scratch
0B0C07             0122*  ; compute dy = y1-y0
0B0C07 AF          0123*      xor a ; clear carry
0B0C08 FD E5       0124*      push iy ; move iy to hl via the stack
0B0C0A E1          0125*      pop hl ; hl = y1
0B0C0B ED 52       0126*      sbc hl,de ; hl = dy
0B0C0D 22 5E 0C 0B 0127*      ld (dy168),hl ; dy to scratch
0B0C11             0128*  ; populate output registers and return
0B0C11 EB          0129*      ex de,hl        ; ud.e = dy
0B0C12 ED 4B 58 0C 0130*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0C17 C9          0131*      ret
0B0C18             0132*  
0B0C18             0133*  ; compute the euclidian distance between two cartesian coordinates
0B0C18             0134*  ; using the formula d = sqrt(dx^2+dy^2
0B0C18             0135*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0C18             0136*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0C18             0137*  ; output; uh.l is the 16.8 fixed format distance
0B0C18             0138*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0C18             0139*  ; destroys: a,hl,bc,de
0B0C18             0140*  distance168:
0B0C18             0141*  ; compute dx = x1-x0
0B0C18 AF          0142*      xor a ; clear carry
0B0C19 DD E5       0143*      push ix ; move ix to hl via the stack
0B0C1B E1          0144*      pop hl ; hl = x1
0B0C1C ED 42       0145*      sbc hl,bc ; hl = dx
0B0C1E 22 58 0C 0B 0146*      ld (dx168),hl ; dx to scratch
0B0C22             0147*  ; ; test dx for overflow
0B0C22             0148*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0C22             0149*  ; 	ex de,hl
0B0C22             0150*  ; 	sbc hl,de ; test for overflow
0B0C22             0151*  ; 	push af ; carry indicates overflow
0B0C22             0152*  ; compute dy = y1-y0
0B0C22 AF          0153*      xor a ; clear carry
0B0C23 FD E5       0154*      push iy ; move iy to hl via the stack
0B0C25 E1          0155*      pop hl ; hl = y1
0B0C26 ED 52       0156*      sbc hl,de ; hl = dy
0B0C28 22 5E 0C 0B 0157*      ld (dy168),hl ; dy to scratch
0B0C2C             0158*  ; ; test dy for overflow
0B0C2C             0159*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0C2C             0160*  ; 	ex de,hl
0B0C2C             0161*  ; 	sbc hl,de ; test for overflow
0B0C2C             0162*  ; 	push af ; carry indicates overflow
0B0C2C             0163*  ; compute dy^2
0B0C2C 2A 5E 0C 0B 0164*  	ld hl,(dy168)
0B0C30 CD 6D 07 0B 0165*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B0C34             0166*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0C34 E5          0167*      push hl ; load hl/2 to bc via the stack
0B0C35 C1          0168*      pop bc ; bc = dy/2
0B0C36 EB          0169*      ex de,hl ; de = dy/2
0B0C37 CD 03 09 0B 0170*      call umul168 ; uh.l = dy^2/2
0B0C3B E5          0171*      push hl ; dy^2/2 to the stack
0B0C3C             0172*  ; compute dx^2
0B0C3C 2A 58 0C 0B 0173*      ld hl,(dx168) ; get back dx
0B0C40 CD 6D 07 0B 0174*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B0C44             0175*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0C44 E5          0176*      push hl ; load hl/2 to bc via the stack
0B0C45 C1          0177*      pop bc ; bc = dx/2
0B0C46 EB          0178*      ex de,hl ; de = dx/2
0B0C47 CD 03 09 0B 0179*      call umul168 ; uh.l = dx^2/2
0B0C4B             0180*  ; commpute dy^2+dx^2
0B0C4B D1          0181*      pop de ; get back dx^2/2
0B0C4C 19          0182*      add hl,de ; hl = dx^2/2+dy^2/2
0B0C4D             0183*  ; compute sqrt(dx^2/2+dy^2/2)
0B0C4D CD 68 0A 0B 0184*      call sqrt168 ; uh.l = distance/2
0B0C51             0185*      ; add hl,hl ; hl = distance
0B0C51             0186*  ; ; check for overflow
0B0C51             0187*  ; 	pop af ; get back the overflow flags
0B0C51             0188*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0C51             0189*  ; 	ld b,a ; save the overflow flag
0B0C51             0190*  ; 	pop af ; get back the overflow flags
0B0C51             0191*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0C51             0192*  ; 	add a,b ; if a != 0 then we had overflow
0B0C51             0193*  ;     ret z ; no overflow we're done
0B0C51             0194*  ; @overflow:
0B0C51             0195*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0C51 C9          0196*  	ret
0B0C52             0197*  @scratch: ds 6
0B0C58             0198*  dx168: ds 6
0B0C5E             0199*  dy168: ds 6
0B0C64             0200*  
0B0C64             0201*  ; atan2(ub.c,ud.e) --> uh.l
0B0C64             0202*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0C64             0203*  ;   whether inputs are integers or fractional doesn't matter
0B0C64             0204*  ;   so long as the sign bit of the upper byte is correct
0B0C64             0205*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0C64             0206*  ; angles are COMPASS HEADINGS based on
0B0C64             0207*  ; screen coordinate conventions,where the y axis is flipped
0B0C64             0208*  ; #E0 315      0       45 #20
0B0C64             0209*  ;        -x,-y | +x,-y
0B0C64             0210*  ; #C0 270------+------ 90 #40
0B0C64             0211*  ;        -x,+y | +x,+y
0B0C64             0212*  ; #A0 225   180 #80   135 #60
0B0C64             0213*  atan2_168game:
0B0C64             0214*  ; get signs and make everything positive
0B0C64             0215*  ; get abs(x) and store its original sign
0B0C64 C5          0216*      push bc
0B0C65 E1          0217*      pop hl
0B0C66 CD 6D 07 0B 0218*      call abs_hlu ; if x was negative this also sets the sign flag
0B0C6A E5          0219*      push hl ; store abs(x)
0B0C6B C1          0220*      pop bc ; bc = abs(x)
0B0C6C F5          0221*      push af ; store sign of x
0B0C6D             0222*  ; get abs(y) and store its original sign
0B0C6D EB          0223*      ex de,hl ; hl = y
0B0C6E CD 6D 07 0B 0224*      call abs_hlu ; if y was negative this also sets the sign flag
0B0C72 EB          0225*      ex de,hl ; de = abs(y)
0B0C73 F5          0226*      push af ; store sign of y
0B0C74             0227*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0C74             0228*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B0C74 AF          0229*      xor a ; clear the carry flag
0B0C75 D5          0230*      push de
0B0C76 E1          0231*      pop hl
0B0C77 ED 42       0232*      sbc hl,bc
0B0C79 F5          0233*      push af ; save sign of de - bc
0B0C7A F2 83 0C 0B 0234*      jp p,@1 ; bc <= de, so we skip ahead
0B0C7E             0235*  ; otherwise we swap bc and de
0B0C7E C5          0236*      push bc
0B0C7F E1          0237*      pop hl
0B0C80 EB          0238*      ex de,hl
0B0C81 E5          0239*      push hl
0B0C82 C1          0240*      pop bc
0B0C83             0241*  @1:
0B0C83             0242*  ; now we're ready to snag our preliminary result
0B0C83 CD F1 0C 0B 0243*      call atan_168game ; uh.l comes back with prelim result
0B0C87             0244*  ; now we adjust uh.l based on sign of de - bc
0B0C87 F1          0245*      pop af
0B0C88 F2 94 0C 0B 0246*      jp p,@2 ; bc <= de,so we skip ahead
0B0C8C EB          0247*      ex de,hl
0B0C8D 21 00 40 00 0248*      ld hl,0x004000 ; 90 degrees
0B0C91 AF          0249*      xor a ; clear the carry flag
0B0C92 ED 52       0250*      sbc hl,de ; subtract result from 90 degrees
0B0C94             0251*      ; ld de,0 ; prep to clear hlu
0B0C94             0252*      ; ld d,h
0B0C94             0253*      ; ld e,l
0B0C94             0254*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0C94             0255*      ; fall through
0B0C94             0256*  @2:
0B0C94             0257*  ; now the fun part of adjusting the result
0B0C94             0258*  ; based on which quadrant (x,y) is in
0B0C94             0259*  ; #E0 315      0       45 #20
0B0C94             0260*  ;        -x,-y | +x,-y
0B0C94             0261*  ; #C0 270------+------ 90 #40
0B0C94             0262*  ;        -x,+y | +x,+y
0B0C94             0263*  ; #A0 225   180 #80   135 #60
0B0C94 F1          0264*      pop af ; sign of y
0B0C95 CA D2 0C 0B 0265*      jp z,@y_zero
0B0C99 F2 B2 0C 0B 0266*      jp p,@y_pos
0B0C9D             0267*  ; y neg,check x
0B0C9D F1          0268*      pop af ; sign of x
0B0C9E CA AC 0C 0B 0269*      jp z,@y_neg_x_zero
0B0CA2 F2 B1 0C 0B 0270*      jp p,@y_neg_x_pos
0B0CA6             0271*  ; y neg,x neg
0B0CA6             0272*  ; angle is 270-360
0B0CA6             0273*  ; negating the intermediate does the trick
0B0CA6 CD 7D 07 0B 0274*      call neg_hlu
0B0CAA 18 31       0275*      jr @zero_hlu
0B0CAC             0276*  
0B0CAC             0277*  @y_neg_x_zero:
0B0CAC             0278*  ; y neg,x zero
0B0CAC             0279*  ; angle is 0
0B0CAC 21 00 00 00 0280*      ld hl,0
0B0CB0 C9          0281*      ret
0B0CB1             0282*  @y_neg_x_pos:
0B0CB1             0283*  ; y neg,x pos
0B0CB1             0284*  ; angle is 0 to 90
0B0CB1             0285*  ; so we're good
0B0CB1 C9          0286*      ret
0B0CB2             0287*  
0B0CB2             0288*  @y_pos:
0B0CB2 F1          0289*      pop af ; sign of x
0B0CB3 CA C2 0C 0B 0290*      jp z,@y_pos_x_zero
0B0CB7 F2 C7 0C 0B 0291*      jp p,@y_pos_x_pos
0B0CBB             0292*  ; y pos,x neg
0B0CBB             0293*  ; angle is 180-270
0B0CBB             0294*  ; so we add 180 to intermediate
0B0CBB 11 00 80 00 0295*      ld de,0x008000
0B0CBF 19          0296*      add hl,de
0B0CC0 18 1B       0297*      jr @zero_hlu
0B0CC2             0298*  @y_pos_x_zero:
0B0CC2             0299*  ; y pos,x zero
0B0CC2             0300*  ; angle is 180
0B0CC2 21 00 80 00 0301*      ld hl,0x008000
0B0CC6 C9          0302*      ret
0B0CC7             0303*  @y_pos_x_pos:
0B0CC7             0304*  ; y pos,x pos
0B0CC7             0305*  ; angle is 90-180
0B0CC7             0306*  ; neg the intermediate and add 180 degrees
0B0CC7 CD 7D 07 0B 0307*      call neg_hlu
0B0CCB 11 00 80 00 0308*      ld de,0x008000
0B0CCF 19          0309*      add hl,de
0B0CD0 18 0B       0310*      jr @zero_hlu
0B0CD2             0311*  
0B0CD2             0312*  @y_zero:
0B0CD2 F1          0313*      pop af ; sign of x
0B0CD3 FA D8 0C 0B 0314*      jp m,@y_zero_x_neg
0B0CD7             0315*  ; y zero,x pos
0B0CD7             0316*  ; angle is 90,nothing to do
0B0CD7 C9          0317*      ret
0B0CD8             0318*  @y_zero_x_neg:
0B0CD8             0319*  ; y zero ,x neg
0B0CD8             0320*  ; angle is 270
0B0CD8 21 00 C0 00 0321*      ld hl,0x00C000
0B0CDC C9          0322*      ret
0B0CDD             0323*  @zero_hlu:
0B0CDD AF          0324*      xor a
0B0CDE 22 EB 0C 0B 0325*      ld (@scratch),hl
0B0CE2 32 ED 0C 0B 0326*      ld (@scratch+2),a
0B0CE6 2A EB 0C 0B 0327*      ld hl,(@scratch)
0B0CEA C9          0328*      ret
0B0CEB             0329*  @scratch: ds 6
0B0CF1             0330*  
0B0CF1             0331*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0CF1             0332*  ; output: uh.l is the 16.8 fixed format angle
0B0CF1             0333*  ; destroys: a,hl,bc,de
0B0CF1             0334*  ; the following note was written by github copilot:
0B0CF1             0335*  ; note: this routine is a bit of a hack
0B0CF1             0336*  ;      but it works
0B0CF1             0337*  ;      and it's fast
0B0CF1             0338*  ;      and it's small
0B0CF1             0339*  ;      and it's accurate
0B0CF1             0340*  ;      and it's easy to understand
0B0CF1             0341*  ;      and it's easy to modify
0B0CF1             0342*  ;      and it's easy to use
0B0CF1             0343*  ;      and it's easy to remember
0B0CF1             0344*  ;      and it's easy to love
0B0CF1             0345*  ;      and it's easy to hate
0B0CF1             0346*  ;      and it's easy to ignore
0B0CF1             0347*  ;      and it's easy to forget
0B0CF1             0348*  ;      and it's easy to remember
0B0CF1             0349*  ;      and it's easy to forget
0B0CF1             0350*  ;      and it's easy to remember
0B0CF1             0351*  ;      (ok the bot is stuck in a loop)
0B0CF1             0352*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0CF1             0353*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0CF1             0354*  atan_168game:
0B0CF1             0355*  ; because we use compass headings instead of geometric angles
0B0CF1             0356*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0CF1             0357*  ; we can do faster unsigned division here because we know dx and dy are positive
0B0CF1 CD 6B 09 0B 0358*  	call udiv168 ; uh.l = dx/dy
0B0CF5             0359*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0CF5             0360*  ; ; test uh.l for 0
0B0CF5             0361*  ;     add hl,de
0B0CF5             0362*  ;     or a
0B0CF5             0363*  ;     sbc hl,de
0B0CF5             0364*  ;     jr z,@is_zero
0B0CF5             0365*  ; ; test uh.l for 1
0B0CF5             0366*  ;     xor a ; clear carry
0B0CF5             0367*  ;     ex de,hl
0B0CF5             0368*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0CF5             0369*  ;     sbc hl,de
0B0CF5             0370*  ;     jr z,@is_45
0B0CF5             0371*  ; ; END TODO
0B0CF5             0372*  
0B0CF5             0373*  ; no special cases so we move on
0B0CF5             0374*  ; l contains the fractional portion of tan(uh.l)
0B0CF5             0375*  ; we multiply it by three to get our lookup table index
0B0CF5 26 03       0376*      ld h,3
0B0CF7 ED 6C       0377*      mlt hl ; gosh that is handy
0B0CF9 11 00 00 00 0378*      ld de,0 ; clear deu
0B0CFD 54          0379*      ld d,h ; copy hl to de
0B0CFE 5D          0380*      ld e,l ; de contains our index
0B0CFF 21 14 10 0B 0381*      ld hl,atan_lut_168 ; grab the lut address
0B0D03 19          0382*      add hl,de ; bump hl by the index
0B0D04 ED 27       0383*      ld hl,(hl) ; don't try this on a z80!
0B0D06 C9          0384*      ret ; and out
0B0D07             0385*  @is_45:
0B0D07 21 00 20 00 0386*      ld hl,0x002000 ; 45 degrees decimal
0B0D0B C9          0387*      ret
0B0D0C             0388*  ; for the case tan(0)
0B0D0C             0389*  @is_zero:
0B0D0C 21 00 00 00 0390*      ld hl,0x000000
0B0D10 C9          0391*      ret
0B0D11             0392*  
0B0D11             0393*  
0B0D11             0394*  sin_lut_168:
0B0D11 00 00 00    0395*  	dl 0x000000 ; 0.000 00, 0.000
0B0D14 06 00 00    0396*  	dl 0x000006 ; 1.406 01, 0.025
0B0D17 0C 00 00    0397*  	dl 0x00000C ; 2.813 02, 0.049
0B0D1A 12 00 00    0398*  	dl 0x000012 ; 4.219 03, 0.074
0B0D1D 19 00 00    0399*  	dl 0x000019 ; 5.625 04, 0.098
0B0D20 1F 00 00    0400*  	dl 0x00001F ; 7.031 05, 0.122
0B0D23 25 00 00    0401*  	dl 0x000025 ; 8.438 06, 0.147
0B0D26 2B 00 00    0402*  	dl 0x00002B ; 9.844 07, 0.171
0B0D29 31 00 00    0403*  	dl 0x000031 ; 11.250 08, 0.195
0B0D2C 38 00 00    0404*  	dl 0x000038 ; 12.656 09, 0.219
0B0D2F 3E 00 00    0405*  	dl 0x00003E ; 14.063 0A, 0.243
0B0D32 44 00 00    0406*  	dl 0x000044 ; 15.469 0B, 0.267
0B0D35 4A 00 00    0407*  	dl 0x00004A ; 16.875 0C, 0.290
0B0D38 50 00 00    0408*  	dl 0x000050 ; 18.281 0D, 0.314
0B0D3B 56 00 00    0409*  	dl 0x000056 ; 19.688 0E, 0.337
0B0D3E 5C 00 00    0410*  	dl 0x00005C ; 21.094 0F, 0.360
0B0D41 61 00 00    0411*  	dl 0x000061 ; 22.500 10, 0.383
0B0D44 67 00 00    0412*  	dl 0x000067 ; 23.906 11, 0.405
0B0D47 6D 00 00    0413*  	dl 0x00006D ; 25.313 12, 0.428
0B0D4A 73 00 00    0414*  	dl 0x000073 ; 26.719 13, 0.450
0B0D4D 78 00 00    0415*  	dl 0x000078 ; 28.125 14, 0.471
0B0D50 7E 00 00    0416*  	dl 0x00007E ; 29.531 15, 0.493
0B0D53 83 00 00    0417*  	dl 0x000083 ; 30.938 16, 0.514
0B0D56 88 00 00    0418*  	dl 0x000088 ; 32.344 17, 0.535
0B0D59 8E 00 00    0419*  	dl 0x00008E ; 33.750 18, 0.556
0B0D5C 93 00 00    0420*  	dl 0x000093 ; 35.156 19, 0.576
0B0D5F 98 00 00    0421*  	dl 0x000098 ; 36.563 1A, 0.596
0B0D62 9D 00 00    0422*  	dl 0x00009D ; 37.969 1B, 0.615
0B0D65 A2 00 00    0423*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0D68 A7 00 00    0424*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0D6B AB 00 00    0425*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0D6E B0 00 00    0426*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B0D71 B5 00 00    0427*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0D74 B9 00 00    0428*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0D77 BD 00 00    0429*  	dl 0x0000BD ; 47.813 22, 0.741
0B0D7A C1 00 00    0430*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0D7D C5 00 00    0431*  	dl 0x0000C5 ; 50.625 24, 0.773
0B0D80 C9 00 00    0432*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0D83 CD 00 00    0433*  	dl 0x0000CD ; 53.438 26, 0.803
0B0D86 D1 00 00    0434*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0D89 D4 00 00    0435*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0D8C D8 00 00    0436*  	dl 0x0000D8 ; 57.656 29, 0.845
0B0D8F DB 00 00    0437*  	dl 0x0000DB ; 59.063 2A, 0.858
0B0D92 DE 00 00    0438*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0D95 E1 00 00    0439*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0D98 E4 00 00    0440*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0D9B E7 00 00    0441*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B0D9E EA 00 00    0442*  	dl 0x0000EA ; 66.094 2F, 0.914
0B0DA1 EC 00 00    0443*  	dl 0x0000EC ; 67.500 30, 0.924
0B0DA4 EE 00 00    0444*  	dl 0x0000EE ; 68.906 31, 0.933
0B0DA7 F1 00 00    0445*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0DAA F3 00 00    0446*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0DAD F4 00 00    0447*  	dl 0x0000F4 ; 73.125 34, 0.957
0B0DB0 F6 00 00    0448*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0DB3 F8 00 00    0449*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0DB6 F9 00 00    0450*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0DB9 FB 00 00    0451*  	dl 0x0000FB ; 78.750 38, 0.981
0B0DBC FC 00 00    0452*  	dl 0x0000FC ; 80.156 39, 0.985
0B0DBF FD 00 00    0453*  	dl 0x0000FD ; 81.563 3A, 0.989
0B0DC2 FE 00 00    0454*  	dl 0x0000FE ; 82.969 3B, 0.992
0B0DC5 FE 00 00    0455*  	dl 0x0000FE ; 84.375 3C, 0.995
0B0DC8 FF 00 00    0456*  	dl 0x0000FF ; 85.781 3D, 0.997
0B0DCB FF 00 00    0457*  	dl 0x0000FF ; 87.188 3E, 0.999
0B0DCE FF 00 00    0458*  	dl 0x0000FF ; 88.594 3F, 1.000
0B0DD1 00 01 00    0459*  	dl 0x000100 ; 90.000 40, 1.000
0B0DD4 FF 00 00    0460*  	dl 0x0000FF ; 91.406 41, 1.000
0B0DD7 FF 00 00    0461*  	dl 0x0000FF ; 92.813 42, 0.999
0B0DDA FF 00 00    0462*  	dl 0x0000FF ; 94.219 43, 0.997
0B0DDD FE 00 00    0463*  	dl 0x0000FE ; 95.625 44, 0.995
0B0DE0 FE 00 00    0464*  	dl 0x0000FE ; 97.031 45, 0.992
0B0DE3 FD 00 00    0465*  	dl 0x0000FD ; 98.438 46, 0.989
0B0DE6 FC 00 00    0466*  	dl 0x0000FC ; 99.844 47, 0.985
0B0DE9 FB 00 00    0467*  	dl 0x0000FB ; 101.250 48, 0.981
0B0DEC F9 00 00    0468*  	dl 0x0000F9 ; 102.656 49, 0.976
0B0DEF F8 00 00    0469*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B0DF2 F6 00 00    0470*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B0DF5 F4 00 00    0471*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B0DF8 F3 00 00    0472*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B0DFB F1 00 00    0473*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B0DFE EE 00 00    0474*  	dl 0x0000EE ; 111.094 4F, 0.933
0B0E01 EC 00 00    0475*  	dl 0x0000EC ; 112.500 50, 0.924
0B0E04 EA 00 00    0476*  	dl 0x0000EA ; 113.906 51, 0.914
0B0E07 E7 00 00    0477*  	dl 0x0000E7 ; 115.313 52, 0.904
0B0E0A E4 00 00    0478*  	dl 0x0000E4 ; 116.719 53, 0.893
0B0E0D E1 00 00    0479*  	dl 0x0000E1 ; 118.125 54, 0.882
0B0E10 DE 00 00    0480*  	dl 0x0000DE ; 119.531 55, 0.870
0B0E13 DB 00 00    0481*  	dl 0x0000DB ; 120.938 56, 0.858
0B0E16 D8 00 00    0482*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0E19 D4 00 00    0483*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0E1C D1 00 00    0484*  	dl 0x0000D1 ; 125.156 59, 0.818
0B0E1F CD 00 00    0485*  	dl 0x0000CD ; 126.563 5A, 0.803
0B0E22 C9 00 00    0486*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0E25 C5 00 00    0487*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0E28 C1 00 00    0488*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0E2B BD 00 00    0489*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0E2E B9 00 00    0490*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B0E31 B5 00 00    0491*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0E34 B0 00 00    0492*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0E37 AB 00 00    0493*  	dl 0x0000AB ; 137.813 62, 0.672
0B0E3A A7 00 00    0494*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0E3D A2 00 00    0495*  	dl 0x0000A2 ; 140.625 64, 0.634
0B0E40 9D 00 00    0496*  	dl 0x00009D ; 142.031 65, 0.615
0B0E43 98 00 00    0497*  	dl 0x000098 ; 143.438 66, 0.596
0B0E46 93 00 00    0498*  	dl 0x000093 ; 144.844 67, 0.576
0B0E49 8E 00 00    0499*  	dl 0x00008E ; 146.250 68, 0.556
0B0E4C 88 00 00    0500*  	dl 0x000088 ; 147.656 69, 0.535
0B0E4F 83 00 00    0501*  	dl 0x000083 ; 149.063 6A, 0.514
0B0E52 7E 00 00    0502*  	dl 0x00007E ; 150.469 6B, 0.493
0B0E55 78 00 00    0503*  	dl 0x000078 ; 151.875 6C, 0.471
0B0E58 73 00 00    0504*  	dl 0x000073 ; 153.281 6D, 0.450
0B0E5B 6D 00 00    0505*  	dl 0x00006D ; 154.688 6E, 0.428
0B0E5E 67 00 00    0506*  	dl 0x000067 ; 156.094 6F, 0.405
0B0E61 61 00 00    0507*  	dl 0x000061 ; 157.500 70, 0.383
0B0E64 5C 00 00    0508*  	dl 0x00005C ; 158.906 71, 0.360
0B0E67 56 00 00    0509*  	dl 0x000056 ; 160.313 72, 0.337
0B0E6A 50 00 00    0510*  	dl 0x000050 ; 161.719 73, 0.314
0B0E6D 4A 00 00    0511*  	dl 0x00004A ; 163.125 74, 0.290
0B0E70 44 00 00    0512*  	dl 0x000044 ; 164.531 75, 0.267
0B0E73 3E 00 00    0513*  	dl 0x00003E ; 165.938 76, 0.243
0B0E76 38 00 00    0514*  	dl 0x000038 ; 167.344 77, 0.219
0B0E79 31 00 00    0515*  	dl 0x000031 ; 168.750 78, 0.195
0B0E7C 2B 00 00    0516*  	dl 0x00002B ; 170.156 79, 0.171
0B0E7F 25 00 00    0517*  	dl 0x000025 ; 171.563 7A, 0.147
0B0E82 1F 00 00    0518*  	dl 0x00001F ; 172.969 7B, 0.122
0B0E85 19 00 00    0519*  	dl 0x000019 ; 174.375 7C, 0.098
0B0E88 12 00 00    0520*  	dl 0x000012 ; 175.781 7D, 0.074
0B0E8B 0C 00 00    0521*  	dl 0x00000C ; 177.188 7E, 0.049
0B0E8E 06 00 00    0522*  	dl 0x000006 ; 178.594 7F, 0.025
0B0E91 00 00 00    0523*  	dl 0x000000 ; 180.000 80, 0.000
0B0E94 FA FF FF    0524*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0E97 F4 FF FF    0525*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0E9A EE FF FF    0526*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0E9D E7 FF FF    0527*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B0EA0 E1 FF FF    0528*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0EA3 DB FF FF    0529*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0EA6 D5 FF FF    0530*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0EA9 CF FF FF    0531*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0EAC C8 FF FF    0532*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B0EAF C2 FF FF    0533*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B0EB2 BC FF FF    0534*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0EB5 B6 FF FF    0535*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0EB8 B0 FF FF    0536*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0EBB AA FF FF    0537*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B0EBE A4 FF FF    0538*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B0EC1 9F FF FF    0539*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B0EC4 99 FF FF    0540*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B0EC7 93 FF FF    0541*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B0ECA 8D FF FF    0542*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B0ECD 88 FF FF    0543*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B0ED0 82 FF FF    0544*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B0ED3 7D FF FF    0545*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B0ED6 78 FF FF    0546*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B0ED9 72 FF FF    0547*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B0EDC 6D FF FF    0548*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B0EDF 68 FF FF    0549*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B0EE2 63 FF FF    0550*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B0EE5 5E FF FF    0551*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B0EE8 59 FF FF    0552*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B0EEB 55 FF FF    0553*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B0EEE 50 FF FF    0554*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B0EF1 4B FF FF    0555*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B0EF4 47 FF FF    0556*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B0EF7 43 FF FF    0557*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B0EFA 3F FF FF    0558*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B0EFD 3B FF FF    0559*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B0F00 37 FF FF    0560*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B0F03 33 FF FF    0561*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B0F06 2F FF FF    0562*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B0F09 2C FF FF    0563*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B0F0C 28 FF FF    0564*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B0F0F 25 FF FF    0565*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B0F12 22 FF FF    0566*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B0F15 1F FF FF    0567*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B0F18 1C FF FF    0568*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B0F1B 19 FF FF    0569*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B0F1E 16 FF FF    0570*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B0F21 14 FF FF    0571*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B0F24 12 FF FF    0572*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0F27 0F FF FF    0573*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0F2A 0D FF FF    0574*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B0F2D 0C FF FF    0575*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B0F30 0A FF FF    0576*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B0F33 08 FF FF    0577*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0F36 07 FF FF    0578*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0F39 05 FF FF    0579*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0F3C 04 FF FF    0580*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B0F3F 03 FF FF    0581*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B0F42 02 FF FF    0582*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0F45 02 FF FF    0583*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0F48 01 FF FF    0584*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0F4B 01 FF FF    0585*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B0F4E 01 FF FF    0586*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B0F51 00 FF FF    0587*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B0F54 01 FF FF    0588*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0F57 01 FF FF    0589*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0F5A 01 FF FF    0590*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B0F5D 02 FF FF    0591*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B0F60 02 FF FF    0592*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B0F63 03 FF FF    0593*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0F66 04 FF FF    0594*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0F69 05 FF FF    0595*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0F6C 07 FF FF    0596*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B0F6F 08 FF FF    0597*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B0F72 0A FF FF    0598*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0F75 0C FF FF    0599*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0F78 0D FF FF    0600*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0F7B 0F FF FF    0601*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B0F7E 12 FF FF    0602*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B0F81 14 FF FF    0603*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B0F84 16 FF FF    0604*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0F87 19 FF FF    0605*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0F8A 1C FF FF    0606*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B0F8D 1F FF FF    0607*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B0F90 22 FF FF    0608*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B0F93 25 FF FF    0609*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0F96 28 FF FF    0610*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0F99 2C FF FF    0611*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B0F9C 2F FF FF    0612*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B0F9F 33 FF FF    0613*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B0FA2 37 FF FF    0614*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0FA5 3B FF FF    0615*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0FA8 3F FF FF    0616*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0FAB 43 FF FF    0617*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B0FAE 47 FF FF    0618*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B0FB1 4B FF FF    0619*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B0FB4 50 FF FF    0620*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B0FB7 55 FF FF    0621*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B0FBA 59 FF FF    0622*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B0FBD 5E FF FF    0623*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B0FC0 63 FF FF    0624*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B0FC3 68 FF FF    0625*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B0FC6 6D FF FF    0626*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B0FC9 72 FF FF    0627*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B0FCC 78 FF FF    0628*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B0FCF 7D FF FF    0629*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B0FD2 82 FF FF    0630*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B0FD5 88 FF FF    0631*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B0FD8 8D FF FF    0632*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B0FDB 93 FF FF    0633*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B0FDE 99 FF FF    0634*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B0FE1 9F FF FF    0635*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B0FE4 A4 FF FF    0636*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B0FE7 AA FF FF    0637*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B0FEA B0 FF FF    0638*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B0FED B6 FF FF    0639*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B0FF0 BC FF FF    0640*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B0FF3 C2 FF FF    0641*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B0FF6 C8 FF FF    0642*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B0FF9 CF FF FF    0643*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B0FFC D5 FF FF    0644*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B0FFF DB FF FF    0645*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B1002 E1 FF FF    0646*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B1005 E7 FF FF    0647*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B1008 EE FF FF    0648*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B100B F4 FF FF    0649*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B100E FA FF FF    0650*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B1011 00 00 00    0651*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B1014             0652*  
0B1014             0653*  atan_lut_168:
0B1014 00 00 00    0654*  	dl 0x000000 ; 000000, 0.000
0B1017 28 00 00    0655*  	dl 0x000028 ; 000001, 0.224
0B101A 51 00 00    0656*  	dl 0x000051 ; 000002, 0.448
0B101D 7A 00 00    0657*  	dl 0x00007A ; 000003, 0.671
0B1020 A2 00 00    0658*  	dl 0x0000A2 ; 000004, 0.895
0B1023 CB 00 00    0659*  	dl 0x0000CB ; 000005, 1.119
0B1026 F4 00 00    0660*  	dl 0x0000F4 ; 000006, 1.343
0B1029 1D 01 00    0661*  	dl 0x00011D ; 000007, 1.566
0B102C 45 01 00    0662*  	dl 0x000145 ; 000008, 1.790
0B102F 6E 01 00    0663*  	dl 0x00016E ; 000009, 2.013
0B1032 97 01 00    0664*  	dl 0x000197 ; 00000A, 2.237
0B1035 BF 01 00    0665*  	dl 0x0001BF ; 00000B, 2.460
0B1038 E8 01 00    0666*  	dl 0x0001E8 ; 00000C, 2.684
0B103B 11 02 00    0667*  	dl 0x000211 ; 00000D, 2.907
0B103E 39 02 00    0668*  	dl 0x000239 ; 00000E, 3.130
0B1041 62 02 00    0669*  	dl 0x000262 ; 00000F, 3.353
0B1044 8B 02 00    0670*  	dl 0x00028B ; 000010, 3.576
0B1047 B3 02 00    0671*  	dl 0x0002B3 ; 000011, 3.799
0B104A DC 02 00    0672*  	dl 0x0002DC ; 000012, 4.022
0B104D 04 03 00    0673*  	dl 0x000304 ; 000013, 4.245
0B1050 2D 03 00    0674*  	dl 0x00032D ; 000014, 4.467
0B1053 55 03 00    0675*  	dl 0x000355 ; 000015, 4.690
0B1056 7E 03 00    0676*  	dl 0x00037E ; 000016, 4.912
0B1059 A6 03 00    0677*  	dl 0x0003A6 ; 000017, 5.134
0B105C CE 03 00    0678*  	dl 0x0003CE ; 000018, 5.356
0B105F F7 03 00    0679*  	dl 0x0003F7 ; 000019, 5.578
0B1062 1F 04 00    0680*  	dl 0x00041F ; 00001A, 5.799
0B1065 48 04 00    0681*  	dl 0x000448 ; 00001B, 6.021
0B1068 70 04 00    0682*  	dl 0x000470 ; 00001C, 6.242
0B106B 98 04 00    0683*  	dl 0x000498 ; 00001D, 6.463
0B106E C0 04 00    0684*  	dl 0x0004C0 ; 00001E, 6.684
0B1071 E8 04 00    0685*  	dl 0x0004E8 ; 00001F, 6.905
0B1074 11 05 00    0686*  	dl 0x000511 ; 000020, 7.125
0B1077 39 05 00    0687*  	dl 0x000539 ; 000021, 7.345
0B107A 61 05 00    0688*  	dl 0x000561 ; 000022, 7.565
0B107D 89 05 00    0689*  	dl 0x000589 ; 000023, 7.785
0B1080 B1 05 00    0690*  	dl 0x0005B1 ; 000024, 8.005
0B1083 D9 05 00    0691*  	dl 0x0005D9 ; 000025, 8.224
0B1086 01 06 00    0692*  	dl 0x000601 ; 000026, 8.443
0B1089 28 06 00    0693*  	dl 0x000628 ; 000027, 8.662
0B108C 50 06 00    0694*  	dl 0x000650 ; 000028, 8.881
0B108F 78 06 00    0695*  	dl 0x000678 ; 000029, 9.099
0B1092 A0 06 00    0696*  	dl 0x0006A0 ; 00002A, 9.317
0B1095 C7 06 00    0697*  	dl 0x0006C7 ; 00002B, 9.535
0B1098 EF 06 00    0698*  	dl 0x0006EF ; 00002C, 9.752
0B109B 16 07 00    0699*  	dl 0x000716 ; 00002D, 9.970
0B109E 3E 07 00    0700*  	dl 0x00073E ; 00002E, 10.187
0B10A1 65 07 00    0701*  	dl 0x000765 ; 00002F, 10.403
0B10A4 8D 07 00    0702*  	dl 0x00078D ; 000030, 10.620
0B10A7 B4 07 00    0703*  	dl 0x0007B4 ; 000031, 10.836
0B10AA DB 07 00    0704*  	dl 0x0007DB ; 000032, 11.051
0B10AD 03 08 00    0705*  	dl 0x000803 ; 000033, 11.267
0B10B0 2A 08 00    0706*  	dl 0x00082A ; 000034, 11.482
0B10B3 51 08 00    0707*  	dl 0x000851 ; 000035, 11.697
0B10B6 78 08 00    0708*  	dl 0x000878 ; 000036, 11.911
0B10B9 9F 08 00    0709*  	dl 0x00089F ; 000037, 12.125
0B10BC C6 08 00    0710*  	dl 0x0008C6 ; 000038, 12.339
0B10BF ED 08 00    0711*  	dl 0x0008ED ; 000039, 12.553
0B10C2 13 09 00    0712*  	dl 0x000913 ; 00003A, 12.766
0B10C5 3A 09 00    0713*  	dl 0x00093A ; 00003B, 12.978
0B10C8 61 09 00    0714*  	dl 0x000961 ; 00003C, 13.191
0B10CB 87 09 00    0715*  	dl 0x000987 ; 00003D, 13.403
0B10CE AE 09 00    0716*  	dl 0x0009AE ; 00003E, 13.614
0B10D1 D4 09 00    0717*  	dl 0x0009D4 ; 00003F, 13.825
0B10D4 FB 09 00    0718*  	dl 0x0009FB ; 000040, 14.036
0B10D7 21 0A 00    0719*  	dl 0x000A21 ; 000041, 14.247
0B10DA 47 0A 00    0720*  	dl 0x000A47 ; 000042, 14.457
0B10DD 6D 0A 00    0721*  	dl 0x000A6D ; 000043, 14.666
0B10E0 94 0A 00    0722*  	dl 0x000A94 ; 000044, 14.876
0B10E3 BA 0A 00    0723*  	dl 0x000ABA ; 000045, 15.085
0B10E6 E0 0A 00    0724*  	dl 0x000AE0 ; 000046, 15.293
0B10E9 05 0B 00    0725*  	dl 0x000B05 ; 000047, 15.501
0B10EC 2B 0B 00    0726*  	dl 0x000B2B ; 000048, 15.709
0B10EF 51 0B 00    0727*  	dl 0x000B51 ; 000049, 15.916
0B10F2 77 0B 00    0728*  	dl 0x000B77 ; 00004A, 16.123
0B10F5 9C 0B 00    0729*  	dl 0x000B9C ; 00004B, 16.329
0B10F8 C2 0B 00    0730*  	dl 0x000BC2 ; 00004C, 16.535
0B10FB E7 0B 00    0731*  	dl 0x000BE7 ; 00004D, 16.740
0B10FE 0C 0C 00    0732*  	dl 0x000C0C ; 00004E, 16.945
0B1101 32 0C 00    0733*  	dl 0x000C32 ; 00004F, 17.150
0B1104 57 0C 00    0734*  	dl 0x000C57 ; 000050, 17.354
0B1107 7C 0C 00    0735*  	dl 0x000C7C ; 000051, 17.558
0B110A A1 0C 00    0736*  	dl 0x000CA1 ; 000052, 17.761
0B110D C6 0C 00    0737*  	dl 0x000CC6 ; 000053, 17.964
0B1110 EB 0C 00    0738*  	dl 0x000CEB ; 000054, 18.166
0B1113 0F 0D 00    0739*  	dl 0x000D0F ; 000055, 18.368
0B1116 34 0D 00    0740*  	dl 0x000D34 ; 000056, 18.569
0B1119 58 0D 00    0741*  	dl 0x000D58 ; 000057, 18.770
0B111C 7D 0D 00    0742*  	dl 0x000D7D ; 000058, 18.970
0B111F A1 0D 00    0743*  	dl 0x000DA1 ; 000059, 19.170
0B1122 C6 0D 00    0744*  	dl 0x000DC6 ; 00005A, 19.370
0B1125 EA 0D 00    0745*  	dl 0x000DEA ; 00005B, 19.569
0B1128 0E 0E 00    0746*  	dl 0x000E0E ; 00005C, 19.767
0B112B 32 0E 00    0747*  	dl 0x000E32 ; 00005D, 19.965
0B112E 56 0E 00    0748*  	dl 0x000E56 ; 00005E, 20.163
0B1131 7A 0E 00    0749*  	dl 0x000E7A ; 00005F, 20.360
0B1134 9E 0E 00    0750*  	dl 0x000E9E ; 000060, 20.556
0B1137 C1 0E 00    0751*  	dl 0x000EC1 ; 000061, 20.752
0B113A E5 0E 00    0752*  	dl 0x000EE5 ; 000062, 20.947
0B113D 08 0F 00    0753*  	dl 0x000F08 ; 000063, 21.142
0B1140 2C 0F 00    0754*  	dl 0x000F2C ; 000064, 21.337
0B1143 4F 0F 00    0755*  	dl 0x000F4F ; 000065, 21.531
0B1146 72 0F 00    0756*  	dl 0x000F72 ; 000066, 21.724
0B1149 95 0F 00    0757*  	dl 0x000F95 ; 000067, 21.917
0B114C B8 0F 00    0758*  	dl 0x000FB8 ; 000068, 22.109
0B114F DB 0F 00    0759*  	dl 0x000FDB ; 000069, 22.301
0B1152 FE 0F 00    0760*  	dl 0x000FFE ; 00006A, 22.493
0B1155 21 10 00    0761*  	dl 0x001021 ; 00006B, 22.683
0B1158 44 10 00    0762*  	dl 0x001044 ; 00006C, 22.874
0B115B 66 10 00    0763*  	dl 0x001066 ; 00006D, 23.063
0B115E 89 10 00    0764*  	dl 0x001089 ; 00006E, 23.253
0B1161 AB 10 00    0765*  	dl 0x0010AB ; 00006F, 23.441
0B1164 CD 10 00    0766*  	dl 0x0010CD ; 000070, 23.629
0B1167 EF 10 00    0767*  	dl 0x0010EF ; 000071, 23.817
0B116A 11 11 00    0768*  	dl 0x001111 ; 000072, 24.004
0B116D 33 11 00    0769*  	dl 0x001133 ; 000073, 24.191
0B1170 55 11 00    0770*  	dl 0x001155 ; 000074, 24.376
0B1173 77 11 00    0771*  	dl 0x001177 ; 000075, 24.562
0B1176 99 11 00    0772*  	dl 0x001199 ; 000076, 24.747
0B1179 BA 11 00    0773*  	dl 0x0011BA ; 000077, 24.931
0B117C DC 11 00    0774*  	dl 0x0011DC ; 000078, 25.115
0B117F FD 11 00    0775*  	dl 0x0011FD ; 000079, 25.298
0B1182 1E 12 00    0776*  	dl 0x00121E ; 00007A, 25.481
0B1185 3F 12 00    0777*  	dl 0x00123F ; 00007B, 25.663
0B1188 60 12 00    0778*  	dl 0x001260 ; 00007C, 25.844
0B118B 81 12 00    0779*  	dl 0x001281 ; 00007D, 26.025
0B118E A2 12 00    0780*  	dl 0x0012A2 ; 00007E, 26.206
0B1191 C3 12 00    0781*  	dl 0x0012C3 ; 00007F, 26.386
0B1194 E4 12 00    0782*  	dl 0x0012E4 ; 000080, 26.565
0B1197 04 13 00    0783*  	dl 0x001304 ; 000081, 26.744
0B119A 25 13 00    0784*  	dl 0x001325 ; 000082, 26.922
0B119D 45 13 00    0785*  	dl 0x001345 ; 000083, 27.100
0B11A0 65 13 00    0786*  	dl 0x001365 ; 000084, 27.277
0B11A3 85 13 00    0787*  	dl 0x001385 ; 000085, 27.453
0B11A6 A5 13 00    0788*  	dl 0x0013A5 ; 000086, 27.629
0B11A9 C5 13 00    0789*  	dl 0x0013C5 ; 000087, 27.805
0B11AC E5 13 00    0790*  	dl 0x0013E5 ; 000088, 27.979
0B11AF 05 14 00    0791*  	dl 0x001405 ; 000089, 28.154
0B11B2 24 14 00    0792*  	dl 0x001424 ; 00008A, 28.327
0B11B5 44 14 00    0793*  	dl 0x001444 ; 00008B, 28.501
0B11B8 63 14 00    0794*  	dl 0x001463 ; 00008C, 28.673
0B11BB 83 14 00    0795*  	dl 0x001483 ; 00008D, 28.845
0B11BE A2 14 00    0796*  	dl 0x0014A2 ; 00008E, 29.017
0B11C1 C1 14 00    0797*  	dl 0x0014C1 ; 00008F, 29.187
0B11C4 E0 14 00    0798*  	dl 0x0014E0 ; 000090, 29.358
0B11C7 FF 14 00    0799*  	dl 0x0014FF ; 000091, 29.527
0B11CA 1E 15 00    0800*  	dl 0x00151E ; 000092, 29.697
0B11CD 3C 15 00    0801*  	dl 0x00153C ; 000093, 29.865
0B11D0 5B 15 00    0802*  	dl 0x00155B ; 000094, 30.033
0B11D3 79 15 00    0803*  	dl 0x001579 ; 000095, 30.201
0B11D6 98 15 00    0804*  	dl 0x001598 ; 000096, 30.368
0B11D9 B6 15 00    0805*  	dl 0x0015B6 ; 000097, 30.534
0B11DC D4 15 00    0806*  	dl 0x0015D4 ; 000098, 30.700
0B11DF F2 15 00    0807*  	dl 0x0015F2 ; 000099, 30.865
0B11E2 10 16 00    0808*  	dl 0x001610 ; 00009A, 31.030
0B11E5 2E 16 00    0809*  	dl 0x00162E ; 00009B, 31.194
0B11E8 4C 16 00    0810*  	dl 0x00164C ; 00009C, 31.357
0B11EB 6A 16 00    0811*  	dl 0x00166A ; 00009D, 31.520
0B11EE 87 16 00    0812*  	dl 0x001687 ; 00009E, 31.682
0B11F1 A5 16 00    0813*  	dl 0x0016A5 ; 00009F, 31.844
0B11F4 C2 16 00    0814*  	dl 0x0016C2 ; 0000A0, 32.005
0B11F7 DF 16 00    0815*  	dl 0x0016DF ; 0000A1, 32.166
0B11FA FC 16 00    0816*  	dl 0x0016FC ; 0000A2, 32.326
0B11FD 19 17 00    0817*  	dl 0x001719 ; 0000A3, 32.486
0B1200 36 17 00    0818*  	dl 0x001736 ; 0000A4, 32.645
0B1203 53 17 00    0819*  	dl 0x001753 ; 0000A5, 32.803
0B1206 70 17 00    0820*  	dl 0x001770 ; 0000A6, 32.961
0B1209 8C 17 00    0821*  	dl 0x00178C ; 0000A7, 33.118
0B120C A9 17 00    0822*  	dl 0x0017A9 ; 0000A8, 33.275
0B120F C5 17 00    0823*  	dl 0x0017C5 ; 0000A9, 33.431
0B1212 E2 17 00    0824*  	dl 0x0017E2 ; 0000AA, 33.587
0B1215 FE 17 00    0825*  	dl 0x0017FE ; 0000AB, 33.742
0B1218 1A 18 00    0826*  	dl 0x00181A ; 0000AC, 33.896
0B121B 36 18 00    0827*  	dl 0x001836 ; 0000AD, 34.050
0B121E 52 18 00    0828*  	dl 0x001852 ; 0000AE, 34.203
0B1221 6E 18 00    0829*  	dl 0x00186E ; 0000AF, 34.356
0B1224 8A 18 00    0830*  	dl 0x00188A ; 0000B0, 34.509
0B1227 A5 18 00    0831*  	dl 0x0018A5 ; 0000B1, 34.660
0B122A C1 18 00    0832*  	dl 0x0018C1 ; 0000B2, 34.811
0B122D DC 18 00    0833*  	dl 0x0018DC ; 0000B3, 34.962
0B1230 F7 18 00    0834*  	dl 0x0018F7 ; 0000B4, 35.112
0B1233 13 19 00    0835*  	dl 0x001913 ; 0000B5, 35.262
0B1236 2E 19 00    0836*  	dl 0x00192E ; 0000B6, 35.410
0B1239 49 19 00    0837*  	dl 0x001949 ; 0000B7, 35.559
0B123C 64 19 00    0838*  	dl 0x001964 ; 0000B8, 35.707
0B123F 7F 19 00    0839*  	dl 0x00197F ; 0000B9, 35.854
0B1242 99 19 00    0840*  	dl 0x001999 ; 0000BA, 36.001
0B1245 B4 19 00    0841*  	dl 0x0019B4 ; 0000BB, 36.147
0B1248 CE 19 00    0842*  	dl 0x0019CE ; 0000BC, 36.293
0B124B E9 19 00    0843*  	dl 0x0019E9 ; 0000BD, 36.438
0B124E 03 1A 00    0844*  	dl 0x001A03 ; 0000BE, 36.582
0B1251 1D 1A 00    0845*  	dl 0x001A1D ; 0000BF, 36.726
0B1254 37 1A 00    0846*  	dl 0x001A37 ; 0000C0, 36.870
0B1257 51 1A 00    0847*  	dl 0x001A51 ; 0000C1, 37.013
0B125A 6B 1A 00    0848*  	dl 0x001A6B ; 0000C2, 37.155
0B125D 85 1A 00    0849*  	dl 0x001A85 ; 0000C3, 37.297
0B1260 9F 1A 00    0850*  	dl 0x001A9F ; 0000C4, 37.439
0B1263 B9 1A 00    0851*  	dl 0x001AB9 ; 0000C5, 37.579
0B1266 D2 1A 00    0852*  	dl 0x001AD2 ; 0000C6, 37.720
0B1269 EC 1A 00    0853*  	dl 0x001AEC ; 0000C7, 37.859
0B126C 05 1B 00    0854*  	dl 0x001B05 ; 0000C8, 37.999
0B126F 1E 1B 00    0855*  	dl 0x001B1E ; 0000C9, 38.137
0B1272 37 1B 00    0856*  	dl 0x001B37 ; 0000CA, 38.276
0B1275 50 1B 00    0857*  	dl 0x001B50 ; 0000CB, 38.413
0B1278 69 1B 00    0858*  	dl 0x001B69 ; 0000CC, 38.550
0B127B 82 1B 00    0859*  	dl 0x001B82 ; 0000CD, 38.687
0B127E 9B 1B 00    0860*  	dl 0x001B9B ; 0000CE, 38.823
0B1281 B4 1B 00    0861*  	dl 0x001BB4 ; 0000CF, 38.959
0B1284 CC 1B 00    0862*  	dl 0x001BCC ; 0000D0, 39.094
0B1287 E5 1B 00    0863*  	dl 0x001BE5 ; 0000D1, 39.228
0B128A FD 1B 00    0864*  	dl 0x001BFD ; 0000D2, 39.362
0B128D 16 1C 00    0865*  	dl 0x001C16 ; 0000D3, 39.496
0B1290 2E 1C 00    0866*  	dl 0x001C2E ; 0000D4, 39.629
0B1293 46 1C 00    0867*  	dl 0x001C46 ; 0000D5, 39.762
0B1296 5E 1C 00    0868*  	dl 0x001C5E ; 0000D6, 39.894
0B1299 76 1C 00    0869*  	dl 0x001C76 ; 0000D7, 40.025
0B129C 8E 1C 00    0870*  	dl 0x001C8E ; 0000D8, 40.156
0B129F A5 1C 00    0871*  	dl 0x001CA5 ; 0000D9, 40.286
0B12A2 BD 1C 00    0872*  	dl 0x001CBD ; 0000DA, 40.416
0B12A5 D5 1C 00    0873*  	dl 0x001CD5 ; 0000DB, 40.546
0B12A8 EC 1C 00    0874*  	dl 0x001CEC ; 0000DC, 40.675
0B12AB 04 1D 00    0875*  	dl 0x001D04 ; 0000DD, 40.803
0B12AE 1B 1D 00    0876*  	dl 0x001D1B ; 0000DE, 40.931
0B12B1 32 1D 00    0877*  	dl 0x001D32 ; 0000DF, 41.059
0B12B4 49 1D 00    0878*  	dl 0x001D49 ; 0000E0, 41.186
0B12B7 60 1D 00    0879*  	dl 0x001D60 ; 0000E1, 41.312
0B12BA 77 1D 00    0880*  	dl 0x001D77 ; 0000E2, 41.438
0B12BD 8E 1D 00    0881*  	dl 0x001D8E ; 0000E3, 41.564
0B12C0 A5 1D 00    0882*  	dl 0x001DA5 ; 0000E4, 41.689
0B12C3 BB 1D 00    0883*  	dl 0x001DBB ; 0000E5, 41.814
0B12C6 D2 1D 00    0884*  	dl 0x001DD2 ; 0000E6, 41.938
0B12C9 E9 1D 00    0885*  	dl 0x001DE9 ; 0000E7, 42.061
0B12CC FF 1D 00    0886*  	dl 0x001DFF ; 0000E8, 42.184
0B12CF 15 1E 00    0887*  	dl 0x001E15 ; 0000E9, 42.307
0B12D2 2C 1E 00    0888*  	dl 0x001E2C ; 0000EA, 42.429
0B12D5 42 1E 00    0889*  	dl 0x001E42 ; 0000EB, 42.551
0B12D8 58 1E 00    0890*  	dl 0x001E58 ; 0000EC, 42.672
0B12DB 6E 1E 00    0891*  	dl 0x001E6E ; 0000ED, 42.793
0B12DE 84 1E 00    0892*  	dl 0x001E84 ; 0000EE, 42.913
0B12E1 99 1E 00    0893*  	dl 0x001E99 ; 0000EF, 43.033
0B12E4 AF 1E 00    0894*  	dl 0x001EAF ; 0000F0, 43.152
0B12E7 C5 1E 00    0895*  	dl 0x001EC5 ; 0000F1, 43.271
0B12EA DA 1E 00    0896*  	dl 0x001EDA ; 0000F2, 43.390
0B12ED F0 1E 00    0897*  	dl 0x001EF0 ; 0000F3, 43.508
0B12F0 05 1F 00    0898*  	dl 0x001F05 ; 0000F4, 43.625
0B12F3 1B 1F 00    0899*  	dl 0x001F1B ; 0000F5, 43.742
0B12F6 30 1F 00    0900*  	dl 0x001F30 ; 0000F6, 43.859
0B12F9 45 1F 00    0901*  	dl 0x001F45 ; 0000F7, 43.975
0B12FC 5A 1F 00    0902*  	dl 0x001F5A ; 0000F8, 44.091
0B12FF 6F 1F 00    0903*  	dl 0x001F6F ; 0000F9, 44.206
0B1302 84 1F 00    0904*  	dl 0x001F84 ; 0000FA, 44.321
0B1305 99 1F 00    0905*  	dl 0x001F99 ; 0000FB, 44.435
0B1308 AD 1F 00    0906*  	dl 0x001FAD ; 0000FC, 44.549
0B130B C2 1F 00    0907*  	dl 0x001FC2 ; 0000FD, 44.662
0B130E D7 1F 00    0908*  	dl 0x001FD7 ; 0000FE, 44.775
0B1311 EB 1F 00    0909*  	dl 0x001FEB ; 0000FF, 44.888
0B1314 00 20 00    0910*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B1317             0023       include "files.inc"
0B1317             0001*  ; load to onboard 8k sram
0B1317             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B1317             0024       include "timer.inc"
0B1317             0001*  ; Table 32. Timer Control Registers
0B1317             0002*  ; this constant is the base address of the timer control registers
0B1317             0003*  ; each timer takes three bytes:
0B1317             0004*  ;   0: control register
0B1317             0005*  ;   1: low byte of timer reset value
0B1317             0006*  ;   2: high byte of timer reset value
0B1317             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B1317             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B1317             0009*  TMR_CTL:     equ 80h
0B1317             0010*  
0B1317             0011*  ; Timer Control Register Bit Definitions
0B1317             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B1317             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B1317             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B1317             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B1317             0016*                              ; the TMRx_CTL register is read.
0B1317             0017*  
0B1317             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B1317             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B1317             0020*  
0B1317             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B1317             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B1317             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B1317             0024*                              ; written to the counter when the end-of-count value is reached.
0B1317             0025*  
0B1317             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B1317             0027*  CLK_DIV_256:  equ %00001100 ;
0B1317             0028*  CLK_DIV_64:   equ %00001000 ;
0B1317             0029*  CLK_DIV_16:   equ %00000100 ;
0B1317             0030*  CLK_DIV_4:    equ %00000000 ;
0B1317             0031*  
0B1317             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B1317             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B1317             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B1317             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B1317             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B1317             0037*                              ; SINGLE-PASS mode is used.
0B1317             0038*  
0B1317             0039*  ; disable/enable the programmable reload timer
0B1317             0040*  PRT_EN_0:     equ %00000000 ;
0B1317             0041*  PRT_EN_1:     equ %00000001 ;
0B1317             0042*  
0B1317             0043*  ; Table 37. Timer Input Source Select Register
0B1317             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B1317             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B1317             0046*  ;   00: System clock / CLK_DIV
0B1317             0047*  ;   01: RTC / CLK_DIV
0B1317             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B1317             0049*  ;   10: GPIO port B pin 1.
0B1317             0050*  ;   11: GPIO port B pin 1.
0B1317             0051*  TMR_ISS:   equ 92h ; register address
0B1317             0052*  
0B1317             0053*  ; Table 51. Real-Time Clock Control Register
0B1317             0054*  RTC_CTRL: equ EDh ; register address
0B1317             0055*  
0B1317             0056*  ; alarm interrupt disable/enable
0B1317             0057*  RTC_ALARM_0:    equ %00000000
0B1317             0058*  RTC_ALARM_1:    equ %10000000
0B1317             0059*  
0B1317             0060*  ; interrupt on alarm disable/enable
0B1317             0061*  RTC_INT_ENT_0:  equ %00000000
0B1317             0062*  RTC_INT_ENT_1:  equ %01000000
0B1317             0063*  
0B1317             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B1317             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B1317             0066*  
0B1317             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B1317             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B1317             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B1317             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B1317             0071*  
0B1317             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B1317             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B1317             0074*  
0B1317             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B1317             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B1317             0077*  
0B1317             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B1317             0079*                                  ; RTC counter is enabled.
0B1317             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B1317             0081*                                  ; RTC counter is disabled.
0B1317             0082*  
0B1317             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B1317             0084*  
0B1317             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B1317             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B1317 00 00 00    0087*  prt_reload: dl 0x000000
0B131A             0088*  
0B131A             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B131A             0090*  ; ;          de = number PRT interrupts during test interval
0B131A             0091*  ; prt_calibrate:
0B131A             0092*  ;     call vdu_vblank
0B131A             0093*  ; ; set a MOS timer
0B131A             0094*  ;     ld hl,120*1 ; 1 second
0B131A             0095*  ;     ld iy,tmr_test
0B131A             0096*  ;     call tmr_set
0B131A             0097*  ; ; set a PRT timer
0B131A             0098*  ;     ; ld hl,prt_reload_hardware
0B131A             0099*  ;     ; ld hl,prt_reload_emulator
0B131A             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B131A             0101*  ;     ld (prt_reload),hl
0B131A             0102*  ;     call prt_set
0B131A             0103*  ; @loop:
0B131A             0104*  ; ; check time remaining on MOS timer
0B131A             0105*  ;     call tmr_get
0B131A             0106*  ;     jp z,@done ; time expired,so quit
0B131A             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B131A             0108*  ;     jr @loop
0B131A             0109*  ; @done:
0B131A             0110*  ;     ld de,(prt_irq_counter)
0B131A             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B131A             0112*  ;     ld (prt_reload),bc
0B131A             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B131A             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B131A             0115*  ;     ld (is_emulator),a
0B131A             0116*  ;     sbc hl,de
0B131A             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B131A             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B131A             0119*  ;     ret m ; negative result means we're on hardware
0B131A             0120*  ;     inc a ; we're on emulator
0B131A             0121*  ;     ld (is_emulator),a
0B131A             0122*  ;     ld bc,prt_reload_emulator
0B131A             0123*  ;     ld (prt_reload),bc
0B131A             0124*  ;     ld hl,on_emulator
0B131A             0125*  ;     ret
0B131A             0126*  
0B131A             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B131A             0128*  
0B131A             0129*  ; set PRT timer
0B131A             0130*  prt_set:
0B131A 21 00 00 00 0131*      ld hl,0
0B131E 22 68 13 0B 0132*      ld (prt_irq_counter),hl
0B1322 2A 17 13 0B 0133*      ld hl,(prt_reload)
0B1326 ED 29 84    0134*      out0 ($84),l
0B1329 ED 21 85    0135*  	out0 ($85),h
0B132C             0136*  ; disable timer
0B132C 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B132E ED 39 83    0138*  	out0 ($83),a
0B1331             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B1331 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B1333 ED 39 83    0141*  	out0 ($83),a
0B1336 C9          0142*      ret
0B1337             0143*  
0B1337             0144*  ; ===============================================
0B1337             0145*  ; PRT Timer Interrupt Handling
0B1337             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B1337             0147*  ; -----------------------------------------------
0B1337             0148*  prt_irq_init:
0B1337             0149*      ; set up interrupt vector table 2
0B1337 21 00 00 00 0150*  	ld hl,0
0B133B 3A 0C 01 00 0151*  	ld a,($10c)
0B133F 6F          0152*  	ld l,a
0B1340 3A 0D 01 00 0153*  	ld a,($10d)
0B1344 67          0154*  	ld h,a
0B1345             0155*  
0B1345             0156*  	; skip over CALL ($c3)
0B1345 23          0157*  	inc hl
0B1346             0158*  	; load address of jump into vector table 2 (in ram)
0B1346 ED 27       0159*  	ld hl,(hl)
0B1348             0160*  
0B1348             0161*  	; write CALL prt_irq_handler to vector table 2
0B1348 3E C3       0162*  	ld a,$c3
0B134A 77          0163*  	ld (hl),a
0B134B 23          0164*  	inc hl
0B134C 11 53 13 0B 0165*  	ld de,prt_irq_handler
0B1350 ED 1F       0166*  	ld (hl),de
0B1352             0167*  
0B1352 C9          0168*      ret
0B1353             0169*  
0B1353             0170*  prt_irq_handler:
0B1353 F3          0171*  	di
0B1354 F5          0172*  	push af
0B1355 E5          0173*      push hl
0B1356 ED 38 83    0174*  	in0 a,($83)
0B1359 2A 68 13 0B 0175*  	ld hl,(prt_irq_counter)
0B135D 23          0176*  	inc hl
0B135E 22 68 13 0B 0177*  	ld (prt_irq_counter),hl
0B1362 E1          0178*      pop hl
0B1363 F1          0179*  	pop af
0B1364 FB          0180*  	ei
0B1365 5B ED 4D    0181*  	reti.l
0B1368             0182*  
0B1368             0183*  prt_irq_counter:
0B1368 00 00 00    0184*  	.dl 0
0B136B             0185*  prt_irq_counter_saved:
0B136B 00 00 00    0186*      .dl 0
0B136E             0187*  
0B136E             0188*  prt_loop_reset:
0B136E E5          0189*      push hl
0B136F 21 00 00 00 0190*  	ld hl,0
0B1373 22 68 13 0B 0191*  	ld (prt_irq_counter),hl
0B1377 22 D9 13 0B 0192*      ld (prt_loop_counter),hl
0B137B 22 DC 13 0B 0193*      ld (prt_loops),hl
0B137F CD 1A 13 0B 0194*      call prt_set
0B1383 E1          0195*      pop hl
0B1384 C9          0196*      ret
0B1385             0197*  
0B1385             0198*  prt_loop_start:
0B1385 E5          0199*      push hl
0B1386 21 00 00 00 0200*  	ld hl,0
0B138A 22 68 13 0B 0201*  	ld (prt_irq_counter),hl
0B138E E1          0202*      pop hl
0B138F C9          0203*      ret
0B1390             0204*  
0B1390             0205*  prt_loop_stop:
0B1390 E5          0206*      push hl
0B1391 D5          0207*      push de
0B1392 2A 68 13 0B 0208*      ld hl,(prt_irq_counter)
0B1396 ED 5B D9 13 0209*      ld de,(prt_loop_counter)
       0B          
0B139B 19          0210*      add hl,de
0B139C 22 D9 13 0B 0211*      ld (prt_loop_counter),hl
0B13A0 21 00 00 00 0212*      ld hl,0
0B13A4 22 68 13 0B 0213*      ld (prt_irq_counter),hl
0B13A8 2A DC 13 0B 0214*      ld hl,(prt_loops)
0B13AC 23          0215*      inc hl
0B13AD 22 DC 13 0B 0216*      ld (prt_loops),hl
0B13B1 D1          0217*      pop de
0B13B2 E1          0218*      pop hl
0B13B3 C9          0219*      ret
0B13B4             0220*  
0B13B4             0221*  ; inputs: bc = y,x text coordinates to print
0B13B4             0222*  prt_loop_print:
0B13B4 F5          0223*      push af
0B13B5 E5          0224*      push hl
0B13B6 C5          0225*      push bc
0B13B7 D5          0226*      push de
0B13B8 DD E5       0227*      push ix
0B13BA FD E5       0228*      push iy
0B13BC CD D1 14 0B 0229*      call vdu_move_cursor
0B13C0             0230*  
0B13C0 2A D9 13 0B 0231*      ld hl,(prt_loop_counter)
0B13C4 CD 2B 03 0B 0232*      call printDec
0B13C8             0233*  
0B13C8 2A DC 13 0B 0234*      ld hl,(prt_loops)
0B13CC CD 2B 03 0B 0235*      call printDec
0B13D0             0236*  
0B13D0 FD E1       0237*      pop iy
0B13D2 DD E1       0238*      pop ix
0B13D4 D1          0239*      pop de
0B13D5 C1          0240*      pop bc
0B13D6 E1          0241*      pop hl
0B13D7 F1          0242*      pop af
0B13D8 C9          0243*      ret
0B13D9             0244*  
0B13D9             0245*  prt_loop_counter:
0B13D9 00 00 00    0246*      .dl 0
0B13DC             0247*  prt_loops:
0B13DC 00 00 00    0248*      .dl 0
0B13DF             0249*  
0B13DF             0250*  ; ===============================================
0B13DF             0251*  ; Timer functions
0B13DF             0252*  ; -----------------------------------------------
0B13DF             0253*  ; set a countdown timer
0B13DF             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B13DF             0255*  ; returns: hl = current time
0B13DF             0256*  tmr_set:
0B13DF FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B13E2             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B13E2 3E 08       0001*M 			LD	A, function
0B13E4 5B CF       0002*M 			RST.L	08h
0B13E6 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B13E9 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B13EC C9          0261*      ret
0B13ED             0262*  
0B13ED             0263*  ; gets time remaining on a countdown timer
0B13ED             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B13ED             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B13ED             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B13ED             0267*  tmr_get:
0B13ED             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B13ED 3E 08       0001*M 			LD	A, function
0B13EF 5B CF       0002*M 			RST.L	08h
0B13F1 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B13F4 FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B13F7 AF          0271*      xor a                   ; clear carry
0B13F8 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B13FA FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B13FD AF          0274*      xor a                   ; clear carry
0B13FE ED 5A       0275*      adc hl,de               ; hl = time remaining
0B1400             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1400 C9          0277*      ret
0B1401             0278*  
0B1401 00 00 00    0279*  timestamp_now: dl 0
0B1404 00 00 00    0280*  timestamp_old: dl 0
0B1407 00 00 00    0281*  timestamp_chg: dl 0
0B140A             0282*  
0B140A             0283*  ; update the global timestamp from the system clock
0B140A             0284*  ; inputs: none
0B140A             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B140A             0286*  ;          de = current time
0B140A             0287*  ;          ix = pointer to syvars table
0B140A             0288*  ; destroys: af,hl,de,ix
0B140A             0289*  timestamp_tick:
0B140A ED 5B 01 14 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B140F ED 53 04 14 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B1414             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1414 3E 08       0001*M 			LD	A, function
0B1416 5B CF       0002*M 			RST.L	08h
0B1418 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B141B 22 01 14 0B 0294*      ld (timestamp_now),hl   ; save current time
0B141F AF          0295*      xor a                   ; clear carry
0B1420 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B1422 22 07 14 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B1426 C9          0298*      ret
0B1427             0299*  
0B1427             0300*  ; set a countdown timer
0B1427             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1427             0302*  ; requires: timestamp_tick to be called at least once before this function
0B1427             0303*  ; returns: hl = current time
0B1427             0304*  ; destroys: hl
0B1427             0305*  timestamp_tmr_set:
0B1427 FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B142A 2A 01 14 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B142E FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B1431 C9          0309*      ret
0B1432             0310*  
0B1432             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B1432             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1432             0313*  ; requires: timestamp_tick to be called at least once before this function
0B1432             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1432             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1432             0316*  ; destroys: af,hl,de
0B1432             0317*  timestamp_tmr_get:
0B1432 ED 5B 01 14 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B1437 FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B143A AF          0320*      xor a                   ; clear carry
0B143B ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B143D FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B1440 AF          0323*      xor a                   ; clear carry
0B1441 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B1443             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1443 C9          0326*      ret
0B1444             0327*  
0B1444             0328*  ; main loop timer functions
0B1444             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B144A             0330*  
0B144A             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B144A             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B144A             0333*  ; returns: hl = current time
0B144A             0334*  ; destroys: af,hl,de,ix,iy
0B144A             0335*  tmr_main_loop_set:
0B144A FD 21 44 14 0336*      ld iy,tmr_main_loop
       0B          
0B144F FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B1452 CD 0A 14 0B 0338*      call timestamp_tick
0B1456 2A 01 14 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B145A FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B145D C9          0341*      ret
0B145E             0342*  
0B145E             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B145E             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B145E             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B145E             0346*  ; destroys: af,hl,de,ix,iy
0B145E             0347*  tmr_main_loop_get:
0B145E CD 0A 14 0B 0348*      call timestamp_tick
0B1462 FD 21 44 14 0349*      ld iy,tmr_main_loop
       0B          
0B1467 CD 32 14 0B 0350*      call timestamp_tmr_get
0B146B C9          0351*      ret
0B146C             0352*  
0B146C             0353*  ; set a stopwatch
0B146C             0354*  ; returns: hl = start time
0B146C             0355*  ; destroys: hl,ix
0B146C             0356*  stopwatch_set:
0B146C             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B146C 3E 08       0001*M 			LD	A, function
0B146E 5B CF       0002*M 			RST.L	08h
0B1470 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B1473 22 88 14 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B1477 C9          0360*      ret
0B1478             0361*  
0B1478             0362*  ; gets time elapsed on a stopwatch
0B1478             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B1478             0364*  ; destroys: af,hl,de,ix
0B1478             0365*  stopwatch_get:
0B1478             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1478 3E 08       0001*M 			LD	A, function
0B147A 5B CF       0002*M 			RST.L	08h
0B147C DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B147F ED 5B 88 14 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B1484 AF          0369*      xor a                   ; clear carry
0B1485 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B1487 C9          0371*      ret
0B1488             0372*  
0B1488             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B148B             0374*  
0B148B             0375*  ; ------------------
0B148B             0376*  ; delay routine
0B148B             0377*  ; Author: Richard Turrnidge
0B148B             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B148B             0379*  ; routine waits a fixed time,then returns
0B148B             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B148B             0381*  ; eg. ld A,00000100b
0B148B             0382*  
0B148B             0383*  multiPurposeDelay:
0B148B F5          0384*      push af
0B148C C5          0385*      push bc
0B148D DD E5       0386*      push ix
0B148F 47          0387*      ld b,a
0B1490 3E 08       0388*      ld a,$08
0B1492 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B1494             0390*  
0B1494             0391*  waitLoop:
0B1494             0392*  
0B1494 DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B1497             0394*  
0B1497             0395*                                  ;   we check if bit set is same as last time we checked.
0B1497             0396*                                  ;   bit 0 - don't use
0B1497             0397*                                  ;   bit 1 - changes 64 times per second
0B1497             0398*                                  ;   bit 2 - changes 32 times per second
0B1497             0399*                                  ;   bit 3 - changes 16 times per second
0B1497             0400*  
0B1497             0401*                                  ;   bit 4 - changes 8 times per second
0B1497             0402*                                  ;   bit 5 - changes 4 times per second
0B1497             0403*                                  ;   bit 6 - changes 2 times per second
0B1497             0404*                                  ;   bit 7 - changes 1 times per second
0B1497 A0          0405*      and b
0B1498 4F          0406*      ld c,a
0B1499 3A AA 14 0B 0407*      ld a,(oldTimeStamp)
0B149D B9          0408*      cp c                        ; is A same as last value?
0B149E 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B14A0 79          0410*      ld a,c
0B14A1 32 AA 14 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B14A5             0412*  
0B14A5 DD E1       0413*      pop ix
0B14A7 C1          0414*      pop bc
0B14A8 F1          0415*      pop af
0B14A9 C9          0416*      ret
0B14AA             0417*  
0B14AA 00          0418*  oldTimeStamp:   .db 00h
0B14AB             0025       include "vdu.inc"
0B14AB             0001*  
0B14AB             0002*  ; VDU 30: Home cursor
0B14AB             0003*  vdu_home_cursor:
0B14AB 3E 1E       0004*      ld a,30
0B14AD 5B D7       0005*  	rst.lil $10
0B14AF C9          0006*  	ret
0B14B0             0007*  
0B14B0             0008*  cursor_on:
0B14B0 21 BB 14 0B 0009*  	ld hl,@cmd
0B14B4 01 03 00 00 0010*  	ld bc,@end-@cmd
0B14B8 5B DF       0011*  	rst.lil $18
0B14BA C9          0012*  	ret
0B14BB             0013*  @cmd:
0B14BB 17 01 01    0014*  	db 23,1,1
0B14BE             0015*  @end:
0B14BE             0016*  
0B14BE             0017*  cursor_off:
0B14BE 21 C9 14 0B 0018*  	ld hl,@cmd
0B14C2 01 03 00 00 0019*  	ld bc,@end-@cmd
0B14C6 5B DF       0020*  	rst.lil $18
0B14C8 C9          0021*  	ret
0B14C9             0022*  @cmd:
0B14C9 17 01 00    0023*  	db 23,1,0
0B14CC             0024*  @end:
0B14CC             0025*  
0B14CC             0026*  ; VDU 9: Move cursor forward one character
0B14CC             0027*  vdu_cursor_forward:
0B14CC 3E 09       0028*      ld a,9
0B14CE 5B D7       0029*  	rst.lil $10
0B14D0 C9          0030*  	ret
0B14D1             0031*  
0B14D1             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B14D1             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B14D1             0034*  vdu_move_cursor:
0B14D1 ED 43 E2 14 0035*      ld (@x0),bc
       0B          
0B14D6 21 E1 14 0B 0036*  	ld hl,@cmd
0B14DA 01 03 00 00 0037*  	ld bc,@end-@cmd
0B14DE 5B DF       0038*  	rst.lil $18
0B14E0 C9          0039*  	ret
0B14E1 1F          0040*  @cmd: 	db 31
0B14E2 00          0041*  @x0:	db 0
0B14E3 00          0042*  @y0: 	db 0
0B14E4 00          0043*  @end: 	db 0 ; padding
0B14E5             0044*  
0B14E5             0045*  ; VDU 12: Clear text area (CLS)
0B14E5             0046*  vdu_cls:
0B14E5 3E 0C       0047*      ld a,12
0B14E7 5B D7       0048*  	rst.lil $10
0B14E9 C9          0049*  	ret
0B14EA             0050*  
0B14EA             0051*  vdu_flip:
0B14EA 21 F5 14 0B 0052*  	ld hl,@cmd
0B14EE 01 03 00 00 0053*  	ld bc,@end-@cmd
0B14F2 5B DF       0054*  	rst.lil $18
0B14F4 C9          0055*  	ret
0B14F5 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B14F8             0057*  @end:
0B14F8             0058*  
0B14F8             0059*  ; VDU 16: Clear graphics area (CLG)
0B14F8             0060*  vdu_clg:
0B14F8 3E 10       0061*      ld a,16
0B14FA 5B D7       0062*  	rst.lil $10
0B14FC C9          0063*  	ret
0B14FD             0064*  
0B14FD             0065*  ; COLOUR MODES
0B14FD             0066*  ; Mode	Effect
0B14FD             0067*  ; 0	Set on-screen pixel to target colour value
0B14FD             0068*  ; 1	OR value with the on-screen pixel
0B14FD             0069*  ; 2	AND value with the on-screen pixel
0B14FD             0070*  ; 3	XOR value with the on-screen pixel
0B14FD             0071*  ; 4	Invert the on-screen pixel
0B14FD             0072*  ; 5	No operation
0B14FD             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B14FD             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B14FD             0075*  
0B14FD             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B14FD             0077*  vdu_colour_text:
0B14FD 32 0D 15 0B 0078*  	ld (@arg),a
0B1501 21 0C 15 0B 0079*  	ld hl,@cmd
0B1505 01 02 00 00 0080*  	ld bc,@end-@cmd
0B1509 5B DF       0081*  	rst.lil $18
0B150B C9          0082*  	ret
0B150C 11          0083*  @cmd: db 17
0B150D 00          0084*  @arg: db 0
0B150E             0085*  @end:
0B150E             0086*  
0B150E             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B150E             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B150E             0089*  vdu_gcol:
0B150E 32 23 15 0B 0090*  	ld (@mode),a
0B1512 79          0091*      ld a,c
0B1513 32 24 15 0B 0092*      ld (@col),a
0B1517 21 22 15 0B 0093*  	ld hl,@cmd
0B151B 01 03 00 00 0094*  	ld bc,@end-@cmd
0B151F 5B DF       0095*  	rst.lil $18
0B1521 C9          0096*  	ret
0B1522 12          0097*  @cmd:  db 18
0B1523 00          0098*  @mode: db 0
0B1524 00          0099*  @col:  db 0
0B1525             0100*  @end:
0B1525             0101*  
0B1525             0102*  
0B1525             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B1525             0104*  ; MIND THE LITTLE-ENDIANESS
0B1525             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B1525             0106*  ; outputs; nothing
0B1525             0107*  ; destroys: a might make it out alive
0B1525             0108*  vdu_set_txt_viewport:
0B1525 ED 43 3B 15 0109*      ld (@lb),bc
       0B          
0B152A ED 53 3D 15 0110*  	ld (@rt),de
       0B          
0B152F 21 3A 15 0B 0111*  	ld hl,@cmd
0B1533 01 05 00 00 0112*  	ld bc,@end-@cmd
0B1537 5B DF       0113*  	rst.lil $18
0B1539 C9          0114*  	ret
0B153A 1C          0115*  @cmd:   db 28 ; set text viewport command
0B153B 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B153D 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B153F 00          0118*  @end:   db 0x00	  ; padding
0B1540             0119*  
0B1540             0120*  ; Wait for VBLANK interrupt
0B1540             0121*  vdu_vblank:
0B1540 DD E5       0122*      PUSH 	IX
0B1542             0123*  	MOSCALL	mos_sysvars
0B1542 3E 08       0001*M 			LD	A, function
0B1544 5B CF       0002*M 			RST.L	08h
0B1546 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B1549             0125*  @wait:
0B1549 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B154C 28 FB       0127*      JR	Z, @wait
0B154E DD E1       0128*      POP	IX
0B1550 C9          0129*      RET
0B1551             0130*  
0B1551             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B1551             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B1551             0133*  ; 	because we have turned off logical screen scaling
0B1551             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B1551             0135*  ; outputs; nothing
0B1551             0136*  ; destroys: a might make it out alive
0B1551             0137*  vdu_set_gfx_viewport:
0B1551 ED 43 71 15 0138*      ld (@x0),bc
       0B          
0B1556 FD 22 73 15 0139*      ld (@y1),iy
       0B          
0B155B DD 22 75 15 0140*  	ld (@x1),ix
       0B          
0B1560 ED 53 77 15 0141*  	ld (@y0),de
       0B          
0B1565 21 70 15 0B 0142*  	ld hl,@cmd
0B1569 01 09 00 00 0143*  	ld bc,@end-@cmd
0B156D 5B DF       0144*  	rst.lil $18
0B156F C9          0145*  	ret
0B1570 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B1571 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B1573 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B1575 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B1577 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B1579 00          0151*  @end:   db 0x00	  ; padding
0B157A             0152*  
0B157A             0153*  ; SCREEN MODES
0B157A             0154*  ; ===============================
0B157A             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B157A             0156*  ; ---   ----  ----  ----  -------
0B157A             0157*  ; 11    320   240   2     60hz
0B157A             0158*  ; 139   320   240   2     60hz
0B157A             0159*  ; 23    512   384   2     60hz
0B157A             0160*  ; 151   512   384   2     60hz
0B157A             0161*  ; 6     640   240   2     60hz
0B157A             0162*  ; 134   640   240   2     60hz
0B157A             0163*  ; 2     640   480   2     60hz
0B157A             0164*  ; 130   640   480   2     60hz
0B157A             0165*  ; 17    800   600   2     60hz
0B157A             0166*  ; 145   800   600   2     60hz
0B157A             0167*  ; 18    1024  768   2     60hz
0B157A             0168*  ; 146   1024  768   2     60hz
0B157A             0169*  ; ---   ----  ----  ----  -------
0B157A             0170*  ; 10    320   240   4     60hz
0B157A             0171*  ; 138   320   240   4     60hz
0B157A             0172*  ; 22    512   384   4     60hz
0B157A             0173*  ; 150   512   384   4     60hz
0B157A             0174*  ; 5     640   240   4     60hz
0B157A             0175*  ; 133   640   240   4     60hz
0B157A             0176*  ; 1     640   480   4     60hz
0B157A             0177*  ; 129   640   480   4     60hz
0B157A             0178*  ; 16    800   600   4     60hz
0B157A             0179*  ; 19    1024  768   4     60hz
0B157A             0180*  ; ---   ----  ----  ----  -------
0B157A             0181*  ; 9     320   240   16    60hz
0B157A             0182*  ; 137   320   240   16    60hz
0B157A             0183*  ; 21    512   384   16    60hz
0B157A             0184*  ; 149   512   384   16    60hz
0B157A             0185*  ; 4     640   240   16    60hz
0B157A             0186*  ; 132   640   240   16    60hz
0B157A             0187*  ; 0     640   480   16    60hz
0B157A             0188*  ; 7     n/a   n/a   16    60hz
0B157A             0189*  ; ---   ----  ----  ----  -------
0B157A             0190*  ; 8     320   240   64    60hz
0B157A             0191*  ; 136   320   240   64    60hz
0B157A             0192*  ; 20    512   384   64    60hz
0B157A             0193*  ; 3     640   240   64    60hz
0B157A             0194*  ; ---   ----  ----  ----  -------
0B157A             0195*  vdu_set_screen_mode:
0B157A 32 8A 15 0B 0196*  	ld (@arg),a
0B157E 21 89 15 0B 0197*  	ld hl,@cmd
0B1582 01 02 00 00 0198*  	ld bc,@end-@cmd
0B1586 5B DF       0199*  	rst.lil $18
0B1588 C9          0200*  	ret
0B1589 16          0201*  @cmd: db 22 ; set screen mode
0B158A 00          0202*  @arg: db 0  ; screen mode parameter
0B158B             0203*  @end:
0B158B             0204*  
0B158B             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B158B             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B158B             0207*  ; note: default setting on boot is scaling ON
0B158B             0208*  vdu_set_scaling:
0B158B 32 9D 15 0B 0209*  	ld (@arg),a
0B158F 21 9A 15 0B 0210*  	ld hl,@cmd
0B1593 01 04 00 00 0211*  	ld bc,@end-@cmd
0B1597 5B DF       0212*  	rst.lil $18
0B1599 C9          0213*  	ret
0B159A 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B159D 00          0215*  @arg: db 0  ; scaling on/off
0B159E             0216*  @end:
0B159E             0217*  
0B159E             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B159E             0219*  ; inputs: hl=bufferId
0B159E             0220*  vdu_buff_select:
0B159E 22 B0 15 0B 0221*  	ld (@bufferId),hl
0B15A2 21 AD 15 0B 0222*  	ld hl,@cmd
0B15A6 01 05 00 00 0223*  	ld bc,@end-@cmd
0B15AA 5B DF       0224*  	rst.lil $18
0B15AC C9          0225*  	ret
0B15AD 17 1B 20    0226*  @cmd: db 23,27,0x20
0B15B0 00 00       0227*  @bufferId: dw 0x0000
0B15B2 00          0228*  @end: db 0x00 ; padding
0B15B3             0229*  
0B15B3             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B15B3             0231*  ; inputs: a=format; bc=width; de=height
0B15B3             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B15B3             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B15B3             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B15B3             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B15B3             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B15B3             0237*  ; 3 	Reserved for internal use by VDP (“native” format)
0B15B3             0238*  vdu_bmp_create:
0B15B3 ED 43 CF 15 0239*      ld (@width),bc
       0B          
0B15B8 ED 53 D1 15 0240*      ld (@height),de
       0B          
0B15BD 32 D3 15 0B 0241*      ld (@fmt),a
0B15C1 21 CC 15 0B 0242*  	ld hl,@cmd
0B15C5 01 08 00 00 0243*  	ld bc,@end-@cmd
0B15C9 5B DF       0244*  	rst.lil $18
0B15CB C9          0245*  	ret
0B15CC 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B15CF 00 00       0247*  @width:     dw 0x0000
0B15D1 00 00       0248*  @height:    dw 0x0000
0B15D3 00          0249*  @fmt:       db 0x00
0B15D4             0250*  @end:
0B15D4             0251*  
0B15D4             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B15D4             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B15D4             0254*  vdu_load_img_rgba2_to_8:
0B15D4             0255*  ; backup the target buffer id and image dimensions
0B15D4 E5          0256*      push hl
0B15D5 D5          0257*      push de
0B15D6 C5          0258*      push bc
0B15D7             0259*  ; load the rgba2 image to working buffer 65534
0B15D7 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B15DB CD DE 16 0B 0261*  	call vdu_load_buffer_from_file
0B15DF             0262*  ; restore the image dimensions and target buffer id
0B15DF C1          0263*      pop bc
0B15E0 D1          0264*      pop de
0B15E1 E1          0265*      pop hl
0B15E2             0266*  ; fall through to vdu_rgba2_to_8
0B15E2             0267*  
0B15E2             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B15E2             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B15E2             0270*  ; the "expand bitmap" command is:
0B15E2             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B15E2             0272*  ; and then to reverse the byte order to fix endian-ness:
0B15E2             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B15E2             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B15E2             0275*  ; VDU 23,27,&20,targetBufferID%;
0B15E2             0276*  ; VDU 23,27,&21,width%;height%;0
0B15E2             0277*  ; -------------------------------------------------------------------
0B15E2             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B15E2             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B15E2             0280*  vdu_rgba2_to_8:
0B15E2             0281*  ; load the image dimensions and buffer id parameters
0B15E2 ED 43 3E 16 0282*      ld (@width),bc
       0B          
0B15E7 ED 53 40 16 0283*      ld (@height),de
       0B          
0B15EC 22 23 16 0B 0284*      ld (@bufferId0),hl
0B15F0 22 30 16 0B 0285*      ld (@bufferId2),hl
0B15F4 22 39 16 0B 0286*      ld (@bufferId1),hl
0B15F8             0287*  ; clean up bytes that got stomped on by the ID loads
0B15F8 3E 48       0288*      ld a,0x48
0B15FA 32 25 16 0B 0289*      ld (@bufferId0+2),a
0B15FE 3E 17       0290*      ld a,23
0B1600 32 3B 16 0B 0291*      ld (@bufferId1+2),a
0B1604 3E 18       0292*      ld a,24
0B1606 32 32 16 0B 0293*      ld (@bufferId2+2),a
0B160A AF          0294*      xor a
0B160B 32 42 16 0B 0295*      ld (@height+2),a
0B160F             0296*  ; send the vdu command strings
0B160F 21 1A 16 0B 0297*      ld hl,@beg
0B1613 01 29 00 00 0298*      ld bc,@end-@beg
0B1617 5B DF       0299*      rst.lil $18
0B1619 C9          0300*      ret
0B161A             0301*  @beg:
0B161A             0302*  ; Command 14: Consolidate blocks in a buffer
0B161A             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B161A 17 00 A0    0304*      db 23,0,0xA0
0B161D FE FF       0305*      dw 65534 ; workingBufferId
0B161F 0E          0306*      db 14 ; consolidate blocks
0B1620             0307*  ; the "expand bitmap" command is:
0B1620             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B1620 17 00 A0    0309*      db 23,0,0xA0
0B1623 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B1625 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B1626 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B1627 FE FF       0313*      dw 65534 ; sourceBufferId
0B1629 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B162D             0315*  ; reverse the byte order to fix endian-ness:
0B162D             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B162D             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B162D             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B162D 17 00 A0    0319*      db 23,0,0xA0
0B1630 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B1632 18          0321*      db 24 ; reverse byte order
0B1633 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B1634 04 00       0323*      dw 4 ; size (4 bytes)
0B1636             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B1636             0325*  ; VDU 23,27,&20,targetBufferID%;
0B1636 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B1639 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B163B             0328*  ; VDU 23,27,&21,width%;height%;0
0B163B 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B163E 00 00       0330*  @width: dw 0x0000
0B1640 00 00       0331*  @height: dw 0x0000
0B1642 00          0332*      db 0x00 ; rgba8888 format
0B1643             0333*  @end:
0B1643             0334*  
0B1643             0335*  ; scratch variables
0B1643 00 00 00    0336*  bufferId0: dl 0x000000
0B1646 00 00 00    0337*  bufferId1: dl 0x000000
0B1649             0338*  
0B1649             0339*  ; load a vdu buffer from local memory
0B1649             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1649             0341*  vdu_load_buffer:
0B1649 ED 43 72 16 0342*      ld (@length),bc
       0B          
0B164E D5          0343*      push de ; save data pointer
0B164F             0344*  ; send the vdu command string
0B164F 7D          0345*      ld a,l
0B1650 32 6F 16 0B 0346*      ld (@bufferId),a
0B1654 7C          0347*      ld a,h
0B1655 32 70 16 0B 0348*      ld (@bufferId+1),a
0B1659 21 6C 16 0B 0349*      ld hl,@cmd
0B165D 01 08 00 00 0350*      ld bc,@end-@cmd
0B1661 5B DF       0351*      rst.lil $18
0B1663             0352*  ; send the buffer data
0B1663 E1          0353*      pop hl ; pointer to data
0B1664 ED 4B 72 16 0354*      ld bc,(@length)
       0B          
0B1669 5B DF       0355*      rst.lil $18 ; send it
0B166B C9          0356*      ret
0B166C             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B166C 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B166F 00 00       0359*  @bufferId:	dw 0x0000
0B1671 00          0360*  		    db 0 ; load buffer
0B1672 00 00       0361*  @length:	dw 0x0000
0B1674 00          0362*  @end: db 0 ; padding
0B1675             0363*  
0B1675             0364*  ; clear a buffer
0B1675             0365*  ; inputs: hl = bufferId
0B1675             0366*  vdu_clear_buffer:
0B1675 7D          0367*      ld a,l
0B1676 32 8D 16 0B 0368*      ld (@bufferId),a
0B167A 7C          0369*      ld a,h
0B167B 32 8E 16 0B 0370*      ld (@bufferId+1),a
0B167F 21 8A 16 0B 0371*      ld hl,@cmd
0B1683 01 06 00 00 0372*      ld bc,@end-@cmd
0B1687 5B DF       0373*      rst.lil $18
0B1689 C9          0374*      ret
0B168A 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B168D 00 00       0376*  @bufferId:	dw 0x0000
0B168F 02          0377*  		    db 2 ; clear buffer
0B1690             0378*  @end:
0B1690             0379*  
0B1690             0380*  vdu_clear_all_buffers:
0B1690             0381*  ; clear all buffers
0B1690 21 9B 16 0B 0382*      ld hl,@beg
0B1694 01 06 00 00 0383*      ld bc,@end-@beg
0B1698 5B DF       0384*      rst.lil $18
0B169A C9          0385*      ret
0B169B 17 00 A0    0386*  @beg: db 23,0,$A0
0B169E FF FF       0387*        dw -1 ; clear all buffers
0B16A0 02          0388*        db 2  ; command 2: clear a buffer
0B16A1             0389*  @end:
0B16A1             0390*  
0B16A1             0391*  ; Command 14: Consolidate blocks in a buffer
0B16A1             0392*  vdu_consolidate_buffer:
0B16A1             0393*  ; set parameters for vdu call
0B16A1 7D          0394*      ld a,l
0B16A2 32 B9 16 0B 0395*      ld (@bufferId),a
0B16A6 7C          0396*      ld a,h
0B16A7 32 BA 16 0B 0397*      ld (@bufferId+1),a
0B16AB 21 B6 16 0B 0398*      ld hl,@beg
0B16AF 01 06 00 00 0399*      ld bc,@end-@beg
0B16B3 5B DF       0400*      rst.lil $18
0B16B5 C9          0401*      ret
0B16B6             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B16B6 17 00 A0    0403*  @beg: db 23,0,0xA0
0B16B9 00 00       0404*  @bufferId: dw 0x0000
0B16BB 0E          0405*             db 14
0B16BC             0406*  @end:
0B16BC             0407*  
0B16BC             0408*  ; load an image file to a buffer and make it a bitmap
0B16BC             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B16BC             0410*  vdu_load_img:
0B16BC             0411*  ; back up image type and dimension parameters
0B16BC 22 43 16 0B 0412*      ld (bufferId0),hl
0B16C0 F5          0413*      push af
0B16C1 C5          0414*  	push bc
0B16C2 D5          0415*  	push de
0B16C3             0416*  ; load the image
0B16C3 CD DE 16 0B 0417*  	call vdu_load_buffer_from_file
0B16C7             0418*  ; now make it a bitmap
0B16C7 2A 43 16 0B 0419*      ld hl,(bufferId0)
0B16CB CD A1 16 0B 0420*      call vdu_consolidate_buffer
0B16CF 2A 43 16 0B 0421*      ld hl,(bufferId0)
0B16D3 CD 9E 15 0B 0422*      call vdu_buff_select
0B16D7 D1          0423*  	pop de ; image height
0B16D8 C1          0424*  	pop bc ; image width
0B16D9 F1          0425*  	pop af ; image type
0B16DA C3 B3 15 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B16DE             0427*  
0B16DE             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B16DE             0429*  vdu_load_buffer_from_file:
0B16DE 22 43 16 0B 0430*      ld (bufferId0),hl
0B16E2             0431*  
0B16E2             0432*  ; clear target buffer
0B16E2 CD 75 16 0B 0433*      call vdu_clear_buffer
0B16E6             0434*  
0B16E6             0435*  ; open the file in read mode
0B16E6             0436*  ; Open a file
0B16E6             0437*  ; HLU: Filename
0B16E6             0438*  ;   C: Mode
0B16E6             0439*  ; Returns:
0B16E6             0440*  ;   A: Filehandle, or 0 if couldn't open
0B16E6 FD E5       0441*  	push iy ; pointer to filename
0B16E8 E1          0442*  	pop hl
0B16E9 0E 01       0443*  	ld c,fa_read
0B16EB             0444*      MOSCALL mos_fopen
0B16EB 3E 0A       0001*M 			LD	A, function
0B16ED 5B CF       0002*M 			RST.L	08h
0B16EF 32 2A 17 0B 0445*      ld (@filehandle),a
0B16F3             0446*  
0B16F3             0447*  @read_file:
0B16F3             0448*  ; Read a block of data from a file
0B16F3             0449*  ;   C: Filehandle
0B16F3             0450*  ; HLU: Pointer to where to write the data to
0B16F3             0451*  ; DEU: Number of bytes to read
0B16F3             0452*  ; Returns:
0B16F3             0453*  ; DEU: Number of bytes read
0B16F3 3A 2A 17 0B 0454*      ld a,(@filehandle)
0B16F7 4F          0455*      ld c,a
0B16F8 21 00 E0 B7 0456*      ld hl,filedata
0B16FC 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B1700             0458*      MOSCALL mos_fread
0B1700 3E 1A       0001*M 			LD	A, function
0B1702 5B CF       0002*M 			RST.L	08h
0B1704             0459*  
0B1704             0460*  ; ; DEBUG: print chunk size
0B1704             0461*  ;     push de
0B1704             0462*  ;     pop hl
0B1704             0463*  ;     call printDec
0B1704             0464*  ;     call printNewLine
0B1704             0465*  
0B1704             0466*  ; test de for zero bytes read
0B1704 21 00 00 00 0467*      ld hl,0
0B1708 AF          0468*      xor a ; clear carry
0B1709 ED 52       0469*      sbc hl,de
0B170B CA 21 17 0B 0470*      jp z,@close_file
0B170F             0471*  
0B170F             0472*  ; load a vdu buffer from local memory
0B170F             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B170F 2A 43 16 0B 0474*      ld hl,(bufferId0)
0B1713 D5          0475*      push de ; chunksize
0B1714 C1          0476*      pop bc
0B1715 11 00 E0 B7 0477*      ld de,filedata
0B1719 CD 49 16 0B 0478*      call vdu_load_buffer
0B171D             0479*  
0B171D             0480*  ; ; print progress breadcrumbs
0B171D             0481*  ;     ld a,'.'
0B171D             0482*  ;     rst.lil 10h
0B171D             0483*  
0B171D             0484*  ; read the next block
0B171D C3 F3 16 0B 0485*      jp @read_file
0B1721             0486*  
0B1721             0487*  ; close the file
0B1721             0488*  @close_file:
0B1721 3A 2A 17 0B 0489*      ld a,(@filehandle)
0B1725             0490*      MOSCALL mos_fclose
0B1725 3E 0B       0001*M 			LD	A, function
0B1727 5B CF       0002*M 			RST.L	08h
0B1729 C9          0491*      ret ; vdu_load_buffer_from_file
0B172A             0492*  
0B172A 00          0493*  @filehandle: db 0 ; file handle
0B172B 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B172E             0495*  
0B172E 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B1731             0497*  
0B1731             0498*  ; File information structure (FILINFO)
0B1731             0499*  @filinfo:
0B1731 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B1735 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B1737 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B1739 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B173A 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B1747 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B1847             0026       ; include "vdu_fonts.inc"
0B1847             0027       include "vdu_plot.inc"
0B1847             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1847             0002*  ; PLOT code 	(Decimal) 	Effect
0B1847             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B1847             0004*  plot_sl_both: equ 0x00
0B1847             0005*  
0B1847             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B1847             0007*  plot_sl_first: equ 0x08
0B1847             0008*  
0B1847             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B1847             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B1847             0011*  
0B1847             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B1847             0013*  plot_sl_last: equ 0x20
0B1847             0014*  
0B1847             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B1847             0016*  plot_sl_none: equ 0x28
0B1847             0017*  
0B1847             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B1847             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B1847             0020*  
0B1847             0021*  ; &40-&47 	64-71 	Point plot
0B1847             0022*  plot_pt: equ 0x40
0B1847             0023*  
0B1847             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0B1847             0025*  plot_lf_lr_non_bg: equ 0x48
0B1847             0026*  
0B1847             0027*  ; &50-&57 	80-87 	Triangle fill
0B1847             0028*  plot_tf: equ 0x50
0B1847             0029*  
0B1847             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0B1847             0031*  plot_lf_r_bg: equ 0x58
0B1847             0032*  
0B1847             0033*  ; &60-&67 	96-103 	Rectangle fill
0B1847             0034*  plot_rf: equ 0x60
0B1847             0035*  
0B1847             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0B1847             0037*  plot_lf_lr_fg: equ 0x60
0B1847             0038*  
0B1847             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B1847             0040*  plot_pf: equ 0x70
0B1847             0041*  
0B1847             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0B1847             0043*  plot_lf_r_non_fg: equ 0x78
0B1847             0044*  
0B1847             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B1847             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B1847             0047*  
0B1847             0048*  ; &90-&97 	144-151 	Circle outline
0B1847             0049*  plot_co: equ 0x90
0B1847             0050*  
0B1847             0051*  ; &98-&9F 	152-159 	Circle fill
0B1847             0052*  plot_cf: equ 0x98
0B1847             0053*  
0B1847             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B1847             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B1847             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B1847             0057*  
0B1847             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B1847             0059*  plot_rcm: equ 0xB8
0B1847             0060*  
0B1847             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B1847             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B1847             0063*  ; &D0-&D7 	208-215 	Not defined
0B1847             0064*  ; &D8-&DF 	216-223 	Not defined
0B1847             0065*  ; &E0-&E7 	224-231 	Not defined
0B1847             0066*  
0B1847             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0B1847             0068*  plot_bmp: equ 0xE8
0B1847             0069*  
0B1847             0070*  ; &F0-&F7 	240-247 	Not defined
0B1847             0071*  ; &F8-&FF 	248-255 	Not defined
0B1847             0072*  
0B1847             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0B1847             0074*  ; Agon Console8 VDP 2.2.0
0B1847             0075*  
0B1847             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B1847             0077*  ; Plot code 	Effect
0B1847             0078*  ; 0 	Move relative
0B1847             0079*  mv_rel: equ 0
0B1847             0080*  
0B1847             0081*  ; 1 	Plot relative in current foreground colour
0B1847             0082*  dr_rel_fg: equ 1
0B1847             0083*  
0B1847             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B1847             0085*  ; 3 	Plot relative in current background colour
0B1847             0086*  dr_rel_bg: equ 3
0B1847             0087*  
0B1847             0088*  ; 4 	Move absolute
0B1847             0089*  mv_abs: equ 4
0B1847             0090*  
0B1847             0091*  ; 5 	Plot absolute in current foreground colour
0B1847             0092*  dr_abs_fg: equ 5
0B1847             0093*  
0B1847             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B1847             0095*  ; 7 	Plot absolute in current background colour
0B1847             0096*  dr_abs_bg: equ 7
0B1847             0097*  
0B1847             0098*  ; Codes 0-3 use the position data provided as part of the command
0B1847             0099*  ; as a relative position, adding the position given to the current
0B1847             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B1847             0101*  ; as part of the command as an absolute position, setting the current
0B1847             0102*  ; graphical cursor position to the position given.
0B1847             0103*  
0B1847             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B1847             0105*  ; current pixel colour. These operations cannot currently be supported
0B1847             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B1847             0107*  ; supported. Support for these codes may be added in a future version
0B1847             0108*  ; of the VDP firmware.
0B1847             0109*  
0B1847             0110*  ; 16 colour palette constants
0B1847             0111*  c_black: equ 0
0B1847             0112*  c_red_dk: equ 1
0B1847             0113*  c_green_dk: equ 2
0B1847             0114*  c_yellow_dk: equ 3
0B1847             0115*  c_blue_dk: equ 4
0B1847             0116*  c_magenta_dk: equ 5
0B1847             0117*  c_cyan_dk: equ 6
0B1847             0118*  c_grey: equ 7
0B1847             0119*  c_grey_dk: equ 8
0B1847             0120*  c_red: equ 9
0B1847             0121*  c_green: equ 10
0B1847             0122*  c_yellow: equ 11
0B1847             0123*  c_blue: equ 12
0B1847             0124*  c_magenta: equ 13
0B1847             0125*  c_cyan: equ 14
0B1847             0126*  c_white: equ 15
0B1847             0127*  
0B1847             0128*  ; VDU 25, mode, x; y;: PLOT command
0B1847             0129*  ; inputs: a=mode, bc=x0, de=y0
0B1847             0130*  vdu_plot:
0B1847 32 61 18 0B 0131*      ld (@mode),a
0B184B ED 43 62 18 0132*      ld (@x0),bc
       0B          
0B1850 ED 53 64 18 0133*      ld (@y0),de
       0B          
0B1855 21 60 18 0B 0134*  	ld hl,@cmd
0B1859 01 06 00 00 0135*  	ld bc,@end-@cmd
0B185D 5B DF       0136*  	rst.lil $18
0B185F C9          0137*  	ret
0B1860 19          0138*  @cmd:   db 25
0B1861 00          0139*  @mode:  db 0
0B1862 00 00       0140*  @x0: 	dw 0
0B1864 00 00       0141*  @y0: 	dw 0
0B1866 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B1867             0143*  
0B1867             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1867             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
0B1867             0146*  ; VDU 25, mode, x; y;: PLOT command
0B1867             0147*  ; inputs: bc=x0, de=y0
0B1867             0148*  ; prerequisites: vdu_buff_select
0B1867             0149*  vdu_plot_bmp:
0B1867 ED 43 7E 18 0150*      ld (@x0),bc
       0B          
0B186C ED 53 80 18 0151*      ld (@y0),de
       0B          
0B1871 21 7C 18 0B 0152*  	ld hl,@cmd
0B1875 01 06 00 00 0153*  	ld bc,@end-@cmd
0B1879 5B DF       0154*  	rst.lil $18
0B187B C9          0155*  	ret
0B187C 19          0156*  @cmd:   db 25
0B187D ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B187E 00 00       0158*  @x0: 	dw 0x0000
0B1880 00 00       0159*  @y0: 	dw 0x0000
0B1882 00          0160*  @end:   db 0x00 ; padding
0B1883             0161*  
0B1883             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1883             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
0B1883             0164*  ; VDU 25, mode, x; y;: PLOT command
0B1883             0165*  ; inputs: bc=x0, de=y0
0B1883             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B1883             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B1883             0168*  ;   the fractional portiion of the inputs are truncated
0B1883             0169*  ;   leaving only the 16-bit integer portion
0B1883             0170*  ; prerequisites: vdu_buff_select
0B1883             0171*  vdu_plot_bmp168:
0B1883             0172*  ; populate in the reverse of normal to keep the
0B1883             0173*  ; inputs from stomping on each other
0B1883 ED 53 A1 18 0174*      ld (@y0-1),de
       0B          
0B1888 ED 43 9F 18 0175*      ld (@x0-1),bc
       0B          
0B188D 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B188F 32 9F 18 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B1893 21 9E 18 0B 0178*  	ld hl,@cmd
0B1897 01 06 00 00 0179*  	ld bc,@end-@cmd
0B189B 5B DF       0180*  	rst.lil $18
0B189D C9          0181*  	ret
0B189E 19          0182*  @cmd:   db 25
0B189F ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B18A0 00 00       0184*  @x0: 	dw 0x0000
0B18A2 00 00       0185*  @y0: 	dw 0x0000
0B18A4             0186*  @end:  ; no padding required b/c we shifted de right
0B18A4             0187*  
0B18A4             0188*  ; draw a filled rectangle
0B18A4             0189*  vdu_plot_rf:
0B18A4 ED 43 CB 18 0190*      ld (@x0),bc
       0B          
0B18A9 ED 53 CD 18 0191*      ld (@y0),de
       0B          
0B18AE DD 22 D1 18 0192*      ld (@x1),ix
       0B          
0B18B3 FD 22 D3 18 0193*      ld (@y1),iy
       0B          
0B18B8 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B18BA 32 CF 18 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B18BE 21 C9 18 0B 0196*  	ld hl,@cmd0
0B18C2 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B18C6 5B DF       0198*  	rst.lil $18
0B18C8 C9          0199*      ret
0B18C9 19          0200*  @cmd0:  db 25 ; plot
0B18CA 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B18CB 00 00       0202*  @x0:    dw 0x0000
0B18CD 00 00       0203*  @y0:    dw 0x0000
0B18CF 19          0204*  @cmd1:  db 25 ; plot
0B18D0 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B18D1 00 00       0206*  @x1:    dw 0x0000
0B18D3 00 00       0207*  @y1:    dw 0x0000
0B18D5 00          0208*  @end:   db 0x00 ; padding
0B18D6             0209*  
0B18D6             0210*  ; draw a filled circle
0B18D6             0211*  vdu_plot_cf:
0B18D6 ED 43 FD 18 0212*      ld (@x0),bc
       0B          
0B18DB ED 53 FF 18 0213*      ld (@y0),de
       0B          
0B18E0 DD 22 03 19 0214*      ld (@x1),ix
       0B          
0B18E5 FD 22 05 19 0215*      ld (@y1),iy
       0B          
0B18EA 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B18EC 32 01 19 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B18F0 21 FB 18 0B 0218*  	ld hl,@cmd0
0B18F4 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B18F8 5B DF       0220*  	rst.lil $18
0B18FA C9          0221*      ret
0B18FB 19          0222*  @cmd0:  db 25 ; plot
0B18FC 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B18FD 00 00       0224*  @x0:    dw 0x0000
0B18FF 00 00       0225*  @y0:    dw 0x0000
0B1901 19          0226*  @cmd1:  db 25 ; plot
0B1902 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B1903 00 00       0228*  @x1:    dw 0x0000
0B1905 00 00       0229*  @y1:    dw 0x0000
0B1907 00          0230*  @end:   db 0x00 ; padding
0B1908             0231*  
0B1908             0232*  ; VDU 25, mode, x; y;: PLOT command
0B1908             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B1908             0234*  plot:
0B1908 32 22 19 0B 0235*      ld (@mode),a
0B190C DD 22 23 19 0236*      ld (@x0),ix
       0B          
0B1911 FD 22 25 19 0237*      ld (@y0),iy
       0B          
0B1916 21 21 19 0B 0238*  	ld hl,@cmd
0B191A 01 06 00 00 0239*  	ld bc,@end-@cmd
0B191E 5B DF       0240*  	rst.lil $18
0B1920 C9          0241*  	ret
0B1921 19          0242*  @cmd:   db 25
0B1922 00          0243*  @mode:  db 0
0B1923 00 00       0244*  @x0: 	dw 0
0B1925 00 00       0245*  @y0: 	dw 0
0B1927 00          0246*  @end:   db 0 ; padding
0B1928             0247*  
0B1928             0248*  ; VDU 5: Write text at graphics cursor
0B1928             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B1928             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B1928             0251*  plot_text:
0B1928 E5          0252*      push hl ; save text pointer
0B1929             0253*  ; move graphics cursor to x0, y0
0B1929 3E 44       0254*      ld a,plot_pt+mv_abs
0B192B CD 08 19 0B 0255*      call plot
0B192F             0256*  ; write text
0B192F E1          0257*      pop hl ; restore text pointer
0B1930 CD 73 02 0B 0258*      call printString
0B1934 C9          0259*      ret
0B1935             0028   
0B1935             0029   ; SHAWN'S INCLUDES
0B1935             0030   	INCLUDE	"strings24.asm"
0B1935             0001*  ;------------------------------------------------------------------------
0B1935             0002*  ;  strings24.asm
0B1935             0003*  ;
0B1935             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B1935             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B1935             0006*  ;  MIT license
0B1935             0007*  ;------------------------------------------------------------------------
0B1935             0008*  
0B1935             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B1935             0010*  ; and postpended with a minus sign if was negative
0B1935             0011*  ; Uses HLU, DEU, BCU
0B1935             0012*  print_HLU_s24:
0B1935 CD 6D 07 0B 0013*  	call abs_hlu
0B1939 F5          0014*  	push af ; save the sign and zero flags
0B193A CD 45 19 0B 0015*  	call print_HLU_u24
0B193E F1          0016*  	pop af
0B193F F0          0017*  	ret p ; HLU was positive so nothig more to do
0B1940 3E 2D       0018*  	ld a,'-'
0B1942 5B D7       0019*  	rst.lil 10h
0B1944 C9          0020*  	ret
0B1945             0021*  
0B1945             0022*  ;------------------------------------------------------------------------
0B1945             0023*  ;Full print and buffer routine so you can adjust behaviour
0B1945             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B1945             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B1945             0026*  ;Print value in HLU in decimal with leading 0s removed
0B1945             0027*  ; Uses HLU, DEU, BCU
0B1945             0028*  ;------------------------------------------------------------------------
0B1945             0029*  
0B1945             0030*  print_HLU_u24:
0B1945 22 22 1A 0B 0031*  	ld	(hex_temp),hl
0B1949 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B194B 11 25 1A 0B 0033*  	ld	de,outbuf
0B194F D5          0034*  	push	de
0B1950 21 07 00 00 0035*  	ld	hl,7
0B1954 19          0036*  	add	hl,de
0B1955 E5          0037*  	push	hl
0B1956 D1          0038*  	pop	de	;copy HLU to DEU
0B1957 AF          0039*  	xor	a
0B1958             0040*  _pde_u_zerobuf:
0B1958 77          0041*  	ld	(hl),a	;zero out the output
0B1959 2B          0042*  	dec	hl
0B195A 10 FC       0043*  	djnz	_pde_u_zerobuf
0B195C             0044*  
0B195C 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B195E             0046*  _bcd_Convert:
0B195E             0047*  
0B195E 21 22 1A 0B 0048*  	ld hl,hex_temp
0B1962             0049*  ;
0B1962 CB 26       0050*  	sla (hl)
0B1964 23          0051*  	inc hl
0B1965 CB 16       0052*  	rl (hl)
0B1967 23          0053*  	inc hl
0B1968 CB 16       0054*  	rl (hl)		;24 bits rolled right
0B196A             0055*  
0B196A             0056*  
0B196A 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B196C D5          0058*  	push	de
0B196D E1          0059*  	pop	hl
0B196E             0060*  
0B196E             0061*  _bcd_Add3:
0B196E 7E          0062*  	ld	a,(hl)
0B196F 8F          0063*  	adc	a
0B1970 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B1971 FE 10       0065*  	cp	10h	;did we roll over nibble?
0B1973 3F          0066*  	ccf
0B1974 CB A7       0067*  	res	4,a
0B1976             0068*  
0B1976 77          0069*          ld (hl),a
0B1977 2B          0070*  	dec	hl
0B1978 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B197A 0D          0072*          dec c
0B197B 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B197D             0074*  
0B197D             0075*  
0B197D E1          0076*  	pop	hl
0B197E E5          0077*  	push	hl
0B197F 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B1981             0079*  _pde_u_make_ascii:
0B1981 7E          0080*  	ld	a,(hl)
0B1982 B7          0081*  	or	a
0B1983 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B1985 36 20       0083*  	ld	(hl),' '
0B1987 23          0084*  	inc	hl
0B1988 10 F7       0085*  	djnz	_pde_u_make_ascii
0B198A             0086*  _pde_u_make_ascii2:
0B198A 04          0087*  	inc	b
0B198B             0088*  _pde_u_make_ascii3:
0B198B 7E          0089*  	ld	a,(hl)
0B198C F6 30       0090*  	or	30h
0B198E 77          0091*  	ld	(hl),a
0B198F 23          0092*  	inc	hl
0B1990 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B1992             0094*  
0B1992 E1          0095*  	pop	hl
0B1993 06 08       0096*  	ld	b,8
0B1995             0097*  _pde_u_final_out:
0B1995 7E          0098*  	ld	a,(hl)
0B1996 23          0099*  	inc	hl
0B1997 FE 20       0100*  	cp	' '
0B1999 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B199B 5B D7       0102*  	rst.lil	10h
0B199D             0103*  _pde_u_final_out_strip:
0B199D 10 F6       0104*  	djnz	_pde_u_final_out
0B199F C9          0105*  	ret
0B19A0             0106*  
0B19A0             0107*  ;------------------------------------------------------------------------
0B19A0             0108*  ; is_digit
0B19A0             0109*  ; C flag set if A is a digit
0B19A0             0110*  ; preserves all registers
0B19A0             0111*  ;------------------------------------------------------------------------
0B19A0             0112*  is_digit:
0B19A0 FE 30       0113*  	cp	'0'
0B19A2 3F          0114*  	ccf
0B19A3 D0          0115*  	ret	nc	;less that '0'
0B19A4 FE 3A       0116*  	cp	'9' + 1
0B19A6 C9          0117*  	ret
0B19A7             0118*  
0B19A7             0119*  
0B19A7             0120*  ;------------------------------------------------------------------------
0B19A7             0121*  ; char2hex
0B19A7             0122*  ; Input: ASCII nibble in A
0B19A7             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B19A7             0124*  ;------------------------------------------------------------------------
0B19A7             0125*  char2hex:
0B19A7 FE 30       0126*  	CP	'0'
0B19A9 38 1D       0127*  	JR	C, char_not_hex
0B19AB FE 3A       0128*  	CP	'9' + 1
0B19AD 30 03       0129*  	JR	NC, char_not_09
0B19AF D6 30       0130*  	sub	'0'
0B19B1 C9          0131*  	ret
0B19B2             0132*  
0B19B2             0133*  char_not_09:
0B19B2             0134*  	; char is not 0 to 9. Try upper case
0B19B2 FE 41       0135*  	CP	'A'
0B19B4 38 12       0136*  	JR	C, char_not_hex
0B19B6 FE 47       0137*  	CP	'F' + 1
0B19B8 30 03       0138*  	JR	NC, char_not_AF
0B19BA D6 37       0139*  	sub	'A'-10
0B19BC C9          0140*  	ret
0B19BD             0141*  
0B19BD             0142*  char_not_AF:
0B19BD             0143*  	; char is not upper case A-F. Try lower
0B19BD FE 61       0144*  	CP	'a'
0B19BF 38 07       0145*  	JR	C, char_not_hex
0B19C1 FE 67       0146*  	CP	'f' + 1
0B19C3 30 03       0147*  	JR	NC, char_not_hex
0B19C5 D6 57       0148*  	sub	'a' - 10
0B19C7 C9          0149*  	RET
0B19C8             0150*  
0B19C8             0151*  char_not_hex:
0B19C8 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B19CA C9          0153*  	RET
0B19CB             0154*  
0B19CB             0155*  ;------------------------------------------------------------------------
0B19CB             0156*  ;  newline
0B19CB             0157*  ;  Output CR+LF; all registers preserved
0B19CB             0158*  ;------------------------------------------------------------------------
0B19CB             0159*  newline:
0B19CB F5          0160*         push   AF
0B19CC 3E 0D       0161*         LD     A, 13
0B19CE 5B D7       0162*         RST.LIL    10h
0B19D0 3E 0A       0163*         LD     A, 10
0B19D2 5B D7       0164*         RST.LIL    10h
0B19D4 F1          0165*         POP    AF
0B19D5 C9          0166*         RET
0B19D6             0167*  
0B19D6             0168*  ;------------------------------------------------------------------------
0B19D6             0169*  ;  put_nibble
0B19D6             0170*  ;  Output a single hex nibble in A
0B19D6             0171*  ;  All registers preserved
0B19D6             0172*  ;------------------------------------------------------------------------
0B19D6             0173*  put_nibble:
0B19D6 F5          0174*  	push   AF
0B19D7 C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B19D9 27          0176*  	daa
0B19DA CE 40       0177*  	adc    a,040h
0B19DC 27          0178*  	daa
0B19DD 5B D7       0179*  	RST.LIL    10h	;output character in A
0B19DF F1          0180*  	pop    AF
0B19E0 C9          0181*  	ret
0B19E1             0182*  
0B19E1             0183*  ;------------------------------------------------------------------------
0B19E1             0184*  ;  print_A
0B19E1             0185*  ;  Output the 8-bit hex number A
0B19E1             0186*  ;  All registers preserved
0B19E1             0187*  ;------------------------------------------------------------------------
0B19E1             0188*  print_A:
0B19E1 F5          0189*  	push 	AF
0B19E2 F5          0190*  	push 	AF	;save for second nibble
0B19E3 0F          0191*  	rrca
0B19E4 0F          0192*  	rrca
0B19E5 0F          0193*  	rrca
0B19E6 0F          0194*  	rrca
0B19E7 E6 0F       0195*  	and	0Fh	;first nibble
0B19E9 CD D6 19 0B 0196*  	call	put_nibble
0B19ED F1          0197*  	pop 	AF
0B19EE E6 0F       0198*  	and	0Fh	;second nibble
0B19F0 CD D6 19 0B 0199*  	call	put_nibble
0B19F4 F1          0200*  	pop 	AF
0B19F5 C9          0201*  	ret
0B19F6             0202*  
0B19F6             0203*  ;------------------------------------------------------------------------
0B19F6             0204*  ;  print_HLU_hex
0B19F6             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B19F6             0206*  ;------------------------------------------------------------------------
0B19F6             0207*  print_HLU_hex:
0B19F6 F5          0208*         push   AF
0B19F7 22 22 1A 0B 0209*         ld     (hex_temp),hl
0B19FB 3A 24 1A 0B 0210*         ld     a,(hex_temp+2)
0B19FF CD E1 19 0B 0211*         call   print_A
0B1A03 3A 23 1A 0B 0212*         ld     a,(hex_temp+1)
0B1A07 CD E1 19 0B 0213*         call   print_A
0B1A0B 3A 22 1A 0B 0214*         ld     a,(hex_temp)
0B1A0F CD E1 19 0B 0215*         call   print_A
0B1A13 F1          0216*         POP    AF
0B1A14 C9          0217*         RET
0B1A15             0218*  
0B1A15             0219*  ;------------------------------------------------------------------------
0B1A15             0220*  ;  puts
0B1A15             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B1A15             0222*  ;  registers preserved.
0B1A15             0223*  ;------------------------------------------------------------------------
0B1A15             0224*  puts:
0B1A15 F5          0225*         push   AF
0B1A16 C5          0226*         push   BC
0B1A17 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B1A1B 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B1A1D 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B1A1F C1          0230*         pop    BC
0B1A20 F1          0231*         pop    AF
0B1A21 C9          0232*         ret
0B1A22             0233*  
0B1A22             0234*  ;------------------------------------------------------------------------
0B1A22             0235*  ; Data area
0B1A22             0236*  ; Storage for 24 bit conversion
0B1A22             0237*  ;------------------------------------------------------------------------
0B1A22             0238*  hex_temp:
0B1A22 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B1A25             0240*  
0B1A25             0241*  outbuf:
0B1A25 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B1A2E             0031   
0B1A2E             0032   ; APPLICATION INCLUDES
0B1A2E 55 73 61 67 0033   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B1A46 45 72 72 6F 0034   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B1A4F 53 75 63 63 0035   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1A5A             0036   
0B1A5A             0037   ; This is a scratch moslet for testing new features
0B1A5A             0038   ; Parameters:
0B1A5A             0039   ;
0B1A5A             0040   
0B1A5A             0041   ; ========= BOILERPLATE MAIN LOOP =========
0B1A5A             0042   ; The main routine
0B1A5A             0043   ; IXU: argv - pointer to array of parameters
0B1A5A             0044   ;   C: argc - number of parameters
0B1A5A             0045   ; Returns:
0B1A5A             0046   ;  HL: Error code, or 0 if OK
0B1A5A             0047   
0B1A5A             0048   min_args: equ 3
0B1A5A             0049   
0B1A5A             0050   _main:
0B1A5A 79          0051       ld a,c              ; how many arguments?
0B1A5B FE 03       0052       cp min_args         ; not enough?
0B1A5D 30 1A       0053       jr nc,main          ; if enough, go to main loop
0B1A5F 21 2E 1A 0B 0054       ld hl,str_usage     ; if not enough, print usage
0B1A63 CD 73 02 0B 0055       call printString
0B1A67             0056                           ; fall through to _main_end_error
0B1A67             0057   
0B1A67             0058   _main_end_error:
0B1A67 21 46 1A 0B 0059       ld hl,str_error     ; print error message
0B1A6B CD 73 02 0B 0060       call printString
0B1A6F 21 13 00 00 0061       ld hl,19            ; return error code 19
0B1A73 C9          0062       ret
0B1A74             0063   
0B1A74             0064   _main_end_ok:
0B1A74             0065       ; ld hl,str_success   ; print success message
0B1A74             0066       ; call printString
0B1A74 21 00 00 00 0067       ld hl,0             ; return 0 for success
0B1A78 C9          0068       ret
0B1A79             0069   
0B1A79             0070   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B1A79             0071   main:
0B1A79 0D          0072       dec c               ; decrement the argument count to skip the program name
0B1A7A             0073   
0B1A7A             0074   test_sdiv168:
0B1A7A             0075   ; get first numeric argument
0B1A7A CD 4B 1B 0B 0076       call get_arg_s168 ; de = first numeric argument
0B1A7E D5          0077       push de
0B1A7F EB          0078       ex de,hl
0B1A80 CD 34 04 0B 0079       call print_s168
0B1A84             0080   
0B1A84             0081   ; match on single number functions
0B1A84 FD 21 15 1B 0082       ld iy,function
       0B          
0B1A89 CD A7 1B 0B 0083       call match_next_and_print ; iy = function pointer, zero flag set if match
0B1A8D F5          0084       push af ; save zero flag
0B1A8E FD E5       0085       push iy ; save the function pointer
0B1A90 CA B0 1A 0B 0086       jp z,@execute
0B1A94             0087   
0B1A94             0088   ; match on two-number operators
0B1A94 FD E1       0089       pop iy ; dummy pops
0B1A96 F1          0090       pop af ; to balance stack
0B1A97 ED 32 FD    0091       lea ix,ix-3
0B1A9A FD 21 CF 1A 0092       ld iy,operator
       0B          
0B1A9F CD A7 1B 0B 0093       call match_next_and_print ; iy = operator pointer, zero flag set if match
0B1AA3 F5          0094       push af ; save zero flag
0B1AA4 FD E5       0095       push iy ; save the operator pointer
0B1AA6             0096   
0B1AA6             0097   ; get second numeric argument if needed
0B1AA6 CD 4B 1B 0B 0098       call get_arg_s168 ; de = second argument
0B1AAA EB          0099       ex de,hl
0B1AAB CD 34 04 0B 0100       call print_s168
0B1AAF EB          0101       ex de,hl
0B1AB0             0102   
0B1AB0             0103   @execute:
0B1AB0 FD E1       0104       pop iy ; restore the function/operator pointer
0B1AB2 F1          0105       pop af ; restore zero flag
0B1AB3 E1          0106       pop hl ; restore first argument
0B1AB4             0107   
0B1AB4 C2 67 1A 0B 0108       jp nz,_main_end_error
0B1AB8             0109   
0B1AB8             0110       callIY ; call the function
0B1AB8 01 BF 1A 0B 0001M          ld bc,$+7     ; Address of first instruction after the jump
0B1ABC C5          0002M          push bc       ; which constitutes the return address
0B1ABD FD E9       0003M          jp   (iy)     ; Jump to the address in IY
0B1ABF CD 34 04 0B 0111       call print_s168
0B1AC3 CD 88 02 0B 0112       call printNewLine
0B1AC7 CD 88 02 0B 0113       call printNewLine
0B1ACB             0114   
0B1ACB C3 74 1A 0B 0115       jp _main_end_ok
0B1ACF             0116   
0B1ACF             0117   ; ========== DISPATCH TABLES ==========
0B1ACF             0118   operator:
0B1ACF E4 1A 0B    0119       dl addition
0B1AD2 EA 1A 0B    0120       dl subtract
0B1AD5 F2 1A 0B    0121       dl multiply
0B1AD8 FB 1A 0B    0122       dl divide
0B1ADB 05 1B 0B    0123       dl tan
0B1ADE 0C 1B 0B    0124       dl atan2
0B1AE1 00 00 00    0125       dl 0x000000 ; list terminator
0B1AE4             0126   addition:
0B1AE4 18 02       0127       jr @start
0B1AE6 2B 00       0128       asciz "+"
0B1AE8             0129   @start:
0B1AE8 19          0130       add hl,de
0B1AE9 C9          0131       ret
0B1AEA             0132   subtract:
0B1AEA 18 02       0133       jr @start
0B1AEC 2D 00       0134       asciz "-"
0B1AEE             0135   @start:
0B1AEE AF          0136       xor a ; clear carry
0B1AEF ED 52       0137       sbc hl,de
0B1AF1 C9          0138       ret
0B1AF2             0139   multiply:
0B1AF2 18 02       0140       jr @start
0B1AF4 2A 00       0141       asciz "*"
0B1AF6             0142   @start:
0B1AF6 CD 0B 09 0B 0143       call smul168
0B1AFA C9          0144       ret
0B1AFB             0145   divide:
0B1AFB 18 02       0146       jr @start
0B1AFD 2F 00       0147       asciz "/"
0B1AFF             0148   @start:
0B1AFF CD A5 09 0B 0149       call sdiv168
0B1B03 EB          0150       ex de,hl
0B1B04 C9          0151       ret
0B1B05             0152   tan:
0B1B05 18 04       0153       jr @start
0B1B07 74 61 6E 00 0154       asciz "tan"
0B1B0B             0155   @start:
0B1B0B             0156       ; call tan168
0B1B0B C9          0157       ret
0B1B0C             0158   atan2:
0B1B0C 18 06       0159       jr @start
0B1B0E 61 74 61 6E 0160       asciz "atan2"
       32 00       
0B1B14             0161   @start:
0B1B14             0162       ; call atan2_168
0B1B14 C9          0163       ret
0B1B15             0164   
0B1B15             0165   function:
0B1B15 21 1B 0B    0166       dl sin
0B1B18 30 1B 0B    0167       dl cos
0B1B1B 3F 1B 0B    0168       dl sqrt
0B1B1E 00 00 00    0169       dl 0x000000 ; list terminator
0B1B21             0170   sin:
0B1B21 18 04       0171       jr @start
0B1B23 73 69 6E 00 0172       asciz "sin"
0B1B27             0173   @start:
0B1B27 CD 53 0B 0B 0174       call deg_360_to_255
0B1B2B CD 94 0B 0B 0175       call sin168
0B1B2F C9          0176       ret
0B1B30             0177   cos:
0B1B30 18 04       0178       jr @start
0B1B32 63 6F 73 00 0179       asciz "cos"
0B1B36             0180   @start:
0B1B36 CD 53 0B 0B 0181       call deg_360_to_255
0B1B3A CD 8F 0B 0B 0182       call cos168
0B1B3E C9          0183       ret
0B1B3F             0184   sqrt:
0B1B3F 18 05       0185       jr @start
0B1B41 73 71 72 74 0186       asciz "sqrt"
       00          
0B1B46             0187   @start:
0B1B46 CD 68 0A 0B 0188       call sqrt168
0B1B4A C9          0189       ret
0B1B4B             0190   
0B1B4B             0191   ; ========== HELPER FUNCTIONS ==========
0B1B4B             0192   ; get the next argument after ix as a signed 16.8 fixed point number
0B1B4B             0193   ; inputs: ix = pointer to the argument string
0B1B4B             0194   ; outputs: ude = signed 16.8 fixed point number
0B1B4B             0195   ; destroys: a, d, e, h, l, f
0B1B4B             0196   get_arg_s168:
0B1B4B ED 32 03    0197       lea ix,ix+3 ; point to the next argument
0B1B4E DD 27 00    0198       ld hl,(ix)  ; get the argument string
0B1B51 CD 94 01 0B 0199       call asc_to_s168 ; convert the string to a number
0B1B55 C9          0200       ret ; return with the value in DE
0B1B56             0201   
0B1B56             0202   ; Inputs: ix = pointer to the argument string
0B1B56             0203   ; Outputs: ude = signed 24-bit integer
0B1B56             0204   ; Destroys: a, d, e, h, l, f
0B1B56             0205   get_arg_s24:
0B1B56 ED 32 03    0206       lea ix,ix+3 ; point to the next argument
0B1B59 DD 27 00    0207       ld hl,(ix)  ; get the argument string
0B1B5C CD 45 01 0B 0208       call asc_to_s24 ; convert the string to a number
0B1B60 C9          0209       ret ; return with the value in DE
0B1B61             0210   
0B1B61             0211   get_plot_coords:
0B1B61             0212   ; get the move coordinates
0B1B61 ED 32 03    0213       lea ix,ix+3 ; pointer to next argument address
0B1B64 DD 27 00    0214       ld hl,(ix)  ; pointer to the x coordinate string
0B1B67 CD 94 01 0B 0215       call asc_to_s168 ; de = x coordinate
0B1B6B D5          0216       push de
0B1B6C C1          0217       pop bc ; bc = x coordinate
0B1B6D ED 32 03    0218       lea ix,ix+3 ; pointer to next argument address
0B1B70 DD 27 00    0219       ld hl,(ix)  ; pointer to the y coordinate string
0B1B73 CD 94 01 0B 0220       call asc_to_s168 ; de = y coordinate
0B1B77 C9          0221       ret
0B1B78             0222   
0B1B78             0223   get_arg_text:
0B1B78 ED 32 03    0224       lea ix,ix+3 ; point to the next argument
0B1B7B DD 27 00    0225       ld hl,(ix)  ; get the argument string
0B1B7E C9          0226       ret
0B1B7F             0227   
0B1B7F             0228   ; match the next argument after ix to the dispatch table at iy
0B1B7F             0229   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1B7F             0230   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1B7F             0231   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1B7F             0232   ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B1B7F             0233   ; destroys: a, hl, de, ix, iy, flags
0B1B7F             0234   match_next:
0B1B7F ED 32 03    0235       lea ix,ix+3         ; point to the next argument
0B1B82             0236   @loop:
0B1B82 FD 27 00    0237       ld hl,(iy)          ; pointer argument dispatch record
0B1B85             0238       sign_hlu            ; check for list terminator
0B1B85 19          0001M          add hl,de
0B1B86 B7          0002M          or a
0B1B87 ED 52       0003M          sbc hl,de
0B1B89 CA A1 1B 0B 0239       jp z,@no_match      ; if a=0, return error
0B1B8D 23          0240       inc hl              ; skip over jp instruction
0B1B8E 23          0241       inc hl
0B1B8F DD 17 00    0242       ld de,(ix)          ; pointer to the argument string
0B1B92 CD B8 1B 0B 0243       call str_equal      ; compare the argument to the dispatch table entry
0B1B96 CA A3 1B 0B 0244       jp z,@match         ; if equal, return success
0B1B9A ED 33 03    0245       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1B9D C3 82 1B 0B 0246       jp @loop            ; and loop
0B1BA1             0247   @no_match:
0B1BA1 3C          0248       inc a               ; no match so return a=1 and zero flag reset
0B1BA2 C9          0249       ret
0B1BA3             0250   @match:
0B1BA3 FD 37 00    0251       ld iy,(iy)          ; get the function pointer
0B1BA6 C9          0252       ret                 ; return a=0 and zero flag set
0B1BA7             0253   
0B1BA7             0254   ; same as match_next, but prints the parameter if a match is found
0B1BA7             0255   match_next_and_print:
0B1BA7 CD 7F 1B 0B 0256       call match_next
0B1BAB C0          0257       ret nz ; no match found
0B1BAC ED 32 FD    0258       lea ix,ix-3
0B1BAF CD 78 1B 0B 0259       call get_arg_text ; hl points to the operator string
0B1BB3 CD C3 1B 0B 0260       call print_param
0B1BB7 C9          0261       ret
0B1BB8             0262   
0B1BB8             0263   ; compare two zero-terminated strings for equality, case-sensitive
0B1BB8             0264   ; hl: pointer to first string, de: pointer to second string
0B1BB8             0265   ; returns: z if equal, nz if not equal
0B1BB8             0266   ; destroys: a, hl, de
0B1BB8             0267   str_equal:
0B1BB8 1A          0268       ld a,(de)           ; get the first character
0B1BB9 BE          0269       cp (hl)             ; compare to the second character
0B1BBA C0          0270       ret nz              ; if not equal, return
0B1BBB B7          0271       or a
0B1BBC C8          0272       ret z               ; if equal and zero, return
0B1BBD 23          0273       inc hl              ; next character
0B1BBE 13          0274       inc de
0B1BBF C3 B8 1B 0B 0275       jp str_equal        ; loop until end of string
0B1BC3             0276   
0B1BC3             0277   ; print the parameter string pointed to by ix
0B1BC3             0278   ; destroys: a, hl
0B1BC3             0279   print_param:
0B1BC3 DD 27 00    0280       ld hl,(ix)          ; get the parameter pointer
0B1BC6 CD 73 02 0B 0281       call printString    ; print the parameter string
0B1BCA 3E 20       0282       ld a,' '            ; print a space separator
0B1BCC 5B D7       0283       rst.lil $10
0B1BCE C9          0284       ret
0B1BCF             0285   
0B1BCF             0286   ; print the parameters
0B1BCF             0287   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1BCF             0288   ; destroys: a, hl, bc
0B1BCF             0289   print_params:
0B1BCF 41          0290       ld b,c              ; loop counter = number of parameters
0B1BD0 DD E5       0291       push ix             ; save the pointer to the parameters
0B1BD2             0292   @loop:
0B1BD2 C5          0293       push bc             ; save the loop counter
0B1BD3 CD C3 1B 0B 0294       call print_param    ; print the parameter
0B1BD7 ED 32 03    0295       lea ix,ix+3         ; next parameter pointer
0B1BDA C1          0296       pop bc              ; get back the loop counter
0B1BDB 10 F5       0297       djnz @loop          ; loop until done
0B1BDD DD E1       0298       pop ix              ; restore the pointer to the parameters
0B1BDF C9          0299       ret
0B1BE0             0300   
0B1BE0             0301   debug_print:
0B1BE0 CD 88 02 0B 0302       call printNewLine   ; DEBUG
0B1BE4 CD 8D 06 0B 0303       call dumpFlags      ; DEBUG
0B1BE8 CD C3 1B 0B 0304       call print_param    ; DEBUG
0B1BEC CD 88 02 0B 0305       call printNewLine   ; DEBUG
0B1BF0 CD 88 02 0B 0306       call printNewLine   ; DEBUG
0B1BF4 C9          0307       ret
