        Output     Line 
       
               0001 ;
               0002 ; Title:	calcbas
               0003 ; Author:	Brandon R. Gates
               0004 ; Created:	29/10/2024
               0005 
               0006 ; ========================================
               0007 ; MODIFIED MOSLET INITIALIZATION CODE
               0008 ; ========================================
               0009 ;
               0010 ; Title:	Copy - Initialisation Code
               0011 ; Author:	Dean Belfield, Lennart Benschop
               0012 ; Created:	06/11/2022
               0013 ; Last Updated:	26/12/2022
               0014 ;
               0015 ; Modinfo:
               0016 ; 17/12/2022:	Added parameter processing
               0017 ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
               0018 ; Changed:      08/04/2924 adapt to ez80asm
               0019 ;
               0020 ASSUME	ADL = 1
               0021 INCLUDE "mos_api.inc"
              0001* ;
              0002* ; Title:	AGON MOS - API for user projects
              0003* ; Author:	Dean Belfield
              0004* ; Created:	03/08/2022
              0005* ; Last Updated:	11/11/2023
              0006* ;
              0007* ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
              0008* ;
              0009* ; Modinfo:
              0010* ; 05/08/2022:	Added mos_feof
              0011* ; 09/08/2022:	Added system variables: cursorX, cursorY
              0012* ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
              0013* ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
              0014* ; 24/09/2022:	Added mos_getError, mos_mkdir
              0015* ; 13/10/2022:	Added mos_oscli
              0016* ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
              0017* ; 04/03/2023:	Added sysvar_scrpixelIndex
              0018* ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
              0019* ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
              0020* ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
              0021* ; 22/03/2023:	The VDP commands are now indexed from 0x80
              0022* ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
              0023* ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
              0024* ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
              0025* ; 19/05/2023:	Added sysvar_scrMode
              0026* ; 05/06/2023:	Added sysvar_rtcEnable
              0027* ; 03/08/2023:	Added mos_setkbvector
              0028* ; 10/08/2023:	Added mos_getkbmap
              0029* ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
              0030* ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
              0031* ;
              0032* ; VDP control (VDU 23, 0, n)
              0033* ;
              0034* vdp_gp:			EQU 	80h
              0035* vdp_keycode:		EQU 	81h
              0036* vdp_cursor:		EQU	82h
              0037* vdp_scrchar:		EQU	83h
              0038* vdp_scrpixel:		EQU	84h
              0039* vdp_audio:		EQU	85h
              0040* vdp_mode:		EQU	86h
              0041* vdp_rtc:		EQU	87h
              0042* vdp_keystate:		EQU	88h
              0043* vdp_logicalcoords:	EQU	C0h
              0044* vdp_terminalmode:	EQU	FFh
              0045* 
              0046* ; MOS high level functions
              0047* ;
              0048* mos_getkey:		EQU	00h
              0049* mos_load:		EQU	01h
              0050* mos_save:		EQU	02h
              0051* mos_cd:			EQU	03h
              0052* mos_dir:		EQU	04h
              0053* mos_del:		EQU	05h
              0054* mos_ren:		EQU	06h
              0055* mos_mkdir:		EQU	07h
              0056* mos_sysvars:		EQU	08h
              0057* mos_editline:		EQU	09h
              0058* mos_fopen:		EQU	0Ah
              0059* mos_fclose:		EQU	0Bh
              0060* mos_fgetc:		EQU	0Ch
              0061* mos_fputc:		EQU	0Dh
              0062* mos_feof:		EQU	0Eh
              0063* mos_getError:		EQU	0Fh
              0064* mos_oscli:		EQU	10h
              0065* mos_copy:		EQU	11h
              0066* mos_getrtc:		EQU	12h
              0067* mos_setrtc:		EQU	13h
              0068* mos_setintvector:	EQU	14h
              0069* mos_uopen:		EQU	15h
              0070* mos_uclose:		EQU	16h
              0071* mos_ugetc:		EQU	17h
              0072* mos_uputc:		EQU 	18h
              0073* mos_getfil:		EQU	19h
              0074* mos_fread:		EQU	1Ah
              0075* mos_fwrite:		EQU	1Bh
              0076* mos_flseek:		EQU	1Ch
              0077* mos_setkbvector:	EQU	1Dh
              0078* mos_getkbmap:		EQU	1Eh
              0079* mos_i2c_open:		EQU	1Fh
              0080* mos_i2c_close:		EQU	20h
              0081* mos_i2c_write:		EQU	21h
              0082* mos_i2c_read:		EQU	22h
              0083* 
              0084* 
              0085* ; FatFS file access functions
              0086* ;
              0087* ffs_fopen:		EQU	80h
              0088* ffs_fclose:		EQU	81h
              0089* ffs_fread:		EQU	82h
              0090* ffs_fwrite:		EQU	83h
              0091* ffs_flseek:		EQU	84h
              0092* ffs_ftruncate:		EQU	85h
              0093* ffs_fsync:		EQU	86h
              0094* ffs_fforward:		EQU	87h
              0095* ffs_fexpand:		EQU	88h
              0096* ffs_fgets:		EQU	89h
              0097* ffs_fputc:		EQU	8Ah
              0098* ffs_fputs:		EQU	8Bh
              0099* ffs_fprintf:		EQU	8Ch
              0100* ffs_ftell:		EQU	8Dh
              0101* ffs_feof:		EQU	8Eh
              0102* ffs_fsize:		EQU	8Fh
              0103* ffs_ferror:		EQU	90h
              0104* 
              0105* ; FatFS directory access functions
              0106* ;
              0107* ffs_dopen:		EQU	91h
              0108* ffs_dclose:		EQU	92h
              0109* ffs_dread:		EQU	93h
              0110* ffs_dfindfirst:		EQU	94h
              0111* ffs_dfindnext:		EQU	95h
              0112* 
              0113* ; FatFS file and directory management functions
              0114* ;
              0115* ffs_stat:		EQU	96h
              0116* ffs_unlink:		EQU	97h
              0117* ffs_rename:		EQU	98h
              0118* ffs_chmod:		EQU	99h
              0119* ffs_utime:		EQU	9Ah
              0120* ffs_mkdir:		EQU	9Bh
              0121* ffs_chdir:		EQU	9Ch
              0122* ffs_chdrive:		EQU	9Dh
              0123* ffs_getcwd:		EQU	9Eh
              0124* 
              0125* ; FatFS volume management and system configuration functions
              0126* ;
              0127* ffs_mount:		EQU	9Fh
              0128* ffs_mkfs:		EQU	A0h
              0129* ffs_fdisk:		EQU	A1h
              0130* ffs_getfree:		EQU	A2h
              0131* ffs_getlabel:		EQU	A3h
              0132* ffs_setlabel:		EQU	A4h
              0133* ffs_setcp:		EQU	A5h
              0134* 
              0135* ; File access modes
              0136* ;
              0137* fa_read:		EQU	01h
              0138* fa_write:		EQU	02h
              0139* fa_open_existing:	EQU	00h
              0140* fa_create_new:		EQU	04h
              0141* fa_create_always:	EQU	08h
              0142* fa_open_always:		EQU	10h
              0143* fa_open_append:		EQU	30h
              0144* 
              0145* ; System variable indexes for api_sysvars
              0146* ; Index into _sysvars in globals.asm
              0147* ;
              0148* sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
              0149* sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
              0150* sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
              0151* sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
              0152* sysvar_cursorX:		EQU	07h	; 1: Cursor X position
              0153* sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
              0154* sysvar_scrchar:		EQU	09h	; 1: Character read from screen
              0155* sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
              0156* sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
              0157* sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
              0158* sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
              0159* sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
              0160* sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
              0161* sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
              0162* sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
              0163* sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
              0164* sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
              0165* sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
              0166* sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
              0167* sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
              0168* sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
              0169* sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
              0170* sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
              0171* sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
              0172* sysvar_scrMode:		EQU	27h	; 1: Screen mode
              0173* sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
              0174* sysvar_mouseX:		EQU	29h	; 2: Mouse X position
              0175* sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
              0176* sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
              0177* sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
              0178* sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
              0179* sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
              0180* ;
              0181* ; Flags for the VPD protocol
              0182* ;
              0183* vdp_pflag_cursor:	EQU	00000001b
              0184* vdp_pflag_scrchar:	EQU	00000010b
              0185* vdp_pflag_point:	EQU	00000100b
              0186* vdp_pflag_audio:	EQU	00001000b
              0187* vdp_pflag_mode:		EQU	00010000b
              0188* vdp_pflag_rtc:		EQU	00100000b
              0189* vdp_pflag_mouse:	EQU	01000000b
              0190* ; vdp_pflag_buffered:	EQU	10000000b
              0191* 
              0192* 
              0193* ; FatFS structures
              0194* ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
              0195* ;
              0196* ; Object ID and allocation information (FFOBJID)
              0197* FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
              0198* FFOBJID.id:       EQU 3    ; Hosting volume mount ID
              0199* FFOBJID.attr:     EQU 5    ; Object attribute
              0200* FFOBJID.stat:     EQU 6    ; Object chain status
              0201* FFOBJID.sclust:   EQU 7    ; Object data start cluster
              0202* FFOBJID.objsize:  EQU 11   ; Object size
              0203* FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
              0204* ;
              0205* ; File object structure (FIL)
              0206* ;
              0207* FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0208* FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
              0209* FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
              0210* FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
              0211* FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
              0212* FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
              0213* FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
              0214* FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
              0215* FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
              0216* ;
              0217* ; Directory object structure (DIR)
              0218* ;
              0219* DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0220* DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
              0221* DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
              0222* DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
              0223* DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
              0224* DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
              0225* DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
              0226* DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
              0227* ;
              0228* ; File information structure (FILINFO)
              0229* ;
              0230* FILINFO.fsize:    EQU 0    ; File size
              0231* FILINFO.fdate:    EQU 4    ; Modified date
              0232* FILINFO.ftime:    EQU 6    ; Modified time
              0233* FILINFO.fattrib:  EQU 8    ; File attribute
              0234* FILINFO.altname:  EQU 9    ; Alternative file name
              0235* FILINFO.fname:    EQU 22   ; Primary file name
              0236* FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
              0237* ;
              0238* ; Macro for calling the API
              0239* ; Parameters:
              0240* ; - function: One of the function numbers listed above
              0241* ;
              0242* MACRO MOSCALL	function
              0243* LD	A, function
              0244* RST.LIS	08h
              0245* ENDMACRO
               0022 ORG 0x0B0000 ; Is a moslet
               0023 
               0024 MACRO PROGNAME
               0025 ASCIZ "calcbas"
               0026 ENDMACRO
               0027 ;
               0028 ; Start in ADL mode
               0029 ;
0B0000 C3      0030 JP	_start
0B0001 45 
0B0002 00 
0B0003 0B 
               0031 ;
               0032 ; The header stuff is from byte 64 onwards
               0033 ;
               0034 _exec_name:
               0035 PROGNAME			; The executable name, only used in argv
0B0004 63     0001M ASCIZ "calcbas"
0B0005 61 
0B0006 6C 
0B0007 63 
0B0007 62   
0B0008 61 
0B0009 73 
0B000A 00 
               0036 
0B000C FF      0037 ALIGN	64
0B000D FF 
0B000E FF 
0B000F FF 
0B000F FF   
0B0010 FF 
0B0011 FF 
0B0012 FF 
0B0012 FF   
0B0013 FF 
0B0014 FF 
0B0015 FF 
0B0015 FF   
0B0016 FF 
0B0017 FF 
0B0018 FF 
0B0018 FF   
0B0019 FF 
0B001A FF 
0B001B FF 
0B001B FF   
0B001C FF 
0B001D FF 
0B001E FF 
0B001E FF   
0B001F FF 
0B0020 FF 
0B0021 FF 
0B0021 FF   
0B0022 FF 
0B0023 FF 
0B0024 FF 
0B0024 FF   
0B0025 FF 
0B0026 FF 
0B0027 FF 
0B0027 FF   
0B0028 FF 
0B0029 FF 
0B002A FF 
0B002A FF   
0B002B FF 
0B002C FF 
0B002D FF 
0B002D FF   
0B002E FF 
0B002F FF 
0B0030 FF 
0B0030 FF   
0B0031 FF 
0B0032 FF 
0B0033 FF 
               0038 
0B0040 4D      0039 DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0041 4F 
0B0042 53 
0B0043 00      0040 DB	00h			; MOS header version 0
0B0044 01      0041 DB	01h			; Flag for run mode (0: Z80, 1: ADL)
               0042 ;
               0043 ; And the code follows on immediately after the header
               0044 ;
               0045 _start:
0B0045 F5      0046 PUSH	AF			; Preserve the registers
0B0046 C5      0047 PUSH	BC
0B0047 D5      0048 PUSH	DE
0B0048 DD      0049 PUSH	IX
0B0049 E5 
0B004A FD      0050 PUSH	IY
0B004B E5 
0B004C ED      0051 LD	A, MB			; Save MB
0B004D 6E 
0B004E F5      0052 PUSH 	AF
0B004F AF      0053 XOR 	A
0B0050 ED      0054 LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0051 6D 
               0055 
0B0052 CD      0056 CALL		_clear_ram ; Clear the BASIC memory allocation
0B0053 BD 
0B0054 00 
0B0055 0B 
               0057 
0B0056 DD      0058 LD	IX, argv_ptrs		; The argv array pointer address
0B0057 21 
0B0058 4E 
0B0059 03 
0B0059 0B   
0B005B DD      0059 PUSH	IX
0B005C E5 
0B005D CD      0060 CALL	_parse_params		; Parse the parameters
0B005E 74 
0B005F 00 
0B0060 0B 
0B0061 DD      0061 POP	IX			; IX: argv
0B0062 E1 
0B0063 06      0062 LD	B, 0			;  C: argc
0B0064 00 
0B0065 CD      0063 CALL	_main			; Start user code
0B0066 B7 
0B0067 03 
0B0068 0B 
               0064 
0B0069 F1      0065 POP 	AF
0B006A ED      0066 LD	MB, A
0B006B 6D 
0B006C FD      0067 POP	IY			; Restore registers
0B006D E1 
0B006E DD      0068 POP	IX
0B006F E1 
0B0070 D1      0069 POP	DE
0B0071 C1      0070 POP	BC
0B0072 F1      0071 POP	AF
0B0073 C9      0072 RET
               0073 
               0074 ; Parse the parameter string into a C array
               0075 ; Parameters
               0076 ; - HL: Address of parameter string
               0077 ; - IX: Address for array pointer storage
               0078 ; Returns:
               0079 ; -  C: Number of parameters parsed
               0080 ;
0B0074 01      0081 _parse_params:		LD	BC, _exec_name
0B0075 04 
0B0076 00 
0B0077 0B 
0B0078 DD      0082 LD	(IX+0), BC		; ARGV[0] = the executable name
0B0079 0F 
0B007A 00 
0B007B ED      0083 LEA     IX, IX+3
0B007C 32 
0B007D 03 
0B007E CD      0084 CALL	_skip_spaces		; Skip HL past any leading spaces
0B007F B6 
0B0080 00 
0B0081 0B 
               0085 ;
0B0082 01      0086 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0083 01 
0B0084 00 
0B0085 00 
0B0086 06      0087 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0087 0F 
               0088 ;
               0089 _parse_params_1:
0B0088 C5      0090 PUSH	BC			; Stack ARGC
0B0089 E5      0091 PUSH	HL			; Stack start address of token
0B008A CD      0092 CALL	_get_token		; Get the next token
0B008B A7 
0B008C 00 
0B008D 0B 
0B008E 79      0093 LD	A, C			; A: Length of the token in characters
0B008F D1      0094 POP	DE			; Start address of token (was in HL)
0B0090 C1      0095 POP	BC			; ARGC
0B0091 B7      0096 OR	A			; Check for A=0 (no token found) OR at end of string
0B0092 C8      0097 RET	Z
               0098 ;
0B0093 DD      0099 LD	(IX+0), DE		; Store the pointer to the token
0B0094 1F 
0B0095 00 
0B0096 E5      0100 PUSH	HL			; DE=HL
0B0097 D1      0101 POP	DE
0B0098 CD      0102 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0099 B6 
0B009A 00 
0B009B 0B 
0B009C AF      0103 XOR	A
0B009D 12      0104 LD	(DE), A			; Zero-terminate the token
0B009E ED      0105 LEA  	IX, IX+3			; Advance to next pointer position
0B009F 32 
0B00A0 03 
0B00A1 0C      0106 INC	C			; Increment ARGC
0B00A2 79      0107 LD	A, C			; Check for C >= A
0B00A3 B8      0108 CP	B
0B00A4 38      0109 JR	C, _parse_params_1	; And loop
0B00A5 E2 
0B00A6 C9      0110 RET
               0111 
               0112 ; Get the next token
               0113 ; Parameters:
               0114 ; - HL: Address of parameter string
               0115 ; Returns:
               0116 ; - HL: Address of first character after token
               0117 ; -  C: Length of token (in characters)
               0118 ;
0B00A7 0E      0119 _get_token:		LD	C, 0			; Initialise length
0B00A8 00 
0B00A9 7E      0120 @@:			LD	A, (HL)			; Get the character from the parameter string
0B00AA B7      0121 OR	A			; Exit if 0 (end of parameter string in MOS)
0B00AB C8      0122 RET 	Z
0B00AC FE      0123 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AD 0D 
0B00AE C8      0124 RET	Z
0B00AF FE      0125 CP	' '			; Exit if space (end of token)
0B00B0 20 
0B00B1 C8      0126 RET	Z
0B00B2 23      0127 INC	HL			; Advance to next character
0B00B3 0C      0128 INC 	C			; Increment length
0B00B4 18      0129 JR	@B
0B00B5 F3 
               0130 
               0131 ; Skip spaces in the parameter string
               0132 ; Parameters:
               0133 ; - HL: Address of parameter string
               0134 ; Returns:
               0135 ; - HL: Address of next none-space character
               0136 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0137 ;
0B00B6 7E      0138 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B7 FE      0139 CP	' '			; Exit if not space
0B00B8 20 
0B00B9 C0      0140 RET	NZ
0B00BA 23      0141 INC	HL			; Advance to next character
0B00BB 18      0142 JR	_skip_spaces		; Increment length
0B00BC F9 
               0143 
               0144 ; ========================================
               0145 ; BASIC INITIALIZATION CODE FROM basic/init.asm
               0146 ; ========================================
               0147 ;
               0148 ;Clear the application memory
               0149 ;
               0150 _clear_ram:
0B00BD E5      0151 push hl
0B00BE C5      0152 PUSH		BC
0B00BF 21      0153 LD		HL, RAM_START
0B00C0 00 
0B00C1 4E 
0B00C2 0B 
0B00C3 11      0154 LD		DE, RAM_START + 1
0B00C4 01 
0B00C5 4E 
0B00C6 0B 
0B00C7 01      0155 LD		BC, RAM_END - RAM_START - 1
0B00C8 4F 
0B00C9 03 
0B00CA 00 
0B00CB AF      0156 XOR		A
0B00CC 77      0157 LD		(HL), A
0B00CD ED      0158 LDIR
0B00CE B0 
0B00CF C1      0159 POP		BC
0B00D0 E1      0160 pop hl
0B00D1 C9      0161 RET
               0162 
               0163 ; ========================================
               0164 ; BEGIN APPLICATION CODE
               0165 ; ========================================
               0166 
               0167 ; API INCLUDES
               0168 
               0169 ; APPLICATION INCLUDES
               0170 include "calcbas.inc"
              0001* 
              0002* ; global scratch memory for registers
0B00D2 00     0003* uaf: dl 0
0B00D3 00 
0B00D4 00 
0B00D5 00     0004* uhl: dl 0
0B00D6 00 
0B00D7 00 
0B00D8 00     0005* ubc: dl 0
0B00D9 00 
0B00DA 00 
0B00DB 00     0006* ude: dl 0
0B00DC 00 
0B00DD 00 
0B00DE 00     0007* uix: dl 0
0B00DF 00 
0B00E0 00 
0B00E1 00     0008* uiy: dl 0
0B00E2 00 
0B00E3 00 
0B00E4 00     0009* usp: dl 0
0B00E5 00 
0B00E6 00 
0B00E7 00     0010* upc: dl 0
0B00E8 00 
0B00E9 00 
              0011* 
0B00EA 20     0012* str_afu: db " af=",0
0B00EB 61 
0B00EC 66 
0B00ED 3D 
0B00ED 00   
0B00EF 20     0013* str_hlu: db " hl=",0
0B00F0 68 
0B00F1 6C 
0B00F2 3D 
0B00F2 00   
0B00F4 20     0014* str_bcu: db " bc=",0
0B00F5 62 
0B00F6 63 
0B00F7 3D 
0B00F7 00   
0B00F9 20     0015* str_deu: db " de=",0
0B00FA 64 
0B00FB 65 
0B00FC 3D 
0B00FC 00   
0B00FE 20     0016* str_ixu: db " ix=",0
0B00FF 69 
0B0100 78 
0B0101 3D 
0B0101 00   
0B0103 20     0017* str_iyu: db " iy=",0
0B0104 69 
0B0105 79 
0B0106 3D 
0B0106 00   
              0018* 
              0019* ; test the sign of HL
              0020* ; inputs: HL obviously
              0021* ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
              0022* ; destroys: flags
              0023* MACRO sign_hlu
              0024* add hl,de
              0025* or a
              0026* sbc hl,de
              0027* ENDMACRO
              0028* 
              0029* MACRO PUSH_ALL
              0030* ex af,af'
              0031* exx
              0032* push af
              0033* push hl
              0034* push bc
              0035* push de
              0036* 
              0037* ex af,af'
              0038* exx
              0039* push af
              0040* push hl
              0041* push bc
              0042* push de
              0043* push ix
              0044* push iy
              0045* ENDMACRO
              0046* 
              0047* MACRO POP_ALL
              0048* pop iy
              0049* pop ix
              0050* pop de
              0051* pop bc
              0052* pop hl
              0053* pop af
              0054* ex af,af'
              0055* exx
              0056* 
              0057* pop de
              0058* pop bc
              0059* pop hl
              0060* pop af
              0061* ex af,af'
              0062* exx
              0063* ENDMACRO
              0064* 
              0065* ; put the value in HLU into the accumulator
              0066* ; destroys: af
              0067* MACRO HLU_TO_A
              0068* push hl ; 4 cycles
              0069* inc sp ; 1 cycle
              0070* pop af  ; 4 cycles
              0071* dec sp ; 1 cycle
              0072* ; 10 cycles total
              0073* ENDMACRO
              0074* 
              0075* ; Print a 24-bit HEX number
              0076* ; HLU: Number to print
              0077* printHex24:
              0078* HLU_TO_A
0B0108 E5    0001*M push hl ; 4 cycles
0B0109 33    0002*M inc sp ; 1 cycle
0B010A F1    0003*M pop af  ; 4 cycles
0B010B 3B    0004*M dec sp ; 1 cycle
             0005*M ; 10 cycles total
0B010C CD     0079* CALL	printHex8
0B010D 16 
0B010E 01 
0B010F 0B 
              0080* ; Print a 16-bit HEX number
              0081* ; HL: Number to print
              0082* printHex16:
0B0110 7C     0083* LD		A,H
0B0111 CD     0084* CALL	printHex8
0B0112 16 
0B0113 01 
0B0114 0B 
0B0115 7D     0085* LD		A,L
              0086* ; Print an 8-bit HEX number
              0087* ; A: Number to print
              0088* printHex8:
              0089* ; LD		C,A
0B0116 32     0090* ld (uaf+1),a
0B0117 D3 
0B0118 00 
0B0119 0B 
0B011A 1F     0091* RRA
0B011B 1F     0092* RRA
0B011C 1F     0093* RRA
0B011D 1F     0094* RRA
0B011E CD     0095* CALL	@F
0B011F 26 
0B0120 01 
0B0121 0B 
              0096* ; LD		A,C
0B0122 3A     0097* ld a,(uaf+1)
0B0123 D3 
0B0124 00 
0B0125 0B 
              0098* @@:
0B0126 E6     0099* AND		0Fh
0B0127 0F 
0B0128 C6     0100* ADD		A,90h
0B0129 90 
0B012A 27     0101* DAA
0B012B CE     0102* ADC		A,40h
0B012C 40 
0B012D 27     0103* DAA
0B012E 5B     0104* RST.LIL	10h
0B012F D7 
0B0130 C9     0105* RET
              0106* 
              0107* ; print the binary representation of the 8-bit value in a
              0108* ; destroys a, hl, bc
              0109* printBin8:
0B0131 06     0110* ld b,8      ; loop counter for 8 bits
0B0132 08 
0B0133 21     0111* ld hl,@cmd  ; set hl to the low byte of the output string
0B0134 4E 
0B0135 01 
0B0136 0B 
              0112* ; (which will be the high bit of the value in a)
              0113* @loop:
0B0137 07     0114* rlca ; put the next highest bit into carry
0B0138 38     0115* jr c,@one
0B0139 04 
0B013A 36     0116* ld (hl),'0'
0B013B 30 
0B013C 18     0117* jr @next_bit
0B013D 02 
              0118* @one:
0B013E 36     0119* ld (hl),'1'
0B013F 31 
              0120* @next_bit:
0B0140 23     0121* inc hl
0B0141 10     0122* djnz @loop
0B0142 F4 
              0123* ; print it
0B0143 21     0124* ld hl,@cmd
0B0144 4E 
0B0145 01 
0B0146 0B 
0B0147 01     0125* ld bc,@end-@cmd
0B0148 08 
0B0149 00 
0B014A 00 
0B014B 5B     0126* rst.lil $18
0B014C DF 
0B014D C9     0127* ret
              0128* @cmd: ds 8 ; eight bytes for eight bits
              0129* @end:
              0130* 
              0131* ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
              0132* ; Print a zero-terminated string
              0133* ; HL: Pointer to string
              0134* printString:
0B0156 C5     0135* PUSH	BC
0B0157 01     0136* LD		BC,0
0B0158 00 
0B0159 00 
0B015A 00 
0B015B 3E     0137* LD 	 	A,0
0B015C 00 
0B015D 5B     0138* RST.LIL 18h
0B015E DF 
0B015F C1     0139* POP		BC
0B0160 C9     0140* RET
              0141* ; print a VDU sequence
              0142* ; HL: Pointer to VDU sequence - <1 byte length> <data>
              0143* sendVDUsequence:
0B0161 C5     0144* PUSH	BC
0B0162 01     0145* LD		BC, 0
0B0163 00 
0B0164 00 
0B0165 00 
0B0166 4E     0146* LD		C, (HL)
0B0167 5B     0147* RST.LIL	18h
0B0168 DF 
0B0169 C1     0148* POP		BC
0B016A C9     0149* RET
              0150* ; Print Newline sequence to VDP
              0151* printNewLine:
0B016B F5     0152* push af ; for some reason rst.lil 10h sets carry flag
0B016C 3E     0153* LD	A, '\r'
0B016D 0D 
0B016E 5B     0154* RST.LIL 10h
0B016F D7 
0B0170 3E     0155* LD	A, '\n'
0B0171 0A 
0B0172 5B     0156* RST.LIL 10h
0B0173 D7 
0B0174 F1     0157* pop af
0B0175 C9     0158* RET
              0159* 
              0160* ; Print a zero-terminated string inline with code, e.g.:
              0161* ;
              0162* ;    call printInline
              0163* ;    ASCIZ "Hello, world!\r\n"
              0164* ;
              0165* ; Destroys: HL,AF
              0166* printInline:
0B0176 E1     0167* pop hl ; get the return address = pointer to start of string
0B0177 CD     0168* call printString ; HL advances to end of string
0B0178 56 
0B0179 01 
0B017A 0B 
0B017B E5     0169* push hl ; restore the return address = pointer to end of string
0B017C C9     0170* ret
              0171* 
              0172* ; inputs: whatever is in the flags register
              0173* ; outputs: binary representation of flags
              0174* ;          with a header so we know which is what
              0175* ; destroys: nothing
              0176* ; preserves: everything
              0177* dumpFlags:
              0178* ; first we curse zilog for not giving direct access to flags
0B017D F5     0179* push af ; this is so we can send it back unharmed
0B017E F5     0180* push af ; this is so we can pop it to hl
              0181* ; store everything in scratch
0B017F 22     0182* ld (uhl),hl
0B0180 D5 
0B0181 00 
0B0182 0B 
0B0183 ED     0183* ld (ubc),bc
0B0184 43 
0B0185 D8 
0B0186 00 
0B0186 0B   
0B0188 ED     0184* ld (ude),de
0B0189 53 
0B018A DB 
0B018B 00 
0B018B 0B   
0B018D DD     0185* ld (uix),ix
0B018E 22 
0B018F DE 
0B0190 00 
0B0190 0B   
0B0192 FD     0186* ld (uiy),iy
0B0193 22 
0B0194 E1 
0B0195 00 
0B0195 0B   
              0187* ; next we print the header
0B0197 21     0188* ld hl,@header
0B0198 C3 
0B0199 01 
0B019A 0B 
0B019B CD     0189* call printString
0B019C 56 
0B019D 01 
0B019E 0B 
0B019F E1     0190* pop hl ; flags are now in l
0B01A0 7D     0191* ld a,l ; flags are now in a
0B01A1 CD     0192* call printBin8
0B01A2 31 
0B01A3 01 
0B01A4 0B 
0B01A5 CD     0193* call printNewLine
0B01A6 6B 
0B01A7 01 
0B01A8 0B 
              0194* ; restore everything
0B01A9 2A     0195* ld hl, (uhl)
0B01AA D5 
0B01AB 00 
0B01AC 0B 
0B01AD ED     0196* ld bc, (ubc)
0B01AE 4B 
0B01AF D8 
0B01B0 00 
0B01B0 0B   
0B01B2 ED     0197* ld de, (ude)
0B01B3 5B 
0B01B4 DB 
0B01B5 00 
0B01B5 0B   
0B01B7 DD     0198* ld ix, (uix)
0B01B8 2A 
0B01B9 DE 
0B01BA 00 
0B01BA 0B   
0B01BC FD     0199* ld iy, (uiy)
0B01BD 2A 
0B01BE E1 
0B01BF 00 
0B01BF 0B   
0B01C1 F1     0200* pop af ; send her home the way she came
0B01C2 C9     0201* ret
              0202* ; Bit 7 (S): Sign flag
              0203* ; Bit 6 (Z): Zero flag
              0204* ; Bit 5 (5): Reserved (copy of bit 5 of the result)
              0205* ; Bit 4 (H): Half Carry flag
              0206* ; Bit 3 (3): Reserved (copy of bit 3 of the result)
              0207* ; Bit 2 (PV): Parity/Overflow flag
              0208* ; Bit 1 (N): Subtract flag
              0209* ; Bit 0 (C): Carry flag
0B01C3 53     0210* @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
0B01C4 5A 
0B01C5 78 
0B01C6 48 
0B01C6 78   
0B01C7 50 
0B01C8 4E 
0B01C9 43 
0B01C9 0D   
0B01CA 0A 
0B01CB 00 
              0211* 
              0212* ; print registers to screen in hexidecimal format
              0213* ; inputs: none
              0214* ; outputs: values of every register printed to screen
              0215* ;    values of each register in global scratch memory
              0216* ; destroys: nothing
              0217* dumpRegistersHex:
              0218* ; store everything in scratch
0B01CE 22     0219* ld (uhl),hl
0B01CF D5 
0B01D0 00 
0B01D1 0B 
0B01D2 ED     0220* ld (ubc),bc
0B01D3 43 
0B01D4 D8 
0B01D5 00 
0B01D5 0B   
0B01D7 ED     0221* ld (ude),de
0B01D8 53 
0B01D9 DB 
0B01DA 00 
0B01DA 0B   
0B01DC DD     0222* ld (uix),ix
0B01DD 22 
0B01DE DE 
0B01DF 00 
0B01DF 0B   
0B01E1 FD     0223* ld (uiy),iy
0B01E2 22 
0B01E3 E1 
0B01E4 00 
0B01E4 0B   
0B01E6 F5     0224* push af ; fml
0B01E7 E1     0225* pop hl  ; thanks, zilog
0B01E8 22     0226* ld (uaf),hl
0B01E9 D2 
0B01EA 00 
0B01EB 0B 
0B01EC F5     0227* push af ; dammit
              0228* 
              0229* ; home the cursor
              0230* ; call vdu_home_cursor
              0231* ; call printNewLine
              0232* 
              0233* ; print each register
0B01ED 21     0234* ld hl,str_afu
0B01EE EA 
0B01EF 00 
0B01F0 0B 
0B01F1 CD     0235* call printString
0B01F2 56 
0B01F3 01 
0B01F4 0B 
0B01F5 2A     0236* ld hl,(uaf)
0B01F6 D2 
0B01F7 00 
0B01F8 0B 
0B01F9 CD     0237* call printHex24
0B01FA 08 
0B01FB 01 
0B01FC 0B 
              0238* ; call printNewLine
              0239* 
0B01FD 21     0240* ld hl,str_hlu
0B01FE EF 
0B01FF 00 
0B0200 0B 
0B0201 CD     0241* call printString
0B0202 56 
0B0203 01 
0B0204 0B 
0B0205 2A     0242* ld hl,(uhl)
0B0206 D5 
0B0207 00 
0B0208 0B 
0B0209 CD     0243* call printHex24
0B020A 08 
0B020B 01 
0B020C 0B 
              0244* ; call printNewLine
              0245* 
0B020D 21     0246* ld hl,str_bcu
0B020E F4 
0B020F 00 
0B0210 0B 
0B0211 CD     0247* call printString
0B0212 56 
0B0213 01 
0B0214 0B 
0B0215 2A     0248* ld hl,(ubc)
0B0216 D8 
0B0217 00 
0B0218 0B 
0B0219 CD     0249* call printHex24
0B021A 08 
0B021B 01 
0B021C 0B 
              0250* ; call printNewLine
              0251* 
0B021D 21     0252* ld hl,str_deu
0B021E F9 
0B021F 00 
0B0220 0B 
0B0221 CD     0253* call printString
0B0222 56 
0B0223 01 
0B0224 0B 
0B0225 2A     0254* ld hl,(ude)
0B0226 DB 
0B0227 00 
0B0228 0B 
0B0229 CD     0255* call printHex24
0B022A 08 
0B022B 01 
0B022C 0B 
              0256* ; call printNewLine
              0257* 
0B022D 21     0258* ld hl,str_ixu
0B022E FE 
0B022F 00 
0B0230 0B 
0B0231 CD     0259* call printString
0B0232 56 
0B0233 01 
0B0234 0B 
0B0235 2A     0260* ld hl,(uix)
0B0236 DE 
0B0237 00 
0B0238 0B 
0B0239 CD     0261* call printHex24
0B023A 08 
0B023B 01 
0B023C 0B 
              0262* ; call printNewLine
              0263* 
0B023D 21     0264* ld hl,str_iyu
0B023E 03 
0B023F 01 
0B0240 0B 
0B0241 CD     0265* call printString
0B0242 56 
0B0243 01 
0B0244 0B 
0B0245 2A     0266* ld hl,(uiy)
0B0246 E1 
0B0247 00 
0B0248 0B 
0B0249 CD     0267* call printHex24
0B024A 08 
0B024B 01 
0B024C 0B 
              0268* ; call printNewLine
              0269* 
              0270* ; call vdu_vblank
              0271* 
0B024D CD     0272* call printNewLine
0B024E 6B 
0B024F 01 
0B0250 0B 
              0273* ; restore everything
0B0251 2A     0274* ld hl, (uhl)
0B0252 D5 
0B0253 00 
0B0254 0B 
0B0255 ED     0275* ld bc, (ubc)
0B0256 4B 
0B0257 D8 
0B0258 00 
0B0258 0B   
0B025A ED     0276* ld de, (ude)
0B025B 5B 
0B025C DB 
0B025D 00 
0B025D 0B   
0B025F DD     0277* ld ix, (uix)
0B0260 2A 
0B0261 DE 
0B0262 00 
0B0262 0B   
0B0264 FD     0278* ld iy, (uiy)
0B0265 2A 
0B0266 E1 
0B0267 00 
0B0267 0B   
0B0269 F1     0279* pop af
              0280* ; all done
0B026A C9     0281* ret
              0282* 
              0283* dumpRegistersHexPrime:
0B026B D9     0284* exx
0B026C 08     0285* ex af,af'
0B026D CD     0286* call dumpRegistersHex
0B026E CE 
0B026F 01 
0B0270 0B 
0B0271 08     0287* ex af,af'
0B0272 D9     0288* exx
0B0273 C9     0289* ret
              0290* 
              0291* ; additionally dump prime registers
              0292* ; inputs: none
              0293* ; outputs: values of every register printed to screen
              0294* ; destroys: nothing
              0295* dumpRegistersHexAll:
0B0274 CD     0296* call dumpRegistersHex
0B0275 CE 
0B0276 01 
0B0277 0B 
0B0278 08     0297* ex af,af'
0B0279 D9     0298* exx
0B027A CD     0299* call dumpRegistersHex
0B027B CE 
0B027C 01 
0B027D 0B 
0B027E 08     0300* ex af,af'
0B027F D9     0301* exx
0B0280 C9     0302* ret
              0303* 
              0304* ; print bytes from an address to the screen in hexidecimal format
              0305* ; inputs: hl = address of first byte to print, a = number of bytes to print
              0306* ; outputs: values of each byte printed to screen separated by spaces
              0307* ; destroys: nothing
              0308* dumpMemoryHex:
              0309* ; save registers to the stack
0B0281 C5     0310* push bc
0B0282 E5     0311* push hl
0B0283 F5     0312* push af
              0313* 
              0314* ; print the address and separator
0B0284 CD     0315* call printHex24
0B0285 08 
0B0286 01 
0B0287 0B 
0B0288 3E     0316* ld a,':'
0B0289 3A 
0B028A 5B     0317* rst.lil 10h
0B028B D7 
0B028C 3E     0318* ld a,' '
0B028D 20 
0B028E 5B     0319* rst.lil 10h
0B028F D7 
              0320* 
              0321* ; set b to be our loop counter
0B0290 F1     0322* pop af
0B0291 47     0323* ld b,a
0B0292 E1     0324* pop hl
0B0293 E5     0325* push hl
0B0294 F5     0326* push af
              0327* @loop:
              0328* ; print the byte
0B0295 7E     0329* ld a,(hl)
0B0296 CD     0330* call printHex8
0B0297 16 
0B0298 01 
0B0299 0B 
              0331* ; print a space
0B029A 3E     0332* ld a,' '
0B029B 20 
0B029C 5B     0333* rst.lil 10h
0B029D D7 
0B029E 23     0334* inc hl
0B029F 10     0335* djnz @loop
0B02A0 F4 
0B02A1 CD     0336* call printNewLine
0B02A2 6B 
0B02A3 01 
0B02A4 0B 
              0337* 
              0338* ; restore everything
0B02A5 F1     0339* pop af
0B02A6 E1     0340* pop hl
0B02A7 C1     0341* pop bc
              0342* 
              0343* ; all done
0B02A8 C9     0344* ret
              0345* 
              0346* ; store HLH'L'C floating point number in a 40-bit buffer
              0347* ; inputs: HLH'L'C = floating point number
              0348* ;         ix = buffer address
              0349* ; outputs: buffer filled with floating point number
              0350* ; destroys: nothing
              0351* store_float_pri:
0B02A9 DD     0352* ld (ix+0),c
0B02AA 71 
0B02AB 00 
0B02AC DD     0353* ld (ix+3),l
0B02AD 75 
0B02AE 03 
0B02AF DD     0354* ld (ix+4),h
0B02B0 74 
0B02B1 04 
0B02B2 D9     0355* exx
0B02B3 DD     0356* ld (ix+1),l
0B02B4 75 
0B02B5 01 
0B02B6 DD     0357* ld (ix+2),h
0B02B7 74 
0B02B8 02 
0B02B9 D9     0358* exx
0B02BA C9     0359* ret
              0360* 
              0361* ; store DED'E'B floating point number in a 40-bit buffer
              0362* ; inputs: DED'E'B = floating point number
              0363* ;         ix = buffer address
              0364* ; outputs: buffer filled with floating point number
              0365* ; destroys: nothing
              0366* store_float_sec:
0B02BB DD     0367* ld (ix+0),b
0B02BC 70 
0B02BD 00 
0B02BE DD     0368* ld (ix+3),e
0B02BF 73 
0B02C0 03 
0B02C1 DD     0369* ld (ix+4),d
0B02C2 72 
0B02C3 04 
0B02C4 D9     0370* exx
0B02C5 DD     0371* ld (ix+1),e
0B02C6 73 
0B02C7 01 
0B02C8 DD     0372* ld (ix+2),d
0B02C9 72 
0B02CA 02 
0B02CB D9     0373* exx
0B02CC C9     0374* ret
              0375* 
              0376* ; fetch HLH'L'C floating point number from a 40-bit buffer
              0377* ; inputs: ix = buffer address
              0378* ; outputs: HLH'L'C = floating point number
              0379* ; destroys: HLH'L'C
              0380* fetch_float_nor:
0B02CD DD     0381* ld c,(ix+0)
0B02CE 4E 
0B02CF 00 
0B02D0 DD     0382* ld l,(ix+3)
0B02D1 6E 
0B02D2 03 
0B02D3 DD     0383* ld h,(ix+4)
0B02D4 66 
0B02D5 04 
0B02D6 D9     0384* exx
0B02D7 DD     0385* ld l,(ix+1)
0B02D8 6E 
0B02D9 01 
0B02DA DD     0386* ld h,(ix+2)
0B02DB 66 
0B02DC 02 
0B02DD D9     0387* exx
0B02DE C9     0388* ret
              0389* 
              0390* ; fetch DED'E'B floating point number from a 40-bit buffer
              0391* ; inputs: ix = buffer address
              0392* ; outputs: DED'E'B = floating point number
              0393* ; destroys: DED'E'B
              0394* fetch_float_alt:
0B02DF DD     0395* ld b,(ix+0)
0B02E0 46 
0B02E1 00 
0B02E2 DD     0396* ld e,(ix+3)
0B02E3 5E 
0B02E4 03 
0B02E5 DD     0397* ld d,(ix+4)
0B02E6 56 
0B02E7 04 
0B02E8 D9     0398* exx
0B02E9 DD     0399* ld e,(ix+1)
0B02EA 5E 
0B02EB 01 
0B02EC DD     0400* ld d,(ix+2)
0B02ED 56 
0B02EE 02 
0B02EF D9     0401* exx
0B02F0 C9     0402* ret
              0403* 
              0404* ; print HLH'L'C floating point number in hex format
              0405* ; inputs: HLH'L'C = floating point number
              0406* print_float_hex_nor:
0B02F1 CD     0407* call printHex16
0B02F2 10 
0B02F3 01 
0B02F4 0B 
0B02F5 3E     0408* ld a,'.'
0B02F6 2E 
0B02F7 5B     0409* rst.lil 10h
0B02F8 D7 
0B02F9 D9     0410* exx
0B02FA CD     0411* call printHex16
0B02FB 10 
0B02FC 01 
0B02FD 0B 
0B02FE D9     0412* exx
0B02FF 3E     0413* ld a,'^'
0B0300 5E 
0B0301 5B     0414* rst.lil 10h
0B0302 D7 
0B0303 79     0415* ld a,c
0B0304 CD     0416* call printHex8
0B0305 16 
0B0306 01 
0B0307 0B 
0B0308 C9     0417* ret
              0418* 
              0419* ; print DED'E'B floating point number in hex format
              0420* ; inputs: DED'E'B = floating point number
              0421* print_float_hex_alt:
0B0309 EB     0422* ex de,hl
0B030A CD     0423* call printHex16
0B030B 10 
0B030C 01 
0B030D 0B 
0B030E EB     0424* ex de,hl
0B030F 3E     0425* ld a,'.'
0B0310 2E 
0B0311 5B     0426* rst.lil 10h
0B0312 D7 
0B0313 D9     0427* exx
0B0314 EB     0428* ex de,hl
0B0315 CD     0429* call printHex16
0B0316 10 
0B0317 01 
0B0318 0B 
0B0319 EB     0430* ex de,hl
0B031A D9     0431* exx
0B031B 3E     0432* ld a,'^'
0B031C 5E 
0B031D 5B     0433* rst.lil 10h
0B031E D7 
0B031F 78     0434* ld a,b
0B0320 CD     0435* call printHex8
0B0321 16 
0B0322 01 
0B0323 0B 
0B0324 C9     0436* ret
              0437* 
              0438* print_floats_hex:
0B0325 CD     0439* call print_float_hex_nor
0B0326 F1 
0B0327 02 
0B0328 0B 
0B0329 3E     0440* ld a,' '
0B032A 20 
0B032B 5B     0441* rst.lil 10h
0B032C D7 
0B032D CD     0442* call print_float_hex_alt
0B032E 09 
0B032F 03 
0B0330 0B 
0B0331 C9     0443* ret
              0444* 
              0445* ; print a floating point number in decimal format
              0446* ; inputs: HL'H'L'C is the number to print
              0447* ; outputs: number printed to screen
              0448* ;          ACCS null-terminated string representation of the number
              0449* ; destroys: everything except ix
              0450* print_float_dec:
              0451* print_float_dec_nor:
0B0332 DD     0452* push ix             ; save the pointer to the parameters
0B0333 E5 
0B0334 11     0453* ld de,ACCS          ; point to the string accumulator
0B0335 00 
0B0336 4E 
0B0337 0B 
0B0338 DD     0454* ld ix,@G9-1         ; get the format code for the number
0B0339 21 
0B033A 4B 
0B033B 03 
0B033B 0B   
0B033D CD     0455* call STR ; convert the number to a string
0B033E 30 
0B033F 0D 
0B0340 0B 
0B0341 21     0456* ld hl,ACCS ; point to the string accumulator
0B0342 00 
0B0343 4E 
0B0344 0B 
0B0345 CD     0457* call printString
0B0346 56 
0B0347 01 
0B0348 0B 
0B0349 DD     0458* pop ix              ; restore the pointer to the parameters
0B034A E1 
0B034B C9     0459* ret
0B034C 09     0460* @G9:			DW    9
0B034D 00 
               0171 include "mathfpp.inc"
              0001* ; integer operations
              0002* iand:	EQU 0x00	; AND (INTEGER)
              0003* ibdiv:	EQU 0x01	; DIV
              0004* ieor:	EQU 0x02	; EOR
              0005* imod:	EQU 0x03	; MOD
              0006* ior:	EQU 0x04	; OR
              0007* ile:	EQU 0x05	; <=
              0008* ine:	EQU 0x06	; <>
              0009* ige:	EQU 0x07	; >=
              0010* ilt:	EQU 0x08	; <
              0011* ieq:	EQU 0x09	; =
              0012* imul:	EQU 0x0A	; *
              0013* iadd:	EQU 0x0B	; +
              0014* igt:	EQU 0x0C	; >
              0015* isub:	EQU 0x0D	; -
              0016* ipow:	EQU 0x0E	; ^
              0017* idiv:	EQU 0x0F	; /
              0018* ;
              0019* ; floating point functions
              0020* absv:	EQU 0x00	; ABS
              0021* acs:	EQU 0x01	; ACS
              0022* asn:	EQU 0x02	; ASN
              0023* atn:	EQU 0x03	; ATN
              0024* cos:	EQU 0x04	; COS
              0025* deg:	EQU 0x05	; DEG
              0026* exp:	EQU 0x06	; EXP
              0027* int_:	EQU 0x07	; INT
              0028* ln:	EQU 0x08	; LN
              0029* log:	EQU 0x09	; LOG
              0030* notk:	EQU 0x0A	; NOT
              0031* rad:	EQU 0x0B	; RAD
              0032* sgn:	EQU 0x0C	; SGN
              0033* sin:	EQU 0x0D	; SIN
              0034* sqr:	EQU 0x0E	; SQR
              0035* tan:	EQU 0x0F	; TAN
              0036* zero:	EQU 0x10	; ZERO
              0037* fone:	EQU 0x11	; FONE
              0038* true:	EQU 0x12	; TRUE
              0039* pi:	EQU 0x13	; PI
              0040* val:	EQU 0x14	; VAL
              0041* str:	EQU 0x15	; STR$
              0042* sfix:	EQU 0x16	; FIX
              0043* sfloat:	EQU 0x17	; FLOAT
              0044* ftest:	EQU 0x18	; TEST
              0045* fcomp:	EQU 0x19	; COMPARE
              0046* ;
              0047* ; floating point operations
              0048* fand:	EQU 0x00	; AND (FLOATING-POINT)
              0049* fbdiv:	EQU 0x01	; DIV
              0050* feor:	EQU 0x02	; EOR
              0051* fmod:	EQU 0x03	; MOD
              0052* ffor:	EQU 0x04	; OR
              0053* fle:	EQU 0x05	; <=
              0054* fne:	EQU 0x06	; <>
              0055* fge:	EQU 0x07	; >=
              0056* flt:	EQU 0x08	; <
              0057* feq:	EQU 0x09	; =
              0058* fmul:	EQU 0x0A	; *
              0059* fadd:	EQU 0x0B	; +
              0060* fgt:	EQU 0x0C	; >
              0061* fsub:	EQU 0x0D	; -
              0062* fpow:	EQU 0x0E	; ^
              0063* fdiv:	EQU 0x0F	; /
               0172 
               0173 ; Storage for the argv array pointers
               0174 min_args: equ 2
               0175 argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B034E 00      0176 argv_ptrs:		    BLKP	argv_ptrs_max, 0
0B034F 00 
0B0350 00 
0B0351 00 
0B0351 00   
0B0352 00 
0B0353 00 
0B0354 00 
0B0354 00   
0B0355 00 
0B0356 00 
0B0357 00 
0B0357 00   
0B0358 00 
0B0359 00 
0B035A 00 
0B035A 00   
0B035B 00 
0B035C 00 
0B035D 00 
0B035D 00   
0B035E 00 
0B035F 00 
0B0360 00 
0B0360 00   
0B0361 00 
0B0362 00 
0B0363 00 
0B0363 00   
0B0364 00 
0B0365 00 
0B0366 00 
0B0366 00   
0B0367 00 
0B0368 00 
0B0369 00 
0B0369 00   
0B036A 00 
0B036B 00 
0B036C 00 
0B036C 00   
0B036D 00 
0B036E 00 
0B036F 00 
0B036F 00   
0B0370 00 
0B0371 00 
0B0372 00 
               0177 _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
               0178 
               0179 ; Storage for the arguments, ORDER MATTERS
               0180 arg1: ds 5
               0181 arg2: ds 5
               0182 
               0183 ; GLOBAL MESSAGE STRINGS
0B038B 55      0184 str_usage: ASCIZ "Usage: scratch <args>\r\n"
0B038C 73 
0B038D 61 
0B038E 67 
0B038E 65   
0B038F 3A 
0B0390 20 
0B0391 73 
0B0391 63   
0B0392 72 
0B0393 61 
0B0394 74 
0B0394 63   
0B0395 68 
0B0396 20 
0B0397 3C 
0B0397 61   
0B0398 72 
0B0399 67 
0B039A 73 
0B039A 3E   
0B039B 0D 
0B039C 0A 
0B039D 00 
0B03A3 45      0185 str_error: ASCIZ "Error!\r\n"
0B03A4 72 
0B03A5 72 
0B03A6 6F 
0B03A6 72   
0B03A7 21 
0B03A8 0D 
0B03A9 0A 
0B03A9 00   
0B03AC 53      0186 str_success: ASCIZ "Success!\r\n"
0B03AD 75 
0B03AE 63 
0B03AF 63 
0B03AF 65   
0B03B0 73 
0B03B1 73 
0B03B2 21 
0B03B2 0D   
0B03B3 0A 
0B03B4 00 
               0187 
               0188 ; ========= MAIN LOOP =========
               0189 ; The main routine
               0190 ; IXU: argv - pointer to array of parameters
               0191 ;   C: argc - number of parameters
               0192 ; Returns:
               0193 ;  HL: Error code, or 0 if OK
               0194 
               0195 _main:
0B03B7 79      0196 ld a,c              ; how many arguments?
0B03B8 FE      0197 cp min_args         ; not enough?
0B03B9 02 
0B03BA 30      0198 jr nc,main          ; if enough, go to main loop
0B03BB 23 
0B03BC 21      0199 ld hl,str_usage     ; if not enough, print usage
0B03BD 8B 
0B03BE 03 
0B03BF 0B 
0B03C0 CD      0200 call printString
0B03C1 56 
0B03C2 01 
0B03C3 0B 
               0201 ; fall through to _main_end_error
               0202 
               0203 _main_end_error:
0B03C4 21      0204 ld hl,str_error     ; print error message
0B03C5 A3 
0B03C6 03 
0B03C7 0B 
0B03C8 CD      0205 call printString
0B03C9 56 
0B03CA 01 
0B03CB 0B 
0B03CC 21      0206 ld hl,19            ; return error code 19
0B03CD 13 
0B03CE 00 
0B03CF 00 
0B03D0 C9      0207 ret
               0208 
               0209 ; begin BASIC-specific end code
               0210 ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B03D1 ED      0211 _basic_end:			LD		SP, (_sps)		; Restore the stack pointer
0B03D2 7B 
0B03D3 7E 
0B03D4 03 
0B03D4 0B   
               0212 ; fall through to _main_end_ok
               0213 ; end BASIC-specific end code
               0214 
               0215 _main_end_ok:
               0216 ; ld hl,str_success   ; print success message
               0217 ; call printString
0B03D6 CD      0218 call printNewLine
0B03D7 6B 
0B03D8 01 
0B03D9 0B 
0B03DA 21      0219 ld hl,0             ; return 0 for success
0B03DB 00 
0B03DC 00 
0B03DD 00 
0B03DE C9      0220 ret
               0221 
               0222 ; ========= BEGIN CUSTOM MAIN LOOP =========
               0223 main:
0B03DF DD      0224 ld hl,(ix)          ; get the first argument in case hl doesn't land here with it
0B03E0 27 
0B03E1 00 
               0225 
0B03E2 CD      0226 call store_arg_float1
0B03E3 2F 
0B03E4 04 
0B03E5 0B 
0B03E6 CD      0227 call print_float_dec
0B03E7 32 
0B03E8 03 
0B03E9 0B 
               0228 
0B03EA CD      0229 call printInline
0B03EB 76 
0B03EC 01 
0B03ED 0B 
0B03EE 20      0230 asciz " * "
0B03EF 2A 
0B03F0 20 
0B03F1 00 
               0231 
0B03F2 CD      0232 call store_arg_float2
0B03F3 47 
0B03F4 04 
0B03F5 0B 
0B03F6 CD      0233 call print_float_dec
0B03F7 32 
0B03F8 03 
0B03F9 0B 
               0234 
0B03FA CD      0235 call printInline
0B03FB 76 
0B03FC 01 
0B03FD 0B 
0B03FE 20      0236 asciz " = "
0B03FF 3D 
0B0400 20 
0B0401 00 
               0237 
0B0402 DD      0238 ld ix,arg1
0B0403 21 
0B0404 81 
0B0405 03 
0B0405 0B   
0B0407 CD      0239 call fetch_float_nor
0B0408 CD 
0B0409 02 
0B040A 0B 
               0240 
0B040B ED      0241 lea ix,ix+5 ; arg2
0B040C 32 
0B040D 05 
0B040E CD      0242 call fetch_float_alt
0B040F DF 
0B0410 02 
0B0411 0B 
               0243 
               0244 ; call FMUL ; HLH'L'C * DED'E'B --> HLH'L'C
0B0412 3E      0245 ld a,fmul
0B0413 0A 
0B0414 CD      0246 call FPP
0B0415 34 
0B0416 24 
0B0417 0B 
0B0418 CD      0247 call print_float_dec
0B0419 32 
0B041A 03 
0B041B 0B 
               0248 
0B041C C3      0249 jp _main_end_ok     ; return success
0B041D D6 
0B041E 03 
0B041F 0B 
               0250 
               0251 
               0252 ; ========== HELPER FUNCTIONS ==========
               0253 ;
               0254 ; get the next argument after ix as a floating point number
               0255 ; inputs: ix = pointer to the argument string
               0256 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0257 ; destroys: everything except iy, including prime registers
               0258 get_arg_float:
0B0420 ED      0259 lea ix,ix+3 ; point to the next argument
0B0421 32 
0B0422 03 
0B0423 DD      0260 push ix ; preserve
0B0424 E5 
0B0425 DD      0261 ld ix,(ix)  ; point to argument string
0B0426 37 
0B0427 00 
0B0428 CD      0262 call VAL_FP ; convert the string to a float
0B0429 AB 
0B042A 28 
0B042B 0B 
0B042C DD      0263 pop ix ; restore
0B042D E1 
0B042E C9      0264 ret ; return with the value in HLH'L'C
               0265 
               0266 ; get the next argument after ix as a floating point number and store it in ag1 buffer
               0267 ; inputs: ix = pointer to the argument string
               0268 ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0269 ; destroys: everything except iy, including prime registers
               0270 store_arg_float1:
0B042F ED      0271 lea ix,ix+3 ; point to the next argument
0B0430 32 
0B0431 03 
0B0432 DD      0272 push ix ; preserve
0B0433 E5 
0B0434 DD      0273 ld ix,(ix)  ; point to argument string
0B0435 37 
0B0436 00 
0B0437 CD      0274 call VAL_FP ; convert the string to a float
0B0438 AB 
0B0439 28 
0B043A 0B 
0B043B DD      0275 ld ix,arg1 ; point to the buffer
0B043C 21 
0B043D 81 
0B043E 03 
0B043E 0B   
0B0440 CD      0276 call store_float_pri ; save the float in arg1 buffer
0B0441 A9 
0B0442 02 
0B0443 0B 
0B0444 DD      0277 pop ix ; restore
0B0445 E1 
0B0446 C9      0278 ret ; return with the value in HLH'L'C
               0279 
               0280 ; same as above, but store the float in arg2 buffer
               0281 store_arg_float2:
0B0447 ED      0282 lea ix,ix+3 ; point to the next argument
0B0448 32 
0B0449 03 
0B044A DD      0283 push ix ; preserve
0B044B E5 
0B044C DD      0284 ld ix,(ix)  ; point to argument string
0B044D 37 
0B044E 00 
0B044F CD      0285 call VAL_FP ; convert the string to a float
0B0450 AB 
0B0451 28 
0B0452 0B 
0B0453 DD      0286 ld ix,arg2 ; point to the buffer
0B0454 21 
0B0455 86 
0B0456 03 
0B0456 0B   
0B0458 CD      0287 call store_float_pri ; save the float in arg2 buffer
0B0459 A9 
0B045A 02 
0B045B 0B 
0B045C DD      0288 pop ix ; restore
0B045D E1 
0B045E C9      0289 ret ; return with the value in HLH'L'C
               0290 ;
               0291 ; get the next argument after ix as a string
               0292 ; inputs: ix = pointer to the argument string
               0293 ; outputs: HL = pointer to the argument string, ix points to the next argument
               0294 ; destroys: a, h, l, f
               0295 get_arg_text:
0B045F ED      0296 lea ix,ix+3 ; point to the next argument
0B0460 32 
0B0461 03 
0B0462 DD      0297 ld hl,(ix)  ; get the argument string
0B0463 27 
0B0464 00 
0B0465 C9      0298 ret
               0299 ;
               0300 ; match the next argument after ix to the dispatch table at iy
               0301 ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
               0302 ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
               0303 ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
               0304 ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
               0305 ; destroys: a, hl, de, ix, iy, flags
               0306 match_next:
0B0466 ED      0307 lea ix,ix+3         ; point to the next argument
0B0467 32 
0B0468 03 
               0308 @loop:
0B0469 FD      0309 ld hl,(iy)          ; pointer argument dispatch record
0B046A 27 
0B046B 00 
               0310 sign_hlu            ; check for list terminator
0B046C 19     0001M add hl,de
0B046D B7     0002M or a
0B046E ED     0003M sbc hl,de
0B046F 52 
0B0470 CA      0311 jp z,@no_match      ; if a=0, return error
0B0471 88 
0B0472 04 
0B0473 0B 
0B0474 23      0312 inc hl              ; skip over jp instruction
0B0475 23      0313 inc hl
0B0476 DD      0314 ld de,(ix)          ; pointer to the argument string
0B0477 17 
0B0478 00 
0B0479 CD      0315 call str_equal      ; compare the argument to the dispatch table entry
0B047A 9F 
0B047B 04 
0B047C 0B 
0B047D CA      0316 jp z,@match         ; if equal, return success
0B047E 8A 
0B047F 04 
0B0480 0B 
0B0481 ED      0317 lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B0482 33 
0B0483 03 
0B0484 C3      0318 jp @loop            ; and loop
0B0485 69 
0B0486 04 
0B0487 0B 
               0319 @no_match:
0B0488 3C      0320 inc a               ; no match so return a=1 and zero flag reset
0B0489 C9      0321 ret
               0322 @match:
0B048A FD      0323 ld iy,(iy)          ; get the function pointer
0B048B 37 
0B048C 00 
0B048D C9      0324 ret                 ; return a=0 and zero flag set
               0325 
               0326 ; same as match_next, but prints the parameter if a match is found
               0327 match_next_and_print:
0B048E CD      0328 call match_next
0B048F 66 
0B0490 04 
0B0491 0B 
0B0492 C0      0329 ret nz ; no match found
0B0493 ED      0330 lea ix,ix-3
0B0494 32 
0B0495 FD 
0B0496 CD      0331 call get_arg_text ; hl points to the operator string
0B0497 5F 
0B0498 04 
0B0499 0B 
0B049A CD      0332 call print_param
0B049B AA 
0B049C 04 
0B049D 0B 
0B049E C9      0333 ret
               0334 
               0335 ; compare two zero-terminated strings for equality, case-sensitive
               0336 ; hl: pointer to first string, de: pointer to second string
               0337 ; returns: z if equal, nz if not equal
               0338 ; destroys: a, hl, de
               0339 str_equal:
0B049F 1A      0340 ld a,(de)           ; get the first character
0B04A0 BE      0341 cp (hl)             ; compare to the second character
0B04A1 C0      0342 ret nz              ; if not equal, return
0B04A2 B7      0343 or a
0B04A3 C8      0344 ret z               ; if equal and zero, return
0B04A4 23      0345 inc hl              ; next character
0B04A5 13      0346 inc de
0B04A6 C3      0347 jp str_equal        ; loop until end of string
0B04A7 9F 
0B04A8 04 
0B04A9 0B 
               0348 
               0349 ; print the parameter string pointed to by ix
               0350 ; destroys: a, hl
               0351 print_param:
0B04AA DD      0352 ld hl,(ix)          ; get the parameter pointer
0B04AB 27 
0B04AC 00 
0B04AD CD      0353 call printString    ; print the parameter string
0B04AE 56 
0B04AF 01 
0B04B0 0B 
0B04B1 3E      0354 ld a,' '            ; print a space separator
0B04B2 20 
0B04B3 5B      0355 rst.lil $10
0B04B4 D7 
0B04B5 C9      0356 ret
               0357 
               0358 ; print the parameters
               0359 ; inputs: b = number of parameters, ix = pointer to the parameters
               0360 ; destroys: a, hl, bc
               0361 print_params:
0B04B6 41      0362 ld b,c              ; loop counter = number of parameters
0B04B7 DD      0363 push ix             ; save the pointer to the parameters
0B04B8 E5 
               0364 @loop:
0B04B9 C5      0365 push bc             ; save the loop counter
0B04BA CD      0366 call print_param    ; print the parameter
0B04BB AA 
0B04BC 04 
0B04BD 0B 
0B04BE ED      0367 lea ix,ix+3         ; next parameter pointer
0B04BF 32 
0B04C0 03 
0B04C1 C1      0368 pop bc              ; get back the loop counter
0B04C2 10      0369 djnz @loop          ; loop until done
0B04C3 F5 
0B04C4 DD      0370 pop ix              ; restore the pointer to the parameters
0B04C5 E1 
0B04C6 C9      0371 ret
               0372 
               0373 debug_print:
0B04C7 CD      0374 call printNewLine
0B04C8 6B 
0B04C9 01 
0B04CA 0B 
0B04CB CD      0375 call dumpRegistersHexAll
0B04CC 74 
0B04CD 02 
0B04CE 0B 
0B04CF CD      0376 call printNewLine
0B04D0 6B 
0B04D1 01 
0B04D2 0B 
0B04D3 C9      0377 ret
               0378 
               0379 include "basic.inc" ; must be last so that RAM has room for BASIC operations
              0001* ; include "basic/mos_api.inc"
              0002* include "basic/macros.inc"
             0001** ; Title:	BBC Basic Interpreter - Z80 version
             0002** ;		Useful macros
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	11/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 11/06/2023:	Modified to run in ADL mode
             0009** ; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
             0010** 
             0011** MACRO EXREG	rp1, rp2
             0012** PUSH	rp1
             0013** POP	rp2
             0014** ENDMACRO
             0015** 
             0016** ; MACRO ADD8U_DE	reg
             0017** MACRO ADD8U_DE
             0018** ADD	A, E
             0019** LD	E, A
             0020** ADC	A, D
             0021** SUB	E
             0022** LD	D, A
             0023** ENDMACRO
             0024** 
             0025** ; MACRO ADD8U_HL	reg
             0026** MACRO ADD8U_HL
             0027** ADD	A, L
             0028** LD	L, A
             0029** ADC	A, H
             0030** SUB	L
             0031** LD	H, A
             0032** ENDMACRO
             0033** 
             0034** MACRO VDU	val
             0035** LD	A, val
             0036** CALL	OSWRCH
             0037** ENDMACRO
             0038** 
             0039** MACRO SET_GPIO	reg, val
             0040** IN0	A, (reg)
             0041** OR	val
             0042** OUT0	(reg), A
             0043** ENDMACRO
             0044** 
             0045** MACRO RES_GPIO	reg, val
             0046** PUSH	BC
             0047** LD	A, val
             0048** CPL
             0049** LD	C, A
             0050** IN0	A, (reg)
             0051** AND	C
             0052** OUT0	(reg), A
             0053** POP	BC
             0054** ENDMACRO
              0003* include "basic/equs.inc"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Equs
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	08/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 08/06/2023:	Added SIZEW
             0009** 
             0010** ; XREF		STAVAR
             0011** ; XREF		ACCS
             0012** 
             0013** RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
             0014** ;Stack_Top:		EQU		0000h	; Stack at top
             0015** SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
             0016** 
             0017** ; For GPIO
             0018** ; PA not available on eZ80L92
             0019** ;
             0020** PA_DR:			EQU		96h
             0021** PA_DDR:			EQU		97h
             0022** PA_ALT1:		EQU		98h
             0023** PA_ALT2:		EQU		99h
             0024** PB_DR:          	EQU		9Ah
             0025** PB_DDR:        	 	EQU		9Bh
             0026** PB_ALT1:        	EQU		9Ch
             0027** PB_ALT2:        	EQU		9Dh
             0028** PC_DR:          	EQU		9Eh
             0029** PC_DDR:         	EQU		9Fh
             0030** PC_ALT1:        	EQU		A0h
             0031** PC_ALT2:        	EQU		A1h
             0032** PD_DR:          	EQU		A2h
             0033** PD_DDR:			EQU		A3h
             0034** PD_ALT1:		EQU		A4h
             0035** PD_ALT2:		EQU		A5h
             0036** 
             0037** GPIOMODE_OUT:		EQU		0	; Output
             0038** GPIOMODE_IN:		EQU		1	; Input
             0039** GPIOMODE_DIO:		EQU		2	; Open Drain IO
             0040** GPIOMODE_SIO:		EQU		3	; Open Source IO
             0041** GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
             0042** GPIOMODE_ALTF:		EQU		5;	; Alt Function
             0043** GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
             0044** GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
             0045** GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
             0046** GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
             0047** 
             0048** ; ; Originally in ram.asm
             0049** ; ;
             0050** ; OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
             0051** ; PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
             0052** ; VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
             0053** 
             0054** ; Originally in main.asm
             0055** ;
             0056** CR:			EQU     0DH
             0057** LF:			EQU     0AH
             0058** ESC:			EQU     1BH
              0004* ; include "basic/init.asm" ; relevant bits folded into calcbas.asm
              0005* include "basic/eval.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Expression Evaluation & Arithmetic Module - "EVAL"
             0004** ; Author:	(C) Copyright  R.T.Russell  1984
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	12/05/2023
             0007** ; Last Updated:	17/08/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 07/06/2023:	Modified to run in ADL mode
             0011** ; 26/06/2023:	Fixed HEX and HEXSTR
             0012** ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
             0013** ; 17/08/2023:	Added binary constants
             0014** 
             0015** ; .ASSUME	ADL = 1
             0016** 
             0017** ; INCLUDE	"equs.inc"
             0018** ; INCLUDE "macros.inc"
             0019** ; INCLUDE "mos_api.inc"	; In MOS/src
             0020** 
             0021** ; SEGMENT CODE
             0022** 
             0023** ; XDEF	EXPR
             0024** ; XDEF	EXPRN
             0025** ; XDEF	EXPRI
             0026** ; XDEF	EXPRS
             0027** ; XDEF	ITEMI
             0028** ; XDEF	LOADN
             0029** ; XDEF	LOAD4
             0030** ; XDEF	CONS
             0031** ; XDEF	LOADS
             0032** ; XDEF	SFIX
             0033** ; XDEF	VAL0
             0034** ; XDEF	SEARCH
             0035** ; XDEF	SWAP
             0036** ; XDEF	TEST
             0037** ; XDEF	DECODE
             0038** ; XDEF	HEXSTR
             0039** ; XDEF	STR
             0040** ; XDEF	ZERO
             0041** ; XDEF	PUSHS
             0042** ; XDEF	POPS
             0043** ; XDEF	COMMA
             0044** ; XDEF	BRAKET
             0045** ; XDEF	NXT
             0046** ; XDEF	COUNT0
             0047** 
             0048** ; XREF	ADVAL
             0049** ; XREF	FN_EX
             0050** ; XREF	POINT
             0051** ; XREF	USR
             0052** ; XREF	SYNTAX
             0053** ; XREF	ERROR_
             0054** ; XREF	CHECK
             0055** ; XREF	GETVAR
             0056** ; XREF	LISTON
             0057** ; XREF	RANGE
             0058** ; XREF	FPP
             0059** ; XREF	GETCSR
             0060** ; XREF	CHANEL
             0061** ; XREF	OSSTAT
             0062** ; XREF	OSBGET
             0063** ; XREF	LOMEM
             0064** ; XREF	HIMEM
             0065** ; XREF	PAGE_
             0066** ; XREF	TOP
             0067** ; XREF	ERL
             0068** ; XREF	ERR
             0069** ; XREF	COUNT
             0070** ; XREF	OSOPEN
             0071** ; XREF	GETEXT
             0072** ; XREF	GETPTR
             0073** ; XREF	GETIME
             0074** ; XREF	GETIMS
             0075** ; XREF	LEXAN2
             0076** ; XREF	RANDOM
             0077** ; XREF	STORE5
             0078** ; XREF	GETSCHR
             0079** ; XREF	OSRDCH
             0080** ; XREF	OSKEY
             0081** ; XREF	INKEY1
             0082** ; XREF	EXTERR
             0083** ;
             0084** ; BINARY FLOATING POINT REPRESENTATION:
             0085** ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
             0086** ;     8 BIT EXCESS-128 SIGNED EXPONENT
             0087** ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
             0088** ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
             0089** ;
             0090** ; BINARY INTEGER REPRESENTATION:
             0091** ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
             0092** ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
             0093** ;
             0094** ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
             0095** ;                             EXPONENT - C
             0096** ;
             0097** 
             0098** ;
             0099** ; Table of addresses for functions
             0100** ;
             0101** FUNTOK:			EQU	8DH			; First token number
             0102** ;
0B04D4 B0    0103** FUNTBL:			DW24	DECODE			; Line number
0B04D5 0C 
0B04D6 0B 
0B04D7 5E    0104** DW24	OPENIN			; OPENIN
0B04D8 09 
0B04D9 0B 
0B04DA 80    0105** DW24	PTR_EV			; PTR
0B04DB 09 
0B04DC 0B 
0B04DD 1A    0106** DW24	PAGEV			; PAGE
0B04DE 09 
0B04DF 0B 
0B04E0 8A    0107** DW24	TIMEV			; TIME
0B04E1 09 
0B04E2 0B 
0B04E3 06    0108** DW24	LOMEMV			; LOMEM
0B04E4 09 
0B04E5 0B 
0B04E6 10    0109** DW24	HIMEMV			; HIMEM
0B04E7 09 
0B04E8 0B 
0B04E9 DE    0110** DW24	ABSV			; ABS
0B04EA 09 
0B04EB 0B 
0B04EC 1A    0111** DW24	ACS			; ACS
0B04ED 0A 
0B04EE 0B 
0B04EF 81    0112** DW24	ADVAL			; ADVAL
0B04F0 47 
0B04F1 0B 
0B04F2 EF    0113** DW24	ASC			; ASC
0B04F3 08 
0B04F4 0B 
0B04F5 12    0114** DW24	ASN			; ASN
0B04F6 0A 
0B04F7 0B 
0B04F8 16    0115** DW24	ATN			; ATN
0B04F9 0A 
0B04FA 0B 
0B04FB B8    0116** DW24	BGET			; BGET
0B04FC 08 
0B04FD 0B 
0B04FE FE    0117** DW24	COS			; COS
0B04FF 09 
0B0500 0B 
0B0501 45    0118** DW24	COUNTV			; COUNT
0B0502 09 
0B0503 0B 
0B0504 E6    0119** DW24	DEG			; DEG
0B0505 09 
0B0506 0B 
0B0507 39    0120** DW24	ERLV			; ERL
0B0508 09 
0B0509 0B 
0B050A 3F    0121** DW24	ERRV			; ERR
0B050B 09 
0B050C 0B 
0B050D 43    0122** DW24	EVAL_			; EVAL
0B050E 0A 
0B050F 0B 
0B0510 06    0123** DW24	EXP			; EXP
0B0511 0A 
0B0512 0B 
0B0513 76    0124** DW24	EXT			; EXT
0B0514 09 
0B0515 0B 
0B0516 5D    0125** DW24	ZERO			; FALSE
0B0517 0D 
0B0518 0B 
0B0519 49    0126** DW24	FN_EX			; FN
0B051A 14 
0B051B 0B 
0B051C D6    0127** DW24	GET			; GET
0B051D 08 
0B051E 0B 
0B051F C5    0128** DW24	INKEY			; INKEY
0B0520 08 
0B0521 0B 
0B0522 F5    0129** DW24	INSTR			; INSTR(
0B0523 0A 
0B0524 0B 
0B0525 F2    0130** DW24	INT_			; INT
0B0526 09 
0B0527 0B 
0B0528 FF    0131** DW24	LEN			; LEN
0B0529 08 
0B052A 0B 
0B052B 0A    0132** DW24	LN			; LN
0B052C 0A 
0B052D 0B 
0B052E 0E    0133** DW24	LOG			; LOG
0B052F 0A 
0B0530 0B 
0B0531 E2    0134** DW24	NOTK			; NOT
0B0532 09 
0B0533 0B 
0B0534 5A    0135** DW24	OPENUP			; OPENUP
0B0535 09 
0B0536 0B 
0B0537 57    0136** DW24	OPENOT			; OPENOUT
0B0538 09 
0B0539 0B 
0B053A DA    0137** DW24	PI			; PI
0B053B 09 
0B053C 0B 
0B053D 33    0138** DW24	POINT			; POINT(
0B053E 48 
0B053F 0B 
0B0540 97    0139** DW24	POS			; POS
0B0541 08 
0B0542 0B 
0B0543 EA    0140** DW24	RAD			; RAD
0B0544 09 
0B0545 0B 
0B0546 77    0141** DW24	RND			; RND
0B0547 0A 
0B0548 0B 
0B0549 EE    0142** DW24	SGN			; SGN
0B054A 09 
0B054B 0B 
0B054C 02    0143** DW24	SIN			; SIN
0B054D 0A 
0B054E 0B 
0B054F F6    0144** DW24	SQR			; SQR
0B0550 09 
0B0551 0B 
0B0552 FA    0145** DW24	TAN			; TAN
0B0553 09 
0B0554 0B 
0B0555 24    0146** DW24	TOPV			; TO(P)
0B0556 09 
0B0557 0B 
0B0558 CF    0147** DW24	TRUE			; TRUE
0B0559 09 
0B055A 0B 
0B055B EC    0148** DW24	USR			; USR
0B055C 18 
0B055D 0B 
0B055E 34    0149** DW24	VAL			; VAL
0B055F 0A 
0B0560 0B 
0B0561 A0    0150** DW24	VPOS			; VPOS
0B0562 08 
0B0563 0B 
0B0564 89    0151** DW24	CHRS			; CHRS
0B0565 0B 
0B0566 0B 
0B0567 91    0152** DW24	GETS			; GETS
0B0568 0B 
0B0569 0B 
0B056A A2    0153** DW24	INKEYS			; INKEYS
0B056B 0B 
0B056C 0B 
0B056D 27    0154** DW24	LEFTS			; LEFTS(
0B056E 0C 
0B056F 0B 
0B0570 EF    0155** DW24	MIDS			; MIDS(
0B0571 0B 
0B0572 0B 
0B0573 47    0156** DW24	RIGHTS			; RIGHTS(
0B0574 0C 
0B0575 0B 
0B0576 14    0157** DW24	STRS			; STR$
0B0577 0D 
0B0578 0B 
0B0579 68    0158** DW24	STRING_			; STRINGS(
0B057A 0C 
0B057B 0B 
0B057C A8    0159** DW24	EOF			; EOF
0B057D 08 
0B057E 0B 
             0160** ;
             0161** FUNTBL_END:		EQU	$
             0162** ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
             0163** TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
             0164** 
             0165** ANDK:			EQU     80H
             0166** DIVK:			EQU     81H
             0167** EORK:			EQU     82H
             0168** MODK:			EQU     83H
             0169** ORK:			EQU     84H
             0170** ;
0B057F BA    0171** SOPTBL:			DW24	SLE			; <= (STRING)
0B0580 09 
0B0581 0B 
0B0582 C3    0172** DW24	SNE			; <>
0B0583 09 
0B0584 0B 
0B0585 B3    0173** DW24	SGE			; >=
0B0586 09 
0B0587 0B 
0B0588 A4    0174** DW24	SLT			; <
0B0589 09 
0B058A 0B 
0B058B CA    0175** DW24	SEQ			; =
0B058C 09 
0B058D 0B 
0B058E AB    0176** DW24	SGT			; >
0B058F 09 
0B0590 0B 
             0177** ;
             0178** ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
             0179** ;     Expression type is returned in A'F':
             0180** ;        Numeric - A' bit 7=0, F' sign bit cleared.
             0181** ;         String - A' bit 7=1, F' sign bit set.
             0182** ; Floating-point or integer result returned in HLH'L'C
             0183** ; Integer result denoted by C=0 and HLH'L' non-zero.
             0184** ; String result returned in string accumulator, DE set.
             0185** ;
             0186** ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
             0187** ;               (2) ^
             0188** ;               (3) * / MOD DIV
             0189** ;               (4) + -
             0190** ;               (5) = <> <= >= > <
             0191** ;               (6) AND
             0192** ;               (7) EOR OR
             0193** 
             0194** ;
             0195** ; Level 7: EOR and OR
             0196** ;
0B0591 CD    0197** EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0B0592 AA 
0B0593 05 
0B0594 0B 
0B0595 FE    0198** EXPR0A:			CP      EORK            	; Is operator EOR?
0B0596 82 
0B0597 28    0199** JR      Z,EXPR0B		; Yes, so skip to next bit
0B0598 03 
0B0599 FE    0200** CP      ORK			; Is operator OR
0B059A 84 
0B059B C0    0201** RET     NZ			; No, so return
             0202** ;
0B059C CD    0203** EXPR0B:			CALL    SAVE_EV            	; Save first operand
0B059D 08 
0B059E 0E 
0B059F 0B 
0B05A0 CD    0204** CALL    EXPR1           	; Get second operand
0B05A1 AA 
0B05A2 05 
0B05A3 0B 
0B05A4 CD    0205** CALL    DOIT            	; Do the operation
0B05A5 17 
0B05A6 0E 
0B05A7 0B 
0B05A8 18    0206** JR      EXPR0A          	; And continue
0B05A9 EB 
             0207** ;
             0208** ; Level 6: AND
             0209** ;
0B05AA CD    0210** EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0B05AB BF 
0B05AC 05 
0B05AD 0B 
0B05AE FE    0211** EXPR1A:			CP      ANDK			; Is operator AND?
0B05AF 80 
0B05B0 C0    0212** RET     NZ			; No, so return
0B05B1 CD    0213** CALL    SAVE_EV			; Save first operand
0B05B2 08 
0B05B3 0E 
0B05B4 0B 
0B05B5 CD    0214** CALL    EXPR2			; Get second operand
0B05B6 BF 
0B05B7 05 
0B05B8 0B 
0B05B9 CD    0215** CALL    DOIT			; Do the operation
0B05BA 17 
0B05BB 0E 
0B05BC 0B 
0B05BD 18    0216** JR      EXPR1A			; And continue
0B05BE EF 
             0217** ;
             0218** ; Level 5: Comparisons
             0219** ;
0B05BF CD    0220** EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0B05C0 31 
0B05C1 06 
0B05C2 0B 
0B05C3 CD    0221** CALL    RELOP?			; Is it ">", "=" or "<"?
0B05C4 DF 
0B05C5 0D 
0B05C6 0B 
0B05C7 C0    0222** RET     NZ			; No, so return
0B05C8 47    0223** LD      B,A			; Store the first operator in B
0B05C9 FD    0224** INC     IY              	; Bump over operator
0B05CA 23 
0B05CB CD    0225** CALL    NXT			;
0B05CC 3A 
0B05CD 0E 
0B05CE 0B 
0B05CF CD    0226** CALL    RELOP?          	; Is it a compound operator?
0B05D0 DF 
0B05D1 0D 
0B05D2 0B 
0B05D3 20    0227** JR      NZ,EXPR2B		; No, so skip next bit
0B05D4 09 
0B05D5 FD    0228** INC     IY			; Bump over operator
0B05D6 23 
0B05D7 B8    0229** CP      B			; Compare with first
0B05D8 CA    0230** JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
0B05D9 61 
0B05DA 10 
0B05DB 0B 
0B05DC 80    0231** ADD     A,B
0B05DD 47    0232** LD      B,A			; B: Unique code for the compound operator
0B05DE 78    0233** EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
0B05DF 08    0234** EX      AF,AF'
0B05E0 FA    0235** JP      M,EXPR2S		; If it is a string, then branch here to handle it
0B05E1 FA 
0B05E2 05 
0B05E3 0B 
0B05E4 08    0236** EX      AF,AF'
0B05E5 D6    0237** SUB     4
0B05E6 04 
0B05E7 FE    0238** CP      '>'-4
0B05E8 3A 
0B05E9 20    0239** JR      NZ,EXPR2C
0B05EA 02 
0B05EB C6    0240** ADD     A,2
0B05EC 02 
0B05ED CD    0241** EXPR2C:			CALL    SAVE1
0B05EE 0A 
0B05EF 0E 
0B05F0 0B 
0B05F1 CD    0242** CALL    EXPR3
0B05F2 31 
0B05F3 06 
0B05F4 0B 
0B05F5 CD    0243** CALL    DOIT            	; NB: Must NOT be "JP DOIT"
0B05F6 17 
0B05F7 0E 
0B05F8 0B 
0B05F9 C9    0244** RET
             0245** ;
0B05FA 08    0246** EXPR2S:			EX      AF,AF'			; Handle string comparisons
0B05FB 3D    0247** DEC     A
0B05FC E6    0248** AND     7
0B05FD 07 
0B05FE CD    0249** CALL    PUSHS           	; Save string on the stack
0B05FF 7E 
0B0600 0D 
0B0601 0B 
0B0602 F5    0250** PUSH    AF              	; Save the operator
0B0603 CD    0251** CALL    EXPR3           	; Get the second string
0B0604 31 
0B0605 06 
0B0606 0B 
0B0607 08    0252** EX      AF,AF'
0B0608 F2    0253** JP      P,TYPE_EV_
0B0609 00 
0B060A 07 
0B060B 0B 
0B060C F1    0254** POP     AF
0B060D 4B    0255** LD      C,E             	; Length of string #2
0B060E D1    0256** POP     DE
0B060F 21    0257** LD      HL,0
0B0610 00 
0B0611 00 
0B0612 00 
0B0613 39    0258** ADD     HL,SP
0B0614 43    0259** LD      B,E             	; Length of string #1
0B0615 D5    0260** PUSH    DE
0B0616 11    0261** LD      DE,ACCS
0B0617 00 
0B0618 4E 
0B0619 0B 
0B061A EB    0262** EX      DE,HL
0B061B CD    0263** CALL    DISPT2
0B061C 46 
0B061D 0E 
0B061E 0B 
0B061F D1    0264** POP     DE
0B0620 EB    0265** EX      DE,HL
0B0621 7D    0266** LD	A,L
0B0622 21    0267** LD	HL,0
0B0623 00 
0B0624 00 
0B0625 00 
0B0626 6F    0268** LD	L,A
0B0627 39    0269** ADD     HL,SP
0B0628 F9    0270** LD      SP,HL
0B0629 EB    0271** EX      DE,HL
0B062A AF    0272** XOR     A               	; Numeric marker
0B062B 4F    0273** LD      C,A             	; Integer marker
0B062C 08    0274** EX      AF,AF'
0B062D FD    0275** LD      A,(IY)
0B062E 7E 
0B062F 00 
0B0630 C9    0276** RET
             0277** ;
             0278** ; Level 4: + and -
             0279** ;
0B0631 CD    0280** EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
0B0632 8E 
0B0633 06 
0B0634 0B 
0B0635 FE    0281** EXPR3A:			CP      '-'			; Is it "-"?
0B0636 2D 
0B0637 28    0282** JR      Z,EXPR3B		; Yes, so skip the next bit
0B0638 09 
0B0639 FE    0283** CP      '+'			; Is it "+"?
0B063A 2B 
0B063B C0    0284** RET     NZ			; No, so return
0B063C 08    0285** EX      AF,AF'			; Get the type
0B063D FA    0286** JP      M,EXPR3S		; Branch here if string
0B063E 50 
0B063F 06 
0B0640 0B 
0B0641 08    0287** EX      AF,AF'
0B0642 CD    0288** EXPR3B:			CALL    SAVE_EV			; Save the first operator
0B0643 08 
0B0644 0E 
0B0645 0B 
0B0646 CD    0289** CALL    EXPR4			; Fetch the second operator
0B0647 8E 
0B0648 06 
0B0649 0B 
0B064A CD    0290** CALL    DOIT			; Do the operation
0B064B 17 
0B064C 0E 
0B064D 0B 
0B064E 18    0291** JR      EXPR3A			; And continue
0B064F E5 
             0292** ;
0B0650 08    0293** EXPR3S:			EX      AF,AF'			; Handle string concatenation
0B0651 FD    0294** INC     IY              	; Bump past the "+"
0B0652 23 
0B0653 CD    0295** CALL    PUSHS           	; Save the string on the stack
0B0654 7E 
0B0655 0D 
0B0656 0B 
0B0657 CD    0296** CALL    EXPR4           	; Fetch the second operator
0B0658 8E 
0B0659 06 
0B065A 0B 
0B065B 08    0297** EX      AF,AF'
0B065C F2    0298** JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0B065D 00 
0B065E 07 
0B065F 0B 
0B0660 01    0299** LD	BC, 0			; Clear BC
0B0661 00 
0B0662 00 
0B0663 00 
0B0664 4B    0300** LD      C,E             	; C: Length of the second string
0B0665 D1    0301** POP     DE
0B0666 D5    0302** PUSH    DE
0B0667 21    0303** LD      HL,ACCS
0B0668 00 
0B0669 4E 
0B066A 0B 
             0304** ; BEGIN MISSING FROM BINARY
             0305** ; LD	A,E			;  E: Length of the first string
             0306** ; LD      DE,ACCS
             0307** ; LD	E,A 			; DE: Pointer to the end of the first string
             0308** ; END MISSING FROM BINARY
0B066B 54    0309** LD		D,H ; ADDED FROM BINARY
0B066C 79    0310** LD      A,C
0B066D B7    0311** OR      A
0B066E 28    0312** JR      Z,EXP3S3
0B066F 0F 
0B0670 6F    0313** LD      L,A             	; Source
0B0671 83    0314** ADD     A,E
0B0672 5F    0315** LD      E,A             	; Destination
0B0673 3E    0316** LD      A,19
0B0674 13 
0B0675 DA    0317** JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0B0676 2A 
0B0677 3B 
0B0678 0B 
0B0679 D5    0318** PUSH    DE
0B067A 1D    0319** DEC     E
0B067B 2D    0320** DEC     L
0B067C ED    0321** LDDR                    	; Copy
0B067D B8 
0B067E D1    0322** POP     DE
0B067F D9    0323** EXP3S3:			EXX
0B0680 C1    0324** POP     BC
0B0681 CD    0325** CALL    POPS            	; Restore from stack
0B0682 A8 
0B0683 0D 
0B0684 0B 
0B0685 D9    0326** EXX
0B0686 F6    0327** OR      80H             	; Flag as a string
0B0687 80 
0B0688 08    0328** EX      AF,AF'
0B0689 FD    0329** LD      A,(IY)			; Fetch the next character
0B068A 7E 
0B068B 00 
0B068C 18    0330** JR      EXPR3A			; And continue
0B068D A7 
             0331** ;
             0332** ; Level 3: * / MOD DIV
             0333** ;
0B068E CD    0334** EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0B068F AF 
0B0690 06 
0B0691 0B 
0B0692 FE    0335** EXPR4A:			CP      '*'			; "*" is valid
0B0693 2A 
0B0694 28    0336** JR      Z,EXPR4B
0B0695 0B 
0B0696 FE    0337** CP      '/'			; "/" is valid
0B0697 2F 
0B0698 28    0338** JR      Z,EXPR4B
0B0699 07 
0B069A FE    0339** CP      MODK			; MOD token is valid
0B069B 83 
0B069C 28    0340** JR      Z,EXPR4B
0B069D 03 
0B069E FE    0341** CP      DIVK			; DIV token is valid
0B069F 81 
0B06A0 C0    0342** RET     NZ			; And return if it is anything else
0B06A1 CD    0343** EXPR4B:			CALL    SAVE_EV
0B06A2 08 
0B06A3 0E 
0B06A4 0B 
0B06A5 CD    0344** CALL    EXPR5
0B06A6 AF 
0B06A7 06 
0B06A8 0B 
0B06A9 CD    0345** CALL    DOIT
0B06AA 17 
0B06AB 0E 
0B06AC 0B 
0B06AD 18    0346** JR      EXPR4A
0B06AE E3 
             0347** ;
             0348** ; Level 2: ^
             0349** ;
0B06AF CD    0350** EXPR5:			CALL    ITEM			; Get variable
0B06B0 8F 
0B06B1 07 
0B06B2 0B 
0B06B3 B7    0351** OR      A               	; Test type
0B06B4 08    0352** EX      AF,AF'          	; Save type
0B06B5 CD    0353** EXPR5A:			CALL    NXT			; Skip spaces
0B06B6 3A 
0B06B7 0E 
0B06B8 0B 
0B06B9 FE    0354** CP      '^'			; Is the operator "^"?
0B06BA 5E 
0B06BB C0    0355** RET     NZ			; No, so return
0B06BC CD    0356** CALL    SAVE_EV			; Save first operand
0B06BD 08 
0B06BE 0E 
0B06BF 0B 
0B06C0 CD    0357** CALL    ITEM			; Get second operand
0B06C1 8F 
0B06C2 07 
0B06C3 0B 
0B06C4 B7    0358** OR      A			; Test type
0B06C5 08    0359** EX      AF,AF'			; Save type
0B06C6 CD    0360** CALL    DOIT			; Do the operation
0B06C7 17 
0B06C8 0E 
0B06C9 0B 
0B06CA 18    0361** JR      EXPR5A			; And continue
0B06CB E9 
             0362** ;
             0363** ; Evaluate a numeric expression
             0364** ;
0B06CC CD    0365** EXPRN:			CALL    EXPR			; Evaluate expression
0B06CD 91 
0B06CE 05 
0B06CF 0B 
0B06D0 08    0366** EX      AF,AF'			; Get the type
0B06D1 F0    0367** RET     P			; And return if it is a number
0B06D2 18    0368** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B06D3 2C 
             0369** ;
             0370** ; Evaluate a fixed-point expression
             0371** ;
0B06D4 CD    0372** EXPRI:			CALL    EXPR			; Evaluate the expression
0B06D5 91 
0B06D6 05 
0B06D7 0B 
0B06D8 08    0373** EX      AF,AF'			; Get the type
0B06D9 F2    0374** JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B06DA 2C 
0B06DB 0A 
0B06DC 0B 
0B06DD 18    0375** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B06DE 21 
             0376** ;
             0377** ; Evaluate a string expression
             0378** ;
0B06DF CD    0379** EXPRS:			CALL    EXPR			; Evaluate the expression
0B06E0 91 
0B06E1 05 
0B06E2 0B 
0B06E3 08    0380** EX      AF,AF'			; Get the type
0B06E4 F8    0381** RET     M			; And return if it is a string
0B06E5 18    0382** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B06E6 19 
             0383** ;
             0384** ; Get a numeric variable
             0385** ;
0B06E7 CD    0386** ITEMN:			CALL    ITEM			; Get the variable
0B06E8 8F 
0B06E9 07 
0B06EA 0B 
0B06EB B7    0387** OR      A			; Test the type
0B06EC F0    0388** RET     P			; And return if it is a number
0B06ED 18    0389** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B06EE 11 
             0390** ;
             0391** ; Get a fixed-point variable
             0392** ;
0B06EF CD    0393** ITEMI:			CALL    ITEM			; Get the variable
0B06F0 8F 
0B06F1 07 
0B06F2 0B 
0B06F3 B7    0394** OR      A			; Test the type
0B06F4 F2    0395** JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B06F5 2C 
0B06F6 0A 
0B06F7 0B 
0B06F8 18    0396** JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B06F9 06 
             0397** ;
             0398** ; Get a string variable
             0399** ;
0B06FA CD    0400** ITEMS:			CALL    ITEM			; Get the variable
0B06FB 8F 
0B06FC 07 
0B06FD 0B 
0B06FE B7    0401** OR      A			; Test the type
0B06FF F8    0402** RET     M			; If it is a string, then return
             0403** ;							; Otherwise
0B0700 3E    0404** TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
0B0701 06 
0B0702 C3    0405** JP      ERROR_
0B0703 2A 
0B0704 3B 
0B0705 0B 
             0406** ;
             0407** ; Evaluate a bracketed expression
             0408** ;
0B0706 CD    0409** ITEM1:			CALL    EXPR            	; Evaluate the expression
0B0707 91 
0B0708 05 
0B0709 0B 
0B070A CD    0410** CALL    BRAKET			; Check for closing bracket
0B070B F9 
0B070C 0D 
0B070D 0B 
0B070E 08    0411** EX      AF,AF'
0B070F C9    0412** RET
             0413** ;
             0414** ; HEX - Get hexadecimal constant.
             0415** ;   Inputs: ASCII string at (IY)
             0416** ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
             0417** ;           IY updated (points to delimiter)
             0418** ;
0B0710 CD    0419** HEX:			CALL    ZERO			; Set result to 0
0B0711 5D 
0B0712 0D 
0B0713 0B 
0B0714 CD    0420** CALL    HEXDIG			; Fetch the character from IY
0B0715 C2 
0B0716 0D 
0B0717 0B 
0B0718 38    0421** JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
0B0719 1B 
0B071A FD    0422** HEX1:			INC     IY			; Move pointer to next character
0B071B 23 
0B071C E6    0423** AND     0FH			; Clear the top nibble
0B071D 0F 
0B071E 06    0424** LD      B,4			; Loop counter
0B071F 04 
             0425** ;
0B0720 D9    0426** HEX2:			EXX				; Shift the result left B (4) times. This makes
0B0721 52    0427** ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
0B0722 29 
0B0723 D9    0428** EXX				; .
0B0724 52    0429** ADC.S   HL,HL			; .
0B0725 ED 
0B0726 6A 
0B0727 10    0430** DJNZ    HEX2			; And loop
0B0728 F7 
0B0729 D9    0431** EXX
0B072A B5    0432** OR      L			; OR in the digit
0B072B 6F    0433** LD      L,A
0B072C D9    0434** EXX
             0435** ;
0B072D CD    0436** CALL    HEXDIG			; Fetch the next character
0B072E C2 
0B072F 0D 
0B0730 0B 
0B0731 30    0437** JR      NC,HEX1			; If it is a HEX digit then loop
0B0732 E7 
0B0733 AF    0438** XOR     A			; Clear A
0B0734 C9    0439** RET
             0440** ;
0B0735 3E    0441** BADHEX:			LD      A,28
0B0736 1C 
0B0737 C3    0442** JP      ERROR_          	; Error: "Bad HEX"
0B0738 2A 
0B0739 3B 
0B073A 0B 
             0443** ;
             0444** ; BIN - Get binary constant.
             0445** ;   Inputs: ASCII string at (IY)
             0446** ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
             0447** ;           IY updated (points to delimiter)
             0448** ;
0B073B CD    0449** BIN:			CALL    ZERO			; Set result to 0
0B073C 5D 
0B073D 0D 
0B073E 0B 
0B073F CD    0450** CALL	BINDIG			; Fetch the character from IY
0B0740 D5 
0B0741 0D 
0B0742 0B 
0B0743 38    0451** JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
0B0744 13 
0B0745 FD    0452** BIN1:			INC	IY			; Move pointer to next character
0B0746 23 
0B0747 0F    0453** RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
0B0748 D9    0454** EXX				;
0B0749 52    0455** ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
0B074A ED 
0B074B 6A 
0B074C D9    0456** EXX
0B074D 52    0457** ADC.S	HL,HL
0B074E ED 
0B074F 6A 
0B0750 CD    0458** CALL	BINDIG			; Fetch the next character
0B0751 D5 
0B0752 0D 
0B0753 0B 
0B0754 30    0459** JR	NC,BIN1
0B0755 EF 
0B0756 AF    0460** XOR	A			; Clear A
0B0757 C9    0461** RET
             0462** ;
0B0758 3E    0463** BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0B0759 1C 
0B075A CD    0464** CALL	EXTERR
0B075B 41 
0B075C 3B 
0B075D 0B 
0B075E 42    0465** DB	"Bad Binary", 0
0B075F 61 
0B0760 64 
0B0761 20 
0B0761 42   
0B0762 69 
0B0763 6E 
0B0764 61 
0B0764 72   
0B0765 79 
0B0766 00 
             0466** ;
             0467** ; MINUS - Unary minus.
             0468** ;   Inputs: IY = text pointer
             0469** ;  Outputs: Numeric result, same type as argument.
             0470** ;           Result in H'L'HLC
             0471** ;
0B0769 CD    0472** MINUS:			CALL    ITEMN			; Get the numeric argument
0B076A E7 
0B076B 06 
0B076C 0B 
0B076D 0D    0473** MINUS0:			DEC     C			; Check exponent (C)
0B076E 0C    0474** INC     C			; If it is zero, then it's either a FP zero or an integer
0B076F 28    0475** JR      Z,NEGATE_EV        	; So do an integer negation
0B0770 06 
             0476** ;
0B0771 7C    0477** LD      A,H			; Do a FP negation by
0B0772 EE    0478** XOR     80H             	; Toggling the sign bit (H)
0B0773 80 
0B0774 67    0479** LD      H,A
0B0775 AF    0480** XOR     A               	; Numeric marker
0B0776 C9    0481** RET
             0482** ;
0B0777 D9    0483** NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0B0778 7C    0484** LD      A,H			; First do a one's complement by negating all the bytes
0B0779 2F    0485** CPL
0B077A 67    0486** LD      H,A
0B077B 7D    0487** LD      A,L
0B077C 2F    0488** CPL
0B077D 6F    0489** LD      L,A
0B077E D9    0490** EXX
0B077F 7C    0491** LD      A,H
0B0780 2F    0492** CPL
0B0781 67    0493** LD      H,A
0B0782 7D    0494** LD      A,L
0B0783 2F    0495** CPL
0B0784 6F    0496** LD      L,A
0B0785 D9    0497** ADD1:			EXX				; Then add 1
0B0786 23    0498** INC     HL
0B0787 7C    0499** LD      A,H
0B0788 B5    0500** OR      L
0B0789 D9    0501** EXX
0B078A 3E    0502** LD      A,0             	; Numeric marker
0B078B 00 
0B078C C0    0503** RET     NZ
0B078D 23    0504** INC     HL
0B078E C9    0505** RET
             0506** ;
             0507** ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
             0508** ; Item type is returned in A:  Bit 7=0 numeric.
             0509** ;                              Bit 7=1 string.
             0510** ; Numeric item returned in HLH'L'C.
             0511** ; String item returned in string accumulator,
             0512** ;   DE addresses byte after last (E=length).
             0513** ;
0B078F CD    0514** ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0B0790 19 
0B0791 1A 
0B0792 0B 
0B0793 CD    0515** CALL    NXT			; Skip spaces
0B0794 3A 
0B0795 0E 
0B0796 0B 
0B0797 FD    0516** INC     IY			; Move to the prefix character
0B0798 23 
0B0799 FE    0517** CP      '&'			; If `&`
0B079A 26 
0B079B CA    0518** JP      Z,HEX           	; Then get a HEX constant
0B079C 10 
0B079D 07 
0B079E 0B 
0B079F FE    0519** CP	'%'			; If '%'
0B07A0 25 
0B07A1 28    0520** JR	Z,BIN			; Then get a BINARY constant
0B07A2 98 
0B07A3 FE    0521** CP      '-'			; If `-`
0B07A4 2D 
0B07A5 28    0522** JR      Z,MINUS         	; Then get a negative number
0B07A6 C2 
0B07A7 FE    0523** CP      '+'			; If `+`
0B07A8 2B 
0B07A9 CA    0524** JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0B07AA E7 
0B07AB 06 
0B07AC 0B 
0B07AD FE    0525** CP      '('			; If `(`
0B07AE 28 
0B07AF CA    0526** JP      Z,ITEM1         	; Start of a bracketed expression
0B07B0 06 
0B07B1 07 
0B07B2 0B 
0B07B3 FE    0527** CP      34			; If `"`
0B07B4 22 
0B07B5 28    0528** JR      Z,CONS          	; Start of a string constant
0B07B6 7A 
0B07B7 FE    0529** CP      TCMD_EV			; Is it out of range of the function table?
0B07B8 C6 
0B07B9 D2    0530** JP      NC,SYNTAX       	; Error: "Syntax Error"
0B07BA 61 
0B07BB 10 
0B07BC 0B 
0B07BD FE    0531** CP      FUNTOK			; If it is in range, then
0B07BE 8D 
0B07BF D2    0532** JP      NC,DISPAT       	; It's a function
0B07C0 4D 
0B07C1 0E 
0B07C2 0B 
0B07C3 FD    0533** DEC     IY
0B07C4 2B 
0B07C5 FE    0534** CP      ':'
0B07C6 3A 
0B07C7 30    0535** JR      NC,ITEM2		; VARIABLE?
0B07C8 0C 
0B07C9 FE    0536** CP      '0'
0B07CA 30 
0B07CB D2    0537** JP      NC,CON			; NUMERIC CONSTANT
0B07CC 58 
0B07CD 08 
0B07CE 0B 
0B07CF FE    0538** CP      '.'
0B07D0 2E 
0B07D1 CA    0539** JP      Z,CON			; NUMERIC CONSTANT
0B07D2 58 
0B07D3 08 
0B07D4 0B 
0B07D5 CD    0540** ITEM2:			CALL    GETVAR			; VARIABLE
0B07D6 04 
0B07D7 3E 
0B07D8 0B 
0B07D9 20    0541** JR      NZ,NOSUCH
0B07DA 37 
0B07DB B7    0542** OR      A
0B07DC FA    0543** JP      M,LOADS			; STRING VARIABLE
0B07DD 6A 
0B07DE 08 
0B07DF 0B 
0B07E0 B7    0544** LOADN:			OR      A
0B07E1 28    0545** JR      Z,LOAD1			; BYTE VARIABLE
0B07E2 20 
0B07E3 0E    0546** LD      C,0
0B07E4 00 
0B07E5 CB    0547** BIT     0,A
0B07E6 47 
0B07E7 28    0548** JR      Z,LOAD4			; INTEGER VARIABLE
0B07E8 03 
0B07E9 DD    0549** LOAD5:			LD      C,(IX+4)
0B07EA 4E 
0B07EB 04 
0B07EC D9    0550** LOAD4:			EXX
0B07ED 21    0551** LD	HL, 0			; TODO: Optimise
0B07EE 00 
0B07EF 00 
0B07F0 00 
0B07F1 DD    0552** LD      L,(IX+0)
0B07F2 6E 
0B07F3 00 
0B07F4 DD    0553** LD      H,(IX+1)
0B07F5 66 
0B07F6 01 
0B07F7 D9    0554** EXX
0B07F8 21    0555** LD	HL, 0			; TODO: Optimise
0B07F9 00 
0B07FA 00 
0B07FB 00 
0B07FC DD    0556** LD      L,(IX+2)
0B07FD 6E 
0B07FE 02 
0B07FF DD    0557** LD      H,(IX+3)
0B0800 66 
0B0801 03 
0B0802 C9    0558** RET
             0559** ;
0B0803 21    0560** LOAD1:			LD      HL,0
0B0804 00 
0B0805 00 
0B0806 00 
0B0807 D9    0561** EXX
0B0808 21    0562** LD      HL,0			; TODO: Optimise
0B0809 00 
0B080A 00 
0B080B 00 
0B080C DD    0563** LD      L,(IX+0)
0B080D 6E 
0B080E 00 
0B080F D9    0564** EXX
0B0810 4C    0565** LD      C,H
0B0811 C9    0566** RET
             0567** ;
0B0812 DA    0568** NOSUCH:			JP      C,SYNTAX
0B0813 61 
0B0814 10 
0B0815 0B 
0B0816 3A    0569** LD      A,(LISTON)
0B0817 40 
0B0818 51 
0B0819 0B 
0B081A CB    0570** BIT     5,A
0B081B 6F 
0B081C 3E    0571** LD      A,26
0B081D 1A 
0B081E 20    0572** JR      NZ,ERROR0_EV		; Throw "No such variable"
0B081F 26 
0B0820 FD    0573** NOS1:			INC     IY
0B0821 23 
0B0822 CD    0574** CALL    RANGE
0B0823 39 
0B0824 40 
0B0825 0B 
0B0826 30    0575** JR      NC,NOS1
0B0827 F8 
0B0828 DD    0576** LD      IX,PC
0B0829 21 
0B082A 40 
0B082B 50 
0B082B 0B   
0B082D AF    0577** XOR     A
0B082E 4F    0578** LD      C,A
0B082F 18    0579** JR      LOAD4
0B0830 BB 
             0580** ;
             0581** ;CONS - Get string constant from ASCII string.
             0582** ;   Inputs: ASCII string at (IY)
             0583** ;  Outputs: Result in string accumulator.
             0584** ;           D = MS byte of ACCS, E = string length
             0585** ;           A7 = 1 (string marker)
             0586** ;           IY updated
             0587** ;
0B0831 11    0588** CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
0B0832 00 
0B0833 4E 
0B0834 0B 
0B0835 FD    0589** CONS3:			LD      A,(IY)			; Fetch the first character and
0B0836 7E 
0B0837 00 
0B0838 FD    0590** INC     IY			; Increment the pointer
0B0839 23 
0B083A FE    0591** CP      '"'			; Check for start quote
0B083B 22 
0B083C 28    0592** JR      Z,CONS2			; Yes, so jump to the bit that parses the string
0B083D 0C 
             0593** ;
0B083E 12    0594** CONS1:			LD      (DE),A			; Store the character in the string accumulator
0B083F 1C    0595** INC     E			; Increment the string accumulator pointer
0B0840 FE    0596** CP      CR			; Is it CR
0B0841 0D 
0B0842 20    0597** JR      NZ,CONS3		; No, so keep looping
0B0843 F1 
             0598** ;
0B0844 3E    0599** LD      A,9
0B0845 09 
0B0846 C3    0600** ERROR0_EV:			JP      ERROR_           	; Throw error "Missing '"'
0B0847 2A 
0B0848 3B 
0B0849 0B 
             0601** ;
0B084A FD    0602** CONS2:			LD      A,(IY)			; Fetch the next character
0B084B 7E 
0B084C 00 
0B084D FE    0603** CP      '"'			; Check for end quote?
0B084E 22 
0B084F FD    0604** INC     IY			; Increment the pointer
0B0850 23 
0B0851 28    0605** JR      Z,CONS1			; It is the end of string marker so jump to the end routine
0B0852 EB 
0B0853 FD    0606** DEC     IY			;
0B0854 2B 
0B0855 3E    0607** LD      A,80H           	; String marker
0B0856 80 
0B0857 C9    0608** RET
             0609** ;
             0610** ;CON - Get unsigned numeric constant from ASCII string.
             0611** ;   Inputs: ASCII string at (IY).
             0612** ;  Outputs: Variable-type result in HLH'L'C
             0613** ;           IY updated (points to delimiter)
             0614** ;           A7 = 0 (numeric marker)
             0615** ;
0B0858 FD    0616** CON:			PUSH    IY
0B0859 E5 
0B085A DD    0617** POP     IX
0B085B E1 
0B085C 3E    0618** LD      A,36
0B085D 24 
0B085E CD    0619** CALL    FPP
0B085F 34 
0B0860 24 
0B0861 0B 
0B0862 38    0620** JR      C,ERROR0_EV
0B0863 E2 
0B0864 DD    0621** PUSH    IX
0B0865 E5 
0B0866 FD    0622** POP     IY
0B0867 E1 
0B0868 AF    0623** XOR     A
0B0869 C9    0624** RET
             0625** ;
0B086A 11    0626** LOADS:			LD      DE,ACCS			; Where to store the string
0B086B 00 
0B086C 4E 
0B086D 0B 
0B086E 1F    0627** RRA
0B086F 30    0628** JR      NC,LOADS2       	; Skip if it is a fixed string
0B0870 1A 
             0629** ;
0B0871 D9    0630** EXX				; This block was a call to LOAD4
0B0872 DD    0631** LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B0873 6E 
0B0874 00 
0B0875 DD    0632** LD      H,(IX+1)		; The maximum original string length
0B0876 66 
0B0877 01 
0B0878 D9    0633** EXX
0B0879 DD    0634** LD	HL,(IX+2)		; Address of the string (24-bit)
0B087A 27 
0B087B 02 
             0635** ;
0B087C D9    0636** EXX
0B087D 7D    0637** LD      A,L
0B087E D9    0638** EXX
0B087F B7    0639** OR      A
0B0880 01    0640** LD	BC,0			; BC: Number of bytes to copy
0B0881 00 
0B0882 00 
0B0883 00 
0B0884 4F    0641** LD      C,A
0B0885 3E    0642** LD      A,80H           	; String marker
0B0886 80 
0B0887 C8    0643** RET     Z
0B0888 ED    0644** LDIR
0B0889 B0 
0B088A C9    0645** RET
0B088B 7E    0646** LOADS2:			LD      A,(HL)
0B088C 12    0647** LD      (DE),A
0B088D 23    0648** INC     HL
0B088E FE    0649** CP      CR
0B088F 0D 
0B0890 3E    0650** LD      A,80H           	; String marker
0B0891 80 
0B0892 C8    0651** RET     Z
0B0893 1C    0652** INC     E
0B0894 20    0653** JR      NZ,LOADS2
0B0895 F5 
0B0896 C9    0654** RET                     	; Return null string
             0655** ;
             0656** ;VARIABLE-TYPE FUNCTIONS:
             0657** ;
             0658** ;Result returned in HLH'L'C (floating point)
             0659** ;Result returned in HLH'L' (C=0) (integer)
             0660** ;Result returned in string accumulator & DE (string)
             0661** ;All registers destroyed.
             0662** ;IY (text pointer) updated.
             0663** ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
             0664** ;
             0665** ;POS - horizontal cursor position.
             0666** ;VPOS - vertical cursor position.
             0667** ;EOF - return status of file.
             0668** ;BGET - read byte from file.
             0669** ;INKEY - as GET but wait only n centiseconds.
             0670** ;GET - wait for keypress and return ASCII value.
             0671** ;GET(n) - input from Z80 port n.
             0672** ;ASC - ASCII value of string.
             0673** ;LEN - length of string.
             0674** ;LOMEM - location of dynamic variables.
             0675** ;HIMEM - top of available RAM.
             0676** ;PAGE - start of current text page.
             0677** ;TOP - address of first free byte after program.
             0678** ;ERL - line number where last error occurred.
             0679** ;ERR - number of last error.
             0680** ;COUNT - number of printing characters since CR.
             0681** ;Results are integer numeric.
             0682** ;
0B0897 CD    0683** POS:			CALL    GETCSR			; Return the horizontal cursor position
0B0898 96 
0B0899 42 
0B089A 0B 
0B089B EB    0684** EX      DE,HL			;  L: The X cursor position
0B089C C3    0685** JP      COUNT1			; Return an 8-bit value
0B089D 4B 
0B089E 09 
0B089F 0B 
             0686** ;
0B08A0 CD    0687** VPOS:			CALL    GETCSR			; Return the vertical cursor position
0B08A1 96 
0B08A2 42 
0B08A3 0B 
0B08A4 C3    0688** JP      COUNT1			; Return an 8-bit value
0B08A5 4B 
0B08A6 09 
0B08A7 0B 
             0689** ;
0B08A8 CD    0690** EOF:			CALL    CHANEL			; Check for EOF
0B08A9 50 
0B08AA 1C 
0B08AB 0B 
0B08AC CD    0691** CALL    OSSTAT
0B08AD 0E 
0B08AE 47 
0B08AF 0B 
0B08B0 CA    0692** JP      Z,TRUE			; Yes, so return true
0B08B1 CF 
0B08B2 09 
0B08B3 0B 
0B08B4 C3    0693** JP      ZERO			; Otherwise return false (zero)
0B08B5 5D 
0B08B6 0D 
0B08B7 0B 
             0694** ;
0B08B8 CD    0695** BGET:			CALL    CHANEL          	; Channel number
0B08B9 50 
0B08BA 1C 
0B08BB 0B 
0B08BC CD    0696** CALL    OSBGET
0B08BD FD 
0B08BE 46 
0B08BF 0B 
0B08C0 6F    0697** LD      L,A
0B08C1 C3    0698** JP      COUNT0			; Return an 8-bit value
0B08C2 49 
0B08C3 09 
0B08C4 0B 
             0699** ;
0B08C5 CD    0700** INKEY:			CALL    ITEMI			; Get the argument
0B08C6 EF 
0B08C7 06 
0B08C8 0B 
0B08C9 CB    0701** BIT	7, H			; Check the sign
0B08CA 7C 
0B08CB D9    0702** EXX				; HL: The argument
0B08CC C2    0703** JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
0B08CD B5 
0B08CE 0B 
0B08CF 0B 
0B08D0 CD    0704** CALL	INKEY0 			; Do INKEY(n)
0B08D1 A7 
0B08D2 0B 
0B08D3 0B 
0B08D4 18    0705** JR      ASC0			; Return a numeric value
0B08D5 1D 
             0706** ;
0B08D6 CD    0707** GET:			CALL    NXT			; Skip whitespace
0B08D7 3A 
0B08D8 0E 
0B08D9 0B 
0B08DA FE    0708** CP      '('			; Is it GET(
0B08DB 28 
0B08DC 20    0709** JR      NZ,GET0			; No, so get a keyboard character
0B08DD 0B 
0B08DE CD    0710** CALL    ITEMI           	; Yes, so fetch the port address
0B08DF EF 
0B08E0 06 
0B08E1 0B 
0B08E2 D9    0711** EXX
0B08E3 44    0712** LD      B,H			; BC: The port address
0B08E4 4D    0713** LD      C,L
0B08E5 ED    0714** IN      L,(C)           	;  L: Input from port BC
0B08E6 68 
0B08E7 18    0715** JR      COUNT0			; Return an 8-bit value
0B08E8 60 
             0716** ;
0B08E9 CD    0717** GET0:			CALL    GETS			; Read the keyboard character
0B08EA 91 
0B08EB 0B 
0B08EC 0B 
0B08ED 18    0718** JR      ASC1			; And return the value
0B08EE 0A 
             0719** ;
0B08EF CD    0720** ASC:			CALL    ITEMS			; Get the string argument argument
0B08F0 FA 
0B08F1 06 
0B08F2 0B 
0B08F3 AF    0721** ASC0:			XOR     A			; Quickly check the length of the string in ACCS
0B08F4 BB    0722** CP      E			; Is the pointer 0
0B08F5 CA    0723** JP      Z,TRUE          	; Yes, so return -1 as it is a null string
0B08F6 CF 
0B08F7 09 
0B08F8 0B 
0B08F9 2A    0724** ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
0B08FA 00 
0B08FB 4E 
0B08FC 0B 
0B08FD 18    0725** JR      COUNT0			; An 8-bit value
0B08FE 4A 
             0726** ;
0B08FF CD    0727** LEN:			CALL    ITEMS			; Get the string argument
0B0900 FA 
0B0901 06 
0B0902 0B 
0B0903 EB    0728** EX      DE,HL			; HL: Pointer into ACCS
0B0904 18    0729** JR      COUNT0			; Return L
0B0905 43 
             0730** ;
0B0906 2A    0731** LOMEMV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
0B0907 1A 
0B0908 51 
0B0909 0B 
0B090A 3A    0732** LD	A, (LOMEM+2)
0B090B 1C 
0B090C 51 
0B090D 0B 
0B090E 18    0733** JR      COUNT2			; A 24-bit value
0B090F 41 
             0734** ;
0B0910 2A    0735** HIMEMV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
0B0911 20 
0B0912 51 
0B0913 0B 
0B0914 3A    0736** LD	A, (HIMEM+2)
0B0915 22 
0B0916 51 
0B0917 0B 
0B0918 18    0737** JR      COUNT2			; A 24-bit value
0B0919 37 
             0738** ;
0B091A 2A    0739** PAGEV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
0B091B 14 
0B091C 51 
0B091D 0B 
0B091E 3A    0740** LD	A, (PAGE_+2)		; A 24-bit value
0B091F 16 
0B0920 51 
0B0921 0B 
0B0922 18    0741** JR      COUNT2
0B0923 2D 
             0742** ;
0B0924 FD    0743** TOPV:			LD      A,(IY)			; Return the TOP system variable
0B0925 7E 
0B0926 00 
0B0927 FD    0744** INC     IY              	; Skip "P"
0B0928 23 
0B0929 FE    0745** CP      'P'
0B092A 50 
0B092B C2    0746** JP      NZ,SYNTAX       	; Throw "Syntax Error"
0B092C 61 
0B092D 10 
0B092E 0B 
0B092F 2A    0747** LD      HL,(TOP)
0B0930 17 
0B0931 51 
0B0932 0B 
0B0933 3A    0748** LD	A, (TOP+2)
0B0934 19 
0B0935 51 
0B0936 0B 
0B0937 18    0749** JR      COUNT2
0B0938 18 
             0750** ;
0B0939 2A    0751** ERLV:			LD      HL,(ERL)		; Return the error line
0B093A 33 
0B093B 51 
0B093C 0B 
0B093D 18    0752** JR      COUNT1			; A 16-bit value
0B093E 0C 
             0753** ;
0B093F 2A    0754** ERRV:			LD      HL,(ERR)		; Return the error value
0B0940 3F 
0B0941 51 
0B0942 0B 
0B0943 18    0755** JR      COUNT0			; An 8-bit value
0B0944 04 
             0756** ;
0B0945 2A    0757** COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
0B0946 3D 
0B0947 51 
0B0948 0B 
             0758** 
0B0949 26    0759** COUNT0:			LD      H,0			; Return L
0B094A 00 
0B094B D9    0760** COUNT1:			EXX				; Return HL
0B094C AF    0761** XOR     A
0B094D 4F    0762** LD      C,A             	; Integer marker
0B094E 67    0763** LD      H,A
0B094F 6F    0764** LD      L,A
0B0950 C9    0765** RET
0B0951 D9    0766** COUNT2:			EXX
0B0952 6F    0767** LD	L,A
0B0953 AF    0768** XOR	A
0B0954 4F    0769** LD	C,A			; Integer marker
0B0955 67    0770** LD	H,A
0B0956 C9    0771** RET
             0772** ;
             0773** ;OPENIN - Open a file for reading.
             0774** ;OPENOT - Open a file for writing.
             0775** ;OPENUP - Open a file for reading or writing.
             0776** ;Result is integer channel number (0 if error)
             0777** ;
0B0957 AF    0778** OPENOT:			XOR     A			; Open for writing
0B0958 18    0779** JR	OPENIN_1
0B0959 06 
             0780** ;
0B095A 3E    0781** OPENUP:			LD      A,2			; Open for reading / writing
0B095B 02 
0B095C 18    0782** JR	OPENIN_1
0B095D 02 
             0783** ;
0B095E 3E    0784** OPENIN:			LD      A,1			; Open for reading
0B095F 01 
             0785** ;
0B0960 F5    0786** OPENIN_1:		PUSH    AF              	; Save OPEN type
0B0961 CD    0787** CALL    ITEMS           	; Fetch the filename
0B0962 FA 
0B0963 06 
0B0964 0B 
0B0965 3E    0788** LD      A,CR
0B0966 0D 
0B0967 12    0789** LD      (DE),A
0B0968 F1    0790** POP     AF              	; Restore the OPEN type
0B0969 C6    0791** ADD     A,-1            	; Affect the flags
0B096A FF 
0B096B 21    0792** LD      HL,ACCS
0B096C 00 
0B096D 4E 
0B096E 0B 
0B096F CD    0793** CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0B0970 E6 
0B0971 46 
0B0972 0B 
0B0973 6F    0794** LD      L,A			; L: Channel number
0B0974 18    0795** JR      COUNT0			; Return channel number to BASIC
0B0975 D3 
             0796** ;
             0797** ;EXT - Return length of file.
             0798** ;PTR_EV - Return current file pointer.
             0799** ;Results are integer numeric.
             0800** ;
0B0976 CD    0801** EXT:			CALL    CHANEL
0B0977 50 
0B0978 1C 
0B0979 0B 
0B097A CD    0802** CALL    GETEXT
0B097B 44 
0B097C 47 
0B097D 0B 
0B097E 18    0803** JR      TIME0
0B097F 15 
             0804** ;
0B0980 CD    0805** PTR_EV:			CALL    CHANEL
0B0981 50 
0B0982 1C 
0B0983 0B 
0B0984 CD    0806** CALL    GETPTR
0B0985 18 
0B0986 47 
0B0987 0B 
0B0988 18    0807** JR      TIME0
0B0989 0B 
             0808** ;
             0809** ;TIME - Return current value of elapsed time.
             0810** ;Result is integer numeric.
             0811** ;
0B098A FD    0812** TIMEV:			LD      A,(IY)
0B098B 7E 
0B098C 00 
0B098D FE    0813** CP      '$'
0B098E 24 
0B098F 28    0814** JR      Z,TIMEVS
0B0990 0A 
0B0991 CD    0815** CALL    GETIME
0B0992 76 
0B0993 42 
0B0994 0B 
0B0995 D5    0816** TIME0:			PUSH    DE
0B0996 D9    0817** EXX
0B0997 E1    0818** POP     HL
0B0998 AF    0819** XOR     A
0B0999 4F    0820** LD      C,A
0B099A C9    0821** RET
             0822** ;
             0823** ;TIME$ - Return date/time string.
             0824** ;Result is string
             0825** ;
0B099B FD    0826** TIMEVS:			INC     IY              ;SKIP $
0B099C 23 
0B099D CD    0827** CALL    GETIMS
0B099E 5D 
0B099F 47 
0B09A0 0B 
0B09A1 3E    0828** LD      A,80H           ;MARK STRING
0B09A2 80 
0B09A3 C9    0829** RET
             0830** ;
             0831** ;String comparison:
             0832** ;
0B09A4 CD    0833** SLT:			CALL    SCP
0B09A5 59 
0B09A6 0D 
0B09A7 0B 
0B09A8 D0    0834** RET     NC
0B09A9 18    0835** JR      TRUE
0B09AA 24 
             0836** ;
0B09AB CD    0837** SGT:			CALL    SCP
0B09AC 59 
0B09AD 0D 
0B09AE 0B 
0B09AF C8    0838** RET     Z
0B09B0 D8    0839** RET     C
0B09B1 18    0840** JR      TRUE
0B09B2 1C 
             0841** ;
0B09B3 CD    0842** SGE:			CALL    SCP
0B09B4 59 
0B09B5 0D 
0B09B6 0B 
0B09B7 D8    0843** RET     C
0B09B8 18    0844** JR      TRUE
0B09B9 15 
             0845** ;
0B09BA CD    0846** SLE:			CALL    SCP
0B09BB 59 
0B09BC 0D 
0B09BD 0B 
0B09BE 28    0847** JR      Z,TRUE
0B09BF 0F 
0B09C0 D0    0848** RET     NC
0B09C1 18    0849** JR      TRUE
0B09C2 0C 
             0850** ;
0B09C3 CD    0851** SNE:			CALL    SCP
0B09C4 59 
0B09C5 0D 
0B09C6 0B 
0B09C7 C8    0852** RET     Z
0B09C8 18    0853** JR      TRUE
0B09C9 05 
             0854** ;
0B09CA CD    0855** SEQ:			CALL    SCP
0B09CB 59 
0B09CC 0D 
0B09CD 0B 
0B09CE C0    0856** RET     NZ
0B09CF 3E    0857** TRUE:			LD      A,-1
0B09D0 FF 
0B09D1 D9    0858** EXX
0B09D2 67    0859** LD      H,A
0B09D3 6F    0860** LD      L,A
0B09D4 D9    0861** EXX
0B09D5 67    0862** LD      H,A
0B09D6 6F    0863** LD      L,A
0B09D7 3C    0864** INC     A
0B09D8 4F    0865** LD      C,A
0B09D9 C9    0866** RET
             0867** ;
             0868** ;PI - Return PI (3.141592654)
             0869** ;Result is floating-point numeric.
             0870** ;
0B09DA 3E    0871** PI:			LD      A,35
0B09DB 23 
0B09DC 18    0872** JR      FPP1
0B09DD 44 
             0873** ;
             0874** ;ABS - Absolute value
             0875** ;Result is numeric, variable type.
             0876** ;
0B09DE 3E    0877** ABSV:			LD      A,16
0B09DF 10 
0B09E0 18    0878** JR      FPPN
0B09E1 3A 
             0879** ;
             0880** ;NOT - Complement integer.
             0881** ;Result is integer numeric.
             0882** ;
0B09E2 3E    0883** NOTK:			LD      A,26
0B09E3 1A 
0B09E4 18    0884** JR      FPPN
0B09E5 36 
             0885** ;
             0886** ;DEG - Convert radians to degrees
             0887** ;Result is floating-point numeric.
             0888** ;
0B09E6 3E    0889** DEG:			LD      A,21
0B09E7 15 
0B09E8 18    0890** JR      FPPN
0B09E9 32 
             0891** ;
             0892** ;RAD - Convert degrees to radians
             0893** ;Result is floating-point numeric.
             0894** ;
0B09EA 3E    0895** RAD:			LD      A,27
0B09EB 1B 
0B09EC 18    0896** JR      FPPN
0B09ED 2E 
             0897** ;
             0898** ;SGN - Return -1, 0 or +1
             0899** ;Result is integer numeric.
             0900** ;
0B09EE 3E    0901** SGN:			LD      A,28
0B09EF 1C 
0B09F0 18    0902** JR      FPPN
0B09F1 2A 
             0903** ;
             0904** ;INT - Floor function
             0905** ;Result is integer numeric.
             0906** ;
0B09F2 3E    0907** INT_:			LD      A,23
0B09F3 17 
0B09F4 18    0908** JR      FPPN
0B09F5 26 
             0909** ;
             0910** ;SQR - square root
             0911** ;Result is floating-point numeric.
             0912** ;
0B09F6 3E    0913** SQR:			LD      A,30
0B09F7 1E 
0B09F8 18    0914** JR      FPPN
0B09F9 22 
             0915** ;
             0916** ;TAN - Tangent function
             0917** ;Result is floating-point numeric.
             0918** ;
0B09FA 3E    0919** TAN:			LD      A,31
0B09FB 1F 
0B09FC 18    0920** JR      FPPN
0B09FD 1E 
             0921** ;
             0922** ;COS - Cosine function
             0923** ;Result is floating-point numeric.
             0924** ;
0B09FE 3E    0925** COS:			LD      A,20
0B09FF 14 
0B0A00 18    0926** JR      FPPN
0B0A01 1A 
             0927** ;
             0928** ;SIN - Sine function
             0929** ;Result is floating-point numeric.
             0930** ;
0B0A02 3E    0931** SIN:			LD      A,29
0B0A03 1D 
0B0A04 18    0932** JR      FPPN
0B0A05 16 
             0933** ;
             0934** ;EXP - Exponential function
             0935** ;Result is floating-point numeric.
             0936** ;
0B0A06 3E    0937** EXP:			LD      A,22
0B0A07 16 
0B0A08 18    0938** JR      FPPN
0B0A09 12 
             0939** ;
             0940** ;LN - Natural log.
             0941** ;Result is floating-point numeric.
             0942** ;
0B0A0A 3E    0943** LN:			LD      A,24
0B0A0B 18 
0B0A0C 18    0944** JR      FPPN
0B0A0D 0E 
             0945** ;
             0946** ;LOG - base-10 logarithm.
             0947** ;Result is floating-point numeric.
             0948** ;
0B0A0E 3E    0949** LOG:			LD      A,25
0B0A0F 19 
0B0A10 18    0950** JR      FPPN
0B0A11 0A 
             0951** ;
             0952** ;ASN - Arc-sine
             0953** ;Result is floating-point numeric.
             0954** ;
0B0A12 3E    0955** ASN:			LD      A,18
0B0A13 12 
0B0A14 18    0956** JR      FPPN
0B0A15 06 
             0957** ;
             0958** ;ATN - arc-tangent
             0959** ;Result is floating-point numeric.
             0960** ;
0B0A16 3E    0961** ATN:			LD      A,19
0B0A17 13 
0B0A18 18    0962** JR      FPPN
0B0A19 02 
             0963** ;
             0964** ;ACS - arc-cosine
             0965** ;Result is floating point numeric.
             0966** ;
0B0A1A 3E    0967** ACS:			LD      A,17
0B0A1B 11 
0B0A1C F5    0968** FPPN:			PUSH    AF
0B0A1D CD    0969** CALL    ITEMN
0B0A1E E7 
0B0A1F 06 
0B0A20 0B 
0B0A21 F1    0970** POP     AF
0B0A22 CD    0971** FPP1:			CALL    FPP
0B0A23 34 
0B0A24 24 
0B0A25 0B 
0B0A26 DA    0972** JP      C,ERROR_
0B0A27 2A 
0B0A28 3B 
0B0A29 0B 
0B0A2A AF    0973** XOR     A
0B0A2B C9    0974** RET
             0975** ;
             0976** ;SFIX - Convert to fixed-point notation
             0977** ;
0B0A2C 3E    0978** SFIX:			LD      A,38
0B0A2D 26 
0B0A2E 18    0979** JR      FPP1
0B0A2F F2 
             0980** ;
             0981** ;SFLOAT - Convert to floating-point notation
             0982** ;
0B0A30 3E    0983** SFLOAT:			LD      A,39
0B0A31 27 
0B0A32 18    0984** JR      FPP1
0B0A33 EE 
             0985** ;
             0986** ;VAL - Return numeric value of string.
             0987** ;Result is variable type numeric.
             0988** ;
0B0A34 CD    0989** VAL:			CALL    ITEMS
0B0A35 FA 
0B0A36 06 
0B0A37 0B 
0B0A38 AF    0990** VAL0:			XOR     A
0B0A39 12    0991** LD      (DE),A
0B0A3A DD    0992** LD      IX,ACCS
0B0A3B 21 
0B0A3C 00 
0B0A3D 4E 
0B0A3D 0B   
0B0A3F 3E    0993** LD      A,36
0B0A40 24 
0B0A41 18    0994** JR      FPP1
0B0A42 DF 
             0995** ;
             0996** ;EVAL - Pass string to expression evaluator.
             0997** ;Result is variable type (numeric or string).
             0998** ;
0B0A43 CD    0999** EVAL_:			CALL    ITEMS
0B0A44 FA 
0B0A45 06 
0B0A46 0B 
0B0A47 3E    1000** LD      A,CR
0B0A48 0D 
0B0A49 12    1001** LD      (DE),A
0B0A4A FD    1002** PUSH    IY
0B0A4B E5 
0B0A4C 11    1003** LD      DE,ACCS
0B0A4D 00 
0B0A4E 4E 
0B0A4F 0B 
0B0A50 FD    1004** LD      IY,ACCS
0B0A51 21 
0B0A52 00 
0B0A53 4E 
0B0A53 0B   
0B0A55 0E    1005** LD      C,0
0B0A56 00 
0B0A57 CD    1006** CALL    LEXAN2          ;TOKENISE
0B0A58 69 
0B0A59 40 
0B0A5A 0B 
0B0A5B 12    1007** LD      (DE),A
0B0A5C 13    1008** INC     DE
0B0A5D AF    1009** XOR     A
0B0A5E CD    1010** CALL    PUSHS           ;PUT ON STACK
0B0A5F 7E 
0B0A60 0D 
0B0A61 0B 
0B0A62 FD    1011** LD      IY,SIZEW	;WAS 2
0B0A63 21 
0B0A64 03 
0B0A65 00 
0B0A65 00   
0B0A67 FD    1012** ADD     IY,SP
0B0A68 39 
0B0A69 CD    1013** CALL    EXPR
0B0A6A 91 
0B0A6B 05 
0B0A6C 0B 
0B0A6D FD    1014** POP     IY
0B0A6E E1 
0B0A6F FD    1015** ADD     IY,SP
0B0A70 39 
0B0A71 FD    1016** LD      SP,IY           ;ADJUST STACK POINTER
0B0A72 F9 
0B0A73 FD    1017** POP     IY
0B0A74 E1 
0B0A75 08    1018** EX      AF,AF'
0B0A76 C9    1019** RET
             1020** ;
             1021** ;RND - Random number function.
             1022** ; RND gives random integer 0-&FFFFFFFF
             1023** ; RND(-n) seeds random number & returns -n.
             1024** ; RND(0) returns last value in RND(1) form.
             1025** ; RND(1) returns floating-point 0-0.99999999.
             1026** ; RND(n) returns random integer 1-n.
             1027** ;
0B0A77 DD    1028** RND:			LD      IX,RANDOM
0B0A78 21 
0B0A79 38 
0B0A7A 51 
0B0A7A 0B   
0B0A7C CD    1029** CALL    NXT
0B0A7D 3A 
0B0A7E 0E 
0B0A7F 0B 
0B0A80 FE    1030** CP      '('
0B0A81 28 
0B0A82 28    1031** JR      Z,RND5          ;ARGUMENT FOLLOWS
0B0A83 20 
0B0A84 CD    1032** CALL    LOAD5
0B0A85 E9 
0B0A86 07 
0B0A87 0B 
0B0A88 CB    1033** RND1:			RR      C
0B0A89 19 
0B0A8A 06    1034** LD      B,32
0B0A8B 20 
0B0A8C D9    1035** RND2:			EXX                     ;CALCULATE NEXT
0B0A8D 52    1036** ADC.S   HL,HL
0B0A8E ED 
0B0A8F 6A 
0B0A90 D9    1037** EXX
0B0A91 52    1038** ADC.S   HL,HL
0B0A92 ED 
0B0A93 6A 
0B0A94 CB    1039** BIT     3,L
0B0A95 5D 
0B0A96 28    1040** JR      Z,RND3
0B0A97 01 
0B0A98 3F    1041** CCF
0B0A99 10    1042** RND3:			DJNZ    RND2
0B0A9A F1 
0B0A9B CB    1043** RND4:			RL      C               ;SAVE CARRY
0B0A9C 11 
0B0A9D CD    1044** CALL    STORE5          ;STORE NEW NUMBER
0B0A9E A5 
0B0A9F 19 
0B0AA0 0B 
0B0AA1 AF    1045** XOR     A
0B0AA2 4F    1046** LD      C,A
0B0AA3 C9    1047** RET
0B0AA4 CD    1048** RND5:			CALL    ITEMI
0B0AA5 EF 
0B0AA6 06 
0B0AA7 0B 
0B0AA8 DD    1049** LD      IX,RANDOM
0B0AA9 21 
0B0AAA 38 
0B0AAB 51 
0B0AAB 0B   
0B0AAD CB    1050** BIT     7,H             ;NEGATIVE?
0B0AAE 7C 
0B0AAF 37    1051** SCF
0B0AB0 20    1052** JR      NZ,RND4         ;SEED
0B0AB1 E9 
0B0AB2 CD    1053** CALL    TEST
0B0AB3 A9 
0B0AB4 0C 
0B0AB5 0B 
0B0AB6 F5    1054** PUSH    AF
0B0AB7 CD    1055** CALL    SWAP
0B0AB8 A1 
0B0AB9 0C 
0B0ABA 0B 
0B0ABB D9    1056** EXX
0B0ABC CD    1057** CALL    LOAD5
0B0ABD E9 
0B0ABE 07 
0B0ABF 0B 
0B0AC0 C4    1058** CALL    NZ,RND1         ;NEXT IF NON-ZERO
0B0AC1 88 
0B0AC2 0A 
0B0AC3 0B 
0B0AC4 D9    1059** EXX                     ;SCRAMBLE (CARE!)
0B0AC5 0E    1060** LD      C,7FH
0B0AC6 7F 
0B0AC7 CB    1061** RND6:			BIT     7,H             ;FLOAT
0B0AC8 7C 
0B0AC9 20    1062** JR      NZ,RND7
0B0ACA 0A 
0B0ACB D9    1063** EXX
0B0ACC 52    1064** ADD.S   HL,HL
0B0ACD 29 
0B0ACE D9    1065** EXX
0B0ACF 52    1066** ADC.S   HL,HL
0B0AD0 ED 
0B0AD1 6A 
0B0AD2 0D    1067** DEC     C
0B0AD3 20    1068** JR      NZ,RND6
0B0AD4 F2 
0B0AD5 CB    1069** RND7:			RES     7,H             ;POSITIVE 0-0.999999
0B0AD6 BC 
0B0AD7 F1    1070** POP     AF
0B0AD8 C8    1071** RET     Z               ;ZERO ARGUMENT
0B0AD9 D9    1072** EXX
0B0ADA 7B    1073** LD      A,E
0B0ADB 3D    1074** DEC     A
0B0ADC B2    1075** OR      D
0B0ADD D9    1076** EXX
0B0ADE B3    1077** OR      E
0B0ADF B2    1078** OR      D
0B0AE0 C8    1079** RET     Z               ;ARGUMENT=1
0B0AE1 06    1080** LD      B,0             ;INTEGER MARKER
0B0AE2 00 
0B0AE3 3E    1081** LD      A,10
0B0AE4 0A 
0B0AE5 CD    1082** CALL    FPP             ;MULTIPLY
0B0AE6 34 
0B0AE7 24 
0B0AE8 0B 
0B0AE9 DA    1083** JP      C,ERROR_
0B0AEA 2A 
0B0AEB 3B 
0B0AEC 0B 
0B0AED CD    1084** CALL    SFIX
0B0AEE 2C 
0B0AEF 0A 
0B0AF0 0B 
0B0AF1 C3    1085** JP      ADD1
0B0AF2 85 
0B0AF3 07 
0B0AF4 0B 
             1086** ;
             1087** ; INSTR - String search.
             1088** ; Result is integer numeric.
             1089** ;
0B0AF5 CD    1090** INSTR:			CALL    EXPRSC			; Get the first string expression
0B0AF6 E8 
0B0AF7 0D 
0B0AF8 0B 
0B0AF9 CD    1091** CALL    PUSHS           	; Push the string onto the stack
0B0AFA 7E 
0B0AFB 0D 
0B0AFC 0B 
0B0AFD CD    1092** CALL    EXPRS           	; Get the second string expression
0B0AFE DF 
0B0AFF 06 
0B0B00 0B 
0B0B01 C1    1093** POP     BC			;  C: String length, B: Value of A before PUSHS was called
0B0B02 21    1094** LD      HL,0
0B0B03 00 
0B0B04 00 
0B0B05 00 
0B0B06 39    1095** ADD     HL,SP           	; HL: Pointer to main string
0B0B07 C5    1096** PUSH    BC              	;  C: Main string length
0B0B08 43    1097** LD      B,E             	;  B: Sub-string length
0B0B09 CD    1098** CALL    NXT			; Skip whitespace
0B0B0A 3A 
0B0B0B 0E 
0B0B0C 0B 
0B0B0D FE    1099** CP      ','			; Check if there is a comma for the third parameter
0B0B0E 2C 
0B0B0F 3E    1100** LD      A,0			;  A: Default start position in string
0B0B10 00 
0B0B11 20    1101** JR      NZ,INSTR1		; No, so skip the next bit
0B0B12 1A 
0B0B13 FD    1102** INC     IY              	; Skip the comma
0B0B14 23 
0B0B15 C5    1103** PUSH    BC              	; Save the lengths
0B0B16 E5    1104** PUSH    HL              	; Save the pointer to the main string
0B0B17 CD    1105** CALL    PUSHS			; Push the string onto the stack
0B0B18 7E 
0B0B19 0D 
0B0B1A 0B 
0B0B1B CD    1106** CALL    EXPRI			; Get the third (numeric) parameter - the starting position
0B0B1C D4 
0B0B1D 06 
0B0B1E 0B 
0B0B1F C1    1107** POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
0B0B20 CD    1108** CALL    POPS			; Pop the string off the stack
0B0B21 A8 
0B0B22 0D 
0B0B23 0B 
0B0B24 E1    1109** POP     HL              	; Restore the pointer to the main string
0B0B25 C1    1110** POP     BC              	; Restore the lengths
0B0B26 D9    1111** EXX
0B0B27 7D    1112** LD      A,L			; A: The start position in the  string
0B0B28 D9    1113** EXX
0B0B29 B7    1114** OR      A			; Set the flags
0B0B2A 28    1115** JR      Z,INSTR1		; If it is zero, then skip
0B0B2B 01 
0B0B2C 3D    1116** DEC     A
0B0B2D 11    1117** INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
0B0B2E 00 
0B0B2F 4E 
0B0B30 0B 
0B0B31 CD    1118** CALL    SEARCH			; Do the search
0B0B32 4F 
0B0B33 0B 
0B0B34 0B 
0B0B35 D1    1119** POP     DE
0B0B36 28    1120** JR      Z,INSTR2        	; NB: Carry cleared
0B0B37 03 
0B0B38 ED    1121** SBC     HL,HL
0B0B39 62 
0B0B3A 39    1122** ADD     HL,SP
0B0B3B ED    1123** INSTR2:			SBC     HL,SP
0B0B3C 72 
0B0B3D EB    1124** EX      DE,HL
0B0B3E 7D    1125** LD	A,L
0B0B3F 21    1126** LD      HL,0
0B0B40 00 
0B0B41 00 
0B0B42 00 
0B0B43 6F    1127** LD	L,A
0B0B44 39    1128** ADD     HL,SP
0B0B45 F9    1129** LD      SP,HL
0B0B46 EB    1130** EX      DE,HL
0B0B47 CD    1131** CALL    BRAKET			; Check for closing bracket
0B0B48 F9 
0B0B49 0D 
0B0B4A 0B 
0B0B4B C3    1132** JP      COUNT1			; Return a numeric integer
0B0B4C 4B 
0B0B4D 09 
0B0B4E 0B 
             1133** ;
             1134** ; SEARCH - Search string for sub-string
             1135** ;    Inputs: Main string at HL length C
             1136** ;            Sub-string  at DE length B
             1137** ;            Starting offset A
             1138** ;   Outputs: NZ - not found
             1139** ;            Z - found at location HL-1
             1140** ;            Carry always cleared
             1141** ;
0B0B4F C5    1142** SEARCH:			PUSH    BC			; Add the starting offset to HL
0B0B50 01    1143** LD      BC,0
0B0B51 00 
0B0B52 00 
0B0B53 00 
0B0B54 4F    1144** LD      C,A
0B0B55 09    1145** ADD     HL,BC           	; New start address
0B0B56 C1    1146** POP     BC
0B0B57 91    1147** SUB     C			; If the starting offset > main string length, then do nothing
0B0B58 30    1148** JR      NC,SRCH4
0B0B59 2C 
0B0B5A ED    1149** NEG
0B0B5B 44 
0B0B5C 4F    1150** LD      C,A             	; Remaining length
             1151** ;
0B0B5D C5    1152** SRCH1:			PUSH    BC
0B0B5E 79    1153** LD	A,C
0B0B5F 01    1154** LD	BC,0
0B0B60 00 
0B0B61 00 
0B0B62 00 
0B0B63 4F    1155** LD	C,A
0B0B64 1A    1156** LD      A,(DE)
0B0B65 ED    1157** CPIR                    	; Find the first character
0B0B66 B1 
0B0B67 79    1158** LD      A,C
0B0B68 C1    1159** POP     BC
0B0B69 20    1160** JR      NZ,SRCH4
0B0B6A 1B 
0B0B6B 4F    1161** LD      C,A
             1162** ;
             1163** ; This block of four instructions was commented as a bug fix by R.T.Russell
             1164** ;
0B0B6C 05    1165** DEC     B			; Bug fix
0B0B6D B8    1166** CP      B			; Bug fix
0B0B6E 04    1167** INC     B			; Bug fix
0B0B6F 38    1168** JR      C,SRCH4			; Bug fix
0B0B70 15 
             1169** ;
0B0B71 C5    1170** PUSH    BC
0B0B72 D5    1171** PUSH    DE
0B0B73 E5    1172** PUSH    HL
0B0B74 05    1173** DEC     B
0B0B75 28    1174** JR      Z,SRCH3         	; Found!
0B0B76 08 
0B0B77 13    1175** SRCH2:			INC     DE
0B0B78 1A    1176** LD      A,(DE)
0B0B79 BE    1177** CP      (HL)
0B0B7A 20    1178** JR      NZ,SRCH3
0B0B7B 03 
0B0B7C 23    1179** INC     HL
0B0B7D 10    1180** DJNZ    SRCH2
0B0B7E F8 
0B0B7F E1    1181** SRCH3:			POP     HL
0B0B80 D1    1182** POP     DE
0B0B81 C1    1183** POP     BC
0B0B82 20    1184** JR      NZ,SRCH1
0B0B83 D9 
0B0B84 AF    1185** XOR     A               	; Flags: Z, NC
0B0B85 C9    1186** RET                     	; Found
             1187** ;
0B0B86 F6    1188** SRCH4:			OR      0FFH            	; Flags: NZ, NC
0B0B87 FF 
0B0B88 C9    1189** RET                     	; Not found
             1190** ;
             1191** ;CHRS - Return character with given ASCII value.
             1192** ;Result is string.
             1193** ;
0B0B89 CD    1194** CHRS:			CALL    ITEMI
0B0B8A EF 
0B0B8B 06 
0B0B8C 0B 
0B0B8D D9    1195** EXX
0B0B8E 7D    1196** LD      A,L
0B0B8F 18    1197** JR      GET1
0B0B90 0E 
             1198** ;
             1199** ;GETS - Return key pressed as stringor character at position (X,Y).
             1200** ;Result is string.
             1201** ;
0B0B91 CD    1202** GETS:			CALL	NXT		;NEW CODE FOR GET$(X,Y)
0B0B92 3A 
0B0B93 0E 
0B0B94 0B 
0B0B95 FE    1203** CP	'('
0B0B96 28 
0B0B97 CA    1204** JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0B0B98 C6 
0B0B99 47 
0B0B9A 0B 
0B0B9B CD    1205** CALL    OSRDCH
0B0B9C F3 
0B0B9D 42 
0B0B9E 0B 
0B0B9F 37    1206** GET1:			SCF
0B0BA0 18    1207** JR      INKEY1
0B0BA1 09 
             1208** ;
             1209** ; INKEYS - Wait up to n centiseconds for keypress.
             1210** ;          Return key pressed as string or null
             1211** ;          string if time elapsed.
             1212** ; Result is string.
             1213** ;
0B0BA2 CD    1214** INKEYS:			CALL    ITEMI			; Fetch the argument
0B0BA3 EF 
0B0BA4 06 
0B0BA5 0B 
0B0BA6 D9    1215** EXX
0B0BA7 CD    1216** INKEY0:			CALL    OSKEY			; This is the entry point for INKEY(n)
0B0BA8 FC 
0B0BA9 42 
0B0BAA 0B 
0B0BAB 11    1217** INKEY1:			LD      DE,ACCS			; Store the result in the string accumulator
0B0BAC 00 
0B0BAD 4E 
0B0BAE 0B 
0B0BAF 12    1218** LD      (DE),A
0B0BB0 3E    1219** LD      A,80H
0B0BB1 80 
0B0BB2 D0    1220** RET     NC
0B0BB3 1C    1221** INC     E
0B0BB4 C9    1222** RET
             1223** ;
             1224** ; INKEYM - Check immediately whether a given key is being pressed
             1225** ; Result is integer numeric
             1226** ;
             1227** INKEYM:			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0B0BB5 3E   0001**M LD	A, function
0B0BB6 1E 
0B0BB7 49   0002**M RST.LIS	08h
0B0BB8 CF 
0B0BB9 23    1228** INC	HL			; Index from 0
0B0BBA 7D    1229** LD	A, L			; Negate the LSB of the answer
0B0BBB ED    1230** NEG
0B0BBC 44 
0B0BBD 4F    1231** LD	C, A			;  E: The positive keycode value
0B0BBE 3E    1232** LD	A, 1			; Throw an "Out of range" error
0B0BBF 01 
0B0BC0 FA    1233** JP	M, ERROR_		; if the argument < - 128
0B0BC1 2A 
0B0BC2 3B 
0B0BC3 0B 
             1234** ;
0B0BC4 21    1235** LD	HL, BITLOOKUP		; HL: The bit lookup table
0B0BC5 E7 
0B0BC6 0B 
0B0BC7 0B 
0B0BC8 11    1236** LD	DE, 0
0B0BC9 00 
0B0BCA 00 
0B0BCB 00 
0B0BCC 79    1237** LD	A, C
0B0BCD E6    1238** AND	00000111b		; Just need the first three bits
0B0BCE 07 
0B0BCF 5F    1239** LD	E, A			; DE: The bit number
0B0BD0 19    1240** ADD	HL, DE
0B0BD1 46    1241** LD	B, (HL)			;  B: The mask
             1242** ;
0B0BD2 79    1243** LD	A, C			; Fetch the keycode again
0B0BD3 E6    1244** AND	01111000b		; And divide by 8
0B0BD4 78 
0B0BD5 0F    1245** RRCA
0B0BD6 0F    1246** RRCA
0B0BD7 0F    1247** RRCA
0B0BD8 5F    1248** LD	E, A			; DE: The offset (the MSW has already been cleared previously)
0B0BD9 DD    1249** ADD	IX, DE			; IX: The address
0B0BDA 19 
0B0BDB 78    1250** LD	A, B			;  B: The mask
0B0BDC DD    1251** AND	(IX+0)			; Check whether the bit is set
0B0BDD A6 
0B0BDE 00 
0B0BDF CA    1252** JP	Z, ZERO			; No, so return 0
0B0BE0 5D 
0B0BE1 0D 
0B0BE2 0B 
0B0BE3 C3    1253** JP	TRUE			; Otherwise return -1
0B0BE4 CF 
0B0BE5 09 
0B0BE6 0B 
             1254** ;
             1255** ; A bit lookup table
             1256** ;
0B0BE7 01    1257** BITLOOKUP:		DB	01h, 02h, 04h, 08h
0B0BE8 02 
0B0BE9 04 
0B0BEA 08 
0B0BEB 10    1258** DB	10h, 20h, 40h, 80h
0B0BEC 20 
0B0BED 40 
0B0BEE 80 
             1259** ;
             1260** ; MID$ - Return sub-string.
             1261** ; Result is string.
             1262** ;
0B0BEF CD    1263** MIDS:			CALL    EXPRSC			; Get the first string expression
0B0BF0 E8 
0B0BF1 0D 
0B0BF2 0B 
0B0BF3 CD    1264** CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B0BF4 7E 
0B0BF5 0D 
0B0BF6 0B 
0B0BF7 CD    1265** CALL    EXPRI			; Get the second expression
0B0BF8 D4 
0B0BF9 06 
0B0BFA 0B 
0B0BFB C1    1266** POP     BC			; C: String length, B: Value of A before PUSHS was called
0B0BFC CD    1267** CALL    POPS			; Pop the string back off the stack to the string accumulator
0B0BFD A8 
0B0BFE 0D 
0B0BFF 0B 
0B0C00 D9    1268** EXX
0B0C01 7D    1269** LD      A,L			; A: The start index
0B0C02 D9    1270** EXX
0B0C03 B7    1271** OR      A			; If the start index is 0, then we don't need to do the next bit
0B0C04 28    1272** JR      Z,MIDS1
0B0C05 0E 
0B0C06 3D    1273** DEC     A
0B0C07 6F    1274** LD      L,A			; L: The start index - 1
0B0C08 93    1275** SUB     E			; Subtract from the string length
0B0C09 1E    1276** LD      E,0			; Preemptively set the string length to 0
0B0C0A 00 
0B0C0B 30    1277** JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
0B0C0C 07 
0B0C0D ED    1278** NEG				; Negate the answer and
0B0C0E 44 
0B0C0F 4F    1279** LD      C,A			; C: Number of bytes to copy
0B0C10 CD    1280** CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
0B0C11 53 
0B0C12 0C 
0B0C13 0B 
0B0C14 CD    1281** MIDS1:			CALL    NXT			; Skip whitespace
0B0C15 3A 
0B0C16 0E 
0B0C17 0B 
0B0C18 FE    1282** CP      ','			; Check for a comma
0B0C19 2C 
0B0C1A FD    1283** INC     IY			; Advance to the next character in the BASIC line
0B0C1B 23 
0B0C1C 28    1284** JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
0B0C1D 0D 
0B0C1E FD    1285** DEC     IY			; Restore the BASIC program pointer
0B0C1F 2B 
0B0C20 CD    1286** CALL    BRAKET			; Check for a bracket
0B0C21 F9 
0B0C22 0D 
0B0C23 0B 
0B0C24 3E    1287** LD      A,80H			; String marker
0B0C25 80 
0B0C26 C9    1288** RET
             1289** ;
             1290** ; LEFT$ - Return left part of string.
             1291** ; Carry cleared if entire string returned.
             1292** ; Result is string.
             1293** ;
0B0C27 CD    1294** LEFTS:			CALL    EXPRSC			; Get the first string expression
0B0C28 E8 
0B0C29 0D 
0B0C2A 0B 
0B0C2B CD    1295** LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B0C2C 7E 
0B0C2D 0D 
0B0C2E 0B 
0B0C2F CD    1296** CALL    EXPRI			; Get the second expression
0B0C30 D4 
0B0C31 06 
0B0C32 0B 
0B0C33 C1    1297** POP     BC			; C: String length, B: Value of A before PUSHS was called
0B0C34 CD    1298** CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
0B0C35 A8 
0B0C36 0D 
0B0C37 0B 
0B0C38 CD    1299** CALL    BRAKET			; Check for closing bracket
0B0C39 F9 
0B0C3A 0D 
0B0C3B 0B 
0B0C3C D9    1300** EXX
0B0C3D 7D    1301** LD      A,L			; L: The second parameter
0B0C3E D9    1302** EXX
0B0C3F BB    1303** CP      E			; Compare with the string length
0B0C40 30    1304** JR      NC,LEFT3		; If it is greater than or equal then do nothing
0B0C41 02 
0B0C42 6B    1305** LD      L,E             	; For RIGHTS, no effect in LEFTS
0B0C43 5F    1306** LEFT2:			LD      E,A			; E: The new length of string
0B0C44 3E    1307** LEFT3:			LD      A,80H           	; String marker
0B0C45 80 
0B0C46 C9    1308** RET
             1309** ;
             1310** ; RIGHT$ - Return right part of string.
             1311** ; Result is string.
             1312** ;
0B0C47 CD    1313** RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
0B0C48 27 
0B0C49 0C 
0B0C4A 0B 
0B0C4B D0    1314** RET     NC			; Do nothing if the second parameter is >= string length
0B0C4C 1C    1315** INC     E			; Check for a zero length string
0B0C4D 1D    1316** DEC     E
0B0C4E C8    1317** RET     Z			; Yes, so do nothing
0B0C4F 4B    1318** LD      C,E			;  C: Number of bytes to copy
0B0C50 7D    1319** LD      A,L
0B0C51 93    1320** SUB     E
0B0C52 6F    1321** LD      L,A			;  L: Index into the string
0B0C53 79    1322** RIGHT1:			LD	A,C
0B0C54 01    1323** LD	BC,0
0B0C55 00 
0B0C56 00 
0B0C57 00 
0B0C58 4F    1324** LD	C,A			; BC: Number of bytes to copy (with top word cleared)
0B0C59 7D    1325** LD	A,L
0B0C5A 21    1326** LD	HL,ACCS
0B0C5B 00 
0B0C5C 4E 
0B0C5D 0B 
0B0C5E 6F    1327** LD	L,A			; HL: Source (in ACCS)
0B0C5F 11    1328** LD      DE,ACCS			; DE: Destination (start of ACCS)
0B0C60 00 
0B0C61 4E 
0B0C62 0B 
0B0C63 ED    1329** LDIR                    	; Copy
0B0C64 B0 
0B0C65 3E    1330** LD      A,80H			; String marker
0B0C66 80 
0B0C67 C9    1331** RET
             1332** ;
             1333** ; STRINGS - Return n concatenations of a string.
             1334** ; Result is string.
             1335** ;
0B0C68 CD    1336** STRING_:		CALL    EXPRI			; Get number of times to replicate
0B0C69 D4 
0B0C6A 06 
0B0C6B 0B 
0B0C6C CD    1337** CALL    COMMA			; Check for comma
0B0C6D EC 
0B0C6E 0D 
0B0C6F 0B 
0B0C70 D9    1338** EXX
0B0C71 7D    1339** LD      A,L			; L: Number of iterations of string
0B0C72 D9    1340** EXX
0B0C73 F5    1341** PUSH    AF
0B0C74 CD    1342** CALL    EXPRS			; Get the string
0B0C75 DF 
0B0C76 06 
0B0C77 0B 
0B0C78 CD    1343** CALL    BRAKET			; Check for closing bracket
0B0C79 F9 
0B0C7A 0D 
0B0C7B 0B 
0B0C7C F1    1344** POP     AF			; A: Number of iterations of string
0B0C7D B7    1345** OR      A			; Set flags
0B0C7E 28    1346** JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0B0C7F C3 
0B0C80 3D    1347** DEC     A
0B0C81 4F    1348** LD      C,A			; C: Loop counter
0B0C82 3E    1349** LD      A,80H			; String marker
0B0C83 80 
0B0C84 C8    1350** RET     Z
0B0C85 1C    1351** INC     E			; Check for empty string
0B0C86 1D    1352** DEC     E
0B0C87 C8    1353** RET     Z              		; And return
0B0C88 43    1354** LD      B,E			; B: String length tally
0B0C89 21    1355** LD	HL,ACCS
0B0C8A 00 
0B0C8B 4E 
0B0C8C 0B 
0B0C8D C5    1356** STRIN1:			PUSH    BC
0B0C8E 7E    1357** STRIN2:			LD      A,(HL)
0B0C8F 23    1358** INC     HL
0B0C90 12    1359** LD      (DE),A
0B0C91 1C    1360** INC     E
0B0C92 3E    1361** LD      A,19
0B0C93 13 
0B0C94 CA    1362** JP      Z,ERROR_         	; Throw a "String too long" error
0B0C95 2A 
0B0C96 3B 
0B0C97 0B 
0B0C98 10    1363** DJNZ    STRIN2
0B0C99 F4 
0B0C9A C1    1364** POP     BC
0B0C9B 0D    1365** DEC     C
0B0C9C 20    1366** JR      NZ,STRIN1
0B0C9D EF 
0B0C9E 3E    1367** LD      A,80H
0B0C9F 80 
0B0CA0 C9    1368** RET
             1369** ;
             1370** ;SUBROUTINES
             1371** ;
             1372** ;SWAP - Swap arguments
             1373** ;Exchanges DE,HL D'E',H'L' and B,C
             1374** ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
             1375** ;
0B0CA1 79    1376** SWAP:			LD      A,C
0B0CA2 48    1377** LD      C,B
0B0CA3 47    1378** LD      B,A
0B0CA4 EB    1379** EX      DE,HL
0B0CA5 D9    1380** EXX
0B0CA6 EB    1381** EX      DE,HL
0B0CA7 D9    1382** EXX
0B0CA8 C9    1383** RET
             1384** ;
             1385** ;TEST - Test HLH'L' for zero
             1386** ;Outputs: Z-flag set & A=0 if zero
             1387** ;Destroys: A,F
             1388** ;
0B0CA9 7C    1389** TEST:			LD      A,H
0B0CAA B5    1390** OR      L
0B0CAB D9    1391** EXX
0B0CAC B4    1392** OR      H
0B0CAD B5    1393** OR      L
0B0CAE D9    1394** EXX
0B0CAF C9    1395** RET
             1396** ;
             1397** ;DECODE - Decode line number in pseudo-binary.
             1398** ;   Inputs: IY = Text pointer.
             1399** ;   Outputs: HL=0, H'L'=line number, C=0.
             1400** ;   Destroys: A,C,H,L,H',L',IY,F
             1401** ;
0B0CB0 D9    1402** DECODE:			EXX
0B0CB1 21    1403** LD	HL, 0
0B0CB2 00 
0B0CB3 00 
0B0CB4 00 
0B0CB5 FD    1404** LD      A,(IY)
0B0CB6 7E 
0B0CB7 00 
0B0CB8 FD    1405** INC     IY
0B0CB9 23 
0B0CBA 17    1406** RLA
0B0CBB 17    1407** RLA
0B0CBC 67    1408** LD      H,A
0B0CBD E6    1409** AND     0C0H
0B0CBE C0 
0B0CBF FD    1410** XOR     (IY)
0B0CC0 AE 
0B0CC1 00 
0B0CC2 FD    1411** INC     IY
0B0CC3 23 
0B0CC4 6F    1412** LD      L,A
0B0CC5 7C    1413** LD      A,H
0B0CC6 17    1414** RLA
0B0CC7 17    1415** RLA
0B0CC8 E6    1416** AND     0C0H
0B0CC9 C0 
0B0CCA FD    1417** XOR     (IY)
0B0CCB AE 
0B0CCC 00 
0B0CCD FD    1418** INC     IY
0B0CCE 23 
0B0CCF 67    1419** LD      H,A
0B0CD0 D9    1420** EXX
             1421** ;			XOR     A
             1422** ;			LD      C,A
             1423** ;			LD      H,A
             1424** ;			LD      L,A
0B0CD1 21    1425** LD	HL, 0
0B0CD2 00 
0B0CD3 00 
0B0CD4 00 
0B0CD5 4D    1426** LD	C, L
0B0CD6 C9    1427** RET
             1428** ;
             1429** ;HEXSTR - convert numeric value to HEX string.
             1430** ;   Inputs: HLH'L'C = integer or floating-point number
             1431** ;  Outputs: String in string accumulator.
             1432** ;           E = string length.  D = ACCS/256
             1433** ;
0B0CD7 FD    1434** HEXSTS:			INC     IY              ;SKIP TILDE
0B0CD8 23 
0B0CD9 CD    1435** CALL    ITEMN
0B0CDA E7 
0B0CDB 06 
0B0CDC 0B 
0B0CDD CD    1436** CALL    HEXSTR
0B0CDE E4 
0B0CDF 0C 
0B0CE0 0B 
0B0CE1 3E    1437** LD      A,80H
0B0CE2 80 
0B0CE3 C9    1438** RET
             1439** ;
0B0CE4 CD    1440** HEXSTR:			CALL    SFIX
0B0CE5 2C 
0B0CE6 0A 
0B0CE7 0B 
0B0CE8 01    1441** LD      BC,8
0B0CE9 08 
0B0CEA 00 
0B0CEB 00 
0B0CEC 11    1442** LD      DE,ACCS
0B0CED 00 
0B0CEE 4E 
0B0CEF 0B 
0B0CF0 C5    1443** HEXST1:			PUSH    BC
0B0CF1 06    1444** LD      B,4
0B0CF2 04 
0B0CF3 AF    1445** XOR     A
0B0CF4 D9    1446** HEXST2:			EXX
0B0CF5 52    1447** ADD.S	HL,HL
0B0CF6 29 
0B0CF7 D9    1448** EXX
0B0CF8 52    1449** ADC.S	HL,HL
0B0CF9 ED 
0B0CFA 6A 
0B0CFB 17    1450** RLA
0B0CFC 10    1451** DJNZ    HEXST2
0B0CFD F6 
0B0CFE C1    1452** POP     BC
0B0CFF 0D    1453** DEC     C
0B0D00 F8    1454** RET     M
0B0D01 28    1455** JR      Z,HEXST3
0B0D02 06 
0B0D03 B7    1456** OR      A
0B0D04 20    1457** JR      NZ,HEXST3
0B0D05 03 
0B0D06 B8    1458** CP      B
0B0D07 28    1459** JR      Z,HEXST1
0B0D08 E7 
0B0D09 C6    1460** HEXST3:			ADD     A,90H
0B0D0A 90 
0B0D0B 27    1461** DAA
0B0D0C CE    1462** ADC     A,40H
0B0D0D 40 
0B0D0E 27    1463** DAA
0B0D0F 12    1464** LD      (DE),A
0B0D10 13    1465** INC     DE
0B0D11 47    1466** LD      B,A
0B0D12 18    1467** JR      HEXST1
0B0D13 DC 
             1468** ;
             1469** ;Function STR - convert numeric value to ASCII string.
             1470** ;   Inputs: HLH'L'C = integer or floating-point number.
             1471** ;  Outputs: String in string accumulator.
             1472** ;           E = length, D = ACCS/256
             1473** ;           A = 80H (type=string)
             1474** ;
             1475** ;First normalise for decimal output:
             1476** ;
0B0D14 CD    1477** STRS:			CALL    NXT
0B0D15 3A 
0B0D16 0E 
0B0D17 0B 
0B0D18 FE    1478** CP      '~'
0B0D19 7E 
0B0D1A 28    1479** JR      Z,HEXSTS
0B0D1B BB 
0B0D1C CD    1480** CALL    ITEMN
0B0D1D E7 
0B0D1E 06 
0B0D1F 0B 
0B0D20 DD    1481** LD      IX,STAVAR
0B0D21 21 
0B0D22 00 
0B0D23 50 
0B0D23 0B   
0B0D25 DD    1482** LD      A,(IX+3)
0B0D26 7E 
0B0D27 03 
0B0D28 B7    1483** OR      A
0B0D29 DD    1484** LD      IX,G9-1         ;G9 FORMAT
0B0D2A 21 
0B0D2B 56 
0B0D2C 0D 
0B0D2C 0B   
0B0D2E 28    1485** JR      Z,STR0
0B0D2F 05 
0B0D30 DD    1486** STR:			LD      IX,STAVAR
0B0D31 21 
0B0D32 00 
0B0D33 50 
0B0D33 0B   
0B0D35 11    1487** STR0:			LD      DE,ACCS
0B0D36 00 
0B0D37 4E 
0B0D38 0B 
0B0D39 3E    1488** LD      A,37
0B0D3A 25 
0B0D3B CD    1489** CALL    FPP
0B0D3C 34 
0B0D3D 24 
0B0D3E 0B 
0B0D3F DA    1490** JP      C,ERROR_
0B0D40 2A 
0B0D41 3B 
0B0D42 0B 
0B0D43 DD    1491** BIT     0,(IX+2)
0B0D44 CB 
0B0D45 02 
0B0D46 46 
0B0D47 3E    1492** STR1:			LD      A,80H           ;STRING MARKER
0B0D48 80 
0B0D49 C8    1493** RET     Z
0B0D4A 79    1494** LD      A,C
0B0D4B C6    1495** ADD     A,4
0B0D4C 04 
0B0D4D BB    1496** STR2:			CP      E
0B0D4E 28    1497** JR      Z,STR1
0B0D4F F7 
0B0D50 EB    1498** EX      DE,HL
0B0D51 36    1499** LD      (HL),' '        ;TRAILING SPACE
0B0D52 20 
0B0D53 23    1500** INC     HL
0B0D54 EB    1501** EX      DE,HL
0B0D55 18    1502** JR      STR2
0B0D56 F6 
             1503** ;
0B0D57 09    1504** G9:			DW    9
0B0D58 00 
             1505** ;
             1506** ;STRING COMPARE
             1507** ;Compare string (DE) length B with string (HL) length C.
             1508** ;Result preset to false.
             1509** ;
0B0D59 CD    1510** SCP:			CALL	SCP0
0B0D5A 67 
0B0D5B 0D 
0B0D5C 0B 
             1511** ;
0B0D5D 3E    1512** ZERO:			LD      A,0
0B0D5E 00 
0B0D5F D9    1513** EXX
0B0D60 67    1514** LD      H,A
0B0D61 6F    1515** LD      L,A
0B0D62 D9    1516** EXX
0B0D63 67    1517** LD      H,A
0B0D64 6F    1518** LD      L,A
0B0D65 4F    1519** LD      C,A
0B0D66 C9    1520** RET
             1521** ;
0B0D67 04    1522** SCP0:			INC     B
0B0D68 0C    1523** INC     C
0B0D69 05    1524** SCP1:			DEC     B
0B0D6A 28    1525** JR      Z,SCP2
0B0D6B 0A 
0B0D6C 0D    1526** DEC     C
0B0D6D 28    1527** JR      Z,SCP3
0B0D6E 0C 
0B0D6F 1A    1528** LD      A,(DE)
0B0D70 BE    1529** CP      (HL)
0B0D71 C0    1530** RET     NZ
0B0D72 13    1531** INC     DE
0B0D73 23    1532** INC     HL
0B0D74 18    1533** JR      SCP1
0B0D75 F3 
0B0D76 B7    1534** SCP2:			OR      A
0B0D77 0D    1535** DEC     C
0B0D78 C8    1536** RET     Z
0B0D79 37    1537** SCF
0B0D7A C9    1538** RET
0B0D7B B7    1539** SCP3:			OR      A
0B0D7C 0C    1540** INC     C
0B0D7D C9    1541** RET
             1542** ;
             1543** ; PUSHS - SAVE STRING ON STACK.
             1544** ;     Inputs: String in string accumulator.
             1545** ;             E = string length.
             1546** ;             A - saved on stack.
             1547** ;   Destroys: B,C,D,E,H,L,IX,SP,F
             1548** ;
0B0D7E CD    1549** PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0B0D7F 19 
0B0D80 1A 
0B0D81 0B 
0B0D82 DD    1550** POP     IX              	; IX: Return address
0B0D83 E1 
0B0D84 B7    1551** OR      A               	; Clear the carry flag
0B0D85 01    1552** LD	BC,0			; BC: Length of the string
0B0D86 00 
0B0D87 00 
0B0D88 00 
0B0D89 4B    1553** LD	C,E
0B0D8A 21    1554** LD      HL,ACCS			; HL: Pointer to the string accumulator
0B0D8B 00 
0B0D8C 4E 
0B0D8D 0B 
0B0D8E 11    1555** LD	DE,ACCS
0B0D8F 00 
0B0D90 4E 
0B0D91 0B 
0B0D92 59    1556** LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0B0D93 ED    1557** SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0B0D94 52 
0B0D95 39    1558** ADD     HL,SP			; Grow the stack
0B0D96 F9    1559** LD      SP,HL
0B0D97 57    1560** LD      D,A			;  D: This needs to be set to A for some functions
             1561** ; BEGIN MISSING FROM BINARY
             1562** ; LD	B,A			; Stack A and C (the string length)
             1563** ; PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
             1564** ; LD	B,0			; Reset B to 0 for the LDIR in this function
             1565** ; END MISSING FROM BINARY
0B0D98 D5    1566** PUSH 	DE ; ADDED FROM BINARY
0B0D99 28    1567** JR      Z,PUSHS1        	; Is it zero length?
0B0D9A 0B 
0B0D9B 11    1568** LD      DE,ACCS			; DE: Destination
0B0D9C 00 
0B0D9D 4E 
0B0D9E 0B 
0B0D9F EB    1569** EX      DE,HL			; HL: Destination, DE: Address on stack
0B0DA0 ED    1570** LDIR	                    	; Copy to stack
0B0DA1 B0 
0B0DA2 CD    1571** CALL    CHECK			; Final check to see if there is sufficient space on the stack
0B0DA3 19 
0B0DA4 1A 
0B0DA5 0B 
0B0DA6 DD    1572** PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B0DA7 E9 
             1573** ;
             1574** ; POPS - RESTORE STRING FROM STACK.
             1575** ;     Inputs: C = string length.
             1576** ;    Outputs: String in string accumulator.
             1577** ;             E = string length.
             1578** ;   Destroys: B,C,D,E,H,L,IX,SP,F
             1579** ;
0B0DA8 DD    1580** POPS:			POP     IX              	; IX: Return address
0B0DA9 E1 
0B0DAA 69    1581** LD	L,C			; Temporarily store string length in L
0B0DAB 01    1582** LD	BC,0
0B0DAC 00 
0B0DAD 00 
0B0DAE 00 
0B0DAF 4D    1583** LD	C,L			; BC: Number of bytes to copy
0B0DB0 21    1584** LD      HL,0			; HL: 0
0B0DB1 00 
0B0DB2 00 
0B0DB3 00 
0B0DB4 39    1585** ADD     HL,SP			; HL: Stack address
0B0DB5 11    1586** LD      DE,ACCS			; DE: Destination
0B0DB6 00 
0B0DB7 4E 
0B0DB8 0B 
0B0DB9 0C    1587** INC     C			; Quick check to see if this is a zero length string
0B0DBA 0D    1588** DEC     C
0B0DBB 28    1589** JR      Z,POPS1         	; Yes it is, so skip
0B0DBC 02 
0B0DBD ED    1590** LDIR                    	; No, so copy from the stack
0B0DBE B0 
0B0DBF F9    1591** POPS1:			LD      SP,HL			; Shrink the stack
0B0DC0 DD    1592** JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B0DC1 E9 
             1593** ;
0B0DC2 FD    1594** HEXDIG:			LD      A,(IY)
0B0DC3 7E 
0B0DC4 00 
0B0DC5 FE    1595** CP      '0'
0B0DC6 30 
0B0DC7 D8    1596** RET     C
0B0DC8 FE    1597** CP      '9'+1
0B0DC9 3A 
0B0DCA 3F    1598** CCF
0B0DCB D0    1599** RET     NC
0B0DCC FE    1600** CP      'A'
0B0DCD 41 
0B0DCE D8    1601** RET     C
0B0DCF D6    1602** SUB     'A'-10
0B0DD0 37 
0B0DD1 FE    1603** CP      16
0B0DD2 10 
0B0DD3 3F    1604** CCF
0B0DD4 C9    1605** RET
             1606** ;
0B0DD5 FD    1607** BINDIG:			LD	A,(IY)
0B0DD6 7E 
0B0DD7 00 
0B0DD8 FE    1608** CP	'0'
0B0DD9 30 
0B0DDA D8    1609** RET	C
0B0DDB FE    1610** CP	'1'+1
0B0DDC 32 
0B0DDD 3F    1611** CCF
0B0DDE C9    1612** RET
             1613** ;
0B0DDF FE    1614** RELOP?:			CP      '>'
0B0DE0 3E 
0B0DE1 D0    1615** RET     NC
0B0DE2 FE    1616** CP      '='
0B0DE3 3D 
0B0DE4 D0    1617** RET     NC
0B0DE5 FE    1618** CP      '<'
0B0DE6 3C 
0B0DE7 C9    1619** RET
             1620** ;
0B0DE8 CD    1621** EXPRSC:			CALL    EXPRS
0B0DE9 DF 
0B0DEA 06 
0B0DEB 0B 
0B0DEC CD    1622** COMMA:			CALL    NXT
0B0DED 3A 
0B0DEE 0E 
0B0DEF 0B 
0B0DF0 FD    1623** INC     IY
0B0DF1 23 
0B0DF2 FE    1624** CP      ','
0B0DF3 2C 
0B0DF4 C8    1625** RET     Z
0B0DF5 3E    1626** LD      A,5
0B0DF6 05 
0B0DF7 18    1627** JR      ERROR1_EV          ;"Missing ,"
0B0DF8 0B 
             1628** ;
0B0DF9 CD    1629** BRAKET:			CALL    NXT
0B0DFA 3A 
0B0DFB 0E 
0B0DFC 0B 
0B0DFD FD    1630** INC     IY
0B0DFE 23 
0B0DFF FE    1631** CP      ')'
0B0E00 29 
0B0E01 C8    1632** RET     Z
0B0E02 3E    1633** LD      A,27
0B0E03 1B 
0B0E04 C3    1634** ERROR1_EV:			JP      ERROR_           ;"Missing )"
0B0E05 2A 
0B0E06 3B 
0B0E07 0B 
             1635** ;
0B0E08 FD    1636** SAVE_EV:			INC     IY
0B0E09 23 
0B0E0A 08    1637** SAVE1:			EX      AF,AF'
0B0E0B FA    1638** JP      M,TYPE_EV_
0B0E0C 00 
0B0E0D 07 
0B0E0E 0B 
0B0E0F 08    1639** EX      AF,AF'
0B0E10 E3    1640** EX      (SP),HL
0B0E11 D9    1641** EXX
0B0E12 E5    1642** PUSH    HL
0B0E13 D9    1643** EXX
0B0E14 F5    1644** PUSH    AF
0B0E15 C5    1645** PUSH    BC
0B0E16 E9    1646** JP      (HL)
             1647** ;
0B0E17 08    1648** DOIT:			EX      AF,AF'
0B0E18 FA    1649** JP      M,TYPE_EV_
0B0E19 00 
0B0E1A 07 
0B0E1B 0B 
0B0E1C D9    1650** EXX
0B0E1D C1    1651** POP     BC              ;RETURN ADDRESS
0B0E1E D9    1652** EXX
0B0E1F 79    1653** LD      A,C
0B0E20 C1    1654** POP     BC
0B0E21 47    1655** LD      B,A
0B0E22 F1    1656** POP     AF              ;OPERATOR
0B0E23 D9    1657** EXX
0B0E24 EB    1658** EX      DE,HL
0B0E25 E1    1659** POP     HL
0B0E26 D9    1660** EXX
0B0E27 EB    1661** EX      DE,HL
0B0E28 E1    1662** POP     HL
0B0E29 D9    1663** EXX
0B0E2A C5    1664** PUSH    BC
0B0E2B D9    1665** EXX
0B0E2C E6    1666** AND     0FH
0B0E2D 0F 
0B0E2E CD    1667** CALL    FPP
0B0E2F 34 
0B0E30 24 
0B0E31 0B 
0B0E32 38    1668** JR      C,ERROR1_EV
0B0E33 D0 
0B0E34 AF    1669** XOR     A
0B0E35 08    1670** EX      AF,AF'          ;TYPE
0B0E36 FD    1671** LD      A,(IY)
0B0E37 7E 
0B0E38 00 
0B0E39 C9    1672** RET
             1673** ;
             1674** ; Skip spaces
             1675** ; - IY: String pointer
             1676** ; Returns:
             1677** ;  - A: The non-space character found
             1678** ; - IY: Points to the character before that
             1679** ;
0B0E3A FD    1680** NXT:			LD      A,(IY)			; Fetch the character
0B0E3B 7E 
0B0E3C 00 
0B0E3D FE    1681** CP      ' '			; If it is space, then return
0B0E3E 20 
0B0E3F C0    1682** RET     NZ
0B0E40 FD    1683** INC     IY			; Increment the pointer and
0B0E41 23 
0B0E42 C3    1684** JP      NXT			; Loop
0B0E43 3A 
0B0E44 0E 
0B0E45 0B 
             1685** ;
0B0E46 E5    1686** DISPT2:			PUSH    HL
0B0E47 21    1687** LD      HL,SOPTBL
0B0E48 7F 
0B0E49 05 
0B0E4A 0B 
0B0E4B 18    1688** JR      DISPT0
0B0E4C 07 
             1689** ;
0B0E4D E5    1690** DISPAT:			PUSH    HL
0B0E4E D6    1691** SUB     FUNTOK
0B0E4F 8D 
0B0E50 21    1692** LD      HL,FUNTBL
0B0E51 D4 
0B0E52 04 
0B0E53 0B 
0B0E54 C5    1693** DISPT0:			PUSH    BC
             1694** 
0B0E55 01    1695** LD	BC, 3
0B0E56 03 
0B0E57 00 
0B0E58 00 
0B0E59 47    1696** LD	B, A
0B0E5A ED    1697** MLT	BC
0B0E5B 4C 
0B0E5C 09    1698** ADD	HL, BC
0B0E5D ED    1699** LD	HL, (HL)
0B0E5E 27 
             1700** 
             1701** ;			ADD     A,A
             1702** ;			LD      C,A
             1703** ;			LD      B,0
             1704** ;			ADD     HL,BC
             1705** ;			LD      A,(HL)
             1706** ;			INC     HL
             1707** ;			LD      H,(HL)
             1708** ;			LD      L,A
             1709** 
0B0E5F C1    1710** POP     BC
0B0E60 E3    1711** EX      (SP),HL
0B0E61 C9    1712** RET                     ;OFF TO ROUTINE
             1713** 
              0006* include "basic/exec.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Statement Execution & Assembler Module - "EXEC"
             0004** ; Author:	(C) Copyright  R.T.Russell  1984
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	12/05/2023
             0007** ; Last Updated:	26/06/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 27/01/1984:	Version 2.1
             0011** ; 02/03/1987:	Version 3.0
             0012** ; 11/06/1987:	Version 3.1
             0013** ; 12/05/2023:	Modified by Dean Belfield
             0014** ; 07/06/2023:	Modified to run in ADL mode
             0015** ; 26/06/2023:	Fixed DIM, USR, and address output of inline assembler
             0016** 
             0017** ; .ASSUME	ADL = 1
             0018** 
             0019** ; INCLUDE	"equs.inc"
             0020** 
             0021** ; SEGMENT CODE
             0022** 
             0023** ; XDEF	XEQ
             0024** ; XDEF	CHAIN0
             0025** ; XDEF	RUN
             0026** ; XDEF	SYNTAX
             0027** ; XDEF	ESCAPE
             0028** ; XDEF	FN_EX
             0029** ; XDEF	USR
             0030** ; XDEF	STORE5
             0031** ; XDEF	STORE4
             0032** ; XDEF	CHECK
             0033** ; XDEF	TERMQ
             0034** ; XDEF	FILL
             0035** ; XDEF	X4OR5
             0036** ; XDEF	MUL16
             0037** ; XDEF	CHANEL
             0038** ; XDEF	ASSEM
             0039** 
             0040** ; XREF	AUTO
             0041** ; XREF	DELETE
             0042** ; XREF	LOAD
             0043** ; XREF	LIST_
             0044** ; XREF	NEW
             0045** ; XREF	OLD
             0046** ; XREF	RENUM
             0047** ; XREF	SAVE
             0048** ; XREF	SOUND
             0049** ; XREF	CLG
             0050** ; XREF	DRAW
             0051** ; XREF	ENVEL
             0052** ; XREF	GCOL
             0053** ; XREF	MODE
             0054** ; XREF	MOVE
             0055** ; XREF	PLOT
             0056** ; XREF	COLOUR
             0057** ; XREF	EXPRS
             0058** ; XREF	HIMEM
             0059** ; XREF	LOAD0
             0060** ; XREF	RANDOM
             0061** ; XREF	CLEAR
             0062** ; XREF	ERRTRP
             0063** ; XREF	PAGE_
             0064** ; XREF	DATAPTR
             0065** ; XREF	ERRLIN
             0066** ; XREF	TRAP
             0067** ; XREF	NXT
             0068** ; XREF	SETLIN
             0069** ; XREF	CLOOP
             0070** ; XREF	OSSHUT
             0071** ; XREF	WARM
             0072** ; XREF	TRACEN
             0073** ; XREF	OUTCHR
             0074** ; XREF	PBCDL
             0075** ; XREF	OSCLI
             0076** ; XREF	LISTON
             0077** ; XREF	GETVAR
             0078** ; XREF	PUTVAR
             0079** ; XREF	DATPTR
             0080** ; XREF	ERROR_
             0081** ; XREF	EXPR
             0082** ; XREF	CREATE
             0083** ; XREF	EXPRI
             0084** ; XREF	BRAKET
             0085** ; XREF	FREE
             0086** ; XREF	OSBPUT
             0087** ; XREF	COUNT
             0088** ; XREF	STR
             0089** ; XREF	HEXSTR
             0090** ; XREF	CRLF
             0091** ; XREF	ITEMI
             0092** ; XREF	FINDL
             0093** ; XREF	TEST
             0094** ; XREF	EXPRN
             0095** ; XREF	DLOAD5
             0096** ; XREF	DLOAD5_SPL
             0097** ; XREF	LOADN
             0098** ; XREF	FPP
             0099** ; XREF	SWAP
             0100** ; XREF	GETDEF
             0101** ; XREF	ZERO
             0102** ; XREF	OSBGET
             0103** ; XREF	BUFFER
             0104** ; XREF	CONS
             0105** ; XREF	VAL0
             0106** ; XREF	OSLINE
             0107** ; XREF	CLRSCN
             0108** ; XREF	TELL
             0109** ; XREF	SAYLN
             0110** ; XREF	REPORT
             0111** ; XREF	PUTPTR
             0112** ; XREF	PUTIME
             0113** ; XREF	PUTIMS
             0114** ; XREF	LOMEM
             0115** ; XREF	WIDTH
             0116** ; XREF	OSWRCH
             0117** ; XREF	COMMA
             0118** ; XREF	OSCALL
             0119** ; XREF	SFIX
             0120** ; XREF	LOAD4
             0121** ; XREF	PUSHS
             0122** ; XREF	POPS
             0123** ; XREF	LOADS
             0124** ; XREF	PUTCSR
             0125** ; XREF	OUT_
             0126** ; XREF	R0
             0127** ;
             0128** ; List of token values used in this module
             0129** ;
             0130** TAND:			EQU     80H
             0131** TOR:			EQU     84H
             0132** TERROR_EX:			EQU     85H
             0133** LINE_EX_:			EQU     86H
             0134** OFF_:			EQU     87H
             0135** STEP:			EQU     88H
             0136** SPC:			EQU     89H
             0137** TAB:			EQU     8AH
             0138** ELSE_EX_:			EQU     8BH
             0139** THEN_EX_:			EQU     8CH
             0140** LINO_EX:			EQU     8DH
             0141** TO_EX:			EQU     B8H
             0142** TCMD_EX:			EQU     C6H
             0143** TCALL:			EQU     D6H
             0144** DATA_EX_:			EQU     DCH
             0145** DEF_:			EQU     DDH
             0146** TGOSUB:			EQU     E4H
             0147** TGOTO:			EQU     E5H
             0148** TON:			EQU     EEH
             0149** TPROC:			EQU     F2H
             0150** TSTOP:			EQU     FAH
             0151** 
             0152** ; The command table
             0153** ; Commands are tokens from C6H onwards; this lookup table is used to
             0154** ; run the corresponding function; Note that DATA and DEF both use the same
             0155** ; code as REM
             0156** ;
0B0E62 B3    0157** CMDTAB:			DW24  AUTO			; C6H
0B0E63 3A 
0B0E64 0B 
0B0E65 16    0158** DW24  DELETE			; C7H
0B0E66 39 
0B0E67 0B 
0B0E68 F4    0159** DW24  LOAD			; C8H
0B0E69 3A 
0B0E6A 0B 
0B0E6B 51    0160** DW24  LIST_			; C9H
0B0E6C 39 
0B0E6D 0B 
0B0E6E D1    0161** DW24  NEW			; CAH
0B0E6F 3A 
0B0E70 0B 
0B0E71 D7    0162** DW24  OLD			; CBH
0B0E72 3A 
0B0E73 0B 
0B0E74 E0    0163** DW24  RENUM			; CCH
0B0E75 39 
0B0E76 0B 
0B0E77 05    0164** DW24  SAVE			; CDH
0B0E78 3B 
0B0E79 0B 
0B0E7A 72    0165** DW24  PUT			; CEH
0B0E7B 19 
0B0E7C 0B 
0B0E7D 92    0166** DW24  PTR_EX			; CFH
0B0E7E 17 
0B0E7F 0B 
0B0E80 AC    0167** DW24  PAGEV_EX			; D0H
0B0E81 17 
0B0E82 0B 
0B0E83 BF    0168** DW24  TIMEV_EX			; D1H
0B0E84 17 
0B0E85 0B 
0B0E86 E8    0169** DW24  LOMEMV_EX			; D2H
0B0E87 17 
0B0E88 0B 
0B0E89 01    0170** DW24  HIMEMV_EX			; D3H
0B0E8A 18 
0B0E8B 0B 
0B0E8C F0    0171** DW24  SOUND			; D4H
0B0E8D 49 
0B0E8E 0B 
0B0E8F 8C    0172** DW24  BPUT			; D5H
0B0E90 18 
0B0E91 0B 
0B0E92 A4    0173** DW24  CALL_			; D6H
0B0E93 18 
0B0E94 0B 
0B0E95 16    0174** DW24  CHAIN			; D7H
0B0E96 0F 
0B0E97 0B 
0B0E98 61    0175** DW24  CLR			; D8H
0B0E99 17 
0B0E9A 0B 
0B0E9B 80    0176** DW24  CLOSE			; D9H
0B0E9C 18 
0B0E9D 0B 
0B0E9E 8C    0177** DW24  CLG			; DAH
0B0E9F 47 
0B0EA0 0B 
0B0EA1 34    0178** DW24  CLS			; DBH
0B0EA2 17 
0B0EA3 0B 
0B0EA4 F5    0179** DW24  REM_EX             		; DCH: DATA
0B0EA5 0F 
0B0EA6 0B 
0B0EA7 F5    0180** DW24  REM_EX             		; DDH: DEF
0B0EA8 0F 
0B0EA9 0B 
0B0EAA BB    0181** DW24  DIM_EX			; DEH
0B0EAB 10 
0B0EAC 0B 
0B0EAD B6    0182** DW24  DRAW			; DFH
0B0EAE 49 
0B0EAF 0B 
0B0EB0 90    0183** DW24  END_			; E0H
0B0EB1 0F 
0B0EB2 0B 
0B0EB3 4C    0184** DW24  ENDPRO			; E1H
0B0EB4 15 
0B0EB5 0B 
0B0EB6 81    0185** DW24  ENVEL			; E2H
0B0EB7 47 
0B0EB8 0B 
0B0EB9 61    0186** DW24  FOR_EX			; E3H
0B0EBA 13 
0B0EBB 0B 
0B0EBC 11    0187** DW24  GOSUB_EX			; E4H
0B0EBD 13 
0B0EBE 0B 
0B0EBF F5    0188** DW24  GOTO_EX			; E5H
0B0EC0 12 
0B0EC1 0B 
0B0EC2 4A    0189** DW24  GCOL			; E6H
0B0EC3 49 
0B0EC4 0B 
0B0EC5 00    0190** DW24  IF_			; E7H
0B0EC6 17 
0B0EC7 0B 
0B0EC8 EE    0191** DW24  INPUT			; E8H
0B0EC9 15 
0B0ECA 0B 
0B0ECB 16    0192** DW24  LET			; E9H
0B0ECC 10 
0B0ECD 0B 
0B0ECE F1    0193** DW24  LOCAL_EX_			; EAH
0B0ECF 14 
0B0ED0 0B 
0B0ED1 9C    0194** DW24  MODE			; EBH
0B0ED2 47 
0B0ED3 0B 
0B0ED4 AE    0195** DW24  MOVE			; ECH
0B0ED5 49 
0B0ED6 0B 
0B0ED7 AF    0196** DW24  NEXT_EX			; EDH
0B0ED8 13 
0B0ED9 0B 
0B0EDA 88    0197** DW24  ON_EX_			; EEH
0B0EDB 12 
0B0EDC 0B 
0B0EDD 5A    0198** DW24  VDU			; EFH
0B0EDE 18 
0B0EDF 0B 
0B0EE0 7C    0199** DW24  PLOT			; F0H
0B0EE1 49 
0B0EE2 0B 
0B0EE3 91    0200** DW24  PRINT_			; F1H
0B0EE4 11 
0B0EE5 0B 
0B0EE6 4E    0201** DW24  PROC_EX			; F2H
0B0EE7 14 
0B0EE8 0B 
0B0EE9 A0    0202** DW24  READ			; F3H
0B0EEA 16 
0B0EEB 0B 
0B0EEC F5    0203** DW24  REM_EX			; F4H
0B0EED 0F 
0B0EEE 0B 
0B0EEF 31    0204** DW24  REPEAT_EX			; F5H
0B0EF0 13 
0B0EF1 0B 
0B0EF2 59    0205** DW24  REPOR			; F6H
0B0EF3 17 
0B0EF4 0B 
0B0EF5 6B    0206** DW24  RESTOR_EX			; F7H
0B0EF6 17 
0B0EF7 0B 
0B0EF8 1F    0207** DW24  RETURN			; F8H
0B0EF9 13 
0B0EFA 0B 
0B0EFB 10    0208** DW24  RUN			; F9H
0B0EFC 0F 
0B0EFD 0B 
0B0EFE 41    0209** DW24  STOP			; FAH
0B0EFF 17 
0B0F00 0B 
0B0F01 98    0210** DW24  COLOUR			; FBH
0B0F02 48 
0B0F03 0B 
0B0F04 3C    0211** DW24  TRACE_EX			; FCH
0B0F05 18 
0B0F06 0B 
0B0F07 3B    0212** DW24  UNTIL_EX			; FDH
0B0F08 13 
0B0F09 0B 
0B0F0A 2E    0213** DW24  WIDTHV			; FEH
0B0F0B 18 
0B0F0C 0B 
0B0F0D DB    0214** DW24  CLI             		; FFH: OSCLI
0B0F0E 0F 
0B0F0F 0B 
             0215** 
             0216** ; RUN
             0217** ; RUN "filename"
             0218** ;
0B0F10 CD    0219** RUN:			CALL    TERMQ			; Standalone RUN command?
0B0F11 44 
0B0F12 1B 
0B0F13 0B 
0B0F14 28    0220** JR      Z,RUN0			; Yes, so just RUN the code
0B0F15 10 
             0221** 
             0222** ; CHAIN "filename"
             0223** ;
0B0F16 CD    0224** CHAIN:			CALL    EXPRS			; Get the filename
0B0F17 DF 
0B0F18 06 
0B0F19 0B 
0B0F1A 3E    0225** LD      A,CR			; Terminate it with a CR
0B0F1B 0D 
0B0F1C 12    0226** LD      (DE),A
0B0F1D ED    0227** CHAIN0:			LD      SP,(HIMEM)		; Reset SP
0B0F1E 7B 
0B0F1F 20 
0B0F20 51 
0B0F20 0B   
0B0F22 CD    0228** CALL    LOAD0			; And load the file in
0B0F23 E9 
0B0F24 3B 
0B0F25 0B 
             0229** ;
0B0F26 ED    0230** RUN0:			LD      SP,(HIMEM)      	; Prepare for RUN
0B0F27 7B 
0B0F28 20 
0B0F29 51 
0B0F29 0B   
0B0F2B DD    0231** LD      IX,RANDOM		; Pointer to the RANDOM sysvar
0B0F2C 21 
0B0F2D 38 
0B0F2E 51 
0B0F2E 0B   
0B0F30 ED    0232** @@:			LD      A, R			; Use the R register to seed the random number generator
0B0F31 5F 
0B0F32 28    0233** JR      Z, @B			; Loop unti we get a non-zero value in A
0B0F33 FC 
0B0F34 07    0234** RLCA				; Rotate it
0B0F35 07    0235** RLCA
0B0F36 DD    0236** LD      (IX+3),A		; And store
0B0F37 77 
0B0F38 03 
0B0F39 9F    0237** SBC     A,A			; Depending upon the C flag, this will either be 00h or FFh
0B0F3A DD    0238** LD      (IX+4),A		; And store
0B0F3B 77 
0B0F3C 04 
0B0F3D CD    0239** CALL    CLEAR
0B0F3E 40 
0B0F3F 3C 
0B0F40 0B 
0B0F41 21    0240** LD      HL,0			; Clear the error trap sysvar
0B0F42 00 
0B0F43 00 
0B0F44 00 
0B0F45 22    0241** LD      (ERRTRP),HL
0B0F46 2C 
0B0F47 51 
0B0F48 0B 
0B0F49 2A    0242** LD      HL,(PAGE_)		; Load HL with the start of program memory (PAGE)
0B0F4A 14 
0B0F4B 51 
0B0F4C 0B 
0B0F4D 3E    0243** LD      A,DATA_EX_			; The DATA token value
0B0F4E DC 
0B0F4F CD    0244** CALL    SEARCH_EX          	; Search for the first DATA token in the tokenised listing
0B0F50 18 
0B0F51 1C 
0B0F52 0B 
0B0F53 22    0245** LD      (DATPTR),HL     	; Set data pointer
0B0F54 31 
0B0F55 51 
0B0F56 0B 
0B0F57 FD    0246** LD      IY,(PAGE_)		; Load IY with the start of program memory
0B0F58 2A 
0B0F59 14 
0B0F5A 51 
0B0F5A 0B   
             0247** ;
0B0F5C CD    0248** XEQ0:			CALL    NEWLIN
0B0F5D A4 
0B0F5E 0F 
0B0F5F 0B 
0B0F60 FD    0249** XEQ:			LD      (ERRLIN),IY     	; Error pointer
0B0F61 22 
0B0F62 35 
0B0F63 51 
0B0F63 0B   
0B0F65 CD    0250** CALL    TRAP           		; Check keyboard
0B0F66 37 
0B0F67 43 
0B0F68 0B 
0B0F69 CD    0251** XEQ1:			CALL    NXT
0B0F6A 3A 
0B0F6B 0E 
0B0F6C 0B 
0B0F6D FD    0252** INC     IY
0B0F6E 23 
0B0F6F FE    0253** CP      ':'             	; Seperator
0B0F70 3A 
0B0F71 28    0254** JR      Z,XEQ1
0B0F72 F6 
0B0F73 FE    0255** CP      CR
0B0F74 0D 
0B0F75 28    0256** JR      Z,XEQ0          	; New program line
0B0F76 E5 
0B0F77 D6    0257** SUB     TCMD_EX
0B0F78 C6 
0B0F79 DA    0258** JP      C,LET0          	; Implied "LET"
0B0F7A 04 
0B0F7B 10 
0B0F7C 0B 
             0259** 
0B0F7D 01    0260** LD	BC, 3
0B0F7E 03 
0B0F7F 00 
0B0F80 00 
0B0F81 47    0261** LD	B, A
0B0F82 ED    0262** MLT	BC
0B0F83 4C 
0B0F84 21    0263** LD	HL,CMDTAB
0B0F85 62 
0B0F86 0E 
0B0F87 0B 
0B0F88 09    0264** ADD	HL, BC
0B0F89 ED    0265** LD	HL, (HL)		; Table entry
0B0F8A 27 
             0266** 
             0267** ;			ADD     A,A
             0268** ;			LD      C,A
             0269** ;			LD      B,0
             0270** ;			LD      HL,CMDTAB
             0271** ;			ADD     HL,BC
             0272** ;			LD      A,(HL)          	; Table entry
             0273** ;			INC     HL
             0274** ;			LD      H,(HL)
             0275** ;			LD      L,A
             0276** 
0B0F8B CD    0277** CALL    NXT
0B0F8C 3A 
0B0F8D 0E 
0B0F8E 0B 
0B0F8F E9    0278** JP      (HL)            	; Execute the statement
             0279** 
             0280** ;END
             0281** ;
0B0F90 CD    0282** END_:			CALL    SETLIN          ;FIND CURRENT LINE
0B0F91 78 
0B0F92 3D 
0B0F93 0B 
0B0F94 7C    0283** LD      A,H
0B0F95 B5    0284** OR      L               ;DIRECT?
0B0F96 CA    0285** JP      Z,CLOOP
0B0F97 4A 
0B0F98 34 
0B0F99 0B 
0B0F9A 1E    0286** LD      E,0
0B0F9B 00 
0B0F9C CD    0287** CALL    OSSHUT          ;CLOSE ALL FILES
0B0F9D F5 
0B0F9E 46 
0B0F9F 0B 
0B0FA0 C3    0288** JP      WARM            ;"Ready"
0B0FA1 49 
0B0FA2 34 
0B0FA3 0B 
             0289** ;
0B0FA4 FD    0290** NEWLIN:			LD      A,(IY+0)        ;A=LINE LENGTH
0B0FA5 7E 
0B0FA6 00 
0B0FA7 01    0291** LD      BC,3
0B0FA8 03 
0B0FA9 00 
0B0FAA 00 
0B0FAB FD    0292** ADD     IY,BC
0B0FAC 09 
0B0FAD B7    0293** OR      A
0B0FAE 28    0294** JR      Z,END_           ;LENGTH=0, EXIT
0B0FAF E0 
0B0FB0 2A    0295** LD      HL,(TRACEN)
0B0FB1 26 
0B0FB2 51 
0B0FB3 0B 
0B0FB4 7C    0296** LD      A,H
0B0FB5 B5    0297** OR      L
0B0FB6 C8    0298** RET     Z
0B0FB7 11    0299** LD	DE, 0		;Clear DE
0B0FB8 00 
0B0FB9 00 
0B0FBA 00 
0B0FBB FD    0300** LD      D,(IY-1)        ;DE = LINE NUMBER
0B0FBC 56 
0B0FBD FF 
0B0FBE FD    0301** LD      E,(IY-2)
0B0FBF 5E 
0B0FC0 FE 
0B0FC1 ED    0302** SBC     HL,DE
0B0FC2 52 
0B0FC3 D8    0303** RET     C
0B0FC4 EB    0304** EX      DE,HL
0B0FC5 3E    0305** LD      A,'['           ;TRACE
0B0FC6 5B 
0B0FC7 CD    0306** CALL    OUTCHR
0B0FC8 19 
0B0FC9 3D 
0B0FCA 0B 
0B0FCB CD    0307** CALL    PBCDL
0B0FCC C1 
0B0FCD 3D 
0B0FCE 0B 
0B0FCF 3E    0308** LD      A,']'
0B0FD0 5D 
0B0FD1 CD    0309** CALL    OUTCHR
0B0FD2 19 
0B0FD3 3D 
0B0FD4 0B 
0B0FD5 3E    0310** LD      A,' '
0B0FD6 20 
0B0FD7 C3    0311** JP      OUTCHR
0B0FD8 19 
0B0FD9 3D 
0B0FDA 0B 
             0312** 
             0313** ; Routines for each statement -------------------------------------------------
             0314** 
             0315** ; OSCLI
             0316** ;
0B0FDB CD    0317** CLI:			CALL    EXPRS
0B0FDC DF 
0B0FDD 06 
0B0FDE 0B 
0B0FDF 3E    0318** LD      A,CR
0B0FE0 0D 
0B0FE1 12    0319** LD      (DE),A
0B0FE2 21    0320** LD      HL,ACCS
0B0FE3 00 
0B0FE4 4E 
0B0FE5 0B 
0B0FE6 CD    0321** CALL    OSCLI
0B0FE7 5A 
0B0FE8 43 
0B0FE9 0B 
0B0FEA C3    0322** JP      XEQ
0B0FEB 60 
0B0FEC 0F 
0B0FED 0B 
             0323** 
             0324** ; REM, *
             0325** ;
0B0FEE FD    0326** EXT_EX:			PUSH    IY
0B0FEF E5 
0B0FF0 E1    0327** POP     HL
0B0FF1 CD    0328** CALL    OSCLI
0B0FF2 5A 
0B0FF3 43 
0B0FF4 0B 
0B0FF5 FD    0329** REM_EX:			PUSH    IY
0B0FF6 E5 
0B0FF7 E1    0330** POP     HL
0B0FF8 3E    0331** LD      A,CR
0B0FF9 0D 
0B0FFA 47    0332** LD      B,A
0B0FFB ED    0333** CPIR                    ;FIND LINE END
0B0FFC B1 
0B0FFD E5    0334** PUSH    HL
0B0FFE FD    0335** POP     IY
0B0FFF E1 
0B1000 C3    0336** JP      XEQ0
0B1001 5C 
0B1002 0F 
0B1003 0B 
             0337** 
             0338** ; [LET] var = expr
             0339** ;
0B1004 FE    0340** LET0:			CP      ELSE_EX_-TCMD_EX
0B1005 C5 
0B1006 28    0341** JR      Z,REM_EX
0B1007 ED 
             0342** ; CP      ('*'-TCMD) & 0FFH
             0343** ; JR      Z,EXT_EX
             0344** ; CP      ('='-TCMD) & 0FFH
             0345** ; JR      Z,FNEND
             0346** ; CP      ('['-TCMD) & 0FFH
             0347** ; ez80asm doesn't like () in expressions
0B1008 FE    0348** CP      '*'-TCMD_EX & 0FFH
0B1009 64 
0B100A 28    0349** JR      Z,EXT_EX
0B100B E2 
0B100C FE    0350** CP      '='-TCMD_EX & 0FFH
0B100D 77 
0B100E 28    0351** JR      Z,FNEND
0B100F 5B 
0B1010 FE    0352** CP      '['-TCMD_EX & 0FFH
0B1011 95 
0B1012 28    0353** JR      Z,ASM
0B1013 25 
0B1014 FD    0354** DEC     IY
0B1015 2B 
0B1016 CD    0355** LET:			CALL    ASSIGN			; Assign the variable
0B1017 88 
0B1018 19 
0B1019 0B 
0B101A CA    0356** JP      Z,XEQ			; Return if Z as it is a numeric variable that has been assigned in ASSIGN
0B101B 60 
0B101C 0F 
0B101D 0B 
0B101E 38    0357** JR      C,SYNTAX        	; Return if C as it is an illegal variable
0B101F 41 
             0358** ;
0B1020 F5    0359** PUSH    AF              	; At this point we're dealing with a string type (A=81h)
0B1021 CD    0360** CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B1022 5A 
0B1023 1B 
0B1024 0B 
0B1025 E5    0361** PUSH    HL			; HL: Address of the variable
0B1026 CD    0362** CALL    EXPRS
0B1027 DF 
0B1028 06 
0B1029 0B 
0B102A DD    0363** POP     IX			; IX: Address of the variable
0B102B E1 
0B102C F1    0364** POP     AF			; AF: The variable type
0B102D CD    0365** CALL    STACCS			; Copy the string from ACCS to the variable area
0B102E CA 
0B102F 19 
0B1030 0B 
0B1031 C3    0366** XEQR:			JP      XEQ
0B1032 60 
0B1033 0F 
0B1034 0B 
             0367** ;
0B1035 CD    0368** ASM0:			CALL    NEWLIN
0B1036 A4 
0B1037 0F 
0B1038 0B 
0B1039 FD    0369** ASM:			LD      (ERRLIN),IY
0B103A 22 
0B103B 35 
0B103C 51 
0B103C 0B   
0B103E CD    0370** CALL    TRAP
0B103F 37 
0B1040 43 
0B1041 0B 
0B1042 CD    0371** CALL    ASSEM
0B1043 65 
0B1044 1C 
0B1045 0B 
0B1046 38    0372** JR      C,SYNTAX
0B1047 19 
0B1048 FE    0373** CP      CR
0B1049 0D 
0B104A 28    0374** JR      Z,ASM0
0B104B E9 
0B104C 21    0375** LD      HL,LISTON
0B104D 40 
0B104E 51 
0B104F 0B 
0B1050 7E    0376** LD      A,(HL)
0B1051 E6    0377** AND     0FH
0B1052 0F 
0B1053 F6    0378** OR      B0H
0B1054 B0 
0B1055 77    0379** LD      (HL),A
0B1056 18    0380** JR      XEQR
0B1057 D9 
             0381** ;
0B1058 CD    0382** VAR_:			CALL    GETVAR
0B1059 04 
0B105A 3E 
0B105B 0B 
0B105C C8    0383** RET     Z
0B105D D2    0384** JP      NC,PUTVAR
0B105E F3 
0B105F 3D 
0B1060 0B 
0B1061 3E    0385** SYNTAX:			LD      A,16            ;"Syntax error"
0B1062 10 
0B1063 18    0386** JR	ERROR0_EX
0B1064 02 
0B1065 3E    0387** ESCAPE:			LD      A,17            ;"Escape"
0B1066 11 
0B1067 C3    0388** ERROR0_EX:			JP      ERROR_
0B1068 2A 
0B1069 3B 
0B106A 0B 
             0389** 
             0390** ; =
             0391** ;
0B106B CD    0392** FNEND:			CALL    EXPR            ;FUNCTION RESULT
0B106C 91 
0B106D 05 
0B106E 0B 
0B106F 43    0393** LD      B,E
0B1070 EB    0394** EX      DE,HL
0B1071 D9    0395** EXX                     ;SAVE RESULT
0B1072 EB    0396** EX      DE,HL           ; IN DEB'C'D'E'
0B1073 C1    0397** FNEND5:			POP     BC
0B1074 21    0398** LD      HL,LOCCHK
0B1075 22 
0B1076 1B 
0B1077 0B 
0B1078 B7    0399** OR      A
0B1079 ED    0400** SBC     HL,BC
0B107A 42 
0B107B 28    0401** JR      Z,FNEND0        ;LOCAL VARIABLE
0B107C 1C 
0B107D 21    0402** LD      HL,FNCHK
0B107E 4E 
0B107F 14 
0B1080 0B 
0B1081 B7    0403** OR      A
0B1082 ED    0404** SBC     HL,BC
0B1083 42 
0B1084 3E    0405** LD      A,7
0B1085 07 
0B1086 20    0406** JR      NZ,ERROR0_EX       ;"No FN"
0B1087 DF 
0B1088 FD    0407** POP     IY
0B1089 E1 
0B108A FD    0408** LD      (ERRLIN),IY     ;IN CASE OF ERROR
0B108B 22 
0B108C 35 
0B108D 51 
0B108D 0B   
0B108F EB    0409** EX      DE,HL
0B1090 D9    0410** EXX
0B1091 EB    0411** EX      DE,HL
0B1092 11    0412** LD      DE,ACCS
0B1093 00 
0B1094 4E 
0B1095 0B 
0B1096 58    0413** LD      E,B
0B1097 08    0414** EX      AF,AF'
0B1098 C9    0415** RET
             0416** ;
0B1099 DD    0417** FNEND0:			POP     IX
0B109A E1 
0B109B C1    0418** POP     BC
0B109C 78    0419** LD      A,B
0B109D B7    0420** OR      A
0B109E FA    0421** JP      M,FNEND1        ;STRING
0B109F AC 
0B10A0 10 
0B10A1 0B 
0B10A2 E1    0422** POP     HL
0B10A3 D9    0423** EXX
0B10A4 E1    0424** POP     HL
0B10A5 D9    0425** EXX
0B10A6 CD    0426** CALL    STORE
0B10A7 A0 
0B10A8 19 
0B10A9 0B 
0B10AA 18    0427** JR      FNEND5
0B10AB C7 
0B10AC 21    0428** FNEND1:			LD      HL,0
0B10AD 00 
0B10AE 00 
0B10AF 00 
0B10B0 39    0429** ADD     HL,SP
0B10B1 D5    0430** PUSH    DE
0B10B2 59    0431** LD      E,C
0B10B3 CD    0432** CALL    STORES
0B10B4 CE 
0B10B5 19 
0B10B6 0B 
0B10B7 D1    0433** POP     DE
0B10B8 F9    0434** LD      SP,HL
0B10B9 18    0435** JR      FNEND5
0B10BA B8 
             0436** 
             0437** ; DIM var(dim1[,dim2[,...]])[,var(...]
             0438** ; DIM var expr[,var expr...]
             0439** ;
0B10BB CD    0440** DIM_EX:			CALL    GETVAR          	; Get the variable
0B10BC 04 
0B10BD 3E 
0B10BE 0B 
0B10BF DA    0441** JP      C,BADDIM		; Throw a "Bad Dim" error
0B10C0 4B 
0B10C1 11 
0B10C2 0B 
0B10C3 CA    0442** JP      Z,DIM4			; If Z then the command is DIM var% expr, so don't need to create an entity
0B10C4 55 
0B10C5 11 
0B10C6 0B 
0B10C7 CD    0443** CALL    CREATE			; Create a new entity
0B10C8 78 
0B10C9 3F 
0B10CA 0B 
0B10CB E5    0444** PUSH    HL			; HL: Address of the entity
0B10CC DD    0445** POP     IX			; IX: Address of the entity
0B10CD E1 
0B10CE FD    0446** LD      A,(IY)			; Fetch the next character from the tokenised string
0B10CF 7E 
0B10D0 00 
0B10D1 FE    0447** CP      '('			; Check for opening brackets
0B10D2 28 
0B10D3 7A    0448** LD      A,D			;  A: The dimension variable type (04h = Integer, 05h = Float, 81h = String)
0B10D4 20    0449** JR      NZ,DIM4			; It is not a bracket; the command is DIM var expr
0B10D5 7F 
             0450** ;
             0451** ; At this point we're reserving a variable array
             0452** ;
0B10D6 E5    0453** PUSH    HL			; HL: Address of the entity
0B10D7 F5    0454** PUSH    AF           	   	;  A: Entity type (04h = Integer, 05h = Float, 81h = String)
0B10D8 11    0455** LD      DE,1			; DE: Total size of array accumulator (important for multi-dimensioned arrays)
0B10D9 01 
0B10DA 00 
0B10DB 00 
0B10DC 42    0456** LD      B,D			;  B: The number of dimensions in the array
             0457** ;
0B10DD FD    0458** DIM1:			INC     IY			; Skip to the next token
0B10DE 23 
0B10DF C5    0459** PUSH    BC			; Stack the dimension counter
0B10E0 D5    0460** PUSH    DE			; Stack the total size of array accumulator
0B10E1 DD    0461** PUSH    IX			; Stack the entity address
0B10E2 E5 
0B10E3 CD    0462** CALL    EXPRI           	; Fetch the size of this dimension
0B10E4 D4 
0B10E5 06 
0B10E6 0B 
0B10E7 CB    0463** BIT     7,H			; If it is negative then
0B10E8 7C 
0B10E9 20    0464** JR      NZ,BADDIM		; Throw a "Bad Dim" error
0B10EA 60 
0B10EB D9    0465** EXX
0B10EC 23    0466** INC     HL			; HL: Size of this dimension; increment (BBC BASIC DIMs are always one bigger)
0B10ED DD    0467** POP     IX			; IX: The entity address
0B10EE E1 
0B10EF DD    0468** INC     IX
0B10F0 23 
0B10F1 DD    0469** LD      (IX),L          	; Save the size of this dimension in the entity
0B10F2 75 
0B10F3 00 
0B10F4 DD    0470** INC     IX
0B10F5 23 
0B10F6 DD    0471** LD      (IX),H
0B10F7 74 
0B10F8 00 
0B10F9 C1    0472** POP     BC
0B10FA CD    0473** CALL    MUL16           	; HL = HL * BC (Number of Dimensions * Total size of array accumulator)
0B10FB 3C 
0B10FC 1C 
0B10FD 0B 
0B10FE 38    0474** JR      C,NOROOM        	; Throw a "No Room" error if overflow
0B10FF 4F 
0B1100 EB    0475** EX      DE,HL           	; DE: The new total size of array accumulator
0B1101 C1    0476** POP     BC
0B1102 04    0477** INC     B               	;  B: The dimension counter; increment
0B1103 FD    0478** LD      A,(IY)			; Fetch the nex token
0B1104 7E 
0B1105 00 
0B1106 FE    0479** CP      ','             	; Check for another dimension in the array
0B1107 2C 
0B1108 28    0480** JR      Z,DIM1			; And loop
0B1109 D3 
             0481** ;
0B110A CD    0482** CALL    BRAKET          	; Check for closing bracket
0B110B F9 
0B110C 0D 
0B110D 0B 
0B110E F1    0483** POP     AF              	; Restore the type
0B110F DD    0484** INC     IX
0B1110 23 
0B1111 DD    0485** EX      (SP),IX
0B1112 E3 
0B1113 DD    0486** LD      (IX),B          	; Number of dimensions
0B1114 70 
0B1115 00 
0B1116 CD    0487** CALL    X4OR5           	; Dimension Accumulator Value * 4 or * 5 depending on type
0B1117 2F 
0B1118 1C 
0B1119 0B 
0B111A E1    0488** POP     HL			; Restore the entity address
0B111B 38    0489** JR      C,NOROOM		; Throw a "No Room" error if there is an overflow
0B111C 32 
             0490** ;
             0491** ; We now allocate the memory for the array
             0492** ;
0B111D 19    0493** DIM3:			ADD     HL,DE
0B111E 38    0494** JR      C,NOROOM
0B111F 2F 
0B1120 E5    0495** PUSH    HL
0B1121 24    0496** INC     H
0B1122 28    0497** JR      Z,NOROOM
0B1123 2B 
0B1124 ED    0498** SBC     HL,SP
0B1125 72 
0B1126 30    0499** JR      NC,NOROOM       	; Throw an "Out of Space" error
0B1127 27 
0B1128 E1    0500** POP     HL
0B1129 22    0501** LD      (FREE),HL
0B112A 1D 
0B112B 51 
0B112C 0B 
0B112D 7A    0502** DIM2:			LD      A,D
0B112E B3    0503** OR      E
0B112F 28    0504** JR      Z,DIM5
0B1130 06 
0B1131 2B    0505** DEC     HL
0B1132 36    0506** LD      (HL),0         		; Initialise the array
0B1133 00 
0B1134 1B    0507** DEC     DE
0B1135 18    0508** JR      DIM2
0B1136 F6 
0B1137 CD    0509** DIM5:			CALL    NXT
0B1138 3A 
0B1139 0E 
0B113A 0B 
0B113B FE    0510** CP      ','            		; Another variable?
0B113C 2C 
0B113D C2    0511** JP      NZ,XEQ
0B113E 60 
0B113F 0F 
0B1140 0B 
0B1141 FD    0512** INC     IY
0B1142 23 
0B1143 CD    0513** CALL    NXT
0B1144 3A 
0B1145 0E 
0B1146 0B 
0B1147 C3    0514** JP      DIM_EX
0B1148 BB 
0B1149 10 
0B114A 0B 
             0515** ;
             0516** ; DIM errors
             0517** ;
0B114B 3E    0518** BADDIM:			LD      A,10            	; Throw a "Bad DIM" error
0B114C 0A 
0B114D 18    0519** JR	ERROR1_EX
0B114E 02 
0B114F 3E    0520** NOROOM:			LD      A,11            	; Throw a "DIM space" error
0B1150 0B 
0B1151 C3    0521** ERROR1_EX:			JP      ERROR_
0B1152 2A 
0B1153 3B 
0B1154 0B 
             0522** ;
             0523** ; At this point we're reserving a block of memory, i.e.
             0524** ; DIM var expr[,var expr...]
             0525** ;
0B1155 B7    0526** DIM4:			OR      A			;  A: The dimension variable type
0B1156 28    0527** JR      Z,BADDIM		; Throw "Bad Dim" if variable is an 8-bit indirection
0B1157 F3 
0B1158 FA    0528** JP      M,BADDIM        	; or a string
0B1159 4B 
0B115A 11 
0B115B 0B 
0B115C 47    0529** LD      B,A			; Temporarily store the dimension variable type in B
0B115D FD    0530** LD      A,(IY-1)		; Get the last character but one
0B115E 7E 
0B115F FF 
0B1160 FE    0531** CP      ')'			; Check if it is a trailing bracket
0B1161 29 
0B1162 28    0532** JR      Z,BADDIM		; And throw a "Bad Dim" error if there is a trailing bracket
0B1163 E7 
             0533** ;
0B1164 21    0534** LD	HL,0			; Clear HL
0B1165 00 
0B1166 00 
0B1167 00 
0B1168 3A    0535** LD	A,(FREE+0)		; HL: Lower 16 bits of FREE
0B1169 1D 
0B116A 51 
0B116B 0B 
0B116C 6F    0536** LD	L,A
0B116D 3A    0537** LD	A,(FREE+1)
0B116E 1E 
0B116F 51 
0B1170 0B 
0B1171 67    0538** LD	H,A
0B1172 78    0539** LD	A,B			; Restore the dimension variable type
0B1173 D9    0540** EXX
0B1174 21    0541** LD	HL,0			; Clear HL
0B1175 00 
0B1176 00 
0B1177 00 
0B1178 47    0542** LD	B,A			; Temporarily store the dimension variable type in B
0B1179 3A    0543** LD	A,(FREE+2)		; HL: Upper 8 bits of FREE (bits 16-23)
0B117A 1F 
0B117B 51 
0B117C 0B 
0B117D 6F    0544** LD	L,A
0B117E 78    0545** LD	A,B			; Restore the dimension variable type
0B117F 4C    0546** LD	C,H
0B1180 CD    0547** CALL    STORE           	; Store the address
0B1181 A0 
0B1182 19 
0B1183 0B 
0B1184 CD    0548** CALL    EXPRI			; Get the number of bytes to store
0B1185 D4 
0B1186 06 
0B1187 0B 
0B1188 D9    0549** EXX
0B1189 23    0550** INC     HL			; Add one to it
0B118A EB    0551** EX      DE,HL
0B118B 2A    0552** LD      HL,(FREE)
0B118C 1D 
0B118D 51 
0B118E 0B 
0B118F 18    0553** JR      DIM3			; Continue with the DIM
0B1190 8C 
             0554** 
             0555** ; PRINT list...
             0556** ; PRINT #channel,list...
             0557** ;
0B1191 FE    0558** PRINT_:			CP      '#'
0B1192 23 
0B1193 20    0559** JR      NZ,PRINT0
0B1194 7C 
0B1195 CD    0560** CALL    CHNL            ;CHANNEL NO. = E
0B1196 5C 
0B1197 1C 
0B1198 0B 
0B1199 CD    0561** PRNTN1:			CALL    NXT
0B119A 3A 
0B119B 0E 
0B119C 0B 
0B119D FE    0562** CP      ','
0B119E 2C 
0B119F C2    0563** JP      NZ,XEQ
0B11A0 60 
0B11A1 0F 
0B11A2 0B 
0B11A3 FD    0564** INC     IY
0B11A4 23 
0B11A5 D5    0565** PUSH    DE
0B11A6 CD    0566** CALL    EXPR            ;ITEM TO PRINT
0B11A7 91 
0B11A8 05 
0B11A9 0B 
0B11AA 08    0567** EX      AF,AF'
0B11AB FA    0568** JP      M,PRNTN2        ;STRING
0B11AC D1 
0B11AD 11 
0B11AE 0B 
0B11AF D1    0569** POP     DE
0B11B0 C5    0570** PUSH    BC
0B11B1 D9    0571** EXX
0B11B2 7D    0572** LD      A,L
0B11B3 D9    0573** EXX
0B11B4 CD    0574** CALL    OSBPUT
0B11B5 05 
0B11B6 47 
0B11B7 0B 
0B11B8 D9    0575** EXX
0B11B9 7C    0576** LD      A,H
0B11BA D9    0577** EXX
0B11BB CD    0578** CALL    OSBPUT
0B11BC 05 
0B11BD 47 
0B11BE 0B 
0B11BF 7D    0579** LD      A,L
0B11C0 CD    0580** CALL    OSBPUT
0B11C1 05 
0B11C2 47 
0B11C3 0B 
0B11C4 7C    0581** LD      A,H
0B11C5 CD    0582** CALL    OSBPUT
0B11C6 05 
0B11C7 47 
0B11C8 0B 
0B11C9 C1    0583** POP     BC
0B11CA 79    0584** LD      A,C
0B11CB CD    0585** CALL    OSBPUT
0B11CC 05 
0B11CD 47 
0B11CE 0B 
0B11CF 18    0586** JR      PRNTN1
0B11D0 C8 
0B11D1 4B    0587** PRNTN2:			LD      C,E
0B11D2 D1    0588** POP     DE
0B11D3 21    0589** LD      HL,ACCS
0B11D4 00 
0B11D5 4E 
0B11D6 0B 
0B11D7 0C    0590** INC     C
0B11D8 0D    0591** PRNTN3:			DEC     C
0B11D9 28    0592** JR      Z,PRNTN4
0B11DA 0A 
0B11DB 7E    0593** LD      A,(HL)
0B11DC 23    0594** INC     HL
0B11DD C5    0595** PUSH    BC
0B11DE CD    0596** CALL    OSBPUT
0B11DF 05 
0B11E0 47 
0B11E1 0B 
0B11E2 C1    0597** POP     BC
0B11E3 18    0598** JR      PRNTN3
0B11E4 F3 
0B11E5 3E    0599** PRNTN4:			LD      A,CR
0B11E6 0D 
0B11E7 CD    0600** CALL    OSBPUT
0B11E8 05 
0B11E9 47 
0B11EA 0B 
0B11EB 18    0601** JR      PRNTN1
0B11EC AC 
             0602** ;
0B11ED 06    0603** PRINT6:			LD      B,2
0B11EE 02 
0B11EF 18    0604** JR      PRINTC
0B11F0 27 
0B11F1 01    0605** PRINT8:			LD      BC,100H
0B11F2 00 
0B11F3 01 
0B11F4 00 
0B11F5 18    0606** JR      PRINTC
0B11F6 21 
0B11F7 21    0607** PRINT9:			LD      HL,STAVAR
0B11F8 00 
0B11F9 50 
0B11FA 0B 
0B11FB AF    0608** XOR     A
0B11FC BE    0609** CP      (HL)
0B11FD 28    0610** JR      Z,PRINT0
0B11FE 12 
0B11FF 3A    0611** LD      A,(COUNT)
0B1200 3D 
0B1201 51 
0B1202 0B 
0B1203 B7    0612** OR      A
0B1204 28    0613** JR      Z,PRINT0
0B1205 0B 
0B1206 96    0614** PRINTA:			SUB     (HL)
0B1207 28    0615** JR      Z,PRINT0
0B1208 08 
0B1209 30    0616** JR      NC,PRINTA
0B120A FB 
0B120B ED    0617** NEG
0B120C 44 
0B120D CD    0618** CALL    FILL
0B120E B9 
0B120F 1B 
0B1210 0B 
0B1211 3A    0619** PRINT0:			LD      A,(STAVAR)
0B1212 00 
0B1213 50 
0B1214 0B 
0B1215 4F    0620** LD      C,A             ;PRINTS
0B1216 06    0621** LD      B,0             ;PRINTF
0B1217 00 
0B1218 CD    0622** PRINTC:			CALL    TERMQ
0B1219 44 
0B121A 1B 
0B121B 0B 
0B121C 28    0623** JR      Z,PRINT4
0B121D 3F 
0B121E CB    0624** RES     0,B
0B121F 80 
0B1220 FD    0625** INC     IY
0B1221 23 
0B1222 FE    0626** CP      '~'
0B1223 7E 
0B1224 28    0627** JR      Z,PRINT6
0B1225 C7 
0B1226 FE    0628** CP      ';'
0B1227 3B 
0B1228 28    0629** JR      Z,PRINT8
0B1229 C7 
0B122A FE    0630** CP      ','
0B122B 2C 
0B122C 28    0631** JR      Z,PRINT9
0B122D C9 
0B122E CD    0632** CALL    FORMAT          ;SPC, TAB, '
0B122F 69 
0B1230 1B 
0B1231 0B 
0B1232 28    0633** JR      Z,PRINTC
0B1233 E4 
0B1234 FD    0634** DEC     IY
0B1235 2B 
0B1236 C5    0635** PUSH    BC
0B1237 CD    0636** CALL    EXPR            ;VARIABLE TYPE
0B1238 91 
0B1239 05 
0B123A 0B 
0B123B 08    0637** EX      AF,AF'
0B123C FA    0638** JP      M,PRINT3        ;STRING
0B123D 56 
0B123E 12 
0B123F 0B 
0B1240 D1    0639** POP     DE
0B1241 D5    0640** PUSH    DE
0B1242 CB    0641** BIT     1,D
0B1243 4A 
0B1244 F5    0642** PUSH    AF
0B1245 CC    0643** CALL    Z,STR           ;DECIMAL
0B1246 30 
0B1247 0D 
0B1248 0B 
0B1249 F1    0644** POP     AF
0B124A C4    0645** CALL    NZ,HEXSTR       ;HEX
0B124B E4 
0B124C 0C 
0B124D 0B 
0B124E C1    0646** POP     BC
0B124F C5    0647** PUSH    BC
0B1250 79    0648** LD      A,C
0B1251 93    0649** SUB     E
0B1252 D4    0650** CALL    NC,FILL         ;RIGHT JUSTIFY
0B1253 B9 
0B1254 1B 
0B1255 0B 
0B1256 C1    0651** PRINT3:			POP     BC
0B1257 CD    0652** CALL    PTEXT           ;PRINT
0B1258 C8 
0B1259 1B 
0B125A 0B 
0B125B 18    0653** JR      PRINTC
0B125C BB 
0B125D CB    0654** PRINT4:			BIT     0,B
0B125E 40 
0B125F CC    0655** CALL    Z,CRLF
0B1260 11 
0B1261 3D 
0B1262 0B 
0B1263 C3    0656** JP      XEQ
0B1264 60 
0B1265 0F 
0B1266 0B 
             0657** 
             0658** ; ON ERROR statement [:statement...]
             0659** ; ON ERROR OFF
             0660** ;
0B1267 FD    0661** ONERR:			INC     IY              ;SKIP "ERROR"
0B1268 23 
0B1269 21    0662** LD      HL,0
0B126A 00 
0B126B 00 
0B126C 00 
0B126D 22    0663** LD      (ERRTRP),HL
0B126E 2C 
0B126F 51 
0B1270 0B 
0B1271 CD    0664** CALL    NXT
0B1272 3A 
0B1273 0E 
0B1274 0B 
0B1275 FE    0665** CP      OFF_
0B1276 87 
0B1277 FD    0666** INC     IY
0B1278 23 
0B1279 CA    0667** JP      Z,XEQ
0B127A 60 
0B127B 0F 
0B127C 0B 
0B127D FD    0668** DEC     IY
0B127E 2B 
0B127F FD    0669** LD      (ERRTRP),IY
0B1280 22 
0B1281 2C 
0B1282 51 
0B1282 0B   
0B1284 C3    0670** JP      REM_EX
0B1285 F5 
0B1286 0F 
0B1287 0B 
             0671** 
             0672** ; ON expr GOTO line[,line...] [ELSE statement]
             0673** ; ON expr GOTO line[,line...] [ELSE line]
             0674** ; ON expr GOSUB line[,line...] [ELSE statement]
             0675** ; ON expr GOSUB line[,line...] [ELSE line]
             0676** ; ON expr PROCone [,PROCtwo..] [ELSE PROCotherwise]
             0677** ;
0B1288 FE    0678** ON_EX_:			CP      TERROR_EX
0B1289 85 
0B128A 28    0679** JR      Z,ONERR         ;"ON ERROR"
0B128B DB 
0B128C CD    0680** CALL    EXPRI
0B128D D4 
0B128E 06 
0B128F 0B 
0B1290 FD    0681** LD      A,(IY)
0B1291 7E 
0B1292 00 
0B1293 FD    0682** INC     IY
0B1294 23 
0B1295 1E    0683** LD      E,','           ;SEPARATOR
0B1296 2C 
0B1297 FE    0684** CP      TGOTO
0B1298 E5 
0B1299 28    0685** JR      Z,ON1
0B129A 0B 
0B129B FE    0686** CP      TGOSUB
0B129C E4 
0B129D 28    0687** JR      Z,ON1
0B129E 07 
0B129F 1E    0688** LD      E,TPROC
0B12A0 F2 
0B12A1 BB    0689** CP      E
0B12A2 3E    0690** LD      A,39
0B12A3 27 
0B12A4 20    0691** JR      NZ,ERROR2_EX       ;"ON syntax"
0B12A5 45 
0B12A6 57    0692** ON1:			LD      D,A
0B12A7 D9    0693** EXX
0B12A8 E5    0694** PUSH    HL
0B12A9 D9    0695** EXX
0B12AA C1    0696** POP     BC              ;ON INDEX
0B12AB 78    0697** LD      A,B
0B12AC B4    0698** OR      H
0B12AD B5    0699** OR      L
0B12AE 20    0700** JR      NZ,ON4          ;OUT OF RANGE
0B12AF 2A 
0B12B0 B1    0701** OR      C
0B12B1 28    0702** JR      Z,ON4
0B12B2 27 
0B12B3 0D    0703** DEC     C
0B12B4 28    0704** JR      Z,ON3           ;INDEX=1
0B12B5 0E 
0B12B6 CD    0705** ON2:			CALL    TERMQ
0B12B7 44 
0B12B8 1B 
0B12B9 0B 
0B12BA 28    0706** JR      Z,ON4           ;OUT OF RANGE
0B12BB 1E 
0B12BC FD    0707** INC     IY              ;SKIP DELIMITER
0B12BD 23 
0B12BE BB    0708** CP      E
0B12BF 20    0709** JR      NZ,ON2
0B12C0 F5 
0B12C1 0D    0710** DEC     C
0B12C2 20    0711** JR      NZ,ON2
0B12C3 F2 
0B12C4 7B    0712** ON3:			LD      A,E
0B12C5 FE    0713** CP      TPROC
0B12C6 F2 
0B12C7 28    0714** JR      Z,ONPROC
0B12C8 26 
0B12C9 D5    0715** PUSH    DE
0B12CA CD    0716** CALL    ITEMI           ;LINE NUMBER
0B12CB EF 
0B12CC 06 
0B12CD 0B 
0B12CE D1    0717** POP     DE
0B12CF 7A    0718** LD      A,D
0B12D0 FE    0719** CP      TGOTO
0B12D1 E5 
0B12D2 28    0720** JR      Z,GOTO2
0B12D3 2D 
0B12D4 CD    0721** CALL    SPAN            ;SKIP REST OF LIST
0B12D5 51 
0B12D6 1B 
0B12D7 0B 
0B12D8 18    0722** JR      GOSUB1
0B12D9 3B 
             0723** ;
0B12DA FD    0724** ON4:			LD      A,(IY)
0B12DB 7E 
0B12DC 00 
0B12DD FD    0725** INC     IY
0B12DE 23 
0B12DF FE    0726** CP      ELSE_EX_
0B12E0 8B 
0B12E1 CA    0727** JP      Z,IF1           ;ELSE CLAUSE
0B12E2 15 
0B12E3 17 
0B12E4 0B 
0B12E5 FE    0728** CP      CR
0B12E6 0D 
0B12E7 20    0729** JR      NZ,ON4
0B12E8 F1 
0B12E9 3E    0730** LD      A,40
0B12EA 28 
0B12EB C3    0731** ERROR2_EX:			JP      ERROR_           ;"ON range"
0B12EC 2A 
0B12ED 3B 
0B12EE 0B 
             0732** ;
0B12EF 3E    0733** ONPROC:			LD      A,TON
0B12F0 EE 
0B12F1 C3    0734** JP      PROC_EX
0B12F2 4E 
0B12F3 14 
0B12F4 0B 
             0735** 
             0736** ; GOTO line
             0737** ;
0B12F5 CD    0738** GOTO_EX:			CALL    ITEMI           	; Fetch the line number
0B12F6 EF 
0B12F7 06 
0B12F8 0B 
0B12F9 CD    0739** GOTO1:			CALL    TERMQ			; Check for terminator
0B12FA 44 
0B12FB 1B 
0B12FC 0B 
0B12FD C2    0740** JP      NZ,SYNTAX		; Throw a "Syntax Error" if not found
0B12FE 61 
0B12FF 10 
0B1300 0B 
0B1301 D9    0741** GOTO2:			EXX
0B1302 CD    0742** CALL    FINDL			; HL: Line number - Find the line
0B1303 59 
0B1304 3D 
0B1305 0B 
0B1306 E5    0743** PUSH    HL			; HL: Address of the line
0B1307 FD    0744** POP     IY			; IY = HL
0B1308 E1 
0B1309 CA    0745** JP      Z,XEQ0			; If the line is found, then continue execution at that point
0B130A 5C 
0B130B 0F 
0B130C 0B 
0B130D 3E    0746** LD      A,41			; Otherwise throw a "No such line" error
0B130E 29 
0B130F 18    0747** JR      ERROR2_EX
0B1310 DA 
             0748** 
             0749** ; GOSUB line
             0750** ; This pushes the following data onto the execution stack
             0751** ; - 3 bytes: Current execution address
             0752** ; - 3 bytes: Marker (the address of label GOSCHK)
             0753** ;
0B1311 CD    0754** GOSUB_EX:			CALL    ITEMI			; Fetch the line number
0B1312 EF 
0B1313 06 
0B1314 0B 
0B1315 FD    0755** GOSUB1:			PUSH    IY              	; Push the current execution address onto the execution stack
0B1316 E5 
0B1317 CD    0756** CALL    CHECK           	; Check there is enough room
0B1318 19 
0B1319 1A 
0B131A 0B 
0B131B CD    0757** CALL    GOTO1           	; Push the marker (address of GOSCHK) onto the execution stack and GOTO the line number
0B131C F9 
0B131D 12 
0B131E 0B 
             0758** GOSCHK:			EQU     $
             0759** 
             0760** ; RETURN
             0761** ; This pops the following data off the execution stack as pushed by GOSUB
             0762** ; - 3 bytes: Marker (should be the address of label GOSCHK)
             0763** ; - 3 bytes: The return execution address
             0764** ;
0B131F D1    0765** RETURN:			POP     DE			; Pop the marker off the execution stack
0B1320 21    0766** LD      HL,GOSCHK		; Compare with GOSCHK
0B1321 1F 
0B1322 13 
0B1323 0B 
0B1324 B7    0767** OR      A
0B1325 ED    0768** SBC     HL,DE
0B1326 52 
0B1327 FD    0769** POP     IY			; Pop the return address off the execution stack
0B1328 E1 
0B1329 CA    0770** JP      Z,XEQ			; Provided this has been called by a GOSUB then continue execution at the return address
0B132A 60 
0B132B 0F 
0B132C 0B 
0B132D 3E    0771** LD      A,38			; Otherwise throw a "No GOSUB" error
0B132E 26 
0B132F 18    0772** JR      ERROR2_EX
0B1330 BA 
             0773** 
             0774** ; REPEAT
             0775** ; This pushes the following data onto the execution stack
             0776** ; - 3 bytes: Current execution address
             0777** ; - 3 bytes: Marker (the address of label REPCHK)
             0778** ;
0B1331 FD    0779** REPEAT_EX:			PUSH    IY			; Push the current execution address onto the execution stack
0B1332 E5 
0B1333 CD    0780** CALL    CHECK			; Check if there is enough room
0B1334 19 
0B1335 1A 
0B1336 0B 
0B1337 CD    0781** CALL    XEQ			; Push the marker (address of REPCHK) onto the execution stack and continue execution
0B1338 60 
0B1339 0F 
0B133A 0B 
             0782** REPCHK:			EQU     $
             0783** 
             0784** ; UNTIL expr
             0785** ; This pops the following data off the execution stack
             0786** ; - 3 bytes: Marker (should be the address of label REPCHK)
             0787** ; - 3 bytes: The address of the REPEAT instruction
             0788** ; It also ensures that the data is pushed back on for subsequent UNTIL instructions
             0789** ;
0B133B C1    0790** UNTIL_EX:			POP     BC			; Fetch the marker
0B133C C5    0791** PUSH    BC			; And push it back onto the execution stack
0B133D 21    0792** LD      HL,REPCHK		; Compare with REPCHK
0B133E 3B 
0B133F 13 
0B1340 0B 
0B1341 B7    0793** OR      A
0B1342 ED    0794** SBC     HL,BC
0B1343 42 
0B1344 3E    0795** LD      A,43
0B1345 2B 
0B1346 20    0796** JR      NZ,ERROR2_EX		; Throw a "No REPEAT" if this value does not match
0B1347 A3 
0B1348 CD    0797** CALL    EXPRI			; Fetch the expression
0B1349 D4 
0B134A 06 
0B134B 0B 
0B134C CD    0798** CALL    TEST			; Test if the expression evaluates to zero
0B134D A9 
0B134E 0C 
0B134F 0B 
0B1350 C1    0799** POP     BC			; Pop the marker
0B1351 D1    0800** POP     DE			; Pop the address of the REPEAT instruction
0B1352 20    0801** JR      NZ,XEQ2         	; If it is TRUE, then continue execution after the UNTIL instruction (we're done looping)
0B1353 05 
0B1354 D5    0802** PUSH    DE			; Push the address of the REPEAT instruction back on the stack
0B1355 C5    0803** PUSH    BC			; Push the marker back on the stack
0B1356 D5    0804** PUSH    DE			; IY = DE
0B1357 FD    0805** POP     IY			; This sets the execution address back to the REPEAT instruction
0B1358 E1 
0B1359 C3    0806** XEQ2:			JP      XEQ			; Continue execution
0B135A 60 
0B135B 0F 
0B135C 0B 
             0807** 
             0808** ; FOR var = expr TO expr [STEP expr]
             0809** ; This pushes the following data onto the execution stack
             0810** ; - 3 bytes: The limit value
             0811** ; - 3 bytes: The step value
             0812** ; - 3 bytes: The current execution address
             0813** ; - 3 bytes: The address of the loop variable
             0814** ; - 3 bytes: Marker (the address of FORCHK)
             0815** ;
0B135D 3E    0816** FORVAR:			LD      A,34
0B135E 22 
0B135F 18    0817** JR      ERROR2_EX          	; Throw "FOR variable" error
0B1360 8A 
             0818** ;
0B1361 CD    0819** FOR_EX:			CALL    ASSIGN			; Assign the START expression value to a variable
0B1362 88 
0B1363 19 
0B1364 0B 
0B1365 20    0820** JR      NZ,FORVAR       	; If the variable is a string, or invalid, then throw a "FOR variable" error
0B1366 F6 
0B1367 F5    0821** PUSH    AF              	; Save the variable type
0B1368 FD    0822** LD      A,(IY)			; Check the next token
0B1369 7E 
0B136A 00 
0B136B FE    0823** CP      TO_EX			; Compare with the token value for "TO"
0B136C B8 
0B136D 3E    0824** LD      A,36			; Set the error code to 36 ("No TO")
0B136E 24 
0B136F C2    0825** JP      NZ,ERROR2_EX       	; And throw the error if that token is missing
0B1370 EB 
0B1371 12 
0B1372 0B 
0B1373 FD    0826** INC     IY			; Skip to the next token
0B1374 23 
             0827** ;
0B1375 DD    0828** PUSH    IX
0B1376 E5 
0B1377 CD    0829** CALL    EXPRN           	; Fetch the LIMIT expression value
0B1378 CC 
0B1379 06 
0B137A 0B 
0B137B DD    0830** POP     IX
0B137C E1 
0B137D F1    0831** POP     AF
0B137E 47    0832** LD      B,A             	; B: LIMIT value type (04h = Integer, 05h = Float)
0B137F C5    0833** PUSH    BC              	; Stack the LIMIT value
0B1380 E5    0834** PUSH    HL
0B1381 21    0835** LD      HL,0
0B1382 00 
0B1383 00 
0B1384 00 
0B1385 4C    0836** LD      C,H
0B1386 D9    0837** EXX
0B1387 E5    0838** PUSH    HL
             0839** ;
0B1388 21    0840** LD      HL,1            	; The preset STEP value is 1
0B1389 01 
0B138A 00 
0B138B 00 
0B138C D9    0841** EXX
0B138D FD    0842** LD      A,(IY)			; Fetch the next token
0B138E 7E 
0B138F 00 
0B1390 FE    0843** CP      STEP			; Compare with the token value for "STEP"
0B1391 88 
0B1392 20    0844** JR      NZ,FOR1			; If there is no STEP token, then skip the next bit
0B1393 0A 
             0845** ;
0B1394 FD    0846** INC     IY			; Skip past the STEP token
0B1395 23 
0B1396 DD    0847** PUSH    IX
0B1397 E5 
0B1398 CD    0848** CALL    EXPRN          		; Fetch the STEP expression value
0B1399 CC 
0B139A 06 
0B139B 0B 
0B139C DD    0849** POP     IX
0B139D E1 
             0850** ;
0B139E C5    0851** FOR1:			PUSH    BC			; Stack the STEP value
0B139F E5    0852** PUSH    HL
0B13A0 D9    0853** EXX
0B13A1 E5    0854** PUSH    HL
0B13A2 D9    0855** EXX
             0856** ;
0B13A3 FD    0857** PUSH    IY              	; Stack the current execution address
0B13A4 E5 
0B13A5 DD    0858** PUSH    IX              	; Stack the loop variable
0B13A6 E5 
0B13A7 CD    0859** CALL    CHECK
0B13A8 19 
0B13A9 1A 
0B13AA 0B 
0B13AB CD    0860** CALL    XEQ
0B13AC 60 
0B13AD 0F 
0B13AE 0B 
             0861** FORCHK:			EQU     $
             0862** 
             0863** ; NEXT [var[,var...]]
             0864** ; This pops the following data off the execution stack
             0865** ; - 3 bytes: Marker (the address of FORCHK)
             0866** ; - 3 bytes: The address of the loop variable
             0867** ; - 3 bytes: The current execution address
             0868** ; - 3 bytes: The step value
             0869** ; - 3 bytes: The limit value
             0870** ; It also ensures that the data is pushed back on for subsequent NEXT instructions
             0871** ;
0B13AF C1    0872** NEXT_EX:			POP     BC              	; Pop the marker off the execution stack
0B13B0 21    0873** LD      HL,FORCHK		; Compare with FORCHK
0B13B1 AF 
0B13B2 13 
0B13B3 0B 
0B13B4 B7    0874** OR      A
0B13B5 ED    0875** SBC     HL,BC
0B13B6 42 
0B13B7 3E    0876** LD      A,32
0B13B8 20 
0B13B9 C2    0877** JP      NZ,ERROR3_EX      		; If this does not match, throw a "No FOR" error
0B13BA 45 
0B13BB 14 
0B13BC 0B 
0B13BD CD    0878** CALL    TERMQ			; Check for terminator (a NEXT without a variable)
0B13BE 44 
0B13BF 1B 
0B13C0 0B 
0B13C1 E1    0879** POP     HL			; Pop the address of the loop variable off the execution stack
0B13C2 E5    0880** PUSH    HL			; Push it back onto the execution stack
0B13C3 C5    0881** PUSH    BC			; Push the marker back onto the execution stack
0B13C4 E5    0882** PUSH    HL			; HL: Address of the loop variable off the stack
0B13C5 C4    0883** CALL    NZ,GETVAR       	; If there is no terminator, get the variable from the args
0B13C6 04 
0B13C7 3E 
0B13C8 0B 
0B13C9 D1    0884** POP     DE			; DE: Address of the loop variable off the stack
0B13CA EB    0885** EX      DE,HL			; HL: Address of the loop variable off the stack, DE: Address of the variable from args
0B13CB B7    0886** OR      A
0B13CC ED    0887** NEXT0:			SBC     HL,DE			; Compare to make sure that the variables match
0B13CD 52 
0B13CE 20    0888** JR      NZ,NEXT1		; They don't, so jump to NEXT1
0B13CF 61 
0B13D0 D5    0889** PUSH    DE
0B13D1 DD    0890** LD      IX,9+3			; IX: Address of the STEP value on the execution stack
0B13D2 21 
0B13D3 0C 
0B13D4 00 
0B13D4 00   
0B13D6 DD    0891** ADD     IX,SP
0B13D7 39 
0B13D8 CD    0892** CALL    DLOAD5_SPL      	; Load the STEP value
0B13D9 AB 
0B13DA 2D 
0B13DB 0B 
0B13DC DD    0893** LD      A,(IX+16)       	; Get the STEP type
0B13DD 7E 
0B13DE 10 
0B13DF DD    0894** POP     IX
0B13E0 E1 
0B13E1 CD    0895** CALL    LOADN           	; Load the LOOP variable
0B13E2 E0 
0B13E3 07 
0B13E4 0B 
0B13E5 CB    0896** BIT     7,D             	; Check the sign
0B13E6 7A 
0B13E7 F5    0897** PUSH    AF
0B13E8 3E    0898** LD      A,'+' & 0FH
0B13E9 0B 
0B13EA CD    0899** CALL    FPP             	; Add the STEP
0B13EB 34 
0B13EC 24 
0B13ED 0B 
0B13EE 38    0900** JR      C,ERROR3_EX
0B13EF 55 
0B13F0 F1    0901** POP     AF              	; Restore TYPE
0B13F1 F5    0902** PUSH    AF
0B13F2 CD    0903** CALL    STORE           	; Update the variable
0B13F3 A0 
0B13F4 19 
0B13F5 0B 
0B13F6 DD    0904** LD      IX,18+3			; IX: Address of the LIMIT value on the execution stack
0B13F7 21 
0B13F8 15 
0B13F9 00 
0B13F9 00   
0B13FB DD    0905** ADD     IX,SP
0B13FC 39 
0B13FD CD    0906** CALL    DLOAD5_SPL      	; Load the LIMIT value
0B13FE AB 
0B13FF 2D 
0B1400 0B 
0B1401 F1    0907** POP     AF
0B1402 CC    0908** CALL    Z,SWAP			; Swap the arguments if the sign is ?
0B1403 A1 
0B1404 0C 
0B1405 0B 
             0909** ; LD      A,0+('<'-4) & 0FH
0B1406 3E    0910** LD      A,0+'<'-4 & 0FH ; ez80asm doesn't do () in expressions
0B1407 08 
0B1408 CD    0911** CALL    FPP             	; Test against the limit
0B1409 34 
0B140A 24 
0B140B 0B 
0B140C 38    0912** JR      C,ERROR3_EX		; Throw an error if FPP returns bad
0B140D 37 
0B140E 24    0913** INC     H
0B140F 20    0914** JR      NZ,LOOP_        	; Keep looping
0B1410 14 
0B1411 21    0915** LD      HL,27			; Adjust the stack
0B1412 1B 
0B1413 00 
0B1414 00 
0B1415 39    0916** ADD     HL,SP
0B1416 F9    0917** LD      SP,HL
0B1417 CD    0918** CALL    NXT
0B1418 3A 
0B1419 0E 
0B141A 0B 
0B141B FE    0919** CP      ','			; Check for multiple variables
0B141C 2C 
0B141D C2    0920** JP      NZ,XEQ			; No, so we are done at ths point
0B141E 60 
0B141F 0F 
0B1420 0B 
0B1421 FD    0921** INC     IY			; Increment to the next variable
0B1422 23 
0B1423 18    0922** JR      NEXT_EX			; And continue
0B1424 8A 
             0923** ;
0B1425 C1    0924** LOOP_:			POP     BC
0B1426 D1    0925** POP     DE
0B1427 FD    0926** POP     IY
0B1428 E1 
0B1429 FD    0927** PUSH    IY
0B142A E5 
0B142B D5    0928** PUSH    DE
0B142C C5    0929** PUSH    BC
0B142D C3    0930** JP      XEQ
0B142E 60 
0B142F 0F 
0B1430 0B 
             0931** ;
0B1431 21    0932** NEXT1:			LD      HL,27			; TODO: What does this do?
0B1432 1B 
0B1433 00 
0B1434 00 
0B1435 39    0933** ADD     HL,SP
0B1436 F9    0934** LD      SP,HL			; Adjust the stack
0B1437 C1    0935** POP     BC
0B1438 21    0936** LD      HL,FORCHK
0B1439 AF 
0B143A 13 
0B143B 0B 
0B143C ED    0937** SBC     HL,BC
0B143D 42 
0B143E E1    0938** POP     HL              	; Variable pointer
0B143F E5    0939** PUSH    HL
0B1440 C5    0940** PUSH    BC
0B1441 28    0941** JR      Z,NEXT0
0B1442 89 
             0942** ;
0B1443 3E    0943** LD      A,33
0B1444 21 
0B1445 C3    0944** ERROR3_EX:			JP      ERROR_           	; Throw the error "Can't match FOR"
0B1446 2A 
0B1447 3B 
0B1448 0B 
             0945** 
             0946** ; FNname
             0947** ; N.B. ENTERED WITH A <> TON
             0948** ;
0B1449 F5    0949** FN_EX:			PUSH    AF              	; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5
0B144A CD    0950** CALL    PROC1
0B144B 53 
0B144C 14 
0B144D 0B 
             0951** FNCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
             0952** 
             0953** ; PROCname
             0954** ; N.B. ENTERED WITH A = ON PROC FLAG (EEh or the first character of the token name)
             0955** ; This pushes the following data onto the execution stack
             0956** ; - 3 bytes: The return address for ENDPROC (initially the ON PROC FLAG)
             0957** ; - 3 bytes: Marker (the address of PROCHK)
             0958** ;
0B144E F5    0959** PROC_EX:			PUSH    AF			; Push A onto the stack; this'll be checked for the token ON (TON) in PROC5,
0B144F CD    0960** CALL    PROC1			; and is also space reserved on the stack for the return address
0B1450 53 
0B1451 14 
0B1452 0B 
             0961** PROCHK:			EQU     $			; This will never fall through as PROC1 will do a JP XEQ
             0962** ;
0B1453 CD    0963** PROC1:			CALL    CHECK			; Check there is space for this
0B1454 19 
0B1455 1A 
0B1456 0B 
0B1457 FD    0964** DEC     IY			; Decrement IY to the PROC token
0B1458 2B 
0B1459 FD    0965** PUSH    IY			; Stack the pointer
0B145A E5 
0B145B CD    0966** CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B145C C5 
0B145D 3E 
0B145E 0B 
0B145F C1    0967** POP     BC			; BC = IY
0B1460 28    0968** JR      Z,PROC4			; If found in the dynamic area then skip to PROC4
0B1461 41 
0B1462 3E    0969** LD      A,30
0B1463 1E 
0B1464 38    0970** JR      C,ERROR3_EX        	; Throw error "Bad call" if invalid PROC/FN call
0B1465 DF 
             0971** ;
             0972** ; At this point the PROC/FN has not yet been registered in the dynamic area
             0973** ; So we need to search through the listing and find where the DEFPROC/FN is and save the address
             0974** ;
0B1466 C5    0975** PUSH    BC			; BC: Still pointing to the PROC token in the tokenised line
0B1467 2A    0976** LD      HL,(PAGE_)		; HL: Start of program memory
0B1468 14 
0B1469 51 
0B146A 0B 
             0977** ;
0B146B 3E    0978** PROC2:			LD      A,DEF_			;  A: The token to search for
0B146C DD 
0B146D CD    0979** CALL    SEARCH_EX          	; Look for "DEF" as the first token in a program line
0B146E 18 
0B146F 1C 
0B1470 0B 
0B1471 38    0980** JR      C,PROC3			; Not found, so jump to PROC3
0B1472 26 
0B1473 E5    0981** PUSH    HL			; HL: Points to the DEF token in the DEFPROC
0B1474 FD    0982** POP     IY			; IY = HL
0B1475 E1 
0B1476 FD    0983** INC     IY              	; Skip the DEF token
0B1477 23 
0B1478 CD    0984** CALL    NXT			; And any whitespace
0B1479 3A 
0B147A 0E 
0B147B 0B 
0B147C CD    0985** CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B147D C5 
0B147E 3E 
0B147F 0B 
0B1480 FD    0986** PUSH    IY
0B1481 E5 
0B1482 D1    0987** POP     DE			; DE: Points to the PROC/FN token in tokenised line of the DEFPROC
0B1483 38    0988** JR      C,PROC6			; Skip if there is an error (neither FN or PROC first)
0B1484 09 
0B1485 C4    0989** CALL    NZ,CREATE		; Create an entity in the dynamic area
0B1486 78 
0B1487 3F 
0B1488 0B 
0B1489 FD    0990** PUSH    IY			; IY: Pointer to the DEFPROC/FN arguments
0B148A E5 
0B148B D1    0991** POP     DE			; DE = IY
0B148C ED    0992** LD	(HL),DE			; Save address
0B148D 1F 
             0993** ;
0B148E EB    0994** PROC6:			EX      DE,HL			; HL: Address of the procedure
0B148F 3E    0995** LD      A,CR			; The character to search for
0B1490 0D 
0B1491 01    0996** LD	BC,100h			; Only need to search 256 bytes or so ahead; maximum line length
0B1492 00 
0B1493 01 
0B1494 00 
0B1495 ED    0997** CPIR                    	; Skip to next line
0B1496 B1 
0B1497 18    0998** JR      PROC2			; Rinse, lather and repeat
0B1498 D2 
             0999** ;
             1000** ; At this point a DEF has not been found for the PROC/FN
             1001** ;
0B1499 FD    1002** PROC3:			POP     IY              	; Restore the execution address
0B149A E1 
0B149B CD    1003** CALL    GETDEF			; Search for this PROC/FN entry in the dynamic area
0B149C C5 
0B149D 3E 
0B149E 0B 
0B149F 3E    1004** LD      A,29
0B14A0 1D 
0B14A1 20    1005** JR      NZ,ERROR3_EX      		; Throw error "No such FN/PROC" if not found
0B14A2 A2 
             1006** ;
             1007** ; At this point we have a PROC/FN entry in the dynamic area
             1008** ;
0B14A3 ED    1009** PROC4:			LD	DE,(HL)			; HL: Address of pointer; fetch entity address in DE
0B14A4 17 
0B14A5 21    1010** LD	HL,3
0B14A6 03 
0B14A7 00 
0B14A8 00 
0B14A9 39    1011** ADD     HL,SP
0B14AA CD    1012** CALL    NXT             	; Allow space before "("
0B14AB 3A 
0B14AC 0E 
0B14AD 0B 
0B14AE D5    1013** PUSH    DE              	; Exchange DE and IY
0B14AF FD    1014** EX      (SP),IY
0B14B0 E3 
0B14B1 FE    1015** CP      '('             	; Arguments?
0B14B2 28 
0B14B3 D1    1016** POP     DE			; NB: This has been moved after the compare otherwise DE gets corrupted later? IDK why!?!
0B14B4 20    1017** JR      NZ,PROC5
0B14B5 20 
0B14B6 CD    1018** CALL    NXT             	; Allow space before "("
0B14B7 3A 
0B14B8 0E 
0B14B9 0B 
0B14BA FE    1019** CP      '('
0B14BB 28 
0B14BC C2    1020** JP      NZ,SYNTAX       	; Throw "Syntax error"
0B14BD 61 
0B14BE 10 
0B14BF 0B 
0B14C0 FD    1021** PUSH    IY
0B14C1 E5 
0B14C2 C1    1022** POP     BC              	; Save IY in BC
0B14C3 D9    1023** EXX
0B14C4 CD    1024** CALL    SAVLOC          	; Save local parameters
0B14C5 C4 
0B14C6 1A 
0B14C7 0B 
0B14C8 CD    1025** CALL    BRAKET          	; Closing bracket
0B14C9 F9 
0B14CA 0D 
0B14CB 0B 
0B14CC D9    1026** EXX
0B14CD C5    1027** PUSH    BC
0B14CE FD    1028** POP     IY              	; Restore IY
0B14CF E1 
0B14D0 E5    1029** PUSH    HL
0B14D1 CD    1030** CALL    ARGUE           	; Transfer arguments
0B14D2 40 
0B14D3 1A 
0B14D4 0B 
0B14D5 E1    1031** POP     HL
             1032** ;
0B14D6 23    1033** PROC5:			INC	HL			; Increment to the ON PROC flag address
0B14D7 7E    1034** LD	A, (HL)			; And fetch the value
0B14D8 2B    1035** DEC 	HL
0B14D9 ED    1036** LD	(HL), DE		; Save the ENDPROC return address pointer in the BASIC listing
0B14DA 1F 
0B14DB FE    1037** CP	TON			; Was it "ON PROC"?
0B14DC EE 
0B14DD C2    1038** JP	NZ, XEQ			; No, so back to XEQ
0B14DE 60 
0B14DF 0F 
0B14E0 0B 
0B14E1 D5    1039** PUSH    DE			; Exchange DE and IY
0B14E2 FD    1040** EX      (SP),IY
0B14E3 E3 
0B14E4 CD    1041** CALL    SPAN            	; Skip rest of ON list
0B14E5 51 
0B14E6 1B 
0B14E7 0B 
0B14E8 FD    1042** EX      (SP),IY			; Exchange DE and IY
0B14E9 E3 
0B14EA D1    1043** POP     DE
0B14EB ED    1044** LD	(HL), DE		; Save the return address
0B14EC 1F 
0B14ED C3    1045** JP      XEQ
0B14EE 60 
0B14EF 0F 
0B14F0 0B 
             1046** 
             1047** ; LOCAL var[,var...]
             1048** ;
0B14F1 C1    1049** LOCAL_EX_:			POP     BC			; BC: The current check marker (on the stack)
0B14F2 C5    1050** PUSH    BC
0B14F3 21    1051** LD      HL,FNCHK		; Check if we are in a FN
0B14F4 4E 
0B14F5 14 
0B14F6 0B 
0B14F7 B7    1052** OR      A
0B14F8 ED    1053** SBC     HL,BC
0B14F9 42 
0B14FA 28    1054** JR      Z,LOCAL1		; Yes, so all good, we can use local
0B14FB 16 
0B14FC 21    1055** LD      HL,PROCHK		; Now check if we are in a PROC
0B14FD 53 
0B14FE 14 
0B14FF 0B 
0B1500 B7    1056** OR      A
0B1501 ED    1057** SBC     HL,BC
0B1502 42 
0B1503 28    1058** JR      Z,LOCAL1		; Again, all good, we can use local
0B1504 0D 
0B1505 21    1059** LD      HL,LOCCHK		; Finally check for the local parameters marker
0B1506 22 
0B1507 1B 
0B1508 0B 
0B1509 B7    1060** OR      A
0B150A ED    1061** SBC     HL,BC			; If it is not present, then
0B150B 42 
0B150C 3E    1062** LD      A,12
0B150D 0C 
0B150E C2    1063** JP      NZ,ERROR_        	; Then throw a "Not LOCAL" errr
0B150F 2A 
0B1510 3B 
0B1511 0B 
             1064** ;
             1065** ; At this point we are adding a local variable into a PROC or FN
             1066** ;
0B1512 FD    1067** LOCAL1:			PUSH    IY			; IY: BASIC pointer
0B1513 E5 
0B1514 C1    1068** POP     BC			; BC: Copy of the BASIC pointer
0B1515 D9    1069** EXX
0B1516 FD    1070** DEC     IY
0B1517 2B 
0B1518 CD    1071** CALL    SAVLOC
0B1519 C4 
0B151A 1A 
0B151B 0B 
0B151C D9    1072** EXX
0B151D C5    1073** PUSH    BC
0B151E FD    1074** POP     IY
0B151F E1 
             1075** ;
0B1520 CD    1076** LOCAL2:			CALL    GETVAR			; Get the variable location
0B1521 04 
0B1522 3E 
0B1523 0B 
0B1524 C2    1077** JP      NZ,SYNTAX
0B1525 61 
0B1526 10 
0B1527 0B 
0B1528 B7    1078** OR      A               	; Check the variable type (80h = string)
0B1529 08    1079** EX      AF,AF'
0B152A CD    1080** CALL    ZERO			; Zero the variable anyway
0B152B 5D 
0B152C 0D 
0B152D 0B 
0B152E 08    1081** EX      AF,AF'
0B152F F5    1082** PUSH    AF
0B1530 F4    1083** CALL    P,STORE         	; Call STORE if it is not a string
0B1531 A0 
0B1532 19 
0B1533 0B 
0B1534 F1    1084** POP     AF
0B1535 59    1085** LD      E,C
0B1536 FC    1086** CALL    M,STORES		; Call STORES if it is a string
0B1537 CE 
0B1538 19 
0B1539 0B 
0B153A CD    1087** CALL    NXT			; Skip to the next character in the expression
0B153B 3A 
0B153C 0E 
0B153D 0B 
0B153E FE    1088** CP      ','			; Is it a comma?
0B153F 2C 
0B1540 C2    1089** JP      NZ,XEQ			; No, so we're done, carry on executing
0B1541 60 
0B1542 0F 
0B1543 0B 
0B1544 FD    1090** INC     IY			; Yes, so skip the comma
0B1545 23 
0B1546 CD    1091** CALL    NXT			; And any whitespace
0B1547 3A 
0B1548 0E 
0B1549 0B 
0B154A 18    1092** JR      LOCAL2			; Then loop back and handle any further local variables
0B154B D4 
             1093** 
             1094** ; ENDPROC
             1095** ;
0B154C C1    1096** ENDPRO:			POP     BC			; Pop the check value off the stack
0B154D 21    1097** LD      HL,LOCCHK		; Check if it is the LOCAL Marker
0B154E 22 
0B154F 1B 
0B1550 0B 
0B1551 B7    1098** OR      A
0B1552 ED    1099** SBC     HL,BC
0B1553 42 
0B1554 28    1100** JR      Z,UNSTK         	; Yes, it is, so first need to unstack the local variables
0B1555 13 
             1101** ;
0B1556 21    1102** LD      HL,PROCHK       	; Check if it is the PROC marker
0B1557 53 
0B1558 14 
0B1559 0B 
0B155A B7    1103** OR      A
0B155B ED    1104** SBC     HL,BC
0B155C 42 
0B155D FD    1105** POP     IY
0B155E E1 
0B155F CA    1106** JP      Z,XEQ			; Yes, it is, so carry on, all is good
0B1560 60 
0B1561 0F 
0B1562 0B 
0B1563 3E    1107** LD      A,13			; Otherwise throw the "No PROC" error
0B1564 0D 
0B1565 C3    1108** JP      ERROR_
0B1566 2A 
0B1567 3B 
0B1568 0B 
             1109** ;
0B1569 DD    1110** UNSTK:			POP     IX			; Unstack a single local variable
0B156A E1 
0B156B C1    1111** POP     BC
0B156C 78    1112** LD      A,B
0B156D B7    1113** OR      A
0B156E FA    1114** JP      M,UNSTK1        	; Jump here if it is a string? (80h)
0B156F 7C 
0B1570 15 
0B1571 0B 
0B1572 E1    1115** POP     HL			; Unstack a normal variable
0B1573 D9    1116** EXX
0B1574 E1    1117** POP     HL
0B1575 D9    1118** EXX
0B1576 CD    1119** CALL    STORE			; TODO: Not sure why or where it is being stored at this point
0B1577 A0 
0B1578 19 
0B1579 0B 
0B157A 18    1120** JR      ENDPRO			; And loop back to ENDPRO
0B157B D0 
             1121** ;
0B157C 21    1122** UNSTK1:			LD      HL,0			; Unstack a string
0B157D 00 
0B157E 00 
0B157F 00 
0B1580 39    1123** ADD     HL,SP
0B1581 59    1124** LD      E,C
0B1582 CD    1125** CALL    STORES			; TODO: Not sure why or where it is being stored at this point
0B1583 CE 
0B1584 19 
0B1585 0B 
0B1586 F9    1126** LD      SP,HL
0B1587 18    1127** JR      ENDPRO
0B1588 C3 
             1128** 
             1129** ; INPUT #channel,var,var...
             1130** ;
0B1589 CD    1131** INPUTN:			CALL    CHNL            ;E = CHANNEL NUMBER
0B158A 5C 
0B158B 1C 
0B158C 0B 
0B158D CD    1132** INPN1:			CALL    NXT
0B158E 3A 
0B158F 0E 
0B1590 0B 
0B1591 FE    1133** CP      ','
0B1592 2C 
0B1593 C2    1134** JP      NZ,XEQ
0B1594 60 
0B1595 0F 
0B1596 0B 
0B1597 FD    1135** INC     IY
0B1598 23 
0B1599 CD    1136** CALL    NXT
0B159A 3A 
0B159B 0E 
0B159C 0B 
0B159D D5    1137** PUSH    DE
0B159E CD    1138** CALL    VAR_
0B159F 58 
0B15A0 10 
0B15A1 0B 
0B15A2 D1    1139** POP     DE
0B15A3 F5    1140** PUSH    AF              ;SAVE TYPE
0B15A4 E5    1141** PUSH    HL              ;VARPTR
0B15A5 B7    1142** OR      A
0B15A6 FA    1143** JP      M,INPN2         ;STRING
0B15A7 D2 
0B15A8 15 
0B15A9 0B 
0B15AA CD    1144** CALL    OSBGET
0B15AB FD 
0B15AC 46 
0B15AD 0B 
0B15AE D9    1145** EXX
0B15AF 6F    1146** LD      L,A
0B15B0 D9    1147** EXX
0B15B1 CD    1148** CALL    OSBGET
0B15B2 FD 
0B15B3 46 
0B15B4 0B 
0B15B5 D9    1149** EXX
0B15B6 67    1150** LD      H,A
0B15B7 D9    1151** EXX
0B15B8 CD    1152** CALL    OSBGET
0B15B9 FD 
0B15BA 46 
0B15BB 0B 
0B15BC 6F    1153** LD      L,A
0B15BD CD    1154** CALL    OSBGET
0B15BE FD 
0B15BF 46 
0B15C0 0B 
0B15C1 67    1155** LD      H,A
0B15C2 CD    1156** CALL    OSBGET
0B15C3 FD 
0B15C4 46 
0B15C5 0B 
0B15C6 4F    1157** LD      C,A
0B15C7 DD    1158** POP     IX
0B15C8 E1 
0B15C9 F1    1159** POP     AF              ;RESTORE TYPE
0B15CA D5    1160** PUSH    DE              ;SAVE CHANNEL
0B15CB CD    1161** CALL    STORE
0B15CC A0 
0B15CD 19 
0B15CE 0B 
0B15CF D1    1162** POP     DE
0B15D0 18    1163** JR      INPN1
0B15D1 BB 
0B15D2 21    1164** INPN2:			LD      HL,ACCS
0B15D3 00 
0B15D4 4E 
0B15D5 0B 
0B15D6 CD    1165** INPN3:			CALL    OSBGET
0B15D7 FD 
0B15D8 46 
0B15D9 0B 
0B15DA FE    1166** CP      CR
0B15DB 0D 
0B15DC 28    1167** JR      Z,INPN4
0B15DD 04 
0B15DE 77    1168** LD      (HL),A
0B15DF 2C    1169** INC     L
0B15E0 20    1170** JR      NZ,INPN3
0B15E1 F4 
0B15E2 DD    1171** INPN4:			POP     IX
0B15E3 E1 
0B15E4 F1    1172** POP     AF
0B15E5 D5    1173** PUSH    DE
0B15E6 EB    1174** EX      DE,HL
0B15E7 CD    1175** CALL    STACCS
0B15E8 CA 
0B15E9 19 
0B15EA 0B 
0B15EB D1    1176** POP     DE
0B15EC 18    1177** JR      INPN1
0B15ED 9F 
             1178** 
             1179** ; INPUT ['][SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
             1180** ; INPUT LINE [SPC(x)][TAB(x[,y])]["prompt",]var[,var...]
             1181** ;
0B15EE FE    1182** INPUT:			CP      '#'
0B15EF 23 
0B15F0 28    1183** JR      Z,INPUTN
0B15F1 97 
0B15F2 0E    1184** LD      C,0             ;FLAG PROMPT
0B15F3 00 
0B15F4 FE    1185** CP      LINE_EX_
0B15F5 86 
0B15F6 20    1186** JR      NZ,INPUT0
0B15F7 04 
0B15F8 FD    1187** INC     IY              ;SKIP "LINE"
0B15F9 23 
0B15FA 0E    1188** LD      C,80H
0B15FB 80 
0B15FC 21    1189** INPUT0:			LD      HL,BUFFER
0B15FD 00 
0B15FE 4F 
0B15FF 0B 
0B1600 36    1190** LD      (HL),CR         ;INITIALISE EMPTY
0B1601 0D 
0B1602 CD    1191** INPUT1:			CALL    TERMQ
0B1603 44 
0B1604 1B 
0B1605 0B 
0B1606 CA    1192** JP      Z,XEQ           ;DONE
0B1607 60 
0B1608 0F 
0B1609 0B 
0B160A FD    1193** INC     IY
0B160B 23 
0B160C FE    1194** CP      ','
0B160D 2C 
0B160E 28    1195** JR      Z,INPUT3        ;SKIP COMMA
0B160F 5C 
0B1610 FE    1196** CP      ';'
0B1611 3B 
0B1612 28    1197** JR      Z,INPUT3
0B1613 58 
0B1614 E5    1198** PUSH    HL              ;SAVE BUFFER POINTER
0B1615 FE    1199** CP      34		;ASCII ""
0B1616 22 
0B1617 20    1200** JR      NZ,INPUT6
0B1618 0C 
0B1619 C5    1201** PUSH    BC
0B161A CD    1202** CALL    CONS
0B161B 31 
0B161C 08 
0B161D 0B 
0B161E C1    1203** POP     BC
0B161F CD    1204** CALL    PTEXT           ;PRINT PROMPT
0B1620 C8 
0B1621 1B 
0B1622 0B 
0B1623 18    1205** JR      INPUT9
0B1624 06 
0B1625 CD    1206** INPUT6:			CALL    FORMAT          ;SPC, TAB, '
0B1626 69 
0B1627 1B 
0B1628 0B 
0B1629 20    1207** JR      NZ,INPUT2
0B162A 05 
0B162B E1    1208** INPUT9:			POP     HL
0B162C CB    1209** SET     0,C             ;FLAG NO PROMPT
0B162D C1 
0B162E 18    1210** JR      INPUT0
0B162F CC 
0B1630 FD    1211** INPUT2:			DEC     IY
0B1631 2B 
0B1632 C5    1212** PUSH    BC
0B1633 CD    1213** CALL    VAR_
0B1634 58 
0B1635 10 
0B1636 0B 
0B1637 C1    1214** POP     BC
0B1638 E1    1215** POP     HL
0B1639 F5    1216** PUSH    AF              ;SAVE TYPE
0B163A 7E    1217** LD      A,(HL)
0B163B 23    1218** INC     HL
0B163C FE    1219** CP      CR              ;BUFFER EMPTY?
0B163D 0D 
0B163E CC    1220** CALL    Z,REFILL
0B163F 70 
0B1640 16 
0B1641 0B 
0B1642 CB    1221** BIT     7,C
0B1643 79 
0B1644 F5    1222** PUSH    AF
0B1645 C4    1223** CALL    NZ,LINES
0B1646 EA 
0B1647 1B 
0B1648 0B 
0B1649 F1    1224** POP     AF
0B164A CC    1225** CALL    Z,FETCHS
0B164B D7 
0B164C 1B 
0B164D 0B 
0B164E F1    1226** POP     AF              ;RESTORE TYPE
0B164F C5    1227** PUSH    BC
0B1650 E5    1228** PUSH    HL
0B1651 B7    1229** OR      A
0B1652 FA    1230** JP      M,INPUT4        ;STRING
0B1653 66 
0B1654 16 
0B1655 0B 
0B1656 F5    1231** PUSH    AF
0B1657 DD    1232** PUSH    IX
0B1658 E5 
0B1659 CD    1233** CALL    VAL0
0B165A 38 
0B165B 0A 
0B165C 0B 
0B165D DD    1234** POP     IX
0B165E E1 
0B165F F1    1235** POP     AF
0B1660 CD    1236** CALL    STORE
0B1661 A0 
0B1662 19 
0B1663 0B 
0B1664 18    1237** JR      INPUT5
0B1665 04 
0B1666 CD    1238** INPUT4:			CALL    STACCS
0B1667 CA 
0B1668 19 
0B1669 0B 
0B166A E1    1239** INPUT5:			POP     HL
0B166B C1    1240** POP     BC
0B166C CB    1241** INPUT3:			RES     0,C
0B166D 81 
0B166E 18    1242** JR      INPUT1
0B166F 92 
             1243** ;
0B1670 CB    1244** REFILL:			BIT     0,C
0B1671 41 
0B1672 20    1245** JR      NZ,REFIL0       ;NO PROMPT
0B1673 0C 
0B1674 3E    1246** LD      A,'?'
0B1675 3F 
0B1676 CD    1247** CALL    OUTCHR          ;PROMPT
0B1677 19 
0B1678 3D 
0B1679 0B 
0B167A 3E    1248** LD      A,' '
0B167B 20 
0B167C CD    1249** CALL    OUTCHR
0B167D 19 
0B167E 3D 
0B167F 0B 
0B1680 21    1250** REFIL0:			LD      HL,BUFFER
0B1681 00 
0B1682 4F 
0B1683 0B 
0B1684 C5    1251** PUSH    BC
0B1685 E5    1252** PUSH    HL
0B1686 DD    1253** PUSH    IX
0B1687 E5 
0B1688 CD    1254** CALL    OSLINE
0B1689 29 
0B168A 42 
0B168B 0B 
0B168C DD    1255** POP     IX
0B168D E1 
0B168E E1    1256** POP     HL
0B168F C1    1257** POP     BC
0B1690 47    1258** LD      B,A             ;POS AT ENTRY
0B1691 AF    1259** XOR     A
0B1692 32    1260** LD      (COUNT),A
0B1693 3D 
0B1694 51 
0B1695 0B 
0B1696 B8    1261** CP      B
0B1697 C8    1262** RET     Z
0B1698 7E    1263** REFIL1:			LD      A,(HL)
0B1699 FE    1264** CP      CR
0B169A 0D 
0B169B C8    1265** RET     Z
0B169C 23    1266** INC     HL
0B169D 10    1267** DJNZ    REFIL1
0B169E F9 
0B169F C9    1268** RET
             1269** 
             1270** ; READ var[,var...]
             1271** ;
0B16A0 FE    1272** READ:			CP      '#'
0B16A1 23 
0B16A2 CA    1273** JP      Z,INPUTN
0B16A3 89 
0B16A4 15 
0B16A5 0B 
0B16A6 2A    1274** LD      HL,(DATPTR)
0B16A7 31 
0B16A8 51 
0B16A9 0B 
0B16AA 7E    1275** READ0:			LD      A,(HL)
0B16AB 23    1276** INC     HL              ;SKIP COMMA OR "DATA"
0B16AC FE    1277** CP      CR              ;END OF DATA STMT?
0B16AD 0D 
0B16AE CC    1278** CALL    Z,GETDAT
0B16AF F2 
0B16B0 16 
0B16B1 0B 
0B16B2 E5    1279** PUSH    HL
0B16B3 CD    1280** CALL    VAR_
0B16B4 58 
0B16B5 10 
0B16B6 0B 
0B16B7 E1    1281** POP     HL
0B16B8 B7    1282** OR      A
0B16B9 FA    1283** JP      M,READ1         ;STRING
0B16BA D2 
0B16BB 16 
0B16BC 0B 
0B16BD E5    1284** PUSH    HL
0B16BE FD    1285** EX      (SP),IY
0B16BF E3 
0B16C0 F5    1286** PUSH    AF              ;SAVE TYPE
0B16C1 DD    1287** PUSH    IX
0B16C2 E5 
0B16C3 CD    1288** CALL    EXPRN
0B16C4 CC 
0B16C5 06 
0B16C6 0B 
0B16C7 DD    1289** POP     IX
0B16C8 E1 
0B16C9 F1    1290** POP     AF
0B16CA CD    1291** CALL    STORE
0B16CB A0 
0B16CC 19 
0B16CD 0B 
0B16CE FD    1292** EX      (SP),IY
0B16CF E3 
0B16D0 18    1293** JR      READ2
0B16D1 09 
0B16D2 CD    1294** READ1:			CALL    FETCHS
0B16D3 D7 
0B16D4 1B 
0B16D5 0B 
0B16D6 E5    1295** PUSH    HL
0B16D7 CD    1296** CALL    STACCS
0B16D8 CA 
0B16D9 19 
0B16DA 0B 
0B16DB E1    1297** READ2:			POP     HL
0B16DC 22    1298** LD      (DATPTR),HL
0B16DD 31 
0B16DE 51 
0B16DF 0B 
0B16E0 CD    1299** CALL    NXT
0B16E1 3A 
0B16E2 0E 
0B16E3 0B 
0B16E4 FE    1300** CP      ','
0B16E5 2C 
0B16E6 C2    1301** JP      NZ,XEQ
0B16E7 60 
0B16E8 0F 
0B16E9 0B 
0B16EA FD    1302** INC     IY
0B16EB 23 
0B16EC CD    1303** CALL    NXT
0B16ED 3A 
0B16EE 0E 
0B16EF 0B 
0B16F0 18    1304** JR      READ0
0B16F1 B8 
             1305** ;
0B16F2 3E    1306** GETDAT:			LD      A,DATA_EX_
0B16F3 DC 
0B16F4 CD    1307** CALL    SEARCH_EX
0B16F5 18 
0B16F6 1C 
0B16F7 0B 
0B16F8 23    1308** INC     HL
0B16F9 D0    1309** RET     NC
0B16FA 3E    1310** LD      A,42
0B16FB 2A 
0B16FC C3    1311** ERROR4:			JP      ERROR_           ;"Out of DATA"
0B16FD 2A 
0B16FE 3B 
0B16FF 0B 
             1312** 
             1313** ; IF expr statement
             1314** ; IF expr THEN statement [ELSE statement]
             1315** ; IF expr THEN line [ELSE line]
             1316** ;
0B1700 CD    1317** IF_:			CALL    EXPRI
0B1701 D4 
0B1702 06 
0B1703 0B 
0B1704 CD    1318** CALL    TEST
0B1705 A9 
0B1706 0C 
0B1707 0B 
0B1708 28    1319** JR      Z,IFNOT         ;FALSE
0B1709 19 
0B170A FD    1320** LD      A,(IY)
0B170B 7E 
0B170C 00 
0B170D FE    1321** CP      THEN_EX_
0B170E 8C 
0B170F C2    1322** JP      NZ,XEQ
0B1710 60 
0B1711 0F 
0B1712 0B 
0B1713 FD    1323** INC     IY              ;SKIP "THEN"
0B1714 23 
0B1715 CD    1324** IF1:			CALL    NXT
0B1716 3A 
0B1717 0E 
0B1718 0B 
0B1719 FE    1325** CP      LINO_EX
0B171A 8D 
0B171B C2    1326** JP      NZ,XEQ          ;STATEMENT FOLLOWS
0B171C 60 
0B171D 0F 
0B171E 0B 
0B171F C3    1327** JP      GOTO_EX            ;LINE NO. FOLLOWS
0B1720 F5 
0B1721 12 
0B1722 0B 
0B1723 FD    1328** IFNOT:			LD      A,(IY)
0B1724 7E 
0B1725 00 
0B1726 FE    1329** CP      CR
0B1727 0D 
0B1728 FD    1330** INC     IY
0B1729 23 
0B172A CA    1331** JP      Z,XEQ0          ;END OF LINE
0B172B 5C 
0B172C 0F 
0B172D 0B 
0B172E FE    1332** CP      ELSE_EX_
0B172F 8B 
0B1730 20    1333** JR      NZ,IFNOT
0B1731 F1 
0B1732 18    1334** JR      IF1
0B1733 E1 
             1335** 
             1336** ; CLS
             1337** ;
0B1734 CD    1338** CLS:		CALL    CLRSCN
0B1735 96 
0B1736 47 
0B1737 0B 
0B1738 AF    1339** XOR     A
0B1739 32    1340** LD      (COUNT),A
0B173A 3D 
0B173B 51 
0B173C 0B 
0B173D C3    1341** JP      XEQ
0B173E 60 
0B173F 0F 
0B1740 0B 
             1342** 
             1343** ; STOP
             1344** ;
0B1741 CD    1345** STOP:			CALL    TELL
0B1742 5A 
0B1743 41 
0B1744 0B 
0B1745 0D    1346** DB	CR
0B1746 0A    1347** DB	LF
0B1747 FA    1348** DB	TSTOP
0B1748 00    1349** DB	0
0B1749 CD    1350** CALL    SETLIN          ;FIND CURRENT LINE
0B174A 78 
0B174B 3D 
0B174C 0B 
0B174D CD    1351** CALL    SAYLN
0B174E AC 
0B174F 3D 
0B1750 0B 
0B1751 CD    1352** CALL    CRLF
0B1752 11 
0B1753 3D 
0B1754 0B 
0B1755 C3    1353** JP      CLOOP
0B1756 4A 
0B1757 34 
0B1758 0B 
             1354** 
             1355** ; REPORT
             1356** ;
0B1759 CD    1357** REPOR:			CALL    REPORT
0B175A 4C 
0B175B 41 
0B175C 0B 
0B175D C3    1358** JP      XEQ
0B175E 60 
0B175F 0F 
0B1760 0B 
             1359** 
             1360** ; CLEAR
             1361** ;
0B1761 CD    1362** CLR:			CALL    CLEAR
0B1762 40 
0B1763 3C 
0B1764 0B 
0B1765 2A    1363** LD      HL,(PAGE_)
0B1766 14 
0B1767 51 
0B1768 0B 
0B1769 18    1364** JR      RESTR1
0B176A 19 
             1365** 
             1366** ; RESTORE [line]
             1367** ;
0B176B 2A    1368** RESTOR_EX:			LD      HL,(PAGE_)
0B176C 14 
0B176D 51 
0B176E 0B 
0B176F CD    1369** CALL    TERMQ
0B1770 44 
0B1771 1B 
0B1772 0B 
0B1773 28    1370** JR      Z,RESTR1
0B1774 0F 
0B1775 CD    1371** CALL    ITEMI
0B1776 EF 
0B1777 06 
0B1778 0B 
0B1779 D9    1372** EXX
0B177A CD    1373** CALL    FINDL           ;SEARCH FOR LINE
0B177B 59 
0B177C 3D 
0B177D 0B 
0B177E 3E    1374** LD      A,41
0B177F 29 
0B1780 C2    1375** JP      NZ,ERROR4       ;"No such line"
0B1781 FC 
0B1782 16 
0B1783 0B 
0B1784 3E    1376** RESTR1:			LD      A,DATA_EX_
0B1785 DC 
0B1786 CD    1377** CALL    SEARCH_EX
0B1787 18 
0B1788 1C 
0B1789 0B 
0B178A 22    1378** LD      (DATPTR),HL
0B178B 31 
0B178C 51 
0B178D 0B 
0B178E C3    1379** JP      XEQ
0B178F 60 
0B1790 0F 
0B1791 0B 
             1380** 
             1381** ; PTR#channel=expr
             1382** ; PAGE=expr
             1383** ; TIME=expr
             1384** ; LOMEM=expr
             1385** ; HIMEM=expr
             1386** ;
0B1792 CD    1387** PTR_EX:			CALL    CHANEL
0B1793 50 
0B1794 1C 
0B1795 0B 
0B1796 CD    1388** CALL    EQUALS
0B1797 5A 
0B1798 1B 
0B1799 0B 
0B179A 7B    1389** LD      A,E
0B179B F5    1390** PUSH    AF
0B179C CD    1391** CALL    EXPRI
0B179D D4 
0B179E 06 
0B179F 0B 
0B17A0 E5    1392** PUSH    HL
0B17A1 D9    1393** EXX
0B17A2 D1    1394** POP     DE
0B17A3 F1    1395** POP     AF
0B17A4 CD    1396** CALL    PUTPTR
0B17A5 31 
0B17A6 47 
0B17A7 0B 
0B17A8 C3    1397** JP      XEQ
0B17A9 60 
0B17AA 0F 
0B17AB 0B 
             1398** ;
0B17AC CD    1399** PAGEV_EX:			CALL    EQUALS
0B17AD 5A 
0B17AE 1B 
0B17AF 0B 
0B17B0 CD    1400** CALL    EXPRI
0B17B1 D4 
0B17B2 06 
0B17B3 0B 
0B17B4 D9    1401** EXX
0B17B5 2E    1402** LD      L,0
0B17B6 00 
0B17B7 22    1403** LD      (PAGE_),HL
0B17B8 14 
0B17B9 51 
0B17BA 0B 
0B17BB C3    1404** JP      XEQ
0B17BC 60 
0B17BD 0F 
0B17BE 0B 
             1405** ;
0B17BF FE    1406** TIMEV_EX:			CP      '$'
0B17C0 24 
0B17C1 28    1407** JR      Z,TIMEVS_EX
0B17C2 13 
0B17C3 CD    1408** CALL    EQUALS
0B17C4 5A 
0B17C5 1B 
0B17C6 0B 
0B17C7 CD    1409** CALL    EXPRI
0B17C8 D4 
0B17C9 06 
0B17CA 0B 
0B17CB E5    1410** PUSH    HL
0B17CC D9    1411** EXX
0B17CD D1    1412** POP     DE
0B17CE CD    1413** CALL    PUTIME
0B17CF 61 
0B17D0 42 
0B17D1 0B 
0B17D2 C3    1414** JP      XEQ
0B17D3 60 
0B17D4 0F 
0B17D5 0B 
             1415** ;
0B17D6 FD    1416** TIMEVS_EX:			INC     IY              ;SKIP '$'
0B17D7 23 
0B17D8 CD    1417** CALL    EQUALS
0B17D9 5A 
0B17DA 1B 
0B17DB 0B 
0B17DC CD    1418** CALL    EXPRS
0B17DD DF 
0B17DE 06 
0B17DF 0B 
0B17E0 CD    1419** CALL    PUTIMS
0B17E1 81 
0B17E2 47 
0B17E3 0B 
0B17E4 C3    1420** JP      XEQ
0B17E5 60 
0B17E6 0F 
0B17E7 0B 
             1421** ;
0B17E8 CD    1422** LOMEMV_EX:			CALL    EQUALS
0B17E9 5A 
0B17EA 1B 
0B17EB 0B 
0B17EC CD    1423** CALL    EXPRI
0B17ED D4 
0B17EE 06 
0B17EF 0B 
0B17F0 CD    1424** CALL    CLEAR
0B17F1 40 
0B17F2 3C 
0B17F3 0B 
0B17F4 D9    1425** EXX
0B17F5 22    1426** LD      (LOMEM),HL
0B17F6 1A 
0B17F7 51 
0B17F8 0B 
0B17F9 22    1427** LD      (FREE),HL
0B17FA 1D 
0B17FB 51 
0B17FC 0B 
0B17FD C3    1428** JP      XEQ
0B17FE 60 
0B17FF 0F 
0B1800 0B 
             1429** ;
0B1801 CD    1430** HIMEMV_EX:			CALL    EQUALS			; Check for '=' and throw an error if not found
0B1802 5A 
0B1803 1B 
0B1804 0B 
0B1805 CD    1431** CALL    EXPRI			; Load the expression into registers
0B1806 D4 
0B1807 06 
0B1808 0B 
             1432** ; BEGIN MISSING FROM BINARY
             1433** ; LD	A,L			;  A: The MSB of the 24-bit value
             1434** ; EXX				; HL: The LSW of the 24-bit value
             1435** ; LD	(R0),HL
             1436** ; LD	(R0+2),A
             1437** ; LD	HL,(FREE)
             1438** ; LD      DE,256
             1439** ; ADD	HL,DE
             1440** ; EX	DE,HL			; DE: FREE + 256
             1441** ; LD	HL,(R0)			; HL: The passed expression
             1442** ; END MISSING FROM BINARY
             1443** ; BEGIN ADDED FROM BINARY
0B1809 D9    1444** exx
0B180A ED    1445** ld de,(FREE)
0B180B 5B 
0B180C 1D 
0B180D 51 
0B180D 0B   
0B180F 14    1446** inc d
             1447** ; END ADDED FROM BINARY
0B1810 AF    1448** XOR     A
0B1811 ED    1449** SBC     HL,DE
0B1812 52 
0B1813 19    1450** ADD     HL,DE			; Do a bounds check
0B1814 DA    1451** JP      C,ERROR_         	; Throw the error: "No room"
0B1815 2A 
0B1816 3B 
0B1817 0B 
0B1818 ED    1452** LD      DE,(HIMEM)
0B1819 5B 
0B181A 20 
0B181B 51 
0B181B 0B   
0B181D 22    1453** LD      (HIMEM),HL
0B181E 20 
0B181F 51 
0B1820 0B 
0B1821 EB    1454** EX      DE,HL
0B1822 ED    1455** SBC     HL,SP			; Adjust the stack
0B1823 72 
0B1824 C2    1456** JP      NZ,XEQ
0B1825 60 
0B1826 0F 
0B1827 0B 
0B1828 EB    1457** EX      DE,HL
0B1829 F9    1458** LD      SP,HL           	; Load the SP
0B182A C3    1459** JP      XEQ
0B182B 60 
0B182C 0F 
0B182D 0B 
             1460** 
             1461** ; WIDTH expr
             1462** ;
0B182E CD    1463** WIDTHV:			CALL    EXPRI
0B182F D4 
0B1830 06 
0B1831 0B 
0B1832 D9    1464** EXX
0B1833 7D    1465** LD      A,L
0B1834 32    1466** LD      (WIDTH),A
0B1835 3E 
0B1836 51 
0B1837 0B 
0B1838 C3    1467** JP      XEQ
0B1839 60 
0B183A 0F 
0B183B 0B 
             1468** 
             1469** ; TRACE ON
             1470** ; TRACE OFF
             1471** ; TRACE line
             1472** ;
0B183C FD    1473** TRACE_EX:			INC     IY
0B183D 23 
0B183E 21    1474** LD      HL,0
0B183F 00 
0B1840 00 
0B1841 00 
0B1842 FE    1475** CP      TON
0B1843 EE 
0B1844 28    1476** JR      Z,TRACE0
0B1845 0B 
0B1846 FE    1477** CP      OFF_
0B1847 87 
0B1848 28    1478** JR      Z,TRACE1
0B1849 08 
0B184A FD    1479** DEC     IY
0B184B 2B 
0B184C CD    1480** CALL    EXPRI
0B184D D4 
0B184E 06 
0B184F 0B 
0B1850 D9    1481** EXX
0B1851 2B    1482** TRACE0:			DEC     HL
0B1852 22    1483** TRACE1:			LD      (TRACEN),HL
0B1853 26 
0B1854 51 
0B1855 0B 
0B1856 C3    1484** JP      XEQ
0B1857 60 
0B1858 0F 
0B1859 0B 
             1485** 
             1486** ; VDU expr,expr;....
             1487** ;
             1488** ; BEGIN MISSING FROM BINARY
             1489** ; VDU:			LD	IX,BUFFER		; Storage for the VDU stream
             1490** ; VDU1:			PUSH	IX
             1491** ; 			CALL    EXPRI			; Fetch the VDU character
             1492** ; 			POP	IX
             1493** ; 			EXX
             1494** ; 			LD	(IX+0),L		; Write out the character to the buffer
             1495** ; 			INC	IX
             1496** ; 			LD      A,(IY)			;  A: The separator character
             1497** ; 			CP      ','			; Is it a comma?
             1498** ; 			JR      Z,VDU2			; Yes, so it's a byte value - skip to next expression
             1499** ; 			CP      ';'			; Is it a semicolon?
             1500** ; 			JR      NZ,VDU3			; No, so skip to the next expression
             1501** ; 			LD	(IX+0),H		; Write out the high byte to the buffer
             1502** ; 			INC	IX
             1503** ; VDU2:			INC     IY			; Skip to the next character
             1504** ; VDU3:			CALL    TERMQ			; Skip past white space
             1505** ; 			JR      NZ,VDU1			; Loop unti reached end of the VDU command
             1506** ; 			LD	A,IXL			;  A: Number of bytes to write out
             1507** ; 			OR	A
             1508** ; 			JR 	Z,VDU4			; No bytes to write, so skip the next bit
             1509** ; 			LD	HL,BUFFER		; HL: Start of stream
             1510** ; 			LD	BC,0
             1511** ; 			LD	C,A			; BC: Number of bytes to write out
             1512** ; 			RST.LIL	18h			; Output the buffer to MOS
             1513** ; END MISSING FROM BINARY
             1514** ; BEGIN ADDED FROM BINARY
             1515** VDU:
0B185A CD    1516** call EXPRI
0B185B D4 
0B185C 06 
0B185D 0B 
0B185E D9    1517** exx
0B185F 7D    1518** ld a,l
0B1860 CD    1519** call OSWRCH
0B1861 CA 
0B1862 42 
0B1863 0B 
0B1864 FD    1520** ld a,(iy)
0B1865 7E 
0B1866 00 
0B1867 FE    1521** cp $2c
0B1868 2C 
0B1869 28    1522** jr z,$+$0b
0B186A 09 
0B186B FE    1523** cp $3b
0B186C 3B 
0B186D 20    1524** jr nz,$+$09
0B186E 07 
0B186F 7C    1525** ld a,h
0B1870 CD    1526** call OSWRCH
0B1871 CA 
0B1872 42 
0B1873 0B 
0B1874 FD    1527** inc iy
0B1875 23 
0B1876 CD    1528** call TERMQ
0B1877 44 
0B1878 1B 
0B1879 0B 
0B187A 20    1529** jr nz,$-$20
0B187B DE 
             1530** ; END ADDED FROM BINARY
0B187C C3    1531** VDU4:			JP      XEQ
0B187D 60 
0B187E 0F 
0B187F 0B 
             1532** 
             1533** ; CLOSE channel number
             1534** ;
0B1880 CD    1535** CLOSE:			CALL    CHANEL			; Fetch the channel number
0B1881 50 
0B1882 1C 
0B1883 0B 
0B1884 CD    1536** CALL    OSSHUT			; Close the channel
0B1885 F5 
0B1886 46 
0B1887 0B 
0B1888 C3    1537** JP      XEQ
0B1889 60 
0B188A 0F 
0B188B 0B 
             1538** 
             1539** ; BPUT channel,byte
             1540** ;
0B188C CD    1541** BPUT:			CALL    CHANEL          	; Fetch the channel number
0B188D 50 
0B188E 1C 
0B188F 0B 
0B1890 D5    1542** PUSH    DE			; DE: Channel number
0B1891 CD    1543** CALL    COMMA			; Skip to the next expression
0B1892 EC 
0B1893 0D 
0B1894 0B 
0B1895 CD    1544** CALL    EXPRI           	; Feth the data
0B1896 D4 
0B1897 06 
0B1898 0B 
0B1899 D9    1545** EXX
0B189A 7D    1546** LD      A,L			; A: The byte to write
0B189B D1    1547** POP     DE
0B189C CD    1548** CALL    OSBPUT			; Write the byte out
0B189D 05 
0B189E 47 
0B189F 0B 
0B18A0 C3    1549** JP      XEQ
0B18A1 60 
0B18A2 0F 
0B18A3 0B 
             1550** 
             1551** ; CALL address[,var[,var...]]
             1552** ;
             1553** ; Note that the parameter table differs from the Z80 version
             1554** ; Each entry now takes up 4 bytes, not 3, so the table is now:
             1555** ;  -1 byte:  Number of parameters
             1556** ; Then, for each parameter:
             1557** ;  -1 byte:  Parameter type (00h: byte, 04h: word, 05h: real, 80h: fixed string, 81h: dynamic string)
             1558** ;  -3 bytes: Parameter address
             1559** ;
             1560** ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/bbckey1.html#callparms for more information
             1561** ;
0B18A4 CD    1562** CALL_:			CALL    EXPRI           	; Fetch the address
0B18A5 D4 
0B18A6 06 
0B18A7 0B 
0B18A8 7D    1563** LD	A,L			;  A: MSB of address
0B18A9 D9    1564** EXX
0B18AA 22    1565** LD	(R0+0),HL		; HL: LSW of address
0B18AB 4A 
0B18AC 51 
0B18AD 0B 
0B18AE 32    1566** LD	(R0+2),A
0B18AF 4C 
0B18B0 51 
0B18B1 0B 
0B18B2 06    1567** LD      B,0             	;  B: The parameter counter
0B18B3 00 
0B18B4 11    1568** LD      DE,BUFFER       	; DE: Vector
0B18B5 00 
0B18B6 4F 
0B18B7 0B 
             1569** ;
0B18B8 CD    1570** CALL1:			CALL    NXT			; Skip whitespace
0B18B9 3A 
0B18BA 0E 
0B18BB 0B 
0B18BC FE    1571** CP      ','			; Check for comma
0B18BD 2C 
0B18BE 20    1572** JR      NZ,CALL2		; If no more parameters, then jump here
0B18BF 1B 
0B18C0 FD    1573** INC     IY			; Skip to the next character
0B18C1 23 
0B18C2 04    1574** INC     B			; Increment the parameter count
0B18C3 CD    1575** CALL    NXT			; Skip whitespace
0B18C4 3A 
0B18C5 0E 
0B18C6 0B 
0B18C7 C5    1576** PUSH    BC
0B18C8 D5    1577** PUSH    DE
0B18C9 CD    1578** CALL    VAR_
0B18CA 58 
0B18CB 10 
0B18CC 0B 
0B18CD D1    1579** POP     DE
0B18CE C1    1580** POP     BC
0B18CF 13    1581** INC     DE
0B18D0 12    1582** LD      (DE),A			; Save the parameter type
0B18D1 13    1583** INC     DE
0B18D2 EB    1584** EX      DE,HL
0B18D3 ED    1585** LD	(HL),DE			; Save the parameter address (3 bytes)
0B18D4 1F 
0B18D5 23    1586** INC	HL
0B18D6 23    1587** INC	HL
0B18D7 23    1588** INC	HL
0B18D8 EB    1589** EX      DE,HL
0B18D9 18    1590** JR      CALL1
0B18DA DD 
             1591** ;
0B18DB 78    1592** CALL2:			LD      A,B
0B18DC 32    1593** LD      (BUFFER),A      	; Save the parameter count
0B18DD 00 
0B18DE 4F 
0B18DF 0B 
0B18E0 2A    1594** LD	HL,(R0)			; HL: Address of the code
0B18E1 4A 
0B18E2 51 
0B18E3 0B 
0B18E4 CD    1595** CALL    USR1			; And call it
0B18E5 FE 
0B18E6 18 
0B18E7 0B 
0B18E8 C3    1596** JP      XEQ
0B18E9 60 
0B18EA 0F 
0B18EB 0B 
             1597** 
             1598** ; USR(address)
             1599** ;
0B18EC CD    1600** USR:			CALL    ITEMI			; Evaluate the expression
0B18ED EF 
0B18EE 06 
0B18EF 0B 
0B18F0 7D    1601** LD	A,L			;  A: MSB of address
0B18F1 D9    1602** EXX
0B18F2 22    1603** LD	(R0+0),HL		; HL: LSW of address
0B18F3 4A 
0B18F4 51 
0B18F5 0B 
0B18F6 32    1604** LD	(R0+2),A
0B18F7 4C 
0B18F8 51 
0B18F9 0B 
0B18FA 2A    1605** LD	HL,(R0)			; Get the 24-bit address in HL
0B18FB 4A 
0B18FC 51 
0B18FD 0B 
             1606** ;
0B18FE E5    1607** USR1:			PUSH    HL              	; Address on stack
0B18FF FD    1608** EX      (SP),IY
0B1900 E3 
0B1901 24    1609** INC     H               	; Check for PAGE &00FFxx
0B1902 B4    1610** OR	H
0B1903 21    1611** LD      HL,USR2         	; Return address
0B1904 6D 
0B1905 19 
0B1906 0B 
0B1907 E5    1612** PUSH    HL
0B1908 DD    1613** LD      IX,STAVAR
0B1909 21 
0B190A 00 
0B190B 50 
0B190B 0B   
0B190D CC    1614** CALL    Z,OSCALL        	; Intercept &00FFxx
0B190E BB 
0B190F 46 
0B1910 0B 
             1615** ;
0B1911 DD    1616** LD      C, (IX+24)		; F%
0B1912 4E 
0B1913 18 
0B1914 C5    1617** PUSH    BC
             1618** ;
0B1915 DD    1619** LD	A, (IX+8)		; B% -> MSW
0B1916 7E 
0B1917 08 
0B1918 32    1620** LD	(R0+1), A
0B1919 4B 
0B191A 51 
0B191B 0B 
0B191C DD    1621** LD	A, (IX+9)
0B191D 7E 
0B191E 09 
0B191F 32    1622** LD	(R0+2), A
0B1920 4C 
0B1921 51 
0B1922 0B 
0B1923 DD    1623** LD	A, (IX+12)		; C% -> LSB
0B1924 7E 
0B1925 0C 
0B1926 32    1624** LD	(R0+0), A
0B1927 4A 
0B1928 51 
0B1929 0B 
0B192A ED    1625** LD	BC, (R0)
0B192B 4B 
0B192C 4A 
0B192D 51 
0B192D 0B   
             1626** ;
0B192F DD    1627** LD	A, (IX+16)		; D% -> MSW
0B1930 7E 
0B1931 10 
0B1932 32    1628** LD	(R0+1), A
0B1933 4B 
0B1934 51 
0B1935 0B 
0B1936 DD    1629** LD	A, (IX+17)
0B1937 7E 
0B1938 11 
0B1939 32    1630** LD	(R0+2), A
0B193A 4C 
0B193B 51 
0B193C 0B 
0B193D DD    1631** LD	A, (IX+20)		; E% -> LSB
0B193E 7E 
0B193F 14 
0B1940 32    1632** LD	(R0+0), A
0B1941 4A 
0B1942 51 
0B1943 0B 
0B1944 ED    1633** LD	DE, (R0)
0B1945 5B 
0B1946 4A 
0B1947 51 
0B1947 0B   
             1634** ;
0B1949 DD    1635** LD	A, (IX+32)		; H% -> MSW
0B194A 7E 
0B194B 20 
0B194C 32    1636** LD	(R0+1), A
0B194D 4B 
0B194E 51 
0B194F 0B 
0B1950 DD    1637** LD	A, (IX+33)
0B1951 7E 
0B1952 21 
0B1953 32    1638** LD	(R0+2), A
0B1954 4C 
0B1955 51 
0B1956 0B 
0B1957 DD    1639** LD	A, (IX+48)		; L% -> LSB
0B1958 7E 
0B1959 30 
0B195A 32    1640** LD	(R0+0), A
0B195B 4A 
0B195C 51 
0B195D 0B 
0B195E 2A    1641** LD	HL, (R0)
0B195F 4A 
0B1960 51 
0B1961 0B 
             1642** ;
0B1962 F1    1643** POP     AF			; F%
0B1963 DD    1644** LD      A, (IX+4)        	; A%
0B1964 7E 
0B1965 04 
             1645** 
0B1966 DD    1646** LD      IX,BUFFER
0B1967 21 
0B1968 00 
0B1969 4F 
0B1969 0B   
0B196B FD    1647** JP      (IY)            	; Off to user routine
0B196C E9 
             1648** ;
0B196D FD    1649** USR2:			POP     IY
0B196E E1 
0B196F AF    1650** XOR     A
0B1970 4F    1651** LD      C,A
0B1971 C9    1652** RET
             1653** 
             1654** ; PUT port,data
             1655** ;
0B1972 CD    1656** PUT:			CALL    EXPRI           ;PORT ADDRESS
0B1973 D4 
0B1974 06 
0B1975 0B 
0B1976 D9    1657** EXX
0B1977 E5    1658** PUSH    HL
0B1978 CD    1659** CALL    COMMA
0B1979 EC 
0B197A 0D 
0B197B 0B 
0B197C CD    1660** CALL    EXPRI           ;DATA
0B197D D4 
0B197E 06 
0B197F 0B 
0B1980 D9    1661** EXX
0B1981 C1    1662** POP     BC
0B1982 ED    1663** OUT     (C),L           ;OUTPUT TO PORT BC
0B1983 69 
0B1984 C3    1664** JP      XEQ
0B1985 60 
0B1986 0F 
0B1987 0B 
             1665** 
             1666** ; SUBROUTINES -----------------------------------------------------------------
             1667** 
             1668** ; ASSIGN - Assign a numeric value to a variable.
             1669** ; Outputs: NC,  Z - OK, numeric.
             1670** ;          NC, NZ - OK, string.
             1671** ;           C, NZ - illegal
             1672** ;
0B1988 CD    1673** ASSIGN:			CALL    GETVAR          	; Try to get the variable
0B1989 04 
0B198A 3E 
0B198B 0B 
0B198C D8    1674** RET     C               	; Return with C if it is an illegal variable
0B198D C4    1675** CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0B198E F3 
0B198F 3D 
0B1990 0B 
0B1991 B7    1676** OR      A
0B1992 F8    1677** RET     M               	; Return if type is string (81h)
0B1993 F5    1678** PUSH    AF              	; It's a numeric type from this point on
0B1994 CD    1679** CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B1995 5A 
0B1996 1B 
0B1997 0B 
0B1998 E5    1680** PUSH    HL
0B1999 CD    1681** CALL    EXPRN
0B199A CC 
0B199B 06 
0B199C 0B 
0B199D DD    1682** POP     IX
0B199E E1 
0B199F F1    1683** POP     AF
0B19A0 CB    1684** STORE:			BIT     0,A
0B19A1 47 
0B19A2 28    1685** JR      Z,STOREI
0B19A3 13 
0B19A4 BF    1686** CP      A               	; Set the variable to 0
0B19A5 DD    1687** STORE5:			LD      (IX+4),C
0B19A6 71 
0B19A7 04 
0B19A8 D9    1688** STORE4:			EXX
0B19A9 DD    1689** LD      (IX+0),L
0B19AA 75 
0B19AB 00 
0B19AC DD    1690** LD      (IX+1),H
0B19AD 74 
0B19AE 01 
0B19AF D9    1691** EXX
0B19B0 DD    1692** LD      (IX+2),L
0B19B1 75 
0B19B2 02 
0B19B3 DD    1693** LD      (IX+3),H
0B19B4 74 
0B19B5 03 
0B19B6 C9    1694** RET
0B19B7 F5    1695** STOREI:			PUSH    AF
0B19B8 0C    1696** INC     C               ;SPEED - & PRESERVE F'
0B19B9 0D    1697** DEC     C               ; WHEN CALLED BY FNEND0
0B19BA C4    1698** CALL    NZ,SFIX         ;CONVERT TO INTEGER
0B19BB 2C 
0B19BC 0A 
0B19BD 0B 
0B19BE F1    1699** POP     AF
0B19BF FE    1700** CP      4
0B19C0 04 
0B19C1 28    1701** JR      Z,STORE4
0B19C2 E5 
0B19C3 BF    1702** CP      A               ;SET ZERO
0B19C4 D9    1703** STORE1:			EXX
0B19C5 DD    1704** LD      (IX+0),L
0B19C6 75 
0B19C7 00 
0B19C8 D9    1705** EXX
0B19C9 C9    1706** RET
             1707** ;
             1708** ; Copy a string from the string accumulator to variable storage on the stack
             1709** ; Parameters:
             1710** ; - AF: The variable type (should be 81h for a string, 80h for a fixed/static string)
             1711** ; - IX: Address of the variable storage on the stack
             1712** ;
0B19CA 21    1713** STACCS:			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B19CB 00 
0B19CC 4E 
0B19CD 0B 
             1714** ;
             1715** ; Parameters:
             1716** ; As above, but:
             1717** ; - HL: Address of the string to be stored
             1718** ; -  E: The string length
             1719** ; NB:
             1720** ; Strings are mutable
             1721** ; Strings are stored in the following format in the variable:
             1722** ; - Address of the next variable (3 bytes)
             1723** ; - The rest of the variable name - this is zero terminated
             1724** ; - Current string length (byte)
             1725** ; - Maximum (original) string length (byte)
             1726** ; - String start address (3 bytes for BBC BASIC for eZ80, 2 bytes for standard BBC BASIC for Z80)
             1727** ; See https://www.bbcbasic.co.uk/bbcbasic/mancpm/annexd.html#string for more details
             1728** ;
0B19CE 1F    1729** STORES:			RRA				; Rotate right to shift bit 0 into carry
0B19CF 30    1730** JR      NC,STORS3		; It's a fixed/static string, so skip the next bit
0B19D0 5D 
0B19D1 E5    1731** PUSH    HL			; Stack ACCS
             1732** ;
             1733** ; Load the string pointer and lengths into registers - these are all zeroed for new strings
             1734** ;
0B19D2 D9    1735** EXX				; This block was a call to LOAD4
0B19D3 DD    1736** LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B19D4 6E 
0B19D5 00 
0B19D6 DD    1737** LD      H,(IX+1)		; The maximum original string length
0B19D7 66 
0B19D8 01 
0B19D9 D9    1738** EXX
0B19DA DD    1739** LD	HL,(IX+2)		; Address of the string (24-bit)
0B19DB 27 
0B19DC 02 
             1740** ;
0B19DD 7B    1741** LD      A,E             	; E : Length of string in ACCS (as passed to the function)
0B19DE D9    1742** EXX
0B19DF 6F    1743** LD      L,A			; L': Length of string currently stored on the stack
0B19E0 7C    1744** LD      A,H             	; H': The maximum (original) string length
0B19E1 D9    1745** EXX
0B19E2 BB    1746** CP      E			; Check whether there is enough room for the string in ACCS in the allocated space
0B19E3 30    1747** JR      NC,STORS1       	; Yes there is, so skip the next bit
0B19E4 17 
             1748** ;
             1749** ; At this point we're either initialising a new string or assigning more memory to an existing string
             1750** ; Note that there is no garbage collection here, so if a string is reassigned and the new string is longer
             1751** ; then the existing and new strings may both exist in memory.
             1752** ;
0B19E5 D9    1753** EXX
0B19E6 65    1754** LD      H,L			; H: Set the maximum string length to the string length
0B19E7 D9    1755** EXX
0B19E8 E5    1756** PUSH    HL
0B19E9 01    1757** LD	BC, 0
0B19EA 00 
0B19EB 00 
0B19EC 00 
0B19ED 4F    1758** LD      C,A			; BC: The maximum (original) string length
0B19EE 09    1759** ADD     HL,BC			; Work out whether this is the last string in memory
0B19EF ED    1760** LD      BC,(FREE)
0B19F0 4B 
0B19F1 1D 
0B19F2 51 
0B19F2 0B   
0B19F4 ED    1761** SBC     HL,BC			; Is string last?
0B19F5 42 
0B19F6 E1    1762** POP     HL
0B19F7 37    1763** SCF
0B19F8 28    1764** JR      Z,STORS1
0B19F9 02 
             1765** ; LD	HL, BC			; HL=BC
0B19FA C5    1766** push bc
0B19FB E1    1767** pop hl
             1768** ;
             1769** ; At this point carry flag will be clear if the string can be replaced in memory, otherwise will be set
             1770** ; - H': The maximum (original) string length
             1771** ; - L': The actual string length (must be less than H')
             1772** ; - HL: Address of the string in memory
             1773** ;
0B19FC D9    1774** STORS1:			EXX				; This block was a call to STORE4
0B19FD DD    1775** LD      (IX+0),L		; The actual string length (must be less then H')
0B19FE 75 
0B19FF 00 
0B1A00 DD    1776** LD      (IX+1),H		; The maximum (original) string length
0B1A01 74 
0B1A02 01 
0B1A03 D9    1777** EXX
0B1A04 DD    1778** LD	(IX+2),HL		; The pointer to the original string
0B1A05 2F 
0B1A06 02 
             1779** ;
0B1A07 01    1780** LD	BC, 0
0B1A08 00 
0B1A09 00 
0B1A0A 00 
0B1A0B 4B    1781** LD      C,E			; BC: The new string length
0B1A0C EB    1782** EX      DE,HL
0B1A0D E1    1783** POP     HL
0B1A0E 0D    1784** DEC     C			; Strings can only be 255 bytes long, so this is a quick way to
0B1A0F 0C    1785** INC     C			; check whether BC is 0 without affecting the carry flag
0B1A10 C8    1786** RET     Z               	; It is, so it's a NULL string, don't need to do anything else here
0B1A11 ED    1787** LDIR				; Replace the string in memory
0B1A12 B0 
0B1A13 D0    1788** RET     NC
0B1A14 ED    1789** LD      (FREE),DE		; Set the new value of FREE and fall through to CHECK
0B1A15 53 
0B1A16 1D 
0B1A17 51 
0B1A17 0B   
             1790** ;
             1791** ; Check whether the stack is full
             1792** ;
0B1A19 E5    1793** CHECK:			PUSH    HL
0B1A1A C5    1794** PUSH	BC
0B1A1B 2A    1795** LD      HL,(FREE)		; HL: Address of first free space byte
0B1A1C 1D 
0B1A1D 51 
0B1A1E 0B 
0B1A1F 01    1796** LD	BC,100h			; BC: One page of memory
0B1A20 00 
0B1A21 01 
0B1A22 00 
0B1A23 09    1797** ADD	HL,BC			; Add a page to FREE
0B1A24 ED    1798** SBC     HL,SP			; And subtract the current SP
0B1A25 72 
0B1A26 C1    1799** POP	BC
0B1A27 E1    1800** POP     HL
0B1A28 D8    1801** RET     C			; The SP is not in the same page, so just return
0B1A29 AF    1802** XOR     A			; Otherwise
0B1A2A C3    1803** JP      ERROR_			; Throw error "No room"
0B1A2B 2A 
0B1A2C 3B 
0B1A2D 0B 
             1804** ;
0B1A2E 01    1805** STORS3:			LD	BC,0
0B1A2F 00 
0B1A30 00 
0B1A31 00 
0B1A32 4B    1806** LD      C,E			; BC: String length
0B1A33 DD    1807** PUSH    IX
0B1A34 E5 
0B1A35 D1    1808** POP     DE			; DE: Destination
0B1A36 AF    1809** XOR     A			; Check if string length is 0
0B1A37 B9    1810** CP      C
0B1A38 28    1811** JR      Z,STORS5		; Yes, so don't copy
0B1A39 02 
0B1A3A ED    1812** LDIR
0B1A3B B0 
0B1A3C 3E    1813** STORS5:			LD      A,CR			; Finally add the terminator
0B1A3D 0D 
0B1A3E 12    1814** LD      (DE),A
0B1A3F C9    1815** RET
             1816** 
             1817** ; ARGUE: TRANSFER FN OR PROC ARGUMENTS FROM THE
             1818** ;  CALLING STATEMENT TO THE DUMMY VARIABLES VIA
             1819** ;  THE STACK.  IT MUST BE DONE THIS WAY TO MAKE
             1820** ;  PROCFRED(A,B)    DEF PROCFRED(B,A)     WORK.
             1821** ;    Inputs: DE addresses parameter list
             1822** ;            IY addresses dummy variable list
             1823** ;   Outputs: DE,IY updated
             1824** ;  Destroys: Everything
             1825** ;
0B1A40 3E    1826** ARGUE:			LD      A,-1
0B1A41 FF 
0B1A42 F5    1827** PUSH    AF              	; Put marker on the stack
0B1A43 FD    1828** ARGUE1:			INC     IY              	; Bump past '(' or ',''
0B1A44 23 
0B1A45 13    1829** INC     DE
0B1A46 D5    1830** PUSH    DE
0B1A47 CD    1831** CALL    NXT			; Skip any whitespace
0B1A48 3A 
0B1A49 0E 
0B1A4A 0B 
0B1A4B CD    1832** CALL    GETVAR			; Get the location of the variable in HL/IX
0B1A4C 04 
0B1A4D 3E 
0B1A4E 0B 
0B1A4F 38    1833** JR      C,ARGERR		; If the parameter contains an illegal character then throw an error
0B1A50 3F 
0B1A51 C4    1834** CALL    NZ,PUTVAR
0B1A52 F3 
0B1A53 3D 
0B1A54 0B 
0B1A55 D1    1835** POP     DE
0B1A56 E5    1836** PUSH    HL              	; VARPTR
0B1A57 B7    1837** OR      A               	; Check the variable type
0B1A58 F5    1838** PUSH    AF
0B1A59 D5    1839** PUSH    DE
0B1A5A FD    1840** EX      (SP),IY
0B1A5B E3 
0B1A5C FA    1841** JP      M,ARGUE2        	; Jump here if it is a string
0B1A5D 74 
0B1A5E 1A 
0B1A5F 0B 
             1842** ;
0B1A60 CD    1843** CALL    EXPRN           	; At this point it is numeric, so get the numeric expression value
0B1A61 CC 
0B1A62 06 
0B1A63 0B 
0B1A64 FD    1844** EX      (SP),IY
0B1A65 E3 
0B1A66 D1    1845** POP     DE
0B1A67 F1    1846** POP     AF
0B1A68 D9    1847** EXX
0B1A69 E5    1848** PUSH    HL
0B1A6A D9    1849** EXX
0B1A6B E5    1850** PUSH    HL
0B1A6C 47    1851** LD      B,A
0B1A6D C5    1852** PUSH    BC
0B1A6E CD    1853** CALL    CHECK           	; Check room
0B1A6F 19 
0B1A70 1A 
0B1A71 0B 
0B1A72 18    1854** JR      ARGUE4
0B1A73 0F 
             1855** ;
0B1A74 CD    1856** ARGUE2:			CALL    EXPRS			; At this point it is a string variable, so get the string expression value
0B1A75 DF 
0B1A76 06 
0B1A77 0B 
0B1A78 FD    1857** EX      (SP),IY
0B1A79 E3 
0B1A7A D9    1858** EXX
0B1A7B D1    1859** POP     DE
0B1A7C D9    1860** EXX
0B1A7D F1    1861** POP     AF
0B1A7E CD    1862** CALL    PUSHS
0B1A7F 7E 
0B1A80 0D 
0B1A81 0B 
0B1A82 D9    1863** EXX
             1864** ;
0B1A83 CD    1865** ARGUE4:			CALL    NXT			; Skip whitespace
0B1A84 3A 
0B1A85 0E 
0B1A86 0B 
0B1A87 FE    1866** CP      ','			; Check to see if the next value is a comma
0B1A88 2C 
0B1A89 20    1867** JR      NZ,ARGUE5		; No, so jump here
0B1A8A 0B 
0B1A8B 1A    1868** LD      A,(DE)
0B1A8C FE    1869** CP      ','			; Are there any more arguments?
0B1A8D 2C 
0B1A8E 28    1870** JR      Z,ARGUE1        	; Yes, so loop
0B1A8F B3 
             1871** ;
0B1A90 3E    1872** ARGERR:			LD      A,31
0B1A91 1F 
0B1A92 C3    1873** JP      ERROR_           	; Throw error "Arguments"
0B1A93 2A 
0B1A94 3B 
0B1A95 0B 
             1874** ;
0B1A96 CD    1875** ARGUE5:			CALL    BRAKET			; Check for end bracket (throws an error if missing)
0B1A97 F9 
0B1A98 0D 
0B1A99 0B 
0B1A9A 1A    1876** LD      A,(DE)
0B1A9B FE    1877** CP      ')'
0B1A9C 29 
0B1A9D 20    1878** JR      NZ,ARGERR
0B1A9E F1 
0B1A9F 13    1879** INC     DE
0B1AA0 D9    1880** EXX
0B1AA1 C1    1881** ARGUE6:			POP     BC
0B1AA2 78    1882** LD      A,B
0B1AA3 3C    1883** INC     A
0B1AA4 D9    1884** EXX
0B1AA5 C8    1885** RET     Z               	; Marker popped
0B1AA6 D9    1886** EXX
0B1AA7 3D    1887** DEC     A
0B1AA8 FA    1888** JP      M,ARGUE7        	; If it is a string, then jump here
0B1AA9 B8 
0B1AAA 1A 
0B1AAB 0B 
0B1AAC E1    1889** POP     HL
0B1AAD D9    1890** EXX
0B1AAE E1    1891** POP     HL
0B1AAF D9    1892** EXX
0B1AB0 DD    1893** POP     IX
0B1AB1 E1 
0B1AB2 CD    1894** CALL    STORE	           	; Write to dummy variable
0B1AB3 A0 
0B1AB4 19 
0B1AB5 0B 
0B1AB6 18    1895** JR      ARGUE6
0B1AB7 E9 
             1896** ;
0B1AB8 CD    1897** ARGUE7:			CALL    POPS
0B1AB9 A8 
0B1ABA 0D 
0B1ABB 0B 
0B1ABC DD    1898** POP     IX
0B1ABD E1 
0B1ABE CD    1899** CALL    STACCS
0B1ABF CA 
0B1AC0 19 
0B1AC1 0B 
0B1AC2 18    1900** JR      ARGUE6
0B1AC3 DD 
             1901** 
             1902** ; SAVLOC: SUBROUTINE TO STACK LOCAL PARAMETERS
             1903** ;   OF A FUNCTION OR PROCEDURE.
             1904** ; THERE IS A LOT OF STACK MANIPULATION - CARE!!
             1905** ;    Inputs: IY is parameters pointer
             1906** ;   Outputs: IY updated
             1907** ;  Destroys: A,B,C,D,E,H,L,IX,IY,F,SP
             1908** ;
0B1AC4 D1    1909** SAVLOC:			POP     DE              	; DE: Return address (from the CALL)
             1910** ;
0B1AC5 FD    1911** SAVLO1:			INC     IY              	; Bump past '(' or ','
0B1AC6 23 
0B1AC7 CD    1912** CALL    NXT			; And also any whitespace
0B1AC8 3A 
0B1AC9 0E 
0B1ACA 0B 
0B1ACB D5    1913** PUSH    DE			; Push the return address back onto the stack
0B1ACC D9    1914** EXX
0B1ACD C5    1915** PUSH    BC
0B1ACE D5    1916** PUSH    DE
0B1ACF E5    1917** PUSH    HL
0B1AD0 D9    1918** EXX
0B1AD1 CD    1919** CALL    VAR_             	; Dummy variable
0B1AD2 58 
0B1AD3 10 
0B1AD4 0B 
0B1AD5 D9    1920** EXX
0B1AD6 E1    1921** POP     HL
0B1AD7 D1    1922** POP     DE
0B1AD8 C1    1923** POP     BC
0B1AD9 D9    1924** EXX
0B1ADA D1    1925** POP     DE
0B1ADB B7    1926** OR      A               	; Check the variable type
0B1ADC FA    1927** JP      M,SAVLO2        	; 80h = string, so jump to save a local string
0B1ADD EF 
0B1ADE 1A 
0B1ADF 0B 
0B1AE0 D9    1928** EXX
0B1AE1 E5    1929** PUSH    HL              	; Save H'L'
0B1AE2 D9    1930** EXX
0B1AE3 47    1931** LD      B,A             	;  B: Variable type
0B1AE4 CD    1932** CALL    LOADN
0B1AE5 E0 
0B1AE6 07 
0B1AE7 0B 
0B1AE8 D9    1933** EXX
0B1AE9 E3    1934** EX      (SP),HL
0B1AEA D9    1935** EXX
0B1AEB E5    1936** PUSH    HL
0B1AEC C5    1937** PUSH    BC
0B1AED 18    1938** JR      SAVLO4
0B1AEE 2D 
             1939** ;
0B1AEF F5    1940** SAVLO2:			PUSH    AF              	; Save the type (string)
0B1AF0 D5    1941** PUSH    DE
0B1AF1 D9    1942** EXX
0B1AF2 E5    1943** PUSH    HL
0B1AF3 D9    1944** EXX
0B1AF4 CD    1945** CALL    LOADS
0B1AF5 6A 
0B1AF6 08 
0B1AF7 0B 
0B1AF8 D9    1946** EXX
0B1AF9 E1    1947** POP     HL
0B1AFA D9    1948** EXX
0B1AFB 01    1949** LD	BC,0
0B1AFC 00 
0B1AFD 00 
0B1AFE 00 
0B1AFF 4B    1950** LD      C,E			; BC: String length
0B1B00 D1    1951** POP     DE
0B1B01 CD    1952** CALL    CHECK			; Check if there is space on the stack
0B1B02 19 
0B1B03 1A 
0B1B04 0B 
0B1B05 F1    1953** POP     AF              	; Level stack
0B1B06 21    1954** LD      HL,0
0B1B07 00 
0B1B08 00 
0B1B09 00 
0B1B0A ED    1955** SBC     HL,BC			; HL: Number of bytes required on the stack for the string
0B1B0B 42 
0B1B0C 39    1956** ADD     HL,SP			; Make space for the string on the stack
0B1B0D F9    1957** LD      SP,HL
0B1B0E 47    1958** LD      B,A             	;  B: Variable type
0B1B0F C5    1959** PUSH    BC
0B1B10 28    1960** JR      Z,SAVLO4
0B1B11 0A 
0B1B12 D5    1961** PUSH    DE
0B1B13 11    1962** LD      DE,ACCS
0B1B14 00 
0B1B15 4E 
0B1B16 0B 
0B1B17 EB    1963** EX      DE,HL
0B1B18 45    1964** LD      B,L
0B1B19 ED    1965** LDIR                    	; Save the string onto the stack
0B1B1A B0 
0B1B1B D1    1966** POP     DE
             1967** ;
0B1B1C DD    1968** SAVLO4:			PUSH    IX			; VARPTR
0B1B1D E5 
0B1B1E CD    1969** CALL    SAVLO5
0B1B1F 22 
0B1B20 1B 
0B1B21 0B 
             1970** LOCCHK:			EQU     $
0B1B22 CD    1971** SAVLO5:			CALL    CHECK
0B1B23 19 
0B1B24 1A 
0B1B25 0B 
0B1B26 CD    1972** CALL    NXT
0B1B27 3A 
0B1B28 0E 
0B1B29 0B 
0B1B2A FE    1973** CP      ','             	; Are there any more local variables?
0B1B2B 2C 
0B1B2C 28    1974** JR      Z,SAVLO1		; Yes, so loop
0B1B2D 97 
0B1B2E EB    1975** EX      DE,HL			; DE -> HL: The return address
0B1B2F E9    1976** JP      (HL)            	; And effectvely return
             1977** ;
0B1B30 FD    1978** DELIM:			LD      A,(IY)          	; Assembler delimiter
0B1B31 7E 
0B1B32 00 
0B1B33 FE    1979** CP      ' '
0B1B34 20 
0B1B35 C8    1980** RET     Z
0B1B36 FE    1981** CP      ','
0B1B37 2C 
0B1B38 C8    1982** RET     Z
0B1B39 FE    1983** CP      ')'
0B1B3A 29 
0B1B3B C8    1984** RET     Z
0B1B3C FE    1985** TERM:			CP      ';'             	; Assembler terminator
0B1B3D 3B 
0B1B3E C8    1986** RET     Z
0B1B3F FE    1987** CP      '\'
0B1B40 5C 
0B1B41 C8    1988** RET     Z
0B1B42 18    1989** JR      TERM0
0B1B43 07 
             1990** ;
0B1B44 CD    1991** TERMQ:			CALL    NXT
0B1B45 3A 
0B1B46 0E 
0B1B47 0B 
0B1B48 FE    1992** CP      ELSE_EX_
0B1B49 8B 
0B1B4A D0    1993** RET     NC
0B1B4B FE    1994** TERM0:			CP      ':'             	; Assembler seperator
0B1B4C 3A 
0B1B4D D0    1995** RET     NC
0B1B4E FE    1996** CP      CR
0B1B4F 0D 
0B1B50 C9    1997** RET
             1998** ;
0B1B51 CD    1999** SPAN:			CALL    TERMQ
0B1B52 44 
0B1B53 1B 
0B1B54 0B 
0B1B55 C8    2000** RET     Z
0B1B56 FD    2001** INC     IY
0B1B57 23 
0B1B58 18    2002** JR      SPAN
0B1B59 F7 
             2003** ;
             2004** ; This snippet is used to check whether an expression is followed by an '=' symbol
             2005** ;
0B1B5A CD    2006** EQUALS:			CALL    NXT			; Skip whitespace
0B1B5B 3A 
0B1B5C 0E 
0B1B5D 0B 
0B1B5E FD    2007** INC     IY			; Skip past the character in question
0B1B5F 23 
0B1B60 FE    2008** CP      '='			; Is it '='
0B1B61 3D 
0B1B62 C8    2009** RET     Z			; Yes, so return
0B1B63 3E    2010** LD      A,4			; Otherwise
0B1B64 04 
0B1B65 C3    2011** JP      ERROR_           	; Throw error "Mistake"
0B1B66 2A 
0B1B67 3B 
0B1B68 0B 
             2012** ;
0B1B69 FE    2013** FORMAT:			CP      TAB
0B1B6A 8A 
0B1B6B 28    2014** JR      Z,DOTAB
0B1B6C 0D 
0B1B6D FE    2015** CP      SPC
0B1B6E 89 
0B1B6F 28    2016** JR      Z,DOSPC
0B1B70 40 
0B1B71 FE    2017** CP      '''
0B1B72 27 
0B1B73 C0    2018** RET     NZ
0B1B74 CD    2019** CALL    CRLF
0B1B75 11 
0B1B76 3D 
0B1B77 0B 
0B1B78 AF    2020** XOR     A
0B1B79 C9    2021** RET
             2022** ;
0B1B7A C5    2023** DOTAB:			PUSH    BC
0B1B7B CD    2024** CALL    EXPRI
0B1B7C D4 
0B1B7D 06 
0B1B7E 0B 
0B1B7F D9    2025** EXX
0B1B80 C1    2026** POP     BC
0B1B81 FD    2027** LD      A,(IY)
0B1B82 7E 
0B1B83 00 
0B1B84 FE    2028** CP      ','
0B1B85 2C 
0B1B86 28    2029** JR      Z,DOTAB1
0B1B87 14 
0B1B88 CD    2030** CALL    BRAKET
0B1B89 F9 
0B1B8A 0D 
0B1B8B 0B 
0B1B8C 7D    2031** LD      A,L
0B1B8D 21    2032** TABIT:			LD      HL,COUNT
0B1B8E 3D 
0B1B8F 51 
0B1B90 0B 
0B1B91 BE    2033** CP      (HL)
0B1B92 C8    2034** RET     Z
0B1B93 F5    2035** PUSH    AF
0B1B94 DC    2036** CALL    C,CRLF
0B1B95 11 
0B1B96 3D 
0B1B97 0B 
0B1B98 F1    2037** POP     AF
0B1B99 96    2038** SUB     (HL)
0B1B9A 18    2039** JR      FILL
0B1B9B 1D 
0B1B9C FD    2040** DOTAB1:			INC     IY
0B1B9D 23 
0B1B9E C5    2041** PUSH    BC
0B1B9F E5    2042** PUSH    HL
0B1BA0 CD    2043** CALL    EXPRI
0B1BA1 D4 
0B1BA2 06 
0B1BA3 0B 
0B1BA4 D9    2044** EXX
0B1BA5 D1    2045** POP     DE
0B1BA6 C1    2046** POP     BC
0B1BA7 CD    2047** CALL    BRAKET
0B1BA8 F9 
0B1BA9 0D 
0B1BAA 0B 
0B1BAB CD    2048** CALL    PUTCSR
0B1BAC 8B 
0B1BAD 42 
0B1BAE 0B 
0B1BAF AF    2049** XOR     A
0B1BB0 C9    2050** RET
             2051** ;
0B1BB1 C5    2052** DOSPC:			PUSH    BC
0B1BB2 CD    2053** CALL    ITEMI
0B1BB3 EF 
0B1BB4 06 
0B1BB5 0B 
0B1BB6 D9    2054** EXX
0B1BB7 7D    2055** LD      A,L
0B1BB8 C1    2056** POP     BC
0B1BB9 B7    2057** FILL:			OR      A
0B1BBA C8    2058** RET     Z
0B1BBB C5    2059** PUSH    BC
0B1BBC 47    2060** LD      B,A
0B1BBD 3E    2061** FILL1:			LD      A,' '
0B1BBE 20 
0B1BBF CD    2062** CALL    OUTCHR
0B1BC0 19 
0B1BC1 3D 
0B1BC2 0B 
0B1BC3 10    2063** DJNZ    FILL1
0B1BC4 F8 
0B1BC5 C1    2064** POP     BC
0B1BC6 AF    2065** XOR     A
0B1BC7 C9    2066** RET
             2067** ;
0B1BC8 21    2068** PTEXT:			LD      HL,ACCS
0B1BC9 00 
0B1BCA 4E 
0B1BCB 0B 
0B1BCC 1C    2069** INC     E
0B1BCD 1D    2070** PTEXT1:			DEC     E
0B1BCE C8    2071** RET     Z
0B1BCF 7E    2072** LD      A,(HL)
0B1BD0 23    2073** INC     HL
0B1BD1 CD    2074** CALL    OUTCHR
0B1BD2 19 
0B1BD3 3D 
0B1BD4 0B 
0B1BD5 18    2075** JR      PTEXT1
0B1BD6 F6 
             2076** ;
0B1BD7 F5    2077** FETCHS:			PUSH    AF
0B1BD8 C5    2078** PUSH    BC
0B1BD9 E5    2079** PUSH    HL
0B1BDA FD    2080** EX      (SP),IY
0B1BDB E3 
0B1BDC CD    2081** CALL    XTRACT
0B1BDD F7 
0B1BDE 1B 
0B1BDF 0B 
0B1BE0 CD    2082** CALL    NXT
0B1BE1 3A 
0B1BE2 0E 
0B1BE3 0B 
0B1BE4 FD    2083** EX      (SP),IY
0B1BE5 E3 
0B1BE6 E1    2084** POP     HL
0B1BE7 C1    2085** POP     BC
0B1BE8 F1    2086** POP     AF
0B1BE9 C9    2087** RET
             2088** ;
0B1BEA 11    2089** LINES:			LD      DE,ACCS
0B1BEB 00 
0B1BEC 4E 
0B1BED 0B 
0B1BEE 7E    2090** LINE1S:			LD      A,(HL)
0B1BEF 12    2091** LD      (DE),A
0B1BF0 FE    2092** CP      CR
0B1BF1 0D 
0B1BF2 C8    2093** RET     Z
0B1BF3 23    2094** INC     HL
0B1BF4 1C    2095** INC     E
0B1BF5 18    2096** JR      LINE1S
0B1BF6 F7 
             2097** ;
0B1BF7 CD    2098** XTRACT:			CALL    NXT
0B1BF8 3A 
0B1BF9 0E 
0B1BFA 0B 
0B1BFB FE    2099** CP      '"'
0B1BFC 22 
0B1BFD FD    2100** INC     IY
0B1BFE 23 
0B1BFF CA    2101** JP      Z,CONS
0B1C00 31 
0B1C01 08 
0B1C02 0B 
0B1C03 FD    2102** DEC     IY
0B1C04 2B 
0B1C05 11    2103** LD      DE,ACCS
0B1C06 00 
0B1C07 4E 
0B1C08 0B 
0B1C09 FD    2104** XTRAC1:			LD      A,(IY)
0B1C0A 7E 
0B1C0B 00 
0B1C0C 12    2105** LD      (DE),A
0B1C0D FE    2106** CP      ','
0B1C0E 2C 
0B1C0F C8    2107** RET     Z
0B1C10 FE    2108** CP      CR
0B1C11 0D 
0B1C12 C8    2109** RET     Z
0B1C13 FD    2110** INC     IY
0B1C14 23 
0B1C15 1C    2111** INC     E
0B1C16 18    2112** JR      XTRAC1
0B1C17 F1 
             2113** 
             2114** ; Search for a token at the start of a program line
             2115** ; - HL: Pointer to the start of a tokenised line in the program area
             2116** ; Returns:
             2117** ; - HL: Pointer to the
             2118** ; -  F: Carry set if not found
             2119** ; Corrupts:
             2120** ; - BC
             2121** ;
0B1C18 01    2122** SEARCH_EX:			LD      BC,0			; Clear BC
0B1C19 00 
0B1C1A 00 
0B1C1B 00 
             2123** ;
0B1C1C 4E    2124** SRCH1_EX:			LD      C,(HL)			;  C: Fetch the line length
0B1C1D 0C    2125** INC     C			; Check for 0, i.e. end of program marker
0B1C1E 0D    2126** DEC     C
0B1C1F 28    2127** JR      Z,SRCH2_EX         	; Not found the token, so end
0B1C20 0B 
0B1C21 23    2128** INC     HL			; Skip the line length and line number
0B1C22 23    2129** INC     HL
0B1C23 23    2130** INC     HL
0B1C24 BE    2131** CP      (HL)			; Compare with the token
0B1C25 C8    2132** RET     Z			; Found it, so return with carry not set
0B1C26 0D    2133** DEC     C			; Skip to the next line
0B1C27 0D    2134** DEC     C
0B1C28 0D    2135** DEC     C
0B1C29 09    2136** ADD     HL,BC
0B1C2A 18    2137** JR      SRCH1_EX			; Rinse, lather and repeat
0B1C2B F0 
             2138** ;
0B1C2C 2B    2139** SRCH2_EX:			DEC     HL              	; Token not found, so back up to the CR at the end of the last line
0B1C2D 37    2140** SCF				; And set the carry flag
0B1C2E C9    2141** RET
             2142** 
             2143** ; Multiply by 4 or 5
             2144** ; This function is used to allocate space for dimensioned variables
             2145** ; This is a 24-bit operation
             2146** ; - DE: Number to multiple
             2147** ; -  A: 04h (Integer) - takes up 4 bytes
             2148** ;       05h (Float)   - takes up 5 bytes
             2149** ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
             2150** ; Returns:
             2151** ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
             2152** ; -  F: Carry if overflow
             2153** ; Corrupts:
             2154** ; - HL
0B1C2F FE    2155** X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0B1C30 04 
             2156** ; LD	HL,DE
0B1C31 D5    2157** push de
0B1C32 E1    2158** pop hl
0B1C33 29    2159** ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0B1C34 D8    2160** RET     C			; Exit if overflow
0B1C35 29    2161** ADD     HL,HL			; Multiply by 2 again
0B1C36 D8    2162** RET     C			; Exit if overflow
0B1C37 EB    2163** EX      DE,HL			; DE: Product
0B1C38 C8    2164** RET     Z			; Exit if A = 4
0B1C39 19    2165** ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0B1C3A EB    2166** EX      DE,HL			; DE: Product
0B1C3B C9    2167** RET
             2168** 
             2169** ; 16-bit unsigned multiply
             2170** ; - HL: Operand 1
             2171** ; - BC: Operand 2
             2172** ; Returns:
             2173** ; - HL: Result
             2174** ; -  F: C if overflow
             2175** ;
0B1C3C C5    2176** MUL16:			PUSH	BC
0B1C3D 51    2177** LD	D, C			; Set up the registers for the multiplies
0B1C3E 5D    2178** LD	E, L
0B1C3F 69    2179** LD	L, C
0B1C40 4B    2180** LD	C, E
0B1C41 ED    2181** MLT	HL			; HL = H * C (*256)
0B1C42 6C 
0B1C43 ED    2182** MLT	DE			; DE = L * C
0B1C44 5C 
0B1C45 ED    2183** MLT	BC			; BC = B * L (*256)
0B1C46 4C 
0B1C47 09    2184** ADD	HL, BC			; HL = The sum of the two most significant multiplications
0B1C48 C1    2185** POP	BC
0B1C49 AF    2186** XOR	A
0B1C4A 9C    2187** SBC	H			; If H is not zero then it's an overflow
0B1C4B D8    2188** RET	C
0B1C4C 65    2189** LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0B1C4D 6F    2190** LD	L, A
0B1C4E 19    2191** ADD	HL, DE
0B1C4F C9    2192** RET
             2193** ;
0B1C50 CD    2194** CHANEL:			CALL    NXT			; Skip whitespace
0B1C51 3A 
0B1C52 0E 
0B1C53 0B 
0B1C54 FE    2195** CP      '#'			; Check for the '#' symbol
0B1C55 23 
0B1C56 3E    2196** LD      A,45
0B1C57 2D 
0B1C58 C2    2197** JP      NZ,ERROR_        	; If it is missing, then throw a "Missing #" error
0B1C59 2A 
0B1C5A 3B 
0B1C5B 0B 
0B1C5C FD    2198** CHNL:			INC     IY             		; Bump past the '#'
0B1C5D 23 
0B1C5E CD    2199** CALL    ITEMI			; Get the channel number
0B1C5F EF 
0B1C60 06 
0B1C61 0B 
0B1C62 D9    2200** EXX
0B1C63 EB    2201** EX      DE,HL			; DE: The channel number
0B1C64 C9    2202** RET
             2203** 
             2204** ; ASSEMBLER -------------------------------------------------------------------
             2205** 
             2206** ; Language independant control section:
             2207** ;  Outputs: A=delimiter, carry set if syntax error.
             2208** ;
0B1C65 CD    2209** ASSEM:			CALL    SKIP
0B1C66 7F 
0B1C67 21 
0B1C68 0B 
0B1C69 FD    2210** INC     IY
0B1C6A 23 
0B1C6B FE    2211** CP      ':'
0B1C6C 3A 
0B1C6D 28    2212** JR      Z,ASSEM
0B1C6E F6 
0B1C6F FE    2213** CP      ']'
0B1C70 5D 
0B1C71 C8    2214** RET     Z
0B1C72 FE    2215** CP      CR
0B1C73 0D 
0B1C74 C8    2216** RET     Z
0B1C75 FD    2217** DEC     IY
0B1C76 2B 
0B1C77 DD    2218** LD      IX,(PC)         	; Program counter (P% - defined in equs.inc)
0B1C78 2A 
0B1C79 40 
0B1C7A 50 
0B1C7A 0B   
0B1C7C 21    2219** LD      HL,LISTON
0B1C7D 40 
0B1C7E 51 
0B1C7F 0B 
0B1C80 CB    2220** BIT     6,(HL)
0B1C81 76 
0B1C82 28    2221** JR      Z,ASSEM0
0B1C83 05 
0B1C84 DD    2222** LD      IX,(OC)         	; Code origin (O% - defined in equs.inc)
0B1C85 2A 
0B1C86 3C 
0B1C87 50 
0B1C87 0B   
0B1C89 DD    2223** ASSEM0:			PUSH    IX
0B1C8A E5 
0B1C8B FD    2224** PUSH    IY
0B1C8C E5 
0B1C8D CD    2225** CALL    ASMB
0B1C8E 3D 
0B1C8F 1D 
0B1C90 0B 
0B1C91 C1    2226** POP     BC
0B1C92 D1    2227** POP     DE
0B1C93 D8    2228** RET     C
0B1C94 CD    2229** CALL    SKIP
0B1C95 7F 
0B1C96 21 
0B1C97 0B 
0B1C98 37    2230** SCF
0B1C99 C0    2231** RET     NZ
0B1C9A FD    2232** DEC     IY
0B1C9B 2B 
0B1C9C FD    2233** ASSEM3:			INC     IY
0B1C9D 23 
0B1C9E FD    2234** LD      A,(IY)
0B1C9F 7E 
0B1CA0 00 
0B1CA1 CD    2235** CALL    TERM0
0B1CA2 4B 
0B1CA3 1B 
0B1CA4 0B 
0B1CA5 20    2236** JR      NZ,ASSEM3
0B1CA6 F5 
0B1CA7 3A    2237** LD      A,(LISTON)
0B1CA8 40 
0B1CA9 51 
0B1CAA 0B 
0B1CAB DD    2238** PUSH    IX
0B1CAC E5 
0B1CAD E1    2239** POP     HL
0B1CAE B7    2240** OR      A
0B1CAF ED    2241** SBC     HL,DE
0B1CB0 52 
0B1CB1 EB    2242** EX      DE,HL           	; DE: Number of bytes
0B1CB2 E5    2243** PUSH    HL
0B1CB3 2A    2244** LD      HL,(PC)
0B1CB4 40 
0B1CB5 50 
0B1CB6 0B 
0B1CB7 E5    2245** PUSH    HL
0B1CB8 19    2246** ADD     HL,DE
0B1CB9 22    2247** LD      (PC),HL         	; Update PC
0B1CBA 40 
0B1CBB 50 
0B1CBC 0B 
0B1CBD CB    2248** BIT     6,A
0B1CBE 77 
0B1CBF 28    2249** JR      Z,ASSEM5
0B1CC0 09 
0B1CC1 2A    2250** LD      HL,(OC)
0B1CC2 3C 
0B1CC3 50 
0B1CC4 0B 
0B1CC5 19    2251** ADD     HL,DE
0B1CC6 22    2252** LD      (OC),HL         	; Update OC
0B1CC7 3C 
0B1CC8 50 
0B1CC9 0B 
0B1CCA E1    2253** ASSEM5:			POP     HL              	; Old PC
0B1CCB DD    2254** POP     IX              	; Code here
0B1CCC E1 
0B1CCD CB    2255** BIT     4,A
0B1CCE 67 
0B1CCF 28    2256** JR      Z,ASSEM
0B1CD0 94 
0B1CD1 22    2257** LD	(R0),HL			; Store HL in R0 so we can access the MSB
0B1CD2 4A 
0B1CD3 51 
0B1CD4 0B 
0B1CD5 3A    2258** LD	A,(R0+2)		; Print out the address
0B1CD6 4C 
0B1CD7 51 
0B1CD8 0B 
0B1CD9 CD    2259** CALL	HEX_EX
0B1CDA 27 
0B1CDB 1D 
0B1CDC 0B 
0B1CDD 7C    2260** LD      A,H
0B1CDE CD    2261** CALL    HEX_EX
0B1CDF 27 
0B1CE0 1D 
0B1CE1 0B 
0B1CE2 7D    2262** LD      A,L
0B1CE3 CD    2263** CALL    HEXSP
0B1CE4 1F 
0B1CE5 1D 
0B1CE6 0B 
0B1CE7 AF    2264** XOR     A
0B1CE8 BB    2265** CP      E
0B1CE9 28    2266** JR      Z,ASSEM2
0B1CEA 18 
             2267** ;
0B1CEB 3A    2268** ASSEM1:			LD      A,(COUNT)
0B1CEC 3D 
0B1CED 51 
0B1CEE 0B 
0B1CEF FE    2269** CP      20
0B1CF0 14 
0B1CF1 3E    2270** LD      A,7
0B1CF2 07 
0B1CF3 D4    2271** CALL    NC,TABIT        	; Next line
0B1CF4 8D 
0B1CF5 1B 
0B1CF6 0B 
0B1CF7 DD    2272** LD      A,(IX)
0B1CF8 7E 
0B1CF9 00 
0B1CFA CD    2273** CALL    HEXSP
0B1CFB 1F 
0B1CFC 1D 
0B1CFD 0B 
0B1CFE DD    2274** INC     IX
0B1CFF 23 
0B1D00 1D    2275** DEC     E
0B1D01 20    2276** JR      NZ,ASSEM1
0B1D02 E8 
             2277** ;
0B1D03 3E    2278** ASSEM2:			LD      A,22			; Tab to the disassembly field
0B1D04 16 
0B1D05 CD    2279** CALL    TABIT
0B1D06 8D 
0B1D07 1B 
0B1D08 0B 
0B1D09 FD    2280** PUSH    IY
0B1D0A E5 
0B1D0B E1    2281** POP     HL
0B1D0C ED    2282** SBC     HL,BC
0B1D0D 42 
0B1D0E 0A    2283** ASSEM4:			LD      A,(BC)
0B1D0F CD    2284** CALL    OUT_
0B1D10 36 
0B1D11 3D 
0B1D12 0B 
0B1D13 03    2285** INC     BC
0B1D14 2D    2286** DEC     L
0B1D15 20    2287** JR      NZ,ASSEM4
0B1D16 F7 
0B1D17 CD    2288** CALL    CRLF
0B1D18 11 
0B1D19 3D 
0B1D1A 0B 
0B1D1B C3    2289** JP      ASSEM
0B1D1C 65 
0B1D1D 1C 
0B1D1E 0B 
             2290** ;
0B1D1F CD    2291** HEXSP:			CALL    HEX_EX
0B1D20 27 
0B1D21 1D 
0B1D22 0B 
0B1D23 3E    2292** LD      A,' '
0B1D24 20 
0B1D25 18    2293** JR      OUTCH1
0B1D26 12 
0B1D27 F5    2294** HEX_EX:			PUSH    AF
0B1D28 0F    2295** RRCA
0B1D29 0F    2296** RRCA
0B1D2A 0F    2297** RRCA
0B1D2B 0F    2298** RRCA
0B1D2C CD    2299** CALL    HEXOUT
0B1D2D 31 
0B1D2E 1D 
0B1D2F 0B 
0B1D30 F1    2300** POP     AF
0B1D31 E6    2301** HEXOUT:			AND     0FH
0B1D32 0F 
0B1D33 C6    2302** ADD     A,90H
0B1D34 90 
0B1D35 27    2303** DAA
0B1D36 CE    2304** ADC     A,40H
0B1D37 40 
0B1D38 27    2305** DAA
0B1D39 C3    2306** OUTCH1:			JP      OUT_
0B1D3A 36 
0B1D3B 3D 
0B1D3C 0B 
             2307** 
             2308** ; Processor Specific Translation Section:
             2309** ;
             2310** ; Register Usage: B: Type of most recent operand (the base value selected from the opcode table)
             2311** ;                 C: Opcode beig built
             2312** ;                 D: Flags
             2313** ;			Bit 7: Set to 1 if the instruction uses long addressing
             2314** ;			Bit 6: Set to 1 if the instruction is an index instruction with offset
             2315** ;                 E: Offset from IX or IY
             2316** ;                HL: Numeric operand value
             2317** ;                IX: Code destination pointer
             2318** ;                IY: Source text pointer
             2319** ;    Inputs: A = initial character
             2320** ;   Outputs: Carry set if syntax error.
             2321** ;
0B1D3D FE    2322** ASMB:			CP      '.'			; Check for a dot; this indicates a label
0B1D3E 2E 
0B1D3F 20    2323** JR      NZ,ASMB1		; No, so just process the instruction
0B1D40 1F 
0B1D41 FD    2324** INC     IY			; Skip past the dot to the label name
0B1D42 23 
0B1D43 DD    2325** PUSH    IX			; Store the code destination pointer
0B1D44 E5 
0B1D45 CD    2326** CALL    VAR_			; Create a variable
0B1D46 58 
0B1D47 10 
0B1D48 0B 
0B1D49 F5    2327** PUSH    AF
0B1D4A CD    2328** CALL    ZERO			; Zero it
0B1D4B 5D 
0B1D4C 0D 
0B1D4D 0B 
0B1D4E 3A    2329** LD	A,(PC+2)
0B1D4F 42 
0B1D50 50 
0B1D51 0B 
0B1D52 6F    2330** LD	L,A			; The MSB of the 24-bit address
0B1D53 D9    2331** EXX
0B1D54 2A    2332** LD      HL,(PC)			; The LSW of the 24-bit address (only 16-bits used)
0B1D55 40 
0B1D56 50 
0B1D57 0B 
0B1D58 D9    2333** EXX
0B1D59 F1    2334** POP     AF
0B1D5A CD    2335** CALL    STORE			; Store the program counter
0B1D5B A0 
0B1D5C 19 
0B1D5D 0B 
0B1D5E DD    2336** POP     IX			; Restore the code destination pointer
0B1D5F E1 
             2337** ;
0B1D60 3A    2338** ASMB1:			LD	A,(LISTON)		; Get the OPT flags
0B1D61 40 
0B1D62 51 
0B1D63 0B 
0B1D64 E6    2339** AND	80H
0B1D65 80 
0B1D66 57    2340** LD      D,A     		;  D: Clear the flags and set the initial ADL mode (copied from bit 7 of LISTON)
0B1D67 CD    2341** CALL    SKIP			; Skip any whitespace
0B1D68 7F 
0B1D69 21 
0B1D6A 0B 
0B1D6B C8    2342** RET     Z			; And return if there is nothing further to process
0B1D6C FE    2343** CP      TCALL			; Check if it is the token CALL (it will have been tokenised by BASIC)
0B1D6D D6 
0B1D6E 0E    2344** LD      C,0C4H			;  A: The base operand
0B1D6F C4 
0B1D70 FD    2345** INC     IY			; Skip past the token
0B1D71 23 
0B1D72 CA    2346** JP      Z,GROUP13_1		; And jump to GROUP13, which handles CALL
0B1D73 B4 
0B1D74 1E 
0B1D75 0B 
0B1D76 FD    2347** DEC     IY			; Skip back, as we're not doing the above at this point
0B1D77 2B 
0B1D78 21    2348** LD      HL,OPCODS		; HL: Pointer to the eZ80 opcodes table
0B1D79 96 
0B1D7A 21 
0B1D7B 0B 
0B1D7C CD    2349** CALL    FIND			; Find the opcode
0B1D7D 2E 
0B1D7E 21 
0B1D7F 0B 
0B1D80 D8    2350** RET     C			; If not found, then return; carry indicates an error condition
0B1D81 48    2351** LD      C,B     		;  C: A copy of the opcode
             2352** ;
             2353** ; GROUP 0: Trivial cases requiring no computation
             2354** ; GROUP 1: As Group 0, but with "ED" prefix
             2355** ;
0B1D82 D6    2356** SUB     68			; The number of opcodes in GROUP0 and GROUP1
0B1D83 44 
0B1D84 30    2357** JR      NC,GROUP02		; If not in that range, then check GROUP2
0B1D85 08 
0B1D86 FE    2358** CP      15-68			; Anything between 15 and 68 (neat compare trick here)
0B1D87 CB 
0B1D88 D4    2359** CALL    NC,ED			; Needs to be prefixed with ED
0B1D89 87 
0B1D8A 20 
0B1D8B 0B 
0B1D8C 18    2360** JR      BYTE0			; Then write the opcode byte
0B1D8D 76 
             2361** ;
             2362** ; GROUP 2: BIT, RES, SET
             2363** ; GROUP 3: RLC, RRC, RL, RR, SLA, SRA, SRL
             2364** ;
0B1D8E D6    2365** GROUP02:		SUB     10			; The number of opcodes in GROUP2 and GROUP3
0B1D8F 0A 
0B1D90 30    2366** JR      NC,GROUP04		; If not in that range, then check GROUP4
0B1D91 12 
0B1D92 FE    2367** CP      3-10			;
0B1D93 F9 
0B1D94 DC    2368** CALL    C,BIT_
0B1D95 1C 
0B1D96 21 
0B1D97 0B 
0B1D98 D8    2369** RET     C
0B1D99 CD    2370** CALL    REGLO
0B1D9A ED 
0B1D9B 20 
0B1D9C 0B 
0B1D9D D8    2371** RET     C
0B1D9E CD    2372** CALL    CB
0B1D9F 8B 
0B1DA0 20 
0B1DA1 0B 
0B1DA2 18    2373** JR      BYTE0
0B1DA3 60 
             2374** ;
             2375** ; GROUP 4 - PUSH, POP, EX (SP)
             2376** ;
0B1DA4 D6    2377** GROUP04:		SUB     3			; The number of opcodes in GROUP4
0B1DA5 03 
0B1DA6 30    2378** JR      NC,GROUP05		; If not in that range, then check GROUP5
0B1DA7 07 
0B1DA8 CD    2379** GROUP04_1:		CALL    PAIR_EX
0B1DA9 0F 
0B1DAA 21 
0B1DAB 0B 
0B1DAC D8    2380** RET     C
0B1DAD 18    2381** JR      BYTE0
0B1DAE 55 
             2382** ;
             2383** ; GROUP 5 - SUB, AND, XOR, OR, CP
             2384** ; GROUP 6 - ADD, ADC, SBC
             2385** ;
0B1DAF D6    2386** GROUP05:		SUB     8+2			; The number of opcodes in GROUP5 and GROUP6
0B1DB0 0A 
0B1DB1 30    2387** JR      NC,GROUP07
0B1DB2 39 
0B1DB3 FE    2388** CP      5-8
0B1DB4 FD 
0B1DB5 06    2389** LD      B,7
0B1DB6 07 
0B1DB7 D4    2390** CALL    NC,OPND			; Get the first operand
0B1DB8 9B 
0B1DB9 20 
0B1DBA 0B 
0B1DBB 78    2391** LD      A,B
0B1DBC FE    2392** CP      7			; Is the operand 'A'?
0B1DBD 07 
0B1DBE 20    2393** JR      NZ,GROUP05_HL		; No, so check for HL, IX or IY
0B1DBF 15 
             2394** ;
0B1DC0 CD    2395** GROUP05_1:		CALL    REGLO			; Handle ADD A,?
0B1DC1 ED 
0B1DC2 20 
0B1DC3 0B 
0B1DC4 79    2396** LD      A,C
0B1DC5 30    2397** JR      NC,BIND1		; If it is a register, then write that out
0B1DC6 2E 
0B1DC7 EE    2398** XOR     46H			; Handle ADD A,n
0B1DC8 46 
0B1DC9 CD    2399** CALL    BIND
0B1DCA 8D 
0B1DCB 20 
0B1DCC 0B 
0B1DCD CD    2400** DB_:			CALL    NUMBER
0B1DCE CD 
0B1DCF 20 
0B1DD0 0B 
0B1DD1 C3    2401** JP      VAL8
0B1DD2 86 
0B1DD3 1E 
0B1DD4 0B 
             2402** ;
0B1DD5 E6    2403** GROUP05_HL:		AND     3FH
0B1DD6 3F 
0B1DD7 FE    2404** CP      12
0B1DD8 0C 
0B1DD9 37    2405** SCF
0B1DDA C0    2406** RET     NZ
0B1DDB 79    2407** LD      A,C
0B1DDC FE    2408** CP      80H
0B1DDD 80 
0B1DDE 0E    2409** LD      C,9
0B1DDF 09 
0B1DE0 28    2410** JR      Z,GROUP04_1
0B1DE1 C6 
0B1DE2 EE    2411** XOR     1CH
0B1DE3 1C 
0B1DE4 0F    2412** RRCA
0B1DE5 4F    2413** LD      C,A
0B1DE6 CD    2414** CALL    ED
0B1DE7 87 
0B1DE8 20 
0B1DE9 0B 
0B1DEA 18    2415** JR      GROUP04_1
0B1DEB BC 
             2416** ;
             2417** ; GROUP 7 - INC, DEC
             2418** ;
0B1DEC D6    2419** GROUP07:		SUB     2			; The number of opcodes in GROUP7
0B1DED 02 
0B1DEE 30    2420** JR      NC,GROUP08
0B1DEF 19 
0B1DF0 CD    2421** CALL    REGHI
0B1DF1 F4 
0B1DF2 20 
0B1DF3 0B 
0B1DF4 79    2422** LD      A,C
0B1DF5 D2    2423** BIND1:			JP      NC,BIND
0B1DF6 8D 
0B1DF7 20 
0B1DF8 0B 
0B1DF9 EE    2424** XOR     64H
0B1DFA 64 
0B1DFB 07    2425** RLCA
0B1DFC 07    2426** RLCA
0B1DFD 07    2427** RLCA
0B1DFE 4F    2428** LD      C,A
0B1DFF CD    2429** CALL    PAIR1_EX
0B1E00 14 
0B1E01 21 
0B1E02 0B 
0B1E03 D8    2430** RET     C
0B1E04 79    2431** BYTE0:			LD      A,C
0B1E05 C3    2432** JP      BYTE_
0B1E06 BC 
0B1E07 20 
0B1E08 0B 
             2433** ;
             2434** ; Group 8: IN0, OUT0
             2435** ;
0B1E09 D6    2436** GROUP08:		SUB	2			; The number of opcodes in GROUP8
0B1E0A 02 
0B1E0B 30    2437** JR	NC,GROUP09
0B1E0C 26 
0B1E0D FE    2438** CP	1-2
0B1E0E FF 
0B1E0F CC    2439** CALL    Z,NUMBER		; Fetch number first if OUT
0B1E10 CD 
0B1E11 20 
0B1E12 0B 
0B1E13 08    2440** EX      AF,AF'			; Save flags
0B1E14 CD    2441** CALL    REG			; Get the register value regardless
0B1E15 E1 
0B1E16 20 
0B1E17 0B 
0B1E18 D8    2442** RET     C			; Return if not a register
0B1E19 08    2443** EX      AF,AF'			; Restore the flags
0B1E1A DC    2444** CALL    C,NUMBER		; Fetch number last if IN
0B1E1B CD 
0B1E1C 20 
0B1E1D 0B 
0B1E1E 78    2445** LD	A,B			; Get the register number
0B1E1F FE    2446** CP	6			; Fail on (HL)
0B1E20 06 
0B1E21 37    2447** SCF
0B1E22 C8    2448** RET	Z
0B1E23 FE    2449** CP	8			; Check it is just single pairs only
0B1E24 08 
0B1E25 3F    2450** CCF
0B1E26 D8    2451** RET	C			; And return if it is an invalid register
0B1E27 07    2452** RLCA				; Bind with the operand
0B1E28 07    2453** RLCA
0B1E29 07    2454** RLCA
0B1E2A 81    2455** ADD	A,C
             2456** ; BEGIN NOT IN BINARY
             2457** ; LD	C,A
             2458** ; CALL	ED			; Prefix with ED
             2459** ; LD	A,C
             2460** ; END NOT IN BINARY
0B1E2B CD    2461** CALL	BYTE_			; Write out the operand
0B1E2C BC 
0B1E2D 20 
0B1E2E 0B 
0B1E2F C3    2462** JP	VAL8			; Write out the value
0B1E30 86 
0B1E31 1E 
0B1E32 0B 
             2463** ;
             2464** ; GROUP 9 - IN
             2465** ; GROUP 10 - OUT
             2466** ;
0B1E33 D6    2467** GROUP09:		SUB     2			; The number of opcodes in GROUP09 amd GROUP10
0B1E34 02 
0B1E35 30    2468** JR      NC,GROUP11
0B1E36 25 
0B1E37 FE    2469** CP      1-2			; Check if Group 9 or Group 1
0B1E38 FF 
0B1E39 CC    2470** CALL    Z,CORN			; Call CORN if Group 10 (OUT)
0B1E3A 7B 
0B1E3B 20 
0B1E3C 0B 
0B1E3D 08    2471** EX      AF,AF'			; Save flags
0B1E3E CD    2472** CALL    REGHI			; Get the register value regardless
0B1E3F F4 
0B1E40 20 
0B1E41 0B 
0B1E42 D8    2473** RET     C			; Return if not a register
0B1E43 08    2474** EX      AF,AF'			; Restore the flags
0B1E44 DC    2475** CALL    C,CORN			; Call CORN if Group 9 (IN)
0B1E45 7B 
0B1E46 20 
0B1E47 0B 
0B1E48 24    2476** INC     H			; If it is IN r,(C) or OUT (C),r then
0B1E49 28    2477** JR      Z,BYTE0			; Just write the operand out
0B1E4A B9 
             2478** ;
0B1E4B 78    2479** LD      A,B			; Check the register
0B1E4C FE    2480** CP      7
0B1E4D 07 
0B1E4E 37    2481** SCF
0B1E4F C0    2482** RET     NZ			; If it is not A, then return
             2483** ;
0B1E50 79    2484** LD      A,C			; Bind the register with the operand
0B1E51 EE    2485** XOR     3
0B1E52 03 
0B1E53 07    2486** RLCA
0B1E54 07    2487** RLCA
0B1E55 07    2488** RLCA
0B1E56 CD    2489** CALL    BYTE_			; Write out the operand
0B1E57 BC 
0B1E58 20 
0B1E59 0B 
0B1E5A 18    2490** JR      VAL8			; And the value
0B1E5B 2A 
             2491** ;
             2492** ; GROUP 11 - JR, DJNZ
             2493** ;
0B1E5C D6    2494** GROUP11:		SUB     2			; The number of opcodes in GROUP11
0B1E5D 02 
0B1E5E 30    2495** JR      NC,GROUP12
0B1E5F 2B 
0B1E60 FE    2496** CP      1-2
0B1E61 FF 
0B1E62 C4    2497** CALL    NZ,COND_
0B1E63 FB 
0B1E64 20 
0B1E65 0B 
0B1E66 79    2498** LD      A,C
0B1E67 30    2499** JR      NC,@F
0B1E68 02 
0B1E69 3E    2500** LD      A,18H
0B1E6A 18 
0B1E6B CD    2501** @@:			CALL    BYTE_
0B1E6C BC 
0B1E6D 20 
0B1E6E 0B 
0B1E6F CD    2502** CALL    NUMBER
0B1E70 CD 
0B1E71 20 
0B1E72 0B 
0B1E73 ED    2503** LD      DE,(PC)
0B1E74 5B 
0B1E75 40 
0B1E76 50 
0B1E76 0B   
0B1E78 13    2504** INC     DE
0B1E79 37    2505** SCF
0B1E7A ED    2506** SBC     HL,DE
0B1E7B 52 
0B1E7C 7D    2507** LD      A,L
0B1E7D 17    2508** RLA
0B1E7E 9F    2509** SBC     A,A
0B1E7F BC    2510** CP      H
0B1E80 3E    2511** TOOFAR:			LD      A,1
0B1E81 01 
0B1E82 C2    2512** JP      NZ,ERROR_		; Throw an "Out of range" error
0B1E83 2A 
0B1E84 3B 
0B1E85 0B 
0B1E86 7D    2513** VAL8:			LD      A,L
0B1E87 C3    2514** JP      BYTE_
0B1E88 BC 
0B1E89 20 
0B1E8A 0B 
             2515** ;
             2516** ; GROUP 12 - JP
             2517** ;
0B1E8B D6    2518** GROUP12:		SUB	1			; The number of opcodes in GROUP12
0B1E8C 01 
0B1E8D 30    2519** JR	NC,GROUP13
0B1E8E 21 
0B1E8F CD    2520** CALL	EZ80SF_PART		; Evaluate the suffix (just LIL and SIS)
0B1E90 E1 
0B1E91 1F 
0B1E92 0B 
0B1E93 D8    2521** RET	C			; Exit if an invalid suffix is provided
0B1E94 CD    2522** CALL    COND_			; Evaluate the conditions
0B1E95 FB 
0B1E96 20 
0B1E97 0B 
0B1E98 79    2523** LD      A,C
0B1E99 30    2524** JR      NC,GROUP12_1
0B1E9A 0D 
0B1E9B 78    2525** LD      A,B
0B1E9C E6    2526** AND     3FH
0B1E9D 3F 
0B1E9E FE    2527** CP      6
0B1E9F 06 
0B1EA0 3E    2528** LD      A,0E9H
0B1EA1 E9 
0B1EA2 CA    2529** JP      Z,BYTE_
0B1EA3 BC 
0B1EA4 20 
0B1EA5 0B 
0B1EA6 3E    2530** LD      A,0C3H
0B1EA7 C3 
0B1EA8 CD    2531** GROUP12_1:		CALL    BYTE_			; Output the opcode (with conditions)
0B1EA9 BC 
0B1EAA 20 
0B1EAB 0B 
0B1EAC C3    2532** JP	ADDR_			; Output the address
0B1EAD 36 
0B1EAE 20 
0B1EAF 0B 
             2533** ;
             2534** ; GROUP 13 - CALL
             2535** ;
0B1EB0 D6    2536** GROUP13:		SUB	1			; The number of opcodes in GROUP13
0B1EB1 01 
0B1EB2 30    2537** JR	NC,GROUP14
0B1EB3 0C 
0B1EB4 CD    2538** GROUP13_1:		CALL	EZ80SF_FULL		; Evaluate the suffix
0B1EB5 F9 
0B1EB6 1F 
0B1EB7 0B 
0B1EB8 CD    2539** CALL    GROUP15_1		; Output the opcode (with conditions)
0B1EB9 DB 
0B1EBA 1E 
0B1EBB 0B 
0B1EBC C3    2540** JP	ADDR_			; Output the address
0B1EBD 36 
0B1EBE 20 
0B1EBF 0B 
             2541** ;
             2542** ; GROUP 14 - RST
             2543** ;
0B1EC0 D6    2544** GROUP14:		SUB	1			; The number of opcodes in GROUP14
0B1EC1 01 
0B1EC2 30    2545** JR	NC,GROUP15
0B1EC3 13 
0B1EC4 CD    2546** CALL	EZ80SF_FULL		; Evaluate the suffix
0B1EC5 F9 
0B1EC6 1F 
0B1EC7 0B 
0B1EC8 D8    2547** RET	C			; Exit if an invalid suffix provided
0B1EC9 CD    2548** CALL    NUMBER
0B1ECA CD 
0B1ECB 20 
0B1ECC 0B 
0B1ECD A1    2549** AND     C
0B1ECE B4    2550** OR      H
0B1ECF 20    2551** JR      NZ,TOOFAR
0B1ED0 AF 
0B1ED1 7D    2552** LD      A,L
0B1ED2 B1    2553** OR      C
0B1ED3 C3    2554** JP      BYTE_
0B1ED4 BC 
0B1ED5 20 
0B1ED6 0B 
             2555** ;
             2556** ; GROUP 15 - RET
             2557** ;
0B1ED7 D6    2558** GROUP15:		SUB	1			; The number of opcodes in GROUP15
0B1ED8 01 
0B1ED9 30    2559** JR	NC,GROUP16
0B1EDA 0F 
0B1EDB CD    2560** GROUP15_1:		CALL    COND_
0B1EDC FB 
0B1EDD 20 
0B1EDE 0B 
0B1EDF 79    2561** LD      A,C
0B1EE0 D2    2562** JP      NC,BYTE_
0B1EE1 BC 
0B1EE2 20 
0B1EE3 0B 
0B1EE4 F6    2563** OR      9
0B1EE5 09 
0B1EE6 C3    2564** JP      BYTE_
0B1EE7 BC 
0B1EE8 20 
0B1EE9 0B 
             2565** ;
             2566** ; GROUP 16 - LD
             2567** ;
0B1EEA D6    2568** GROUP16:		SUB	1			; The number of opcodes in GROUP16
0B1EEB 01 
0B1EEC 30    2569** JR	NC,GROUP17
0B1EED 74 
0B1EEE CD    2570** CALL	EZ80SF_FULL		; Evaluate the suffix
0B1EEF F9 
0B1EF0 1F 
0B1EF1 0B 
0B1EF2 CD    2571** CALL    LDOP			; Check for accumulator loads
0B1EF3 2A 
0B1EF4 21 
0B1EF5 0B 
0B1EF6 D2    2572** JP      NC,LDA			; Yes, so jump here
0B1EF7 56 
0B1EF8 20 
0B1EF9 0B 
0B1EFA CD    2573** CALL    REGHI
0B1EFB F4 
0B1EFC 20 
0B1EFD 0B 
0B1EFE 08    2574** EX      AF,AF'
0B1EFF CD    2575** CALL    SKIP
0B1F00 7F 
0B1F01 21 
0B1F02 0B 
0B1F03 FE    2576** CP      '('			; Check for bracket
0B1F04 28 
0B1F05 28    2577** JR      Z,LDIN			; Yes, so we're doing an indirect load from memory
0B1F06 24 
0B1F07 08    2578** EX      AF,AF'
0B1F08 D2    2579** JP      NC,GROUP05_1		; Load single register direct; go here
0B1F09 C0 
0B1F0A 1D 
0B1F0B 0B 
0B1F0C 0E    2580** LD      C,1
0B1F0D 01 
0B1F0E CD    2581** CALL    PAIR1_EX
0B1F0F 14 
0B1F10 21 
0B1F11 0B 
0B1F12 D8    2582** RET     C
0B1F13 3E    2583** LD      A,14
0B1F14 0E 
0B1F15 B8    2584** CP      B
0B1F16 47    2585** LD      B,A
0B1F17 CC    2586** CALL    Z,PAIR_EX
0B1F18 0F 
0B1F19 21 
0B1F1A 0B 
0B1F1B 78    2587** LD      A,B
0B1F1C E6    2588** AND     3FH
0B1F1D 3F 
0B1F1E FE    2589** CP      12
0B1F1F 0C 
0B1F20 79    2590** LD      A,C
0B1F21 C2    2591** JP      NZ,GROUP12_1		; Load register pair direct; go here
0B1F22 A8 
0B1F23 1E 
0B1F24 0B 
0B1F25 3E    2592** LD      A,0F9H
0B1F26 F9 
0B1F27 C3    2593** JP      BYTE_
0B1F28 BC 
0B1F29 20 
0B1F2A 0B 
             2594** ;
0B1F2B 08    2595** LDIN:			EX      AF,AF'
0B1F2C C5    2596** PUSH    BC
0B1F2D D4    2597** CALL    NC,REGLO
0B1F2E ED 
0B1F2F 20 
0B1F30 0B 
0B1F31 79    2598** LD      A,C
0B1F32 C1    2599** POP     BC
0B1F33 D2    2600** JP      NC,BIND
0B1F34 8D 
0B1F35 20 
0B1F36 0B 
0B1F37 0E    2601** LD      C,0AH
0B1F38 0A 
0B1F39 CD    2602** CALL    PAIR1_EX
0B1F3A 14 
0B1F3B 21 
0B1F3C 0B 
0B1F3D CD    2603** CALL    LD16
0B1F3E 61 
0B1F3F 20 
0B1F40 0B 
0B1F41 D2    2604** JP      NC,GROUP12_1
0B1F42 A8 
0B1F43 1E 
0B1F44 0B 
0B1F45 CD    2605** CALL    NUMBER
0B1F46 CD 
0B1F47 20 
0B1F48 0B 
0B1F49 0E    2606** LD      C,2
0B1F4A 02 
0B1F4B CD    2607** CALL    PAIR_EX
0B1F4C 0F 
0B1F4D 21 
0B1F4E 0B 
0B1F4F CD    2608** CALL    LD16
0B1F50 61 
0B1F51 20 
0B1F52 0B 
0B1F53 D8    2609** RET     C
0B1F54 CD    2610** CALL    BYTE_
0B1F55 BC 
0B1F56 20 
0B1F57 0B 
0B1F58 CB    2611** BIT	7,D			; Check the ADL flag
0B1F59 7A 
0B1F5A C2    2612** JP	NZ,VAL24 		; If it is set, then use 24-bit addresses
0B1F5B 4B 
0B1F5C 20 
0B1F5D 0B 
0B1F5E C3    2613** JP      VAL16			; Otherwise use 16-bit addresses
0B1F5F 3E 
0B1F60 20 
0B1F61 0B 
             2614** ;
             2615** ; Group 17 - TST
             2616** ;
0B1F62 D6    2617** GROUP17:		SUB	1			; The number of opcodes in GROUP17
0B1F63 01 
0B1F64 30    2618** JR	NC,OPTS
0B1F65 25 
0B1F66 CD    2619** CALL	ED			; Needs to be prefixed with ED
0B1F67 87 
0B1F68 20 
0B1F69 0B 
0B1F6A CD    2620** CALL	REG			; Fetch the register
0B1F6B E1 
0B1F6C 20 
0B1F6D 0B 
0B1F6E 30    2621** JR	NC,GROUP17_1		; It's just a register
0B1F6F 0E 
             2622** ;
0B1F70 3E    2623** LD	A,64H			; Opcode for TST n
0B1F71 64 
0B1F72 CD    2624** CALL	BYTE_			; Write out the opcode
0B1F73 BC 
0B1F74 20 
0B1F75 0B 
0B1F76 CD    2625** CALL	NUMBER			; Get the number
0B1F77 CD 
0B1F78 20 
0B1F79 0B 
0B1F7A C3    2626** JP	VAL8			; And write that out
0B1F7B 86 
0B1F7C 1E 
0B1F7D 0B 
             2627** ;
0B1F7E 78    2628** GROUP17_1:		LD	A,B			; Check the register rangs
0B1F7F FE    2629** CP	8
0B1F80 08 
0B1F81 3F    2630** CCF
0B1F82 D8    2631** RET	C			; Ret with carry flag set for error if out of range
0B1F83 07    2632** RLCA				; Get the opcode value
0B1F84 07    2633** RLCA
0B1F85 07    2634** RLCA
0B1F86 81    2635** ADD	A,C			; Add the opcode base in
0B1F87 C3    2636** JP	BYTE_
0B1F88 BC 
0B1F89 20 
0B1F8A 0B 
             2637** 
             2638** ;
             2639** ; Assembler directives - OPT, ADL
             2640** ;
0B1F8B D6    2641** OPTS:			SUB	2
0B1F8C 02 
0B1F8D 30    2642** JR	NC, DEFS
0B1F8E 2B 
0B1F8F FE    2643** CP	1-2			; Check for ADL opcode
0B1F90 FF 
0B1F91 28    2644** JR	Z, ADL_
0B1F92 13 
             2645** ;
0B1F93 CD    2646** OPT:			CALL    NUMBER			; Fetch the OPT value
0B1F94 CD 
0B1F95 20 
0B1F96 0B 
0B1F97 21    2647** LD      HL,LISTON		; Address of the LISTON/OPT flag
0B1F98 40 
0B1F99 51 
0B1F9A 0B 
0B1F9B E6    2648** AND	7			; Only interested in the first three bits
0B1F9C 07 
0B1F9D 4F    2649** LD      C,A			; Store the new OPT value in C
0B1F9E ED    2650** RLD				; Shift the top nibble of LISTON (OPT) into A
0B1F9F 6F 
0B1FA0 E6    2651** AND	8			; Clear the bottom three bits, preserving the ADL bit
0B1FA1 08 
0B1FA2 B1    2652** OR	C			; OR in the new value
0B1FA3 ED    2653** RRD				; And shift the nibble back in
0B1FA4 67 
0B1FA5 C9    2654** RET
             2655** ;
0B1FA6 CD    2656** ADL_:			CALL	NUMBER			; Fetch the ADL value
0B1FA7 CD 
0B1FA8 20 
0B1FA9 0B 
0B1FAA E6    2657** AND	1			; Only interested if it is 0 or 1
0B1FAB 01 
0B1FAC 0F    2658** RRCA				; Rotate to bit 7
0B1FAD 4F    2659** LD	C,A			; Store in C
0B1FAE 3A    2660** LD	A,(LISTON)		; Get the LISTON system variable
0B1FAF 40 
0B1FB0 51 
0B1FB1 0B 
0B1FB2 E6    2661** AND	7Fh			; Clear bit 7
0B1FB3 7F 
0B1FB4 B1    2662** OR	C			; OR in the ADL value
0B1FB5 32    2663** LD	(LISTON),A		; Store
0B1FB6 40 
0B1FB7 51 
0B1FB8 0B 
0B1FB9 C9    2664** RET
             2665** ;
             2666** ; DEFB, DEFW, DEFL, DEFM
             2667** ;
0B1FBA B7    2668** DEFS:			OR	A			; Handle DEFB
0B1FBB CA    2669** JP	Z, DB_
0B1FBC CD 
0B1FBD 1D 
0B1FBE 0B 
0B1FBF 3D    2670** DEC	A			; Handle DEFW
0B1FC0 CA    2671** JP	Z, ADDR16
0B1FC1 3A 
0B1FC2 20 
0B1FC3 0B 
0B1FC4 3D    2672** DEC	A			; Handle DEFL
0B1FC5 CA    2673** JP	Z, ADDR24
0B1FC6 47 
0B1FC7 20 
0B1FC8 0B 
             2674** ;
0B1FC9 DD    2675** PUSH    IX			; Handle DEFM
0B1FCA E5 
0B1FCB CD    2676** CALL    EXPRS
0B1FCC DF 
0B1FCD 06 
0B1FCE 0B 
0B1FCF DD    2677** POP     IX
0B1FD0 E1 
0B1FD1 21    2678** LD      HL,ACCS
0B1FD2 00 
0B1FD3 4E 
0B1FD4 0B 
0B1FD5 AF    2679** @@:			XOR     A
0B1FD6 BB    2680** CP      E
0B1FD7 C8    2681** RET     Z
0B1FD8 7E    2682** LD      A,(HL)
0B1FD9 23    2683** INC     HL
0B1FDA CD    2684** CALL    BYTE_
0B1FDB BC 
0B1FDC 20 
0B1FDD 0B 
0B1FDE 1D    2685** DEC     E
0B1FDF 18    2686** JR      @B
0B1FE0 F4 
             2687** 
             2688** ;
             2689** ;SUBROUTINES:
             2690** ;
0B1FE1 FD    2691** EZ80SF_PART:		LD	A,(IY)			; Check for a dot
0B1FE2 7E 
0B1FE3 00 
0B1FE4 FE    2692** CP	'.'
0B1FE5 2E 
0B1FE6 28    2693** JR	Z, @F			; If present, then carry on processing the eZ80 suffix
0B1FE7 02 
0B1FE8 B7    2694** OR	A			; Reset the carry flag (no error)
0B1FE9 C9    2695** RET				; And return
0B1FEA FD    2696** @@:			INC	IY			; Skip the dot
0B1FEB 23 
0B1FEC C5    2697** PUSH	BC			; Push the operand
0B1FED 21    2698** LD	HL,EZ80SFS_2		; Check the shorter fully qualified table (just LIL and SIS)
0B1FEE 15 
0B1FEF 24 
0B1FF0 0B 
0B1FF1 CD    2699** CALL	FIND			; Look up the operand
0B1FF2 2E 
0B1FF3 21 
0B1FF4 0B 
0B1FF5 30    2700** JR	NC,EZ80SF_OK
0B1FF6 24 
0B1FF7 C1    2701** POP	BC			; Not found at this point, so will return with a C (error)
0B1FF8 C9    2702** RET
             2703** ;
0B1FF9 FD    2704** EZ80SF_FULL:		LD	A,(IY)			; Check for a dot
0B1FFA 7E 
0B1FFB 00 
0B1FFC FE    2705** CP	'.'
0B1FFD 2E 
0B1FFE 28    2706** JR	Z,@F			; If present, then carry on processing the eZ80 suffix
0B1FFF 02 
0B2000 B7    2707** OR	A			; Reset the carry flag (no error)
0B2001 C9    2708** RET				; And return
0B2002 FD    2709** @@:			INC	IY 			; Skip the dot
0B2003 23 
0B2004 C5    2710** PUSH	BC			; Push the operand
0B2005 21    2711** LD	HL,EZ80SFS_1		; First check the fully qualified table
0B2006 0D 
0B2007 24 
0B2008 0B 
0B2009 CD    2712** CALL	FIND 			; Look up the operand
0B200A 2E 
0B200B 21 
0B200C 0B 
0B200D 30    2713** JR	NC,EZ80SF_OK		; Yes, we've found it, so go write it out
0B200E 0C 
0B200F CD    2714** CALL	EZ80SF_TABLE		; Get the correct shortcut table in HL based upon the ADL mode
0B2010 2A 
0B2011 20 
0B2012 0B 
0B2013 CD    2715** CALL	FIND
0B2014 2E 
0B2015 21 
0B2016 0B 
0B2017 30    2716** JR	NC,EZ80SF_OK
0B2018 02 
0B2019 C1    2717** POP	BC			; Not found at this point, so will return with a C (error)
0B201A C9    2718** RET
             2719** ;
0B201B 78    2720** EZ80SF_OK:		LD	A,B			; The operand value
0B201C D4    2721** CALL	NC,BYTE_ 		; Write it out if found
0B201D BC 
0B201E 20 
0B201F 0B 
0B2020 CB    2722** RES	7,D			; Clear the default ADL mode from the flags
0B2021 BA 
0B2022 E6    2723** AND	2			; Check the second half of the suffix (.xxL)
0B2023 02 
0B2024 0F    2724** RRCA				; Shift into bit 7
0B2025 0F    2725** RRCA
0B2026 B2    2726** OR	D			; Or into bit 7 of D
0B2027 57    2727** LD	D,A
0B2028 C1    2728** POP	BC 			; Restore the operand
0B2029 C9    2729** RET
             2730** ;
0B202A 21    2731** EZ80SF_TABLE:		LD	HL,EZ80SFS_ADL0		; Return with the ADL0 lookup table
0B202B 1E 
0B202C 24 
0B202D 0B 
0B202E CB    2732** BIT 	7,D			; if bit 7 of D is 0
0B202F 7A 
0B2030 C8    2733** RET	Z
0B2031 21    2734** LD	HL,EZ80SFS_ADL1		; Otherwise return with the ADL1 lookup table
0B2032 29 
0B2033 24 
0B2034 0B 
0B2035 C9    2735** RET
             2736** ;
0B2036 CB    2737** ADDR_:			BIT	7,D			; Check the ADL flag
0B2037 7A 
0B2038 20    2738** JR	NZ,ADDR24 		; If it is set, then use 24-bit addresses
0B2039 0D 
             2739** ;
0B203A CD    2740** ADDR16:			CALL	NUMBER			; Fetch an address (16-bit) and fall through to VAL16
0B203B CD 
0B203C 20 
0B203D 0B 
0B203E CD    2741** VAL16:			CALL    VAL8			; Write out a 16-bit value (HL)
0B203F 86 
0B2040 1E 
0B2041 0B 
0B2042 7C    2742** LD      A,H
0B2043 C3    2743** JP      BYTE_
0B2044 BC 
0B2045 20 
0B2046 0B 
             2744** ;
0B2047 CD    2745** ADDR24:			CALL    NUMBER			; Fetch an address (24-bit) and fall through to VAL24
0B2048 CD 
0B2049 20 
0B204A 0B 
0B204B CD    2746** VAL24:			CALL	VAL16			; Lower 16-bits are in HL
0B204C 3E 
0B204D 20 
0B204E 0B 
0B204F D9    2747** EXX
0B2050 7D    2748** LD	A,L			; Upper 16-bits are in HL', just need L' to make up 24-bit value
0B2051 D9    2749** EXX
0B2052 C3    2750** JP	BYTE_
0B2053 BC 
0B2054 20 
0B2055 0B 
             2751** ;
0B2056 FE    2752** LDA:			CP      4
0B2057 04 
0B2058 DC    2753** CALL    C,ED
0B2059 87 
0B205A 20 
0B205B 0B 
0B205C 78    2754** LD      A,B
0B205D C3    2755** JP      BYTE_
0B205E BC 
0B205F 20 
0B2060 0B 
             2756** ;
0B2061 78    2757** LD16:			LD      A,B
0B2062 38    2758** JR      C,LD8
0B2063 0F 
0B2064 78    2759** LD      A,B
0B2065 E6    2760** AND     3FH
0B2066 3F 
0B2067 FE    2761** CP      12
0B2068 0C 
0B2069 79    2762** LD      A,C
0B206A C8    2763** RET     Z
0B206B CD    2764** CALL    ED
0B206C 87 
0B206D 20 
0B206E 0B 
0B206F 79    2765** LD      A,C
0B2070 F6    2766** OR      43H
0B2071 43 
0B2072 C9    2767** RET
             2768** ;
0B2073 FE    2769** LD8:			CP      7
0B2074 07 
0B2075 37    2770** SCF
0B2076 C0    2771** RET     NZ
0B2077 79    2772** LD      A,C
0B2078 F6    2773** OR      30H
0B2079 30 
0B207A C9    2774** RET
             2775** ;
             2776** ; Used in IN and OUT to handle whether the operand is C or a number
             2777** ;
0B207B C5    2778** CORN:			PUSH    BC
0B207C CD    2779** CALL    OPND			; Get the operand
0B207D 9B 
0B207E 20 
0B207F 0B 
0B2080 CB    2780** BIT     5,B
0B2081 68 
0B2082 C1    2781** POP     BC
0B2083 28    2782** JR      Z,NUMBER		; If bit 5 is clear, then it's IN A,(N) or OUT (N),A, so fetch the port number
0B2084 48 
0B2085 26    2783** LD      H,-1			; At this point it's IN r,(C) or OUT (C),r, so flag by setting H to &FF
0B2086 FF 
             2784** ;
0B2087 3E    2785** ED:			LD      A,0EDH			; Write an ED prefix out
0B2088 ED 
0B2089 18    2786** JR      BYTE_
0B208A 31 
             2787** ;
0B208B 3E    2788** CB:			LD      A,0CBH
0B208C CB 
0B208D FE    2789** BIND:			CP      76H
0B208E 76 
0B208F 37    2790** SCF
0B2090 C8    2791** RET     Z               	; Reject LD (HL),(HL)
0B2091 CD    2792** CALL    BYTE_
0B2092 BC 
0B2093 20 
0B2094 0B 
0B2095 CB    2793** BIT	6,D			; Check the index bit in flags
0B2096 72 
0B2097 C8    2794** RET     Z
0B2098 7B    2795** LD      A,E			; If there is an index, output the offset
0B2099 18    2796** JR      BYTE_
0B209A 21 
             2797** ;
             2798** ; Search through the operand table
             2799** ; Returns:
             2800** ; - B: The operand type
             2801** ; - D: Bit 7: 0 = no prefix, 1 = prefix
             2802** ; - E: The IX/IY offset
             2803** ; - F: Carry if not found
             2804** ;
0B209B E5    2805** OPND:			PUSH    HL			; Preserve HL
0B209C 21    2806** LD      HL,OPRNDS		; The operands table
0B209D 9F 
0B209E 23 
0B209F 0B 
0B20A0 CD    2807** CALL    FIND			; Find the operand
0B20A1 2E 
0B20A2 21 
0B20A3 0B 
0B20A4 E1    2808** POP     HL
0B20A5 D8    2809** RET     C			; Return if not found
0B20A6 CB    2810** BIT     7,B			; Check if it is an index register (IX, IY)
0B20A7 78 
0B20A8 C8    2811** RET     Z			; Return if it isn't
0B20A9 CB    2812** SET	6,D			; Set flag to indicate we've got an index
0B20AA F2 
0B20AB CB    2813** BIT     3,B			; Check if an offset is required
0B20AC 58 
0B20AD E5    2814** PUSH    HL
0B20AE CC    2815** CALL    Z,OFFSET_EX		; If bit 3 of B is zero, then get the offset
0B20AF C3 
0B20B0 20 
0B20B1 0B 
0B20B2 5D    2816** LD      E,L			; E: The offset
0B20B3 E1    2817** POP     HL
0B20B4 3E    2818** LD	A,DDH			; IX prefix
0B20B5 DD 
0B20B6 CB    2819** BIT     6,B			; If bit 6 is reset then
0B20B7 70 
0B20B8 28    2820** JR      Z,BYTE_			; It's an IX instruction, otherwise set
0B20B9 02 
0B20BA 3E    2821** LD	A,FDH			; IY prefix
0B20BB FD 
             2822** ;
0B20BC DD    2823** BYTE_:			LD      (IX),A			; Write a byte out
0B20BD 77 
0B20BE 00 
0B20BF DD    2824** INC     IX
0B20C0 23 
0B20C1 B7    2825** OR      A
0B20C2 C9    2826** RET
             2827** ;
0B20C3 FD    2828** OFFSET_EX:			LD      A,(IY)
0B20C4 7E 
0B20C5 00 
0B20C6 FE    2829** CP      ')'
0B20C7 29 
0B20C8 21    2830** LD      HL,0
0B20C9 00 
0B20CA 00 
0B20CB 00 
0B20CC C8    2831** RET     Z
0B20CD CD    2832** NUMBER:			CALL    SKIP
0B20CE 7F 
0B20CF 21 
0B20D0 0B 
0B20D1 C5    2833** PUSH    BC
0B20D2 D5    2834** PUSH    DE
0B20D3 DD    2835** PUSH    IX
0B20D4 E5 
0B20D5 CD    2836** CALL    EXPRI
0B20D6 D4 
0B20D7 06 
0B20D8 0B 
0B20D9 DD    2837** POP     IX
0B20DA E1 
0B20DB D9    2838** EXX
0B20DC D1    2839** POP     DE
0B20DD C1    2840** POP     BC
0B20DE 7D    2841** LD      A,L
0B20DF B7    2842** OR      A
0B20E0 C9    2843** RET
             2844** ;
0B20E1 CD    2845** REG:			CALL    OPND
0B20E2 9B 
0B20E3 20 
0B20E4 0B 
0B20E5 D8    2846** RET     C
0B20E6 78    2847** LD      A,B
0B20E7 E6    2848** AND     3FH
0B20E8 3F 
0B20E9 FE    2849** CP      8
0B20EA 08 
0B20EB 3F    2850** CCF
0B20EC C9    2851** RET
             2852** ;
0B20ED CD    2853** REGLO:			CALL    REG
0B20EE E1 
0B20EF 20 
0B20F0 0B 
0B20F1 D8    2854** RET     C
0B20F2 18    2855** JR      ORC
0B20F3 33 
             2856** ;
0B20F4 CD    2857** REGHI:			CALL    REG
0B20F5 E1 
0B20F6 20 
0B20F7 0B 
0B20F8 D8    2858** RET     C
0B20F9 18    2859** JR      SHL3
0B20FA 29 
             2860** ;
0B20FB CD    2861** COND_:			CALL    OPND
0B20FC 9B 
0B20FD 20 
0B20FE 0B 
0B20FF D8    2862** RET     C
0B2100 78    2863** LD      A,B
0B2101 E6    2864** AND     1FH
0B2102 1F 
0B2103 D6    2865** SUB     16
0B2104 10 
0B2105 30    2866** JR      NC,SHL3
0B2106 1D 
0B2107 FE    2867** CP      -15
0B2108 F1 
0B2109 37    2868** SCF
0B210A C0    2869** RET     NZ
0B210B 3E    2870** LD      A,3
0B210C 03 
0B210D 18    2871** JR      SHL3
0B210E 15 
             2872** ;
0B210F CD    2873** PAIR_EX:			CALL    OPND
0B2110 9B 
0B2111 20 
0B2112 0B 
0B2113 D8    2874** RET     C
0B2114 78    2875** PAIR1_EX:			LD      A,B
0B2115 E6    2876** AND     0FH
0B2116 0F 
0B2117 D6    2877** SUB     8
0B2118 08 
0B2119 D8    2878** RET     C
0B211A 18    2879** JR      SHL3
0B211B 08 
             2880** ;
0B211C CD    2881** BIT_:			CALL    NUMBER
0B211D CD 
0B211E 20 
0B211F 0B 
0B2120 FE    2882** CP      8
0B2121 08 
0B2122 3F    2883** CCF
0B2123 D8    2884** RET     C
0B2124 07    2885** SHL3:			RLCA
0B2125 07    2886** RLCA
0B2126 07    2887** RLCA
0B2127 B1    2888** ORC:			OR      C
0B2128 4F    2889** LD      C,A
0B2129 C9    2890** RET
             2891** ;
0B212A 21    2892** LDOP:			LD      HL,LDOPS
0B212B E4 
0B212C 23 
0B212D 0B 
             2893** 
             2894** ;
             2895** ; Look up a value in a table
             2896** ; Parameters:
             2897** ; - IY: Address of the assembly language line in the BASIC program area
             2898** ; - HL: Address of the table
             2899** ; Returns:
             2900** ; - B: The operand code
             2901** ; - F: Carry set if not found
             2902** ;
0B212E CD    2903** FIND:			CALL    SKIP			; Skip delimiters
0B212F 7F 
0B2130 21 
0B2131 0B 
             2904** ;
0B2132 06    2905** EXIT_:			LD      B,0			; Set B to 0
0B2133 00 
0B2134 37    2906** SCF				; Set the carry flag
0B2135 C8    2907** RET     Z			; Returns if Z
             2908** ;
0B2136 FE    2909** CP      DEF_			; Special case for token DEF (used in DEFB, DEFW, DEFL, DEFM)
0B2137 DD 
0B2138 28    2910** JR      Z,FIND0
0B2139 04 
0B213A FE    2911** CP      TOR+1			; Special case for tokens AND and OR
0B213B 85 
0B213C 3F    2912** CCF
0B213D D8    2913** RET     C
0B213E 7E    2914** FIND0:			LD      A,(HL)			; Check for the end of the table (0 byte marker)
0B213F B7    2915** OR      A
0B2140 28    2916** JR      Z,EXIT_			; Exit
0B2141 F0 
0B2142 FD    2917** XOR     (IY)
0B2143 AE 
0B2144 00 
0B2145 E6    2918** AND     01011111B
0B2146 5F 
0B2147 28    2919** JR      Z,FIND2
0B2148 09 
0B2149 CB    2920** FIND1:			BIT     7,(HL)
0B214A 7E 
0B214B 23    2921** INC     HL
0B214C 28    2922** JR      Z,FIND1
0B214D FB 
0B214E 23    2923** INC     HL
0B214F 04    2924** INC     B
0B2150 18    2925** JR      FIND0
0B2151 EC 
             2926** ;
0B2152 FD    2927** FIND2:			PUSH    IY
0B2153 E5 
0B2154 CB    2928** FIND3:			BIT     7,(HL)			; Is this the end of token marker?
0B2155 7E 
0B2156 FD    2929** INC     IY
0B2157 23 
0B2158 23    2930** INC     HL
0B2159 20    2931** JR      NZ,FIND5		; Yes
0B215A 11 
0B215B BE    2932** CP      (HL)
0B215C CC    2933** CALL    Z,SKIP0
0B215D 7E 
0B215E 21 
0B215F 0B 
0B2160 7E    2934** LD      A,(HL)
0B2161 FD    2935** XOR     (IY)
0B2162 AE 
0B2163 00 
0B2164 E6    2936** AND     01011111B
0B2165 5F 
0B2166 28    2937** JR      Z,FIND3
0B2167 EC 
0B2168 FD    2938** FIND4:			POP     IY
0B2169 E1 
0B216A 18    2939** JR      FIND1
0B216B DD 
             2940** ;
0B216C CD    2941** FIND5:			CALL    DELIM			; Is it a delimiter?
0B216D 30 
0B216E 1B 
0B216F 0B 
0B2170 C4    2942** CALL	NZ,DOT 			; No, so also check whether it is a dot character (for suffixes)
0B2171 93 
0B2172 21 
0B2173 0B 
0B2174 C4    2943** CALL    NZ,SIGN			; No, so also check whether it is a SIGN character ('+' or '-')
0B2175 8D 
0B2176 21 
0B2177 0B 
0B2178 20    2944** JR      NZ,FIND4		; If it is not a sign or a delimiter, then loop
0B2179 EE 
             2945** ;
0B217A 78    2946** FIND6:			LD      A,B			; At this point we have a token
0B217B 46    2947** LD      B,(HL)			; Fetch the token type code
0B217C E1    2948** POP     HL			; Restore the stack
0B217D C9    2949** RET
             2950** ;
0B217E 23    2951** SKIP0:			INC     HL
0B217F CD    2952** SKIP:			CALL    DELIM			; Is it a delimiter?
0B2180 30 
0B2181 1B 
0B2182 0B 
0B2183 C0    2953** RET     NZ			; No, so return
0B2184 CD    2954** CALL    TERM			; Is it a terminator?
0B2185 3C 
0B2186 1B 
0B2187 0B 
0B2188 C8    2955** RET     Z			; Yes, so return
0B2189 FD    2956** INC     IY			; Increment the basic program counter
0B218A 23 
0B218B 18    2957** JR      SKIP			; And loop
0B218C F2 
             2958** ;
0B218D FE    2959** SIGN:			CP      '+'			; Check whether the character is a sign symbol
0B218E 2B 
0B218F C8    2960** RET     Z
0B2190 FE    2961** CP      '-'
0B2191 2D 
0B2192 C9    2962** RET
             2963** ;
0B2193 FE    2964** DOT:			CP	'.'			; Check if it is a dot character
0B2194 2E 
0B2195 C9    2965** RET
             2966** ; Z80 opcode list
             2967** ;
             2968** ; Group 0: (15 opcodes)
             2969** ; Trivial cases requiring no computation
             2970** ;
             2971** ; BEGIN REFACTOR FROM BINARY
             2972** ; OPCODS:
             2973** ; 			DB	"NO","P"+80H,00h	; # 00h
             2974** ; 			DB	"RLC","A"+80H,07h
             2975** ; 			DB	"EX",0,"AF",0,"AF","'"+80H,08h
             2976** ; 			DB	"RRC","A"+80H,0FH
             2977** ; 			DB	"RL","A"+80H,17H
             2978** ; 			DB	"RR","A"+80H,1FH
             2979** ; 			DB	"DA","A"+80H,27H
             2980** ; 			DB	"CP","L"+80H,2FH
             2981** ; 			DB	"SC","F"+80H,37H
             2982** ; 			DB	"CC","F"+80H,3FH
             2983** ; 			DB	"HAL","T"+80H,76H
             2984** ; 			DB	"EX","X"+80H,D9H
             2985** ; 			DB	"EX",0,"DE",0,"H","L"+80H,EBH
             2986** ; 			DB	"D","I"+80H,F3H
             2987** ; 			DB	"E","I"+80H,FBH
             2988** ; ;
             2989** ; ; Group 1: (53 opcodes)
             2990** ; ; As Group 0, but with an ED prefix
             2991** ; ;
             2992** ; 			DB	"NE","G"+80H,44H	; 0Fh
             2993** ; 			DB	"IM",0,"0"+80H,46H
             2994** ; 			DB	"RET","N"+80H,45H
             2995** ; 			DB	"MLT",0,"B","C"+80H,4CH
             2996** ; 			DB	"RET","I"+80H,4DH
             2997** ; 			DB	"IM",0,"1"+80H,56H
             2998** ; 			DB	"MLT",0,"D","E"+80H,5CH
             2999** ; 			DB	"IM",0,"2"+80H,5EH
             3000** ; 			DB	"RR","D"+80H,67H
             3001** ; 			DB	"MLT",0,"H","L"+80H,6CH
             3002** ; 			DB	"LD",0,"MB",0,"A"+80H,6DH
             3003** ; 			DB	"LD",0,"A",0,"M","B"+80H,6EH
             3004** ; 			DB	"RL","D"+80H,6FH
             3005** ; 			DB	"SL","P"+80H,76H
             3006** ; 			DB	"MLT",0,"S","P"+80H,7CH
             3007** ; 			DB	"STMI","X"+80H,7DH
             3008** ; 			DB	"RSMI","X"+80H,7EH
             3009** ; 			DB	"INI","M"+80H,82H
             3010** ; 			DB	"OTI","M"+80H,83H
             3011** ; 			DB	"INI","2"+80H,84H
             3012** ; 			DB	"IND","M"+80H,8AH
             3013** ; 			DB	"OTD","M"+80H,8BH
             3014** ; 			DB	"IND","2"+80H,8CH
             3015** ; 			DB	"INIM","R"+80H,92H
             3016** ; 			DB	"OTIM","R"+80H,93H
             3017** ; 			DB	"INI2","R"+80H,94H
             3018** ; 			DB	"INDM","R"+80H,9AH
             3019** ; 			DB	"OTDM","R"+80H,9BH
             3020** ; 			DB	"IND2","R"+80H,9CH
             3021** ; 			DB	"LD","I"+80H,A0H
             3022** ; 			DB	"CP","I"+80H,A1H
             3023** ; 			DB	"IN","I"+80H,A2H
             3024** ; 			DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
             3025** ; 			DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
             3026** ; 			DB	"LD","D"+80H,A8H
             3027** ; 			DB	"CP","D"+80H,A9H
             3028** ; 			DB	"IN","D"+80H,AAH
             3029** ; 			DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
             3030** ; 			DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
             3031** ; 			DB	"LDI","R"+80H,B0H
             3032** ; 			DB	"CPI","R"+80H,B1H
             3033** ; 			DB	"INI","R"+80H,B2H
             3034** ; 			DB	"OTI","R"+80H,B3H
             3035** ; 			DB	"OTI2","R"+80H,B4H
             3036** ; 			DB	"LDD","R"+80H,B8H
             3037** ; 			DB	"CPD","R"+80H,B9H
             3038** ; 			DB	"IND","R"+80H,BAH
             3039** ; 			DB	"OTD","R"+80H,BBH
             3040** ; 			DB	"OTD2","R"+80H,BCH
             3041** ; 			DB	"INIR","X"+80H,C2H
             3042** ; 			DB	"OTIR","X"+80H,C3H
             3043** ; 			DB	"INDR","X"+80H,CAH
             3044** ; 			DB	"OTDR","X"+80H,CBH
             3045** ; ;
             3046** ; ; Group 2: (3 opcodes)
             3047** ; ;
             3048** ; 			DB	"BI","T"+80H,40H	; 44h
             3049** ; 			DB	"RE","S"+80H,80H
             3050** ; 			DB	"SE","T"+80H,C0H
             3051** ; ;
             3052** ; ; Group 3: (7 opcodes)
             3053** ; ;
             3054** ; 			DB	"RL","C"+80H,00H	; 47h
             3055** ; 			DB	"RR","C"+80H,08H
             3056** ; 			DB	"R","L"+80H,10H
             3057** ; 			DB	"R","R"+80H,18H
             3058** ; 			DB	"SL","A"+80H,20H
             3059** ; 			DB	"SR","A"+80H,28H
             3060** ; 			DB	"SR","L"+80H,38H
             3061** ; ;
             3062** ; ; Group 4: (3 opcodes)
             3063** ; ;
             3064** ; 			DB	"PO","P"+80H,C1H	; 4Eh
             3065** ; 			DB	"PUS","H"+80H,C5H
             3066** ; 			DB	"EX",0,"(S","P"+80H,E3H
             3067** ; ;
             3068** ; ; Group 5: (7 opcodes)
             3069** ; ;
             3070** ; 			DB	"SU","B"+80H,90H	; 51h
             3071** ; 			DB	"AN","D"+80H,A0H
             3072** ; 			DB	"XO","R"+80H,A8H
             3073** ; 			DB	"O","R"+80H,B0H
             3074** ; 			DB	"C","P"+80H,B8H
             3075** ; 			DB	TAND,A0H		; 56h TAND: Tokenised AND
             3076** ; 			DB	TOR,B0H			; 57h TOR: Tokenised OR
             3077** ; ;
             3078** ; ; Group 6 (3 opcodes)
             3079** ; ;
             3080** ; 			DB	"AD","D"+80H,80H	; 58h
             3081** ; 			DB	"AD","C"+80H,88H
             3082** ; 			DB	"SB","C"+80H,98H
             3083** ; ;
             3084** ; ; Group 7: (2 opcodes)
             3085** ; ;
             3086** ; 			DB	"IN","C"+80H,04H	; 5Bh
             3087** ; 			DB	"DE","C"+80H,05H
             3088** ; ;
             3089** ; ; Group 8: (2 opcodes)
             3090** ; ;
             3091** ; 			DB	"IN","0"+80H,00H	; 5Dh
             3092** ; 			DB	"OUT","0"+80H,01H
             3093** ; ;
             3094** ; ; Group 9: (1 opcode)
             3095** ; ;
             3096** ; 			DB	"I","N"+80H,40H		; 5Fh
             3097** ; ;
             3098** ; ; Group 10: (1 opcode)
             3099** ; ;
             3100** ; 			DB	"OU","T"+80H,41H	; 60h
             3101** ; ;
             3102** ; ; Group 11: (2 opcodes)
             3103** ; ;
             3104** ; 			DB	"J","R"+80H,20H		; 61h
             3105** ; 			DB	"DJN","Z"+80H,10H
             3106** ; ;
             3107** ; ; Group 12: (1 opcode)
             3108** ; ;
             3109** ; 			DB	"J","P"+80H,C2H		; 63h
             3110** ; ;
             3111** ; ; Group 13: (1 opcode)
             3112** ; ;
             3113** ; 			DB	"CAL","L"+80H,C4H	; 64h
             3114** ; ;
             3115** ; ; Group 14: (1 opcode)
             3116** ; ;
             3117** ; 			DB	"RS","T"+80H,C7H	; 65h
             3118** ; ;
             3119** ; ; Group 15: (1 opcode)
             3120** ; ;
             3121** ; 			DB	"RE","T"+80H,C0H	; 66h
             3122** ; ;
             3123** ; ; Group 16: (1 opcode)
             3124** ; ;
             3125** ; 			DB	"L","D"+80H,40H		; 67h
             3126** ; ;
             3127** ; ; Group 17: (1 opcode)
             3128** ; ;
             3129** ; 			DB	"TS","T"+80H,04H	; 68h
             3130** 
             3131** ; ;
             3132** ; ; Assembler Directives
             3133** ; ;
             3134** ; 			DB	"OP","T"+80H,00H	; 69h OPT
             3135** ; 			DB	"AD","L"+80H,00H	; 6Ah ADL
             3136** ; ;
             3137** ; 			DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
             3138** ; 			DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
             3139** ; 			DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
             3140** ; 			DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
             3141** ; ;
             3142** ; 			DB	0
             3143** ; ;
             3144** ; ; Operands
             3145** ; ;
             3146** ; OPRNDS:			DB	"B"+80H, 00H
             3147** ; 			DB	"C"+80H, 01H
             3148** ; 			DB	"D"+80H, 02H
             3149** ; 			DB	"E"+80H, 03H
             3150** ; 			DB	"H"+80H, 04H
             3151** ; 			DB	"L"+80H, 05H
             3152** ; 			DB	"(H","L"+80H,06H
             3153** ; 			DB	"A"+80H, 07H
             3154** ; 			DB	"(I","X"+80H,86H
             3155** ; 			DB	"(I","Y"+80H,C6H
             3156** ; ;
             3157** ; 			DB	"B","C"+80H,08H
             3158** ; 			DB	"D","E"+80H,0AH
             3159** ; 			DB	"H","L"+80H,0CH
             3160** ; 			DB	"I","X"+80H,8CH
             3161** ; 			DB	"I","Y"+80H,CCH
             3162** ; 			DB	"A","F"+80H,0EH
             3163** ; 			DB	"S","P"+80H,0EH
             3164** ; ;
             3165** ; 			DB	"N","Z"+80H,10H
             3166** ; 			DB	"Z"+80H,11H
             3167** ; 			DB	"N","C"+80H,12H
             3168** ; 			DB	"P","O"+80H,14H
             3169** ; 			DB	"P","E"+80H,15H
             3170** ; 			DB	"P"+80H,16H
             3171** ; 			DB	"M"+80H,17H
             3172** ; ;
             3173** ; 			DB	"(","C"+80H,20H
             3174** ; ;
             3175** ; 			DB	0
             3176** ; ;
             3177** ; ; Load operations
             3178** ; ;
             3179** ; LDOPS:			DB	"I",0,"A"+80H,47H
             3180** ; 			DB	"R",0,"A"+80H,4FH
             3181** ; 			DB	"A",0,"I"+80H,57H
             3182** ; 			DB	"A",0,"R"+80H,5FH
             3183** ; 			DB	"(BC",0,"A"+80H,02h
             3184** ; 			DB	"(DE",0,"A"+80H,12H
             3185** ; 			DB	"A",0,"(B","C"+80H,0AH
             3186** ; 			DB	"A",0,"(D","E"+80H,1AH
             3187** ; ;
             3188** ; 			DB	0
             3189** ; ;
             3190** ; ; eZ80 addressing mode suffixes
             3191** ; ;
             3192** ; ; Fully qualified suffixes
             3193** ; ;
             3194** ; EZ80SFS_1:		DB	"LI","S"+80H,49H
             3195** ; 			DB	"SI","L"+80H,52H
             3196** ; EZ80SFS_2:		DB	"SI","S"+80H,40H
             3197** ; 			DB	"LI","L"+80H,5BH
             3198** ; ;
             3199** ; 			DB	0
             3200** ; ;
             3201** ; ; Shortcuts when ADL mode is 0
             3202** ; ;
             3203** ; EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
             3204** ; 			DB	"L"+80H,49H		; Equivalent to .LIS
             3205** ; 			DB	"I","S"+80H,40H		; Equivalent to .SIS
             3206** ; 			DB	"I","L"+80H,52H		; Equivalent to .SIL
             3207** ; ;
             3208** ; 			DB	0
             3209** ; ;
             3210** ; ; Shortcuts when ADL mode is 1
             3211** ; ;
             3212** ; EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
             3213** ; 			DB	"L"+80H,5BH		; Equivalent to .LIL
             3214** ; 			DB	"I","S"+80H,49H		; Equivalent to .LIS
             3215** ; 			DB	"I","L"+80H,5BH		; Equivalent to .LIL
             3216** ; ;
             3217** ; 			DB	0
             3218** ; END REFACTOR FROM BINARY
             3219** ; BEGIN INSERT FROM BINARY
             3220** ;
             3221** ; Trivial cases requiring no computation
             3222** OPCODS:
0B2196 4E    3223** db 0x4e ; 041DCC 4E      5258 DB	"NO","P"+80H,00h	; # 00h
0B2197 4F    3224** db 0x4f ; 041DCD
0B2198 D0    3225** db 0xd0 ; 041DCE
0B2199 00    3226** db 0x00 ; 041DCF
0B219A 52    3227** db 0x52 ; 041DD0 52      5259 DB	"RLC","A"+80H,07h
0B219B 4C    3228** db 0x4c ; 041DD1
0B219C 43    3229** db 0x43 ; 041DD2
0B219D C1    3230** db 0xc1 ; 041DD3
0B219E 07    3231** db 0x07 ; 041DD4
0B219F 45    3232** db 0x45 ; 041DD5 45      5260 DB	"EX",0,"AF",0,"AF","'"+80H,08h
0B21A0 58    3233** db 0x58 ; 041DD6
0B21A1 00    3234** db 0x00 ; 041DD7
0B21A2 41    3235** db 0x41 ; 041DD8
0B21A3 46    3236** db 0x46 ; 041DD9
0B21A4 00    3237** db 0x00 ; 041DDA
0B21A5 41    3238** db 0x41 ; 041DDB
0B21A6 46    3239** db 0x46 ; 041DDC
0B21A7 A7    3240** db 0xa7 ; 041DDD
0B21A8 08    3241** db 0x08 ; 041DDE
0B21A9 52    3242** db 0x52 ; 041DDF 52      5261 DB	"RRC","A"+80H,0FH
0B21AA 52    3243** db 0x52 ; 041DE0
0B21AB 43    3244** db 0x43 ; 041DE1
0B21AC C1    3245** db 0xc1 ; 041DE2
0B21AD 0F    3246** db 0x0f ; 041DE3
0B21AE 52    3247** db 0x52 ; 041DE4 52      5262 DB	"RL","A"+80H,17H
0B21AF 4C    3248** db 0x4c ; 041DE5
0B21B0 C1    3249** db 0xc1 ; 041DE6
0B21B1 17    3250** db 0x17 ; 041DE7
0B21B2 52    3251** db 0x52 ; 041DE8 52      5263 DB	"RR","A"+80H,1FH
0B21B3 52    3252** db 0x52 ; 041DE9
0B21B4 C1    3253** db 0xc1 ; 041DEA
0B21B5 1F    3254** db 0x1f ; 041DEB
0B21B6 44    3255** db 0x44 ; 041DEC 44      5264 DB	"DA","A"+80H,27H
0B21B7 41    3256** db 0x41 ; 041DED
0B21B8 C1    3257** db 0xc1 ; 041DEE
0B21B9 27    3258** db 0x27 ; 041DEF
0B21BA 43    3259** db 0x43 ; 041DF0 43      5265 DB	"CP","L"+80H,2FH
0B21BB 50    3260** db 0x50 ; 041DF1
0B21BC CC    3261** db 0xcc ; 041DF2
0B21BD 2F    3262** db 0x2f ; 041DF3
0B21BE 53    3263** db 0x53 ; 041DF4 53      5266 DB	"SC","F"+80H,37H
0B21BF 43    3264** db 0x43 ; 041DF5
0B21C0 C6    3265** db 0xc6 ; 041DF6
0B21C1 37    3266** db 0x37 ; 041DF7
0B21C2 43    3267** db 0x43 ; 041DF8 43      5267 DB	"CC","F"+80H,3FH
0B21C3 43    3268** db 0x43 ; 041DF9
0B21C4 C6    3269** db 0xc6 ; 041DFA
0B21C5 3F    3270** db 0x3f ; 041DFB
0B21C6 48    3271** db 0x48 ; 041DFC 48      5268 DB	"HAL","T"+80H,76H
0B21C7 41    3272** db 0x41 ; 041DFD
0B21C8 4C    3273** db 0x4c ; 041DFE
0B21C9 D4    3274** db 0xd4 ; 041DFF
0B21CA 76    3275** db 0x76 ; 041E00
0B21CB 45    3276** db 0x45 ; 041E01 45      5269 DB	"EX","X"+80H,D9H
0B21CC 58    3277** db 0x58 ; 041E02
0B21CD D8    3278** db 0xd8 ; 041E03
0B21CE D9    3279** db 0xd9 ; 041E04
0B21CF 45    3280** db 0x45 ; 041E05 45      5270 DB	"EX",0,"DE",0,"H","L"+80H,EBH
0B21D0 58    3281** db 0x58 ; 041E06
0B21D1 00    3282** db 0x00 ; 041E07
0B21D2 44    3283** db 0x44 ; 041E08
0B21D3 45    3284** db 0x45 ; 041E09
0B21D4 00    3285** db 0x00 ; 041E0A
0B21D5 48    3286** db 0x48 ; 041E0B
0B21D6 CC    3287** db 0xcc ; 041E0C
0B21D7 EB    3288** db 0xeb ; 041E0D
0B21D8 44    3289** db 0x44 ; 041E0E 44      5271 DB	"D","I"+80H,F3H
0B21D9 C9    3290** db 0xc9 ; 041E0F
0B21DA F3    3291** db 0xf3 ; 041E10
0B21DB 45    3292** db 0x45 ; 041E11 45      5272 DB	"E","I"+80H,FBH
0B21DC C9    3293** db 0xc9 ; 041E12
0B21DD FB    3294** db 0xfb ; 041E13
             3295** ;
             3296** ; Group 1: (53 opcodes)
             3297** ; As Group 0, but with an ED prefix
             3298** ;
0B21DE 4E    3299** db 0x4e ; 041E14 4E      5277 DB	"NE","G"+80H,44H	; 0Fh
0B21DF 45    3300** db 0x45 ; 041E15
0B21E0 C7    3301** db 0xc7 ; 041E16
0B21E1 44    3302** db 0x44 ; 041E17
0B21E2 49    3303** db 0x49 ; 041E18 49      5278 DB	"IM",0,"0"+80H,46H
0B21E3 4D    3304** db 0x4d ; 041E19
0B21E4 00    3305** db 0x00 ; 041E1A
0B21E5 B0    3306** db 0xb0 ; 041E1B
0B21E6 46    3307** db 0x46 ; 041E1C
0B21E7 52    3308** db 0x52 ; 041E1D 52      5279 DB	"RET","N"+80H,45H
0B21E8 45    3309** db 0x45 ; 041E1E
0B21E9 54    3310** db 0x54 ; 041E1F
0B21EA CE    3311** db 0xce ; 041E20
0B21EB 45    3312** db 0x45 ; 041E21
0B21EC 4D    3313** db 0x4d ; 041E22 4D      5280 DB	"MLT",0,"B","C"+80H,4CH
0B21ED 4C    3314** db 0x4c ; 041E23
0B21EE 54    3315** db 0x54 ; 041E24
0B21EF 00    3316** db 0x00 ; 041E25
0B21F0 42    3317** db 0x42 ; 041E26
0B21F1 C3    3318** db 0xc3 ; 041E27
0B21F2 4C    3319** db 0x4c ; 041E28
0B21F3 52    3320** db 0x52 ; 041E29 52      5281 DB	"RET","I"+80H,4DH
0B21F4 45    3321** db 0x45 ; 041E2A
0B21F5 54    3322** db 0x54 ; 041E2B
0B21F6 C9    3323** db 0xc9 ; 041E2C
0B21F7 4D    3324** db 0x4d ; 041E2D
0B21F8 49    3325** db 0x49 ; 041E2E 49      5282 DB	"IM",0,"1"+80H,56H
0B21F9 4D    3326** db 0x4d ; 041E2F
0B21FA 00    3327** db 0x00 ; 041E30
0B21FB B1    3328** db 0xb1 ; 041E31
0B21FC 56    3329** db 0x56 ; 041E32
0B21FD 4D    3330** db 0x4d ; 041E33 4D      5283 DB	"MLT",0,"D","E"+80H,5CH
0B21FE 4C    3331** db 0x4c ; 041E34
0B21FF 54    3332** db 0x54 ; 041E35
0B2200 00    3333** db 0x00 ; 041E36
0B2201 44    3334** db 0x44 ; 041E37
0B2202 C5    3335** db 0xc5 ; 041E38
0B2203 5C    3336** db 0x5c ; 041E39
0B2204 49    3337** db 0x49 ; 041E3A 49      5284 DB	"IM",0,"2"+80H,5EH
0B2205 4D    3338** db 0x4d ; 041E3B
0B2206 00    3339** db 0x00 ; 041E3C
0B2207 B2    3340** db 0xb2 ; 041E3D
0B2208 5E    3341** db 0x5e ; 041E3E
0B2209 52    3342** db 0x52 ; 041E3F 52      5285 DB	"RR","D"+80H,67H
0B220A 52    3343** db 0x52 ; 041E40
0B220B C4    3344** db 0xc4 ; 041E41
0B220C 67    3345** db 0x67 ; 041E42
0B220D 4D    3346** db 0x4d ; 041E43 4D      5286 DB	"MLT",0,"H","L"+80H,6CH
0B220E 4C    3347** db 0x4c ; 041E44
0B220F 54    3348** db 0x54 ; 041E45
0B2210 00    3349** db 0x00 ; 041E46
0B2211 48    3350** db 0x48 ; 041E47
0B2212 CC    3351** db 0xcc ; 041E48
0B2213 6C    3352** db 0x6c ; 041E49
0B2214 4C    3353** db 0x4c ; 041E4A 4C      5287 DB	"LD",0,"MB",0,"A"+80H,6DH
0B2215 44    3354** db 0x44 ; 041E4B
0B2216 00    3355** db 0x00 ; 041E4C
0B2217 4D    3356** db 0x4d ; 041E4D
0B2218 42    3357** db 0x42 ; 041E4E
0B2219 00    3358** db 0x00 ; 041E4F
0B221A C1    3359** db 0xc1 ; 041E50
0B221B 6D    3360** db 0x6d ; 041E51
0B221C 4C    3361** db 0x4c ; 041E52 4C      5288 DB	"LD",0,"A",0,"M","B"+80H,6EH
0B221D 44    3362** db 0x44 ; 041E53
0B221E 00    3363** db 0x00 ; 041E54
0B221F 41    3364** db 0x41 ; 041E55
0B2220 00    3365** db 0x00 ; 041E56
0B2221 4D    3366** db 0x4d ; 041E57
0B2222 C2    3367** db 0xc2 ; 041E58
0B2223 6E    3368** db 0x6e ; 041E59
0B2224 52    3369** db 0x52 ; 041E5A 52      5289 DB	"RL","D"+80H,6FH
0B2225 4C    3370** db 0x4c ; 041E5B
0B2226 C4    3371** db 0xc4 ; 041E5C
0B2227 6F    3372** db 0x6f ; 041E5D
0B2228 53    3373** db 0x53 ; 041E5E 53      5290 DB	"SL","P"+80H,76H
0B2229 4C    3374** db 0x4c ; 041E5F
0B222A D0    3375** db 0xd0 ; 041E60
0B222B 76    3376** db 0x76 ; 041E61
0B222C 4D    3377** db 0x4d ; 041E62 4D      5291 DB	"MLT",0,"S","P"+80H,7CH
0B222D 4C    3378** db 0x4c ; 041E63
0B222E 54    3379** db 0x54 ; 041E64
0B222F 00    3380** db 0x00 ; 041E65
0B2230 53    3381** db 0x53 ; 041E66
0B2231 D0    3382** db 0xd0 ; 041E67
0B2232 7C    3383** db 0x7c ; 041E68
0B2233 53    3384** db 0x53 ; 041E69 53      5292 DB	"STMI","X"+80H,7DH
0B2234 54    3385** db 0x54 ; 041E6A
0B2235 4D    3386** db 0x4d ; 041E6B
0B2236 49    3387** db 0x49 ; 041E6C
0B2237 D8    3388** db 0xd8 ; 041E6D
0B2238 7D    3389** db 0x7d ; 041E6E
0B2239 52    3390** db 0x52 ; 041E6F 52      5293 DB	"RSMI","X"+80H,7EH
0B223A 53    3391** db 0x53 ; 041E70
0B223B 4D    3392** db 0x4d ; 041E71
0B223C 49    3393** db 0x49 ; 041E72
0B223D D8    3394** db 0xd8 ; 041E73
0B223E 7E    3395** db 0x7e ; 041E74
0B223F 49    3396** db 0x49 ; 041E75 49      5294 DB	"INI","M"+80H,82H
0B2240 4E    3397** db 0x4e ; 041E76
0B2241 49    3398** db 0x49 ; 041E77
0B2242 CD    3399** db 0xcd ; 041E78
0B2243 82    3400** db 0x82 ; 041E79
0B2244 4F    3401** db 0x4f ; 041E7A 4F      5295 DB	"OTI","M"+80H,83H
0B2245 54    3402** db 0x54 ; 041E7B
0B2246 49    3403** db 0x49 ; 041E7C
0B2247 CD    3404** db 0xcd ; 041E7D
0B2248 83    3405** db 0x83 ; 041E7E
0B2249 49    3406** db 0x49 ; 041E7F 49      5296 DB	"INI","2"+80H,84H
0B224A 4E    3407** db 0x4e ; 041E80
0B224B 49    3408** db 0x49 ; 041E81
0B224C B2    3409** db 0xb2 ; 041E82
0B224D 84    3410** db 0x84 ; 041E83
0B224E 49    3411** db 0x49 ; 041E84 49      5297 DB	"IND","M"+80H,8AH
0B224F 4E    3412** db 0x4e ; 041E85
0B2250 44    3413** db 0x44 ; 041E86
0B2251 CD    3414** db 0xcd ; 041E87
0B2252 8A    3415** db 0x8a ; 041E88
0B2253 4F    3416** db 0x4f ; 041E89 4F      5298 DB	"OTD","M"+80H,8BH
0B2254 54    3417** db 0x54 ; 041E8A
0B2255 44    3418** db 0x44 ; 041E8B
0B2256 CD    3419** db 0xcd ; 041E8C
0B2257 8B    3420** db 0x8b ; 041E8D
0B2258 49    3421** db 0x49 ; 041E8E 49      5299 DB	"IND","2"+80H,8CH
0B2259 4E    3422** db 0x4e ; 041E8F
0B225A 44    3423** db 0x44 ; 041E90
0B225B B2    3424** db 0xb2 ; 041E91
0B225C 8C    3425** db 0x8c ; 041E92
0B225D 49    3426** db 0x49 ; 041E93 49      5300 DB	"INIM","R"+80H,92H
0B225E 4E    3427** db 0x4e ; 041E94
0B225F 49    3428** db 0x49 ; 041E95
0B2260 4D    3429** db 0x4d ; 041E96
0B2261 D2    3430** db 0xd2 ; 041E97
0B2262 92    3431** db 0x92 ; 041E98
0B2263 4F    3432** db 0x4f ; 041E99 4F      5301 DB	"OTIM","R"+80H,93H
0B2264 54    3433** db 0x54 ; 041E9A
0B2265 49    3434** db 0x49 ; 041E9B
0B2266 4D    3435** db 0x4d ; 041E9C
0B2267 D2    3436** db 0xd2 ; 041E9D
0B2268 93    3437** db 0x93 ; 041E9E
0B2269 49    3438** db 0x49 ; 041E9F 49      5302 DB	"INI2","R"+80H,94H
0B226A 4E    3439** db 0x4e ; 041EA0
0B226B 49    3440** db 0x49 ; 041EA1
0B226C 32    3441** db 0x32 ; 041EA2
0B226D D2    3442** db 0xd2 ; 041EA3
0B226E 94    3443** db 0x94 ; 041EA4
0B226F 49    3444** db 0x49 ; 041EA5 49      5303 DB	"INDM","R"+80H,9AH
0B2270 4E    3445** db 0x4e ; 041EA6
0B2271 44    3446** db 0x44 ; 041EA7
0B2272 4D    3447** db 0x4d ; 041EA8
0B2273 D2    3448** db 0xd2 ; 041EA9
0B2274 9A    3449** db 0x9a ; 041EAA
0B2275 4F    3450** db 0x4f ; 041EAB 4F      5304 DB	"OTDM","R"+80H,9BH
0B2276 54    3451** db 0x54 ; 041EAC
0B2277 44    3452** db 0x44 ; 041EAD
0B2278 4D    3453** db 0x4d ; 041EAE
0B2279 D2    3454** db 0xd2 ; 041EAF
0B227A 9B    3455** db 0x9b ; 041EB0
0B227B 49    3456** db 0x49 ; 041EB1 49      5305 DB	"IND2","R"+80H,9CH
0B227C 4E    3457** db 0x4e ; 041EB2
0B227D 44    3458** db 0x44 ; 041EB3
0B227E 32    3459** db 0x32 ; 041EB4
0B227F D2    3460** db 0xd2 ; 041EB5
0B2280 9C    3461** db 0x9c ; 041EB6
0B2281 4C    3462** db 0x4c ; 041EB7 4C      5306 DB	"LD","I"+80H,A0H
0B2282 44    3463** db 0x44 ; 041EB8
0B2283 C9    3464** db 0xc9 ; 041EB9
0B2284 A0    3465** db 0xa0 ; 041EBA
0B2285 43    3466** db 0x43 ; 041EBB 43      5307 DB	"CP","I"+80H,A1H
0B2286 50    3467** db 0x50 ; 041EBC
0B2287 C9    3468** db 0xc9 ; 041EBD
0B2288 A1    3469** db 0xa1 ; 041EBE
0B2289 49    3470** db 0x49 ; 041EBF 49      5308 DB	"IN","I"+80H,A2H
0B228A 4E    3471** db 0x4e ; 041EC0
0B228B C9    3472** db 0xc9 ; 041EC1
0B228C A2    3473** db 0xa2 ; 041EC2
0B228D 4F    3474** db 0x4f ; 041EC3 4F      5309 DB	"OUTI","2"+80H,A4H	; These are swapped round so that FIND will find
0B228E 55    3475** db 0x55 ; 041EC4
0B228F 54    3476** db 0x54 ; 041EC5
0B2290 49    3477** db 0x49 ; 041EC6
0B2291 B2    3478** db 0xb2 ; 041EC7
0B2292 A4    3479** db 0xa4 ; 041EC8
0B2293 4F    3480** db 0x4f ; 041EC9 4F      5310 DB	"OUT","I"+80H,A3H	; OUTI2 before OUTI
0B2294 55    3481** db 0x55 ; 041ECA
0B2295 54    3482** db 0x54 ; 041ECB
0B2296 C9    3483** db 0xc9 ; 041ECC
0B2297 A3    3484** db 0xa3 ; 041ECD
0B2298 4C    3485** db 0x4c ; 041ECE 4C      5311 DB	"LD","D"+80H,A8H
0B2299 44    3486** db 0x44 ; 041ECF
0B229A C4    3487** db 0xc4 ; 041ED0
0B229B A8    3488** db 0xa8 ; 041ED1
0B229C 43    3489** db 0x43 ; 041ED2 43      5312 DB	"CP","D"+80H,A9H
0B229D 50    3490** db 0x50 ; 041ED3
0B229E C4    3491** db 0xc4 ; 041ED4
0B229F A9    3492** db 0xa9 ; 041ED5
0B22A0 49    3493** db 0x49 ; 041ED6 49      5313 DB	"IN","D"+80H,AAH
0B22A1 4E    3494** db 0x4e ; 041ED7
0B22A2 C4    3495** db 0xc4 ; 041ED8
0B22A3 AA    3496** db 0xaa ; 041ED9
0B22A4 4F    3497** db 0x4f ; 041EDA 4F      5314 DB	"OUTD","2"+80H,ACH	; Similarly these are swapped round so that FIND
0B22A5 55    3498** db 0x55 ; 041EDB
0B22A6 54    3499** db 0x54 ; 041EDC
0B22A7 44    3500** db 0x44 ; 041EDD
0B22A8 B2    3501** db 0xb2 ; 041EDE
0B22A9 AC    3502** db 0xac ; 041EDF
0B22AA 4F    3503** db 0x4f ; 041EE0 4F      5315 DB	"OUT","D"+80H,ABH	; will find OUTD2 before OUTD
0B22AB 55    3504** db 0x55 ; 041EE1
0B22AC 54    3505** db 0x54 ; 041EE2
0B22AD C4    3506** db 0xc4 ; 041EE3
0B22AE AB    3507** db 0xab ; 041EE4
0B22AF 4C    3508** db 0x4c ; 041EE5 4C      5316 DB	"LDI","R"+80H,B0H
0B22B0 44    3509** db 0x44 ; 041EE6
0B22B1 49    3510** db 0x49 ; 041EE7
0B22B2 D2    3511** db 0xd2 ; 041EE8
0B22B3 B0    3512** db 0xb0 ; 041EE9
0B22B4 43    3513** db 0x43 ; 041EEA 43      5317 DB	"CPI","R"+80H,B1H
0B22B5 50    3514** db 0x50 ; 041EEB
0B22B6 49    3515** db 0x49 ; 041EEC
0B22B7 D2    3516** db 0xd2 ; 041EED
0B22B8 B1    3517** db 0xb1 ; 041EEE
0B22B9 49    3518** db 0x49 ; 041EEF 49      5318 DB	"INI","R"+80H,B2H
0B22BA 4E    3519** db 0x4e ; 041EF0
0B22BB 49    3520** db 0x49 ; 041EF1
0B22BC D2    3521** db 0xd2 ; 041EF2
0B22BD B2    3522** db 0xb2 ; 041EF3
0B22BE 4F    3523** db 0x4f ; 041EF4 4F      5319 DB	"OTI","R"+80H,B3H
0B22BF 54    3524** db 0x54 ; 041EF5
0B22C0 49    3525** db 0x49 ; 041EF6
0B22C1 D2    3526** db 0xd2 ; 041EF7
0B22C2 B3    3527** db 0xb3 ; 041EF8
0B22C3 4F    3528** db 0x4f ; 041EF9 4F      5320 DB	"OTI2","R"+80H,B4H
0B22C4 54    3529** db 0x54 ; 041EFA
0B22C5 49    3530** db 0x49 ; 041EFB
0B22C6 32    3531** db 0x32 ; 041EFC
0B22C7 D2    3532** db 0xd2 ; 041EFD
0B22C8 B4    3533** db 0xb4 ; 041EFE
0B22C9 4C    3534** db 0x4c ; 041EFF 4C      5321 DB	"LDD","R"+80H,B8H
0B22CA 44    3535** db 0x44 ; 041F00
0B22CB 44    3536** db 0x44 ; 041F01
0B22CC D2    3537** db 0xd2 ; 041F02
0B22CD B8    3538** db 0xb8 ; 041F03
0B22CE 43    3539** db 0x43 ; 041F04 43      5322 DB	"CPD","R"+80H,B9H
0B22CF 50    3540** db 0x50 ; 041F05
0B22D0 44    3541** db 0x44 ; 041F06
0B22D1 D2    3542** db 0xd2 ; 041F07
0B22D2 B9    3543** db 0xb9 ; 041F08
0B22D3 49    3544** db 0x49 ; 041F09 49      5323 DB	"IND","R"+80H,BAH
0B22D4 4E    3545** db 0x4e ; 041F0A
0B22D5 44    3546** db 0x44 ; 041F0B
0B22D6 D2    3547** db 0xd2 ; 041F0C
0B22D7 BA    3548** db 0xba ; 041F0D
0B22D8 4F    3549** db 0x4f ; 041F0E 4F      5324 DB	"OTD","R"+80H,BBH
0B22D9 54    3550** db 0x54 ; 041F0F
0B22DA 44    3551** db 0x44 ; 041F10
0B22DB D2    3552** db 0xd2 ; 041F11
0B22DC BB    3553** db 0xbb ; 041F12
0B22DD 4F    3554** db 0x4f ; 041F13 4F      5325 DB	"OTD2","R"+80H,BCH
0B22DE 54    3555** db 0x54 ; 041F14
0B22DF 44    3556** db 0x44 ; 041F15
0B22E0 32    3557** db 0x32 ; 041F16
0B22E1 D2    3558** db 0xd2 ; 041F17
0B22E2 BC    3559** db 0xbc ; 041F18
0B22E3 49    3560** db 0x49 ; 041F19 49      5326 DB	"INIR","X"+80H,C2H
0B22E4 4E    3561** db 0x4e ; 041F1A
0B22E5 49    3562** db 0x49 ; 041F1B
0B22E6 52    3563** db 0x52 ; 041F1C
0B22E7 D8    3564** db 0xd8 ; 041F1D
0B22E8 C2    3565** db 0xc2 ; 041F1E
0B22E9 4F    3566** db 0x4f ; 041F1F 4F      5327 DB	"OTIR","X"+80H,C3H
0B22EA 54    3567** db 0x54 ; 041F20
0B22EB 49    3568** db 0x49 ; 041F21
0B22EC 52    3569** db 0x52 ; 041F22
0B22ED D8    3570** db 0xd8 ; 041F23
0B22EE C3    3571** db 0xc3 ; 041F24
0B22EF 49    3572** db 0x49 ; 041F25 49      5328 DB	"INDR","X"+80H,CAH
0B22F0 4E    3573** db 0x4e ; 041F26
0B22F1 44    3574** db 0x44 ; 041F27
0B22F2 52    3575** db 0x52 ; 041F28
0B22F3 D8    3576** db 0xd8 ; 041F29
0B22F4 CA    3577** db 0xca ; 041F2A
0B22F5 4F    3578** db 0x4f ; 041F2B 4F      5329 DB	"OTDR","X"+80H,CBH
0B22F6 54    3579** db 0x54 ; 041F2C
0B22F7 44    3580** db 0x44 ; 041F2D
0B22F8 52    3581** db 0x52 ; 041F2E
0B22F9 D8    3582** db 0xd8 ; 041F2F
0B22FA CB    3583** db 0xcb ; 041F30
             3584** ;
             3585** ; Group 2: (3 opcodes)
             3586** ;
0B22FB 42    3587** db 0x42 ; 041F31 42      5333 DB	"BI","T"+80H,40H	; 44h
0B22FC 49    3588** db 0x49 ; 041F32
0B22FD D4    3589** db 0xd4 ; 041F33
0B22FE 40    3590** db 0x40 ; 041F34
0B22FF 52    3591** db 0x52 ; 041F35 52      5333 DB	"RE","S"+80H,80H
0B2300 45    3592** db 0x45 ; 041F36
0B2301 D3    3593** db 0xd3 ; 041F37
0B2302 80    3594** db 0x80 ; 041F38
0B2303 53    3595** db 0x53 ; 041F39 53      5334 DB	"SE","T"+80H,C0H
0B2304 45    3596** db 0x45 ; 041F3A
0B2305 D4    3597** db 0xd4 ; 041F3B
0B2306 C0    3598** db 0xc0 ; 041F3C
             3599** ;
             3600** ; Group 3: (7 opcodes)
             3601** ;
0B2307 52    3602** db 0x52 ; 041F3D 52      5338 DB	"RL","C"+80H,00H	; 47h
0B2308 4C    3603** db 0x4c ; 041F3E
0B2309 C3    3604** db 0xc3 ; 041F3F
0B230A 00    3605** db 0x00 ; 041F40
0B230B 52    3606** db 0x52 ; 041F41 52      5339 DB	"RR","C"+80H,08H
0B230C 52    3607** db 0x52 ; 041F42
0B230D C3    3608** db 0xc3 ; 041F43
0B230E 08    3609** db 0x08 ; 041F44
0B230F 52    3610** db 0x52 ; 041F45 52      5340 DB	"R","L"+80H,10H
0B2310 CC    3611** db 0xcc ; 041F46
0B2311 10    3612** db 0x10 ; 041F47
0B2312 52    3613** db 0x52 ; 041F48 52      5341 DB	"R","R"+80H,18H
0B2313 D2    3614** db 0xd2 ; 041F49
0B2314 18    3615** db 0x18 ; 041F4A
0B2315 53    3616** db 0x53 ; 041F4B 53      5342 DB	"SL","A"+80H,20H
0B2316 4C    3617** db 0x4c ; 041F4C
0B2317 C1    3618** db 0xc1 ; 041F4D
0B2318 20    3619** db 0x20 ; 041F4E
0B2319 53    3620** db 0x53 ; 041F4F 53      5343 DB	"SR","A"+80H,28H
0B231A 52    3621** db 0x52 ; 041F50
0B231B C1    3622** db 0xc1 ; 041F51
0B231C 28    3623** db 0x28 ; 041F52
0B231D 53    3624** db 0x53 ; 041F53 53      5344 DB	"SR","L"+80H,38H
0B231E 52    3625** db 0x52 ; 041F54
0B231F CC    3626** db 0xcc ; 041F55
0B2320 38    3627** db 0x38 ; 041F56
             3628** ;
             3629** ; Group 4: (3 opcodes)
             3630** ;
0B2321 50    3631** db 0x50 ; 041F57 50      5348 DB	"PO","P"+80H,C1H	; 4Eh
0B2322 4F    3632** db 0x4f ; 041F58
0B2323 D0    3633** db 0xd0 ; 041F59
0B2324 C1    3634** db 0xc1 ; 041F5A
0B2325 50    3635** db 0x50 ; 041F5B 50      5349 DB	"PUS","H"+80H,C5H
0B2326 55    3636** db 0x55 ; 041F5C
0B2327 53    3637** db 0x53 ; 041F5D
0B2328 C8    3638** db 0xc8 ; 041F5E
0B2329 C5    3639** db 0xc5 ; 041F5F
0B232A 45    3640** db 0x45 ; 041F60 45      5350 DB	"EX",0,"(S","P"+80H,E3H
0B232B 58    3641** db 0x58 ; 041F61
0B232C 00    3642** db 0x00 ; 041F62
0B232D 28    3643** db 0x28 ; 041F63
0B232E 53    3644** db 0x53 ; 041F64
0B232F D0    3645** db 0xd0 ; 041F65
0B2330 E3    3646** db 0xe3 ; 041F66
             3647** ;
             3648** ; Group 5: (7 opcodes)
             3649** ;
0B2331 53    3650** db 0x53 ; 041F67 53      5354 DB	"SU","B"+80H,90H	; 51h
0B2332 55    3651** db 0x55 ; 041F68
0B2333 C2    3652** db 0xc2 ; 041F69
0B2334 90    3653** db 0x90 ; 041F6A
0B2335 41    3654** db 0x41 ; 041F6B 41      5355 DB	"AN","D"+80H,A0H
0B2336 4E    3655** db 0x4e ; 041F6C
0B2337 C4    3656** db 0xc4 ; 041F6D
0B2338 A0    3657** db 0xa0 ; 041F6E
0B2339 58    3658** db 0x58 ; 041F6F 58      5356 DB	"XO","R"+80H,A8H
0B233A 4F    3659** db 0x4f ; 041F70
0B233B D2    3660** db 0xd2 ; 041F71
0B233C A8    3661** db 0xa8 ; 041F72
0B233D 4F    3662** db 0x4f ; 041F73 4F      5357 DB	"O","R"+80H,B0H
0B233E D2    3663** db 0xd2 ; 041F74
0B233F B0    3664** db 0xb0 ; 041F75
0B2340 43    3665** db 0x43 ; 041F76 43      5358 DB	"C","P"+80H,B8H
0B2341 D0    3666** db 0xd0 ; 041F77
0B2342 B8    3667** db 0xb8 ; 041F78
0B2343 80    3668** db 0x80 ; 041F79 80      5359 DB	TAND,A0H		; 56h TAND: Tokenised AND
0B2344 A0    3669** db 0xa0 ; 041F7A
0B2345 84    3670** db 0x84 ; 041F7B 84      5360 DB	TOR,B0H			; 57h TOR: Tokenised OR
0B2346 B0    3671** db 0xb0 ; 041F7C
             3672** ;
             3673** ; Group 6 (3 opcodes)
             3674** ;
0B2347 41    3675** db 0x41 ; 041F7D 41      5364 DB	"AD","D"+80H,80H	; 58h
0B2348 44    3676** db 0x44 ; 041F7E
0B2349 C4    3677** db 0xc4 ; 041F7F
0B234A 80    3678** db 0x80 ; 041F80
0B234B 41    3679** db 0x41 ; 041F81 41      5365 DB	"AD","C"+80H,88H
0B234C 44    3680** db 0x44 ; 041F82
0B234D C3    3681** db 0xc3 ; 041F83
0B234E 88    3682** db 0x88 ; 041F84
0B234F 53    3683** db 0x53 ; 041F85 53      5366 DB	"SB","C"+80H,98H
0B2350 42    3684** db 0x42 ; 041F86
0B2351 C3    3685** db 0xc3 ; 041F87
0B2352 98    3686** db 0x98 ; 041F88
             3687** ;
             3688** ; Group 7: (2 opcodes)
             3689** ;
0B2353 49    3690** db 0x49 ; 041F89 49      5370 DB	"IN","C"+80H,04H	; 5Bh
0B2354 4E    3691** db 0x4e ; 041F8A
0B2355 C3    3692** db 0xc3 ; 041F8B
0B2356 04    3693** db 0x04 ; 041F8C
0B2357 44    3694** db 0x44 ; 041F8D 44      5371 DB	"DE","C"+80H,05H
0B2358 45    3695** db 0x45 ; 041F8E
0B2359 C3    3696** db 0xc3 ; 041F8F
0B235A 05    3697** db 0x05 ; 041F90
             3698** ;
             3699** ; Group 8: (2 opcodes)
             3700** ;
0B235B 49    3701** db 0x49 ; 041F91 49      5375 DB	"IN","0"+80H,00H	; 5Dh
0B235C 4E    3702** db 0x4e ; 041F92
0B235D B0    3703** db 0xb0 ; 041F93
0B235E 00    3704** db 0x00 ; 041F94
0B235F 4F    3705** db 0x4f ; 041F95 4F      5376 DB	"OUT","0"+80H,01H
0B2360 55    3706** db 0x55 ; 041F96
0B2361 54    3707** db 0x54 ; 041F97
0B2362 B0    3708** db 0xb0 ; 041F98
0B2363 01    3709** db 0x01 ; 041F99
             3710** ;
             3711** ; Group 9: (1 opcode)
             3712** ;
0B2364 49    3713** db 0x49 ; 041F9A 49      5380 DB	"I","N"+80H,40H		; 5Fh
0B2365 CE    3714** db 0xce ; 041F9B
0B2366 40    3715** db 0x40 ; 041F9C
             3716** ;
             3717** ; Group 10: (1 opcode)
             3718** ;
0B2367 4F    3719** db 0x4f ; 041F9D 4F      5384 DB	"OU","T"+80H,41H	; 60h
0B2368 55    3720** db 0x55 ; 041F9E
0B2369 D4    3721** db 0xd4 ; 041F9F
0B236A 41    3722** db 0x41 ; 041FA0
             3723** ;
             3724** ; Group 11: (2 opcodes)
             3725** ;
0B236B 4A    3726** db 0x4a ; 041FA1 4A      5388 DB	"J","R"+80H,20H		; 61h
0B236C D2    3727** db 0xd2 ; 041FA2
0B236D 20    3728** db 0x20 ; 041FA3
0B236E 44    3729** db 0x44 ; 041FA4 44      5389 DB	"DJN","Z"+80H,10H
0B236F 4A    3730** db 0x4a ; 041FA5
0B2370 4E    3731** db 0x4e ; 041FA6
0B2371 DA    3732** db 0xda ; 041FA7
0B2372 10    3733** db 0x10 ; 041FA8
             3734** ;
             3735** ; Group 12: (1 opcode)
             3736** ;
0B2373 4A    3737** db 0x4a ; 041FA9 4A      5393 DB	"J","P"+80H,C2H		; 63h
0B2374 D0    3738** db 0xd0 ; 041FAA
0B2375 C2    3739** db 0xc2 ; 041FAB
             3740** ;
             3741** ; Group 13: (1 opcode)
             3742** ;
0B2376 43    3743** db 0x43 ; 041FAC 43      5397 DB	"CAL","L"+80H,C4H	; 64h
0B2377 41    3744** db 0x41 ; 041FAD
0B2378 4C    3745** db 0x4c ; 041FAE
0B2379 CC    3746** db 0xcc ; 041FAF
0B237A C4    3747** db 0xc4 ; 041FB0
             3748** ;
             3749** ; Group 14: (1 opcode)
             3750** ;
0B237B 52    3751** db 0x52 ; 041FB1 52      5401 DB	"RS","T"+80H,C7H	; 65h
0B237C 53    3752** db 0x53 ; 041FB2
0B237D D4    3753** db 0xd4 ; 041FB3
0B237E C7    3754** db 0xc7 ; 041FB4
             3755** ;
             3756** ; Group 15: (1 opcode)
             3757** ;
0B237F 52    3758** db 0x52 ; 041FB5 52      5405 DB	"RE","T"+80H,C0H	; 66h
0B2380 45    3759** db 0x45 ; 041FB6
0B2381 D4    3760** db 0xd4 ; 041FB7
0B2382 C0    3761** db 0xc0 ; 041FB8
             3762** ;
             3763** ; Group 16: (1 opcode)
             3764** ;
0B2383 4C    3765** db 0x4c ; 041FB9 4C      5409 DB	"L","D"+80H,40H		; 67h
0B2384 C4    3766** db 0xc4 ; 041FBA
0B2385 40    3767** db 0x40 ; 041FBB
             3768** ;
             3769** ; Group 17: (1 opcode)
             3770** ;
0B2386 54    3771** db 0x54 ; 041FBC 54      5413 DB	"TS","T"+80H,04H	; 68h
0B2387 53    3772** db 0x53 ; 041FBD
0B2388 D4    3773** db 0xd4 ; 041FBE
0B2389 04    3774** db 0x04 ; 041FBF
             3775** ;
             3776** ; Assembler Directives
             3777** ;
0B238A 4F    3778** db 0x4f ; 041FC0 4F      5418 DB	"OP","T"+80H,00H	; 69h OPT
0B238B 50    3779** db 0x50 ; 041FC1
0B238C D4    3780** db 0xd4 ; 041FC2
0B238D 00    3781** db 0x00 ; 041FC3
0B238E 41    3782** db 0x41 ; 041FC4 41      5419 DB	"AD","L"+80H,00H	; 6Ah ADL
0B238F 44    3783** db 0x44 ; 041FC5
0B2390 CC    3784** db 0xcc ; 041FC6
0B2391 00    3785** db 0x00 ; 041FC7
0B2392 5D    3786** db 0x5d ; 041FC8 5D      5421 DB	DEF_ & 7FH,"B"+80H,00H	; 6Bh Tokenised DEF + B
0B2393 C2    3787** db 0xc2 ; 041FC9
0B2394 00    3788** db 0x00 ; 041FCA
0B2395 5D    3789** db 0x5d ; 041FCB 5D      5422 DB	DEF_ & 7FH,"W"+80H,00H	; 6Ch Tokenised DEF + W
0B2396 D7    3790** db 0xd7 ; 041FCC
0B2397 00    3791** db 0x00 ; 041FCD
0B2398 5D    3792** db 0x5d ; 041FCE 5D      5423 DB	DEF_ & 7FH,"L"+80H,00H	; 6Dh Tokenised DEF + L
0B2399 CC    3793** db 0xcc ; 041FCF
0B239A 00    3794** db 0x00 ; 041FD0
0B239B 5D    3795** db 0x5d ; 041FD1 5D      5424 DB 	DEF_ & 7FH,"M"+80H,00H	; 6Eh Tokenised DEF + M
0B239C CD    3796** db 0xcd ; 041FD2
0B239D 00    3797** db 0x00 ; 041FD3
0B239E 00    3798** db 0x00 ; 041FD4 00      5426 DB	0
             3799** ;
             3800** ; Operands
             3801** ;
             3802** OPRNDS:
0B239F C2    3803** db 0xc2 ; 041FD5 42      5430 OPRNDS:			DB	"B"+80H, 00H
0B23A0 00    3804** db 0x00 ; 041FD6
0B23A1 C3    3805** db 0xc3 ; 041FD7 43      5431 DB	"C"+80H, 01H
0B23A2 01    3806** db 0x01 ; 041FD8
0B23A3 C4    3807** db 0xc4 ; 041FD9 44      5432 DB	"D"+80H, 02H
0B23A4 02    3808** db 0x02 ; 041FDA
0B23A5 C5    3809** db 0xc5 ; 041FDB 45      5433 DB	"E"+80H, 03H
0B23A6 03    3810** db 0x03 ; 041FDC
0B23A7 C8    3811** db 0xc8 ; 041FDD 48      5434 DB	"H"+80H, 04H
0B23A8 04    3812** db 0x04 ; 041FDE
0B23A9 CC    3813** db 0xcc ; 041FDF 4C      5435 DB	"L"+80H, 05H
0B23AA 05    3814** db 0x05 ; 041FE0
0B23AB 28    3815** db 0x28 ; 041FE1 28      5436 DB	"(H","L"+80H,06H
0B23AC 48    3816** db 0x48 ; 041FE2
0B23AD CC    3817** db 0xcc ; 041FE3
0B23AE 06    3818** db 0x06 ; 041FE4
0B23AF C1    3819** db 0xc1 ; 041FE5 41      5437 DB	"A"+80H, 07H
0B23B0 07    3820** db 0x07 ; 041FE6
0B23B1 28    3821** db 0x28 ; 041FE7 28      5438 DB	"(I","X"+80H,86H
0B23B2 49    3822** db 0x49 ; 041FE8
0B23B3 D8    3823** db 0xd8 ; 041FE9
0B23B4 86    3824** db 0x86 ; 041FEA
0B23B5 28    3825** db 0x28 ; 041FEB 28      5439 DB	"(I","Y"+80H,C6H
0B23B6 49    3826** db 0x49 ; 041FEC
0B23B7 D9    3827** db 0xd9 ; 041FED
0B23B8 C6    3828** db 0xc6 ; 041FEE
0B23B9 42    3829** db 0x42 ; 041FEF 42      5441 DB	"B","C"+80H,08H
0B23BA C3    3830** db 0xc3 ; 041FF0
0B23BB 08    3831** db 0x08 ; 041FF1
0B23BC 44    3832** db 0x44 ; 041FF2 44      5442 DB	"D","E"+80H,0AH
0B23BD C5    3833** db 0xc5 ; 041FF3
0B23BE 0A    3834** db 0x0a ; 041FF4
0B23BF 48    3835** db 0x48 ; 041FF5 48      5443 DB	"H","L"+80H,0CH
0B23C0 CC    3836** db 0xcc ; 041FF6
0B23C1 0C    3837** db 0x0c ; 041FF7
0B23C2 49    3838** db 0x49 ; 041FF8 49      5444 DB	"I","X"+80H,8CH
0B23C3 D8    3839** db 0xd8 ; 041FF9
0B23C4 8C    3840** db 0x8c ; 041FFA
0B23C5 49    3841** db 0x49 ; 041FFB 49      5445 DB	"I","Y"+80H,CCH
0B23C6 D9    3842** db 0xd9 ; 041FFC
0B23C7 CC    3843** db 0xcc ; 041FFD
0B23C8 41    3844** db 0x41 ; 041FFE 41      5446 DB	"A","F"+80H,0EH
0B23C9 C6    3845** db 0xc6 ; 041FFF
0B23CA 0E    3846** db 0x0e ; 042000
0B23CB 53    3847** db 0x53 ; 042001 53      5447 DB	"S","P"+80H,0EH
0B23CC D0    3848** db 0xd0 ; 042002
0B23CD 0E    3849** db 0x0e ; 042003
0B23CE 4E    3850** db 0x4e ; 042004 4E      5449 DB	"N","Z"+80H,10H
0B23CF DA    3851** db 0xda ; 042005
0B23D0 10    3852** db 0x10 ; 042006
0B23D1 DA    3853** db 0xda ; 042007 5A      5450 DB	"Z"+80H,11H
0B23D2 11    3854** db 0x11 ; 042008
0B23D3 4E    3855** db 0x4e ; 042009 4E      5451 DB	"N","C"+80H,12H
0B23D4 C3    3856** db 0xc3 ; 04200A
0B23D5 12    3857** db 0x12 ; 04200B
0B23D6 50    3858** db 0x50 ; 04200C 50      5452 DB	"P","O"+80H,14H
0B23D7 CF    3859** db 0xcf ; 04200D
0B23D8 14    3860** db 0x14 ; 04200E
0B23D9 50    3861** db 0x50 ; 04200F 50      5453 DB	"P","E"+80H,15H
0B23DA C5    3862** db 0xc5 ; 042010
0B23DB 15    3863** db 0x15 ; 042011
0B23DC D0    3864** db 0xd0 ; 042012 50      5454 DB	"P"+80H,16H
0B23DD 16    3865** db 0x16 ; 042013
0B23DE CD    3866** db 0xcd ; 042014 4D      5455 DB	"M"+80H,17H
0B23DF 17    3867** db 0x17 ; 042015
0B23E0 28    3868** db 0x28 ; 042016 28      5457 DB	"(","C"+80H,20H
0B23E1 C3    3869** db 0xc3 ; 042017
0B23E2 20    3870** db 0x20 ; 042018
0B23E3 00    3871** db 0x00 ; 042019 00      5459 DB	0
             3872** ;
             3873** ; Load operations
             3874** ;
             3875** LDOPS:
0B23E4 49    3876** db 0x49 ; 04201A 49      5463 LDOPS:			DB	"I",0,"A"+80H,47H
0B23E5 00    3877** db 0x00 ; 04201B
0B23E6 C1    3878** db 0xc1 ; 04201C
0B23E7 47    3879** db 0x47 ; 04201D
0B23E8 52    3880** db 0x52 ; 04201E 52      5464 DB	"R",0,"A"+80H,4FH
0B23E9 00    3881** db 0x00 ; 04201F
0B23EA C1    3882** db 0xc1 ; 042020
0B23EB 4F    3883** db 0x4f ; 042021
0B23EC 41    3884** db 0x41 ; 042022 41      5465 DB	"A",0,"I"+80H,57H
0B23ED 00    3885** db 0x00 ; 042023
0B23EE C9    3886** db 0xc9 ; 042024
0B23EF 57    3887** db 0x57 ; 042025
0B23F0 41    3888** db 0x41 ; 042026 41      5466 DB	"A",0,"R"+80H,5FH
0B23F1 00    3889** db 0x00 ; 042027
0B23F2 D2    3890** db 0xd2 ; 042028
0B23F3 5F    3891** db 0x5f ; 042029
0B23F4 28    3892** db 0x28 ; 04202A 28      5467 DB	"(BC",0,"A"+80H,02h
0B23F5 42    3893** db 0x42 ; 04202B
0B23F6 43    3894** db 0x43 ; 04202C
0B23F7 00    3895** db 0x00 ; 04202D
0B23F8 C1    3896** db 0xc1 ; 04202E
0B23F9 02    3897** db 0x02 ; 04202F
0B23FA 28    3898** db 0x28 ; 042030 28      5468 DB	"(DE",0,"A"+80H,12H
0B23FB 44    3899** db 0x44 ; 042031
0B23FC 45    3900** db 0x45 ; 042032
0B23FD 00    3901** db 0x00 ; 042033
0B23FE C1    3902** db 0xc1 ; 042034
0B23FF 12    3903** db 0x12 ; 042035
0B2400 41    3904** db 0x41 ; 042036 41      5469 DB	"A",0,"(B","C"+80H,0AH
0B2401 00    3905** db 0x00 ; 042037
0B2402 28    3906** db 0x28 ; 042038
0B2403 42    3907** db 0x42 ; 042039
0B2404 C3    3908** db 0xc3 ; 04203A
0B2405 0A    3909** db 0x0a ; 04203B
0B2406 41    3910** db 0x41 ; 04203C 41      5470 DB	"A",0,"(D","E"+80H,1AH
0B2407 00    3911** db 0x00 ; 04203D
0B2408 28    3912** db 0x28 ; 04203E
0B2409 44    3913** db 0x44 ; 04203F
0B240A C5    3914** db 0xc5 ; 042040
0B240B 1A    3915** db 0x1a ; 042041
0B240C 00    3916** db 0x00 ; 042042 00      5472 DB	0
             3917** ;
             3918** ; eZ80 addressing mode suffixes
             3919** ;
             3920** ; Fully qualified suffixes
             3921** ;
             3922** EZ80SFS_1:
0B240D 4C    3923** db 0x4c ; 042043 4C      5478 EZ80SFS_1:		DB	"LI","S"+80H,49H
0B240E 49    3924** db 0x49 ; 042044
0B240F D3    3925** db 0xd3 ; 042045
0B2410 49    3926** db 0x49 ; 042046
0B2411 53    3927** db 0x53 ; 042047 53      5479 DB	"SI","L"+80H,52H
0B2412 49    3928** db 0x49 ; 042048
0B2413 CC    3929** db 0xcc ; 042049
0B2414 52    3930** db 0x52 ; 04204A
             3931** 
             3932** EZ80SFS_2:
0B2415 53    3933** db 0x53 ; 04204B 53      5480 EZ80SFS_2:		DB	"SI","S"+80H,40H
0B2416 49    3934** db 0x49 ; 04204C
0B2417 D3    3935** db 0xd3 ; 04204D
0B2418 40    3936** db 0x40 ; 04204E
0B2419 4C    3937** db 0x4c ; 04204F 4C      5481 DB	"LI","L"+80H,5BH
0B241A 49    3938** db 0x49 ; 042050
0B241B CC    3939** db 0xcc ; 042051
0B241C 5B    3940** db 0x5b ; 042052
0B241D 00    3941** db 0x00 ; 042053 00      5483 DB	0
             3942** ;
             3943** ; Shortcuts when ADL mode is 0
             3944** ;
             3945** EZ80SFS_ADL0:
0B241E D3    3946** db 0xd3 ; 042054 53      5487 EZ80SFS_ADL0:		DB	"S"+80H,40H		; Equivalent to .SIS
0B241F 40    3947** db 0x40 ; 042055
0B2420 CC    3948** db 0xcc ; 042056 4C      5488 DB	"L"+80H,49H		; Equivalent to .LIS
0B2421 49    3949** db 0x49 ; 042057
0B2422 49    3950** db 0x49 ; 042058 49      5489 DB	"I","S"+80H,40H		; Equivalent to .SIS
0B2423 D3    3951** db 0xd3 ; 042059
0B2424 40    3952** db 0x40 ; 04205A
0B2425 49    3953** db 0x49 ; 04205B 49      5490 DB	"I","L"+80H,52H		; Equivalent to .SIL
0B2426 CC    3954** db 0xcc ; 04205C
0B2427 52    3955** db 0x52 ; 04205D
0B2428 00    3956** db 0x00 ; 04205E 00      5492 DB	0
             3957** ;
             3958** ; Shortcuts when ADL mode is 1
             3959** ;
             3960** EZ80SFS_ADL1:
0B2429 D3    3961** db 0xd3 ; 04205F 53      5496 EZ80SFS_ADL1:		DB	"S"+80H,52H		; Equivalent to .SIL
0B242A 52    3962** db 0x52 ; 042060
0B242B CC    3963** db 0xcc ; 042061 4C      5497 DB	"L"+80H,5BH		; Equivalent to .LIL
0B242C 5B    3964** db 0x5b ; 042062
0B242D 49    3965** db 0x49 ; 042063 49      5498 DB	"I","S"+80H,49H		; Equivalent to .LIS
0B242E D3    3966** db 0xd3 ; 042064
0B242F 49    3967** db 0x49 ; 042065
0B2430 49    3968** db 0x49 ; 042066 49      5499 DB	"I","L"+80H,5BH		; Equivalent to .LIL
0B2431 CC    3969** db 0xcc ; 042067
0B2432 5B    3970** db 0x5b ; 042068
0B2433 00    3971** db 0x00 ; 042069 00      5501 DB	0
             3972** ; END INSERT FROM BINARY
             3973** ;
             3974** ; .LIST
             3975** ;
             3976** ; already defined in equs.inc
             3977** ; LF:			EQU     0AH
             3978** ; CR:			EQU     0DH
              0007* include "fpp.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Z80 Floating Point Package
             0004** ; Author:	(C) Copyright  R.T.Russell  1986
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	03/05/2022
             0007** ; Last Updated:	07/06/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 26/10/1986:	Version 0.0
             0011** ; 14/12/1988:	Vesion 0.1 (Bug Fix)
             0012** ; 12/05/2023:	Modified by Dean Belfield
             0013** ; 07/06/2023:	Modified to run in ADL mode
             0014** 
             0015** ; .ASSUME	ADL = 1
             0016** 
             0017** ; SEGMENT CODE
             0018** 
             0019** ; XDEF	FPP
             0020** ; XDEF	DLOAD5
             0021** ; XDEF	DLOAD5_SPL
             0022** ;
             0023** ;BINARY FLOATING POINT REPRESENTATION:
             0024** ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
             0025** ;    8 BIT EXCESS-128 SIGNED EXPONENT
             0026** ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
             0027** ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
             0028** ;
             0029** ;BINARY INTEGER REPRESENTATION:
             0030** ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
             0031** ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
             0032** ;
             0033** ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
             0034** ;                            EXPONENT - C
             0035** ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
             0036** ;                               EXPONENT - B
             0037** 
             0038** ;
             0039** ;Error codes:
             0040** ;
             0041** 
             0042** BADOP:			EQU     1               ;Bad operation code
             0043** DIVBY0:			EQU     18              ;Division by zero
             0044** TOOBIG_FP:			EQU     20              ;Too big
             0045** NGROOT:			EQU     21              ;Negative root
             0046** LOGRNG:			EQU     22              ;Log range
             0047** ACLOST:			EQU     23              ;Accuracy lost
             0048** EXPRNG:			EQU     24              ;Exp range
             0049** ;
             0050** ;Call entry and despatch code:
             0051** ;
             0052** FPP:
             0053** ; call dumpRegistersHexAll ; DEBUG
             0054** ; call printNewLine ; DEBUG
             0055** 
0B2434 FD    0056** PUSH    IY              ;Save IY
0B2435 E5 
0B2436 FD    0057** LD      IY,0
0B2437 21 
0B2438 00 
0B2439 00 
0B2439 00   
0B243B FD    0058** ADD     IY,SP           ;Save SP in IY
0B243C 39 
0B243D CD    0059** CALL    OP              ;Perform operation
0B243E 4D 
0B243F 24 
0B2440 0B 
0B2441 BF    0060** CP      A               ;Good return (Z, NC)
0B2442 FD    0061** EXIT_FP_:			POP     IY              ;Restore IY
0B2443 E1 
0B2444 C9    0062** RET                     ;Return to caller
             0063** ;
             0064** ;Error exit:
             0065** ;
0B2445 3E    0066** BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B2446 01 
0B2447 FD    0067** ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B2448 F9 
0B2449 B7    0068** OR      A               ;Set NZ
0B244A 37    0069** SCF                     ;Set C
0B244B 18    0070** JR      EXIT_FP_
0B244C F5 
             0071** ;
             0072** ;Perform operation or function:
             0073** ;
             0074** ; OP:			CP      (RTABLE-DTABLE)/3
0B244D FE    0075** OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B244E 2A 
             0076** 
0B244F 30    0077** JR      NC,BAD_FP
0B2450 F4 
             0078** ; CP      (FTABLE-DTABLE)/3
0B2451 FE    0079** CP      FTABLE-DTABLE/3 ; ditto
0B2452 10 
0B2453 30    0080** JR      NC,DISPAT_FP
0B2454 08 
0B2455 08    0081** EX      AF,AF'
0B2456 78    0082** LD      A,B
0B2457 B1    0083** OR      C               ;Both integer?
0B2458 C4    0084** CALL    NZ,FLOATA       ;No, so float both
0B2459 60 
0B245A 2F 
0B245B 0B 
0B245C 08    0085** EX      AF,AF'
0B245D E5    0086** DISPAT_FP:			PUSH    HL
0B245E 21    0087** LD      HL,DTABLE
0B245F 70 
0B2460 24 
0B2461 0B 
0B2462 C5    0088** PUSH    BC
0B2463 01    0089** LD	BC, 3		; C = 3
0B2464 03 
0B2465 00 
0B2466 00 
0B2467 47    0090** LD	B, A 		; B = op-code
0B2468 ED    0091** MLT 	BC 		;BC = op-code * 3
0B2469 4C 
0B246A 09    0092** ADD	HL, BC 		;Add to table base
0B246B ED    0093** LD	HL, (HL)	;Get the routine address (24-bit)
0B246C 27 
             0094** 
             0095** ;        		ADD     A, A            ;A = op-code * 2
             0096** ;        		LD      C,A
             0097** ;        		LD      B,0             ;BC = op-code * 2
             0098** ;        		ADD     HL,BC
             0099** ;        		LD      A,(HL)          ;Get low byte
             0100** ;        		INC     HL
             0101** ;        		LD      H,(HL)          ;Get high byte
             0102** ;        		LD      L,A
             0103** 
0B246D C1    0104** POP     BC
0B246E E3    0105** EX      (SP),HL
0B246F C9    0106** RET                     ;Off to routine
             0107** ;
             0108** ;Despatch table:
             0109** ;
0B2470 22    0110** DTABLE:			DW24  IAND            ;AND (INTEGER)
0B2471 25 
0B2472 0B 
0B2473 90    0111** DW24  IBDIV           ;DIV
0B2474 25 
0B2475 0B 
0B2476 35    0112** DW24  IEOR            ;EOR
0B2477 25 
0B2478 0B 
0B2479 5B    0113** DW24  IMOD            ;MOD
0B247A 25 
0B247B 0B 
0B247C 48    0114** DW24  IOR             ;OR
0B247D 25 
0B247E 0B 
0B247F 16    0115** DW24  ILE             ;<=
0B2480 28 
0B2481 0B 
0B2482 25    0116** DW24  INE             ;<>
0B2483 28 
0B2484 0B 
0B2485 09    0117** DW24  IGE             ;>=
0B2486 28 
0B2487 0B 
0B2488 EE    0118** DW24  ILT             ;<
0B2489 27 
0B248A 0B 
0B248B 32    0119** DW24  IEQ             ;=
0B248C 28 
0B248D 0B 
0B248E 7E    0120** DW24  IMUL            ;*
0B248F 26 
0B2490 0B 
0B2491 B9    0121** DW24  IADD            ;+
0B2492 25 
0B2493 0B 
0B2494 FB    0122** DW24  IGT             ;>
0B2495 27 
0B2496 0B 
0B2497 A0    0123** DW24  ISUB            ;-
0B2498 25 
0B2499 0B 
0B249A 35    0124** DW24  IPOW            ;^
0B249B 27 
0B249C 0B 
0B249D 2B    0125** DW24  IDIV            ;/
0B249E 26 
0B249F 0B 
             0126** ;
             0127** FTABLE:
0B24A0 44    0128** DW24  ABSV_FP            ;ABS
0B24A1 28 
0B24A2 0B 
0B24A3 2A    0129** DW24  ACS_FP             ;ACS
0B24A4 2C 
0B24A5 0B 
0B24A6 68    0130** DW24  ASN_FP             ;ASN
0B24A7 2B 
0B24A8 0B 
0B24A9 98    0131** DW24  ATN_FP             ;ATN
0B24AA 2B 
0B24AB 0B 
0B24AC 63    0132** DW24  COS_FP             ;COS
0B24AD 29 
0B24AE 0B 
0B24AF 72    0133** DW24  DEG_FP             ;DEG
0B24B0 28 
0B24B1 0B 
0B24B2 1F    0134** DW24  EXP_FP             ;EXP
0B24B3 2A 
0B24B4 0B 
0B24B5 C6    0135** DW24  INT_FP_            ;INT
0B24B6 28 
0B24B7 0B 
0B24B8 BD    0136** DW24  LN_FP              ;LN
0B24B9 2A 
0B24BA 0B 
0B24BB 52    0137** DW24  LOG_FP             ;LOG
0B24BC 2B 
0B24BD 0B 
0B24BE 50    0138** DW24  NOTK_FP            ;NOT
0B24BF 28 
0B24C0 0B 
0B24C1 7C    0139** DW24  RAD_FP             ;RAD
0B24C2 28 
0B24C3 0B 
0B24C4 97    0140** DW24  SGN_FP             ;SGN
0B24C5 28 
0B24C6 0B 
0B24C7 70    0141** DW24  SIN_FP             ;SIN
0B24C8 29 
0B24C9 0B 
0B24CA DF    0142** DW24  SQR_FP             ;SQR
0B24CB 28 
0B24CC 0B 
0B24CD 3D    0143** DW24  TAN_FP             ;TAN
0B24CE 29 
0B24CF 0B 
             0144** ;
0B24D0 ED    0145** DW24  ZERO_FP            ;ZERO
0B24D1 2F 
0B24D2 0B 
0B24D3 F8    0146** DW24  FONE_FP            ;FONE
0B24D4 29 
0B24D5 0B 
0B24D6 37    0147** DW24  TRUE_FP            ;TRUE
0B24D7 28 
0B24D8 0B 
0B24D9 64    0148** DW24  PI_FP              ;PI
0B24DA 28 
0B24DB 0B 
             0149** ;
0B24DC AB    0150** DW24  VAL_FP             ;VAL
0B24DD 28 
0B24DE 0B 
0B24DF 33    0151** DW24  STR_FP             ;STR$
0B24E0 2C 
0B24E1 0B 
             0152** ;
0B24E2 94    0153** DW24  SFIX_FP            ;FIX
0B24E3 2E 
0B24E4 0B 
0B24E5 70    0154** DW24  SFLOAT_FP          ;FLOAT
0B24E6 2F 
0B24E7 0B 
             0155** ;
0B24E8 BE    0156** DW24  FTEST_FP           ;TEST
0B24E9 2F 
0B24EA 0B 
0B24EB D0    0157** DW24  FCOMP_FP           ;COMPARE
0B24EC 2F 
0B24ED 0B 
             0158** ;
0B24EE 1E    0159** RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B24EF 25 
0B24F0 0B 
0B24F1 8C    0160** DW24  FBDIV           ;DIV
0B24F2 25 
0B24F3 0B 
0B24F4 31    0161** DW24  FEOR            ;EOR
0B24F5 25 
0B24F6 0B 
0B24F7 57    0162** DW24  FMOD            ;MOD
0B24F8 25 
0B24F9 0B 
0B24FA 44    0163** DW24  FFOR             ;OR
0B24FB 25 
0B24FC 0B 
0B24FD 10    0164** DW24  FLE             ;<=
0B24FE 28 
0B24FF 0B 
0B2500 1F    0165** DW24  FNE             ;<>
0B2501 28 
0B2502 0B 
0B2503 03    0166** DW24  FGE             ;>=
0B2504 28 
0B2505 0B 
0B2506 E8    0167** DW24  FLT             ;<
0B2507 27 
0B2508 0B 
0B2509 2C    0168** DW24  FEQ             ;=
0B250A 28 
0B250B 0B 
0B250C D8    0169** DW24  FMUL            ;*
0B250D 26 
0B250E 0B 
0B250F C6    0170** DW24  FADD            ;+
0B2510 25 
0B2511 0B 
0B2512 F5    0171** DW24  FGT             ;>
0B2513 27 
0B2514 0B 
0B2515 AD    0172** DW24  FSUB            ;-
0B2516 25 
0B2517 0B 
0B2518 B5    0173** DW24  FPOW            ;^
0B2519 27 
0B251A 0B 
0B251B 2F    0174** DW24  FDIV            ;/
0B251C 26 
0B251D 0B 
             0175** ;
             0176** ;       PAGE
             0177** ;
             0178** ;ARITHMETIC AND LOGICAL OPERATORS:
             0179** ;All take two arguments, in HLH'L'C & DED'E'B.
             0180** ;Output in HLH'L'C
             0181** ;All registers except IX, IY destroyed.
             0182** ; (N.B. FPOW destroys IX).
             0183** ;
             0184** ;FAND - Floating-point AND.
             0185** ;IAND - Integer AND.
             0186** ;
0B251E CD    0187** FAND:			CALL    FIX2
0B251F 88 
0B2520 2E 
0B2521 0B 
0B2522 7C    0188** IAND:			LD      A,H
0B2523 A2    0189** AND     D
0B2524 67    0190** LD      H,A
0B2525 7D    0191** LD      A,L
0B2526 A3    0192** AND     E
0B2527 6F    0193** LD      L,A
0B2528 D9    0194** EXX
0B2529 7C    0195** LD      A,H
0B252A A2    0196** AND     D
0B252B 67    0197** LD      H,A
0B252C 7D    0198** LD      A,L
0B252D A3    0199** AND     E
0B252E 6F    0200** LD      L,A
0B252F D9    0201** EXX
0B2530 C9    0202** RET
             0203** ;
             0204** ;FEOR - Floating-point exclusive-OR.
             0205** ;IEOR - Integer exclusive-OR.
             0206** ;
0B2531 CD    0207** FEOR:			CALL    FIX2
0B2532 88 
0B2533 2E 
0B2534 0B 
0B2535 7C    0208** IEOR:			LD      A,H
0B2536 AA    0209** XOR     D
0B2537 67    0210** LD      H,A
0B2538 7D    0211** LD      A,L
0B2539 AB    0212** XOR     E
0B253A 6F    0213** LD      L,A
0B253B D9    0214** EXX
0B253C 7C    0215** LD      A,H
0B253D AA    0216** XOR     D
0B253E 67    0217** LD      H,A
0B253F 7D    0218** LD      A,L
0B2540 AB    0219** XOR     E
0B2541 6F    0220** LD      L,A
0B2542 D9    0221** EXX
0B2543 C9    0222** RET
             0223** ;
             0224** ;FOR - Floating-point OR.
             0225** ;IOR - Integer OR.
             0226** ;
0B2544 CD    0227** FFOR:			CALL    FIX2
0B2545 88 
0B2546 2E 
0B2547 0B 
0B2548 7C    0228** IOR:			LD      A,H
0B2549 B2    0229** OR      D
0B254A 67    0230** LD      H,A
0B254B 7D    0231** LD      A,L
0B254C B3    0232** OR      E
0B254D 6F    0233** LD      L,A
0B254E D9    0234** EXX
0B254F 7C    0235** LD      A,H
0B2550 B2    0236** OR      D
0B2551 67    0237** LD      H,A
0B2552 7D    0238** LD      A,L
0B2553 B3    0239** OR      E
0B2554 6F    0240** LD      L,A
0B2555 D9    0241** EXX
0B2556 C9    0242** RET
             0243** ;
             0244** ;FMOD - Floating-point remainder.
             0245** ;IMOD - Integer remainder.
             0246** ;
0B2557 CD    0247** FMOD:			CALL    FIX2
0B2558 88 
0B2559 2E 
0B255A 0B 
0B255B 7C    0248** IMOD:			LD      A,H
0B255C AA    0249** XOR     D               ;DIV RESULT SIGN
0B255D CB    0250** BIT     7,H
0B255E 7C 
0B255F 08    0251** EX      AF,AF'
0B2560 CB    0252** BIT     7,H
0B2561 7C 
0B2562 C4    0253** CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B2563 A4 
0B2564 2E 
0B2565 0B 
0B2566 CD    0254** CALL    SWAP_FP
0B2567 A1 
0B2568 2F 
0B2569 0B 
0B256A CB    0255** BIT     7,H
0B256B 7C 
0B256C C4    0256** CALL    NZ,NEGATE
0B256D A4 
0B256E 2E 
0B256F 0B 
0B2570 44    0257** LD      B,H
0B2571 4D    0258** LD      C,L
0B2572 21    0259** LD      HL,0
0B2573 00 
0B2574 00 
0B2575 00 
0B2576 D9    0260** EXX
0B2577 44    0261** LD      B,H
0B2578 4D    0262** LD      C,L
0B2579 21    0263** LD      HL,0
0B257A 00 
0B257B 00 
0B257C 00 
0B257D 3E    0264** LD      A,-33
0B257E DF 
0B257F CD    0265** CALL    DIVA            ;DIVIDE
0B2580 2E 
0B2581 31 
0B2582 0B 
0B2583 D9    0266** EXX
0B2584 0E    0267** LD      C,0             ;INTEGER MARKER
0B2585 00 
0B2586 08    0268** EX      AF,AF'
0B2587 C8    0269** RET     Z
0B2588 C3    0270** JP      NEGATE
0B2589 A4 
0B258A 2E 
0B258B 0B 
             0271** ;
             0272** ;BDIV - Integer division.
             0273** ;
0B258C CD    0274** FBDIV:			CALL    FIX2
0B258D 88 
0B258E 2E 
0B258F 0B 
0B2590 CD    0275** IBDIV:			CALL    IMOD
0B2591 5B 
0B2592 25 
0B2593 0B 
0B2594 B7    0276** OR      A
0B2595 CD    0277** CALL    SWAP_FP
0B2596 A1 
0B2597 2F 
0B2598 0B 
0B2599 0E    0278** LD      C,0
0B259A 00 
0B259B F0    0279** RET     P
0B259C C3    0280** JP      NEGATE
0B259D A4 
0B259E 2E 
0B259F 0B 
             0281** ;
             0282** ;ISUB - Integer subtraction.
             0283** ;FSUB - Floating point subtraction with rounding.
             0284** ;
0B25A0 CD    0285** ISUB:			CALL    SUB_
0B25A1 3C 
0B25A2 30 
0B25A3 0B 
0B25A4 E0    0286** RET     PO
0B25A5 CD    0287** CALL    ADD_
0B25A6 34 
0B25A7 30 
0B25A8 0B 
0B25A9 CD    0288** CALL    FLOAT2
0B25AA 64 
0B25AB 2F 
0B25AC 0B 
0B25AD 7A    0289** FSUB:			LD      A,D
0B25AE EE    0290** XOR     80H             ;CHANGE SIGN THEN ADD
0B25AF 80 
0B25B0 57    0291** LD      D,A
0B25B1 18    0292** JR      FADD
0B25B2 13 
             0293** ;
             0294** ;Reverse subtract.
             0295** ;
0B25B3 7C    0296** RSUB:			LD      A,H
0B25B4 EE    0297** XOR     80H
0B25B5 80 
0B25B6 67    0298** LD      H,A
0B25B7 18    0299** JR      FADD
0B25B8 0D 
             0300** ;
             0301** ;IADD - Integer addition.
             0302** ;FADD - Floating point addition with rounding.
             0303** ;
0B25B9 CD    0304** IADD:			CALL    ADD_
0B25BA 34 
0B25BB 30 
0B25BC 0B 
0B25BD E0    0305** RET     PO
0B25BE CD    0306** CALL    SUB_
0B25BF 3C 
0B25C0 30 
0B25C1 0B 
0B25C2 CD    0307** CALL    FLOAT2
0B25C3 64 
0B25C4 2F 
0B25C5 0B 
0B25C6 05    0308** FADD:			DEC     B
0B25C7 04    0309** INC     B
0B25C8 C8    0310** RET     Z               ;ARG 2 ZERO
0B25C9 0D    0311** DEC     C
0B25CA 0C    0312** INC     C
0B25CB CA    0313** JP      Z,SWAP_FP          ;ARG 1 ZERO
0B25CC A1 
0B25CD 2F 
0B25CE 0B 
0B25CF D9    0314** EXX
0B25D0 01    0315** LD      BC,0            ;INITIALISE
0B25D1 00 
0B25D2 00 
0B25D3 00 
0B25D4 D9    0316** EXX
0B25D5 7C    0317** LD      A,H
0B25D6 AA    0318** XOR     D               ;XOR SIGNS
0B25D7 F5    0319** PUSH    AF
0B25D8 78    0320** LD      A,B
0B25D9 B9    0321** CP      C               ;COMPARE EXPONENTS
0B25DA DC    0322** CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B25DB A1 
0B25DC 2F 
0B25DD 0B 
0B25DE 78    0323** LD      A,B
0B25DF CB    0324** SET     7,H             ;IMPLIED 1
0B25E0 FC 
0B25E1 C4    0325** CALL    NZ,FIX          ;ALIGN
0B25E2 75 
0B25E3 2E 
0B25E4 0B 
0B25E5 F1    0326** POP     AF
0B25E6 7A    0327** LD      A,D             ;SIGN OF LARGER
0B25E7 CB    0328** SET     7,D             ;IMPLIED 1
0B25E8 FA 
0B25E9 FA    0329** JP      M,FADD3         ;SIGNS DIFFERENT
0B25EA F9 
0B25EB 25 
0B25EC 0B 
0B25ED CD    0330** CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B25EE 34 
0B25EF 30 
0B25F0 0B 
0B25F1 DC    0331** CALL    C,DIV2          ;NORMALISE
0B25F2 A9 
0B25F3 2F 
0B25F4 0B 
0B25F5 CB    0332** SET     7,H
0B25F6 FC 
0B25F7 18    0333** JR      FADD4
0B25F8 0D 
             0334** ;
0B25F9 CD    0335** FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B25FA 3C 
0B25FB 30 
0B25FC 0B 
0B25FD DC    0336** CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B25FE BC 
0B25FF 2E 
0B2600 0B 
0B2601 CD    0337** CALL    FLO48
0B2602 3B 
0B2603 2F 
0B2604 0B 
0B2605 2F    0338** CPL                     ;CHANGE RESULT SIGN
0B2606 D9    0339** FADD4:			EXX
0B2607 EB    0340** EX      DE,HL
0B2608 21    0341** LD      HL,8000H
0B2609 00 
0B260A 80 
0B260B 00 
0B260C B7    0342** OR      A               ;CLEAR CARRY
0B260D 52    0343** SBC.S   HL,BC
0B260E ED 
0B260F 42 
0B2610 EB    0344** EX      DE,HL
0B2611 D9    0345** EXX
0B2612 CC    0346** CALL    Z,ODD           ;ROUND UNBIASSED
0B2613 9B 
0B2614 2F 
0B2615 0B 
0B2616 DC    0347** CALL    C,ADD1_FP          ;ROUND UP
0B2617 89 
0B2618 2F 
0B2619 0B 
0B261A DC    0348** CALL    C,INCC
0B261B B6 
0B261C 2F 
0B261D 0B 
0B261E CB    0349** RES     7,H
0B261F BC 
0B2620 0D    0350** DEC     C
0B2621 0C    0351** INC     C
0B2622 CA    0352** JP      Z,ZERO_FP
0B2623 ED 
0B2624 2F 
0B2625 0B 
0B2626 B7    0353** OR      A               ;RESULT SIGNQ
0B2627 F0    0354** RET     P               ;POSITIVE
0B2628 CB    0355** SET     7,H             ;NEGATIVE
0B2629 FC 
0B262A C9    0356** RET
             0357** ;
             0358** ;IDIV - Integer division.
             0359** ;FDIV - Floating point division with rounding.
             0360** ;
0B262B CD    0361** IDIV:			CALL    FLOAT2
0B262C 64 
0B262D 2F 
0B262E 0B 
0B262F 05    0362** FDIV:			DEC     B               ;TEST FOR ZERO
0B2630 04    0363** INC     B
0B2631 3E    0364** LD      A,DIVBY0
0B2632 12 
0B2633 CA    0365** JP      Z,ERROR_FP_         ;"Division by zero"
0B2634 47 
0B2635 24 
0B2636 0B 
0B2637 0D    0366** DEC     C               ;TEST FOR ZERO
0B2638 0C    0367** INC     C
0B2639 C8    0368** RET     Z
0B263A 7C    0369** LD      A,H
0B263B AA    0370** XOR     D               ;CALC. RESULT SIGN
0B263C 08    0371** EX      AF,AF'          ;SAVE SIGN
0B263D CB    0372** SET     7,D             ;REPLACE IMPLIED 1's
0B263E FA 
0B263F CB    0373** SET     7,H
0B2640 FC 
0B2641 C5    0374** PUSH    BC              ;SAVE EXPONENTS
0B2642 42    0375** LD      B,D             ;LOAD REGISTERS
0B2643 4B    0376** LD      C,E
0B2644 11    0377** LD      DE,0
0B2645 00 
0B2646 00 
0B2647 00 
0B2648 D9    0378** EXX
0B2649 42    0379** LD      B,D
0B264A 4B    0380** LD      C,E
0B264B 11    0381** LD      DE,0
0B264C 00 
0B264D 00 
0B264E 00 
0B264F 3E    0382** LD      A,-32           ;LOOP COUNTER
0B2650 E0 
0B2651 CD    0383** CALL    DIVA            ;DIVIDE
0B2652 2E 
0B2653 31 
0B2654 0B 
0B2655 D9    0384** EXX
0B2656 CB    0385** BIT     7,D
0B2657 7A 
0B2658 D9    0386** EXX
0B2659 CC    0387** CALL    Z,DIVB          ;NORMALISE & INC A
0B265A 4D 
0B265B 31 
0B265C 0B 
0B265D EB    0388** EX      DE,HL
0B265E D9    0389** EXX
0B265F CB    0390** SRL     B               ;DIVISOR/2
0B2660 38 
0B2661 CB    0391** RR      C
0B2662 19 
0B2663 B7    0392** OR      A               ;CLEAR CARRY
0B2664 52    0393** SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B2665 ED 
0B2666 42 
0B2667 3F    0394** CCF
0B2668 EB    0395** EX      DE,HL           ;RESULT IN HLH'L'
0B2669 CC    0396** CALL    Z,ODD           ;ROUND UNBIASSED
0B266A 9B 
0B266B 2F 
0B266C 0B 
0B266D DC    0397** CALL    C,ADD1_FP          ;ROUND UP
0B266E 89 
0B266F 2F 
0B2670 0B 
0B2671 C1    0398** POP     BC              ;RESTORE EXPONENTS
0B2672 DC    0399** CALL    C,INCC
0B2673 B6 
0B2674 2F 
0B2675 0B 
0B2676 1F    0400** RRA                     ;LSB OF A TO CARRY
0B2677 79    0401** LD      A,C             ;COMPUTE NEW EXPONENT
0B2678 98    0402** SBC     A,B
0B2679 3F    0403** CCF
0B267A C3    0404** JP      CHKOVF
0B267B 1B 
0B267C 27 
0B267D 0B 
             0405** ;
             0406** ;IMUL - Integer multiplication.
             0407** ;
0B267E 7C    0408** IMUL:			LD      A,H
0B267F AA    0409** XOR     D
0B2680 08    0410** EX      AF,AF'          ;SAVE RESULT SIGN
0B2681 CB    0411** BIT     7,H
0B2682 7C 
0B2683 C4    0412** CALL    NZ,NEGATE
0B2684 A4 
0B2685 2E 
0B2686 0B 
0B2687 CD    0413** CALL    SWAP_FP
0B2688 A1 
0B2689 2F 
0B268A 0B 
0B268B CB    0414** BIT     7,H
0B268C 7C 
0B268D C4    0415** CALL    NZ,NEGATE
0B268E A4 
0B268F 2E 
0B2690 0B 
0B2691 44    0416** LD      B,H
0B2692 4D    0417** LD      C,L
0B2693 21    0418** LD      HL,0
0B2694 00 
0B2695 00 
0B2696 00 
0B2697 D9    0419** EXX
0B2698 44    0420** LD      B,H
0B2699 4D    0421** LD      C,L
0B269A 21    0422** LD      HL,0
0B269B 00 
0B269C 00 
0B269D 00 
0B269E 3E    0423** LD      A,-33
0B269F DF 
0B26A0 CD    0424** CALL    MULA            ;MULTIPLY
0B26A1 65 
0B26A2 31 
0B26A3 0B 
0B26A4 D9    0425** EXX
0B26A5 0E    0426** LD      C,191           ;PRESET EXPONENT
0B26A6 BF 
0B26A7 CD    0427** CALL    TEST_FP            ;TEST RANGE
0B26A8 C9 
0B26A9 2F 
0B26AA 0B 
0B26AB 20    0428** JR      NZ,IMUL1        ;TOO BIG
0B26AC 0F 
0B26AD CB    0429** BIT     7,D
0B26AE 7A 
0B26AF 20    0430** JR      NZ,IMUL1
0B26B0 0B 
0B26B1 CD    0431** CALL    SWAP_FP
0B26B2 A1 
0B26B3 2F 
0B26B4 0B 
0B26B5 4A    0432** LD      C,D             ;INTEGER MARKER
0B26B6 08    0433** EX      AF,AF'
0B26B7 F0    0434** RET     P
0B26B8 C3    0435** JP      NEGATE
0B26B9 A4 
0B26BA 2E 
0B26BB 0B 
             0436** ;
0B26BC 0D    0437** IMUL1:			DEC     C
0B26BD D9    0438** EXX
0B26BE CB    0439** SLA     E
0B26BF 23 
0B26C0 CB    0440** RL      D
0B26C1 12 
0B26C2 D9    0441** EXX
0B26C3 CB    0442** RL      E
0B26C4 13 
0B26C5 CB    0443** RL      D
0B26C6 12 
0B26C7 D9    0444** EXX
0B26C8 52    0445** ADC.S   HL,HL
0B26C9 ED 
0B26CA 6A 
0B26CB D9    0446** EXX
0B26CC 52    0447** ADC.S   HL,HL
0B26CD ED 
0B26CE 6A 
0B26CF F2    0448** JP      P,IMUL1         ;NORMALISE
0B26D0 BC 
0B26D1 26 
0B26D2 0B 
0B26D3 08    0449** EX      AF,AF'
0B26D4 F8    0450** RET     M
0B26D5 CB    0451** RES     7,H             ;POSITIVE
0B26D6 BC 
0B26D7 C9    0452** RET
             0453** ;
             0454** ;FMUL - Floating point multiplication with rounding.
             0455** ;
             0456** FMUL:
             0457** ; call dumpRegistersHexAll ; DEBUG
             0458** ; call printNewLine ; DEBUG
             0459** 
0B26D8 05    0460** DEC     B               ;TEST FOR ZERO
0B26D9 04    0461** INC     B
0B26DA CA    0462** JP      Z,ZERO_FP
0B26DB ED 
0B26DC 2F 
0B26DD 0B 
0B26DE 0D    0463** DEC     C               ;TEST FOR ZERO
0B26DF 0C    0464** INC     C
0B26E0 C8    0465** RET     Z
0B26E1 7C    0466** LD      A,H
0B26E2 AA    0467** XOR     D               ;CALC. RESULT SIGN
0B26E3 08    0468** EX      AF,AF'
0B26E4 CB    0469** SET     7,D             ;REPLACE IMPLIED 1's
0B26E5 FA 
0B26E6 CB    0470** SET     7,H
0B26E7 FC 
0B26E8 C5    0471** PUSH    BC              ;SAVE EXPONENTS
0B26E9 44    0472** LD      B,H             ;LOAD REGISTERS
0B26EA 4D    0473** LD      C,L
0B26EB 21    0474** LD      HL,0
0B26EC 00 
0B26ED 00 
0B26EE 00 
0B26EF D9    0475** EXX
0B26F0 44    0476** LD      B,H
0B26F1 4D    0477** LD      C,L
0B26F2 21    0478** LD      HL,0
0B26F3 00 
0B26F4 00 
0B26F5 00 
0B26F6 3E    0479** LD      A,-32           ;LOOP COUNTER
0B26F7 E0 
0B26F8 CD    0480** CALL    MULA            ;MULTIPLY
0B26F9 65 
0B26FA 31 
0B26FB 0B 
0B26FC DC    0481** CALL    C,MULB          ;NORMALISE & INC A
0B26FD 7B 
0B26FE 31 
0B26FF 0B 
0B2700 D9    0482** EXX
0B2701 E5    0483** PUSH    HL
0B2702 21    0484** LD      HL,8000H
0B2703 00 
0B2704 80 
0B2705 00 
0B2706 B7    0485** OR      A               ;CLEAR CARRY
0B2707 52    0486** SBC.S   HL,DE
0B2708 ED 
0B2709 52 
0B270A E1    0487** POP     HL
0B270B CC    0488** CALL    Z,ODD           ;ROUND UNBIASSED
0B270C 9B 
0B270D 2F 
0B270E 0B 
0B270F DC    0489** CALL    C,ADD1_FP          ;ROUND UP
0B2710 89 
0B2711 2F 
0B2712 0B 
0B2713 C1    0490** POP     BC              ;RESTORE EXPONENTS
0B2714 DC    0491** CALL    C,INCC
0B2715 B6 
0B2716 2F 
0B2717 0B 
0B2718 1F    0492** RRA                     ;LSB OF A TO CARRY
0B2719 79    0493** LD      A,C             ;COMPUTE NEW EXPONENT
0B271A 88    0494** ADC     A,B
0B271B 38    0495** CHKOVF:			JR      C,CHKO1
0B271C 06 
0B271D F2    0496** JP      P,ZERO_FP          ;UNDERFLOW
0B271E ED 
0B271F 2F 
0B2720 0B 
0B2721 18    0497** JR      CHKO2
0B2722 04 
0B2723 FA    0498** CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B2724 B8 
0B2725 2F 
0B2726 0B 
0B2727 C6    0499** CHKO2:			ADD     A,80H
0B2728 80 
0B2729 4F    0500** LD      C,A
0B272A CA    0501** JP      Z,ZERO_FP
0B272B ED 
0B272C 2F 
0B272D 0B 
0B272E 08    0502** EX      AF,AF'          ;RESTORE SIGN BIT
0B272F CB    0503** RES     7,H
0B2730 BC 
0B2731 F0    0504** RET     P
0B2732 CB    0505** SET     7,H
0B2733 FC 
0B2734 C9    0506** RET
             0507** ;
             0508** ;IPOW - Integer involution.
             0509** ;
0B2735 CD    0510** IPOW:			CALL    SWAP_FP
0B2736 A1 
0B2737 2F 
0B2738 0B 
0B2739 CB    0511** BIT     7,H
0B273A 7C 
0B273B F5    0512** PUSH    AF              ;SAVE SIGN
0B273C C4    0513** CALL    NZ,NEGATE
0B273D A4 
0B273E 2E 
0B273F 0B 
0B2740 48    0514** IPOW0:			LD      C,B
0B2741 06    0515** LD      B,32            ;LOOP COUNTER
0B2742 20 
0B2743 CD    0516** IPOW1:			CALL    X2
0B2744 59 
0B2745 30 
0B2746 0B 
0B2747 38    0517** JR      C,IPOW2
0B2748 08 
0B2749 10    0518** DJNZ    IPOW1
0B274A F8 
0B274B F1    0519** POP     AF
0B274C D9    0520** EXX
0B274D 2C    0521** INC     L               ;RESULT=1
0B274E D9    0522** EXX
0B274F 4C    0523** LD      C,H
0B2750 C9    0524** RET
             0525** ;
0B2751 F1    0526** IPOW2:			POP     AF
0B2752 C5    0527** PUSH    BC
0B2753 EB    0528** EX      DE,HL
0B2754 E5    0529** PUSH    HL
0B2755 D9    0530** EXX
0B2756 EB    0531** EX      DE,HL
0B2757 E5    0532** PUSH    HL
0B2758 D9    0533** EXX
0B2759 DD    0534** LD      IX,0
0B275A 21 
0B275B 00 
0B275C 00 
0B275C 00   
0B275E DD    0535** ADD     IX,SP
0B275F 39 
0B2760 28    0536** JR      Z,IPOW4
0B2761 48 
0B2762 C5    0537** PUSH    BC
0B2763 D9    0538** EXX
0B2764 D5    0539** PUSH    DE
0B2765 D9    0540** EXX
0B2766 D5    0541** PUSH    DE
0B2767 CD    0542** CALL    SFLOAT_FP
0B2768 70 
0B2769 2F 
0B276A 0B 
0B276B CD    0543** CALL    RECIP
0B276C A4 
0B276D 2A 
0B276E 0B 
0B276F DD    0544** LD      (IX+4),C
0B2770 71 
0B2771 04 
0B2772 D9    0545** EXX
0B2773 DD    0546** LD      (IX+0),L
0B2774 75 
0B2775 00 
0B2776 DD    0547** LD      (IX+1),H
0B2777 74 
0B2778 01 
0B2779 D9    0548** EXX
0B277A DD    0549** LD      (IX+2),L
0B277B 75 
0B277C 02 
0B277D DD    0550** LD      (IX+3),H
0B277E 74 
0B277F 03 
0B2780 18    0551** JR      IPOW5
0B2781 21 
             0552** ;
0B2782 C5    0553** IPOW3:			PUSH    BC
0B2783 D9    0554** EXX
0B2784 CB    0555** SLA     E
0B2785 23 
0B2786 CB    0556** RL      D
0B2787 12 
0B2788 D5    0557** PUSH    DE
0B2789 D9    0558** EXX
0B278A CB    0559** RL      E
0B278B 13 
0B278C CB    0560** RL      D
0B278D 12 
0B278E D5    0561** PUSH    DE
0B278F 3E    0562** LD      A,'*' & 0FH
0B2790 0A 
0B2791 F5    0563** PUSH    AF
0B2792 CD    0564** CALL    COPY_
0B2793 6D 
0B2794 30 
0B2795 0B 
0B2796 CD    0565** CALL    OP              ;SQUARE
0B2797 4D 
0B2798 24 
0B2799 0B 
0B279A F1    0566** POP     AF
0B279B CD    0567** CALL    DLOAD5
0B279C 99 
0B279D 2D 
0B279E 0B 
0B279F DC    0568** CALL    C,OP            ;MULTIPLY BY X
0B27A0 4D 
0B27A1 24 
0B27A2 0B 
0B27A3 D1    0569** IPOW5:			POP     DE
0B27A4 D9    0570** EXX
0B27A5 D1    0571** POP     DE
0B27A6 D9    0572** EXX
0B27A7 79    0573** LD      A,C
0B27A8 C1    0574** POP     BC
0B27A9 4F    0575** LD      C,A
0B27AA 10    0576** IPOW4:			DJNZ    IPOW3
0B27AB D6 
0B27AC F1    0577** POP     AF
0B27AD F1    0578** POP     AF
0B27AE F1    0579** POP     AF
0B27AF C9    0580** RET
             0581** ;
0B27B0 F1    0582** FPOW0:			POP     AF
0B27B1 F1    0583** POP     AF
0B27B2 F1    0584** POP     AF
0B27B3 18    0585** JR      IPOW0
0B27B4 8B 
             0586** ;
             0587** ;FPOW - Floating-point involution.
             0588** ;
0B27B5 CB    0589** FPOW:			BIT     7,D
0B27B6 7A 
0B27B7 F5    0590** PUSH    AF
0B27B8 CD    0591** CALL    SWAP_FP
0B27B9 A1 
0B27BA 2F 
0B27BB 0B 
0B27BC CD    0592** CALL    PUSH5
0B27BD 7D 
0B27BE 30 
0B27BF 0B 
0B27C0 0D    0593** DEC     C
0B27C1 0C    0594** INC     C
0B27C2 28    0595** JR      Z,FPOW0
0B27C3 EC 
0B27C4 3E    0596** LD      A,158
0B27C5 9E 
0B27C6 B9    0597** CP      C
0B27C7 38    0598** JR      C,FPOW1
0B27C8 0A 
0B27C9 3C    0599** INC     A
0B27CA CD    0600** CALL    FIX
0B27CB 75 
0B27CC 2E 
0B27CD 0B 
0B27CE 08    0601** EX      AF,AF'
0B27CF F2    0602** JP      P,FPOW0
0B27D0 B0 
0B27D1 27 
0B27D2 0B 
0B27D3 CD    0603** FPOW1:			CALL    SWAP_FP
0B27D4 A1 
0B27D5 2F 
0B27D6 0B 
0B27D7 CD    0604** CALL    LN0
0B27D8 C1 
0B27D9 2A 
0B27DA 0B 
0B27DB CD    0605** CALL    POP5
0B27DC 86 
0B27DD 30 
0B27DE 0B 
0B27DF F1    0606** POP     AF
0B27E0 CD    0607** CALL    FMUL
0B27E1 D8 
0B27E2 26 
0B27E3 0B 
0B27E4 C3    0608** JP      EXP0
0B27E5 23 
0B27E6 2A 
0B27E7 0B 
             0609** ;
             0610** ;Integer and floating-point compare.
             0611** ;Result is TRUE (-1) or FALSE (0).
             0612** ;
0B27E8 CD    0613** FLT:			CALL    FCP
0B27E9 F7 
0B27EA 2F 
0B27EB 0B 
0B27EC 18    0614** JR      ILT1
0B27ED 04 
0B27EE CD    0615** ILT:			CALL    ICP
0B27EF E9 
0B27F0 2F 
0B27F1 0B 
0B27F2 D0    0616** ILT1:			RET     NC
0B27F3 18    0617** JR      TRUE_FP
0B27F4 42 
             0618** ;
0B27F5 CD    0619** FGT:			CALL    FCP
0B27F6 F7 
0B27F7 2F 
0B27F8 0B 
0B27F9 18    0620** JR      IGT1
0B27FA 04 
0B27FB CD    0621** IGT:			CALL    ICP
0B27FC E9 
0B27FD 2F 
0B27FE 0B 
0B27FF C8    0622** IGT1:			RET     Z
0B2800 D8    0623** RET     C
0B2801 18    0624** JR      TRUE_FP
0B2802 34 
             0625** ;
0B2803 CD    0626** FGE:			CALL    FCP
0B2804 F7 
0B2805 2F 
0B2806 0B 
0B2807 18    0627** JR      IGE1
0B2808 04 
0B2809 CD    0628** IGE:			CALL    ICP
0B280A E9 
0B280B 2F 
0B280C 0B 
0B280D D8    0629** IGE1:			RET     C
0B280E 18    0630** JR      TRUE_FP
0B280F 27 
             0631** ;
0B2810 CD    0632** FLE:			CALL    FCP
0B2811 F7 
0B2812 2F 
0B2813 0B 
0B2814 18    0633** JR      ILE1
0B2815 04 
0B2816 CD    0634** ILE:			CALL    ICP
0B2817 E9 
0B2818 2F 
0B2819 0B 
0B281A 28    0635** ILE1:			JR      Z,TRUE_FP
0B281B 1B 
0B281C D0    0636** RET     NC
0B281D 18    0637** JR      TRUE_FP
0B281E 18 
             0638** ;
0B281F CD    0639** FNE:			CALL    FCP
0B2820 F7 
0B2821 2F 
0B2822 0B 
0B2823 18    0640** JR      INE1
0B2824 04 
0B2825 CD    0641** INE:			CALL    ICP
0B2826 E9 
0B2827 2F 
0B2828 0B 
0B2829 C8    0642** INE1:			RET     Z
0B282A 18    0643** JR      TRUE_FP
0B282B 0B 
             0644** ;
0B282C CD    0645** FEQ:			CALL    FCP
0B282D F7 
0B282E 2F 
0B282F 0B 
0B2830 18    0646** JR      IEQ1
0B2831 04 
0B2832 CD    0647** IEQ:			CALL    ICP
0B2833 E9 
0B2834 2F 
0B2835 0B 
0B2836 C0    0648** IEQ1:			RET     NZ
0B2837 21    0649** TRUE_FP:			LD      HL,-1
0B2838 FF 
0B2839 FF 
0B283A FF 
0B283B D9    0650** EXX
0B283C 21    0651** LD      HL,-1
0B283D FF 
0B283E FF 
0B283F FF 
0B2840 D9    0652** EXX
0B2841 AF    0653** XOR     A
0B2842 4F    0654** LD      C,A
0B2843 C9    0655** RET
             0656** ;
             0657** ;FUNCTIONS:
             0658** ;
             0659** ;Result returned in HLH'L'C (floating point)
             0660** ;Result returned in HLH'L' (C=0) (integer)
             0661** ;All registers except IY destroyed.
             0662** ;
             0663** ;ABS - Absolute value
             0664** ;Result is numeric, variable type.
             0665** ;
0B2844 CB    0666** ABSV_FP:			BIT     7,H
0B2845 7C 
0B2846 C8    0667** RET     Z               ;POSITIVE/ZERO
0B2847 0D    0668** DEC     C
0B2848 0C    0669** INC     C
0B2849 CA    0670** JP      Z,NEGATE        ;INTEGER
0B284A A4 
0B284B 2E 
0B284C 0B 
0B284D CB    0671** RES     7,H
0B284E BC 
0B284F C9    0672** RET
             0673** ;
             0674** ;NOT - Complement integer.
             0675** ;Result is integer numeric.
             0676** ;
0B2850 CD    0677** NOTK_FP:			CALL    SFIX_FP
0B2851 94 
0B2852 2E 
0B2853 0B 
0B2854 7C    0678** LD      A,H
0B2855 2F    0679** CPL
0B2856 67    0680** LD      H,A
0B2857 7D    0681** LD      A,L
0B2858 2F    0682** CPL
0B2859 6F    0683** LD      L,A
0B285A D9    0684** EXX
0B285B 7C    0685** LD      A,H
0B285C 2F    0686** CPL
0B285D 67    0687** LD      H,A
0B285E 7D    0688** LD      A,L
0B285F 2F    0689** CPL
0B2860 6F    0690** LD      L,A
0B2861 D9    0691** EXX
0B2862 AF    0692** XOR     A               ;NUMERIC MARKER
0B2863 C9    0693** RET
             0694** ;
             0695** ;PI - Return PI (3.141592654)
             0696** ;Result is floating-point numeric.
             0697** ;
0B2864 21    0698** PI_FP:			LD      HL,490FH
0B2865 0F 
0B2866 49 
0B2867 00 
0B2868 D9    0699** EXX
0B2869 21    0700** LD      HL,0DAA2H
0B286A A2 
0B286B DA 
0B286C 00 
0B286D D9    0701** EXX
0B286E 0E    0702** LD      C,81H
0B286F 81 
0B2870 AF    0703** XOR     A               ;NUMERIC MARKER
0B2871 C9    0704** RET
             0705** ;
             0706** ;DEG - Convert radians to degrees
             0707** ;Result is floating-point numeric.
             0708** ;
0B2872 CD    0709** DEG_FP:			CALL    FPI180
0B2873 86 
0B2874 28 
0B2875 0B 
0B2876 CD    0710** CALL    FMUL
0B2877 D8 
0B2878 26 
0B2879 0B 
0B287A AF    0711** XOR     A
0B287B C9    0712** RET
             0713** ;
             0714** ;RAD - Convert degrees to radians
             0715** ;Result is floating-point numeric.
             0716** ;
0B287C CD    0717** RAD_FP:			CALL    FPI180
0B287D 86 
0B287E 28 
0B287F 0B 
0B2880 CD    0718** CALL    FDIV
0B2881 2F 
0B2882 26 
0B2883 0B 
0B2884 AF    0719** XOR     A
0B2885 C9    0720** RET
             0721** ;
             0722** ;180/PI
             0723** ;
0B2886 CD    0724** FPI180:			CALL    SFLOAT_FP
0B2887 70 
0B2888 2F 
0B2889 0B 
0B288A 11    0725** LD      DE,652EH
0B288B 2E 
0B288C 65 
0B288D 00 
0B288E D9    0726** EXX
0B288F 11    0727** LD      DE,0E0D3H
0B2890 D3 
0B2891 E0 
0B2892 00 
0B2893 D9    0728** EXX
0B2894 06    0729** LD      B,85H
0B2895 85 
0B2896 C9    0730** RET
             0731** ;
             0732** ;SGN - Return -1, 0 or +1
             0733** ;Result is integer numeric.
             0734** ;
0B2897 CD    0735** SGN_FP:			CALL    TEST_FP
0B2898 C9 
0B2899 2F 
0B289A 0B 
0B289B B1    0736** OR      C
0B289C C8    0737** RET     Z               ;ZERO
0B289D CB    0738** BIT     7,H
0B289E 7C 
0B289F C2    0739** JP      NZ,TRUE_FP         ;-1
0B28A0 37 
0B28A1 28 
0B28A2 0B 
0B28A3 CD    0740** CALL    ZERO_FP
0B28A4 ED 
0B28A5 2F 
0B28A6 0B 
0B28A7 C3    0741** JP      ADD1_FP            ;1
0B28A8 89 
0B28A9 2F 
0B28AA 0B 
             0742** ;
             0743** ;VAL - Return numeric value of string.
             0744** ;Input: ASCII string at IX
             0745** ;Result is variable type numeric.
             0746** ;
0B28AB CD    0747** VAL_FP:			CALL    SIGNQ
0B28AC 07 
0B28AD 32 
0B28AE 0B 
0B28AF F5    0748** PUSH    AF
0B28B0 CD    0749** CALL    CON_FP
0B28B1 B7 
0B28B2 2D 
0B28B3 0B 
0B28B4 F1    0750** POP     AF
0B28B5 FE    0751** CP      '-'
0B28B6 2D 
0B28B7 3E    0752** LD      A,0             ;NUMERIC MARKER
0B28B8 00 
0B28B9 C0    0753** RET     NZ
0B28BA 0D    0754** DEC     C
0B28BB 0C    0755** INC     C
0B28BC CA    0756** JP      Z,NEGATE        ;ZERO/INTEGER
0B28BD A4 
0B28BE 2E 
0B28BF 0B 
0B28C0 7C    0757** LD      A,H
0B28C1 EE    0758** XOR     80H             ;CHANGE SIGN (FP)
0B28C2 80 
0B28C3 67    0759** LD      H,A
0B28C4 AF    0760** XOR     A
0B28C5 C9    0761** RET
             0762** ;
             0763** ;INT - Floor function
             0764** ;Result is integer numeric.
             0765** ;
0B28C6 0D    0766** INT_FP_:			DEC     C
0B28C7 0C    0767** INC     C
0B28C8 C8    0768** RET     Z               ;ZERO/INTEGER
0B28C9 3E    0769** LD      A,159
0B28CA 9F 
0B28CB 44    0770** LD      B,H             ;B7=SIGN BIT
0B28CC CD    0771** CALL    FIX
0B28CD 75 
0B28CE 2E 
0B28CF 0B 
0B28D0 08    0772** EX      AF,AF'
0B28D1 A0    0773** AND     B
0B28D2 FC    0774** CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B28D3 89 
0B28D4 2F 
0B28D5 0B 
0B28D6 78    0775** LD      A,B
0B28D7 B7    0776** OR      A
0B28D8 FC    0777** CALL    M,NEGATE
0B28D9 A4 
0B28DA 2E 
0B28DB 0B 
0B28DC AF    0778** XOR     A
0B28DD 4F    0779** LD      C,A
0B28DE C9    0780** RET
             0781** ;
             0782** ;SQR - square root
             0783** ;Result is floating-point numeric.
             0784** ;
0B28DF CD    0785** SQR_FP:			CALL    SFLOAT_FP
0B28E0 70 
0B28E1 2F 
0B28E2 0B 
0B28E3 CB    0786** SQR0:			BIT     7,H
0B28E4 7C 
0B28E5 3E    0787** LD      A,NGROOT
0B28E6 15 
0B28E7 C2    0788** JP      NZ,ERROR_FP_        ;"-ve root"
0B28E8 47 
0B28E9 24 
0B28EA 0B 
0B28EB 0D    0789** DEC     C
0B28EC 0C    0790** INC     C
0B28ED C8    0791** RET     Z               ;ZERO
0B28EE CB    0792** SET     7,H             ;IMPLIED 1
0B28EF FC 
0B28F0 CB    0793** BIT     0,C
0B28F1 41 
0B28F2 CC    0794** CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B28F3 A9 
0B28F4 2F 
0B28F5 0B 
0B28F6 79    0795** LD      A,C
0B28F7 D6    0796** SUB     80H
0B28F8 80 
0B28F9 CB    0797** SRA     A               ;HALVE EXPONENT
0B28FA 2F 
0B28FB C6    0798** ADD     A,80H
0B28FC 80 
0B28FD 4F    0799** LD      C,A
0B28FE C5    0800** PUSH    BC              ;SAVE EXPONENT
0B28FF EB    0801** EX      DE,HL
0B2900 21    0802** LD      HL,0
0B2901 00 
0B2902 00 
0B2903 00 
0B2904 44    0803** LD      B,H
0B2905 4D    0804** LD      C,L
0B2906 D9    0805** EXX
0B2907 EB    0806** EX      DE,HL
0B2908 21    0807** LD      HL,0
0B2909 00 
0B290A 00 
0B290B 00 
0B290C 44    0808** LD      B,H
0B290D 4D    0809** LD      C,L
0B290E 3E    0810** LD      A,-31
0B290F E1 
0B2910 CD    0811** CALL    SQRA            ;ROOT
0B2911 9F 
0B2912 31 
0B2913 0B 
0B2914 D9    0812** EXX
0B2915 CB    0813** BIT     7,B
0B2916 78 
0B2917 D9    0814** EXX
0B2918 CC    0815** CALL    Z,SQRA          ;NORMALISE & INC A
0B2919 9F 
0B291A 31 
0B291B 0B 
0B291C CD    0816** CALL    SQRB
0B291D E0 
0B291E 31 
0B291F 0B 
0B2920 B7    0817** OR      A               ;CLEAR CARRY
0B2921 CD    0818** CALL    DIVB
0B2922 4D 
0B2923 31 
0B2924 0B 
0B2925 CB    0819** RR      E               ;LSB TO CARRY
0B2926 1B 
0B2927 60    0820** LD      H,B
0B2928 69    0821** LD      L,C
0B2929 D9    0822** EXX
0B292A 60    0823** LD      H,B
0B292B 69    0824** LD      L,C
0B292C DC    0825** CALL    C,ADD1_FP          ;ROUND UP
0B292D 89 
0B292E 2F 
0B292F 0B 
0B2930 C1    0826** POP     BC              ;RESTORE EXPONENT
0B2931 DC    0827** CALL    C,INCC
0B2932 B6 
0B2933 2F 
0B2934 0B 
0B2935 1F    0828** RRA
0B2936 9F    0829** SBC     A,A
0B2937 81    0830** ADD     A,C
0B2938 4F    0831** LD      C,A
0B2939 CB    0832** RES     7,H             ;POSITIVE
0B293A BC 
0B293B AF    0833** XOR     A
0B293C C9    0834** RET
             0835** ;
             0836** ;TAN - Tangent function
             0837** ;Result is floating-point numeric.
             0838** ;
0B293D CD    0839** TAN_FP:			CALL    SFLOAT_FP
0B293E 70 
0B293F 2F 
0B2940 0B 
0B2941 CD    0840** CALL    PUSH5
0B2942 7D 
0B2943 30 
0B2944 0B 
0B2945 CD    0841** CALL    COS0
0B2946 67 
0B2947 29 
0B2948 0B 
0B2949 CD    0842** CALL    POP5
0B294A 86 
0B294B 30 
0B294C 0B 
0B294D CD    0843** CALL    PUSH5
0B294E 7D 
0B294F 30 
0B2950 0B 
0B2951 CD    0844** CALL    SWAP_FP
0B2952 A1 
0B2953 2F 
0B2954 0B 
0B2955 CD    0845** CALL    SIN0
0B2956 74 
0B2957 29 
0B2958 0B 
0B2959 CD    0846** CALL    POP5
0B295A 86 
0B295B 30 
0B295C 0B 
0B295D CD    0847** CALL    FDIV
0B295E 2F 
0B295F 26 
0B2960 0B 
0B2961 AF    0848** XOR     A               ;NUMERIC MARKER
0B2962 C9    0849** RET
             0850** ;
             0851** ;COS - Cosine function
             0852** ;Result is floating-point numeric.
             0853** ;
0B2963 CD    0854** COS_FP:			CALL    SFLOAT_FP
0B2964 70 
0B2965 2F 
0B2966 0B 
0B2967 CD    0855** COS0:			CALL    SCALE
0B2968 CC 
0B2969 2E 
0B296A 0B 
0B296B 1C    0856** INC     E
0B296C 1C    0857** INC     E
0B296D 7B    0858** LD      A,E
0B296E 18    0859** JR      SIN1
0B296F 10 
             0860** ;
             0861** ;SIN - Sine function
             0862** ;Result is floating-point numeric.
             0863** ;
0B2970 CD    0864** SIN_FP:			CALL    SFLOAT_FP
0B2971 70 
0B2972 2F 
0B2973 0B 
0B2974 E5    0865** SIN0:			PUSH    HL              ;H7=SIGN
0B2975 CD    0866** CALL    SCALE
0B2976 CC 
0B2977 2E 
0B2978 0B 
0B2979 F1    0867** POP     AF
0B297A 07    0868** RLCA
0B297B 07    0869** RLCA
0B297C 07    0870** RLCA
0B297D E6    0871** AND     4
0B297E 04 
0B297F AB    0872** XOR     E
0B2980 F5    0873** SIN1:			PUSH    AF              ;OCTANT
0B2981 CB    0874** RES     7,H
0B2982 BC 
0B2983 1F    0875** RRA
0B2984 CD    0876** CALL    PIBY4
0B2985 12 
0B2986 2A 
0B2987 0B 
0B2988 DC    0877** CALL    C,RSUB          ;X=(PI/4)-X
0B2989 B3 
0B298A 25 
0B298B 0B 
0B298C F1    0878** POP     AF
0B298D F5    0879** PUSH    AF
0B298E E6    0880** AND     3
0B298F 03 
0B2990 E2    0881** JP      PO,SIN2         ;USE COSINE APPROX.
0B2991 C9 
0B2992 29 
0B2993 0B 
0B2994 CD    0882** CALL    PUSH5           ;SAVE X
0B2995 7D 
0B2996 30 
0B2997 0B 
0B2998 CD    0883** CALL    SQUARE          ;PUSH X*X
0B2999 75 
0B299A 30 
0B299B 0B 
0B299C CD    0884** CALL    POLY
0B299D BA 
0B299E 30 
0B299F 0B 
0B29A0 B7    0885** DW	0A8B7H          ;a(8)
0B29A1 A8 
0B29A2 11    0886** DW	3611H
0B29A3 36 
0B29A4 6D    0887** DB	6DH
0B29A5 26    0888** DW	0DE26H          ;a(6)
0B29A6 DE 
0B29A7 05    0889** DW	0D005H
0B29A8 D0 
0B29A9 73    0890** DB	73H
0B29AA C0    0891** DW	80C0H           ;a(4)
0B29AB 80 
0B29AC 88    0892** DW	888H
0B29AD 08 
0B29AE 79    0893** DB	79H
0B29AF 9D    0894** DW	0AA9DH          ;a(2)
0B29B0 AA 
0B29B1 AA    0895** DW	0AAAAH
0B29B2 AA 
0B29B3 7D    0896** DB	7DH
0B29B4 00    0897** DW	0               ;a(0)
0B29B5 00 
0B29B6 00    0898** DW	0
0B29B7 00 
0B29B8 80    0899** DB	80H
0B29B9 CD    0900** CALL    POP5
0B29BA 86 
0B29BB 30 
0B29BC 0B 
0B29BD CD    0901** CALL    POP5
0B29BE 86 
0B29BF 30 
0B29C0 0B 
0B29C1 CD    0902** CALL    FMUL
0B29C2 D8 
0B29C3 26 
0B29C4 0B 
0B29C5 C3    0903** JP      SIN3
0B29C6 EE 
0B29C7 29 
0B29C8 0B 
             0904** ;
0B29C9 CD    0905** SIN2:			CALL    SQUARE          ;PUSH X*X
0B29CA 75 
0B29CB 30 
0B29CC 0B 
0B29CD CD    0906** CALL    POLY
0B29CE BA 
0B29CF 30 
0B29D0 0B 
0B29D1 71    0907** DW	0D571H          ;b(8)
0B29D2 D5 
0B29D3 78    0908** DW	4C78H
0B29D4 4C 
0B29D5 70    0909** DB	70H
0B29D6 AF    0910** DW	94AFH           ;b(6)
0B29D7 94 
0B29D8 03    0911** DW	0B603H
0B29D9 B6 
0B29DA 76    0912** DB	76H
0B29DB C8    0913** DW	9CC8H           ;b(4)
0B29DC 9C 
0B29DD AA    0914** DW	2AAAH
0B29DE 2A 
0B29DF 7B    0915** DB	7BH
0B29E0 DD    0916** DW	0FFDDH          ;b(2)
0B29E1 FF 
0B29E2 FF    0917** DW	0FFFFH
0B29E3 FF 
0B29E4 7E    0918** DB	7EH
0B29E5 00    0919** DW	0               ;b(0)
0B29E6 00 
0B29E7 00    0920** DW	0
0B29E8 00 
0B29E9 80    0921** DB	80H
0B29EA CD    0922** CALL    POP5
0B29EB 86 
0B29EC 30 
0B29ED 0B 
0B29EE F1    0923** SIN3:			POP     AF
0B29EF E6    0924** AND     4
0B29F0 04 
0B29F1 C8    0925** RET     Z
0B29F2 0D    0926** DEC     C
0B29F3 0C    0927** INC     C
0B29F4 C8    0928** RET     Z               ;ZERO
0B29F5 CB    0929** SET     7,H             ;MAKE NEGATIVE
0B29F6 FC 
0B29F7 C9    0930** RET
             0931** ;
             0932** ;Floating-point one:
             0933** ;
0B29F8 21    0934** FONE_FP:			LD      HL,0
0B29F9 00 
0B29FA 00 
0B29FB 00 
0B29FC D9    0935** EXX
0B29FD 21    0936** LD      HL,0
0B29FE 00 
0B29FF 00 
0B2A00 00 
0B2A01 D9    0937** EXX
0B2A02 0E    0938** LD      C,80H
0B2A03 80 
0B2A04 C9    0939** RET
             0940** ;
0B2A05 11    0941** DONE:			LD      DE,0
0B2A06 00 
0B2A07 00 
0B2A08 00 
0B2A09 D9    0942** EXX
0B2A0A 11    0943** LD      DE,0
0B2A0B 00 
0B2A0C 00 
0B2A0D 00 
0B2A0E D9    0944** EXX
0B2A0F 06    0945** LD      B,80H
0B2A10 80 
0B2A11 C9    0946** RET
             0947** ;
0B2A12 11    0948** PIBY4:			LD      DE,490FH
0B2A13 0F 
0B2A14 49 
0B2A15 00 
0B2A16 D9    0949** EXX
0B2A17 11    0950** LD      DE,0DAA2H
0B2A18 A2 
0B2A19 DA 
0B2A1A 00 
0B2A1B D9    0951** EXX
0B2A1C 06    0952** LD      B,7FH
0B2A1D 7F 
0B2A1E C9    0953** RET
             0954** ;
             0955** ;EXP - Exponential function
             0956** ;Result is floating-point numeric.
             0957** ;
0B2A1F CD    0958** EXP_FP:			CALL    SFLOAT_FP
0B2A20 70 
0B2A21 2F 
0B2A22 0B 
0B2A23 CD    0959** EXP0:			CALL    LN2             ;LN(2)
0B2A24 B0 
0B2A25 2A 
0B2A26 0B 
0B2A27 D9    0960** EXX
0B2A28 1D    0961** DEC     E
0B2A29 01    0962** LD      BC,0D1CFH       ;0.6931471805599453
0B2A2A CF 
0B2A2B D1 
0B2A2C 00 
0B2A2D D9    0963** EXX
0B2A2E E5    0964** PUSH    HL              ;H7=SIGN
0B2A2F CD    0965** CALL    MOD48           ;"MODULUS"
0B2A30 DF 
0B2A31 2E 
0B2A32 0B 
0B2A33 F1    0966** POP     AF
0B2A34 CB    0967** BIT     7,E
0B2A35 7B 
0B2A36 28    0968** JR      Z,EXP1
0B2A37 0B 
0B2A38 17    0969** RLA
0B2A39 DA    0970** JP      C,ZERO_FP
0B2A3A ED 
0B2A3B 2F 
0B2A3C 0B 
0B2A3D 3E    0971** LD      A,EXPRNG
0B2A3E 18 
0B2A3F C3    0972** JP      ERROR_FP_           ;"Exp range"
0B2A40 47 
0B2A41 24 
0B2A42 0B 
             0973** ;
0B2A43 E6    0974** EXP1:			AND     80H
0B2A44 80 
0B2A45 B3    0975** OR      E
0B2A46 F5    0976** PUSH    AF              ;INTEGER PART
0B2A47 CB    0977** RES     7,H
0B2A48 BC 
0B2A49 CD    0978** CALL    PUSH5           ;PUSH X*LN(2)
0B2A4A 7D 
0B2A4B 30 
0B2A4C 0B 
0B2A4D CD    0979** CALL    POLY
0B2A4E BA 
0B2A4F 30 
0B2A50 0B 
0B2A51 72    0980** DW	4072H           ;a(7)
0B2A52 40 
0B2A53 2E    0981** DW	942EH
0B2A54 94 
0B2A55 73    0982** DB	73H
0B2A56 65    0983** DW	6F65H           ;a(6)
0B2A57 6F 
0B2A58 4F    0984** DW	2E4FH
0B2A59 2E 
0B2A5A 76    0985** DB	76H
0B2A5B 37    0986** DW	6D37H           ;a(5)
0B2A5C 6D 
0B2A5D 02    0987** DW	8802H
0B2A5E 88 
0B2A5F 79    0988** DB	79H
0B2A60 12    0989** DW	0E512H          ;a(4)
0B2A61 E5 
0B2A62 A0    0990** DW	2AA0H
0B2A63 2A 
0B2A64 7B    0991** DB	7BH
0B2A65 14    0992** DW	4F14H           ;a(3)
0B2A66 4F 
0B2A67 AA    0993** DW	0AAAAH
0B2A68 AA 
0B2A69 7D    0994** DB	7DH
0B2A6A 56    0995** DW	0FD56H          ;a(2)
0B2A6B FD 
0B2A6C FF    0996** DW	7FFFH
0B2A6D 7F 
0B2A6E 7E    0997** DB	7EH
0B2A6F FE    0998** DW	0FFFEH          ;a(1)
0B2A70 FF 
0B2A71 FF    0999** DW	0FFFFH
0B2A72 FF 
0B2A73 7F    1000** DB	7FH
0B2A74 00    1001** DW	0               ;a(0)
0B2A75 00 
0B2A76 00    1002** DW	0
0B2A77 00 
0B2A78 80    1003** DB	80H
0B2A79 CD    1004** CALL    POP5
0B2A7A 86 
0B2A7B 30 
0B2A7C 0B 
0B2A7D F1    1005** POP     AF
0B2A7E F5    1006** PUSH    AF
0B2A7F F4    1007** CALL    P,RECIP         ;X=1/X
0B2A80 A4 
0B2A81 2A 
0B2A82 0B 
0B2A83 F1    1008** POP     AF
0B2A84 F2    1009** JP      P,EXP4
0B2A85 8C 
0B2A86 2A 
0B2A87 0B 
0B2A88 E6    1010** AND     7FH
0B2A89 7F 
0B2A8A ED    1011** NEG
0B2A8B 44 
0B2A8C C6    1012** EXP4:			ADD     A,80H
0B2A8D 80 
0B2A8E 81    1013** ADD     A,C
0B2A8F 38    1014** JR      C,EXP2
0B2A90 06 
0B2A91 F2    1015** JP      P,ZERO_FP          ;UNDERFLOW
0B2A92 ED 
0B2A93 2F 
0B2A94 0B 
0B2A95 18    1016** JR      EXP3
0B2A96 04 
0B2A97 FA    1017** EXP2:			JP      M,OFLOW         ;OVERFLOW
0B2A98 B8 
0B2A99 2F 
0B2A9A 0B 
0B2A9B C6    1018** EXP3:			ADD     A,80H
0B2A9C 80 
0B2A9D CA    1019** JP      Z,ZERO_FP
0B2A9E ED 
0B2A9F 2F 
0B2AA0 0B 
0B2AA1 4F    1020** LD      C,A
0B2AA2 AF    1021** XOR     A               ;NUMERIC MARKER
0B2AA3 C9    1022** RET
             1023** ;
0B2AA4 CD    1024** RECIP:			CALL    DONE
0B2AA5 05 
0B2AA6 2A 
0B2AA7 0B 
0B2AA8 CD    1025** RDIV:			CALL    SWAP_FP
0B2AA9 A1 
0B2AAA 2F 
0B2AAB 0B 
0B2AAC C3    1026** JP      FDIV            ;RECIPROCAL
0B2AAD 2F 
0B2AAE 26 
0B2AAF 0B 
             1027** ;
0B2AB0 11    1028** LN2:			LD      DE,3172H        ;LN(2)
0B2AB1 72 
0B2AB2 31 
0B2AB3 00 
0B2AB4 D9    1029** EXX
0B2AB5 11    1030** LD      DE,17F8H
0B2AB6 F8 
0B2AB7 17 
0B2AB8 00 
0B2AB9 D9    1031** EXX
0B2ABA 06    1032** LD      B,7FH
0B2ABB 7F 
0B2ABC C9    1033** RET
             1034** ;
             1035** ;LN - Natural log.
             1036** ;Result is floating-point numeric.
             1037** ;
0B2ABD CD    1038** LN_FP:			CALL    SFLOAT_FP
0B2ABE 70 
0B2ABF 2F 
0B2AC0 0B 
0B2AC1 3E    1039** LN0:			LD      A,LOGRNG
0B2AC2 16 
0B2AC3 CB    1040** BIT     7,H
0B2AC4 7C 
0B2AC5 C2    1041** JP      NZ,ERROR_FP_        ;"Log range"
0B2AC6 47 
0B2AC7 24 
0B2AC8 0B 
0B2AC9 0C    1042** INC     C
0B2ACA 0D    1043** DEC     C
0B2ACB CA    1044** JP      Z,ERROR_FP_
0B2ACC 47 
0B2ACD 24 
0B2ACE 0B 
0B2ACF 11    1045** LD      DE,3504H        ;SQR(2)
0B2AD0 04 
0B2AD1 35 
0B2AD2 00 
0B2AD3 D9    1046** EXX
0B2AD4 11    1047** LD      DE,0F333H       ;1.41421356237
0B2AD5 33 
0B2AD6 F3 
0B2AD7 00 
0B2AD8 D9    1048** EXX
0B2AD9 CD    1049** CALL    ICP0            ;MANTISSA>SQR(2)?
0B2ADA 00 
0B2ADB 30 
0B2ADC 0B 
0B2ADD 79    1050** LD      A,C             ;EXPONENT
0B2ADE 0E    1051** LD      C,80H           ;1 <= X < 2
0B2ADF 80 
0B2AE0 38    1052** JR      C,LN4
0B2AE1 02 
0B2AE2 0D    1053** DEC     C
0B2AE3 3C    1054** INC     A
0B2AE4 F5    1055** LN4:			PUSH    AF              ;SAVE EXPONENT
0B2AE5 CD    1056** CALL    RATIO           ;X=(X-1)/(X+1)
0B2AE6 92 
0B2AE7 30 
0B2AE8 0B 
0B2AE9 CD    1057** CALL    PUSH5
0B2AEA 7D 
0B2AEB 30 
0B2AEC 0B 
0B2AED CD    1058** CALL    SQUARE          ;PUSH X*X
0B2AEE 75 
0B2AEF 30 
0B2AF0 0B 
0B2AF1 CD    1059** CALL    POLY
0B2AF2 BA 
0B2AF3 30 
0B2AF4 0B 
0B2AF5 48    1060** DW	0CC48H          ;a(9)
0B2AF6 CC 
0B2AF7 FB    1061** DW	74FBH
0B2AF8 74 
0B2AF9 7D    1062** DB	7DH
0B2AFA AF    1063** DW	0AEAFH          ;a(7)
0B2AFB AE 
0B2AFC FF    1064** DW	11FFH
0B2AFD 11 
0B2AFE 7E    1065** DB	7EH
0B2AFF 8C    1066** DW	0D98CH          ;a(5)
0B2B00 D9 
0B2B01 CD    1067** DW	4CCDH
0B2B02 4C 
0B2B03 7E    1068** DB	7EH
0B2B04 E3    1069** DW	0A9E3H          ;a(3)
0B2B05 A9 
0B2B06 AA    1070** DW	2AAAH
0B2B07 2A 
0B2B08 7F    1071** DB	7FH
0B2B09 00    1072** DW	0               ;a(1)
0B2B0A 00 
0B2B0B 00    1073** DW	0
0B2B0C 00 
0B2B0D 81    1074** DB	81H
0B2B0E CD    1075** CALL    POP5
0B2B0F 86 
0B2B10 30 
0B2B11 0B 
0B2B12 CD    1076** CALL    POP5
0B2B13 86 
0B2B14 30 
0B2B15 0B 
0B2B16 CD    1077** CALL    FMUL
0B2B17 D8 
0B2B18 26 
0B2B19 0B 
0B2B1A F1    1078** POP     AF              ;EXPONENT
0B2B1B CD    1079** CALL    PUSH5
0B2B1C 7D 
0B2B1D 30 
0B2B1E 0B 
0B2B1F 08    1080** EX      AF,AF'
0B2B20 CD    1081** CALL    ZERO_FP
0B2B21 ED 
0B2B22 2F 
0B2B23 0B 
0B2B24 08    1082** EX      AF,AF'
0B2B25 D6    1083** SUB     80H
0B2B26 80 
0B2B27 28    1084** JR      Z,LN3
0B2B28 1F 
0B2B29 30    1085** JR      NC,LN1
0B2B2A 02 
0B2B2B 2F    1086** CPL
0B2B2C 3C    1087** INC     A
0B2B2D 67    1088** LN1:			LD      H,A
0B2B2E 0E    1089** LD      C,87H
0B2B2F 87 
0B2B30 F5    1090** PUSH    AF
0B2B31 CD    1091** CALL    FLOAT_
0B2B32 50 
0B2B33 2F 
0B2B34 0B 
0B2B35 CB    1092** RES     7,H
0B2B36 BC 
0B2B37 CD    1093** CALL    LN2
0B2B38 B0 
0B2B39 2A 
0B2B3A 0B 
0B2B3B CD    1094** CALL    FMUL
0B2B3C D8 
0B2B3D 26 
0B2B3E 0B 
0B2B3F F1    1095** POP     AF
0B2B40 30    1096** JR      NC,LN3
0B2B41 06 
0B2B42 FA    1097** JP      M,LN3
0B2B43 48 
0B2B44 2B 
0B2B45 0B 
0B2B46 CB    1098** SET     7,H
0B2B47 FC 
0B2B48 CD    1099** LN3:			CALL    POP5
0B2B49 86 
0B2B4A 30 
0B2B4B 0B 
0B2B4C CD    1100** CALL    FADD
0B2B4D C6 
0B2B4E 25 
0B2B4F 0B 
0B2B50 AF    1101** XOR     A
0B2B51 C9    1102** RET
             1103** ;
             1104** ;LOG - base-10 logarithm.
             1105** ;Result is floating-point numeric.
             1106** ;
0B2B52 CD    1107** LOG_FP:			CALL    LN_FP
0B2B53 BD 
0B2B54 2A 
0B2B55 0B 
0B2B56 11    1108** LD      DE,5E5BH        ;LOG(e)
0B2B57 5B 
0B2B58 5E 
0B2B59 00 
0B2B5A D9    1109** EXX
0B2B5B 11    1110** LD      DE,0D8A9H
0B2B5C A9 
0B2B5D D8 
0B2B5E 00 
0B2B5F D9    1111** EXX
0B2B60 06    1112** LD      B,7EH
0B2B61 7E 
0B2B62 CD    1113** CALL    FMUL
0B2B63 D8 
0B2B64 26 
0B2B65 0B 
0B2B66 AF    1114** XOR     A
0B2B67 C9    1115** RET
             1116** ;
             1117** ;ASN - Arc-sine
             1118** ;Result is floating-point numeric.
             1119** ;
0B2B68 CD    1120** ASN_FP:			CALL    SFLOAT_FP
0B2B69 70 
0B2B6A 2F 
0B2B6B 0B 
0B2B6C CD    1121** CALL    PUSH5
0B2B6D 7D 
0B2B6E 30 
0B2B6F 0B 
0B2B70 CD    1122** CALL    COPY_
0B2B71 6D 
0B2B72 30 
0B2B73 0B 
0B2B74 CD    1123** CALL    FMUL
0B2B75 D8 
0B2B76 26 
0B2B77 0B 
0B2B78 CD    1124** CALL    DONE
0B2B79 05 
0B2B7A 2A 
0B2B7B 0B 
0B2B7C CD    1125** CALL    RSUB
0B2B7D B3 
0B2B7E 25 
0B2B7F 0B 
0B2B80 CD    1126** CALL    SQR0
0B2B81 E3 
0B2B82 28 
0B2B83 0B 
0B2B84 CD    1127** CALL    POP5
0B2B85 86 
0B2B86 30 
0B2B87 0B 
0B2B88 0C    1128** INC     C
0B2B89 0D    1129** DEC     C
0B2B8A 3E    1130** LD      A,2
0B2B8B 02 
0B2B8C D5    1131** PUSH    DE
0B2B8D CA    1132** JP      Z,ACS1
0B2B8E 12 
0B2B8F 2C 
0B2B90 0B 
0B2B91 D1    1133** POP     DE
0B2B92 CD    1134** CALL    RDIV
0B2B93 A8 
0B2B94 2A 
0B2B95 0B 
0B2B96 18    1135** JR      ATN0
0B2B97 04 
             1136** ;
             1137** ;ATN - arc-tangent
             1138** ;Result is floating-point numeric.
             1139** ;
0B2B98 CD    1140** ATN_FP:			CALL    SFLOAT_FP
0B2B99 70 
0B2B9A 2F 
0B2B9B 0B 
0B2B9C E5    1141** ATN0:			PUSH    HL              ;SAVE SIGN
0B2B9D CB    1142** RES     7,H
0B2B9E BC 
0B2B9F 11    1143** LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B2BA0 13 
0B2BA1 54 
0B2BA2 00 
0B2BA3 D9    1144** EXX
0B2BA4 11    1145** LD      DE,0CCD0H
0B2BA5 D0 
0B2BA6 CC 
0B2BA7 00 
0B2BA8 D9    1146** EXX
0B2BA9 06    1147** LD      B,7EH
0B2BAA 7E 
0B2BAB CD    1148** CALL    FCP0            ;COMPARE
0B2BAC FD 
0B2BAD 2F 
0B2BAE 0B 
0B2BAF 06    1149** LD      B,0
0B2BB0 00 
0B2BB1 38    1150** JR      C,ATN2
0B2BB2 22 
0B2BB3 11    1151** LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B2BB4 82 
0B2BB5 1A 
0B2BB6 00 
0B2BB7 D9    1152** EXX
0B2BB8 11    1153** LD      DE,799AH
0B2BB9 9A 
0B2BBA 79 
0B2BBB 00 
0B2BBC D9    1154** EXX
0B2BBD 06    1155** LD      B,81H
0B2BBE 81 
0B2BBF CD    1156** CALL    FCP0            ;COMPARE
0B2BC0 FD 
0B2BC1 2F 
0B2BC2 0B 
0B2BC3 38    1157** JR      C,ATN1
0B2BC4 0A 
0B2BC5 CD    1158** CALL    RECIP           ;X=1/X
0B2BC6 A4 
0B2BC7 2A 
0B2BC8 0B 
0B2BC9 06    1159** LD      B,2
0B2BCA 02 
0B2BCB C3    1160** JP      ATN2
0B2BCC D5 
0B2BCD 2B 
0B2BCE 0B 
0B2BCF CD    1161** ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B2BD0 92 
0B2BD1 30 
0B2BD2 0B 
0B2BD3 06    1162** LD      B,1
0B2BD4 01 
0B2BD5 C5    1163** ATN2:			PUSH    BC              ;SAVE FLAG
0B2BD6 CD    1164** CALL    PUSH5
0B2BD7 7D 
0B2BD8 30 
0B2BD9 0B 
0B2BDA CD    1165** CALL    SQUARE          ;PUSH X*X
0B2BDB 75 
0B2BDC 30 
0B2BDD 0B 
0B2BDE CD    1166** CALL    POLY
0B2BDF BA 
0B2BE0 30 
0B2BE1 0B 
0B2BE2 35    1167** DW	0F335H          ;a(13)
0B2BE3 F3 
0B2BE4 D8    1168** DW	37D8H
0B2BE5 37 
0B2BE6 7B    1169** DB	7BH
0B2BE7 91    1170** DW	6B91H           ;a(11)
0B2BE8 6B 
0B2BE9 B9    1171** DW	0AAB9H
0B2BEA AA 
0B2BEB 7C    1172** DB	7CH
0B2BEC DE    1173** DW	41DEH           ;a(9)
0B2BED 41 
0B2BEE 97    1174** DW	6197H
0B2BEF 61 
0B2BF0 7C    1175** DB	7CH
0B2BF1 7B    1176** DW	9D7BH           ;a(7)
0B2BF2 9D 
0B2BF3 37    1177** DW	9237H
0B2BF4 92 
0B2BF5 7D    1178** DB	7DH
0B2BF6 5A    1179** DW	2A5AH           ;a(5)
0B2BF7 2A 
0B2BF8 CC    1180** DW	4CCCH
0B2BF9 4C 
0B2BFA 7D    1181** DB	7DH
0B2BFB 5C    1182** DW	0A95CH          ;a(3)
0B2BFC A9 
0B2BFD AA    1183** DW	0AAAAH
0B2BFE AA 
0B2BFF 7E    1184** DB	7EH
0B2C00 00    1185** DW	0               ;a(1)
0B2C01 00 
0B2C02 00    1186** DW	0
0B2C03 00 
0B2C04 80    1187** DB	80H
0B2C05 CD    1188** CALL    POP5
0B2C06 86 
0B2C07 30 
0B2C08 0B 
0B2C09 CD    1189** CALL    POP5
0B2C0A 86 
0B2C0B 30 
0B2C0C 0B 
0B2C0D CD    1190** CALL    FMUL
0B2C0E D8 
0B2C0F 26 
0B2C10 0B 
0B2C11 F1    1191** POP     AF
0B2C12 CD    1192** ACS1:			CALL    PIBY4           ;PI/4
0B2C13 12 
0B2C14 2A 
0B2C15 0B 
0B2C16 1F    1193** RRA
0B2C17 F5    1194** PUSH    AF
0B2C18 DC    1195** CALL    C,FADD
0B2C19 C6 
0B2C1A 25 
0B2C1B 0B 
0B2C1C F1    1196** POP     AF
0B2C1D 04    1197** INC     B
0B2C1E 1F    1198** RRA
0B2C1F DC    1199** CALL    C,RSUB
0B2C20 B3 
0B2C21 25 
0B2C22 0B 
0B2C23 F1    1200** POP     AF
0B2C24 B7    1201** OR      A
0B2C25 F0    1202** RET     P
0B2C26 CB    1203** SET     7,H             ;MAKE NEGATIVE
0B2C27 FC 
0B2C28 AF    1204** XOR     A
0B2C29 C9    1205** RET
             1206** ;
             1207** ;ACS - Arc cosine=PI/2-ASN.
             1208** ;Result is floating point numeric.
             1209** ;
0B2C2A CD    1210** ACS_FP:			CALL    ASN_FP
0B2C2B 68 
0B2C2C 2B 
0B2C2D 0B 
0B2C2E 3E    1211** LD      A,2
0B2C2F 02 
0B2C30 F5    1212** PUSH    AF
0B2C31 18    1213** JR      ACS1
0B2C32 DF 
             1214** ;
             1215** ;Function STR - convert numeric value to ASCII string.
             1216** ;   Inputs: HLH'L'C = integer or floating-point number
             1217** ;           DE = address at which to store string
             1218** ;           IX = address of @% format control
             1219** ;  Outputs: String stored, with NUL terminator
             1220** ;
             1221** ;First normalise for decimal output:
             1222** ;
0B2C33 CD    1223** STR_FP:			CALL    SFLOAT_FP
0B2C34 70 
0B2C35 2F 
0B2C36 0B 
0B2C37 06    1224** LD      B,0             ;DEFAULT PT. POSITION
0B2C38 00 
0B2C39 CB    1225** BIT     7,H             ;NEGATIVE?
0B2C3A 7C 
0B2C3B 28    1226** JR      Z,STR10
0B2C3C 06 
0B2C3D CB    1227** RES     7,H
0B2C3E BC 
0B2C3F 3E    1228** LD      A,'-'
0B2C40 2D 
0B2C41 12    1229** LD      (DE),A          ;STORE SIGN
0B2C42 13    1230** INC     DE
0B2C43 AF    1231** STR10:			XOR     A               ;CLEAR A
0B2C44 B9    1232** CP      C
0B2C45 28    1233** JR      Z,STR02          ;ZERO
0B2C46 4E 
0B2C47 D5    1234** PUSH    DE              ;SAVE TEXT POINTER
0B2C48 78    1235** LD      A,B
0B2C49 F5    1236** STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B2C4A 79    1237** LD      A,C             ;BINARY EXPONENT
0B2C4B FE    1238** CP      161
0B2C4C A1 
0B2C4D 30    1239** JR      NC,STR14
0B2C4E 1C 
0B2C4F FE    1240** CP      155
0B2C50 9B 
0B2C51 30    1241** JR      NC,STR15
0B2C52 29 
0B2C53 2F    1242** CPL
0B2C54 FE    1243** CP      225
0B2C55 E1 
0B2C56 38    1244** JR      C,STR13
0B2C57 02 
0B2C58 3E    1245** LD      A,-8
0B2C59 F8 
0B2C5A C6    1246** STR13:			ADD     A,28
0B2C5B 1C 
0B2C5C CD    1247** CALL    POWR10
0B2C5D E9 
0B2C5E 30 
0B2C5F 0B 
0B2C60 F5    1248** PUSH    AF
0B2C61 CD    1249** CALL    FMUL
0B2C62 D8 
0B2C63 26 
0B2C64 0B 
0B2C65 F1    1250** POP     AF
0B2C66 47    1251** LD      B,A
0B2C67 F1    1252** POP     AF
0B2C68 90    1253** SUB     B
0B2C69 18    1254** JR      STR11
0B2C6A DE 
0B2C6B D6    1255** STR14:			SUB     32
0B2C6C 20 
0B2C6D CD    1256** CALL    POWR10
0B2C6E E9 
0B2C6F 30 
0B2C70 0B 
0B2C71 F5    1257** PUSH    AF
0B2C72 CD    1258** CALL    FDIV
0B2C73 2F 
0B2C74 26 
0B2C75 0B 
0B2C76 F1    1259** POP     AF
0B2C77 47    1260** LD      B,A
0B2C78 F1    1261** POP     AF
0B2C79 80    1262** ADD     A,B
0B2C7A 18    1263** JR      STR11
0B2C7B CD 
0B2C7C 3E    1264** STR15:			LD      A,9
0B2C7D 09 
0B2C7E CD    1265** CALL    POWR10          ;10^9
0B2C7F E9 
0B2C80 30 
0B2C81 0B 
0B2C82 CD    1266** CALL    FCP0
0B2C83 FD 
0B2C84 2F 
0B2C85 0B 
0B2C86 79    1267** LD      A,C
0B2C87 C1    1268** POP     BC
0B2C88 4F    1269** LD      C,A
0B2C89 CB    1270** SET     7,H             ;IMPLIED 1
0B2C8A FC 
0B2C8B DC    1271** CALL    C,X10B          ;X10, DEC B
0B2C8C 25 
0B2C8D 30 
0B2C8E 0B 
0B2C8F D1    1272** POP     DE              ;RESTORE TEXT POINTER
0B2C90 CB    1273** RES     7,C
0B2C91 B9 
0B2C92 3E    1274** LD      A,0
0B2C93 00 
0B2C94 17    1275** RLA                     ;PUT CARRY IN LSB
             1276** ;
             1277** ;At this point decimal normalisation has been done,
             1278** ;now convert to decimal digits:
             1279** ;      AHLH'L' = number in normalised integer form
             1280** ;            B = decimal place adjustment
             1281** ;            C = binary place adjustment (29-33)
             1282** ;
0B2C95 0C    1283** STR02:			INC     C
0B2C96 08    1284** EX      AF,AF'          ;SAVE A
0B2C97 78    1285** LD      A,B
0B2C98 DD    1286** BIT     1,(IX+2)
0B2C99 CB 
0B2C9A 02 
0B2C9B 4E 
0B2C9C 20    1287** JR      NZ,STR20
0B2C9D 08 
0B2C9E AF    1288** XOR     A
0B2C9F DD    1289** CP      (IX+1)
0B2CA0 BE 
0B2CA1 01 
0B2CA2 28    1290** JR      Z,STR21
0B2CA3 0B 
0B2CA4 3E    1291** LD      A,-10
0B2CA5 F6 
0B2CA6 DD    1292** STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B2CA7 86 
0B2CA8 01 
0B2CA9 B7    1293** OR      A               ;CLEAR CARRY
0B2CAA FA    1294** JP      M,STR21
0B2CAB AF 
0B2CAC 2C 
0B2CAD 0B 
0B2CAE AF    1295** XOR     A
0B2CAF F5    1296** STR21:			PUSH    AF
0B2CB0 08    1297** EX      AF,AF'          ;RESTORE A
0B2CB1 CD    1298** STR22:			CALL    X2              ;RL AHLH'L'
0B2CB2 59 
0B2CB3 30 
0B2CB4 0B 
0B2CB5 8F    1299** ADC     A,A
0B2CB6 FE    1300** CP      10
0B2CB7 0A 
0B2CB8 38    1301** JR      C,STR23
0B2CB9 05 
0B2CBA D6    1302** SUB     10
0B2CBB 0A 
0B2CBC D9    1303** EXX
0B2CBD 2C    1304** INC     L               ;SET RESULT BIT
0B2CBE D9    1305** EXX
0B2CBF 0D    1306** STR23:			DEC     C
0B2CC0 20    1307** JR      NZ,STR22        ;32 TIMES
0B2CC1 EF 
0B2CC2 4F    1308** LD      C,A             ;REMAINDER
0B2CC3 7C    1309** LD      A,H
0B2CC4 E6    1310** AND     3FH             ;CLEAR OUT JUNK
0B2CC5 3F 
0B2CC6 67    1311** LD      H,A
0B2CC7 F1    1312** POP     AF
0B2CC8 F2    1313** JP      P,STR24
0B2CC9 D6 
0B2CCA 2C 
0B2CCB 0B 
0B2CCC 3C    1314** INC     A
0B2CCD 20    1315** JR      NZ,STR26
0B2CCE 1C 
0B2CCF 3E    1316** LD      A,4
0B2CD0 04 
0B2CD1 B9    1317** CP      C               ;ROUND UP?
0B2CD2 3E    1318** LD      A,0
0B2CD3 00 
0B2CD4 18    1319** JR      STR26
0B2CD5 15 
0B2CD6 F5    1320** STR24:			PUSH    AF
0B2CD7 79    1321** LD      A,C
0B2CD8 CE    1322** ADC     A,'0'           ;ADD CARRY
0B2CD9 30 
0B2CDA FE    1323** CP      '0'
0B2CDB 30 
0B2CDC 28    1324** JR      Z,STR25         ;SUPPRESS ZERO
0B2CDD 05 
0B2CDE FE    1325** CP      '9'+1
0B2CDF 3A 
0B2CE0 3F    1326** CCF
0B2CE1 30    1327** JR      NC,STR26
0B2CE2 08 
0B2CE3 E3    1328** STR25:			EX      (SP),HL
0B2CE4 CB    1329** BIT     6,L             ;ZERO FLAG
0B2CE5 75 
0B2CE6 E3    1330** EX      (SP),HL
0B2CE7 20    1331** JR      NZ,STR27
0B2CE8 05 
0B2CE9 3E    1332** LD      A,'0'
0B2CEA 30 
0B2CEB 3C    1333** STR26:			INC     A               ;SET +VE
0B2CEC 3D    1334** DEC     A
0B2CED F5    1335** PUSH    AF              ;PUT ON STACK + CARRY
0B2CEE 04    1336** STR27:			INC     B
0B2CEF CD    1337** CALL    TEST_FP            ;IS HLH'L' ZERO?
0B2CF0 C9 
0B2CF1 2F 
0B2CF2 0B 
0B2CF3 0E    1338** LD      C,32
0B2CF4 20 
0B2CF5 3E    1339** LD      A,0
0B2CF6 00 
0B2CF7 20    1340** JR      NZ,STR22
0B2CF8 B8 
0B2CF9 F1    1341** POP     AF
0B2CFA F5    1342** PUSH    AF
0B2CFB 3E    1343** LD      A,0
0B2CFC 00 
0B2CFD 38    1344** JR      C,STR22
0B2CFE B2 
             1345** ;
             1346** ;At this point, the decimal character string is stored
             1347** ; on the stack. Trailing zeroes are suppressed and may
             1348** ; need to be replaced.
             1349** ;B register holds decimal point position.
             1350** ;Now format number and store as ASCII string:
             1351** ;
0B2CFF EB    1352** STR3:			EX      DE,HL           ;STRING POINTER
0B2D00 0E    1353** LD      C,-1            ;FLAG "E"
0B2D01 FF 
0B2D02 16    1354** LD      D,1
0B2D03 01 
0B2D04 DD    1355** LD      E,(IX+1)        ;f2
0B2D05 5E 
0B2D06 01 
0B2D07 DD    1356** BIT     0,(IX+2)
0B2D08 CB 
0B2D09 02 
0B2D0A 46 
0B2D0B 20    1357** JR      NZ,STR34        ;E MODE
0B2D0C 35 
0B2D0D DD    1358** BIT     1,(IX+2)
0B2D0E CB 
0B2D0F 02 
0B2D10 4E 
0B2D11 28    1359** JR      Z,STR31
0B2D12 12 
0B2D13 78    1360** LD      A,B             ;F MODE
0B2D14 B7    1361** OR      A
0B2D15 28    1362** JR      Z,STR30
0B2D16 05 
0B2D17 FA    1363** JP      M,STR30
0B2D18 1C 
0B2D19 2D 
0B2D1A 0B 
0B2D1B 50    1364** LD      D,B
0B2D1C 7A    1365** STR30:			LD      A,D
0B2D1D DD    1366** ADD     A,(IX+1)
0B2D1E 86 
0B2D1F 01 
0B2D20 5F    1367** LD      E,A
0B2D21 FE    1368** CP      11
0B2D22 0B 
0B2D23 38    1369** JR      C,STR32
0B2D24 19 
0B2D25 78    1370** STR31:			LD      A,B             ;G MODE
0B2D26 11    1371** LD      DE,101H
0B2D27 01 
0B2D28 01 
0B2D29 00 
0B2D2A B7    1372** OR      A
0B2D2B FA    1373** JP      M,STR34
0B2D2C 42 
0B2D2D 2D 
0B2D2E 0B 
0B2D2F 28    1374** JR      Z,STR32
0B2D30 0D 
0B2D31 DD    1375** LD      A,(IX+1)
0B2D32 7E 
0B2D33 01 
0B2D34 B7    1376** OR      A
0B2D35 20    1377** JR      NZ,STR3A
0B2D36 02 
0B2D37 3E    1378** LD      A,10
0B2D38 0A 
0B2D39 B8    1379** STR3A:			CP      B
0B2D3A 38    1380** JR      C,STR34
0B2D3B 06 
0B2D3C 50    1381** LD      D,B
0B2D3D 58    1382** LD      E,B
0B2D3E 78    1383** STR32:			LD      A,B
0B2D3F C6    1384** ADD     A,129
0B2D40 81 
0B2D41 4F    1385** LD      C,A
0B2D42 CB    1386** STR34:			SET     7,D
0B2D43 FA 
0B2D44 1D    1387** DEC     E
0B2D45 7A    1388** STR35:			LD      A,D
0B2D46 B9    1389** CP      C
0B2D47 30    1390** JR      NC,STR33
0B2D48 0E 
0B2D49 F1    1391** STR36:			POP     AF
0B2D4A 28    1392** JR      Z,STR37
0B2D4B 04 
0B2D4C F2    1393** JP      P,STR38
0B2D4D 59 
0B2D4E 2D 
0B2D4F 0B 
0B2D50 F5    1394** STR37:			PUSH    AF
0B2D51 1C    1395** INC     E
0B2D52 1D    1396** DEC     E
0B2D53 FA    1397** JP      M,STR4
0B2D54 6A 
0B2D55 2D 
0B2D56 0B 
0B2D57 3E    1398** STR33:			LD      A,'0'
0B2D58 30 
0B2D59 15    1399** STR38:			DEC     D
0B2D5A E2    1400** JP      PO,STR39
0B2D5B 61 
0B2D5C 2D 
0B2D5D 0B 
0B2D5E 36    1401** LD      (HL),'.'
0B2D5F 2E 
0B2D60 23    1402** INC     HL
0B2D61 77    1403** STR39:			LD      (HL),A
0B2D62 23    1404** INC     HL
0B2D63 1D    1405** DEC     E
0B2D64 F2    1406** JP      P,STR35
0B2D65 45 
0B2D66 2D 
0B2D67 0B 
0B2D68 18    1407** JR      STR36
0B2D69 DF 
             1408** ;
0B2D6A F1    1409** STR4:			POP     AF
0B2D6B 0C    1410** STR40:			INC     C
0B2D6C 4D    1411** LD      C,L
0B2D6D 20    1412** JR      NZ,STR44
0B2D6E 28 
0B2D6F 36    1413** LD      (HL),'E'        ;EXPONENT
0B2D70 45 
0B2D71 23    1414** INC     HL
0B2D72 78    1415** LD      A,B
0B2D73 3D    1416** DEC     A
0B2D74 F2    1417** JP      P,STR41
0B2D75 7D 
0B2D76 2D 
0B2D77 0B 
0B2D78 36    1418** LD      (HL),'-'
0B2D79 2D 
0B2D7A 23    1419** INC     HL
0B2D7B ED    1420** NEG
0B2D7C 44 
0B2D7D 36    1421** STR41:			LD      (HL),'0'
0B2D7E 30 
0B2D7F 28    1422** JR      Z,STR47
0B2D80 15 
0B2D81 FE    1423** CP      10
0B2D82 0A 
0B2D83 47    1424** LD      B,A
0B2D84 3E    1425** LD      A,':'
0B2D85 3A 
0B2D86 38    1426** JR      C,STR42
0B2D87 03 
0B2D88 23    1427** INC     HL
0B2D89 36    1428** LD      (HL),'0'
0B2D8A 30 
0B2D8B 34    1429** STR42:			INC     (HL)
0B2D8C BE    1430** CP      (HL)
0B2D8D 20    1431** JR      NZ,STR43
0B2D8E 05 
0B2D8F 36    1432** LD      (HL),'0'
0B2D90 30 
0B2D91 2B    1433** DEC     HL
0B2D92 34    1434** INC     (HL)
0B2D93 23    1435** INC     HL
0B2D94 10    1436** STR43:			DJNZ    STR42
0B2D95 F5 
0B2D96 23    1437** STR47:			INC     HL
0B2D97 EB    1438** STR44:			EX      DE,HL
0B2D98 C9    1439** RET
             1440** ;
             1441** ;Support subroutines:
             1442** ;
0B2D99 DD    1443** DLOAD5:			LD      B,(IX+4)
0B2D9A 46 
0B2D9B 04 
0B2D9C D9    1444** EXX
0B2D9D DD    1445** LD      E,(IX+0)
0B2D9E 5E 
0B2D9F 00 
0B2DA0 DD    1446** LD      D,(IX+1)
0B2DA1 56 
0B2DA2 01 
0B2DA3 D9    1447** EXX
0B2DA4 DD    1448** LD      E,(IX+2)
0B2DA5 5E 
0B2DA6 02 
0B2DA7 DD    1449** LD      D,(IX+3)
0B2DA8 56 
0B2DA9 03 
0B2DAA C9    1450** RET
             1451** ;
0B2DAB DD    1452** DLOAD5_SPL:		LD      B,(IX+6)
0B2DAC 46 
0B2DAD 06 
0B2DAE D9    1453** EXX
0B2DAF DD    1454** LD	DE, (IX+0)
0B2DB0 17 
0B2DB1 00 
0B2DB2 D9    1455** EXX
0B2DB3 DD    1456** LD	DE, (IX+3)
0B2DB4 17 
0B2DB5 03 
0B2DB6 C9    1457** RET
             1458** ;
             1459** ;CON_FP - Get unsigned numeric constant from ASCII string.
             1460** ;   Inputs: ASCII string at (IX).
             1461** ;  Outputs: Variable-type result in HLH'L'C
             1462** ;           IX updated (points to delimiter)
             1463** ;           A7 = 0 (numeric marker)
             1464** ;
0B2DB7 CD    1465** CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B2DB8 ED 
0B2DB9 2F 
0B2DBA 0B 
0B2DBB 0E    1466** LD      C,0             ;TRUNCATION COUNTER
0B2DBC 00 
0B2DBD CD    1467** CALL    UINT          ;GET INTEGER PART
0B2DBE 4B 
0B2DBF 2E 
0B2DC0 0B 
0B2DC1 FE    1468** CP      '.'
0B2DC2 2E 
0B2DC3 06    1469** LD      B,0             ;DECL. PLACE COUNTER
0B2DC4 00 
0B2DC5 CC    1470** CALL    Z,NUMBIX        ;GET FRACTION PART
0B2DC6 49 
0B2DC7 2E 
0B2DC8 0B 
0B2DC9 FE    1471** CP      'E'
0B2DCA 45 
0B2DCB 3E    1472** LD      A,0             ;INITIALISE EXPONENT
0B2DCC 00 
0B2DCD CC    1473** CALL    Z,GETEXP        ;GET EXPONENT
0B2DCE 17 
0B2DCF 2E 
0B2DD0 0B 
0B2DD1 CB    1474** BIT     7,H
0B2DD2 7C 
0B2DD3 20    1475** JR      NZ,CON0         ;INTEGER OVERFLOW
0B2DD4 08 
0B2DD5 B7    1476** OR      A
0B2DD6 20    1477** JR      NZ,CON0         ;EXPONENT NON-ZERO
0B2DD7 05 
0B2DD8 B8    1478** CP      B
0B2DD9 20    1479** JR      NZ,CON0         ;DECIMAL POINT
0B2DDA 02 
0B2DDB B9    1480** CP      C
0B2DDC C8    1481** RET     Z               ;INTEGER
0B2DDD 90    1482** CON0:			SUB     B
0B2DDE 81    1483** ADD     A,C
0B2DDF 0E    1484** LD      C,159
0B2DE0 9F 
0B2DE1 CD    1485** CALL    FLOAT_
0B2DE2 50 
0B2DE3 2F 
0B2DE4 0B 
0B2DE5 CB    1486** RES     7,H             ;DITCH IMPLIED 1
0B2DE6 BC 
0B2DE7 B7    1487** OR      A
0B2DE8 C8    1488** RET     Z               ;DONE
0B2DE9 FA    1489** JP      M,CON2          ;NEGATIVE EXPONENT
0B2DEA F7 
0B2DEB 2D 
0B2DEC 0B 
0B2DED CD    1490** CALL    POWR10
0B2DEE E9 
0B2DEF 30 
0B2DF0 0B 
0B2DF1 CD    1491** CALL    FMUL            ;SCALE
0B2DF2 D8 
0B2DF3 26 
0B2DF4 0B 
0B2DF5 AF    1492** XOR     A
0B2DF6 C9    1493** RET
0B2DF7 FE    1494** CON2:			CP      -38
0B2DF8 DA 
0B2DF9 38    1495** JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B2DFA 0C 
0B2DFB ED    1496** NEG
0B2DFC 44 
0B2DFD CD    1497** CALL    POWR10
0B2DFE E9 
0B2DFF 30 
0B2E00 0B 
0B2E01 CD    1498** CALL    FDIV            ;SCALE
0B2E02 2F 
0B2E03 26 
0B2E04 0B 
0B2E05 AF    1499** XOR     A
0B2E06 C9    1500** RET
0B2E07 F5    1501** CON3:			PUSH    AF
0B2E08 3E    1502** LD      A,38
0B2E09 26 
0B2E0A CD    1503** CALL    POWR10
0B2E0B E9 
0B2E0C 30 
0B2E0D 0B 
0B2E0E CD    1504** CALL    FDIV
0B2E0F 2F 
0B2E10 26 
0B2E11 0B 
0B2E12 F1    1505** POP     AF
0B2E13 C6    1506** ADD     A,38
0B2E14 26 
0B2E15 18    1507** JR      CON2
0B2E16 E0 
             1508** ;
             1509** ;GETEXP - Get decimal exponent from string
             1510** ;     Inputs: ASCII string at (IX)
             1511** ;             (IX points at 'E')
             1512** ;             A = initial value
             1513** ;    Outputs: A = new exponent
             1514** ;             IX updated.
             1515** ;   Destroys: A,A',IX,F,F'
             1516** ;
0B2E17 C5    1517** GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B2E18 47    1518** LD      B,A             ;INITIAL VALUE
0B2E19 0E    1519** LD      C,2             ;2 DIGITS MAX
0B2E1A 02 
0B2E1B DD    1520** INC     IX              ;BUMP PAST 'E'
0B2E1C 23 
0B2E1D CD    1521** CALL    SIGNQ
0B2E1E 07 
0B2E1F 32 
0B2E20 0B 
0B2E21 08    1522** EX      AF,AF'          ;SAVE EXPONENT SIGN
0B2E22 CD    1523** GETEX1:			CALL    DIGITQ
0B2E23 FD 
0B2E24 31 
0B2E25 0B 
0B2E26 38    1524** JR      C,GETEX2
0B2E27 18 
0B2E28 78    1525** LD      A,B             ;B=B*10
0B2E29 87    1526** ADD     A,A
0B2E2A 87    1527** ADD     A,A
0B2E2B 80    1528** ADD     A,B
0B2E2C 87    1529** ADD     A,A
0B2E2D 47    1530** LD      B,A
0B2E2E DD    1531** LD      A,(IX)          ;GET BACK DIGIT
0B2E2F 7E 
0B2E30 00 
0B2E31 DD    1532** INC     IX
0B2E32 23 
0B2E33 E6    1533** AND     0FH             ;MASK UNWANTED BITS
0B2E34 0F 
0B2E35 80    1534** ADD     A,B             ;ADD IN DIGIT
0B2E36 47    1535** LD      B,A
0B2E37 0D    1536** DEC     C
0B2E38 F2    1537** JP      P,GETEX1
0B2E39 22 
0B2E3A 2E 
0B2E3B 0B 
0B2E3C 06    1538** LD      B,100           ;FORCE OVERFLOW
0B2E3D 64 
0B2E3E 18    1539** JR      GETEX1
0B2E3F E2 
0B2E40 08    1540** GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B2E41 FE    1541** CP      '-'
0B2E42 2D 
0B2E43 78    1542** LD      A,B
0B2E44 C1    1543** POP     BC              ;RESTORE
0B2E45 C0    1544** RET     NZ
0B2E46 ED    1545** NEG                     ;NEGATE EXPONENT
0B2E47 44 
0B2E48 C9    1546** RET
             1547** ;
             1548** ;UINT: Get unsigned integer from string.
             1549** ;    Inputs: string at (IX)
             1550** ;            C = truncated digit count
             1551** ;                (initially zero)
             1552** ;            B = total digit count
             1553** ;            HLH'L' = initial value
             1554** ;   Outputs: HLH'L' = number (binary integer)
             1555** ;            A = delimiter.
             1556** ;            B, C & IX updated
             1557** ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
             1558** ;
0B2E49 DD    1559** NUMBIX:			INC     IX
0B2E4A 23 
0B2E4B CD    1560** UINT:			CALL    DIGITQ
0B2E4C FD 
0B2E4D 31 
0B2E4E 0B 
0B2E4F D8    1561** RET     C
0B2E50 04    1562** INC     B               ;INCREMENT DIGIT COUNT
0B2E51 DD    1563** INC     IX
0B2E52 23 
0B2E53 CD    1564** CALL    X10             ;*10 & COPY OLD VALUE
0B2E54 46 
0B2E55 30 
0B2E56 0B 
0B2E57 38    1565** JR      C,NUMB1         ;OVERFLOW
0B2E58 15 
0B2E59 0D    1566** DEC     C               ;SEE IF TRUNCATED
0B2E5A 0C    1567** INC     C
0B2E5B 20    1568** JR      NZ,NUMB1        ;IMPORTANT!
0B2E5C 11 
0B2E5D E6    1569** AND     0FH
0B2E5E 0F 
0B2E5F D9    1570** EXX
0B2E60 06    1571** LD      B,0
0B2E61 00 
0B2E62 4F    1572** LD      C,A
0B2E63 52    1573** ADD.S   HL,BC           ;ADD IN DIGIT
0B2E64 09 
0B2E65 D9    1574** EXX
0B2E66 30    1575** JR      NC,UINT
0B2E67 E3 
0B2E68 52    1576** INC.S   HL              ;CARRY
0B2E69 23 
0B2E6A 7C    1577** LD      A,H
0B2E6B B5    1578** OR      L
0B2E6C 20    1579** JR      NZ,UINT
0B2E6D DD 
0B2E6E 0C    1580** NUMB1:			INC     C               ;TRUNCATION COUNTER
0B2E6F CD    1581** CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B2E70 A4 
0B2E71 2F 
0B2E72 0B 
0B2E73 18    1582** JR      UINT
0B2E74 D6 
             1583** ;
             1584** ;FIX - Fix number to specified exponent value.
             1585** ;    Inputs: HLH'L'C = +ve non-zero number (floated)
             1586** ;            A = desired exponent (A>C)
             1587** ;   Outputs: HLH'L'C = fixed number (unsigned)
             1588** ;            fraction shifted into B'C'
             1589** ;            A'F' positive if integer input
             1590** ;  Destroys: C,H,L,A',B',C',H',L',F,F'
             1591** ;
0B2E75 08    1592** FIX:			EX      AF,AF'
0B2E76 AF    1593** XOR     A
0B2E77 08    1594** EX      AF,AF'
0B2E78 CB    1595** SET     7,H             ;IMPLIED 1
0B2E79 FC 
0B2E7A CD    1596** FIX1:			CALL    DIV2
0B2E7B A9 
0B2E7C 2F 
0B2E7D 0B 
0B2E7E B9    1597** CP      C
0B2E7F C8    1598** RET     Z
0B2E80 D2    1599** JP      NC,FIX1
0B2E81 7A 
0B2E82 2E 
0B2E83 0B 
0B2E84 C3    1600** JP      OFLOW
0B2E85 B8 
0B2E86 2F 
0B2E87 0B 
             1601** ;
             1602** ;SFIX - Convert to integer if necessary.
             1603** ;    Input: Variable-type number in HLH'L'C
             1604** ;   Output: Integer in HLH'L', C=0
             1605** ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
             1606** ;
             1607** ;NEGATE - Negate HLH'L'
             1608** ;    Destroys: H,L,H',L',F
             1609** ;
0B2E88 CD    1610** FIX2:			CALL    SWAP_FP
0B2E89 A1 
0B2E8A 2F 
0B2E8B 0B 
0B2E8C CD    1611** CALL    SFIX_FP
0B2E8D 94 
0B2E8E 2E 
0B2E8F 0B 
0B2E90 CD    1612** CALL    SWAP_FP
0B2E91 A1 
0B2E92 2F 
0B2E93 0B 
0B2E94 0D    1613** SFIX_FP:			DEC     C
0B2E95 0C    1614** INC     C
0B2E96 C8    1615** RET     Z               ;INTEGER/ZERO
0B2E97 CB    1616** BIT     7,H             ;SIGN
0B2E98 7C 
0B2E99 F5    1617** PUSH    AF
0B2E9A 3E    1618** LD      A,159
0B2E9B 9F 
0B2E9C CD    1619** CALL    FIX
0B2E9D 75 
0B2E9E 2E 
0B2E9F 0B 
0B2EA0 F1    1620** POP     AF
0B2EA1 0E    1621** LD      C,0
0B2EA2 00 
0B2EA3 C8    1622** RET     Z
0B2EA4 B7    1623** NEGATE:			OR      A               ;CLEAR CARRY
0B2EA5 D9    1624** EXX
0B2EA6 D5    1625** NEG0:			PUSH    DE
0B2EA7 EB    1626** EX      DE,HL
0B2EA8 21    1627** LD      HL,0
0B2EA9 00 
0B2EAA 00 
0B2EAB 00 
0B2EAC 52    1628** SBC.S   HL,DE
0B2EAD ED 
0B2EAE 52 
0B2EAF D1    1629** POP     DE
0B2EB0 D9    1630** EXX
0B2EB1 D5    1631** PUSH    DE
0B2EB2 EB    1632** EX      DE,HL
0B2EB3 21    1633** LD      HL,0
0B2EB4 00 
0B2EB5 00 
0B2EB6 00 
0B2EB7 52    1634** SBC.S   HL,DE
0B2EB8 ED 
0B2EB9 52 
0B2EBA D1    1635** POP     DE
0B2EBB C9    1636** RET
             1637** ;
             1638** ;NEG - Negate HLH'L'B'C'
             1639** ;    Also complements A (used in FADD)
             1640** ;    Destroys: A,H,L,B',C',H',L',F
             1641** ;
0B2EBC D9    1642** NEG_:			EXX
0B2EBD 2F    1643** CPL
0B2EBE E5    1644** PUSH    HL
0B2EBF B7    1645** OR      A               ;CLEAR CARRY
0B2EC0 21    1646** LD      HL,0
0B2EC1 00 
0B2EC2 00 
0B2EC3 00 
0B2EC4 52    1647** SBC.S   HL,BC
0B2EC5 ED 
0B2EC6 42 
0B2EC7 44    1648** LD      B,H
0B2EC8 4D    1649** LD      C,L
0B2EC9 E1    1650** POP     HL
0B2ECA 18    1651** JR      NEG0
0B2ECB DA 
             1652** ;
             1653** ;SCALE - Trig scaling.
             1654** ;MOD48 - 48-bit floating-point "modulus" (remainder).
             1655** ;   Inputs: HLH'L'C unsigned floating-point dividend
             1656** ;           DED'E'B'C'B unsigned 48-bit FP divisor
             1657** ;  Outputs: HLH'L'C floating point remainder (H7=1)
             1658** ;           E = quotient (bit 7 is sticky)
             1659** ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
             1660** ;FLO48 - Float unsigned number (48 bits)
             1661** ;    Input/output in HLH'L'B'C'C
             1662** ;   Destroys: C,H,L,B',C',H',L',F
             1663** ;
0B2ECC 3E    1664** SCALE:			LD      A,150
0B2ECD 96 
0B2ECE B9    1665** CP      C
0B2ECF 3E    1666** LD      A,ACLOST
0B2ED0 17 
0B2ED1 DA    1667** JP      C,ERROR_FP_         ;"Accuracy lost"
0B2ED2 47 
0B2ED3 24 
0B2ED4 0B 
0B2ED5 CD    1668** CALL    PIBY4
0B2ED6 12 
0B2ED7 2A 
0B2ED8 0B 
0B2ED9 D9    1669** EXX
0B2EDA 01    1670** LD      BC,2169H        ;3.141592653589793238
0B2EDB 69 
0B2EDC 21 
0B2EDD 00 
0B2EDE D9    1671** EXX
0B2EDF CB    1672** MOD48:			SET     7,D             ;IMPLIED 1
0B2EE0 FA 
0B2EE1 CB    1673** SET     7,H
0B2EE2 FC 
0B2EE3 79    1674** LD      A,C
0B2EE4 0E    1675** LD      C,0             ;INIT QUOTIENT
0B2EE5 00 
0B2EE6 DD    1676** LD      IX,0
0B2EE7 21 
0B2EE8 00 
0B2EE9 00 
0B2EE9 00   
0B2EEB DD    1677** PUSH    IX              ;PUT ZERO ON STACK
0B2EEC E5 
0B2EED B8    1678** CP      B
0B2EEE 38    1679** JR      C,MOD485        ;DIVIDEND<DIVISOR
0B2EEF 46 
0B2EF0 D9    1680** MOD481:			EXX                     ;CARRY=0 HERE
0B2EF1 E3    1681** EX      (SP),HL
0B2EF2 52    1682** SBC.S   HL,BC
0B2EF3 ED 
0B2EF4 42 
0B2EF5 E3    1683** EX      (SP),HL
0B2EF6 52    1684** SBC.S   HL,DE
0B2EF7 ED 
0B2EF8 52 
0B2EF9 D9    1685** EXX
0B2EFA 52    1686** SBC.S   HL,DE
0B2EFB ED 
0B2EFC 52 
0B2EFD 30    1687** JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B2EFE 0C 
0B2EFF D9    1688** EXX
0B2F00 E3    1689** EX      (SP),HL
0B2F01 52    1690** ADD.S   HL,BC
0B2F02 09 
0B2F03 E3    1691** EX      (SP),HL
0B2F04 52    1692** ADC.S   HL,DE
0B2F05 ED 
0B2F06 5A 
0B2F07 D9    1693** EXX
0B2F08 52    1694** ADC.S   HL,DE
0B2F09 ED 
0B2F0A 5A 
0B2F0B 3F    1695** MOD482:			CCF
0B2F0C CB    1696** RL      C               ;QUOTIENT
0B2F0D 11 
0B2F0E 30    1697** JR      NC,MOD483
0B2F0F 02 
0B2F10 CB    1698** SET     7,C             ;STICKY BIT
0B2F11 F9 
0B2F12 3D    1699** MOD483:			DEC     A
0B2F13 B8    1700** CP      B
0B2F14 38    1701** JR      C,MOD484        ;DIVIDEND<DIVISOR
0B2F15 1F 
0B2F16 E3    1702** EX      (SP),HL
0B2F17 52    1703** ADD.S   HL,HL           ;DIVIDEND * 2
0B2F18 29 
0B2F19 E3    1704** EX      (SP),HL
0B2F1A D9    1705** EXX
0B2F1B 52    1706** ADC.S   HL,HL
0B2F1C ED 
0B2F1D 6A 
0B2F1E D9    1707** EXX
0B2F1F 52    1708** ADC.S   HL,HL
0B2F20 ED 
0B2F21 6A 
0B2F22 30    1709** JR      NC,MOD481       ;AGAIN
0B2F23 CC 
0B2F24 B7    1710** OR      A
0B2F25 D9    1711** EXX
0B2F26 E3    1712** EX      (SP),HL
0B2F27 52    1713** SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B2F28 ED 
0B2F29 42 
0B2F2A E3    1714** EX      (SP),HL
0B2F2B 52    1715** SBC.S   HL,DE
0B2F2C ED 
0B2F2D 52 
0B2F2E D9    1716** EXX
0B2F2F 52    1717** SBC.S   HL,DE
0B2F30 ED 
0B2F31 52 
0B2F32 B7    1718** OR      A
0B2F33 18    1719** JR      MOD482
0B2F34 D6 
             1720** ;
0B2F35 3C    1721** MOD484:			INC     A
0B2F36 59    1722** MOD485:			LD      E,C             ;QUOTIENT
0B2F37 4F    1723** LD      C,A             ;REMAINDER EXPONENT
0B2F38 D9    1724** EXX
0B2F39 C1    1725** POP     BC
0B2F3A D9    1726** EXX
0B2F3B CB    1727** FLO48:			BIT     7,H
0B2F3C 7C 
0B2F3D C0    1728** RET     NZ
0B2F3E D9    1729** EXX
0B2F3F CB    1730** SLA     C
0B2F40 21 
0B2F41 CB    1731** RL      B
0B2F42 10 
0B2F43 52    1732** ADC.S   HL,HL
0B2F44 ED 
0B2F45 6A 
0B2F46 D9    1733** EXX
0B2F47 52    1734** ADC.S   HL,HL
0B2F48 ED 
0B2F49 6A 
0B2F4A 0D    1735** DEC     C
0B2F4B C2    1736** JP      NZ,FLO48
0B2F4C 3B 
0B2F4D 2F 
0B2F4E 0B 
0B2F4F C9    1737** RET
             1738** ;
             1739** ;Float unsigned number
             1740** ;    Input/output in HLH'L'C
             1741** ;   Destroys: C,H,L,H',L',F
             1742** ;
0B2F50 CB    1743** FLOAT_:			BIT     7,H
0B2F51 7C 
0B2F52 C0    1744** RET     NZ
0B2F53 D9    1745** EXX                     ;SAME AS "X2"
0B2F54 52    1746** ADD.S   HL,HL           ;TIME-CRITICAL
0B2F55 29 
0B2F56 D9    1747** EXX                     ;REGION
0B2F57 52    1748** ADC.S   HL,HL           ;(BENCHMARKS)
0B2F58 ED 
0B2F59 6A 
0B2F5A 0D    1749** DEC     C
0B2F5B C2    1750** JP      NZ,FLOAT_
0B2F5C 50 
0B2F5D 2F 
0B2F5E 0B 
0B2F5F C9    1751** RET
             1752** ;
             1753** ;SFLOAT - Convert to floating-point if necessary.
             1754** ;    Input: Variable-type number in HLH'L'C
             1755** ;    Output: Floating-point in HLH'L'C
             1756** ;    Destroys: A,C,H,L,H',L',F
             1757** ;
0B2F60 08    1758** FLOATA:			EX      AF,AF'
             1759** ; ADD     A,(RTABLE-DTABLE)/3
0B2F61 C6    1760** ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B2F62 2A 
0B2F63 08    1761** EX      AF,AF'
0B2F64 CD    1762** FLOAT2:			CALL    SWAP_FP
0B2F65 A1 
0B2F66 2F 
0B2F67 0B 
0B2F68 CD    1763** CALL    SFLOAT_FP
0B2F69 70 
0B2F6A 2F 
0B2F6B 0B 
0B2F6C CD    1764** CALL    SWAP_FP
0B2F6D A1 
0B2F6E 2F 
0B2F6F 0B 
0B2F70 0D    1765** SFLOAT_FP:			DEC     C
0B2F71 0C    1766** INC     C
0B2F72 C0    1767** RET     NZ              ;ALREADY FLOATING-POINT
0B2F73 CD    1768** CALL    TEST_FP
0B2F74 C9 
0B2F75 2F 
0B2F76 0B 
0B2F77 C8    1769** RET     Z               ;ZERO
0B2F78 7C    1770** LD      A,H
0B2F79 B7    1771** OR      A
0B2F7A FC    1772** CALL    M,NEGATE
0B2F7B A4 
0B2F7C 2E 
0B2F7D 0B 
0B2F7E 0E    1773** LD      C,159
0B2F7F 9F 
0B2F80 CD    1774** CALL    FLOAT_
0B2F81 50 
0B2F82 2F 
0B2F83 0B 
0B2F84 B7    1775** OR      A
0B2F85 F8    1776** RET     M               ;NEGATIVE
0B2F86 CB    1777** RES     7,H
0B2F87 BC 
0B2F88 C9    1778** RET
             1779** ;
             1780** ;ROUND UP
             1781** ;Return with carry set if 32-bit overflow
             1782** ;   Destroys: H,L,B',C',H',L',F
             1783** ;
0B2F89 D9    1784** ADD1_FP:			EXX
0B2F8A 01    1785** LD      BC,1
0B2F8B 01 
0B2F8C 00 
0B2F8D 00 
0B2F8E 52    1786** ADD.S   HL,BC
0B2F8F 09 
0B2F90 D9    1787** EXX
0B2F91 D0    1788** RET     NC
0B2F92 C5    1789** PUSH    BC
0B2F93 01    1790** LD      BC,1
0B2F94 01 
0B2F95 00 
0B2F96 00 
0B2F97 52    1791** ADD.S   HL,BC
0B2F98 09 
0B2F99 C1    1792** POP     BC
0B2F9A C9    1793** RET
             1794** ;
             1795** ;ODD - Add one if even, leave alone if odd.
             1796** ; (Used to perform unbiassed rounding, i.e.
             1797** ;  number is rounded up half the time)
             1798** ;    Destroys: L',F (carry cleared)
             1799** ;
0B2F9B B7    1800** ODD:			OR      A               ;CLEAR CARRY
0B2F9C D9    1801** EXX
0B2F9D CB    1802** SET     0,L             ;MAKE ODD
0B2F9E C5 
0B2F9F D9    1803** EXX
0B2FA0 C9    1804** RET
             1805** ;
             1806** ;SWAP_FP - Swap arguments.
             1807** ;    Exchanges DE,HL D'E',H'L' and B,C
             1808** ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
             1809** ;SWAP1 - Swap DEHL with D'E'H'L'
             1810** ;    Destroys: D,E,H,L,D',E',H',L'
             1811** ;
0B2FA1 79    1812** SWAP_FP:			LD      A,C
0B2FA2 48    1813** LD      C,B
0B2FA3 47    1814** LD      B,A
0B2FA4 EB    1815** SWAP1:			EX      DE,HL
0B2FA5 D9    1816** EXX
0B2FA6 EB    1817** EX      DE,HL
0B2FA7 D9    1818** EXX
0B2FA8 C9    1819** RET
             1820** ;
             1821** ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
             1822** ; INCC - destroys C,F
             1823** ; OFLOW
             1824** ;
0B2FA9 CD    1825** DIV2:			CALL    D2
0B2FAA 62 
0B2FAB 30 
0B2FAC 0B 
0B2FAD D9    1826** EXX
0B2FAE CB    1827** RR      B
0B2FAF 18 
0B2FB0 CB    1828** RR      C
0B2FB1 19 
0B2FB2 08    1829** EX      AF,AF'
0B2FB3 B0    1830** OR      B
0B2FB4 08    1831** EX      AF,AF'
0B2FB5 D9    1832** EXX
0B2FB6 0C    1833** INCC:			INC     C
0B2FB7 C0    1834** RET     NZ
0B2FB8 3E    1835** OFLOW:			LD      A,TOOBIG_FP
0B2FB9 14 
0B2FBA C3    1836** JP      ERROR_FP_           ;"Too big"
0B2FBB 47 
0B2FBC 24 
0B2FBD 0B 
             1837** ;
             1838** ; FTEST - Test for zero & sign
             1839** ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
             1840** ;
0B2FBE CD    1841** FTEST_FP:			CALL    TEST_FP
0B2FBF C9 
0B2FC0 2F 
0B2FC1 0B 
0B2FC2 C8    1842** RET     Z
0B2FC3 7C    1843** LD      A,H
0B2FC4 E6    1844** AND     10000000B
0B2FC5 80 
0B2FC6 F6    1845** OR      01000000B
0B2FC7 40 
0B2FC8 C9    1846** RET
             1847** ;
             1848** ; TEST_FP - Test HLH'L' for zero.
             1849** ;     Output: Z-flag set & A=0 if HLH'L'=0
             1850** ;     Destroys: A,F
             1851** ;
0B2FC9 7C    1852** TEST_FP:			LD      A,H
0B2FCA B5    1853** OR      L
0B2FCB D9    1854** EXX
0B2FCC B4    1855** OR      H
0B2FCD B5    1856** OR      L
0B2FCE D9    1857** EXX
0B2FCF C9    1858** RET
             1859** ;
             1860** ; FCOMP - Compare two numbers
             1861** ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
             1862** ;
0B2FD0 78    1863** FCOMP_FP:			LD      A,B
0B2FD1 B1    1864** OR      C               ;Both integer?
0B2FD2 20    1865** JR      NZ,FCOMP1
0B2FD3 0B 
0B2FD4 CD    1866** CALL    ICP
0B2FD5 E9 
0B2FD6 2F 
0B2FD7 0B 
0B2FD8 3E    1867** FCOMP0:			LD      A,0
0B2FD9 00 
0B2FDA C8    1868** RET     Z               ;Equal
0B2FDB 3E    1869** LD      A,80H
0B2FDC 80 
0B2FDD 1F    1870** RRA
0B2FDE C9    1871** RET
             1872** ;
0B2FDF CD    1873** FCOMP1:			CALL    FLOAT2          ;Float both
0B2FE0 64 
0B2FE1 2F 
0B2FE2 0B 
0B2FE3 CD    1874** CALL    FCP
0B2FE4 F7 
0B2FE5 2F 
0B2FE6 0B 
0B2FE7 18    1875** JR      FCOMP0
0B2FE8 EF 
             1876** ;
             1877** ; Integer and floating point compare.
             1878** ; Sets carry & zero flags according to HLH'L'C-DED'E'B
             1879** ; Result pre-set to FALSE
             1880** ; ICP1, FCP1 destroy A,F
             1881** ;
             1882** ; ZERO - Return zero.
             1883** ;  Destroys: A,C,H,L,H',L'
             1884** ;
0B2FE9 CD    1885** ICP:			CALL    ICP1
0B2FEA 1C 
0B2FEB 30 
0B2FEC 0B 
0B2FED 3E    1886** ZERO_FP:			LD      A,0
0B2FEE 00 
0B2FEF D9    1887** EXX
0B2FF0 67    1888** LD      H,A
0B2FF1 6F    1889** LD      L,A
0B2FF2 D9    1890** EXX
0B2FF3 67    1891** LD      H,A
0B2FF4 6F    1892** LD      L,A
0B2FF5 4F    1893** LD      C,A
0B2FF6 C9    1894** RET
             1895** ;
0B2FF7 CD    1896** FCP:			CALL    FCP1
0B2FF8 0E 
0B2FF9 30 
0B2FFA 0B 
0B2FFB 18    1897** JR      ZERO_FP            ;PRESET FALSE
0B2FFC F0 
             1898** ;
0B2FFD 79    1899** FCP0:			LD      A,C
0B2FFE B8    1900** CP      B               ;COMPARE EXPONENTS
0B2FFF C0    1901** RET     NZ
             1902** ICP0:
0B3000 52    1903** SBC.S   HL,DE           ;COMP MANTISSA MSB
0B3001 ED 
0B3002 52 
0B3003 52    1904** ADD.S   HL,DE
0B3004 19 
0B3005 C0    1905** RET     NZ
0B3006 D9    1906** EXX
0B3007 52    1907** SBC.S   HL,DE           ;COMP MANTISSA LSB
0B3008 ED 
0B3009 52 
0B300A 52    1908** ADD.S   HL,DE
0B300B 19 
0B300C D9    1909** EXX
0B300D C9    1910** RET
             1911** ;
0B300E 7C    1912** FCP1:			LD      A,H
0B300F AA    1913** XOR     D
0B3010 7C    1914** LD      A,H
0B3011 17    1915** RLA
0B3012 F8    1916** RET     M
0B3013 30    1917** JR      NC,FCP0
0B3014 E8 
0B3015 CD    1918** CALL    FCP0
0B3016 FD 
0B3017 2F 
0B3018 0B 
0B3019 C8    1919** RET     Z               ;** V0.1 BUG FIX
0B301A 3F    1920** CCF
0B301B C9    1921** RET
             1922** ;
0B301C 7C    1923** ICP1:			LD      A,H
0B301D AA    1924** XOR     D
0B301E F2    1925** JP      P,ICP0
0B301F 00 
0B3020 30 
0B3021 0B 
0B3022 7C    1926** LD      A,H
0B3023 17    1927** RLA
0B3024 C9    1928** RET
             1929** ;
             1930** ; ADD - Integer add.
             1931** ; Carry, sign & zero flags valid on exit
             1932** ;     Destroys: H,L,H',L',F
             1933** ;
0B3025 05    1934** X10B:			DEC     B
0B3026 0C    1935** INC     C
0B3027 CD    1936** X5:			CALL    COPY0
0B3028 6E 
0B3029 30 
0B302A 0B 
0B302B CD    1937** CALL    D2C
0B302C 61 
0B302D 30 
0B302E 0B 
0B302F CD    1938** CALL    D2C
0B3030 61 
0B3031 30 
0B3032 0B 
0B3033 08    1939** EX      AF,AF'          ;SAVE CARRY
0B3034 D9    1940** ADD_:			EXX
0B3035 52    1941** ADD.S   HL,DE
0B3036 19 
0B3037 D9    1942** EXX
0B3038 52    1943** ADC.S   HL,DE
0B3039 ED 
0B303A 5A 
0B303B C9    1944** RET
             1945** ;
             1946** ; SUB - Integer subtract.
             1947** ; Carry, sign & zero flags valid on exit
             1948** ;     Destroys: H,L,H',L',F
             1949** ;
0B303C D9    1950** SUB_:			EXX
0B303D B7    1951** OR      A
0B303E 52    1952** SBC.S   HL,DE
0B303F ED 
0B3040 52 
0B3041 D9    1953** EXX
0B3042 52    1954** SBC.S   HL,DE
0B3043 ED 
0B3044 52 
0B3045 C9    1955** RET
             1956** ;
             1957** ; X10 - unsigned integer * 10
             1958** ;    Inputs: HLH'L' initial value
             1959** ;   Outputs: DED'E' = initial HLH'L'
             1960** ;            Carry bit set if overflow
             1961** ;            If carry not set HLH'L'=result
             1962** ;  Destroys: D,E,H,L,D',E',H',L',F
             1963** ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
             1964** ;     Carry set if MSB=1 before shift.
             1965** ;     Sign set if MSB=1 after shift.
             1966** ;     Destroys: H,L,H',L',F
             1967** ;
0B3046 CD    1968** X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B3047 6E 
0B3048 30 
0B3049 0B 
0B304A CD    1969** CALL    X2
0B304B 59 
0B304C 30 
0B304D 0B 
0B304E D8    1970** RET     C               ;TOO BIG
0B304F CD    1971** CALL    X2
0B3050 59 
0B3051 30 
0B3052 0B 
0B3053 D8    1972** RET     C
0B3054 CD    1973** CALL    ADD_
0B3055 34 
0B3056 30 
0B3057 0B 
0B3058 D8    1974** RET     C
0B3059 D9    1975** X2:			EXX
0B305A 52    1976** ADD.S   HL,HL
0B305B 29 
0B305C D9    1977** EXX
0B305D 52    1978** ADC.S   HL,HL
0B305E ED 
0B305F 6A 
0B3060 C9    1979** RET
             1980** ;
             1981** ; D2 - Divide HLH'L' by 2 as 32-bit integer.
             1982** ;     Carry set if LSB=1 before shift.
             1983** ;     Destroys: H,L,H',L',F
             1984** ;
0B3061 0C    1985** D2C:			INC     C
0B3062 CB    1986** D2:			SRL     H
0B3063 3C 
0B3064 CB    1987** RR      L
0B3065 1D 
0B3066 D9    1988** EXX
0B3067 CB    1989** RR      H
0B3068 1C 
0B3069 CB    1990** RR      L
0B306A 1D 
0B306B D9    1991** EXX
0B306C C9    1992** RET
             1993** ;
             1994** ; COPY - COPY HLH'L'C INTO DED'E'B
             1995** ;   Destroys: B,C,D,E,H,L,D',E',H',L'
             1996** ;
0B306D 41    1997** COPY_:			LD      B,C
0B306E 54    1998** COPY0:			LD      D,H
0B306F 5D    1999** LD      E,L
0B3070 D9    2000** EXX
0B3071 54    2001** LD      D,H
0B3072 5D    2002** LD      E,L
0B3073 D9    2003** EXX
0B3074 C9    2004** RET
             2005** ;
             2006** ; SQUARE - PUSH X*X
             2007** ; PUSH5 - PUSH HLH'L'C ONTO STACK.
             2008** ;   Destroys: SP,IX
             2009** ;
0B3075 CD    2010** SQUARE:			CALL    COPY_
0B3076 6D 
0B3077 30 
0B3078 0B 
0B3079 CD    2011** CALL    FMUL
0B307A D8 
0B307B 26 
0B307C 0B 
0B307D DD    2012** PUSH5:			POP     IX              ;RETURN ADDRESS
0B307E E1 
0B307F C5    2013** PUSH    BC
0B3080 E5    2014** PUSH    HL
0B3081 D9    2015** EXX
0B3082 E5    2016** PUSH    HL
0B3083 D9    2017** EXX
0B3084 DD    2018** JP      (IX)            ;"RETURN"
0B3085 E9 
             2019** ;
             2020** ; POP5 - POP DED'E'B OFF STACK.
             2021** ;   Destroys: A,B,D,E,D',E',SP,IX
             2022** ;
0B3086 DD    2023** POP5:			POP     IX              ;RETURN ADDRESS
0B3087 E1 
0B3088 D9    2024** EXX
0B3089 D1    2025** POP     DE
0B308A D9    2026** EXX
0B308B D1    2027** POP     DE
0B308C 79    2028** LD      A,C
0B308D C1    2029** POP     BC
0B308E 41    2030** LD      B,C
0B308F 4F    2031** LD      C,A
0B3090 DD    2032** JP      (IX)            ;"RETURN"
0B3091 E9 
             2033** ;
             2034** ; RATIO - Calculate (X-1)/(X+1)
             2035** ;     Inputs: X in HLH'L'C
             2036** ;    Outputs: (X-1)/(X+1) in HLH'L'C
             2037** ;   Destroys: Everything except IY,SP,I
             2038** ;
0B3092 CD    2039** RATIO:			CALL    PUSH5           ;SAVE X
0B3093 7D 
0B3094 30 
0B3095 0B 
0B3096 CD    2040** CALL    DONE
0B3097 05 
0B3098 2A 
0B3099 0B 
0B309A CD    2041** CALL    FADD
0B309B C6 
0B309C 25 
0B309D 0B 
0B309E CD    2042** CALL    POP5            ;RESTORE X
0B309F 86 
0B30A0 30 
0B30A1 0B 
0B30A2 CD    2043** CALL    PUSH5           ;SAVE X+1
0B30A3 7D 
0B30A4 30 
0B30A5 0B 
0B30A6 CD    2044** CALL    SWAP_FP
0B30A7 A1 
0B30A8 2F 
0B30A9 0B 
0B30AA CD    2045** CALL    DONE
0B30AB 05 
0B30AC 2A 
0B30AD 0B 
0B30AE CD    2046** CALL    FSUB
0B30AF AD 
0B30B0 25 
0B30B1 0B 
0B30B2 CD    2047** CALL    POP5            ;RESTORE X+1
0B30B3 86 
0B30B4 30 
0B30B5 0B 
0B30B6 C3    2048** JP      FDIV
0B30B7 2F 
0B30B8 26 
0B30B9 0B 
             2049** ;
             2050** ; POLY - Evaluate a polynomial.
             2051** ;     Inputs: X in HLH'L'C and also stored at (SP+2)
             2052** ;             Polynomial coefficients follow call.
             2053** ;    Outputs: Result in HLH'L'C
             2054** ;   Destroys: Everything except IY,SP,I
             2055** ; Routine terminates on finding a coefficient >=1.
             2056** ; Note: The last coefficient is EXECUTED on return
             2057** ;       so must contain only innocuous bytes!
             2058** ;
0B30BA DD    2059** POLY:			LD      IX, 3				; Advance the SP to the return address
0B30BB 21 
0B30BC 03 
0B30BD 00 
0B30BD 00   
0B30BF DD    2060** ADD     IX, SP
0B30C0 39 
0B30C1 DD    2061** EX      (SP), IX			; IX: Points to the inline list of coefficients
0B30C2 E3 
             2062** ;
0B30C3 CD    2063** CALL    DLOAD5          		; Load the first coefficient from (IX)
0B30C4 99 
0B30C5 2D 
0B30C6 0B 
0B30C7 CD    2064** POLY1:			CALL    FMUL
0B30C8 D8 
0B30C9 26 
0B30CA 0B 
0B30CB 11    2065** LD      DE, 5				; Skip to the next coefficient
0B30CC 05 
0B30CD 00 
0B30CE 00 
0B30CF DD    2066** ADD     IX, DE
0B30D0 19 
0B30D1 CD    2067** CALL    DLOAD5          		; Load the second coefficient from (IX)
0B30D2 99 
0B30D3 2D 
0B30D4 0B 
0B30D5 DD    2068** EX      (SP), IX			; Restore the SP just in case we need to return
0B30D6 E3 
0B30D7 04    2069** INC     B
0B30D8 05    2070** DEC     B               		; Test B for end byte (80h)
0B30D9 FA    2071** JP      M,FADD				; Yes, so add and return
0B30DA C6 
0B30DB 25 
0B30DC 0B 
0B30DD CD    2072** CALL    FADD				; No, so add
0B30DE C6 
0B30DF 25 
0B30E0 0B 
0B30E1 CD    2073** CALL    DLOAD5_SPL			; Load X from SP
0B30E2 AB 
0B30E3 2D 
0B30E4 0B 
0B30E5 DD    2074** EX      (SP), IX			; IX: Points to the inline list of coefficients
0B30E6 E3 
0B30E7 18    2075** JR      POLY1				; And loop
0B30E8 DE 
             2076** ;
             2077** ; POWR10 - Calculate power of ten.
             2078** ;     Inputs: A=power of 10 required (A<128)
             2079** ;             A=binary exponent to be exceeded (A>=128)
             2080** ;    Outputs: DED'E'B = result
             2081** ;             A = actual power of ten returned
             2082** ;   Destroys: A,B,D,E,A',D',E',F,F'
             2083** ;
0B30E9 3C    2084** POWR10:			INC     A
0B30EA 08    2085** EX      AF,AF'
0B30EB E5    2086** PUSH    HL
0B30EC D9    2087** EXX
0B30ED E5    2088** PUSH    HL
0B30EE D9    2089** EXX
0B30EF CD    2090** CALL    DONE
0B30F0 05 
0B30F1 2A 
0B30F2 0B 
0B30F3 CD    2091** CALL    SWAP_FP
0B30F4 A1 
0B30F5 2F 
0B30F6 0B 
0B30F7 AF    2092** XOR     A
0B30F8 08    2093** POWR11:			EX      AF,AF'
0B30F9 3D    2094** DEC     A
0B30FA 28    2095** JR      Z,POWR14        ;EXIT TYPE 1
0B30FB 26 
0B30FC F2    2096** JP      P,POWR13
0B30FD 04 
0B30FE 31 
0B30FF 0B 
0B3100 B9    2097** CP      C
0B3101 38    2098** JR      C,POWR14        ;EXIT TYPE 2
0B3102 1F 
0B3103 3C    2099** INC     A
0B3104 08    2100** POWR13:			EX      AF,AF'
0B3105 3C    2101** INC     A
0B3106 CB    2102** SET     7,H
0B3107 FC 
0B3108 CD    2103** CALL    X5
0B3109 27 
0B310A 30 
0B310B 0B 
0B310C 30    2104** JR      NC,POWR12
0B310D 06 
0B310E 08    2105** EX      AF,AF'
0B310F CD    2106** CALL    D2C
0B3110 61 
0B3111 30 
0B3112 0B 
0B3113 08    2107** EX      AF,AF'
0B3114 08    2108** POWR12:			EX      AF,AF'
0B3115 DC    2109** CALL    C,ADD1_FP          ;ROUND UP
0B3116 89 
0B3117 2F 
0B3118 0B 
0B3119 0C    2110** INC     C
0B311A FA    2111** JP      M,POWR11
0B311B F8 
0B311C 30 
0B311D 0B 
0B311E C3    2112** JP      OFLOW
0B311F B8 
0B3120 2F 
0B3121 0B 
0B3122 CD    2113** POWR14:			CALL    SWAP_FP
0B3123 A1 
0B3124 2F 
0B3125 0B 
0B3126 CB    2114** RES     7,D
0B3127 BA 
0B3128 D9    2115** EXX
0B3129 E1    2116** POP     HL
0B312A D9    2117** EXX
0B312B E1    2118** POP     HL
0B312C 08    2119** EX      AF,AF'
0B312D C9    2120** RET
             2121** ;
             2122** ; DIVA, DIVB - DIVISION PRIMITIVE.
             2123** ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
             2124** ;               Remainder in H'L'HL
             2125** ;     Inputs: A = loop counter (normally -32)
             2126** ;     Destroys: A,D,E,H,L,D',E',H',L',F
             2127** ;
0B312E B7    2128** DIVA:			OR      A               ;CLEAR CARRY
             2129** DIV0:
0B312F 52    2130** SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B3130 ED 
0B3131 42 
0B3132 D9    2131** EXX
0B3133 52    2132** SBC.S   HL,BC
0B3134 ED 
0B3135 42 
0B3136 D9    2133** EXX
0B3137 30    2134** JR      NC,DIV1
0B3138 07 
0B3139 52    2135** ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B313A 09 
0B313B D9    2136** EXX
0B313C 52    2137** ADC.S   HL,BC
0B313D ED 
0B313E 4A 
0B313F D9    2138** EXX
0B3140 3F    2139** DIV1:			CCF
0B3141 CB    2140** DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B3142 13 
0B3143 CB    2141** RL      D
0B3144 12 
0B3145 D9    2142** EXX
0B3146 CB    2143** RL      E
0B3147 13 
0B3148 CB    2144** RL      D
0B3149 12 
0B314A D9    2145** EXX
0B314B 3C    2146** INC     A
0B314C F0    2147** RET     P
             2148** DIVB:
0B314D 52    2149** ADC.S   HL,HL           ;DIVIDEND*2
0B314E ED 
0B314F 6A 
0B3150 D9    2150** EXX
0B3151 52    2151** ADC.S   HL,HL
0B3152 ED 
0B3153 6A 
0B3154 D9    2152** EXX
0B3155 30    2153** JR      NC,DIV0
0B3156 D8 
0B3157 B7    2154** OR      A
0B3158 52    2155** SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B3159 ED 
0B315A 42 
0B315B D9    2156** EXX
0B315C 52    2157** SBC.S   HL,BC
0B315D ED 
0B315E 42 
0B315F D9    2158** EXX
0B3160 37    2159** SCF
0B3161 C3    2160** JP      DIVC
0B3162 41 
0B3163 31 
0B3164 0B 
             2161** ;
             2162** ;MULA, MULB - MULTIPLICATION PRIMITIVE.
             2163** ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
             2164** ;    Inputs: A = loop counter (usually -32)
             2165** ;            H'L'HL = 0
             2166** ;    Destroys: D,E,H,L,D',E',H',L',A,F
             2167** ;
0B3165 B7    2168** MULA:			OR      A               ;CLEAR CARRY
0B3166 D9    2169** MUL0:			EXX
0B3167 CB    2170** RR      D               ;MULTIPLIER/2
0B3168 1A 
0B3169 CB    2171** RR      E
0B316A 1B 
0B316B D9    2172** EXX
0B316C CB    2173** RR      D
0B316D 1A 
0B316E CB    2174** RR      E
0B316F 1B 
0B3170 30    2175** JR      NC,MUL1
0B3171 07 
0B3172 52    2176** ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B3173 09 
0B3174 D9    2177** EXX
0B3175 52    2178** ADC.S   HL,BC
0B3176 ED 
0B3177 4A 
0B3178 D9    2179** EXX
0B3179 3C    2180** MUL1:			INC     A
0B317A F0    2181** RET     P
0B317B D9    2182** MULB:			EXX
0B317C CB    2183** RR      H               ;PRODUCT/2
0B317D 1C 
0B317E CB    2184** RR      L
0B317F 1D 
0B3180 D9    2185** EXX
0B3181 CB    2186** RR      H
0B3182 1C 
0B3183 CB    2187** RR      L
0B3184 1D 
0B3185 C3    2188** JP      MUL0
0B3186 66 
0B3187 31 
0B3188 0B 
             2189** ;
             2190** ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
             2191** ;     Function: B'C'BC = SQR (D'E'DE)
             2192** ;     Inputs: A = loop counter (normally -31)
             2193** ;             B'C'BCH'L'HL initialised to 0
             2194** ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
             2195** ;
             2196** SQR1:
0B3189 52    2197** SBC.S   HL,BC
0B318A ED 
0B318B 42 
0B318C D9    2198** EXX
0B318D 52    2199** SBC.S   HL,BC
0B318E ED 
0B318F 42 
0B3190 D9    2200** EXX
0B3191 0C    2201** INC     C
0B3192 30    2202** JR      NC,SQR2
0B3193 09 
0B3194 0D    2203** DEC     C
0B3195 52    2204** ADD.S   HL,BC
0B3196 09 
0B3197 D9    2205** EXX
0B3198 52    2206** ADC.S   HL,BC
0B3199 ED 
0B319A 4A 
0B319B D9    2207** EXX
0B319C 0D    2208** DEC     C
0B319D 3C    2209** SQR2:			INC     A
0B319E F0    2210** RET     P
0B319F CB    2211** SQRA:			SLA     C
0B31A0 21 
0B31A1 CB    2212** RL      B
0B31A2 10 
0B31A3 D9    2213** EXX
0B31A4 CB    2214** RL      C
0B31A5 11 
0B31A6 CB    2215** RL      B
0B31A7 10 
0B31A8 D9    2216** EXX
0B31A9 0C    2217** INC     C
0B31AA CB    2218** SLA     E
0B31AB 23 
0B31AC CB    2219** RL      D
0B31AD 12 
0B31AE D9    2220** EXX
0B31AF CB    2221** RL      E
0B31B0 13 
0B31B1 CB    2222** RL      D
0B31B2 12 
0B31B3 D9    2223** EXX
0B31B4 52    2224** ADC.S   HL,HL
0B31B5 ED 
0B31B6 6A 
0B31B7 D9    2225** EXX
0B31B8 52    2226** ADC.S   HL,HL
0B31B9 ED 
0B31BA 6A 
0B31BB D9    2227** EXX
0B31BC CB    2228** SLA     E
0B31BD 23 
0B31BE CB    2229** RL      D
0B31BF 12 
0B31C0 D9    2230** EXX
0B31C1 CB    2231** RL      E
0B31C2 13 
0B31C3 CB    2232** RL      D
0B31C4 12 
0B31C5 D9    2233** EXX
0B31C6 52    2234** ADC.S   HL,HL
0B31C7 ED 
0B31C8 6A 
0B31C9 D9    2235** EXX
0B31CA 52    2236** ADC.S   HL,HL
0B31CB ED 
0B31CC 6A 
0B31CD D9    2237** EXX
0B31CE D2    2238** JP      NC,SQR1
0B31CF 89 
0B31D0 31 
0B31D1 0B 
0B31D2 B7    2239** SQR3:			OR      A
0B31D3 52    2240** SBC.S   HL,BC
0B31D4 ED 
0B31D5 42 
0B31D6 D9    2241** EXX
0B31D7 52    2242** SBC.S   HL,BC
0B31D8 ED 
0B31D9 42 
0B31DA D9    2243** EXX
0B31DB 0C    2244** INC     C
0B31DC C3    2245** JP      SQR2
0B31DD 9D 
0B31DE 31 
0B31DF 0B 
             2246** ;
             2247** SQRB:
0B31E0 52    2248** ADD.S   HL,HL
0B31E1 29 
0B31E2 D9    2249** EXX
0B31E3 52    2250** ADC.S   HL,HL
0B31E4 ED 
0B31E5 6A 
0B31E6 D9    2251** EXX
0B31E7 38    2252** JR      C,SQR3
0B31E8 E9 
0B31E9 3C    2253** INC     A
0B31EA 0C    2254** INC     C
0B31EB 52    2255** SBC.S   HL,BC
0B31EC ED 
0B31ED 42 
0B31EE D9    2256** EXX
0B31EF 52    2257** SBC.S   HL,BC
0B31F0 ED 
0B31F1 42 
0B31F2 D9    2258** EXX
0B31F3 D0    2259** RET     NC
0B31F4 52    2260** ADD.S   HL,BC
0B31F5 09 
0B31F6 D9    2261** EXX
0B31F7 52    2262** ADC.S   HL,BC
0B31F8 ED 
0B31F9 4A 
0B31FA D9    2263** EXX
0B31FB 0D    2264** DEC     C
0B31FC C9    2265** RET
             2266** ;
0B31FD DD    2267** DIGITQ:			LD      A,(IX)
0B31FE 7E 
0B31FF 00 
0B3200 FE    2268** CP      '9'+1
0B3201 3A 
0B3202 3F    2269** CCF
0B3203 D8    2270** RET     C
0B3204 FE    2271** CP      '0'
0B3205 30 
0B3206 C9    2272** RET
             2273** ;
0B3207 DD    2274** SIGNQ:			LD      A,(IX)
0B3208 7E 
0B3209 00 
0B320A DD    2275** INC     IX
0B320B 23 
0B320C FE    2276** CP      ' '
0B320D 20 
0B320E 28    2277** JR      Z,SIGNQ
0B320F F7 
0B3210 FE    2278** CP      '+'
0B3211 2B 
0B3212 C8    2279** RET     Z
0B3213 FE    2280** CP      '-'
0B3214 2D 
0B3215 C8    2281** RET     Z
0B3216 DD    2282** DEC     IX
0B3217 2B 
0B3218 C9    2283** RET
              0008* include "basic/gpio.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - GPIO functions
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	12/05/2023
             0006** ;
             0007** ; Modinfo:
             0008** 
             0009** ; INCLUDE	"macros.inc"
             0010** ; INCLUDE	"equs.inc"
             0011** 
             0012** ; .ASSUME	ADL = 1
             0013** 
             0014** ; SEGMENT CODE
             0015** 
             0016** ; XDEF	GPIOB_SETMODE
             0017** 
             0018** ; XREF	SWITCH_A
             0019** 
             0020** ;  A: Mode
             0021** ;  B: Pins
             0022** ;
0B3219 CD    0023** GPIOB_SETMODE:		CALL	SWITCH_A
0B321A BE 
0B321B 41 
0B321C 0B 
0B321D 31    0024** DW	GPIOB_M0	; Output
0B321E 32 
0B321F 56    0025** DW	GPIOB_M1	; Input
0B3220 32 
0B3221 76    0026** DW	GPIOB_M2	; Open Drain IO
0B3222 32 
0B3223 96    0027** DW	GPIOB_M3	; Open Source IO
0B3224 32 
0B3225 B1    0028** DW	GPIOB_M4	; Interrupt, Dual Edge
0B3226 32 
0B3227 DD    0029** DW	GPIOB_M5	; Alt Function
0B3228 32 
0B3229 F8    0030** DW	GPIOB_M6	; Interrupt, Active Low
0B322A 32 
0B322B 1F    0031** DW	GPIOB_M7	; Interrupt, Active High
0B322C 33 
0B322D 41    0032** DW	GPIOB_M8	; Interrupt, Falling Edge
0B322E 33 
0B322F 63    0033** DW	GPIOB_M9	; Interrupt, Rising Edge
0B3230 33 
             0034** 
             0035** ; Output
             0036** ;
             0037** GPIOB_M0:		RES_GPIO PB_DDR,  B
0B3231 C5   0001**M PUSH	BC
0B3232 78   0002**M LD	A, val
0B3233 2F   0003**M CPL
0B3234 4F   0004**M LD	C, A
0B3235 ED   0005**M IN0	A, (reg)
0B3236 38 
0B3237 9B 
0B3238 A1   0006**M AND	C
0B3239 ED   0007**M OUT0	(reg), A
0B323A 39 
0B323B 9B 
0B323C C1   0008**M POP	BC
             0038** RES_GPIO PB_ALT1, B
0B323D C5   0001**M PUSH	BC
0B323E 78   0002**M LD	A, val
0B323F 2F   0003**M CPL
0B3240 4F   0004**M LD	C, A
0B3241 ED   0005**M IN0	A, (reg)
0B3242 38 
0B3243 9C 
0B3244 A1   0006**M AND	C
0B3245 ED   0007**M OUT0	(reg), A
0B3246 39 
0B3247 9C 
0B3248 C1   0008**M POP	BC
             0039** RES_GPIO PB_ALT2, B
0B3249 C5   0001**M PUSH	BC
0B324A 78   0002**M LD	A, val
0B324B 2F   0003**M CPL
0B324C 4F   0004**M LD	C, A
0B324D ED   0005**M IN0	A, (reg)
0B324E 38 
0B324F 9D 
0B3250 A1   0006**M AND	C
0B3251 ED   0007**M OUT0	(reg), A
0B3252 39 
0B3253 9D 
0B3254 C1   0008**M POP	BC
0B3255 C9    0040** RET
             0041** 
             0042** ; Input
             0043** ;
             0044** GPIOB_M1:		SET_GPIO PB_DDR,  B
0B3256 ED   0001**M IN0	A, (reg)
0B3257 38 
0B3258 9B 
0B3259 B0   0002**M OR	val
0B325A ED   0003**M OUT0	(reg), A
0B325B 39 
0B325C 9B 
             0045** RES_GPIO PB_ALT1, B
0B325D C5   0001**M PUSH	BC
0B325E 78   0002**M LD	A, val
0B325F 2F   0003**M CPL
0B3260 4F   0004**M LD	C, A
0B3261 ED   0005**M IN0	A, (reg)
0B3262 38 
0B3263 9C 
0B3264 A1   0006**M AND	C
0B3265 ED   0007**M OUT0	(reg), A
0B3266 39 
0B3267 9C 
0B3268 C1   0008**M POP	BC
             0046** RES_GPIO PB_ALT2, B
0B3269 C5   0001**M PUSH	BC
0B326A 78   0002**M LD	A, val
0B326B 2F   0003**M CPL
0B326C 4F   0004**M LD	C, A
0B326D ED   0005**M IN0	A, (reg)
0B326E 38 
0B326F 9D 
0B3270 A1   0006**M AND	C
0B3271 ED   0007**M OUT0	(reg), A
0B3272 39 
0B3273 9D 
0B3274 C1   0008**M POP	BC
0B3275 C9    0047** RET
             0048** 
             0049** ; Open Drain IO
             0050** ;
             0051** GPIOB_M2:		RES_GPIO PB_DDR,  B
0B3276 C5   0001**M PUSH	BC
0B3277 78   0002**M LD	A, val
0B3278 2F   0003**M CPL
0B3279 4F   0004**M LD	C, A
0B327A ED   0005**M IN0	A, (reg)
0B327B 38 
0B327C 9B 
0B327D A1   0006**M AND	C
0B327E ED   0007**M OUT0	(reg), A
0B327F 39 
0B3280 9B 
0B3281 C1   0008**M POP	BC
             0052** SET_GPIO PB_ALT1, B
0B3282 ED   0001**M IN0	A, (reg)
0B3283 38 
0B3284 9C 
0B3285 B0   0002**M OR	val
0B3286 ED   0003**M OUT0	(reg), A
0B3287 39 
0B3288 9C 
             0053** RES_GPIO PB_ALT2, B
0B3289 C5   0001**M PUSH	BC
0B328A 78   0002**M LD	A, val
0B328B 2F   0003**M CPL
0B328C 4F   0004**M LD	C, A
0B328D ED   0005**M IN0	A, (reg)
0B328E 38 
0B328F 9D 
0B3290 A1   0006**M AND	C
0B3291 ED   0007**M OUT0	(reg), A
0B3292 39 
0B3293 9D 
0B3294 C1   0008**M POP	BC
0B3295 C9    0054** RET
             0055** 
             0056** ; Open Source IO
             0057** ;
             0058** GPIOB_M3:		SET_GPIO PB_DDR,  B
0B3296 ED   0001**M IN0	A, (reg)
0B3297 38 
0B3298 9B 
0B3299 B0   0002**M OR	val
0B329A ED   0003**M OUT0	(reg), A
0B329B 39 
0B329C 9B 
             0059** SET_GPIO PB_ALT1, B
0B329D ED   0001**M IN0	A, (reg)
0B329E 38 
0B329F 9C 
0B32A0 B0   0002**M OR	val
0B32A1 ED   0003**M OUT0	(reg), A
0B32A2 39 
0B32A3 9C 
             0060** RES_GPIO PB_ALT2, B
0B32A4 C5   0001**M PUSH	BC
0B32A5 78   0002**M LD	A, val
0B32A6 2F   0003**M CPL
0B32A7 4F   0004**M LD	C, A
0B32A8 ED   0005**M IN0	A, (reg)
0B32A9 38 
0B32AA 9D 
0B32AB A1   0006**M AND	C
0B32AC ED   0007**M OUT0	(reg), A
0B32AD 39 
0B32AE 9D 
0B32AF C1   0008**M POP	BC
0B32B0 C9    0061** RET
             0062** 
             0063** ; Interrupt, Dual Edge
             0064** ;
             0065** GPIOB_M4:		SET_GPIO PB_DR,   B
0B32B1 ED   0001**M IN0	A, (reg)
0B32B2 38 
0B32B3 9A 
0B32B4 B0   0002**M OR	val
0B32B5 ED   0003**M OUT0	(reg), A
0B32B6 39 
0B32B7 9A 
             0066** RES_GPIO PB_DDR,  B
0B32B8 C5   0001**M PUSH	BC
0B32B9 78   0002**M LD	A, val
0B32BA 2F   0003**M CPL
0B32BB 4F   0004**M LD	C, A
0B32BC ED   0005**M IN0	A, (reg)
0B32BD 38 
0B32BE 9B 
0B32BF A1   0006**M AND	C
0B32C0 ED   0007**M OUT0	(reg), A
0B32C1 39 
0B32C2 9B 
0B32C3 C1   0008**M POP	BC
             0067** RES_GPIO PB_ALT1, B
0B32C4 C5   0001**M PUSH	BC
0B32C5 78   0002**M LD	A, val
0B32C6 2F   0003**M CPL
0B32C7 4F   0004**M LD	C, A
0B32C8 ED   0005**M IN0	A, (reg)
0B32C9 38 
0B32CA 9C 
0B32CB A1   0006**M AND	C
0B32CC ED   0007**M OUT0	(reg), A
0B32CD 39 
0B32CE 9C 
0B32CF C1   0008**M POP	BC
             0068** RES_GPIO PB_ALT2, B
0B32D0 C5   0001**M PUSH	BC
0B32D1 78   0002**M LD	A, val
0B32D2 2F   0003**M CPL
0B32D3 4F   0004**M LD	C, A
0B32D4 ED   0005**M IN0	A, (reg)
0B32D5 38 
0B32D6 9D 
0B32D7 A1   0006**M AND	C
0B32D8 ED   0007**M OUT0	(reg), A
0B32D9 39 
0B32DA 9D 
0B32DB C1   0008**M POP	BC
0B32DC C9    0069** RET
             0070** 
             0071** ; Alt Function
             0072** ;
             0073** GPIOB_M5:		SET_GPIO PB_DDR,  B
0B32DD ED   0001**M IN0	A, (reg)
0B32DE 38 
0B32DF 9B 
0B32E0 B0   0002**M OR	val
0B32E1 ED   0003**M OUT0	(reg), A
0B32E2 39 
0B32E3 9B 
             0074** RES_GPIO PB_ALT1, B
0B32E4 C5   0001**M PUSH	BC
0B32E5 78   0002**M LD	A, val
0B32E6 2F   0003**M CPL
0B32E7 4F   0004**M LD	C, A
0B32E8 ED   0005**M IN0	A, (reg)
0B32E9 38 
0B32EA 9C 
0B32EB A1   0006**M AND	C
0B32EC ED   0007**M OUT0	(reg), A
0B32ED 39 
0B32EE 9C 
0B32EF C1   0008**M POP	BC
             0075** SET_GPIO PB_ALT2, B
0B32F0 ED   0001**M IN0	A, (reg)
0B32F1 38 
0B32F2 9D 
0B32F3 B0   0002**M OR	val
0B32F4 ED   0003**M OUT0	(reg), A
0B32F5 39 
0B32F6 9D 
0B32F7 C9    0076** RET
             0077** 
             0078** ; Interrupt, Active Low
             0079** ;
             0080** GPIOB_M6:		RES_GPIO PB_DR,   B
0B32F8 C5   0001**M PUSH	BC
0B32F9 78   0002**M LD	A, val
0B32FA 2F   0003**M CPL
0B32FB 4F   0004**M LD	C, A
0B32FC ED   0005**M IN0	A, (reg)
0B32FD 38 
0B32FE 9A 
0B32FF A1   0006**M AND	C
0B3300 ED   0007**M OUT0	(reg), A
0B3301 39 
0B3302 9A 
0B3303 C1   0008**M POP	BC
             0081** RES_GPIO PB_DDR,  B
0B3304 C5   0001**M PUSH	BC
0B3305 78   0002**M LD	A, val
0B3306 2F   0003**M CPL
0B3307 4F   0004**M LD	C, A
0B3308 ED   0005**M IN0	A, (reg)
0B3309 38 
0B330A 9B 
0B330B A1   0006**M AND	C
0B330C ED   0007**M OUT0	(reg), A
0B330D 39 
0B330E 9B 
0B330F C1   0008**M POP	BC
             0082** SET_GPIO PB_ALT1, B
0B3310 ED   0001**M IN0	A, (reg)
0B3311 38 
0B3312 9C 
0B3313 B0   0002**M OR	val
0B3314 ED   0003**M OUT0	(reg), A
0B3315 39 
0B3316 9C 
             0083** SET_GPIO PB_ALT2, B
0B3317 ED   0001**M IN0	A, (reg)
0B3318 38 
0B3319 9D 
0B331A B0   0002**M OR	val
0B331B ED   0003**M OUT0	(reg), A
0B331C 39 
0B331D 9D 
0B331E C9    0084** RET
             0085** 
             0086** 
             0087** ; Interrupt, Active High
             0088** ;
             0089** GPIOB_M7:		SET_GPIO PB_DR,   B
0B331F ED   0001**M IN0	A, (reg)
0B3320 38 
0B3321 9A 
0B3322 B0   0002**M OR	val
0B3323 ED   0003**M OUT0	(reg), A
0B3324 39 
0B3325 9A 
             0090** RES_GPIO PB_DDR,  B
0B3326 C5   0001**M PUSH	BC
0B3327 78   0002**M LD	A, val
0B3328 2F   0003**M CPL
0B3329 4F   0004**M LD	C, A
0B332A ED   0005**M IN0	A, (reg)
0B332B 38 
0B332C 9B 
0B332D A1   0006**M AND	C
0B332E ED   0007**M OUT0	(reg), A
0B332F 39 
0B3330 9B 
0B3331 C1   0008**M POP	BC
             0091** SET_GPIO PB_ALT1, B
0B3332 ED   0001**M IN0	A, (reg)
0B3333 38 
0B3334 9C 
0B3335 B0   0002**M OR	val
0B3336 ED   0003**M OUT0	(reg), A
0B3337 39 
0B3338 9C 
             0092** SET_GPIO PB_ALT2, B
0B3339 ED   0001**M IN0	A, (reg)
0B333A 38 
0B333B 9D 
0B333C B0   0002**M OR	val
0B333D ED   0003**M OUT0	(reg), A
0B333E 39 
0B333F 9D 
0B3340 C9    0093** RET
             0094** 
             0095** 
             0096** ; Interrupt, Falling Edge
             0097** ;
             0098** GPIOB_M8:		RES_GPIO PB_DR,   B
0B3341 C5   0001**M PUSH	BC
0B3342 78   0002**M LD	A, val
0B3343 2F   0003**M CPL
0B3344 4F   0004**M LD	C, A
0B3345 ED   0005**M IN0	A, (reg)
0B3346 38 
0B3347 9A 
0B3348 A1   0006**M AND	C
0B3349 ED   0007**M OUT0	(reg), A
0B334A 39 
0B334B 9A 
0B334C C1   0008**M POP	BC
             0099** SET_GPIO PB_DDR,  B
0B334D ED   0001**M IN0	A, (reg)
0B334E 38 
0B334F 9B 
0B3350 B0   0002**M OR	val
0B3351 ED   0003**M OUT0	(reg), A
0B3352 39 
0B3353 9B 
             0100** SET_GPIO PB_ALT1, B
0B3354 ED   0001**M IN0	A, (reg)
0B3355 38 
0B3356 9C 
0B3357 B0   0002**M OR	val
0B3358 ED   0003**M OUT0	(reg), A
0B3359 39 
0B335A 9C 
             0101** SET_GPIO PB_ALT2, B
0B335B ED   0001**M IN0	A, (reg)
0B335C 38 
0B335D 9D 
0B335E B0   0002**M OR	val
0B335F ED   0003**M OUT0	(reg), A
0B3360 39 
0B3361 9D 
0B3362 C9    0102** RET
             0103** 
             0104** ; Interrupt, Rising Edge
             0105** ;
             0106** GPIOB_M9:		SET_GPIO PB_DR,   B
0B3363 ED   0001**M IN0	A, (reg)
0B3364 38 
0B3365 9A 
0B3366 B0   0002**M OR	val
0B3367 ED   0003**M OUT0	(reg), A
0B3368 39 
0B3369 9A 
             0107** SET_GPIO PB_DDR,  B
0B336A ED   0001**M IN0	A, (reg)
0B336B 38 
0B336C 9B 
0B336D B0   0002**M OR	val
0B336E ED   0003**M OUT0	(reg), A
0B336F 39 
0B3370 9B 
             0108** SET_GPIO PB_ALT1, B
0B3371 ED   0001**M IN0	A, (reg)
0B3372 38 
0B3373 9C 
0B3374 B0   0002**M OR	val
0B3375 ED   0003**M OUT0	(reg), A
0B3376 39 
0B3377 9C 
             0109** SET_GPIO PB_ALT2, B
0B3378 ED   0001**M IN0	A, (reg)
0B3379 38 
0B337A 9D 
0B337B B0   0002**M OR	val
0B337C ED   0003**M OUT0	(reg), A
0B337D 39 
0B337E 9D 
0B337F C9    0110** RET
              0009* include "basic/main.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Command, Error and Lexical Analysis Module - "MAIN"
             0004** ; Author:	(C) Copyright  R.T.Russell  1984
             0005** ; Modified By:	Dean Belfield
             0006** ; Created:	12/05/2023
             0007** ; Last Updated:	26/11/2023
             0008** ;
             0009** ; Modinfo:
             0010** ; 07/05/1984:	Version 2.3
             0011** ; 01/03/1987:	Version 3.0
             0012** ; 03/05/2022:	Modified by Dean Belfield
             0013** ; 06/06/2023:	Modified to run in ADL mode
             0014** ; 26/06/2023:	Fixed binary and unary indirection
             0015** ; 17/08/2023:	Added binary constants
             0016** ; 15/11/2023:	Fixed bug in ONEDIT1 for OSLOAD_TXT, Startup message now includes Agon version
             0017** ; 26/11/2023:	Fixed bug in AUTOLOAD
             0018** 
             0019** ; .ASSUME	ADL = 1
             0020** 
             0021** ; INCLUDE	"equs.inc"
             0022** 
             0023** ; SEGMENT CODE
             0024** 
             0025** ; XDEF	_basic_main
             0026** 
             0027** ; XDEF	COLD
             0028** ; XDEF	WARM
             0029** ; XDEF	CLOOP
             0030** ; XDEF	DELETE
             0031** ; XDEF	LIST_
             0032** ; XDEF	RENUM
             0033** ; XDEF	AUTO
             0034** ; XDEF	NEW
             0035** ; XDEF	OLD
             0036** ; XDEF	LOAD
             0037** ; XDEF	SAVE
             0038** ; XDEF	ERROR_
             0039** ; XDEF	EXTERR
             0040** ; XDEF	LOAD0
             0041** ; XDEF	CLEAR
             0042** ; XDEF	CRLF
             0043** ; XDEF	OUTCHR
             0044** ; XDEF	OUT_
             0045** ; XDEF	FINDL
             0046** ; XDEF	SETLIN
             0047** ; XDEF	PBCDL
             0048** ; XDEF	SAYLN
             0049** ; XDEF	PUTVAR
             0050** ; XDEF	GETVAR
             0051** ; XDEF	GETDEF
             0052** ; XDEF	CREATE
             0053** ; XDEF	RANGE
             0054** ; XDEF	LEXAN2
             0055** ; XDEF	REPORT
             0056** ; XDEF	TELL
             0057** ; XDEF	SPACE_
             0058** ; XDEF	KEYWDS
             0059** ; XDEF	KEYWDL
             0060** ; XDEF	ONEDIT
             0061** ; XDEF	ONEDIT1
             0062** ; XDEF	LISTIT
             0063** ; XDEF	CLEAN
             0064** 
             0065** ; XREF	LISTON
             0066** ; XREF	ERRTXT
             0067** ; XREF	OSINIT
             0068** ; XREF	HIMEM
             0069** ; XREF	PAGE_
             0070** ; XREF	CHAIN0
             0071** ; XREF	PROMPT
             0072** ; XREF	ERRTRP
             0073** ; XREF	ERRLIN
             0074** ; XREF	AUTONO
             0075** ; XREF	LINENO
             0076** ; XREF	INCREM
             0077** ; XREF	OSLINE
             0078** ; XREF	COUNT
             0079** ; XREF	NXT
             0080** ; XREF	BUFFER
             0081** ; XREF	XEQ
             0082** ; XREF	TOP
             0083** ; XREF	EXPRI
             0084** ; XREF	SEARCH
             0085** ; XREF	LTRAP
             0086** ; XREF	LOMEM
             0087** ; XREF	DECODE
             0088** ; XREF	EXPRS
             0089** ; XREF	OSSAVE
             0090** ; XREF	ERR
             0091** ; XREF	ERL
             0092** ; XREF	TRACEN
             0093** ; XREF	RESET
             0094** ; XREF	OSSHUT
             0095** ; XREF	OSLOAD
             0096** ; XREF	FREE
             0097** ; XREF	DYNVAR
             0098** ; XREF	FILL
             0099** ; XREF	OSWRCH
             0100** ; XREF	WIDTH
             0101** ; XREF	COMMA
             0102** ; XREF	MUL16
             0103** ; XREF	BRAKET
             0104** ; XREF	X4OR5
             0105** ; XREF	LOADN
             0106** ; XREF	SFIX
             0107** ; XREF	ITEMI
             0108** ; XREF	FNPTR
             0109** ; XREF	PROPTR
             0110** ; XREF	CHECK
             0111** ; XREF	TERMQ
             0112** ; XREF	OSWRCHCH
             0113** ; XREF	NEWIT
             0114** ; XREF	BAD
             0115** ; XREF	RAM_START
             0116** ; XREF	RAM_END
             0117** ; XREF	R0
             0118** ; XREF	STAR_VERSION
             0119** 
             0120** ; XREF	_basic_end			; In init.asm
             0121** ;
             0122** ; A handful of common token IDs
             0123** ;
             0124** TERROR_MN:			EQU     85H
             0125** LINE_MN_:			EQU     86H
             0126** ELSE_MN_:			EQU     8BH
             0127** THEN_MN_:			EQU     8CH
             0128** LINO_MN:			EQU     8DH
             0129** FN:			EQU     A4H
             0130** TO_MN:			EQU     B8H
             0131** REN:			EQU     CCH
             0132** DATA_MN_:			EQU     DCH
             0133** DIM:			EQU     DEH
             0134** FOR:			EQU     E3H
             0135** GOSUB:			EQU     E4H
             0136** GOTO:			EQU     E5H
             0137** TIF:			EQU     E7H
             0138** LOCAL_:			EQU     EAH
             0139** NEXT:			EQU     EDH
             0140** ON_:			EQU     EEH
             0141** PROC:			EQU     F2H
             0142** REM:			EQU     F4H
             0143** REPEAT:			EQU     F5H
             0144** RESTOR:			EQU     F7H
             0145** TRACE:			EQU     FCH
             0146** UNTIL:			EQU     FDH
             0147** ;
             0148** ; This defines the block of tokens that are pseudo-variables.
             0149** ; There are two versions of each token, a GET and a SET
             0150** 
             0151** ; Name  : GET : SET
             0152** ; ------:-----:----
             0153** ; PTR   : 8Fh : CFh
             0154** ; PAGE  : 90h : D0h
             0155** ; TIME  : 91h : D1h
             0156** ; LOMEM : 92h : D2h
             0157** ; HIMEM : 93h : D3h
             0158** ;
             0159** ; Examples:
             0160** ;   LET A% = PAGE : REM This is the GET version
             0161** ;   PAGE = 40000  : REM This is the SET version
             0162** ;
             0163** TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
             0164** TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
             0165** OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
             0166** 
             0167** ; The main routine
             0168** ; IXU: argv - pointer to array of parameters
             0169** ;   C: argc - number of parameters
             0170** ; Returns:
             0171** ;  HL: Error code, or 0 if OK
             0172** ;
0B3380 21    0173** _basic_main:			LD	HL, ACCS		; Clear the ACCS
0B3381 00 
0B3382 4E 
0B3383 0B 
0B3384 36    0174** LD	(HL), 0
0B3385 00 
0B3386 79    0175** LD	A, C
0B3387 FE    0176** CP	2
0B3388 02 
0B3389 28    0177** JR	Z, AUTOLOAD		; 2 parameters = autoload
0B338A 2D 
0B338B 38    0178** JR	C, COLD			; 1 parameter = normal start
0B338C 3F 
0B338D CD    0179** CALL	STAR_VERSION
0B338E 02 
0B338F 44 
0B3390 0B 
0B3391 CD    0180** CALL	TELL
0B3392 5A 
0B3393 41 
0B3394 0B 
0B3395 55    0181** DB	"Usage:\n\r"
0B3396 73 
0B3397 61 
0B3398 67 
0B3398 65   
0B3399 3A 
0B339A 0A 
0B339B 0D 
0B339D 52    0182** DB	"RUN . <filename>\n\r", 0
0B339E 55 
0B339F 4E 
0B33A0 20 
0B33A0 2E   
0B33A1 20 
0B33A2 3C 
0B33A3 66 
0B33A3 69   
0B33A4 6C 
0B33A5 65 
0B33A6 6E 
0B33A6 61   
0B33A7 6D 
0B33A8 65 
0B33A9 3E 
0B33A9 0A   
0B33AA 0D 
0B33AB 00 
0B33B0 21    0183** LD	HL, 0			; The error code
0B33B1 00 
0B33B2 00 
0B33B3 00 
0B33B4 C3    0184** JP	_basic_end
0B33B5 D1 
0B33B6 03 
0B33B7 0B 
             0185** ;
0B33B8 DD    0186** AUTOLOAD:		LD	HL, (IX+3)		; HLU: Address of filename
0B33B9 27 
0B33BA 03 
0B33BB 11    0187** LD	DE, ACCS		;  DE: Destination address
0B33BC 00 
0B33BD 4E 
0B33BE 0B 
0B33BF 7E    0188** AUTOLOAD_1:		LD	A, (HL)			; Fetch the filename byte
0B33C0 12    0189** LD	(DE), A			;
0B33C1 23    0190** INC	HL			; Increase the source pointer
0B33C2 1C    0191** INC	E			; We only need to increase E as ACCS is on a page boundary
0B33C3 28    0192** JR	Z, AUTOLOAD_2		; End if we hit the page boundary
0B33C4 03 
0B33C5 B7    0193** OR	A
0B33C6 20    0194** JR	NZ, AUTOLOAD_1		; Loop until we hit a 0 byte
0B33C7 F7 
0B33C8 1D    0195** AUTOLOAD_2:		DEC	E
0B33C9 3E    0196** LD	A, CR
0B33CA 0D 
0B33CB 12    0197** LD	(DE), A			; Replace the 0 byte with a CR for BBC BASIC
             0198** ;
0B33CC E1    0199** COLD:			POP	HL			; Pop the return address to init off SPS
0B33CD E5    0200** PUSH	HL 			; Stack it on SPL (*BYE will use this as the return address)
0B33CE 21    0201** LD	HL, STAVAR		; Cold start
0B33CF 00 
0B33D0 50 
0B33D1 0B 
0B33D2 F9    0202** LD	SP, HL
0B33D3 36    0203** LD	(HL), 10
0B33D4 0A 
0B33D5 23    0204** INC	HL
0B33D6 36    0205** LD	(HL),9
0B33D7 09 
0B33D8 CD    0206** CALL    OSINIT			; Call the machine specific OS initialisation routines
0B33D9 4B 
0B33DA 43 
0B33DB 0B 
0B33DC ED    0207** LD      (HIMEM),DE		; This returns HIMEM (ramtop) in DE - store in the HIMEM sysvar
0B33DD 53 
0B33DE 20 
0B33DF 51 
0B33DF 0B   
0B33E1 22    0208** LD      (PAGE_),HL		; And PAGE in HL (where BASIC program storage starts) - store in PAGE sysvar
0B33E2 14 
0B33E3 51 
0B33E4 0B 
0B33E5 3E    0209** LD      A,B7H           	; Set LISTO sysvar; the bottom nibble is LISTO (7), top nibble is OPT (B)
0B33E6 B7 
0B33E7 32    0210** LD      (LISTON),A
0B33E8 40 
0B33E9 51 
0B33EA 0B 
0B33EB 21    0211** LD      HL,NOTICE
0B33EC 26 
0B33ED 34 
0B33EE 0B 
0B33EF 22    0212** LD      (ERRTXT),HL
0B33F0 2F 
0B33F1 51 
0B33F2 0B 
0B33F3 CD    0213** CALL    NEWIT			; From what I can determine, NEWIT always returns with Z flag set
0B33F4 36 
0B33F5 3C 
0B33F6 0B 
0B33F7 3A    0214** LD	A,(ACCS)		; Check if there is a filename in ACCS
0B33F8 00 
0B33F9 4E 
0B33FA 0B 
0B33FB B7    0215** OR	A
0B33FC C2    0216** JP	NZ,CHAIN0		; Yes, so load and run
0B33FD 1D 
0B33FE 0F 
0B33FF 0B 
0B3400 CD    0217** CALL	STAR_VERSION		;
0B3401 02 
0B3402 44 
0B3403 0B 
0B3404 CD    0218** CALL    TELL			; Output the welcome message
0B3405 5A 
0B3406 41 
0B3407 0B 
0B3408 42    0219** DB    	"BBC BASIC (Z80) Version 3.00\n\r"
0B3409 42 
0B340A 43 
0B340B 20 
0B340B 42   
0B340C 41 
0B340D 53 
0B340E 49 
0B340E 43   
0B340F 20 
0B3410 28 
0B3411 5A 
0B3411 38   
0B3412 30 
0B3413 29 
0B3414 20 
0B3414 56   
0B3415 65 
0B3416 72 
0B3417 73 
0B3417 69   
0B3418 6F 
0B3419 6E 
0B341A 20 
0B341A 33   
0B341B 2E 
0B341C 30 
0B341D 30 
0B341D 0A   
0B341E 0D 
0B3426 28    0220** NOTICE:			DB    	"(C) Copyright R.T.Russell 1987\n\r"
0B3427 43 
0B3428 29 
0B3429 20 
0B3429 43   
0B342A 6F 
0B342B 70 
0B342C 79 
0B342C 72   
0B342D 69 
0B342E 67 
0B342F 68 
0B342F 74   
0B3430 20 
0B3431 52 
0B3432 2E 
0B3432 54   
0B3433 2E 
0B3434 52 
0B3435 75 
0B3435 73   
0B3436 73 
0B3437 65 
0B3438 6C 
0B3438 6C   
0B3439 20 
0B343A 31 
0B343B 39 
0B343B 38   
0B343C 37 
0B343D 0A 
0B343E 0D 
0B3446 0A    0221** DB	"\n\r", 0
0B3447 0D 
0B3448 00 
             0222** ;
0B3449 F6    0223** WARM:			DB 	F6H			; Opcode for OR? Maybe to CCF (the following SCF will be the operand)
             0224** ;
             0225** ; This is the main entry point for BASIC
             0226** ;
0B344A 37    0227** CLOOP:			SCF				; See above - not sure why this is here!
0B344B ED    0228** LD      SP,(HIMEM)
0B344C 7B 
0B344D 20 
0B344E 51 
0B344E 0B   
0B3450 CD    0229** CALL    PROMPT          	; Prompt user
0B3451 C4 
0B3452 42 
0B3453 0B 
0B3454 21    0230** LD      HL,LISTON		; Pointer to the LISTO/OPT sysvar
0B3455 40 
0B3456 51 
0B3457 0B 
0B3458 7E    0231** LD      A,(HL)			; Fetch the value
0B3459 E6    0232** AND     0FH             	; Bottom nibble: LISTO
0B345A 0F 
0B345B F6    0233** OR      B0H             	; Top nibble: Default to OPT (3) with ADL mode bit set to 1 for assembler
0B345C B0 
0B345D 77    0234** LD      (HL),A			; Store back in
0B345E ED    0235** SBC     HL,HL           	; HL: 0
0B345F 62 
0B3460 22    0236** LD      (ERRTRP),HL		; Clear ERRTRP sysvar
0B3461 2C 
0B3462 51 
0B3463 0B 
0B3464 22    0237** LD      (ERRLIN),HL		; Clear ERRLIN sysvar (ON ERROR)
0B3465 35 
0B3466 51 
0B3467 0B 
             0238** ;
0B3468 2A    0239** LD      HL,(AUTONO)		; Get the auto line number
0B3469 29 
0B346A 51 
0B346B 0B 
0B346C 22    0240** LD      (LINENO),HL		; Store in line number
0B346D 23 
0B346E 51 
0B346F 0B 
0B3470 7C    0241** LD      A,H			; If the auto line number is zero then
0B3471 B5    0242** OR      L
0B3472 28    0243** JR      Z,NOAUTO		; We're not auto line numbering, so skip the next bit
0B3473 1E 
             0244** ;
             0245** ; This section handles auto line numbering
             0246** ;
0B3474 E5    0247** PUSH    HL			; Stack the line number
0B3475 CD    0248** CALL    PBCD           	 	; Output the line number
0B3476 C5 
0B3477 3D 
0B3478 0B 
0B3479 E1    0249** POP     HL			; Pop the line number back off the stack
             0250** ;			LD      BC,(INCREM)		; Load BC with Increment - but INCREM is just a byte; C is the value
             0251** ;			LD      B,0			; So clear B
0B347A 01    0252** LD	BC, 0			; Load BC with Increment
0B347B 00 
0B347C 00 
0B347D 00 
0B347E 3A    0253** LD	A,(INCREM)
0B347F 41 
0B3480 51 
0B3481 0B 
0B3482 4F    0254** LD	C, A
0B3483 09    0255** ADD     HL,BC			; Add the increment to the line number
0B3484 DA    0256** JP      C,TOOBIG		; And error if we wrap
0B3485 EF 
0B3486 3F 
0B3487 0B 
0B3488 22    0257** LD      (AUTONO),HL		; Store the new auto line number
0B3489 29 
0B348A 51 
0B348B 0B 
0B348C 3E    0258** LD      A,' '			; Print a space
0B348D 20 
0B348E CD    0259** CALL    OUTCHR
0B348F 19 
0B3490 3D 
0B3491 0B 
             0260** ;
             0261** ; This section invokes the line editor
             0262** ;
0B3492 21    0263** NOAUTO:			LD      HL,ACCS			; Storage for the line editor (256 bytes)
0B3493 00 
0B3494 4E 
0B3495 0B 
0B3496 CD    0264** CALL    OSLINE          	; Call the line editor in MOS
0B3497 29 
0B3498 42 
0B3499 0B 
0B349A CD    0265** ONEDIT:			CALL	ONEDIT1			; Enter the line into memory
0B349B A6 
0B349C 34 
0B349D 0B 
0B349E DC    0266** CALL    C,CLEAN			; Set TOP, write out &FFFF end of program marker
0B349F 09 
0B34A0 3C 
0B34A1 0B 
0B34A2 C3    0267** JP      CLOOP			; Jump back to immediate mode
0B34A3 4A 
0B34A4 34 
0B34A5 0B 
             0268** ;
             0269** ; This bit enters the line into memory
             0270** ; Also called from OSLOAD_TXT
             0271** ; Returns:
             0272** ; F: C if a new line has been entered (CLEAN will need to be called)
             0273** ;
0B34A6 AF    0274** ONEDIT1:		XOR     A			; Entry point after *EDIT
0B34A7 32    0275** LD      (COUNT),A
0B34A8 3D 
0B34A9 51 
0B34AA 0B 
0B34AB FD    0276** LD      IY,ACCS
0B34AC 21 
0B34AD 00 
0B34AE 4E 
0B34AE 0B   
0B34B0 CD    0277** CALL    LINNUM			; HL: The line number from the input buffer
0B34B1 C3 
0B34B2 3F 
0B34B3 0B 
0B34B4 CD    0278** CALL    NXT			; Skip spaces
0B34B5 3A 
0B34B6 0E 
0B34B7 0B 
0B34B8 7C    0279** LD      A,H			; HL: The line number will be 0 for immediate mode or when auto line numbering is used
0B34B9 B5    0280** OR      L
0B34BA 28    0281** JR      Z,LNZERO        	; Skip if there is no line number in the input buffer
0B34BB 04 
0B34BC 22    0282** LD      (LINENO),HL		; Otherwise store it
0B34BD 23 
0B34BE 51 
0B34BF 0B 
             0283** ;
             0284** ; This bit does the lexical analysis and tokenisation
             0285** ;
0B34C0 0E    0286** LNZERO:			LD	C,1			; Left mode
0B34C1 01 
0B34C2 11    0287** LD      DE,BUFFER		; Buffer for tokenised BASIC
0B34C3 00 
0B34C4 4F 
0B34C5 0B 
0B34C6 CD    0288** CALL    LEXAN2          	; Lexical analysis on the user input
0B34C7 69 
0B34C8 40 
0B34C9 0B 
0B34CA 12    0289** LD      (DE),A          	; Terminator
0B34CB AF    0290** XOR     A
             0291** ;			LD      B,A
             0292** ;			LD      C,E             	; BC: Line length
0B34CC 01    0293** LD	BC,0
0B34CD 00 
0B34CE 00 
0B34CF 00 
0B34D0 4B    0294** LD	C,E			; BC: Line length
0B34D1 13    0295** INC     DE
0B34D2 12    0296** LD      (DE),A          	; Zero next
0B34D3 2A    0297** LD      HL,(LINENO)		; Get the line number
0B34D4 23 
0B34D5 51 
0B34D6 0B 
0B34D7 7C    0298** LD      A,H			; Is it zero, i.e. a command with no line number?
0B34D8 B5    0299** OR      L
0B34D9 FD    0300** LD      IY,BUFFER       	; Yes, so we're in immediate mode
0B34DA 21 
0B34DB 00 
0B34DC 4F 
0B34DC 0B   
0B34DE CA    0301** JP      Z,XEQ           	; Execute it
0B34DF 60 
0B34E0 0F 
0B34E1 0B 
             0302** ;
             0303** ; This section stores the BASIC line in memory
             0304** ;
0B34E2 C5    0305** PUSH    BC
0B34E3 E5    0306** PUSH    HL
0B34E4 CD    0307** CALL    SETTOP          	; Set TOP sysvar
0B34E5 15 
0B34E6 3C 
0B34E7 0B 
0B34E8 E1    0308** POP     HL
0B34E9 CD    0309** CALL    FINDL			; Find the address of the line
0B34EA 59 
0B34EB 3D 
0B34EC 0B 
0B34ED CC    0310** CALL    Z,DEL			; Delete the existing line if found
0B34EE CC 
0B34EF 3B 
0B34F0 0B 
0B34F1 C1    0311** POP     BC
0B34F2 79    0312** LD      A,C			; Check for the line length being zero, i.e.
0B34F3 B7    0313** OR      A			; the user has just entered a line number in the command line
0B34F4 C8    0314** RET	Z 	         	; If so, then don't do anything else
0B34F5 C6    0315** ADD     A,4
0B34F6 04 
0B34F7 4F    0316** LD      C,A             	; Length inclusive
0B34F8 D5    0317** PUSH    DE              	; DE: Line number (fetched from the call to FINDL)
0B34F9 C5    0318** PUSH    BC              	; BC: Line length
0B34FA EB    0319** EX      DE,HL			; DE: Address of the line in memory
0B34FB 2A    0320** LD      HL,(TOP)		; HL: TOP (the first free location after the end of the BASIC program)
0B34FC 17 
0B34FD 51 
0B34FE 0B 
0B34FF E5    0321** PUSH    HL			; Stack TOP (current TOP value)
0B3500 09    0322** ADD     HL,BC			; Add the line length to HL, the new TOP value
0B3501 E5    0323** PUSH    HL			; Stack HL (new TOP value)
0B3502 24    0324** INC     H			; Add 256 to HL
0B3503 AF    0325** XOR     A
0B3504 ED    0326** SBC     HL,SP			; Check whether HL is in the same page as the current stack pointer
0B3505 72 
0B3506 E1    0327** POP     HL			; Pop HL (new TOP value)
0B3507 D2    0328** JP      NC,ERROR_        	; If HL is in the stack page, then error: "No room"
0B3508 2A 
0B3509 3B 
0B350A 0B 
0B350B 22    0329** LD      (TOP),HL		; Store new value of TOP
0B350C 17 
0B350D 51 
0B350E 0B 
0B350F E3    0330** EX      (SP),HL			; HL: TOP (current TOP value), top of stack now contains new TOP value
0B3510 E5    0331** PUSH    HL			; PUSH current TOP value
0B3511 23    0332** INC     HL
0B3512 B7    0333** OR      A
0B3513 ED    0334** SBC     HL,DE			; DE: Address of the line in memory
0B3514 52 
0B3515 44    0335** LD      B,H             	; BC: Amount to move
0B3516 4D    0336** LD      C,L
0B3517 E1    0337** POP     HL			; HL: Destination (current TOP value)
0B3518 D1    0338** POP     DE			; DE: Source (new TOP value)
0B3519 28    0339** JR      Z,ATEND			; If current TOP and new TOP are the same, i.e. adding a line at the end, then skip...
0B351A 02 
0B351B ED    0340** LDDR                    	; Otherwise, make space for the new line in the program
0B351C B8 
0B351D C1    0341** ATEND:			POP     BC              	; BC: Line length
0B351E D1    0342** POP     DE              	; DE: Line number
0B351F 23    0343** INC     HL			; HL: Destination address
0B3520 71    0344** LD      (HL),C          	; Store length
0B3521 23    0345** INC     HL
0B3522 73    0346** LD      (HL),E          	; Store line number
0B3523 23    0347** INC     HL
0B3524 72    0348** LD      (HL),D
0B3525 23    0349** INC     HL
0B3526 11    0350** LD      DE,BUFFER		; DE: Location of the new, tokenised line
0B3527 00 
0B3528 4F 
0B3529 0B 
0B352A EB    0351** EX      DE,HL			; HL: Location of the new, tokensied line, DE: Destination address in BASIC program
0B352B 0D    0352** DEC     C			; Subtract 3 from the number of bytes to copy to
0B352C 0D    0353** DEC     C			; compensate for the 3 bytes stored above (length and line number)
0B352D 0D    0354** DEC     C
0B352E ED    0355** LDIR                    	; Add the line to the BASIC program
0B352F B0 
0B3530 37    0356** SCF				; To flag we need to call CLEAN
0B3531 C9    0357** RET
             0358** ;
             0359** ; List of tokens and keywords. If a keyword is followed by 0 then
             0360** ; it will only match with the keyword followed immediately by
             0361** ; a delimiter
             0362** ;
0B3532 80    0363** KEYWDS:			DB    80H, "AND"
0B3533 41 
0B3534 4E 
0B3535 44 
0B3536 94    0364** DB    94H, "ABS"
0B3537 41 
0B3538 42 
0B3539 53 
0B353A 95    0365** DB    95H, "ACS"
0B353B 41 
0B353C 43 
0B353D 53 
0B353E 96    0366** DB    96H, "ADVAL"
0B353F 41 
0B3540 44 
0B3541 56 
0B3541 41   
0B3542 4C 
0B3544 97    0367** DB    97H, "ASC"
0B3545 41 
0B3546 53 
0B3547 43 
0B3548 98    0368** DB    98H, "ASN"
0B3549 41 
0B354A 53 
0B354B 4E 
0B354C 99    0369** DB    99H, "ATN"
0B354D 41 
0B354E 54 
0B354F 4E 
0B3550 C6    0370** DB    C6H, "AUTO"
0B3551 41 
0B3552 55 
0B3553 54 
0B3553 4F   
0B3555 9A    0371** DB    9AH, "BGET", 0
0B3556 42 
0B3557 47 
0B3558 45 
0B3558 54   
0B3559 00 
0B355B D5    0372** DB    D5H, "BPUT", 0
0B355C 42 
0B355D 50 
0B355E 55 
0B355E 54   
0B355F 00 
0B3561 FB    0373** DB    FBH, "COLOUR"
0B3562 43 
0B3563 4F 
0B3564 4C 
0B3564 4F   
0B3565 55 
0B3566 52 
0B3568 FB    0374** DB    FBH, "COLOR"
0B3569 43 
0B356A 4F 
0B356B 4C 
0B356B 4F   
0B356C 52 
0B356E D6    0375** DB    D6H, "CALL"
0B356F 43 
0B3570 41 
0B3571 4C 
0B3571 4C   
0B3573 D7    0376** DB    D7H, "CHAIN"
0B3574 43 
0B3575 48 
0B3576 41 
0B3576 49   
0B3577 4E 
0B3579 BD    0377** DB    BDH, "CHR$"
0B357A 43 
0B357B 48 
0B357C 52 
0B357C 24   
0B357E D8    0378** DB    D8H, "CLEAR", 0
0B357F 43 
0B3580 4C 
0B3581 45 
0B3581 41   
0B3582 52 
0B3583 00 
0B3585 D9    0379** DB    D9H, "CLOSE", 0
0B3586 43 
0B3587 4C 
0B3588 4F 
0B3588 53   
0B3589 45 
0B358A 00 
0B358C DA    0380** DB    DAH, "CLG", 0
0B358D 43 
0B358E 4C 
0B358F 47 
0B358F 00   
0B3591 DB    0381** DB    DBH, "CLS", 0
0B3592 43 
0B3593 4C 
0B3594 53 
0B3594 00   
0B3596 9B    0382** DB    9BH, "COS"
0B3597 43 
0B3598 4F 
0B3599 53 
0B359A 9C    0383** DB    9CH, "COUNT", 0
0B359B 43 
0B359C 4F 
0B359D 55 
0B359D 4E   
0B359E 54 
0B359F 00 
0B35A1 DC    0384** DB    DCH, "DATA"
0B35A2 44 
0B35A3 41 
0B35A4 54 
0B35A4 41   
0B35A6 9D    0385** DB    9DH, "DEG"
0B35A7 44 
0B35A8 45 
0B35A9 47 
0B35AA DD    0386** DB    DDH, "DEF"
0B35AB 44 
0B35AC 45 
0B35AD 46 
0B35AE C7    0387** DB    C7H, "DELETE"
0B35AF 44 
0B35B0 45 
0B35B1 4C 
0B35B1 45   
0B35B2 54 
0B35B3 45 
0B35B5 81    0388** DB    81H, "DIV"
0B35B6 44 
0B35B7 49 
0B35B8 56 
0B35B9 DE    0389** DB    DEH, "DIM"
0B35BA 44 
0B35BB 49 
0B35BC 4D 
0B35BD DF    0390** DB    DFH, "DRAW"
0B35BE 44 
0B35BF 52 
0B35C0 41 
0B35C0 57   
0B35C2 E1    0391** DB    E1H, "ENDPROC", 0
0B35C3 45 
0B35C4 4E 
0B35C5 44 
0B35C5 50   
0B35C6 52 
0B35C7 4F 
0B35C8 43 
0B35C8 00   
0B35CB E0    0392** DB    E0H, "END", 0
0B35CC 45 
0B35CD 4E 
0B35CE 44 
0B35CE 00   
0B35D0 E2    0393** DB    E2H, "ENVELOPE"
0B35D1 45 
0B35D2 4E 
0B35D3 56 
0B35D3 45   
0B35D4 4C 
0B35D5 4F 
0B35D6 50 
0B35D6 45   
0B35D9 8B    0394** DB    8BH, "ELSE"
0B35DA 45 
0B35DB 4C 
0B35DC 53 
0B35DC 45   
0B35DE A0    0395** DB    A0H, "EVAL"
0B35DF 45 
0B35E0 56 
0B35E1 41 
0B35E1 4C   
0B35E3 9E    0396** DB    9EH, "ERL", 0
0B35E4 45 
0B35E5 52 
0B35E6 4C 
0B35E6 00   
0B35E8 85    0397** DB    85H, "ERROR"
0B35E9 45 
0B35EA 52 
0B35EB 52 
0B35EB 4F   
0B35EC 52 
0B35EE C5    0398** DB    C5H, "EOF", 0
0B35EF 45 
0B35F0 4F 
0B35F1 46 
0B35F1 00   
0B35F3 82    0399** DB    82H, "EOR"
0B35F4 45 
0B35F5 4F 
0B35F6 52 
0B35F7 9F    0400** DB    9FH, "ERR", 0
0B35F8 45 
0B35F9 52 
0B35FA 52 
0B35FA 00   
0B35FC A1    0401** DB    A1H, "EXP"
0B35FD 45 
0B35FE 58 
0B35FF 50 
0B3600 A2    0402** DB    A2H, "EXT", 0
0B3601 45 
0B3602 58 
0B3603 54 
0B3603 00   
0B3605 E3    0403** DB    E3H, "FOR"
0B3606 46 
0B3607 4F 
0B3608 52 
0B3609 A3    0404** DB    A3H, "FALSE", 0
0B360A 46 
0B360B 41 
0B360C 4C 
0B360C 53   
0B360D 45 
0B360E 00 
0B3610 A4    0405** DB    A4H, "FN"
0B3611 46 
0B3612 4E 
0B3613 E5    0406** DB    E5H, "GOTO"
0B3614 47 
0B3615 4F 
0B3616 54 
0B3616 4F   
0B3618 BE    0407** DB    BEH, "GET$"
0B3619 47 
0B361A 45 
0B361B 54 
0B361B 24   
0B361D A5    0408** DB    A5H, "GET"
0B361E 47 
0B361F 45 
0B3620 54 
0B3621 E4    0409** DB    E4H, "GOSUB"
0B3622 47 
0B3623 4F 
0B3624 53 
0B3624 55   
0B3625 42 
0B3627 E6    0410** DB    E6H, "GCOL"
0B3628 47 
0B3629 43 
0B362A 4F 
0B362A 4C   
0B362C 93    0411** DB    93H, "HIMEM", 0
0B362D 48 
0B362E 49 
0B362F 4D 
0B362F 45   
0B3630 4D 
0B3631 00 
0B3633 E8    0412** DB    E8H, "INPUT"
0B3634 49 
0B3635 4E 
0B3636 50 
0B3636 55   
0B3637 54 
0B3639 E7    0413** DB    E7H, "IF"
0B363A 49 
0B363B 46 
0B363C BF    0414** DB    BFH, "INKEY$"
0B363D 49 
0B363E 4E 
0B363F 4B 
0B363F 45   
0B3640 59 
0B3641 24 
0B3643 A6    0415** DB    A6H, "INKEY"
0B3644 49 
0B3645 4E 
0B3646 4B 
0B3646 45   
0B3647 59 
0B3649 A8    0416** DB    A8H, "INT"
0B364A 49 
0B364B 4E 
0B364C 54 
0B364D A7    0417** DB    A7H, "INSTR("
0B364E 49 
0B364F 4E 
0B3650 53 
0B3650 54   
0B3651 52 
0B3652 28 
0B3654 C9    0418** DB    C9H, "LIST"
0B3655 4C 
0B3656 49 
0B3657 53 
0B3657 54   
0B3659 86    0419** DB    86H, "LINE"
0B365A 4C 
0B365B 49 
0B365C 4E 
0B365C 45   
0B365E C8    0420** DB    C8H, "LOAD"
0B365F 4C 
0B3660 4F 
0B3661 41 
0B3661 44   
0B3663 92    0421** DB    92H, "LOMEM", 0
0B3664 4C 
0B3665 4F 
0B3666 4D 
0B3666 45   
0B3667 4D 
0B3668 00 
0B366A EA    0422** DB    EAH, "LOCAL"
0B366B 4C 
0B366C 4F 
0B366D 43 
0B366D 41   
0B366E 4C 
0B3670 C0    0423** DB    C0H, "LEFT$("
0B3671 4C 
0B3672 45 
0B3673 46 
0B3673 54   
0B3674 24 
0B3675 28 
0B3677 A9    0424** DB    A9H, "LEN"
0B3678 4C 
0B3679 45 
0B367A 4E 
0B367B E9    0425** DB    E9H, "LET"
0B367C 4C 
0B367D 45 
0B367E 54 
0B367F AB    0426** DB    ABH, "LOG"
0B3680 4C 
0B3681 4F 
0B3682 47 
0B3683 AA    0427** DB    AAH, "LN"
0B3684 4C 
0B3685 4E 
0B3686 C1    0428** DB    C1H, "MID$("
0B3687 4D 
0B3688 49 
0B3689 44 
0B3689 24   
0B368A 28 
0B368C EB    0429** DB    EBH, "MODE"
0B368D 4D 
0B368E 4F 
0B368F 44 
0B368F 45   
0B3691 83    0430** DB    83H, "MOD"
0B3692 4D 
0B3693 4F 
0B3694 44 
0B3695 EC    0431** DB    ECH, "MOVE"
0B3696 4D 
0B3697 4F 
0B3698 56 
0B3698 45   
0B369A ED    0432** DB    EDH, "NEXT"
0B369B 4E 
0B369C 45 
0B369D 58 
0B369D 54   
0B369F CA    0433** DB    CAH, "NEW", 0
0B36A0 4E 
0B36A1 45 
0B36A2 57 
0B36A2 00   
0B36A4 AC    0434** DB    ACH, "NOT"
0B36A5 4E 
0B36A6 4F 
0B36A7 54 
0B36A8 CB    0435** DB    CBH, "OLD", 0
0B36A9 4F 
0B36AA 4C 
0B36AB 44 
0B36AB 00   
0B36AD EE    0436** DB    EEH, "ON"
0B36AE 4F 
0B36AF 4E 
0B36B0 87    0437** DB    87H, "OFF"
0B36B1 4F 
0B36B2 46 
0B36B3 46 
0B36B4 84    0438** DB    84H, "OR"
0B36B5 4F 
0B36B6 52 
0B36B7 8E    0439** DB    8EH, "OPENIN"
0B36B8 4F 
0B36B9 50 
0B36BA 45 
0B36BA 4E   
0B36BB 49 
0B36BC 4E 
0B36BE AE    0440** DB    AEH, "OPENOUT"
0B36BF 4F 
0B36C0 50 
0B36C1 45 
0B36C1 4E   
0B36C2 4F 
0B36C3 55 
0B36C4 54 
0B36C6 AD    0441** DB    ADH, "OPENUP"
0B36C7 4F 
0B36C8 50 
0B36C9 45 
0B36C9 4E   
0B36CA 55 
0B36CB 50 
0B36CD FF    0442** DB    FFH, "OSCLI"
0B36CE 4F 
0B36CF 53 
0B36D0 43 
0B36D0 4C   
0B36D1 49 
0B36D3 F1    0443** DB    F1H, "PRINT"
0B36D4 50 
0B36D5 52 
0B36D6 49 
0B36D6 4E   
0B36D7 54 
0B36D9 90    0444** DB    90H, "PAGE", 0
0B36DA 50 
0B36DB 41 
0B36DC 47 
0B36DC 45   
0B36DD 00 
0B36DF 8F    0445** DB    8FH, "PTR", 0
0B36E0 50 
0B36E1 54 
0B36E2 52 
0B36E2 00   
0B36E4 AF    0446** DB    AFH, "PI", 0
0B36E5 50 
0B36E6 49 
0B36E7 00 
0B36E8 F0    0447** DB    F0H, "PLOT"
0B36E9 50 
0B36EA 4C 
0B36EB 4F 
0B36EB 54   
0B36ED B0    0448** DB    B0H, "POINT("
0B36EE 50 
0B36EF 4F 
0B36F0 49 
0B36F0 4E   
0B36F1 54 
0B36F2 28 
0B36F4 F2    0449** DB    F2H, "PROC"
0B36F5 50 
0B36F6 52 
0B36F7 4F 
0B36F7 43   
0B36F9 B1    0450** DB    B1H, "POS", 0
0B36FA 50 
0B36FB 4F 
0B36FC 53 
0B36FC 00   
0B36FE CE    0451** DB    CEH, "PUT"
0B36FF 50 
0B3700 55 
0B3701 54 
0B3702 F8    0452** DB    F8H, "RETURN", 0
0B3703 52 
0B3704 45 
0B3705 54 
0B3705 55   
0B3706 52 
0B3707 4E 
0B3708 00 
0B370A F5    0453** DB    F5H, "REPEAT"
0B370B 52 
0B370C 45 
0B370D 50 
0B370D 45   
0B370E 41 
0B370F 54 
0B3711 F6    0454** DB    F6H, "REPORT", 0
0B3712 52 
0B3713 45 
0B3714 50 
0B3714 4F   
0B3715 52 
0B3716 54 
0B3717 00 
0B3719 F3    0455** DB    F3H, "READ"
0B371A 52 
0B371B 45 
0B371C 41 
0B371C 44   
0B371E F4    0456** DB    F4H, "REM"
0B371F 52 
0B3720 45 
0B3721 4D 
0B3722 F9    0457** DB    F9H, "RUN", 0
0B3723 52 
0B3724 55 
0B3725 4E 
0B3725 00   
0B3727 B2    0458** DB    B2H, "RAD"
0B3728 52 
0B3729 41 
0B372A 44 
0B372B F7    0459** DB    F7H, "RESTORE"
0B372C 52 
0B372D 45 
0B372E 53 
0B372E 54   
0B372F 4F 
0B3730 52 
0B3731 45 
0B3733 C2    0460** DB    C2H, "RIGHT$("
0B3734 52 
0B3735 49 
0B3736 47 
0B3736 48   
0B3737 54 
0B3738 24 
0B3739 28 
0B373B B3    0461** DB    B3H, "RND", 0
0B373C 52 
0B373D 4E 
0B373E 44 
0B373E 00   
0B3740 CC    0462** DB    CCH, "RENUMBER"
0B3741 52 
0B3742 45 
0B3743 4E 
0B3743 55   
0B3744 4D 
0B3745 42 
0B3746 45 
0B3746 52   
0B3749 88    0463** DB    88H, "STEP"
0B374A 53 
0B374B 54 
0B374C 45 
0B374C 50   
0B374E CD    0464** DB    CDH, "SAVE"
0B374F 53 
0B3750 41 
0B3751 56 
0B3751 45   
0B3753 B4    0465** DB    B4H, "SGN"
0B3754 53 
0B3755 47 
0B3756 4E 
0B3757 B5    0466** DB    B5H, "SIN"
0B3758 53 
0B3759 49 
0B375A 4E 
0B375B B6    0467** DB    B6H, "SQR"
0B375C 53 
0B375D 51 
0B375E 52 
0B375F 89    0468** DB    89H, "SPC"
0B3760 53 
0B3761 50 
0B3762 43 
0B3763 C3    0469** DB    C3H, "STR$"
0B3764 53 
0B3765 54 
0B3766 52 
0B3766 24   
0B3768 C4    0470** DB    C4H, "STRING$("
0B3769 53 
0B376A 54 
0B376B 52 
0B376B 49   
0B376C 4E 
0B376D 47 
0B376E 24 
0B376E 28   
0B3771 D4    0471** DB    D4H, "SOUND"
0B3772 53 
0B3773 4F 
0B3774 55 
0B3774 4E   
0B3775 44 
0B3777 FA    0472** DB    FAH, "STOP", 0
0B3778 53 
0B3779 54 
0B377A 4F 
0B377A 50   
0B377B 00 
0B377D B7    0473** DB    B7H, "TAN"
0B377E 54 
0B377F 41 
0B3780 4E 
0B3781 8C    0474** DB    8CH, "THEN"
0B3782 54 
0B3783 48 
0B3784 45 
0B3784 4E   
0B3786 B8    0475** DB    B8H, "TO"
0B3787 54 
0B3788 4F 
0B3789 8A    0476** DB    8AH, "TAB("
0B378A 54 
0B378B 41 
0B378C 42 
0B378C 28   
0B378E FC    0477** DB    FCH, "TRACE"
0B378F 54 
0B3790 52 
0B3791 41 
0B3791 43   
0B3792 45 
0B3794 91    0478** DB    91H, "TIME", 0
0B3795 54 
0B3796 49 
0B3797 4D 
0B3797 45   
0B3798 00 
0B379A B9    0479** DB    B9H, "TRUE", 0
0B379B 54 
0B379C 52 
0B379D 55 
0B379D 45   
0B379E 00 
0B37A0 FD    0480** DB    FDH, "UNTIL"
0B37A1 55 
0B37A2 4E 
0B37A3 54 
0B37A3 49   
0B37A4 4C 
0B37A6 BA    0481** DB    BAH, "USR"
0B37A7 55 
0B37A8 53 
0B37A9 52 
0B37AA EF    0482** DB    EFH, "VDU"
0B37AB 56 
0B37AC 44 
0B37AD 55 
0B37AE BB    0483** DB    BBH, "VAL"
0B37AF 56 
0B37B0 41 
0B37B1 4C 
0B37B2 BC    0484** DB    BCH, "VPOS", 0
0B37B3 56 
0B37B4 50 
0B37B5 4F 
0B37B5 53   
0B37B6 00 
0B37B8 FE    0485** DB    FEH, "WIDTH"
0B37B9 57 
0B37BA 49 
0B37BB 44 
0B37BB 54   
0B37BC 48 
0B37BE D3    0486** DB    D3H, "HIMEM"
0B37BF 48 
0B37C0 49 
0B37C1 4D 
0B37C1 45   
0B37C2 4D 
0B37C4 D2    0487** DB    D2H, "LOMEM"
0B37C5 4C 
0B37C6 4F 
0B37C7 4D 
0B37C7 45   
0B37C8 4D 
0B37CA D0    0488** DB    D0H, "PAGE"
0B37CB 50 
0B37CC 41 
0B37CD 47 
0B37CD 45   
0B37CF CF    0489** DB    CFH, "PTR"
0B37D0 50 
0B37D1 54 
0B37D2 52 
0B37D3 D1    0490** DB    D1H, "TIME"
0B37D4 54 
0B37D5 49 
0B37D6 4D 
0B37D6 45   
             0491** ;
             0492** ; These are indexed from the ERRWDS table
             0493** ;
0B37D8 01    0494** DB    01H, "Missing "
0B37D9 4D 
0B37DA 69 
0B37DB 73 
0B37DB 73   
0B37DC 69 
0B37DD 6E 
0B37DE 67 
0B37DE 20   
0B37E1 02    0495** DB    02H, "No such "
0B37E2 4E 
0B37E3 6F 
0B37E4 20 
0B37E4 73   
0B37E5 75 
0B37E6 63 
0B37E7 68 
0B37E7 20   
0B37EA 03    0496** DB    03H, "Bad "
0B37EB 42 
0B37EC 61 
0B37ED 64 
0B37ED 20   
0B37EF 04    0497** DB    04H, " range"
0B37F0 20 
0B37F1 72 
0B37F2 61 
0B37F2 6E   
0B37F3 67 
0B37F4 65 
0B37F6 05    0498** DB    05H, "variable"
0B37F7 76 
0B37F8 61 
0B37F9 72 
0B37F9 69   
0B37FA 61 
0B37FB 62 
0B37FC 6C 
0B37FC 65   
0B37FF 06    0499** DB    06H, "Out of"
0B3800 4F 
0B3801 75 
0B3802 74 
0B3802 20   
0B3803 6F 
0B3804 66 
0B3806 07    0500** DB    07H, "No "
0B3807 4E 
0B3808 6F 
0B3809 20 
0B380A 08    0501** DB    08H, " space"
0B380B 20 
0B380C 73 
0B380D 70 
0B380D 61   
0B380E 63 
0B380F 65 
             0502** 
             0503** KEYWDL:			EQU     $-KEYWDS
0B3811 FF    0504** DW    -1
0B3812 FF 
             0505** ;
             0506** ; Error messages
             0507** ;
0B3813 07    0508** ERRWDS:			DB    7, "room", 0		;  0: No room
0B3814 72 
0B3815 6F 
0B3816 6F 
0B3816 6D   
0B3817 00 
0B3819 06    0509** DB    6, 4, 0			;  1: Out of range
0B381A 04 
0B381B 00 
0B381C 00    0510** DB    0				;  2: *
0B381D 00    0511** DB    0				;  3: *
0B381E 4D    0512** DB    "Mistake", 0		;  4: Mistake
0B381F 69 
0B3820 73 
0B3821 74 
0B3821 61   
0B3822 6B 
0B3823 65 
0B3824 00 
0B3826 01    0513** DB    1, ",", 0			;  5: Missing ,
0B3827 2C 
0B3828 00 
0B3829 54    0514** DB    "Type mismatch", 0	;  6: Type mismatch
0B382A 79 
0B382B 70 
0B382C 65 
0B382C 20   
0B382D 6D 
0B382E 69 
0B382F 73 
0B382F 6D   
0B3830 61 
0B3831 74 
0B3832 63 
0B3832 68   
0B3833 00 
0B3837 07    0515** DB    7, FN, 0			;  7: No FN
0B3838 A4 
0B3839 00 
0B383A 00    0516** DB    0				;  8: *
0B383B 01    0517** DB    1, 34, 0			;  9: Missing "
0B383C 22 
0B383D 00 
0B383E 03    0518** DB    3, DIM, 0			; 10: Bad DIM
0B383F DE 
0B3840 00 
0B3841 DE    0519** DB    DIM, 8, 0			; 11: DIM space
0B3842 08 
0B3843 00 
0B3844 4E    0520** DB    "Not ", LOCAL_, 0		; 12: Not LOCAL
0B3845 6F 
0B3846 74 
0B3847 20 
0B3847 EA   
0B3848 00 
0B384A 07    0521** DB    7, PROC, 0		; 13: No PROC
0B384B F2 
0B384C 00 
0B384D 41    0522** DB    "Array", 0		; 14: Array
0B384E 72 
0B384F 72 
0B3850 61 
0B3850 79   
0B3851 00 
0B3853 53    0523** DB    "Subscript", 0		; 15: Subscript
0B3854 75 
0B3855 62 
0B3856 73 
0B3856 63   
0B3857 72 
0B3858 69 
0B3859 70 
0B3859 74   
0B385A 00 
0B385D 53    0524** DB    "Syntax error", 0		; 16: Syntax error
0B385E 79 
0B385F 6E 
0B3860 74 
0B3860 61   
0B3861 78 
0B3862 20 
0B3863 65 
0B3863 72   
0B3864 72 
0B3865 6F 
0B3866 72 
0B3866 00   
0B386A 45    0525** DB    "Escape", 0		; 17: Escape
0B386B 73 
0B386C 63 
0B386D 61 
0B386D 70   
0B386E 65 
0B386F 00 
0B3871 44    0526** DB    "Division by zero", 0	; 18: Division by zero
0B3872 69 
0B3873 76 
0B3874 69 
0B3874 73   
0B3875 69 
0B3876 6F 
0B3877 6E 
0B3877 20   
0B3878 62 
0B3879 79 
0B387A 20 
0B387A 7A   
0B387B 65 
0B387C 72 
0B387D 6F 
0B387D 00   
0B3882 53    0527** DB    "String too long", 0	; 19: String too long
0B3883 74 
0B3884 72 
0B3885 69 
0B3885 6E   
0B3886 67 
0B3887 20 
0B3888 74 
0B3888 6F   
0B3889 6F 
0B388A 20 
0B388B 6C 
0B388B 6F   
0B388C 6E 
0B388D 67 
0B388E 00 
0B3892 54    0528** DB    "Too big", 0		; 20: Too big
0B3893 6F 
0B3894 6F 
0B3895 20 
0B3895 62   
0B3896 69 
0B3897 67 
0B3898 00 
0B389A 2D    0529** DB    "-ve root", 0		; 21: -ve root
0B389B 76 
0B389C 65 
0B389D 20 
0B389D 72   
0B389E 6F 
0B389F 6F 
0B38A0 74 
0B38A0 00   
0B38A3 4C    0530** DB    "Log", 4, 0		; 22: Log range
0B38A4 6F 
0B38A5 67 
0B38A6 04 
0B38A6 00   
0B38A8 41    0531** DB    "Accuracy lost", 0	; 23: Accuracy lost
0B38A9 63 
0B38AA 63 
0B38AB 75 
0B38AB 72   
0B38AC 61 
0B38AD 63 
0B38AE 79 
0B38AE 20   
0B38AF 6C 
0B38B0 6F 
0B38B1 73 
0B38B1 74   
0B38B2 00 
0B38B6 45    0532** DB    "Exp", 4, 0		; 24: Exp range
0B38B7 78 
0B38B8 70 
0B38B9 04 
0B38B9 00   
0B38BB 00    0533** DB    0				; 25: *
0B38BC 02    0534** DB    2, 5, 0			; 26: No such variable
0B38BD 05 
0B38BE 00 
0B38BF 01    0535** DB    1, ")", 0			; 27: Missing )
0B38C0 29 
0B38C1 00 
0B38C2 03    0536** DB    3, "HEX", 0		; 28: Bad HEX
0B38C3 48 
0B38C4 45 
0B38C5 58 
0B38C5 00   
0B38C7 02    0537** DB    2, FN, "/", PROC, 0	; 29: No such FN/PROC
0B38C8 A4 
0B38C9 2F 
0B38CA F2 
0B38CA 00   
0B38CC 03    0538** DB    3, "call", 0		; 30: Bad call
0B38CD 63 
0B38CE 61 
0B38CF 6C 
0B38CF 6C   
0B38D0 00 
0B38D2 41    0539** DB    "Arguments", 0		; 31: Arguments
0B38D3 72 
0B38D4 67 
0B38D5 75 
0B38D5 6D   
0B38D6 65 
0B38D7 6E 
0B38D8 74 
0B38D8 73   
0B38D9 00 
0B38DC 07    0540** DB    7, FOR, 0			; 32: No FOR
0B38DD E3 
0B38DE 00 
0B38DF 43    0541** DB    "Can't match ", FOR, 0	; 33: Can't match FOR
0B38E0 61 
0B38E1 6E 
0B38E2 27 
0B38E2 74   
0B38E3 20 
0B38E4 6D 
0B38E5 61 
0B38E5 74   
0B38E6 63 
0B38E7 68 
0B38E8 20 
0B38E8 E3   
0B38E9 00 
0B38ED E3    0542** DB    FOR, " ", 5, 0		; 34: FOR variable
0B38EE 20 
0B38EF 05 
0B38F0 00 
0B38F1 00    0543** DB    0				; 35: *
0B38F2 07    0544** DB    7, TO_MN, 0			; 36: No TO
0B38F3 B8 
0B38F4 00 
0B38F5 00    0545** DB    0				; 37: *
0B38F6 07    0546** DB    7, GOSUB, 0		; 38: No GOSUB
0B38F7 E4 
0B38F8 00 
0B38F9 EE    0547** DB    ON_, " syntax", 0		; 39: ON syntax
0B38FA 20 
0B38FB 73 
0B38FC 79 
0B38FC 6E   
0B38FD 74 
0B38FE 61 
0B38FF 78 
0B38FF 00   
0B3902 EE    0548** DB    ON_, 4, 0			; 40: ON range
0B3903 04 
0B3904 00 
0B3905 02    0549** DB    2, "line", 0		; 41: No such line
0B3906 6C 
0B3907 69 
0B3908 6E 
0B3908 65   
0B3909 00 
0B390B 06    0550** DB    6, " ", DATA_MN_, 0		; 42: Out of DATA
0B390C 20 
0B390D DC 
0B390E 00 
0B390F 07    0551** DB    7, REPEAT, 0		; 43: No REPEAT
0B3910 F5 
0B3911 00 
0B3912 00    0552** DB    0				; 44: *
0B3913 01    0553** DB    1, "#", 0			; 45: Missing #
0B3914 23 
0B3915 00 
             0554** ;
             0555** ; COMMANDS:
             0556** ;
             0557** ; DELETE line,line
             0558** ;
0B3916 CD    0559** DELETE:			CALL    SETTOP          	; Set TOP sysvar (first free byte at end of BASIC program)
0B3917 15 
0B3918 3C 
0B3919 0B 
0B391A CD    0560** CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B391B 1D 
0B391C 40 
0B391D 0B 
0B391E 7E    0561** DELET1:			LD      A,(HL)			; Check whether it's the last line
0B391F B7    0562** OR      A
0B3920 CA    0563** JP      Z,WARMNC		; Yes, so do nothing
0B3921 A7 
0B3922 39 
0B3923 0B 
0B3924 23    0564** INC     HL			; Skip the line length byte
0B3925 11    0565** LD	DE, 0			; Clear DE
0B3926 00 
0B3927 00 
0B3928 00 
0B3929 5E    0566** LD      E,(HL)			; Fetch the line number in DE
0B392A 23    0567** INC     HL
0B392B 56    0568** LD      D,(HL)
0B392C 7A    0569** LD      A,D			; If the line number is zero then
0B392D B3    0570** OR      E
0B392E 28    0571** JR      Z,CLOOP1        	; Do nothing
0B392F 1D 
0B3930 2B    0572** DEC     HL			; Decrement BASIC program pointer back to length
0B3931 2B    0573** DEC     HL
0B3932 EB    0574** EX      DE,HL			; Check if we've gone past the terminating line
0B3933 37    0575** SCF
0B3934 ED    0576** SBC     HL,BC
0B3935 42 
0B3936 EB    0577** EX      DE,HL
0B3937 30    0578** JR      NC,WARMNC		; Yes, so exit back to BASIC prompt
0B3938 6E 
0B3939 C5    0579** PUSH    BC
0B393A CD    0580** CALL    DEL			; Delete the line pointed to by HL
0B393B CC 
0B393C 3B 
0B393D 0B 
0B393E C1    0581** POP     BC
0B393F 18    0582** JR      DELET1			; And loop round to the next line
0B3940 DD 
             0583** ;
             0584** ; LISTO expr
             0585** ;
0B3941 FD    0586** LISTO:			INC     IY              	; Skip "O" byte
0B3942 23 
0B3943 CD    0587** CALL    EXPRI			; Get expr
0B3944 D4 
0B3945 06 
0B3946 0B 
0B3947 D9    0588** EXX
0B3948 7D    0589** LD      A,L
0B3949 32    0590** LD      (LISTON),A		; Store in LISTON sysvar
0B394A 40 
0B394B 51 
0B394C 0B 
0B394D C3    0591** CLOOP1:			JP      CLOOP
0B394E 4A 
0B394F 34 
0B3950 0B 
             0592** ;
             0593** ; LIST
             0594** ; LIST line
             0595** ; LIST line,line [IF string]
             0596** ; LIST ,line
             0597** ; LIST line,
             0598** ;
0B3951 FE    0599** LIST_:			CP      'O'			; Check for O (LISTO)
0B3952 4F 
0B3953 28    0600** JR      Z,LISTO			; and jump to LISTO if zero
0B3954 EC 
0B3955 CD    0601** CALL    DLPAIR			; Get the line number pair - HL: BASIC program address, BC: second number (or 0 if missing)
0B3956 1D 
0B3957 40 
0B3958 0B 
0B3959 CD    0602** CALL    NXT			; Skip space
0B395A 3A 
0B395B 0E 
0B395C 0B 
0B395D FE    0603** CP      TIF             	; Check for IF clause (token IF)
0B395E E7 
0B395F 3E    0604** LD      A,0             	; Initialise the IF clause string length
0B3960 00 
0B3961 20    0605** JR      NZ,LISTB		; If there is no IF clause, skip the next bit
0B3962 17 
             0606** ;
0B3963 FD    0607** INC     IY              	; Skip the IF token
0B3964 23 
0B3965 CD    0608** CALL    NXT             	; And skip any spaces
0B3966 3A 
0B3967 0E 
0B3968 0B 
0B3969 EB    0609** EX      DE,HL			; DE: Address in memory
0B396A FD    0610** PUSH    IY			; LD IY, HL
0B396B E5 
0B396C E1    0611** POP     HL              	; HL is now the address of the tokenised line
0B396D 3E    0612** LD      A,CR
0B396E 0D 
0B396F C5    0613** PUSH    BC			; Stack the second line number arg
0B3970 01    0614** LD      BC,256
0B3971 00 
0B3972 01 
0B3973 00 
0B3974 ED    0615** CPIR                    	; Locate CR byte
0B3975 B1 
0B3976 79    0616** LD      A,C
0B3977 2F    0617** CPL                    	 	; A: Substring length (of IF clause)
0B3978 C1    0618** POP     BC			; Restore the second line number arg
0B3979 EB    0619** EX      DE,HL			; HL: Address in memory
             0620** ;
0B397A 5F    0621** LISTB:			LD      E,A             	; E: IF clause string length
0B397B 78    0622** LD      A,B			; Check whether a second line number was passed (BC!=0)
0B397C B1    0623** OR      C
0B397D 20    0624** JR      NZ,LISTA		; If there isn't a second line number
0B397E 01 
0B397F 0B    0625** DEC     BC			; then we set it to the maximum of 65535
             0626** ;
0B3980 D9    0627** LISTA:			EXX
0B3981 DD    0628** LD      IX,LISTON		; IX : Pointer to the LISTON (LISTO and OPT) sysvar
0B3982 21 
0B3983 40 
0B3984 51 
0B3984 0B   
0B3986 01    0629** LD      BC,0            	; BC': Indentation counter (C: FOR/NEXT, B: REPEAT/UNTIL)
0B3987 00 
0B3988 00 
0B3989 00 
0B398A D9    0630** EXX
0B398B 3E    0631** LD      A,20			; Number of lines to list
0B398C 14 
             0632** ;
0B398D C5    0633** LISTC:			PUSH    BC              	; Save second line number
0B398E D5    0634** PUSH    DE              	; Save IF clause length
0B398F E5    0635** PUSH    HL              	; Save BASIC program counter
0B3990 08    0636** EX      AF,AF'
             0637** ;
             0638** ; BBC BASIC for Z80 lines are stored as follows:
             0639** ;
             0640** ; - [LEN] [LSB] [MSB] [DATA...] [0x0D]: LSB, MSB = line number
             0641** ; - [&00] [&FF] [&FF]: End of program marker
             0642** ;
             0643** ; This is the Russell format and different to the Wilson/Acorn format: https://www.beebwiki.mdfs.net/Program_format
             0644** ;
0B3991 7E    0645** LD      A,(HL)			; Check for end of program marker
0B3992 B7    0646** OR      A			; If found
0B3993 28    0647** JR      Z,WARMNC		; Jump to WARMNC (F=NC, so will jump to WARM)
0B3994 12 
             0648** ;
             0649** ; Check if past terminating line number
             0650** ;
0B3995 7B    0651** LD      A,E             	; A: IF clause length
0B3996 23    0652** INC     HL			; Skip the length byte
0B3997 11    0653** LD	DE,0			; Clear DE
0B3998 00 
0B3999 00 
0B399A 00 
0B399B 5E    0654** LD      E,(HL)			; Fetch the line number in DE
0B399C 23    0655** INC     HL
0B399D 56    0656** LD      D,(HL)
0B399E 2B    0657** DEC     HL			; Step HL back to the length byte
0B399F 2B    0658** DEC     HL
0B39A0 D5    0659** PUSH    DE             	 	; Push the line number on the stack
0B39A1 EB    0660** EX      DE,HL			; HL: line number
0B39A2 37    0661** SCF				; Do a 16-bit compare of HL and DE
0B39A3 ED    0662** SBC     HL,BC
0B39A4 42 
0B39A5 EB    0663** EX      DE,HL
0B39A6 D1    0664** POP     DE              	; Restore the line number
0B39A7 D2    0665** WARMNC:			JP      NC,WARM			; If exceeded the terminating line number then jump to WARM
0B39A8 49 
0B39A9 34 
0B39AA 0B 
0B39AB 4E    0666** LD      C,(HL)          	; C: Line length + 4
0B39AC 47    0667** LD      B,A             	; B: IF clause length
             0668** ;
             0669** ; Check if "UNLISTABLE":
             0670** ;
0B39AD 7A    0671** LD      A,D			; TODO: What is "UNLISTABLE?"
0B39AE B3    0672** OR      E
0B39AF CA    0673** JP      Z,CLOOP
0B39B0 4A 
0B39B1 34 
0B39B2 0B 
             0674** ;
             0675** ; Check for IF clause:
             0676** ;
0B39B3 23    0677** INC     HL			; Skip the length
0B39B4 23    0678** INC     HL			; Skip the line number
0B39B5 23    0679** INC     HL              	; HL: Address of the tokenised BASIC line
0B39B6 0D    0680** DEC     C			;  C: Line length
0B39B7 0D    0681** DEC     C
0B39B8 0D    0682** DEC     C
0B39B9 0D    0683** DEC     C
0B39BA D5    0684** PUSH    DE              	; Save the line number
0B39BB E5    0685** PUSH    HL              	; Save the BASIC program address
0B39BC AF    0686** XOR     A               	;
0B39BD B8    0687** CP      B              	 	; Check for an IF clause (B!=0)
0B39BE FD    0688** PUSH    IY			; LD IY, DE
0B39BF E5 
0B39C0 D1    0689** POP     DE              	; DE: Address of the IF clause string in the input buffer
0B39C1 C4    0690** CALL    NZ,SEARCH      		; If there is an IF clause (B!=0) then search for it
0B39C2 4F 
0B39C3 0B 
0B39C4 0B 
0B39C5 E1    0691** POP     HL              	; Restore BASIC program address
0B39C6 D1    0692** POP     DE              	; Restore line number
0B39C7 FD    0693** PUSH    IY
0B39C8 E5 
0B39C9 CC    0694** CALL    Z,LISTIT        	; List if no IF clause OR there is an IF clause match
0B39CA 5C 
0B39CB 3C 
0B39CC 0B 
0B39CD FD    0695** POP     IY
0B39CE E1 
             0696** ;
0B39CF 08    0697** EX      AF,AF'
0B39D0 3D    0698** DEC     A			; Decrement line list counter
0B39D1 CD    0699** CALL    LTRAP			; TODO: This destroys A - is this a bug I've introduced in LTRAP?
0B39D2 3B 
0B39D3 43 
0B39D4 0B 
0B39D5 E1    0700** POP     HL             	 	; Restore BASIC program address to beginning of line
0B39D6 11    0701** LD	DE,0
0B39D7 00 
0B39D8 00 
0B39D9 00 
0B39DA 5E    0702** LD      E,(HL)			; Fetch the length of line in DE
0B39DB 19    0703** ADD     HL,DE           	; Go to the next line
0B39DC D1    0704** POP     DE              	; Restore IF clause length
0B39DD C1    0705** POP     BC              	; Restore second line number
0B39DE 18    0706** JR      LISTC			; Loop back to do next line
0B39DF AD 
             0707** ;
             0708** ; RENUMBER
             0709** ; RENUMBER start
             0710** ; RENUMBER start,increment
             0711** ; RENUMBER ,increment
             0712** ;
0B39E0 CD    0713** RENUM:			CALL    CLEAR           	; Uses the heap so clear all dynamic variables and function/procedure pointers
0B39E1 40 
0B39E2 3C 
0B39E3 0B 
0B39E4 CD    0714** CALL    PAIR            	; Fetch the parameters - HL: start (NEW line number), BC: increment
0B39E5 F5 
0B39E6 3F 
0B39E7 0B 
0B39E8 D9    0715** EXX
0B39E9 2A    0716** LD      HL,(PAGE_)		; HL: Top of program
0B39EA 14 
0B39EB 51 
0B39EC 0B 
0B39ED ED    0717** LD      DE,(LOMEM)		; DE: Start address of the heap
0B39EE 5B 
0B39EF 1A 
0B39F0 51 
0B39F0 0B   
             0718** ;
             0719** ; Build the table
             0720** ;
0B39F2 7E    0721** RENUM1:			LD      A,(HL)          	; Fetch the line length byte
0B39F3 B7    0722** OR      A			; Is it zero, i.e. the end of program marker?
0B39F4 28    0723** JR      Z,RENUM2		; Yes, so skip to the next part
0B39F5 36 
0B39F6 23    0724** INC     HL
0B39F7 4E    0725** LD      C,(HL)          	; BC: The OLD line number
0B39F8 23    0726** INC     HL
0B39F9 46    0727** LD      B,(HL)
0B39FA 78    0728** LD      A,B			; Check whether the line number is zero - we only need to check the LSW
0B39FB B1    0729** OR      C
0B39FC CA    0730** JP      Z,CLOOP        		; If the line number is zero, then exit back to the command line
0B39FD 4A 
0B39FE 34 
0B39FF 0B 
0B3A00 EB    0731** EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B3A01 71    0732** LD      (HL),C			; Store the OLD line number in the heap
0B3A02 23    0733** INC     HL
0B3A03 70    0734** LD      (HL),B
0B3A04 23    0735** INC     HL
0B3A05 D9    0736** EXX				; HL: line number, BC: increment (16-bit values)
0B3A06 E5    0737** PUSH    HL			; HL: Stack the NEW line number value
0B3A07 52    0738** ADD.S   HL,BC           	; Add the increment
0B3A08 09 
0B3A09 DA    0739** JP      C,TOOBIG        	; If > 65535, then error: "Too big"
0B3A0A EF 
0B3A0B 3F 
0B3A0C 0B 
0B3A0D D9    0740** EXX				; DE: Pointer to BASIC program, HL: Pointer to heap
0B3A0E C1    0741** POP     BC			; BC: Pop the NEW line number value off the stack
0B3A0F 71    0742** LD      (HL),C			; Store the NEW line number in the heap
0B3A10 23    0743** INC     HL
0B3A11 70    0744** LD      (HL),B
0B3A12 23    0745** INC     HL
0B3A13 EB    0746** EX      DE,HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B3A14 2B    0747** DEC     HL			; Back up to the line length byte
0B3A15 2B    0748** DEC     HL
0B3A16 01    0749** LD	BC, 0
0B3A17 00 
0B3A18 00 
0B3A19 00 
0B3A1A 4E    0750** LD      C,(HL)			; BC: Line length
0B3A1B 09    0751** ADD	HL,BC           	; Advance HL to next line
0B3A1C EB    0752** EX      DE,HL			; DE: Pointer to BASIC program, HL: Pointer to heap
0B3A1D E5    0753** PUSH    HL
0B3A1E 24    0754** INC     H			; Increment to next page
0B3A1F ED    0755** SBC     HL,SP			; Subtract from SP
0B3A20 72 
0B3A21 E1    0756** POP     HL
0B3A22 EB    0757** EX      DE, HL			; HL: Pointer to BASIC program, DE: Pointer to heap
0B3A23 38    0758** JR      C,RENUM1        	; Loop, as the heap pointer has not strayed into the stack page
0B3A24 CD 
0B3A25 CD    0759** CALL    EXTERR          	; Otherwise throw error: "RENUMBER space'
0B3A26 41 
0B3A27 3B 
0B3A28 0B 
0B3A29 CC    0760** DB    	REN
0B3A2A 08    0761** DB    	8
0B3A2B 00    0762** DB    	0
             0763** ;
             0764** ; At this point a list of BASIC line numbers have been written to the heap
             0765** ; as word pairs:
             0766** ; - DW: The OLD line number
             0767** ; - DW: The NEW line number
             0768** ;
0B3A2C EB    0769** RENUM2:			EX      DE,HL			; HL: Pointer to the end of the heap
0B3A2D 36    0770** LD      (HL),-1			; Mark the end with FFFFh
0B3A2E FF 
0B3A2F 23    0771** INC     HL
0B3A30 36    0772** LD      (HL),-1
0B3A31 FF 
0B3A32 ED    0773** LD      DE,(LOMEM)		; DE: Pointer to the start of the heap
0B3A33 5B 
0B3A34 1A 
0B3A35 51 
0B3A35 0B   
0B3A37 D9    0774** EXX
0B3A38 2A    0775** LD      HL,(PAGE_)		; HL: Start of the BASIC program area
0B3A39 14 
0B3A3A 51 
0B3A3B 0B 
0B3A3C 4E    0776** RENUM3:			LD      C,(HL)			; Fetch the first line length byte
0B3A3D 79    0777** LD      A,C			; If it is zero, then no program, so...
0B3A3E B7    0778** OR      A
0B3A3F CA    0779** JP      Z,WARM			; Jump to warm start
0B3A40 49 
0B3A41 34 
0B3A42 0B 
0B3A43 D9    0780** EXX				; HL: Pointer to end of heap, DE: Pointer to start of heap
0B3A44 EB    0781** EX      DE,HL			; DE: Pointer to end of heap, HL: Pointer to start of heap
0B3A45 23    0782** INC     HL			; Skip to the NEW line number
0B3A46 23    0783** INC     HL
0B3A47 5E    0784** LD      E,(HL)			; DE: The NEW line number
0B3A48 23    0785** INC     HL
0B3A49 56    0786** LD      D,(HL)
0B3A4A 23    0787** INC     HL
0B3A4B D5    0788** PUSH    DE			; Stack the NEW line number
0B3A4C EB    0789** EX      DE,HL			; HL: The NEW line number, DE: Pointer to the end of heap
0B3A4D 22    0790** LD      (LINENO),HL		; Store the line number in LINENO
0B3A4E 23 
0B3A4F 51 
0B3A50 0B 
0B3A51 D9    0791** EXX				; HL: Pointer to the BASIC program area
0B3A52 D1    0792** POP     DE			; DE: The NEW line number
0B3A53 23    0793** INC     HL
0B3A54 73    0794** LD      (HL),E          	; Write out the NEW line number to the BASIC program
0B3A55 23    0795** INC     HL
0B3A56 72    0796** LD      (HL),D
0B3A57 23    0797** INC     HL
0B3A58 0D    0798** DEC     C			; Subtract 3 from the line length to compensate for increasing HL by 3 above
0B3A59 0D    0799** DEC     C
0B3A5A 0D    0800** DEC     C
0B3A5B 79    0801** LD	A,C
0B3A5C 01    0802** LD	BC,0
0B3A5D 00 
0B3A5E 00 
0B3A5F 00 
0B3A60 4F    0803** LD	C,A			; BC: Line length
             0804** ;
0B3A61 3E    0805** RENUM7:			LD      A,LINO_MN			; A: The token code that precedes any line number encoded in BASIC (i.e. GOTO/GOSUB)
0B3A62 8D 
0B3A63 ED    0806** CPIR                    	; Search for the token
0B3A64 B1 
0B3A65 20    0807** JR      NZ,RENUM3		; If not found, then loop to process the next line
0B3A66 D5 
             0808** ;
             0809** ; Having established this line contains at least one encoded line number, we need to update it to point to the new line number
             0810** ;
0B3A67 C5    0811** PUSH    BC			; Stack everything
0B3A68 E5    0812** PUSH    HL
0B3A69 E5    0813** PUSH    HL			; HL: Pointer to encoded line number
0B3A6A FD    0814** POP     IY			; IY: Pointer to encoded line number
0B3A6B E1 
0B3A6C D9    0815** EXX
0B3A6D CD    0816** CALL    DECODE			; Decode the encoded line number (in HL')
0B3A6E B0 
0B3A6F 0C 
0B3A70 0B 
0B3A71 D9    0817** EXX				; HL: Decoded line number
0B3A72 44    0818** LD      B,H			; BC: Decoded line number
0B3A73 4D    0819** LD      C,L
0B3A74 2A    0820** LD      HL,(LOMEM)		; HL: Pointer to heap
0B3A75 1A 
0B3A76 51 
0B3A77 0B 
             0821** ;
             0822** ; This section of code cross-references the decoded (OLD) line number with the list
             0823** ; created previously in the global heap
             0824** ;
0B3A78 5E    0825** RENUM4:			LD      E,(HL)          	; DE: The OLD line number
0B3A79 23    0826** INC     HL
0B3A7A 56    0827** LD      D,(HL)
0B3A7B 23    0828** INC     HL
0B3A7C EB    0829** EX      DE,HL			; HL: The OLD line number, DE: Pointer in the global heap
0B3A7D B7    0830** OR      A               	; Clear the carry and...
0B3A7E 52    0831** SBC.S   HL,BC			; Compare by means of subtraction the OLD line number against the one in the heap
0B3A7F ED 
0B3A80 42 
0B3A81 EB    0832** EX      DE,HL			; HL: Pointer in the global heap
0B3A82 5E    0833** LD      E,(HL)          	; DE: The NEW line number
0B3A83 23    0834** INC     HL
0B3A84 56    0835** LD      D,(HL)
0B3A85 23    0836** INC     HL
0B3A86 38    0837** JR      C,RENUM4		; Loop until there is a match (Z) or not (NC)
0B3A87 F0 
0B3A88 EB    0838** EX      DE,HL			; DE: Pointer in the global heap
0B3A89 28    0839** JR      Z,RENUM5        	; If Z flag is set, there is an exact match to the decoded line number on the heap
0B3A8A 1D 
             0840** ;
0B3A8B CD    0841** CALL    TELL			; Display this error if the line number is not found
0B3A8C 5A 
0B3A8D 41 
0B3A8E 0B 
0B3A8F 46    0842** DB    	"Failed at "
0B3A90 61 
0B3A91 69 
0B3A92 6C 
0B3A92 65   
0B3A93 64 
0B3A94 20 
0B3A95 61 
0B3A95 74   
0B3A96 20 
0B3A99 00    0843** DB    	0
0B3A9A 2A    0844** LD      HL,(LINENO)
0B3A9B 23 
0B3A9C 51 
0B3A9D 0B 
0B3A9E CD    0845** CALL    PBCDL
0B3A9F C1 
0B3AA0 3D 
0B3AA1 0B 
0B3AA2 CD    0846** CALL    CRLF
0B3AA3 11 
0B3AA4 3D 
0B3AA5 0B 
0B3AA6 18    0847** JR      RENUM6			; And carry on renumbering
0B3AA7 07 
             0848** ;
             0849** ; This snippet re-encodes the line number in the BASIC program
             0850** ;
0B3AA8 D1    0851** RENUM5:			POP     DE			; DE: Pointer to the encoded line number in the listing
0B3AA9 D5    0852** PUSH    DE
0B3AAA 1B    0853** DEC     DE			; Back up a byte to the LINO token
0B3AAB CD    0854** CALL    ENCODE          	; Re-write the new line number out
0B3AAC 26 
0B3AAD 41 
0B3AAE 0B 
0B3AAF E1    0855** RENUM6:			POP     HL			; HL: Pointer to the encoded line number in the listing
0B3AB0 C1    0856** POP     BC			; BC: The remaining line length
0B3AB1 18    0857** JR      RENUM7			; Carry on checking for any more encoded line numbers in this line
0B3AB2 AE 
             0858** ;
             0859** ; AUTO
             0860** ; AUTO start,increment
             0861** ; AUTO start
             0862** ; AUTO ,increment
             0863** ;
0B3AB3 CD    0864** AUTO:			CALL    PAIR			; Get the parameter pair (HL: first parameter, BC: second parameter)
0B3AB4 F5 
0B3AB5 3F 
0B3AB6 0B 
0B3AB7 22    0865** LD      (AUTONO),HL		; Store the start in AUTONO
0B3AB8 29 
0B3AB9 51 
0B3ABA 0B 
0B3ABB 79    0866** LD      A,C			; Increment is 8 bit (0-255)
0B3ABC 32    0867** LD      (INCREM),A		; Store that in INCREM
0B3ABD 41 
0B3ABE 51 
0B3ABF 0B 
0B3AC0 18    0868** JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B3AC1 2E 
             0869** ;
             0870** ; BAD
             0871** ; NEW
             0872** ;
0B3AC2 CD    0873** BAD:			CALL    TELL            	; Output "Bad program" error
0B3AC3 5A 
0B3AC4 41 
0B3AC5 0B 
0B3AC6 03    0874** DB    3				; Token for "BAD"
0B3AC7 70    0875** DB    "program"
0B3AC8 72 
0B3AC9 6F 
0B3ACA 67 
0B3ACA 72   
0B3ACB 61 
0B3ACC 6D 
0B3ACE 0D    0876** DB    CR
0B3ACF 0A    0877** DB    LF
0B3AD0 00    0878** DB    0				; Falls through to NEW
             0879** ;
0B3AD1 CD    0880** NEW:			CALL    NEWIT			; Call NEWIT (clears program area and variables)
0B3AD2 36 
0B3AD3 3C 
0B3AD4 0B 
0B3AD5 18    0881** JR      CLOOP0			; Jump back indirectly to the command loop via CLOOP0 (optimisation for size)
0B3AD6 19 
             0882** ;
             0883** ; OLD
             0884** ;
0B3AD7 2A    0885** OLD:			LD      HL,(PAGE_)		; HL: The start of the BASIC program area
0B3AD8 14 
0B3AD9 51 
0B3ADA 0B 
0B3ADB E5    0886** PUSH    HL			; Stack it
0B3ADC 23    0887** INC     HL			; Skip the potential length byte of first line of code
0B3ADD 23    0888** INC     HL			; And the line number word
0B3ADE 23    0889** INC     HL
0B3ADF 01    0890** LD      BC,252			; Look for a CR in the first 252 bytes of code; maximum line length
0B3AE0 FC 
0B3AE1 00 
0B3AE2 00 
0B3AE3 3E    0891** LD      A,CR
0B3AE4 0D 
0B3AE5 ED    0892** CPIR
0B3AE6 B1 
0B3AE7 20    0893** JR      NZ,BAD			; If not found, then the first line of code is not a valid BBC BASIC code
0B3AE8 D9 
0B3AE9 7D    0894** LD      A,L			; It could still be garbage though! Store the position in A; this requires
0B3AEA E1    0895** POP     HL			; PAGE to be on a 256 page boundary, and is now the length of the first line
0B3AEB 77    0896** LD      (HL),A			; Restore the length byte (this will have been set to 0 by NEW)
0B3AEC CD    0897** CALL    CLEAN			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B3AED 09 
0B3AEE 3C 
0B3AEF 0B 
0B3AF0 C3    0898** CLOOP0:			JP      CLOOP			; Jump back to the command loop
0B3AF1 4A 
0B3AF2 34 
0B3AF3 0B 
             0899** ;
             0900** ; LOAD filename
             0901** ;
0B3AF4 CD    0902** LOAD:			CALL    EXPRS           	; Get the filename
0B3AF5 DF 
0B3AF6 06 
0B3AF7 0B 
0B3AF8 3E    0903** LD      A,CR			; DE points to the last byte of filename in ACCS
0B3AF9 0D 
0B3AFA 12    0904** LD      (DE),A			; Terminate filename with a CR
0B3AFB CD    0905** CALL    LOAD0			; Load the file in, then CLEAN
0B3AFC E9 
0B3AFD 3B 
0B3AFE 0B 
0B3AFF CD    0906** CALL    CLEAR			; Further checks for bad program, set TOP, write out &FFFF end of program marker
0B3B00 40 
0B3B01 3C 
0B3B02 0B 
0B3B03 18    0907** JR      WARM0			; Jump back to the command loop
0B3B04 21 
             0908** ;
             0909** ; SAVE filename
             0910** ;
0B3B05 CD    0911** SAVE:			CALL    SETTOP          	; Set TOP sysvar
0B3B06 15 
0B3B07 3C 
0B3B08 0B 
0B3B09 CD    0912** CALL    EXPRS           	; Get the filename
0B3B0A DF 
0B3B0B 06 
0B3B0C 0B 
0B3B0D 3E    0913** LD      A,CR			; Terminate the filename with a CR
0B3B0E 0D 
0B3B0F 12    0914** LD      (DE),A
0B3B10 ED    0915** LD      DE,(PAGE_)		; DE: Start of program memory
0B3B11 5B 
0B3B12 14 
0B3B13 51 
0B3B13 0B   
0B3B15 2A    0916** LD      HL,(TOP)		; HL: Top of program memory
0B3B16 17 
0B3B17 51 
0B3B18 0B 
0B3B19 B7    0917** OR      A			; Calculate program size (TOP-PAGE)
0B3B1A ED    0918** SBC     HL,DE
0B3B1B 52 
0B3B1C 44    0919** LD      B,H             	; BC: Length of program in bytes
0B3B1D 4D    0920** LD      C,L
0B3B1E 21    0921** LD      HL,ACCS			; HL: Address of the filename
0B3B1F 00 
0B3B20 4E 
0B3B21 0B 
0B3B22 CD    0922** CALL    OSSAVE			; Call the SAVE routine in patch.asm
0B3B23 F7 
0B3B24 45 
0B3B25 0B 
0B3B26 C3    0923** WARM0:			JP      WARM			; Jump back to the command loop
0B3B27 49 
0B3B28 34 
0B3B29 0B 
             0924** 
             0925** ;
             0926** ; ERROR
             0927** ; Called whenever BASIC needs to halt with an error
             0928** ; Error messages are indexed from 0
             0929** ; Inputs:
             0930** ;  A: Error number
             0931** ;
0B3B2A ED    0932** ERROR_:			LD      SP,(HIMEM)		; Set SP to HIMEM
0B3B2B 7B 
0B3B2C 20 
0B3B2D 51 
0B3B2D 0B   
0B3B2F 21    0933** LD      HL,ERRWDS		; Index into the error string table
0B3B30 13 
0B3B31 38 
0B3B32 0B 
0B3B33 B7    0934** OR      A			; We don't need to search for the first error
0B3B34 28    0935** JR      Z,ERROR1		; So skip the search routine
0B3B35 0A 
             0936** ;
             0937** ; Search the error table for error #A
             0938** ; HL will end up being the pointer into the correct error
             0939** ; There is no bounds checking on this, so invalid error numbers will probably output garbage
             0940** ;
0B3B36 47    0941** LD      B,A             	; Store error number in B
0B3B37 08    0942** EX      AF,AF'			; Store error number in AF'
0B3B38 AF    0943** XOR     A
0B3B39 BE    0944** ERROR0:			CP      (HL)			; Compare the character with 0 (the terminator byte)
0B3B3A 23    0945** INC     HL			; Increment the string pointer
0B3B3B 20    0946** JR      NZ,ERROR0		; Loop until with hit a 0
0B3B3C FC 
0B3B3D 10    0947** DJNZ    ERROR0			; Decrements the error number and loop until 0
0B3B3E FA 
0B3B3F 08    0948** EX      AF,AF'			; Restore the error number from AF'
             0949** ;
             0950** ; At this point HL points to the tokenised error string
             0951** ;
0B3B40 E5    0952** ERROR1:			PUSH    HL			; Stack the error string pointer and fall through to EXTERR
             0953** 
             0954** ;
             0955** ; EXTERR
             0956** ; Inputs:
             0957** ;  A: Error number
             0958** ;
             0959** ; This is the entry point for external errors, i.e. ones not in the ERRWDS table
             0960** ; The error text immediately follows the CALL to EXTERR, for example:
             0961** ; > CALL  EXTERR
             0962** ; > DB    "Silly", 0
             0963** ; So we can get the address of the string by popping the return address off the stack
             0964** ;
0B3B41 E1    0965** EXTERR:			POP     HL			; Pop the error string pointer
0B3B42 22    0966** LD      (ERRTXT),HL		; Store in ERRTXT sysvar
0B3B43 2F 
0B3B44 51 
0B3B45 0B 
0B3B46 ED    0967** LD      SP,(HIMEM)		; Set SP to HIMEM
0B3B47 7B 
0B3B48 20 
0B3B49 51 
0B3B49 0B   
0B3B4B 32    0968** LD      (ERR),A			; Store error number in ERR sysvar
0B3B4C 3F 
0B3B4D 51 
0B3B4E 0B 
0B3B4F CD    0969** CALL    SETLIN			; Get line number
0B3B50 78 
0B3B51 3D 
0B3B52 0B 
0B3B53 22    0970** LD      (ERL),HL		; Store in ERL sysvar
0B3B54 33 
0B3B55 51 
0B3B56 0B 
0B3B57 B7    0971** OR      A			; Is error number 0?
0B3B58 28    0972** JR      Z,ERROR2		; Yes, so skip the next bit as error number 0 is untrappable
0B3B59 0D 
             0973** ;
0B3B5A 2A    0974** LD      HL,(ERRTRP)		; Check whether the error is trapped
0B3B5B 2C 
0B3B5C 51 
0B3B5D 0B 
0B3B5E 7C    0975** LD      A,H
0B3B5F B5    0976** OR      L
0B3B60 E5    0977** PUSH    HL			; HL: Error line
0B3B61 FD    0978** POP     IY			; IY: HL
0B3B62 E1 
0B3B63 C2    0979** JP      NZ,XEQ         	 	; If error trapped, jump to XEQ
0B3B64 60 
0B3B65 0F 
0B3B66 0B 
             0980** ;
0B3B67 21    0981** ERROR2:			LD      HL,0
0B3B68 00 
0B3B69 00 
0B3B6A 00 
0B3B6B 22    0982** LD      (AUTONO),HL		; Cancel AUTO
0B3B6C 29 
0B3B6D 51 
0B3B6E 0B 
0B3B6F 22    0983** LD      (TRACEN),HL     	; Cancel TRACE
0B3B70 26 
0B3B71 51 
0B3B72 0B 
0B3B73 CD    0984** CALL    RESET           	; Reset OPSYS
0B3B74 80 
0B3B75 47 
0B3B76 0B 
0B3B77 CD    0985** CALL    CRLF			; Output newline
0B3B78 11 
0B3B79 3D 
0B3B7A 0B 
0B3B7B CD    0986** CALL    REPORT          	; Output the error message
0B3B7C 4C 
0B3B7D 41 
0B3B7E 0B 
0B3B7F CD    0987** CALL    SAYLN			; Output " at line nnnn" message.
0B3B80 AC 
0B3B81 3D 
0B3B82 0B 
0B3B83 1E    0988** LD      E,0			; Close all files
0B3B84 00 
0B3B85 DC    0989** CALL    C,OSSHUT
0B3B86 F5 
0B3B87 46 
0B3B88 0B 
0B3B89 CD    0990** CALL    CRLF			; Output newline
0B3B8A 11 
0B3B8B 3D 
0B3B8C 0B 
0B3B8D C3    0991** JP      CLOOP			; Back to CLOOP
0B3B8E 4A 
0B3B8F 34 
0B3B90 0B 
             0992** ;
             0993** ; SUBROUTINES:
             0994** ;
             0995** ; LEX - SEARCH FOR KEYWORDS
             0996** ;   Inputs: HL = start of keyword table
             0997** ;           IY = start of match text
             0998** ;  Outputs: If found, Z-flag set, A=token.
             0999** ;           If not found, Z-flag reset, A=(IY).
             1000** ;           IY updated (if NZ, IY unchanged).
             1001** ; Destroys: A,B,H,L,IY,F
             1002** ;
0B3B91 21    1003** LEX:			LD      HL,KEYWDS		; Address of the keywords table
0B3B92 32 
0B3B93 35 
0B3B94 0B 
             1004** ;
0B3B95 FD    1005** LEX0:			LD      A,(IY)			; Fetch the character to match
0B3B96 7E 
0B3B97 00 
0B3B98 46    1006** LD      B,(HL)			; B: The token from the keywords table
0B3B99 23    1007** INC     HL			; Increment the pointer in the keywords table
0B3B9A BE    1008** CP      (HL)			; Compare the first characters
0B3B9B 28    1009** JR      Z,LEX2			; If there is a match, then skip to LEX2
0B3B9C 08 
0B3B9D D8    1010** RET     C               	; No match, so fail
             1011** ;
             1012** ; This snippet of code skips to the next token in the KEYWDS table
             1013** ;
0B3B9E 23    1014** LEX1:			INC     HL			; Increment the pointer
0B3B9F CB    1015** BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0B3BA0 7E 
0B3BA1 28    1016** JR      Z,LEX1			; No, so loop
0B3BA2 FB 
0B3BA3 18    1017** JR      LEX0			; At this point HL is pointing to the start of the next keyword
0B3BA4 F0 
             1018** ;
0B3BA5 FD    1019** LEX2:			PUSH    IY              	; Save the input pointer
0B3BA6 E5 
0B3BA7 23    1020** LEX3:			INC     HL			; Increment the keyword pointer
0B3BA8 CB    1021** BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0B3BA9 7E 
0B3BAA 20    1022** JR      NZ,LEX6         	; Jump to here as we've found a token
0B3BAB 1C 
0B3BAC FD    1023** INC     IY			; Increment the text pointer
0B3BAD 23 
0B3BAE FD    1024** LD      A,(IY)			; Fetch the character
0B3BAF 7E 
0B3BB0 00 
0B3BB1 FE    1025** CP      '.'			; Is it an abbreviated keyword?
0B3BB2 2E 
0B3BB3 28    1026** JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0B3BB4 13 
0B3BB5 BE    1027** CP      (HL)			; Compare with the keywords list
0B3BB6 28    1028** JR      Z,LEX3			; It's a match, so continue checking this keyword
0B3BB7 EF 
0B3BB8 CD    1029** CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B3BB9 45 
0B3BBA 40 
0B3BBB 0B 
0B3BBC 38    1030** JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0B3BBD 04 
             1031** ;
0B3BBE FD    1032** LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0B3BBF E1 
0B3BC0 18    1033** JR      LEX1			; And loop back to start again
0B3BC1 DC 
             1034** ;
             1035** ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
             1036** ; immediately delimited
             1037** ;
0B3BC2 7E    1038** LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0B3BC3 B7    1039** OR      A			; If it is not zero, then...
0B3BC4 20    1040** JR      NZ,LEX4			; Keep searching
0B3BC5 F8 
0B3BC6 FD    1041** DEC     IY			; If it is zero, then skip the input pointer back one byte
0B3BC7 2B 
             1042** ;
             1043** ; We've found a token at this point
             1044** ;
0B3BC8 F1    1045** LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0B3BC9 AF    1046** XOR     A			; Set the Z flag
0B3BCA 78    1047** LD      A,B			; A: The token
0B3BCB C9    1048** RET
             1049** ;
             1050** ; DEL - DELETE A PROGRAM LINE.
             1051** ;   Inputs: HL addresses program line.
             1052** ; Destroys: B,C,F
             1053** ;
             1054** ; This simply erases the line by moving all of the code after the line to be deleted back over
             1055** ; it using an LDIR
             1056** ;
0B3BCC D5    1057** DEL:			PUSH    DE
0B3BCD E5    1058** PUSH    HL
0B3BCE E5    1059** PUSH    HL			; HL: Address of the program line
0B3BCF 06    1060** LD      B,0			; BC: Length of the line
0B3BD0 00 
0B3BD1 4E    1061** LD      C,(HL)
0B3BD2 09    1062** ADD     HL,BC			; HL: Advanced to the start of the next line
0B3BD3 E5    1063** PUSH    HL
0B3BD4 EB    1064** EX      DE,HL			; DE: Pointer to the next line
0B3BD5 2A    1065** LD      HL,(TOP)		; HL: Pointer to the end of the program
0B3BD6 17 
0B3BD7 51 
0B3BD8 0B 
0B3BD9 ED    1066** SBC     HL,DE
0B3BDA 52 
0B3BDB 44    1067** LD      B,H			; BC: Size of block to move
0B3BDC 4D    1068** LD      C,L
0B3BDD E1    1069** POP     HL			; HL: Pointer to next line
0B3BDE D1    1070** POP     DE			; DE: Pointer to this line
0B3BDF ED    1071** LDIR                    	; Delete the line
0B3BE0 B0 
0B3BE1 ED    1072** LD      (TOP),DE		; Adjust TOP
0B3BE2 53 
0B3BE3 17 
0B3BE4 51 
0B3BE4 0B   
0B3BE6 E1    1073** POP     HL
0B3BE7 D1    1074** POP     DE
0B3BE8 C9    1075** RET
             1076** ;
             1077** ;LOAD0 - LOAD A DISK FILE THEN CLEAN.
             1078** ;   Inputs: Filename in ACCS (term CR)
             1079** ; Destroys: A,B,C,D,E,H,L,F
             1080** ;
             1081** ;CLEAN - CHECK FOR BAD PROGRAM, FIND END OF TEXT
             1082** ; AND WRITE FF FF, THEN LOAD (TOP).
             1083** ; Destroys: A,B,C,H,L,F
             1084** ;
0B3BE9 ED    1085** LOAD0: 			LD      DE,(PAGE_)		; DE: Beginning of BASIC program area
0B3BEA 5B 
0B3BEB 14 
0B3BEC 51 
0B3BEC 0B   
0B3BEE 21    1086** LD      HL,-256
0B3BEF 00 
0B3BF0 FF 
0B3BF1 FF 
0B3BF2 39    1087** ADD     HL,SP
0B3BF3 ED    1088** SBC     HL,DE           	; Find available space
0B3BF4 52 
0B3BF5 44    1089** LD      B,H
0B3BF6 4D    1090** LD      C,L
0B3BF7 21    1091** LD      HL,ACCS
0B3BF8 00 
0B3BF9 4E 
0B3BFA 0B 
0B3BFB CD    1092** CALL    OSLOAD          	; Call the OSLOAD function in patch
0B3BFC 5E 
0B3BFD 45 
0B3BFE 0B 
0B3BFF D4    1093** CALL    NC,NEWIT		; If NC then NEW
0B3C00 36 
0B3C01 3C 
0B3C02 0B 
0B3C03 3E    1094** LD      A,0
0B3C04 00 
0B3C05 D2    1095** JP      NC,ERROR_        	; And trigger a "No room" error, otherwise...
0B3C06 2A 
0B3C07 3B 
0B3C08 0B 
             1096** ;
0B3C09 CD    1097** CLEAN:			CALL    SETTOP			; Set TOP sysvar
0B3C0A 15 
0B3C0B 3C 
0B3C0C 0B 
0B3C0D 2B    1098** DEC     HL			; Write out the end of program markers
0B3C0E 36    1099** LD      (HL),-1
0B3C0F FF 
0B3C10 2B    1100** DEC     HL
0B3C11 36    1101** LD      (HL),-1
0B3C12 FF 
0B3C13 18    1102** JR      CLEAR			; Clear all dynamic variables and function/procedure pointers
0B3C14 2B 
             1103** ;
             1104** ; Set the TOP sysvar; the first free location after the end of the current program
             1105** ; Returns:
             1106** ; - HL: TOP
             1107** ;
0B3C15 2A    1108** SETTOP:			LD      HL,(PAGE_)		; Start at beginning of BASIC program area
0B3C16 14 
0B3C17 51 
0B3C18 0B 
0B3C19 01    1109** LD	BC, 0			; BC: 0
0B3C1A 00 
0B3C1B 00 
0B3C1C 00 
0B3C1D 3E    1110** LD      A,CR			; End of line marker
0B3C1E 0D 
0B3C1F 4E    1111** SETOP1:			LD      C,(HL)			; BC: Get first byte of program line (line length)
0B3C20 0C    1112** INC     C			; Check for zero
0B3C21 0D    1113** DEC     C
0B3C22 28    1114** JR      Z,SETOP2		; If it is zero, we've reached the end
0B3C23 0A 
0B3C24 09    1115** ADD     HL,BC			; Skip to next line
0B3C25 2B    1116** DEC     HL			; Check end of previous line
0B3C26 BE    1117** CP      (HL)
0B3C27 23    1118** INC     HL
0B3C28 28    1119** JR      Z,SETOP1		; If CR then loop
0B3C29 F5 
0B3C2A C3    1120** JP      BAD			; If anything else, then something has gone wrong - trip a Bad Program error
0B3C2B C2 
0B3C2C 3A 
0B3C2D 0B 
             1121** ;
0B3C2E 23    1122** SETOP2:			INC     HL             		; Skip the 3 byte end of program marker (&00, &FF, &FF)
0B3C2F 23    1123** INC     HL			; NB: Called from NEWIT
0B3C30 23    1124** INC     HL
0B3C31 22    1125** LD      (TOP),HL		; Store in TOP sysvar
0B3C32 17 
0B3C33 51 
0B3C34 0B 
0B3C35 C9    1126** RET
             1127** ;
             1128** ; NEWIT - NEW PROGRAM THEN CLEAR
             1129** ;   Destroys: H,L
             1130** ;
             1131** ; CLEAR - CLEAR ALL DYNAMIC VARIABLES INCLUDING
             1132** ; FUNCTION AND PROCEDURE POINTERS.
             1133** ;   Destroys: Nothing
             1134** ;
0B3C36 2A    1135** NEWIT:			LD      HL,(PAGE_)		; HL: First byte of BASIC program area
0B3C37 14 
0B3C38 51 
0B3C39 0B 
0B3C3A 36    1136** LD      (HL),0			; Stick a 0 in there
0B3C3B 00 
0B3C3C CD    1137** CALL    SETOP2			; Skip three bytes to get to end of empty BASIC program area and set TOP sysvar
0B3C3D 2E 
0B3C3E 3C 
0B3C3F 0B 
             1138** ;
0B3C40 E5    1139** CLEAR:			PUSH    HL			; Stack the BASIC program pointer
0B3C41 2A    1140** LD      HL,(TOP)		; Get the TOP sysvar - first available byte after BASIC
0B3C42 17 
0B3C43 51 
0B3C44 0B 
0B3C45 22    1141** LD      (LOMEM),HL		; Set the LOMEM sysvar
0B3C46 1A 
0B3C47 51 
0B3C48 0B 
0B3C49 22    1142** LD      (FREE),HL		; And the FREE sysvar with that value
0B3C4A 1D 
0B3C4B 51 
0B3C4C 0B 
0B3C4D 21    1143** LD      HL,DYNVAR		; Get the pointer to the dynamic variable pointers buffer in RAM
0B3C4E 6C 
0B3C4F 50 
0B3C50 0B 
0B3C51 C5    1144** PUSH    BC
             1145** ; LD      B,3*(54+2)		; Loop counter
0B3C52 06    1146** LD      B,54+2*3		; ez80asm doesn't do () in expressions
0B3C53 A8 
0B3C54 36    1147** CLEAR1:			LD      (HL),0			; Clear the dynamic variable pointers
0B3C55 00 
0B3C56 23    1148** INC     HL
0B3C57 10    1149** DJNZ    CLEAR1
0B3C58 FB 
0B3C59 C1    1150** POP     BC
0B3C5A E1    1151** POP     HL			; Restore the BASIC program pointer
0B3C5B C9    1152** RET
             1153** ;
             1154** ;LISTIT - LIST A PROGRAM LINE.
             1155** ;    Inputs: HL addresses line
             1156** ;            DE = line number (binary)
             1157** ;            IX = Pointer to LISTON
             1158** ;             B = FOR/NEXT indent level
             1159** ;             C = REPEAT/UNTIL indent level
             1160** ;  Destroys: A,D,E,B',C',D',E',H',L',IY,F
             1161** ;
0B3C5C E5    1162** LISTIT:			PUSH    HL			; Stack the address of the line
0B3C5D EB    1163** EX      DE,HL			; HL: Line number
0B3C5E C5    1164** PUSH    BC
0B3C5F CD    1165** CALL    PBCD			; Print the line number
0B3C60 C5 
0B3C61 3D 
0B3C62 0B 
0B3C63 C1    1166** POP     BC
0B3C64 E1    1167** POP     HL			; HL: Address of the first token/character
0B3C65 7E    1168** LD      A,(HL)			; Fetch the token
0B3C66 FE    1169** CP      NEXT			; Is it NEXT...
0B3C67 ED 
0B3C68 CC    1170** CALL    Z,INDENT		; Yes, so indent in
0B3C69 F2 
0B3C6A 3C 
0B3C6B 0B 
0B3C6C FE    1171** CP      UNTIL			; Or is it UNTIL...
0B3C6D FD 
0B3C6E CC    1172** CALL    Z,INDENT		; Yes, so indent in
0B3C6F F2 
0B3C70 3C 
0B3C71 0B 
0B3C72 D9    1173** EXX
0B3C73 3E    1174** LD      A,' '
0B3C74 20 
0B3C75 DD    1175** BIT     0,(IX)			; If BIT 0 of LISTON is set
0B3C76 CB 
0B3C77 00 
0B3C78 46 
0B3C79 C4    1176** CALL    NZ,OUTCHR		; Then print a space after the line number
0B3C7A 19 
0B3C7B 3D 
0B3C7C 0B 
0B3C7D 78    1177** LD      A,B			; Fetch the FOR/NEXT indent level
0B3C7E 87    1178** ADD     A,A			; Multiply by 2
0B3C7F DD    1179** BIT     1,(IX)			; If BIT 1 of LISTON is set
0B3C80 CB 
0B3C81 00 
0B3C82 4E 
0B3C83 C4    1180** CALL    NZ,FILL			; Then print the FOR/NEXT indent
0B3C84 B9 
0B3C85 1B 
0B3C86 0B 
0B3C87 79    1181** LD      A,C			; Fetch the REPEAT/UNTIL indent level
0B3C88 87    1182** ADD     A,A			; Multiply by 2
0B3C89 DD    1183** BIT     2,(IX)			; If BIT 2 of LISTON is set
0B3C8A CB 
0B3C8B 00 
0B3C8C 56 
0B3C8D C4    1184** CALL    NZ,FILL			; Then print the REPEAT/UNTIL indent
0B3C8E B9 
0B3C8F 1B 
0B3C90 0B 
0B3C91 D9    1185** EXX
0B3C92 7E    1186** LD      A,(HL)			; Fetch the token
0B3C93 FE    1187** CP      FOR			; Is it FOR?
0B3C94 E3 
0B3C95 CC    1188** CALL    Z,INDENT		; Yes, so indent
0B3C96 F2 
0B3C97 3C 
0B3C98 0B 
0B3C99 FE    1189** CP      REPEAT			; Is it REPEAT?
0B3C9A F5 
0B3C9B CC    1190** CALL    Z,INDENT		; Yes, so indent
0B3C9C F2 
0B3C9D 3C 
0B3C9E 0B 
0B3C9F 1E    1191** LD      E,0			; E: The quote counter - reset to 0
0B3CA0 00 
0B3CA1 7E    1192** LIST8:			LD      A,(HL)			; Fetch a character / token byte
0B3CA2 23    1193** INC     HL
0B3CA3 FE    1194** CP      CR			; Is it end of line?
0B3CA4 0D 
0B3CA5 28    1195** JR      Z,LISTE			; Yes, so finish (DB: Used to jump to CRLF, modified for *EDIT)
0B3CA6 0B 
0B3CA7 FE    1196** CP      34			; Is it a quote character?
0B3CA8 22 
0B3CA9 20    1197** JR      NZ,LIST7		; No, so skip to next bit
0B3CAA 01 
0B3CAB 1C    1198** INC     E			; Otherwise increment quote counter
0B3CAC CD    1199** LIST7:			CALL    LOUT			; Output the character / token
0B3CAD E1 
0B3CAE 3C 
0B3CAF 0B 
0B3CB0 18    1200** JR      LIST8			; And repeat
0B3CB1 EF 
             1201** ;
             1202** ; DB: Modification for *EDIT
             1203** ; Terminate the line with either a CRLF or a NUL character
             1204** ;
0B3CB2 DD    1205** LISTE:			BIT 	3,(IX)			; Are we printing to buffer?
0B3CB3 CB 
0B3CB4 00 
0B3CB5 5E 
0B3CB6 28    1206** JR	Z, CRLF			; Yes, so print a CRLF
0B3CB7 59 
0B3CB8 AF    1207** XOR	A			; Otherwise print a NUL (0)
0B3CB9 C3    1208** JP	OSWRCH
0B3CBA CA 
0B3CBB 42 
0B3CBC 0B 
             1209** ;
             1210** ; Decode the 3 byte GOTO type line number
             1211** ;
0B3CBD E5    1212** PRLINO:			PUSH    HL			; Swap HL and IY
0B3CBE FD    1213** POP     IY			; IY: Pointer to the line number
0B3CBF E1 
0B3CC0 C5    1214** PUSH    BC
0B3CC1 CD    1215** CALL    DECODE			; Decode
0B3CC2 B0 
0B3CC3 0C 
0B3CC4 0B 
0B3CC5 C1    1216** POP     BC
0B3CC6 D9    1217** EXX
0B3CC7 C5    1218** PUSH    BC
0B3CC8 CD    1219** CALL    PBCDL			; Output the line number
0B3CC9 C1 
0B3CCA 3D 
0B3CCB 0B 
0B3CCC C1    1220** POP     BC
0B3CCD D9    1221** EXX
0B3CCE FD    1222** PUSH    IY			; Swap HL and IY
0B3CCF E5 
0B3CD0 E1    1223** POP     HL			; HL: Pointer to the next character in the line
0B3CD1 C9    1224** RET
             1225** ;
             1226** ; DB: Modification for internationalisation
             1227** ;
0B3CD2 CD    1228** PRREM:			CALL	OUT_			; Output the REM token
0B3CD3 36 
0B3CD4 3D 
0B3CD5 0B 
0B3CD6 7E    1229** @@:			LD	A, (HL)			; Fetch the character
0B3CD7 FE    1230** CP	CR			; If it is end of line, then
0B3CD8 0D 
0B3CD9 C8    1231** RET	Z			; we have finished
0B3CDA CD    1232** CALL	OUTCHR			; Ouput the character
0B3CDB 19 
0B3CDC 3D 
0B3CDD 0B 
0B3CDE 23    1233** INC	HL
0B3CDF 18    1234** JR	@B			; And loop
0B3CE0 F5 
             1235** ;
             1236** ; DB: End of modification
             1237** ;
0B3CE1 CB    1238** LOUT:			BIT     0,E			; If the quote counter is odd (bit 1 set) then
0B3CE2 43 
0B3CE3 20    1239** JR      NZ,OUTCHR		; don't tokenise, just output the character
0B3CE4 34 
0B3CE5 FE    1240** CP	REM			; DB: Is it REM
0B3CE6 F4 
0B3CE7 28    1241** JR	Z, PRREM		; DB: Yes so jump to the special case for REM
0B3CE8 E9 
0B3CE9 FE    1242** CP      LINO_MN			; Is it a line number (following GOTO/GOSUB etc)?
0B3CEA 8D 
0B3CEB 28    1243** JR      Z,PRLINO		; Yes, so decode and print the line number
0B3CEC D0 
0B3CED CD    1244** CALL    OUT_			; Output a character / keyword
0B3CEE 36 
0B3CEF 3D 
0B3CF0 0B 
0B3CF1 7E    1245** LD      A,(HL)			; Fetch the next character
             1246** ;
             1247** ; This block of code handles the indentation
             1248** ; B: Counter for FOR/NEXT indent
             1249** ; C: Counter for REPEAT/UNTIL indent
             1250** ;
0B3CF2 D9    1251** INDENT:			EXX
0B3CF3 FE    1252** CP      FOR			; If the token is FOR
0B3CF4 E3 
0B3CF5 28    1253** JR      Z,IND1			; Then INC B
0B3CF6 09 
0B3CF7 FE    1254** CP      NEXT			; If it is NEXT
0B3CF8 ED 
0B3CF9 20    1255** JR      NZ,IND2_		; Then...
0B3CFA 06 
0B3CFB 05    1256** DEC     B			; DEC B
0B3CFC F2    1257** JP      P,IND2_			; If we have gone below 0 then
0B3CFD 01 
0B3CFE 3D 
0B3CFF 0B 
0B3D00 04    1258** IND1:			INC     B			; Increment back to 0
             1259** ;
0B3D01 FE    1260** IND2_:			CP      REPEAT			; If the token is REPEAT
0B3D02 F5 
0B3D03 28    1261** JR      Z,IND3			; Then INC C
0B3D04 09 
0B3D05 FE    1262** CP      UNTIL			; If it is UNTIL
0B3D06 FD 
0B3D07 20    1263** JR      NZ,IND4			; Then...
0B3D08 06 
0B3D09 0D    1264** DEC     C			; DEC C
0B3D0A F2    1265** JP      P,IND4			; If we have gone below 0 then
0B3D0B 0F 
0B3D0C 3D 
0B3D0D 0B 
0B3D0E 0C    1266** IND3:			INC     C			; Incremet back to 0
0B3D0F D9    1267** IND4:			EXX
0B3D10 C9    1268** RET
             1269** ;
             1270** ;CRLF - SEND CARRIAGE RETURN, LINE FEED.
             1271** ;  Destroys: A,F
             1272** ;OUTCHR - OUTPUT A CHARACTER TO CONSOLE.
             1273** ;    Inputs: A = character
             1274** ;  Destroys: A,F
             1275** ;
0B3D11 3E    1276** CRLF:			LD      A,CR			; Output CR
0B3D12 0D 
0B3D13 CD    1277** CALL    OUTCHR
0B3D14 19 
0B3D15 3D 
0B3D16 0B 
0B3D17 3E    1278** LD      A,LF			; Output LF
0B3D18 0A 
             1279** ;
0B3D19 CD    1280** OUTCHR:			CALL    OSWRCH			; Output the character in A
0B3D1A CA 
0B3D1B 42 
0B3D1C 0B 
0B3D1D D6    1281** SUB     CR			; Check for CR
0B3D1E 0D 
0B3D1F 28    1282** JR      Z,CARRET		; If it is CR then A will be 0, this will clear the count
0B3D20 06 
0B3D21 D8    1283** RET     C              		; If it is less than CR, it is non-printing, so don't increment the count
0B3D22 3A    1284** LD      A,(COUNT)		; Increment the count
0B3D23 3D 
0B3D24 51 
0B3D25 0B 
0B3D26 3C    1285** INC     A
             1286** ;
0B3D27 32    1287** CARRET:			LD      (COUNT),A		; Store the new count value
0B3D28 3D 
0B3D29 51 
0B3D2A 0B 
0B3D2B C8    1288** RET     Z			; Return if the count has wrapped to 0
0B3D2C E5    1289** PUSH    HL			; Now check if count = print width
0B3D2D 2A    1290** LD      HL,(WIDTH)		; Get the print width; it's a byte value, so
0B3D2E 3E 
0B3D2F 51 
0B3D30 0B 
0B3D31 BD    1291** CP      L			; L is the width. Compare it with count.
0B3D32 E1    1292** POP     HL
0B3D33 C0    1293** RET     NZ			; If we've not hit print width, then just return
0B3D34 18    1294** JR      CRLF			; Otherwise output CRLF
0B3D35 DB 
             1295** ;
             1296** ; OUT - SEND CHARACTER OR KEYWORD
             1297** ;   Inputs: A = character (>=10, <128)
             1298** ;           A = Token (<10, >=128)
             1299** ;  Destroys: A,F
             1300** ;
0B3D36 FE    1301** OUT_:			CP      138			; Neat trick to do condition: If A >= 10 or < 128 then PE flag is set
0B3D37 8A 
0B3D38 EA    1302** JP      PE,OUTCHR		; If so, then it's a character, so just output it
0B3D39 19 
0B3D3A 3D 
0B3D3B 0B 
             1303** ;
             1304** ; This bit looks up the character in the KEYWDS token table and expands it
             1305** ; Note the CP 138; this sets the overflow flag as follows:
             1306** ;
             1307** ; NB:
             1308** ;  1. Any 8-bit number between 128 and 255 is negative (two's complement) so 138 is -118, 128 = -128
             1309** ;  2. CP is effectively a SUB; sets the flags without affecting A
             1310** ;  3. The operation n - -118 ~ n + 118
             1311** ;
             1312** ; So:
             1313** ;  *   9 CP 138 ~    9 + 118 = 127 = no overflow : token
             1314** ;  *  10 CP 138 ~   10 + 118 = 128 =    overflow : character
             1315** ;  * 127 CP 138 ~  127 + 118 = 245 =    overflow : character
             1316** ;  * 128 CP 138 ~ -128 + 118 = -10 = no overflow : token
             1317** ;
0B3D3C C5    1318** PUSH    BC			; Preserve BC and HL
0B3D3D E5    1319** PUSH    HL
0B3D3E 21    1320** LD      HL,KEYWDS		; The list of tokens and keywords
0B3D3F 32 
0B3D40 35 
0B3D41 0B 
0B3D42 01    1321** LD      BC,KEYWDL		; The length of the keyword list
0B3D43 DF 
0B3D44 02 
0B3D45 00 
0B3D46 ED    1322** CPIR				; We can just do a straight CPIR as the token characters are unique in the list
0B3D47 B1 
             1323** ;							; At this point HL points to the next byte, the first character of the token
0B3D48 7E    1324** TOKEN1:			LD      A,(HL)			; Fetch the character
0B3D49 23    1325** INC     HL			; Increment to the next byte in the token table
0B3D4A FE    1326** CP      138			; If A >= 10 or < 128, i.e. we've not hit the token code for the next token
0B3D4B 8A 
0B3D4C F5    1327** PUSH    AF			; Then...
0B3D4D EC    1328** CALL    PE,OUTCHR		; Output the character...
0B3D4E 19 
0B3D4F 3D 
0B3D50 0B 
0B3D51 F1    1329** POP     AF			;
0B3D52 EA    1330** JP      PE,TOKEN1		; And loop to the next character
0B3D53 48 
0B3D54 3D 
0B3D55 0B 
0B3D56 E1    1331** POP     HL			; Done, so tidy up the stack and exit
0B3D57 C1    1332** POP     BC
0B3D58 C9    1333** RET
             1334** ;
             1335** ; FINDL - FIND PROGRAM LINE
             1336** ;   Inputs: HL = line number (binary)
             1337** ;  Outputs: HL addresses line (if found)
             1338** ;           DE = line number
             1339** ;           Z-flag set if found.
             1340** ; Destroys: A,B,C,D,E,H,L,F
             1341** ;
0B3D59 EB    1342** FINDL:			EX      DE,HL			; DE: Line number (binary)
0B3D5A 2A    1343** LD      HL,(PAGE_)		; HL: Top of BASIC program area
0B3D5B 14 
0B3D5C 51 
0B3D5D 0B 
0B3D5E AF    1344** XOR     A               	;  A: 0
0B3D5F BE    1345** CP      (HL)			; Check for end of program marker
0B3D60 3C    1346** INC     A			;  A: 1
0B3D61 D0    1347** RET     NC			; Return with 1 if 0
0B3D62 AF    1348** XOR     A               	; Clear the carry flag
             1349** ;			LD      B,A			;  B: 0
0B3D63 01    1350** LD	BC, 0			; BC: 0
0B3D64 00 
0B3D65 00 
0B3D66 00 
             1351** ;
0B3D67 4E    1352** FINDL1:			LD      C,(HL)			;  C: The line length
0B3D68 E5    1353** PUSH    HL			; Stack the current program counter
0B3D69 23    1354** INC     HL			; Skip to the line number bytes
0B3D6A 7E    1355** LD      A,(HL)			; Fetch the line number (in binary) from the BASIC line in HL
0B3D6B 23    1356** INC     HL
0B3D6C 66    1357** LD      H,(HL)
0B3D6D 6F    1358** LD      L,A
0B3D6E 52    1359** SBC.S   HL,DE			; Compare with the line number we're searching for
0B3D6F ED 
0B3D70 52 
0B3D71 E1    1360** POP     HL			; Get the current program counter
0B3D72 D0    1361** RET     NC              	; Then return if found or past (Z flag will be set if line number matches)
0B3D73 09    1362** ADD     HL,BC			; Skip to the next line (B was set to 0 before the loop was entered)
0B3D74 C3    1363** JP      FINDL1			; And loop
0B3D75 67 
0B3D76 3D 
0B3D77 0B 
             1364** ;
             1365** ; SETLIN - Search program for line containing address
             1366** ;          Update (LINENO)
             1367** ;   Inputs: Address in (ERRLIN)
             1368** ;  Outputs: Line number in HL and (LINENO)
             1369** ; Destroys: B,C,D,E,H,L,F
             1370** ;
0B3D78 01    1371** SETLIN:			LD	BC, 0			; Zero BC for later
0B3D79 00 
0B3D7A 00 
0B3D7B 00 
             1372** ;			LD      B, 0			; Zero B for later
0B3D7C ED    1373** LD      DE, (ERRLIN)		; DE: Address of line
0B3D7D 5B 
0B3D7E 35 
0B3D7F 51 
0B3D7F 0B   
0B3D81 2A    1374** LD      HL, (PAGE_)		; HL: Start of user program area
0B3D82 14 
0B3D83 51 
0B3D84 0B 
0B3D85 B7    1375** OR      A			; Do a 24 bit compare without destroying HL
0B3D86 ED    1376** SBC     HL, DE			;  Z: DE = HL, NC: DE <= HL
0B3D87 52 
0B3D88 19    1377** ADD     HL, DE			;  C: DE > HL
0B3D89 30    1378** JR      NC, SET3		; So skip, as the address is less than or equal to the top of program area
0B3D8A 1B 
             1379** ;
0B3D8B 4E    1380** SET1:			LD      C, (HL)			; Get the length of the line; zero indicates the end of the BASIC program
0B3D8C 0C    1381** INC     C			; This is a way to check for zero without using the accumulator
0B3D8D 0D    1382** DEC     C			; If it is zero, then...
0B3D8E 28    1383** JR      Z, SET3			; We've reached the end of the current BASIC program, not found the line
0B3D8F 16 
0B3D90 09    1384** ADD     HL, BC			; Skip to the next line (we set B to 0 at the top of this subroutine)
0B3D91 ED    1385** SBC     HL, DE			; Do a 24-bit compare; the previous ADD will have cleared the carry flag
0B3D92 52 
0B3D93 19    1386** ADD     HL, DE
0B3D94 38    1387** JR      C, SET1			; Loop whilst DE (the address to search for) is > HL (the current line)
0B3D95 F5 
0B3D96 ED    1388** SBC     HL, BC			; We've found it, so back up to the beginning of the line
0B3D97 42 
0B3D98 23    1389** INC     HL			; Skip the length counter
0B3D99 11    1390** LD	DE, 0			; Zero DE
0B3D9A 00 
0B3D9B 00 
0B3D9C 00 
0B3D9D 5E    1391** LD      E, (HL)          	; Fetch the line number
0B3D9E 23    1392** INC     HL
0B3D9F 56    1393** LD      D, (HL)
0B3DA0 EB    1394** EX      DE, HL			; HL: The line number
0B3DA1 22    1395** SET2:			LD      (LINENO), HL		; Store in the variable LINENO
0B3DA2 23 
0B3DA3 51 
0B3DA4 0B 
0B3DA5 C9    1396** RET
             1397** ;
0B3DA6 21    1398** SET3:			LD      HL, 0			; We've not found the line at this point so
0B3DA7 00 
0B3DA8 00 
0B3DA9 00 
0B3DAA 18    1399** JR      SET2			; Set LINENO to 0
0B3DAB F5 
             1400** ;
             1401** ;SAYLN - PRINT " at line nnnn" MESSAGE.
             1402** ;  Outputs: Carry=0 if line number is zero.
             1403** ;           Carry=1 if line number is non-zero.
             1404** ; Destroys: A,B,C,D,E,H,L,F
             1405** ;
0B3DAC 2A    1406** SAYLN:			LD      HL,(LINENO)		; Get the LINENO sysvar
0B3DAD 23 
0B3DAE 51 
0B3DAF 0B 
0B3DB0 7C    1407** LD      A,H			; If it is zero then
0B3DB1 B5    1408** OR      L
0B3DB2 C8    1409** RET     Z			; Don't need to do anything; return with F:C set to 0
0B3DB3 CD    1410** CALL    TELL			; Output the error message
0B3DB4 5A 
0B3DB5 41 
0B3DB6 0B 
0B3DB7 20    1411** DB    	" at line ", 0
0B3DB8 61 
0B3DB9 74 
0B3DBA 20 
0B3DBA 6C   
0B3DBB 69 
0B3DBC 6E 
0B3DBD 65 
0B3DBD 20   
0B3DBE 00 
0B3DC1 0E    1412** PBCDL:			LD      C,0			; C: Leading character (NUL)
0B3DC2 00 
0B3DC3 18    1413** JR      PBCD0			; Output the line number; return with F:C set to 1
0B3DC4 02 
             1414** ;
             1415** ; PBCD - PRINT NUMBER AS DECIMAL INTEGER.
             1416** ;   Inputs: HL = number (binary).
             1417** ;  Outputs: Carry = 1
             1418** ; Destroys: A,B,C,D,E,H,L,F
             1419** ;
0B3DC5 0E    1420** PBCD:			LD      C,' '			; C: Leading character (" ")
0B3DC6 20 
0B3DC7 06    1421** PBCD0:			LD      B,5			; Number of digits in result
0B3DC8 05 
0B3DC9 11    1422** LD      DE,10000		; Start off with the 10,000 column
0B3DCA 10 
0B3DCB 27 
0B3DCC 00 
0B3DCD AF    1423** PBCD1:			XOR     A			; Counter
0B3DCE ED    1424** PBCD2:			SBC     HL,DE			; Loop and count how many 10,000s we have
0B3DCF 52 
0B3DD0 3C    1425** INC     A
0B3DD1 30    1426** JR      NC,PBCD2
0B3DD2 FB 
0B3DD3 19    1427** ADD     HL,DE			; The loop overruns by one, so adjust here
0B3DD4 3D    1428** DEC     A			; A: Number of 10,000s
0B3DD5 28    1429** JR      Z,PBCD3			; If it is 0, then skip the next bit
0B3DD6 04 
0B3DD7 CB    1430** SET     4,C			; C: Set to '0' ASCII (30h)
0B3DD8 E1 
0B3DD9 CB    1431** SET     5,C
0B3DDA E9 
0B3DDB B1    1432** PBCD3:			OR      C			; A is then an ASCII character, or 00h if we've not processed any non-zero digits yet
0B3DDC C4    1433** CALL    NZ,OUTCHR		; If it is not a leading NUL character then output it
0B3DDD 19 
0B3DDE 3D 
0B3DDF 0B 
0B3DE0 78    1434** LD      A,B			; If on first transition, skip this
0B3DE1 FE    1435** CP      5			; TODO: Need to find out why
0B3DE2 05 
0B3DE3 28    1436** JR      Z,PBCD4
0B3DE4 06 
0B3DE5 29    1437** ADD     HL,HL			; HL x  2 : We shift the number being tested left,
0B3DE6 54    1438** LD      D,H			;         : rather than shifting DE right
0B3DE7 5D    1439** LD      E,L			;         : This makes a lot of sense
0B3DE8 29    1440** ADD     HL,HL			; HL x  4
0B3DE9 29    1441** ADD     HL,HL			; HL x  8
0B3DEA 19    1442** ADD     HL,DE			; HL x 10
0B3DEB 11    1443** PBCD4:			LD      DE,1000			; Set the column heading to 1,000s for subsequent runs
0B3DEC E8 
0B3DED 03 
0B3DEE 00 
0B3DEF 10    1444** DJNZ    PBCD1			; Loop until done
0B3DF0 DC 
0B3DF1 37    1445** SCF				; SCF set for SAYLN in this module
0B3DF2 C9    1446** RET
             1447** ;
             1448** ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
             1449** ;   Inputs: HL, IY as returned from GETVAR (NZ).
             1450** ;  Outputs: As GETVAR.
             1451** ; Destroys: everything
             1452** ;
0B3DF3 CD    1453** PUTVAR:			CALL    CREATE			; Create the variable
0B3DF4 78 
0B3DF5 3F 
0B3DF6 0B 
0B3DF7 FD    1454** LD      A,(IY)			; Fetch the next character
0B3DF8 7E 
0B3DF9 00 
0B3DFA FE    1455** CP      '('			; Check for bad use of array
0B3DFB 28 
0B3DFC 20    1456** JR      NZ,GETVZ        	; It's fine, so set the exit conditions
0B3DFD 70 
0B3DFE 3E    1457** ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
0B3DFF 0E 
0B3E00 C3    1458** ERROR3:			JP      ERROR_
0B3E01 2A 
0B3E02 3B 
0B3E03 0B 
             1459** ;
             1460** ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
             1461** ;   Inputs: IY addresses first character.
             1462** ;  Outputs: Carry set and NZ if illegal character.
             1463** ;           Z-flag set if variable found, then:
             1464** ;            A = variable type (0,4,5,128 or 129)
             1465** ;            HL = IX = variable pointer.
             1466** ;            IY updated
             1467** ;           If Z-flag & carry reset, then:
             1468** ;            HL, IY set for subsequent PUTVAR call.
             1469** ; Destroys: everything
             1470** ;
0B3E04 FD    1471** GETVAR:			LD      A,(IY)			; Get the first character
0B3E05 7E 
0B3E06 00 
0B3E07 FE    1472** CP      '$'			; Is it a string?
0B3E08 24 
0B3E09 28    1473** JR      Z,GETV4			; Yes, so branch here
0B3E0A 69 
0B3E0B FE    1474** CP      '!'			; Is it indirection (32-bit)?
0B3E0C 21 
0B3E0D 28    1475** JR      Z,GETV5			; Yes, so branch here
0B3E0E 69 
0B3E0F FE    1476** CP      '?'			; Is it indirection (8-bit)?
0B3E10 3F 
0B3E11 28    1477** JR      Z,GETV6			; Yes, so branch here
0B3E12 69 
             1478** ;
0B3E13 CD    1479** CALL    LOCATE			; Locate the variable
0B3E14 E2 
0B3E15 3E 
0B3E16 0B 
0B3E17 C0    1480** RET     NZ			; And exit here if not found
             1481** ;
             1482** ; At this point:
             1483** ;  HL: Address of variable in memory
             1484** ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
             1485** ;
0B3E18 FD    1486** LD      A,(IY)			; Further checks
0B3E19 7E 
0B3E1A 00 
0B3E1B FE    1487** CP      '('             	; Is it an array?
0B3E1C 28 
0B3E1D 20    1488** JR      NZ,GETVX        	; No, so exit
0B3E1E 47 
             1489** ;
             1490** ; We are processing an array at this point
             1491** ;
0B3E1F D5    1492** PUSH    DE              	; Save the variable type (in D)
0B3E20 7E    1493** LD      A,(HL)          	; Fetch the number of dimensions
0B3E21 B7    1494** OR      A
0B3E22 28    1495** JR      Z,ARRAY			; If there are none, then Error: 'Array'
0B3E23 DA 
0B3E24 23    1496** INC     HL			;
0B3E25 11    1497** LD      DE,0            	; Accumulator
0B3E26 00 
0B3E27 00 
0B3E28 00 
0B3E29 F5    1498** PUSH    AF
0B3E2A FD    1499** INC     IY              	; Skip "("
0B3E2B 23 
0B3E2C 18    1500** JR      GETV3
0B3E2D 05 
             1501** ;
0B3E2E F5    1502** GETV2:			PUSH    AF
0B3E2F CD    1503** CALL    COMMA
0B3E30 EC 
0B3E31 0D 
0B3E32 0B 
0B3E33 E5    1504** GETV3:			PUSH    HL
0B3E34 D5    1505** PUSH    DE
0B3E35 CD    1506** CALL    EXPRI			; Get the subscript
0B3E36 D4 
0B3E37 06 
0B3E38 0B 
0B3E39 D9    1507** EXX
0B3E3A D1    1508** POP     DE
0B3E3B E3    1509** EX      (SP),HL
0B3E3C 4E    1510** LD      C,(HL)
0B3E3D 23    1511** INC     HL
0B3E3E 46    1512** LD      B,(HL)
0B3E3F 23    1513** INC     HL
0B3E40 E3    1514** EX      (SP),HL
0B3E41 EB    1515** EX      DE,HL
0B3E42 D5    1516** PUSH    DE
0B3E43 CD    1517** CALL    MUL16			; HL=HL*BC
0B3E44 3C 
0B3E45 1C 
0B3E46 0B 
0B3E47 D1    1518** POP     DE
0B3E48 19    1519** ADD     HL,DE
0B3E49 EB    1520** EX      DE,HL
0B3E4A B7    1521** OR      A
0B3E4B ED    1522** SBC     HL,BC
0B3E4C 42 
0B3E4D 3E    1523** LD      A,15
0B3E4E 0F 
0B3E4F 30    1524** JR      NC,ERROR3		; Throw a "Subscript" error
0B3E50 AF 
0B3E51 E1    1525** POP     HL
0B3E52 F1    1526** POP     AF
0B3E53 3D    1527** DEC     A               	; Dimension counter
0B3E54 20    1528** JR      NZ,GETV2
0B3E55 D8 
0B3E56 CD    1529** CALL    BRAKET          	; Check for closing bracket
0B3E57 F9 
0B3E58 0D 
0B3E59 0B 
0B3E5A F1    1530** POP     AF              	; Restore the type
0B3E5B E5    1531** PUSH    HL
0B3E5C CD    1532** CALL    X4OR5           	; DE=DE*n
0B3E5D 2F 
0B3E5E 1C 
0B3E5F 0B 
0B3E60 E1    1533** POP     HL
0B3E61 19    1534** ADD     HL,DE
0B3E62 57    1535** LD      D,A             	; The type
0B3E63 FD    1536** LD      A,(IY)
0B3E64 7E 
0B3E65 00 
0B3E66 FE    1537** GETVX:			CP      '?'
0B3E67 3F 
0B3E68 28    1538** JR      Z,GETV9
0B3E69 1E 
0B3E6A FE    1539** CP      '!'
0B3E6B 21 
0B3E6C 28    1540** JR      Z,GETV8
0B3E6D 16 
0B3E6E E5    1541** GETVZ:			PUSH    HL              	; Set exit conditions
0B3E6F DD    1542** POP     IX
0B3E70 E1 
0B3E71 7A    1543** LD      A,D
0B3E72 BF    1544** CP      A
0B3E73 C9    1545** RET
             1546** ;
             1547** ; Process strings, unary & binary indirection:
             1548** ;
0B3E74 3E    1549** GETV4:			LD      A,128           	; Static strings
0B3E75 80 
0B3E76 18    1550** JR      GETV7
0B3E77 05 
             1551** ;
0B3E78 3E    1552** GETV5:			LD      A,4             	; Unary 32-bit indirection
0B3E79 04 
0B3E7A 18    1553** JR      GETV7
0B3E7B 01 
             1554** ;
0B3E7C AF    1555** GETV6:			XOR     A               	; Unary 8-bit indirection
             1556** ;
0B3E7D 21    1557** GETV7:			LD      HL,0
0B3E7E 00 
0B3E7F 00 
0B3E80 00 
0B3E81 F5    1558** PUSH    AF
0B3E82 18    1559** JR      GETV0
0B3E83 24 
             1560** ;
0B3E84 06    1561** GETV8:			LD      B,4             	; Binary 32-bt indirection
0B3E85 04 
0B3E86 18    1562** JR      GETVA
0B3E87 02 
             1563** ;
0B3E88 06    1564** GETV9:			LD      B,0             	; Binary 8-bit indirection
0B3E89 00 
             1565** ;
0B3E8A E5    1566** GETVA:			PUSH    HL
0B3E8B DD    1567** POP     IX
0B3E8C E1 
0B3E8D 7A    1568** LD      A,D            		; Fetch the variable type
0B3E8E FE    1569** CP      129			; Is it a string?
0B3E8F 81 
0B3E90 C8    1570** RET     Z               	; Yes, so exit here
0B3E91 C5    1571** PUSH    BC
0B3E92 CD    1572** CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
0B3E93 E0 
0B3E94 07 
0B3E95 0B 
0B3E96 CD    1573** CALL    SFIX
0B3E97 2C 
0B3E98 0A 
0B3E99 0B 
0B3E9A 7D    1574** LD	A,L
0B3E9B D9    1575** EXX
0B3E9C 22    1576** LD	(R0+0),HL
0B3E9D 4A 
0B3E9E 51 
0B3E9F 0B 
0B3EA0 32    1577** LD	(R0+2),A
0B3EA1 4C 
0B3EA2 51 
0B3EA3 0B 
0B3EA4 2A    1578** LD	HL,(R0)			; HL: 24-bit address of the variable in memory
0B3EA5 4A 
0B3EA6 51 
0B3EA7 0B 
             1579** ;
0B3EA8 E5    1580** GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
0B3EA9 FD    1581** INC     IY
0B3EAA 23 
0B3EAB CD    1582** CALL    ITEMI
0B3EAC EF 
0B3EAD 06 
0B3EAE 0B 
0B3EAF 7D    1583** LD	A,L			;  A: The MSB of the address
0B3EB0 D9    1584** EXX
0B3EB1 22    1585** LD	(R0+0),HL		; HL: The LSW of the address
0B3EB2 4A 
0B3EB3 51 
0B3EB4 0B 
0B3EB5 32    1586** LD	(R0+2),A		; R0: L'HL or the 24-bit address
0B3EB6 4C 
0B3EB7 51 
0B3EB8 0B 
0B3EB9 D1    1587** POP     DE
0B3EBA F1    1588** POP     AF
0B3EBB 2A    1589** LD	HL,(R0)			; HL: L'HL
0B3EBC 4A 
0B3EBD 51 
0B3EBE 0B 
0B3EBF 19    1590** ADD     HL,DE
0B3EC0 E5    1591** PUSH    HL
0B3EC1 DD    1592** POP     IX
0B3EC2 E1 
0B3EC3 BF    1593** CP      A
0B3EC4 C9    1594** RET
             1595** ;
             1596** ;GETDEF - Find entry for FN or PROC in dynamic area.
             1597** ;   Inputs: IY addresses byte following "DEF" token.
             1598** ;  Outputs: Z flag set if found
             1599** ;           Carry set if neither FN or PROC first.
             1600** ;           If Z: HL points to entry
             1601** ;                 IY addresses delimiter
             1602** ; Destroys: A,D,E,H,L,IY,F
             1603** ;
0B3EC5 FD    1604** GETDEF:			LD      A,(IY+1)		; Get the next character from the tokenised line (the start of the procedure name)
0B3EC6 7E 
0B3EC7 01 
0B3EC8 CD    1605** CALL    RANGE1			; Is it in range: "0" to "9", "A" to "Z", "a' to "z", "@", "_" or "`"?
0B3EC9 45 
0B3ECA 40 
0B3ECB 0B 
0B3ECC D8    1606** RET     C			; No so return with C set
0B3ECD FD    1607** LD      A,(IY)			; Fetch the current character from the tokenised line
0B3ECE 7E 
0B3ECF 00 
0B3ED0 21    1608** LD      HL,FNPTR		; HL: Address of the dynamic function pointer in ram.asm
0B3ED1 0E 
0B3ED2 51 
0B3ED3 0B 
0B3ED4 FE    1609** CP      FN			; Is it the token FN?
0B3ED5 A4 
0B3ED6 28    1610** JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3ED7 4A 
0B3ED8 21    1611** LD      HL,PROPTR		; HL: Address of the dynamic procedure pointer in ram.asm
0B3ED9 11 
0B3EDA 51 
0B3EDB 0B 
0B3EDC FE    1612** CP      PROC			; Is it the token PROC?
0B3EDD F2 
0B3EDE 28    1613** JR      Z,LOC2			; Yes, so skip to LOC2 with that pointer to find a match
0B3EDF 42 
0B3EE0 37    1614** SCF				; No, so just return with C set
0B3EE1 C9    1615** RET
             1616** ;
             1617** ; LOCATE - Try to locate variable name in static or dynamic variables.
             1618** ; If illegal first character return carry, non-zero.
             1619** ; If found, return no-carry, zero.
             1620** ; If not found, return no-carry, non-zero.
             1621** ;   Inputs: IY=Addresses first character of name.
             1622** ;            A=(IY)
             1623** ;  Outputs:  F=Z set if found, then:
             1624** ;           IY=addresses terminator
             1625** ;           HL=addresses location of variable
             1626** ;            D=type of variable: 4 = integer
             1627** ;                                5 = floating point
             1628** ;                              129 = string
             1629** ; Destroys: A,D,E,H,L,IY,F
             1630** ;
             1631** ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
             1632** ; They can contain any alphanumeric character and underscore (_)
             1633** ; String variables are postfixed with the dollar ($) character
             1634** ; Integer variables are postfixed with the percent (%) character
             1635** ; Static integer variables are named @%, A% to Z%
             1636** ; All other variables are dynamic
             1637** ;
0B3EE2 D6    1638** LOCATE:			SUB     '@'			; Check for valid range
0B3EE3 40 
0B3EE4 D8    1639** RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
0B3EE5 21    1640** LD      HL, 0			; Clear HL
0B3EE6 00 
0B3EE7 00 
0B3EE8 00 
0B3EE9 FE    1641** CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
0B3EEA 1B 
0B3EEB 30    1642** JR      NC,LOC0         	; Then branch here
0B3EEC 1E 
0B3EED 6F    1643** LD	L, A			; HL = A
0B3EEE FD    1644** LD      A,(IY+1)        	; Check the 2nd character
0B3EEF 7E 
0B3EF0 01 
0B3EF1 FE    1645** CP      '%'			; If not "%" then it is not static...
0B3EF2 25 
0B3EF3 20    1646** JR      NZ,LOC1         	; Branch here
0B3EF4 21 
0B3EF5 FD    1647** LD      A,(IY+2)		; Check the 3rd character
0B3EF6 7E 
0B3EF7 02 
0B3EF8 FE    1648** CP      '('			; If it is "(" (array) then it is not static...
0B3EF9 28 
0B3EFA 28    1649** JR      Z,LOC1          	; Branch here
0B3EFB 1A 
             1650** ;
             1651** ; At this point we're dealing with a static variable
             1652** ;
0B3EFC 29    1653** ADD     HL,HL			; HL: Variable index * 4
0B3EFD 29    1654** ADD	HL,HL
0B3EFE 11    1655** LD      DE,STAVAR       	; The static variable area in memory
0B3EFF 00 
0B3F00 50 
0B3F01 0B 
0B3F02 19    1656** ADD     HL,DE			; HL: The address of the static variable
0B3F03 FD    1657** INC     IY			; Skip the program pointer past the static variable name
0B3F04 23 
0B3F05 FD    1658** INC     IY
0B3F06 23 
0B3F07 16    1659** LD      D,4             	; Set the type to be integer
0B3F08 04 
0B3F09 AF    1660** XOR     A			; Set the Z flag
0B3F0A C9    1661** RET
             1662** ;
             1663** ; At this point it's potentially a dynamic variable, just need to do a few more checks
             1664** ;
0B3F0B FE    1665** LOC0:			CP      '_'-'@'			; Check the first character is in
0B3F0C 1F 
0B3F0D D8    1666** RET     C			; the range "_" to
0B3F0E FE    1667** CP      'z'-'@'+1		; "z" (lowercase characters only)
0B3F0F 3B 
0B3F10 3F    1668** CCF				; If it is not in range then
0B3F11 3D    1669** DEC     A               	; Set NZ flag and
0B3F12 D8    1670** RET     C			; Exit here
0B3F13 D6    1671** SUB     3			; This brings it in the range of 27 upwards (need to confirm)
0B3F14 03 
0B3F15 6F    1672** LD	L, A			; HL = A
             1673** ;
             1674** ; Yes, it's definitely a dynamic variable at this point...
             1675** ;
0B3F16 7D    1676** LOC1:			LD	A, L			; Fetch variable index
0B3F17 87    1677** ADD	A, A			; x 2
0B3F18 85    1678** ADD	A, L			; x 3
0B3F19 D6    1679** SUB	3			; Subtract 2 TODO: Should be 3
0B3F1A 03 
0B3F1B 6F    1680** LD	L, A
0B3F1C 11    1681** LD      DE, DYNVAR       	; The dynamic variable storage
0B3F1D 6C 
0B3F1E 50 
0B3F1F 0B 
0B3F20 D8    1682** RET	C			; Bounds check to trap for variable '@'
0B3F21 19    1683** ADD     HL, DE			; HL: Address of first entry
             1684** ;
             1685** ; Loop through the linked list of variables to find a match
             1686** ;
0B3F22 ED    1687** LOC2:			LD	DE, (HL)		; Fetch the original pointer
0B3F23 17 
0B3F24 E5    1688** PUSH	HL			; Need to preserve HL for LOC6
0B3F25 AF    1689** XOR	A			; Reset carry flag
0B3F26 ED    1690** SBC	HL, HL			; Set HL to 0
0B3F27 62 
0B3F28 ED    1691** SBC	HL, DE			; Compare with 0
0B3F29 52 
0B3F2A E1    1692** POP	HL			; Restore the original pointer
0B3F2B 28    1693** JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
0B3F2C 49 
             1694** ; LD	HL, DE			; Make a copy of this pointer in HL
0B3F2D D5    1695** push de
0B3F2E E1    1696** pop hl ; how was that even possible?
0B3F2F 23    1697** INC     HL              	; Skip the link (24-bits)
0B3F30 23    1698** INC     HL
0B3F31 23    1699** INC	HL			; HL: Address of the variable name in DYNVARS
0B3F32 FD    1700** PUSH    IY			; IY: Address of the variable name in the program
0B3F33 E5 
             1701** ;
0B3F34 7E    1702** LOC3:			LD      A,(HL)         		; Compare
0B3F35 23    1703** INC     HL
0B3F36 FD    1704** INC     IY
0B3F37 23 
0B3F38 FD    1705** CP      (IY)
0B3F39 BE 
0B3F3A 00 
0B3F3B 28    1706** JR      Z, LOC3			; Keep looping whilst we've got a match...
0B3F3C F7 
0B3F3D B7    1707** OR      A               	; Have we hit a terminator?
0B3F3E 28    1708** JR      Z,LOC5          	; Yes, so maybe we've found a variable
0B3F3F 07 
             1709** ;
0B3F40 FD    1710** LOC4:			POP     IY			; Restore the pointer in the program
0B3F41 E1 
0B3F42 EB    1711** EX      DE, HL			; HL: New pointer in DYNVARS
0B3F43 C3    1712** JP      LOC2            	; Loop round and try again
0B3F44 22 
0B3F45 3F 
0B3F46 0B 
             1713** ;
             1714** ; We might have located a variable at this point, just need to do a few more tests
             1715** ;
0B3F47 FD    1716** LOC5:			DEC     IY
0B3F48 2B 
0B3F49 FD    1717** LD      A,(IY)
0B3F4A 7E 
0B3F4B 00 
0B3F4C FE    1718** CP      '('
0B3F4D 28 
0B3F4E 28    1719** JR      Z,LOC5A         	; FOUND
0B3F4F 15 
0B3F50 FD    1720** INC     IY
0B3F51 23 
0B3F52 CD    1721** CALL    RANGE
0B3F53 39 
0B3F54 40 
0B3F55 0B 
0B3F56 38    1722** JR      C,LOC5A         	; FOUND
0B3F57 0D 
0B3F58 FE    1723** CP      '('
0B3F59 28 
0B3F5A 28    1724** JR      Z,LOC4          	; KEEP LOOKING
0B3F5B E4 
0B3F5C FD    1725** LD      A,(IY-1)
0B3F5D 7E 
0B3F5E FF 
0B3F5F CD    1726** CALL    RANGE1
0B3F60 45 
0B3F61 40 
0B3F62 0B 
0B3F63 30    1727** JR      NC,LOC4         	; KEEP LOOKING
0B3F64 DB 
0B3F65 D1    1728** LOC5A:			POP     DE
0B3F66 FD    1729** TYPE_:			LD      A,(IY-1)		; Check the string type postfix
0B3F67 7E 
0B3F68 FF 
0B3F69 FE    1730** CP      '$'			; Is it a string?
0B3F6A 24 
0B3F6B 16    1731** LD      D,129			; Yes, so return D = 129
0B3F6C 81 
0B3F6D C8    1732** RET     Z
0B3F6E FE    1733** CP      '%'			; Is it an integer?
0B3F6F 25 
0B3F70 16    1734** LD      D,4			; Yes, so return D = 4
0B3F71 04 
0B3F72 C8    1735** RET     Z
0B3F73 14    1736** INC     D			; At this point it must be a float
0B3F74 BF    1737** CP      A			; Set the flags
0B3F75 C9    1738** RET
             1739** ;
             1740** ; The variable is undefined at this point; HL will be zero
             1741** ;
0B3F76 3C    1742** LOC6:			INC     A               	; Set NZ flag
0B3F77 C9    1743** RET
             1744** ;
             1745** ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
             1746** ;   Inputs: HL, IY as returned from LOCATE (NZ).
             1747** ;  Outputs: As LOCATE, GETDEF.
             1748** ; Destroys: As LOCATE, GETDEF.
             1749** ;
0B3F78 AF    1750** CREATE:			XOR     A
0B3F79 ED    1751** LD      DE,(FREE)		; Get the last byte of available RAM
0B3F7A 5B 
0B3F7B 1D 
0B3F7C 51 
0B3F7C 0B   
0B3F7E ED    1752** LD	(HL), DE		; Store
0B3F7F 1F 
0B3F80 EB    1753** EX      DE,HL
0B3F81 77    1754** LD      (HL),A			; Clear the link of the new entity
0B3F82 23    1755** INC     HL
0B3F83 77    1756** LD      (HL),A
0B3F84 23    1757** INC     HL
0B3F85 77    1758** LD      (HL),A
0B3F86 23    1759** INC     HL
0B3F87 FD    1760** LOC7:			INC     IY
0B3F88 23 
0B3F89 CD    1761** CALL    RANGE           	; END OF VARIABLE?
0B3F8A 39 
0B3F8B 40 
0B3F8C 0B 
0B3F8D 38    1762** JR      C,LOC8
0B3F8E 15 
0B3F8F 77    1763** LD      (HL),A
0B3F90 23    1764** INC     HL
0B3F91 CD    1765** CALL    RANGE1
0B3F92 45 
0B3F93 40 
0B3F94 0B 
0B3F95 30    1766** JR      NC,LOC7
0B3F96 F0 
0B3F97 FE    1767** CP      '('
0B3F98 28 
0B3F99 28    1768** JR      Z,LOC8
0B3F9A 09 
0B3F9B FD    1769** LD      A,(IY+1)
0B3F9C 7E 
0B3F9D 01 
0B3F9E FE    1770** CP      '('
0B3F9F 28 
0B3FA0 28    1771** JR      Z,LOC7
0B3FA1 E5 
0B3FA2 FD    1772** INC     IY
0B3FA3 23 
0B3FA4 36    1773** LOC8:			LD      (HL),0          	; TERMINATOR
0B3FA5 00 
0B3FA6 23    1774** INC     HL
0B3FA7 E5    1775** PUSH    HL
0B3FA8 CD    1776** CALL    TYPE_			; Get the variable type in D
0B3FA9 66 
0B3FAA 3F 
0B3FAB 0B 
0B3FAC 3E    1777** LD      A,4			; If it is an integer then it takes up 4 bytes
0B3FAD 04 
0B3FAE BA    1778** CP      D
0B3FAF 28    1779** JR      Z,LOC9			; So skip the next bit
0B3FB0 01 
0B3FB1 3C    1780** INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0B3FB2 36    1781** LOC9:			LD      (HL),0          	; Initialise the memory to zero
0B3FB3 00 
0B3FB4 23    1782** INC     HL
0B3FB5 3D    1783** DEC     A
0B3FB6 20    1784** JR      NZ,LOC9
0B3FB7 FA 
0B3FB8 22    1785** LD      (FREE),HL		; Adjust the stack
0B3FB9 1D 
0B3FBA 51 
0B3FBB 0B 
0B3FBC CD    1786** CALL    CHECK			; Check whether we are out of space
0B3FBD 19 
0B3FBE 1A 
0B3FBF 0B 
0B3FC0 E1    1787** POP     HL
0B3FC1 AF    1788** XOR     A
0B3FC2 C9    1789** RET
             1790** ;
             1791** ; LINNUM - GET LINE NUMBER FROM TEXT STRING
             1792** ;   Inputs: IY = Text Pointer
             1793** ;  Outputs: HL = Line number (zero if none)
             1794** ;           IY updated
             1795** ; Destroys: A,D,E,H,L,IY,F
             1796** ;
             1797** ; This bit of code performs a BASE 10 shift to build up the number
             1798** ; So if the string passed is "345", the algorithm does this:
             1799** ;
             1800** ;    HL : Digit	: Operation
             1801** ; ----- : ----- : ---------
             1802** ; 00000 :	:
             1803** ; 00003 :     3	: Multiply HL  (0) by 10   (0) and add 3   (3)
             1804** ; 00034 :     4 : Multiply HL  (3) by 10  (30) and add 4  (34)
             1805** ; 00345 :     5	: Multiply HL (34) by 10 (340) and add 5 (345)
             1806** ;
             1807** ; The multiply by 10 is done by an unrolled shift and add loop
             1808** ;
0B3FC3 CD    1809** LINNUM:			CALL    NXT			; Skip whitespace to the first character
0B3FC4 3A 
0B3FC5 0E 
0B3FC6 0B 
0B3FC7 40    1810** LD.SIS  HL,0			; The running total
0B3FC8 21 
0B3FC9 00 
0B3FCA 00 
0B3FCB FD    1811** LINNM1:			LD      A,(IY)			; A: Fetch the digit to add in
0B3FCC 7E 
0B3FCD 00 
0B3FCE D6    1812** SUB     '0'			; Sub ASCII '0' to make a binary number (0-9)
0B3FCF 30 
0B3FD0 D8    1813** RET     C			; And return if less than 0
0B3FD1 FE    1814** CP      10			; Or greater than or equal to 10
0B3FD2 0A 
0B3FD3 D0    1815** RET     NC			; As we've hit a non-numeric character (end of number) at this point
0B3FD4 FD    1816** INC     IY			; Increment the string pointer
0B3FD5 23 
0B3FD6 54    1817** LD      D,H			; This next block multiplys HL by 10, shifting the result left in BASE 10
0B3FD7 5D    1818** LD      E,L			; Store the original number in DE
0B3FD8 52    1819** ADD.S   HL,HL           	; *2
0B3FD9 29 
0B3FDA 38    1820** JR      C,TOOBIG		; At each point, error if > 65535 (carry flag set)
0B3FDB 13 
0B3FDC 52    1821** ADD.S   HL,HL           	; *4S
0B3FDD 29 
0B3FDE 38    1822** JR      C,TOOBIG
0B3FDF 0F 
0B3FE0 52    1823** ADD.S   HL,DE           	; *5
0B3FE1 19 
0B3FE2 38    1824** JR      C,TOOBIG
0B3FE3 0B 
0B3FE4 52    1825** ADD.S   HL,HL           	; *10
0B3FE5 29 
0B3FE6 38    1826** JR      C,TOOBIG
0B3FE7 07 
0B3FE8 5F    1827** LD      E,A			; A->DE: the digit to add in
0B3FE9 16    1828** LD      D,0
0B3FEA 00 
0B3FEB 52    1829** ADD.S   HL,DE           	; Add in the digit to the running total
0B3FEC 19 
0B3FED 30    1830** JR      NC,LINNM1       	; And if it is still <= 65535, loop
0B3FEE DC 
             1831** ;
0B3FEF 3E    1832** TOOBIG:			LD      A,20
0B3FF0 14 
0B3FF1 C3    1833** JP      ERROR_           	; Error: "Too big"
0B3FF2 2A 
0B3FF3 3B 
0B3FF4 0B 
             1834** ;
             1835** ; PAIR - GET PAIR OF LINE NUMBERS FOR RENUMBER/AUTO.
             1836** ;   Inputs: IY = text pointer
             1837** ;  Outputs: HL = first number (10 by default)
             1838** ;           BC = second number (10 by default)
             1839** ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IY,F
             1840** ;
0B3FF5 CD    1841** PAIR:			CALL    LINNUM          	; Parse the first line number
0B3FF6 C3 
0B3FF7 3F 
0B3FF8 0B 
0B3FF9 7C    1842** LD      A,H			; If it is not zero, then...
0B3FFA B5    1843** OR      L
0B3FFB 20    1844** JR      NZ,PAIR1		; Skip...
0B3FFC 02 
0B3FFD 2E    1845** LD      L,10			; HL: the default value (10)
0B3FFE 0A 
             1846** ;
0B3FFF CD    1847** PAIR1:			CALL    TERMQ			; Check for ELSE, : or CR
0B4000 44 
0B4001 1B 
0B4002 0B 
0B4003 FD    1848** INC     IY			; Skip to next character
0B4004 23 
0B4005 E5    1849** PUSH    HL			; Stack the first line number
0B4006 21    1850** LD      HL,10			; HL: the second default (10)
0B4007 0A 
0B4008 00 
0B4009 00 
0B400A C4    1851** CALL    NZ,LINNUM       	; Parse the second line number
0B400B C3 
0B400C 3F 
0B400D 0B 
0B400E E3    1852** EX      (SP),HL			; HL: The first line number (off the stack)
0B400F C1    1853** POP     BC			; BC: Second line number
0B4010 78    1854** LD      A,B			; If the second line number is not zero then...
0B4011 B1    1855** OR      C			; We're good...
0B4012 C0    1856** RET     NZ			; Exit, otherwise...
0B4013 CD    1857** CALL    EXTERR			; Throw error: "Silly"
0B4014 41 
0B4015 3B 
0B4016 0B 
0B4017 53    1858** DB    	"Silly", 0
0B4018 69 
0B4019 6C 
0B401A 6C 
0B401A 79   
0B401B 00 
             1859** ;
             1860** ; DLPAIR - GET PAIR OF LINE NUMBERS FOR DELETE/LIST.
             1861** ;   Inputs: IY = text pointer
             1862** ;  Outputs: HL = points to program text
             1863** ;           BC = second number (0 by default)
             1864** ; Destroys: A,B,C,D,E,H,L,IY,F
             1865** ;
0B401D CD    1866** DLPAIR:			CALL    LINNUM			; Parse the first line number
0B401E C3 
0B401F 3F 
0B4020 0B 
0B4021 E5    1867** PUSH    HL			; Stack it
0B4022 CD    1868** CALL    TERMQ			; Check for ELSE, : or CR
0B4023 44 
0B4024 1B 
0B4025 0B 
0B4026 28    1869** JR      Z,DLP1			; And exit if so
0B4027 0A 
0B4028 FE    1870** CP      TIF			; Is the token IF?
0B4029 E7 
0B402A 28    1871** JR      Z,DLP1			; Yes, so skip the next bit...
0B402B 06 
0B402C FD    1872** INC     IY			; Otherwise...
0B402D 23 
0B402E CD    1873** CALL    LINNUM			; Fetch the second line number
0B402F C3 
0B4030 3F 
0B4031 0B 
0B4032 E3    1874** DLP1:			EX      (SP),HL			; HL: The first line number (off the stack)
0B4033 CD    1875** CALL    FINDL			; HL: Find the address of the line
0B4034 59 
0B4035 3D 
0B4036 0B 
0B4037 C1    1876** POP     BC			; BC: The second number
0B4038 C9    1877** RET
             1878** ;
             1879** ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
             1880** ;   Inputs: IY addresses character
             1881** ;  Outputs: Carry set if out-of-range.
             1882** ; Destroys: A,F
             1883** ;
             1884** ; It is called here to check the following
             1885** ; In range: "$", "%" and "("
             1886** ;   Plus all characters in RANGE1 and RANGE2
             1887** ;
0B4039 FD    1888** RANGE:			LD      A,(IY)			; Fetch the character
0B403A 7E 
0B403B 00 
0B403C FE    1889** CP      '$'			; Postfix for string variable is valid
0B403D 24 
0B403E C8    1890** RET     Z
0B403F FE    1891** CP      '%'			; Postfix for integer variable is valid
0B4040 25 
0B4041 C8    1892** RET     Z
0B4042 FE    1893** CP      '('			; Postfix for array is valid
0B4043 28 
0B4044 C8    1894** RET     Z
             1895** ;
             1896** ; It is called here to check the following
             1897** ; In range: "0" to "9" and "@"
             1898** ;   Plus all characters in RANGE2
             1899** ;
0B4045 FE    1900** RANGE1:			CP      '0'			; If it is between '0'...
0B4046 30 
0B4047 D8    1901** RET     C
0B4048 FE    1902** CP      '9'+1			; And '9'...
0B4049 3A 
0B404A 3F    1903** CCF
0B404B D0    1904** RET     NC			; Then it is valid
0B404C FE    1905** CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
0B404D 40 
0B404E C8    1906** RET     Z
             1907** ;
             1908** ; It is called here to check the following
             1909** ; In range: "A" to "Z", "a' to "z", "_" and "`"
             1910** ;
0B404F FE    1911** RANGE2:			CP      'A'			; If it is between 'A'...
0B4050 41 
0B4051 D8    1912** RET     C
0B4052 FE    1913** CP      'Z'+1			; And 'Z'...
0B4053 5B 
0B4054 3F    1914** CCF
0B4055 D0    1915** RET     NC			; Then it is valid
0B4056 FE    1916** CP      '_'			; If it is underscore, grave, or between 'a'
0B4057 5F 
0B4058 D8    1917** RET     C
0B4059 FE    1918** CP      'z'+1			; And 'z'
0B405A 7B 
0B405B 3F    1919** CCF				; Then it is valid
0B405C C9    1920** RET
             1921** ;
             1922** ; Throw a 'LINE space' error (line too long)
             1923** ; This is called from LEXAN
             1924** ;
0B405D AF    1925** SPACE_: 		XOR     A
0B405E CD    1926** CALL    EXTERR          	; "LINE space"
0B405F 41 
0B4060 3B 
0B4061 0B 
0B4062 86    1927** DB    	LINE_MN_, 8, 0
0B4063 08 
0B4064 00 
             1928** ;
             1929** ; LEXAN - LEXICAL ANALYSIS.
             1930** ;  Bit 0,C: 1=left, 0=right
             1931** ;  Bit 2,C: 1=in BINARY
             1932** ;  Bit 3,C: 1=in HEX
             1933** ;  Bit 4,C: 1=accept line number
             1934** ;  Bit 5,C: 1=in variable, FN, PROC
             1935** ;  Bit 6,C: 1=in REM, DATA, *
             1936** ;  Bit 7,C: 1=in quotes
             1937** ;   Inputs: IY addresses source string
             1938** ;           DE addresses destination string (must be page boundary)
             1939** ;            C sets initial mode
             1940** ;  Outputs: DE, IY updated
             1941** ;            A holds carriage return
             1942** ;
0B4065 12    1943** LEXAN1:			LD      (DE),A          	; Transfer to buffer
0B4066 13    1944** INC     DE              	; Increment the pointers
0B4067 FD    1945** INC     IY			; And fall through to the main function
0B4068 23 
             1946** ;
             1947** ; This is the main entry point
             1948** ;
0B4069 7B    1949** LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
0B406A FE    1950** CP      252             	; If it is >= 252 bytes, then...
0B406B FC 
0B406C 30    1951** JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0B406D EF 
0B406E FD    1952** LD      A,(IY)			; Fetch character from source string
0B406F 7E 
0B4070 00 
0B4071 FE    1953** CP      CR			; If it is a CR
0B4072 0D 
0B4073 C8    1954** RET     Z               	; Then it is end of line; we're done parsing
0B4074 CD    1955** CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B4075 45 
0B4076 40 
0B4077 0B 
0B4078 30    1956** JR      NC,LEXAN3		; Yes, so skip
0B4079 06 
0B407A CB    1957** RES     5,C             	; FLAG: NOT IN VARIABLE
0B407B A9 
0B407C CB    1958** RES     3,C             	; FLAG: NOT IN HEX
0B407D 99 
0B407E CB    1959** RES	2,C			; FLAG: NOT IN BINARY
0B407F 91 
             1960** ;
0B4080 FE    1961** LEXAN3:			CP      ' '			; Ignore spaces
0B4081 20 
0B4082 28    1962** JR      Z,LEXAN1
0B4083 E1 
0B4084 FE    1963** CP      ','			; Ignore commas
0B4085 2C 
0B4086 28    1964** JR      Z,LEXAN1
0B4087 DD 
0B4088 FE    1965** CP	'2'			; If less than '2'
0B4089 32 
0B408A 30    1966** JR	NC, @F			; No, so skip
0B408B 02 
0B408C CB    1967** RES	2,C			; FLAG: NOT IN BINARY
0B408D 91 
0B408E FE    1968** @@:			CP      'G'			; If less then 'G'
0B408F 47 
0B4090 38    1969** JR      C,LEXAN4		; Yes, so skip
0B4091 02 
0B4092 CB    1970** RES     3,C             	; FLAG: NOT IN HEX
0B4093 99 
             1971** ;
0B4094 FE    1972** LEXAN4:			CP      34			; Is it a quote character?
0B4095 22 
0B4096 20    1973** JR      NZ,LEXAN5		; No, so skip
0B4097 05 
0B4098 CB    1974** RL      C			; Toggle bit 7 of C by shifting it into carry flag
0B4099 11 
0B409A 3F    1975** CCF                     	; Toggle the carry
0B409B CB    1976** RR      C			; And then shifting it back into bit 7 of C
0B409C 19 
             1977** ;
0B409D CB    1978** LEXAN5:			BIT     4,C			; Accept line number?
0B409E 61 
0B409F 28    1979** JR      Z,LEXAN6		; No, so skip
0B40A0 12 
0B40A1 CB    1980** RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
0B40A2 A1 
0B40A3 C5    1981** PUSH    BC
0B40A4 D5    1982** PUSH    DE
0B40A5 CD    1983** CALL    LINNUM         		; Parse the line number to HL
0B40A6 C3 
0B40A7 3F 
0B40A8 0B 
0B40A9 D1    1984** POP     DE
0B40AA C1    1985** POP     BC
0B40AB 7C    1986** LD      A,H			; If it is not zero
0B40AC B5    1987** OR      L
0B40AD C4    1988** CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
0B40AE 26 
0B40AF 41 
0B40B0 0B 
0B40B1 18    1989** JR      LEXAN2          	; And loop
0B40B2 B6 
             1990** ;
0B40B3 0D    1991** LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0B40B4 28    1992** JR      Z,LEXAN7        	; If so, skip
0B40B5 0A 
0B40B6 0C    1993** INC     C			; Otherwise restore C
0B40B7 20    1994** JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0B40B8 AC 
0B40B9 B7    1995** OR      A			; Set the flags based on the character
0B40BA F4    1996** CALL    P,LEX           	; Tokenise if A < 128
0B40BB 91 
0B40BC 3B 
0B40BD 0B 
0B40BE 18    1997** JR      LEXAN8			; And skip
0B40BF 13 
             1998** ;
             1999** ; Processing the LEFT hand side here
             2000** ;
0B40C0 FE    2001** LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0B40C1 2A 
0B40C2 28    2002** JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0B40C3 17 
0B40C4 B7    2003** OR      A			; Set the flags based on the character
0B40C5 F4    2004** CALL    P,LEX           	; Tokenise if A < 128
0B40C6 91 
0B40C7 3B 
0B40C8 0B 
             2005** ;
             2006** ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
             2007** ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
             2008** ; Examples:
             2009** ;   LET A% = PAGE : REM This is the GET version
             2010** ;   PAGE = 40000  : REM This is the SET version
             2011** ;
0B40C9 FE    2012** CP      TOKLO			; TOKLO is 8Fh
0B40CA 8F 
0B40CB 38    2013** JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
0B40CC 06 
0B40CD FE    2014** CP      TOKHI+1			; TOKHI is 93h
0B40CE 94 
0B40CF 30    2015** JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
0B40D0 02 
0B40D1 C6    2016** ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
0B40D2 40 
             2017** ;
0B40D3 FE    2018** LEXAN8:			CP      REM			; If the token is REM
0B40D4 F4 
0B40D5 28    2019** JR      Z,LEXAN9		; Then stop tokenising
0B40D6 04 
0B40D7 FE    2020** CP      DATA_MN_			; If it is not DATA then
0B40D8 DC 
0B40D9 20    2021** JR      NZ,LEXANA		; Skip
0B40DA 02 
0B40DB CB    2022** LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
0B40DC F1 
             2023** ;
0B40DD FE    2024** LEXANA:			CP      FN			; If the token is FN
0B40DE A4 
0B40DF 28    2025** JR      Z,LEXANB
0B40E0 0A 
0B40E1 FE    2026** CP      PROC			; Or the token is PROC
0B40E2 F2 
0B40E3 28    2027** JR      Z,LEXANB		; Then jump to here
0B40E4 06 
0B40E5 CD    2028** CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
0B40E6 4F 
0B40E7 40 
0B40E8 0B 
0B40E9 38    2029** JR      C,LEXANC		; Jump here if out of range
0B40EA 02 
             2030** ;
0B40EB CB    2031** LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
0B40EC E9 
0B40ED FE    2032** LEXANC:			CP      '&'			; Check for hex prefix
0B40EE 26 
0B40EF 20    2033** JR      NZ,LEXAND		; If not, skip
0B40F0 02 
0B40F1 CB    2034** SET     3,C             	; FLAG: IN HEX
0B40F2 D9 
             2035** ;
0B40F3 FE    2036** LEXAND:			CP	'%'			; Check for binary prefix
0B40F4 25 
0B40F5 20    2037** JR	NZ,LEXANE		; If not, skip
0B40F6 02 
0B40F7 CB    2038** SET	2,C			; FLAG: IN BINARY
0B40F8 D1 
             2039** ;
0B40F9 21    2040** LEXANE:			LD      HL,LIST1		; List of tokens that must be followed by a line number
0B40FA 1D 
0B40FB 41 
0B40FC 0B 
0B40FD C5    2041** PUSH    BC
0B40FE 01    2042** LD      BC,LIST1L		; The list length
0B40FF 06 
0B4100 00 
0B4101 00 
0B4102 ED    2043** CPIR				; Check if the token is in this list
0B4103 B1 
0B4104 C1    2044** POP     BC
0B4105 20    2045** JR      NZ,LEXANF		; If not, then skip
0B4106 02 
0B4107 CB    2046** SET     4,C             	; FLAG: ACCEPT LINE NUMBER
0B4108 E1 
             2047** ;
0B4109 21    2048** LEXANF:			LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
0B410A 21 
0B410B 41 
0B410C 0B 
0B410D C5    2049** PUSH    BC
0B410E 01    2050** LD      BC,LIST2L		; The list length
0B410F 05 
0B4110 00 
0B4111 00 
0B4112 ED    2051** CPIR				; Check if the token is in this list
0B4113 B1 
0B4114 C1    2052** POP     BC
0B4115 20    2053** JR      NZ,LEXANG		; If not, then skip
0B4116 02 
0B4117 CB    2054** SET     0,C             	; FLAG: ENTER LEFT MODE
0B4118 C1 
0B4119 C3    2055** LEXANG:			JP      LEXAN1			; And loop
0B411A 65 
0B411B 40 
0B411C 0B 
             2056** 
             2057** ;
             2058** ; LIST1: List of tokens that must be followed by line numbers
             2059** ; LIST2: List of tokens that switch the lexical analysis back to LEFT mode
             2060** ;
0B411D E5    2061** LIST1:			DB	GOTO
0B411E E4    2062** DB	GOSUB
0B411F F7    2063** DB	RESTOR
0B4120 FC    2064** DB	TRACE
0B4121 8C    2065** LIST2:			DB	THEN_MN_
0B4122 8B    2066** DB	ELSE_MN_
             2067** LIST1L:			EQU     $-LIST1
0B4123 F5    2068** DB	REPEAT
0B4124 85    2069** DB	TERROR_MN
0B4125 3A    2070** DB    	':'
             2071** LIST2L:			EQU     $-LIST2
             2072** ;
             2073** ; ENCODE - ENCODE LINE NUMBER INTO PSEUDO-BINARY FORM.
             2074** ;   Inputs: HL=line number, DE=string pointer
             2075** ;  Outputs: DE updated, BIT 4,C set.
             2076** ; Destroys: A,B,C,D,E,F
             2077** ;
             2078** ; Thanks to Matt Godblot for this explanation (https://xania.org/200711/bbc-basic-line-number-format)
             2079** ;
             2080** ; The line number is spread over three bytes and kept in the range of normal ASCII values so the interpreter
             2081** ; can make this short cut in skipping to the non-ASCII token ELSE. The algorithm used splits the top two bits off
             2082** ; each of the two bytes of the 16-bit line number. These bits are combined (in binary as 00LlHh00),
             2083** ; exclusive-ORred with 0x54, and stored as the first byte of the 3-byte sequence. The remaining six bits of
             2084** ; each byte are then stored, in LO/HI order, ORred with 0x40.
             2085** ;
0B4126 CB    2086** ENCODE:			SET     4,C			; Set bit 4 of C (for lexical analysis - accept line number)
0B4127 E1 
0B4128 EB    2087** EX      DE, HL			; HL: string pointer, DE: line number
0B4129 36    2088** LD      (HL), LINO_MN		; Store 8Dh first to flag next bytes as an encoded line number
0B412A 8D 
0B412B 23    2089** INC     HL
0B412C 7A    2090** LD      A,D			; Get the high byte
0B412D E6    2091** AND     0C0H			; Get the top two bits	DD000000
0B412E C0 
0B412F 0F    2092** RRCA				; Shift right		00DD0000
0B4130 0F    2093** RRCA
0B4131 47    2094** LD      B,A			; Store in B
0B4132 7B    2095** LD      A,E			; Get the low byte
0B4133 E6    2096** AND     0C0H			; Get the top two bits	EE000000
0B4134 C0 
0B4135 B0    2097** OR      B			; Combine with D	EEDD0000
0B4136 0F    2098** RRCA				; Shift right		00EEDD00
0B4137 0F    2099** RRCA
0B4138 EE    2100** XOR     01010100B		; XOR with 54h
0B4139 54 
0B413A 77    2101** LD      (HL),A			; Store this as the second byte
0B413B 23    2102** INC     HL
0B413C 7B    2103** LD      A,E			; Get the low byte
0B413D E6    2104** AND     3FH			; Strip the top two bits off
0B413E 3F 
0B413F F6    2105** OR      '@'			; OR with 40h
0B4140 40 
0B4141 77    2106** LD      (HL),A			; Store
0B4142 23    2107** INC     HL
0B4143 7A    2108** LD      A,D			; Get the high byte
0B4144 E6    2109** AND     3FH			; Strip the top two bits off
0B4145 3F 
0B4146 F6    2110** OR      '@'			; OR with 40h
0B4147 40 
0B4148 77    2111** LD      (HL),A			; Store
0B4149 23    2112** INC     HL
0B414A EB    2113** EX      DE,HL			; DE: string pointer, HL: line number
0B414B C9    2114** RET
             2115** ;
             2116** ; TEXT - OUTPUT MESSAGE.
             2117** ;   Inputs: HL addresses text (terminated by nul)
             2118** ;  Outputs: HL addresses character following nul.
             2119** ; Destroys: A,H,L,F
             2120** ;
0B414C 2A    2121** REPORT:			LD      HL, (ERRTXT)		; Output an error message pointed to by ERRTXT
0B414D 2F 
0B414E 51 
0B414F 0B 
             2122** ;
0B4150 7E    2123** TEXT_:			LD      A, (HL)			; Fetch the character
0B4151 23    2124** INC     HL			; Increment pointer to next character
0B4152 B7    2125** OR      A			; Check for the nul (0) string terminator
0B4153 C8    2126** RET     Z			; And return if so
0B4154 CD    2127** CALL    OUT_			; Output the character; note that OUT_ will detokenise tokens
0B4155 36 
0B4156 3D 
0B4157 0B 
0B4158 18    2128** JR      TEXT_			; And loop
0B4159 F6 
             2129** ;
             2130** ; TELL - OUTPUT MESSAGE.
             2131** ;   Inputs: Text follows subroutine call (term=nul)
             2132** ; Destroys: A,F
             2133** ;
             2134** ; Example usage:
             2135** ;
             2136** ;	CALL	TELL			Call the function
             2137** ;	DB	"Hello World", 0	Followed by a zero terminated string
             2138** ;	LD	A, (1234H)		Program execution will carry on here after the message is output
             2139** ;
0B415A E3    2140** TELL:			EX      (SP), HL		; Get the return address off the stack into HL, this is the
0B415B CD    2141** CALL    TEXT_			; first byte of the string that follows it. Print it, then
0B415C 50 
0B415D 41 
0B415E 0B 
0B415F E3    2142** EX      (SP), HL		; HL will point to the next instruction, swap this back onto the stack
0B4160 C9    2143** RET				; at this point we'll return to the first instruction after the message
              0010* include "basic/misc.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Miscellaneous helper functions
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	12/05/2023
             0006** ;
             0007** ; Modinfo:
             0008** 
             0009** ; INCLUDE	"equs.inc"
             0010** ; INCLUDE	"macros.inc"
             0011** 
             0012** ; .ASSUME	ADL = 1
             0013** 
             0014** ; SEGMENT CODE
             0015** 
             0016** ; XDEF	ASC_TO_NUMBER
             0017** ; XDEF	SWITCH_A
             0018** ; XDEF	NULLTOCR
             0019** ; XDEF	CRTONULL
             0020** ; XDEF	CSTR_FNAME
             0021** ; XDEF	CSTR_LINE
             0022** ; XDEF	CSTR_FINDCH
             0023** ; XDEF	CSTR_ENDSWITH
             0024** ; XDEF	CSTR_CAT
             0025** 
             0026** ; XREF	OSWRCH
             0027** ; XREF	KEYWDS
             0028** ; XREF	KEYWDL
             0029** 
             0030** ; Read a number and convert to binary
             0031** ; If prefixed with &, will read as hex, otherwise decimal
             0032** ;   Inputs: HL: Pointer in string buffer
             0033** ;  Outputs: HL: Updated text pointer
             0034** ;           DE: Value
             0035** ;            A: Terminator (spaces skipped)
             0036** ; Destroys: A,D,E,H,L,F
             0037** ;
0B4161 C5    0038** ASC_TO_NUMBER:		PUSH	BC			; Preserve BC
0B4162 11    0039** LD	DE, 0			; Initialise DE
0B4163 00 
0B4164 00 
0B4165 00 
0B4166 CD    0040** CALL	SKIPSPC			; Skip whitespace
0B4167 A8 
0B4168 41 
0B4169 0B 
0B416A 7E    0041** LD	A, (HL)			; Read first character
0B416B FE    0042** CP	'&'			; Is it prefixed with '&' (HEX number)?
0B416C 26 
0B416D 20    0043** JR	NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B416E 1F 
0B416F 23    0044** INC	HL			; Otherwise fall through to ASC_TO_HEX
             0045** ;
0B4170 7E    0046** ASC_TO_NUMBER1:		LD	A, (HL)			; Fetch the character
0B4171 CD    0047** CALL    UPPERC			; Convert to uppercase
0B4172 B6 
0B4173 41 
0B4174 0B 
0B4175 D6    0048** SUB	'0'			; Normalise to 0
0B4176 30 
0B4177 38    0049** JR 	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B4178 2E 
0B4179 FE    0050** CP 	10			; Check if >= 10
0B417A 0A 
0B417B 38    0051** JR 	C,ASC_TO_NUMBER2	; No, so skip next bit
0B417C 06 
0B417D D6    0052** SUB 	7			; Adjust ASCII A-F to nibble
0B417E 07 
0B417F FE    0053** CP 	16			; Check for > F
0B4180 10 
0B4181 30    0054** JR 	NC, ASC_TO_NUMBER4	; Return if out of range
0B4182 24 
0B4183 EB    0055** ASC_TO_NUMBER2:		EX 	DE, HL 			; Shift DE left 4 times
0B4184 29    0056** ADD	HL, HL
0B4185 29    0057** ADD	HL, HL
0B4186 29    0058** ADD	HL, HL
0B4187 29    0059** ADD	HL, HL
0B4188 EB    0060** EX	DE, HL
0B4189 B3    0061** OR      E			; OR the new digit in to the least significant nibble
0B418A 5F    0062** LD      E, A
0B418B 23    0063** INC     HL			; Onto the next character
0B418C 18    0064** JR      ASC_TO_NUMBER1		; And loop
0B418D E2 
             0065** ;
0B418E 7E    0066** ASC_TO_NUMBER3:		LD	A, (HL)
0B418F D6    0067** SUB	'0'			; Normalise to 0
0B4190 30 
0B4191 38    0068** JR	C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B4192 14 
0B4193 FE    0069** CP	10			; Check if >= 10
0B4194 0A 
0B4195 30    0070** JR	NC, ASC_TO_NUMBER4	; Return if >= 10
0B4196 10 
0B4197 EB    0071** EX 	DE, HL 			; Stick DE in HL
0B4198 44    0072** LD	B, H 			; And copy HL into BC
0B4199 4D    0073** LD	C, L
0B419A 29    0074** ADD	HL, HL 			; x 2
0B419B 29    0075** ADD	HL, HL 			; x 4
0B419C 09    0076** ADD	HL, BC 			; x 5
0B419D 29    0077** ADD	HL, HL 			; x 10
0B419E EB    0078** EX	DE, HL
             0079** ADD8U_DE 			; Add A to DE (macro)
0B419F 83   0001**M ADD	A, E
0B41A0 5F   0002**M LD	E, A
0B41A1 8A   0003**M ADC	A, D
0B41A2 93   0004**M SUB	E
0B41A3 57   0005**M LD	D, A
0B41A4 23    0080** INC	HL
0B41A5 18    0081** JR	ASC_TO_NUMBER3
0B41A6 E7 
0B41A7 C1    0082** ASC_TO_NUMBER4:		POP	BC 			; Fall through to SKIPSPC here
             0083** 
             0084** ; Skip a space
             0085** ; HL: Pointer in string buffer
             0086** ;
0B41A8 7E    0087** SKIPSPC:			LD      A, (HL)
0B41A9 FE    0088** CP      ' '
0B41AA 20 
0B41AB C0    0089** RET     NZ
0B41AC 23    0090** INC     HL
0B41AD 18    0091** JR      SKIPSPC
0B41AE F9 
             0092** 
             0093** ; Skip a string
             0094** ; HL: Pointer in string buffer
             0095** ;
0B41AF 7E    0096** SKIPNOTSP:		LD	A, (HL)
0B41B0 FE    0097** CP	' '
0B41B1 20 
0B41B2 C8    0098** RET	Z
0B41B3 23    0099** INC	HL
0B41B4 18    0100** JR	SKIPNOTSP
0B41B5 F9 
             0101** 
             0102** ; Convert a character to upper case
             0103** ;  A: Character to convert
             0104** ;
0B41B6 E6    0105** UPPERC:  		AND     7FH
0B41B7 7F 
0B41B8 FE    0106** CP      '`'
0B41B9 60 
0B41BA D8    0107** RET     C
0B41BB E6    0108** AND     5FH			; Convert to upper case
0B41BC 5F 
0B41BD C9    0109** RET
             0110** 
             0111** ; Switch on A - lookup table immediately after call
             0112** ;  A: Index into lookup table
             0113** ;
0B41BE E3    0114** SWITCH_A:		EX	(SP), HL		; Swap HL with the contents of the top of the stack
0B41BF 87    0115** ADD	A, A			; Multiply A by two
             0116** ADD8U_HL 			; Add to HL (macro)
0B41C0 85   0001**M ADD	A, L
0B41C1 6F   0002**M LD	L, A
0B41C2 8C   0003**M ADC	A, H
0B41C3 95   0004**M SUB	L
0B41C4 67   0005**M LD	H, A
0B41C5 7E    0117** LD	A, (HL)			; follow the call. Fetch an address from the
0B41C6 23    0118** INC	HL 			; table.
0B41C7 66    0119** LD	H, (HL)
0B41C8 6F    0120** LD	L, A
0B41C9 E3    0121** EX	(SP), HL		; Swap this new address back, restores HL
0B41CA C9    0122** RET				; Return program control to this new address
             0123** 
             0124** ; Convert the buffer to a null terminated string and back
             0125** ; HL: Buffer address
             0126** ;
0B41CB C5    0127** NULLTOCR:		PUSH 	BC
0B41CC 06    0128** LD	B, 0
0B41CD 00 
0B41CE 0E    0129** LD	C, CR
0B41CF 0D 
0B41D0 18    0130** JR	CRTONULL0
0B41D1 05 
             0131** ;
0B41D2 C5    0132** CRTONULL:		PUSH	BC
0B41D3 06    0133** LD	B, CR
0B41D4 0D 
0B41D5 0E    0134** LD	C, 0
0B41D6 00 
             0135** ;
0B41D7 E5    0136** CRTONULL0:		PUSH	HL
0B41D8 7E    0137** CRTONULL1:		LD	A, (HL)
0B41D9 B8    0138** CP 	B
0B41DA 28    0139** JR	Z, CRTONULL2
0B41DB 03 
0B41DC 23    0140** INC	HL
0B41DD 18    0141** JR	CRTONULL1
0B41DE F9 
0B41DF 71    0142** CRTONULL2:		LD	(HL), C
0B41E0 E1    0143** POP 	HL
0B41E1 C1    0144** POP	BC
0B41E2 C9    0145** RET
             0146** 
             0147** ; Copy a filename to DE and zero terminate it
             0148** ; HL: Source
             0149** ; DE: Destination (ACCS)
             0150** ;
0B41E3 7E    0151** CSTR_FNAME:		LD	A, (HL)			; Get source
0B41E4 FE    0152** CP	32			; Is it space
0B41E5 20 
0B41E6 28    0153** JR	Z, @F
0B41E7 09 
0B41E8 FE    0154** CP	CR			; Or is it CR
0B41E9 0D 
0B41EA 28    0155** JR	Z, @F
0B41EB 05 
0B41EC 12    0156** LD	(DE), A			; No, so store
0B41ED 23    0157** INC	HL			; Increment
0B41EE 13    0158** INC	DE
0B41EF 18    0159** JR	CSTR_FNAME		; And loop
0B41F0 F2 
0B41F1 AF    0160** @@:			XOR	A			; Zero terminate the target string
0B41F2 12    0161** LD	(DE), A
0B41F3 13    0162** INC	DE			; And point to next free address
0B41F4 C9    0163** RET
             0164** 
             0165** ; Copy a CR terminated line to DE and zero terminate it
             0166** ; HL: Source
             0167** ; DE: Destination (ACCS)
             0168** ;
0B41F5 7E    0169** CSTR_LINE:		LD	A, (HL)			; Get source
0B41F6 FE    0170** CP	CR			; Is it CR
0B41F7 0D 
0B41F8 28    0171** JR	Z, @F
0B41F9 05 
0B41FA 12    0172** LD	(DE), A			; No, so store
0B41FB 23    0173** INC	HL			; Increment
0B41FC 13    0174** INC	DE
0B41FD 18    0175** JR	CSTR_LINE		; And loop
0B41FE F6 
0B41FF AF    0176** @@:			XOR	A			; Zero terminate the target string
0B4200 12    0177** LD	(DE), A
0B4201 13    0178** INC	DE			; And point to next free address
0B4202 C9    0179** RET
             0180** 
             0181** ; Find the first occurrence of a character (case sensitive)
             0182** ; HL: Source
             0183** ;  C: Character to find
             0184** ; Returns:
             0185** ; HL: Pointer to character, or end of string marker
             0186** ;
0B4203 7E    0187** CSTR_FINDCH:		LD	A, (HL)			; Get source
0B4204 B9    0188** CP	C			; Is it our character?
0B4205 C8    0189** RET	Z			; Yes, so exit
0B4206 B7    0190** OR	A			; Is it the end of string?
0B4207 C8    0191** RET	Z			; Yes, so exit
0B4208 23    0192** INC	HL
0B4209 18    0193** JR	CSTR_FINDCH
0B420A F8 
             0194** 
             0195** ; Check whether a string ends with another string (case insensitive)
             0196** ; HL: Source
             0197** ; DE: The substring we want to test with
             0198** ; Returns:
             0199** ;  F: Z if HL ends with DE, otherwise NZ
             0200** ;
0B420B 7E    0201** CSTR_ENDSWITH:		LD	A, (HL)			; Get the source string byte
0B420C CD    0202** CALL	UPPERC			; Convert to upper case
0B420D B6 
0B420E 41 
0B420F 0B 
0B4210 4F    0203** LD	C, A
0B4211 1A    0204** LD	A, (DE)			; Get the substring byte
0B4212 B9    0205** CP	C
0B4213 C0    0206** RET	NZ			; Return NZ if at any point the strings don't match
0B4214 B1    0207** OR	C			; Check whether both bytes are zero
0B4215 C8    0208** RET	Z			; If so, return, as we have reached the end of both strings
0B4216 23    0209** INC	HL
0B4217 13    0210** INC	DE
0B4218 18    0211** JR	CSTR_ENDSWITH		; And loop
0B4219 F1 
             0212** 
             0213** ; Concatenate a string onto the end of another string
             0214** ; HL: Source
             0215** ; DE: Second string
             0216** ;
0B421A 7E    0217** CSTR_CAT:		LD	A, (HL)			; Loop until we find the end of the first string
0B421B B7    0218** OR	A
0B421C 28    0219** JR	Z, CSTR_CAT_1
0B421D 03 
0B421E 23    0220** INC	HL
0B421F 18    0221** JR	CSTR_CAT
0B4220 F9 
             0222** ;
0B4221 1A    0223** CSTR_CAT_1:		LD	A, (DE)			; Copy the second string onto the end of the first string
0B4222 77    0224** LD	(HL), A
0B4223 B7    0225** OR	A			; Check for end of string
0B4224 C8    0226** RET	Z			; And return
0B4225 23    0227** INC	HL
0B4226 13    0228** INC	DE
0B4227 18    0229** JR	CSTR_CAT_1		; Loop until finished
0B4228 F8 
              0011* include "basic/patch.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	15/11/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 11/07/2023:	Fixed *BYE for ADL mode
             0009** ; 15/11/2023:	Improved OSLOAD_TXT; now handles LF terminated files, files with no trailing LF or CR/LF at end
             0010** 
             0011** ; .ASSUME	ADL = 1
             0012** 
             0013** ; INCLUDE	"equs.inc"
             0014** ; INCLUDE "macros.inc"
             0015** ; INCLUDE "mos_api.inc"	; In MOS/src
             0016** 
             0017** ; SEGMENT CODE
             0018** 
             0019** ; XDEF	OSWRCH
             0020** ; XDEF	OSLINE
             0021** ; XDEF	ESCSET
             0022** ; XDEF	PUTIME
             0023** ; XDEF	GETIME
             0024** ; XDEF	PUTCSR
             0025** ; XDEF 	GETCSR
             0026** ; XDEF	OSRDCH
             0027** ; XDEF	PROMPT
             0028** ; XDEF	OSKEY
             0029** ; XDEF	TRAP
             0030** ; XDEF	LTRAP
             0031** ; XDEF	OSINIT
             0032** ; XDEF	OSCLI
             0033** ; XDEF	OSBPUT
             0034** ; XDEF	OSBGET
             0035** ; XDEF	OSSTAT
             0036** ; XDEF	OSSHUT
             0037** ; XDEF	OSOPEN
             0038** ; XDEF	OSCALL
             0039** ; XDEF	GETPTR
             0040** ; XDEF	PUTPTR
             0041** ; XDEF	GETEXT
             0042** ; XDEF	GETIMS
             0043** ; XDEF	RESET
             0044** ; XDEF	OSLOAD
             0045** ; XDEF	OSSAVE
             0046** ; XDEF	EXPR_W2
             0047** ; XDEF	STAR_VERSION
             0048** 
             0049** ; XREF	_basic_end			; In init.asm
             0050** 
             0051** ; XREF	ASC_TO_NUMBER
             0052** ; XREF	RAM_START
             0053** ; XREF	RAM_END
             0054** ; XREF	FLAGS
             0055** ; XREF	ESCAPE
             0056** ; XREF	USER
             0057** ; XREF	RAM_Top
             0058** ; XREF	EXTERR
             0059** ; XREF	COUNT0
             0060** ; XREF	EXPRI
             0061** ; XREF	COMMA
             0062** ; XREF	XEQ
             0063** ; XREF	NXT
             0064** ; XREF	NULLTOCR
             0065** ; XREF	CRLF
             0066** ; XREF	CSTR_FNAME
             0067** ; XREF	CSTR_LINE
             0068** ; XREF	CSTR_FINDCH
             0069** ; XREF	CSTR_ENDSWITH
             0070** ; XREF	CSTR_CAT
             0071** ; XREF	FINDL
             0072** ; XREF	OUT_
             0073** ; XREF	ERROR_
             0074** ; XREF	ONEDIT
             0075** ; XREF	TELL
             0076** ; XREF	OSWRCHPT
             0077** ; XREF	OSWRCHCH
             0078** ; XREF	OSWRCHFH
             0079** ; XREF	LISTON
             0080** ; XREF	LISTIT
             0081** ; XREF	PAGE_
             0082** ; XREF	ONEDIT1
             0083** ; XREF	CLEAN
             0084** ; XREF	NEWIT
             0085** ; XREF	BAD
             0086** ; XREF	VBLANK_INIT
             0087** ; XREF	VBLANK_STOP
             0088** ; XREF	KEYDOWN
             0089** ; XREF	KEYASCII
             0090** ; XREF	WIDTH
             0091** ; XREF	ASSEM
             0092** 
             0093** ; OSLINE: Invoke the line editor
             0094** ;
0B4229 1E    0095** OSLINE:			LD 	E, 1			; Default is to clear the buffer
0B422A 01 
             0096** 
             0097** ; Entry point to line editor that does not clear the buffer
             0098** ;
0B422B FD    0099** OSLINE1:		PUSH	IY
0B422C E5 
0B422D E5    0100** PUSH	HL			; Buffer address
0B422E 01    0101** LD	BC, 256			; Buffer length
0B422F 00 
0B4230 01 
0B4231 00 
             0102** MOSCALL	mos_editline		; Call the MOS line editor
0B4232 3E   0001**M LD	A, function
0B4233 09 
0B4234 49   0002**M RST.LIS	08h
0B4235 CF 
0B4236 E1    0103** POP	HL			; Pop the address
0B4237 FD    0104** POP	IY
0B4238 E1 
0B4239 F5    0105** PUSH	AF			; Stack the return value (key pressed)
0B423A CD    0106** CALL	NULLTOCR		; Turn the 0 character to a CR
0B423B CB 
0B423C 41 
0B423D 0B 
0B423E CD    0107** CALL	CRLF			; Display CRLF
0B423F 11 
0B4240 3D 
0B4241 0B 
0B4242 F1    0108** POP	AF
0B4243 FE    0109** CP	1Bh 			; Check if ESC terminated the input
0B4244 1B 
0B4245 CA    0110** JP	Z, LTRAP1 		; Yes, so do the ESC thing
0B4246 41 
0B4247 43 
0B4248 0B 
0B4249 3A    0111** LD	A, (FLAGS)		; Otherwise
0B424A 42 
0B424B 51 
0B424C 0B 
0B424D CB    0112** RES	7, A 			; Clear the escape flag
0B424E BF 
0B424F 32    0113** LD	(FLAGS), A
0B4250 42 
0B4251 51 
0B4252 0B 
0B4253 CD    0114** CALL	WAIT_VBLANK 		; Wait a frame
0B4254 07 
0B4255 45 
0B4256 0B 
0B4257 AF    0115** XOR	A			; Return A = 0
0B4258 32    0116** LD	(KEYDOWN), A
0B4259 47 
0B425A 51 
0B425B 0B 
0B425C 32    0117** LD	(KEYASCII), A
0B425D 48 
0B425E 51 
0B425F 0B 
0B4260 C9    0118** RET
             0119** 
             0120** ; PUTIME: set current time to DE:HL, in centiseconds.
             0121** ;
0B4261 DD    0122** PUTIME:			PUSH 	IX
0B4262 E5 
             0123** MOSCALL	mos_sysvars
0B4263 3E   0001**M LD	A, function
0B4264 08 
0B4265 49   0002**M RST.LIS	08h
0B4266 CF 
0B4267 DD    0124** LD	(IX + sysvar_time + 0), L
0B4268 75 
0B4269 00 
0B426A DD    0125** LD	(IX + sysvar_time + 1), H
0B426B 74 
0B426C 01 
0B426D DD    0126** LD	(IX + sysvar_time + 2), E
0B426E 73 
0B426F 02 
0B4270 DD    0127** LD	(IX + sysvar_time + 3), D
0B4271 72 
0B4272 03 
0B4273 DD    0128** POP	IX
0B4274 E1 
0B4275 C9    0129** RET
             0130** 
             0131** ; GETIME: return current time in DE:HL, in centiseconds
             0132** ;
0B4276 DD    0133** GETIME:			PUSH 	IX
0B4277 E5 
             0134** MOSCALL	mos_sysvars
0B4278 3E   0001**M LD	A, function
0B4279 08 
0B427A 49   0002**M RST.LIS	08h
0B427B CF 
0B427C DD    0135** LD	L, (IX + sysvar_time + 0)
0B427D 6E 
0B427E 00 
0B427F DD    0136** LD	H, (IX + sysvar_time + 1)
0B4280 66 
0B4281 01 
0B4282 DD    0137** LD	E, (IX + sysvar_time + 2)
0B4283 5E 
0B4284 02 
0B4285 DD    0138** LD	D, (IX + sysvar_time + 3)
0B4286 56 
0B4287 03 
0B4288 DD    0139** POP	IX
0B4289 E1 
0B428A C9    0140** RET
             0141** 
             0142** ; PUTCSR: move to cursor to x=DE, y=HL
             0143** ;
0B428B 3E    0144** PUTCSR:			LD	A, 1Fh			; TAB
0B428C 1F 
0B428D 5B    0145** RST.LIL	10h
0B428E D7 
0B428F 7B    0146** LD	A, E			; X
0B4290 5B    0147** RST.LIL 10h
0B4291 D7 
0B4292 7D    0148** LD	A, L			; Y
0B4293 5B    0149** RST.LIL 10h
0B4294 D7 
0B4295 C9    0150** RET
             0151** 
             0152** ; GETCSR: return cursor position in x=DE, y=HL
             0153** ;
0B4296 DD    0154** GETCSR:			PUSH	IX			; Get the system vars in IX
0B4297 E5 
             0155** MOSCALL	mos_sysvars		; Reset the semaphore
0B4298 3E   0001**M LD	A, function
0B4299 08 
0B429A 49   0002**M RST.LIS	08h
0B429B CF 
0B429C DD    0156** RES	0, (IX+sysvar_vpd_pflags)
0B429D CB 
0B429E 04 
0B429F 86 
             0157** VDU	23
0B42A0 3E   0001**M LD	A, val
0B42A1 17 
0B42A2 CD   0002**M CALL	OSWRCH
0B42A3 CA 
0B42A4 42 
0B42A5 0B 
             0158** VDU	0
0B42A6 3E   0001**M LD	A, val
0B42A7 00 
0B42A8 CD   0002**M CALL	OSWRCH
0B42A9 CA 
0B42AA 42 
0B42AB 0B 
             0159** VDU	vdp_cursor
0B42AC 3E   0001**M LD	A, val
0B42AD 82 
0B42AE CD   0002**M CALL	OSWRCH
0B42AF CA 
0B42B0 42 
0B42B1 0B 
0B42B2 DD    0160** @@:			BIT	0, (IX+sysvar_vpd_pflags)
0B42B3 CB 
0B42B4 04 
0B42B5 46 
0B42B6 28    0161** JR	Z, @B			; Wait for the result
0B42B7 FA 
0B42B8 16    0162** LD 	D, 0
0B42B9 00 
0B42BA 62    0163** LD	H, D
0B42BB DD    0164** LD	E, (IX + sysvar_cursorX)
0B42BC 5E 
0B42BD 07 
0B42BE DD    0165** LD	L, (IX + sysvar_cursorY)
0B42BF 6E 
0B42C0 08 
0B42C1 DD    0166** POP	IX
0B42C2 E1 
0B42C3 C9    0167** RET
             0168** 
             0169** ; PROMPT: output the input prompt
             0170** ;
0B42C4 3E    0171** PROMPT: 		LD	A,'>'
0B42C5 3E 
0B42C6 C3    0172** JP	OSWRCH
0B42C7 CA 
0B42C8 42 
0B42C9 0B 
             0173** 
             0174** ; OSWRCH: Write a character out to the ESP32 VDU handler via the MOS
             0175** ; A: Character to write
             0176** ;
0B42CA E5    0177** OSWRCH:			PUSH	HL
0B42CB 21    0178** LD	HL, LISTON		; Fetch the LISTON variable
0B42CC 40 
0B42CD 51 
0B42CE 0B 
0B42CF CB    0179** BIT	3, (HL)			; Check whether we are in *EDIT mode
0B42D0 5E 
0B42D1 20    0180** JR	NZ, OSWRCH_BUFFER	; Yes, so just output to buffer
0B42D2 0B 
             0181** ;
0B42D3 2A    0182** LD	HL, (OSWRCHCH)		; L: Channel #
0B42D4 45 
0B42D5 51 
0B42D6 0B 
0B42D7 2D    0183** DEC	L			; If it is 1
0B42D8 28    0184** JR	Z, OSWRCH_FILE		; Then we are outputting to a file
0B42D9 10 
             0185** ;
0B42DA E1    0186** POP	HL			; Otherwise
0B42DB 5B    0187** RST.LIL	10h			; Output the character to MOS
0B42DC D7 
0B42DD C9    0188** RET
             0189** ;
0B42DE 2A    0190** OSWRCH_BUFFER:		LD	HL, (OSWRCHPT)		; Fetch the pointer buffer
0B42DF 43 
0B42E0 51 
0B42E1 0B 
0B42E2 77    0191** LD	(HL), A			; Echo the character into the buffer
0B42E3 23    0192** INC	HL			; Increment pointer
0B42E4 22    0193** LD	(OSWRCHPT), HL		; Write pointer back
0B42E5 43 
0B42E6 51 
0B42E7 0B 
0B42E8 E1    0194** POP	HL
0B42E9 C9    0195** RET
             0196** ;
0B42EA D5    0197** OSWRCH_FILE:		PUSH	DE
0B42EB 5C    0198** LD	E, H			; Filehandle to E
0B42EC CD    0199** CALL	OSBPUT			; Write the byte out
0B42ED 05 
0B42EE 47 
0B42EF 0B 
0B42F0 D1    0200** POP	DE
0B42F1 E1    0201** POP	HL
0B42F2 C9    0202** RET
             0203** 
             0204** ; OSRDCH: Read a character in from the ESP32 keyboard handler
             0205** ; This is only called in GETS (eval.asm)
             0206** ;
             0207** OSRDCH:			MOSCALL	mos_getkey		; Read keyboard
0B42F3 3E   0001**M LD	A, function
0B42F4 00 
0B42F5 49   0002**M RST.LIS	08h
0B42F6 CF 
0B42F7 FE    0208** CP	1Bh
0B42F8 1B 
0B42F9 28    0209** JR	Z, LTRAP1
0B42FA 46 
0B42FB C9    0210** RET
             0211** 
             0212** 
             0213** ;OSKEY - Read key with time-limit, test for ESCape.
             0214** ;Main function is carried out in user patch.
             0215** ;   Inputs: HL = time limit (centiseconds)
             0216** ;  Outputs: Carry reset if time-out
             0217** ;           If carry set A = character
             0218** ; Destroys: A,H,L,F
             0219** ;
0B42FC CD    0220** OSKEY:			CALL	READKEY			; Read the keyboard
0B42FD 2D 
0B42FE 43 
0B42FF 0B 
0B4300 28    0221** JR	Z, @F 			; Skip if we have a key
0B4301 0A 
0B4302 7C    0222** LD	A, H 			; Check loop counter
0B4303 B5    0223** OR 	L
0B4304 C8    0224** RET 	Z 			; Return, we've not got a key at this point
0B4305 CD    0225** CALL	WAIT_VBLANK 		; Wait a frame
0B4306 07 
0B4307 45 
0B4308 0B 
0B4309 2B    0226** DEC 	HL			; Decrement
0B430A 18    0227** JR	OSKEY 			; And loop
0B430B F0 
             0228** ;
0B430C 21    0229** @@:			LD	HL, KEYDOWN		; We have a key, so
0B430D 47 
0B430E 51 
0B430F 0B 
0B4310 36    0230** LD	(HL), 0			; clear the keydown flag
0B4311 00 
0B4312 FE    0231** CP	1BH			; If we are not pressing ESC,
0B4313 1B 
0B4314 37    0232** SCF 				; then flag we've got a character
0B4315 C0    0233** RET	NZ
             0234** ;
             0235** ; ESCSET
             0236** ; Set the escape flag (bit 7 of FLAGS = 1) if escape is enabled (bit 6 of FLAGS = 0)
             0237** ;
0B4316 E5    0238** ESCSET: 		PUSH    HL
0B4317 21    0239** LD      HL,FLAGS		; Pointer to FLAGS
0B4318 42 
0B4319 51 
0B431A 0B 
0B431B CB    0240** BIT     6,(HL)			; If bit 6 is set, then
0B431C 76 
0B431D 20    0241** JR      NZ,ESCDIS		; escape is disabled, so skip
0B431E 02 
0B431F CB    0242** SET     7,(HL)			; Set bit 7, the escape flag
0B4320 FE 
0B4321 E1    0243** ESCDIS: 		POP     HL
0B4322 C9    0244** RET
             0245** ;
             0246** ; ESCTEST
             0247** ; Test for ESC key
             0248** ;
0B4323 CD    0249** ESCTEST:		CALL	READKEY			; Read the keyboard
0B4324 2D 
0B4325 43 
0B4326 0B 
0B4327 C0    0250** RET	NZ			; Skip if no key is pressed
0B4328 FE    0251** CP	1BH			; If ESC pressed then
0B4329 1B 
0B432A 28    0252** JR	Z,ESCSET		; jump to the escape set routine
0B432B EA 
0B432C C9    0253** RET
             0254** 
             0255** ; Read the keyboard
             0256** ; Returns:
             0257** ; - A: ASCII of the pressed key
             0258** ; - F: Z if the key is pressed, otherwise NZ
             0259** ;
0B432D 3A    0260** READKEY:		LD	A, (KEYDOWN)		; Get key down
0B432E 47 
0B432F 51 
0B4330 0B 
0B4331 3D    0261** DEC	A 			; Set Z flag if keydown is 1
0B4332 3A    0262** LD	A, (KEYASCII)		; Get key ASCII value
0B4333 48 
0B4334 51 
0B4335 0B 
0B4336 C9    0263** RET
             0264** ;
             0265** ; TRAP
             0266** ; This is called whenever BASIC needs to check for ESC
             0267** ;
0B4337 CD    0268** TRAP:			CALL	ESCTEST			; Read keyboard, test for ESC, set FLAGS
0B4338 23 
0B4339 43 
0B433A 0B 
             0269** ;
0B433B 3A    0270** LTRAP:			LD	A,(FLAGS)		; Get FLAGS
0B433C 42 
0B433D 51 
0B433E 0B 
0B433F B7    0271** OR	A			; This checks for bit 7; if it is not set then the result will
0B4340 F0    0272** RET	P			; be positive (bit 7 is the sign bit in Z80), so return
0B4341 21    0273** LTRAP1:			LD	HL,FLAGS 		; Escape is pressed at this point, so
0B4342 42 
0B4343 51 
0B4344 0B 
0B4345 CB    0274** RES	7,(HL)			; Clear the escape pressed flag and
0B4346 BE 
0B4347 C3    0275** JP	ESCAPE			; Jump to the ESCAPE error routine in exec.asm
0B4348 65 
0B4349 10 
0B434A 0B 
             0276** 
             0277** ;OSINIT - Initialise RAM mapping etc.
             0278** ;If BASIC is entered by BBCBASIC FILENAME then file
             0279** ;FILENAME.BBC is automatically CHAINed.
             0280** ;   Outputs: DE = initial value of HIMEM (top of RAM)
             0281** ;            HL = initial value of PAGE (user program)
             0282** ;            Z-flag reset indicates AUTO-RUN.
             0283** ;  Destroys: A,D,E,H,L,F
             0284** ;
0B434B CD    0285** OSINIT:			CALL	VBLANK_INIT
0B434C AA 
0B434D 4C 
0B434E 0B 
0B434F AF    0286** XOR	A
0B4350 21    0287** LD 	HL, USER
0B4351 00 
0B4352 52 
0B4353 0B 
0B4354 11    0288** LD	DE, RAM_Top
0B4355 00 
0B4356 00 
0B4357 0B 
0B4358 5F    0289** LD	E, A			; Page boundary
0B4359 C9    0290** RET
             0291** 
             0292** ;
             0293** ;OSCLI - Process a MOS command
             0294** ;
0B435A CD    0295** OSCLI: 			CALL    SKIPSP
0B435B CE 
0B435C 43 
0B435D 0B 
0B435E FE    0296** CP      CR
0B435F 0D 
0B4360 C8    0297** RET     Z
0B4361 FE    0298** CP      '|'
0B4362 7C 
0B4363 C8    0299** RET     Z
0B4364 EB    0300** EX      DE,HL
0B4365 21    0301** LD      HL,COMDS
0B4366 DD 
0B4367 43 
0B4368 0B 
0B4369 1A    0302** OSCLI0:			LD      A,(DE)
0B436A CD    0303** CALL    UPPRC
0B436B D5 
0B436C 43 
0B436D 0B 
0B436E BE    0304** CP      (HL)
0B436F 28    0305** JR      Z,OSCLI2
0B4370 0B 
0B4371 38    0306** JR      C,OSCLI6
0B4372 30 
0B4373 CB    0307** OSCLI1:			BIT     7,(HL)
0B4374 7E 
0B4375 23    0308** INC     HL
0B4376 28    0309** JR      Z,OSCLI1
0B4377 FB 
0B4378 23    0310** INC     HL
0B4379 23    0311** INC     HL
0B437A 18    0312** JR      OSCLI0
0B437B ED 
             0313** ;
0B437C D5    0314** OSCLI2:			PUSH    DE
0B437D 13    0315** OSCLI3:			INC     DE
0B437E 23    0316** INC     HL
0B437F 1A    0317** LD      A,(DE)
0B4380 CD    0318** CALL    UPPRC
0B4381 D5 
0B4382 43 
0B4383 0B 
0B4384 FE    0319** CP      '.'			; ABBREVIATED?
0B4385 2E 
0B4386 28    0320** JR      Z,OSCLI4
0B4387 0A 
0B4388 AE    0321** XOR     (HL)
0B4389 28    0322** JR      Z,OSCLI3
0B438A F2 
0B438B FE    0323** CP      80H
0B438C 80 
0B438D 28    0324** JR      Z,OSCLI4
0B438E 03 
0B438F D1    0325** POP     DE
0B4390 18    0326** JR      OSCLI1
0B4391 E1 
             0327** ;
0B4392 F1    0328** OSCLI4:			POP     AF
0B4393 13    0329** INC     DE
0B4394 CB    0330** OSCLI5:			BIT     7,(HL)
0B4395 7E 
0B4396 23    0331** INC     HL
0B4397 28    0332** JR      Z,OSCLI5
0B4398 FB 
0B4399 7E    0333** LD      A,(HL)
0B439A 23    0334** INC     HL
0B439B 66    0335** LD      H,(HL)
0B439C 6F    0336** LD      L,A
0B439D E5    0337** PUSH    HL
0B439E EB    0338** EX      DE,HL
0B439F C3    0339** JP      SKIPSP
0B43A0 CE 
0B43A1 43 
0B43A2 0B 
             0340** ;
0B43A3 EB    0341** OSCLI6:			EX	DE, HL			; HL: Buffer for command
0B43A4 11    0342** LD	DE, ACCS		; Buffer for command string is ACCS (the string accumulator)
0B43A5 00 
0B43A6 4E 
0B43A7 0B 
0B43A8 D5    0343** PUSH	DE			; Store buffer address
0B43A9 CD    0344** CALL	CSTR_LINE		; Fetch the line
0B43AA F5 
0B43AB 41 
0B43AC 0B 
0B43AD E1    0345** POP	HL			; HL: Pointer to command string in ACCS
0B43AE FD    0346** PUSH	IY
0B43AF E5 
             0347** MOSCALL	mos_oscli		; Returns OSCLI error in A
0B43B0 3E   0001**M LD	A, function
0B43B1 10 
0B43B2 49   0002**M RST.LIS	08h
0B43B3 CF 
0B43B4 FD    0348** POP	IY
0B43B5 E1 
0B43B6 B7    0349** OR	A			; 0 means MOS returned OK
0B43B7 C8    0350** RET	Z			; So don't do anything
0B43B8 C3    0351** JP 	OSERROR			; Otherwise it's a MOS error
0B43B9 E1 
0B43BA 45 
0B43BB 0B 
             0352** 
0B43BC 3E    0353** HUH:    		LD      A,254			; Bad command error
0B43BD FE 
0B43BE CD    0354** CALL    EXTERR
0B43BF 41 
0B43C0 3B 
0B43C1 0B 
0B43C2 42    0355** DB    	"Bad command"
0B43C3 61 
0B43C4 64 
0B43C5 20 
0B43C5 63   
0B43C6 6F 
0B43C7 6D 
0B43C8 6D 
0B43C8 61   
0B43C9 6E 
0B43CA 64 
0B43CD 00    0356** DEFB    0
             0357** 
0B43CE 7E    0358** SKIPSP:			LD      A,(HL)
0B43CF FE    0359** CP      ' '
0B43D0 20 
0B43D1 C0    0360** RET     NZ
0B43D2 23    0361** INC     HL
0B43D3 18    0362** JR      SKIPSP
0B43D4 F9 
             0363** 
0B43D5 E6    0364** UPPRC:  		AND     7FH
0B43D6 7F 
0B43D7 FE    0365** CP      '`'
0B43D8 60 
0B43D9 D8    0366** RET     C
0B43DA E6    0367** AND     5FH			; CONVERT TO UPPER CASE
0B43DB 5F 
0B43DC C9    0368** RET
             0369** 
             0370** ; Each command has bit 7 of the last character set, and is followed by the address of the handler
             0371** ; These must be in alphabetical order
             0372** ;
             0373** ; BEGIN NOT FOUND IN BINARY
             0374** ; COMDS:  		DB	"AS","M"+80h		; ASM
             0375** ; 			DW	STAR_ASM
             0376** ; 			DB	"BY","E"+80h		; BYE
             0377** ; 			DW	STAR_BYE
             0378** ; 			DB	"EDI","T"+80h		; EDIT
             0379** ; 			DW	STAR_EDIT
             0380** ; 			DB	"F","X"+80h		; FX
             0381** ; 			DW	STAR_FX
             0382** ; 			DB	"VERSIO","N"+80h	; VERSION
             0383** ; 			DW	STAR_VERSION
             0384** ; 			DB	FFh
             0385** ; END NOT FOUND IN BINARY
             0386** ; BEGIN INSERTED FROM BINARY
             0387** ; Each command has bit 7 of the last character set, and is followed by the address of the handler
             0388** ; These must be in alphabetical order
             0389** ;
             0390** COMDS:
0B43DD 42    0391** db 0x42 ; 044013 41     11404 COMDS:  		DB	"AS","M"+80h		; ASM
0B43DE 59    0392** db 0x59 ; 044014
0B43DF C5    0393** db 0xc5 ; 044015
0B43E0 2C    0394** db 0x2c ; 044016 31     11405 DW	STAR_ASM
0B43E1 40    0395** db 0x40 ; 044017
0B43E2 45    0396** db 0x45 ; 044018 42     11406 DB	"BY","E"+80h		; BYE
0B43E3 44    0397** db 0x44 ; 044019
0B43E4 49    0398** db 0x49 ; 04401A
0B43E5 D4    0399** db 0xd4 ; 04401B 3D     11407 DW	STAR_BYE
0B43E6 61    0400** db 0x61 ; 04401C
0B43E7 40    0401** db 0x40 ; 04401D 45     11408 DB	"EDI","T"+80h		; EDIT
0B43E8 46    0402** db 0x46 ; 04401E
0B43E9 D8    0403** db 0xd8 ; 04401F
0B43EA A1    0404** db 0xa1 ; 044020
0B43EB 40    0405** db 0x40 ; 044021 72     11409 DW	STAR_EDIT
0B43EC 56    0406** db 0x56 ; 044022
0B43ED 45    0407** db 0x45 ; 044023 46     11410 DB	"F","X"+80h		; FX
0B43EE 52    0408** db 0x52 ; 044024
0B43EF 53    0409** db 0x53 ; 044025 B2     11411 DW	STAR_FX
0B43F0 49    0410** db 0x49 ; 044026
0B43F1 4F    0411** db 0x4f ; 044027 56     11412 DB	"VERSIO","N"+80h	; VERSION
0B43F2 CE    0412** db 0xce ; 044028
0B43F3 38    0413** db 0x38 ; 044029
0B43F4 40    0414** db 0x40 ; 04402A
0B43F5 FF    0415** db 0xff ; 04402B
             0416** ; END INSERTED FROM BINARY
             0417** 
             0418** ; BEGIN NOT FOUND IN BINARY
             0419** ; ; *ASM string
             0420** ; ;
             0421** ; STAR_ASM:		PUSH	IY			; Stack the BASIC pointer
             0422** ; 			PUSH	HL			; HL = IY
             0423** ; 			POP	IY
             0424** ; 			CALL	ASSEM			; Invoke the assembler
             0425** ; 			POP	IY
             0426** ; 			RET
             0427** ; END NOT FOUND IN BINARY
             0428** 
             0429** ; *BYE
             0430** ;
0B43F6 CD    0431** STAR_BYE:		CALL	VBLANK_STOP		; Restore MOS interrupts
0B43F7 BE 
0B43F8 4C 
0B43F9 0B 
0B43FA 21    0432** LD	HL, 0			; The return value
0B43FB 00 
0B43FC 00 
0B43FD 00 
0B43FE C3    0433** JP	_basic_end 			; Jump back to the end routine in init.asm
0B43FF D1 
0B4400 03 
0B4401 0B 
             0434** 
             0435** ; *VERSION
             0436** ;
0B4402 CD    0437** STAR_VERSION:		CALL    TELL			; Output the welcome message
0B4403 5A 
0B4404 41 
0B4405 0B 
0B4406 42    0438** DB    	"BBC BASIC (Agon ADL) Version 1.03\n\r",0
0B4407 42 
0B4408 43 
0B4409 20 
0B4409 42   
0B440A 41 
0B440B 53 
0B440C 49 
0B440C 43   
0B440D 20 
0B440E 28 
0B440F 41 
0B440F 67   
0B4410 6F 
0B4411 6E 
0B4412 20 
0B4412 41   
0B4413 44 
0B4414 4C 
0B4415 29 
0B4415 20   
0B4416 56 
0B4417 65 
0B4418 72 
0B4418 73   
0B4419 69 
0B441A 6F 
0B441B 6E 
0B441B 20   
0B441C 31 
0B441D 2E 
0B441E 30 
0B441E 33   
0B441F 0A 
0B4420 0D 
0B4421 00 
0B442A C9    0439** RET
             0440** 
             0441** ; *EDIT linenum
             0442** ;
0B442B CD    0443** STAR_EDIT:		CALL	ASC_TO_NUMBER		; DE: Line number to edit
0B442C 61 
0B442D 41 
0B442E 0B 
0B442F EB    0444** EX	DE, HL			; HL: Line number
0B4430 CD    0445** CALL	FINDL			; HL: Address in RAM of tokenised line
0B4431 59 
0B4432 3D 
0B4433 0B 
0B4434 3E    0446** LD	A, 41			; F:NZ If the line is not found
0B4435 29 
0B4436 C2    0447** JP	NZ, ERROR_		; Do error 41: No such line in that case
0B4437 2A 
0B4438 3B 
0B4439 0B 
             0448** ;
             0449** ; Use LISTIT to output the line to the ACCS buffer
             0450** ;
0B443A 23    0451** INC	HL			; Skip the length byte
0B443B 5E    0452** LD	E, (HL)			; Fetch the line number
0B443C 23    0453** INC	HL
0B443D 56    0454** LD	D, (HL)
0B443E 23    0455** INC	HL
0B443F DD    0456** LD	IX, ACCS		; Pointer to where the copy is to be stored
0B4440 21 
0B4441 00 
0B4442 4E 
0B4442 0B   
0B4444 DD    0457** LD	(OSWRCHPT), IX
0B4445 22 
0B4446 43 
0B4447 51 
0B4447 0B   
0B4449 DD    0458** LD	IX, LISTON		; Pointer to LISTON variable in RAM
0B444A 21 
0B444B 40 
0B444C 51 
0B444C 0B   
0B444E DD    0459** LD	A, (IX)			; Store that variable
0B444F 7E 
0B4450 00 
0B4451 F5    0460** PUSH	AF
0B4452 DD    0461** LD	(IX), 09h		; Set to echo to buffer
0B4453 36 
0B4454 00 
0B4455 09 
0B4456 CD    0462** CALL	LISTIT
0B4457 5C 
0B4458 3C 
0B4459 0B 
0B445A F1    0463** POP	AF
0B445B DD    0464** LD	(IX), A			; Restore the original LISTON variable
0B445C 77 
0B445D 00 
0B445E 21    0465** LD	HL, ACCS		; HL: ACCS
0B445F 00 
0B4460 4E 
0B4461 0B 
0B4462 5D    0466** LD	E, L			;  E: 0 - Don't clear the buffer; ACCS is on a page boundary so L is 0
0B4463 CD    0467** CALL	OSLINE1			; Invoke the editor
0B4464 2B 
0B4465 42 
0B4466 0B 
0B4467 C3    0468** JP	ONEDIT			; Jump back to the BASIC loop just after the normal line edit
0B4468 9A 
0B4469 34 
0B446A 0B 
             0469** 
             0470** ; OSCLI FX n
             0471** ;
0B446B CD    0472** STAR_FX:		CALL	ASC_TO_NUMBER
0B446C 61 
0B446D 41 
0B446E 0B 
0B446F 4B    0473** LD	C, E			; C: Save FX #
0B4470 CD    0474** CALL	ASC_TO_NUMBER
0B4471 61 
0B4472 41 
0B4473 0B 
0B4474 7A    0475** LD	A, D  			; Is first parameter > 255?
0B4475 B7    0476** OR 	A
0B4476 28    0477** JR	Z, STAR_FX1		; Yes, so skip next bit
0B4477 03 
0B4478 EB    0478** EX	DE, HL 			; Parameter is 16-bit
0B4479 18    0479** JR	STAR_FX2
0B447A 07 
             0480** ;
0B447B 43    0481** STAR_FX1:		LD	B, E 			; B: Save First parameter
0B447C CD    0482** CALL	ASC_TO_NUMBER		; Fetch second parameter
0B447D 61 
0B447E 41 
0B447F 0B 
0B4480 68    0483** LD	L, B 			; L: First parameter
0B4481 63    0484** LD	H, E 			; H: Second parameter
             0485** ;
0B4482 79    0486** STAR_FX2:		LD	A, C 			; A: FX #, and fall through to OSBYTE
             0487** ;
             0488** ; OSBYTE
             0489** ;  A: FX #
             0490** ;  L: First parameter
             0491** ;  H: Second parameter
             0492** ;
0B4483 FE    0493** OSBYTE:			CP	0BH			; *FX 11, n: Keyboard auto-repeat delay
0B4484 0B 
0B4485 28    0494** JR	Z, OSBYTE_0B
0B4486 18 
0B4487 FE    0495** CP	0CH			; *FX 12, n: Keyboard auto-repeat rate
0B4488 0C 
0B4489 28    0496** JR	Z, OSBYTE_0C
0B448A 43 
0B448B FE    0497** CP	13H			; *FX 19: Wait for vblank
0B448C 13 
0B448D 28    0498** JR	Z, OSBYTE_13
0B448E 6E 
0B448F FE    0499** CP	76H			; *FX 118, n: Set keyboard LED
0B4490 76 
0B4491 CA    0500** JP	Z, OSBYTE_76
0B4492 18 
0B4493 45 
0B4494 0B 
0B4495 FE    0501** CP	A0H
0B4496 A0 
0B4497 CA    0502** JP	Z, OSBYTE_A0
0B4498 48 
0B4499 45 
0B449A 0B 
0B449B C3    0503** JP	HUH			; Anything else trips an error
0B449C BC 
0B449D 43 
0B449E 0B 
             0504** 
             0505** ; OSBYTE 0x0B (FX 11,n): Keyboard auto-repeat delay
             0506** ; Parameters:
             0507** ; - HL: Repeat delay
             0508** ;
             0509** OSBYTE_0B:		VDU	23
0B449F 3E   0001**M LD	A, val
0B44A0 17 
0B44A1 CD   0002**M CALL	OSWRCH
0B44A2 CA 
0B44A3 42 
0B44A4 0B 
             0510** VDU	0
0B44A5 3E   0001**M LD	A, val
0B44A6 00 
0B44A7 CD   0002**M CALL	OSWRCH
0B44A8 CA 
0B44A9 42 
0B44AA 0B 
             0511** VDU	vdp_keystate
0B44AB 3E   0001**M LD	A, val
0B44AC 88 
0B44AD CD   0002**M CALL	OSWRCH
0B44AE CA 
0B44AF 42 
0B44B0 0B 
             0512** VDU	L
0B44B1 7D   0001**M LD	A, val
0B44B2 CD   0002**M CALL	OSWRCH
0B44B3 CA 
0B44B4 42 
0B44B5 0B 
             0513** VDU	H
0B44B6 7C   0001**M LD	A, val
0B44B7 CD   0002**M CALL	OSWRCH
0B44B8 CA 
0B44B9 42 
0B44BA 0B 
             0514** VDU	0
0B44BB 3E   0001**M LD	A, val
0B44BC 00 
0B44BD CD   0002**M CALL	OSWRCH
0B44BE CA 
0B44BF 42 
0B44C0 0B 
             0515** VDU 	0
0B44C1 3E   0001**M LD	A, val
0B44C2 00 
0B44C3 CD   0002**M CALL	OSWRCH
0B44C4 CA 
0B44C5 42 
0B44C6 0B 
             0516** VDU	255
0B44C7 3E   0001**M LD	A, val
0B44C8 FF 
0B44C9 CD   0002**M CALL	OSWRCH
0B44CA CA 
0B44CB 42 
0B44CC 0B 
0B44CD C9    0517** RET
             0518** 
             0519** ; OSBYTE 0x0C (FX 12,n): Keyboard auto-repeat rate
             0520** ; Parameters:
             0521** ; - HL: Repeat rate
             0522** ;
             0523** OSBYTE_0C:		VDU	23
0B44CE 3E   0001**M LD	A, val
0B44CF 17 
0B44D0 CD   0002**M CALL	OSWRCH
0B44D1 CA 
0B44D2 42 
0B44D3 0B 
             0524** VDU	0
0B44D4 3E   0001**M LD	A, val
0B44D5 00 
0B44D6 CD   0002**M CALL	OSWRCH
0B44D7 CA 
0B44D8 42 
0B44D9 0B 
             0525** VDU	vdp_keystate
0B44DA 3E   0001**M LD	A, val
0B44DB 88 
0B44DC CD   0002**M CALL	OSWRCH
0B44DD CA 
0B44DE 42 
0B44DF 0B 
             0526** VDU	0
0B44E0 3E   0001**M LD	A, val
0B44E1 00 
0B44E2 CD   0002**M CALL	OSWRCH
0B44E3 CA 
0B44E4 42 
0B44E5 0B 
             0527** VDU 	0
0B44E6 3E   0001**M LD	A, val
0B44E7 00 
0B44E8 CD   0002**M CALL	OSWRCH
0B44E9 CA 
0B44EA 42 
0B44EB 0B 
             0528** VDU	L
0B44EC 7D   0001**M LD	A, val
0B44ED CD   0002**M CALL	OSWRCH
0B44EE CA 
0B44EF 42 
0B44F0 0B 
             0529** VDU	H
0B44F1 7C   0001**M LD	A, val
0B44F2 CD   0002**M CALL	OSWRCH
0B44F3 CA 
0B44F4 42 
0B44F5 0B 
             0530** VDU	255
0B44F6 3E   0001**M LD	A, val
0B44F7 FF 
0B44F8 CD   0002**M CALL	OSWRCH
0B44F9 CA 
0B44FA 42 
0B44FB 0B 
0B44FC C9    0531** RET
             0532** 
             0533** ; OSBYTE 0x13 (FX 19): Wait for vertical blank interrupt
             0534** ;
0B44FD CD    0535** OSBYTE_13:		CALL	WAIT_VBLANK
0B44FE 07 
0B44FF 45 
0B4500 0B 
0B4501 2E    0536** LD	L, 0			; Returns 0
0B4502 00 
0B4503 C3    0537** JP	COUNT0
0B4504 49 
0B4505 09 
0B4506 0B 
             0538** ;
0B4507 DD    0539** WAIT_VBLANK:		PUSH 	IX			; Wait for VBLANK interrupt
0B4508 E5 
             0540** MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B4509 3E   0001**M LD	A, function
0B450A 08 
0B450B 49   0002**M RST.LIS	08h
0B450C CF 
0B450D DD    0541** LD	A, (IX + sysvar_time + 0)
0B450E 7E 
0B450F 00 
0B4510 DD    0542** @@:			CP 	A, (IX + sysvar_time + 0)
0B4511 BE 
0B4512 00 
0B4513 28    0543** JR	Z, @B
0B4514 FB 
0B4515 DD    0544** POP	IX
0B4516 E1 
0B4517 C9    0545** RET
             0546** 
             0547** ; OSBYTE 0x76 (FX 118,n): Set Keyboard LED
             0548** ; Parameters:
             0549** ; - L: LED (Bit 0: Scroll Lock, Bit 1: Caps Lock, Bit 2: Num Lock)
             0550** ;
             0551** OSBYTE_76:		VDU	23
0B4518 3E   0001**M LD	A, val
0B4519 17 
0B451A CD   0002**M CALL	OSWRCH
0B451B CA 
0B451C 42 
0B451D 0B 
             0552** VDU	0
0B451E 3E   0001**M LD	A, val
0B451F 00 
0B4520 CD   0002**M CALL	OSWRCH
0B4521 CA 
0B4522 42 
0B4523 0B 
             0553** VDU	vdp_keystate
0B4524 3E   0001**M LD	A, val
0B4525 88 
0B4526 CD   0002**M CALL	OSWRCH
0B4527 CA 
0B4528 42 
0B4529 0B 
             0554** VDU	0
0B452A 3E   0001**M LD	A, val
0B452B 00 
0B452C CD   0002**M CALL	OSWRCH
0B452D CA 
0B452E 42 
0B452F 0B 
             0555** VDU 	0
0B4530 3E   0001**M LD	A, val
0B4531 00 
0B4532 CD   0002**M CALL	OSWRCH
0B4533 CA 
0B4534 42 
0B4535 0B 
             0556** VDU	0
0B4536 3E   0001**M LD	A, val
0B4537 00 
0B4538 CD   0002**M CALL	OSWRCH
0B4539 CA 
0B453A 42 
0B453B 0B 
             0557** VDU	0
0B453C 3E   0001**M LD	A, val
0B453D 00 
0B453E CD   0002**M CALL	OSWRCH
0B453F CA 
0B4540 42 
0B4541 0B 
             0558** VDU	L
0B4542 7D   0001**M LD	A, val
0B4543 CD   0002**M CALL	OSWRCH
0B4544 CA 
0B4545 42 
0B4546 0B 
0B4547 C9    0559** RET
             0560** 
             0561** ; OSBYTE 0xA0: Fetch system variable
             0562** ; Parameters:
             0563** ; - L: The system variable to fetch
             0564** ;
0B4548 DD    0565** OSBYTE_A0:		PUSH	IX
0B4549 E5 
             0566** MOSCALL	mos_sysvars		; Fetch pointer to system variables
0B454A 3E   0001**M LD	A, function
0B454B 08 
0B454C 49   0002**M RST.LIS	08h
0B454D CF 
0B454E 01    0567** LD	BC, 0
0B454F 00 
0B4550 00 
0B4551 00 
0B4552 4D    0568** LD	C, L			; BCU = L
0B4553 DD    0569** ADD	IX, BC			; Add to IX
0B4554 09 
0B4555 DD    0570** LD	L, (IX + 0)		; Fetch the return value
0B4556 6E 
0B4557 00 
0B4558 DD    0571** POP	IX
0B4559 E1 
0B455A C3    0572** JP 	COUNT0
0B455B 49 
0B455C 09 
0B455D 0B 
             0573** 
             0574** ;OSLOAD - Load an area of memory from a file.
             0575** ;   Inputs: HL addresses filename (CR terminated)
             0576** ;           DE = address at which to load
             0577** ;           BC = maximum allowed size (bytes)
             0578** ;  Outputs: Carry reset indicates no room for file.
             0579** ; Destroys: A,B,C,D,E,H,L,F
             0580** ;
0B455E C5    0581** OSLOAD:			PUSH	BC			; Stack the size
0B455F D5    0582** PUSH	DE			; Stack the load address
0B4560 11    0583** LD	DE, ACCS		; Buffer address for filename
0B4561 00 
0B4562 4E 
0B4563 0B 
0B4564 CD    0584** CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B4565 E3 
0B4566 41 
0B4567 0B 
0B4568 21    0585** LD	HL, ACCS		; HL: Filename
0B4569 00 
0B456A 4E 
0B456B 0B 
0B456C CD    0586** CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B456D 5E 
0B456E 46 
0B456F 0B 
0B4570 CD    0587** CALL	EXT_HANDLER		; Get the default handler
0B4571 72 
0B4572 46 
0B4573 0B 
0B4574 D1    0588** POP	DE			; Restore the load address
0B4575 C1    0589** POP	BC			; Restore the size
0B4576 B7    0590** OR	A
0B4577 28    0591** JR 	Z, OSLOAD_BBC
0B4578 60 
             0592** ;
             0593** ; Load the file in as a text file
             0594** ;
0B4579 AF    0595** OSLOAD_TXT:		XOR	A			; Set file attributes to read
0B457A CD    0596** CALL	OSOPEN			; Open the file
0B457B E6 
0B457C 46 
0B457D 0B 
0B457E 5F    0597** LD 	E, A 			; The filehandle
0B457F B7    0598** OR	A
0B4580 3E    0599** LD	A, 4			; File not found error
0B4581 04 
0B4582 28    0600** JR	Z, OSERROR		; Jump to error handler
0B4583 5D 
0B4584 CD    0601** CALL	NEWIT			; Call NEW to clear the program space
0B4585 36 
0B4586 3C 
0B4587 0B 
             0602** ;
0B4588 21    0603** OSLOAD_TXT1:		LD	HL, ACCS 		; Where the input is going to be stored
0B4589 00 
0B458A 4E 
0B458B 0B 
             0604** ;
             0605** ; First skip any whitespace (indents) at the beginning of the input
             0606** ;
0B458C CD    0607** @@:			CALL	OSBGET			; Read the byte into A
0B458D FD 
0B458E 46 
0B458F 0B 
0B4590 38    0608** JR	C, OSLOAD_TXT3		; Is it EOF?
0B4591 1E 
0B4592 FE    0609** CP	LF 			; Is it LF?
0B4593 0A 
0B4594 28    0610** JR	Z, OSLOAD_TXT3 		; Yes, so skip to the next line
0B4595 1A 
0B4596 FE    0611** CP	21h			; Is it less than or equal to ASCII space?
0B4597 21 
0B4598 38    0612** JR	C, @B 			; Yes, so keep looping
0B4599 F2 
0B459A 77    0613** LD	(HL), A 		; Store the first character
0B459B 2C    0614** INC	L
             0615** ;
             0616** ; Now read the rest of the line in
             0617** ;
0B459C CD    0618** OSLOAD_TXT2:		CALL	OSBGET			; Read the byte into A
0B459D FD 
0B459E 46 
0B459F 0B 
0B45A0 38    0619** JR	C, OSLOAD_TXT4		; Is it EOF?
0B45A1 2B 
0B45A2 FE    0620** CP	20h			; Skip if not an ASCII character
0B45A3 20 
0B45A4 38    0621** JR	C, @F
0B45A5 06 
0B45A6 77    0622** LD	(HL), A 		; Store in the input buffer
0B45A7 2C    0623** INC	L			; Increment the buffer pointer
0B45A8 CA    0624** JP	Z, BAD			; If the buffer is full (wrapped to 0) then jump to Bad Program error
0B45A9 C2 
0B45AA 3A 
0B45AB 0B 
0B45AC FE    0625** @@:			CP	LF			; Check for LF
0B45AD 0A 
0B45AE 20    0626** JR	NZ, OSLOAD_TXT2		; If not, then loop to read the rest of the characters in
0B45AF EC 
             0627** ;
             0628** ; Finally, handle EOL/EOF
             0629** ;
0B45B0 36    0630** OSLOAD_TXT3:		LD	(HL), CR		; Store a CR for BBC BASIC
0B45B1 0D 
0B45B2 7D    0631** LD	A, L			; Check for minimum line length
0B45B3 FE    0632** CP	2			; If it is 2 characters or less (including CR)
0B45B4 02 
0B45B5 38    0633** JR	C, @F			; Then don't bother entering it
0B45B6 0A 
0B45B7 D5    0634** PUSH	DE			; Preserve the filehandle
0B45B8 CD    0635** CALL	ONEDIT1			; Enter the line in memory
0B45B9 A6 
0B45BA 34 
0B45BB 0B 
0B45BC DC    0636** CALL	C,CLEAN			; If a new line has been entered, then call CLEAN to set TOP and write &FFFF end of program marker
0B45BD 09 
0B45BE 3C 
0B45BF 0B 
0B45C0 D1    0637** POP	DE
0B45C1 CD    0638** @@:			CALL	OSSTAT			; End of file?
0B45C2 0E 
0B45C3 47 
0B45C4 0B 
0B45C5 20    0639** JR	NZ, OSLOAD_TXT1		; No, so loop
0B45C6 C1 
0B45C7 CD    0640** CALL	OSSHUT			; Close the file
0B45C8 F5 
0B45C9 46 
0B45CA 0B 
0B45CB 37    0641** SCF				; Flag to BASIC that we're good
0B45CC C9    0642** RET
             0643** ;
             0644** ; Special case for BASIC programs with no blank line at the end
             0645** ;
0B45CD FE    0646** OSLOAD_TXT4:		CP	20h			; Skip if not an ASCII character
0B45CE 20 
0B45CF 38    0647** JR	C, @F
0B45D0 06 
0B45D1 77    0648** LD	(HL), A			; Store the character
0B45D2 2C    0649** INC	L
0B45D3 CA    0650** JP	Z, BAD
0B45D4 C2 
0B45D5 3A 
0B45D6 0B 
0B45D7 18    0651** @@:			JR	OSLOAD_TXT3
0B45D8 D7 
             0652** 
             0653** ;
             0654** ; Load the file in as a tokenised binary blob
             0655** ;
             0656** OSLOAD_BBC:		MOSCALL	mos_load		; Call LOAD in MOS
0B45D9 3E   0001**M LD	A, function
0B45DA 01 
0B45DB 49   0002**M RST.LIS	08h
0B45DC CF 
0B45DD D0    0657** RET	NC			; If load returns with carry reset - NO ROOM
0B45DE B7    0658** OR	A			; If there is no error (A=0)
0B45DF 37    0659** SCF				; Need to set carry indicating there was room
0B45E0 C8    0660** RET	Z			; Return
             0661** ;
0B45E1 F5    0662** OSERROR:		PUSH	AF			; Handle the MOS error
0B45E2 21    0663** LD	HL, ACCS		; Address of the buffer
0B45E3 00 
0B45E4 4E 
0B45E5 0B 
0B45E6 01    0664** LD	BC, 256			; Length of the buffer
0B45E7 00 
0B45E8 01 
0B45E9 00 
0B45EA 5F    0665** LD	E, A			; The error code
             0666** MOSCALL	mos_getError		; Copy the error message into the buffer
0B45EB 3E   0001**M LD	A, function
0B45EC 0F 
0B45ED 49   0002**M RST.LIS	08h
0B45EE CF 
0B45EF F1    0667** POP	AF
0B45F0 E5    0668** PUSH	HL			; Stack the address of the error (now in ACCS)
0B45F1 C6    0669** ADD	A, 127			; Add 127 to the error code (MOS errors start at 128, and are trappable)
0B45F2 7F 
0B45F3 C3    0670** JP	EXTERR			; Trigger an external error
0B45F4 41 
0B45F5 3B 
0B45F6 0B 
             0671** 
             0672** ;OSSAVE - Save an area of memory to a file.
             0673** ;   Inputs: HL addresses filename (term CR)
             0674** ;           DE = start address of data to save
             0675** ;           BC = length of data to save (bytes)
             0676** ; Destroys: A,B,C,D,E,H,L,F
             0677** ;
0B45F7 C5    0678** OSSAVE:			PUSH	BC			; Stack the size
0B45F8 D5    0679** PUSH	DE			; Stack the save address
0B45F9 11    0680** LD	DE, ACCS		; Buffer address for filename
0B45FA 00 
0B45FB 4E 
0B45FC 0B 
0B45FD CD    0681** CALL	CSTR_FNAME		; Fetch filename from MOS into buffer
0B45FE E3 
0B45FF 41 
0B4600 0B 
0B4601 21    0682** LD	HL, ACCS		; HL: Filename
0B4602 00 
0B4603 4E 
0B4604 0B 
0B4605 CD    0683** CALL	EXT_DEFAULT		; Tack on the extension .BBC if not specified
0B4606 5E 
0B4607 46 
0B4608 0B 
0B4609 CD    0684** CALL	EXT_HANDLER		; Get the default handler
0B460A 72 
0B460B 46 
0B460C 0B 
0B460D D1    0685** POP	DE			; Restore the save address
0B460E C1    0686** POP	BC			; Restore the size
0B460F B7    0687** OR	A			; Is the extension .BBC
0B4610 28    0688** JR	Z, OSSAVE_BBC		; Yes, so use that
0B4611 44 
             0689** ;
             0690** ; Save the file out as a text file
             0691** ;
0B4612 3A    0692** OSSAVE_TXT:		LD 	A, (OSWRCHCH)		; Stack the current channel
0B4613 45 
0B4614 51 
0B4615 0B 
0B4616 F5    0693** PUSH	AF
0B4617 AF    0694** XOR	A
0B4618 3C    0695** INC	A			; Make sure C is clear, A is 1, for OPENOUT
0B4619 32    0696** LD	(OSWRCHCH), A
0B461A 45 
0B461B 51 
0B461C 0B 
0B461D CD    0697** CALL	OSOPEN			; Open the file
0B461E E6 
0B461F 46 
0B4620 0B 
0B4621 32    0698** LD	(OSWRCHFH), A		; Store the file handle for OSWRCH
0B4622 46 
0B4623 51 
0B4624 0B 
0B4625 DD    0699** LD	IX, LISTON		; Required for LISTIT
0B4626 21 
0B4627 40 
0B4628 51 
0B4628 0B   
0B462A 2A    0700** LD	HL, (PAGE_)		; Get start of program area
0B462B 14 
0B462C 51 
0B462D 0B 
0B462E D9    0701** EXX
0B462F 01    0702** LD	BC, 0			; Set the initial indent counters
0B4630 00 
0B4631 00 
0B4632 00 
0B4633 D9    0703** EXX
0B4634 7E    0704** OSSAVE_TXT1:		LD	A, (HL)			; Check for end of program marker
0B4635 B7    0705** OR	A
0B4636 28    0706** JR	Z, OSSAVE_TXT2
0B4637 0F 
0B4638 23    0707** INC	HL			; Skip the length byte
0B4639 11    0708** LD	DE, 0			; Clear DE to ensure we get a 16-bit line number
0B463A 00 
0B463B 00 
0B463C 00 
0B463D 5E    0709** LD	E, (HL)			; Get the line number
0B463E 23    0710** INC	HL
0B463F 56    0711** LD	D, (HL)
0B4640 23    0712** INC	HL
0B4641 CD    0713** CALL	LISTIT			; List the line
0B4642 5C 
0B4643 3C 
0B4644 0B 
0B4645 18    0714** JR	OSSAVE_TXT1
0B4646 ED 
0B4647 3A    0715** OSSAVE_TXT2:		LD	A, (OSWRCHFH)		; Get the file handle
0B4648 46 
0B4649 51 
0B464A 0B 
0B464B 5F    0716** LD	E, A
0B464C CD    0717** CALL	OSSHUT			; Close it
0B464D F5 
0B464E 46 
0B464F 0B 
0B4650 F1    0718** POP	AF			; Restore the channel
0B4651 32    0719** LD	(OSWRCHCH), A
0B4652 45 
0B4653 51 
0B4654 0B 
0B4655 C9    0720** RET
             0721** ;
             0722** ; Save the file out as a tokenised binary blob
             0723** ;
             0724** OSSAVE_BBC:		MOSCALL	mos_save		; Call SAVE in MOS
0B4656 3E   0001**M LD	A, function
0B4657 02 
0B4658 49   0002**M RST.LIS	08h
0B4659 CF 
0B465A B7    0725** OR	A			; If there is no error (A=0)
0B465B C8    0726** RET	Z			; Just return
0B465C 18    0727** JR	OSERROR			; Trip an error
0B465D 83 
             0728** 
             0729** ; Check if an extension is specified in the filename
             0730** ; Add a default if not specified
             0731** ; HL: Filename (CSTR format)
             0732** ;
0B465E E5    0733** EXT_DEFAULT:		PUSH	HL			; Stack the filename pointer
0B465F 0E    0734** LD	C, '.'			; Search for dot (marks start of extension)
0B4660 2E 
0B4661 CD    0735** CALL	CSTR_FINDCH
0B4662 03 
0B4663 42 
0B4664 0B 
0B4665 B7    0736** OR	A			; Check for end of string marker
0B4666 20    0737** JR	NZ, @F			; No, so skip as we have an extension at this point
0B4667 08 
0B4668 11    0738** LD	DE, EXT_LOOKUP		; Get the first (default extension)
0B4669 A2 
0B466A 46 
0B466B 0B 
0B466C CD    0739** CALL	CSTR_CAT		; Concat it to string pointed to by HL
0B466D 1A 
0B466E 42 
0B466F 0B 
0B4670 E1    0740** @@:			POP	HL			; Restore the filename pointer
0B4671 C9    0741** RET
             0742** 
             0743** ; Check if an extension is valid and, if so, provide a pointer to a handler
             0744** ; HL: Filename (CSTR format)
             0745** ; Returns:
             0746** ;  A: Filename extension type (0=BBC tokenised, 1=ASCII untokenised)
             0747** ;
0B4672 E5    0748** EXT_HANDLER:		PUSH	HL			; Stack the filename pointer
0B4673 0E    0749** LD	C, '.'			; Find the '.'
0B4674 2E 
0B4675 CD    0750** CALL	CSTR_FINDCH
0B4676 03 
0B4677 42 
0B4678 0B 
0B4679 11    0751** LD	DE, EXT_LOOKUP		; The lookup table
0B467A A2 
0B467B 46 
0B467C 0B 
             0752** ;
0B467D E5    0753** EXT_HANDLER_1:		PUSH	HL			; Stack the pointer to the extension
0B467E CD    0754** CALL	CSTR_ENDSWITH		; Check whether the string ends with the entry in the lookup
0B467F 0B 
0B4680 42 
0B4681 0B 
0B4682 E1    0755** POP	HL			; Restore the pointer to the extension
0B4683 28    0756** JR	Z, EXT_HANDLER_2	; We have a match!
0B4684 19 
             0757** ;
0B4685 1A    0758** @@:			LD	A, (DE)			; Skip to the end of the entry in the lookup
0B4686 13    0759** INC	DE
0B4687 B7    0760** OR	A
0B4688 20    0761** JR	NZ, @B
0B4689 FB 
0B468A 13    0762** INC	DE			; Skip the file extension # byte
             0763** ;
0B468B 1A    0764** LD	A, (DE)			; Are we at the end of the table?
0B468C B7    0765** OR	A
0B468D 20    0766** JR	NZ, EXT_HANDLER_1	; No, so loop
0B468E EE 
             0767** ;
0B468F 3E    0768** LD      A,204			; Throw a "Bad name" error
0B4690 CC 
0B4691 CD    0769** CALL    EXTERR
0B4692 41 
0B4693 3B 
0B4694 0B 
0B4695 42    0770** DB    	"Bad name", 0
0B4696 61 
0B4697 64 
0B4698 20 
0B4698 6E   
0B4699 61 
0B469A 6D 
0B469B 65 
0B469B 00   
             0771** ;
0B469E 13    0772** EXT_HANDLER_2:		INC	DE			; Skip to the file extension # byte
0B469F 1A    0773** LD	A, (DE)
0B46A0 E1    0774** POP	HL			; Restore the filename pointer
0B46A1 C9    0775** RET
             0776** ;
             0777** 
             0778** 
             0779** ; Extension lookup table
             0780** ; CSTR, TYPE
             0781** ; 	- 0: BBC (tokenised BBC BASIC for Z80 format)
             0782** ; 	- 1: Human readable plain text
             0783** ;
0B46A2 2E    0784** EXT_LOOKUP:		DB	".BBC", 0, 0		; First entry is the default extension
0B46A3 42 
0B46A4 42 
0B46A5 43 
0B46A5 00   
0B46A6 00 
0B46A8 2E    0785** DB	".TXT", 0, 1
0B46A9 54 
0B46AA 58 
0B46AB 54 
0B46AB 00   
0B46AC 01 
0B46AE 2E    0786** DB	".ASC", 0, 1
0B46AF 41 
0B46B0 53 
0B46B1 43 
0B46B1 00   
0B46B2 01 
0B46B4 2E    0787** DB	".BAS", 0, 1
0B46B5 42 
0B46B6 41 
0B46B7 53 
0B46B7 00   
0B46B8 01 
0B46BA 00    0788** DB	0			; End of table
             0789** 
             0790** ;OSCALL - Intercept page &FF calls and provide an alternative address
             0791** ;
             0792** ;&FFF7:	OSCLI	Execute *command.
             0793** ;&FFF4:	OSBYTE	Various byte-wide functions.
             0794** ;&FFF1:	OSWORD	Various control block functions.
             0795** ;&FFEE:	OSWRCH	Write character to output stream.
             0796** ;&FFE7:	OSNEWL	Write NewLine to output stream.
             0797** ;&FFE3:	OSASCI	Write character or NewLine to output stream.
             0798** ;&FFE0:	OSRDCH	Wait for character from input stream.
             0799** ;&FFDD:	OSFILE	Perform actions on whole files or directories.
             0800** ;&FFDA:	OSARGS	Read and write information on open files or filing systems.
             0801** ;&FFD7:	OSBGET	Read a byte from an a channel.
             0802** ;&FFD4:	OSBPUT	Write a byte to a channel.
             0803** ;&FFD1:	OSGBPB	Read and write blocks of data.
             0804** ;&FFCE:	OSFIND	Open or close a file.
             0805** ;
0B46BB 21    0806** OSCALL:			LD	HL, OSCALL_TABLE
0B46BC D1 
0B46BD 46 
0B46BE 0B 
0B46BF 7E    0807** OSCALL_1:		LD	A, (HL)
0B46C0 23    0808** INC	HL
0B46C1 FE    0809** CP	FFh
0B46C2 FF 
0B46C3 C8    0810** RET	Z
0B46C4 FD    0811** CP	A, IYL
0B46C5 BD 
0B46C6 28    0812** JR	Z, OSCALL_2
0B46C7 06 
0B46C8 D0    0813** RET	NC
0B46C9 23    0814** INC	HL
0B46CA 23    0815** INC	HL
0B46CB 23    0816** INC	HL
0B46CC 18    0817** JR	OSCALL_1
0B46CD F1 
0B46CE ED    0818** OSCALL_2:		LD	IY,(HL)
0B46CF 31 
0B46D0 C9    0819** RET
0B46D1 D4    0820** OSCALL_TABLE:		DB 	D4h
0B46D2 05    0821** DW24 	OSBPUT
0B46D3 47 
0B46D4 0B 
0B46D5 D7    0822** DB 	D7h
0B46D6 FD    0823** DW24 	OSBGET
0B46D7 46 
0B46D8 0B 
0B46D9 EE    0824** DB 	EEh
0B46DA CA    0825** DW24 	OSWRCH
0B46DB 42 
0B46DC 0B 
0B46DD F4    0826** DB	F4h
0B46DE 83    0827** DW24 	OSBYTE
0B46DF 44 
0B46E0 0B 
0B46E1 F7    0828** DB	F7h
0B46E2 5A    0829** DW24	OSCLI
0B46E3 43 
0B46E4 0B 
0B46E5 FF    0830** DB	FFh
             0831** 
             0832** ; OSOPEN
             0833** ; HL: Pointer to path
             0834** ;  F: C Z
             0835** ;     x x OPENIN
             0836** ; 	  OPENOUT
             0837** ;     x	  OPENUP
             0838** ; Returns:
             0839** ;  A: Filehandle, 0 if cannot open
             0840** ;
0B46E6 0E    0841** OSOPEN:			LD	C, fa_read
0B46E7 01 
0B46E8 28    0842** JR	Z, @F
0B46E9 06 
0B46EA 0E    0843** LD	C, fa_write | fa_open_append
0B46EB 32 
0B46EC 38    0844** JR	C, @F
0B46ED 02 
0B46EE 0E    0845** LD	C, fa_write | fa_create_always
0B46EF 0A 
             0846** @@:			MOSCALL	mos_fopen
0B46F0 3E   0001**M LD	A, function
0B46F1 0A 
0B46F2 49   0002**M RST.LIS	08h
0B46F3 CF 
0B46F4 C9    0847** RET
             0848** 
             0849** ;OSSHUT - Close disk file(s).
             0850** ; E = file channel
             0851** ;  If E=0 all files are closed (except SPOOL)
             0852** ; Destroys: A,B,C,D,E,H,L,F
             0853** ;
0B46F5 C5    0854** OSSHUT:			PUSH	BC
0B46F6 4B    0855** LD	C, E
             0856** MOSCALL	mos_fclose
0B46F7 3E   0001**M LD	A, function
0B46F8 0B 
0B46F9 49   0002**M RST.LIS	08h
0B46FA CF 
0B46FB C1    0857** POP	BC
0B46FC C9    0858** RET
             0859** 
             0860** ; OSBGET - Read a byte from a random disk file.
             0861** ;  E = file channel
             0862** ; Returns
             0863** ;  A = byte read
             0864** ;  Carry set if LAST BYTE of file
             0865** ; Destroys: A,B,C,F
             0866** ;
0B46FD C5    0867** OSBGET:			PUSH	BC
0B46FE 4B    0868** LD	C, E
             0869** MOSCALL	mos_fgetc
0B46FF 3E   0001**M LD	A, function
0B4700 0C 
0B4701 49   0002**M RST.LIS	08h
0B4702 CF 
0B4703 C1    0870** POP	BC
0B4704 C9    0871** RET
             0872** 
             0873** ; OSBPUT - Write a byte to a random disk file.
             0874** ;  E = file channel
             0875** ;  A = byte to write
             0876** ; Destroys: A,B,C,F
             0877** ;
0B4705 C5    0878** OSBPUT:			PUSH	BC
0B4706 4B    0879** LD	C, E
0B4707 47    0880** LD	B, A
             0881** MOSCALL	mos_fputc
0B4708 3E   0001**M LD	A, function
0B4709 0D 
0B470A 49   0002**M RST.LIS	08h
0B470B CF 
0B470C C1    0882** POP	BC
0B470D C9    0883** RET
             0884** 
             0885** ; OSSTAT - Read file status
             0886** ;  E = file channel
             0887** ; Returns
             0888** ;  F: Z flag set - EOF
             0889** ;  A: If Z then A = 0
             0890** ; Destroys: A,D,E,H,L,F
             0891** ;
0B470E C5    0892** OSSTAT:			PUSH	BC
0B470F 4B    0893** LD	C, E
             0894** MOSCALL	mos_feof
0B4710 3E   0001**M LD	A, function
0B4711 0E 
0B4712 49   0002**M RST.LIS	08h
0B4713 CF 
0B4714 C1    0895** POP	BC
0B4715 FE    0896** CP	1
0B4716 01 
0B4717 C9    0897** RET
             0898** 
             0899** ; GETPTR - Return file pointer.
             0900** ;    E = file channel
             0901** ; Returns:
             0902** ; DEHL = pointer (0-&7FFFFF)
             0903** ; Destroys: A,B,C,D,E,H,L,F
             0904** ;
0B4718 FD    0905** GETPTR:			PUSH		IY
0B4719 E5 
0B471A 4B    0906** LD		C, E
             0907** MOSCALL		mos_getfil 	; HLU: Pointer to FIL structure
0B471B 3E   0001**M LD	A, function
0B471C 19 
0B471D 49   0002**M RST.LIS	08h
0B471E CF 
0B471F E5    0908** PUSH		HL
0B4720 FD    0909** POP		IY		; IYU: Pointer to FIL structure
0B4721 E1 
0B4722 FD    0910** LD		L, (IY + FIL.fptr + 0)
0B4723 6E 
0B4724 11 
0B4725 FD    0911** LD		H, (IY + FIL.fptr + 1)
0B4726 66 
0B4727 12 
0B4728 FD    0912** LD		E, (IY + FIL.fptr + 2)
0B4729 5E 
0B472A 13 
0B472B FD    0913** LD		D, (IY + FIL.fptr + 3)
0B472C 56 
0B472D 14 
0B472E FD    0914** POP		IY
0B472F E1 
0B4730 C9    0915** RET
             0916** 
             0917** ; PUTPTR - Update file pointer.
             0918** ;    A = file channel
             0919** ; DEHL = new pointer (0-&7FFFFF)
             0920** ; Destroys: A,B,C,D,E,H,L,F
             0921** ;
0B4731 FD    0922** PUTPTR:			PUSH		IY
0B4732 E5 
0B4733 4F    0923** LD		C, A  		; C: Filehandle
0B4734 E5    0924** PUSH		HL
0B4735 21    0925** LD		HL, 2
0B4736 02 
0B4737 00 
0B4738 00 
0B4739 39    0926** ADD		HL, SP
0B473A 73    0927** LD		(HL), E 	; 3rd byte of DWORD set to E
0B473B E1    0928** POP		HL
0B473C 5A    0929** LD		E, D  		; 4th byte passed as E
             0930** MOSCALL		mos_flseek
0B473D 3E   0001**M LD	A, function
0B473E 1C 
0B473F 49   0002**M RST.LIS	08h
0B4740 CF 
0B4741 FD    0931** POP		IY
0B4742 E1 
0B4743 C9    0932** RET
             0933** 
             0934** ; GETEXT - Find file size.
             0935** ;    E = file channel
             0936** ; Returns:
             0937** ; DEHL = file size (0-&800000)
             0938** ; Destroys: A,B,C,D,E,H,L,F
             0939** ;
0B4744 FD    0940** GETEXT:         PUSH    IY
0B4745 E5 
0B4746 4B    0941** LD      C, E
             0942** MOSCALL mos_getfil  ; HLU: Pointer to FIL structure
0B4747 3E   0001**M LD	A, function
0B4748 19 
0B4749 49   0002**M RST.LIS	08h
0B474A CF 
0B474B E5    0943** PUSH    HL
0B474C FD    0944** POP     IY          ; IYU: Pointer to FIL structure
0B474D E1 
             0945** ; Access the obj.objsize field using the offset values
0B474E FD    0946** LD      L, (IY + FIL.obj + FFOBJID.objsize + 0)
0B474F 6E 
0B4750 0B 
0B4751 FD    0947** LD      H, (IY + FIL.obj + FFOBJID.objsize + 1)
0B4752 66 
0B4753 0C 
0B4754 FD    0948** LD      E, (IY + FIL.obj + FFOBJID.objsize + 2)
0B4755 5E 
0B4756 0D 
0B4757 FD    0949** LD      D, (IY + FIL.obj + FFOBJID.objsize + 3)
0B4758 56 
0B4759 0E 
             0950** 
0B475A FD    0951** POP     IY
0B475B E1 
0B475C C9    0952** RET
             0953** 
             0954** ; GETIMS - Get time from RTC
             0955** ;
0B475D FD    0956** GETIMS:			PUSH	IY
0B475E E5 
0B475F 21    0957** LD	HL, ACCS 		; Where to store the time string
0B4760 00 
0B4761 4E 
0B4762 0B 
             0958** MOSCALL	mos_getrtc
0B4763 3E   0001**M LD	A, function
0B4764 12 
0B4765 49   0002**M RST.LIS	08h
0B4766 CF 
0B4767 11    0959** LD	DE, ACCS		; DE: pointer to start of string accumulator
0B4768 00 
0B4769 4E 
0B476A 0B 
0B476B 5F    0960** LD	E, A 			;  E: now points to the end of the string
0B476C FD    0961** POP	IY
0B476D E1 
0B476E C9    0962** RET
             0963** 
             0964** ; Get two word values from EXPR in DE, HL
             0965** ; IY: Pointer to expression string
             0966** ; Returns:
             0967** ; DE: P1
             0968** ; HL: P2
             0969** ;
0B476F CD    0970** EXPR_W2:		CALL	EXPRI			; Get first parameter
0B4770 D4 
0B4771 06 
0B4772 0B 
0B4773 D9    0971** EXX
0B4774 E5    0972** PUSH	HL
0B4775 CD    0973** CALL	COMMA
0B4776 EC 
0B4777 0D 
0B4778 0B 
0B4779 CD    0974** CALL	EXPRI			; Get second parameter
0B477A D4 
0B477B 06 
0B477C 0B 
0B477D D9    0975** EXX
0B477E D1    0976** POP	DE
0B477F C9    0977** RET
             0978** 
             0979** ; Stuff not implemented yet
             0980** ;
0B4780 C9    0981** RESET:			RET
              0012* include "basic/sorry.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		Catch-all for unimplemented functionality
             0004** ; Author:	Dean Belfield
             0005** ; Created:	12/05/2023
             0006** ; Last Updated:	12/05/2023
             0007** ;
             0008** ; Modinfo:
             0009** 
             0010** ; .ASSUME	ADL = 1
             0011** 
             0012** ; SEGMENT CODE
             0013** 
             0014** ; XDEF	ENVEL
             0015** ; XDEF	ADVAL
             0016** ; XDEF	PUTIMS
             0017** 
             0018** ; XREF	EXTERR
             0019** 
             0020** ENVEL:
             0021** ADVAL:
             0022** PUTIMS:
0B4781 AF    0023** XOR     A
0B4782 CD    0024** CALL    EXTERR
0B4783 41 
0B4784 3B 
0B4785 0B 
0B4786 53    0025** DEFB    "Sorry"
0B4787 6F 
0B4788 72 
0B4789 72 
0B4789 79   
0B478B 00    0026** DEFB    0
              0013* include "basic/agon_graphics.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Graphics stuff
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	07/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 07/06/2023:	Modified to run in ADL mode
             0009** 
             0010** ; .ASSUME	ADL = 1
             0011** 
             0012** ; INCLUDE	"equs.inc"
             0013** ; INCLUDE "macros.inc"
             0014** ; INCLUDE "mos_api.inc"	; In MOS/src
             0015** 
             0016** ; SEGMENT CODE
             0017** 
             0018** ; XDEF	CLG
             0019** ; XDEF	CLRSCN
             0020** ; XDEF	MODE
             0021** ; XDEF	COLOUR
             0022** ; XDEF	GCOL
             0023** ; XDEF	MOVE
             0024** ; XDEF	PLOT
             0025** ; XDEF	DRAW
             0026** ; XDEF	POINT
             0027** ; XDEF	GETSCHR
             0028** 
             0029** ; XREF	OSWRCH
             0030** ; XREF	ASC_TO_NUMBER
             0031** ; XREF	EXTERR
             0032** ; XREF	EXPRI
             0033** ; XREF	COMMA
             0034** ; XREF	XEQ
             0035** ; XREF	NXT
             0036** ; XREF	BRAKET
             0037** ; XREF	COUNT0
             0038** ; XREF	CRTONULL
             0039** ; XREF	NULLTOCR
             0040** ; XREF	CRLF
             0041** ; XREF	EXPR_W2
             0042** ; XREF	INKEY1
             0043** 
             0044** ; CLG: clears the graphics area
             0045** ;
             0046** CLG:
             0047** 
             0048** VDU	10h
0B478C 3E   0001**M LD	A, val
0B478D 10 
0B478E CD   0002**M CALL	OSWRCH
0B478F CA 
0B4790 42 
0B4791 0B 
0B4792 C3    0049** JP	XEQ
0B4793 60 
0B4794 0F 
0B4795 0B 
             0050** 
             0051** ; CLS: clears the text area
             0052** ;
0B4796 3E    0053** CLRSCN:			LD	A, 0Ch
0B4797 0C 
0B4798 C3    0054** JP	OSWRCH
0B4799 CA 
0B479A 42 
0B479B 0B 
             0055** 
             0056** ; MODE n: Set video mode
             0057** ;
0B479C DD    0058** MODE:			PUSH	IX			; Get the system vars in IX
0B479D E5 
             0059** MOSCALL	mos_sysvars		; Reset the semaphore
0B479E 3E   0001**M LD	A, function
0B479F 08 
0B47A0 49   0002**M RST.LIS	08h
0B47A1 CF 
0B47A2 DD    0060** RES	4, (IX+sysvar_vpd_pflags)
0B47A3 CB 
0B47A4 04 
0B47A5 A6 
0B47A6 CD    0061** CALL    EXPRI
0B47A7 D4 
0B47A8 06 
0B47A9 0B 
0B47AA D9    0062** EXX
             0063** VDU	16H			; Mode change
0B47AB 3E   0001**M LD	A, val
0B47AC 16 
0B47AD CD   0002**M CALL	OSWRCH
0B47AE CA 
0B47AF 42 
0B47B0 0B 
             0064** VDU	L
0B47B1 7D   0001**M LD	A, val
0B47B2 CD   0002**M CALL	OSWRCH
0B47B3 CA 
0B47B4 42 
0B47B5 0B 
             0065** MOSCALL	mos_sysvars
0B47B6 3E   0001**M LD	A, function
0B47B7 08 
0B47B8 49   0002**M RST.LIS	08h
0B47B9 CF 
0B47BA DD    0066** @@:			BIT	4, (IX+sysvar_vpd_pflags)
0B47BB CB 
0B47BC 04 
0B47BD 66 
0B47BE 28    0067** JR	Z, @B			; Wait for the result
0B47BF FA 
0B47C0 DD    0068** POP	IX
0B47C1 E1 
0B47C2 C3    0069** JP	XEQ
0B47C3 60 
0B47C4 0F 
0B47C5 0B 
             0070** 
             0071** ; GET(x,y): Get the ASCII code of a character on screen
             0072** ;
0B47C6 FD    0073** GETSCHR:		INC	IY
0B47C7 23 
0B47C8 CD    0074** CALL    EXPRI      		; Get X coordinate
0B47C9 D4 
0B47CA 06 
0B47CB 0B 
0B47CC D9    0075** EXX
0B47CD 22    0076** LD	(VDU_BUFFER+0), HL
0B47CE 00 
0B47CF 4E 
0B47D0 0B 
0B47D1 CD    0077** CALL	COMMA
0B47D2 EC 
0B47D3 0D 
0B47D4 0B 
0B47D5 CD    0078** CALL	EXPRI			; Get Y coordinate
0B47D6 D4 
0B47D7 06 
0B47D8 0B 
0B47D9 D9    0079** EXX
0B47DA 22    0080** LD	(VDU_BUFFER+2), HL
0B47DB 02 
0B47DC 4E 
0B47DD 0B 
0B47DE CD    0081** CALL	BRAKET			; Closing bracket
0B47DF F9 
0B47E0 0D 
0B47E1 0B 
             0082** ;
0B47E2 DD    0083** PUSH	IX			; Get the system vars in IX
0B47E3 E5 
             0084** MOSCALL	mos_sysvars		; Reset the semaphore
0B47E4 3E   0001**M LD	A, function
0B47E5 08 
0B47E6 49   0002**M RST.LIS	08h
0B47E7 CF 
0B47E8 DD    0085** RES	1, (IX+sysvar_vpd_pflags)
0B47E9 CB 
0B47EA 04 
0B47EB 8E 
             0086** VDU	23
0B47EC 3E   0001**M LD	A, val
0B47ED 17 
0B47EE CD   0002**M CALL	OSWRCH
0B47EF CA 
0B47F0 42 
0B47F1 0B 
             0087** VDU	0
0B47F2 3E   0001**M LD	A, val
0B47F3 00 
0B47F4 CD   0002**M CALL	OSWRCH
0B47F5 CA 
0B47F6 42 
0B47F7 0B 
             0088** VDU	vdp_scrchar
0B47F8 3E   0001**M LD	A, val
0B47F9 83 
0B47FA CD   0002**M CALL	OSWRCH
0B47FB CA 
0B47FC 42 
0B47FD 0B 
             0089** VDU	(VDU_BUFFER+0)
0B47FE 3A   0001**M LD	A, val
0B47FF 00 
0B4800 4E 
0B4801 0B 
0B4802 CD   0002**M CALL	OSWRCH
0B4803 CA 
0B4804 42 
0B4805 0B 
             0090** VDU	(VDU_BUFFER+1)
0B4806 3A   0001**M LD	A, val
0B4807 01 
0B4808 4E 
0B4809 0B 
0B480A CD   0002**M CALL	OSWRCH
0B480B CA 
0B480C 42 
0B480D 0B 
             0091** VDU	(VDU_BUFFER+2)
0B480E 3A   0001**M LD	A, val
0B480F 02 
0B4810 4E 
0B4811 0B 
0B4812 CD   0002**M CALL	OSWRCH
0B4813 CA 
0B4814 42 
0B4815 0B 
             0092** VDU	(VDU_BUFFER+3)
0B4816 3A   0001**M LD	A, val
0B4817 03 
0B4818 4E 
0B4819 0B 
0B481A CD   0002**M CALL	OSWRCH
0B481B CA 
0B481C 42 
0B481D 0B 
0B481E DD    0093** @@:			BIT	1, (IX+sysvar_vpd_pflags)
0B481F CB 
0B4820 04 
0B4821 4E 
0B4822 28    0094** JR	Z, @B			; Wait for the result
0B4823 FA 
0B4824 DD    0095** LD	A, (IX+sysvar_scrchar)	; Fetch the result in A
0B4825 7E 
0B4826 09 
0B4827 B7    0096** OR	A			; Check for 00h
0B4828 37    0097** SCF				; C = character map
0B4829 20    0098** JR	NZ, @F			; We have a character, so skip next bit
0B482A 02 
0B482B AF    0099** XOR	A			; Clear carry
0B482C 3D    0100** DEC	A			; Set A to FFh
0B482D DD    0101** @@:			POP	IX
0B482E E1 
0B482F C3    0102** JP	INKEY1			; Jump back to the GET command
0B4830 AB 
0B4831 0B 
0B4832 0B 
             0103** 
             0104** ; POINT(x,y): Get the pixel colour of a point on screen
             0105** ;
0B4833 CD    0106** POINT:			CALL    EXPRI      		; Get X coordinate
0B4834 D4 
0B4835 06 
0B4836 0B 
0B4837 D9    0107** EXX
0B4838 22    0108** LD	(VDU_BUFFER+0), HL
0B4839 00 
0B483A 4E 
0B483B 0B 
0B483C CD    0109** CALL	COMMA
0B483D EC 
0B483E 0D 
0B483F 0B 
0B4840 CD    0110** CALL	EXPRI			; Get Y coordinate
0B4841 D4 
0B4842 06 
0B4843 0B 
0B4844 D9    0111** EXX
0B4845 22    0112** LD	(VDU_BUFFER+2), HL
0B4846 02 
0B4847 4E 
0B4848 0B 
0B4849 CD    0113** CALL	BRAKET			; Closing bracket
0B484A F9 
0B484B 0D 
0B484C 0B 
             0114** ;
0B484D DD    0115** PUSH	IX			; Get the system vars in IX
0B484E E5 
             0116** MOSCALL	mos_sysvars		; Reset the semaphore
0B484F 3E   0001**M LD	A, function
0B4850 08 
0B4851 49   0002**M RST.LIS	08h
0B4852 CF 
0B4853 DD    0117** RES	2, (IX+sysvar_vpd_pflags)
0B4854 CB 
0B4855 04 
0B4856 96 
             0118** VDU	23
0B4857 3E   0001**M LD	A, val
0B4858 17 
0B4859 CD   0002**M CALL	OSWRCH
0B485A CA 
0B485B 42 
0B485C 0B 
             0119** VDU	0
0B485D 3E   0001**M LD	A, val
0B485E 00 
0B485F CD   0002**M CALL	OSWRCH
0B4860 CA 
0B4861 42 
0B4862 0B 
             0120** VDU	vdp_scrpixel
0B4863 3E   0001**M LD	A, val
0B4864 84 
0B4865 CD   0002**M CALL	OSWRCH
0B4866 CA 
0B4867 42 
0B4868 0B 
             0121** VDU	(VDU_BUFFER+0)
0B4869 3A   0001**M LD	A, val
0B486A 00 
0B486B 4E 
0B486C 0B 
0B486D CD   0002**M CALL	OSWRCH
0B486E CA 
0B486F 42 
0B4870 0B 
             0122** VDU	(VDU_BUFFER+1)
0B4871 3A   0001**M LD	A, val
0B4872 01 
0B4873 4E 
0B4874 0B 
0B4875 CD   0002**M CALL	OSWRCH
0B4876 CA 
0B4877 42 
0B4878 0B 
             0123** VDU	(VDU_BUFFER+2)
0B4879 3A   0001**M LD	A, val
0B487A 02 
0B487B 4E 
0B487C 0B 
0B487D CD   0002**M CALL	OSWRCH
0B487E CA 
0B487F 42 
0B4880 0B 
             0124** VDU	(VDU_BUFFER+3)
0B4881 3A   0001**M LD	A, val
0B4882 03 
0B4883 4E 
0B4884 0B 
0B4885 CD   0002**M CALL	OSWRCH
0B4886 CA 
0B4887 42 
0B4888 0B 
0B4889 DD    0125** @@:			BIT	2, (IX+sysvar_vpd_pflags)
0B488A CB 
0B488B 04 
0B488C 56 
0B488D 28    0126** JR	Z, @B			; Wait for the result
0B488E FA 
             0127** ;
             0128** ; Return the data as a 1 byte index
             0129** ;
0B488F DD    0130** LD	L, (IX+sysvar_scrpixelIndex)
0B4890 6E 
0B4891 16 
0B4892 DD    0131** POP	IX
0B4893 E1 
0B4894 C3    0132** JP	COUNT0
0B4895 49 
0B4896 09 
0B4897 0B 
             0133** 
             0134** 
             0135** ; COLOUR colour
             0136** ; COLOUR L,P
             0137** ; COLOUR L,R,G,B
             0138** ;
0B4898 CD    0139** COLOUR:			CALL	EXPRI			; The colour / mode
0B4899 D4 
0B489A 06 
0B489B 0B 
0B489C D9    0140** EXX
0B489D 7D    0141** LD	A, L
0B489E 32    0142** LD	(VDU_BUFFER+0), A	; Store first parameter
0B489F 00 
0B48A0 4E 
0B48A1 0B 
0B48A2 CD    0143** CALL	NXT			; Are there any more parameters?
0B48A3 3A 
0B48A4 0E 
0B48A5 0B 
0B48A6 FE    0144** CP	','
0B48A7 2C 
0B48A8 28    0145** JR	Z, COLOUR_1		; Yes, so we're doing a palette change next
0B48A9 12 
             0146** ;
             0147** VDU	11h			; Just set the colour
0B48AA 3E   0001**M LD	A, val
0B48AB 11 
0B48AC CD   0002**M CALL	OSWRCH
0B48AD CA 
0B48AE 42 
0B48AF 0B 
             0148** VDU	(VDU_BUFFER+0)
0B48B0 3A   0001**M LD	A, val
0B48B1 00 
0B48B2 4E 
0B48B3 0B 
0B48B4 CD   0002**M CALL	OSWRCH
0B48B5 CA 
0B48B6 42 
0B48B7 0B 
0B48B8 C3    0149** JP	XEQ
0B48B9 60 
0B48BA 0F 
0B48BB 0B 
             0150** ;
0B48BC CD    0151** COLOUR_1:		CALL	COMMA
0B48BD EC 
0B48BE 0D 
0B48BF 0B 
0B48C0 CD    0152** CALL	EXPRI			; Parse R (OR P)
0B48C1 D4 
0B48C2 06 
0B48C3 0B 
0B48C4 D9    0153** EXX
0B48C5 7D    0154** LD	A, L
0B48C6 32    0155** LD	(VDU_BUFFER+1), A
0B48C7 01 
0B48C8 4E 
0B48C9 0B 
0B48CA CD    0156** CALL	NXT			; Are there any more parameters?
0B48CB 3A 
0B48CC 0E 
0B48CD 0B 
0B48CE FE    0157** CP	','
0B48CF 2C 
0B48D0 28    0158** JR	Z, COLOUR_2		; Yes, so we're doing COLOUR L,R,G,B
0B48D1 2C 
             0159** ;
             0160** VDU	13h			; VDU:COLOUR
0B48D2 3E   0001**M LD	A, val
0B48D3 13 
0B48D4 CD   0002**M CALL	OSWRCH
0B48D5 CA 
0B48D6 42 
0B48D7 0B 
             0161** VDU	(VDU_BUFFER+0)		; Logical Colour
0B48D8 3A   0001**M LD	A, val
0B48D9 00 
0B48DA 4E 
0B48DB 0B 
0B48DC CD   0002**M CALL	OSWRCH
0B48DD CA 
0B48DE 42 
0B48DF 0B 
             0162** VDU	(VDU_BUFFER+1)		; Palette Colour
0B48E0 3A   0001**M LD	A, val
0B48E1 01 
0B48E2 4E 
0B48E3 0B 
0B48E4 CD   0002**M CALL	OSWRCH
0B48E5 CA 
0B48E6 42 
0B48E7 0B 
             0163** VDU	0			; RGB set to 0
0B48E8 3E   0001**M LD	A, val
0B48E9 00 
0B48EA CD   0002**M CALL	OSWRCH
0B48EB CA 
0B48EC 42 
0B48ED 0B 
             0164** VDU	0
0B48EE 3E   0001**M LD	A, val
0B48EF 00 
0B48F0 CD   0002**M CALL	OSWRCH
0B48F1 CA 
0B48F2 42 
0B48F3 0B 
             0165** VDU	0
0B48F4 3E   0001**M LD	A, val
0B48F5 00 
0B48F6 CD   0002**M CALL	OSWRCH
0B48F7 CA 
0B48F8 42 
0B48F9 0B 
0B48FA C3    0166** JP	XEQ
0B48FB 60 
0B48FC 0F 
0B48FD 0B 
             0167** ;
0B48FE CD    0168** COLOUR_2:		CALL	COMMA
0B48FF EC 
0B4900 0D 
0B4901 0B 
0B4902 CD    0169** CALL	EXPRI			; Parse G
0B4903 D4 
0B4904 06 
0B4905 0B 
0B4906 D9    0170** EXX
0B4907 7D    0171** LD	A, L
0B4908 32    0172** LD	(VDU_BUFFER+2), A
0B4909 02 
0B490A 4E 
0B490B 0B 
0B490C CD    0173** CALL	COMMA
0B490D EC 
0B490E 0D 
0B490F 0B 
0B4910 CD    0174** CALL	EXPRI			; Parse B
0B4911 D4 
0B4912 06 
0B4913 0B 
0B4914 D9    0175** EXX
0B4915 7D    0176** LD	A, L
0B4916 32    0177** LD	(VDU_BUFFER+3), A
0B4917 03 
0B4918 4E 
0B4919 0B 
             0178** VDU	13h			; VDU:COLOUR
0B491A 3E   0001**M LD	A, val
0B491B 13 
0B491C CD   0002**M CALL	OSWRCH
0B491D CA 
0B491E 42 
0B491F 0B 
             0179** VDU	(VDU_BUFFER+0)		; Logical Colour
0B4920 3A   0001**M LD	A, val
0B4921 00 
0B4922 4E 
0B4923 0B 
0B4924 CD   0002**M CALL	OSWRCH
0B4925 CA 
0B4926 42 
0B4927 0B 
             0180** VDU	FFh			; Physical Colour (-1 for RGB mode)
0B4928 3E   0001**M LD	A, val
0B4929 FF 
0B492A CD   0002**M CALL	OSWRCH
0B492B CA 
0B492C 42 
0B492D 0B 
             0181** VDU	(VDU_BUFFER+1)		; R
0B492E 3A   0001**M LD	A, val
0B492F 01 
0B4930 4E 
0B4931 0B 
0B4932 CD   0002**M CALL	OSWRCH
0B4933 CA 
0B4934 42 
0B4935 0B 
             0182** VDU	(VDU_BUFFER+2)		; G
0B4936 3A   0001**M LD	A, val
0B4937 02 
0B4938 4E 
0B4939 0B 
0B493A CD   0002**M CALL	OSWRCH
0B493B CA 
0B493C 42 
0B493D 0B 
             0183** VDU	(VDU_BUFFER+3)		; B
0B493E 3A   0001**M LD	A, val
0B493F 03 
0B4940 4E 
0B4941 0B 
0B4942 CD   0002**M CALL	OSWRCH
0B4943 CA 
0B4944 42 
0B4945 0B 
0B4946 C3    0184** JP	XEQ
0B4947 60 
0B4948 0F 
0B4949 0B 
             0185** 
             0186** ; GCOL mode,colour
             0187** ;
0B494A CD    0188** GCOL:			CALL	EXPRI			; Parse MODE
0B494B D4 
0B494C 06 
0B494D 0B 
0B494E D9    0189** EXX
0B494F 7D    0190** LD	A, L
0B4950 32    0191** LD	(VDU_BUFFER+0), A
0B4951 00 
0B4952 4E 
0B4953 0B 
0B4954 CD    0192** CALL	COMMA
0B4955 EC 
0B4956 0D 
0B4957 0B 
             0193** ;
0B4958 CD    0194** CALL	EXPRI			; Parse Colour
0B4959 D4 
0B495A 06 
0B495B 0B 
0B495C D9    0195** EXX
0B495D 7D    0196** LD	A, L
0B495E 32    0197** LD	(VDU_BUFFER+1), A
0B495F 01 
0B4960 4E 
0B4961 0B 
             0198** ;
             0199** VDU	12h			; VDU:GCOL
0B4962 3E   0001**M LD	A, val
0B4963 12 
0B4964 CD   0002**M CALL	OSWRCH
0B4965 CA 
0B4966 42 
0B4967 0B 
             0200** VDU	(VDU_BUFFER+0)		; Mode
0B4968 3A   0001**M LD	A, val
0B4969 00 
0B496A 4E 
0B496B 0B 
0B496C CD   0002**M CALL	OSWRCH
0B496D CA 
0B496E 42 
0B496F 0B 
             0201** VDU	(VDU_BUFFER+1)		; Colour
0B4970 3A   0001**M LD	A, val
0B4971 01 
0B4972 4E 
0B4973 0B 
0B4974 CD   0002**M CALL	OSWRCH
0B4975 CA 
0B4976 42 
0B4977 0B 
0B4978 C3    0202** JP	XEQ
0B4979 60 
0B497A 0F 
0B497B 0B 
             0203** 
             0204** ; PLOT mode,x,y
             0205** ;
0B497C CD    0206** PLOT:			CALL	EXPRI		; Parse mode
0B497D D4 
0B497E 06 
0B497F 0B 
0B4980 D9    0207** EXX
0B4981 E5    0208** PUSH	HL		; Push mode (L) onto stack
0B4982 CD    0209** CALL	COMMA
0B4983 EC 
0B4984 0D 
0B4985 0B 
0B4986 CD    0210** CALL	EXPR_W2		; Parse X and Y
0B4987 6F 
0B4988 47 
0B4989 0B 
0B498A C1    0211** POP	BC		; Pop mode (C) off stack
             0212** PLOT_1:			VDU	19H		; VDU code for PLOT
0B498B 3E   0001**M LD	A, val
0B498C 19 
0B498D CD   0002**M CALL	OSWRCH
0B498E CA 
0B498F 42 
0B4990 0B 
             0213** VDU	C		;  C: Mode
0B4991 79   0001**M LD	A, val
0B4992 CD   0002**M CALL	OSWRCH
0B4993 CA 
0B4994 42 
0B4995 0B 
             0214** VDU	E		; DE: X
0B4996 7B   0001**M LD	A, val
0B4997 CD   0002**M CALL	OSWRCH
0B4998 CA 
0B4999 42 
0B499A 0B 
             0215** VDU	D
0B499B 7A   0001**M LD	A, val
0B499C CD   0002**M CALL	OSWRCH
0B499D CA 
0B499E 42 
0B499F 0B 
             0216** VDU	L		; HL: Y
0B49A0 7D   0001**M LD	A, val
0B49A1 CD   0002**M CALL	OSWRCH
0B49A2 CA 
0B49A3 42 
0B49A4 0B 
             0217** VDU	H
0B49A5 7C   0001**M LD	A, val
0B49A6 CD   0002**M CALL	OSWRCH
0B49A7 CA 
0B49A8 42 
0B49A9 0B 
0B49AA C3    0218** JP	XEQ
0B49AB 60 
0B49AC 0F 
0B49AD 0B 
             0219** 
             0220** ; MOVE x,y
             0221** ;
0B49AE CD    0222** MOVE:			CALL	EXPR_W2		; Parse X and Y
0B49AF 6F 
0B49B0 47 
0B49B1 0B 
0B49B2 0E    0223** LD	C, 04H		; Plot mode 04H (Move)
0B49B3 04 
0B49B4 18    0224** JR	PLOT_1		; Plot
0B49B5 D5 
             0225** 
             0226** ; DRAW x1,y1
             0227** ; DRAW x1,y1,x2,y2
             0228** ;
0B49B6 CD    0229** DRAW:			CALL	EXPR_W2		; Get X1 and Y1
0B49B7 6F 
0B49B8 47 
0B49B9 0B 
0B49BA CD    0230** CALL	NXT		; Are there any more parameters?
0B49BB 3A 
0B49BC 0E 
0B49BD 0B 
0B49BE FE    0231** CP	','
0B49BF 2C 
0B49C0 0E    0232** LD	C, 05h		; Code for LINE
0B49C1 05 
0B49C2 20    0233** JR	NZ, PLOT_1	; No, so just do DRAW x1,y1
0B49C3 C7 
             0234** VDU	19h		; Move to the first coordinates
0B49C4 3E   0001**M LD	A, val
0B49C5 19 
0B49C6 CD   0002**M CALL	OSWRCH
0B49C7 CA 
0B49C8 42 
0B49C9 0B 
             0235** VDU	04h
0B49CA 3E   0001**M LD	A, val
0B49CB 04 
0B49CC CD   0002**M CALL	OSWRCH
0B49CD CA 
0B49CE 42 
0B49CF 0B 
             0236** VDU	E
0B49D0 7B   0001**M LD	A, val
0B49D1 CD   0002**M CALL	OSWRCH
0B49D2 CA 
0B49D3 42 
0B49D4 0B 
             0237** VDU	D
0B49D5 7A   0001**M LD	A, val
0B49D6 CD   0002**M CALL	OSWRCH
0B49D7 CA 
0B49D8 42 
0B49D9 0B 
             0238** VDU	L
0B49DA 7D   0001**M LD	A, val
0B49DB CD   0002**M CALL	OSWRCH
0B49DC CA 
0B49DD 42 
0B49DE 0B 
             0239** VDU	H
0B49DF 7C   0001**M LD	A, val
0B49E0 CD   0002**M CALL	OSWRCH
0B49E1 CA 
0B49E2 42 
0B49E3 0B 
0B49E4 CD    0240** CALL	COMMA
0B49E5 EC 
0B49E6 0D 
0B49E7 0B 
0B49E8 C5    0241** PUSH	BC
0B49E9 CD    0242** CALL	EXPR_W2		; Get X2 and Y2
0B49EA 6F 
0B49EB 47 
0B49EC 0B 
0B49ED C1    0243** POP	BC
0B49EE 18    0244** JR	PLOT_1		; Now DRAW the line to those positions
0B49EF 9B 
             0245** 
             0246** 
             0247** 
              0014* include "basic/agon_sound.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Audio stuff
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	12/05/2023
             0006** ;
             0007** ; Modinfo:
             0008** 
             0009** ; .ASSUME	ADL = 1
             0010** 
             0011** ; INCLUDE	"equs.inc"
             0012** ; INCLUDE "macros.inc"
             0013** ; INCLUDE "mos_api.inc"	; In MOS/src
             0014** 
             0015** ; SEGMENT CODE
             0016** 
             0017** ; XDEF	SOUND
             0018** 
             0019** ; XREF	COMMA
             0020** ; XREF	EXPR_W2
             0021** ; XREF	XEQ
             0022** ; XREF	LTRAP
             0023** ; XREF	OSWRCH
             0024** ; XREF	VDU_BUFFER
             0025** 
             0026** 
             0027** ; SOUND channel,volume,pitch,duration
             0028** ; volume: 0 (off) to -15 (full volume)
             0029** ; pitch: 0 - 255
             0030** ; duration: -1 to 254 (duration in 20ths of a second, -1 = play forever)
             0031** ;
0B49F0 CD    0032** SOUND:			CALL	EXPR_W2			; DE: Channel/Control, HL: Volume
0B49F1 6F 
0B49F2 47 
0B49F3 0B 
0B49F4 7D    0033** LD	A, L 			;  A: Volume
0B49F5 F5    0034** PUSH	AF
0B49F6 D5    0035** PUSH	DE
0B49F7 CD    0036** CALL	COMMA
0B49F8 EC 
0B49F9 0D 
0B49FA 0B 
0B49FB CD    0037** CALL	EXPR_W2			; DE: Pitch, HL: Duration
0B49FC 6F 
0B49FD 47 
0B49FE 0B 
0B49FF 53    0038** LD	D, E			;  D: Pitch
0B4A00 5D    0039** LD	E, L 			;  E: Duration
0B4A01 E1    0040** POP	HL 			; HL: Channel/Control
0B4A02 F1    0041** POP	AF
0B4A03 ED    0042** NEG
0B4A04 44 
0B4A05 FE    0043** CP	16			; Check volume is in bounds
0B4A06 10 
0B4A07 D2    0044** JP	NC, XEQ			; Out of bounds, do nothing
0B4A08 60 
0B4A09 0F 
0B4A0A 0B 
             0045** ;
             0046** ; Store	in VDU vars
             0047** ;
0B4A0B 4F    0048** LD	C, A			; Store Volume in C
0B4A0C 7D    0049** LD	A, L
0B4A0D 32    0050** LD	(VDU_BUFFER+0), A	; Channel
0B4A0E 00 
0B4A0F 4E 
0B4A10 0B 
0B4A11 AF    0051** XOR	A
0B4A12 32    0052** LD	(VDU_BUFFER+1), A	; Waveform
0B4A13 01 
0B4A14 4E 
0B4A15 0B 
             0053** ;
             0054** ; Calculate the volume
             0055** ;
0B4A16 06    0056** LD	B, 6			; C already contains the volume
0B4A17 06 
0B4A18 ED    0057** MLT	BC			; Multiply by 6 (0-15 scales to 0-90)
0B4A19 4C 
0B4A1A 79    0058** LD	A, C
0B4A1B 32    0059** LD	(VDU_BUFFER+2), A
0B4A1C 02 
0B4A1D 4E 
0B4A1E 0B 
             0060** ;
             0061** ; And the frequency
             0062** ;
0B4A1F 4B    0063** LD	C, E			; Store duration in C
0B4A20 26    0064** LD	H, 0			; Lookup the frequency
0B4A21 00 
0B4A22 6A    0065** LD	L, D
0B4A23 11    0066** LD	DE, SOUND_FREQ_LOOKUP
0B4A24 AA 
0B4A25 4A 
0B4A26 0B 
0B4A27 29    0067** ADD	HL, HL
0B4A28 19    0068** ADD	HL, DE
0B4A29 7E    0069** LD	A, (HL)
0B4A2A 32    0070** LD	(VDU_BUFFER+3), A
0B4A2B 03 
0B4A2C 4E 
0B4A2D 0B 
0B4A2E 23    0071** INC	HL
0B4A2F 7E    0072** LD	A, (HL)
0B4A30 32    0073** LD	(VDU_BUFFER+4), A
0B4A31 04 
0B4A32 4E 
0B4A33 0B 
             0074** ;
             0075** ; And now the duration - multiply it by 50 to convert from 1/20ths of seconds to milliseconds
             0076** ;
0B4A34 06    0077** LD	B, 50			; C contains the duration, so MLT by 50
0B4A35 32 
0B4A36 ED    0078** MLT	BC
0B4A37 4C 
0B4A38 ED    0079** LD	(VDU_BUFFER+5), BC
0B4A39 43 
0B4A3A 05 
0B4A3B 4E 
0B4A3B 0B   
             0080** ;
0B4A3D DD    0081** PUSH	IX			; Get the system vars in IX
0B4A3E E5 
             0082** MOSCALL	mos_sysvars		; Reset the semaphore
0B4A3F 3E   0001**M LD	A, function
0B4A40 08 
0B4A41 49   0002**M RST.LIS	08h
0B4A42 CF 
0B4A43 5B    0083** SOUND0:			RES.LIL	3, (IX+sysvar_vpd_pflags)
0B4A44 DD 
0B4A45 CB 
0B4A46 04 
0B4A46 9E   
             0084** ;
             0085** VDU	23			; Send the sound command
0B4A48 3E   0001**M LD	A, val
0B4A49 17 
0B4A4A CD   0002**M CALL	OSWRCH
0B4A4B CA 
0B4A4C 42 
0B4A4D 0B 
             0086** VDU	0
0B4A4E 3E   0001**M LD	A, val
0B4A4F 00 
0B4A50 CD   0002**M CALL	OSWRCH
0B4A51 CA 
0B4A52 42 
0B4A53 0B 
             0087** VDU	vdp_audio
0B4A54 3E   0001**M LD	A, val
0B4A55 85 
0B4A56 CD   0002**M CALL	OSWRCH
0B4A57 CA 
0B4A58 42 
0B4A59 0B 
             0088** VDU	(VDU_BUFFER+0)		; 0: Channel
0B4A5A 3A   0001**M LD	A, val
0B4A5B 00 
0B4A5C 4E 
0B4A5D 0B 
0B4A5E CD   0002**M CALL	OSWRCH
0B4A5F CA 
0B4A60 42 
0B4A61 0B 
             0089** VDU	(VDU_BUFFER+1)		; 1: Waveform (0)
0B4A62 3A   0001**M LD	A, val
0B4A63 01 
0B4A64 4E 
0B4A65 0B 
0B4A66 CD   0002**M CALL	OSWRCH
0B4A67 CA 
0B4A68 42 
0B4A69 0B 
             0090** VDU	(VDU_BUFFER+2)		; 2: Volume (0-100)
0B4A6A 3A   0001**M LD	A, val
0B4A6B 02 
0B4A6C 4E 
0B4A6D 0B 
0B4A6E CD   0002**M CALL	OSWRCH
0B4A6F CA 
0B4A70 42 
0B4A71 0B 
             0091** VDU	(VDU_BUFFER+3)		; 3: Frequency L
0B4A72 3A   0001**M LD	A, val
0B4A73 03 
0B4A74 4E 
0B4A75 0B 
0B4A76 CD   0002**M CALL	OSWRCH
0B4A77 CA 
0B4A78 42 
0B4A79 0B 
             0092** VDU	(VDU_BUFFER+4)		; 4: Frequency H
0B4A7A 3A   0001**M LD	A, val
0B4A7B 04 
0B4A7C 4E 
0B4A7D 0B 
0B4A7E CD   0002**M CALL	OSWRCH
0B4A7F CA 
0B4A80 42 
0B4A81 0B 
             0093** VDU	(VDU_BUFFER+5)		; 5: Duration L
0B4A82 3A   0001**M LD	A, val
0B4A83 05 
0B4A84 4E 
0B4A85 0B 
0B4A86 CD   0002**M CALL	OSWRCH
0B4A87 CA 
0B4A88 42 
0B4A89 0B 
             0094** VDU	(VDU_BUFFER+6)		; 6: Duration H
0B4A8A 3A   0001**M LD	A, val
0B4A8B 06 
0B4A8C 4E 
0B4A8D 0B 
0B4A8E CD   0002**M CALL	OSWRCH
0B4A8F CA 
0B4A90 42 
0B4A91 0B 
             0095** ;
             0096** ; Wait for acknowledgement
             0097** ;
0B4A92 5B    0098** @@:			BIT.LIL	3, (IX+sysvar_vpd_pflags)
0B4A93 DD 
0B4A94 CB 
0B4A95 04 
0B4A95 5E   
0B4A97 28    0099** JR	Z, @B			; Wait for the result
0B4A98 F9 
0B4A99 CD    0100** CALL	LTRAP			; Check for ESC
0B4A9A 3B 
0B4A9B 43 
0B4A9C 0B 
0B4A9D 5B    0101** LD.LIL	A, (IX+sysvar_audioSuccess)
0B4A9E DD 
0B4A9F 7E 
0B4AA0 0E 
0B4AA1 A7    0102** AND	A			; Check if VDP has queued the note
0B4AA2 28    0103** JR	Z, SOUND0		; No, so loop back and send again
0B4AA3 9F 
             0104** ;
0B4AA4 DD    0105** POP	IX
0B4AA5 E1 
0B4AA6 C3    0106** JP	XEQ
0B4AA7 60 
0B4AA8 0F 
0B4AA9 0B 
             0107** 
             0108** ; Frequency Lookup Table
             0109** ; Set up to replicate the BBC Micro audio frequencies
             0110** ;
             0111** ; Split over 5 complete octaves, with 53 being middle C
             0112** ; * C4: 262hz
             0113** ; + A4: 440hz
             0114** ;
             0115** ;	2	3	4	5	6	7	8
             0116** ;
             0117** ; B	1	49	97	145	193	241
             0118** ; A#	0	45	93	141	189	237
             0119** ; A		41	89+	137	185	233
             0120** ; G#		37	85	133	181	229
             0121** ; G		33	81	129	177	225
             0122** ; F#		29	77	125	173	221
             0123** ; F		25	73	121	169	217
             0124** ; E		21	69	117	165	213
             0125** ; D#		17	65	113	161	209
             0126** ; D		13	61	109	157	205	253
             0127** ; C#		9	57	105	153	201	249
             0128** ; C		5	53*	101	149	197	245
             0129** ;
0B4AAA 75    0130** SOUND_FREQ_LOOKUP:	DW	 117,  118,  120,  122,  123,  131,  133,  135
0B4AAB 00 
0B4AAC 76 
0B4AAD 00 
0B4AAD 78   
0B4AAE 00 
0B4AAF 7A 
0B4AB0 00 
0B4AB0 7B   
0B4AB1 00 
0B4AB2 83 
0B4AB3 00 
0B4AB3 85   
0B4AB4 00 
0B4AB5 87 
0B4AB6 00 
0B4ABA 89    0131** DW	 137,  139,  141,  143,  145,  147,  149,  151
0B4ABB 00 
0B4ABC 8B 
0B4ABD 00 
0B4ABD 8D   
0B4ABE 00 
0B4ABF 8F 
0B4AC0 00 
0B4AC0 91   
0B4AC1 00 
0B4AC2 93 
0B4AC3 00 
0B4AC3 95   
0B4AC4 00 
0B4AC5 97 
0B4AC6 00 
0B4ACA 99    0132** DW	 153,  156,  158,  160,  162,  165,  167,  170
0B4ACB 00 
0B4ACC 9C 
0B4ACD 00 
0B4ACD 9E   
0B4ACE 00 
0B4ACF A0 
0B4AD0 00 
0B4AD0 A2   
0B4AD1 00 
0B4AD2 A5 
0B4AD3 00 
0B4AD3 A7   
0B4AD4 00 
0B4AD5 AA 
0B4AD6 00 
0B4ADA AC    0133** DW	 172,  175,  177,  180,  182,  185,  188,  190
0B4ADB 00 
0B4ADC AF 
0B4ADD 00 
0B4ADD B1   
0B4ADE 00 
0B4ADF B4 
0B4AE0 00 
0B4AE0 B6   
0B4AE1 00 
0B4AE2 B9 
0B4AE3 00 
0B4AE3 BC   
0B4AE4 00 
0B4AE5 BE 
0B4AE6 00 
0B4AEA C1    0134** DW	 193,  196,  199,  202,  205,  208,  211,  214
0B4AEB 00 
0B4AEC C4 
0B4AED 00 
0B4AED C7   
0B4AEE 00 
0B4AEF CA 
0B4AF0 00 
0B4AF0 CD   
0B4AF1 00 
0B4AF2 D0 
0B4AF3 00 
0B4AF3 D3   
0B4AF4 00 
0B4AF5 D6 
0B4AF6 00 
0B4AFA D9    0135** DW	 217,  220,  223,  226,  230,  233,  236,  240
0B4AFB 00 
0B4AFC DC 
0B4AFD 00 
0B4AFD DF   
0B4AFE 00 
0B4AFF E2 
0B4B00 00 
0B4B00 E6   
0B4B01 00 
0B4B02 E9 
0B4B03 00 
0B4B03 EC   
0B4B04 00 
0B4B05 F0 
0B4B06 00 
0B4B0A F3    0136** DW	 243,  247,  251,  254,  258,  262,  265,  269
0B4B0B 00 
0B4B0C F7 
0B4B0D 00 
0B4B0D FB   
0B4B0E 00 
0B4B0F FE 
0B4B10 00 
0B4B10 02   
0B4B11 01 
0B4B12 06 
0B4B13 01 
0B4B13 09   
0B4B14 01 
0B4B15 0D 
0B4B16 01 
0B4B1A 11    0137** DW	 273,  277,  281,  285,  289,  294,  298,  302
0B4B1B 01 
0B4B1C 15 
0B4B1D 01 
0B4B1D 19   
0B4B1E 01 
0B4B1F 1D 
0B4B20 01 
0B4B20 21   
0B4B21 01 
0B4B22 26 
0B4B23 01 
0B4B23 2A   
0B4B24 01 
0B4B25 2E 
0B4B26 01 
0B4B2A 33    0138** DW	 307,  311,  316,  320,  325,  330,  334,  339
0B4B2B 01 
0B4B2C 37 
0B4B2D 01 
0B4B2D 3C   
0B4B2E 01 
0B4B2F 40 
0B4B30 01 
0B4B30 45   
0B4B31 01 
0B4B32 4A 
0B4B33 01 
0B4B33 4E   
0B4B34 01 
0B4B35 53 
0B4B36 01 
0B4B3A 58    0139** DW	 344,  349,  354,  359,  365,  370,  375,  381
0B4B3B 01 
0B4B3C 5D 
0B4B3D 01 
0B4B3D 62   
0B4B3E 01 
0B4B3F 67 
0B4B40 01 
0B4B40 6D   
0B4B41 01 
0B4B42 72 
0B4B43 01 
0B4B43 77   
0B4B44 01 
0B4B45 7D 
0B4B46 01 
0B4B4A 82    0140** DW	 386,  392,  398,  403,  409,  415,  421,  427
0B4B4B 01 
0B4B4C 88 
0B4B4D 01 
0B4B4D 8E   
0B4B4E 01 
0B4B4F 93 
0B4B50 01 
0B4B50 99   
0B4B51 01 
0B4B52 9F 
0B4B53 01 
0B4B53 A5   
0B4B54 01 
0B4B55 AB 
0B4B56 01 
0B4B5A B2    0141** DW	 434,  440,  446,  453,  459,  466,  473,  480
0B4B5B 01 
0B4B5C B8 
0B4B5D 01 
0B4B5D BE   
0B4B5E 01 
0B4B5F C5 
0B4B60 01 
0B4B60 CB   
0B4B61 01 
0B4B62 D2 
0B4B63 01 
0B4B63 D9   
0B4B64 01 
0B4B65 E0 
0B4B66 01 
0B4B6A E7    0142** DW	 487,  494,  501,  508,  516,  523,  531,  539
0B4B6B 01 
0B4B6C EE 
0B4B6D 01 
0B4B6D F5   
0B4B6E 01 
0B4B6F FC 
0B4B70 01 
0B4B70 04   
0B4B71 02 
0B4B72 0B 
0B4B73 02 
0B4B73 13   
0B4B74 02 
0B4B75 1B 
0B4B76 02 
0B4B7A 22    0143** DW	 546,  554,  562,  571,  579,  587,  596,  605
0B4B7B 02 
0B4B7C 2A 
0B4B7D 02 
0B4B7D 32   
0B4B7E 02 
0B4B7F 3B 
0B4B80 02 
0B4B80 43   
0B4B81 02 
0B4B82 4B 
0B4B83 02 
0B4B83 54   
0B4B84 02 
0B4B85 5D 
0B4B86 02 
0B4B8A 65    0144** DW	 613,  622,  631,  641,  650,  659,  669,  679
0B4B8B 02 
0B4B8C 6E 
0B4B8D 02 
0B4B8D 77   
0B4B8E 02 
0B4B8F 81 
0B4B90 02 
0B4B90 8A   
0B4B91 02 
0B4B92 93 
0B4B93 02 
0B4B93 9D   
0B4B94 02 
0B4B95 A7 
0B4B96 02 
0B4B9A B1    0145** DW	 689,  699,  709,  719,  729,  740,  751,  762
0B4B9B 02 
0B4B9C BB 
0B4B9D 02 
0B4B9D C5   
0B4B9E 02 
0B4B9F CF 
0B4BA0 02 
0B4BA0 D9   
0B4BA1 02 
0B4BA2 E4 
0B4BA3 02 
0B4BA3 EF   
0B4BA4 02 
0B4BA5 FA 
0B4BA6 02 
0B4BAA 05    0146** DW	 773,  784,  795,  807,  819,  831,  843,  855
0B4BAB 03 
0B4BAC 10 
0B4BAD 03 
0B4BAD 1B   
0B4BAE 03 
0B4BAF 27 
0B4BB0 03 
0B4BB0 33   
0B4BB1 03 
0B4BB2 3F 
0B4BB3 03 
0B4BB3 4B   
0B4BB4 03 
0B4BB5 57 
0B4BB6 03 
0B4BBA 63    0147** DW	 867,  880,  893,  906,  919,  932,  946,  960
0B4BBB 03 
0B4BBC 70 
0B4BBD 03 
0B4BBD 7D   
0B4BBE 03 
0B4BBF 8A 
0B4BC0 03 
0B4BC0 97   
0B4BC1 03 
0B4BC2 A4 
0B4BC3 03 
0B4BC3 B2   
0B4BC4 03 
0B4BC5 C0 
0B4BC6 03 
0B4BCA CE    0148** DW	 974,  988, 1002, 1017, 1032, 1047, 1062, 1078
0B4BCB 03 
0B4BCC DC 
0B4BCD 03 
0B4BCD EA   
0B4BCE 03 
0B4BCF F9 
0B4BD0 03 
0B4BD0 08   
0B4BD1 04 
0B4BD2 17 
0B4BD3 04 
0B4BD3 26   
0B4BD4 04 
0B4BD5 36 
0B4BD6 04 
0B4BDA 45    0149** DW	1093, 1109, 1125, 1142, 1158, 1175, 1192, 1210
0B4BDB 04 
0B4BDC 55 
0B4BDD 04 
0B4BDD 65   
0B4BDE 04 
0B4BDF 76 
0B4BE0 04 
0B4BE0 86   
0B4BE1 04 
0B4BE2 97 
0B4BE3 04 
0B4BE3 A8   
0B4BE4 04 
0B4BE5 BA 
0B4BE6 04 
0B4BEA CB    0150** DW	1227, 1245, 1263, 1282, 1300, 1319, 1338, 1358
0B4BEB 04 
0B4BEC DD 
0B4BED 04 
0B4BED EF   
0B4BEE 04 
0B4BEF 02 
0B4BF0 05 
0B4BF0 14   
0B4BF1 05 
0B4BF2 27 
0B4BF3 05 
0B4BF3 3A   
0B4BF4 05 
0B4BF5 4E 
0B4BF6 05 
0B4BFA 62    0151** DW	1378, 1398, 1418, 1439, 1459, 1481, 1502, 1524
0B4BFB 05 
0B4BFC 76 
0B4BFD 05 
0B4BFD 8A   
0B4BFE 05 
0B4BFF 9F 
0B4C00 05 
0B4C00 B3   
0B4C01 05 
0B4C02 C9 
0B4C03 05 
0B4C03 DE   
0B4C04 05 
0B4C05 F4 
0B4C06 05 
0B4C0A 0A    0152** DW	1546, 1569, 1592, 1615, 1638, 1662, 1686, 1711
0B4C0B 06 
0B4C0C 21 
0B4C0D 06 
0B4C0D 38   
0B4C0E 06 
0B4C0F 4F 
0B4C10 06 
0B4C10 66   
0B4C11 06 
0B4C12 7E 
0B4C13 06 
0B4C13 96   
0B4C14 06 
0B4C15 AF 
0B4C16 06 
0B4C1A C8    0153** DW	1736, 1761, 1786, 1812, 1839, 1866, 1893, 1920
0B4C1B 06 
0B4C1C E1 
0B4C1D 06 
0B4C1D FA   
0B4C1E 06 
0B4C1F 14 
0B4C20 07 
0B4C20 2F   
0B4C21 07 
0B4C22 4A 
0B4C23 07 
0B4C23 65   
0B4C24 07 
0B4C25 80 
0B4C26 07 
0B4C2A 9C    0154** DW	1948, 1976, 2005, 2034, 2064, 2093, 2123, 2154
0B4C2B 07 
0B4C2C B8 
0B4C2D 07 
0B4C2D D5   
0B4C2E 07 
0B4C2F F2 
0B4C30 07 
0B4C30 10   
0B4C31 08 
0B4C32 2D 
0B4C33 08 
0B4C33 4B   
0B4C34 08 
0B4C35 6A 
0B4C36 08 
0B4C3A 8A    0155** DW	2186, 2217, 2250, 2282, 2316, 2349, 2383, 2418
0B4C3B 08 
0B4C3C A9 
0B4C3D 08 
0B4C3D CA   
0B4C3E 08 
0B4C3F EA 
0B4C40 08 
0B4C40 0C   
0B4C41 09 
0B4C42 2D 
0B4C43 09 
0B4C43 4F   
0B4C44 09 
0B4C45 72 
0B4C46 09 
0B4C4A 95    0156** DW	2453, 2489, 2525, 2562, 2599, 2637, 2675, 2714
0B4C4B 09 
0B4C4C B9 
0B4C4D 09 
0B4C4D DD   
0B4C4E 09 
0B4C4F 02 
0B4C50 0A 
0B4C50 27   
0B4C51 0A 
0B4C52 4D 
0B4C53 0A 
0B4C53 73   
0B4C54 0A 
0B4C55 9A 
0B4C56 0A 
0B4C5A C2    0157** DW	2754, 2794, 2834, 2876, 2918, 2960, 3003, 3047
0B4C5B 0A 
0B4C5C EA 
0B4C5D 0A 
0B4C5D 12   
0B4C5E 0B 
0B4C5F 3C 
0B4C60 0B 
0B4C60 66   
0B4C61 0B 
0B4C62 90 
0B4C63 0B 
0B4C63 BB   
0B4C64 0B 
0B4C65 E7 
0B4C66 0B 
0B4C6A 13    0158** DW	3091, 3136, 3182, 3228, 3275, 3322, 3371, 3420
0B4C6B 0C 
0B4C6C 40 
0B4C6D 0C 
0B4C6D 6E   
0B4C6E 0C 
0B4C6F 9C 
0B4C70 0C 
0B4C70 CB   
0B4C71 0C 
0B4C72 FA 
0B4C73 0C 
0B4C73 2B   
0B4C74 0D 
0B4C75 5C 
0B4C76 0D 
0B4C7A 8E    0159** DW	3470, 3520, 3571, 3623, 3676, 3729, 3784, 3839
0B4C7B 0D 
0B4C7C C0 
0B4C7D 0D 
0B4C7D F3   
0B4C7E 0D 
0B4C7F 27 
0B4C80 0E 
0B4C80 5C   
0B4C81 0E 
0B4C82 91 
0B4C83 0E 
0B4C83 C8   
0B4C84 0E 
0B4C85 FF 
0B4C86 0E 
0B4C8A 36    0160** DW	3894, 3951, 4009, 4067, 4126, 4186, 4247, 4309
0B4C8B 0F 
0B4C8C 6F 
0B4C8D 0F 
0B4C8D A9   
0B4C8E 0F 
0B4C8F E3 
0B4C90 0F 
0B4C90 1E   
0B4C91 10 
0B4C92 5A 
0B4C93 10 
0B4C93 97   
0B4C94 10 
0B4C95 D5 
0B4C96 10 
0B4C9A 13    0161** DW	4371, 4435, 4499, 4565, 4631, 4699, 4767, 4836
0B4C9B 11 
0B4C9C 53 
0B4C9D 11 
0B4C9D 93   
0B4C9E 11 
0B4C9F D5 
0B4CA0 11 
0B4CA0 17   
0B4CA1 12 
0B4CA2 5B 
0B4CA3 12 
0B4CA3 9F   
0B4CA4 12 
0B4CA5 E4 
0B4CA6 12 
             0162** 
             0163** 
              0015* include "basic/interrupts.asm"
             0001** ;
             0002** ; Title:	BBC Basic for AGON - Interrupts
             0003** ; Author:	Dean Belfield
             0004** ; Created:	12/05/2023
             0005** ; Last Updated:	07/06/2023
             0006** ;
             0007** ; Modinfo:
             0008** ; 07/06/2023:	Modified to run in ADL mode
             0009** 
             0010** ; .ASSUME	ADL = 1
             0011** 
             0012** ; INCLUDE	"macros.inc"
             0013** ; INCLUDE	"equs.inc"
             0014** ; INCLUDE "mos_api.inc"	; In MOS/src
             0015** 
             0016** ; SEGMENT CODE
             0017** 
             0018** ; XDEF	VBLANK_INIT
             0019** ; XDEF	VBLANK_STOP
             0020** ; XDEF	VBLANK_HANDLER
             0021** 
             0022** ; XREF	ESCSET
             0023** ; XREF	KEYDOWN		; In ram.asm
             0024** ; XREF	KEYASCII 	; In ram.asm
             0025** ; XREF	KEYCOUNT	; In ram.asm
             0026** 
             0027** ; Hook into the MOS VBLANK interrupt
             0028** ;
0B4CAA F3    0029** VBLANK_INIT:		DI
0B4CAB 21    0030** LD		HL, VBLANK_HANDLER		; this interrupt handler routine who's
0B4CAC FF 
0B4CAD 4C 
0B4CAE 0B 
0B4CAF 1E    0031** LD		E, 32h				; Set up the VBlank Interrupt Vector
0B4CB0 32 
             0032** MOSCALL		mos_setintvector
0B4CB1 3E   0001**M LD	A, function
0B4CB2 14 
0B4CB3 49   0002**M RST.LIS	08h
0B4CB4 CF 
             0033** ; EX		HL, DE 				; DEU: Pointer to the MOS interrupt vector
0B4CB5 EB    0034** ex de,hl
0B4CB6 21    0035** LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B4CB7 0D 
0B4CB8 4D 
0B4CB9 0B 
0B4CBA ED    0036** LD		(HL), DE			; Self-modify the code
0B4CBB 1F 
0B4CBC FB    0037** EI
0B4CBD C9    0038** RET
             0039** 
             0040** ; Unhook the custom VBLANK interrupt
             0041** ;
0B4CBE F3    0042** VBLANK_STOP:		DI
0B4CBF 21    0043** LD		HL, VBLANK_HANDLER_JP + 1	; Pointer to the JP address in this segment
0B4CC0 0D 
0B4CC1 4D 
0B4CC2 0B 
0B4CC3 ED    0044** LD		DE, (HL)
0B4CC4 17 
0B4CC5 EB    0045** EX		DE, HL 				; HLU: Address of MOS interrupt vector
0B4CC6 1E    0046** LD		E, 32h
0B4CC7 32 
             0047** MOSCALL		mos_setintvector		; Restore the MOS interrupt vector
0B4CC8 3E   0001**M LD	A, function
0B4CC9 14 
0B4CCA 49   0002**M RST.LIS	08h
0B4CCB CF 
0B4CCC FB    0048** EI
0B4CCD C9    0049** RET
             0050** 
             0051** ; A safe LIS call to ESCSET
             0052** ;
             0053** DO_KEYBOARD:		MOSCALL		mos_sysvars			; Get the system variables
0B4CCE 3E   0001**M LD	A, function
0B4CCF 08 
0B4CD0 49   0002**M RST.LIS	08h
0B4CD1 CF 
0B4CD2 21    0054** LD		HL, KEYCOUNT 			; Check whether the keycount has changed
0B4CD3 49 
0B4CD4 51 
0B4CD5 0B 
0B4CD6 DD    0055** LD		A, (IX + sysvar_vkeycount)	; by comparing the MOS copy
0B4CD7 7E 
0B4CD8 19 
0B4CD9 BE    0056** CP 		(HL)				; with our local copy
0B4CDA 20    0057** JR		NZ, DO_KEYBOARD_1		; Yes it has, so jump to the next bit
0B4CDB 0A 
             0058** ;
0B4CDC AF    0059** DO_KEYBOARD_0:		XOR		A 				; Clear the keyboard values
0B4CDD 32    0060** LD		(KEYASCII), A
0B4CDE 48 
0B4CDF 51 
0B4CE0 0B 
0B4CE1 32    0061** LD		(KEYDOWN), A
0B4CE2 47 
0B4CE3 51 
0B4CE4 0B 
0B4CE5 C9    0062** RET	 					; And return
             0063** ;
0B4CE6 77    0064** DO_KEYBOARD_1:		LD		(HL), A 			; Store the updated local copy of keycount
0B4CE7 DD    0065** LD		A, (IX + sysvar_vkeydown)	; Fetch key down value (1 = key down, 0 = key up)
0B4CE8 7E 
0B4CE9 18 
0B4CEA B7    0066** OR		A
0B4CEB 28    0067** JR		Z, DO_KEYBOARD_0		; If it is key up, then clear the keyboard values
0B4CEC EF 
             0068** ;
0B4CED 32    0069** LD		(KEYDOWN), A 			; Store the keydown value
0B4CEE 47 
0B4CEF 51 
0B4CF0 0B 
0B4CF1 DD    0070** LD		A, (IX + sysvar_keyascii)	; Fetch key ASCII value
0B4CF2 7E 
0B4CF3 05 
0B4CF4 32    0071** LD		(KEYASCII), A 			; Store locally
0B4CF5 48 
0B4CF6 51 
0B4CF7 0B 
0B4CF8 FE    0072** CP		1Bh				; Is it escape?
0B4CF9 1B 
0B4CFA CC    0073** CALL		Z, ESCSET			; Yes, so set the escape flags
0B4CFB 16 
0B4CFC 43 
0B4CFD 0B 
0B4CFE C9    0074** RET						; Return to the interrupt handler
             0075** 
0B4CFF F3    0076** VBLANK_HANDLER:		DI
0B4D00 F5    0077** PUSH		AF
0B4D01 E5    0078** PUSH		HL
0B4D02 DD    0079** PUSH		IX
0B4D03 E5 
0B4D04 CD    0080** CALL		DO_KEYBOARD
0B4D05 CE 
0B4D06 4C 
0B4D07 0B 
0B4D08 DD    0081** POP		IX
0B4D09 E1 
0B4D0A E1    0082** POP		HL
0B4D0B F1    0083** POP		AF
             0084** ;
             0085** ; Finally jump to the MOS interrupt
             0086** ;
0B4D0C C3    0087** VBLANK_HANDLER_JP:	JP		0				; This is self-modified by VBLANK_INIT
0B4D0D 00 
0B4D0E 00 
0B4D0F 00 
              0016* include "basic/ram.asm"
             0001** ;
             0002** ; Title:	BBC Basic Interpreter - Z80 version
             0003** ;		RAM Module for BBC Basic Interpreter
             0004** ;		For use with Version 2.0 of BBC BASIC
             0005** ;		Standard CP/M Distribution Version
             0006** ; Author:	(C) Copyright  R.T.Russell 31-12-1983
             0007** ; Modified By:	Dean Belfield
             0008** ; Created:	12/05/2023
             0009** ; Last Updated:	26/06/2023
             0010** ;
             0011** ; Modinfo:
             0012** ; 06/06/2023:	Modified to run in ADL mode
             0013** ; 26/06/2023:	Added temporary stores R0 and R1
             0014** 
             0015** ; .ASSUME	ADL = 1
             0016** 
             0017** ; DEFINE	LORAM, SPACE = ROM
             0018** ; SEGMENT LORAM
             0019** 
             0020** ; XDEF	ACCS
             0021** ; XDEF	BUFFER
             0022** ; XDEF	STAVAR
             0023** ; XDEF	DYNVAR
             0024** ; XDEF	FNPTR
             0025** ; XDEF	PROPTR
             0026** ; XDEF	PAGE_
             0027** ; XDEF	TOP
             0028** ; XDEF	LOMEM
             0029** ; XDEF 	FREE
             0030** ; XDEF	HIMEM
             0031** ; XDEF	LINENO
             0032** ; XDEF	TRACEN
             0033** ; XDEF	AUTONO
             0034** ; XDEF	ERRTRP
             0035** ; XDEF	ERRTXT
             0036** ; XDEF	DATPTR
             0037** ; XDEF	ERL
             0038** ; XDEF	ERRLIN
             0039** ; XDEF	RANDOM
             0040** ; XDEF	COUNT
             0041** ; XDEF	WIDTH
             0042** ; XDEF	ERR
             0043** ; XDEF	LISTON
             0044** ; XDEF	INCREM
             0045** 
             0046** ; XDEF	FLAGS
             0047** ; XDEF	OSWRCHPT
             0048** ; XDEF	OSWRCHCH
             0049** ; XDEF	OSWRCHFH
             0050** ; XDEF	KEYDOWN
             0051** ; XDEF	KEYASCII
             0052** ; XDEF	KEYCOUNT
             0053** 
             0054** ; XDEF	R0
             0055** ; XDEF	R1
             0056** 
             0057** ; XDEF	RAM_START
             0058** ; XDEF	RAM_END
             0059** ; XDEF	USER
             0060** 
             0061** end_binary: ;  for assemble.py to know where to truncate the binary file
0B4D10 FF    0062** ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
0B4D11 FF 
0B4D12 FF 
0B4D13 FF 
0B4D13 FF   
0B4D14 FF 
0B4D15 FF 
0B4D16 FF 
0B4D16 FF   
0B4D17 FF 
0B4D18 FF 
0B4D19 FF 
0B4D19 FF   
0B4D1A FF 
0B4D1B FF 
0B4D1C FF 
0B4D1C FF   
0B4D1D FF 
0B4D1E FF 
0B4D1F FF 
0B4D1F FF   
0B4D20 FF 
0B4D21 FF 
0B4D22 FF 
0B4D22 FF   
0B4D23 FF 
0B4D24 FF 
0B4D25 FF 
0B4D25 FF   
0B4D26 FF 
0B4D27 FF 
0B4D28 FF 
0B4D28 FF   
0B4D29 FF 
0B4D2A FF 
0B4D2B FF 
0B4D2B FF   
0B4D2C FF 
0B4D2D FF 
0B4D2E FF 
0B4D2E FF   
0B4D2F FF 
0B4D30 FF 
0B4D31 FF 
0B4D31 FF   
0B4D32 FF 
0B4D33 FF 
0B4D34 FF 
0B4D34 FF   
0B4D35 FF 
0B4D36 FF 
0B4D37 FF 
0B4D37 FF   
0B4D38 FF 
0B4D39 FF 
0B4D3A FF 
0B4D3A FF   
0B4D3B FF 
0B4D3C FF 
0B4D3D FF 
0B4D3D FF   
0B4D3E FF 
0B4D3F FF 
0B4D40 FF 
0B4D40 FF   
0B4D41 FF 
0B4D42 FF 
0B4D43 FF 
0B4D43 FF   
0B4D44 FF 
0B4D45 FF 
0B4D46 FF 
0B4D46 FF   
0B4D47 FF 
0B4D48 FF 
0B4D49 FF 
0B4D49 FF   
0B4D4A FF 
0B4D4B FF 
0B4D4C FF 
0B4D4C FF   
0B4D4D FF 
0B4D4E FF 
0B4D4F FF 
0B4D4F FF   
0B4D50 FF 
0B4D51 FF 
0B4D52 FF 
0B4D52 FF   
0B4D53 FF 
0B4D54 FF 
0B4D55 FF 
0B4D55 FF   
0B4D56 FF 
0B4D57 FF 
0B4D58 FF 
0B4D58 FF   
0B4D59 FF 
0B4D5A FF 
0B4D5B FF 
0B4D5B FF   
0B4D5C FF 
0B4D5D FF 
0B4D5E FF 
0B4D5E FF   
0B4D5F FF 
0B4D60 FF 
0B4D61 FF 
0B4D61 FF   
0B4D62 FF 
0B4D63 FF 
0B4D64 FF 
0B4D64 FF   
0B4D65 FF 
0B4D66 FF 
0B4D67 FF 
0B4D67 FF   
0B4D68 FF 
0B4D69 FF 
0B4D6A FF 
0B4D6A FF   
0B4D6B FF 
0B4D6C FF 
0B4D6D FF 
0B4D6D FF   
0B4D6E FF 
0B4D6F FF 
0B4D70 FF 
0B4D70 FF   
0B4D71 FF 
0B4D72 FF 
0B4D73 FF 
0B4D73 FF   
0B4D74 FF 
0B4D75 FF 
0B4D76 FF 
0B4D76 FF   
0B4D77 FF 
0B4D78 FF 
0B4D79 FF 
0B4D79 FF   
0B4D7A FF 
0B4D7B FF 
0B4D7C FF 
0B4D7C FF   
0B4D7D FF 
0B4D7E FF 
0B4D7F FF 
0B4D7F FF   
0B4D80 FF 
0B4D81 FF 
0B4D82 FF 
0B4D82 FF   
0B4D83 FF 
0B4D84 FF 
0B4D85 FF 
0B4D85 FF   
0B4D86 FF 
0B4D87 FF 
0B4D88 FF 
0B4D88 FF   
0B4D89 FF 
0B4D8A FF 
0B4D8B FF 
0B4D8B FF   
0B4D8C FF 
0B4D8D FF 
0B4D8E FF 
0B4D8E FF   
0B4D8F FF 
0B4D90 FF 
0B4D91 FF 
0B4D91 FF   
0B4D92 FF 
0B4D93 FF 
0B4D94 FF 
0B4D94 FF   
0B4D95 FF 
0B4D96 FF 
0B4D97 FF 
0B4D97 FF   
0B4D98 FF 
0B4D99 FF 
0B4D9A FF 
0B4D9A FF   
0B4D9B FF 
0B4D9C FF 
0B4D9D FF 
0B4D9D FF   
0B4D9E FF 
0B4D9F FF 
0B4DA0 FF 
0B4DA0 FF   
0B4DA1 FF 
0B4DA2 FF 
0B4DA3 FF 
0B4DA3 FF   
0B4DA4 FF 
0B4DA5 FF 
0B4DA6 FF 
0B4DA6 FF   
0B4DA7 FF 
0B4DA8 FF 
0B4DA9 FF 
0B4DA9 FF   
0B4DAA FF 
0B4DAB FF 
0B4DAC FF 
0B4DAC FF   
0B4DAD FF 
0B4DAE FF 
0B4DAF FF 
0B4DAF FF   
0B4DB0 FF 
0B4DB1 FF 
0B4DB2 FF 
0B4DB2 FF   
0B4DB3 FF 
0B4DB4 FF 
0B4DB5 FF 
0B4DB5 FF   
0B4DB6 FF 
0B4DB7 FF 
0B4DB8 FF 
0B4DB8 FF   
0B4DB9 FF 
0B4DBA FF 
0B4DBB FF 
0B4DBB FF   
0B4DBC FF 
0B4DBD FF 
0B4DBE FF 
0B4DBE FF   
0B4DBF FF 
0B4DC0 FF 
0B4DC1 FF 
0B4DC1 FF   
0B4DC2 FF 
0B4DC3 FF 
0B4DC4 FF 
             0063** RAM_START:
             0064** ;
0B4E00 00    0065** ACCS:           BLKB    256,0             ; String Accumulator
0B4E01 00 
0B4E02 00 
0B4E03 00 
0B4E03 00   
0B4E04 00 
0B4E05 00 
0B4E06 00 
0B4E06 00   
0B4E07 00 
0B4E08 00 
0B4E09 00 
0B4E09 00   
0B4E0A 00 
0B4E0B 00 
0B4E0C 00 
0B4E0C 00   
0B4E0D 00 
0B4E0E 00 
0B4E0F 00 
0B4E0F 00   
0B4E10 00 
0B4E11 00 
0B4E12 00 
0B4E12 00   
0B4E13 00 
0B4E14 00 
0B4E15 00 
0B4E15 00   
0B4E16 00 
0B4E17 00 
0B4E18 00 
0B4E18 00   
0B4E19 00 
0B4E1A 00 
0B4E1B 00 
0B4E1B 00   
0B4E1C 00 
0B4E1D 00 
0B4E1E 00 
0B4E1E 00   
0B4E1F 00 
0B4E20 00 
0B4E21 00 
0B4E21 00   
0B4E22 00 
0B4E23 00 
0B4E24 00 
0B4E24 00   
0B4E25 00 
0B4E26 00 
0B4E27 00 
0B4E27 00   
0B4E28 00 
0B4E29 00 
0B4E2A 00 
0B4E2A 00   
0B4E2B 00 
0B4E2C 00 
0B4E2D 00 
0B4E2D 00   
0B4E2E 00 
0B4E2F 00 
0B4E30 00 
0B4E30 00   
0B4E31 00 
0B4E32 00 
0B4E33 00 
0B4E33 00   
0B4E34 00 
0B4E35 00 
0B4E36 00 
0B4E36 00   
0B4E37 00 
0B4E38 00 
0B4E39 00 
0B4E39 00   
0B4E3A 00 
0B4E3B 00 
0B4E3C 00 
0B4E3C 00   
0B4E3D 00 
0B4E3E 00 
0B4E3F 00 
0B4E3F 00   
0B4E40 00 
0B4E41 00 
0B4E42 00 
0B4E42 00   
0B4E43 00 
0B4E44 00 
0B4E45 00 
0B4E45 00   
0B4E46 00 
0B4E47 00 
0B4E48 00 
0B4E48 00   
0B4E49 00 
0B4E4A 00 
0B4E4B 00 
0B4E4B 00   
0B4E4C 00 
0B4E4D 00 
0B4E4E 00 
0B4E4E 00   
0B4E4F 00 
0B4E50 00 
0B4E51 00 
0B4E51 00   
0B4E52 00 
0B4E53 00 
0B4E54 00 
0B4E54 00   
0B4E55 00 
0B4E56 00 
0B4E57 00 
0B4E57 00   
0B4E58 00 
0B4E59 00 
0B4E5A 00 
0B4E5A 00   
0B4E5B 00 
0B4E5C 00 
0B4E5D 00 
0B4E5D 00   
0B4E5E 00 
0B4E5F 00 
0B4E60 00 
0B4E60 00   
0B4E61 00 
0B4E62 00 
0B4E63 00 
0B4E63 00   
0B4E64 00 
0B4E65 00 
0B4E66 00 
0B4E66 00   
0B4E67 00 
0B4E68 00 
0B4E69 00 
0B4E69 00   
0B4E6A 00 
0B4E6B 00 
0B4E6C 00 
0B4E6C 00   
0B4E6D 00 
0B4E6E 00 
0B4E6F 00 
0B4E6F 00   
0B4E70 00 
0B4E71 00 
0B4E72 00 
0B4E72 00   
0B4E73 00 
0B4E74 00 
0B4E75 00 
0B4E75 00   
0B4E76 00 
0B4E77 00 
0B4E78 00 
0B4E78 00   
0B4E79 00 
0B4E7A 00 
0B4E7B 00 
0B4E7B 00   
0B4E7C 00 
0B4E7D 00 
0B4E7E 00 
0B4E7E 00   
0B4E7F 00 
0B4E80 00 
0B4E81 00 
0B4E81 00   
0B4E82 00 
0B4E83 00 
0B4E84 00 
0B4E84 00   
0B4E85 00 
0B4E86 00 
0B4E87 00 
0B4E87 00   
0B4E88 00 
0B4E89 00 
0B4E8A 00 
0B4E8A 00   
0B4E8B 00 
0B4E8C 00 
0B4E8D 00 
0B4E8D 00   
0B4E8E 00 
0B4E8F 00 
0B4E90 00 
0B4E90 00   
0B4E91 00 
0B4E92 00 
0B4E93 00 
0B4E93 00   
0B4E94 00 
0B4E95 00 
0B4E96 00 
0B4E96 00   
0B4E97 00 
0B4E98 00 
0B4E99 00 
0B4E99 00   
0B4E9A 00 
0B4E9B 00 
0B4E9C 00 
0B4E9C 00   
0B4E9D 00 
0B4E9E 00 
0B4E9F 00 
0B4E9F 00   
0B4EA0 00 
0B4EA1 00 
0B4EA2 00 
0B4EA2 00   
0B4EA3 00 
0B4EA4 00 
0B4EA5 00 
0B4EA5 00   
0B4EA6 00 
0B4EA7 00 
0B4EA8 00 
0B4EA8 00   
0B4EA9 00 
0B4EAA 00 
0B4EAB 00 
0B4EAB 00   
0B4EAC 00 
0B4EAD 00 
0B4EAE 00 
0B4EAE 00   
0B4EAF 00 
0B4EB0 00 
0B4EB1 00 
0B4EB1 00   
0B4EB2 00 
0B4EB3 00 
0B4EB4 00 
0B4EB4 00   
0B4EB5 00 
0B4EB6 00 
0B4EB7 00 
0B4EB7 00   
0B4EB8 00 
0B4EB9 00 
0B4EBA 00 
0B4EBA 00   
0B4EBB 00 
0B4EBC 00 
0B4EBD 00 
0B4EBD 00   
0B4EBE 00 
0B4EBF 00 
0B4EC0 00 
0B4F00 00    0066** BUFFER:         BLKB    256,0             ; String Input Buffer
0B4F01 00 
0B4F02 00 
0B4F03 00 
0B4F03 00   
0B4F04 00 
0B4F05 00 
0B4F06 00 
0B4F06 00   
0B4F07 00 
0B4F08 00 
0B4F09 00 
0B4F09 00   
0B4F0A 00 
0B4F0B 00 
0B4F0C 00 
0B4F0C 00   
0B4F0D 00 
0B4F0E 00 
0B4F0F 00 
0B4F0F 00   
0B4F10 00 
0B4F11 00 
0B4F12 00 
0B4F12 00   
0B4F13 00 
0B4F14 00 
0B4F15 00 
0B4F15 00   
0B4F16 00 
0B4F17 00 
0B4F18 00 
0B4F18 00   
0B4F19 00 
0B4F1A 00 
0B4F1B 00 
0B4F1B 00   
0B4F1C 00 
0B4F1D 00 
0B4F1E 00 
0B4F1E 00   
0B4F1F 00 
0B4F20 00 
0B4F21 00 
0B4F21 00   
0B4F22 00 
0B4F23 00 
0B4F24 00 
0B4F24 00   
0B4F25 00 
0B4F26 00 
0B4F27 00 
0B4F27 00   
0B4F28 00 
0B4F29 00 
0B4F2A 00 
0B4F2A 00   
0B4F2B 00 
0B4F2C 00 
0B4F2D 00 
0B4F2D 00   
0B4F2E 00 
0B4F2F 00 
0B4F30 00 
0B4F30 00   
0B4F31 00 
0B4F32 00 
0B4F33 00 
0B4F33 00   
0B4F34 00 
0B4F35 00 
0B4F36 00 
0B4F36 00   
0B4F37 00 
0B4F38 00 
0B4F39 00 
0B4F39 00   
0B4F3A 00 
0B4F3B 00 
0B4F3C 00 
0B4F3C 00   
0B4F3D 00 
0B4F3E 00 
0B4F3F 00 
0B4F3F 00   
0B4F40 00 
0B4F41 00 
0B4F42 00 
0B4F42 00   
0B4F43 00 
0B4F44 00 
0B4F45 00 
0B4F45 00   
0B4F46 00 
0B4F47 00 
0B4F48 00 
0B4F48 00   
0B4F49 00 
0B4F4A 00 
0B4F4B 00 
0B4F4B 00   
0B4F4C 00 
0B4F4D 00 
0B4F4E 00 
0B4F4E 00   
0B4F4F 00 
0B4F50 00 
0B4F51 00 
0B4F51 00   
0B4F52 00 
0B4F53 00 
0B4F54 00 
0B4F54 00   
0B4F55 00 
0B4F56 00 
0B4F57 00 
0B4F57 00   
0B4F58 00 
0B4F59 00 
0B4F5A 00 
0B4F5A 00   
0B4F5B 00 
0B4F5C 00 
0B4F5D 00 
0B4F5D 00   
0B4F5E 00 
0B4F5F 00 
0B4F60 00 
0B4F60 00   
0B4F61 00 
0B4F62 00 
0B4F63 00 
0B4F63 00   
0B4F64 00 
0B4F65 00 
0B4F66 00 
0B4F66 00   
0B4F67 00 
0B4F68 00 
0B4F69 00 
0B4F69 00   
0B4F6A 00 
0B4F6B 00 
0B4F6C 00 
0B4F6C 00   
0B4F6D 00 
0B4F6E 00 
0B4F6F 00 
0B4F6F 00   
0B4F70 00 
0B4F71 00 
0B4F72 00 
0B4F72 00   
0B4F73 00 
0B4F74 00 
0B4F75 00 
0B4F75 00   
0B4F76 00 
0B4F77 00 
0B4F78 00 
0B4F78 00   
0B4F79 00 
0B4F7A 00 
0B4F7B 00 
0B4F7B 00   
0B4F7C 00 
0B4F7D 00 
0B4F7E 00 
0B4F7E 00   
0B4F7F 00 
0B4F80 00 
0B4F81 00 
0B4F81 00   
0B4F82 00 
0B4F83 00 
0B4F84 00 
0B4F84 00   
0B4F85 00 
0B4F86 00 
0B4F87 00 
0B4F87 00   
0B4F88 00 
0B4F89 00 
0B4F8A 00 
0B4F8A 00   
0B4F8B 00 
0B4F8C 00 
0B4F8D 00 
0B4F8D 00   
0B4F8E 00 
0B4F8F 00 
0B4F90 00 
0B4F90 00   
0B4F91 00 
0B4F92 00 
0B4F93 00 
0B4F93 00   
0B4F94 00 
0B4F95 00 
0B4F96 00 
0B4F96 00   
0B4F97 00 
0B4F98 00 
0B4F99 00 
0B4F99 00   
0B4F9A 00 
0B4F9B 00 
0B4F9C 00 
0B4F9C 00   
0B4F9D 00 
0B4F9E 00 
0B4F9F 00 
0B4F9F 00   
0B4FA0 00 
0B4FA1 00 
0B4FA2 00 
0B4FA2 00   
0B4FA3 00 
0B4FA4 00 
0B4FA5 00 
0B4FA5 00   
0B4FA6 00 
0B4FA7 00 
0B4FA8 00 
0B4FA8 00   
0B4FA9 00 
0B4FAA 00 
0B4FAB 00 
0B4FAB 00   
0B4FAC 00 
0B4FAD 00 
0B4FAE 00 
0B4FAE 00   
0B4FAF 00 
0B4FB0 00 
0B4FB1 00 
0B4FB1 00   
0B4FB2 00 
0B4FB3 00 
0B4FB4 00 
0B4FB4 00   
0B4FB5 00 
0B4FB6 00 
0B4FB7 00 
0B4FB7 00   
0B4FB8 00 
0B4FB9 00 
0B4FBA 00 
0B4FBA 00   
0B4FBB 00 
0B4FBC 00 
0B4FBD 00 
0B4FBD 00   
0B4FBE 00 
0B4FBF 00 
0B4FC0 00 
0B5000 00    0067** STAVAR:         BLKB    27*4,0            ; Static Variables
0B5001 00 
0B5002 00 
0B5003 00 
0B5003 00   
0B5004 00 
0B5005 00 
0B5006 00 
0B5006 00   
0B5007 00 
0B5008 00 
0B5009 00 
0B5009 00   
0B500A 00 
0B500B 00 
0B500C 00 
0B500C 00   
0B500D 00 
0B500E 00 
0B500F 00 
0B500F 00   
0B5010 00 
0B5011 00 
0B5012 00 
0B5012 00   
0B5013 00 
0B5014 00 
0B5015 00 
0B5015 00   
0B5016 00 
0B5017 00 
0B5018 00 
0B5018 00   
0B5019 00 
0B501A 00 
0B501B 00 
0B501B 00   
0B501C 00 
0B501D 00 
0B501E 00 
0B501E 00   
0B501F 00 
0B5020 00 
0B5021 00 
0B5021 00   
0B5022 00 
0B5023 00 
0B5024 00 
0B5024 00   
0B5025 00 
0B5026 00 
0B5027 00 
0B5027 00   
0B5028 00 
0B5029 00 
0B502A 00 
0B502A 00   
0B502B 00 
0B502C 00 
0B502D 00 
0B502D 00   
0B502E 00 
0B502F 00 
0B5030 00 
0B5030 00   
0B5031 00 
0B5032 00 
0B5033 00 
0B5033 00   
0B5034 00 
0B5035 00 
0B5036 00 
0B5036 00   
0B5037 00 
0B5038 00 
0B5039 00 
0B5039 00   
0B503A 00 
0B503B 00 
0B503C 00 
0B503C 00   
0B503D 00 
0B503E 00 
0B503F 00 
0B503F 00   
0B5040 00 
0B5041 00 
0B5042 00 
0B5042 00   
0B5043 00 
0B5044 00 
0B5045 00 
0B5045 00   
0B5046 00 
0B5047 00 
0B5048 00 
0B5048 00   
0B5049 00 
0B504A 00 
0B504B 00 
0B504B 00   
0B504C 00 
0B504D 00 
0B504E 00 
0B504E 00   
0B504F 00 
0B5050 00 
0B5051 00 
0B506C 00    0068** DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
0B506D 00 
0B506E 00 
0B506F 00 
0B506F 00   
0B5070 00 
0B5071 00 
0B5072 00 
0B5072 00   
0B5073 00 
0B5074 00 
0B5075 00 
0B5075 00   
0B5076 00 
0B5077 00 
0B5078 00 
0B5078 00   
0B5079 00 
0B507A 00 
0B507B 00 
0B507B 00   
0B507C 00 
0B507D 00 
0B507E 00 
0B507E 00   
0B507F 00 
0B5080 00 
0B5081 00 
0B5081 00   
0B5082 00 
0B5083 00 
0B5084 00 
0B5084 00   
0B5085 00 
0B5086 00 
0B5087 00 
0B5087 00   
0B5088 00 
0B5089 00 
0B508A 00 
0B508A 00   
0B508B 00 
0B508C 00 
0B508D 00 
0B508D 00   
0B508E 00 
0B508F 00 
0B5090 00 
0B5090 00   
0B5091 00 
0B5092 00 
0B5093 00 
0B5093 00   
0B5094 00 
0B5095 00 
0B5096 00 
0B5096 00   
0B5097 00 
0B5098 00 
0B5099 00 
0B5099 00   
0B509A 00 
0B509B 00 
0B509C 00 
0B509C 00   
0B509D 00 
0B509E 00 
0B509F 00 
0B509F 00   
0B50A0 00 
0B50A1 00 
0B50A2 00 
0B50A2 00   
0B50A3 00 
0B50A4 00 
0B50A5 00 
0B50A5 00   
0B50A6 00 
0B50A7 00 
0B50A8 00 
0B50A8 00   
0B50A9 00 
0B50AA 00 
0B50AB 00 
0B50AB 00   
0B50AC 00 
0B50AD 00 
0B50AE 00 
0B50AE 00   
0B50AF 00 
0B50B0 00 
0B50B1 00 
0B50B1 00   
0B50B2 00 
0B50B3 00 
0B50B4 00 
0B50B4 00   
0B50B5 00 
0B50B6 00 
0B50B7 00 
0B50B7 00   
0B50B8 00 
0B50B9 00 
0B50BA 00 
0B50BA 00   
0B50BB 00 
0B50BC 00 
0B50BD 00 
0B50BD 00   
0B50BE 00 
0B50BF 00 
0B50C0 00 
0B50C0 00   
0B50C1 00 
0B50C2 00 
0B50C3 00 
0B50C3 00   
0B50C4 00 
0B50C5 00 
0B50C6 00 
0B50C6 00   
0B50C7 00 
0B50C8 00 
0B50C9 00 
0B50C9 00   
0B50CA 00 
0B50CB 00 
0B50CC 00 
0B50CC 00   
0B50CD 00 
0B50CE 00 
0B50CF 00 
0B50CF 00   
0B50D0 00 
0B50D1 00 
0B50D2 00 
0B50D2 00   
0B50D3 00 
0B50D4 00 
0B50D5 00 
0B50D5 00   
0B50D6 00 
0B50D7 00 
0B50D8 00 
0B50D8 00   
0B50D9 00 
0B50DA 00 
0B50DB 00 
0B50DB 00   
0B50DC 00 
0B50DD 00 
0B50DE 00 
0B50DE 00   
0B50DF 00 
0B50E0 00 
0B50E1 00 
0B50E1 00   
0B50E2 00 
0B50E3 00 
0B50E4 00 
0B50E4 00   
0B50E5 00 
0B510E 00    0069** FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B510F 00 
0B5110 00 
0B5111 00    0070** PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B5112 00 
0B5113 00 
             0071** ;
0B5114 00    0072** PAGE_:          BLKB    3,0               ; Start of User Program
0B5115 00 
0B5116 00 
0B5117 00    0073** TOP:            BLKB    3,0               ; First Location after User Program
0B5118 00 
0B5119 00 
0B511A 00    0074** LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B511B 00 
0B511C 00 
0B511D 00    0075** FREE:           BLKB    3,0               ; First Free Space Byte
0B511E 00 
0B511F 00 
0B5120 00    0076** HIMEM:          BLKB    3,0               ; First Protected Byte
0B5121 00 
0B5122 00 
             0077** ;
0B5123 00    0078** LINENO:         BLKB    3,0               ; Line Number
0B5124 00 
0B5125 00 
0B5126 00    0079** TRACEN:         BLKB    3,0               ; Trace Flag
0B5127 00 
0B5128 00 
0B5129 00    0080** AUTONO:         BLKB    3,0               ; Auto Flag
0B512A 00 
0B512B 00 
0B512C 00    0081** ERRTRP:         BLKB    3,0               ; Error Trap
0B512D 00 
0B512E 00 
0B512F 00    0082** ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B5130 00 
0B5131 00    0083** DATPTR:         BLKB    2,0               ; Data Pointer
0B5132 00 
0B5133 00    0084** ERL:            BLKB    2,0               ; Error Line
0B5134 00 
0B5135 00    0085** ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B5136 00 
0B5137 00 
0B5138 00    0086** RANDOM:         BLKB    5,0               ; Random Number
0B5139 00 
0B513A 00 
0B513B 00 
0B513B 00   
0B513D 00    0087** COUNT:          BLKB    1,0               ; Print Position
0B513E 00    0088** WIDTH:          BLKB    1,0               ; Print Width
0B513F 00    0089** ERR:            BLKB    1,0               ; Error Number
0B5140 00    0090** LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
             0091** ; - BIT 0: If set, output a space after the line number
             0092** ; - BIT 1: If set, then indent FOR/NEXT loops
             0093** ; - BIT 2: If set, then indent REPEAT/UNTIL loops
             0094** ; - BIT 3: If set, then output to buffer for *EDIT
             0095** ; OPT FLAG (top nibble)
             0096** ; - BIT 4: If set, then list whilst assembling
             0097** ; - BIT 5: If set, then assembler errors are reported
             0098** ; - BIT 6: If set, then place the code starting at address pointed to by O%
             0099** ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B5141 00    0100** INCREM:         BLKB    1,0               ; Auto-Increment Value
             0101** ;
             0102** ; --------------------------------------------------------------------------------------------
             0103** ; BEGIN MODIFIED CODE
             0104** ; --------------------------------------------------------------------------------------------
             0105** ; Originally in equs.inc
             0106** ;
             0107** OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
             0108** PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
             0109** VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
             0110** ; --------------------------------------------------------------------------------------------
             0111** ; END MODIFIED CODE
             0112** ; --------------------------------------------------------------------------------------------
             0113** 
             0114** ; Extra Agon-implementation specific system variables
             0115** ;
0B5142 00    0116** FLAGS:          BLKB    1,0       ; Miscellaneous flags
             0117** ; - BIT 7: Set if ESC pressed
             0118** ; - BIT 6: Set to disable ESC
0B5143 00    0119** OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B5144 00 
0B5145 00    0120** OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
             0121** ; - 0: Console
             0122** ; - 1: File
0B5146 00    0123** OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B5147 00    0124** KEYDOWN:        BLKB    1,0       ; Keydown flag
0B5148 00    0125** KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B5149 00    0126** KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B514A 00    0127** R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B514B 00 
0B514C 00 
0B514D 00    0128** R1:             BLKB    3,0
0B514E 00 
0B514F 00 
             0129** 
             0130** ;
             0131** ; This must be at the end
             0132** ;
             0133** RAM_END:
0B5150 FF    0134** ALIGN	256
0B5151 FF 
0B5152 FF 
0B5153 FF 
0B5153 FF   
0B5154 FF 
0B5155 FF 
0B5156 FF 
0B5156 FF   
0B5157 FF 
0B5158 FF 
0B5159 FF 
0B5159 FF   
0B515A FF 
0B515B FF 
0B515C FF 
0B515C FF   
0B515D FF 
0B515E FF 
0B515F FF 
0B515F FF   
0B5160 FF 
0B5161 FF 
0B5162 FF 
0B5162 FF   
0B5163 FF 
0B5164 FF 
0B5165 FF 
0B5165 FF   
0B5166 FF 
0B5167 FF 
0B5168 FF 
0B5168 FF   
0B5169 FF 
0B516A FF 
0B516B FF 
0B516B FF   
0B516C FF 
0B516D FF 
0B516E FF 
0B516E FF   
0B516F FF 
0B5170 FF 
0B5171 FF 
0B5171 FF   
0B5172 FF 
0B5173 FF 
0B5174 FF 
0B5174 FF   
0B5175 FF 
0B5176 FF 
0B5177 FF 
0B5177 FF   
0B5178 FF 
0B5179 FF 
0B517A FF 
0B517A FF   
0B517B FF 
0B517C FF 
0B517D FF 
0B517D FF   
0B517E FF 
0B517F FF 
0B5180 FF 
0B5180 FF   
0B5181 FF 
0B5182 FF 
0B5183 FF 
0B5183 FF   
0B5184 FF 
0B5185 FF 
0B5186 FF 
0B5186 FF   
0B5187 FF 
0B5188 FF 
0B5189 FF 
0B5189 FF   
0B518A FF 
0B518B FF 
0B518C FF 
0B518C FF   
0B518D FF 
0B518E FF 
0B518F FF 
0B518F FF   
0B5190 FF 
0B5191 FF 
0B5192 FF 
0B5192 FF   
0B5193 FF 
0B5194 FF 
0B5195 FF 
0B5195 FF   
0B5196 FF 
0B5197 FF 
0B5198 FF 
0B5198 FF   
0B5199 FF 
0B519A FF 
0B519B FF 
0B519B FF   
0B519C FF 
0B519D FF 
0B519E FF 
0B519E FF   
0B519F FF 
0B51A0 FF 
0B51A1 FF 
0B51A1 FF   
0B51A2 FF 
0B51A3 FF 
0B51A4 FF 
0B51A4 FF   
0B51A5 FF 
0B51A6 FF 
0B51A7 FF 
0B51A7 FF   
0B51A8 FF 
0B51A9 FF 
0B51AA FF 
0B51AA FF   
0B51AB FF 
0B51AC FF 
0B51AD FF 
0B51AD FF   
0B51AE FF 
0B51AF FF 
0B51B0 FF 
0B51B0 FF   
0B51B1 FF 
0B51B2 FF 
0B51B3 FF 
0B51B3 FF   
0B51B4 FF 
0B51B5 FF 
0B51B6 FF 
0B51B6 FF   
0B51B7 FF 
0B51B8 FF 
0B51B9 FF 
0B51B9 FF   
0B51BA FF 
0B51BB FF 
0B51BC FF 
0B51BC FF   
0B51BD FF 
0B51BE FF 
0B51BF FF 
0B51BF FF   
0B51C0 FF 
0B51C1 FF 
0B51C2 FF 
0B51C2 FF   
0B51C3 FF 
0B51C4 FF 
0B51C5 FF 
0B51C5 FF   
0B51C6 FF 
0B51C7 FF 
0B51C8 FF 
0B51C8 FF   
0B51C9 FF 
0B51CA FF 
0B51CB FF 
0B51CB FF   
0B51CC FF 
0B51CD FF 
0B51CE FF 
0B51CE FF   
0B51CF FF 
0B51D0 FF 
0B51D1 FF 
0B51D1 FF   
0B51D2 FF 
0B51D3 FF 
0B51D4 FF 
             0135** USER:							; Must be aligned on a page boundary
             0136** 
               0380 ; include "fpp/ram.asm" ; must be final include so dynamic RAM allocation has room
