PC     Output      Line
040000             0001       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD 21 17 04 0020       call main
040050             0021   
040050             0022   exit:
040050 FD E1       0023       pop iy
040052 DD E1       0024       pop ix
040054 D1          0025       pop de
040055 C1          0026       pop bc
040056 F1          0027       pop af
040057 21 00 00 00 0028       ld hl,0
04005B             0029   
04005B C9          0030       ret
04005C             0031   
04005C             0032   ; API INCLUDES
04005C             0033       include "functions.inc"
04005C             0001*      MACRO printChar char
04005C             0002*          LD A, char
04005C             0003*          RST.LIL 10h
04005C             0004*      ENDMACRO
04005C             0005*  
04005C             0006*  ; test the sign of HL
04005C             0007*  ; inputs: HL obviously
04005C             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04005C             0009*  ; destroys: flags
04005C             0010*      MACRO signHL
04005C             0011*          add hl,de
04005C             0012*          or a
04005C             0013*          sbc hl,de
04005C             0014*      ENDMACRO
04005C             0015*  
04005C             0016*  ; Simulated call to subroutine at HL
04005C             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04005C             0018*  ; outputs: whatever the subroutine does, including HL and BC
04005C             0019*  ; destroys: only what the subroutine does, but always BC
04005C             0020*      MACRO callHL
04005C             0021*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0022*          push bc       ; which constitutes the return address
04005C             0023*          jp   (hl)     ; Jump to the address in HL
04005C             0024*      ENDMACRO
04005C             0025*  
04005C             0026*  ; Simulated call to subroutine at IX
04005C             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04005C             0028*  ; outputs: whatever the subroutine does, including IX and BC
04005C             0029*  ; destroys: only what the subroutine does, but always BC
04005C             0030*      MACRO callIX
04005C             0031*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0032*          push bc       ; which constitutes the return address
04005C             0033*          jp   (ix)     ; Jump to the address in IX
04005C             0034*      ENDMACRO
04005C             0035*  
04005C             0036*  ; Simulated call to soubroutinte at IY
04005C             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04005C             0038*  ; outputs: whatever the subroutine does, including IY and BC
04005C             0039*  ; destroys: only what the subroutine does, but always BC
04005C             0040*      MACRO callIY
04005C             0041*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0042*          push bc       ; which constitutes the return address
04005C             0043*          jp   (iy)     ; Jump to the address in IY
04005C             0044*      ENDMACRO
04005C             0045*  
04005C             0046*      MACRO HLU_TO_A
04005C             0047*          push hl
04005C             0048*          inc sp
04005C             0049*          pop af
04005C             0050*          dec sp
04005C             0051*      ENDMACRO
04005C             0052*  
04005C             0053*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04005C             0054*  ; Print a zero-terminated string
04005C             0055*  ; HL: Pointer to string
04005C             0056*  printString:
04005C C5          0057*  	PUSH	BC
04005D 01 00 00 00 0058*  	LD		BC,0
040061 3E 00       0059*  	LD 	 	A,0
040063 5B DF       0060*  	RST.LIL 18h
040065 C1          0061*  	POP		BC
040066 C9          0062*  	RET
040067             0063*  ; print a VDU sequence
040067             0064*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040067             0065*  sendVDUsequence:
040067 C5          0066*  	PUSH	BC
040068 01 00 00 00 0067*  	LD		BC, 0
04006C 4E          0068*  	LD		C, (HL)
04006D 5B DF       0069*  	RST.LIL	18h
04006F C1          0070*  	POP		BC
040070 C9          0071*  	RET
040071             0072*  ; Print Newline sequence to VDP
040071             0073*  printNewLine:
040071 F5          0074*      push af ; for some reason rst.lil 10h sets carry flag
040072 3E 0D       0075*  	LD	A, '\r'
040074 5B D7       0076*  	RST.LIL 10h
040076 3E 0A       0077*  	LD	A, '\n'
040078 5B D7       0078*  	RST.LIL 10h
04007A F1          0079*      pop af
04007B C9          0080*  	RET
04007C             0081*  
04007C             0082*  ; Print a 24-bit HEX number
04007C             0083*  ; HLU: Number to print
04007C             0084*  printHex24:
04007C E5          0085*  	PUSH	HL
04007D 21 02 00 00 0086*  	LD		HL, 2
040081 39          0087*  	ADD		HL, SP
040082 7E          0088*  	LD		A, (HL)
040083 E1          0089*  	POP		HL
040084 CD 8E 00 04 0090*  	CALL	printHex8
040088             0091*  ; Print a 16-bit HEX number
040088             0092*  ; HL: Number to print
040088             0093*  printHex16:
040088 7C          0094*  	LD		A,H
040089 CD 8E 00 04 0095*  	CALL	printHex8
04008D 7D          0096*  	LD		A,L
04008E             0097*  ; Print an 8-bit HEX number
04008E             0098*  ; A: Number to print
04008E             0099*  printHex8:
04008E 4F          0100*  	LD		C,A
04008F 1F          0101*  	RRA
040090 1F          0102*  	RRA
040091 1F          0103*  	RRA
040092 1F          0104*  	RRA
040093 CD 98 00 04 0105*  	CALL	@F
040097 79          0106*  	LD		A,C
040098             0107*  @@:
040098 E6 0F       0108*  	AND		0Fh
04009A C6 90       0109*  	ADD		A,90h
04009C 27          0110*  	DAA
04009D CE 40       0111*  	ADC		A,40h
04009F 27          0112*  	DAA
0400A0 5B D7       0113*  	RST.LIL	10h
0400A2 C9          0114*  	RET
0400A3             0115*  
0400A3             0116*  printHexA:
0400A3 F5          0117*      push af
0400A4 C5          0118*      push bc
0400A5 CD 8E 00 04 0119*      call printHex8
0400A9 C1          0120*      pop bc
0400AA F1          0121*      pop af
0400AB C9          0122*      ret
0400AC             0123*  
0400AC             0124*  printHexHL:
0400AC F5          0125*      push af
0400AD C5          0126*      push bc
0400AE CD 88 00 04 0127*      call printHex16
0400B2 C1          0128*      pop bc
0400B3 F1          0129*      pop af
0400B4             0130*  
0400B4             0131*  printHexUHL:
0400B4 F5          0132*      push af
0400B5 C5          0133*      push bc
0400B6 CD 7C 00 04 0134*      call printHex24
0400BA C1          0135*      pop bc
0400BB F1          0136*      pop af
0400BC             0137*  
0400BC             0138*  printHexABHL:
0400BC             0139*  ; preserve registers
0400BC C5          0140*      push bc ; b will be ok c will not
0400BD F5          0141*      push af ; will get totally destroyed
0400BE             0142*  ; print a
0400BE CD 8E 00 04 0143*      call printHex8
0400C2             0144*  ; print b
0400C2 78          0145*      ld a,b
0400C3 CD 8E 00 04 0146*      call printHex8
0400C7             0147*  ; print hl
0400C7 CD 88 00 04 0148*      call printHex16
0400CB             0149*  ; restore registers
0400CB F1          0150*      pop af
0400CC C1          0151*      pop bc
0400CD C9          0152*      ret
0400CE             0153*  
0400CE             0154*  printHexBHL:
0400CE             0155*  ; preserve registers
0400CE C5          0156*      push bc ; b will be ok c will not
0400CF F5          0157*      push af ; will get totally destroyed
0400D0             0158*  ; print b
0400D0 78          0159*      ld a,b
0400D1 CD 8E 00 04 0160*      call printHex8
0400D5             0161*  ; print hl
0400D5 CD 88 00 04 0162*      call printHex16
0400D9             0163*  ; restore registers
0400D9 F1          0164*      pop af
0400DA C1          0165*      pop bc
0400DB C9          0166*      ret
0400DC             0167*  
0400DC             0168*  printHexCDE:
0400DC             0169*  ; preserve registers
0400DC C5          0170*      push bc ; b will be ok c will not
0400DD F5          0171*      push af ; will get totally destroyed
0400DE             0172*  ; print c
0400DE 79          0173*      ld a,c
0400DF CD 8E 00 04 0174*      call printHex8
0400E3             0175*  ; print de
0400E3 EB          0176*      ex de,hl
0400E4 CD 88 00 04 0177*      call printHex16
0400E8 EB          0178*      ex de,hl
0400E9             0179*  ; restore registers
0400E9 F1          0180*      pop af
0400EA C1          0181*      pop bc
0400EB C9          0182*      ret
0400EC             0183*  
0400EC             0184*  ; Print a 0x HEX prefix
0400EC             0185*  DisplayHexPrefix:
0400EC 3E 30       0186*  	LD	A, '0'
0400EE 5B D7       0187*  	RST.LIL 10h
0400F0 3E 78       0188*  	LD	A, 'x'
0400F2 5B D7       0189*  	RST.LIL 10h
0400F4 C9          0190*  	RET
0400F5             0191*  
0400F5             0192*      MACRO printDecBC
0400F5             0193*          push hl
0400F5             0194*          push bc
0400F5             0195*          pop hl
0400F5             0196*          call printDec
0400F5             0197*          pop hl
0400F5             0198*      ENDMACRO
0400F5             0199*  
0400F5             0200*      MACRO printDecDE
0400F5             0201*          push hl
0400F5             0202*          push de
0400F5             0203*          pop hl
0400F5             0204*          call printDec
0400F5             0205*          pop hl
0400F5             0206*      ENDMACRO
0400F5             0207*  
0400F5             0208*      MACRO printDecHL
0400F5             0209*          call printDec
0400F5             0210*      ENDMACRO
0400F5             0211*  
0400F5             0212*      MACRO printDecIX
0400F5             0213*          push hl
0400F5             0214*          push ix
0400F5             0215*          pop hl
0400F5             0216*          call printDec
0400F5             0217*          pop hl
0400F5             0218*      ENDMACRO
0400F5             0219*  
0400F5             0220*      MACRO printDecIY
0400F5             0221*          push hl
0400F5             0222*          push iy
0400F5             0223*          pop hl
0400F5             0224*          call printDec
0400F5             0225*          pop hl
0400F5             0226*      ENDMACRO
0400F5             0227*  
0400F5             0228*  
0400F5             0229*  ; Prints the right justified decimal value in HL without leading zeroes
0400F5             0230*  ; HL : Value to print
0400F5             0231*  ; preserves all registers and flags
0400F5             0232*  printDec:
0400F5             0233*  ; BEGIN MY CODE
0400F5             0234*  ; back up all the things
0400F5 F5          0235*      push af
0400F6 C5          0236*      push bc
0400F7 D5          0237*      push de
0400F8 E5          0238*      push hl
0400F9             0239*  ; END MY CODE
0400F9 11 21 01 04 0240*  	LD	 DE, _printDecBuffer
0400FD CD 31 01 04 0241*  	CALL u24_to_ascii
040101             0242*  ; BEGIN MY CODE
040101             0243*  ; replace leading zeroes with spaces
040101 21 21 01 04 0244*      LD	 HL, _printDecBuffer
040105 06 07       0245*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040107             0246*  @loop:
040107 7E          0247*      LD	 A, (HL)
040108 FE 30       0248*      CP	 '0'
04010A C2 18 01 04 0249*      JP	 NZ, @done
04010E 3E 20       0250*      LD   A, ' '
040110 77          0251*      LD	 (HL), A
040111 23          0252*      INC	 HL
040112 CD E8 06 04 0253*      CALL vdu_cursor_forward
040116 10 EF       0254*      DJNZ @loop
040118             0255*  @done:
040118             0256*  ; END MY CODE
040118             0257*  	; LD	 HL, _printDecBuffer
040118 CD 5C 00 04 0258*  	CALL printString
04011C             0259*  ; BEGIN MY CODE
04011C             0260*  ; restore all the things
04011C E1          0261*      pop hl
04011D D1          0262*      pop de
04011E C1          0263*      pop bc
04011F F1          0264*      pop af
040120             0265*  ; END MY CODE
040120 C9          0266*  	RET
040121 00 00 00 00 0267*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040131             0268*  
040131             0269*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040131             0270*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040131             0271*  ; so it will allways be 8 characters length
040131             0272*  ; HL : Value to convert to string
040131             0273*  ; DE : pointer to buffer, at least 8 byte + 0
040131             0274*  u24_to_ascii:
040131 01 80 69 67 0275*  	LD	 BC,-10000000
040135 CD 68 01 04 0276*  	CALL @one_digit
040139 01 C0 BD F0 0277*  	LD	 BC,-1000000
04013D CD 68 01 04 0278*  	CALL @one_digit
040141 01 60 79 FE 0279*  	LD	 BC,-100000
040145 CD 68 01 04 0280*  	CALL @one_digit
040149 01 F0 D8 FF 0281*  	LD   BC,-10000
04014D CD 68 01 04 0282*  	CALL @one_digit
040151 01 18 FC FF 0283*  	LD   BC,-1000
040155 CD 68 01 04 0284*  	CALL @one_digit
040159 01 9C FF FF 0285*  	LD   BC,-100
04015D CD 68 01 04 0286*  	CALL @one_digit
040161 0E F6       0287*  	LD   C,-10
040163 CD 68 01 04 0288*  	CALL @one_digit
040167 48          0289*  	LD   C,B
040168             0290*  @one_digit:
040168 3E 2F       0291*  	LD   A,'0'-1
04016A             0292*  @divide_me:
04016A 3C          0293*  	INC  A
04016B 09          0294*  	ADD  HL,BC
04016C 38 FC       0295*  	JR   C,@divide_me
04016E ED 42       0296*  	SBC  HL,BC
040170 12          0297*  	LD   (DE),A
040171 13          0298*  	INC  DE
040172 C9          0299*  	RET
040173             0300*  
040173             0301*  print_u24:
040173 11 21 01 04 0302*      ld de,_printDecBuffer
040177 CD 31 01 04 0303*      call u24_to_ascii
04017B 21 21 01 04 0304*      ld hl,_printDecBuffer
04017F CD 5C 00 04 0305*      call printString
040183 C9          0306*      ret
040184             0307*  
040184             0308*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040184             0309*  ; HL : Value to convert to string (integer part in H, fractional part in L)
040184             0310*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040184             0311*  u168_to_ascii:
040184             0312*  ; add a leading space to make room for sign flag if needed
040184 3E 20       0313*      ld a,' '
040186 12          0314*      ld (de),a
040187 13          0315*      inc de
040188             0316*  ; Convert integer part
040188 E5          0317*      push hl               ; Save HL (we’ll need the fractional part later)
040189 CD 9E 0C 04 0318*      call shift_hlu_r1b    ; Shift to get integer portion in HL
04018D 01 F0 D8 FF 0319*      ld   bc, -10000
040191 CD B4 01 04 0320*      call @one_int
040195 01 18 FC FF 0321*      ld   bc, -1000
040199 CD B4 01 04 0322*      call @one_int
04019D 01 9C FF FF 0323*      ld   bc, -100
0401A1 CD B4 01 04 0324*      call @one_int
0401A5 0E F6       0325*      ld   c, -10
0401A7 CD B4 01 04 0326*      call @one_int
0401AB 48          0327*      ld   c, b
0401AC CD B4 01 04 0328*      call @one_int
0401B0 C3 BF 01 04 0329*      jp   @frac            ; Jump to fractional part conversion
0401B4             0330*  @one_int:
0401B4 3E 2F       0331*      ld   a, '0' - 1       ; Start ASCII character at '0'
0401B6             0332*  @divide_me:
0401B6 3C          0333*      inc  a
0401B7 09          0334*      add  hl, bc           ; Accumulate until overflow
0401B8 38 FC       0335*      jr   c, @divide_me
0401BA ED 42       0336*      sbc  hl, bc           ; Remove excess after overflow
0401BC 12          0337*      ld   (de), a          ; Store ASCII digit
0401BD 13          0338*      inc  de
0401BE C9          0339*      ret
0401BF             0340*  ; Convert fractional part
0401BF             0341*  @frac:
0401BF 3E 2E       0342*      ld   a, '.'           ; Decimal point
0401C1 12          0343*      ld   (de), a
0401C2 13          0344*      inc  de
0401C3 E1          0345*      pop  hl               ; Restore HL with original fraction
0401C4 06 03       0346*      ld   b, 3             ; Loop counter for 3 fractional digits
0401C6             0347*  @frac_loop:
0401C6 26 0A       0348*      ld   h, 10            ; Load multiplier for fractional part
0401C8 ED 6C       0349*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0401CA 3E 30       0350*      ld   a, '0'
0401CC 84          0351*      add  a, h             ; Convert integer part to ASCII
0401CD 12          0352*      ld   (de), a
0401CE 13          0353*      inc  de
0401CF 10 F5       0354*      djnz @frac_loop       ; Repeat for each fractional digit
0401D1             0355*  ; Add null terminator
0401D1 AF          0356*      xor  a                ; Null terminator
0401D2 12          0357*      ld   (de), a
0401D3 C9          0358*      ret
0401D4             0359*  
0401D4             0360*  print_u168:
0401D4 11 21 01 04 0361*      ld de,_printDecBuffer
0401D8 CD 84 01 04 0362*      call u168_to_ascii
0401DC 21 21 01 04 0363*      ld hl,_printDecBuffer
0401E0 CD 5C 00 04 0364*      call printString
0401E4 C9          0365*      ret
0401E5             0366*  
0401E5             0367*  ; signed version of u168_to_ascii
0401E5             0368*  s168_to_ascii:
0401E5 D5          0369*      push de ; save starting address of buffer
0401E6 CD D5 16 04 0370*      call abs_hlu
0401EA F5          0371*      push af ; save sign flag
0401EB CD 84 01 04 0372*      call u168_to_ascii
0401EF F1          0373*      pop af ; restore sign flag
0401F0 D1          0374*      pop de ; restore starting address of buffer
0401F1 F0          0375*      ret p ; hlu was positive so nothing to do
0401F2 3E 2D       0376*      ld a,'-'
0401F4 12          0377*      ld (de),a
0401F5 C9          0378*      ret
0401F6             0379*  
0401F6             0380*  print_s168:
0401F6 11 21 01 04 0381*      ld de,_printDecBuffer
0401FA CD E5 01 04 0382*      call s168_to_ascii
0401FE 21 21 01 04 0383*      ld hl,_printDecBuffer
040202 CD 5C 00 04 0384*      call printString
040206 C9          0385*      ret
040207             0386*  
040207             0387*  ; #### new functions added by Brandon R. Gates ####
040207             0388*  
040207             0389*  ; print the binary representation of the 8-bit value in a
040207             0390*  ; destroys a, hl, bc
040207             0391*  printBin8:
040207 06 08       0392*      ld b,8      ; loop counter for 8 bits
040209 21 24 02 04 0393*      ld hl,@cmd  ; set hl to the low byte of the output string
04020D             0394*                  ; (which will be the high bit of the value in a)
04020D             0395*  @loop:
04020D 07          0396*      rlca ; put the next highest bit into carry
04020E 38 04       0397*      jr c,@one
040210 36 30       0398*      ld (hl),'0'
040212 18 02       0399*      jr @next_bit
040214             0400*  @one:
040214 36 31       0401*      ld (hl),'1'
040216             0402*  @next_bit:
040216 23          0403*      inc hl
040217 10 F4       0404*      djnz @loop
040219             0405*  ; print it
040219 21 24 02 04 0406*  	ld hl,@cmd
04021D 01 08 00 00 0407*  	ld bc,@end-@cmd
040221 5B DF       0408*  	rst.lil $18
040223 C9          0409*  	ret
040224             0410*  @cmd: ds 8 ; eight bytes for eight bits
04022C             0411*  @end:
04022C             0412*  
04022C             0413*  ; print the binary representation of the 8-bit value in a
04022C             0414*  ; in reverse order (lsb first)
04022C             0415*  ; destroys a, hl, bc
04022C             0416*  printBin8Rev:
04022C 06 08       0417*      ld b,8      ; loop counter for 8 bits
04022E 21 49 02 04 0418*      ld hl,@cmd  ; set hl to the low byte of the output string
040232             0419*                  ; (which will be the high bit of the value in a)
040232             0420*  @loop:
040232 0F          0421*      rrca ; put the next lowest bit into carry
040233 38 04       0422*      jr c,@one
040235 36 30       0423*      ld (hl),'0'
040237 18 02       0424*      jr @next_bit
040239             0425*  @one:
040239 36 31       0426*      ld (hl),'1'
04023B             0427*  @next_bit:
04023B 23          0428*      inc hl
04023C 10 F4       0429*      djnz @loop
04023E             0430*  ; print it
04023E 21 49 02 04 0431*  	ld hl,@cmd
040242 01 08 00 00 0432*  	ld bc,@end-@cmd
040246 5B DF       0433*  	rst.lil $18
040248 C9          0434*  	ret
040249             0435*  @cmd: ds 8 ; eight bytes for eight bits
040251             0436*  @end:
040251             0437*  
040251             0438*  ; print registers to screen in hexidecimal format
040251             0439*  ; inputs: none
040251             0440*  ; outputs: values of every register printed to screen
040251             0441*  ;    values of each register in global scratch memory
040251             0442*  ; destroys: nothing
040251             0443*  stepRegistersHex:
040251             0444*  ; store everything in scratch
040251 22 3E 04 04 0445*      ld (uhl),hl
040255 ED 43 41 04 0446*      ld (ubc),bc
       04          
04025A ED 53 44 04 0447*      ld (ude),de
       04          
04025F DD 22 47 04 0448*      ld (uix),ix
       04          
040264 FD 22 4A 04 0449*      ld (uiy),iy
       04          
040269 F5          0450*      push af ; fml
04026A E1          0451*      pop hl  ; thanks, zilog
04026B 22 3B 04 04 0452*      ld (uaf),hl
04026F F5          0453*      push af ; dammit
040270             0454*  
040270             0455*  ; home the cursor
040270 CD C7 06 04 0456*      call vdu_home_cursor
040274             0457*  
040274             0458*  ; print each register
040274 21 C1 03 04 0459*      ld hl,str_afu
040278 CD 5C 00 04 0460*      call printString
04027C 2A 3B 04 04 0461*      ld hl,(uaf)
040280 CD 7C 00 04 0462*      call printHex24
040284 CD 71 00 04 0463*      call printNewLine
040288             0464*  
040288 21 C6 03 04 0465*      ld hl,str_hlu
04028C CD 5C 00 04 0466*      call printString
040290 2A 3E 04 04 0467*      ld hl,(uhl)
040294 CD 7C 00 04 0468*      call printHex24
040298 CD 71 00 04 0469*      call printNewLine
04029C             0470*  
04029C 21 CB 03 04 0471*      ld hl,str_bcu
0402A0 CD 5C 00 04 0472*      call printString
0402A4 2A 41 04 04 0473*      ld hl,(ubc)
0402A8 CD 7C 00 04 0474*      call printHex24
0402AC CD 71 00 04 0475*      call printNewLine
0402B0             0476*  
0402B0 21 D0 03 04 0477*      ld hl,str_deu
0402B4 CD 5C 00 04 0478*      call printString
0402B8 2A 44 04 04 0479*      ld hl,(ude)
0402BC CD 7C 00 04 0480*      call printHex24
0402C0 CD 71 00 04 0481*      call printNewLine
0402C4             0482*  
0402C4 21 D5 03 04 0483*      ld hl,str_ixu
0402C8 CD 5C 00 04 0484*      call printString
0402CC 2A 47 04 04 0485*      ld hl,(uix)
0402D0 CD 7C 00 04 0486*      call printHex24
0402D4 CD 71 00 04 0487*      call printNewLine
0402D8             0488*  
0402D8 21 DA 03 04 0489*      ld hl,str_iyu
0402DC CD 5C 00 04 0490*      call printString
0402E0 2A 4A 04 04 0491*      ld hl,(uiy)
0402E4 CD 7C 00 04 0492*      call printHex24
0402E8 CD 71 00 04 0493*      call printNewLine
0402EC             0494*  
0402EC             0495*      ; call vsync
0402EC             0496*  
0402EC CD 71 00 04 0497*      call printNewLine
0402F0             0498*  
0402F0             0499*  ; check for right shift key and quit if pressed
0402F0             0500*  	MOSCALL mos_getkbmap
0402F0 3E 1E       0001*M 			LD	A, function
0402F2 5B CF       0002*M 			RST.L	08h
0402F4             0501*  @stayhere:
0402F4             0502*  ; 7 RightShift
0402F4 DD CB 00 76 0503*      bit 6,(ix+0)
0402F8 20 02       0504*      jr nz,@RightShift
0402FA 18 F8       0505*      jr @stayhere
0402FC             0506*  @RightShift:
0402FC DD CB 0E 86 0507*      res 0,(ix+14) ; debounce the key (hopefully)
040300 3E 80       0508*      ld a,%10000000
040302 CD A7 06 04 0509*      call multiPurposeDelay
040306             0510*  
040306             0511*  ; restore everything
040306 2A 3E 04 04 0512*      ld hl, (uhl)
04030A ED 4B 41 04 0513*      ld bc, (ubc)
       04          
04030F ED 5B 44 04 0514*      ld de, (ude)
       04          
040314 DD 2A 47 04 0515*      ld ix, (uix)
       04          
040319 FD 2A 4A 04 0516*      ld iy, (uiy)
       04          
04031E F1          0517*      pop af
04031F             0518*  ; all done
04031F C9          0519*      ret
040320             0520*  
040320             0521*  ; print registers to screen in hexidecimal format
040320             0522*  ; inputs: none
040320             0523*  ; outputs: values of every register printed to screen
040320             0524*  ;    values of each register in global scratch memory
040320             0525*  ; destroys: nothing
040320             0526*  dumpRegistersHex:
040320             0527*  ; store everything in scratch
040320 22 3E 04 04 0528*      ld (uhl),hl
040324 ED 43 41 04 0529*      ld (ubc),bc
       04          
040329 ED 53 44 04 0530*      ld (ude),de
       04          
04032E DD 22 47 04 0531*      ld (uix),ix
       04          
040333 FD 22 4A 04 0532*      ld (uiy),iy
       04          
040338 F5          0533*      push af ; fml
040339 E1          0534*      pop hl  ; thanks, zilog
04033A 22 3B 04 04 0535*      ld (uaf),hl
04033E F5          0536*      push af ; dammit
04033F             0537*  
04033F             0538*  ; home the cursor
04033F             0539*      ; call vdu_home_cursor
04033F             0540*      ; call printNewLine
04033F             0541*  
04033F             0542*  ; print each register
04033F 21 C1 03 04 0543*      ld hl,str_afu
040343 CD 5C 00 04 0544*      call printString
040347 2A 3B 04 04 0545*      ld hl,(uaf)
04034B CD 7C 00 04 0546*      call printHex24
04034F             0547*      ; call printNewLine
04034F             0548*  
04034F 21 C6 03 04 0549*      ld hl,str_hlu
040353 CD 5C 00 04 0550*      call printString
040357 2A 3E 04 04 0551*      ld hl,(uhl)
04035B CD 7C 00 04 0552*      call printHex24
04035F             0553*      ; call printNewLine
04035F             0554*  
04035F 21 CB 03 04 0555*      ld hl,str_bcu
040363 CD 5C 00 04 0556*      call printString
040367 2A 41 04 04 0557*      ld hl,(ubc)
04036B CD 7C 00 04 0558*      call printHex24
04036F             0559*      ; call printNewLine
04036F             0560*  
04036F 21 D0 03 04 0561*      ld hl,str_deu
040373 CD 5C 00 04 0562*      call printString
040377 2A 44 04 04 0563*      ld hl,(ude)
04037B CD 7C 00 04 0564*      call printHex24
04037F             0565*      ; call printNewLine
04037F             0566*  
04037F 21 D5 03 04 0567*      ld hl,str_ixu
040383 CD 5C 00 04 0568*      call printString
040387 2A 47 04 04 0569*      ld hl,(uix)
04038B CD 7C 00 04 0570*      call printHex24
04038F             0571*      ; call printNewLine
04038F             0572*  
04038F 21 DA 03 04 0573*      ld hl,str_iyu
040393 CD 5C 00 04 0574*      call printString
040397 2A 4A 04 04 0575*      ld hl,(uiy)
04039B CD 7C 00 04 0576*      call printHex24
04039F             0577*      ; call printNewLine
04039F             0578*  
04039F CD 5C 07 04 0579*      call vdu_vblank
0403A3             0580*  
0403A3 CD 71 00 04 0581*      call printNewLine
0403A7             0582*  ; restore everything
0403A7 2A 3E 04 04 0583*      ld hl, (uhl)
0403AB ED 4B 41 04 0584*      ld bc, (ubc)
       04          
0403B0 ED 5B 44 04 0585*      ld de, (ude)
       04          
0403B5 DD 2A 47 04 0586*      ld ix, (uix)
       04          
0403BA FD 2A 4A 04 0587*      ld iy, (uiy)
       04          
0403BF F1          0588*      pop af
0403C0             0589*  ; all done
0403C0 C9          0590*      ret
0403C1             0591*  
0403C1 20 61 66 3D 0592*  str_afu: db " af=",0
       00          
0403C6 20 68 6C 3D 0593*  str_hlu: db " hl=",0
       00          
0403CB 20 62 63 3D 0594*  str_bcu: db " bc=",0
       00          
0403D0 20 64 65 3D 0595*  str_deu: db " de=",0
       00          
0403D5 20 69 78 3D 0596*  str_ixu: db " ix=",0
       00          
0403DA 20 69 79 3D 0597*  str_iyu: db " iy=",0
       00          
0403DF             0598*  
0403DF             0599*  ; print udeuhl to screen in hexidecimal format
0403DF             0600*  ; inputs: none
0403DF             0601*  ; outputs: concatenated hexidecimal udeuhl
0403DF             0602*  ; destroys: nothing
0403DF             0603*  dumpUDEUHLHex:
0403DF             0604*  ; store everything in scratch
0403DF 22 3E 04 04 0605*      ld (uhl),hl
0403E3 ED 43 41 04 0606*      ld (ubc),bc
       04          
0403E8 ED 53 44 04 0607*      ld (ude),de
       04          
0403ED DD 22 47 04 0608*      ld (uix),ix
       04          
0403F2 FD 22 4A 04 0609*      ld (uiy),iy
       04          
0403F7 F5          0610*      push af
0403F8             0611*  
0403F8             0612*  ; print each register
0403F8             0613*  
0403F8 21 32 04 04 0614*      ld hl,str_udeuhl
0403FC CD 5C 00 04 0615*      call printString
040400 2A 44 04 04 0616*      ld hl,(ude)
040404 CD 7C 00 04 0617*      call printHex24
040408 3E 2E       0618*  	ld a,'.'	; print a dot to separate the values
04040A 5B D7       0619*  	rst.lil 10h
04040C 2A 3E 04 04 0620*      ld hl,(uhl)
040410 CD 7C 00 04 0621*      call printHex24
040414 CD 71 00 04 0622*      call printNewLine
040418             0623*  
040418             0624*  ; restore everything
040418 2A 3E 04 04 0625*      ld hl, (uhl)
04041C ED 4B 41 04 0626*      ld bc, (ubc)
       04          
040421 ED 5B 44 04 0627*      ld de, (ude)
       04          
040426 DD 2A 47 04 0628*      ld ix, (uix)
       04          
04042B FD 2A 4A 04 0629*      ld iy, (uiy)
       04          
040430 F1          0630*      pop af
040431             0631*  ; all done
040431 C9          0632*      ret
040432             0633*  
040432 75 64 65 2E 0634*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04043B             0635*  
04043B             0636*  ; global scratch memory for registers
04043B 00 00 00    0637*  uaf: dl 0
04043E 00 00 00    0638*  uhl: dl 0
040441 00 00 00    0639*  ubc: dl 0
040444 00 00 00    0640*  ude: dl 0
040447 00 00 00    0641*  uix: dl 0
04044A 00 00 00    0642*  uiy: dl 0
04044D 00 00 00    0643*  usp: dl 0
040450 00 00 00    0644*  upc: dl 0
040453             0645*  
040453             0646*  ; inputs: whatever is in the flags register
040453             0647*  ; outputs: binary representation of flags
040453             0648*  ;          with a header so we know which is what
040453             0649*  ; destroys: nothing
040453             0650*  ; preserves: everything
040453             0651*  dumpFlags:
040453             0652*  ; first we curse zilog for not giving direct access to flags
040453 F5          0653*      push af ; this is so we can send it back unharmed
040454 F5          0654*      push af ; this is so we can pop it to hl
040455             0655*  ; store everything in scratch
040455 22 3E 04 04 0656*      ld (uhl),hl
040459 ED 43 41 04 0657*      ld (ubc),bc
       04          
04045E ED 53 44 04 0658*      ld (ude),de
       04          
040463 DD 22 47 04 0659*      ld (uix),ix
       04          
040468 FD 22 4A 04 0660*      ld (uiy),iy
       04          
04046D             0661*  ; next we print the header
04046D 21 99 04 04 0662*      ld hl,@header
040471 CD 5C 00 04 0663*      call printString
040475 E1          0664*      pop hl ; flags are now in l
040476 7D          0665*      ld a,l ; flags are now in a
040477 CD 07 02 04 0666*      call printBin8
04047B CD 71 00 04 0667*  	call printNewLine
04047F             0668*  ; restore everything
04047F 2A 3E 04 04 0669*      ld hl, (uhl)
040483 ED 4B 41 04 0670*      ld bc, (ubc)
       04          
040488 ED 5B 44 04 0671*      ld de, (ude)
       04          
04048D DD 2A 47 04 0672*      ld ix, (uix)
       04          
040492 FD 2A 4A 04 0673*      ld iy, (uiy)
       04          
040497 F1          0674*      pop af ; send her home the way she came
040498 C9          0675*      ret
040499             0676*  ; Bit 7 (S): Sign flag
040499             0677*  ; Bit 6 (Z): Zero flag
040499             0678*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
040499             0679*  ; Bit 4 (H): Half Carry flag
040499             0680*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
040499             0681*  ; Bit 2 (PV): Parity/Overflow flag
040499             0682*  ; Bit 1 (N): Subtract flag
040499             0683*  ; Bit 0 (C): Carry flag
040499 53 5A 78 48 0684*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0404A4             0685*  
0404A4             0686*  ; set all the bits in the flag register
0404A4             0687*  ; more of an academic exercise than anything useful
0404A4             0688*  ; inputs; none
0404A4             0689*  ; outputs; a=0,f=255
0404A4             0690*  ; destroys: flags, hl
0404A4             0691*  ; preserves: a, because why not
0404A4             0692*  setAllFlags:
0404A4 21 FF 00 00 0693*      ld hl,255
0404A8 67          0694*      ld h,a ; four cycles to preserve a is cheap
0404A9 E5          0695*      push hl
0404AA F1          0696*      pop af
0404AB C9          0697*      ret
0404AC             0698*  
0404AC             0699*  ; reset all the bits in the flag register
0404AC             0700*  ; unlike its inverse counterpart, this may actually be useful
0404AC             0701*  ; inputs; none
0404AC             0702*  ; outputs; a=0,f=0
0404AC             0703*  ; destroys: flags, hl
0404AC             0704*  ; preserves: a, because why not
0404AC             0705*  resetAllFlags:
0404AC 21 00 00 00 0706*      ld hl,0
0404B0 67          0707*      ld h,a ; four cycles to preserve a is cheap
0404B1 E5          0708*      push hl
0404B2 F1          0709*      pop af
0404B3 C9          0710*      ret
0404B4             0711*  
0404B4             0712*  ; wait until user presses a key
0404B4             0713*  ; inputs: none
0404B4             0714*  ; outputs: none
0404B4             0715*  ; destroys: af,ix
0404B4             0716*  waitKeypress:
0404B4             0717*      MOSCALL mos_sysvars
0404B4 3E 08       0001*M 			LD	A, function
0404B6 5B CF       0002*M 			RST.L	08h
0404B8 AF          0718*      xor a ; zero out any prior keypresses
0404B9 DD 77 05    0719*      ld (ix+sysvar_keyascii),a
0404BC             0720*  @loop:
0404BC DD 7E 05    0721*      ld a,(ix+sysvar_keyascii)
0404BF A7          0722*      and a
0404C0 C0          0723*      ret nz
0404C1 18 F9       0724*      jr @loop
0404C3             0725*  
0404C3             0726*  
0404C3             0727*  ; print bytes from an address to the screen in hexidecimal format
0404C3             0728*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0404C3             0729*  ; outputs: values of each byte printed to screen separated by spaces
0404C3             0730*  ; destroys: nothing
0404C3             0731*  dumpMemoryHex:
0404C3             0732*  ; save registers to the stack
0404C3 C5          0733*      push bc
0404C4 E5          0734*      push hl
0404C5 F5          0735*      push af
0404C6             0736*  
0404C6             0737*  ; print the address and separator
0404C6 CD 7C 00 04 0738*      call printHex24
0404CA 3E 3A       0739*      ld a,':'
0404CC 5B D7       0740*      rst.lil 10h
0404CE 3E 20       0741*      ld a,' '
0404D0 5B D7       0742*      rst.lil 10h
0404D2             0743*  
0404D2             0744*  ; set b to be our loop counter
0404D2 F1          0745*      pop af
0404D3 47          0746*      ld b,a
0404D4 E1          0747*      pop hl
0404D5 E5          0748*      push hl
0404D6 F5          0749*      push af
0404D7             0750*  @loop:
0404D7             0751*  ; print the byte
0404D7 7E          0752*      ld a,(hl)
0404D8 CD 8E 00 04 0753*      call printHex8
0404DC             0754*  ; print a space
0404DC 3E 20       0755*      ld a,' '
0404DE 5B D7       0756*      rst.lil 10h
0404E0 23          0757*      inc hl
0404E1 10 F4       0758*      djnz @loop
0404E3             0759*      ; call printNewLine
0404E3             0760*  
0404E3             0761*  ; restore everything
0404E3 F1          0762*      pop af
0404E4 E1          0763*      pop hl
0404E5 C1          0764*      pop bc
0404E6             0765*  
0404E6             0766*  ; all done
0404E6 C9          0767*      ret
0404E7             0768*  
0404E7             0769*  
0404E7             0770*  ; print bytes from an address to the screen in binary format
0404E7             0771*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0404E7             0772*  ; outputs: values of each byte printed to screen separated by spaces
0404E7             0773*  ; destroys: nothing
0404E7             0774*  dumpMemoryBin:
0404E7             0775*  ; save all registers to the stack
0404E7 F5          0776*      push af
0404E8 C5          0777*      push bc
0404E9 D5          0778*      push de
0404EA E5          0779*      push hl
0404EB DD E5       0780*      push ix
0404ED FD E5       0781*      push iy
0404EF             0782*  
0404EF             0783*  ; set b to be our loop counter
0404EF 47          0784*      ld b,a
0404F0             0785*  @loop:
0404F0             0786*  ; print the byte
0404F0 7E          0787*      ld a,(hl)
0404F1 E5          0788*      push hl
0404F2 C5          0789*      push bc
0404F3 CD 07 02 04 0790*      call printBin8
0404F7 C1          0791*      pop bc
0404F8             0792*  ; print a space
0404F8 3E 20       0793*      ld a,' '
0404FA 5B D7       0794*      rst.lil 10h
0404FC E1          0795*      pop hl
0404FD 23          0796*      inc hl
0404FE 10 F0       0797*      djnz @loop
040500 CD 71 00 04 0798*      call printNewLine
040504             0799*  
040504             0800*  ; restore everything
040504 FD E1       0801*      pop iy
040506 DD E1       0802*      pop ix
040508 E1          0803*      pop hl
040509 D1          0804*      pop de
04050A C1          0805*      pop bc
04050B F1          0806*      pop af
04050C             0807*  ; all done
04050C C9          0808*      ret
04050D             0809*  
04050D             0810*  ; print bytes from an address to the screen in binary format
04050D             0811*  ; with the bits of each byte in reverse order (lsb first)
04050D             0812*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04050D             0813*  ; outputs: values of each byte printed to screen separated by spaces
04050D             0814*  ; destroys: nothing
04050D             0815*  dumpMemoryBinRev:
04050D             0816*  ; save all registers to the stack
04050D F5          0817*      push af
04050E C5          0818*      push bc
04050F D5          0819*      push de
040510 E5          0820*      push hl
040511 DD E5       0821*      push ix
040513 FD E5       0822*      push iy
040515             0823*  
040515             0824*  ; set b to be our loop counter
040515 47          0825*      ld b,a
040516             0826*  @loop:
040516             0827*  ; print the byte
040516 7E          0828*      ld a,(hl)
040517 E5          0829*      push hl
040518 C5          0830*      push bc
040519 CD 2C 02 04 0831*      call printBin8Rev
04051D C1          0832*      pop bc
04051E             0833*  ; print a space
04051E 3E 20       0834*      ld a,' '
040520 5B D7       0835*      rst.lil 10h
040522 E1          0836*      pop hl
040523 23          0837*      inc hl
040524 10 F0       0838*      djnz @loop
040526 CD 71 00 04 0839*      call printNewLine
04052A             0840*  
04052A             0841*  ; restore everything
04052A FD E1       0842*      pop iy
04052C DD E1       0843*      pop ix
04052E E1          0844*      pop hl
04052F D1          0845*      pop de
040530 C1          0846*      pop bc
040531 F1          0847*      pop af
040532             0848*  ; all done
040532 C9          0849*      ret
040533             0034       include "files.inc"
040533             0001*  ; load to onboard 8k sram
040533             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
040533             0035       include "timer.inc"
040533             0001*  ; Table 32. Timer Control Registers
040533             0002*  ; this constant is the base address of the timer control registers
040533             0003*  ; each timer takes three bytes:
040533             0004*  ;   0: control register
040533             0005*  ;   1: low byte of timer reset value
040533             0006*  ;   2: high byte of timer reset value
040533             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
040533             0008*  ; which correctly force the high and upper bytes of the address bus to zero
040533             0009*  TMR_CTL:     equ 80h
040533             0010*  
040533             0011*  ; Timer Control Register Bit Definitions
040533             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
040533             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
040533             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
040533             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
040533             0016*                              ; the TMRx_CTL register is read.
040533             0017*  
040533             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
040533             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
040533             0020*  
040533             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
040533             0022*                              ;  0,and counting stops when the end-of-count value is reached.
040533             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
040533             0024*                              ; written to the counter when the end-of-count value is reached.
040533             0025*  
040533             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
040533             0027*  CLK_DIV_256:  equ %00001100 ;
040533             0028*  CLK_DIV_64:   equ %00001000 ;
040533             0029*  CLK_DIV_16:   equ %00000100 ;
040533             0030*  CLK_DIV_4:    equ %00000000 ;
040533             0031*  
040533             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
040533             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
040533             0034*                              ; When a 1 is written to this bit,the values in the reload registers
040533             0035*                              ;  are loaded into the downcounter when the timer restarts. The
040533             0036*                              ; programmer must ensure that this bit is set to 1 each time
040533             0037*                              ; SINGLE-PASS mode is used.
040533             0038*  
040533             0039*  ; disable/enable the programmable reload timer
040533             0040*  PRT_EN_0:     equ %00000000 ;
040533             0041*  PRT_EN_1:     equ %00000001 ;
040533             0042*  
040533             0043*  ; Table 37. Timer Input Source Select Register
040533             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
040533             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
040533             0046*  ;   00: System clock / CLK_DIV
040533             0047*  ;   01: RTC / CLK_DIV
040533             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
040533             0049*  ;   10: GPIO port B pin 1.
040533             0050*  ;   11: GPIO port B pin 1.
040533             0051*  TMR_ISS:   equ 92h ; register address
040533             0052*  
040533             0053*  ; Table 51. Real-Time Clock Control Register
040533             0054*  RTC_CTRL: equ EDh ; register address
040533             0055*  
040533             0056*  ; alarm interrupt disable/enable
040533             0057*  RTC_ALARM_0:    equ %00000000
040533             0058*  RTC_ALARM_1:    equ %10000000
040533             0059*  
040533             0060*  ; interrupt on alarm disable/enable
040533             0061*  RTC_INT_ENT_0:  equ %00000000
040533             0062*  RTC_INT_ENT_1:  equ %01000000
040533             0063*  
040533             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
040533             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
040533             0066*  
040533             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
040533             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
040533             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
040533             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
040533             0071*  
040533             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
040533             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
040533             0074*  
040533             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
040533             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
040533             0077*  
040533             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
040533             0079*                                  ; RTC counter is enabled.
040533             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
040533             0081*                                  ; RTC counter is disabled.
040533             0082*  
040533             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
040533             0084*  
040533             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
040533             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
040533 00 00 00    0087*  prt_reload: dl 0x000000
040536             0088*  
040536             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
040536             0090*  ; ;          de = number PRT interrupts during test interval
040536             0091*  ; prt_calibrate:
040536             0092*  ;     call vdu_vblank
040536             0093*  ; ; set a MOS timer
040536             0094*  ;     ld hl,120*1 ; 1 second
040536             0095*  ;     ld iy,tmr_test
040536             0096*  ;     call tmr_set
040536             0097*  ; ; set a PRT timer
040536             0098*  ;     ; ld hl,prt_reload_hardware
040536             0099*  ;     ; ld hl,prt_reload_emulator
040536             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
040536             0101*  ;     ld (prt_reload),hl
040536             0102*  ;     call prt_set
040536             0103*  ; @loop:
040536             0104*  ; ; check time remaining on MOS timer
040536             0105*  ;     call tmr_get
040536             0106*  ;     jp z,@done ; time expired,so quit
040536             0107*  ;     jp m,@done ; time past expiration (negative),so quit
040536             0108*  ;     jr @loop
040536             0109*  ; @done:
040536             0110*  ;     ld de,(prt_irq_counter)
040536             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
040536             0112*  ;     ld (prt_reload),bc
040536             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
040536             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
040536             0115*  ;     ld (is_emulator),a
040536             0116*  ;     sbc hl,de
040536             0117*  ;     ld hl,on_hardware ; default message for running on hardware
040536             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
040536             0119*  ;     ret m ; negative result means we're on hardware
040536             0120*  ;     inc a ; we're on emulator
040536             0121*  ;     ld (is_emulator),a
040536             0122*  ;     ld bc,prt_reload_emulator
040536             0123*  ;     ld (prt_reload),bc
040536             0124*  ;     ld hl,on_emulator
040536             0125*  ;     ret
040536             0126*  
040536             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
040536             0128*  
040536             0129*  ; set PRT timer
040536             0130*  prt_set:
040536 21 00 00 00 0131*      ld hl,0
04053A 22 84 05 04 0132*      ld (prt_irq_counter),hl
04053E 2A 33 05 04 0133*      ld hl,(prt_reload)
040542 ED 29 84    0134*      out0 ($84),l
040545 ED 21 85    0135*  	out0 ($85),h
040548             0136*  ; disable timer
040548 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
04054A ED 39 83    0138*  	out0 ($83),a
04054D             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04054D 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04054F ED 39 83    0141*  	out0 ($83),a
040552 C9          0142*      ret
040553             0143*  
040553             0144*  ; ===============================================
040553             0145*  ; PRT Timer Interrupt Handling
040553             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
040553             0147*  ; -----------------------------------------------
040553             0148*  prt_irq_init:
040553             0149*      ; set up interrupt vector table 2
040553 21 00 00 00 0150*  	ld hl,0
040557 3A 0C 01 00 0151*  	ld a,($10c)
04055B 6F          0152*  	ld l,a
04055C 3A 0D 01 00 0153*  	ld a,($10d)
040560 67          0154*  	ld h,a
040561             0155*  
040561             0156*  	; skip over CALL ($c3)
040561 23          0157*  	inc hl
040562             0158*  	; load address of jump into vector table 2 (in ram)
040562 ED 27       0159*  	ld hl,(hl)
040564             0160*  
040564             0161*  	; write CALL prt_irq_handler to vector table 2
040564 3E C3       0162*  	ld a,$c3
040566 77          0163*  	ld (hl),a
040567 23          0164*  	inc hl
040568 11 6F 05 04 0165*  	ld de,prt_irq_handler
04056C ED 1F       0166*  	ld (hl),de
04056E             0167*  
04056E C9          0168*      ret
04056F             0169*  
04056F             0170*  prt_irq_handler:
04056F F3          0171*  	di
040570 F5          0172*  	push af
040571 E5          0173*      push hl
040572 ED 38 83    0174*  	in0 a,($83)
040575 2A 84 05 04 0175*  	ld hl,(prt_irq_counter)
040579 23          0176*  	inc hl
04057A 22 84 05 04 0177*  	ld (prt_irq_counter),hl
04057E E1          0178*      pop hl
04057F F1          0179*  	pop af
040580 FB          0180*  	ei
040581 5B ED 4D    0181*  	reti.l
040584             0182*  
040584             0183*  prt_irq_counter:
040584 00 00 00    0184*  	.dl 0
040587             0185*  prt_irq_counter_saved:
040587 00 00 00    0186*      .dl 0
04058A             0187*  
04058A             0188*  prt_loop_reset:
04058A E5          0189*      push hl
04058B 21 00 00 00 0190*  	ld hl,0
04058F 22 84 05 04 0191*  	ld (prt_irq_counter),hl
040593 22 F5 05 04 0192*      ld (prt_loop_counter),hl
040597 22 F8 05 04 0193*      ld (prt_loops),hl
04059B CD 36 05 04 0194*      call prt_set
04059F E1          0195*      pop hl
0405A0 C9          0196*      ret
0405A1             0197*  
0405A1             0198*  prt_loop_start:
0405A1 E5          0199*      push hl
0405A2 21 00 00 00 0200*  	ld hl,0
0405A6 22 84 05 04 0201*  	ld (prt_irq_counter),hl
0405AA E1          0202*      pop hl
0405AB C9          0203*      ret
0405AC             0204*  
0405AC             0205*  prt_loop_stop:
0405AC E5          0206*      push hl
0405AD D5          0207*      push de
0405AE 2A 84 05 04 0208*      ld hl,(prt_irq_counter)
0405B2 ED 5B F5 05 0209*      ld de,(prt_loop_counter)
       04          
0405B7 19          0210*      add hl,de
0405B8 22 F5 05 04 0211*      ld (prt_loop_counter),hl
0405BC 21 00 00 00 0212*      ld hl,0
0405C0 22 84 05 04 0213*      ld (prt_irq_counter),hl
0405C4 2A F8 05 04 0214*      ld hl,(prt_loops)
0405C8 23          0215*      inc hl
0405C9 22 F8 05 04 0216*      ld (prt_loops),hl
0405CD D1          0217*      pop de
0405CE E1          0218*      pop hl
0405CF C9          0219*      ret
0405D0             0220*  
0405D0             0221*  ; inputs: bc = y,x text coordinates to print
0405D0             0222*  prt_loop_print:
0405D0 F5          0223*      push af
0405D1 E5          0224*      push hl
0405D2 C5          0225*      push bc
0405D3 D5          0226*      push de
0405D4 DD E5       0227*      push ix
0405D6 FD E5       0228*      push iy
0405D8 CD ED 06 04 0229*      call vdu_move_cursor
0405DC             0230*  
0405DC 2A F5 05 04 0231*      ld hl,(prt_loop_counter)
0405E0 CD F5 00 04 0232*      call printDec
0405E4             0233*  
0405E4 2A F8 05 04 0234*      ld hl,(prt_loops)
0405E8 CD F5 00 04 0235*      call printDec
0405EC             0236*  
0405EC FD E1       0237*      pop iy
0405EE DD E1       0238*      pop ix
0405F0 D1          0239*      pop de
0405F1 C1          0240*      pop bc
0405F2 E1          0241*      pop hl
0405F3 F1          0242*      pop af
0405F4 C9          0243*      ret
0405F5             0244*  
0405F5             0245*  prt_loop_counter:
0405F5 00 00 00    0246*      .dl 0
0405F8             0247*  prt_loops:
0405F8 00 00 00    0248*      .dl 0
0405FB             0249*  
0405FB             0250*  ; ===============================================
0405FB             0251*  ; Timer functions
0405FB             0252*  ; -----------------------------------------------
0405FB             0253*  ; set a countdown timer
0405FB             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0405FB             0255*  ; returns: hl = current time
0405FB             0256*  tmr_set:
0405FB FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0405FE             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0405FE 3E 08       0001*M 			LD	A, function
040600 5B CF       0002*M 			RST.L	08h
040602 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
040605 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
040608 C9          0261*      ret
040609             0262*  
040609             0263*  ; gets time remaining on a countdown timer
040609             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040609             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
040609             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
040609             0267*  tmr_get:
040609             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
040609 3E 08       0001*M 			LD	A, function
04060B 5B CF       0002*M 			RST.L	08h
04060D DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
040610 FD 27 00    0270*      ld hl,(iy+0)            ; get start time
040613 AF          0271*      xor a                   ; clear carry
040614 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
040616 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
040619 AF          0274*      xor a                   ; clear carry
04061A ED 5A       0275*      adc hl,de               ; hl = time remaining
04061C             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04061C C9          0277*      ret
04061D             0278*  
04061D 00 00 00    0279*  timestamp_now: dl 0
040620 00 00 00    0280*  timestamp_old: dl 0
040623 00 00 00    0281*  timestamp_chg: dl 0
040626             0282*  
040626             0283*  ; update the global timestamp from the system clock
040626             0284*  ; inputs: none
040626             0285*  ; returns: hl = time elapsed in 1/120ths of a second
040626             0286*  ;          de = current time
040626             0287*  ;          ix = pointer to syvars table
040626             0288*  ; destroys: af,hl,de,ix
040626             0289*  timestamp_tick:
040626 ED 5B 1D 06 0290*      ld de,(timestamp_now)   ; get previous time
       04          
04062B ED 53 20 06 0291*      ld (timestamp_old),de   ; save previous time
       04          
040630             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
040630 3E 08       0001*M 			LD	A, function
040632 5B CF       0002*M 			RST.L	08h
040634 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
040637 22 1D 06 04 0294*      ld (timestamp_now),hl   ; save current time
04063B AF          0295*      xor a                   ; clear carry
04063C ED 52       0296*      sbc hl,de               ; hl = time elapsed
04063E 22 23 06 04 0297*      ld (timestamp_chg),hl   ; save elapsed time
040642 C9          0298*      ret
040643             0299*  
040643             0300*  ; set a countdown timer
040643             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040643             0302*  ; requires: timestamp_tick to be called at least once before this function
040643             0303*  ; returns: hl = current time
040643             0304*  ; destroys: hl
040643             0305*  timestamp_tmr_set:
040643 FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
040646 2A 1D 06 04 0307*      ld hl,(timestamp_now)   ; get current timestamp
04064A FD 2F 00    0308*      ld (iy+0),hl            ; set start time
04064D C9          0309*      ret
04064E             0310*  
04064E             0311*  ; gets time remaining on a countdown timer following the global timestamp
04064E             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04064E             0313*  ; requires: timestamp_tick to be called at least once before this function
04064E             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04064E             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
04064E             0316*  ; destroys: af,hl,de
04064E             0317*  timestamp_tmr_get:
04064E ED 5B 1D 06 0318*      ld de,(timestamp_now)   ; get current timestamp
       04          
040653 FD 27 00    0319*      ld hl,(iy+0)            ; get start time
040656 AF          0320*      xor a                   ; clear carry
040657 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
040659 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
04065C AF          0323*      xor a                   ; clear carry
04065D ED 5A       0324*      adc hl,de               ; hl = time remaining
04065F             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04065F C9          0326*      ret
040660             0327*  
040660             0328*  ; main loop timer functions
040660             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
040666             0330*  
040666             0331*  ; set a countdown timer for the main loop using the timestamp timer
040666             0332*  ; inputs: hl = time to set in 1/120ths of a second
040666             0333*  ; returns: hl = current time
040666             0334*  ; destroys: af,hl,de,ix,iy
040666             0335*  tmr_main_loop_set:
040666 FD 21 60 06 0336*      ld iy,tmr_main_loop
       04          
04066B FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
04066E CD 26 06 04 0338*      call timestamp_tick
040672 2A 1D 06 04 0339*      ld hl,(timestamp_now)   ; get current timestamp
040676 FD 2F 00    0340*      ld (iy+0),hl ; set start time
040679 C9          0341*      ret
04067A             0342*  
04067A             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
04067A             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04067A             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
04067A             0346*  ; destroys: af,hl,de,ix,iy
04067A             0347*  tmr_main_loop_get:
04067A CD 26 06 04 0348*      call timestamp_tick
04067E FD 21 60 06 0349*      ld iy,tmr_main_loop
       04          
040683 CD 4E 06 04 0350*      call timestamp_tmr_get
040687 C9          0351*      ret
040688             0352*  
040688             0353*  ; set a stopwatch
040688             0354*  ; returns: hl = start time
040688             0355*  ; destroys: hl,ix
040688             0356*  stopwatch_set:
040688             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
040688 3E 08       0001*M 			LD	A, function
04068A 5B CF       0002*M 			RST.L	08h
04068C DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
04068F 22 A4 06 04 0359*      ld (stopwatch_started),hl            ; set start time
040693 C9          0360*      ret
040694             0361*  
040694             0362*  ; gets time elapsed on a stopwatch
040694             0363*  ; returns: hl = time elapsed in 1/120ths of a second
040694             0364*  ; destroys: af,hl,de,ix
040694             0365*  stopwatch_get:
040694             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
040694 3E 08       0001*M 			LD	A, function
040696 5B CF       0002*M 			RST.L	08h
040698 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
04069B ED 5B A4 06 0368*      ld de,(stopwatch_started)            ; get start time
       04          
0406A0 AF          0369*      xor a                   ; clear carry
0406A1 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0406A3 C9          0371*      ret
0406A4             0372*  
0406A4             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0406A7             0374*  
0406A7             0375*  ; ------------------
0406A7             0376*  ; delay routine
0406A7             0377*  ; Author: Richard Turrnidge
0406A7             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0406A7             0379*  ; routine waits a fixed time,then returns
0406A7             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0406A7             0381*  ; eg. ld A,00000100b
0406A7             0382*  
0406A7             0383*  multiPurposeDelay:
0406A7 F5          0384*      push af
0406A8 C5          0385*      push bc
0406A9 DD E5       0386*      push ix
0406AB 47          0387*      ld b,a
0406AC 3E 08       0388*      ld a,$08
0406AE 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0406B0             0390*  
0406B0             0391*  waitLoop:
0406B0             0392*  
0406B0 DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0406B3             0394*  
0406B3             0395*                                  ;   we check if bit set is same as last time we checked.
0406B3             0396*                                  ;   bit 0 - don't use
0406B3             0397*                                  ;   bit 1 - changes 64 times per second
0406B3             0398*                                  ;   bit 2 - changes 32 times per second
0406B3             0399*                                  ;   bit 3 - changes 16 times per second
0406B3             0400*  
0406B3             0401*                                  ;   bit 4 - changes 8 times per second
0406B3             0402*                                  ;   bit 5 - changes 4 times per second
0406B3             0403*                                  ;   bit 6 - changes 2 times per second
0406B3             0404*                                  ;   bit 7 - changes 1 times per second
0406B3 A0          0405*      and b
0406B4 4F          0406*      ld c,a
0406B5 3A C6 06 04 0407*      ld a,(oldTimeStamp)
0406B9 B9          0408*      cp c                        ; is A same as last value?
0406BA 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0406BC 79          0410*      ld a,c
0406BD 32 C6 06 04 0411*      ld (oldTimeStamp),a        ; set new value
0406C1             0412*  
0406C1 DD E1       0413*      pop ix
0406C3 C1          0414*      pop bc
0406C4 F1          0415*      pop af
0406C5 C9          0416*      ret
0406C6             0417*  
0406C6 00          0418*  oldTimeStamp:   .db 00h
0406C7             0036       include "vdu.inc"
0406C7             0001*  
0406C7             0002*  ; VDU 30: Home cursor
0406C7             0003*  vdu_home_cursor:
0406C7 3E 1E       0004*      ld a,30
0406C9 5B D7       0005*  	rst.lil $10
0406CB C9          0006*  	ret
0406CC             0007*  
0406CC             0008*  cursor_on:
0406CC 21 D7 06 04 0009*  	ld hl,@cmd
0406D0 01 03 00 00 0010*  	ld bc,@end-@cmd
0406D4 5B DF       0011*  	rst.lil $18
0406D6 C9          0012*  	ret
0406D7             0013*  @cmd:
0406D7 17 01 01    0014*  	db 23,1,1
0406DA             0015*  @end:
0406DA             0016*  
0406DA             0017*  cursor_off:
0406DA 21 E5 06 04 0018*  	ld hl,@cmd
0406DE 01 03 00 00 0019*  	ld bc,@end-@cmd
0406E2 5B DF       0020*  	rst.lil $18
0406E4 C9          0021*  	ret
0406E5             0022*  @cmd:
0406E5 17 01 00    0023*  	db 23,1,0
0406E8             0024*  @end:
0406E8             0025*  
0406E8             0026*  ; VDU 9: Move cursor forward one character
0406E8             0027*  vdu_cursor_forward:
0406E8 3E 09       0028*      ld a,9
0406EA 5B D7       0029*  	rst.lil $10
0406EC C9          0030*  	ret
0406ED             0031*  
0406ED             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0406ED             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0406ED             0034*  vdu_move_cursor:
0406ED ED 43 FE 06 0035*      ld (@x0),bc
       04          
0406F2 21 FD 06 04 0036*  	ld hl,@cmd
0406F6 01 03 00 00 0037*  	ld bc,@end-@cmd
0406FA 5B DF       0038*  	rst.lil $18
0406FC C9          0039*  	ret
0406FD 1F          0040*  @cmd: 	db 31
0406FE 00          0041*  @x0:	db 0
0406FF 00          0042*  @y0: 	db 0
040700 00          0043*  @end: 	db 0 ; padding
040701             0044*  
040701             0045*  ; VDU 12: Clear text area (CLS)
040701             0046*  vdu_cls:
040701 3E 0C       0047*      ld a,12
040703 5B D7       0048*  	rst.lil $10
040705 C9          0049*  	ret
040706             0050*  
040706             0051*  vdu_flip:
040706 21 11 07 04 0052*  	ld hl,@cmd
04070A 01 03 00 00 0053*  	ld bc,@end-@cmd
04070E 5B DF       0054*  	rst.lil $18
040710 C9          0055*  	ret
040711 17 00 C3    0056*  @cmd: db 23,0,0xC3
040714             0057*  @end:
040714             0058*  
040714             0059*  ; VDU 16: Clear graphics area (CLG)
040714             0060*  vdu_clg:
040714 3E 10       0061*      ld a,16
040716 5B D7       0062*  	rst.lil $10
040718 C9          0063*  	ret
040719             0064*  
040719             0065*  ; COLOUR MODES
040719             0066*  ; Mode	Effect
040719             0067*  ; 0	Set on-screen pixel to target colour value
040719             0068*  ; 1	OR value with the on-screen pixel
040719             0069*  ; 2	AND value with the on-screen pixel
040719             0070*  ; 3	XOR value with the on-screen pixel
040719             0071*  ; 4	Invert the on-screen pixel
040719             0072*  ; 5	No operation
040719             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
040719             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
040719             0075*  
040719             0076*  ; VDU 17, colour: Define text colour (COLOUR)
040719             0077*  vdu_colour_text:
040719 32 29 07 04 0078*  	ld (@arg),a
04071D 21 28 07 04 0079*  	ld hl,@cmd
040721 01 02 00 00 0080*  	ld bc,@end-@cmd
040725 5B DF       0081*  	rst.lil $18
040727 C9          0082*  	ret
040728 11          0083*  @cmd: db 17
040729 00          0084*  @arg: db 0
04072A             0085*  @end:
04072A             0086*  
04072A             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
04072A             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
04072A             0089*  vdu_gcol:
04072A 32 3F 07 04 0090*  	ld (@mode),a
04072E 79          0091*      ld a,c
04072F 32 40 07 04 0092*      ld (@col),a
040733 21 3E 07 04 0093*  	ld hl,@cmd
040737 01 03 00 00 0094*  	ld bc,@end-@cmd
04073B 5B DF       0095*  	rst.lil $18
04073D C9          0096*  	ret
04073E 12          0097*  @cmd:  db 18
04073F 00          0098*  @mode: db 0
040740 00          0099*  @col:  db 0
040741             0100*  @end:
040741             0101*  
040741             0102*  
040741             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
040741             0104*  ; MIND THE LITTLE-ENDIANESS
040741             0105*  ; inputs: c=left,b=bottom,e=right,d=top
040741             0106*  ; outputs; nothing
040741             0107*  ; destroys: a might make it out alive
040741             0108*  vdu_set_txt_viewport:
040741 ED 43 57 07 0109*      ld (@lb),bc
       04          
040746 ED 53 59 07 0110*  	ld (@rt),de
       04          
04074B 21 56 07 04 0111*  	ld hl,@cmd
04074F 01 05 00 00 0112*  	ld bc,@end-@cmd
040753 5B DF       0113*  	rst.lil $18
040755 C9          0114*  	ret
040756 1C          0115*  @cmd:   db 28 ; set text viewport command
040757 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
040759 00 00       0117*  @rt: 	dw 0x0000 ; set by de
04075B 00          0118*  @end:   db 0x00	  ; padding
04075C             0119*  
04075C             0120*  ; Wait for VBLANK interrupt
04075C             0121*  vdu_vblank:
04075C DD E5       0122*      PUSH 	IX
04075E             0123*  	MOSCALL	mos_sysvars
04075E 3E 08       0001*M 			LD	A, function
040760 5B CF       0002*M 			RST.L	08h
040762 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
040765             0125*  @wait:
040765 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
040768 28 FB       0127*      JR	Z, @wait
04076A DD E1       0128*      POP	IX
04076C C9          0129*      RET
04076D             0130*  
04076D             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04076D             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
04076D             0133*  ; 	because we have turned off logical screen scaling
04076D             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04076D             0135*  ; outputs; nothing
04076D             0136*  ; destroys: a might make it out alive
04076D             0137*  vdu_set_gfx_viewport:
04076D ED 43 8D 07 0138*      ld (@x0),bc
       04          
040772 FD 22 8F 07 0139*      ld (@y1),iy
       04          
040777 DD 22 91 07 0140*  	ld (@x1),ix
       04          
04077C ED 53 93 07 0141*  	ld (@y0),de
       04          
040781 21 8C 07 04 0142*  	ld hl,@cmd
040785 01 09 00 00 0143*  	ld bc,@end-@cmd
040789 5B DF       0144*  	rst.lil $18
04078B C9          0145*  	ret
04078C 18          0146*  @cmd:   db 24 ; set graphics viewport command
04078D 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
04078F 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
040791 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
040793 00 00       0150*  @y0: 	dw 0x0000 ; set by de
040795 00          0151*  @end:   db 0x00	  ; padding
040796             0152*  
040796             0153*  ; SCREEN MODES
040796             0154*  ; ===============================
040796             0155*  ; Mode  Horz  Vert  Cols  Refresh
040796             0156*  ; ---   ----  ----  ----  -------
040796             0157*  ; 11    320   240   2     60hz
040796             0158*  ; 139   320   240   2     60hz
040796             0159*  ; 23    512   384   2     60hz
040796             0160*  ; 151   512   384   2     60hz
040796             0161*  ; 6     640   240   2     60hz
040796             0162*  ; 134   640   240   2     60hz
040796             0163*  ; 2     640   480   2     60hz
040796             0164*  ; 130   640   480   2     60hz
040796             0165*  ; 17    800   600   2     60hz
040796             0166*  ; 145   800   600   2     60hz
040796             0167*  ; 18    1024  768   2     60hz
040796             0168*  ; 146   1024  768   2     60hz
040796             0169*  ; ---   ----  ----  ----  -------
040796             0170*  ; 10    320   240   4     60hz
040796             0171*  ; 138   320   240   4     60hz
040796             0172*  ; 22    512   384   4     60hz
040796             0173*  ; 150   512   384   4     60hz
040796             0174*  ; 5     640   240   4     60hz
040796             0175*  ; 133   640   240   4     60hz
040796             0176*  ; 1     640   480   4     60hz
040796             0177*  ; 129   640   480   4     60hz
040796             0178*  ; 16    800   600   4     60hz
040796             0179*  ; 19    1024  768   4     60hz
040796             0180*  ; ---   ----  ----  ----  -------
040796             0181*  ; 9     320   240   16    60hz
040796             0182*  ; 137   320   240   16    60hz
040796             0183*  ; 21    512   384   16    60hz
040796             0184*  ; 149   512   384   16    60hz
040796             0185*  ; 4     640   240   16    60hz
040796             0186*  ; 132   640   240   16    60hz
040796             0187*  ; 0     640   480   16    60hz
040796             0188*  ; 7     n/a   n/a   16    60hz
040796             0189*  ; ---   ----  ----  ----  -------
040796             0190*  ; 8     320   240   64    60hz
040796             0191*  ; 136   320   240   64    60hz
040796             0192*  ; 20    512   384   64    60hz
040796             0193*  ; 3     640   240   64    60hz
040796             0194*  ; ---   ----  ----  ----  -------
040796             0195*  vdu_set_screen_mode:
040796 32 A6 07 04 0196*  	ld (@arg),a
04079A 21 A5 07 04 0197*  	ld hl,@cmd
04079E 01 02 00 00 0198*  	ld bc,@end-@cmd
0407A2 5B DF       0199*  	rst.lil $18
0407A4 C9          0200*  	ret
0407A5 16          0201*  @cmd: db 22 ; set screen mode
0407A6 00          0202*  @arg: db 0  ; screen mode parameter
0407A7             0203*  @end:
0407A7             0204*  
0407A7             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0407A7             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0407A7             0207*  ; note: default setting on boot is scaling ON
0407A7             0208*  vdu_set_scaling:
0407A7 32 B9 07 04 0209*  	ld (@arg),a
0407AB 21 B6 07 04 0210*  	ld hl,@cmd
0407AF 01 04 00 00 0211*  	ld bc,@end-@cmd
0407B3 5B DF       0212*  	rst.lil $18
0407B5 C9          0213*  	ret
0407B6 17 00 C0    0214*  @cmd: db 23,0,0xC0
0407B9 00          0215*  @arg: db 0  ; scaling on/off
0407BA             0216*  @end:
0407BA             0217*  
0407BA             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0407BA             0219*  ; inputs: hl=bufferId
0407BA             0220*  vdu_buff_select:
0407BA 22 CC 07 04 0221*  	ld (@bufferId),hl
0407BE 21 C9 07 04 0222*  	ld hl,@cmd
0407C2 01 05 00 00 0223*  	ld bc,@end-@cmd
0407C6 5B DF       0224*  	rst.lil $18
0407C8 C9          0225*  	ret
0407C9 17 1B 20    0226*  @cmd: db 23,27,0x20
0407CC 00 00       0227*  @bufferId: dw 0x0000
0407CE 00          0228*  @end: db 0x00 ; padding
0407CF             0229*  
0407CF             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0407CF             0231*  ; inputs: a=format; bc=width; de=height
0407CF             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0407CF             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0407CF             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0407CF             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0407CF             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0407CF             0237*  ; 3 	Reserved for internal use by VDP (“native” format)
0407CF             0238*  vdu_bmp_create:
0407CF ED 43 EB 07 0239*      ld (@width),bc
       04          
0407D4 ED 53 ED 07 0240*      ld (@height),de
       04          
0407D9 32 EF 07 04 0241*      ld (@fmt),a
0407DD 21 E8 07 04 0242*  	ld hl,@cmd
0407E1 01 08 00 00 0243*  	ld bc,@end-@cmd
0407E5 5B DF       0244*  	rst.lil $18
0407E7 C9          0245*  	ret
0407E8 17 1B 21    0246*  @cmd:       db 23,27,0x21
0407EB 00 00       0247*  @width:     dw 0x0000
0407ED 00 00       0248*  @height:    dw 0x0000
0407EF 00          0249*  @fmt:       db 0x00
0407F0             0250*  @end:
0407F0             0251*  
0407F0             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0407F0             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0407F0             0254*  vdu_load_img_rgba2_to_8:
0407F0             0255*  ; backup the target buffer id and image dimensions
0407F0 E5          0256*      push hl
0407F1 D5          0257*      push de
0407F2 C5          0258*      push bc
0407F3             0259*  ; load the rgba2 image to working buffer 65534
0407F3 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0407F7 CD FA 08 04 0261*  	call vdu_load_buffer_from_file
0407FB             0262*  ; restore the image dimensions and target buffer id
0407FB C1          0263*      pop bc
0407FC D1          0264*      pop de
0407FD E1          0265*      pop hl
0407FE             0266*  ; fall through to vdu_rgba2_to_8
0407FE             0267*  
0407FE             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0407FE             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0407FE             0270*  ; the "expand bitmap" command is:
0407FE             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0407FE             0272*  ; and then to reverse the byte order to fix endian-ness:
0407FE             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0407FE             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0407FE             0275*  ; VDU 23,27,&20,targetBufferID%;
0407FE             0276*  ; VDU 23,27,&21,width%;height%;0
0407FE             0277*  ; -------------------------------------------------------------------
0407FE             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0407FE             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0407FE             0280*  vdu_rgba2_to_8:
0407FE             0281*  ; load the image dimensions and buffer id parameters
0407FE ED 43 5A 08 0282*      ld (@width),bc
       04          
040803 ED 53 5C 08 0283*      ld (@height),de
       04          
040808 22 3F 08 04 0284*      ld (@bufferId0),hl
04080C 22 4C 08 04 0285*      ld (@bufferId2),hl
040810 22 55 08 04 0286*      ld (@bufferId1),hl
040814             0287*  ; clean up bytes that got stomped on by the ID loads
040814 3E 48       0288*      ld a,0x48
040816 32 41 08 04 0289*      ld (@bufferId0+2),a
04081A 3E 17       0290*      ld a,23
04081C 32 57 08 04 0291*      ld (@bufferId1+2),a
040820 3E 18       0292*      ld a,24
040822 32 4E 08 04 0293*      ld (@bufferId2+2),a
040826 AF          0294*      xor a
040827 32 5E 08 04 0295*      ld (@height+2),a
04082B             0296*  ; send the vdu command strings
04082B 21 36 08 04 0297*      ld hl,@beg
04082F 01 29 00 00 0298*      ld bc,@end-@beg
040833 5B DF       0299*      rst.lil $18
040835 C9          0300*      ret
040836             0301*  @beg:
040836             0302*  ; Command 14: Consolidate blocks in a buffer
040836             0303*  ; VDU 23, 0, &A0, bufferId; 14
040836 17 00 A0    0304*      db 23,0,0xA0
040839 FE FF       0305*      dw 65534 ; workingBufferId
04083B 0E          0306*      db 14 ; consolidate blocks
04083C             0307*  ; the "expand bitmap" command is:
04083C             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04083C 17 00 A0    0309*      db 23,0,0xA0
04083F 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
040841 48          0311*      db 0x48 ; given as decimal command 72 in the docs
040842 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
040843 FE FF       0313*      dw 65534 ; sourceBufferId
040845 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040849             0315*  ; reverse the byte order to fix endian-ness:
040849             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
040849             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040849             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040849 17 00 A0    0319*      db 23,0,0xA0
04084C 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
04084E 18          0321*      db 24 ; reverse byte order
04084F 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
040850 04 00       0323*      dw 4 ; size (4 bytes)
040852             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040852             0325*  ; VDU 23,27,&20,targetBufferID%;
040852 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
040855 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
040857             0328*  ; VDU 23,27,&21,width%;height%;0
040857 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
04085A 00 00       0330*  @width: dw 0x0000
04085C 00 00       0331*  @height: dw 0x0000
04085E 00          0332*      db 0x00 ; rgba8888 format
04085F             0333*  @end:
04085F             0334*  
04085F             0335*  ; scratch variables
04085F 00 00 00    0336*  bufferId0: dl 0x000000
040862 00 00 00    0337*  bufferId1: dl 0x000000
040865             0338*  
040865             0339*  ; load a vdu buffer from local memory
040865             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040865             0341*  vdu_load_buffer:
040865 ED 43 8E 08 0342*      ld (@length),bc
       04          
04086A D5          0343*      push de ; save data pointer
04086B             0344*  ; send the vdu command string
04086B 7D          0345*      ld a,l
04086C 32 8B 08 04 0346*      ld (@bufferId),a
040870 7C          0347*      ld a,h
040871 32 8C 08 04 0348*      ld (@bufferId+1),a
040875 21 88 08 04 0349*      ld hl,@cmd
040879 01 08 00 00 0350*      ld bc,@end-@cmd
04087D 5B DF       0351*      rst.lil $18
04087F             0352*  ; send the buffer data
04087F E1          0353*      pop hl ; pointer to data
040880 ED 4B 8E 08 0354*      ld bc,(@length)
       04          
040885 5B DF       0355*      rst.lil $18 ; send it
040887 C9          0356*      ret
040888             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
040888 17 00 A0    0358*  @cmd:       db 23,0,0xA0
04088B 00 00       0359*  @bufferId:	dw 0x0000
04088D 00          0360*  		    db 0 ; load buffer
04088E 00 00       0361*  @length:	dw 0x0000
040890 00          0362*  @end: db 0 ; padding
040891             0363*  
040891             0364*  ; clear a buffer
040891             0365*  ; inputs: hl = bufferId
040891             0366*  vdu_clear_buffer:
040891 7D          0367*      ld a,l
040892 32 A9 08 04 0368*      ld (@bufferId),a
040896 7C          0369*      ld a,h
040897 32 AA 08 04 0370*      ld (@bufferId+1),a
04089B 21 A6 08 04 0371*      ld hl,@cmd
04089F 01 06 00 00 0372*      ld bc,@end-@cmd
0408A3 5B DF       0373*      rst.lil $18
0408A5 C9          0374*      ret
0408A6 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0408A9 00 00       0376*  @bufferId:	dw 0x0000
0408AB 02          0377*  		    db 2 ; clear buffer
0408AC             0378*  @end:
0408AC             0379*  
0408AC             0380*  vdu_clear_all_buffers:
0408AC             0381*  ; clear all buffers
0408AC 21 B7 08 04 0382*      ld hl,@beg
0408B0 01 06 00 00 0383*      ld bc,@end-@beg
0408B4 5B DF       0384*      rst.lil $18
0408B6 C9          0385*      ret
0408B7 17 00 A0    0386*  @beg: db 23,0,$A0
0408BA FF FF       0387*        dw -1 ; clear all buffers
0408BC 02          0388*        db 2  ; command 2: clear a buffer
0408BD             0389*  @end:
0408BD             0390*  
0408BD             0391*  ; Command 14: Consolidate blocks in a buffer
0408BD             0392*  vdu_consolidate_buffer:
0408BD             0393*  ; set parameters for vdu call
0408BD 7D          0394*      ld a,l
0408BE 32 D5 08 04 0395*      ld (@bufferId),a
0408C2 7C          0396*      ld a,h
0408C3 32 D6 08 04 0397*      ld (@bufferId+1),a
0408C7 21 D2 08 04 0398*      ld hl,@beg
0408CB 01 06 00 00 0399*      ld bc,@end-@beg
0408CF 5B DF       0400*      rst.lil $18
0408D1 C9          0401*      ret
0408D2             0402*  ; VDU 23, 0, &A0, bufferId; 14
0408D2 17 00 A0    0403*  @beg: db 23,0,0xA0
0408D5 00 00       0404*  @bufferId: dw 0x0000
0408D7 0E          0405*             db 14
0408D8             0406*  @end:
0408D8             0407*  
0408D8             0408*  ; load an image file to a buffer and make it a bitmap
0408D8             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0408D8             0410*  vdu_load_img:
0408D8             0411*  ; back up image type and dimension parameters
0408D8 22 5F 08 04 0412*      ld (bufferId0),hl
0408DC F5          0413*      push af
0408DD C5          0414*  	push bc
0408DE D5          0415*  	push de
0408DF             0416*  ; load the image
0408DF CD FA 08 04 0417*  	call vdu_load_buffer_from_file
0408E3             0418*  ; now make it a bitmap
0408E3 2A 5F 08 04 0419*      ld hl,(bufferId0)
0408E7 CD BD 08 04 0420*      call vdu_consolidate_buffer
0408EB 2A 5F 08 04 0421*      ld hl,(bufferId0)
0408EF CD BA 07 04 0422*      call vdu_buff_select
0408F3 D1          0423*  	pop de ; image height
0408F4 C1          0424*  	pop bc ; image width
0408F5 F1          0425*  	pop af ; image type
0408F6 C3 CF 07 04 0426*  	jp vdu_bmp_create ; will return to caller from there
0408FA             0427*  
0408FA             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0408FA             0429*  vdu_load_buffer_from_file:
0408FA 22 5F 08 04 0430*      ld (bufferId0),hl
0408FE             0431*  
0408FE             0432*  ; clear target buffer
0408FE CD 91 08 04 0433*      call vdu_clear_buffer
040902             0434*  
040902             0435*  ; open the file in read mode
040902             0436*  ; Open a file
040902             0437*  ; HLU: Filename
040902             0438*  ;   C: Mode
040902             0439*  ; Returns:
040902             0440*  ;   A: Filehandle, or 0 if couldn't open
040902 FD E5       0441*  	push iy ; pointer to filename
040904 E1          0442*  	pop hl
040905 0E 01       0443*  	ld c,fa_read
040907             0444*      MOSCALL mos_fopen
040907 3E 0A       0001*M 			LD	A, function
040909 5B CF       0002*M 			RST.L	08h
04090B 32 46 09 04 0445*      ld (@filehandle),a
04090F             0446*  
04090F             0447*  @read_file:
04090F             0448*  ; Read a block of data from a file
04090F             0449*  ;   C: Filehandle
04090F             0450*  ; HLU: Pointer to where to write the data to
04090F             0451*  ; DEU: Number of bytes to read
04090F             0452*  ; Returns:
04090F             0453*  ; DEU: Number of bytes read
04090F 3A 46 09 04 0454*      ld a,(@filehandle)
040913 4F          0455*      ld c,a
040914 21 00 E0 B7 0456*      ld hl,filedata
040918 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
04091C             0458*      MOSCALL mos_fread
04091C 3E 1A       0001*M 			LD	A, function
04091E 5B CF       0002*M 			RST.L	08h
040920             0459*  
040920             0460*  ; ; DEBUG: print chunk size
040920             0461*  ;     push de
040920             0462*  ;     pop hl
040920             0463*  ;     call printDec
040920             0464*  ;     call printNewLine
040920             0465*  
040920             0466*  ; test de for zero bytes read
040920 21 00 00 00 0467*      ld hl,0
040924 AF          0468*      xor a ; clear carry
040925 ED 52       0469*      sbc hl,de
040927 CA 3D 09 04 0470*      jp z,@close_file
04092B             0471*  
04092B             0472*  ; load a vdu buffer from local memory
04092B             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04092B 2A 5F 08 04 0474*      ld hl,(bufferId0)
04092F D5          0475*      push de ; chunksize
040930 C1          0476*      pop bc
040931 11 00 E0 B7 0477*      ld de,filedata
040935 CD 65 08 04 0478*      call vdu_load_buffer
040939             0479*  
040939             0480*  ; ; print progress breadcrumbs
040939             0481*  ;     ld a,'.'
040939             0482*  ;     rst.lil 10h
040939             0483*  
040939             0484*  ; read the next block
040939 C3 0F 09 04 0485*      jp @read_file
04093D             0486*  
04093D             0487*  ; close the file
04093D             0488*  @close_file:
04093D 3A 46 09 04 0489*      ld a,(@filehandle)
040941             0490*      MOSCALL mos_fclose
040941 3E 0B       0001*M 			LD	A, function
040943 5B CF       0002*M 			RST.L	08h
040945 C9          0491*      ret ; vdu_load_buffer_from_file
040946             0492*  
040946 00          0493*  @filehandle: db 0 ; file handle
040947 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
04094A             0495*  
04094A 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
04094D             0497*  
04094D             0498*  ; File information structure (FILINFO)
04094D             0499*  @filinfo:
04094D 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
040951 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
040953 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040955 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040956 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
040963 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040A63             0037       ; include "vdu_fonts.inc"
040A63             0038       include "vdu_plot.inc"
040A63             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040A63             0002*  ; PLOT code 	(Decimal) 	Effect
040A63             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
040A63             0004*  plot_sl_both: equ 0x00
040A63             0005*  
040A63             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
040A63             0007*  plot_sl_first: equ 0x08
040A63             0008*  
040A63             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
040A63             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
040A63             0011*  
040A63             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
040A63             0013*  plot_sl_last: equ 0x20
040A63             0014*  
040A63             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
040A63             0016*  plot_sl_none: equ 0x28
040A63             0017*  
040A63             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
040A63             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
040A63             0020*  
040A63             0021*  ; &40-&47 	64-71 	Point plot
040A63             0022*  plot_pt: equ 0x40
040A63             0023*  
040A63             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
040A63             0025*  plot_lf_lr_non_bg: equ 0x48
040A63             0026*  
040A63             0027*  ; &50-&57 	80-87 	Triangle fill
040A63             0028*  plot_tf: equ 0x50
040A63             0029*  
040A63             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
040A63             0031*  plot_lf_r_bg: equ 0x58
040A63             0032*  
040A63             0033*  ; &60-&67 	96-103 	Rectangle fill
040A63             0034*  plot_rf: equ 0x60
040A63             0035*  
040A63             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
040A63             0037*  plot_lf_lr_fg: equ 0x60
040A63             0038*  
040A63             0039*  ; &70-&77 	112-119 	Parallelogram fill
040A63             0040*  plot_pf: equ 0x70
040A63             0041*  
040A63             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
040A63             0043*  plot_lf_r_non_fg: equ 0x78
040A63             0044*  
040A63             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
040A63             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
040A63             0047*  
040A63             0048*  ; &90-&97 	144-151 	Circle outline
040A63             0049*  plot_co: equ 0x90
040A63             0050*  
040A63             0051*  ; &98-&9F 	152-159 	Circle fill
040A63             0052*  plot_cf: equ 0x98
040A63             0053*  
040A63             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
040A63             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
040A63             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
040A63             0057*  
040A63             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
040A63             0059*  plot_rcm: equ 0xB8
040A63             0060*  
040A63             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
040A63             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
040A63             0063*  ; &D0-&D7 	208-215 	Not defined
040A63             0064*  ; &D8-&DF 	216-223 	Not defined
040A63             0065*  ; &E0-&E7 	224-231 	Not defined
040A63             0066*  
040A63             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
040A63             0068*  plot_bmp: equ 0xE8
040A63             0069*  
040A63             0070*  ; &F0-&F7 	240-247 	Not defined
040A63             0071*  ; &F8-&FF 	248-255 	Not defined
040A63             0072*  
040A63             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
040A63             0074*  ; Agon Console8 VDP 2.2.0
040A63             0075*  
040A63             0076*  ; Within each group of eight plot codes, the effects are as follows:
040A63             0077*  ; Plot code 	Effect
040A63             0078*  ; 0 	Move relative
040A63             0079*  mv_rel: equ 0
040A63             0080*  
040A63             0081*  ; 1 	Plot relative in current foreground colour
040A63             0082*  dr_rel_fg: equ 1
040A63             0083*  
040A63             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
040A63             0085*  ; 3 	Plot relative in current background colour
040A63             0086*  dr_rel_bg: equ 3
040A63             0087*  
040A63             0088*  ; 4 	Move absolute
040A63             0089*  mv_abs: equ 4
040A63             0090*  
040A63             0091*  ; 5 	Plot absolute in current foreground colour
040A63             0092*  dr_abs_fg: equ 5
040A63             0093*  
040A63             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
040A63             0095*  ; 7 	Plot absolute in current background colour
040A63             0096*  dr_abs_bg: equ 7
040A63             0097*  
040A63             0098*  ; Codes 0-3 use the position data provided as part of the command
040A63             0099*  ; as a relative position, adding the position given to the current
040A63             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
040A63             0101*  ; as part of the command as an absolute position, setting the current
040A63             0102*  ; graphical cursor position to the position given.
040A63             0103*  
040A63             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
040A63             0105*  ; current pixel colour. These operations cannot currently be supported
040A63             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
040A63             0107*  ; supported. Support for these codes may be added in a future version
040A63             0108*  ; of the VDP firmware.
040A63             0109*  
040A63             0110*  ; 16 colour palette constants
040A63             0111*  c_black: equ 0
040A63             0112*  c_red_dk: equ 1
040A63             0113*  c_green_dk: equ 2
040A63             0114*  c_yellow_dk: equ 3
040A63             0115*  c_blue_dk: equ 4
040A63             0116*  c_magenta_dk: equ 5
040A63             0117*  c_cyan_dk: equ 6
040A63             0118*  c_grey: equ 7
040A63             0119*  c_grey_dk: equ 8
040A63             0120*  c_red: equ 9
040A63             0121*  c_green: equ 10
040A63             0122*  c_yellow: equ 11
040A63             0123*  c_blue: equ 12
040A63             0124*  c_magenta: equ 13
040A63             0125*  c_cyan: equ 14
040A63             0126*  c_white: equ 15
040A63             0127*  
040A63             0128*  ; VDU 25, mode, x; y;: PLOT command
040A63             0129*  ; inputs: a=mode, bc=x0, de=y0
040A63             0130*  vdu_plot:
040A63 32 7D 0A 04 0131*      ld (@mode),a
040A67 ED 43 7E 0A 0132*      ld (@x0),bc
       04          
040A6C ED 53 80 0A 0133*      ld (@y0),de
       04          
040A71 21 7C 0A 04 0134*  	ld hl,@cmd
040A75 01 06 00 00 0135*  	ld bc,@end-@cmd
040A79 5B DF       0136*  	rst.lil $18
040A7B C9          0137*  	ret
040A7C 19          0138*  @cmd:   db 25
040A7D 00          0139*  @mode:  db 0
040A7E 00 00       0140*  @x0: 	dw 0
040A80 00 00       0141*  @y0: 	dw 0
040A82 00          0142*  @end:   db 0 ; extra byte to soak up deu
040A83             0143*  
040A83             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040A83             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
040A83             0146*  ; VDU 25, mode, x; y;: PLOT command
040A83             0147*  ; inputs: bc=x0, de=y0
040A83             0148*  ; prerequisites: vdu_buff_select
040A83             0149*  vdu_plot_bmp:
040A83 ED 43 9A 0A 0150*      ld (@x0),bc
       04          
040A88 ED 53 9C 0A 0151*      ld (@y0),de
       04          
040A8D 21 98 0A 04 0152*  	ld hl,@cmd
040A91 01 06 00 00 0153*  	ld bc,@end-@cmd
040A95 5B DF       0154*  	rst.lil $18
040A97 C9          0155*  	ret
040A98 19          0156*  @cmd:   db 25
040A99 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040A9A 00 00       0158*  @x0: 	dw 0x0000
040A9C 00 00       0159*  @y0: 	dw 0x0000
040A9E 00          0160*  @end:   db 0x00 ; padding
040A9F             0161*  
040A9F             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040A9F             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
040A9F             0164*  ; VDU 25, mode, x; y;: PLOT command
040A9F             0165*  ; inputs: bc=x0, de=y0
040A9F             0166*  ; USING 16.8 FIXED POINT COORDINATES
040A9F             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040A9F             0168*  ;   the fractional portiion of the inputs are truncated
040A9F             0169*  ;   leaving only the 16-bit integer portion
040A9F             0170*  ; prerequisites: vdu_buff_select
040A9F             0171*  vdu_plot_bmp168:
040A9F             0172*  ; populate in the reverse of normal to keep the
040A9F             0173*  ; inputs from stomping on each other
040A9F ED 53 BD 0A 0174*      ld (@y0-1),de
       04          
040AA4 ED 43 BB 0A 0175*      ld (@x0-1),bc
       04          
040AA9 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
040AAB 32 BB 0A 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
040AAF 21 BA 0A 04 0178*  	ld hl,@cmd
040AB3 01 06 00 00 0179*  	ld bc,@end-@cmd
040AB7 5B DF       0180*  	rst.lil $18
040AB9 C9          0181*  	ret
040ABA 19          0182*  @cmd:   db 25
040ABB ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040ABC 00 00       0184*  @x0: 	dw 0x0000
040ABE 00 00       0185*  @y0: 	dw 0x0000
040AC0             0186*  @end:  ; no padding required b/c we shifted de right
040AC0             0187*  
040AC0             0188*  ; draw a filled rectangle
040AC0             0189*  vdu_plot_rf:
040AC0 ED 43 E7 0A 0190*      ld (@x0),bc
       04          
040AC5 ED 53 E9 0A 0191*      ld (@y0),de
       04          
040ACA DD 22 ED 0A 0192*      ld (@x1),ix
       04          
040ACF FD 22 EF 0A 0193*      ld (@y1),iy
       04          
040AD4 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
040AD6 32 EB 0A 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040ADA 21 E5 0A 04 0196*  	ld hl,@cmd0
040ADE 01 0C 00 00 0197*  	ld bc,@end-@cmd0
040AE2 5B DF       0198*  	rst.lil $18
040AE4 C9          0199*      ret
040AE5 19          0200*  @cmd0:  db 25 ; plot
040AE6 04          0201*  @arg0:  db plot_sl_both+mv_abs
040AE7 00 00       0202*  @x0:    dw 0x0000
040AE9 00 00       0203*  @y0:    dw 0x0000
040AEB 19          0204*  @cmd1:  db 25 ; plot
040AEC 65          0205*  @arg1:  db plot_rf+dr_abs_fg
040AED 00 00       0206*  @x1:    dw 0x0000
040AEF 00 00       0207*  @y1:    dw 0x0000
040AF1 00          0208*  @end:   db 0x00 ; padding
040AF2             0209*  
040AF2             0210*  ; draw a filled circle
040AF2             0211*  vdu_plot_cf:
040AF2 ED 43 19 0B 0212*      ld (@x0),bc
       04          
040AF7 ED 53 1B 0B 0213*      ld (@y0),de
       04          
040AFC DD 22 1F 0B 0214*      ld (@x1),ix
       04          
040B01 FD 22 21 0B 0215*      ld (@y1),iy
       04          
040B06 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
040B08 32 1D 0B 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040B0C 21 17 0B 04 0218*  	ld hl,@cmd0
040B10 01 0C 00 00 0219*  	ld bc,@end-@cmd0
040B14 5B DF       0220*  	rst.lil $18
040B16 C9          0221*      ret
040B17 19          0222*  @cmd0:  db 25 ; plot
040B18 04          0223*  @arg0:  db plot_sl_both+mv_abs
040B19 00 00       0224*  @x0:    dw 0x0000
040B1B 00 00       0225*  @y0:    dw 0x0000
040B1D 19          0226*  @cmd1:  db 25 ; plot
040B1E 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
040B1F 00 00       0228*  @x1:    dw 0x0000
040B21 00 00       0229*  @y1:    dw 0x0000
040B23 00          0230*  @end:   db 0x00 ; padding
040B24             0231*  
040B24             0232*  ; VDU 25, mode, x; y;: PLOT command
040B24             0233*  ; inputs: a=mode, ix=x0, iy=y0
040B24             0234*  plot:
040B24 32 3E 0B 04 0235*      ld (@mode),a
040B28 DD 22 3F 0B 0236*      ld (@x0),ix
       04          
040B2D FD 22 41 0B 0237*      ld (@y0),iy
       04          
040B32 21 3D 0B 04 0238*  	ld hl,@cmd
040B36 01 06 00 00 0239*  	ld bc,@end-@cmd
040B3A 5B DF       0240*  	rst.lil $18
040B3C C9          0241*  	ret
040B3D 19          0242*  @cmd:   db 25
040B3E 00          0243*  @mode:  db 0
040B3F 00 00       0244*  @x0: 	dw 0
040B41 00 00       0245*  @y0: 	dw 0
040B43 00          0246*  @end:   db 0 ; padding
040B44             0247*  
040B44             0248*  ; VDU 5: Write text at graphics cursor
040B44             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
040B44             0250*  ; prerequisites: gcol foreground set, VDU 5 set
040B44             0251*  plot_text:
040B44 E5          0252*      push hl ; save text pointer
040B45             0253*  ; move graphics cursor to x0, y0
040B45 3E 44       0254*      ld a,plot_pt+mv_abs
040B47 CD 24 0B 04 0255*      call plot
040B4B             0256*  ; write text
040B4B E1          0257*      pop hl ; restore text pointer
040B4C CD 5C 00 04 0258*      call printString
040B50 C9          0259*      ret
040B51             0039   
040B51             0040   ; SHAWN'S INCLUDES
040B51             0041   	INCLUDE	"strings24.asm"
040B51             0001*  ;------------------------------------------------------------------------
040B51             0002*  ;  strings24.asm
040B51             0003*  ;
040B51             0004*  ; 24-bit native ez80 strings routines for numerical processing
040B51             0005*  ;  Copyright (c) Shawn Sijnstra 2024
040B51             0006*  ;  MIT license
040B51             0007*  ;------------------------------------------------------------------------
040B51             0008*  
040B51             0009*  ;Print signed value in HLU in decimal with leading 0s removed
040B51             0010*  ; and postpended with a minus sign if was negative
040B51             0011*  ; Uses HLU, DEU, BCU
040B51             0012*  print_HLU_s24:
040B51 CD D5 16 04 0013*  	call abs_hlu
040B55 F5          0014*  	push af ; save the sign and zero flags
040B56 CD 61 0B 04 0015*  	call print_HLU_u24
040B5A F1          0016*  	pop af
040B5B F0          0017*  	ret p ; HLU was positive so nothig more to do
040B5C 3E 2D       0018*  	ld a,'-'
040B5E 5B D7       0019*  	rst.lil 10h
040B60 C9          0020*  	ret
040B61             0021*  
040B61             0022*  ;------------------------------------------------------------------------
040B61             0023*  ;Full print and buffer routine so you can adjust behaviour
040B61             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
040B61             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
040B61             0026*  ;Print value in HLU in decimal with leading 0s removed
040B61             0027*  ; Uses HLU, DEU, BCU
040B61             0028*  ;------------------------------------------------------------------------
040B61             0029*  
040B61             0030*  print_HLU_u24:
040B61 22 3E 0C 04 0031*  	ld	(hex_temp),hl
040B65 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
040B67 11 41 0C 04 0033*  	ld	de,outbuf
040B6B D5          0034*  	push	de
040B6C 21 07 00 00 0035*  	ld	hl,7
040B70 19          0036*  	add	hl,de
040B71 E5          0037*  	push	hl
040B72 D1          0038*  	pop	de	;copy HLU to DEU
040B73 AF          0039*  	xor	a
040B74             0040*  _pde_u_zerobuf:
040B74 77          0041*  	ld	(hl),a	;zero out the output
040B75 2B          0042*  	dec	hl
040B76 10 FC       0043*  	djnz	_pde_u_zerobuf
040B78             0044*  
040B78 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
040B7A             0046*  _bcd_Convert:
040B7A             0047*  
040B7A 21 3E 0C 04 0048*  	ld hl,hex_temp
040B7E             0049*  ;
040B7E CB 26       0050*  	sla (hl)
040B80 23          0051*  	inc hl
040B81 CB 16       0052*  	rl (hl)
040B83 23          0053*  	inc hl
040B84 CB 16       0054*  	rl (hl)		;24 bits rolled right
040B86             0055*  
040B86             0056*  
040B86 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
040B88 D5          0058*  	push	de
040B89 E1          0059*  	pop	hl
040B8A             0060*  
040B8A             0061*  _bcd_Add3:
040B8A 7E          0062*  	ld	a,(hl)
040B8B 8F          0063*  	adc	a
040B8C 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
040B8D FE 10       0065*  	cp	10h	;did we roll over nibble?
040B8F 3F          0066*  	ccf
040B90 CB A7       0067*  	res	4,a
040B92             0068*  
040B92 77          0069*          ld (hl),a
040B93 2B          0070*  	dec	hl
040B94 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
040B96 0D          0072*          dec c
040B97 20 E1       0073*          jr nz, _bcd_Convert	;loop around
040B99             0074*  
040B99             0075*  
040B99 E1          0076*  	pop	hl
040B9A E5          0077*  	push	hl
040B9B 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
040B9D             0079*  _pde_u_make_ascii:
040B9D 7E          0080*  	ld	a,(hl)
040B9E B7          0081*  	or	a
040B9F 20 05       0082*  	jr	nz,_pde_u_make_ascii2
040BA1 36 20       0083*  	ld	(hl),' '
040BA3 23          0084*  	inc	hl
040BA4 10 F7       0085*  	djnz	_pde_u_make_ascii
040BA6             0086*  _pde_u_make_ascii2:
040BA6 04          0087*  	inc	b
040BA7             0088*  _pde_u_make_ascii3:
040BA7 7E          0089*  	ld	a,(hl)
040BA8 F6 30       0090*  	or	30h
040BAA 77          0091*  	ld	(hl),a
040BAB 23          0092*  	inc	hl
040BAC 10 F9       0093*  	djnz	_pde_u_make_ascii3
040BAE             0094*  
040BAE E1          0095*  	pop	hl
040BAF 06 08       0096*  	ld	b,8
040BB1             0097*  _pde_u_final_out:
040BB1 7E          0098*  	ld	a,(hl)
040BB2 23          0099*  	inc	hl
040BB3 FE 20       0100*  	cp	' '
040BB5 28 02       0101*  	jr	z,_pde_u_final_out_strip
040BB7 5B D7       0102*  	rst.lil	10h
040BB9             0103*  _pde_u_final_out_strip:
040BB9 10 F6       0104*  	djnz	_pde_u_final_out
040BBB C9          0105*  	ret
040BBC             0106*  
040BBC             0107*  ;------------------------------------------------------------------------
040BBC             0108*  ; is_digit
040BBC             0109*  ; C flag set if A is a digit
040BBC             0110*  ; preserves all registers
040BBC             0111*  ;------------------------------------------------------------------------
040BBC             0112*  is_digit:
040BBC FE 30       0113*  	cp	'0'
040BBE 3F          0114*  	ccf
040BBF D0          0115*  	ret	nc	;less that '0'
040BC0 FE 3A       0116*  	cp	'9' + 1
040BC2 C9          0117*  	ret
040BC3             0118*  
040BC3             0119*  
040BC3             0120*  ;------------------------------------------------------------------------
040BC3             0121*  ; char2hex
040BC3             0122*  ; Input: ASCII nibble in A
040BC3             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
040BC3             0124*  ;------------------------------------------------------------------------
040BC3             0125*  char2hex:
040BC3 FE 30       0126*  	CP	'0'
040BC5 38 1D       0127*  	JR	C, char_not_hex
040BC7 FE 3A       0128*  	CP	'9' + 1
040BC9 30 03       0129*  	JR	NC, char_not_09
040BCB D6 30       0130*  	sub	'0'
040BCD C9          0131*  	ret
040BCE             0132*  
040BCE             0133*  char_not_09:
040BCE             0134*  	; char is not 0 to 9. Try upper case
040BCE FE 41       0135*  	CP	'A'
040BD0 38 12       0136*  	JR	C, char_not_hex
040BD2 FE 47       0137*  	CP	'F' + 1
040BD4 30 03       0138*  	JR	NC, char_not_AF
040BD6 D6 37       0139*  	sub	'A'-10
040BD8 C9          0140*  	ret
040BD9             0141*  
040BD9             0142*  char_not_AF:
040BD9             0143*  	; char is not upper case A-F. Try lower
040BD9 FE 61       0144*  	CP	'a'
040BDB 38 07       0145*  	JR	C, char_not_hex
040BDD FE 67       0146*  	CP	'f' + 1
040BDF 30 03       0147*  	JR	NC, char_not_hex
040BE1 D6 57       0148*  	sub	'a' - 10
040BE3 C9          0149*  	RET
040BE4             0150*  
040BE4             0151*  char_not_hex:
040BE4 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
040BE6 C9          0153*  	RET
040BE7             0154*  
040BE7             0155*  ;------------------------------------------------------------------------
040BE7             0156*  ;  newline
040BE7             0157*  ;  Output CR+LF; all registers preserved
040BE7             0158*  ;------------------------------------------------------------------------
040BE7             0159*  newline:
040BE7 F5          0160*         push   AF
040BE8 3E 0D       0161*         LD     A, 13
040BEA 5B D7       0162*         RST.LIL    10h
040BEC 3E 0A       0163*         LD     A, 10
040BEE 5B D7       0164*         RST.LIL    10h
040BF0 F1          0165*         POP    AF
040BF1 C9          0166*         RET
040BF2             0167*  
040BF2             0168*  ;------------------------------------------------------------------------
040BF2             0169*  ;  put_nibble
040BF2             0170*  ;  Output a single hex nibble in A
040BF2             0171*  ;  All registers preserved
040BF2             0172*  ;------------------------------------------------------------------------
040BF2             0173*  put_nibble:
040BF2 F5          0174*  	push   AF
040BF3 C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
040BF5 27          0176*  	daa
040BF6 CE 40       0177*  	adc    a,040h
040BF8 27          0178*  	daa
040BF9 5B D7       0179*  	RST.LIL    10h	;output character in A
040BFB F1          0180*  	pop    AF
040BFC C9          0181*  	ret
040BFD             0182*  
040BFD             0183*  ;------------------------------------------------------------------------
040BFD             0184*  ;  print_A
040BFD             0185*  ;  Output the 8-bit hex number A
040BFD             0186*  ;  All registers preserved
040BFD             0187*  ;------------------------------------------------------------------------
040BFD             0188*  print_A:
040BFD F5          0189*  	push 	AF
040BFE F5          0190*  	push 	AF	;save for second nibble
040BFF 0F          0191*  	rrca
040C00 0F          0192*  	rrca
040C01 0F          0193*  	rrca
040C02 0F          0194*  	rrca
040C03 E6 0F       0195*  	and	0Fh	;first nibble
040C05 CD F2 0B 04 0196*  	call	put_nibble
040C09 F1          0197*  	pop 	AF
040C0A E6 0F       0198*  	and	0Fh	;second nibble
040C0C CD F2 0B 04 0199*  	call	put_nibble
040C10 F1          0200*  	pop 	AF
040C11 C9          0201*  	ret
040C12             0202*  
040C12             0203*  ;------------------------------------------------------------------------
040C12             0204*  ;  print_HLU_hex
040C12             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
040C12             0206*  ;------------------------------------------------------------------------
040C12             0207*  print_HLU_hex:
040C12 F5          0208*         push   AF
040C13 22 3E 0C 04 0209*         ld     (hex_temp),hl
040C17 3A 40 0C 04 0210*         ld     a,(hex_temp+2)
040C1B CD FD 0B 04 0211*         call   print_A
040C1F 3A 3F 0C 04 0212*         ld     a,(hex_temp+1)
040C23 CD FD 0B 04 0213*         call   print_A
040C27 3A 3E 0C 04 0214*         ld     a,(hex_temp)
040C2B CD FD 0B 04 0215*         call   print_A
040C2F F1          0216*         POP    AF
040C30 C9          0217*         RET
040C31             0218*  
040C31             0219*  ;------------------------------------------------------------------------
040C31             0220*  ;  puts
040C31             0221*  ;  Output a zero-terminated string whose address is in HL; all
040C31             0222*  ;  registers preserved.
040C31             0223*  ;------------------------------------------------------------------------
040C31             0224*  puts:
040C31 F5          0225*         push   AF
040C32 C5          0226*         push   BC
040C33 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
040C37 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
040C39 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
040C3B C1          0230*         pop    BC
040C3C F1          0231*         pop    AF
040C3D C9          0232*         ret
040C3E             0233*  
040C3E             0234*  ;------------------------------------------------------------------------
040C3E             0235*  ; Data area
040C3E             0236*  ; Storage for 24 bit conversion
040C3E             0237*  ;------------------------------------------------------------------------
040C3E             0238*  hex_temp:
040C3E 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
040C41             0240*  
040C41             0241*  outbuf:
040C41 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
040C4A             0042   	INCLUDE	"arith24.asm"
040C4A             0001*  
040C4A             0002*  
040C4A             0003*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040C4A             0004*  ; uses EZ80 MLT instruction for speed
040C4A             0005*  ; operation: BHL * A --> ABHL
040C4A             0006*  umul824:
040C4A D5          0007*  	push de ; preserve de
040C4B             0008*  ; low byte
040C4B 5D          0009*  	ld e,l
040C4C 57          0010*  	ld d,a
040C4D ED 5C       0011*  	mlt de
040C4F 6B          0012*  	ld l,e ; product low byte
040C50 08          0013*  	ex af,af' ; save multiplier
040C51 7A          0014*  	ld a,d ; carry
040C52 08          0015*  	ex af,af' ; save carry, restore multiplier
040C53             0016*  ; high byte
040C53 5C          0017*  	ld e,h
040C54 57          0018*  	ld d,a
040C55 ED 5C       0019*  	mlt de
040C57 08          0020*  	ex af,af' ; save multiplier, restore carry
040C58 83          0021*  	add a,e ; add carry
040C59 67          0022*  	ld h,a ; product middle byte
040C5A 7A          0023*  	ld a,d ; carry
040C5B 08          0024*  	ex af,af' ; save carry, restore multiplier
040C5C             0025*  ; upper byte
040C5C 58          0026*  	ld e,b
040C5D 57          0027*  	ld d,a
040C5E ED 5C       0028*  	mlt de
040C60 08          0029*  	ex af,af' ; restore carry
040C61 8B          0030*  	adc a,e ; add carry
040C62 47          0031*  	ld b,a ; product upper byte
040C63             0032*  ; highest byte
040C63 3E 00       0033*  	ld a,0 ; preserve carry flag
040C65 8A          0034*  	adc a,d ; product highest byte
040C66 D1          0035*  	pop de ; restore de
040C67 C9          0036*  	ret
040C68             0037*  
040C68             0038*  
040C68             0039*  
040C68             0040*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040C68             0041*  ; uses EZ80 MLT instruction and shadow registers for speed
040C68             0042*  ; operation: BHL * CDE --> BHLCDE
040C68             0043*  ; destroys: everything including shadow registers but not index registers
040C68             0044*  umul2424:
040C68             0045*  ; put HLU and DEU into B and C respectively
040C68             0046*  
040C68             0047*  umul2448out: ds 6 ; output buffer
040C6E             0048*  
040C6E             0049*  arith24uaf: ds 6
040C74             0050*  arith24uhl: ds 6
040C7A             0051*  arith24ubc: ds 6
040C80             0052*  arith24ude: ds 6
040C86             0053*  arith24uix: ds 6
040C8C             0054*  arith24uiy: ds 6
040C92             0055*  arith24usp: ds 6
040C98             0056*  arith24upc: ds 6
040C9E             0057*  
040C9E             0058*  ; hlu 1 byte right shift
040C9E             0059*  ; returns: hlu / 256, fractional portion in a
040C9E             0060*  ; destroys: af
040C9E             0061*  shift_hlu_r1b:
040C9E AF          0062*  	xor a
040C9F 32 B0 0C 04 0063*  	ld (@buffer+3),a
040CA3 7D          0064*  	ld a,l ; save the fractional portion
040CA4 22 AD 0C 04 0065*  	ld (@buffer),hl
040CA8 2A AE 0C 04 0066*  	ld hl,(@buffer+1)
040CAC C9          0067*  	ret
040CAD             0068*  @buffer: ds 4
040CB1             0069*  
040CB1             0070*  ;------------------------------------------------------------------------
040CB1             0071*  ;  arith24.asm
040CB1             0072*  ;  24-bit ez80 arithmetic routines
040CB1             0073*  ;  Copyright (c) Shawn Sijnstra 2024
040CB1             0074*  ;  MIT license
040CB1             0075*  ;
040CB1             0076*  ;  This library was created as a tool to help make ez80
040CB1             0077*  ;  24-bit native assembly routines for simple mathematical problems
040CB1             0078*  ;  more widely available.
040CB1             0079*  ;
040CB1             0080*  ;------------------------------------------------------------------------
040CB1             0081*  
040CB1             0082*  ;------------------------------------------------------------------------
040CB1             0083*  ; umul24:	HL = HL*DE (unsigned)
040CB1             0084*  ; Preserves AF, BC, DE
040CB1             0085*  ; Uses a fast multiply routine.
040CB1             0086*  ;------------------------------------------------------------------------
040CB1             0087*  umul24:
040CB1 D5          0088*  	push	DE
040CB2 C5          0089*  	push	BC
040CB3 F5          0090*  	push	AF
040CB4 E5          0091*  	push	HL
040CB5 C1          0092*  	pop		BC
040CB6 3E 18       0093*      ld	 	a, 24 ; No. of bits to process
040CB8 21 00 00 00 0094*      ld	 	hl, 0 ; Result
040CBC             0095*  umul24_lp:
040CBC 29          0096*  	add	hl,hl
040CBD EB          0097*  	ex	de,hl
040CBE 29          0098*  	add	hl,hl
040CBF EB          0099*  	ex	de,hl
040CC0 30 01       0100*  	jr	nc,umul24_nc
040CC2 09          0101*  	add	hl,bc
040CC3             0102*  umul24_nc:
040CC3 3D          0103*  	dec	a
040CC4 20 F6       0104*  	jr	nz,umul24_lp
040CC6 F1          0105*  	pop	af
040CC7 C1          0106*  	pop	bc
040CC8 D1          0107*  	pop	de
040CC9 C9          0108*  	ret
040CCA             0109*  
040CCA             0110*  ;------------------------------------------------------------------------
040CCA             0111*  ; udiv24
040CCA             0112*  ; Unsigned 24-bit division
040CCA             0113*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040CCA             0114*  ;
040CCA             0115*  ; Uses AF BC DE HL
040CCA             0116*  ; Uses Restoring Division algorithm
040CCA             0117*  ;------------------------------------------------------------------------
040CCA             0118*  
040CCA             0119*  udiv24:
040CCA E5          0120*  	push	hl
040CCB C1          0121*  	pop		bc	;move dividend to BCU
040CCC 21 00 00 00 0122*  	ld		hl,0	;result
040CD0 A7          0123*  	and		a
040CD1 ED 52       0124*  	sbc		hl,de	;test for div by 0
040CD3 C8          0125*  	ret		z		;it's zero, carry flag is clear
040CD4 19          0126*  	add		hl,de	;HL is 0 again
040CD5 3E 18       0127*  	ld		a,24	;number of loops through.
040CD7             0128*  udiv1:
040CD7 C5          0129*  	push	bc	;complicated way of doing this because of lack of access to top bits
040CD8 E3          0130*  	ex		(sp),hl
040CD9 37          0131*  	scf
040CDA ED 6A       0132*  	adc	hl,hl
040CDC E3          0133*  	ex	(sp),hl
040CDD C1          0134*  	pop	bc		;we now have bc = (bc * 2) + 1
040CDE             0135*  
040CDE ED 6A       0136*  	adc	hl,hl
040CE0 A7          0137*  	and	a		;is this the bug
040CE1 ED 52       0138*  	sbc	hl,de
040CE3 30 02       0139*  	jr	nc,udiv2
040CE5 19          0140*  	add	hl,de
040CE6             0141*  ;	dec	c
040CE6 0B          0142*  	dec	bc
040CE7             0143*  udiv2:
040CE7 3D          0144*  	dec	a
040CE8 20 ED       0145*  	jr	nz,udiv1
040CEA 37          0146*  	scf		;flag used for div0 error
040CEB C5          0147*  	push	bc
040CEC D1          0148*  	pop		de	;remainder
040CED C9          0149*  	ret
040CEE             0150*  
040CEE             0151*  
040CEE             0152*  ; umul24:	UH.L = UH.L*UD.E (unsigned)
040CEE             0153*  ; Preserves AF, BC, DE
040CEE             0154*  umul168:
040CEE             0155*  
040CEE             0156*  umul168out: ds 6
040CF4             0157*  
040CF4             0158*  ; perform signed multiplication of 16.8 fixed place values
040CF4             0159*  ; with an signed 16.8 fixed place result
040CF4             0160*  ; inputs: ub.c and ud.e are the operands
040CF4             0161*  ; outputs: uh.l is the product
040CF4             0162*  ; destroys: a,bc
040CF4             0163*  ; TODO: make flags appropriate to the sign of the result
040CF4             0164*  smul168:
040CF4             0165*  ; make everything positive and save signs
040CF4 C5          0166*      push bc         ; get bc to hl
040CF5 E1          0167*      pop hl          ; for the next call
040CF6 CD D5 16 04 0168*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
040CFA             0169*  
040CFA             0170*      ; call dumpFlags ; passes
040CFA             0171*  
040CFA CA 2D 0D 04 0172*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040CFE F5          0173*      push af         ; save sign of bc
040CFF E5          0174*      push hl         ; now put abs(hl)
040D00 C1          0175*      pop bc          ; back into bc = abs(bc)
040D01 EB          0176*      ex de,hl        ; now we do de same way
040D02 CD D5 16 04 0177*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
040D06             0178*  
040D06             0179*      ; call dumpFlags ; passes
040D06             0180*  
040D06 CA 2D 0D 04 0181*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
040D0A EB          0182*      ex de,hl        ; hl back to de = abs(de)
040D0B             0183*  ; determine sign of result
040D0B F2 16 0D 04 0184*      jp p,@de_pos    ; sign positive,de is positive
040D0F             0185*  
040D0F             0186*      ; call dumpFlags ; correctly doesnt make it here
040D0F             0187*  
040D0F F1          0188*      pop af          ; get back sign of bc
040D10             0189*  
040D10             0190*      ; call dumpFlags ; correctly doesn't make it here
040D10             0191*  
040D10 FA 1F 0D 04 0192*      jp m,@result_pos  ; bc and de negative, result is positive
040D14             0193*  
040D14             0194*      ; call dumpFlags  ; corectly doesn't make it here
040D14             0195*  
040D14 18 05       0196*      jr @result_neg
040D16             0197*  @de_pos:
040D16 F1          0198*      pop af          ; get back sign of bc
040D17             0199*  
040D17             0200*      ; call dumpFlags  ; passes
040D17             0201*  
040D17 F2 1F 0D 04 0202*      jp p,@result_pos   ; bc and de are both positive so result is positive
040D1B             0203*  
040D1B             0204*      ; call dumpFlags ; correctly makes it here
040D1B             0205*  
040D1B             0206*                      ; fall through to result_neg
040D1B             0207*  @result_neg:
040D1B AF          0208*      xor a           ; zero a and clear carry
040D1C 3D          0209*      dec a           ; set sign flag to negative
040D1D             0210*  
040D1D             0211*      ; call dumpFlags ; passes
040D1D             0212*  
040D1D 18 02       0213*      jr @do_mul
040D1F             0214*  @result_pos:
040D1F AF          0215*      xor a           ; zero a and clear carry
040D20 3C          0216*      inc a           ; set sign flag to positive
040D21             0217*                      ; fall through to do_mul
040D21             0218*  
040D21             0219*      ; call dumpFlags ; correctly doesn't make it here
040D21             0220*  
040D21             0221*  @do_mul:
040D21 F5          0222*      push af         ; save sign of result
040D22 CD EE 0C 04 0223*      call umul168
040D26 F1          0224*      pop af          ; get back sign of result
040D27             0225*  
040D27             0226*      ; call dumpFlags ; passes
040D27             0227*  
040D27 F0          0228*      ret p           ; result is positive so nothing to do
040D28             0229*  
040D28             0230*      ; call dumpRegistersHex ; passes
040D28             0231*  
040D28 CD E5 16 04 0232*      call neg_hlu    ; result is negative so negate it
040D2C             0233*  
040D2C             0234*      ; call dumpRegistersHex ; passes
040D2C C9          0235*      ret
040D2D             0236*  @is_zero:           ; result is zero
040D2D AF          0237*      xor a           ; sets zero flag, which we want,
040D2E             0238*                      ; sets pv flag which we might not (zero is parity even)
040D2E             0239*                      ; resets all others which is okay
040D2E C9          0240*      ret
040D2F             0241*  
040D2F             0242*  ; perform unsigned division of fixed place values
040D2F             0243*  ; with an unsigned 16.8 fixed place result
040D2F             0244*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
040D2F             0245*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
040D2F             0246*  ; destroys: a,bc
040D2F             0247*  udiv168:
040D2F             0248*  ; shift dividend left 8 bits
040D2F ED 43 7B 0C 0249*      ld (arith24ubc+1),bc
       04          
040D34 AF          0250*      xor a
040D35 32 7A 0C 04 0251*      ld (arith24ubc),a
040D39 ED 4B 7A 0C 0252*      ld bc,(arith24ubc)
       04          
040D3E CD CA 0C 04 0253*      call udiv24
040D42             0254*  ; flip-flop outptuts to satisfy downstream consumers
040D42             0255*  ; TODO: this is a hack and should be fixed
040D42             0256*  ; (so says copilot ... but it's not wrong)
040D42 E5          0257*      push hl
040D43 C5          0258*      push bc
040D44 E1          0259*      pop hl
040D45 C1          0260*      pop bc
040D46 C9          0261*      ret
040D47             0262*  
040D47             0263*  ; perform signed division of 16.8 fixed place values
040D47             0264*  ; with an signed 16.8 fixed place result
040D47             0265*  ; inputs: ub.c is dividend,ud.e is divisor
040D47             0266*  ; outputs: uh.l is quotient
040D47             0267*  ; destroys: a,bc
040D47             0268*  ; note: uses carry flag to test for sign of operands and result
040D47             0269*  ;       which can be confusing and should perhaps be changed
040D47             0270*  ; note2: helper functions abs_hlu and neg_hlu have been modified
040D47             0271*  ;       to return accurate flags according to the origional signs
040D47             0272*  ;       (or zero) of this function's inputs
040D47             0273*  sdiv168:
040D47             0274*  ; make everything positive and save signs
040D47 C5          0275*      push bc         ; get bc to hl
040D48 E1          0276*      pop hl          ; for the next call
040D49 CD D5 16 04 0277*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
040D4D CA 80 0D 04 0278*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040D51 F5          0279*      push af         ; save sign of bc
040D52 E5          0280*      push hl         ; now put abs(hl)
040D53 C1          0281*      pop bc          ; back into bc = abs(bc)
040D54 EB          0282*      ex de,hl        ; now we do de same way
040D55 CD D5 16 04 0283*      call abs_hlu
040D59 CA 82 0D 04 0284*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
040D5D EB          0285*      ex de,hl        ; hl back to de = abs(de)
040D5E             0286*  ; determine sign of result
040D5E F2 69 0D 04 0287*      jp p,@de_pos    ; sign positive,de is positive
040D62 F1          0288*      pop af          ; get back sign of bc
040D63 FA 72 0D 04 0289*      jp m,@result_pos  ; bc and de negative, result is positive
040D67 18 05       0290*      jr @result_neg
040D69             0291*  @de_pos:
040D69 F1          0292*      pop af          ; get back sign of bc
040D6A F2 72 0D 04 0293*      jp p,@result_pos   ; bc and de are both positive so result is positive
040D6E             0294*                      ; fall through to result_neg
040D6E             0295*  @result_neg:
040D6E AF          0296*      xor a           ; zero a and clear carry
040D6F 3D          0297*      dec a           ; set sign flag to negative
040D70 18 02       0298*      jr @do_div
040D72             0299*  @result_pos:
040D72 AF          0300*      xor a           ; zero a and clear carry
040D73 3C          0301*      inc a           ; set sign flag to negative
040D74             0302*                      ; fall through to do_div
040D74             0303*  @do_div:
040D74 F5          0304*      push af         ; save sign of result
040D75 CD 2F 0D 04 0305*      call udiv168
040D79 F1          0306*      pop af          ; get back sign of result
040D7A F0          0307*      ret p           ; result is positive so nothing to do
040D7B CD E5 16 04 0308*      call neg_hlu    ; result is negative so negate it
040D7F C9          0309*      ret
040D80             0310*  @is_zero:           ; result is zero
040D80 AF          0311*      xor a           ; sets zero flag, which we want,
040D81             0312*                      ; sets pv flag which we might not (zero is parity even)
040D81             0313*                      ; resets all others which is okay
040D81 C9          0314*      ret
040D82             0315*  @div_by_zero:       ; result is undefined, which isn't defined in binary
040D82             0316*                      ; so we'll just return zero until i can think of something better
040D82 F1          0317*      pop af          ; dummy pop
040D83 AF          0318*      xor a           ; sets zero flag, which is ok,
040D84             0319*                      ; sets pv flag which could be interpreted as overflow, which is good
040D84             0320*                      ; resets all others which is okay
040D84 C9          0321*      ret
040D85             0322*  
040D85             0323*  ;------------------------------------------------------------------------
040D85             0324*  ; neg24
040D85             0325*  ; Returns: HLU = 0-HLU
040D85             0326*  ; preserves all other registers
040D85             0327*  ;------------------------------------------------------------------------
040D85             0328*  neg24:
040D85 D5          0329*  	push	de
040D86 EB          0330*  	ex		de,hl
040D87 21 00 00 00 0331*  	ld		hl,0
040D8B B7          0332*  	or		a
040D8C ED 52       0333*  	sbc		hl,de
040D8E D1          0334*  	pop		de
040D8F C9          0335*  	ret
040D90             0336*  
040D90             0337*  ;------------------------------------------------------------------------
040D90             0338*  ; or_hlu_deu: 24 bit bitwise OR
040D90             0339*  ; Returns: hlu = hlu OR deu
040D90             0340*  ; preserves all other registers
040D90             0341*  ;------------------------------------------------------------------------
040D90             0342*  or_hlu_deu:
040D90 22 1B 0E 04 0343*  	ld	(bitbuf1),hl
040D94 ED 53 1E 0E 0344*  	ld	(bitbuf2),de
       04          
040D99 D5          0345*  	push	de	;preserve DEU
040D9A C5          0346*  	push	bc	;preserve BCU
040D9B 06 03       0347*  	ld		b,3
040D9D 21 1B 0E 04 0348*  	ld	hl,bitbuf1
040DA1 11 1B 0E 04 0349*  	ld	de,bitbuf1
040DA5             0350*  orloop_24:
040DA5 1A          0351*  	ld	a,(de)
040DA6 B6          0352*  	or	(hl)
040DA7 12          0353*  	ld	(de),a
040DA8 13          0354*  	inc	de
040DA9 23          0355*  	inc	hl
040DAA 10 F9       0356*  	djnz	orloop_24
040DAC 2A 1E 0E 04 0357*  	ld	hl,(bitbuf2)
040DB0 C1          0358*  	pop		bc	;restore BC
040DB1 D1          0359*  	pop		de	;restore DE
040DB2             0360*  
040DB2             0361*  ;------------------------------------------------------------------------
040DB2             0362*  ; and_hlu_deu: 24 bit bitwise AND
040DB2             0363*  ; Returns: hlu = hlu AND deu
040DB2             0364*  ; preserves all other registers
040DB2             0365*  ;------------------------------------------------------------------------
040DB2             0366*  and_hlu_deu:
040DB2 22 1B 0E 04 0367*  	ld	(bitbuf1),hl
040DB6 ED 53 1E 0E 0368*  	ld	(bitbuf2),de
       04          
040DBB D5          0369*  	push	de	;preserve DEU
040DBC C5          0370*  	push	bc	;preserve BCU
040DBD 06 03       0371*  	ld		b,3
040DBF 21 1B 0E 04 0372*  	ld	hl,bitbuf1
040DC3 11 1B 0E 04 0373*  	ld	de,bitbuf1
040DC7             0374*  andloop_24:
040DC7 1A          0375*  	ld	a,(de)
040DC8 A6          0376*  	and	(hl)
040DC9 12          0377*  	ld	(de),a
040DCA 13          0378*  	inc	de
040DCB 23          0379*  	inc	hl
040DCC 10 F9       0380*  	djnz	andloop_24
040DCE 2A 1E 0E 04 0381*  	ld	hl,(bitbuf2)
040DD2 C1          0382*  	pop		bc	;restore BC
040DD3 D1          0383*  	pop		de	;restore DE
040DD4             0384*  
040DD4             0385*  ;------------------------------------------------------------------------
040DD4             0386*  ; xor_hlu_deu: 24 bit bitwise XOR
040DD4             0387*  ; Returns: hlu = hlu XOR deu
040DD4             0388*  ; preserves all other registers
040DD4             0389*  ;------------------------------------------------------------------------
040DD4             0390*  xor_hlu_deu:
040DD4 22 1B 0E 04 0391*  	ld	(bitbuf1),hl
040DD8 ED 53 1E 0E 0392*  	ld	(bitbuf2),de
       04          
040DDD D5          0393*  	push	de	;preserve DEU
040DDE C5          0394*  	push	bc	;preserve BCU
040DDF 06 03       0395*  	ld		b,3
040DE1 21 1B 0E 04 0396*  	ld	hl,bitbuf1
040DE5 11 1B 0E 04 0397*  	ld	de,bitbuf1
040DE9             0398*  xorloop_24:
040DE9 1A          0399*  	ld	a,(de)
040DEA AE          0400*  	xor	(hl)
040DEB 12          0401*  	ld	(de),a
040DEC 13          0402*  	inc	de
040DED 23          0403*  	inc	hl
040DEE 10 F9       0404*  	djnz	xorloop_24
040DF0 2A 1E 0E 04 0405*  	ld	hl,(bitbuf2)
040DF4 C1          0406*  	pop		bc	;restore BC
040DF5 D1          0407*  	pop		de	;restore DE
040DF6             0408*  
040DF6             0409*  ;------------------------------------------------------------------------
040DF6             0410*  ; shl_hlu: 24 bit shift left hlu by deu positions
040DF6             0411*  ; Returns: hlu = hlu << deu
040DF6             0412*  ;		   de = 0
040DF6             0413*  ; NOTE: only considers deu up to 16 bits.
040DF6             0414*  ; preserves all other registers
040DF6             0415*  ;------------------------------------------------------------------------
040DF6             0416*  shl_hlu:
040DF6 7A          0417*  	ld		a,d		;up to 16 bit.
040DF7 B3          0418*  	or		e
040DF8 C8          0419*  	ret		z		;we're done
040DF9 29          0420*  	add		hl,hl	;shift HLU left
040DFA 1B          0421*  	dec		de
040DFB 18 F9       0422*  	jr		shl_hlu
040DFD             0423*  
040DFD             0424*  ;------------------------------------------------------------------------
040DFD             0425*  ; shr_hlu: 24 bit shift right hlu by deu positions
040DFD             0426*  ; Returns: hlu = hlu >> deu
040DFD             0427*  ;		   de = 0
040DFD             0428*  ; NOTE: only considers deu up to 16 bits.
040DFD             0429*  ; preserves all other registers
040DFD             0430*  ;------------------------------------------------------------------------
040DFD             0431*  shr_hlu:
040DFD 22 1B 0E 04 0432*  	ld		(bitbuf1),hl
040E01 21 1D 0E 04 0433*  	ld		hl,bitbuf1+2
040E05             0434*  shr_loop:
040E05 7A          0435*  	ld		a,d		;up to 16 bit.
040E06 B3          0436*  	or		e
040E07 28 0D       0437*  	jr		z,shr_done		;we're done
040E09             0438*  ;carry is clear from or instruction
040E09 CB 1E       0439*  	rr		(hl)
040E0B 2B          0440*  	dec		hl
040E0C CB 1E       0441*  	rr		(hl)
040E0E 2B          0442*  	dec		hl
040E0F CB 1E       0443*  	rr		(hl)
040E11 23          0444*  	inc		hl
040E12 23          0445*  	inc		hl
040E13 1B          0446*  	dec		de
040E14 18 EF       0447*  	jr		shr_loop
040E16             0448*  shr_done:
040E16 2A 1B 0E 04 0449*  	ld		hl,(bitbuf1)	;collect result
040E1A C9          0450*  	ret
040E1B             0451*  
040E1B             0452*  ;------------------------------------------------------------------------
040E1B             0453*  ; Scratch area for calculations
040E1B             0454*  ;------------------------------------------------------------------------
040E1B 00 00 00    0455*  bitbuf1:	dw24	0	;bit manipulation buffer 1
040E1E 00 00 00    0456*  bitbuf2:	dw24	0	;bit manipulation buffer 2
040E21             0457*  
040E21             0458*  ; ========== FROM maths24.inc ==========
040E21             0459*  
040E21             0460*  ; http://www.z80.info/pseudo-random.txt
040E21             0461*  rand_8:
040E21 C5          0462*      push bc
040E22 3A 35 0E 04 0463*      ld a,(r_seed)
040E26 4F          0464*      ld c,a
040E27             0465*  
040E27 0F          0466*      rrca ; multiply by 32
040E28 0F          0467*      rrca
040E29 0F          0468*      rrca
040E2A EE 1F       0469*      xor 0x1f
040E2C             0470*  
040E2C 81          0471*      add a,c
040E2D DE FF       0472*      sbc a,255 ; carry
040E2F             0473*  
040E2F 32 35 0E 04 0474*      ld (r_seed),a
040E33 C1          0475*      pop bc
040E34 C9          0476*      ret
040E35 50          0477*  r_seed: defb $50
040E36             0478*  
040E36             0479*  ; tests the sign of 24-bit register hlu
040E36             0480*  ; returns: a in [-1,0,1]
040E36             0481*  ;   sign and zero flags as expected
040E36             0482*  ;   hl is untouched
040E36             0483*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
040E36             0484*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
040E36             0485*  get_sign_hlu:
040E36             0486*      ; Load the upper byte of HLU into A
040E36 E5          0487*      push hl
040E37 DD 21 00 00 0488*      ld ix,0
       00          
040E3C DD 39       0489*      add ix,sp
040E3E DD 7E 02    0490*      ld a,(ix+2)
040E41 E1          0491*      pop hl
040E42             0492*  
040E42 B5          0493*      or l                ; OR with the low byte to check if HL is zero
040E43 C8          0494*      ret z               ; Return if HL is zero
040E44             0495*  
040E44 3E FF       0496*      ld a,-1             ; Send A back as -1 if the sign flag is set
040E46 CB 7C       0497*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
040E48 C0          0498*      ret nz              ; If set,HL is negative,return with the sign flag set
040E49             0499*  
040E49 3E 01       0500*      ld a,1             ; Otherwise,HL is positive
040E4B A7          0501*      and a               ; Reset the zero flag
040E4C C9          0502*      ret                 ; Return with A set to 1
040E4D             0503*  
040E4D             0504*  ; convert unsigned angles from a 360 to 255 degree circle
040E4D             0505*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040E4D             0506*  ; outputs: uh.l is the angle255 in 16.8 fixed format
040E4D             0507*  ; destroys: TODO
040E4D             0508*  ; note: even though the inputs and outputs are 16.8 fixed format
040E4D             0509*  ;       precision is effectively limited to 8.8 fixed format
040E4D             0510*  deg_360_to_255:
040E4D             0511*  ; clear scratch buffer
040E4D 11 00 00 00 0512*  	ld de,0
040E51 ED 53 7D 0E 0513*  	ld (@scratch),de
       04          
040E56             0514*  ; divide uh.l by 360
040E56 11 68 01 00 0515*  	ld de,360
040E5A             0516*  ; get integer portion
040E5A CD CA 0C 04 0517*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
040E5E ED 53 84 0E 0518*  	ld (@output+1),de ; shift result up one byte
       04          
040E63             0519*  ; get fractional portion
040E63 22 7E 0E 04 0520*  	ld (@scratch+1),hl ; shift remainder up one byte
040E67 2A 7D 0E 04 0521*  	ld hl,(@scratch)
040E6B 11 68 01 00 0522*  	ld de,360
040E6F CD CA 0C 04 0523*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
040E73 7B          0524*  	ld a,e ; lowest byte is all we need
040E74 32 83 0E 04 0525*  	ld (@output),a
040E78             0526*  ; we want the low 3 bytes for 16.8 output
040E78 2A 83 0E 04 0527*  	ld hl,(@output)
040E7C C9          0528*  	ret
040E7D             0529*  @scratch: ds 6 ; scratch buffer for shifting bytes
040E83             0530*  @output: ds 6 ; scratch buffer to accumulate output
040E89             0531*  
040E89             0532*  ; 16.8 fixed inputs / outputs
040E89             0533*  ; takes: uh.l as angle in degrees 256
040E89             0534*  ;        ud.e as radius
040E89             0535*  ; returns ub.c as dx, ud.e as dy
040E89             0536*  ;        displacements from origin (0,0)
040E89             0537*  ; destroys: everything except indexes
040E89             0538*  polar_to_cartesian:
040E89             0539*  ; back up input parameters
040E89 22 74 0C 04 0540*      ld (arith24uhl), hl
040E8D ED 53 80 0C 0541*      ld (arith24ude), de
       04          
040E92             0542*  ; compute dx = sin(uh.l) * ud.e
040E92 CD C1 0E 04 0543*      call sin168
040E96 E5          0544*      push hl
040E97 C1          0545*      pop bc          ; ub.c = sin(uh.l)
040E98 ED 5B 80 0C 0546*  	ld de, (arith24ude)   ; get radius back
       04          
040E9D CD F4 0C 04 0547*  	call smul168    ; uh.l = ub.c * ud.e = dx
040EA1 E5          0548*      push hl         ; store dx for output
040EA2             0549*  ; compute dy = -cos(uh.l) * ud.e
040EA2 2A 74 0C 04 0550*      ld hl, (arith24uhl)
040EA6 CD BC 0E 04 0551*      call cos168
040EAA CD E5 16 04 0552*  	call neg_hlu    ; invert dy for screen coords convention
040EAE E5          0553*      push hl
040EAF C1          0554*      pop bc          ; ub.c = -cos(uh.l)
040EB0 ED 5B 80 0C 0555*      ld de, (arith24ude)   ; get radius back
       04          
040EB5 CD F4 0C 04 0556*      call smul168    ; uh.l = ub.c * ud.e = dy
040EB9 EB          0557*      ex de, hl       ; de = dy for output
040EBA C1          0558*      pop bc          ; bc = dx for output
040EBB             0559*  ; and out
040EBB C9          0560*      ret
040EBC             0561*  
040EBC             0562*  ; fixed 16.8 routine
040EBC             0563*  ; cos(uh.l) --> uh.l
040EBC             0564*  ; destroys: de
040EBC             0565*  cos168:
040EBC             0566*  ; for cos we simply increment the angle by 90 degrees
040EBC             0567*  ; or 0x004000 in 16.8 degrees256
040EBC             0568*  ; which makes it a sin problem
040EBC 11 00 40 00 0569*      ld de,0x004000
040EC0 19          0570*      add hl,de ; modulo 256 happens below
040EC1             0571*  ; fall through to sin168
040EC1             0572*  ; ---------------------
040EC1             0573*  ; fixed 16.8 routine
040EC1             0574*  ; sin(uh.l) --> uh.l
040EC1             0575*  ; destroys: de
040EC1             0576*  sin168:
040EC1             0577*  ; h contains the integer portion of our angle
040EC1             0578*  ; we multiply it by three to get our lookup table index
040EC1 2E 03       0579*      ld l,3
040EC3 ED 6C       0580*      mlt hl ; gosh that is handy
040EC5 11 00 00 00 0581*      ld de,0 ; clear deu
040EC9 54          0582*      ld d,h ; copy hl to de
040ECA 5D          0583*      ld e,l ; de contains our index
040ECB 21 D2 10 04 0584*      ld hl,sin_lut_168 ; grab the lut address
040ECF 19          0585*      add hl,de ; bump hl by the index
040ED0 ED 27       0586*      ld hl,(hl) ; don't try this on a z80!
040ED2 C9          0587*      ret ; and out
040ED3             0588*  
040ED3             0589*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040ED3             0590*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040ED3             0591*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040ED3             0592*  ;         also populates scratch locations dx168 and dy168
040ED3             0593*  ; destroys: a,hl,bc,de
040ED3             0594*  dxy168:
040ED3             0595*  ; compute dx = x1-x0
040ED3 AF          0596*      xor a ; clear carry
040ED4 DD E5       0597*      push ix ; move ix to hl via the stack
040ED6 E1          0598*      pop hl ; hl = x1
040ED7 ED 42       0599*      sbc hl,bc ; hl = dx
040ED9 22 2E 0F 04 0600*      ld (dx168),hl ; dx to scratch
040EDD             0601*  ; compute dy = y1-y0
040EDD AF          0602*      xor a ; clear carry
040EDE FD E5       0603*      push iy ; move iy to hl via the stack
040EE0 E1          0604*      pop hl ; hl = y1
040EE1 ED 52       0605*      sbc hl,de ; hl = dy
040EE3 22 34 0F 04 0606*      ld (dy168),hl ; dy to scratch
040EE7             0607*  ; populate output registers and return
040EE7 EB          0608*      ex de,hl        ; ud.e = dy
040EE8 ED 4B 2E 0F 0609*      ld bc,(dx168)   ; ub.c = dx
       04          
040EED C9          0610*      ret
040EEE             0611*  
040EEE             0612*  ; compute the euclidian distance between two cartesian coordinates
040EEE             0613*  ; using the formula d = sqrt(dx^2+dy^2
040EEE             0614*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040EEE             0615*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040EEE             0616*  ; output; uh.l is the 16.8 fixed format distance
040EEE             0617*  ;       dx168/y are the 16.8 fixed format dx and dy
040EEE             0618*  ; destroys: a,hl,bc,de
040EEE             0619*  distance168:
040EEE             0620*  ; compute dx = x1-x0
040EEE AF          0621*      xor a ; clear carry
040EEF DD E5       0622*      push ix ; move ix to hl via the stack
040EF1 E1          0623*      pop hl ; hl = x1
040EF2 ED 42       0624*      sbc hl,bc ; hl = dx
040EF4 22 2E 0F 04 0625*      ld (dx168),hl ; dx to scratch
040EF8             0626*  ; ; test dx for overflow
040EF8             0627*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
040EF8             0628*  ; 	ex de,hl
040EF8             0629*  ; 	sbc hl,de ; test for overflow
040EF8             0630*  ; 	push af ; carry indicates overflow
040EF8             0631*  ; compute dy = y1-y0
040EF8 AF          0632*      xor a ; clear carry
040EF9 FD E5       0633*      push iy ; move iy to hl via the stack
040EFB E1          0634*      pop hl ; hl = y1
040EFC ED 52       0635*      sbc hl,de ; hl = dy
040EFE 22 34 0F 04 0636*      ld (dy168),hl ; dy to scratch
040F02             0637*  ; ; test dy for overflow
040F02             0638*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
040F02             0639*  ; 	ex de,hl
040F02             0640*  ; 	sbc hl,de ; test for overflow
040F02             0641*  ; 	push af ; carry indicates overflow
040F02             0642*  ; compute dy^2
040F02 2A 34 0F 04 0643*  	ld hl,(dy168)
040F06 CD D5 16 04 0644*      call abs_hlu  ; make dy positive so we can use unsigned multiply
040F0A             0645*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
040F0A E5          0646*      push hl ; load hl/2 to bc via the stack
040F0B C1          0647*      pop bc ; bc = dy/2
040F0C EB          0648*      ex de,hl ; de = dy/2
040F0D CD EE 0C 04 0649*      call umul168 ; uh.l = dy^2/2
040F11 E5          0650*      push hl ; dy^2/2 to the stack
040F12             0651*  ; compute dx^2
040F12 2A 2E 0F 04 0652*      ld hl,(dx168) ; get back dx
040F16 CD D5 16 04 0653*      call abs_hlu  ; make dx positive so we can use unsigned multiply
040F1A             0654*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
040F1A E5          0655*      push hl ; load hl/2 to bc via the stack
040F1B C1          0656*      pop bc ; bc = dx/2
040F1C EB          0657*      ex de,hl ; de = dx/2
040F1D CD EE 0C 04 0658*      call umul168 ; uh.l = dx^2/2
040F21             0659*  ; commpute dy^2+dx^2
040F21 D1          0660*      pop de ; get back dx^2/2
040F22 19          0661*      add hl,de ; hl = dx^2/2+dy^2/2
040F23             0662*  ; compute sqrt(dx^2/2+dy^2/2)
040F23 CD E7 0F 04 0663*      call sqrt168 ; uh.l = distance/2
040F27             0664*      ; add hl,hl ; hl = distance
040F27             0665*  ; ; check for overflow
040F27             0666*  ; 	pop af ; get back the overflow flags
040F27             0667*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
040F27             0668*  ; 	ld b,a ; save the overflow flag
040F27             0669*  ; 	pop af ; get back the overflow flags
040F27             0670*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
040F27             0671*  ; 	add a,b ; if a != 0 then we had overflow
040F27             0672*  ;     ret z ; no overflow we're done
040F27             0673*  ; @overflow:
040F27             0674*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
040F27 C9          0675*  	ret
040F28             0676*  @scratch: ds 6
040F2E             0677*  dx168: ds 6
040F34             0678*  dy168: ds 6
040F3A             0679*  
040F3A             0680*  ; atan2(ub.c,ud.e) --> uh.l
040F3A             0681*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040F3A             0682*  ;   whether inputs are integers or fractional doesn't matter
040F3A             0683*  ;   so long as the sign bit of the upper byte is correct
040F3A             0684*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040F3A             0685*  ; angles are COMPASS HEADINGS based on
040F3A             0686*  ; screen coordinate conventions,where the y axis is flipped
040F3A             0687*  ; #E0 315      0       45 #20
040F3A             0688*  ;        -x,-y | +x,-y
040F3A             0689*  ; #C0 270------+------ 90 #40
040F3A             0690*  ;        -x,+y | +x,+y
040F3A             0691*  ; #A0 225   180 #80   135 #60
040F3A             0692*  atan2_168game:
040F3A             0693*  ; get signs and make everything positive
040F3A             0694*  ; get abs(x) and store its original sign
040F3A C5          0695*      push bc
040F3B E1          0696*      pop hl
040F3C CD D5 16 04 0697*      call abs_hlu ; if x was negative this also sets the sign flag
040F40 E5          0698*      push hl ; store abs(x)
040F41 C1          0699*      pop bc ; bc = abs(x)
040F42 F5          0700*      push af ; store sign of x
040F43             0701*  ; get abs(y) and store its original sign
040F43 EB          0702*      ex de,hl ; hl = y
040F44 CD D5 16 04 0703*      call abs_hlu ; if y was negative this also sets the sign flag
040F48 EB          0704*      ex de,hl ; de = abs(y)
040F49 F5          0705*      push af ; store sign of y
040F4A             0706*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040F4A             0707*  ; this ensures that our lookup value is between 0 and 1 inclusive
040F4A AF          0708*      xor a ; clear the carry flag
040F4B D5          0709*      push de
040F4C E1          0710*      pop hl
040F4D ED 42       0711*      sbc hl,bc
040F4F F5          0712*      push af ; save sign of de - bc
040F50 F2 59 0F 04 0713*      jp p,@1 ; bc <= de, so we skip ahead
040F54             0714*  ; otherwise we swap bc and de
040F54 C5          0715*      push bc
040F55 E1          0716*      pop hl
040F56 EB          0717*      ex de,hl
040F57 E5          0718*      push hl
040F58 C1          0719*      pop bc
040F59             0720*  @1:
040F59             0721*  ; now we're ready to snag our preliminary result
040F59 CD C7 0F 04 0722*      call atan_168game ; uh.l comes back with prelim result
040F5D             0723*  ; now we adjust uh.l based on sign of de - bc
040F5D F1          0724*      pop af
040F5E F2 6A 0F 04 0725*      jp p,@2 ; bc <= de,so we skip ahead
040F62 EB          0726*      ex de,hl
040F63 21 00 40 00 0727*      ld hl,0x004000 ; 90 degrees
040F67 AF          0728*      xor a ; clear the carry flag
040F68 ED 52       0729*      sbc hl,de ; subtract result from 90 degrees
040F6A             0730*      ; ld de,0 ; prep to clear hlu
040F6A             0731*      ; ld d,h
040F6A             0732*      ; ld e,l
040F6A             0733*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
040F6A             0734*      ; fall through
040F6A             0735*  @2:
040F6A             0736*  ; now the fun part of adjusting the result
040F6A             0737*  ; based on which quadrant (x,y) is in
040F6A             0738*  ; #E0 315      0       45 #20
040F6A             0739*  ;        -x,-y | +x,-y
040F6A             0740*  ; #C0 270------+------ 90 #40
040F6A             0741*  ;        -x,+y | +x,+y
040F6A             0742*  ; #A0 225   180 #80   135 #60
040F6A F1          0743*      pop af ; sign of y
040F6B CA A8 0F 04 0744*      jp z,@y_zero
040F6F F2 88 0F 04 0745*      jp p,@y_pos
040F73             0746*  ; y neg,check x
040F73 F1          0747*      pop af ; sign of x
040F74 CA 82 0F 04 0748*      jp z,@y_neg_x_zero
040F78 F2 87 0F 04 0749*      jp p,@y_neg_x_pos
040F7C             0750*  ; y neg,x neg
040F7C             0751*  ; angle is 270-360
040F7C             0752*  ; negating the intermediate does the trick
040F7C CD E5 16 04 0753*      call neg_hlu
040F80 18 31       0754*      jr @zero_hlu
040F82             0755*  
040F82             0756*  @y_neg_x_zero:
040F82             0757*  ; y neg,x zero
040F82             0758*  ; angle is 0
040F82 21 00 00 00 0759*      ld hl,0
040F86 C9          0760*      ret
040F87             0761*  @y_neg_x_pos:
040F87             0762*  ; y neg,x pos
040F87             0763*  ; angle is 0 to 90
040F87             0764*  ; so we're good
040F87 C9          0765*      ret
040F88             0766*  
040F88             0767*  @y_pos:
040F88 F1          0768*      pop af ; sign of x
040F89 CA 98 0F 04 0769*      jp z,@y_pos_x_zero
040F8D F2 9D 0F 04 0770*      jp p,@y_pos_x_pos
040F91             0771*  ; y pos,x neg
040F91             0772*  ; angle is 180-270
040F91             0773*  ; so we add 180 to intermediate
040F91 11 00 80 00 0774*      ld de,0x008000
040F95 19          0775*      add hl,de
040F96 18 1B       0776*      jr @zero_hlu
040F98             0777*  @y_pos_x_zero:
040F98             0778*  ; y pos,x zero
040F98             0779*  ; angle is 180
040F98 21 00 80 00 0780*      ld hl,0x008000
040F9C C9          0781*      ret
040F9D             0782*  @y_pos_x_pos:
040F9D             0783*  ; y pos,x pos
040F9D             0784*  ; angle is 90-180
040F9D             0785*  ; neg the intermediate and add 180 degrees
040F9D CD E5 16 04 0786*      call neg_hlu
040FA1 11 00 80 00 0787*      ld de,0x008000
040FA5 19          0788*      add hl,de
040FA6 18 0B       0789*      jr @zero_hlu
040FA8             0790*  
040FA8             0791*  @y_zero:
040FA8 F1          0792*      pop af ; sign of x
040FA9 FA AE 0F 04 0793*      jp m,@y_zero_x_neg
040FAD             0794*  ; y zero,x pos
040FAD             0795*  ; angle is 90,nothing to do
040FAD C9          0796*      ret
040FAE             0797*  @y_zero_x_neg:
040FAE             0798*  ; y zero ,x neg
040FAE             0799*  ; angle is 270
040FAE 21 00 C0 00 0800*      ld hl,0x00C000
040FB2 C9          0801*      ret
040FB3             0802*  @zero_hlu:
040FB3 AF          0803*      xor a
040FB4 22 C1 0F 04 0804*      ld (@scratch),hl
040FB8 32 C3 0F 04 0805*      ld (@scratch+2),a
040FBC 2A C1 0F 04 0806*      ld hl,(@scratch)
040FC0 C9          0807*      ret
040FC1             0808*  @scratch: ds 6
040FC7             0809*  
040FC7             0810*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040FC7             0811*  ; output: uh.l is the 16.8 fixed format angle
040FC7             0812*  ; destroys: a,hl,bc,de
040FC7             0813*  ; the following note was written by github copilot:
040FC7             0814*  ; note: this routine is a bit of a hack
040FC7             0815*  ;      but it works
040FC7             0816*  ;      and it's fast
040FC7             0817*  ;      and it's small
040FC7             0818*  ;      and it's accurate
040FC7             0819*  ;      and it's easy to understand
040FC7             0820*  ;      and it's easy to modify
040FC7             0821*  ;      and it's easy to use
040FC7             0822*  ;      and it's easy to remember
040FC7             0823*  ;      and it's easy to love
040FC7             0824*  ;      and it's easy to hate
040FC7             0825*  ;      and it's easy to ignore
040FC7             0826*  ;      and it's easy to forget
040FC7             0827*  ;      and it's easy to remember
040FC7             0828*  ;      and it's easy to forget
040FC7             0829*  ;      and it's easy to remember
040FC7             0830*  ;      (ok the bot is stuck in a loop)
040FC7             0831*  ; REAL NOTE: only works for angles from 0 to 45 degrees
040FC7             0832*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
040FC7             0833*  atan_168game:
040FC7             0834*  ; because we use compass headings instead of geometric angles
040FC7             0835*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040FC7             0836*  ; we can do faster unsigned division here because we know dx and dy are positive
040FC7 CD 2F 0D 04 0837*  	call udiv168 ; uh.l = dx/dy
040FCB             0838*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
040FCB             0839*  ; ; test uh.l for 0
040FCB             0840*  ;     add hl,de
040FCB             0841*  ;     or a
040FCB             0842*  ;     sbc hl,de
040FCB             0843*  ;     jr z,@is_zero
040FCB             0844*  ; ; test uh.l for 1
040FCB             0845*  ;     xor a ; clear carry
040FCB             0846*  ;     ex de,hl
040FCB             0847*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
040FCB             0848*  ;     sbc hl,de
040FCB             0849*  ;     jr z,@is_45
040FCB             0850*  ; ; END TODO
040FCB             0851*  
040FCB             0852*  ; no special cases so we move on
040FCB             0853*  ; l contains the fractional portion of tan(uh.l)
040FCB             0854*  ; we multiply it by three to get our lookup table index
040FCB 26 03       0855*      ld h,3
040FCD ED 6C       0856*      mlt hl ; gosh that is handy
040FCF 11 00 00 00 0857*      ld de,0 ; clear deu
040FD3 54          0858*      ld d,h ; copy hl to de
040FD4 5D          0859*      ld e,l ; de contains our index
040FD5 21 D2 13 04 0860*      ld hl,atan_lut_168 ; grab the lut address
040FD9 19          0861*      add hl,de ; bump hl by the index
040FDA ED 27       0862*      ld hl,(hl) ; don't try this on a z80!
040FDC C9          0863*      ret ; and out
040FDD             0864*  @is_45:
040FDD 21 00 20 00 0865*      ld hl,0x002000 ; 45 degrees decimal
040FE1 C9          0866*      ret
040FE2             0867*  ; for the case tan(0)
040FE2             0868*  @is_zero:
040FE2 21 00 00 00 0869*      ld hl,0x000000
040FE6 C9          0870*      ret
040FE7             0871*  
040FE7             0872*  ; Expects  ADL mode
040FE7             0873*  ; Inputs:  UH.L
040FE7             0874*  ; Outputs: UH.L is the 16.8 square root
040FE7             0875*  ;          UD.E is the difference inputHL-DE^2
040FE7             0876*  ;          c flag reset
040FE7             0877*  sqrt168:
040FE7 CD F1 0F 04 0878*      call sqrt24
040FEB EB          0879*      ex de,hl
040FEC 29          0880*      add hl,hl
040FED 29          0881*      add hl,hl
040FEE 29          0882*      add hl,hl
040FEF 29          0883*      add hl,hl
040FF0 C9          0884*      ret
040FF1             0885*  
040FF1             0886*  ; Expects  ADL mode
040FF1             0887*  ; Inputs:  HL
040FF1             0888*  ; Outputs: DE is the integer square root
040FF1             0889*  ;          HL is the difference inputHL-DE^2
040FF1             0890*  ;          c flag reset
040FF1             0891*  sqrt24:
040FF1 AF          0892*      xor a
040FF2 45          0893*      ld b,l
040FF3 C5          0894*      push bc
040FF4 47          0895*      ld b,a
040FF5 57          0896*      ld d,a
040FF6 4F          0897*      ld c,a
040FF7 6F          0898*      ld l,a
040FF8 5F          0899*      ld e,a
040FF9             0900*  
040FF9             0901*      ;Iteration 1
040FF9 29          0902*      add hl,hl
040FFA CB 11       0903*      rl c
040FFC 29          0904*      add hl,hl
040FFD CB 11       0905*      rl c
040FFF 91          0906*      sub c
041000 30 04       0907*      jr nc,$+6
041002 1C          0908*      inc e
041003 1C          0909*      inc e
041004 2F          0910*      cpl
041005 4F          0911*      ld c,a
041006             0912*  
041006             0913*      ;Iteration 2
041006 29          0914*      add hl,hl
041007 CB 11       0915*      rl c
041009 29          0916*      add hl,hl
04100A CB 11       0917*      rl c
04100C CB 13       0918*      rl e
04100E 7B          0919*      ld a,e
04100F 91          0920*      sub c
041010 30 04       0921*      jr nc,$+6
041012 1C          0922*      inc e
041013 1C          0923*      inc e
041014 2F          0924*      cpl
041015 4F          0925*      ld c,a
041016             0926*  
041016             0927*      ;Iteration 3
041016 29          0928*      add hl,hl
041017 CB 11       0929*      rl c
041019 29          0930*      add hl,hl
04101A CB 11       0931*      rl c
04101C CB 13       0932*      rl e
04101E 7B          0933*      ld a,e
04101F 91          0934*      sub c
041020 30 04       0935*      jr nc,$+6
041022 1C          0936*      inc e
041023 1C          0937*      inc e
041024 2F          0938*      cpl
041025 4F          0939*      ld c,a
041026             0940*  
041026             0941*      ;Iteration 4
041026 29          0942*      add hl,hl
041027 CB 11       0943*      rl c
041029 29          0944*      add hl,hl
04102A CB 11       0945*      rl c
04102C CB 13       0946*      rl e
04102E 7B          0947*      ld a,e
04102F 91          0948*      sub c
041030 30 04       0949*      jr nc,$+6
041032 1C          0950*      inc e
041033 1C          0951*      inc e
041034 2F          0952*      cpl
041035 4F          0953*      ld c,a
041036             0954*  
041036             0955*      ;Iteration 5
041036 29          0956*      add hl,hl
041037 CB 11       0957*      rl c
041039 29          0958*      add hl,hl
04103A CB 11       0959*      rl c
04103C CB 13       0960*      rl e
04103E 7B          0961*      ld a,e
04103F 91          0962*      sub c
041040 30 04       0963*      jr nc,$+6
041042 1C          0964*      inc e
041043 1C          0965*      inc e
041044 2F          0966*      cpl
041045 4F          0967*      ld c,a
041046             0968*  
041046             0969*      ;Iteration 6
041046 29          0970*      add hl,hl
041047 CB 11       0971*      rl c
041049 29          0972*      add hl,hl
04104A CB 11       0973*      rl c
04104C CB 13       0974*      rl e
04104E 7B          0975*      ld a,e
04104F 91          0976*      sub c
041050 30 04       0977*      jr nc,$+6
041052 1C          0978*      inc e
041053 1C          0979*      inc e
041054 2F          0980*      cpl
041055 4F          0981*      ld c,a
041056             0982*  
041056             0983*      ;Iteration 7
041056 29          0984*      add hl,hl
041057 CB 11       0985*      rl c
041059 29          0986*      add hl,hl
04105A CB 11       0987*      rl c
04105C CB 10       0988*      rl b
04105E EB          0989*      ex de,hl
04105F 29          0990*      add hl,hl
041060 E5          0991*      push hl
041061 ED 42       0992*      sbc hl,bc
041063 30 06       0993*      jr nc,$+8
041065 7C          0994*      ld a,h
041066 2F          0995*      cpl
041067 47          0996*      ld b,a
041068 7D          0997*      ld a,l
041069 2F          0998*      cpl
04106A 4F          0999*      ld c,a
04106B E1          1000*      pop hl
04106C 30 02       1001*      jr nc,$+4
04106E 23          1002*      inc hl
04106F 23          1003*      inc hl
041070 EB          1004*      ex de,hl
041071             1005*  
041071             1006*      ;Iteration 8
041071 29          1007*      add hl,hl
041072 69          1008*      ld l,c
041073 60          1009*      ld h,b
041074 ED 6A       1010*      adc hl,hl
041076 ED 6A       1011*      adc hl,hl
041078 EB          1012*      ex de,hl
041079 29          1013*      add hl,hl
04107A ED 52       1014*      sbc hl,de
04107C 19          1015*      add hl,de
04107D EB          1016*      ex de,hl
04107E 30 04       1017*      jr nc,$+6
041080 ED 52       1018*      sbc hl,de
041082 13          1019*      inc de
041083 13          1020*      inc de
041084             1021*  
041084             1022*      ;Iteration 9
041084 F1          1023*      pop af
041085 17          1024*      rla
041086 ED 6A       1025*      adc hl,hl
041088 17          1026*      rla
041089 ED 6A       1027*      adc hl,hl
04108B EB          1028*      ex de,hl
04108C 29          1029*      add hl,hl
04108D ED 52       1030*      sbc hl,de
04108F 19          1031*      add hl,de
041090 EB          1032*      ex de,hl
041091 30 04       1033*      jr nc,$+6
041093 ED 52       1034*      sbc hl,de
041095 13          1035*      inc de
041096 13          1036*      inc de
041097             1037*  
041097             1038*      ;Iteration 10
041097 17          1039*      rla
041098 ED 6A       1040*      adc hl,hl
04109A 17          1041*      rla
04109B ED 6A       1042*      adc hl,hl
04109D EB          1043*      ex de,hl
04109E 29          1044*      add hl,hl
04109F ED 52       1045*      sbc hl,de
0410A1 19          1046*      add hl,de
0410A2 EB          1047*      ex de,hl
0410A3 30 04       1048*      jr nc,$+6
0410A5 ED 52       1049*      sbc hl,de
0410A7 13          1050*      inc de
0410A8 13          1051*      inc de
0410A9             1052*  
0410A9             1053*      ;Iteration 11
0410A9 17          1054*      rla
0410AA ED 6A       1055*      adc hl,hl
0410AC 17          1056*      rla
0410AD ED 6A       1057*      adc hl,hl
0410AF EB          1058*      ex de,hl
0410B0 29          1059*      add hl,hl
0410B1 ED 52       1060*      sbc hl,de
0410B3 19          1061*      add hl,de
0410B4 EB          1062*      ex de,hl
0410B5 30 04       1063*      jr nc,$+6
0410B7 ED 52       1064*      sbc hl,de
0410B9 13          1065*      inc de
0410BA 13          1066*      inc de
0410BB             1067*  
0410BB             1068*      ;Iteration 11
0410BB 17          1069*      rla
0410BC ED 6A       1070*      adc hl,hl
0410BE 17          1071*      rla
0410BF ED 6A       1072*      adc hl,hl
0410C1 EB          1073*      ex de,hl
0410C2 29          1074*      add hl,hl
0410C3 ED 52       1075*      sbc hl,de
0410C5 19          1076*      add hl,de
0410C6 EB          1077*      ex de,hl
0410C7 30 04       1078*      jr nc,$+6
0410C9 ED 52       1079*      sbc hl,de
0410CB 13          1080*      inc de
0410CC 13          1081*      inc de
0410CD             1082*  
0410CD CB 1A       1083*      rr d
0410CF CB 1B       1084*      rr e
0410D1 C9          1085*      ret
0410D2             1086*  
0410D2             1087*  sin_lut_168:
0410D2 00 00 00    1088*  	dl 0x000000 ; 0.000 00, 0.000
0410D5 06 00 00    1089*  	dl 0x000006 ; 1.406 01, 0.025
0410D8 0C 00 00    1090*  	dl 0x00000C ; 2.813 02, 0.049
0410DB 12 00 00    1091*  	dl 0x000012 ; 4.219 03, 0.074
0410DE 19 00 00    1092*  	dl 0x000019 ; 5.625 04, 0.098
0410E1 1F 00 00    1093*  	dl 0x00001F ; 7.031 05, 0.122
0410E4 25 00 00    1094*  	dl 0x000025 ; 8.438 06, 0.147
0410E7 2B 00 00    1095*  	dl 0x00002B ; 9.844 07, 0.171
0410EA 31 00 00    1096*  	dl 0x000031 ; 11.250 08, 0.195
0410ED 38 00 00    1097*  	dl 0x000038 ; 12.656 09, 0.219
0410F0 3E 00 00    1098*  	dl 0x00003E ; 14.063 0A, 0.243
0410F3 44 00 00    1099*  	dl 0x000044 ; 15.469 0B, 0.267
0410F6 4A 00 00    1100*  	dl 0x00004A ; 16.875 0C, 0.290
0410F9 50 00 00    1101*  	dl 0x000050 ; 18.281 0D, 0.314
0410FC 56 00 00    1102*  	dl 0x000056 ; 19.688 0E, 0.337
0410FF 5C 00 00    1103*  	dl 0x00005C ; 21.094 0F, 0.360
041102 61 00 00    1104*  	dl 0x000061 ; 22.500 10, 0.383
041105 67 00 00    1105*  	dl 0x000067 ; 23.906 11, 0.405
041108 6D 00 00    1106*  	dl 0x00006D ; 25.313 12, 0.428
04110B 73 00 00    1107*  	dl 0x000073 ; 26.719 13, 0.450
04110E 78 00 00    1108*  	dl 0x000078 ; 28.125 14, 0.471
041111 7E 00 00    1109*  	dl 0x00007E ; 29.531 15, 0.493
041114 83 00 00    1110*  	dl 0x000083 ; 30.938 16, 0.514
041117 88 00 00    1111*  	dl 0x000088 ; 32.344 17, 0.535
04111A 8E 00 00    1112*  	dl 0x00008E ; 33.750 18, 0.556
04111D 93 00 00    1113*  	dl 0x000093 ; 35.156 19, 0.576
041120 98 00 00    1114*  	dl 0x000098 ; 36.563 1A, 0.596
041123 9D 00 00    1115*  	dl 0x00009D ; 37.969 1B, 0.615
041126 A2 00 00    1116*  	dl 0x0000A2 ; 39.375 1C, 0.634
041129 A7 00 00    1117*  	dl 0x0000A7 ; 40.781 1D, 0.653
04112C AB 00 00    1118*  	dl 0x0000AB ; 42.188 1E, 0.672
04112F B0 00 00    1119*  	dl 0x0000B0 ; 43.594 1F, 0.690
041132 B5 00 00    1120*  	dl 0x0000B5 ; 45.000 20, 0.707
041135 B9 00 00    1121*  	dl 0x0000B9 ; 46.406 21, 0.724
041138 BD 00 00    1122*  	dl 0x0000BD ; 47.813 22, 0.741
04113B C1 00 00    1123*  	dl 0x0000C1 ; 49.219 23, 0.757
04113E C5 00 00    1124*  	dl 0x0000C5 ; 50.625 24, 0.773
041141 C9 00 00    1125*  	dl 0x0000C9 ; 52.031 25, 0.788
041144 CD 00 00    1126*  	dl 0x0000CD ; 53.438 26, 0.803
041147 D1 00 00    1127*  	dl 0x0000D1 ; 54.844 27, 0.818
04114A D4 00 00    1128*  	dl 0x0000D4 ; 56.250 28, 0.831
04114D D8 00 00    1129*  	dl 0x0000D8 ; 57.656 29, 0.845
041150 DB 00 00    1130*  	dl 0x0000DB ; 59.063 2A, 0.858
041153 DE 00 00    1131*  	dl 0x0000DE ; 60.469 2B, 0.870
041156 E1 00 00    1132*  	dl 0x0000E1 ; 61.875 2C, 0.882
041159 E4 00 00    1133*  	dl 0x0000E4 ; 63.281 2D, 0.893
04115C E7 00 00    1134*  	dl 0x0000E7 ; 64.688 2E, 0.904
04115F EA 00 00    1135*  	dl 0x0000EA ; 66.094 2F, 0.914
041162 EC 00 00    1136*  	dl 0x0000EC ; 67.500 30, 0.924
041165 EE 00 00    1137*  	dl 0x0000EE ; 68.906 31, 0.933
041168 F1 00 00    1138*  	dl 0x0000F1 ; 70.313 32, 0.942
04116B F3 00 00    1139*  	dl 0x0000F3 ; 71.719 33, 0.950
04116E F4 00 00    1140*  	dl 0x0000F4 ; 73.125 34, 0.957
041171 F6 00 00    1141*  	dl 0x0000F6 ; 74.531 35, 0.964
041174 F8 00 00    1142*  	dl 0x0000F8 ; 75.938 36, 0.970
041177 F9 00 00    1143*  	dl 0x0000F9 ; 77.344 37, 0.976
04117A FB 00 00    1144*  	dl 0x0000FB ; 78.750 38, 0.981
04117D FC 00 00    1145*  	dl 0x0000FC ; 80.156 39, 0.985
041180 FD 00 00    1146*  	dl 0x0000FD ; 81.563 3A, 0.989
041183 FE 00 00    1147*  	dl 0x0000FE ; 82.969 3B, 0.992
041186 FE 00 00    1148*  	dl 0x0000FE ; 84.375 3C, 0.995
041189 FF 00 00    1149*  	dl 0x0000FF ; 85.781 3D, 0.997
04118C FF 00 00    1150*  	dl 0x0000FF ; 87.188 3E, 0.999
04118F FF 00 00    1151*  	dl 0x0000FF ; 88.594 3F, 1.000
041192 00 01 00    1152*  	dl 0x000100 ; 90.000 40, 1.000
041195 FF 00 00    1153*  	dl 0x0000FF ; 91.406 41, 1.000
041198 FF 00 00    1154*  	dl 0x0000FF ; 92.813 42, 0.999
04119B FF 00 00    1155*  	dl 0x0000FF ; 94.219 43, 0.997
04119E FE 00 00    1156*  	dl 0x0000FE ; 95.625 44, 0.995
0411A1 FE 00 00    1157*  	dl 0x0000FE ; 97.031 45, 0.992
0411A4 FD 00 00    1158*  	dl 0x0000FD ; 98.438 46, 0.989
0411A7 FC 00 00    1159*  	dl 0x0000FC ; 99.844 47, 0.985
0411AA FB 00 00    1160*  	dl 0x0000FB ; 101.250 48, 0.981
0411AD F9 00 00    1161*  	dl 0x0000F9 ; 102.656 49, 0.976
0411B0 F8 00 00    1162*  	dl 0x0000F8 ; 104.063 4A, 0.970
0411B3 F6 00 00    1163*  	dl 0x0000F6 ; 105.469 4B, 0.964
0411B6 F4 00 00    1164*  	dl 0x0000F4 ; 106.875 4C, 0.957
0411B9 F3 00 00    1165*  	dl 0x0000F3 ; 108.281 4D, 0.950
0411BC F1 00 00    1166*  	dl 0x0000F1 ; 109.688 4E, 0.942
0411BF EE 00 00    1167*  	dl 0x0000EE ; 111.094 4F, 0.933
0411C2 EC 00 00    1168*  	dl 0x0000EC ; 112.500 50, 0.924
0411C5 EA 00 00    1169*  	dl 0x0000EA ; 113.906 51, 0.914
0411C8 E7 00 00    1170*  	dl 0x0000E7 ; 115.313 52, 0.904
0411CB E4 00 00    1171*  	dl 0x0000E4 ; 116.719 53, 0.893
0411CE E1 00 00    1172*  	dl 0x0000E1 ; 118.125 54, 0.882
0411D1 DE 00 00    1173*  	dl 0x0000DE ; 119.531 55, 0.870
0411D4 DB 00 00    1174*  	dl 0x0000DB ; 120.938 56, 0.858
0411D7 D8 00 00    1175*  	dl 0x0000D8 ; 122.344 57, 0.845
0411DA D4 00 00    1176*  	dl 0x0000D4 ; 123.750 58, 0.831
0411DD D1 00 00    1177*  	dl 0x0000D1 ; 125.156 59, 0.818
0411E0 CD 00 00    1178*  	dl 0x0000CD ; 126.563 5A, 0.803
0411E3 C9 00 00    1179*  	dl 0x0000C9 ; 127.969 5B, 0.788
0411E6 C5 00 00    1180*  	dl 0x0000C5 ; 129.375 5C, 0.773
0411E9 C1 00 00    1181*  	dl 0x0000C1 ; 130.781 5D, 0.757
0411EC BD 00 00    1182*  	dl 0x0000BD ; 132.188 5E, 0.741
0411EF B9 00 00    1183*  	dl 0x0000B9 ; 133.594 5F, 0.724
0411F2 B5 00 00    1184*  	dl 0x0000B5 ; 135.000 60, 0.707
0411F5 B0 00 00    1185*  	dl 0x0000B0 ; 136.406 61, 0.690
0411F8 AB 00 00    1186*  	dl 0x0000AB ; 137.813 62, 0.672
0411FB A7 00 00    1187*  	dl 0x0000A7 ; 139.219 63, 0.653
0411FE A2 00 00    1188*  	dl 0x0000A2 ; 140.625 64, 0.634
041201 9D 00 00    1189*  	dl 0x00009D ; 142.031 65, 0.615
041204 98 00 00    1190*  	dl 0x000098 ; 143.438 66, 0.596
041207 93 00 00    1191*  	dl 0x000093 ; 144.844 67, 0.576
04120A 8E 00 00    1192*  	dl 0x00008E ; 146.250 68, 0.556
04120D 88 00 00    1193*  	dl 0x000088 ; 147.656 69, 0.535
041210 83 00 00    1194*  	dl 0x000083 ; 149.063 6A, 0.514
041213 7E 00 00    1195*  	dl 0x00007E ; 150.469 6B, 0.493
041216 78 00 00    1196*  	dl 0x000078 ; 151.875 6C, 0.471
041219 73 00 00    1197*  	dl 0x000073 ; 153.281 6D, 0.450
04121C 6D 00 00    1198*  	dl 0x00006D ; 154.688 6E, 0.428
04121F 67 00 00    1199*  	dl 0x000067 ; 156.094 6F, 0.405
041222 61 00 00    1200*  	dl 0x000061 ; 157.500 70, 0.383
041225 5C 00 00    1201*  	dl 0x00005C ; 158.906 71, 0.360
041228 56 00 00    1202*  	dl 0x000056 ; 160.313 72, 0.337
04122B 50 00 00    1203*  	dl 0x000050 ; 161.719 73, 0.314
04122E 4A 00 00    1204*  	dl 0x00004A ; 163.125 74, 0.290
041231 44 00 00    1205*  	dl 0x000044 ; 164.531 75, 0.267
041234 3E 00 00    1206*  	dl 0x00003E ; 165.938 76, 0.243
041237 38 00 00    1207*  	dl 0x000038 ; 167.344 77, 0.219
04123A 31 00 00    1208*  	dl 0x000031 ; 168.750 78, 0.195
04123D 2B 00 00    1209*  	dl 0x00002B ; 170.156 79, 0.171
041240 25 00 00    1210*  	dl 0x000025 ; 171.563 7A, 0.147
041243 1F 00 00    1211*  	dl 0x00001F ; 172.969 7B, 0.122
041246 19 00 00    1212*  	dl 0x000019 ; 174.375 7C, 0.098
041249 12 00 00    1213*  	dl 0x000012 ; 175.781 7D, 0.074
04124C 0C 00 00    1214*  	dl 0x00000C ; 177.188 7E, 0.049
04124F 06 00 00    1215*  	dl 0x000006 ; 178.594 7F, 0.025
041252 00 00 00    1216*  	dl 0x000000 ; 180.000 80, 0.000
041255 FA FF FF    1217*  	dl 0xFFFFFA ; 181.406 81, -0.025
041258 F4 FF FF    1218*  	dl 0xFFFFF4 ; 182.813 82, -0.049
04125B EE FF FF    1219*  	dl 0xFFFFEE ; 184.219 83, -0.074
04125E E7 FF FF    1220*  	dl 0xFFFFE7 ; 185.625 84, -0.098
041261 E1 FF FF    1221*  	dl 0xFFFFE1 ; 187.031 85, -0.122
041264 DB FF FF    1222*  	dl 0xFFFFDB ; 188.438 86, -0.147
041267 D5 FF FF    1223*  	dl 0xFFFFD5 ; 189.844 87, -0.171
04126A CF FF FF    1224*  	dl 0xFFFFCF ; 191.250 88, -0.195
04126D C8 FF FF    1225*  	dl 0xFFFFC8 ; 192.656 89, -0.219
041270 C2 FF FF    1226*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
041273 BC FF FF    1227*  	dl 0xFFFFBC ; 195.469 8B, -0.267
041276 B6 FF FF    1228*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
041279 B0 FF FF    1229*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04127C AA FF FF    1230*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04127F A4 FF FF    1231*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
041282 9F FF FF    1232*  	dl 0xFFFF9F ; 202.500 90, -0.383
041285 99 FF FF    1233*  	dl 0xFFFF99 ; 203.906 91, -0.405
041288 93 FF FF    1234*  	dl 0xFFFF93 ; 205.313 92, -0.428
04128B 8D FF FF    1235*  	dl 0xFFFF8D ; 206.719 93, -0.450
04128E 88 FF FF    1236*  	dl 0xFFFF88 ; 208.125 94, -0.471
041291 82 FF FF    1237*  	dl 0xFFFF82 ; 209.531 95, -0.493
041294 7D FF FF    1238*  	dl 0xFFFF7D ; 210.938 96, -0.514
041297 78 FF FF    1239*  	dl 0xFFFF78 ; 212.344 97, -0.535
04129A 72 FF FF    1240*  	dl 0xFFFF72 ; 213.750 98, -0.556
04129D 6D FF FF    1241*  	dl 0xFFFF6D ; 215.156 99, -0.576
0412A0 68 FF FF    1242*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0412A3 63 FF FF    1243*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0412A6 5E FF FF    1244*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0412A9 59 FF FF    1245*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0412AC 55 FF FF    1246*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0412AF 50 FF FF    1247*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0412B2 4B FF FF    1248*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0412B5 47 FF FF    1249*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0412B8 43 FF FF    1250*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0412BB 3F FF FF    1251*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0412BE 3B FF FF    1252*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0412C1 37 FF FF    1253*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0412C4 33 FF FF    1254*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0412C7 2F FF FF    1255*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0412CA 2C FF FF    1256*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0412CD 28 FF FF    1257*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0412D0 25 FF FF    1258*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0412D3 22 FF FF    1259*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0412D6 1F FF FF    1260*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0412D9 1C FF FF    1261*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0412DC 19 FF FF    1262*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0412DF 16 FF FF    1263*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0412E2 14 FF FF    1264*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0412E5 12 FF FF    1265*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0412E8 0F FF FF    1266*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0412EB 0D FF FF    1267*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0412EE 0C FF FF    1268*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0412F1 0A FF FF    1269*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0412F4 08 FF FF    1270*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0412F7 07 FF FF    1271*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0412FA 05 FF FF    1272*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0412FD 04 FF FF    1273*  	dl 0xFFFF04 ; 260.156 B9, -0.985
041300 03 FF FF    1274*  	dl 0xFFFF03 ; 261.563 BA, -0.989
041303 02 FF FF    1275*  	dl 0xFFFF02 ; 262.969 BB, -0.992
041306 02 FF FF    1276*  	dl 0xFFFF02 ; 264.375 BC, -0.995
041309 01 FF FF    1277*  	dl 0xFFFF01 ; 265.781 BD, -0.997
04130C 01 FF FF    1278*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04130F 01 FF FF    1279*  	dl 0xFFFF01 ; 268.594 BF, -1.000
041312 00 FF FF    1280*  	dl 0xFFFF00 ; 270.000 C0, -1.000
041315 01 FF FF    1281*  	dl 0xFFFF01 ; 271.406 C1, -1.000
041318 01 FF FF    1282*  	dl 0xFFFF01 ; 272.813 C2, -0.999
04131B 01 FF FF    1283*  	dl 0xFFFF01 ; 274.219 C3, -0.997
04131E 02 FF FF    1284*  	dl 0xFFFF02 ; 275.625 C4, -0.995
041321 02 FF FF    1285*  	dl 0xFFFF02 ; 277.031 C5, -0.992
041324 03 FF FF    1286*  	dl 0xFFFF03 ; 278.438 C6, -0.989
041327 04 FF FF    1287*  	dl 0xFFFF04 ; 279.844 C7, -0.985
04132A 05 FF FF    1288*  	dl 0xFFFF05 ; 281.250 C8, -0.981
04132D 07 FF FF    1289*  	dl 0xFFFF07 ; 282.656 C9, -0.976
041330 08 FF FF    1290*  	dl 0xFFFF08 ; 284.063 CA, -0.970
041333 0A FF FF    1291*  	dl 0xFFFF0A ; 285.469 CB, -0.964
041336 0C FF FF    1292*  	dl 0xFFFF0C ; 286.875 CC, -0.957
041339 0D FF FF    1293*  	dl 0xFFFF0D ; 288.281 CD, -0.950
04133C 0F FF FF    1294*  	dl 0xFFFF0F ; 289.688 CE, -0.942
04133F 12 FF FF    1295*  	dl 0xFFFF12 ; 291.094 CF, -0.933
041342 14 FF FF    1296*  	dl 0xFFFF14 ; 292.500 D0, -0.924
041345 16 FF FF    1297*  	dl 0xFFFF16 ; 293.906 D1, -0.914
041348 19 FF FF    1298*  	dl 0xFFFF19 ; 295.313 D2, -0.904
04134B 1C FF FF    1299*  	dl 0xFFFF1C ; 296.719 D3, -0.893
04134E 1F FF FF    1300*  	dl 0xFFFF1F ; 298.125 D4, -0.882
041351 22 FF FF    1301*  	dl 0xFFFF22 ; 299.531 D5, -0.870
041354 25 FF FF    1302*  	dl 0xFFFF25 ; 300.938 D6, -0.858
041357 28 FF FF    1303*  	dl 0xFFFF28 ; 302.344 D7, -0.845
04135A 2C FF FF    1304*  	dl 0xFFFF2C ; 303.750 D8, -0.831
04135D 2F FF FF    1305*  	dl 0xFFFF2F ; 305.156 D9, -0.818
041360 33 FF FF    1306*  	dl 0xFFFF33 ; 306.563 DA, -0.803
041363 37 FF FF    1307*  	dl 0xFFFF37 ; 307.969 DB, -0.788
041366 3B FF FF    1308*  	dl 0xFFFF3B ; 309.375 DC, -0.773
041369 3F FF FF    1309*  	dl 0xFFFF3F ; 310.781 DD, -0.757
04136C 43 FF FF    1310*  	dl 0xFFFF43 ; 312.188 DE, -0.741
04136F 47 FF FF    1311*  	dl 0xFFFF47 ; 313.594 DF, -0.724
041372 4B FF FF    1312*  	dl 0xFFFF4B ; 315.000 E0, -0.707
041375 50 FF FF    1313*  	dl 0xFFFF50 ; 316.406 E1, -0.690
041378 55 FF FF    1314*  	dl 0xFFFF55 ; 317.813 E2, -0.672
04137B 59 FF FF    1315*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04137E 5E FF FF    1316*  	dl 0xFFFF5E ; 320.625 E4, -0.634
041381 63 FF FF    1317*  	dl 0xFFFF63 ; 322.031 E5, -0.615
041384 68 FF FF    1318*  	dl 0xFFFF68 ; 323.438 E6, -0.596
041387 6D FF FF    1319*  	dl 0xFFFF6D ; 324.844 E7, -0.576
04138A 72 FF FF    1320*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04138D 78 FF FF    1321*  	dl 0xFFFF78 ; 327.656 E9, -0.535
041390 7D FF FF    1322*  	dl 0xFFFF7D ; 329.063 EA, -0.514
041393 82 FF FF    1323*  	dl 0xFFFF82 ; 330.469 EB, -0.493
041396 88 FF FF    1324*  	dl 0xFFFF88 ; 331.875 EC, -0.471
041399 8D FF FF    1325*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04139C 93 FF FF    1326*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04139F 99 FF FF    1327*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0413A2 9F FF FF    1328*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0413A5 A4 FF FF    1329*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0413A8 AA FF FF    1330*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0413AB B0 FF FF    1331*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0413AE B6 FF FF    1332*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0413B1 BC FF FF    1333*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0413B4 C2 FF FF    1334*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0413B7 C8 FF FF    1335*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0413BA CF FF FF    1336*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0413BD D5 FF FF    1337*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0413C0 DB FF FF    1338*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0413C3 E1 FF FF    1339*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0413C6 E7 FF FF    1340*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0413C9 EE FF FF    1341*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0413CC F4 FF FF    1342*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0413CF FA FF FF    1343*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0413D2             1344*  
0413D2             1345*  atan_lut_168:
0413D2 00 00 00    1346*  	dl 0x000000 ; 000000, 0.000
0413D5 28 00 00    1347*  	dl 0x000028 ; 000001, 0.224
0413D8 51 00 00    1348*  	dl 0x000051 ; 000002, 0.448
0413DB 7A 00 00    1349*  	dl 0x00007A ; 000003, 0.671
0413DE A2 00 00    1350*  	dl 0x0000A2 ; 000004, 0.895
0413E1 CB 00 00    1351*  	dl 0x0000CB ; 000005, 1.119
0413E4 F4 00 00    1352*  	dl 0x0000F4 ; 000006, 1.343
0413E7 1D 01 00    1353*  	dl 0x00011D ; 000007, 1.566
0413EA 45 01 00    1354*  	dl 0x000145 ; 000008, 1.790
0413ED 6E 01 00    1355*  	dl 0x00016E ; 000009, 2.013
0413F0 97 01 00    1356*  	dl 0x000197 ; 00000A, 2.237
0413F3 BF 01 00    1357*  	dl 0x0001BF ; 00000B, 2.460
0413F6 E8 01 00    1358*  	dl 0x0001E8 ; 00000C, 2.684
0413F9 11 02 00    1359*  	dl 0x000211 ; 00000D, 2.907
0413FC 39 02 00    1360*  	dl 0x000239 ; 00000E, 3.130
0413FF 62 02 00    1361*  	dl 0x000262 ; 00000F, 3.353
041402 8B 02 00    1362*  	dl 0x00028B ; 000010, 3.576
041405 B3 02 00    1363*  	dl 0x0002B3 ; 000011, 3.799
041408 DC 02 00    1364*  	dl 0x0002DC ; 000012, 4.022
04140B 04 03 00    1365*  	dl 0x000304 ; 000013, 4.245
04140E 2D 03 00    1366*  	dl 0x00032D ; 000014, 4.467
041411 55 03 00    1367*  	dl 0x000355 ; 000015, 4.690
041414 7E 03 00    1368*  	dl 0x00037E ; 000016, 4.912
041417 A6 03 00    1369*  	dl 0x0003A6 ; 000017, 5.134
04141A CE 03 00    1370*  	dl 0x0003CE ; 000018, 5.356
04141D F7 03 00    1371*  	dl 0x0003F7 ; 000019, 5.578
041420 1F 04 00    1372*  	dl 0x00041F ; 00001A, 5.799
041423 48 04 00    1373*  	dl 0x000448 ; 00001B, 6.021
041426 70 04 00    1374*  	dl 0x000470 ; 00001C, 6.242
041429 98 04 00    1375*  	dl 0x000498 ; 00001D, 6.463
04142C C0 04 00    1376*  	dl 0x0004C0 ; 00001E, 6.684
04142F E8 04 00    1377*  	dl 0x0004E8 ; 00001F, 6.905
041432 11 05 00    1378*  	dl 0x000511 ; 000020, 7.125
041435 39 05 00    1379*  	dl 0x000539 ; 000021, 7.345
041438 61 05 00    1380*  	dl 0x000561 ; 000022, 7.565
04143B 89 05 00    1381*  	dl 0x000589 ; 000023, 7.785
04143E B1 05 00    1382*  	dl 0x0005B1 ; 000024, 8.005
041441 D9 05 00    1383*  	dl 0x0005D9 ; 000025, 8.224
041444 01 06 00    1384*  	dl 0x000601 ; 000026, 8.443
041447 28 06 00    1385*  	dl 0x000628 ; 000027, 8.662
04144A 50 06 00    1386*  	dl 0x000650 ; 000028, 8.881
04144D 78 06 00    1387*  	dl 0x000678 ; 000029, 9.099
041450 A0 06 00    1388*  	dl 0x0006A0 ; 00002A, 9.317
041453 C7 06 00    1389*  	dl 0x0006C7 ; 00002B, 9.535
041456 EF 06 00    1390*  	dl 0x0006EF ; 00002C, 9.752
041459 16 07 00    1391*  	dl 0x000716 ; 00002D, 9.970
04145C 3E 07 00    1392*  	dl 0x00073E ; 00002E, 10.187
04145F 65 07 00    1393*  	dl 0x000765 ; 00002F, 10.403
041462 8D 07 00    1394*  	dl 0x00078D ; 000030, 10.620
041465 B4 07 00    1395*  	dl 0x0007B4 ; 000031, 10.836
041468 DB 07 00    1396*  	dl 0x0007DB ; 000032, 11.051
04146B 03 08 00    1397*  	dl 0x000803 ; 000033, 11.267
04146E 2A 08 00    1398*  	dl 0x00082A ; 000034, 11.482
041471 51 08 00    1399*  	dl 0x000851 ; 000035, 11.697
041474 78 08 00    1400*  	dl 0x000878 ; 000036, 11.911
041477 9F 08 00    1401*  	dl 0x00089F ; 000037, 12.125
04147A C6 08 00    1402*  	dl 0x0008C6 ; 000038, 12.339
04147D ED 08 00    1403*  	dl 0x0008ED ; 000039, 12.553
041480 13 09 00    1404*  	dl 0x000913 ; 00003A, 12.766
041483 3A 09 00    1405*  	dl 0x00093A ; 00003B, 12.978
041486 61 09 00    1406*  	dl 0x000961 ; 00003C, 13.191
041489 87 09 00    1407*  	dl 0x000987 ; 00003D, 13.403
04148C AE 09 00    1408*  	dl 0x0009AE ; 00003E, 13.614
04148F D4 09 00    1409*  	dl 0x0009D4 ; 00003F, 13.825
041492 FB 09 00    1410*  	dl 0x0009FB ; 000040, 14.036
041495 21 0A 00    1411*  	dl 0x000A21 ; 000041, 14.247
041498 47 0A 00    1412*  	dl 0x000A47 ; 000042, 14.457
04149B 6D 0A 00    1413*  	dl 0x000A6D ; 000043, 14.666
04149E 94 0A 00    1414*  	dl 0x000A94 ; 000044, 14.876
0414A1 BA 0A 00    1415*  	dl 0x000ABA ; 000045, 15.085
0414A4 E0 0A 00    1416*  	dl 0x000AE0 ; 000046, 15.293
0414A7 05 0B 00    1417*  	dl 0x000B05 ; 000047, 15.501
0414AA 2B 0B 00    1418*  	dl 0x000B2B ; 000048, 15.709
0414AD 51 0B 00    1419*  	dl 0x000B51 ; 000049, 15.916
0414B0 77 0B 00    1420*  	dl 0x000B77 ; 00004A, 16.123
0414B3 9C 0B 00    1421*  	dl 0x000B9C ; 00004B, 16.329
0414B6 C2 0B 00    1422*  	dl 0x000BC2 ; 00004C, 16.535
0414B9 E7 0B 00    1423*  	dl 0x000BE7 ; 00004D, 16.740
0414BC 0C 0C 00    1424*  	dl 0x000C0C ; 00004E, 16.945
0414BF 32 0C 00    1425*  	dl 0x000C32 ; 00004F, 17.150
0414C2 57 0C 00    1426*  	dl 0x000C57 ; 000050, 17.354
0414C5 7C 0C 00    1427*  	dl 0x000C7C ; 000051, 17.558
0414C8 A1 0C 00    1428*  	dl 0x000CA1 ; 000052, 17.761
0414CB C6 0C 00    1429*  	dl 0x000CC6 ; 000053, 17.964
0414CE EB 0C 00    1430*  	dl 0x000CEB ; 000054, 18.166
0414D1 0F 0D 00    1431*  	dl 0x000D0F ; 000055, 18.368
0414D4 34 0D 00    1432*  	dl 0x000D34 ; 000056, 18.569
0414D7 58 0D 00    1433*  	dl 0x000D58 ; 000057, 18.770
0414DA 7D 0D 00    1434*  	dl 0x000D7D ; 000058, 18.970
0414DD A1 0D 00    1435*  	dl 0x000DA1 ; 000059, 19.170
0414E0 C6 0D 00    1436*  	dl 0x000DC6 ; 00005A, 19.370
0414E3 EA 0D 00    1437*  	dl 0x000DEA ; 00005B, 19.569
0414E6 0E 0E 00    1438*  	dl 0x000E0E ; 00005C, 19.767
0414E9 32 0E 00    1439*  	dl 0x000E32 ; 00005D, 19.965
0414EC 56 0E 00    1440*  	dl 0x000E56 ; 00005E, 20.163
0414EF 7A 0E 00    1441*  	dl 0x000E7A ; 00005F, 20.360
0414F2 9E 0E 00    1442*  	dl 0x000E9E ; 000060, 20.556
0414F5 C1 0E 00    1443*  	dl 0x000EC1 ; 000061, 20.752
0414F8 E5 0E 00    1444*  	dl 0x000EE5 ; 000062, 20.947
0414FB 08 0F 00    1445*  	dl 0x000F08 ; 000063, 21.142
0414FE 2C 0F 00    1446*  	dl 0x000F2C ; 000064, 21.337
041501 4F 0F 00    1447*  	dl 0x000F4F ; 000065, 21.531
041504 72 0F 00    1448*  	dl 0x000F72 ; 000066, 21.724
041507 95 0F 00    1449*  	dl 0x000F95 ; 000067, 21.917
04150A B8 0F 00    1450*  	dl 0x000FB8 ; 000068, 22.109
04150D DB 0F 00    1451*  	dl 0x000FDB ; 000069, 22.301
041510 FE 0F 00    1452*  	dl 0x000FFE ; 00006A, 22.493
041513 21 10 00    1453*  	dl 0x001021 ; 00006B, 22.683
041516 44 10 00    1454*  	dl 0x001044 ; 00006C, 22.874
041519 66 10 00    1455*  	dl 0x001066 ; 00006D, 23.063
04151C 89 10 00    1456*  	dl 0x001089 ; 00006E, 23.253
04151F AB 10 00    1457*  	dl 0x0010AB ; 00006F, 23.441
041522 CD 10 00    1458*  	dl 0x0010CD ; 000070, 23.629
041525 EF 10 00    1459*  	dl 0x0010EF ; 000071, 23.817
041528 11 11 00    1460*  	dl 0x001111 ; 000072, 24.004
04152B 33 11 00    1461*  	dl 0x001133 ; 000073, 24.191
04152E 55 11 00    1462*  	dl 0x001155 ; 000074, 24.376
041531 77 11 00    1463*  	dl 0x001177 ; 000075, 24.562
041534 99 11 00    1464*  	dl 0x001199 ; 000076, 24.747
041537 BA 11 00    1465*  	dl 0x0011BA ; 000077, 24.931
04153A DC 11 00    1466*  	dl 0x0011DC ; 000078, 25.115
04153D FD 11 00    1467*  	dl 0x0011FD ; 000079, 25.298
041540 1E 12 00    1468*  	dl 0x00121E ; 00007A, 25.481
041543 3F 12 00    1469*  	dl 0x00123F ; 00007B, 25.663
041546 60 12 00    1470*  	dl 0x001260 ; 00007C, 25.844
041549 81 12 00    1471*  	dl 0x001281 ; 00007D, 26.025
04154C A2 12 00    1472*  	dl 0x0012A2 ; 00007E, 26.206
04154F C3 12 00    1473*  	dl 0x0012C3 ; 00007F, 26.386
041552 E4 12 00    1474*  	dl 0x0012E4 ; 000080, 26.565
041555 04 13 00    1475*  	dl 0x001304 ; 000081, 26.744
041558 25 13 00    1476*  	dl 0x001325 ; 000082, 26.922
04155B 45 13 00    1477*  	dl 0x001345 ; 000083, 27.100
04155E 65 13 00    1478*  	dl 0x001365 ; 000084, 27.277
041561 85 13 00    1479*  	dl 0x001385 ; 000085, 27.453
041564 A5 13 00    1480*  	dl 0x0013A5 ; 000086, 27.629
041567 C5 13 00    1481*  	dl 0x0013C5 ; 000087, 27.805
04156A E5 13 00    1482*  	dl 0x0013E5 ; 000088, 27.979
04156D 05 14 00    1483*  	dl 0x001405 ; 000089, 28.154
041570 24 14 00    1484*  	dl 0x001424 ; 00008A, 28.327
041573 44 14 00    1485*  	dl 0x001444 ; 00008B, 28.501
041576 63 14 00    1486*  	dl 0x001463 ; 00008C, 28.673
041579 83 14 00    1487*  	dl 0x001483 ; 00008D, 28.845
04157C A2 14 00    1488*  	dl 0x0014A2 ; 00008E, 29.017
04157F C1 14 00    1489*  	dl 0x0014C1 ; 00008F, 29.187
041582 E0 14 00    1490*  	dl 0x0014E0 ; 000090, 29.358
041585 FF 14 00    1491*  	dl 0x0014FF ; 000091, 29.527
041588 1E 15 00    1492*  	dl 0x00151E ; 000092, 29.697
04158B 3C 15 00    1493*  	dl 0x00153C ; 000093, 29.865
04158E 5B 15 00    1494*  	dl 0x00155B ; 000094, 30.033
041591 79 15 00    1495*  	dl 0x001579 ; 000095, 30.201
041594 98 15 00    1496*  	dl 0x001598 ; 000096, 30.368
041597 B6 15 00    1497*  	dl 0x0015B6 ; 000097, 30.534
04159A D4 15 00    1498*  	dl 0x0015D4 ; 000098, 30.700
04159D F2 15 00    1499*  	dl 0x0015F2 ; 000099, 30.865
0415A0 10 16 00    1500*  	dl 0x001610 ; 00009A, 31.030
0415A3 2E 16 00    1501*  	dl 0x00162E ; 00009B, 31.194
0415A6 4C 16 00    1502*  	dl 0x00164C ; 00009C, 31.357
0415A9 6A 16 00    1503*  	dl 0x00166A ; 00009D, 31.520
0415AC 87 16 00    1504*  	dl 0x001687 ; 00009E, 31.682
0415AF A5 16 00    1505*  	dl 0x0016A5 ; 00009F, 31.844
0415B2 C2 16 00    1506*  	dl 0x0016C2 ; 0000A0, 32.005
0415B5 DF 16 00    1507*  	dl 0x0016DF ; 0000A1, 32.166
0415B8 FC 16 00    1508*  	dl 0x0016FC ; 0000A2, 32.326
0415BB 19 17 00    1509*  	dl 0x001719 ; 0000A3, 32.486
0415BE 36 17 00    1510*  	dl 0x001736 ; 0000A4, 32.645
0415C1 53 17 00    1511*  	dl 0x001753 ; 0000A5, 32.803
0415C4 70 17 00    1512*  	dl 0x001770 ; 0000A6, 32.961
0415C7 8C 17 00    1513*  	dl 0x00178C ; 0000A7, 33.118
0415CA A9 17 00    1514*  	dl 0x0017A9 ; 0000A8, 33.275
0415CD C5 17 00    1515*  	dl 0x0017C5 ; 0000A9, 33.431
0415D0 E2 17 00    1516*  	dl 0x0017E2 ; 0000AA, 33.587
0415D3 FE 17 00    1517*  	dl 0x0017FE ; 0000AB, 33.742
0415D6 1A 18 00    1518*  	dl 0x00181A ; 0000AC, 33.896
0415D9 36 18 00    1519*  	dl 0x001836 ; 0000AD, 34.050
0415DC 52 18 00    1520*  	dl 0x001852 ; 0000AE, 34.203
0415DF 6E 18 00    1521*  	dl 0x00186E ; 0000AF, 34.356
0415E2 8A 18 00    1522*  	dl 0x00188A ; 0000B0, 34.509
0415E5 A5 18 00    1523*  	dl 0x0018A5 ; 0000B1, 34.660
0415E8 C1 18 00    1524*  	dl 0x0018C1 ; 0000B2, 34.811
0415EB DC 18 00    1525*  	dl 0x0018DC ; 0000B3, 34.962
0415EE F7 18 00    1526*  	dl 0x0018F7 ; 0000B4, 35.112
0415F1 13 19 00    1527*  	dl 0x001913 ; 0000B5, 35.262
0415F4 2E 19 00    1528*  	dl 0x00192E ; 0000B6, 35.410
0415F7 49 19 00    1529*  	dl 0x001949 ; 0000B7, 35.559
0415FA 64 19 00    1530*  	dl 0x001964 ; 0000B8, 35.707
0415FD 7F 19 00    1531*  	dl 0x00197F ; 0000B9, 35.854
041600 99 19 00    1532*  	dl 0x001999 ; 0000BA, 36.001
041603 B4 19 00    1533*  	dl 0x0019B4 ; 0000BB, 36.147
041606 CE 19 00    1534*  	dl 0x0019CE ; 0000BC, 36.293
041609 E9 19 00    1535*  	dl 0x0019E9 ; 0000BD, 36.438
04160C 03 1A 00    1536*  	dl 0x001A03 ; 0000BE, 36.582
04160F 1D 1A 00    1537*  	dl 0x001A1D ; 0000BF, 36.726
041612 37 1A 00    1538*  	dl 0x001A37 ; 0000C0, 36.870
041615 51 1A 00    1539*  	dl 0x001A51 ; 0000C1, 37.013
041618 6B 1A 00    1540*  	dl 0x001A6B ; 0000C2, 37.155
04161B 85 1A 00    1541*  	dl 0x001A85 ; 0000C3, 37.297
04161E 9F 1A 00    1542*  	dl 0x001A9F ; 0000C4, 37.439
041621 B9 1A 00    1543*  	dl 0x001AB9 ; 0000C5, 37.579
041624 D2 1A 00    1544*  	dl 0x001AD2 ; 0000C6, 37.720
041627 EC 1A 00    1545*  	dl 0x001AEC ; 0000C7, 37.859
04162A 05 1B 00    1546*  	dl 0x001B05 ; 0000C8, 37.999
04162D 1E 1B 00    1547*  	dl 0x001B1E ; 0000C9, 38.137
041630 37 1B 00    1548*  	dl 0x001B37 ; 0000CA, 38.276
041633 50 1B 00    1549*  	dl 0x001B50 ; 0000CB, 38.413
041636 69 1B 00    1550*  	dl 0x001B69 ; 0000CC, 38.550
041639 82 1B 00    1551*  	dl 0x001B82 ; 0000CD, 38.687
04163C 9B 1B 00    1552*  	dl 0x001B9B ; 0000CE, 38.823
04163F B4 1B 00    1553*  	dl 0x001BB4 ; 0000CF, 38.959
041642 CC 1B 00    1554*  	dl 0x001BCC ; 0000D0, 39.094
041645 E5 1B 00    1555*  	dl 0x001BE5 ; 0000D1, 39.228
041648 FD 1B 00    1556*  	dl 0x001BFD ; 0000D2, 39.362
04164B 16 1C 00    1557*  	dl 0x001C16 ; 0000D3, 39.496
04164E 2E 1C 00    1558*  	dl 0x001C2E ; 0000D4, 39.629
041651 46 1C 00    1559*  	dl 0x001C46 ; 0000D5, 39.762
041654 5E 1C 00    1560*  	dl 0x001C5E ; 0000D6, 39.894
041657 76 1C 00    1561*  	dl 0x001C76 ; 0000D7, 40.025
04165A 8E 1C 00    1562*  	dl 0x001C8E ; 0000D8, 40.156
04165D A5 1C 00    1563*  	dl 0x001CA5 ; 0000D9, 40.286
041660 BD 1C 00    1564*  	dl 0x001CBD ; 0000DA, 40.416
041663 D5 1C 00    1565*  	dl 0x001CD5 ; 0000DB, 40.546
041666 EC 1C 00    1566*  	dl 0x001CEC ; 0000DC, 40.675
041669 04 1D 00    1567*  	dl 0x001D04 ; 0000DD, 40.803
04166C 1B 1D 00    1568*  	dl 0x001D1B ; 0000DE, 40.931
04166F 32 1D 00    1569*  	dl 0x001D32 ; 0000DF, 41.059
041672 49 1D 00    1570*  	dl 0x001D49 ; 0000E0, 41.186
041675 60 1D 00    1571*  	dl 0x001D60 ; 0000E1, 41.312
041678 77 1D 00    1572*  	dl 0x001D77 ; 0000E2, 41.438
04167B 8E 1D 00    1573*  	dl 0x001D8E ; 0000E3, 41.564
04167E A5 1D 00    1574*  	dl 0x001DA5 ; 0000E4, 41.689
041681 BB 1D 00    1575*  	dl 0x001DBB ; 0000E5, 41.814
041684 D2 1D 00    1576*  	dl 0x001DD2 ; 0000E6, 41.938
041687 E9 1D 00    1577*  	dl 0x001DE9 ; 0000E7, 42.061
04168A FF 1D 00    1578*  	dl 0x001DFF ; 0000E8, 42.184
04168D 15 1E 00    1579*  	dl 0x001E15 ; 0000E9, 42.307
041690 2C 1E 00    1580*  	dl 0x001E2C ; 0000EA, 42.429
041693 42 1E 00    1581*  	dl 0x001E42 ; 0000EB, 42.551
041696 58 1E 00    1582*  	dl 0x001E58 ; 0000EC, 42.672
041699 6E 1E 00    1583*  	dl 0x001E6E ; 0000ED, 42.793
04169C 84 1E 00    1584*  	dl 0x001E84 ; 0000EE, 42.913
04169F 99 1E 00    1585*  	dl 0x001E99 ; 0000EF, 43.033
0416A2 AF 1E 00    1586*  	dl 0x001EAF ; 0000F0, 43.152
0416A5 C5 1E 00    1587*  	dl 0x001EC5 ; 0000F1, 43.271
0416A8 DA 1E 00    1588*  	dl 0x001EDA ; 0000F2, 43.390
0416AB F0 1E 00    1589*  	dl 0x001EF0 ; 0000F3, 43.508
0416AE 05 1F 00    1590*  	dl 0x001F05 ; 0000F4, 43.625
0416B1 1B 1F 00    1591*  	dl 0x001F1B ; 0000F5, 43.742
0416B4 30 1F 00    1592*  	dl 0x001F30 ; 0000F6, 43.859
0416B7 45 1F 00    1593*  	dl 0x001F45 ; 0000F7, 43.975
0416BA 5A 1F 00    1594*  	dl 0x001F5A ; 0000F8, 44.091
0416BD 6F 1F 00    1595*  	dl 0x001F6F ; 0000F9, 44.206
0416C0 84 1F 00    1596*  	dl 0x001F84 ; 0000FA, 44.321
0416C3 99 1F 00    1597*  	dl 0x001F99 ; 0000FB, 44.435
0416C6 AD 1F 00    1598*  	dl 0x001FAD ; 0000FC, 44.549
0416C9 C2 1F 00    1599*  	dl 0x001FC2 ; 0000FD, 44.662
0416CC D7 1F 00    1600*  	dl 0x001FD7 ; 0000FE, 44.775
0416CF EB 1F 00    1601*  	dl 0x001FEB ; 0000FF, 44.888
0416D2 00 20 00    1602*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0416D5             1603*  
0416D5             1604*  ; ---------------------------------------------------------
0416D5             1605*  ; BEGIN HELPER ROUTINES
0416D5             1606*  ; ---------------------------------------------------------
0416D5             1607*  ;
0416D5             1608*  ; absolute value of hlu
0416D5             1609*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0416D5             1610*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0416D5             1611*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0416D5             1612*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0416D5             1613*  ; destroys: a
0416D5             1614*  abs_hlu:
0416D5 19          1615*      add hl,de
0416D6 B7          1616*      or a
0416D7 ED 52       1617*      sbc hl,de
0416D9 FA DE 16 04 1618*      jp m,@is_neg
0416DD C9          1619*      ret         ; hlu is positive or zero so we're done
0416DE             1620*  @is_neg:
0416DE F5          1621*      push af     ; otherwise, save current flags for return
0416DF CD E5 16 04 1622*      call neg_hlu ; negate hlu
0416E3 F1          1623*      pop af      ; get back flags
0416E4 C9          1624*      ret
0416E5             1625*  
0416E5             1626*  ; flip the sign of hlu
0416E5             1627*  ; inputs: hlu
0416E5             1628*  ; returns: 0-hlu, flags set appropriately for the result:
0416E5             1629*  ;         s1,z0,pv0,n1,c1 if result is negative
0416E5             1630*  ;         s0,z1,pv0,n1,c0 if result is zero
0416E5             1631*  ;         s0,z0,pv0,n1,c1 if result is positive
0416E5             1632*  ; destroys a
0416E5             1633*  neg_hlu:
0416E5 D5          1634*      push de     ; save de
0416E6 EB          1635*      ex de,hl    ; put hl into de
0416E7 21 00 00 00 1636*      ld hl,0     ; clear hl
0416EB AF          1637*      xor a       ; clear carry
0416EC ED 52       1638*      sbc hl,de   ; 0-hlu = -hlu
0416EE D1          1639*      pop de      ; get de back
0416EF C9          1640*      ret         ; easy peasy
0416F0             1641*  
0416F0             1642*  ;------------------------------------------------------------------------
0416F0             1643*  ; divide hlu by 2, inspired by above
0416F0             1644*  ;------------------------------------------------------------------------
0416F0             1645*  hlu_div2:
0416F0 22 1B 0E 04 1646*  	ld		(bitbuf1),hl
0416F4 21 1D 0E 04 1647*  	ld		hl,bitbuf1+2
0416F8 CB 1E       1648*  	rr		(hl)
0416FA 2B          1649*  	dec		hl
0416FB CB 1E       1650*  	rr		(hl)
0416FD 2B          1651*  	dec		hl
0416FE CB 1E       1652*  	rr		(hl)
041700 23          1653*  	inc		hl
041701 23          1654*  	inc		hl
041702 2A 1B 0E 04 1655*      ld hl,(bitbuf1)
041706 C9          1656*      ret
041707             1657*  
041707             1658*  ; this is my little hack to divide by 16
041707             1659*  hlu_div16:
041707 AF          1660*      xor a
041708 29          1661*      add hl,hl
041709 17          1662*      rla
04170A 29          1663*      add hl,hl
04170B 17          1664*      rla
04170C 29          1665*      add hl,hl
04170D 17          1666*      rla
04170E 29          1667*      add hl,hl
04170F 17          1668*      rla
041710 22 1D 17 04 1669*      ld (@scratch),hl
041714 32 20 17 04 1670*      ld (@scratch+3),a
041718 2A 1E 17 04 1671*      ld hl,(@scratch+1)
04171C C9          1672*      ret
04171D             1673*  @scratch: ds 4
041721             0043   
041721             0044   main:
041721 21 FF FF FF 0045       ld hl,0xFFFFFF
041725             0046       HLU_TO_A
041725 E5          0001M          push hl
041726 33          0002M          inc sp
041727 F1          0003M          pop af
041728 3B          0004M          dec sp
041729 47          0047       ld b,a
04172A CD CE 00 04 0048       call printHexBHL
04172E CD 71 00 04 0049       call printNewLine
041732             0050   
041732 3E FF       0051       ld a,0xFF
041734 CD A3 00 04 0052       call printHexA
041738 CD 71 00 04 0053       call printNewLine
04173C             0054   
04173C CD 4A 0C 04 0055       call umul824
041740 CD BC 00 04 0056       call printHexABHL
041744 CD 71 00 04 0057       call printNewLine
041748 C9          0058       ret
