        Output     Line 
       
               0001 ;
               0002 ; Title:	calcbas
               0003 ; Author:	Brandon R. Gates
               0004 ; Created:	29/10/2024
               0005 
               0006 ; ========================================
               0007 ; MODIFIED MOSLET INITIALIZATION CODE
               0008 ; ========================================
               0009 ;
               0010 ; Title:	Copy - Initialisation Code
               0011 ; Author:	Dean Belfield, Lennart Benschop
               0012 ; Created:	06/11/2022
               0013 ; Last Updated:	26/12/2022
               0014 ;
               0015 ; Modinfo:
               0016 ; 17/12/2022:	Added parameter processing
               0017 ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
               0018 ; Changed:      08/04/2924 adapt to ez80asm
               0019 ;
               0020 ASSUME	ADL = 1
               0021 INCLUDE "mos_api.inc"
              0001* ;
              0002* ; Title:	AGON MOS - API for user projects
              0003* ; Author:	Dean Belfield
              0004* ; Created:	03/08/2022
              0005* ; Last Updated:	11/11/2023
              0006* ;
              0007* ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
              0008* ;
              0009* ; Modinfo:
              0010* ; 05/08/2022:	Added mos_feof
              0011* ; 09/08/2022:	Added system variables: cursorX, cursorY
              0012* ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
              0013* ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
              0014* ; 24/09/2022:	Added mos_getError, mos_mkdir
              0015* ; 13/10/2022:	Added mos_oscli
              0016* ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
              0017* ; 04/03/2023:	Added sysvar_scrpixelIndex
              0018* ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
              0019* ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
              0020* ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
              0021* ; 22/03/2023:	The VDP commands are now indexed from 0x80
              0022* ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
              0023* ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
              0024* ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
              0025* ; 19/05/2023:	Added sysvar_scrMode
              0026* ; 05/06/2023:	Added sysvar_rtcEnable
              0027* ; 03/08/2023:	Added mos_setkbvector
              0028* ; 10/08/2023:	Added mos_getkbmap
              0029* ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
              0030* ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
              0031* ;
              0032* ; VDP control (VDU 23, 0, n)
              0033* ;
              0034* vdp_gp:			EQU 	80h
              0035* vdp_keycode:		EQU 	81h
              0036* vdp_cursor:		EQU	82h
              0037* vdp_scrchar:		EQU	83h
              0038* vdp_scrpixel:		EQU	84h
              0039* vdp_audio:		EQU	85h
              0040* vdp_mode:		EQU	86h
              0041* vdp_rtc:		EQU	87h
              0042* vdp_keystate:		EQU	88h
              0043* vdp_logicalcoords:	EQU	C0h
              0044* vdp_terminalmode:	EQU	FFh
              0045* 
              0046* ; MOS high level functions
              0047* ;
              0048* mos_getkey:		EQU	00h
              0049* mos_load:		EQU	01h
              0050* mos_save:		EQU	02h
              0051* mos_cd:			EQU	03h
              0052* mos_dir:		EQU	04h
              0053* mos_del:		EQU	05h
              0054* mos_ren:		EQU	06h
              0055* mos_mkdir:		EQU	07h
              0056* mos_sysvars:		EQU	08h
              0057* mos_editline:		EQU	09h
              0058* mos_fopen:		EQU	0Ah
              0059* mos_fclose:		EQU	0Bh
              0060* mos_fgetc:		EQU	0Ch
              0061* mos_fputc:		EQU	0Dh
              0062* mos_feof:		EQU	0Eh
              0063* mos_getError:		EQU	0Fh
              0064* mos_oscli:		EQU	10h
              0065* mos_copy:		EQU	11h
              0066* mos_getrtc:		EQU	12h
              0067* mos_setrtc:		EQU	13h
              0068* mos_setintvector:	EQU	14h
              0069* mos_uopen:		EQU	15h
              0070* mos_uclose:		EQU	16h
              0071* mos_ugetc:		EQU	17h
              0072* mos_uputc:		EQU 	18h
              0073* mos_getfil:		EQU	19h
              0074* mos_fread:		EQU	1Ah
              0075* mos_fwrite:		EQU	1Bh
              0076* mos_flseek:		EQU	1Ch
              0077* mos_setkbvector:	EQU	1Dh
              0078* mos_getkbmap:		EQU	1Eh
              0079* mos_i2c_open:		EQU	1Fh
              0080* mos_i2c_close:		EQU	20h
              0081* mos_i2c_write:		EQU	21h
              0082* mos_i2c_read:		EQU	22h
              0083* 
              0084* 
              0085* ; FatFS file access functions
              0086* ;
              0087* ffs_fopen:		EQU	80h
              0088* ffs_fclose:		EQU	81h
              0089* ffs_fread:		EQU	82h
              0090* ffs_fwrite:		EQU	83h
              0091* ffs_flseek:		EQU	84h
              0092* ffs_ftruncate:		EQU	85h
              0093* ffs_fsync:		EQU	86h
              0094* ffs_fforward:		EQU	87h
              0095* ffs_fexpand:		EQU	88h
              0096* ffs_fgets:		EQU	89h
              0097* ffs_fputc:		EQU	8Ah
              0098* ffs_fputs:		EQU	8Bh
              0099* ffs_fprintf:		EQU	8Ch
              0100* ffs_ftell:		EQU	8Dh
              0101* ffs_feof:		EQU	8Eh
              0102* ffs_fsize:		EQU	8Fh
              0103* ffs_ferror:		EQU	90h
              0104* 
              0105* ; FatFS directory access functions
              0106* ;
              0107* ffs_dopen:		EQU	91h
              0108* ffs_dclose:		EQU	92h
              0109* ffs_dread:		EQU	93h
              0110* ffs_dfindfirst:		EQU	94h
              0111* ffs_dfindnext:		EQU	95h
              0112* 
              0113* ; FatFS file and directory management functions
              0114* ;
              0115* ffs_stat:		EQU	96h
              0116* ffs_unlink:		EQU	97h
              0117* ffs_rename:		EQU	98h
              0118* ffs_chmod:		EQU	99h
              0119* ffs_utime:		EQU	9Ah
              0120* ffs_mkdir:		EQU	9Bh
              0121* ffs_chdir:		EQU	9Ch
              0122* ffs_chdrive:		EQU	9Dh
              0123* ffs_getcwd:		EQU	9Eh
              0124* 
              0125* ; FatFS volume management and system configuration functions
              0126* ;
              0127* ffs_mount:		EQU	9Fh
              0128* ffs_mkfs:		EQU	A0h
              0129* ffs_fdisk:		EQU	A1h
              0130* ffs_getfree:		EQU	A2h
              0131* ffs_getlabel:		EQU	A3h
              0132* ffs_setlabel:		EQU	A4h
              0133* ffs_setcp:		EQU	A5h
              0134* 
              0135* ; File access modes
              0136* ;
              0137* fa_read:		EQU	01h
              0138* fa_write:		EQU	02h
              0139* fa_open_existing:	EQU	00h
              0140* fa_create_new:		EQU	04h
              0141* fa_create_always:	EQU	08h
              0142* fa_open_always:		EQU	10h
              0143* fa_open_append:		EQU	30h
              0144* 
              0145* ; System variable indexes for api_sysvars
              0146* ; Index into _sysvars in globals.asm
              0147* ;
              0148* sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
              0149* sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
              0150* sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
              0151* sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
              0152* sysvar_cursorX:		EQU	07h	; 1: Cursor X position
              0153* sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
              0154* sysvar_scrchar:		EQU	09h	; 1: Character read from screen
              0155* sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
              0156* sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
              0157* sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
              0158* sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
              0159* sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
              0160* sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
              0161* sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
              0162* sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
              0163* sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
              0164* sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
              0165* sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
              0166* sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
              0167* sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
              0168* sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
              0169* sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
              0170* sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
              0171* sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
              0172* sysvar_scrMode:		EQU	27h	; 1: Screen mode
              0173* sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
              0174* sysvar_mouseX:		EQU	29h	; 2: Mouse X position
              0175* sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
              0176* sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
              0177* sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
              0178* sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
              0179* sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
              0180* ;
              0181* ; Flags for the VPD protocol
              0182* ;
              0183* vdp_pflag_cursor:	EQU	00000001b
              0184* vdp_pflag_scrchar:	EQU	00000010b
              0185* vdp_pflag_point:	EQU	00000100b
              0186* vdp_pflag_audio:	EQU	00001000b
              0187* vdp_pflag_mode:		EQU	00010000b
              0188* vdp_pflag_rtc:		EQU	00100000b
              0189* vdp_pflag_mouse:	EQU	01000000b
              0190* ; vdp_pflag_buffered:	EQU	10000000b
              0191* 
              0192* 
              0193* ; FatFS structures
              0194* ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
              0195* ;
              0196* ; Object ID and allocation information (FFOBJID)
              0197* FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
              0198* FFOBJID.id:       EQU 3    ; Hosting volume mount ID
              0199* FFOBJID.attr:     EQU 5    ; Object attribute
              0200* FFOBJID.stat:     EQU 6    ; Object chain status
              0201* FFOBJID.sclust:   EQU 7    ; Object data start cluster
              0202* FFOBJID.objsize:  EQU 11   ; Object size
              0203* FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
              0204* ;
              0205* ; File object structure (FIL)
              0206* ;
              0207* FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0208* FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
              0209* FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
              0210* FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
              0211* FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
              0212* FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
              0213* FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
              0214* FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
              0215* FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
              0216* ;
              0217* ; Directory object structure (DIR)
              0218* ;
              0219* DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
              0220* DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
              0221* DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
              0222* DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
              0223* DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
              0224* DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
              0225* DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
              0226* DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
              0227* ;
              0228* ; File information structure (FILINFO)
              0229* ;
              0230* FILINFO.fsize:    EQU 0    ; File size
              0231* FILINFO.fdate:    EQU 4    ; Modified date
              0232* FILINFO.ftime:    EQU 6    ; Modified time
              0233* FILINFO.fattrib:  EQU 8    ; File attribute
              0234* FILINFO.altname:  EQU 9    ; Alternative file name
              0235* FILINFO.fname:    EQU 22   ; Primary file name
              0236* FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
              0237* ;
              0238* ; Macro for calling the API
              0239* ; Parameters:
              0240* ; - function: One of the function numbers listed above
              0241* ;
              0242* MACRO MOSCALL	function
              0243* LD	A, function
              0244* RST.LIS	08h
              0245* ENDMACRO
               0022 ORG 0x0B0000 ; Is a moslet
               0023 
               0024 MACRO PROGNAME
               0025 ASCIZ "calcbas"
               0026 ENDMACRO
               0027 ;
               0028 ; Start in ADL mode
               0029 ;
0B0000 C3      0030 JP	_start
0B0001 45 
0B0002 00 
0B0003 0B 
               0031 ;
               0032 ; The header stuff is from byte 64 onwards
               0033 ;
               0034 _exec_name:
               0035 PROGNAME			; The executable name, only used in argv
0B0004 63     0001M ASCIZ "calcbas"
0B0005 61 
0B0006 6C 
0B0007 63 
0B0007 62   
0B0008 61 
0B0009 73 
0B000A 00 
               0036 
0B000C FF      0037 ALIGN	64
0B000D FF 
0B000E FF 
0B000F FF 
0B000F FF   
0B0010 FF 
0B0011 FF 
0B0012 FF 
0B0012 FF   
0B0013 FF 
0B0014 FF 
0B0015 FF 
0B0015 FF   
0B0016 FF 
0B0017 FF 
0B0018 FF 
0B0018 FF   
0B0019 FF 
0B001A FF 
0B001B FF 
0B001B FF   
0B001C FF 
0B001D FF 
0B001E FF 
0B001E FF   
0B001F FF 
0B0020 FF 
0B0021 FF 
0B0021 FF   
0B0022 FF 
0B0023 FF 
0B0024 FF 
0B0024 FF   
0B0025 FF 
0B0026 FF 
0B0027 FF 
0B0027 FF   
0B0028 FF 
0B0029 FF 
0B002A FF 
0B002A FF   
0B002B FF 
0B002C FF 
0B002D FF 
0B002D FF   
0B002E FF 
0B002F FF 
0B0030 FF 
0B0030 FF   
0B0031 FF 
0B0032 FF 
0B0033 FF 
               0038 
0B0040 4D      0039 DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0041 4F 
0B0042 53 
0B0043 00      0040 DB	00h			; MOS header version 0
0B0044 01      0041 DB	01h			; Flag for run mode (0: Z80, 1: ADL)
               0042 ;
               0043 ; And the code follows on immediately after the header
               0044 ;
               0045 _start:
0B0045 F5      0046 PUSH	AF			; Preserve the registers
0B0046 C5      0047 PUSH	BC
0B0047 D5      0048 PUSH	DE
0B0048 DD      0049 PUSH	IX
0B0049 E5 
0B004A FD      0050 PUSH	IY
0B004B E5 
0B004C ED      0051 LD	A, MB			; Save MB
0B004D 6E 
0B004E F5      0052 PUSH 	AF
0B004F AF      0053 XOR 	A
0B0050 ED      0054 LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0051 6D 
               0055 
               0056 ; ; intialize BASIC-specific stuff
               0057 ; 			LD		(_sps), SP 		; Preserve the 24-bit stack pointer (SPS)
               0058 ; 			CALL		_clear_ram
               0059 ; ; end of BASIC-specific initialization
               0060 
0B0052 DD      0061 LD	IX, argv_ptrs		; The argv array pointer address
0B0053 21 
0B0054 31 
0B0055 02 
0B0055 0B   
0B0057 DD      0062 PUSH	IX
0B0058 E5 
0B0059 CD      0063 CALL	_parse_params		; Parse the parameters
0B005A 70 
0B005B 00 
0B005C 0B 
0B005D DD      0064 POP	IX			; IX: argv
0B005E E1 
0B005F 06      0065 LD	B, 0			;  C: argc
0B0060 00 
0B0061 CD      0066 CALL	_main			; Start user code
0B0062 90 
0B0063 02 
0B0064 0B 
               0067 
0B0065 F1      0068 POP 	AF
0B0066 ED      0069 LD	MB, A
0B0067 6D 
0B0068 FD      0070 POP	IY			; Restore registers
0B0069 E1 
0B006A DD      0071 POP	IX
0B006B E1 
0B006C D1      0072 POP	DE
0B006D C1      0073 POP	BC
0B006E F1      0074 POP	AF
0B006F C9      0075 RET
               0076 
               0077 ; Parse the parameter string into a C array
               0078 ; Parameters
               0079 ; - HL: Address of parameter string
               0080 ; - IX: Address for array pointer storage
               0081 ; Returns:
               0082 ; -  C: Number of parameters parsed
               0083 ;
0B0070 01      0084 _parse_params:		LD	BC, _exec_name
0B0071 04 
0B0072 00 
0B0073 0B 
0B0074 DD      0085 LD	(IX+0), BC		; ARGV[0] = the executable name
0B0075 0F 
0B0076 00 
0B0077 ED      0086 LEA     IX, IX+3
0B0078 32 
0B0079 03 
0B007A CD      0087 CALL	_skip_spaces		; Skip HL past any leading spaces
0B007B B2 
0B007C 00 
0B007D 0B 
               0088 ;
0B007E 01      0089 LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B007F 01 
0B0080 00 
0B0081 00 
0B0082 06      0090 LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0083 0F 
               0091 ;
               0092 _parse_params_1:
0B0084 C5      0093 PUSH	BC			; Stack ARGC
0B0085 E5      0094 PUSH	HL			; Stack start address of token
0B0086 CD      0095 CALL	_get_token		; Get the next token
0B0087 A3 
0B0088 00 
0B0089 0B 
0B008A 79      0096 LD	A, C			; A: Length of the token in characters
0B008B D1      0097 POP	DE			; Start address of token (was in HL)
0B008C C1      0098 POP	BC			; ARGC
0B008D B7      0099 OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8      0100 RET	Z
               0101 ;
0B008F DD      0102 LD	(IX+0), DE		; Store the pointer to the token
0B0090 1F 
0B0091 00 
0B0092 E5      0103 PUSH	HL			; DE=HL
0B0093 D1      0104 POP	DE
0B0094 CD      0105 CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0095 B2 
0B0096 00 
0B0097 0B 
0B0098 AF      0106 XOR	A
0B0099 12      0107 LD	(DE), A			; Zero-terminate the token
0B009A ED      0108 LEA  	IX, IX+3			; Advance to next pointer position
0B009B 32 
0B009C 03 
0B009D 0C      0109 INC	C			; Increment ARGC
0B009E 79      0110 LD	A, C			; Check for C >= A
0B009F B8      0111 CP	B
0B00A0 38      0112 JR	C, _parse_params_1	; And loop
0B00A1 E2 
0B00A2 C9      0113 RET
               0114 
               0115 ; Get the next token
               0116 ; Parameters:
               0117 ; - HL: Address of parameter string
               0118 ; Returns:
               0119 ; - HL: Address of first character after token
               0120 ; -  C: Length of token (in characters)
               0121 ;
0B00A3 0E      0122 _get_token:		LD	C, 0			; Initialise length
0B00A4 00 
0B00A5 7E      0123 @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7      0124 OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8      0125 RET 	Z
0B00A8 FE      0126 CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00A9 0D 
0B00AA C8      0127 RET	Z
0B00AB FE      0128 CP	' '			; Exit if space (end of token)
0B00AC 20 
0B00AD C8      0129 RET	Z
0B00AE 23      0130 INC	HL			; Advance to next character
0B00AF 0C      0131 INC 	C			; Increment length
0B00B0 18      0132 JR	@B
0B00B1 F3 
               0133 
               0134 ; Skip spaces in the parameter string
               0135 ; Parameters:
               0136 ; - HL: Address of parameter string
               0137 ; Returns:
               0138 ; - HL: Address of next none-space character
               0139 ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
               0140 ;
0B00B2 7E      0141 _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE      0142 CP	' '			; Exit if not space
0B00B4 20 
0B00B5 C0      0143 RET	NZ
0B00B6 23      0144 INC	HL			; Advance to next character
0B00B7 18      0145 JR	_skip_spaces		; Increment length
0B00B8 F9 
               0146 
               0147 ; ========================================
               0148 ; BASIC INITIALIZATION CODE FROM basic/init.asm
               0149 ; ========================================
               0150 ;
               0151 ; ;Clear the application memory
               0152 ; ;
               0153 ; _clear_ram:
               0154 ;             push hl
               0155 ;             PUSH		BC
               0156 ; 			LD		HL, RAM_START
               0157 ; 			LD		DE, RAM_START + 1
               0158 ; 			LD		BC, RAM_END - RAM_START - 1
               0159 ; 			XOR		A
               0160 ; 			LD		(HL), A
               0161 ; 			LDIR
               0162 ; 			POP		BC
               0163 ;             pop hl
               0164 ; 			RET
               0165 
               0166 ; ========================================
               0167 ; BEGIN APPLICATION CODE
               0168 ; ========================================
               0169 
               0170 ; API INCLUDES
               0171 
               0172 ; APPLICATION INCLUDES
               0173 include "temp.inc"
              0001* 
              0002* ; global scratch memory for registers
0B00B9 00     0003* uaf: dl 0
0B00BA 00 
0B00BB 00 
0B00BC 00     0004* uhl: dl 0
0B00BD 00 
0B00BE 00 
0B00BF 00     0005* ubc: dl 0
0B00C0 00 
0B00C1 00 
0B00C2 00     0006* ude: dl 0
0B00C3 00 
0B00C4 00 
0B00C5 00     0007* uix: dl 0
0B00C6 00 
0B00C7 00 
0B00C8 00     0008* uiy: dl 0
0B00C9 00 
0B00CA 00 
0B00CB 00     0009* usp: dl 0
0B00CC 00 
0B00CD 00 
0B00CE 00     0010* upc: dl 0
0B00CF 00 
0B00D0 00 
              0011* 
0B00D1 20     0012* str_afu: db " af=",0
0B00D2 61 
0B00D3 66 
0B00D4 3D 
0B00D4 00   
0B00D6 20     0013* str_hlu: db " hl=",0
0B00D7 68 
0B00D8 6C 
0B00D9 3D 
0B00D9 00   
0B00DB 20     0014* str_bcu: db " bc=",0
0B00DC 62 
0B00DD 63 
0B00DE 3D 
0B00DE 00   
0B00E0 20     0015* str_deu: db " de=",0
0B00E1 64 
0B00E2 65 
0B00E3 3D 
0B00E3 00   
0B00E5 20     0016* str_ixu: db " ix=",0
0B00E6 69 
0B00E7 78 
0B00E8 3D 
0B00E8 00   
0B00EA 20     0017* str_iyu: db " iy=",0
0B00EB 69 
0B00EC 79 
0B00ED 3D 
0B00ED 00   
              0018* 
              0019* ; test the sign of HL
              0020* ; inputs: HL obviously
              0021* ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
              0022* ; destroys: flags
              0023* MACRO sign_hlu
              0024* add hl,de
              0025* or a
              0026* sbc hl,de
              0027* ENDMACRO
              0028* 
              0029* MACRO PUSH_ALL
              0030* ex af,af'
              0031* exx
              0032* push af
              0033* push hl
              0034* push bc
              0035* push de
              0036* 
              0037* ex af,af'
              0038* exx
              0039* push af
              0040* push hl
              0041* push bc
              0042* push de
              0043* push ix
              0044* push iy
              0045* ENDMACRO
              0046* 
              0047* MACRO POP_ALL
              0048* pop iy
              0049* pop ix
              0050* pop de
              0051* pop bc
              0052* pop hl
              0053* pop af
              0054* ex af,af'
              0055* exx
              0056* 
              0057* pop de
              0058* pop bc
              0059* pop hl
              0060* pop af
              0061* ex af,af'
              0062* exx
              0063* ENDMACRO
              0064* 
              0065* ; Print a 24-bit HEX number
              0066* ; HLU: Number to print
              0067* printHex24:
              0068* ; PUSH	HL      ; 4 cycles
              0069* ; LD		HL, 2   ; 4 cycles
              0070* ; ADD		HL, SP  ; 1 cycle
              0071* ; LD		A, (HL) ; 2 cycles
              0072* ; POP		HL      ; 4 cycles
              0073* ;                 ; 15 cycles total
0B00EF E5     0074* push hl ; 4 cycles
0B00F0 33     0075* inc sp ; 1 cycle
0B00F1 F1     0076* pop af  ; 4 cycles
0B00F2 3B     0077* dec sp ; 1 cycle
              0078* ; 10 cycles total
0B00F3 CD     0079* CALL	printHex8
0B00F4 FD 
0B00F5 00 
0B00F6 0B 
              0080* ; Print a 16-bit HEX number
              0081* ; HL: Number to print
              0082* printHex16:
0B00F7 7C     0083* LD		A,H
0B00F8 CD     0084* CALL	printHex8
0B00F9 FD 
0B00FA 00 
0B00FB 0B 
0B00FC 7D     0085* LD		A,L
              0086* ; Print an 8-bit HEX number
              0087* ; A: Number to print
              0088* printHex8:
0B00FD 4F     0089* LD		C,A
0B00FE 1F     0090* RRA
0B00FF 1F     0091* RRA
0B0100 1F     0092* RRA
0B0101 1F     0093* RRA
0B0102 CD     0094* CALL	@F
0B0103 07 
0B0104 01 
0B0105 0B 
0B0106 79     0095* LD		A,C
              0096* @@:
0B0107 E6     0097* AND		0Fh
0B0108 0F 
0B0109 C6     0098* ADD		A,90h
0B010A 90 
0B010B 27     0099* DAA
0B010C CE     0100* ADC		A,40h
0B010D 40 
0B010E 27     0101* DAA
0B010F 5B     0102* RST.LIL	10h
0B0110 D7 
0B0111 C9     0103* RET
              0104* 
              0105* ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
              0106* ; Print a zero-terminated string
              0107* ; HL: Pointer to string
              0108* printString:
0B0112 C5     0109* PUSH	BC
0B0113 01     0110* LD		BC,0
0B0114 00 
0B0115 00 
0B0116 00 
0B0117 3E     0111* LD 	 	A,0
0B0118 00 
0B0119 5B     0112* RST.LIL 18h
0B011A DF 
0B011B C1     0113* POP		BC
0B011C C9     0114* RET
              0115* ; print a VDU sequence
              0116* ; HL: Pointer to VDU sequence - <1 byte length> <data>
              0117* sendVDUsequence:
0B011D C5     0118* PUSH	BC
0B011E 01     0119* LD		BC, 0
0B011F 00 
0B0120 00 
0B0121 00 
0B0122 4E     0120* LD		C, (HL)
0B0123 5B     0121* RST.LIL	18h
0B0124 DF 
0B0125 C1     0122* POP		BC
0B0126 C9     0123* RET
              0124* ; Print Newline sequence to VDP
              0125* printNewLine:
0B0127 F5     0126* push af ; for some reason rst.lil 10h sets carry flag
0B0128 3E     0127* LD	A, '\r'
0B0129 0D 
0B012A 5B     0128* RST.LIL 10h
0B012B D7 
0B012C 3E     0129* LD	A, '\n'
0B012D 0A 
0B012E 5B     0130* RST.LIL 10h
0B012F D7 
0B0130 F1     0131* pop af
0B0131 C9     0132* RET
              0133* 
              0134* ; print registers to screen in hexidecimal format
              0135* ; inputs: none
              0136* ; outputs: values of every register printed to screen
              0137* ;    values of each register in global scratch memory
              0138* ; destroys: nothing
              0139* dumpRegistersHex:
              0140* ; store everything in scratch
0B0132 22     0141* ld (uhl),hl
0B0133 BC 
0B0134 00 
0B0135 0B 
0B0136 ED     0142* ld (ubc),bc
0B0137 43 
0B0138 BF 
0B0139 00 
0B0139 0B   
0B013B ED     0143* ld (ude),de
0B013C 53 
0B013D C2 
0B013E 00 
0B013E 0B   
0B0140 DD     0144* ld (uix),ix
0B0141 22 
0B0142 C5 
0B0143 00 
0B0143 0B   
0B0145 FD     0145* ld (uiy),iy
0B0146 22 
0B0147 C8 
0B0148 00 
0B0148 0B   
0B014A F5     0146* push af ; fml
0B014B E1     0147* pop hl  ; thanks, zilog
0B014C 22     0148* ld (uaf),hl
0B014D B9 
0B014E 00 
0B014F 0B 
0B0150 F5     0149* push af ; dammit
              0150* 
              0151* ; home the cursor
              0152* ; call vdu_home_cursor
              0153* ; call printNewLine
              0154* 
              0155* ; print each register
0B0151 21     0156* ld hl,str_afu
0B0152 D1 
0B0153 00 
0B0154 0B 
0B0155 CD     0157* call printString
0B0156 12 
0B0157 01 
0B0158 0B 
0B0159 2A     0158* ld hl,(uaf)
0B015A B9 
0B015B 00 
0B015C 0B 
0B015D CD     0159* call printHex24
0B015E EF 
0B015F 00 
0B0160 0B 
              0160* ; call printNewLine
              0161* 
0B0161 21     0162* ld hl,str_hlu
0B0162 D6 
0B0163 00 
0B0164 0B 
0B0165 CD     0163* call printString
0B0166 12 
0B0167 01 
0B0168 0B 
0B0169 2A     0164* ld hl,(uhl)
0B016A BC 
0B016B 00 
0B016C 0B 
0B016D CD     0165* call printHex24
0B016E EF 
0B016F 00 
0B0170 0B 
              0166* ; call printNewLine
              0167* 
0B0171 21     0168* ld hl,str_bcu
0B0172 DB 
0B0173 00 
0B0174 0B 
0B0175 CD     0169* call printString
0B0176 12 
0B0177 01 
0B0178 0B 
0B0179 2A     0170* ld hl,(ubc)
0B017A BF 
0B017B 00 
0B017C 0B 
0B017D CD     0171* call printHex24
0B017E EF 
0B017F 00 
0B0180 0B 
              0172* ; call printNewLine
              0173* 
0B0181 21     0174* ld hl,str_deu
0B0182 E0 
0B0183 00 
0B0184 0B 
0B0185 CD     0175* call printString
0B0186 12 
0B0187 01 
0B0188 0B 
0B0189 2A     0176* ld hl,(ude)
0B018A C2 
0B018B 00 
0B018C 0B 
0B018D CD     0177* call printHex24
0B018E EF 
0B018F 00 
0B0190 0B 
              0178* ; call printNewLine
              0179* 
0B0191 21     0180* ld hl,str_ixu
0B0192 E5 
0B0193 00 
0B0194 0B 
0B0195 CD     0181* call printString
0B0196 12 
0B0197 01 
0B0198 0B 
0B0199 2A     0182* ld hl,(uix)
0B019A C5 
0B019B 00 
0B019C 0B 
0B019D CD     0183* call printHex24
0B019E EF 
0B019F 00 
0B01A0 0B 
              0184* ; call printNewLine
              0185* 
0B01A1 21     0186* ld hl,str_iyu
0B01A2 EA 
0B01A3 00 
0B01A4 0B 
0B01A5 CD     0187* call printString
0B01A6 12 
0B01A7 01 
0B01A8 0B 
0B01A9 2A     0188* ld hl,(uiy)
0B01AA C8 
0B01AB 00 
0B01AC 0B 
0B01AD CD     0189* call printHex24
0B01AE EF 
0B01AF 00 
0B01B0 0B 
              0190* ; call printNewLine
              0191* 
              0192* ; call vdu_vblank
              0193* 
0B01B1 CD     0194* call printNewLine
0B01B2 27 
0B01B3 01 
0B01B4 0B 
              0195* ; restore everything
0B01B5 2A     0196* ld hl, (uhl)
0B01B6 BC 
0B01B7 00 
0B01B8 0B 
0B01B9 ED     0197* ld bc, (ubc)
0B01BA 4B 
0B01BB BF 
0B01BC 00 
0B01BC 0B   
0B01BE ED     0198* ld de, (ude)
0B01BF 5B 
0B01C0 C2 
0B01C1 00 
0B01C1 0B   
0B01C3 DD     0199* ld ix, (uix)
0B01C4 2A 
0B01C5 C5 
0B01C6 00 
0B01C6 0B   
0B01C8 FD     0200* ld iy, (uiy)
0B01C9 2A 
0B01CA C8 
0B01CB 00 
0B01CB 0B   
0B01CD F1     0201* pop af
              0202* ; all done
0B01CE C9     0203* ret
              0204* 
              0205* dumpRegistersHexPrime:
0B01CF D9     0206* exx
0B01D0 08     0207* ex af,af'
0B01D1 CD     0208* call dumpRegistersHex
0B01D2 32 
0B01D3 01 
0B01D4 0B 
0B01D5 08     0209* ex af,af'
0B01D6 D9     0210* exx
0B01D7 C9     0211* ret
              0212* 
              0213* ; additionally dump prime registers
              0214* ; inputs: none
              0215* ; outputs: values of every register printed to screen
              0216* ; destroys: nothing
              0217* dumpRegistersHexAll:
0B01D8 CD     0218* call dumpRegistersHex
0B01D9 32 
0B01DA 01 
0B01DB 0B 
0B01DC 08     0219* ex af,af'
0B01DD D9     0220* exx
0B01DE CD     0221* call dumpRegistersHex
0B01DF 32 
0B01E0 01 
0B01E1 0B 
0B01E2 08     0222* ex af,af'
0B01E3 D9     0223* exx
0B01E4 C9     0224* ret
              0225* 
              0226* ; print bytes from an address to the screen in hexidecimal format
              0227* ; inputs: hl = address of first byte to print, a = number of bytes to print
              0228* ; outputs: values of each byte printed to screen separated by spaces
              0229* ; destroys: nothing
              0230* dumpMemoryHex:
              0231* ; save registers to the stack
0B01E5 C5     0232* push bc
0B01E6 E5     0233* push hl
0B01E7 F5     0234* push af
              0235* 
              0236* ; print the address and separator
0B01E8 CD     0237* call printHex24
0B01E9 EF 
0B01EA 00 
0B01EB 0B 
0B01EC 3E     0238* ld a,':'
0B01ED 3A 
0B01EE 5B     0239* rst.lil 10h
0B01EF D7 
0B01F0 3E     0240* ld a,' '
0B01F1 20 
0B01F2 5B     0241* rst.lil 10h
0B01F3 D7 
              0242* 
              0243* ; set b to be our loop counter
0B01F4 F1     0244* pop af
0B01F5 47     0245* ld b,a
0B01F6 E1     0246* pop hl
0B01F7 E5     0247* push hl
0B01F8 F5     0248* push af
              0249* @loop:
              0250* ; print the byte
0B01F9 7E     0251* ld a,(hl)
0B01FA CD     0252* call printHex8
0B01FB FD 
0B01FC 00 
0B01FD 0B 
              0253* ; print a space
0B01FE 3E     0254* ld a,' '
0B01FF 20 
0B0200 5B     0255* rst.lil 10h
0B0201 D7 
0B0202 23     0256* inc hl
0B0203 10     0257* djnz @loop
0B0204 F4 
0B0205 CD     0258* call printNewLine
0B0206 27 
0B0207 01 
0B0208 0B 
              0259* 
              0260* ; restore everything
0B0209 F1     0261* pop af
0B020A E1     0262* pop hl
0B020B C1     0263* pop bc
              0264* 
              0265* ; all done
0B020C C9     0266* ret
               0174 include "fpp.inc"
              0001* ;
              0002* ; Title:	BBC Basic Interpreter - Z80 version
              0003* ;		Z80 Floating Point Package
              0004* ; Author:	(C) Copyright  R.T.Russell  1986
              0005* ; Modified By:	Dean Belfield
              0006* ; Created:	03/05/2022
              0007* ; Last Updated:	07/06/2023
              0008* ;
              0009* ; Modinfo:
              0010* ; 26/10/1986:	Version 0.0
              0011* ; 14/12/1988:	Vesion 0.1 (Bug Fix)
              0012* ; 12/05/2023:	Modified by Dean Belfield
              0013* ; 07/06/2023:	Modified to run in ADL mode
              0014* ;
              0015* ;BINARY FLOATING POINT REPRESENTATION:
              0016* ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
              0017* ;    8 BIT EXCESS-128 SIGNED EXPONENT
              0018* ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
              0019* ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
              0020* ;
              0021* ;BINARY INTEGER REPRESENTATION:
              0022* ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
              0023* ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
              0024* ;
              0025* ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
              0026* ;                            EXPONENT - C
              0027* ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
              0028* ;                               EXPONENT - B
              0029* 
              0030* 
              0031* 
              0032* ;
              0033* ;MULA, MULB - MULTIPLICATION PRIMITIVE.
              0034* ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
              0035* ;    Inputs: A = loop counter (usually -32)
              0036* ;            H'L'HL = 0
              0037* ;    Destroys: D,E,H,L,D',E',H',L',A,F
              0038* ;
0B020D B7     0039* MULA:			OR      A               ;CLEAR CARRY
0B020E D9     0040* MUL0:			EXX
0B020F CB     0041* RR      D               ;MULTIPLIER/2
0B0210 1A 
0B0211 CB     0042* RR      E
0B0212 1B 
0B0213 D9     0043* EXX
0B0214 CB     0044* RR      D
0B0215 1A 
0B0216 CB     0045* RR      E
0B0217 1B 
0B0218 30     0046* JR      NC,MUL1
0B0219 07 
0B021A 52     0047* ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B021B 09 
0B021C D9     0048* EXX
0B021D 52     0049* ADC.S   HL,BC
0B021E ED 
0B021F 4A 
0B0220 D9     0050* EXX
0B0221 3C     0051* MUL1:			INC     A
0B0222 F0     0052* RET     P
0B0223 D9     0053* MULB:			EXX
0B0224 CB     0054* RR      H               ;PRODUCT/2
0B0225 1C 
0B0226 CB     0055* RR      L
0B0227 1D 
0B0228 D9     0056* EXX
0B0229 CB     0057* RR      H
0B022A 1C 
0B022B CB     0058* RR      L
0B022C 1D 
0B022D C3     0059* JP      MUL0
0B022E 0E 
0B022F 02 
0B0230 0B 
              0060* 
               0175 ; include "basic/basic.asm" ; must be last so that RAM has room for BASIC operations
               0176 
               0177 ; Storage for the argv array pointers
               0178 min_args: equ 2
               0179 argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0231 00      0180 argv_ptrs:		    BLKP	argv_ptrs_max, 0
0B0232 00 
0B0233 00 
0B0234 00 
0B0234 00   
0B0235 00 
0B0236 00 
0B0237 00 
0B0237 00   
0B0238 00 
0B0239 00 
0B023A 00 
0B023A 00   
0B023B 00 
0B023C 00 
0B023D 00 
0B023D 00   
0B023E 00 
0B023F 00 
0B0240 00 
0B0240 00   
0B0241 00 
0B0242 00 
0B0243 00 
0B0243 00   
0B0244 00 
0B0245 00 
0B0246 00 
0B0246 00   
0B0247 00 
0B0248 00 
0B0249 00 
0B0249 00   
0B024A 00 
0B024B 00 
0B024C 00 
0B024C 00   
0B024D 00 
0B024E 00 
0B024F 00 
0B024F 00   
0B0250 00 
0B0251 00 
0B0252 00 
0B0252 00   
0B0253 00 
0B0254 00 
0B0255 00 
               0181 _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
               0182 
               0183 ; GLOBAL MESSAGE STRINGS
0B0264 55      0184 str_usage: ASCIZ "Usage: scratch <args>\r\n"
0B0265 73 
0B0266 61 
0B0267 67 
0B0267 65   
0B0268 3A 
0B0269 20 
0B026A 73 
0B026A 63   
0B026B 72 
0B026C 61 
0B026D 74 
0B026D 63   
0B026E 68 
0B026F 20 
0B0270 3C 
0B0270 61   
0B0271 72 
0B0272 67 
0B0273 73 
0B0273 3E   
0B0274 0D 
0B0275 0A 
0B0276 00 
0B027C 45      0185 str_error: ASCIZ "Error!\r\n"
0B027D 72 
0B027E 72 
0B027F 6F 
0B027F 72   
0B0280 21 
0B0281 0D 
0B0282 0A 
0B0282 00   
0B0285 53      0186 str_success: ASCIZ "Success!\r\n"
0B0286 75 
0B0287 63 
0B0288 63 
0B0288 65   
0B0289 73 
0B028A 73 
0B028B 21 
0B028B 0D   
0B028C 0A 
0B028D 00 
               0187 
               0188 ; ========= MAIN LOOP =========
               0189 ; The main routine
               0190 ; IXU: argv - pointer to array of parameters
               0191 ;   C: argc - number of parameters
               0192 ; Returns:
               0193 ;  HL: Error code, or 0 if OK
               0194 
               0195 _main:
0B0290 79      0196 ld a,c              ; how many arguments?
0B0291 FE      0197 cp min_args         ; not enough?
0B0292 02 
0B0293 30      0198 jr nc,main          ; if enough, go to main loop
0B0294 27 
0B0295 21      0199 ld hl,str_usage     ; if not enough, print usage
0B0296 64 
0B0297 02 
0B0298 0B 
0B0299 CD      0200 call printString
0B029A 12 
0B029B 01 
0B029C 0B 
               0201 ; fall through to _main_end_error
               0202 
               0203 _main_end_error:
0B029D 21      0204 ld hl,str_error     ; print error message
0B029E 7C 
0B029F 02 
0B02A0 0B 
0B02A1 CD      0205 call printString
0B02A2 12 
0B02A3 01 
0B02A4 0B 
0B02A5 21      0206 ld hl,19            ; return error code 19
0B02A6 13 
0B02A7 00 
0B02A8 00 
0B02A9 C9      0207 ret
               0208 
               0209 ; begin BASIC-specific end code
               0210 ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B02AA ED      0211 _basic_end:			LD		SP, (_sps)		; Restore the stack pointer
0B02AB 7B 
0B02AC 61 
0B02AD 02 
0B02AD 0B   
               0212 ; fall through to _main_end_ok
               0213 ; end BASIC-specific end code
               0214 
               0215 _main_end_ok:
0B02AF 21      0216 ld hl,str_success   ; print success message
0B02B0 85 
0B02B1 02 
0B02B2 0B 
0B02B3 CD      0217 call printString
0B02B4 12 
0B02B5 01 
0B02B6 0B 
0B02B7 21      0218 ld hl,0             ; return 0 for success
0B02B8 00 
0B02B9 00 
0B02BA 00 
0B02BB C9      0219 ret
               0220 
               0221 ; ========= BEGIN CUSTOM MAIN LOOP =========
               0222 main:
0B02BC 0D      0223 dec c               ; decrement the argument count to skip the program name
0B02BD ED      0224 lea ix,ix+3         ; point to the first real argument (argv_ptrs+3)
0B02BE 32 
0B02BF 03 
0B02C0 DD      0225 ld hl,(ix)          ; get the first argument in case hl doesn't land here with it
0B02C1 27 
0B02C2 00 
               0226 
               0227 
0B02C3 C3      0228 jp _main_end_ok     ; return success
0B02C4 AF 
0B02C5 02 
0B02C6 0B 
               0229 
               0230 
               0231 ; ========== HELPER FUNCTIONS ==========
               0232 ;
               0233 ; ; get the next argument after ix as a floating point number
               0234 ; ; inputs: ix = pointer to the argument string
               0235 ; ; outputs: HLH'L'C = floating point number, ix points to the next argument
               0236 ; ; destroys: everything except iy, including prime registers
               0237 ; get_arg_float:
               0238 ;     lea ix,ix+3 ; point to the next argument
               0239 ;     push ix ; preserve
               0240 ;     ld ix,(ix)  ; point to argument string
               0241 ;     call VAL ; convert the string to a float
               0242 ;     pop ix ; restore
               0243 ;     ret ; return with the value in HLH'L'C
               0244 ;
               0245 ; get the next argument after ix as a string
               0246 ; inputs: ix = pointer to the argument string
               0247 ; outputs: HL = pointer to the argument string, ix points to the next argument
               0248 ; destroys: a, h, l, f
               0249 get_arg_text:
0B02C7 ED      0250 lea ix,ix+3 ; point to the next argument
0B02C8 32 
0B02C9 03 
0B02CA DD      0251 ld hl,(ix)  ; get the argument string
0B02CB 27 
0B02CC 00 
0B02CD C9      0252 ret
               0253 ;
               0254 ; match the next argument after ix to the dispatch table at iy
               0255 ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
               0256 ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
               0257 ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
               0258 ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
               0259 ; destroys: a, hl, de, ix, iy, flags
               0260 match_next:
0B02CE ED      0261 lea ix,ix+3         ; point to the next argument
0B02CF 32 
0B02D0 03 
               0262 @loop:
0B02D1 FD      0263 ld hl,(iy)          ; pointer argument dispatch record
0B02D2 27 
0B02D3 00 
               0264 sign_hlu            ; check for list terminator
0B02D4 19     0001M add hl,de
0B02D5 B7     0002M or a
0B02D6 ED     0003M sbc hl,de
0B02D7 52 
0B02D8 CA      0265 jp z,@no_match      ; if a=0, return error
0B02D9 F0 
0B02DA 02 
0B02DB 0B 
0B02DC 23      0266 inc hl              ; skip over jp instruction
0B02DD 23      0267 inc hl
0B02DE DD      0268 ld de,(ix)          ; pointer to the argument string
0B02DF 17 
0B02E0 00 
0B02E1 CD      0269 call str_equal      ; compare the argument to the dispatch table entry
0B02E2 07 
0B02E3 03 
0B02E4 0B 
0B02E5 CA      0270 jp z,@match         ; if equal, return success
0B02E6 F2 
0B02E7 02 
0B02E8 0B 
0B02E9 ED      0271 lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B02EA 33 
0B02EB 03 
0B02EC C3      0272 jp @loop            ; and loop
0B02ED D1 
0B02EE 02 
0B02EF 0B 
               0273 @no_match:
0B02F0 3C      0274 inc a               ; no match so return a=1 and zero flag reset
0B02F1 C9      0275 ret
               0276 @match:
0B02F2 FD      0277 ld iy,(iy)          ; get the function pointer
0B02F3 37 
0B02F4 00 
0B02F5 C9      0278 ret                 ; return a=0 and zero flag set
               0279 
               0280 ; same as match_next, but prints the parameter if a match is found
               0281 match_next_and_print:
0B02F6 CD      0282 call match_next
0B02F7 CE 
0B02F8 02 
0B02F9 0B 
0B02FA C0      0283 ret nz ; no match found
0B02FB ED      0284 lea ix,ix-3
0B02FC 32 
0B02FD FD 
0B02FE CD      0285 call get_arg_text ; hl points to the operator string
0B02FF C7 
0B0300 02 
0B0301 0B 
0B0302 CD      0286 call print_param
0B0303 12 
0B0304 03 
0B0305 0B 
0B0306 C9      0287 ret
               0288 
               0289 ; compare two zero-terminated strings for equality, case-sensitive
               0290 ; hl: pointer to first string, de: pointer to second string
               0291 ; returns: z if equal, nz if not equal
               0292 ; destroys: a, hl, de
               0293 str_equal:
0B0307 1A      0294 ld a,(de)           ; get the first character
0B0308 BE      0295 cp (hl)             ; compare to the second character
0B0309 C0      0296 ret nz              ; if not equal, return
0B030A B7      0297 or a
0B030B C8      0298 ret z               ; if equal and zero, return
0B030C 23      0299 inc hl              ; next character
0B030D 13      0300 inc de
0B030E C3      0301 jp str_equal        ; loop until end of string
0B030F 07 
0B0310 03 
0B0311 0B 
               0302 
               0303 ; print the parameter string pointed to by ix
               0304 ; destroys: a, hl
               0305 print_param:
0B0312 DD      0306 ld hl,(ix)          ; get the parameter pointer
0B0313 27 
0B0314 00 
0B0315 CD      0307 call printString    ; print the parameter string
0B0316 12 
0B0317 01 
0B0318 0B 
0B0319 3E      0308 ld a,' '            ; print a space separator
0B031A 20 
0B031B 5B      0309 rst.lil $10
0B031C D7 
0B031D C9      0310 ret
               0311 
               0312 ; print the parameters
               0313 ; inputs: b = number of parameters, ix = pointer to the parameters
               0314 ; destroys: a, hl, bc
               0315 print_params:
0B031E 41      0316 ld b,c              ; loop counter = number of parameters
0B031F DD      0317 push ix             ; save the pointer to the parameters
0B0320 E5 
               0318 @loop:
0B0321 C5      0319 push bc             ; save the loop counter
0B0322 CD      0320 call print_param    ; print the parameter
0B0323 12 
0B0324 03 
0B0325 0B 
0B0326 ED      0321 lea ix,ix+3         ; next parameter pointer
0B0327 32 
0B0328 03 
0B0329 C1      0322 pop bc              ; get back the loop counter
0B032A 10      0323 djnz @loop          ; loop until done
0B032B F5 
0B032C DD      0324 pop ix              ; restore the pointer to the parameters
0B032D E1 
0B032E C9      0325 ret
               0326 
               0327 debug_print:
0B032F CD      0328 call printNewLine
0B0330 27 
0B0331 01 
0B0332 0B 
0B0333 CD      0329 call dumpRegistersHexAll
0B0334 D8 
0B0335 01 
0B0336 0B 
0B0337 CD      0330 call printNewLine
0B0338 27 
0B0339 01 
0B033A 0B 
0B033B C9      0331 ret
