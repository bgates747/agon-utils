PC     Output      Line
040000             0001       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD B5 17 04 0020       call main
040050             0021   
040050             0022   exit:
040050 FD E1       0023       pop iy
040052 DD E1       0024       pop ix
040054 D1          0025       pop de
040055 C1          0026       pop bc
040056 F1          0027       pop af
040057 21 00 00 00 0028       ld hl,0
04005B             0029   
04005B C9          0030       ret
04005C             0031   
04005C             0032   ; API INCLUDES
04005C             0033       include "functions.inc"
04005C             0001*      MACRO printChar char
04005C             0002*          LD A, char
04005C             0003*          RST.LIL 10h
04005C             0004*      ENDMACRO
04005C             0005*  
04005C             0006*  ; test the sign of HL
04005C             0007*  ; inputs: HL obviously
04005C             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04005C             0009*  ; destroys: flags
04005C             0010*      MACRO sign_hlu
04005C             0011*          add hl,de
04005C             0012*          or a
04005C             0013*          sbc hl,de
04005C             0014*      ENDMACRO
04005C             0015*  
04005C             0016*  ; Simulated call to subroutine at HL
04005C             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04005C             0018*  ; outputs: whatever the subroutine does, including HL and BC
04005C             0019*  ; destroys: only what the subroutine does, but always BC
04005C             0020*      MACRO callHL
04005C             0021*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0022*          push bc       ; which constitutes the return address
04005C             0023*          jp   (hl)     ; Jump to the address in HL
04005C             0024*      ENDMACRO
04005C             0025*  
04005C             0026*  ; Simulated call to subroutine at IX
04005C             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04005C             0028*  ; outputs: whatever the subroutine does, including IX and BC
04005C             0029*  ; destroys: only what the subroutine does, but always BC
04005C             0030*      MACRO callIX
04005C             0031*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0032*          push bc       ; which constitutes the return address
04005C             0033*          jp   (ix)     ; Jump to the address in IX
04005C             0034*      ENDMACRO
04005C             0035*  
04005C             0036*  ; Simulated call to soubroutinte at IY
04005C             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04005C             0038*  ; outputs: whatever the subroutine does, including IY and BC
04005C             0039*  ; destroys: only what the subroutine does, but always BC
04005C             0040*      MACRO callIY
04005C             0041*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0042*          push bc       ; which constitutes the return address
04005C             0043*          jp   (iy)     ; Jump to the address in IY
04005C             0044*      ENDMACRO
04005C             0045*  
04005C             0046*  ; put the value in HLU into the accumulator
04005C             0047*  ; destroys: af
04005C             0048*      MACRO HLU_TO_A
04005C             0049*          push hl ; 4 cycles
04005C             0050*          inc sp ; 1 cycle
04005C             0051*          pop af  ; 4 cycles
04005C             0052*          dec sp ; 1 cycle
04005C             0053*                 ; 10 cycles total
04005C             0054*      ENDMACRO
04005C             0055*  
04005C             0056*  A_TO_HLU:
04005C             0057*      ; call is 7 cycles
04005C 22 69 00 04 0058*      ld (@scratch),hl ; 7 cycles
040060 32 6B 00 04 0059*      ld (@scratch+2),a ; 5 cycles
040064 2A 69 00 04 0060*      ld hl,(@scratch) ; 7 cycles
040068 C9          0061*      ret ; 6 cycles
040069             0062*          ; 25 cycles total
040069 00 00 00    0063*  @scratch: dl 0
04006C             0064*  
04006C             0065*      MACRO A_TO_HLU
04006C             0066*          push.s af
04006C             0067*          inc sp
04006C             0068*          push.s hl
04006C             0069*          pop hl
04006C             0070*          inc sp
04006C             0071*          inc sp
04006C             0072*      ENDMACRO
04006C             0073*  
04006C             0074*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04006C             0075*  ; Print a zero-terminated string
04006C             0076*  ; HL: Pointer to string
04006C             0077*  printString:
04006C C5          0078*  	PUSH	BC
04006D 01 00 00 00 0079*  	LD		BC,0
040071 3E 00       0080*  	LD 	 	A,0
040073 5B DF       0081*  	RST.LIL 18h
040075 C1          0082*  	POP		BC
040076 C9          0083*  	RET
040077             0084*  ; print a VDU sequence
040077             0085*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040077             0086*  sendVDUsequence:
040077 C5          0087*  	PUSH	BC
040078 01 00 00 00 0088*  	LD		BC, 0
04007C 4E          0089*  	LD		C, (HL)
04007D 5B DF       0090*  	RST.LIL	18h
04007F C1          0091*  	POP		BC
040080 C9          0092*  	RET
040081             0093*  ; Print Newline sequence to VDP
040081             0094*  printNewLine:
040081 F5          0095*      push af ; for some reason rst.lil 10h sets carry flag
040082 3E 0D       0096*  	LD	A, '\r'
040084 5B D7       0097*  	RST.LIL 10h
040086 3E 0A       0098*  	LD	A, '\n'
040088 5B D7       0099*  	RST.LIL 10h
04008A F1          0100*      pop af
04008B C9          0101*  	RET
04008C             0102*  
04008C             0103*  ; Print a 24-bit HEX number
04008C             0104*  ; HLU: Number to print
04008C             0105*  printHex24:
04008C             0106*  	; PUSH	HL      ; 4 cycles
04008C             0107*  	; LD		HL, 2   ; 4 cycles
04008C             0108*  	; ADD		HL, SP  ; 1 cycle
04008C             0109*  	; LD		A, (HL) ; 2 cycles
04008C             0110*  	; POP		HL      ; 4 cycles
04008C             0111*      ;                 ; 15 cycles total
04008C E5          0112*      push hl ; 4 cycles
04008D 33          0113*      inc sp ; 1 cycle
04008E F1          0114*      pop af  ; 4 cycles
04008F 3B          0115*      dec sp ; 1 cycle
040090             0116*              ; 10 cycles total
040090 CD 9A 00 04 0117*  	CALL	printHex8
040094             0118*  ; Print a 16-bit HEX number
040094             0119*  ; HL: Number to print
040094             0120*  printHex16:
040094 7C          0121*  	LD		A,H
040095 CD 9A 00 04 0122*  	CALL	printHex8
040099 7D          0123*  	LD		A,L
04009A             0124*  ; Print an 8-bit HEX number
04009A             0125*  ; A: Number to print
04009A             0126*  printHex8:
04009A 4F          0127*  	LD		C,A
04009B 1F          0128*  	RRA
04009C 1F          0129*  	RRA
04009D 1F          0130*  	RRA
04009E 1F          0131*  	RRA
04009F CD A4 00 04 0132*  	CALL	@F
0400A3 79          0133*  	LD		A,C
0400A4             0134*  @@:
0400A4 E6 0F       0135*  	AND		0Fh
0400A6 C6 90       0136*  	ADD		A,90h
0400A8 27          0137*  	DAA
0400A9 CE 40       0138*  	ADC		A,40h
0400AB 27          0139*  	DAA
0400AC 5B D7       0140*  	RST.LIL	10h
0400AE C9          0141*  	RET
0400AF             0142*  
0400AF             0143*  printHexA:
0400AF F5          0144*      push af
0400B0 C5          0145*      push bc
0400B1 CD 9A 00 04 0146*      call printHex8
0400B5 3E 20       0147*      ld a,' '
0400B7 5B D7       0148*      rst.lil 10h
0400B9 C1          0149*      pop bc
0400BA F1          0150*      pop af
0400BB C9          0151*      ret
0400BC             0152*  
0400BC             0153*  printHexHL:
0400BC F5          0154*      push af
0400BD C5          0155*      push bc
0400BE CD 94 00 04 0156*      call printHex16
0400C2 3E 20       0157*      ld a,' '
0400C4 5B D7       0158*      rst.lil 10h
0400C6 C1          0159*      pop bc
0400C7 F1          0160*      pop af
0400C8 C9          0161*      ret
0400C9             0162*  
0400C9             0163*  printHexUHL:
0400C9 F5          0164*      push af
0400CA C5          0165*      push bc
0400CB CD 8C 00 04 0166*      call printHex24
0400CF 3E 20       0167*      ld a,' '
0400D1 5B D7       0168*      rst.lil 10h
0400D3 C1          0169*      pop bc
0400D4 F1          0170*      pop af
0400D5 C9          0171*      ret
0400D6             0172*  
0400D6             0173*  printHexAUHL:
0400D6 F5          0174*      push af
0400D7 C5          0175*      push bc
0400D8 CD 9A 00 04 0176*      call printHex8
0400DC 3E 2E       0177*      ld a,'.'
0400DE 5B D7       0178*      rst.lil 10h
0400E0 CD 8C 00 04 0179*      call printHex24
0400E4 3E 20       0180*      ld a,' '
0400E6 5B D7       0181*      rst.lil 10h
0400E8 C1          0182*      pop bc
0400E9 F1          0183*      pop af
0400EA C9          0184*      ret
0400EB             0185*  
0400EB             0186*  printHexABHL:
0400EB             0187*  ; preserve registers
0400EB C5          0188*      push bc ; b will be ok c will not
0400EC F5          0189*      push af ; will get totally destroyed
0400ED             0190*  ; print a
0400ED CD 9A 00 04 0191*      call printHex8
0400F1             0192*  ; print b
0400F1 78          0193*      ld a,b
0400F2 CD 9A 00 04 0194*      call printHex8
0400F6             0195*  ; print hl
0400F6 CD 94 00 04 0196*      call printHex16
0400FA             0197*  ; restore registers
0400FA F1          0198*      pop af
0400FB C1          0199*      pop bc
0400FC C9          0200*      ret
0400FD             0201*  
0400FD             0202*  printHexBHL:
0400FD             0203*  ; preserve registers
0400FD C5          0204*      push bc ; b will be ok c will not
0400FE F5          0205*      push af ; will get totally destroyed
0400FF             0206*  ; print b
0400FF 78          0207*      ld a,b
040100 CD 9A 00 04 0208*      call printHex8
040104             0209*  ; print hl
040104 CD 94 00 04 0210*      call printHex16
040108             0211*  ; restore registers
040108 F1          0212*      pop af
040109 C1          0213*      pop bc
04010A C9          0214*      ret
04010B             0215*  
04010B             0216*  printHexCDE:
04010B             0217*  ; preserve registers
04010B C5          0218*      push bc ; b will be ok c will not
04010C F5          0219*      push af ; will get totally destroyed
04010D             0220*  ; print c
04010D 79          0221*      ld a,c
04010E CD 9A 00 04 0222*      call printHex8
040112             0223*  ; print de
040112 EB          0224*      ex de,hl
040113 CD 94 00 04 0225*      call printHex16
040117 EB          0226*      ex de,hl
040118             0227*  ; restore registers
040118 F1          0228*      pop af
040119 C1          0229*      pop bc
04011A C9          0230*      ret
04011B             0231*  
04011B             0232*  ; Print a 0x HEX prefix
04011B             0233*  DisplayHexPrefix:
04011B 3E 30       0234*  	LD	A, '0'
04011D 5B D7       0235*  	RST.LIL 10h
04011F 3E 78       0236*  	LD	A, 'x'
040121 5B D7       0237*  	RST.LIL 10h
040123 C9          0238*  	RET
040124             0239*  
040124             0240*      MACRO printDecBC
040124             0241*          push hl
040124             0242*          push bc
040124             0243*          pop hl
040124             0244*          call printDec
040124             0245*          pop hl
040124             0246*      ENDMACRO
040124             0247*  
040124             0248*      MACRO printDecDE
040124             0249*          push hl
040124             0250*          push de
040124             0251*          pop hl
040124             0252*          call printDec
040124             0253*          pop hl
040124             0254*      ENDMACRO
040124             0255*  
040124             0256*      MACRO printDecHL
040124             0257*          call printDec
040124             0258*      ENDMACRO
040124             0259*  
040124             0260*      MACRO printDecIX
040124             0261*          push hl
040124             0262*          push ix
040124             0263*          pop hl
040124             0264*          call printDec
040124             0265*          pop hl
040124             0266*      ENDMACRO
040124             0267*  
040124             0268*      MACRO printDecIY
040124             0269*          push hl
040124             0270*          push iy
040124             0271*          pop hl
040124             0272*          call printDec
040124             0273*          pop hl
040124             0274*      ENDMACRO
040124             0275*  
040124             0276*  
040124             0277*  ; Prints the right justified decimal value in HL without leading zeroes
040124             0278*  ; HL : Value to print
040124             0279*  ; preserves all registers and flags
040124             0280*  printDec:
040124             0281*  ; BEGIN MY CODE
040124             0282*  ; back up all the things
040124 F5          0283*      push af
040125 C5          0284*      push bc
040126 D5          0285*      push de
040127 E5          0286*      push hl
040128             0287*  ; END MY CODE
040128 11 50 01 04 0288*  	LD	 DE, _printDecBuffer
04012C CD 60 01 04 0289*  	CALL u24_to_ascii
040130             0290*  ; BEGIN MY CODE
040130             0291*  ; replace leading zeroes with spaces
040130 21 50 01 04 0292*      LD	 HL, _printDecBuffer
040134 06 07       0293*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040136             0294*  @loop:
040136 7E          0295*      LD	 A, (HL)
040137 FE 30       0296*      CP	 '0'
040139 C2 47 01 04 0297*      JP	 NZ, @done
04013D 3E 20       0298*      LD   A, ' '
04013F 77          0299*      LD	 (HL), A
040140 23          0300*      INC	 HL
040141 CD 53 12 04 0301*      CALL vdu_cursor_forward
040145 10 EF       0302*      DJNZ @loop
040147             0303*  @done:
040147             0304*  ; END MY CODE
040147             0305*  	; LD	 HL, _printDecBuffer
040147 CD 6C 00 04 0306*  	CALL printString
04014B             0307*  ; BEGIN MY CODE
04014B             0308*  ; restore all the things
04014B E1          0309*      pop hl
04014C D1          0310*      pop de
04014D C1          0311*      pop bc
04014E F1          0312*      pop af
04014F             0313*  ; END MY CODE
04014F C9          0314*  	RET
040150 00 00 00 00 0315*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040160             0316*  
040160             0317*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040160             0318*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040160             0319*  ; so it will allways be 8 characters length
040160             0320*  ; HL : Value to convert to string
040160             0321*  ; DE : pointer to buffer, at least 8 byte + 0
040160             0322*  u24_to_ascii:
040160 01 80 69 67 0323*  	LD	 BC,-10000000
040164 CD 97 01 04 0324*  	CALL @one_digit
040168 01 C0 BD F0 0325*  	LD	 BC,-1000000
04016C CD 97 01 04 0326*  	CALL @one_digit
040170 01 60 79 FE 0327*  	LD	 BC,-100000
040174 CD 97 01 04 0328*  	CALL @one_digit
040178 01 F0 D8 FF 0329*  	LD   BC,-10000
04017C CD 97 01 04 0330*  	CALL @one_digit
040180 01 18 FC FF 0331*  	LD   BC,-1000
040184 CD 97 01 04 0332*  	CALL @one_digit
040188 01 9C FF FF 0333*  	LD   BC,-100
04018C CD 97 01 04 0334*  	CALL @one_digit
040190 0E F6       0335*  	LD   C,-10
040192 CD 97 01 04 0336*  	CALL @one_digit
040196 48          0337*  	LD   C,B
040197             0338*  @one_digit:
040197 3E 2F       0339*  	LD   A,'0'-1
040199             0340*  @divide_me:
040199 3C          0341*  	INC  A
04019A 09          0342*  	ADD  HL,BC
04019B 38 FC       0343*  	JR   C,@divide_me
04019D ED 42       0344*  	SBC  HL,BC
04019F 12          0345*  	LD   (DE),A
0401A0 13          0346*  	INC  DE
0401A1 C9          0347*  	RET
0401A2             0348*  
0401A2             0349*  print_u24:
0401A2 11 50 01 04 0350*      ld de,_printDecBuffer
0401A6 CD 60 01 04 0351*      call u24_to_ascii
0401AA 21 50 01 04 0352*      ld hl,_printDecBuffer
0401AE CD 6C 00 04 0353*      call printString
0401B2 C9          0354*      ret
0401B3             0355*  
0401B3             0356*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0401B3             0357*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0401B3             0358*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0401B3             0359*  u168_to_ascii:
0401B3             0360*  ; add a leading space to make room for sign flag if needed
0401B3 3E 20       0361*      ld a,' '
0401B5 12          0362*      ld (de),a
0401B6 13          0363*      inc de
0401B7             0364*  ; Convert integer part
0401B7 E5          0365*      push hl               ; Save HL (weâ€™ll need the fractional part later)
0401B8 CD 03 08 04 0366*      call shift_hlu_r1b    ; Shift to get integer portion in HL
0401BC 01 F0 D8 FF 0367*      ld   bc, -10000
0401C0 CD E3 01 04 0368*      call @one_int
0401C4 01 18 FC FF 0369*      ld   bc, -1000
0401C8 CD E3 01 04 0370*      call @one_int
0401CC 01 9C FF FF 0371*      ld   bc, -100
0401D0 CD E3 01 04 0372*      call @one_int
0401D4 0E F6       0373*      ld   c, -10
0401D6 CD E3 01 04 0374*      call @one_int
0401DA 48          0375*      ld   c, b
0401DB CD E3 01 04 0376*      call @one_int
0401DF C3 EE 01 04 0377*      jp   @frac            ; Jump to fractional part conversion
0401E3             0378*  @one_int:
0401E3 3E 2F       0379*      ld   a, '0' - 1       ; Start ASCII character at '0'
0401E5             0380*  @divide_me:
0401E5 3C          0381*      inc  a
0401E6 09          0382*      add  hl, bc           ; Accumulate until overflow
0401E7 38 FC       0383*      jr   c, @divide_me
0401E9 ED 42       0384*      sbc  hl, bc           ; Remove excess after overflow
0401EB 12          0385*      ld   (de), a          ; Store ASCII digit
0401EC 13          0386*      inc  de
0401ED C9          0387*      ret
0401EE             0388*  ; Convert fractional part
0401EE             0389*  @frac:
0401EE 3E 2E       0390*      ld   a, '.'           ; Decimal point
0401F0 12          0391*      ld   (de), a
0401F1 13          0392*      inc  de
0401F2 E1          0393*      pop  hl               ; Restore HL with original fraction
0401F3 06 03       0394*      ld   b, 3             ; Loop counter for 3 fractional digits
0401F5             0395*  @frac_loop:
0401F5 26 0A       0396*      ld   h, 10            ; Load multiplier for fractional part
0401F7 ED 6C       0397*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0401F9 3E 30       0398*      ld   a, '0'
0401FB 84          0399*      add  a, h             ; Convert integer part to ASCII
0401FC 12          0400*      ld   (de), a
0401FD 13          0401*      inc  de
0401FE 10 F5       0402*      djnz @frac_loop       ; Repeat for each fractional digit
040200             0403*  ; Add null terminator
040200 AF          0404*      xor  a                ; Null terminator
040201 12          0405*      ld   (de), a
040202 C9          0406*      ret
040203             0407*  
040203             0408*  print_u168:
040203 11 50 01 04 0409*      ld de,_printDecBuffer
040207 CD B3 01 04 0410*      call u168_to_ascii
04020B 21 50 01 04 0411*      ld hl,_printDecBuffer
04020F CD 6C 00 04 0412*      call printString
040213 C9          0413*      ret
040214             0414*  
040214             0415*  ; signed version of u168_to_ascii
040214             0416*  s168_to_ascii:
040214 D5          0417*      push de ; save starting address of buffer
040215 CD 62 05 04 0418*      call abs_hlu
040219 F5          0419*      push af ; save sign flag
04021A CD B3 01 04 0420*      call u168_to_ascii
04021E F1          0421*      pop af ; restore sign flag
04021F D1          0422*      pop de ; restore starting address of buffer
040220 F0          0423*      ret p ; hlu was positive so nothing to do
040221 3E 2D       0424*      ld a,'-'
040223 12          0425*      ld (de),a
040224 C9          0426*      ret
040225             0427*  
040225             0428*  print_s168:
040225 11 50 01 04 0429*      ld de,_printDecBuffer
040229 CD 14 02 04 0430*      call s168_to_ascii
04022D 21 50 01 04 0431*      ld hl,_printDecBuffer
040231 CD 6C 00 04 0432*      call printString
040235 C9          0433*      ret
040236             0434*  
040236             0435*  ; #### new functions added by Brandon R. Gates ####
040236             0436*  
040236             0437*  ; print the binary representation of the 8-bit value in a
040236             0438*  ; destroys a, hl, bc
040236             0439*  printBin8:
040236 06 08       0440*      ld b,8      ; loop counter for 8 bits
040238 21 53 02 04 0441*      ld hl,@cmd  ; set hl to the low byte of the output string
04023C             0442*                  ; (which will be the high bit of the value in a)
04023C             0443*  @loop:
04023C 07          0444*      rlca ; put the next highest bit into carry
04023D 38 04       0445*      jr c,@one
04023F 36 30       0446*      ld (hl),'0'
040241 18 02       0447*      jr @next_bit
040243             0448*  @one:
040243 36 31       0449*      ld (hl),'1'
040245             0450*  @next_bit:
040245 23          0451*      inc hl
040246 10 F4       0452*      djnz @loop
040248             0453*  ; print it
040248 21 53 02 04 0454*  	ld hl,@cmd
04024C 01 08 00 00 0455*  	ld bc,@end-@cmd
040250 5B DF       0456*  	rst.lil $18
040252 C9          0457*  	ret
040253             0458*  @cmd: ds 8 ; eight bytes for eight bits
04025B             0459*  @end:
04025B             0460*  
04025B             0461*  ; print the binary representation of the 8-bit value in a
04025B             0462*  ; in reverse order (lsb first)
04025B             0463*  ; destroys a, hl, bc
04025B             0464*  printBin8Rev:
04025B 06 08       0465*      ld b,8      ; loop counter for 8 bits
04025D 21 78 02 04 0466*      ld hl,@cmd  ; set hl to the low byte of the output string
040261             0467*                  ; (which will be the high bit of the value in a)
040261             0468*  @loop:
040261 0F          0469*      rrca ; put the next lowest bit into carry
040262 38 04       0470*      jr c,@one
040264 36 30       0471*      ld (hl),'0'
040266 18 02       0472*      jr @next_bit
040268             0473*  @one:
040268 36 31       0474*      ld (hl),'1'
04026A             0475*  @next_bit:
04026A 23          0476*      inc hl
04026B 10 F4       0477*      djnz @loop
04026D             0478*  ; print it
04026D 21 78 02 04 0479*  	ld hl,@cmd
040271 01 08 00 00 0480*  	ld bc,@end-@cmd
040275 5B DF       0481*  	rst.lil $18
040277 C9          0482*  	ret
040278             0483*  @cmd: ds 8 ; eight bytes for eight bits
040280             0484*  @end:
040280             0485*  
040280             0486*  ; print registers to screen in hexidecimal format
040280             0487*  ; inputs: none
040280             0488*  ; outputs: values of every register printed to screen
040280             0489*  ;    values of each register in global scratch memory
040280             0490*  ; destroys: nothing
040280             0491*  stepRegistersHex:
040280             0492*  ; store everything in scratch
040280 22 6D 04 04 0493*      ld (uhl),hl
040284 ED 43 70 04 0494*      ld (ubc),bc
       04          
040289 ED 53 73 04 0495*      ld (ude),de
       04          
04028E DD 22 76 04 0496*      ld (uix),ix
       04          
040293 FD 22 79 04 0497*      ld (uiy),iy
       04          
040298 F5          0498*      push af ; fml
040299 E1          0499*      pop hl  ; thanks, zilog
04029A 22 6A 04 04 0500*      ld (uaf),hl
04029E F5          0501*      push af ; dammit
04029F             0502*  
04029F             0503*  ; home the cursor
04029F CD 32 12 04 0504*      call vdu_home_cursor
0402A3             0505*  
0402A3             0506*  ; print each register
0402A3 21 F0 03 04 0507*      ld hl,str_afu
0402A7 CD 6C 00 04 0508*      call printString
0402AB 2A 6A 04 04 0509*      ld hl,(uaf)
0402AF CD 8C 00 04 0510*      call printHex24
0402B3 CD 81 00 04 0511*      call printNewLine
0402B7             0512*  
0402B7 21 F5 03 04 0513*      ld hl,str_hlu
0402BB CD 6C 00 04 0514*      call printString
0402BF 2A 6D 04 04 0515*      ld hl,(uhl)
0402C3 CD 8C 00 04 0516*      call printHex24
0402C7 CD 81 00 04 0517*      call printNewLine
0402CB             0518*  
0402CB 21 FA 03 04 0519*      ld hl,str_bcu
0402CF CD 6C 00 04 0520*      call printString
0402D3 2A 70 04 04 0521*      ld hl,(ubc)
0402D7 CD 8C 00 04 0522*      call printHex24
0402DB CD 81 00 04 0523*      call printNewLine
0402DF             0524*  
0402DF 21 FF 03 04 0525*      ld hl,str_deu
0402E3 CD 6C 00 04 0526*      call printString
0402E7 2A 73 04 04 0527*      ld hl,(ude)
0402EB CD 8C 00 04 0528*      call printHex24
0402EF CD 81 00 04 0529*      call printNewLine
0402F3             0530*  
0402F3 21 04 04 04 0531*      ld hl,str_ixu
0402F7 CD 6C 00 04 0532*      call printString
0402FB 2A 76 04 04 0533*      ld hl,(uix)
0402FF CD 8C 00 04 0534*      call printHex24
040303 CD 81 00 04 0535*      call printNewLine
040307             0536*  
040307 21 09 04 04 0537*      ld hl,str_iyu
04030B CD 6C 00 04 0538*      call printString
04030F 2A 79 04 04 0539*      ld hl,(uiy)
040313 CD 8C 00 04 0540*      call printHex24
040317 CD 81 00 04 0541*      call printNewLine
04031B             0542*  
04031B             0543*      ; call vsync
04031B             0544*  
04031B CD 81 00 04 0545*      call printNewLine
04031F             0546*  
04031F             0547*  ; check for right shift key and quit if pressed
04031F             0548*  	MOSCALL mos_getkbmap
04031F 3E 1E       0001*M 			LD	A, function
040321 5B CF       0002*M 			RST.L	08h
040323             0549*  @stayhere:
040323             0550*  ; 7 RightShift
040323 DD CB 00 76 0551*      bit 6,(ix+0)
040327 20 02       0552*      jr nz,@RightShift
040329 18 F8       0553*      jr @stayhere
04032B             0554*  @RightShift:
04032B DD CB 0E 86 0555*      res 0,(ix+14) ; debounce the key (hopefully)
04032F 3E 80       0556*      ld a,%10000000
040331 CD 12 12 04 0557*      call multiPurposeDelay
040335             0558*  
040335             0559*  ; restore everything
040335 2A 6D 04 04 0560*      ld hl, (uhl)
040339 ED 4B 70 04 0561*      ld bc, (ubc)
       04          
04033E ED 5B 73 04 0562*      ld de, (ude)
       04          
040343 DD 2A 76 04 0563*      ld ix, (uix)
       04          
040348 FD 2A 79 04 0564*      ld iy, (uiy)
       04          
04034D F1          0565*      pop af
04034E             0566*  ; all done
04034E C9          0567*      ret
04034F             0568*  
04034F             0569*  ; print registers to screen in hexidecimal format
04034F             0570*  ; inputs: none
04034F             0571*  ; outputs: values of every register printed to screen
04034F             0572*  ;    values of each register in global scratch memory
04034F             0573*  ; destroys: nothing
04034F             0574*  dumpRegistersHex:
04034F             0575*  ; store everything in scratch
04034F 22 6D 04 04 0576*      ld (uhl),hl
040353 ED 43 70 04 0577*      ld (ubc),bc
       04          
040358 ED 53 73 04 0578*      ld (ude),de
       04          
04035D DD 22 76 04 0579*      ld (uix),ix
       04          
040362 FD 22 79 04 0580*      ld (uiy),iy
       04          
040367 F5          0581*      push af ; fml
040368 E1          0582*      pop hl  ; thanks, zilog
040369 22 6A 04 04 0583*      ld (uaf),hl
04036D F5          0584*      push af ; dammit
04036E             0585*  
04036E             0586*  ; home the cursor
04036E             0587*      ; call vdu_home_cursor
04036E             0588*      ; call printNewLine
04036E             0589*  
04036E             0590*  ; print each register
04036E 21 F0 03 04 0591*      ld hl,str_afu
040372 CD 6C 00 04 0592*      call printString
040376 2A 6A 04 04 0593*      ld hl,(uaf)
04037A CD 8C 00 04 0594*      call printHex24
04037E             0595*      ; call printNewLine
04037E             0596*  
04037E 21 F5 03 04 0597*      ld hl,str_hlu
040382 CD 6C 00 04 0598*      call printString
040386 2A 6D 04 04 0599*      ld hl,(uhl)
04038A CD 8C 00 04 0600*      call printHex24
04038E             0601*      ; call printNewLine
04038E             0602*  
04038E 21 FA 03 04 0603*      ld hl,str_bcu
040392 CD 6C 00 04 0604*      call printString
040396 2A 70 04 04 0605*      ld hl,(ubc)
04039A CD 8C 00 04 0606*      call printHex24
04039E             0607*      ; call printNewLine
04039E             0608*  
04039E 21 FF 03 04 0609*      ld hl,str_deu
0403A2 CD 6C 00 04 0610*      call printString
0403A6 2A 73 04 04 0611*      ld hl,(ude)
0403AA CD 8C 00 04 0612*      call printHex24
0403AE             0613*      ; call printNewLine
0403AE             0614*  
0403AE 21 04 04 04 0615*      ld hl,str_ixu
0403B2 CD 6C 00 04 0616*      call printString
0403B6 2A 76 04 04 0617*      ld hl,(uix)
0403BA CD 8C 00 04 0618*      call printHex24
0403BE             0619*      ; call printNewLine
0403BE             0620*  
0403BE 21 09 04 04 0621*      ld hl,str_iyu
0403C2 CD 6C 00 04 0622*      call printString
0403C6 2A 79 04 04 0623*      ld hl,(uiy)
0403CA CD 8C 00 04 0624*      call printHex24
0403CE             0625*      ; call printNewLine
0403CE             0626*  
0403CE CD C7 12 04 0627*      call vdu_vblank
0403D2             0628*  
0403D2 CD 81 00 04 0629*      call printNewLine
0403D6             0630*  ; restore everything
0403D6 2A 6D 04 04 0631*      ld hl, (uhl)
0403DA ED 4B 70 04 0632*      ld bc, (ubc)
       04          
0403DF ED 5B 73 04 0633*      ld de, (ude)
       04          
0403E4 DD 2A 76 04 0634*      ld ix, (uix)
       04          
0403E9 FD 2A 79 04 0635*      ld iy, (uiy)
       04          
0403EE F1          0636*      pop af
0403EF             0637*  ; all done
0403EF C9          0638*      ret
0403F0             0639*  
0403F0 20 61 66 3D 0640*  str_afu: db " af=",0
       00          
0403F5 20 68 6C 3D 0641*  str_hlu: db " hl=",0
       00          
0403FA 20 62 63 3D 0642*  str_bcu: db " bc=",0
       00          
0403FF 20 64 65 3D 0643*  str_deu: db " de=",0
       00          
040404 20 69 78 3D 0644*  str_ixu: db " ix=",0
       00          
040409 20 69 79 3D 0645*  str_iyu: db " iy=",0
       00          
04040E             0646*  
04040E             0647*  ; print udeuhl to screen in hexidecimal format
04040E             0648*  ; inputs: none
04040E             0649*  ; outputs: concatenated hexidecimal udeuhl
04040E             0650*  ; destroys: nothing
04040E             0651*  dumpUDEUHLHex:
04040E             0652*  ; store everything in scratch
04040E 22 6D 04 04 0653*      ld (uhl),hl
040412 ED 43 70 04 0654*      ld (ubc),bc
       04          
040417 ED 53 73 04 0655*      ld (ude),de
       04          
04041C DD 22 76 04 0656*      ld (uix),ix
       04          
040421 FD 22 79 04 0657*      ld (uiy),iy
       04          
040426 F5          0658*      push af
040427             0659*  
040427             0660*  ; print each register
040427             0661*  
040427 21 61 04 04 0662*      ld hl,str_udeuhl
04042B CD 6C 00 04 0663*      call printString
04042F 2A 73 04 04 0664*      ld hl,(ude)
040433 CD 8C 00 04 0665*      call printHex24
040437 3E 2E       0666*  	ld a,'.'	; print a dot to separate the values
040439 5B D7       0667*  	rst.lil 10h
04043B 2A 6D 04 04 0668*      ld hl,(uhl)
04043F CD 8C 00 04 0669*      call printHex24
040443 CD 81 00 04 0670*      call printNewLine
040447             0671*  
040447             0672*  ; restore everything
040447 2A 6D 04 04 0673*      ld hl, (uhl)
04044B ED 4B 70 04 0674*      ld bc, (ubc)
       04          
040450 ED 5B 73 04 0675*      ld de, (ude)
       04          
040455 DD 2A 76 04 0676*      ld ix, (uix)
       04          
04045A FD 2A 79 04 0677*      ld iy, (uiy)
       04          
04045F F1          0678*      pop af
040460             0679*  ; all done
040460 C9          0680*      ret
040461             0681*  
040461 75 64 65 2E 0682*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04046A             0683*  
04046A             0684*  ; global scratch memory for registers
04046A 00 00 00    0685*  uaf: dl 0
04046D 00 00 00    0686*  uhl: dl 0
040470 00 00 00    0687*  ubc: dl 0
040473 00 00 00    0688*  ude: dl 0
040476 00 00 00    0689*  uix: dl 0
040479 00 00 00    0690*  uiy: dl 0
04047C 00 00 00    0691*  usp: dl 0
04047F 00 00 00    0692*  upc: dl 0
040482             0693*  
040482             0694*  ; inputs: whatever is in the flags register
040482             0695*  ; outputs: binary representation of flags
040482             0696*  ;          with a header so we know which is what
040482             0697*  ; destroys: nothing
040482             0698*  ; preserves: everything
040482             0699*  dumpFlags:
040482             0700*  ; first we curse zilog for not giving direct access to flags
040482 F5          0701*      push af ; this is so we can send it back unharmed
040483 F5          0702*      push af ; this is so we can pop it to hl
040484             0703*  ; store everything in scratch
040484 22 6D 04 04 0704*      ld (uhl),hl
040488 ED 43 70 04 0705*      ld (ubc),bc
       04          
04048D ED 53 73 04 0706*      ld (ude),de
       04          
040492 DD 22 76 04 0707*      ld (uix),ix
       04          
040497 FD 22 79 04 0708*      ld (uiy),iy
       04          
04049C             0709*  ; next we print the header
04049C 21 C8 04 04 0710*      ld hl,@header
0404A0 CD 6C 00 04 0711*      call printString
0404A4 E1          0712*      pop hl ; flags are now in l
0404A5 7D          0713*      ld a,l ; flags are now in a
0404A6 CD 36 02 04 0714*      call printBin8
0404AA CD 81 00 04 0715*  	call printNewLine
0404AE             0716*  ; restore everything
0404AE 2A 6D 04 04 0717*      ld hl, (uhl)
0404B2 ED 4B 70 04 0718*      ld bc, (ubc)
       04          
0404B7 ED 5B 73 04 0719*      ld de, (ude)
       04          
0404BC DD 2A 76 04 0720*      ld ix, (uix)
       04          
0404C1 FD 2A 79 04 0721*      ld iy, (uiy)
       04          
0404C6 F1          0722*      pop af ; send her home the way she came
0404C7 C9          0723*      ret
0404C8             0724*  ; Bit 7 (S): Sign flag
0404C8             0725*  ; Bit 6 (Z): Zero flag
0404C8             0726*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0404C8             0727*  ; Bit 4 (H): Half Carry flag
0404C8             0728*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0404C8             0729*  ; Bit 2 (PV): Parity/Overflow flag
0404C8             0730*  ; Bit 1 (N): Subtract flag
0404C8             0731*  ; Bit 0 (C): Carry flag
0404C8 53 5A 78 48 0732*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0404D3             0733*  
0404D3             0734*  ; set all the bits in the flag register
0404D3             0735*  ; more of an academic exercise than anything useful
0404D3             0736*  ; inputs; none
0404D3             0737*  ; outputs; a=0,f=255
0404D3             0738*  ; destroys: flags, hl
0404D3             0739*  ; preserves: a, because why not
0404D3             0740*  setAllFlags:
0404D3 21 FF 00 00 0741*      ld hl,255
0404D7 67          0742*      ld h,a ; four cycles to preserve a is cheap
0404D8 E5          0743*      push hl
0404D9 F1          0744*      pop af
0404DA C9          0745*      ret
0404DB             0746*  
0404DB             0747*  ; reset all the bits in the flag register
0404DB             0748*  ; unlike its inverse counterpart, this may actually be useful
0404DB             0749*  ; inputs; none
0404DB             0750*  ; outputs; a=0,f=0
0404DB             0751*  ; destroys: flags, hl
0404DB             0752*  ; preserves: a, because why not
0404DB             0753*  resetAllFlags:
0404DB 21 00 00 00 0754*      ld hl,0
0404DF 67          0755*      ld h,a ; four cycles to preserve a is cheap
0404E0 E5          0756*      push hl
0404E1 F1          0757*      pop af
0404E2 C9          0758*      ret
0404E3             0759*  
0404E3             0760*  ; wait until user presses a key
0404E3             0761*  ; inputs: none
0404E3             0762*  ; outputs: none
0404E3             0763*  ; destroys: af,ix
0404E3             0764*  waitKeypress:
0404E3             0765*      MOSCALL mos_sysvars
0404E3 3E 08       0001*M 			LD	A, function
0404E5 5B CF       0002*M 			RST.L	08h
0404E7 AF          0766*      xor a ; zero out any prior keypresses
0404E8 DD 77 05    0767*      ld (ix+sysvar_keyascii),a
0404EB             0768*  @loop:
0404EB DD 7E 05    0769*      ld a,(ix+sysvar_keyascii)
0404EE A7          0770*      and a
0404EF C0          0771*      ret nz
0404F0 18 F9       0772*      jr @loop
0404F2             0773*  
0404F2             0774*  
0404F2             0775*  ; print bytes from an address to the screen in hexidecimal format
0404F2             0776*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0404F2             0777*  ; outputs: values of each byte printed to screen separated by spaces
0404F2             0778*  ; destroys: nothing
0404F2             0779*  dumpMemoryHex:
0404F2             0780*  ; save registers to the stack
0404F2 C5          0781*      push bc
0404F3 E5          0782*      push hl
0404F4 F5          0783*      push af
0404F5             0784*  
0404F5             0785*  ; print the address and separator
0404F5 CD 8C 00 04 0786*      call printHex24
0404F9 3E 3A       0787*      ld a,':'
0404FB 5B D7       0788*      rst.lil 10h
0404FD 3E 20       0789*      ld a,' '
0404FF 5B D7       0790*      rst.lil 10h
040501             0791*  
040501             0792*  ; set b to be our loop counter
040501 F1          0793*      pop af
040502 47          0794*      ld b,a
040503 E1          0795*      pop hl
040504 E5          0796*      push hl
040505 F5          0797*      push af
040506             0798*  @loop:
040506             0799*  ; print the byte
040506 7E          0800*      ld a,(hl)
040507 CD 9A 00 04 0801*      call printHex8
04050B             0802*  ; print a space
04050B 3E 20       0803*      ld a,' '
04050D 5B D7       0804*      rst.lil 10h
04050F 23          0805*      inc hl
040510 10 F4       0806*      djnz @loop
040512             0807*      ; call printNewLine
040512             0808*  
040512             0809*  ; restore everything
040512 F1          0810*      pop af
040513 E1          0811*      pop hl
040514 C1          0812*      pop bc
040515             0813*  
040515             0814*  ; all done
040515 C9          0815*      ret
040516             0816*  
040516             0817*  
040516             0818*  ; print bytes from an address to the screen in binary format
040516             0819*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040516             0820*  ; outputs: values of each byte printed to screen separated by spaces
040516             0821*  ; destroys: nothing
040516             0822*  dumpMemoryBin:
040516             0823*  ; save all registers to the stack
040516 F5          0824*      push af
040517 C5          0825*      push bc
040518 D5          0826*      push de
040519 E5          0827*      push hl
04051A DD E5       0828*      push ix
04051C FD E5       0829*      push iy
04051E             0830*  
04051E             0831*  ; set b to be our loop counter
04051E 47          0832*      ld b,a
04051F             0833*  @loop:
04051F             0834*  ; print the byte
04051F 7E          0835*      ld a,(hl)
040520 E5          0836*      push hl
040521 C5          0837*      push bc
040522 CD 36 02 04 0838*      call printBin8
040526 C1          0839*      pop bc
040527             0840*  ; print a space
040527 3E 20       0841*      ld a,' '
040529 5B D7       0842*      rst.lil 10h
04052B E1          0843*      pop hl
04052C 23          0844*      inc hl
04052D 10 F0       0845*      djnz @loop
04052F CD 81 00 04 0846*      call printNewLine
040533             0847*  
040533             0848*  ; restore everything
040533 FD E1       0849*      pop iy
040535 DD E1       0850*      pop ix
040537 E1          0851*      pop hl
040538 D1          0852*      pop de
040539 C1          0853*      pop bc
04053A F1          0854*      pop af
04053B             0855*  ; all done
04053B C9          0856*      ret
04053C             0857*  
04053C             0858*  ; print bytes from an address to the screen in binary format
04053C             0859*  ; with the bits of each byte in reverse order (lsb first)
04053C             0860*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04053C             0861*  ; outputs: values of each byte printed to screen separated by spaces
04053C             0862*  ; destroys: nothing
04053C             0863*  dumpMemoryBinRev:
04053C             0864*  ; save all registers to the stack
04053C F5          0865*      push af
04053D C5          0866*      push bc
04053E D5          0867*      push de
04053F E5          0868*      push hl
040540 DD E5       0869*      push ix
040542 FD E5       0870*      push iy
040544             0871*  
040544             0872*  ; set b to be our loop counter
040544 47          0873*      ld b,a
040545             0874*  @loop:
040545             0875*  ; print the byte
040545 7E          0876*      ld a,(hl)
040546 E5          0877*      push hl
040547 C5          0878*      push bc
040548 CD 5B 02 04 0879*      call printBin8Rev
04054C C1          0880*      pop bc
04054D             0881*  ; print a space
04054D 3E 20       0882*      ld a,' '
04054F 5B D7       0883*      rst.lil 10h
040551 E1          0884*      pop hl
040552 23          0885*      inc hl
040553 10 F0       0886*      djnz @loop
040555 CD 81 00 04 0887*      call printNewLine
040559             0888*  
040559             0889*  ; restore everything
040559 FD E1       0890*      pop iy
04055B DD E1       0891*      pop ix
04055D E1          0892*      pop hl
04055E D1          0893*      pop de
04055F C1          0894*      pop bc
040560 F1          0895*      pop af
040561             0896*  ; all done
040561 C9          0897*      ret
040562             0034       include "maths.inc"
040562             0001*  ; absolute value of hlu
040562             0002*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040562             0003*  ;         s1,z0,pv0,n1,c0 if hlu was negative
040562             0004*  ;         s0,z1,pv0,n1,c0 if hlu was zero
040562             0005*  ;         s0,z0,pv0,n1,c0 if hlu was positive
040562             0006*  ; destroys: a
040562             0007*  abs_hlu:
040562 19          0008*      add hl,de
040563 B7          0009*      or a
040564 ED 52       0010*      sbc hl,de
040566 FA 6B 05 04 0011*      jp m,@is_neg
04056A C9          0012*      ret         ; hlu is positive or zero so we're done
04056B             0013*  @is_neg:
04056B F5          0014*      push af     ; otherwise, save current flags for return
04056C CD 72 05 04 0015*      call neg_hlu ; negate hlu
040570 F1          0016*      pop af      ; get back flags
040571 C9          0017*      ret
040572             0018*  
040572             0019*  ; flip the sign of hlu
040572             0020*  ; inputs: hlu
040572             0021*  ; returns: 0-hlu, flags set appropriately for the result:
040572             0022*  ;         s1,z0,pv0,n1,c1 if result is negative
040572             0023*  ;         s0,z1,pv0,n1,c0 if result is zero
040572             0024*  ;         s0,z0,pv0,n1,c1 if result is positive
040572             0025*  ; destroys a
040572             0026*  neg_hlu:
040572 D5          0027*      push de     ; save de
040573 EB          0028*      ex de,hl    ; put hl into de
040574 21 00 00 00 0029*      ld hl,0     ; clear hl
040578 AF          0030*      xor a       ; clear carry
040579 ED 52       0031*      sbc hl,de   ; 0-hlu = -hlu
04057B D1          0032*      pop de      ; get de back
04057C C9          0033*      ret         ; easy peasy
04057D             0034*  
04057D             0035*  ;------------------------------------------------------------------------
04057D             0036*  ; divide hlu by 2, inspired by above
04057D             0037*  ;------------------------------------------------------------------------
04057D             0038*  hlu_div2:
04057D 22 FD 07 04 0039*  	ld		(bitbuf1),hl
040581 21 FF 07 04 0040*  	ld		hl,bitbuf1+2
040585 CB 1E       0041*  	rr		(hl)
040587 2B          0042*  	dec		hl
040588 CB 1E       0043*  	rr		(hl)
04058A 2B          0044*  	dec		hl
04058B CB 1E       0045*  	rr		(hl)
04058D 23          0046*  	inc		hl
04058E 23          0047*  	inc		hl
04058F 2A FD 07 04 0048*      ld hl,(bitbuf1)
040593 C9          0049*      ret
040594             0050*  
040594             0051*  ; this is my little hack to divide by 16
040594             0052*  hlu_div16:
040594 AF          0053*      xor a
040595 29          0054*      add hl,hl
040596 17          0055*      rla
040597 29          0056*      add hl,hl
040598 17          0057*      rla
040599 29          0058*      add hl,hl
04059A 17          0059*      rla
04059B 29          0060*      add hl,hl
04059C 17          0061*      rla
04059D 22 AA 05 04 0062*      ld (@scratch),hl
0405A1 32 AD 05 04 0063*      ld (@scratch+3),a
0405A5 2A AB 05 04 0064*      ld hl,(@scratch+1)
0405A9 C9          0065*      ret
0405AA             0066*  @scratch: ds 4
0405AE             0067*  
0405AE             0068*  
0405AE 00 00 00 00 0069*  add_bcd_arg1: db #00,#00,#00,#00
0405B2 00 00 00 00 0070*  add_bcd_arg2: db #00,#00,#00,#00
0405B6             0071*  
0405B6             0072*  ; set bcd values in a scratch memory address from registers bcde
0405B6             0073*  ; input: hl; scratch address,bcde; 8-place bcd number
0405B6             0074*  ; destroys ; hl
0405B6             0075*  set_bcd:
0405B6 73          0076*      ld (hl),e
0405B7 23          0077*      inc hl
0405B8 72          0078*      ld (hl),d
0405B9 23          0079*      inc hl
0405BA 71          0080*      ld (hl),c
0405BB 23          0081*      inc hl
0405BC 70          0082*      ld (hl),b
0405BD C9          0083*      ret
0405BE             0084*  
0405BE             0085*  ; load bcd values from a scratch memory address to bcde
0405BE             0086*  ; input: hl; scratch address
0405BE             0087*  ; output: bcde; 8-place bcd number
0405BE             0088*  ; destroys: hl
0405BE             0089*  get_bcd:
0405BE 5E          0090*      ld e,(hl)
0405BF 23          0091*      inc hl
0405C0 56          0092*      ld d,(hl)
0405C1 23          0093*      inc hl
0405C2 4E          0094*      ld c,(hl)
0405C3 23          0095*      inc hl
0405C4 46          0096*      ld b,(hl)
0405C5 C9          0097*      ret
0405C6             0098*  
0405C6             0099*  ; BCD addition
0405C6             0100*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0405C6             0101*  ;       a is the number of bytes holding each number (number of places/2)
0405C6             0102*  ; outputs: (hl) + (de) --> (hl)
0405C6             0103*  ; destroys: a,b,de,hl
0405C6             0104*  add_bcd:
0405C6 47          0105*      ld b,a ; loop counter
0405C7 AF          0106*      xor a ; reset a, clear carry flag
0405C8             0107*  adcec:
0405C8 1A          0108*      ld a,(de) ; addend to acc
0405C9 8E          0109*      adc a,(hl) ; add (hl) to acc
0405CA 27          0110*      daa ; adjust result to bcd
0405CB 77          0111*      ld (hl),a ; store result
0405CC 23          0112*      inc hl ; advance memory pointers
0405CD 13          0113*      inc de
0405CE 10 F8       0114*      djnz adcec ; loop until b == 0
0405D0 C9          0115*      ret
0405D1             0116*  
0405D1             0117*  ; BCD subtraction
0405D1             0118*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0405D1             0119*  ;       a is the number of bytes holding each number (number of places/2)
0405D1             0120*  ; outputs: (hl) - (de) --> (hl)
0405D1             0121*  ; destroys: a,b,de,hl
0405D1             0122*  sub_bcd:
0405D1 47          0123*      ld b,a ; loop counter
0405D2 AF          0124*      xor a ; reset a,clear carry flag
0405D3             0125*  subdec:
0405D3 1A          0126*      ld a,(de) ; subtrahend to acc
0405D4 9E          0127*      sbc a,(hl) ; subtract (hl) from acc
0405D5 27          0128*      daa ; adjust result to bcd
0405D6 77          0129*      ld (hl),a ; store result
0405D7 23          0130*      inc hl ; advance memory pointers
0405D8 13          0131*      inc de
0405D9 10 F8       0132*      djnz subdec ; loop until b == 0
0405DB C9          0133*      ret
0405DC             0134*  
0405DC             0135*  ; http://www.z80.info/pseudo-random.txt
0405DC             0136*  rand_8:
0405DC C5          0137*      push bc
0405DD 3A F0 05 04 0138*      ld a,(r_seed)
0405E1 4F          0139*      ld c,a
0405E2             0140*  
0405E2 0F          0141*      rrca ; multiply by 32
0405E3 0F          0142*      rrca
0405E4 0F          0143*      rrca
0405E5 EE 1F       0144*      xor 0x1f
0405E7             0145*  
0405E7 81          0146*      add a,c
0405E8 DE FF       0147*      sbc a,255 ; carry
0405EA             0148*  
0405EA 32 F0 05 04 0149*      ld (r_seed),a
0405EE C1          0150*      pop bc
0405EF C9          0151*      ret
0405F0 50          0152*  r_seed: defb $50
0405F1             0153*  
0405F1             0154*  
0405F1             0035   	INCLUDE	"arith24.inc"
0405F1             0001*  arith24uaf: ds 6
0405F7             0002*  arith24uhl: ds 6
0405FD             0003*  arith24ubc: ds 6
040603             0004*  arith24ude: ds 6
040609             0005*  arith24uix: ds 6
04060F             0006*  arith24uiy: ds 6
040615             0007*  arith24usp: ds 6
04061B             0008*  arith24upc: ds 6
040621             0009*  
040621             0010*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040621             0011*  ; uses EZ80 MLT instruction for speed
040621             0012*  ; operation: UHL * A --> AUHL
040621             0013*  ; destroys: AF, HL
040621             0014*  umul24x8:
040621 D5          0015*  	push de ; preserve de
040622             0016*  ; low byte
040622 5D          0017*  	ld e,l
040623 57          0018*  	ld d,a
040624 ED 5C       0019*  	mlt de
040626 6B          0020*  	ld l,e ; product low byte
040627 08          0021*  	ex af,af' ; save multiplier
040628 7A          0022*  	ld a,d ; carry
040629 08          0023*  	ex af,af' ; save carry, restore multiplier
04062A             0024*  ; high byte
04062A 5C          0025*  	ld e,h
04062B 57          0026*  	ld d,a
04062C ED 5C       0027*  	mlt de
04062E 08          0028*  	ex af,af' ; save multiplier, restore carry
04062F 83          0029*  	add a,e ; add carry
040630 67          0030*  	ld h,a ; product middle byte
040631 7A          0031*  	ld a,d ; carry
040632 08          0032*  	ex af,af' ; save carry, restore multiplier
040633             0033*  ; upper byte
040633 E5          0034*  	push hl
040634 33          0035*  	inc sp
040635 D1          0036*  	pop de ; d = hlu
040636 3B          0037*  	dec sp
040637 5F          0038*  	ld e,a
040638 ED 5C       0039*  	mlt de
04063A 08          0040*  	ex af,af' ; restore carry
04063B 8B          0041*  	adc a,e ; add carry
04063C 22 4D 06 04 0042*      ld (@scratch),hl ; 7 cycles
040640 32 4F 06 04 0043*      ld (@scratch+2),a ; 5 cycles
040644 2A 4D 06 04 0044*      ld hl,(@scratch) ; 7 cycles
040648             0045*  ; highest byte
040648 3E 00       0046*  	ld a,0 ; preserve carry flag
04064A 8A          0047*  	adc a,d ; product highest byte
04064B D1          0048*  	pop de ; restore de
04064C C9          0049*  	ret
04064D             0050*  @scratch: ds 3
040650             0051*  
040650             0052*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040650             0053*  ; operation: UHL * UDE --> umul24x24out
040650             0054*  umul24x24:
040650 FD 21 A8 06 0055*  	ld iy,umul24x24out ; point to output buffer
       04          
040655 C5          0056*  	push bc
040656 01 00 00 00 0057*  	ld bc,0
04065A FD 0F 00    0058*  	ld (iy),bc
04065D FD 0F 03    0059*  	ld (iy+3),bc
040660 C1          0060*  	pop bc
040661             0061*  
040661             0062*  ; STEP 1: UHL * E
040661 7B          0063*  	ld a,e
040662 E5          0064*  	push hl
040663 CD 21 06 04 0065*  	call umul24x8
040667 FD 2F 00    0066*  	ld (iy+0),hl
04066A FD 77 03    0067*  	ld (iy+3),a
04066D             0068*  
04066D             0069*  ; STEP 2: UHL * D
04066D E1          0070*  	pop hl
04066E E5          0071*  	push hl
04066F 7A          0072*  	ld a,d
040670 CD 21 06 04 0073*  	call umul24x8
040674 CD 81 06 04 0074*  	call @accumulate
040678             0075*  
040678             0076*  ; STEP 3: UHL * DEU
040678 E1          0077*  	pop hl
040679 D5          0078*  	push de
04067A 33          0079*  	inc sp
04067B F1          0080*  	pop af
04067C 3B          0081*  	dec sp
04067D CD 21 06 04 0082*  	call umul24x8
040681             0083*  
040681             0084*  @accumulate:
040681 FD 23       0085*  	inc iy
040683             0086*  ; highest byte of product to carry
040683 FD 77 03    0087*  	ld (iy+3),a
040686             0088*  ; low byte of product
040686 7D          0089*  	ld a,l
040687 FD 86 00    0090*  	add a,(iy+0)
04068A FD 77 00    0091*  	ld (iy+0),a
04068D             0092*  ; high byte of product
04068D 7C          0093*  	ld a,h
04068E FD 8E 01    0094*  	adc a,(iy+1)
040691 FD 77 01    0095*  	ld (iy+1),a
040694             0096*  ; uppper byte of product
040694 E5          0097*  	push hl
040695 33          0098*  	inc sp
040696 E1          0099*  	pop hl
040697 3B          0100*  	dec sp
040698 7C          0101*  	ld a,h
040699 FD 8E 02    0102*  	adc a,(iy+2)
04069C FD 77 02    0103*  	ld (iy+2),a
04069F             0104*  ; carry
04069F 3E 00       0105*  	ld a,0 ; preserve flags
0406A1 FD 8E 03    0106*  	adc a,(iy+3)
0406A4 FD 77 03    0107*  	ld (iy+3),a
0406A7 C9          0108*  	ret
0406A8             0109*  umul24x24out: ds 6 ; output buffer
0406AE             0110*  
0406AE             0111*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
0406AE             0112*  umul168:
0406AE CD 50 06 04 0113*  	call umul24x24
0406B2 FD 27 FF    0114*  	ld hl,(iy-1)
0406B5 C9          0115*  	ret
0406B6             0116*  
0406B6             0117*  ; smul168:	UH.L = UH.L*UD.E (signed)
0406B6             0118*  smul168:
0406B6             0119*  ; make everything positive and store sign flags
0406B6 CD 62 05 04 0120*  	call abs_hlu
0406BA F5          0121*  	push af
0406BB EB          0122*  	ex de,hl
0406BC CD 62 05 04 0123*  	call abs_hlu
0406C0 EB          0124*  	ex de,hl
0406C1 F5          0125*  	push af
0406C2             0126*  ; do the multiplication
0406C2 CD AE 06 04 0127*  	call umul168
0406C6             0128*  ; adjust sign of result
0406C6 F1          0129*  	pop af
0406C7 FA CD 06 04 0130*  	jp m,@de_neg
0406CB F1          0131*  	pop af
0406CC F0          0132*  	ret p ; both positive, nothing to do
0406CD             0133*  @de_neg:
0406CD F1          0134*  	pop af
0406CE F8          0135*  	ret m ; both negative, nothing to do
0406CF CD 72 05 04 0136*  	call neg_hlu ; result is negative
0406D3 C9          0137*  	ret
0406D4             0138*  
0406D4             0139*  ;------------------------------------------------------------------------
0406D4             0140*  ;  arith24.inc
0406D4             0141*  ;  24-bit ez80 arithmetic routines
0406D4             0142*  ;  Copyright (c) Shawn Sijnstra 2024
0406D4             0143*  ;  MIT license
0406D4             0144*  ;
0406D4             0145*  ;  This library was created as a tool to help make ez80
0406D4             0146*  ;  24-bit native assembly routines for simple mathematical problems
0406D4             0147*  ;  more widely available.
0406D4             0148*  ;
0406D4             0149*  ;------------------------------------------------------------------------
0406D4             0150*  
0406D4             0151*  ;------------------------------------------------------------------------
0406D4             0152*  ; umul24:	HL = HL*DE (unsigned)
0406D4             0153*  ; Preserves AF, BC, DE
0406D4             0154*  ; Uses a fast multiply routine.
0406D4             0155*  ;------------------------------------------------------------------------
0406D4             0156*  umul24:
0406D4 D5          0157*  	push	DE
0406D5 C5          0158*  	push	BC
0406D6 F5          0159*  	push	AF
0406D7 E5          0160*  	push	HL
0406D8 C1          0161*  	pop		BC
0406D9 3E 18       0162*      ld	 	a, 24 ; No. of bits to process
0406DB 21 00 00 00 0163*      ld	 	hl, 0 ; Result
0406DF             0164*  umul24_lp:
0406DF 29          0165*  	add	hl,hl
0406E0 EB          0166*  	ex	de,hl
0406E1 29          0167*  	add	hl,hl
0406E2 EB          0168*  	ex	de,hl
0406E3 30 01       0169*  	jr	nc,umul24_nc
0406E5 09          0170*  	add	hl,bc
0406E6             0171*  umul24_nc:
0406E6 3D          0172*  	dec	a
0406E7 20 F6       0173*  	jr	nz,umul24_lp
0406E9 F1          0174*  	pop	af
0406EA C1          0175*  	pop	bc
0406EB D1          0176*  	pop	de
0406EC C9          0177*  	ret
0406ED             0178*  
0406ED             0179*  ;------------------------------------------------------------------------
0406ED             0180*  ; udiv24
0406ED             0181*  ; Unsigned 24-bit division
0406ED             0182*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0406ED             0183*  ;
0406ED             0184*  ; Uses AF BC DE HL
0406ED             0185*  ; Uses Restoring Division algorithm
0406ED             0186*  ;------------------------------------------------------------------------
0406ED             0187*  
0406ED             0188*  udiv24:
0406ED E5          0189*  	push	hl
0406EE C1          0190*  	pop		bc	;move dividend to BCU
0406EF 21 00 00 00 0191*  	ld		hl,0	;result
0406F3 A7          0192*  	and		a
0406F4 ED 52       0193*  	sbc		hl,de	;test for div by 0
0406F6 C8          0194*  	ret		z		;it's zero, carry flag is clear
0406F7 19          0195*  	add		hl,de	;HL is 0 again
0406F8 3E 18       0196*  	ld		a,24	;number of loops through.
0406FA             0197*  udiv1:
0406FA C5          0198*  	push	bc	;complicated way of doing this because of lack of access to top bits
0406FB E3          0199*  	ex		(sp),hl
0406FC 37          0200*  	scf
0406FD ED 6A       0201*  	adc	hl,hl
0406FF E3          0202*  	ex	(sp),hl
040700 C1          0203*  	pop	bc		;we now have bc = (bc * 2) + 1
040701             0204*  
040701 ED 6A       0205*  	adc	hl,hl
040703 A7          0206*  	and	a		;is this the bug
040704 ED 52       0207*  	sbc	hl,de
040706 30 02       0208*  	jr	nc,udiv2
040708 19          0209*  	add	hl,de
040709             0210*  ;	dec	c
040709 0B          0211*  	dec	bc
04070A             0212*  udiv2:
04070A 3D          0213*  	dec	a
04070B 20 ED       0214*  	jr	nz,udiv1
04070D 37          0215*  	scf		;flag used for div0 error
04070E C5          0216*  	push	bc
04070F D1          0217*  	pop		de	;remainder
040710 C9          0218*  	ret
040711             0219*  
040711             0220*  ; perform unsigned division of fixed place values
040711             0221*  ; with an unsigned 16.8 fixed place result
040711             0222*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
040711             0223*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
040711             0224*  ; destroys: a,bc
040711             0225*  udiv168:
040711             0226*  ; shift dividend left 8 bits
040711 ED 43 FE 05 0227*      ld (arith24ubc+1),bc
       04          
040716 AF          0228*      xor a
040717 32 FD 05 04 0229*      ld (arith24ubc),a
04071B ED 4B FD 05 0230*      ld bc,(arith24ubc)
       04          
040720 CD ED 06 04 0231*      call udiv24
040724             0232*  ; flip-flop outptuts to satisfy downstream consumers
040724             0233*  ; TODO: this is a hack and should be fixed
040724             0234*  ; (so says copilot ... but it's not wrong)
040724 E5          0235*      push hl
040725 C5          0236*      push bc
040726 E1          0237*      pop hl
040727 C1          0238*      pop bc
040728 C9          0239*      ret
040729             0240*  
040729             0241*  ; perform signed division of 16.8 fixed place values
040729             0242*  ; with an signed 16.8 fixed place result
040729             0243*  ; inputs: ub.c is dividend,ud.e is divisor
040729             0244*  ; outputs: uh.l is quotient
040729             0245*  ; destroys: a,bc
040729             0246*  ; note: uses carry flag to test for sign of operands and result
040729             0247*  ;       which can be confusing and should perhaps be changed
040729             0248*  ; note2: helper functions abs_hlu and neg_hlu have been modified
040729             0249*  ;       to return accurate flags according to the origional signs
040729             0250*  ;       (or zero) of this function's inputs
040729             0251*  sdiv168:
040729             0252*  ; make everything positive and save signs
040729 C5          0253*      push bc         ; get bc to hl
04072A E1          0254*      pop hl          ; for the next call
04072B CD 62 05 04 0255*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
04072F CA 62 07 04 0256*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040733 F5          0257*      push af         ; save sign of bc
040734 E5          0258*      push hl         ; now put abs(hl)
040735 C1          0259*      pop bc          ; back into bc = abs(bc)
040736 EB          0260*      ex de,hl        ; now we do de same way
040737 CD 62 05 04 0261*      call abs_hlu
04073B CA 64 07 04 0262*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
04073F EB          0263*      ex de,hl        ; hl back to de = abs(de)
040740             0264*  ; determine sign of result
040740 F2 4B 07 04 0265*      jp p,@de_pos    ; sign positive,de is positive
040744 F1          0266*      pop af          ; get back sign of bc
040745 FA 54 07 04 0267*      jp m,@result_pos  ; bc and de negative, result is positive
040749 18 05       0268*      jr @result_neg
04074B             0269*  @de_pos:
04074B F1          0270*      pop af          ; get back sign of bc
04074C F2 54 07 04 0271*      jp p,@result_pos   ; bc and de are both positive so result is positive
040750             0272*                      ; fall through to result_neg
040750             0273*  @result_neg:
040750 AF          0274*      xor a           ; zero a and clear carry
040751 3D          0275*      dec a           ; set sign flag to negative
040752 18 02       0276*      jr @do_div
040754             0277*  @result_pos:
040754 AF          0278*      xor a           ; zero a and clear carry
040755 3C          0279*      inc a           ; set sign flag to negative
040756             0280*                      ; fall through to do_div
040756             0281*  @do_div:
040756 F5          0282*      push af         ; save sign of result
040757 CD 11 07 04 0283*      call udiv168
04075B F1          0284*      pop af          ; get back sign of result
04075C F0          0285*      ret p           ; result is positive so nothing to do
04075D CD 72 05 04 0286*      call neg_hlu    ; result is negative so negate it
040761 C9          0287*      ret
040762             0288*  @is_zero:           ; result is zero
040762 AF          0289*      xor a           ; sets zero flag, which we want,
040763             0290*                      ; sets pv flag which we might not (zero is parity even)
040763             0291*                      ; resets all others which is okay
040763 C9          0292*      ret
040764             0293*  @div_by_zero:       ; result is undefined, which isn't defined in binary
040764             0294*                      ; so we'll just return zero until i can think of something better
040764 F1          0295*      pop af          ; dummy pop
040765 AF          0296*      xor a           ; sets zero flag, which is ok,
040766             0297*                      ; sets pv flag which could be interpreted as overflow, which is good
040766             0298*                      ; resets all others which is okay
040766 C9          0299*      ret
040767             0300*  
040767             0301*  ;------------------------------------------------------------------------
040767             0302*  ; neg24
040767             0303*  ; Returns: HLU = 0-HLU
040767             0304*  ; preserves all other registers
040767             0305*  ;------------------------------------------------------------------------
040767             0306*  neg24:
040767 D5          0307*  	push	de
040768 EB          0308*  	ex		de,hl
040769 21 00 00 00 0309*  	ld		hl,0
04076D B7          0310*  	or		a
04076E ED 52       0311*  	sbc		hl,de
040770 D1          0312*  	pop		de
040771 C9          0313*  	ret
040772             0314*  
040772             0315*  ;------------------------------------------------------------------------
040772             0316*  ; or_hlu_deu: 24 bit bitwise OR
040772             0317*  ; Returns: hlu = hlu OR deu
040772             0318*  ; preserves all other registers
040772             0319*  ;------------------------------------------------------------------------
040772             0320*  or_hlu_deu:
040772 22 FD 07 04 0321*  	ld	(bitbuf1),hl
040776 ED 53 00 08 0322*  	ld	(bitbuf2),de
       04          
04077B D5          0323*  	push	de	;preserve DEU
04077C C5          0324*  	push	bc	;preserve BCU
04077D 06 03       0325*  	ld		b,3
04077F 21 FD 07 04 0326*  	ld	hl,bitbuf1
040783 11 FD 07 04 0327*  	ld	de,bitbuf1
040787             0328*  orloop_24:
040787 1A          0329*  	ld	a,(de)
040788 B6          0330*  	or	(hl)
040789 12          0331*  	ld	(de),a
04078A 13          0332*  	inc	de
04078B 23          0333*  	inc	hl
04078C 10 F9       0334*  	djnz	orloop_24
04078E 2A 00 08 04 0335*  	ld	hl,(bitbuf2)
040792 C1          0336*  	pop		bc	;restore BC
040793 D1          0337*  	pop		de	;restore DE
040794             0338*  
040794             0339*  ;------------------------------------------------------------------------
040794             0340*  ; and_hlu_deu: 24 bit bitwise AND
040794             0341*  ; Returns: hlu = hlu AND deu
040794             0342*  ; preserves all other registers
040794             0343*  ;------------------------------------------------------------------------
040794             0344*  and_hlu_deu:
040794 22 FD 07 04 0345*  	ld	(bitbuf1),hl
040798 ED 53 00 08 0346*  	ld	(bitbuf2),de
       04          
04079D D5          0347*  	push	de	;preserve DEU
04079E C5          0348*  	push	bc	;preserve BCU
04079F 06 03       0349*  	ld		b,3
0407A1 21 FD 07 04 0350*  	ld	hl,bitbuf1
0407A5 11 FD 07 04 0351*  	ld	de,bitbuf1
0407A9             0352*  andloop_24:
0407A9 1A          0353*  	ld	a,(de)
0407AA A6          0354*  	and	(hl)
0407AB 12          0355*  	ld	(de),a
0407AC 13          0356*  	inc	de
0407AD 23          0357*  	inc	hl
0407AE 10 F9       0358*  	djnz	andloop_24
0407B0 2A 00 08 04 0359*  	ld	hl,(bitbuf2)
0407B4 C1          0360*  	pop		bc	;restore BC
0407B5 D1          0361*  	pop		de	;restore DE
0407B6             0362*  
0407B6             0363*  ;------------------------------------------------------------------------
0407B6             0364*  ; xor_hlu_deu: 24 bit bitwise XOR
0407B6             0365*  ; Returns: hlu = hlu XOR deu
0407B6             0366*  ; preserves all other registers
0407B6             0367*  ;------------------------------------------------------------------------
0407B6             0368*  xor_hlu_deu:
0407B6 22 FD 07 04 0369*  	ld	(bitbuf1),hl
0407BA ED 53 00 08 0370*  	ld	(bitbuf2),de
       04          
0407BF D5          0371*  	push	de	;preserve DEU
0407C0 C5          0372*  	push	bc	;preserve BCU
0407C1 06 03       0373*  	ld		b,3
0407C3 21 FD 07 04 0374*  	ld	hl,bitbuf1
0407C7 11 FD 07 04 0375*  	ld	de,bitbuf1
0407CB             0376*  xorloop_24:
0407CB 1A          0377*  	ld	a,(de)
0407CC AE          0378*  	xor	(hl)
0407CD 12          0379*  	ld	(de),a
0407CE 13          0380*  	inc	de
0407CF 23          0381*  	inc	hl
0407D0 10 F9       0382*  	djnz	xorloop_24
0407D2 2A 00 08 04 0383*  	ld	hl,(bitbuf2)
0407D6 C1          0384*  	pop		bc	;restore BC
0407D7 D1          0385*  	pop		de	;restore DE
0407D8             0386*  
0407D8             0387*  ;------------------------------------------------------------------------
0407D8             0388*  ; shl_hlu: 24 bit shift left hlu by deu positions
0407D8             0389*  ; Returns: hlu = hlu << deu
0407D8             0390*  ;		   de = 0
0407D8             0391*  ; NOTE: only considers deu up to 16 bits.
0407D8             0392*  ; preserves all other registers
0407D8             0393*  ;------------------------------------------------------------------------
0407D8             0394*  shl_hlu:
0407D8 7A          0395*  	ld		a,d		;up to 16 bit.
0407D9 B3          0396*  	or		e
0407DA C8          0397*  	ret		z		;we're done
0407DB 29          0398*  	add		hl,hl	;shift HLU left
0407DC 1B          0399*  	dec		de
0407DD 18 F9       0400*  	jr		shl_hlu
0407DF             0401*  
0407DF             0402*  ;------------------------------------------------------------------------
0407DF             0403*  ; shr_hlu: 24 bit shift right hlu by deu positions
0407DF             0404*  ; Returns: hlu = hlu >> deu
0407DF             0405*  ;		   de = 0
0407DF             0406*  ; NOTE: only considers deu up to 16 bits.
0407DF             0407*  ; preserves all other registers
0407DF             0408*  ;------------------------------------------------------------------------
0407DF             0409*  shr_hlu:
0407DF 22 FD 07 04 0410*  	ld		(bitbuf1),hl
0407E3 21 FF 07 04 0411*  	ld		hl,bitbuf1+2
0407E7             0412*  shr_loop:
0407E7 7A          0413*  	ld		a,d		;up to 16 bit.
0407E8 B3          0414*  	or		e
0407E9 28 0D       0415*  	jr		z,shr_done		;we're done
0407EB             0416*  ;carry is clear from or instruction
0407EB CB 1E       0417*  	rr		(hl)
0407ED 2B          0418*  	dec		hl
0407EE CB 1E       0419*  	rr		(hl)
0407F0 2B          0420*  	dec		hl
0407F1 CB 1E       0421*  	rr		(hl)
0407F3 23          0422*  	inc		hl
0407F4 23          0423*  	inc		hl
0407F5 1B          0424*  	dec		de
0407F6 18 EF       0425*  	jr		shr_loop
0407F8             0426*  shr_done:
0407F8 2A FD 07 04 0427*  	ld		hl,(bitbuf1)	;collect result
0407FC C9          0428*  	ret
0407FD             0429*  
0407FD             0430*  ;------------------------------------------------------------------------
0407FD             0431*  ; Scratch area for calculations
0407FD             0432*  ;------------------------------------------------------------------------
0407FD 00 00 00    0433*  bitbuf1:	dw24	0	;bit manipulation buffer 1
040800 00 00 00    0434*  bitbuf2:	dw24	0	;bit manipulation buffer 2
040803             0435*  
040803             0436*  ; ========== FROM maths24.inc ==========
040803             0437*  
040803             0438*  ; hlu 1 byte right shift
040803             0439*  ; returns: hlu / 256, fractional portion in a
040803             0440*  ; destroys: af
040803             0441*  shift_hlu_r1b:
040803 AF          0442*  	xor a
040804 32 15 08 04 0443*  	ld (@buffer+3),a
040808 7D          0444*  	ld a,l ; save the fractional portion
040809 22 12 08 04 0445*  	ld (@buffer),hl
04080D 2A 13 08 04 0446*  	ld hl,(@buffer+1)
040811 C9          0447*  	ret
040812             0448*  @buffer: ds 4
040816             0449*  
040816             0450*  ; Expects  ADL mode
040816             0451*  ; Inputs:  UH.L
040816             0452*  ; Outputs: UH.L is the 16.8 square root
040816             0453*  ;          UD.E is the difference inputHL-DE^2
040816             0454*  ;          c flag reset
040816             0455*  sqrt168:
040816 CD 20 08 04 0456*      call sqrt24
04081A EB          0457*      ex de,hl
04081B 29          0458*      add hl,hl
04081C 29          0459*      add hl,hl
04081D 29          0460*      add hl,hl
04081E 29          0461*      add hl,hl
04081F C9          0462*      ret
040820             0463*  
040820             0464*  ; Expects  ADL mode
040820             0465*  ; Inputs:  HL
040820             0466*  ; Outputs: DE is the integer square root
040820             0467*  ;          HL is the difference inputHL-DE^2
040820             0468*  ;          c flag reset
040820             0469*  sqrt24:
040820 AF          0470*      xor a
040821 45          0471*      ld b,l
040822 C5          0472*      push bc
040823 47          0473*      ld b,a
040824 57          0474*      ld d,a
040825 4F          0475*      ld c,a
040826 6F          0476*      ld l,a
040827 5F          0477*      ld e,a
040828             0478*  
040828             0479*      ;Iteration 1
040828 29          0480*      add hl,hl
040829 CB 11       0481*      rl c
04082B 29          0482*      add hl,hl
04082C CB 11       0483*      rl c
04082E 91          0484*      sub c
04082F 30 04       0485*      jr nc,$+6
040831 1C          0486*      inc e
040832 1C          0487*      inc e
040833 2F          0488*      cpl
040834 4F          0489*      ld c,a
040835             0490*  
040835             0491*      ;Iteration 2
040835 29          0492*      add hl,hl
040836 CB 11       0493*      rl c
040838 29          0494*      add hl,hl
040839 CB 11       0495*      rl c
04083B CB 13       0496*      rl e
04083D 7B          0497*      ld a,e
04083E 91          0498*      sub c
04083F 30 04       0499*      jr nc,$+6
040841 1C          0500*      inc e
040842 1C          0501*      inc e
040843 2F          0502*      cpl
040844 4F          0503*      ld c,a
040845             0504*  
040845             0505*      ;Iteration 3
040845 29          0506*      add hl,hl
040846 CB 11       0507*      rl c
040848 29          0508*      add hl,hl
040849 CB 11       0509*      rl c
04084B CB 13       0510*      rl e
04084D 7B          0511*      ld a,e
04084E 91          0512*      sub c
04084F 30 04       0513*      jr nc,$+6
040851 1C          0514*      inc e
040852 1C          0515*      inc e
040853 2F          0516*      cpl
040854 4F          0517*      ld c,a
040855             0518*  
040855             0519*      ;Iteration 4
040855 29          0520*      add hl,hl
040856 CB 11       0521*      rl c
040858 29          0522*      add hl,hl
040859 CB 11       0523*      rl c
04085B CB 13       0524*      rl e
04085D 7B          0525*      ld a,e
04085E 91          0526*      sub c
04085F 30 04       0527*      jr nc,$+6
040861 1C          0528*      inc e
040862 1C          0529*      inc e
040863 2F          0530*      cpl
040864 4F          0531*      ld c,a
040865             0532*  
040865             0533*      ;Iteration 5
040865 29          0534*      add hl,hl
040866 CB 11       0535*      rl c
040868 29          0536*      add hl,hl
040869 CB 11       0537*      rl c
04086B CB 13       0538*      rl e
04086D 7B          0539*      ld a,e
04086E 91          0540*      sub c
04086F 30 04       0541*      jr nc,$+6
040871 1C          0542*      inc e
040872 1C          0543*      inc e
040873 2F          0544*      cpl
040874 4F          0545*      ld c,a
040875             0546*  
040875             0547*      ;Iteration 6
040875 29          0548*      add hl,hl
040876 CB 11       0549*      rl c
040878 29          0550*      add hl,hl
040879 CB 11       0551*      rl c
04087B CB 13       0552*      rl e
04087D 7B          0553*      ld a,e
04087E 91          0554*      sub c
04087F 30 04       0555*      jr nc,$+6
040881 1C          0556*      inc e
040882 1C          0557*      inc e
040883 2F          0558*      cpl
040884 4F          0559*      ld c,a
040885             0560*  
040885             0561*      ;Iteration 7
040885 29          0562*      add hl,hl
040886 CB 11       0563*      rl c
040888 29          0564*      add hl,hl
040889 CB 11       0565*      rl c
04088B CB 10       0566*      rl b
04088D EB          0567*      ex de,hl
04088E 29          0568*      add hl,hl
04088F E5          0569*      push hl
040890 ED 42       0570*      sbc hl,bc
040892 30 06       0571*      jr nc,$+8
040894 7C          0572*      ld a,h
040895 2F          0573*      cpl
040896 47          0574*      ld b,a
040897 7D          0575*      ld a,l
040898 2F          0576*      cpl
040899 4F          0577*      ld c,a
04089A E1          0578*      pop hl
04089B 30 02       0579*      jr nc,$+4
04089D 23          0580*      inc hl
04089E 23          0581*      inc hl
04089F EB          0582*      ex de,hl
0408A0             0583*  
0408A0             0584*      ;Iteration 8
0408A0 29          0585*      add hl,hl
0408A1 69          0586*      ld l,c
0408A2 60          0587*      ld h,b
0408A3 ED 6A       0588*      adc hl,hl
0408A5 ED 6A       0589*      adc hl,hl
0408A7 EB          0590*      ex de,hl
0408A8 29          0591*      add hl,hl
0408A9 ED 52       0592*      sbc hl,de
0408AB 19          0593*      add hl,de
0408AC EB          0594*      ex de,hl
0408AD 30 04       0595*      jr nc,$+6
0408AF ED 52       0596*      sbc hl,de
0408B1 13          0597*      inc de
0408B2 13          0598*      inc de
0408B3             0599*  
0408B3             0600*      ;Iteration 9
0408B3 F1          0601*      pop af
0408B4 17          0602*      rla
0408B5 ED 6A       0603*      adc hl,hl
0408B7 17          0604*      rla
0408B8 ED 6A       0605*      adc hl,hl
0408BA EB          0606*      ex de,hl
0408BB 29          0607*      add hl,hl
0408BC ED 52       0608*      sbc hl,de
0408BE 19          0609*      add hl,de
0408BF EB          0610*      ex de,hl
0408C0 30 04       0611*      jr nc,$+6
0408C2 ED 52       0612*      sbc hl,de
0408C4 13          0613*      inc de
0408C5 13          0614*      inc de
0408C6             0615*  
0408C6             0616*      ;Iteration 10
0408C6 17          0617*      rla
0408C7 ED 6A       0618*      adc hl,hl
0408C9 17          0619*      rla
0408CA ED 6A       0620*      adc hl,hl
0408CC EB          0621*      ex de,hl
0408CD 29          0622*      add hl,hl
0408CE ED 52       0623*      sbc hl,de
0408D0 19          0624*      add hl,de
0408D1 EB          0625*      ex de,hl
0408D2 30 04       0626*      jr nc,$+6
0408D4 ED 52       0627*      sbc hl,de
0408D6 13          0628*      inc de
0408D7 13          0629*      inc de
0408D8             0630*  
0408D8             0631*      ;Iteration 11
0408D8 17          0632*      rla
0408D9 ED 6A       0633*      adc hl,hl
0408DB 17          0634*      rla
0408DC ED 6A       0635*      adc hl,hl
0408DE EB          0636*      ex de,hl
0408DF 29          0637*      add hl,hl
0408E0 ED 52       0638*      sbc hl,de
0408E2 19          0639*      add hl,de
0408E3 EB          0640*      ex de,hl
0408E4 30 04       0641*      jr nc,$+6
0408E6 ED 52       0642*      sbc hl,de
0408E8 13          0643*      inc de
0408E9 13          0644*      inc de
0408EA             0645*  
0408EA             0646*      ;Iteration 11
0408EA 17          0647*      rla
0408EB ED 6A       0648*      adc hl,hl
0408ED 17          0649*      rla
0408EE ED 6A       0650*      adc hl,hl
0408F0 EB          0651*      ex de,hl
0408F1 29          0652*      add hl,hl
0408F2 ED 52       0653*      sbc hl,de
0408F4 19          0654*      add hl,de
0408F5 EB          0655*      ex de,hl
0408F6 30 04       0656*      jr nc,$+6
0408F8 ED 52       0657*      sbc hl,de
0408FA 13          0658*      inc de
0408FB 13          0659*      inc de
0408FC             0660*  
0408FC CB 1A       0661*      rr d
0408FE CB 1B       0662*      rr e
040900 C9          0663*      ret
040901             0036       include "trig24.inc"
040901             0001*  
040901             0002*  ; convert unsigned angles from a 360 to 255 degree circle
040901             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040901             0004*  ; outputs: uh.l is the angle255 in 16.8 fixed format
040901             0005*  ; destroys: TODO
040901             0006*  ; note: even though the inputs and outputs are 16.8 fixed format
040901             0007*  ;       precision is effectively limited to 8.8 fixed format
040901             0008*  deg_360_to_255:
040901             0009*  ; clear scratch buffer
040901 11 00 00 00 0010*  	ld de,0
040905 ED 53 31 09 0011*  	ld (@scratch),de
       04          
04090A             0012*  ; divide uh.l by 360
04090A 11 68 01 00 0013*  	ld de,360
04090E             0014*  ; get integer portion
04090E CD ED 06 04 0015*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
040912 ED 53 38 09 0016*  	ld (@output+1),de ; shift result up one byte
       04          
040917             0017*  ; get fractional portion
040917 22 32 09 04 0018*  	ld (@scratch+1),hl ; shift remainder up one byte
04091B 2A 31 09 04 0019*  	ld hl,(@scratch)
04091F 11 68 01 00 0020*  	ld de,360
040923 CD ED 06 04 0021*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
040927 7B          0022*  	ld a,e ; lowest byte is all we need
040928 32 37 09 04 0023*  	ld (@output),a
04092C             0024*  ; we want the low 3 bytes for 16.8 output
04092C 2A 37 09 04 0025*  	ld hl,(@output)
040930 C9          0026*  	ret
040931             0027*  @scratch: ds 6 ; scratch buffer for shifting bytes
040937             0028*  @output: ds 6 ; scratch buffer to accumulate output
04093D             0029*  
04093D             0030*  ; 16.8 fixed inputs / outputs
04093D             0031*  ; takes: uh.l as angle in degrees 256
04093D             0032*  ;        ud.e as radius
04093D             0033*  ; returns ub.c as dx, ud.e as dy
04093D             0034*  ;        displacements from origin (0,0)
04093D             0035*  ; destroys: everything except indexes
04093D             0036*  polar_to_cartesian:
04093D             0037*  ; back up input parameters
04093D 22 F7 05 04 0038*      ld (arith24uhl), hl
040941 ED 53 03 06 0039*      ld (arith24ude), de
       04          
040946             0040*  ; compute dx = sin(uh.l) * ud.e
040946 CD 75 09 04 0041*      call sin168
04094A E5          0042*      push hl
04094B C1          0043*      pop bc          ; ub.c = sin(uh.l)
04094C ED 5B 03 06 0044*  	ld de, (arith24ude)   ; get radius back
       04          
040951 CD B6 06 04 0045*  	call smul168    ; uh.l = ub.c * ud.e = dx
040955 E5          0046*      push hl         ; store dx for output
040956             0047*  ; compute dy = -cos(uh.l) * ud.e
040956 2A F7 05 04 0048*      ld hl, (arith24uhl)
04095A CD 70 09 04 0049*      call cos168
04095E CD 72 05 04 0050*  	call neg_hlu    ; invert dy for screen coords convention
040962 E5          0051*      push hl
040963 C1          0052*      pop bc          ; ub.c = -cos(uh.l)
040964 ED 5B 03 06 0053*      ld de, (arith24ude)   ; get radius back
       04          
040969 CD B6 06 04 0054*      call smul168    ; uh.l = ub.c * ud.e = dy
04096D EB          0055*      ex de, hl       ; de = dy for output
04096E C1          0056*      pop bc          ; bc = dx for output
04096F             0057*  ; and out
04096F C9          0058*      ret
040970             0059*  
040970             0060*  ; fixed 16.8 routine
040970             0061*  ; cos(uh.l) --> uh.l
040970             0062*  ; destroys: de
040970             0063*  cos168:
040970             0064*  ; for cos we simply increment the angle by 90 degrees
040970             0065*  ; or 0x004000 in 16.8 degrees256
040970             0066*  ; which makes it a sin problem
040970 11 00 40 00 0067*      ld de,0x004000
040974 19          0068*      add hl,de ; modulo 256 happens below
040975             0069*  ; fall through to sin168
040975             0070*  ; ---------------------
040975             0071*  ; fixed 16.8 routine
040975             0072*  ; sin(uh.l) --> uh.l
040975             0073*  ; destroys: de
040975             0074*  sin168:
040975             0075*  ; h contains the integer portion of our angle
040975             0076*  ; we multiply it by three to get our lookup table index
040975 2E 03       0077*      ld l,3
040977 ED 6C       0078*      mlt hl ; gosh that is handy
040979 11 00 00 00 0079*      ld de,0 ; clear deu
04097D 54          0080*      ld d,h ; copy hl to de
04097E 5D          0081*      ld e,l ; de contains our index
04097F 21 9B 0A 04 0082*      ld hl,sin_lut_168 ; grab the lut address
040983 19          0083*      add hl,de ; bump hl by the index
040984 ED 27       0084*      ld hl,(hl) ; don't try this on a z80!
040986 C9          0085*      ret ; and out
040987             0086*  
040987             0087*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040987             0088*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040987             0089*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040987             0090*  ;         also populates scratch locations dx168 and dy168
040987             0091*  ; destroys: a,hl,bc,de
040987             0092*  dxy168:
040987             0093*  ; compute dx = x1-x0
040987 AF          0094*      xor a ; clear carry
040988 DD E5       0095*      push ix ; move ix to hl via the stack
04098A E1          0096*      pop hl ; hl = x1
04098B ED 42       0097*      sbc hl,bc ; hl = dx
04098D 22 E2 09 04 0098*      ld (dx168),hl ; dx to scratch
040991             0099*  ; compute dy = y1-y0
040991 AF          0100*      xor a ; clear carry
040992 FD E5       0101*      push iy ; move iy to hl via the stack
040994 E1          0102*      pop hl ; hl = y1
040995 ED 52       0103*      sbc hl,de ; hl = dy
040997 22 E8 09 04 0104*      ld (dy168),hl ; dy to scratch
04099B             0105*  ; populate output registers and return
04099B EB          0106*      ex de,hl        ; ud.e = dy
04099C ED 4B E2 09 0107*      ld bc,(dx168)   ; ub.c = dx
       04          
0409A1 C9          0108*      ret
0409A2             0109*  
0409A2             0110*  ; compute the euclidian distance between two cartesian coordinates
0409A2             0111*  ; using the formula d = sqrt(dx^2+dy^2
0409A2             0112*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0409A2             0113*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0409A2             0114*  ; output; uh.l is the 16.8 fixed format distance
0409A2             0115*  ;       dx168/y are the 16.8 fixed format dx and dy
0409A2             0116*  ; destroys: a,hl,bc,de
0409A2             0117*  distance168:
0409A2             0118*  ; compute dx = x1-x0
0409A2 AF          0119*      xor a ; clear carry
0409A3 DD E5       0120*      push ix ; move ix to hl via the stack
0409A5 E1          0121*      pop hl ; hl = x1
0409A6 ED 42       0122*      sbc hl,bc ; hl = dx
0409A8 22 E2 09 04 0123*      ld (dx168),hl ; dx to scratch
0409AC             0124*  ; ; test dx for overflow
0409AC             0125*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0409AC             0126*  ; 	ex de,hl
0409AC             0127*  ; 	sbc hl,de ; test for overflow
0409AC             0128*  ; 	push af ; carry indicates overflow
0409AC             0129*  ; compute dy = y1-y0
0409AC AF          0130*      xor a ; clear carry
0409AD FD E5       0131*      push iy ; move iy to hl via the stack
0409AF E1          0132*      pop hl ; hl = y1
0409B0 ED 52       0133*      sbc hl,de ; hl = dy
0409B2 22 E8 09 04 0134*      ld (dy168),hl ; dy to scratch
0409B6             0135*  ; ; test dy for overflow
0409B6             0136*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0409B6             0137*  ; 	ex de,hl
0409B6             0138*  ; 	sbc hl,de ; test for overflow
0409B6             0139*  ; 	push af ; carry indicates overflow
0409B6             0140*  ; compute dy^2
0409B6 2A E8 09 04 0141*  	ld hl,(dy168)
0409BA CD 62 05 04 0142*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0409BE             0143*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0409BE E5          0144*      push hl ; load hl/2 to bc via the stack
0409BF C1          0145*      pop bc ; bc = dy/2
0409C0 EB          0146*      ex de,hl ; de = dy/2
0409C1 CD AE 06 04 0147*      call umul168 ; uh.l = dy^2/2
0409C5 E5          0148*      push hl ; dy^2/2 to the stack
0409C6             0149*  ; compute dx^2
0409C6 2A E2 09 04 0150*      ld hl,(dx168) ; get back dx
0409CA CD 62 05 04 0151*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0409CE             0152*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0409CE E5          0153*      push hl ; load hl/2 to bc via the stack
0409CF C1          0154*      pop bc ; bc = dx/2
0409D0 EB          0155*      ex de,hl ; de = dx/2
0409D1 CD AE 06 04 0156*      call umul168 ; uh.l = dx^2/2
0409D5             0157*  ; commpute dy^2+dx^2
0409D5 D1          0158*      pop de ; get back dx^2/2
0409D6 19          0159*      add hl,de ; hl = dx^2/2+dy^2/2
0409D7             0160*  ; compute sqrt(dx^2/2+dy^2/2)
0409D7 CD 16 08 04 0161*      call sqrt168 ; uh.l = distance/2
0409DB             0162*      ; add hl,hl ; hl = distance
0409DB             0163*  ; ; check for overflow
0409DB             0164*  ; 	pop af ; get back the overflow flags
0409DB             0165*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0409DB             0166*  ; 	ld b,a ; save the overflow flag
0409DB             0167*  ; 	pop af ; get back the overflow flags
0409DB             0168*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0409DB             0169*  ; 	add a,b ; if a != 0 then we had overflow
0409DB             0170*  ;     ret z ; no overflow we're done
0409DB             0171*  ; @overflow:
0409DB             0172*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0409DB C9          0173*  	ret
0409DC             0174*  @scratch: ds 6
0409E2             0175*  dx168: ds 6
0409E8             0176*  dy168: ds 6
0409EE             0177*  
0409EE             0178*  ; atan2(ub.c,ud.e) --> uh.l
0409EE             0179*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0409EE             0180*  ;   whether inputs are integers or fractional doesn't matter
0409EE             0181*  ;   so long as the sign bit of the upper byte is correct
0409EE             0182*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0409EE             0183*  ; angles are COMPASS HEADINGS based on
0409EE             0184*  ; screen coordinate conventions,where the y axis is flipped
0409EE             0185*  ; #E0 315      0       45 #20
0409EE             0186*  ;        -x,-y | +x,-y
0409EE             0187*  ; #C0 270------+------ 90 #40
0409EE             0188*  ;        -x,+y | +x,+y
0409EE             0189*  ; #A0 225   180 #80   135 #60
0409EE             0190*  atan2_168game:
0409EE             0191*  ; get signs and make everything positive
0409EE             0192*  ; get abs(x) and store its original sign
0409EE C5          0193*      push bc
0409EF E1          0194*      pop hl
0409F0 CD 62 05 04 0195*      call abs_hlu ; if x was negative this also sets the sign flag
0409F4 E5          0196*      push hl ; store abs(x)
0409F5 C1          0197*      pop bc ; bc = abs(x)
0409F6 F5          0198*      push af ; store sign of x
0409F7             0199*  ; get abs(y) and store its original sign
0409F7 EB          0200*      ex de,hl ; hl = y
0409F8 CD 62 05 04 0201*      call abs_hlu ; if y was negative this also sets the sign flag
0409FC EB          0202*      ex de,hl ; de = abs(y)
0409FD F5          0203*      push af ; store sign of y
0409FE             0204*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0409FE             0205*  ; this ensures that our lookup value is between 0 and 1 inclusive
0409FE AF          0206*      xor a ; clear the carry flag
0409FF D5          0207*      push de
040A00 E1          0208*      pop hl
040A01 ED 42       0209*      sbc hl,bc
040A03 F5          0210*      push af ; save sign of de - bc
040A04 F2 0D 0A 04 0211*      jp p,@1 ; bc <= de, so we skip ahead
040A08             0212*  ; otherwise we swap bc and de
040A08 C5          0213*      push bc
040A09 E1          0214*      pop hl
040A0A EB          0215*      ex de,hl
040A0B E5          0216*      push hl
040A0C C1          0217*      pop bc
040A0D             0218*  @1:
040A0D             0219*  ; now we're ready to snag our preliminary result
040A0D CD 7B 0A 04 0220*      call atan_168game ; uh.l comes back with prelim result
040A11             0221*  ; now we adjust uh.l based on sign of de - bc
040A11 F1          0222*      pop af
040A12 F2 1E 0A 04 0223*      jp p,@2 ; bc <= de,so we skip ahead
040A16 EB          0224*      ex de,hl
040A17 21 00 40 00 0225*      ld hl,0x004000 ; 90 degrees
040A1B AF          0226*      xor a ; clear the carry flag
040A1C ED 52       0227*      sbc hl,de ; subtract result from 90 degrees
040A1E             0228*      ; ld de,0 ; prep to clear hlu
040A1E             0229*      ; ld d,h
040A1E             0230*      ; ld e,l
040A1E             0231*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
040A1E             0232*      ; fall through
040A1E             0233*  @2:
040A1E             0234*  ; now the fun part of adjusting the result
040A1E             0235*  ; based on which quadrant (x,y) is in
040A1E             0236*  ; #E0 315      0       45 #20
040A1E             0237*  ;        -x,-y | +x,-y
040A1E             0238*  ; #C0 270------+------ 90 #40
040A1E             0239*  ;        -x,+y | +x,+y
040A1E             0240*  ; #A0 225   180 #80   135 #60
040A1E F1          0241*      pop af ; sign of y
040A1F CA 5C 0A 04 0242*      jp z,@y_zero
040A23 F2 3C 0A 04 0243*      jp p,@y_pos
040A27             0244*  ; y neg,check x
040A27 F1          0245*      pop af ; sign of x
040A28 CA 36 0A 04 0246*      jp z,@y_neg_x_zero
040A2C F2 3B 0A 04 0247*      jp p,@y_neg_x_pos
040A30             0248*  ; y neg,x neg
040A30             0249*  ; angle is 270-360
040A30             0250*  ; negating the intermediate does the trick
040A30 CD 72 05 04 0251*      call neg_hlu
040A34 18 31       0252*      jr @zero_hlu
040A36             0253*  
040A36             0254*  @y_neg_x_zero:
040A36             0255*  ; y neg,x zero
040A36             0256*  ; angle is 0
040A36 21 00 00 00 0257*      ld hl,0
040A3A C9          0258*      ret
040A3B             0259*  @y_neg_x_pos:
040A3B             0260*  ; y neg,x pos
040A3B             0261*  ; angle is 0 to 90
040A3B             0262*  ; so we're good
040A3B C9          0263*      ret
040A3C             0264*  
040A3C             0265*  @y_pos:
040A3C F1          0266*      pop af ; sign of x
040A3D CA 4C 0A 04 0267*      jp z,@y_pos_x_zero
040A41 F2 51 0A 04 0268*      jp p,@y_pos_x_pos
040A45             0269*  ; y pos,x neg
040A45             0270*  ; angle is 180-270
040A45             0271*  ; so we add 180 to intermediate
040A45 11 00 80 00 0272*      ld de,0x008000
040A49 19          0273*      add hl,de
040A4A 18 1B       0274*      jr @zero_hlu
040A4C             0275*  @y_pos_x_zero:
040A4C             0276*  ; y pos,x zero
040A4C             0277*  ; angle is 180
040A4C 21 00 80 00 0278*      ld hl,0x008000
040A50 C9          0279*      ret
040A51             0280*  @y_pos_x_pos:
040A51             0281*  ; y pos,x pos
040A51             0282*  ; angle is 90-180
040A51             0283*  ; neg the intermediate and add 180 degrees
040A51 CD 72 05 04 0284*      call neg_hlu
040A55 11 00 80 00 0285*      ld de,0x008000
040A59 19          0286*      add hl,de
040A5A 18 0B       0287*      jr @zero_hlu
040A5C             0288*  
040A5C             0289*  @y_zero:
040A5C F1          0290*      pop af ; sign of x
040A5D FA 62 0A 04 0291*      jp m,@y_zero_x_neg
040A61             0292*  ; y zero,x pos
040A61             0293*  ; angle is 90,nothing to do
040A61 C9          0294*      ret
040A62             0295*  @y_zero_x_neg:
040A62             0296*  ; y zero ,x neg
040A62             0297*  ; angle is 270
040A62 21 00 C0 00 0298*      ld hl,0x00C000
040A66 C9          0299*      ret
040A67             0300*  @zero_hlu:
040A67 AF          0301*      xor a
040A68 22 75 0A 04 0302*      ld (@scratch),hl
040A6C 32 77 0A 04 0303*      ld (@scratch+2),a
040A70 2A 75 0A 04 0304*      ld hl,(@scratch)
040A74 C9          0305*      ret
040A75             0306*  @scratch: ds 6
040A7B             0307*  
040A7B             0308*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040A7B             0309*  ; output: uh.l is the 16.8 fixed format angle
040A7B             0310*  ; destroys: a,hl,bc,de
040A7B             0311*  ; the following note was written by github copilot:
040A7B             0312*  ; note: this routine is a bit of a hack
040A7B             0313*  ;      but it works
040A7B             0314*  ;      and it's fast
040A7B             0315*  ;      and it's small
040A7B             0316*  ;      and it's accurate
040A7B             0317*  ;      and it's easy to understand
040A7B             0318*  ;      and it's easy to modify
040A7B             0319*  ;      and it's easy to use
040A7B             0320*  ;      and it's easy to remember
040A7B             0321*  ;      and it's easy to love
040A7B             0322*  ;      and it's easy to hate
040A7B             0323*  ;      and it's easy to ignore
040A7B             0324*  ;      and it's easy to forget
040A7B             0325*  ;      and it's easy to remember
040A7B             0326*  ;      and it's easy to forget
040A7B             0327*  ;      and it's easy to remember
040A7B             0328*  ;      (ok the bot is stuck in a loop)
040A7B             0329*  ; REAL NOTE: only works for angles from 0 to 45 degrees
040A7B             0330*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
040A7B             0331*  atan_168game:
040A7B             0332*  ; because we use compass headings instead of geometric angles
040A7B             0333*  ; we compute dx/dy which is 1/tan(theta) in the maths world
040A7B             0334*  ; we can do faster unsigned division here because we know dx and dy are positive
040A7B CD 11 07 04 0335*  	call udiv168 ; uh.l = dx/dy
040A7F             0336*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
040A7F             0337*  ; ; test uh.l for 0
040A7F             0338*  ;     add hl,de
040A7F             0339*  ;     or a
040A7F             0340*  ;     sbc hl,de
040A7F             0341*  ;     jr z,@is_zero
040A7F             0342*  ; ; test uh.l for 1
040A7F             0343*  ;     xor a ; clear carry
040A7F             0344*  ;     ex de,hl
040A7F             0345*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
040A7F             0346*  ;     sbc hl,de
040A7F             0347*  ;     jr z,@is_45
040A7F             0348*  ; ; END TODO
040A7F             0349*  
040A7F             0350*  ; no special cases so we move on
040A7F             0351*  ; l contains the fractional portion of tan(uh.l)
040A7F             0352*  ; we multiply it by three to get our lookup table index
040A7F 26 03       0353*      ld h,3
040A81 ED 6C       0354*      mlt hl ; gosh that is handy
040A83 11 00 00 00 0355*      ld de,0 ; clear deu
040A87 54          0356*      ld d,h ; copy hl to de
040A88 5D          0357*      ld e,l ; de contains our index
040A89 21 9B 0D 04 0358*      ld hl,atan_lut_168 ; grab the lut address
040A8D 19          0359*      add hl,de ; bump hl by the index
040A8E ED 27       0360*      ld hl,(hl) ; don't try this on a z80!
040A90 C9          0361*      ret ; and out
040A91             0362*  @is_45:
040A91 21 00 20 00 0363*      ld hl,0x002000 ; 45 degrees decimal
040A95 C9          0364*      ret
040A96             0365*  ; for the case tan(0)
040A96             0366*  @is_zero:
040A96 21 00 00 00 0367*      ld hl,0x000000
040A9A C9          0368*      ret
040A9B             0369*  
040A9B             0370*  
040A9B             0371*  sin_lut_168:
040A9B 00 00 00    0372*  	dl 0x000000 ; 0.000 00, 0.000
040A9E 06 00 00    0373*  	dl 0x000006 ; 1.406 01, 0.025
040AA1 0C 00 00    0374*  	dl 0x00000C ; 2.813 02, 0.049
040AA4 12 00 00    0375*  	dl 0x000012 ; 4.219 03, 0.074
040AA7 19 00 00    0376*  	dl 0x000019 ; 5.625 04, 0.098
040AAA 1F 00 00    0377*  	dl 0x00001F ; 7.031 05, 0.122
040AAD 25 00 00    0378*  	dl 0x000025 ; 8.438 06, 0.147
040AB0 2B 00 00    0379*  	dl 0x00002B ; 9.844 07, 0.171
040AB3 31 00 00    0380*  	dl 0x000031 ; 11.250 08, 0.195
040AB6 38 00 00    0381*  	dl 0x000038 ; 12.656 09, 0.219
040AB9 3E 00 00    0382*  	dl 0x00003E ; 14.063 0A, 0.243
040ABC 44 00 00    0383*  	dl 0x000044 ; 15.469 0B, 0.267
040ABF 4A 00 00    0384*  	dl 0x00004A ; 16.875 0C, 0.290
040AC2 50 00 00    0385*  	dl 0x000050 ; 18.281 0D, 0.314
040AC5 56 00 00    0386*  	dl 0x000056 ; 19.688 0E, 0.337
040AC8 5C 00 00    0387*  	dl 0x00005C ; 21.094 0F, 0.360
040ACB 61 00 00    0388*  	dl 0x000061 ; 22.500 10, 0.383
040ACE 67 00 00    0389*  	dl 0x000067 ; 23.906 11, 0.405
040AD1 6D 00 00    0390*  	dl 0x00006D ; 25.313 12, 0.428
040AD4 73 00 00    0391*  	dl 0x000073 ; 26.719 13, 0.450
040AD7 78 00 00    0392*  	dl 0x000078 ; 28.125 14, 0.471
040ADA 7E 00 00    0393*  	dl 0x00007E ; 29.531 15, 0.493
040ADD 83 00 00    0394*  	dl 0x000083 ; 30.938 16, 0.514
040AE0 88 00 00    0395*  	dl 0x000088 ; 32.344 17, 0.535
040AE3 8E 00 00    0396*  	dl 0x00008E ; 33.750 18, 0.556
040AE6 93 00 00    0397*  	dl 0x000093 ; 35.156 19, 0.576
040AE9 98 00 00    0398*  	dl 0x000098 ; 36.563 1A, 0.596
040AEC 9D 00 00    0399*  	dl 0x00009D ; 37.969 1B, 0.615
040AEF A2 00 00    0400*  	dl 0x0000A2 ; 39.375 1C, 0.634
040AF2 A7 00 00    0401*  	dl 0x0000A7 ; 40.781 1D, 0.653
040AF5 AB 00 00    0402*  	dl 0x0000AB ; 42.188 1E, 0.672
040AF8 B0 00 00    0403*  	dl 0x0000B0 ; 43.594 1F, 0.690
040AFB B5 00 00    0404*  	dl 0x0000B5 ; 45.000 20, 0.707
040AFE B9 00 00    0405*  	dl 0x0000B9 ; 46.406 21, 0.724
040B01 BD 00 00    0406*  	dl 0x0000BD ; 47.813 22, 0.741
040B04 C1 00 00    0407*  	dl 0x0000C1 ; 49.219 23, 0.757
040B07 C5 00 00    0408*  	dl 0x0000C5 ; 50.625 24, 0.773
040B0A C9 00 00    0409*  	dl 0x0000C9 ; 52.031 25, 0.788
040B0D CD 00 00    0410*  	dl 0x0000CD ; 53.438 26, 0.803
040B10 D1 00 00    0411*  	dl 0x0000D1 ; 54.844 27, 0.818
040B13 D4 00 00    0412*  	dl 0x0000D4 ; 56.250 28, 0.831
040B16 D8 00 00    0413*  	dl 0x0000D8 ; 57.656 29, 0.845
040B19 DB 00 00    0414*  	dl 0x0000DB ; 59.063 2A, 0.858
040B1C DE 00 00    0415*  	dl 0x0000DE ; 60.469 2B, 0.870
040B1F E1 00 00    0416*  	dl 0x0000E1 ; 61.875 2C, 0.882
040B22 E4 00 00    0417*  	dl 0x0000E4 ; 63.281 2D, 0.893
040B25 E7 00 00    0418*  	dl 0x0000E7 ; 64.688 2E, 0.904
040B28 EA 00 00    0419*  	dl 0x0000EA ; 66.094 2F, 0.914
040B2B EC 00 00    0420*  	dl 0x0000EC ; 67.500 30, 0.924
040B2E EE 00 00    0421*  	dl 0x0000EE ; 68.906 31, 0.933
040B31 F1 00 00    0422*  	dl 0x0000F1 ; 70.313 32, 0.942
040B34 F3 00 00    0423*  	dl 0x0000F3 ; 71.719 33, 0.950
040B37 F4 00 00    0424*  	dl 0x0000F4 ; 73.125 34, 0.957
040B3A F6 00 00    0425*  	dl 0x0000F6 ; 74.531 35, 0.964
040B3D F8 00 00    0426*  	dl 0x0000F8 ; 75.938 36, 0.970
040B40 F9 00 00    0427*  	dl 0x0000F9 ; 77.344 37, 0.976
040B43 FB 00 00    0428*  	dl 0x0000FB ; 78.750 38, 0.981
040B46 FC 00 00    0429*  	dl 0x0000FC ; 80.156 39, 0.985
040B49 FD 00 00    0430*  	dl 0x0000FD ; 81.563 3A, 0.989
040B4C FE 00 00    0431*  	dl 0x0000FE ; 82.969 3B, 0.992
040B4F FE 00 00    0432*  	dl 0x0000FE ; 84.375 3C, 0.995
040B52 FF 00 00    0433*  	dl 0x0000FF ; 85.781 3D, 0.997
040B55 FF 00 00    0434*  	dl 0x0000FF ; 87.188 3E, 0.999
040B58 FF 00 00    0435*  	dl 0x0000FF ; 88.594 3F, 1.000
040B5B 00 01 00    0436*  	dl 0x000100 ; 90.000 40, 1.000
040B5E FF 00 00    0437*  	dl 0x0000FF ; 91.406 41, 1.000
040B61 FF 00 00    0438*  	dl 0x0000FF ; 92.813 42, 0.999
040B64 FF 00 00    0439*  	dl 0x0000FF ; 94.219 43, 0.997
040B67 FE 00 00    0440*  	dl 0x0000FE ; 95.625 44, 0.995
040B6A FE 00 00    0441*  	dl 0x0000FE ; 97.031 45, 0.992
040B6D FD 00 00    0442*  	dl 0x0000FD ; 98.438 46, 0.989
040B70 FC 00 00    0443*  	dl 0x0000FC ; 99.844 47, 0.985
040B73 FB 00 00    0444*  	dl 0x0000FB ; 101.250 48, 0.981
040B76 F9 00 00    0445*  	dl 0x0000F9 ; 102.656 49, 0.976
040B79 F8 00 00    0446*  	dl 0x0000F8 ; 104.063 4A, 0.970
040B7C F6 00 00    0447*  	dl 0x0000F6 ; 105.469 4B, 0.964
040B7F F4 00 00    0448*  	dl 0x0000F4 ; 106.875 4C, 0.957
040B82 F3 00 00    0449*  	dl 0x0000F3 ; 108.281 4D, 0.950
040B85 F1 00 00    0450*  	dl 0x0000F1 ; 109.688 4E, 0.942
040B88 EE 00 00    0451*  	dl 0x0000EE ; 111.094 4F, 0.933
040B8B EC 00 00    0452*  	dl 0x0000EC ; 112.500 50, 0.924
040B8E EA 00 00    0453*  	dl 0x0000EA ; 113.906 51, 0.914
040B91 E7 00 00    0454*  	dl 0x0000E7 ; 115.313 52, 0.904
040B94 E4 00 00    0455*  	dl 0x0000E4 ; 116.719 53, 0.893
040B97 E1 00 00    0456*  	dl 0x0000E1 ; 118.125 54, 0.882
040B9A DE 00 00    0457*  	dl 0x0000DE ; 119.531 55, 0.870
040B9D DB 00 00    0458*  	dl 0x0000DB ; 120.938 56, 0.858
040BA0 D8 00 00    0459*  	dl 0x0000D8 ; 122.344 57, 0.845
040BA3 D4 00 00    0460*  	dl 0x0000D4 ; 123.750 58, 0.831
040BA6 D1 00 00    0461*  	dl 0x0000D1 ; 125.156 59, 0.818
040BA9 CD 00 00    0462*  	dl 0x0000CD ; 126.563 5A, 0.803
040BAC C9 00 00    0463*  	dl 0x0000C9 ; 127.969 5B, 0.788
040BAF C5 00 00    0464*  	dl 0x0000C5 ; 129.375 5C, 0.773
040BB2 C1 00 00    0465*  	dl 0x0000C1 ; 130.781 5D, 0.757
040BB5 BD 00 00    0466*  	dl 0x0000BD ; 132.188 5E, 0.741
040BB8 B9 00 00    0467*  	dl 0x0000B9 ; 133.594 5F, 0.724
040BBB B5 00 00    0468*  	dl 0x0000B5 ; 135.000 60, 0.707
040BBE B0 00 00    0469*  	dl 0x0000B0 ; 136.406 61, 0.690
040BC1 AB 00 00    0470*  	dl 0x0000AB ; 137.813 62, 0.672
040BC4 A7 00 00    0471*  	dl 0x0000A7 ; 139.219 63, 0.653
040BC7 A2 00 00    0472*  	dl 0x0000A2 ; 140.625 64, 0.634
040BCA 9D 00 00    0473*  	dl 0x00009D ; 142.031 65, 0.615
040BCD 98 00 00    0474*  	dl 0x000098 ; 143.438 66, 0.596
040BD0 93 00 00    0475*  	dl 0x000093 ; 144.844 67, 0.576
040BD3 8E 00 00    0476*  	dl 0x00008E ; 146.250 68, 0.556
040BD6 88 00 00    0477*  	dl 0x000088 ; 147.656 69, 0.535
040BD9 83 00 00    0478*  	dl 0x000083 ; 149.063 6A, 0.514
040BDC 7E 00 00    0479*  	dl 0x00007E ; 150.469 6B, 0.493
040BDF 78 00 00    0480*  	dl 0x000078 ; 151.875 6C, 0.471
040BE2 73 00 00    0481*  	dl 0x000073 ; 153.281 6D, 0.450
040BE5 6D 00 00    0482*  	dl 0x00006D ; 154.688 6E, 0.428
040BE8 67 00 00    0483*  	dl 0x000067 ; 156.094 6F, 0.405
040BEB 61 00 00    0484*  	dl 0x000061 ; 157.500 70, 0.383
040BEE 5C 00 00    0485*  	dl 0x00005C ; 158.906 71, 0.360
040BF1 56 00 00    0486*  	dl 0x000056 ; 160.313 72, 0.337
040BF4 50 00 00    0487*  	dl 0x000050 ; 161.719 73, 0.314
040BF7 4A 00 00    0488*  	dl 0x00004A ; 163.125 74, 0.290
040BFA 44 00 00    0489*  	dl 0x000044 ; 164.531 75, 0.267
040BFD 3E 00 00    0490*  	dl 0x00003E ; 165.938 76, 0.243
040C00 38 00 00    0491*  	dl 0x000038 ; 167.344 77, 0.219
040C03 31 00 00    0492*  	dl 0x000031 ; 168.750 78, 0.195
040C06 2B 00 00    0493*  	dl 0x00002B ; 170.156 79, 0.171
040C09 25 00 00    0494*  	dl 0x000025 ; 171.563 7A, 0.147
040C0C 1F 00 00    0495*  	dl 0x00001F ; 172.969 7B, 0.122
040C0F 19 00 00    0496*  	dl 0x000019 ; 174.375 7C, 0.098
040C12 12 00 00    0497*  	dl 0x000012 ; 175.781 7D, 0.074
040C15 0C 00 00    0498*  	dl 0x00000C ; 177.188 7E, 0.049
040C18 06 00 00    0499*  	dl 0x000006 ; 178.594 7F, 0.025
040C1B 00 00 00    0500*  	dl 0x000000 ; 180.000 80, 0.000
040C1E FA FF FF    0501*  	dl 0xFFFFFA ; 181.406 81, -0.025
040C21 F4 FF FF    0502*  	dl 0xFFFFF4 ; 182.813 82, -0.049
040C24 EE FF FF    0503*  	dl 0xFFFFEE ; 184.219 83, -0.074
040C27 E7 FF FF    0504*  	dl 0xFFFFE7 ; 185.625 84, -0.098
040C2A E1 FF FF    0505*  	dl 0xFFFFE1 ; 187.031 85, -0.122
040C2D DB FF FF    0506*  	dl 0xFFFFDB ; 188.438 86, -0.147
040C30 D5 FF FF    0507*  	dl 0xFFFFD5 ; 189.844 87, -0.171
040C33 CF FF FF    0508*  	dl 0xFFFFCF ; 191.250 88, -0.195
040C36 C8 FF FF    0509*  	dl 0xFFFFC8 ; 192.656 89, -0.219
040C39 C2 FF FF    0510*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040C3C BC FF FF    0511*  	dl 0xFFFFBC ; 195.469 8B, -0.267
040C3F B6 FF FF    0512*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
040C42 B0 FF FF    0513*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
040C45 AA FF FF    0514*  	dl 0xFFFFAA ; 199.688 8E, -0.337
040C48 A4 FF FF    0515*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040C4B 9F FF FF    0516*  	dl 0xFFFF9F ; 202.500 90, -0.383
040C4E 99 FF FF    0517*  	dl 0xFFFF99 ; 203.906 91, -0.405
040C51 93 FF FF    0518*  	dl 0xFFFF93 ; 205.313 92, -0.428
040C54 8D FF FF    0519*  	dl 0xFFFF8D ; 206.719 93, -0.450
040C57 88 FF FF    0520*  	dl 0xFFFF88 ; 208.125 94, -0.471
040C5A 82 FF FF    0521*  	dl 0xFFFF82 ; 209.531 95, -0.493
040C5D 7D FF FF    0522*  	dl 0xFFFF7D ; 210.938 96, -0.514
040C60 78 FF FF    0523*  	dl 0xFFFF78 ; 212.344 97, -0.535
040C63 72 FF FF    0524*  	dl 0xFFFF72 ; 213.750 98, -0.556
040C66 6D FF FF    0525*  	dl 0xFFFF6D ; 215.156 99, -0.576
040C69 68 FF FF    0526*  	dl 0xFFFF68 ; 216.563 9A, -0.596
040C6C 63 FF FF    0527*  	dl 0xFFFF63 ; 217.969 9B, -0.615
040C6F 5E FF FF    0528*  	dl 0xFFFF5E ; 219.375 9C, -0.634
040C72 59 FF FF    0529*  	dl 0xFFFF59 ; 220.781 9D, -0.653
040C75 55 FF FF    0530*  	dl 0xFFFF55 ; 222.188 9E, -0.672
040C78 50 FF FF    0531*  	dl 0xFFFF50 ; 223.594 9F, -0.690
040C7B 4B FF FF    0532*  	dl 0xFFFF4B ; 225.000 A0, -0.707
040C7E 47 FF FF    0533*  	dl 0xFFFF47 ; 226.406 A1, -0.724
040C81 43 FF FF    0534*  	dl 0xFFFF43 ; 227.813 A2, -0.741
040C84 3F FF FF    0535*  	dl 0xFFFF3F ; 229.219 A3, -0.757
040C87 3B FF FF    0536*  	dl 0xFFFF3B ; 230.625 A4, -0.773
040C8A 37 FF FF    0537*  	dl 0xFFFF37 ; 232.031 A5, -0.788
040C8D 33 FF FF    0538*  	dl 0xFFFF33 ; 233.438 A6, -0.803
040C90 2F FF FF    0539*  	dl 0xFFFF2F ; 234.844 A7, -0.818
040C93 2C FF FF    0540*  	dl 0xFFFF2C ; 236.250 A8, -0.831
040C96 28 FF FF    0541*  	dl 0xFFFF28 ; 237.656 A9, -0.845
040C99 25 FF FF    0542*  	dl 0xFFFF25 ; 239.063 AA, -0.858
040C9C 22 FF FF    0543*  	dl 0xFFFF22 ; 240.469 AB, -0.870
040C9F 1F FF FF    0544*  	dl 0xFFFF1F ; 241.875 AC, -0.882
040CA2 1C FF FF    0545*  	dl 0xFFFF1C ; 243.281 AD, -0.893
040CA5 19 FF FF    0546*  	dl 0xFFFF19 ; 244.688 AE, -0.904
040CA8 16 FF FF    0547*  	dl 0xFFFF16 ; 246.094 AF, -0.914
040CAB 14 FF FF    0548*  	dl 0xFFFF14 ; 247.500 B0, -0.924
040CAE 12 FF FF    0549*  	dl 0xFFFF12 ; 248.906 B1, -0.933
040CB1 0F FF FF    0550*  	dl 0xFFFF0F ; 250.313 B2, -0.942
040CB4 0D FF FF    0551*  	dl 0xFFFF0D ; 251.719 B3, -0.950
040CB7 0C FF FF    0552*  	dl 0xFFFF0C ; 253.125 B4, -0.957
040CBA 0A FF FF    0553*  	dl 0xFFFF0A ; 254.531 B5, -0.964
040CBD 08 FF FF    0554*  	dl 0xFFFF08 ; 255.938 B6, -0.970
040CC0 07 FF FF    0555*  	dl 0xFFFF07 ; 257.344 B7, -0.976
040CC3 05 FF FF    0556*  	dl 0xFFFF05 ; 258.750 B8, -0.981
040CC6 04 FF FF    0557*  	dl 0xFFFF04 ; 260.156 B9, -0.985
040CC9 03 FF FF    0558*  	dl 0xFFFF03 ; 261.563 BA, -0.989
040CCC 02 FF FF    0559*  	dl 0xFFFF02 ; 262.969 BB, -0.992
040CCF 02 FF FF    0560*  	dl 0xFFFF02 ; 264.375 BC, -0.995
040CD2 01 FF FF    0561*  	dl 0xFFFF01 ; 265.781 BD, -0.997
040CD5 01 FF FF    0562*  	dl 0xFFFF01 ; 267.188 BE, -0.999
040CD8 01 FF FF    0563*  	dl 0xFFFF01 ; 268.594 BF, -1.000
040CDB 00 FF FF    0564*  	dl 0xFFFF00 ; 270.000 C0, -1.000
040CDE 01 FF FF    0565*  	dl 0xFFFF01 ; 271.406 C1, -1.000
040CE1 01 FF FF    0566*  	dl 0xFFFF01 ; 272.813 C2, -0.999
040CE4 01 FF FF    0567*  	dl 0xFFFF01 ; 274.219 C3, -0.997
040CE7 02 FF FF    0568*  	dl 0xFFFF02 ; 275.625 C4, -0.995
040CEA 02 FF FF    0569*  	dl 0xFFFF02 ; 277.031 C5, -0.992
040CED 03 FF FF    0570*  	dl 0xFFFF03 ; 278.438 C6, -0.989
040CF0 04 FF FF    0571*  	dl 0xFFFF04 ; 279.844 C7, -0.985
040CF3 05 FF FF    0572*  	dl 0xFFFF05 ; 281.250 C8, -0.981
040CF6 07 FF FF    0573*  	dl 0xFFFF07 ; 282.656 C9, -0.976
040CF9 08 FF FF    0574*  	dl 0xFFFF08 ; 284.063 CA, -0.970
040CFC 0A FF FF    0575*  	dl 0xFFFF0A ; 285.469 CB, -0.964
040CFF 0C FF FF    0576*  	dl 0xFFFF0C ; 286.875 CC, -0.957
040D02 0D FF FF    0577*  	dl 0xFFFF0D ; 288.281 CD, -0.950
040D05 0F FF FF    0578*  	dl 0xFFFF0F ; 289.688 CE, -0.942
040D08 12 FF FF    0579*  	dl 0xFFFF12 ; 291.094 CF, -0.933
040D0B 14 FF FF    0580*  	dl 0xFFFF14 ; 292.500 D0, -0.924
040D0E 16 FF FF    0581*  	dl 0xFFFF16 ; 293.906 D1, -0.914
040D11 19 FF FF    0582*  	dl 0xFFFF19 ; 295.313 D2, -0.904
040D14 1C FF FF    0583*  	dl 0xFFFF1C ; 296.719 D3, -0.893
040D17 1F FF FF    0584*  	dl 0xFFFF1F ; 298.125 D4, -0.882
040D1A 22 FF FF    0585*  	dl 0xFFFF22 ; 299.531 D5, -0.870
040D1D 25 FF FF    0586*  	dl 0xFFFF25 ; 300.938 D6, -0.858
040D20 28 FF FF    0587*  	dl 0xFFFF28 ; 302.344 D7, -0.845
040D23 2C FF FF    0588*  	dl 0xFFFF2C ; 303.750 D8, -0.831
040D26 2F FF FF    0589*  	dl 0xFFFF2F ; 305.156 D9, -0.818
040D29 33 FF FF    0590*  	dl 0xFFFF33 ; 306.563 DA, -0.803
040D2C 37 FF FF    0591*  	dl 0xFFFF37 ; 307.969 DB, -0.788
040D2F 3B FF FF    0592*  	dl 0xFFFF3B ; 309.375 DC, -0.773
040D32 3F FF FF    0593*  	dl 0xFFFF3F ; 310.781 DD, -0.757
040D35 43 FF FF    0594*  	dl 0xFFFF43 ; 312.188 DE, -0.741
040D38 47 FF FF    0595*  	dl 0xFFFF47 ; 313.594 DF, -0.724
040D3B 4B FF FF    0596*  	dl 0xFFFF4B ; 315.000 E0, -0.707
040D3E 50 FF FF    0597*  	dl 0xFFFF50 ; 316.406 E1, -0.690
040D41 55 FF FF    0598*  	dl 0xFFFF55 ; 317.813 E2, -0.672
040D44 59 FF FF    0599*  	dl 0xFFFF59 ; 319.219 E3, -0.653
040D47 5E FF FF    0600*  	dl 0xFFFF5E ; 320.625 E4, -0.634
040D4A 63 FF FF    0601*  	dl 0xFFFF63 ; 322.031 E5, -0.615
040D4D 68 FF FF    0602*  	dl 0xFFFF68 ; 323.438 E6, -0.596
040D50 6D FF FF    0603*  	dl 0xFFFF6D ; 324.844 E7, -0.576
040D53 72 FF FF    0604*  	dl 0xFFFF72 ; 326.250 E8, -0.556
040D56 78 FF FF    0605*  	dl 0xFFFF78 ; 327.656 E9, -0.535
040D59 7D FF FF    0606*  	dl 0xFFFF7D ; 329.063 EA, -0.514
040D5C 82 FF FF    0607*  	dl 0xFFFF82 ; 330.469 EB, -0.493
040D5F 88 FF FF    0608*  	dl 0xFFFF88 ; 331.875 EC, -0.471
040D62 8D FF FF    0609*  	dl 0xFFFF8D ; 333.281 ED, -0.450
040D65 93 FF FF    0610*  	dl 0xFFFF93 ; 334.688 EE, -0.428
040D68 99 FF FF    0611*  	dl 0xFFFF99 ; 336.094 EF, -0.405
040D6B 9F FF FF    0612*  	dl 0xFFFF9F ; 337.500 F0, -0.383
040D6E A4 FF FF    0613*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
040D71 AA FF FF    0614*  	dl 0xFFFFAA ; 340.313 F2, -0.337
040D74 B0 FF FF    0615*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
040D77 B6 FF FF    0616*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
040D7A BC FF FF    0617*  	dl 0xFFFFBC ; 344.531 F5, -0.267
040D7D C2 FF FF    0618*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
040D80 C8 FF FF    0619*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
040D83 CF FF FF    0620*  	dl 0xFFFFCF ; 348.750 F8, -0.195
040D86 D5 FF FF    0621*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
040D89 DB FF FF    0622*  	dl 0xFFFFDB ; 351.563 FA, -0.147
040D8C E1 FF FF    0623*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
040D8F E7 FF FF    0624*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
040D92 EE FF FF    0625*  	dl 0xFFFFEE ; 355.781 FD, -0.074
040D95 F4 FF FF    0626*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
040D98 FA FF FF    0627*  	dl 0xFFFFFA ; 358.594 FF, -0.025
040D9B             0628*  
040D9B             0629*  atan_lut_168:
040D9B 00 00 00    0630*  	dl 0x000000 ; 000000, 0.000
040D9E 28 00 00    0631*  	dl 0x000028 ; 000001, 0.224
040DA1 51 00 00    0632*  	dl 0x000051 ; 000002, 0.448
040DA4 7A 00 00    0633*  	dl 0x00007A ; 000003, 0.671
040DA7 A2 00 00    0634*  	dl 0x0000A2 ; 000004, 0.895
040DAA CB 00 00    0635*  	dl 0x0000CB ; 000005, 1.119
040DAD F4 00 00    0636*  	dl 0x0000F4 ; 000006, 1.343
040DB0 1D 01 00    0637*  	dl 0x00011D ; 000007, 1.566
040DB3 45 01 00    0638*  	dl 0x000145 ; 000008, 1.790
040DB6 6E 01 00    0639*  	dl 0x00016E ; 000009, 2.013
040DB9 97 01 00    0640*  	dl 0x000197 ; 00000A, 2.237
040DBC BF 01 00    0641*  	dl 0x0001BF ; 00000B, 2.460
040DBF E8 01 00    0642*  	dl 0x0001E8 ; 00000C, 2.684
040DC2 11 02 00    0643*  	dl 0x000211 ; 00000D, 2.907
040DC5 39 02 00    0644*  	dl 0x000239 ; 00000E, 3.130
040DC8 62 02 00    0645*  	dl 0x000262 ; 00000F, 3.353
040DCB 8B 02 00    0646*  	dl 0x00028B ; 000010, 3.576
040DCE B3 02 00    0647*  	dl 0x0002B3 ; 000011, 3.799
040DD1 DC 02 00    0648*  	dl 0x0002DC ; 000012, 4.022
040DD4 04 03 00    0649*  	dl 0x000304 ; 000013, 4.245
040DD7 2D 03 00    0650*  	dl 0x00032D ; 000014, 4.467
040DDA 55 03 00    0651*  	dl 0x000355 ; 000015, 4.690
040DDD 7E 03 00    0652*  	dl 0x00037E ; 000016, 4.912
040DE0 A6 03 00    0653*  	dl 0x0003A6 ; 000017, 5.134
040DE3 CE 03 00    0654*  	dl 0x0003CE ; 000018, 5.356
040DE6 F7 03 00    0655*  	dl 0x0003F7 ; 000019, 5.578
040DE9 1F 04 00    0656*  	dl 0x00041F ; 00001A, 5.799
040DEC 48 04 00    0657*  	dl 0x000448 ; 00001B, 6.021
040DEF 70 04 00    0658*  	dl 0x000470 ; 00001C, 6.242
040DF2 98 04 00    0659*  	dl 0x000498 ; 00001D, 6.463
040DF5 C0 04 00    0660*  	dl 0x0004C0 ; 00001E, 6.684
040DF8 E8 04 00    0661*  	dl 0x0004E8 ; 00001F, 6.905
040DFB 11 05 00    0662*  	dl 0x000511 ; 000020, 7.125
040DFE 39 05 00    0663*  	dl 0x000539 ; 000021, 7.345
040E01 61 05 00    0664*  	dl 0x000561 ; 000022, 7.565
040E04 89 05 00    0665*  	dl 0x000589 ; 000023, 7.785
040E07 B1 05 00    0666*  	dl 0x0005B1 ; 000024, 8.005
040E0A D9 05 00    0667*  	dl 0x0005D9 ; 000025, 8.224
040E0D 01 06 00    0668*  	dl 0x000601 ; 000026, 8.443
040E10 28 06 00    0669*  	dl 0x000628 ; 000027, 8.662
040E13 50 06 00    0670*  	dl 0x000650 ; 000028, 8.881
040E16 78 06 00    0671*  	dl 0x000678 ; 000029, 9.099
040E19 A0 06 00    0672*  	dl 0x0006A0 ; 00002A, 9.317
040E1C C7 06 00    0673*  	dl 0x0006C7 ; 00002B, 9.535
040E1F EF 06 00    0674*  	dl 0x0006EF ; 00002C, 9.752
040E22 16 07 00    0675*  	dl 0x000716 ; 00002D, 9.970
040E25 3E 07 00    0676*  	dl 0x00073E ; 00002E, 10.187
040E28 65 07 00    0677*  	dl 0x000765 ; 00002F, 10.403
040E2B 8D 07 00    0678*  	dl 0x00078D ; 000030, 10.620
040E2E B4 07 00    0679*  	dl 0x0007B4 ; 000031, 10.836
040E31 DB 07 00    0680*  	dl 0x0007DB ; 000032, 11.051
040E34 03 08 00    0681*  	dl 0x000803 ; 000033, 11.267
040E37 2A 08 00    0682*  	dl 0x00082A ; 000034, 11.482
040E3A 51 08 00    0683*  	dl 0x000851 ; 000035, 11.697
040E3D 78 08 00    0684*  	dl 0x000878 ; 000036, 11.911
040E40 9F 08 00    0685*  	dl 0x00089F ; 000037, 12.125
040E43 C6 08 00    0686*  	dl 0x0008C6 ; 000038, 12.339
040E46 ED 08 00    0687*  	dl 0x0008ED ; 000039, 12.553
040E49 13 09 00    0688*  	dl 0x000913 ; 00003A, 12.766
040E4C 3A 09 00    0689*  	dl 0x00093A ; 00003B, 12.978
040E4F 61 09 00    0690*  	dl 0x000961 ; 00003C, 13.191
040E52 87 09 00    0691*  	dl 0x000987 ; 00003D, 13.403
040E55 AE 09 00    0692*  	dl 0x0009AE ; 00003E, 13.614
040E58 D4 09 00    0693*  	dl 0x0009D4 ; 00003F, 13.825
040E5B FB 09 00    0694*  	dl 0x0009FB ; 000040, 14.036
040E5E 21 0A 00    0695*  	dl 0x000A21 ; 000041, 14.247
040E61 47 0A 00    0696*  	dl 0x000A47 ; 000042, 14.457
040E64 6D 0A 00    0697*  	dl 0x000A6D ; 000043, 14.666
040E67 94 0A 00    0698*  	dl 0x000A94 ; 000044, 14.876
040E6A BA 0A 00    0699*  	dl 0x000ABA ; 000045, 15.085
040E6D E0 0A 00    0700*  	dl 0x000AE0 ; 000046, 15.293
040E70 05 0B 00    0701*  	dl 0x000B05 ; 000047, 15.501
040E73 2B 0B 00    0702*  	dl 0x000B2B ; 000048, 15.709
040E76 51 0B 00    0703*  	dl 0x000B51 ; 000049, 15.916
040E79 77 0B 00    0704*  	dl 0x000B77 ; 00004A, 16.123
040E7C 9C 0B 00    0705*  	dl 0x000B9C ; 00004B, 16.329
040E7F C2 0B 00    0706*  	dl 0x000BC2 ; 00004C, 16.535
040E82 E7 0B 00    0707*  	dl 0x000BE7 ; 00004D, 16.740
040E85 0C 0C 00    0708*  	dl 0x000C0C ; 00004E, 16.945
040E88 32 0C 00    0709*  	dl 0x000C32 ; 00004F, 17.150
040E8B 57 0C 00    0710*  	dl 0x000C57 ; 000050, 17.354
040E8E 7C 0C 00    0711*  	dl 0x000C7C ; 000051, 17.558
040E91 A1 0C 00    0712*  	dl 0x000CA1 ; 000052, 17.761
040E94 C6 0C 00    0713*  	dl 0x000CC6 ; 000053, 17.964
040E97 EB 0C 00    0714*  	dl 0x000CEB ; 000054, 18.166
040E9A 0F 0D 00    0715*  	dl 0x000D0F ; 000055, 18.368
040E9D 34 0D 00    0716*  	dl 0x000D34 ; 000056, 18.569
040EA0 58 0D 00    0717*  	dl 0x000D58 ; 000057, 18.770
040EA3 7D 0D 00    0718*  	dl 0x000D7D ; 000058, 18.970
040EA6 A1 0D 00    0719*  	dl 0x000DA1 ; 000059, 19.170
040EA9 C6 0D 00    0720*  	dl 0x000DC6 ; 00005A, 19.370
040EAC EA 0D 00    0721*  	dl 0x000DEA ; 00005B, 19.569
040EAF 0E 0E 00    0722*  	dl 0x000E0E ; 00005C, 19.767
040EB2 32 0E 00    0723*  	dl 0x000E32 ; 00005D, 19.965
040EB5 56 0E 00    0724*  	dl 0x000E56 ; 00005E, 20.163
040EB8 7A 0E 00    0725*  	dl 0x000E7A ; 00005F, 20.360
040EBB 9E 0E 00    0726*  	dl 0x000E9E ; 000060, 20.556
040EBE C1 0E 00    0727*  	dl 0x000EC1 ; 000061, 20.752
040EC1 E5 0E 00    0728*  	dl 0x000EE5 ; 000062, 20.947
040EC4 08 0F 00    0729*  	dl 0x000F08 ; 000063, 21.142
040EC7 2C 0F 00    0730*  	dl 0x000F2C ; 000064, 21.337
040ECA 4F 0F 00    0731*  	dl 0x000F4F ; 000065, 21.531
040ECD 72 0F 00    0732*  	dl 0x000F72 ; 000066, 21.724
040ED0 95 0F 00    0733*  	dl 0x000F95 ; 000067, 21.917
040ED3 B8 0F 00    0734*  	dl 0x000FB8 ; 000068, 22.109
040ED6 DB 0F 00    0735*  	dl 0x000FDB ; 000069, 22.301
040ED9 FE 0F 00    0736*  	dl 0x000FFE ; 00006A, 22.493
040EDC 21 10 00    0737*  	dl 0x001021 ; 00006B, 22.683
040EDF 44 10 00    0738*  	dl 0x001044 ; 00006C, 22.874
040EE2 66 10 00    0739*  	dl 0x001066 ; 00006D, 23.063
040EE5 89 10 00    0740*  	dl 0x001089 ; 00006E, 23.253
040EE8 AB 10 00    0741*  	dl 0x0010AB ; 00006F, 23.441
040EEB CD 10 00    0742*  	dl 0x0010CD ; 000070, 23.629
040EEE EF 10 00    0743*  	dl 0x0010EF ; 000071, 23.817
040EF1 11 11 00    0744*  	dl 0x001111 ; 000072, 24.004
040EF4 33 11 00    0745*  	dl 0x001133 ; 000073, 24.191
040EF7 55 11 00    0746*  	dl 0x001155 ; 000074, 24.376
040EFA 77 11 00    0747*  	dl 0x001177 ; 000075, 24.562
040EFD 99 11 00    0748*  	dl 0x001199 ; 000076, 24.747
040F00 BA 11 00    0749*  	dl 0x0011BA ; 000077, 24.931
040F03 DC 11 00    0750*  	dl 0x0011DC ; 000078, 25.115
040F06 FD 11 00    0751*  	dl 0x0011FD ; 000079, 25.298
040F09 1E 12 00    0752*  	dl 0x00121E ; 00007A, 25.481
040F0C 3F 12 00    0753*  	dl 0x00123F ; 00007B, 25.663
040F0F 60 12 00    0754*  	dl 0x001260 ; 00007C, 25.844
040F12 81 12 00    0755*  	dl 0x001281 ; 00007D, 26.025
040F15 A2 12 00    0756*  	dl 0x0012A2 ; 00007E, 26.206
040F18 C3 12 00    0757*  	dl 0x0012C3 ; 00007F, 26.386
040F1B E4 12 00    0758*  	dl 0x0012E4 ; 000080, 26.565
040F1E 04 13 00    0759*  	dl 0x001304 ; 000081, 26.744
040F21 25 13 00    0760*  	dl 0x001325 ; 000082, 26.922
040F24 45 13 00    0761*  	dl 0x001345 ; 000083, 27.100
040F27 65 13 00    0762*  	dl 0x001365 ; 000084, 27.277
040F2A 85 13 00    0763*  	dl 0x001385 ; 000085, 27.453
040F2D A5 13 00    0764*  	dl 0x0013A5 ; 000086, 27.629
040F30 C5 13 00    0765*  	dl 0x0013C5 ; 000087, 27.805
040F33 E5 13 00    0766*  	dl 0x0013E5 ; 000088, 27.979
040F36 05 14 00    0767*  	dl 0x001405 ; 000089, 28.154
040F39 24 14 00    0768*  	dl 0x001424 ; 00008A, 28.327
040F3C 44 14 00    0769*  	dl 0x001444 ; 00008B, 28.501
040F3F 63 14 00    0770*  	dl 0x001463 ; 00008C, 28.673
040F42 83 14 00    0771*  	dl 0x001483 ; 00008D, 28.845
040F45 A2 14 00    0772*  	dl 0x0014A2 ; 00008E, 29.017
040F48 C1 14 00    0773*  	dl 0x0014C1 ; 00008F, 29.187
040F4B E0 14 00    0774*  	dl 0x0014E0 ; 000090, 29.358
040F4E FF 14 00    0775*  	dl 0x0014FF ; 000091, 29.527
040F51 1E 15 00    0776*  	dl 0x00151E ; 000092, 29.697
040F54 3C 15 00    0777*  	dl 0x00153C ; 000093, 29.865
040F57 5B 15 00    0778*  	dl 0x00155B ; 000094, 30.033
040F5A 79 15 00    0779*  	dl 0x001579 ; 000095, 30.201
040F5D 98 15 00    0780*  	dl 0x001598 ; 000096, 30.368
040F60 B6 15 00    0781*  	dl 0x0015B6 ; 000097, 30.534
040F63 D4 15 00    0782*  	dl 0x0015D4 ; 000098, 30.700
040F66 F2 15 00    0783*  	dl 0x0015F2 ; 000099, 30.865
040F69 10 16 00    0784*  	dl 0x001610 ; 00009A, 31.030
040F6C 2E 16 00    0785*  	dl 0x00162E ; 00009B, 31.194
040F6F 4C 16 00    0786*  	dl 0x00164C ; 00009C, 31.357
040F72 6A 16 00    0787*  	dl 0x00166A ; 00009D, 31.520
040F75 87 16 00    0788*  	dl 0x001687 ; 00009E, 31.682
040F78 A5 16 00    0789*  	dl 0x0016A5 ; 00009F, 31.844
040F7B C2 16 00    0790*  	dl 0x0016C2 ; 0000A0, 32.005
040F7E DF 16 00    0791*  	dl 0x0016DF ; 0000A1, 32.166
040F81 FC 16 00    0792*  	dl 0x0016FC ; 0000A2, 32.326
040F84 19 17 00    0793*  	dl 0x001719 ; 0000A3, 32.486
040F87 36 17 00    0794*  	dl 0x001736 ; 0000A4, 32.645
040F8A 53 17 00    0795*  	dl 0x001753 ; 0000A5, 32.803
040F8D 70 17 00    0796*  	dl 0x001770 ; 0000A6, 32.961
040F90 8C 17 00    0797*  	dl 0x00178C ; 0000A7, 33.118
040F93 A9 17 00    0798*  	dl 0x0017A9 ; 0000A8, 33.275
040F96 C5 17 00    0799*  	dl 0x0017C5 ; 0000A9, 33.431
040F99 E2 17 00    0800*  	dl 0x0017E2 ; 0000AA, 33.587
040F9C FE 17 00    0801*  	dl 0x0017FE ; 0000AB, 33.742
040F9F 1A 18 00    0802*  	dl 0x00181A ; 0000AC, 33.896
040FA2 36 18 00    0803*  	dl 0x001836 ; 0000AD, 34.050
040FA5 52 18 00    0804*  	dl 0x001852 ; 0000AE, 34.203
040FA8 6E 18 00    0805*  	dl 0x00186E ; 0000AF, 34.356
040FAB 8A 18 00    0806*  	dl 0x00188A ; 0000B0, 34.509
040FAE A5 18 00    0807*  	dl 0x0018A5 ; 0000B1, 34.660
040FB1 C1 18 00    0808*  	dl 0x0018C1 ; 0000B2, 34.811
040FB4 DC 18 00    0809*  	dl 0x0018DC ; 0000B3, 34.962
040FB7 F7 18 00    0810*  	dl 0x0018F7 ; 0000B4, 35.112
040FBA 13 19 00    0811*  	dl 0x001913 ; 0000B5, 35.262
040FBD 2E 19 00    0812*  	dl 0x00192E ; 0000B6, 35.410
040FC0 49 19 00    0813*  	dl 0x001949 ; 0000B7, 35.559
040FC3 64 19 00    0814*  	dl 0x001964 ; 0000B8, 35.707
040FC6 7F 19 00    0815*  	dl 0x00197F ; 0000B9, 35.854
040FC9 99 19 00    0816*  	dl 0x001999 ; 0000BA, 36.001
040FCC B4 19 00    0817*  	dl 0x0019B4 ; 0000BB, 36.147
040FCF CE 19 00    0818*  	dl 0x0019CE ; 0000BC, 36.293
040FD2 E9 19 00    0819*  	dl 0x0019E9 ; 0000BD, 36.438
040FD5 03 1A 00    0820*  	dl 0x001A03 ; 0000BE, 36.582
040FD8 1D 1A 00    0821*  	dl 0x001A1D ; 0000BF, 36.726
040FDB 37 1A 00    0822*  	dl 0x001A37 ; 0000C0, 36.870
040FDE 51 1A 00    0823*  	dl 0x001A51 ; 0000C1, 37.013
040FE1 6B 1A 00    0824*  	dl 0x001A6B ; 0000C2, 37.155
040FE4 85 1A 00    0825*  	dl 0x001A85 ; 0000C3, 37.297
040FE7 9F 1A 00    0826*  	dl 0x001A9F ; 0000C4, 37.439
040FEA B9 1A 00    0827*  	dl 0x001AB9 ; 0000C5, 37.579
040FED D2 1A 00    0828*  	dl 0x001AD2 ; 0000C6, 37.720
040FF0 EC 1A 00    0829*  	dl 0x001AEC ; 0000C7, 37.859
040FF3 05 1B 00    0830*  	dl 0x001B05 ; 0000C8, 37.999
040FF6 1E 1B 00    0831*  	dl 0x001B1E ; 0000C9, 38.137
040FF9 37 1B 00    0832*  	dl 0x001B37 ; 0000CA, 38.276
040FFC 50 1B 00    0833*  	dl 0x001B50 ; 0000CB, 38.413
040FFF 69 1B 00    0834*  	dl 0x001B69 ; 0000CC, 38.550
041002 82 1B 00    0835*  	dl 0x001B82 ; 0000CD, 38.687
041005 9B 1B 00    0836*  	dl 0x001B9B ; 0000CE, 38.823
041008 B4 1B 00    0837*  	dl 0x001BB4 ; 0000CF, 38.959
04100B CC 1B 00    0838*  	dl 0x001BCC ; 0000D0, 39.094
04100E E5 1B 00    0839*  	dl 0x001BE5 ; 0000D1, 39.228
041011 FD 1B 00    0840*  	dl 0x001BFD ; 0000D2, 39.362
041014 16 1C 00    0841*  	dl 0x001C16 ; 0000D3, 39.496
041017 2E 1C 00    0842*  	dl 0x001C2E ; 0000D4, 39.629
04101A 46 1C 00    0843*  	dl 0x001C46 ; 0000D5, 39.762
04101D 5E 1C 00    0844*  	dl 0x001C5E ; 0000D6, 39.894
041020 76 1C 00    0845*  	dl 0x001C76 ; 0000D7, 40.025
041023 8E 1C 00    0846*  	dl 0x001C8E ; 0000D8, 40.156
041026 A5 1C 00    0847*  	dl 0x001CA5 ; 0000D9, 40.286
041029 BD 1C 00    0848*  	dl 0x001CBD ; 0000DA, 40.416
04102C D5 1C 00    0849*  	dl 0x001CD5 ; 0000DB, 40.546
04102F EC 1C 00    0850*  	dl 0x001CEC ; 0000DC, 40.675
041032 04 1D 00    0851*  	dl 0x001D04 ; 0000DD, 40.803
041035 1B 1D 00    0852*  	dl 0x001D1B ; 0000DE, 40.931
041038 32 1D 00    0853*  	dl 0x001D32 ; 0000DF, 41.059
04103B 49 1D 00    0854*  	dl 0x001D49 ; 0000E0, 41.186
04103E 60 1D 00    0855*  	dl 0x001D60 ; 0000E1, 41.312
041041 77 1D 00    0856*  	dl 0x001D77 ; 0000E2, 41.438
041044 8E 1D 00    0857*  	dl 0x001D8E ; 0000E3, 41.564
041047 A5 1D 00    0858*  	dl 0x001DA5 ; 0000E4, 41.689
04104A BB 1D 00    0859*  	dl 0x001DBB ; 0000E5, 41.814
04104D D2 1D 00    0860*  	dl 0x001DD2 ; 0000E6, 41.938
041050 E9 1D 00    0861*  	dl 0x001DE9 ; 0000E7, 42.061
041053 FF 1D 00    0862*  	dl 0x001DFF ; 0000E8, 42.184
041056 15 1E 00    0863*  	dl 0x001E15 ; 0000E9, 42.307
041059 2C 1E 00    0864*  	dl 0x001E2C ; 0000EA, 42.429
04105C 42 1E 00    0865*  	dl 0x001E42 ; 0000EB, 42.551
04105F 58 1E 00    0866*  	dl 0x001E58 ; 0000EC, 42.672
041062 6E 1E 00    0867*  	dl 0x001E6E ; 0000ED, 42.793
041065 84 1E 00    0868*  	dl 0x001E84 ; 0000EE, 42.913
041068 99 1E 00    0869*  	dl 0x001E99 ; 0000EF, 43.033
04106B AF 1E 00    0870*  	dl 0x001EAF ; 0000F0, 43.152
04106E C5 1E 00    0871*  	dl 0x001EC5 ; 0000F1, 43.271
041071 DA 1E 00    0872*  	dl 0x001EDA ; 0000F2, 43.390
041074 F0 1E 00    0873*  	dl 0x001EF0 ; 0000F3, 43.508
041077 05 1F 00    0874*  	dl 0x001F05 ; 0000F4, 43.625
04107A 1B 1F 00    0875*  	dl 0x001F1B ; 0000F5, 43.742
04107D 30 1F 00    0876*  	dl 0x001F30 ; 0000F6, 43.859
041080 45 1F 00    0877*  	dl 0x001F45 ; 0000F7, 43.975
041083 5A 1F 00    0878*  	dl 0x001F5A ; 0000F8, 44.091
041086 6F 1F 00    0879*  	dl 0x001F6F ; 0000F9, 44.206
041089 84 1F 00    0880*  	dl 0x001F84 ; 0000FA, 44.321
04108C 99 1F 00    0881*  	dl 0x001F99 ; 0000FB, 44.435
04108F AD 1F 00    0882*  	dl 0x001FAD ; 0000FC, 44.549
041092 C2 1F 00    0883*  	dl 0x001FC2 ; 0000FD, 44.662
041095 D7 1F 00    0884*  	dl 0x001FD7 ; 0000FE, 44.775
041098 EB 1F 00    0885*  	dl 0x001FEB ; 0000FF, 44.888
04109B 00 20 00    0886*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
04109E             0037       include "files.inc"
04109E             0001*  ; load to onboard 8k sram
04109E             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
04109E             0038       include "timer.inc"
04109E             0001*  ; Table 32. Timer Control Registers
04109E             0002*  ; this constant is the base address of the timer control registers
04109E             0003*  ; each timer takes three bytes:
04109E             0004*  ;   0: control register
04109E             0005*  ;   1: low byte of timer reset value
04109E             0006*  ;   2: high byte of timer reset value
04109E             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
04109E             0008*  ; which correctly force the high and upper bytes of the address bus to zero
04109E             0009*  TMR_CTL:     equ 80h
04109E             0010*  
04109E             0011*  ; Timer Control Register Bit Definitions
04109E             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
04109E             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
04109E             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
04109E             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
04109E             0016*                              ; the TMRx_CTL register is read.
04109E             0017*  
04109E             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
04109E             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
04109E             0020*  
04109E             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
04109E             0022*                              ;  0,and counting stops when the end-of-count value is reached.
04109E             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
04109E             0024*                              ; written to the counter when the end-of-count value is reached.
04109E             0025*  
04109E             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
04109E             0027*  CLK_DIV_256:  equ %00001100 ;
04109E             0028*  CLK_DIV_64:   equ %00001000 ;
04109E             0029*  CLK_DIV_16:   equ %00000100 ;
04109E             0030*  CLK_DIV_4:    equ %00000000 ;
04109E             0031*  
04109E             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
04109E             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
04109E             0034*                              ; When a 1 is written to this bit,the values in the reload registers
04109E             0035*                              ;  are loaded into the downcounter when the timer restarts. The
04109E             0036*                              ; programmer must ensure that this bit is set to 1 each time
04109E             0037*                              ; SINGLE-PASS mode is used.
04109E             0038*  
04109E             0039*  ; disable/enable the programmable reload timer
04109E             0040*  PRT_EN_0:     equ %00000000 ;
04109E             0041*  PRT_EN_1:     equ %00000001 ;
04109E             0042*  
04109E             0043*  ; Table 37. Timer Input Source Select Register
04109E             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
04109E             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
04109E             0046*  ;   00: System clock / CLK_DIV
04109E             0047*  ;   01: RTC / CLK_DIV
04109E             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
04109E             0049*  ;   10: GPIO port B pin 1.
04109E             0050*  ;   11: GPIO port B pin 1.
04109E             0051*  TMR_ISS:   equ 92h ; register address
04109E             0052*  
04109E             0053*  ; Table 51. Real-Time Clock Control Register
04109E             0054*  RTC_CTRL: equ EDh ; register address
04109E             0055*  
04109E             0056*  ; alarm interrupt disable/enable
04109E             0057*  RTC_ALARM_0:    equ %00000000
04109E             0058*  RTC_ALARM_1:    equ %10000000
04109E             0059*  
04109E             0060*  ; interrupt on alarm disable/enable
04109E             0061*  RTC_INT_ENT_0:  equ %00000000
04109E             0062*  RTC_INT_ENT_1:  equ %01000000
04109E             0063*  
04109E             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
04109E             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
04109E             0066*  
04109E             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
04109E             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
04109E             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
04109E             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
04109E             0071*  
04109E             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
04109E             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
04109E             0074*  
04109E             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
04109E             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
04109E             0077*  
04109E             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
04109E             0079*                                  ; RTC counter is enabled.
04109E             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
04109E             0081*                                  ; RTC counter is disabled.
04109E             0082*  
04109E             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
04109E             0084*  
04109E             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
04109E             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
04109E 00 00 00    0087*  prt_reload: dl 0x000000
0410A1             0088*  
0410A1             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0410A1             0090*  ; ;          de = number PRT interrupts during test interval
0410A1             0091*  ; prt_calibrate:
0410A1             0092*  ;     call vdu_vblank
0410A1             0093*  ; ; set a MOS timer
0410A1             0094*  ;     ld hl,120*1 ; 1 second
0410A1             0095*  ;     ld iy,tmr_test
0410A1             0096*  ;     call tmr_set
0410A1             0097*  ; ; set a PRT timer
0410A1             0098*  ;     ; ld hl,prt_reload_hardware
0410A1             0099*  ;     ; ld hl,prt_reload_emulator
0410A1             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0410A1             0101*  ;     ld (prt_reload),hl
0410A1             0102*  ;     call prt_set
0410A1             0103*  ; @loop:
0410A1             0104*  ; ; check time remaining on MOS timer
0410A1             0105*  ;     call tmr_get
0410A1             0106*  ;     jp z,@done ; time expired,so quit
0410A1             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0410A1             0108*  ;     jr @loop
0410A1             0109*  ; @done:
0410A1             0110*  ;     ld de,(prt_irq_counter)
0410A1             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0410A1             0112*  ;     ld (prt_reload),bc
0410A1             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0410A1             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0410A1             0115*  ;     ld (is_emulator),a
0410A1             0116*  ;     sbc hl,de
0410A1             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0410A1             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0410A1             0119*  ;     ret m ; negative result means we're on hardware
0410A1             0120*  ;     inc a ; we're on emulator
0410A1             0121*  ;     ld (is_emulator),a
0410A1             0122*  ;     ld bc,prt_reload_emulator
0410A1             0123*  ;     ld (prt_reload),bc
0410A1             0124*  ;     ld hl,on_emulator
0410A1             0125*  ;     ret
0410A1             0126*  
0410A1             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0410A1             0128*  
0410A1             0129*  ; set PRT timer
0410A1             0130*  prt_set:
0410A1 21 00 00 00 0131*      ld hl,0
0410A5 22 EF 10 04 0132*      ld (prt_irq_counter),hl
0410A9 2A 9E 10 04 0133*      ld hl,(prt_reload)
0410AD ED 29 84    0134*      out0 ($84),l
0410B0 ED 21 85    0135*  	out0 ($85),h
0410B3             0136*  ; disable timer
0410B3 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0410B5 ED 39 83    0138*  	out0 ($83),a
0410B8             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0410B8 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0410BA ED 39 83    0141*  	out0 ($83),a
0410BD C9          0142*      ret
0410BE             0143*  
0410BE             0144*  ; ===============================================
0410BE             0145*  ; PRT Timer Interrupt Handling
0410BE             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0410BE             0147*  ; -----------------------------------------------
0410BE             0148*  prt_irq_init:
0410BE             0149*      ; set up interrupt vector table 2
0410BE 21 00 00 00 0150*  	ld hl,0
0410C2 3A 0C 01 00 0151*  	ld a,($10c)
0410C6 6F          0152*  	ld l,a
0410C7 3A 0D 01 00 0153*  	ld a,($10d)
0410CB 67          0154*  	ld h,a
0410CC             0155*  
0410CC             0156*  	; skip over CALL ($c3)
0410CC 23          0157*  	inc hl
0410CD             0158*  	; load address of jump into vector table 2 (in ram)
0410CD ED 27       0159*  	ld hl,(hl)
0410CF             0160*  
0410CF             0161*  	; write CALL prt_irq_handler to vector table 2
0410CF 3E C3       0162*  	ld a,$c3
0410D1 77          0163*  	ld (hl),a
0410D2 23          0164*  	inc hl
0410D3 11 DA 10 04 0165*  	ld de,prt_irq_handler
0410D7 ED 1F       0166*  	ld (hl),de
0410D9             0167*  
0410D9 C9          0168*      ret
0410DA             0169*  
0410DA             0170*  prt_irq_handler:
0410DA F3          0171*  	di
0410DB F5          0172*  	push af
0410DC E5          0173*      push hl
0410DD ED 38 83    0174*  	in0 a,($83)
0410E0 2A EF 10 04 0175*  	ld hl,(prt_irq_counter)
0410E4 23          0176*  	inc hl
0410E5 22 EF 10 04 0177*  	ld (prt_irq_counter),hl
0410E9 E1          0178*      pop hl
0410EA F1          0179*  	pop af
0410EB FB          0180*  	ei
0410EC 5B ED 4D    0181*  	reti.l
0410EF             0182*  
0410EF             0183*  prt_irq_counter:
0410EF 00 00 00    0184*  	.dl 0
0410F2             0185*  prt_irq_counter_saved:
0410F2 00 00 00    0186*      .dl 0
0410F5             0187*  
0410F5             0188*  prt_loop_reset:
0410F5 E5          0189*      push hl
0410F6 21 00 00 00 0190*  	ld hl,0
0410FA 22 EF 10 04 0191*  	ld (prt_irq_counter),hl
0410FE 22 60 11 04 0192*      ld (prt_loop_counter),hl
041102 22 63 11 04 0193*      ld (prt_loops),hl
041106 CD A1 10 04 0194*      call prt_set
04110A E1          0195*      pop hl
04110B C9          0196*      ret
04110C             0197*  
04110C             0198*  prt_loop_start:
04110C E5          0199*      push hl
04110D 21 00 00 00 0200*  	ld hl,0
041111 22 EF 10 04 0201*  	ld (prt_irq_counter),hl
041115 E1          0202*      pop hl
041116 C9          0203*      ret
041117             0204*  
041117             0205*  prt_loop_stop:
041117 E5          0206*      push hl
041118 D5          0207*      push de
041119 2A EF 10 04 0208*      ld hl,(prt_irq_counter)
04111D ED 5B 60 11 0209*      ld de,(prt_loop_counter)
       04          
041122 19          0210*      add hl,de
041123 22 60 11 04 0211*      ld (prt_loop_counter),hl
041127 21 00 00 00 0212*      ld hl,0
04112B 22 EF 10 04 0213*      ld (prt_irq_counter),hl
04112F 2A 63 11 04 0214*      ld hl,(prt_loops)
041133 23          0215*      inc hl
041134 22 63 11 04 0216*      ld (prt_loops),hl
041138 D1          0217*      pop de
041139 E1          0218*      pop hl
04113A C9          0219*      ret
04113B             0220*  
04113B             0221*  ; inputs: bc = y,x text coordinates to print
04113B             0222*  prt_loop_print:
04113B F5          0223*      push af
04113C E5          0224*      push hl
04113D C5          0225*      push bc
04113E D5          0226*      push de
04113F DD E5       0227*      push ix
041141 FD E5       0228*      push iy
041143 CD 58 12 04 0229*      call vdu_move_cursor
041147             0230*  
041147 2A 60 11 04 0231*      ld hl,(prt_loop_counter)
04114B CD 24 01 04 0232*      call printDec
04114F             0233*  
04114F 2A 63 11 04 0234*      ld hl,(prt_loops)
041153 CD 24 01 04 0235*      call printDec
041157             0236*  
041157 FD E1       0237*      pop iy
041159 DD E1       0238*      pop ix
04115B D1          0239*      pop de
04115C C1          0240*      pop bc
04115D E1          0241*      pop hl
04115E F1          0242*      pop af
04115F C9          0243*      ret
041160             0244*  
041160             0245*  prt_loop_counter:
041160 00 00 00    0246*      .dl 0
041163             0247*  prt_loops:
041163 00 00 00    0248*      .dl 0
041166             0249*  
041166             0250*  ; ===============================================
041166             0251*  ; Timer functions
041166             0252*  ; -----------------------------------------------
041166             0253*  ; set a countdown timer
041166             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041166             0255*  ; returns: hl = current time
041166             0256*  tmr_set:
041166 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
041169             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
041169 3E 08       0001*M 			LD	A, function
04116B 5B CF       0002*M 			RST.L	08h
04116D DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
041170 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
041173 C9          0261*      ret
041174             0262*  
041174             0263*  ; gets time remaining on a countdown timer
041174             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
041174             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
041174             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
041174             0267*  tmr_get:
041174             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
041174 3E 08       0001*M 			LD	A, function
041176 5B CF       0002*M 			RST.L	08h
041178 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
04117B FD 27 00    0270*      ld hl,(iy+0)            ; get start time
04117E AF          0271*      xor a                   ; clear carry
04117F ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
041181 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
041184 AF          0274*      xor a                   ; clear carry
041185 ED 5A       0275*      adc hl,de               ; hl = time remaining
041187             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
041187 C9          0277*      ret
041188             0278*  
041188 00 00 00    0279*  timestamp_now: dl 0
04118B 00 00 00    0280*  timestamp_old: dl 0
04118E 00 00 00    0281*  timestamp_chg: dl 0
041191             0282*  
041191             0283*  ; update the global timestamp from the system clock
041191             0284*  ; inputs: none
041191             0285*  ; returns: hl = time elapsed in 1/120ths of a second
041191             0286*  ;          de = current time
041191             0287*  ;          ix = pointer to syvars table
041191             0288*  ; destroys: af,hl,de,ix
041191             0289*  timestamp_tick:
041191 ED 5B 88 11 0290*      ld de,(timestamp_now)   ; get previous time
       04          
041196 ED 53 8B 11 0291*      ld (timestamp_old),de   ; save previous time
       04          
04119B             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
04119B 3E 08       0001*M 			LD	A, function
04119D 5B CF       0002*M 			RST.L	08h
04119F DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0411A2 22 88 11 04 0294*      ld (timestamp_now),hl   ; save current time
0411A6 AF          0295*      xor a                   ; clear carry
0411A7 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0411A9 22 8E 11 04 0297*      ld (timestamp_chg),hl   ; save elapsed time
0411AD C9          0298*      ret
0411AE             0299*  
0411AE             0300*  ; set a countdown timer
0411AE             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411AE             0302*  ; requires: timestamp_tick to be called at least once before this function
0411AE             0303*  ; returns: hl = current time
0411AE             0304*  ; destroys: hl
0411AE             0305*  timestamp_tmr_set:
0411AE FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0411B1 2A 88 11 04 0307*      ld hl,(timestamp_now)   ; get current timestamp
0411B5 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0411B8 C9          0309*      ret
0411B9             0310*  
0411B9             0311*  ; gets time remaining on a countdown timer following the global timestamp
0411B9             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0411B9             0313*  ; requires: timestamp_tick to be called at least once before this function
0411B9             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0411B9             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0411B9             0316*  ; destroys: af,hl,de
0411B9             0317*  timestamp_tmr_get:
0411B9 ED 5B 88 11 0318*      ld de,(timestamp_now)   ; get current timestamp
       04          
0411BE FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0411C1 AF          0320*      xor a                   ; clear carry
0411C2 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0411C4 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0411C7 AF          0323*      xor a                   ; clear carry
0411C8 ED 5A       0324*      adc hl,de               ; hl = time remaining
0411CA             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0411CA C9          0326*      ret
0411CB             0327*  
0411CB             0328*  ; main loop timer functions
0411CB             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0411D1             0330*  
0411D1             0331*  ; set a countdown timer for the main loop using the timestamp timer
0411D1             0332*  ; inputs: hl = time to set in 1/120ths of a second
0411D1             0333*  ; returns: hl = current time
0411D1             0334*  ; destroys: af,hl,de,ix,iy
0411D1             0335*  tmr_main_loop_set:
0411D1 FD 21 CB 11 0336*      ld iy,tmr_main_loop
       04          
0411D6 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0411D9 CD 91 11 04 0338*      call timestamp_tick
0411DD 2A 88 11 04 0339*      ld hl,(timestamp_now)   ; get current timestamp
0411E1 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0411E4 C9          0341*      ret
0411E5             0342*  
0411E5             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0411E5             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0411E5             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0411E5             0346*  ; destroys: af,hl,de,ix,iy
0411E5             0347*  tmr_main_loop_get:
0411E5 CD 91 11 04 0348*      call timestamp_tick
0411E9 FD 21 CB 11 0349*      ld iy,tmr_main_loop
       04          
0411EE CD B9 11 04 0350*      call timestamp_tmr_get
0411F2 C9          0351*      ret
0411F3             0352*  
0411F3             0353*  ; set a stopwatch
0411F3             0354*  ; returns: hl = start time
0411F3             0355*  ; destroys: hl,ix
0411F3             0356*  stopwatch_set:
0411F3             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0411F3 3E 08       0001*M 			LD	A, function
0411F5 5B CF       0002*M 			RST.L	08h
0411F7 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0411FA 22 0F 12 04 0359*      ld (stopwatch_started),hl            ; set start time
0411FE C9          0360*      ret
0411FF             0361*  
0411FF             0362*  ; gets time elapsed on a stopwatch
0411FF             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0411FF             0364*  ; destroys: af,hl,de,ix
0411FF             0365*  stopwatch_get:
0411FF             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0411FF 3E 08       0001*M 			LD	A, function
041201 5B CF       0002*M 			RST.L	08h
041203 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
041206 ED 5B 0F 12 0368*      ld de,(stopwatch_started)            ; get start time
       04          
04120B AF          0369*      xor a                   ; clear carry
04120C ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
04120E C9          0371*      ret
04120F             0372*  
04120F             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
041212             0374*  
041212             0375*  ; ------------------
041212             0376*  ; delay routine
041212             0377*  ; Author: Richard Turrnidge
041212             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
041212             0379*  ; routine waits a fixed time,then returns
041212             0380*  ; arrive with A =  the delay byte. One bit to be set only.
041212             0381*  ; eg. ld A,00000100b
041212             0382*  
041212             0383*  multiPurposeDelay:
041212 F5          0384*      push af
041213 C5          0385*      push bc
041214 DD E5       0386*      push ix
041216 47          0387*      ld b,a
041217 3E 08       0388*      ld a,$08
041219 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
04121B             0390*  
04121B             0391*  waitLoop:
04121B             0392*  
04121B DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
04121E             0394*  
04121E             0395*                                  ;   we check if bit set is same as last time we checked.
04121E             0396*                                  ;   bit 0 - don't use
04121E             0397*                                  ;   bit 1 - changes 64 times per second
04121E             0398*                                  ;   bit 2 - changes 32 times per second
04121E             0399*                                  ;   bit 3 - changes 16 times per second
04121E             0400*  
04121E             0401*                                  ;   bit 4 - changes 8 times per second
04121E             0402*                                  ;   bit 5 - changes 4 times per second
04121E             0403*                                  ;   bit 6 - changes 2 times per second
04121E             0404*                                  ;   bit 7 - changes 1 times per second
04121E A0          0405*      and b
04121F 4F          0406*      ld c,a
041220 3A 31 12 04 0407*      ld a,(oldTimeStamp)
041224 B9          0408*      cp c                        ; is A same as last value?
041225 28 F4       0409*      jr z,waitLoop              ; loop here if it is
041227 79          0410*      ld a,c
041228 32 31 12 04 0411*      ld (oldTimeStamp),a        ; set new value
04122C             0412*  
04122C DD E1       0413*      pop ix
04122E C1          0414*      pop bc
04122F F1          0415*      pop af
041230 C9          0416*      ret
041231             0417*  
041231 00          0418*  oldTimeStamp:   .db 00h
041232             0039       include "vdu.inc"
041232             0001*  
041232             0002*  ; VDU 30: Home cursor
041232             0003*  vdu_home_cursor:
041232 3E 1E       0004*      ld a,30
041234 5B D7       0005*  	rst.lil $10
041236 C9          0006*  	ret
041237             0007*  
041237             0008*  cursor_on:
041237 21 42 12 04 0009*  	ld hl,@cmd
04123B 01 03 00 00 0010*  	ld bc,@end-@cmd
04123F 5B DF       0011*  	rst.lil $18
041241 C9          0012*  	ret
041242             0013*  @cmd:
041242 17 01 01    0014*  	db 23,1,1
041245             0015*  @end:
041245             0016*  
041245             0017*  cursor_off:
041245 21 50 12 04 0018*  	ld hl,@cmd
041249 01 03 00 00 0019*  	ld bc,@end-@cmd
04124D 5B DF       0020*  	rst.lil $18
04124F C9          0021*  	ret
041250             0022*  @cmd:
041250 17 01 00    0023*  	db 23,1,0
041253             0024*  @end:
041253             0025*  
041253             0026*  ; VDU 9: Move cursor forward one character
041253             0027*  vdu_cursor_forward:
041253 3E 09       0028*      ld a,9
041255 5B D7       0029*  	rst.lil $10
041257 C9          0030*  	ret
041258             0031*  
041258             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
041258             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
041258             0034*  vdu_move_cursor:
041258 ED 43 69 12 0035*      ld (@x0),bc
       04          
04125D 21 68 12 04 0036*  	ld hl,@cmd
041261 01 03 00 00 0037*  	ld bc,@end-@cmd
041265 5B DF       0038*  	rst.lil $18
041267 C9          0039*  	ret
041268 1F          0040*  @cmd: 	db 31
041269 00          0041*  @x0:	db 0
04126A 00          0042*  @y0: 	db 0
04126B 00          0043*  @end: 	db 0 ; padding
04126C             0044*  
04126C             0045*  ; VDU 12: Clear text area (CLS)
04126C             0046*  vdu_cls:
04126C 3E 0C       0047*      ld a,12
04126E 5B D7       0048*  	rst.lil $10
041270 C9          0049*  	ret
041271             0050*  
041271             0051*  vdu_flip:
041271 21 7C 12 04 0052*  	ld hl,@cmd
041275 01 03 00 00 0053*  	ld bc,@end-@cmd
041279 5B DF       0054*  	rst.lil $18
04127B C9          0055*  	ret
04127C 17 00 C3    0056*  @cmd: db 23,0,0xC3
04127F             0057*  @end:
04127F             0058*  
04127F             0059*  ; VDU 16: Clear graphics area (CLG)
04127F             0060*  vdu_clg:
04127F 3E 10       0061*      ld a,16
041281 5B D7       0062*  	rst.lil $10
041283 C9          0063*  	ret
041284             0064*  
041284             0065*  ; COLOUR MODES
041284             0066*  ; Mode	Effect
041284             0067*  ; 0	Set on-screen pixel to target colour value
041284             0068*  ; 1	OR value with the on-screen pixel
041284             0069*  ; 2	AND value with the on-screen pixel
041284             0070*  ; 3	XOR value with the on-screen pixel
041284             0071*  ; 4	Invert the on-screen pixel
041284             0072*  ; 5	No operation
041284             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041284             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041284             0075*  
041284             0076*  ; VDU 17, colour: Define text colour (COLOUR)
041284             0077*  vdu_colour_text:
041284 32 94 12 04 0078*  	ld (@arg),a
041288 21 93 12 04 0079*  	ld hl,@cmd
04128C 01 02 00 00 0080*  	ld bc,@end-@cmd
041290 5B DF       0081*  	rst.lil $18
041292 C9          0082*  	ret
041293 11          0083*  @cmd: db 17
041294 00          0084*  @arg: db 0
041295             0085*  @end:
041295             0086*  
041295             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041295             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041295             0089*  vdu_gcol:
041295 32 AA 12 04 0090*  	ld (@mode),a
041299 79          0091*      ld a,c
04129A 32 AB 12 04 0092*      ld (@col),a
04129E 21 A9 12 04 0093*  	ld hl,@cmd
0412A2 01 03 00 00 0094*  	ld bc,@end-@cmd
0412A6 5B DF       0095*  	rst.lil $18
0412A8 C9          0096*  	ret
0412A9 12          0097*  @cmd:  db 18
0412AA 00          0098*  @mode: db 0
0412AB 00          0099*  @col:  db 0
0412AC             0100*  @end:
0412AC             0101*  
0412AC             0102*  
0412AC             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0412AC             0104*  ; MIND THE LITTLE-ENDIANESS
0412AC             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0412AC             0106*  ; outputs; nothing
0412AC             0107*  ; destroys: a might make it out alive
0412AC             0108*  vdu_set_txt_viewport:
0412AC ED 43 C2 12 0109*      ld (@lb),bc
       04          
0412B1 ED 53 C4 12 0110*  	ld (@rt),de
       04          
0412B6 21 C1 12 04 0111*  	ld hl,@cmd
0412BA 01 05 00 00 0112*  	ld bc,@end-@cmd
0412BE 5B DF       0113*  	rst.lil $18
0412C0 C9          0114*  	ret
0412C1 1C          0115*  @cmd:   db 28 ; set text viewport command
0412C2 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0412C4 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0412C6 00          0118*  @end:   db 0x00	  ; padding
0412C7             0119*  
0412C7             0120*  ; Wait for VBLANK interrupt
0412C7             0121*  vdu_vblank:
0412C7 DD E5       0122*      PUSH 	IX
0412C9             0123*  	MOSCALL	mos_sysvars
0412C9 3E 08       0001*M 			LD	A, function
0412CB 5B CF       0002*M 			RST.L	08h
0412CD DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0412D0             0125*  @wait:
0412D0 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0412D3 28 FB       0127*      JR	Z, @wait
0412D5 DD E1       0128*      POP	IX
0412D7 C9          0129*      RET
0412D8             0130*  
0412D8             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0412D8             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0412D8             0133*  ; 	because we have turned off logical screen scaling
0412D8             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0412D8             0135*  ; outputs; nothing
0412D8             0136*  ; destroys: a might make it out alive
0412D8             0137*  vdu_set_gfx_viewport:
0412D8 ED 43 F8 12 0138*      ld (@x0),bc
       04          
0412DD FD 22 FA 12 0139*      ld (@y1),iy
       04          
0412E2 DD 22 FC 12 0140*  	ld (@x1),ix
       04          
0412E7 ED 53 FE 12 0141*  	ld (@y0),de
       04          
0412EC 21 F7 12 04 0142*  	ld hl,@cmd
0412F0 01 09 00 00 0143*  	ld bc,@end-@cmd
0412F4 5B DF       0144*  	rst.lil $18
0412F6 C9          0145*  	ret
0412F7 18          0146*  @cmd:   db 24 ; set graphics viewport command
0412F8 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0412FA 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0412FC 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0412FE 00 00       0150*  @y0: 	dw 0x0000 ; set by de
041300 00          0151*  @end:   db 0x00	  ; padding
041301             0152*  
041301             0153*  ; SCREEN MODES
041301             0154*  ; ===============================
041301             0155*  ; Mode  Horz  Vert  Cols  Refresh
041301             0156*  ; ---   ----  ----  ----  -------
041301             0157*  ; 11    320   240   2     60hz
041301             0158*  ; 139   320   240   2     60hz
041301             0159*  ; 23    512   384   2     60hz
041301             0160*  ; 151   512   384   2     60hz
041301             0161*  ; 6     640   240   2     60hz
041301             0162*  ; 134   640   240   2     60hz
041301             0163*  ; 2     640   480   2     60hz
041301             0164*  ; 130   640   480   2     60hz
041301             0165*  ; 17    800   600   2     60hz
041301             0166*  ; 145   800   600   2     60hz
041301             0167*  ; 18    1024  768   2     60hz
041301             0168*  ; 146   1024  768   2     60hz
041301             0169*  ; ---   ----  ----  ----  -------
041301             0170*  ; 10    320   240   4     60hz
041301             0171*  ; 138   320   240   4     60hz
041301             0172*  ; 22    512   384   4     60hz
041301             0173*  ; 150   512   384   4     60hz
041301             0174*  ; 5     640   240   4     60hz
041301             0175*  ; 133   640   240   4     60hz
041301             0176*  ; 1     640   480   4     60hz
041301             0177*  ; 129   640   480   4     60hz
041301             0178*  ; 16    800   600   4     60hz
041301             0179*  ; 19    1024  768   4     60hz
041301             0180*  ; ---   ----  ----  ----  -------
041301             0181*  ; 9     320   240   16    60hz
041301             0182*  ; 137   320   240   16    60hz
041301             0183*  ; 21    512   384   16    60hz
041301             0184*  ; 149   512   384   16    60hz
041301             0185*  ; 4     640   240   16    60hz
041301             0186*  ; 132   640   240   16    60hz
041301             0187*  ; 0     640   480   16    60hz
041301             0188*  ; 7     n/a   n/a   16    60hz
041301             0189*  ; ---   ----  ----  ----  -------
041301             0190*  ; 8     320   240   64    60hz
041301             0191*  ; 136   320   240   64    60hz
041301             0192*  ; 20    512   384   64    60hz
041301             0193*  ; 3     640   240   64    60hz
041301             0194*  ; ---   ----  ----  ----  -------
041301             0195*  vdu_set_screen_mode:
041301 32 11 13 04 0196*  	ld (@arg),a
041305 21 10 13 04 0197*  	ld hl,@cmd
041309 01 02 00 00 0198*  	ld bc,@end-@cmd
04130D 5B DF       0199*  	rst.lil $18
04130F C9          0200*  	ret
041310 16          0201*  @cmd: db 22 ; set screen mode
041311 00          0202*  @arg: db 0  ; screen mode parameter
041312             0203*  @end:
041312             0204*  
041312             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041312             0206*  ; inputs: a is scaling mode, 1=on, 0=off
041312             0207*  ; note: default setting on boot is scaling ON
041312             0208*  vdu_set_scaling:
041312 32 24 13 04 0209*  	ld (@arg),a
041316 21 21 13 04 0210*  	ld hl,@cmd
04131A 01 04 00 00 0211*  	ld bc,@end-@cmd
04131E 5B DF       0212*  	rst.lil $18
041320 C9          0213*  	ret
041321 17 00 C0    0214*  @cmd: db 23,0,0xC0
041324 00          0215*  @arg: db 0  ; scaling on/off
041325             0216*  @end:
041325             0217*  
041325             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041325             0219*  ; inputs: hl=bufferId
041325             0220*  vdu_buff_select:
041325 22 37 13 04 0221*  	ld (@bufferId),hl
041329 21 34 13 04 0222*  	ld hl,@cmd
04132D 01 05 00 00 0223*  	ld bc,@end-@cmd
041331 5B DF       0224*  	rst.lil $18
041333 C9          0225*  	ret
041334 17 1B 20    0226*  @cmd: db 23,27,0x20
041337 00 00       0227*  @bufferId: dw 0x0000
041339 00          0228*  @end: db 0x00 ; padding
04133A             0229*  
04133A             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
04133A             0231*  ; inputs: a=format; bc=width; de=height
04133A             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
04133A             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
04133A             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
04133A             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
04133A             0236*  ; 2 	Mono/Mask (1-bit per pixel)
04133A             0237*  ; 3 	Reserved for internal use by VDP (â€œnativeâ€ format)
04133A             0238*  vdu_bmp_create:
04133A ED 43 56 13 0239*      ld (@width),bc
       04          
04133F ED 53 58 13 0240*      ld (@height),de
       04          
041344 32 5A 13 04 0241*      ld (@fmt),a
041348 21 53 13 04 0242*  	ld hl,@cmd
04134C 01 08 00 00 0243*  	ld bc,@end-@cmd
041350 5B DF       0244*  	rst.lil $18
041352 C9          0245*  	ret
041353 17 1B 21    0246*  @cmd:       db 23,27,0x21
041356 00 00       0247*  @width:     dw 0x0000
041358 00 00       0248*  @height:    dw 0x0000
04135A 00          0249*  @fmt:       db 0x00
04135B             0250*  @end:
04135B             0251*  
04135B             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04135B             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04135B             0254*  vdu_load_img_rgba2_to_8:
04135B             0255*  ; backup the target buffer id and image dimensions
04135B E5          0256*      push hl
04135C D5          0257*      push de
04135D C5          0258*      push bc
04135E             0259*  ; load the rgba2 image to working buffer 65534
04135E 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
041362 CD 65 14 04 0261*  	call vdu_load_buffer_from_file
041366             0262*  ; restore the image dimensions and target buffer id
041366 C1          0263*      pop bc
041367 D1          0264*      pop de
041368 E1          0265*      pop hl
041369             0266*  ; fall through to vdu_rgba2_to_8
041369             0267*  
041369             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041369             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041369             0270*  ; the "expand bitmap" command is:
041369             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041369             0272*  ; and then to reverse the byte order to fix endian-ness:
041369             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041369             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041369             0275*  ; VDU 23,27,&20,targetBufferID%;
041369             0276*  ; VDU 23,27,&21,width%;height%;0
041369             0277*  ; -------------------------------------------------------------------
041369             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
041369             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041369             0280*  vdu_rgba2_to_8:
041369             0281*  ; load the image dimensions and buffer id parameters
041369 ED 43 C5 13 0282*      ld (@width),bc
       04          
04136E ED 53 C7 13 0283*      ld (@height),de
       04          
041373 22 AA 13 04 0284*      ld (@bufferId0),hl
041377 22 B7 13 04 0285*      ld (@bufferId2),hl
04137B 22 C0 13 04 0286*      ld (@bufferId1),hl
04137F             0287*  ; clean up bytes that got stomped on by the ID loads
04137F 3E 48       0288*      ld a,0x48
041381 32 AC 13 04 0289*      ld (@bufferId0+2),a
041385 3E 17       0290*      ld a,23
041387 32 C2 13 04 0291*      ld (@bufferId1+2),a
04138B 3E 18       0292*      ld a,24
04138D 32 B9 13 04 0293*      ld (@bufferId2+2),a
041391 AF          0294*      xor a
041392 32 C9 13 04 0295*      ld (@height+2),a
041396             0296*  ; send the vdu command strings
041396 21 A1 13 04 0297*      ld hl,@beg
04139A 01 29 00 00 0298*      ld bc,@end-@beg
04139E 5B DF       0299*      rst.lil $18
0413A0 C9          0300*      ret
0413A1             0301*  @beg:
0413A1             0302*  ; Command 14: Consolidate blocks in a buffer
0413A1             0303*  ; VDU 23, 0, &A0, bufferId; 14
0413A1 17 00 A0    0304*      db 23,0,0xA0
0413A4 FE FF       0305*      dw 65534 ; workingBufferId
0413A6 0E          0306*      db 14 ; consolidate blocks
0413A7             0307*  ; the "expand bitmap" command is:
0413A7             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0413A7 17 00 A0    0309*      db 23,0,0xA0
0413AA 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0413AC 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0413AD 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0413AE FE FF       0313*      dw 65534 ; sourceBufferId
0413B0 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0413B4             0315*  ; reverse the byte order to fix endian-ness:
0413B4             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0413B4             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0413B4             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0413B4 17 00 A0    0319*      db 23,0,0xA0
0413B7 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0413B9 18          0321*      db 24 ; reverse byte order
0413BA 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0413BB 04 00       0323*      dw 4 ; size (4 bytes)
0413BD             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0413BD             0325*  ; VDU 23,27,&20,targetBufferID%;
0413BD 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0413C0 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0413C2             0328*  ; VDU 23,27,&21,width%;height%;0
0413C2 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0413C5 00 00       0330*  @width: dw 0x0000
0413C7 00 00       0331*  @height: dw 0x0000
0413C9 00          0332*      db 0x00 ; rgba8888 format
0413CA             0333*  @end:
0413CA             0334*  
0413CA             0335*  ; scratch variables
0413CA 00 00 00    0336*  bufferId0: dl 0x000000
0413CD 00 00 00    0337*  bufferId1: dl 0x000000
0413D0             0338*  
0413D0             0339*  ; load a vdu buffer from local memory
0413D0             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0413D0             0341*  vdu_load_buffer:
0413D0 ED 43 F9 13 0342*      ld (@length),bc
       04          
0413D5 D5          0343*      push de ; save data pointer
0413D6             0344*  ; send the vdu command string
0413D6 7D          0345*      ld a,l
0413D7 32 F6 13 04 0346*      ld (@bufferId),a
0413DB 7C          0347*      ld a,h
0413DC 32 F7 13 04 0348*      ld (@bufferId+1),a
0413E0 21 F3 13 04 0349*      ld hl,@cmd
0413E4 01 08 00 00 0350*      ld bc,@end-@cmd
0413E8 5B DF       0351*      rst.lil $18
0413EA             0352*  ; send the buffer data
0413EA E1          0353*      pop hl ; pointer to data
0413EB ED 4B F9 13 0354*      ld bc,(@length)
       04          
0413F0 5B DF       0355*      rst.lil $18 ; send it
0413F2 C9          0356*      ret
0413F3             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0413F3 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0413F6 00 00       0359*  @bufferId:	dw 0x0000
0413F8 00          0360*  		    db 0 ; load buffer
0413F9 00 00       0361*  @length:	dw 0x0000
0413FB 00          0362*  @end: db 0 ; padding
0413FC             0363*  
0413FC             0364*  ; clear a buffer
0413FC             0365*  ; inputs: hl = bufferId
0413FC             0366*  vdu_clear_buffer:
0413FC 7D          0367*      ld a,l
0413FD 32 14 14 04 0368*      ld (@bufferId),a
041401 7C          0369*      ld a,h
041402 32 15 14 04 0370*      ld (@bufferId+1),a
041406 21 11 14 04 0371*      ld hl,@cmd
04140A 01 06 00 00 0372*      ld bc,@end-@cmd
04140E 5B DF       0373*      rst.lil $18
041410 C9          0374*      ret
041411 17 00 A0    0375*  @cmd:       db 23,0,0xA0
041414 00 00       0376*  @bufferId:	dw 0x0000
041416 02          0377*  		    db 2 ; clear buffer
041417             0378*  @end:
041417             0379*  
041417             0380*  vdu_clear_all_buffers:
041417             0381*  ; clear all buffers
041417 21 22 14 04 0382*      ld hl,@beg
04141B 01 06 00 00 0383*      ld bc,@end-@beg
04141F 5B DF       0384*      rst.lil $18
041421 C9          0385*      ret
041422 17 00 A0    0386*  @beg: db 23,0,$A0
041425 FF FF       0387*        dw -1 ; clear all buffers
041427 02          0388*        db 2  ; command 2: clear a buffer
041428             0389*  @end:
041428             0390*  
041428             0391*  ; Command 14: Consolidate blocks in a buffer
041428             0392*  vdu_consolidate_buffer:
041428             0393*  ; set parameters for vdu call
041428 7D          0394*      ld a,l
041429 32 40 14 04 0395*      ld (@bufferId),a
04142D 7C          0396*      ld a,h
04142E 32 41 14 04 0397*      ld (@bufferId+1),a
041432 21 3D 14 04 0398*      ld hl,@beg
041436 01 06 00 00 0399*      ld bc,@end-@beg
04143A 5B DF       0400*      rst.lil $18
04143C C9          0401*      ret
04143D             0402*  ; VDU 23, 0, &A0, bufferId; 14
04143D 17 00 A0    0403*  @beg: db 23,0,0xA0
041440 00 00       0404*  @bufferId: dw 0x0000
041442 0E          0405*             db 14
041443             0406*  @end:
041443             0407*  
041443             0408*  ; load an image file to a buffer and make it a bitmap
041443             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041443             0410*  vdu_load_img:
041443             0411*  ; back up image type and dimension parameters
041443 22 CA 13 04 0412*      ld (bufferId0),hl
041447 F5          0413*      push af
041448 C5          0414*  	push bc
041449 D5          0415*  	push de
04144A             0416*  ; load the image
04144A CD 65 14 04 0417*  	call vdu_load_buffer_from_file
04144E             0418*  ; now make it a bitmap
04144E 2A CA 13 04 0419*      ld hl,(bufferId0)
041452 CD 28 14 04 0420*      call vdu_consolidate_buffer
041456 2A CA 13 04 0421*      ld hl,(bufferId0)
04145A CD 25 13 04 0422*      call vdu_buff_select
04145E D1          0423*  	pop de ; image height
04145F C1          0424*  	pop bc ; image width
041460 F1          0425*  	pop af ; image type
041461 C3 3A 13 04 0426*  	jp vdu_bmp_create ; will return to caller from there
041465             0427*  
041465             0428*  ; inputs: hl = bufferId; iy = pointer to filename
041465             0429*  vdu_load_buffer_from_file:
041465 22 CA 13 04 0430*      ld (bufferId0),hl
041469             0431*  
041469             0432*  ; clear target buffer
041469 CD FC 13 04 0433*      call vdu_clear_buffer
04146D             0434*  
04146D             0435*  ; open the file in read mode
04146D             0436*  ; Open a file
04146D             0437*  ; HLU: Filename
04146D             0438*  ;   C: Mode
04146D             0439*  ; Returns:
04146D             0440*  ;   A: Filehandle, or 0 if couldn't open
04146D FD E5       0441*  	push iy ; pointer to filename
04146F E1          0442*  	pop hl
041470 0E 01       0443*  	ld c,fa_read
041472             0444*      MOSCALL mos_fopen
041472 3E 0A       0001*M 			LD	A, function
041474 5B CF       0002*M 			RST.L	08h
041476 32 B1 14 04 0445*      ld (@filehandle),a
04147A             0446*  
04147A             0447*  @read_file:
04147A             0448*  ; Read a block of data from a file
04147A             0449*  ;   C: Filehandle
04147A             0450*  ; HLU: Pointer to where to write the data to
04147A             0451*  ; DEU: Number of bytes to read
04147A             0452*  ; Returns:
04147A             0453*  ; DEU: Number of bytes read
04147A 3A B1 14 04 0454*      ld a,(@filehandle)
04147E 4F          0455*      ld c,a
04147F 21 00 E0 B7 0456*      ld hl,filedata
041483 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
041487             0458*      MOSCALL mos_fread
041487 3E 1A       0001*M 			LD	A, function
041489 5B CF       0002*M 			RST.L	08h
04148B             0459*  
04148B             0460*  ; ; DEBUG: print chunk size
04148B             0461*  ;     push de
04148B             0462*  ;     pop hl
04148B             0463*  ;     call printDec
04148B             0464*  ;     call printNewLine
04148B             0465*  
04148B             0466*  ; test de for zero bytes read
04148B 21 00 00 00 0467*      ld hl,0
04148F AF          0468*      xor a ; clear carry
041490 ED 52       0469*      sbc hl,de
041492 CA A8 14 04 0470*      jp z,@close_file
041496             0471*  
041496             0472*  ; load a vdu buffer from local memory
041496             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041496 2A CA 13 04 0474*      ld hl,(bufferId0)
04149A D5          0475*      push de ; chunksize
04149B C1          0476*      pop bc
04149C 11 00 E0 B7 0477*      ld de,filedata
0414A0 CD D0 13 04 0478*      call vdu_load_buffer
0414A4             0479*  
0414A4             0480*  ; ; print progress breadcrumbs
0414A4             0481*  ;     ld a,'.'
0414A4             0482*  ;     rst.lil 10h
0414A4             0483*  
0414A4             0484*  ; read the next block
0414A4 C3 7A 14 04 0485*      jp @read_file
0414A8             0486*  
0414A8             0487*  ; close the file
0414A8             0488*  @close_file:
0414A8 3A B1 14 04 0489*      ld a,(@filehandle)
0414AC             0490*      MOSCALL mos_fclose
0414AC 3E 0B       0001*M 			LD	A, function
0414AE 5B CF       0002*M 			RST.L	08h
0414B0 C9          0491*      ret ; vdu_load_buffer_from_file
0414B1             0492*  
0414B1 00          0493*  @filehandle: db 0 ; file handle
0414B2 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0414B5             0495*  
0414B5 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0414B8             0497*  
0414B8             0498*  ; File information structure (FILINFO)
0414B8             0499*  @filinfo:
0414B8 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0414BC 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0414BE 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0414C0 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0414C1 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0414CE 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0415CE             0040       ; include "vdu_fonts.inc"
0415CE             0041       include "vdu_plot.inc"
0415CE             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0415CE             0002*  ; PLOT code 	(Decimal) 	Effect
0415CE             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0415CE             0004*  plot_sl_both: equ 0x00
0415CE             0005*  
0415CE             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0415CE             0007*  plot_sl_first: equ 0x08
0415CE             0008*  
0415CE             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0415CE             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0415CE             0011*  
0415CE             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0415CE             0013*  plot_sl_last: equ 0x20
0415CE             0014*  
0415CE             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0415CE             0016*  plot_sl_none: equ 0x28
0415CE             0017*  
0415CE             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0415CE             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0415CE             0020*  
0415CE             0021*  ; &40-&47 	64-71 	Point plot
0415CE             0022*  plot_pt: equ 0x40
0415CE             0023*  
0415CE             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background Â§Â§
0415CE             0025*  plot_lf_lr_non_bg: equ 0x48
0415CE             0026*  
0415CE             0027*  ; &50-&57 	80-87 	Triangle fill
0415CE             0028*  plot_tf: equ 0x50
0415CE             0029*  
0415CE             0030*  ; &58-&5F 	88-95 	Line fill right to background Â§Â§
0415CE             0031*  plot_lf_r_bg: equ 0x58
0415CE             0032*  
0415CE             0033*  ; &60-&67 	96-103 	Rectangle fill
0415CE             0034*  plot_rf: equ 0x60
0415CE             0035*  
0415CE             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground Â§Â§
0415CE             0037*  plot_lf_lr_fg: equ 0x60
0415CE             0038*  
0415CE             0039*  ; &70-&77 	112-119 	Parallelogram fill
0415CE             0040*  plot_pf: equ 0x70
0415CE             0041*  
0415CE             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground Â§Â§
0415CE             0043*  plot_lf_r_non_fg: equ 0x78
0415CE             0044*  
0415CE             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0415CE             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0415CE             0047*  
0415CE             0048*  ; &90-&97 	144-151 	Circle outline
0415CE             0049*  plot_co: equ 0x90
0415CE             0050*  
0415CE             0051*  ; &98-&9F 	152-159 	Circle fill
0415CE             0052*  plot_cf: equ 0x98
0415CE             0053*  
0415CE             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0415CE             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0415CE             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0415CE             0057*  
0415CE             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0415CE             0059*  plot_rcm: equ 0xB8
0415CE             0060*  
0415CE             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0415CE             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0415CE             0063*  ; &D0-&D7 	208-215 	Not defined
0415CE             0064*  ; &D8-&DF 	216-223 	Not defined
0415CE             0065*  ; &E0-&E7 	224-231 	Not defined
0415CE             0066*  
0415CE             0067*  ; &E8-&EF 	232-239 	Bitmap plot Â§
0415CE             0068*  plot_bmp: equ 0xE8
0415CE             0069*  
0415CE             0070*  ; &F0-&F7 	240-247 	Not defined
0415CE             0071*  ; &F8-&FF 	248-255 	Not defined
0415CE             0072*  
0415CE             0073*  ; Â§ Support added in Agon Console8 VDP 2.1.0 Â§Â§ Support added in
0415CE             0074*  ; Agon Console8 VDP 2.2.0
0415CE             0075*  
0415CE             0076*  ; Within each group of eight plot codes, the effects are as follows:
0415CE             0077*  ; Plot code 	Effect
0415CE             0078*  ; 0 	Move relative
0415CE             0079*  mv_rel: equ 0
0415CE             0080*  
0415CE             0081*  ; 1 	Plot relative in current foreground colour
0415CE             0082*  dr_rel_fg: equ 1
0415CE             0083*  
0415CE             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0415CE             0085*  ; 3 	Plot relative in current background colour
0415CE             0086*  dr_rel_bg: equ 3
0415CE             0087*  
0415CE             0088*  ; 4 	Move absolute
0415CE             0089*  mv_abs: equ 4
0415CE             0090*  
0415CE             0091*  ; 5 	Plot absolute in current foreground colour
0415CE             0092*  dr_abs_fg: equ 5
0415CE             0093*  
0415CE             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0415CE             0095*  ; 7 	Plot absolute in current background colour
0415CE             0096*  dr_abs_bg: equ 7
0415CE             0097*  
0415CE             0098*  ; Codes 0-3 use the position data provided as part of the command
0415CE             0099*  ; as a relative position, adding the position given to the current
0415CE             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0415CE             0101*  ; as part of the command as an absolute position, setting the current
0415CE             0102*  ; graphical cursor position to the position given.
0415CE             0103*  
0415CE             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0415CE             0105*  ; current pixel colour. These operations cannot currently be supported
0415CE             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0415CE             0107*  ; supported. Support for these codes may be added in a future version
0415CE             0108*  ; of the VDP firmware.
0415CE             0109*  
0415CE             0110*  ; 16 colour palette constants
0415CE             0111*  c_black: equ 0
0415CE             0112*  c_red_dk: equ 1
0415CE             0113*  c_green_dk: equ 2
0415CE             0114*  c_yellow_dk: equ 3
0415CE             0115*  c_blue_dk: equ 4
0415CE             0116*  c_magenta_dk: equ 5
0415CE             0117*  c_cyan_dk: equ 6
0415CE             0118*  c_grey: equ 7
0415CE             0119*  c_grey_dk: equ 8
0415CE             0120*  c_red: equ 9
0415CE             0121*  c_green: equ 10
0415CE             0122*  c_yellow: equ 11
0415CE             0123*  c_blue: equ 12
0415CE             0124*  c_magenta: equ 13
0415CE             0125*  c_cyan: equ 14
0415CE             0126*  c_white: equ 15
0415CE             0127*  
0415CE             0128*  ; VDU 25, mode, x; y;: PLOT command
0415CE             0129*  ; inputs: a=mode, bc=x0, de=y0
0415CE             0130*  vdu_plot:
0415CE 32 E8 15 04 0131*      ld (@mode),a
0415D2 ED 43 E9 15 0132*      ld (@x0),bc
       04          
0415D7 ED 53 EB 15 0133*      ld (@y0),de
       04          
0415DC 21 E7 15 04 0134*  	ld hl,@cmd
0415E0 01 06 00 00 0135*  	ld bc,@end-@cmd
0415E4 5B DF       0136*  	rst.lil $18
0415E6 C9          0137*  	ret
0415E7 19          0138*  @cmd:   db 25
0415E8 00          0139*  @mode:  db 0
0415E9 00 00       0140*  @x0: 	dw 0
0415EB 00 00       0141*  @y0: 	dw 0
0415ED 00          0142*  @end:   db 0 ; extra byte to soak up deu
0415EE             0143*  
0415EE             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0415EE             0145*  ; &E8-&EF 	232-239 	Bitmap plot Â§
0415EE             0146*  ; VDU 25, mode, x; y;: PLOT command
0415EE             0147*  ; inputs: bc=x0, de=y0
0415EE             0148*  ; prerequisites: vdu_buff_select
0415EE             0149*  vdu_plot_bmp:
0415EE ED 43 05 16 0150*      ld (@x0),bc
       04          
0415F3 ED 53 07 16 0151*      ld (@y0),de
       04          
0415F8 21 03 16 04 0152*  	ld hl,@cmd
0415FC 01 06 00 00 0153*  	ld bc,@end-@cmd
041600 5B DF       0154*  	rst.lil $18
041602 C9          0155*  	ret
041603 19          0156*  @cmd:   db 25
041604 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041605 00 00       0158*  @x0: 	dw 0x0000
041607 00 00       0159*  @y0: 	dw 0x0000
041609 00          0160*  @end:   db 0x00 ; padding
04160A             0161*  
04160A             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
04160A             0163*  ; &E8-&EF 	232-239 	Bitmap plot Â§
04160A             0164*  ; VDU 25, mode, x; y;: PLOT command
04160A             0165*  ; inputs: bc=x0, de=y0
04160A             0166*  ; USING 16.8 FIXED POINT COORDINATES
04160A             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
04160A             0168*  ;   the fractional portiion of the inputs are truncated
04160A             0169*  ;   leaving only the 16-bit integer portion
04160A             0170*  ; prerequisites: vdu_buff_select
04160A             0171*  vdu_plot_bmp168:
04160A             0172*  ; populate in the reverse of normal to keep the
04160A             0173*  ; inputs from stomping on each other
04160A ED 53 28 16 0174*      ld (@y0-1),de
       04          
04160F ED 43 26 16 0175*      ld (@x0-1),bc
       04          
041614 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
041616 32 26 16 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
04161A 21 25 16 04 0178*  	ld hl,@cmd
04161E 01 06 00 00 0179*  	ld bc,@end-@cmd
041622 5B DF       0180*  	rst.lil $18
041624 C9          0181*  	ret
041625 19          0182*  @cmd:   db 25
041626 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
041627 00 00       0184*  @x0: 	dw 0x0000
041629 00 00       0185*  @y0: 	dw 0x0000
04162B             0186*  @end:  ; no padding required b/c we shifted de right
04162B             0187*  
04162B             0188*  ; draw a filled rectangle
04162B             0189*  vdu_plot_rf:
04162B ED 43 52 16 0190*      ld (@x0),bc
       04          
041630 ED 53 54 16 0191*      ld (@y0),de
       04          
041635 DD 22 58 16 0192*      ld (@x1),ix
       04          
04163A FD 22 5A 16 0193*      ld (@y1),iy
       04          
04163F 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
041641 32 56 16 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041645 21 50 16 04 0196*  	ld hl,@cmd0
041649 01 0C 00 00 0197*  	ld bc,@end-@cmd0
04164D 5B DF       0198*  	rst.lil $18
04164F C9          0199*      ret
041650 19          0200*  @cmd0:  db 25 ; plot
041651 04          0201*  @arg0:  db plot_sl_both+mv_abs
041652 00 00       0202*  @x0:    dw 0x0000
041654 00 00       0203*  @y0:    dw 0x0000
041656 19          0204*  @cmd1:  db 25 ; plot
041657 65          0205*  @arg1:  db plot_rf+dr_abs_fg
041658 00 00       0206*  @x1:    dw 0x0000
04165A 00 00       0207*  @y1:    dw 0x0000
04165C 00          0208*  @end:   db 0x00 ; padding
04165D             0209*  
04165D             0210*  ; draw a filled circle
04165D             0211*  vdu_plot_cf:
04165D ED 43 84 16 0212*      ld (@x0),bc
       04          
041662 ED 53 86 16 0213*      ld (@y0),de
       04          
041667 DD 22 8A 16 0214*      ld (@x1),ix
       04          
04166C FD 22 8C 16 0215*      ld (@y1),iy
       04          
041671 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
041673 32 88 16 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
041677 21 82 16 04 0218*  	ld hl,@cmd0
04167B 01 0C 00 00 0219*  	ld bc,@end-@cmd0
04167F 5B DF       0220*  	rst.lil $18
041681 C9          0221*      ret
041682 19          0222*  @cmd0:  db 25 ; plot
041683 04          0223*  @arg0:  db plot_sl_both+mv_abs
041684 00 00       0224*  @x0:    dw 0x0000
041686 00 00       0225*  @y0:    dw 0x0000
041688 19          0226*  @cmd1:  db 25 ; plot
041689 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
04168A 00 00       0228*  @x1:    dw 0x0000
04168C 00 00       0229*  @y1:    dw 0x0000
04168E 00          0230*  @end:   db 0x00 ; padding
04168F             0231*  
04168F             0232*  ; VDU 25, mode, x; y;: PLOT command
04168F             0233*  ; inputs: a=mode, ix=x0, iy=y0
04168F             0234*  plot:
04168F 32 A9 16 04 0235*      ld (@mode),a
041693 DD 22 AA 16 0236*      ld (@x0),ix
       04          
041698 FD 22 AC 16 0237*      ld (@y0),iy
       04          
04169D 21 A8 16 04 0238*  	ld hl,@cmd
0416A1 01 06 00 00 0239*  	ld bc,@end-@cmd
0416A5 5B DF       0240*  	rst.lil $18
0416A7 C9          0241*  	ret
0416A8 19          0242*  @cmd:   db 25
0416A9 00          0243*  @mode:  db 0
0416AA 00 00       0244*  @x0: 	dw 0
0416AC 00 00       0245*  @y0: 	dw 0
0416AE 00          0246*  @end:   db 0 ; padding
0416AF             0247*  
0416AF             0248*  ; VDU 5: Write text at graphics cursor
0416AF             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0416AF             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0416AF             0251*  plot_text:
0416AF E5          0252*      push hl ; save text pointer
0416B0             0253*  ; move graphics cursor to x0, y0
0416B0 3E 44       0254*      ld a,plot_pt+mv_abs
0416B2 CD 8F 16 04 0255*      call plot
0416B6             0256*  ; write text
0416B6 E1          0257*      pop hl ; restore text pointer
0416B7 CD 6C 00 04 0258*      call printString
0416BB C9          0259*      ret
0416BC             0042   
0416BC             0043   ; SHAWN'S INCLUDES
0416BC             0044   	INCLUDE	"strings24.asm"
0416BC             0001*  ;------------------------------------------------------------------------
0416BC             0002*  ;  strings24.asm
0416BC             0003*  ;
0416BC             0004*  ; 24-bit native ez80 strings routines for numerical processing
0416BC             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0416BC             0006*  ;  MIT license
0416BC             0007*  ;------------------------------------------------------------------------
0416BC             0008*  
0416BC             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0416BC             0010*  ; and postpended with a minus sign if was negative
0416BC             0011*  ; Uses HLU, DEU, BCU
0416BC             0012*  print_HLU_s24:
0416BC CD 62 05 04 0013*  	call abs_hlu
0416C0 F5          0014*  	push af ; save the sign and zero flags
0416C1 CD CC 16 04 0015*  	call print_HLU_u24
0416C5 F1          0016*  	pop af
0416C6 F0          0017*  	ret p ; HLU was positive so nothig more to do
0416C7 3E 2D       0018*  	ld a,'-'
0416C9 5B D7       0019*  	rst.lil 10h
0416CB C9          0020*  	ret
0416CC             0021*  
0416CC             0022*  ;------------------------------------------------------------------------
0416CC             0023*  ;Full print and buffer routine so you can adjust behaviour
0416CC             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0416CC             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0416CC             0026*  ;Print value in HLU in decimal with leading 0s removed
0416CC             0027*  ; Uses HLU, DEU, BCU
0416CC             0028*  ;------------------------------------------------------------------------
0416CC             0029*  
0416CC             0030*  print_HLU_u24:
0416CC 22 A9 17 04 0031*  	ld	(hex_temp),hl
0416D0 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0416D2 11 AC 17 04 0033*  	ld	de,outbuf
0416D6 D5          0034*  	push	de
0416D7 21 07 00 00 0035*  	ld	hl,7
0416DB 19          0036*  	add	hl,de
0416DC E5          0037*  	push	hl
0416DD D1          0038*  	pop	de	;copy HLU to DEU
0416DE AF          0039*  	xor	a
0416DF             0040*  _pde_u_zerobuf:
0416DF 77          0041*  	ld	(hl),a	;zero out the output
0416E0 2B          0042*  	dec	hl
0416E1 10 FC       0043*  	djnz	_pde_u_zerobuf
0416E3             0044*  
0416E3 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0416E5             0046*  _bcd_Convert:
0416E5             0047*  
0416E5 21 A9 17 04 0048*  	ld hl,hex_temp
0416E9             0049*  ;
0416E9 CB 26       0050*  	sla (hl)
0416EB 23          0051*  	inc hl
0416EC CB 16       0052*  	rl (hl)
0416EE 23          0053*  	inc hl
0416EF CB 16       0054*  	rl (hl)		;24 bits rolled right
0416F1             0055*  
0416F1             0056*  
0416F1 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0416F3 D5          0058*  	push	de
0416F4 E1          0059*  	pop	hl
0416F5             0060*  
0416F5             0061*  _bcd_Add3:
0416F5 7E          0062*  	ld	a,(hl)
0416F6 8F          0063*  	adc	a
0416F7 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0416F8 FE 10       0065*  	cp	10h	;did we roll over nibble?
0416FA 3F          0066*  	ccf
0416FB CB A7       0067*  	res	4,a
0416FD             0068*  
0416FD 77          0069*          ld (hl),a
0416FE 2B          0070*  	dec	hl
0416FF 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
041701 0D          0072*          dec c
041702 20 E1       0073*          jr nz, _bcd_Convert	;loop around
041704             0074*  
041704             0075*  
041704 E1          0076*  	pop	hl
041705 E5          0077*  	push	hl
041706 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
041708             0079*  _pde_u_make_ascii:
041708 7E          0080*  	ld	a,(hl)
041709 B7          0081*  	or	a
04170A 20 05       0082*  	jr	nz,_pde_u_make_ascii2
04170C 36 20       0083*  	ld	(hl),' '
04170E 23          0084*  	inc	hl
04170F 10 F7       0085*  	djnz	_pde_u_make_ascii
041711             0086*  _pde_u_make_ascii2:
041711 04          0087*  	inc	b
041712             0088*  _pde_u_make_ascii3:
041712 7E          0089*  	ld	a,(hl)
041713 F6 30       0090*  	or	30h
041715 77          0091*  	ld	(hl),a
041716 23          0092*  	inc	hl
041717 10 F9       0093*  	djnz	_pde_u_make_ascii3
041719             0094*  
041719 E1          0095*  	pop	hl
04171A 06 08       0096*  	ld	b,8
04171C             0097*  _pde_u_final_out:
04171C 7E          0098*  	ld	a,(hl)
04171D 23          0099*  	inc	hl
04171E FE 20       0100*  	cp	' '
041720 28 02       0101*  	jr	z,_pde_u_final_out_strip
041722 5B D7       0102*  	rst.lil	10h
041724             0103*  _pde_u_final_out_strip:
041724 10 F6       0104*  	djnz	_pde_u_final_out
041726 C9          0105*  	ret
041727             0106*  
041727             0107*  ;------------------------------------------------------------------------
041727             0108*  ; is_digit
041727             0109*  ; C flag set if A is a digit
041727             0110*  ; preserves all registers
041727             0111*  ;------------------------------------------------------------------------
041727             0112*  is_digit:
041727 FE 30       0113*  	cp	'0'
041729 3F          0114*  	ccf
04172A D0          0115*  	ret	nc	;less that '0'
04172B FE 3A       0116*  	cp	'9' + 1
04172D C9          0117*  	ret
04172E             0118*  
04172E             0119*  
04172E             0120*  ;------------------------------------------------------------------------
04172E             0121*  ; char2hex
04172E             0122*  ; Input: ASCII nibble in A
04172E             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
04172E             0124*  ;------------------------------------------------------------------------
04172E             0125*  char2hex:
04172E FE 30       0126*  	CP	'0'
041730 38 1D       0127*  	JR	C, char_not_hex
041732 FE 3A       0128*  	CP	'9' + 1
041734 30 03       0129*  	JR	NC, char_not_09
041736 D6 30       0130*  	sub	'0'
041738 C9          0131*  	ret
041739             0132*  
041739             0133*  char_not_09:
041739             0134*  	; char is not 0 to 9. Try upper case
041739 FE 41       0135*  	CP	'A'
04173B 38 12       0136*  	JR	C, char_not_hex
04173D FE 47       0137*  	CP	'F' + 1
04173F 30 03       0138*  	JR	NC, char_not_AF
041741 D6 37       0139*  	sub	'A'-10
041743 C9          0140*  	ret
041744             0141*  
041744             0142*  char_not_AF:
041744             0143*  	; char is not upper case A-F. Try lower
041744 FE 61       0144*  	CP	'a'
041746 38 07       0145*  	JR	C, char_not_hex
041748 FE 67       0146*  	CP	'f' + 1
04174A 30 03       0147*  	JR	NC, char_not_hex
04174C D6 57       0148*  	sub	'a' - 10
04174E C9          0149*  	RET
04174F             0150*  
04174F             0151*  char_not_hex:
04174F 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
041751 C9          0153*  	RET
041752             0154*  
041752             0155*  ;------------------------------------------------------------------------
041752             0156*  ;  newline
041752             0157*  ;  Output CR+LF; all registers preserved
041752             0158*  ;------------------------------------------------------------------------
041752             0159*  newline:
041752 F5          0160*         push   AF
041753 3E 0D       0161*         LD     A, 13
041755 5B D7       0162*         RST.LIL    10h
041757 3E 0A       0163*         LD     A, 10
041759 5B D7       0164*         RST.LIL    10h
04175B F1          0165*         POP    AF
04175C C9          0166*         RET
04175D             0167*  
04175D             0168*  ;------------------------------------------------------------------------
04175D             0169*  ;  put_nibble
04175D             0170*  ;  Output a single hex nibble in A
04175D             0171*  ;  All registers preserved
04175D             0172*  ;------------------------------------------------------------------------
04175D             0173*  put_nibble:
04175D F5          0174*  	push   AF
04175E C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
041760 27          0176*  	daa
041761 CE 40       0177*  	adc    a,040h
041763 27          0178*  	daa
041764 5B D7       0179*  	RST.LIL    10h	;output character in A
041766 F1          0180*  	pop    AF
041767 C9          0181*  	ret
041768             0182*  
041768             0183*  ;------------------------------------------------------------------------
041768             0184*  ;  print_A
041768             0185*  ;  Output the 8-bit hex number A
041768             0186*  ;  All registers preserved
041768             0187*  ;------------------------------------------------------------------------
041768             0188*  print_A:
041768 F5          0189*  	push 	AF
041769 F5          0190*  	push 	AF	;save for second nibble
04176A 0F          0191*  	rrca
04176B 0F          0192*  	rrca
04176C 0F          0193*  	rrca
04176D 0F          0194*  	rrca
04176E E6 0F       0195*  	and	0Fh	;first nibble
041770 CD 5D 17 04 0196*  	call	put_nibble
041774 F1          0197*  	pop 	AF
041775 E6 0F       0198*  	and	0Fh	;second nibble
041777 CD 5D 17 04 0199*  	call	put_nibble
04177B F1          0200*  	pop 	AF
04177C C9          0201*  	ret
04177D             0202*  
04177D             0203*  ;------------------------------------------------------------------------
04177D             0204*  ;  print_HLU_hex
04177D             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
04177D             0206*  ;------------------------------------------------------------------------
04177D             0207*  print_HLU_hex:
04177D F5          0208*         push   AF
04177E 22 A9 17 04 0209*         ld     (hex_temp),hl
041782 3A AB 17 04 0210*         ld     a,(hex_temp+2)
041786 CD 68 17 04 0211*         call   print_A
04178A 3A AA 17 04 0212*         ld     a,(hex_temp+1)
04178E CD 68 17 04 0213*         call   print_A
041792 3A A9 17 04 0214*         ld     a,(hex_temp)
041796 CD 68 17 04 0215*         call   print_A
04179A F1          0216*         POP    AF
04179B C9          0217*         RET
04179C             0218*  
04179C             0219*  ;------------------------------------------------------------------------
04179C             0220*  ;  puts
04179C             0221*  ;  Output a zero-terminated string whose address is in HL; all
04179C             0222*  ;  registers preserved.
04179C             0223*  ;------------------------------------------------------------------------
04179C             0224*  puts:
04179C F5          0225*         push   AF
04179D C5          0226*         push   BC
04179E 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0417A2 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0417A4 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0417A6 C1          0230*         pop    BC
0417A7 F1          0231*         pop    AF
0417A8 C9          0232*         ret
0417A9             0233*  
0417A9             0234*  ;------------------------------------------------------------------------
0417A9             0235*  ; Data area
0417A9             0236*  ; Storage for 24 bit conversion
0417A9             0237*  ;------------------------------------------------------------------------
0417A9             0238*  hex_temp:
0417A9 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0417AC             0240*  
0417AC             0241*  outbuf:
0417AC 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0417B5             0045   
0417B5             0046   main:
0417B5             0047   
0417B5 CD BA 17 04 0048       call test_umul24x24
0417B9             0049       ; call test_umul24x8
0417B9             0050   
0417B9 C9          0051       ret
0417BA             0052   
0417BA             0053   test_umul24x24:
0417BA 21 02 00 00 0054       ld hl,2
0417BE 11 03 00 00 0055       ld de,3
0417C2 CD C9 00 04 0056       call printHexUHL
0417C6 CD 81 00 04 0057       call printNewLine
0417CA EB          0058       ex de,hl
0417CB CD C9 00 04 0059       call printHexUHL
0417CF CD 81 00 04 0060       call printNewLine
0417D3 CD 81 00 04 0061       call printNewLine
0417D7 EB          0062       ex de,hl
0417D8             0063   
0417D8 CD 50 06 04 0064       call umul24x24
0417DC 2A AB 06 04 0065       ld hl,(umul24x24out+3)
0417E0 CD C9 00 04 0066       call printHexUHL
0417E4 2A A8 06 04 0067       ld hl,(umul24x24out)
0417E8 CD C9 00 04 0068       call printHexUHL
0417EC CD 81 00 04 0069       call printNewLine
0417F0 C9          0070       ret
0417F1             0071   
0417F1             0072   test_umul24x8:
0417F1 21 02 00 00 0073       ld hl,2
0417F5 3E 03       0074       ld a,3
0417F7 CD C9 00 04 0075       call printHexUHL
0417FB CD 81 00 04 0076       call printNewLine
0417FF CD AF 00 04 0077       call printHexA
041803 CD 81 00 04 0078       call printNewLine
041807 CD 21 06 04 0079       call umul24x8
04180B CD AF 00 04 0080       call printHexA
04180F CD C9 00 04 0081       call printHexUHL
041813 CD 81 00 04 0082       call printNewLine
041817 C9          0083       ret
