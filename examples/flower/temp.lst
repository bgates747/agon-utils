PC     Output      Line
040000             0001       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0002   
040000             0003       .assume adl=1
040000             0004       .org 0x040000
040000             0005   
040000 C3 45 00 04 0006       jp start
040004             0007   
040004 FF FF FF FF 0008       .align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0009       .db "MOS"
040043 00          0010       .db 00h
040044 01          0011       .db 01h
040045             0012   
040045             0013   start:
040045 F5          0014       push af
040046 C5          0015       push bc
040047 D5          0016       push de
040048 DD E5       0017       push ix
04004A FD E5       0018       push iy
04004C             0019   
04004C CD B0 17 04 0020       call main
040050             0021   
040050             0022   exit:
040050 FD E1       0023       pop iy
040052 DD E1       0024       pop ix
040054 D1          0025       pop de
040055 C1          0026       pop bc
040056 F1          0027       pop af
040057 21 00 00 00 0028       ld hl,0
04005B             0029   
04005B C9          0030       ret
04005C             0031   
04005C             0032   ; API INCLUDES
04005C             0033       include "functions.inc"
04005C             0001*      MACRO printChar char
04005C             0002*          LD A, char
04005C             0003*          RST.LIL 10h
04005C             0004*      ENDMACRO
04005C             0005*  
04005C             0006*  ; test the sign of HL
04005C             0007*  ; inputs: HL obviously
04005C             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
04005C             0009*  ; destroys: flags
04005C             0010*      MACRO signHL
04005C             0011*          add hl,de
04005C             0012*          or a
04005C             0013*          sbc hl,de
04005C             0014*      ENDMACRO
04005C             0015*  
04005C             0016*  ; Simulated call to subroutine at HL
04005C             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
04005C             0018*  ; outputs: whatever the subroutine does, including HL and BC
04005C             0019*  ; destroys: only what the subroutine does, but always BC
04005C             0020*      MACRO callHL
04005C             0021*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0022*          push bc       ; which constitutes the return address
04005C             0023*          jp   (hl)     ; Jump to the address in HL
04005C             0024*      ENDMACRO
04005C             0025*  
04005C             0026*  ; Simulated call to subroutine at IX
04005C             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
04005C             0028*  ; outputs: whatever the subroutine does, including IX and BC
04005C             0029*  ; destroys: only what the subroutine does, but always BC
04005C             0030*      MACRO callIX
04005C             0031*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0032*          push bc       ; which constitutes the return address
04005C             0033*          jp   (ix)     ; Jump to the address in IX
04005C             0034*      ENDMACRO
04005C             0035*  
04005C             0036*  ; Simulated call to soubroutinte at IY
04005C             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
04005C             0038*  ; outputs: whatever the subroutine does, including IY and BC
04005C             0039*  ; destroys: only what the subroutine does, but always BC
04005C             0040*      MACRO callIY
04005C             0041*          ld bc,$+7     ; Address of first instruction after the jump
04005C             0042*          push bc       ; which constitutes the return address
04005C             0043*          jp   (iy)     ; Jump to the address in IY
04005C             0044*      ENDMACRO
04005C             0045*  
04005C             0046*  ; put the value in HLU into the accumulator
04005C             0047*  ; destroys: af
04005C             0048*      MACRO HLU_TO_A
04005C             0049*          push hl ; 4 cycles
04005C             0050*          inc sp ; 1 cycle
04005C             0051*          pop af  ; 4 cycles
04005C             0052*          dec sp ; 1 cycle
04005C             0053*                 ; 10 cycles total
04005C             0054*      ENDMACRO
04005C             0055*  
04005C             0056*  A_TO_HLU:
04005C             0057*      ; call is 7 cycles
04005C 22 69 00 04 0058*      ld (@scratch),hl ; 7 cycles
040060 32 6B 00 04 0059*      ld (@scratch+2),a ; 5 cycles
040064 2A 69 00 04 0060*      ld hl,(@scratch) ; 7 cycles
040068 C9          0061*      ret ; 6 cycles
040069             0062*          ; 25 cycles total
040069 00 00 00    0063*  @scratch: dl 0
04006C             0064*  
04006C             0065*      MACRO A_TO_HLU
04006C             0066*          push.s af
04006C             0067*          inc sp
04006C             0068*          push.s hl
04006C             0069*          pop hl
04006C             0070*          inc sp
04006C             0071*          inc sp
04006C             0072*      ENDMACRO
04006C             0073*  
04006C             0074*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
04006C             0075*  ; Print a zero-terminated string
04006C             0076*  ; HL: Pointer to string
04006C             0077*  printString:
04006C C5          0078*  	PUSH	BC
04006D 01 00 00 00 0079*  	LD		BC,0
040071 3E 00       0080*  	LD 	 	A,0
040073 5B DF       0081*  	RST.LIL 18h
040075 C1          0082*  	POP		BC
040076 C9          0083*  	RET
040077             0084*  ; print a VDU sequence
040077             0085*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040077             0086*  sendVDUsequence:
040077 C5          0087*  	PUSH	BC
040078 01 00 00 00 0088*  	LD		BC, 0
04007C 4E          0089*  	LD		C, (HL)
04007D 5B DF       0090*  	RST.LIL	18h
04007F C1          0091*  	POP		BC
040080 C9          0092*  	RET
040081             0093*  ; Print Newline sequence to VDP
040081             0094*  printNewLine:
040081 F5          0095*      push af ; for some reason rst.lil 10h sets carry flag
040082 3E 0D       0096*  	LD	A, '\r'
040084 5B D7       0097*  	RST.LIL 10h
040086 3E 0A       0098*  	LD	A, '\n'
040088 5B D7       0099*  	RST.LIL 10h
04008A F1          0100*      pop af
04008B C9          0101*  	RET
04008C             0102*  
04008C             0103*  ; Print a 24-bit HEX number
04008C             0104*  ; HLU: Number to print
04008C             0105*  printHex24:
04008C             0106*  	; PUSH	HL      ; 4 cycles
04008C             0107*  	; LD		HL, 2   ; 4 cycles
04008C             0108*  	; ADD		HL, SP  ; 1 cycle
04008C             0109*  	; LD		A, (HL) ; 2 cycles
04008C             0110*  	; POP		HL      ; 4 cycles
04008C             0111*      ;                 ; 15 cycles total
04008C E5          0112*      push hl ; 4 cycles
04008D 33          0113*      inc sp ; 1 cycle
04008E F1          0114*      pop af  ; 4 cycles
04008F 3B          0115*      dec sp ; 1 cycle
040090             0116*              ; 10 cycles total
040090 CD 9A 00 04 0117*  	CALL	printHex8
040094             0118*  ; Print a 16-bit HEX number
040094             0119*  ; HL: Number to print
040094             0120*  printHex16:
040094 7C          0121*  	LD		A,H
040095 CD 9A 00 04 0122*  	CALL	printHex8
040099 7D          0123*  	LD		A,L
04009A             0124*  ; Print an 8-bit HEX number
04009A             0125*  ; A: Number to print
04009A             0126*  printHex8:
04009A 4F          0127*  	LD		C,A
04009B 1F          0128*  	RRA
04009C 1F          0129*  	RRA
04009D 1F          0130*  	RRA
04009E 1F          0131*  	RRA
04009F CD A4 00 04 0132*  	CALL	@F
0400A3 79          0133*  	LD		A,C
0400A4             0134*  @@:
0400A4 E6 0F       0135*  	AND		0Fh
0400A6 C6 90       0136*  	ADD		A,90h
0400A8 27          0137*  	DAA
0400A9 CE 40       0138*  	ADC		A,40h
0400AB 27          0139*  	DAA
0400AC 5B D7       0140*  	RST.LIL	10h
0400AE C9          0141*  	RET
0400AF             0142*  
0400AF             0143*  printHexA:
0400AF F5          0144*      push af
0400B0 C5          0145*      push bc
0400B1 CD 9A 00 04 0146*      call printHex8
0400B5 3E 20       0147*      ld a,' '
0400B7 5B D7       0148*      rst.lil 10h
0400B9 C1          0149*      pop bc
0400BA F1          0150*      pop af
0400BB C9          0151*      ret
0400BC             0152*  
0400BC             0153*  printHexHL:
0400BC F5          0154*      push af
0400BD C5          0155*      push bc
0400BE CD 94 00 04 0156*      call printHex16
0400C2 3E 20       0157*      ld a,' '
0400C4 5B D7       0158*      rst.lil 10h
0400C6 C1          0159*      pop bc
0400C7 F1          0160*      pop af
0400C8 C9          0161*      ret
0400C9             0162*  
0400C9             0163*  printHexUHL:
0400C9 F5          0164*      push af
0400CA C5          0165*      push bc
0400CB CD 8C 00 04 0166*      call printHex24
0400CF 3E 20       0167*      ld a,' '
0400D1 5B D7       0168*      rst.lil 10h
0400D3 C1          0169*      pop bc
0400D4 F1          0170*      pop af
0400D5 C9          0171*      ret
0400D6             0172*  
0400D6             0173*  printHexAUHL:
0400D6 F5          0174*      push af
0400D7 C5          0175*      push bc
0400D8 CD 9A 00 04 0176*      call printHex8
0400DC 3E 2E       0177*      ld a,'.'
0400DE 5B D7       0178*      rst.lil 10h
0400E0 CD 8C 00 04 0179*      call printHex24
0400E4 3E 20       0180*      ld a,' '
0400E6 5B D7       0181*      rst.lil 10h
0400E8 C1          0182*      pop bc
0400E9 F1          0183*      pop af
0400EA C9          0184*      ret
0400EB             0185*  
0400EB             0186*  printHexABHL:
0400EB             0187*  ; preserve registers
0400EB C5          0188*      push bc ; b will be ok c will not
0400EC F5          0189*      push af ; will get totally destroyed
0400ED             0190*  ; print a
0400ED CD 9A 00 04 0191*      call printHex8
0400F1             0192*  ; print b
0400F1 78          0193*      ld a,b
0400F2 CD 9A 00 04 0194*      call printHex8
0400F6             0195*  ; print hl
0400F6 CD 94 00 04 0196*      call printHex16
0400FA             0197*  ; restore registers
0400FA F1          0198*      pop af
0400FB C1          0199*      pop bc
0400FC C9          0200*      ret
0400FD             0201*  
0400FD             0202*  printHexBHL:
0400FD             0203*  ; preserve registers
0400FD C5          0204*      push bc ; b will be ok c will not
0400FE F5          0205*      push af ; will get totally destroyed
0400FF             0206*  ; print b
0400FF 78          0207*      ld a,b
040100 CD 9A 00 04 0208*      call printHex8
040104             0209*  ; print hl
040104 CD 94 00 04 0210*      call printHex16
040108             0211*  ; restore registers
040108 F1          0212*      pop af
040109 C1          0213*      pop bc
04010A C9          0214*      ret
04010B             0215*  
04010B             0216*  printHexCDE:
04010B             0217*  ; preserve registers
04010B C5          0218*      push bc ; b will be ok c will not
04010C F5          0219*      push af ; will get totally destroyed
04010D             0220*  ; print c
04010D 79          0221*      ld a,c
04010E CD 9A 00 04 0222*      call printHex8
040112             0223*  ; print de
040112 EB          0224*      ex de,hl
040113 CD 94 00 04 0225*      call printHex16
040117 EB          0226*      ex de,hl
040118             0227*  ; restore registers
040118 F1          0228*      pop af
040119 C1          0229*      pop bc
04011A C9          0230*      ret
04011B             0231*  
04011B             0232*  ; Print a 0x HEX prefix
04011B             0233*  DisplayHexPrefix:
04011B 3E 30       0234*  	LD	A, '0'
04011D 5B D7       0235*  	RST.LIL 10h
04011F 3E 78       0236*  	LD	A, 'x'
040121 5B D7       0237*  	RST.LIL 10h
040123 C9          0238*  	RET
040124             0239*  
040124             0240*      MACRO printDecBC
040124             0241*          push hl
040124             0242*          push bc
040124             0243*          pop hl
040124             0244*          call printDec
040124             0245*          pop hl
040124             0246*      ENDMACRO
040124             0247*  
040124             0248*      MACRO printDecDE
040124             0249*          push hl
040124             0250*          push de
040124             0251*          pop hl
040124             0252*          call printDec
040124             0253*          pop hl
040124             0254*      ENDMACRO
040124             0255*  
040124             0256*      MACRO printDecHL
040124             0257*          call printDec
040124             0258*      ENDMACRO
040124             0259*  
040124             0260*      MACRO printDecIX
040124             0261*          push hl
040124             0262*          push ix
040124             0263*          pop hl
040124             0264*          call printDec
040124             0265*          pop hl
040124             0266*      ENDMACRO
040124             0267*  
040124             0268*      MACRO printDecIY
040124             0269*          push hl
040124             0270*          push iy
040124             0271*          pop hl
040124             0272*          call printDec
040124             0273*          pop hl
040124             0274*      ENDMACRO
040124             0275*  
040124             0276*  
040124             0277*  ; Prints the right justified decimal value in HL without leading zeroes
040124             0278*  ; HL : Value to print
040124             0279*  ; preserves all registers and flags
040124             0280*  printDec:
040124             0281*  ; BEGIN MY CODE
040124             0282*  ; back up all the things
040124 F5          0283*      push af
040125 C5          0284*      push bc
040126 D5          0285*      push de
040127 E5          0286*      push hl
040128             0287*  ; END MY CODE
040128 11 50 01 04 0288*  	LD	 DE, _printDecBuffer
04012C CD 60 01 04 0289*  	CALL u24_to_ascii
040130             0290*  ; BEGIN MY CODE
040130             0291*  ; replace leading zeroes with spaces
040130 21 50 01 04 0292*      LD	 HL, _printDecBuffer
040134 06 07       0293*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040136             0294*  @loop:
040136 7E          0295*      LD	 A, (HL)
040137 FE 30       0296*      CP	 '0'
040139 C2 47 01 04 0297*      JP	 NZ, @done
04013D 3E 20       0298*      LD   A, ' '
04013F 77          0299*      LD	 (HL), A
040140 23          0300*      INC	 HL
040141 CD 17 07 04 0301*      CALL vdu_cursor_forward
040145 10 EF       0302*      DJNZ @loop
040147             0303*  @done:
040147             0304*  ; END MY CODE
040147             0305*  	; LD	 HL, _printDecBuffer
040147 CD 6C 00 04 0306*  	CALL printString
04014B             0307*  ; BEGIN MY CODE
04014B             0308*  ; restore all the things
04014B E1          0309*      pop hl
04014C D1          0310*      pop de
04014D C1          0311*      pop bc
04014E F1          0312*      pop af
04014F             0313*  ; END MY CODE
04014F C9          0314*  	RET
040150 00 00 00 00 0315*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040160             0316*  
040160             0317*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040160             0318*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040160             0319*  ; so it will allways be 8 characters length
040160             0320*  ; HL : Value to convert to string
040160             0321*  ; DE : pointer to buffer, at least 8 byte + 0
040160             0322*  u24_to_ascii:
040160 01 80 69 67 0323*  	LD	 BC,-10000000
040164 CD 97 01 04 0324*  	CALL @one_digit
040168 01 C0 BD F0 0325*  	LD	 BC,-1000000
04016C CD 97 01 04 0326*  	CALL @one_digit
040170 01 60 79 FE 0327*  	LD	 BC,-100000
040174 CD 97 01 04 0328*  	CALL @one_digit
040178 01 F0 D8 FF 0329*  	LD   BC,-10000
04017C CD 97 01 04 0330*  	CALL @one_digit
040180 01 18 FC FF 0331*  	LD   BC,-1000
040184 CD 97 01 04 0332*  	CALL @one_digit
040188 01 9C FF FF 0333*  	LD   BC,-100
04018C CD 97 01 04 0334*  	CALL @one_digit
040190 0E F6       0335*  	LD   C,-10
040192 CD 97 01 04 0336*  	CALL @one_digit
040196 48          0337*  	LD   C,B
040197             0338*  @one_digit:
040197 3E 2F       0339*  	LD   A,'0'-1
040199             0340*  @divide_me:
040199 3C          0341*  	INC  A
04019A 09          0342*  	ADD  HL,BC
04019B 38 FC       0343*  	JR   C,@divide_me
04019D ED 42       0344*  	SBC  HL,BC
04019F 12          0345*  	LD   (DE),A
0401A0 13          0346*  	INC  DE
0401A1 C9          0347*  	RET
0401A2             0348*  
0401A2             0349*  print_u24:
0401A2 11 50 01 04 0350*      ld de,_printDecBuffer
0401A6 CD 60 01 04 0351*      call u24_to_ascii
0401AA 21 50 01 04 0352*      ld hl,_printDecBuffer
0401AE CD 6C 00 04 0353*      call printString
0401B2 C9          0354*      ret
0401B3             0355*  
0401B3             0356*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0401B3             0357*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0401B3             0358*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0401B3             0359*  u168_to_ascii:
0401B3             0360*  ; add a leading space to make room for sign flag if needed
0401B3 3E 20       0361*      ld a,' '
0401B5 12          0362*      ld (de),a
0401B6 13          0363*      inc de
0401B7             0364*  ; Convert integer part
0401B7 E5          0365*      push hl               ; Save HL (we’ll need the fractional part later)
0401B8 CD 2D 0D 04 0366*      call shift_hlu_r1b    ; Shift to get integer portion in HL
0401BC 01 F0 D8 FF 0367*      ld   bc, -10000
0401C0 CD E3 01 04 0368*      call @one_int
0401C4 01 18 FC FF 0369*      ld   bc, -1000
0401C8 CD E3 01 04 0370*      call @one_int
0401CC 01 9C FF FF 0371*      ld   bc, -100
0401D0 CD E3 01 04 0372*      call @one_int
0401D4 0E F6       0373*      ld   c, -10
0401D6 CD E3 01 04 0374*      call @one_int
0401DA 48          0375*      ld   c, b
0401DB CD E3 01 04 0376*      call @one_int
0401DF C3 EE 01 04 0377*      jp   @frac            ; Jump to fractional part conversion
0401E3             0378*  @one_int:
0401E3 3E 2F       0379*      ld   a, '0' - 1       ; Start ASCII character at '0'
0401E5             0380*  @divide_me:
0401E5 3C          0381*      inc  a
0401E6 09          0382*      add  hl, bc           ; Accumulate until overflow
0401E7 38 FC       0383*      jr   c, @divide_me
0401E9 ED 42       0384*      sbc  hl, bc           ; Remove excess after overflow
0401EB 12          0385*      ld   (de), a          ; Store ASCII digit
0401EC 13          0386*      inc  de
0401ED C9          0387*      ret
0401EE             0388*  ; Convert fractional part
0401EE             0389*  @frac:
0401EE 3E 2E       0390*      ld   a, '.'           ; Decimal point
0401F0 12          0391*      ld   (de), a
0401F1 13          0392*      inc  de
0401F2 E1          0393*      pop  hl               ; Restore HL with original fraction
0401F3 06 03       0394*      ld   b, 3             ; Loop counter for 3 fractional digits
0401F5             0395*  @frac_loop:
0401F5 26 0A       0396*      ld   h, 10            ; Load multiplier for fractional part
0401F7 ED 6C       0397*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0401F9 3E 30       0398*      ld   a, '0'
0401FB 84          0399*      add  a, h             ; Convert integer part to ASCII
0401FC 12          0400*      ld   (de), a
0401FD 13          0401*      inc  de
0401FE 10 F5       0402*      djnz @frac_loop       ; Repeat for each fractional digit
040200             0403*  ; Add null terminator
040200 AF          0404*      xor  a                ; Null terminator
040201 12          0405*      ld   (de), a
040202 C9          0406*      ret
040203             0407*  
040203             0408*  print_u168:
040203 11 50 01 04 0409*      ld de,_printDecBuffer
040207 CD B3 01 04 0410*      call u168_to_ascii
04020B 21 50 01 04 0411*      ld hl,_printDecBuffer
04020F CD 6C 00 04 0412*      call printString
040213 C9          0413*      ret
040214             0414*  
040214             0415*  ; signed version of u168_to_ascii
040214             0416*  s168_to_ascii:
040214 D5          0417*      push de ; save starting address of buffer
040215 CD 64 17 04 0418*      call abs_hlu
040219 F5          0419*      push af ; save sign flag
04021A CD B3 01 04 0420*      call u168_to_ascii
04021E F1          0421*      pop af ; restore sign flag
04021F D1          0422*      pop de ; restore starting address of buffer
040220 F0          0423*      ret p ; hlu was positive so nothing to do
040221 3E 2D       0424*      ld a,'-'
040223 12          0425*      ld (de),a
040224 C9          0426*      ret
040225             0427*  
040225             0428*  print_s168:
040225 11 50 01 04 0429*      ld de,_printDecBuffer
040229 CD 14 02 04 0430*      call s168_to_ascii
04022D 21 50 01 04 0431*      ld hl,_printDecBuffer
040231 CD 6C 00 04 0432*      call printString
040235 C9          0433*      ret
040236             0434*  
040236             0435*  ; #### new functions added by Brandon R. Gates ####
040236             0436*  
040236             0437*  ; print the binary representation of the 8-bit value in a
040236             0438*  ; destroys a, hl, bc
040236             0439*  printBin8:
040236 06 08       0440*      ld b,8      ; loop counter for 8 bits
040238 21 53 02 04 0441*      ld hl,@cmd  ; set hl to the low byte of the output string
04023C             0442*                  ; (which will be the high bit of the value in a)
04023C             0443*  @loop:
04023C 07          0444*      rlca ; put the next highest bit into carry
04023D 38 04       0445*      jr c,@one
04023F 36 30       0446*      ld (hl),'0'
040241 18 02       0447*      jr @next_bit
040243             0448*  @one:
040243 36 31       0449*      ld (hl),'1'
040245             0450*  @next_bit:
040245 23          0451*      inc hl
040246 10 F4       0452*      djnz @loop
040248             0453*  ; print it
040248 21 53 02 04 0454*  	ld hl,@cmd
04024C 01 08 00 00 0455*  	ld bc,@end-@cmd
040250 5B DF       0456*  	rst.lil $18
040252 C9          0457*  	ret
040253             0458*  @cmd: ds 8 ; eight bytes for eight bits
04025B             0459*  @end:
04025B             0460*  
04025B             0461*  ; print the binary representation of the 8-bit value in a
04025B             0462*  ; in reverse order (lsb first)
04025B             0463*  ; destroys a, hl, bc
04025B             0464*  printBin8Rev:
04025B 06 08       0465*      ld b,8      ; loop counter for 8 bits
04025D 21 78 02 04 0466*      ld hl,@cmd  ; set hl to the low byte of the output string
040261             0467*                  ; (which will be the high bit of the value in a)
040261             0468*  @loop:
040261 0F          0469*      rrca ; put the next lowest bit into carry
040262 38 04       0470*      jr c,@one
040264 36 30       0471*      ld (hl),'0'
040266 18 02       0472*      jr @next_bit
040268             0473*  @one:
040268 36 31       0474*      ld (hl),'1'
04026A             0475*  @next_bit:
04026A 23          0476*      inc hl
04026B 10 F4       0477*      djnz @loop
04026D             0478*  ; print it
04026D 21 78 02 04 0479*  	ld hl,@cmd
040271 01 08 00 00 0480*  	ld bc,@end-@cmd
040275 5B DF       0481*  	rst.lil $18
040277 C9          0482*  	ret
040278             0483*  @cmd: ds 8 ; eight bytes for eight bits
040280             0484*  @end:
040280             0485*  
040280             0486*  ; print registers to screen in hexidecimal format
040280             0487*  ; inputs: none
040280             0488*  ; outputs: values of every register printed to screen
040280             0489*  ;    values of each register in global scratch memory
040280             0490*  ; destroys: nothing
040280             0491*  stepRegistersHex:
040280             0492*  ; store everything in scratch
040280 22 6D 04 04 0493*      ld (uhl),hl
040284 ED 43 70 04 0494*      ld (ubc),bc
       04          
040289 ED 53 73 04 0495*      ld (ude),de
       04          
04028E DD 22 76 04 0496*      ld (uix),ix
       04          
040293 FD 22 79 04 0497*      ld (uiy),iy
       04          
040298 F5          0498*      push af ; fml
040299 E1          0499*      pop hl  ; thanks, zilog
04029A 22 6A 04 04 0500*      ld (uaf),hl
04029E F5          0501*      push af ; dammit
04029F             0502*  
04029F             0503*  ; home the cursor
04029F CD F6 06 04 0504*      call vdu_home_cursor
0402A3             0505*  
0402A3             0506*  ; print each register
0402A3 21 F0 03 04 0507*      ld hl,str_afu
0402A7 CD 6C 00 04 0508*      call printString
0402AB 2A 6A 04 04 0509*      ld hl,(uaf)
0402AF CD 8C 00 04 0510*      call printHex24
0402B3 CD 81 00 04 0511*      call printNewLine
0402B7             0512*  
0402B7 21 F5 03 04 0513*      ld hl,str_hlu
0402BB CD 6C 00 04 0514*      call printString
0402BF 2A 6D 04 04 0515*      ld hl,(uhl)
0402C3 CD 8C 00 04 0516*      call printHex24
0402C7 CD 81 00 04 0517*      call printNewLine
0402CB             0518*  
0402CB 21 FA 03 04 0519*      ld hl,str_bcu
0402CF CD 6C 00 04 0520*      call printString
0402D3 2A 70 04 04 0521*      ld hl,(ubc)
0402D7 CD 8C 00 04 0522*      call printHex24
0402DB CD 81 00 04 0523*      call printNewLine
0402DF             0524*  
0402DF 21 FF 03 04 0525*      ld hl,str_deu
0402E3 CD 6C 00 04 0526*      call printString
0402E7 2A 73 04 04 0527*      ld hl,(ude)
0402EB CD 8C 00 04 0528*      call printHex24
0402EF CD 81 00 04 0529*      call printNewLine
0402F3             0530*  
0402F3 21 04 04 04 0531*      ld hl,str_ixu
0402F7 CD 6C 00 04 0532*      call printString
0402FB 2A 76 04 04 0533*      ld hl,(uix)
0402FF CD 8C 00 04 0534*      call printHex24
040303 CD 81 00 04 0535*      call printNewLine
040307             0536*  
040307 21 09 04 04 0537*      ld hl,str_iyu
04030B CD 6C 00 04 0538*      call printString
04030F 2A 79 04 04 0539*      ld hl,(uiy)
040313 CD 8C 00 04 0540*      call printHex24
040317 CD 81 00 04 0541*      call printNewLine
04031B             0542*  
04031B             0543*      ; call vsync
04031B             0544*  
04031B CD 81 00 04 0545*      call printNewLine
04031F             0546*  
04031F             0547*  ; check for right shift key and quit if pressed
04031F             0548*  	MOSCALL mos_getkbmap
04031F 3E 1E       0001*M 			LD	A, function
040321 5B CF       0002*M 			RST.L	08h
040323             0549*  @stayhere:
040323             0550*  ; 7 RightShift
040323 DD CB 00 76 0551*      bit 6,(ix+0)
040327 20 02       0552*      jr nz,@RightShift
040329 18 F8       0553*      jr @stayhere
04032B             0554*  @RightShift:
04032B DD CB 0E 86 0555*      res 0,(ix+14) ; debounce the key (hopefully)
04032F 3E 80       0556*      ld a,%10000000
040331 CD D6 06 04 0557*      call multiPurposeDelay
040335             0558*  
040335             0559*  ; restore everything
040335 2A 6D 04 04 0560*      ld hl, (uhl)
040339 ED 4B 70 04 0561*      ld bc, (ubc)
       04          
04033E ED 5B 73 04 0562*      ld de, (ude)
       04          
040343 DD 2A 76 04 0563*      ld ix, (uix)
       04          
040348 FD 2A 79 04 0564*      ld iy, (uiy)
       04          
04034D F1          0565*      pop af
04034E             0566*  ; all done
04034E C9          0567*      ret
04034F             0568*  
04034F             0569*  ; print registers to screen in hexidecimal format
04034F             0570*  ; inputs: none
04034F             0571*  ; outputs: values of every register printed to screen
04034F             0572*  ;    values of each register in global scratch memory
04034F             0573*  ; destroys: nothing
04034F             0574*  dumpRegistersHex:
04034F             0575*  ; store everything in scratch
04034F 22 6D 04 04 0576*      ld (uhl),hl
040353 ED 43 70 04 0577*      ld (ubc),bc
       04          
040358 ED 53 73 04 0578*      ld (ude),de
       04          
04035D DD 22 76 04 0579*      ld (uix),ix
       04          
040362 FD 22 79 04 0580*      ld (uiy),iy
       04          
040367 F5          0581*      push af ; fml
040368 E1          0582*      pop hl  ; thanks, zilog
040369 22 6A 04 04 0583*      ld (uaf),hl
04036D F5          0584*      push af ; dammit
04036E             0585*  
04036E             0586*  ; home the cursor
04036E             0587*      ; call vdu_home_cursor
04036E             0588*      ; call printNewLine
04036E             0589*  
04036E             0590*  ; print each register
04036E 21 F0 03 04 0591*      ld hl,str_afu
040372 CD 6C 00 04 0592*      call printString
040376 2A 6A 04 04 0593*      ld hl,(uaf)
04037A CD 8C 00 04 0594*      call printHex24
04037E             0595*      ; call printNewLine
04037E             0596*  
04037E 21 F5 03 04 0597*      ld hl,str_hlu
040382 CD 6C 00 04 0598*      call printString
040386 2A 6D 04 04 0599*      ld hl,(uhl)
04038A CD 8C 00 04 0600*      call printHex24
04038E             0601*      ; call printNewLine
04038E             0602*  
04038E 21 FA 03 04 0603*      ld hl,str_bcu
040392 CD 6C 00 04 0604*      call printString
040396 2A 70 04 04 0605*      ld hl,(ubc)
04039A CD 8C 00 04 0606*      call printHex24
04039E             0607*      ; call printNewLine
04039E             0608*  
04039E 21 FF 03 04 0609*      ld hl,str_deu
0403A2 CD 6C 00 04 0610*      call printString
0403A6 2A 73 04 04 0611*      ld hl,(ude)
0403AA CD 8C 00 04 0612*      call printHex24
0403AE             0613*      ; call printNewLine
0403AE             0614*  
0403AE 21 04 04 04 0615*      ld hl,str_ixu
0403B2 CD 6C 00 04 0616*      call printString
0403B6 2A 76 04 04 0617*      ld hl,(uix)
0403BA CD 8C 00 04 0618*      call printHex24
0403BE             0619*      ; call printNewLine
0403BE             0620*  
0403BE 21 09 04 04 0621*      ld hl,str_iyu
0403C2 CD 6C 00 04 0622*      call printString
0403C6 2A 79 04 04 0623*      ld hl,(uiy)
0403CA CD 8C 00 04 0624*      call printHex24
0403CE             0625*      ; call printNewLine
0403CE             0626*  
0403CE CD 8B 07 04 0627*      call vdu_vblank
0403D2             0628*  
0403D2 CD 81 00 04 0629*      call printNewLine
0403D6             0630*  ; restore everything
0403D6 2A 6D 04 04 0631*      ld hl, (uhl)
0403DA ED 4B 70 04 0632*      ld bc, (ubc)
       04          
0403DF ED 5B 73 04 0633*      ld de, (ude)
       04          
0403E4 DD 2A 76 04 0634*      ld ix, (uix)
       04          
0403E9 FD 2A 79 04 0635*      ld iy, (uiy)
       04          
0403EE F1          0636*      pop af
0403EF             0637*  ; all done
0403EF C9          0638*      ret
0403F0             0639*  
0403F0 20 61 66 3D 0640*  str_afu: db " af=",0
       00          
0403F5 20 68 6C 3D 0641*  str_hlu: db " hl=",0
       00          
0403FA 20 62 63 3D 0642*  str_bcu: db " bc=",0
       00          
0403FF 20 64 65 3D 0643*  str_deu: db " de=",0
       00          
040404 20 69 78 3D 0644*  str_ixu: db " ix=",0
       00          
040409 20 69 79 3D 0645*  str_iyu: db " iy=",0
       00          
04040E             0646*  
04040E             0647*  ; print udeuhl to screen in hexidecimal format
04040E             0648*  ; inputs: none
04040E             0649*  ; outputs: concatenated hexidecimal udeuhl
04040E             0650*  ; destroys: nothing
04040E             0651*  dumpUDEUHLHex:
04040E             0652*  ; store everything in scratch
04040E 22 6D 04 04 0653*      ld (uhl),hl
040412 ED 43 70 04 0654*      ld (ubc),bc
       04          
040417 ED 53 73 04 0655*      ld (ude),de
       04          
04041C DD 22 76 04 0656*      ld (uix),ix
       04          
040421 FD 22 79 04 0657*      ld (uiy),iy
       04          
040426 F5          0658*      push af
040427             0659*  
040427             0660*  ; print each register
040427             0661*  
040427 21 61 04 04 0662*      ld hl,str_udeuhl
04042B CD 6C 00 04 0663*      call printString
04042F 2A 73 04 04 0664*      ld hl,(ude)
040433 CD 8C 00 04 0665*      call printHex24
040437 3E 2E       0666*  	ld a,'.'	; print a dot to separate the values
040439 5B D7       0667*  	rst.lil 10h
04043B 2A 6D 04 04 0668*      ld hl,(uhl)
04043F CD 8C 00 04 0669*      call printHex24
040443 CD 81 00 04 0670*      call printNewLine
040447             0671*  
040447             0672*  ; restore everything
040447 2A 6D 04 04 0673*      ld hl, (uhl)
04044B ED 4B 70 04 0674*      ld bc, (ubc)
       04          
040450 ED 5B 73 04 0675*      ld de, (ude)
       04          
040455 DD 2A 76 04 0676*      ld ix, (uix)
       04          
04045A FD 2A 79 04 0677*      ld iy, (uiy)
       04          
04045F F1          0678*      pop af
040460             0679*  ; all done
040460 C9          0680*      ret
040461             0681*  
040461 75 64 65 2E 0682*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04046A             0683*  
04046A             0684*  ; global scratch memory for registers
04046A 00 00 00    0685*  uaf: dl 0
04046D 00 00 00    0686*  uhl: dl 0
040470 00 00 00    0687*  ubc: dl 0
040473 00 00 00    0688*  ude: dl 0
040476 00 00 00    0689*  uix: dl 0
040479 00 00 00    0690*  uiy: dl 0
04047C 00 00 00    0691*  usp: dl 0
04047F 00 00 00    0692*  upc: dl 0
040482             0693*  
040482             0694*  ; inputs: whatever is in the flags register
040482             0695*  ; outputs: binary representation of flags
040482             0696*  ;          with a header so we know which is what
040482             0697*  ; destroys: nothing
040482             0698*  ; preserves: everything
040482             0699*  dumpFlags:
040482             0700*  ; first we curse zilog for not giving direct access to flags
040482 F5          0701*      push af ; this is so we can send it back unharmed
040483 F5          0702*      push af ; this is so we can pop it to hl
040484             0703*  ; store everything in scratch
040484 22 6D 04 04 0704*      ld (uhl),hl
040488 ED 43 70 04 0705*      ld (ubc),bc
       04          
04048D ED 53 73 04 0706*      ld (ude),de
       04          
040492 DD 22 76 04 0707*      ld (uix),ix
       04          
040497 FD 22 79 04 0708*      ld (uiy),iy
       04          
04049C             0709*  ; next we print the header
04049C 21 C8 04 04 0710*      ld hl,@header
0404A0 CD 6C 00 04 0711*      call printString
0404A4 E1          0712*      pop hl ; flags are now in l
0404A5 7D          0713*      ld a,l ; flags are now in a
0404A6 CD 36 02 04 0714*      call printBin8
0404AA CD 81 00 04 0715*  	call printNewLine
0404AE             0716*  ; restore everything
0404AE 2A 6D 04 04 0717*      ld hl, (uhl)
0404B2 ED 4B 70 04 0718*      ld bc, (ubc)
       04          
0404B7 ED 5B 73 04 0719*      ld de, (ude)
       04          
0404BC DD 2A 76 04 0720*      ld ix, (uix)
       04          
0404C1 FD 2A 79 04 0721*      ld iy, (uiy)
       04          
0404C6 F1          0722*      pop af ; send her home the way she came
0404C7 C9          0723*      ret
0404C8             0724*  ; Bit 7 (S): Sign flag
0404C8             0725*  ; Bit 6 (Z): Zero flag
0404C8             0726*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0404C8             0727*  ; Bit 4 (H): Half Carry flag
0404C8             0728*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0404C8             0729*  ; Bit 2 (PV): Parity/Overflow flag
0404C8             0730*  ; Bit 1 (N): Subtract flag
0404C8             0731*  ; Bit 0 (C): Carry flag
0404C8 53 5A 78 48 0732*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0404D3             0733*  
0404D3             0734*  ; set all the bits in the flag register
0404D3             0735*  ; more of an academic exercise than anything useful
0404D3             0736*  ; inputs; none
0404D3             0737*  ; outputs; a=0,f=255
0404D3             0738*  ; destroys: flags, hl
0404D3             0739*  ; preserves: a, because why not
0404D3             0740*  setAllFlags:
0404D3 21 FF 00 00 0741*      ld hl,255
0404D7 67          0742*      ld h,a ; four cycles to preserve a is cheap
0404D8 E5          0743*      push hl
0404D9 F1          0744*      pop af
0404DA C9          0745*      ret
0404DB             0746*  
0404DB             0747*  ; reset all the bits in the flag register
0404DB             0748*  ; unlike its inverse counterpart, this may actually be useful
0404DB             0749*  ; inputs; none
0404DB             0750*  ; outputs; a=0,f=0
0404DB             0751*  ; destroys: flags, hl
0404DB             0752*  ; preserves: a, because why not
0404DB             0753*  resetAllFlags:
0404DB 21 00 00 00 0754*      ld hl,0
0404DF 67          0755*      ld h,a ; four cycles to preserve a is cheap
0404E0 E5          0756*      push hl
0404E1 F1          0757*      pop af
0404E2 C9          0758*      ret
0404E3             0759*  
0404E3             0760*  ; wait until user presses a key
0404E3             0761*  ; inputs: none
0404E3             0762*  ; outputs: none
0404E3             0763*  ; destroys: af,ix
0404E3             0764*  waitKeypress:
0404E3             0765*      MOSCALL mos_sysvars
0404E3 3E 08       0001*M 			LD	A, function
0404E5 5B CF       0002*M 			RST.L	08h
0404E7 AF          0766*      xor a ; zero out any prior keypresses
0404E8 DD 77 05    0767*      ld (ix+sysvar_keyascii),a
0404EB             0768*  @loop:
0404EB DD 7E 05    0769*      ld a,(ix+sysvar_keyascii)
0404EE A7          0770*      and a
0404EF C0          0771*      ret nz
0404F0 18 F9       0772*      jr @loop
0404F2             0773*  
0404F2             0774*  
0404F2             0775*  ; print bytes from an address to the screen in hexidecimal format
0404F2             0776*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0404F2             0777*  ; outputs: values of each byte printed to screen separated by spaces
0404F2             0778*  ; destroys: nothing
0404F2             0779*  dumpMemoryHex:
0404F2             0780*  ; save registers to the stack
0404F2 C5          0781*      push bc
0404F3 E5          0782*      push hl
0404F4 F5          0783*      push af
0404F5             0784*  
0404F5             0785*  ; print the address and separator
0404F5 CD 8C 00 04 0786*      call printHex24
0404F9 3E 3A       0787*      ld a,':'
0404FB 5B D7       0788*      rst.lil 10h
0404FD 3E 20       0789*      ld a,' '
0404FF 5B D7       0790*      rst.lil 10h
040501             0791*  
040501             0792*  ; set b to be our loop counter
040501 F1          0793*      pop af
040502 47          0794*      ld b,a
040503 E1          0795*      pop hl
040504 E5          0796*      push hl
040505 F5          0797*      push af
040506             0798*  @loop:
040506             0799*  ; print the byte
040506 7E          0800*      ld a,(hl)
040507 CD 9A 00 04 0801*      call printHex8
04050B             0802*  ; print a space
04050B 3E 20       0803*      ld a,' '
04050D 5B D7       0804*      rst.lil 10h
04050F 23          0805*      inc hl
040510 10 F4       0806*      djnz @loop
040512             0807*      ; call printNewLine
040512             0808*  
040512             0809*  ; restore everything
040512 F1          0810*      pop af
040513 E1          0811*      pop hl
040514 C1          0812*      pop bc
040515             0813*  
040515             0814*  ; all done
040515 C9          0815*      ret
040516             0816*  
040516             0817*  
040516             0818*  ; print bytes from an address to the screen in binary format
040516             0819*  ; inputs: hl = address of first byte to print, a = number of bytes to print
040516             0820*  ; outputs: values of each byte printed to screen separated by spaces
040516             0821*  ; destroys: nothing
040516             0822*  dumpMemoryBin:
040516             0823*  ; save all registers to the stack
040516 F5          0824*      push af
040517 C5          0825*      push bc
040518 D5          0826*      push de
040519 E5          0827*      push hl
04051A DD E5       0828*      push ix
04051C FD E5       0829*      push iy
04051E             0830*  
04051E             0831*  ; set b to be our loop counter
04051E 47          0832*      ld b,a
04051F             0833*  @loop:
04051F             0834*  ; print the byte
04051F 7E          0835*      ld a,(hl)
040520 E5          0836*      push hl
040521 C5          0837*      push bc
040522 CD 36 02 04 0838*      call printBin8
040526 C1          0839*      pop bc
040527             0840*  ; print a space
040527 3E 20       0841*      ld a,' '
040529 5B D7       0842*      rst.lil 10h
04052B E1          0843*      pop hl
04052C 23          0844*      inc hl
04052D 10 F0       0845*      djnz @loop
04052F CD 81 00 04 0846*      call printNewLine
040533             0847*  
040533             0848*  ; restore everything
040533 FD E1       0849*      pop iy
040535 DD E1       0850*      pop ix
040537 E1          0851*      pop hl
040538 D1          0852*      pop de
040539 C1          0853*      pop bc
04053A F1          0854*      pop af
04053B             0855*  ; all done
04053B C9          0856*      ret
04053C             0857*  
04053C             0858*  ; print bytes from an address to the screen in binary format
04053C             0859*  ; with the bits of each byte in reverse order (lsb first)
04053C             0860*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04053C             0861*  ; outputs: values of each byte printed to screen separated by spaces
04053C             0862*  ; destroys: nothing
04053C             0863*  dumpMemoryBinRev:
04053C             0864*  ; save all registers to the stack
04053C F5          0865*      push af
04053D C5          0866*      push bc
04053E D5          0867*      push de
04053F E5          0868*      push hl
040540 DD E5       0869*      push ix
040542 FD E5       0870*      push iy
040544             0871*  
040544             0872*  ; set b to be our loop counter
040544 47          0873*      ld b,a
040545             0874*  @loop:
040545             0875*  ; print the byte
040545 7E          0876*      ld a,(hl)
040546 E5          0877*      push hl
040547 C5          0878*      push bc
040548 CD 5B 02 04 0879*      call printBin8Rev
04054C C1          0880*      pop bc
04054D             0881*  ; print a space
04054D 3E 20       0882*      ld a,' '
04054F 5B D7       0883*      rst.lil 10h
040551 E1          0884*      pop hl
040552 23          0885*      inc hl
040553 10 F0       0886*      djnz @loop
040555 CD 81 00 04 0887*      call printNewLine
040559             0888*  
040559             0889*  ; restore everything
040559 FD E1       0890*      pop iy
04055B DD E1       0891*      pop ix
04055D E1          0892*      pop hl
04055E D1          0893*      pop de
04055F C1          0894*      pop bc
040560 F1          0895*      pop af
040561             0896*  ; all done
040561 C9          0897*      ret
040562             0034       include "files.inc"
040562             0001*  ; load to onboard 8k sram
040562             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
040562             0035       include "timer.inc"
040562             0001*  ; Table 32. Timer Control Registers
040562             0002*  ; this constant is the base address of the timer control registers
040562             0003*  ; each timer takes three bytes:
040562             0004*  ;   0: control register
040562             0005*  ;   1: low byte of timer reset value
040562             0006*  ;   2: high byte of timer reset value
040562             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
040562             0008*  ; which correctly force the high and upper bytes of the address bus to zero
040562             0009*  TMR_CTL:     equ 80h
040562             0010*  
040562             0011*  ; Timer Control Register Bit Definitions
040562             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
040562             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
040562             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
040562             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
040562             0016*                              ; the TMRx_CTL register is read.
040562             0017*  
040562             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
040562             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
040562             0020*  
040562             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
040562             0022*                              ;  0,and counting stops when the end-of-count value is reached.
040562             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
040562             0024*                              ; written to the counter when the end-of-count value is reached.
040562             0025*  
040562             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
040562             0027*  CLK_DIV_256:  equ %00001100 ;
040562             0028*  CLK_DIV_64:   equ %00001000 ;
040562             0029*  CLK_DIV_16:   equ %00000100 ;
040562             0030*  CLK_DIV_4:    equ %00000000 ;
040562             0031*  
040562             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
040562             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
040562             0034*                              ; When a 1 is written to this bit,the values in the reload registers
040562             0035*                              ;  are loaded into the downcounter when the timer restarts. The
040562             0036*                              ; programmer must ensure that this bit is set to 1 each time
040562             0037*                              ; SINGLE-PASS mode is used.
040562             0038*  
040562             0039*  ; disable/enable the programmable reload timer
040562             0040*  PRT_EN_0:     equ %00000000 ;
040562             0041*  PRT_EN_1:     equ %00000001 ;
040562             0042*  
040562             0043*  ; Table 37. Timer Input Source Select Register
040562             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
040562             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
040562             0046*  ;   00: System clock / CLK_DIV
040562             0047*  ;   01: RTC / CLK_DIV
040562             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
040562             0049*  ;   10: GPIO port B pin 1.
040562             0050*  ;   11: GPIO port B pin 1.
040562             0051*  TMR_ISS:   equ 92h ; register address
040562             0052*  
040562             0053*  ; Table 51. Real-Time Clock Control Register
040562             0054*  RTC_CTRL: equ EDh ; register address
040562             0055*  
040562             0056*  ; alarm interrupt disable/enable
040562             0057*  RTC_ALARM_0:    equ %00000000
040562             0058*  RTC_ALARM_1:    equ %10000000
040562             0059*  
040562             0060*  ; interrupt on alarm disable/enable
040562             0061*  RTC_INT_ENT_0:  equ %00000000
040562             0062*  RTC_INT_ENT_1:  equ %01000000
040562             0063*  
040562             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
040562             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
040562             0066*  
040562             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
040562             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
040562             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
040562             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
040562             0071*  
040562             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
040562             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
040562             0074*  
040562             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
040562             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
040562             0077*  
040562             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
040562             0079*                                  ; RTC counter is enabled.
040562             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
040562             0081*                                  ; RTC counter is disabled.
040562             0082*  
040562             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
040562             0084*  
040562             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
040562             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
040562 00 00 00    0087*  prt_reload: dl 0x000000
040565             0088*  
040565             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
040565             0090*  ; ;          de = number PRT interrupts during test interval
040565             0091*  ; prt_calibrate:
040565             0092*  ;     call vdu_vblank
040565             0093*  ; ; set a MOS timer
040565             0094*  ;     ld hl,120*1 ; 1 second
040565             0095*  ;     ld iy,tmr_test
040565             0096*  ;     call tmr_set
040565             0097*  ; ; set a PRT timer
040565             0098*  ;     ; ld hl,prt_reload_hardware
040565             0099*  ;     ; ld hl,prt_reload_emulator
040565             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
040565             0101*  ;     ld (prt_reload),hl
040565             0102*  ;     call prt_set
040565             0103*  ; @loop:
040565             0104*  ; ; check time remaining on MOS timer
040565             0105*  ;     call tmr_get
040565             0106*  ;     jp z,@done ; time expired,so quit
040565             0107*  ;     jp m,@done ; time past expiration (negative),so quit
040565             0108*  ;     jr @loop
040565             0109*  ; @done:
040565             0110*  ;     ld de,(prt_irq_counter)
040565             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
040565             0112*  ;     ld (prt_reload),bc
040565             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
040565             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
040565             0115*  ;     ld (is_emulator),a
040565             0116*  ;     sbc hl,de
040565             0117*  ;     ld hl,on_hardware ; default message for running on hardware
040565             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
040565             0119*  ;     ret m ; negative result means we're on hardware
040565             0120*  ;     inc a ; we're on emulator
040565             0121*  ;     ld (is_emulator),a
040565             0122*  ;     ld bc,prt_reload_emulator
040565             0123*  ;     ld (prt_reload),bc
040565             0124*  ;     ld hl,on_emulator
040565             0125*  ;     ret
040565             0126*  
040565             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
040565             0128*  
040565             0129*  ; set PRT timer
040565             0130*  prt_set:
040565 21 00 00 00 0131*      ld hl,0
040569 22 B3 05 04 0132*      ld (prt_irq_counter),hl
04056D 2A 62 05 04 0133*      ld hl,(prt_reload)
040571 ED 29 84    0134*      out0 ($84),l
040574 ED 21 85    0135*  	out0 ($85),h
040577             0136*  ; disable timer
040577 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
040579 ED 39 83    0138*  	out0 ($83),a
04057C             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
04057C 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
04057E ED 39 83    0141*  	out0 ($83),a
040581 C9          0142*      ret
040582             0143*  
040582             0144*  ; ===============================================
040582             0145*  ; PRT Timer Interrupt Handling
040582             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
040582             0147*  ; -----------------------------------------------
040582             0148*  prt_irq_init:
040582             0149*      ; set up interrupt vector table 2
040582 21 00 00 00 0150*  	ld hl,0
040586 3A 0C 01 00 0151*  	ld a,($10c)
04058A 6F          0152*  	ld l,a
04058B 3A 0D 01 00 0153*  	ld a,($10d)
04058F 67          0154*  	ld h,a
040590             0155*  
040590             0156*  	; skip over CALL ($c3)
040590 23          0157*  	inc hl
040591             0158*  	; load address of jump into vector table 2 (in ram)
040591 ED 27       0159*  	ld hl,(hl)
040593             0160*  
040593             0161*  	; write CALL prt_irq_handler to vector table 2
040593 3E C3       0162*  	ld a,$c3
040595 77          0163*  	ld (hl),a
040596 23          0164*  	inc hl
040597 11 9E 05 04 0165*  	ld de,prt_irq_handler
04059B ED 1F       0166*  	ld (hl),de
04059D             0167*  
04059D C9          0168*      ret
04059E             0169*  
04059E             0170*  prt_irq_handler:
04059E F3          0171*  	di
04059F F5          0172*  	push af
0405A0 E5          0173*      push hl
0405A1 ED 38 83    0174*  	in0 a,($83)
0405A4 2A B3 05 04 0175*  	ld hl,(prt_irq_counter)
0405A8 23          0176*  	inc hl
0405A9 22 B3 05 04 0177*  	ld (prt_irq_counter),hl
0405AD E1          0178*      pop hl
0405AE F1          0179*  	pop af
0405AF FB          0180*  	ei
0405B0 5B ED 4D    0181*  	reti.l
0405B3             0182*  
0405B3             0183*  prt_irq_counter:
0405B3 00 00 00    0184*  	.dl 0
0405B6             0185*  prt_irq_counter_saved:
0405B6 00 00 00    0186*      .dl 0
0405B9             0187*  
0405B9             0188*  prt_loop_reset:
0405B9 E5          0189*      push hl
0405BA 21 00 00 00 0190*  	ld hl,0
0405BE 22 B3 05 04 0191*  	ld (prt_irq_counter),hl
0405C2 22 24 06 04 0192*      ld (prt_loop_counter),hl
0405C6 22 27 06 04 0193*      ld (prt_loops),hl
0405CA CD 65 05 04 0194*      call prt_set
0405CE E1          0195*      pop hl
0405CF C9          0196*      ret
0405D0             0197*  
0405D0             0198*  prt_loop_start:
0405D0 E5          0199*      push hl
0405D1 21 00 00 00 0200*  	ld hl,0
0405D5 22 B3 05 04 0201*  	ld (prt_irq_counter),hl
0405D9 E1          0202*      pop hl
0405DA C9          0203*      ret
0405DB             0204*  
0405DB             0205*  prt_loop_stop:
0405DB E5          0206*      push hl
0405DC D5          0207*      push de
0405DD 2A B3 05 04 0208*      ld hl,(prt_irq_counter)
0405E1 ED 5B 24 06 0209*      ld de,(prt_loop_counter)
       04          
0405E6 19          0210*      add hl,de
0405E7 22 24 06 04 0211*      ld (prt_loop_counter),hl
0405EB 21 00 00 00 0212*      ld hl,0
0405EF 22 B3 05 04 0213*      ld (prt_irq_counter),hl
0405F3 2A 27 06 04 0214*      ld hl,(prt_loops)
0405F7 23          0215*      inc hl
0405F8 22 27 06 04 0216*      ld (prt_loops),hl
0405FC D1          0217*      pop de
0405FD E1          0218*      pop hl
0405FE C9          0219*      ret
0405FF             0220*  
0405FF             0221*  ; inputs: bc = y,x text coordinates to print
0405FF             0222*  prt_loop_print:
0405FF F5          0223*      push af
040600 E5          0224*      push hl
040601 C5          0225*      push bc
040602 D5          0226*      push de
040603 DD E5       0227*      push ix
040605 FD E5       0228*      push iy
040607 CD 1C 07 04 0229*      call vdu_move_cursor
04060B             0230*  
04060B 2A 24 06 04 0231*      ld hl,(prt_loop_counter)
04060F CD 24 01 04 0232*      call printDec
040613             0233*  
040613 2A 27 06 04 0234*      ld hl,(prt_loops)
040617 CD 24 01 04 0235*      call printDec
04061B             0236*  
04061B FD E1       0237*      pop iy
04061D DD E1       0238*      pop ix
04061F D1          0239*      pop de
040620 C1          0240*      pop bc
040621 E1          0241*      pop hl
040622 F1          0242*      pop af
040623 C9          0243*      ret
040624             0244*  
040624             0245*  prt_loop_counter:
040624 00 00 00    0246*      .dl 0
040627             0247*  prt_loops:
040627 00 00 00    0248*      .dl 0
04062A             0249*  
04062A             0250*  ; ===============================================
04062A             0251*  ; Timer functions
04062A             0252*  ; -----------------------------------------------
04062A             0253*  ; set a countdown timer
04062A             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04062A             0255*  ; returns: hl = current time
04062A             0256*  tmr_set:
04062A FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
04062D             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
04062D 3E 08       0001*M 			LD	A, function
04062F 5B CF       0002*M 			RST.L	08h
040631 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
040634 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
040637 C9          0261*      ret
040638             0262*  
040638             0263*  ; gets time remaining on a countdown timer
040638             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040638             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
040638             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
040638             0267*  tmr_get:
040638             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
040638 3E 08       0001*M 			LD	A, function
04063A 5B CF       0002*M 			RST.L	08h
04063C DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
04063F FD 27 00    0270*      ld hl,(iy+0)            ; get start time
040642 AF          0271*      xor a                   ; clear carry
040643 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
040645 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
040648 AF          0274*      xor a                   ; clear carry
040649 ED 5A       0275*      adc hl,de               ; hl = time remaining
04064B             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04064B C9          0277*      ret
04064C             0278*  
04064C 00 00 00    0279*  timestamp_now: dl 0
04064F 00 00 00    0280*  timestamp_old: dl 0
040652 00 00 00    0281*  timestamp_chg: dl 0
040655             0282*  
040655             0283*  ; update the global timestamp from the system clock
040655             0284*  ; inputs: none
040655             0285*  ; returns: hl = time elapsed in 1/120ths of a second
040655             0286*  ;          de = current time
040655             0287*  ;          ix = pointer to syvars table
040655             0288*  ; destroys: af,hl,de,ix
040655             0289*  timestamp_tick:
040655 ED 5B 4C 06 0290*      ld de,(timestamp_now)   ; get previous time
       04          
04065A ED 53 4F 06 0291*      ld (timestamp_old),de   ; save previous time
       04          
04065F             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
04065F 3E 08       0001*M 			LD	A, function
040661 5B CF       0002*M 			RST.L	08h
040663 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
040666 22 4C 06 04 0294*      ld (timestamp_now),hl   ; save current time
04066A AF          0295*      xor a                   ; clear carry
04066B ED 52       0296*      sbc hl,de               ; hl = time elapsed
04066D 22 52 06 04 0297*      ld (timestamp_chg),hl   ; save elapsed time
040671 C9          0298*      ret
040672             0299*  
040672             0300*  ; set a countdown timer
040672             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
040672             0302*  ; requires: timestamp_tick to be called at least once before this function
040672             0303*  ; returns: hl = current time
040672             0304*  ; destroys: hl
040672             0305*  timestamp_tmr_set:
040672 FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
040675 2A 4C 06 04 0307*      ld hl,(timestamp_now)   ; get current timestamp
040679 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
04067C C9          0309*      ret
04067D             0310*  
04067D             0311*  ; gets time remaining on a countdown timer following the global timestamp
04067D             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
04067D             0313*  ; requires: timestamp_tick to be called at least once before this function
04067D             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
04067D             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
04067D             0316*  ; destroys: af,hl,de
04067D             0317*  timestamp_tmr_get:
04067D ED 5B 4C 06 0318*      ld de,(timestamp_now)   ; get current timestamp
       04          
040682 FD 27 00    0319*      ld hl,(iy+0)            ; get start time
040685 AF          0320*      xor a                   ; clear carry
040686 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
040688 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
04068B AF          0323*      xor a                   ; clear carry
04068C ED 5A       0324*      adc hl,de               ; hl = time remaining
04068E             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
04068E C9          0326*      ret
04068F             0327*  
04068F             0328*  ; main loop timer functions
04068F             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
040695             0330*  
040695             0331*  ; set a countdown timer for the main loop using the timestamp timer
040695             0332*  ; inputs: hl = time to set in 1/120ths of a second
040695             0333*  ; returns: hl = current time
040695             0334*  ; destroys: af,hl,de,ix,iy
040695             0335*  tmr_main_loop_set:
040695 FD 21 8F 06 0336*      ld iy,tmr_main_loop
       04          
04069A FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
04069D CD 55 06 04 0338*      call timestamp_tick
0406A1 2A 4C 06 04 0339*      ld hl,(timestamp_now)   ; get current timestamp
0406A5 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0406A8 C9          0341*      ret
0406A9             0342*  
0406A9             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0406A9             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0406A9             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0406A9             0346*  ; destroys: af,hl,de,ix,iy
0406A9             0347*  tmr_main_loop_get:
0406A9 CD 55 06 04 0348*      call timestamp_tick
0406AD FD 21 8F 06 0349*      ld iy,tmr_main_loop
       04          
0406B2 CD 7D 06 04 0350*      call timestamp_tmr_get
0406B6 C9          0351*      ret
0406B7             0352*  
0406B7             0353*  ; set a stopwatch
0406B7             0354*  ; returns: hl = start time
0406B7             0355*  ; destroys: hl,ix
0406B7             0356*  stopwatch_set:
0406B7             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0406B7 3E 08       0001*M 			LD	A, function
0406B9 5B CF       0002*M 			RST.L	08h
0406BB DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0406BE 22 D3 06 04 0359*      ld (stopwatch_started),hl            ; set start time
0406C2 C9          0360*      ret
0406C3             0361*  
0406C3             0362*  ; gets time elapsed on a stopwatch
0406C3             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0406C3             0364*  ; destroys: af,hl,de,ix
0406C3             0365*  stopwatch_get:
0406C3             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0406C3 3E 08       0001*M 			LD	A, function
0406C5 5B CF       0002*M 			RST.L	08h
0406C7 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0406CA ED 5B D3 06 0368*      ld de,(stopwatch_started)            ; get start time
       04          
0406CF AF          0369*      xor a                   ; clear carry
0406D0 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0406D2 C9          0371*      ret
0406D3             0372*  
0406D3             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0406D6             0374*  
0406D6             0375*  ; ------------------
0406D6             0376*  ; delay routine
0406D6             0377*  ; Author: Richard Turrnidge
0406D6             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0406D6             0379*  ; routine waits a fixed time,then returns
0406D6             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0406D6             0381*  ; eg. ld A,00000100b
0406D6             0382*  
0406D6             0383*  multiPurposeDelay:
0406D6 F5          0384*      push af
0406D7 C5          0385*      push bc
0406D8 DD E5       0386*      push ix
0406DA 47          0387*      ld b,a
0406DB 3E 08       0388*      ld a,$08
0406DD 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0406DF             0390*  
0406DF             0391*  waitLoop:
0406DF             0392*  
0406DF DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0406E2             0394*  
0406E2             0395*                                  ;   we check if bit set is same as last time we checked.
0406E2             0396*                                  ;   bit 0 - don't use
0406E2             0397*                                  ;   bit 1 - changes 64 times per second
0406E2             0398*                                  ;   bit 2 - changes 32 times per second
0406E2             0399*                                  ;   bit 3 - changes 16 times per second
0406E2             0400*  
0406E2             0401*                                  ;   bit 4 - changes 8 times per second
0406E2             0402*                                  ;   bit 5 - changes 4 times per second
0406E2             0403*                                  ;   bit 6 - changes 2 times per second
0406E2             0404*                                  ;   bit 7 - changes 1 times per second
0406E2 A0          0405*      and b
0406E3 4F          0406*      ld c,a
0406E4 3A F5 06 04 0407*      ld a,(oldTimeStamp)
0406E8 B9          0408*      cp c                        ; is A same as last value?
0406E9 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0406EB 79          0410*      ld a,c
0406EC 32 F5 06 04 0411*      ld (oldTimeStamp),a        ; set new value
0406F0             0412*  
0406F0 DD E1       0413*      pop ix
0406F2 C1          0414*      pop bc
0406F3 F1          0415*      pop af
0406F4 C9          0416*      ret
0406F5             0417*  
0406F5 00          0418*  oldTimeStamp:   .db 00h
0406F6             0036       include "vdu.inc"
0406F6             0001*  
0406F6             0002*  ; VDU 30: Home cursor
0406F6             0003*  vdu_home_cursor:
0406F6 3E 1E       0004*      ld a,30
0406F8 5B D7       0005*  	rst.lil $10
0406FA C9          0006*  	ret
0406FB             0007*  
0406FB             0008*  cursor_on:
0406FB 21 06 07 04 0009*  	ld hl,@cmd
0406FF 01 03 00 00 0010*  	ld bc,@end-@cmd
040703 5B DF       0011*  	rst.lil $18
040705 C9          0012*  	ret
040706             0013*  @cmd:
040706 17 01 01    0014*  	db 23,1,1
040709             0015*  @end:
040709             0016*  
040709             0017*  cursor_off:
040709 21 14 07 04 0018*  	ld hl,@cmd
04070D 01 03 00 00 0019*  	ld bc,@end-@cmd
040711 5B DF       0020*  	rst.lil $18
040713 C9          0021*  	ret
040714             0022*  @cmd:
040714 17 01 00    0023*  	db 23,1,0
040717             0024*  @end:
040717             0025*  
040717             0026*  ; VDU 9: Move cursor forward one character
040717             0027*  vdu_cursor_forward:
040717 3E 09       0028*      ld a,9
040719 5B D7       0029*  	rst.lil $10
04071B C9          0030*  	ret
04071C             0031*  
04071C             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04071C             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
04071C             0034*  vdu_move_cursor:
04071C ED 43 2D 07 0035*      ld (@x0),bc
       04          
040721 21 2C 07 04 0036*  	ld hl,@cmd
040725 01 03 00 00 0037*  	ld bc,@end-@cmd
040729 5B DF       0038*  	rst.lil $18
04072B C9          0039*  	ret
04072C 1F          0040*  @cmd: 	db 31
04072D 00          0041*  @x0:	db 0
04072E 00          0042*  @y0: 	db 0
04072F 00          0043*  @end: 	db 0 ; padding
040730             0044*  
040730             0045*  ; VDU 12: Clear text area (CLS)
040730             0046*  vdu_cls:
040730 3E 0C       0047*      ld a,12
040732 5B D7       0048*  	rst.lil $10
040734 C9          0049*  	ret
040735             0050*  
040735             0051*  vdu_flip:
040735 21 40 07 04 0052*  	ld hl,@cmd
040739 01 03 00 00 0053*  	ld bc,@end-@cmd
04073D 5B DF       0054*  	rst.lil $18
04073F C9          0055*  	ret
040740 17 00 C3    0056*  @cmd: db 23,0,0xC3
040743             0057*  @end:
040743             0058*  
040743             0059*  ; VDU 16: Clear graphics area (CLG)
040743             0060*  vdu_clg:
040743 3E 10       0061*      ld a,16
040745 5B D7       0062*  	rst.lil $10
040747 C9          0063*  	ret
040748             0064*  
040748             0065*  ; COLOUR MODES
040748             0066*  ; Mode	Effect
040748             0067*  ; 0	Set on-screen pixel to target colour value
040748             0068*  ; 1	OR value with the on-screen pixel
040748             0069*  ; 2	AND value with the on-screen pixel
040748             0070*  ; 3	XOR value with the on-screen pixel
040748             0071*  ; 4	Invert the on-screen pixel
040748             0072*  ; 5	No operation
040748             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
040748             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
040748             0075*  
040748             0076*  ; VDU 17, colour: Define text colour (COLOUR)
040748             0077*  vdu_colour_text:
040748 32 58 07 04 0078*  	ld (@arg),a
04074C 21 57 07 04 0079*  	ld hl,@cmd
040750 01 02 00 00 0080*  	ld bc,@end-@cmd
040754 5B DF       0081*  	rst.lil $18
040756 C9          0082*  	ret
040757 11          0083*  @cmd: db 17
040758 00          0084*  @arg: db 0
040759             0085*  @end:
040759             0086*  
040759             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
040759             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
040759             0089*  vdu_gcol:
040759 32 6E 07 04 0090*  	ld (@mode),a
04075D 79          0091*      ld a,c
04075E 32 6F 07 04 0092*      ld (@col),a
040762 21 6D 07 04 0093*  	ld hl,@cmd
040766 01 03 00 00 0094*  	ld bc,@end-@cmd
04076A 5B DF       0095*  	rst.lil $18
04076C C9          0096*  	ret
04076D 12          0097*  @cmd:  db 18
04076E 00          0098*  @mode: db 0
04076F 00          0099*  @col:  db 0
040770             0100*  @end:
040770             0101*  
040770             0102*  
040770             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
040770             0104*  ; MIND THE LITTLE-ENDIANESS
040770             0105*  ; inputs: c=left,b=bottom,e=right,d=top
040770             0106*  ; outputs; nothing
040770             0107*  ; destroys: a might make it out alive
040770             0108*  vdu_set_txt_viewport:
040770 ED 43 86 07 0109*      ld (@lb),bc
       04          
040775 ED 53 88 07 0110*  	ld (@rt),de
       04          
04077A 21 85 07 04 0111*  	ld hl,@cmd
04077E 01 05 00 00 0112*  	ld bc,@end-@cmd
040782 5B DF       0113*  	rst.lil $18
040784 C9          0114*  	ret
040785 1C          0115*  @cmd:   db 28 ; set text viewport command
040786 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
040788 00 00       0117*  @rt: 	dw 0x0000 ; set by de
04078A 00          0118*  @end:   db 0x00	  ; padding
04078B             0119*  
04078B             0120*  ; Wait for VBLANK interrupt
04078B             0121*  vdu_vblank:
04078B DD E5       0122*      PUSH 	IX
04078D             0123*  	MOSCALL	mos_sysvars
04078D 3E 08       0001*M 			LD	A, function
04078F 5B CF       0002*M 			RST.L	08h
040791 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
040794             0125*  @wait:
040794 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
040797 28 FB       0127*      JR	Z, @wait
040799 DD E1       0128*      POP	IX
04079B C9          0129*      RET
04079C             0130*  
04079C             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
04079C             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
04079C             0133*  ; 	because we have turned off logical screen scaling
04079C             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
04079C             0135*  ; outputs; nothing
04079C             0136*  ; destroys: a might make it out alive
04079C             0137*  vdu_set_gfx_viewport:
04079C ED 43 BC 07 0138*      ld (@x0),bc
       04          
0407A1 FD 22 BE 07 0139*      ld (@y1),iy
       04          
0407A6 DD 22 C0 07 0140*  	ld (@x1),ix
       04          
0407AB ED 53 C2 07 0141*  	ld (@y0),de
       04          
0407B0 21 BB 07 04 0142*  	ld hl,@cmd
0407B4 01 09 00 00 0143*  	ld bc,@end-@cmd
0407B8 5B DF       0144*  	rst.lil $18
0407BA C9          0145*  	ret
0407BB 18          0146*  @cmd:   db 24 ; set graphics viewport command
0407BC 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0407BE 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0407C0 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0407C2 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0407C4 00          0151*  @end:   db 0x00	  ; padding
0407C5             0152*  
0407C5             0153*  ; SCREEN MODES
0407C5             0154*  ; ===============================
0407C5             0155*  ; Mode  Horz  Vert  Cols  Refresh
0407C5             0156*  ; ---   ----  ----  ----  -------
0407C5             0157*  ; 11    320   240   2     60hz
0407C5             0158*  ; 139   320   240   2     60hz
0407C5             0159*  ; 23    512   384   2     60hz
0407C5             0160*  ; 151   512   384   2     60hz
0407C5             0161*  ; 6     640   240   2     60hz
0407C5             0162*  ; 134   640   240   2     60hz
0407C5             0163*  ; 2     640   480   2     60hz
0407C5             0164*  ; 130   640   480   2     60hz
0407C5             0165*  ; 17    800   600   2     60hz
0407C5             0166*  ; 145   800   600   2     60hz
0407C5             0167*  ; 18    1024  768   2     60hz
0407C5             0168*  ; 146   1024  768   2     60hz
0407C5             0169*  ; ---   ----  ----  ----  -------
0407C5             0170*  ; 10    320   240   4     60hz
0407C5             0171*  ; 138   320   240   4     60hz
0407C5             0172*  ; 22    512   384   4     60hz
0407C5             0173*  ; 150   512   384   4     60hz
0407C5             0174*  ; 5     640   240   4     60hz
0407C5             0175*  ; 133   640   240   4     60hz
0407C5             0176*  ; 1     640   480   4     60hz
0407C5             0177*  ; 129   640   480   4     60hz
0407C5             0178*  ; 16    800   600   4     60hz
0407C5             0179*  ; 19    1024  768   4     60hz
0407C5             0180*  ; ---   ----  ----  ----  -------
0407C5             0181*  ; 9     320   240   16    60hz
0407C5             0182*  ; 137   320   240   16    60hz
0407C5             0183*  ; 21    512   384   16    60hz
0407C5             0184*  ; 149   512   384   16    60hz
0407C5             0185*  ; 4     640   240   16    60hz
0407C5             0186*  ; 132   640   240   16    60hz
0407C5             0187*  ; 0     640   480   16    60hz
0407C5             0188*  ; 7     n/a   n/a   16    60hz
0407C5             0189*  ; ---   ----  ----  ----  -------
0407C5             0190*  ; 8     320   240   64    60hz
0407C5             0191*  ; 136   320   240   64    60hz
0407C5             0192*  ; 20    512   384   64    60hz
0407C5             0193*  ; 3     640   240   64    60hz
0407C5             0194*  ; ---   ----  ----  ----  -------
0407C5             0195*  vdu_set_screen_mode:
0407C5 32 D5 07 04 0196*  	ld (@arg),a
0407C9 21 D4 07 04 0197*  	ld hl,@cmd
0407CD 01 02 00 00 0198*  	ld bc,@end-@cmd
0407D1 5B DF       0199*  	rst.lil $18
0407D3 C9          0200*  	ret
0407D4 16          0201*  @cmd: db 22 ; set screen mode
0407D5 00          0202*  @arg: db 0  ; screen mode parameter
0407D6             0203*  @end:
0407D6             0204*  
0407D6             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0407D6             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0407D6             0207*  ; note: default setting on boot is scaling ON
0407D6             0208*  vdu_set_scaling:
0407D6 32 E8 07 04 0209*  	ld (@arg),a
0407DA 21 E5 07 04 0210*  	ld hl,@cmd
0407DE 01 04 00 00 0211*  	ld bc,@end-@cmd
0407E2 5B DF       0212*  	rst.lil $18
0407E4 C9          0213*  	ret
0407E5 17 00 C0    0214*  @cmd: db 23,0,0xC0
0407E8 00          0215*  @arg: db 0  ; scaling on/off
0407E9             0216*  @end:
0407E9             0217*  
0407E9             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0407E9             0219*  ; inputs: hl=bufferId
0407E9             0220*  vdu_buff_select:
0407E9 22 FB 07 04 0221*  	ld (@bufferId),hl
0407ED 21 F8 07 04 0222*  	ld hl,@cmd
0407F1 01 05 00 00 0223*  	ld bc,@end-@cmd
0407F5 5B DF       0224*  	rst.lil $18
0407F7 C9          0225*  	ret
0407F8 17 1B 20    0226*  @cmd: db 23,27,0x20
0407FB 00 00       0227*  @bufferId: dw 0x0000
0407FD 00          0228*  @end: db 0x00 ; padding
0407FE             0229*  
0407FE             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0407FE             0231*  ; inputs: a=format; bc=width; de=height
0407FE             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0407FE             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0407FE             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0407FE             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0407FE             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0407FE             0237*  ; 3 	Reserved for internal use by VDP (“native” format)
0407FE             0238*  vdu_bmp_create:
0407FE ED 43 1A 08 0239*      ld (@width),bc
       04          
040803 ED 53 1C 08 0240*      ld (@height),de
       04          
040808 32 1E 08 04 0241*      ld (@fmt),a
04080C 21 17 08 04 0242*  	ld hl,@cmd
040810 01 08 00 00 0243*  	ld bc,@end-@cmd
040814 5B DF       0244*  	rst.lil $18
040816 C9          0245*  	ret
040817 17 1B 21    0246*  @cmd:       db 23,27,0x21
04081A 00 00       0247*  @width:     dw 0x0000
04081C 00 00       0248*  @height:    dw 0x0000
04081E 00          0249*  @fmt:       db 0x00
04081F             0250*  @end:
04081F             0251*  
04081F             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
04081F             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
04081F             0254*  vdu_load_img_rgba2_to_8:
04081F             0255*  ; backup the target buffer id and image dimensions
04081F E5          0256*      push hl
040820 D5          0257*      push de
040821 C5          0258*      push bc
040822             0259*  ; load the rgba2 image to working buffer 65534
040822 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
040826 CD 29 09 04 0261*  	call vdu_load_buffer_from_file
04082A             0262*  ; restore the image dimensions and target buffer id
04082A C1          0263*      pop bc
04082B D1          0264*      pop de
04082C E1          0265*      pop hl
04082D             0266*  ; fall through to vdu_rgba2_to_8
04082D             0267*  
04082D             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
04082D             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
04082D             0270*  ; the "expand bitmap" command is:
04082D             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04082D             0272*  ; and then to reverse the byte order to fix endian-ness:
04082D             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04082D             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
04082D             0275*  ; VDU 23,27,&20,targetBufferID%;
04082D             0276*  ; VDU 23,27,&21,width%;height%;0
04082D             0277*  ; -------------------------------------------------------------------
04082D             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
04082D             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
04082D             0280*  vdu_rgba2_to_8:
04082D             0281*  ; load the image dimensions and buffer id parameters
04082D ED 43 89 08 0282*      ld (@width),bc
       04          
040832 ED 53 8B 08 0283*      ld (@height),de
       04          
040837 22 6E 08 04 0284*      ld (@bufferId0),hl
04083B 22 7B 08 04 0285*      ld (@bufferId2),hl
04083F 22 84 08 04 0286*      ld (@bufferId1),hl
040843             0287*  ; clean up bytes that got stomped on by the ID loads
040843 3E 48       0288*      ld a,0x48
040845 32 70 08 04 0289*      ld (@bufferId0+2),a
040849 3E 17       0290*      ld a,23
04084B 32 86 08 04 0291*      ld (@bufferId1+2),a
04084F 3E 18       0292*      ld a,24
040851 32 7D 08 04 0293*      ld (@bufferId2+2),a
040855 AF          0294*      xor a
040856 32 8D 08 04 0295*      ld (@height+2),a
04085A             0296*  ; send the vdu command strings
04085A 21 65 08 04 0297*      ld hl,@beg
04085E 01 29 00 00 0298*      ld bc,@end-@beg
040862 5B DF       0299*      rst.lil $18
040864 C9          0300*      ret
040865             0301*  @beg:
040865             0302*  ; Command 14: Consolidate blocks in a buffer
040865             0303*  ; VDU 23, 0, &A0, bufferId; 14
040865 17 00 A0    0304*      db 23,0,0xA0
040868 FE FF       0305*      dw 65534 ; workingBufferId
04086A 0E          0306*      db 14 ; consolidate blocks
04086B             0307*  ; the "expand bitmap" command is:
04086B             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04086B 17 00 A0    0309*      db 23,0,0xA0
04086E 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
040870 48          0311*      db 0x48 ; given as decimal command 72 in the docs
040871 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
040872 FE FF       0313*      dw 65534 ; sourceBufferId
040874 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
040878             0315*  ; reverse the byte order to fix endian-ness:
040878             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
040878             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
040878             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
040878 17 00 A0    0319*      db 23,0,0xA0
04087B 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
04087D 18          0321*      db 24 ; reverse byte order
04087E 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
04087F 04 00       0323*      dw 4 ; size (4 bytes)
040881             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
040881             0325*  ; VDU 23,27,&20,targetBufferID%;
040881 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
040884 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
040886             0328*  ; VDU 23,27,&21,width%;height%;0
040886 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
040889 00 00       0330*  @width: dw 0x0000
04088B 00 00       0331*  @height: dw 0x0000
04088D 00          0332*      db 0x00 ; rgba8888 format
04088E             0333*  @end:
04088E             0334*  
04088E             0335*  ; scratch variables
04088E 00 00 00    0336*  bufferId0: dl 0x000000
040891 00 00 00    0337*  bufferId1: dl 0x000000
040894             0338*  
040894             0339*  ; load a vdu buffer from local memory
040894             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
040894             0341*  vdu_load_buffer:
040894 ED 43 BD 08 0342*      ld (@length),bc
       04          
040899 D5          0343*      push de ; save data pointer
04089A             0344*  ; send the vdu command string
04089A 7D          0345*      ld a,l
04089B 32 BA 08 04 0346*      ld (@bufferId),a
04089F 7C          0347*      ld a,h
0408A0 32 BB 08 04 0348*      ld (@bufferId+1),a
0408A4 21 B7 08 04 0349*      ld hl,@cmd
0408A8 01 08 00 00 0350*      ld bc,@end-@cmd
0408AC 5B DF       0351*      rst.lil $18
0408AE             0352*  ; send the buffer data
0408AE E1          0353*      pop hl ; pointer to data
0408AF ED 4B BD 08 0354*      ld bc,(@length)
       04          
0408B4 5B DF       0355*      rst.lil $18 ; send it
0408B6 C9          0356*      ret
0408B7             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0408B7 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0408BA 00 00       0359*  @bufferId:	dw 0x0000
0408BC 00          0360*  		    db 0 ; load buffer
0408BD 00 00       0361*  @length:	dw 0x0000
0408BF 00          0362*  @end: db 0 ; padding
0408C0             0363*  
0408C0             0364*  ; clear a buffer
0408C0             0365*  ; inputs: hl = bufferId
0408C0             0366*  vdu_clear_buffer:
0408C0 7D          0367*      ld a,l
0408C1 32 D8 08 04 0368*      ld (@bufferId),a
0408C5 7C          0369*      ld a,h
0408C6 32 D9 08 04 0370*      ld (@bufferId+1),a
0408CA 21 D5 08 04 0371*      ld hl,@cmd
0408CE 01 06 00 00 0372*      ld bc,@end-@cmd
0408D2 5B DF       0373*      rst.lil $18
0408D4 C9          0374*      ret
0408D5 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0408D8 00 00       0376*  @bufferId:	dw 0x0000
0408DA 02          0377*  		    db 2 ; clear buffer
0408DB             0378*  @end:
0408DB             0379*  
0408DB             0380*  vdu_clear_all_buffers:
0408DB             0381*  ; clear all buffers
0408DB 21 E6 08 04 0382*      ld hl,@beg
0408DF 01 06 00 00 0383*      ld bc,@end-@beg
0408E3 5B DF       0384*      rst.lil $18
0408E5 C9          0385*      ret
0408E6 17 00 A0    0386*  @beg: db 23,0,$A0
0408E9 FF FF       0387*        dw -1 ; clear all buffers
0408EB 02          0388*        db 2  ; command 2: clear a buffer
0408EC             0389*  @end:
0408EC             0390*  
0408EC             0391*  ; Command 14: Consolidate blocks in a buffer
0408EC             0392*  vdu_consolidate_buffer:
0408EC             0393*  ; set parameters for vdu call
0408EC 7D          0394*      ld a,l
0408ED 32 04 09 04 0395*      ld (@bufferId),a
0408F1 7C          0396*      ld a,h
0408F2 32 05 09 04 0397*      ld (@bufferId+1),a
0408F6 21 01 09 04 0398*      ld hl,@beg
0408FA 01 06 00 00 0399*      ld bc,@end-@beg
0408FE 5B DF       0400*      rst.lil $18
040900 C9          0401*      ret
040901             0402*  ; VDU 23, 0, &A0, bufferId; 14
040901 17 00 A0    0403*  @beg: db 23,0,0xA0
040904 00 00       0404*  @bufferId: dw 0x0000
040906 0E          0405*             db 14
040907             0406*  @end:
040907             0407*  
040907             0408*  ; load an image file to a buffer and make it a bitmap
040907             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
040907             0410*  vdu_load_img:
040907             0411*  ; back up image type and dimension parameters
040907 22 8E 08 04 0412*      ld (bufferId0),hl
04090B F5          0413*      push af
04090C C5          0414*  	push bc
04090D D5          0415*  	push de
04090E             0416*  ; load the image
04090E CD 29 09 04 0417*  	call vdu_load_buffer_from_file
040912             0418*  ; now make it a bitmap
040912 2A 8E 08 04 0419*      ld hl,(bufferId0)
040916 CD EC 08 04 0420*      call vdu_consolidate_buffer
04091A 2A 8E 08 04 0421*      ld hl,(bufferId0)
04091E CD E9 07 04 0422*      call vdu_buff_select
040922 D1          0423*  	pop de ; image height
040923 C1          0424*  	pop bc ; image width
040924 F1          0425*  	pop af ; image type
040925 C3 FE 07 04 0426*  	jp vdu_bmp_create ; will return to caller from there
040929             0427*  
040929             0428*  ; inputs: hl = bufferId; iy = pointer to filename
040929             0429*  vdu_load_buffer_from_file:
040929 22 8E 08 04 0430*      ld (bufferId0),hl
04092D             0431*  
04092D             0432*  ; clear target buffer
04092D CD C0 08 04 0433*      call vdu_clear_buffer
040931             0434*  
040931             0435*  ; open the file in read mode
040931             0436*  ; Open a file
040931             0437*  ; HLU: Filename
040931             0438*  ;   C: Mode
040931             0439*  ; Returns:
040931             0440*  ;   A: Filehandle, or 0 if couldn't open
040931 FD E5       0441*  	push iy ; pointer to filename
040933 E1          0442*  	pop hl
040934 0E 01       0443*  	ld c,fa_read
040936             0444*      MOSCALL mos_fopen
040936 3E 0A       0001*M 			LD	A, function
040938 5B CF       0002*M 			RST.L	08h
04093A 32 75 09 04 0445*      ld (@filehandle),a
04093E             0446*  
04093E             0447*  @read_file:
04093E             0448*  ; Read a block of data from a file
04093E             0449*  ;   C: Filehandle
04093E             0450*  ; HLU: Pointer to where to write the data to
04093E             0451*  ; DEU: Number of bytes to read
04093E             0452*  ; Returns:
04093E             0453*  ; DEU: Number of bytes read
04093E 3A 75 09 04 0454*      ld a,(@filehandle)
040942 4F          0455*      ld c,a
040943 21 00 E0 B7 0456*      ld hl,filedata
040947 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
04094B             0458*      MOSCALL mos_fread
04094B 3E 1A       0001*M 			LD	A, function
04094D 5B CF       0002*M 			RST.L	08h
04094F             0459*  
04094F             0460*  ; ; DEBUG: print chunk size
04094F             0461*  ;     push de
04094F             0462*  ;     pop hl
04094F             0463*  ;     call printDec
04094F             0464*  ;     call printNewLine
04094F             0465*  
04094F             0466*  ; test de for zero bytes read
04094F 21 00 00 00 0467*      ld hl,0
040953 AF          0468*      xor a ; clear carry
040954 ED 52       0469*      sbc hl,de
040956 CA 6C 09 04 0470*      jp z,@close_file
04095A             0471*  
04095A             0472*  ; load a vdu buffer from local memory
04095A             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04095A 2A 8E 08 04 0474*      ld hl,(bufferId0)
04095E D5          0475*      push de ; chunksize
04095F C1          0476*      pop bc
040960 11 00 E0 B7 0477*      ld de,filedata
040964 CD 94 08 04 0478*      call vdu_load_buffer
040968             0479*  
040968             0480*  ; ; print progress breadcrumbs
040968             0481*  ;     ld a,'.'
040968             0482*  ;     rst.lil 10h
040968             0483*  
040968             0484*  ; read the next block
040968 C3 3E 09 04 0485*      jp @read_file
04096C             0486*  
04096C             0487*  ; close the file
04096C             0488*  @close_file:
04096C 3A 75 09 04 0489*      ld a,(@filehandle)
040970             0490*      MOSCALL mos_fclose
040970 3E 0B       0001*M 			LD	A, function
040972 5B CF       0002*M 			RST.L	08h
040974 C9          0491*      ret ; vdu_load_buffer_from_file
040975             0492*  
040975 00          0493*  @filehandle: db 0 ; file handle
040976 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
040979             0495*  
040979 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
04097C             0497*  
04097C             0498*  ; File information structure (FILINFO)
04097C             0499*  @filinfo:
04097C 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
040980 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
040982 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
040984 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
040985 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
040992 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040A92             0037       ; include "vdu_fonts.inc"
040A92             0038       include "vdu_plot.inc"
040A92             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040A92             0002*  ; PLOT code 	(Decimal) 	Effect
040A92             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
040A92             0004*  plot_sl_both: equ 0x00
040A92             0005*  
040A92             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
040A92             0007*  plot_sl_first: equ 0x08
040A92             0008*  
040A92             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
040A92             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
040A92             0011*  
040A92             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
040A92             0013*  plot_sl_last: equ 0x20
040A92             0014*  
040A92             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
040A92             0016*  plot_sl_none: equ 0x28
040A92             0017*  
040A92             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
040A92             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
040A92             0020*  
040A92             0021*  ; &40-&47 	64-71 	Point plot
040A92             0022*  plot_pt: equ 0x40
040A92             0023*  
040A92             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
040A92             0025*  plot_lf_lr_non_bg: equ 0x48
040A92             0026*  
040A92             0027*  ; &50-&57 	80-87 	Triangle fill
040A92             0028*  plot_tf: equ 0x50
040A92             0029*  
040A92             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
040A92             0031*  plot_lf_r_bg: equ 0x58
040A92             0032*  
040A92             0033*  ; &60-&67 	96-103 	Rectangle fill
040A92             0034*  plot_rf: equ 0x60
040A92             0035*  
040A92             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
040A92             0037*  plot_lf_lr_fg: equ 0x60
040A92             0038*  
040A92             0039*  ; &70-&77 	112-119 	Parallelogram fill
040A92             0040*  plot_pf: equ 0x70
040A92             0041*  
040A92             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
040A92             0043*  plot_lf_r_non_fg: equ 0x78
040A92             0044*  
040A92             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
040A92             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
040A92             0047*  
040A92             0048*  ; &90-&97 	144-151 	Circle outline
040A92             0049*  plot_co: equ 0x90
040A92             0050*  
040A92             0051*  ; &98-&9F 	152-159 	Circle fill
040A92             0052*  plot_cf: equ 0x98
040A92             0053*  
040A92             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
040A92             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
040A92             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
040A92             0057*  
040A92             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
040A92             0059*  plot_rcm: equ 0xB8
040A92             0060*  
040A92             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
040A92             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
040A92             0063*  ; &D0-&D7 	208-215 	Not defined
040A92             0064*  ; &D8-&DF 	216-223 	Not defined
040A92             0065*  ; &E0-&E7 	224-231 	Not defined
040A92             0066*  
040A92             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
040A92             0068*  plot_bmp: equ 0xE8
040A92             0069*  
040A92             0070*  ; &F0-&F7 	240-247 	Not defined
040A92             0071*  ; &F8-&FF 	248-255 	Not defined
040A92             0072*  
040A92             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
040A92             0074*  ; Agon Console8 VDP 2.2.0
040A92             0075*  
040A92             0076*  ; Within each group of eight plot codes, the effects are as follows:
040A92             0077*  ; Plot code 	Effect
040A92             0078*  ; 0 	Move relative
040A92             0079*  mv_rel: equ 0
040A92             0080*  
040A92             0081*  ; 1 	Plot relative in current foreground colour
040A92             0082*  dr_rel_fg: equ 1
040A92             0083*  
040A92             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
040A92             0085*  ; 3 	Plot relative in current background colour
040A92             0086*  dr_rel_bg: equ 3
040A92             0087*  
040A92             0088*  ; 4 	Move absolute
040A92             0089*  mv_abs: equ 4
040A92             0090*  
040A92             0091*  ; 5 	Plot absolute in current foreground colour
040A92             0092*  dr_abs_fg: equ 5
040A92             0093*  
040A92             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
040A92             0095*  ; 7 	Plot absolute in current background colour
040A92             0096*  dr_abs_bg: equ 7
040A92             0097*  
040A92             0098*  ; Codes 0-3 use the position data provided as part of the command
040A92             0099*  ; as a relative position, adding the position given to the current
040A92             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
040A92             0101*  ; as part of the command as an absolute position, setting the current
040A92             0102*  ; graphical cursor position to the position given.
040A92             0103*  
040A92             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
040A92             0105*  ; current pixel colour. These operations cannot currently be supported
040A92             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
040A92             0107*  ; supported. Support for these codes may be added in a future version
040A92             0108*  ; of the VDP firmware.
040A92             0109*  
040A92             0110*  ; 16 colour palette constants
040A92             0111*  c_black: equ 0
040A92             0112*  c_red_dk: equ 1
040A92             0113*  c_green_dk: equ 2
040A92             0114*  c_yellow_dk: equ 3
040A92             0115*  c_blue_dk: equ 4
040A92             0116*  c_magenta_dk: equ 5
040A92             0117*  c_cyan_dk: equ 6
040A92             0118*  c_grey: equ 7
040A92             0119*  c_grey_dk: equ 8
040A92             0120*  c_red: equ 9
040A92             0121*  c_green: equ 10
040A92             0122*  c_yellow: equ 11
040A92             0123*  c_blue: equ 12
040A92             0124*  c_magenta: equ 13
040A92             0125*  c_cyan: equ 14
040A92             0126*  c_white: equ 15
040A92             0127*  
040A92             0128*  ; VDU 25, mode, x; y;: PLOT command
040A92             0129*  ; inputs: a=mode, bc=x0, de=y0
040A92             0130*  vdu_plot:
040A92 32 AC 0A 04 0131*      ld (@mode),a
040A96 ED 43 AD 0A 0132*      ld (@x0),bc
       04          
040A9B ED 53 AF 0A 0133*      ld (@y0),de
       04          
040AA0 21 AB 0A 04 0134*  	ld hl,@cmd
040AA4 01 06 00 00 0135*  	ld bc,@end-@cmd
040AA8 5B DF       0136*  	rst.lil $18
040AAA C9          0137*  	ret
040AAB 19          0138*  @cmd:   db 25
040AAC 00          0139*  @mode:  db 0
040AAD 00 00       0140*  @x0: 	dw 0
040AAF 00 00       0141*  @y0: 	dw 0
040AB1 00          0142*  @end:   db 0 ; extra byte to soak up deu
040AB2             0143*  
040AB2             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040AB2             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
040AB2             0146*  ; VDU 25, mode, x; y;: PLOT command
040AB2             0147*  ; inputs: bc=x0, de=y0
040AB2             0148*  ; prerequisites: vdu_buff_select
040AB2             0149*  vdu_plot_bmp:
040AB2 ED 43 C9 0A 0150*      ld (@x0),bc
       04          
040AB7 ED 53 CB 0A 0151*      ld (@y0),de
       04          
040ABC 21 C7 0A 04 0152*  	ld hl,@cmd
040AC0 01 06 00 00 0153*  	ld bc,@end-@cmd
040AC4 5B DF       0154*  	rst.lil $18
040AC6 C9          0155*  	ret
040AC7 19          0156*  @cmd:   db 25
040AC8 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040AC9 00 00       0158*  @x0: 	dw 0x0000
040ACB 00 00       0159*  @y0: 	dw 0x0000
040ACD 00          0160*  @end:   db 0x00 ; padding
040ACE             0161*  
040ACE             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
040ACE             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
040ACE             0164*  ; VDU 25, mode, x; y;: PLOT command
040ACE             0165*  ; inputs: bc=x0, de=y0
040ACE             0166*  ; USING 16.8 FIXED POINT COORDINATES
040ACE             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
040ACE             0168*  ;   the fractional portiion of the inputs are truncated
040ACE             0169*  ;   leaving only the 16-bit integer portion
040ACE             0170*  ; prerequisites: vdu_buff_select
040ACE             0171*  vdu_plot_bmp168:
040ACE             0172*  ; populate in the reverse of normal to keep the
040ACE             0173*  ; inputs from stomping on each other
040ACE ED 53 EC 0A 0174*      ld (@y0-1),de
       04          
040AD3 ED 43 EA 0A 0175*      ld (@x0-1),bc
       04          
040AD8 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
040ADA 32 EA 0A 04 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
040ADE 21 E9 0A 04 0178*  	ld hl,@cmd
040AE2 01 06 00 00 0179*  	ld bc,@end-@cmd
040AE6 5B DF       0180*  	rst.lil $18
040AE8 C9          0181*  	ret
040AE9 19          0182*  @cmd:   db 25
040AEA ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
040AEB 00 00       0184*  @x0: 	dw 0x0000
040AED 00 00       0185*  @y0: 	dw 0x0000
040AEF             0186*  @end:  ; no padding required b/c we shifted de right
040AEF             0187*  
040AEF             0188*  ; draw a filled rectangle
040AEF             0189*  vdu_plot_rf:
040AEF ED 43 16 0B 0190*      ld (@x0),bc
       04          
040AF4 ED 53 18 0B 0191*      ld (@y0),de
       04          
040AF9 DD 22 1C 0B 0192*      ld (@x1),ix
       04          
040AFE FD 22 1E 0B 0193*      ld (@y1),iy
       04          
040B03 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
040B05 32 1A 0B 04 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040B09 21 14 0B 04 0196*  	ld hl,@cmd0
040B0D 01 0C 00 00 0197*  	ld bc,@end-@cmd0
040B11 5B DF       0198*  	rst.lil $18
040B13 C9          0199*      ret
040B14 19          0200*  @cmd0:  db 25 ; plot
040B15 04          0201*  @arg0:  db plot_sl_both+mv_abs
040B16 00 00       0202*  @x0:    dw 0x0000
040B18 00 00       0203*  @y0:    dw 0x0000
040B1A 19          0204*  @cmd1:  db 25 ; plot
040B1B 65          0205*  @arg1:  db plot_rf+dr_abs_fg
040B1C 00 00       0206*  @x1:    dw 0x0000
040B1E 00 00       0207*  @y1:    dw 0x0000
040B20 00          0208*  @end:   db 0x00 ; padding
040B21             0209*  
040B21             0210*  ; draw a filled circle
040B21             0211*  vdu_plot_cf:
040B21 ED 43 48 0B 0212*      ld (@x0),bc
       04          
040B26 ED 53 4A 0B 0213*      ld (@y0),de
       04          
040B2B DD 22 4E 0B 0214*      ld (@x1),ix
       04          
040B30 FD 22 50 0B 0215*      ld (@y1),iy
       04          
040B35 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
040B37 32 4C 0B 04 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
040B3B 21 46 0B 04 0218*  	ld hl,@cmd0
040B3F 01 0C 00 00 0219*  	ld bc,@end-@cmd0
040B43 5B DF       0220*  	rst.lil $18
040B45 C9          0221*      ret
040B46 19          0222*  @cmd0:  db 25 ; plot
040B47 04          0223*  @arg0:  db plot_sl_both+mv_abs
040B48 00 00       0224*  @x0:    dw 0x0000
040B4A 00 00       0225*  @y0:    dw 0x0000
040B4C 19          0226*  @cmd1:  db 25 ; plot
040B4D 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
040B4E 00 00       0228*  @x1:    dw 0x0000
040B50 00 00       0229*  @y1:    dw 0x0000
040B52 00          0230*  @end:   db 0x00 ; padding
040B53             0231*  
040B53             0232*  ; VDU 25, mode, x; y;: PLOT command
040B53             0233*  ; inputs: a=mode, ix=x0, iy=y0
040B53             0234*  plot:
040B53 32 6D 0B 04 0235*      ld (@mode),a
040B57 DD 22 6E 0B 0236*      ld (@x0),ix
       04          
040B5C FD 22 70 0B 0237*      ld (@y0),iy
       04          
040B61 21 6C 0B 04 0238*  	ld hl,@cmd
040B65 01 06 00 00 0239*  	ld bc,@end-@cmd
040B69 5B DF       0240*  	rst.lil $18
040B6B C9          0241*  	ret
040B6C 19          0242*  @cmd:   db 25
040B6D 00          0243*  @mode:  db 0
040B6E 00 00       0244*  @x0: 	dw 0
040B70 00 00       0245*  @y0: 	dw 0
040B72 00          0246*  @end:   db 0 ; padding
040B73             0247*  
040B73             0248*  ; VDU 5: Write text at graphics cursor
040B73             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
040B73             0250*  ; prerequisites: gcol foreground set, VDU 5 set
040B73             0251*  plot_text:
040B73 E5          0252*      push hl ; save text pointer
040B74             0253*  ; move graphics cursor to x0, y0
040B74 3E 44       0254*      ld a,plot_pt+mv_abs
040B76 CD 53 0B 04 0255*      call plot
040B7A             0256*  ; write text
040B7A E1          0257*      pop hl ; restore text pointer
040B7B CD 6C 00 04 0258*      call printString
040B7F C9          0259*      ret
040B80             0039   
040B80             0040   ; SHAWN'S INCLUDES
040B80             0041   	INCLUDE	"strings24.asm"
040B80             0001*  ;------------------------------------------------------------------------
040B80             0002*  ;  strings24.asm
040B80             0003*  ;
040B80             0004*  ; 24-bit native ez80 strings routines for numerical processing
040B80             0005*  ;  Copyright (c) Shawn Sijnstra 2024
040B80             0006*  ;  MIT license
040B80             0007*  ;------------------------------------------------------------------------
040B80             0008*  
040B80             0009*  ;Print signed value in HLU in decimal with leading 0s removed
040B80             0010*  ; and postpended with a minus sign if was negative
040B80             0011*  ; Uses HLU, DEU, BCU
040B80             0012*  print_HLU_s24:
040B80 CD 64 17 04 0013*  	call abs_hlu
040B84 F5          0014*  	push af ; save the sign and zero flags
040B85 CD 90 0B 04 0015*  	call print_HLU_u24
040B89 F1          0016*  	pop af
040B8A F0          0017*  	ret p ; HLU was positive so nothig more to do
040B8B 3E 2D       0018*  	ld a,'-'
040B8D 5B D7       0019*  	rst.lil 10h
040B8F C9          0020*  	ret
040B90             0021*  
040B90             0022*  ;------------------------------------------------------------------------
040B90             0023*  ;Full print and buffer routine so you can adjust behaviour
040B90             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
040B90             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
040B90             0026*  ;Print value in HLU in decimal with leading 0s removed
040B90             0027*  ; Uses HLU, DEU, BCU
040B90             0028*  ;------------------------------------------------------------------------
040B90             0029*  
040B90             0030*  print_HLU_u24:
040B90 22 6D 0C 04 0031*  	ld	(hex_temp),hl
040B94 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
040B96 11 70 0C 04 0033*  	ld	de,outbuf
040B9A D5          0034*  	push	de
040B9B 21 07 00 00 0035*  	ld	hl,7
040B9F 19          0036*  	add	hl,de
040BA0 E5          0037*  	push	hl
040BA1 D1          0038*  	pop	de	;copy HLU to DEU
040BA2 AF          0039*  	xor	a
040BA3             0040*  _pde_u_zerobuf:
040BA3 77          0041*  	ld	(hl),a	;zero out the output
040BA4 2B          0042*  	dec	hl
040BA5 10 FC       0043*  	djnz	_pde_u_zerobuf
040BA7             0044*  
040BA7 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
040BA9             0046*  _bcd_Convert:
040BA9             0047*  
040BA9 21 6D 0C 04 0048*  	ld hl,hex_temp
040BAD             0049*  ;
040BAD CB 26       0050*  	sla (hl)
040BAF 23          0051*  	inc hl
040BB0 CB 16       0052*  	rl (hl)
040BB2 23          0053*  	inc hl
040BB3 CB 16       0054*  	rl (hl)		;24 bits rolled right
040BB5             0055*  
040BB5             0056*  
040BB5 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
040BB7 D5          0058*  	push	de
040BB8 E1          0059*  	pop	hl
040BB9             0060*  
040BB9             0061*  _bcd_Add3:
040BB9 7E          0062*  	ld	a,(hl)
040BBA 8F          0063*  	adc	a
040BBB 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
040BBC FE 10       0065*  	cp	10h	;did we roll over nibble?
040BBE 3F          0066*  	ccf
040BBF CB A7       0067*  	res	4,a
040BC1             0068*  
040BC1 77          0069*          ld (hl),a
040BC2 2B          0070*  	dec	hl
040BC3 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
040BC5 0D          0072*          dec c
040BC6 20 E1       0073*          jr nz, _bcd_Convert	;loop around
040BC8             0074*  
040BC8             0075*  
040BC8 E1          0076*  	pop	hl
040BC9 E5          0077*  	push	hl
040BCA 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
040BCC             0079*  _pde_u_make_ascii:
040BCC 7E          0080*  	ld	a,(hl)
040BCD B7          0081*  	or	a
040BCE 20 05       0082*  	jr	nz,_pde_u_make_ascii2
040BD0 36 20       0083*  	ld	(hl),' '
040BD2 23          0084*  	inc	hl
040BD3 10 F7       0085*  	djnz	_pde_u_make_ascii
040BD5             0086*  _pde_u_make_ascii2:
040BD5 04          0087*  	inc	b
040BD6             0088*  _pde_u_make_ascii3:
040BD6 7E          0089*  	ld	a,(hl)
040BD7 F6 30       0090*  	or	30h
040BD9 77          0091*  	ld	(hl),a
040BDA 23          0092*  	inc	hl
040BDB 10 F9       0093*  	djnz	_pde_u_make_ascii3
040BDD             0094*  
040BDD E1          0095*  	pop	hl
040BDE 06 08       0096*  	ld	b,8
040BE0             0097*  _pde_u_final_out:
040BE0 7E          0098*  	ld	a,(hl)
040BE1 23          0099*  	inc	hl
040BE2 FE 20       0100*  	cp	' '
040BE4 28 02       0101*  	jr	z,_pde_u_final_out_strip
040BE6 5B D7       0102*  	rst.lil	10h
040BE8             0103*  _pde_u_final_out_strip:
040BE8 10 F6       0104*  	djnz	_pde_u_final_out
040BEA C9          0105*  	ret
040BEB             0106*  
040BEB             0107*  ;------------------------------------------------------------------------
040BEB             0108*  ; is_digit
040BEB             0109*  ; C flag set if A is a digit
040BEB             0110*  ; preserves all registers
040BEB             0111*  ;------------------------------------------------------------------------
040BEB             0112*  is_digit:
040BEB FE 30       0113*  	cp	'0'
040BED 3F          0114*  	ccf
040BEE D0          0115*  	ret	nc	;less that '0'
040BEF FE 3A       0116*  	cp	'9' + 1
040BF1 C9          0117*  	ret
040BF2             0118*  
040BF2             0119*  
040BF2             0120*  ;------------------------------------------------------------------------
040BF2             0121*  ; char2hex
040BF2             0122*  ; Input: ASCII nibble in A
040BF2             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
040BF2             0124*  ;------------------------------------------------------------------------
040BF2             0125*  char2hex:
040BF2 FE 30       0126*  	CP	'0'
040BF4 38 1D       0127*  	JR	C, char_not_hex
040BF6 FE 3A       0128*  	CP	'9' + 1
040BF8 30 03       0129*  	JR	NC, char_not_09
040BFA D6 30       0130*  	sub	'0'
040BFC C9          0131*  	ret
040BFD             0132*  
040BFD             0133*  char_not_09:
040BFD             0134*  	; char is not 0 to 9. Try upper case
040BFD FE 41       0135*  	CP	'A'
040BFF 38 12       0136*  	JR	C, char_not_hex
040C01 FE 47       0137*  	CP	'F' + 1
040C03 30 03       0138*  	JR	NC, char_not_AF
040C05 D6 37       0139*  	sub	'A'-10
040C07 C9          0140*  	ret
040C08             0141*  
040C08             0142*  char_not_AF:
040C08             0143*  	; char is not upper case A-F. Try lower
040C08 FE 61       0144*  	CP	'a'
040C0A 38 07       0145*  	JR	C, char_not_hex
040C0C FE 67       0146*  	CP	'f' + 1
040C0E 30 03       0147*  	JR	NC, char_not_hex
040C10 D6 57       0148*  	sub	'a' - 10
040C12 C9          0149*  	RET
040C13             0150*  
040C13             0151*  char_not_hex:
040C13 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
040C15 C9          0153*  	RET
040C16             0154*  
040C16             0155*  ;------------------------------------------------------------------------
040C16             0156*  ;  newline
040C16             0157*  ;  Output CR+LF; all registers preserved
040C16             0158*  ;------------------------------------------------------------------------
040C16             0159*  newline:
040C16 F5          0160*         push   AF
040C17 3E 0D       0161*         LD     A, 13
040C19 5B D7       0162*         RST.LIL    10h
040C1B 3E 0A       0163*         LD     A, 10
040C1D 5B D7       0164*         RST.LIL    10h
040C1F F1          0165*         POP    AF
040C20 C9          0166*         RET
040C21             0167*  
040C21             0168*  ;------------------------------------------------------------------------
040C21             0169*  ;  put_nibble
040C21             0170*  ;  Output a single hex nibble in A
040C21             0171*  ;  All registers preserved
040C21             0172*  ;------------------------------------------------------------------------
040C21             0173*  put_nibble:
040C21 F5          0174*  	push   AF
040C22 C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
040C24 27          0176*  	daa
040C25 CE 40       0177*  	adc    a,040h
040C27 27          0178*  	daa
040C28 5B D7       0179*  	RST.LIL    10h	;output character in A
040C2A F1          0180*  	pop    AF
040C2B C9          0181*  	ret
040C2C             0182*  
040C2C             0183*  ;------------------------------------------------------------------------
040C2C             0184*  ;  print_A
040C2C             0185*  ;  Output the 8-bit hex number A
040C2C             0186*  ;  All registers preserved
040C2C             0187*  ;------------------------------------------------------------------------
040C2C             0188*  print_A:
040C2C F5          0189*  	push 	AF
040C2D F5          0190*  	push 	AF	;save for second nibble
040C2E 0F          0191*  	rrca
040C2F 0F          0192*  	rrca
040C30 0F          0193*  	rrca
040C31 0F          0194*  	rrca
040C32 E6 0F       0195*  	and	0Fh	;first nibble
040C34 CD 21 0C 04 0196*  	call	put_nibble
040C38 F1          0197*  	pop 	AF
040C39 E6 0F       0198*  	and	0Fh	;second nibble
040C3B CD 21 0C 04 0199*  	call	put_nibble
040C3F F1          0200*  	pop 	AF
040C40 C9          0201*  	ret
040C41             0202*  
040C41             0203*  ;------------------------------------------------------------------------
040C41             0204*  ;  print_HLU_hex
040C41             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
040C41             0206*  ;------------------------------------------------------------------------
040C41             0207*  print_HLU_hex:
040C41 F5          0208*         push   AF
040C42 22 6D 0C 04 0209*         ld     (hex_temp),hl
040C46 3A 6F 0C 04 0210*         ld     a,(hex_temp+2)
040C4A CD 2C 0C 04 0211*         call   print_A
040C4E 3A 6E 0C 04 0212*         ld     a,(hex_temp+1)
040C52 CD 2C 0C 04 0213*         call   print_A
040C56 3A 6D 0C 04 0214*         ld     a,(hex_temp)
040C5A CD 2C 0C 04 0215*         call   print_A
040C5E F1          0216*         POP    AF
040C5F C9          0217*         RET
040C60             0218*  
040C60             0219*  ;------------------------------------------------------------------------
040C60             0220*  ;  puts
040C60             0221*  ;  Output a zero-terminated string whose address is in HL; all
040C60             0222*  ;  registers preserved.
040C60             0223*  ;------------------------------------------------------------------------
040C60             0224*  puts:
040C60 F5          0225*         push   AF
040C61 C5          0226*         push   BC
040C62 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
040C66 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
040C68 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
040C6A C1          0230*         pop    BC
040C6B F1          0231*         pop    AF
040C6C C9          0232*         ret
040C6D             0233*  
040C6D             0234*  ;------------------------------------------------------------------------
040C6D             0235*  ; Data area
040C6D             0236*  ; Storage for 24 bit conversion
040C6D             0237*  ;------------------------------------------------------------------------
040C6D             0238*  hex_temp:
040C6D 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
040C70             0240*  
040C70             0241*  outbuf:
040C70 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
040C79             0042   	INCLUDE	"arith24.asm"
040C79             0001*  
040C79             0002*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
040C79             0003*  ; uses EZ80 MLT instruction for speed
040C79             0004*  ; operation: UHL * A --> AUHL
040C79             0005*  ; destroys: AF, HL
040C79             0006*  umul24x8:
040C79 D5          0007*  	push de ; preserve de
040C7A             0008*  ; low byte
040C7A 5D          0009*  	ld e,l
040C7B 57          0010*  	ld d,a
040C7C ED 5C       0011*  	mlt de
040C7E 6B          0012*  	ld l,e ; product low byte
040C7F 08          0013*  	ex af,af' ; save multiplier
040C80 7A          0014*  	ld a,d ; carry
040C81 08          0015*  	ex af,af' ; save carry, restore multiplier
040C82             0016*  ; high byte
040C82 5C          0017*  	ld e,h
040C83 57          0018*  	ld d,a
040C84 ED 5C       0019*  	mlt de
040C86 08          0020*  	ex af,af' ; save multiplier, restore carry
040C87 83          0021*  	add a,e ; add carry
040C88 67          0022*  	ld h,a ; product middle byte
040C89 7A          0023*  	ld a,d ; carry
040C8A 08          0024*  	ex af,af' ; save carry, restore multiplier
040C8B             0025*  ; upper byte
040C8B E5          0026*  	push hl
040C8C 33          0027*  	inc sp
040C8D D1          0028*  	pop de ; d = hlu
040C8E 3B          0029*  	dec sp
040C8F 5F          0030*  	ld e,a
040C90 ED 5C       0031*  	mlt de
040C92 08          0032*  	ex af,af' ; restore carry
040C93 8B          0033*  	adc a,e ; add carry
040C94             0034*  ; highest byte
040C94 22 A5 0C 04 0035*      ld (@scratch),hl ; 7 cycles
040C98 32 A7 0C 04 0036*      ld (@scratch+2),a ; 5 cycles
040C9C 2A A5 0C 04 0037*      ld hl,(@scratch) ; 7 cycles
040CA0 3E 00       0038*  	ld a,0 ; preserve carry flag
040CA2 8A          0039*  	adc a,d ; product highest byte
040CA3 D1          0040*  	pop de ; restore de
040CA4 C9          0041*  	ret
040CA5             0042*  @scratch: ds 3
040CA8             0043*  
040CA8             0044*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
040CA8             0045*  ; operation: UHL * UDE --> umul24x24out
040CA8             0046*  umul24x24:
040CA8 FD 21 F4 0C 0047*  	ld iy,umul24x24out ; point to output buffer
       04          
040CAD             0048*  
040CAD             0049*  ; STEP 1: UHL * E
040CAD 7B          0050*  	ld a,e
040CAE E5          0051*  	push hl
040CAF CD 79 0C 04 0052*  	call umul24x8
040CB3 FD 2F 00    0053*  	ld (iy+0),hl
040CB6 FD 77 03    0054*  	ld (iy+3),a
040CB9             0055*  
040CB9             0056*  ; STEP 2: UHL * D
040CB9 E1          0057*  	pop hl
040CBA E5          0058*  	push hl
040CBB 7A          0059*  	ld a,d
040CBC CD 79 0C 04 0060*  	call umul24x8
040CC0 CD CD 0C 04 0061*  	call @accumulate
040CC4             0062*  
040CC4             0063*  ; STEP 3: UHL * DEU
040CC4 E1          0064*  	pop hl
040CC5 D5          0065*  	push de
040CC6 33          0066*  	inc sp
040CC7 F1          0067*  	pop af
040CC8 3B          0068*  	dec sp
040CC9 CD 79 0C 04 0069*  	call umul24x8
040CCD             0070*  
040CCD             0071*  @accumulate:
040CCD FD 23       0072*  	inc iy
040CCF             0073*  ; highest byte of product to carry
040CCF FD 77 03    0074*  	ld (iy+3),a
040CD2             0075*  ; low byte of product
040CD2 7D          0076*  	ld a,l
040CD3 FD 86 00    0077*  	add a,(iy+0)
040CD6 FD 77 00    0078*  	ld (iy+0),a
040CD9             0079*  ; high byte of product
040CD9 7C          0080*  	ld a,h
040CDA FD 8E 01    0081*  	adc a,(iy+1)
040CDD FD 77 01    0082*  	ld (iy+1),a
040CE0             0083*  ; uppper byte of product
040CE0 E5          0084*  	push hl
040CE1 33          0085*  	inc sp
040CE2 E1          0086*  	pop hl
040CE3 3B          0087*  	dec sp
040CE4 7C          0088*  	ld a,h
040CE5 FD 8E 02    0089*  	adc a,(iy+2)
040CE8 FD 77 02    0090*  	ld (iy+2),a
040CEB             0091*  ; carry
040CEB 3E 00       0092*  	ld a,0 ; preserve flags
040CED FD 8E 03    0093*  	adc a,(iy+3)
040CF0 FD 77 03    0094*  	ld (iy+3),a
040CF3 C9          0095*  	ret
040CF4             0096*  
040CF4             0097*  umul24x24out: ds 6 ; output buffer
040CFA             0098*  umul24x24de: ds 3  ; scratch buffer to hold multiplier
040CFD             0099*  
040CFD             0100*  arith24uaf: ds 6
040D03             0101*  arith24uhl: ds 6
040D09             0102*  arith24ubc: ds 6
040D0F             0103*  arith24ude: ds 6
040D15             0104*  arith24uix: ds 6
040D1B             0105*  arith24uiy: ds 6
040D21             0106*  arith24usp: ds 6
040D27             0107*  arith24upc: ds 6
040D2D             0108*  
040D2D             0109*  ; hlu 1 byte right shift
040D2D             0110*  ; returns: hlu / 256, fractional portion in a
040D2D             0111*  ; destroys: af
040D2D             0112*  shift_hlu_r1b:
040D2D AF          0113*  	xor a
040D2E 32 3F 0D 04 0114*  	ld (@buffer+3),a
040D32 7D          0115*  	ld a,l ; save the fractional portion
040D33 22 3C 0D 04 0116*  	ld (@buffer),hl
040D37 2A 3D 0D 04 0117*  	ld hl,(@buffer+1)
040D3B C9          0118*  	ret
040D3C             0119*  @buffer: ds 4
040D40             0120*  
040D40             0121*  ;------------------------------------------------------------------------
040D40             0122*  ;  arith24.asm
040D40             0123*  ;  24-bit ez80 arithmetic routines
040D40             0124*  ;  Copyright (c) Shawn Sijnstra 2024
040D40             0125*  ;  MIT license
040D40             0126*  ;
040D40             0127*  ;  This library was created as a tool to help make ez80
040D40             0128*  ;  24-bit native assembly routines for simple mathematical problems
040D40             0129*  ;  more widely available.
040D40             0130*  ;
040D40             0131*  ;------------------------------------------------------------------------
040D40             0132*  
040D40             0133*  ;------------------------------------------------------------------------
040D40             0134*  ; umul24:	HL = HL*DE (unsigned)
040D40             0135*  ; Preserves AF, BC, DE
040D40             0136*  ; Uses a fast multiply routine.
040D40             0137*  ;------------------------------------------------------------------------
040D40             0138*  umul24:
040D40 D5          0139*  	push	DE
040D41 C5          0140*  	push	BC
040D42 F5          0141*  	push	AF
040D43 E5          0142*  	push	HL
040D44 C1          0143*  	pop		BC
040D45 3E 18       0144*      ld	 	a, 24 ; No. of bits to process
040D47 21 00 00 00 0145*      ld	 	hl, 0 ; Result
040D4B             0146*  umul24_lp:
040D4B 29          0147*  	add	hl,hl
040D4C EB          0148*  	ex	de,hl
040D4D 29          0149*  	add	hl,hl
040D4E EB          0150*  	ex	de,hl
040D4F 30 01       0151*  	jr	nc,umul24_nc
040D51 09          0152*  	add	hl,bc
040D52             0153*  umul24_nc:
040D52 3D          0154*  	dec	a
040D53 20 F6       0155*  	jr	nz,umul24_lp
040D55 F1          0156*  	pop	af
040D56 C1          0157*  	pop	bc
040D57 D1          0158*  	pop	de
040D58 C9          0159*  	ret
040D59             0160*  
040D59             0161*  ;------------------------------------------------------------------------
040D59             0162*  ; udiv24
040D59             0163*  ; Unsigned 24-bit division
040D59             0164*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040D59             0165*  ;
040D59             0166*  ; Uses AF BC DE HL
040D59             0167*  ; Uses Restoring Division algorithm
040D59             0168*  ;------------------------------------------------------------------------
040D59             0169*  
040D59             0170*  udiv24:
040D59 E5          0171*  	push	hl
040D5A C1          0172*  	pop		bc	;move dividend to BCU
040D5B 21 00 00 00 0173*  	ld		hl,0	;result
040D5F A7          0174*  	and		a
040D60 ED 52       0175*  	sbc		hl,de	;test for div by 0
040D62 C8          0176*  	ret		z		;it's zero, carry flag is clear
040D63 19          0177*  	add		hl,de	;HL is 0 again
040D64 3E 18       0178*  	ld		a,24	;number of loops through.
040D66             0179*  udiv1:
040D66 C5          0180*  	push	bc	;complicated way of doing this because of lack of access to top bits
040D67 E3          0181*  	ex		(sp),hl
040D68 37          0182*  	scf
040D69 ED 6A       0183*  	adc	hl,hl
040D6B E3          0184*  	ex	(sp),hl
040D6C C1          0185*  	pop	bc		;we now have bc = (bc * 2) + 1
040D6D             0186*  
040D6D ED 6A       0187*  	adc	hl,hl
040D6F A7          0188*  	and	a		;is this the bug
040D70 ED 52       0189*  	sbc	hl,de
040D72 30 02       0190*  	jr	nc,udiv2
040D74 19          0191*  	add	hl,de
040D75             0192*  ;	dec	c
040D75 0B          0193*  	dec	bc
040D76             0194*  udiv2:
040D76 3D          0195*  	dec	a
040D77 20 ED       0196*  	jr	nz,udiv1
040D79 37          0197*  	scf		;flag used for div0 error
040D7A C5          0198*  	push	bc
040D7B D1          0199*  	pop		de	;remainder
040D7C C9          0200*  	ret
040D7D             0201*  
040D7D             0202*  
040D7D             0203*  ; umul24:	UH.L = UH.L*UD.E (unsigned)
040D7D             0204*  ; Preserves AF, BC, DE
040D7D             0205*  umul168:
040D7D             0206*  
040D7D             0207*  umul168out: ds 6
040D83             0208*  
040D83             0209*  ; perform signed multiplication of 16.8 fixed place values
040D83             0210*  ; with an signed 16.8 fixed place result
040D83             0211*  ; inputs: ub.c and ud.e are the operands
040D83             0212*  ; outputs: uh.l is the product
040D83             0213*  ; destroys: a,bc
040D83             0214*  ; TODO: make flags appropriate to the sign of the result
040D83             0215*  smul168:
040D83             0216*  ; make everything positive and save signs
040D83 C5          0217*      push bc         ; get bc to hl
040D84 E1          0218*      pop hl          ; for the next call
040D85 CD 64 17 04 0219*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
040D89             0220*  
040D89             0221*      ; call dumpFlags ; passes
040D89             0222*  
040D89 CA BC 0D 04 0223*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040D8D F5          0224*      push af         ; save sign of bc
040D8E E5          0225*      push hl         ; now put abs(hl)
040D8F C1          0226*      pop bc          ; back into bc = abs(bc)
040D90 EB          0227*      ex de,hl        ; now we do de same way
040D91 CD 64 17 04 0228*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
040D95             0229*  
040D95             0230*      ; call dumpFlags ; passes
040D95             0231*  
040D95 CA BC 0D 04 0232*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
040D99 EB          0233*      ex de,hl        ; hl back to de = abs(de)
040D9A             0234*  ; determine sign of result
040D9A F2 A5 0D 04 0235*      jp p,@de_pos    ; sign positive,de is positive
040D9E             0236*  
040D9E             0237*      ; call dumpFlags ; correctly doesnt make it here
040D9E             0238*  
040D9E F1          0239*      pop af          ; get back sign of bc
040D9F             0240*  
040D9F             0241*      ; call dumpFlags ; correctly doesn't make it here
040D9F             0242*  
040D9F FA AE 0D 04 0243*      jp m,@result_pos  ; bc and de negative, result is positive
040DA3             0244*  
040DA3             0245*      ; call dumpFlags  ; corectly doesn't make it here
040DA3             0246*  
040DA3 18 05       0247*      jr @result_neg
040DA5             0248*  @de_pos:
040DA5 F1          0249*      pop af          ; get back sign of bc
040DA6             0250*  
040DA6             0251*      ; call dumpFlags  ; passes
040DA6             0252*  
040DA6 F2 AE 0D 04 0253*      jp p,@result_pos   ; bc and de are both positive so result is positive
040DAA             0254*  
040DAA             0255*      ; call dumpFlags ; correctly makes it here
040DAA             0256*  
040DAA             0257*                      ; fall through to result_neg
040DAA             0258*  @result_neg:
040DAA AF          0259*      xor a           ; zero a and clear carry
040DAB 3D          0260*      dec a           ; set sign flag to negative
040DAC             0261*  
040DAC             0262*      ; call dumpFlags ; passes
040DAC             0263*  
040DAC 18 02       0264*      jr @do_mul
040DAE             0265*  @result_pos:
040DAE AF          0266*      xor a           ; zero a and clear carry
040DAF 3C          0267*      inc a           ; set sign flag to positive
040DB0             0268*                      ; fall through to do_mul
040DB0             0269*  
040DB0             0270*      ; call dumpFlags ; correctly doesn't make it here
040DB0             0271*  
040DB0             0272*  @do_mul:
040DB0 F5          0273*      push af         ; save sign of result
040DB1 CD 7D 0D 04 0274*      call umul168
040DB5 F1          0275*      pop af          ; get back sign of result
040DB6             0276*  
040DB6             0277*      ; call dumpFlags ; passes
040DB6             0278*  
040DB6 F0          0279*      ret p           ; result is positive so nothing to do
040DB7             0280*  
040DB7             0281*      ; call dumpRegistersHex ; passes
040DB7             0282*  
040DB7 CD 74 17 04 0283*      call neg_hlu    ; result is negative so negate it
040DBB             0284*  
040DBB             0285*      ; call dumpRegistersHex ; passes
040DBB C9          0286*      ret
040DBC             0287*  @is_zero:           ; result is zero
040DBC AF          0288*      xor a           ; sets zero flag, which we want,
040DBD             0289*                      ; sets pv flag which we might not (zero is parity even)
040DBD             0290*                      ; resets all others which is okay
040DBD C9          0291*      ret
040DBE             0292*  
040DBE             0293*  ; perform unsigned division of fixed place values
040DBE             0294*  ; with an unsigned 16.8 fixed place result
040DBE             0295*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
040DBE             0296*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
040DBE             0297*  ; destroys: a,bc
040DBE             0298*  udiv168:
040DBE             0299*  ; shift dividend left 8 bits
040DBE ED 43 0A 0D 0300*      ld (arith24ubc+1),bc
       04          
040DC3 AF          0301*      xor a
040DC4 32 09 0D 04 0302*      ld (arith24ubc),a
040DC8 ED 4B 09 0D 0303*      ld bc,(arith24ubc)
       04          
040DCD CD 59 0D 04 0304*      call udiv24
040DD1             0305*  ; flip-flop outptuts to satisfy downstream consumers
040DD1             0306*  ; TODO: this is a hack and should be fixed
040DD1             0307*  ; (so says copilot ... but it's not wrong)
040DD1 E5          0308*      push hl
040DD2 C5          0309*      push bc
040DD3 E1          0310*      pop hl
040DD4 C1          0311*      pop bc
040DD5 C9          0312*      ret
040DD6             0313*  
040DD6             0314*  ; perform signed division of 16.8 fixed place values
040DD6             0315*  ; with an signed 16.8 fixed place result
040DD6             0316*  ; inputs: ub.c is dividend,ud.e is divisor
040DD6             0317*  ; outputs: uh.l is quotient
040DD6             0318*  ; destroys: a,bc
040DD6             0319*  ; note: uses carry flag to test for sign of operands and result
040DD6             0320*  ;       which can be confusing and should perhaps be changed
040DD6             0321*  ; note2: helper functions abs_hlu and neg_hlu have been modified
040DD6             0322*  ;       to return accurate flags according to the origional signs
040DD6             0323*  ;       (or zero) of this function's inputs
040DD6             0324*  sdiv168:
040DD6             0325*  ; make everything positive and save signs
040DD6 C5          0326*      push bc         ; get bc to hl
040DD7 E1          0327*      pop hl          ; for the next call
040DD8 CD 64 17 04 0328*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
040DDC CA 0F 0E 04 0329*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040DE0 F5          0330*      push af         ; save sign of bc
040DE1 E5          0331*      push hl         ; now put abs(hl)
040DE2 C1          0332*      pop bc          ; back into bc = abs(bc)
040DE3 EB          0333*      ex de,hl        ; now we do de same way
040DE4 CD 64 17 04 0334*      call abs_hlu
040DE8 CA 11 0E 04 0335*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
040DEC EB          0336*      ex de,hl        ; hl back to de = abs(de)
040DED             0337*  ; determine sign of result
040DED F2 F8 0D 04 0338*      jp p,@de_pos    ; sign positive,de is positive
040DF1 F1          0339*      pop af          ; get back sign of bc
040DF2 FA 01 0E 04 0340*      jp m,@result_pos  ; bc and de negative, result is positive
040DF6 18 05       0341*      jr @result_neg
040DF8             0342*  @de_pos:
040DF8 F1          0343*      pop af          ; get back sign of bc
040DF9 F2 01 0E 04 0344*      jp p,@result_pos   ; bc and de are both positive so result is positive
040DFD             0345*                      ; fall through to result_neg
040DFD             0346*  @result_neg:
040DFD AF          0347*      xor a           ; zero a and clear carry
040DFE 3D          0348*      dec a           ; set sign flag to negative
040DFF 18 02       0349*      jr @do_div
040E01             0350*  @result_pos:
040E01 AF          0351*      xor a           ; zero a and clear carry
040E02 3C          0352*      inc a           ; set sign flag to negative
040E03             0353*                      ; fall through to do_div
040E03             0354*  @do_div:
040E03 F5          0355*      push af         ; save sign of result
040E04 CD BE 0D 04 0356*      call udiv168
040E08 F1          0357*      pop af          ; get back sign of result
040E09 F0          0358*      ret p           ; result is positive so nothing to do
040E0A CD 74 17 04 0359*      call neg_hlu    ; result is negative so negate it
040E0E C9          0360*      ret
040E0F             0361*  @is_zero:           ; result is zero
040E0F AF          0362*      xor a           ; sets zero flag, which we want,
040E10             0363*                      ; sets pv flag which we might not (zero is parity even)
040E10             0364*                      ; resets all others which is okay
040E10 C9          0365*      ret
040E11             0366*  @div_by_zero:       ; result is undefined, which isn't defined in binary
040E11             0367*                      ; so we'll just return zero until i can think of something better
040E11 F1          0368*      pop af          ; dummy pop
040E12 AF          0369*      xor a           ; sets zero flag, which is ok,
040E13             0370*                      ; sets pv flag which could be interpreted as overflow, which is good
040E13             0371*                      ; resets all others which is okay
040E13 C9          0372*      ret
040E14             0373*  
040E14             0374*  ;------------------------------------------------------------------------
040E14             0375*  ; neg24
040E14             0376*  ; Returns: HLU = 0-HLU
040E14             0377*  ; preserves all other registers
040E14             0378*  ;------------------------------------------------------------------------
040E14             0379*  neg24:
040E14 D5          0380*  	push	de
040E15 EB          0381*  	ex		de,hl
040E16 21 00 00 00 0382*  	ld		hl,0
040E1A B7          0383*  	or		a
040E1B ED 52       0384*  	sbc		hl,de
040E1D D1          0385*  	pop		de
040E1E C9          0386*  	ret
040E1F             0387*  
040E1F             0388*  ;------------------------------------------------------------------------
040E1F             0389*  ; or_hlu_deu: 24 bit bitwise OR
040E1F             0390*  ; Returns: hlu = hlu OR deu
040E1F             0391*  ; preserves all other registers
040E1F             0392*  ;------------------------------------------------------------------------
040E1F             0393*  or_hlu_deu:
040E1F 22 AA 0E 04 0394*  	ld	(bitbuf1),hl
040E23 ED 53 AD 0E 0395*  	ld	(bitbuf2),de
       04          
040E28 D5          0396*  	push	de	;preserve DEU
040E29 C5          0397*  	push	bc	;preserve BCU
040E2A 06 03       0398*  	ld		b,3
040E2C 21 AA 0E 04 0399*  	ld	hl,bitbuf1
040E30 11 AA 0E 04 0400*  	ld	de,bitbuf1
040E34             0401*  orloop_24:
040E34 1A          0402*  	ld	a,(de)
040E35 B6          0403*  	or	(hl)
040E36 12          0404*  	ld	(de),a
040E37 13          0405*  	inc	de
040E38 23          0406*  	inc	hl
040E39 10 F9       0407*  	djnz	orloop_24
040E3B 2A AD 0E 04 0408*  	ld	hl,(bitbuf2)
040E3F C1          0409*  	pop		bc	;restore BC
040E40 D1          0410*  	pop		de	;restore DE
040E41             0411*  
040E41             0412*  ;------------------------------------------------------------------------
040E41             0413*  ; and_hlu_deu: 24 bit bitwise AND
040E41             0414*  ; Returns: hlu = hlu AND deu
040E41             0415*  ; preserves all other registers
040E41             0416*  ;------------------------------------------------------------------------
040E41             0417*  and_hlu_deu:
040E41 22 AA 0E 04 0418*  	ld	(bitbuf1),hl
040E45 ED 53 AD 0E 0419*  	ld	(bitbuf2),de
       04          
040E4A D5          0420*  	push	de	;preserve DEU
040E4B C5          0421*  	push	bc	;preserve BCU
040E4C 06 03       0422*  	ld		b,3
040E4E 21 AA 0E 04 0423*  	ld	hl,bitbuf1
040E52 11 AA 0E 04 0424*  	ld	de,bitbuf1
040E56             0425*  andloop_24:
040E56 1A          0426*  	ld	a,(de)
040E57 A6          0427*  	and	(hl)
040E58 12          0428*  	ld	(de),a
040E59 13          0429*  	inc	de
040E5A 23          0430*  	inc	hl
040E5B 10 F9       0431*  	djnz	andloop_24
040E5D 2A AD 0E 04 0432*  	ld	hl,(bitbuf2)
040E61 C1          0433*  	pop		bc	;restore BC
040E62 D1          0434*  	pop		de	;restore DE
040E63             0435*  
040E63             0436*  ;------------------------------------------------------------------------
040E63             0437*  ; xor_hlu_deu: 24 bit bitwise XOR
040E63             0438*  ; Returns: hlu = hlu XOR deu
040E63             0439*  ; preserves all other registers
040E63             0440*  ;------------------------------------------------------------------------
040E63             0441*  xor_hlu_deu:
040E63 22 AA 0E 04 0442*  	ld	(bitbuf1),hl
040E67 ED 53 AD 0E 0443*  	ld	(bitbuf2),de
       04          
040E6C D5          0444*  	push	de	;preserve DEU
040E6D C5          0445*  	push	bc	;preserve BCU
040E6E 06 03       0446*  	ld		b,3
040E70 21 AA 0E 04 0447*  	ld	hl,bitbuf1
040E74 11 AA 0E 04 0448*  	ld	de,bitbuf1
040E78             0449*  xorloop_24:
040E78 1A          0450*  	ld	a,(de)
040E79 AE          0451*  	xor	(hl)
040E7A 12          0452*  	ld	(de),a
040E7B 13          0453*  	inc	de
040E7C 23          0454*  	inc	hl
040E7D 10 F9       0455*  	djnz	xorloop_24
040E7F 2A AD 0E 04 0456*  	ld	hl,(bitbuf2)
040E83 C1          0457*  	pop		bc	;restore BC
040E84 D1          0458*  	pop		de	;restore DE
040E85             0459*  
040E85             0460*  ;------------------------------------------------------------------------
040E85             0461*  ; shl_hlu: 24 bit shift left hlu by deu positions
040E85             0462*  ; Returns: hlu = hlu << deu
040E85             0463*  ;		   de = 0
040E85             0464*  ; NOTE: only considers deu up to 16 bits.
040E85             0465*  ; preserves all other registers
040E85             0466*  ;------------------------------------------------------------------------
040E85             0467*  shl_hlu:
040E85 7A          0468*  	ld		a,d		;up to 16 bit.
040E86 B3          0469*  	or		e
040E87 C8          0470*  	ret		z		;we're done
040E88 29          0471*  	add		hl,hl	;shift HLU left
040E89 1B          0472*  	dec		de
040E8A 18 F9       0473*  	jr		shl_hlu
040E8C             0474*  
040E8C             0475*  ;------------------------------------------------------------------------
040E8C             0476*  ; shr_hlu: 24 bit shift right hlu by deu positions
040E8C             0477*  ; Returns: hlu = hlu >> deu
040E8C             0478*  ;		   de = 0
040E8C             0479*  ; NOTE: only considers deu up to 16 bits.
040E8C             0480*  ; preserves all other registers
040E8C             0481*  ;------------------------------------------------------------------------
040E8C             0482*  shr_hlu:
040E8C 22 AA 0E 04 0483*  	ld		(bitbuf1),hl
040E90 21 AC 0E 04 0484*  	ld		hl,bitbuf1+2
040E94             0485*  shr_loop:
040E94 7A          0486*  	ld		a,d		;up to 16 bit.
040E95 B3          0487*  	or		e
040E96 28 0D       0488*  	jr		z,shr_done		;we're done
040E98             0489*  ;carry is clear from or instruction
040E98 CB 1E       0490*  	rr		(hl)
040E9A 2B          0491*  	dec		hl
040E9B CB 1E       0492*  	rr		(hl)
040E9D 2B          0493*  	dec		hl
040E9E CB 1E       0494*  	rr		(hl)
040EA0 23          0495*  	inc		hl
040EA1 23          0496*  	inc		hl
040EA2 1B          0497*  	dec		de
040EA3 18 EF       0498*  	jr		shr_loop
040EA5             0499*  shr_done:
040EA5 2A AA 0E 04 0500*  	ld		hl,(bitbuf1)	;collect result
040EA9 C9          0501*  	ret
040EAA             0502*  
040EAA             0503*  ;------------------------------------------------------------------------
040EAA             0504*  ; Scratch area for calculations
040EAA             0505*  ;------------------------------------------------------------------------
040EAA 00 00 00    0506*  bitbuf1:	dw24	0	;bit manipulation buffer 1
040EAD 00 00 00    0507*  bitbuf2:	dw24	0	;bit manipulation buffer 2
040EB0             0508*  
040EB0             0509*  ; ========== FROM maths24.inc ==========
040EB0             0510*  
040EB0             0511*  ; http://www.z80.info/pseudo-random.txt
040EB0             0512*  rand_8:
040EB0 C5          0513*      push bc
040EB1 3A C4 0E 04 0514*      ld a,(r_seed)
040EB5 4F          0515*      ld c,a
040EB6             0516*  
040EB6 0F          0517*      rrca ; multiply by 32
040EB7 0F          0518*      rrca
040EB8 0F          0519*      rrca
040EB9 EE 1F       0520*      xor 0x1f
040EBB             0521*  
040EBB 81          0522*      add a,c
040EBC DE FF       0523*      sbc a,255 ; carry
040EBE             0524*  
040EBE 32 C4 0E 04 0525*      ld (r_seed),a
040EC2 C1          0526*      pop bc
040EC3 C9          0527*      ret
040EC4 50          0528*  r_seed: defb $50
040EC5             0529*  
040EC5             0530*  ; tests the sign of 24-bit register hlu
040EC5             0531*  ; returns: a in [-1,0,1]
040EC5             0532*  ;   sign and zero flags as expected
040EC5             0533*  ;   hl is untouched
040EC5             0534*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
040EC5             0535*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
040EC5             0536*  get_sign_hlu:
040EC5             0537*      ; Load the upper byte of HLU into A
040EC5 E5          0538*      push hl
040EC6 DD 21 00 00 0539*      ld ix,0
       00          
040ECB DD 39       0540*      add ix,sp
040ECD DD 7E 02    0541*      ld a,(ix+2)
040ED0 E1          0542*      pop hl
040ED1             0543*  
040ED1 B5          0544*      or l                ; OR with the low byte to check if HL is zero
040ED2 C8          0545*      ret z               ; Return if HL is zero
040ED3             0546*  
040ED3 3E FF       0547*      ld a,-1             ; Send A back as -1 if the sign flag is set
040ED5 CB 7C       0548*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
040ED7 C0          0549*      ret nz              ; If set,HL is negative,return with the sign flag set
040ED8             0550*  
040ED8 3E 01       0551*      ld a,1             ; Otherwise,HL is positive
040EDA A7          0552*      and a               ; Reset the zero flag
040EDB C9          0553*      ret                 ; Return with A set to 1
040EDC             0554*  
040EDC             0555*  ; convert unsigned angles from a 360 to 255 degree circle
040EDC             0556*  ; inputs: uh.l is the angle360 in 16.8 fixed format
040EDC             0557*  ; outputs: uh.l is the angle255 in 16.8 fixed format
040EDC             0558*  ; destroys: TODO
040EDC             0559*  ; note: even though the inputs and outputs are 16.8 fixed format
040EDC             0560*  ;       precision is effectively limited to 8.8 fixed format
040EDC             0561*  deg_360_to_255:
040EDC             0562*  ; clear scratch buffer
040EDC 11 00 00 00 0563*  	ld de,0
040EE0 ED 53 0C 0F 0564*  	ld (@scratch),de
       04          
040EE5             0565*  ; divide uh.l by 360
040EE5 11 68 01 00 0566*  	ld de,360
040EE9             0567*  ; get integer portion
040EE9 CD 59 0D 04 0568*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
040EED ED 53 13 0F 0569*  	ld (@output+1),de ; shift result up one byte
       04          
040EF2             0570*  ; get fractional portion
040EF2 22 0D 0F 04 0571*  	ld (@scratch+1),hl ; shift remainder up one byte
040EF6 2A 0C 0F 04 0572*  	ld hl,(@scratch)
040EFA 11 68 01 00 0573*  	ld de,360
040EFE CD 59 0D 04 0574*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
040F02 7B          0575*  	ld a,e ; lowest byte is all we need
040F03 32 12 0F 04 0576*  	ld (@output),a
040F07             0577*  ; we want the low 3 bytes for 16.8 output
040F07 2A 12 0F 04 0578*  	ld hl,(@output)
040F0B C9          0579*  	ret
040F0C             0580*  @scratch: ds 6 ; scratch buffer for shifting bytes
040F12             0581*  @output: ds 6 ; scratch buffer to accumulate output
040F18             0582*  
040F18             0583*  ; 16.8 fixed inputs / outputs
040F18             0584*  ; takes: uh.l as angle in degrees 256
040F18             0585*  ;        ud.e as radius
040F18             0586*  ; returns ub.c as dx, ud.e as dy
040F18             0587*  ;        displacements from origin (0,0)
040F18             0588*  ; destroys: everything except indexes
040F18             0589*  polar_to_cartesian:
040F18             0590*  ; back up input parameters
040F18 22 03 0D 04 0591*      ld (arith24uhl), hl
040F1C ED 53 0F 0D 0592*      ld (arith24ude), de
       04          
040F21             0593*  ; compute dx = sin(uh.l) * ud.e
040F21 CD 50 0F 04 0594*      call sin168
040F25 E5          0595*      push hl
040F26 C1          0596*      pop bc          ; ub.c = sin(uh.l)
040F27 ED 5B 0F 0D 0597*  	ld de, (arith24ude)   ; get radius back
       04          
040F2C CD 83 0D 04 0598*  	call smul168    ; uh.l = ub.c * ud.e = dx
040F30 E5          0599*      push hl         ; store dx for output
040F31             0600*  ; compute dy = -cos(uh.l) * ud.e
040F31 2A 03 0D 04 0601*      ld hl, (arith24uhl)
040F35 CD 4B 0F 04 0602*      call cos168
040F39 CD 74 17 04 0603*  	call neg_hlu    ; invert dy for screen coords convention
040F3D E5          0604*      push hl
040F3E C1          0605*      pop bc          ; ub.c = -cos(uh.l)
040F3F ED 5B 0F 0D 0606*      ld de, (arith24ude)   ; get radius back
       04          
040F44 CD 83 0D 04 0607*      call smul168    ; uh.l = ub.c * ud.e = dy
040F48 EB          0608*      ex de, hl       ; de = dy for output
040F49 C1          0609*      pop bc          ; bc = dx for output
040F4A             0610*  ; and out
040F4A C9          0611*      ret
040F4B             0612*  
040F4B             0613*  ; fixed 16.8 routine
040F4B             0614*  ; cos(uh.l) --> uh.l
040F4B             0615*  ; destroys: de
040F4B             0616*  cos168:
040F4B             0617*  ; for cos we simply increment the angle by 90 degrees
040F4B             0618*  ; or 0x004000 in 16.8 degrees256
040F4B             0619*  ; which makes it a sin problem
040F4B 11 00 40 00 0620*      ld de,0x004000
040F4F 19          0621*      add hl,de ; modulo 256 happens below
040F50             0622*  ; fall through to sin168
040F50             0623*  ; ---------------------
040F50             0624*  ; fixed 16.8 routine
040F50             0625*  ; sin(uh.l) --> uh.l
040F50             0626*  ; destroys: de
040F50             0627*  sin168:
040F50             0628*  ; h contains the integer portion of our angle
040F50             0629*  ; we multiply it by three to get our lookup table index
040F50 2E 03       0630*      ld l,3
040F52 ED 6C       0631*      mlt hl ; gosh that is handy
040F54 11 00 00 00 0632*      ld de,0 ; clear deu
040F58 54          0633*      ld d,h ; copy hl to de
040F59 5D          0634*      ld e,l ; de contains our index
040F5A 21 61 11 04 0635*      ld hl,sin_lut_168 ; grab the lut address
040F5E 19          0636*      add hl,de ; bump hl by the index
040F5F ED 27       0637*      ld hl,(hl) ; don't try this on a z80!
040F61 C9          0638*      ret ; and out
040F62             0639*  
040F62             0640*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040F62             0641*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040F62             0642*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040F62             0643*  ;         also populates scratch locations dx168 and dy168
040F62             0644*  ; destroys: a,hl,bc,de
040F62             0645*  dxy168:
040F62             0646*  ; compute dx = x1-x0
040F62 AF          0647*      xor a ; clear carry
040F63 DD E5       0648*      push ix ; move ix to hl via the stack
040F65 E1          0649*      pop hl ; hl = x1
040F66 ED 42       0650*      sbc hl,bc ; hl = dx
040F68 22 BD 0F 04 0651*      ld (dx168),hl ; dx to scratch
040F6C             0652*  ; compute dy = y1-y0
040F6C AF          0653*      xor a ; clear carry
040F6D FD E5       0654*      push iy ; move iy to hl via the stack
040F6F E1          0655*      pop hl ; hl = y1
040F70 ED 52       0656*      sbc hl,de ; hl = dy
040F72 22 C3 0F 04 0657*      ld (dy168),hl ; dy to scratch
040F76             0658*  ; populate output registers and return
040F76 EB          0659*      ex de,hl        ; ud.e = dy
040F77 ED 4B BD 0F 0660*      ld bc,(dx168)   ; ub.c = dx
       04          
040F7C C9          0661*      ret
040F7D             0662*  
040F7D             0663*  ; compute the euclidian distance between two cartesian coordinates
040F7D             0664*  ; using the formula d = sqrt(dx^2+dy^2
040F7D             0665*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040F7D             0666*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040F7D             0667*  ; output; uh.l is the 16.8 fixed format distance
040F7D             0668*  ;       dx168/y are the 16.8 fixed format dx and dy
040F7D             0669*  ; destroys: a,hl,bc,de
040F7D             0670*  distance168:
040F7D             0671*  ; compute dx = x1-x0
040F7D AF          0672*      xor a ; clear carry
040F7E DD E5       0673*      push ix ; move ix to hl via the stack
040F80 E1          0674*      pop hl ; hl = x1
040F81 ED 42       0675*      sbc hl,bc ; hl = dx
040F83 22 BD 0F 04 0676*      ld (dx168),hl ; dx to scratch
040F87             0677*  ; ; test dx for overflow
040F87             0678*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
040F87             0679*  ; 	ex de,hl
040F87             0680*  ; 	sbc hl,de ; test for overflow
040F87             0681*  ; 	push af ; carry indicates overflow
040F87             0682*  ; compute dy = y1-y0
040F87 AF          0683*      xor a ; clear carry
040F88 FD E5       0684*      push iy ; move iy to hl via the stack
040F8A E1          0685*      pop hl ; hl = y1
040F8B ED 52       0686*      sbc hl,de ; hl = dy
040F8D 22 C3 0F 04 0687*      ld (dy168),hl ; dy to scratch
040F91             0688*  ; ; test dy for overflow
040F91             0689*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
040F91             0690*  ; 	ex de,hl
040F91             0691*  ; 	sbc hl,de ; test for overflow
040F91             0692*  ; 	push af ; carry indicates overflow
040F91             0693*  ; compute dy^2
040F91 2A C3 0F 04 0694*  	ld hl,(dy168)
040F95 CD 64 17 04 0695*      call abs_hlu  ; make dy positive so we can use unsigned multiply
040F99             0696*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
040F99 E5          0697*      push hl ; load hl/2 to bc via the stack
040F9A C1          0698*      pop bc ; bc = dy/2
040F9B EB          0699*      ex de,hl ; de = dy/2
040F9C CD 7D 0D 04 0700*      call umul168 ; uh.l = dy^2/2
040FA0 E5          0701*      push hl ; dy^2/2 to the stack
040FA1             0702*  ; compute dx^2
040FA1 2A BD 0F 04 0703*      ld hl,(dx168) ; get back dx
040FA5 CD 64 17 04 0704*      call abs_hlu  ; make dx positive so we can use unsigned multiply
040FA9             0705*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
040FA9 E5          0706*      push hl ; load hl/2 to bc via the stack
040FAA C1          0707*      pop bc ; bc = dx/2
040FAB EB          0708*      ex de,hl ; de = dx/2
040FAC CD 7D 0D 04 0709*      call umul168 ; uh.l = dx^2/2
040FB0             0710*  ; commpute dy^2+dx^2
040FB0 D1          0711*      pop de ; get back dx^2/2
040FB1 19          0712*      add hl,de ; hl = dx^2/2+dy^2/2
040FB2             0713*  ; compute sqrt(dx^2/2+dy^2/2)
040FB2 CD 76 10 04 0714*      call sqrt168 ; uh.l = distance/2
040FB6             0715*      ; add hl,hl ; hl = distance
040FB6             0716*  ; ; check for overflow
040FB6             0717*  ; 	pop af ; get back the overflow flags
040FB6             0718*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
040FB6             0719*  ; 	ld b,a ; save the overflow flag
040FB6             0720*  ; 	pop af ; get back the overflow flags
040FB6             0721*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
040FB6             0722*  ; 	add a,b ; if a != 0 then we had overflow
040FB6             0723*  ;     ret z ; no overflow we're done
040FB6             0724*  ; @overflow:
040FB6             0725*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
040FB6 C9          0726*  	ret
040FB7             0727*  @scratch: ds 6
040FBD             0728*  dx168: ds 6
040FC3             0729*  dy168: ds 6
040FC9             0730*  
040FC9             0731*  ; atan2(ub.c,ud.e) --> uh.l
040FC9             0732*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040FC9             0733*  ;   whether inputs are integers or fractional doesn't matter
040FC9             0734*  ;   so long as the sign bit of the upper byte is correct
040FC9             0735*  ; output: uh.l is the 16.8 fixed angle in degrees 256
040FC9             0736*  ; angles are COMPASS HEADINGS based on
040FC9             0737*  ; screen coordinate conventions,where the y axis is flipped
040FC9             0738*  ; #E0 315      0       45 #20
040FC9             0739*  ;        -x,-y | +x,-y
040FC9             0740*  ; #C0 270------+------ 90 #40
040FC9             0741*  ;        -x,+y | +x,+y
040FC9             0742*  ; #A0 225   180 #80   135 #60
040FC9             0743*  atan2_168game:
040FC9             0744*  ; get signs and make everything positive
040FC9             0745*  ; get abs(x) and store its original sign
040FC9 C5          0746*      push bc
040FCA E1          0747*      pop hl
040FCB CD 64 17 04 0748*      call abs_hlu ; if x was negative this also sets the sign flag
040FCF E5          0749*      push hl ; store abs(x)
040FD0 C1          0750*      pop bc ; bc = abs(x)
040FD1 F5          0751*      push af ; store sign of x
040FD2             0752*  ; get abs(y) and store its original sign
040FD2 EB          0753*      ex de,hl ; hl = y
040FD3 CD 64 17 04 0754*      call abs_hlu ; if y was negative this also sets the sign flag
040FD7 EB          0755*      ex de,hl ; de = abs(y)
040FD8 F5          0756*      push af ; store sign of y
040FD9             0757*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
040FD9             0758*  ; this ensures that our lookup value is between 0 and 1 inclusive
040FD9 AF          0759*      xor a ; clear the carry flag
040FDA D5          0760*      push de
040FDB E1          0761*      pop hl
040FDC ED 42       0762*      sbc hl,bc
040FDE F5          0763*      push af ; save sign of de - bc
040FDF F2 E8 0F 04 0764*      jp p,@1 ; bc <= de, so we skip ahead
040FE3             0765*  ; otherwise we swap bc and de
040FE3 C5          0766*      push bc
040FE4 E1          0767*      pop hl
040FE5 EB          0768*      ex de,hl
040FE6 E5          0769*      push hl
040FE7 C1          0770*      pop bc
040FE8             0771*  @1:
040FE8             0772*  ; now we're ready to snag our preliminary result
040FE8 CD 56 10 04 0773*      call atan_168game ; uh.l comes back with prelim result
040FEC             0774*  ; now we adjust uh.l based on sign of de - bc
040FEC F1          0775*      pop af
040FED F2 F9 0F 04 0776*      jp p,@2 ; bc <= de,so we skip ahead
040FF1 EB          0777*      ex de,hl
040FF2 21 00 40 00 0778*      ld hl,0x004000 ; 90 degrees
040FF6 AF          0779*      xor a ; clear the carry flag
040FF7 ED 52       0780*      sbc hl,de ; subtract result from 90 degrees
040FF9             0781*      ; ld de,0 ; prep to clear hlu
040FF9             0782*      ; ld d,h
040FF9             0783*      ; ld e,l
040FF9             0784*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
040FF9             0785*      ; fall through
040FF9             0786*  @2:
040FF9             0787*  ; now the fun part of adjusting the result
040FF9             0788*  ; based on which quadrant (x,y) is in
040FF9             0789*  ; #E0 315      0       45 #20
040FF9             0790*  ;        -x,-y | +x,-y
040FF9             0791*  ; #C0 270------+------ 90 #40
040FF9             0792*  ;        -x,+y | +x,+y
040FF9             0793*  ; #A0 225   180 #80   135 #60
040FF9 F1          0794*      pop af ; sign of y
040FFA CA 37 10 04 0795*      jp z,@y_zero
040FFE F2 17 10 04 0796*      jp p,@y_pos
041002             0797*  ; y neg,check x
041002 F1          0798*      pop af ; sign of x
041003 CA 11 10 04 0799*      jp z,@y_neg_x_zero
041007 F2 16 10 04 0800*      jp p,@y_neg_x_pos
04100B             0801*  ; y neg,x neg
04100B             0802*  ; angle is 270-360
04100B             0803*  ; negating the intermediate does the trick
04100B CD 74 17 04 0804*      call neg_hlu
04100F 18 31       0805*      jr @zero_hlu
041011             0806*  
041011             0807*  @y_neg_x_zero:
041011             0808*  ; y neg,x zero
041011             0809*  ; angle is 0
041011 21 00 00 00 0810*      ld hl,0
041015 C9          0811*      ret
041016             0812*  @y_neg_x_pos:
041016             0813*  ; y neg,x pos
041016             0814*  ; angle is 0 to 90
041016             0815*  ; so we're good
041016 C9          0816*      ret
041017             0817*  
041017             0818*  @y_pos:
041017 F1          0819*      pop af ; sign of x
041018 CA 27 10 04 0820*      jp z,@y_pos_x_zero
04101C F2 2C 10 04 0821*      jp p,@y_pos_x_pos
041020             0822*  ; y pos,x neg
041020             0823*  ; angle is 180-270
041020             0824*  ; so we add 180 to intermediate
041020 11 00 80 00 0825*      ld de,0x008000
041024 19          0826*      add hl,de
041025 18 1B       0827*      jr @zero_hlu
041027             0828*  @y_pos_x_zero:
041027             0829*  ; y pos,x zero
041027             0830*  ; angle is 180
041027 21 00 80 00 0831*      ld hl,0x008000
04102B C9          0832*      ret
04102C             0833*  @y_pos_x_pos:
04102C             0834*  ; y pos,x pos
04102C             0835*  ; angle is 90-180
04102C             0836*  ; neg the intermediate and add 180 degrees
04102C CD 74 17 04 0837*      call neg_hlu
041030 11 00 80 00 0838*      ld de,0x008000
041034 19          0839*      add hl,de
041035 18 0B       0840*      jr @zero_hlu
041037             0841*  
041037             0842*  @y_zero:
041037 F1          0843*      pop af ; sign of x
041038 FA 3D 10 04 0844*      jp m,@y_zero_x_neg
04103C             0845*  ; y zero,x pos
04103C             0846*  ; angle is 90,nothing to do
04103C C9          0847*      ret
04103D             0848*  @y_zero_x_neg:
04103D             0849*  ; y zero ,x neg
04103D             0850*  ; angle is 270
04103D 21 00 C0 00 0851*      ld hl,0x00C000
041041 C9          0852*      ret
041042             0853*  @zero_hlu:
041042 AF          0854*      xor a
041043 22 50 10 04 0855*      ld (@scratch),hl
041047 32 52 10 04 0856*      ld (@scratch+2),a
04104B 2A 50 10 04 0857*      ld hl,(@scratch)
04104F C9          0858*      ret
041050             0859*  @scratch: ds 6
041056             0860*  
041056             0861*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
041056             0862*  ; output: uh.l is the 16.8 fixed format angle
041056             0863*  ; destroys: a,hl,bc,de
041056             0864*  ; the following note was written by github copilot:
041056             0865*  ; note: this routine is a bit of a hack
041056             0866*  ;      but it works
041056             0867*  ;      and it's fast
041056             0868*  ;      and it's small
041056             0869*  ;      and it's accurate
041056             0870*  ;      and it's easy to understand
041056             0871*  ;      and it's easy to modify
041056             0872*  ;      and it's easy to use
041056             0873*  ;      and it's easy to remember
041056             0874*  ;      and it's easy to love
041056             0875*  ;      and it's easy to hate
041056             0876*  ;      and it's easy to ignore
041056             0877*  ;      and it's easy to forget
041056             0878*  ;      and it's easy to remember
041056             0879*  ;      and it's easy to forget
041056             0880*  ;      and it's easy to remember
041056             0881*  ;      (ok the bot is stuck in a loop)
041056             0882*  ; REAL NOTE: only works for angles from 0 to 45 degrees
041056             0883*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
041056             0884*  atan_168game:
041056             0885*  ; because we use compass headings instead of geometric angles
041056             0886*  ; we compute dx/dy which is 1/tan(theta) in the maths world
041056             0887*  ; we can do faster unsigned division here because we know dx and dy are positive
041056 CD BE 0D 04 0888*  	call udiv168 ; uh.l = dx/dy
04105A             0889*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
04105A             0890*  ; ; test uh.l for 0
04105A             0891*  ;     add hl,de
04105A             0892*  ;     or a
04105A             0893*  ;     sbc hl,de
04105A             0894*  ;     jr z,@is_zero
04105A             0895*  ; ; test uh.l for 1
04105A             0896*  ;     xor a ; clear carry
04105A             0897*  ;     ex de,hl
04105A             0898*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
04105A             0899*  ;     sbc hl,de
04105A             0900*  ;     jr z,@is_45
04105A             0901*  ; ; END TODO
04105A             0902*  
04105A             0903*  ; no special cases so we move on
04105A             0904*  ; l contains the fractional portion of tan(uh.l)
04105A             0905*  ; we multiply it by three to get our lookup table index
04105A 26 03       0906*      ld h,3
04105C ED 6C       0907*      mlt hl ; gosh that is handy
04105E 11 00 00 00 0908*      ld de,0 ; clear deu
041062 54          0909*      ld d,h ; copy hl to de
041063 5D          0910*      ld e,l ; de contains our index
041064 21 61 14 04 0911*      ld hl,atan_lut_168 ; grab the lut address
041068 19          0912*      add hl,de ; bump hl by the index
041069 ED 27       0913*      ld hl,(hl) ; don't try this on a z80!
04106B C9          0914*      ret ; and out
04106C             0915*  @is_45:
04106C 21 00 20 00 0916*      ld hl,0x002000 ; 45 degrees decimal
041070 C9          0917*      ret
041071             0918*  ; for the case tan(0)
041071             0919*  @is_zero:
041071 21 00 00 00 0920*      ld hl,0x000000
041075 C9          0921*      ret
041076             0922*  
041076             0923*  ; Expects  ADL mode
041076             0924*  ; Inputs:  UH.L
041076             0925*  ; Outputs: UH.L is the 16.8 square root
041076             0926*  ;          UD.E is the difference inputHL-DE^2
041076             0927*  ;          c flag reset
041076             0928*  sqrt168:
041076 CD 80 10 04 0929*      call sqrt24
04107A EB          0930*      ex de,hl
04107B 29          0931*      add hl,hl
04107C 29          0932*      add hl,hl
04107D 29          0933*      add hl,hl
04107E 29          0934*      add hl,hl
04107F C9          0935*      ret
041080             0936*  
041080             0937*  ; Expects  ADL mode
041080             0938*  ; Inputs:  HL
041080             0939*  ; Outputs: DE is the integer square root
041080             0940*  ;          HL is the difference inputHL-DE^2
041080             0941*  ;          c flag reset
041080             0942*  sqrt24:
041080 AF          0943*      xor a
041081 45          0944*      ld b,l
041082 C5          0945*      push bc
041083 47          0946*      ld b,a
041084 57          0947*      ld d,a
041085 4F          0948*      ld c,a
041086 6F          0949*      ld l,a
041087 5F          0950*      ld e,a
041088             0951*  
041088             0952*      ;Iteration 1
041088 29          0953*      add hl,hl
041089 CB 11       0954*      rl c
04108B 29          0955*      add hl,hl
04108C CB 11       0956*      rl c
04108E 91          0957*      sub c
04108F 30 04       0958*      jr nc,$+6
041091 1C          0959*      inc e
041092 1C          0960*      inc e
041093 2F          0961*      cpl
041094 4F          0962*      ld c,a
041095             0963*  
041095             0964*      ;Iteration 2
041095 29          0965*      add hl,hl
041096 CB 11       0966*      rl c
041098 29          0967*      add hl,hl
041099 CB 11       0968*      rl c
04109B CB 13       0969*      rl e
04109D 7B          0970*      ld a,e
04109E 91          0971*      sub c
04109F 30 04       0972*      jr nc,$+6
0410A1 1C          0973*      inc e
0410A2 1C          0974*      inc e
0410A3 2F          0975*      cpl
0410A4 4F          0976*      ld c,a
0410A5             0977*  
0410A5             0978*      ;Iteration 3
0410A5 29          0979*      add hl,hl
0410A6 CB 11       0980*      rl c
0410A8 29          0981*      add hl,hl
0410A9 CB 11       0982*      rl c
0410AB CB 13       0983*      rl e
0410AD 7B          0984*      ld a,e
0410AE 91          0985*      sub c
0410AF 30 04       0986*      jr nc,$+6
0410B1 1C          0987*      inc e
0410B2 1C          0988*      inc e
0410B3 2F          0989*      cpl
0410B4 4F          0990*      ld c,a
0410B5             0991*  
0410B5             0992*      ;Iteration 4
0410B5 29          0993*      add hl,hl
0410B6 CB 11       0994*      rl c
0410B8 29          0995*      add hl,hl
0410B9 CB 11       0996*      rl c
0410BB CB 13       0997*      rl e
0410BD 7B          0998*      ld a,e
0410BE 91          0999*      sub c
0410BF 30 04       1000*      jr nc,$+6
0410C1 1C          1001*      inc e
0410C2 1C          1002*      inc e
0410C3 2F          1003*      cpl
0410C4 4F          1004*      ld c,a
0410C5             1005*  
0410C5             1006*      ;Iteration 5
0410C5 29          1007*      add hl,hl
0410C6 CB 11       1008*      rl c
0410C8 29          1009*      add hl,hl
0410C9 CB 11       1010*      rl c
0410CB CB 13       1011*      rl e
0410CD 7B          1012*      ld a,e
0410CE 91          1013*      sub c
0410CF 30 04       1014*      jr nc,$+6
0410D1 1C          1015*      inc e
0410D2 1C          1016*      inc e
0410D3 2F          1017*      cpl
0410D4 4F          1018*      ld c,a
0410D5             1019*  
0410D5             1020*      ;Iteration 6
0410D5 29          1021*      add hl,hl
0410D6 CB 11       1022*      rl c
0410D8 29          1023*      add hl,hl
0410D9 CB 11       1024*      rl c
0410DB CB 13       1025*      rl e
0410DD 7B          1026*      ld a,e
0410DE 91          1027*      sub c
0410DF 30 04       1028*      jr nc,$+6
0410E1 1C          1029*      inc e
0410E2 1C          1030*      inc e
0410E3 2F          1031*      cpl
0410E4 4F          1032*      ld c,a
0410E5             1033*  
0410E5             1034*      ;Iteration 7
0410E5 29          1035*      add hl,hl
0410E6 CB 11       1036*      rl c
0410E8 29          1037*      add hl,hl
0410E9 CB 11       1038*      rl c
0410EB CB 10       1039*      rl b
0410ED EB          1040*      ex de,hl
0410EE 29          1041*      add hl,hl
0410EF E5          1042*      push hl
0410F0 ED 42       1043*      sbc hl,bc
0410F2 30 06       1044*      jr nc,$+8
0410F4 7C          1045*      ld a,h
0410F5 2F          1046*      cpl
0410F6 47          1047*      ld b,a
0410F7 7D          1048*      ld a,l
0410F8 2F          1049*      cpl
0410F9 4F          1050*      ld c,a
0410FA E1          1051*      pop hl
0410FB 30 02       1052*      jr nc,$+4
0410FD 23          1053*      inc hl
0410FE 23          1054*      inc hl
0410FF EB          1055*      ex de,hl
041100             1056*  
041100             1057*      ;Iteration 8
041100 29          1058*      add hl,hl
041101 69          1059*      ld l,c
041102 60          1060*      ld h,b
041103 ED 6A       1061*      adc hl,hl
041105 ED 6A       1062*      adc hl,hl
041107 EB          1063*      ex de,hl
041108 29          1064*      add hl,hl
041109 ED 52       1065*      sbc hl,de
04110B 19          1066*      add hl,de
04110C EB          1067*      ex de,hl
04110D 30 04       1068*      jr nc,$+6
04110F ED 52       1069*      sbc hl,de
041111 13          1070*      inc de
041112 13          1071*      inc de
041113             1072*  
041113             1073*      ;Iteration 9
041113 F1          1074*      pop af
041114 17          1075*      rla
041115 ED 6A       1076*      adc hl,hl
041117 17          1077*      rla
041118 ED 6A       1078*      adc hl,hl
04111A EB          1079*      ex de,hl
04111B 29          1080*      add hl,hl
04111C ED 52       1081*      sbc hl,de
04111E 19          1082*      add hl,de
04111F EB          1083*      ex de,hl
041120 30 04       1084*      jr nc,$+6
041122 ED 52       1085*      sbc hl,de
041124 13          1086*      inc de
041125 13          1087*      inc de
041126             1088*  
041126             1089*      ;Iteration 10
041126 17          1090*      rla
041127 ED 6A       1091*      adc hl,hl
041129 17          1092*      rla
04112A ED 6A       1093*      adc hl,hl
04112C EB          1094*      ex de,hl
04112D 29          1095*      add hl,hl
04112E ED 52       1096*      sbc hl,de
041130 19          1097*      add hl,de
041131 EB          1098*      ex de,hl
041132 30 04       1099*      jr nc,$+6
041134 ED 52       1100*      sbc hl,de
041136 13          1101*      inc de
041137 13          1102*      inc de
041138             1103*  
041138             1104*      ;Iteration 11
041138 17          1105*      rla
041139 ED 6A       1106*      adc hl,hl
04113B 17          1107*      rla
04113C ED 6A       1108*      adc hl,hl
04113E EB          1109*      ex de,hl
04113F 29          1110*      add hl,hl
041140 ED 52       1111*      sbc hl,de
041142 19          1112*      add hl,de
041143 EB          1113*      ex de,hl
041144 30 04       1114*      jr nc,$+6
041146 ED 52       1115*      sbc hl,de
041148 13          1116*      inc de
041149 13          1117*      inc de
04114A             1118*  
04114A             1119*      ;Iteration 11
04114A 17          1120*      rla
04114B ED 6A       1121*      adc hl,hl
04114D 17          1122*      rla
04114E ED 6A       1123*      adc hl,hl
041150 EB          1124*      ex de,hl
041151 29          1125*      add hl,hl
041152 ED 52       1126*      sbc hl,de
041154 19          1127*      add hl,de
041155 EB          1128*      ex de,hl
041156 30 04       1129*      jr nc,$+6
041158 ED 52       1130*      sbc hl,de
04115A 13          1131*      inc de
04115B 13          1132*      inc de
04115C             1133*  
04115C CB 1A       1134*      rr d
04115E CB 1B       1135*      rr e
041160 C9          1136*      ret
041161             1137*  
041161             1138*  sin_lut_168:
041161 00 00 00    1139*  	dl 0x000000 ; 0.000 00, 0.000
041164 06 00 00    1140*  	dl 0x000006 ; 1.406 01, 0.025
041167 0C 00 00    1141*  	dl 0x00000C ; 2.813 02, 0.049
04116A 12 00 00    1142*  	dl 0x000012 ; 4.219 03, 0.074
04116D 19 00 00    1143*  	dl 0x000019 ; 5.625 04, 0.098
041170 1F 00 00    1144*  	dl 0x00001F ; 7.031 05, 0.122
041173 25 00 00    1145*  	dl 0x000025 ; 8.438 06, 0.147
041176 2B 00 00    1146*  	dl 0x00002B ; 9.844 07, 0.171
041179 31 00 00    1147*  	dl 0x000031 ; 11.250 08, 0.195
04117C 38 00 00    1148*  	dl 0x000038 ; 12.656 09, 0.219
04117F 3E 00 00    1149*  	dl 0x00003E ; 14.063 0A, 0.243
041182 44 00 00    1150*  	dl 0x000044 ; 15.469 0B, 0.267
041185 4A 00 00    1151*  	dl 0x00004A ; 16.875 0C, 0.290
041188 50 00 00    1152*  	dl 0x000050 ; 18.281 0D, 0.314
04118B 56 00 00    1153*  	dl 0x000056 ; 19.688 0E, 0.337
04118E 5C 00 00    1154*  	dl 0x00005C ; 21.094 0F, 0.360
041191 61 00 00    1155*  	dl 0x000061 ; 22.500 10, 0.383
041194 67 00 00    1156*  	dl 0x000067 ; 23.906 11, 0.405
041197 6D 00 00    1157*  	dl 0x00006D ; 25.313 12, 0.428
04119A 73 00 00    1158*  	dl 0x000073 ; 26.719 13, 0.450
04119D 78 00 00    1159*  	dl 0x000078 ; 28.125 14, 0.471
0411A0 7E 00 00    1160*  	dl 0x00007E ; 29.531 15, 0.493
0411A3 83 00 00    1161*  	dl 0x000083 ; 30.938 16, 0.514
0411A6 88 00 00    1162*  	dl 0x000088 ; 32.344 17, 0.535
0411A9 8E 00 00    1163*  	dl 0x00008E ; 33.750 18, 0.556
0411AC 93 00 00    1164*  	dl 0x000093 ; 35.156 19, 0.576
0411AF 98 00 00    1165*  	dl 0x000098 ; 36.563 1A, 0.596
0411B2 9D 00 00    1166*  	dl 0x00009D ; 37.969 1B, 0.615
0411B5 A2 00 00    1167*  	dl 0x0000A2 ; 39.375 1C, 0.634
0411B8 A7 00 00    1168*  	dl 0x0000A7 ; 40.781 1D, 0.653
0411BB AB 00 00    1169*  	dl 0x0000AB ; 42.188 1E, 0.672
0411BE B0 00 00    1170*  	dl 0x0000B0 ; 43.594 1F, 0.690
0411C1 B5 00 00    1171*  	dl 0x0000B5 ; 45.000 20, 0.707
0411C4 B9 00 00    1172*  	dl 0x0000B9 ; 46.406 21, 0.724
0411C7 BD 00 00    1173*  	dl 0x0000BD ; 47.813 22, 0.741
0411CA C1 00 00    1174*  	dl 0x0000C1 ; 49.219 23, 0.757
0411CD C5 00 00    1175*  	dl 0x0000C5 ; 50.625 24, 0.773
0411D0 C9 00 00    1176*  	dl 0x0000C9 ; 52.031 25, 0.788
0411D3 CD 00 00    1177*  	dl 0x0000CD ; 53.438 26, 0.803
0411D6 D1 00 00    1178*  	dl 0x0000D1 ; 54.844 27, 0.818
0411D9 D4 00 00    1179*  	dl 0x0000D4 ; 56.250 28, 0.831
0411DC D8 00 00    1180*  	dl 0x0000D8 ; 57.656 29, 0.845
0411DF DB 00 00    1181*  	dl 0x0000DB ; 59.063 2A, 0.858
0411E2 DE 00 00    1182*  	dl 0x0000DE ; 60.469 2B, 0.870
0411E5 E1 00 00    1183*  	dl 0x0000E1 ; 61.875 2C, 0.882
0411E8 E4 00 00    1184*  	dl 0x0000E4 ; 63.281 2D, 0.893
0411EB E7 00 00    1185*  	dl 0x0000E7 ; 64.688 2E, 0.904
0411EE EA 00 00    1186*  	dl 0x0000EA ; 66.094 2F, 0.914
0411F1 EC 00 00    1187*  	dl 0x0000EC ; 67.500 30, 0.924
0411F4 EE 00 00    1188*  	dl 0x0000EE ; 68.906 31, 0.933
0411F7 F1 00 00    1189*  	dl 0x0000F1 ; 70.313 32, 0.942
0411FA F3 00 00    1190*  	dl 0x0000F3 ; 71.719 33, 0.950
0411FD F4 00 00    1191*  	dl 0x0000F4 ; 73.125 34, 0.957
041200 F6 00 00    1192*  	dl 0x0000F6 ; 74.531 35, 0.964
041203 F8 00 00    1193*  	dl 0x0000F8 ; 75.938 36, 0.970
041206 F9 00 00    1194*  	dl 0x0000F9 ; 77.344 37, 0.976
041209 FB 00 00    1195*  	dl 0x0000FB ; 78.750 38, 0.981
04120C FC 00 00    1196*  	dl 0x0000FC ; 80.156 39, 0.985
04120F FD 00 00    1197*  	dl 0x0000FD ; 81.563 3A, 0.989
041212 FE 00 00    1198*  	dl 0x0000FE ; 82.969 3B, 0.992
041215 FE 00 00    1199*  	dl 0x0000FE ; 84.375 3C, 0.995
041218 FF 00 00    1200*  	dl 0x0000FF ; 85.781 3D, 0.997
04121B FF 00 00    1201*  	dl 0x0000FF ; 87.188 3E, 0.999
04121E FF 00 00    1202*  	dl 0x0000FF ; 88.594 3F, 1.000
041221 00 01 00    1203*  	dl 0x000100 ; 90.000 40, 1.000
041224 FF 00 00    1204*  	dl 0x0000FF ; 91.406 41, 1.000
041227 FF 00 00    1205*  	dl 0x0000FF ; 92.813 42, 0.999
04122A FF 00 00    1206*  	dl 0x0000FF ; 94.219 43, 0.997
04122D FE 00 00    1207*  	dl 0x0000FE ; 95.625 44, 0.995
041230 FE 00 00    1208*  	dl 0x0000FE ; 97.031 45, 0.992
041233 FD 00 00    1209*  	dl 0x0000FD ; 98.438 46, 0.989
041236 FC 00 00    1210*  	dl 0x0000FC ; 99.844 47, 0.985
041239 FB 00 00    1211*  	dl 0x0000FB ; 101.250 48, 0.981
04123C F9 00 00    1212*  	dl 0x0000F9 ; 102.656 49, 0.976
04123F F8 00 00    1213*  	dl 0x0000F8 ; 104.063 4A, 0.970
041242 F6 00 00    1214*  	dl 0x0000F6 ; 105.469 4B, 0.964
041245 F4 00 00    1215*  	dl 0x0000F4 ; 106.875 4C, 0.957
041248 F3 00 00    1216*  	dl 0x0000F3 ; 108.281 4D, 0.950
04124B F1 00 00    1217*  	dl 0x0000F1 ; 109.688 4E, 0.942
04124E EE 00 00    1218*  	dl 0x0000EE ; 111.094 4F, 0.933
041251 EC 00 00    1219*  	dl 0x0000EC ; 112.500 50, 0.924
041254 EA 00 00    1220*  	dl 0x0000EA ; 113.906 51, 0.914
041257 E7 00 00    1221*  	dl 0x0000E7 ; 115.313 52, 0.904
04125A E4 00 00    1222*  	dl 0x0000E4 ; 116.719 53, 0.893
04125D E1 00 00    1223*  	dl 0x0000E1 ; 118.125 54, 0.882
041260 DE 00 00    1224*  	dl 0x0000DE ; 119.531 55, 0.870
041263 DB 00 00    1225*  	dl 0x0000DB ; 120.938 56, 0.858
041266 D8 00 00    1226*  	dl 0x0000D8 ; 122.344 57, 0.845
041269 D4 00 00    1227*  	dl 0x0000D4 ; 123.750 58, 0.831
04126C D1 00 00    1228*  	dl 0x0000D1 ; 125.156 59, 0.818
04126F CD 00 00    1229*  	dl 0x0000CD ; 126.563 5A, 0.803
041272 C9 00 00    1230*  	dl 0x0000C9 ; 127.969 5B, 0.788
041275 C5 00 00    1231*  	dl 0x0000C5 ; 129.375 5C, 0.773
041278 C1 00 00    1232*  	dl 0x0000C1 ; 130.781 5D, 0.757
04127B BD 00 00    1233*  	dl 0x0000BD ; 132.188 5E, 0.741
04127E B9 00 00    1234*  	dl 0x0000B9 ; 133.594 5F, 0.724
041281 B5 00 00    1235*  	dl 0x0000B5 ; 135.000 60, 0.707
041284 B0 00 00    1236*  	dl 0x0000B0 ; 136.406 61, 0.690
041287 AB 00 00    1237*  	dl 0x0000AB ; 137.813 62, 0.672
04128A A7 00 00    1238*  	dl 0x0000A7 ; 139.219 63, 0.653
04128D A2 00 00    1239*  	dl 0x0000A2 ; 140.625 64, 0.634
041290 9D 00 00    1240*  	dl 0x00009D ; 142.031 65, 0.615
041293 98 00 00    1241*  	dl 0x000098 ; 143.438 66, 0.596
041296 93 00 00    1242*  	dl 0x000093 ; 144.844 67, 0.576
041299 8E 00 00    1243*  	dl 0x00008E ; 146.250 68, 0.556
04129C 88 00 00    1244*  	dl 0x000088 ; 147.656 69, 0.535
04129F 83 00 00    1245*  	dl 0x000083 ; 149.063 6A, 0.514
0412A2 7E 00 00    1246*  	dl 0x00007E ; 150.469 6B, 0.493
0412A5 78 00 00    1247*  	dl 0x000078 ; 151.875 6C, 0.471
0412A8 73 00 00    1248*  	dl 0x000073 ; 153.281 6D, 0.450
0412AB 6D 00 00    1249*  	dl 0x00006D ; 154.688 6E, 0.428
0412AE 67 00 00    1250*  	dl 0x000067 ; 156.094 6F, 0.405
0412B1 61 00 00    1251*  	dl 0x000061 ; 157.500 70, 0.383
0412B4 5C 00 00    1252*  	dl 0x00005C ; 158.906 71, 0.360
0412B7 56 00 00    1253*  	dl 0x000056 ; 160.313 72, 0.337
0412BA 50 00 00    1254*  	dl 0x000050 ; 161.719 73, 0.314
0412BD 4A 00 00    1255*  	dl 0x00004A ; 163.125 74, 0.290
0412C0 44 00 00    1256*  	dl 0x000044 ; 164.531 75, 0.267
0412C3 3E 00 00    1257*  	dl 0x00003E ; 165.938 76, 0.243
0412C6 38 00 00    1258*  	dl 0x000038 ; 167.344 77, 0.219
0412C9 31 00 00    1259*  	dl 0x000031 ; 168.750 78, 0.195
0412CC 2B 00 00    1260*  	dl 0x00002B ; 170.156 79, 0.171
0412CF 25 00 00    1261*  	dl 0x000025 ; 171.563 7A, 0.147
0412D2 1F 00 00    1262*  	dl 0x00001F ; 172.969 7B, 0.122
0412D5 19 00 00    1263*  	dl 0x000019 ; 174.375 7C, 0.098
0412D8 12 00 00    1264*  	dl 0x000012 ; 175.781 7D, 0.074
0412DB 0C 00 00    1265*  	dl 0x00000C ; 177.188 7E, 0.049
0412DE 06 00 00    1266*  	dl 0x000006 ; 178.594 7F, 0.025
0412E1 00 00 00    1267*  	dl 0x000000 ; 180.000 80, 0.000
0412E4 FA FF FF    1268*  	dl 0xFFFFFA ; 181.406 81, -0.025
0412E7 F4 FF FF    1269*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0412EA EE FF FF    1270*  	dl 0xFFFFEE ; 184.219 83, -0.074
0412ED E7 FF FF    1271*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0412F0 E1 FF FF    1272*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0412F3 DB FF FF    1273*  	dl 0xFFFFDB ; 188.438 86, -0.147
0412F6 D5 FF FF    1274*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0412F9 CF FF FF    1275*  	dl 0xFFFFCF ; 191.250 88, -0.195
0412FC C8 FF FF    1276*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0412FF C2 FF FF    1277*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
041302 BC FF FF    1278*  	dl 0xFFFFBC ; 195.469 8B, -0.267
041305 B6 FF FF    1279*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
041308 B0 FF FF    1280*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04130B AA FF FF    1281*  	dl 0xFFFFAA ; 199.688 8E, -0.337
04130E A4 FF FF    1282*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
041311 9F FF FF    1283*  	dl 0xFFFF9F ; 202.500 90, -0.383
041314 99 FF FF    1284*  	dl 0xFFFF99 ; 203.906 91, -0.405
041317 93 FF FF    1285*  	dl 0xFFFF93 ; 205.313 92, -0.428
04131A 8D FF FF    1286*  	dl 0xFFFF8D ; 206.719 93, -0.450
04131D 88 FF FF    1287*  	dl 0xFFFF88 ; 208.125 94, -0.471
041320 82 FF FF    1288*  	dl 0xFFFF82 ; 209.531 95, -0.493
041323 7D FF FF    1289*  	dl 0xFFFF7D ; 210.938 96, -0.514
041326 78 FF FF    1290*  	dl 0xFFFF78 ; 212.344 97, -0.535
041329 72 FF FF    1291*  	dl 0xFFFF72 ; 213.750 98, -0.556
04132C 6D FF FF    1292*  	dl 0xFFFF6D ; 215.156 99, -0.576
04132F 68 FF FF    1293*  	dl 0xFFFF68 ; 216.563 9A, -0.596
041332 63 FF FF    1294*  	dl 0xFFFF63 ; 217.969 9B, -0.615
041335 5E FF FF    1295*  	dl 0xFFFF5E ; 219.375 9C, -0.634
041338 59 FF FF    1296*  	dl 0xFFFF59 ; 220.781 9D, -0.653
04133B 55 FF FF    1297*  	dl 0xFFFF55 ; 222.188 9E, -0.672
04133E 50 FF FF    1298*  	dl 0xFFFF50 ; 223.594 9F, -0.690
041341 4B FF FF    1299*  	dl 0xFFFF4B ; 225.000 A0, -0.707
041344 47 FF FF    1300*  	dl 0xFFFF47 ; 226.406 A1, -0.724
041347 43 FF FF    1301*  	dl 0xFFFF43 ; 227.813 A2, -0.741
04134A 3F FF FF    1302*  	dl 0xFFFF3F ; 229.219 A3, -0.757
04134D 3B FF FF    1303*  	dl 0xFFFF3B ; 230.625 A4, -0.773
041350 37 FF FF    1304*  	dl 0xFFFF37 ; 232.031 A5, -0.788
041353 33 FF FF    1305*  	dl 0xFFFF33 ; 233.438 A6, -0.803
041356 2F FF FF    1306*  	dl 0xFFFF2F ; 234.844 A7, -0.818
041359 2C FF FF    1307*  	dl 0xFFFF2C ; 236.250 A8, -0.831
04135C 28 FF FF    1308*  	dl 0xFFFF28 ; 237.656 A9, -0.845
04135F 25 FF FF    1309*  	dl 0xFFFF25 ; 239.063 AA, -0.858
041362 22 FF FF    1310*  	dl 0xFFFF22 ; 240.469 AB, -0.870
041365 1F FF FF    1311*  	dl 0xFFFF1F ; 241.875 AC, -0.882
041368 1C FF FF    1312*  	dl 0xFFFF1C ; 243.281 AD, -0.893
04136B 19 FF FF    1313*  	dl 0xFFFF19 ; 244.688 AE, -0.904
04136E 16 FF FF    1314*  	dl 0xFFFF16 ; 246.094 AF, -0.914
041371 14 FF FF    1315*  	dl 0xFFFF14 ; 247.500 B0, -0.924
041374 12 FF FF    1316*  	dl 0xFFFF12 ; 248.906 B1, -0.933
041377 0F FF FF    1317*  	dl 0xFFFF0F ; 250.313 B2, -0.942
04137A 0D FF FF    1318*  	dl 0xFFFF0D ; 251.719 B3, -0.950
04137D 0C FF FF    1319*  	dl 0xFFFF0C ; 253.125 B4, -0.957
041380 0A FF FF    1320*  	dl 0xFFFF0A ; 254.531 B5, -0.964
041383 08 FF FF    1321*  	dl 0xFFFF08 ; 255.938 B6, -0.970
041386 07 FF FF    1322*  	dl 0xFFFF07 ; 257.344 B7, -0.976
041389 05 FF FF    1323*  	dl 0xFFFF05 ; 258.750 B8, -0.981
04138C 04 FF FF    1324*  	dl 0xFFFF04 ; 260.156 B9, -0.985
04138F 03 FF FF    1325*  	dl 0xFFFF03 ; 261.563 BA, -0.989
041392 02 FF FF    1326*  	dl 0xFFFF02 ; 262.969 BB, -0.992
041395 02 FF FF    1327*  	dl 0xFFFF02 ; 264.375 BC, -0.995
041398 01 FF FF    1328*  	dl 0xFFFF01 ; 265.781 BD, -0.997
04139B 01 FF FF    1329*  	dl 0xFFFF01 ; 267.188 BE, -0.999
04139E 01 FF FF    1330*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0413A1 00 FF FF    1331*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0413A4 01 FF FF    1332*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0413A7 01 FF FF    1333*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0413AA 01 FF FF    1334*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0413AD 02 FF FF    1335*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0413B0 02 FF FF    1336*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0413B3 03 FF FF    1337*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0413B6 04 FF FF    1338*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0413B9 05 FF FF    1339*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0413BC 07 FF FF    1340*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0413BF 08 FF FF    1341*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0413C2 0A FF FF    1342*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0413C5 0C FF FF    1343*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0413C8 0D FF FF    1344*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0413CB 0F FF FF    1345*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0413CE 12 FF FF    1346*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0413D1 14 FF FF    1347*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0413D4 16 FF FF    1348*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0413D7 19 FF FF    1349*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0413DA 1C FF FF    1350*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0413DD 1F FF FF    1351*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0413E0 22 FF FF    1352*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0413E3 25 FF FF    1353*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0413E6 28 FF FF    1354*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0413E9 2C FF FF    1355*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0413EC 2F FF FF    1356*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0413EF 33 FF FF    1357*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0413F2 37 FF FF    1358*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0413F5 3B FF FF    1359*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0413F8 3F FF FF    1360*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0413FB 43 FF FF    1361*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0413FE 47 FF FF    1362*  	dl 0xFFFF47 ; 313.594 DF, -0.724
041401 4B FF FF    1363*  	dl 0xFFFF4B ; 315.000 E0, -0.707
041404 50 FF FF    1364*  	dl 0xFFFF50 ; 316.406 E1, -0.690
041407 55 FF FF    1365*  	dl 0xFFFF55 ; 317.813 E2, -0.672
04140A 59 FF FF    1366*  	dl 0xFFFF59 ; 319.219 E3, -0.653
04140D 5E FF FF    1367*  	dl 0xFFFF5E ; 320.625 E4, -0.634
041410 63 FF FF    1368*  	dl 0xFFFF63 ; 322.031 E5, -0.615
041413 68 FF FF    1369*  	dl 0xFFFF68 ; 323.438 E6, -0.596
041416 6D FF FF    1370*  	dl 0xFFFF6D ; 324.844 E7, -0.576
041419 72 FF FF    1371*  	dl 0xFFFF72 ; 326.250 E8, -0.556
04141C 78 FF FF    1372*  	dl 0xFFFF78 ; 327.656 E9, -0.535
04141F 7D FF FF    1373*  	dl 0xFFFF7D ; 329.063 EA, -0.514
041422 82 FF FF    1374*  	dl 0xFFFF82 ; 330.469 EB, -0.493
041425 88 FF FF    1375*  	dl 0xFFFF88 ; 331.875 EC, -0.471
041428 8D FF FF    1376*  	dl 0xFFFF8D ; 333.281 ED, -0.450
04142B 93 FF FF    1377*  	dl 0xFFFF93 ; 334.688 EE, -0.428
04142E 99 FF FF    1378*  	dl 0xFFFF99 ; 336.094 EF, -0.405
041431 9F FF FF    1379*  	dl 0xFFFF9F ; 337.500 F0, -0.383
041434 A4 FF FF    1380*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
041437 AA FF FF    1381*  	dl 0xFFFFAA ; 340.313 F2, -0.337
04143A B0 FF FF    1382*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
04143D B6 FF FF    1383*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
041440 BC FF FF    1384*  	dl 0xFFFFBC ; 344.531 F5, -0.267
041443 C2 FF FF    1385*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
041446 C8 FF FF    1386*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
041449 CF FF FF    1387*  	dl 0xFFFFCF ; 348.750 F8, -0.195
04144C D5 FF FF    1388*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
04144F DB FF FF    1389*  	dl 0xFFFFDB ; 351.563 FA, -0.147
041452 E1 FF FF    1390*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
041455 E7 FF FF    1391*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
041458 EE FF FF    1392*  	dl 0xFFFFEE ; 355.781 FD, -0.074
04145B F4 FF FF    1393*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
04145E FA FF FF    1394*  	dl 0xFFFFFA ; 358.594 FF, -0.025
041461             1395*  
041461             1396*  atan_lut_168:
041461 00 00 00    1397*  	dl 0x000000 ; 000000, 0.000
041464 28 00 00    1398*  	dl 0x000028 ; 000001, 0.224
041467 51 00 00    1399*  	dl 0x000051 ; 000002, 0.448
04146A 7A 00 00    1400*  	dl 0x00007A ; 000003, 0.671
04146D A2 00 00    1401*  	dl 0x0000A2 ; 000004, 0.895
041470 CB 00 00    1402*  	dl 0x0000CB ; 000005, 1.119
041473 F4 00 00    1403*  	dl 0x0000F4 ; 000006, 1.343
041476 1D 01 00    1404*  	dl 0x00011D ; 000007, 1.566
041479 45 01 00    1405*  	dl 0x000145 ; 000008, 1.790
04147C 6E 01 00    1406*  	dl 0x00016E ; 000009, 2.013
04147F 97 01 00    1407*  	dl 0x000197 ; 00000A, 2.237
041482 BF 01 00    1408*  	dl 0x0001BF ; 00000B, 2.460
041485 E8 01 00    1409*  	dl 0x0001E8 ; 00000C, 2.684
041488 11 02 00    1410*  	dl 0x000211 ; 00000D, 2.907
04148B 39 02 00    1411*  	dl 0x000239 ; 00000E, 3.130
04148E 62 02 00    1412*  	dl 0x000262 ; 00000F, 3.353
041491 8B 02 00    1413*  	dl 0x00028B ; 000010, 3.576
041494 B3 02 00    1414*  	dl 0x0002B3 ; 000011, 3.799
041497 DC 02 00    1415*  	dl 0x0002DC ; 000012, 4.022
04149A 04 03 00    1416*  	dl 0x000304 ; 000013, 4.245
04149D 2D 03 00    1417*  	dl 0x00032D ; 000014, 4.467
0414A0 55 03 00    1418*  	dl 0x000355 ; 000015, 4.690
0414A3 7E 03 00    1419*  	dl 0x00037E ; 000016, 4.912
0414A6 A6 03 00    1420*  	dl 0x0003A6 ; 000017, 5.134
0414A9 CE 03 00    1421*  	dl 0x0003CE ; 000018, 5.356
0414AC F7 03 00    1422*  	dl 0x0003F7 ; 000019, 5.578
0414AF 1F 04 00    1423*  	dl 0x00041F ; 00001A, 5.799
0414B2 48 04 00    1424*  	dl 0x000448 ; 00001B, 6.021
0414B5 70 04 00    1425*  	dl 0x000470 ; 00001C, 6.242
0414B8 98 04 00    1426*  	dl 0x000498 ; 00001D, 6.463
0414BB C0 04 00    1427*  	dl 0x0004C0 ; 00001E, 6.684
0414BE E8 04 00    1428*  	dl 0x0004E8 ; 00001F, 6.905
0414C1 11 05 00    1429*  	dl 0x000511 ; 000020, 7.125
0414C4 39 05 00    1430*  	dl 0x000539 ; 000021, 7.345
0414C7 61 05 00    1431*  	dl 0x000561 ; 000022, 7.565
0414CA 89 05 00    1432*  	dl 0x000589 ; 000023, 7.785
0414CD B1 05 00    1433*  	dl 0x0005B1 ; 000024, 8.005
0414D0 D9 05 00    1434*  	dl 0x0005D9 ; 000025, 8.224
0414D3 01 06 00    1435*  	dl 0x000601 ; 000026, 8.443
0414D6 28 06 00    1436*  	dl 0x000628 ; 000027, 8.662
0414D9 50 06 00    1437*  	dl 0x000650 ; 000028, 8.881
0414DC 78 06 00    1438*  	dl 0x000678 ; 000029, 9.099
0414DF A0 06 00    1439*  	dl 0x0006A0 ; 00002A, 9.317
0414E2 C7 06 00    1440*  	dl 0x0006C7 ; 00002B, 9.535
0414E5 EF 06 00    1441*  	dl 0x0006EF ; 00002C, 9.752
0414E8 16 07 00    1442*  	dl 0x000716 ; 00002D, 9.970
0414EB 3E 07 00    1443*  	dl 0x00073E ; 00002E, 10.187
0414EE 65 07 00    1444*  	dl 0x000765 ; 00002F, 10.403
0414F1 8D 07 00    1445*  	dl 0x00078D ; 000030, 10.620
0414F4 B4 07 00    1446*  	dl 0x0007B4 ; 000031, 10.836
0414F7 DB 07 00    1447*  	dl 0x0007DB ; 000032, 11.051
0414FA 03 08 00    1448*  	dl 0x000803 ; 000033, 11.267
0414FD 2A 08 00    1449*  	dl 0x00082A ; 000034, 11.482
041500 51 08 00    1450*  	dl 0x000851 ; 000035, 11.697
041503 78 08 00    1451*  	dl 0x000878 ; 000036, 11.911
041506 9F 08 00    1452*  	dl 0x00089F ; 000037, 12.125
041509 C6 08 00    1453*  	dl 0x0008C6 ; 000038, 12.339
04150C ED 08 00    1454*  	dl 0x0008ED ; 000039, 12.553
04150F 13 09 00    1455*  	dl 0x000913 ; 00003A, 12.766
041512 3A 09 00    1456*  	dl 0x00093A ; 00003B, 12.978
041515 61 09 00    1457*  	dl 0x000961 ; 00003C, 13.191
041518 87 09 00    1458*  	dl 0x000987 ; 00003D, 13.403
04151B AE 09 00    1459*  	dl 0x0009AE ; 00003E, 13.614
04151E D4 09 00    1460*  	dl 0x0009D4 ; 00003F, 13.825
041521 FB 09 00    1461*  	dl 0x0009FB ; 000040, 14.036
041524 21 0A 00    1462*  	dl 0x000A21 ; 000041, 14.247
041527 47 0A 00    1463*  	dl 0x000A47 ; 000042, 14.457
04152A 6D 0A 00    1464*  	dl 0x000A6D ; 000043, 14.666
04152D 94 0A 00    1465*  	dl 0x000A94 ; 000044, 14.876
041530 BA 0A 00    1466*  	dl 0x000ABA ; 000045, 15.085
041533 E0 0A 00    1467*  	dl 0x000AE0 ; 000046, 15.293
041536 05 0B 00    1468*  	dl 0x000B05 ; 000047, 15.501
041539 2B 0B 00    1469*  	dl 0x000B2B ; 000048, 15.709
04153C 51 0B 00    1470*  	dl 0x000B51 ; 000049, 15.916
04153F 77 0B 00    1471*  	dl 0x000B77 ; 00004A, 16.123
041542 9C 0B 00    1472*  	dl 0x000B9C ; 00004B, 16.329
041545 C2 0B 00    1473*  	dl 0x000BC2 ; 00004C, 16.535
041548 E7 0B 00    1474*  	dl 0x000BE7 ; 00004D, 16.740
04154B 0C 0C 00    1475*  	dl 0x000C0C ; 00004E, 16.945
04154E 32 0C 00    1476*  	dl 0x000C32 ; 00004F, 17.150
041551 57 0C 00    1477*  	dl 0x000C57 ; 000050, 17.354
041554 7C 0C 00    1478*  	dl 0x000C7C ; 000051, 17.558
041557 A1 0C 00    1479*  	dl 0x000CA1 ; 000052, 17.761
04155A C6 0C 00    1480*  	dl 0x000CC6 ; 000053, 17.964
04155D EB 0C 00    1481*  	dl 0x000CEB ; 000054, 18.166
041560 0F 0D 00    1482*  	dl 0x000D0F ; 000055, 18.368
041563 34 0D 00    1483*  	dl 0x000D34 ; 000056, 18.569
041566 58 0D 00    1484*  	dl 0x000D58 ; 000057, 18.770
041569 7D 0D 00    1485*  	dl 0x000D7D ; 000058, 18.970
04156C A1 0D 00    1486*  	dl 0x000DA1 ; 000059, 19.170
04156F C6 0D 00    1487*  	dl 0x000DC6 ; 00005A, 19.370
041572 EA 0D 00    1488*  	dl 0x000DEA ; 00005B, 19.569
041575 0E 0E 00    1489*  	dl 0x000E0E ; 00005C, 19.767
041578 32 0E 00    1490*  	dl 0x000E32 ; 00005D, 19.965
04157B 56 0E 00    1491*  	dl 0x000E56 ; 00005E, 20.163
04157E 7A 0E 00    1492*  	dl 0x000E7A ; 00005F, 20.360
041581 9E 0E 00    1493*  	dl 0x000E9E ; 000060, 20.556
041584 C1 0E 00    1494*  	dl 0x000EC1 ; 000061, 20.752
041587 E5 0E 00    1495*  	dl 0x000EE5 ; 000062, 20.947
04158A 08 0F 00    1496*  	dl 0x000F08 ; 000063, 21.142
04158D 2C 0F 00    1497*  	dl 0x000F2C ; 000064, 21.337
041590 4F 0F 00    1498*  	dl 0x000F4F ; 000065, 21.531
041593 72 0F 00    1499*  	dl 0x000F72 ; 000066, 21.724
041596 95 0F 00    1500*  	dl 0x000F95 ; 000067, 21.917
041599 B8 0F 00    1501*  	dl 0x000FB8 ; 000068, 22.109
04159C DB 0F 00    1502*  	dl 0x000FDB ; 000069, 22.301
04159F FE 0F 00    1503*  	dl 0x000FFE ; 00006A, 22.493
0415A2 21 10 00    1504*  	dl 0x001021 ; 00006B, 22.683
0415A5 44 10 00    1505*  	dl 0x001044 ; 00006C, 22.874
0415A8 66 10 00    1506*  	dl 0x001066 ; 00006D, 23.063
0415AB 89 10 00    1507*  	dl 0x001089 ; 00006E, 23.253
0415AE AB 10 00    1508*  	dl 0x0010AB ; 00006F, 23.441
0415B1 CD 10 00    1509*  	dl 0x0010CD ; 000070, 23.629
0415B4 EF 10 00    1510*  	dl 0x0010EF ; 000071, 23.817
0415B7 11 11 00    1511*  	dl 0x001111 ; 000072, 24.004
0415BA 33 11 00    1512*  	dl 0x001133 ; 000073, 24.191
0415BD 55 11 00    1513*  	dl 0x001155 ; 000074, 24.376
0415C0 77 11 00    1514*  	dl 0x001177 ; 000075, 24.562
0415C3 99 11 00    1515*  	dl 0x001199 ; 000076, 24.747
0415C6 BA 11 00    1516*  	dl 0x0011BA ; 000077, 24.931
0415C9 DC 11 00    1517*  	dl 0x0011DC ; 000078, 25.115
0415CC FD 11 00    1518*  	dl 0x0011FD ; 000079, 25.298
0415CF 1E 12 00    1519*  	dl 0x00121E ; 00007A, 25.481
0415D2 3F 12 00    1520*  	dl 0x00123F ; 00007B, 25.663
0415D5 60 12 00    1521*  	dl 0x001260 ; 00007C, 25.844
0415D8 81 12 00    1522*  	dl 0x001281 ; 00007D, 26.025
0415DB A2 12 00    1523*  	dl 0x0012A2 ; 00007E, 26.206
0415DE C3 12 00    1524*  	dl 0x0012C3 ; 00007F, 26.386
0415E1 E4 12 00    1525*  	dl 0x0012E4 ; 000080, 26.565
0415E4 04 13 00    1526*  	dl 0x001304 ; 000081, 26.744
0415E7 25 13 00    1527*  	dl 0x001325 ; 000082, 26.922
0415EA 45 13 00    1528*  	dl 0x001345 ; 000083, 27.100
0415ED 65 13 00    1529*  	dl 0x001365 ; 000084, 27.277
0415F0 85 13 00    1530*  	dl 0x001385 ; 000085, 27.453
0415F3 A5 13 00    1531*  	dl 0x0013A5 ; 000086, 27.629
0415F6 C5 13 00    1532*  	dl 0x0013C5 ; 000087, 27.805
0415F9 E5 13 00    1533*  	dl 0x0013E5 ; 000088, 27.979
0415FC 05 14 00    1534*  	dl 0x001405 ; 000089, 28.154
0415FF 24 14 00    1535*  	dl 0x001424 ; 00008A, 28.327
041602 44 14 00    1536*  	dl 0x001444 ; 00008B, 28.501
041605 63 14 00    1537*  	dl 0x001463 ; 00008C, 28.673
041608 83 14 00    1538*  	dl 0x001483 ; 00008D, 28.845
04160B A2 14 00    1539*  	dl 0x0014A2 ; 00008E, 29.017
04160E C1 14 00    1540*  	dl 0x0014C1 ; 00008F, 29.187
041611 E0 14 00    1541*  	dl 0x0014E0 ; 000090, 29.358
041614 FF 14 00    1542*  	dl 0x0014FF ; 000091, 29.527
041617 1E 15 00    1543*  	dl 0x00151E ; 000092, 29.697
04161A 3C 15 00    1544*  	dl 0x00153C ; 000093, 29.865
04161D 5B 15 00    1545*  	dl 0x00155B ; 000094, 30.033
041620 79 15 00    1546*  	dl 0x001579 ; 000095, 30.201
041623 98 15 00    1547*  	dl 0x001598 ; 000096, 30.368
041626 B6 15 00    1548*  	dl 0x0015B6 ; 000097, 30.534
041629 D4 15 00    1549*  	dl 0x0015D4 ; 000098, 30.700
04162C F2 15 00    1550*  	dl 0x0015F2 ; 000099, 30.865
04162F 10 16 00    1551*  	dl 0x001610 ; 00009A, 31.030
041632 2E 16 00    1552*  	dl 0x00162E ; 00009B, 31.194
041635 4C 16 00    1553*  	dl 0x00164C ; 00009C, 31.357
041638 6A 16 00    1554*  	dl 0x00166A ; 00009D, 31.520
04163B 87 16 00    1555*  	dl 0x001687 ; 00009E, 31.682
04163E A5 16 00    1556*  	dl 0x0016A5 ; 00009F, 31.844
041641 C2 16 00    1557*  	dl 0x0016C2 ; 0000A0, 32.005
041644 DF 16 00    1558*  	dl 0x0016DF ; 0000A1, 32.166
041647 FC 16 00    1559*  	dl 0x0016FC ; 0000A2, 32.326
04164A 19 17 00    1560*  	dl 0x001719 ; 0000A3, 32.486
04164D 36 17 00    1561*  	dl 0x001736 ; 0000A4, 32.645
041650 53 17 00    1562*  	dl 0x001753 ; 0000A5, 32.803
041653 70 17 00    1563*  	dl 0x001770 ; 0000A6, 32.961
041656 8C 17 00    1564*  	dl 0x00178C ; 0000A7, 33.118
041659 A9 17 00    1565*  	dl 0x0017A9 ; 0000A8, 33.275
04165C C5 17 00    1566*  	dl 0x0017C5 ; 0000A9, 33.431
04165F E2 17 00    1567*  	dl 0x0017E2 ; 0000AA, 33.587
041662 FE 17 00    1568*  	dl 0x0017FE ; 0000AB, 33.742
041665 1A 18 00    1569*  	dl 0x00181A ; 0000AC, 33.896
041668 36 18 00    1570*  	dl 0x001836 ; 0000AD, 34.050
04166B 52 18 00    1571*  	dl 0x001852 ; 0000AE, 34.203
04166E 6E 18 00    1572*  	dl 0x00186E ; 0000AF, 34.356
041671 8A 18 00    1573*  	dl 0x00188A ; 0000B0, 34.509
041674 A5 18 00    1574*  	dl 0x0018A5 ; 0000B1, 34.660
041677 C1 18 00    1575*  	dl 0x0018C1 ; 0000B2, 34.811
04167A DC 18 00    1576*  	dl 0x0018DC ; 0000B3, 34.962
04167D F7 18 00    1577*  	dl 0x0018F7 ; 0000B4, 35.112
041680 13 19 00    1578*  	dl 0x001913 ; 0000B5, 35.262
041683 2E 19 00    1579*  	dl 0x00192E ; 0000B6, 35.410
041686 49 19 00    1580*  	dl 0x001949 ; 0000B7, 35.559
041689 64 19 00    1581*  	dl 0x001964 ; 0000B8, 35.707
04168C 7F 19 00    1582*  	dl 0x00197F ; 0000B9, 35.854
04168F 99 19 00    1583*  	dl 0x001999 ; 0000BA, 36.001
041692 B4 19 00    1584*  	dl 0x0019B4 ; 0000BB, 36.147
041695 CE 19 00    1585*  	dl 0x0019CE ; 0000BC, 36.293
041698 E9 19 00    1586*  	dl 0x0019E9 ; 0000BD, 36.438
04169B 03 1A 00    1587*  	dl 0x001A03 ; 0000BE, 36.582
04169E 1D 1A 00    1588*  	dl 0x001A1D ; 0000BF, 36.726
0416A1 37 1A 00    1589*  	dl 0x001A37 ; 0000C0, 36.870
0416A4 51 1A 00    1590*  	dl 0x001A51 ; 0000C1, 37.013
0416A7 6B 1A 00    1591*  	dl 0x001A6B ; 0000C2, 37.155
0416AA 85 1A 00    1592*  	dl 0x001A85 ; 0000C3, 37.297
0416AD 9F 1A 00    1593*  	dl 0x001A9F ; 0000C4, 37.439
0416B0 B9 1A 00    1594*  	dl 0x001AB9 ; 0000C5, 37.579
0416B3 D2 1A 00    1595*  	dl 0x001AD2 ; 0000C6, 37.720
0416B6 EC 1A 00    1596*  	dl 0x001AEC ; 0000C7, 37.859
0416B9 05 1B 00    1597*  	dl 0x001B05 ; 0000C8, 37.999
0416BC 1E 1B 00    1598*  	dl 0x001B1E ; 0000C9, 38.137
0416BF 37 1B 00    1599*  	dl 0x001B37 ; 0000CA, 38.276
0416C2 50 1B 00    1600*  	dl 0x001B50 ; 0000CB, 38.413
0416C5 69 1B 00    1601*  	dl 0x001B69 ; 0000CC, 38.550
0416C8 82 1B 00    1602*  	dl 0x001B82 ; 0000CD, 38.687
0416CB 9B 1B 00    1603*  	dl 0x001B9B ; 0000CE, 38.823
0416CE B4 1B 00    1604*  	dl 0x001BB4 ; 0000CF, 38.959
0416D1 CC 1B 00    1605*  	dl 0x001BCC ; 0000D0, 39.094
0416D4 E5 1B 00    1606*  	dl 0x001BE5 ; 0000D1, 39.228
0416D7 FD 1B 00    1607*  	dl 0x001BFD ; 0000D2, 39.362
0416DA 16 1C 00    1608*  	dl 0x001C16 ; 0000D3, 39.496
0416DD 2E 1C 00    1609*  	dl 0x001C2E ; 0000D4, 39.629
0416E0 46 1C 00    1610*  	dl 0x001C46 ; 0000D5, 39.762
0416E3 5E 1C 00    1611*  	dl 0x001C5E ; 0000D6, 39.894
0416E6 76 1C 00    1612*  	dl 0x001C76 ; 0000D7, 40.025
0416E9 8E 1C 00    1613*  	dl 0x001C8E ; 0000D8, 40.156
0416EC A5 1C 00    1614*  	dl 0x001CA5 ; 0000D9, 40.286
0416EF BD 1C 00    1615*  	dl 0x001CBD ; 0000DA, 40.416
0416F2 D5 1C 00    1616*  	dl 0x001CD5 ; 0000DB, 40.546
0416F5 EC 1C 00    1617*  	dl 0x001CEC ; 0000DC, 40.675
0416F8 04 1D 00    1618*  	dl 0x001D04 ; 0000DD, 40.803
0416FB 1B 1D 00    1619*  	dl 0x001D1B ; 0000DE, 40.931
0416FE 32 1D 00    1620*  	dl 0x001D32 ; 0000DF, 41.059
041701 49 1D 00    1621*  	dl 0x001D49 ; 0000E0, 41.186
041704 60 1D 00    1622*  	dl 0x001D60 ; 0000E1, 41.312
041707 77 1D 00    1623*  	dl 0x001D77 ; 0000E2, 41.438
04170A 8E 1D 00    1624*  	dl 0x001D8E ; 0000E3, 41.564
04170D A5 1D 00    1625*  	dl 0x001DA5 ; 0000E4, 41.689
041710 BB 1D 00    1626*  	dl 0x001DBB ; 0000E5, 41.814
041713 D2 1D 00    1627*  	dl 0x001DD2 ; 0000E6, 41.938
041716 E9 1D 00    1628*  	dl 0x001DE9 ; 0000E7, 42.061
041719 FF 1D 00    1629*  	dl 0x001DFF ; 0000E8, 42.184
04171C 15 1E 00    1630*  	dl 0x001E15 ; 0000E9, 42.307
04171F 2C 1E 00    1631*  	dl 0x001E2C ; 0000EA, 42.429
041722 42 1E 00    1632*  	dl 0x001E42 ; 0000EB, 42.551
041725 58 1E 00    1633*  	dl 0x001E58 ; 0000EC, 42.672
041728 6E 1E 00    1634*  	dl 0x001E6E ; 0000ED, 42.793
04172B 84 1E 00    1635*  	dl 0x001E84 ; 0000EE, 42.913
04172E 99 1E 00    1636*  	dl 0x001E99 ; 0000EF, 43.033
041731 AF 1E 00    1637*  	dl 0x001EAF ; 0000F0, 43.152
041734 C5 1E 00    1638*  	dl 0x001EC5 ; 0000F1, 43.271
041737 DA 1E 00    1639*  	dl 0x001EDA ; 0000F2, 43.390
04173A F0 1E 00    1640*  	dl 0x001EF0 ; 0000F3, 43.508
04173D 05 1F 00    1641*  	dl 0x001F05 ; 0000F4, 43.625
041740 1B 1F 00    1642*  	dl 0x001F1B ; 0000F5, 43.742
041743 30 1F 00    1643*  	dl 0x001F30 ; 0000F6, 43.859
041746 45 1F 00    1644*  	dl 0x001F45 ; 0000F7, 43.975
041749 5A 1F 00    1645*  	dl 0x001F5A ; 0000F8, 44.091
04174C 6F 1F 00    1646*  	dl 0x001F6F ; 0000F9, 44.206
04174F 84 1F 00    1647*  	dl 0x001F84 ; 0000FA, 44.321
041752 99 1F 00    1648*  	dl 0x001F99 ; 0000FB, 44.435
041755 AD 1F 00    1649*  	dl 0x001FAD ; 0000FC, 44.549
041758 C2 1F 00    1650*  	dl 0x001FC2 ; 0000FD, 44.662
04175B D7 1F 00    1651*  	dl 0x001FD7 ; 0000FE, 44.775
04175E EB 1F 00    1652*  	dl 0x001FEB ; 0000FF, 44.888
041761 00 20 00    1653*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
041764             1654*  
041764             1655*  ; ---------------------------------------------------------
041764             1656*  ; BEGIN HELPER ROUTINES
041764             1657*  ; ---------------------------------------------------------
041764             1658*  ;
041764             1659*  ; absolute value of hlu
041764             1660*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
041764             1661*  ;         s1,z0,pv0,n1,c0 if hlu was negative
041764             1662*  ;         s0,z1,pv0,n1,c0 if hlu was zero
041764             1663*  ;         s0,z0,pv0,n1,c0 if hlu was positive
041764             1664*  ; destroys: a
041764             1665*  abs_hlu:
041764 19          1666*      add hl,de
041765 B7          1667*      or a
041766 ED 52       1668*      sbc hl,de
041768 FA 6D 17 04 1669*      jp m,@is_neg
04176C C9          1670*      ret         ; hlu is positive or zero so we're done
04176D             1671*  @is_neg:
04176D F5          1672*      push af     ; otherwise, save current flags for return
04176E CD 74 17 04 1673*      call neg_hlu ; negate hlu
041772 F1          1674*      pop af      ; get back flags
041773 C9          1675*      ret
041774             1676*  
041774             1677*  ; flip the sign of hlu
041774             1678*  ; inputs: hlu
041774             1679*  ; returns: 0-hlu, flags set appropriately for the result:
041774             1680*  ;         s1,z0,pv0,n1,c1 if result is negative
041774             1681*  ;         s0,z1,pv0,n1,c0 if result is zero
041774             1682*  ;         s0,z0,pv0,n1,c1 if result is positive
041774             1683*  ; destroys a
041774             1684*  neg_hlu:
041774 D5          1685*      push de     ; save de
041775 EB          1686*      ex de,hl    ; put hl into de
041776 21 00 00 00 1687*      ld hl,0     ; clear hl
04177A AF          1688*      xor a       ; clear carry
04177B ED 52       1689*      sbc hl,de   ; 0-hlu = -hlu
04177D D1          1690*      pop de      ; get de back
04177E C9          1691*      ret         ; easy peasy
04177F             1692*  
04177F             1693*  ;------------------------------------------------------------------------
04177F             1694*  ; divide hlu by 2, inspired by above
04177F             1695*  ;------------------------------------------------------------------------
04177F             1696*  hlu_div2:
04177F 22 AA 0E 04 1697*  	ld		(bitbuf1),hl
041783 21 AC 0E 04 1698*  	ld		hl,bitbuf1+2
041787 CB 1E       1699*  	rr		(hl)
041789 2B          1700*  	dec		hl
04178A CB 1E       1701*  	rr		(hl)
04178C 2B          1702*  	dec		hl
04178D CB 1E       1703*  	rr		(hl)
04178F 23          1704*  	inc		hl
041790 23          1705*  	inc		hl
041791 2A AA 0E 04 1706*      ld hl,(bitbuf1)
041795 C9          1707*      ret
041796             1708*  
041796             1709*  ; this is my little hack to divide by 16
041796             1710*  hlu_div16:
041796 AF          1711*      xor a
041797 29          1712*      add hl,hl
041798 17          1713*      rla
041799 29          1714*      add hl,hl
04179A 17          1715*      rla
04179B 29          1716*      add hl,hl
04179C 17          1717*      rla
04179D 29          1718*      add hl,hl
04179E 17          1719*      rla
04179F 22 AC 17 04 1720*      ld (@scratch),hl
0417A3 32 AF 17 04 1721*      ld (@scratch+3),a
0417A7 2A AD 17 04 1722*      ld hl,(@scratch+1)
0417AB C9          1723*      ret
0417AC             1724*  @scratch: ds 4
0417B0             0043   
0417B0             0044   main:
0417B0             0045   
0417B0 CD B5 17 04 0046       call test_umul24x24
0417B4             0047       ; call test_umul24x8
0417B4             0048   
0417B4 C9          0049       ret
0417B5             0050   
0417B5             0051   test_umul24x24:
0417B5 21 02 00 00 0052       ld hl,2
0417B9 11 03 00 00 0053       ld de,3
0417BD CD C9 00 04 0054       call printHexUHL
0417C1 CD 81 00 04 0055       call printNewLine
0417C5 EB          0056       ex de,hl
0417C6 CD C9 00 04 0057       call printHexUHL
0417CA CD 81 00 04 0058       call printNewLine
0417CE CD 81 00 04 0059       call printNewLine
0417D2 EB          0060       ex de,hl
0417D3             0061   
0417D3 CD A8 0C 04 0062       call umul24x24
0417D7 2A F7 0C 04 0063       ld hl,(umul24x24out+3)
0417DB CD C9 00 04 0064       call printHexUHL
0417DF 2A F4 0C 04 0065       ld hl,(umul24x24out)
0417E3 CD C9 00 04 0066       call printHexUHL
0417E7 CD 81 00 04 0067       call printNewLine
0417EB C9          0068       ret
0417EC             0069   
0417EC             0070   test_umul24x8:
0417EC 21 02 00 00 0071       ld hl,2
0417F0 3E 03       0072       ld a,3
0417F2 CD C9 00 04 0073       call printHexUHL
0417F6 CD 81 00 04 0074       call printNewLine
0417FA CD AF 00 04 0075       call printHexA
0417FE CD 81 00 04 0076       call printNewLine
041802 CD 79 0C 04 0077       call umul24x8
041806 CD AF 00 04 0078       call printHexA
04180A CD C9 00 04 0079       call printHexUHL
04180E CD 81 00 04 0080       call printNewLine
041812 C9          0081       ret
