PC     Output      Line
040000             0001    ;
040000             0002    ; Title:	flower
040000             0003    ; Author:	Brandon R. Gates (BeeGee747)
040000             0004    ; Created:	Nov. 2024
040000             0005    ;
040000             0006    ; This program draws 2D curves related to the epitrochoid family (i.e. Spirographs),
040000             0007    ; more generally known as roulettes. However, instead of an outer wheel rolling
040000             0008    ; around on an inner wheel, this algorithm can be thought of as a rotating arm whose
040000             0009    ; radius oscillates a set number of times per rotation, which is set by the petals parameter.
040000             0010    ; Unlike the Spirograph toy which plots a continuous curve, the vectors parameter determines
040000             0011    ; the number of points plotted per oscillation. Specifying a small number of vectors leads
040000             0012    ; to more angular polygonal-type curves reminiscent of string art. Also unlike the toy,
040000             0013    ; a shrink factor can be specified resulting in graphs which are true spirals.
040000             0014    ;
040000             0015    ; More information about epitrochoid curves can be found here:
040000             0016    ; https://mathcurve.com/courbes2d.gb/epitrochoid/epitrochoid.shtml
040000             0017    ;
040000             0018    ; Parameters with example values:
040000             0019    ; petals       = 3.03  : Number of radius oscillations per cycle.
040000             0020    ; vectors      = 1.98  : Number of points plotted per oscillation.
040000             0021    ; depth        = 0.6   : Multiplier determining the depth of the oscillation.
040000             0022    ; periods      = 66    : Number of full rotations.
040000             0023    ; shrink       = 0.8   : Multiplier determining the final radius relative to the start.
040000             0024    ; theta_init   = 0.0   : Starting angle of the drawing cursor relative to the origin.
040000             0025    ; radius_scale = 512   : Starting radius.
040000             0026    ;
040000             0027    ; ========================================
040000             0028    ; MOSLET INITIALIZATION CODE
040000             0029    ; ========================================
040000             0030    ;
040000             0031        ASSUME	ADL = 1
040000             0032        INCLUDE "mos_api.inc"
040000             0001*   ;
040000             0002*   ; Title:	AGON MOS - API for user projects
040000             0003*   ; Author:	Dean Belfield
040000             0004*   ; Created:	03/08/2022
040000             0005*   ; Last Updated:	11/11/2023
040000             0006*   ;
040000             0007*   ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0008*   ;
040000             0009*   ; Modinfo:
040000             0010*   ; 05/08/2022:	Added mos_feof
040000             0011*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*   ; 13/10/2022:	Added mos_oscli
040000             0016*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*   ; 19/05/2023:	Added sysvar_scrMode
040000             0026*   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*   ; 03/08/2023:	Added mos_setkbvector
040000             0028*   ; 10/08/2023:	Added mos_getkbmap
040000             0029*   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0030*   ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0031*   ;
040000             0032*   ; VDP control (VDU 23, 0, n)
040000             0033*   ;
040000             0034*   vdp_gp:			EQU 	80h
040000             0035*   vdp_keycode:		EQU 	81h
040000             0036*   vdp_cursor:		EQU	82h
040000             0037*   vdp_scrchar:		EQU	83h
040000             0038*   vdp_scrpixel:		EQU	84h
040000             0039*   vdp_audio:		EQU	85h
040000             0040*   vdp_mode:		EQU	86h
040000             0041*   vdp_rtc:		EQU	87h
040000             0042*   vdp_keystate:		EQU	88h
040000             0043*   vdp_logicalcoords:	EQU	C0h
040000             0044*   vdp_terminalmode:	EQU	FFh
040000             0045*   
040000             0046*   ; MOS high level functions
040000             0047*   ;
040000             0048*   mos_getkey:		EQU	00h
040000             0049*   mos_load:		EQU	01h
040000             0050*   mos_save:		EQU	02h
040000             0051*   mos_cd:			EQU	03h
040000             0052*   mos_dir:		EQU	04h
040000             0053*   mos_del:		EQU	05h
040000             0054*   mos_ren:		EQU	06h
040000             0055*   mos_mkdir:		EQU	07h
040000             0056*   mos_sysvars:		EQU	08h
040000             0057*   mos_editline:		EQU	09h
040000             0058*   mos_fopen:		EQU	0Ah
040000             0059*   mos_fclose:		EQU	0Bh
040000             0060*   mos_fgetc:		EQU	0Ch
040000             0061*   mos_fputc:		EQU	0Dh
040000             0062*   mos_feof:		EQU	0Eh
040000             0063*   mos_getError:		EQU	0Fh
040000             0064*   mos_oscli:		EQU	10h
040000             0065*   mos_copy:		EQU	11h
040000             0066*   mos_getrtc:		EQU	12h
040000             0067*   mos_setrtc:		EQU	13h
040000             0068*   mos_setintvector:	EQU	14h
040000             0069*   mos_uopen:		EQU	15h
040000             0070*   mos_uclose:		EQU	16h
040000             0071*   mos_ugetc:		EQU	17h
040000             0072*   mos_uputc:		EQU 	18h
040000             0073*   mos_getfil:		EQU	19h
040000             0074*   mos_fread:		EQU	1Ah
040000             0075*   mos_fwrite:		EQU	1Bh
040000             0076*   mos_flseek:		EQU	1Ch
040000             0077*   mos_setkbvector:	EQU	1Dh
040000             0078*   mos_getkbmap:		EQU	1Eh
040000             0079*   mos_i2c_open:		EQU	1Fh
040000             0080*   mos_i2c_close:		EQU	20h
040000             0081*   mos_i2c_write:		EQU	21h
040000             0082*   mos_i2c_read:		EQU	22h
040000             0083*   
040000             0084*   
040000             0085*   ; FatFS file access functions
040000             0086*   ;
040000             0087*   ffs_fopen:		EQU	80h
040000             0088*   ffs_fclose:		EQU	81h
040000             0089*   ffs_fread:		EQU	82h
040000             0090*   ffs_fwrite:		EQU	83h
040000             0091*   ffs_flseek:		EQU	84h
040000             0092*   ffs_ftruncate:		EQU	85h
040000             0093*   ffs_fsync:		EQU	86h
040000             0094*   ffs_fforward:		EQU	87h
040000             0095*   ffs_fexpand:		EQU	88h
040000             0096*   ffs_fgets:		EQU	89h
040000             0097*   ffs_fputc:		EQU	8Ah
040000             0098*   ffs_fputs:		EQU	8Bh
040000             0099*   ffs_fprintf:		EQU	8Ch
040000             0100*   ffs_ftell:		EQU	8Dh
040000             0101*   ffs_feof:		EQU	8Eh
040000             0102*   ffs_fsize:		EQU	8Fh
040000             0103*   ffs_ferror:		EQU	90h
040000             0104*   
040000             0105*   ; FatFS directory access functions
040000             0106*   ;
040000             0107*   ffs_dopen:		EQU	91h
040000             0108*   ffs_dclose:		EQU	92h
040000             0109*   ffs_dread:		EQU	93h
040000             0110*   ffs_dfindfirst:		EQU	94h
040000             0111*   ffs_dfindnext:		EQU	95h
040000             0112*   
040000             0113*   ; FatFS file and directory management functions
040000             0114*   ;
040000             0115*   ffs_stat:		EQU	96h
040000             0116*   ffs_unlink:		EQU	97h
040000             0117*   ffs_rename:		EQU	98h
040000             0118*   ffs_chmod:		EQU	99h
040000             0119*   ffs_utime:		EQU	9Ah
040000             0120*   ffs_mkdir:		EQU	9Bh
040000             0121*   ffs_chdir:		EQU	9Ch
040000             0122*   ffs_chdrive:		EQU	9Dh
040000             0123*   ffs_getcwd:		EQU	9Eh
040000             0124*   
040000             0125*   ; FatFS volume management and system configuration functions
040000             0126*   ;
040000             0127*   ffs_mount:		EQU	9Fh
040000             0128*   ffs_mkfs:		EQU	A0h
040000             0129*   ffs_fdisk:		EQU	A1h
040000             0130*   ffs_getfree:		EQU	A2h
040000             0131*   ffs_getlabel:		EQU	A3h
040000             0132*   ffs_setlabel:		EQU	A4h
040000             0133*   ffs_setcp:		EQU	A5h
040000             0134*   
040000             0135*   ; File access modes
040000             0136*   ;
040000             0137*   fa_read:		EQU	01h
040000             0138*   fa_write:		EQU	02h
040000             0139*   fa_open_existing:	EQU	00h
040000             0140*   fa_create_new:		EQU	04h
040000             0141*   fa_create_always:	EQU	08h
040000             0142*   fa_open_always:		EQU	10h
040000             0143*   fa_open_append:		EQU	30h
040000             0144*   
040000             0145*   ; System variable indexes for api_sysvars
040000             0146*   ; Index into _sysvars in globals.asm
040000             0147*   ;
040000             0148*   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0149*   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0150*   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0151*   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0152*   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0153*   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0154*   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0155*   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0156*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0157*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0158*   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0159*   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0160*   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0161*   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0162*   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0163*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0164*   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0165*   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0166*   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0167*   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0168*   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0169*   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0170*   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0171*   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0172*   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0173*   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0174*   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0175*   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0176*   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0177*   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0178*   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0179*   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0180*   ;
040000             0181*   ; Flags for the VPD protocol
040000             0182*   ;
040000             0183*   vdp_pflag_cursor:	EQU	00000001b
040000             0184*   vdp_pflag_scrchar:	EQU	00000010b
040000             0185*   vdp_pflag_point:	EQU	00000100b
040000             0186*   vdp_pflag_audio:	EQU	00001000b
040000             0187*   vdp_pflag_mode:		EQU	00010000b
040000             0188*   vdp_pflag_rtc:		EQU	00100000b
040000             0189*   vdp_pflag_mouse:	EQU	01000000b
040000             0190*   ; vdp_pflag_buffered:	EQU	10000000b
040000             0191*   
040000             0192*   
040000             0193*   ; FatFS structures
040000             0194*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0195*   ;
040000             0196*   ; Object ID and allocation information (FFOBJID)
040000             0197*   FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0198*   FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0199*   FFOBJID.attr:     EQU 5    ; Object attribute
040000             0200*   FFOBJID.stat:     EQU 6    ; Object chain status
040000             0201*   FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0202*   FFOBJID.objsize:  EQU 11   ; Object size
040000             0203*   FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0204*   ;
040000             0205*   ; File object structure (FIL)
040000             0206*   ;
040000             0207*   FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0208*   FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0209*   FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0210*   FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0211*   FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0212*   FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0213*   FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0214*   FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0215*   FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0216*   ;
040000             0217*   ; Directory object structure (DIR)
040000             0218*   ;
040000             0219*   DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0220*   DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0221*   DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0222*   DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0223*   DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0224*   DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0225*   DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0226*   DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0227*   ;
040000             0228*   ; File information structure (FILINFO)
040000             0229*   ;
040000             0230*   FILINFO.fsize:    EQU 0    ; File size
040000             0231*   FILINFO.fdate:    EQU 4    ; Modified date
040000             0232*   FILINFO.ftime:    EQU 6    ; Modified time
040000             0233*   FILINFO.fattrib:  EQU 8    ; File attribute
040000             0234*   FILINFO.altname:  EQU 9    ; Alternative file name
040000             0235*   FILINFO.fname:    EQU 22   ; Primary file name
040000             0236*   FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0237*   ;
040000             0238*   ; Macro for calling the API
040000             0239*   ; Parameters:
040000             0240*   ; - function: One of the function numbers listed above
040000             0241*   ;
040000             0242*   			MACRO MOSCALL	function
040000             0243*   			LD	A, function
040000             0244*   			RST.LIS	08h
040000             0245*   			ENDMACRO
040000             0033        INCLUDE "macros.inc"
040000             0001*   
040000             0002*   ; test the sign of HL
040000             0003*   ; inputs: HL obviously
040000             0004*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040000             0005*   ; destroys: flags
040000             0006*       MACRO SIGN_HLU
040000             0007*       add hl,de ; 1 cycle
040000             0008*       or a ; clear flags ; 1 cycle
040000             0009*       sbc hl,de ; 2 cycles
040000             0010*       ; 4 cycles total
040000             0011*       ENDMACRO
040000             0012*   
040000             0013*   ; put the value in A into HLU
040000             0014*   ; affects: HLU
040000             0015*   ; destroys: nothing
040000             0016*   ; note: $ instead of @@ b/c anon labels deprecated in ez80asm
040000             0017*       MACRO A_TO_HLU
040000             0018*       xor a ; 1 cycle
040000             0019*       ld ($+8+1),hl ; 7 cycles
040000             0020*       ld ($+4+3),a ; 5 cycles
040000             0021*       ld hl,0x000000 ; 4 cycles
040000             0022*       ; 17 cycles total
040000             0023*       ENDMACRO
040000             0024*   
040000             0025*   ; alternative: https://discord.com/channels/1158535358624039014/1282290921815408681/1318315567102300220
040000             0026*   ; one cycle less but burns flags
040000             0027*       MACRO A_TO_HLU_ALT
040000             0028*       push hl ; 4 cycles
040000             0029*       ld hl,2 ; 4 cycles
040000             0030*       add hl,sp ; 1 cycle
040000             0031*       ld (hl),a ; 2 cycles
040000             0032*       pop hl ; 4 cycles
040000             0033*       ; 15 cycles total
040000             0034*       ENDMACRO
040000             0035*   
040000             0036*       MACRO hlu_mul256
040000             0037*       add hl,hl ; * 2
040000             0038*       add hl,hl ; * 4
040000             0039*       add hl,hl ; * 8
040000             0040*       add hl,hl ; * 16
040000             0041*       add hl,hl ; * 32
040000             0042*       add hl,hl ; * 64
040000             0043*       add hl,hl ; * 128
040000             0044*       add hl,hl ; * 256
040000             0045*       ENDMACRO
040000             0046*   
040000             0047*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1317793870070812715
040000             0048*       MACRO SRL_UHL
040000             0049*       dec sp ; 1 cycle
040000             0050*       push hl ; 4 cycles
040000             0051*       inc sp ; 1 cycle
040000             0052*       pop hl ; 4 cycles
040000             0053*       inc hl ; 1 cycle
040000             0054*       dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
040000             0055*       ; 13 cycles total
040000             0056*       ENDMACRO
040000             0057*   
040000             0058*       MACRO printChar char
040000             0059*       LD A, char
040000             0060*       RST.LIL 10h
040000             0061*       ENDMACRO
040000             0062*   
040000             0063*   ; Simulated call to subroutine at HL
040000             0064*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040000             0065*   ; outputs: whatever the subroutine does, including HL and BC
040000             0066*   ; destroys: only what the subroutine does, but always BC
040000             0067*       MACRO CALL_HL
040000             0068*       ld bc,$+6 ; Address of first instruction after the jump
040000             0069*       push bc ; which constitutes the return address
040000             0070*       jp (hl) ; Jump to the address in HL
040000             0071*       ENDMACRO
040000             0072*   
040000             0073*   ; Simulated call to subroutine at IX
040000             0074*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040000             0075*   ; outputs: whatever the subroutine does, including IX and BC
040000             0076*   ; destroys: only what the subroutine does, but always BC
040000             0077*       MACRO CALL_IX
040000             0078*       ld bc,$+6 ; Address of first instruction after the jump
040000             0079*       push bc ; which constitutes the return address
040000             0080*       jp (ix) ; Jump to the address in IX
040000             0081*       ENDMACRO
040000             0082*   
040000             0083*   ; Simulated call to soubroutinte at IY
040000             0084*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040000             0085*   ; outputs: whatever the subroutine does, including IY and BC
040000             0086*   ; destroys: only what the subroutine does, but always BC
040000             0087*       MACRO CALL_IY
040000             0088*       ld bc,$+6 ; Address of first instruction after the jump
040000             0089*       push bc ; which constitutes the return address
040000             0090*       jp (iy) ; Jump to the address in IY
040000             0091*       ENDMACRO
040000             0092*   
040000             0093*   ; put the value in HLU into A
040000             0094*   ; destroys: af
040000             0095*       MACRO HLU_TO_A
040000             0096*       dec sp ; 1 cycle
040000             0097*       push hl ; 4 cycles
040000             0098*       inc sp ; 1 cycle
040000             0099*       pop af ; 4 cycles
040000             0100*       ; 10 cycles total
040000             0101*       ENDMACRO
040000             0102*   
040000             0103*       MACRO PUSH_ALL
040000             0104*       ex af,af'
040000             0105*       exx
040000             0106*       push af
040000             0107*       push hl
040000             0108*       push bc
040000             0109*       push de
040000             0110*   
040000             0111*       ex af,af'
040000             0112*       exx
040000             0113*       push af
040000             0114*       push hl
040000             0115*       push bc
040000             0116*       push de
040000             0117*       push ix
040000             0118*       push iy
040000             0119*       ENDMACRO
040000             0120*   
040000             0121*       MACRO POP_ALL
040000             0122*       pop iy
040000             0123*       pop ix
040000             0124*       pop de
040000             0125*       pop bc
040000             0126*       pop hl
040000             0127*       pop af
040000             0128*       ex af,af'
040000             0129*       exx
040000             0130*   
040000             0131*       pop de
040000             0132*       pop bc
040000             0133*       pop hl
040000             0134*       pop af
040000             0135*       ex af,af'
040000             0136*       exx
040000             0137*       ENDMACRO
040000             0138*   
040000             0034        ORG 0x0B0000 ; Is a moslet
0B0000             0035    
0B0000             0036        MACRO PROGNAME
0B0000             0037        ASCIZ "flower"
0B0000             0038        ENDMACRO
0B0000             0039    ;
0B0000             0040    ; Start in ADL mode
0B0000             0041    ;
0B0000 C3 45 00 0B 0042    			JP	_start
0B0004             0043    ;
0B0004             0044    ; The header stuff is from byte 64 onwards
0B0004             0045    ;
0B0004             0046    _exec_name:
0B0004             0047    			PROGNAME			; The executable name, only used in argv
                       M1 Args: none
0B0004 66 6C 6F 77 0001M1      ASCIZ "flower"
       65 72 00    
0B000B             0048    
0B000B             0049    			ALIGN	64
0B0040             0050    
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF 
0B0040 4D 4F 53    0051    			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0052    			DB	00h			; MOS header version 0
0B0044 01          0053    			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0054    ;
0B0045             0055    ; And the code follows on immediately after the header
0B0045             0056    ;
0B0045             0057    _start:
0B0045 F5          0058                PUSH	AF			; Preserve the registers
0B0046 C5          0059    			PUSH	BC
0B0047 D5          0060    			PUSH	DE
0B0048 DD E5       0061    			PUSH	IX
0B004A FD E5       0062    			PUSH	IY
0B004C ED 6E       0063    			LD	A, MB			; Save MB
0B004E F5          0064    			PUSH 	AF
0B004F AF          0065    			XOR 	A
0B0050 ED 6D       0066    			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0067    
0B0052 CD BD 00 0B 0068    			CALL		_clear_ram ; Clear the BASIC memory allocation
0B0056             0069    
0B0056 DD 21 72 1B 0070    			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B005B DD E5       0071    			PUSH	IX
0B005D CD 74 00 0B 0072    			CALL	_parse_params		; Parse the parameters
0B0061 DD E1       0073    			POP	IX			; IX: argv
0B0063 06 00       0074    			LD	B, 0			;  C: argc
0B0065 CD 35 1C 0B 0075    			CALL	_main_init			; Start user code
0B0069             0076    
0B0069 F1          0077    			POP 	AF
0B006A ED 6D       0078    			LD	MB, A
0B006C FD E1       0079    			POP	IY			; Restore registers
0B006E DD E1       0080    			POP	IX
0B0070 D1          0081    			POP	DE
0B0071 C1          0082    			POP	BC
0B0072 F1          0083    			POP	AF
0B0073 C9          0084    			RET
0B0074             0085    
0B0074             0086    ; Parse the parameter string into a C array
0B0074             0087    ; Parameters
0B0074             0088    ; - HL: Address of parameter string
0B0074             0089    ; - IX: Address for array pointer storage
0B0074             0090    ; Returns:
0B0074             0091    ; -  C: Number of parameters parsed
0B0074             0092    ;
0B0074 01 04 00 0B 0093    _parse_params:		LD	BC, _exec_name
0B0078 DD 0F 00    0094    			LD	(IX+0), BC		; ARGV[0] = the executable name
0B007B ED 32 03    0095    			LEA     IX, IX+3
0B007E CD B6 00 0B 0096    			CALL	_skip_spaces		; Skip HL past any leading spaces
0B0082             0097    ;
0B0082 01 01 00 00 0098    			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0086 06 0F       0099    			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0088             0100    ;
0B0088             0101    _parse_params_1:
0B0088 C5          0102    			PUSH	BC			; Stack ARGC
0B0089 E5          0103    			PUSH	HL			; Stack start address of token
0B008A CD A7 00 0B 0104    			CALL	_get_token		; Get the next token
0B008E 79          0105    			LD	A, C			; A: Length of the token in characters
0B008F D1          0106    			POP	DE			; Start address of token (was in HL)
0B0090 C1          0107    			POP	BC			; ARGC
0B0091 B7          0108    			OR	A			; Check for A=0 (no token found) OR at end of string
0B0092 C8          0109    			RET	Z
0B0093             0110    ;
0B0093 DD 1F 00    0111    			LD	(IX+0), DE		; Store the pointer to the token
0B0096 E5          0112    			PUSH	HL			; DE=HL
0B0097 D1          0113    			POP	DE
0B0098 CD B6 00 0B 0114    			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B009C AF          0115    			XOR	A
0B009D 12          0116    			LD	(DE), A			; Zero-terminate the token
0B009E ED 32 03    0117    			LEA  	IX, IX+3			; Advance to next pointer position
0B00A1 0C          0118    			INC	C			; Increment ARGC
0B00A2 79          0119    			LD	A, C			; Check for C >= A
0B00A3 B8          0120    			CP	B
0B00A4 38 E2       0121    			JR	C, _parse_params_1	; And loop
0B00A6 C9          0122    			RET
0B00A7             0123    
0B00A7             0124    ; Get the next token
0B00A7             0125    ; Parameters:
0B00A7             0126    ; - HL: Address of parameter string
0B00A7             0127    ; Returns:
0B00A7             0128    ; - HL: Address of first character after token
0B00A7             0129    ; -  C: Length of token (in characters)
0B00A7             0130    ;
0B00A7 0E 00       0131    _get_token:		LD	C, 0			; Initialise length
0B00A9 7E          0132    @@:			LD	A, (HL)			; Get the character from the parameter string
0B00AA B7          0133    			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00AB C8          0134    			RET 	Z
0B00AC FE 0D       0135    			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AE C8          0136    			RET	Z
0B00AF FE 20       0137    			CP	' '			; Exit if space (end of token)
0B00B1 C8          0138    			RET	Z
0B00B2 23          0139    			INC	HL			; Advance to next character
0B00B3 0C          0140    			INC 	C			; Increment length
0B00B4 18 F3       0141    			JR	@B
0B00B6             0142    
0B00B6             0143    ; Skip spaces in the parameter string
0B00B6             0144    ; Parameters:
0B00B6             0145    ; - HL: Address of parameter string
0B00B6             0146    ; Returns:
0B00B6             0147    ; - HL: Address of next none-space character
0B00B6             0148    ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B6             0149    ;
0B00B6 7E          0150    _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B7 FE 20       0151    			CP	' '			; Exit if not space
0B00B9 C0          0152    			RET	NZ
0B00BA 23          0153    			INC	HL			; Advance to next character
0B00BB 18 F9       0154    			JR	_skip_spaces		; Increment length
0B00BD             0155    
0B00BD             0156    ; ========================================
0B00BD             0157    ; BASIC INITIALIZATION CODE FROM basic/init.asm
0B00BD             0158    ; ========================================
0B00BD             0159    ;
0B00BD             0160    ;Clear the application memory
0B00BD             0161    ;
0B00BD             0162    _clear_ram:
0B00BD E5          0163                push hl
0B00BE C5          0164                PUSH		BC
0B00BF 21 00 21 0B 0165    			LD		HL, RAM_START
0B00C3 11 01 21 0B 0166    			LD		DE, RAM_START + 1
0B00C7 01 4F 03 00 0167    			LD		BC, RAM_END - RAM_START - 1
0B00CB AF          0168    			XOR		A
0B00CC 77          0169    			LD		(HL), A
0B00CD ED B0       0170    			LDIR
0B00CF C1          0171    			POP		BC
0B00D0 E1          0172                pop hl
0B00D1 C9          0173    			RET
0B00D2             0174    
0B00D2             0175    ; ========================================
0B00D2             0176    ; BEGIN APPLICATION CODE
0B00D2             0177    ; ========================================
0B00D2             0178    
0B00D2             0179    ; API INCLUDES
0B00D2             0180        include "basic/fpp.asm"
0B00D2             0001*   ;
0B00D2             0002*   ; Title:	BBC Basic Interpreter - Z80 version
0B00D2             0003*   ;		Z80 Floating Point Package
0B00D2             0004*   ; Author:	(C) Copyright  R.T.Russell  1986
0B00D2             0005*   ; Modified By:	Dean Belfield
0B00D2             0006*   ; Created:	03/05/2022
0B00D2             0007*   ; Last Updated:	07/06/2023
0B00D2             0008*   ;
0B00D2             0009*   ; Modinfo:
0B00D2             0010*   ; 26/10/1986:	Version 0.0
0B00D2             0011*   ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0B00D2             0012*   ; 12/05/2023:	Modified by Dean Belfield
0B00D2             0013*   ; 07/06/2023:	Modified to run in ADL mode
0B00D2             0014*   
0B00D2             0015*   			; .ASSUME	ADL = 1
0B00D2             0016*   
0B00D2             0017*   			; SEGMENT CODE
0B00D2             0018*   
0B00D2             0019*   			; XDEF	FPP
0B00D2             0020*   			; XDEF	DLOAD5
0B00D2             0021*   			; XDEF	DLOAD5_SPL
0B00D2             0022*   ;
0B00D2             0023*   ;BINARY FLOATING POINT REPRESENTATION:
0B00D2             0024*   ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B00D2             0025*   ;    8 BIT EXCESS-128 SIGNED EXPONENT
0B00D2             0026*   ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B00D2             0027*   ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B00D2             0028*   ;
0B00D2             0029*   ;BINARY INTEGER REPRESENTATION:
0B00D2             0030*   ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B00D2             0031*   ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B00D2             0032*   ;
0B00D2             0033*   ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B00D2             0034*   ;                            EXPONENT - C
0B00D2             0035*   ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0B00D2             0036*   ;                               EXPONENT - B
0B00D2             0037*   
0B00D2             0038*   ;
0B00D2             0039*   ;Error codes:
0B00D2             0040*   ;
0B00D2             0041*   
0B00D2             0042*   BADOP:			EQU     1               ;Bad operation code
0B00D2             0043*   DIVBY0:			EQU     18              ;Division by zero
0B00D2             0044*   TOOBIG_FP:			EQU     20              ;Too big
0B00D2             0045*   NGROOT:			EQU     21              ;Negative root
0B00D2             0046*   LOGRNG:			EQU     22              ;Log range
0B00D2             0047*   ACLOST:			EQU     23              ;Accuracy lost
0B00D2             0048*   EXPRNG:			EQU     24              ;Exp range
0B00D2             0049*   ;
0B00D2             0050*   ;Call entry and despatch code:
0B00D2             0051*   ;
0B00D2 FD E5       0052*   FPP:			PUSH    IY              ;Save IY
0B00D4 FD 21 00 00 0053*           		LD      IY,0
       00          
0B00D9 FD 39       0054*           		ADD     IY,SP           ;Save SP in IY
0B00DB CD EB 00 0B 0055*           		CALL    OP              ;Perform operation
0B00DF BF          0056*           		CP      A               ;Good return (Z, NC)
0B00E0 FD E1       0057*   EXIT_FP_:			POP     IY              ;Restore IY
0B00E2 C9          0058*           		RET                     ;Return to caller
0B00E3             0059*   ;
0B00E3             0060*   ;Error exit:
0B00E3             0061*   ;
0B00E3 3E 01       0062*   BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0B00E5 FD F9       0063*   ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0B00E7 B7          0064*           		OR      A               ;Set NZ
0B00E8 37          0065*           		SCF                     ;Set C
0B00E9 18 F5       0066*           		JR      EXIT_FP_
0B00EB             0067*   ;
0B00EB             0068*   ;Perform operation or function:
0B00EB             0069*   ;
0B00EB             0070*   ; OP:			CP      (RTABLE-DTABLE)/3
0B00EB FE 2A       0071*   OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B00ED             0072*   
0B00ED 30 F4       0073*           		JR      NC,BAD_FP
0B00EF             0074*           		; CP      (FTABLE-DTABLE)/3
0B00EF FE 10       0075*   				CP      FTABLE-DTABLE/3 ; ditto
0B00F1 30 08       0076*           		JR      NC,DISPAT_FP
0B00F3 08          0077*           		EX      AF,AF'
0B00F4 78          0078*           		LD      A,B
0B00F5 B1          0079*           		OR      C               ;Both integer?
0B00F6 C4 FE 0B 0B 0080*           		CALL    NZ,FLOATA       ;No, so float both
0B00FA 08          0081*           		EX      AF,AF'
0B00FB E5          0082*   DISPAT_FP:			PUSH    HL
0B00FC 21 0E 01 0B 0083*           		LD      HL,DTABLE
0B0100 C5          0084*           		PUSH    BC
0B0101 01 03 00 00 0085*   			LD	BC, 3		; C = 3
0B0105 47          0086*   			LD	B, A 		; B = op-code
0B0106 ED 4C       0087*   			MLT 	BC 		;BC = op-code * 3
0B0108 09          0088*   			ADD	HL, BC 		;Add to table base
0B0109 ED 27       0089*   			LD	HL, (HL)	;Get the routine address (24-bit)
0B010B             0090*   
0B010B             0091*   ;        		ADD     A, A            ;A = op-code * 2
0B010B             0092*   ;        		LD      C,A
0B010B             0093*   ;        		LD      B,0             ;BC = op-code * 2
0B010B             0094*   ;        		ADD     HL,BC
0B010B             0095*   ;        		LD      A,(HL)          ;Get low byte
0B010B             0096*   ;        		INC     HL
0B010B             0097*   ;        		LD      H,(HL)          ;Get high byte
0B010B             0098*   ;        		LD      L,A
0B010B             0099*   
0B010B C1          0100*           		POP     BC
0B010C E3          0101*           		EX      (SP),HL
0B010D C9          0102*           		RET                     ;Off to routine
0B010E             0103*   ;
0B010E             0104*   ;Despatch table:
0B010E             0105*   ;
0B010E C0 01 0B    0106*   DTABLE:			DW24  IAND            ;AND (INTEGER)
0B0111 2E 02 0B    0107*           		DW24  IBDIV           ;DIV
0B0114 D3 01 0B    0108*           		DW24  IEOR            ;EOR
0B0117 F9 01 0B    0109*           		DW24  IMOD            ;MOD
0B011A E6 01 0B    0110*           		DW24  IOR             ;OR
0B011D B4 04 0B    0111*           		DW24  ILE             ;<=
0B0120 C3 04 0B    0112*           		DW24  INE             ;<>
0B0123 A7 04 0B    0113*           		DW24  IGE             ;>=
0B0126 8C 04 0B    0114*           		DW24  ILT             ;<
0B0129 D0 04 0B    0115*           		DW24  IEQ             ;=
0B012C 1C 03 0B    0116*           		DW24  IMUL            ;*
0B012F 57 02 0B    0117*           		DW24  IADD            ;+
0B0132 99 04 0B    0118*           		DW24  IGT             ;>
0B0135 3E 02 0B    0119*           		DW24  ISUB            ;-
0B0138 D3 03 0B    0120*           		DW24  IPOW            ;^
0B013B C9 02 0B    0121*           		DW24  IDIV            ;/
0B013E             0122*   ;
0B013E             0123*   FTABLE:
0B013E E2 04 0B    0124*   				DW24  ABSV_FP            ;ABS
0B0141 C8 08 0B    0125*           		DW24  ACS_FP             ;ACS
0B0144 06 08 0B    0126*           		DW24  ASN_FP             ;ASN
0B0147 36 08 0B    0127*           		DW24  ATN_FP             ;ATN
0B014A 01 06 0B    0128*           		DW24  COS_FP             ;COS
0B014D 10 05 0B    0129*           		DW24  DEG_FP             ;DEG
0B0150 BD 06 0B    0130*           		DW24  EXP_FP             ;EXP
0B0153 64 05 0B    0131*           		DW24  INT_FP_            ;INT
0B0156 5B 07 0B    0132*           		DW24  LN_FP              ;LN
0B0159 F0 07 0B    0133*           		DW24  LOG_FP             ;LOG
0B015C EE 04 0B    0134*           		DW24  NOTK_FP            ;NOT
0B015F 1A 05 0B    0135*           		DW24  RAD_FP             ;RAD
0B0162 35 05 0B    0136*           		DW24  SGN_FP             ;SGN
0B0165 0E 06 0B    0137*           		DW24  SIN_FP             ;SIN
0B0168 7D 05 0B    0138*           		DW24  SQR_FP             ;SQR
0B016B DB 05 0B    0139*           		DW24  TAN_FP             ;TAN
0B016E             0140*   ;
0B016E 8B 0C 0B    0141*   		        DW24  ZERO_FP            ;ZERO
0B0171 96 06 0B    0142*           		DW24  FONE_FP            ;FONE
0B0174 D5 04 0B    0143*           		DW24  TRUE_FP            ;TRUE
0B0177 02 05 0B    0144*           		DW24  PI_FP              ;PI
0B017A             0145*   ;
0B017A 49 05 0B    0146*   		        DW24  VAL_FP             ;VAL
0B017D D1 08 0B    0147*           		DW24  STR_FP             ;STR$
0B0180             0148*   ;
0B0180 32 0B 0B    0149*           		DW24  SFIX_FP            ;FIX
0B0183 0E 0C 0B    0150*           		DW24  SFLOAT_FP          ;FLOAT
0B0186             0151*   ;
0B0186 5C 0C 0B    0152*   		        DW24  FTEST_FP           ;TEST
0B0189 6E 0C 0B    0153*           		DW24  FCOMP_FP           ;COMPARE
0B018C             0154*   ;
0B018C BC 01 0B    0155*   RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B018F 2A 02 0B    0156*           		DW24  FBDIV           ;DIV
0B0192 CF 01 0B    0157*           		DW24  FEOR            ;EOR
0B0195 F5 01 0B    0158*           		DW24  FMOD            ;MOD
0B0198 E2 01 0B    0159*           		DW24  FFOR             ;OR
0B019B AE 04 0B    0160*           		DW24  FLE             ;<=
0B019E BD 04 0B    0161*           		DW24  FNE             ;<>
0B01A1 A1 04 0B    0162*           		DW24  FGE             ;>=
0B01A4 86 04 0B    0163*           		DW24  FLT             ;<
0B01A7 CA 04 0B    0164*           		DW24  FEQ             ;=
0B01AA 76 03 0B    0165*           		DW24  FMUL            ;*
0B01AD 64 02 0B    0166*           		DW24  FADD            ;+
0B01B0 93 04 0B    0167*           		DW24  FGT             ;>
0B01B3 4B 02 0B    0168*           		DW24  FSUB            ;-
0B01B6 53 04 0B    0169*           		DW24  FPOW            ;^
0B01B9 CD 02 0B    0170*           		DW24  FDIV            ;/
0B01BC             0171*   ;
0B01BC             0172*   ;       PAGE
0B01BC             0173*   ;
0B01BC             0174*   ;ARITHMETIC AND LOGICAL OPERATORS:
0B01BC             0175*   ;All take two arguments, in HLH'L'C & DED'E'B.
0B01BC             0176*   ;Output in HLH'L'C
0B01BC             0177*   ;All registers except IX, IY destroyed.
0B01BC             0178*   ; (N.B. FPOW destroys IX).
0B01BC             0179*   ;
0B01BC             0180*   ;FAND - Floating-point AND.
0B01BC             0181*   ;IAND - Integer AND.
0B01BC             0182*   ;
0B01BC CD 26 0B 0B 0183*   FAND:			CALL    FIX2
0B01C0 7C          0184*   IAND:			LD      A,H
0B01C1 A2          0185*           		AND     D
0B01C2 67          0186*           		LD      H,A
0B01C3 7D          0187*           		LD      A,L
0B01C4 A3          0188*           		AND     E
0B01C5 6F          0189*           		LD      L,A
0B01C6 D9          0190*           		EXX
0B01C7 7C          0191*           		LD      A,H
0B01C8 A2          0192*           		AND     D
0B01C9 67          0193*           		LD      H,A
0B01CA 7D          0194*           		LD      A,L
0B01CB A3          0195*           		AND     E
0B01CC 6F          0196*           		LD      L,A
0B01CD D9          0197*           		EXX
0B01CE C9          0198*           		RET
0B01CF             0199*   ;
0B01CF             0200*   ;FEOR - Floating-point exclusive-OR.
0B01CF             0201*   ;IEOR - Integer exclusive-OR.
0B01CF             0202*   ;
0B01CF CD 26 0B 0B 0203*   FEOR:			CALL    FIX2
0B01D3 7C          0204*   IEOR:			LD      A,H
0B01D4 AA          0205*           		XOR     D
0B01D5 67          0206*           		LD      H,A
0B01D6 7D          0207*           		LD      A,L
0B01D7 AB          0208*           		XOR     E
0B01D8 6F          0209*           		LD      L,A
0B01D9 D9          0210*           		EXX
0B01DA 7C          0211*           		LD      A,H
0B01DB AA          0212*           		XOR     D
0B01DC 67          0213*           		LD      H,A
0B01DD 7D          0214*           		LD      A,L
0B01DE AB          0215*           		XOR     E
0B01DF 6F          0216*           		LD      L,A
0B01E0 D9          0217*           		EXX
0B01E1 C9          0218*           		RET
0B01E2             0219*   ;
0B01E2             0220*   ;FOR - Floating-point OR.
0B01E2             0221*   ;IOR - Integer OR.
0B01E2             0222*   ;
0B01E2 CD 26 0B 0B 0223*   FFOR:			CALL    FIX2
0B01E6 7C          0224*   IOR:			LD      A,H
0B01E7 B2          0225*           		OR      D
0B01E8 67          0226*           		LD      H,A
0B01E9 7D          0227*           		LD      A,L
0B01EA B3          0228*           		OR      E
0B01EB 6F          0229*           		LD      L,A
0B01EC D9          0230*           		EXX
0B01ED 7C          0231*           		LD      A,H
0B01EE B2          0232*           		OR      D
0B01EF 67          0233*           		LD      H,A
0B01F0 7D          0234*           		LD      A,L
0B01F1 B3          0235*           		OR      E
0B01F2 6F          0236*           		LD      L,A
0B01F3 D9          0237*           		EXX
0B01F4 C9          0238*           		RET
0B01F5             0239*   ;
0B01F5             0240*   ;FMOD - Floating-point remainder.
0B01F5             0241*   ;IMOD - Integer remainder.
0B01F5             0242*   ;
0B01F5 CD 26 0B 0B 0243*   FMOD:			CALL    FIX2
0B01F9 7C          0244*   IMOD:			LD      A,H
0B01FA AA          0245*           		XOR     D               ;DIV RESULT SIGN
0B01FB CB 7C       0246*           		BIT     7,H
0B01FD 08          0247*           		EX      AF,AF'
0B01FE CB 7C       0248*           		BIT     7,H
0B0200 C4 42 0B 0B 0249*           		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B0204 CD 3F 0C 0B 0250*           		CALL    SWAP_FP
0B0208 CB 7C       0251*           		BIT     7,H
0B020A C4 42 0B 0B 0252*           		CALL    NZ,NEGATE
0B020E 44          0253*           		LD      B,H
0B020F 4D          0254*           		LD      C,L
0B0210 21 00 00 00 0255*           		LD      HL,0
0B0214 D9          0256*           		EXX
0B0215 44          0257*           		LD      B,H
0B0216 4D          0258*           		LD      C,L
0B0217 21 00 00 00 0259*           		LD      HL,0
0B021B 3E DF       0260*           		LD      A,-33
0B021D CD CC 0D 0B 0261*           		CALL    DIVA            ;DIVIDE
0B0221 D9          0262*           		EXX
0B0222 0E 00       0263*           		LD      C,0             ;INTEGER MARKER
0B0224 08          0264*           		EX      AF,AF'
0B0225 C8          0265*           		RET     Z
0B0226 C3 42 0B 0B 0266*           		JP      NEGATE
0B022A             0267*   ;
0B022A             0268*   ;BDIV - Integer division.
0B022A             0269*   ;
0B022A CD 26 0B 0B 0270*   FBDIV:			CALL    FIX2
0B022E CD F9 01 0B 0271*   IBDIV:			CALL    IMOD
0B0232 B7          0272*           		OR      A
0B0233 CD 3F 0C 0B 0273*           		CALL    SWAP_FP
0B0237 0E 00       0274*           		LD      C,0
0B0239 F0          0275*           		RET     P
0B023A C3 42 0B 0B 0276*           		JP      NEGATE
0B023E             0277*   ;
0B023E             0278*   ;ISUB - Integer subtraction.
0B023E             0279*   ;FSUB - Floating point subtraction with rounding.
0B023E             0280*   ;
0B023E CD DA 0C 0B 0281*   ISUB:			CALL    SUB_
0B0242 E0          0282*           		RET     PO
0B0243 CD D2 0C 0B 0283*           		CALL    ADD_
0B0247 CD 02 0C 0B 0284*           		CALL    FLOAT2
0B024B 7A          0285*   FSUB:			LD      A,D
0B024C EE 80       0286*           		XOR     80H             ;CHANGE SIGN THEN ADD
0B024E 57          0287*           		LD      D,A
0B024F 18 13       0288*           		JR      FADD
0B0251             0289*   ;
0B0251             0290*   ;Reverse subtract.
0B0251             0291*   ;
0B0251 7C          0292*   RSUB:			LD      A,H
0B0252 EE 80       0293*           		XOR     80H
0B0254 67          0294*           		LD      H,A
0B0255 18 0D       0295*           		JR      FADD
0B0257             0296*   ;
0B0257             0297*   ;IADD - Integer addition.
0B0257             0298*   ;FADD - Floating point addition with rounding.
0B0257             0299*   ;
0B0257 CD D2 0C 0B 0300*   IADD:			CALL    ADD_
0B025B E0          0301*           		RET     PO
0B025C CD DA 0C 0B 0302*           		CALL    SUB_
0B0260 CD 02 0C 0B 0303*           		CALL    FLOAT2
0B0264 05          0304*   FADD:			DEC     B
0B0265 04          0305*           		INC     B
0B0266 C8          0306*           		RET     Z               ;ARG 2 ZERO
0B0267 0D          0307*           		DEC     C
0B0268 0C          0308*           		INC     C
0B0269 CA 3F 0C 0B 0309*           		JP      Z,SWAP_FP          ;ARG 1 ZERO
0B026D D9          0310*           		EXX
0B026E 01 00 00 00 0311*           		LD      BC,0            ;INITIALISE
0B0272 D9          0312*           		EXX
0B0273 7C          0313*           		LD      A,H
0B0274 AA          0314*           		XOR     D               ;XOR SIGNS
0B0275 F5          0315*           		PUSH    AF
0B0276 78          0316*           		LD      A,B
0B0277 B9          0317*           		CP      C               ;COMPARE EXPONENTS
0B0278 DC 3F 0C 0B 0318*           		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B027C 78          0319*           		LD      A,B
0B027D CB FC       0320*           		SET     7,H             ;IMPLIED 1
0B027F C4 13 0B 0B 0321*           		CALL    NZ,FIX          ;ALIGN
0B0283 F1          0322*           		POP     AF
0B0284 7A          0323*           		LD      A,D             ;SIGN OF LARGER
0B0285 CB FA       0324*           		SET     7,D             ;IMPLIED 1
0B0287 FA 97 02 0B 0325*           		JP      M,FADD3         ;SIGNS DIFFERENT
0B028B CD D2 0C 0B 0326*           		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B028F DC 47 0C 0B 0327*           		CALL    C,DIV2          ;NORMALISE
0B0293 CB FC       0328*           		SET     7,H
0B0295 18 0D       0329*           		JR      FADD4
0B0297             0330*   ;
0B0297 CD DA 0C 0B 0331*   FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B029B DC 5A 0B 0B 0332*           		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B029F CD D9 0B 0B 0333*           		CALL    FLO48
0B02A3 2F          0334*           		CPL                     ;CHANGE RESULT SIGN
0B02A4 D9          0335*   FADD4:			EXX
0B02A5 EB          0336*           		EX      DE,HL
0B02A6 21 00 80 00 0337*           		LD      HL,8000H
0B02AA B7          0338*           		OR      A               ;CLEAR CARRY
0B02AB 52 ED 42    0339*           		SBC.S   HL,BC
0B02AE EB          0340*           		EX      DE,HL
0B02AF D9          0341*           		EXX
0B02B0 CC 39 0C 0B 0342*           		CALL    Z,ODD           ;ROUND UNBIASSED
0B02B4 DC 27 0C 0B 0343*           		CALL    C,ADD1_FP          ;ROUND UP
0B02B8 DC 54 0C 0B 0344*           		CALL    C,INCC
0B02BC CB BC       0345*           		RES     7,H
0B02BE 0D          0346*           		DEC     C
0B02BF 0C          0347*           		INC     C
0B02C0 CA 8B 0C 0B 0348*           		JP      Z,ZERO_FP
0B02C4 B7          0349*           		OR      A               ;RESULT SIGNQ
0B02C5 F0          0350*           		RET     P               ;POSITIVE
0B02C6 CB FC       0351*           		SET     7,H             ;NEGATIVE
0B02C8 C9          0352*           		RET
0B02C9             0353*   ;
0B02C9             0354*   ;IDIV - Integer division.
0B02C9             0355*   ;FDIV - Floating point division with rounding.
0B02C9             0356*   ;
0B02C9 CD 02 0C 0B 0357*   IDIV:			CALL    FLOAT2
0B02CD 05          0358*   FDIV:			DEC     B               ;TEST FOR ZERO
0B02CE 04          0359*           		INC     B
0B02CF 3E 12       0360*           		LD      A,DIVBY0
0B02D1 CA E5 00 0B 0361*           		JP      Z,ERROR_FP_         ;"Division by zero"
0B02D5 0D          0362*           		DEC     C               ;TEST FOR ZERO
0B02D6 0C          0363*           		INC     C
0B02D7 C8          0364*           		RET     Z
0B02D8 7C          0365*           		LD      A,H
0B02D9 AA          0366*           		XOR     D               ;CALC. RESULT SIGN
0B02DA 08          0367*           		EX      AF,AF'          ;SAVE SIGN
0B02DB CB FA       0368*           		SET     7,D             ;REPLACE IMPLIED 1's
0B02DD CB FC       0369*           		SET     7,H
0B02DF C5          0370*           		PUSH    BC              ;SAVE EXPONENTS
0B02E0 42          0371*           		LD      B,D             ;LOAD REGISTERS
0B02E1 4B          0372*           		LD      C,E
0B02E2 11 00 00 00 0373*           		LD      DE,0
0B02E6 D9          0374*           		EXX
0B02E7 42          0375*           		LD      B,D
0B02E8 4B          0376*           		LD      C,E
0B02E9 11 00 00 00 0377*           		LD      DE,0
0B02ED 3E E0       0378*           		LD      A,-32           ;LOOP COUNTER
0B02EF CD CC 0D 0B 0379*           		CALL    DIVA            ;DIVIDE
0B02F3 D9          0380*           		EXX
0B02F4 CB 7A       0381*           		BIT     7,D
0B02F6 D9          0382*           		EXX
0B02F7 CC EB 0D 0B 0383*           		CALL    Z,DIVB          ;NORMALISE & INC A
0B02FB EB          0384*           		EX      DE,HL
0B02FC D9          0385*           		EXX
0B02FD CB 38       0386*           		SRL     B               ;DIVISOR/2
0B02FF CB 19       0387*           		RR      C
0B0301 B7          0388*           		OR      A               ;CLEAR CARRY
0B0302 52 ED 42    0389*           		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B0305 3F          0390*           		CCF
0B0306 EB          0391*           		EX      DE,HL           ;RESULT IN HLH'L'
0B0307 CC 39 0C 0B 0392*           		CALL    Z,ODD           ;ROUND UNBIASSED
0B030B DC 27 0C 0B 0393*           		CALL    C,ADD1_FP          ;ROUND UP
0B030F C1          0394*           		POP     BC              ;RESTORE EXPONENTS
0B0310 DC 54 0C 0B 0395*           		CALL    C,INCC
0B0314 1F          0396*           		RRA                     ;LSB OF A TO CARRY
0B0315 79          0397*           		LD      A,C             ;COMPUTE NEW EXPONENT
0B0316 98          0398*           		SBC     A,B
0B0317 3F          0399*           		CCF
0B0318 C3 B9 03 0B 0400*           		JP      CHKOVF
0B031C             0401*   ;
0B031C             0402*   ;IMUL - Integer multiplication.
0B031C             0403*   ;
0B031C 7C          0404*   IMUL:			LD      A,H
0B031D AA          0405*           		XOR     D
0B031E 08          0406*           		EX      AF,AF'          ;SAVE RESULT SIGN
0B031F CB 7C       0407*           		BIT     7,H
0B0321 C4 42 0B 0B 0408*           		CALL    NZ,NEGATE
0B0325 CD 3F 0C 0B 0409*           		CALL    SWAP_FP
0B0329 CB 7C       0410*           		BIT     7,H
0B032B C4 42 0B 0B 0411*           		CALL    NZ,NEGATE
0B032F 44          0412*           		LD      B,H
0B0330 4D          0413*           		LD      C,L
0B0331 21 00 00 00 0414*           		LD      HL,0
0B0335 D9          0415*           		EXX
0B0336 44          0416*           		LD      B,H
0B0337 4D          0417*           		LD      C,L
0B0338 21 00 00 00 0418*           		LD      HL,0
0B033C 3E DF       0419*           		LD      A,-33
0B033E CD 03 0E 0B 0420*           		CALL    MULA            ;MULTIPLY
0B0342 D9          0421*           		EXX
0B0343 0E BF       0422*           		LD      C,191           ;PRESET EXPONENT
0B0345 CD 67 0C 0B 0423*           		CALL    TEST_FP            ;TEST RANGE
0B0349 20 0F       0424*           		JR      NZ,IMUL1        ;TOO BIG
0B034B CB 7A       0425*           		BIT     7,D
0B034D 20 0B       0426*           		JR      NZ,IMUL1
0B034F CD 3F 0C 0B 0427*           		CALL    SWAP_FP
0B0353 4A          0428*           		LD      C,D             ;INTEGER MARKER
0B0354 08          0429*           		EX      AF,AF'
0B0355 F0          0430*           		RET     P
0B0356 C3 42 0B 0B 0431*           		JP      NEGATE
0B035A             0432*   ;
0B035A 0D          0433*   IMUL1:			DEC     C
0B035B D9          0434*           		EXX
0B035C CB 23       0435*           		SLA     E
0B035E CB 12       0436*           		RL      D
0B0360 D9          0437*           		EXX
0B0361 CB 13       0438*           		RL      E
0B0363 CB 12       0439*           		RL      D
0B0365 D9          0440*           		EXX
0B0366 52 ED 6A    0441*           		ADC.S   HL,HL
0B0369 D9          0442*           		EXX
0B036A 52 ED 6A    0443*           		ADC.S   HL,HL
0B036D F2 5A 03 0B 0444*           		JP      P,IMUL1         ;NORMALISE
0B0371 08          0445*           		EX      AF,AF'
0B0372 F8          0446*           		RET     M
0B0373 CB BC       0447*           		RES     7,H             ;POSITIVE
0B0375 C9          0448*           		RET
0B0376             0449*   ;
0B0376             0450*   ;FMUL - Floating point multiplication with rounding.
0B0376             0451*   ;
0B0376 05          0452*   FMUL:			DEC     B               ;TEST FOR ZERO
0B0377 04          0453*           		INC     B
0B0378 CA 8B 0C 0B 0454*           		JP      Z,ZERO_FP
0B037C 0D          0455*           		DEC     C               ;TEST FOR ZERO
0B037D 0C          0456*           		INC     C
0B037E C8          0457*           		RET     Z
0B037F 7C          0458*           		LD      A,H
0B0380 AA          0459*           		XOR     D               ;CALC. RESULT SIGN
0B0381 08          0460*           		EX      AF,AF'
0B0382 CB FA       0461*           		SET     7,D             ;REPLACE IMPLIED 1's
0B0384 CB FC       0462*           		SET     7,H
0B0386 C5          0463*           		PUSH    BC              ;SAVE EXPONENTS
0B0387 44          0464*           		LD      B,H             ;LOAD REGISTERS
0B0388 4D          0465*           		LD      C,L
0B0389 21 00 00 00 0466*           		LD      HL,0
0B038D D9          0467*           		EXX
0B038E 44          0468*           		LD      B,H
0B038F 4D          0469*           		LD      C,L
0B0390 21 00 00 00 0470*           		LD      HL,0
0B0394 3E E0       0471*           		LD      A,-32           ;LOOP COUNTER
0B0396 CD 03 0E 0B 0472*           		CALL    MULA            ;MULTIPLY
0B039A DC 19 0E 0B 0473*           		CALL    C,MULB          ;NORMALISE & INC A
0B039E D9          0474*           		EXX
0B039F E5          0475*           		PUSH    HL
0B03A0 21 00 80 00 0476*           		LD      HL,8000H
0B03A4 B7          0477*           		OR      A               ;CLEAR CARRY
0B03A5 52 ED 52    0478*           		SBC.S   HL,DE
0B03A8 E1          0479*           		POP     HL
0B03A9 CC 39 0C 0B 0480*           		CALL    Z,ODD           ;ROUND UNBIASSED
0B03AD DC 27 0C 0B 0481*           		CALL    C,ADD1_FP          ;ROUND UP
0B03B1 C1          0482*           		POP     BC              ;RESTORE EXPONENTS
0B03B2 DC 54 0C 0B 0483*           		CALL    C,INCC
0B03B6 1F          0484*           		RRA                     ;LSB OF A TO CARRY
0B03B7 79          0485*           		LD      A,C             ;COMPUTE NEW EXPONENT
0B03B8 88          0486*           		ADC     A,B
0B03B9 38 06       0487*   CHKOVF:			JR      C,CHKO1
0B03BB F2 8B 0C 0B 0488*           		JP      P,ZERO_FP          ;UNDERFLOW
0B03BF 18 04       0489*           		JR      CHKO2
0B03C1 FA 56 0C 0B 0490*   CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B03C5 C6 80       0491*   CHKO2:			ADD     A,80H
0B03C7 4F          0492*           		LD      C,A
0B03C8 CA 8B 0C 0B 0493*           		JP      Z,ZERO_FP
0B03CC 08          0494*           		EX      AF,AF'          ;RESTORE SIGN BIT
0B03CD CB BC       0495*           		RES     7,H
0B03CF F0          0496*           		RET     P
0B03D0 CB FC       0497*           		SET     7,H
0B03D2 C9          0498*           		RET
0B03D3             0499*   ;
0B03D3             0500*   ;IPOW - Integer involution.
0B03D3             0501*   ;
0B03D3 CD 3F 0C 0B 0502*   IPOW:			CALL    SWAP_FP
0B03D7 CB 7C       0503*           		BIT     7,H
0B03D9 F5          0504*           		PUSH    AF              ;SAVE SIGN
0B03DA C4 42 0B 0B 0505*           		CALL    NZ,NEGATE
0B03DE 48          0506*   IPOW0:			LD      C,B
0B03DF 06 20       0507*           		LD      B,32            ;LOOP COUNTER
0B03E1 CD F7 0C 0B 0508*   IPOW1:			CALL    X2
0B03E5 38 08       0509*           		JR      C,IPOW2
0B03E7 10 F8       0510*           		DJNZ    IPOW1
0B03E9 F1          0511*           		POP     AF
0B03EA D9          0512*           		EXX
0B03EB 2C          0513*           		INC     L               ;RESULT=1
0B03EC D9          0514*           		EXX
0B03ED 4C          0515*           		LD      C,H
0B03EE C9          0516*           		RET
0B03EF             0517*   ;
0B03EF F1          0518*   IPOW2:			POP     AF
0B03F0 C5          0519*           		PUSH    BC
0B03F1 EB          0520*           		EX      DE,HL
0B03F2 E5          0521*           		PUSH    HL
0B03F3 D9          0522*           		EXX
0B03F4 EB          0523*           		EX      DE,HL
0B03F5 E5          0524*           		PUSH    HL
0B03F6 D9          0525*           		EXX
0B03F7 DD 21 00 00 0526*           		LD      IX,0
       00          
0B03FC DD 39       0527*           		ADD     IX,SP
0B03FE 28 48       0528*           		JR      Z,IPOW4
0B0400 C5          0529*           		PUSH    BC
0B0401 D9          0530*           		EXX
0B0402 D5          0531*           		PUSH    DE
0B0403 D9          0532*           		EXX
0B0404 D5          0533*           		PUSH    DE
0B0405 CD 0E 0C 0B 0534*           		CALL    SFLOAT_FP
0B0409 CD 42 07 0B 0535*           		CALL    RECIP
0B040D DD 71 04    0536*           		LD      (IX+4),C
0B0410 D9          0537*           		EXX
0B0411 DD 75 00    0538*           		LD      (IX+0),L
0B0414 DD 74 01    0539*           		LD      (IX+1),H
0B0417 D9          0540*           		EXX
0B0418 DD 75 02    0541*           		LD      (IX+2),L
0B041B DD 74 03    0542*           		LD      (IX+3),H
0B041E 18 21       0543*           		JR      IPOW5
0B0420             0544*   ;
0B0420 C5          0545*   IPOW3:			PUSH    BC
0B0421 D9          0546*           		EXX
0B0422 CB 23       0547*           		SLA     E
0B0424 CB 12       0548*           		RL      D
0B0426 D5          0549*           		PUSH    DE
0B0427 D9          0550*           		EXX
0B0428 CB 13       0551*           		RL      E
0B042A CB 12       0552*           		RL      D
0B042C D5          0553*           		PUSH    DE
0B042D 3E 0A       0554*           		LD      A,'*' & 0FH
0B042F F5          0555*           		PUSH    AF
0B0430 CD 0B 0D 0B 0556*           		CALL    COPY_
0B0434 CD EB 00 0B 0557*           		CALL    OP              ;SQUARE
0B0438 F1          0558*           		POP     AF
0B0439 CD 37 0A 0B 0559*           		CALL    DLOAD5
0B043D DC EB 00 0B 0560*           		CALL    C,OP            ;MULTIPLY BY X
0B0441 D1          0561*   IPOW5:			POP     DE
0B0442 D9          0562*           		EXX
0B0443 D1          0563*           		POP     DE
0B0444 D9          0564*           		EXX
0B0445 79          0565*           		LD      A,C
0B0446 C1          0566*           		POP     BC
0B0447 4F          0567*           		LD      C,A
0B0448 10 D6       0568*   IPOW4:			DJNZ    IPOW3
0B044A F1          0569*           		POP     AF
0B044B F1          0570*           		POP     AF
0B044C F1          0571*           		POP     AF
0B044D C9          0572*           		RET
0B044E             0573*   ;
0B044E F1          0574*   FPOW0:			POP     AF
0B044F F1          0575*           		POP     AF
0B0450 F1          0576*           		POP     AF
0B0451 18 8B       0577*           		JR      IPOW0
0B0453             0578*   ;
0B0453             0579*   ;FPOW - Floating-point involution.
0B0453             0580*   ;
0B0453 CB 7A       0581*   FPOW:			BIT     7,D
0B0455 F5          0582*           		PUSH    AF
0B0456 CD 3F 0C 0B 0583*           		CALL    SWAP_FP
0B045A CD 1B 0D 0B 0584*           		CALL    PUSH5
0B045E 0D          0585*           		DEC     C
0B045F 0C          0586*           		INC     C
0B0460 28 EC       0587*           		JR      Z,FPOW0
0B0462 3E 9E       0588*           		LD      A,158
0B0464 B9          0589*           		CP      C
0B0465 38 0A       0590*           		JR      C,FPOW1
0B0467 3C          0591*           		INC     A
0B0468 CD 13 0B 0B 0592*           		CALL    FIX
0B046C 08          0593*           		EX      AF,AF'
0B046D F2 4E 04 0B 0594*           		JP      P,FPOW0
0B0471 CD 3F 0C 0B 0595*   FPOW1:			CALL    SWAP_FP
0B0475 CD 5F 07 0B 0596*           		CALL    LN0
0B0479 CD 24 0D 0B 0597*           		CALL    POP5
0B047D F1          0598*           		POP     AF
0B047E CD 76 03 0B 0599*           		CALL    FMUL
0B0482 C3 C1 06 0B 0600*           		JP      EXP0
0B0486             0601*   ;
0B0486             0602*   ;Integer and floating-point compare.
0B0486             0603*   ;Result is TRUE (-1) or FALSE (0).
0B0486             0604*   ;
0B0486 CD 95 0C 0B 0605*   FLT:			CALL    FCP
0B048A 18 04       0606*           		JR      ILT1
0B048C CD 87 0C 0B 0607*   ILT:			CALL    ICP
0B0490 D0          0608*   ILT1:			RET     NC
0B0491 18 42       0609*           		JR      TRUE_FP
0B0493             0610*   ;
0B0493 CD 95 0C 0B 0611*   FGT:			CALL    FCP
0B0497 18 04       0612*           		JR      IGT1
0B0499 CD 87 0C 0B 0613*   IGT:			CALL    ICP
0B049D C8          0614*   IGT1:			RET     Z
0B049E D8          0615*           		RET     C
0B049F 18 34       0616*           		JR      TRUE_FP
0B04A1             0617*   ;
0B04A1 CD 95 0C 0B 0618*   FGE:			CALL    FCP
0B04A5 18 04       0619*           		JR      IGE1
0B04A7 CD 87 0C 0B 0620*   IGE:			CALL    ICP
0B04AB D8          0621*   IGE1:			RET     C
0B04AC 18 27       0622*           		JR      TRUE_FP
0B04AE             0623*   ;
0B04AE CD 95 0C 0B 0624*   FLE:			CALL    FCP
0B04B2 18 04       0625*           		JR      ILE1
0B04B4 CD 87 0C 0B 0626*   ILE:			CALL    ICP
0B04B8 28 1B       0627*   ILE1:			JR      Z,TRUE_FP
0B04BA D0          0628*           		RET     NC
0B04BB 18 18       0629*           		JR      TRUE_FP
0B04BD             0630*   ;
0B04BD CD 95 0C 0B 0631*   FNE:			CALL    FCP
0B04C1 18 04       0632*           		JR      INE1
0B04C3 CD 87 0C 0B 0633*   INE:			CALL    ICP
0B04C7 C8          0634*   INE1:			RET     Z
0B04C8 18 0B       0635*           		JR      TRUE_FP
0B04CA             0636*   ;
0B04CA CD 95 0C 0B 0637*   FEQ:			CALL    FCP
0B04CE 18 04       0638*           		JR      IEQ1
0B04D0 CD 87 0C 0B 0639*   IEQ:			CALL    ICP
0B04D4 C0          0640*   IEQ1:			RET     NZ
0B04D5 21 FF FF FF 0641*   TRUE_FP:			LD      HL,-1
0B04D9 D9          0642*           		EXX
0B04DA 21 FF FF FF 0643*           		LD      HL,-1
0B04DE D9          0644*           		EXX
0B04DF AF          0645*           		XOR     A
0B04E0 4F          0646*           		LD      C,A
0B04E1 C9          0647*           		RET
0B04E2             0648*   ;
0B04E2             0649*   ;FUNCTIONS:
0B04E2             0650*   ;
0B04E2             0651*   ;Result returned in HLH'L'C (floating point)
0B04E2             0652*   ;Result returned in HLH'L' (C=0) (integer)
0B04E2             0653*   ;All registers except IY destroyed.
0B04E2             0654*   ;
0B04E2             0655*   ;ABS - Absolute value
0B04E2             0656*   ;Result is numeric, variable type.
0B04E2             0657*   ;
0B04E2 CB 7C       0658*   ABSV_FP:			BIT     7,H
0B04E4 C8          0659*           		RET     Z               ;POSITIVE/ZERO
0B04E5 0D          0660*           		DEC     C
0B04E6 0C          0661*           		INC     C
0B04E7 CA 42 0B 0B 0662*           		JP      Z,NEGATE        ;INTEGER
0B04EB CB BC       0663*           		RES     7,H
0B04ED C9          0664*           		RET
0B04EE             0665*   ;
0B04EE             0666*   ;NOT - Complement integer.
0B04EE             0667*   ;Result is integer numeric.
0B04EE             0668*   ;
0B04EE CD 32 0B 0B 0669*   NOTK_FP:			CALL    SFIX_FP
0B04F2 7C          0670*           		LD      A,H
0B04F3 2F          0671*           		CPL
0B04F4 67          0672*           		LD      H,A
0B04F5 7D          0673*           		LD      A,L
0B04F6 2F          0674*           		CPL
0B04F7 6F          0675*           		LD      L,A
0B04F8 D9          0676*           		EXX
0B04F9 7C          0677*           		LD      A,H
0B04FA 2F          0678*           		CPL
0B04FB 67          0679*           		LD      H,A
0B04FC 7D          0680*           		LD      A,L
0B04FD 2F          0681*           		CPL
0B04FE 6F          0682*           		LD      L,A
0B04FF D9          0683*           		EXX
0B0500 AF          0684*           		XOR     A               ;NUMERIC MARKER
0B0501 C9          0685*           		RET
0B0502             0686*   ;
0B0502             0687*   ;PI - Return PI (3.141592654)
0B0502             0688*   ;Result is floating-point numeric.
0B0502             0689*   ;
0B0502 21 0F 49 00 0690*   PI_FP:			LD      HL,490FH
0B0506 D9          0691*           		EXX
0B0507 21 A2 DA 00 0692*           		LD      HL,0DAA2H
0B050B D9          0693*           		EXX
0B050C 0E 81       0694*           		LD      C,81H
0B050E AF          0695*           		XOR     A               ;NUMERIC MARKER
0B050F C9          0696*           		RET
0B0510             0697*   ;
0B0510             0698*   ;DEG - Convert radians to degrees
0B0510             0699*   ;Result is floating-point numeric.
0B0510             0700*   ;
0B0510 CD 24 05 0B 0701*   DEG_FP:			CALL    FPI180
0B0514 CD 76 03 0B 0702*           		CALL    FMUL
0B0518 AF          0703*           		XOR     A
0B0519 C9          0704*           		RET
0B051A             0705*   ;
0B051A             0706*   ;RAD - Convert degrees to radians
0B051A             0707*   ;Result is floating-point numeric.
0B051A             0708*   ;
0B051A CD 24 05 0B 0709*   RAD_FP:			CALL    FPI180
0B051E CD CD 02 0B 0710*           		CALL    FDIV
0B0522 AF          0711*           		XOR     A
0B0523 C9          0712*           		RET
0B0524             0713*   ;
0B0524             0714*   ;180/PI
0B0524             0715*   ;
0B0524 CD 0E 0C 0B 0716*   FPI180:			CALL    SFLOAT_FP
0B0528 11 2E 65 00 0717*           		LD      DE,652EH
0B052C D9          0718*           		EXX
0B052D 11 D3 E0 00 0719*           		LD      DE,0E0D3H
0B0531 D9          0720*           		EXX
0B0532 06 85       0721*           		LD      B,85H
0B0534 C9          0722*           		RET
0B0535             0723*   ;
0B0535             0724*   ;SGN - Return -1, 0 or +1
0B0535             0725*   ;Result is integer numeric.
0B0535             0726*   ;
0B0535 CD 67 0C 0B 0727*   SGN_FP:			CALL    TEST_FP
0B0539 B1          0728*           		OR      C
0B053A C8          0729*           		RET     Z               ;ZERO
0B053B CB 7C       0730*           		BIT     7,H
0B053D C2 D5 04 0B 0731*           		JP      NZ,TRUE_FP         ;-1
0B0541 CD 8B 0C 0B 0732*           		CALL    ZERO_FP
0B0545 C3 27 0C 0B 0733*           		JP      ADD1_FP            ;1
0B0549             0734*   ;
0B0549             0735*   ;VAL - Return numeric value of string.
0B0549             0736*   ;Input: ASCII string at IX
0B0549             0737*   ;Result is variable type numeric.
0B0549             0738*   ;
0B0549 CD A5 0E 0B 0739*   VAL_FP:			CALL    SIGNQ
0B054D F5          0740*           		PUSH    AF
0B054E CD 55 0A 0B 0741*           		CALL    CON_FP
0B0552 F1          0742*           		POP     AF
0B0553 FE 2D       0743*           		CP      '-'
0B0555 3E 00       0744*           		LD      A,0             ;NUMERIC MARKER
0B0557 C0          0745*           		RET     NZ
0B0558 0D          0746*           		DEC     C
0B0559 0C          0747*           		INC     C
0B055A CA 42 0B 0B 0748*           		JP      Z,NEGATE        ;ZERO/INTEGER
0B055E 7C          0749*           		LD      A,H
0B055F EE 80       0750*           		XOR     80H             ;CHANGE SIGN (FP)
0B0561 67          0751*           		LD      H,A
0B0562 AF          0752*           		XOR     A
0B0563 C9          0753*           		RET
0B0564             0754*   ;
0B0564             0755*   ;INT - Floor function
0B0564             0756*   ;Result is integer numeric.
0B0564             0757*   ;
0B0564 0D          0758*   INT_FP_:			DEC     C
0B0565 0C          0759*           		INC     C
0B0566 C8          0760*           		RET     Z               ;ZERO/INTEGER
0B0567 3E 9F       0761*           		LD      A,159
0B0569 44          0762*           		LD      B,H             ;B7=SIGN BIT
0B056A CD 13 0B 0B 0763*           		CALL    FIX
0B056E 08          0764*           		EX      AF,AF'
0B056F A0          0765*           		AND     B
0B0570 FC 27 0C 0B 0766*           		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
0B0574 78          0767*           		LD      A,B
0B0575 B7          0768*           		OR      A
0B0576 FC 42 0B 0B 0769*           		CALL    M,NEGATE
0B057A AF          0770*           		XOR     A
0B057B 4F          0771*           		LD      C,A
0B057C C9          0772*           		RET
0B057D             0773*   ;
0B057D             0774*   ;SQR - square root
0B057D             0775*   ;Result is floating-point numeric.
0B057D             0776*   ;
0B057D CD 0E 0C 0B 0777*   SQR_FP:			CALL    SFLOAT_FP
0B0581 CB 7C       0778*   SQR0:			BIT     7,H
0B0583 3E 15       0779*           		LD      A,NGROOT
0B0585 C2 E5 00 0B 0780*           		JP      NZ,ERROR_FP_        ;"-ve root"
0B0589 0D          0781*           		DEC     C
0B058A 0C          0782*           		INC     C
0B058B C8          0783*           		RET     Z               ;ZERO
0B058C CB FC       0784*           		SET     7,H             ;IMPLIED 1
0B058E CB 41       0785*           		BIT     0,C
0B0590 CC 47 0C 0B 0786*           		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B0594 79          0787*           		LD      A,C
0B0595 D6 80       0788*           		SUB     80H
0B0597 CB 2F       0789*           		SRA     A               ;HALVE EXPONENT
0B0599 C6 80       0790*           		ADD     A,80H
0B059B 4F          0791*           		LD      C,A
0B059C C5          0792*           		PUSH    BC              ;SAVE EXPONENT
0B059D EB          0793*           		EX      DE,HL
0B059E 21 00 00 00 0794*           		LD      HL,0
0B05A2 44          0795*           		LD      B,H
0B05A3 4D          0796*           		LD      C,L
0B05A4 D9          0797*           		EXX
0B05A5 EB          0798*           		EX      DE,HL
0B05A6 21 00 00 00 0799*           		LD      HL,0
0B05AA 44          0800*           		LD      B,H
0B05AB 4D          0801*           		LD      C,L
0B05AC 3E E1       0802*           		LD      A,-31
0B05AE CD 3D 0E 0B 0803*           		CALL    SQRA            ;ROOT
0B05B2 D9          0804*           		EXX
0B05B3 CB 78       0805*           		BIT     7,B
0B05B5 D9          0806*           		EXX
0B05B6 CC 3D 0E 0B 0807*           		CALL    Z,SQRA          ;NORMALISE & INC A
0B05BA CD 7E 0E 0B 0808*           		CALL    SQRB
0B05BE B7          0809*           		OR      A               ;CLEAR CARRY
0B05BF CD EB 0D 0B 0810*           		CALL    DIVB
0B05C3 CB 1B       0811*           		RR      E               ;LSB TO CARRY
0B05C5 60          0812*           		LD      H,B
0B05C6 69          0813*           		LD      L,C
0B05C7 D9          0814*           		EXX
0B05C8 60          0815*           		LD      H,B
0B05C9 69          0816*           		LD      L,C
0B05CA DC 27 0C 0B 0817*           		CALL    C,ADD1_FP          ;ROUND UP
0B05CE C1          0818*           		POP     BC              ;RESTORE EXPONENT
0B05CF DC 54 0C 0B 0819*           		CALL    C,INCC
0B05D3 1F          0820*           		RRA
0B05D4 9F          0821*           		SBC     A,A
0B05D5 81          0822*           		ADD     A,C
0B05D6 4F          0823*           		LD      C,A
0B05D7 CB BC       0824*           		RES     7,H             ;POSITIVE
0B05D9 AF          0825*           		XOR     A
0B05DA C9          0826*           		RET
0B05DB             0827*   ;
0B05DB             0828*   ;TAN - Tangent function
0B05DB             0829*   ;Result is floating-point numeric.
0B05DB             0830*   ;
0B05DB CD 0E 0C 0B 0831*   TAN_FP:			CALL    SFLOAT_FP
0B05DF CD 1B 0D 0B 0832*           		CALL    PUSH5
0B05E3 CD 05 06 0B 0833*           		CALL    COS0
0B05E7 CD 24 0D 0B 0834*           		CALL    POP5
0B05EB CD 1B 0D 0B 0835*           		CALL    PUSH5
0B05EF CD 3F 0C 0B 0836*           		CALL    SWAP_FP
0B05F3 CD 12 06 0B 0837*           		CALL    SIN0
0B05F7 CD 24 0D 0B 0838*           		CALL    POP5
0B05FB CD CD 02 0B 0839*           		CALL    FDIV
0B05FF AF          0840*           		XOR     A               ;NUMERIC MARKER
0B0600 C9          0841*           		RET
0B0601             0842*   ;
0B0601             0843*   ;COS - Cosine function
0B0601             0844*   ;Result is floating-point numeric.
0B0601             0845*   ;
0B0601 CD 0E 0C 0B 0846*   COS_FP:			CALL    SFLOAT_FP
0B0605 CD 6A 0B 0B 0847*   COS0:			CALL    SCALE
0B0609 1C          0848*           		INC     E
0B060A 1C          0849*           		INC     E
0B060B 7B          0850*           		LD      A,E
0B060C 18 10       0851*           		JR      SIN1
0B060E             0852*   ;
0B060E             0853*   ;SIN - Sine function
0B060E             0854*   ;Result is floating-point numeric.
0B060E             0855*   ;
0B060E CD 0E 0C 0B 0856*   SIN_FP:			CALL    SFLOAT_FP
0B0612 E5          0857*   SIN0:			PUSH    HL              ;H7=SIGN
0B0613 CD 6A 0B 0B 0858*           		CALL    SCALE
0B0617 F1          0859*           		POP     AF
0B0618 07          0860*           		RLCA
0B0619 07          0861*           		RLCA
0B061A 07          0862*           		RLCA
0B061B E6 04       0863*           		AND     4
0B061D AB          0864*           		XOR     E
0B061E F5          0865*   SIN1:			PUSH    AF              ;OCTANT
0B061F CB BC       0866*           		RES     7,H
0B0621 1F          0867*           		RRA
0B0622 CD B0 06 0B 0868*           		CALL    PIBY4
0B0626 DC 51 02 0B 0869*           		CALL    C,RSUB          ;X=(PI/4)-X
0B062A F1          0870*           		POP     AF
0B062B F5          0871*           		PUSH    AF
0B062C E6 03       0872*           		AND     3
0B062E E2 67 06 0B 0873*           		JP      PO,SIN2         ;USE COSINE APPROX.
0B0632 CD 1B 0D 0B 0874*           		CALL    PUSH5           ;SAVE X
0B0636 CD 13 0D 0B 0875*           		CALL    SQUARE          ;PUSH X*X
0B063A CD 58 0D 0B 0876*           		CALL    POLY
0B063E B7 A8       0877*           		DW	0A8B7H          ;a(8)
0B0640 11 36       0878*           		DW	3611H
0B0642 6D          0879*           		DB	6DH
0B0643 26 DE       0880*           		DW	0DE26H          ;a(6)
0B0645 05 D0       0881*           		DW	0D005H
0B0647 73          0882*           		DB	73H
0B0648 C0 80       0883*           		DW	80C0H           ;a(4)
0B064A 88 08       0884*           		DW	888H
0B064C 79          0885*           		DB	79H
0B064D 9D AA       0886*           		DW	0AA9DH          ;a(2)
0B064F AA AA       0887*           		DW	0AAAAH
0B0651 7D          0888*           		DB	7DH
0B0652 00 00       0889*           		DW	0               ;a(0)
0B0654 00 00       0890*           		DW	0
0B0656 80          0891*           		DB	80H
0B0657 CD 24 0D 0B 0892*           		CALL    POP5
0B065B CD 24 0D 0B 0893*           		CALL    POP5
0B065F CD 76 03 0B 0894*           		CALL    FMUL
0B0663 C3 8C 06 0B 0895*           		JP      SIN3
0B0667             0896*   ;
0B0667 CD 13 0D 0B 0897*   SIN2:			CALL    SQUARE          ;PUSH X*X
0B066B CD 58 0D 0B 0898*           		CALL    POLY
0B066F 71 D5       0899*           		DW	0D571H          ;b(8)
0B0671 78 4C       0900*           		DW	4C78H
0B0673 70          0901*           		DB	70H
0B0674 AF 94       0902*           		DW	94AFH           ;b(6)
0B0676 03 B6       0903*           		DW	0B603H
0B0678 76          0904*           		DB	76H
0B0679 C8 9C       0905*           		DW	9CC8H           ;b(4)
0B067B AA 2A       0906*           		DW	2AAAH
0B067D 7B          0907*           		DB	7BH
0B067E DD FF       0908*           		DW	0FFDDH          ;b(2)
0B0680 FF FF       0909*           		DW	0FFFFH
0B0682 7E          0910*           		DB	7EH
0B0683 00 00       0911*           		DW	0               ;b(0)
0B0685 00 00       0912*           		DW	0
0B0687 80          0913*           		DB	80H
0B0688 CD 24 0D 0B 0914*           		CALL    POP5
0B068C F1          0915*   SIN3:			POP     AF
0B068D E6 04       0916*           		AND     4
0B068F C8          0917*           		RET     Z
0B0690 0D          0918*           		DEC     C
0B0691 0C          0919*           		INC     C
0B0692 C8          0920*           		RET     Z               ;ZERO
0B0693 CB FC       0921*           		SET     7,H             ;MAKE NEGATIVE
0B0695 C9          0922*           		RET
0B0696             0923*   ;
0B0696             0924*   ;Floating-point one:
0B0696             0925*   ;
0B0696 21 00 00 00 0926*   FONE_FP:			LD      HL,0
0B069A D9          0927*           		EXX
0B069B 21 00 00 00 0928*           		LD      HL,0
0B069F D9          0929*           		EXX
0B06A0 0E 80       0930*           		LD      C,80H
0B06A2 C9          0931*           		RET
0B06A3             0932*   ;
0B06A3 11 00 00 00 0933*   DONE:			LD      DE,0
0B06A7 D9          0934*           		EXX
0B06A8 11 00 00 00 0935*           		LD      DE,0
0B06AC D9          0936*           		EXX
0B06AD 06 80       0937*           		LD      B,80H
0B06AF C9          0938*           		RET
0B06B0             0939*   ;
0B06B0 11 0F 49 00 0940*   PIBY4:			LD      DE,490FH
0B06B4 D9          0941*           		EXX
0B06B5 11 A2 DA 00 0942*           		LD      DE,0DAA2H
0B06B9 D9          0943*           		EXX
0B06BA 06 7F       0944*           		LD      B,7FH
0B06BC C9          0945*           		RET
0B06BD             0946*   ;
0B06BD             0947*   ;EXP - Exponential function
0B06BD             0948*   ;Result is floating-point numeric.
0B06BD             0949*   ;
0B06BD CD 0E 0C 0B 0950*   EXP_FP:			CALL    SFLOAT_FP
0B06C1 CD 4E 07 0B 0951*   EXP0:			CALL    LN2             ;LN(2)
0B06C5 D9          0952*           		EXX
0B06C6 1D          0953*   	        	DEC     E
0B06C7 01 CF D1 00 0954*   		        LD      BC,0D1CFH       ;0.6931471805599453
0B06CB D9          0955*           		EXX
0B06CC E5          0956*           		PUSH    HL              ;H7=SIGN
0B06CD CD 7D 0B 0B 0957*           		CALL    MOD48           ;"MODULUS"
0B06D1 F1          0958*           		POP     AF
0B06D2 CB 7B       0959*           		BIT     7,E
0B06D4 28 0B       0960*           		JR      Z,EXP1
0B06D6 17          0961*           		RLA
0B06D7 DA 8B 0C 0B 0962*           		JP      C,ZERO_FP
0B06DB 3E 18       0963*           		LD      A,EXPRNG
0B06DD C3 E5 00 0B 0964*           		JP      ERROR_FP_           ;"Exp range"
0B06E1             0965*   ;
0B06E1 E6 80       0966*   EXP1:			AND     80H
0B06E3 B3          0967*           		OR      E
0B06E4 F5          0968*           		PUSH    AF              ;INTEGER PART
0B06E5 CB BC       0969*           		RES     7,H
0B06E7 CD 1B 0D 0B 0970*           		CALL    PUSH5           ;PUSH X*LN(2)
0B06EB CD 58 0D 0B 0971*           		CALL    POLY
0B06EF 72 40       0972*           		DW	4072H           ;a(7)
0B06F1 2E 94       0973*           		DW	942EH
0B06F3 73          0974*           		DB	73H
0B06F4 65 6F       0975*           		DW	6F65H           ;a(6)
0B06F6 4F 2E       0976*           		DW	2E4FH
0B06F8 76          0977*           		DB	76H
0B06F9 37 6D       0978*           		DW	6D37H           ;a(5)
0B06FB 02 88       0979*           		DW	8802H
0B06FD 79          0980*           		DB	79H
0B06FE 12 E5       0981*           		DW	0E512H          ;a(4)
0B0700 A0 2A       0982*           		DW	2AA0H
0B0702 7B          0983*           		DB	7BH
0B0703 14 4F       0984*           		DW	4F14H           ;a(3)
0B0705 AA AA       0985*           		DW	0AAAAH
0B0707 7D          0986*           		DB	7DH
0B0708 56 FD       0987*           		DW	0FD56H          ;a(2)
0B070A FF 7F       0988*           		DW	7FFFH
0B070C 7E          0989*           		DB	7EH
0B070D FE FF       0990*           		DW	0FFFEH          ;a(1)
0B070F FF FF       0991*           		DW	0FFFFH
0B0711 7F          0992*           		DB	7FH
0B0712 00 00       0993*           		DW	0               ;a(0)
0B0714 00 00       0994*           		DW	0
0B0716 80          0995*           		DB	80H
0B0717 CD 24 0D 0B 0996*           		CALL    POP5
0B071B F1          0997*           		POP     AF
0B071C F5          0998*           		PUSH    AF
0B071D F4 42 07 0B 0999*           		CALL    P,RECIP         ;X=1/X
0B0721 F1          1000*           		POP     AF
0B0722 F2 2A 07 0B 1001*           		JP      P,EXP4
0B0726 E6 7F       1002*           		AND     7FH
0B0728 ED 44       1003*           		NEG
0B072A C6 80       1004*   EXP4:			ADD     A,80H
0B072C 81          1005*           		ADD     A,C
0B072D 38 06       1006*           		JR      C,EXP2
0B072F F2 8B 0C 0B 1007*           		JP      P,ZERO_FP          ;UNDERFLOW
0B0733 18 04       1008*           		JR      EXP3
0B0735 FA 56 0C 0B 1009*   EXP2:			JP      M,OFLOW         ;OVERFLOW
0B0739 C6 80       1010*   EXP3:			ADD     A,80H
0B073B CA 8B 0C 0B 1011*           		JP      Z,ZERO_FP
0B073F 4F          1012*           		LD      C,A
0B0740 AF          1013*           		XOR     A               ;NUMERIC MARKER
0B0741 C9          1014*           		RET
0B0742             1015*   ;
0B0742 CD A3 06 0B 1016*   RECIP:			CALL    DONE
0B0746 CD 3F 0C 0B 1017*   RDIV:			CALL    SWAP_FP
0B074A C3 CD 02 0B 1018*           		JP      FDIV            ;RECIPROCAL
0B074E             1019*   ;
0B074E 11 72 31 00 1020*   LN2:			LD      DE,3172H        ;LN(2)
0B0752 D9          1021*           		EXX
0B0753 11 F8 17 00 1022*           		LD      DE,17F8H
0B0757 D9          1023*           		EXX
0B0758 06 7F       1024*           		LD      B,7FH
0B075A C9          1025*           		RET
0B075B             1026*   ;
0B075B             1027*   ;LN - Natural log.
0B075B             1028*   ;Result is floating-point numeric.
0B075B             1029*   ;
0B075B CD 0E 0C 0B 1030*   LN_FP:			CALL    SFLOAT_FP
0B075F 3E 16       1031*   LN0:			LD      A,LOGRNG
0B0761 CB 7C       1032*           		BIT     7,H
0B0763 C2 E5 00 0B 1033*           		JP      NZ,ERROR_FP_        ;"Log range"
0B0767 0C          1034*           		INC     C
0B0768 0D          1035*           		DEC     C
0B0769 CA E5 00 0B 1036*           		JP      Z,ERROR_FP_
0B076D 11 04 35 00 1037*           		LD      DE,3504H        ;SQR(2)
0B0771 D9          1038*           		EXX
0B0772 11 33 F3 00 1039*           		LD      DE,0F333H       ;1.41421356237
0B0776 D9          1040*           		EXX
0B0777 CD 9E 0C 0B 1041*           		CALL    ICP0            ;MANTISSA>SQR(2)?
0B077B 79          1042*           		LD      A,C             ;EXPONENT
0B077C 0E 80       1043*           		LD      C,80H           ;1 <= X < 2
0B077E 38 02       1044*           		JR      C,LN4
0B0780 0D          1045*           		DEC     C
0B0781 3C          1046*           		INC     A
0B0782 F5          1047*   LN4:			PUSH    AF              ;SAVE EXPONENT
0B0783 CD 30 0D 0B 1048*           		CALL    RATIO           ;X=(X-1)/(X+1)
0B0787 CD 1B 0D 0B 1049*           		CALL    PUSH5
0B078B CD 13 0D 0B 1050*   		        CALL    SQUARE          ;PUSH X*X
0B078F CD 58 0D 0B 1051*           		CALL    POLY
0B0793 48 CC       1052*           		DW	0CC48H          ;a(9)
0B0795 FB 74       1053*           		DW	74FBH
0B0797 7D          1054*           		DB	7DH
0B0798 AF AE       1055*           		DW	0AEAFH          ;a(7)
0B079A FF 11       1056*           		DW	11FFH
0B079C 7E          1057*           		DB	7EH
0B079D 8C D9       1058*           		DW	0D98CH          ;a(5)
0B079F CD 4C       1059*           		DW	4CCDH
0B07A1 7E          1060*           		DB	7EH
0B07A2 E3 A9       1061*           		DW	0A9E3H          ;a(3)
0B07A4 AA 2A       1062*           		DW	2AAAH
0B07A6 7F          1063*           		DB	7FH
0B07A7 00 00       1064*           		DW	0               ;a(1)
0B07A9 00 00       1065*           		DW	0
0B07AB 81          1066*           		DB	81H
0B07AC CD 24 0D 0B 1067*           		CALL    POP5
0B07B0 CD 24 0D 0B 1068*           		CALL    POP5
0B07B4 CD 76 03 0B 1069*           		CALL    FMUL
0B07B8 F1          1070*           		POP     AF              ;EXPONENT
0B07B9 CD 1B 0D 0B 1071*           		CALL    PUSH5
0B07BD 08          1072*           		EX      AF,AF'
0B07BE CD 8B 0C 0B 1073*           		CALL    ZERO_FP
0B07C2 08          1074*           		EX      AF,AF'
0B07C3 D6 80       1075*           		SUB     80H
0B07C5 28 1F       1076*           		JR      Z,LN3
0B07C7 30 02       1077*           		JR      NC,LN1
0B07C9 2F          1078*           		CPL
0B07CA 3C          1079*           		INC     A
0B07CB 67          1080*   LN1:			LD      H,A
0B07CC 0E 87       1081*           		LD      C,87H
0B07CE F5          1082*           		PUSH    AF
0B07CF CD EE 0B 0B 1083*           		CALL    FLOAT_
0B07D3 CB BC       1084*           		RES     7,H
0B07D5 CD 4E 07 0B 1085*           		CALL    LN2
0B07D9 CD 76 03 0B 1086*           		CALL    FMUL
0B07DD F1          1087*           		POP     AF
0B07DE 30 06       1088*           		JR      NC,LN3
0B07E0 FA E6 07 0B 1089*           		JP      M,LN3
0B07E4 CB FC       1090*           		SET     7,H
0B07E6 CD 24 0D 0B 1091*   LN3:			CALL    POP5
0B07EA CD 64 02 0B 1092*           		CALL    FADD
0B07EE AF          1093*           		XOR     A
0B07EF C9          1094*           		RET
0B07F0             1095*   ;
0B07F0             1096*   ;LOG - base-10 logarithm.
0B07F0             1097*   ;Result is floating-point numeric.
0B07F0             1098*   ;
0B07F0 CD 5B 07 0B 1099*   LOG_FP:			CALL    LN_FP
0B07F4 11 5B 5E 00 1100*           		LD      DE,5E5BH        ;LOG(e)
0B07F8 D9          1101*           		EXX
0B07F9 11 A9 D8 00 1102*           		LD      DE,0D8A9H
0B07FD D9          1103*           		EXX
0B07FE 06 7E       1104*           		LD      B,7EH
0B0800 CD 76 03 0B 1105*           		CALL    FMUL
0B0804 AF          1106*           		XOR     A
0B0805 C9          1107*           		RET
0B0806             1108*   ;
0B0806             1109*   ;ASN - Arc-sine
0B0806             1110*   ;Result is floating-point numeric.
0B0806             1111*   ;
0B0806 CD 0E 0C 0B 1112*   ASN_FP:			CALL    SFLOAT_FP
0B080A CD 1B 0D 0B 1113*           		CALL    PUSH5
0B080E CD 0B 0D 0B 1114*           		CALL    COPY_
0B0812 CD 76 03 0B 1115*           		CALL    FMUL
0B0816 CD A3 06 0B 1116*           		CALL    DONE
0B081A CD 51 02 0B 1117*           		CALL    RSUB
0B081E CD 81 05 0B 1118*           		CALL    SQR0
0B0822 CD 24 0D 0B 1119*           		CALL    POP5
0B0826 0C          1120*           		INC     C
0B0827 0D          1121*           		DEC     C
0B0828 3E 02       1122*           		LD      A,2
0B082A D5          1123*           		PUSH    DE
0B082B CA B0 08 0B 1124*           		JP      Z,ACS1
0B082F D1          1125*           		POP     DE
0B0830 CD 46 07 0B 1126*           		CALL    RDIV
0B0834 18 04       1127*           		JR      ATN0
0B0836             1128*   ;
0B0836             1129*   ;ATN - arc-tangent
0B0836             1130*   ;Result is floating-point numeric.
0B0836             1131*   ;
0B0836 CD 0E 0C 0B 1132*   ATN_FP:			CALL    SFLOAT_FP
0B083A E5          1133*   ATN0:			PUSH    HL              ;SAVE SIGN
0B083B CB BC       1134*           		RES     7,H
0B083D 11 13 54 00 1135*           		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B0841 D9          1136*           		EXX
0B0842 11 D0 CC 00 1137*           		LD      DE,0CCD0H
0B0846 D9          1138*           		EXX
0B0847 06 7E       1139*           		LD      B,7EH
0B0849 CD 9B 0C 0B 1140*           		CALL    FCP0            ;COMPARE
0B084D 06 00       1141*           		LD      B,0
0B084F 38 22       1142*           		JR      C,ATN2
0B0851 11 82 1A 00 1143*           		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B0855 D9          1144*           		EXX
0B0856 11 9A 79 00 1145*           		LD      DE,799AH
0B085A D9          1146*           		EXX
0B085B 06 81       1147*           		LD      B,81H
0B085D CD 9B 0C 0B 1148*           		CALL    FCP0            ;COMPARE
0B0861 38 0A       1149*           		JR      C,ATN1
0B0863 CD 42 07 0B 1150*           		CALL    RECIP           ;X=1/X
0B0867 06 02       1151*           		LD      B,2
0B0869 C3 73 08 0B 1152*           		JP      ATN2
0B086D CD 30 0D 0B 1153*   ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B0871 06 01       1154*           		LD      B,1
0B0873 C5          1155*   ATN2:			PUSH    BC              ;SAVE FLAG
0B0874 CD 1B 0D 0B 1156*           		CALL    PUSH5
0B0878 CD 13 0D 0B 1157*           		CALL    SQUARE          ;PUSH X*X
0B087C CD 58 0D 0B 1158*           		CALL    POLY
0B0880 35 F3       1159*           		DW	0F335H          ;a(13)
0B0882 D8 37       1160*           		DW	37D8H
0B0884 7B          1161*           		DB	7BH
0B0885 91 6B       1162*           		DW	6B91H           ;a(11)
0B0887 B9 AA       1163*           		DW	0AAB9H
0B0889 7C          1164*           		DB	7CH
0B088A DE 41       1165*           		DW	41DEH           ;a(9)
0B088C 97 61       1166*           		DW	6197H
0B088E 7C          1167*           		DB	7CH
0B088F 7B 9D       1168*           		DW	9D7BH           ;a(7)
0B0891 37 92       1169*           		DW	9237H
0B0893 7D          1170*           		DB	7DH
0B0894 5A 2A       1171*           		DW	2A5AH           ;a(5)
0B0896 CC 4C       1172*           		DW	4CCCH
0B0898 7D          1173*           		DB	7DH
0B0899 5C A9       1174*           		DW	0A95CH          ;a(3)
0B089B AA AA       1175*           		DW	0AAAAH
0B089D 7E          1176*           		DB	7EH
0B089E 00 00       1177*           		DW	0               ;a(1)
0B08A0 00 00       1178*           		DW	0
0B08A2 80          1179*           		DB	80H
0B08A3 CD 24 0D 0B 1180*           		CALL    POP5
0B08A7 CD 24 0D 0B 1181*           		CALL    POP5
0B08AB CD 76 03 0B 1182*           		CALL    FMUL
0B08AF F1          1183*           		POP     AF
0B08B0 CD B0 06 0B 1184*   ACS1:			CALL    PIBY4           ;PI/4
0B08B4 1F          1185*           		RRA
0B08B5 F5          1186*           		PUSH    AF
0B08B6 DC 64 02 0B 1187*           		CALL    C,FADD
0B08BA F1          1188*           		POP     AF
0B08BB 04          1189*           		INC     B
0B08BC 1F          1190*           		RRA
0B08BD DC 51 02 0B 1191*           		CALL    C,RSUB
0B08C1 F1          1192*           		POP     AF
0B08C2 B7          1193*           		OR      A
0B08C3 F0          1194*           		RET     P
0B08C4 CB FC       1195*           		SET     7,H             ;MAKE NEGATIVE
0B08C6 AF          1196*           		XOR     A
0B08C7 C9          1197*           		RET
0B08C8             1198*   ;
0B08C8             1199*   ;ACS - Arc cosine=PI/2-ASN.
0B08C8             1200*   ;Result is floating point numeric.
0B08C8             1201*   ;
0B08C8 CD 06 08 0B 1202*   ACS_FP:			CALL    ASN_FP
0B08CC 3E 02       1203*           		LD      A,2
0B08CE F5          1204*           		PUSH    AF
0B08CF 18 DF       1205*           		JR      ACS1
0B08D1             1206*   ;
0B08D1             1207*   ;Function STR - convert numeric value to ASCII string.
0B08D1             1208*   ;   Inputs: HLH'L'C = integer or floating-point number
0B08D1             1209*   ;           DE = address at which to store string
0B08D1             1210*   ;           IX = address of @% format control
0B08D1             1211*   ;  Outputs: String stored, with NUL terminator
0B08D1             1212*   ;
0B08D1             1213*   ;First normalise for decimal output:
0B08D1             1214*   ;
0B08D1 CD 0E 0C 0B 1215*   STR_FP:			CALL    SFLOAT_FP
0B08D5 06 00       1216*           		LD      B,0             ;DEFAULT PT. POSITION
0B08D7 CB 7C       1217*           		BIT     7,H             ;NEGATIVE?
0B08D9 28 06       1218*           		JR      Z,STR10
0B08DB CB BC       1219*           		RES     7,H
0B08DD 3E 2D       1220*           		LD      A,'-'
0B08DF 12          1221*           		LD      (DE),A          ;STORE SIGN
0B08E0 13          1222*           		INC     DE
0B08E1 AF          1223*   STR10:			XOR     A               ;CLEAR A
0B08E2 B9          1224*           		CP      C
0B08E3 28 4E       1225*           		JR      Z,STR02          ;ZERO
0B08E5 D5          1226*           		PUSH    DE              ;SAVE TEXT POINTER
0B08E6 78          1227*           		LD      A,B
0B08E7 F5          1228*   STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B08E8 79          1229*           		LD      A,C             ;BINARY EXPONENT
0B08E9 FE A1       1230*           		CP      161
0B08EB 30 1C       1231*           		JR      NC,STR14
0B08ED FE 9B       1232*           		CP      155
0B08EF 30 29       1233*           		JR      NC,STR15
0B08F1 2F          1234*           		CPL
0B08F2 FE E1       1235*           		CP      225
0B08F4 38 02       1236*           		JR      C,STR13
0B08F6 3E F8       1237*           		LD      A,-8
0B08F8 C6 1C       1238*   STR13:			ADD     A,28
0B08FA CD 87 0D 0B 1239*           		CALL    POWR10
0B08FE F5          1240*           		PUSH    AF
0B08FF CD 76 03 0B 1241*           		CALL    FMUL
0B0903 F1          1242*           		POP     AF
0B0904 47          1243*           		LD      B,A
0B0905 F1          1244*           		POP     AF
0B0906 90          1245*           		SUB     B
0B0907 18 DE       1246*           		JR      STR11
0B0909 D6 20       1247*   STR14:			SUB     32
0B090B CD 87 0D 0B 1248*           		CALL    POWR10
0B090F F5          1249*           		PUSH    AF
0B0910 CD CD 02 0B 1250*           		CALL    FDIV
0B0914 F1          1251*           		POP     AF
0B0915 47          1252*           		LD      B,A
0B0916 F1          1253*           		POP     AF
0B0917 80          1254*           		ADD     A,B
0B0918 18 CD       1255*           		JR      STR11
0B091A 3E 09       1256*   STR15:			LD      A,9
0B091C CD 87 0D 0B 1257*           		CALL    POWR10          ;10^9
0B0920 CD 9B 0C 0B 1258*           		CALL    FCP0
0B0924 79          1259*           		LD      A,C
0B0925 C1          1260*           		POP     BC
0B0926 4F          1261*           		LD      C,A
0B0927 CB FC       1262*           		SET     7,H             ;IMPLIED 1
0B0929 DC C3 0C 0B 1263*           		CALL    C,X10B          ;X10, DEC B
0B092D D1          1264*           		POP     DE              ;RESTORE TEXT POINTER
0B092E CB B9       1265*           		RES     7,C
0B0930 3E 00       1266*           		LD      A,0
0B0932 17          1267*           		RLA                     ;PUT CARRY IN LSB
0B0933             1268*   ;
0B0933             1269*   ;At this point decimal normalisation has been done,
0B0933             1270*   ;now convert to decimal digits:
0B0933             1271*   ;      AHLH'L' = number in normalised integer form
0B0933             1272*   ;            B = decimal place adjustment
0B0933             1273*   ;            C = binary place adjustment (29-33)
0B0933             1274*   ;
0B0933 0C          1275*   STR02:			INC     C
0B0934 08          1276*           		EX      AF,AF'          ;SAVE A
0B0935 78          1277*           		LD      A,B
0B0936 DD CB 02 4E 1278*           		BIT     1,(IX+2)
0B093A 20 08       1279*           		JR      NZ,STR20
0B093C AF          1280*           		XOR     A
0B093D DD BE 01    1281*           		CP      (IX+1)
0B0940 28 0B       1282*           		JR      Z,STR21
0B0942 3E F6       1283*           		LD      A,-10
0B0944 DD 86 01    1284*   STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B0947 B7          1285*           		OR      A               ;CLEAR CARRY
0B0948 FA 4D 09 0B 1286*           		JP      M,STR21
0B094C AF          1287*           		XOR     A
0B094D F5          1288*   STR21:			PUSH    AF
0B094E 08          1289*           		EX      AF,AF'          ;RESTORE A
0B094F CD F7 0C 0B 1290*   STR22:			CALL    X2              ;RL AHLH'L'
0B0953 8F          1291*           		ADC     A,A
0B0954 FE 0A       1292*           		CP      10
0B0956 38 05       1293*           		JR      C,STR23
0B0958 D6 0A       1294*           		SUB     10
0B095A D9          1295*           		EXX
0B095B 2C          1296*           		INC     L               ;SET RESULT BIT
0B095C D9          1297*           		EXX
0B095D 0D          1298*   STR23:			DEC     C
0B095E 20 EF       1299*           		JR      NZ,STR22        ;32 TIMES
0B0960 4F          1300*           		LD      C,A             ;REMAINDER
0B0961 7C          1301*           		LD      A,H
0B0962 E6 3F       1302*           		AND     3FH             ;CLEAR OUT JUNK
0B0964 67          1303*           		LD      H,A
0B0965 F1          1304*           		POP     AF
0B0966 F2 74 09 0B 1305*           		JP      P,STR24
0B096A 3C          1306*           		INC     A
0B096B 20 1C       1307*           		JR      NZ,STR26
0B096D 3E 04       1308*           		LD      A,4
0B096F B9          1309*           		CP      C               ;ROUND UP?
0B0970 3E 00       1310*           		LD      A,0
0B0972 18 15       1311*           		JR      STR26
0B0974 F5          1312*   STR24:			PUSH    AF
0B0975 79          1313*           		LD      A,C
0B0976 CE 30       1314*           		ADC     A,'0'           ;ADD CARRY
0B0978 FE 30       1315*           		CP      '0'
0B097A 28 05       1316*           		JR      Z,STR25         ;SUPPRESS ZERO
0B097C FE 3A       1317*           		CP      '9'+1
0B097E 3F          1318*           		CCF
0B097F 30 08       1319*           		JR      NC,STR26
0B0981 E3          1320*   STR25:			EX      (SP),HL
0B0982 CB 75       1321*           		BIT     6,L             ;ZERO FLAG
0B0984 E3          1322*   		        EX      (SP),HL
0B0985 20 05       1323*           		JR      NZ,STR27
0B0987 3E 30       1324*           		LD      A,'0'
0B0989 3C          1325*   STR26:			INC     A               ;SET +VE
0B098A 3D          1326*           		DEC     A
0B098B F5          1327*           		PUSH    AF              ;PUT ON STACK + CARRY
0B098C 04          1328*   STR27:			INC     B
0B098D CD 67 0C 0B 1329*           		CALL    TEST_FP            ;IS HLH'L' ZERO?
0B0991 0E 20       1330*           		LD      C,32
0B0993 3E 00       1331*           		LD      A,0
0B0995 20 B8       1332*           		JR      NZ,STR22
0B0997 F1          1333*           		POP     AF
0B0998 F5          1334*           		PUSH    AF
0B0999 3E 00       1335*           		LD      A,0
0B099B 38 B2       1336*           		JR      C,STR22
0B099D             1337*   ;
0B099D             1338*   ;At this point, the decimal character string is stored
0B099D             1339*   ; on the stack. Trailing zeroes are suppressed and may
0B099D             1340*   ; need to be replaced.
0B099D             1341*   ;B register holds decimal point position.
0B099D             1342*   ;Now format number and store as ASCII string:
0B099D             1343*   ;
0B099D EB          1344*   STR3:			EX      DE,HL           ;STRING POINTER
0B099E 0E FF       1345*           		LD      C,-1            ;FLAG "E"
0B09A0 16 01       1346*           		LD      D,1
0B09A2 DD 5E 01    1347*           		LD      E,(IX+1)        ;f2
0B09A5 DD CB 02 46 1348*           		BIT     0,(IX+2)
0B09A9 20 35       1349*           		JR      NZ,STR34        ;E MODE
0B09AB DD CB 02 4E 1350*           		BIT     1,(IX+2)
0B09AF 28 12       1351*           		JR      Z,STR31
0B09B1 78          1352*           		LD      A,B             ;F MODE
0B09B2 B7          1353*           		OR      A
0B09B3 28 05       1354*           		JR      Z,STR30
0B09B5 FA BA 09 0B 1355*           		JP      M,STR30
0B09B9 50          1356*           		LD      D,B
0B09BA 7A          1357*   STR30:			LD      A,D
0B09BB DD 86 01    1358*           		ADD     A,(IX+1)
0B09BE 5F          1359*           		LD      E,A
0B09BF FE 0B       1360*           		CP      11
0B09C1 38 19       1361*           		JR      C,STR32
0B09C3 78          1362*   STR31:			LD      A,B             ;G MODE
0B09C4 11 01 01 00 1363*           		LD      DE,101H
0B09C8 B7          1364*           		OR      A
0B09C9 FA E0 09 0B 1365*           		JP      M,STR34
0B09CD 28 0D       1366*           		JR      Z,STR32
0B09CF DD 7E 01    1367*           		LD      A,(IX+1)
0B09D2 B7          1368*           		OR      A
0B09D3 20 02       1369*           		JR      NZ,STR3A
0B09D5 3E 0A       1370*           		LD      A,10
0B09D7 B8          1371*   STR3A:			CP      B
0B09D8 38 06       1372*           		JR      C,STR34
0B09DA 50          1373*           		LD      D,B
0B09DB 58          1374*           		LD      E,B
0B09DC 78          1375*   STR32:			LD      A,B
0B09DD C6 81       1376*           		ADD     A,129
0B09DF 4F          1377*           		LD      C,A
0B09E0 CB FA       1378*   STR34:			SET     7,D
0B09E2 1D          1379*           		DEC     E
0B09E3 7A          1380*   STR35:			LD      A,D
0B09E4 B9          1381*           		CP      C
0B09E5 30 0E       1382*           		JR      NC,STR33
0B09E7 F1          1383*   STR36:			POP     AF
0B09E8 28 04       1384*           		JR      Z,STR37
0B09EA F2 F7 09 0B 1385*           		JP      P,STR38
0B09EE F5          1386*   STR37:			PUSH    AF
0B09EF 1C          1387*           		INC     E
0B09F0 1D          1388*           		DEC     E
0B09F1 FA 08 0A 0B 1389*           		JP      M,STR4
0B09F5 3E 30       1390*   STR33:			LD      A,'0'
0B09F7 15          1391*   STR38:			DEC     D
0B09F8 E2 FF 09 0B 1392*           		JP      PO,STR39
0B09FC 36 2E       1393*           		LD      (HL),'.'
0B09FE 23          1394*           		INC     HL
0B09FF 77          1395*   STR39:			LD      (HL),A
0B0A00 23          1396*           		INC     HL
0B0A01 1D          1397*           		DEC     E
0B0A02 F2 E3 09 0B 1398*           		JP      P,STR35
0B0A06 18 DF       1399*           		JR      STR36
0B0A08             1400*   ;
0B0A08 F1          1401*   STR4:			POP     AF
0B0A09 0C          1402*   STR40:			INC     C
0B0A0A 4D          1403*           		LD      C,L
0B0A0B 20 28       1404*           		JR      NZ,STR44
0B0A0D 36 45       1405*           		LD      (HL),'E'        ;EXPONENT
0B0A0F 23          1406*           		INC     HL
0B0A10 78          1407*           		LD      A,B
0B0A11 3D          1408*           		DEC     A
0B0A12 F2 1B 0A 0B 1409*           		JP      P,STR41
0B0A16 36 2D       1410*           		LD      (HL),'-'
0B0A18 23          1411*           		INC     HL
0B0A19 ED 44       1412*           		NEG
0B0A1B 36 30       1413*   STR41:			LD      (HL),'0'
0B0A1D 28 15       1414*           		JR      Z,STR47
0B0A1F FE 0A       1415*           		CP      10
0B0A21 47          1416*           		LD      B,A
0B0A22 3E 3A       1417*           		LD      A,':'
0B0A24 38 03       1418*           		JR      C,STR42
0B0A26 23          1419*           		INC     HL
0B0A27 36 30       1420*           		LD      (HL),'0'
0B0A29 34          1421*   STR42:			INC     (HL)
0B0A2A BE          1422*           		CP      (HL)
0B0A2B 20 05       1423*           		JR      NZ,STR43
0B0A2D 36 30       1424*           		LD      (HL),'0'
0B0A2F 2B          1425*           		DEC     HL
0B0A30 34          1426*           		INC     (HL)
0B0A31 23          1427*           		INC     HL
0B0A32 10 F5       1428*   STR43:			DJNZ    STR42
0B0A34 23          1429*   STR47:			INC     HL
0B0A35 EB          1430*   STR44:			EX      DE,HL
0B0A36 C9          1431*         			RET
0B0A37             1432*   ;
0B0A37             1433*   ;Support subroutines:
0B0A37             1434*   ;
0B0A37 DD 46 04    1435*   DLOAD5:			LD      B,(IX+4)
0B0A3A D9          1436*           		EXX
0B0A3B DD 5E 00    1437*           		LD      E,(IX+0)
0B0A3E DD 56 01    1438*           		LD      D,(IX+1)
0B0A41 D9          1439*           		EXX
0B0A42 DD 5E 02    1440*           		LD      E,(IX+2)
0B0A45 DD 56 03    1441*           		LD      D,(IX+3)
0B0A48 C9          1442*           		RET
0B0A49             1443*   ;
0B0A49 DD 46 06    1444*   DLOAD5_SPL:		LD      B,(IX+6)
0B0A4C D9          1445*   			EXX
0B0A4D DD 17 00    1446*   			LD	DE, (IX+0)
0B0A50 D9          1447*   			EXX
0B0A51 DD 17 03    1448*   			LD	DE, (IX+3)
0B0A54 C9          1449*   			RET
0B0A55             1450*   ;
0B0A55             1451*   ;CON_FP - Get unsigned numeric constant from ASCII string.
0B0A55             1452*   ;   Inputs: ASCII string at (IX).
0B0A55             1453*   ;  Outputs: Variable-type result in HLH'L'C
0B0A55             1454*   ;           IX updated (points to delimiter)
0B0A55             1455*   ;           A7 = 0 (numeric marker)
0B0A55             1456*   ;
0B0A55 CD 8B 0C 0B 1457*   CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0B0A59 0E 00       1458*           		LD      C,0             ;TRUNCATION COUNTER
0B0A5B CD E9 0A 0B 1459*           		CALL    UINT          ;GET INTEGER PART
0B0A5F FE 2E       1460*           		CP      '.'
0B0A61 06 00       1461*           		LD      B,0             ;DECL. PLACE COUNTER
0B0A63 CC E7 0A 0B 1462*           		CALL    Z,NUMBIX        ;GET FRACTION PART
0B0A67 FE 45       1463*           		CP      'E'
0B0A69 3E 00       1464*           		LD      A,0             ;INITIALISE EXPONENT
0B0A6B CC B5 0A 0B 1465*           		CALL    Z,GETEXP        ;GET EXPONENT
0B0A6F CB 7C       1466*           		BIT     7,H
0B0A71 20 08       1467*           		JR      NZ,CON0         ;INTEGER OVERFLOW
0B0A73 B7          1468*           		OR      A
0B0A74 20 05       1469*           		JR      NZ,CON0         ;EXPONENT NON-ZERO
0B0A76 B8          1470*           		CP      B
0B0A77 20 02       1471*           		JR      NZ,CON0         ;DECIMAL POINT
0B0A79 B9          1472*           		CP      C
0B0A7A C8          1473*           		RET     Z               ;INTEGER
0B0A7B 90          1474*   CON0:			SUB     B
0B0A7C 81          1475*           		ADD     A,C
0B0A7D 0E 9F       1476*           		LD      C,159
0B0A7F CD EE 0B 0B 1477*           		CALL    FLOAT_
0B0A83 CB BC       1478*           		RES     7,H             ;DITCH IMPLIED 1
0B0A85 B7          1479*           		OR      A
0B0A86 C8          1480*           		RET     Z               ;DONE
0B0A87 FA 95 0A 0B 1481*           		JP      M,CON2          ;NEGATIVE EXPONENT
0B0A8B CD 87 0D 0B 1482*           		CALL    POWR10
0B0A8F CD 76 03 0B 1483*           		CALL    FMUL            ;SCALE
0B0A93 AF          1484*           		XOR     A
0B0A94 C9          1485*           		RET
0B0A95 FE DA       1486*   CON2:			CP      -38
0B0A97 38 0C       1487*           		JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B0A99 ED 44       1488*           		NEG
0B0A9B CD 87 0D 0B 1489*           		CALL    POWR10
0B0A9F CD CD 02 0B 1490*           		CALL    FDIV            ;SCALE
0B0AA3 AF          1491*           		XOR     A
0B0AA4 C9          1492*           		RET
0B0AA5 F5          1493*   CON3:			PUSH    AF
0B0AA6 3E 26       1494*           		LD      A,38
0B0AA8 CD 87 0D 0B 1495*           		CALL    POWR10
0B0AAC CD CD 02 0B 1496*           		CALL    FDIV
0B0AB0 F1          1497*           		POP     AF
0B0AB1 C6 26       1498*           		ADD     A,38
0B0AB3 18 E0       1499*           		JR      CON2
0B0AB5             1500*   ;
0B0AB5             1501*   ;GETEXP - Get decimal exponent from string
0B0AB5             1502*   ;     Inputs: ASCII string at (IX)
0B0AB5             1503*   ;             (IX points at 'E')
0B0AB5             1504*   ;             A = initial value
0B0AB5             1505*   ;    Outputs: A = new exponent
0B0AB5             1506*   ;             IX updated.
0B0AB5             1507*   ;   Destroys: A,A',IX,F,F'
0B0AB5             1508*   ;
0B0AB5 C5          1509*   GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B0AB6 47          1510*           		LD      B,A             ;INITIAL VALUE
0B0AB7 0E 02       1511*           		LD      C,2             ;2 DIGITS MAX
0B0AB9 DD 23       1512*           		INC     IX              ;BUMP PAST 'E'
0B0ABB CD A5 0E 0B 1513*           		CALL    SIGNQ
0B0ABF 08          1514*           		EX      AF,AF'          ;SAVE EXPONENT SIGN
0B0AC0 CD 9B 0E 0B 1515*   GETEX1:			CALL    DIGITQ
0B0AC4 38 18       1516*           		JR      C,GETEX2
0B0AC6 78          1517*           		LD      A,B             ;B=B*10
0B0AC7 87          1518*           		ADD     A,A
0B0AC8 87          1519*           		ADD     A,A
0B0AC9 80          1520*           		ADD     A,B
0B0ACA 87          1521*           		ADD     A,A
0B0ACB 47          1522*           		LD      B,A
0B0ACC DD 7E 00    1523*           		LD      A,(IX)          ;GET BACK DIGIT
0B0ACF DD 23       1524*           		INC     IX
0B0AD1 E6 0F       1525*           		AND     0FH             ;MASK UNWANTED BITS
0B0AD3 80          1526*           		ADD     A,B             ;ADD IN DIGIT
0B0AD4 47          1527*           		LD      B,A
0B0AD5 0D          1528*           		DEC     C
0B0AD6 F2 C0 0A 0B 1529*           		JP      P,GETEX1
0B0ADA 06 64       1530*           		LD      B,100           ;FORCE OVERFLOW
0B0ADC 18 E2       1531*           		JR      GETEX1
0B0ADE 08          1532*   GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B0ADF FE 2D       1533*           		CP      '-'
0B0AE1 78          1534*           		LD      A,B
0B0AE2 C1          1535*           		POP     BC              ;RESTORE
0B0AE3 C0          1536*           		RET     NZ
0B0AE4 ED 44       1537*           		NEG                     ;NEGATE EXPONENT
0B0AE6 C9          1538*           		RET
0B0AE7             1539*   ;
0B0AE7             1540*   ;UINT: Get unsigned integer from string.
0B0AE7             1541*   ;    Inputs: string at (IX)
0B0AE7             1542*   ;            C = truncated digit count
0B0AE7             1543*   ;                (initially zero)
0B0AE7             1544*   ;            B = total digit count
0B0AE7             1545*   ;            HLH'L' = initial value
0B0AE7             1546*   ;   Outputs: HLH'L' = number (binary integer)
0B0AE7             1547*   ;            A = delimiter.
0B0AE7             1548*   ;            B, C & IX updated
0B0AE7             1549*   ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B0AE7             1550*   ;
0B0AE7 DD 23       1551*   NUMBIX:			INC     IX
0B0AE9 CD 9B 0E 0B 1552*   UINT:			CALL    DIGITQ
0B0AED D8          1553*           		RET     C
0B0AEE 04          1554*           		INC     B               ;INCREMENT DIGIT COUNT
0B0AEF DD 23       1555*           		INC     IX
0B0AF1 CD E4 0C 0B 1556*           		CALL    X10             ;*10 & COPY OLD VALUE
0B0AF5 38 15       1557*           		JR      C,NUMB1         ;OVERFLOW
0B0AF7 0D          1558*           		DEC     C               ;SEE IF TRUNCATED
0B0AF8 0C          1559*           		INC     C
0B0AF9 20 11       1560*           		JR      NZ,NUMB1        ;IMPORTANT!
0B0AFB E6 0F       1561*           		AND     0FH
0B0AFD D9          1562*           		EXX
0B0AFE 06 00       1563*           		LD      B,0
0B0B00 4F          1564*           		LD      C,A
0B0B01 52 09       1565*           		ADD.S   HL,BC           ;ADD IN DIGIT
0B0B03 D9          1566*           		EXX
0B0B04 30 E3       1567*           		JR      NC,UINT
0B0B06 52 23       1568*           		INC.S   HL              ;CARRY
0B0B08 7C          1569*           		LD      A,H
0B0B09 B5          1570*           		OR      L
0B0B0A 20 DD       1571*           		JR      NZ,UINT
0B0B0C 0C          1572*   NUMB1:			INC     C               ;TRUNCATION COUNTER
0B0B0D CD 42 0C 0B 1573*           		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B0B11 18 D6       1574*           		JR      UINT
0B0B13             1575*   ;
0B0B13             1576*   ;FIX - Fix number to specified exponent value.
0B0B13             1577*   ;    Inputs: HLH'L'C = +ve non-zero number (floated)
0B0B13             1578*   ;            A = desired exponent (A>C)
0B0B13             1579*   ;   Outputs: HLH'L'C = fixed number (unsigned)
0B0B13             1580*   ;            fraction shifted into B'C'
0B0B13             1581*   ;            A'F' positive if integer input
0B0B13             1582*   ;  Destroys: C,H,L,A',B',C',H',L',F,F'
0B0B13             1583*   ;
0B0B13 08          1584*   FIX:			EX      AF,AF'
0B0B14 AF          1585*           		XOR     A
0B0B15 08          1586*           		EX      AF,AF'
0B0B16 CB FC       1587*           		SET     7,H             ;IMPLIED 1
0B0B18 CD 47 0C 0B 1588*   FIX1:			CALL    DIV2
0B0B1C B9          1589*           		CP      C
0B0B1D C8          1590*           		RET     Z
0B0B1E D2 18 0B 0B 1591*           		JP      NC,FIX1
0B0B22 C3 56 0C 0B 1592*           		JP      OFLOW
0B0B26             1593*   ;
0B0B26             1594*   ;SFIX - Convert to integer if necessary.
0B0B26             1595*   ;    Input: Variable-type number in HLH'L'C
0B0B26             1596*   ;   Output: Integer in HLH'L', C=0
0B0B26             1597*   ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
0B0B26             1598*   ;
0B0B26             1599*   ;NEGATE - Negate HLH'L'
0B0B26             1600*   ;    Destroys: H,L,H',L',F
0B0B26             1601*   ;
0B0B26 CD 3F 0C 0B 1602*   FIX2:			CALL    SWAP_FP
0B0B2A CD 32 0B 0B 1603*           		CALL    SFIX_FP
0B0B2E CD 3F 0C 0B 1604*           		CALL    SWAP_FP
0B0B32 0D          1605*   SFIX_FP:			DEC     C
0B0B33 0C          1606*           		INC     C
0B0B34 C8          1607*           		RET     Z               ;INTEGER/ZERO
0B0B35 CB 7C       1608*           		BIT     7,H             ;SIGN
0B0B37 F5          1609*           		PUSH    AF
0B0B38 3E 9F       1610*           		LD      A,159
0B0B3A CD 13 0B 0B 1611*           		CALL    FIX
0B0B3E F1          1612*           		POP     AF
0B0B3F 0E 00       1613*           		LD      C,0
0B0B41 C8          1614*           		RET     Z
0B0B42 B7          1615*   NEGATE:			OR      A               ;CLEAR CARRY
0B0B43 D9          1616*           		EXX
0B0B44 D5          1617*   NEG0:			PUSH    DE
0B0B45 EB          1618*           		EX      DE,HL
0B0B46 21 00 00 00 1619*           		LD      HL,0
0B0B4A 52 ED 52    1620*           		SBC.S   HL,DE
0B0B4D D1          1621*           		POP     DE
0B0B4E D9          1622*           		EXX
0B0B4F D5          1623*           		PUSH    DE
0B0B50 EB          1624*           		EX      DE,HL
0B0B51 21 00 00 00 1625*           		LD      HL,0
0B0B55 52 ED 52    1626*           		SBC.S   HL,DE
0B0B58 D1          1627*           		POP     DE
0B0B59 C9          1628*           		RET
0B0B5A             1629*   ;
0B0B5A             1630*   ;NEG - Negate HLH'L'B'C'
0B0B5A             1631*   ;    Also complements A (used in FADD)
0B0B5A             1632*   ;    Destroys: A,H,L,B',C',H',L',F
0B0B5A             1633*   ;
0B0B5A D9          1634*   NEG_:			EXX
0B0B5B 2F          1635*           		CPL
0B0B5C E5          1636*           		PUSH    HL
0B0B5D B7          1637*           		OR      A               ;CLEAR CARRY
0B0B5E 21 00 00 00 1638*           		LD      HL,0
0B0B62 52 ED 42    1639*           		SBC.S   HL,BC
0B0B65 44          1640*           		LD      B,H
0B0B66 4D          1641*           		LD      C,L
0B0B67 E1          1642*           		POP     HL
0B0B68 18 DA       1643*           		JR      NEG0
0B0B6A             1644*   ;
0B0B6A             1645*   ;SCALE - Trig scaling.
0B0B6A             1646*   ;MOD48 - 48-bit floating-point "modulus" (remainder).
0B0B6A             1647*   ;   Inputs: HLH'L'C unsigned floating-point dividend
0B0B6A             1648*   ;           DED'E'B'C'B unsigned 48-bit FP divisor
0B0B6A             1649*   ;  Outputs: HLH'L'C floating point remainder (H7=1)
0B0B6A             1650*   ;           E = quotient (bit 7 is sticky)
0B0B6A             1651*   ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B0B6A             1652*   ;FLO48 - Float unsigned number (48 bits)
0B0B6A             1653*   ;    Input/output in HLH'L'B'C'C
0B0B6A             1654*   ;   Destroys: C,H,L,B',C',H',L',F
0B0B6A             1655*   ;
0B0B6A 3E 96       1656*   SCALE:			LD      A,150
0B0B6C B9          1657*           		CP      C
0B0B6D 3E 17       1658*           		LD      A,ACLOST
0B0B6F DA E5 00 0B 1659*           		JP      C,ERROR_FP_         ;"Accuracy lost"
0B0B73 CD B0 06 0B 1660*           		CALL    PIBY4
0B0B77 D9          1661*           		EXX
0B0B78 01 69 21 00 1662*           		LD      BC,2169H        ;3.141592653589793238
0B0B7C D9          1663*           		EXX
0B0B7D CB FA       1664*   MOD48:			SET     7,D             ;IMPLIED 1
0B0B7F CB FC       1665*           		SET     7,H
0B0B81 79          1666*           		LD      A,C
0B0B82 0E 00       1667*           		LD      C,0             ;INIT QUOTIENT
0B0B84 DD 21 00 00 1668*           		LD      IX,0
       00          
0B0B89 DD E5       1669*           		PUSH    IX              ;PUT ZERO ON STACK
0B0B8B B8          1670*           		CP      B
0B0B8C 38 46       1671*           		JR      C,MOD485        ;DIVIDEND<DIVISOR
0B0B8E D9          1672*   MOD481:			EXX                     ;CARRY=0 HERE
0B0B8F E3          1673*           		EX      (SP),HL
0B0B90 52 ED 42    1674*           		SBC.S   HL,BC
0B0B93 E3          1675*           		EX      (SP),HL
0B0B94 52 ED 52    1676*           		SBC.S   HL,DE
0B0B97 D9          1677*           		EXX
0B0B98 52 ED 52    1678*           		SBC.S   HL,DE
0B0B9B 30 0C       1679*           		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B0B9D D9          1680*           		EXX
0B0B9E E3          1681*           		EX      (SP),HL
0B0B9F 52 09       1682*           		ADD.S   HL,BC
0B0BA1 E3          1683*           		EX      (SP),HL
0B0BA2 52 ED 5A    1684*           		ADC.S   HL,DE
0B0BA5 D9          1685*           		EXX
0B0BA6 52 ED 5A    1686*           		ADC.S   HL,DE
0B0BA9 3F          1687*   MOD482:			CCF
0B0BAA CB 11       1688*           		RL      C               ;QUOTIENT
0B0BAC 30 02       1689*           		JR      NC,MOD483
0B0BAE CB F9       1690*           		SET     7,C             ;STICKY BIT
0B0BB0 3D          1691*   MOD483:			DEC     A
0B0BB1 B8          1692*           		CP      B
0B0BB2 38 1F       1693*           		JR      C,MOD484        ;DIVIDEND<DIVISOR
0B0BB4 E3          1694*           		EX      (SP),HL
0B0BB5 52 29       1695*           		ADD.S   HL,HL           ;DIVIDEND * 2
0B0BB7 E3          1696*           		EX      (SP),HL
0B0BB8 D9          1697*           		EXX
0B0BB9 52 ED 6A    1698*           		ADC.S   HL,HL
0B0BBC D9          1699*           		EXX
0B0BBD 52 ED 6A    1700*           		ADC.S   HL,HL
0B0BC0 30 CC       1701*           		JR      NC,MOD481       ;AGAIN
0B0BC2 B7          1702*           		OR      A
0B0BC3 D9          1703*           		EXX
0B0BC4 E3          1704*           		EX      (SP),HL
0B0BC5 52 ED 42    1705*           		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B0BC8 E3          1706*           		EX      (SP),HL
0B0BC9 52 ED 52    1707*           		SBC.S   HL,DE
0B0BCC D9          1708*           		EXX
0B0BCD 52 ED 52    1709*           		SBC.S   HL,DE
0B0BD0 B7          1710*           		OR      A
0B0BD1 18 D6       1711*           		JR      MOD482
0B0BD3             1712*   ;
0B0BD3 3C          1713*   MOD484:			INC     A
0B0BD4 59          1714*   MOD485:			LD      E,C             ;QUOTIENT
0B0BD5 4F          1715*           		LD      C,A             ;REMAINDER EXPONENT
0B0BD6 D9          1716*           		EXX
0B0BD7 C1          1717*           		POP     BC
0B0BD8 D9          1718*           		EXX
0B0BD9 CB 7C       1719*   FLO48:			BIT     7,H
0B0BDB C0          1720*           		RET     NZ
0B0BDC D9          1721*           		EXX
0B0BDD CB 21       1722*           		SLA     C
0B0BDF CB 10       1723*           		RL      B
0B0BE1 52 ED 6A    1724*           		ADC.S   HL,HL
0B0BE4 D9          1725*           		EXX
0B0BE5 52 ED 6A    1726*           		ADC.S   HL,HL
0B0BE8 0D          1727*           		DEC     C
0B0BE9 C2 D9 0B 0B 1728*           		JP      NZ,FLO48
0B0BED C9          1729*           		RET
0B0BEE             1730*   ;
0B0BEE             1731*   ;Float unsigned number
0B0BEE             1732*   ;    Input/output in HLH'L'C
0B0BEE             1733*   ;   Destroys: C,H,L,H',L',F
0B0BEE             1734*   ;
0B0BEE CB 7C       1735*   FLOAT_:			BIT     7,H
0B0BF0 C0          1736*           		RET     NZ
0B0BF1 D9          1737*           		EXX                     ;SAME AS "X2"
0B0BF2 52 29       1738*           		ADD.S   HL,HL           ;TIME-CRITICAL
0B0BF4 D9          1739*           		EXX                     ;REGION
0B0BF5 52 ED 6A    1740*           		ADC.S   HL,HL           ;(BENCHMARKS)
0B0BF8 0D          1741*           		DEC     C
0B0BF9 C2 EE 0B 0B 1742*           		JP      NZ,FLOAT_
0B0BFD C9          1743*           		RET
0B0BFE             1744*   ;
0B0BFE             1745*   ;SFLOAT - Convert to floating-point if necessary.
0B0BFE             1746*   ;    Input: Variable-type number in HLH'L'C
0B0BFE             1747*   ;    Output: Floating-point in HLH'L'C
0B0BFE             1748*   ;    Destroys: A,C,H,L,H',L',F
0B0BFE             1749*   ;
0B0BFE 08          1750*   FLOATA:			EX      AF,AF'
0B0BFF             1751*           		; ADD     A,(RTABLE-DTABLE)/3
0B0BFF C6 2A       1752*           		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B0C01 08          1753*           		EX      AF,AF'
0B0C02 CD 3F 0C 0B 1754*   FLOAT2:			CALL    SWAP_FP
0B0C06 CD 0E 0C 0B 1755*           		CALL    SFLOAT_FP
0B0C0A CD 3F 0C 0B 1756*           		CALL    SWAP_FP
0B0C0E 0D          1757*   SFLOAT_FP:			DEC     C
0B0C0F 0C          1758*           		INC     C
0B0C10 C0          1759*           		RET     NZ              ;ALREADY FLOATING-POINT
0B0C11 CD 67 0C 0B 1760*           		CALL    TEST_FP
0B0C15 C8          1761*           		RET     Z               ;ZERO
0B0C16 7C          1762*           		LD      A,H
0B0C17 B7          1763*           		OR      A
0B0C18 FC 42 0B 0B 1764*           		CALL    M,NEGATE
0B0C1C 0E 9F       1765*           		LD      C,159
0B0C1E CD EE 0B 0B 1766*           		CALL    FLOAT_
0B0C22 B7          1767*           		OR      A
0B0C23 F8          1768*           		RET     M               ;NEGATIVE
0B0C24 CB BC       1769*           		RES     7,H
0B0C26 C9          1770*           		RET
0B0C27             1771*   ;
0B0C27             1772*   ;ROUND UP
0B0C27             1773*   ;Return with carry set if 32-bit overflow
0B0C27             1774*   ;   Destroys: H,L,B',C',H',L',F
0B0C27             1775*   ;
0B0C27 D9          1776*   ADD1_FP:			EXX
0B0C28 01 01 00 00 1777*           		LD      BC,1
0B0C2C 52 09       1778*           		ADD.S   HL,BC
0B0C2E D9          1779*           		EXX
0B0C2F D0          1780*           		RET     NC
0B0C30 C5          1781*           		PUSH    BC
0B0C31 01 01 00 00 1782*           		LD      BC,1
0B0C35 52 09       1783*           		ADD.S   HL,BC
0B0C37 C1          1784*           		POP     BC
0B0C38 C9          1785*           		RET
0B0C39             1786*   ;
0B0C39             1787*   ;ODD - Add one if even, leave alone if odd.
0B0C39             1788*   ; (Used to perform unbiassed rounding, i.e.
0B0C39             1789*   ;  number is rounded up half the time)
0B0C39             1790*   ;    Destroys: L',F (carry cleared)
0B0C39             1791*   ;
0B0C39 B7          1792*   ODD:			OR      A               ;CLEAR CARRY
0B0C3A D9          1793*           		EXX
0B0C3B CB C5       1794*           		SET     0,L             ;MAKE ODD
0B0C3D D9          1795*           		EXX
0B0C3E C9          1796*           		RET
0B0C3F             1797*   ;
0B0C3F             1798*   ;SWAP_FP - Swap arguments.
0B0C3F             1799*   ;    Exchanges DE,HL D'E',H'L' and B,C
0B0C3F             1800*   ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B0C3F             1801*   ;SWAP1 - Swap DEHL with D'E'H'L'
0B0C3F             1802*   ;    Destroys: D,E,H,L,D',E',H',L'
0B0C3F             1803*   ;
0B0C3F 79          1804*   SWAP_FP:			LD      A,C
0B0C40 48          1805*           		LD      C,B
0B0C41 47          1806*           		LD      B,A
0B0C42 EB          1807*   SWAP1:			EX      DE,HL
0B0C43 D9          1808*           		EXX
0B0C44 EB          1809*           		EX      DE,HL
0B0C45 D9          1810*           		EXX
0B0C46 C9          1811*           		RET
0B0C47             1812*   ;
0B0C47             1813*   ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
0B0C47             1814*   ; INCC - destroys C,F
0B0C47             1815*   ; OFLOW
0B0C47             1816*   ;
0B0C47 CD 00 0D 0B 1817*   DIV2:			CALL    D2
0B0C4B D9          1818*           		EXX
0B0C4C CB 18       1819*           		RR      B
0B0C4E CB 19       1820*           		RR      C
0B0C50 08          1821*           		EX      AF,AF'
0B0C51 B0          1822*           		OR      B
0B0C52 08          1823*           		EX      AF,AF'
0B0C53 D9          1824*           		EXX
0B0C54 0C          1825*   INCC:			INC     C
0B0C55 C0          1826*           		RET     NZ
0B0C56 3E 14       1827*   OFLOW:			LD      A,TOOBIG_FP
0B0C58 C3 E5 00 0B 1828*           		JP      ERROR_FP_           ;"Too big"
0B0C5C             1829*   ;
0B0C5C             1830*   ; FTEST - Test for zero & sign
0B0C5C             1831*   ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
0B0C5C             1832*   ;
0B0C5C CD 67 0C 0B 1833*   FTEST_FP:			CALL    TEST_FP
0B0C60 C8          1834*           		RET     Z
0B0C61 7C          1835*           		LD      A,H
0B0C62 E6 80       1836*           		AND     10000000B
0B0C64 F6 40       1837*           		OR      01000000B
0B0C66 C9          1838*           		RET
0B0C67             1839*   ;
0B0C67             1840*   ; TEST_FP - Test HLH'L' for zero.
0B0C67             1841*   ;     Output: Z-flag set & A=0 if HLH'L'=0
0B0C67             1842*   ;     Destroys: A,F
0B0C67             1843*   ;
0B0C67 7C          1844*   TEST_FP:			LD      A,H
0B0C68 B5          1845*           		OR      L
0B0C69 D9          1846*           		EXX
0B0C6A B4          1847*           		OR      H
0B0C6B B5          1848*           		OR      L
0B0C6C D9          1849*           		EXX
0B0C6D C9          1850*           		RET
0B0C6E             1851*   ;
0B0C6E             1852*   ; FCOMP - Compare two numbers
0B0C6E             1853*   ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
0B0C6E             1854*   ;
0B0C6E 78          1855*   FCOMP_FP:			LD      A,B
0B0C6F B1          1856*           		OR      C               ;Both integer?
0B0C70 20 0B       1857*           		JR      NZ,FCOMP1
0B0C72 CD 87 0C 0B 1858*           		CALL    ICP
0B0C76 3E 00       1859*   FCOMP0:			LD      A,0
0B0C78 C8          1860*           		RET     Z               ;Equal
0B0C79 3E 80       1861*           		LD      A,80H
0B0C7B 1F          1862*           		RRA
0B0C7C C9          1863*           		RET
0B0C7D             1864*   ;
0B0C7D CD 02 0C 0B 1865*   FCOMP1:			CALL    FLOAT2          ;Float both
0B0C81 CD 95 0C 0B 1866*           		CALL    FCP
0B0C85 18 EF       1867*           		JR      FCOMP0
0B0C87             1868*   ;
0B0C87             1869*   ; Integer and floating point compare.
0B0C87             1870*   ; Sets carry & zero flags according to HLH'L'C-DED'E'B
0B0C87             1871*   ; Result pre-set to FALSE
0B0C87             1872*   ; ICP1, FCP1 destroy A,F
0B0C87             1873*   ;
0B0C87             1874*   ; ZERO - Return zero.
0B0C87             1875*   ;  Destroys: A,C,H,L,H',L'
0B0C87             1876*   ;
0B0C87 CD BA 0C 0B 1877*   ICP:			CALL    ICP1
0B0C8B 3E 00       1878*   ZERO_FP:			LD      A,0
0B0C8D D9          1879*           		EXX
0B0C8E 67          1880*           		LD      H,A
0B0C8F 6F          1881*   	       		LD      L,A
0B0C90 D9          1882*           		EXX
0B0C91 67          1883*         			LD      H,A
0B0C92 6F          1884*        			LD      L,A
0B0C93 4F          1885*   	    		LD      C,A
0B0C94 C9          1886*           		RET
0B0C95             1887*   ;
0B0C95 CD AC 0C 0B 1888*   FCP:			CALL    FCP1
0B0C99 18 F0       1889*           		JR      ZERO_FP            ;PRESET FALSE
0B0C9B             1890*   ;
0B0C9B 79          1891*   FCP0:			LD      A,C
0B0C9C B8          1892*           		CP      B               ;COMPARE EXPONENTS
0B0C9D C0          1893*           		RET     NZ
0B0C9E             1894*   ICP0:
0B0C9E 52 ED 52    1895*   			SBC.S   HL,DE           ;COMP MANTISSA MSB
0B0CA1 52 19       1896*           		ADD.S   HL,DE
0B0CA3 C0          1897*           		RET     NZ
0B0CA4 D9          1898*           		EXX
0B0CA5 52 ED 52    1899*           		SBC.S   HL,DE           ;COMP MANTISSA LSB
0B0CA8 52 19       1900*           		ADD.S   HL,DE
0B0CAA D9          1901*           		EXX
0B0CAB C9          1902*           		RET
0B0CAC             1903*   ;
0B0CAC 7C          1904*   FCP1:			LD      A,H
0B0CAD AA          1905*           		XOR     D
0B0CAE 7C          1906*           		LD      A,H
0B0CAF 17          1907*           		RLA
0B0CB0 F8          1908*           		RET     M
0B0CB1 30 E8       1909*           		JR      NC,FCP0
0B0CB3 CD 9B 0C 0B 1910*           		CALL    FCP0
0B0CB7 C8          1911*           		RET     Z               ;** V0.1 BUG FIX
0B0CB8 3F          1912*           		CCF
0B0CB9 C9          1913*           		RET
0B0CBA             1914*   ;
0B0CBA 7C          1915*   ICP1:			LD      A,H
0B0CBB AA          1916*           		XOR     D
0B0CBC F2 9E 0C 0B 1917*           		JP      P,ICP0
0B0CC0 7C          1918*           		LD      A,H
0B0CC1 17          1919*           		RLA
0B0CC2 C9          1920*           		RET
0B0CC3             1921*   ;
0B0CC3             1922*   ; ADD - Integer add.
0B0CC3             1923*   ; Carry, sign & zero flags valid on exit
0B0CC3             1924*   ;     Destroys: H,L,H',L',F
0B0CC3             1925*   ;
0B0CC3 05          1926*   X10B:			DEC     B
0B0CC4 0C          1927*           		INC     C
0B0CC5 CD 0C 0D 0B 1928*   X5:			CALL    COPY0
0B0CC9 CD FF 0C 0B 1929*           		CALL    D2C
0B0CCD CD FF 0C 0B 1930*           		CALL    D2C
0B0CD1 08          1931*           		EX      AF,AF'          ;SAVE CARRY
0B0CD2 D9          1932*   ADD_:			EXX
0B0CD3 52 19       1933*           		ADD.S   HL,DE
0B0CD5 D9          1934*           		EXX
0B0CD6 52 ED 5A    1935*           		ADC.S   HL,DE
0B0CD9 C9          1936*           		RET
0B0CDA             1937*   ;
0B0CDA             1938*   ; SUB - Integer subtract.
0B0CDA             1939*   ; Carry, sign & zero flags valid on exit
0B0CDA             1940*   ;     Destroys: H,L,H',L',F
0B0CDA             1941*   ;
0B0CDA D9          1942*   SUB_:			EXX
0B0CDB B7          1943*           		OR      A
0B0CDC 52 ED 52    1944*           		SBC.S   HL,DE
0B0CDF D9          1945*           		EXX
0B0CE0 52 ED 52    1946*           		SBC.S   HL,DE
0B0CE3 C9          1947*           		RET
0B0CE4             1948*   ;
0B0CE4             1949*   ; X10 - unsigned integer * 10
0B0CE4             1950*   ;    Inputs: HLH'L' initial value
0B0CE4             1951*   ;   Outputs: DED'E' = initial HLH'L'
0B0CE4             1952*   ;            Carry bit set if overflow
0B0CE4             1953*   ;            If carry not set HLH'L'=result
0B0CE4             1954*   ;  Destroys: D,E,H,L,D',E',H',L',F
0B0CE4             1955*   ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
0B0CE4             1956*   ;     Carry set if MSB=1 before shift.
0B0CE4             1957*   ;     Sign set if MSB=1 after shift.
0B0CE4             1958*   ;     Destroys: H,L,H',L',F
0B0CE4             1959*   ;
0B0CE4 CD 0C 0D 0B 1960*   X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B0CE8 CD F7 0C 0B 1961*           		CALL    X2
0B0CEC D8          1962*           		RET     C               ;TOO BIG
0B0CED CD F7 0C 0B 1963*           		CALL    X2
0B0CF1 D8          1964*           		RET     C
0B0CF2 CD D2 0C 0B 1965*           		CALL    ADD_
0B0CF6 D8          1966*           		RET     C
0B0CF7 D9          1967*   X2:			EXX
0B0CF8 52 29       1968*           		ADD.S   HL,HL
0B0CFA D9          1969*           		EXX
0B0CFB 52 ED 6A    1970*           		ADC.S   HL,HL
0B0CFE C9          1971*           		RET
0B0CFF             1972*   ;
0B0CFF             1973*   ; D2 - Divide HLH'L' by 2 as 32-bit integer.
0B0CFF             1974*   ;     Carry set if LSB=1 before shift.
0B0CFF             1975*   ;     Destroys: H,L,H',L',F
0B0CFF             1976*   ;
0B0CFF 0C          1977*   D2C:			INC     C
0B0D00 CB 3C       1978*   D2:			SRL     H
0B0D02 CB 1D       1979*           		RR      L
0B0D04 D9          1980*           		EXX
0B0D05 CB 1C       1981*           		RR      H
0B0D07 CB 1D       1982*           		RR      L
0B0D09 D9          1983*           		EXX
0B0D0A C9          1984*           		RET
0B0D0B             1985*   ;
0B0D0B             1986*   ; COPY - COPY HLH'L'C INTO DED'E'B
0B0D0B             1987*   ;   Destroys: B,C,D,E,H,L,D',E',H',L'
0B0D0B             1988*   ;
0B0D0B 41          1989*   COPY_:			LD      B,C
0B0D0C 54          1990*   COPY0:			LD      D,H
0B0D0D 5D          1991*           		LD      E,L
0B0D0E D9          1992*           		EXX
0B0D0F 54          1993*           		LD      D,H
0B0D10 5D          1994*           		LD      E,L
0B0D11 D9          1995*           		EXX
0B0D12 C9          1996*           		RET
0B0D13             1997*   ;
0B0D13             1998*   ; SQUARE - PUSH X*X
0B0D13             1999*   ; PUSH5 - PUSH HLH'L'C ONTO STACK.
0B0D13             2000*   ;   Destroys: SP,IX
0B0D13             2001*   ;
0B0D13 CD 0B 0D 0B 2002*   SQUARE:			CALL    COPY_
0B0D17 CD 76 03 0B 2003*           		CALL    FMUL
0B0D1B DD E1       2004*   PUSH5:			POP     IX              ;RETURN ADDRESS
0B0D1D C5          2005*           		PUSH    BC
0B0D1E E5          2006*           		PUSH    HL
0B0D1F D9          2007*           		EXX
0B0D20 E5          2008*           		PUSH    HL
0B0D21 D9          2009*           		EXX
0B0D22 DD E9       2010*           		JP      (IX)            ;"RETURN"
0B0D24             2011*   ;
0B0D24             2012*   ; POP5 - POP DED'E'B OFF STACK.
0B0D24             2013*   ;   Destroys: A,B,D,E,D',E',SP,IX
0B0D24             2014*   ;
0B0D24 DD E1       2015*   POP5:			POP     IX              ;RETURN ADDRESS
0B0D26 D9          2016*           		EXX
0B0D27 D1          2017*           		POP     DE
0B0D28 D9          2018*           		EXX
0B0D29 D1          2019*           		POP     DE
0B0D2A 79          2020*           		LD      A,C
0B0D2B C1          2021*           		POP     BC
0B0D2C 41          2022*           		LD      B,C
0B0D2D 4F          2023*           		LD      C,A
0B0D2E DD E9       2024*           		JP      (IX)            ;"RETURN"
0B0D30             2025*   ;
0B0D30             2026*   ; RATIO - Calculate (X-1)/(X+1)
0B0D30             2027*   ;     Inputs: X in HLH'L'C
0B0D30             2028*   ;    Outputs: (X-1)/(X+1) in HLH'L'C
0B0D30             2029*   ;   Destroys: Everything except IY,SP,I
0B0D30             2030*   ;
0B0D30 CD 1B 0D 0B 2031*   RATIO:			CALL    PUSH5           ;SAVE X
0B0D34 CD A3 06 0B 2032*           		CALL    DONE
0B0D38 CD 64 02 0B 2033*           		CALL    FADD
0B0D3C CD 24 0D 0B 2034*           		CALL    POP5            ;RESTORE X
0B0D40 CD 1B 0D 0B 2035*           		CALL    PUSH5           ;SAVE X+1
0B0D44 CD 3F 0C 0B 2036*           		CALL    SWAP_FP
0B0D48 CD A3 06 0B 2037*           		CALL    DONE
0B0D4C CD 4B 02 0B 2038*           		CALL    FSUB
0B0D50 CD 24 0D 0B 2039*           		CALL    POP5            ;RESTORE X+1
0B0D54 C3 CD 02 0B 2040*           		JP      FDIV
0B0D58             2041*   ;
0B0D58             2042*   ; POLY - Evaluate a polynomial.
0B0D58             2043*   ;     Inputs: X in HLH'L'C and also stored at (SP+2)
0B0D58             2044*   ;             Polynomial coefficients follow call.
0B0D58             2045*   ;    Outputs: Result in HLH'L'C
0B0D58             2046*   ;   Destroys: Everything except IY,SP,I
0B0D58             2047*   ; Routine terminates on finding a coefficient >=1.
0B0D58             2048*   ; Note: The last coefficient is EXECUTED on return
0B0D58             2049*   ;       so must contain only innocuous bytes!
0B0D58             2050*   ;
0B0D58 DD 21 03 00 2051*   POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
0B0D5D DD 39       2052*           		ADD     IX, SP
0B0D5F DD E3       2053*           		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B0D61             2054*   ;
0B0D61 CD 37 0A 0B 2055*           		CALL    DLOAD5          		; Load the first coefficient from (IX)
0B0D65 CD 76 03 0B 2056*   POLY1:			CALL    FMUL
0B0D69 11 05 00 00 2057*           		LD      DE, 5				; Skip to the next coefficient
0B0D6D DD 19       2058*           		ADD     IX, DE
0B0D6F CD 37 0A 0B 2059*           		CALL    DLOAD5          		; Load the second coefficient from (IX)
0B0D73 DD E3       2060*           		EX      (SP), IX			; Restore the SP just in case we need to return
0B0D75 04          2061*           		INC     B
0B0D76 05          2062*           		DEC     B               		; Test B for end byte (80h)
0B0D77 FA 64 02 0B 2063*           		JP      M,FADD				; Yes, so add and return
0B0D7B CD 64 02 0B 2064*           		CALL    FADD				; No, so add
0B0D7F CD 49 0A 0B 2065*           		CALL    DLOAD5_SPL			; Load X from SP
0B0D83 DD E3       2066*           		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B0D85 18 DE       2067*           		JR      POLY1				; And loop
0B0D87             2068*   ;
0B0D87             2069*   ; POWR10 - Calculate power of ten.
0B0D87             2070*   ;     Inputs: A=power of 10 required (A<128)
0B0D87             2071*   ;             A=binary exponent to be exceeded (A>=128)
0B0D87             2072*   ;    Outputs: DED'E'B = result
0B0D87             2073*   ;             A = actual power of ten returned
0B0D87             2074*   ;   Destroys: A,B,D,E,A',D',E',F,F'
0B0D87             2075*   ;
0B0D87 3C          2076*   POWR10:			INC     A
0B0D88 08          2077*           		EX      AF,AF'
0B0D89 E5          2078*           		PUSH    HL
0B0D8A D9          2079*           		EXX
0B0D8B E5          2080*           		PUSH    HL
0B0D8C D9          2081*           		EXX
0B0D8D CD A3 06 0B 2082*           		CALL    DONE
0B0D91 CD 3F 0C 0B 2083*           		CALL    SWAP_FP
0B0D95 AF          2084*           		XOR     A
0B0D96 08          2085*   POWR11:			EX      AF,AF'
0B0D97 3D          2086*           		DEC     A
0B0D98 28 26       2087*           		JR      Z,POWR14        ;EXIT TYPE 1
0B0D9A F2 A2 0D 0B 2088*           		JP      P,POWR13
0B0D9E B9          2089*           		CP      C
0B0D9F 38 1F       2090*           		JR      C,POWR14        ;EXIT TYPE 2
0B0DA1 3C          2091*           		INC     A
0B0DA2 08          2092*   POWR13:			EX      AF,AF'
0B0DA3 3C          2093*           		INC     A
0B0DA4 CB FC       2094*           		SET     7,H
0B0DA6 CD C5 0C 0B 2095*           		CALL    X5
0B0DAA 30 06       2096*           		JR      NC,POWR12
0B0DAC 08          2097*           		EX      AF,AF'
0B0DAD CD FF 0C 0B 2098*           		CALL    D2C
0B0DB1 08          2099*           		EX      AF,AF'
0B0DB2 08          2100*   POWR12:			EX      AF,AF'
0B0DB3 DC 27 0C 0B 2101*           		CALL    C,ADD1_FP          ;ROUND UP
0B0DB7 0C          2102*           		INC     C
0B0DB8 FA 96 0D 0B 2103*           		JP      M,POWR11
0B0DBC C3 56 0C 0B 2104*           		JP      OFLOW
0B0DC0 CD 3F 0C 0B 2105*   POWR14:			CALL    SWAP_FP
0B0DC4 CB BA       2106*           		RES     7,D
0B0DC6 D9          2107*           		EXX
0B0DC7 E1          2108*           		POP     HL
0B0DC8 D9          2109*           		EXX
0B0DC9 E1          2110*           		POP     HL
0B0DCA 08          2111*           		EX      AF,AF'
0B0DCB C9          2112*           		RET
0B0DCC             2113*   ;
0B0DCC             2114*   ; DIVA, DIVB - DIVISION PRIMITIVE.
0B0DCC             2115*   ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
0B0DCC             2116*   ;               Remainder in H'L'HL
0B0DCC             2117*   ;     Inputs: A = loop counter (normally -32)
0B0DCC             2118*   ;     Destroys: A,D,E,H,L,D',E',H',L',F
0B0DCC             2119*   ;
0B0DCC B7          2120*   DIVA:			OR      A               ;CLEAR CARRY
0B0DCD             2121*   DIV0:
0B0DCD 52 ED 42    2122*   			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B0DD0 D9          2123*           		EXX
0B0DD1 52 ED 42    2124*           		SBC.S   HL,BC
0B0DD4 D9          2125*           		EXX
0B0DD5 30 07       2126*           		JR      NC,DIV1
0B0DD7 52 09       2127*           		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B0DD9 D9          2128*           		EXX
0B0DDA 52 ED 4A    2129*           		ADC.S   HL,BC
0B0DDD D9          2130*           		EXX
0B0DDE 3F          2131*   DIV1:			CCF
0B0DDF CB 13       2132*   DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B0DE1 CB 12       2133*           		RL      D
0B0DE3 D9          2134*           		EXX
0B0DE4 CB 13       2135*           		RL      E
0B0DE6 CB 12       2136*           		RL      D
0B0DE8 D9          2137*           		EXX
0B0DE9 3C          2138*           		INC     A
0B0DEA F0          2139*           		RET     P
0B0DEB             2140*   DIVB:
0B0DEB 52 ED 6A    2141*   			ADC.S   HL,HL           ;DIVIDEND*2
0B0DEE D9          2142*           		EXX
0B0DEF 52 ED 6A    2143*           		ADC.S   HL,HL
0B0DF2 D9          2144*           		EXX
0B0DF3 30 D8       2145*           		JR      NC,DIV0
0B0DF5 B7          2146*           		OR      A
0B0DF6 52 ED 42    2147*           		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B0DF9 D9          2148*           		EXX
0B0DFA 52 ED 42    2149*           		SBC.S   HL,BC
0B0DFD D9          2150*           		EXX
0B0DFE 37          2151*           		SCF
0B0DFF C3 DF 0D 0B 2152*           		JP      DIVC
0B0E03             2153*   ;
0B0E03             2154*   ;MULA, MULB - MULTIPLICATION PRIMITIVE.
0B0E03             2155*   ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
0B0E03             2156*   ;    Inputs: A = loop counter (usually -32)
0B0E03             2157*   ;            H'L'HL = 0
0B0E03             2158*   ;    Destroys: D,E,H,L,D',E',H',L',A,F
0B0E03             2159*   ;
0B0E03 B7          2160*   MULA:			OR      A               ;CLEAR CARRY
0B0E04 D9          2161*   MUL0:			EXX
0B0E05 CB 1A       2162*           		RR      D               ;MULTIPLIER/2
0B0E07 CB 1B       2163*           		RR      E
0B0E09 D9          2164*           		EXX
0B0E0A CB 1A       2165*           		RR      D
0B0E0C CB 1B       2166*           		RR      E
0B0E0E 30 07       2167*           		JR      NC,MUL1
0B0E10 52 09       2168*           		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B0E12 D9          2169*           		EXX
0B0E13 52 ED 4A    2170*           		ADC.S   HL,BC
0B0E16 D9          2171*           		EXX
0B0E17 3C          2172*   MUL1:			INC     A
0B0E18 F0          2173*           		RET     P
0B0E19 D9          2174*   MULB:			EXX
0B0E1A CB 1C       2175*           		RR      H               ;PRODUCT/2
0B0E1C CB 1D       2176*           		RR      L
0B0E1E D9          2177*           		EXX
0B0E1F CB 1C       2178*           		RR      H
0B0E21 CB 1D       2179*           		RR      L
0B0E23 C3 04 0E 0B 2180*           		JP      MUL0
0B0E27             2181*   ;
0B0E27             2182*   ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
0B0E27             2183*   ;     Function: B'C'BC = SQR (D'E'DE)
0B0E27             2184*   ;     Inputs: A = loop counter (normally -31)
0B0E27             2185*   ;             B'C'BCH'L'HL initialised to 0
0B0E27             2186*   ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
0B0E27             2187*   ;
0B0E27             2188*   SQR1:
0B0E27 52 ED 42    2189*   			SBC.S   HL,BC
0B0E2A D9          2190*           		EXX
0B0E2B 52 ED 42    2191*           		SBC.S   HL,BC
0B0E2E D9          2192*           		EXX
0B0E2F 0C          2193*           		INC     C
0B0E30 30 09       2194*           		JR      NC,SQR2
0B0E32 0D          2195*           		DEC     C
0B0E33 52 09       2196*           		ADD.S   HL,BC
0B0E35 D9          2197*           		EXX
0B0E36 52 ED 4A    2198*           		ADC.S   HL,BC
0B0E39 D9          2199*           		EXX
0B0E3A 0D          2200*           		DEC     C
0B0E3B 3C          2201*   SQR2:			INC     A
0B0E3C F0          2202*           		RET     P
0B0E3D CB 21       2203*   SQRA:			SLA     C
0B0E3F CB 10       2204*           		RL      B
0B0E41 D9          2205*           		EXX
0B0E42 CB 11       2206*           		RL      C
0B0E44 CB 10       2207*           		RL      B
0B0E46 D9          2208*           		EXX
0B0E47 0C          2209*           		INC     C
0B0E48 CB 23       2210*           		SLA     E
0B0E4A CB 12       2211*           		RL      D
0B0E4C D9          2212*           		EXX
0B0E4D CB 13       2213*           		RL      E
0B0E4F CB 12       2214*           		RL      D
0B0E51 D9          2215*           		EXX
0B0E52 52 ED 6A    2216*           		ADC.S   HL,HL
0B0E55 D9          2217*           		EXX
0B0E56 52 ED 6A    2218*           		ADC.S   HL,HL
0B0E59 D9          2219*           		EXX
0B0E5A CB 23       2220*           		SLA     E
0B0E5C CB 12       2221*           		RL      D
0B0E5E D9          2222*           		EXX
0B0E5F CB 13       2223*           		RL      E
0B0E61 CB 12       2224*           		RL      D
0B0E63 D9          2225*           		EXX
0B0E64 52 ED 6A    2226*           		ADC.S   HL,HL
0B0E67 D9          2227*           		EXX
0B0E68 52 ED 6A    2228*           		ADC.S   HL,HL
0B0E6B D9          2229*           		EXX
0B0E6C D2 27 0E 0B 2230*           		JP      NC,SQR1
0B0E70 B7          2231*   SQR3:			OR      A
0B0E71 52 ED 42    2232*           		SBC.S   HL,BC
0B0E74 D9          2233*           		EXX
0B0E75 52 ED 42    2234*           		SBC.S   HL,BC
0B0E78 D9          2235*           		EXX
0B0E79 0C          2236*           		INC     C
0B0E7A C3 3B 0E 0B 2237*           		JP      SQR2
0B0E7E             2238*   ;
0B0E7E             2239*   SQRB:
0B0E7E 52 29       2240*   			ADD.S   HL,HL
0B0E80 D9          2241*           		EXX
0B0E81 52 ED 6A    2242*           		ADC.S   HL,HL
0B0E84 D9          2243*           		EXX
0B0E85 38 E9       2244*           		JR      C,SQR3
0B0E87 3C          2245*           		INC     A
0B0E88 0C          2246*           		INC     C
0B0E89 52 ED 42    2247*           		SBC.S   HL,BC
0B0E8C D9          2248*           		EXX
0B0E8D 52 ED 42    2249*           		SBC.S   HL,BC
0B0E90 D9          2250*           		EXX
0B0E91 D0          2251*           		RET     NC
0B0E92 52 09       2252*           		ADD.S   HL,BC
0B0E94 D9          2253*           		EXX
0B0E95 52 ED 4A    2254*           		ADC.S   HL,BC
0B0E98 D9          2255*           		EXX
0B0E99 0D          2256*           		DEC     C
0B0E9A C9          2257*           		RET
0B0E9B             2258*   ;
0B0E9B DD 7E 00    2259*   DIGITQ:			LD      A,(IX)
0B0E9E FE 3A       2260*           		CP      '9'+1
0B0EA0 3F          2261*           		CCF
0B0EA1 D8          2262*           		RET     C
0B0EA2 FE 30       2263*           		CP      '0'
0B0EA4 C9          2264*           		RET
0B0EA5             2265*   ;
0B0EA5 DD 7E 00    2266*   SIGNQ:			LD      A,(IX)
0B0EA8 DD 23       2267*           		INC     IX
0B0EAA FE 20       2268*           		CP      ' '
0B0EAC 28 F7       2269*           		JR      Z,SIGNQ
0B0EAE FE 2B       2270*           		CP      '+'
0B0EB0 C8          2271*           		RET     Z
0B0EB1 FE 2D       2272*           		CP      '-'
0B0EB3 C8          2273*           		RET     Z
0B0EB4 DD 2B       2274*           		DEC     IX
0B0EB6 C9          2275*           		RET
0B0EB7             0181        include "functions.inc"
0B0EB7             0001*   ; Print a zero-terminated string inline with code, e.g.:
0B0EB7             0002*   ;
0B0EB7             0003*   ;    call printInline
0B0EB7             0004*   ;    ASCIZ "Hello, world!\r\n"
0B0EB7             0005*   ;
0B0EB7             0006*   ; Destroys: HL,AF
0B0EB7             0007*   printInline:
0B0EB7 E1          0008*       pop hl ; get the return address = pointer to start of string
0B0EB8 CD BE 0E 0B 0009*       call printString ; HL advances to end of string
0B0EBC E5          0010*       push hl ; restore the return address = pointer to end of string
0B0EBD C9          0011*       ret
0B0EBE             0012*   
0B0EBE             0013*   ; Print a zero-terminated string
0B0EBE             0014*   ; IX: Pointer to string, A: signed offset from IX
0B0EBE             0015*   printStringIX:
0B0EBE             0016*   
0B0EBE             0017*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0EBE             0018*   ; Print a zero-terminated string
0B0EBE             0019*   ; HL: Pointer to string
0B0EBE             0020*   ; returns: hl pointed to character after string terminator
0B0EBE             0021*   ; destroys: af, hl
0B0EBE             0022*   printString:
0B0EBE C5          0023*       PUSH BC
0B0EBF 01 00 00 00 0024*       LD BC,0
0B0EC3 3E 00       0025*       LD A,0
0B0EC5 5B DF       0026*       RST.LIL 18h
0B0EC7 C1          0027*       POP BC
0B0EC8 C9          0028*       RET
0B0EC9             0029*   ; print a VDU sequence
0B0EC9             0030*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0EC9             0031*   sendVDUsequence:
0B0EC9 C5          0032*       PUSH BC
0B0ECA 01 00 00 00 0033*       LD BC, 0
0B0ECE 4E          0034*       LD C, (HL)
0B0ECF 5B DF       0035*       RST.LIL 18h
0B0ED1 C1          0036*       POP BC
0B0ED2 C9          0037*       RET
0B0ED3             0038*   ; Print Newline sequence to VDP
0B0ED3             0039*   ; destroys: nothing
0B0ED3             0040*   printNewLine:
0B0ED3 F5          0041*       push af ; for some reason rst.lil 10h sets carry flag
0B0ED4 3E 0D       0042*       LD A, '\r'
0B0ED6 5B D7       0043*       RST.LIL 10h
0B0ED8 3E 0A       0044*       LD A, '\n'
0B0EDA 5B D7       0045*       RST.LIL 10h
0B0EDC F1          0046*       pop af
0B0EDD C9          0047*       RET
0B0EDE             0048*   
0B0EDE             0049*   ; print a zero-terminated string at a graphics coordinate
0B0EDE             0050*   ; Inputs: HL Pointer to string, BC,DE x,y position (in pixels)
0B0EDE             0051*   printStringGfx:
0B0EDE E5          0052*       push hl ; preserve string pointer
0B0EDF             0053*   ; move graphics cursor to x,y location
0B0EDF 3E 44       0054*       ld a,plot_pt+mv_abs
0B0EE1 CD 65 1A 0B 0055*       call vdu_plot
0B0EE5             0056*   ; print string
0B0EE5 E1          0057*       pop hl ; restore string pointer
0B0EE6             0058*   @print_loop:
0B0EE6 7E          0059*       ld a,(hl)
0B0EE7 B7          0060*       or a ; check for end of string
0B0EE8 C8          0061*       ret z ; if zero, we're done
0B0EE9 08          0062*       ex af,af' ; preserve character
0B0EEA 3E 05       0063*       ld a,5 ; VDU 5 char to gfx cursor
0B0EEC 5B D7       0064*       rst.lil 10h ; send it
0B0EEE 08          0065*       ex af,af' ; restore character
0B0EEF 5B D7       0066*       rst.lil 10h ; print character
0B0EF1 23          0067*       inc hl
0B0EF2 C3 E6 0E 0B 0068*       jp @print_loop
0B0EF6 C9          0069*       ret
0B0EF7             0070*   ; end printStringGfx
0B0EF7             0071*   
0B0EF7             0072*   ; Print a 24-bit HEX number
0B0EF7             0073*   ; HLU: Number to print
0B0EF7             0074*   printHex24:
0B0EF7             0075*       HLU_TO_A
                       M1 Args: none
0B0EF7 3B          0001*M1     dec sp ; 1 cycle
0B0EF8 E5          0002*M1     push hl ; 4 cycles
0B0EF9 33          0003*M1     inc sp ; 1 cycle
0B0EFA F1          0004*M1     pop af ; 4 cycles
0B0EFB             0005*M1     ; 10 cycles total
0B0EFB CD 05 0F 0B 0076*       CALL printHex8
0B0EFF             0077*   ; Print a 16-bit HEX number
0B0EFF             0078*   ; HL: Number to print
0B0EFF             0079*   printHex16:
0B0EFF 7C          0080*       LD A,H
0B0F00 CD 05 0F 0B 0081*       CALL printHex8
0B0F04 7D          0082*       LD A,L
0B0F05             0083*   ; Print an 8-bit HEX number
0B0F05             0084*   ; A: Number to print
0B0F05             0085*   printHex8:
0B0F05 4F          0086*       LD C,A
0B0F06 1F          0087*       RRA
0B0F07 1F          0088*       RRA
0B0F08 1F          0089*       RRA
0B0F09 1F          0090*       RRA
0B0F0A CD 0F 0F 0B 0091*       CALL @F
0B0F0E 79          0092*       LD A,C
0B0F0F             0093*   @@:
0B0F0F E6 0F       0094*       AND 0Fh
0B0F11 C6 90       0095*       ADD A,90h
0B0F13 27          0096*       DAA
0B0F14 CE 40       0097*       ADC A,40h
0B0F16 27          0098*       DAA
0B0F17 5B D7       0099*       RST.LIL 10h
0B0F19 C9          0100*       RET
0B0F1A             0101*   
0B0F1A             0102*   ; Print a 0x HEX prefix
0B0F1A             0103*   DisplayHexPrefix:
0B0F1A 3E 30       0104*       LD A, '0'
0B0F1C 5B D7       0105*       RST.LIL 10h
0B0F1E 3E 78       0106*       LD A, 'x'
0B0F20 5B D7       0107*       RST.LIL 10h
0B0F22 C9          0108*       RET
0B0F23             0109*   
0B0F23             0110*       MACRO printDecBC
0B0F23             0111*       push hl
0B0F23             0112*       push bc
0B0F23             0113*       pop hl
0B0F23             0114*       call printDec
0B0F23             0115*       pop hl
0B0F23             0116*       ENDMACRO
0B0F23             0117*   
0B0F23             0118*       MACRO printDecDE
0B0F23             0119*       push hl
0B0F23             0120*       push de
0B0F23             0121*       pop hl
0B0F23             0122*       call printDec
0B0F23             0123*       pop hl
0B0F23             0124*       ENDMACRO
0B0F23             0125*   
0B0F23             0126*       MACRO printDecHL
0B0F23             0127*       call printDec
0B0F23             0128*       ENDMACRO
0B0F23             0129*   
0B0F23             0130*       MACRO printDecIX
0B0F23             0131*       push hl
0B0F23             0132*       push ix
0B0F23             0133*       pop hl
0B0F23             0134*       call printDec
0B0F23             0135*       pop hl
0B0F23             0136*       ENDMACRO
0B0F23             0137*   
0B0F23             0138*       MACRO printDecIY
0B0F23             0139*       push hl
0B0F23             0140*       push iy
0B0F23             0141*       pop hl
0B0F23             0142*       call printDec
0B0F23             0143*       pop hl
0B0F23             0144*       ENDMACRO
0B0F23             0145*   
0B0F23             0146*   
0B0F23             0147*   ; Prints the right justified decimal value in HL without leading zeroes
0B0F23             0148*   ; HL : Value to print
0B0F23             0149*   ; preserves all registers and flags
0B0F23             0150*   printDec:
0B0F23             0151*   ; BEGIN MY CODE
0B0F23             0152*   ; back up all the things
0B0F23 F5          0153*       push af
0B0F24 C5          0154*       push bc
0B0F25 D5          0155*       push de
0B0F26 E5          0156*       push hl
0B0F27             0157*   ; END MY CODE
0B0F27 11 4F 0F 0B 0158*       LD DE, _printDecBuffer
0B0F2B CD 5F 0F 0B 0159*       CALL u24_to_ascii
0B0F2F             0160*   ; BEGIN MY CODE
0B0F2F             0161*   ; replace leading zeroes with spaces
0B0F2F 21 4F 0F 0B 0162*       LD HL, _printDecBuffer
0B0F33 06 07       0163*       ld B, 7 ; if HL was 0, we want to keep the final zero
0B0F35             0164*   @loop:
0B0F35 7E          0165*       LD A, (HL)
0B0F36 FE 30       0166*       CP '0'
0B0F38 C2 42 0F 0B 0167*       JP NZ, @done
0B0F3C 3E 20       0168*       LD A, ' '
0B0F3E 77          0169*       LD (HL), A
0B0F3F 23          0170*       INC HL
0B0F40             0171*       ; CALL vdu_cursor_forward
0B0F40 10 F3       0172*       DJNZ @loop
0B0F42             0173*   @done:
0B0F42             0174*   ; END MY CODE
0B0F42 21 4F 0F 0B 0175*       LD HL, _printDecBuffer
0B0F46 CD BE 0E 0B 0176*       CALL printString
0B0F4A             0177*   ; BEGIN MY CODE
0B0F4A             0178*   ; restore all the things
0B0F4A E1          0179*       pop hl
0B0F4B D1          0180*       pop de
0B0F4C C1          0181*       pop bc
0B0F4D F1          0182*       pop af
0B0F4E             0183*   ; END MY CODE
0B0F4E C9          0184*       RET
0B0F4F 00 00 00 00 0185*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0F5F             0186*   
0B0F5F             0187*   ; This routine converts the unsigned 24-bit value in HLU into its ASCII representation,
0B0F5F             0188*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0F5F             0189*   ; so it will allways be 8 characters length
0B0F5F             0190*   ; HL : Value to convert to string
0B0F5F             0191*   ; DE : pointer to buffer, at least 8 byte + 0
0B0F5F             0192*   u24_to_ascii:
0B0F5F 01 80 69 67 0193*       LD BC,-10000000
0B0F63 CD 96 0F 0B 0194*       CALL one_digit
0B0F67 01 C0 BD F0 0195*       LD BC,-1000000
0B0F6B CD 96 0F 0B 0196*       CALL one_digit
0B0F6F 01 60 79 FE 0197*       LD BC,-100000
0B0F73 CD 96 0F 0B 0198*       CALL one_digit
0B0F77 01 F0 D8 FF 0199*       LD BC,-10000
0B0F7B CD 96 0F 0B 0200*       CALL one_digit
0B0F7F             0201*   u8_to_ascii: ; same arguments but hl <= 255, uhl and h = 0
0B0F7F 01 18 FC FF 0202*       LD BC,-1000
0B0F83 CD 96 0F 0B 0203*       CALL one_digit
0B0F87 01 9C FF FF 0204*       LD BC,-100
0B0F8B CD 96 0F 0B 0205*       CALL one_digit
0B0F8F 0E F6       0206*       LD C,-10
0B0F91 CD 96 0F 0B 0207*       CALL one_digit
0B0F95 48          0208*       LD C,B
0B0F96             0209*   one_digit:
0B0F96 3E 2F       0210*       LD A,'0'-1
0B0F98             0211*   @divide_me:
0B0F98 3C          0212*       INC A
0B0F99 09          0213*       ADD HL,BC
0B0F9A 38 FC       0214*       JR C,@divide_me
0B0F9C ED 42       0215*       SBC HL,BC
0B0F9E 12          0216*       LD (DE),A
0B0F9F 13          0217*       INC DE
0B0FA0 C9          0218*       RET
0B0FA1             0219*   
0B0FA1             0220*   print_u24:
0B0FA1 D5          0221*       push de
0B0FA2 E5          0222*       push hl
0B0FA3 11 4F 0F 0B 0223*       ld de,_printDecBuffer
0B0FA7 CD 5F 0F 0B 0224*       call u24_to_ascii
0B0FAB 21 4F 0F 0B 0225*       ld hl,_printDecBuffer
0B0FAF CD BE 0E 0B 0226*       call printString
0B0FB3 3E 20       0227*       ld a,' '
0B0FB5 5B D7       0228*       rst.lil 10h
0B0FB7 E1          0229*       pop hl
0B0FB8 D1          0230*       pop de
0B0FB9 C9          0231*       ret
0B0FBA             0232*   
0B0FBA             0233*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0FBA             0234*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0FBA             0235*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0FBA             0236*   u168_to_ascii:
0B0FBA             0237*   ; add a leading space to make room for sign flag if needed
0B0FBA 3E 20       0238*       ld a,' '
0B0FBC 12          0239*       ld (de),a
0B0FBD 13          0240*       inc de
0B0FBE             0241*   ; Convert integer part
0B0FBE E5          0242*       push hl ; Save HL (we’ll need the fractional part later)
0B0FBF             0243*       ; call hlu_udiv256 ; Shift to get integer portion in HL
0B0FBF             0244*       SRL_UHL ; Shift to get integer portion in HL
                       M1 Args: none
0B0FBF 3B          0001*M1     dec sp ; 1 cycle
0B0FC0 E5          0002*M1     push hl ; 4 cycles
0B0FC1 33          0003*M1     inc sp ; 1 cycle
0B0FC2 E1          0004*M1     pop hl ; 4 cycles
0B0FC3 23          0005*M1     inc hl ; 1 cycle
0B0FC4 52 2B       0006*M1     dec.s hl ; 2 cycles <-- the .s sets hlu to zero (undocumented)
0B0FC6             0007*M1     ; 13 cycles total
0B0FC6 01 F0 D8 FF 0245*       ld bc, -10000
0B0FCA CD ED 0F 0B 0246*       call @one_int
0B0FCE 01 18 FC FF 0247*       ld bc, -1000
0B0FD2 CD ED 0F 0B 0248*       call @one_int
0B0FD6 01 9C FF FF 0249*       ld bc, -100
0B0FDA CD ED 0F 0B 0250*       call @one_int
0B0FDE 0E F6       0251*       ld c, -10
0B0FE0 CD ED 0F 0B 0252*       call @one_int
0B0FE4 48          0253*       ld c, b
0B0FE5 CD ED 0F 0B 0254*       call @one_int
0B0FE9 C3 F8 0F 0B 0255*       jp @frac ; Jump to fractional part conversion
0B0FED             0256*   @one_int:
0B0FED 3E 2F       0257*       ld a, '0' - 1 ; Start ASCII character at '0'
0B0FEF             0258*   @divide_me:
0B0FEF 3C          0259*       inc a
0B0FF0 09          0260*       add hl, bc ; Accumulate until overflow
0B0FF1 38 FC       0261*       jr c, @divide_me
0B0FF3 ED 42       0262*       sbc hl, bc ; Remove excess after overflow
0B0FF5 12          0263*       ld (de), a ; Store ASCII digit
0B0FF6 13          0264*       inc de
0B0FF7 C9          0265*       ret
0B0FF8             0266*   ; Convert fractional part
0B0FF8             0267*   @frac:
0B0FF8 3E 2E       0268*       ld a, '.' ; Decimal point
0B0FFA 12          0269*       ld (de), a
0B0FFB 13          0270*       inc de
0B0FFC E1          0271*       pop hl ; Restore HL with original fraction
0B0FFD 06 03       0272*       ld b, 3 ; Loop counter for 3 fractional digits
0B0FFF             0273*   @frac_loop:
0B0FFF 26 0A       0274*       ld h, 10 ; Load multiplier for fractional part
0B1001 ED 6C       0275*       mlt hl ; Multiply by 10, result in HL (H holds the integer part)
0B1003 3E 30       0276*       ld a, '0'
0B1005 84          0277*       add a, h ; Convert integer part to ASCII
0B1006 12          0278*       ld (de), a
0B1007 13          0279*       inc de
0B1008 10 F5       0280*       djnz @frac_loop ; Repeat for each fractional digit
0B100A             0281*   ; Add null terminator
0B100A AF          0282*       xor a ; Null terminator
0B100B 12          0283*       ld (de), a
0B100C C9          0284*       ret
0B100D             0285*   
0B100D             0286*   print_u168:
0B100D D5          0287*       push de
0B100E E5          0288*       push hl
0B100F 11 4F 0F 0B 0289*       ld de,_printDecBuffer
0B1013 CD BA 0F 0B 0290*       call u168_to_ascii
0B1017 21 4F 0F 0B 0291*       ld hl,_printDecBuffer
0B101B CD BE 0E 0B 0292*       call printString
0B101F E1          0293*       pop hl
0B1020 D1          0294*       pop de
0B1021 C9          0295*       ret
0B1022             0296*   
0B1022             0297*   ; signed version of u168_to_ascii
0B1022             0298*   s168_to_ascii:
0B1022 D5          0299*       push de ; save starting address of buffer
0B1023 CD 9D 12 0B 0300*       call hlu_abs
0B1027 F5          0301*       push af ; save sign flag
0B1028 CD BA 0F 0B 0302*       call u168_to_ascii
0B102C F1          0303*       pop af ; restore sign flag
0B102D D1          0304*       pop de ; restore starting address of buffer
0B102E F0          0305*       ret p ; hlu was positive so nothing to do
0B102F 3E 2D       0306*       ld a,'-'
0B1031 12          0307*       ld (de),a
0B1032 C9          0308*       ret
0B1033             0309*   
0B1033             0310*   print_s168:
0B1033 D5          0311*       push de
0B1034 E5          0312*       push hl
0B1035 11 4F 0F 0B 0313*       ld de,_printDecBuffer
0B1039 CD 22 10 0B 0314*       call s168_to_ascii
0B103D 21 4F 0F 0B 0315*       ld hl,_printDecBuffer
0B1041 CD BE 0E 0B 0316*       call printString
0B1045 E1          0317*       pop hl
0B1046 D1          0318*       pop de
0B1047 C9          0319*       ret
0B1048             0320*   
0B1048             0321*   print_s168_hl:
0B1048 F5          0322*       push af
0B1049 E5          0323*       push hl
0B104A CD 33 10 0B 0324*       call print_s168
0B104E 3E 20       0325*       ld a,' '
0B1050 5B D7       0326*       rst.lil 10h
0B1052 E1          0327*       pop hl
0B1053 F1          0328*       pop af
0B1054 C9          0329*       ret
0B1055             0330*   
0B1055             0331*   print_s168_bc:
0B1055 F5          0332*       push af
0B1056 C5          0333*       push bc
0B1057 E5          0334*       push hl
0B1058 C5          0335*       push bc
0B1059 E1          0336*       pop hl
0B105A CD 33 10 0B 0337*       call print_s168
0B105E 3E 20       0338*       ld a,' '
0B1060 5B D7       0339*       rst.lil 10h
0B1062 E1          0340*       pop hl
0B1063 C1          0341*       pop bc
0B1064 F1          0342*       pop af
0B1065 C9          0343*       ret
0B1066             0344*   
0B1066             0345*   print_s168_de:
0B1066 F5          0346*       push af
0B1067 D5          0347*       push de
0B1068 E5          0348*       push hl
0B1069 EB          0349*       ex de,hl
0B106A CD 33 10 0B 0350*       call print_s168
0B106E 3E 20       0351*       ld a,' '
0B1070 5B D7       0352*       rst.lil 10h
0B1072 E1          0353*       pop hl
0B1073 D1          0354*       pop de
0B1074 F1          0355*       pop af
0B1075 C9          0356*       ret
0B1076             0357*   
0B1076             0358*   print_s168_hl_bc_de:
0B1076 F5          0359*       push af
0B1077 C5          0360*       push bc
0B1078 D5          0361*       push de
0B1079 E5          0362*       push hl
0B107A CD 33 10 0B 0363*       call print_s168
0B107E 3E 20       0364*       ld a,' '
0B1080 5B D7       0365*       rst.lil 10h
0B1082 C5          0366*       push bc
0B1083 E1          0367*       pop hl
0B1084 CD 33 10 0B 0368*       call print_s168
0B1088 3E 20       0369*       ld a,' '
0B108A 5B D7       0370*       rst.lil 10h
0B108C EB          0371*       ex de,hl
0B108D CD 33 10 0B 0372*       call print_s168
0B1091 3E 20       0373*       ld a,' '
0B1093 5B D7       0374*       rst.lil 10h
0B1095 E1          0375*       pop hl
0B1096 D1          0376*       pop de
0B1097 C1          0377*       pop bc
0B1098 F1          0378*       pop af
0B1099 C9          0379*       ret
0B109A             0380*   
0B109A             0381*   print_s168_bc_de:
0B109A F5          0382*       push af
0B109B C5          0383*       push bc
0B109C D5          0384*       push de
0B109D C5          0385*       push bc
0B109E E1          0386*       pop hl
0B109F CD 33 10 0B 0387*       call print_s168
0B10A3 3E 20       0388*       ld a,' '
0B10A5 5B D7       0389*       rst.lil 10h
0B10A7 EB          0390*       ex de,hl
0B10A8 CD 33 10 0B 0391*       call print_s168
0B10AC 3E 20       0392*       ld a,' '
0B10AE 5B D7       0393*       rst.lil 10h
0B10B0 E1          0394*       pop hl
0B10B1 D1          0395*       pop de
0B10B2 C1          0396*       pop bc
0B10B3 F1          0397*       pop af
0B10B4 C9          0398*       ret
0B10B5             0399*   
0B10B5             0400*   print_s168_a:
0B10B5 F5          0401*       push af
0B10B6 C5          0402*       push bc
0B10B7 E5          0403*       push hl
0B10B8 21 00 00 00 0404*       ld hl,0
0B10BC 6F          0405*       ld l,a
0B10BD CD 48 10 0B 0406*       call print_s168_hl
0B10C1 E1          0407*       pop hl
0B10C2 C1          0408*       pop bc
0B10C3 F1          0409*       pop af
0B10C4 C9          0410*       ret
0B10C5             0411*   
0B10C5             0412*   ; #### new functions added by Brandon R. Gates ####
0B10C5             0413*   
0B10C5             0414*   ; print the binary representation of the 8-bit value in a
0B10C5             0415*   ; destroys a, hl, bc
0B10C5             0416*   printBin8:
0B10C5 06 08       0417*       ld b,8 ; loop counter for 8 bits
0B10C7 21 E2 10 0B 0418*       ld hl,@cmd ; set hl to the low byte of the output string
0B10CB             0419*       ; (which will be the high bit of the value in a)
0B10CB             0420*   @loop:
0B10CB 07          0421*       rlca ; put the next highest bit into carry
0B10CC 38 04       0422*       jr c,@one
0B10CE 36 30       0423*       ld (hl),'0'
0B10D0 18 02       0424*       jr @next_bit
0B10D2             0425*   @one:
0B10D2 36 31       0426*       ld (hl),'1'
0B10D4             0427*   @next_bit:
0B10D4 23          0428*       inc hl
0B10D5 10 F4       0429*       djnz @loop
0B10D7             0430*   ; print it
0B10D7 21 E2 10 0B 0431*       ld hl,@cmd
0B10DB 01 08 00 00 0432*       ld bc,@end-@cmd
0B10DF 5B DF       0433*       rst.lil $18
0B10E1 C9          0434*       ret
0B10E2             0435*   @cmd: ds 8 ; eight bytes for eight bits
0B10EA             0436*   @end:
0B10EA             0437*   
0B10EA             0438*   ; print the binary representation of the 8-bit value in a
0B10EA             0439*   ; in reverse order (lsb first)
0B10EA             0440*   ; destroys a, hl, bc
0B10EA             0441*   printBin8Rev:
       FF FF FF FF 
       FF FF FF FF 
0B10EA 06 08       0442*       ld b,8 ; loop counter for 8 bits
0B10EC 21 07 11 0B 0443*       ld hl,@cmd ; set hl to the low byte of the output string
0B10F0             0444*       ; (which will be the high bit of the value in a)
0B10F0             0445*   @loop:
0B10F0 0F          0446*       rrca ; put the next lowest bit into carry
0B10F1 38 04       0447*       jr c,@one
0B10F3 36 30       0448*       ld (hl),'0'
0B10F5 18 02       0449*       jr @next_bit
0B10F7             0450*   @one:
0B10F7 36 31       0451*       ld (hl),'1'
0B10F9             0452*   @next_bit:
0B10F9 23          0453*       inc hl
0B10FA 10 F4       0454*       djnz @loop
0B10FC             0455*   ; print it
0B10FC 21 07 11 0B 0456*       ld hl,@cmd
0B1100 01 08 00 00 0457*       ld bc,@end-@cmd
0B1104 5B DF       0458*       rst.lil $18
0B1106 C9          0459*       ret
0B1107             0460*   @cmd: ds 8 ; eight bytes for eight bits
0B110F             0461*   @end:
0B110F             0462*   
       FF FF FF FF 
       FF FF FF FF 
0B110F 20 61 66 3D 0463*   str_afu: db " af=",0
       00          
0B1114 20 68 6C 3D 0464*   str_hlu: db " hl=",0
       00          
0B1119 20 62 63 3D 0465*   str_bcu: db " bc=",0
       00          
0B111E 20 64 65 3D 0466*   str_deu: db " de=",0
       00          
0B1123 20 69 78 3D 0467*   str_ixu: db " ix=",0
       00          
0B1128 20 69 79 3D 0468*   str_iyu: db " iy=",0
       00          
0B112D             0469*   
0B112D             0470*   ; print udeuhl to screen in hexidecimal format
0B112D             0471*   ; inputs: none
0B112D             0472*   ; outputs: concatenated hexidecimal udeuhl
0B112D             0473*   ; destroys: nothing
0B112D             0474*   dumpUDEUHLHex:
0B112D             0475*   ; store everything in scratch
0B112D 22 8C 11 0B 0476*       ld (uhl),hl
0B1131 ED 43 8F 11 0477*       ld (ubc),bc
       0B          
0B1136 ED 53 92 11 0478*       ld (ude),de
       0B          
0B113B DD 22 95 11 0479*       ld (uix),ix
       0B          
0B1140 FD 22 98 11 0480*       ld (uiy),iy
       0B          
0B1145 F5          0481*       push af
0B1146             0482*   
0B1146             0483*   ; print each register
0B1146             0484*   
0B1146 21 80 11 0B 0485*       ld hl,str_udeuhl
0B114A CD BE 0E 0B 0486*       call printString
0B114E 2A 92 11 0B 0487*       ld hl,(ude)
0B1152 CD F7 0E 0B 0488*       call printHex24
0B1156 3E 2E       0489*       ld a,'.' ; print a dot to separate the values
0B1158 5B D7       0490*       rst.lil 10h
0B115A 2A 8C 11 0B 0491*       ld hl,(uhl)
0B115E CD F7 0E 0B 0492*       call printHex24
0B1162 CD D3 0E 0B 0493*       call printNewLine
0B1166             0494*   
0B1166             0495*   ; restore everything
0B1166 2A 8C 11 0B 0496*       ld hl, (uhl)
0B116A ED 4B 8F 11 0497*       ld bc, (ubc)
       0B          
0B116F ED 5B 92 11 0498*       ld de, (ude)
       0B          
0B1174 DD 2A 95 11 0499*       ld ix, (uix)
       0B          
0B1179 FD 2A 98 11 0500*       ld iy, (uiy)
       0B          
0B117E F1          0501*       pop af
0B117F             0502*   ; all done
0B117F C9          0503*       ret
0B1180             0504*   
0B1180 75 64 65 2E 0505*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B1189             0506*   
0B1189             0507*   ; global scratch memory for registers
0B1189 00 00 00    0508*   uaf: dl 0
0B118C 00 00 00    0509*   uhl: dl 0
0B118F 00 00 00    0510*   ubc: dl 0
0B1192 00 00 00    0511*   ude: dl 0
0B1195 00 00 00    0512*   uix: dl 0
0B1198 00 00 00    0513*   uiy: dl 0
0B119B 00 00 00    0514*   usp: dl 0
0B119E 00 00 00    0515*   upc: dl 0
0B11A1             0516*   
0B11A1             0517*   
0B11A1             0518*   ; set all the bits in the flag register
0B11A1             0519*   ; more of an academic exercise than anything useful
0B11A1             0520*   ; inputs; none
0B11A1             0521*   ; outputs; a=0,f=255
0B11A1             0522*   ; destroys: flags, hl
0B11A1             0523*   ; preserves: a, because why not
0B11A1             0524*   setAllFlags:
0B11A1 21 FF 00 00 0525*       ld hl,255
0B11A5 67          0526*       ld h,a ; four cycles to preserve a is cheap
0B11A6 E5          0527*       push hl
0B11A7 F1          0528*       pop af
0B11A8 C9          0529*       ret
0B11A9             0530*   
0B11A9             0531*   ; reset all the bits in the flag register
0B11A9             0532*   ; unlike its inverse counterpart, this may actually be useful
0B11A9             0533*   ; inputs; none
0B11A9             0534*   ; outputs; a=0,f=0
0B11A9             0535*   ; destroys: flags, hl
0B11A9             0536*   ; preserves: a, because why not
0B11A9             0537*   resetAllFlags:
0B11A9 21 00 00 00 0538*       ld hl,0
0B11AD 67          0539*       ld h,a ; four cycles to preserve a is cheap
0B11AE E5          0540*       push hl
0B11AF F1          0541*       pop af
0B11B0 C9          0542*       ret
0B11B1             0543*   
0B11B1             0544*   ; wait until user presses a key
0B11B1             0545*   ; inputs: none
0B11B1             0546*   ; outputs: ascii code of key pressed in a
0B11B1             0547*   ; destroys: af,ix
0B11B1             0548*   waitKeypress:
0B11B1             0549*       MOSCALL mos_getkey
                       M1 Args: function=mos_getkey 
0B11B1 3E 00       0001*M1 			LD	A, function
0B11B3 49 CF       0002*M1 			RST.LIS	08h
0B11B5 C9          0550*       ret
0B11B6             0551*   
0B11B6             0552*   ; clear a block of memory by writing a prescribed value to each byte in the range
0B11B6             0553*   ; inputs: a = value to write, hl = address of first byte, bc = number of bytes
0B11B6             0554*   ; outputs: memory block is cleared
0B11B6             0555*   ; destroys: hl, bc, de
0B11B6             0556*   clear_mem:
0B11B6 0B          0557*       dec bc ; we do this because we will increment de before writing the first byte
0B11B7 77          0558*       ld (hl),a
0B11B8 E5          0559*       push hl
0B11B9 D1          0560*       pop de
0B11BA 13          0561*       inc de ; target address
0B11BB ED B0       0562*       ldir
0B11BD C9          0563*       ret
0B11BE             0182        include "arith24.inc"
0B11BE             0001*   ;------------------------------------------------------------------------
0B11BE             0002*   ;  arith24.asm
0B11BE             0003*   ;  24-bit ez80 arithmetic routines
0B11BE             0004*   ;  Copyright (c) Shawn Sijnstra 2024
0B11BE             0005*   ;  MIT license
0B11BE             0006*   ;
0B11BE             0007*   ;  This library was created as a tool to help make ez80
0B11BE             0008*   ;  24-bit native assembly routines for simple mathematical problems
0B11BE             0009*   ;  more widely available.
0B11BE             0010*   ;
0B11BE             0011*   ;------------------------------------------------------------------------
0B11BE             0012*   
0B11BE             0013*   ;------------------------------------------------------------------------
0B11BE             0014*   ; umul24:	HL = HL*DE (unsigned)
0B11BE             0015*   ; Preserves AF, BC, DE
0B11BE             0016*   ; Uses a fast multiply routine.
0B11BE             0017*   ;------------------------------------------------------------------------
0B11BE             0018*   umul24:
0B11BE D5          0019*   	push	DE
0B11BF C5          0020*   	push	BC
0B11C0 F5          0021*   	push	AF
0B11C1 E5          0022*   	push	HL
0B11C2 C1          0023*   	pop		BC
0B11C3 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
0B11C5 21 00 00 00 0025*       ld	 	hl, 0 ; Result
0B11C9             0026*   umul24_lp:
0B11C9 29          0027*   	add	hl,hl
0B11CA EB          0028*   	ex	de,hl
0B11CB 29          0029*   	add	hl,hl
0B11CC EB          0030*   	ex	de,hl
0B11CD 30 01       0031*   	jr	nc,umul24_nc
0B11CF 09          0032*   	add	hl,bc
0B11D0             0033*   umul24_nc:
0B11D0 3D          0034*   	dec	a
0B11D1 20 F6       0035*   	jr	nz,umul24_lp
0B11D3 F1          0036*   	pop	af
0B11D4 C1          0037*   	pop	bc
0B11D5 D1          0038*   	pop	de
0B11D6 C9          0039*   	ret
0B11D7             0040*   
0B11D7             0041*   
0B11D7             0042*   ;------------------------------------------------------------------------
0B11D7             0043*   ; udiv24
0B11D7             0044*   ; Unsigned 24-bit division
0B11D7             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B11D7             0046*   ;
0B11D7             0047*   ; Uses AF BC DE HL
0B11D7             0048*   ; Uses Restoring Division algorithm
0B11D7             0049*   ;------------------------------------------------------------------------
0B11D7             0050*   
0B11D7             0051*   udiv24:
0B11D7 E5          0052*   	push	hl
0B11D8 C1          0053*   	pop		bc	;move dividend to BCU
0B11D9 21 00 00 00 0054*   	ld		hl,0	;result
0B11DD A7          0055*   	and		a
0B11DE ED 52       0056*   	sbc		hl,de	;test for div by 0
0B11E0 C8          0057*   	ret		z		;it's zero, carry flag is clear
0B11E1 19          0058*   	add		hl,de	;HL is 0 again
0B11E2 3E 18       0059*   	ld		a,24	;number of loops through.
0B11E4             0060*   udiv1:
0B11E4 C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
0B11E5 E3          0062*   	ex		(sp),hl
0B11E6 37          0063*   	scf
0B11E7 ED 6A       0064*   	adc	hl,hl
0B11E9 E3          0065*   	ex	(sp),hl
0B11EA C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
0B11EB             0067*   
0B11EB ED 6A       0068*   	adc	hl,hl
0B11ED A7          0069*   	and	a		;is this the bug
0B11EE ED 52       0070*   	sbc	hl,de
0B11F0 30 02       0071*   	jr	nc,udiv2
0B11F2 19          0072*   	add	hl,de
0B11F3             0073*   ;	dec	c
0B11F3 0B          0074*   	dec	bc
0B11F4             0075*   udiv2:
0B11F4 3D          0076*   	dec	a
0B11F5 20 ED       0077*   	jr	nz,udiv1
0B11F7 37          0078*   	scf		;flag used for div0 error
0B11F8 C5          0079*   	push	bc
0B11F9 D1          0080*   	pop		de	;remainder
0B11FA C9          0081*   	ret
0B11FB             0082*   
0B11FB             0083*   
0B11FB             0084*   
0B11FB             0085*   ;------------------------------------------------------------------------
0B11FB             0086*   ; neg24
0B11FB             0087*   ; Returns: HLU = 0-HLU
0B11FB             0088*   ; preserves all other registers
0B11FB             0089*   ;------------------------------------------------------------------------
0B11FB             0090*   neg24:
0B11FB D5          0091*   	push	de
0B11FC EB          0092*   	ex		de,hl
0B11FD 21 00 00 00 0093*   	ld		hl,0
0B1201 B7          0094*   	or		a
0B1202 ED 52       0095*   	sbc		hl,de
0B1204 D1          0096*   	pop		de
0B1205 C9          0097*   	ret
0B1206             0098*   
0B1206             0099*   ;------------------------------------------------------------------------
0B1206             0100*   ; or_hlu_deu: 24 bit bitwise OR
0B1206             0101*   ; Returns: hlu = hlu OR deu
0B1206             0102*   ; preserves all other registers
0B1206             0103*   ;------------------------------------------------------------------------
0B1206             0104*   or_hlu_deu:
0B1206 22 91 12 0B 0105*   	ld	(bitbuf1),hl
0B120A ED 53 94 12 0106*   	ld	(bitbuf2),de
       0B          
0B120F D5          0107*   	push	de	;preserve DEU
0B1210 C5          0108*   	push	bc	;preserve BCU
0B1211 06 03       0109*   	ld		b,3
0B1213 21 91 12 0B 0110*   	ld	hl,bitbuf1
0B1217 11 91 12 0B 0111*   	ld	de,bitbuf1
0B121B             0112*   orloop_24:
0B121B 1A          0113*   	ld	a,(de)
0B121C B6          0114*   	or	(hl)
0B121D 12          0115*   	ld	(de),a
0B121E 13          0116*   	inc	de
0B121F 23          0117*   	inc	hl
0B1220 10 F9       0118*   	djnz	orloop_24
0B1222 2A 94 12 0B 0119*   	ld	hl,(bitbuf2)
0B1226 C1          0120*   	pop		bc	;restore BC
0B1227 D1          0121*   	pop		de	;restore DE
0B1228             0122*   
0B1228             0123*   ;------------------------------------------------------------------------
0B1228             0124*   ; and_hlu_deu: 24 bit bitwise AND
0B1228             0125*   ; Returns: hlu = hlu AND deu
0B1228             0126*   ; preserves all other registers
0B1228             0127*   ;------------------------------------------------------------------------
0B1228             0128*   and_hlu_deu:
0B1228 22 91 12 0B 0129*   	ld	(bitbuf1),hl
0B122C ED 53 94 12 0130*   	ld	(bitbuf2),de
       0B          
0B1231 D5          0131*   	push	de	;preserve DEU
0B1232 C5          0132*   	push	bc	;preserve BCU
0B1233 06 03       0133*   	ld		b,3
0B1235 21 91 12 0B 0134*   	ld	hl,bitbuf1
0B1239 11 91 12 0B 0135*   	ld	de,bitbuf1
0B123D             0136*   andloop_24:
0B123D 1A          0137*   	ld	a,(de)
0B123E A6          0138*   	and	(hl)
0B123F 12          0139*   	ld	(de),a
0B1240 13          0140*   	inc	de
0B1241 23          0141*   	inc	hl
0B1242 10 F9       0142*   	djnz	andloop_24
0B1244 2A 94 12 0B 0143*   	ld	hl,(bitbuf2)
0B1248 C1          0144*   	pop		bc	;restore BC
0B1249 D1          0145*   	pop		de	;restore DE
0B124A             0146*   
0B124A             0147*   ;------------------------------------------------------------------------
0B124A             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0B124A             0149*   ; Returns: hlu = hlu XOR deu
0B124A             0150*   ; preserves all other registers
0B124A             0151*   ;------------------------------------------------------------------------
0B124A             0152*   xor_hlu_deu:
0B124A 22 91 12 0B 0153*   	ld	(bitbuf1),hl
0B124E ED 53 94 12 0154*   	ld	(bitbuf2),de
       0B          
0B1253 D5          0155*   	push	de	;preserve DEU
0B1254 C5          0156*   	push	bc	;preserve BCU
0B1255 06 03       0157*   	ld		b,3
0B1257 21 91 12 0B 0158*   	ld	hl,bitbuf1
0B125B 11 91 12 0B 0159*   	ld	de,bitbuf1
0B125F             0160*   xorloop_24:
0B125F 1A          0161*   	ld	a,(de)
0B1260 AE          0162*   	xor	(hl)
0B1261 12          0163*   	ld	(de),a
0B1262 13          0164*   	inc	de
0B1263 23          0165*   	inc	hl
0B1264 10 F9       0166*   	djnz	xorloop_24
0B1266 2A 94 12 0B 0167*   	ld	hl,(bitbuf2)
0B126A C1          0168*   	pop		bc	;restore BC
0B126B D1          0169*   	pop		de	;restore DE
0B126C             0170*   
0B126C             0171*   ;------------------------------------------------------------------------
0B126C             0172*   ; shl_hlu: 24 bit shift left hlu by deu positions
0B126C             0173*   ; Returns: hlu = hlu << deu
0B126C             0174*   ;		   de = 0
0B126C             0175*   ; NOTE: only considers deu up to 16 bits.
0B126C             0176*   ; preserves all other registers
0B126C             0177*   ;------------------------------------------------------------------------
0B126C             0178*   shl_hlu:
0B126C 7A          0179*   	ld		a,d		;up to 16 bit.
0B126D B3          0180*   	or		e
0B126E C8          0181*   	ret		z		;we're done
0B126F 29          0182*   	add		hl,hl	;shift HLU left
0B1270 1B          0183*   	dec		de
0B1271 18 F9       0184*   	jr		shl_hlu
0B1273             0185*   
0B1273             0186*   ;------------------------------------------------------------------------
0B1273             0187*   ; shr_hlu: 24 bit shift right hlu by deu positions
0B1273             0188*   ; Returns: hlu = hlu >> deu
0B1273             0189*   ;		   de = 0
0B1273             0190*   ; NOTE: only considers deu up to 16 bits.
0B1273             0191*   ; preserves all other registers
0B1273             0192*   ;------------------------------------------------------------------------
0B1273             0193*   shr_hlu:
0B1273 22 91 12 0B 0194*   	ld		(bitbuf1),hl
0B1277 21 93 12 0B 0195*   	ld		hl,bitbuf1+2
0B127B             0196*   shr_loop:
0B127B 7A          0197*   	ld		a,d		;up to 16 bit.
0B127C B3          0198*   	or		e
0B127D 28 0D       0199*   	jr		z,shr_done		;we're done
0B127F             0200*   ;carry is clear from or instruction
0B127F CB 1E       0201*   	rr		(hl)
0B1281 2B          0202*   	dec		hl
0B1282 CB 1E       0203*   	rr		(hl)
0B1284 2B          0204*   	dec		hl
0B1285 CB 1E       0205*   	rr		(hl)
0B1287 23          0206*   	inc		hl
0B1288 23          0207*   	inc		hl
0B1289 1B          0208*   	dec		de
0B128A 18 EF       0209*   	jr		shr_loop
0B128C             0210*   shr_done:
0B128C 2A 91 12 0B 0211*   	ld		hl,(bitbuf1)	;collect result
0B1290 C9          0212*   	ret
0B1291             0213*   
0B1291             0214*   ;------------------------------------------------------------------------
0B1291             0215*   ; Scratch area for calculations
0B1291             0216*   ;------------------------------------------------------------------------
0B1291 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
0B1294 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
0B1297             0183    	include "maths.inc"
0B1297             0001*   ;------------------------------------------------------------------------
0B1297             0002*   ; Scratch area for calculations
0B1297             0003*   ;------------------------------------------------------------------------
0B1297 00 00 00    0004*   scratch1: dw24 0 ;bit manipulation buffer 1
0B129A 00 00 00    0005*   scratch2: dw24 0 ;bit manipulation buffer 2
0B129D             0006*   
0B129D             0007*   ; absolute value of hlu
0B129D             0008*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B129D             0009*   ;         s1,z0,pv0,n1,c0 if hlu was negative
0B129D             0010*   ;         s0,z1,pv0,n1,c0 if hlu was zero
0B129D             0011*   ;         s0,z0,pv0,n1,c0 if hlu was positive
0B129D             0012*   ; destroys: a
0B129D             0013*   hlu_abs:
0B129D 19          0014*       add hl,de
0B129E B7          0015*       or a
0B129F ED 52       0016*       sbc hl,de
0B12A1 FA A6 12 0B 0017*       jp m,@is_neg
0B12A5 C9          0018*       ret ; hlu is positive or zero so we're done
0B12A6             0019*   @is_neg:
0B12A6 F5          0020*       push af ; otherwise, save current flags for return
0B12A7 CD AD 12 0B 0021*       call neg_hlu ; negate hlu
0B12AB F1          0022*       pop af ; get back flags
0B12AC C9          0023*       ret
0B12AD             0024*   
0B12AD             0025*   ; flip the sign of hlu
0B12AD             0026*   ; inputs: hlu
0B12AD             0027*   ; returns: 0-hlu, flags set appropriately for the result:
0B12AD             0028*   ;         s1,z0,pv0,n1,c1 if result is negative
0B12AD             0029*   ;         s0,z1,pv0,n1,c0 if result is zero
0B12AD             0030*   ;         s0,z0,pv0,n1,c1 if result is positive
0B12AD             0031*   ; destroys a
0B12AD             0032*   neg_hlu:
0B12AD D5          0033*       push de ; save de
0B12AE EB          0034*       ex de,hl ; put hl into de
0B12AF 21 00 00 00 0035*       ld hl,0 ; clear hl
0B12B3 AF          0036*       xor a ; clear carry
0B12B4 ED 52       0037*       sbc hl,de ; 0-hlu = -hlu
0B12B6 D1          0038*       pop de ; get de back
0B12B7 C9          0039*       ret ; easy peasy
0B12B8             0040*   
0B12B8             0041*   ;------------------------------------------------------------------------
0B12B8             0042*   ; divide hlu by 2, inspired by above
0B12B8             0043*   ;------------------------------------------------------------------------
0B12B8             0044*   hlu_div2:
0B12B8 22 97 12 0B 0045*       ld (scratch1),hl
0B12BC 21 99 12 0B 0046*       ld hl,scratch1+2
0B12C0 CB 1E       0047*       rr (hl)
0B12C2 2B          0048*       dec hl
0B12C3 CB 1E       0049*       rr (hl)
0B12C5 2B          0050*       dec hl
0B12C6 CB 1E       0051*       rr (hl)
0B12C8 23          0052*       inc hl
0B12C9 23          0053*       inc hl
0B12CA 2A 97 12 0B 0054*       ld hl,(scratch1)
0B12CE C9          0055*       ret
0B12CF             0056*   
0B12CF             0057*   ; this is my little hack to divide by 16
0B12CF             0058*   hlu_div16:
0B12CF AF          0059*       xor a
0B12D0 29          0060*       add hl,hl
0B12D1 17          0061*       rla
0B12D2 29          0062*       add hl,hl
0B12D3 17          0063*       rla
0B12D4 29          0064*       add hl,hl
0B12D5 17          0065*       rla
0B12D6 29          0066*       add hl,hl
0B12D7 17          0067*       rla
0B12D8 22 E5 12 0B 0068*       ld (@scratch),hl
0B12DC 32 E8 12 0B 0069*       ld (@scratch+3),a
0B12E0 2A E6 12 0B 0070*       ld hl,(@scratch+1)
0B12E4 C9          0071*       ret
0B12E5             0072*   @scratch: ds 4
0B12E9             0073*   
0B12E9             0074*   ; hlu signed division by 256
0B12E9             0075*   ; returns: hlu / 256
0B12E9             0076*   ; destroys: af
0B12E9             0077*   hlu_sdiv256:
       FF FF FF FF 
0B12E9 AF          0078*       xor a ; assume hl is positive
0B12EA 22 00 13 0B 0079*       ld (@buffer),hl
0B12EE             0080*       SIGN_HLU
                       M1 Args: none
0B12EE 19          0001*M1     add hl,de ; 1 cycle
0B12EF B7          0002*M1     or a ; clear flags ; 1 cycle
0B12F0 ED 52       0003*M1     sbc hl,de ; 2 cycles
0B12F2             0004*M1     ; 4 cycles total
0B12F2 F2 F7 12 0B 0081*       jp p,@hl_pos
0B12F6 3D          0082*       dec a
0B12F7             0083*   @hl_pos:
0B12F7 32 03 13 0B 0084*       ld (@buffer+3),a
0B12FB 2A 01 13 0B 0085*       ld hl,(@buffer+1)
0B12FF C9          0086*       ret
0B1300             0087*   @buffer: ds 4
0B1304             0088*   
0B1304             0089*   ; hlu 1 byte right shift, unsigned
0B1304             0090*   ; returns: hlu / 256, fractional portion in a
0B1304             0091*   ; destroys: af
0B1304             0092*   hlu_udiv256:
       FF FF FF FF 
0B1304 AF          0093*       xor a
0B1305 32 16 13 0B 0094*       ld (@buffer+3),a
0B1309 7D          0095*       ld a,l ; save the fractional portion
0B130A 22 13 13 0B 0096*       ld (@buffer),hl
0B130E 2A 14 13 0B 0097*       ld hl,(@buffer+1)
0B1312 C9          0098*       ret
0B1313             0099*   @buffer: ds 4
0B1317             0100*   
0B1317             0101*   ; floor(value,n)
0B1317             0102*   ; inputs: hl = value to floor, de = n
0B1317             0103*   ; outputs: hl = value floored to n
0B1317             0104*   ; destroys: af, hl, bc, de
0B1317             0105*   hlu_floor:
       FF FF FF FF 
0B1317 D5          0106*       push de ; save n
0B1318 CD D7 11 0B 0107*       call udiv24 ; de = quotient, hl = remainder
0B131C E1          0108*       pop hl ; get n back (was de)
0B131D CD BE 11 0B 0109*       call umul24 ; hl = n * quotient
0B1321 C9          0110*       ret
0B1322             0111*   ; end hlu_floor
0B1322             0112*   
0B1322             0113*   ; ceil(value,n)
0B1322             0114*   ; inputs: hl = value to ceil, de = n
0B1322             0115*   ; outputs: hl = value ceiled to n
0B1322             0116*   ; destroys: af, hl, bc, de
0B1322             0117*   hlu_ceiling:
0B1322 D5          0118*       push de ; save n
0B1323 CD D7 11 0B 0119*       call udiv24 ; de = quotient, hl = remainder
0B1327             0120*       SIGN_HLU ; test remaider for zero
                       M1 Args: none
0B1327 19          0001*M1     add hl,de ; 1 cycle
0B1328 B7          0002*M1     or a ; clear flags ; 1 cycle
0B1329 ED 52       0003*M1     sbc hl,de ; 2 cycles
0B132B             0004*M1     ; 4 cycles total
0B132B CA 30 13 0B 0121*       jp z,@F ; if zero, nothing to add
0B132F 13          0122*       inc de ; add 1 to quotient for the ceiling
0B1330             0123*   @@:
0B1330 E1          0124*       pop hl ; get n back (was de)
0B1331 CD BE 11 0B 0125*       call umul24 ; hl = n * quotient
0B1335 C9          0126*       ret
0B1336             0127*   ; end hlu_ceiling
0B1336             0128*   
0B1336 C9          0129*       ret
0B1337             0130*   
0B1337 00 00 00 00 0131*   add_bcd_arg1: db #00,#00,#00,#00
0B133B 00 00 00 00 0132*   add_bcd_arg2: db #00,#00,#00,#00
0B133F             0133*   
0B133F             0134*   ; set bcd values in a scratch memory address from registers bcde
0B133F             0135*   ; input: hl; scratch address,bcde; 8-place bcd number
0B133F             0136*   ; destroys ; hl
0B133F             0137*   set_bcd:
0B133F 73          0138*       ld (hl),e
0B1340 23          0139*       inc hl
0B1341 72          0140*       ld (hl),d
0B1342 23          0141*       inc hl
0B1343 71          0142*       ld (hl),c
0B1344 23          0143*       inc hl
0B1345 70          0144*       ld (hl),b
0B1346 C9          0145*       ret
0B1347             0146*   
0B1347             0147*   ; load bcd values from a scratch memory address to bcde
0B1347             0148*   ; input: hl; scratch address
0B1347             0149*   ; output: bcde; 8-place bcd number
0B1347             0150*   ; destroys: hl
0B1347             0151*   get_bcd:
0B1347 5E          0152*       ld e,(hl)
0B1348 23          0153*       inc hl
0B1349 56          0154*       ld d,(hl)
0B134A 23          0155*       inc hl
0B134B 4E          0156*       ld c,(hl)
0B134C 23          0157*       inc hl
0B134D 46          0158*       ld b,(hl)
0B134E C9          0159*       ret
0B134F             0160*   
0B134F             0161*   ; BCD addition
0B134F             0162*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B134F             0163*   ;       a is the number of bytes holding each number (number of places/2)
0B134F             0164*   ; outputs: (hl) + (de) --> (hl)
0B134F             0165*   ; destroys: a,b,de,hl
0B134F             0166*   add_bcd:
0B134F 47          0167*       ld b,a ; loop counter
0B1350 AF          0168*       xor a ; reset a, clear carry flag
0B1351             0169*   adcec:
0B1351 1A          0170*       ld a,(de) ; addend to acc
0B1352 8E          0171*       adc a,(hl) ; add (hl) to acc
0B1353 27          0172*       daa ; adjust result to bcd
0B1354 77          0173*       ld (hl),a ; store result
0B1355 23          0174*       inc hl ; advance memory pointers
0B1356 13          0175*       inc de
0B1357 10 F8       0176*       djnz adcec ; loop until b == 0
0B1359 C9          0177*       ret
0B135A             0178*   
0B135A             0179*   ; BCD subtraction
0B135A             0180*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B135A             0181*   ;       a is the number of bytes holding each number (number of places/2)
0B135A             0182*   ; outputs: (hl) - (de) --> (hl)
0B135A             0183*   ; destroys: a,b,de,hl
0B135A             0184*   sub_bcd:
0B135A 47          0185*       ld b,a ; loop counter
0B135B AF          0186*       xor a ; reset a,clear carry flag
0B135C             0187*   subdec:
0B135C 1A          0188*       ld a,(de) ; subtrahend to acc
0B135D 9E          0189*       sbc a,(hl) ; subtract (hl) from acc
0B135E 27          0190*       daa ; adjust result to bcd
0B135F 77          0191*       ld (hl),a ; store result
0B1360 23          0192*       inc hl ; advance memory pointers
0B1361 13          0193*       inc de
0B1362 10 F8       0194*       djnz subdec ; loop until b == 0
0B1364 C9          0195*       ret
0B1365             0196*   
0B1365             0197*   ; http://www.z80.info/pseudo-random.txt
0B1365             0198*   rand_8:
0B1365 C5          0199*       push bc
0B1366 3A 79 13 0B 0200*       ld a,(r_seed)
0B136A 4F          0201*       ld c,a
0B136B             0202*   
0B136B 0F          0203*       rrca ; multiply by 32
0B136C 0F          0204*       rrca
0B136D 0F          0205*       rrca
0B136E EE 1F       0206*       xor 0x1f
0B1370             0207*   
0B1370 81          0208*       add a,c
0B1371 DE FF       0209*       sbc a,255 ; carry
0B1373             0210*   
0B1373 32 79 13 0B 0211*       ld (r_seed),a
0B1377 C1          0212*       pop bc
0B1378 C9          0213*       ret
0B1379 50          0214*   r_seed: defb $50
0B137A             0215*   
0B137A             0216*   ; https://www.omnimaga.org/asm-language/ez80-optimized-routines/msg399325/#msg399325
0B137A             0217*   prng24:
0B137A             0218*   ;;Expects ADL mode.
0B137A             0219*   ;;Output: HL
0B137A             0220*   ;;50cc
0B137A             0221*   ;;33 bytes
0B137A             0222*   ;;cycle length: 281,474,959,933,440 (about 2.8 trillion)
0B137A ED 5B 9B 13 0223*       ld de,(seed1)
       0B          
0B137F B7          0224*       or a
0B1380 ED 62       0225*       sbc hl,hl
0B1382 19          0226*       add hl,de
0B1383 29          0227*       add hl,hl
0B1384 29          0228*       add hl,hl
0B1385 2C          0229*       inc l
0B1386 19          0230*       add hl,de
0B1387 22 9B 13 0B 0231*       ld (seed1),hl
0B138B 2A 9E 13 0B 0232*       ld hl,(seed2)
0B138F 29          0233*       add hl,hl
0B1390 9F          0234*       sbc a,a
0B1391 E6 1B       0235*       and %00011011
0B1393 AD          0236*       xor l
0B1394 6F          0237*       ld l,a
0B1395 22 9E 13 0B 0238*       ld (seed2),hl
0B1399 19          0239*       add hl,de
0B139A C9          0240*       ret
0B139B 00 00 00    0241*   seed1: dl 0
0B139E 00 00 00    0242*   seed2: dl 0
0B13A1             0243*   
0B13A1             0244*   
0B13A1             0245*   ; https://map.grauw.nl/sources/external/z80bits.html#2.1
0B13A1             0246*   ; h / l -> h, remain a
0B13A1             0247*   ; 2.1 Restoring 8-bit / 8-bit Unsigned
0B13A1             0248*   ; Input: H = Dividend, L = Divisor, A = 0
0B13A1             0249*   ; Output: H = Quotient, A = Remainder, L = Divisor (unchanged)
0B13A1             0250*   udiv8:
0B13A1 AF          0251*       xor a
0B13A2 06 08       0252*       ld b,8
0B13A4             0253*   @loop:
0B13A4 CB 24       0254*       sla h
0B13A6 17          0255*       rla
0B13A7 BD          0256*       cp l
0B13A8 38 02       0257*       jr c,$+4
0B13AA 95          0258*       sub l
0B13AB 24          0259*       inc h
0B13AC 10 F6       0260*       djnz @loop
0B13AE C9          0261*       ret
0B13AF             0262*   
0B13AF             0263*   ; https://www.omnimaga.org/asm-language/(z80)-32-bit-by-16-bits-division-and-32-bit-square-root/msg406903/#msg406903
0B13AF             0264*   ; This divides HLIX by BC
0B13AF             0265*   ; The result is stored in HLIX, the remainder in DE
0B13AF             0266*   ; BC is unmodified
0B13AF             0267*   ; A is 0
0B13AF             0268*   udiv3216:
0B13AF 11 00 00 00 0269*       ld de,0		; 10
0B13B3 3E 20       0270*       ld a,32		; 7
0B13B5             0271*   @loop:
0B13B5 52 DD 29    0272*       add.s ix,ix		; 15
0B13B8 52 ED 6A    0273*       adc.s hl,hl		; 15
0B13BB EB          0274*       ex de,hl		; 4
0B13BC 52 ED 6A    0275*       adc.s hl,hl		; 15
0B13BF B7          0276*       or a			; 4
0B13C0 52 ED 42    0277*       sbc.s hl,bc		; 15
0B13C3 52 DD 23    0278*       inc.s ix		; 10
0B13C6 30 05       0279*       jr nc,@cansub		; 12/7
0B13C8 52 09       0280*       add.s hl,bc		; 11
0B13CA 52 DD 2B    0281*       dec.s ix		; 10
0B13CD             0282*   @cansub:
0B13CD EB          0283*       ex de,hl		; 4
0B13CE 3D          0284*       dec a		; 4
0B13CF 20 E4       0285*       jr nz,@loop	; 12/7
0B13D1 C9          0286*       ret			; 10
0B13D2             0287*   ; end udiv3216
0B13D2             0288*   
0B13D2             0289*   ; https://discord.com/channels/1158535358624039014/1282290921815408681/1329274504022720512
0B13D2             0290*   ; calc84maniac's 32-bit by 23-bit division routine
0B13D2             0291*   ; This divides AUIX by UDE (maximum 23 bits)
0B13D2             0292*   ; The result is stored in AUIX, the remainder in UHL
0B13D2             0293*   ; UDE, C are unmodified
0B13D2             0294*   ; B is 0
0B13D2             0295*   udiv3223:
0B13D2 B7          0296*       or a,a         ; 1
0B13D3 ED 62       0297*       sbc hl,hl      ; 2
0B13D5 06 20       0298*       ld b,32        ; 2
0B13D7             0299*   @loop:
0B13D7 DD 29       0300*       add ix,ix      ; 2
0B13D9 8F          0301*       adc a,a        ; 1
0B13DA ED 6A       0302*       adc hl,hl      ; 2
0B13DC ED 52       0303*       sbc hl,de      ; 2
0B13DE DD 23       0304*       inc ix         ; 2
0B13E0 30 03       0305*       jr nc,@cansub  ; 2/4
0B13E2 19          0306*       add hl,de      ; 1
0B13E3 DD 2B       0307*       dec ix         ; 2
0B13E5             0308*   @cansub:
0B13E5 10 F0       0309*       djnz @loop     ; 2/4
0B13E7 C9          0310*       ret            ; 10
0B13E8             0311*   ; end udiv3223
0B13E8             0312*   
0B13E8             0313*   ; calc84maniac https://discord.com/channels/1158535358624039014/1282290921815408681/1330991583369101322
0B13E8             0314*   ; add uhl to signed integer a
0B13E8             0315*   add_uhl_a_signed:
0B13E8 D5          0316*       push de    ; 4 cycles
0B13E9 EB          0317*       ex de, hl  ; 1 cycle  UDE = UHL
0B13EA 07          0318*       rlca       ; 1 cycle  CF = signbit(A)
0B13EB ED 62       0319*       sbc hl, hl ; 2 cycles UHL = -signbit(A)
0B13ED 0F          0320*       rrca       ; 1 cycle  Restore A
0B13EE 6F          0321*       ld l, a    ; 1 cycle  UHL = signext(A)
0B13EF 19          0322*       add hl, de ; 1 cycle  UHL = UDE + signext(A)
0B13F0 D1          0323*       pop de     ; 4 cycles
0B13F1             0324*                  ; 15 cycles total
0B13F1 C9          0325*       ret
0B13F2             0326*   ; end hlu_add_a_signed
0B13F2             0184        include "fpp_ext.inc"
0B13F2             0001*   ; integer operations
0B13F2             0002*   iand:	EQU 58	; AND (INTEGER)
0B13F2             0003*   ibdiv:	EQU 59	; DIV
0B13F2             0004*   ieor:	EQU 60	; EOR
0B13F2             0005*   imod:	EQU 61	; MOD
0B13F2             0006*   ior:	EQU 62	; OR
0B13F2             0007*   ile:	EQU 63	; <=
0B13F2             0008*   ine:	EQU 64	; <>
0B13F2             0009*   ige:	EQU 65	; >=
0B13F2             0010*   ilt:	EQU 66	; <
0B13F2             0011*   ieq:	EQU 67	; =
0B13F2             0012*   imul:	EQU 68	; *
0B13F2             0013*   iadd:	EQU 69	; +
0B13F2             0014*   igt:	EQU 70	; >
0B13F2             0015*   isub:	EQU 71	; -
0B13F2             0016*   ipow:	EQU 72	; ^
0B13F2             0017*   idiv:	EQU 73	; /
0B13F2             0018*   ;
0B13F2             0019*   ; floating point functions
0B13F2             0020*   absv:	EQU 16	; ABS
0B13F2             0021*   acs:	EQU 17	; ACS
0B13F2             0022*   asn:	EQU 18	; ASN
0B13F2             0023*   atn:	EQU 19	; ATN
0B13F2             0024*   cos:	EQU 20	; COS
0B13F2             0025*   deg:	EQU 21	; DEG
0B13F2             0026*   exp:	EQU 22	; EXP
0B13F2             0027*   int_:	EQU 23	; INT
0B13F2             0028*   ln:	    EQU 24	; LN
0B13F2             0029*   log:	EQU 25	; LOG
0B13F2             0030*   notk:	EQU 26	; NOT
0B13F2             0031*   rad:	EQU 27	; RAD
0B13F2             0032*   sgn:	EQU 28	; SGN
0B13F2             0033*   sin:	EQU 29	; SIN
0B13F2             0034*   sqr:	EQU 30	; SQR
0B13F2             0035*   tan:	EQU 31	; TAN
0B13F2             0036*   zero:	EQU 32	; ZERO
0B13F2             0037*   fone:	EQU 33	; FONE
0B13F2             0038*   true:	EQU 34	; TRUE
0B13F2             0039*   pi:	    EQU 35	; PI
0B13F2             0040*   val:	EQU 36	; VAL
0B13F2             0041*   str:	EQU 37	; STR$
0B13F2             0042*   sfix:	EQU 38	; FIX
0B13F2             0043*   sfloat:	EQU 39	; FLOAT
0B13F2             0044*   ftest:	EQU 40	; TEST
0B13F2             0045*   fcomp:	EQU 41	; COMPARE
0B13F2             0046*   ;
0B13F2             0047*   ; floating point operations
0B13F2             0048*   fand:	EQU  0	; AND (FLOATING-POINT)
0B13F2             0049*   fbdiv:	EQU  1	; DIV
0B13F2             0050*   feor:	EQU  2	; EOR
0B13F2             0051*   fmod:	EQU  3	; MOD
0B13F2             0052*   ffor:	EQU  4	; OR
0B13F2             0053*   fle:	EQU  5	; <=
0B13F2             0054*   fne:	EQU  6	; <>
0B13F2             0055*   fge:	EQU  7	; >=
0B13F2             0056*   flt:	EQU  8	; <
0B13F2             0057*   feq:	EQU  9	; =
0B13F2             0058*   fmul:	EQU 10	; *
0B13F2             0059*   fadd:	EQU 11	; +
0B13F2             0060*   fgt:	EQU 12	; >
0B13F2             0061*   fsub:	EQU 13	; -
0B13F2             0062*   fpow:	EQU 14	; ^
0B13F2             0063*   fdiv:	EQU 15	; /
0B13F2             0064*   
0B13F2             0065*       MACRO LOAD_FLOAT ARG
0B13F2             0066*       ld ix,$+11
0B13F2             0067*       call val_fp ; convert the string to a float
0B13F2             0068*       jp (ix)
0B13F2             0069*       asciz ARG
0B13F2             0070*       ENDMACRO
0B13F2             0071*   
0B13F2             0072*   ; --- originally in eval.asm ---
0B13F2             0073*   ;SWAP - Swap arguments
0B13F2             0074*   ;Exchanges DE,HL D'E',H'L' and B,C
0B13F2             0075*   ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B13F2             0076*   ;
0B13F2 79          0077*   SWAP:			LD      A,C
0B13F3 48          0078*   			LD      C,B
0B13F4 47          0079*   			LD      B,A
0B13F5 EB          0080*   			EX      DE,HL
0B13F6 D9          0081*   			EXX
0B13F7 EB          0082*   			EX      DE,HL
0B13F8 D9          0083*   			EXX
0B13F9 C9          0084*   			RET
0B13FA             0085*   
0B13FA             0086*   ; same as VAL_FP in fpp.asm, but preserves any float stored in DED'E'B
0B13FA             0087*   val_fp:
0B13FA FD E5       0088*       push iy ; preserve
0B13FC FD 21 17 14 0089*       ld iy,@val
       0B          
0B1401 CD 12 15 0B 0090*       call store_float_iy_alt
0B1405 3E 24       0091*       ld a,val
0B1407 CD D2 00 0B 0092*       call FPP ; string converted to float in HLH'L'C
0B140B FD 21 17 14 0093*       ld iy,@val
       0B          
0B1410 CD 24 15 0B 0094*       call fetch_float_iy_alt
0B1414 FD E1       0095*       pop iy ; restore
0B1416 C9          0096*       ret
0B1417             0097*   @val: ds 5
0B141C             0098*   
0B141C             0099*   ; same as INT_FP_ in fpp.asm but preserves B, which keeps any float stored in DED'E'B intact
0B141C             0100*   ; af will also return differently from the original
0B141C             0101*   ;INT - Floor function
0B141C             0102*   ;Result is integer numeric.
0B141C             0103*   ;
0B141C             0104*   int_fp_:
       FF FF FF FF 
       FF 
0B141C C5          0105*       push bc ; preserve b
0B141D 3E 17       0106*       ld a,int_
0B141F CD D2 00 0B 0107*       call FPP
0B1423 F1          0108*       pop af ; restore b to a
0B1424 47          0109*       ld b,a ; restore b
0B1425 C9          0110*       RET
0B1426             0111*   
0B1426             0112*   ; convert floating point number to integer and store it in HLU
0B1426             0113*   ; inputs: HLH'L'C = floating point number
0B1426             0114*   ; outputs: HLU = integer part of the number
0B1426             0115*   ; destroys: all except DEU and U'D'E'B, index registers
0B1426             0116*   int2hlu:
0B1426 CD 1C 14 0B 0117*       call int_fp_
0B142A 7D          0118*       ld a,l
0B142B F5          0119*       push af
0B142C D9          0120*       exx
0B142D E5          0121*       push hl
0B142E D9          0122*       exx
0B142F E1          0123*       pop hl
0B1430 F1          0124*       pop af
0B1431             0125*       A_TO_HLU
                       M1 Args: none
0B1431 AF          0001*M1     xor a ; 1 cycle
0B1432 22 3B 14 0B 0002*M1     ld ($+8+1),hl ; 7 cycles
0B1436 32 3D 14 0B 0003*M1     ld ($+4+3),a ; 5 cycles
0B143A 21 00 00 00 0004*M1     ld hl,0x000000 ; 4 cycles
0B143E             0005*M1     ; 17 cycles total
0B143E C9          0126*       ret
0B143F             0127*   
0B143F             0128*   ; convert polar coordinates to cartesian coordinates as deltas from the origin
0B143F             0129*   ; inputs: HLH'L'C = angle in radians
0B143F             0130*   ;         DED'E'B = radius
0B143F             0131*   ; outputs: HLH'L'C = dx
0B143F             0132*   ;          DED'E'B = dy
0B143F             0133*   polar_to_cartesian_fpp:
0B143F             0134*   ; store input parameters in scratch
0B143F FD 21 97 14 0135*       ld iy,@angle
       0B          
0B1444 CD EE 14 0B 0136*       call store_float_iy_nor
0B1448 FD 21 9C 14 0137*       ld iy,@radius
       0B          
0B144D CD 12 15 0B 0138*       call store_float_iy_alt
0B1451             0139*   ; compute dy = sin(angle) * radius
0B1451 3E 1D       0140*       ld a,sin
0B1453 CD D2 00 0B 0141*       call FPP ; HLH'L'C = sin(angle)
0B1457 FD 21 9C 14 0142*       ld iy,@radius
       0B          
0B145C CD 24 15 0B 0143*       call fetch_float_iy_alt ; DED'E'B = radius
0B1460 3E 0A       0144*       ld a,fmul
0B1462 CD D2 00 0B 0145*       call FPP ; HLH'L'C = sin(angle) * radius
0B1466 FD 21 A1 14 0146*       ld iy,@scratch
       0B          
0B146B CD EE 14 0B 0147*       call store_float_iy_nor ; @scratch = dy
0B146F             0148*   ; compute dx = cos(angle) * radius
0B146F FD 21 97 14 0149*       ld iy,@angle
       0B          
0B1474 CD 00 15 0B 0150*       call fetch_float_iy_nor
0B1478 3E 14       0151*       ld a,cos
0B147A CD D2 00 0B 0152*       call FPP ; HLH'L'C = cos(angle)
0B147E FD 21 9C 14 0153*       ld iy,@radius
       0B          
0B1483 CD 24 15 0B 0154*       call fetch_float_iy_alt ; DED'E'B = radius
0B1487 3E 0A       0155*       ld a,fmul
0B1489 CD D2 00 0B 0156*       call FPP ; HLH'L'C = cos(angle) * radius
0B148D             0157*   ; restore dy from @scratch
0B148D FD 21 A1 14 0158*       ld iy,@scratch
       0B          
0B1492 CD 24 15 0B 0159*       call fetch_float_iy_alt
0B1496 C9          0160*       ret
0B1497             0161*   @angle: ds 5
0B149C             0162*   @radius: ds 5
0B14A1             0163*   @scratch: ds 5
0B14A6             0164*   
0B14A6             0165*   ; store HLH'L'C floating point number in a 40-bit buffer
0B14A6             0166*   ; inputs: HLH'L'C = floating point number
0B14A6             0167*   ;         ix = buffer address
0B14A6             0168*   ; outputs: buffer filled with floating point number
0B14A6             0169*   ; destroys: nothing
0B14A6             0170*   store_float_nor:
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF 
0B14A6 DD 71 00    0171*       ld (ix+0),c
0B14A9 D9          0172*       exx
0B14AA DD 75 03    0173*       ld (ix+3),l
0B14AD DD 74 04    0174*       ld (ix+4),h
0B14B0 D9          0175*       exx
0B14B1 DD 75 01    0176*       ld (ix+1),l
0B14B4 DD 74 02    0177*       ld (ix+2),h
0B14B7 C9          0178*       ret
0B14B8             0179*   
0B14B8             0180*   ; fetch HLH'L'C floating point number from a 40-bit buffer
0B14B8             0181*   ; inputs: ix = buffer address
0B14B8             0182*   ; outputs: HLH'L'C = floating point number
0B14B8             0183*   ; destroys: HLH'L'C
0B14B8             0184*   fetch_float_nor:
0B14B8 DD 4E 00    0185*       ld c,(ix+0)
0B14BB D9          0186*       exx
0B14BC DD 6E 03    0187*       ld l,(ix+3)
0B14BF DD 66 04    0188*       ld h,(ix+4)
0B14C2 D9          0189*       exx
0B14C3 DD 6E 01    0190*       ld l,(ix+1)
0B14C6 DD 66 02    0191*       ld h,(ix+2)
0B14C9 C9          0192*       ret
0B14CA             0193*   
0B14CA             0194*   ; store DED'E'B floating point number in a 40-bit buffer
0B14CA             0195*   ; inputs: DED'E'B = floating point number
0B14CA             0196*   ;         ix = buffer address
0B14CA             0197*   ; outputs: buffer filled with floating point number
0B14CA             0198*   ; destroys: nothing
0B14CA             0199*   store_float_alt:
0B14CA DD 70 00    0200*       ld (ix+0),b
0B14CD D9          0201*       exx
0B14CE DD 73 03    0202*       ld (ix+3),e
0B14D1 DD 72 04    0203*       ld (ix+4),d
0B14D4 D9          0204*       exx
0B14D5 DD 73 01    0205*       ld (ix+1),e
0B14D8 DD 72 02    0206*       ld (ix+2),d
0B14DB C9          0207*       ret
0B14DC             0208*   
0B14DC             0209*   ; fetch DED'E'B floating point number from a 40-bit buffer
0B14DC             0210*   ; inputs: ix = buffer address
0B14DC             0211*   ; outputs: DED'E'B = floating point number
0B14DC             0212*   ; destroys: DED'E'B
0B14DC             0213*   fetch_float_alt:
0B14DC DD 46 00    0214*       ld b,(ix+0)
0B14DF D9          0215*       exx
0B14E0 DD 5E 03    0216*       ld e,(ix+3)
0B14E3 DD 56 04    0217*       ld d,(ix+4)
0B14E6 D9          0218*       exx
0B14E7 DD 5E 01    0219*       ld e,(ix+1)
0B14EA DD 56 02    0220*       ld d,(ix+2)
0B14ED C9          0221*       ret
0B14EE             0222*   
0B14EE             0223*   
0B14EE             0224*   ; store HLH'L'C floating point number in a 40-bit buffer
0B14EE             0225*   ; inputs: HLH'L'C = floating point number
0B14EE             0226*   ;         iy = buffer address
0B14EE             0227*   ; outputs: buffer filled with floating point number
0B14EE             0228*   ; destroys: nothing
0B14EE             0229*   store_float_iy_nor:
0B14EE FD 71 00    0230*       ld (iy+0),c
0B14F1 D9          0231*       exx
0B14F2 FD 75 03    0232*       ld (iy+3),l
0B14F5 FD 74 04    0233*       ld (iy+4),h
0B14F8 D9          0234*       exx
0B14F9 FD 75 01    0235*       ld (iy+1),l
0B14FC FD 74 02    0236*       ld (iy+2),h
0B14FF C9          0237*       ret
0B1500             0238*   
0B1500             0239*   ; fetch HLH'L'C floating point number from a 40-bit buffer
0B1500             0240*   ; inputs: iy = buffer address
0B1500             0241*   ; outputs: HLH'L'C = floating point number
0B1500             0242*   ; destroys: HLH'L'C
0B1500             0243*   fetch_float_iy_nor:
0B1500 FD 4E 00    0244*       ld c,(iy+0)
0B1503 D9          0245*       exx
0B1504 FD 6E 03    0246*       ld l,(iy+3)
0B1507 FD 66 04    0247*       ld h,(iy+4)
0B150A D9          0248*       exx
0B150B FD 6E 01    0249*       ld l,(iy+1)
0B150E FD 66 02    0250*       ld h,(iy+2)
0B1511 C9          0251*       ret
0B1512             0252*   
0B1512             0253*   ; store DED'E'B floating point number in a 40-bit buffer
0B1512             0254*   ; inputs: DED'E'B = floating point number
0B1512             0255*   ;         iy = buffer address
0B1512             0256*   ; outputs: buffer filled with floating point number
0B1512             0257*   ; destroys: nothing
0B1512             0258*   store_float_iy_alt:
0B1512 FD 70 00    0259*       ld (iy+0),b
0B1515 D9          0260*       exx
0B1516 FD 73 03    0261*       ld (iy+3),e
0B1519 FD 72 04    0262*       ld (iy+4),d
0B151C D9          0263*       exx
0B151D FD 73 01    0264*       ld (iy+1),e
0B1520 FD 72 02    0265*       ld (iy+2),d
0B1523 C9          0266*       ret
0B1524             0267*   
0B1524             0268*   ; fetch DED'E'B floating point number from a 40-bit buffer
0B1524             0269*   ; inputs: iy = buffer address
0B1524             0270*   ; outputs: DED'E'B = floating point number
0B1524             0271*   ; destroys: DED'E'B
0B1524             0272*   fetch_float_iy_alt:
0B1524 FD 46 00    0273*       ld b,(iy+0)
0B1527 D9          0274*       exx
0B1528 FD 5E 03    0275*       ld e,(iy+3)
0B152B FD 56 04    0276*       ld d,(iy+4)
0B152E D9          0277*       exx
0B152F FD 5E 01    0278*       ld e,(iy+1)
0B1532 FD 56 02    0279*       ld d,(iy+2)
0B1535 C9          0280*       ret
0B1536             0281*   
0B1536             0282*   ; store HLH'L'C integer number in a 32-bit buffer
0B1536             0283*   ; inputs: HLH'L'C = integer number
0B1536             0284*   ;         ix = buffer address
0B1536             0285*   ; outputs: buffer filled with integer number
0B1536             0286*   ; destroys: nothing
0B1536             0287*   store_int_nor:
0B1536 D9          0288*       exx
0B1537 DD 75 00    0289*       ld (ix+0),l
0B153A DD 74 01    0290*       ld (ix+1),h
0B153D D9          0291*       exx
0B153E DD 75 02    0292*       ld (ix+2),l
0B1541 DD 74 03    0293*       ld (ix+3),h
0B1544 C9          0294*       ret
0B1545             0295*   
0B1545             0296*   ; fetch HLH'L'C integer number from a 32-bit buffer
0B1545             0297*   ; inputs: ix = buffer address
0B1545             0298*   ; outputs: HLH'L'C = integer number
0B1545             0299*   ; destroys: HLH'L'C
0B1545             0300*   fetch_int_nor:
0B1545 D9          0301*       exx
0B1546 DD 6E 00    0302*       ld l,(ix+0)
0B1549 DD 66 01    0303*       ld h,(ix+1)
0B154C D9          0304*       exx
0B154D DD 6E 02    0305*       ld l,(ix+2)
0B1550 DD 66 03    0306*       ld h,(ix+3)
0B1553 0E 00       0307*       ld c,0 ; set exponent to 0
0B1555 C9          0308*       ret
0B1556             0309*   
0B1556             0310*   ; store DED'E'B integer number in a 32-bit buffer
0B1556             0311*   ; inputs: DED'E'B = integer number
0B1556             0312*   ;         ix = buffer address
0B1556             0313*   ; outputs: buffer filled with integer number
0B1556             0314*   ; destroys: nothing
0B1556             0315*   store_int_alt:
0B1556             0316*   
0B1556 DD 73 00    0317*       ld (ix+0),e
0B1559 DD 72 01    0318*       ld (ix+1),d
0B155C D9          0319*       exx
0B155D DD 73 02    0320*       ld (ix+2),e
0B1560 DD 72 03    0321*       ld (ix+3),d
0B1563 C9          0322*       ret
0B1564             0323*   
0B1564             0324*   ; fetch DED'E'B integer number from a 32-bit buffer
0B1564             0325*   ; inputs: ix = buffer address
0B1564             0326*   ; outputs: DED'E'B = integer number
0B1564             0327*   ; destroys: DED'E'B
0B1564             0328*   fetch_int_alt:
0B1564 D9          0329*       exx
0B1565 DD 5E 00    0330*       ld e,(ix+0)
0B1568 DD 56 01    0331*       ld d,(ix+1)
0B156B D9          0332*       exx
0B156C DD 5E 02    0333*       ld e,(ix+2)
0B156F DD 56 03    0334*       ld d,(ix+3)
0B1572 06 00       0335*       ld b,0 ; set exponent to 0
0B1574 C9          0336*       ret
0B1575             0337*   
0B1575             0338*   ; store HLH'L'C integer number in a 32-bit buffer
0B1575             0339*   ; inputs: HLH'L'C = integer number
0B1575             0340*   ;         iy = buffer address
0B1575             0341*   ; outputs: buffer filled with integer number
0B1575             0342*   ; destroys: nothing
0B1575             0343*   store_int_iy_nor:
0B1575 D9          0344*       exx
0B1576 FD 75 00    0345*       ld (iy+0),l
0B1579 FD 74 01    0346*       ld (iy+1),h
0B157C D9          0347*       exx
0B157D FD 75 02    0348*       ld (iy+2),l
0B1580 FD 74 03    0349*       ld (iy+3),h
0B1583 C9          0350*       ret
0B1584             0351*   
0B1584             0352*   ; fetch HLH'L'C integer number from a 32-bit buffer
0B1584             0353*   ; inputs: iy = buffer address
0B1584             0354*   ; outputs: HLH'L'C = integer number
0B1584             0355*   ; destroys: HLH'L'C
0B1584             0356*   fetch_int_iy_nor:
0B1584             0357*   
0B1584 FD 6E 00    0358*       ld l,(iy+0)
0B1587 FD 66 01    0359*       ld h,(iy+1)
0B158A D9          0360*       exx
0B158B FD 6E 02    0361*       ld l,(iy+2)
0B158E FD 66 03    0362*       ld h,(iy+3)
0B1591 0E 00       0363*       ld c,0 ; set exponent to 0
0B1593 C9          0364*       ret
0B1594             0365*   
0B1594             0366*   ; store DED'E'B integer number in a 32-bit buffer
0B1594             0367*   ; inputs: DED'E'B = integer number
0B1594             0368*   ;         iy = buffer address
0B1594             0369*   ; outputs: buffer filled with integer number
0B1594             0370*   ; destroys: nothing
0B1594             0371*   store_int_iy_alt:
0B1594 D9          0372*       exx
0B1595 FD 73 00    0373*       ld (iy+0),e
0B1598 FD 72 01    0374*       ld (iy+1),d
0B159B D9          0375*       exx
0B159C FD 73 02    0376*       ld (iy+2),e
0B159F FD 72 03    0377*       ld (iy+3),d
0B15A2 C9          0378*       ret
0B15A3             0379*   
0B15A3             0380*   ; fetch DED'E'B integer number from a 32-bit buffer
0B15A3             0381*   ; inputs: iy = buffer address
0B15A3             0382*   ; outputs: DED'E'B = integer number
0B15A3             0383*   ; destroys: DED'E'B
0B15A3             0384*   fetch_int_iy_alt:
0B15A3 D9          0385*       exx
0B15A4 FD 5E 00    0386*       ld e,(iy+0)
0B15A7 FD 56 01    0387*       ld d,(iy+1)
0B15AA D9          0388*       exx
0B15AB FD 5E 02    0389*       ld e,(iy+2)
0B15AE FD 56 03    0390*       ld d,(iy+3)
0B15B1 06 00       0391*       ld b,0 ; set exponent to 0
0B15B3 C9          0392*       ret
0B15B4             0393*   
0B15B4             0394*   ; print HLH'L'C floating point number in hex format
0B15B4             0395*   ; inputs: HLH'L'C = floating point number
0B15B4             0396*   print_float_hex_nor:
0B15B4             0397*       PUSH_ALL
                       M1 Args: none
0B15B4 08          0001*M1     ex af,af'
0B15B5 D9          0002*M1     exx
0B15B6 F5          0003*M1     push af
0B15B7 E5          0004*M1     push hl
0B15B8 C5          0005*M1     push bc
0B15B9 D5          0006*M1     push de
0B15BA             0007*M1 
0B15BA 08          0008*M1     ex af,af'
0B15BB D9          0009*M1     exx
0B15BC F5          0010*M1     push af
0B15BD E5          0011*M1     push hl
0B15BE C5          0012*M1     push bc
0B15BF D5          0013*M1     push de
0B15C0 DD E5       0014*M1     push ix
0B15C2 FD E5       0015*M1     push iy
0B15C4 C5          0398*       push bc ; preserve c
0B15C5 CD FF 0E 0B 0399*       call printHex16
0B15C9 3E 2E       0400*       ld a,'.'
0B15CB 5B D7       0401*       rst.lil 10h
0B15CD D9          0402*       exx
0B15CE CD FF 0E 0B 0403*       call printHex16
0B15D2 D9          0404*       exx
0B15D3 3E 5E       0405*       ld a,'^'
0B15D5 5B D7       0406*       rst.lil 10h
0B15D7 C1          0407*       pop bc ; restore c
0B15D8 79          0408*       ld a,c
0B15D9 CD 05 0F 0B 0409*       call printHex8
0B15DD             0410*       POP_ALL
                       M1 Args: none
0B15DD FD E1       0001*M1     pop iy
0B15DF DD E1       0002*M1     pop ix
0B15E1 D1          0003*M1     pop de
0B15E2 C1          0004*M1     pop bc
0B15E3 E1          0005*M1     pop hl
0B15E4 F1          0006*M1     pop af
0B15E5 08          0007*M1     ex af,af'
0B15E6 D9          0008*M1     exx
0B15E7             0009*M1 
0B15E7 D1          0010*M1     pop de
0B15E8 C1          0011*M1     pop bc
0B15E9 E1          0012*M1     pop hl
0B15EA F1          0013*M1     pop af
0B15EB 08          0014*M1     ex af,af'
0B15EC D9          0015*M1     exx
0B15ED C9          0411*       ret
0B15EE             0412*   
0B15EE             0413*   ; print DED'E'B floating point number in hex format
0B15EE             0414*   ; inputs: DED'E'B = floating point number
0B15EE             0415*   print_float_hex_alt:
0B15EE             0416*       PUSH_ALL
                       M1 Args: none
0B15EE 08          0001*M1     ex af,af'
0B15EF D9          0002*M1     exx
0B15F0 F5          0003*M1     push af
0B15F1 E5          0004*M1     push hl
0B15F2 C5          0005*M1     push bc
0B15F3 D5          0006*M1     push de
0B15F4             0007*M1 
0B15F4 08          0008*M1     ex af,af'
0B15F5 D9          0009*M1     exx
0B15F6 F5          0010*M1     push af
0B15F7 E5          0011*M1     push hl
0B15F8 C5          0012*M1     push bc
0B15F9 D5          0013*M1     push de
0B15FA DD E5       0014*M1     push ix
0B15FC FD E5       0015*M1     push iy
0B15FE C5          0417*       push bc ; preserve b
0B15FF EB          0418*       ex de,hl
0B1600 CD FF 0E 0B 0419*       call printHex16
0B1604 EB          0420*       ex de,hl
0B1605 3E 2E       0421*       ld a,'.'
0B1607 5B D7       0422*       rst.lil 10h
0B1609 D9          0423*       exx
0B160A EB          0424*       ex de,hl
0B160B CD FF 0E 0B 0425*       call printHex16
0B160F EB          0426*       ex de,hl
0B1610 D9          0427*       exx
0B1611 3E 5E       0428*       ld a,'^'
0B1613 5B D7       0429*       rst.lil 10h
0B1615 F1          0430*       pop af ; restore b to a
0B1616 CD 05 0F 0B 0431*       call printHex8
0B161A             0432*       POP_ALL
                       M1 Args: none
0B161A FD E1       0001*M1     pop iy
0B161C DD E1       0002*M1     pop ix
0B161E D1          0003*M1     pop de
0B161F C1          0004*M1     pop bc
0B1620 E1          0005*M1     pop hl
0B1621 F1          0006*M1     pop af
0B1622 08          0007*M1     ex af,af'
0B1623 D9          0008*M1     exx
0B1624             0009*M1 
0B1624 D1          0010*M1     pop de
0B1625 C1          0011*M1     pop bc
0B1626 E1          0012*M1     pop hl
0B1627 F1          0013*M1     pop af
0B1628 08          0014*M1     ex af,af'
0B1629 D9          0015*M1     exx
0B162A C9          0433*       ret
0B162B             0434*   
0B162B             0435*   print_floats_hex:
0B162B CD B4 15 0B 0436*       call print_float_hex_nor
0B162F 3E 20       0437*       ld a,' '
0B1631 5B D7       0438*       rst.lil 10h
0B1633 CD EE 15 0B 0439*       call print_float_hex_alt
0B1637 C9          0440*       ret
0B1638             0441*   
0B1638             0442*   ; print a floating point number in decimal format
0B1638             0443*   ; inputs: HL'H'L'C is the number to print
0B1638             0444*   ; outputs: number printed to screen
0B1638             0445*   ;          ACCS null-terminated string representation of the number
0B1638             0446*   ; destroys: everything except ix
0B1638             0447*   print_float_dec:
0B1638             0448*   print_float_dec_nor:
0B1638 DD E5       0449*       push ix             ; preserve
0B163A             0450*   
0B163A             0451*   ; back up floats in normal and alternate registers
0B163A DD 21 7B 16 0452*       ld ix,@float_nor
       0B          
0B163F CD A6 14 0B 0453*       call store_float_nor
0B1643 DD 21 80 16 0454*       ld ix,@float_alt
       0B          
0B1648 CD CA 14 0B 0455*       call store_float_alt
0B164C             0456*   
0B164C             0457*   ; convert the number to a string
0B164C 11 00 21 0B 0458*       ld de,ACCS          ; point to the string accumulator
0B1650 DD 21 78 16 0459*       ld ix,@G9-1         ; get the format code for the number
       0B          
0B1655 CD D1 08 0B 0460*       call STR_FP         ; convert the number to a string
0B1659 EB          0461*       ex de,hl            ; point to end of the string
0B165A 36 00       0462*       ld (hl),0           ; null-terminate the string
0B165C 21 00 21 0B 0463*       ld hl,ACCS          ; point to the string accumulator
0B1660 CD BE 0E 0B 0464*       call printString
0B1664             0465*   
0B1664             0466*   ; restore floats in normal and alternate registers
0B1664 DD 21 7B 16 0467*       ld ix,@float_nor
       0B          
0B1669 CD B8 14 0B 0468*       call fetch_float_nor
0B166D DD 21 80 16 0469*       ld ix,@float_alt
       0B          
0B1672 CD DC 14 0B 0470*       call fetch_float_alt
0B1676             0471*   
0B1676             0472*   ; cleanup and go home
0B1676 DD E1       0473*       pop ix              ; restore
0B1678 C9          0474*       ret
0B1679 09 00       0475*   @G9:			DW    9
0B167B             0476*   @float_nor: ds 5
0B1680             0477*   @float_alt: ds 5
0B1685             0478*   
0B1685             0479*   print_float_dec_alt:
       FF FF FF FF 
       FF FF FF FF 
       FF FF 
0B1685 CD F2 13 0B 0480*       CALL SWAP
0B1689 CD 38 16 0B 0481*       CALL print_float_dec_nor
0B168D CD F2 13 0B 0482*       CALL SWAP
0B1691 C9          0483*       ret
0B1692             0484*   
0B1692             0485*   ;PI - Return PI (3.14159265)
0B1692             0486*   ;Result is floating-point numeric.
0B1692             0487*   ;
0B1692 11 0F 49 00 0488*   pi_alt:			LD      DE,0x490F
0B1696 D9          0489*           		EXX
0B1697 11 A2 DA 00 0490*           		LD      DE,0xDAA2
0B169B D9          0491*           		EXX
0B169C 06 81       0492*           		LD      B,0x81
0B169E AF          0493*           		XOR     A               ;NUMERIC MARKER
0B169F C9          0494*           		RET
0B16A0             0495*   
0B16A0             0496*   ;PI - Return PI * 2 (6.28318531)
0B16A0             0497*   ;Result is floating-point numeric.
0B16A0             0498*   ;
0B16A0 11 0F 49 00 0499*   pi2_alt:		LD      DE,0x490F
0B16A4 D9          0500*           		EXX
0B16A5 11 A3 DA 00 0501*           		LD      DE,0xDAA3
0B16A9 D9          0502*           		EXX
0B16AA 06 82       0503*           		LD      B,0x82
0B16AC AF          0504*           		XOR     A               ;NUMERIC MARKER
0B16AD C9          0505*           		RET
0B16AE             0185        include "vdu.inc"
0B16AE             0001*   
0B16AE             0002*   ; VDU 30: Home cursor
0B16AE             0003*   vdu_home_cursor:
0B16AE 3E 1E       0004*       ld a,30
0B16B0 5B D7       0005*   	rst.lil $10
0B16B2 C9          0006*   	ret
0B16B3             0007*   
0B16B3             0008*   cursor_on:
0B16B3 21 BE 16 0B 0009*   	ld hl,@cmd
0B16B7 01 03 00 00 0010*   	ld bc,@end-@cmd
0B16BB 5B DF       0011*   	rst.lil $18
0B16BD C9          0012*   	ret
0B16BE             0013*   @cmd:
0B16BE 17 01 01    0014*   	db 23,1,1
0B16C1             0015*   @end:
0B16C1             0016*   
0B16C1             0017*   cursor_off:
0B16C1 21 CC 16 0B 0018*   	ld hl,@cmd
0B16C5 01 03 00 00 0019*   	ld bc,@end-@cmd
0B16C9 5B DF       0020*   	rst.lil $18
0B16CB C9          0021*   	ret
0B16CC             0022*   @cmd:
0B16CC 17 01 00    0023*   	db 23,1,0
0B16CF             0024*   @end:
0B16CF             0025*   
0B16CF             0026*   ; VDU 9: Move cursor forward one character
0B16CF             0027*   vdu_cursor_forward:
0B16CF 3E 09       0028*       ld a,9
0B16D1 5B D7       0029*   	rst.lil $10
0B16D3 C9          0030*   	ret
0B16D4             0031*   
0B16D4             0032*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B16D4             0033*   ; inputs: c=x, b=y 8-bit unsigned integers
0B16D4             0034*   vdu_move_cursor:
0B16D4 ED 43 E5 16 0035*       ld (@x0),bc
       0B          
0B16D9 21 E4 16 0B 0036*   	ld hl,@cmd
0B16DD 01 03 00 00 0037*   	ld bc,@end-@cmd
0B16E1 5B DF       0038*   	rst.lil $18
0B16E3 C9          0039*   	ret
0B16E4 1F          0040*   @cmd: 	db 31
0B16E5 00          0041*   @x0:	db 0
0B16E6 00          0042*   @y0: 	db 0
0B16E7 00          0043*   @end: 	db 0 ; padding
0B16E8             0044*   
0B16E8             0045*   ; VDU 12: Clear text area (CLS)
0B16E8             0046*   vdu_cls:
0B16E8 3E 0C       0047*       ld a,12
0B16EA 5B D7       0048*   	rst.lil $10
0B16EC C9          0049*   	ret
0B16ED             0050*   
0B16ED             0051*   vdu_flip:
0B16ED 21 F8 16 0B 0052*   	ld hl,@cmd
0B16F1 01 03 00 00 0053*   	ld bc,@end-@cmd
0B16F5 5B DF       0054*   	rst.lil $18
0B16F7 C9          0055*   	ret
0B16F8 17 00 C3    0056*   @cmd: db 23,0,0xC3
0B16FB             0057*   @end:
0B16FB             0058*   
0B16FB             0059*   ; VDU 16: Clear graphics area (CLG)
0B16FB             0060*   vdu_clg:
0B16FB 3E 10       0061*       ld a,16
0B16FD 5B D7       0062*   	rst.lil $10
0B16FF C9          0063*   	ret
0B1700             0064*   
0B1700             0065*   ; COLOUR MODES
0B1700             0066*   ; Mode	Effect
0B1700             0067*   ; 0	Set on-screen pixel to target colour value
0B1700             0068*   ; 1	OR value with the on-screen pixel
0B1700             0069*   ; 2	AND value with the on-screen pixel
0B1700             0070*   ; 3	XOR value with the on-screen pixel
0B1700             0071*   ; 4	Invert the on-screen pixel
0B1700             0072*   ; 5	No operation
0B1700             0073*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0B1700             0074*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0B1700             0075*   
0B1700             0076*   ; VDU 17, colour: Define text colour (COLOUR)
0B1700             0077*   vdu_colour_text:
0B1700 32 10 17 0B 0078*   	ld (@arg),a
0B1704 21 0F 17 0B 0079*   	ld hl,@cmd
0B1708 01 02 00 00 0080*   	ld bc,@end-@cmd
0B170C 5B DF       0081*   	rst.lil $18
0B170E C9          0082*   	ret
0B170F 11          0083*   @cmd: db 17
0B1710 00          0084*   @arg: db 0
0B1711             0085*   @end:
0B1711             0086*   
0B1711             0087*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B1711             0088*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0B1711             0089*   vdu_gcol:
0B1711 32 26 17 0B 0090*   	ld (@mode),a
0B1715 79          0091*       ld a,c
0B1716 32 27 17 0B 0092*       ld (@col),a
0B171A 21 25 17 0B 0093*   	ld hl,@cmd
0B171E 01 03 00 00 0094*   	ld bc,@end-@cmd
0B1722 5B DF       0095*   	rst.lil $18
0B1724 C9          0096*   	ret
0B1725 12          0097*   @cmd:  db 18
0B1726 00          0098*   @mode: db 0
0B1727 00          0099*   @col:  db 0
0B1728             0100*   @end:
0B1728             0101*   
0B1728             0102*   
0B1728             0103*   ; VDU 28, left, bottom, right, top: Set text viewport **
0B1728             0104*   ; MIND THE LITTLE-ENDIANESS
0B1728             0105*   ; inputs: c=left,b=bottom,e=right,d=top
0B1728             0106*   ; outputs; nothing
0B1728             0107*   ; destroys: a might make it out alive
0B1728             0108*   vdu_set_txt_viewport:
0B1728 ED 43 3E 17 0109*       ld (@lb),bc
       0B          
0B172D ED 53 40 17 0110*   	ld (@rt),de
       0B          
0B1732 21 3D 17 0B 0111*   	ld hl,@cmd
0B1736 01 05 00 00 0112*   	ld bc,@end-@cmd
0B173A 5B DF       0113*   	rst.lil $18
0B173C C9          0114*   	ret
0B173D 1C          0115*   @cmd:   db 28 ; set text viewport command
0B173E 00 00       0116*   @lb: 	dw 0x0000 ; set by bc
0B1740 00 00       0117*   @rt: 	dw 0x0000 ; set by de
0B1742 00          0118*   @end:   db 0x00	  ; padding
0B1743             0119*   
0B1743             0120*   ; Wait for VBLANK interrupt
0B1743             0121*   vdu_vblank:
0B1743 DD E5       0122*       PUSH 	IX
0B1745             0123*   	MOSCALL	mos_sysvars
                       M1 Args: function=mos_sysvars 
0B1745 3E 08       0001*M1 			LD	A, function
0B1747 49 CF       0002*M1 			RST.LIS	08h
0B1749 DD 7E 00    0124*   	LD	A, (IX + sysvar_time + 0)
0B174C             0125*   @wait:
0B174C DD BE 00    0126*       CP 	A, (IX + sysvar_time + 0)
0B174F 28 FB       0127*       JR	Z, @wait
0B1751 DD E1       0128*       POP	IX
0B1753 C9          0129*       RET
0B1754             0130*   
0B1754             0131*   ; VDU 29, x; y;: Set graphics origin
0B1754             0132*   ; This command sets the graphics origin.
0B1754             0133*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0B1754             0134*   ; inputs: bc=x0,de=y0
0B1754             0135*   ; outputs; nothing
0B1754             0136*   ; destroys: a might make it out alive
0B1754             0137*   vdu_set_gfx_origin:
0B1754 ED 43 6A 17 0138*       ld (@x0),bc
       0B          
0B1759 ED 53 6C 17 0139*       ld (@y0),de
       0B          
0B175E 21 69 17 0B 0140*       ld hl,@cmd
0B1762 01 05 00 00 0141*       ld bc,@end-@cmd
0B1766 5B DF       0142*       rst.lil $18
0B1768 C9          0143*       ret
0B1769 1D          0144*   @cmd:   db 29 ; set graphics origin command
0B176A 00 00       0145*   @x0: 	dw 0x0000 ; set by bc
0B176C 00 00       0146*   @y0: 	dw 0x0000 ; set by de
0B176E 00          0147*   @end:   db 0x00	  ; padding
0B176F             0148*   
0B176F             0149*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B176F             0150*   ; NOTE: the order of the y-coordinate parameters are inverted
0B176F             0151*   ; 	because we have turned off logical screen scaling
0B176F             0152*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B176F             0153*   ; outputs; nothing
0B176F             0154*   ; destroys: a might make it out alive
0B176F             0155*   vdu_set_gfx_viewport:
0B176F ED 43 8F 17 0156*       ld (@x0),bc
       0B          
0B1774 FD 22 91 17 0157*       ld (@y1),iy
       0B          
0B1779 DD 22 93 17 0158*   	ld (@x1),ix
       0B          
0B177E ED 53 95 17 0159*   	ld (@y0),de
       0B          
0B1783 21 8E 17 0B 0160*   	ld hl,@cmd
0B1787 01 09 00 00 0161*   	ld bc,@end-@cmd
0B178B 5B DF       0162*   	rst.lil $18
0B178D C9          0163*   	ret
0B178E 18          0164*   @cmd:   db 24 ; set graphics viewport command
0B178F 00 00       0165*   @x0: 	dw 0x0000 ; set by bc
0B1791 00 00       0166*   @y1: 	dw 0x0000 ; set by iy
0B1793 00 00       0167*   @x1: 	dw 0x0000 ; set by ix
0B1795 00 00       0168*   @y0: 	dw 0x0000 ; set by de
0B1797 00          0169*   @end:   db 0x00	  ; padding
0B1798             0170*   
0B1798             0171*   ; SCREEN MODES
0B1798             0172*   ; ===============================
0B1798             0173*   ; Mode  Horz  Vert  Cols  Refresh
0B1798             0174*   ; ---   ----  ----  ----  -------
0B1798             0175*   ; 11    320   240   2     60hz
0B1798             0176*   ; 139   320   240   2     60hz
0B1798             0177*   ; 23    512   384   2     60hz
0B1798             0178*   ; 151   512   384   2     60hz
0B1798             0179*   ; 6     640   240   2     60hz
0B1798             0180*   ; 134   640   240   2     60hz
0B1798             0181*   ; 2     640   480   2     60hz
0B1798             0182*   ; 130   640   480   2     60hz
0B1798             0183*   ; 17    800   600   2     60hz
0B1798             0184*   ; 145   800   600   2     60hz
0B1798             0185*   ; 18    1024  768   2     60hz
0B1798             0186*   ; 146   1024  768   2     60hz
0B1798             0187*   ; ---   ----  ----  ----  -------
0B1798             0188*   ; 10    320   240   4     60hz
0B1798             0189*   ; 138   320   240   4     60hz
0B1798             0190*   ; 22    512   384   4     60hz
0B1798             0191*   ; 150   512   384   4     60hz
0B1798             0192*   ; 5     640   240   4     60hz
0B1798             0193*   ; 133   640   240   4     60hz
0B1798             0194*   ; 1     640   480   4     60hz
0B1798             0195*   ; 129   640   480   4     60hz
0B1798             0196*   ; 16    800   600   4     60hz
0B1798             0197*   ; 19    1024  768   4     60hz
0B1798             0198*   ; ---   ----  ----  ----  -------
0B1798             0199*   ; 9     320   240   16    60hz
0B1798             0200*   ; 137   320   240   16    60hz
0B1798             0201*   ; 21    512   384   16    60hz
0B1798             0202*   ; 149   512   384   16    60hz
0B1798             0203*   ; 4     640   240   16    60hz
0B1798             0204*   ; 132   640   240   16    60hz
0B1798             0205*   ; 0     640   480   16    60hz
0B1798             0206*   ; 7     n/a   n/a   16    60hz
0B1798             0207*   ; ---   ----  ----  ----  -------
0B1798             0208*   ; 8     320   240   64    60hz
0B1798             0209*   ; 136   320   240   64    60hz
0B1798             0210*   ; 20    512   384   64    60hz
0B1798             0211*   ; 3     640   240   64    60hz
0B1798             0212*   ; ---   ----  ----  ----  -------
0B1798             0213*   vdu_set_screen_mode:
0B1798 32 A8 17 0B 0214*   	ld (@arg),a
0B179C 21 A7 17 0B 0215*   	ld hl,@cmd
0B17A0 01 02 00 00 0216*   	ld bc,@end-@cmd
0B17A4 5B DF       0217*   	rst.lil $18
0B17A6 C9          0218*   	ret
0B17A7 16          0219*   @cmd: db 22 ; set screen mode
0B17A8 00          0220*   @arg: db 0  ; screen mode parameter
0B17A9             0221*   @end:
0B17A9             0222*   
0B17A9             0223*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B17A9             0224*   ; inputs: a is scaling mode, 1=on, 0=off
0B17A9             0225*   ; note: default setting on boot is scaling ON
0B17A9             0226*   vdu_set_scaling:
0B17A9 32 BB 17 0B 0227*   	ld (@arg),a
0B17AD 21 B8 17 0B 0228*   	ld hl,@cmd
0B17B1 01 04 00 00 0229*   	ld bc,@end-@cmd
0B17B5 5B DF       0230*   	rst.lil $18
0B17B7 C9          0231*   	ret
0B17B8 17 00 C0    0232*   @cmd: db 23,0,0xC0
0B17BB 00          0233*   @arg: db 0  ; scaling on/off
0B17BC             0234*   @end:
0B17BC             0235*   
0B17BC             0236*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B17BC             0237*   ; inputs: hl=bufferId
0B17BC             0238*   vdu_buff_select:
0B17BC 22 CE 17 0B 0239*   	ld (@bufferId),hl
0B17C0 21 CB 17 0B 0240*   	ld hl,@cmd
0B17C4 01 05 00 00 0241*   	ld bc,@end-@cmd
0B17C8 5B DF       0242*   	rst.lil $18
0B17CA C9          0243*   	ret
0B17CB 17 1B 20    0244*   @cmd: db 23,27,0x20
0B17CE 00 00       0245*   @bufferId: dw 0x0000
0B17D0 00          0246*   @end: db 0x00 ; padding
0B17D1             0247*   
0B17D1             0248*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B17D1             0249*   ; inputs: a=format; bc=width; de=height
0B17D1             0250*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B17D1             0251*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B17D1             0252*   ; 0 	RGBA8888 (4-bytes per pixel)
0B17D1             0253*   ; 1 	RGBA2222 (1-bytes per pixel)
0B17D1             0254*   ; 2 	Mono/Mask (1-bit per pixel)
0B17D1             0255*   ; 3 	Reserved for internal use by VDP (“native” format)
0B17D1             0256*   vdu_bmp_create:
0B17D1 ED 43 ED 17 0257*       ld (@width),bc
       0B          
0B17D6 ED 53 EF 17 0258*       ld (@height),de
       0B          
0B17DB 32 F1 17 0B 0259*       ld (@fmt),a
0B17DF 21 EA 17 0B 0260*   	ld hl,@cmd
0B17E3 01 08 00 00 0261*   	ld bc,@end-@cmd
0B17E7 5B DF       0262*   	rst.lil $18
0B17E9 C9          0263*   	ret
0B17EA 17 1B 21    0264*   @cmd:       db 23,27,0x21
0B17ED 00 00       0265*   @width:     dw 0x0000
0B17EF 00 00       0266*   @height:    dw 0x0000
0B17F1 00          0267*   @fmt:       db 0x00
0B17F2             0268*   @end:
0B17F2             0269*   
0B17F2             0270*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B17F2             0271*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B17F2             0272*   vdu_load_img_rgba2_to_8:
0B17F2             0273*   ; backup the target buffer id and image dimensions
0B17F2 E5          0274*       push hl
0B17F3 D5          0275*       push de
0B17F4 C5          0276*       push bc
0B17F5             0277*   ; load the rgba2 image to working buffer 65534
0B17F5 21 FE FF 00 0278*       ld hl,65534 ; temporary working buffer id
0B17F9 CD FC 18 0B 0279*   	call vdu_load_buffer_from_file
0B17FD             0280*   ; restore the image dimensions and target buffer id
0B17FD C1          0281*       pop bc
0B17FE D1          0282*       pop de
0B17FF E1          0283*       pop hl
0B1800             0284*   ; fall through to vdu_rgba2_to_8
0B1800             0285*   
0B1800             0286*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B1800             0287*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B1800             0288*   ; the "expand bitmap" command is:
0B1800             0289*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B1800             0290*   ; and then to reverse the byte order to fix endian-ness:
0B1800             0291*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B1800             0292*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B1800             0293*   ; VDU 23,27,&20,targetBufferID%;
0B1800             0294*   ; VDU 23,27,&21,width%;height%;0
0B1800             0295*   ; -------------------------------------------------------------------
0B1800             0296*   ; inputs: bc,de image width,height ; hl = targetBufferId
0B1800             0297*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B1800             0298*   vdu_rgba2_to_8:
0B1800             0299*   ; load the image dimensions and buffer id parameters
0B1800 ED 43 5C 18 0300*       ld (@width),bc
       0B          
0B1805 ED 53 5E 18 0301*       ld (@height),de
       0B          
0B180A 22 41 18 0B 0302*       ld (@bufferId0),hl
0B180E 22 4E 18 0B 0303*       ld (@bufferId2),hl
0B1812 22 57 18 0B 0304*       ld (@bufferId1),hl
0B1816             0305*   ; clean up bytes that got stomped on by the ID loads
0B1816 3E 48       0306*       ld a,0x48
0B1818 32 43 18 0B 0307*       ld (@bufferId0+2),a
0B181C 3E 17       0308*       ld a,23
0B181E 32 59 18 0B 0309*       ld (@bufferId1+2),a
0B1822 3E 18       0310*       ld a,24
0B1824 32 50 18 0B 0311*       ld (@bufferId2+2),a
0B1828 AF          0312*       xor a
0B1829 32 60 18 0B 0313*       ld (@height+2),a
0B182D             0314*   ; send the vdu command strings
0B182D 21 38 18 0B 0315*       ld hl,@beg
0B1831 01 29 00 00 0316*       ld bc,@end-@beg
0B1835 5B DF       0317*       rst.lil $18
0B1837 C9          0318*       ret
0B1838             0319*   @beg:
0B1838             0320*   ; Command 14: Consolidate blocks in a buffer
0B1838             0321*   ; VDU 23, 0, &A0, bufferId; 14
0B1838 17 00 A0    0322*       db 23,0,0xA0
0B183B FE FF       0323*       dw 65534 ; workingBufferId
0B183D 0E          0324*       db 14 ; consolidate blocks
0B183E             0325*   ; the "expand bitmap" command is:
0B183E             0326*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B183E 17 00 A0    0327*       db 23,0,0xA0
0B1841 00 00       0328*   @bufferId0: dw 0x0000 ; targetBufferId
0B1843 48          0329*       db 0x48 ; given as decimal command 72 in the docs
0B1844 02          0330*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B1845 FE FF       0331*       dw 65534 ; sourceBufferId
0B1847 00 7F BF FF 0332*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B184B             0333*   ; reverse the byte order to fix endian-ness:
0B184B             0334*   ; Command 24: Reverse the order of data of blocks within a buffer
0B184B             0335*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B184B             0336*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B184B 17 00 A0    0337*       db 23,0,0xA0
0B184E 00 00       0338*   @bufferId2:    dw 0x0000 ; targetBufferId
0B1850 18          0339*       db 24 ; reverse byte order
0B1851 04          0340*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B1852 04 00       0341*       dw 4 ; size (4 bytes)
0B1854             0342*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B1854             0343*   ; VDU 23,27,&20,targetBufferID%;
0B1854 17 1B 20    0344*       db 23,27,0x20 ; select bitmap
0B1857 00 00       0345*   @bufferId1: dw 0x0000 ; targetBufferId
0B1859             0346*   ; VDU 23,27,&21,width%;height%;0
0B1859 17 1B 21    0347*       db 23,27,0x21 ; create bitmap from buffer
0B185C 00 00       0348*   @width: dw 0x0000
0B185E 00 00       0349*   @height: dw 0x0000
0B1860 00          0350*       db 0x00 ; rgba8888 format
0B1861             0351*   @end:
0B1861             0352*   
0B1861             0353*   ; scratch variables
0B1861 00 00 00    0354*   bufferId0: dl 0x000000
0B1864 00 00 00    0355*   bufferId1: dl 0x000000
0B1867             0356*   
0B1867             0357*   ; load a vdu buffer from local memory
0B1867             0358*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1867             0359*   vdu_load_buffer:
0B1867 ED 43 90 18 0360*       ld (@length),bc
       0B          
0B186C D5          0361*       push de ; save data pointer
0B186D             0362*   ; send the vdu command string
0B186D 7D          0363*       ld a,l
0B186E 32 8D 18 0B 0364*       ld (@bufferId),a
0B1872 7C          0365*       ld a,h
0B1873 32 8E 18 0B 0366*       ld (@bufferId+1),a
0B1877 21 8A 18 0B 0367*       ld hl,@cmd
0B187B 01 08 00 00 0368*       ld bc,@end-@cmd
0B187F 5B DF       0369*       rst.lil $18
0B1881             0370*   ; send the buffer data
0B1881 E1          0371*       pop hl ; pointer to data
0B1882 ED 4B 90 18 0372*       ld bc,(@length)
       0B          
0B1887 5B DF       0373*       rst.lil $18 ; send it
0B1889 C9          0374*       ret
0B188A             0375*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B188A 17 00 A0    0376*   @cmd:       db 23,0,0xA0
0B188D 00 00       0377*   @bufferId:	dw 0x0000
0B188F 00          0378*   		    db 0 ; load buffer
0B1890 00 00       0379*   @length:	dw 0x0000
0B1892 00          0380*   @end: db 0 ; padding
0B1893             0381*   
0B1893             0382*   ; clear a buffer
0B1893             0383*   ; inputs: hl = bufferId
0B1893             0384*   vdu_clear_buffer:
0B1893 7D          0385*       ld a,l
0B1894 32 AB 18 0B 0386*       ld (@bufferId),a
0B1898 7C          0387*       ld a,h
0B1899 32 AC 18 0B 0388*       ld (@bufferId+1),a
0B189D 21 A8 18 0B 0389*       ld hl,@cmd
0B18A1 01 06 00 00 0390*       ld bc,@end-@cmd
0B18A5 5B DF       0391*       rst.lil $18
0B18A7 C9          0392*       ret
0B18A8 17 00 A0    0393*   @cmd:       db 23,0,0xA0
0B18AB 00 00       0394*   @bufferId:	dw 0x0000
0B18AD 02          0395*   		    db 2 ; clear buffer
0B18AE             0396*   @end:
0B18AE             0397*   
0B18AE             0398*   vdu_clear_all_buffers:
0B18AE             0399*   ; clear all buffers
0B18AE 21 B9 18 0B 0400*       ld hl,@beg
0B18B2 01 06 00 00 0401*       ld bc,@end-@beg
0B18B6 5B DF       0402*       rst.lil $18
0B18B8 C9          0403*       ret
0B18B9 17 00 A0    0404*   @beg: db 23,0,$A0
0B18BC FF FF       0405*         dw -1 ; clear all buffers
0B18BE 02          0406*         db 2  ; command 2: clear a buffer
0B18BF             0407*   @end:
0B18BF             0408*   
0B18BF             0409*   ; Command 14: Consolidate blocks in a buffer
0B18BF             0410*   vdu_consolidate_buffer:
0B18BF             0411*   ; set parameters for vdu call
0B18BF 7D          0412*       ld a,l
0B18C0 32 D7 18 0B 0413*       ld (@bufferId),a
0B18C4 7C          0414*       ld a,h
0B18C5 32 D8 18 0B 0415*       ld (@bufferId+1),a
0B18C9 21 D4 18 0B 0416*       ld hl,@beg
0B18CD 01 06 00 00 0417*       ld bc,@end-@beg
0B18D1 5B DF       0418*       rst.lil $18
0B18D3 C9          0419*       ret
0B18D4             0420*   ; VDU 23, 0, &A0, bufferId; 14
0B18D4 17 00 A0    0421*   @beg: db 23,0,0xA0
0B18D7 00 00       0422*   @bufferId: dw 0x0000
0B18D9 0E          0423*              db 14
0B18DA             0424*   @end:
0B18DA             0425*   
0B18DA             0426*   ; load an image file to a buffer and make it a bitmap
0B18DA             0427*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B18DA             0428*   vdu_load_img:
0B18DA             0429*   ; back up image type and dimension parameters
0B18DA 22 61 18 0B 0430*       ld (bufferId0),hl
0B18DE F5          0431*       push af
0B18DF C5          0432*   	push bc
0B18E0 D5          0433*   	push de
0B18E1             0434*   ; load the image
0B18E1 CD FC 18 0B 0435*   	call vdu_load_buffer_from_file
0B18E5             0436*   ; now make it a bitmap
0B18E5 2A 61 18 0B 0437*       ld hl,(bufferId0)
0B18E9 CD BF 18 0B 0438*       call vdu_consolidate_buffer
0B18ED 2A 61 18 0B 0439*       ld hl,(bufferId0)
0B18F1 CD BC 17 0B 0440*       call vdu_buff_select
0B18F5 D1          0441*   	pop de ; image height
0B18F6 C1          0442*   	pop bc ; image width
0B18F7 F1          0443*   	pop af ; image type
0B18F8 C3 D1 17 0B 0444*   	jp vdu_bmp_create ; will return to caller from there
0B18FC             0445*   
0B18FC             0446*   ; inputs: hl = bufferId; iy = pointer to filename
0B18FC             0447*   vdu_load_buffer_from_file:
0B18FC 22 61 18 0B 0448*       ld (bufferId0),hl
0B1900             0449*   
0B1900             0450*   ; clear target buffer
0B1900 CD 93 18 0B 0451*       call vdu_clear_buffer
0B1904             0452*   
0B1904             0453*   ; open the file in read mode
0B1904             0454*   ; Open a file
0B1904             0455*   ; HLU: Filename
0B1904             0456*   ;   C: Mode
0B1904             0457*   ; Returns:
0B1904             0458*   ;   A: Filehandle, or 0 if couldn't open
0B1904 FD E5       0459*   	push iy ; pointer to filename
0B1906 E1          0460*   	pop hl
0B1907 0E 01       0461*   	ld c,fa_read
0B1909             0462*       MOSCALL mos_fopen
                       M1 Args: function=mos_fopen 
0B1909 3E 0A       0001*M1 			LD	A, function
0B190B 49 CF       0002*M1 			RST.LIS	08h
0B190D 32 48 19 0B 0463*       ld (@filehandle),a
0B1911             0464*   
0B1911             0465*   @read_file:
0B1911             0466*   ; Read a block of data from a file
0B1911             0467*   ;   C: Filehandle
0B1911             0468*   ; HLU: Pointer to where to write the data to
0B1911             0469*   ; DEU: Number of bytes to read
0B1911             0470*   ; Returns:
0B1911             0471*   ; DEU: Number of bytes read
0B1911 3A 48 19 0B 0472*       ld a,(@filehandle)
0B1915 4F          0473*       ld c,a
0B1916 21 00 E0 B7 0474*       ld hl,filedata
0B191A 11 00 20 00 0475*       ld de,8192 ; max we can read into onboard sram at one time
0B191E             0476*       MOSCALL mos_fread
                       M1 Args: function=mos_fread 
0B191E 3E 1A       0001*M1 			LD	A, function
0B1920 49 CF       0002*M1 			RST.LIS	08h
0B1922             0477*   
0B1922             0478*   ; ; DEBUG: print chunk size
0B1922             0479*   ;     push de
0B1922             0480*   ;     pop hl
0B1922             0481*   ;     call printDec
0B1922             0482*   ;     call printNewLine
0B1922             0483*   
0B1922             0484*   ; test de for zero bytes read
0B1922 21 00 00 00 0485*       ld hl,0
0B1926 AF          0486*       xor a ; clear carry
0B1927 ED 52       0487*       sbc hl,de
0B1929 CA 3F 19 0B 0488*       jp z,@close_file
0B192D             0489*   
0B192D             0490*   ; load a vdu buffer from local memory
0B192D             0491*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B192D 2A 61 18 0B 0492*       ld hl,(bufferId0)
0B1931 D5          0493*       push de ; chunksize
0B1932 C1          0494*       pop bc
0B1933 11 00 E0 B7 0495*       ld de,filedata
0B1937 CD 67 18 0B 0496*       call vdu_load_buffer
0B193B             0497*   
0B193B             0498*   ; ; print progress breadcrumbs
0B193B             0499*   ;     ld a,'.'
0B193B             0500*   ;     rst.lil 10h
0B193B             0501*   
0B193B             0502*   ; read the next block
0B193B C3 11 19 0B 0503*       jp @read_file
0B193F             0504*   
0B193F             0505*   ; close the file
0B193F             0506*   @close_file:
0B193F 3A 48 19 0B 0507*       ld a,(@filehandle)
0B1943             0508*       MOSCALL mos_fclose
                       M1 Args: function=mos_fclose 
0B1943 3E 0B       0001*M1 			LD	A, function
0B1945 49 CF       0002*M1 			RST.LIS	08h
0B1947 C9          0509*       ret ; vdu_load_buffer_from_file
0B1948             0510*   
0B1948 00          0511*   @filehandle: db 0 ; file handle
0B1949 00 00 00    0512*   @fil: dl 0 ; pointer to FIL struct
0B194C             0513*   
0B194C 00 00 00    0514*   @chunkpointer: dl 0 ; pointer to current chunk
0B194F             0515*   
0B194F             0516*   ; File information structure (FILINFO)
0B194F             0517*   @filinfo:
0B194F 00 00 00 00 0518*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B1953 00 00       0519*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B1955 00 00       0520*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B1957 00          0521*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B1958 00 00 00 00 0522*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B1965 00 00 00 00 0523*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B1A65             0186        include "vdu_plot.inc"
0B1A65             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1A65             0002*   ; PLOT code 	(Decimal) 	Effect
0B1A65             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
0B1A65             0004*   plot_sl_both: equ 0x00
0B1A65             0005*   
0B1A65             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
0B1A65             0007*   plot_sl_first: equ 0x08
0B1A65             0008*   
0B1A65             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B1A65             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B1A65             0011*   
0B1A65             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
0B1A65             0013*   plot_sl_last: equ 0x20
0B1A65             0014*   
0B1A65             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
0B1A65             0016*   plot_sl_none: equ 0x28
0B1A65             0017*   
0B1A65             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B1A65             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B1A65             0020*   
0B1A65             0021*   ; &40-&47 	64-71 	Point plot
0B1A65             0022*   plot_pt: equ 0x40
0B1A65             0023*   
0B1A65             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0B1A65             0025*   plot_lf_lr_non_bg: equ 0x48
0B1A65             0026*   
0B1A65             0027*   ; &50-&57 	80-87 	Triangle fill
0B1A65             0028*   plot_tf: equ 0x50
0B1A65             0029*   
0B1A65             0030*   ; &58-&5F 	88-95 	Line fill right to background §§
0B1A65             0031*   plot_lf_r_bg: equ 0x58
0B1A65             0032*   
0B1A65             0033*   ; &60-&67 	96-103 	Rectangle fill
0B1A65             0034*   plot_rf: equ 0x60
0B1A65             0035*   
0B1A65             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0B1A65             0037*   plot_lf_lr_fg: equ 0x60
0B1A65             0038*   
0B1A65             0039*   ; &70-&77 	112-119 	Parallelogram fill
0B1A65             0040*   plot_pf: equ 0x70
0B1A65             0041*   
0B1A65             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0B1A65             0043*   plot_lf_r_non_fg: equ 0x78
0B1A65             0044*   
0B1A65             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B1A65             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B1A65             0047*   
0B1A65             0048*   ; &90-&97 	144-151 	Circle outline
0B1A65             0049*   plot_co: equ 0x90
0B1A65             0050*   
0B1A65             0051*   ; &98-&9F 	152-159 	Circle fill
0B1A65             0052*   plot_cf: equ 0x98
0B1A65             0053*   
0B1A65             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B1A65             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B1A65             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B1A65             0057*   
0B1A65             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
0B1A65             0059*   plot_rcm: equ 0xB8
0B1A65             0060*   
0B1A65             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B1A65             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B1A65             0063*   ; &D0-&D7 	208-215 	Not defined
0B1A65             0064*   ; &D8-&DF 	216-223 	Not defined
0B1A65             0065*   ; &E0-&E7 	224-231 	Not defined
0B1A65             0066*   
0B1A65             0067*   ; &E8-&EF 	232-239 	Bitmap plot §
0B1A65             0068*   plot_bmp: equ 0xE8
0B1A65             0069*   
0B1A65             0070*   ; &F0-&F7 	240-247 	Not defined
0B1A65             0071*   ; &F8-&FF 	248-255 	Not defined
0B1A65             0072*   
0B1A65             0073*   ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0B1A65             0074*   ; Agon Console8 VDP 2.2.0
0B1A65             0075*   
0B1A65             0076*   ; Within each group of eight plot codes, the effects are as follows:
0B1A65             0077*   ; Plot code 	Effect
0B1A65             0078*   ; 0 	Move relative
0B1A65             0079*   mv_rel: equ 0
0B1A65             0080*   
0B1A65             0081*   ; 1 	Plot relative in current foreground colour
0B1A65             0082*   dr_rel_fg: equ 1
0B1A65             0083*   
0B1A65             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
0B1A65             0085*   ; 3 	Plot relative in current background colour
0B1A65             0086*   dr_rel_bg: equ 3
0B1A65             0087*   
0B1A65             0088*   ; 4 	Move absolute
0B1A65             0089*   mv_abs: equ 4
0B1A65             0090*   
0B1A65             0091*   ; 5 	Plot absolute in current foreground colour
0B1A65             0092*   dr_abs_fg: equ 5
0B1A65             0093*   
0B1A65             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
0B1A65             0095*   ; 7 	Plot absolute in current background colour
0B1A65             0096*   dr_abs_bg: equ 7
0B1A65             0097*   
0B1A65             0098*   ; Codes 0-3 use the position data provided as part of the command
0B1A65             0099*   ; as a relative position, adding the position given to the current
0B1A65             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
0B1A65             0101*   ; as part of the command as an absolute position, setting the current
0B1A65             0102*   ; graphical cursor position to the position given.
0B1A65             0103*   
0B1A65             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B1A65             0105*   ; current pixel colour. These operations cannot currently be supported
0B1A65             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
0B1A65             0107*   ; supported. Support for these codes may be added in a future version
0B1A65             0108*   ; of the VDP firmware.
0B1A65             0109*   
0B1A65             0110*   ; 16 colour palette constants
0B1A65             0111*   c_black: equ 0
0B1A65             0112*   c_red_dk: equ 1
0B1A65             0113*   c_green_dk: equ 2
0B1A65             0114*   c_yellow_dk: equ 3
0B1A65             0115*   c_blue_dk: equ 4
0B1A65             0116*   c_magenta_dk: equ 5
0B1A65             0117*   c_cyan_dk: equ 6
0B1A65             0118*   c_grey: equ 7
0B1A65             0119*   c_grey_dk: equ 8
0B1A65             0120*   c_red: equ 9
0B1A65             0121*   c_green: equ 10
0B1A65             0122*   c_yellow: equ 11
0B1A65             0123*   c_blue: equ 12
0B1A65             0124*   c_magenta: equ 13
0B1A65             0125*   c_cyan: equ 14
0B1A65             0126*   c_white: equ 15
0B1A65             0127*   
0B1A65             0128*   ; VDU 25, mode, x; y;: PLOT command
0B1A65             0129*   ; inputs: a=mode, bc=x0, de=y0
0B1A65             0130*   vdu_plot:
0B1A65 32 7F 1A 0B 0131*       ld (@mode),a
0B1A69 ED 43 80 1A 0132*       ld (@x0),bc
       0B          
0B1A6E ED 53 82 1A 0133*       ld (@y0),de
       0B          
0B1A73 21 7E 1A 0B 0134*   	ld hl,@cmd
0B1A77 01 06 00 00 0135*   	ld bc,@end-@cmd
0B1A7B 5B DF       0136*   	rst.lil $18
0B1A7D C9          0137*   	ret
0B1A7E 19          0138*   @cmd:   db 25
0B1A7F 00          0139*   @mode:  db 0
0B1A80 00 00       0140*   @x0: 	dw 0
0B1A82 00 00       0141*   @y0: 	dw 0
0B1A84 00          0142*   @end:   db 0 ; extra byte to soak up deu
0B1A85             0143*   
0B1A85             0144*   ; VDU 25, mode, x; y;: PLOT command
0B1A85             0145*   ; USING 16.8 FIXED POINT COORDINATES
0B1A85             0146*   ; inputs: a=mode, ub.c=x0, ud.e=y0
0B1A85             0147*   vdu_plot_168:
0B1A85 ED 53 A1 1A 0148*       ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
       0B          
0B1A8A ED 43 9F 1A 0149*       ld (@x0-1),bc ; integer portion only
       0B          
0B1A8F 32 9F 1A 0B 0150*       ld (@mode),a  ; load this order b/c we shifted bc right
0B1A93 21 9E 1A 0B 0151*   	ld hl,@cmd
0B1A97 01 06 00 00 0152*   	ld bc,@end-@cmd
0B1A9B 5B DF       0153*   	rst.lil $18
0B1A9D             0154*       ; ld hl,@cmd
0B1A9D             0155*       ; ld a,6
0B1A9D             0156*       ; call dumpMemoryHex
0B1A9D             0157*       ; call printNewLine
0B1A9D C9          0158*   	ret
0B1A9E 19          0159*   @cmd:   db 25
0B1A9F 00          0160*   @mode:  db 0
0B1AA0 00 00       0161*   @x0: 	dw 0
0B1AA2 00 00       0162*   @y0: 	dw 0
0B1AA4             0163*   @end:  ; no padding required b/c we shifted de right
0B1AA4             0164*   
0B1AA4             0165*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1AA4             0166*   ; &E8-&EF 	232-239 	Bitmap plot §
0B1AA4             0167*   ; VDU 25, mode, x; y;: PLOT command
0B1AA4             0168*   ; inputs: bc=x0, de=y0
0B1AA4             0169*   ; prerequisites: vdu_buff_select
0B1AA4             0170*   vdu_plot_bmp:
0B1AA4 ED 43 BB 1A 0171*       ld (@x0),bc
       0B          
0B1AA9 ED 53 BD 1A 0172*       ld (@y0),de
       0B          
0B1AAE 21 B9 1A 0B 0173*   	ld hl,@cmd
0B1AB2 01 06 00 00 0174*   	ld bc,@end-@cmd
0B1AB6 5B DF       0175*   	rst.lil $18
0B1AB8 C9          0176*   	ret
0B1AB9 19          0177*   @cmd:   db 25
0B1ABA ED          0178*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1ABB 00 00       0179*   @x0: 	dw 0x0000
0B1ABD 00 00       0180*   @y0: 	dw 0x0000
0B1ABF 00          0181*   @end:   db 0x00 ; padding
0B1AC0             0182*   
0B1AC0             0183*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B1AC0             0184*   ; &E8-&EF 	232-239 	Bitmap plot §
0B1AC0             0185*   ; VDU 25, mode, x; y;: PLOT command
0B1AC0             0186*   ; inputs: bc=x0, de=y0
0B1AC0             0187*   ; USING 16.8 FIXED POINT COORDINATES
0B1AC0             0188*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B1AC0             0189*   ;   the fractional portiion of the inputs are truncated
0B1AC0             0190*   ;   leaving only the 16-bit integer portion
0B1AC0             0191*   ; prerequisites: vdu_buff_select
0B1AC0             0192*   vdu_plot_bmp168:
0B1AC0             0193*   ; populate in the reverse of normal to keep the
0B1AC0             0194*   ; inputs from stomping on each other
0B1AC0 ED 53 DE 1A 0195*       ld (@y0-1),de
       0B          
0B1AC5 ED 43 DC 1A 0196*       ld (@x0-1),bc
       0B          
0B1ACA 3E ED       0197*       ld a,plot_bmp+dr_abs_fg ; 0xED
0B1ACC 32 DC 1A 0B 0198*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B1AD0 21 DB 1A 0B 0199*   	ld hl,@cmd
0B1AD4 01 06 00 00 0200*   	ld bc,@end-@cmd
0B1AD8 5B DF       0201*   	rst.lil $18
0B1ADA C9          0202*   	ret
0B1ADB 19          0203*   @cmd:   db 25
0B1ADC ED          0204*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1ADD 00 00       0205*   @x0: 	dw 0x0000
0B1ADF 00 00       0206*   @y0: 	dw 0x0000
0B1AE1             0207*   @end:  ; no padding required b/c we shifted de right
0B1AE1             0208*   
0B1AE1             0209*   ; draw a filled rectangle
0B1AE1             0210*   vdu_plot_rf:
0B1AE1 ED 43 08 1B 0211*       ld (@x0),bc
       0B          
0B1AE6 ED 53 0A 1B 0212*       ld (@y0),de
       0B          
0B1AEB DD 22 0E 1B 0213*       ld (@x1),ix
       0B          
0B1AF0 FD 22 10 1B 0214*       ld (@y1),iy
       0B          
0B1AF5 3E 19       0215*       ld a,25 ; we have to reload the 2nd plot command
0B1AF7 32 0C 1B 0B 0216*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1AFB 21 06 1B 0B 0217*   	ld hl,@cmd0
0B1AFF 01 0C 00 00 0218*   	ld bc,@end-@cmd0
0B1B03 5B DF       0219*   	rst.lil $18
0B1B05 C9          0220*       ret
0B1B06 19          0221*   @cmd0:  db 25 ; plot
0B1B07 04          0222*   @arg0:  db plot_sl_both+mv_abs
0B1B08 00 00       0223*   @x0:    dw 0x0000
0B1B0A 00 00       0224*   @y0:    dw 0x0000
0B1B0C 19          0225*   @cmd1:  db 25 ; plot
0B1B0D 65          0226*   @arg1:  db plot_rf+dr_abs_fg
0B1B0E 00 00       0227*   @x1:    dw 0x0000
0B1B10 00 00       0228*   @y1:    dw 0x0000
0B1B12 00          0229*   @end:   db 0x00 ; padding
0B1B13             0230*   
0B1B13             0231*   ; draw a filled circle
0B1B13             0232*   vdu_plot_cf:
0B1B13 ED 43 3A 1B 0233*       ld (@x0),bc
       0B          
0B1B18 ED 53 3C 1B 0234*       ld (@y0),de
       0B          
0B1B1D DD 22 40 1B 0235*       ld (@x1),ix
       0B          
0B1B22 FD 22 42 1B 0236*       ld (@y1),iy
       0B          
0B1B27 3E 19       0237*       ld a,25 ; we have to reload the 2nd plot command
0B1B29 32 3E 1B 0B 0238*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1B2D 21 38 1B 0B 0239*   	ld hl,@cmd0
0B1B31 01 0C 00 00 0240*   	ld bc,@end-@cmd0
0B1B35 5B DF       0241*   	rst.lil $18
0B1B37 C9          0242*       ret
0B1B38 19          0243*   @cmd0:  db 25 ; plot
0B1B39 04          0244*   @arg0:  db plot_sl_both+mv_abs
0B1B3A 00 00       0245*   @x0:    dw 0x0000
0B1B3C 00 00       0246*   @y0:    dw 0x0000
0B1B3E 19          0247*   @cmd1:  db 25 ; plot
0B1B3F 9D          0248*   @arg1:  db plot_cf+dr_abs_fg
0B1B40 00 00       0249*   @x1:    dw 0x0000
0B1B42 00 00       0250*   @y1:    dw 0x0000
0B1B44 00          0251*   @end:   db 0x00 ; padding
0B1B45             0252*   
0B1B45             0253*   ; VDU 25, mode, x; y;: PLOT command
0B1B45             0254*   ; inputs: a=mode, ix=x0, iy=y0
0B1B45             0255*   plot:
0B1B45 32 5F 1B 0B 0256*       ld (@mode),a
0B1B49 DD 22 60 1B 0257*       ld (@x0),ix
       0B          
0B1B4E FD 22 62 1B 0258*       ld (@y0),iy
       0B          
0B1B53 21 5E 1B 0B 0259*   	ld hl,@cmd
0B1B57 01 06 00 00 0260*   	ld bc,@end-@cmd
0B1B5B 5B DF       0261*   	rst.lil $18
0B1B5D C9          0262*   	ret
0B1B5E 19          0263*   @cmd:   db 25
0B1B5F 00          0264*   @mode:  db 0
0B1B60 00 00       0265*   @x0: 	dw 0
0B1B62 00 00       0266*   @y0: 	dw 0
0B1B64 00          0267*   @end:   db 0 ; padding
0B1B65             0268*   
0B1B65             0269*   ; VDU 5: Write text at graphics cursor
0B1B65             0270*   ; inputs: hl = pointer to text, ix=x0, iy=y0
0B1B65             0271*   ; prerequisites: gcol foreground set, VDU 5 set
0B1B65             0272*   plot_text:
0B1B65 E5          0273*       push hl ; save text pointer
0B1B66             0274*   ; move graphics cursor to x0, y0
0B1B66 3E 44       0275*       ld a,plot_pt+mv_abs
0B1B68 CD 45 1B 0B 0276*       call plot
0B1B6C             0277*   ; write text
0B1B6C E1          0278*       pop hl ; restore text pointer
0B1B6D CD BE 0E 0B 0279*       call printString
0B1B71 C9          0280*       ret
0B1B72             0187        include "files.inc"
0B1B72             0001*   ; load to onboard 8k sram
0B1B72             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
0B1B72             0188    
0B1B72             0189    ; APPLICATION INCLUDES
0B1B72             0190    
0B1B72             0191    ; Storage for the argv array pointers
0B1B72             0192    min_args: equ 1
0B1B72             0193    argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B1B72 00 00 00 00 0194    argv_ptrs:		    BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B1BA2             0195    _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
0B1BA5             0196    
0B1BA5             0197    ; Storage for the arguments, ORDER MATTERS
0B1BA5             0198    arg1: ds 5
0B1BAA             0199    arg2: ds 5
0B1BAF             0200    
0B1BAF             0201    ; GLOBAL MESSAGE STRINGS
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF 
0B1BAF 55 73 61 67 0202    str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B1BC7 45 72 72 6F 0203    str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B1BD0 53 75 63 63 0204    str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1BDB             0205    
0B1BDB             0206    ; GLOBAL VARIABLES / DEFAULTS
0B1BDB             0207    ; ---- input arguments (float) ----
0B1BDB             0208    input_params_num: equ 7
0B1BDB             0209    input_params:
0B1BDB 81 1F 85 EB 0210    petals:             db   0x81, 0x1F, 0x85, 0xEB, 0x41 ; 3.03
       41          
0B1BE0 80 D7 A3 70 0211    vectors:            db   0x80, 0xD7, 0xA3, 0x70, 0x7D ; 1.98
       7D          
0B1BE5 7F 9A 99 99 0212    depth:              db   0x7F, 0x9A, 0x99, 0x99, 0x19 ; 0.6
       19          
0B1BEA 00 42 00 00 0213    periods:            db   0x00, 0x42, 0x00, 0x00, 0x00 ; 66.0
       00          
0B1BEF 7F CC CC CC 0214    shrink:             db   0x7F, 0xCC, 0xCC, 0xCC, 0x4C ; 0.8
       4C          
0B1BF4 00 00 02 00 0215    radius_scale: 	    db   0x00, 0x00, 0x02, 0x00, 0x00 ; 512.0
       00          
0B1BF9 00 00 00 00 0216    theta_init: 	    db   0x00, 0x00, 0x00, 0x00, 0x00 ; 0
       00          
0B1BFE             0217    
0B1BFE             0218    ; ---- main loop constants (float unless noted otherwise) ----
0B1BFE 00 00 00 00 0219    step_theta_prime:   blkb 5,0    ; Step increment for theta_prime in each loop iteration
       00          
0B1C03 00 00 00 00 0220    step_theta_petal:   blkb 5,0    ; Step increment for theta_petal in each loop iteration
       00          
0B1C08 00 00 00 00 0221    total_steps:        blkb 5,0    ; Total number of iterations based on periods and step_theta_prime
       00          
0B1C0D 00 00 00 00 0222    step_shrink:        blkb 5,0    ; Step decrement applied to radius in each iteration
       00          
0B1C12             0223    
0B1C12             0224    ; ---- main loop state variables (float) ----
0B1C12 00 00 00 00 0225    theta_prime: 	    blkb 5,0    ; Angle of the drawing cursor relative to the origin
       00          
0B1C17 00 00 00 00 0226    theta_petal: 	    blkb 5,0    ; Angle used to compute radius offset of the petal circle
       00          
0B1C1C 00 00 00 00 0227    radius_prime:       blkb 5,0    ; Initial radius before shrink factor is applied
       00          
0B1C21 00 00 00 00 0228    radius_petal:       blkb 5,0    ; Radius of the petal circle
       00          
0B1C26 00 00 00 00 0229    radius:             blkb 5,0    ; Total radius of the curve
       00          
0B1C2B 00 00 00 00 0230    x_prev:             blkb 5,0    ; Previous x coordinate
       00          
0B1C30 00 00 00 00 0231    y_prev:             blkb 5,0    ; Previous y coordinate
       00          
0B1C35             0232    
0B1C35             0233    ; ========= MAIN LOOP =========
0B1C35             0234    ; The main routine
0B1C35             0235    ; IXU: argv - pointer to array of parameters
0B1C35             0236    ;   C: argc - number of parameters
0B1C35             0237    ; Returns:
0B1C35             0238    ;  HL: Error code, or 0 if OK
0B1C35             0239    
0B1C35             0240    _main_init:
0B1C35 79          0241        ld a,c              ; how many arguments?
0B1C36 FE 01       0242        cp min_args         ; not enough?
0B1C38 30 23       0243        jr nc,main          ; if enough, go to main loop
0B1C3A 21 AF 1B 0B 0244        ld hl,str_usage     ; if not enough, print usage
0B1C3E CD BE 0E 0B 0245        call printString
0B1C42             0246                            ; fall through to _main_end_error
0B1C42             0247    
0B1C42             0248    _main_end_error:
0B1C42 21 C7 1B 0B 0249        ld hl,str_error     ; print error message
0B1C46 CD BE 0E 0B 0250        call printString
0B1C4A 21 13 00 00 0251        ld hl,19            ; return error code 19
0B1C4E C9          0252        ret
0B1C4F             0253    
0B1C4F             0254    ; begin BASIC-specific end code
0B1C4F             0255    ; This bit of code is called from STAR_BYE and returns us safely to MOS
0B1C4F ED 7B A2 1B 0256    _end:			LD		SP, (_sps)		; Restore the stack pointer
       0B          
0B1C54             0257    ; fall through to _main_end_ok
0B1C54             0258    ; end BASIC-specific end code
0B1C54             0259    
0B1C54             0260    _main_end_ok:
0B1C54             0261        ; call printNewLine
0B1C54             0262        ; ld hl,str_success   ; print success message
0B1C54             0263        ; call printString
0B1C54 CD D3 0E 0B 0264        call printNewLine
0B1C58 21 00 00 00 0265        ld hl,0             ; return 0 for success
0B1C5C C9          0266        ret
0B1C5D             0267    
0B1C5D             0268    ; ========= BEGIN CUSTOM MAIN LOOP =========
0B1C5D             0269    main:
0B1C5D 0D          0270        dec c               ; decrement the argument count to skip the program name
0B1C5E CD B4 1E 0B 0271        call load_input     ; load the input arguments
0B1C62 CD E8 16 0B 0272        call vdu_cls        ; clear the screen
0B1C66 CD D0 1E 0B 0273        call print_input    ; print the input arguments
0B1C6A             0274    
0B1C6A             0275    ; Set screen origin to the center
0B1C6A 01 80 02 00 0276        ld bc,1280/2 ; x
0B1C6E 11 00 02 00 0277        ld de,1024/2 ; y
0B1C72 CD 54 17 0B 0278        call vdu_set_gfx_origin
0B1C76             0279    
0B1C76             0280    ; --- convert input thetas to radians
0B1C76 FD 21 12 1C 0281        ld iy,theta_prime
       0B          
0B1C7B CD 00 15 0B 0282        call fetch_float_iy_nor
0B1C7F 3E 1B       0283        ld a,rad
0B1C81 CD D2 00 0B 0284        call FPP
0B1C85 CD EE 14 0B 0285        call store_float_iy_nor
0B1C89             0286    
0B1C89 FD 21 17 1C 0287        ld iy,theta_petal
       0B          
0B1C8E CD 00 15 0B 0288        call fetch_float_iy_nor
0B1C92 3E 1B       0289        ld a,rad
0B1C94 CD D2 00 0B 0290        call FPP
0B1C98 CD EE 14 0B 0291        call store_float_iy_nor
0B1C9C             0292    
0B1C9C FD 21 F9 1B 0293        ld iy,theta_init
       0B          
0B1CA1 CD 00 15 0B 0294        call fetch_float_iy_nor
0B1CA5 3E 1B       0295        ld a,rad
0B1CA7 CD D2 00 0B 0296        call FPP
0B1CAB CD EE 14 0B 0297        call store_float_iy_nor
0B1CAF             0298    
0B1CAF FD 21 12 1C 0299        ld iy,theta_prime ; set theta_prime to theta_init
       0B          
0B1CB4 CD EE 14 0B 0300        call store_float_iy_nor
0B1CB8             0301    
0B1CB8             0302    ; --- compute the main loop parameters ---
0B1CB8             0303    ; step_theta_prime = 2 * pi / (petals * vectors)
0B1CB8 FD 21 DB 1B 0304        ld iy,petals
       0B          
0B1CBD CD 00 15 0B 0305        call fetch_float_iy_nor
0B1CC1 FD 21 E0 1B 0306        ld iy,vectors
       0B          
0B1CC6 CD 24 15 0B 0307        call fetch_float_iy_alt
0B1CCA 3E 0A       0308        ld a,fmul
0B1CCC CD D2 00 0B 0309        call FPP ; HLH'L'C = petals * vectors
0B1CD0             0310    
0B1CD0 CD A0 16 0B 0311        call pi2_alt ; DED'E'B = 2 * pi
0B1CD4 CD F2 13 0B 0312        call SWAP ; HLH'L'C <--> DED'E'B
0B1CD8 3E 0F       0313        ld a,fdiv
0B1CDA CD D2 00 0B 0314        call FPP ; HLH'L'C = 2 * pi / (petals * vectors)
0B1CDE FD 21 FE 1B 0315        ld iy,step_theta_prime
       0B          
0B1CE3 CD EE 14 0B 0316        call store_float_iy_nor
0B1CE7             0317    
0B1CE7             0318    ; step_theta_petal = 2 * pi / vectors
0B1CE7 FD 21 E0 1B 0319        ld iy,vectors
       0B          
0B1CEC CD 00 15 0B 0320        call fetch_float_iy_nor
0B1CF0 CD A0 16 0B 0321        call pi2_alt ; DED'E'B = 2 * pi
0B1CF4 CD F2 13 0B 0322        call SWAP ; HLH'L'C <--> DED'E'B
0B1CF8 3E 0F       0323        ld a,fdiv
0B1CFA CD D2 00 0B 0324        call FPP ; HLH'L'C = 2 * pi / vectors
0B1CFE             0325    ; fmod rounds to the nearest integer, so we leave it out until we can find a better solution
0B1CFE             0326        ; call pi2_alt ; DED'E'B = 2 * pi
0B1CFE             0327        ; ld a,fmod
0B1CFE             0328        ; call FPP ; HLH'L'C = 2 * pi % vectors
0B1CFE FD 21 03 1C 0329        ld iy,step_theta_petal
       0B          
0B1D03 CD EE 14 0B 0330        call store_float_iy_nor
0B1D07             0331    
0B1D07             0332    ; total_steps = int(petals * vectors * periods)
0B1D07 FD 21 DB 1B 0333        ld iy,petals
       0B          
0B1D0C CD 00 15 0B 0334        call fetch_float_iy_nor
0B1D10 FD 21 E0 1B 0335        ld iy,vectors
       0B          
0B1D15 CD 24 15 0B 0336        call fetch_float_iy_alt
0B1D19 3E 0A       0337        ld a,fmul
0B1D1B CD D2 00 0B 0338        call FPP ; HLH'L'C = petals * vectors
0B1D1F             0339    
0B1D1F FD 21 EA 1B 0340        ld iy,periods
       0B          
0B1D24 CD 24 15 0B 0341        call fetch_float_iy_alt
0B1D28 3E 0A       0342        ld a,fmul
0B1D2A CD D2 00 0B 0343        call FPP ; HLH'L'C = petals * vectors * periods
0B1D2E FD 21 08 1C 0344        ld iy,total_steps
       0B          
0B1D33 CD EE 14 0B 0345        call store_float_iy_nor ; we'll make it an integer after computing step_shrink
0B1D37             0346    
0B1D37             0347    ; Initialize radius_prime accounting for depth
0B1D37             0348        LOAD_FLOAT "1"
                       M1 Args: ARG="1" 
0B1D37 DD 21 42 1D 0001M1      ld ix,$+11
       0B          
0B1D3C CD FA 13 0B 0002M1      call val_fp ; convert the string to a float
0B1D40 DD E9       0003M1      jp (ix)
0B1D42 31 00       0004M1      asciz ARG
0B1D44 FD 21 E5 1B 0349        ld iy,depth
       0B          
0B1D49 CD 24 15 0B 0350        call fetch_float_iy_alt
0B1D4D 3E 0B       0351        ld a,fadd
0B1D4F CD D2 00 0B 0352        call FPP ; HLH'L'C = 1 + depth
0B1D53 CD F2 13 0B 0353        call SWAP ; DED'E'B = 1 + depth
0B1D57 FD 21 F4 1B 0354        ld iy,radius_scale
       0B          
0B1D5C CD 00 15 0B 0355        call fetch_float_iy_nor
0B1D60 3E 0F       0356        ld a,fdiv
0B1D62 CD D2 00 0B 0357        call FPP ; HLH'L'C = radius_scale / (1 + depth)
0B1D66 FD 21 1C 1C 0358        ld iy,radius_prime
       0B          
0B1D6B CD EE 14 0B 0359        call store_float_iy_nor
0B1D6F             0360    
0B1D6F             0361    ; Calculate shrink per step (linear)
0B1D6F             0362        ; step_shrink = -shrink * radius_scale / total_steps
0B1D6F FD 21 EF 1B 0363        ld iy,shrink
       0B          
0B1D74 CD 24 15 0B 0364        call fetch_float_iy_alt
0B1D78 3E 0A       0365        ld a,fmul
0B1D7A CD D2 00 0B 0366        call FPP ; HLH'L'C = shrink * radius_prime
0B1D7E FD 21 08 1C 0367        ld iy,total_steps
       0B          
0B1D83 CD 24 15 0B 0368        call fetch_float_iy_alt
0B1D87 3E 0F       0369        ld a,fdiv
0B1D89 CD D2 00 0B 0370        call FPP ; HLH'L'C = shrink * radius_scale / total_steps
0B1D8D             0371    
0B1D8D             0372        ; call NEG_ ; HLH'L'C = -shrink * radius_scale / total_steps
0B1D8D             0373    ; NEG_ is not working as expected, so we'll just subtract from zero
0B1D8D CD F2 13 0B 0374        call SWAP
0B1D91             0375        LOAD_FLOAT "0"
                       M1 Args: ARG="0" 
0B1D91 DD 21 9C 1D 0001M1      ld ix,$+11
       0B          
0B1D96 CD FA 13 0B 0002M1      call val_fp ; convert the string to a float
0B1D9A DD E9       0003M1      jp (ix)
0B1D9C 30 00       0004M1      asciz ARG
0B1D9E 3E 0D       0376        ld a,fsub
0B1DA0 CD D2 00 0B 0377        call FPP ; HLH'L'C = -shrink * radius_scale / total_steps
0B1DA4 FD 21 0D 1C 0378        ld iy,step_shrink
       0B          
0B1DA9 CD EE 14 0B 0379        call store_float_iy_nor
0B1DAD             0380    
0B1DAD             0381    ; Make total_steps an integer and store it in uhl
0B1DAD FD 21 08 1C 0382        ld iy,total_steps
       0B          
0B1DB2 CD 00 15 0B 0383        call fetch_float_iy_nor
0B1DB6 CD 26 14 0B 0384        call int2hlu ; UHL = int(total_steps)
0B1DBA FD 2F 00    0385        ld (iy),hl
0B1DBD             0386    
0B1DBD             0387    ; set initial point and move graphics cursor to it
0B1DBD CD 66 1E 0B 0388        call calc_point ; HLH'L'C = x DED'E'B = y
0B1DC1             0389    
0B1DC1 3E 44       0390        ld a,plot_pt+mv_abs
0B1DC3 CD 3C 1E 0B 0391        call vdu_plot_float
0B1DC7             0392    
0B1DC7             0393    ; fall through to main loop
0B1DC7             0394    
0B1DC7             0395    @loop:
0B1DC7             0396    ; Advance thetas
0B1DC7             0397        ; theta_prime += step_theta_prime
0B1DC7 FD 21 FE 1B 0398        ld iy,step_theta_prime
       0B          
0B1DCC CD 00 15 0B 0399        call fetch_float_iy_nor
0B1DD0 FD 21 12 1C 0400        ld iy,theta_prime
       0B          
0B1DD5 CD 24 15 0B 0401        call fetch_float_iy_alt
0B1DD9 3E 0B       0402        ld a,fadd
0B1DDB CD D2 00 0B 0403        call FPP ; HLH'L'C = theta_prime + step_theta_prime
0B1DDF CD EE 14 0B 0404        call store_float_iy_nor ; theta_prime
0B1DE3             0405    
0B1DE3             0406        ; theta_petal += step_theta_petal
0B1DE3 FD 21 03 1C 0407        ld iy,step_theta_petal
       0B          
0B1DE8 CD 00 15 0B 0408        call fetch_float_iy_nor
0B1DEC FD 21 17 1C 0409        ld iy,theta_petal
       0B          
0B1DF1 CD 24 15 0B 0410        call fetch_float_iy_alt
0B1DF5 3E 0B       0411        ld a,fadd
0B1DF7 CD D2 00 0B 0412        call FPP ; HLH'L'C = theta_petal + step_theta_petal
0B1DFB CD EE 14 0B 0413        call store_float_iy_nor ; theta_petal
0B1DFF             0414    
0B1DFF             0415    ; Update radius_prime
0B1DFF             0416        ; radius_prime += step_shrink
0B1DFF FD 21 0D 1C 0417        ld iy,step_shrink
       0B          
0B1E04 CD 00 15 0B 0418        call fetch_float_iy_nor
0B1E08 FD 21 1C 1C 0419        ld iy,radius_prime
       0B          
0B1E0D CD 24 15 0B 0420        call fetch_float_iy_alt
0B1E11 3E 0B       0421        ld a,fadd
0B1E13 CD D2 00 0B 0422        call FPP ; HLH'L'C = radius_prime + step_shrink
0B1E17 CD EE 14 0B 0423        call store_float_iy_nor ; radius_prime
0B1E1B             0424    
0B1E1B             0425    ; Calculate new coordinates and draw a line from the previous point
0B1E1B CD 66 1E 0B 0426        call calc_point ; HLH'L'C = x DED'E'B = y
0B1E1F 3E 05       0427        ld a,plot_sl_both+dr_abs_fg ; plot mode
0B1E21 CD 3C 1E 0B 0428        call vdu_plot_float
0B1E25             0429    
0B1E25             0430    ; Decrement the loop counter
0B1E25 2A 08 1C 0B 0431        ld hl,(total_steps)
0B1E29 11 FF FF FF 0432        ld de,-1
0B1E2D A7          0433        and a ; clear carry
0B1E2E ED 5A       0434        adc hl,de
0B1E30 22 08 1C 0B 0435        ld (total_steps),hl
0B1E34 F2 C7 1D 0B 0436        jp p,@loop
0B1E38             0437    
0B1E38 C3 54 1C 0B 0438        jp _main_end_ok
0B1E3C             0439    
0B1E3C             0440    ; VDU 25, mode, x; y;: PLOT command
0B1E3C             0441    ; inputs: a=mode, HL'H'L'C=x, DE'D'E'B=y
0B1E3C             0442    vdu_plot_float:
0B1E3C 32 60 1E 0B 0443        ld (@mode),a
0B1E40             0444    
0B1E40 CD 26 14 0B 0445        call int2hlu
0B1E44 22 61 1E 0B 0446        ld (@x0),hl
0B1E48             0447    
0B1E48 CD F2 13 0B 0448        call SWAP
0B1E4C CD 26 14 0B 0449        call int2hlu
0B1E50 22 63 1E 0B 0450        ld (@y0),hl
0B1E54             0451    
0B1E54 21 5F 1E 0B 0452    	ld hl,@cmd
0B1E58 01 06 00 00 0453    	ld bc,@end-@cmd
0B1E5C 5B DF       0454    	rst.lil $18
0B1E5E C9          0455    	ret
0B1E5F 19          0456    @cmd:   db 25
0B1E60 00          0457    @mode:  db 0
0B1E61 00 00       0458    @x0: 	dw 0
0B1E63 00 00       0459    @y0: 	dw 0
0B1E65 00          0460    @end:   db 0 ; padding
0B1E66             0461    
0B1E66             0462    ; compute the Cartesian coordinates of the next point on the curve
0B1E66             0463    ; inputs: theta_prime, theta_petal, radius_prime, depth
0B1E66             0464    ; outputs: HLH'L'C = x, DED'E'B = y
0B1E66             0465    calc_point:
0B1E66             0466    ; Calculate the petal radius and total radius
0B1E66             0467        ; radius_petal = math.cos(theta_petal) * depth
0B1E66 FD 21 17 1C 0468        ld iy,theta_petal
       0B          
0B1E6B CD 00 15 0B 0469        call fetch_float_iy_nor
0B1E6F 3E 14       0470        ld a,cos
0B1E71 CD D2 00 0B 0471        call FPP ; HLH'L'C = cos(theta_petal)
0B1E75 FD 21 E5 1B 0472        ld iy,depth
       0B          
0B1E7A CD 24 15 0B 0473        call fetch_float_iy_alt
0B1E7E 3E 0A       0474        ld a,fmul
0B1E80 CD D2 00 0B 0475        call FPP ; HLH'L'C = radius_petal
0B1E84             0476    
0B1E84             0477        ; radius = radius_prime + radius_petal * radius_prime
0B1E84 FD 21 1C 1C 0478        ld iy,radius_prime
       0B          
0B1E89 CD 24 15 0B 0479        call fetch_float_iy_alt
0B1E8D 3E 0A       0480        ld a,fmul
0B1E8F CD D2 00 0B 0481        call FPP ; HLH'L'C = radius_petal * radius_prime
0B1E93 FD 21 1C 1C 0482        ld iy,radius_prime
       0B          
0B1E98 CD 24 15 0B 0483        call fetch_float_iy_alt
0B1E9C 3E 0B       0484        ld a,fadd
0B1E9E CD D2 00 0B 0485        call FPP ; HLH'L'C = radius
0B1EA2 CD F2 13 0B 0486        call SWAP ; DED'E'B = radius
0B1EA6             0487    
0B1EA6             0488    ; Convert polar to Cartesian coordinates
0B1EA6 FD 21 12 1C 0489        ld iy,theta_prime
       0B          
0B1EAB CD 00 15 0B 0490        call fetch_float_iy_nor ; HLH'L'C = theta_prime
0B1EAF CD 3F 14 0B 0491        call polar_to_cartesian_fpp ; HLH'L'C = x, DED'E'B = y
0B1EB3             0492    
0B1EB3 C9          0493        ret
0B1EB4             0494    
0B1EB4             0495    ; --- Load arguments ---
0B1EB4             0496    ; --------------------------------
0B1EB4             0497    load_input:
0B1EB4 06 07       0498        ld b,input_params_num ; loop counter assuming correct number of arguments were entered
0B1EB6 79          0499        ld a,c ; number of arguments entered
0B1EB7 90          0500        sub b ; compare expected with entered
0B1EB8 F2 BF 1E 0B 0501        jp p,@F ; entered arguments >= expected, so proceed ignoring any excess arguments
0B1EBC 80          0502        add a,b ; set loop counter to entered arguments
0B1EBD C8          0503        ret z ; no arguments entered so return, leaving all to defaults
0B1EBE 47          0504        ld b,a
0B1EBF             0505    @@:
0B1EBF FD 21 DB 1B 0506        ld iy,input_params  ; point to the arguments table
       0B          
0B1EC4             0507    @loop:
0B1EC4 C5          0508        push bc ; save the loop counter
0B1EC5 CD AD 1F 0B 0509        call store_arg_iy_float ; get the next argument and store it
0B1EC9 ED 33 05    0510        lea iy,iy+5  ; point to the next parameter
0B1ECC C1          0511        pop bc ; get back the loop counter
0B1ECD 10 F5       0512        djnz @loop ; loop until done
0B1ECF C9          0513        ret
0B1ED0             0514    
0B1ED0             0515    print_input:
0B1ED0 06 07       0516        ld b,input_params_num ; loop counter = number of arguments
0B1ED2 FD 21 DB 1B 0517        ld iy,input_params  ; point to the arguments table
       0B          
0B1ED7             0518    @loop:
0B1ED7 C5          0519        push bc ; save the loop counter
0B1ED8 CD 00 15 0B 0520        call fetch_float_iy_nor ; fetch the next parameter into HLH'L'C
0B1EDC CD 38 16 0B 0521        call print_float_dec_nor ; print the parameter
0B1EE0 3E 20       0522        ld a,' ' ; print a space separator
0B1EE2 5B D7       0523        rst.lil $10
0B1EE4 ED 33 05    0524        lea iy,iy+5  ; point to the next parameter
0B1EE7 C1          0525        pop bc ; get back the loop counter
0B1EE8 10 ED       0526        djnz @loop ; loop until done
0B1EEA C9          0527        ret
0B1EEB             0528    
0B1EEB             0529    ; --- Specific parameter processing functions ---
0B1EEB             0530    args_count_off:
0B1EEB 21 F7 1E 0B 0531        ld hl,@str_args_count_off
0B1EEF CD BE 0E 0B 0532        call printString
0B1EF3 C3 42 1C 0B 0533        jp _main_end_error
0B1EF7 41 72 67 75 0534    @str_args_count_off: db "Argument counts mismatch!\r\n",0
       6D 65 6E 74 
       20 63 6F 75 
       6E 74 73 20 
       6D 69 73 6D 
       61 74 63 68 
       21 0D 0A 00 
0B1F13             0535    
0B1F13             0536    ; ---- text strings ----
0B1F13 73 74 65 70 0537    str_step_theta_prime: ASCIZ "step_theta_prime: "
       5F 74 68 65 
       74 61 5F 70 
       72 69 6D 65 
       3A 20 00    
0B1F26 73 74 65 70 0538    str_step_theta_petal: ASCIZ "step_theta_petal: "
       5F 74 68 65 
       74 61 5F 70 
       65 74 61 6C 
       3A 20 00    
0B1F39 74 6F 74 61 0539    str_total_steps: ASCIZ "total_steps: "
       6C 5F 73 74 
       65 70 73 3A 
       20 00       
0B1F47 73 74 65 70 0540    str_step_shrink: ASCIZ "step_shrink: "
       5F 73 68 72 
       69 6E 6B 3A 
       20 00       
0B1F55             0541    
0B1F55 74 68 65 74 0542    str_theta_prime: ASCIZ "theta_prime: "
       61 5F 70 72 
       69 6D 65 3A 
       20 00       
0B1F63 72 61 64 69 0543    str_radius_prime: ASCIZ "radius_prime: "
       75 73 5F 70 
       72 69 6D 65 
       3A 20 00    
0B1F72 72 61 64 69 0544    str_radius_petal: ASCIZ "radius_petal: "
       75 73 5F 70 
       65 74 61 6C 
       3A 20 00    
0B1F81 74 68 65 74 0545    str_theta_petal: ASCIZ "theta_petal: "
       61 5F 70 65 
       74 61 6C 3A 
       20 00       
0B1F8F             0546    
0B1F8F 72 61 64 69 0547    str_radius: ASCIZ "radius: "
       75 73 3A 20 
       00          
0B1F98 78 2C 79 3A 0548    str_xy: ASCIZ "x,y: "
       20 00       
0B1F9E             0549    
0B1F9E             0550    ; ========== HELPER FUNCTIONS ==========
0B1F9E             0551    ;
0B1F9E             0552    ; get the next argument after ix as a floating point number
0B1F9E             0553    ; inputs: ix = pointer to the argument string
0B1F9E             0554    ; outputs: HLH'L'C = floating point number, ix points to the next argument
0B1F9E             0555    ; destroys: everything except iy, including prime registers
0B1F9E             0556    get_arg_float:
0B1F9E ED 32 03    0557        lea ix,ix+3 ; point to the next argument
0B1FA1 DD E5       0558        push ix ; preserve
0B1FA3 DD 37 00    0559        ld ix,(ix)  ; point to argument string
0B1FA6 CD FA 13 0B 0560        call val_fp ; convert the string to a float
0B1FAA DD E1       0561        pop ix ; restore
0B1FAC C9          0562        ret ; return with the value in HLH'L'C
0B1FAD             0563    
0B1FAD             0564    ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
0B1FAD             0565    ; inputs: ix = pointer to the argument string
0B1FAD             0566    ; outputs: HLH'L'C = floating point number, ix points to the next argument
0B1FAD             0567    ; destroys: everything except iy, including prime registers
0B1FAD             0568    store_arg_iy_float:
0B1FAD ED 32 03    0569        lea ix,ix+3 ; point to the next argument
0B1FB0 DD E5       0570        push ix ; preserve
0B1FB2 DD 37 00    0571        ld ix,(ix)  ; point to argument string
0B1FB5 CD FA 13 0B 0572        call val_fp ; convert the string to a float
0B1FB9 CD EE 14 0B 0573        call store_float_iy_nor ; save the float in buffer
0B1FBD DD E1       0574        pop ix ; restore
0B1FBF C9          0575        ret ; return with the value in HLH'L'C
0B1FC0             0576    ;
0B1FC0             0577    ; get the next argument after ix as a string
0B1FC0             0578    ; inputs: ix = pointer to the argument string
0B1FC0             0579    ; outputs: HL = pointer to the argument string, ix points to the next argument
0B1FC0             0580    ; destroys: a, h, l, f
0B1FC0             0581    get_arg_text:
0B1FC0 ED 32 03    0582        lea ix,ix+3 ; point to the next argument
0B1FC3 DD 27 00    0583        ld hl,(ix)  ; get the argument string
0B1FC6 C9          0584        ret
0B1FC7             0585    ;
0B1FC7             0586    ; match the next argument after ix to the dispatch table at iy
0B1FC7             0587    ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1FC7             0588    ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1FC7             0589    ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1FC7             0590    ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B1FC7             0591    ; destroys: a, hl, de, ix, iy, flags
0B1FC7             0592    match_next:
0B1FC7 ED 32 03    0593        lea ix,ix+3         ; point to the next argument
0B1FCA             0594    @loop:
0B1FCA FD 27 00    0595        ld hl,(iy)          ; pointer argument dispatch record
0B1FCD             0596        sign_hlu            ; check for list terminator
                       M1 Args: none
0B1FCD 19          0001M1      add hl,de ; 1 cycle
0B1FCE B7          0002M1      or a ; clear flags ; 1 cycle
0B1FCF ED 52       0003M1      sbc hl,de ; 2 cycles
0B1FD1             0004M1      ; 4 cycles total
0B1FD1 CA E9 1F 0B 0597        jp z,@no_match      ; if a=0, return error
0B1FD5 23          0598        inc hl              ; skip over jp instruction
0B1FD6 23          0599        inc hl
0B1FD7 DD 17 00    0600        ld de,(ix)          ; pointer to the argument string
0B1FDA CD 00 20 0B 0601        call str_equal      ; compare the argument to the dispatch table entry
0B1FDE CA EB 1F 0B 0602        jp z,@match         ; if equal, return success
0B1FE2 ED 33 03    0603        lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1FE5 C3 CA 1F 0B 0604        jp @loop            ; and loop
0B1FE9             0605    @no_match:
0B1FE9 3C          0606        inc a               ; no match so return a=1 and zero flag reset
0B1FEA C9          0607        ret
0B1FEB             0608    @match:
0B1FEB FD 37 00    0609        ld iy,(iy)          ; get the function pointer
0B1FEE C9          0610        ret                 ; return a=0 and zero flag set
0B1FEF             0611    
0B1FEF             0612    ; same as match_next, but prints the parameter if a match is found
0B1FEF             0613    match_next_and_print:
0B1FEF CD C7 1F 0B 0614        call match_next
0B1FF3 C0          0615        ret nz ; no match found
0B1FF4 ED 32 FD    0616        lea ix,ix-3
0B1FF7 CD C0 1F 0B 0617        call get_arg_text ; hl points to the operator string
0B1FFB CD 0B 20 0B 0618        call print_param
0B1FFF C9          0619        ret
0B2000             0620    
0B2000             0621    ; compare two zero-terminated strings for equality, case-sensitive
0B2000             0622    ; hl: pointer to first string, de: pointer to second string
0B2000             0623    ; returns: z if equal, nz if not equal
0B2000             0624    ; destroys: a, hl, de
0B2000             0625    str_equal:
0B2000 1A          0626        ld a,(de)           ; get the first character
0B2001 BE          0627        cp (hl)             ; compare to the second character
0B2002 C0          0628        ret nz              ; if not equal, return
0B2003 B7          0629        or a
0B2004 C8          0630        ret z               ; if equal and zero, return
0B2005 23          0631        inc hl              ; next character
0B2006 13          0632        inc de
0B2007 C3 00 20 0B 0633        jp str_equal        ; loop until end of string
0B200B             0634    
0B200B             0635    ; print the parameter string pointed to by ix
0B200B             0636    ; destroys: a, hl
0B200B             0637    print_param:
0B200B DD 27 00    0638        ld hl,(ix)          ; get the parameter pointer
0B200E CD BE 0E 0B 0639        call printString    ; print the parameter string
0B2012 3E 20       0640        ld a,' '            ; print a space separator
0B2014 5B D7       0641        rst.lil $10
0B2016 C9          0642        ret
0B2017             0643    
0B2017             0644    ; print the parameters
0B2017             0645    ; inputs: b = number of parameters, ix = pointer to the parameters
0B2017             0646    ; destroys: a, hl, bc
0B2017             0647    print_params:
0B2017 41          0648        ld b,c              ; loop counter = number of parameters
0B2018 DD E5       0649        push ix             ; save the pointer to the parameters
0B201A             0650    @loop:
0B201A C5          0651        push bc             ; save the loop counter
0B201B CD 0B 20 0B 0652        call print_param    ; print the parameter
0B201F ED 32 03    0653        lea ix,ix+3         ; next parameter pointer
0B2022 C1          0654        pop bc              ; get back the loop counter
0B2023 10 F5       0655        djnz @loop          ; loop until done
0B2025 DD E1       0656        pop ix              ; restore the pointer to the parameters
0B2027 C9          0657        ret
0B2028             0658    
0B2028             0659        include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
0B2028             0001*   ;
0B2028             0002*   ; Title:	BBC Basic Interpreter - Z80 version
0B2028             0003*   ;		RAM Module for BBC Basic Interpreter
0B2028             0004*   ;		For use with Version 2.0 of BBC BASIC
0B2028             0005*   ;		Standard CP/M Distribution Version
0B2028             0006*   ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0B2028             0007*   ; Modified By:	Dean Belfield
0B2028             0008*   ; Created:	12/05/2023
0B2028             0009*   ; Last Updated:	26/06/2023
0B2028             0010*   ;
0B2028             0011*   ; Modinfo:
0B2028             0012*   ; 06/06/2023:	Modified to run in ADL mode
0B2028             0013*   ; 26/06/2023:	Added temporary stores R0 and R1
0B2028             0014*   
0B2028             0015*   			; .ASSUME	ADL = 1
0B2028             0016*   
0B2028             0017*   			; DEFINE	LORAM, SPACE = ROM
0B2028             0018*   			; SEGMENT LORAM
0B2028             0019*   
0B2028             0020*   			; XDEF	ACCS
0B2028             0021*   			; XDEF	BUFFER
0B2028             0022*   			; XDEF	STAVAR
0B2028             0023*   			; XDEF	DYNVAR
0B2028             0024*   			; XDEF	FNPTR
0B2028             0025*   			; XDEF	PROPTR
0B2028             0026*   			; XDEF	PAGE_
0B2028             0027*   			; XDEF	TOP
0B2028             0028*   			; XDEF	LOMEM
0B2028             0029*   			; XDEF 	FREE
0B2028             0030*   			; XDEF	HIMEM
0B2028             0031*   			; XDEF	LINENO
0B2028             0032*   			; XDEF	TRACEN
0B2028             0033*   			; XDEF	AUTONO
0B2028             0034*   			; XDEF	ERRTRP
0B2028             0035*   			; XDEF	ERRTXT
0B2028             0036*   			; XDEF	DATPTR
0B2028             0037*   			; XDEF	ERL
0B2028             0038*   			; XDEF	ERRLIN
0B2028             0039*   			; XDEF	RANDOM
0B2028             0040*   			; XDEF	COUNT
0B2028             0041*   			; XDEF	WIDTH
0B2028             0042*   			; XDEF	ERR
0B2028             0043*   			; XDEF	LISTON
0B2028             0044*   			; XDEF	INCREM
0B2028             0045*   
0B2028             0046*   			; XDEF	FLAGS
0B2028             0047*   			; XDEF	OSWRCHPT
0B2028             0048*   			; XDEF	OSWRCHCH
0B2028             0049*   			; XDEF	OSWRCHFH
0B2028             0050*   			; XDEF	KEYDOWN
0B2028             0051*   			; XDEF	KEYASCII
0B2028             0052*   			; XDEF	KEYCOUNT
0B2028             0053*   
0B2028             0054*   			; XDEF	R0
0B2028             0055*   			; XDEF	R1
0B2028             0056*   
0B2028             0057*   			; XDEF	RAM_START
0B2028             0058*   			; XDEF	RAM_END
0B2028             0059*   			; XDEF	USER
0B2028             0060*   
0B2028             0061*   end_binary: ;  for assemble.py to know where to truncate the binary file
0B2028             0062*   			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
0B2100             0063*   RAM_START:
0B2100             0064*   ;
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B2100 00 00 00 00 0065*   ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B2200 00 00 00 00 0066*   BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B2300 00 00 00 00 0067*   STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B236C 00 00 00 00 0068*   DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
0B240E 00 00 00    0069*   FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
0B2411 00 00 00    0070*   PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
0B2414             0071*   ;
0B2414 00 00 00    0072*   PAGE_:          BLKB    3,0               ; Start of User Program
0B2417 00 00 00    0073*   TOP:            BLKB    3,0               ; First Location after User Program
0B241A 00 00 00    0074*   LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
0B241D 00 00 00    0075*   FREE:           BLKB    3,0               ; First Free Space Byte
0B2420 00 00 00    0076*   HIMEM:          BLKB    3,0               ; First Protected Byte
0B2423             0077*   ;
0B2423 00 00 00    0078*   LINENO:         BLKB    3,0               ; Line Number
0B2426 00 00 00    0079*   TRACEN:         BLKB    3,0               ; Trace Flag
0B2429 00 00 00    0080*   AUTONO:         BLKB    3,0               ; Auto Flag
0B242C 00 00 00    0081*   ERRTRP:         BLKB    3,0               ; Error Trap
0B242F 00 00       0082*   ERRTXT:         BLKB    2,0               ; Error Message Pointer
0B2431 00 00       0083*   DATPTR:         BLKB    2,0               ; Data Pointer
0B2433 00 00       0084*   ERL:            BLKB    2,0               ; Error Line
0B2435 00 00 00    0085*   ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
0B2438 00 00 00 00 0086*   RANDOM:         BLKB    5,0               ; Random Number
       00          
0B243D 00          0087*   COUNT:          BLKB    1,0               ; Print Position
0B243E 00          0088*   WIDTH:          BLKB    1,0               ; Print Width
0B243F 00          0089*   ERR:            BLKB    1,0               ; Error Number
0B2440 00          0090*   LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
0B2441             0091*                                   ; - BIT 0: If set, output a space after the line number
0B2441             0092*                                   ; - BIT 1: If set, then indent FOR/NEXT loops
0B2441             0093*                                   ; - BIT 2: If set, then indent REPEAT/UNTIL loops
0B2441             0094*                                   ; - BIT 3: If set, then output to buffer for *EDIT
0B2441             0095*                                   ; OPT FLAG (top nibble)
0B2441             0096*                                   ; - BIT 4: If set, then list whilst assembling
0B2441             0097*                                   ; - BIT 5: If set, then assembler errors are reported
0B2441             0098*                                   ; - BIT 6: If set, then place the code starting at address pointed to by O%
0B2441             0099*                                   ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B2441 00          0100*   INCREM:         BLKB    1,0               ; Auto-Increment Value
0B2442             0101*   ;
0B2442             0102*   ; --------------------------------------------------------------------------------------------
0B2442             0103*   ; BEGIN MODIFIED CODE
0B2442             0104*   ; --------------------------------------------------------------------------------------------
0B2442             0105*   ; Originally in equs.inc
0B2442             0106*   ;
0B2442             0107*   OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
0B2442             0108*   PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
0B2442             0109*   VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
0B2442             0110*   ; --------------------------------------------------------------------------------------------
0B2442             0111*   ; END MODIFIED CODE
0B2442             0112*   ; --------------------------------------------------------------------------------------------
0B2442             0113*   
0B2442             0114*   ; Extra Agon-implementation specific system variables
0B2442             0115*   ;
0B2442 00          0116*   FLAGS:          BLKB    1,0       ; Miscellaneous flags
0B2443             0117*                                   ; - BIT 7: Set if ESC pressed
0B2443             0118*                                   ; - BIT 6: Set to disable ESC
0B2443 00 00       0119*   OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
0B2445 00          0120*   OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
0B2446             0121*                                   ; - 0: Console
0B2446             0122*                                   ; - 1: File
0B2446 00          0123*   OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
0B2447 00          0124*   KEYDOWN:        BLKB    1,0       ; Keydown flag
0B2448 00          0125*   KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
0B2449 00          0126*   KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
0B244A 00 00 00    0127*   R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
0B244D 00 00 00    0128*   R1:             BLKB    3,0
0B2450             0129*   
0B2450             0130*   ;
0B2450             0131*   ; This must be at the end
0B2450             0132*   ;
0B2450             0133*   RAM_END:
0B2450             0134*   			ALIGN	256
0B2500             0135*   USER:							; Must be aligned on a page boundary
0B2500             0136*   
