PC     Output      Line
040000             0001       ASSUME ADL = 1
040000             0002       ; INCLUDE "mos_api.inc"
040000             0003       ORG 0x0B0000 ; Is a moslet
0B0000 C3 45 00 0B 0004       JP _start
0B0004             0005   
0B0004 63 61 6C 63 0006   _exec_name: ASCIZ "calcbas"
       62 61 73 00 
0B000C FF FF FF FF 0007       ALIGN 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040 4D 4F 53    0008       DB "MOS" ; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0009       DB 00h ; MOS header version 0
0B0044 01          0010       DB 01h ; Flag for run mode (0: Z80, 1: ADL)
0B0045             0011   _start:
0B0045 F5          0012       PUSH AF ; Preserve the registers
0B0046 C5          0013       PUSH BC
0B0047 D5          0014       PUSH DE
0B0048 DD E5       0015       PUSH IX
0B004A FD E5       0016       PUSH IY
0B004C ED 6E       0017       LD A, MB ; Save MB
0B004E F5          0018       PUSH AF
0B004F AF          0019       XOR A
0B0050 ED 6D       0020       LD MB, A ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0021   
0B0052 DD 21 B9 00 0022       LD IX, argv_ptrs ; The argv array pointer address
       0B          
0B0057 DD E5       0023       PUSH IX
0B0059 CD 70 00 0B 0024       CALL _parse_params ; Parse the parameters
0B005D DD E1       0025       POP IX ; IX: argv
0B005F 06 00       0026       LD B, 0 ; C: argc
0B0061 CD 66 0E 0B 0027       CALL _main_init ; Start user code
0B0065             0028   
0B0065 F1          0029       POP AF
0B0066 ED 6D       0030       LD MB, A
0B0068 FD E1       0031       POP IY ; Restore registers
0B006A DD E1       0032       POP IX
0B006C D1          0033       POP DE
0B006D C1          0034       POP BC
0B006E F1          0035       POP AF
0B006F C9          0036       RET
0B0070             0037   
0B0070             0038   ; Parse the parameter string into a C array
0B0070             0039   ; Parameters
0B0070             0040   ; - HL: Address of parameter string
0B0070             0041   ; - IX: Address for array pointer storage
0B0070             0042   ; Returns:
0B0070             0043   ; -  C: Number of parameters parsed
0B0070             0044   ;
0B0070 01 04 00 0B 0045   _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0046   			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0047   			LEA     IX, IX+3
0B007A CD B2 00 0B 0048   			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0049   ;
0B007E 01 01 00 00 0050   			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0051   			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0052   ;
0B0084             0053   _parse_params_1:
0B0084 C5          0054   			PUSH	BC			; Stack ARGC
0B0085 E5          0055   			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0056   			CALL	_get_token		; Get the next token
0B008A 79          0057   			LD	A, C			; A: Length of the token in characters
0B008B D1          0058   			POP	DE			; Start address of token (was in HL)
0B008C C1          0059   			POP	BC			; ARGC
0B008D B7          0060   			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0061   			RET	Z
0B008F             0062   ;
0B008F DD 1F 00    0063   			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0064   			PUSH	HL			; DE=HL
0B0093 D1          0065   			POP	DE
0B0094 CD B2 00 0B 0066   			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0067   			XOR	A
0B0099 12          0068   			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0069   			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0070   			INC	C			; Increment ARGC
0B009E 79          0071   			LD	A, C			; Check for C >= A
0B009F B8          0072   			CP	B
0B00A0 38 E2       0073   			JR	C, _parse_params_1	; And loop
0B00A2 C9          0074   			RET
0B00A3             0075   
0B00A3             0076   ; Get the next token
0B00A3             0077   ; Parameters:
0B00A3             0078   ; - HL: Address of parameter string
0B00A3             0079   ; Returns:
0B00A3             0080   ; - HL: Address of first character after token
0B00A3             0081   ; -  C: Length of token (in characters)
0B00A3             0082   ;
0B00A3 0E 00       0083   _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0084   @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0085   			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0086   			RET 	Z
0B00A8 FE 0D       0087   			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0088   			RET	Z
0B00AB FE 20       0089   			CP	' '			; Exit if space (end of token)
0B00AD C8          0090   			RET	Z
0B00AE 23          0091   			INC	HL			; Advance to next character
0B00AF 0C          0092   			INC 	C			; Increment length
0B00B0 18 F3       0093   			JR	@B
0B00B2             0094   
0B00B2             0095   ; Skip spaces in the parameter string
0B00B2             0096   ; Parameters:
0B00B2             0097   ; - HL: Address of parameter string
0B00B2             0098   ; Returns:
0B00B2             0099   ; - HL: Address of next none-space character
0B00B2             0100   ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0101   ;
0B00B2 7E          0102   _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0103   			CP	' '			; Exit if not space
0B00B5 C0          0104   			RET	NZ
0B00B6 23          0105   			INC	HL			; Advance to next character
0B00B7 18 F9       0106   			JR	_skip_spaces		; Increment length
0B00B9             0107   
0B00B9             0108   ; Storage for the argv array pointers
0B00B9             0109   min_args: equ 1
0B00B9             0110   argv_ptrs_max: EQU 16 ; Maximum number of arguments allowed in argv
0B00B9 00 00 00 00 0111   argv_ptrs: BLKP argv_ptrs_max,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0112   
0B00E9             0113   ; ========================================
0B00E9             0114   ; BEGIN APPLICATION CODE
0B00E9             0115   ; ========================================
0B00E9             0116   
0B00E9             0117   ; API INCLUDES
0B00E9             0118       include "fixed168.inc"
0B00E9             0001*  ; multiply HL by 256
0B00E9             0002*  ; inputs: HL
0B00E9             0003*  ; outputs: HL*256
0B00E9             0004*  ; destroys: flags
0B00E9             0005*      MACRO hlu_mul256
0B00E9             0006*          add hl,hl ; * 2
0B00E9             0007*          add hl,hl ; * 4
0B00E9             0008*          add hl,hl ; * 8
0B00E9             0009*          add hl,hl ; * 16
0B00E9             0010*          add hl,hl ; * 32
0B00E9             0011*          add hl,hl ; * 64
0B00E9             0012*          add hl,hl ; * 128
0B00E9             0013*          add hl,hl ; * 256
0B00E9             0014*      ENDMACRO
0B00E9             0015*  
0B00E9             0016*  ; test the sign of HL
0B00E9             0017*  ; inputs: HL obviously
0B00E9             0018*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B00E9             0019*  ; destroys: flags
0B00E9             0020*      MACRO sign_hlu
0B00E9             0021*          add hl,de
0B00E9             0022*          or a
0B00E9             0023*          sbc hl,de
0B00E9             0024*      ENDMACRO
0B00E9             0025*  
0B00E9             0026*  ; hlu signed division by 256
0B00E9             0027*  ; returns: hlu / 256
0B00E9             0028*  ; destroys: af
0B00E9             0029*  hlu_sdiv256:
0B00E9 AF          0030*      xor a ; assume hl is positive
0B00EA 22 00 01 0B 0031*      ld (@buffer),hl
0B00EE             0032*      sign_hlu
0B00EE 19          0001*M         add hl,de
0B00EF B7          0002*M         or a
0B00F0 ED 52       0003*M         sbc hl,de
0B00F2 F2 F7 00 0B 0033*      jp p,@hl_pos
0B00F6 3D          0034*      dec a
0B00F7             0035*  @hl_pos:
0B00F7 32 03 01 0B 0036*      ld (@buffer+3),a
0B00FB 2A 01 01 0B 0037*      ld hl,(@buffer+1)
0B00FF C9          0038*      ret
0B0100 00 00 00 00 0039*  @buffer: blkb 4,0
0B0104             0040*  
0B0104             0041*  ; hlu 1 byte right shift, unsigned
0B0104             0042*  ; returns: hlu / 256, fractional portion in a
0B0104             0043*  ; destroys: af
0B0104             0044*  hlu_udiv256:
0B0104 7D          0045*  	ld a,l ; save the fractional portion
0B0105 22 0E 01 0B 0046*  	ld (@buffer),hl
0B0109 2A 0F 01 0B 0047*  	ld hl,(@buffer+1)
0B010D C9          0048*  	ret
0B010E 00 00 00 00 0049*  @buffer: blkb 4,0
0B0112             0050*  
0B0112             0051*  ; absolute value of hlu
0B0112             0052*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B0112             0053*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B0112             0054*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B0112             0055*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B0112             0056*  ; destroys: a
0B0112             0057*  hlu_abs:
0B0112 19          0058*      add hl,de
0B0113 B7          0059*      or a
0B0114 ED 52       0060*      sbc hl,de
0B0116 FA 1B 01 0B 0061*      jp m,@is_neg
0B011A C9          0062*      ret         ; hlu is positive or zero so we're done
0B011B             0063*  @is_neg:
0B011B F5          0064*      push af     ; otherwise, save current flags for return
0B011C CD 22 01 0B 0065*      call neg_hlu ; negate hlu
0B0120 F1          0066*      pop af      ; get back flags
0B0121 C9          0067*      ret
0B0122             0068*  
0B0122             0069*  ; flip the sign of hlu
0B0122             0070*  ; inputs: hlu
0B0122             0071*  ; returns: 0-hlu, flags set appropriately for the result:
0B0122             0072*  ;         s1,z0,pv0,n1,c1 if result is negative
0B0122             0073*  ;         s0,z1,pv0,n1,c0 if result is zero
0B0122             0074*  ;         s0,z0,pv0,n1,c1 if result is positive
0B0122             0075*  ; destroys a
0B0122             0076*  neg_hlu:
0B0122 D5          0077*      push de     ; save de
0B0123 EB          0078*      ex de,hl    ; put hl into de
0B0124 21 00 00 00 0079*      ld hl,0     ; clear hl
0B0128 AF          0080*      xor a       ; clear carry
0B0129 ED 52       0081*      sbc hl,de   ; 0-hlu = -hlu
0B012B D1          0082*      pop de      ; get de back
0B012C C9          0083*      ret         ; easy peasy
0B012D             0084*  
0B012D             0085*      ; include "fixed24.inc"
0B012D             0086*  
0B012D             0087*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B012D             0088*  ; uses EZ80 MLT instruction for speed
0B012D             0089*  ; operation: UHL * A --> UHL
0B012D             0090*  ; destroys: AF, HL
0B012D             0091*  smul24x8:
0B012D             0092*  ; make hl positive and store sign flag
0B012D CD 12 01 0B 0093*  	call hlu_abs
0B0131 F5          0094*  	push af
0B0132             0095*  ; do the division
0B0132 CD 3D 01 0B 0096*      call mul24x8 ; hl = product
0B0136             0097*  ; adjust sign of result
0B0136 F1          0098*  	pop af ; sign de
0B0137 F0          0099*  	ret p ; hl was positive, nothing to do
0B0138 CD 22 01 0B 0100*  	call neg_hlu ; result is negative
0B013C C9          0101*  	ret
0B013D             0102*  
0B013D             0103*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B013D             0104*  ; uses EZ80 MLT instruction for speed
0B013D             0105*  ; operation: UHL * A --> AUHL
0B013D             0106*  ; destroys: AF, HL
0B013D             0107*  mul24x8:
0B013D D5          0108*  	push de ; preserve de
0B013E             0109*  ; low byte
0B013E 5D          0110*  	ld e,l
0B013F 57          0111*  	ld d,a
0B0140 ED 5C       0112*  	mlt de
0B0142 6B          0113*  	ld l,e ; product low byte
0B0143 08          0114*  	ex af,af' ; save multiplier
0B0144 7A          0115*  	ld a,d ; carry
0B0145 08          0116*  	ex af,af' ; save carry, restore multiplier
0B0146             0117*  ; high byte
0B0146 5C          0118*  	ld e,h
0B0147 57          0119*  	ld d,a
0B0148 ED 5C       0120*  	mlt de
0B014A 08          0121*  	ex af,af' ; save multiplier, restore carry
0B014B 83          0122*  	add a,e ; add carry
0B014C 67          0123*  	ld h,a ; product middle byte
0B014D 7A          0124*  	ld a,d ; carry
0B014E 08          0125*  	ex af,af' ; save carry, restore multiplier
0B014F             0126*  ; upper byte
0B014F 22 6A 01 0B 0127*      ld (@scratch),hl ; 7 cycles
0B0153 5F          0128*  	ld e,a
0B0154 3A 6C 01 0B 0129*  	ld a,(@scratch+2)
0B0158 57          0130*  	ld d,a
0B0159 ED 5C       0131*  	mlt de
0B015B 08          0132*  	ex af,af' ; restore carry
0B015C 8B          0133*  	adc a,e ; add carry
0B015D 32 6C 01 0B 0134*      ld (@scratch+2),a ; 5 cycles
0B0161 2A 6A 01 0B 0135*      ld hl,(@scratch) ; 7 cycles
0B0165             0136*  ; highest byte
0B0165 3E 00       0137*  	ld a,0 ; preserve carry flag
0B0167 8A          0138*  	adc a,d ; product highest byte
0B0168 D1          0139*  	pop de ; restore de
0B0169 C9          0140*  	ret
0B016A             0141*  @scratch: ds 3
0B016D             0142*  
0B016D 00 00 00 00 0143*  mul24out: blkb 6,0
       00 00       
0B0173             0144*  
0B0173             0145*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0173             0146*  ; operation: UHL * UDE --> mul24out
0B0173             0147*  mul24:
0B0173 DD E5       0148*  	push ix ; preserve
0B0175             0149*  ; point to output buffer and clear it
0B0175 DD 21 6D 01 0150*  	ld ix,mul24out
       0B          
0B017A C5          0151*  	push bc
0B017B 01 00 00 00 0152*  	ld bc,0
0B017F DD 0F 00    0153*  	ld (ix),bc
0B0182 DD 0F 03    0154*  	ld (ix+3),bc
0B0185 C1          0155*  	pop bc
0B0186             0156*  ; STEP 1: UHL * E
0B0186 7B          0157*  	ld a,e
0B0187 E5          0158*  	push hl
0B0188 CD 3D 01 0B 0159*  	call mul24x8
0B018C DD 2F 00    0160*  	ld (ix+0),hl
0B018F DD 77 03    0161*  	ld (ix+3),a
0B0192             0162*  ; STEP 2: UHL * D
0B0192 E1          0163*  	pop hl
0B0193 E5          0164*  	push hl
0B0194 7A          0165*  	ld a,d
0B0195 CD 3D 01 0B 0166*  	call mul24x8
0B0199 CD B2 01 0B 0167*  	call @accumulate
0B019D             0168*  ; STEP 3: UHL * DEU
0B019D E1          0169*  	pop hl
0B019E ED 53 E2 01 0170*  	ld (@de),de
       0B          
0B01A3 3A E4 01 0B 0171*  	ld a,(@de+2)
0B01A7 CD 3D 01 0B 0172*  	call mul24x8
0B01AB CD B2 01 0B 0173*  	call @accumulate
0B01AF             0174*  ; all done
0B01AF DD E1       0175*  	pop ix ; restore
0B01B1 C9          0176*  	ret
0B01B2             0177*  @accumulate:
0B01B2 DD 23       0178*  	inc ix
0B01B4             0179*  ; highest byte of product to carry
0B01B4 DD 77 03    0180*  	ld (ix+3),a
0B01B7             0181*  ; low byte of product
0B01B7 7D          0182*  	ld a,l
0B01B8 DD 86 00    0183*  	add a,(ix+0)
0B01BB DD 77 00    0184*  	ld (ix+0),a
0B01BE             0185*  ; high byte of product
0B01BE 7C          0186*  	ld a,h
0B01BF DD 8E 01    0187*  	adc a,(ix+1)
0B01C2 DD 77 01    0188*  	ld (ix+1),a
0B01C5             0189*  ; uppper byte of product
0B01C5 22 DF 01 0B 0190*  	ld (@hl),hl
0B01C9 3A E1 01 0B 0191*  	ld a,(@hl+2)
0B01CD DD 8E 02    0192*  	adc a,(ix+2)
0B01D0 DD 77 02    0193*  	ld (ix+2),a
0B01D3             0194*  ; carry
0B01D3 3E 00       0195*  	ld a,0 ; preserve flags
0B01D5 DD 8E 03    0196*  	adc a,(ix+3)
0B01D8 DD 77 03    0197*  	ld (ix+3),a
0B01DB C9          0198*  	ret
0B01DC             0199*  
0B01DC 00 00 00    0200*  @ix: dl 0
0B01DF 00 00 00    0201*  @hl: dl 0
0B01E2 00 00 00    0202*  @de: dl 0
0B01E5             0203*  
0B01E5             0204*  ; UHL * UDE --> UHL (unsigned)
0B01E5             0205*  umul24:
0B01E5 CD 73 01 0B 0206*  	call mul24
0B01E9 2A 6D 01 0B 0207*  	ld hl,(mul24out)
0B01ED C9          0208*  	ret
0B01EE             0209*  
0B01EE             0210*  ; UH.L = UH.L*UD.E (unsigned)
0B01EE             0211*  umul168:
0B01EE CD 73 01 0B 0212*  	call mul24
0B01F2 2A 6E 01 0B 0213*  	ld hl,(mul24out+1)
0B01F6 C9          0214*  	ret
0B01F7             0215*  
0B01F7             0216*  ; UH.L * UD.E --> UH.L (signed)
0B01F7             0217*  smul168:
0B01F7             0218*  ; make everything positive and store sign flags
0B01F7 CD 12 01 0B 0219*  	call hlu_abs
0B01FB F5          0220*  	push af
0B01FC EB          0221*  	ex de,hl
0B01FD CD 12 01 0B 0222*  	call hlu_abs
0B0201 EB          0223*  	ex de,hl
0B0202 F5          0224*  	push af
0B0203             0225*  ; do the division
0B0203 CD EE 01 0B 0226*      call umul168 ; hl = product
0B0207             0227*  ; adjust sign of result
0B0207 F1          0228*  	pop af ; sign de
0B0208 FA 13 02 0B 0229*  	jp m,@de_neg
0B020C F1          0230*  	pop af ; sign hl
0B020D F0          0231*  	ret p ; both positive, nothing to do
0B020E             0232*  @hl_neg:
0B020E CD 22 01 0B 0233*      call neg_hlu ; de pos, hl neg, result is negative
0B0212 C9          0234*      ret
0B0213             0235*  @de_neg:
0B0213 F1          0236*  	pop af
0B0214 F8          0237*  	ret m ; both negative, nothing to do
0B0215 CD 22 01 0B 0238*  	call neg_hlu ; result is negative
0B0219 C9          0239*  	ret
0B021A             0240*  
0B021A             0241*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B021A             0242*  ; perform unsigned division of 16.8 fixed place values
0B021A             0243*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B021A             0244*  udiv168:
0B021A             0245*  ; back up divisor
0B021A ED 53 51 02 0246*  	ld (@ude),de
       0B          
0B021F             0247*  ; get the 16-bit integer part of the quotient
0B021F CD 82 02 0B 0248*      call udiv24 ; de = quotient, hl = remainder
0B0223             0249*  ; load quotient to upper three bytes of output
0B0223 ED 53 58 02 0250*      ld (div168_out+1),de
       0B          
0B0228             0251*  @div256:
0B0228             0252*  ; multiply remainder by 256
0B0228             0253*  	hlu_mul256
0B0228 29          0001*M         add hl,hl ; * 2
0B0229 29          0002*M         add hl,hl ; * 4
0B022A 29          0003*M         add hl,hl ; * 8
0B022B 29          0004*M         add hl,hl ; * 16
0B022C 29          0005*M         add hl,hl ; * 32
0B022D 29          0006*M         add hl,hl ; * 64
0B022E 29          0007*M         add hl,hl ; * 128
0B022F 29          0008*M         add hl,hl ; * 256
0B0230             0254*  ; skip fractional computation if remainder is zero
0B0230             0255*      sign_hlu
0B0230 19          0001*M         add hl,de
0B0231 B7          0002*M         or a
0B0232 ED 52       0003*M         sbc hl,de
0B0234 20 03       0256*      jr nz,@div_frac
0B0236 AF          0257*      xor a
0B0237 18 0A       0258*      jr @write_frac
0B0239             0259*  ; now divide the shifted remainder by the divisor
0B0239             0260*  @div_frac:
0B0239 ED 5B 51 02 0261*  	ld de,(@ude) ; get back divisor
       0B          
0B023E CD 82 02 0B 0262*      call udiv24 ; de = quotient, hl = remainder
0B0242             0263*  ; load low byte of quotient to low byte of output
0B0242 7B          0264*      ld a,e
0B0243             0265*  @write_frac:
0B0243 32 57 02 0B 0266*      ld (div168_out),a
0B0247             0267*  ; load de with return value
0B0247 ED 5B 57 02 0268*      ld de,(div168_out)
       0B          
0B024C             0269*  ; load a with any overflow
0B024C 3A 5A 02 0B 0270*      ld a,(div168_out+3)
0B0250 C9          0271*      ret ; ud.e is the 16.8 result
0B0251             0272*  @ude: ds 6
0B0257             0273*  div168_out: ds 4 ; the extra byte is for overflow
0B025B             0274*  
0B025B             0275*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B025B             0276*  ; perform signed division of 16.8 fixed place values
0B025B             0277*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B025B             0278*  sdiv168:
0B025B             0279*  ; make everything positive and store sign flags
0B025B CD 12 01 0B 0280*  	call hlu_abs
0B025F F5          0281*  	push af
0B0260 EB          0282*  	ex de,hl
0B0261 CD 12 01 0B 0283*  	call hlu_abs
0B0265 EB          0284*  	ex de,hl
0B0266 F5          0285*  	push af
0B0267             0286*  ; do the division
0B0267 CD 1A 02 0B 0287*      call udiv168 ; de = quotient, hl = remainder
0B026B             0288*  ; adjust sign of result
0B026B F1          0289*  	pop af ; sign de
0B026C FA 79 02 0B 0290*  	jp m,@de_neg
0B0270 F1          0291*  	pop af ; sign hl
0B0271 F0          0292*  	ret p ; both positive, nothing to do
0B0272             0293*  @hl_neg:
0B0272 EB          0294*      ex de,hl ; hl = quotient, de = remainder
0B0273 CD 22 01 0B 0295*      call neg_hlu ; de pos, hl neg, result is negative
0B0277 EB          0296*      ex de,hl ; de = negated quotient, hl = remainder
0B0278 C9          0297*      ret
0B0279             0298*  @de_neg:
0B0279 F1          0299*  	pop af
0B027A F8          0300*  	ret m ; both negative, nothing to do
0B027B EB          0301*      ex de,hl ; hl = quotient, de = remainder
0B027C CD 22 01 0B 0302*  	call neg_hlu ; result is negative
0B0280 EB          0303*      ex de,hl ; de = negated quotient, hl = remainder
0B0281 C9          0304*  	ret
0B0282             0305*  
0B0282             0306*  ;------------------------------------------------------------------------
0B0282             0307*  ;  arith24.asm
0B0282             0308*  ;  24-bit ez80 arithmetic routines
0B0282             0309*  ;  Copyright (c) Shawn Sijnstra 2024
0B0282             0310*  ;  MIT license
0B0282             0311*  ;
0B0282             0312*  ;  This library was created as a tool to help make ez80
0B0282             0313*  ;  24-bit native assembly routines for simple mathematical problems
0B0282             0314*  ;  more widely available.
0B0282             0315*  ;
0B0282             0316*  ;------------------------------------------------------------------------
0B0282             0317*  ;
0B0282             0318*  ;------------------------------------------------------------------------
0B0282             0319*  ; udiv24
0B0282             0320*  ; Unsigned 24-bit division
0B0282             0321*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0282             0322*  ;
0B0282             0323*  ; Uses AF BC DE HL
0B0282             0324*  ; Uses Restoring Division algorithm
0B0282             0325*  ;------------------------------------------------------------------------
0B0282             0326*  
0B0282             0327*  udiv24:
0B0282 E5          0328*  	push	hl
0B0283 C1          0329*  	pop		bc	;move dividend to BCU
0B0284 21 00 00 00 0330*  	ld		hl,0	;result
0B0288 A7          0331*  	and		a
0B0289 ED 52       0332*  	sbc		hl,de	;test for div by 0
0B028B C8          0333*  	ret		z		;it's zero, carry flag is clear
0B028C 19          0334*  	add		hl,de	;HL is 0 again
0B028D 3E 18       0335*  	ld		a,24	;number of loops through.
0B028F             0336*  udiv1:
0B028F C5          0337*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0290 E3          0338*  	ex		(sp),hl
0B0291 37          0339*  	scf
0B0292 ED 6A       0340*  	adc	hl,hl
0B0294 E3          0341*  	ex	(sp),hl
0B0295 C1          0342*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0296             0343*  
0B0296 ED 6A       0344*  	adc	hl,hl
0B0298 A7          0345*  	and	a		;is this the bug
0B0299 ED 52       0346*  	sbc	hl,de
0B029B 30 02       0347*  	jr	nc,udiv2
0B029D 19          0348*  	add	hl,de
0B029E             0349*  ;	dec	c
0B029E 0B          0350*  	dec	bc
0B029F             0351*  udiv2:
0B029F 3D          0352*  	dec	a
0B02A0 20 ED       0353*  	jr	nz,udiv1
0B02A2 37          0354*  	scf		;flag used for div0 error
0B02A3 C5          0355*  	push	bc
0B02A4 D1          0356*  	pop		de	;remainder
0B02A5 C9          0357*  	ret
0B02A6             0358*  
0B02A6             0359*  ;------------------------------------------------------------------------
0B02A6             0360*  ;  END 24-bit ez80 arithmetic routines by Shawn Sijnstra
0B02A6             0361*  ;------------------------------------------------------------------------
0B02A6             0362*  
0B02A6             0363*  
0B02A6             0364*      ; include "trig24fast.inc"
0B02A6             0365*  
0B02A6             0366*  
0B02A6             0367*  ; convert signed angles from a 360 to 256 degree circle
0B02A6             0368*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B02A6             0369*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B02A6             0370*  ; destroys: TODO
0B02A6             0371*  deg_360_to_256:
0B02A6 D5          0372*  	push de ; preserve de
0B02A7             0373*  ; make angle positive and store sign flag
0B02A7 CD 12 01 0B 0374*  	call hlu_abs
0B02AB F5          0375*  	push af
0B02AC             0376*  ; multiply by 256 first to keep precision
0B02AC             0377*  	hlu_mul256 ; uh.l = uh.l * 256
0B02AC 29          0001*M         add hl,hl ; * 2
0B02AD 29          0002*M         add hl,hl ; * 4
0B02AE 29          0003*M         add hl,hl ; * 8
0B02AF 29          0004*M         add hl,hl ; * 16
0B02B0 29          0005*M         add hl,hl ; * 32
0B02B1 29          0006*M         add hl,hl ; * 64
0B02B2 29          0007*M         add hl,hl ; * 128
0B02B3 29          0008*M         add hl,hl ; * 256
0B02B4             0378*  ; divide uh.l by 360
0B02B4 11 68 01 00 0379*  	ld de,360
0B02B8 CD 82 02 0B 0380*  	call udiv24 ; ud.e = degrees / 360
0B02BC EB          0381*  	ex de,hl    ; uh.l = degrees / 360
0B02BD             0382*  ; restore sign flag and adjust output accordingly
0B02BD F1          0383*  	pop af
0B02BE F2 C6 02 0B 0384*  	jp p,@pos ; positive number
0B02C2 CD 22 01 0B 0385*  	call neg_hlu
0B02C6             0386*  @pos:
0B02C6             0387*  ; restore de and return uh.l as the result
0B02C6 D1          0388*  	pop de
0B02C7 C9          0389*  	ret
0B02C8             0390*  
0B02C8             0391*  ; fixed 16.8 routine
0B02C8             0392*  ; cos(uh.l) --> uh.l
0B02C8             0393*  ; destroys: f, hl
0B02C8             0394*  cos168:
0B02C8 D5          0395*      push de ; preserve de
0B02C9             0396*  ; for cos we simply increment the angle by 90 degrees
0B02C9             0397*  ; or 0x004000 in 16.8 degrees256
0B02C9             0398*  ; which makes it a sin problem
0B02C9 11 00 40 00 0399*      ld de,0x004000
0B02CD 19          0400*      add hl,de ; modulo 256 happens below
0B02CE D1          0401*      pop de ; restore de
0B02CF             0402*  ; fall through to sin168
0B02CF             0403*  
0B02CF             0404*  ; ---------------------
0B02CF             0405*  ; fixed 16.8 routine
0B02CF             0406*  ; sin(uh.l) --> uh.l
0B02CF             0407*  ; destroys: f, hl
0B02CF             0408*  sin168:
0B02CF D5          0409*  	push de
0B02D0             0410*  ; handle negative angles appropriately
0B02D0 CD 12 01 0B 0411*  	call hlu_abs
0B02D4 F2 DD 02 0B 0412*  	jp p,@F
0B02D8 11 00 00 FF 0413*  	ld de,-256*256
0B02DC 19          0414*  	add hl,de
0B02DD             0415*  @@:
0B02DD 2E 03       0416*  	ld l,3 ; multiply by 3 to get our lookup index
0B02DF ED 6C       0417*      mlt hl
0B02E1 11 2C 05 0B 0418*      ld de,sin_lut_168 ; grab the lut address
0B02E5 19          0419*      add hl,de ; bump hl by the index
0B02E6 ED 27       0420*      ld hl,(hl) ; don't try this on a z80!
0B02E8 D1          0421*      pop de
0B02E9 C9          0422*      ret
0B02EA             0423*  
0B02EA             0424*  ; 16.8 fixed inputs / outputs
0B02EA             0425*  ; takes: uh.l as angle in degrees 256
0B02EA             0426*  ;        ud.e as radius
0B02EA             0427*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B02EA             0428*  ;        displacements from origin (0,0)
0B02EA             0429*  ; destroys: everything except indexes
0B02EA             0430*  polar_to_cartesian:
0B02EA             0431*  ; back up input parameters
0B02EA 22 19 03 0B 0432*      ld (@angle), hl
0B02EE ED 53 1C 03 0433*      ld (@radius), de
       0B          
0B02F3             0434*  ; compute dx = sin(uh.l) * ud.e
0B02F3 CD CF 02 0B 0435*      call sin168 ; uh.l = sin(uh.l)
0B02F7 ED 5B 1C 03 0436*  	ld de,(@radius)
       0B          
0B02FC CD F7 01 0B 0437*  	call smul168 ; uh.l = dx
0B0300 E5          0438*      push hl
0B0301             0439*  ; compute dy = -cos(uh.l) * ud.e
0B0301 2A 19 03 0B 0440*      ld hl,(@angle)
0B0305 CD C8 02 0B 0441*      call cos168 ; uh.l = cos(uh.l)
0B0309 ED 5B 1C 03 0442*      ld de,(@radius)
       0B          
0B030E CD F7 01 0B 0443*      call smul168    ; uh.l = dy
0B0312 CD 22 01 0B 0444*      call neg_hlu ; invert dy for screen coords convention
0B0316 EB          0445*      ex de,hl       ; de = dy for output
0B0317 C1          0446*      pop bc          ; bc = dx for output
0B0318             0447*  ; and out
0B0318 C9          0448*      ret
0B0319             0449*  @angle: ds 3
0B031C             0450*  @radius: ds 3
0B031F             0451*  
0B031F             0452*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B031F             0453*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B031F             0454*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B031F             0455*  ;         also populates scratch locations dx168 and dy168
0B031F             0456*  ; destroys: a,hl,bc,de
0B031F             0457*  dxy168:
0B031F             0458*  ; compute dx = x1-x0
0B031F AF          0459*      xor a ; clear carry
0B0320 DD E5       0460*      push ix ; move ix to hl via the stack
0B0322 E1          0461*      pop hl ; hl = x1
0B0323 ED 42       0462*      sbc hl,bc ; hl = dx
0B0325 22 3A 03 0B 0463*      ld (dx168),hl ; dx to scratch
0B0329             0464*  ; compute dy = y1-y0
0B0329 AF          0465*      xor a ; clear carry
0B032A FD E5       0466*      push iy ; move iy to hl via the stack
0B032C E1          0467*      pop hl ; hl = y1
0B032D ED 52       0468*      sbc hl,de ; hl = dy
0B032F 22 40 03 0B 0469*      ld (dy168),hl ; dy to scratch
0B0333             0470*  ; populate output registers and return
0B0333 EB          0471*      ex de,hl        ; ud.e = dy
0B0334 ED 4B 3A 03 0472*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0339 C9          0473*      ret
0B033A 00 00 00 00 0474*  dx168: blkb 6,0
       00 00       
0B0340 00 00 00 00 0475*  dy168: blkb 6,0
       00 00       
0B0346             0476*  
0B0346             0477*  ; compute the euclidian distance between two cartesian coordinates
0B0346             0478*  ; using the formula d = sqrt(dx^2+dy^2)
0B0346             0479*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0346             0480*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0346             0481*  ; output; uh.l is the 16.8 fixed format distance
0B0346             0482*  ;         also populates scratch locations dx168 and dy168
0B0346             0483*  ; destroys: a,hl,bc,de
0B0346             0484*  ; NOTE: rounds both deltas down to the nearest integer to avoid overflow when squaring,
0B0346             0485*  ;       thus the result will always be an integer, albeit in 16.8 format
0B0346             0486*  distance168:
0B0346 CD 1F 03 0B 0487*  	call dxy168 ; ub.c = dx, ud.e = dy
0B034A             0488*  ; compute dy^2
0B034A EB          0489*  	ex de,hl
0B034B CD 12 01 0B 0490*  	call hlu_abs
0B034F CD 04 01 0B 0491*  	call hlu_udiv256 ; make integer to avoid overflow for dy >= 256
0B0353 E5          0492*  	push hl
0B0354 D1          0493*  	pop de
0B0355 CD E5 01 0B 0494*  	call umul24 ; hl = dy^2
0B0359 E5          0495*  	push hl ; save dy^2
0B035A             0496*  ; compute dx^2
0B035A 2A 3A 03 0B 0497*  	ld hl,(dx168)
0B035E CD 12 01 0B 0498*  	call hlu_abs
0B0362 CD 04 01 0B 0499*  	call hlu_udiv256 ; make integer to avoid overflow for dx >= 256
0B0366 E5          0500*  	push hl
0B0367 D1          0501*  	pop de
0B0368 CD E5 01 0B 0502*  	call umul24 ; hl = dx^2
0B036C             0503*  ; add dx^2 and dy^2
0B036C D1          0504*  	pop de ; de = dy^2 (was hl)
0B036D 19          0505*  	add hl,de ; hl = dx^2 + dy^2
0B036E             0506*  ; compute the square root
0B036E CD 47 04 0B 0507*  	call sqrt24 ; de = sqrt(dx^2 + dy^2)
0B0372 EB          0508*      ex de,hl ; hl = distance
0B0373             0509*      hlu_mul256 ; convert back to 16.8 fixed
0B0373 29          0001*M         add hl,hl ; * 2
0B0374 29          0002*M         add hl,hl ; * 4
0B0375 29          0003*M         add hl,hl ; * 8
0B0376 29          0004*M         add hl,hl ; * 16
0B0377 29          0005*M         add hl,hl ; * 32
0B0378 29          0006*M         add hl,hl ; * 64
0B0379 29          0007*M         add hl,hl ; * 128
0B037A 29          0008*M         add hl,hl ; * 256
0B037B C9          0510*  	ret
0B037C             0511*  
0B037C             0512*  ; atan2_(ub.c,ud.e) --> uh.l
0B037C             0513*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B037C             0514*  ;   whether inputs are integers or fractional doesn't matter
0B037C             0515*  ;   so long as the sign bit of the upper byte is correct
0B037C             0516*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B037C             0517*  ; angles are COMPASS HEADINGS based on
0B037C             0518*  ; screen coordinate conventions,where the y axis is flipped
0B037C             0519*  ; #E0 315      0       45 #20
0B037C             0520*  ;        -x,-y | +x,-y
0B037C             0521*  ; #C0 270------+------ 90 #40
0B037C             0522*  ;        -x,+y | +x,+y
0B037C             0523*  ; #A0 225   180 #80   135 #60
0B037C             0524*  atan2_168fast:
0B037C             0525*  ; get signs and make everything positive
0B037C             0526*  ; get abs(x) and store its original sign
0B037C C5          0527*      push bc
0B037D E1          0528*      pop hl
0B037E CD 12 01 0B 0529*      call hlu_abs ; if x was negative this also sets the sign flag
0B0382 E5          0530*      push hl ; store abs(x)
0B0383 C1          0531*      pop bc ; bc = abs(x)
0B0384 F5          0532*      push af ; store sign of x
0B0385             0533*  ; get abs(y) and store its original sign
0B0385 EB          0534*      ex de,hl ; hl = y
0B0386 CD 12 01 0B 0535*      call hlu_abs ; if y was negative this also sets the sign flag
0B038A EB          0536*      ex de,hl ; de = abs(y)
0B038B F5          0537*      push af ; store sign of y
0B038C             0538*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B038C             0539*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B038C AF          0540*      xor a ; clear the carry flag
0B038D D5          0541*      push de
0B038E E1          0542*      pop hl
0B038F ED 42       0543*      sbc hl,bc
0B0391 F5          0544*      push af ; save sign of de - bc
0B0392 F2 9B 03 0B 0545*      jp p,@1 ; bc <= de, so we skip ahead
0B0396             0546*  ; otherwise we swap bc and de
0B0396 C5          0547*      push bc
0B0397 E1          0548*      pop hl
0B0398 EB          0549*      ex de,hl
0B0399 E5          0550*      push hl
0B039A C1          0551*      pop bc
0B039B             0552*  @1:
0B039B             0553*  ; now we're ready to snag our preliminary result
0B039B C5          0554*  	push bc
0B039C E1          0555*  	pop hl
0B039D CD 0B 04 0B 0556*      call atan_168fast ; uh.l comes back with prelim result
0B03A1             0557*  ; now we adjust uh.l based on sign of de - bc
0B03A1 F1          0558*      pop af
0B03A2 F2 AE 03 0B 0559*      jp p,@2 ; bc <= de,so we skip ahead
0B03A6 EB          0560*      ex de,hl
0B03A7 21 00 40 00 0561*      ld hl,0x004000 ; 90 degrees
0B03AB AF          0562*      xor a ; clear the carry flag
0B03AC ED 52       0563*      sbc hl,de ; subtract result from 90 degrees
0B03AE             0564*  @2:
0B03AE             0565*  ; now the fun part of adjusting the result
0B03AE             0566*  ; based on which quadrant (x,y) is in
0B03AE             0567*  ; #E0 315      0       45 #20
0B03AE             0568*  ;        -x,-y | +x,-y
0B03AE             0569*  ; #C0 270------+------ 90 #40
0B03AE             0570*  ;        -x,+y | +x,+y
0B03AE             0571*  ; #A0 225   180 #80   135 #60
0B03AE F1          0572*      pop af ; sign of y
0B03AF CA EC 03 0B 0573*      jp z,@y_zero
0B03B3 F2 CC 03 0B 0574*      jp p,@y_pos
0B03B7             0575*  ; y neg,check x
0B03B7 F1          0576*      pop af ; sign of x
0B03B8 CA C6 03 0B 0577*      jp z,@y_neg_x_zero
0B03BC F2 CB 03 0B 0578*      jp p,@y_neg_x_pos
0B03C0             0579*  ; y neg,x neg
0B03C0             0580*  ; angle is 270-360
0B03C0             0581*  ; negating the intermediate does the trick
0B03C0 CD 22 01 0B 0582*      call neg_hlu
0B03C4 18 31       0583*      jr @zero_hlu
0B03C6             0584*  
0B03C6             0585*  @y_neg_x_zero:
0B03C6             0586*  ; y neg,x zero
0B03C6             0587*  ; angle is 0
0B03C6 21 00 00 00 0588*      ld hl,0
0B03CA C9          0589*      ret
0B03CB             0590*  @y_neg_x_pos:
0B03CB             0591*  ; y neg,x pos
0B03CB             0592*  ; angle is 0 to 90
0B03CB             0593*  ; so we're good
0B03CB C9          0594*      ret
0B03CC             0595*  
0B03CC             0596*  @y_pos:
0B03CC F1          0597*      pop af ; sign of x
0B03CD CA DC 03 0B 0598*      jp z,@y_pos_x_zero
0B03D1 F2 E1 03 0B 0599*      jp p,@y_pos_x_pos
0B03D5             0600*  ; y pos,x neg
0B03D5             0601*  ; angle is 180-270
0B03D5             0602*  ; so we add 180 to intermediate
0B03D5 11 00 80 00 0603*      ld de,0x008000
0B03D9 19          0604*      add hl,de
0B03DA 18 1B       0605*      jr @zero_hlu
0B03DC             0606*  @y_pos_x_zero:
0B03DC             0607*  ; y pos,x zero
0B03DC             0608*  ; angle is 180
0B03DC 21 00 80 00 0609*      ld hl,0x008000
0B03E0 C9          0610*      ret
0B03E1             0611*  @y_pos_x_pos:
0B03E1             0612*  ; y pos,x pos
0B03E1             0613*  ; angle is 90-180
0B03E1             0614*  ; neg the intermediate and add 180 degrees
0B03E1 CD 22 01 0B 0615*      call neg_hlu
0B03E5 11 00 80 00 0616*      ld de,0x008000
0B03E9 19          0617*      add hl,de
0B03EA 18 0B       0618*      jr @zero_hlu
0B03EC             0619*  
0B03EC             0620*  @y_zero:
0B03EC F1          0621*      pop af ; sign of x
0B03ED FA F2 03 0B 0622*      jp m,@y_zero_x_neg
0B03F1             0623*  ; y zero,x pos
0B03F1             0624*  ; angle is 90,nothing to do
0B03F1 C9          0625*      ret
0B03F2             0626*  @y_zero_x_neg:
0B03F2             0627*  ; y zero ,x neg
0B03F2             0628*  ; angle is 270
0B03F2 21 00 C0 00 0629*      ld hl,0x00C000
0B03F6 C9          0630*      ret
0B03F7             0631*  @zero_hlu:
0B03F7 AF          0632*      xor a
0B03F8 22 05 04 0B 0633*      ld (@scratch),hl
0B03FC 32 07 04 0B 0634*      ld (@scratch+2),a
0B0400 2A 05 04 0B 0635*      ld hl,(@scratch)
0B0404 C9          0636*      ret
0B0405             0637*  @scratch: ds 6
0B040B             0638*  
0B040B             0639*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B040B             0640*  ; output: uh.l is the 16.8 fixed format angle in degrees 256
0B040B             0641*  ; destroys: a,hl,bc,de
0B040B             0642*  ; note: only works for angles from 0 to 32 (45) degrees
0B040B             0643*  ;   use atan2_168fast (which calls this proc) to handle the full 256 (360) degrees
0B040B             0644*  atan_168fast:
0B040B             0645*  ; because we use compass headings instead of geometric angles
0B040B             0646*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B040B             0647*  ; we can do faster unsigned division here because we know dx and dy are positive
0B040B CD 1A 02 0B 0648*  	call udiv168 ; ud.e = dx/dy
0B040F EB          0649*  	ex de,hl ; uh.l = dx/dy
0B0410             0650*  ; test uh.l for 0
0B0410 19          0651*      add hl,de
0B0411 B7          0652*      or a
0B0412 ED 52       0653*      sbc hl,de
0B0414 28 22       0654*      jr z,@is_zero
0B0416             0655*  ; test uh.l for 1
0B0416 AF          0656*      xor a ; clear carry
0B0417 EB          0657*      ex de,hl
0B0418 21 00 01 00 0658*      ld hl,0x000100 ; 1 in 16.8 fixed format
0B041C ED 52       0659*      sbc hl,de
0B041E 28 13       0660*      jr z,@is_45
0B0420 EB          0661*  	ex de,hl
0B0421             0662*  ; no special cases so we move on
0B0421             0663*  ; l contains the fractional portion of tan(uh.l)
0B0421             0664*  ; we multiply it by three to get our lookup table index
0B0421 26 03       0665*      ld h,3
0B0423 ED 6C       0666*      mlt hl ; gosh that is handy
0B0425 11 00 00 00 0667*      ld de,0 ; clear deu
0B0429 54          0668*      ld d,h ; copy hl to de
0B042A 5D          0669*      ld e,l ; de contains our index
0B042B 21 2F 08 0B 0670*      ld hl,atan_lut_168 ; grab the lut address
0B042F 19          0671*      add hl,de ; bump hl by the index
0B0430 ED 27       0672*      ld hl,(hl) ; don't try this on a z80!
0B0432 C9          0673*      ret ; and out
0B0433             0674*  @is_45:
0B0433 21 00 20 00 0675*      ld hl,0x002000 ; 45 degrees decimal
0B0437 C9          0676*      ret
0B0438             0677*  ; for the case tan(0)
0B0438             0678*  @is_zero:
0B0438 21 00 00 00 0679*      ld hl,0x000000
0B043C C9          0680*      ret
0B043D             0681*  
0B043D             0682*  ; Expects  ADL mode
0B043D             0683*  ; Inputs:  UH.L
0B043D             0684*  ; Outputs: UH.L is the 16.8 square root
0B043D             0685*  ;          UDE is the integer difference inputHL-DE^2
0B043D             0686*  sqrt168:
0B043D CD 47 04 0B 0687*      call sqrt24
0B0441 EB          0688*      ex de,hl
0B0442 29          0689*      add hl,hl
0B0443 29          0690*      add hl,hl
0B0444 29          0691*      add hl,hl
0B0445 29          0692*      add hl,hl
0B0446 C9          0693*      ret
0B0447             0694*  
0B0447             0695*  sqrt24:
0B0447             0696*  ; Expects ADL mode
0B0447             0697*  ; Inputs: HL
0B0447             0698*  ; Outputs: DE is the integer square root
0B0447             0699*  ;          HL is the difference inputHL-DE^2
0B0447             0700*  ;          c flag reset
0B0447 11 00 00 00 0701*  	ld de,0 ; clear output
0B044B AF          0702*      xor a
0B044C 45          0703*      ld b,l
0B044D             0704*  	; ld c, h     ; C = high byte of HL (CORRECTED)
0B044D C5          0705*      push bc
0B044E 47          0706*      ld b,a
0B044F 57          0707*      ld d,a
0B0450 4F          0708*      ld c,a  ; WRONG, should be h (see above)
0B0451 6F          0709*      ld l,a
0B0452 5F          0710*      ld e,a
0B0453             0711*  ; Iteration 1
0B0453 29          0712*      add hl,hl
0B0454 CB 11       0713*      rl c
0B0456 29          0714*      add hl,hl
0B0457 CB 11       0715*      rl c
0B0459 91          0716*      sub c
0B045A 30 04       0717*      jr nc,$+6
0B045C 1C          0718*      inc e
0B045D 1C          0719*      inc e
0B045E 2F          0720*      cpl
0B045F 4F          0721*      ld c,a
0B0460             0722*  ;	call debug_print
0B0460             0723*  ; Iteration 2
0B0460 29          0724*      add hl,hl
0B0461 CB 11       0725*      rl c
0B0463 29          0726*      add hl,hl
0B0464 CB 11       0727*      rl c
0B0466 CB 13       0728*      rl e
0B0468 7B          0729*      ld a,e
0B0469 91          0730*      sub c
0B046A 30 04       0731*      jr nc,$+6
0B046C 1C          0732*      inc e
0B046D 1C          0733*      inc e
0B046E 2F          0734*      cpl
0B046F 4F          0735*      ld c,a
0B0470             0736*  ;	call debug_print
0B0470             0737*  ; Iteration 3
0B0470 29          0738*      add hl,hl
0B0471 CB 11       0739*      rl c
0B0473 29          0740*      add hl,hl
0B0474 CB 11       0741*      rl c
0B0476 CB 13       0742*      rl e
0B0478 7B          0743*      ld a,e
0B0479 91          0744*      sub c
0B047A 30 04       0745*      jr nc,$+6
0B047C 1C          0746*      inc e
0B047D 1C          0747*      inc e
0B047E 2F          0748*      cpl
0B047F 4F          0749*      ld c,a
0B0480             0750*  ;	call debug_print
0B0480             0751*  ; Iteration 4
0B0480 29          0752*      add hl,hl
0B0481 CB 11       0753*      rl c
0B0483 29          0754*      add hl,hl
0B0484 CB 11       0755*      rl c
0B0486 CB 13       0756*      rl e
0B0488 7B          0757*      ld a,e
0B0489 91          0758*      sub c
0B048A 30 04       0759*      jr nc,$+6
0B048C 1C          0760*      inc e
0B048D 1C          0761*      inc e
0B048E 2F          0762*      cpl
0B048F 4F          0763*      ld c,a
0B0490             0764*  ;	call debug_print
0B0490             0765*  ; Iteration 5
0B0490 29          0766*      add hl,hl
0B0491 CB 11       0767*      rl c
0B0493 29          0768*      add hl,hl
0B0494 CB 11       0769*      rl c
0B0496 CB 13       0770*      rl e
0B0498 7B          0771*      ld a,e
0B0499 91          0772*      sub c
0B049A 30 04       0773*      jr nc,$+6
0B049C 1C          0774*      inc e
0B049D 1C          0775*      inc e
0B049E 2F          0776*      cpl
0B049F 4F          0777*      ld c,a
0B04A0             0778*  ;	call debug_print
0B04A0             0779*  ; Iteration 6
0B04A0 29          0780*      add hl,hl
0B04A1 CB 11       0781*      rl c
0B04A3 29          0782*      add hl,hl
0B04A4 CB 11       0783*      rl c
0B04A6 CB 13       0784*      rl e
0B04A8 7B          0785*      ld a,e
0B04A9 91          0786*      sub c
0B04AA 30 04       0787*      jr nc,$+6
0B04AC 1C          0788*      inc e
0B04AD 1C          0789*      inc e
0B04AE 2F          0790*      cpl
0B04AF 4F          0791*      ld c,a
0B04B0             0792*  ;	call debug_print
0B04B0             0793*  ; Iteration 7
0B04B0 29          0794*      add hl,hl
0B04B1 CB 11       0795*      rl c
0B04B3 29          0796*      add hl,hl
0B04B4 CB 11       0797*      rl c
0B04B6 CB 10       0798*      rl b
0B04B8 EB          0799*      ex de,hl
0B04B9 29          0800*      add hl,hl
0B04BA E5          0801*      push hl
0B04BB ED 42       0802*      sbc hl,bc
0B04BD 30 06       0803*      jr nc,$+8
0B04BF 7C          0804*      ld a,h
0B04C0 2F          0805*      cpl
0B04C1 47          0806*      ld b,a
0B04C2 7D          0807*      ld a,l
0B04C3 2F          0808*      cpl
0B04C4 4F          0809*      ld c,a
0B04C5 E1          0810*      pop hl
0B04C6 30 02       0811*      jr nc,$+4
0B04C8 23          0812*      inc hl
0B04C9 23          0813*      inc hl
0B04CA EB          0814*      ex de,hl
0B04CB             0815*  ;	call debug_print
0B04CB             0816*  ; Iteration 8
0B04CB 29          0817*      add hl,hl
0B04CC 69          0818*      ld l,c
0B04CD 60          0819*      ld h,b
0B04CE ED 6A       0820*      adc hl,hl
0B04D0 ED 6A       0821*      adc hl,hl
0B04D2 EB          0822*      ex de,hl
0B04D3 29          0823*      add hl,hl
0B04D4 ED 52       0824*      sbc hl,de
0B04D6 19          0825*      add hl,de
0B04D7 EB          0826*      ex de,hl
0B04D8 30 04       0827*      jr nc,$+6
0B04DA ED 52       0828*      sbc hl,de
0B04DC 13          0829*      inc de
0B04DD 13          0830*      inc de
0B04DE             0831*  ;	call debug_print
0B04DE             0832*  ; Iteration 9
0B04DE F1          0833*      pop af
0B04DF 17          0834*      rla
0B04E0 ED 6A       0835*      adc hl,hl
0B04E2 17          0836*      rla
0B04E3 ED 6A       0837*      adc hl,hl
0B04E5 EB          0838*      ex de,hl
0B04E6 29          0839*      add hl,hl
0B04E7 ED 52       0840*      sbc hl,de
0B04E9 19          0841*      add hl,de
0B04EA EB          0842*      ex de,hl
0B04EB 30 04       0843*      jr nc,$+6
0B04ED ED 52       0844*      sbc hl,de
0B04EF 13          0845*      inc de
0B04F0 13          0846*      inc de
0B04F1             0847*  ;	call debug_print
0B04F1             0848*  ; Iteration 10
0B04F1 17          0849*      rla
0B04F2 ED 6A       0850*      adc hl,hl
0B04F4 17          0851*      rla
0B04F5 ED 6A       0852*      adc hl,hl
0B04F7 EB          0853*      ex de,hl
0B04F8 29          0854*      add hl,hl
0B04F9 ED 52       0855*      sbc hl,de
0B04FB 19          0856*      add hl,de
0B04FC EB          0857*      ex de,hl
0B04FD 30 04       0858*      jr nc,$+6
0B04FF ED 52       0859*      sbc hl,de
0B0501 13          0860*      inc de
0B0502 13          0861*      inc de
0B0503             0862*  ;	call debug_print
0B0503             0863*  ; Iteration 11
0B0503 17          0864*      rla
0B0504 ED 6A       0865*      adc hl,hl
0B0506 17          0866*      rla
0B0507 ED 6A       0867*      adc hl,hl
0B0509 EB          0868*      ex de,hl
0B050A 29          0869*      add hl,hl
0B050B ED 52       0870*      sbc hl,de
0B050D 19          0871*      add hl,de
0B050E EB          0872*      ex de,hl
0B050F 30 04       0873*      jr nc,$+6
0B0511 ED 52       0874*      sbc hl,de
0B0513 13          0875*      inc de
0B0514 13          0876*      inc de
0B0515             0877*  ;	call debug_print
0B0515             0878*  ; Iteration 12
0B0515 17          0879*      rla
0B0516 ED 6A       0880*      adc hl,hl
0B0518 17          0881*      rla
0B0519 ED 6A       0882*      adc hl,hl
0B051B EB          0883*      ex de,hl
0B051C 29          0884*      add hl,hl
0B051D ED 52       0885*      sbc hl,de
0B051F 19          0886*      add hl,de
0B0520 EB          0887*      ex de,hl
0B0521 30 04       0888*      jr nc,$+6
0B0523 ED 52       0889*      sbc hl,de
0B0525 13          0890*      inc de
0B0526 13          0891*      inc de
0B0527             0892*  ;	call debug_print
0B0527             0893*  ; Final output
0B0527 CB 1A       0894*      rr d
0B0529 CB 1B       0895*      rr e
0B052B C9          0896*      ret
0B052C             0897*  
0B052C             0898*  sin_lut_168:
0B052C 00 00 00    0899*  	dl 0x000000 ; 0.000 00, 0.000
0B052F 06 00 00    0900*  	dl 0x000006 ; 1.406 01, 0.025
0B0532 0C 00 00    0901*  	dl 0x00000C ; 2.813 02, 0.049
0B0535 12 00 00    0902*  	dl 0x000012 ; 4.219 03, 0.074
0B0538 19 00 00    0903*  	dl 0x000019 ; 5.625 04, 0.098
0B053B 1F 00 00    0904*  	dl 0x00001F ; 7.031 05, 0.122
0B053E 25 00 00    0905*  	dl 0x000025 ; 8.438 06, 0.147
0B0541 2B 00 00    0906*  	dl 0x00002B ; 9.844 07, 0.171
0B0544 31 00 00    0907*  	dl 0x000031 ; 11.250 08, 0.195
0B0547 38 00 00    0908*  	dl 0x000038 ; 12.656 09, 0.219
0B054A 3E 00 00    0909*  	dl 0x00003E ; 14.063 0A, 0.243
0B054D 44 00 00    0910*  	dl 0x000044 ; 15.469 0B, 0.267
0B0550 4A 00 00    0911*  	dl 0x00004A ; 16.875 0C, 0.290
0B0553 50 00 00    0912*  	dl 0x000050 ; 18.281 0D, 0.314
0B0556 56 00 00    0913*  	dl 0x000056 ; 19.688 0E, 0.337
0B0559 5C 00 00    0914*  	dl 0x00005C ; 21.094 0F, 0.360
0B055C 61 00 00    0915*  	dl 0x000061 ; 22.500 10, 0.383
0B055F 67 00 00    0916*  	dl 0x000067 ; 23.906 11, 0.405
0B0562 6D 00 00    0917*  	dl 0x00006D ; 25.313 12, 0.428
0B0565 73 00 00    0918*  	dl 0x000073 ; 26.719 13, 0.450
0B0568 78 00 00    0919*  	dl 0x000078 ; 28.125 14, 0.471
0B056B 7E 00 00    0920*  	dl 0x00007E ; 29.531 15, 0.493
0B056E 83 00 00    0921*  	dl 0x000083 ; 30.938 16, 0.514
0B0571 88 00 00    0922*  	dl 0x000088 ; 32.344 17, 0.535
0B0574 8E 00 00    0923*  	dl 0x00008E ; 33.750 18, 0.556
0B0577 93 00 00    0924*  	dl 0x000093 ; 35.156 19, 0.576
0B057A 98 00 00    0925*  	dl 0x000098 ; 36.563 1A, 0.596
0B057D 9D 00 00    0926*  	dl 0x00009D ; 37.969 1B, 0.615
0B0580 A2 00 00    0927*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0583 A7 00 00    0928*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0586 AB 00 00    0929*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0589 B0 00 00    0930*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B058C B5 00 00    0931*  	dl 0x0000B5 ; 45.000 20, 0.707
0B058F B9 00 00    0932*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0592 BD 00 00    0933*  	dl 0x0000BD ; 47.813 22, 0.741
0B0595 C1 00 00    0934*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0598 C5 00 00    0935*  	dl 0x0000C5 ; 50.625 24, 0.773
0B059B C9 00 00    0936*  	dl 0x0000C9 ; 52.031 25, 0.788
0B059E CD 00 00    0937*  	dl 0x0000CD ; 53.438 26, 0.803
0B05A1 D1 00 00    0938*  	dl 0x0000D1 ; 54.844 27, 0.818
0B05A4 D4 00 00    0939*  	dl 0x0000D4 ; 56.250 28, 0.831
0B05A7 D8 00 00    0940*  	dl 0x0000D8 ; 57.656 29, 0.845
0B05AA DB 00 00    0941*  	dl 0x0000DB ; 59.063 2A, 0.858
0B05AD DE 00 00    0942*  	dl 0x0000DE ; 60.469 2B, 0.870
0B05B0 E1 00 00    0943*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B05B3 E4 00 00    0944*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B05B6 E7 00 00    0945*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B05B9 EA 00 00    0946*  	dl 0x0000EA ; 66.094 2F, 0.914
0B05BC EC 00 00    0947*  	dl 0x0000EC ; 67.500 30, 0.924
0B05BF EE 00 00    0948*  	dl 0x0000EE ; 68.906 31, 0.933
0B05C2 F1 00 00    0949*  	dl 0x0000F1 ; 70.313 32, 0.942
0B05C5 F3 00 00    0950*  	dl 0x0000F3 ; 71.719 33, 0.950
0B05C8 F4 00 00    0951*  	dl 0x0000F4 ; 73.125 34, 0.957
0B05CB F6 00 00    0952*  	dl 0x0000F6 ; 74.531 35, 0.964
0B05CE F8 00 00    0953*  	dl 0x0000F8 ; 75.938 36, 0.970
0B05D1 F9 00 00    0954*  	dl 0x0000F9 ; 77.344 37, 0.976
0B05D4 FB 00 00    0955*  	dl 0x0000FB ; 78.750 38, 0.981
0B05D7 FC 00 00    0956*  	dl 0x0000FC ; 80.156 39, 0.985
0B05DA FD 00 00    0957*  	dl 0x0000FD ; 81.563 3A, 0.989
0B05DD FE 00 00    0958*  	dl 0x0000FE ; 82.969 3B, 0.992
0B05E0 FE 00 00    0959*  	dl 0x0000FE ; 84.375 3C, 0.995
0B05E3 FF 00 00    0960*  	dl 0x0000FF ; 85.781 3D, 0.997
0B05E6 FF 00 00    0961*  	dl 0x0000FF ; 87.188 3E, 0.999
0B05E9 FF 00 00    0962*  	dl 0x0000FF ; 88.594 3F, 1.000
0B05EC 00 01 00    0963*  	dl 0x000100 ; 90.000 40, 1.000
0B05EF FF 00 00    0964*  	dl 0x0000FF ; 91.406 41, 1.000
0B05F2 FF 00 00    0965*  	dl 0x0000FF ; 92.813 42, 0.999
0B05F5 FF 00 00    0966*  	dl 0x0000FF ; 94.219 43, 0.997
0B05F8 FE 00 00    0967*  	dl 0x0000FE ; 95.625 44, 0.995
0B05FB FE 00 00    0968*  	dl 0x0000FE ; 97.031 45, 0.992
0B05FE FD 00 00    0969*  	dl 0x0000FD ; 98.438 46, 0.989
0B0601 FC 00 00    0970*  	dl 0x0000FC ; 99.844 47, 0.985
0B0604 FB 00 00    0971*  	dl 0x0000FB ; 101.250 48, 0.981
0B0607 F9 00 00    0972*  	dl 0x0000F9 ; 102.656 49, 0.976
0B060A F8 00 00    0973*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B060D F6 00 00    0974*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B0610 F4 00 00    0975*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B0613 F3 00 00    0976*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B0616 F1 00 00    0977*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B0619 EE 00 00    0978*  	dl 0x0000EE ; 111.094 4F, 0.933
0B061C EC 00 00    0979*  	dl 0x0000EC ; 112.500 50, 0.924
0B061F EA 00 00    0980*  	dl 0x0000EA ; 113.906 51, 0.914
0B0622 E7 00 00    0981*  	dl 0x0000E7 ; 115.313 52, 0.904
0B0625 E4 00 00    0982*  	dl 0x0000E4 ; 116.719 53, 0.893
0B0628 E1 00 00    0983*  	dl 0x0000E1 ; 118.125 54, 0.882
0B062B DE 00 00    0984*  	dl 0x0000DE ; 119.531 55, 0.870
0B062E DB 00 00    0985*  	dl 0x0000DB ; 120.938 56, 0.858
0B0631 D8 00 00    0986*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0634 D4 00 00    0987*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0637 D1 00 00    0988*  	dl 0x0000D1 ; 125.156 59, 0.818
0B063A CD 00 00    0989*  	dl 0x0000CD ; 126.563 5A, 0.803
0B063D C9 00 00    0990*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0640 C5 00 00    0991*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0643 C1 00 00    0992*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0646 BD 00 00    0993*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0649 B9 00 00    0994*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B064C B5 00 00    0995*  	dl 0x0000B5 ; 135.000 60, 0.707
0B064F B0 00 00    0996*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0652 AB 00 00    0997*  	dl 0x0000AB ; 137.813 62, 0.672
0B0655 A7 00 00    0998*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0658 A2 00 00    0999*  	dl 0x0000A2 ; 140.625 64, 0.634
0B065B 9D 00 00    1000*  	dl 0x00009D ; 142.031 65, 0.615
0B065E 98 00 00    1001*  	dl 0x000098 ; 143.438 66, 0.596
0B0661 93 00 00    1002*  	dl 0x000093 ; 144.844 67, 0.576
0B0664 8E 00 00    1003*  	dl 0x00008E ; 146.250 68, 0.556
0B0667 88 00 00    1004*  	dl 0x000088 ; 147.656 69, 0.535
0B066A 83 00 00    1005*  	dl 0x000083 ; 149.063 6A, 0.514
0B066D 7E 00 00    1006*  	dl 0x00007E ; 150.469 6B, 0.493
0B0670 78 00 00    1007*  	dl 0x000078 ; 151.875 6C, 0.471
0B0673 73 00 00    1008*  	dl 0x000073 ; 153.281 6D, 0.450
0B0676 6D 00 00    1009*  	dl 0x00006D ; 154.688 6E, 0.428
0B0679 67 00 00    1010*  	dl 0x000067 ; 156.094 6F, 0.405
0B067C 61 00 00    1011*  	dl 0x000061 ; 157.500 70, 0.383
0B067F 5C 00 00    1012*  	dl 0x00005C ; 158.906 71, 0.360
0B0682 56 00 00    1013*  	dl 0x000056 ; 160.313 72, 0.337
0B0685 50 00 00    1014*  	dl 0x000050 ; 161.719 73, 0.314
0B0688 4A 00 00    1015*  	dl 0x00004A ; 163.125 74, 0.290
0B068B 44 00 00    1016*  	dl 0x000044 ; 164.531 75, 0.267
0B068E 3E 00 00    1017*  	dl 0x00003E ; 165.938 76, 0.243
0B0691 38 00 00    1018*  	dl 0x000038 ; 167.344 77, 0.219
0B0694 31 00 00    1019*  	dl 0x000031 ; 168.750 78, 0.195
0B0697 2B 00 00    1020*  	dl 0x00002B ; 170.156 79, 0.171
0B069A 25 00 00    1021*  	dl 0x000025 ; 171.563 7A, 0.147
0B069D 1F 00 00    1022*  	dl 0x00001F ; 172.969 7B, 0.122
0B06A0 19 00 00    1023*  	dl 0x000019 ; 174.375 7C, 0.098
0B06A3 12 00 00    1024*  	dl 0x000012 ; 175.781 7D, 0.074
0B06A6 0C 00 00    1025*  	dl 0x00000C ; 177.188 7E, 0.049
0B06A9 06 00 00    1026*  	dl 0x000006 ; 178.594 7F, 0.025
0B06AC 00 00 00    1027*  	dl 0x000000 ; 180.000 80, 0.000
0B06AF FA FF FF    1028*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B06B2 F4 FF FF    1029*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B06B5 EE FF FF    1030*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B06B8 E7 FF FF    1031*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B06BB E1 FF FF    1032*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B06BE DB FF FF    1033*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B06C1 D5 FF FF    1034*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B06C4 CF FF FF    1035*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B06C7 C8 FF FF    1036*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B06CA C2 FF FF    1037*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B06CD BC FF FF    1038*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B06D0 B6 FF FF    1039*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B06D3 B0 FF FF    1040*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B06D6 AA FF FF    1041*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B06D9 A4 FF FF    1042*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B06DC 9F FF FF    1043*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B06DF 99 FF FF    1044*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B06E2 93 FF FF    1045*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B06E5 8D FF FF    1046*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B06E8 88 FF FF    1047*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B06EB 82 FF FF    1048*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B06EE 7D FF FF    1049*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B06F1 78 FF FF    1050*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B06F4 72 FF FF    1051*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B06F7 6D FF FF    1052*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B06FA 68 FF FF    1053*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B06FD 63 FF FF    1054*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B0700 5E FF FF    1055*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B0703 59 FF FF    1056*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B0706 55 FF FF    1057*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B0709 50 FF FF    1058*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B070C 4B FF FF    1059*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B070F 47 FF FF    1060*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B0712 43 FF FF    1061*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B0715 3F FF FF    1062*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B0718 3B FF FF    1063*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B071B 37 FF FF    1064*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B071E 33 FF FF    1065*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B0721 2F FF FF    1066*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B0724 2C FF FF    1067*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B0727 28 FF FF    1068*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B072A 25 FF FF    1069*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B072D 22 FF FF    1070*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B0730 1F FF FF    1071*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B0733 1C FF FF    1072*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B0736 19 FF FF    1073*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B0739 16 FF FF    1074*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B073C 14 FF FF    1075*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B073F 12 FF FF    1076*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0742 0F FF FF    1077*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0745 0D FF FF    1078*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B0748 0C FF FF    1079*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B074B 0A FF FF    1080*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B074E 08 FF FF    1081*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0751 07 FF FF    1082*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0754 05 FF FF    1083*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0757 04 FF FF    1084*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B075A 03 FF FF    1085*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B075D 02 FF FF    1086*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0760 02 FF FF    1087*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0763 01 FF FF    1088*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0766 01 FF FF    1089*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B0769 01 FF FF    1090*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B076C 00 FF FF    1091*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B076F 01 FF FF    1092*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0772 01 FF FF    1093*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0775 01 FF FF    1094*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B0778 02 FF FF    1095*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B077B 02 FF FF    1096*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B077E 03 FF FF    1097*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0781 04 FF FF    1098*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0784 05 FF FF    1099*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0787 07 FF FF    1100*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B078A 08 FF FF    1101*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B078D 0A FF FF    1102*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0790 0C FF FF    1103*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0793 0D FF FF    1104*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0796 0F FF FF    1105*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B0799 12 FF FF    1106*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B079C 14 FF FF    1107*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B079F 16 FF FF    1108*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B07A2 19 FF FF    1109*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B07A5 1C FF FF    1110*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B07A8 1F FF FF    1111*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B07AB 22 FF FF    1112*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B07AE 25 FF FF    1113*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B07B1 28 FF FF    1114*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B07B4 2C FF FF    1115*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B07B7 2F FF FF    1116*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B07BA 33 FF FF    1117*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B07BD 37 FF FF    1118*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B07C0 3B FF FF    1119*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B07C3 3F FF FF    1120*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B07C6 43 FF FF    1121*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B07C9 47 FF FF    1122*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B07CC 4B FF FF    1123*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B07CF 50 FF FF    1124*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B07D2 55 FF FF    1125*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B07D5 59 FF FF    1126*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B07D8 5E FF FF    1127*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B07DB 63 FF FF    1128*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B07DE 68 FF FF    1129*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B07E1 6D FF FF    1130*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B07E4 72 FF FF    1131*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B07E7 78 FF FF    1132*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B07EA 7D FF FF    1133*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B07ED 82 FF FF    1134*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B07F0 88 FF FF    1135*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B07F3 8D FF FF    1136*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B07F6 93 FF FF    1137*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B07F9 99 FF FF    1138*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B07FC 9F FF FF    1139*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B07FF A4 FF FF    1140*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B0802 AA FF FF    1141*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B0805 B0 FF FF    1142*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B0808 B6 FF FF    1143*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B080B BC FF FF    1144*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B080E C2 FF FF    1145*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B0811 C8 FF FF    1146*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B0814 CF FF FF    1147*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B0817 D5 FF FF    1148*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B081A DB FF FF    1149*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B081D E1 FF FF    1150*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B0820 E7 FF FF    1151*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B0823 EE FF FF    1152*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B0826 F4 FF FF    1153*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B0829 FA FF FF    1154*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B082C 00 00 00    1155*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B082F             1156*  
0B082F             1157*  atan_lut_168:
0B082F 00 00 00    1158*  	dl 0x000000 ; 000000, 0.000
0B0832 28 00 00    1159*  	dl 0x000028 ; 000001, 0.224
0B0835 51 00 00    1160*  	dl 0x000051 ; 000002, 0.448
0B0838 7A 00 00    1161*  	dl 0x00007A ; 000003, 0.671
0B083B A2 00 00    1162*  	dl 0x0000A2 ; 000004, 0.895
0B083E CB 00 00    1163*  	dl 0x0000CB ; 000005, 1.119
0B0841 F4 00 00    1164*  	dl 0x0000F4 ; 000006, 1.343
0B0844 1D 01 00    1165*  	dl 0x00011D ; 000007, 1.566
0B0847 45 01 00    1166*  	dl 0x000145 ; 000008, 1.790
0B084A 6E 01 00    1167*  	dl 0x00016E ; 000009, 2.013
0B084D 97 01 00    1168*  	dl 0x000197 ; 00000A, 2.237
0B0850 BF 01 00    1169*  	dl 0x0001BF ; 00000B, 2.460
0B0853 E8 01 00    1170*  	dl 0x0001E8 ; 00000C, 2.684
0B0856 11 02 00    1171*  	dl 0x000211 ; 00000D, 2.907
0B0859 39 02 00    1172*  	dl 0x000239 ; 00000E, 3.130
0B085C 62 02 00    1173*  	dl 0x000262 ; 00000F, 3.353
0B085F 8B 02 00    1174*  	dl 0x00028B ; 000010, 3.576
0B0862 B3 02 00    1175*  	dl 0x0002B3 ; 000011, 3.799
0B0865 DC 02 00    1176*  	dl 0x0002DC ; 000012, 4.022
0B0868 04 03 00    1177*  	dl 0x000304 ; 000013, 4.245
0B086B 2D 03 00    1178*  	dl 0x00032D ; 000014, 4.467
0B086E 55 03 00    1179*  	dl 0x000355 ; 000015, 4.690
0B0871 7E 03 00    1180*  	dl 0x00037E ; 000016, 4.912
0B0874 A6 03 00    1181*  	dl 0x0003A6 ; 000017, 5.134
0B0877 CE 03 00    1182*  	dl 0x0003CE ; 000018, 5.356
0B087A F7 03 00    1183*  	dl 0x0003F7 ; 000019, 5.578
0B087D 1F 04 00    1184*  	dl 0x00041F ; 00001A, 5.799
0B0880 48 04 00    1185*  	dl 0x000448 ; 00001B, 6.021
0B0883 70 04 00    1186*  	dl 0x000470 ; 00001C, 6.242
0B0886 98 04 00    1187*  	dl 0x000498 ; 00001D, 6.463
0B0889 C0 04 00    1188*  	dl 0x0004C0 ; 00001E, 6.684
0B088C E8 04 00    1189*  	dl 0x0004E8 ; 00001F, 6.905
0B088F 11 05 00    1190*  	dl 0x000511 ; 000020, 7.125
0B0892 39 05 00    1191*  	dl 0x000539 ; 000021, 7.345
0B0895 61 05 00    1192*  	dl 0x000561 ; 000022, 7.565
0B0898 89 05 00    1193*  	dl 0x000589 ; 000023, 7.785
0B089B B1 05 00    1194*  	dl 0x0005B1 ; 000024, 8.005
0B089E D9 05 00    1195*  	dl 0x0005D9 ; 000025, 8.224
0B08A1 01 06 00    1196*  	dl 0x000601 ; 000026, 8.443
0B08A4 28 06 00    1197*  	dl 0x000628 ; 000027, 8.662
0B08A7 50 06 00    1198*  	dl 0x000650 ; 000028, 8.881
0B08AA 78 06 00    1199*  	dl 0x000678 ; 000029, 9.099
0B08AD A0 06 00    1200*  	dl 0x0006A0 ; 00002A, 9.317
0B08B0 C7 06 00    1201*  	dl 0x0006C7 ; 00002B, 9.535
0B08B3 EF 06 00    1202*  	dl 0x0006EF ; 00002C, 9.752
0B08B6 16 07 00    1203*  	dl 0x000716 ; 00002D, 9.970
0B08B9 3E 07 00    1204*  	dl 0x00073E ; 00002E, 10.187
0B08BC 65 07 00    1205*  	dl 0x000765 ; 00002F, 10.403
0B08BF 8D 07 00    1206*  	dl 0x00078D ; 000030, 10.620
0B08C2 B4 07 00    1207*  	dl 0x0007B4 ; 000031, 10.836
0B08C5 DB 07 00    1208*  	dl 0x0007DB ; 000032, 11.051
0B08C8 03 08 00    1209*  	dl 0x000803 ; 000033, 11.267
0B08CB 2A 08 00    1210*  	dl 0x00082A ; 000034, 11.482
0B08CE 51 08 00    1211*  	dl 0x000851 ; 000035, 11.697
0B08D1 78 08 00    1212*  	dl 0x000878 ; 000036, 11.911
0B08D4 9F 08 00    1213*  	dl 0x00089F ; 000037, 12.125
0B08D7 C6 08 00    1214*  	dl 0x0008C6 ; 000038, 12.339
0B08DA ED 08 00    1215*  	dl 0x0008ED ; 000039, 12.553
0B08DD 13 09 00    1216*  	dl 0x000913 ; 00003A, 12.766
0B08E0 3A 09 00    1217*  	dl 0x00093A ; 00003B, 12.978
0B08E3 61 09 00    1218*  	dl 0x000961 ; 00003C, 13.191
0B08E6 87 09 00    1219*  	dl 0x000987 ; 00003D, 13.403
0B08E9 AE 09 00    1220*  	dl 0x0009AE ; 00003E, 13.614
0B08EC D4 09 00    1221*  	dl 0x0009D4 ; 00003F, 13.825
0B08EF FB 09 00    1222*  	dl 0x0009FB ; 000040, 14.036
0B08F2 21 0A 00    1223*  	dl 0x000A21 ; 000041, 14.247
0B08F5 47 0A 00    1224*  	dl 0x000A47 ; 000042, 14.457
0B08F8 6D 0A 00    1225*  	dl 0x000A6D ; 000043, 14.666
0B08FB 94 0A 00    1226*  	dl 0x000A94 ; 000044, 14.876
0B08FE BA 0A 00    1227*  	dl 0x000ABA ; 000045, 15.085
0B0901 E0 0A 00    1228*  	dl 0x000AE0 ; 000046, 15.293
0B0904 05 0B 00    1229*  	dl 0x000B05 ; 000047, 15.501
0B0907 2B 0B 00    1230*  	dl 0x000B2B ; 000048, 15.709
0B090A 51 0B 00    1231*  	dl 0x000B51 ; 000049, 15.916
0B090D 77 0B 00    1232*  	dl 0x000B77 ; 00004A, 16.123
0B0910 9C 0B 00    1233*  	dl 0x000B9C ; 00004B, 16.329
0B0913 C2 0B 00    1234*  	dl 0x000BC2 ; 00004C, 16.535
0B0916 E7 0B 00    1235*  	dl 0x000BE7 ; 00004D, 16.740
0B0919 0C 0C 00    1236*  	dl 0x000C0C ; 00004E, 16.945
0B091C 32 0C 00    1237*  	dl 0x000C32 ; 00004F, 17.150
0B091F 57 0C 00    1238*  	dl 0x000C57 ; 000050, 17.354
0B0922 7C 0C 00    1239*  	dl 0x000C7C ; 000051, 17.558
0B0925 A1 0C 00    1240*  	dl 0x000CA1 ; 000052, 17.761
0B0928 C6 0C 00    1241*  	dl 0x000CC6 ; 000053, 17.964
0B092B EB 0C 00    1242*  	dl 0x000CEB ; 000054, 18.166
0B092E 0F 0D 00    1243*  	dl 0x000D0F ; 000055, 18.368
0B0931 34 0D 00    1244*  	dl 0x000D34 ; 000056, 18.569
0B0934 58 0D 00    1245*  	dl 0x000D58 ; 000057, 18.770
0B0937 7D 0D 00    1246*  	dl 0x000D7D ; 000058, 18.970
0B093A A1 0D 00    1247*  	dl 0x000DA1 ; 000059, 19.170
0B093D C6 0D 00    1248*  	dl 0x000DC6 ; 00005A, 19.370
0B0940 EA 0D 00    1249*  	dl 0x000DEA ; 00005B, 19.569
0B0943 0E 0E 00    1250*  	dl 0x000E0E ; 00005C, 19.767
0B0946 32 0E 00    1251*  	dl 0x000E32 ; 00005D, 19.965
0B0949 56 0E 00    1252*  	dl 0x000E56 ; 00005E, 20.163
0B094C 7A 0E 00    1253*  	dl 0x000E7A ; 00005F, 20.360
0B094F 9E 0E 00    1254*  	dl 0x000E9E ; 000060, 20.556
0B0952 C1 0E 00    1255*  	dl 0x000EC1 ; 000061, 20.752
0B0955 E5 0E 00    1256*  	dl 0x000EE5 ; 000062, 20.947
0B0958 08 0F 00    1257*  	dl 0x000F08 ; 000063, 21.142
0B095B 2C 0F 00    1258*  	dl 0x000F2C ; 000064, 21.337
0B095E 4F 0F 00    1259*  	dl 0x000F4F ; 000065, 21.531
0B0961 72 0F 00    1260*  	dl 0x000F72 ; 000066, 21.724
0B0964 95 0F 00    1261*  	dl 0x000F95 ; 000067, 21.917
0B0967 B8 0F 00    1262*  	dl 0x000FB8 ; 000068, 22.109
0B096A DB 0F 00    1263*  	dl 0x000FDB ; 000069, 22.301
0B096D FE 0F 00    1264*  	dl 0x000FFE ; 00006A, 22.493
0B0970 21 10 00    1265*  	dl 0x001021 ; 00006B, 22.683
0B0973 44 10 00    1266*  	dl 0x001044 ; 00006C, 22.874
0B0976 66 10 00    1267*  	dl 0x001066 ; 00006D, 23.063
0B0979 89 10 00    1268*  	dl 0x001089 ; 00006E, 23.253
0B097C AB 10 00    1269*  	dl 0x0010AB ; 00006F, 23.441
0B097F CD 10 00    1270*  	dl 0x0010CD ; 000070, 23.629
0B0982 EF 10 00    1271*  	dl 0x0010EF ; 000071, 23.817
0B0985 11 11 00    1272*  	dl 0x001111 ; 000072, 24.004
0B0988 33 11 00    1273*  	dl 0x001133 ; 000073, 24.191
0B098B 55 11 00    1274*  	dl 0x001155 ; 000074, 24.376
0B098E 77 11 00    1275*  	dl 0x001177 ; 000075, 24.562
0B0991 99 11 00    1276*  	dl 0x001199 ; 000076, 24.747
0B0994 BA 11 00    1277*  	dl 0x0011BA ; 000077, 24.931
0B0997 DC 11 00    1278*  	dl 0x0011DC ; 000078, 25.115
0B099A FD 11 00    1279*  	dl 0x0011FD ; 000079, 25.298
0B099D 1E 12 00    1280*  	dl 0x00121E ; 00007A, 25.481
0B09A0 3F 12 00    1281*  	dl 0x00123F ; 00007B, 25.663
0B09A3 60 12 00    1282*  	dl 0x001260 ; 00007C, 25.844
0B09A6 81 12 00    1283*  	dl 0x001281 ; 00007D, 26.025
0B09A9 A2 12 00    1284*  	dl 0x0012A2 ; 00007E, 26.206
0B09AC C3 12 00    1285*  	dl 0x0012C3 ; 00007F, 26.386
0B09AF E4 12 00    1286*  	dl 0x0012E4 ; 000080, 26.565
0B09B2 04 13 00    1287*  	dl 0x001304 ; 000081, 26.744
0B09B5 25 13 00    1288*  	dl 0x001325 ; 000082, 26.922
0B09B8 45 13 00    1289*  	dl 0x001345 ; 000083, 27.100
0B09BB 65 13 00    1290*  	dl 0x001365 ; 000084, 27.277
0B09BE 85 13 00    1291*  	dl 0x001385 ; 000085, 27.453
0B09C1 A5 13 00    1292*  	dl 0x0013A5 ; 000086, 27.629
0B09C4 C5 13 00    1293*  	dl 0x0013C5 ; 000087, 27.805
0B09C7 E5 13 00    1294*  	dl 0x0013E5 ; 000088, 27.979
0B09CA 05 14 00    1295*  	dl 0x001405 ; 000089, 28.154
0B09CD 24 14 00    1296*  	dl 0x001424 ; 00008A, 28.327
0B09D0 44 14 00    1297*  	dl 0x001444 ; 00008B, 28.501
0B09D3 63 14 00    1298*  	dl 0x001463 ; 00008C, 28.673
0B09D6 83 14 00    1299*  	dl 0x001483 ; 00008D, 28.845
0B09D9 A2 14 00    1300*  	dl 0x0014A2 ; 00008E, 29.017
0B09DC C1 14 00    1301*  	dl 0x0014C1 ; 00008F, 29.187
0B09DF E0 14 00    1302*  	dl 0x0014E0 ; 000090, 29.358
0B09E2 FF 14 00    1303*  	dl 0x0014FF ; 000091, 29.527
0B09E5 1E 15 00    1304*  	dl 0x00151E ; 000092, 29.697
0B09E8 3C 15 00    1305*  	dl 0x00153C ; 000093, 29.865
0B09EB 5B 15 00    1306*  	dl 0x00155B ; 000094, 30.033
0B09EE 79 15 00    1307*  	dl 0x001579 ; 000095, 30.201
0B09F1 98 15 00    1308*  	dl 0x001598 ; 000096, 30.368
0B09F4 B6 15 00    1309*  	dl 0x0015B6 ; 000097, 30.534
0B09F7 D4 15 00    1310*  	dl 0x0015D4 ; 000098, 30.700
0B09FA F2 15 00    1311*  	dl 0x0015F2 ; 000099, 30.865
0B09FD 10 16 00    1312*  	dl 0x001610 ; 00009A, 31.030
0B0A00 2E 16 00    1313*  	dl 0x00162E ; 00009B, 31.194
0B0A03 4C 16 00    1314*  	dl 0x00164C ; 00009C, 31.357
0B0A06 6A 16 00    1315*  	dl 0x00166A ; 00009D, 31.520
0B0A09 87 16 00    1316*  	dl 0x001687 ; 00009E, 31.682
0B0A0C A5 16 00    1317*  	dl 0x0016A5 ; 00009F, 31.844
0B0A0F C2 16 00    1318*  	dl 0x0016C2 ; 0000A0, 32.005
0B0A12 DF 16 00    1319*  	dl 0x0016DF ; 0000A1, 32.166
0B0A15 FC 16 00    1320*  	dl 0x0016FC ; 0000A2, 32.326
0B0A18 19 17 00    1321*  	dl 0x001719 ; 0000A3, 32.486
0B0A1B 36 17 00    1322*  	dl 0x001736 ; 0000A4, 32.645
0B0A1E 53 17 00    1323*  	dl 0x001753 ; 0000A5, 32.803
0B0A21 70 17 00    1324*  	dl 0x001770 ; 0000A6, 32.961
0B0A24 8C 17 00    1325*  	dl 0x00178C ; 0000A7, 33.118
0B0A27 A9 17 00    1326*  	dl 0x0017A9 ; 0000A8, 33.275
0B0A2A C5 17 00    1327*  	dl 0x0017C5 ; 0000A9, 33.431
0B0A2D E2 17 00    1328*  	dl 0x0017E2 ; 0000AA, 33.587
0B0A30 FE 17 00    1329*  	dl 0x0017FE ; 0000AB, 33.742
0B0A33 1A 18 00    1330*  	dl 0x00181A ; 0000AC, 33.896
0B0A36 36 18 00    1331*  	dl 0x001836 ; 0000AD, 34.050
0B0A39 52 18 00    1332*  	dl 0x001852 ; 0000AE, 34.203
0B0A3C 6E 18 00    1333*  	dl 0x00186E ; 0000AF, 34.356
0B0A3F 8A 18 00    1334*  	dl 0x00188A ; 0000B0, 34.509
0B0A42 A5 18 00    1335*  	dl 0x0018A5 ; 0000B1, 34.660
0B0A45 C1 18 00    1336*  	dl 0x0018C1 ; 0000B2, 34.811
0B0A48 DC 18 00    1337*  	dl 0x0018DC ; 0000B3, 34.962
0B0A4B F7 18 00    1338*  	dl 0x0018F7 ; 0000B4, 35.112
0B0A4E 13 19 00    1339*  	dl 0x001913 ; 0000B5, 35.262
0B0A51 2E 19 00    1340*  	dl 0x00192E ; 0000B6, 35.410
0B0A54 49 19 00    1341*  	dl 0x001949 ; 0000B7, 35.559
0B0A57 64 19 00    1342*  	dl 0x001964 ; 0000B8, 35.707
0B0A5A 7F 19 00    1343*  	dl 0x00197F ; 0000B9, 35.854
0B0A5D 99 19 00    1344*  	dl 0x001999 ; 0000BA, 36.001
0B0A60 B4 19 00    1345*  	dl 0x0019B4 ; 0000BB, 36.147
0B0A63 CE 19 00    1346*  	dl 0x0019CE ; 0000BC, 36.293
0B0A66 E9 19 00    1347*  	dl 0x0019E9 ; 0000BD, 36.438
0B0A69 03 1A 00    1348*  	dl 0x001A03 ; 0000BE, 36.582
0B0A6C 1D 1A 00    1349*  	dl 0x001A1D ; 0000BF, 36.726
0B0A6F 37 1A 00    1350*  	dl 0x001A37 ; 0000C0, 36.870
0B0A72 51 1A 00    1351*  	dl 0x001A51 ; 0000C1, 37.013
0B0A75 6B 1A 00    1352*  	dl 0x001A6B ; 0000C2, 37.155
0B0A78 85 1A 00    1353*  	dl 0x001A85 ; 0000C3, 37.297
0B0A7B 9F 1A 00    1354*  	dl 0x001A9F ; 0000C4, 37.439
0B0A7E B9 1A 00    1355*  	dl 0x001AB9 ; 0000C5, 37.579
0B0A81 D2 1A 00    1356*  	dl 0x001AD2 ; 0000C6, 37.720
0B0A84 EC 1A 00    1357*  	dl 0x001AEC ; 0000C7, 37.859
0B0A87 05 1B 00    1358*  	dl 0x001B05 ; 0000C8, 37.999
0B0A8A 1E 1B 00    1359*  	dl 0x001B1E ; 0000C9, 38.137
0B0A8D 37 1B 00    1360*  	dl 0x001B37 ; 0000CA, 38.276
0B0A90 50 1B 00    1361*  	dl 0x001B50 ; 0000CB, 38.413
0B0A93 69 1B 00    1362*  	dl 0x001B69 ; 0000CC, 38.550
0B0A96 82 1B 00    1363*  	dl 0x001B82 ; 0000CD, 38.687
0B0A99 9B 1B 00    1364*  	dl 0x001B9B ; 0000CE, 38.823
0B0A9C B4 1B 00    1365*  	dl 0x001BB4 ; 0000CF, 38.959
0B0A9F CC 1B 00    1366*  	dl 0x001BCC ; 0000D0, 39.094
0B0AA2 E5 1B 00    1367*  	dl 0x001BE5 ; 0000D1, 39.228
0B0AA5 FD 1B 00    1368*  	dl 0x001BFD ; 0000D2, 39.362
0B0AA8 16 1C 00    1369*  	dl 0x001C16 ; 0000D3, 39.496
0B0AAB 2E 1C 00    1370*  	dl 0x001C2E ; 0000D4, 39.629
0B0AAE 46 1C 00    1371*  	dl 0x001C46 ; 0000D5, 39.762
0B0AB1 5E 1C 00    1372*  	dl 0x001C5E ; 0000D6, 39.894
0B0AB4 76 1C 00    1373*  	dl 0x001C76 ; 0000D7, 40.025
0B0AB7 8E 1C 00    1374*  	dl 0x001C8E ; 0000D8, 40.156
0B0ABA A5 1C 00    1375*  	dl 0x001CA5 ; 0000D9, 40.286
0B0ABD BD 1C 00    1376*  	dl 0x001CBD ; 0000DA, 40.416
0B0AC0 D5 1C 00    1377*  	dl 0x001CD5 ; 0000DB, 40.546
0B0AC3 EC 1C 00    1378*  	dl 0x001CEC ; 0000DC, 40.675
0B0AC6 04 1D 00    1379*  	dl 0x001D04 ; 0000DD, 40.803
0B0AC9 1B 1D 00    1380*  	dl 0x001D1B ; 0000DE, 40.931
0B0ACC 32 1D 00    1381*  	dl 0x001D32 ; 0000DF, 41.059
0B0ACF 49 1D 00    1382*  	dl 0x001D49 ; 0000E0, 41.186
0B0AD2 60 1D 00    1383*  	dl 0x001D60 ; 0000E1, 41.312
0B0AD5 77 1D 00    1384*  	dl 0x001D77 ; 0000E2, 41.438
0B0AD8 8E 1D 00    1385*  	dl 0x001D8E ; 0000E3, 41.564
0B0ADB A5 1D 00    1386*  	dl 0x001DA5 ; 0000E4, 41.689
0B0ADE BB 1D 00    1387*  	dl 0x001DBB ; 0000E5, 41.814
0B0AE1 D2 1D 00    1388*  	dl 0x001DD2 ; 0000E6, 41.938
0B0AE4 E9 1D 00    1389*  	dl 0x001DE9 ; 0000E7, 42.061
0B0AE7 FF 1D 00    1390*  	dl 0x001DFF ; 0000E8, 42.184
0B0AEA 15 1E 00    1391*  	dl 0x001E15 ; 0000E9, 42.307
0B0AED 2C 1E 00    1392*  	dl 0x001E2C ; 0000EA, 42.429
0B0AF0 42 1E 00    1393*  	dl 0x001E42 ; 0000EB, 42.551
0B0AF3 58 1E 00    1394*  	dl 0x001E58 ; 0000EC, 42.672
0B0AF6 6E 1E 00    1395*  	dl 0x001E6E ; 0000ED, 42.793
0B0AF9 84 1E 00    1396*  	dl 0x001E84 ; 0000EE, 42.913
0B0AFC 99 1E 00    1397*  	dl 0x001E99 ; 0000EF, 43.033
0B0AFF AF 1E 00    1398*  	dl 0x001EAF ; 0000F0, 43.152
0B0B02 C5 1E 00    1399*  	dl 0x001EC5 ; 0000F1, 43.271
0B0B05 DA 1E 00    1400*  	dl 0x001EDA ; 0000F2, 43.390
0B0B08 F0 1E 00    1401*  	dl 0x001EF0 ; 0000F3, 43.508
0B0B0B 05 1F 00    1402*  	dl 0x001F05 ; 0000F4, 43.625
0B0B0E 1B 1F 00    1403*  	dl 0x001F1B ; 0000F5, 43.742
0B0B11 30 1F 00    1404*  	dl 0x001F30 ; 0000F6, 43.859
0B0B14 45 1F 00    1405*  	dl 0x001F45 ; 0000F7, 43.975
0B0B17 5A 1F 00    1406*  	dl 0x001F5A ; 0000F8, 44.091
0B0B1A 6F 1F 00    1407*  	dl 0x001F6F ; 0000F9, 44.206
0B0B1D 84 1F 00    1408*  	dl 0x001F84 ; 0000FA, 44.321
0B0B20 99 1F 00    1409*  	dl 0x001F99 ; 0000FB, 44.435
0B0B23 AD 1F 00    1410*  	dl 0x001FAD ; 0000FC, 44.549
0B0B26 C2 1F 00    1411*  	dl 0x001FC2 ; 0000FD, 44.662
0B0B29 D7 1F 00    1412*  	dl 0x001FD7 ; 0000FE, 44.775
0B0B2C EB 1F 00    1413*  	dl 0x001FEB ; 0000FF, 44.888
0B0B2F 00 20 00    1414*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B0B32             1415*  
0B0B32             1416*  	; include "functions.inc"
0B0B32             1417*  
0B0B32             1418*      MACRO printChar char
0B0B32             1419*          LD A, char
0B0B32             1420*          RST.LIL 10h
0B0B32             1421*      ENDMACRO
0B0B32             1422*  
0B0B32             1423*  ; put the value in HLU into the accumulator
0B0B32             1424*  ; destroys: af
0B0B32             1425*      MACRO HLU_TO_A
0B0B32             1426*          push hl ; 4 cycles
0B0B32             1427*          inc sp ; 1 cycle
0B0B32             1428*          pop af  ; 4 cycles
0B0B32             1429*          dec sp ; 1 cycle
0B0B32             1430*                 ; 10 cycles total
0B0B32             1431*      ENDMACRO
0B0B32             1432*  
0B0B32             1433*  ; put the value in the accumulator into HLU
0B0B32             1434*  ; destroys a
0B0B32             1435*  A_TO_HLU:
0B0B32             1436*      ; call is 7 cycles
0B0B32 22 3F 0B 0B 1437*      ld (@scratch),hl ; 7 cycles
0B0B36 32 41 0B 0B 1438*      ld (@scratch+2),a ; 5 cycles
0B0B3A 2A 3F 0B 0B 1439*      ld hl,(@scratch) ; 7 cycles
0B0B3E C9          1440*      ret ; 6 cycles
0B0B3F             1441*          ; 25 cycles total
0B0B3F 00 00 00    1442*  @scratch: dl 0
0B0B42             1443*  
0B0B42             1444*  
0B0B42             1445*  ; Print a zero-terminated string inline with code, e.g.:
0B0B42             1446*  ;
0B0B42             1447*  ;    call printInline
0B0B42             1448*  ;    ASCIZ "Hello, world!\r\n"
0B0B42             1449*  ;
0B0B42             1450*  ; Destroys: HL,AF
0B0B42             1451*  printInline:
0B0B42 E1          1452*      pop hl ; get the return address = pointer to start of string
0B0B43 CD 49 0B 0B 1453*      call printString ; HL advances to end of string
0B0B47 E5          1454*      push hl ; restore the return address = pointer to end of string
0B0B48 C9          1455*      ret
0B0B49             1456*  
0B0B49             1457*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0B49             1458*  ; Print a zero-terminated string
0B0B49             1459*  ; HL: Pointer to string
0B0B49             1460*  printString:
0B0B49 C5          1461*  	PUSH	BC
0B0B4A 01 00 00 00 1462*  	LD		BC,0
0B0B4E 3E 00       1463*  	LD 	 	A,0
0B0B50 5B DF       1464*  	RST.LIL 18h
0B0B52 C1          1465*  	POP		BC
0B0B53 C9          1466*  	RET
0B0B54             1467*  ; print a VDU sequence
0B0B54             1468*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0B54             1469*  sendVDUsequence:
0B0B54 C5          1470*  	PUSH	BC
0B0B55 01 00 00 00 1471*  	LD		BC, 0
0B0B59 4E          1472*  	LD		C, (HL)
0B0B5A 5B DF       1473*  	RST.LIL	18h
0B0B5C C1          1474*  	POP		BC
0B0B5D C9          1475*  	RET
0B0B5E             1476*  ; Print Newline sequence to VDP
0B0B5E             1477*  printNewLine:
0B0B5E F5          1478*      push af ; for some reason rst.lil 10h sets carry flag
0B0B5F 3E 0D       1479*  	LD	A, '\r'
0B0B61 5B D7       1480*  	RST.LIL 10h
0B0B63 3E 0A       1481*  	LD	A, '\n'
0B0B65 5B D7       1482*  	RST.LIL 10h
0B0B67 F1          1483*      pop af
0B0B68 C9          1484*  	RET
0B0B69             1485*  
0B0B69             1486*  ; Print a 24-bit HEX number
0B0B69             1487*  ; HLU: Number to print
0B0B69             1488*  printHex24:
0B0B69             1489*      HLU_TO_A
0B0B69 E5          0001*M         push hl ; 4 cycles
0B0B6A 33          0002*M         inc sp ; 1 cycle
0B0B6B F1          0003*M         pop af  ; 4 cycles
0B0B6C 3B          0004*M         dec sp ; 1 cycle
0B0B6D             0005*M                ; 10 cycles total
0B0B6D CD 77 0B 0B 1490*  	CALL	printHex8
0B0B71             1491*  ; Print a 16-bit HEX number
0B0B71             1492*  ; HL: Number to print
0B0B71             1493*  printHex16:
0B0B71 7C          1494*  	LD		A,H
0B0B72 CD 77 0B 0B 1495*  	CALL	printHex8
0B0B76 7D          1496*  	LD		A,L
0B0B77             1497*  ; Print an 8-bit HEX number
0B0B77             1498*  ; A: Number to print
0B0B77             1499*  printHex8:
0B0B77 4F          1500*  	LD		C,A
0B0B78 1F          1501*  	RRA
0B0B79 1F          1502*  	RRA
0B0B7A 1F          1503*  	RRA
0B0B7B 1F          1504*  	RRA
0B0B7C CD 81 0B 0B 1505*  	CALL	@F
0B0B80 79          1506*  	LD		A,C
0B0B81             1507*  @@:
0B0B81 E6 0F       1508*  	AND		0Fh
0B0B83 C6 90       1509*  	ADD		A,90h
0B0B85 27          1510*  	DAA
0B0B86 CE 40       1511*  	ADC		A,40h
0B0B88 27          1512*  	DAA
0B0B89 5B D7       1513*  	RST.LIL	10h
0B0B8B C9          1514*  	RET
0B0B8C             1515*  
0B0B8C             1516*  printHexUHL:
0B0B8C E5          1517*  	push hl
0B0B8D CD 69 0B 0B 1518*  	call printHex24
0B0B91 E1          1519*  	pop hl
0B0B92 C9          1520*  	ret
0B0B93             1521*  
0B0B93             1522*  ; Prints the right justified decimal value in HL without leading zeroes
0B0B93             1523*  ; HL : Value to print
0B0B93             1524*  ; preserves all registers and flags
0B0B93             1525*  printDec:
0B0B93             1526*  ; BEGIN MY CODE
0B0B93             1527*  ; back up all the things
0B0B93 F5          1528*      push af
0B0B94 C5          1529*      push bc
0B0B95 D5          1530*      push de
0B0B96 E5          1531*      push hl
0B0B97             1532*  ; END MY CODE
0B0B97 11 BF 0B 0B 1533*  	LD	 DE, _printDecBuffer
0B0B9B CD CF 0B 0B 1534*  	CALL u24_to_ascii
0B0B9F             1535*  ; BEGIN MY CODE
0B0B9F             1536*  ; replace leading zeroes with spaces
0B0B9F 21 BF 0B 0B 1537*      LD	 HL, _printDecBuffer
0B0BA3 06 07       1538*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0BA5             1539*  @loop:
0B0BA5 7E          1540*      LD	 A, (HL)
0B0BA6 FE 30       1541*      CP	 '0'
0B0BA8 C2 B2 0B 0B 1542*      JP	 NZ, @done
0B0BAC 3E 20       1543*      LD   A, ' '
0B0BAE 77          1544*      LD	 (HL), A
0B0BAF 23          1545*      INC	 HL
0B0BB0             1546*      ; CALL vdu_cursor_forward
0B0BB0 10 F3       1547*      DJNZ @loop
0B0BB2             1548*  @done:
0B0BB2             1549*  ; END MY CODE
0B0BB2 21 BF 0B 0B 1550*  	LD	 HL, _printDecBuffer
0B0BB6 CD 49 0B 0B 1551*  	CALL printString
0B0BBA             1552*  ; BEGIN MY CODE
0B0BBA             1553*  ; restore all the things
0B0BBA E1          1554*      pop hl
0B0BBB D1          1555*      pop de
0B0BBC C1          1556*      pop bc
0B0BBD F1          1557*      pop af
0B0BBE             1558*  ; END MY CODE
0B0BBE C9          1559*  	RET
0B0BBF 00 00 00 00 1560*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0BCF             1561*  
0B0BCF             1562*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0BCF             1563*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0BCF             1564*  ; so it will allways be 8 characters length
0B0BCF             1565*  ; HL : Value to convert to string
0B0BCF             1566*  ; DE : pointer to buffer, at least 8 byte + 0
0B0BCF             1567*  u24_to_ascii:
0B0BCF 01 80 69 67 1568*  	LD	 BC,-10000000
0B0BD3 CD 06 0C 0B 1569*  	CALL @one_digit
0B0BD7 01 C0 BD F0 1570*  	LD	 BC,-1000000
0B0BDB CD 06 0C 0B 1571*  	CALL @one_digit
0B0BDF 01 60 79 FE 1572*  	LD	 BC,-100000
0B0BE3 CD 06 0C 0B 1573*  	CALL @one_digit
0B0BE7 01 F0 D8 FF 1574*  	LD   BC,-10000
0B0BEB CD 06 0C 0B 1575*  	CALL @one_digit
0B0BEF 01 18 FC FF 1576*  	LD   BC,-1000
0B0BF3 CD 06 0C 0B 1577*  	CALL @one_digit
0B0BF7 01 9C FF FF 1578*  	LD   BC,-100
0B0BFB CD 06 0C 0B 1579*  	CALL @one_digit
0B0BFF 0E F6       1580*  	LD   C,-10
0B0C01 CD 06 0C 0B 1581*  	CALL @one_digit
0B0C05 48          1582*  	LD   C,B
0B0C06             1583*  @one_digit:
0B0C06 3E 2F       1584*  	LD   A,'0'-1
0B0C08             1585*  @divide_me:
0B0C08 3C          1586*  	INC  A
0B0C09 09          1587*  	ADD  HL,BC
0B0C0A 38 FC       1588*  	JR   C,@divide_me
0B0C0C ED 42       1589*  	SBC  HL,BC
0B0C0E 12          1590*  	LD   (DE),A
0B0C0F 13          1591*  	INC  DE
0B0C10 C9          1592*  	RET
0B0C11             1593*  
0B0C11             1594*  print_u24:
0B0C11 D5          1595*      push de
0B0C12 E5          1596*      push hl
0B0C13 11 BF 0B 0B 1597*      ld de,_printDecBuffer
0B0C17 CD CF 0B 0B 1598*      call u24_to_ascii
0B0C1B 21 BF 0B 0B 1599*      ld hl,_printDecBuffer
0B0C1F CD 49 0B 0B 1600*      call printString
0B0C23 3E 20       1601*      ld a,' '
0B0C25 5B D7       1602*      rst.lil 10h
0B0C27 E1          1603*      pop hl
0B0C28 D1          1604*      pop de
0B0C29 C9          1605*      ret
0B0C2A             1606*  
0B0C2A             1607*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B0C2A             1608*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B0C2A             1609*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B0C2A             1610*  u168_to_ascii:
0B0C2A             1611*  ; add a leading space to make room for sign flag if needed
0B0C2A 3E 20       1612*      ld a,' '
0B0C2C 12          1613*      ld (de),a
0B0C2D 13          1614*      inc de
0B0C2E             1615*  ; Convert integer part
0B0C2E E5          1616*      push hl               ; Save HL (we’ll need the fractional part later)
0B0C2F CD 04 01 0B 1617*      call hlu_udiv256    ; Shift to get integer portion in HL
0B0C33 01 F0 D8 FF 1618*      ld   bc, -10000
0B0C37 CD 5A 0C 0B 1619*      call @one_int
0B0C3B 01 18 FC FF 1620*      ld   bc, -1000
0B0C3F CD 5A 0C 0B 1621*      call @one_int
0B0C43 01 9C FF FF 1622*      ld   bc, -100
0B0C47 CD 5A 0C 0B 1623*      call @one_int
0B0C4B 0E F6       1624*      ld   c, -10
0B0C4D CD 5A 0C 0B 1625*      call @one_int
0B0C51 48          1626*      ld   c, b
0B0C52 CD 5A 0C 0B 1627*      call @one_int
0B0C56 C3 65 0C 0B 1628*      jp   @frac            ; Jump to fractional part conversion
0B0C5A             1629*  @one_int:
0B0C5A 3E 2F       1630*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B0C5C             1631*  @divide_me:
0B0C5C 3C          1632*      inc  a
0B0C5D 09          1633*      add  hl, bc           ; Accumulate until overflow
0B0C5E 38 FC       1634*      jr   c, @divide_me
0B0C60 ED 42       1635*      sbc  hl, bc           ; Remove excess after overflow
0B0C62 12          1636*      ld   (de), a          ; Store ASCII digit
0B0C63 13          1637*      inc  de
0B0C64 C9          1638*      ret
0B0C65             1639*  ; Convert fractional part
0B0C65             1640*  @frac:
0B0C65 3E 2E       1641*      ld   a, '.'           ; Decimal point
0B0C67 12          1642*      ld   (de), a
0B0C68 13          1643*      inc  de
0B0C69 E1          1644*      pop  hl               ; Restore HL with original fraction
0B0C6A 06 03       1645*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0C6C             1646*  @frac_loop:
0B0C6C 26 0A       1647*      ld   h, 10            ; Load multiplier for fractional part
0B0C6E ED 6C       1648*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0C70 3E 30       1649*      ld   a, '0'
0B0C72 84          1650*      add  a, h             ; Convert integer part to ASCII
0B0C73 12          1651*      ld   (de), a
0B0C74 13          1652*      inc  de
0B0C75 10 F5       1653*      djnz @frac_loop       ; Repeat for each fractional digit
0B0C77             1654*  ; Add null terminator
0B0C77 AF          1655*      xor  a                ; Null terminator
0B0C78 12          1656*      ld   (de), a
0B0C79 C9          1657*      ret
0B0C7A             1658*  
0B0C7A             1659*  print_u168:
0B0C7A D5          1660*      push de
0B0C7B E5          1661*      push hl
0B0C7C 11 BF 0B 0B 1662*      ld de,_printDecBuffer
0B0C80 CD 2A 0C 0B 1663*      call u168_to_ascii
0B0C84 21 BF 0B 0B 1664*      ld hl,_printDecBuffer
0B0C88 CD 49 0B 0B 1665*      call printString
0B0C8C E1          1666*      pop hl
0B0C8D D1          1667*      pop de
0B0C8E C9          1668*      ret
0B0C8F             1669*  
0B0C8F             1670*  ; signed version of u168_to_ascii
0B0C8F             1671*  s168_to_ascii:
0B0C8F D5          1672*      push de ; save starting address of buffer
0B0C90 CD 12 01 0B 1673*      call hlu_abs
0B0C94 F5          1674*      push af ; save sign flag
0B0C95 CD 2A 0C 0B 1675*      call u168_to_ascii
0B0C99 F1          1676*      pop af ; restore sign flag
0B0C9A D1          1677*      pop de ; restore starting address of buffer
0B0C9B F0          1678*      ret p ; hlu was positive so nothing to do
0B0C9C 3E 2D       1679*      ld a,'-'
0B0C9E 12          1680*      ld (de),a
0B0C9F C9          1681*      ret
0B0CA0             1682*  
0B0CA0             1683*  print_s168:
0B0CA0 D5          1684*      push de
0B0CA1 E5          1685*      push hl
0B0CA2 11 BF 0B 0B 1686*      ld de,_printDecBuffer
0B0CA6 CD 8F 0C 0B 1687*      call s168_to_ascii
0B0CAA 21 BF 0B 0B 1688*      ld hl,_printDecBuffer
0B0CAE CD 49 0B 0B 1689*      call printString
0B0CB2 E1          1690*      pop hl
0B0CB3 D1          1691*      pop de
0B0CB4 C9          1692*      ret
0B0CB5             1693*  
0B0CB5             1694*  	; include "parse.inc"
0B0CB5             1695*  
0B0CB5             1696*  ;
0B0CB5             1697*  ; Title:	Number Parsing Functions
0B0CB5             1698*  ; Author:	Dean Belfield
0B0CB5             1699*  ; Created:	15/11/2022
0B0CB5             1700*  ; Last Updated:	15/11/2022
0B0CB5             1701*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B0CB5             1702*  ; Modinfo:
0B0CB5             1703*  ; 2024/04/08    Adapt for ez80asm
0B0CB5             1704*  
0B0CB5             1705*  ; Read a number and convert to binary
0B0CB5             1706*  ; If prefixed with &, will read as hex, otherwise decimal
0B0CB5             1707*  ;   Inputs: HL: Pointer in string buffer
0B0CB5             1708*  ;  Outputs: HL: Updated text pointer
0B0CB5             1709*  ;           DE: Value
0B0CB5             1710*  ;            A: Terminator (spaces skipped)
0B0CB5             1711*  ;            F: Carry set if valid number, otherwise reset
0B0CB5             1712*  ; Destroys: A,D,E,H,L,F
0B0CB5             1713*  ;
0B0CB5 11 00 00 00 1714*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B0CB9             1715*  			; CALL		_skip_spaces		; Skip whitespace
0B0CB9 7E          1716*  			LD		A, (HL)			; Read first character
0B0CBA B7          1717*  			OR		A			; Check for end of string
0B0CBB C8          1718*  			RET		Z			; Return with no carry if not
0B0CBC C5          1719*  			PUSH		BC			; Preserve BC
0B0CBD FE 26       1720*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B0CBF 20 23       1721*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B0CC1 23          1722*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B0CC2             1723*  ;
0B0CC2 7E          1724*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B0CC3 CD 05 0D 0B 1725*  			CALL   	 	UPPRC			; Convert to uppercase
0B0CC7 D6 30       1726*  			SUB		'0'			; Normalise to 0
0B0CC9 38 37       1727*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0CCB FE 0A       1728*  			CP 		10			; Check if >= 10
0B0CCD 38 06       1729*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0CCF D6 07       1730*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0CD1 FE 10       1731*  			CP 		16			; Check for > F
0B0CD3 30 2D       1732*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B0CD5             1733*  ;
0B0CD5 E5          1734*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B0CD6 D5          1735*  			PUSH		DE			; LD HL, DE
0B0CD7 E1          1736*  			POP		HL
0B0CD8 29          1737*  			ADD		HL, HL
0B0CD9 29          1738*  			ADD		HL, HL
0B0CDA 29          1739*  			ADD		HL, HL
0B0CDB 29          1740*  			ADD		HL, HL
0B0CDC E5          1741*  			PUSH		HL			; LD DE, HL
0B0CDD D1          1742*  			POP		DE
0B0CDE E1          1743*  			POP		HL			; Restore HL
0B0CDF B3          1744*  			OR      	E			; OR the new digit in to the least significant nibble
0B0CE0 5F          1745*  			LD      	E, A
0B0CE1             1746*  ;
0B0CE1 23          1747*  			INC		HL			; Onto the next character
0B0CE2 18 DE       1748*  			JR      	ASC_TO_NUMBER1		; And loop
0B0CE4             1749*  ;
0B0CE4 7E          1750*  ASC_TO_NUMBER3:		LD		A, (HL)
0B0CE5 D6 30       1751*  			SUB		'0'			; Normalise to 0
0B0CE7 38 19       1752*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0CE9 FE 0A       1753*  			CP		10			; Check if >= 10
0B0CEB 30 15       1754*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0CED             1755*  ;
0B0CED E5          1756*  			PUSH		HL			; Stack HL
0B0CEE D5          1757*  			PUSH		DE			; LD HL, DE
0B0CEF E1          1758*  			POP		HL
0B0CF0 E5          1759*  			PUSH		HL			; LD BC, HL
0B0CF1 C1          1760*  			POP		BC
0B0CF2 29          1761*  			ADD		HL, HL 			; x 2
0B0CF3 29          1762*  			ADD		HL, HL 			; x 4
0B0CF4 09          1763*  			ADD		HL, BC 			; x 5
0B0CF5 29          1764*  			ADD		HL, HL 			; x 10
0B0CF6 01 00 00 00 1765*  			LD		BC, 0
0B0CFA 4F          1766*  			LD 		C, A			; LD BCU, A
0B0CFB 09          1767*  			ADD		HL, BC			; Add BCU to HL
0B0CFC E5          1768*  			PUSH		HL			; LD DE, HL
0B0CFD D1          1769*  			POP		DE
0B0CFE E1          1770*  			POP		HL			; Restore HL
0B0CFF             1771*  ;
0B0CFF 23          1772*  			INC		HL
0B0D00 18 E2       1773*  			JR		ASC_TO_NUMBER3
0B0D02 C1          1774*  ASC_TO_NUMBER4:		POP		BC
0B0D03 37          1775*  			SCF					; We have a valid number so set carry
0B0D04 C9          1776*  			RET
0B0D05             1777*  
0B0D05             1778*  
0B0D05             1779*  ; Convert a character to upper case
0B0D05             1780*  ;  A: Character to convert
0B0D05             1781*  ;
0B0D05 E6 7F       1782*  UPPRC:  		AND     	7FH
0B0D07 FE 60       1783*  			CP      	'`'
0B0D09 D8          1784*  			RET     	C
0B0D0A E6 5F       1785*  			AND     	5FH			; Convert to upper case
0B0D0C C9          1786*  			RET
0B0D0D             1787*  
0B0D0D             1788*  ; -----------------------------------------------------------------------
0B0D0D             1789*  ;
0B0D0D             1790*  ; additional functions by Brandon R. Gates based on Dean's code
0B0D0D             1791*  ;
0B0D0D             1792*  ;------------------------------------------------------------------------
0B0D0D             1793*  ; Read a number and convert to binary (decimal only)
0B0D0D             1794*  ; Inputs: hl: Pointer in string buffer
0B0D0D             1795*  ; Outputs: hl: Updated text pointer
0B0D0D             1796*  ;         de: Value
0B0D0D             1797*  ;         a: Terminator (spaces skipped)
0B0D0D             1798*  ;         f: Carry set if valid number, otherwise reset
0B0D0D             1799*  ; Destroys: a, d, e, h, l, f
0B0D0D             1800*  ;------------------------------------------------------------------------
0B0D0D             1801*  asc_to_s24:
0B0D0D 3E 01       1802*      ld a,1 ; set sign flag
0B0D0F 32 5B 0D 0B 1803*      ld (@sign),a ; store sign flag
0B0D13             1804*  
0B0D13 11 00 00 00 1805*      ld de, 0 ; initialise de
0B0D17             1806*      ; call _skip_spaces ; skip whitespace
0B0D17             1807*  
0B0D17 7E          1808*      ld a, (hl) ; read first character
0B0D18 B7          1809*      or a ; check for end of string
0B0D19 C8          1810*      ret z ; return with no carry if not
0B0D1A             1811*  
0B0D1A C5          1812*      push bc ; preserve bc
0B0D1B             1813*  
0B0D1B FE 2D       1814*      cp '-' ; check for negative number
0B0D1D C2 27 0D 0B 1815*      jp nz,@loop ; number is positive, nothing more to do
0B0D21 AF          1816*      xor a ; sign flag to zero
0B0D22 32 5B 0D 0B 1817*      ld (@sign),a ; store sign flag
0B0D26 23          1818*      inc hl ; skip '-'
0B0D27             1819*  
0B0D27             1820*  @loop:
0B0D27 7E          1821*      ld a, (hl)
0B0D28 D6 30       1822*      sub '0' ; normalise to 0
0B0D2A 38 19       1823*      jr c, @integer_end ; return if < ascii '0'
0B0D2C FE 0A       1824*      cp 10 ; check if >= 10
0B0D2E 30 15       1825*      jr nc, @integer_end ; return if >= 10
0B0D30 E5          1826*      push hl ; stack hl
0B0D31 D5          1827*      push de ; ld hl, de
0B0D32 E1          1828*      pop hl
0B0D33 E5          1829*      push hl ; ld bc, hl
0B0D34 C1          1830*      pop bc
0B0D35 29          1831*      add hl, hl ; x 2
0B0D36 29          1832*      add hl, hl ; x 4
0B0D37 09          1833*      add hl, bc ; x 5
0B0D38 29          1834*      add hl, hl ; x 10
0B0D39 01 00 00 00 1835*      ld bc, 0
0B0D3D 4F          1836*      ld c, a ; ld bcu, a
0B0D3E 09          1837*      add hl, bc ; add bcu to hl
0B0D3F E5          1838*      push hl ; ld de, hl
0B0D40 D1          1839*      pop de
0B0D41 E1          1840*      pop hl ; restore hl
0B0D42 23          1841*      inc hl
0B0D43 18 E2       1842*      jr @loop
0B0D45             1843*  
0B0D45             1844*  @integer_end:
0B0D45 C1          1845*      pop bc ; send bc back how she came in
0B0D46 3A 5B 0D 0B 1846*      ld a, (@sign) ; get sign flag
0B0D4A 3D          1847*      dec a ; check if negative
0B0D4B F2 59 0D 0B 1848*      jp p,@pos ; positive number
0B0D4F             1849*  
0B0D4F             1850*  ; Negate de
0B0D4F E5          1851*      push hl ; save text pointer
0B0D50 21 00 00 00 1852*      ld hl, 0
0B0D54 AF          1853*      xor a ; clear carry
0B0D55 ED 52       1854*      sbc hl, de ; subtract DE from HL
0B0D57 EB          1855*      ex de, hl ; DE = 0-HL
0B0D58 E1          1856*      pop hl ; restore text pointer
0B0D59             1857*  
0B0D59             1858*  @pos:
0B0D59 37          1859*      scf ; we have a valid number so set carry
0B0D5A C9          1860*      ret
0B0D5B             1861*  
0B0D5B 00          1862*  @sign: db 0 ; sign flag buffer
0B0D5C             1863*  
0B0D5C             1864*  
0B0D5C             1865*  ;------------------------------------------------------------------------
0B0D5C             1866*  ; Read a number and convert to binary (decimal only)
0B0D5C             1867*  ; Inputs: hl: Pointer in string buffer
0B0D5C             1868*  ; Outputs: hl: Updated text pointer
0B0D5C             1869*  ;         de: Value
0B0D5C             1870*  ;         a: Terminator (spaces skipped)
0B0D5C             1871*  ;         f: Carry set if valid number, otherwise reset
0B0D5C             1872*  ; Destroys: a, d, e, h, l, f
0B0D5C             1873*  ;------------------------------------------------------------------------
0B0D5C             1874*  asc_to_s168:
0B0D5C 3E 01       1875*      ld a,1 ; set sign flag
0B0D5E 32 1B 0E 0B 1876*      ld (@sign),a ; store sign flag
0B0D62             1877*  
0B0D62 11 00 00 00 1878*      ld de, 0 ; initialise de
0B0D66 ED 53 13 0E 1879*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B0D6B ED 53 17 0E 1880*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B0D70             1881*  
0B0D70             1882*      ; call _skip_spaces ; skip whitespace
0B0D70             1883*  
0B0D70 7E          1884*      ld a, (hl) ; read first character
0B0D71 B7          1885*      or a ; check for end of string
0B0D72 C8          1886*      ret z ; return with no carry if not
0B0D73             1887*  
0B0D73 C5          1888*      push bc ; preserve bc
0B0D74             1889*  
0B0D74 FE 2D       1890*      cp '-' ; check for negative number
0B0D76 C2 80 0D 0B 1891*      jp nz,@loop ; number is positive, nothing more to do
0B0D7A AF          1892*      xor a ; sign flag to zero
0B0D7B 32 1B 0E 0B 1893*      ld (@sign),a ; store sign flag
0B0D7F 23          1894*      inc hl ; skip '-'
0B0D80             1895*  
0B0D80             1896*  @loop:
0B0D80 7E          1897*      ld a, (hl)
0B0D81             1898*  
0B0D81             1899*  ; chcek for decimal point
0B0D81 FE 2E       1900*      cp '.' ; check for decimal point
0B0D83 CA C4 0D 0B 1901*      jp z,@fractional_start ; jump to fractional part
0B0D87             1902*  
0B0D87             1903*  ; process integer part
0B0D87 D6 30       1904*      sub '0' ; normalise to 0
0B0D89 38 19       1905*      jr c, @integer_end ; return if < ascii '0'
0B0D8B FE 0A       1906*      cp 10 ; check if >= 10
0B0D8D 30 15       1907*      jr nc, @integer_end ; return if >= 10
0B0D8F E5          1908*      push hl ; stack hl
0B0D90 D5          1909*      push de ; ld hl, de
0B0D91 E1          1910*      pop hl
0B0D92 E5          1911*      push hl ; ld bc, hl
0B0D93 C1          1912*      pop bc
0B0D94 29          1913*      add hl, hl ; x 2
0B0D95 29          1914*      add hl, hl ; x 4
0B0D96 09          1915*      add hl, bc ; x 5
0B0D97 29          1916*      add hl, hl ; x 10
0B0D98 01 00 00 00 1917*      ld bc, 0
0B0D9C 4F          1918*      ld c, a ; ld bcu, a
0B0D9D 09          1919*      add hl, bc ; add bcu to hl
0B0D9E E5          1920*      push hl ; ld de, hl
0B0D9F D1          1921*      pop de
0B0DA0 E1          1922*      pop hl ; restore hl
0B0DA1 23          1923*      inc hl
0B0DA2 18 DC       1924*      jr @loop
0B0DA4             1925*  
0B0DA4             1926*  @integer_end:
0B0DA4 ED 53 14 0E 1927*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0DA9             1928*  
0B0DA9             1929*  @end:
0B0DA9 C1          1930*      pop bc ; send bc back how she came in
0B0DAA ED 5B 13 0E 1931*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B0DAF 3A 1B 0E 0B 1932*      ld a, (@sign) ; get sign flag
0B0DB3 3D          1933*      dec a ; check if negative
0B0DB4 F2 C2 0D 0B 1934*      jp p,@pos ; positive number
0B0DB8             1935*  
0B0DB8             1936*  ; Negate de
0B0DB8 E5          1937*      push hl ; save text pointer
0B0DB9 21 00 00 00 1938*      ld hl, 0
0B0DBD AF          1939*      xor a ; clear carry
0B0DBE ED 52       1940*      sbc hl, de ; subtract DE from HL
0B0DC0 EB          1941*      ex de, hl ; DE = 0-HL
0B0DC1 E1          1942*      pop hl ; restore text pointer
0B0DC2             1943*  
0B0DC2             1944*  @pos:
0B0DC2 37          1945*      scf ; we have a valid number so set carry
0B0DC3 C9          1946*      ret
0B0DC4             1947*  
0B0DC4             1948*  @fractional_start:
0B0DC4 DD E5       1949*      push ix                    ; preserve ix
0B0DC6 ED 53 14 0E 1950*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0DCB 06 03       1951*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0DCD 11 00 00 00 1952*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0DD1 DD 21 1C 0E 1953*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0DD6 23          1954*      inc hl                     ; Skip decimal point
0B0DD7             1955*  
0B0DD7             1956*  @fractional_loop:
0B0DD7 7E          1957*      ld a, (hl)                 ; Load next character
0B0DD8 D6 30       1958*      sub '0'                    ; Normalize ASCII to decimal
0B0DDA 38 1C       1959*      jr c, @end_fraction        ; Exit if < '0'
0B0DDC FE 0A       1960*      cp 10
0B0DDE 30 18       1961*      jr nc, @end_fraction       ; Exit if >= 10
0B0DE0             1962*  
0B0DE0             1963*      ; Multiply the current fractional accumulator by 10
0B0DE0 E5          1964*      push hl                    ; Save char pointer
0B0DE1 F5          1965*      push af                    ; Save the digit
0B0DE2 EB          1966*      ex de, hl
0B0DE3 E5          1967*      push hl
0B0DE4 29          1968*      add hl,hl ; * 2
0B0DE5 29          1969*      add hl,hl ; * 4
0B0DE6 D1          1970*      pop de
0B0DE7 19          1971*      add hl,de ; * 5
0B0DE8 29          1972*      add hl,hl ; * 10
0B0DE9 11 00 00 00 1973*      ld de, 0                   ; Clear DEU
0B0DED F1          1974*      pop af                     ; Restore the current digit
0B0DEE 5F          1975*      ld e, a                    ; Load the digit into E
0B0DEF 19          1976*      add hl, de                 ; Add the digit to the accumulator
0B0DF0 EB          1977*      ex de, hl                  ; Result back to DE
0B0DF1 ED 32 03    1978*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0DF4 E1          1979*      pop hl                     ; Restore char pointer
0B0DF5 23          1980*      inc hl                     ; Move to the next character
0B0DF6 10 DF       1981*      djnz @fractional_loop      ; Loop if more digits to process
0B0DF8             1982*  
0B0DF8             1983*  @end_fraction:
0B0DF8             1984*  ; Final scaling based on number of fractional digits processed
0B0DF8 ED 53 18 0E 1985*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0DFD 2A 17 0E 0B 1986*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0E01             1987*  
0B0E01 DD 17 00    1988*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0E04 CD 82 02 0B 1989*      call udiv24                ; Perform 24-bit division to scale down
0B0E08 7B          1990*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0E09 32 13 0E 0B 1991*      ld (@result), a            ; Store fractional part in result buffer
0B0E0D DD E1       1992*      pop ix                     ; Restore ix
0B0E0F C3 A9 0D 0B 1993*      jp @end                    ; Final sign check and flag setup
0B0E13             1994*  
0B0E13             1995*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0E17             1996*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0E1B 00          1997*  @sign: db 0                    ; Sign flag buffer
0B0E1C             1998*  
0B0E1C             1999*  powers_of_10:
0B0E1C 01 00 00    2000*      dl 1                       ; 10^0
0B0E1F 0A 00 00    2001*      dl 10                      ; 10^1
0B0E22 64 00 00    2002*      dl 100                     ; 10^2
0B0E25 E8 03 00    2003*      dl 1000                    ; 10^3
0B0E28 10 27 00    2004*      dl 10000                   ; 10^4
0B0E2B             0119   
0B0E2B             0120   ; APPLICATION INCLUDES
0B0E2B             0121   debug_print:
0B0E2B CD 93 0B 0B 0122       call printDec
0B0E2F EB          0123       ex de,hl
0B0E30 CD 93 0B 0B 0124       call printDec
0B0E34 EB          0125       ex de,hl
0B0E35 CD 5E 0B 0B 0126       call printNewLine
0B0E39 C9          0127       ret
0B0E3A             0128   
0B0E3A 55 73 61 67 0129   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B0E52 45 72 72 6F 0130   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B0E5B 53 75 63 63 0131   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B0E66             0132   
0B0E66             0133   ; ========= MAIN LOOP =========
0B0E66             0134   ; The main routine
0B0E66             0135   ; IXU: argv - pointer to array of parameters
0B0E66             0136   ; C: argc - number of parameters
0B0E66             0137   ; Returns:
0B0E66             0138   ; HL: Error code, or 0 if OK
0B0E66             0139   
0B0E66             0140   ; min_args: equ 3
0B0E66             0141   
0B0E66             0142   _main_init:
0B0E66 79          0143       ld a,c ; how many arguments?
0B0E67 FE 01       0144       cp min_args ; not enough?
0B0E69 30 1A       0145       jr nc,main ; if enough, go to main loop
0B0E6B 21 3A 0E 0B 0146       ld hl,str_usage ; if not enough, print usage
0B0E6F CD 49 0B 0B 0147       call printString
0B0E73             0148       ; fall through to _main_end_error
0B0E73             0149   
0B0E73             0150   _main_end_error:
0B0E73 21 52 0E 0B 0151       ld hl,str_error ; print error message
0B0E77 CD 49 0B 0B 0152       call printString
0B0E7B 21 13 00 00 0153       ld hl,19 ; return error code 19
0B0E7F C9          0154       ret
0B0E80             0155   
0B0E80             0156   _main_end_ok:
0B0E80             0157       ; ld hl,str_success ; print success message
0B0E80             0158       ; call printString
0B0E80 21 00 00 00 0159       ld hl,0 ; return 0 for success
0B0E84 C9          0160       ret
0B0E85             0161   
0B0E85             0162   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B0E85             0163   main:
0B0E85 0D          0164       dec c ; decrement the argument count to skip the program name
0B0E86             0165   
0B0E86             0166   ; ; get first numeric argument
0B0E86             0167   ;     call get_arg_s168
0B0E86             0168   ;     ex de,hl
0B0E86             0169   ;     call sqrt168
0B0E86             0170   ;     call print_s168
0B0E86             0171   
0B0E86 21 00 00 00 0172       ld hl,0x000000 ; x0 0
0B0E8A 11 00 00 00 0173       ld de,0x000000 ; y0 0
0B0E8E DD 21 00 00 0174       ld ix,0x010000 ; x1 256
       01          
0B0E93 FD 21 00 00 0175       ld iy,0x010000 ; y1 256
       01          
0B0E98 CD 46 03 0B 0176       call distance168
0B0E9C CD A0 0C 0B 0177       call print_s168
0B0EA0             0178   
0B0EA0 CD 5E 0B 0B 0179       call printNewLine
0B0EA4 CD 5E 0B 0B 0180       call printNewLine
0B0EA8             0181   
0B0EA8 C3 80 0E 0B 0182       jp _main_end_ok ; return 0 for success
0B0EAC             0183   
0B0EAC             0184   
0B0EAC             0185   ; ========== HELPER FUNCTIONS ==========
0B0EAC             0186   ; get the next argument after ix as a signed 16.8 fixed point number
0B0EAC             0187   ; inputs: ix = pointer to the argument string
0B0EAC             0188   ; outputs: ude = signed 16.8 fixed point number
0B0EAC             0189   ; destroys: a, d, e, h, l, f
0B0EAC             0190   get_arg_s168:
0B0EAC ED 32 03    0191       lea ix,ix+3 ; point to the next argument
0B0EAF DD 27 00    0192       ld hl,(ix) ; get the argument string
0B0EB2 CD 5C 0D 0B 0193       call asc_to_s168 ; convert the string to a number
0B0EB6 C9          0194       ret ; return with the value in DE
0B0EB7             0195   
0B0EB7             0196   ; Inputs: ix = pointer to the argument string
0B0EB7             0197   ; Outputs: ude = signed 24-bit integer
0B0EB7             0198   ; Destroys: a, d, e, h, l, f
0B0EB7             0199   get_arg_s24:
0B0EB7 ED 32 03    0200       lea ix,ix+3 ; point to the next argument
0B0EBA DD 27 00    0201       ld hl,(ix) ; get the argument string
0B0EBD CD 0D 0D 0B 0202       call asc_to_s24 ; convert the string to a number
0B0EC1 C9          0203       ret ; return with the value in DE
0B0EC2             0204   
0B0EC2             0205   get_arg_text:
0B0EC2 ED 32 03    0206       lea ix,ix+3 ; point to the next argument
0B0EC5 DD 27 00    0207       ld hl,(ix) ; get the argument string
0B0EC8 C9          0208       ret
0B0EC9             0209   
0B0EC9             0210   ; match the next argument after ix to the dispatch table at iy
0B0EC9             0211   ; - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B0EC9             0212   ; - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B0EC9             0213   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B0EC9             0214   ; ON MATCH: iy=dispatch address, a=0 and zero flag set
0B0EC9             0215   ; destroys: a, hl, de, ix, iy, flags
0B0EC9             0216   match_next:
0B0EC9 ED 32 03    0217       lea ix,ix+3 ; point to the next argument
0B0ECC             0218   @loop:
0B0ECC FD 27 00    0219       ld hl,(iy) ; pointer argument dispatch record
0B0ECF             0220       sign_hlu ; check for list terminator
0B0ECF 19          0001M          add hl,de
0B0ED0 B7          0002M          or a
0B0ED1 ED 52       0003M          sbc hl,de
0B0ED3 CA EB 0E 0B 0221       jp z,@no_match ; if a=0, return error
0B0ED7 23          0222       inc hl ; skip over jp instruction
0B0ED8 23          0223       inc hl
0B0ED9 DD 17 00    0224       ld de,(ix) ; pointer to the argument string
0B0EDC CD 02 0F 0B 0225       call str_equal ; compare the argument to the dispatch table entry
0B0EE0 CA ED 0E 0B 0226       jp z,@match ; if equal, return success
0B0EE4 ED 33 03    0227       lea iy,iy+3 ; if not equal, bump iy to next dispatch table entry
0B0EE7 C3 CC 0E 0B 0228       jp @loop ; and loop
0B0EEB             0229   @no_match:
0B0EEB 3C          0230       inc a ; no match so return a=1 and zero flag reset
0B0EEC C9          0231       ret
0B0EED             0232   @match:
0B0EED FD 37 00    0233       ld iy,(iy) ; get the function pointer
0B0EF0 C9          0234       ret ; return a=0 and zero flag set
0B0EF1             0235   
0B0EF1             0236   ; same as match_next, but prints the parameter if a match is found
0B0EF1             0237   match_next_and_print:
0B0EF1 CD C9 0E 0B 0238       call match_next
0B0EF5 C0          0239       ret nz ; no match found
0B0EF6 ED 32 FD    0240       lea ix,ix-3
0B0EF9 CD C2 0E 0B 0241       call get_arg_text ; hl points to the operator string
0B0EFD CD 0D 0F 0B 0242       call print_param
0B0F01 C9          0243       ret
0B0F02             0244   
0B0F02             0245   ; compare two zero-terminated strings for equality, case-sensitive
0B0F02             0246   ; hl: pointer to first string, de: pointer to second string
0B0F02             0247   ; returns: z if equal, nz if not equal
0B0F02             0248   ; destroys: a, hl, de
0B0F02             0249   str_equal:
0B0F02 1A          0250       ld a,(de) ; get the first character
0B0F03 BE          0251       cp (hl) ; compare to the second character
0B0F04 C0          0252       ret nz ; if not equal, return
0B0F05 B7          0253       or a
0B0F06 C8          0254       ret z ; if equal and zero, return
0B0F07 23          0255       inc hl ; next character
0B0F08 13          0256       inc de
0B0F09 C3 02 0F 0B 0257       jp str_equal ; loop until end of string
0B0F0D             0258   
0B0F0D             0259   ; print the parameter string pointed to by ix
0B0F0D             0260   ; destroys: a, hl
0B0F0D             0261   print_param:
0B0F0D DD 27 00    0262       ld hl,(ix) ; get the parameter pointer
0B0F10 CD 49 0B 0B 0263       call printString ; print the parameter string
0B0F14 3E 20       0264       ld a,' ' ; print a space separator
0B0F16 5B D7       0265       rst.lil $10
0B0F18 C9          0266       ret
0B0F19             0267   
0B0F19             0268   ; print the parameters
0B0F19             0269   ; inputs: b = number of parameters, ix = pointer to the parameters
0B0F19             0270   ; destroys: a, hl, bc
0B0F19             0271   print_params:
0B0F19 41          0272       ld b,c ; loop counter = number of parameters
0B0F1A DD E5       0273       push ix ; save the pointer to the parameters
0B0F1C             0274   @loop:
0B0F1C C5          0275       push bc ; save the loop counter
0B0F1D CD 0D 0F 0B 0276       call print_param ; print the parameter
0B0F21 ED 32 03    0277       lea ix,ix+3 ; next parameter pointer
0B0F24 C1          0278       pop bc ; get back the loop counter
0B0F25 10 F5       0279       djnz @loop ; loop until done
0B0F27 DD E1       0280       pop ix ; restore the pointer to the parameters
0B0F29 C9          0281       ret
