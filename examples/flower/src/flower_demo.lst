PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0030*  ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0031*  ;
040000             0032*  ; VDP control (VDU 23, 0, n)
040000             0033*  ;
040000             0034*  vdp_gp:			EQU 	80h
040000             0035*  vdp_keycode:		EQU 	81h
040000             0036*  vdp_cursor:		EQU	82h
040000             0037*  vdp_scrchar:		EQU	83h
040000             0038*  vdp_scrpixel:		EQU	84h
040000             0039*  vdp_audio:		EQU	85h
040000             0040*  vdp_mode:		EQU	86h
040000             0041*  vdp_rtc:		EQU	87h
040000             0042*  vdp_keystate:		EQU	88h
040000             0043*  vdp_logicalcoords:	EQU	C0h
040000             0044*  vdp_terminalmode:	EQU	FFh
040000             0045*  
040000             0046*  ; MOS high level functions
040000             0047*  ;
040000             0048*  mos_getkey:		EQU	00h
040000             0049*  mos_load:		EQU	01h
040000             0050*  mos_save:		EQU	02h
040000             0051*  mos_cd:			EQU	03h
040000             0052*  mos_dir:		EQU	04h
040000             0053*  mos_del:		EQU	05h
040000             0054*  mos_ren:		EQU	06h
040000             0055*  mos_mkdir:		EQU	07h
040000             0056*  mos_sysvars:		EQU	08h
040000             0057*  mos_editline:		EQU	09h
040000             0058*  mos_fopen:		EQU	0Ah
040000             0059*  mos_fclose:		EQU	0Bh
040000             0060*  mos_fgetc:		EQU	0Ch
040000             0061*  mos_fputc:		EQU	0Dh
040000             0062*  mos_feof:		EQU	0Eh
040000             0063*  mos_getError:		EQU	0Fh
040000             0064*  mos_oscli:		EQU	10h
040000             0065*  mos_copy:		EQU	11h
040000             0066*  mos_getrtc:		EQU	12h
040000             0067*  mos_setrtc:		EQU	13h
040000             0068*  mos_setintvector:	EQU	14h
040000             0069*  mos_uopen:		EQU	15h
040000             0070*  mos_uclose:		EQU	16h
040000             0071*  mos_ugetc:		EQU	17h
040000             0072*  mos_uputc:		EQU 	18h
040000             0073*  mos_getfil:		EQU	19h
040000             0074*  mos_fread:		EQU	1Ah
040000             0075*  mos_fwrite:		EQU	1Bh
040000             0076*  mos_flseek:		EQU	1Ch
040000             0077*  mos_setkbvector:	EQU	1Dh
040000             0078*  mos_getkbmap:		EQU	1Eh
040000             0079*  mos_i2c_open:		EQU	1Fh
040000             0080*  mos_i2c_close:		EQU	20h
040000             0081*  mos_i2c_write:		EQU	21h
040000             0082*  mos_i2c_read:		EQU	22h
040000             0083*  
040000             0084*  
040000             0085*  ; FatFS file access functions
040000             0086*  ;
040000             0087*  ffs_fopen:		EQU	80h
040000             0088*  ffs_fclose:		EQU	81h
040000             0089*  ffs_fread:		EQU	82h
040000             0090*  ffs_fwrite:		EQU	83h
040000             0091*  ffs_flseek:		EQU	84h
040000             0092*  ffs_ftruncate:		EQU	85h
040000             0093*  ffs_fsync:		EQU	86h
040000             0094*  ffs_fforward:		EQU	87h
040000             0095*  ffs_fexpand:		EQU	88h
040000             0096*  ffs_fgets:		EQU	89h
040000             0097*  ffs_fputc:		EQU	8Ah
040000             0098*  ffs_fputs:		EQU	8Bh
040000             0099*  ffs_fprintf:		EQU	8Ch
040000             0100*  ffs_ftell:		EQU	8Dh
040000             0101*  ffs_feof:		EQU	8Eh
040000             0102*  ffs_fsize:		EQU	8Fh
040000             0103*  ffs_ferror:		EQU	90h
040000             0104*  
040000             0105*  ; FatFS directory access functions
040000             0106*  ;
040000             0107*  ffs_dopen:		EQU	91h
040000             0108*  ffs_dclose:		EQU	92h
040000             0109*  ffs_dread:		EQU	93h
040000             0110*  ffs_dfindfirst:		EQU	94h
040000             0111*  ffs_dfindnext:		EQU	95h
040000             0112*  
040000             0113*  ; FatFS file and directory management functions
040000             0114*  ;
040000             0115*  ffs_stat:		EQU	96h
040000             0116*  ffs_unlink:		EQU	97h
040000             0117*  ffs_rename:		EQU	98h
040000             0118*  ffs_chmod:		EQU	99h
040000             0119*  ffs_utime:		EQU	9Ah
040000             0120*  ffs_mkdir:		EQU	9Bh
040000             0121*  ffs_chdir:		EQU	9Ch
040000             0122*  ffs_chdrive:		EQU	9Dh
040000             0123*  ffs_getcwd:		EQU	9Eh
040000             0124*  
040000             0125*  ; FatFS volume management and system configuration functions
040000             0126*  ;
040000             0127*  ffs_mount:		EQU	9Fh
040000             0128*  ffs_mkfs:		EQU	A0h
040000             0129*  ffs_fdisk:		EQU	A1h
040000             0130*  ffs_getfree:		EQU	A2h
040000             0131*  ffs_getlabel:		EQU	A3h
040000             0132*  ffs_setlabel:		EQU	A4h
040000             0133*  ffs_setcp:		EQU	A5h
040000             0134*  
040000             0135*  ; File access modes
040000             0136*  ;
040000             0137*  fa_read:		EQU	01h
040000             0138*  fa_write:		EQU	02h
040000             0139*  fa_open_existing:	EQU	00h
040000             0140*  fa_create_new:		EQU	04h
040000             0141*  fa_create_always:	EQU	08h
040000             0142*  fa_open_always:		EQU	10h
040000             0143*  fa_open_append:		EQU	30h
040000             0144*  
040000             0145*  ; System variable indexes for api_sysvars
040000             0146*  ; Index into _sysvars in globals.asm
040000             0147*  ;
040000             0148*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0149*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0150*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0151*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0152*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0153*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0154*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0155*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0156*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0157*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0158*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0159*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0160*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0161*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0162*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0163*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0164*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0165*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0166*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0167*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0168*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0169*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0170*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0171*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0172*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0173*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0174*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0175*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0176*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0177*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0178*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0179*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0180*  ;
040000             0181*  ; Flags for the VPD protocol
040000             0182*  ;
040000             0183*  vdp_pflag_cursor:	EQU	00000001b
040000             0184*  vdp_pflag_scrchar:	EQU	00000010b
040000             0185*  vdp_pflag_point:	EQU	00000100b
040000             0186*  vdp_pflag_audio:	EQU	00001000b
040000             0187*  vdp_pflag_mode:		EQU	00010000b
040000             0188*  vdp_pflag_rtc:		EQU	00100000b
040000             0189*  vdp_pflag_mouse:	EQU	01000000b
040000             0190*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0191*  
040000             0192*  
040000             0193*  ; FatFS structures
040000             0194*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0195*  ;
040000             0196*  ; Object ID and allocation information (FFOBJID)
040000             0197*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0198*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0199*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0200*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0201*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0202*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0203*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0204*  ;
040000             0205*  ; File object structure (FIL)
040000             0206*  ;
040000             0207*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0208*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0209*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0210*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0211*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0212*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0213*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0214*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0215*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0220*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0221*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0222*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0223*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0224*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0225*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0226*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0227*  ;
040000             0228*  ; File information structure (FILINFO)
040000             0229*  ;
040000             0230*  FILINFO.fsize:    EQU 0    ; File size
040000             0231*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0232*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0233*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0234*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0235*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0236*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0237*  ;
040000             0238*  ; Macro for calling the API
040000             0239*  ; Parameters:
040000             0240*  ; - function: One of the function numbers listed above
040000             0241*  ;
040000             0242*  			MACRO MOSCALL	function
040000             0243*  			LD	A, function
040000             0244*  			RST.LIS	08h
040000             0245*  			ENDMACRO
040000             0004       MACRO PROGNAME
040000             0005       ASCIZ "flower_demo"
040000             0006       ENDMACRO
040000 C3 45 00 04 0007       jp start
040004             0008   _exec_name:
040004             0009       PROGNAME
040004 66 6C 6F 77 0001M      ASCIZ "flower_demo"
       65 72 5F 64 
       65 6D 6F 00 
040010 FF FF FF FF 0010       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53 00 0011       db "MOS", 00h, 01h
       01          
040045             0012   start:
040045 F5          0013       push af
040046 C5          0014       push bc
040047 D5          0015       push de
040048 DD E5       0016       push ix
04004A FD E5       0017       push iy
04004C CD 2C 1C 04 0018       call init
040050 CD B6 1C 04 0019       call main
040054             0020   exit:
040054 FD E1       0021       pop iy
040056 DD E1       0022       pop ix
040058 D1          0023       pop de
040059 C1          0024       pop bc
04005A F1          0025       pop af
04005B 21 00 00 00 0026       ld hl,0
04005F C9          0027       ret
040060             0028   
040060             0029   ; ---- list of input arguments to cycle through ----
040060 66 00 04    0030   cur_sample: dl samples ; address of the current sample
040063 66 00 04    0031   next_sample: dl samples ; address of the next sample
040066             0032   samples:
040066 33 2C 20 31 0033       asciz "3, 1.03703704, 0.5, 64, 1, 512, 90, 100"
       2E 30 33 37 
       30 33 37 30 
       34 2C 20 30 
       2E 35 2C 20 
       36 34 2C 20 
       31 2C 20 35 
       31 32 2C 20 
       39 30 2C 20 
       31 30 30 00 
04008E 32 2E 39 39 0034       asciz "2.99, 0.96618358, 0.5, 64, 1, 512, 90, 1"
       2C 20 30 2E 
       39 36 36 31 
       38 33 35 38 
       2C 20 30 2E 
       35 2C 20 36 
       34 2C 20 31 
       2C 20 35 31 
       32 2C 20 39 
       30 2C 20 31 
       00          
0400B7             0035   
0400B7             0036       ; asciz "3.03, 1.98019802, 0.0, 66, 1, 512, 90, 12"
0400B7             0037       ; asciz "3.03, 1.98019802, 1.0, 66, 1, 512, 90, 1"
0400B7             0038   
0400B7             0039       ; asciz "6.96, 2.0028733, 0.4, 50, 1, 512, 90, 50"
0400B7             0040       ; asciz "6.96, 2.01, 0.4, 50, 1, 512, 90, 1"
0400B7             0041   
0400B7             0042       ; asciz "6.99, 1.78826896, 0.5, 100, 0, 512, 90, 20"
0400B7             0043       ; asciz "6.99, 1.81211254, 0.5, 100, 0, 512, 90, 1"
0400B7             0044   
0400B7             0045       ; asciz "6.966, 2.01, 0.4, 50, 1, 512, 90, 17"
0400B7             0046       ; asciz "7.034, 2.00, 0.4, 50, 1, 512, 90, 1"
0400B7             0047       ; asciz "6.966, 1.99, 0.4, 50, 1, 512, 90, 17"
0400B7             0048       ; asciz "7.034, 2.00, 0.4, 50, 1, 512, 90, 17"
0400B7             0049   
0400B7 00 00 00    0050       dl 0; list terminator
0400BA             0051   
0400BA             0052   ; APPLICATION INCLUDES
0400BA             0053   filedata: equ 0xB7E000 ; start address of 8k onboard sram
0400BA             0054       include "basic/fpp.asm"
0400BA             0001*  ;
0400BA             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0400BA             0003*  ;		Z80 Floating Point Package
0400BA             0004*  ; Author:	(C) Copyright  R.T.Russell  1986
0400BA             0005*  ; Modified By:	Dean Belfield
0400BA             0006*  ; Created:	03/05/2022
0400BA             0007*  ; Last Updated:	07/06/2023
0400BA             0008*  ;
0400BA             0009*  ; Modinfo:
0400BA             0010*  ; 26/10/1986:	Version 0.0
0400BA             0011*  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0400BA             0012*  ; 12/05/2023:	Modified by Dean Belfield
0400BA             0013*  ; 07/06/2023:	Modified to run in ADL mode
0400BA             0014*  
0400BA             0015*  			; .ASSUME	ADL = 1
0400BA             0016*  
0400BA             0017*  			; SEGMENT CODE
0400BA             0018*  
0400BA             0019*  			; XDEF	FPP
0400BA             0020*  			; XDEF	DLOAD5
0400BA             0021*  			; XDEF	DLOAD5_SPL
0400BA             0022*  ;
0400BA             0023*  ;BINARY FLOATING POINT REPRESENTATION:
0400BA             0024*  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0400BA             0025*  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0400BA             0026*  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0400BA             0027*  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0400BA             0028*  ;
0400BA             0029*  ;BINARY INTEGER REPRESENTATION:
0400BA             0030*  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0400BA             0031*  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0400BA             0032*  ;
0400BA             0033*  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0400BA             0034*  ;                            EXPONENT - C
0400BA             0035*  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0400BA             0036*  ;                               EXPONENT - B
0400BA             0037*  
0400BA             0038*  ;
0400BA             0039*  ;Error codes:
0400BA             0040*  ;
0400BA             0041*  
0400BA             0042*  BADOP:			EQU     1               ;Bad operation code
0400BA             0043*  DIVBY0:			EQU     18              ;Division by zero
0400BA             0044*  TOOBIG_FP:			EQU     20              ;Too big
0400BA             0045*  NGROOT:			EQU     21              ;Negative root
0400BA             0046*  LOGRNG:			EQU     22              ;Log range
0400BA             0047*  ACLOST:			EQU     23              ;Accuracy lost
0400BA             0048*  EXPRNG:			EQU     24              ;Exp range
0400BA             0049*  ;
0400BA             0050*  ;Call entry and despatch code:
0400BA             0051*  ;
0400BA FD E5       0052*  FPP:			PUSH    IY              ;Save IY
0400BC FD 21 00 00 0053*          		LD      IY,0
       00          
0400C1 FD 39       0054*          		ADD     IY,SP           ;Save SP in IY
0400C3 CD D3 00 04 0055*          		CALL    OP              ;Perform operation
0400C7 BF          0056*          		CP      A               ;Good return (Z, NC)
0400C8 FD E1       0057*  EXIT_FP_:			POP     IY              ;Restore IY
0400CA C9          0058*          		RET                     ;Return to caller
0400CB             0059*  ;
0400CB             0060*  ;Error exit:
0400CB             0061*  ;
0400CB 3E 01       0062*  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
0400CD FD F9       0063*  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
0400CF B7          0064*          		OR      A               ;Set NZ
0400D0 37          0065*          		SCF                     ;Set C
0400D1 18 F5       0066*          		JR      EXIT_FP_
0400D3             0067*  ;
0400D3             0068*  ;Perform operation or function:
0400D3             0069*  ;
0400D3             0070*  ; OP:			CP      (RTABLE-DTABLE)/3
0400D3 FE 2A       0071*  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0400D5             0072*  
0400D5 30 F4       0073*          		JR      NC,BAD_FP
0400D7             0074*          		; CP      (FTABLE-DTABLE)/3
0400D7 FE 10       0075*  				CP      FTABLE-DTABLE/3 ; ditto
0400D9 30 08       0076*          		JR      NC,DISPAT_FP
0400DB 08          0077*          		EX      AF,AF'
0400DC 78          0078*          		LD      A,B
0400DD B1          0079*          		OR      C               ;Both integer?
0400DE C4 E6 0B 04 0080*          		CALL    NZ,FLOATA       ;No, so float both
0400E2 08          0081*          		EX      AF,AF'
0400E3 E5          0082*  DISPAT_FP:			PUSH    HL
0400E4 21 F6 00 04 0083*          		LD      HL,DTABLE
0400E8 C5          0084*          		PUSH    BC
0400E9 01 03 00 00 0085*  			LD	BC, 3		; C = 3
0400ED 47          0086*  			LD	B, A 		; B = op-code
0400EE ED 4C       0087*  			MLT 	BC 		;BC = op-code * 3
0400F0 09          0088*  			ADD	HL, BC 		;Add to table base
0400F1 ED 27       0089*  			LD	HL, (HL)	;Get the routine address (24-bit)
0400F3             0090*  
0400F3             0091*  ;        		ADD     A, A            ;A = op-code * 2
0400F3             0092*  ;        		LD      C,A
0400F3             0093*  ;        		LD      B,0             ;BC = op-code * 2
0400F3             0094*  ;        		ADD     HL,BC
0400F3             0095*  ;        		LD      A,(HL)          ;Get low byte
0400F3             0096*  ;        		INC     HL
0400F3             0097*  ;        		LD      H,(HL)          ;Get high byte
0400F3             0098*  ;        		LD      L,A
0400F3             0099*  
0400F3 C1          0100*          		POP     BC
0400F4 E3          0101*          		EX      (SP),HL
0400F5 C9          0102*          		RET                     ;Off to routine
0400F6             0103*  ;
0400F6             0104*  ;Despatch table:
0400F6             0105*  ;
0400F6 A8 01 04    0106*  DTABLE:			DW24  IAND            ;AND (INTEGER)
0400F9 16 02 04    0107*          		DW24  IBDIV           ;DIV
0400FC BB 01 04    0108*          		DW24  IEOR            ;EOR
0400FF E1 01 04    0109*          		DW24  IMOD            ;MOD
040102 CE 01 04    0110*          		DW24  IOR             ;OR
040105 9C 04 04    0111*          		DW24  ILE             ;<=
040108 AB 04 04    0112*          		DW24  INE             ;<>
04010B 8F 04 04    0113*          		DW24  IGE             ;>=
04010E 74 04 04    0114*          		DW24  ILT             ;<
040111 B8 04 04    0115*          		DW24  IEQ             ;=
040114 04 03 04    0116*          		DW24  IMUL            ;*
040117 3F 02 04    0117*          		DW24  IADD            ;+
04011A 81 04 04    0118*          		DW24  IGT             ;>
04011D 26 02 04    0119*          		DW24  ISUB            ;-
040120 BB 03 04    0120*          		DW24  IPOW            ;^
040123 B1 02 04    0121*          		DW24  IDIV            ;/
040126             0122*  ;
040126             0123*  FTABLE:
040126 CA 04 04    0124*  				DW24  ABSV_FP            ;ABS
040129 B0 08 04    0125*          		DW24  ACS_FP             ;ACS
04012C EE 07 04    0126*          		DW24  ASN_FP             ;ASN
04012F 1E 08 04    0127*          		DW24  ATN_FP             ;ATN
040132 E9 05 04    0128*          		DW24  COS_FP             ;COS
040135 F8 04 04    0129*          		DW24  DEG_FP             ;DEG
040138 A5 06 04    0130*          		DW24  EXP_FP             ;EXP
04013B 4C 05 04    0131*          		DW24  INT_FP_            ;INT
04013E 43 07 04    0132*          		DW24  LN_FP              ;LN
040141 D8 07 04    0133*          		DW24  LOG_FP             ;LOG
040144 D6 04 04    0134*          		DW24  NOTK_FP            ;NOT
040147 02 05 04    0135*          		DW24  RAD_FP             ;RAD
04014A 1D 05 04    0136*          		DW24  SGN_FP             ;SGN
04014D F6 05 04    0137*          		DW24  SIN_FP             ;SIN
040150 65 05 04    0138*          		DW24  SQR_FP             ;SQR
040153 C3 05 04    0139*          		DW24  TAN_FP             ;TAN
040156             0140*  ;
040156 73 0C 04    0141*  		        DW24  ZERO_FP            ;ZERO
040159 7E 06 04    0142*          		DW24  FONE_FP            ;FONE
04015C BD 04 04    0143*          		DW24  TRUE_FP            ;TRUE
04015F EA 04 04    0144*          		DW24  PI_FP              ;PI
040162             0145*  ;
040162 31 05 04    0146*  		        DW24  VAL_FP             ;VAL
040165 B9 08 04    0147*          		DW24  STR_FP             ;STR$
040168             0148*  ;
040168 1A 0B 04    0149*          		DW24  SFIX_FP            ;FIX
04016B F6 0B 04    0150*          		DW24  SFLOAT_FP          ;FLOAT
04016E             0151*  ;
04016E 44 0C 04    0152*  		        DW24  FTEST_FP           ;TEST
040171 56 0C 04    0153*          		DW24  FCOMP_FP           ;COMPARE
040174             0154*  ;
040174 A4 01 04    0155*  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
040177 12 02 04    0156*          		DW24  FBDIV           ;DIV
04017A B7 01 04    0157*          		DW24  FEOR            ;EOR
04017D DD 01 04    0158*          		DW24  FMOD            ;MOD
040180 CA 01 04    0159*          		DW24  FFOR             ;OR
040183 96 04 04    0160*          		DW24  FLE             ;<=
040186 A5 04 04    0161*          		DW24  FNE             ;<>
040189 89 04 04    0162*          		DW24  FGE             ;>=
04018C 6E 04 04    0163*          		DW24  FLT             ;<
04018F B2 04 04    0164*          		DW24  FEQ             ;=
040192 5E 03 04    0165*          		DW24  FMUL            ;*
040195 4C 02 04    0166*          		DW24  FADD            ;+
040198 7B 04 04    0167*          		DW24  FGT             ;>
04019B 33 02 04    0168*          		DW24  FSUB            ;-
04019E 3B 04 04    0169*          		DW24  FPOW            ;^
0401A1 B5 02 04    0170*          		DW24  FDIV            ;/
0401A4             0171*  ;
0401A4             0172*  ;       PAGE
0401A4             0173*  ;
0401A4             0174*  ;ARITHMETIC AND LOGICAL OPERATORS:
0401A4             0175*  ;All take two arguments, in HLH'L'C & DED'E'B.
0401A4             0176*  ;Output in HLH'L'C
0401A4             0177*  ;All registers except IX, IY destroyed.
0401A4             0178*  ; (N.B. FPOW destroys IX).
0401A4             0179*  ;
0401A4             0180*  ;FAND - Floating-point AND.
0401A4             0181*  ;IAND - Integer AND.
0401A4             0182*  ;
0401A4 CD 0E 0B 04 0183*  FAND:			CALL    FIX2
0401A8 7C          0184*  IAND:			LD      A,H
0401A9 A2          0185*          		AND     D
0401AA 67          0186*          		LD      H,A
0401AB 7D          0187*          		LD      A,L
0401AC A3          0188*          		AND     E
0401AD 6F          0189*          		LD      L,A
0401AE D9          0190*          		EXX
0401AF 7C          0191*          		LD      A,H
0401B0 A2          0192*          		AND     D
0401B1 67          0193*          		LD      H,A
0401B2 7D          0194*          		LD      A,L
0401B3 A3          0195*          		AND     E
0401B4 6F          0196*          		LD      L,A
0401B5 D9          0197*          		EXX
0401B6 C9          0198*          		RET
0401B7             0199*  ;
0401B7             0200*  ;FEOR - Floating-point exclusive-OR.
0401B7             0201*  ;IEOR - Integer exclusive-OR.
0401B7             0202*  ;
0401B7 CD 0E 0B 04 0203*  FEOR:			CALL    FIX2
0401BB 7C          0204*  IEOR:			LD      A,H
0401BC AA          0205*          		XOR     D
0401BD 67          0206*          		LD      H,A
0401BE 7D          0207*          		LD      A,L
0401BF AB          0208*          		XOR     E
0401C0 6F          0209*          		LD      L,A
0401C1 D9          0210*          		EXX
0401C2 7C          0211*          		LD      A,H
0401C3 AA          0212*          		XOR     D
0401C4 67          0213*          		LD      H,A
0401C5 7D          0214*          		LD      A,L
0401C6 AB          0215*          		XOR     E
0401C7 6F          0216*          		LD      L,A
0401C8 D9          0217*          		EXX
0401C9 C9          0218*          		RET
0401CA             0219*  ;
0401CA             0220*  ;FOR - Floating-point OR.
0401CA             0221*  ;IOR - Integer OR.
0401CA             0222*  ;
0401CA CD 0E 0B 04 0223*  FFOR:			CALL    FIX2
0401CE 7C          0224*  IOR:			LD      A,H
0401CF B2          0225*          		OR      D
0401D0 67          0226*          		LD      H,A
0401D1 7D          0227*          		LD      A,L
0401D2 B3          0228*          		OR      E
0401D3 6F          0229*          		LD      L,A
0401D4 D9          0230*          		EXX
0401D5 7C          0231*          		LD      A,H
0401D6 B2          0232*          		OR      D
0401D7 67          0233*          		LD      H,A
0401D8 7D          0234*          		LD      A,L
0401D9 B3          0235*          		OR      E
0401DA 6F          0236*          		LD      L,A
0401DB D9          0237*          		EXX
0401DC C9          0238*          		RET
0401DD             0239*  ;
0401DD             0240*  ;FMOD - Floating-point remainder.
0401DD             0241*  ;IMOD - Integer remainder.
0401DD             0242*  ;
0401DD CD 0E 0B 04 0243*  FMOD:			CALL    FIX2
0401E1 7C          0244*  IMOD:			LD      A,H
0401E2 AA          0245*          		XOR     D               ;DIV RESULT SIGN
0401E3 CB 7C       0246*          		BIT     7,H
0401E5 08          0247*          		EX      AF,AF'
0401E6 CB 7C       0248*          		BIT     7,H
0401E8 C4 2A 0B 04 0249*          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0401EC CD 27 0C 04 0250*          		CALL    SWAP_FP
0401F0 CB 7C       0251*          		BIT     7,H
0401F2 C4 2A 0B 04 0252*          		CALL    NZ,NEGATE
0401F6 44          0253*          		LD      B,H
0401F7 4D          0254*          		LD      C,L
0401F8 21 00 00 00 0255*          		LD      HL,0
0401FC D9          0256*          		EXX
0401FD 44          0257*          		LD      B,H
0401FE 4D          0258*          		LD      C,L
0401FF 21 00 00 00 0259*          		LD      HL,0
040203 3E DF       0260*          		LD      A,-33
040205 CD B4 0D 04 0261*          		CALL    DIVA            ;DIVIDE
040209 D9          0262*          		EXX
04020A 0E 00       0263*          		LD      C,0             ;INTEGER MARKER
04020C 08          0264*          		EX      AF,AF'
04020D C8          0265*          		RET     Z
04020E C3 2A 0B 04 0266*          		JP      NEGATE
040212             0267*  ;
040212             0268*  ;BDIV - Integer division.
040212             0269*  ;
040212 CD 0E 0B 04 0270*  FBDIV:			CALL    FIX2
040216 CD E1 01 04 0271*  IBDIV:			CALL    IMOD
04021A B7          0272*          		OR      A
04021B CD 27 0C 04 0273*          		CALL    SWAP_FP
04021F 0E 00       0274*          		LD      C,0
040221 F0          0275*          		RET     P
040222 C3 2A 0B 04 0276*          		JP      NEGATE
040226             0277*  ;
040226             0278*  ;ISUB - Integer subtraction.
040226             0279*  ;FSUB - Floating point subtraction with rounding.
040226             0280*  ;
040226 CD C2 0C 04 0281*  ISUB:			CALL    SUB_
04022A E0          0282*          		RET     PO
04022B CD BA 0C 04 0283*          		CALL    ADD_
04022F CD EA 0B 04 0284*          		CALL    FLOAT2
040233 7A          0285*  FSUB:			LD      A,D
040234 EE 80       0286*          		XOR     80H             ;CHANGE SIGN THEN ADD
040236 57          0287*          		LD      D,A
040237 18 13       0288*          		JR      FADD
040239             0289*  ;
040239             0290*  ;Reverse subtract.
040239             0291*  ;
040239 7C          0292*  RSUB:			LD      A,H
04023A EE 80       0293*          		XOR     80H
04023C 67          0294*          		LD      H,A
04023D 18 0D       0295*          		JR      FADD
04023F             0296*  ;
04023F             0297*  ;IADD - Integer addition.
04023F             0298*  ;FADD - Floating point addition with rounding.
04023F             0299*  ;
04023F CD BA 0C 04 0300*  IADD:			CALL    ADD_
040243 E0          0301*          		RET     PO
040244 CD C2 0C 04 0302*          		CALL    SUB_
040248 CD EA 0B 04 0303*          		CALL    FLOAT2
04024C 05          0304*  FADD:			DEC     B
04024D 04          0305*          		INC     B
04024E C8          0306*          		RET     Z               ;ARG 2 ZERO
04024F 0D          0307*          		DEC     C
040250 0C          0308*          		INC     C
040251 CA 27 0C 04 0309*          		JP      Z,SWAP_FP          ;ARG 1 ZERO
040255 D9          0310*          		EXX
040256 01 00 00 00 0311*          		LD      BC,0            ;INITIALISE
04025A D9          0312*          		EXX
04025B 7C          0313*          		LD      A,H
04025C AA          0314*          		XOR     D               ;XOR SIGNS
04025D F5          0315*          		PUSH    AF
04025E 78          0316*          		LD      A,B
04025F B9          0317*          		CP      C               ;COMPARE EXPONENTS
040260 DC 27 0C 04 0318*          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
040264 78          0319*          		LD      A,B
040265 CB FC       0320*          		SET     7,H             ;IMPLIED 1
040267 C4 FB 0A 04 0321*          		CALL    NZ,FIX          ;ALIGN
04026B F1          0322*          		POP     AF
04026C 7A          0323*          		LD      A,D             ;SIGN OF LARGER
04026D CB FA       0324*          		SET     7,D             ;IMPLIED 1
04026F FA 7F 02 04 0325*          		JP      M,FADD3         ;SIGNS DIFFERENT
040273 CD BA 0C 04 0326*          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
040277 DC 2F 0C 04 0327*          		CALL    C,DIV2          ;NORMALISE
04027B CB FC       0328*          		SET     7,H
04027D 18 0D       0329*          		JR      FADD4
04027F             0330*  ;
04027F CD C2 0C 04 0331*  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
040283 DC 42 0B 04 0332*          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
040287 CD C1 0B 04 0333*          		CALL    FLO48
04028B 2F          0334*          		CPL                     ;CHANGE RESULT SIGN
04028C D9          0335*  FADD4:			EXX
04028D EB          0336*          		EX      DE,HL
04028E 21 00 80 00 0337*          		LD      HL,8000H
040292 B7          0338*          		OR      A               ;CLEAR CARRY
040293 52 ED 42    0339*          		SBC.S   HL,BC
040296 EB          0340*          		EX      DE,HL
040297 D9          0341*          		EXX
040298 CC 21 0C 04 0342*          		CALL    Z,ODD           ;ROUND UNBIASSED
04029C DC 0F 0C 04 0343*          		CALL    C,ADD1_FP          ;ROUND UP
0402A0 DC 3C 0C 04 0344*          		CALL    C,INCC
0402A4 CB BC       0345*          		RES     7,H
0402A6 0D          0346*          		DEC     C
0402A7 0C          0347*          		INC     C
0402A8 CA 73 0C 04 0348*          		JP      Z,ZERO_FP
0402AC B7          0349*          		OR      A               ;RESULT SIGNQ
0402AD F0          0350*          		RET     P               ;POSITIVE
0402AE CB FC       0351*          		SET     7,H             ;NEGATIVE
0402B0 C9          0352*          		RET
0402B1             0353*  ;
0402B1             0354*  ;IDIV - Integer division.
0402B1             0355*  ;FDIV - Floating point division with rounding.
0402B1             0356*  ;
0402B1 CD EA 0B 04 0357*  IDIV:			CALL    FLOAT2
0402B5 05          0358*  FDIV:			DEC     B               ;TEST FOR ZERO
0402B6 04          0359*          		INC     B
0402B7 3E 12       0360*          		LD      A,DIVBY0
0402B9 CA CD 00 04 0361*          		JP      Z,ERROR_FP_         ;"Division by zero"
0402BD 0D          0362*          		DEC     C               ;TEST FOR ZERO
0402BE 0C          0363*          		INC     C
0402BF C8          0364*          		RET     Z
0402C0 7C          0365*          		LD      A,H
0402C1 AA          0366*          		XOR     D               ;CALC. RESULT SIGN
0402C2 08          0367*          		EX      AF,AF'          ;SAVE SIGN
0402C3 CB FA       0368*          		SET     7,D             ;REPLACE IMPLIED 1's
0402C5 CB FC       0369*          		SET     7,H
0402C7 C5          0370*          		PUSH    BC              ;SAVE EXPONENTS
0402C8 42          0371*          		LD      B,D             ;LOAD REGISTERS
0402C9 4B          0372*          		LD      C,E
0402CA 11 00 00 00 0373*          		LD      DE,0
0402CE D9          0374*          		EXX
0402CF 42          0375*          		LD      B,D
0402D0 4B          0376*          		LD      C,E
0402D1 11 00 00 00 0377*          		LD      DE,0
0402D5 3E E0       0378*          		LD      A,-32           ;LOOP COUNTER
0402D7 CD B4 0D 04 0379*          		CALL    DIVA            ;DIVIDE
0402DB D9          0380*          		EXX
0402DC CB 7A       0381*          		BIT     7,D
0402DE D9          0382*          		EXX
0402DF CC D3 0D 04 0383*          		CALL    Z,DIVB          ;NORMALISE & INC A
0402E3 EB          0384*          		EX      DE,HL
0402E4 D9          0385*          		EXX
0402E5 CB 38       0386*          		SRL     B               ;DIVISOR/2
0402E7 CB 19       0387*          		RR      C
0402E9 B7          0388*          		OR      A               ;CLEAR CARRY
0402EA 52 ED 42    0389*          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0402ED 3F          0390*          		CCF
0402EE EB          0391*          		EX      DE,HL           ;RESULT IN HLH'L'
0402EF CC 21 0C 04 0392*          		CALL    Z,ODD           ;ROUND UNBIASSED
0402F3 DC 0F 0C 04 0393*          		CALL    C,ADD1_FP          ;ROUND UP
0402F7 C1          0394*          		POP     BC              ;RESTORE EXPONENTS
0402F8 DC 3C 0C 04 0395*          		CALL    C,INCC
0402FC 1F          0396*          		RRA                     ;LSB OF A TO CARRY
0402FD 79          0397*          		LD      A,C             ;COMPUTE NEW EXPONENT
0402FE 98          0398*          		SBC     A,B
0402FF 3F          0399*          		CCF
040300 C3 A1 03 04 0400*          		JP      CHKOVF
040304             0401*  ;
040304             0402*  ;IMUL - Integer multiplication.
040304             0403*  ;
040304 7C          0404*  IMUL:			LD      A,H
040305 AA          0405*          		XOR     D
040306 08          0406*          		EX      AF,AF'          ;SAVE RESULT SIGN
040307 CB 7C       0407*          		BIT     7,H
040309 C4 2A 0B 04 0408*          		CALL    NZ,NEGATE
04030D CD 27 0C 04 0409*          		CALL    SWAP_FP
040311 CB 7C       0410*          		BIT     7,H
040313 C4 2A 0B 04 0411*          		CALL    NZ,NEGATE
040317 44          0412*          		LD      B,H
040318 4D          0413*          		LD      C,L
040319 21 00 00 00 0414*          		LD      HL,0
04031D D9          0415*          		EXX
04031E 44          0416*          		LD      B,H
04031F 4D          0417*          		LD      C,L
040320 21 00 00 00 0418*          		LD      HL,0
040324 3E DF       0419*          		LD      A,-33
040326 CD EB 0D 04 0420*          		CALL    MULA            ;MULTIPLY
04032A D9          0421*          		EXX
04032B 0E BF       0422*          		LD      C,191           ;PRESET EXPONENT
04032D CD 4F 0C 04 0423*          		CALL    TEST_FP            ;TEST RANGE
040331 20 0F       0424*          		JR      NZ,IMUL1        ;TOO BIG
040333 CB 7A       0425*          		BIT     7,D
040335 20 0B       0426*          		JR      NZ,IMUL1
040337 CD 27 0C 04 0427*          		CALL    SWAP_FP
04033B 4A          0428*          		LD      C,D             ;INTEGER MARKER
04033C 08          0429*          		EX      AF,AF'
04033D F0          0430*          		RET     P
04033E C3 2A 0B 04 0431*          		JP      NEGATE
040342             0432*  ;
040342 0D          0433*  IMUL1:			DEC     C
040343 D9          0434*          		EXX
040344 CB 23       0435*          		SLA     E
040346 CB 12       0436*          		RL      D
040348 D9          0437*          		EXX
040349 CB 13       0438*          		RL      E
04034B CB 12       0439*          		RL      D
04034D D9          0440*          		EXX
04034E 52 ED 6A    0441*          		ADC.S   HL,HL
040351 D9          0442*          		EXX
040352 52 ED 6A    0443*          		ADC.S   HL,HL
040355 F2 42 03 04 0444*          		JP      P,IMUL1         ;NORMALISE
040359 08          0445*          		EX      AF,AF'
04035A F8          0446*          		RET     M
04035B CB BC       0447*          		RES     7,H             ;POSITIVE
04035D C9          0448*          		RET
04035E             0449*  ;
04035E             0450*  ;FMUL - Floating point multiplication with rounding.
04035E             0451*  ;
04035E 05          0452*  FMUL:			DEC     B               ;TEST FOR ZERO
04035F 04          0453*          		INC     B
040360 CA 73 0C 04 0454*          		JP      Z,ZERO_FP
040364 0D          0455*          		DEC     C               ;TEST FOR ZERO
040365 0C          0456*          		INC     C
040366 C8          0457*          		RET     Z
040367 7C          0458*          		LD      A,H
040368 AA          0459*          		XOR     D               ;CALC. RESULT SIGN
040369 08          0460*          		EX      AF,AF'
04036A CB FA       0461*          		SET     7,D             ;REPLACE IMPLIED 1's
04036C CB FC       0462*          		SET     7,H
04036E C5          0463*          		PUSH    BC              ;SAVE EXPONENTS
04036F 44          0464*          		LD      B,H             ;LOAD REGISTERS
040370 4D          0465*          		LD      C,L
040371 21 00 00 00 0466*          		LD      HL,0
040375 D9          0467*          		EXX
040376 44          0468*          		LD      B,H
040377 4D          0469*          		LD      C,L
040378 21 00 00 00 0470*          		LD      HL,0
04037C 3E E0       0471*          		LD      A,-32           ;LOOP COUNTER
04037E CD EB 0D 04 0472*          		CALL    MULA            ;MULTIPLY
040382 DC 01 0E 04 0473*          		CALL    C,MULB          ;NORMALISE & INC A
040386 D9          0474*          		EXX
040387 E5          0475*          		PUSH    HL
040388 21 00 80 00 0476*          		LD      HL,8000H
04038C B7          0477*          		OR      A               ;CLEAR CARRY
04038D 52 ED 52    0478*          		SBC.S   HL,DE
040390 E1          0479*          		POP     HL
040391 CC 21 0C 04 0480*          		CALL    Z,ODD           ;ROUND UNBIASSED
040395 DC 0F 0C 04 0481*          		CALL    C,ADD1_FP          ;ROUND UP
040399 C1          0482*          		POP     BC              ;RESTORE EXPONENTS
04039A DC 3C 0C 04 0483*          		CALL    C,INCC
04039E 1F          0484*          		RRA                     ;LSB OF A TO CARRY
04039F 79          0485*          		LD      A,C             ;COMPUTE NEW EXPONENT
0403A0 88          0486*          		ADC     A,B
0403A1 38 06       0487*  CHKOVF:			JR      C,CHKO1
0403A3 F2 73 0C 04 0488*          		JP      P,ZERO_FP          ;UNDERFLOW
0403A7 18 04       0489*          		JR      CHKO2
0403A9 FA 3E 0C 04 0490*  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0403AD C6 80       0491*  CHKO2:			ADD     A,80H
0403AF 4F          0492*          		LD      C,A
0403B0 CA 73 0C 04 0493*          		JP      Z,ZERO_FP
0403B4 08          0494*          		EX      AF,AF'          ;RESTORE SIGN BIT
0403B5 CB BC       0495*          		RES     7,H
0403B7 F0          0496*          		RET     P
0403B8 CB FC       0497*          		SET     7,H
0403BA C9          0498*          		RET
0403BB             0499*  ;
0403BB             0500*  ;IPOW - Integer involution.
0403BB             0501*  ;
0403BB CD 27 0C 04 0502*  IPOW:			CALL    SWAP_FP
0403BF CB 7C       0503*          		BIT     7,H
0403C1 F5          0504*          		PUSH    AF              ;SAVE SIGN
0403C2 C4 2A 0B 04 0505*          		CALL    NZ,NEGATE
0403C6 48          0506*  IPOW0:			LD      C,B
0403C7 06 20       0507*          		LD      B,32            ;LOOP COUNTER
0403C9 CD DF 0C 04 0508*  IPOW1:			CALL    X2
0403CD 38 08       0509*          		JR      C,IPOW2
0403CF 10 F8       0510*          		DJNZ    IPOW1
0403D1 F1          0511*          		POP     AF
0403D2 D9          0512*          		EXX
0403D3 2C          0513*          		INC     L               ;RESULT=1
0403D4 D9          0514*          		EXX
0403D5 4C          0515*          		LD      C,H
0403D6 C9          0516*          		RET
0403D7             0517*  ;
0403D7 F1          0518*  IPOW2:			POP     AF
0403D8 C5          0519*          		PUSH    BC
0403D9 EB          0520*          		EX      DE,HL
0403DA E5          0521*          		PUSH    HL
0403DB D9          0522*          		EXX
0403DC EB          0523*          		EX      DE,HL
0403DD E5          0524*          		PUSH    HL
0403DE D9          0525*          		EXX
0403DF DD 21 00 00 0526*          		LD      IX,0
       00          
0403E4 DD 39       0527*          		ADD     IX,SP
0403E6 28 48       0528*          		JR      Z,IPOW4
0403E8 C5          0529*          		PUSH    BC
0403E9 D9          0530*          		EXX
0403EA D5          0531*          		PUSH    DE
0403EB D9          0532*          		EXX
0403EC D5          0533*          		PUSH    DE
0403ED CD F6 0B 04 0534*          		CALL    SFLOAT_FP
0403F1 CD 2A 07 04 0535*          		CALL    RECIP
0403F5 DD 71 04    0536*          		LD      (IX+4),C
0403F8 D9          0537*          		EXX
0403F9 DD 75 00    0538*          		LD      (IX+0),L
0403FC DD 74 01    0539*          		LD      (IX+1),H
0403FF D9          0540*          		EXX
040400 DD 75 02    0541*          		LD      (IX+2),L
040403 DD 74 03    0542*          		LD      (IX+3),H
040406 18 21       0543*          		JR      IPOW5
040408             0544*  ;
040408 C5          0545*  IPOW3:			PUSH    BC
040409 D9          0546*          		EXX
04040A CB 23       0547*          		SLA     E
04040C CB 12       0548*          		RL      D
04040E D5          0549*          		PUSH    DE
04040F D9          0550*          		EXX
040410 CB 13       0551*          		RL      E
040412 CB 12       0552*          		RL      D
040414 D5          0553*          		PUSH    DE
040415 3E 0A       0554*          		LD      A,'*' & 0FH
040417 F5          0555*          		PUSH    AF
040418 CD F3 0C 04 0556*          		CALL    COPY_
04041C CD D3 00 04 0557*          		CALL    OP              ;SQUARE
040420 F1          0558*          		POP     AF
040421 CD 1F 0A 04 0559*          		CALL    DLOAD5
040425 DC D3 00 04 0560*          		CALL    C,OP            ;MULTIPLY BY X
040429 D1          0561*  IPOW5:			POP     DE
04042A D9          0562*          		EXX
04042B D1          0563*          		POP     DE
04042C D9          0564*          		EXX
04042D 79          0565*          		LD      A,C
04042E C1          0566*          		POP     BC
04042F 4F          0567*          		LD      C,A
040430 10 D6       0568*  IPOW4:			DJNZ    IPOW3
040432 F1          0569*          		POP     AF
040433 F1          0570*          		POP     AF
040434 F1          0571*          		POP     AF
040435 C9          0572*          		RET
040436             0573*  ;
040436 F1          0574*  FPOW0:			POP     AF
040437 F1          0575*          		POP     AF
040438 F1          0576*          		POP     AF
040439 18 8B       0577*          		JR      IPOW0
04043B             0578*  ;
04043B             0579*  ;FPOW - Floating-point involution.
04043B             0580*  ;
04043B CB 7A       0581*  FPOW:			BIT     7,D
04043D F5          0582*          		PUSH    AF
04043E CD 27 0C 04 0583*          		CALL    SWAP_FP
040442 CD 03 0D 04 0584*          		CALL    PUSH5
040446 0D          0585*          		DEC     C
040447 0C          0586*          		INC     C
040448 28 EC       0587*          		JR      Z,FPOW0
04044A 3E 9E       0588*          		LD      A,158
04044C B9          0589*          		CP      C
04044D 38 0A       0590*          		JR      C,FPOW1
04044F 3C          0591*          		INC     A
040450 CD FB 0A 04 0592*          		CALL    FIX
040454 08          0593*          		EX      AF,AF'
040455 F2 36 04 04 0594*          		JP      P,FPOW0
040459 CD 27 0C 04 0595*  FPOW1:			CALL    SWAP_FP
04045D CD 47 07 04 0596*          		CALL    LN0
040461 CD 0C 0D 04 0597*          		CALL    POP5
040465 F1          0598*          		POP     AF
040466 CD 5E 03 04 0599*          		CALL    FMUL
04046A C3 A9 06 04 0600*          		JP      EXP0
04046E             0601*  ;
04046E             0602*  ;Integer and floating-point compare.
04046E             0603*  ;Result is TRUE (-1) or FALSE (0).
04046E             0604*  ;
04046E CD 7D 0C 04 0605*  FLT:			CALL    FCP
040472 18 04       0606*          		JR      ILT1
040474 CD 6F 0C 04 0607*  ILT:			CALL    ICP
040478 D0          0608*  ILT1:			RET     NC
040479 18 42       0609*          		JR      TRUE_FP
04047B             0610*  ;
04047B CD 7D 0C 04 0611*  FGT:			CALL    FCP
04047F 18 04       0612*          		JR      IGT1
040481 CD 6F 0C 04 0613*  IGT:			CALL    ICP
040485 C8          0614*  IGT1:			RET     Z
040486 D8          0615*          		RET     C
040487 18 34       0616*          		JR      TRUE_FP
040489             0617*  ;
040489 CD 7D 0C 04 0618*  FGE:			CALL    FCP
04048D 18 04       0619*          		JR      IGE1
04048F CD 6F 0C 04 0620*  IGE:			CALL    ICP
040493 D8          0621*  IGE1:			RET     C
040494 18 27       0622*          		JR      TRUE_FP
040496             0623*  ;
040496 CD 7D 0C 04 0624*  FLE:			CALL    FCP
04049A 18 04       0625*          		JR      ILE1
04049C CD 6F 0C 04 0626*  ILE:			CALL    ICP
0404A0 28 1B       0627*  ILE1:			JR      Z,TRUE_FP
0404A2 D0          0628*          		RET     NC
0404A3 18 18       0629*          		JR      TRUE_FP
0404A5             0630*  ;
0404A5 CD 7D 0C 04 0631*  FNE:			CALL    FCP
0404A9 18 04       0632*          		JR      INE1
0404AB CD 6F 0C 04 0633*  INE:			CALL    ICP
0404AF C8          0634*  INE1:			RET     Z
0404B0 18 0B       0635*          		JR      TRUE_FP
0404B2             0636*  ;
0404B2 CD 7D 0C 04 0637*  FEQ:			CALL    FCP
0404B6 18 04       0638*          		JR      IEQ1
0404B8 CD 6F 0C 04 0639*  IEQ:			CALL    ICP
0404BC C0          0640*  IEQ1:			RET     NZ
0404BD 21 FF FF FF 0641*  TRUE_FP:			LD      HL,-1
0404C1 D9          0642*          		EXX
0404C2 21 FF FF FF 0643*          		LD      HL,-1
0404C6 D9          0644*          		EXX
0404C7 AF          0645*          		XOR     A
0404C8 4F          0646*          		LD      C,A
0404C9 C9          0647*          		RET
0404CA             0648*  ;
0404CA             0649*  ;FUNCTIONS:
0404CA             0650*  ;
0404CA             0651*  ;Result returned in HLH'L'C (floating point)
0404CA             0652*  ;Result returned in HLH'L' (C=0) (integer)
0404CA             0653*  ;All registers except IY destroyed.
0404CA             0654*  ;
0404CA             0655*  ;ABS - Absolute value
0404CA             0656*  ;Result is numeric, variable type.
0404CA             0657*  ;
0404CA CB 7C       0658*  ABSV_FP:			BIT     7,H
0404CC C8          0659*          		RET     Z               ;POSITIVE/ZERO
0404CD 0D          0660*          		DEC     C
0404CE 0C          0661*          		INC     C
0404CF CA 2A 0B 04 0662*          		JP      Z,NEGATE        ;INTEGER
0404D3 CB BC       0663*          		RES     7,H
0404D5 C9          0664*          		RET
0404D6             0665*  ;
0404D6             0666*  ;NOT - Complement integer.
0404D6             0667*  ;Result is integer numeric.
0404D6             0668*  ;
0404D6 CD 1A 0B 04 0669*  NOTK_FP:			CALL    SFIX_FP
0404DA 7C          0670*          		LD      A,H
0404DB 2F          0671*          		CPL
0404DC 67          0672*          		LD      H,A
0404DD 7D          0673*          		LD      A,L
0404DE 2F          0674*          		CPL
0404DF 6F          0675*          		LD      L,A
0404E0 D9          0676*          		EXX
0404E1 7C          0677*          		LD      A,H
0404E2 2F          0678*          		CPL
0404E3 67          0679*          		LD      H,A
0404E4 7D          0680*          		LD      A,L
0404E5 2F          0681*          		CPL
0404E6 6F          0682*          		LD      L,A
0404E7 D9          0683*          		EXX
0404E8 AF          0684*          		XOR     A               ;NUMERIC MARKER
0404E9 C9          0685*          		RET
0404EA             0686*  ;
0404EA             0687*  ;PI - Return PI (3.141592654)
0404EA             0688*  ;Result is floating-point numeric.
0404EA             0689*  ;
0404EA 21 0F 49 00 0690*  PI_FP:			LD      HL,490FH
0404EE D9          0691*          		EXX
0404EF 21 A2 DA 00 0692*          		LD      HL,0DAA2H
0404F3 D9          0693*          		EXX
0404F4 0E 81       0694*          		LD      C,81H
0404F6 AF          0695*          		XOR     A               ;NUMERIC MARKER
0404F7 C9          0696*          		RET
0404F8             0697*  ;
0404F8             0698*  ;DEG - Convert radians to degrees
0404F8             0699*  ;Result is floating-point numeric.
0404F8             0700*  ;
0404F8 CD 0C 05 04 0701*  DEG_FP:			CALL    FPI180
0404FC CD 5E 03 04 0702*          		CALL    FMUL
040500 AF          0703*          		XOR     A
040501 C9          0704*          		RET
040502             0705*  ;
040502             0706*  ;RAD - Convert degrees to radians
040502             0707*  ;Result is floating-point numeric.
040502             0708*  ;
040502 CD 0C 05 04 0709*  RAD_FP:			CALL    FPI180
040506 CD B5 02 04 0710*          		CALL    FDIV
04050A AF          0711*          		XOR     A
04050B C9          0712*          		RET
04050C             0713*  ;
04050C             0714*  ;180/PI
04050C             0715*  ;
04050C CD F6 0B 04 0716*  FPI180:			CALL    SFLOAT_FP
040510 11 2E 65 00 0717*          		LD      DE,652EH
040514 D9          0718*          		EXX
040515 11 D3 E0 00 0719*          		LD      DE,0E0D3H
040519 D9          0720*          		EXX
04051A 06 85       0721*          		LD      B,85H
04051C C9          0722*          		RET
04051D             0723*  ;
04051D             0724*  ;SGN - Return -1, 0 or +1
04051D             0725*  ;Result is integer numeric.
04051D             0726*  ;
04051D CD 4F 0C 04 0727*  SGN_FP:			CALL    TEST_FP
040521 B1          0728*          		OR      C
040522 C8          0729*          		RET     Z               ;ZERO
040523 CB 7C       0730*          		BIT     7,H
040525 C2 BD 04 04 0731*          		JP      NZ,TRUE_FP         ;-1
040529 CD 73 0C 04 0732*          		CALL    ZERO_FP
04052D C3 0F 0C 04 0733*          		JP      ADD1_FP            ;1
040531             0734*  ;
040531             0735*  ;VAL - Return numeric value of string.
040531             0736*  ;Input: ASCII string at IX
040531             0737*  ;Result is variable type numeric.
040531             0738*  ;
040531 CD 8D 0E 04 0739*  VAL_FP:			CALL    SIGNQ
040535 F5          0740*          		PUSH    AF
040536 CD 3D 0A 04 0741*          		CALL    CON_FP
04053A F1          0742*          		POP     AF
04053B FE 2D       0743*          		CP      '-'
04053D 3E 00       0744*          		LD      A,0             ;NUMERIC MARKER
04053F C0          0745*          		RET     NZ
040540 0D          0746*          		DEC     C
040541 0C          0747*          		INC     C
040542 CA 2A 0B 04 0748*          		JP      Z,NEGATE        ;ZERO/INTEGER
040546 7C          0749*          		LD      A,H
040547 EE 80       0750*          		XOR     80H             ;CHANGE SIGN (FP)
040549 67          0751*          		LD      H,A
04054A AF          0752*          		XOR     A
04054B C9          0753*          		RET
04054C             0754*  ;
04054C             0755*  ;INT - Floor function
04054C             0756*  ;Result is integer numeric.
04054C             0757*  ;
04054C 0D          0758*  INT_FP_:			DEC     C
04054D 0C          0759*          		INC     C
04054E C8          0760*          		RET     Z               ;ZERO/INTEGER
04054F 3E 9F       0761*          		LD      A,159
040551 44          0762*          		LD      B,H             ;B7=SIGN BIT
040552 CD FB 0A 04 0763*          		CALL    FIX
040556 08          0764*          		EX      AF,AF'
040557 A0          0765*          		AND     B
040558 FC 0F 0C 04 0766*          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
04055C 78          0767*          		LD      A,B
04055D B7          0768*          		OR      A
04055E FC 2A 0B 04 0769*          		CALL    M,NEGATE
040562 AF          0770*          		XOR     A
040563 4F          0771*          		LD      C,A
040564 C9          0772*          		RET
040565             0773*  ;
040565             0774*  ;SQR - square root
040565             0775*  ;Result is floating-point numeric.
040565             0776*  ;
040565 CD F6 0B 04 0777*  SQR_FP:			CALL    SFLOAT_FP
040569 CB 7C       0778*  SQR0:			BIT     7,H
04056B 3E 15       0779*          		LD      A,NGROOT
04056D C2 CD 00 04 0780*          		JP      NZ,ERROR_FP_        ;"-ve root"
040571 0D          0781*          		DEC     C
040572 0C          0782*          		INC     C
040573 C8          0783*          		RET     Z               ;ZERO
040574 CB FC       0784*          		SET     7,H             ;IMPLIED 1
040576 CB 41       0785*          		BIT     0,C
040578 CC 2F 0C 04 0786*          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
04057C 79          0787*          		LD      A,C
04057D D6 80       0788*          		SUB     80H
04057F CB 2F       0789*          		SRA     A               ;HALVE EXPONENT
040581 C6 80       0790*          		ADD     A,80H
040583 4F          0791*          		LD      C,A
040584 C5          0792*          		PUSH    BC              ;SAVE EXPONENT
040585 EB          0793*          		EX      DE,HL
040586 21 00 00 00 0794*          		LD      HL,0
04058A 44          0795*          		LD      B,H
04058B 4D          0796*          		LD      C,L
04058C D9          0797*          		EXX
04058D EB          0798*          		EX      DE,HL
04058E 21 00 00 00 0799*          		LD      HL,0
040592 44          0800*          		LD      B,H
040593 4D          0801*          		LD      C,L
040594 3E E1       0802*          		LD      A,-31
040596 CD 25 0E 04 0803*          		CALL    SQRA            ;ROOT
04059A D9          0804*          		EXX
04059B CB 78       0805*          		BIT     7,B
04059D D9          0806*          		EXX
04059E CC 25 0E 04 0807*          		CALL    Z,SQRA          ;NORMALISE & INC A
0405A2 CD 66 0E 04 0808*          		CALL    SQRB
0405A6 B7          0809*          		OR      A               ;CLEAR CARRY
0405A7 CD D3 0D 04 0810*          		CALL    DIVB
0405AB CB 1B       0811*          		RR      E               ;LSB TO CARRY
0405AD 60          0812*          		LD      H,B
0405AE 69          0813*          		LD      L,C
0405AF D9          0814*          		EXX
0405B0 60          0815*          		LD      H,B
0405B1 69          0816*          		LD      L,C
0405B2 DC 0F 0C 04 0817*          		CALL    C,ADD1_FP          ;ROUND UP
0405B6 C1          0818*          		POP     BC              ;RESTORE EXPONENT
0405B7 DC 3C 0C 04 0819*          		CALL    C,INCC
0405BB 1F          0820*          		RRA
0405BC 9F          0821*          		SBC     A,A
0405BD 81          0822*          		ADD     A,C
0405BE 4F          0823*          		LD      C,A
0405BF CB BC       0824*          		RES     7,H             ;POSITIVE
0405C1 AF          0825*          		XOR     A
0405C2 C9          0826*          		RET
0405C3             0827*  ;
0405C3             0828*  ;TAN - Tangent function
0405C3             0829*  ;Result is floating-point numeric.
0405C3             0830*  ;
0405C3 CD F6 0B 04 0831*  TAN_FP:			CALL    SFLOAT_FP
0405C7 CD 03 0D 04 0832*          		CALL    PUSH5
0405CB CD ED 05 04 0833*          		CALL    COS0
0405CF CD 0C 0D 04 0834*          		CALL    POP5
0405D3 CD 03 0D 04 0835*          		CALL    PUSH5
0405D7 CD 27 0C 04 0836*          		CALL    SWAP_FP
0405DB CD FA 05 04 0837*          		CALL    SIN0
0405DF CD 0C 0D 04 0838*          		CALL    POP5
0405E3 CD B5 02 04 0839*          		CALL    FDIV
0405E7 AF          0840*          		XOR     A               ;NUMERIC MARKER
0405E8 C9          0841*          		RET
0405E9             0842*  ;
0405E9             0843*  ;COS - Cosine function
0405E9             0844*  ;Result is floating-point numeric.
0405E9             0845*  ;
0405E9 CD F6 0B 04 0846*  COS_FP:			CALL    SFLOAT_FP
0405ED CD 52 0B 04 0847*  COS0:			CALL    SCALE
0405F1 1C          0848*          		INC     E
0405F2 1C          0849*          		INC     E
0405F3 7B          0850*          		LD      A,E
0405F4 18 10       0851*          		JR      SIN1
0405F6             0852*  ;
0405F6             0853*  ;SIN - Sine function
0405F6             0854*  ;Result is floating-point numeric.
0405F6             0855*  ;
0405F6 CD F6 0B 04 0856*  SIN_FP:			CALL    SFLOAT_FP
0405FA E5          0857*  SIN0:			PUSH    HL              ;H7=SIGN
0405FB CD 52 0B 04 0858*          		CALL    SCALE
0405FF F1          0859*          		POP     AF
040600 07          0860*          		RLCA
040601 07          0861*          		RLCA
040602 07          0862*          		RLCA
040603 E6 04       0863*          		AND     4
040605 AB          0864*          		XOR     E
040606 F5          0865*  SIN1:			PUSH    AF              ;OCTANT
040607 CB BC       0866*          		RES     7,H
040609 1F          0867*          		RRA
04060A CD 98 06 04 0868*          		CALL    PIBY4
04060E DC 39 02 04 0869*          		CALL    C,RSUB          ;X=(PI/4)-X
040612 F1          0870*          		POP     AF
040613 F5          0871*          		PUSH    AF
040614 E6 03       0872*          		AND     3
040616 E2 4F 06 04 0873*          		JP      PO,SIN2         ;USE COSINE APPROX.
04061A CD 03 0D 04 0874*          		CALL    PUSH5           ;SAVE X
04061E CD FB 0C 04 0875*          		CALL    SQUARE          ;PUSH X*X
040622 CD 40 0D 04 0876*          		CALL    POLY
040626 B7 A8       0877*          		DW	0A8B7H          ;a(8)
040628 11 36       0878*          		DW	3611H
04062A 6D          0879*          		DB	6DH
04062B 26 DE       0880*          		DW	0DE26H          ;a(6)
04062D 05 D0       0881*          		DW	0D005H
04062F 73          0882*          		DB	73H
040630 C0 80       0883*          		DW	80C0H           ;a(4)
040632 88 08       0884*          		DW	888H
040634 79          0885*          		DB	79H
040635 9D AA       0886*          		DW	0AA9DH          ;a(2)
040637 AA AA       0887*          		DW	0AAAAH
040639 7D          0888*          		DB	7DH
04063A 00 00       0889*          		DW	0               ;a(0)
04063C 00 00       0890*          		DW	0
04063E 80          0891*          		DB	80H
04063F CD 0C 0D 04 0892*          		CALL    POP5
040643 CD 0C 0D 04 0893*          		CALL    POP5
040647 CD 5E 03 04 0894*          		CALL    FMUL
04064B C3 74 06 04 0895*          		JP      SIN3
04064F             0896*  ;
04064F CD FB 0C 04 0897*  SIN2:			CALL    SQUARE          ;PUSH X*X
040653 CD 40 0D 04 0898*          		CALL    POLY
040657 71 D5       0899*          		DW	0D571H          ;b(8)
040659 78 4C       0900*          		DW	4C78H
04065B 70          0901*          		DB	70H
04065C AF 94       0902*          		DW	94AFH           ;b(6)
04065E 03 B6       0903*          		DW	0B603H
040660 76          0904*          		DB	76H
040661 C8 9C       0905*          		DW	9CC8H           ;b(4)
040663 AA 2A       0906*          		DW	2AAAH
040665 7B          0907*          		DB	7BH
040666 DD FF       0908*          		DW	0FFDDH          ;b(2)
040668 FF FF       0909*          		DW	0FFFFH
04066A 7E          0910*          		DB	7EH
04066B 00 00       0911*          		DW	0               ;b(0)
04066D 00 00       0912*          		DW	0
04066F 80          0913*          		DB	80H
040670 CD 0C 0D 04 0914*          		CALL    POP5
040674 F1          0915*  SIN3:			POP     AF
040675 E6 04       0916*          		AND     4
040677 C8          0917*          		RET     Z
040678 0D          0918*          		DEC     C
040679 0C          0919*          		INC     C
04067A C8          0920*          		RET     Z               ;ZERO
04067B CB FC       0921*          		SET     7,H             ;MAKE NEGATIVE
04067D C9          0922*          		RET
04067E             0923*  ;
04067E             0924*  ;Floating-point one:
04067E             0925*  ;
04067E 21 00 00 00 0926*  FONE_FP:			LD      HL,0
040682 D9          0927*          		EXX
040683 21 00 00 00 0928*          		LD      HL,0
040687 D9          0929*          		EXX
040688 0E 80       0930*          		LD      C,80H
04068A C9          0931*          		RET
04068B             0932*  ;
04068B 11 00 00 00 0933*  DONE:			LD      DE,0
04068F D9          0934*          		EXX
040690 11 00 00 00 0935*          		LD      DE,0
040694 D9          0936*          		EXX
040695 06 80       0937*          		LD      B,80H
040697 C9          0938*          		RET
040698             0939*  ;
040698 11 0F 49 00 0940*  PIBY4:			LD      DE,490FH
04069C D9          0941*          		EXX
04069D 11 A2 DA 00 0942*          		LD      DE,0DAA2H
0406A1 D9          0943*          		EXX
0406A2 06 7F       0944*          		LD      B,7FH
0406A4 C9          0945*          		RET
0406A5             0946*  ;
0406A5             0947*  ;EXP - Exponential function
0406A5             0948*  ;Result is floating-point numeric.
0406A5             0949*  ;
0406A5 CD F6 0B 04 0950*  EXP_FP:			CALL    SFLOAT_FP
0406A9 CD 36 07 04 0951*  EXP0:			CALL    LN2             ;LN(2)
0406AD D9          0952*          		EXX
0406AE 1D          0953*  	        	DEC     E
0406AF 01 CF D1 00 0954*  		        LD      BC,0D1CFH       ;0.6931471805599453
0406B3 D9          0955*          		EXX
0406B4 E5          0956*          		PUSH    HL              ;H7=SIGN
0406B5 CD 65 0B 04 0957*          		CALL    MOD48           ;"MODULUS"
0406B9 F1          0958*          		POP     AF
0406BA CB 7B       0959*          		BIT     7,E
0406BC 28 0B       0960*          		JR      Z,EXP1
0406BE 17          0961*          		RLA
0406BF DA 73 0C 04 0962*          		JP      C,ZERO_FP
0406C3 3E 18       0963*          		LD      A,EXPRNG
0406C5 C3 CD 00 04 0964*          		JP      ERROR_FP_           ;"Exp range"
0406C9             0965*  ;
0406C9 E6 80       0966*  EXP1:			AND     80H
0406CB B3          0967*          		OR      E
0406CC F5          0968*          		PUSH    AF              ;INTEGER PART
0406CD CB BC       0969*          		RES     7,H
0406CF CD 03 0D 04 0970*          		CALL    PUSH5           ;PUSH X*LN(2)
0406D3 CD 40 0D 04 0971*          		CALL    POLY
0406D7 72 40       0972*          		DW	4072H           ;a(7)
0406D9 2E 94       0973*          		DW	942EH
0406DB 73          0974*          		DB	73H
0406DC 65 6F       0975*          		DW	6F65H           ;a(6)
0406DE 4F 2E       0976*          		DW	2E4FH
0406E0 76          0977*          		DB	76H
0406E1 37 6D       0978*          		DW	6D37H           ;a(5)
0406E3 02 88       0979*          		DW	8802H
0406E5 79          0980*          		DB	79H
0406E6 12 E5       0981*          		DW	0E512H          ;a(4)
0406E8 A0 2A       0982*          		DW	2AA0H
0406EA 7B          0983*          		DB	7BH
0406EB 14 4F       0984*          		DW	4F14H           ;a(3)
0406ED AA AA       0985*          		DW	0AAAAH
0406EF 7D          0986*          		DB	7DH
0406F0 56 FD       0987*          		DW	0FD56H          ;a(2)
0406F2 FF 7F       0988*          		DW	7FFFH
0406F4 7E          0989*          		DB	7EH
0406F5 FE FF       0990*          		DW	0FFFEH          ;a(1)
0406F7 FF FF       0991*          		DW	0FFFFH
0406F9 7F          0992*          		DB	7FH
0406FA 00 00       0993*          		DW	0               ;a(0)
0406FC 00 00       0994*          		DW	0
0406FE 80          0995*          		DB	80H
0406FF CD 0C 0D 04 0996*          		CALL    POP5
040703 F1          0997*          		POP     AF
040704 F5          0998*          		PUSH    AF
040705 F4 2A 07 04 0999*          		CALL    P,RECIP         ;X=1/X
040709 F1          1000*          		POP     AF
04070A F2 12 07 04 1001*          		JP      P,EXP4
04070E E6 7F       1002*          		AND     7FH
040710 ED 44       1003*          		NEG
040712 C6 80       1004*  EXP4:			ADD     A,80H
040714 81          1005*          		ADD     A,C
040715 38 06       1006*          		JR      C,EXP2
040717 F2 73 0C 04 1007*          		JP      P,ZERO_FP          ;UNDERFLOW
04071B 18 04       1008*          		JR      EXP3
04071D FA 3E 0C 04 1009*  EXP2:			JP      M,OFLOW         ;OVERFLOW
040721 C6 80       1010*  EXP3:			ADD     A,80H
040723 CA 73 0C 04 1011*          		JP      Z,ZERO_FP
040727 4F          1012*          		LD      C,A
040728 AF          1013*          		XOR     A               ;NUMERIC MARKER
040729 C9          1014*          		RET
04072A             1015*  ;
04072A CD 8B 06 04 1016*  RECIP:			CALL    DONE
04072E CD 27 0C 04 1017*  RDIV:			CALL    SWAP_FP
040732 C3 B5 02 04 1018*          		JP      FDIV            ;RECIPROCAL
040736             1019*  ;
040736 11 72 31 00 1020*  LN2:			LD      DE,3172H        ;LN(2)
04073A D9          1021*          		EXX
04073B 11 F8 17 00 1022*          		LD      DE,17F8H
04073F D9          1023*          		EXX
040740 06 7F       1024*          		LD      B,7FH
040742 C9          1025*          		RET
040743             1026*  ;
040743             1027*  ;LN - Natural log.
040743             1028*  ;Result is floating-point numeric.
040743             1029*  ;
040743 CD F6 0B 04 1030*  LN_FP:			CALL    SFLOAT_FP
040747 3E 16       1031*  LN0:			LD      A,LOGRNG
040749 CB 7C       1032*          		BIT     7,H
04074B C2 CD 00 04 1033*          		JP      NZ,ERROR_FP_        ;"Log range"
04074F 0C          1034*          		INC     C
040750 0D          1035*          		DEC     C
040751 CA CD 00 04 1036*          		JP      Z,ERROR_FP_
040755 11 04 35 00 1037*          		LD      DE,3504H        ;SQR(2)
040759 D9          1038*          		EXX
04075A 11 33 F3 00 1039*          		LD      DE,0F333H       ;1.41421356237
04075E D9          1040*          		EXX
04075F CD 86 0C 04 1041*          		CALL    ICP0            ;MANTISSA>SQR(2)?
040763 79          1042*          		LD      A,C             ;EXPONENT
040764 0E 80       1043*          		LD      C,80H           ;1 <= X < 2
040766 38 02       1044*          		JR      C,LN4
040768 0D          1045*          		DEC     C
040769 3C          1046*          		INC     A
04076A F5          1047*  LN4:			PUSH    AF              ;SAVE EXPONENT
04076B CD 18 0D 04 1048*          		CALL    RATIO           ;X=(X-1)/(X+1)
04076F CD 03 0D 04 1049*          		CALL    PUSH5
040773 CD FB 0C 04 1050*  		        CALL    SQUARE          ;PUSH X*X
040777 CD 40 0D 04 1051*          		CALL    POLY
04077B 48 CC       1052*          		DW	0CC48H          ;a(9)
04077D FB 74       1053*          		DW	74FBH
04077F 7D          1054*          		DB	7DH
040780 AF AE       1055*          		DW	0AEAFH          ;a(7)
040782 FF 11       1056*          		DW	11FFH
040784 7E          1057*          		DB	7EH
040785 8C D9       1058*          		DW	0D98CH          ;a(5)
040787 CD 4C       1059*          		DW	4CCDH
040789 7E          1060*          		DB	7EH
04078A E3 A9       1061*          		DW	0A9E3H          ;a(3)
04078C AA 2A       1062*          		DW	2AAAH
04078E 7F          1063*          		DB	7FH
04078F 00 00       1064*          		DW	0               ;a(1)
040791 00 00       1065*          		DW	0
040793 81          1066*          		DB	81H
040794 CD 0C 0D 04 1067*          		CALL    POP5
040798 CD 0C 0D 04 1068*          		CALL    POP5
04079C CD 5E 03 04 1069*          		CALL    FMUL
0407A0 F1          1070*          		POP     AF              ;EXPONENT
0407A1 CD 03 0D 04 1071*          		CALL    PUSH5
0407A5 08          1072*          		EX      AF,AF'
0407A6 CD 73 0C 04 1073*          		CALL    ZERO_FP
0407AA 08          1074*          		EX      AF,AF'
0407AB D6 80       1075*          		SUB     80H
0407AD 28 1F       1076*          		JR      Z,LN3
0407AF 30 02       1077*          		JR      NC,LN1
0407B1 2F          1078*          		CPL
0407B2 3C          1079*          		INC     A
0407B3 67          1080*  LN1:			LD      H,A
0407B4 0E 87       1081*          		LD      C,87H
0407B6 F5          1082*          		PUSH    AF
0407B7 CD D6 0B 04 1083*          		CALL    FLOAT_
0407BB CB BC       1084*          		RES     7,H
0407BD CD 36 07 04 1085*          		CALL    LN2
0407C1 CD 5E 03 04 1086*          		CALL    FMUL
0407C5 F1          1087*          		POP     AF
0407C6 30 06       1088*          		JR      NC,LN3
0407C8 FA CE 07 04 1089*          		JP      M,LN3
0407CC CB FC       1090*          		SET     7,H
0407CE CD 0C 0D 04 1091*  LN3:			CALL    POP5
0407D2 CD 4C 02 04 1092*          		CALL    FADD
0407D6 AF          1093*          		XOR     A
0407D7 C9          1094*          		RET
0407D8             1095*  ;
0407D8             1096*  ;LOG - base-10 logarithm.
0407D8             1097*  ;Result is floating-point numeric.
0407D8             1098*  ;
0407D8 CD 43 07 04 1099*  LOG_FP:			CALL    LN_FP
0407DC 11 5B 5E 00 1100*          		LD      DE,5E5BH        ;LOG(e)
0407E0 D9          1101*          		EXX
0407E1 11 A9 D8 00 1102*          		LD      DE,0D8A9H
0407E5 D9          1103*          		EXX
0407E6 06 7E       1104*          		LD      B,7EH
0407E8 CD 5E 03 04 1105*          		CALL    FMUL
0407EC AF          1106*          		XOR     A
0407ED C9          1107*          		RET
0407EE             1108*  ;
0407EE             1109*  ;ASN - Arc-sine
0407EE             1110*  ;Result is floating-point numeric.
0407EE             1111*  ;
0407EE CD F6 0B 04 1112*  ASN_FP:			CALL    SFLOAT_FP
0407F2 CD 03 0D 04 1113*          		CALL    PUSH5
0407F6 CD F3 0C 04 1114*          		CALL    COPY_
0407FA CD 5E 03 04 1115*          		CALL    FMUL
0407FE CD 8B 06 04 1116*          		CALL    DONE
040802 CD 39 02 04 1117*          		CALL    RSUB
040806 CD 69 05 04 1118*          		CALL    SQR0
04080A CD 0C 0D 04 1119*          		CALL    POP5
04080E 0C          1120*          		INC     C
04080F 0D          1121*          		DEC     C
040810 3E 02       1122*          		LD      A,2
040812 D5          1123*          		PUSH    DE
040813 CA 98 08 04 1124*          		JP      Z,ACS1
040817 D1          1125*          		POP     DE
040818 CD 2E 07 04 1126*          		CALL    RDIV
04081C 18 04       1127*          		JR      ATN0
04081E             1128*  ;
04081E             1129*  ;ATN - arc-tangent
04081E             1130*  ;Result is floating-point numeric.
04081E             1131*  ;
04081E CD F6 0B 04 1132*  ATN_FP:			CALL    SFLOAT_FP
040822 E5          1133*  ATN0:			PUSH    HL              ;SAVE SIGN
040823 CB BC       1134*          		RES     7,H
040825 11 13 54 00 1135*          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
040829 D9          1136*          		EXX
04082A 11 D0 CC 00 1137*          		LD      DE,0CCD0H
04082E D9          1138*          		EXX
04082F 06 7E       1139*          		LD      B,7EH
040831 CD 83 0C 04 1140*          		CALL    FCP0            ;COMPARE
040835 06 00       1141*          		LD      B,0
040837 38 22       1142*          		JR      C,ATN2
040839 11 82 1A 00 1143*          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
04083D D9          1144*          		EXX
04083E 11 9A 79 00 1145*          		LD      DE,799AH
040842 D9          1146*          		EXX
040843 06 81       1147*          		LD      B,81H
040845 CD 83 0C 04 1148*          		CALL    FCP0            ;COMPARE
040849 38 0A       1149*          		JR      C,ATN1
04084B CD 2A 07 04 1150*          		CALL    RECIP           ;X=1/X
04084F 06 02       1151*          		LD      B,2
040851 C3 5B 08 04 1152*          		JP      ATN2
040855 CD 18 0D 04 1153*  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
040859 06 01       1154*          		LD      B,1
04085B C5          1155*  ATN2:			PUSH    BC              ;SAVE FLAG
04085C CD 03 0D 04 1156*          		CALL    PUSH5
040860 CD FB 0C 04 1157*          		CALL    SQUARE          ;PUSH X*X
040864 CD 40 0D 04 1158*          		CALL    POLY
040868 35 F3       1159*          		DW	0F335H          ;a(13)
04086A D8 37       1160*          		DW	37D8H
04086C 7B          1161*          		DB	7BH
04086D 91 6B       1162*          		DW	6B91H           ;a(11)
04086F B9 AA       1163*          		DW	0AAB9H
040871 7C          1164*          		DB	7CH
040872 DE 41       1165*          		DW	41DEH           ;a(9)
040874 97 61       1166*          		DW	6197H
040876 7C          1167*          		DB	7CH
040877 7B 9D       1168*          		DW	9D7BH           ;a(7)
040879 37 92       1169*          		DW	9237H
04087B 7D          1170*          		DB	7DH
04087C 5A 2A       1171*          		DW	2A5AH           ;a(5)
04087E CC 4C       1172*          		DW	4CCCH
040880 7D          1173*          		DB	7DH
040881 5C A9       1174*          		DW	0A95CH          ;a(3)
040883 AA AA       1175*          		DW	0AAAAH
040885 7E          1176*          		DB	7EH
040886 00 00       1177*          		DW	0               ;a(1)
040888 00 00       1178*          		DW	0
04088A 80          1179*          		DB	80H
04088B CD 0C 0D 04 1180*          		CALL    POP5
04088F CD 0C 0D 04 1181*          		CALL    POP5
040893 CD 5E 03 04 1182*          		CALL    FMUL
040897 F1          1183*          		POP     AF
040898 CD 98 06 04 1184*  ACS1:			CALL    PIBY4           ;PI/4
04089C 1F          1185*          		RRA
04089D F5          1186*          		PUSH    AF
04089E DC 4C 02 04 1187*          		CALL    C,FADD
0408A2 F1          1188*          		POP     AF
0408A3 04          1189*          		INC     B
0408A4 1F          1190*          		RRA
0408A5 DC 39 02 04 1191*          		CALL    C,RSUB
0408A9 F1          1192*          		POP     AF
0408AA B7          1193*          		OR      A
0408AB F0          1194*          		RET     P
0408AC CB FC       1195*          		SET     7,H             ;MAKE NEGATIVE
0408AE AF          1196*          		XOR     A
0408AF C9          1197*          		RET
0408B0             1198*  ;
0408B0             1199*  ;ACS - Arc cosine=PI/2-ASN.
0408B0             1200*  ;Result is floating point numeric.
0408B0             1201*  ;
0408B0 CD EE 07 04 1202*  ACS_FP:			CALL    ASN_FP
0408B4 3E 02       1203*          		LD      A,2
0408B6 F5          1204*          		PUSH    AF
0408B7 18 DF       1205*          		JR      ACS1
0408B9             1206*  ;
0408B9             1207*  ;Function STR - convert numeric value to ASCII string.
0408B9             1208*  ;   Inputs: HLH'L'C = integer or floating-point number
0408B9             1209*  ;           DE = address at which to store string
0408B9             1210*  ;           IX = address of @% format control
0408B9             1211*  ;  Outputs: String stored, with NUL terminator
0408B9             1212*  ;
0408B9             1213*  ;First normalise for decimal output:
0408B9             1214*  ;
0408B9 CD F6 0B 04 1215*  STR_FP:			CALL    SFLOAT_FP
0408BD 06 00       1216*          		LD      B,0             ;DEFAULT PT. POSITION
0408BF CB 7C       1217*          		BIT     7,H             ;NEGATIVE?
0408C1 28 06       1218*          		JR      Z,STR10
0408C3 CB BC       1219*          		RES     7,H
0408C5 3E 2D       1220*          		LD      A,'-'
0408C7 12          1221*          		LD      (DE),A          ;STORE SIGN
0408C8 13          1222*          		INC     DE
0408C9 AF          1223*  STR10:			XOR     A               ;CLEAR A
0408CA B9          1224*          		CP      C
0408CB 28 4E       1225*          		JR      Z,STR02          ;ZERO
0408CD D5          1226*          		PUSH    DE              ;SAVE TEXT POINTER
0408CE 78          1227*          		LD      A,B
0408CF F5          1228*  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0408D0 79          1229*          		LD      A,C             ;BINARY EXPONENT
0408D1 FE A1       1230*          		CP      161
0408D3 30 1C       1231*          		JR      NC,STR14
0408D5 FE 9B       1232*          		CP      155
0408D7 30 29       1233*          		JR      NC,STR15
0408D9 2F          1234*          		CPL
0408DA FE E1       1235*          		CP      225
0408DC 38 02       1236*          		JR      C,STR13
0408DE 3E F8       1237*          		LD      A,-8
0408E0 C6 1C       1238*  STR13:			ADD     A,28
0408E2 CD 6F 0D 04 1239*          		CALL    POWR10
0408E6 F5          1240*          		PUSH    AF
0408E7 CD 5E 03 04 1241*          		CALL    FMUL
0408EB F1          1242*          		POP     AF
0408EC 47          1243*          		LD      B,A
0408ED F1          1244*          		POP     AF
0408EE 90          1245*          		SUB     B
0408EF 18 DE       1246*          		JR      STR11
0408F1 D6 20       1247*  STR14:			SUB     32
0408F3 CD 6F 0D 04 1248*          		CALL    POWR10
0408F7 F5          1249*          		PUSH    AF
0408F8 CD B5 02 04 1250*          		CALL    FDIV
0408FC F1          1251*          		POP     AF
0408FD 47          1252*          		LD      B,A
0408FE F1          1253*          		POP     AF
0408FF 80          1254*          		ADD     A,B
040900 18 CD       1255*          		JR      STR11
040902 3E 09       1256*  STR15:			LD      A,9
040904 CD 6F 0D 04 1257*          		CALL    POWR10          ;10^9
040908 CD 83 0C 04 1258*          		CALL    FCP0
04090C 79          1259*          		LD      A,C
04090D C1          1260*          		POP     BC
04090E 4F          1261*          		LD      C,A
04090F CB FC       1262*          		SET     7,H             ;IMPLIED 1
040911 DC AB 0C 04 1263*          		CALL    C,X10B          ;X10, DEC B
040915 D1          1264*          		POP     DE              ;RESTORE TEXT POINTER
040916 CB B9       1265*          		RES     7,C
040918 3E 00       1266*          		LD      A,0
04091A 17          1267*          		RLA                     ;PUT CARRY IN LSB
04091B             1268*  ;
04091B             1269*  ;At this point decimal normalisation has been done,
04091B             1270*  ;now convert to decimal digits:
04091B             1271*  ;      AHLH'L' = number in normalised integer form
04091B             1272*  ;            B = decimal place adjustment
04091B             1273*  ;            C = binary place adjustment (29-33)
04091B             1274*  ;
04091B 0C          1275*  STR02:			INC     C
04091C 08          1276*          		EX      AF,AF'          ;SAVE A
04091D 78          1277*          		LD      A,B
04091E DD CB 02 4E 1278*          		BIT     1,(IX+2)
040922 20 08       1279*          		JR      NZ,STR20
040924 AF          1280*          		XOR     A
040925 DD BE 01    1281*          		CP      (IX+1)
040928 28 0B       1282*          		JR      Z,STR21
04092A 3E F6       1283*          		LD      A,-10
04092C DD 86 01    1284*  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
04092F B7          1285*          		OR      A               ;CLEAR CARRY
040930 FA 35 09 04 1286*          		JP      M,STR21
040934 AF          1287*          		XOR     A
040935 F5          1288*  STR21:			PUSH    AF
040936 08          1289*          		EX      AF,AF'          ;RESTORE A
040937 CD DF 0C 04 1290*  STR22:			CALL    X2              ;RL AHLH'L'
04093B 8F          1291*          		ADC     A,A
04093C FE 0A       1292*          		CP      10
04093E 38 05       1293*          		JR      C,STR23
040940 D6 0A       1294*          		SUB     10
040942 D9          1295*          		EXX
040943 2C          1296*          		INC     L               ;SET RESULT BIT
040944 D9          1297*          		EXX
040945 0D          1298*  STR23:			DEC     C
040946 20 EF       1299*          		JR      NZ,STR22        ;32 TIMES
040948 4F          1300*          		LD      C,A             ;REMAINDER
040949 7C          1301*          		LD      A,H
04094A E6 3F       1302*          		AND     3FH             ;CLEAR OUT JUNK
04094C 67          1303*          		LD      H,A
04094D F1          1304*          		POP     AF
04094E F2 5C 09 04 1305*          		JP      P,STR24
040952 3C          1306*          		INC     A
040953 20 1C       1307*          		JR      NZ,STR26
040955 3E 04       1308*          		LD      A,4
040957 B9          1309*          		CP      C               ;ROUND UP?
040958 3E 00       1310*          		LD      A,0
04095A 18 15       1311*          		JR      STR26
04095C F5          1312*  STR24:			PUSH    AF
04095D 79          1313*          		LD      A,C
04095E CE 30       1314*          		ADC     A,'0'           ;ADD CARRY
040960 FE 30       1315*          		CP      '0'
040962 28 05       1316*          		JR      Z,STR25         ;SUPPRESS ZERO
040964 FE 3A       1317*          		CP      '9'+1
040966 3F          1318*          		CCF
040967 30 08       1319*          		JR      NC,STR26
040969 E3          1320*  STR25:			EX      (SP),HL
04096A CB 75       1321*          		BIT     6,L             ;ZERO FLAG
04096C E3          1322*  		        EX      (SP),HL
04096D 20 05       1323*          		JR      NZ,STR27
04096F 3E 30       1324*          		LD      A,'0'
040971 3C          1325*  STR26:			INC     A               ;SET +VE
040972 3D          1326*          		DEC     A
040973 F5          1327*          		PUSH    AF              ;PUT ON STACK + CARRY
040974 04          1328*  STR27:			INC     B
040975 CD 4F 0C 04 1329*          		CALL    TEST_FP            ;IS HLH'L' ZERO?
040979 0E 20       1330*          		LD      C,32
04097B 3E 00       1331*          		LD      A,0
04097D 20 B8       1332*          		JR      NZ,STR22
04097F F1          1333*          		POP     AF
040980 F5          1334*          		PUSH    AF
040981 3E 00       1335*          		LD      A,0
040983 38 B2       1336*          		JR      C,STR22
040985             1337*  ;
040985             1338*  ;At this point, the decimal character string is stored
040985             1339*  ; on the stack. Trailing zeroes are suppressed and may
040985             1340*  ; need to be replaced.
040985             1341*  ;B register holds decimal point position.
040985             1342*  ;Now format number and store as ASCII string:
040985             1343*  ;
040985 EB          1344*  STR3:			EX      DE,HL           ;STRING POINTER
040986 0E FF       1345*          		LD      C,-1            ;FLAG "E"
040988 16 01       1346*          		LD      D,1
04098A DD 5E 01    1347*          		LD      E,(IX+1)        ;f2
04098D DD CB 02 46 1348*          		BIT     0,(IX+2)
040991 20 35       1349*          		JR      NZ,STR34        ;E MODE
040993 DD CB 02 4E 1350*          		BIT     1,(IX+2)
040997 28 12       1351*          		JR      Z,STR31
040999 78          1352*          		LD      A,B             ;F MODE
04099A B7          1353*          		OR      A
04099B 28 05       1354*          		JR      Z,STR30
04099D FA A2 09 04 1355*          		JP      M,STR30
0409A1 50          1356*          		LD      D,B
0409A2 7A          1357*  STR30:			LD      A,D
0409A3 DD 86 01    1358*          		ADD     A,(IX+1)
0409A6 5F          1359*          		LD      E,A
0409A7 FE 0B       1360*          		CP      11
0409A9 38 19       1361*          		JR      C,STR32
0409AB 78          1362*  STR31:			LD      A,B             ;G MODE
0409AC 11 01 01 00 1363*          		LD      DE,101H
0409B0 B7          1364*          		OR      A
0409B1 FA C8 09 04 1365*          		JP      M,STR34
0409B5 28 0D       1366*          		JR      Z,STR32
0409B7 DD 7E 01    1367*          		LD      A,(IX+1)
0409BA B7          1368*          		OR      A
0409BB 20 02       1369*          		JR      NZ,STR3A
0409BD 3E 0A       1370*          		LD      A,10
0409BF B8          1371*  STR3A:			CP      B
0409C0 38 06       1372*          		JR      C,STR34
0409C2 50          1373*          		LD      D,B
0409C3 58          1374*          		LD      E,B
0409C4 78          1375*  STR32:			LD      A,B
0409C5 C6 81       1376*          		ADD     A,129
0409C7 4F          1377*          		LD      C,A
0409C8 CB FA       1378*  STR34:			SET     7,D
0409CA 1D          1379*          		DEC     E
0409CB 7A          1380*  STR35:			LD      A,D
0409CC B9          1381*          		CP      C
0409CD 30 0E       1382*          		JR      NC,STR33
0409CF F1          1383*  STR36:			POP     AF
0409D0 28 04       1384*          		JR      Z,STR37
0409D2 F2 DF 09 04 1385*          		JP      P,STR38
0409D6 F5          1386*  STR37:			PUSH    AF
0409D7 1C          1387*          		INC     E
0409D8 1D          1388*          		DEC     E
0409D9 FA F0 09 04 1389*          		JP      M,STR4
0409DD 3E 30       1390*  STR33:			LD      A,'0'
0409DF 15          1391*  STR38:			DEC     D
0409E0 E2 E7 09 04 1392*          		JP      PO,STR39
0409E4 36 2E       1393*          		LD      (HL),'.'
0409E6 23          1394*          		INC     HL
0409E7 77          1395*  STR39:			LD      (HL),A
0409E8 23          1396*          		INC     HL
0409E9 1D          1397*          		DEC     E
0409EA F2 CB 09 04 1398*          		JP      P,STR35
0409EE 18 DF       1399*          		JR      STR36
0409F0             1400*  ;
0409F0 F1          1401*  STR4:			POP     AF
0409F1 0C          1402*  STR40:			INC     C
0409F2 4D          1403*          		LD      C,L
0409F3 20 28       1404*          		JR      NZ,STR44
0409F5 36 45       1405*          		LD      (HL),'E'        ;EXPONENT
0409F7 23          1406*          		INC     HL
0409F8 78          1407*          		LD      A,B
0409F9 3D          1408*          		DEC     A
0409FA F2 03 0A 04 1409*          		JP      P,STR41
0409FE 36 2D       1410*          		LD      (HL),'-'
040A00 23          1411*          		INC     HL
040A01 ED 44       1412*          		NEG
040A03 36 30       1413*  STR41:			LD      (HL),'0'
040A05 28 15       1414*          		JR      Z,STR47
040A07 FE 0A       1415*          		CP      10
040A09 47          1416*          		LD      B,A
040A0A 3E 3A       1417*          		LD      A,':'
040A0C 38 03       1418*          		JR      C,STR42
040A0E 23          1419*          		INC     HL
040A0F 36 30       1420*          		LD      (HL),'0'
040A11 34          1421*  STR42:			INC     (HL)
040A12 BE          1422*          		CP      (HL)
040A13 20 05       1423*          		JR      NZ,STR43
040A15 36 30       1424*          		LD      (HL),'0'
040A17 2B          1425*          		DEC     HL
040A18 34          1426*          		INC     (HL)
040A19 23          1427*          		INC     HL
040A1A 10 F5       1428*  STR43:			DJNZ    STR42
040A1C 23          1429*  STR47:			INC     HL
040A1D EB          1430*  STR44:			EX      DE,HL
040A1E C9          1431*        			RET
040A1F             1432*  ;
040A1F             1433*  ;Support subroutines:
040A1F             1434*  ;
040A1F DD 46 04    1435*  DLOAD5:			LD      B,(IX+4)
040A22 D9          1436*          		EXX
040A23 DD 5E 00    1437*          		LD      E,(IX+0)
040A26 DD 56 01    1438*          		LD      D,(IX+1)
040A29 D9          1439*          		EXX
040A2A DD 5E 02    1440*          		LD      E,(IX+2)
040A2D DD 56 03    1441*          		LD      D,(IX+3)
040A30 C9          1442*          		RET
040A31             1443*  ;
040A31 DD 46 06    1444*  DLOAD5_SPL:		LD      B,(IX+6)
040A34 D9          1445*  			EXX
040A35 DD 17 00    1446*  			LD	DE, (IX+0)
040A38 D9          1447*  			EXX
040A39 DD 17 03    1448*  			LD	DE, (IX+3)
040A3C C9          1449*  			RET
040A3D             1450*  ;
040A3D             1451*  ;CON_FP - Get unsigned numeric constant from ASCII string.
040A3D             1452*  ;   Inputs: ASCII string at (IX).
040A3D             1453*  ;  Outputs: Variable-type result in HLH'L'C
040A3D             1454*  ;           IX updated (points to delimiter)
040A3D             1455*  ;           A7 = 0 (numeric marker)
040A3D             1456*  ;
040A3D CD 73 0C 04 1457*  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
040A41 0E 00       1458*          		LD      C,0             ;TRUNCATION COUNTER
040A43 CD D1 0A 04 1459*          		CALL    UINT          ;GET INTEGER PART
040A47 FE 2E       1460*          		CP      '.'
040A49 06 00       1461*          		LD      B,0             ;DECL. PLACE COUNTER
040A4B CC CF 0A 04 1462*          		CALL    Z,NUMBIX        ;GET FRACTION PART
040A4F FE 45       1463*          		CP      'E'
040A51 3E 00       1464*          		LD      A,0             ;INITIALISE EXPONENT
040A53 CC 9D 0A 04 1465*          		CALL    Z,GETEXP        ;GET EXPONENT
040A57 CB 7C       1466*          		BIT     7,H
040A59 20 08       1467*          		JR      NZ,CON0         ;INTEGER OVERFLOW
040A5B B7          1468*          		OR      A
040A5C 20 05       1469*          		JR      NZ,CON0         ;EXPONENT NON-ZERO
040A5E B8          1470*          		CP      B
040A5F 20 02       1471*          		JR      NZ,CON0         ;DECIMAL POINT
040A61 B9          1472*          		CP      C
040A62 C8          1473*          		RET     Z               ;INTEGER
040A63 90          1474*  CON0:			SUB     B
040A64 81          1475*          		ADD     A,C
040A65 0E 9F       1476*          		LD      C,159
040A67 CD D6 0B 04 1477*          		CALL    FLOAT_
040A6B CB BC       1478*          		RES     7,H             ;DITCH IMPLIED 1
040A6D B7          1479*          		OR      A
040A6E C8          1480*          		RET     Z               ;DONE
040A6F FA 7D 0A 04 1481*          		JP      M,CON2          ;NEGATIVE EXPONENT
040A73 CD 6F 0D 04 1482*          		CALL    POWR10
040A77 CD 5E 03 04 1483*          		CALL    FMUL            ;SCALE
040A7B AF          1484*          		XOR     A
040A7C C9          1485*          		RET
040A7D FE DA       1486*  CON2:			CP      -38
040A7F 38 0C       1487*          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
040A81 ED 44       1488*          		NEG
040A83 CD 6F 0D 04 1489*          		CALL    POWR10
040A87 CD B5 02 04 1490*          		CALL    FDIV            ;SCALE
040A8B AF          1491*          		XOR     A
040A8C C9          1492*          		RET
040A8D F5          1493*  CON3:			PUSH    AF
040A8E 3E 26       1494*          		LD      A,38
040A90 CD 6F 0D 04 1495*          		CALL    POWR10
040A94 CD B5 02 04 1496*          		CALL    FDIV
040A98 F1          1497*          		POP     AF
040A99 C6 26       1498*          		ADD     A,38
040A9B 18 E0       1499*          		JR      CON2
040A9D             1500*  ;
040A9D             1501*  ;GETEXP - Get decimal exponent from string
040A9D             1502*  ;     Inputs: ASCII string at (IX)
040A9D             1503*  ;             (IX points at 'E')
040A9D             1504*  ;             A = initial value
040A9D             1505*  ;    Outputs: A = new exponent
040A9D             1506*  ;             IX updated.
040A9D             1507*  ;   Destroys: A,A',IX,F,F'
040A9D             1508*  ;
040A9D C5          1509*  GETEXP:			PUSH    BC              ;SAVE REGISTERS
040A9E 47          1510*          		LD      B,A             ;INITIAL VALUE
040A9F 0E 02       1511*          		LD      C,2             ;2 DIGITS MAX
040AA1 DD 23       1512*          		INC     IX              ;BUMP PAST 'E'
040AA3 CD 8D 0E 04 1513*          		CALL    SIGNQ
040AA7 08          1514*          		EX      AF,AF'          ;SAVE EXPONENT SIGN
040AA8 CD 83 0E 04 1515*  GETEX1:			CALL    DIGITQ
040AAC 38 18       1516*          		JR      C,GETEX2
040AAE 78          1517*          		LD      A,B             ;B=B*10
040AAF 87          1518*          		ADD     A,A
040AB0 87          1519*          		ADD     A,A
040AB1 80          1520*          		ADD     A,B
040AB2 87          1521*          		ADD     A,A
040AB3 47          1522*          		LD      B,A
040AB4 DD 7E 00    1523*          		LD      A,(IX)          ;GET BACK DIGIT
040AB7 DD 23       1524*          		INC     IX
040AB9 E6 0F       1525*          		AND     0FH             ;MASK UNWANTED BITS
040ABB 80          1526*          		ADD     A,B             ;ADD IN DIGIT
040ABC 47          1527*          		LD      B,A
040ABD 0D          1528*          		DEC     C
040ABE F2 A8 0A 04 1529*          		JP      P,GETEX1
040AC2 06 64       1530*          		LD      B,100           ;FORCE OVERFLOW
040AC4 18 E2       1531*          		JR      GETEX1
040AC6 08          1532*  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
040AC7 FE 2D       1533*          		CP      '-'
040AC9 78          1534*          		LD      A,B
040ACA C1          1535*          		POP     BC              ;RESTORE
040ACB C0          1536*          		RET     NZ
040ACC ED 44       1537*          		NEG                     ;NEGATE EXPONENT
040ACE C9          1538*          		RET
040ACF             1539*  ;
040ACF             1540*  ;UINT: Get unsigned integer from string.
040ACF             1541*  ;    Inputs: string at (IX)
040ACF             1542*  ;            C = truncated digit count
040ACF             1543*  ;                (initially zero)
040ACF             1544*  ;            B = total digit count
040ACF             1545*  ;            HLH'L' = initial value
040ACF             1546*  ;   Outputs: HLH'L' = number (binary integer)
040ACF             1547*  ;            A = delimiter.
040ACF             1548*  ;            B, C & IX updated
040ACF             1549*  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
040ACF             1550*  ;
040ACF DD 23       1551*  NUMBIX:			INC     IX
040AD1 CD 83 0E 04 1552*  UINT:			CALL    DIGITQ
040AD5 D8          1553*          		RET     C
040AD6 04          1554*          		INC     B               ;INCREMENT DIGIT COUNT
040AD7 DD 23       1555*          		INC     IX
040AD9 CD CC 0C 04 1556*          		CALL    X10             ;*10 & COPY OLD VALUE
040ADD 38 15       1557*          		JR      C,NUMB1         ;OVERFLOW
040ADF 0D          1558*          		DEC     C               ;SEE IF TRUNCATED
040AE0 0C          1559*          		INC     C
040AE1 20 11       1560*          		JR      NZ,NUMB1        ;IMPORTANT!
040AE3 E6 0F       1561*          		AND     0FH
040AE5 D9          1562*          		EXX
040AE6 06 00       1563*          		LD      B,0
040AE8 4F          1564*          		LD      C,A
040AE9 52 09       1565*          		ADD.S   HL,BC           ;ADD IN DIGIT
040AEB D9          1566*          		EXX
040AEC 30 E3       1567*          		JR      NC,UINT
040AEE 52 23       1568*          		INC.S   HL              ;CARRY
040AF0 7C          1569*          		LD      A,H
040AF1 B5          1570*          		OR      L
040AF2 20 DD       1571*          		JR      NZ,UINT
040AF4 0C          1572*  NUMB1:			INC     C               ;TRUNCATION COUNTER
040AF5 CD 2A 0C 04 1573*          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
040AF9 18 D6       1574*          		JR      UINT
040AFB             1575*  ;
040AFB             1576*  ;FIX - Fix number to specified exponent value.
040AFB             1577*  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
040AFB             1578*  ;            A = desired exponent (A>C)
040AFB             1579*  ;   Outputs: HLH'L'C = fixed number (unsigned)
040AFB             1580*  ;            fraction shifted into B'C'
040AFB             1581*  ;            A'F' positive if integer input
040AFB             1582*  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
040AFB             1583*  ;
040AFB 08          1584*  FIX:			EX      AF,AF'
040AFC AF          1585*          		XOR     A
040AFD 08          1586*          		EX      AF,AF'
040AFE CB FC       1587*          		SET     7,H             ;IMPLIED 1
040B00 CD 2F 0C 04 1588*  FIX1:			CALL    DIV2
040B04 B9          1589*          		CP      C
040B05 C8          1590*          		RET     Z
040B06 D2 00 0B 04 1591*          		JP      NC,FIX1
040B0A C3 3E 0C 04 1592*          		JP      OFLOW
040B0E             1593*  ;
040B0E             1594*  ;SFIX - Convert to integer if necessary.
040B0E             1595*  ;    Input: Variable-type number in HLH'L'C
040B0E             1596*  ;   Output: Integer in HLH'L', C=0
040B0E             1597*  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
040B0E             1598*  ;
040B0E             1599*  ;NEGATE - Negate HLH'L'
040B0E             1600*  ;    Destroys: H,L,H',L',F
040B0E             1601*  ;
040B0E CD 27 0C 04 1602*  FIX2:			CALL    SWAP_FP
040B12 CD 1A 0B 04 1603*          		CALL    SFIX_FP
040B16 CD 27 0C 04 1604*          		CALL    SWAP_FP
040B1A 0D          1605*  SFIX_FP:			DEC     C
040B1B 0C          1606*          		INC     C
040B1C C8          1607*          		RET     Z               ;INTEGER/ZERO
040B1D CB 7C       1608*          		BIT     7,H             ;SIGN
040B1F F5          1609*          		PUSH    AF
040B20 3E 9F       1610*          		LD      A,159
040B22 CD FB 0A 04 1611*          		CALL    FIX
040B26 F1          1612*          		POP     AF
040B27 0E 00       1613*          		LD      C,0
040B29 C8          1614*          		RET     Z
040B2A B7          1615*  NEGATE:			OR      A               ;CLEAR CARRY
040B2B D9          1616*          		EXX
040B2C D5          1617*  NEG0:			PUSH    DE
040B2D EB          1618*          		EX      DE,HL
040B2E 21 00 00 00 1619*          		LD      HL,0
040B32 52 ED 52    1620*          		SBC.S   HL,DE
040B35 D1          1621*          		POP     DE
040B36 D9          1622*          		EXX
040B37 D5          1623*          		PUSH    DE
040B38 EB          1624*          		EX      DE,HL
040B39 21 00 00 00 1625*          		LD      HL,0
040B3D 52 ED 52    1626*          		SBC.S   HL,DE
040B40 D1          1627*          		POP     DE
040B41 C9          1628*          		RET
040B42             1629*  ;
040B42             1630*  ;NEG - Negate HLH'L'B'C'
040B42             1631*  ;    Also complements A (used in FADD)
040B42             1632*  ;    Destroys: A,H,L,B',C',H',L',F
040B42             1633*  ;
040B42 D9          1634*  NEG_:			EXX
040B43 2F          1635*          		CPL
040B44 E5          1636*          		PUSH    HL
040B45 B7          1637*          		OR      A               ;CLEAR CARRY
040B46 21 00 00 00 1638*          		LD      HL,0
040B4A 52 ED 42    1639*          		SBC.S   HL,BC
040B4D 44          1640*          		LD      B,H
040B4E 4D          1641*          		LD      C,L
040B4F E1          1642*          		POP     HL
040B50 18 DA       1643*          		JR      NEG0
040B52             1644*  ;
040B52             1645*  ;SCALE - Trig scaling.
040B52             1646*  ;MOD48 - 48-bit floating-point "modulus" (remainder).
040B52             1647*  ;   Inputs: HLH'L'C unsigned floating-point dividend
040B52             1648*  ;           DED'E'B'C'B unsigned 48-bit FP divisor
040B52             1649*  ;  Outputs: HLH'L'C floating point remainder (H7=1)
040B52             1650*  ;           E = quotient (bit 7 is sticky)
040B52             1651*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
040B52             1652*  ;FLO48 - Float unsigned number (48 bits)
040B52             1653*  ;    Input/output in HLH'L'B'C'C
040B52             1654*  ;   Destroys: C,H,L,B',C',H',L',F
040B52             1655*  ;
040B52 3E 96       1656*  SCALE:			LD      A,150
040B54 B9          1657*          		CP      C
040B55 3E 17       1658*          		LD      A,ACLOST
040B57 DA CD 00 04 1659*          		JP      C,ERROR_FP_         ;"Accuracy lost"
040B5B CD 98 06 04 1660*          		CALL    PIBY4
040B5F D9          1661*          		EXX
040B60 01 69 21 00 1662*          		LD      BC,2169H        ;3.141592653589793238
040B64 D9          1663*          		EXX
040B65 CB FA       1664*  MOD48:			SET     7,D             ;IMPLIED 1
040B67 CB FC       1665*          		SET     7,H
040B69 79          1666*          		LD      A,C
040B6A 0E 00       1667*          		LD      C,0             ;INIT QUOTIENT
040B6C DD 21 00 00 1668*          		LD      IX,0
       00          
040B71 DD E5       1669*          		PUSH    IX              ;PUT ZERO ON STACK
040B73 B8          1670*          		CP      B
040B74 38 46       1671*          		JR      C,MOD485        ;DIVIDEND<DIVISOR
040B76 D9          1672*  MOD481:			EXX                     ;CARRY=0 HERE
040B77 E3          1673*          		EX      (SP),HL
040B78 52 ED 42    1674*          		SBC.S   HL,BC
040B7B E3          1675*          		EX      (SP),HL
040B7C 52 ED 52    1676*          		SBC.S   HL,DE
040B7F D9          1677*          		EXX
040B80 52 ED 52    1678*          		SBC.S   HL,DE
040B83 30 0C       1679*          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
040B85 D9          1680*          		EXX
040B86 E3          1681*          		EX      (SP),HL
040B87 52 09       1682*          		ADD.S   HL,BC
040B89 E3          1683*          		EX      (SP),HL
040B8A 52 ED 5A    1684*          		ADC.S   HL,DE
040B8D D9          1685*          		EXX
040B8E 52 ED 5A    1686*          		ADC.S   HL,DE
040B91 3F          1687*  MOD482:			CCF
040B92 CB 11       1688*          		RL      C               ;QUOTIENT
040B94 30 02       1689*          		JR      NC,MOD483
040B96 CB F9       1690*          		SET     7,C             ;STICKY BIT
040B98 3D          1691*  MOD483:			DEC     A
040B99 B8          1692*          		CP      B
040B9A 38 1F       1693*          		JR      C,MOD484        ;DIVIDEND<DIVISOR
040B9C E3          1694*          		EX      (SP),HL
040B9D 52 29       1695*          		ADD.S   HL,HL           ;DIVIDEND * 2
040B9F E3          1696*          		EX      (SP),HL
040BA0 D9          1697*          		EXX
040BA1 52 ED 6A    1698*          		ADC.S   HL,HL
040BA4 D9          1699*          		EXX
040BA5 52 ED 6A    1700*          		ADC.S   HL,HL
040BA8 30 CC       1701*          		JR      NC,MOD481       ;AGAIN
040BAA B7          1702*          		OR      A
040BAB D9          1703*          		EXX
040BAC E3          1704*          		EX      (SP),HL
040BAD 52 ED 42    1705*          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
040BB0 E3          1706*          		EX      (SP),HL
040BB1 52 ED 52    1707*          		SBC.S   HL,DE
040BB4 D9          1708*          		EXX
040BB5 52 ED 52    1709*          		SBC.S   HL,DE
040BB8 B7          1710*          		OR      A
040BB9 18 D6       1711*          		JR      MOD482
040BBB             1712*  ;
040BBB 3C          1713*  MOD484:			INC     A
040BBC 59          1714*  MOD485:			LD      E,C             ;QUOTIENT
040BBD 4F          1715*          		LD      C,A             ;REMAINDER EXPONENT
040BBE D9          1716*          		EXX
040BBF C1          1717*          		POP     BC
040BC0 D9          1718*          		EXX
040BC1 CB 7C       1719*  FLO48:			BIT     7,H
040BC3 C0          1720*          		RET     NZ
040BC4 D9          1721*          		EXX
040BC5 CB 21       1722*          		SLA     C
040BC7 CB 10       1723*          		RL      B
040BC9 52 ED 6A    1724*          		ADC.S   HL,HL
040BCC D9          1725*          		EXX
040BCD 52 ED 6A    1726*          		ADC.S   HL,HL
040BD0 0D          1727*          		DEC     C
040BD1 C2 C1 0B 04 1728*          		JP      NZ,FLO48
040BD5 C9          1729*          		RET
040BD6             1730*  ;
040BD6             1731*  ;Float unsigned number
040BD6             1732*  ;    Input/output in HLH'L'C
040BD6             1733*  ;   Destroys: C,H,L,H',L',F
040BD6             1734*  ;
040BD6 CB 7C       1735*  FLOAT_:			BIT     7,H
040BD8 C0          1736*          		RET     NZ
040BD9 D9          1737*          		EXX                     ;SAME AS "X2"
040BDA 52 29       1738*          		ADD.S   HL,HL           ;TIME-CRITICAL
040BDC D9          1739*          		EXX                     ;REGION
040BDD 52 ED 6A    1740*          		ADC.S   HL,HL           ;(BENCHMARKS)
040BE0 0D          1741*          		DEC     C
040BE1 C2 D6 0B 04 1742*          		JP      NZ,FLOAT_
040BE5 C9          1743*          		RET
040BE6             1744*  ;
040BE6             1745*  ;SFLOAT - Convert to floating-point if necessary.
040BE6             1746*  ;    Input: Variable-type number in HLH'L'C
040BE6             1747*  ;    Output: Floating-point in HLH'L'C
040BE6             1748*  ;    Destroys: A,C,H,L,H',L',F
040BE6             1749*  ;
040BE6 08          1750*  FLOATA:			EX      AF,AF'
040BE7             1751*          		; ADD     A,(RTABLE-DTABLE)/3
040BE7 C6 2A       1752*          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
040BE9 08          1753*          		EX      AF,AF'
040BEA CD 27 0C 04 1754*  FLOAT2:			CALL    SWAP_FP
040BEE CD F6 0B 04 1755*          		CALL    SFLOAT_FP
040BF2 CD 27 0C 04 1756*          		CALL    SWAP_FP
040BF6 0D          1757*  SFLOAT_FP:			DEC     C
040BF7 0C          1758*          		INC     C
040BF8 C0          1759*          		RET     NZ              ;ALREADY FLOATING-POINT
040BF9 CD 4F 0C 04 1760*          		CALL    TEST_FP
040BFD C8          1761*          		RET     Z               ;ZERO
040BFE 7C          1762*          		LD      A,H
040BFF B7          1763*          		OR      A
040C00 FC 2A 0B 04 1764*          		CALL    M,NEGATE
040C04 0E 9F       1765*          		LD      C,159
040C06 CD D6 0B 04 1766*          		CALL    FLOAT_
040C0A B7          1767*          		OR      A
040C0B F8          1768*          		RET     M               ;NEGATIVE
040C0C CB BC       1769*          		RES     7,H
040C0E C9          1770*          		RET
040C0F             1771*  ;
040C0F             1772*  ;ROUND UP
040C0F             1773*  ;Return with carry set if 32-bit overflow
040C0F             1774*  ;   Destroys: H,L,B',C',H',L',F
040C0F             1775*  ;
040C0F D9          1776*  ADD1_FP:			EXX
040C10 01 01 00 00 1777*          		LD      BC,1
040C14 52 09       1778*          		ADD.S   HL,BC
040C16 D9          1779*          		EXX
040C17 D0          1780*          		RET     NC
040C18 C5          1781*          		PUSH    BC
040C19 01 01 00 00 1782*          		LD      BC,1
040C1D 52 09       1783*          		ADD.S   HL,BC
040C1F C1          1784*          		POP     BC
040C20 C9          1785*          		RET
040C21             1786*  ;
040C21             1787*  ;ODD - Add one if even, leave alone if odd.
040C21             1788*  ; (Used to perform unbiassed rounding, i.e.
040C21             1789*  ;  number is rounded up half the time)
040C21             1790*  ;    Destroys: L',F (carry cleared)
040C21             1791*  ;
040C21 B7          1792*  ODD:			OR      A               ;CLEAR CARRY
040C22 D9          1793*          		EXX
040C23 CB C5       1794*          		SET     0,L             ;MAKE ODD
040C25 D9          1795*          		EXX
040C26 C9          1796*          		RET
040C27             1797*  ;
040C27             1798*  ;SWAP_FP - Swap arguments.
040C27             1799*  ;    Exchanges DE,HL D'E',H'L' and B,C
040C27             1800*  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
040C27             1801*  ;SWAP1 - Swap DEHL with D'E'H'L'
040C27             1802*  ;    Destroys: D,E,H,L,D',E',H',L'
040C27             1803*  ;
040C27 79          1804*  SWAP_FP:			LD      A,C
040C28 48          1805*          		LD      C,B
040C29 47          1806*          		LD      B,A
040C2A EB          1807*  SWAP1:			EX      DE,HL
040C2B D9          1808*          		EXX
040C2C EB          1809*          		EX      DE,HL
040C2D D9          1810*          		EXX
040C2E C9          1811*          		RET
040C2F             1812*  ;
040C2F             1813*  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
040C2F             1814*  ; INCC - destroys C,F
040C2F             1815*  ; OFLOW
040C2F             1816*  ;
040C2F CD E8 0C 04 1817*  DIV2:			CALL    D2
040C33 D9          1818*          		EXX
040C34 CB 18       1819*          		RR      B
040C36 CB 19       1820*          		RR      C
040C38 08          1821*          		EX      AF,AF'
040C39 B0          1822*          		OR      B
040C3A 08          1823*          		EX      AF,AF'
040C3B D9          1824*          		EXX
040C3C 0C          1825*  INCC:			INC     C
040C3D C0          1826*          		RET     NZ
040C3E 3E 14       1827*  OFLOW:			LD      A,TOOBIG_FP
040C40 C3 CD 00 04 1828*          		JP      ERROR_FP_           ;"Too big"
040C44             1829*  ;
040C44             1830*  ; FTEST - Test for zero & sign
040C44             1831*  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
040C44             1832*  ;
040C44 CD 4F 0C 04 1833*  FTEST_FP:			CALL    TEST_FP
040C48 C8          1834*          		RET     Z
040C49 7C          1835*          		LD      A,H
040C4A E6 80       1836*          		AND     10000000B
040C4C F6 40       1837*          		OR      01000000B
040C4E C9          1838*          		RET
040C4F             1839*  ;
040C4F             1840*  ; TEST_FP - Test HLH'L' for zero.
040C4F             1841*  ;     Output: Z-flag set & A=0 if HLH'L'=0
040C4F             1842*  ;     Destroys: A,F
040C4F             1843*  ;
040C4F 7C          1844*  TEST_FP:			LD      A,H
040C50 B5          1845*          		OR      L
040C51 D9          1846*          		EXX
040C52 B4          1847*          		OR      H
040C53 B5          1848*          		OR      L
040C54 D9          1849*          		EXX
040C55 C9          1850*          		RET
040C56             1851*  ;
040C56             1852*  ; FCOMP - Compare two numbers
040C56             1853*  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
040C56             1854*  ;
040C56 78          1855*  FCOMP_FP:			LD      A,B
040C57 B1          1856*          		OR      C               ;Both integer?
040C58 20 0B       1857*          		JR      NZ,FCOMP1
040C5A CD 6F 0C 04 1858*          		CALL    ICP
040C5E 3E 00       1859*  FCOMP0:			LD      A,0
040C60 C8          1860*          		RET     Z               ;Equal
040C61 3E 80       1861*          		LD      A,80H
040C63 1F          1862*          		RRA
040C64 C9          1863*          		RET
040C65             1864*  ;
040C65 CD EA 0B 04 1865*  FCOMP1:			CALL    FLOAT2          ;Float both
040C69 CD 7D 0C 04 1866*          		CALL    FCP
040C6D 18 EF       1867*          		JR      FCOMP0
040C6F             1868*  ;
040C6F             1869*  ; Integer and floating point compare.
040C6F             1870*  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
040C6F             1871*  ; Result pre-set to FALSE
040C6F             1872*  ; ICP1, FCP1 destroy A,F
040C6F             1873*  ;
040C6F             1874*  ; ZERO - Return zero.
040C6F             1875*  ;  Destroys: A,C,H,L,H',L'
040C6F             1876*  ;
040C6F CD A2 0C 04 1877*  ICP:			CALL    ICP1
040C73 3E 00       1878*  ZERO_FP:			LD      A,0
040C75 D9          1879*          		EXX
040C76 67          1880*          		LD      H,A
040C77 6F          1881*  	       		LD      L,A
040C78 D9          1882*          		EXX
040C79 67          1883*        			LD      H,A
040C7A 6F          1884*       			LD      L,A
040C7B 4F          1885*  	    		LD      C,A
040C7C C9          1886*          		RET
040C7D             1887*  ;
040C7D CD 94 0C 04 1888*  FCP:			CALL    FCP1
040C81 18 F0       1889*          		JR      ZERO_FP            ;PRESET FALSE
040C83             1890*  ;
040C83 79          1891*  FCP0:			LD      A,C
040C84 B8          1892*          		CP      B               ;COMPARE EXPONENTS
040C85 C0          1893*          		RET     NZ
040C86             1894*  ICP0:
040C86 52 ED 52    1895*  			SBC.S   HL,DE           ;COMP MANTISSA MSB
040C89 52 19       1896*          		ADD.S   HL,DE
040C8B C0          1897*          		RET     NZ
040C8C D9          1898*          		EXX
040C8D 52 ED 52    1899*          		SBC.S   HL,DE           ;COMP MANTISSA LSB
040C90 52 19       1900*          		ADD.S   HL,DE
040C92 D9          1901*          		EXX
040C93 C9          1902*          		RET
040C94             1903*  ;
040C94 7C          1904*  FCP1:			LD      A,H
040C95 AA          1905*          		XOR     D
040C96 7C          1906*          		LD      A,H
040C97 17          1907*          		RLA
040C98 F8          1908*          		RET     M
040C99 30 E8       1909*          		JR      NC,FCP0
040C9B CD 83 0C 04 1910*          		CALL    FCP0
040C9F C8          1911*          		RET     Z               ;** V0.1 BUG FIX
040CA0 3F          1912*          		CCF
040CA1 C9          1913*          		RET
040CA2             1914*  ;
040CA2 7C          1915*  ICP1:			LD      A,H
040CA3 AA          1916*          		XOR     D
040CA4 F2 86 0C 04 1917*          		JP      P,ICP0
040CA8 7C          1918*          		LD      A,H
040CA9 17          1919*          		RLA
040CAA C9          1920*          		RET
040CAB             1921*  ;
040CAB             1922*  ; ADD - Integer add.
040CAB             1923*  ; Carry, sign & zero flags valid on exit
040CAB             1924*  ;     Destroys: H,L,H',L',F
040CAB             1925*  ;
040CAB 05          1926*  X10B:			DEC     B
040CAC 0C          1927*          		INC     C
040CAD CD F4 0C 04 1928*  X5:			CALL    COPY0
040CB1 CD E7 0C 04 1929*          		CALL    D2C
040CB5 CD E7 0C 04 1930*          		CALL    D2C
040CB9 08          1931*          		EX      AF,AF'          ;SAVE CARRY
040CBA D9          1932*  ADD_:			EXX
040CBB 52 19       1933*          		ADD.S   HL,DE
040CBD D9          1934*          		EXX
040CBE 52 ED 5A    1935*          		ADC.S   HL,DE
040CC1 C9          1936*          		RET
040CC2             1937*  ;
040CC2             1938*  ; SUB - Integer subtract.
040CC2             1939*  ; Carry, sign & zero flags valid on exit
040CC2             1940*  ;     Destroys: H,L,H',L',F
040CC2             1941*  ;
040CC2 D9          1942*  SUB_:			EXX
040CC3 B7          1943*          		OR      A
040CC4 52 ED 52    1944*          		SBC.S   HL,DE
040CC7 D9          1945*          		EXX
040CC8 52 ED 52    1946*          		SBC.S   HL,DE
040CCB C9          1947*          		RET
040CCC             1948*  ;
040CCC             1949*  ; X10 - unsigned integer * 10
040CCC             1950*  ;    Inputs: HLH'L' initial value
040CCC             1951*  ;   Outputs: DED'E' = initial HLH'L'
040CCC             1952*  ;            Carry bit set if overflow
040CCC             1953*  ;            If carry not set HLH'L'=result
040CCC             1954*  ;  Destroys: D,E,H,L,D',E',H',L',F
040CCC             1955*  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
040CCC             1956*  ;     Carry set if MSB=1 before shift.
040CCC             1957*  ;     Sign set if MSB=1 after shift.
040CCC             1958*  ;     Destroys: H,L,H',L',F
040CCC             1959*  ;
040CCC CD F4 0C 04 1960*  X10:			CALL    COPY0           ;DED'E'=HLH'L'
040CD0 CD DF 0C 04 1961*          		CALL    X2
040CD4 D8          1962*          		RET     C               ;TOO BIG
040CD5 CD DF 0C 04 1963*          		CALL    X2
040CD9 D8          1964*          		RET     C
040CDA CD BA 0C 04 1965*          		CALL    ADD_
040CDE D8          1966*          		RET     C
040CDF D9          1967*  X2:			EXX
040CE0 52 29       1968*          		ADD.S   HL,HL
040CE2 D9          1969*          		EXX
040CE3 52 ED 6A    1970*          		ADC.S   HL,HL
040CE6 C9          1971*          		RET
040CE7             1972*  ;
040CE7             1973*  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
040CE7             1974*  ;     Carry set if LSB=1 before shift.
040CE7             1975*  ;     Destroys: H,L,H',L',F
040CE7             1976*  ;
040CE7 0C          1977*  D2C:			INC     C
040CE8 CB 3C       1978*  D2:			SRL     H
040CEA CB 1D       1979*          		RR      L
040CEC D9          1980*          		EXX
040CED CB 1C       1981*          		RR      H
040CEF CB 1D       1982*          		RR      L
040CF1 D9          1983*          		EXX
040CF2 C9          1984*          		RET
040CF3             1985*  ;
040CF3             1986*  ; COPY - COPY HLH'L'C INTO DED'E'B
040CF3             1987*  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
040CF3             1988*  ;
040CF3 41          1989*  COPY_:			LD      B,C
040CF4 54          1990*  COPY0:			LD      D,H
040CF5 5D          1991*          		LD      E,L
040CF6 D9          1992*          		EXX
040CF7 54          1993*          		LD      D,H
040CF8 5D          1994*          		LD      E,L
040CF9 D9          1995*          		EXX
040CFA C9          1996*          		RET
040CFB             1997*  ;
040CFB             1998*  ; SQUARE - PUSH X*X
040CFB             1999*  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
040CFB             2000*  ;   Destroys: SP,IX
040CFB             2001*  ;
040CFB CD F3 0C 04 2002*  SQUARE:			CALL    COPY_
040CFF CD 5E 03 04 2003*          		CALL    FMUL
040D03 DD E1       2004*  PUSH5:			POP     IX              ;RETURN ADDRESS
040D05 C5          2005*          		PUSH    BC
040D06 E5          2006*          		PUSH    HL
040D07 D9          2007*          		EXX
040D08 E5          2008*          		PUSH    HL
040D09 D9          2009*          		EXX
040D0A DD E9       2010*          		JP      (IX)            ;"RETURN"
040D0C             2011*  ;
040D0C             2012*  ; POP5 - POP DED'E'B OFF STACK.
040D0C             2013*  ;   Destroys: A,B,D,E,D',E',SP,IX
040D0C             2014*  ;
040D0C DD E1       2015*  POP5:			POP     IX              ;RETURN ADDRESS
040D0E D9          2016*          		EXX
040D0F D1          2017*          		POP     DE
040D10 D9          2018*          		EXX
040D11 D1          2019*          		POP     DE
040D12 79          2020*          		LD      A,C
040D13 C1          2021*          		POP     BC
040D14 41          2022*          		LD      B,C
040D15 4F          2023*          		LD      C,A
040D16 DD E9       2024*          		JP      (IX)            ;"RETURN"
040D18             2025*  ;
040D18             2026*  ; RATIO - Calculate (X-1)/(X+1)
040D18             2027*  ;     Inputs: X in HLH'L'C
040D18             2028*  ;    Outputs: (X-1)/(X+1) in HLH'L'C
040D18             2029*  ;   Destroys: Everything except IY,SP,I
040D18             2030*  ;
040D18 CD 03 0D 04 2031*  RATIO:			CALL    PUSH5           ;SAVE X
040D1C CD 8B 06 04 2032*          		CALL    DONE
040D20 CD 4C 02 04 2033*          		CALL    FADD
040D24 CD 0C 0D 04 2034*          		CALL    POP5            ;RESTORE X
040D28 CD 03 0D 04 2035*          		CALL    PUSH5           ;SAVE X+1
040D2C CD 27 0C 04 2036*          		CALL    SWAP_FP
040D30 CD 8B 06 04 2037*          		CALL    DONE
040D34 CD 33 02 04 2038*          		CALL    FSUB
040D38 CD 0C 0D 04 2039*          		CALL    POP5            ;RESTORE X+1
040D3C C3 B5 02 04 2040*          		JP      FDIV
040D40             2041*  ;
040D40             2042*  ; POLY - Evaluate a polynomial.
040D40             2043*  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
040D40             2044*  ;             Polynomial coefficients follow call.
040D40             2045*  ;    Outputs: Result in HLH'L'C
040D40             2046*  ;   Destroys: Everything except IY,SP,I
040D40             2047*  ; Routine terminates on finding a coefficient >=1.
040D40             2048*  ; Note: The last coefficient is EXECUTED on return
040D40             2049*  ;       so must contain only innocuous bytes!
040D40             2050*  ;
040D40 DD 21 03 00 2051*  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
040D45 DD 39       2052*          		ADD     IX, SP
040D47 DD E3       2053*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
040D49             2054*  ;
040D49 CD 1F 0A 04 2055*          		CALL    DLOAD5          		; Load the first coefficient from (IX)
040D4D CD 5E 03 04 2056*  POLY1:			CALL    FMUL
040D51 11 05 00 00 2057*          		LD      DE, 5				; Skip to the next coefficient
040D55 DD 19       2058*          		ADD     IX, DE
040D57 CD 1F 0A 04 2059*          		CALL    DLOAD5          		; Load the second coefficient from (IX)
040D5B DD E3       2060*          		EX      (SP), IX			; Restore the SP just in case we need to return
040D5D 04          2061*          		INC     B
040D5E 05          2062*          		DEC     B               		; Test B for end byte (80h)
040D5F FA 4C 02 04 2063*          		JP      M,FADD				; Yes, so add and return
040D63 CD 4C 02 04 2064*          		CALL    FADD				; No, so add
040D67 CD 31 0A 04 2065*          		CALL    DLOAD5_SPL			; Load X from SP
040D6B DD E3       2066*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
040D6D 18 DE       2067*          		JR      POLY1				; And loop
040D6F             2068*  ;
040D6F             2069*  ; POWR10 - Calculate power of ten.
040D6F             2070*  ;     Inputs: A=power of 10 required (A<128)
040D6F             2071*  ;             A=binary exponent to be exceeded (A>=128)
040D6F             2072*  ;    Outputs: DED'E'B = result
040D6F             2073*  ;             A = actual power of ten returned
040D6F             2074*  ;   Destroys: A,B,D,E,A',D',E',F,F'
040D6F             2075*  ;
040D6F 3C          2076*  POWR10:			INC     A
040D70 08          2077*          		EX      AF,AF'
040D71 E5          2078*          		PUSH    HL
040D72 D9          2079*          		EXX
040D73 E5          2080*          		PUSH    HL
040D74 D9          2081*          		EXX
040D75 CD 8B 06 04 2082*          		CALL    DONE
040D79 CD 27 0C 04 2083*          		CALL    SWAP_FP
040D7D AF          2084*          		XOR     A
040D7E 08          2085*  POWR11:			EX      AF,AF'
040D7F 3D          2086*          		DEC     A
040D80 28 26       2087*          		JR      Z,POWR14        ;EXIT TYPE 1
040D82 F2 8A 0D 04 2088*          		JP      P,POWR13
040D86 B9          2089*          		CP      C
040D87 38 1F       2090*          		JR      C,POWR14        ;EXIT TYPE 2
040D89 3C          2091*          		INC     A
040D8A 08          2092*  POWR13:			EX      AF,AF'
040D8B 3C          2093*          		INC     A
040D8C CB FC       2094*          		SET     7,H
040D8E CD AD 0C 04 2095*          		CALL    X5
040D92 30 06       2096*          		JR      NC,POWR12
040D94 08          2097*          		EX      AF,AF'
040D95 CD E7 0C 04 2098*          		CALL    D2C
040D99 08          2099*          		EX      AF,AF'
040D9A 08          2100*  POWR12:			EX      AF,AF'
040D9B DC 0F 0C 04 2101*          		CALL    C,ADD1_FP          ;ROUND UP
040D9F 0C          2102*          		INC     C
040DA0 FA 7E 0D 04 2103*          		JP      M,POWR11
040DA4 C3 3E 0C 04 2104*          		JP      OFLOW
040DA8 CD 27 0C 04 2105*  POWR14:			CALL    SWAP_FP
040DAC CB BA       2106*          		RES     7,D
040DAE D9          2107*          		EXX
040DAF E1          2108*          		POP     HL
040DB0 D9          2109*          		EXX
040DB1 E1          2110*          		POP     HL
040DB2 08          2111*          		EX      AF,AF'
040DB3 C9          2112*          		RET
040DB4             2113*  ;
040DB4             2114*  ; DIVA, DIVB - DIVISION PRIMITIVE.
040DB4             2115*  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
040DB4             2116*  ;               Remainder in H'L'HL
040DB4             2117*  ;     Inputs: A = loop counter (normally -32)
040DB4             2118*  ;     Destroys: A,D,E,H,L,D',E',H',L',F
040DB4             2119*  ;
040DB4 B7          2120*  DIVA:			OR      A               ;CLEAR CARRY
040DB5             2121*  DIV0:
040DB5 52 ED 42    2122*  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
040DB8 D9          2123*          		EXX
040DB9 52 ED 42    2124*          		SBC.S   HL,BC
040DBC D9          2125*          		EXX
040DBD 30 07       2126*          		JR      NC,DIV1
040DBF 52 09       2127*          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
040DC1 D9          2128*          		EXX
040DC2 52 ED 4A    2129*          		ADC.S   HL,BC
040DC5 D9          2130*          		EXX
040DC6 3F          2131*  DIV1:			CCF
040DC7 CB 13       2132*  DIVC:			RL      E               ;SHIFT RESULT INTO DE
040DC9 CB 12       2133*          		RL      D
040DCB D9          2134*          		EXX
040DCC CB 13       2135*          		RL      E
040DCE CB 12       2136*          		RL      D
040DD0 D9          2137*          		EXX
040DD1 3C          2138*          		INC     A
040DD2 F0          2139*          		RET     P
040DD3             2140*  DIVB:
040DD3 52 ED 6A    2141*  			ADC.S   HL,HL           ;DIVIDEND*2
040DD6 D9          2142*          		EXX
040DD7 52 ED 6A    2143*          		ADC.S   HL,HL
040DDA D9          2144*          		EXX
040DDB 30 D8       2145*          		JR      NC,DIV0
040DDD B7          2146*          		OR      A
040DDE 52 ED 42    2147*          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
040DE1 D9          2148*          		EXX
040DE2 52 ED 42    2149*          		SBC.S   HL,BC
040DE5 D9          2150*          		EXX
040DE6 37          2151*          		SCF
040DE7 C3 C7 0D 04 2152*          		JP      DIVC
040DEB             2153*  ;
040DEB             2154*  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
040DEB             2155*  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
040DEB             2156*  ;    Inputs: A = loop counter (usually -32)
040DEB             2157*  ;            H'L'HL = 0
040DEB             2158*  ;    Destroys: D,E,H,L,D',E',H',L',A,F
040DEB             2159*  ;
040DEB B7          2160*  MULA:			OR      A               ;CLEAR CARRY
040DEC D9          2161*  MUL0:			EXX
040DED CB 1A       2162*          		RR      D               ;MULTIPLIER/2
040DEF CB 1B       2163*          		RR      E
040DF1 D9          2164*          		EXX
040DF2 CB 1A       2165*          		RR      D
040DF4 CB 1B       2166*          		RR      E
040DF6 30 07       2167*          		JR      NC,MUL1
040DF8 52 09       2168*          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
040DFA D9          2169*          		EXX
040DFB 52 ED 4A    2170*          		ADC.S   HL,BC
040DFE D9          2171*          		EXX
040DFF 3C          2172*  MUL1:			INC     A
040E00 F0          2173*          		RET     P
040E01 D9          2174*  MULB:			EXX
040E02 CB 1C       2175*          		RR      H               ;PRODUCT/2
040E04 CB 1D       2176*          		RR      L
040E06 D9          2177*          		EXX
040E07 CB 1C       2178*          		RR      H
040E09 CB 1D       2179*          		RR      L
040E0B C3 EC 0D 04 2180*          		JP      MUL0
040E0F             2181*  ;
040E0F             2182*  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
040E0F             2183*  ;     Function: B'C'BC = SQR (D'E'DE)
040E0F             2184*  ;     Inputs: A = loop counter (normally -31)
040E0F             2185*  ;             B'C'BCH'L'HL initialised to 0
040E0F             2186*  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
040E0F             2187*  ;
040E0F             2188*  SQR1:
040E0F 52 ED 42    2189*  			SBC.S   HL,BC
040E12 D9          2190*          		EXX
040E13 52 ED 42    2191*          		SBC.S   HL,BC
040E16 D9          2192*          		EXX
040E17 0C          2193*          		INC     C
040E18 30 09       2194*          		JR      NC,SQR2
040E1A 0D          2195*          		DEC     C
040E1B 52 09       2196*          		ADD.S   HL,BC
040E1D D9          2197*          		EXX
040E1E 52 ED 4A    2198*          		ADC.S   HL,BC
040E21 D9          2199*          		EXX
040E22 0D          2200*          		DEC     C
040E23 3C          2201*  SQR2:			INC     A
040E24 F0          2202*          		RET     P
040E25 CB 21       2203*  SQRA:			SLA     C
040E27 CB 10       2204*          		RL      B
040E29 D9          2205*          		EXX
040E2A CB 11       2206*          		RL      C
040E2C CB 10       2207*          		RL      B
040E2E D9          2208*          		EXX
040E2F 0C          2209*          		INC     C
040E30 CB 23       2210*          		SLA     E
040E32 CB 12       2211*          		RL      D
040E34 D9          2212*          		EXX
040E35 CB 13       2213*          		RL      E
040E37 CB 12       2214*          		RL      D
040E39 D9          2215*          		EXX
040E3A 52 ED 6A    2216*          		ADC.S   HL,HL
040E3D D9          2217*          		EXX
040E3E 52 ED 6A    2218*          		ADC.S   HL,HL
040E41 D9          2219*          		EXX
040E42 CB 23       2220*          		SLA     E
040E44 CB 12       2221*          		RL      D
040E46 D9          2222*          		EXX
040E47 CB 13       2223*          		RL      E
040E49 CB 12       2224*          		RL      D
040E4B D9          2225*          		EXX
040E4C 52 ED 6A    2226*          		ADC.S   HL,HL
040E4F D9          2227*          		EXX
040E50 52 ED 6A    2228*          		ADC.S   HL,HL
040E53 D9          2229*          		EXX
040E54 D2 0F 0E 04 2230*          		JP      NC,SQR1
040E58 B7          2231*  SQR3:			OR      A
040E59 52 ED 42    2232*          		SBC.S   HL,BC
040E5C D9          2233*          		EXX
040E5D 52 ED 42    2234*          		SBC.S   HL,BC
040E60 D9          2235*          		EXX
040E61 0C          2236*          		INC     C
040E62 C3 23 0E 04 2237*          		JP      SQR2
040E66             2238*  ;
040E66             2239*  SQRB:
040E66 52 29       2240*  			ADD.S   HL,HL
040E68 D9          2241*          		EXX
040E69 52 ED 6A    2242*          		ADC.S   HL,HL
040E6C D9          2243*          		EXX
040E6D 38 E9       2244*          		JR      C,SQR3
040E6F 3C          2245*          		INC     A
040E70 0C          2246*          		INC     C
040E71 52 ED 42    2247*          		SBC.S   HL,BC
040E74 D9          2248*          		EXX
040E75 52 ED 42    2249*          		SBC.S   HL,BC
040E78 D9          2250*          		EXX
040E79 D0          2251*          		RET     NC
040E7A 52 09       2252*          		ADD.S   HL,BC
040E7C D9          2253*          		EXX
040E7D 52 ED 4A    2254*          		ADC.S   HL,BC
040E80 D9          2255*          		EXX
040E81 0D          2256*          		DEC     C
040E82 C9          2257*          		RET
040E83             2258*  ;
040E83 DD 7E 00    2259*  DIGITQ:			LD      A,(IX)
040E86 FE 3A       2260*          		CP      '9'+1
040E88 3F          2261*          		CCF
040E89 D8          2262*          		RET     C
040E8A FE 30       2263*          		CP      '0'
040E8C C9          2264*          		RET
040E8D             2265*  ;
040E8D DD 7E 00    2266*  SIGNQ:			LD      A,(IX)
040E90 DD 23       2267*          		INC     IX
040E92 FE 20       2268*          		CP      ' '
040E94 28 F7       2269*          		JR      Z,SIGNQ
040E96 FE 2B       2270*          		CP      '+'
040E98 C8          2271*          		RET     Z
040E99 FE 2D       2272*          		CP      '-'
040E9B C8          2273*          		RET     Z
040E9C DD 2B       2274*          		DEC     IX
040E9E C9          2275*          		RET
040E9F             0055       include "functions.inc"
040E9F             0001*  
040E9F             0002*      MACRO printChar char
040E9F             0003*          LD A, char
040E9F             0004*          RST.LIL 10h
040E9F             0005*      ENDMACRO
040E9F             0006*  
040E9F             0007*  ; test the sign of HL
040E9F             0008*  ; inputs: HL obviously
040E9F             0009*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040E9F             0010*  ; destroys: flags
040E9F             0011*      MACRO sign_hlu
040E9F             0012*          add hl,de
040E9F             0013*          or a
040E9F             0014*          sbc hl,de
040E9F             0015*      ENDMACRO
040E9F             0016*  
040E9F             0017*  ; Simulated call to subroutine at HL
040E9F             0018*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040E9F             0019*  ; outputs: whatever the subroutine does, including HL and BC
040E9F             0020*  ; destroys: only what the subroutine does, but always BC
040E9F             0021*      MACRO callHL
040E9F             0022*          ld bc,$+7     ; Address of first instruction after the jump
040E9F             0023*          push bc       ; which constitutes the return address
040E9F             0024*          jp   (hl)     ; Jump to the address in HL
040E9F             0025*      ENDMACRO
040E9F             0026*  
040E9F             0027*  ; Simulated call to subroutine at IX
040E9F             0028*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040E9F             0029*  ; outputs: whatever the subroutine does, including IX and BC
040E9F             0030*  ; destroys: only what the subroutine does, but always BC
040E9F             0031*      MACRO callIX
040E9F             0032*          ld bc,$+7     ; Address of first instruction after the jump
040E9F             0033*          push bc       ; which constitutes the return address
040E9F             0034*          jp   (ix)     ; Jump to the address in IX
040E9F             0035*      ENDMACRO
040E9F             0036*  
040E9F             0037*  ; Simulated call to soubroutinte at IY
040E9F             0038*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040E9F             0039*  ; outputs: whatever the subroutine does, including IY and BC
040E9F             0040*  ; destroys: only what the subroutine does, but always BC
040E9F             0041*      MACRO callIY
040E9F             0042*          ld bc,$+7     ; Address of first instruction after the jump
040E9F             0043*          push bc       ; which constitutes the return address
040E9F             0044*          jp   (iy)     ; Jump to the address in IY
040E9F             0045*      ENDMACRO
040E9F             0046*  
040E9F             0047*  ; put the value in HLU into the accumulator
040E9F             0048*  ; destroys: af
040E9F             0049*      MACRO HLU_TO_A
040E9F             0050*          push hl ; 4 cycles
040E9F             0051*          inc sp ; 1 cycle
040E9F             0052*          pop af  ; 4 cycles
040E9F             0053*          dec sp ; 1 cycle
040E9F             0054*                 ; 10 cycles total
040E9F             0055*      ENDMACRO
040E9F             0056*  
040E9F             0057*  A_TO_HLU:
040E9F             0058*      ; call is 7 cycles
040E9F 22 AC 0E 04 0059*      ld (@scratch),hl ; 7 cycles
040EA3 32 AE 0E 04 0060*      ld (@scratch+2),a ; 5 cycles
040EA7 2A AC 0E 04 0061*      ld hl,(@scratch) ; 7 cycles
040EAB C9          0062*      ret ; 6 cycles
040EAC             0063*          ; 25 cycles total
040EAC 00 00 00    0064*  @scratch: dl 0
040EAF             0065*  
040EAF             0066*      ; TODO: implement this
040EAF             0067*      ; MACRO A_TO_HLU
040EAF             0068*      ;     push.s af
040EAF             0069*      ;     inc sp
040EAF             0070*      ;     push.s hl
040EAF             0071*      ;     pop hl
040EAF             0072*      ;     inc sp
040EAF             0073*      ;     inc sp
040EAF             0074*      ; ENDMACRO
040EAF             0075*  
040EAF             0076*      MACRO PUSH_ALL
040EAF             0077*          ex af,af'
040EAF             0078*          exx
040EAF             0079*          push af
040EAF             0080*          push hl
040EAF             0081*          push bc
040EAF             0082*          push de
040EAF             0083*  
040EAF             0084*          ex af,af'
040EAF             0085*          exx
040EAF             0086*          push af
040EAF             0087*          push hl
040EAF             0088*          push bc
040EAF             0089*          push de
040EAF             0090*          push ix
040EAF             0091*          push iy
040EAF             0092*      ENDMACRO
040EAF             0093*  
040EAF             0094*      MACRO POP_ALL
040EAF             0095*          pop iy
040EAF             0096*          pop ix
040EAF             0097*          pop de
040EAF             0098*          pop bc
040EAF             0099*          pop hl
040EAF             0100*          pop af
040EAF             0101*          ex af,af'
040EAF             0102*          exx
040EAF             0103*  
040EAF             0104*          pop de
040EAF             0105*          pop bc
040EAF             0106*          pop hl
040EAF             0107*          pop af
040EAF             0108*          ex af,af'
040EAF             0109*          exx
040EAF             0110*      ENDMACRO
040EAF             0111*  
040EAF             0112*  ; Print a zero-terminated string inline with code, e.g.:
040EAF             0113*  ;
040EAF             0114*  ;    call printInline
040EAF             0115*  ;    ASCIZ "Hello, world!\r\n"
040EAF             0116*  ;
040EAF             0117*  ; Destroys: HL,AF
040EAF             0118*  printInline:
040EAF E1          0119*      pop hl ; get the return address = pointer to start of string
040EB0 CD B6 0E 04 0120*      call printString ; HL advances to end of string
040EB4 E5          0121*      push hl ; restore the return address = pointer to end of string
040EB5 C9          0122*      ret
040EB6             0123*  
040EB6             0124*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040EB6             0125*  ; Print a zero-terminated string
040EB6             0126*  ; HL: Pointer to string
040EB6             0127*  printString:
040EB6 C5          0128*  	PUSH	BC
040EB7 01 00 00 00 0129*  	LD		BC,0
040EBB 3E 00       0130*  	LD 	 	A,0
040EBD 5B DF       0131*  	RST.LIL 18h
040EBF C1          0132*  	POP		BC
040EC0 C9          0133*  	RET
040EC1             0134*  ; print a VDU sequence
040EC1             0135*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040EC1             0136*  sendVDUsequence:
040EC1 C5          0137*  	PUSH	BC
040EC2 01 00 00 00 0138*  	LD		BC, 0
040EC6 4E          0139*  	LD		C, (HL)
040EC7 5B DF       0140*  	RST.LIL	18h
040EC9 C1          0141*  	POP		BC
040ECA C9          0142*  	RET
040ECB             0143*  ; Print Newline sequence to VDP
040ECB             0144*  printNewLine:
040ECB F5          0145*      push af ; for some reason rst.lil 10h sets carry flag
040ECC 3E 0D       0146*  	LD	A, '\r'
040ECE 5B D7       0147*  	RST.LIL 10h
040ED0 3E 0A       0148*  	LD	A, '\n'
040ED2 5B D7       0149*  	RST.LIL 10h
040ED4 F1          0150*      pop af
040ED5 C9          0151*  	RET
040ED6             0152*  
040ED6             0153*  ; Print a 24-bit HEX number
040ED6             0154*  ; HLU: Number to print
040ED6             0155*  printHex24:
040ED6             0156*      HLU_TO_A
040ED6 E5          0001*M         push hl ; 4 cycles
040ED7 33          0002*M         inc sp ; 1 cycle
040ED8 F1          0003*M         pop af  ; 4 cycles
040ED9 3B          0004*M         dec sp ; 1 cycle
040EDA             0005*M                ; 10 cycles total
040EDA CD E4 0E 04 0157*  	CALL	printHex8
040EDE             0158*  ; Print a 16-bit HEX number
040EDE             0159*  ; HL: Number to print
040EDE             0160*  printHex16:
040EDE 7C          0161*  	LD		A,H
040EDF CD E4 0E 04 0162*  	CALL	printHex8
040EE3 7D          0163*  	LD		A,L
040EE4             0164*  ; Print an 8-bit HEX number
040EE4             0165*  ; A: Number to print
040EE4             0166*  printHex8:
040EE4 4F          0167*  	LD		C,A
040EE5 1F          0168*  	RRA
040EE6 1F          0169*  	RRA
040EE7 1F          0170*  	RRA
040EE8 1F          0171*  	RRA
040EE9 CD EE 0E 04 0172*  	CALL	@F
040EED 79          0173*  	LD		A,C
040EEE             0174*  @@:
040EEE E6 0F       0175*  	AND		0Fh
040EF0 C6 90       0176*  	ADD		A,90h
040EF2 27          0177*  	DAA
040EF3 CE 40       0178*  	ADC		A,40h
040EF5 27          0179*  	DAA
040EF6 5B D7       0180*  	RST.LIL	10h
040EF8 C9          0181*  	RET
040EF9             0182*  
040EF9             0183*  printHexA:
040EF9 F5          0184*      push af
040EFA C5          0185*      push bc
040EFB CD E4 0E 04 0186*      call printHex8
040EFF 3E 20       0187*      ld a,' '
040F01 5B D7       0188*      rst.lil 10h
040F03 C1          0189*      pop bc
040F04 F1          0190*      pop af
040F05 C9          0191*      ret
040F06             0192*  
040F06             0193*  printHexHL:
040F06 F5          0194*      push af
040F07 C5          0195*      push bc
040F08 CD DE 0E 04 0196*      call printHex16
040F0C 3E 20       0197*      ld a,' '
040F0E 5B D7       0198*      rst.lil 10h
040F10 C1          0199*      pop bc
040F11 F1          0200*      pop af
040F12 C9          0201*      ret
040F13             0202*  
040F13             0203*  printHexUHL:
040F13 F5          0204*      push af
040F14 C5          0205*      push bc
040F15 CD D6 0E 04 0206*      call printHex24
040F19 3E 20       0207*      ld a,' '
040F1B 5B D7       0208*      rst.lil 10h
040F1D C1          0209*      pop bc
040F1E F1          0210*      pop af
040F1F C9          0211*      ret
040F20             0212*  
040F20             0213*  printHexAUHL:
040F20 F5          0214*      push af
040F21 C5          0215*      push bc
040F22 CD E4 0E 04 0216*      call printHex8
040F26 3E 2E       0217*      ld a,'.'
040F28 5B D7       0218*      rst.lil 10h
040F2A CD D6 0E 04 0219*      call printHex24
040F2E 3E 20       0220*      ld a,' '
040F30 5B D7       0221*      rst.lil 10h
040F32 C1          0222*      pop bc
040F33 F1          0223*      pop af
040F34 C9          0224*      ret
040F35             0225*  
040F35             0226*  printHexABHL:
040F35             0227*  ; preserve registers
040F35 C5          0228*      push bc ; b will be ok c will not
040F36 F5          0229*      push af ; will get totally destroyed
040F37             0230*  ; print a
040F37 CD E4 0E 04 0231*      call printHex8
040F3B             0232*  ; print b
040F3B 78          0233*      ld a,b
040F3C CD E4 0E 04 0234*      call printHex8
040F40             0235*  ; print hl
040F40 CD DE 0E 04 0236*      call printHex16
040F44             0237*  ; restore registers
040F44 F1          0238*      pop af
040F45 C1          0239*      pop bc
040F46 C9          0240*      ret
040F47             0241*  
040F47             0242*  printHexBHL:
040F47             0243*  ; preserve registers
040F47 C5          0244*      push bc ; b will be ok c will not
040F48 F5          0245*      push af ; will get totally destroyed
040F49             0246*  ; print b
040F49 78          0247*      ld a,b
040F4A CD E4 0E 04 0248*      call printHex8
040F4E             0249*  ; print hl
040F4E CD DE 0E 04 0250*      call printHex16
040F52             0251*  ; restore registers
040F52 F1          0252*      pop af
040F53 C1          0253*      pop bc
040F54 C9          0254*      ret
040F55             0255*  
040F55             0256*  printHexCDE:
040F55             0257*  ; preserve registers
040F55 C5          0258*      push bc ; b will be ok c will not
040F56 F5          0259*      push af ; will get totally destroyed
040F57             0260*  ; print c
040F57 79          0261*      ld a,c
040F58 CD E4 0E 04 0262*      call printHex8
040F5C             0263*  ; print de
040F5C EB          0264*      ex de,hl
040F5D CD DE 0E 04 0265*      call printHex16
040F61 EB          0266*      ex de,hl
040F62             0267*  ; restore registers
040F62 F1          0268*      pop af
040F63 C1          0269*      pop bc
040F64 C9          0270*      ret
040F65             0271*  
040F65             0272*  printHexUIX:
040F65             0273*  ; store everything in scratch
040F65 22 DE 13 04 0274*      ld (uhl),hl
040F69 ED 43 E1 13 0275*      ld (ubc),bc
       04          
040F6E ED 53 E4 13 0276*      ld (ude),de
       04          
040F73 DD 22 E7 13 0277*      ld (uix),ix
       04          
040F78 FD 22 EA 13 0278*      ld (uiy),iy
       04          
040F7D F5          0279*      push af ; fml
040F7E             0280*  
040F7E 21 75 13 04 0281*      ld hl,str_ixu
040F82 CD B6 0E 04 0282*      call printString
040F86 2A E7 13 04 0283*      ld hl,(uix)
040F8A CD D6 0E 04 0284*      call printHex24
040F8E CD CB 0E 04 0285*      call printNewLine
040F92             0286*  
040F92             0287*  ; restore everything
040F92 2A DE 13 04 0288*      ld hl, (uhl)
040F96 ED 4B E1 13 0289*      ld bc, (ubc)
       04          
040F9B ED 5B E4 13 0290*      ld de, (ude)
       04          
040FA0 DD 2A E7 13 0291*      ld ix, (uix)
       04          
040FA5 FD 2A EA 13 0292*      ld iy, (uiy)
       04          
040FAA F1          0293*      pop af
040FAB             0294*  ; all done
040FAB C9          0295*      ret
040FAC             0296*  
040FAC             0297*  ; Print a 0x HEX prefix
040FAC             0298*  DisplayHexPrefix:
040FAC 3E 30       0299*  	LD	A, '0'
040FAE 5B D7       0300*  	RST.LIL 10h
040FB0 3E 78       0301*  	LD	A, 'x'
040FB2 5B D7       0302*  	RST.LIL 10h
040FB4 C9          0303*  	RET
040FB5             0304*  
040FB5             0305*      MACRO printDecBC
040FB5             0306*          push hl
040FB5             0307*          push bc
040FB5             0308*          pop hl
040FB5             0309*          call printDec
040FB5             0310*          pop hl
040FB5             0311*      ENDMACRO
040FB5             0312*  
040FB5             0313*      MACRO printDecDE
040FB5             0314*          push hl
040FB5             0315*          push de
040FB5             0316*          pop hl
040FB5             0317*          call printDec
040FB5             0318*          pop hl
040FB5             0319*      ENDMACRO
040FB5             0320*  
040FB5             0321*      MACRO printDecHL
040FB5             0322*          call printDec
040FB5             0323*      ENDMACRO
040FB5             0324*  
040FB5             0325*      MACRO printDecIX
040FB5             0326*          push hl
040FB5             0327*          push ix
040FB5             0328*          pop hl
040FB5             0329*          call printDec
040FB5             0330*          pop hl
040FB5             0331*      ENDMACRO
040FB5             0332*  
040FB5             0333*      MACRO printDecIY
040FB5             0334*          push hl
040FB5             0335*          push iy
040FB5             0336*          pop hl
040FB5             0337*          call printDec
040FB5             0338*          pop hl
040FB5             0339*      ENDMACRO
040FB5             0340*  
040FB5             0341*  
040FB5             0342*  ; Prints the right justified decimal value in HL without leading zeroes
040FB5             0343*  ; HL : Value to print
040FB5             0344*  ; preserves all registers and flags
040FB5             0345*  printDec:
040FB5             0346*  ; BEGIN MY CODE
040FB5             0347*  ; back up all the things
040FB5 F5          0348*      push af
040FB6 C5          0349*      push bc
040FB7 D5          0350*      push de
040FB8 E5          0351*      push hl
040FB9             0352*  ; END MY CODE
040FB9 11 E1 0F 04 0353*  	LD	 DE, _printDecBuffer
040FBD CD F1 0F 04 0354*  	CALL u24_to_ascii
040FC1             0355*  ; BEGIN MY CODE
040FC1             0356*  ; replace leading zeroes with spaces
040FC1 21 E1 0F 04 0357*      LD	 HL, _printDecBuffer
040FC5 06 07       0358*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040FC7             0359*  @loop:
040FC7 7E          0360*      LD	 A, (HL)
040FC8 FE 30       0361*      CP	 '0'
040FCA C2 D4 0F 04 0362*      JP	 NZ, @done
040FCE 3E 20       0363*      LD   A, ' '
040FD0 77          0364*      LD	 (HL), A
040FD1 23          0365*      INC	 HL
040FD2             0366*      ; CALL vdu_cursor_forward
040FD2 10 F3       0367*      DJNZ @loop
040FD4             0368*  @done:
040FD4             0369*  ; END MY CODE
040FD4 21 E1 0F 04 0370*  	LD	 HL, _printDecBuffer
040FD8 CD B6 0E 04 0371*  	CALL printString
040FDC             0372*  ; BEGIN MY CODE
040FDC             0373*  ; restore all the things
040FDC E1          0374*      pop hl
040FDD D1          0375*      pop de
040FDE C1          0376*      pop bc
040FDF F1          0377*      pop af
040FE0             0378*  ; END MY CODE
040FE0 C9          0379*  	RET
040FE1 00 00 00 00 0380*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040FF1             0381*  
040FF1             0382*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040FF1             0383*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040FF1             0384*  ; so it will allways be 8 characters length
040FF1             0385*  ; HL : Value to convert to string
040FF1             0386*  ; DE : pointer to buffer, at least 8 byte + 0
040FF1             0387*  u24_to_ascii:
040FF1 01 80 69 67 0388*  	LD	 BC,-10000000
040FF5 CD 28 10 04 0389*  	CALL @one_digit
040FF9 01 C0 BD F0 0390*  	LD	 BC,-1000000
040FFD CD 28 10 04 0391*  	CALL @one_digit
041001 01 60 79 FE 0392*  	LD	 BC,-100000
041005 CD 28 10 04 0393*  	CALL @one_digit
041009 01 F0 D8 FF 0394*  	LD   BC,-10000
04100D CD 28 10 04 0395*  	CALL @one_digit
041011 01 18 FC FF 0396*  	LD   BC,-1000
041015 CD 28 10 04 0397*  	CALL @one_digit
041019 01 9C FF FF 0398*  	LD   BC,-100
04101D CD 28 10 04 0399*  	CALL @one_digit
041021 0E F6       0400*  	LD   C,-10
041023 CD 28 10 04 0401*  	CALL @one_digit
041027 48          0402*  	LD   C,B
041028             0403*  @one_digit:
041028 3E 2F       0404*  	LD   A,'0'-1
04102A             0405*  @divide_me:
04102A 3C          0406*  	INC  A
04102B 09          0407*  	ADD  HL,BC
04102C 38 FC       0408*  	JR   C,@divide_me
04102E ED 42       0409*  	SBC  HL,BC
041030 12          0410*  	LD   (DE),A
041031 13          0411*  	INC  DE
041032 C9          0412*  	RET
041033             0413*  
041033             0414*  print_u24:
041033 D5          0415*      push de
041034 E5          0416*      push hl
041035 11 E1 0F 04 0417*      ld de,_printDecBuffer
041039 CD F1 0F 04 0418*      call u24_to_ascii
04103D 21 E1 0F 04 0419*      ld hl,_printDecBuffer
041041 CD B6 0E 04 0420*      call printString
041045 3E 20       0421*      ld a,' '
041047 5B D7       0422*      rst.lil 10h
041049 E1          0423*      pop hl
04104A D1          0424*      pop de
04104B C9          0425*      ret
04104C             0426*  
04104C             0427*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04104C             0428*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04104C             0429*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04104C             0430*  u168_to_ascii:
04104C             0431*  ; add a leading space to make room for sign flag if needed
04104C 3E 20       0432*      ld a,' '
04104E 12          0433*      ld (de),a
04104F 13          0434*      inc de
041050             0435*  ; Convert integer part
041050 E5          0436*      push hl               ; Save HL (we’ll need the fractional part later)
041051 CD 3A 15 04 0437*      call hlu_udiv256    ; Shift to get integer portion in HL
041055 01 F0 D8 FF 0438*      ld   bc, -10000
041059 CD 7C 10 04 0439*      call @one_int
04105D 01 18 FC FF 0440*      ld   bc, -1000
041061 CD 7C 10 04 0441*      call @one_int
041065 01 9C FF FF 0442*      ld   bc, -100
041069 CD 7C 10 04 0443*      call @one_int
04106D 0E F6       0444*      ld   c, -10
04106F CD 7C 10 04 0445*      call @one_int
041073 48          0446*      ld   c, b
041074 CD 7C 10 04 0447*      call @one_int
041078 C3 87 10 04 0448*      jp   @frac            ; Jump to fractional part conversion
04107C             0449*  @one_int:
04107C 3E 2F       0450*      ld   a, '0' - 1       ; Start ASCII character at '0'
04107E             0451*  @divide_me:
04107E 3C          0452*      inc  a
04107F 09          0453*      add  hl, bc           ; Accumulate until overflow
041080 38 FC       0454*      jr   c, @divide_me
041082 ED 42       0455*      sbc  hl, bc           ; Remove excess after overflow
041084 12          0456*      ld   (de), a          ; Store ASCII digit
041085 13          0457*      inc  de
041086 C9          0458*      ret
041087             0459*  ; Convert fractional part
041087             0460*  @frac:
041087 3E 2E       0461*      ld   a, '.'           ; Decimal point
041089 12          0462*      ld   (de), a
04108A 13          0463*      inc  de
04108B E1          0464*      pop  hl               ; Restore HL with original fraction
04108C 06 03       0465*      ld   b, 3             ; Loop counter for 3 fractional digits
04108E             0466*  @frac_loop:
04108E 26 0A       0467*      ld   h, 10            ; Load multiplier for fractional part
041090 ED 6C       0468*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
041092 3E 30       0469*      ld   a, '0'
041094 84          0470*      add  a, h             ; Convert integer part to ASCII
041095 12          0471*      ld   (de), a
041096 13          0472*      inc  de
041097 10 F5       0473*      djnz @frac_loop       ; Repeat for each fractional digit
041099             0474*  ; Add null terminator
041099 AF          0475*      xor  a                ; Null terminator
04109A 12          0476*      ld   (de), a
04109B C9          0477*      ret
04109C             0478*  
04109C             0479*  print_u168:
04109C D5          0480*      push de
04109D E5          0481*      push hl
04109E 11 E1 0F 04 0482*      ld de,_printDecBuffer
0410A2 CD 4C 10 04 0483*      call u168_to_ascii
0410A6 21 E1 0F 04 0484*      ld hl,_printDecBuffer
0410AA CD B6 0E 04 0485*      call printString
0410AE E1          0486*      pop hl
0410AF D1          0487*      pop de
0410B0 C9          0488*      ret
0410B1             0489*  
0410B1             0490*  ; signed version of u168_to_ascii
0410B1             0491*  s168_to_ascii:
0410B1 D5          0492*      push de ; save starting address of buffer
0410B2 CD D3 14 04 0493*      call hlu_abs
0410B6 F5          0494*      push af ; save sign flag
0410B7 CD 4C 10 04 0495*      call u168_to_ascii
0410BB F1          0496*      pop af ; restore sign flag
0410BC D1          0497*      pop de ; restore starting address of buffer
0410BD F0          0498*      ret p ; hlu was positive so nothing to do
0410BE 3E 2D       0499*      ld a,'-'
0410C0 12          0500*      ld (de),a
0410C1 C9          0501*      ret
0410C2             0502*  
0410C2             0503*  print_s168:
0410C2 D5          0504*      push de
0410C3 E5          0505*      push hl
0410C4 11 E1 0F 04 0506*      ld de,_printDecBuffer
0410C8 CD B1 10 04 0507*      call s168_to_ascii
0410CC 21 E1 0F 04 0508*      ld hl,_printDecBuffer
0410D0 CD B6 0E 04 0509*      call printString
0410D4 E1          0510*      pop hl
0410D5 D1          0511*      pop de
0410D6 C9          0512*      ret
0410D7             0513*  
0410D7             0514*  print_s168_hl:
0410D7 F5          0515*      push af
0410D8 E5          0516*      push hl
0410D9 CD C2 10 04 0517*      call print_s168
0410DD 3E 20       0518*      ld a,' '
0410DF 5B D7       0519*      rst.lil 10h
0410E1 E1          0520*      pop hl
0410E2 F1          0521*      pop af
0410E3 C9          0522*      ret
0410E4             0523*  
0410E4             0524*  print_s168_bc:
0410E4 F5          0525*      push af
0410E5 C5          0526*      push bc
0410E6 E5          0527*      push hl
0410E7 C5          0528*      push bc
0410E8 E1          0529*      pop hl
0410E9 CD C2 10 04 0530*      call print_s168
0410ED 3E 20       0531*      ld a,' '
0410EF 5B D7       0532*      rst.lil 10h
0410F1 E1          0533*      pop hl
0410F2 C1          0534*      pop bc
0410F3 F1          0535*      pop af
0410F4 C9          0536*      ret
0410F5             0537*  
0410F5             0538*  print_s168_de:
0410F5 F5          0539*      push af
0410F6 D5          0540*      push de
0410F7 E5          0541*      push hl
0410F8 EB          0542*      ex de,hl
0410F9 CD C2 10 04 0543*      call print_s168
0410FD 3E 20       0544*      ld a,' '
0410FF 5B D7       0545*      rst.lil 10h
041101 E1          0546*      pop hl
041102 D1          0547*      pop de
041103 F1          0548*      pop af
041104 C9          0549*      ret
041105             0550*  
041105             0551*  print_s168_hl_bc_de:
041105 F5          0552*      push af
041106 C5          0553*      push bc
041107 D5          0554*      push de
041108 E5          0555*      push hl
041109 CD C2 10 04 0556*      call print_s168
04110D 3E 20       0557*      ld a,' '
04110F 5B D7       0558*      rst.lil 10h
041111 C5          0559*      push bc
041112 E1          0560*      pop hl
041113 CD C2 10 04 0561*      call print_s168
041117 3E 20       0562*      ld a,' '
041119 5B D7       0563*      rst.lil 10h
04111B EB          0564*      ex de,hl
04111C CD C2 10 04 0565*      call print_s168
041120 3E 20       0566*      ld a,' '
041122 5B D7       0567*      rst.lil 10h
041124 E1          0568*      pop hl
041125 D1          0569*      pop de
041126 C1          0570*      pop bc
041127 F1          0571*      pop af
041128 C9          0572*      ret
041129             0573*  
041129             0574*  print_s168_bc_de:
041129 F5          0575*      push af
04112A C5          0576*      push bc
04112B D5          0577*      push de
04112C C5          0578*      push bc
04112D E1          0579*      pop hl
04112E CD C2 10 04 0580*      call print_s168
041132 3E 20       0581*      ld a,' '
041134 5B D7       0582*      rst.lil 10h
041136 EB          0583*      ex de,hl
041137 CD C2 10 04 0584*      call print_s168
04113B 3E 20       0585*      ld a,' '
04113D 5B D7       0586*      rst.lil 10h
04113F E1          0587*      pop hl
041140 D1          0588*      pop de
041141 C1          0589*      pop bc
041142 F1          0590*      pop af
041143 C9          0591*      ret
041144             0592*  
041144             0593*  print_s168_a:
041144 F5          0594*      push af
041145 C5          0595*      push bc
041146 E5          0596*      push hl
041147 21 00 00 00 0597*      ld hl,0
04114B 6F          0598*      ld l,a
04114C CD D7 10 04 0599*      call print_s168_hl
041150 E1          0600*      pop hl
041151 C1          0601*      pop bc
041152 F1          0602*      pop af
041153 C9          0603*      ret
041154             0604*  
041154             0605*  ; #### new functions added by Brandon R. Gates ####
041154             0606*  
041154             0607*  ; print the binary representation of the 8-bit value in a
041154             0608*  ; destroys a, hl, bc
041154             0609*  printBin8:
041154 06 08       0610*      ld b,8      ; loop counter for 8 bits
041156 21 71 11 04 0611*      ld hl,@cmd  ; set hl to the low byte of the output string
04115A             0612*                  ; (which will be the high bit of the value in a)
04115A             0613*  @loop:
04115A 07          0614*      rlca ; put the next highest bit into carry
04115B 38 04       0615*      jr c,@one
04115D 36 30       0616*      ld (hl),'0'
04115F 18 02       0617*      jr @next_bit
041161             0618*  @one:
041161 36 31       0619*      ld (hl),'1'
041163             0620*  @next_bit:
041163 23          0621*      inc hl
041164 10 F4       0622*      djnz @loop
041166             0623*  ; print it
041166 21 71 11 04 0624*  	ld hl,@cmd
04116A 01 08 00 00 0625*  	ld bc,@end-@cmd
04116E 5B DF       0626*  	rst.lil $18
041170 C9          0627*  	ret
041171             0628*  @cmd: ds 8 ; eight bytes for eight bits
041179             0629*  @end:
041179             0630*  
041179             0631*  ; print the binary representation of the 8-bit value in a
041179             0632*  ; in reverse order (lsb first)
041179             0633*  ; destroys a, hl, bc
041179             0634*  printBin8Rev:
041179 06 08       0635*      ld b,8      ; loop counter for 8 bits
04117B 21 96 11 04 0636*      ld hl,@cmd  ; set hl to the low byte of the output string
04117F             0637*                  ; (which will be the high bit of the value in a)
04117F             0638*  @loop:
04117F 0F          0639*      rrca ; put the next lowest bit into carry
041180 38 04       0640*      jr c,@one
041182 36 30       0641*      ld (hl),'0'
041184 18 02       0642*      jr @next_bit
041186             0643*  @one:
041186 36 31       0644*      ld (hl),'1'
041188             0645*  @next_bit:
041188 23          0646*      inc hl
041189 10 F4       0647*      djnz @loop
04118B             0648*  ; print it
04118B 21 96 11 04 0649*  	ld hl,@cmd
04118F 01 08 00 00 0650*  	ld bc,@end-@cmd
041193 5B DF       0651*  	rst.lil $18
041195 C9          0652*  	ret
041196             0653*  @cmd: ds 8 ; eight bytes for eight bits
04119E             0654*  @end:
04119E             0655*  
04119E             0656*  ; print registers to screen in hexidecimal format
04119E             0657*  ; inputs: none
04119E             0658*  ; outputs: values of every register printed to screen
04119E             0659*  ;    values of each register in global scratch memory
04119E             0660*  ; destroys: nothing
04119E             0661*  stepRegistersHex:
04119E             0662*  ; store everything in scratch
04119E 22 DE 13 04 0663*      ld (uhl),hl
0411A2 ED 43 E1 13 0664*      ld (ubc),bc
       04          
0411A7 ED 53 E4 13 0665*      ld (ude),de
       04          
0411AC DD 22 E7 13 0666*      ld (uix),ix
       04          
0411B1 FD 22 EA 13 0667*      ld (uiy),iy
       04          
0411B6 F5          0668*      push af ; fml
0411B7 E1          0669*      pop hl  ; thanks, zilog
0411B8 22 DB 13 04 0670*      ld (uaf),hl
0411BC F5          0671*      push af ; dammit
0411BD             0672*  
0411BD             0673*  ; home the cursor
0411BD             0674*      ; call vdu_home_cursor
0411BD             0675*  
0411BD             0676*  ; print each register
0411BD 21 61 13 04 0677*      ld hl,str_afu
0411C1 CD B6 0E 04 0678*      call printString
0411C5 2A DB 13 04 0679*      ld hl,(uaf)
0411C9 CD D6 0E 04 0680*      call printHex24
0411CD CD CB 0E 04 0681*      call printNewLine
0411D1             0682*  
0411D1 21 66 13 04 0683*      ld hl,str_hlu
0411D5 CD B6 0E 04 0684*      call printString
0411D9 2A DE 13 04 0685*      ld hl,(uhl)
0411DD CD D6 0E 04 0686*      call printHex24
0411E1 CD CB 0E 04 0687*      call printNewLine
0411E5             0688*  
0411E5 21 6B 13 04 0689*      ld hl,str_bcu
0411E9 CD B6 0E 04 0690*      call printString
0411ED 2A E1 13 04 0691*      ld hl,(ubc)
0411F1 CD D6 0E 04 0692*      call printHex24
0411F5 CD CB 0E 04 0693*      call printNewLine
0411F9             0694*  
0411F9 21 70 13 04 0695*      ld hl,str_deu
0411FD CD B6 0E 04 0696*      call printString
041201 2A E4 13 04 0697*      ld hl,(ude)
041205 CD D6 0E 04 0698*      call printHex24
041209 CD CB 0E 04 0699*      call printNewLine
04120D             0700*  
04120D 21 75 13 04 0701*      ld hl,str_ixu
041211 CD B6 0E 04 0702*      call printString
041215 2A E7 13 04 0703*      ld hl,(uix)
041219 CD D6 0E 04 0704*      call printHex24
04121D CD CB 0E 04 0705*      call printNewLine
041221             0706*  
041221 21 7A 13 04 0707*      ld hl,str_iyu
041225 CD B6 0E 04 0708*      call printString
041229 2A EA 13 04 0709*      ld hl,(uiy)
04122D CD D6 0E 04 0710*      call printHex24
041231 CD CB 0E 04 0711*      call printNewLine
041235             0712*  
041235             0713*      ; call vsync
041235             0714*  
041235 CD CB 0E 04 0715*      call printNewLine
041239             0716*  
041239             0717*  ; check for right shift key and quit if pressed
041239             0718*  	MOSCALL mos_getkbmap
041239 3E 1E       0001*M 			LD	A, function
04123B 49 CF       0002*M 			RST.LIS	08h
04123D             0719*  @stayhere:
04123D             0720*  ; 7 RightShift
04123D DD CB 00 76 0721*      bit 6,(ix+0)
041241 20 02       0722*      jr nz,@RightShift
041243 18 F8       0723*      jr @stayhere
041245             0724*  @RightShift:
041245 DD CB 0E 86 0725*      res 0,(ix+14) ; debounce the key (hopefully)
041249 3E 80       0726*      ld a,%10000000
04124B             0727*      ; call multiPurposeDelay
04124B             0728*  
04124B             0729*  ; restore everything
04124B 2A DE 13 04 0730*      ld hl, (uhl)
04124F ED 4B E1 13 0731*      ld bc, (ubc)
       04          
041254 ED 5B E4 13 0732*      ld de, (ude)
       04          
041259 DD 2A E7 13 0733*      ld ix, (uix)
       04          
04125E FD 2A EA 13 0734*      ld iy, (uiy)
       04          
041263 F1          0735*      pop af
041264             0736*  ; all done
041264 C9          0737*      ret
041265             0738*  
041265             0739*  ; print registers to screen in hexidecimal format
041265             0740*  ; inputs: none
041265             0741*  ; outputs: values of every register printed to screen
041265             0742*  ;    values of each register in global scratch memory
041265             0743*  ; destroys: nothing
041265             0744*  dumpRegistersHex:
041265             0745*  ; store everything in scratch
041265 22 DE 13 04 0746*      ld (uhl),hl
041269 ED 43 E1 13 0747*      ld (ubc),bc
       04          
04126E ED 53 E4 13 0748*      ld (ude),de
       04          
041273 DD 22 E7 13 0749*      ld (uix),ix
       04          
041278 FD 22 EA 13 0750*      ld (uiy),iy
       04          
04127D F5          0751*      push af ; fml
04127E E1          0752*      pop hl  ; thanks, zilog
04127F 22 DB 13 04 0753*      ld (uaf),hl
041283 F5          0754*      push af ; dammit
041284             0755*  
041284             0756*  ; home the cursor
041284             0757*      ; call vdu_home_cursor
041284             0758*      ; call printNewLine
041284             0759*  
041284             0760*  ; print each register
041284 21 61 13 04 0761*      ld hl,str_afu
041288 CD B6 0E 04 0762*      call printString
04128C 2A DB 13 04 0763*      ld hl,(uaf)
041290 CD D6 0E 04 0764*      call printHex24
041294             0765*      ; call printNewLine
041294             0766*  
041294 21 66 13 04 0767*      ld hl,str_hlu
041298 CD B6 0E 04 0768*      call printString
04129C 2A DE 13 04 0769*      ld hl,(uhl)
0412A0 CD D6 0E 04 0770*      call printHex24
0412A4             0771*      ; call printNewLine
0412A4             0772*  
0412A4 21 6B 13 04 0773*      ld hl,str_bcu
0412A8 CD B6 0E 04 0774*      call printString
0412AC 2A E1 13 04 0775*      ld hl,(ubc)
0412B0 CD D6 0E 04 0776*      call printHex24
0412B4             0777*      ; call printNewLine
0412B4             0778*  
0412B4 21 70 13 04 0779*      ld hl,str_deu
0412B8 CD B6 0E 04 0780*      call printString
0412BC 2A E4 13 04 0781*      ld hl,(ude)
0412C0 CD D6 0E 04 0782*      call printHex24
0412C4             0783*      ; call printNewLine
0412C4             0784*  
0412C4 21 75 13 04 0785*      ld hl,str_ixu
0412C8 CD B6 0E 04 0786*      call printString
0412CC 2A E7 13 04 0787*      ld hl,(uix)
0412D0 CD D6 0E 04 0788*      call printHex24
0412D4             0789*      ; call printNewLine
0412D4             0790*  
0412D4 21 7A 13 04 0791*      ld hl,str_iyu
0412D8 CD B6 0E 04 0792*      call printString
0412DC 2A EA 13 04 0793*      ld hl,(uiy)
0412E0 CD D6 0E 04 0794*      call printHex24
0412E4             0795*      ; call printNewLine
0412E4             0796*  
0412E4             0797*      ; call vdu_vblank
0412E4             0798*  
0412E4 CD CB 0E 04 0799*      call printNewLine
0412E8             0800*  ; restore everything
0412E8 2A DE 13 04 0801*      ld hl, (uhl)
0412EC ED 4B E1 13 0802*      ld bc, (ubc)
       04          
0412F1 ED 5B E4 13 0803*      ld de, (ude)
       04          
0412F6 DD 2A E7 13 0804*      ld ix, (uix)
       04          
0412FB FD 2A EA 13 0805*      ld iy, (uiy)
       04          
041300 F1          0806*      pop af
041301             0807*  ; all done
041301 C9          0808*      ret
041302             0809*  
041302             0810*  dumpRegistersHexPrime:
041302 D9          0811*      exx
041303 08          0812*      ex af,af'
041304 CD 65 12 04 0813*      call dumpRegistersHex
041308 08          0814*      ex af,af'
041309 D9          0815*      exx
04130A C9          0816*      ret
04130B             0817*  
04130B             0818*  ; additionally dump prime registers
04130B             0819*  ; inputs: none
04130B             0820*  ; outputs: values of every register printed to screen
04130B             0821*  ; destroys: nothing
04130B             0822*  dumpRegistersHexAll:
04130B CD 65 12 04 0823*      call dumpRegistersHex
04130F 08          0824*      ex af,af'
041310 D9          0825*      exx
041311 CD 65 12 04 0826*      call dumpRegistersHex
041315 08          0827*      ex af,af'
041316 D9          0828*      exx
041317 C9          0829*      ret
041318             0830*  
041318             0831*  ; print hlu to screen in hexidecimal format
041318             0832*  ; inputs: none
041318             0833*  ; destroys: nothing
041318             0834*  print_hex_hl:
041318 F5          0835*      push af
041319 E5          0836*      push hl
04131A 21 66 13 04 0837*      ld hl,str_hlu
04131E CD B6 0E 04 0838*      call printString
041322 E1          0839*      pop hl
041323 E5          0840*      push hl
041324 CD D6 0E 04 0841*      call printHex24
041328 3E 20       0842*      ld a,' '
04132A 5B D7       0843*      rst.lil 10h
04132C E1          0844*      pop hl
04132D F1          0845*      pop af
04132E C9          0846*      ret
04132F             0847*  
04132F             0848*  ; print bcu to screen in hexidecimal format
04132F             0849*  ; inputs: none
04132F             0850*  ; destroys: nothing
04132F             0851*  print_hex_bc:
04132F F5          0852*      push af
041330 E5          0853*      push hl
041331 C5          0854*      push bc
041332 21 6B 13 04 0855*      ld hl,str_bcu
041336 CD B6 0E 04 0856*      call printString
04133A E1          0857*      pop hl
04133B E5          0858*      push hl
04133C CD D6 0E 04 0859*      call printHex24
041340 3E 20       0860*      ld a,' '
041342 5B D7       0861*      rst.lil 10h
041344 C1          0862*      pop bc
041345 E1          0863*      pop hl
041346 F1          0864*      pop af
041347 C9          0865*      ret
041348             0866*  
041348             0867*  ; print deu to screen in hexidecimal format
041348             0868*  ; inputs: none
041348             0869*  ; destroys: nothing
041348             0870*  print_hex_de:
041348 F5          0871*      push af
041349 E5          0872*      push hl
04134A D5          0873*      push de
04134B 21 70 13 04 0874*      ld hl,str_deu
04134F CD B6 0E 04 0875*      call printString
041353 E1          0876*      pop hl
041354 E5          0877*      push hl
041355 CD D6 0E 04 0878*      call printHex24
041359 3E 20       0879*      ld a,' '
04135B 5B D7       0880*      rst.lil 10h
04135D D1          0881*      pop de
04135E E1          0882*      pop hl
04135F F1          0883*      pop af
041360 C9          0884*      ret
041361             0885*  
041361 20 61 66 3D 0886*  str_afu: db " af=",0
       00          
041366 20 68 6C 3D 0887*  str_hlu: db " hl=",0
       00          
04136B 20 62 63 3D 0888*  str_bcu: db " bc=",0
       00          
041370 20 64 65 3D 0889*  str_deu: db " de=",0
       00          
041375 20 69 78 3D 0890*  str_ixu: db " ix=",0
       00          
04137A 20 69 79 3D 0891*  str_iyu: db " iy=",0
       00          
04137F             0892*  
04137F             0893*  ; print udeuhl to screen in hexidecimal format
04137F             0894*  ; inputs: none
04137F             0895*  ; outputs: concatenated hexidecimal udeuhl
04137F             0896*  ; destroys: nothing
04137F             0897*  dumpUDEUHLHex:
04137F             0898*  ; store everything in scratch
04137F 22 DE 13 04 0899*      ld (uhl),hl
041383 ED 43 E1 13 0900*      ld (ubc),bc
       04          
041388 ED 53 E4 13 0901*      ld (ude),de
       04          
04138D DD 22 E7 13 0902*      ld (uix),ix
       04          
041392 FD 22 EA 13 0903*      ld (uiy),iy
       04          
041397 F5          0904*      push af
041398             0905*  
041398             0906*  ; print each register
041398             0907*  
041398 21 D2 13 04 0908*      ld hl,str_udeuhl
04139C CD B6 0E 04 0909*      call printString
0413A0 2A E4 13 04 0910*      ld hl,(ude)
0413A4 CD D6 0E 04 0911*      call printHex24
0413A8 3E 2E       0912*  	ld a,'.'	; print a dot to separate the values
0413AA 5B D7       0913*  	rst.lil 10h
0413AC 2A DE 13 04 0914*      ld hl,(uhl)
0413B0 CD D6 0E 04 0915*      call printHex24
0413B4 CD CB 0E 04 0916*      call printNewLine
0413B8             0917*  
0413B8             0918*  ; restore everything
0413B8 2A DE 13 04 0919*      ld hl, (uhl)
0413BC ED 4B E1 13 0920*      ld bc, (ubc)
       04          
0413C1 ED 5B E4 13 0921*      ld de, (ude)
       04          
0413C6 DD 2A E7 13 0922*      ld ix, (uix)
       04          
0413CB FD 2A EA 13 0923*      ld iy, (uiy)
       04          
0413D0 F1          0924*      pop af
0413D1             0925*  ; all done
0413D1 C9          0926*      ret
0413D2             0927*  
0413D2 75 64 65 2E 0928*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0413DB             0929*  
0413DB             0930*  ; global scratch memory for registers
0413DB 00 00 00    0931*  uaf: dl 0
0413DE 00 00 00    0932*  uhl: dl 0
0413E1 00 00 00    0933*  ubc: dl 0
0413E4 00 00 00    0934*  ude: dl 0
0413E7 00 00 00    0935*  uix: dl 0
0413EA 00 00 00    0936*  uiy: dl 0
0413ED 00 00 00    0937*  usp: dl 0
0413F0 00 00 00    0938*  upc: dl 0
0413F3             0939*  
0413F3             0940*  ; inputs: whatever is in the flags register
0413F3             0941*  ; outputs: binary representation of flags
0413F3             0942*  ;          with a header so we know which is what
0413F3             0943*  ; destroys: nothing
0413F3             0944*  ; preserves: everything
0413F3             0945*  dumpFlags:
0413F3             0946*  ; first we curse zilog for not giving direct access to flags
0413F3 F5          0947*      push af ; this is so we can send it back unharmed
0413F4 F5          0948*      push af ; this is so we can pop it to hl
0413F5             0949*  ; store everything in scratch
0413F5 22 DE 13 04 0950*      ld (uhl),hl
0413F9 ED 43 E1 13 0951*      ld (ubc),bc
       04          
0413FE ED 53 E4 13 0952*      ld (ude),de
       04          
041403 DD 22 E7 13 0953*      ld (uix),ix
       04          
041408 FD 22 EA 13 0954*      ld (uiy),iy
       04          
04140D             0955*  ; next we print the header
04140D 21 39 14 04 0956*      ld hl,@header
041411 CD B6 0E 04 0957*      call printString
041415 E1          0958*      pop hl ; flags are now in l
041416 7D          0959*      ld a,l ; flags are now in a
041417 CD 54 11 04 0960*      call printBin8
04141B CD CB 0E 04 0961*  	call printNewLine
04141F             0962*  ; restore everything
04141F 2A DE 13 04 0963*      ld hl, (uhl)
041423 ED 4B E1 13 0964*      ld bc, (ubc)
       04          
041428 ED 5B E4 13 0965*      ld de, (ude)
       04          
04142D DD 2A E7 13 0966*      ld ix, (uix)
       04          
041432 FD 2A EA 13 0967*      ld iy, (uiy)
       04          
041437 F1          0968*      pop af ; send her home the way she came
041438 C9          0969*      ret
041439             0970*  ; Bit 7 (S): Sign flag
041439             0971*  ; Bit 6 (Z): Zero flag
041439             0972*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
041439             0973*  ; Bit 4 (H): Half Carry flag
041439             0974*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
041439             0975*  ; Bit 2 (PV): Parity/Overflow flag
041439             0976*  ; Bit 1 (N): Subtract flag
041439             0977*  ; Bit 0 (C): Carry flag
041439 53 5A 78 48 0978*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041444             0979*  
041444             0980*  ; set all the bits in the flag register
041444             0981*  ; more of an academic exercise than anything useful
041444             0982*  ; inputs; none
041444             0983*  ; outputs; a=0,f=255
041444             0984*  ; destroys: flags, hl
041444             0985*  ; preserves: a, because why not
041444             0986*  setAllFlags:
041444 21 FF 00 00 0987*      ld hl,255
041448 67          0988*      ld h,a ; four cycles to preserve a is cheap
041449 E5          0989*      push hl
04144A F1          0990*      pop af
04144B C9          0991*      ret
04144C             0992*  
04144C             0993*  ; reset all the bits in the flag register
04144C             0994*  ; unlike its inverse counterpart, this may actually be useful
04144C             0995*  ; inputs; none
04144C             0996*  ; outputs; a=0,f=0
04144C             0997*  ; destroys: flags, hl
04144C             0998*  ; preserves: a, because why not
04144C             0999*  resetAllFlags:
04144C 21 00 00 00 1000*      ld hl,0
041450 67          1001*      ld h,a ; four cycles to preserve a is cheap
041451 E5          1002*      push hl
041452 F1          1003*      pop af
041453 C9          1004*      ret
041454             1005*  
041454             1006*  ; wait until user presses a key
041454             1007*  ; inputs: none
041454             1008*  ; outputs: ascii code of key pressed in a
041454             1009*  ; destroys: af,ix
041454             1010*  waitKeypress:
041454             1011*      MOSCALL mos_getkey
041454 3E 00       0001*M 			LD	A, function
041456 49 CF       0002*M 			RST.LIS	08h
041458 C9          1012*      ret
041459             1013*  
041459             1014*  ; print bytes from an address to the screen in hexidecimal format
041459             1015*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041459             1016*  ; outputs: values of each byte printed to screen separated by spaces
041459             1017*  ; destroys: nothing
041459             1018*  dumpMemoryHex:
041459             1019*  ; save registers to the stack
041459 C5          1020*      push bc
04145A E5          1021*      push hl
04145B F5          1022*      push af
04145C             1023*  
04145C             1024*  ; print the address and separator
04145C CD D6 0E 04 1025*      call printHex24
041460 3E 3A       1026*      ld a,':'
041462 5B D7       1027*      rst.lil 10h
041464 3E 20       1028*      ld a,' '
041466 5B D7       1029*      rst.lil 10h
041468             1030*  
041468             1031*  ; set b to be our loop counter
041468 F1          1032*      pop af
041469 47          1033*      ld b,a
04146A E1          1034*      pop hl
04146B E5          1035*      push hl
04146C F5          1036*      push af
04146D             1037*  @loop:
04146D             1038*  ; print the byte
04146D 7E          1039*      ld a,(hl)
04146E CD E4 0E 04 1040*      call printHex8
041472             1041*  ; print a space
041472 3E 20       1042*      ld a,' '
041474 5B D7       1043*      rst.lil 10h
041476 23          1044*      inc hl
041477 10 F4       1045*      djnz @loop
041479 CD CB 0E 04 1046*      call printNewLine
04147D             1047*  
04147D             1048*  ; restore everything
04147D F1          1049*      pop af
04147E E1          1050*      pop hl
04147F C1          1051*      pop bc
041480             1052*  
041480             1053*  ; all done
041480 C9          1054*      ret
041481             1055*  
041481             1056*  
041481             1057*  ; print bytes from an address to the screen in binary format
041481             1058*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041481             1059*  ; outputs: values of each byte printed to screen separated by spaces
041481             1060*  ; destroys: nothing
041481             1061*  dumpMemoryBin:
041481             1062*  ; save all registers to the stack
041481 F5          1063*      push af
041482 C5          1064*      push bc
041483 D5          1065*      push de
041484 E5          1066*      push hl
041485 DD E5       1067*      push ix
041487 FD E5       1068*      push iy
041489             1069*  
041489             1070*  ; set b to be our loop counter
041489 47          1071*      ld b,a
04148A             1072*  @loop:
04148A             1073*  ; print the byte
04148A 7E          1074*      ld a,(hl)
04148B E5          1075*      push hl
04148C C5          1076*      push bc
04148D CD 54 11 04 1077*      call printBin8
041491 C1          1078*      pop bc
041492             1079*  ; print a space
041492 3E 20       1080*      ld a,' '
041494 5B D7       1081*      rst.lil 10h
041496 E1          1082*      pop hl
041497 23          1083*      inc hl
041498 10 F0       1084*      djnz @loop
04149A CD CB 0E 04 1085*      call printNewLine
04149E             1086*  
04149E             1087*  ; restore everything
04149E FD E1       1088*      pop iy
0414A0 DD E1       1089*      pop ix
0414A2 E1          1090*      pop hl
0414A3 D1          1091*      pop de
0414A4 C1          1092*      pop bc
0414A5 F1          1093*      pop af
0414A6             1094*  ; all done
0414A6 C9          1095*      ret
0414A7             1096*  
0414A7             1097*  ; print bytes from an address to the screen in binary format
0414A7             1098*  ; with the bits of each byte in reverse order (lsb first)
0414A7             1099*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0414A7             1100*  ; outputs: values of each byte printed to screen separated by spaces
0414A7             1101*  ; destroys: nothing
0414A7             1102*  dumpMemoryBinRev:
0414A7             1103*  ; save all registers to the stack
0414A7 F5          1104*      push af
0414A8 C5          1105*      push bc
0414A9 D5          1106*      push de
0414AA E5          1107*      push hl
0414AB DD E5       1108*      push ix
0414AD FD E5       1109*      push iy
0414AF             1110*  
0414AF             1111*  ; set b to be our loop counter
0414AF 47          1112*      ld b,a
0414B0             1113*  @loop:
0414B0             1114*  ; print the byte
0414B0 7E          1115*      ld a,(hl)
0414B1 E5          1116*      push hl
0414B2 C5          1117*      push bc
0414B3 CD 79 11 04 1118*      call printBin8Rev
0414B7 C1          1119*      pop bc
0414B8             1120*  ; print a space
0414B8 3E 20       1121*      ld a,' '
0414BA 5B D7       1122*      rst.lil 10h
0414BC E1          1123*      pop hl
0414BD 23          1124*      inc hl
0414BE 10 F0       1125*      djnz @loop
0414C0 CD CB 0E 04 1126*      call printNewLine
0414C4             1127*  
0414C4             1128*  ; restore everything
0414C4 FD E1       1129*      pop iy
0414C6 DD E1       1130*      pop ix
0414C8 E1          1131*      pop hl
0414C9 D1          1132*      pop de
0414CA C1          1133*      pop bc
0414CB F1          1134*      pop af
0414CC             1135*  ; all done
0414CC C9          1136*      ret
0414CD             0056   	include "maths.inc"
0414CD             0001*  ;------------------------------------------------------------------------
0414CD             0002*  ; Scratch area for calculations
0414CD             0003*  ;------------------------------------------------------------------------
0414CD 00 00 00    0004*  scratch1:	dw24	0	;bit manipulation buffer 1
0414D0 00 00 00    0005*  scratch2:	dw24	0	;bit manipulation buffer 2
0414D3             0006*  
0414D3             0007*  ; absolute value of hlu
0414D3             0008*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0414D3             0009*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0414D3             0010*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0414D3             0011*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0414D3             0012*  ; destroys: a
0414D3             0013*  hlu_abs:
0414D3 19          0014*      add hl,de
0414D4 B7          0015*      or a
0414D5 ED 52       0016*      sbc hl,de
0414D7 FA DC 14 04 0017*      jp m,@is_neg
0414DB C9          0018*      ret         ; hlu is positive or zero so we're done
0414DC             0019*  @is_neg:
0414DC F5          0020*      push af     ; otherwise, save current flags for return
0414DD CD E3 14 04 0021*      call neg_hlu ; negate hlu
0414E1 F1          0022*      pop af      ; get back flags
0414E2 C9          0023*      ret
0414E3             0024*  
0414E3             0025*  ; flip the sign of hlu
0414E3             0026*  ; inputs: hlu
0414E3             0027*  ; returns: 0-hlu, flags set appropriately for the result:
0414E3             0028*  ;         s1,z0,pv0,n1,c1 if result is negative
0414E3             0029*  ;         s0,z1,pv0,n1,c0 if result is zero
0414E3             0030*  ;         s0,z0,pv0,n1,c1 if result is positive
0414E3             0031*  ; destroys a
0414E3             0032*  neg_hlu:
0414E3 D5          0033*      push de     ; save de
0414E4 EB          0034*      ex de,hl    ; put hl into de
0414E5 21 00 00 00 0035*      ld hl,0     ; clear hl
0414E9 AF          0036*      xor a       ; clear carry
0414EA ED 52       0037*      sbc hl,de   ; 0-hlu = -hlu
0414EC D1          0038*      pop de      ; get de back
0414ED C9          0039*      ret         ; easy peasy
0414EE             0040*  
0414EE             0041*  ;------------------------------------------------------------------------
0414EE             0042*  ; divide hlu by 2, inspired by above
0414EE             0043*  ;------------------------------------------------------------------------
0414EE             0044*  hlu_div2:
0414EE 22 CD 14 04 0045*  	ld		(scratch1),hl
0414F2 21 CF 14 04 0046*  	ld		hl,scratch1+2
0414F6 CB 1E       0047*  	rr		(hl)
0414F8 2B          0048*  	dec		hl
0414F9 CB 1E       0049*  	rr		(hl)
0414FB 2B          0050*  	dec		hl
0414FC CB 1E       0051*  	rr		(hl)
0414FE 23          0052*  	inc		hl
0414FF 23          0053*  	inc		hl
041500 2A CD 14 04 0054*      ld hl,(scratch1)
041504 C9          0055*      ret
041505             0056*  
041505             0057*  ; this is my little hack to divide by 16
041505             0058*  hlu_div16:
041505 AF          0059*      xor a
041506 29          0060*      add hl,hl
041507 17          0061*      rla
041508 29          0062*      add hl,hl
041509 17          0063*      rla
04150A 29          0064*      add hl,hl
04150B 17          0065*      rla
04150C 29          0066*      add hl,hl
04150D 17          0067*      rla
04150E 22 1B 15 04 0068*      ld (@scratch),hl
041512 32 1E 15 04 0069*      ld (@scratch+3),a
041516 2A 1C 15 04 0070*      ld hl,(@scratch+1)
04151A C9          0071*      ret
04151B             0072*  @scratch: ds 4
04151F             0073*  
04151F             0074*  ; hlu signed division by 256
04151F             0075*  ; returns: hlu / 256
04151F             0076*  ; destroys: af
04151F             0077*  hlu_sdiv256:
04151F AF          0078*      xor a ; assume hl is positive
041520 22 36 15 04 0079*      ld (@buffer),hl
041524             0080*      sign_hlu
041524 19          0001*M         add hl,de
041525 B7          0002*M         or a
041526 ED 52       0003*M         sbc hl,de
041528 F2 2D 15 04 0081*      jp p,@hl_pos
04152C 3D          0082*      dec a
04152D             0083*  @hl_pos:
04152D 32 39 15 04 0084*      ld (@buffer+3),a
041531 2A 37 15 04 0085*      ld hl,(@buffer+1)
041535 C9          0086*      ret
041536             0087*  @buffer: ds 4
04153A             0088*  
04153A             0089*  ; hlu 1 byte right shift, unsigned
04153A             0090*  ; returns: hlu / 256, fractional portion in a
04153A             0091*  ; destroys: af
04153A             0092*  hlu_udiv256:
04153A AF          0093*  	xor a
04153B 32 4C 15 04 0094*  	ld (@buffer+3),a
04153F 7D          0095*  	ld a,l ; save the fractional portion
041540 22 49 15 04 0096*  	ld (@buffer),hl
041544 2A 4A 15 04 0097*  	ld hl,(@buffer+1)
041548 C9          0098*  	ret
041549             0099*  @buffer: ds 4
04154D             0100*  
04154D             0101*      MACRO hlu_mul256
04154D             0102*          add hl,hl ; * 2
04154D             0103*          add hl,hl ; * 4
04154D             0104*          add hl,hl ; * 8
04154D             0105*          add hl,hl ; * 16
04154D             0106*          add hl,hl ; * 32
04154D             0107*          add hl,hl ; * 64
04154D             0108*          add hl,hl ; * 128
04154D             0109*          add hl,hl ; * 256
04154D             0110*      ENDMACRO
04154D             0111*  
04154D             0112*  ; compute the modulo of hlu by deu
04154D             0113*  ; outputs: hlu = hlu % deu
04154D             0114*  ; destroys: f, hl
04154D             0115*  hlu_mod:
04154D B7          0116*  	or a ; clear carry
04154E             0117*  @loop:
04154E ED 52       0118*      sbc hl,de
041550 DA 58 15 04 0119*      jp c, @end
041554 C3 4E 15 04 0120*      jp @loop
041558             0121*  @end:
041558 19          0122*      add hl,de
041559 C9          0123*  	ret
04155A             0124*  
04155A             0125*  
04155A 00 00 00 00 0126*  add_bcd_arg1: db #00,#00,#00,#00
04155E 00 00 00 00 0127*  add_bcd_arg2: db #00,#00,#00,#00
041562             0128*  
041562             0129*  ; set bcd values in a scratch memory address from registers bcde
041562             0130*  ; input: hl; scratch address,bcde; 8-place bcd number
041562             0131*  ; destroys ; hl
041562             0132*  set_bcd:
041562 73          0133*      ld (hl),e
041563 23          0134*      inc hl
041564 72          0135*      ld (hl),d
041565 23          0136*      inc hl
041566 71          0137*      ld (hl),c
041567 23          0138*      inc hl
041568 70          0139*      ld (hl),b
041569 C9          0140*      ret
04156A             0141*  
04156A             0142*  ; load bcd values from a scratch memory address to bcde
04156A             0143*  ; input: hl; scratch address
04156A             0144*  ; output: bcde; 8-place bcd number
04156A             0145*  ; destroys: hl
04156A             0146*  get_bcd:
04156A 5E          0147*      ld e,(hl)
04156B 23          0148*      inc hl
04156C 56          0149*      ld d,(hl)
04156D 23          0150*      inc hl
04156E 4E          0151*      ld c,(hl)
04156F 23          0152*      inc hl
041570 46          0153*      ld b,(hl)
041571 C9          0154*      ret
041572             0155*  
041572             0156*  ; BCD addition
041572             0157*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
041572             0158*  ;       a is the number of bytes holding each number (number of places/2)
041572             0159*  ; outputs: (hl) + (de) --> (hl)
041572             0160*  ; destroys: a,b,de,hl
041572             0161*  add_bcd:
041572 47          0162*      ld b,a ; loop counter
041573 AF          0163*      xor a ; reset a, clear carry flag
041574             0164*  adcec:
041574 1A          0165*      ld a,(de) ; addend to acc
041575 8E          0166*      adc a,(hl) ; add (hl) to acc
041576 27          0167*      daa ; adjust result to bcd
041577 77          0168*      ld (hl),a ; store result
041578 23          0169*      inc hl ; advance memory pointers
041579 13          0170*      inc de
04157A 10 F8       0171*      djnz adcec ; loop until b == 0
04157C C9          0172*      ret
04157D             0173*  
04157D             0174*  ; BCD subtraction
04157D             0175*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04157D             0176*  ;       a is the number of bytes holding each number (number of places/2)
04157D             0177*  ; outputs: (hl) - (de) --> (hl)
04157D             0178*  ; destroys: a,b,de,hl
04157D             0179*  sub_bcd:
04157D 47          0180*      ld b,a ; loop counter
04157E AF          0181*      xor a ; reset a,clear carry flag
04157F             0182*  subdec:
04157F 1A          0183*      ld a,(de) ; subtrahend to acc
041580 9E          0184*      sbc a,(hl) ; subtract (hl) from acc
041581 27          0185*      daa ; adjust result to bcd
041582 77          0186*      ld (hl),a ; store result
041583 23          0187*      inc hl ; advance memory pointers
041584 13          0188*      inc de
041585 10 F8       0189*      djnz subdec ; loop until b == 0
041587 C9          0190*      ret
041588             0191*  
041588             0192*  ; http://www.z80.info/pseudo-random.txt
041588             0193*  rand_8:
041588 C5          0194*      push bc
041589 3A 9C 15 04 0195*      ld a,(r_seed)
04158D 4F          0196*      ld c,a
04158E             0197*  
04158E 0F          0198*      rrca ; multiply by 32
04158F 0F          0199*      rrca
041590 0F          0200*      rrca
041591 EE 1F       0201*      xor 0x1f
041593             0202*  
041593 81          0203*      add a,c
041594 DE FF       0204*      sbc a,255 ; carry
041596             0205*  
041596 32 9C 15 04 0206*      ld (r_seed),a
04159A C1          0207*      pop bc
04159B C9          0208*      ret
04159C 50          0209*  r_seed: defb $50
04159D             0057       include "mathfpp.inc"
04159D             0001*  ; integer operations
04159D             0002*  iand:	EQU 58	; AND (INTEGER)
04159D             0003*  ibdiv:	EQU 59	; DIV
04159D             0004*  ieor:	EQU 60	; EOR
04159D             0005*  imod:	EQU 61	; MOD
04159D             0006*  ior:	EQU 62	; OR
04159D             0007*  ile:	EQU 63	; <=
04159D             0008*  ine:	EQU 64	; <>
04159D             0009*  ige:	EQU 65	; >=
04159D             0010*  ilt:	EQU 66	; <
04159D             0011*  ieq:	EQU 67	; =
04159D             0012*  imul:	EQU 68	; *
04159D             0013*  iadd:	EQU 69	; +
04159D             0014*  igt:	EQU 70	; >
04159D             0015*  isub:	EQU 71	; -
04159D             0016*  ipow:	EQU 72	; ^
04159D             0017*  idiv:	EQU 73	; /
04159D             0018*  ;
04159D             0019*  ; floating point functions
04159D             0020*  absv:	EQU 16	; ABS
04159D             0021*  acs:	EQU 17	; ACS
04159D             0022*  asn:	EQU 18	; ASN
04159D             0023*  atn:	EQU 19	; ATN
04159D             0024*  cos:	EQU 20	; COS
04159D             0025*  deg:	EQU 21	; DEG
04159D             0026*  exp:	EQU 22	; EXP
04159D             0027*  int_:	EQU 23	; INT
04159D             0028*  ln:	    EQU 24	; LN
04159D             0029*  log:	EQU 25	; LOG
04159D             0030*  notk:	EQU 26	; NOT
04159D             0031*  rad:	EQU 27	; RAD
04159D             0032*  sgn:	EQU 28	; SGN
04159D             0033*  sin:	EQU 29	; SIN
04159D             0034*  sqr:	EQU 30	; SQR
04159D             0035*  tan:	EQU 31	; TAN
04159D             0036*  zero:	EQU 32	; ZERO
04159D             0037*  fone:	EQU 33	; FONE
04159D             0038*  true:	EQU 34	; TRUE
04159D             0039*  pi:	    EQU 35	; PI
04159D             0040*  val:	EQU 36	; VAL
04159D             0041*  str:	EQU 37	; STR$
04159D             0042*  sfix:	EQU 38	; FIX
04159D             0043*  sfloat:	EQU 39	; FLOAT
04159D             0044*  ftest:	EQU 40	; TEST
04159D             0045*  fcomp:	EQU 41	; COMPARE
04159D             0046*  ;
04159D             0047*  ; floating point operations
04159D             0048*  fand:	EQU  0	; AND (FLOATING-POINT)
04159D             0049*  fbdiv:	EQU  1	; DIV
04159D             0050*  feor:	EQU  2	; EOR
04159D             0051*  fmod:	EQU  3	; MOD
04159D             0052*  ffor:	EQU  4	; OR
04159D             0053*  fle:	EQU  5	; <=
04159D             0054*  fne:	EQU  6	; <>
04159D             0055*  fge:	EQU  7	; >=
04159D             0056*  flt:	EQU  8	; <
04159D             0057*  feq:	EQU  9	; =
04159D             0058*  fmul:	EQU 10	; *
04159D             0059*  fadd:	EQU 11	; +
04159D             0060*  fgt:	EQU 12	; >
04159D             0061*  fsub:	EQU 13	; -
04159D             0062*  fpow:	EQU 14	; ^
04159D             0063*  fdiv:	EQU 15	; /
04159D             0064*  
04159D             0065*      MACRO LOAD_FLOAT ARG
04159D             0066*      ld ix,$+11
04159D             0067*      call val_fp ; convert the string to a float
04159D             0068*      jp (ix)
04159D             0069*      asciz ARG
04159D             0070*      ENDMACRO
04159D             0071*  
04159D             0072*  ; --- originally in eval.asm ---
04159D             0073*  ;SWAP - Swap arguments
04159D             0074*  ;Exchanges DE,HL D'E',H'L' and B,C
04159D             0075*  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
04159D             0076*  ;
04159D 79          0077*  SWAP:			LD      A,C
04159E 48          0078*  			LD      C,B
04159F 47          0079*  			LD      B,A
0415A0 EB          0080*  			EX      DE,HL
0415A1 D9          0081*  			EXX
0415A2 EB          0082*  			EX      DE,HL
0415A3 D9          0083*  			EXX
0415A4 C9          0084*  			RET
0415A5             0085*  
0415A5             0086*  ; same as VAL_FP in fpp.asm, but preserves any float stored in DED'E'B
0415A5             0087*  val_fp:
0415A5 FD E5       0088*      push iy ; preserve
0415A7 FD 21 C2 15 0089*      ld iy,@val
       04          
0415AC CD B4 16 04 0090*      call store_float_iy_alt
0415B0 3E 24       0091*      ld a,val
0415B2 CD BA 00 04 0092*      call FPP ; string converted to float in HLH'L'C
0415B6 FD 21 C2 15 0093*      ld iy,@val
       04          
0415BB CD C6 16 04 0094*      call fetch_float_iy_alt
0415BF FD E1       0095*      pop iy ; restore
0415C1 C9          0096*      ret
0415C2             0097*  @val: ds 5
0415C7             0098*  
0415C7             0099*  ; same as INT_FP_ in fpp.asm but preserves B, which keeps any float stored in DED'E'B intact
0415C7             0100*  ; af will also return differently from the original
0415C7             0101*  ;INT - Floor function
0415C7             0102*  ;Result is integer numeric.
0415C7             0103*  ;
0415C7             0104*  int_fp_:
0415C7 C5          0105*      push bc ; preserve b
0415C8 3E 17       0106*      ld a,int_
0415CA CD BA 00 04 0107*      call FPP
0415CE F1          0108*      pop af ; restore b to a
0415CF 47          0109*      ld b,a ; restore b
0415D0 C9          0110*      RET
0415D1             0111*  
0415D1             0112*  ; convert floating point number to integer and store it in HLU
0415D1             0113*  ; inputs: HLH'L'C = floating point number
0415D1             0114*  ; outputs: HLU = integer part of the number
0415D1             0115*  ; destroys: all except DEU and U'D'E'B, index registers
0415D1             0116*  int2hlu:
0415D1 CD C7 15 04 0117*      call int_fp_
0415D5 7D          0118*      ld a,l
0415D6 F5          0119*      push af
0415D7 D9          0120*      exx
0415D8 E5          0121*      push hl
0415D9 D9          0122*      exx
0415DA E1          0123*      pop hl
0415DB F1          0124*      pop af
0415DC CD 9F 0E 04 0125*      call A_TO_HLU
0415E0 C9          0126*      ret
0415E1             0127*  
0415E1             0128*  ; convert polar coordinates to cartesian coordinates as deltas from the origin
0415E1             0129*  ; inputs: HLH'L'C = angle in radians
0415E1             0130*  ;         DED'E'B = radius
0415E1             0131*  ; outputs: HLH'L'C = dx
0415E1             0132*  ;          DED'E'B = dy
0415E1             0133*  polar_to_cartesian_fpp:
0415E1             0134*  ; store input parameters in scratch
0415E1 FD 21 39 16 0135*      ld iy,@angle
       04          
0415E6 CD 90 16 04 0136*      call store_float_iy_nor
0415EA FD 21 3E 16 0137*      ld iy,@radius
       04          
0415EF CD B4 16 04 0138*      call store_float_iy_alt
0415F3             0139*  ; compute dy = sin(angle) * radius
0415F3 3E 1D       0140*      ld a,sin
0415F5 CD BA 00 04 0141*      call FPP ; HLH'L'C = sin(angle)
0415F9 FD 21 3E 16 0142*      ld iy,@radius
       04          
0415FE CD C6 16 04 0143*      call fetch_float_iy_alt ; DED'E'B = radius
041602 3E 0A       0144*      ld a,fmul
041604 CD BA 00 04 0145*      call FPP ; HLH'L'C = sin(angle) * radius
041608 FD 21 43 16 0146*      ld iy,@scratch
       04          
04160D CD 90 16 04 0147*      call store_float_iy_nor ; @scratch = dy
041611             0148*  ; compute dx = cos(angle) * radius
041611 FD 21 39 16 0149*      ld iy,@angle
       04          
041616 CD A2 16 04 0150*      call fetch_float_iy_nor
04161A 3E 14       0151*      ld a,cos
04161C CD BA 00 04 0152*      call FPP ; HLH'L'C = cos(angle)
041620 FD 21 3E 16 0153*      ld iy,@radius
       04          
041625 CD C6 16 04 0154*      call fetch_float_iy_alt ; DED'E'B = radius
041629 3E 0A       0155*      ld a,fmul
04162B CD BA 00 04 0156*      call FPP ; HLH'L'C = cos(angle) * radius
04162F             0157*  ; restore dy from @scratch
04162F FD 21 43 16 0158*      ld iy,@scratch
       04          
041634 CD C6 16 04 0159*      call fetch_float_iy_alt
041638 C9          0160*      ret
041639             0161*  @angle: ds 5
04163E             0162*  @radius: ds 5
041643             0163*  @scratch: ds 5
041648             0164*  
041648             0165*  ; store HLH'L'C floating point number in a 40-bit buffer
041648             0166*  ; inputs: HLH'L'C = floating point number
041648             0167*  ;         ix = buffer address
041648             0168*  ; outputs: buffer filled with floating point number
041648             0169*  ; destroys: nothing
041648             0170*  store_float_nor:
041648 DD 71 00    0171*      ld (ix+0),c
04164B DD 75 03    0172*      ld (ix+3),l
04164E DD 74 04    0173*      ld (ix+4),h
041651 D9          0174*      exx
041652 DD 75 01    0175*      ld (ix+1),l
041655 DD 74 02    0176*      ld (ix+2),h
041658 D9          0177*      exx
041659 C9          0178*      ret
04165A             0179*  
04165A             0180*  ; fetch HLH'L'C floating point number from a 40-bit buffer
04165A             0181*  ; inputs: ix = buffer address
04165A             0182*  ; outputs: HLH'L'C = floating point number
04165A             0183*  ; destroys: HLH'L'C
04165A             0184*  fetch_float_nor:
04165A DD 4E 00    0185*      ld c,(ix+0)
04165D DD 6E 03    0186*      ld l,(ix+3)
041660 DD 66 04    0187*      ld h,(ix+4)
041663 D9          0188*      exx
041664 DD 6E 01    0189*      ld l,(ix+1)
041667 DD 66 02    0190*      ld h,(ix+2)
04166A D9          0191*      exx
04166B C9          0192*      ret
04166C             0193*  
04166C             0194*  ; store DED'E'B floating point number in a 40-bit buffer
04166C             0195*  ; inputs: DED'E'B = floating point number
04166C             0196*  ;         ix = buffer address
04166C             0197*  ; outputs: buffer filled with floating point number
04166C             0198*  ; destroys: nothing
04166C             0199*  store_float_alt:
04166C DD 70 00    0200*      ld (ix+0),b
04166F DD 73 03    0201*      ld (ix+3),e
041672 DD 72 04    0202*      ld (ix+4),d
041675 D9          0203*      exx
041676 DD 73 01    0204*      ld (ix+1),e
041679 DD 72 02    0205*      ld (ix+2),d
04167C D9          0206*      exx
04167D C9          0207*      ret
04167E             0208*  
04167E             0209*  ; fetch DED'E'B floating point number from a 40-bit buffer
04167E             0210*  ; inputs: ix = buffer address
04167E             0211*  ; outputs: DED'E'B = floating point number
04167E             0212*  ; destroys: DED'E'B
04167E             0213*  fetch_float_alt:
04167E DD 46 00    0214*      ld b,(ix+0)
041681 DD 5E 03    0215*      ld e,(ix+3)
041684 DD 56 04    0216*      ld d,(ix+4)
041687 D9          0217*      exx
041688 DD 5E 01    0218*      ld e,(ix+1)
04168B DD 56 02    0219*      ld d,(ix+2)
04168E D9          0220*      exx
04168F C9          0221*      ret
041690             0222*  
041690             0223*  
041690             0224*  ; store HLH'L'C floating point number in a 40-bit buffer
041690             0225*  ; inputs: HLH'L'C = floating point number
041690             0226*  ;         iy = buffer address
041690             0227*  ; outputs: buffer filled with floating point number
041690             0228*  ; destroys: nothing
041690             0229*  store_float_iy_nor:
041690 FD 71 00    0230*      ld (iy+0),c
041693 FD 75 03    0231*      ld (iy+3),l
041696 FD 74 04    0232*      ld (iy+4),h
041699 D9          0233*      exx
04169A FD 75 01    0234*      ld (iy+1),l
04169D FD 74 02    0235*      ld (iy+2),h
0416A0 D9          0236*      exx
0416A1 C9          0237*      ret
0416A2             0238*  
0416A2             0239*  ; fetch HLH'L'C floating point number from a 40-bit buffer
0416A2             0240*  ; inputs: iy = buffer address
0416A2             0241*  ; outputs: HLH'L'C = floating point number
0416A2             0242*  ; destroys: HLH'L'C
0416A2             0243*  fetch_float_iy_nor:
0416A2 FD 4E 00    0244*      ld c,(iy+0)
0416A5 FD 6E 03    0245*      ld l,(iy+3)
0416A8 FD 66 04    0246*      ld h,(iy+4)
0416AB D9          0247*      exx
0416AC FD 6E 01    0248*      ld l,(iy+1)
0416AF FD 66 02    0249*      ld h,(iy+2)
0416B2 D9          0250*      exx
0416B3 C9          0251*      ret
0416B4             0252*  
0416B4             0253*  ; store DED'E'B floating point number in a 40-bit buffer
0416B4             0254*  ; inputs: DED'E'B = floating point number
0416B4             0255*  ;         iy = buffer address
0416B4             0256*  ; outputs: buffer filled with floating point number
0416B4             0257*  ; destroys: nothing
0416B4             0258*  store_float_iy_alt:
0416B4 FD 70 00    0259*      ld (iy+0),b
0416B7 FD 73 03    0260*      ld (iy+3),e
0416BA FD 72 04    0261*      ld (iy+4),d
0416BD D9          0262*      exx
0416BE FD 73 01    0263*      ld (iy+1),e
0416C1 FD 72 02    0264*      ld (iy+2),d
0416C4 D9          0265*      exx
0416C5 C9          0266*      ret
0416C6             0267*  
0416C6             0268*  ; fetch DED'E'B floating point number from a 40-bit buffer
0416C6             0269*  ; inputs: iy = buffer address
0416C6             0270*  ; outputs: DED'E'B = floating point number
0416C6             0271*  ; destroys: DED'E'B
0416C6             0272*  fetch_float_iy_alt:
0416C6 FD 46 00    0273*      ld b,(iy+0)
0416C9 FD 5E 03    0274*      ld e,(iy+3)
0416CC FD 56 04    0275*      ld d,(iy+4)
0416CF D9          0276*      exx
0416D0 FD 5E 01    0277*      ld e,(iy+1)
0416D3 FD 56 02    0278*      ld d,(iy+2)
0416D6 D9          0279*      exx
0416D7 C9          0280*      ret
0416D8             0281*  
0416D8             0282*  ; print HLH'L'C floating point number in hex format
0416D8             0283*  ; inputs: HLH'L'C = floating point number
0416D8             0284*  print_float_hex_nor:
0416D8             0285*      PUSH_ALL
0416D8 08          0001*M         ex af,af'
0416D9 D9          0002*M         exx
0416DA F5          0003*M         push af
0416DB E5          0004*M         push hl
0416DC C5          0005*M         push bc
0416DD D5          0006*M         push de
0416DE             0007*M 
0416DE 08          0008*M         ex af,af'
0416DF D9          0009*M         exx
0416E0 F5          0010*M         push af
0416E1 E5          0011*M         push hl
0416E2 C5          0012*M         push bc
0416E3 D5          0013*M         push de
0416E4 DD E5       0014*M         push ix
0416E6 FD E5       0015*M         push iy
0416E8 C5          0286*      push bc ; preserve c
0416E9 CD DE 0E 04 0287*      call printHex16
0416ED 3E 2E       0288*      ld a,'.'
0416EF 5B D7       0289*      rst.lil 10h
0416F1 D9          0290*      exx
0416F2 CD DE 0E 04 0291*      call printHex16
0416F6 D9          0292*      exx
0416F7 3E 5E       0293*      ld a,'^'
0416F9 5B D7       0294*      rst.lil 10h
0416FB C1          0295*      pop bc ; restore c
0416FC 79          0296*      ld a,c
0416FD CD E4 0E 04 0297*      call printHex8
041701             0298*      POP_ALL
041701 FD E1       0001*M         pop iy
041703 DD E1       0002*M         pop ix
041705 D1          0003*M         pop de
041706 C1          0004*M         pop bc
041707 E1          0005*M         pop hl
041708 F1          0006*M         pop af
041709 08          0007*M         ex af,af'
04170A D9          0008*M         exx
04170B             0009*M 
04170B D1          0010*M         pop de
04170C C1          0011*M         pop bc
04170D E1          0012*M         pop hl
04170E F1          0013*M         pop af
04170F 08          0014*M         ex af,af'
041710 D9          0015*M         exx
041711 C9          0299*      ret
041712             0300*  
041712             0301*  ; print DED'E'B floating point number in hex format
041712             0302*  ; inputs: DED'E'B = floating point number
041712             0303*  print_float_hex_alt:
041712             0304*      PUSH_ALL
041712 08          0001*M         ex af,af'
041713 D9          0002*M         exx
041714 F5          0003*M         push af
041715 E5          0004*M         push hl
041716 C5          0005*M         push bc
041717 D5          0006*M         push de
041718             0007*M 
041718 08          0008*M         ex af,af'
041719 D9          0009*M         exx
04171A F5          0010*M         push af
04171B E5          0011*M         push hl
04171C C5          0012*M         push bc
04171D D5          0013*M         push de
04171E DD E5       0014*M         push ix
041720 FD E5       0015*M         push iy
041722 C5          0305*      push bc ; preserve b
041723 EB          0306*      ex de,hl
041724 CD DE 0E 04 0307*      call printHex16
041728 EB          0308*      ex de,hl
041729 3E 2E       0309*      ld a,'.'
04172B 5B D7       0310*      rst.lil 10h
04172D D9          0311*      exx
04172E EB          0312*      ex de,hl
04172F CD DE 0E 04 0313*      call printHex16
041733 EB          0314*      ex de,hl
041734 D9          0315*      exx
041735 3E 5E       0316*      ld a,'^'
041737 5B D7       0317*      rst.lil 10h
041739 F1          0318*      pop af ; restore b to a
04173A CD E4 0E 04 0319*      call printHex8
04173E             0320*      POP_ALL
04173E FD E1       0001*M         pop iy
041740 DD E1       0002*M         pop ix
041742 D1          0003*M         pop de
041743 C1          0004*M         pop bc
041744 E1          0005*M         pop hl
041745 F1          0006*M         pop af
041746 08          0007*M         ex af,af'
041747 D9          0008*M         exx
041748             0009*M 
041748 D1          0010*M         pop de
041749 C1          0011*M         pop bc
04174A E1          0012*M         pop hl
04174B F1          0013*M         pop af
04174C 08          0014*M         ex af,af'
04174D D9          0015*M         exx
04174E C9          0321*      ret
04174F             0322*  
04174F             0323*  print_floats_hex:
04174F CD D8 16 04 0324*      call print_float_hex_nor
041753 3E 20       0325*      ld a,' '
041755 5B D7       0326*      rst.lil 10h
041757 CD 12 17 04 0327*      call print_float_hex_alt
04175B C9          0328*      ret
04175C             0329*  
04175C             0330*  ; print a floating point number in decimal format
04175C             0331*  ; inputs: HL'H'L'C is the number to print
04175C             0332*  ; outputs: number printed to screen
04175C             0333*  ;          ACCS null-terminated string representation of the number
04175C             0334*  ; destroys: everything except ix
04175C             0335*  print_float_dec:
04175C             0336*  print_float_dec_nor:
04175C DD E5       0337*      push ix             ; preserve
04175E             0338*  
04175E             0339*  ; back up floats in normal and alternate registers
04175E DD 21 9F 17 0340*      ld ix,@float_nor
       04          
041763 CD 48 16 04 0341*      call store_float_nor
041767 DD 21 A4 17 0342*      ld ix,@float_alt
       04          
04176C CD 6C 16 04 0343*      call store_float_alt
041770             0344*  
041770             0345*  ; convert the number to a string
041770 11 00 20 04 0346*      ld de,ACCS          ; point to the string accumulator
041774 DD 21 9C 17 0347*      ld ix,@G9-1         ; get the format code for the number
       04          
041779 CD B9 08 04 0348*      call STR_FP         ; convert the number to a string
04177D EB          0349*      ex de,hl            ; point to end of the string
04177E 36 00       0350*      ld (hl),0           ; null-terminate the string
041780 21 00 20 04 0351*      ld hl,ACCS          ; point to the string accumulator
041784 CD B6 0E 04 0352*      call printString
041788             0353*  
041788             0354*  ; restore floats in normal and alternate registers
041788 DD 21 9F 17 0355*      ld ix,@float_nor
       04          
04178D CD 5A 16 04 0356*      call fetch_float_nor
041791 DD 21 A4 17 0357*      ld ix,@float_alt
       04          
041796 CD 7E 16 04 0358*      call fetch_float_alt
04179A             0359*  
04179A             0360*  ; cleanup and go home
04179A DD E1       0361*      pop ix              ; restore
04179C C9          0362*      ret
04179D 09 00       0363*  @G9:			DW    9
04179F             0364*  @float_nor: ds 5
0417A4             0365*  @float_alt: ds 5
0417A9             0366*  
0417A9             0367*  print_float_dec_alt:
0417A9 CD 9D 15 04 0368*      CALL SWAP
0417AD CD 5C 17 04 0369*      CALL print_float_dec_nor
0417B1 CD 9D 15 04 0370*      CALL SWAP
0417B5 C9          0371*      ret
0417B6             0372*  
0417B6             0373*  ;PI - Return PI (3.14159265)
0417B6             0374*  ;Result is floating-point numeric.
0417B6             0375*  ;
0417B6 11 0F 49 00 0376*  pi_alt:			LD      DE,0x490F
0417BA D9          0377*          		EXX
0417BB 11 A2 DA 00 0378*          		LD      DE,0xDAA2
0417BF D9          0379*          		EXX
0417C0 06 81       0380*          		LD      B,0x81
0417C2 AF          0381*          		XOR     A               ;NUMERIC MARKER
0417C3 C9          0382*          		RET
0417C4             0383*  
0417C4             0384*  ;PI - Return PI * 2 (6.28318531)
0417C4             0385*  ;Result is floating-point numeric.
0417C4             0386*  ;
0417C4 11 0F 49 00 0387*  pi2_alt:		LD      DE,0x490F
0417C8 D9          0388*          		EXX
0417C9 11 A3 DA 00 0389*          		LD      DE,0xDAA3
0417CD D9          0390*          		EXX
0417CE 06 82       0391*          		LD      B,0x82
0417D0 AF          0392*          		XOR     A               ;NUMERIC MARKER
0417D1 C9          0393*          		RET
0417D2             0058       include "vdu.inc"
0417D2             0001*  
0417D2             0002*  ; VDU 30: Home cursor
0417D2             0003*  vdu_home_cursor:
0417D2 3E 1E       0004*      ld a,30
0417D4 5B D7       0005*  	rst.lil $10
0417D6 C9          0006*  	ret
0417D7             0007*  
0417D7             0008*  cursor_on:
0417D7 21 E2 17 04 0009*  	ld hl,@cmd
0417DB 01 03 00 00 0010*  	ld bc,@end-@cmd
0417DF 5B DF       0011*  	rst.lil $18
0417E1 C9          0012*  	ret
0417E2             0013*  @cmd:
0417E2 17 01 01    0014*  	db 23,1,1
0417E5             0015*  @end:
0417E5             0016*  
0417E5             0017*  cursor_off:
0417E5 21 F0 17 04 0018*  	ld hl,@cmd
0417E9 01 03 00 00 0019*  	ld bc,@end-@cmd
0417ED 5B DF       0020*  	rst.lil $18
0417EF C9          0021*  	ret
0417F0             0022*  @cmd:
0417F0 17 01 00    0023*  	db 23,1,0
0417F3             0024*  @end:
0417F3             0025*  
0417F3             0026*  ; VDU 9: Move cursor forward one character
0417F3             0027*  vdu_cursor_forward:
0417F3 3E 09       0028*      ld a,9
0417F5 5B D7       0029*  	rst.lil $10
0417F7 C9          0030*  	ret
0417F8             0031*  
0417F8             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0417F8             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0417F8             0034*  vdu_move_cursor:
0417F8 ED 43 09 18 0035*      ld (@x0),bc
       04          
0417FD 21 08 18 04 0036*  	ld hl,@cmd
041801 01 03 00 00 0037*  	ld bc,@end-@cmd
041805 5B DF       0038*  	rst.lil $18
041807 C9          0039*  	ret
041808 1F          0040*  @cmd: 	db 31
041809 00          0041*  @x0:	db 0
04180A 00          0042*  @y0: 	db 0
04180B 00          0043*  @end: 	db 0 ; padding
04180C             0044*  
04180C             0045*  ; VDU 12: Clear text area (CLS)
04180C             0046*  vdu_cls:
04180C 3E 0C       0047*      ld a,12
04180E 5B D7       0048*  	rst.lil $10
041810 C9          0049*  	ret
041811             0050*  
041811             0051*  vdu_flip:
041811 21 1C 18 04 0052*  	ld hl,@cmd
041815 01 03 00 00 0053*  	ld bc,@end-@cmd
041819 5B DF       0054*  	rst.lil $18
04181B C9          0055*  	ret
04181C 17 00 C3    0056*  @cmd: db 23,0,0xC3
04181F             0057*  @end:
04181F             0058*  
04181F             0059*  ; VDU 16: Clear graphics area (CLG)
04181F             0060*  vdu_clg:
04181F 3E 10       0061*      ld a,16
041821 5B D7       0062*  	rst.lil $10
041823 C9          0063*  	ret
041824             0064*  
041824             0065*  ; COLOUR MODES
041824             0066*  ; Mode	Effect
041824             0067*  ; 0	Set on-screen pixel to target colour value
041824             0068*  ; 1	OR value with the on-screen pixel
041824             0069*  ; 2	AND value with the on-screen pixel
041824             0070*  ; 3	XOR value with the on-screen pixel
041824             0071*  ; 4	Invert the on-screen pixel
041824             0072*  ; 5	No operation
041824             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041824             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041824             0075*  
041824             0076*  ; VDU 17, colour: Define text colour (COLOUR)
041824             0077*  vdu_colour_text:
041824 32 34 18 04 0078*  	ld (@arg),a
041828 21 33 18 04 0079*  	ld hl,@cmd
04182C 01 02 00 00 0080*  	ld bc,@end-@cmd
041830 5B DF       0081*  	rst.lil $18
041832 C9          0082*  	ret
041833 11          0083*  @cmd: db 17
041834 00          0084*  @arg: db 0
041835             0085*  @end:
041835             0086*  
041835             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041835             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041835             0089*  vdu_gcol:
041835 32 4A 18 04 0090*  	ld (@mode),a
041839 79          0091*      ld a,c
04183A 32 4B 18 04 0092*      ld (@col),a
04183E 21 49 18 04 0093*  	ld hl,@cmd
041842 01 03 00 00 0094*  	ld bc,@end-@cmd
041846 5B DF       0095*  	rst.lil $18
041848 C9          0096*  	ret
041849 12          0097*  @cmd:  db 18
04184A 00          0098*  @mode: db 0
04184B 00          0099*  @col:  db 0
04184C             0100*  @end:
04184C             0101*  
04184C             0102*  
04184C             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
04184C             0104*  ; MIND THE LITTLE-ENDIANESS
04184C             0105*  ; inputs: c=left,b=bottom,e=right,d=top
04184C             0106*  ; outputs; nothing
04184C             0107*  ; destroys: a might make it out alive
04184C             0108*  vdu_set_txt_viewport:
04184C ED 43 62 18 0109*      ld (@lb),bc
       04          
041851 ED 53 64 18 0110*  	ld (@rt),de
       04          
041856 21 61 18 04 0111*  	ld hl,@cmd
04185A 01 05 00 00 0112*  	ld bc,@end-@cmd
04185E 5B DF       0113*  	rst.lil $18
041860 C9          0114*  	ret
041861 1C          0115*  @cmd:   db 28 ; set text viewport command
041862 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
041864 00 00       0117*  @rt: 	dw 0x0000 ; set by de
041866 00          0118*  @end:   db 0x00	  ; padding
041867             0119*  
041867             0120*  ; Wait for VBLANK interrupt
041867             0121*  vdu_vblank:
041867 DD E5       0122*      PUSH 	IX
041869             0123*  	MOSCALL	mos_sysvars
041869 3E 08       0001*M 			LD	A, function
04186B 49 CF       0002*M 			RST.LIS	08h
04186D DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
041870             0125*  @wait:
041870 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
041873 28 FB       0127*      JR	Z, @wait
041875 DD E1       0128*      POP	IX
041877 C9          0129*      RET
041878             0130*  
041878             0131*  ; VDU 29, x; y;: Set graphics origin
041878             0132*  ; This command sets the graphics origin.
041878             0133*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041878             0134*  ; inputs: bc=x0,de=y0
041878             0135*  ; outputs; nothing
041878             0136*  ; destroys: a might make it out alive
041878             0137*  vdu_set_gfx_origin:
041878 ED 43 8E 18 0138*      ld (@x0),bc
       04          
04187D ED 53 90 18 0139*      ld (@y0),de
       04          
041882 21 8D 18 04 0140*      ld hl,@cmd
041886 01 05 00 00 0141*      ld bc,@end-@cmd
04188A 5B DF       0142*      rst.lil $18
04188C C9          0143*      ret
04188D 1D          0144*  @cmd:   db 29 ; set graphics origin command
04188E 00 00       0145*  @x0: 	dw 0x0000 ; set by bc
041890 00 00       0146*  @y0: 	dw 0x0000 ; set by de
041892 00          0147*  @end:   db 0x00	  ; padding
041893             0148*  
041893             0149*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041893             0150*  ; NOTE: the order of the y-coordinate parameters are inverted
041893             0151*  ; 	because we have turned off logical screen scaling
041893             0152*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041893             0153*  ; outputs; nothing
041893             0154*  ; destroys: a might make it out alive
041893             0155*  vdu_set_gfx_viewport:
041893 ED 43 B3 18 0156*      ld (@x0),bc
       04          
041898 FD 22 B5 18 0157*      ld (@y1),iy
       04          
04189D DD 22 B7 18 0158*  	ld (@x1),ix
       04          
0418A2 ED 53 B9 18 0159*  	ld (@y0),de
       04          
0418A7 21 B2 18 04 0160*  	ld hl,@cmd
0418AB 01 09 00 00 0161*  	ld bc,@end-@cmd
0418AF 5B DF       0162*  	rst.lil $18
0418B1 C9          0163*  	ret
0418B2 18          0164*  @cmd:   db 24 ; set graphics viewport command
0418B3 00 00       0165*  @x0: 	dw 0x0000 ; set by bc
0418B5 00 00       0166*  @y1: 	dw 0x0000 ; set by iy
0418B7 00 00       0167*  @x1: 	dw 0x0000 ; set by ix
0418B9 00 00       0168*  @y0: 	dw 0x0000 ; set by de
0418BB 00          0169*  @end:   db 0x00	  ; padding
0418BC             0170*  
0418BC             0171*  ; SCREEN MODES
0418BC             0172*  ; ===============================
0418BC             0173*  ; Mode  Horz  Vert  Cols  Refresh
0418BC             0174*  ; ---   ----  ----  ----  -------
0418BC             0175*  ; 11    320   240   2     60hz
0418BC             0176*  ; 139   320   240   2     60hz
0418BC             0177*  ; 23    512   384   2     60hz
0418BC             0178*  ; 151   512   384   2     60hz
0418BC             0179*  ; 6     640   240   2     60hz
0418BC             0180*  ; 134   640   240   2     60hz
0418BC             0181*  ; 2     640   480   2     60hz
0418BC             0182*  ; 130   640   480   2     60hz
0418BC             0183*  ; 17    800   600   2     60hz
0418BC             0184*  ; 145   800   600   2     60hz
0418BC             0185*  ; 18    1024  768   2     60hz
0418BC             0186*  ; 146   1024  768   2     60hz
0418BC             0187*  ; ---   ----  ----  ----  -------
0418BC             0188*  ; 10    320   240   4     60hz
0418BC             0189*  ; 138   320   240   4     60hz
0418BC             0190*  ; 22    512   384   4     60hz
0418BC             0191*  ; 150   512   384   4     60hz
0418BC             0192*  ; 5     640   240   4     60hz
0418BC             0193*  ; 133   640   240   4     60hz
0418BC             0194*  ; 1     640   480   4     60hz
0418BC             0195*  ; 129   640   480   4     60hz
0418BC             0196*  ; 16    800   600   4     60hz
0418BC             0197*  ; 19    1024  768   4     60hz
0418BC             0198*  ; ---   ----  ----  ----  -------
0418BC             0199*  ; 9     320   240   16    60hz
0418BC             0200*  ; 137   320   240   16    60hz
0418BC             0201*  ; 21    512   384   16    60hz
0418BC             0202*  ; 149   512   384   16    60hz
0418BC             0203*  ; 4     640   240   16    60hz
0418BC             0204*  ; 132   640   240   16    60hz
0418BC             0205*  ; 0     640   480   16    60hz
0418BC             0206*  ; 7     n/a   n/a   16    60hz
0418BC             0207*  ; ---   ----  ----  ----  -------
0418BC             0208*  ; 8     320   240   64    60hz
0418BC             0209*  ; 136   320   240   64    60hz
0418BC             0210*  ; 20    512   384   64    60hz
0418BC             0211*  ; 3     640   240   64    60hz
0418BC             0212*  ; ---   ----  ----  ----  -------
0418BC             0213*  vdu_set_screen_mode:
0418BC 32 CC 18 04 0214*  	ld (@arg),a
0418C0 21 CB 18 04 0215*  	ld hl,@cmd
0418C4 01 02 00 00 0216*  	ld bc,@end-@cmd
0418C8 5B DF       0217*  	rst.lil $18
0418CA C9          0218*  	ret
0418CB 16          0219*  @cmd: db 22 ; set screen mode
0418CC 00          0220*  @arg: db 0  ; screen mode parameter
0418CD             0221*  @end:
0418CD             0222*  
0418CD             0223*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0418CD             0224*  ; inputs: a is scaling mode, 1=on, 0=off
0418CD             0225*  ; note: default setting on boot is scaling ON
0418CD             0226*  vdu_set_scaling:
0418CD 32 DF 18 04 0227*  	ld (@arg),a
0418D1 21 DC 18 04 0228*  	ld hl,@cmd
0418D5 01 04 00 00 0229*  	ld bc,@end-@cmd
0418D9 5B DF       0230*  	rst.lil $18
0418DB C9          0231*  	ret
0418DC 17 00 C0    0232*  @cmd: db 23,0,0xC0
0418DF 00          0233*  @arg: db 0  ; scaling on/off
0418E0             0234*  @end:
0418E0             0235*  
0418E0             0236*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0418E0             0237*  ; inputs: hl=bufferId
0418E0             0238*  vdu_buff_select:
0418E0 22 F2 18 04 0239*  	ld (@bufferId),hl
0418E4 21 EF 18 04 0240*  	ld hl,@cmd
0418E8 01 05 00 00 0241*  	ld bc,@end-@cmd
0418EC 5B DF       0242*  	rst.lil $18
0418EE C9          0243*  	ret
0418EF 17 1B 20    0244*  @cmd: db 23,27,0x20
0418F2 00 00       0245*  @bufferId: dw 0x0000
0418F4 00          0246*  @end: db 0x00 ; padding
0418F5             0247*  
0418F5             0248*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0418F5             0249*  ; inputs: a=format; bc=width; de=height
0418F5             0250*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0418F5             0251*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0418F5             0252*  ; 0 	RGBA8888 (4-bytes per pixel)
0418F5             0253*  ; 1 	RGBA2222 (1-bytes per pixel)
0418F5             0254*  ; 2 	Mono/Mask (1-bit per pixel)
0418F5             0255*  ; 3 	Reserved for internal use by VDP (“native” format)
0418F5             0256*  vdu_bmp_create:
0418F5 ED 43 11 19 0257*      ld (@width),bc
       04          
0418FA ED 53 13 19 0258*      ld (@height),de
       04          
0418FF 32 15 19 04 0259*      ld (@fmt),a
041903 21 0E 19 04 0260*  	ld hl,@cmd
041907 01 08 00 00 0261*  	ld bc,@end-@cmd
04190B 5B DF       0262*  	rst.lil $18
04190D C9          0263*  	ret
04190E 17 1B 21    0264*  @cmd:       db 23,27,0x21
041911 00 00       0265*  @width:     dw 0x0000
041913 00 00       0266*  @height:    dw 0x0000
041915 00          0267*  @fmt:       db 0x00
041916             0268*  @end:
041916             0269*  
041916             0270*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041916             0271*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041916             0272*  vdu_load_img_rgba2_to_8:
041916             0273*  ; backup the target buffer id and image dimensions
041916 E5          0274*      push hl
041917 D5          0275*      push de
041918 C5          0276*      push bc
041919             0277*  ; load the rgba2 image to working buffer 65534
041919 21 FE FF 00 0278*      ld hl,65534 ; temporary working buffer id
04191D CD 20 1A 04 0279*  	call vdu_load_buffer_from_file
041921             0280*  ; restore the image dimensions and target buffer id
041921 C1          0281*      pop bc
041922 D1          0282*      pop de
041923 E1          0283*      pop hl
041924             0284*  ; fall through to vdu_rgba2_to_8
041924             0285*  
041924             0286*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041924             0287*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041924             0288*  ; the "expand bitmap" command is:
041924             0289*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041924             0290*  ; and then to reverse the byte order to fix endian-ness:
041924             0291*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041924             0292*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041924             0293*  ; VDU 23,27,&20,targetBufferID%;
041924             0294*  ; VDU 23,27,&21,width%;height%;0
041924             0295*  ; -------------------------------------------------------------------
041924             0296*  ; inputs: bc,de image width,height ; hl = targetBufferId
041924             0297*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041924             0298*  vdu_rgba2_to_8:
041924             0299*  ; load the image dimensions and buffer id parameters
041924 ED 43 80 19 0300*      ld (@width),bc
       04          
041929 ED 53 82 19 0301*      ld (@height),de
       04          
04192E 22 65 19 04 0302*      ld (@bufferId0),hl
041932 22 72 19 04 0303*      ld (@bufferId2),hl
041936 22 7B 19 04 0304*      ld (@bufferId1),hl
04193A             0305*  ; clean up bytes that got stomped on by the ID loads
04193A 3E 48       0306*      ld a,0x48
04193C 32 67 19 04 0307*      ld (@bufferId0+2),a
041940 3E 17       0308*      ld a,23
041942 32 7D 19 04 0309*      ld (@bufferId1+2),a
041946 3E 18       0310*      ld a,24
041948 32 74 19 04 0311*      ld (@bufferId2+2),a
04194C AF          0312*      xor a
04194D 32 84 19 04 0313*      ld (@height+2),a
041951             0314*  ; send the vdu command strings
041951 21 5C 19 04 0315*      ld hl,@beg
041955 01 29 00 00 0316*      ld bc,@end-@beg
041959 5B DF       0317*      rst.lil $18
04195B C9          0318*      ret
04195C             0319*  @beg:
04195C             0320*  ; Command 14: Consolidate blocks in a buffer
04195C             0321*  ; VDU 23, 0, &A0, bufferId; 14
04195C 17 00 A0    0322*      db 23,0,0xA0
04195F FE FF       0323*      dw 65534 ; workingBufferId
041961 0E          0324*      db 14 ; consolidate blocks
041962             0325*  ; the "expand bitmap" command is:
041962             0326*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041962 17 00 A0    0327*      db 23,0,0xA0
041965 00 00       0328*  @bufferId0: dw 0x0000 ; targetBufferId
041967 48          0329*      db 0x48 ; given as decimal command 72 in the docs
041968 02          0330*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041969 FE FF       0331*      dw 65534 ; sourceBufferId
04196B 00 7F BF FF 0332*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04196F             0333*  ; reverse the byte order to fix endian-ness:
04196F             0334*  ; Command 24: Reverse the order of data of blocks within a buffer
04196F             0335*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04196F             0336*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04196F 17 00 A0    0337*      db 23,0,0xA0
041972 00 00       0338*  @bufferId2:    dw 0x0000 ; targetBufferId
041974 18          0339*      db 24 ; reverse byte order
041975 04          0340*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041976 04 00       0341*      dw 4 ; size (4 bytes)
041978             0342*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041978             0343*  ; VDU 23,27,&20,targetBufferID%;
041978 17 1B 20    0344*      db 23,27,0x20 ; select bitmap
04197B 00 00       0345*  @bufferId1: dw 0x0000 ; targetBufferId
04197D             0346*  ; VDU 23,27,&21,width%;height%;0
04197D 17 1B 21    0347*      db 23,27,0x21 ; create bitmap from buffer
041980 00 00       0348*  @width: dw 0x0000
041982 00 00       0349*  @height: dw 0x0000
041984 00          0350*      db 0x00 ; rgba8888 format
041985             0351*  @end:
041985             0352*  
041985             0353*  ; scratch variables
041985 00 00 00    0354*  bufferId0: dl 0x000000
041988 00 00 00    0355*  bufferId1: dl 0x000000
04198B             0356*  
04198B             0357*  ; load a vdu buffer from local memory
04198B             0358*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
04198B             0359*  vdu_load_buffer:
04198B ED 43 B4 19 0360*      ld (@length),bc
       04          
041990 D5          0361*      push de ; save data pointer
041991             0362*  ; send the vdu command string
041991 7D          0363*      ld a,l
041992 32 B1 19 04 0364*      ld (@bufferId),a
041996 7C          0365*      ld a,h
041997 32 B2 19 04 0366*      ld (@bufferId+1),a
04199B 21 AE 19 04 0367*      ld hl,@cmd
04199F 01 08 00 00 0368*      ld bc,@end-@cmd
0419A3 5B DF       0369*      rst.lil $18
0419A5             0370*  ; send the buffer data
0419A5 E1          0371*      pop hl ; pointer to data
0419A6 ED 4B B4 19 0372*      ld bc,(@length)
       04          
0419AB 5B DF       0373*      rst.lil $18 ; send it
0419AD C9          0374*      ret
0419AE             0375*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0419AE 17 00 A0    0376*  @cmd:       db 23,0,0xA0
0419B1 00 00       0377*  @bufferId:	dw 0x0000
0419B3 00          0378*  		    db 0 ; load buffer
0419B4 00 00       0379*  @length:	dw 0x0000
0419B6 00          0380*  @end: db 0 ; padding
0419B7             0381*  
0419B7             0382*  ; clear a buffer
0419B7             0383*  ; inputs: hl = bufferId
0419B7             0384*  vdu_clear_buffer:
0419B7 7D          0385*      ld a,l
0419B8 32 CF 19 04 0386*      ld (@bufferId),a
0419BC 7C          0387*      ld a,h
0419BD 32 D0 19 04 0388*      ld (@bufferId+1),a
0419C1 21 CC 19 04 0389*      ld hl,@cmd
0419C5 01 06 00 00 0390*      ld bc,@end-@cmd
0419C9 5B DF       0391*      rst.lil $18
0419CB C9          0392*      ret
0419CC 17 00 A0    0393*  @cmd:       db 23,0,0xA0
0419CF 00 00       0394*  @bufferId:	dw 0x0000
0419D1 02          0395*  		    db 2 ; clear buffer
0419D2             0396*  @end:
0419D2             0397*  
0419D2             0398*  vdu_clear_all_buffers:
0419D2             0399*  ; clear all buffers
0419D2 21 DD 19 04 0400*      ld hl,@beg
0419D6 01 06 00 00 0401*      ld bc,@end-@beg
0419DA 5B DF       0402*      rst.lil $18
0419DC C9          0403*      ret
0419DD 17 00 A0    0404*  @beg: db 23,0,$A0
0419E0 FF FF       0405*        dw -1 ; clear all buffers
0419E2 02          0406*        db 2  ; command 2: clear a buffer
0419E3             0407*  @end:
0419E3             0408*  
0419E3             0409*  ; Command 14: Consolidate blocks in a buffer
0419E3             0410*  vdu_consolidate_buffer:
0419E3             0411*  ; set parameters for vdu call
0419E3 7D          0412*      ld a,l
0419E4 32 FB 19 04 0413*      ld (@bufferId),a
0419E8 7C          0414*      ld a,h
0419E9 32 FC 19 04 0415*      ld (@bufferId+1),a
0419ED 21 F8 19 04 0416*      ld hl,@beg
0419F1 01 06 00 00 0417*      ld bc,@end-@beg
0419F5 5B DF       0418*      rst.lil $18
0419F7 C9          0419*      ret
0419F8             0420*  ; VDU 23, 0, &A0, bufferId; 14
0419F8 17 00 A0    0421*  @beg: db 23,0,0xA0
0419FB 00 00       0422*  @bufferId: dw 0x0000
0419FD 0E          0423*             db 14
0419FE             0424*  @end:
0419FE             0425*  
0419FE             0426*  ; load an image file to a buffer and make it a bitmap
0419FE             0427*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0419FE             0428*  vdu_load_img:
0419FE             0429*  ; back up image type and dimension parameters
0419FE 22 85 19 04 0430*      ld (bufferId0),hl
041A02 F5          0431*      push af
041A03 C5          0432*  	push bc
041A04 D5          0433*  	push de
041A05             0434*  ; load the image
041A05 CD 20 1A 04 0435*  	call vdu_load_buffer_from_file
041A09             0436*  ; now make it a bitmap
041A09 2A 85 19 04 0437*      ld hl,(bufferId0)
041A0D CD E3 19 04 0438*      call vdu_consolidate_buffer
041A11 2A 85 19 04 0439*      ld hl,(bufferId0)
041A15 CD E0 18 04 0440*      call vdu_buff_select
041A19 D1          0441*  	pop de ; image height
041A1A C1          0442*  	pop bc ; image width
041A1B F1          0443*  	pop af ; image type
041A1C C3 F5 18 04 0444*  	jp vdu_bmp_create ; will return to caller from there
041A20             0445*  
041A20             0446*  ; inputs: hl = bufferId; iy = pointer to filename
041A20             0447*  vdu_load_buffer_from_file:
041A20 22 85 19 04 0448*      ld (bufferId0),hl
041A24             0449*  
041A24             0450*  ; clear target buffer
041A24 CD B7 19 04 0451*      call vdu_clear_buffer
041A28             0452*  
041A28             0453*  ; open the file in read mode
041A28             0454*  ; Open a file
041A28             0455*  ; HLU: Filename
041A28             0456*  ;   C: Mode
041A28             0457*  ; Returns:
041A28             0458*  ;   A: Filehandle, or 0 if couldn't open
041A28 FD E5       0459*  	push iy ; pointer to filename
041A2A E1          0460*  	pop hl
041A2B 0E 01       0461*  	ld c,fa_read
041A2D             0462*      MOSCALL mos_fopen
041A2D 3E 0A       0001*M 			LD	A, function
041A2F 49 CF       0002*M 			RST.LIS	08h
041A31 32 6C 1A 04 0463*      ld (@filehandle),a
041A35             0464*  
041A35             0465*  @read_file:
041A35             0466*  ; Read a block of data from a file
041A35             0467*  ;   C: Filehandle
041A35             0468*  ; HLU: Pointer to where to write the data to
041A35             0469*  ; DEU: Number of bytes to read
041A35             0470*  ; Returns:
041A35             0471*  ; DEU: Number of bytes read
041A35 3A 6C 1A 04 0472*      ld a,(@filehandle)
041A39 4F          0473*      ld c,a
041A3A 21 00 E0 B7 0474*      ld hl,filedata
041A3E 11 00 20 00 0475*      ld de,8192 ; max we can read into onboard sram at one time
041A42             0476*      MOSCALL mos_fread
041A42 3E 1A       0001*M 			LD	A, function
041A44 49 CF       0002*M 			RST.LIS	08h
041A46             0477*  
041A46             0478*  ; ; DEBUG: print chunk size
041A46             0479*  ;     push de
041A46             0480*  ;     pop hl
041A46             0481*  ;     call printDec
041A46             0482*  ;     call printNewLine
041A46             0483*  
041A46             0484*  ; test de for zero bytes read
041A46 21 00 00 00 0485*      ld hl,0
041A4A AF          0486*      xor a ; clear carry
041A4B ED 52       0487*      sbc hl,de
041A4D CA 63 1A 04 0488*      jp z,@close_file
041A51             0489*  
041A51             0490*  ; load a vdu buffer from local memory
041A51             0491*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041A51 2A 85 19 04 0492*      ld hl,(bufferId0)
041A55 D5          0493*      push de ; chunksize
041A56 C1          0494*      pop bc
041A57 11 00 E0 B7 0495*      ld de,filedata
041A5B CD 8B 19 04 0496*      call vdu_load_buffer
041A5F             0497*  
041A5F             0498*  ; ; print progress breadcrumbs
041A5F             0499*  ;     ld a,'.'
041A5F             0500*  ;     rst.lil 10h
041A5F             0501*  
041A5F             0502*  ; read the next block
041A5F C3 35 1A 04 0503*      jp @read_file
041A63             0504*  
041A63             0505*  ; close the file
041A63             0506*  @close_file:
041A63 3A 6C 1A 04 0507*      ld a,(@filehandle)
041A67             0508*      MOSCALL mos_fclose
041A67 3E 0B       0001*M 			LD	A, function
041A69 49 CF       0002*M 			RST.LIS	08h
041A6B C9          0509*      ret ; vdu_load_buffer_from_file
041A6C             0510*  
041A6C 00          0511*  @filehandle: db 0 ; file handle
041A6D 00 00 00    0512*  @fil: dl 0 ; pointer to FIL struct
041A70             0513*  
041A70 00 00 00    0514*  @chunkpointer: dl 0 ; pointer to current chunk
041A73             0515*  
041A73             0516*  ; File information structure (FILINFO)
041A73             0517*  @filinfo:
041A73 00 00 00 00 0518*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041A77 00 00       0519*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041A79 00 00       0520*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041A7B 00          0521*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041A7C 00 00 00 00 0522*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041A89 00 00 00 00 0523*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041B89             0059       include "parse_args.inc"
041B89             0001*  ; Parse the parameter string into a C array
041B89             0002*  ; Parameters
041B89             0003*  ; - HL: Address of parameter string
041B89             0004*  ; - IX: Address for array pointer storage
041B89             0005*  ; Returns:
041B89             0006*  ; -  C: Number of parameters parsed
041B89             0007*  ;
041B89 01 04 00 04 0008*  _parse_params:		LD	BC, _exec_name
041B8D DD 0F 00    0009*  			LD	(IX+0), BC		; ARGV[0] = the executable name
041B90 ED 32 03    0010*  			LEA     IX, IX+3
041B93 CD CB 1B 04 0011*  			CALL	_skip_spaces		; Skip HL past any leading spaces
041B97             0012*  ;
041B97 01 01 00 00 0013*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
041B9B 06 0F       0014*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
041B9D             0015*  ;
041B9D             0016*  _parse_params_1:
041B9D C5          0017*  			PUSH	BC			; Stack ARGC
041B9E E5          0018*  			PUSH	HL			; Stack start address of token
041B9F CD BC 1B 04 0019*  			CALL	_get_token		; Get the next token
041BA3 79          0020*  			LD	A, C			; A: Length of the token in characters
041BA4 D1          0021*  			POP	DE			; Start address of token (was in HL)
041BA5 C1          0022*  			POP	BC			; ARGC
041BA6 B7          0023*  			OR	A			; Check for A=0 (no token found) OR at end of string
041BA7 C8          0024*  			RET	Z
041BA8             0025*  ;
041BA8 DD 1F 00    0026*  			LD	(IX+0), DE		; Store the pointer to the token
041BAB E5          0027*  			PUSH	HL			; DE=HL
041BAC D1          0028*  			POP	DE
041BAD CD CB 1B 04 0029*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
041BB1 AF          0030*  			XOR	A
041BB2 12          0031*  			LD	(DE), A			; Zero-terminate the token
041BB3 ED 32 03    0032*  			LEA  	IX, IX+3			; Advance to next pointer position
041BB6 0C          0033*  			INC	C			; Increment ARGC
041BB7 79          0034*  			LD	A, C			; Check for C >= A
041BB8 B8          0035*  			CP	B
041BB9 38 E2       0036*  			JR	C, _parse_params_1	; And loop
041BBB C9          0037*  			RET
041BBC             0038*  
041BBC             0039*  ; Get the next token
041BBC             0040*  ; Parameters:
041BBC             0041*  ; - HL: Address of parameter string
041BBC             0042*  ; Returns:
041BBC             0043*  ; - HL: Address of first character after token
041BBC             0044*  ; -  C: Length of token (in characters)
041BBC             0045*  ;
041BBC 0E 00       0046*  _get_token:		LD	C, 0			; Initialise length
041BBE 7E          0047*  @@:			LD	A, (HL)			; Get the character from the parameter string
041BBF B7          0048*  			OR	A			; Exit if 0 (end of parameter string in MOS)
041BC0 C8          0049*  			RET 	Z
041BC1 FE 0D       0050*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
041BC3 C8          0051*  			RET	Z
041BC4 FE 20       0052*  			CP	' '			; Exit if space (end of token)
041BC6 C8          0053*  			RET	Z
041BC7 23          0054*  			INC	HL			; Advance to next character
041BC8 0C          0055*  			INC 	C			; Increment length
041BC9 18 F3       0056*  			JR	@B
041BCB             0057*  
041BCB             0058*  ; Skip spaces in the parameter string
041BCB             0059*  ; Parameters:
041BCB             0060*  ; - HL: Address of parameter string
041BCB             0061*  ; Returns:
041BCB             0062*  ; - HL: Address of next none-space character
041BCB             0063*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
041BCB             0064*  ;
041BCB 7E          0065*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
041BCC FE 20       0066*  			CP	' '			; Exit if not space
041BCE C0          0067*  			RET	NZ
041BCF 23          0068*  			INC	HL			; Advance to next character
041BD0 18 F9       0069*  			JR	_skip_spaces		; Increment length
041BD2             0070*  
041BD2             0071*  ; Storage for the argv array pointers
041BD2             0072*  min_args: equ 1
041BD2             0073*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
041BD2 00 00 00 00 0074*  argv_ptrs:		    BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041C02             0075*  _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
041C05             0076*  
041C05             0077*  ; begin BASIC-specific end code
041C05             0078*  ; This bit of code is called from STAR_BYE and returns us safely to MOS
041C05 ED 7B 02 1C 0079*  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
041C0A             0080*  ; fall through to _main_end_ok
041C0A             0081*  ; end BASIC-specific end code
041C0A             0082*  
041C0A             0083*  ; ========== HELPER FUNCTIONS ==========
041C0A             0084*  ;
041C0A             0085*  ; get the next argument after ix as a floating point number
041C0A             0086*  ; inputs: ix = pointer to the argument string
041C0A             0087*  ; outputs: HLH'L'C = floating point number, ix points to the next argument
041C0A             0088*  ; destroys: everything except iy, including prime registers
041C0A             0089*  get_arg_float:
041C0A ED 32 03    0090*      lea ix,ix+3 ; point to the next argument
041C0D DD E5       0091*      push ix ; preserve
041C0F DD 37 00    0092*      ld ix,(ix)  ; point to argument string
041C12 CD A5 15 04 0093*      call val_fp ; convert the string to a float
041C16 DD E1       0094*      pop ix ; restore
041C18 C9          0095*      ret ; return with the value in HLH'L'C
041C19             0096*  
041C19             0097*  ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
041C19             0098*  ; inputs: ix = pointer to the argument string
041C19             0099*  ; outputs: HLH'L'C = floating point number, ix points to the next argument
041C19             0100*  ; destroys: everything except iy, including prime registers
041C19             0101*  store_arg_iy_float:
041C19 ED 32 03    0102*      lea ix,ix+3 ; point to the next argument
041C1C DD E5       0103*      push ix ; preserve
041C1E DD 37 00    0104*      ld ix,(ix)  ; point to argument string
041C21 CD A5 15 04 0105*      call val_fp ; convert the string to a float
041C25 CD 90 16 04 0106*      call store_float_iy_nor ; save the float in buffer
041C29 DD E1       0107*      pop ix ; restore
041C2B C9          0108*      ret ; return with the value in HLH'L'C
041C2C             0060   
041C2C             0061   init:
041C2C             0062   ; ========================================
041C2C             0063   ; BASIC INITIALIZATION CODE FROM basic/init.asm
041C2C             0064   ; ========================================
041C2C             0065   ;
041C2C             0066   ;Clear the application memory
041C2C             0067   ;
041C2C             0068   _clear_ram:
041C2C E5          0069       push hl
041C2D C5          0070       PUSH		BC
041C2E 21 00 20 04 0071       LD		HL, RAM_START
041C32 11 01 20 04 0072       LD		DE, RAM_START + 1
041C36 01 4F 03 00 0073       LD		BC, RAM_END - RAM_START - 1
041C3A AF          0074       XOR		A
041C3B 77          0075       LD		(HL), A
041C3C ED B0       0076       LDIR
041C3E C1          0077       POP		BC
041C3F E1          0078       pop hl
041C40             0079   
041C40             0080   ; initialization done
041C40 C9          0081       RET
041C41             0082   
041C41             0083   ; ========================================
041C41             0084   ; MAIN PROGRAM
041C41             0085   ; ========================================
041C41             0086   ; ---- input arguments (float) ----
041C41             0087   input_params_num: equ 8
041C41             0088   input_params:
041C41 81 1F 85 EB 0089   petals:             db   0x81, 0x1F, 0x85, 0xEB, 0x41 ; 3.03
       41          
041C46 80 D7 A3 70 0090   vectors:            db   0x80, 0xD7, 0xA3, 0x70, 0x7D ; 1.98
       7D          
041C4B 7F 9A 99 99 0091   depth:              db   0x7F, 0x9A, 0x99, 0x99, 0x19 ; 0.6
       19          
041C50 00 42 00 00 0092   periods:            db   0x00, 0x42, 0x00, 0x00, 0x00 ; 66.0
       00          
041C55 7F CC CC CC 0093   shrink:             db   0x7F, 0xCC, 0xCC, 0xCC, 0x4C ; 0.8
       4C          
041C5A 00 00 02 00 0094   radius_scale: 	    db   0x00, 0x00, 0x02, 0x00, 0x00 ; 512.0
       00          
041C5F 00 00 00 00 0095   theta_init: 	    db   0x00, 0x00, 0x00, 0x00, 0x00 ; 0
       00          
041C64 00 01 00 00 0096   num_increments:     db   0x00, 0x01, 0x00, 0x00, 0x00 ; 1.0
       00          
041C69             0097   
041C69 00 00 00 00 0098   target_params: blkb input_params_num*5,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041C91             0099   
041C91             0100   ; ---- amount to increment each parameter each loop (float) ----
041C91             0101   inc_params:
041C91 00 00 00 00 0102   petals_inc: blkb 5,0
       00          
041C96 00 00 00 00 0103   vectors_inc: blkb 5,0
       00          
041C9B 00 00 00 00 0104   depth_inc: blkb 5,0
       00          
041CA0 00 00 00 00 0105   periods_inc: blkb 5,0
       00          
041CA5 00 00 00 00 0106   shrink_inc: blkb 5,0
       00          
041CAA 00 00 00 00 0107   radius_scale_inc: blkb 5,0
       00          
041CAF 00 00 00 00 0108   theta_init_inc: blkb 5,0
       00          
041CB4             0109   
041CB4 09 00       0110   G9: DW 9 ; format code for converting floats to strings
041CB6             0111   
041CB6             0112   main:
041CB6             0113   ; set up the display
041CB6 3E 92       0114       ld a,18+128 ; 18   1024  768   2     60hz  double-buffered
041CB8 CD BC 18 04 0115       call vdu_set_screen_mode
041CBC CD E5 17 04 0116   	call cursor_off
041CC0             0117   
041CC0             0118   main_loop:
041CC0             0119   ; get the starting parameters
041CC0 CD 30 1D 04 0120       call get_params
041CC4 FD 21 41 1C 0121       ld iy,input_params
       04          
041CC9 CD 65 1D 04 0122       call load_input
041CCD             0123   
041CCD             0124   ; bump pointer to the next sample
041CCD 2A 63 00 04 0125       ld hl,(next_sample)
041CD1 22 60 00 04 0126       ld (cur_sample),hl
041CD5             0127   
041CD5             0128   ; get the target parameters
041CD5 CD 30 1D 04 0129       call get_params
041CD9 FD 21 69 1C 0130       ld iy,target_params
       04          
041CDE CD 65 1D 04 0131       call load_input
041CE2             0132   
041CE2             0133   ; compute the increment parameters
041CE2 CD BB 1D 04 0134       call compute_increments
041CE6             0135   
041CE6             0136   ; iterate to the target sample
041CE6 DD 21 64 1C 0137       ld ix,target_params-5 ; point to num_increments
       04          
041CEB CD 5A 16 04 0138       call fetch_float_nor
041CEF CD D1 15 04 0139       call int2hlu
041CF3 45          0140       ld b,l ; loop counter
041CF4             0141   
041CF4             0142   @loop:
041CF4 C5          0143       push bc
041CF5             0144   ; assemble the command string and draw the flower
041CF5 CD 73 1D 04 0145       call assemble_command
041CF9 CD 21 1D 04 0146       call draw_flower
041CFD CD 11 18 04 0147       call vdu_flip
041D01             0148   
041D01             0149       ; call waitKeypress
041D01 CD EB 1D 04 0150       call apply_increments
041D05             0151   
041D05             0152   ; check for escape key and quit if pressed
041D05             0153       MOSCALL mos_getkbmap
041D05 3E 1E       0001M  			LD	A, function
041D07 49 CF       0002M  			RST.LIS	08h
041D09 C1          0154       pop bc ; get back the loop counter
041D0A             0155   ; 113 Escape
041D0A DD CB 0E 46 0156       bit 0,(ix+14)
041D0E 20 06       0157       jr nz,main_end
041D10             0158   @Escape:
041D10 10 E2       0159       djnz @loop ; loop until done
041D12             0160   
041D12 C3 C0 1C 04 0161       jp main_loop
041D16             0162   
041D16             0163   main_end:
041D16             0164   ; restore screen to something normalish
041D16 3E 14       0165       ld a,20 ; 20    512   384   64    60hz  single-buffered
041D18 CD BC 18 04 0166   	call vdu_set_screen_mode
041D1C CD D7 17 04 0167   	call cursor_on
041D20 C9          0168   	ret
041D21             0169   
041D21             0170   draw_flower:
041D21 21 42 1E 04 0171       ld hl,command0
041D25             0172       MOSCALL mos_oscli
041D25 3E 10       0001M  			LD	A, function
041D27 49 CF       0002M  			RST.LIS	08h
041D29 3E 20       0173       ld a,' '          ; restore the space after "flower" since
041D2B 32 48 1E 04 0174       ld (command1-1),a ; mos_oscli null-terminates each argument
041D2F C9          0175       ret
041D30             0176   
041D30             0177   get_params:
041D30             0178   ; prepare to read the parameter string
041D30 11 49 1E 04 0179       ld de,command1
041D34 2A 60 00 04 0180       ld hl,(cur_sample)
041D38 7E          0181       ld a,(hl)
041D39 B7          0182       or a
041D3A C2 46 1D 04 0183       jp nz,@loop ; not at end of list so proceed
041D3E 21 66 00 04 0184       ld hl,samples ;loop back to beginning of list
041D42 22 60 00 04 0185       ld (cur_sample),hl
041D46             0186   @loop:
041D46             0187   ; copy the orginal string to the command buffer since _parse_params zero-terminates each token
041D46 7E          0188       ld a,(hl)
041D47 12          0189       ld (de),a
041D48 23          0190       inc hl
041D49 13          0191       inc de
041D4A B7          0192       or a
041D4B C2 46 1D 04 0193       jp nz,@loop
041D4F 22 63 00 04 0194       ld (next_sample),hl
041D53             0195   ; parse the parameters
041D53 21 49 1E 04 0196       ld hl,command1
041D57 DD 21 D2 1B 0197       LD IX,argv_ptrs		; The argv array pointer address
       04          
041D5C DD E5       0198       PUSH IX
041D5E CD 89 1B 04 0199       CALL _parse_params	; Parse the parameters
041D62 DD E1       0200       POP IX
041D64 C9          0201       ret
041D65             0202   
041D65             0203   ; inputs: ix points to the start of the argument pointers
041D65             0204   ;         iy points to the start of the parameter values table
041D65             0205   ; outputs: the parameter values are loaded into the table
041D65             0206   ;          hl points to the next parameter set
041D65             0207   load_input:
041D65 06 08       0208       ld b,input_params_num ; loop counter
041D67             0209   @loop:
041D67 C5          0210       push bc ; save the loop counter
041D68 CD 19 1C 04 0211       call store_arg_iy_float ; get the next argument and store it
041D6C ED 33 05    0212       lea iy,iy+5  ; point to the next parameter
041D6F C1          0213       pop bc ; get back the loop counter
041D70 10 F5       0214       djnz @loop ; loop until done
041D72 C9          0215       ret
041D73             0216   
041D73             0217   assemble_command:
041D73             0218   ; convert the loaded values back into strings and assemble the final command string
041D73 06 08       0219       ld b,input_params_num ; loop counter
041D75 FD 21 41 1C 0220       ld iy,input_params  ; point to the parameter values table
       04          
041D7A DD 21 49 1E 0221       ld ix,command1      ; point to the command string buffer
       04          
041D7F             0222   @loop0:
041D7F C5          0223       push bc             ; save the loop counter
041D80 FD E5       0224       push iy             ; save the parameter pointer
041D82 DD E5       0225       push ix             ; save the command string pointer
041D84 CD A2 16 04 0226       call fetch_float_iy_nor
041D88 11 00 20 04 0227       ld de,ACCS          ; point to the string accumulator
041D8C DD 21 B3 1C 0228       ld ix,G9-1          ; get the format code for the number
       04          
041D91 CD B9 08 04 0229       call STR_FP         ; convert the number to a string
041D95 EB          0230       ex de,hl            ; point to end of the string
041D96 36 00       0231       ld (hl),0           ; null-terminate the string
041D98 21 00 20 04 0232       ld hl,ACCS          ; point to the string accumulator
041D9C DD E1       0233       pop ix             ; get back the command string pointer
041D9E             0234   @loop1:
041D9E 7E          0235       ld a,(hl)           ; get a character
041D9F DD 77 00    0236       ld (ix),a           ; store it
041DA2 23          0237       inc hl              ; point to the next character
041DA3 ED 32 01    0238       lea ix,ix+1         ; point to the next character
041DA6 B7          0239       or a                ; check for end of string
041DA7 20 F5       0240       jr nz,@loop1        ; loop until done
041DA9             0241   
041DA9 3E 20       0242       ld a,' '            ; overwrite the null with a space ...
041DAB DD 77 FF    0243       ld (ix-1),a         ; ... in case we're not at the end
041DAE FD E1       0244       pop iy              ; get back the parameter pointer
041DB0 ED 33 05    0245       lea iy,iy+5         ; point to the next parameter
041DB3 C1          0246       pop bc              ; get back the loop counter
041DB4 10 C9       0247       djnz @loop0         ; loop until done
041DB6             0248   
041DB6 AF          0249       xor a
041DB7 DD 77 00    0250       ld (ix),a           ; now null-terminate the command string
041DBA             0251   
041DBA C9          0252       ret
041DBB             0253   
041DBB             0254   offset_targets: equ input_params_num*5
041DBB             0255   offset_increments: equ input_params_num*5*2
041DBB             0256   
041DBB             0257   compute_increments:
041DBB 06 07       0258       ld b,input_params_num-1 ; loop counter (skip number of increments)
041DBD FD 21 41 1C 0259       ld iy,input_params  ; point to the parameter values table
       04          
041DC2             0260   @loop:
041DC2 C5          0261       push bc ; save the loop counter
041DC3 CD 0C 1E 04 0262       call fetch_float_targets_nor
041DC7 CD C6 16 04 0263       call fetch_float_iy_alt ; input_params
041DCB 3E 0D       0264       ld a,fsub
041DCD CD BA 00 04 0265       call FPP ; HLH'L'C = target - input
041DD1 DD 21 64 1C 0266       ld ix,target_params-5 ; point to num_increments
       04          
041DD6 CD 7E 16 04 0267       call fetch_float_alt
041DDA 3E 0F       0268       ld a,fdiv
041DDC CD BA 00 04 0269       call FPP ; HLH'L'C = (target - input) / num_increments
041DE0 CD 1E 1E 04 0270       call store_float_increments_nor
041DE4 ED 33 05    0271       lea iy,iy+5  ; point to the next parameter
041DE7 C1          0272       pop bc ; get back the loop counter
041DE8 10 D8       0273       djnz @loop ; loop until done
041DEA C9          0274       ret
041DEB             0275   
041DEB             0276   apply_increments:
041DEB 06 08       0277       ld b,input_params_num ; loop counter
041DED FD 21 41 1C 0278       ld iy,input_params  ; point to the parameter values table
       04          
041DF2             0279   @loop:
041DF2 C5          0280       push bc ; save the loop counter
041DF3 CD A2 16 04 0281       call fetch_float_iy_nor
041DF7 CD 30 1E 04 0282       call fetch_float_increments_alt
041DFB 3E 0B       0283       ld a,fadd
041DFD CD BA 00 04 0284       call FPP ; HLH'L'C = input + increment
041E01 CD 90 16 04 0285       call store_float_iy_nor
041E05 ED 33 05    0286       lea iy,iy+5  ; point to the next parameter
041E08 C1          0287       pop bc ; get back the loop counter
041E09 10 E7       0288       djnz @loop ; loop until done
041E0B C9          0289       ret
041E0C             0290   
041E0C             0291   ; fetch HLH'L'C floating point number from a 40-bit buffer
041E0C             0292   ; inputs: iy = buffer address
041E0C             0293   ; outputs: HLH'L'C = floating point number
041E0C             0294   ; destroys: HLH'L'C
041E0C             0295   fetch_float_targets_nor:
041E0C FD 4E 28    0296       ld c,(iy+0+offset_targets)
041E0F FD 6E 2B    0297       ld l,(iy+3+offset_targets)
041E12 FD 66 2C    0298       ld h,(iy+4+offset_targets)
041E15 D9          0299       exx
041E16 FD 6E 29    0300       ld l,(iy+1+offset_targets)
041E19 FD 66 2A    0301       ld h,(iy+2+offset_targets)
041E1C D9          0302       exx
041E1D C9          0303       ret
041E1E             0304   
041E1E             0305   ; store HLH'L'C floating point number in a 40-bit buffer
041E1E             0306   ; inputs: HLH'L'C = floating point number
041E1E             0307   ;         iy = buffer address
041E1E             0308   ; outputs: buffer filled with floating point number
041E1E             0309   ; destroys: nothing
041E1E             0310   store_float_increments_nor:
041E1E FD 71 50    0311       ld (iy+0+offset_increments),c
041E21 FD 75 53    0312       ld (iy+3+offset_increments),l
041E24 FD 74 54    0313       ld (iy+4+offset_increments),h
041E27 D9          0314       exx
041E28 FD 75 51    0315       ld (iy+1+offset_increments),l
041E2B FD 74 52    0316       ld (iy+2+offset_increments),h
041E2E D9          0317       exx
041E2F C9          0318       ret
041E30             0319   
041E30             0320   ; fetch DED'E'B floating point number from a 40-bit buffer
041E30             0321   ; inputs: iy = buffer address
041E30             0322   ; outputs: DED'E'B = floating point number
041E30             0323   ; destroys: DED'E'B
041E30             0324   fetch_float_increments_alt:
041E30 FD 46 50    0325       ld b,(iy+0+offset_increments)
041E33 FD 5E 53    0326       ld e,(iy+3+offset_increments)
041E36 FD 56 54    0327       ld d,(iy+4+offset_increments)
041E39 D9          0328       exx
041E3A FD 5E 51    0329       ld e,(iy+1+offset_increments)
041E3D FD 56 52    0330       ld d,(iy+2+offset_increments)
041E40 D9          0331       exx
041E41 C9          0332       ret
041E42             0333   
041E42             0334   ; @command: asciz "flower 3.93 1.98 .6 66 .8 512 90"
041E42 66 6C 6F 77 0335   command0: db "flower "
       65 72 20    
041E49 00 00 00 00 0336   command1: blkb 256-7,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00          
041F42             0337   
041F42             0338       include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
041F42             0001*  ;
041F42             0002*  ; Title:	BBC Basic Interpreter - Z80 version
041F42             0003*  ;		RAM Module for BBC Basic Interpreter
041F42             0004*  ;		For use with Version 2.0 of BBC BASIC
041F42             0005*  ;		Standard CP/M Distribution Version
041F42             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
041F42             0007*  ; Modified By:	Dean Belfield
041F42             0008*  ; Created:	12/05/2023
041F42             0009*  ; Last Updated:	26/06/2023
041F42             0010*  ;
041F42             0011*  ; Modinfo:
041F42             0012*  ; 06/06/2023:	Modified to run in ADL mode
041F42             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
041F42             0014*  
041F42             0015*  			; .ASSUME	ADL = 1
041F42             0016*  
041F42             0017*  			; DEFINE	LORAM, SPACE = ROM
041F42             0018*  			; SEGMENT LORAM
041F42             0019*  
041F42             0020*  			; XDEF	ACCS
041F42             0021*  			; XDEF	BUFFER
041F42             0022*  			; XDEF	STAVAR
041F42             0023*  			; XDEF	DYNVAR
041F42             0024*  			; XDEF	FNPTR
041F42             0025*  			; XDEF	PROPTR
041F42             0026*  			; XDEF	PAGE_
041F42             0027*  			; XDEF	TOP
041F42             0028*  			; XDEF	LOMEM
041F42             0029*  			; XDEF 	FREE
041F42             0030*  			; XDEF	HIMEM
041F42             0031*  			; XDEF	LINENO
041F42             0032*  			; XDEF	TRACEN
041F42             0033*  			; XDEF	AUTONO
041F42             0034*  			; XDEF	ERRTRP
041F42             0035*  			; XDEF	ERRTXT
041F42             0036*  			; XDEF	DATPTR
041F42             0037*  			; XDEF	ERL
041F42             0038*  			; XDEF	ERRLIN
041F42             0039*  			; XDEF	RANDOM
041F42             0040*  			; XDEF	COUNT
041F42             0041*  			; XDEF	WIDTH
041F42             0042*  			; XDEF	ERR
041F42             0043*  			; XDEF	LISTON
041F42             0044*  			; XDEF	INCREM
041F42             0045*  
041F42             0046*  			; XDEF	FLAGS
041F42             0047*  			; XDEF	OSWRCHPT
041F42             0048*  			; XDEF	OSWRCHCH
041F42             0049*  			; XDEF	OSWRCHFH
041F42             0050*  			; XDEF	KEYDOWN
041F42             0051*  			; XDEF	KEYASCII
041F42             0052*  			; XDEF	KEYCOUNT
041F42             0053*  
041F42             0054*  			; XDEF	R0
041F42             0055*  			; XDEF	R1
041F42             0056*  
041F42             0057*  			; XDEF	RAM_START
041F42             0058*  			; XDEF	RAM_END
041F42             0059*  			; XDEF	USER
041F42             0060*  
041F42             0061*  end_binary: ;  for assemble.py to know where to truncate the binary file
041F42 FF FF FF FF 0062*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
042000             0063*  RAM_START:
042000             0064*  ;
042000 00 00 00 00 0065*  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042100 00 00 00 00 0066*  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042200 00 00 00 00 0067*  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04226C 00 00 00 00 0068*  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
04230E 00 00 00    0069*  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
042311 00 00 00    0070*  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
042314             0071*  ;
042314 00 00 00    0072*  PAGE_:          BLKB    3,0               ; Start of User Program
042317 00 00 00    0073*  TOP:            BLKB    3,0               ; First Location after User Program
04231A 00 00 00    0074*  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
04231D 00 00 00    0075*  FREE:           BLKB    3,0               ; First Free Space Byte
042320 00 00 00    0076*  HIMEM:          BLKB    3,0               ; First Protected Byte
042323             0077*  ;
042323 00 00 00    0078*  LINENO:         BLKB    3,0               ; Line Number
042326 00 00 00    0079*  TRACEN:         BLKB    3,0               ; Trace Flag
042329 00 00 00    0080*  AUTONO:         BLKB    3,0               ; Auto Flag
04232C 00 00 00    0081*  ERRTRP:         BLKB    3,0               ; Error Trap
04232F 00 00       0082*  ERRTXT:         BLKB    2,0               ; Error Message Pointer
042331 00 00       0083*  DATPTR:         BLKB    2,0               ; Data Pointer
042333 00 00       0084*  ERL:            BLKB    2,0               ; Error Line
042335 00 00 00    0085*  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
042338 00 00 00 00 0086*  RANDOM:         BLKB    5,0               ; Random Number
       00          
04233D 00          0087*  COUNT:          BLKB    1,0               ; Print Position
04233E 00          0088*  WIDTH:          BLKB    1,0               ; Print Width
04233F 00          0089*  ERR:            BLKB    1,0               ; Error Number
042340 00          0090*  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
042341             0091*                                  ; - BIT 0: If set, output a space after the line number
042341             0092*                                  ; - BIT 1: If set, then indent FOR/NEXT loops
042341             0093*                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
042341             0094*                                  ; - BIT 3: If set, then output to buffer for *EDIT
042341             0095*                                  ; OPT FLAG (top nibble)
042341             0096*                                  ; - BIT 4: If set, then list whilst assembling
042341             0097*                                  ; - BIT 5: If set, then assembler errors are reported
042341             0098*                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
042341             0099*                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
042341 00          0100*  INCREM:         BLKB    1,0               ; Auto-Increment Value
042342             0101*  ;
042342             0102*  ; --------------------------------------------------------------------------------------------
042342             0103*  ; BEGIN MODIFIED CODE
042342             0104*  ; --------------------------------------------------------------------------------------------
042342             0105*  ; Originally in equs.inc
042342             0106*  ;
042342             0107*  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
042342             0108*  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
042342             0109*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
042342             0110*  ; --------------------------------------------------------------------------------------------
042342             0111*  ; END MODIFIED CODE
042342             0112*  ; --------------------------------------------------------------------------------------------
042342             0113*  
042342             0114*  ; Extra Agon-implementation specific system variables
042342             0115*  ;
042342 00          0116*  FLAGS:          BLKB    1,0       ; Miscellaneous flags
042343             0117*                                  ; - BIT 7: Set if ESC pressed
042343             0118*                                  ; - BIT 6: Set to disable ESC
042343 00 00       0119*  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
042345 00          0120*  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
042346             0121*                                  ; - 0: Console
042346             0122*                                  ; - 1: File
042346 00          0123*  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
042347 00          0124*  KEYDOWN:        BLKB    1,0       ; Keydown flag
042348 00          0125*  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
042349 00          0126*  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
04234A 00 00 00    0127*  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
04234D 00 00 00    0128*  R1:             BLKB    3,0
042350             0129*  
042350             0130*  ;
042350             0131*  ; This must be at the end
042350             0132*  ;
042350             0133*  RAM_END:
042350 FF FF FF FF 0134*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
042400             0135*  USER:							; Must be aligned on a page boundary
042400             0136*  
