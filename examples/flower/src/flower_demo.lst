PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003   
040000             0004       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0030*  ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0031*  ;
040000             0032*  ; VDP control (VDU 23, 0, n)
040000             0033*  ;
040000             0034*  vdp_gp:			EQU 	80h
040000             0035*  vdp_keycode:		EQU 	81h
040000             0036*  vdp_cursor:		EQU	82h
040000             0037*  vdp_scrchar:		EQU	83h
040000             0038*  vdp_scrpixel:		EQU	84h
040000             0039*  vdp_audio:		EQU	85h
040000             0040*  vdp_mode:		EQU	86h
040000             0041*  vdp_rtc:		EQU	87h
040000             0042*  vdp_keystate:		EQU	88h
040000             0043*  vdp_logicalcoords:	EQU	C0h
040000             0044*  vdp_terminalmode:	EQU	FFh
040000             0045*  
040000             0046*  ; MOS high level functions
040000             0047*  ;
040000             0048*  mos_getkey:		EQU	00h
040000             0049*  mos_load:		EQU	01h
040000             0050*  mos_save:		EQU	02h
040000             0051*  mos_cd:			EQU	03h
040000             0052*  mos_dir:		EQU	04h
040000             0053*  mos_del:		EQU	05h
040000             0054*  mos_ren:		EQU	06h
040000             0055*  mos_mkdir:		EQU	07h
040000             0056*  mos_sysvars:		EQU	08h
040000             0057*  mos_editline:		EQU	09h
040000             0058*  mos_fopen:		EQU	0Ah
040000             0059*  mos_fclose:		EQU	0Bh
040000             0060*  mos_fgetc:		EQU	0Ch
040000             0061*  mos_fputc:		EQU	0Dh
040000             0062*  mos_feof:		EQU	0Eh
040000             0063*  mos_getError:		EQU	0Fh
040000             0064*  mos_oscli:		EQU	10h
040000             0065*  mos_copy:		EQU	11h
040000             0066*  mos_getrtc:		EQU	12h
040000             0067*  mos_setrtc:		EQU	13h
040000             0068*  mos_setintvector:	EQU	14h
040000             0069*  mos_uopen:		EQU	15h
040000             0070*  mos_uclose:		EQU	16h
040000             0071*  mos_ugetc:		EQU	17h
040000             0072*  mos_uputc:		EQU 	18h
040000             0073*  mos_getfil:		EQU	19h
040000             0074*  mos_fread:		EQU	1Ah
040000             0075*  mos_fwrite:		EQU	1Bh
040000             0076*  mos_flseek:		EQU	1Ch
040000             0077*  mos_setkbvector:	EQU	1Dh
040000             0078*  mos_getkbmap:		EQU	1Eh
040000             0079*  mos_i2c_open:		EQU	1Fh
040000             0080*  mos_i2c_close:		EQU	20h
040000             0081*  mos_i2c_write:		EQU	21h
040000             0082*  mos_i2c_read:		EQU	22h
040000             0083*  
040000             0084*  
040000             0085*  ; FatFS file access functions
040000             0086*  ;
040000             0087*  ffs_fopen:		EQU	80h
040000             0088*  ffs_fclose:		EQU	81h
040000             0089*  ffs_fread:		EQU	82h
040000             0090*  ffs_fwrite:		EQU	83h
040000             0091*  ffs_flseek:		EQU	84h
040000             0092*  ffs_ftruncate:		EQU	85h
040000             0093*  ffs_fsync:		EQU	86h
040000             0094*  ffs_fforward:		EQU	87h
040000             0095*  ffs_fexpand:		EQU	88h
040000             0096*  ffs_fgets:		EQU	89h
040000             0097*  ffs_fputc:		EQU	8Ah
040000             0098*  ffs_fputs:		EQU	8Bh
040000             0099*  ffs_fprintf:		EQU	8Ch
040000             0100*  ffs_ftell:		EQU	8Dh
040000             0101*  ffs_feof:		EQU	8Eh
040000             0102*  ffs_fsize:		EQU	8Fh
040000             0103*  ffs_ferror:		EQU	90h
040000             0104*  
040000             0105*  ; FatFS directory access functions
040000             0106*  ;
040000             0107*  ffs_dopen:		EQU	91h
040000             0108*  ffs_dclose:		EQU	92h
040000             0109*  ffs_dread:		EQU	93h
040000             0110*  ffs_dfindfirst:		EQU	94h
040000             0111*  ffs_dfindnext:		EQU	95h
040000             0112*  
040000             0113*  ; FatFS file and directory management functions
040000             0114*  ;
040000             0115*  ffs_stat:		EQU	96h
040000             0116*  ffs_unlink:		EQU	97h
040000             0117*  ffs_rename:		EQU	98h
040000             0118*  ffs_chmod:		EQU	99h
040000             0119*  ffs_utime:		EQU	9Ah
040000             0120*  ffs_mkdir:		EQU	9Bh
040000             0121*  ffs_chdir:		EQU	9Ch
040000             0122*  ffs_chdrive:		EQU	9Dh
040000             0123*  ffs_getcwd:		EQU	9Eh
040000             0124*  
040000             0125*  ; FatFS volume management and system configuration functions
040000             0126*  ;
040000             0127*  ffs_mount:		EQU	9Fh
040000             0128*  ffs_mkfs:		EQU	A0h
040000             0129*  ffs_fdisk:		EQU	A1h
040000             0130*  ffs_getfree:		EQU	A2h
040000             0131*  ffs_getlabel:		EQU	A3h
040000             0132*  ffs_setlabel:		EQU	A4h
040000             0133*  ffs_setcp:		EQU	A5h
040000             0134*  
040000             0135*  ; File access modes
040000             0136*  ;
040000             0137*  fa_read:		EQU	01h
040000             0138*  fa_write:		EQU	02h
040000             0139*  fa_open_existing:	EQU	00h
040000             0140*  fa_create_new:		EQU	04h
040000             0141*  fa_create_always:	EQU	08h
040000             0142*  fa_open_always:		EQU	10h
040000             0143*  fa_open_append:		EQU	30h
040000             0144*  
040000             0145*  ; System variable indexes for api_sysvars
040000             0146*  ; Index into _sysvars in globals.asm
040000             0147*  ;
040000             0148*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0149*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0150*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0151*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0152*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0153*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0154*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0155*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0156*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0157*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0158*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0159*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0160*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0161*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0162*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0163*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0164*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0165*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0166*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0167*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0168*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0169*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0170*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0171*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0172*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0173*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0174*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0175*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0176*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0177*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0178*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0179*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0180*  ;
040000             0181*  ; Flags for the VPD protocol
040000             0182*  ;
040000             0183*  vdp_pflag_cursor:	EQU	00000001b
040000             0184*  vdp_pflag_scrchar:	EQU	00000010b
040000             0185*  vdp_pflag_point:	EQU	00000100b
040000             0186*  vdp_pflag_audio:	EQU	00001000b
040000             0187*  vdp_pflag_mode:		EQU	00010000b
040000             0188*  vdp_pflag_rtc:		EQU	00100000b
040000             0189*  vdp_pflag_mouse:	EQU	01000000b
040000             0190*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0191*  
040000             0192*  
040000             0193*  ; FatFS structures
040000             0194*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0195*  ;
040000             0196*  ; Object ID and allocation information (FFOBJID)
040000             0197*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0198*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0199*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0200*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0201*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0202*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0203*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0204*  ;
040000             0205*  ; File object structure (FIL)
040000             0206*  ;
040000             0207*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0208*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0209*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0210*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0211*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0212*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0213*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0214*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0215*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0220*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0221*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0222*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0223*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0224*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0225*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0226*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0227*  ;
040000             0228*  ; File information structure (FILINFO)
040000             0229*  ;
040000             0230*  FILINFO.fsize:    EQU 0    ; File size
040000             0231*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0232*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0233*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0234*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0235*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0236*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0237*  ;
040000             0238*  ; Macro for calling the API
040000             0239*  ; Parameters:
040000             0240*  ; - function: One of the function numbers listed above
040000             0241*  ;
040000             0242*  			MACRO MOSCALL	function
040000             0243*  			LD	A, function
040000             0244*  			RST.LIS	08h
040000             0245*  			ENDMACRO
040000             0005   
040000             0006       MACRO PROGNAME
040000             0007       ASCIZ "flower_demo"
040000             0008       ENDMACRO
040000             0009   
040000 C3 45 00 04 0010       jp start
040004             0011   
040004             0012   _exec_name:
040004             0013   	PROGNAME
040004 66 6C 6F 77 0001M      ASCIZ "flower_demo"
       65 72 5F 64 
       65 6D 6F 00 
040010             0014   
040010 FF FF FF FF 0015       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53    0016       db "MOS"
040043 00          0017       db 00h
040044 01          0018       db 01h
040045             0019   
040045             0020   start:
040045 F5          0021       push af
040046 C5          0022       push bc
040047 D5          0023       push de
040048 DD E5       0024       push ix
04004A FD E5       0025       push iy
04004C             0026   
04004C CD D9 1B 04 0027       call init
040050 CD C1 1D 04 0028       call main
040054             0029   
040054             0030   exit:
040054             0031   
040054 FD E1       0032       pop iy
040056 DD E1       0033       pop ix
040058 D1          0034       pop de
040059 C1          0035       pop bc
04005A F1          0036       pop af
04005B 21 00 00 00 0037       ld hl,0
04005F             0038   
04005F C9          0039       ret
040060             0040   
040060             0041   ; APPLICATION INCLUDES
040060             0042   filedata: equ 0xB7E000 ; start address of 8k onboard sram
040060             0043       include "basic/fpp.asm"
040060             0001*  ;
040060             0002*  ; Title:	BBC Basic Interpreter - Z80 version
040060             0003*  ;		Z80 Floating Point Package
040060             0004*  ; Author:	(C) Copyright  R.T.Russell  1986
040060             0005*  ; Modified By:	Dean Belfield
040060             0006*  ; Created:	03/05/2022
040060             0007*  ; Last Updated:	07/06/2023
040060             0008*  ;
040060             0009*  ; Modinfo:
040060             0010*  ; 26/10/1986:	Version 0.0
040060             0011*  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
040060             0012*  ; 12/05/2023:	Modified by Dean Belfield
040060             0013*  ; 07/06/2023:	Modified to run in ADL mode
040060             0014*  
040060             0015*  			; .ASSUME	ADL = 1
040060             0016*  
040060             0017*  			; SEGMENT CODE
040060             0018*  
040060             0019*  			; XDEF	FPP
040060             0020*  			; XDEF	DLOAD5
040060             0021*  			; XDEF	DLOAD5_SPL
040060             0022*  ;
040060             0023*  ;BINARY FLOATING POINT REPRESENTATION:
040060             0024*  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
040060             0025*  ;    8 BIT EXCESS-128 SIGNED EXPONENT
040060             0026*  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
040060             0027*  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
040060             0028*  ;
040060             0029*  ;BINARY INTEGER REPRESENTATION:
040060             0030*  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
040060             0031*  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
040060             0032*  ;
040060             0033*  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
040060             0034*  ;                            EXPONENT - C
040060             0035*  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
040060             0036*  ;                               EXPONENT - B
040060             0037*  
040060             0038*  ;
040060             0039*  ;Error codes:
040060             0040*  ;
040060             0041*  
040060             0042*  BADOP:			EQU     1               ;Bad operation code
040060             0043*  DIVBY0:			EQU     18              ;Division by zero
040060             0044*  TOOBIG_FP:			EQU     20              ;Too big
040060             0045*  NGROOT:			EQU     21              ;Negative root
040060             0046*  LOGRNG:			EQU     22              ;Log range
040060             0047*  ACLOST:			EQU     23              ;Accuracy lost
040060             0048*  EXPRNG:			EQU     24              ;Exp range
040060             0049*  ;
040060             0050*  ;Call entry and despatch code:
040060             0051*  ;
040060 FD E5       0052*  FPP:			PUSH    IY              ;Save IY
040062 FD 21 00 00 0053*          		LD      IY,0
       00          
040067 FD 39       0054*          		ADD     IY,SP           ;Save SP in IY
040069 CD 79 00 04 0055*          		CALL    OP              ;Perform operation
04006D BF          0056*          		CP      A               ;Good return (Z, NC)
04006E FD E1       0057*  EXIT_FP_:			POP     IY              ;Restore IY
040070 C9          0058*          		RET                     ;Return to caller
040071             0059*  ;
040071             0060*  ;Error exit:
040071             0061*  ;
040071 3E 01       0062*  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
040073 FD F9       0063*  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
040075 B7          0064*          		OR      A               ;Set NZ
040076 37          0065*          		SCF                     ;Set C
040077 18 F5       0066*          		JR      EXIT_FP_
040079             0067*  ;
040079             0068*  ;Perform operation or function:
040079             0069*  ;
040079             0070*  ; OP:			CP      (RTABLE-DTABLE)/3
040079 FE 2A       0071*  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
04007B             0072*  
04007B 30 F4       0073*          		JR      NC,BAD_FP
04007D             0074*          		; CP      (FTABLE-DTABLE)/3
04007D FE 10       0075*  				CP      FTABLE-DTABLE/3 ; ditto
04007F 30 08       0076*          		JR      NC,DISPAT_FP
040081 08          0077*          		EX      AF,AF'
040082 78          0078*          		LD      A,B
040083 B1          0079*          		OR      C               ;Both integer?
040084 C4 8C 0B 04 0080*          		CALL    NZ,FLOATA       ;No, so float both
040088 08          0081*          		EX      AF,AF'
040089 E5          0082*  DISPAT_FP:			PUSH    HL
04008A 21 9C 00 04 0083*          		LD      HL,DTABLE
04008E C5          0084*          		PUSH    BC
04008F 01 03 00 00 0085*  			LD	BC, 3		; C = 3
040093 47          0086*  			LD	B, A 		; B = op-code
040094 ED 4C       0087*  			MLT 	BC 		;BC = op-code * 3
040096 09          0088*  			ADD	HL, BC 		;Add to table base
040097 ED 27       0089*  			LD	HL, (HL)	;Get the routine address (24-bit)
040099             0090*  
040099             0091*  ;        		ADD     A, A            ;A = op-code * 2
040099             0092*  ;        		LD      C,A
040099             0093*  ;        		LD      B,0             ;BC = op-code * 2
040099             0094*  ;        		ADD     HL,BC
040099             0095*  ;        		LD      A,(HL)          ;Get low byte
040099             0096*  ;        		INC     HL
040099             0097*  ;        		LD      H,(HL)          ;Get high byte
040099             0098*  ;        		LD      L,A
040099             0099*  
040099 C1          0100*          		POP     BC
04009A E3          0101*          		EX      (SP),HL
04009B C9          0102*          		RET                     ;Off to routine
04009C             0103*  ;
04009C             0104*  ;Despatch table:
04009C             0105*  ;
04009C 4E 01 04    0106*  DTABLE:			DW24  IAND            ;AND (INTEGER)
04009F BC 01 04    0107*          		DW24  IBDIV           ;DIV
0400A2 61 01 04    0108*          		DW24  IEOR            ;EOR
0400A5 87 01 04    0109*          		DW24  IMOD            ;MOD
0400A8 74 01 04    0110*          		DW24  IOR             ;OR
0400AB 42 04 04    0111*          		DW24  ILE             ;<=
0400AE 51 04 04    0112*          		DW24  INE             ;<>
0400B1 35 04 04    0113*          		DW24  IGE             ;>=
0400B4 1A 04 04    0114*          		DW24  ILT             ;<
0400B7 5E 04 04    0115*          		DW24  IEQ             ;=
0400BA AA 02 04    0116*          		DW24  IMUL            ;*
0400BD E5 01 04    0117*          		DW24  IADD            ;+
0400C0 27 04 04    0118*          		DW24  IGT             ;>
0400C3 CC 01 04    0119*          		DW24  ISUB            ;-
0400C6 61 03 04    0120*          		DW24  IPOW            ;^
0400C9 57 02 04    0121*          		DW24  IDIV            ;/
0400CC             0122*  ;
0400CC             0123*  FTABLE:
0400CC 70 04 04    0124*  				DW24  ABSV_FP            ;ABS
0400CF 56 08 04    0125*          		DW24  ACS_FP             ;ACS
0400D2 94 07 04    0126*          		DW24  ASN_FP             ;ASN
0400D5 C4 07 04    0127*          		DW24  ATN_FP             ;ATN
0400D8 8F 05 04    0128*          		DW24  COS_FP             ;COS
0400DB 9E 04 04    0129*          		DW24  DEG_FP             ;DEG
0400DE 4B 06 04    0130*          		DW24  EXP_FP             ;EXP
0400E1 F2 04 04    0131*          		DW24  INT_FP_            ;INT
0400E4 E9 06 04    0132*          		DW24  LN_FP              ;LN
0400E7 7E 07 04    0133*          		DW24  LOG_FP             ;LOG
0400EA 7C 04 04    0134*          		DW24  NOTK_FP            ;NOT
0400ED A8 04 04    0135*          		DW24  RAD_FP             ;RAD
0400F0 C3 04 04    0136*          		DW24  SGN_FP             ;SGN
0400F3 9C 05 04    0137*          		DW24  SIN_FP             ;SIN
0400F6 0B 05 04    0138*          		DW24  SQR_FP             ;SQR
0400F9 69 05 04    0139*          		DW24  TAN_FP             ;TAN
0400FC             0140*  ;
0400FC 19 0C 04    0141*  		        DW24  ZERO_FP            ;ZERO
0400FF 24 06 04    0142*          		DW24  FONE_FP            ;FONE
040102 63 04 04    0143*          		DW24  TRUE_FP            ;TRUE
040105 90 04 04    0144*          		DW24  PI_FP              ;PI
040108             0145*  ;
040108 D7 04 04    0146*  		        DW24  VAL_FP             ;VAL
04010B 5F 08 04    0147*          		DW24  STR_FP             ;STR$
04010E             0148*  ;
04010E C0 0A 04    0149*          		DW24  SFIX_FP            ;FIX
040111 9C 0B 04    0150*          		DW24  SFLOAT_FP          ;FLOAT
040114             0151*  ;
040114 EA 0B 04    0152*  		        DW24  FTEST_FP           ;TEST
040117 FC 0B 04    0153*          		DW24  FCOMP_FP           ;COMPARE
04011A             0154*  ;
04011A 4A 01 04    0155*  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
04011D B8 01 04    0156*          		DW24  FBDIV           ;DIV
040120 5D 01 04    0157*          		DW24  FEOR            ;EOR
040123 83 01 04    0158*          		DW24  FMOD            ;MOD
040126 70 01 04    0159*          		DW24  FFOR             ;OR
040129 3C 04 04    0160*          		DW24  FLE             ;<=
04012C 4B 04 04    0161*          		DW24  FNE             ;<>
04012F 2F 04 04    0162*          		DW24  FGE             ;>=
040132 14 04 04    0163*          		DW24  FLT             ;<
040135 58 04 04    0164*          		DW24  FEQ             ;=
040138 04 03 04    0165*          		DW24  FMUL            ;*
04013B F2 01 04    0166*          		DW24  FADD            ;+
04013E 21 04 04    0167*          		DW24  FGT             ;>
040141 D9 01 04    0168*          		DW24  FSUB            ;-
040144 E1 03 04    0169*          		DW24  FPOW            ;^
040147 5B 02 04    0170*          		DW24  FDIV            ;/
04014A             0171*  ;
04014A             0172*  ;       PAGE
04014A             0173*  ;
04014A             0174*  ;ARITHMETIC AND LOGICAL OPERATORS:
04014A             0175*  ;All take two arguments, in HLH'L'C & DED'E'B.
04014A             0176*  ;Output in HLH'L'C
04014A             0177*  ;All registers except IX, IY destroyed.
04014A             0178*  ; (N.B. FPOW destroys IX).
04014A             0179*  ;
04014A             0180*  ;FAND - Floating-point AND.
04014A             0181*  ;IAND - Integer AND.
04014A             0182*  ;
04014A CD B4 0A 04 0183*  FAND:			CALL    FIX2
04014E 7C          0184*  IAND:			LD      A,H
04014F A2          0185*          		AND     D
040150 67          0186*          		LD      H,A
040151 7D          0187*          		LD      A,L
040152 A3          0188*          		AND     E
040153 6F          0189*          		LD      L,A
040154 D9          0190*          		EXX
040155 7C          0191*          		LD      A,H
040156 A2          0192*          		AND     D
040157 67          0193*          		LD      H,A
040158 7D          0194*          		LD      A,L
040159 A3          0195*          		AND     E
04015A 6F          0196*          		LD      L,A
04015B D9          0197*          		EXX
04015C C9          0198*          		RET
04015D             0199*  ;
04015D             0200*  ;FEOR - Floating-point exclusive-OR.
04015D             0201*  ;IEOR - Integer exclusive-OR.
04015D             0202*  ;
04015D CD B4 0A 04 0203*  FEOR:			CALL    FIX2
040161 7C          0204*  IEOR:			LD      A,H
040162 AA          0205*          		XOR     D
040163 67          0206*          		LD      H,A
040164 7D          0207*          		LD      A,L
040165 AB          0208*          		XOR     E
040166 6F          0209*          		LD      L,A
040167 D9          0210*          		EXX
040168 7C          0211*          		LD      A,H
040169 AA          0212*          		XOR     D
04016A 67          0213*          		LD      H,A
04016B 7D          0214*          		LD      A,L
04016C AB          0215*          		XOR     E
04016D 6F          0216*          		LD      L,A
04016E D9          0217*          		EXX
04016F C9          0218*          		RET
040170             0219*  ;
040170             0220*  ;FOR - Floating-point OR.
040170             0221*  ;IOR - Integer OR.
040170             0222*  ;
040170 CD B4 0A 04 0223*  FFOR:			CALL    FIX2
040174 7C          0224*  IOR:			LD      A,H
040175 B2          0225*          		OR      D
040176 67          0226*          		LD      H,A
040177 7D          0227*          		LD      A,L
040178 B3          0228*          		OR      E
040179 6F          0229*          		LD      L,A
04017A D9          0230*          		EXX
04017B 7C          0231*          		LD      A,H
04017C B2          0232*          		OR      D
04017D 67          0233*          		LD      H,A
04017E 7D          0234*          		LD      A,L
04017F B3          0235*          		OR      E
040180 6F          0236*          		LD      L,A
040181 D9          0237*          		EXX
040182 C9          0238*          		RET
040183             0239*  ;
040183             0240*  ;FMOD - Floating-point remainder.
040183             0241*  ;IMOD - Integer remainder.
040183             0242*  ;
040183 CD B4 0A 04 0243*  FMOD:			CALL    FIX2
040187 7C          0244*  IMOD:			LD      A,H
040188 AA          0245*          		XOR     D               ;DIV RESULT SIGN
040189 CB 7C       0246*          		BIT     7,H
04018B 08          0247*          		EX      AF,AF'
04018C CB 7C       0248*          		BIT     7,H
04018E C4 D0 0A 04 0249*          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
040192 CD CD 0B 04 0250*          		CALL    SWAP_FP
040196 CB 7C       0251*          		BIT     7,H
040198 C4 D0 0A 04 0252*          		CALL    NZ,NEGATE
04019C 44          0253*          		LD      B,H
04019D 4D          0254*          		LD      C,L
04019E 21 00 00 00 0255*          		LD      HL,0
0401A2 D9          0256*          		EXX
0401A3 44          0257*          		LD      B,H
0401A4 4D          0258*          		LD      C,L
0401A5 21 00 00 00 0259*          		LD      HL,0
0401A9 3E DF       0260*          		LD      A,-33
0401AB CD 5A 0D 04 0261*          		CALL    DIVA            ;DIVIDE
0401AF D9          0262*          		EXX
0401B0 0E 00       0263*          		LD      C,0             ;INTEGER MARKER
0401B2 08          0264*          		EX      AF,AF'
0401B3 C8          0265*          		RET     Z
0401B4 C3 D0 0A 04 0266*          		JP      NEGATE
0401B8             0267*  ;
0401B8             0268*  ;BDIV - Integer division.
0401B8             0269*  ;
0401B8 CD B4 0A 04 0270*  FBDIV:			CALL    FIX2
0401BC CD 87 01 04 0271*  IBDIV:			CALL    IMOD
0401C0 B7          0272*          		OR      A
0401C1 CD CD 0B 04 0273*          		CALL    SWAP_FP
0401C5 0E 00       0274*          		LD      C,0
0401C7 F0          0275*          		RET     P
0401C8 C3 D0 0A 04 0276*          		JP      NEGATE
0401CC             0277*  ;
0401CC             0278*  ;ISUB - Integer subtraction.
0401CC             0279*  ;FSUB - Floating point subtraction with rounding.
0401CC             0280*  ;
0401CC CD 68 0C 04 0281*  ISUB:			CALL    SUB_
0401D0 E0          0282*          		RET     PO
0401D1 CD 60 0C 04 0283*          		CALL    ADD_
0401D5 CD 90 0B 04 0284*          		CALL    FLOAT2
0401D9 7A          0285*  FSUB:			LD      A,D
0401DA EE 80       0286*          		XOR     80H             ;CHANGE SIGN THEN ADD
0401DC 57          0287*          		LD      D,A
0401DD 18 13       0288*          		JR      FADD
0401DF             0289*  ;
0401DF             0290*  ;Reverse subtract.
0401DF             0291*  ;
0401DF 7C          0292*  RSUB:			LD      A,H
0401E0 EE 80       0293*          		XOR     80H
0401E2 67          0294*          		LD      H,A
0401E3 18 0D       0295*          		JR      FADD
0401E5             0296*  ;
0401E5             0297*  ;IADD - Integer addition.
0401E5             0298*  ;FADD - Floating point addition with rounding.
0401E5             0299*  ;
0401E5 CD 60 0C 04 0300*  IADD:			CALL    ADD_
0401E9 E0          0301*          		RET     PO
0401EA CD 68 0C 04 0302*          		CALL    SUB_
0401EE CD 90 0B 04 0303*          		CALL    FLOAT2
0401F2 05          0304*  FADD:			DEC     B
0401F3 04          0305*          		INC     B
0401F4 C8          0306*          		RET     Z               ;ARG 2 ZERO
0401F5 0D          0307*          		DEC     C
0401F6 0C          0308*          		INC     C
0401F7 CA CD 0B 04 0309*          		JP      Z,SWAP_FP          ;ARG 1 ZERO
0401FB D9          0310*          		EXX
0401FC 01 00 00 00 0311*          		LD      BC,0            ;INITIALISE
040200 D9          0312*          		EXX
040201 7C          0313*          		LD      A,H
040202 AA          0314*          		XOR     D               ;XOR SIGNS
040203 F5          0315*          		PUSH    AF
040204 78          0316*          		LD      A,B
040205 B9          0317*          		CP      C               ;COMPARE EXPONENTS
040206 DC CD 0B 04 0318*          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
04020A 78          0319*          		LD      A,B
04020B CB FC       0320*          		SET     7,H             ;IMPLIED 1
04020D C4 A1 0A 04 0321*          		CALL    NZ,FIX          ;ALIGN
040211 F1          0322*          		POP     AF
040212 7A          0323*          		LD      A,D             ;SIGN OF LARGER
040213 CB FA       0324*          		SET     7,D             ;IMPLIED 1
040215 FA 25 02 04 0325*          		JP      M,FADD3         ;SIGNS DIFFERENT
040219 CD 60 0C 04 0326*          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
04021D DC D5 0B 04 0327*          		CALL    C,DIV2          ;NORMALISE
040221 CB FC       0328*          		SET     7,H
040223 18 0D       0329*          		JR      FADD4
040225             0330*  ;
040225 CD 68 0C 04 0331*  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
040229 DC E8 0A 04 0332*          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
04022D CD 67 0B 04 0333*          		CALL    FLO48
040231 2F          0334*          		CPL                     ;CHANGE RESULT SIGN
040232 D9          0335*  FADD4:			EXX
040233 EB          0336*          		EX      DE,HL
040234 21 00 80 00 0337*          		LD      HL,8000H
040238 B7          0338*          		OR      A               ;CLEAR CARRY
040239 52 ED 42    0339*          		SBC.S   HL,BC
04023C EB          0340*          		EX      DE,HL
04023D D9          0341*          		EXX
04023E CC C7 0B 04 0342*          		CALL    Z,ODD           ;ROUND UNBIASSED
040242 DC B5 0B 04 0343*          		CALL    C,ADD1_FP          ;ROUND UP
040246 DC E2 0B 04 0344*          		CALL    C,INCC
04024A CB BC       0345*          		RES     7,H
04024C 0D          0346*          		DEC     C
04024D 0C          0347*          		INC     C
04024E CA 19 0C 04 0348*          		JP      Z,ZERO_FP
040252 B7          0349*          		OR      A               ;RESULT SIGNQ
040253 F0          0350*          		RET     P               ;POSITIVE
040254 CB FC       0351*          		SET     7,H             ;NEGATIVE
040256 C9          0352*          		RET
040257             0353*  ;
040257             0354*  ;IDIV - Integer division.
040257             0355*  ;FDIV - Floating point division with rounding.
040257             0356*  ;
040257 CD 90 0B 04 0357*  IDIV:			CALL    FLOAT2
04025B 05          0358*  FDIV:			DEC     B               ;TEST FOR ZERO
04025C 04          0359*          		INC     B
04025D 3E 12       0360*          		LD      A,DIVBY0
04025F CA 73 00 04 0361*          		JP      Z,ERROR_FP_         ;"Division by zero"
040263 0D          0362*          		DEC     C               ;TEST FOR ZERO
040264 0C          0363*          		INC     C
040265 C8          0364*          		RET     Z
040266 7C          0365*          		LD      A,H
040267 AA          0366*          		XOR     D               ;CALC. RESULT SIGN
040268 08          0367*          		EX      AF,AF'          ;SAVE SIGN
040269 CB FA       0368*          		SET     7,D             ;REPLACE IMPLIED 1's
04026B CB FC       0369*          		SET     7,H
04026D C5          0370*          		PUSH    BC              ;SAVE EXPONENTS
04026E 42          0371*          		LD      B,D             ;LOAD REGISTERS
04026F 4B          0372*          		LD      C,E
040270 11 00 00 00 0373*          		LD      DE,0
040274 D9          0374*          		EXX
040275 42          0375*          		LD      B,D
040276 4B          0376*          		LD      C,E
040277 11 00 00 00 0377*          		LD      DE,0
04027B 3E E0       0378*          		LD      A,-32           ;LOOP COUNTER
04027D CD 5A 0D 04 0379*          		CALL    DIVA            ;DIVIDE
040281 D9          0380*          		EXX
040282 CB 7A       0381*          		BIT     7,D
040284 D9          0382*          		EXX
040285 CC 79 0D 04 0383*          		CALL    Z,DIVB          ;NORMALISE & INC A
040289 EB          0384*          		EX      DE,HL
04028A D9          0385*          		EXX
04028B CB 38       0386*          		SRL     B               ;DIVISOR/2
04028D CB 19       0387*          		RR      C
04028F B7          0388*          		OR      A               ;CLEAR CARRY
040290 52 ED 42    0389*          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
040293 3F          0390*          		CCF
040294 EB          0391*          		EX      DE,HL           ;RESULT IN HLH'L'
040295 CC C7 0B 04 0392*          		CALL    Z,ODD           ;ROUND UNBIASSED
040299 DC B5 0B 04 0393*          		CALL    C,ADD1_FP          ;ROUND UP
04029D C1          0394*          		POP     BC              ;RESTORE EXPONENTS
04029E DC E2 0B 04 0395*          		CALL    C,INCC
0402A2 1F          0396*          		RRA                     ;LSB OF A TO CARRY
0402A3 79          0397*          		LD      A,C             ;COMPUTE NEW EXPONENT
0402A4 98          0398*          		SBC     A,B
0402A5 3F          0399*          		CCF
0402A6 C3 47 03 04 0400*          		JP      CHKOVF
0402AA             0401*  ;
0402AA             0402*  ;IMUL - Integer multiplication.
0402AA             0403*  ;
0402AA 7C          0404*  IMUL:			LD      A,H
0402AB AA          0405*          		XOR     D
0402AC 08          0406*          		EX      AF,AF'          ;SAVE RESULT SIGN
0402AD CB 7C       0407*          		BIT     7,H
0402AF C4 D0 0A 04 0408*          		CALL    NZ,NEGATE
0402B3 CD CD 0B 04 0409*          		CALL    SWAP_FP
0402B7 CB 7C       0410*          		BIT     7,H
0402B9 C4 D0 0A 04 0411*          		CALL    NZ,NEGATE
0402BD 44          0412*          		LD      B,H
0402BE 4D          0413*          		LD      C,L
0402BF 21 00 00 00 0414*          		LD      HL,0
0402C3 D9          0415*          		EXX
0402C4 44          0416*          		LD      B,H
0402C5 4D          0417*          		LD      C,L
0402C6 21 00 00 00 0418*          		LD      HL,0
0402CA 3E DF       0419*          		LD      A,-33
0402CC CD 91 0D 04 0420*          		CALL    MULA            ;MULTIPLY
0402D0 D9          0421*          		EXX
0402D1 0E BF       0422*          		LD      C,191           ;PRESET EXPONENT
0402D3 CD F5 0B 04 0423*          		CALL    TEST_FP            ;TEST RANGE
0402D7 20 0F       0424*          		JR      NZ,IMUL1        ;TOO BIG
0402D9 CB 7A       0425*          		BIT     7,D
0402DB 20 0B       0426*          		JR      NZ,IMUL1
0402DD CD CD 0B 04 0427*          		CALL    SWAP_FP
0402E1 4A          0428*          		LD      C,D             ;INTEGER MARKER
0402E2 08          0429*          		EX      AF,AF'
0402E3 F0          0430*          		RET     P
0402E4 C3 D0 0A 04 0431*          		JP      NEGATE
0402E8             0432*  ;
0402E8 0D          0433*  IMUL1:			DEC     C
0402E9 D9          0434*          		EXX
0402EA CB 23       0435*          		SLA     E
0402EC CB 12       0436*          		RL      D
0402EE D9          0437*          		EXX
0402EF CB 13       0438*          		RL      E
0402F1 CB 12       0439*          		RL      D
0402F3 D9          0440*          		EXX
0402F4 52 ED 6A    0441*          		ADC.S   HL,HL
0402F7 D9          0442*          		EXX
0402F8 52 ED 6A    0443*          		ADC.S   HL,HL
0402FB F2 E8 02 04 0444*          		JP      P,IMUL1         ;NORMALISE
0402FF 08          0445*          		EX      AF,AF'
040300 F8          0446*          		RET     M
040301 CB BC       0447*          		RES     7,H             ;POSITIVE
040303 C9          0448*          		RET
040304             0449*  ;
040304             0450*  ;FMUL - Floating point multiplication with rounding.
040304             0451*  ;
040304 05          0452*  FMUL:			DEC     B               ;TEST FOR ZERO
040305 04          0453*          		INC     B
040306 CA 19 0C 04 0454*          		JP      Z,ZERO_FP
04030A 0D          0455*          		DEC     C               ;TEST FOR ZERO
04030B 0C          0456*          		INC     C
04030C C8          0457*          		RET     Z
04030D 7C          0458*          		LD      A,H
04030E AA          0459*          		XOR     D               ;CALC. RESULT SIGN
04030F 08          0460*          		EX      AF,AF'
040310 CB FA       0461*          		SET     7,D             ;REPLACE IMPLIED 1's
040312 CB FC       0462*          		SET     7,H
040314 C5          0463*          		PUSH    BC              ;SAVE EXPONENTS
040315 44          0464*          		LD      B,H             ;LOAD REGISTERS
040316 4D          0465*          		LD      C,L
040317 21 00 00 00 0466*          		LD      HL,0
04031B D9          0467*          		EXX
04031C 44          0468*          		LD      B,H
04031D 4D          0469*          		LD      C,L
04031E 21 00 00 00 0470*          		LD      HL,0
040322 3E E0       0471*          		LD      A,-32           ;LOOP COUNTER
040324 CD 91 0D 04 0472*          		CALL    MULA            ;MULTIPLY
040328 DC A7 0D 04 0473*          		CALL    C,MULB          ;NORMALISE & INC A
04032C D9          0474*          		EXX
04032D E5          0475*          		PUSH    HL
04032E 21 00 80 00 0476*          		LD      HL,8000H
040332 B7          0477*          		OR      A               ;CLEAR CARRY
040333 52 ED 52    0478*          		SBC.S   HL,DE
040336 E1          0479*          		POP     HL
040337 CC C7 0B 04 0480*          		CALL    Z,ODD           ;ROUND UNBIASSED
04033B DC B5 0B 04 0481*          		CALL    C,ADD1_FP          ;ROUND UP
04033F C1          0482*          		POP     BC              ;RESTORE EXPONENTS
040340 DC E2 0B 04 0483*          		CALL    C,INCC
040344 1F          0484*          		RRA                     ;LSB OF A TO CARRY
040345 79          0485*          		LD      A,C             ;COMPUTE NEW EXPONENT
040346 88          0486*          		ADC     A,B
040347 38 06       0487*  CHKOVF:			JR      C,CHKO1
040349 F2 19 0C 04 0488*          		JP      P,ZERO_FP          ;UNDERFLOW
04034D 18 04       0489*          		JR      CHKO2
04034F FA E4 0B 04 0490*  CHKO1:			JP      M,OFLOW         ;OVERFLOW
040353 C6 80       0491*  CHKO2:			ADD     A,80H
040355 4F          0492*          		LD      C,A
040356 CA 19 0C 04 0493*          		JP      Z,ZERO_FP
04035A 08          0494*          		EX      AF,AF'          ;RESTORE SIGN BIT
04035B CB BC       0495*          		RES     7,H
04035D F0          0496*          		RET     P
04035E CB FC       0497*          		SET     7,H
040360 C9          0498*          		RET
040361             0499*  ;
040361             0500*  ;IPOW - Integer involution.
040361             0501*  ;
040361 CD CD 0B 04 0502*  IPOW:			CALL    SWAP_FP
040365 CB 7C       0503*          		BIT     7,H
040367 F5          0504*          		PUSH    AF              ;SAVE SIGN
040368 C4 D0 0A 04 0505*          		CALL    NZ,NEGATE
04036C 48          0506*  IPOW0:			LD      C,B
04036D 06 20       0507*          		LD      B,32            ;LOOP COUNTER
04036F CD 85 0C 04 0508*  IPOW1:			CALL    X2
040373 38 08       0509*          		JR      C,IPOW2
040375 10 F8       0510*          		DJNZ    IPOW1
040377 F1          0511*          		POP     AF
040378 D9          0512*          		EXX
040379 2C          0513*          		INC     L               ;RESULT=1
04037A D9          0514*          		EXX
04037B 4C          0515*          		LD      C,H
04037C C9          0516*          		RET
04037D             0517*  ;
04037D F1          0518*  IPOW2:			POP     AF
04037E C5          0519*          		PUSH    BC
04037F EB          0520*          		EX      DE,HL
040380 E5          0521*          		PUSH    HL
040381 D9          0522*          		EXX
040382 EB          0523*          		EX      DE,HL
040383 E5          0524*          		PUSH    HL
040384 D9          0525*          		EXX
040385 DD 21 00 00 0526*          		LD      IX,0
       00          
04038A DD 39       0527*          		ADD     IX,SP
04038C 28 48       0528*          		JR      Z,IPOW4
04038E C5          0529*          		PUSH    BC
04038F D9          0530*          		EXX
040390 D5          0531*          		PUSH    DE
040391 D9          0532*          		EXX
040392 D5          0533*          		PUSH    DE
040393 CD 9C 0B 04 0534*          		CALL    SFLOAT_FP
040397 CD D0 06 04 0535*          		CALL    RECIP
04039B DD 71 04    0536*          		LD      (IX+4),C
04039E D9          0537*          		EXX
04039F DD 75 00    0538*          		LD      (IX+0),L
0403A2 DD 74 01    0539*          		LD      (IX+1),H
0403A5 D9          0540*          		EXX
0403A6 DD 75 02    0541*          		LD      (IX+2),L
0403A9 DD 74 03    0542*          		LD      (IX+3),H
0403AC 18 21       0543*          		JR      IPOW5
0403AE             0544*  ;
0403AE C5          0545*  IPOW3:			PUSH    BC
0403AF D9          0546*          		EXX
0403B0 CB 23       0547*          		SLA     E
0403B2 CB 12       0548*          		RL      D
0403B4 D5          0549*          		PUSH    DE
0403B5 D9          0550*          		EXX
0403B6 CB 13       0551*          		RL      E
0403B8 CB 12       0552*          		RL      D
0403BA D5          0553*          		PUSH    DE
0403BB 3E 0A       0554*          		LD      A,'*' & 0FH
0403BD F5          0555*          		PUSH    AF
0403BE CD 99 0C 04 0556*          		CALL    COPY_
0403C2 CD 79 00 04 0557*          		CALL    OP              ;SQUARE
0403C6 F1          0558*          		POP     AF
0403C7 CD C5 09 04 0559*          		CALL    DLOAD5
0403CB DC 79 00 04 0560*          		CALL    C,OP            ;MULTIPLY BY X
0403CF D1          0561*  IPOW5:			POP     DE
0403D0 D9          0562*          		EXX
0403D1 D1          0563*          		POP     DE
0403D2 D9          0564*          		EXX
0403D3 79          0565*          		LD      A,C
0403D4 C1          0566*          		POP     BC
0403D5 4F          0567*          		LD      C,A
0403D6 10 D6       0568*  IPOW4:			DJNZ    IPOW3
0403D8 F1          0569*          		POP     AF
0403D9 F1          0570*          		POP     AF
0403DA F1          0571*          		POP     AF
0403DB C9          0572*          		RET
0403DC             0573*  ;
0403DC F1          0574*  FPOW0:			POP     AF
0403DD F1          0575*          		POP     AF
0403DE F1          0576*          		POP     AF
0403DF 18 8B       0577*          		JR      IPOW0
0403E1             0578*  ;
0403E1             0579*  ;FPOW - Floating-point involution.
0403E1             0580*  ;
0403E1 CB 7A       0581*  FPOW:			BIT     7,D
0403E3 F5          0582*          		PUSH    AF
0403E4 CD CD 0B 04 0583*          		CALL    SWAP_FP
0403E8 CD A9 0C 04 0584*          		CALL    PUSH5
0403EC 0D          0585*          		DEC     C
0403ED 0C          0586*          		INC     C
0403EE 28 EC       0587*          		JR      Z,FPOW0
0403F0 3E 9E       0588*          		LD      A,158
0403F2 B9          0589*          		CP      C
0403F3 38 0A       0590*          		JR      C,FPOW1
0403F5 3C          0591*          		INC     A
0403F6 CD A1 0A 04 0592*          		CALL    FIX
0403FA 08          0593*          		EX      AF,AF'
0403FB F2 DC 03 04 0594*          		JP      P,FPOW0
0403FF CD CD 0B 04 0595*  FPOW1:			CALL    SWAP_FP
040403 CD ED 06 04 0596*          		CALL    LN0
040407 CD B2 0C 04 0597*          		CALL    POP5
04040B F1          0598*          		POP     AF
04040C CD 04 03 04 0599*          		CALL    FMUL
040410 C3 4F 06 04 0600*          		JP      EXP0
040414             0601*  ;
040414             0602*  ;Integer and floating-point compare.
040414             0603*  ;Result is TRUE (-1) or FALSE (0).
040414             0604*  ;
040414 CD 23 0C 04 0605*  FLT:			CALL    FCP
040418 18 04       0606*          		JR      ILT1
04041A CD 15 0C 04 0607*  ILT:			CALL    ICP
04041E D0          0608*  ILT1:			RET     NC
04041F 18 42       0609*          		JR      TRUE_FP
040421             0610*  ;
040421 CD 23 0C 04 0611*  FGT:			CALL    FCP
040425 18 04       0612*          		JR      IGT1
040427 CD 15 0C 04 0613*  IGT:			CALL    ICP
04042B C8          0614*  IGT1:			RET     Z
04042C D8          0615*          		RET     C
04042D 18 34       0616*          		JR      TRUE_FP
04042F             0617*  ;
04042F CD 23 0C 04 0618*  FGE:			CALL    FCP
040433 18 04       0619*          		JR      IGE1
040435 CD 15 0C 04 0620*  IGE:			CALL    ICP
040439 D8          0621*  IGE1:			RET     C
04043A 18 27       0622*          		JR      TRUE_FP
04043C             0623*  ;
04043C CD 23 0C 04 0624*  FLE:			CALL    FCP
040440 18 04       0625*          		JR      ILE1
040442 CD 15 0C 04 0626*  ILE:			CALL    ICP
040446 28 1B       0627*  ILE1:			JR      Z,TRUE_FP
040448 D0          0628*          		RET     NC
040449 18 18       0629*          		JR      TRUE_FP
04044B             0630*  ;
04044B CD 23 0C 04 0631*  FNE:			CALL    FCP
04044F 18 04       0632*          		JR      INE1
040451 CD 15 0C 04 0633*  INE:			CALL    ICP
040455 C8          0634*  INE1:			RET     Z
040456 18 0B       0635*          		JR      TRUE_FP
040458             0636*  ;
040458 CD 23 0C 04 0637*  FEQ:			CALL    FCP
04045C 18 04       0638*          		JR      IEQ1
04045E CD 15 0C 04 0639*  IEQ:			CALL    ICP
040462 C0          0640*  IEQ1:			RET     NZ
040463 21 FF FF FF 0641*  TRUE_FP:			LD      HL,-1
040467 D9          0642*          		EXX
040468 21 FF FF FF 0643*          		LD      HL,-1
04046C D9          0644*          		EXX
04046D AF          0645*          		XOR     A
04046E 4F          0646*          		LD      C,A
04046F C9          0647*          		RET
040470             0648*  ;
040470             0649*  ;FUNCTIONS:
040470             0650*  ;
040470             0651*  ;Result returned in HLH'L'C (floating point)
040470             0652*  ;Result returned in HLH'L' (C=0) (integer)
040470             0653*  ;All registers except IY destroyed.
040470             0654*  ;
040470             0655*  ;ABS - Absolute value
040470             0656*  ;Result is numeric, variable type.
040470             0657*  ;
040470 CB 7C       0658*  ABSV_FP:			BIT     7,H
040472 C8          0659*          		RET     Z               ;POSITIVE/ZERO
040473 0D          0660*          		DEC     C
040474 0C          0661*          		INC     C
040475 CA D0 0A 04 0662*          		JP      Z,NEGATE        ;INTEGER
040479 CB BC       0663*          		RES     7,H
04047B C9          0664*          		RET
04047C             0665*  ;
04047C             0666*  ;NOT - Complement integer.
04047C             0667*  ;Result is integer numeric.
04047C             0668*  ;
04047C CD C0 0A 04 0669*  NOTK_FP:			CALL    SFIX_FP
040480 7C          0670*          		LD      A,H
040481 2F          0671*          		CPL
040482 67          0672*          		LD      H,A
040483 7D          0673*          		LD      A,L
040484 2F          0674*          		CPL
040485 6F          0675*          		LD      L,A
040486 D9          0676*          		EXX
040487 7C          0677*          		LD      A,H
040488 2F          0678*          		CPL
040489 67          0679*          		LD      H,A
04048A 7D          0680*          		LD      A,L
04048B 2F          0681*          		CPL
04048C 6F          0682*          		LD      L,A
04048D D9          0683*          		EXX
04048E AF          0684*          		XOR     A               ;NUMERIC MARKER
04048F C9          0685*          		RET
040490             0686*  ;
040490             0687*  ;PI - Return PI (3.141592654)
040490             0688*  ;Result is floating-point numeric.
040490             0689*  ;
040490 21 0F 49 00 0690*  PI_FP:			LD      HL,490FH
040494 D9          0691*          		EXX
040495 21 A2 DA 00 0692*          		LD      HL,0DAA2H
040499 D9          0693*          		EXX
04049A 0E 81       0694*          		LD      C,81H
04049C AF          0695*          		XOR     A               ;NUMERIC MARKER
04049D C9          0696*          		RET
04049E             0697*  ;
04049E             0698*  ;DEG - Convert radians to degrees
04049E             0699*  ;Result is floating-point numeric.
04049E             0700*  ;
04049E CD B2 04 04 0701*  DEG_FP:			CALL    FPI180
0404A2 CD 04 03 04 0702*          		CALL    FMUL
0404A6 AF          0703*          		XOR     A
0404A7 C9          0704*          		RET
0404A8             0705*  ;
0404A8             0706*  ;RAD - Convert degrees to radians
0404A8             0707*  ;Result is floating-point numeric.
0404A8             0708*  ;
0404A8 CD B2 04 04 0709*  RAD_FP:			CALL    FPI180
0404AC CD 5B 02 04 0710*          		CALL    FDIV
0404B0 AF          0711*          		XOR     A
0404B1 C9          0712*          		RET
0404B2             0713*  ;
0404B2             0714*  ;180/PI
0404B2             0715*  ;
0404B2 CD 9C 0B 04 0716*  FPI180:			CALL    SFLOAT_FP
0404B6 11 2E 65 00 0717*          		LD      DE,652EH
0404BA D9          0718*          		EXX
0404BB 11 D3 E0 00 0719*          		LD      DE,0E0D3H
0404BF D9          0720*          		EXX
0404C0 06 85       0721*          		LD      B,85H
0404C2 C9          0722*          		RET
0404C3             0723*  ;
0404C3             0724*  ;SGN - Return -1, 0 or +1
0404C3             0725*  ;Result is integer numeric.
0404C3             0726*  ;
0404C3 CD F5 0B 04 0727*  SGN_FP:			CALL    TEST_FP
0404C7 B1          0728*          		OR      C
0404C8 C8          0729*          		RET     Z               ;ZERO
0404C9 CB 7C       0730*          		BIT     7,H
0404CB C2 63 04 04 0731*          		JP      NZ,TRUE_FP         ;-1
0404CF CD 19 0C 04 0732*          		CALL    ZERO_FP
0404D3 C3 B5 0B 04 0733*          		JP      ADD1_FP            ;1
0404D7             0734*  ;
0404D7             0735*  ;VAL - Return numeric value of string.
0404D7             0736*  ;Input: ASCII string at IX
0404D7             0737*  ;Result is variable type numeric.
0404D7             0738*  ;
0404D7 CD 33 0E 04 0739*  VAL_FP:			CALL    SIGNQ
0404DB F5          0740*          		PUSH    AF
0404DC CD E3 09 04 0741*          		CALL    CON_FP
0404E0 F1          0742*          		POP     AF
0404E1 FE 2D       0743*          		CP      '-'
0404E3 3E 00       0744*          		LD      A,0             ;NUMERIC MARKER
0404E5 C0          0745*          		RET     NZ
0404E6 0D          0746*          		DEC     C
0404E7 0C          0747*          		INC     C
0404E8 CA D0 0A 04 0748*          		JP      Z,NEGATE        ;ZERO/INTEGER
0404EC 7C          0749*          		LD      A,H
0404ED EE 80       0750*          		XOR     80H             ;CHANGE SIGN (FP)
0404EF 67          0751*          		LD      H,A
0404F0 AF          0752*          		XOR     A
0404F1 C9          0753*          		RET
0404F2             0754*  ;
0404F2             0755*  ;INT - Floor function
0404F2             0756*  ;Result is integer numeric.
0404F2             0757*  ;
0404F2 0D          0758*  INT_FP_:			DEC     C
0404F3 0C          0759*          		INC     C
0404F4 C8          0760*          		RET     Z               ;ZERO/INTEGER
0404F5 3E 9F       0761*          		LD      A,159
0404F7 44          0762*          		LD      B,H             ;B7=SIGN BIT
0404F8 CD A1 0A 04 0763*          		CALL    FIX
0404FC 08          0764*          		EX      AF,AF'
0404FD A0          0765*          		AND     B
0404FE FC B5 0B 04 0766*          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
040502 78          0767*          		LD      A,B
040503 B7          0768*          		OR      A
040504 FC D0 0A 04 0769*          		CALL    M,NEGATE
040508 AF          0770*          		XOR     A
040509 4F          0771*          		LD      C,A
04050A C9          0772*          		RET
04050B             0773*  ;
04050B             0774*  ;SQR - square root
04050B             0775*  ;Result is floating-point numeric.
04050B             0776*  ;
04050B CD 9C 0B 04 0777*  SQR_FP:			CALL    SFLOAT_FP
04050F CB 7C       0778*  SQR0:			BIT     7,H
040511 3E 15       0779*          		LD      A,NGROOT
040513 C2 73 00 04 0780*          		JP      NZ,ERROR_FP_        ;"-ve root"
040517 0D          0781*          		DEC     C
040518 0C          0782*          		INC     C
040519 C8          0783*          		RET     Z               ;ZERO
04051A CB FC       0784*          		SET     7,H             ;IMPLIED 1
04051C CB 41       0785*          		BIT     0,C
04051E CC D5 0B 04 0786*          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
040522 79          0787*          		LD      A,C
040523 D6 80       0788*          		SUB     80H
040525 CB 2F       0789*          		SRA     A               ;HALVE EXPONENT
040527 C6 80       0790*          		ADD     A,80H
040529 4F          0791*          		LD      C,A
04052A C5          0792*          		PUSH    BC              ;SAVE EXPONENT
04052B EB          0793*          		EX      DE,HL
04052C 21 00 00 00 0794*          		LD      HL,0
040530 44          0795*          		LD      B,H
040531 4D          0796*          		LD      C,L
040532 D9          0797*          		EXX
040533 EB          0798*          		EX      DE,HL
040534 21 00 00 00 0799*          		LD      HL,0
040538 44          0800*          		LD      B,H
040539 4D          0801*          		LD      C,L
04053A 3E E1       0802*          		LD      A,-31
04053C CD CB 0D 04 0803*          		CALL    SQRA            ;ROOT
040540 D9          0804*          		EXX
040541 CB 78       0805*          		BIT     7,B
040543 D9          0806*          		EXX
040544 CC CB 0D 04 0807*          		CALL    Z,SQRA          ;NORMALISE & INC A
040548 CD 0C 0E 04 0808*          		CALL    SQRB
04054C B7          0809*          		OR      A               ;CLEAR CARRY
04054D CD 79 0D 04 0810*          		CALL    DIVB
040551 CB 1B       0811*          		RR      E               ;LSB TO CARRY
040553 60          0812*          		LD      H,B
040554 69          0813*          		LD      L,C
040555 D9          0814*          		EXX
040556 60          0815*          		LD      H,B
040557 69          0816*          		LD      L,C
040558 DC B5 0B 04 0817*          		CALL    C,ADD1_FP          ;ROUND UP
04055C C1          0818*          		POP     BC              ;RESTORE EXPONENT
04055D DC E2 0B 04 0819*          		CALL    C,INCC
040561 1F          0820*          		RRA
040562 9F          0821*          		SBC     A,A
040563 81          0822*          		ADD     A,C
040564 4F          0823*          		LD      C,A
040565 CB BC       0824*          		RES     7,H             ;POSITIVE
040567 AF          0825*          		XOR     A
040568 C9          0826*          		RET
040569             0827*  ;
040569             0828*  ;TAN - Tangent function
040569             0829*  ;Result is floating-point numeric.
040569             0830*  ;
040569 CD 9C 0B 04 0831*  TAN_FP:			CALL    SFLOAT_FP
04056D CD A9 0C 04 0832*          		CALL    PUSH5
040571 CD 93 05 04 0833*          		CALL    COS0
040575 CD B2 0C 04 0834*          		CALL    POP5
040579 CD A9 0C 04 0835*          		CALL    PUSH5
04057D CD CD 0B 04 0836*          		CALL    SWAP_FP
040581 CD A0 05 04 0837*          		CALL    SIN0
040585 CD B2 0C 04 0838*          		CALL    POP5
040589 CD 5B 02 04 0839*          		CALL    FDIV
04058D AF          0840*          		XOR     A               ;NUMERIC MARKER
04058E C9          0841*          		RET
04058F             0842*  ;
04058F             0843*  ;COS - Cosine function
04058F             0844*  ;Result is floating-point numeric.
04058F             0845*  ;
04058F CD 9C 0B 04 0846*  COS_FP:			CALL    SFLOAT_FP
040593 CD F8 0A 04 0847*  COS0:			CALL    SCALE
040597 1C          0848*          		INC     E
040598 1C          0849*          		INC     E
040599 7B          0850*          		LD      A,E
04059A 18 10       0851*          		JR      SIN1
04059C             0852*  ;
04059C             0853*  ;SIN - Sine function
04059C             0854*  ;Result is floating-point numeric.
04059C             0855*  ;
04059C CD 9C 0B 04 0856*  SIN_FP:			CALL    SFLOAT_FP
0405A0 E5          0857*  SIN0:			PUSH    HL              ;H7=SIGN
0405A1 CD F8 0A 04 0858*          		CALL    SCALE
0405A5 F1          0859*          		POP     AF
0405A6 07          0860*          		RLCA
0405A7 07          0861*          		RLCA
0405A8 07          0862*          		RLCA
0405A9 E6 04       0863*          		AND     4
0405AB AB          0864*          		XOR     E
0405AC F5          0865*  SIN1:			PUSH    AF              ;OCTANT
0405AD CB BC       0866*          		RES     7,H
0405AF 1F          0867*          		RRA
0405B0 CD 3E 06 04 0868*          		CALL    PIBY4
0405B4 DC DF 01 04 0869*          		CALL    C,RSUB          ;X=(PI/4)-X
0405B8 F1          0870*          		POP     AF
0405B9 F5          0871*          		PUSH    AF
0405BA E6 03       0872*          		AND     3
0405BC E2 F5 05 04 0873*          		JP      PO,SIN2         ;USE COSINE APPROX.
0405C0 CD A9 0C 04 0874*          		CALL    PUSH5           ;SAVE X
0405C4 CD A1 0C 04 0875*          		CALL    SQUARE          ;PUSH X*X
0405C8 CD E6 0C 04 0876*          		CALL    POLY
0405CC B7 A8       0877*          		DW	0A8B7H          ;a(8)
0405CE 11 36       0878*          		DW	3611H
0405D0 6D          0879*          		DB	6DH
0405D1 26 DE       0880*          		DW	0DE26H          ;a(6)
0405D3 05 D0       0881*          		DW	0D005H
0405D5 73          0882*          		DB	73H
0405D6 C0 80       0883*          		DW	80C0H           ;a(4)
0405D8 88 08       0884*          		DW	888H
0405DA 79          0885*          		DB	79H
0405DB 9D AA       0886*          		DW	0AA9DH          ;a(2)
0405DD AA AA       0887*          		DW	0AAAAH
0405DF 7D          0888*          		DB	7DH
0405E0 00 00       0889*          		DW	0               ;a(0)
0405E2 00 00       0890*          		DW	0
0405E4 80          0891*          		DB	80H
0405E5 CD B2 0C 04 0892*          		CALL    POP5
0405E9 CD B2 0C 04 0893*          		CALL    POP5
0405ED CD 04 03 04 0894*          		CALL    FMUL
0405F1 C3 1A 06 04 0895*          		JP      SIN3
0405F5             0896*  ;
0405F5 CD A1 0C 04 0897*  SIN2:			CALL    SQUARE          ;PUSH X*X
0405F9 CD E6 0C 04 0898*          		CALL    POLY
0405FD 71 D5       0899*          		DW	0D571H          ;b(8)
0405FF 78 4C       0900*          		DW	4C78H
040601 70          0901*          		DB	70H
040602 AF 94       0902*          		DW	94AFH           ;b(6)
040604 03 B6       0903*          		DW	0B603H
040606 76          0904*          		DB	76H
040607 C8 9C       0905*          		DW	9CC8H           ;b(4)
040609 AA 2A       0906*          		DW	2AAAH
04060B 7B          0907*          		DB	7BH
04060C DD FF       0908*          		DW	0FFDDH          ;b(2)
04060E FF FF       0909*          		DW	0FFFFH
040610 7E          0910*          		DB	7EH
040611 00 00       0911*          		DW	0               ;b(0)
040613 00 00       0912*          		DW	0
040615 80          0913*          		DB	80H
040616 CD B2 0C 04 0914*          		CALL    POP5
04061A F1          0915*  SIN3:			POP     AF
04061B E6 04       0916*          		AND     4
04061D C8          0917*          		RET     Z
04061E 0D          0918*          		DEC     C
04061F 0C          0919*          		INC     C
040620 C8          0920*          		RET     Z               ;ZERO
040621 CB FC       0921*          		SET     7,H             ;MAKE NEGATIVE
040623 C9          0922*          		RET
040624             0923*  ;
040624             0924*  ;Floating-point one:
040624             0925*  ;
040624 21 00 00 00 0926*  FONE_FP:			LD      HL,0
040628 D9          0927*          		EXX
040629 21 00 00 00 0928*          		LD      HL,0
04062D D9          0929*          		EXX
04062E 0E 80       0930*          		LD      C,80H
040630 C9          0931*          		RET
040631             0932*  ;
040631 11 00 00 00 0933*  DONE:			LD      DE,0
040635 D9          0934*          		EXX
040636 11 00 00 00 0935*          		LD      DE,0
04063A D9          0936*          		EXX
04063B 06 80       0937*          		LD      B,80H
04063D C9          0938*          		RET
04063E             0939*  ;
04063E 11 0F 49 00 0940*  PIBY4:			LD      DE,490FH
040642 D9          0941*          		EXX
040643 11 A2 DA 00 0942*          		LD      DE,0DAA2H
040647 D9          0943*          		EXX
040648 06 7F       0944*          		LD      B,7FH
04064A C9          0945*          		RET
04064B             0946*  ;
04064B             0947*  ;EXP - Exponential function
04064B             0948*  ;Result is floating-point numeric.
04064B             0949*  ;
04064B CD 9C 0B 04 0950*  EXP_FP:			CALL    SFLOAT_FP
04064F CD DC 06 04 0951*  EXP0:			CALL    LN2             ;LN(2)
040653 D9          0952*          		EXX
040654 1D          0953*  	        	DEC     E
040655 01 CF D1 00 0954*  		        LD      BC,0D1CFH       ;0.6931471805599453
040659 D9          0955*          		EXX
04065A E5          0956*          		PUSH    HL              ;H7=SIGN
04065B CD 0B 0B 04 0957*          		CALL    MOD48           ;"MODULUS"
04065F F1          0958*          		POP     AF
040660 CB 7B       0959*          		BIT     7,E
040662 28 0B       0960*          		JR      Z,EXP1
040664 17          0961*          		RLA
040665 DA 19 0C 04 0962*          		JP      C,ZERO_FP
040669 3E 18       0963*          		LD      A,EXPRNG
04066B C3 73 00 04 0964*          		JP      ERROR_FP_           ;"Exp range"
04066F             0965*  ;
04066F E6 80       0966*  EXP1:			AND     80H
040671 B3          0967*          		OR      E
040672 F5          0968*          		PUSH    AF              ;INTEGER PART
040673 CB BC       0969*          		RES     7,H
040675 CD A9 0C 04 0970*          		CALL    PUSH5           ;PUSH X*LN(2)
040679 CD E6 0C 04 0971*          		CALL    POLY
04067D 72 40       0972*          		DW	4072H           ;a(7)
04067F 2E 94       0973*          		DW	942EH
040681 73          0974*          		DB	73H
040682 65 6F       0975*          		DW	6F65H           ;a(6)
040684 4F 2E       0976*          		DW	2E4FH
040686 76          0977*          		DB	76H
040687 37 6D       0978*          		DW	6D37H           ;a(5)
040689 02 88       0979*          		DW	8802H
04068B 79          0980*          		DB	79H
04068C 12 E5       0981*          		DW	0E512H          ;a(4)
04068E A0 2A       0982*          		DW	2AA0H
040690 7B          0983*          		DB	7BH
040691 14 4F       0984*          		DW	4F14H           ;a(3)
040693 AA AA       0985*          		DW	0AAAAH
040695 7D          0986*          		DB	7DH
040696 56 FD       0987*          		DW	0FD56H          ;a(2)
040698 FF 7F       0988*          		DW	7FFFH
04069A 7E          0989*          		DB	7EH
04069B FE FF       0990*          		DW	0FFFEH          ;a(1)
04069D FF FF       0991*          		DW	0FFFFH
04069F 7F          0992*          		DB	7FH
0406A0 00 00       0993*          		DW	0               ;a(0)
0406A2 00 00       0994*          		DW	0
0406A4 80          0995*          		DB	80H
0406A5 CD B2 0C 04 0996*          		CALL    POP5
0406A9 F1          0997*          		POP     AF
0406AA F5          0998*          		PUSH    AF
0406AB F4 D0 06 04 0999*          		CALL    P,RECIP         ;X=1/X
0406AF F1          1000*          		POP     AF
0406B0 F2 B8 06 04 1001*          		JP      P,EXP4
0406B4 E6 7F       1002*          		AND     7FH
0406B6 ED 44       1003*          		NEG
0406B8 C6 80       1004*  EXP4:			ADD     A,80H
0406BA 81          1005*          		ADD     A,C
0406BB 38 06       1006*          		JR      C,EXP2
0406BD F2 19 0C 04 1007*          		JP      P,ZERO_FP          ;UNDERFLOW
0406C1 18 04       1008*          		JR      EXP3
0406C3 FA E4 0B 04 1009*  EXP2:			JP      M,OFLOW         ;OVERFLOW
0406C7 C6 80       1010*  EXP3:			ADD     A,80H
0406C9 CA 19 0C 04 1011*          		JP      Z,ZERO_FP
0406CD 4F          1012*          		LD      C,A
0406CE AF          1013*          		XOR     A               ;NUMERIC MARKER
0406CF C9          1014*          		RET
0406D0             1015*  ;
0406D0 CD 31 06 04 1016*  RECIP:			CALL    DONE
0406D4 CD CD 0B 04 1017*  RDIV:			CALL    SWAP_FP
0406D8 C3 5B 02 04 1018*          		JP      FDIV            ;RECIPROCAL
0406DC             1019*  ;
0406DC 11 72 31 00 1020*  LN2:			LD      DE,3172H        ;LN(2)
0406E0 D9          1021*          		EXX
0406E1 11 F8 17 00 1022*          		LD      DE,17F8H
0406E5 D9          1023*          		EXX
0406E6 06 7F       1024*          		LD      B,7FH
0406E8 C9          1025*          		RET
0406E9             1026*  ;
0406E9             1027*  ;LN - Natural log.
0406E9             1028*  ;Result is floating-point numeric.
0406E9             1029*  ;
0406E9 CD 9C 0B 04 1030*  LN_FP:			CALL    SFLOAT_FP
0406ED 3E 16       1031*  LN0:			LD      A,LOGRNG
0406EF CB 7C       1032*          		BIT     7,H
0406F1 C2 73 00 04 1033*          		JP      NZ,ERROR_FP_        ;"Log range"
0406F5 0C          1034*          		INC     C
0406F6 0D          1035*          		DEC     C
0406F7 CA 73 00 04 1036*          		JP      Z,ERROR_FP_
0406FB 11 04 35 00 1037*          		LD      DE,3504H        ;SQR(2)
0406FF D9          1038*          		EXX
040700 11 33 F3 00 1039*          		LD      DE,0F333H       ;1.41421356237
040704 D9          1040*          		EXX
040705 CD 2C 0C 04 1041*          		CALL    ICP0            ;MANTISSA>SQR(2)?
040709 79          1042*          		LD      A,C             ;EXPONENT
04070A 0E 80       1043*          		LD      C,80H           ;1 <= X < 2
04070C 38 02       1044*          		JR      C,LN4
04070E 0D          1045*          		DEC     C
04070F 3C          1046*          		INC     A
040710 F5          1047*  LN4:			PUSH    AF              ;SAVE EXPONENT
040711 CD BE 0C 04 1048*          		CALL    RATIO           ;X=(X-1)/(X+1)
040715 CD A9 0C 04 1049*          		CALL    PUSH5
040719 CD A1 0C 04 1050*  		        CALL    SQUARE          ;PUSH X*X
04071D CD E6 0C 04 1051*          		CALL    POLY
040721 48 CC       1052*          		DW	0CC48H          ;a(9)
040723 FB 74       1053*          		DW	74FBH
040725 7D          1054*          		DB	7DH
040726 AF AE       1055*          		DW	0AEAFH          ;a(7)
040728 FF 11       1056*          		DW	11FFH
04072A 7E          1057*          		DB	7EH
04072B 8C D9       1058*          		DW	0D98CH          ;a(5)
04072D CD 4C       1059*          		DW	4CCDH
04072F 7E          1060*          		DB	7EH
040730 E3 A9       1061*          		DW	0A9E3H          ;a(3)
040732 AA 2A       1062*          		DW	2AAAH
040734 7F          1063*          		DB	7FH
040735 00 00       1064*          		DW	0               ;a(1)
040737 00 00       1065*          		DW	0
040739 81          1066*          		DB	81H
04073A CD B2 0C 04 1067*          		CALL    POP5
04073E CD B2 0C 04 1068*          		CALL    POP5
040742 CD 04 03 04 1069*          		CALL    FMUL
040746 F1          1070*          		POP     AF              ;EXPONENT
040747 CD A9 0C 04 1071*          		CALL    PUSH5
04074B 08          1072*          		EX      AF,AF'
04074C CD 19 0C 04 1073*          		CALL    ZERO_FP
040750 08          1074*          		EX      AF,AF'
040751 D6 80       1075*          		SUB     80H
040753 28 1F       1076*          		JR      Z,LN3
040755 30 02       1077*          		JR      NC,LN1
040757 2F          1078*          		CPL
040758 3C          1079*          		INC     A
040759 67          1080*  LN1:			LD      H,A
04075A 0E 87       1081*          		LD      C,87H
04075C F5          1082*          		PUSH    AF
04075D CD 7C 0B 04 1083*          		CALL    FLOAT_
040761 CB BC       1084*          		RES     7,H
040763 CD DC 06 04 1085*          		CALL    LN2
040767 CD 04 03 04 1086*          		CALL    FMUL
04076B F1          1087*          		POP     AF
04076C 30 06       1088*          		JR      NC,LN3
04076E FA 74 07 04 1089*          		JP      M,LN3
040772 CB FC       1090*          		SET     7,H
040774 CD B2 0C 04 1091*  LN3:			CALL    POP5
040778 CD F2 01 04 1092*          		CALL    FADD
04077C AF          1093*          		XOR     A
04077D C9          1094*          		RET
04077E             1095*  ;
04077E             1096*  ;LOG - base-10 logarithm.
04077E             1097*  ;Result is floating-point numeric.
04077E             1098*  ;
04077E CD E9 06 04 1099*  LOG_FP:			CALL    LN_FP
040782 11 5B 5E 00 1100*          		LD      DE,5E5BH        ;LOG(e)
040786 D9          1101*          		EXX
040787 11 A9 D8 00 1102*          		LD      DE,0D8A9H
04078B D9          1103*          		EXX
04078C 06 7E       1104*          		LD      B,7EH
04078E CD 04 03 04 1105*          		CALL    FMUL
040792 AF          1106*          		XOR     A
040793 C9          1107*          		RET
040794             1108*  ;
040794             1109*  ;ASN - Arc-sine
040794             1110*  ;Result is floating-point numeric.
040794             1111*  ;
040794 CD 9C 0B 04 1112*  ASN_FP:			CALL    SFLOAT_FP
040798 CD A9 0C 04 1113*          		CALL    PUSH5
04079C CD 99 0C 04 1114*          		CALL    COPY_
0407A0 CD 04 03 04 1115*          		CALL    FMUL
0407A4 CD 31 06 04 1116*          		CALL    DONE
0407A8 CD DF 01 04 1117*          		CALL    RSUB
0407AC CD 0F 05 04 1118*          		CALL    SQR0
0407B0 CD B2 0C 04 1119*          		CALL    POP5
0407B4 0C          1120*          		INC     C
0407B5 0D          1121*          		DEC     C
0407B6 3E 02       1122*          		LD      A,2
0407B8 D5          1123*          		PUSH    DE
0407B9 CA 3E 08 04 1124*          		JP      Z,ACS1
0407BD D1          1125*          		POP     DE
0407BE CD D4 06 04 1126*          		CALL    RDIV
0407C2 18 04       1127*          		JR      ATN0
0407C4             1128*  ;
0407C4             1129*  ;ATN - arc-tangent
0407C4             1130*  ;Result is floating-point numeric.
0407C4             1131*  ;
0407C4 CD 9C 0B 04 1132*  ATN_FP:			CALL    SFLOAT_FP
0407C8 E5          1133*  ATN0:			PUSH    HL              ;SAVE SIGN
0407C9 CB BC       1134*          		RES     7,H
0407CB 11 13 54 00 1135*          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0407CF D9          1136*          		EXX
0407D0 11 D0 CC 00 1137*          		LD      DE,0CCD0H
0407D4 D9          1138*          		EXX
0407D5 06 7E       1139*          		LD      B,7EH
0407D7 CD 29 0C 04 1140*          		CALL    FCP0            ;COMPARE
0407DB 06 00       1141*          		LD      B,0
0407DD 38 22       1142*          		JR      C,ATN2
0407DF 11 82 1A 00 1143*          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0407E3 D9          1144*          		EXX
0407E4 11 9A 79 00 1145*          		LD      DE,799AH
0407E8 D9          1146*          		EXX
0407E9 06 81       1147*          		LD      B,81H
0407EB CD 29 0C 04 1148*          		CALL    FCP0            ;COMPARE
0407EF 38 0A       1149*          		JR      C,ATN1
0407F1 CD D0 06 04 1150*          		CALL    RECIP           ;X=1/X
0407F5 06 02       1151*          		LD      B,2
0407F7 C3 01 08 04 1152*          		JP      ATN2
0407FB CD BE 0C 04 1153*  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0407FF 06 01       1154*          		LD      B,1
040801 C5          1155*  ATN2:			PUSH    BC              ;SAVE FLAG
040802 CD A9 0C 04 1156*          		CALL    PUSH5
040806 CD A1 0C 04 1157*          		CALL    SQUARE          ;PUSH X*X
04080A CD E6 0C 04 1158*          		CALL    POLY
04080E 35 F3       1159*          		DW	0F335H          ;a(13)
040810 D8 37       1160*          		DW	37D8H
040812 7B          1161*          		DB	7BH
040813 91 6B       1162*          		DW	6B91H           ;a(11)
040815 B9 AA       1163*          		DW	0AAB9H
040817 7C          1164*          		DB	7CH
040818 DE 41       1165*          		DW	41DEH           ;a(9)
04081A 97 61       1166*          		DW	6197H
04081C 7C          1167*          		DB	7CH
04081D 7B 9D       1168*          		DW	9D7BH           ;a(7)
04081F 37 92       1169*          		DW	9237H
040821 7D          1170*          		DB	7DH
040822 5A 2A       1171*          		DW	2A5AH           ;a(5)
040824 CC 4C       1172*          		DW	4CCCH
040826 7D          1173*          		DB	7DH
040827 5C A9       1174*          		DW	0A95CH          ;a(3)
040829 AA AA       1175*          		DW	0AAAAH
04082B 7E          1176*          		DB	7EH
04082C 00 00       1177*          		DW	0               ;a(1)
04082E 00 00       1178*          		DW	0
040830 80          1179*          		DB	80H
040831 CD B2 0C 04 1180*          		CALL    POP5
040835 CD B2 0C 04 1181*          		CALL    POP5
040839 CD 04 03 04 1182*          		CALL    FMUL
04083D F1          1183*          		POP     AF
04083E CD 3E 06 04 1184*  ACS1:			CALL    PIBY4           ;PI/4
040842 1F          1185*          		RRA
040843 F5          1186*          		PUSH    AF
040844 DC F2 01 04 1187*          		CALL    C,FADD
040848 F1          1188*          		POP     AF
040849 04          1189*          		INC     B
04084A 1F          1190*          		RRA
04084B DC DF 01 04 1191*          		CALL    C,RSUB
04084F F1          1192*          		POP     AF
040850 B7          1193*          		OR      A
040851 F0          1194*          		RET     P
040852 CB FC       1195*          		SET     7,H             ;MAKE NEGATIVE
040854 AF          1196*          		XOR     A
040855 C9          1197*          		RET
040856             1198*  ;
040856             1199*  ;ACS - Arc cosine=PI/2-ASN.
040856             1200*  ;Result is floating point numeric.
040856             1201*  ;
040856 CD 94 07 04 1202*  ACS_FP:			CALL    ASN_FP
04085A 3E 02       1203*          		LD      A,2
04085C F5          1204*          		PUSH    AF
04085D 18 DF       1205*          		JR      ACS1
04085F             1206*  ;
04085F             1207*  ;Function STR - convert numeric value to ASCII string.
04085F             1208*  ;   Inputs: HLH'L'C = integer or floating-point number
04085F             1209*  ;           DE = address at which to store string
04085F             1210*  ;           IX = address of @% format control
04085F             1211*  ;  Outputs: String stored, with NUL terminator
04085F             1212*  ;
04085F             1213*  ;First normalise for decimal output:
04085F             1214*  ;
04085F CD 9C 0B 04 1215*  STR_FP:			CALL    SFLOAT_FP
040863 06 00       1216*          		LD      B,0             ;DEFAULT PT. POSITION
040865 CB 7C       1217*          		BIT     7,H             ;NEGATIVE?
040867 28 06       1218*          		JR      Z,STR10
040869 CB BC       1219*          		RES     7,H
04086B 3E 2D       1220*          		LD      A,'-'
04086D 12          1221*          		LD      (DE),A          ;STORE SIGN
04086E 13          1222*          		INC     DE
04086F AF          1223*  STR10:			XOR     A               ;CLEAR A
040870 B9          1224*          		CP      C
040871 28 4E       1225*          		JR      Z,STR02          ;ZERO
040873 D5          1226*          		PUSH    DE              ;SAVE TEXT POINTER
040874 78          1227*          		LD      A,B
040875 F5          1228*  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
040876 79          1229*          		LD      A,C             ;BINARY EXPONENT
040877 FE A1       1230*          		CP      161
040879 30 1C       1231*          		JR      NC,STR14
04087B FE 9B       1232*          		CP      155
04087D 30 29       1233*          		JR      NC,STR15
04087F 2F          1234*          		CPL
040880 FE E1       1235*          		CP      225
040882 38 02       1236*          		JR      C,STR13
040884 3E F8       1237*          		LD      A,-8
040886 C6 1C       1238*  STR13:			ADD     A,28
040888 CD 15 0D 04 1239*          		CALL    POWR10
04088C F5          1240*          		PUSH    AF
04088D CD 04 03 04 1241*          		CALL    FMUL
040891 F1          1242*          		POP     AF
040892 47          1243*          		LD      B,A
040893 F1          1244*          		POP     AF
040894 90          1245*          		SUB     B
040895 18 DE       1246*          		JR      STR11
040897 D6 20       1247*  STR14:			SUB     32
040899 CD 15 0D 04 1248*          		CALL    POWR10
04089D F5          1249*          		PUSH    AF
04089E CD 5B 02 04 1250*          		CALL    FDIV
0408A2 F1          1251*          		POP     AF
0408A3 47          1252*          		LD      B,A
0408A4 F1          1253*          		POP     AF
0408A5 80          1254*          		ADD     A,B
0408A6 18 CD       1255*          		JR      STR11
0408A8 3E 09       1256*  STR15:			LD      A,9
0408AA CD 15 0D 04 1257*          		CALL    POWR10          ;10^9
0408AE CD 29 0C 04 1258*          		CALL    FCP0
0408B2 79          1259*          		LD      A,C
0408B3 C1          1260*          		POP     BC
0408B4 4F          1261*          		LD      C,A
0408B5 CB FC       1262*          		SET     7,H             ;IMPLIED 1
0408B7 DC 51 0C 04 1263*          		CALL    C,X10B          ;X10, DEC B
0408BB D1          1264*          		POP     DE              ;RESTORE TEXT POINTER
0408BC CB B9       1265*          		RES     7,C
0408BE 3E 00       1266*          		LD      A,0
0408C0 17          1267*          		RLA                     ;PUT CARRY IN LSB
0408C1             1268*  ;
0408C1             1269*  ;At this point decimal normalisation has been done,
0408C1             1270*  ;now convert to decimal digits:
0408C1             1271*  ;      AHLH'L' = number in normalised integer form
0408C1             1272*  ;            B = decimal place adjustment
0408C1             1273*  ;            C = binary place adjustment (29-33)
0408C1             1274*  ;
0408C1 0C          1275*  STR02:			INC     C
0408C2 08          1276*          		EX      AF,AF'          ;SAVE A
0408C3 78          1277*          		LD      A,B
0408C4 DD CB 02 4E 1278*          		BIT     1,(IX+2)
0408C8 20 08       1279*          		JR      NZ,STR20
0408CA AF          1280*          		XOR     A
0408CB DD BE 01    1281*          		CP      (IX+1)
0408CE 28 0B       1282*          		JR      Z,STR21
0408D0 3E F6       1283*          		LD      A,-10
0408D2 DD 86 01    1284*  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0408D5 B7          1285*          		OR      A               ;CLEAR CARRY
0408D6 FA DB 08 04 1286*          		JP      M,STR21
0408DA AF          1287*          		XOR     A
0408DB F5          1288*  STR21:			PUSH    AF
0408DC 08          1289*          		EX      AF,AF'          ;RESTORE A
0408DD CD 85 0C 04 1290*  STR22:			CALL    X2              ;RL AHLH'L'
0408E1 8F          1291*          		ADC     A,A
0408E2 FE 0A       1292*          		CP      10
0408E4 38 05       1293*          		JR      C,STR23
0408E6 D6 0A       1294*          		SUB     10
0408E8 D9          1295*          		EXX
0408E9 2C          1296*          		INC     L               ;SET RESULT BIT
0408EA D9          1297*          		EXX
0408EB 0D          1298*  STR23:			DEC     C
0408EC 20 EF       1299*          		JR      NZ,STR22        ;32 TIMES
0408EE 4F          1300*          		LD      C,A             ;REMAINDER
0408EF 7C          1301*          		LD      A,H
0408F0 E6 3F       1302*          		AND     3FH             ;CLEAR OUT JUNK
0408F2 67          1303*          		LD      H,A
0408F3 F1          1304*          		POP     AF
0408F4 F2 02 09 04 1305*          		JP      P,STR24
0408F8 3C          1306*          		INC     A
0408F9 20 1C       1307*          		JR      NZ,STR26
0408FB 3E 04       1308*          		LD      A,4
0408FD B9          1309*          		CP      C               ;ROUND UP?
0408FE 3E 00       1310*          		LD      A,0
040900 18 15       1311*          		JR      STR26
040902 F5          1312*  STR24:			PUSH    AF
040903 79          1313*          		LD      A,C
040904 CE 30       1314*          		ADC     A,'0'           ;ADD CARRY
040906 FE 30       1315*          		CP      '0'
040908 28 05       1316*          		JR      Z,STR25         ;SUPPRESS ZERO
04090A FE 3A       1317*          		CP      '9'+1
04090C 3F          1318*          		CCF
04090D 30 08       1319*          		JR      NC,STR26
04090F E3          1320*  STR25:			EX      (SP),HL
040910 CB 75       1321*          		BIT     6,L             ;ZERO FLAG
040912 E3          1322*  		        EX      (SP),HL
040913 20 05       1323*          		JR      NZ,STR27
040915 3E 30       1324*          		LD      A,'0'
040917 3C          1325*  STR26:			INC     A               ;SET +VE
040918 3D          1326*          		DEC     A
040919 F5          1327*          		PUSH    AF              ;PUT ON STACK + CARRY
04091A 04          1328*  STR27:			INC     B
04091B CD F5 0B 04 1329*          		CALL    TEST_FP            ;IS HLH'L' ZERO?
04091F 0E 20       1330*          		LD      C,32
040921 3E 00       1331*          		LD      A,0
040923 20 B8       1332*          		JR      NZ,STR22
040925 F1          1333*          		POP     AF
040926 F5          1334*          		PUSH    AF
040927 3E 00       1335*          		LD      A,0
040929 38 B2       1336*          		JR      C,STR22
04092B             1337*  ;
04092B             1338*  ;At this point, the decimal character string is stored
04092B             1339*  ; on the stack. Trailing zeroes are suppressed and may
04092B             1340*  ; need to be replaced.
04092B             1341*  ;B register holds decimal point position.
04092B             1342*  ;Now format number and store as ASCII string:
04092B             1343*  ;
04092B EB          1344*  STR3:			EX      DE,HL           ;STRING POINTER
04092C 0E FF       1345*          		LD      C,-1            ;FLAG "E"
04092E 16 01       1346*          		LD      D,1
040930 DD 5E 01    1347*          		LD      E,(IX+1)        ;f2
040933 DD CB 02 46 1348*          		BIT     0,(IX+2)
040937 20 35       1349*          		JR      NZ,STR34        ;E MODE
040939 DD CB 02 4E 1350*          		BIT     1,(IX+2)
04093D 28 12       1351*          		JR      Z,STR31
04093F 78          1352*          		LD      A,B             ;F MODE
040940 B7          1353*          		OR      A
040941 28 05       1354*          		JR      Z,STR30
040943 FA 48 09 04 1355*          		JP      M,STR30
040947 50          1356*          		LD      D,B
040948 7A          1357*  STR30:			LD      A,D
040949 DD 86 01    1358*          		ADD     A,(IX+1)
04094C 5F          1359*          		LD      E,A
04094D FE 0B       1360*          		CP      11
04094F 38 19       1361*          		JR      C,STR32
040951 78          1362*  STR31:			LD      A,B             ;G MODE
040952 11 01 01 00 1363*          		LD      DE,101H
040956 B7          1364*          		OR      A
040957 FA 6E 09 04 1365*          		JP      M,STR34
04095B 28 0D       1366*          		JR      Z,STR32
04095D DD 7E 01    1367*          		LD      A,(IX+1)
040960 B7          1368*          		OR      A
040961 20 02       1369*          		JR      NZ,STR3A
040963 3E 0A       1370*          		LD      A,10
040965 B8          1371*  STR3A:			CP      B
040966 38 06       1372*          		JR      C,STR34
040968 50          1373*          		LD      D,B
040969 58          1374*          		LD      E,B
04096A 78          1375*  STR32:			LD      A,B
04096B C6 81       1376*          		ADD     A,129
04096D 4F          1377*          		LD      C,A
04096E CB FA       1378*  STR34:			SET     7,D
040970 1D          1379*          		DEC     E
040971 7A          1380*  STR35:			LD      A,D
040972 B9          1381*          		CP      C
040973 30 0E       1382*          		JR      NC,STR33
040975 F1          1383*  STR36:			POP     AF
040976 28 04       1384*          		JR      Z,STR37
040978 F2 85 09 04 1385*          		JP      P,STR38
04097C F5          1386*  STR37:			PUSH    AF
04097D 1C          1387*          		INC     E
04097E 1D          1388*          		DEC     E
04097F FA 96 09 04 1389*          		JP      M,STR4
040983 3E 30       1390*  STR33:			LD      A,'0'
040985 15          1391*  STR38:			DEC     D
040986 E2 8D 09 04 1392*          		JP      PO,STR39
04098A 36 2E       1393*          		LD      (HL),'.'
04098C 23          1394*          		INC     HL
04098D 77          1395*  STR39:			LD      (HL),A
04098E 23          1396*          		INC     HL
04098F 1D          1397*          		DEC     E
040990 F2 71 09 04 1398*          		JP      P,STR35
040994 18 DF       1399*          		JR      STR36
040996             1400*  ;
040996 F1          1401*  STR4:			POP     AF
040997 0C          1402*  STR40:			INC     C
040998 4D          1403*          		LD      C,L
040999 20 28       1404*          		JR      NZ,STR44
04099B 36 45       1405*          		LD      (HL),'E'        ;EXPONENT
04099D 23          1406*          		INC     HL
04099E 78          1407*          		LD      A,B
04099F 3D          1408*          		DEC     A
0409A0 F2 A9 09 04 1409*          		JP      P,STR41
0409A4 36 2D       1410*          		LD      (HL),'-'
0409A6 23          1411*          		INC     HL
0409A7 ED 44       1412*          		NEG
0409A9 36 30       1413*  STR41:			LD      (HL),'0'
0409AB 28 15       1414*          		JR      Z,STR47
0409AD FE 0A       1415*          		CP      10
0409AF 47          1416*          		LD      B,A
0409B0 3E 3A       1417*          		LD      A,':'
0409B2 38 03       1418*          		JR      C,STR42
0409B4 23          1419*          		INC     HL
0409B5 36 30       1420*          		LD      (HL),'0'
0409B7 34          1421*  STR42:			INC     (HL)
0409B8 BE          1422*          		CP      (HL)
0409B9 20 05       1423*          		JR      NZ,STR43
0409BB 36 30       1424*          		LD      (HL),'0'
0409BD 2B          1425*          		DEC     HL
0409BE 34          1426*          		INC     (HL)
0409BF 23          1427*          		INC     HL
0409C0 10 F5       1428*  STR43:			DJNZ    STR42
0409C2 23          1429*  STR47:			INC     HL
0409C3 EB          1430*  STR44:			EX      DE,HL
0409C4 C9          1431*        			RET
0409C5             1432*  ;
0409C5             1433*  ;Support subroutines:
0409C5             1434*  ;
0409C5 DD 46 04    1435*  DLOAD5:			LD      B,(IX+4)
0409C8 D9          1436*          		EXX
0409C9 DD 5E 00    1437*          		LD      E,(IX+0)
0409CC DD 56 01    1438*          		LD      D,(IX+1)
0409CF D9          1439*          		EXX
0409D0 DD 5E 02    1440*          		LD      E,(IX+2)
0409D3 DD 56 03    1441*          		LD      D,(IX+3)
0409D6 C9          1442*          		RET
0409D7             1443*  ;
0409D7 DD 46 06    1444*  DLOAD5_SPL:		LD      B,(IX+6)
0409DA D9          1445*  			EXX
0409DB DD 17 00    1446*  			LD	DE, (IX+0)
0409DE D9          1447*  			EXX
0409DF DD 17 03    1448*  			LD	DE, (IX+3)
0409E2 C9          1449*  			RET
0409E3             1450*  ;
0409E3             1451*  ;CON_FP - Get unsigned numeric constant from ASCII string.
0409E3             1452*  ;   Inputs: ASCII string at (IX).
0409E3             1453*  ;  Outputs: Variable-type result in HLH'L'C
0409E3             1454*  ;           IX updated (points to delimiter)
0409E3             1455*  ;           A7 = 0 (numeric marker)
0409E3             1456*  ;
0409E3 CD 19 0C 04 1457*  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
0409E7 0E 00       1458*          		LD      C,0             ;TRUNCATION COUNTER
0409E9 CD 77 0A 04 1459*          		CALL    UINT          ;GET INTEGER PART
0409ED FE 2E       1460*          		CP      '.'
0409EF 06 00       1461*          		LD      B,0             ;DECL. PLACE COUNTER
0409F1 CC 75 0A 04 1462*          		CALL    Z,NUMBIX        ;GET FRACTION PART
0409F5 FE 45       1463*          		CP      'E'
0409F7 3E 00       1464*          		LD      A,0             ;INITIALISE EXPONENT
0409F9 CC 43 0A 04 1465*          		CALL    Z,GETEXP        ;GET EXPONENT
0409FD CB 7C       1466*          		BIT     7,H
0409FF 20 08       1467*          		JR      NZ,CON0         ;INTEGER OVERFLOW
040A01 B7          1468*          		OR      A
040A02 20 05       1469*          		JR      NZ,CON0         ;EXPONENT NON-ZERO
040A04 B8          1470*          		CP      B
040A05 20 02       1471*          		JR      NZ,CON0         ;DECIMAL POINT
040A07 B9          1472*          		CP      C
040A08 C8          1473*          		RET     Z               ;INTEGER
040A09 90          1474*  CON0:			SUB     B
040A0A 81          1475*          		ADD     A,C
040A0B 0E 9F       1476*          		LD      C,159
040A0D CD 7C 0B 04 1477*          		CALL    FLOAT_
040A11 CB BC       1478*          		RES     7,H             ;DITCH IMPLIED 1
040A13 B7          1479*          		OR      A
040A14 C8          1480*          		RET     Z               ;DONE
040A15 FA 23 0A 04 1481*          		JP      M,CON2          ;NEGATIVE EXPONENT
040A19 CD 15 0D 04 1482*          		CALL    POWR10
040A1D CD 04 03 04 1483*          		CALL    FMUL            ;SCALE
040A21 AF          1484*          		XOR     A
040A22 C9          1485*          		RET
040A23 FE DA       1486*  CON2:			CP      -38
040A25 38 0C       1487*          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
040A27 ED 44       1488*          		NEG
040A29 CD 15 0D 04 1489*          		CALL    POWR10
040A2D CD 5B 02 04 1490*          		CALL    FDIV            ;SCALE
040A31 AF          1491*          		XOR     A
040A32 C9          1492*          		RET
040A33 F5          1493*  CON3:			PUSH    AF
040A34 3E 26       1494*          		LD      A,38
040A36 CD 15 0D 04 1495*          		CALL    POWR10
040A3A CD 5B 02 04 1496*          		CALL    FDIV
040A3E F1          1497*          		POP     AF
040A3F C6 26       1498*          		ADD     A,38
040A41 18 E0       1499*          		JR      CON2
040A43             1500*  ;
040A43             1501*  ;GETEXP - Get decimal exponent from string
040A43             1502*  ;     Inputs: ASCII string at (IX)
040A43             1503*  ;             (IX points at 'E')
040A43             1504*  ;             A = initial value
040A43             1505*  ;    Outputs: A = new exponent
040A43             1506*  ;             IX updated.
040A43             1507*  ;   Destroys: A,A',IX,F,F'
040A43             1508*  ;
040A43 C5          1509*  GETEXP:			PUSH    BC              ;SAVE REGISTERS
040A44 47          1510*          		LD      B,A             ;INITIAL VALUE
040A45 0E 02       1511*          		LD      C,2             ;2 DIGITS MAX
040A47 DD 23       1512*          		INC     IX              ;BUMP PAST 'E'
040A49 CD 33 0E 04 1513*          		CALL    SIGNQ
040A4D 08          1514*          		EX      AF,AF'          ;SAVE EXPONENT SIGN
040A4E CD 29 0E 04 1515*  GETEX1:			CALL    DIGITQ
040A52 38 18       1516*          		JR      C,GETEX2
040A54 78          1517*          		LD      A,B             ;B=B*10
040A55 87          1518*          		ADD     A,A
040A56 87          1519*          		ADD     A,A
040A57 80          1520*          		ADD     A,B
040A58 87          1521*          		ADD     A,A
040A59 47          1522*          		LD      B,A
040A5A DD 7E 00    1523*          		LD      A,(IX)          ;GET BACK DIGIT
040A5D DD 23       1524*          		INC     IX
040A5F E6 0F       1525*          		AND     0FH             ;MASK UNWANTED BITS
040A61 80          1526*          		ADD     A,B             ;ADD IN DIGIT
040A62 47          1527*          		LD      B,A
040A63 0D          1528*          		DEC     C
040A64 F2 4E 0A 04 1529*          		JP      P,GETEX1
040A68 06 64       1530*          		LD      B,100           ;FORCE OVERFLOW
040A6A 18 E2       1531*          		JR      GETEX1
040A6C 08          1532*  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
040A6D FE 2D       1533*          		CP      '-'
040A6F 78          1534*          		LD      A,B
040A70 C1          1535*          		POP     BC              ;RESTORE
040A71 C0          1536*          		RET     NZ
040A72 ED 44       1537*          		NEG                     ;NEGATE EXPONENT
040A74 C9          1538*          		RET
040A75             1539*  ;
040A75             1540*  ;UINT: Get unsigned integer from string.
040A75             1541*  ;    Inputs: string at (IX)
040A75             1542*  ;            C = truncated digit count
040A75             1543*  ;                (initially zero)
040A75             1544*  ;            B = total digit count
040A75             1545*  ;            HLH'L' = initial value
040A75             1546*  ;   Outputs: HLH'L' = number (binary integer)
040A75             1547*  ;            A = delimiter.
040A75             1548*  ;            B, C & IX updated
040A75             1549*  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
040A75             1550*  ;
040A75 DD 23       1551*  NUMBIX:			INC     IX
040A77 CD 29 0E 04 1552*  UINT:			CALL    DIGITQ
040A7B D8          1553*          		RET     C
040A7C 04          1554*          		INC     B               ;INCREMENT DIGIT COUNT
040A7D DD 23       1555*          		INC     IX
040A7F CD 72 0C 04 1556*          		CALL    X10             ;*10 & COPY OLD VALUE
040A83 38 15       1557*          		JR      C,NUMB1         ;OVERFLOW
040A85 0D          1558*          		DEC     C               ;SEE IF TRUNCATED
040A86 0C          1559*          		INC     C
040A87 20 11       1560*          		JR      NZ,NUMB1        ;IMPORTANT!
040A89 E6 0F       1561*          		AND     0FH
040A8B D9          1562*          		EXX
040A8C 06 00       1563*          		LD      B,0
040A8E 4F          1564*          		LD      C,A
040A8F 52 09       1565*          		ADD.S   HL,BC           ;ADD IN DIGIT
040A91 D9          1566*          		EXX
040A92 30 E3       1567*          		JR      NC,UINT
040A94 52 23       1568*          		INC.S   HL              ;CARRY
040A96 7C          1569*          		LD      A,H
040A97 B5          1570*          		OR      L
040A98 20 DD       1571*          		JR      NZ,UINT
040A9A 0C          1572*  NUMB1:			INC     C               ;TRUNCATION COUNTER
040A9B CD D0 0B 04 1573*          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
040A9F 18 D6       1574*          		JR      UINT
040AA1             1575*  ;
040AA1             1576*  ;FIX - Fix number to specified exponent value.
040AA1             1577*  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
040AA1             1578*  ;            A = desired exponent (A>C)
040AA1             1579*  ;   Outputs: HLH'L'C = fixed number (unsigned)
040AA1             1580*  ;            fraction shifted into B'C'
040AA1             1581*  ;            A'F' positive if integer input
040AA1             1582*  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
040AA1             1583*  ;
040AA1 08          1584*  FIX:			EX      AF,AF'
040AA2 AF          1585*          		XOR     A
040AA3 08          1586*          		EX      AF,AF'
040AA4 CB FC       1587*          		SET     7,H             ;IMPLIED 1
040AA6 CD D5 0B 04 1588*  FIX1:			CALL    DIV2
040AAA B9          1589*          		CP      C
040AAB C8          1590*          		RET     Z
040AAC D2 A6 0A 04 1591*          		JP      NC,FIX1
040AB0 C3 E4 0B 04 1592*          		JP      OFLOW
040AB4             1593*  ;
040AB4             1594*  ;SFIX - Convert to integer if necessary.
040AB4             1595*  ;    Input: Variable-type number in HLH'L'C
040AB4             1596*  ;   Output: Integer in HLH'L', C=0
040AB4             1597*  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
040AB4             1598*  ;
040AB4             1599*  ;NEGATE - Negate HLH'L'
040AB4             1600*  ;    Destroys: H,L,H',L',F
040AB4             1601*  ;
040AB4 CD CD 0B 04 1602*  FIX2:			CALL    SWAP_FP
040AB8 CD C0 0A 04 1603*          		CALL    SFIX_FP
040ABC CD CD 0B 04 1604*          		CALL    SWAP_FP
040AC0 0D          1605*  SFIX_FP:			DEC     C
040AC1 0C          1606*          		INC     C
040AC2 C8          1607*          		RET     Z               ;INTEGER/ZERO
040AC3 CB 7C       1608*          		BIT     7,H             ;SIGN
040AC5 F5          1609*          		PUSH    AF
040AC6 3E 9F       1610*          		LD      A,159
040AC8 CD A1 0A 04 1611*          		CALL    FIX
040ACC F1          1612*          		POP     AF
040ACD 0E 00       1613*          		LD      C,0
040ACF C8          1614*          		RET     Z
040AD0 B7          1615*  NEGATE:			OR      A               ;CLEAR CARRY
040AD1 D9          1616*          		EXX
040AD2 D5          1617*  NEG0:			PUSH    DE
040AD3 EB          1618*          		EX      DE,HL
040AD4 21 00 00 00 1619*          		LD      HL,0
040AD8 52 ED 52    1620*          		SBC.S   HL,DE
040ADB D1          1621*          		POP     DE
040ADC D9          1622*          		EXX
040ADD D5          1623*          		PUSH    DE
040ADE EB          1624*          		EX      DE,HL
040ADF 21 00 00 00 1625*          		LD      HL,0
040AE3 52 ED 52    1626*          		SBC.S   HL,DE
040AE6 D1          1627*          		POP     DE
040AE7 C9          1628*          		RET
040AE8             1629*  ;
040AE8             1630*  ;NEG - Negate HLH'L'B'C'
040AE8             1631*  ;    Also complements A (used in FADD)
040AE8             1632*  ;    Destroys: A,H,L,B',C',H',L',F
040AE8             1633*  ;
040AE8 D9          1634*  NEG_:			EXX
040AE9 2F          1635*          		CPL
040AEA E5          1636*          		PUSH    HL
040AEB B7          1637*          		OR      A               ;CLEAR CARRY
040AEC 21 00 00 00 1638*          		LD      HL,0
040AF0 52 ED 42    1639*          		SBC.S   HL,BC
040AF3 44          1640*          		LD      B,H
040AF4 4D          1641*          		LD      C,L
040AF5 E1          1642*          		POP     HL
040AF6 18 DA       1643*          		JR      NEG0
040AF8             1644*  ;
040AF8             1645*  ;SCALE - Trig scaling.
040AF8             1646*  ;MOD48 - 48-bit floating-point "modulus" (remainder).
040AF8             1647*  ;   Inputs: HLH'L'C unsigned floating-point dividend
040AF8             1648*  ;           DED'E'B'C'B unsigned 48-bit FP divisor
040AF8             1649*  ;  Outputs: HLH'L'C floating point remainder (H7=1)
040AF8             1650*  ;           E = quotient (bit 7 is sticky)
040AF8             1651*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
040AF8             1652*  ;FLO48 - Float unsigned number (48 bits)
040AF8             1653*  ;    Input/output in HLH'L'B'C'C
040AF8             1654*  ;   Destroys: C,H,L,B',C',H',L',F
040AF8             1655*  ;
040AF8 3E 96       1656*  SCALE:			LD      A,150
040AFA B9          1657*          		CP      C
040AFB 3E 17       1658*          		LD      A,ACLOST
040AFD DA 73 00 04 1659*          		JP      C,ERROR_FP_         ;"Accuracy lost"
040B01 CD 3E 06 04 1660*          		CALL    PIBY4
040B05 D9          1661*          		EXX
040B06 01 69 21 00 1662*          		LD      BC,2169H        ;3.141592653589793238
040B0A D9          1663*          		EXX
040B0B CB FA       1664*  MOD48:			SET     7,D             ;IMPLIED 1
040B0D CB FC       1665*          		SET     7,H
040B0F 79          1666*          		LD      A,C
040B10 0E 00       1667*          		LD      C,0             ;INIT QUOTIENT
040B12 DD 21 00 00 1668*          		LD      IX,0
       00          
040B17 DD E5       1669*          		PUSH    IX              ;PUT ZERO ON STACK
040B19 B8          1670*          		CP      B
040B1A 38 46       1671*          		JR      C,MOD485        ;DIVIDEND<DIVISOR
040B1C D9          1672*  MOD481:			EXX                     ;CARRY=0 HERE
040B1D E3          1673*          		EX      (SP),HL
040B1E 52 ED 42    1674*          		SBC.S   HL,BC
040B21 E3          1675*          		EX      (SP),HL
040B22 52 ED 52    1676*          		SBC.S   HL,DE
040B25 D9          1677*          		EXX
040B26 52 ED 52    1678*          		SBC.S   HL,DE
040B29 30 0C       1679*          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
040B2B D9          1680*          		EXX
040B2C E3          1681*          		EX      (SP),HL
040B2D 52 09       1682*          		ADD.S   HL,BC
040B2F E3          1683*          		EX      (SP),HL
040B30 52 ED 5A    1684*          		ADC.S   HL,DE
040B33 D9          1685*          		EXX
040B34 52 ED 5A    1686*          		ADC.S   HL,DE
040B37 3F          1687*  MOD482:			CCF
040B38 CB 11       1688*          		RL      C               ;QUOTIENT
040B3A 30 02       1689*          		JR      NC,MOD483
040B3C CB F9       1690*          		SET     7,C             ;STICKY BIT
040B3E 3D          1691*  MOD483:			DEC     A
040B3F B8          1692*          		CP      B
040B40 38 1F       1693*          		JR      C,MOD484        ;DIVIDEND<DIVISOR
040B42 E3          1694*          		EX      (SP),HL
040B43 52 29       1695*          		ADD.S   HL,HL           ;DIVIDEND * 2
040B45 E3          1696*          		EX      (SP),HL
040B46 D9          1697*          		EXX
040B47 52 ED 6A    1698*          		ADC.S   HL,HL
040B4A D9          1699*          		EXX
040B4B 52 ED 6A    1700*          		ADC.S   HL,HL
040B4E 30 CC       1701*          		JR      NC,MOD481       ;AGAIN
040B50 B7          1702*          		OR      A
040B51 D9          1703*          		EXX
040B52 E3          1704*          		EX      (SP),HL
040B53 52 ED 42    1705*          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
040B56 E3          1706*          		EX      (SP),HL
040B57 52 ED 52    1707*          		SBC.S   HL,DE
040B5A D9          1708*          		EXX
040B5B 52 ED 52    1709*          		SBC.S   HL,DE
040B5E B7          1710*          		OR      A
040B5F 18 D6       1711*          		JR      MOD482
040B61             1712*  ;
040B61 3C          1713*  MOD484:			INC     A
040B62 59          1714*  MOD485:			LD      E,C             ;QUOTIENT
040B63 4F          1715*          		LD      C,A             ;REMAINDER EXPONENT
040B64 D9          1716*          		EXX
040B65 C1          1717*          		POP     BC
040B66 D9          1718*          		EXX
040B67 CB 7C       1719*  FLO48:			BIT     7,H
040B69 C0          1720*          		RET     NZ
040B6A D9          1721*          		EXX
040B6B CB 21       1722*          		SLA     C
040B6D CB 10       1723*          		RL      B
040B6F 52 ED 6A    1724*          		ADC.S   HL,HL
040B72 D9          1725*          		EXX
040B73 52 ED 6A    1726*          		ADC.S   HL,HL
040B76 0D          1727*          		DEC     C
040B77 C2 67 0B 04 1728*          		JP      NZ,FLO48
040B7B C9          1729*          		RET
040B7C             1730*  ;
040B7C             1731*  ;Float unsigned number
040B7C             1732*  ;    Input/output in HLH'L'C
040B7C             1733*  ;   Destroys: C,H,L,H',L',F
040B7C             1734*  ;
040B7C CB 7C       1735*  FLOAT_:			BIT     7,H
040B7E C0          1736*          		RET     NZ
040B7F D9          1737*          		EXX                     ;SAME AS "X2"
040B80 52 29       1738*          		ADD.S   HL,HL           ;TIME-CRITICAL
040B82 D9          1739*          		EXX                     ;REGION
040B83 52 ED 6A    1740*          		ADC.S   HL,HL           ;(BENCHMARKS)
040B86 0D          1741*          		DEC     C
040B87 C2 7C 0B 04 1742*          		JP      NZ,FLOAT_
040B8B C9          1743*          		RET
040B8C             1744*  ;
040B8C             1745*  ;SFLOAT - Convert to floating-point if necessary.
040B8C             1746*  ;    Input: Variable-type number in HLH'L'C
040B8C             1747*  ;    Output: Floating-point in HLH'L'C
040B8C             1748*  ;    Destroys: A,C,H,L,H',L',F
040B8C             1749*  ;
040B8C 08          1750*  FLOATA:			EX      AF,AF'
040B8D             1751*          		; ADD     A,(RTABLE-DTABLE)/3
040B8D C6 2A       1752*          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
040B8F 08          1753*          		EX      AF,AF'
040B90 CD CD 0B 04 1754*  FLOAT2:			CALL    SWAP_FP
040B94 CD 9C 0B 04 1755*          		CALL    SFLOAT_FP
040B98 CD CD 0B 04 1756*          		CALL    SWAP_FP
040B9C 0D          1757*  SFLOAT_FP:			DEC     C
040B9D 0C          1758*          		INC     C
040B9E C0          1759*          		RET     NZ              ;ALREADY FLOATING-POINT
040B9F CD F5 0B 04 1760*          		CALL    TEST_FP
040BA3 C8          1761*          		RET     Z               ;ZERO
040BA4 7C          1762*          		LD      A,H
040BA5 B7          1763*          		OR      A
040BA6 FC D0 0A 04 1764*          		CALL    M,NEGATE
040BAA 0E 9F       1765*          		LD      C,159
040BAC CD 7C 0B 04 1766*          		CALL    FLOAT_
040BB0 B7          1767*          		OR      A
040BB1 F8          1768*          		RET     M               ;NEGATIVE
040BB2 CB BC       1769*          		RES     7,H
040BB4 C9          1770*          		RET
040BB5             1771*  ;
040BB5             1772*  ;ROUND UP
040BB5             1773*  ;Return with carry set if 32-bit overflow
040BB5             1774*  ;   Destroys: H,L,B',C',H',L',F
040BB5             1775*  ;
040BB5 D9          1776*  ADD1_FP:			EXX
040BB6 01 01 00 00 1777*          		LD      BC,1
040BBA 52 09       1778*          		ADD.S   HL,BC
040BBC D9          1779*          		EXX
040BBD D0          1780*          		RET     NC
040BBE C5          1781*          		PUSH    BC
040BBF 01 01 00 00 1782*          		LD      BC,1
040BC3 52 09       1783*          		ADD.S   HL,BC
040BC5 C1          1784*          		POP     BC
040BC6 C9          1785*          		RET
040BC7             1786*  ;
040BC7             1787*  ;ODD - Add one if even, leave alone if odd.
040BC7             1788*  ; (Used to perform unbiassed rounding, i.e.
040BC7             1789*  ;  number is rounded up half the time)
040BC7             1790*  ;    Destroys: L',F (carry cleared)
040BC7             1791*  ;
040BC7 B7          1792*  ODD:			OR      A               ;CLEAR CARRY
040BC8 D9          1793*          		EXX
040BC9 CB C5       1794*          		SET     0,L             ;MAKE ODD
040BCB D9          1795*          		EXX
040BCC C9          1796*          		RET
040BCD             1797*  ;
040BCD             1798*  ;SWAP_FP - Swap arguments.
040BCD             1799*  ;    Exchanges DE,HL D'E',H'L' and B,C
040BCD             1800*  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
040BCD             1801*  ;SWAP1 - Swap DEHL with D'E'H'L'
040BCD             1802*  ;    Destroys: D,E,H,L,D',E',H',L'
040BCD             1803*  ;
040BCD 79          1804*  SWAP_FP:			LD      A,C
040BCE 48          1805*          		LD      C,B
040BCF 47          1806*          		LD      B,A
040BD0 EB          1807*  SWAP1:			EX      DE,HL
040BD1 D9          1808*          		EXX
040BD2 EB          1809*          		EX      DE,HL
040BD3 D9          1810*          		EXX
040BD4 C9          1811*          		RET
040BD5             1812*  ;
040BD5             1813*  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
040BD5             1814*  ; INCC - destroys C,F
040BD5             1815*  ; OFLOW
040BD5             1816*  ;
040BD5 CD 8E 0C 04 1817*  DIV2:			CALL    D2
040BD9 D9          1818*          		EXX
040BDA CB 18       1819*          		RR      B
040BDC CB 19       1820*          		RR      C
040BDE 08          1821*          		EX      AF,AF'
040BDF B0          1822*          		OR      B
040BE0 08          1823*          		EX      AF,AF'
040BE1 D9          1824*          		EXX
040BE2 0C          1825*  INCC:			INC     C
040BE3 C0          1826*          		RET     NZ
040BE4 3E 14       1827*  OFLOW:			LD      A,TOOBIG_FP
040BE6 C3 73 00 04 1828*          		JP      ERROR_FP_           ;"Too big"
040BEA             1829*  ;
040BEA             1830*  ; FTEST - Test for zero & sign
040BEA             1831*  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
040BEA             1832*  ;
040BEA CD F5 0B 04 1833*  FTEST_FP:			CALL    TEST_FP
040BEE C8          1834*          		RET     Z
040BEF 7C          1835*          		LD      A,H
040BF0 E6 80       1836*          		AND     10000000B
040BF2 F6 40       1837*          		OR      01000000B
040BF4 C9          1838*          		RET
040BF5             1839*  ;
040BF5             1840*  ; TEST_FP - Test HLH'L' for zero.
040BF5             1841*  ;     Output: Z-flag set & A=0 if HLH'L'=0
040BF5             1842*  ;     Destroys: A,F
040BF5             1843*  ;
040BF5 7C          1844*  TEST_FP:			LD      A,H
040BF6 B5          1845*          		OR      L
040BF7 D9          1846*          		EXX
040BF8 B4          1847*          		OR      H
040BF9 B5          1848*          		OR      L
040BFA D9          1849*          		EXX
040BFB C9          1850*          		RET
040BFC             1851*  ;
040BFC             1852*  ; FCOMP - Compare two numbers
040BFC             1853*  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
040BFC             1854*  ;
040BFC 78          1855*  FCOMP_FP:			LD      A,B
040BFD B1          1856*          		OR      C               ;Both integer?
040BFE 20 0B       1857*          		JR      NZ,FCOMP1
040C00 CD 15 0C 04 1858*          		CALL    ICP
040C04 3E 00       1859*  FCOMP0:			LD      A,0
040C06 C8          1860*          		RET     Z               ;Equal
040C07 3E 80       1861*          		LD      A,80H
040C09 1F          1862*          		RRA
040C0A C9          1863*          		RET
040C0B             1864*  ;
040C0B CD 90 0B 04 1865*  FCOMP1:			CALL    FLOAT2          ;Float both
040C0F CD 23 0C 04 1866*          		CALL    FCP
040C13 18 EF       1867*          		JR      FCOMP0
040C15             1868*  ;
040C15             1869*  ; Integer and floating point compare.
040C15             1870*  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
040C15             1871*  ; Result pre-set to FALSE
040C15             1872*  ; ICP1, FCP1 destroy A,F
040C15             1873*  ;
040C15             1874*  ; ZERO - Return zero.
040C15             1875*  ;  Destroys: A,C,H,L,H',L'
040C15             1876*  ;
040C15 CD 48 0C 04 1877*  ICP:			CALL    ICP1
040C19 3E 00       1878*  ZERO_FP:			LD      A,0
040C1B D9          1879*          		EXX
040C1C 67          1880*          		LD      H,A
040C1D 6F          1881*  	       		LD      L,A
040C1E D9          1882*          		EXX
040C1F 67          1883*        			LD      H,A
040C20 6F          1884*       			LD      L,A
040C21 4F          1885*  	    		LD      C,A
040C22 C9          1886*          		RET
040C23             1887*  ;
040C23 CD 3A 0C 04 1888*  FCP:			CALL    FCP1
040C27 18 F0       1889*          		JR      ZERO_FP            ;PRESET FALSE
040C29             1890*  ;
040C29 79          1891*  FCP0:			LD      A,C
040C2A B8          1892*          		CP      B               ;COMPARE EXPONENTS
040C2B C0          1893*          		RET     NZ
040C2C             1894*  ICP0:
040C2C 52 ED 52    1895*  			SBC.S   HL,DE           ;COMP MANTISSA MSB
040C2F 52 19       1896*          		ADD.S   HL,DE
040C31 C0          1897*          		RET     NZ
040C32 D9          1898*          		EXX
040C33 52 ED 52    1899*          		SBC.S   HL,DE           ;COMP MANTISSA LSB
040C36 52 19       1900*          		ADD.S   HL,DE
040C38 D9          1901*          		EXX
040C39 C9          1902*          		RET
040C3A             1903*  ;
040C3A 7C          1904*  FCP1:			LD      A,H
040C3B AA          1905*          		XOR     D
040C3C 7C          1906*          		LD      A,H
040C3D 17          1907*          		RLA
040C3E F8          1908*          		RET     M
040C3F 30 E8       1909*          		JR      NC,FCP0
040C41 CD 29 0C 04 1910*          		CALL    FCP0
040C45 C8          1911*          		RET     Z               ;** V0.1 BUG FIX
040C46 3F          1912*          		CCF
040C47 C9          1913*          		RET
040C48             1914*  ;
040C48 7C          1915*  ICP1:			LD      A,H
040C49 AA          1916*          		XOR     D
040C4A F2 2C 0C 04 1917*          		JP      P,ICP0
040C4E 7C          1918*          		LD      A,H
040C4F 17          1919*          		RLA
040C50 C9          1920*          		RET
040C51             1921*  ;
040C51             1922*  ; ADD - Integer add.
040C51             1923*  ; Carry, sign & zero flags valid on exit
040C51             1924*  ;     Destroys: H,L,H',L',F
040C51             1925*  ;
040C51 05          1926*  X10B:			DEC     B
040C52 0C          1927*          		INC     C
040C53 CD 9A 0C 04 1928*  X5:			CALL    COPY0
040C57 CD 8D 0C 04 1929*          		CALL    D2C
040C5B CD 8D 0C 04 1930*          		CALL    D2C
040C5F 08          1931*          		EX      AF,AF'          ;SAVE CARRY
040C60 D9          1932*  ADD_:			EXX
040C61 52 19       1933*          		ADD.S   HL,DE
040C63 D9          1934*          		EXX
040C64 52 ED 5A    1935*          		ADC.S   HL,DE
040C67 C9          1936*          		RET
040C68             1937*  ;
040C68             1938*  ; SUB - Integer subtract.
040C68             1939*  ; Carry, sign & zero flags valid on exit
040C68             1940*  ;     Destroys: H,L,H',L',F
040C68             1941*  ;
040C68 D9          1942*  SUB_:			EXX
040C69 B7          1943*          		OR      A
040C6A 52 ED 52    1944*          		SBC.S   HL,DE
040C6D D9          1945*          		EXX
040C6E 52 ED 52    1946*          		SBC.S   HL,DE
040C71 C9          1947*          		RET
040C72             1948*  ;
040C72             1949*  ; X10 - unsigned integer * 10
040C72             1950*  ;    Inputs: HLH'L' initial value
040C72             1951*  ;   Outputs: DED'E' = initial HLH'L'
040C72             1952*  ;            Carry bit set if overflow
040C72             1953*  ;            If carry not set HLH'L'=result
040C72             1954*  ;  Destroys: D,E,H,L,D',E',H',L',F
040C72             1955*  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
040C72             1956*  ;     Carry set if MSB=1 before shift.
040C72             1957*  ;     Sign set if MSB=1 after shift.
040C72             1958*  ;     Destroys: H,L,H',L',F
040C72             1959*  ;
040C72 CD 9A 0C 04 1960*  X10:			CALL    COPY0           ;DED'E'=HLH'L'
040C76 CD 85 0C 04 1961*          		CALL    X2
040C7A D8          1962*          		RET     C               ;TOO BIG
040C7B CD 85 0C 04 1963*          		CALL    X2
040C7F D8          1964*          		RET     C
040C80 CD 60 0C 04 1965*          		CALL    ADD_
040C84 D8          1966*          		RET     C
040C85 D9          1967*  X2:			EXX
040C86 52 29       1968*          		ADD.S   HL,HL
040C88 D9          1969*          		EXX
040C89 52 ED 6A    1970*          		ADC.S   HL,HL
040C8C C9          1971*          		RET
040C8D             1972*  ;
040C8D             1973*  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
040C8D             1974*  ;     Carry set if LSB=1 before shift.
040C8D             1975*  ;     Destroys: H,L,H',L',F
040C8D             1976*  ;
040C8D 0C          1977*  D2C:			INC     C
040C8E CB 3C       1978*  D2:			SRL     H
040C90 CB 1D       1979*          		RR      L
040C92 D9          1980*          		EXX
040C93 CB 1C       1981*          		RR      H
040C95 CB 1D       1982*          		RR      L
040C97 D9          1983*          		EXX
040C98 C9          1984*          		RET
040C99             1985*  ;
040C99             1986*  ; COPY - COPY HLH'L'C INTO DED'E'B
040C99             1987*  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
040C99             1988*  ;
040C99 41          1989*  COPY_:			LD      B,C
040C9A 54          1990*  COPY0:			LD      D,H
040C9B 5D          1991*          		LD      E,L
040C9C D9          1992*          		EXX
040C9D 54          1993*          		LD      D,H
040C9E 5D          1994*          		LD      E,L
040C9F D9          1995*          		EXX
040CA0 C9          1996*          		RET
040CA1             1997*  ;
040CA1             1998*  ; SQUARE - PUSH X*X
040CA1             1999*  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
040CA1             2000*  ;   Destroys: SP,IX
040CA1             2001*  ;
040CA1 CD 99 0C 04 2002*  SQUARE:			CALL    COPY_
040CA5 CD 04 03 04 2003*          		CALL    FMUL
040CA9 DD E1       2004*  PUSH5:			POP     IX              ;RETURN ADDRESS
040CAB C5          2005*          		PUSH    BC
040CAC E5          2006*          		PUSH    HL
040CAD D9          2007*          		EXX
040CAE E5          2008*          		PUSH    HL
040CAF D9          2009*          		EXX
040CB0 DD E9       2010*          		JP      (IX)            ;"RETURN"
040CB2             2011*  ;
040CB2             2012*  ; POP5 - POP DED'E'B OFF STACK.
040CB2             2013*  ;   Destroys: A,B,D,E,D',E',SP,IX
040CB2             2014*  ;
040CB2 DD E1       2015*  POP5:			POP     IX              ;RETURN ADDRESS
040CB4 D9          2016*          		EXX
040CB5 D1          2017*          		POP     DE
040CB6 D9          2018*          		EXX
040CB7 D1          2019*          		POP     DE
040CB8 79          2020*          		LD      A,C
040CB9 C1          2021*          		POP     BC
040CBA 41          2022*          		LD      B,C
040CBB 4F          2023*          		LD      C,A
040CBC DD E9       2024*          		JP      (IX)            ;"RETURN"
040CBE             2025*  ;
040CBE             2026*  ; RATIO - Calculate (X-1)/(X+1)
040CBE             2027*  ;     Inputs: X in HLH'L'C
040CBE             2028*  ;    Outputs: (X-1)/(X+1) in HLH'L'C
040CBE             2029*  ;   Destroys: Everything except IY,SP,I
040CBE             2030*  ;
040CBE CD A9 0C 04 2031*  RATIO:			CALL    PUSH5           ;SAVE X
040CC2 CD 31 06 04 2032*          		CALL    DONE
040CC6 CD F2 01 04 2033*          		CALL    FADD
040CCA CD B2 0C 04 2034*          		CALL    POP5            ;RESTORE X
040CCE CD A9 0C 04 2035*          		CALL    PUSH5           ;SAVE X+1
040CD2 CD CD 0B 04 2036*          		CALL    SWAP_FP
040CD6 CD 31 06 04 2037*          		CALL    DONE
040CDA CD D9 01 04 2038*          		CALL    FSUB
040CDE CD B2 0C 04 2039*          		CALL    POP5            ;RESTORE X+1
040CE2 C3 5B 02 04 2040*          		JP      FDIV
040CE6             2041*  ;
040CE6             2042*  ; POLY - Evaluate a polynomial.
040CE6             2043*  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
040CE6             2044*  ;             Polynomial coefficients follow call.
040CE6             2045*  ;    Outputs: Result in HLH'L'C
040CE6             2046*  ;   Destroys: Everything except IY,SP,I
040CE6             2047*  ; Routine terminates on finding a coefficient >=1.
040CE6             2048*  ; Note: The last coefficient is EXECUTED on return
040CE6             2049*  ;       so must contain only innocuous bytes!
040CE6             2050*  ;
040CE6 DD 21 03 00 2051*  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
040CEB DD 39       2052*          		ADD     IX, SP
040CED DD E3       2053*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
040CEF             2054*  ;
040CEF CD C5 09 04 2055*          		CALL    DLOAD5          		; Load the first coefficient from (IX)
040CF3 CD 04 03 04 2056*  POLY1:			CALL    FMUL
040CF7 11 05 00 00 2057*          		LD      DE, 5				; Skip to the next coefficient
040CFB DD 19       2058*          		ADD     IX, DE
040CFD CD C5 09 04 2059*          		CALL    DLOAD5          		; Load the second coefficient from (IX)
040D01 DD E3       2060*          		EX      (SP), IX			; Restore the SP just in case we need to return
040D03 04          2061*          		INC     B
040D04 05          2062*          		DEC     B               		; Test B for end byte (80h)
040D05 FA F2 01 04 2063*          		JP      M,FADD				; Yes, so add and return
040D09 CD F2 01 04 2064*          		CALL    FADD				; No, so add
040D0D CD D7 09 04 2065*          		CALL    DLOAD5_SPL			; Load X from SP
040D11 DD E3       2066*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
040D13 18 DE       2067*          		JR      POLY1				; And loop
040D15             2068*  ;
040D15             2069*  ; POWR10 - Calculate power of ten.
040D15             2070*  ;     Inputs: A=power of 10 required (A<128)
040D15             2071*  ;             A=binary exponent to be exceeded (A>=128)
040D15             2072*  ;    Outputs: DED'E'B = result
040D15             2073*  ;             A = actual power of ten returned
040D15             2074*  ;   Destroys: A,B,D,E,A',D',E',F,F'
040D15             2075*  ;
040D15 3C          2076*  POWR10:			INC     A
040D16 08          2077*          		EX      AF,AF'
040D17 E5          2078*          		PUSH    HL
040D18 D9          2079*          		EXX
040D19 E5          2080*          		PUSH    HL
040D1A D9          2081*          		EXX
040D1B CD 31 06 04 2082*          		CALL    DONE
040D1F CD CD 0B 04 2083*          		CALL    SWAP_FP
040D23 AF          2084*          		XOR     A
040D24 08          2085*  POWR11:			EX      AF,AF'
040D25 3D          2086*          		DEC     A
040D26 28 26       2087*          		JR      Z,POWR14        ;EXIT TYPE 1
040D28 F2 30 0D 04 2088*          		JP      P,POWR13
040D2C B9          2089*          		CP      C
040D2D 38 1F       2090*          		JR      C,POWR14        ;EXIT TYPE 2
040D2F 3C          2091*          		INC     A
040D30 08          2092*  POWR13:			EX      AF,AF'
040D31 3C          2093*          		INC     A
040D32 CB FC       2094*          		SET     7,H
040D34 CD 53 0C 04 2095*          		CALL    X5
040D38 30 06       2096*          		JR      NC,POWR12
040D3A 08          2097*          		EX      AF,AF'
040D3B CD 8D 0C 04 2098*          		CALL    D2C
040D3F 08          2099*          		EX      AF,AF'
040D40 08          2100*  POWR12:			EX      AF,AF'
040D41 DC B5 0B 04 2101*          		CALL    C,ADD1_FP          ;ROUND UP
040D45 0C          2102*          		INC     C
040D46 FA 24 0D 04 2103*          		JP      M,POWR11
040D4A C3 E4 0B 04 2104*          		JP      OFLOW
040D4E CD CD 0B 04 2105*  POWR14:			CALL    SWAP_FP
040D52 CB BA       2106*          		RES     7,D
040D54 D9          2107*          		EXX
040D55 E1          2108*          		POP     HL
040D56 D9          2109*          		EXX
040D57 E1          2110*          		POP     HL
040D58 08          2111*          		EX      AF,AF'
040D59 C9          2112*          		RET
040D5A             2113*  ;
040D5A             2114*  ; DIVA, DIVB - DIVISION PRIMITIVE.
040D5A             2115*  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
040D5A             2116*  ;               Remainder in H'L'HL
040D5A             2117*  ;     Inputs: A = loop counter (normally -32)
040D5A             2118*  ;     Destroys: A,D,E,H,L,D',E',H',L',F
040D5A             2119*  ;
040D5A B7          2120*  DIVA:			OR      A               ;CLEAR CARRY
040D5B             2121*  DIV0:
040D5B 52 ED 42    2122*  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
040D5E D9          2123*          		EXX
040D5F 52 ED 42    2124*          		SBC.S   HL,BC
040D62 D9          2125*          		EXX
040D63 30 07       2126*          		JR      NC,DIV1
040D65 52 09       2127*          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
040D67 D9          2128*          		EXX
040D68 52 ED 4A    2129*          		ADC.S   HL,BC
040D6B D9          2130*          		EXX
040D6C 3F          2131*  DIV1:			CCF
040D6D CB 13       2132*  DIVC:			RL      E               ;SHIFT RESULT INTO DE
040D6F CB 12       2133*          		RL      D
040D71 D9          2134*          		EXX
040D72 CB 13       2135*          		RL      E
040D74 CB 12       2136*          		RL      D
040D76 D9          2137*          		EXX
040D77 3C          2138*          		INC     A
040D78 F0          2139*          		RET     P
040D79             2140*  DIVB:
040D79 52 ED 6A    2141*  			ADC.S   HL,HL           ;DIVIDEND*2
040D7C D9          2142*          		EXX
040D7D 52 ED 6A    2143*          		ADC.S   HL,HL
040D80 D9          2144*          		EXX
040D81 30 D8       2145*          		JR      NC,DIV0
040D83 B7          2146*          		OR      A
040D84 52 ED 42    2147*          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
040D87 D9          2148*          		EXX
040D88 52 ED 42    2149*          		SBC.S   HL,BC
040D8B D9          2150*          		EXX
040D8C 37          2151*          		SCF
040D8D C3 6D 0D 04 2152*          		JP      DIVC
040D91             2153*  ;
040D91             2154*  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
040D91             2155*  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
040D91             2156*  ;    Inputs: A = loop counter (usually -32)
040D91             2157*  ;            H'L'HL = 0
040D91             2158*  ;    Destroys: D,E,H,L,D',E',H',L',A,F
040D91             2159*  ;
040D91 B7          2160*  MULA:			OR      A               ;CLEAR CARRY
040D92 D9          2161*  MUL0:			EXX
040D93 CB 1A       2162*          		RR      D               ;MULTIPLIER/2
040D95 CB 1B       2163*          		RR      E
040D97 D9          2164*          		EXX
040D98 CB 1A       2165*          		RR      D
040D9A CB 1B       2166*          		RR      E
040D9C 30 07       2167*          		JR      NC,MUL1
040D9E 52 09       2168*          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
040DA0 D9          2169*          		EXX
040DA1 52 ED 4A    2170*          		ADC.S   HL,BC
040DA4 D9          2171*          		EXX
040DA5 3C          2172*  MUL1:			INC     A
040DA6 F0          2173*          		RET     P
040DA7 D9          2174*  MULB:			EXX
040DA8 CB 1C       2175*          		RR      H               ;PRODUCT/2
040DAA CB 1D       2176*          		RR      L
040DAC D9          2177*          		EXX
040DAD CB 1C       2178*          		RR      H
040DAF CB 1D       2179*          		RR      L
040DB1 C3 92 0D 04 2180*          		JP      MUL0
040DB5             2181*  ;
040DB5             2182*  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
040DB5             2183*  ;     Function: B'C'BC = SQR (D'E'DE)
040DB5             2184*  ;     Inputs: A = loop counter (normally -31)
040DB5             2185*  ;             B'C'BCH'L'HL initialised to 0
040DB5             2186*  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
040DB5             2187*  ;
040DB5             2188*  SQR1:
040DB5 52 ED 42    2189*  			SBC.S   HL,BC
040DB8 D9          2190*          		EXX
040DB9 52 ED 42    2191*          		SBC.S   HL,BC
040DBC D9          2192*          		EXX
040DBD 0C          2193*          		INC     C
040DBE 30 09       2194*          		JR      NC,SQR2
040DC0 0D          2195*          		DEC     C
040DC1 52 09       2196*          		ADD.S   HL,BC
040DC3 D9          2197*          		EXX
040DC4 52 ED 4A    2198*          		ADC.S   HL,BC
040DC7 D9          2199*          		EXX
040DC8 0D          2200*          		DEC     C
040DC9 3C          2201*  SQR2:			INC     A
040DCA F0          2202*          		RET     P
040DCB CB 21       2203*  SQRA:			SLA     C
040DCD CB 10       2204*          		RL      B
040DCF D9          2205*          		EXX
040DD0 CB 11       2206*          		RL      C
040DD2 CB 10       2207*          		RL      B
040DD4 D9          2208*          		EXX
040DD5 0C          2209*          		INC     C
040DD6 CB 23       2210*          		SLA     E
040DD8 CB 12       2211*          		RL      D
040DDA D9          2212*          		EXX
040DDB CB 13       2213*          		RL      E
040DDD CB 12       2214*          		RL      D
040DDF D9          2215*          		EXX
040DE0 52 ED 6A    2216*          		ADC.S   HL,HL
040DE3 D9          2217*          		EXX
040DE4 52 ED 6A    2218*          		ADC.S   HL,HL
040DE7 D9          2219*          		EXX
040DE8 CB 23       2220*          		SLA     E
040DEA CB 12       2221*          		RL      D
040DEC D9          2222*          		EXX
040DED CB 13       2223*          		RL      E
040DEF CB 12       2224*          		RL      D
040DF1 D9          2225*          		EXX
040DF2 52 ED 6A    2226*          		ADC.S   HL,HL
040DF5 D9          2227*          		EXX
040DF6 52 ED 6A    2228*          		ADC.S   HL,HL
040DF9 D9          2229*          		EXX
040DFA D2 B5 0D 04 2230*          		JP      NC,SQR1
040DFE B7          2231*  SQR3:			OR      A
040DFF 52 ED 42    2232*          		SBC.S   HL,BC
040E02 D9          2233*          		EXX
040E03 52 ED 42    2234*          		SBC.S   HL,BC
040E06 D9          2235*          		EXX
040E07 0C          2236*          		INC     C
040E08 C3 C9 0D 04 2237*          		JP      SQR2
040E0C             2238*  ;
040E0C             2239*  SQRB:
040E0C 52 29       2240*  			ADD.S   HL,HL
040E0E D9          2241*          		EXX
040E0F 52 ED 6A    2242*          		ADC.S   HL,HL
040E12 D9          2243*          		EXX
040E13 38 E9       2244*          		JR      C,SQR3
040E15 3C          2245*          		INC     A
040E16 0C          2246*          		INC     C
040E17 52 ED 42    2247*          		SBC.S   HL,BC
040E1A D9          2248*          		EXX
040E1B 52 ED 42    2249*          		SBC.S   HL,BC
040E1E D9          2250*          		EXX
040E1F D0          2251*          		RET     NC
040E20 52 09       2252*          		ADD.S   HL,BC
040E22 D9          2253*          		EXX
040E23 52 ED 4A    2254*          		ADC.S   HL,BC
040E26 D9          2255*          		EXX
040E27 0D          2256*          		DEC     C
040E28 C9          2257*          		RET
040E29             2258*  ;
040E29 DD 7E 00    2259*  DIGITQ:			LD      A,(IX)
040E2C FE 3A       2260*          		CP      '9'+1
040E2E 3F          2261*          		CCF
040E2F D8          2262*          		RET     C
040E30 FE 30       2263*          		CP      '0'
040E32 C9          2264*          		RET
040E33             2265*  ;
040E33 DD 7E 00    2266*  SIGNQ:			LD      A,(IX)
040E36 DD 23       2267*          		INC     IX
040E38 FE 20       2268*          		CP      ' '
040E3A 28 F7       2269*          		JR      Z,SIGNQ
040E3C FE 2B       2270*          		CP      '+'
040E3E C8          2271*          		RET     Z
040E3F FE 2D       2272*          		CP      '-'
040E41 C8          2273*          		RET     Z
040E42 DD 2B       2274*          		DEC     IX
040E44 C9          2275*          		RET
040E45             0044       include "functions.inc"
040E45             0001*  
040E45             0002*      MACRO printChar char
040E45             0003*          LD A, char
040E45             0004*          RST.LIL 10h
040E45             0005*      ENDMACRO
040E45             0006*  
040E45             0007*  ; test the sign of HL
040E45             0008*  ; inputs: HL obviously
040E45             0009*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040E45             0010*  ; destroys: flags
040E45             0011*      MACRO sign_hlu
040E45             0012*          add hl,de
040E45             0013*          or a
040E45             0014*          sbc hl,de
040E45             0015*      ENDMACRO
040E45             0016*  
040E45             0017*  ; Simulated call to subroutine at HL
040E45             0018*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040E45             0019*  ; outputs: whatever the subroutine does, including HL and BC
040E45             0020*  ; destroys: only what the subroutine does, but always BC
040E45             0021*      MACRO callHL
040E45             0022*          ld bc,$+7     ; Address of first instruction after the jump
040E45             0023*          push bc       ; which constitutes the return address
040E45             0024*          jp   (hl)     ; Jump to the address in HL
040E45             0025*      ENDMACRO
040E45             0026*  
040E45             0027*  ; Simulated call to subroutine at IX
040E45             0028*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040E45             0029*  ; outputs: whatever the subroutine does, including IX and BC
040E45             0030*  ; destroys: only what the subroutine does, but always BC
040E45             0031*      MACRO callIX
040E45             0032*          ld bc,$+7     ; Address of first instruction after the jump
040E45             0033*          push bc       ; which constitutes the return address
040E45             0034*          jp   (ix)     ; Jump to the address in IX
040E45             0035*      ENDMACRO
040E45             0036*  
040E45             0037*  ; Simulated call to soubroutinte at IY
040E45             0038*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040E45             0039*  ; outputs: whatever the subroutine does, including IY and BC
040E45             0040*  ; destroys: only what the subroutine does, but always BC
040E45             0041*      MACRO callIY
040E45             0042*          ld bc,$+7     ; Address of first instruction after the jump
040E45             0043*          push bc       ; which constitutes the return address
040E45             0044*          jp   (iy)     ; Jump to the address in IY
040E45             0045*      ENDMACRO
040E45             0046*  
040E45             0047*  ; put the value in HLU into the accumulator
040E45             0048*  ; destroys: af
040E45             0049*      MACRO HLU_TO_A
040E45             0050*          push hl ; 4 cycles
040E45             0051*          inc sp ; 1 cycle
040E45             0052*          pop af  ; 4 cycles
040E45             0053*          dec sp ; 1 cycle
040E45             0054*                 ; 10 cycles total
040E45             0055*      ENDMACRO
040E45             0056*  
040E45             0057*  A_TO_HLU:
040E45             0058*      ; call is 7 cycles
040E45 22 52 0E 04 0059*      ld (@scratch),hl ; 7 cycles
040E49 32 54 0E 04 0060*      ld (@scratch+2),a ; 5 cycles
040E4D 2A 52 0E 04 0061*      ld hl,(@scratch) ; 7 cycles
040E51 C9          0062*      ret ; 6 cycles
040E52             0063*          ; 25 cycles total
040E52 00 00 00    0064*  @scratch: dl 0
040E55             0065*  
040E55             0066*      ; TODO: implement this
040E55             0067*      ; MACRO A_TO_HLU
040E55             0068*      ;     push.s af
040E55             0069*      ;     inc sp
040E55             0070*      ;     push.s hl
040E55             0071*      ;     pop hl
040E55             0072*      ;     inc sp
040E55             0073*      ;     inc sp
040E55             0074*      ; ENDMACRO
040E55             0075*  
040E55             0076*      MACRO PUSH_ALL
040E55             0077*          ex af,af'
040E55             0078*          exx
040E55             0079*          push af
040E55             0080*          push hl
040E55             0081*          push bc
040E55             0082*          push de
040E55             0083*  
040E55             0084*          ex af,af'
040E55             0085*          exx
040E55             0086*          push af
040E55             0087*          push hl
040E55             0088*          push bc
040E55             0089*          push de
040E55             0090*          push ix
040E55             0091*          push iy
040E55             0092*      ENDMACRO
040E55             0093*  
040E55             0094*      MACRO POP_ALL
040E55             0095*          pop iy
040E55             0096*          pop ix
040E55             0097*          pop de
040E55             0098*          pop bc
040E55             0099*          pop hl
040E55             0100*          pop af
040E55             0101*          ex af,af'
040E55             0102*          exx
040E55             0103*  
040E55             0104*          pop de
040E55             0105*          pop bc
040E55             0106*          pop hl
040E55             0107*          pop af
040E55             0108*          ex af,af'
040E55             0109*          exx
040E55             0110*      ENDMACRO
040E55             0111*  
040E55             0112*  ; Print a zero-terminated string inline with code, e.g.:
040E55             0113*  ;
040E55             0114*  ;    call printInline
040E55             0115*  ;    ASCIZ "Hello, world!\r\n"
040E55             0116*  ;
040E55             0117*  ; Destroys: HL,AF
040E55             0118*  printInline:
040E55 E1          0119*      pop hl ; get the return address = pointer to start of string
040E56 CD 5C 0E 04 0120*      call printString ; HL advances to end of string
040E5A E5          0121*      push hl ; restore the return address = pointer to end of string
040E5B C9          0122*      ret
040E5C             0123*  
040E5C             0124*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040E5C             0125*  ; Print a zero-terminated string
040E5C             0126*  ; HL: Pointer to string
040E5C             0127*  printString:
040E5C C5          0128*  	PUSH	BC
040E5D 01 00 00 00 0129*  	LD		BC,0
040E61 3E 00       0130*  	LD 	 	A,0
040E63 5B DF       0131*  	RST.LIL 18h
040E65 C1          0132*  	POP		BC
040E66 C9          0133*  	RET
040E67             0134*  ; print a VDU sequence
040E67             0135*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040E67             0136*  sendVDUsequence:
040E67 C5          0137*  	PUSH	BC
040E68 01 00 00 00 0138*  	LD		BC, 0
040E6C 4E          0139*  	LD		C, (HL)
040E6D 5B DF       0140*  	RST.LIL	18h
040E6F C1          0141*  	POP		BC
040E70 C9          0142*  	RET
040E71             0143*  ; Print Newline sequence to VDP
040E71             0144*  printNewLine:
040E71 F5          0145*      push af ; for some reason rst.lil 10h sets carry flag
040E72 3E 0D       0146*  	LD	A, '\r'
040E74 5B D7       0147*  	RST.LIL 10h
040E76 3E 0A       0148*  	LD	A, '\n'
040E78 5B D7       0149*  	RST.LIL 10h
040E7A F1          0150*      pop af
040E7B C9          0151*  	RET
040E7C             0152*  
040E7C             0153*  ; Print a 24-bit HEX number
040E7C             0154*  ; HLU: Number to print
040E7C             0155*  printHex24:
040E7C             0156*      HLU_TO_A
040E7C E5          0001*M         push hl ; 4 cycles
040E7D 33          0002*M         inc sp ; 1 cycle
040E7E F1          0003*M         pop af  ; 4 cycles
040E7F 3B          0004*M         dec sp ; 1 cycle
040E80             0005*M                ; 10 cycles total
040E80 CD 8A 0E 04 0157*  	CALL	printHex8
040E84             0158*  ; Print a 16-bit HEX number
040E84             0159*  ; HL: Number to print
040E84             0160*  printHex16:
040E84 7C          0161*  	LD		A,H
040E85 CD 8A 0E 04 0162*  	CALL	printHex8
040E89 7D          0163*  	LD		A,L
040E8A             0164*  ; Print an 8-bit HEX number
040E8A             0165*  ; A: Number to print
040E8A             0166*  printHex8:
040E8A 4F          0167*  	LD		C,A
040E8B 1F          0168*  	RRA
040E8C 1F          0169*  	RRA
040E8D 1F          0170*  	RRA
040E8E 1F          0171*  	RRA
040E8F CD 94 0E 04 0172*  	CALL	@F
040E93 79          0173*  	LD		A,C
040E94             0174*  @@:
040E94 E6 0F       0175*  	AND		0Fh
040E96 C6 90       0176*  	ADD		A,90h
040E98 27          0177*  	DAA
040E99 CE 40       0178*  	ADC		A,40h
040E9B 27          0179*  	DAA
040E9C 5B D7       0180*  	RST.LIL	10h
040E9E C9          0181*  	RET
040E9F             0182*  
040E9F             0183*  printHexA:
040E9F F5          0184*      push af
040EA0 C5          0185*      push bc
040EA1 CD 8A 0E 04 0186*      call printHex8
040EA5 3E 20       0187*      ld a,' '
040EA7 5B D7       0188*      rst.lil 10h
040EA9 C1          0189*      pop bc
040EAA F1          0190*      pop af
040EAB C9          0191*      ret
040EAC             0192*  
040EAC             0193*  printHexHL:
040EAC F5          0194*      push af
040EAD C5          0195*      push bc
040EAE CD 84 0E 04 0196*      call printHex16
040EB2 3E 20       0197*      ld a,' '
040EB4 5B D7       0198*      rst.lil 10h
040EB6 C1          0199*      pop bc
040EB7 F1          0200*      pop af
040EB8 C9          0201*      ret
040EB9             0202*  
040EB9             0203*  printHexUHL:
040EB9 F5          0204*      push af
040EBA C5          0205*      push bc
040EBB CD 7C 0E 04 0206*      call printHex24
040EBF 3E 20       0207*      ld a,' '
040EC1 5B D7       0208*      rst.lil 10h
040EC3 C1          0209*      pop bc
040EC4 F1          0210*      pop af
040EC5 C9          0211*      ret
040EC6             0212*  
040EC6             0213*  printHexAUHL:
040EC6 F5          0214*      push af
040EC7 C5          0215*      push bc
040EC8 CD 8A 0E 04 0216*      call printHex8
040ECC 3E 2E       0217*      ld a,'.'
040ECE 5B D7       0218*      rst.lil 10h
040ED0 CD 7C 0E 04 0219*      call printHex24
040ED4 3E 20       0220*      ld a,' '
040ED6 5B D7       0221*      rst.lil 10h
040ED8 C1          0222*      pop bc
040ED9 F1          0223*      pop af
040EDA C9          0224*      ret
040EDB             0225*  
040EDB             0226*  printHexABHL:
040EDB             0227*  ; preserve registers
040EDB C5          0228*      push bc ; b will be ok c will not
040EDC F5          0229*      push af ; will get totally destroyed
040EDD             0230*  ; print a
040EDD CD 8A 0E 04 0231*      call printHex8
040EE1             0232*  ; print b
040EE1 78          0233*      ld a,b
040EE2 CD 8A 0E 04 0234*      call printHex8
040EE6             0235*  ; print hl
040EE6 CD 84 0E 04 0236*      call printHex16
040EEA             0237*  ; restore registers
040EEA F1          0238*      pop af
040EEB C1          0239*      pop bc
040EEC C9          0240*      ret
040EED             0241*  
040EED             0242*  printHexBHL:
040EED             0243*  ; preserve registers
040EED C5          0244*      push bc ; b will be ok c will not
040EEE F5          0245*      push af ; will get totally destroyed
040EEF             0246*  ; print b
040EEF 78          0247*      ld a,b
040EF0 CD 8A 0E 04 0248*      call printHex8
040EF4             0249*  ; print hl
040EF4 CD 84 0E 04 0250*      call printHex16
040EF8             0251*  ; restore registers
040EF8 F1          0252*      pop af
040EF9 C1          0253*      pop bc
040EFA C9          0254*      ret
040EFB             0255*  
040EFB             0256*  printHexCDE:
040EFB             0257*  ; preserve registers
040EFB C5          0258*      push bc ; b will be ok c will not
040EFC F5          0259*      push af ; will get totally destroyed
040EFD             0260*  ; print c
040EFD 79          0261*      ld a,c
040EFE CD 8A 0E 04 0262*      call printHex8
040F02             0263*  ; print de
040F02 EB          0264*      ex de,hl
040F03 CD 84 0E 04 0265*      call printHex16
040F07 EB          0266*      ex de,hl
040F08             0267*  ; restore registers
040F08 F1          0268*      pop af
040F09 C1          0269*      pop bc
040F0A C9          0270*      ret
040F0B             0271*  
040F0B             0272*  printHexUIX:
040F0B             0273*  ; store everything in scratch
040F0B 22 84 13 04 0274*      ld (uhl),hl
040F0F ED 43 87 13 0275*      ld (ubc),bc
       04          
040F14 ED 53 8A 13 0276*      ld (ude),de
       04          
040F19 DD 22 8D 13 0277*      ld (uix),ix
       04          
040F1E FD 22 90 13 0278*      ld (uiy),iy
       04          
040F23 F5          0279*      push af ; fml
040F24             0280*  
040F24 21 1B 13 04 0281*      ld hl,str_ixu
040F28 CD 5C 0E 04 0282*      call printString
040F2C 2A 8D 13 04 0283*      ld hl,(uix)
040F30 CD 7C 0E 04 0284*      call printHex24
040F34 CD 71 0E 04 0285*      call printNewLine
040F38             0286*  
040F38             0287*  ; restore everything
040F38 2A 84 13 04 0288*      ld hl, (uhl)
040F3C ED 4B 87 13 0289*      ld bc, (ubc)
       04          
040F41 ED 5B 8A 13 0290*      ld de, (ude)
       04          
040F46 DD 2A 8D 13 0291*      ld ix, (uix)
       04          
040F4B FD 2A 90 13 0292*      ld iy, (uiy)
       04          
040F50 F1          0293*      pop af
040F51             0294*  ; all done
040F51 C9          0295*      ret
040F52             0296*  
040F52             0297*  ; Print a 0x HEX prefix
040F52             0298*  DisplayHexPrefix:
040F52 3E 30       0299*  	LD	A, '0'
040F54 5B D7       0300*  	RST.LIL 10h
040F56 3E 78       0301*  	LD	A, 'x'
040F58 5B D7       0302*  	RST.LIL 10h
040F5A C9          0303*  	RET
040F5B             0304*  
040F5B             0305*      MACRO printDecBC
040F5B             0306*          push hl
040F5B             0307*          push bc
040F5B             0308*          pop hl
040F5B             0309*          call printDec
040F5B             0310*          pop hl
040F5B             0311*      ENDMACRO
040F5B             0312*  
040F5B             0313*      MACRO printDecDE
040F5B             0314*          push hl
040F5B             0315*          push de
040F5B             0316*          pop hl
040F5B             0317*          call printDec
040F5B             0318*          pop hl
040F5B             0319*      ENDMACRO
040F5B             0320*  
040F5B             0321*      MACRO printDecHL
040F5B             0322*          call printDec
040F5B             0323*      ENDMACRO
040F5B             0324*  
040F5B             0325*      MACRO printDecIX
040F5B             0326*          push hl
040F5B             0327*          push ix
040F5B             0328*          pop hl
040F5B             0329*          call printDec
040F5B             0330*          pop hl
040F5B             0331*      ENDMACRO
040F5B             0332*  
040F5B             0333*      MACRO printDecIY
040F5B             0334*          push hl
040F5B             0335*          push iy
040F5B             0336*          pop hl
040F5B             0337*          call printDec
040F5B             0338*          pop hl
040F5B             0339*      ENDMACRO
040F5B             0340*  
040F5B             0341*  
040F5B             0342*  ; Prints the right justified decimal value in HL without leading zeroes
040F5B             0343*  ; HL : Value to print
040F5B             0344*  ; preserves all registers and flags
040F5B             0345*  printDec:
040F5B             0346*  ; BEGIN MY CODE
040F5B             0347*  ; back up all the things
040F5B F5          0348*      push af
040F5C C5          0349*      push bc
040F5D D5          0350*      push de
040F5E E5          0351*      push hl
040F5F             0352*  ; END MY CODE
040F5F 11 87 0F 04 0353*  	LD	 DE, _printDecBuffer
040F63 CD 97 0F 04 0354*  	CALL u24_to_ascii
040F67             0355*  ; BEGIN MY CODE
040F67             0356*  ; replace leading zeroes with spaces
040F67 21 87 0F 04 0357*      LD	 HL, _printDecBuffer
040F6B 06 07       0358*      ld   B, 7 ; if HL was 0, we want to keep the final zero
040F6D             0359*  @loop:
040F6D 7E          0360*      LD	 A, (HL)
040F6E FE 30       0361*      CP	 '0'
040F70 C2 7A 0F 04 0362*      JP	 NZ, @done
040F74 3E 20       0363*      LD   A, ' '
040F76 77          0364*      LD	 (HL), A
040F77 23          0365*      INC	 HL
040F78             0366*      ; CALL vdu_cursor_forward
040F78 10 F3       0367*      DJNZ @loop
040F7A             0368*  @done:
040F7A             0369*  ; END MY CODE
040F7A 21 87 0F 04 0370*  	LD	 HL, _printDecBuffer
040F7E CD 5C 0E 04 0371*  	CALL printString
040F82             0372*  ; BEGIN MY CODE
040F82             0373*  ; restore all the things
040F82 E1          0374*      pop hl
040F83 D1          0375*      pop de
040F84 C1          0376*      pop bc
040F85 F1          0377*      pop af
040F86             0378*  ; END MY CODE
040F86 C9          0379*  	RET
040F87 00 00 00 00 0380*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
040F97             0381*  
040F97             0382*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
040F97             0383*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
040F97             0384*  ; so it will allways be 8 characters length
040F97             0385*  ; HL : Value to convert to string
040F97             0386*  ; DE : pointer to buffer, at least 8 byte + 0
040F97             0387*  u24_to_ascii:
040F97 01 80 69 67 0388*  	LD	 BC,-10000000
040F9B CD CE 0F 04 0389*  	CALL @one_digit
040F9F 01 C0 BD F0 0390*  	LD	 BC,-1000000
040FA3 CD CE 0F 04 0391*  	CALL @one_digit
040FA7 01 60 79 FE 0392*  	LD	 BC,-100000
040FAB CD CE 0F 04 0393*  	CALL @one_digit
040FAF 01 F0 D8 FF 0394*  	LD   BC,-10000
040FB3 CD CE 0F 04 0395*  	CALL @one_digit
040FB7 01 18 FC FF 0396*  	LD   BC,-1000
040FBB CD CE 0F 04 0397*  	CALL @one_digit
040FBF 01 9C FF FF 0398*  	LD   BC,-100
040FC3 CD CE 0F 04 0399*  	CALL @one_digit
040FC7 0E F6       0400*  	LD   C,-10
040FC9 CD CE 0F 04 0401*  	CALL @one_digit
040FCD 48          0402*  	LD   C,B
040FCE             0403*  @one_digit:
040FCE 3E 2F       0404*  	LD   A,'0'-1
040FD0             0405*  @divide_me:
040FD0 3C          0406*  	INC  A
040FD1 09          0407*  	ADD  HL,BC
040FD2 38 FC       0408*  	JR   C,@divide_me
040FD4 ED 42       0409*  	SBC  HL,BC
040FD6 12          0410*  	LD   (DE),A
040FD7 13          0411*  	INC  DE
040FD8 C9          0412*  	RET
040FD9             0413*  
040FD9             0414*  print_u24:
040FD9 D5          0415*      push de
040FDA E5          0416*      push hl
040FDB 11 87 0F 04 0417*      ld de,_printDecBuffer
040FDF CD 97 0F 04 0418*      call u24_to_ascii
040FE3 21 87 0F 04 0419*      ld hl,_printDecBuffer
040FE7 CD 5C 0E 04 0420*      call printString
040FEB 3E 20       0421*      ld a,' '
040FED 5B D7       0422*      rst.lil 10h
040FEF E1          0423*      pop hl
040FF0 D1          0424*      pop de
040FF1 C9          0425*      ret
040FF2             0426*  
040FF2             0427*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
040FF2             0428*  ; HL : Value to convert to string (integer part in H, fractional part in L)
040FF2             0429*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
040FF2             0430*  u168_to_ascii:
040FF2             0431*  ; add a leading space to make room for sign flag if needed
040FF2 3E 20       0432*      ld a,' '
040FF4 12          0433*      ld (de),a
040FF5 13          0434*      inc de
040FF6             0435*  ; Convert integer part
040FF6 E5          0436*      push hl               ; Save HL (we’ll need the fractional part later)
040FF7 CD EA 14 04 0437*      call hlu_udiv256    ; Shift to get integer portion in HL
040FFB 01 F0 D8 FF 0438*      ld   bc, -10000
040FFF CD 22 10 04 0439*      call @one_int
041003 01 18 FC FF 0440*      ld   bc, -1000
041007 CD 22 10 04 0441*      call @one_int
04100B 01 9C FF FF 0442*      ld   bc, -100
04100F CD 22 10 04 0443*      call @one_int
041013 0E F6       0444*      ld   c, -10
041015 CD 22 10 04 0445*      call @one_int
041019 48          0446*      ld   c, b
04101A CD 22 10 04 0447*      call @one_int
04101E C3 2D 10 04 0448*      jp   @frac            ; Jump to fractional part conversion
041022             0449*  @one_int:
041022 3E 2F       0450*      ld   a, '0' - 1       ; Start ASCII character at '0'
041024             0451*  @divide_me:
041024 3C          0452*      inc  a
041025 09          0453*      add  hl, bc           ; Accumulate until overflow
041026 38 FC       0454*      jr   c, @divide_me
041028 ED 42       0455*      sbc  hl, bc           ; Remove excess after overflow
04102A 12          0456*      ld   (de), a          ; Store ASCII digit
04102B 13          0457*      inc  de
04102C C9          0458*      ret
04102D             0459*  ; Convert fractional part
04102D             0460*  @frac:
04102D 3E 2E       0461*      ld   a, '.'           ; Decimal point
04102F 12          0462*      ld   (de), a
041030 13          0463*      inc  de
041031 E1          0464*      pop  hl               ; Restore HL with original fraction
041032 06 03       0465*      ld   b, 3             ; Loop counter for 3 fractional digits
041034             0466*  @frac_loop:
041034 26 0A       0467*      ld   h, 10            ; Load multiplier for fractional part
041036 ED 6C       0468*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
041038 3E 30       0469*      ld   a, '0'
04103A 84          0470*      add  a, h             ; Convert integer part to ASCII
04103B 12          0471*      ld   (de), a
04103C 13          0472*      inc  de
04103D 10 F5       0473*      djnz @frac_loop       ; Repeat for each fractional digit
04103F             0474*  ; Add null terminator
04103F AF          0475*      xor  a                ; Null terminator
041040 12          0476*      ld   (de), a
041041 C9          0477*      ret
041042             0478*  
041042             0479*  print_u168:
041042 D5          0480*      push de
041043 E5          0481*      push hl
041044 11 87 0F 04 0482*      ld de,_printDecBuffer
041048 CD F2 0F 04 0483*      call u168_to_ascii
04104C 21 87 0F 04 0484*      ld hl,_printDecBuffer
041050 CD 5C 0E 04 0485*      call printString
041054 E1          0486*      pop hl
041055 D1          0487*      pop de
041056 C9          0488*      ret
041057             0489*  
041057             0490*  ; signed version of u168_to_ascii
041057             0491*  s168_to_ascii:
041057 D5          0492*      push de ; save starting address of buffer
041058 CD 83 14 04 0493*      call hlu_abs
04105C F5          0494*      push af ; save sign flag
04105D CD F2 0F 04 0495*      call u168_to_ascii
041061 F1          0496*      pop af ; restore sign flag
041062 D1          0497*      pop de ; restore starting address of buffer
041063 F0          0498*      ret p ; hlu was positive so nothing to do
041064 3E 2D       0499*      ld a,'-'
041066 12          0500*      ld (de),a
041067 C9          0501*      ret
041068             0502*  
041068             0503*  print_s168:
041068 D5          0504*      push de
041069 E5          0505*      push hl
04106A 11 87 0F 04 0506*      ld de,_printDecBuffer
04106E CD 57 10 04 0507*      call s168_to_ascii
041072 21 87 0F 04 0508*      ld hl,_printDecBuffer
041076 CD 5C 0E 04 0509*      call printString
04107A E1          0510*      pop hl
04107B D1          0511*      pop de
04107C C9          0512*      ret
04107D             0513*  
04107D             0514*  print_s168_hl:
04107D F5          0515*      push af
04107E E5          0516*      push hl
04107F CD 68 10 04 0517*      call print_s168
041083 3E 20       0518*      ld a,' '
041085 5B D7       0519*      rst.lil 10h
041087 E1          0520*      pop hl
041088 F1          0521*      pop af
041089 C9          0522*      ret
04108A             0523*  
04108A             0524*  print_s168_bc:
04108A F5          0525*      push af
04108B C5          0526*      push bc
04108C E5          0527*      push hl
04108D C5          0528*      push bc
04108E E1          0529*      pop hl
04108F CD 68 10 04 0530*      call print_s168
041093 3E 20       0531*      ld a,' '
041095 5B D7       0532*      rst.lil 10h
041097 E1          0533*      pop hl
041098 C1          0534*      pop bc
041099 F1          0535*      pop af
04109A C9          0536*      ret
04109B             0537*  
04109B             0538*  print_s168_de:
04109B F5          0539*      push af
04109C D5          0540*      push de
04109D E5          0541*      push hl
04109E EB          0542*      ex de,hl
04109F CD 68 10 04 0543*      call print_s168
0410A3 3E 20       0544*      ld a,' '
0410A5 5B D7       0545*      rst.lil 10h
0410A7 E1          0546*      pop hl
0410A8 D1          0547*      pop de
0410A9 F1          0548*      pop af
0410AA C9          0549*      ret
0410AB             0550*  
0410AB             0551*  print_s168_hl_bc_de:
0410AB F5          0552*      push af
0410AC C5          0553*      push bc
0410AD D5          0554*      push de
0410AE E5          0555*      push hl
0410AF CD 68 10 04 0556*      call print_s168
0410B3 3E 20       0557*      ld a,' '
0410B5 5B D7       0558*      rst.lil 10h
0410B7 C5          0559*      push bc
0410B8 E1          0560*      pop hl
0410B9 CD 68 10 04 0561*      call print_s168
0410BD 3E 20       0562*      ld a,' '
0410BF 5B D7       0563*      rst.lil 10h
0410C1 EB          0564*      ex de,hl
0410C2 CD 68 10 04 0565*      call print_s168
0410C6 3E 20       0566*      ld a,' '
0410C8 5B D7       0567*      rst.lil 10h
0410CA E1          0568*      pop hl
0410CB D1          0569*      pop de
0410CC C1          0570*      pop bc
0410CD F1          0571*      pop af
0410CE C9          0572*      ret
0410CF             0573*  
0410CF             0574*  print_s168_bc_de:
0410CF F5          0575*      push af
0410D0 C5          0576*      push bc
0410D1 D5          0577*      push de
0410D2 C5          0578*      push bc
0410D3 E1          0579*      pop hl
0410D4 CD 68 10 04 0580*      call print_s168
0410D8 3E 20       0581*      ld a,' '
0410DA 5B D7       0582*      rst.lil 10h
0410DC EB          0583*      ex de,hl
0410DD CD 68 10 04 0584*      call print_s168
0410E1 3E 20       0585*      ld a,' '
0410E3 5B D7       0586*      rst.lil 10h
0410E5 E1          0587*      pop hl
0410E6 D1          0588*      pop de
0410E7 C1          0589*      pop bc
0410E8 F1          0590*      pop af
0410E9 C9          0591*      ret
0410EA             0592*  
0410EA             0593*  print_s168_a:
0410EA F5          0594*      push af
0410EB C5          0595*      push bc
0410EC E5          0596*      push hl
0410ED 21 00 00 00 0597*      ld hl,0
0410F1 6F          0598*      ld l,a
0410F2 CD 7D 10 04 0599*      call print_s168_hl
0410F6 E1          0600*      pop hl
0410F7 C1          0601*      pop bc
0410F8 F1          0602*      pop af
0410F9 C9          0603*      ret
0410FA             0604*  
0410FA             0605*  ; #### new functions added by Brandon R. Gates ####
0410FA             0606*  
0410FA             0607*  ; print the binary representation of the 8-bit value in a
0410FA             0608*  ; destroys a, hl, bc
0410FA             0609*  printBin8:
0410FA 06 08       0610*      ld b,8      ; loop counter for 8 bits
0410FC 21 17 11 04 0611*      ld hl,@cmd  ; set hl to the low byte of the output string
041100             0612*                  ; (which will be the high bit of the value in a)
041100             0613*  @loop:
041100 07          0614*      rlca ; put the next highest bit into carry
041101 38 04       0615*      jr c,@one
041103 36 30       0616*      ld (hl),'0'
041105 18 02       0617*      jr @next_bit
041107             0618*  @one:
041107 36 31       0619*      ld (hl),'1'
041109             0620*  @next_bit:
041109 23          0621*      inc hl
04110A 10 F4       0622*      djnz @loop
04110C             0623*  ; print it
04110C 21 17 11 04 0624*  	ld hl,@cmd
041110 01 08 00 00 0625*  	ld bc,@end-@cmd
041114 5B DF       0626*  	rst.lil $18
041116 C9          0627*  	ret
041117             0628*  @cmd: ds 8 ; eight bytes for eight bits
04111F             0629*  @end:
04111F             0630*  
04111F             0631*  ; print the binary representation of the 8-bit value in a
04111F             0632*  ; in reverse order (lsb first)
04111F             0633*  ; destroys a, hl, bc
04111F             0634*  printBin8Rev:
04111F 06 08       0635*      ld b,8      ; loop counter for 8 bits
041121 21 3C 11 04 0636*      ld hl,@cmd  ; set hl to the low byte of the output string
041125             0637*                  ; (which will be the high bit of the value in a)
041125             0638*  @loop:
041125 0F          0639*      rrca ; put the next lowest bit into carry
041126 38 04       0640*      jr c,@one
041128 36 30       0641*      ld (hl),'0'
04112A 18 02       0642*      jr @next_bit
04112C             0643*  @one:
04112C 36 31       0644*      ld (hl),'1'
04112E             0645*  @next_bit:
04112E 23          0646*      inc hl
04112F 10 F4       0647*      djnz @loop
041131             0648*  ; print it
041131 21 3C 11 04 0649*  	ld hl,@cmd
041135 01 08 00 00 0650*  	ld bc,@end-@cmd
041139 5B DF       0651*  	rst.lil $18
04113B C9          0652*  	ret
04113C             0653*  @cmd: ds 8 ; eight bytes for eight bits
041144             0654*  @end:
041144             0655*  
041144             0656*  ; print registers to screen in hexidecimal format
041144             0657*  ; inputs: none
041144             0658*  ; outputs: values of every register printed to screen
041144             0659*  ;    values of each register in global scratch memory
041144             0660*  ; destroys: nothing
041144             0661*  stepRegistersHex:
041144             0662*  ; store everything in scratch
041144 22 84 13 04 0663*      ld (uhl),hl
041148 ED 43 87 13 0664*      ld (ubc),bc
       04          
04114D ED 53 8A 13 0665*      ld (ude),de
       04          
041152 DD 22 8D 13 0666*      ld (uix),ix
       04          
041157 FD 22 90 13 0667*      ld (uiy),iy
       04          
04115C F5          0668*      push af ; fml
04115D E1          0669*      pop hl  ; thanks, zilog
04115E 22 81 13 04 0670*      ld (uaf),hl
041162 F5          0671*      push af ; dammit
041163             0672*  
041163             0673*  ; home the cursor
041163             0674*      ; call vdu_home_cursor
041163             0675*  
041163             0676*  ; print each register
041163 21 07 13 04 0677*      ld hl,str_afu
041167 CD 5C 0E 04 0678*      call printString
04116B 2A 81 13 04 0679*      ld hl,(uaf)
04116F CD 7C 0E 04 0680*      call printHex24
041173 CD 71 0E 04 0681*      call printNewLine
041177             0682*  
041177 21 0C 13 04 0683*      ld hl,str_hlu
04117B CD 5C 0E 04 0684*      call printString
04117F 2A 84 13 04 0685*      ld hl,(uhl)
041183 CD 7C 0E 04 0686*      call printHex24
041187 CD 71 0E 04 0687*      call printNewLine
04118B             0688*  
04118B 21 11 13 04 0689*      ld hl,str_bcu
04118F CD 5C 0E 04 0690*      call printString
041193 2A 87 13 04 0691*      ld hl,(ubc)
041197 CD 7C 0E 04 0692*      call printHex24
04119B CD 71 0E 04 0693*      call printNewLine
04119F             0694*  
04119F 21 16 13 04 0695*      ld hl,str_deu
0411A3 CD 5C 0E 04 0696*      call printString
0411A7 2A 8A 13 04 0697*      ld hl,(ude)
0411AB CD 7C 0E 04 0698*      call printHex24
0411AF CD 71 0E 04 0699*      call printNewLine
0411B3             0700*  
0411B3 21 1B 13 04 0701*      ld hl,str_ixu
0411B7 CD 5C 0E 04 0702*      call printString
0411BB 2A 8D 13 04 0703*      ld hl,(uix)
0411BF CD 7C 0E 04 0704*      call printHex24
0411C3 CD 71 0E 04 0705*      call printNewLine
0411C7             0706*  
0411C7 21 20 13 04 0707*      ld hl,str_iyu
0411CB CD 5C 0E 04 0708*      call printString
0411CF 2A 90 13 04 0709*      ld hl,(uiy)
0411D3 CD 7C 0E 04 0710*      call printHex24
0411D7 CD 71 0E 04 0711*      call printNewLine
0411DB             0712*  
0411DB             0713*      ; call vsync
0411DB             0714*  
0411DB CD 71 0E 04 0715*      call printNewLine
0411DF             0716*  
0411DF             0717*  ; check for right shift key and quit if pressed
0411DF             0718*  	MOSCALL mos_getkbmap
0411DF 3E 1E       0001*M 			LD	A, function
0411E1 49 CF       0002*M 			RST.LIS	08h
0411E3             0719*  @stayhere:
0411E3             0720*  ; 7 RightShift
0411E3 DD CB 00 76 0721*      bit 6,(ix+0)
0411E7 20 02       0722*      jr nz,@RightShift
0411E9 18 F8       0723*      jr @stayhere
0411EB             0724*  @RightShift:
0411EB DD CB 0E 86 0725*      res 0,(ix+14) ; debounce the key (hopefully)
0411EF 3E 80       0726*      ld a,%10000000
0411F1             0727*      ; call multiPurposeDelay
0411F1             0728*  
0411F1             0729*  ; restore everything
0411F1 2A 84 13 04 0730*      ld hl, (uhl)
0411F5 ED 4B 87 13 0731*      ld bc, (ubc)
       04          
0411FA ED 5B 8A 13 0732*      ld de, (ude)
       04          
0411FF DD 2A 8D 13 0733*      ld ix, (uix)
       04          
041204 FD 2A 90 13 0734*      ld iy, (uiy)
       04          
041209 F1          0735*      pop af
04120A             0736*  ; all done
04120A C9          0737*      ret
04120B             0738*  
04120B             0739*  ; print registers to screen in hexidecimal format
04120B             0740*  ; inputs: none
04120B             0741*  ; outputs: values of every register printed to screen
04120B             0742*  ;    values of each register in global scratch memory
04120B             0743*  ; destroys: nothing
04120B             0744*  dumpRegistersHex:
04120B             0745*  ; store everything in scratch
04120B 22 84 13 04 0746*      ld (uhl),hl
04120F ED 43 87 13 0747*      ld (ubc),bc
       04          
041214 ED 53 8A 13 0748*      ld (ude),de
       04          
041219 DD 22 8D 13 0749*      ld (uix),ix
       04          
04121E FD 22 90 13 0750*      ld (uiy),iy
       04          
041223 F5          0751*      push af ; fml
041224 E1          0752*      pop hl  ; thanks, zilog
041225 22 81 13 04 0753*      ld (uaf),hl
041229 F5          0754*      push af ; dammit
04122A             0755*  
04122A             0756*  ; home the cursor
04122A             0757*      ; call vdu_home_cursor
04122A             0758*      ; call printNewLine
04122A             0759*  
04122A             0760*  ; print each register
04122A 21 07 13 04 0761*      ld hl,str_afu
04122E CD 5C 0E 04 0762*      call printString
041232 2A 81 13 04 0763*      ld hl,(uaf)
041236 CD 7C 0E 04 0764*      call printHex24
04123A             0765*      ; call printNewLine
04123A             0766*  
04123A 21 0C 13 04 0767*      ld hl,str_hlu
04123E CD 5C 0E 04 0768*      call printString
041242 2A 84 13 04 0769*      ld hl,(uhl)
041246 CD 7C 0E 04 0770*      call printHex24
04124A             0771*      ; call printNewLine
04124A             0772*  
04124A 21 11 13 04 0773*      ld hl,str_bcu
04124E CD 5C 0E 04 0774*      call printString
041252 2A 87 13 04 0775*      ld hl,(ubc)
041256 CD 7C 0E 04 0776*      call printHex24
04125A             0777*      ; call printNewLine
04125A             0778*  
04125A 21 16 13 04 0779*      ld hl,str_deu
04125E CD 5C 0E 04 0780*      call printString
041262 2A 8A 13 04 0781*      ld hl,(ude)
041266 CD 7C 0E 04 0782*      call printHex24
04126A             0783*      ; call printNewLine
04126A             0784*  
04126A 21 1B 13 04 0785*      ld hl,str_ixu
04126E CD 5C 0E 04 0786*      call printString
041272 2A 8D 13 04 0787*      ld hl,(uix)
041276 CD 7C 0E 04 0788*      call printHex24
04127A             0789*      ; call printNewLine
04127A             0790*  
04127A 21 20 13 04 0791*      ld hl,str_iyu
04127E CD 5C 0E 04 0792*      call printString
041282 2A 90 13 04 0793*      ld hl,(uiy)
041286 CD 7C 0E 04 0794*      call printHex24
04128A             0795*      ; call printNewLine
04128A             0796*  
04128A             0797*      ; call vdu_vblank
04128A             0798*  
04128A CD 71 0E 04 0799*      call printNewLine
04128E             0800*  ; restore everything
04128E 2A 84 13 04 0801*      ld hl, (uhl)
041292 ED 4B 87 13 0802*      ld bc, (ubc)
       04          
041297 ED 5B 8A 13 0803*      ld de, (ude)
       04          
04129C DD 2A 8D 13 0804*      ld ix, (uix)
       04          
0412A1 FD 2A 90 13 0805*      ld iy, (uiy)
       04          
0412A6 F1          0806*      pop af
0412A7             0807*  ; all done
0412A7 C9          0808*      ret
0412A8             0809*  
0412A8             0810*  dumpRegistersHexPrime:
0412A8 D9          0811*      exx
0412A9 08          0812*      ex af,af'
0412AA CD 0B 12 04 0813*      call dumpRegistersHex
0412AE 08          0814*      ex af,af'
0412AF D9          0815*      exx
0412B0 C9          0816*      ret
0412B1             0817*  
0412B1             0818*  ; additionally dump prime registers
0412B1             0819*  ; inputs: none
0412B1             0820*  ; outputs: values of every register printed to screen
0412B1             0821*  ; destroys: nothing
0412B1             0822*  dumpRegistersHexAll:
0412B1 CD 0B 12 04 0823*      call dumpRegistersHex
0412B5 08          0824*      ex af,af'
0412B6 D9          0825*      exx
0412B7 CD 0B 12 04 0826*      call dumpRegistersHex
0412BB 08          0827*      ex af,af'
0412BC D9          0828*      exx
0412BD C9          0829*      ret
0412BE             0830*  
0412BE             0831*  ; print hlu to screen in hexidecimal format
0412BE             0832*  ; inputs: none
0412BE             0833*  ; destroys: nothing
0412BE             0834*  print_hex_hl:
0412BE F5          0835*      push af
0412BF E5          0836*      push hl
0412C0 21 0C 13 04 0837*      ld hl,str_hlu
0412C4 CD 5C 0E 04 0838*      call printString
0412C8 E1          0839*      pop hl
0412C9 E5          0840*      push hl
0412CA CD 7C 0E 04 0841*      call printHex24
0412CE 3E 20       0842*      ld a,' '
0412D0 5B D7       0843*      rst.lil 10h
0412D2 E1          0844*      pop hl
0412D3 F1          0845*      pop af
0412D4 C9          0846*      ret
0412D5             0847*  
0412D5             0848*  ; print bcu to screen in hexidecimal format
0412D5             0849*  ; inputs: none
0412D5             0850*  ; destroys: nothing
0412D5             0851*  print_hex_bc:
0412D5 F5          0852*      push af
0412D6 E5          0853*      push hl
0412D7 C5          0854*      push bc
0412D8 21 11 13 04 0855*      ld hl,str_bcu
0412DC CD 5C 0E 04 0856*      call printString
0412E0 E1          0857*      pop hl
0412E1 E5          0858*      push hl
0412E2 CD 7C 0E 04 0859*      call printHex24
0412E6 3E 20       0860*      ld a,' '
0412E8 5B D7       0861*      rst.lil 10h
0412EA C1          0862*      pop bc
0412EB E1          0863*      pop hl
0412EC F1          0864*      pop af
0412ED C9          0865*      ret
0412EE             0866*  
0412EE             0867*  ; print deu to screen in hexidecimal format
0412EE             0868*  ; inputs: none
0412EE             0869*  ; destroys: nothing
0412EE             0870*  print_hex_de:
0412EE F5          0871*      push af
0412EF E5          0872*      push hl
0412F0 D5          0873*      push de
0412F1 21 16 13 04 0874*      ld hl,str_deu
0412F5 CD 5C 0E 04 0875*      call printString
0412F9 E1          0876*      pop hl
0412FA E5          0877*      push hl
0412FB CD 7C 0E 04 0878*      call printHex24
0412FF 3E 20       0879*      ld a,' '
041301 5B D7       0880*      rst.lil 10h
041303 D1          0881*      pop de
041304 E1          0882*      pop hl
041305 F1          0883*      pop af
041306 C9          0884*      ret
041307             0885*  
041307 20 61 66 3D 0886*  str_afu: db " af=",0
       00          
04130C 20 68 6C 3D 0887*  str_hlu: db " hl=",0
       00          
041311 20 62 63 3D 0888*  str_bcu: db " bc=",0
       00          
041316 20 64 65 3D 0889*  str_deu: db " de=",0
       00          
04131B 20 69 78 3D 0890*  str_ixu: db " ix=",0
       00          
041320 20 69 79 3D 0891*  str_iyu: db " iy=",0
       00          
041325             0892*  
041325             0893*  ; print udeuhl to screen in hexidecimal format
041325             0894*  ; inputs: none
041325             0895*  ; outputs: concatenated hexidecimal udeuhl
041325             0896*  ; destroys: nothing
041325             0897*  dumpUDEUHLHex:
041325             0898*  ; store everything in scratch
041325 22 84 13 04 0899*      ld (uhl),hl
041329 ED 43 87 13 0900*      ld (ubc),bc
       04          
04132E ED 53 8A 13 0901*      ld (ude),de
       04          
041333 DD 22 8D 13 0902*      ld (uix),ix
       04          
041338 FD 22 90 13 0903*      ld (uiy),iy
       04          
04133D F5          0904*      push af
04133E             0905*  
04133E             0906*  ; print each register
04133E             0907*  
04133E 21 78 13 04 0908*      ld hl,str_udeuhl
041342 CD 5C 0E 04 0909*      call printString
041346 2A 8A 13 04 0910*      ld hl,(ude)
04134A CD 7C 0E 04 0911*      call printHex24
04134E 3E 2E       0912*  	ld a,'.'	; print a dot to separate the values
041350 5B D7       0913*  	rst.lil 10h
041352 2A 84 13 04 0914*      ld hl,(uhl)
041356 CD 7C 0E 04 0915*      call printHex24
04135A CD 71 0E 04 0916*      call printNewLine
04135E             0917*  
04135E             0918*  ; restore everything
04135E 2A 84 13 04 0919*      ld hl, (uhl)
041362 ED 4B 87 13 0920*      ld bc, (ubc)
       04          
041367 ED 5B 8A 13 0921*      ld de, (ude)
       04          
04136C DD 2A 8D 13 0922*      ld ix, (uix)
       04          
041371 FD 2A 90 13 0923*      ld iy, (uiy)
       04          
041376 F1          0924*      pop af
041377             0925*  ; all done
041377 C9          0926*      ret
041378             0927*  
041378 75 64 65 2E 0928*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
041381             0929*  
041381             0930*  ; global scratch memory for registers
041381 00 00 00    0931*  uaf: dl 0
041384 00 00 00    0932*  uhl: dl 0
041387 00 00 00    0933*  ubc: dl 0
04138A 00 00 00    0934*  ude: dl 0
04138D 00 00 00    0935*  uix: dl 0
041390 00 00 00    0936*  uiy: dl 0
041393 00 00 00    0937*  usp: dl 0
041396 00 00 00    0938*  upc: dl 0
041399             0939*  
041399             0940*  ; inputs: whatever is in the flags register
041399             0941*  ; outputs: binary representation of flags
041399             0942*  ;          with a header so we know which is what
041399             0943*  ; destroys: nothing
041399             0944*  ; preserves: everything
041399             0945*  dumpFlags:
041399             0946*  ; first we curse zilog for not giving direct access to flags
041399 F5          0947*      push af ; this is so we can send it back unharmed
04139A F5          0948*      push af ; this is so we can pop it to hl
04139B             0949*  ; store everything in scratch
04139B 22 84 13 04 0950*      ld (uhl),hl
04139F ED 43 87 13 0951*      ld (ubc),bc
       04          
0413A4 ED 53 8A 13 0952*      ld (ude),de
       04          
0413A9 DD 22 8D 13 0953*      ld (uix),ix
       04          
0413AE FD 22 90 13 0954*      ld (uiy),iy
       04          
0413B3             0955*  ; next we print the header
0413B3 21 DF 13 04 0956*      ld hl,@header
0413B7 CD 5C 0E 04 0957*      call printString
0413BB E1          0958*      pop hl ; flags are now in l
0413BC 7D          0959*      ld a,l ; flags are now in a
0413BD CD FA 10 04 0960*      call printBin8
0413C1 CD 71 0E 04 0961*  	call printNewLine
0413C5             0962*  ; restore everything
0413C5 2A 84 13 04 0963*      ld hl, (uhl)
0413C9 ED 4B 87 13 0964*      ld bc, (ubc)
       04          
0413CE ED 5B 8A 13 0965*      ld de, (ude)
       04          
0413D3 DD 2A 8D 13 0966*      ld ix, (uix)
       04          
0413D8 FD 2A 90 13 0967*      ld iy, (uiy)
       04          
0413DD F1          0968*      pop af ; send her home the way she came
0413DE C9          0969*      ret
0413DF             0970*  ; Bit 7 (S): Sign flag
0413DF             0971*  ; Bit 6 (Z): Zero flag
0413DF             0972*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0413DF             0973*  ; Bit 4 (H): Half Carry flag
0413DF             0974*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0413DF             0975*  ; Bit 2 (PV): Parity/Overflow flag
0413DF             0976*  ; Bit 1 (N): Subtract flag
0413DF             0977*  ; Bit 0 (C): Carry flag
0413DF 53 5A 78 48 0978*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0413EA             0979*  
0413EA             0980*  ; set all the bits in the flag register
0413EA             0981*  ; more of an academic exercise than anything useful
0413EA             0982*  ; inputs; none
0413EA             0983*  ; outputs; a=0,f=255
0413EA             0984*  ; destroys: flags, hl
0413EA             0985*  ; preserves: a, because why not
0413EA             0986*  setAllFlags:
0413EA 21 FF 00 00 0987*      ld hl,255
0413EE 67          0988*      ld h,a ; four cycles to preserve a is cheap
0413EF E5          0989*      push hl
0413F0 F1          0990*      pop af
0413F1 C9          0991*      ret
0413F2             0992*  
0413F2             0993*  ; reset all the bits in the flag register
0413F2             0994*  ; unlike its inverse counterpart, this may actually be useful
0413F2             0995*  ; inputs; none
0413F2             0996*  ; outputs; a=0,f=0
0413F2             0997*  ; destroys: flags, hl
0413F2             0998*  ; preserves: a, because why not
0413F2             0999*  resetAllFlags:
0413F2 21 00 00 00 1000*      ld hl,0
0413F6 67          1001*      ld h,a ; four cycles to preserve a is cheap
0413F7 E5          1002*      push hl
0413F8 F1          1003*      pop af
0413F9 C9          1004*      ret
0413FA             1005*  
0413FA             1006*  ; wait until user presses a key
0413FA             1007*  ; inputs: none
0413FA             1008*  ; outputs: none
0413FA             1009*  ; destroys: af,ix
0413FA             1010*  waitKeypress:
0413FA             1011*      MOSCALL mos_sysvars
0413FA 3E 08       0001*M 			LD	A, function
0413FC 49 CF       0002*M 			RST.LIS	08h
0413FE AF          1012*      xor a ; zero out any prior keypresses
0413FF DD 77 05    1013*      ld (ix+sysvar_keyascii),a
041402             1014*  @loop:
041402 DD 7E 05    1015*      ld a,(ix+sysvar_keyascii)
041405 A7          1016*      and a
041406 C0          1017*      ret nz
041407 18 F9       1018*      jr @loop
041409             1019*  
041409             1020*  
041409             1021*  ; print bytes from an address to the screen in hexidecimal format
041409             1022*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041409             1023*  ; outputs: values of each byte printed to screen separated by spaces
041409             1024*  ; destroys: nothing
041409             1025*  dumpMemoryHex:
041409             1026*  ; save registers to the stack
041409 C5          1027*      push bc
04140A E5          1028*      push hl
04140B F5          1029*      push af
04140C             1030*  
04140C             1031*  ; print the address and separator
04140C CD 7C 0E 04 1032*      call printHex24
041410 3E 3A       1033*      ld a,':'
041412 5B D7       1034*      rst.lil 10h
041414 3E 20       1035*      ld a,' '
041416 5B D7       1036*      rst.lil 10h
041418             1037*  
041418             1038*  ; set b to be our loop counter
041418 F1          1039*      pop af
041419 47          1040*      ld b,a
04141A E1          1041*      pop hl
04141B E5          1042*      push hl
04141C F5          1043*      push af
04141D             1044*  @loop:
04141D             1045*  ; print the byte
04141D 7E          1046*      ld a,(hl)
04141E CD 8A 0E 04 1047*      call printHex8
041422             1048*  ; print a space
041422 3E 20       1049*      ld a,' '
041424 5B D7       1050*      rst.lil 10h
041426 23          1051*      inc hl
041427 10 F4       1052*      djnz @loop
041429 CD 71 0E 04 1053*      call printNewLine
04142D             1054*  
04142D             1055*  ; restore everything
04142D F1          1056*      pop af
04142E E1          1057*      pop hl
04142F C1          1058*      pop bc
041430             1059*  
041430             1060*  ; all done
041430 C9          1061*      ret
041431             1062*  
041431             1063*  
041431             1064*  ; print bytes from an address to the screen in binary format
041431             1065*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041431             1066*  ; outputs: values of each byte printed to screen separated by spaces
041431             1067*  ; destroys: nothing
041431             1068*  dumpMemoryBin:
041431             1069*  ; save all registers to the stack
041431 F5          1070*      push af
041432 C5          1071*      push bc
041433 D5          1072*      push de
041434 E5          1073*      push hl
041435 DD E5       1074*      push ix
041437 FD E5       1075*      push iy
041439             1076*  
041439             1077*  ; set b to be our loop counter
041439 47          1078*      ld b,a
04143A             1079*  @loop:
04143A             1080*  ; print the byte
04143A 7E          1081*      ld a,(hl)
04143B E5          1082*      push hl
04143C C5          1083*      push bc
04143D CD FA 10 04 1084*      call printBin8
041441 C1          1085*      pop bc
041442             1086*  ; print a space
041442 3E 20       1087*      ld a,' '
041444 5B D7       1088*      rst.lil 10h
041446 E1          1089*      pop hl
041447 23          1090*      inc hl
041448 10 F0       1091*      djnz @loop
04144A CD 71 0E 04 1092*      call printNewLine
04144E             1093*  
04144E             1094*  ; restore everything
04144E FD E1       1095*      pop iy
041450 DD E1       1096*      pop ix
041452 E1          1097*      pop hl
041453 D1          1098*      pop de
041454 C1          1099*      pop bc
041455 F1          1100*      pop af
041456             1101*  ; all done
041456 C9          1102*      ret
041457             1103*  
041457             1104*  ; print bytes from an address to the screen in binary format
041457             1105*  ; with the bits of each byte in reverse order (lsb first)
041457             1106*  ; inputs: hl = address of first byte to print, a = number of bytes to print
041457             1107*  ; outputs: values of each byte printed to screen separated by spaces
041457             1108*  ; destroys: nothing
041457             1109*  dumpMemoryBinRev:
041457             1110*  ; save all registers to the stack
041457 F5          1111*      push af
041458 C5          1112*      push bc
041459 D5          1113*      push de
04145A E5          1114*      push hl
04145B DD E5       1115*      push ix
04145D FD E5       1116*      push iy
04145F             1117*  
04145F             1118*  ; set b to be our loop counter
04145F 47          1119*      ld b,a
041460             1120*  @loop:
041460             1121*  ; print the byte
041460 7E          1122*      ld a,(hl)
041461 E5          1123*      push hl
041462 C5          1124*      push bc
041463 CD 1F 11 04 1125*      call printBin8Rev
041467 C1          1126*      pop bc
041468             1127*  ; print a space
041468 3E 20       1128*      ld a,' '
04146A 5B D7       1129*      rst.lil 10h
04146C E1          1130*      pop hl
04146D 23          1131*      inc hl
04146E 10 F0       1132*      djnz @loop
041470 CD 71 0E 04 1133*      call printNewLine
041474             1134*  
041474             1135*  ; restore everything
041474 FD E1       1136*      pop iy
041476 DD E1       1137*      pop ix
041478 E1          1138*      pop hl
041479 D1          1139*      pop de
04147A C1          1140*      pop bc
04147B F1          1141*      pop af
04147C             1142*  ; all done
04147C C9          1143*      ret
04147D             0045   	include "maths.inc"
04147D             0001*  ;------------------------------------------------------------------------
04147D             0002*  ; Scratch area for calculations
04147D             0003*  ;------------------------------------------------------------------------
04147D 00 00 00    0004*  scratch1:	dw24	0	;bit manipulation buffer 1
041480 00 00 00    0005*  scratch2:	dw24	0	;bit manipulation buffer 2
041483             0006*  
041483             0007*  ; absolute value of hlu
041483             0008*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
041483             0009*  ;         s1,z0,pv0,n1,c0 if hlu was negative
041483             0010*  ;         s0,z1,pv0,n1,c0 if hlu was zero
041483             0011*  ;         s0,z0,pv0,n1,c0 if hlu was positive
041483             0012*  ; destroys: a
041483             0013*  hlu_abs:
041483 19          0014*      add hl,de
041484 B7          0015*      or a
041485 ED 52       0016*      sbc hl,de
041487 FA 8C 14 04 0017*      jp m,@is_neg
04148B C9          0018*      ret         ; hlu is positive or zero so we're done
04148C             0019*  @is_neg:
04148C F5          0020*      push af     ; otherwise, save current flags for return
04148D CD 93 14 04 0021*      call neg_hlu ; negate hlu
041491 F1          0022*      pop af      ; get back flags
041492 C9          0023*      ret
041493             0024*  
041493             0025*  ; flip the sign of hlu
041493             0026*  ; inputs: hlu
041493             0027*  ; returns: 0-hlu, flags set appropriately for the result:
041493             0028*  ;         s1,z0,pv0,n1,c1 if result is negative
041493             0029*  ;         s0,z1,pv0,n1,c0 if result is zero
041493             0030*  ;         s0,z0,pv0,n1,c1 if result is positive
041493             0031*  ; destroys a
041493             0032*  neg_hlu:
041493 D5          0033*      push de     ; save de
041494 EB          0034*      ex de,hl    ; put hl into de
041495 21 00 00 00 0035*      ld hl,0     ; clear hl
041499 AF          0036*      xor a       ; clear carry
04149A ED 52       0037*      sbc hl,de   ; 0-hlu = -hlu
04149C D1          0038*      pop de      ; get de back
04149D C9          0039*      ret         ; easy peasy
04149E             0040*  
04149E             0041*  ;------------------------------------------------------------------------
04149E             0042*  ; divide hlu by 2, inspired by above
04149E             0043*  ;------------------------------------------------------------------------
04149E             0044*  hlu_div2:
04149E 22 7D 14 04 0045*  	ld		(scratch1),hl
0414A2 21 7F 14 04 0046*  	ld		hl,scratch1+2
0414A6 CB 1E       0047*  	rr		(hl)
0414A8 2B          0048*  	dec		hl
0414A9 CB 1E       0049*  	rr		(hl)
0414AB 2B          0050*  	dec		hl
0414AC CB 1E       0051*  	rr		(hl)
0414AE 23          0052*  	inc		hl
0414AF 23          0053*  	inc		hl
0414B0 2A 7D 14 04 0054*      ld hl,(scratch1)
0414B4 C9          0055*      ret
0414B5             0056*  
0414B5             0057*  ; this is my little hack to divide by 16
0414B5             0058*  hlu_div16:
0414B5 AF          0059*      xor a
0414B6 29          0060*      add hl,hl
0414B7 17          0061*      rla
0414B8 29          0062*      add hl,hl
0414B9 17          0063*      rla
0414BA 29          0064*      add hl,hl
0414BB 17          0065*      rla
0414BC 29          0066*      add hl,hl
0414BD 17          0067*      rla
0414BE 22 CB 14 04 0068*      ld (@scratch),hl
0414C2 32 CE 14 04 0069*      ld (@scratch+3),a
0414C6 2A CC 14 04 0070*      ld hl,(@scratch+1)
0414CA C9          0071*      ret
0414CB             0072*  @scratch: ds 4
0414CF             0073*  
0414CF             0074*  ; hlu signed division by 256
0414CF             0075*  ; returns: hlu / 256
0414CF             0076*  ; destroys: af
0414CF             0077*  hlu_sdiv256:
0414CF AF          0078*      xor a ; assume hl is positive
0414D0 22 E6 14 04 0079*      ld (@buffer),hl
0414D4             0080*      sign_hlu
0414D4 19          0001*M         add hl,de
0414D5 B7          0002*M         or a
0414D6 ED 52       0003*M         sbc hl,de
0414D8 F2 DD 14 04 0081*      jp p,@hl_pos
0414DC 3D          0082*      dec a
0414DD             0083*  @hl_pos:
0414DD 32 E9 14 04 0084*      ld (@buffer+3),a
0414E1 2A E7 14 04 0085*      ld hl,(@buffer+1)
0414E5 C9          0086*      ret
0414E6             0087*  @buffer: ds 4
0414EA             0088*  
0414EA             0089*  ; hlu 1 byte right shift, unsigned
0414EA             0090*  ; returns: hlu / 256, fractional portion in a
0414EA             0091*  ; destroys: af
0414EA             0092*  hlu_udiv256:
0414EA AF          0093*  	xor a
0414EB 32 FC 14 04 0094*  	ld (@buffer+3),a
0414EF 7D          0095*  	ld a,l ; save the fractional portion
0414F0 22 F9 14 04 0096*  	ld (@buffer),hl
0414F4 2A FA 14 04 0097*  	ld hl,(@buffer+1)
0414F8 C9          0098*  	ret
0414F9             0099*  @buffer: ds 4
0414FD             0100*  
0414FD             0101*      MACRO hlu_mul256
0414FD             0102*          add hl,hl ; * 2
0414FD             0103*          add hl,hl ; * 4
0414FD             0104*          add hl,hl ; * 8
0414FD             0105*          add hl,hl ; * 16
0414FD             0106*          add hl,hl ; * 32
0414FD             0107*          add hl,hl ; * 64
0414FD             0108*          add hl,hl ; * 128
0414FD             0109*          add hl,hl ; * 256
0414FD             0110*      ENDMACRO
0414FD             0111*  
0414FD             0112*  ; compute the modulo of hlu by deu
0414FD             0113*  ; outputs: hlu = hlu % deu
0414FD             0114*  ; destroys: f, hl
0414FD             0115*  hlu_mod:
0414FD B7          0116*  	or a ; clear carry
0414FE             0117*  @loop:
0414FE ED 52       0118*      sbc hl,de
041500 DA 08 15 04 0119*      jp c, @end
041504 C3 FE 14 04 0120*      jp @loop
041508             0121*  @end:
041508 19          0122*      add hl,de
041509 C9          0123*  	ret
04150A             0124*  
04150A             0125*  
04150A 00 00 00 00 0126*  add_bcd_arg1: db #00,#00,#00,#00
04150E 00 00 00 00 0127*  add_bcd_arg2: db #00,#00,#00,#00
041512             0128*  
041512             0129*  ; set bcd values in a scratch memory address from registers bcde
041512             0130*  ; input: hl; scratch address,bcde; 8-place bcd number
041512             0131*  ; destroys ; hl
041512             0132*  set_bcd:
041512 73          0133*      ld (hl),e
041513 23          0134*      inc hl
041514 72          0135*      ld (hl),d
041515 23          0136*      inc hl
041516 71          0137*      ld (hl),c
041517 23          0138*      inc hl
041518 70          0139*      ld (hl),b
041519 C9          0140*      ret
04151A             0141*  
04151A             0142*  ; load bcd values from a scratch memory address to bcde
04151A             0143*  ; input: hl; scratch address
04151A             0144*  ; output: bcde; 8-place bcd number
04151A             0145*  ; destroys: hl
04151A             0146*  get_bcd:
04151A 5E          0147*      ld e,(hl)
04151B 23          0148*      inc hl
04151C 56          0149*      ld d,(hl)
04151D 23          0150*      inc hl
04151E 4E          0151*      ld c,(hl)
04151F 23          0152*      inc hl
041520 46          0153*      ld b,(hl)
041521 C9          0154*      ret
041522             0155*  
041522             0156*  ; BCD addition
041522             0157*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
041522             0158*  ;       a is the number of bytes holding each number (number of places/2)
041522             0159*  ; outputs: (hl) + (de) --> (hl)
041522             0160*  ; destroys: a,b,de,hl
041522             0161*  add_bcd:
041522 47          0162*      ld b,a ; loop counter
041523 AF          0163*      xor a ; reset a, clear carry flag
041524             0164*  adcec:
041524 1A          0165*      ld a,(de) ; addend to acc
041525 8E          0166*      adc a,(hl) ; add (hl) to acc
041526 27          0167*      daa ; adjust result to bcd
041527 77          0168*      ld (hl),a ; store result
041528 23          0169*      inc hl ; advance memory pointers
041529 13          0170*      inc de
04152A 10 F8       0171*      djnz adcec ; loop until b == 0
04152C C9          0172*      ret
04152D             0173*  
04152D             0174*  ; BCD subtraction
04152D             0175*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
04152D             0176*  ;       a is the number of bytes holding each number (number of places/2)
04152D             0177*  ; outputs: (hl) - (de) --> (hl)
04152D             0178*  ; destroys: a,b,de,hl
04152D             0179*  sub_bcd:
04152D 47          0180*      ld b,a ; loop counter
04152E AF          0181*      xor a ; reset a,clear carry flag
04152F             0182*  subdec:
04152F 1A          0183*      ld a,(de) ; subtrahend to acc
041530 9E          0184*      sbc a,(hl) ; subtract (hl) from acc
041531 27          0185*      daa ; adjust result to bcd
041532 77          0186*      ld (hl),a ; store result
041533 23          0187*      inc hl ; advance memory pointers
041534 13          0188*      inc de
041535 10 F8       0189*      djnz subdec ; loop until b == 0
041537 C9          0190*      ret
041538             0191*  
041538             0192*  ; http://www.z80.info/pseudo-random.txt
041538             0193*  rand_8:
041538 C5          0194*      push bc
041539 3A 4C 15 04 0195*      ld a,(r_seed)
04153D 4F          0196*      ld c,a
04153E             0197*  
04153E 0F          0198*      rrca ; multiply by 32
04153F 0F          0199*      rrca
041540 0F          0200*      rrca
041541 EE 1F       0201*      xor 0x1f
041543             0202*  
041543 81          0203*      add a,c
041544 DE FF       0204*      sbc a,255 ; carry
041546             0205*  
041546 32 4C 15 04 0206*      ld (r_seed),a
04154A C1          0207*      pop bc
04154B C9          0208*      ret
04154C 50          0209*  r_seed: defb $50
04154D             0046       include "mathfpp.inc"
04154D             0001*  ; integer operations
04154D             0002*  iand:	EQU 58	; AND (INTEGER)
04154D             0003*  ibdiv:	EQU 59	; DIV
04154D             0004*  ieor:	EQU 60	; EOR
04154D             0005*  imod:	EQU 61	; MOD
04154D             0006*  ior:	EQU 62	; OR
04154D             0007*  ile:	EQU 63	; <=
04154D             0008*  ine:	EQU 64	; <>
04154D             0009*  ige:	EQU 65	; >=
04154D             0010*  ilt:	EQU 66	; <
04154D             0011*  ieq:	EQU 67	; =
04154D             0012*  imul:	EQU 68	; *
04154D             0013*  iadd:	EQU 69	; +
04154D             0014*  igt:	EQU 70	; >
04154D             0015*  isub:	EQU 71	; -
04154D             0016*  ipow:	EQU 72	; ^
04154D             0017*  idiv:	EQU 73	; /
04154D             0018*  ;
04154D             0019*  ; floating point functions
04154D             0020*  absv:	EQU 16	; ABS
04154D             0021*  acs:	EQU 17	; ACS
04154D             0022*  asn:	EQU 18	; ASN
04154D             0023*  atn:	EQU 19	; ATN
04154D             0024*  cos:	EQU 20	; COS
04154D             0025*  deg:	EQU 21	; DEG
04154D             0026*  exp:	EQU 22	; EXP
04154D             0027*  int_:	EQU 23	; INT
04154D             0028*  ln:	    EQU 24	; LN
04154D             0029*  log:	EQU 25	; LOG
04154D             0030*  notk:	EQU 26	; NOT
04154D             0031*  rad:	EQU 27	; RAD
04154D             0032*  sgn:	EQU 28	; SGN
04154D             0033*  sin:	EQU 29	; SIN
04154D             0034*  sqr:	EQU 30	; SQR
04154D             0035*  tan:	EQU 31	; TAN
04154D             0036*  zero:	EQU 32	; ZERO
04154D             0037*  fone:	EQU 33	; FONE
04154D             0038*  true:	EQU 34	; TRUE
04154D             0039*  pi:	    EQU 35	; PI
04154D             0040*  val:	EQU 36	; VAL
04154D             0041*  str:	EQU 37	; STR$
04154D             0042*  sfix:	EQU 38	; FIX
04154D             0043*  sfloat:	EQU 39	; FLOAT
04154D             0044*  ftest:	EQU 40	; TEST
04154D             0045*  fcomp:	EQU 41	; COMPARE
04154D             0046*  ;
04154D             0047*  ; floating point operations
04154D             0048*  fand:	EQU  0	; AND (FLOATING-POINT)
04154D             0049*  fbdiv:	EQU  1	; DIV
04154D             0050*  feor:	EQU  2	; EOR
04154D             0051*  fmod:	EQU  3	; MOD
04154D             0052*  ffor:	EQU  4	; OR
04154D             0053*  fle:	EQU  5	; <=
04154D             0054*  fne:	EQU  6	; <>
04154D             0055*  fge:	EQU  7	; >=
04154D             0056*  flt:	EQU  8	; <
04154D             0057*  feq:	EQU  9	; =
04154D             0058*  fmul:	EQU 10	; *
04154D             0059*  fadd:	EQU 11	; +
04154D             0060*  fgt:	EQU 12	; >
04154D             0061*  fsub:	EQU 13	; -
04154D             0062*  fpow:	EQU 14	; ^
04154D             0063*  fdiv:	EQU 15	; /
04154D             0064*  
04154D             0065*      MACRO LOAD_FLOAT ARG
04154D             0066*      ld ix,$+11
04154D             0067*      call val_fp ; convert the string to a float
04154D             0068*      jp (ix)
04154D             0069*      asciz ARG
04154D             0070*      ENDMACRO
04154D             0071*  
04154D             0072*  ; --- originally in eval.asm ---
04154D             0073*  ;SWAP - Swap arguments
04154D             0074*  ;Exchanges DE,HL D'E',H'L' and B,C
04154D             0075*  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
04154D             0076*  ;
04154D 79          0077*  SWAP:			LD      A,C
04154E 48          0078*  			LD      C,B
04154F 47          0079*  			LD      B,A
041550 EB          0080*  			EX      DE,HL
041551 D9          0081*  			EXX
041552 EB          0082*  			EX      DE,HL
041553 D9          0083*  			EXX
041554 C9          0084*  			RET
041555             0085*  
041555             0086*  ; same as VAL_FP in fpp.asm, but preserves any float stored in DED'E'B
041555             0087*  val_fp:
041555 FD E5       0088*      push iy ; preserve
041557 FD 21 72 15 0089*      ld iy,@val
       04          
04155C CD 64 16 04 0090*      call store_float_iy_alt
041560 3E 24       0091*      ld a,val
041562 CD 60 00 04 0092*      call FPP ; string converted to float in HLH'L'C
041566 FD 21 72 15 0093*      ld iy,@val
       04          
04156B CD 76 16 04 0094*      call fetch_float_iy_alt
04156F FD E1       0095*      pop iy ; restore
041571 C9          0096*      ret
041572             0097*  @val: ds 5
041577             0098*  
041577             0099*  ; same as INT_FP_ in fpp.asm but preserves B, which keeps any float stored in DED'E'B intact
041577             0100*  ; af will also return differently from the original
041577             0101*  ;INT - Floor function
041577             0102*  ;Result is integer numeric.
041577             0103*  ;
041577             0104*  int_fp_:
041577 C5          0105*      push bc ; preserve b
041578 3E 17       0106*      ld a,int_
04157A CD 60 00 04 0107*      call FPP
04157E F1          0108*      pop af ; restore b to a
04157F 47          0109*      ld b,a ; restore b
041580 C9          0110*      RET
041581             0111*  
041581             0112*  ; convert floating point number to integer and store it in HLU
041581             0113*  ; inputs: HLH'L'C = floating point number
041581             0114*  ; outputs: HLU = integer part of the number
041581             0115*  ; destroys: all except DEU and U'D'E'B, index registers
041581             0116*  int2hlu:
041581 CD 77 15 04 0117*      call int_fp_
041585 7D          0118*      ld a,l
041586 F5          0119*      push af
041587 D9          0120*      exx
041588 E5          0121*      push hl
041589 D9          0122*      exx
04158A E1          0123*      pop hl
04158B F1          0124*      pop af
04158C CD 45 0E 04 0125*      call A_TO_HLU
041590 C9          0126*      ret
041591             0127*  
041591             0128*  ; convert polar coordinates to cartesian coordinates as deltas from the origin
041591             0129*  ; inputs: HLH'L'C = angle in radians
041591             0130*  ;         DED'E'B = radius
041591             0131*  ; outputs: HLH'L'C = dx
041591             0132*  ;          DED'E'B = dy
041591             0133*  polar_to_cartesian_fpp:
041591             0134*  ; store input parameters in scratch
041591 FD 21 E9 15 0135*      ld iy,@angle
       04          
041596 CD 40 16 04 0136*      call store_float_iy_nor
04159A FD 21 EE 15 0137*      ld iy,@radius
       04          
04159F CD 64 16 04 0138*      call store_float_iy_alt
0415A3             0139*  ; compute dy = sin(angle) * radius
0415A3 3E 1D       0140*      ld a,sin
0415A5 CD 60 00 04 0141*      call FPP ; HLH'L'C = sin(angle)
0415A9 FD 21 EE 15 0142*      ld iy,@radius
       04          
0415AE CD 76 16 04 0143*      call fetch_float_iy_alt ; DED'E'B = radius
0415B2 3E 0A       0144*      ld a,fmul
0415B4 CD 60 00 04 0145*      call FPP ; HLH'L'C = sin(angle) * radius
0415B8 FD 21 F3 15 0146*      ld iy,@scratch
       04          
0415BD CD 40 16 04 0147*      call store_float_iy_nor ; @scratch = dy
0415C1             0148*  ; compute dx = cos(angle) * radius
0415C1 FD 21 E9 15 0149*      ld iy,@angle
       04          
0415C6 CD 52 16 04 0150*      call fetch_float_iy_nor
0415CA 3E 14       0151*      ld a,cos
0415CC CD 60 00 04 0152*      call FPP ; HLH'L'C = cos(angle)
0415D0 FD 21 EE 15 0153*      ld iy,@radius
       04          
0415D5 CD 76 16 04 0154*      call fetch_float_iy_alt ; DED'E'B = radius
0415D9 3E 0A       0155*      ld a,fmul
0415DB CD 60 00 04 0156*      call FPP ; HLH'L'C = cos(angle) * radius
0415DF             0157*  ; restore dy from @scratch
0415DF FD 21 F3 15 0158*      ld iy,@scratch
       04          
0415E4 CD 76 16 04 0159*      call fetch_float_iy_alt
0415E8 C9          0160*      ret
0415E9             0161*  @angle: ds 5
0415EE             0162*  @radius: ds 5
0415F3             0163*  @scratch: ds 5
0415F8             0164*  
0415F8             0165*  ; store HLH'L'C floating point number in a 40-bit buffer
0415F8             0166*  ; inputs: HLH'L'C = floating point number
0415F8             0167*  ;         ix = buffer address
0415F8             0168*  ; outputs: buffer filled with floating point number
0415F8             0169*  ; destroys: nothing
0415F8             0170*  store_float_nor:
0415F8 DD 71 00    0171*      ld (ix+0),c
0415FB DD 75 03    0172*      ld (ix+3),l
0415FE DD 74 04    0173*      ld (ix+4),h
041601 D9          0174*      exx
041602 DD 75 01    0175*      ld (ix+1),l
041605 DD 74 02    0176*      ld (ix+2),h
041608 D9          0177*      exx
041609 C9          0178*      ret
04160A             0179*  
04160A             0180*  ; fetch HLH'L'C floating point number from a 40-bit buffer
04160A             0181*  ; inputs: ix = buffer address
04160A             0182*  ; outputs: HLH'L'C = floating point number
04160A             0183*  ; destroys: HLH'L'C
04160A             0184*  fetch_float_nor:
04160A DD 4E 00    0185*      ld c,(ix+0)
04160D DD 6E 03    0186*      ld l,(ix+3)
041610 DD 66 04    0187*      ld h,(ix+4)
041613 D9          0188*      exx
041614 DD 6E 01    0189*      ld l,(ix+1)
041617 DD 66 02    0190*      ld h,(ix+2)
04161A D9          0191*      exx
04161B C9          0192*      ret
04161C             0193*  
04161C             0194*  ; store DED'E'B floating point number in a 40-bit buffer
04161C             0195*  ; inputs: DED'E'B = floating point number
04161C             0196*  ;         ix = buffer address
04161C             0197*  ; outputs: buffer filled with floating point number
04161C             0198*  ; destroys: nothing
04161C             0199*  store_float_alt:
04161C DD 70 00    0200*      ld (ix+0),b
04161F DD 73 03    0201*      ld (ix+3),e
041622 DD 72 04    0202*      ld (ix+4),d
041625 D9          0203*      exx
041626 DD 73 01    0204*      ld (ix+1),e
041629 DD 72 02    0205*      ld (ix+2),d
04162C D9          0206*      exx
04162D C9          0207*      ret
04162E             0208*  
04162E             0209*  ; fetch DED'E'B floating point number from a 40-bit buffer
04162E             0210*  ; inputs: ix = buffer address
04162E             0211*  ; outputs: DED'E'B = floating point number
04162E             0212*  ; destroys: DED'E'B
04162E             0213*  fetch_float_alt:
04162E DD 46 00    0214*      ld b,(ix+0)
041631 DD 5E 03    0215*      ld e,(ix+3)
041634 DD 56 04    0216*      ld d,(ix+4)
041637 D9          0217*      exx
041638 DD 5E 01    0218*      ld e,(ix+1)
04163B DD 56 02    0219*      ld d,(ix+2)
04163E D9          0220*      exx
04163F C9          0221*      ret
041640             0222*  
041640             0223*  
041640             0224*  ; store HLH'L'C floating point number in a 40-bit buffer
041640             0225*  ; inputs: HLH'L'C = floating point number
041640             0226*  ;         iy = buffer address
041640             0227*  ; outputs: buffer filled with floating point number
041640             0228*  ; destroys: nothing
041640             0229*  store_float_iy_nor:
041640 FD 71 00    0230*      ld (iy+0),c
041643 FD 75 03    0231*      ld (iy+3),l
041646 FD 74 04    0232*      ld (iy+4),h
041649 D9          0233*      exx
04164A FD 75 01    0234*      ld (iy+1),l
04164D FD 74 02    0235*      ld (iy+2),h
041650 D9          0236*      exx
041651 C9          0237*      ret
041652             0238*  
041652             0239*  ; fetch HLH'L'C floating point number from a 40-bit buffer
041652             0240*  ; inputs: iy = buffer address
041652             0241*  ; outputs: HLH'L'C = floating point number
041652             0242*  ; destroys: HLH'L'C
041652             0243*  fetch_float_iy_nor:
041652 FD 4E 00    0244*      ld c,(iy+0)
041655 FD 6E 03    0245*      ld l,(iy+3)
041658 FD 66 04    0246*      ld h,(iy+4)
04165B D9          0247*      exx
04165C FD 6E 01    0248*      ld l,(iy+1)
04165F FD 66 02    0249*      ld h,(iy+2)
041662 D9          0250*      exx
041663 C9          0251*      ret
041664             0252*  
041664             0253*  ; store DED'E'B floating point number in a 40-bit buffer
041664             0254*  ; inputs: DED'E'B = floating point number
041664             0255*  ;         iy = buffer address
041664             0256*  ; outputs: buffer filled with floating point number
041664             0257*  ; destroys: nothing
041664             0258*  store_float_iy_alt:
041664 FD 70 00    0259*      ld (iy+0),b
041667 FD 73 03    0260*      ld (iy+3),e
04166A FD 72 04    0261*      ld (iy+4),d
04166D D9          0262*      exx
04166E FD 73 01    0263*      ld (iy+1),e
041671 FD 72 02    0264*      ld (iy+2),d
041674 D9          0265*      exx
041675 C9          0266*      ret
041676             0267*  
041676             0268*  ; fetch DED'E'B floating point number from a 40-bit buffer
041676             0269*  ; inputs: iy = buffer address
041676             0270*  ; outputs: DED'E'B = floating point number
041676             0271*  ; destroys: DED'E'B
041676             0272*  fetch_float_iy_alt:
041676 FD 46 00    0273*      ld b,(iy+0)
041679 FD 5E 03    0274*      ld e,(iy+3)
04167C FD 56 04    0275*      ld d,(iy+4)
04167F D9          0276*      exx
041680 FD 5E 01    0277*      ld e,(iy+1)
041683 FD 56 02    0278*      ld d,(iy+2)
041686 D9          0279*      exx
041687 C9          0280*      ret
041688             0281*  
041688             0282*  ; print HLH'L'C floating point number in hex format
041688             0283*  ; inputs: HLH'L'C = floating point number
041688             0284*  print_float_hex_nor:
041688             0285*      PUSH_ALL
041688 08          0001*M         ex af,af'
041689 D9          0002*M         exx
04168A F5          0003*M         push af
04168B E5          0004*M         push hl
04168C C5          0005*M         push bc
04168D D5          0006*M         push de
04168E             0007*M 
04168E 08          0008*M         ex af,af'
04168F D9          0009*M         exx
041690 F5          0010*M         push af
041691 E5          0011*M         push hl
041692 C5          0012*M         push bc
041693 D5          0013*M         push de
041694 DD E5       0014*M         push ix
041696 FD E5       0015*M         push iy
041698 CD 84 0E 04 0286*      call printHex16
04169C 3E 2E       0287*      ld a,'.'
04169E 5B D7       0288*      rst.lil 10h
0416A0 D9          0289*      exx
0416A1 CD 84 0E 04 0290*      call printHex16
0416A5 D9          0291*      exx
0416A6 3E 5E       0292*      ld a,'^'
0416A8 5B D7       0293*      rst.lil 10h
0416AA 79          0294*      ld a,c
0416AB CD 8A 0E 04 0295*      call printHex8
0416AF             0296*      POP_ALL
0416AF FD E1       0001*M         pop iy
0416B1 DD E1       0002*M         pop ix
0416B3 D1          0003*M         pop de
0416B4 C1          0004*M         pop bc
0416B5 E1          0005*M         pop hl
0416B6 F1          0006*M         pop af
0416B7 08          0007*M         ex af,af'
0416B8 D9          0008*M         exx
0416B9             0009*M 
0416B9 D1          0010*M         pop de
0416BA C1          0011*M         pop bc
0416BB E1          0012*M         pop hl
0416BC F1          0013*M         pop af
0416BD 08          0014*M         ex af,af'
0416BE D9          0015*M         exx
0416BF C9          0297*      ret
0416C0             0298*  
0416C0             0299*  ; print DED'E'B floating point number in hex format
0416C0             0300*  ; inputs: DED'E'B = floating point number
0416C0             0301*  print_float_hex_alt:
0416C0             0302*      PUSH_ALL
0416C0 08          0001*M         ex af,af'
0416C1 D9          0002*M         exx
0416C2 F5          0003*M         push af
0416C3 E5          0004*M         push hl
0416C4 C5          0005*M         push bc
0416C5 D5          0006*M         push de
0416C6             0007*M 
0416C6 08          0008*M         ex af,af'
0416C7 D9          0009*M         exx
0416C8 F5          0010*M         push af
0416C9 E5          0011*M         push hl
0416CA C5          0012*M         push bc
0416CB D5          0013*M         push de
0416CC DD E5       0014*M         push ix
0416CE FD E5       0015*M         push iy
0416D0 EB          0303*      ex de,hl
0416D1 CD 84 0E 04 0304*      call printHex16
0416D5 EB          0305*      ex de,hl
0416D6 3E 2E       0306*      ld a,'.'
0416D8 5B D7       0307*      rst.lil 10h
0416DA D9          0308*      exx
0416DB EB          0309*      ex de,hl
0416DC CD 84 0E 04 0310*      call printHex16
0416E0 EB          0311*      ex de,hl
0416E1 D9          0312*      exx
0416E2 3E 5E       0313*      ld a,'^'
0416E4 5B D7       0314*      rst.lil 10h
0416E6 78          0315*      ld a,b
0416E7 CD 8A 0E 04 0316*      call printHex8
0416EB             0317*      POP_ALL
0416EB FD E1       0001*M         pop iy
0416ED DD E1       0002*M         pop ix
0416EF D1          0003*M         pop de
0416F0 C1          0004*M         pop bc
0416F1 E1          0005*M         pop hl
0416F2 F1          0006*M         pop af
0416F3 08          0007*M         ex af,af'
0416F4 D9          0008*M         exx
0416F5             0009*M 
0416F5 D1          0010*M         pop de
0416F6 C1          0011*M         pop bc
0416F7 E1          0012*M         pop hl
0416F8 F1          0013*M         pop af
0416F9 08          0014*M         ex af,af'
0416FA D9          0015*M         exx
0416FB C9          0318*      ret
0416FC             0319*  
0416FC             0320*  print_floats_hex:
0416FC CD 88 16 04 0321*      call print_float_hex_nor
041700 3E 20       0322*      ld a,' '
041702 5B D7       0323*      rst.lil 10h
041704 CD C0 16 04 0324*      call print_float_hex_alt
041708 C9          0325*      ret
041709             0326*  
041709             0327*  ; print a floating point number in decimal format
041709             0328*  ; inputs: HL'H'L'C is the number to print
041709             0329*  ; outputs: number printed to screen
041709             0330*  ;          ACCS null-terminated string representation of the number
041709             0331*  ; destroys: everything except ix
041709             0332*  print_float_dec:
041709             0333*  print_float_dec_nor:
041709 DD E5       0334*      push ix             ; preserve
04170B             0335*  
04170B             0336*  ; back up floats in normal and alternate registers
04170B DD 21 4C 17 0337*      ld ix,@float_nor
       04          
041710 CD F8 15 04 0338*      call store_float_nor
041714 DD 21 51 17 0339*      ld ix,@float_alt
       04          
041719 CD 1C 16 04 0340*      call store_float_alt
04171D             0341*  
04171D             0342*  ; convert the number to a string
04171D 11 00 20 04 0343*      ld de,ACCS          ; point to the string accumulator
041721 DD 21 49 17 0344*      ld ix,@G9-1         ; get the format code for the number
       04          
041726 CD 5F 08 04 0345*      call STR_FP         ; convert the number to a string
04172A EB          0346*      ex de,hl            ; point to end of the string
04172B 36 00       0347*      ld (hl),0           ; null-terminate the string
04172D 21 00 20 04 0348*      ld hl,ACCS          ; point to the string accumulator
041731 CD 5C 0E 04 0349*      call printString
041735             0350*  
041735             0351*  ; restore floats in normal and alternate registers
041735 DD 21 4C 17 0352*      ld ix,@float_nor
       04          
04173A CD 0A 16 04 0353*      call fetch_float_nor
04173E DD 21 51 17 0354*      ld ix,@float_alt
       04          
041743 CD 2E 16 04 0355*      call fetch_float_alt
041747             0356*  
041747             0357*  ; cleanup and go home
041747 DD E1       0358*      pop ix              ; restore
041749 C9          0359*      ret
04174A 09 00       0360*  @G9:			DW    9
04174C             0361*  @float_nor: ds 5
041751             0362*  @float_alt: ds 5
041756             0363*  
041756             0364*  print_float_dec_alt:
041756 CD 4D 15 04 0365*      CALL SWAP
04175A CD 09 17 04 0366*      CALL print_float_dec_nor
04175E CD 4D 15 04 0367*      CALL SWAP
041762 C9          0368*      ret
041763             0369*  
041763             0370*  ;PI - Return PI (3.14159265)
041763             0371*  ;Result is floating-point numeric.
041763             0372*  ;
041763 11 0F 49 00 0373*  pi_alt:			LD      DE,0x490F
041767 D9          0374*          		EXX
041768 11 A2 DA 00 0375*          		LD      DE,0xDAA2
04176C D9          0376*          		EXX
04176D 06 81       0377*          		LD      B,0x81
04176F AF          0378*          		XOR     A               ;NUMERIC MARKER
041770 C9          0379*          		RET
041771             0380*  
041771             0381*  ;PI - Return PI * 2 (6.28318531)
041771             0382*  ;Result is floating-point numeric.
041771             0383*  ;
041771 11 0F 49 00 0384*  pi2_alt:		LD      DE,0x490F
041775 D9          0385*          		EXX
041776 11 A3 DA 00 0386*          		LD      DE,0xDAA3
04177A D9          0387*          		EXX
04177B 06 82       0388*          		LD      B,0x82
04177D AF          0389*          		XOR     A               ;NUMERIC MARKER
04177E C9          0390*          		RET
04177F             0047       include "vdu.inc"
04177F             0001*  
04177F             0002*  ; VDU 30: Home cursor
04177F             0003*  vdu_home_cursor:
04177F 3E 1E       0004*      ld a,30
041781 5B D7       0005*  	rst.lil $10
041783 C9          0006*  	ret
041784             0007*  
041784             0008*  cursor_on:
041784 21 8F 17 04 0009*  	ld hl,@cmd
041788 01 03 00 00 0010*  	ld bc,@end-@cmd
04178C 5B DF       0011*  	rst.lil $18
04178E C9          0012*  	ret
04178F             0013*  @cmd:
04178F 17 01 01    0014*  	db 23,1,1
041792             0015*  @end:
041792             0016*  
041792             0017*  cursor_off:
041792 21 9D 17 04 0018*  	ld hl,@cmd
041796 01 03 00 00 0019*  	ld bc,@end-@cmd
04179A 5B DF       0020*  	rst.lil $18
04179C C9          0021*  	ret
04179D             0022*  @cmd:
04179D 17 01 00    0023*  	db 23,1,0
0417A0             0024*  @end:
0417A0             0025*  
0417A0             0026*  ; VDU 9: Move cursor forward one character
0417A0             0027*  vdu_cursor_forward:
0417A0 3E 09       0028*      ld a,9
0417A2 5B D7       0029*  	rst.lil $10
0417A4 C9          0030*  	ret
0417A5             0031*  
0417A5             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0417A5             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0417A5             0034*  vdu_move_cursor:
0417A5 ED 43 B6 17 0035*      ld (@x0),bc
       04          
0417AA 21 B5 17 04 0036*  	ld hl,@cmd
0417AE 01 03 00 00 0037*  	ld bc,@end-@cmd
0417B2 5B DF       0038*  	rst.lil $18
0417B4 C9          0039*  	ret
0417B5 1F          0040*  @cmd: 	db 31
0417B6 00          0041*  @x0:	db 0
0417B7 00          0042*  @y0: 	db 0
0417B8 00          0043*  @end: 	db 0 ; padding
0417B9             0044*  
0417B9             0045*  ; VDU 12: Clear text area (CLS)
0417B9             0046*  vdu_cls:
0417B9 3E 0C       0047*      ld a,12
0417BB 5B D7       0048*  	rst.lil $10
0417BD C9          0049*  	ret
0417BE             0050*  
0417BE             0051*  vdu_flip:
0417BE 21 C9 17 04 0052*  	ld hl,@cmd
0417C2 01 03 00 00 0053*  	ld bc,@end-@cmd
0417C6 5B DF       0054*  	rst.lil $18
0417C8 C9          0055*  	ret
0417C9 17 00 C3    0056*  @cmd: db 23,0,0xC3
0417CC             0057*  @end:
0417CC             0058*  
0417CC             0059*  ; VDU 16: Clear graphics area (CLG)
0417CC             0060*  vdu_clg:
0417CC 3E 10       0061*      ld a,16
0417CE 5B D7       0062*  	rst.lil $10
0417D0 C9          0063*  	ret
0417D1             0064*  
0417D1             0065*  ; COLOUR MODES
0417D1             0066*  ; Mode	Effect
0417D1             0067*  ; 0	Set on-screen pixel to target colour value
0417D1             0068*  ; 1	OR value with the on-screen pixel
0417D1             0069*  ; 2	AND value with the on-screen pixel
0417D1             0070*  ; 3	XOR value with the on-screen pixel
0417D1             0071*  ; 4	Invert the on-screen pixel
0417D1             0072*  ; 5	No operation
0417D1             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0417D1             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0417D1             0075*  
0417D1             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0417D1             0077*  vdu_colour_text:
0417D1 32 E1 17 04 0078*  	ld (@arg),a
0417D5 21 E0 17 04 0079*  	ld hl,@cmd
0417D9 01 02 00 00 0080*  	ld bc,@end-@cmd
0417DD 5B DF       0081*  	rst.lil $18
0417DF C9          0082*  	ret
0417E0 11          0083*  @cmd: db 17
0417E1 00          0084*  @arg: db 0
0417E2             0085*  @end:
0417E2             0086*  
0417E2             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0417E2             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0417E2             0089*  vdu_gcol:
0417E2 32 F7 17 04 0090*  	ld (@mode),a
0417E6 79          0091*      ld a,c
0417E7 32 F8 17 04 0092*      ld (@col),a
0417EB 21 F6 17 04 0093*  	ld hl,@cmd
0417EF 01 03 00 00 0094*  	ld bc,@end-@cmd
0417F3 5B DF       0095*  	rst.lil $18
0417F5 C9          0096*  	ret
0417F6 12          0097*  @cmd:  db 18
0417F7 00          0098*  @mode: db 0
0417F8 00          0099*  @col:  db 0
0417F9             0100*  @end:
0417F9             0101*  
0417F9             0102*  
0417F9             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0417F9             0104*  ; MIND THE LITTLE-ENDIANESS
0417F9             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0417F9             0106*  ; outputs; nothing
0417F9             0107*  ; destroys: a might make it out alive
0417F9             0108*  vdu_set_txt_viewport:
0417F9 ED 43 0F 18 0109*      ld (@lb),bc
       04          
0417FE ED 53 11 18 0110*  	ld (@rt),de
       04          
041803 21 0E 18 04 0111*  	ld hl,@cmd
041807 01 05 00 00 0112*  	ld bc,@end-@cmd
04180B 5B DF       0113*  	rst.lil $18
04180D C9          0114*  	ret
04180E 1C          0115*  @cmd:   db 28 ; set text viewport command
04180F 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
041811 00 00       0117*  @rt: 	dw 0x0000 ; set by de
041813 00          0118*  @end:   db 0x00	  ; padding
041814             0119*  
041814             0120*  ; Wait for VBLANK interrupt
041814             0121*  vdu_vblank:
041814 DD E5       0122*      PUSH 	IX
041816             0123*  	MOSCALL	mos_sysvars
041816 3E 08       0001*M 			LD	A, function
041818 49 CF       0002*M 			RST.LIS	08h
04181A DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
04181D             0125*  @wait:
04181D DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
041820 28 FB       0127*      JR	Z, @wait
041822 DD E1       0128*      POP	IX
041824 C9          0129*      RET
041825             0130*  
041825             0131*  ; VDU 29, x; y;: Set graphics origin
041825             0132*  ; This command sets the graphics origin.
041825             0133*  ; The origin is the point on the screen where the coordinates (0,0) are located.
041825             0134*  ; inputs: bc=x0,de=y0
041825             0135*  ; outputs; nothing
041825             0136*  ; destroys: a might make it out alive
041825             0137*  vdu_set_gfx_origin:
041825 ED 43 3B 18 0138*      ld (@x0),bc
       04          
04182A ED 53 3D 18 0139*      ld (@y0),de
       04          
04182F 21 3A 18 04 0140*      ld hl,@cmd
041833 01 05 00 00 0141*      ld bc,@end-@cmd
041837 5B DF       0142*      rst.lil $18
041839 C9          0143*      ret
04183A 1D          0144*  @cmd:   db 29 ; set graphics origin command
04183B 00 00       0145*  @x0: 	dw 0x0000 ; set by bc
04183D 00 00       0146*  @y0: 	dw 0x0000 ; set by de
04183F 00          0147*  @end:   db 0x00	  ; padding
041840             0148*  
041840             0149*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
041840             0150*  ; NOTE: the order of the y-coordinate parameters are inverted
041840             0151*  ; 	because we have turned off logical screen scaling
041840             0152*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
041840             0153*  ; outputs; nothing
041840             0154*  ; destroys: a might make it out alive
041840             0155*  vdu_set_gfx_viewport:
041840 ED 43 60 18 0156*      ld (@x0),bc
       04          
041845 FD 22 62 18 0157*      ld (@y1),iy
       04          
04184A DD 22 64 18 0158*  	ld (@x1),ix
       04          
04184F ED 53 66 18 0159*  	ld (@y0),de
       04          
041854 21 5F 18 04 0160*  	ld hl,@cmd
041858 01 09 00 00 0161*  	ld bc,@end-@cmd
04185C 5B DF       0162*  	rst.lil $18
04185E C9          0163*  	ret
04185F 18          0164*  @cmd:   db 24 ; set graphics viewport command
041860 00 00       0165*  @x0: 	dw 0x0000 ; set by bc
041862 00 00       0166*  @y1: 	dw 0x0000 ; set by iy
041864 00 00       0167*  @x1: 	dw 0x0000 ; set by ix
041866 00 00       0168*  @y0: 	dw 0x0000 ; set by de
041868 00          0169*  @end:   db 0x00	  ; padding
041869             0170*  
041869             0171*  ; SCREEN MODES
041869             0172*  ; ===============================
041869             0173*  ; Mode  Horz  Vert  Cols  Refresh
041869             0174*  ; ---   ----  ----  ----  -------
041869             0175*  ; 11    320   240   2     60hz
041869             0176*  ; 139   320   240   2     60hz
041869             0177*  ; 23    512   384   2     60hz
041869             0178*  ; 151   512   384   2     60hz
041869             0179*  ; 6     640   240   2     60hz
041869             0180*  ; 134   640   240   2     60hz
041869             0181*  ; 2     640   480   2     60hz
041869             0182*  ; 130   640   480   2     60hz
041869             0183*  ; 17    800   600   2     60hz
041869             0184*  ; 145   800   600   2     60hz
041869             0185*  ; 18    1024  768   2     60hz
041869             0186*  ; 146   1024  768   2     60hz
041869             0187*  ; ---   ----  ----  ----  -------
041869             0188*  ; 10    320   240   4     60hz
041869             0189*  ; 138   320   240   4     60hz
041869             0190*  ; 22    512   384   4     60hz
041869             0191*  ; 150   512   384   4     60hz
041869             0192*  ; 5     640   240   4     60hz
041869             0193*  ; 133   640   240   4     60hz
041869             0194*  ; 1     640   480   4     60hz
041869             0195*  ; 129   640   480   4     60hz
041869             0196*  ; 16    800   600   4     60hz
041869             0197*  ; 19    1024  768   4     60hz
041869             0198*  ; ---   ----  ----  ----  -------
041869             0199*  ; 9     320   240   16    60hz
041869             0200*  ; 137   320   240   16    60hz
041869             0201*  ; 21    512   384   16    60hz
041869             0202*  ; 149   512   384   16    60hz
041869             0203*  ; 4     640   240   16    60hz
041869             0204*  ; 132   640   240   16    60hz
041869             0205*  ; 0     640   480   16    60hz
041869             0206*  ; 7     n/a   n/a   16    60hz
041869             0207*  ; ---   ----  ----  ----  -------
041869             0208*  ; 8     320   240   64    60hz
041869             0209*  ; 136   320   240   64    60hz
041869             0210*  ; 20    512   384   64    60hz
041869             0211*  ; 3     640   240   64    60hz
041869             0212*  ; ---   ----  ----  ----  -------
041869             0213*  vdu_set_screen_mode:
041869 32 79 18 04 0214*  	ld (@arg),a
04186D 21 78 18 04 0215*  	ld hl,@cmd
041871 01 02 00 00 0216*  	ld bc,@end-@cmd
041875 5B DF       0217*  	rst.lil $18
041877 C9          0218*  	ret
041878 16          0219*  @cmd: db 22 ; set screen mode
041879 00          0220*  @arg: db 0  ; screen mode parameter
04187A             0221*  @end:
04187A             0222*  
04187A             0223*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
04187A             0224*  ; inputs: a is scaling mode, 1=on, 0=off
04187A             0225*  ; note: default setting on boot is scaling ON
04187A             0226*  vdu_set_scaling:
04187A 32 8C 18 04 0227*  	ld (@arg),a
04187E 21 89 18 04 0228*  	ld hl,@cmd
041882 01 04 00 00 0229*  	ld bc,@end-@cmd
041886 5B DF       0230*  	rst.lil $18
041888 C9          0231*  	ret
041889 17 00 C0    0232*  @cmd: db 23,0,0xC0
04188C 00          0233*  @arg: db 0  ; scaling on/off
04188D             0234*  @end:
04188D             0235*  
04188D             0236*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
04188D             0237*  ; inputs: hl=bufferId
04188D             0238*  vdu_buff_select:
04188D 22 9F 18 04 0239*  	ld (@bufferId),hl
041891 21 9C 18 04 0240*  	ld hl,@cmd
041895 01 05 00 00 0241*  	ld bc,@end-@cmd
041899 5B DF       0242*  	rst.lil $18
04189B C9          0243*  	ret
04189C 17 1B 20    0244*  @cmd: db 23,27,0x20
04189F 00 00       0245*  @bufferId: dw 0x0000
0418A1 00          0246*  @end: db 0x00 ; padding
0418A2             0247*  
0418A2             0248*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0418A2             0249*  ; inputs: a=format; bc=width; de=height
0418A2             0250*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0418A2             0251*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0418A2             0252*  ; 0 	RGBA8888 (4-bytes per pixel)
0418A2             0253*  ; 1 	RGBA2222 (1-bytes per pixel)
0418A2             0254*  ; 2 	Mono/Mask (1-bit per pixel)
0418A2             0255*  ; 3 	Reserved for internal use by VDP (“native” format)
0418A2             0256*  vdu_bmp_create:
0418A2 ED 43 BE 18 0257*      ld (@width),bc
       04          
0418A7 ED 53 C0 18 0258*      ld (@height),de
       04          
0418AC 32 C2 18 04 0259*      ld (@fmt),a
0418B0 21 BB 18 04 0260*  	ld hl,@cmd
0418B4 01 08 00 00 0261*  	ld bc,@end-@cmd
0418B8 5B DF       0262*  	rst.lil $18
0418BA C9          0263*  	ret
0418BB 17 1B 21    0264*  @cmd:       db 23,27,0x21
0418BE 00 00       0265*  @width:     dw 0x0000
0418C0 00 00       0266*  @height:    dw 0x0000
0418C2 00          0267*  @fmt:       db 0x00
0418C3             0268*  @end:
0418C3             0269*  
0418C3             0270*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0418C3             0271*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0418C3             0272*  vdu_load_img_rgba2_to_8:
0418C3             0273*  ; backup the target buffer id and image dimensions
0418C3 E5          0274*      push hl
0418C4 D5          0275*      push de
0418C5 C5          0276*      push bc
0418C6             0277*  ; load the rgba2 image to working buffer 65534
0418C6 21 FE FF 00 0278*      ld hl,65534 ; temporary working buffer id
0418CA CD CD 19 04 0279*  	call vdu_load_buffer_from_file
0418CE             0280*  ; restore the image dimensions and target buffer id
0418CE C1          0281*      pop bc
0418CF D1          0282*      pop de
0418D0 E1          0283*      pop hl
0418D1             0284*  ; fall through to vdu_rgba2_to_8
0418D1             0285*  
0418D1             0286*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0418D1             0287*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0418D1             0288*  ; the "expand bitmap" command is:
0418D1             0289*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0418D1             0290*  ; and then to reverse the byte order to fix endian-ness:
0418D1             0291*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0418D1             0292*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0418D1             0293*  ; VDU 23,27,&20,targetBufferID%;
0418D1             0294*  ; VDU 23,27,&21,width%;height%;0
0418D1             0295*  ; -------------------------------------------------------------------
0418D1             0296*  ; inputs: bc,de image width,height ; hl = targetBufferId
0418D1             0297*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0418D1             0298*  vdu_rgba2_to_8:
0418D1             0299*  ; load the image dimensions and buffer id parameters
0418D1 ED 43 2D 19 0300*      ld (@width),bc
       04          
0418D6 ED 53 2F 19 0301*      ld (@height),de
       04          
0418DB 22 12 19 04 0302*      ld (@bufferId0),hl
0418DF 22 1F 19 04 0303*      ld (@bufferId2),hl
0418E3 22 28 19 04 0304*      ld (@bufferId1),hl
0418E7             0305*  ; clean up bytes that got stomped on by the ID loads
0418E7 3E 48       0306*      ld a,0x48
0418E9 32 14 19 04 0307*      ld (@bufferId0+2),a
0418ED 3E 17       0308*      ld a,23
0418EF 32 2A 19 04 0309*      ld (@bufferId1+2),a
0418F3 3E 18       0310*      ld a,24
0418F5 32 21 19 04 0311*      ld (@bufferId2+2),a
0418F9 AF          0312*      xor a
0418FA 32 31 19 04 0313*      ld (@height+2),a
0418FE             0314*  ; send the vdu command strings
0418FE 21 09 19 04 0315*      ld hl,@beg
041902 01 29 00 00 0316*      ld bc,@end-@beg
041906 5B DF       0317*      rst.lil $18
041908 C9          0318*      ret
041909             0319*  @beg:
041909             0320*  ; Command 14: Consolidate blocks in a buffer
041909             0321*  ; VDU 23, 0, &A0, bufferId; 14
041909 17 00 A0    0322*      db 23,0,0xA0
04190C FE FF       0323*      dw 65534 ; workingBufferId
04190E 0E          0324*      db 14 ; consolidate blocks
04190F             0325*  ; the "expand bitmap" command is:
04190F             0326*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
04190F 17 00 A0    0327*      db 23,0,0xA0
041912 00 00       0328*  @bufferId0: dw 0x0000 ; targetBufferId
041914 48          0329*      db 0x48 ; given as decimal command 72 in the docs
041915 02          0330*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
041916 FE FF       0331*      dw 65534 ; sourceBufferId
041918 00 7F BF FF 0332*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
04191C             0333*  ; reverse the byte order to fix endian-ness:
04191C             0334*  ; Command 24: Reverse the order of data of blocks within a buffer
04191C             0335*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
04191C             0336*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
04191C 17 00 A0    0337*      db 23,0,0xA0
04191F 00 00       0338*  @bufferId2:    dw 0x0000 ; targetBufferId
041921 18          0339*      db 24 ; reverse byte order
041922 04          0340*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
041923 04 00       0341*      dw 4 ; size (4 bytes)
041925             0342*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041925             0343*  ; VDU 23,27,&20,targetBufferID%;
041925 17 1B 20    0344*      db 23,27,0x20 ; select bitmap
041928 00 00       0345*  @bufferId1: dw 0x0000 ; targetBufferId
04192A             0346*  ; VDU 23,27,&21,width%;height%;0
04192A 17 1B 21    0347*      db 23,27,0x21 ; create bitmap from buffer
04192D 00 00       0348*  @width: dw 0x0000
04192F 00 00       0349*  @height: dw 0x0000
041931 00          0350*      db 0x00 ; rgba8888 format
041932             0351*  @end:
041932             0352*  
041932             0353*  ; scratch variables
041932 00 00 00    0354*  bufferId0: dl 0x000000
041935 00 00 00    0355*  bufferId1: dl 0x000000
041938             0356*  
041938             0357*  ; load a vdu buffer from local memory
041938             0358*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041938             0359*  vdu_load_buffer:
041938 ED 43 61 19 0360*      ld (@length),bc
       04          
04193D D5          0361*      push de ; save data pointer
04193E             0362*  ; send the vdu command string
04193E 7D          0363*      ld a,l
04193F 32 5E 19 04 0364*      ld (@bufferId),a
041943 7C          0365*      ld a,h
041944 32 5F 19 04 0366*      ld (@bufferId+1),a
041948 21 5B 19 04 0367*      ld hl,@cmd
04194C 01 08 00 00 0368*      ld bc,@end-@cmd
041950 5B DF       0369*      rst.lil $18
041952             0370*  ; send the buffer data
041952 E1          0371*      pop hl ; pointer to data
041953 ED 4B 61 19 0372*      ld bc,(@length)
       04          
041958 5B DF       0373*      rst.lil $18 ; send it
04195A C9          0374*      ret
04195B             0375*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
04195B 17 00 A0    0376*  @cmd:       db 23,0,0xA0
04195E 00 00       0377*  @bufferId:	dw 0x0000
041960 00          0378*  		    db 0 ; load buffer
041961 00 00       0379*  @length:	dw 0x0000
041963 00          0380*  @end: db 0 ; padding
041964             0381*  
041964             0382*  ; clear a buffer
041964             0383*  ; inputs: hl = bufferId
041964             0384*  vdu_clear_buffer:
041964 7D          0385*      ld a,l
041965 32 7C 19 04 0386*      ld (@bufferId),a
041969 7C          0387*      ld a,h
04196A 32 7D 19 04 0388*      ld (@bufferId+1),a
04196E 21 79 19 04 0389*      ld hl,@cmd
041972 01 06 00 00 0390*      ld bc,@end-@cmd
041976 5B DF       0391*      rst.lil $18
041978 C9          0392*      ret
041979 17 00 A0    0393*  @cmd:       db 23,0,0xA0
04197C 00 00       0394*  @bufferId:	dw 0x0000
04197E 02          0395*  		    db 2 ; clear buffer
04197F             0396*  @end:
04197F             0397*  
04197F             0398*  vdu_clear_all_buffers:
04197F             0399*  ; clear all buffers
04197F 21 8A 19 04 0400*      ld hl,@beg
041983 01 06 00 00 0401*      ld bc,@end-@beg
041987 5B DF       0402*      rst.lil $18
041989 C9          0403*      ret
04198A 17 00 A0    0404*  @beg: db 23,0,$A0
04198D FF FF       0405*        dw -1 ; clear all buffers
04198F 02          0406*        db 2  ; command 2: clear a buffer
041990             0407*  @end:
041990             0408*  
041990             0409*  ; Command 14: Consolidate blocks in a buffer
041990             0410*  vdu_consolidate_buffer:
041990             0411*  ; set parameters for vdu call
041990 7D          0412*      ld a,l
041991 32 A8 19 04 0413*      ld (@bufferId),a
041995 7C          0414*      ld a,h
041996 32 A9 19 04 0415*      ld (@bufferId+1),a
04199A 21 A5 19 04 0416*      ld hl,@beg
04199E 01 06 00 00 0417*      ld bc,@end-@beg
0419A2 5B DF       0418*      rst.lil $18
0419A4 C9          0419*      ret
0419A5             0420*  ; VDU 23, 0, &A0, bufferId; 14
0419A5 17 00 A0    0421*  @beg: db 23,0,0xA0
0419A8 00 00       0422*  @bufferId: dw 0x0000
0419AA 0E          0423*             db 14
0419AB             0424*  @end:
0419AB             0425*  
0419AB             0426*  ; load an image file to a buffer and make it a bitmap
0419AB             0427*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0419AB             0428*  vdu_load_img:
0419AB             0429*  ; back up image type and dimension parameters
0419AB 22 32 19 04 0430*      ld (bufferId0),hl
0419AF F5          0431*      push af
0419B0 C5          0432*  	push bc
0419B1 D5          0433*  	push de
0419B2             0434*  ; load the image
0419B2 CD CD 19 04 0435*  	call vdu_load_buffer_from_file
0419B6             0436*  ; now make it a bitmap
0419B6 2A 32 19 04 0437*      ld hl,(bufferId0)
0419BA CD 90 19 04 0438*      call vdu_consolidate_buffer
0419BE 2A 32 19 04 0439*      ld hl,(bufferId0)
0419C2 CD 8D 18 04 0440*      call vdu_buff_select
0419C6 D1          0441*  	pop de ; image height
0419C7 C1          0442*  	pop bc ; image width
0419C8 F1          0443*  	pop af ; image type
0419C9 C3 A2 18 04 0444*  	jp vdu_bmp_create ; will return to caller from there
0419CD             0445*  
0419CD             0446*  ; inputs: hl = bufferId; iy = pointer to filename
0419CD             0447*  vdu_load_buffer_from_file:
0419CD 22 32 19 04 0448*      ld (bufferId0),hl
0419D1             0449*  
0419D1             0450*  ; clear target buffer
0419D1 CD 64 19 04 0451*      call vdu_clear_buffer
0419D5             0452*  
0419D5             0453*  ; open the file in read mode
0419D5             0454*  ; Open a file
0419D5             0455*  ; HLU: Filename
0419D5             0456*  ;   C: Mode
0419D5             0457*  ; Returns:
0419D5             0458*  ;   A: Filehandle, or 0 if couldn't open
0419D5 FD E5       0459*  	push iy ; pointer to filename
0419D7 E1          0460*  	pop hl
0419D8 0E 01       0461*  	ld c,fa_read
0419DA             0462*      MOSCALL mos_fopen
0419DA 3E 0A       0001*M 			LD	A, function
0419DC 49 CF       0002*M 			RST.LIS	08h
0419DE 32 19 1A 04 0463*      ld (@filehandle),a
0419E2             0464*  
0419E2             0465*  @read_file:
0419E2             0466*  ; Read a block of data from a file
0419E2             0467*  ;   C: Filehandle
0419E2             0468*  ; HLU: Pointer to where to write the data to
0419E2             0469*  ; DEU: Number of bytes to read
0419E2             0470*  ; Returns:
0419E2             0471*  ; DEU: Number of bytes read
0419E2 3A 19 1A 04 0472*      ld a,(@filehandle)
0419E6 4F          0473*      ld c,a
0419E7 21 00 E0 B7 0474*      ld hl,filedata
0419EB 11 00 20 00 0475*      ld de,8192 ; max we can read into onboard sram at one time
0419EF             0476*      MOSCALL mos_fread
0419EF 3E 1A       0001*M 			LD	A, function
0419F1 49 CF       0002*M 			RST.LIS	08h
0419F3             0477*  
0419F3             0478*  ; ; DEBUG: print chunk size
0419F3             0479*  ;     push de
0419F3             0480*  ;     pop hl
0419F3             0481*  ;     call printDec
0419F3             0482*  ;     call printNewLine
0419F3             0483*  
0419F3             0484*  ; test de for zero bytes read
0419F3 21 00 00 00 0485*      ld hl,0
0419F7 AF          0486*      xor a ; clear carry
0419F8 ED 52       0487*      sbc hl,de
0419FA CA 10 1A 04 0488*      jp z,@close_file
0419FE             0489*  
0419FE             0490*  ; load a vdu buffer from local memory
0419FE             0491*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0419FE 2A 32 19 04 0492*      ld hl,(bufferId0)
041A02 D5          0493*      push de ; chunksize
041A03 C1          0494*      pop bc
041A04 11 00 E0 B7 0495*      ld de,filedata
041A08 CD 38 19 04 0496*      call vdu_load_buffer
041A0C             0497*  
041A0C             0498*  ; ; print progress breadcrumbs
041A0C             0499*  ;     ld a,'.'
041A0C             0500*  ;     rst.lil 10h
041A0C             0501*  
041A0C             0502*  ; read the next block
041A0C C3 E2 19 04 0503*      jp @read_file
041A10             0504*  
041A10             0505*  ; close the file
041A10             0506*  @close_file:
041A10 3A 19 1A 04 0507*      ld a,(@filehandle)
041A14             0508*      MOSCALL mos_fclose
041A14 3E 0B       0001*M 			LD	A, function
041A16 49 CF       0002*M 			RST.LIS	08h
041A18 C9          0509*      ret ; vdu_load_buffer_from_file
041A19             0510*  
041A19 00          0511*  @filehandle: db 0 ; file handle
041A1A 00 00 00    0512*  @fil: dl 0 ; pointer to FIL struct
041A1D             0513*  
041A1D 00 00 00    0514*  @chunkpointer: dl 0 ; pointer to current chunk
041A20             0515*  
041A20             0516*  ; File information structure (FILINFO)
041A20             0517*  @filinfo:
041A20 00 00 00 00 0518*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041A24 00 00       0519*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041A26 00 00       0520*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041A28 00          0521*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041A29 00 00 00 00 0522*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041A36 00 00 00 00 0523*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041B36             0048       include "parse_args.inc"
041B36             0001*  ; Parse the parameter string into a C array
041B36             0002*  ; Parameters
041B36             0003*  ; - HL: Address of parameter string
041B36             0004*  ; - IX: Address for array pointer storage
041B36             0005*  ; Returns:
041B36             0006*  ; -  C: Number of parameters parsed
041B36             0007*  ;
041B36 01 04 00 04 0008*  _parse_params:		LD	BC, _exec_name
041B3A DD 0F 00    0009*  			LD	(IX+0), BC		; ARGV[0] = the executable name
041B3D ED 32 03    0010*  			LEA     IX, IX+3
041B40 CD 78 1B 04 0011*  			CALL	_skip_spaces		; Skip HL past any leading spaces
041B44             0012*  ;
041B44 01 01 00 00 0013*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
041B48 06 0F       0014*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
041B4A             0015*  ;
041B4A             0016*  _parse_params_1:
041B4A C5          0017*  			PUSH	BC			; Stack ARGC
041B4B E5          0018*  			PUSH	HL			; Stack start address of token
041B4C CD 69 1B 04 0019*  			CALL	_get_token		; Get the next token
041B50 79          0020*  			LD	A, C			; A: Length of the token in characters
041B51 D1          0021*  			POP	DE			; Start address of token (was in HL)
041B52 C1          0022*  			POP	BC			; ARGC
041B53 B7          0023*  			OR	A			; Check for A=0 (no token found) OR at end of string
041B54 C8          0024*  			RET	Z
041B55             0025*  ;
041B55 DD 1F 00    0026*  			LD	(IX+0), DE		; Store the pointer to the token
041B58 E5          0027*  			PUSH	HL			; DE=HL
041B59 D1          0028*  			POP	DE
041B5A CD 78 1B 04 0029*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
041B5E AF          0030*  			XOR	A
041B5F 12          0031*  			LD	(DE), A			; Zero-terminate the token
041B60 ED 32 03    0032*  			LEA  	IX, IX+3			; Advance to next pointer position
041B63 0C          0033*  			INC	C			; Increment ARGC
041B64 79          0034*  			LD	A, C			; Check for C >= A
041B65 B8          0035*  			CP	B
041B66 38 E2       0036*  			JR	C, _parse_params_1	; And loop
041B68 C9          0037*  			RET
041B69             0038*  
041B69             0039*  ; Get the next token
041B69             0040*  ; Parameters:
041B69             0041*  ; - HL: Address of parameter string
041B69             0042*  ; Returns:
041B69             0043*  ; - HL: Address of first character after token
041B69             0044*  ; -  C: Length of token (in characters)
041B69             0045*  ;
041B69 0E 00       0046*  _get_token:		LD	C, 0			; Initialise length
041B6B 7E          0047*  @@:			LD	A, (HL)			; Get the character from the parameter string
041B6C B7          0048*  			OR	A			; Exit if 0 (end of parameter string in MOS)
041B6D C8          0049*  			RET 	Z
041B6E FE 0D       0050*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
041B70 C8          0051*  			RET	Z
041B71 FE 20       0052*  			CP	' '			; Exit if space (end of token)
041B73 C8          0053*  			RET	Z
041B74 23          0054*  			INC	HL			; Advance to next character
041B75 0C          0055*  			INC 	C			; Increment length
041B76 18 F3       0056*  			JR	@B
041B78             0057*  
041B78             0058*  ; Skip spaces in the parameter string
041B78             0059*  ; Parameters:
041B78             0060*  ; - HL: Address of parameter string
041B78             0061*  ; Returns:
041B78             0062*  ; - HL: Address of next none-space character
041B78             0063*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
041B78             0064*  ;
041B78 7E          0065*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
041B79 FE 20       0066*  			CP	' '			; Exit if not space
041B7B C0          0067*  			RET	NZ
041B7C 23          0068*  			INC	HL			; Advance to next character
041B7D 18 F9       0069*  			JR	_skip_spaces		; Increment length
041B7F             0070*  
041B7F             0071*  ; Storage for the argv array pointers
041B7F             0072*  min_args: equ 1
041B7F             0073*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
041B7F 00 00 00 00 0074*  argv_ptrs:		    BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041BAF             0075*  _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
041BB2             0076*  
041BB2             0077*  ; begin BASIC-specific end code
041BB2             0078*  ; This bit of code is called from STAR_BYE and returns us safely to MOS
041BB2 ED 7B AF 1B 0079*  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
041BB7             0080*  ; fall through to _main_end_ok
041BB7             0081*  ; end BASIC-specific end code
041BB7             0082*  
041BB7             0083*  ; ========== HELPER FUNCTIONS ==========
041BB7             0084*  ;
041BB7             0085*  ; get the next argument after ix as a floating point number
041BB7             0086*  ; inputs: ix = pointer to the argument string
041BB7             0087*  ; outputs: HLH'L'C = floating point number, ix points to the next argument
041BB7             0088*  ; destroys: everything except iy, including prime registers
041BB7             0089*  get_arg_float:
041BB7 ED 32 03    0090*      lea ix,ix+3 ; point to the next argument
041BBA DD E5       0091*      push ix ; preserve
041BBC DD 37 00    0092*      ld ix,(ix)  ; point to argument string
041BBF CD 55 15 04 0093*      call val_fp ; convert the string to a float
041BC3 DD E1       0094*      pop ix ; restore
041BC5 C9          0095*      ret ; return with the value in HLH'L'C
041BC6             0096*  
041BC6             0097*  ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
041BC6             0098*  ; inputs: ix = pointer to the argument string
041BC6             0099*  ; outputs: HLH'L'C = floating point number, ix points to the next argument
041BC6             0100*  ; destroys: everything except iy, including prime registers
041BC6             0101*  store_arg_iy_float:
041BC6 ED 32 03    0102*      lea ix,ix+3 ; point to the next argument
041BC9 DD E5       0103*      push ix ; preserve
041BCB DD 37 00    0104*      ld ix,(ix)  ; point to argument string
041BCE CD 55 15 04 0105*      call val_fp ; convert the string to a float
041BD2 CD 40 16 04 0106*      call store_float_iy_nor ; save the float in buffer
041BD6 DD E1       0107*      pop ix ; restore
041BD8 C9          0108*      ret ; return with the value in HLH'L'C
041BD9             0049   
041BD9             0050   init:
041BD9             0051   ; ========================================
041BD9             0052   ; BASIC INITIALIZATION CODE FROM basic/init.asm
041BD9             0053   ; ========================================
041BD9             0054   ;
041BD9             0055   ;Clear the application memory
041BD9             0056   ;
041BD9             0057   _clear_ram:
041BD9 E5          0058       push hl
041BDA C5          0059       PUSH		BC
041BDB 21 00 20 04 0060       LD		HL, RAM_START
041BDF 11 01 20 04 0061       LD		DE, RAM_START + 1
041BE3 01 4F 03 00 0062       LD		BC, RAM_END - RAM_START - 1
041BE7 AF          0063       XOR		A
041BE8 77          0064       LD		(HL), A
041BE9 ED B0       0065       LDIR
041BEB C1          0066       POP		BC
041BEC E1          0067       pop hl
041BED             0068   
041BED             0069   ; initialization done
041BED C9          0070       RET
041BEE             0071   
041BEE             0072   ; ========================================
041BEE             0073   ; MAIN PROGRAM
041BEE             0074   ; ========================================
041BEE             0075   ; ---- input arguments (float) ----
041BEE             0076   input_params_num: equ 8
041BEE             0077   input_params:
041BEE 81 1E 85 EB 0078   petals:             db   0x81, 0x1E, 0x85, 0xEB, 0x41 ; 3.03
       41          
041BF3 80 D7 A3 70 0079   vectors:            db   0x80, 0xD7, 0xA3, 0x70, 0x7D ; 1.98
       7D          
041BF8 7F 99 99 99 0080   depth:              db   0x7F, 0x99, 0x99, 0x99, 0x19 ; 0.6
       19          
041BFD 86 00 00 00 0081   periods:            db   0x86, 0x00, 0x00, 0x00, 0x04 ; 66
       04          
041C02 7F CC CC CC 0082   shrink:             db   0x7F, 0xCC, 0xCC, 0xCC, 0x4C ; 0.8
       4C          
041C07 88 00 00 00 0083   radius_scale: 	    db   0x88, 0x00, 0x00, 0x00, 0x00 ; 256
       00          
041C0C 00 00 00 00 0084   theta_init: 	    db   0x00, 0x00, 0x00, 0x00, 0x00 ; 0
       00          
041C11 00 00 00 00 0085   loops: blkb 5,0 ; starts as float, but will be converted to int
       00          
041C16             0086   
041C16 00 00 00 00 0087   target_params: blkb input_params_num*5,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041C3E             0088   
041C3E             0089   ; ---- amount to increment each parameter each loop (float) ----
041C3E             0090   inc_params:
041C3E 00 00 00 00 0091   petals_inc: blkb 5,0
       00          
041C43 00 00 00 00 0092   vectors_inc: blkb 5,0
       00          
041C48 00 00 00 00 0093   depth_inc: blkb 5,0
       00          
041C4D 00 00 00 00 0094   periods_inc: blkb 5,0
       00          
041C52 00 00 00 00 0095   shrink_inc: blkb 5,0
       00          
041C57 00 00 00 00 0096   radius_scale_inc: blkb 5,0
       00          
041C5C 00 00 00 00 0097   theta_init_inc: blkb 5,0
       00          
041C61             0098   
041C61 09 00       0099   G9: DW 9 ; format code for converting floats to strings
041C63             0100   
041C63             0101   ; ---- list of input arguments to cycle through ----
041C63 69 1C 04    0102   cur_sample: dl samples ; address of the current sample
041C66 69 1C 04    0103   next_sample: dl samples ; address of the next sample
041C69             0104   samples:
041C69 33 20 34 20 0105       asciz "3 4 .5 30 1 320 0 10"
       2E 35 20 33 
       30 20 31 20 
       33 32 30 20 
       30 20 31 30 
       00          
041C7E 33 20 34 20 0106       asciz "3 4 .5 30 -320 1 0 10"
       2E 35 20 33 
       30 20 2D 33 
       32 30 20 31 
       20 30 20 31 
       30 00       
041C94             0107   
041C94 34 20 35 20 0108       asciz "4 5 .5 30 1 320 0 10"
       2E 35 20 33 
       30 20 31 20 
       33 32 30 20 
       30 20 31 30 
       00          
041CA9 34 20 35 20 0109       asciz "4 5 .5 30 -320 1 0 10"
       2E 35 20 33 
       30 20 2D 33 
       32 30 20 31 
       20 30 20 31 
       30 00       
041CBF             0110   
041CBF 35 20 35 20 0111       asciz "5 5 .5 30 1 320 0 10"
       2E 35 20 33 
       30 20 31 20 
       33 32 30 20 
       30 20 31 30 
       00          
041CD4 35 20 35 20 0112       asciz "5 5 .5 30 -320 1 0 10"
       2E 35 20 33 
       30 20 2D 33 
       32 30 20 31 
       20 30 20 31 
       30 00       
041CEA             0113   
041CEA 36 20 35 20 0114       asciz "6 5 .5 30 1 320 0 10"
       2E 35 20 33 
       30 20 31 20 
       33 32 30 20 
       30 20 31 30 
       00          
041CFF 36 20 35 20 0115       asciz "6 5 .5 30 -320 1 0 10"
       2E 35 20 33 
       30 20 2D 33 
       32 30 20 31 
       20 30 20 31 
       30 00       
041D15             0116   
041D15 37 20 35 2E 0117       asciz "7 5.01 0.5 50 1 320 90 10"
       30 31 20 30 
       2E 35 20 35 
       30 20 31 20 
       33 32 30 20 
       39 30 20 31 
       30 00       
041D2F 37 20 35 2E 0118       asciz "7 5.01 0.5 50 -320 1 90 10"
       30 31 20 30 
       2E 35 20 35 
       30 20 2D 33 
       32 30 20 31 
       20 39 30 20 
       31 30 00    
041D4A             0119   
041D4A 33 2E 30 33 0120       asciz "3.03 1.98 .6 66 .8 320 90 10"
       20 31 2E 39 
       38 20 2E 36 
       20 36 36 20 
       2E 38 20 33 
       32 30 20 39 
       30 20 31 30 
       00          
041D67 33 2E 30 33 0121       asciz "3.03 1.98 .6 66 -320 .8 90 10"
       20 31 2E 39 
       38 20 2E 36 
       20 36 36 20 
       2D 33 32 30 
       20 2E 38 20 
       39 30 20 31 
       30 00       
041D85             0122   
041D85 32 2E 35 20 0123       asciz "2.5 1.001 1 500 1 320 90 10"
       31 2E 30 30 
       31 20 31 20 
       35 30 30 20 
       31 20 33 32 
       30 20 39 30 
       20 31 30 00 
041DA1 32 2E 35 20 0124       asciz "2.5 1.001 1 500 -320 1 90 10"
       31 2E 30 30 
       31 20 31 20 
       35 30 30 20 
       2D 33 32 30 
       20 31 20 39 
       30 20 31 30 
       00          
041DBE             0125   
041DBE 00 00 00    0126       dl 0 ; list terminator
041DC1             0127   
041DC1             0128   main:
041DC1             0129   ; set up the display
041DC1 3E 12       0130       ld a,18;+128 ; 146   1024  768   2     60hz  double-buffered
041DC3 CD 69 18 04 0131       call vdu_set_screen_mode
041DC7             0132   
041DC7             0133   ; set the cursor off
041DC7 CD 92 17 04 0134   	call cursor_off
041DCB             0135   
041DCB             0136   main_loop:
041DCB             0137   ; prepare to read the parameter string
041DCB 11 9C 1E 04 0138       ld de,command1
041DCF 2A 63 1C 04 0139       ld hl,(cur_sample)
041DD3 7E          0140       ld a,(hl)
041DD4 B7          0141       or a
041DD5 C2 E1 1D 04 0142       jp nz,@loop ; not at end of list so proceed
041DD9 21 69 1C 04 0143       ld hl,samples ;loop back to beginning of list
041DDD 22 63 1C 04 0144       ld (cur_sample),hl
041DE1             0145   
041DE1             0146   @loop:
041DE1             0147   ; copy the orginal string to the command buffer since _parse_params zero-terminates each token
041DE1 7E          0148       ld a,(hl)
041DE2 12          0149       ld (de),a
041DE3 23          0150       inc hl
041DE4 13          0151       inc de
041DE5 B7          0152       or a
041DE6 C2 E1 1D 04 0153       jp nz,@loop
041DEA             0154       ; inc hl            ; point to the next sample
041DEA 22 66 1C 04 0155       ld (next_sample),hl ; and store it
041DEE             0156   
041DEE             0157   ; parse the parameters
041DEE 21 9C 1E 04 0158       ld hl,command1
041DF2 DD 21 7F 1B 0159       LD IX,argv_ptrs		; The argv array pointer address
       04          
041DF7 DD E5       0160       PUSH IX
041DF9 CD 36 1B 04 0161       CALL _parse_params	; Parse the parameters
041DFD DD E1       0162       POP IX
041DFF             0163   
041DFF             0164   ; convert the strings to floats and store them in the input_params table
041DFF FD 21 EE 1B 0165       ld iy,input_params
       04          
041E04 CD 78 1E 04 0166       call load_input
041E08             0167   
041E08             0168   ; convert the loaded values back into strings and assemble the final command string
041E08 06 08       0169       ld b,input_params_num ; loop counter
041E0A FD 21 EE 1B 0170       ld iy,input_params  ; point to the parameter values table
       04          
041E0F DD 21 9C 1E 0171       ld ix,command1      ; point to the command string buffer
       04          
041E14             0172   @loop0:
041E14 C5          0173       push bc             ; save the loop counter
041E15 FD E5       0174       push iy             ; save the parameter pointer
041E17 DD E5       0175       push ix             ; save the command string pointer
041E19 CD 52 16 04 0176       call fetch_float_iy_nor
041E1D 11 00 20 04 0177       ld de,ACCS          ; point to the string accumulator
041E21 DD 21 60 1C 0178       ld ix,G9-1          ; get the format code for the number
       04          
041E26 CD 5F 08 04 0179       call STR_FP         ; convert the number to a string
041E2A EB          0180       ex de,hl            ; point to end of the string
041E2B 36 00       0181       ld (hl),0           ; null-terminate the string
041E2D 21 00 20 04 0182       ld hl,ACCS          ; point to the string accumulator
041E31 DD E1       0183       pop ix             ; get back the command string pointer
041E33             0184   @loop1:
041E33 7E          0185       ld a,(hl)           ; get a character
041E34 DD 77 00    0186       ld (ix),a           ; store it
041E37 23          0187       inc hl              ; point to the next character
041E38 ED 32 01    0188       lea ix,ix+1         ; point to the next character
041E3B B7          0189       or a                ; check for end of string
041E3C 20 F5       0190       jr nz,@loop1        ; loop until done
041E3E             0191   
041E3E 3E 20       0192       ld a,' '            ; overwrite the null with a space ...
041E40 DD 77 FF    0193       ld (ix-1),a         ; ... in case we're not at the end
041E43 FD E1       0194       pop iy              ; get back the parameter pointer
041E45 ED 33 05    0195       lea iy,iy+5         ; point to the next parameter
041E48 C1          0196       pop bc              ; get back the loop counter
041E49 10 C9       0197       djnz @loop0         ; loop until done
041E4B             0198   
041E4B AF          0199       xor a
041E4C DD 77 00    0200       ld (ix),a           ; now null-terminate the command string
041E4F             0201   
041E4F             0202   ; draw the flower
041E4F CD 86 1E 04 0203       call draw_flower
041E53             0204   
041E53             0205   ; flip the screen
041E53 CD BE 17 04 0206   	call vdu_flip
041E57             0207   
041E57             0208   ; bump pointer to the next sample
041E57 2A 66 1C 04 0209       ld hl,(next_sample)
041E5B 22 63 1C 04 0210       ld (cur_sample),hl
041E5F             0211   
041E5F             0212   ; check for escape key and quit if pressed
041E5F             0213   	MOSCALL mos_getkbmap
041E5F 3E 1E       0001M  			LD	A, function
041E61 49 CF       0002M  			RST.LIS	08h
041E63             0214   ; 113 Escape
041E63 DD CB 0E 46 0215       bit 0,(ix+14)
041E67 20 04       0216   	jr nz,main_end
041E69             0217   @Escape:
041E69 C3 CB 1D 04 0218   	jp main_loop
041E6D             0219   
041E6D             0220   main_end:
041E6D             0221   ; restore screen to something normalish
041E6D 3E 14       0222       ld a,20 ; 20    512   384   64    60hz  single-buffered
041E6F CD 69 18 04 0223   	call vdu_set_screen_mode
041E73 CD 84 17 04 0224   	call cursor_on
041E77 C9          0225   	ret
041E78             0226   
041E78             0227   ; inputs: ix points to the start of the argument pointers
041E78             0228   ;         iy points to the start of the parameter values table
041E78             0229   load_input:
041E78 06 08       0230       ld b,input_params_num ; loop counter
041E7A             0231   @loop:
041E7A C5          0232       push bc ; save the loop counter
041E7B CD C6 1B 04 0233       call store_arg_iy_float ; get the next argument and store it
041E7F ED 33 05    0234       lea iy,iy+5  ; point to the next parameter
041E82 C1          0235       pop bc ; get back the loop counter
041E83 10 F5       0236       djnz @loop ; loop until done
041E85 C9          0237       ret
041E86             0238   
041E86             0239   draw_flower:
041E86 21 95 1E 04 0240       ld hl,command0
041E8A             0241       MOSCALL mos_oscli
041E8A 3E 10       0001M  			LD	A, function
041E8C 49 CF       0002M  			RST.LIS	08h
041E8E 3E 20       0242       ld a,' ' ; restore the space after "flower" since mos_oscli
041E90 32 9B 1E 04 0243       ld (command1-1),a ; annoyingly null-terminates each argument
041E94 C9          0244       ret
041E95             0245   
041E95             0246   ; @command: asciz "flower 3.93 1.98 .6 66 .8 320 90"
041E95 66 6C 6F 77 0247   command0: db "flower "
       65 72 20    
041E9C 00 00 00 00 0248   command1: blkb 256-7,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00          
041F95             0249   
041F95             0250       include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
041F95             0001*  ;
041F95             0002*  ; Title:	BBC Basic Interpreter - Z80 version
041F95             0003*  ;		RAM Module for BBC Basic Interpreter
041F95             0004*  ;		For use with Version 2.0 of BBC BASIC
041F95             0005*  ;		Standard CP/M Distribution Version
041F95             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
041F95             0007*  ; Modified By:	Dean Belfield
041F95             0008*  ; Created:	12/05/2023
041F95             0009*  ; Last Updated:	26/06/2023
041F95             0010*  ;
041F95             0011*  ; Modinfo:
041F95             0012*  ; 06/06/2023:	Modified to run in ADL mode
041F95             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
041F95             0014*  
041F95             0015*  			; .ASSUME	ADL = 1
041F95             0016*  
041F95             0017*  			; DEFINE	LORAM, SPACE = ROM
041F95             0018*  			; SEGMENT LORAM
041F95             0019*  
041F95             0020*  			; XDEF	ACCS
041F95             0021*  			; XDEF	BUFFER
041F95             0022*  			; XDEF	STAVAR
041F95             0023*  			; XDEF	DYNVAR
041F95             0024*  			; XDEF	FNPTR
041F95             0025*  			; XDEF	PROPTR
041F95             0026*  			; XDEF	PAGE_
041F95             0027*  			; XDEF	TOP
041F95             0028*  			; XDEF	LOMEM
041F95             0029*  			; XDEF 	FREE
041F95             0030*  			; XDEF	HIMEM
041F95             0031*  			; XDEF	LINENO
041F95             0032*  			; XDEF	TRACEN
041F95             0033*  			; XDEF	AUTONO
041F95             0034*  			; XDEF	ERRTRP
041F95             0035*  			; XDEF	ERRTXT
041F95             0036*  			; XDEF	DATPTR
041F95             0037*  			; XDEF	ERL
041F95             0038*  			; XDEF	ERRLIN
041F95             0039*  			; XDEF	RANDOM
041F95             0040*  			; XDEF	COUNT
041F95             0041*  			; XDEF	WIDTH
041F95             0042*  			; XDEF	ERR
041F95             0043*  			; XDEF	LISTON
041F95             0044*  			; XDEF	INCREM
041F95             0045*  
041F95             0046*  			; XDEF	FLAGS
041F95             0047*  			; XDEF	OSWRCHPT
041F95             0048*  			; XDEF	OSWRCHCH
041F95             0049*  			; XDEF	OSWRCHFH
041F95             0050*  			; XDEF	KEYDOWN
041F95             0051*  			; XDEF	KEYASCII
041F95             0052*  			; XDEF	KEYCOUNT
041F95             0053*  
041F95             0054*  			; XDEF	R0
041F95             0055*  			; XDEF	R1
041F95             0056*  
041F95             0057*  			; XDEF	RAM_START
041F95             0058*  			; XDEF	RAM_END
041F95             0059*  			; XDEF	USER
041F95             0060*  
041F95             0061*  end_binary: ;  for assemble.py to know where to truncate the binary file
041F95 FF FF FF FF 0062*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF    
042000             0063*  RAM_START:
042000             0064*  ;
042000 00 00 00 00 0065*  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042100 00 00 00 00 0066*  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042200 00 00 00 00 0067*  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04226C 00 00 00 00 0068*  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
04230E 00 00 00    0069*  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
042311 00 00 00    0070*  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
042314             0071*  ;
042314 00 00 00    0072*  PAGE_:          BLKB    3,0               ; Start of User Program
042317 00 00 00    0073*  TOP:            BLKB    3,0               ; First Location after User Program
04231A 00 00 00    0074*  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
04231D 00 00 00    0075*  FREE:           BLKB    3,0               ; First Free Space Byte
042320 00 00 00    0076*  HIMEM:          BLKB    3,0               ; First Protected Byte
042323             0077*  ;
042323 00 00 00    0078*  LINENO:         BLKB    3,0               ; Line Number
042326 00 00 00    0079*  TRACEN:         BLKB    3,0               ; Trace Flag
042329 00 00 00    0080*  AUTONO:         BLKB    3,0               ; Auto Flag
04232C 00 00 00    0081*  ERRTRP:         BLKB    3,0               ; Error Trap
04232F 00 00       0082*  ERRTXT:         BLKB    2,0               ; Error Message Pointer
042331 00 00       0083*  DATPTR:         BLKB    2,0               ; Data Pointer
042333 00 00       0084*  ERL:            BLKB    2,0               ; Error Line
042335 00 00 00    0085*  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
042338 00 00 00 00 0086*  RANDOM:         BLKB    5,0               ; Random Number
       00          
04233D 00          0087*  COUNT:          BLKB    1,0               ; Print Position
04233E 00          0088*  WIDTH:          BLKB    1,0               ; Print Width
04233F 00          0089*  ERR:            BLKB    1,0               ; Error Number
042340 00          0090*  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
042341             0091*                                  ; - BIT 0: If set, output a space after the line number
042341             0092*                                  ; - BIT 1: If set, then indent FOR/NEXT loops
042341             0093*                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
042341             0094*                                  ; - BIT 3: If set, then output to buffer for *EDIT
042341             0095*                                  ; OPT FLAG (top nibble)
042341             0096*                                  ; - BIT 4: If set, then list whilst assembling
042341             0097*                                  ; - BIT 5: If set, then assembler errors are reported
042341             0098*                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
042341             0099*                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
042341 00          0100*  INCREM:         BLKB    1,0               ; Auto-Increment Value
042342             0101*  ;
042342             0102*  ; --------------------------------------------------------------------------------------------
042342             0103*  ; BEGIN MODIFIED CODE
042342             0104*  ; --------------------------------------------------------------------------------------------
042342             0105*  ; Originally in equs.inc
042342             0106*  ;
042342             0107*  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
042342             0108*  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
042342             0109*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
042342             0110*  ; --------------------------------------------------------------------------------------------
042342             0111*  ; END MODIFIED CODE
042342             0112*  ; --------------------------------------------------------------------------------------------
042342             0113*  
042342             0114*  ; Extra Agon-implementation specific system variables
042342             0115*  ;
042342 00          0116*  FLAGS:          BLKB    1,0       ; Miscellaneous flags
042343             0117*                                  ; - BIT 7: Set if ESC pressed
042343             0118*                                  ; - BIT 6: Set to disable ESC
042343 00 00       0119*  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
042345 00          0120*  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
042346             0121*                                  ; - 0: Console
042346             0122*                                  ; - 1: File
042346 00          0123*  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
042347 00          0124*  KEYDOWN:        BLKB    1,0       ; Keydown flag
042348 00          0125*  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
042349 00          0126*  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
04234A 00 00 00    0127*  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
04234D 00 00 00    0128*  R1:             BLKB    3,0
042350             0129*  
042350             0130*  ;
042350             0131*  ; This must be at the end
042350             0132*  ;
042350             0133*  RAM_END:
042350 FF FF FF FF 0134*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
042400             0135*  USER:							; Must be aligned on a page boundary
042400             0136*  
