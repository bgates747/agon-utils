PC     Output      Line
040000             0001       assume adl=1
040000             0002       org 0x040000
040000             0003       include "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modified: 11/14/2024 by Brandon R. Gates for ez80asm compatibility
040000             0008*  ;
040000             0009*  ; Modinfo:
040000             0010*  ; 05/08/2022:	Added mos_feof
040000             0011*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0012*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0013*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0014*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0015*  ; 13/10/2022:	Added mos_oscli
040000             0016*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0017*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0018*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0019*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0020*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0021*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0022*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0023*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0024*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0025*  ; 19/05/2023:	Added sysvar_scrMode
040000             0026*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0027*  ; 03/08/2023:	Added mos_setkbvector
040000             0028*  ; 10/08/2023:	Added mos_getkbmap
040000             0029*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0030*  ; 11/14/2024:   FatFS structs modified for ez80asm compatibility
040000             0031*  ;
040000             0032*  ; VDP control (VDU 23, 0, n)
040000             0033*  ;
040000             0034*  vdp_gp:			EQU 	80h
040000             0035*  vdp_keycode:		EQU 	81h
040000             0036*  vdp_cursor:		EQU	82h
040000             0037*  vdp_scrchar:		EQU	83h
040000             0038*  vdp_scrpixel:		EQU	84h
040000             0039*  vdp_audio:		EQU	85h
040000             0040*  vdp_mode:		EQU	86h
040000             0041*  vdp_rtc:		EQU	87h
040000             0042*  vdp_keystate:		EQU	88h
040000             0043*  vdp_logicalcoords:	EQU	C0h
040000             0044*  vdp_terminalmode:	EQU	FFh
040000             0045*  
040000             0046*  ; MOS high level functions
040000             0047*  ;
040000             0048*  mos_getkey:		EQU	00h
040000             0049*  mos_load:		EQU	01h
040000             0050*  mos_save:		EQU	02h
040000             0051*  mos_cd:			EQU	03h
040000             0052*  mos_dir:		EQU	04h
040000             0053*  mos_del:		EQU	05h
040000             0054*  mos_ren:		EQU	06h
040000             0055*  mos_mkdir:		EQU	07h
040000             0056*  mos_sysvars:		EQU	08h
040000             0057*  mos_editline:		EQU	09h
040000             0058*  mos_fopen:		EQU	0Ah
040000             0059*  mos_fclose:		EQU	0Bh
040000             0060*  mos_fgetc:		EQU	0Ch
040000             0061*  mos_fputc:		EQU	0Dh
040000             0062*  mos_feof:		EQU	0Eh
040000             0063*  mos_getError:		EQU	0Fh
040000             0064*  mos_oscli:		EQU	10h
040000             0065*  mos_copy:		EQU	11h
040000             0066*  mos_getrtc:		EQU	12h
040000             0067*  mos_setrtc:		EQU	13h
040000             0068*  mos_setintvector:	EQU	14h
040000             0069*  mos_uopen:		EQU	15h
040000             0070*  mos_uclose:		EQU	16h
040000             0071*  mos_ugetc:		EQU	17h
040000             0072*  mos_uputc:		EQU 	18h
040000             0073*  mos_getfil:		EQU	19h
040000             0074*  mos_fread:		EQU	1Ah
040000             0075*  mos_fwrite:		EQU	1Bh
040000             0076*  mos_flseek:		EQU	1Ch
040000             0077*  mos_setkbvector:	EQU	1Dh
040000             0078*  mos_getkbmap:		EQU	1Eh
040000             0079*  mos_i2c_open:		EQU	1Fh
040000             0080*  mos_i2c_close:		EQU	20h
040000             0081*  mos_i2c_write:		EQU	21h
040000             0082*  mos_i2c_read:		EQU	22h
040000             0083*  
040000             0084*  
040000             0085*  ; FatFS file access functions
040000             0086*  ;
040000             0087*  ffs_fopen:		EQU	80h
040000             0088*  ffs_fclose:		EQU	81h
040000             0089*  ffs_fread:		EQU	82h
040000             0090*  ffs_fwrite:		EQU	83h
040000             0091*  ffs_flseek:		EQU	84h
040000             0092*  ffs_ftruncate:		EQU	85h
040000             0093*  ffs_fsync:		EQU	86h
040000             0094*  ffs_fforward:		EQU	87h
040000             0095*  ffs_fexpand:		EQU	88h
040000             0096*  ffs_fgets:		EQU	89h
040000             0097*  ffs_fputc:		EQU	8Ah
040000             0098*  ffs_fputs:		EQU	8Bh
040000             0099*  ffs_fprintf:		EQU	8Ch
040000             0100*  ffs_ftell:		EQU	8Dh
040000             0101*  ffs_feof:		EQU	8Eh
040000             0102*  ffs_fsize:		EQU	8Fh
040000             0103*  ffs_ferror:		EQU	90h
040000             0104*  
040000             0105*  ; FatFS directory access functions
040000             0106*  ;
040000             0107*  ffs_dopen:		EQU	91h
040000             0108*  ffs_dclose:		EQU	92h
040000             0109*  ffs_dread:		EQU	93h
040000             0110*  ffs_dfindfirst:		EQU	94h
040000             0111*  ffs_dfindnext:		EQU	95h
040000             0112*  
040000             0113*  ; FatFS file and directory management functions
040000             0114*  ;
040000             0115*  ffs_stat:		EQU	96h
040000             0116*  ffs_unlink:		EQU	97h
040000             0117*  ffs_rename:		EQU	98h
040000             0118*  ffs_chmod:		EQU	99h
040000             0119*  ffs_utime:		EQU	9Ah
040000             0120*  ffs_mkdir:		EQU	9Bh
040000             0121*  ffs_chdir:		EQU	9Ch
040000             0122*  ffs_chdrive:		EQU	9Dh
040000             0123*  ffs_getcwd:		EQU	9Eh
040000             0124*  
040000             0125*  ; FatFS volume management and system configuration functions
040000             0126*  ;
040000             0127*  ffs_mount:		EQU	9Fh
040000             0128*  ffs_mkfs:		EQU	A0h
040000             0129*  ffs_fdisk:		EQU	A1h
040000             0130*  ffs_getfree:		EQU	A2h
040000             0131*  ffs_getlabel:		EQU	A3h
040000             0132*  ffs_setlabel:		EQU	A4h
040000             0133*  ffs_setcp:		EQU	A5h
040000             0134*  
040000             0135*  ; File access modes
040000             0136*  ;
040000             0137*  fa_read:		EQU	01h
040000             0138*  fa_write:		EQU	02h
040000             0139*  fa_open_existing:	EQU	00h
040000             0140*  fa_create_new:		EQU	04h
040000             0141*  fa_create_always:	EQU	08h
040000             0142*  fa_open_always:		EQU	10h
040000             0143*  fa_open_append:		EQU	30h
040000             0144*  
040000             0145*  ; System variable indexes for api_sysvars
040000             0146*  ; Index into _sysvars in globals.asm
040000             0147*  ;
040000             0148*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0149*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0150*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0151*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0152*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0153*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0154*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0155*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0156*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0157*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0158*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0159*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0160*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0161*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0162*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0163*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0164*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0165*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0166*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0167*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0168*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0169*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0170*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0171*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0172*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0173*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0174*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0175*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0176*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0177*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0178*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0179*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0180*  ;
040000             0181*  ; Flags for the VPD protocol
040000             0182*  ;
040000             0183*  vdp_pflag_cursor:	EQU	00000001b
040000             0184*  vdp_pflag_scrchar:	EQU	00000010b
040000             0185*  vdp_pflag_point:	EQU	00000100b
040000             0186*  vdp_pflag_audio:	EQU	00001000b
040000             0187*  vdp_pflag_mode:		EQU	00010000b
040000             0188*  vdp_pflag_rtc:		EQU	00100000b
040000             0189*  vdp_pflag_mouse:	EQU	01000000b
040000             0190*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0191*  
040000             0192*  
040000             0193*  ; FatFS structures
040000             0194*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0195*  ;
040000             0196*  ; Object ID and allocation information (FFOBJID)
040000             0197*  FFOBJID.fs:       EQU 0    ; Pointer to the hosting volume of this object
040000             0198*  FFOBJID.id:       EQU 3    ; Hosting volume mount ID
040000             0199*  FFOBJID.attr:     EQU 5    ; Object attribute
040000             0200*  FFOBJID.stat:     EQU 6    ; Object chain status
040000             0201*  FFOBJID.sclust:   EQU 7    ; Object data start cluster
040000             0202*  FFOBJID.objsize:  EQU 11   ; Object size
040000             0203*  FFOBJID_SIZE:     EQU 15   ; Total size of FFOBJID structure
040000             0204*  ;
040000             0205*  ; File object structure (FIL)
040000             0206*  ;
040000             0207*  FIL.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0208*  FIL.flag:         EQU FFOBJID_SIZE       ; File status flags
040000             0209*  FIL.err:          EQU FFOBJID_SIZE + 1   ; Abort flag (error code)
040000             0210*  FIL.fptr:         EQU FFOBJID_SIZE + 2   ; File read/write pointer
040000             0211*  FIL.clust:        EQU FFOBJID_SIZE + 6   ; Current cluster of fptr
040000             0212*  FIL.sect:         EQU FFOBJID_SIZE + 10  ; Sector number appearing in buf[]
040000             0213*  FIL.dir_sect:     EQU FFOBJID_SIZE + 14  ; Sector number containing the directory entry
040000             0214*  FIL.dir_ptr:      EQU FFOBJID_SIZE + 18  ; Pointer to the directory entry in the win[]
040000             0215*  FIL_SIZE:         EQU FFOBJID_SIZE + 21  ; Total size of FIL structure
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  DIR.obj:          EQU 0                  ; Object identifier (FFOBJID fields start here)
040000             0220*  DIR.dptr:         EQU FFOBJID_SIZE       ; Current read/write offset
040000             0221*  DIR.clust:        EQU FFOBJID_SIZE + 4   ; Current cluster
040000             0222*  DIR.sect:         EQU FFOBJID_SIZE + 8   ; Current sector
040000             0223*  DIR.dir:          EQU FFOBJID_SIZE + 12  ; Pointer to the directory item in the win[]
040000             0224*  DIR.fn:           EQU FFOBJID_SIZE + 15  ; SFN (in/out) {body[8],ext[3],status[1]}
040000             0225*  DIR.blk_ofs:      EQU FFOBJID_SIZE + 27  ; Offset of current entry block being processed
040000             0226*  DIR_SIZE:         EQU FFOBJID_SIZE + 31  ; Total size of DIR structure
040000             0227*  ;
040000             0228*  ; File information structure (FILINFO)
040000             0229*  ;
040000             0230*  FILINFO.fsize:    EQU 0    ; File size
040000             0231*  FILINFO.fdate:    EQU 4    ; Modified date
040000             0232*  FILINFO.ftime:    EQU 6    ; Modified time
040000             0233*  FILINFO.fattrib:  EQU 8    ; File attribute
040000             0234*  FILINFO.altname:  EQU 9    ; Alternative file name
040000             0235*  FILINFO.fname:    EQU 22   ; Primary file name
040000             0236*  FILINFO_SIZE:     EQU 278  ; Total size of FILINFO structure
040000             0237*  ;
040000             0238*  ; Macro for calling the API
040000             0239*  ; Parameters:
040000             0240*  ; - function: One of the function numbers listed above
040000             0241*  ;
040000             0242*  			MACRO MOSCALL	function
040000             0243*  			LD	A, function
040000             0244*  			RST.LIS	08h
040000             0245*  			ENDMACRO
040000             0004       MACRO PROGNAME
040000             0005       ASCIZ "flower_demo"
040000             0006       ENDMACRO
040000 C3 45 00 04 0007       jp start
040004             0008   _exec_name:
040004             0009       PROGNAME
040004 66 6C 6F 77 0001M      ASCIZ "flower_demo"
       65 72 5F 64 
       65 6D 6F 00 
040010 FF FF FF FF 0010       align 64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
040040 4D 4F 53 00 0011       db "MOS", 00h, 01h
       01          
040045             0012   start:
040045 F5          0013       push af
040046 C5          0014       push bc
040047 D5          0015       push de
040048 DD E5       0016       push ix
04004A FD E5       0017       push iy
04004C CD 6F 1C 04 0018       call init
040050 CD F9 1C 04 0019       call main
040054             0020   exit:
040054 FD E1       0021       pop iy
040056 DD E1       0022       pop ix
040058 D1          0023       pop de
040059 C1          0024       pop bc
04005A F1          0025       pop af
04005B 21 00 00 00 0026       ld hl,0
04005F C9          0027       ret
040060             0028   
040060             0029   ; ---- list of input arguments to cycle through ----
040060 66 00 04    0030   cur_sample: dl samples ; address of the current sample
040063 66 00 04    0031   next_sample: dl samples ; address of the next sample
040066             0032   samples:
040066 36 2E 39 36 0033       asciz "6.966, 2.01, 0.4, 50, 1, 320, 90, 17"
       36 2C 20 32 
       2E 30 31 2C 
       20 30 2E 34 
       2C 20 35 30 
       2C 20 31 2C 
       20 33 32 30 
       2C 20 39 30 
       2C 20 31 37 
       00          
04008B 37 2E 30 33 0034       asciz "7.034, 2.00, 0.4, 50, 1, 320, 90, 17"
       34 2C 20 32 
       2E 30 30 2C 
       20 30 2E 34 
       2C 20 35 30 
       2C 20 31 2C 
       20 33 32 30 
       2C 20 39 30 
       2C 20 31 37 
       00          
0400B0 36 2E 39 36 0035       asciz "6.966, 1.99, 0.4, 50, 1, 320, 90, 17"
       36 2C 20 31 
       2E 39 39 2C 
       20 30 2E 34 
       2C 20 35 30 
       2C 20 31 2C 
       20 33 32 30 
       2C 20 39 30 
       2C 20 31 37 
       00          
0400D5 37 2E 30 33 0036       asciz "7.034, 2.00, 0.4, 50, 1, 320, 90, 17"
       34 2C 20 32 
       2E 30 30 2C 
       20 30 2E 34 
       2C 20 35 30 
       2C 20 31 2C 
       20 33 32 30 
       2C 20 39 30 
       2C 20 31 37 
       00          
0400FA             0037   
0400FA             0038   
0400FA             0039       ; asciz "4.09, 20, 0.25, 25, 0, 320, 90, 20"
0400FA             0040       ; asciz "4.12, 20, 0.25, 25, 0, 320, 90, 20"
0400FA             0041   
0400FA             0042       ; asciz "3 4 0 1 0 320 90 100"
0400FA             0043       ; asciz "3 4 1 1 0 160 -90 100"
0400FA             0044   
0400FA             0045       ; asciz "7.034 1.98 0.5 50 1 320 90 20"
0400FA             0046   
0400FA             0047   
0400FA             0048   
0400FA             0049   
0400FA             0050       ; asciz "3.03 1.98 .6 66 .8 320 0 50"
0400FA             0051       ; asciz "2.97 2.02 .6 66 .8 320 120 1"
0400FA             0052   
0400FA             0053       ; asciz "4.03 2.98 1.6 67 1.8 320 1 20"
0400FA             0054   
0400FA             0055       ; asciz "3 0.98 0.8 30 0.8 256 90 100"
0400FA             0056       ; asciz "3 1.02 0.8 30 0.1 256 90 100"
0400FA             0057   
0400FA             0058       ; asciz "7 5.01 0.5 50 1 320 90 50"
0400FA             0059       ; asciz "3.03 1.98 .6 66 .8 320 90 20"
0400FA             0060       ; asciz "2.5 1.001 1 500 1 320 90 100"
0400FA 00 00 00    0061       dl 0; list terminator
0400FD             0062   
0400FD             0063   ; APPLICATION INCLUDES
0400FD             0064   filedata: equ 0xB7E000 ; start address of 8k onboard sram
0400FD             0065       include "basic/fpp.asm"
0400FD             0001*  ;
0400FD             0002*  ; Title:	BBC Basic Interpreter - Z80 version
0400FD             0003*  ;		Z80 Floating Point Package
0400FD             0004*  ; Author:	(C) Copyright  R.T.Russell  1986
0400FD             0005*  ; Modified By:	Dean Belfield
0400FD             0006*  ; Created:	03/05/2022
0400FD             0007*  ; Last Updated:	07/06/2023
0400FD             0008*  ;
0400FD             0009*  ; Modinfo:
0400FD             0010*  ; 26/10/1986:	Version 0.0
0400FD             0011*  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0400FD             0012*  ; 12/05/2023:	Modified by Dean Belfield
0400FD             0013*  ; 07/06/2023:	Modified to run in ADL mode
0400FD             0014*  
0400FD             0015*  			; .ASSUME	ADL = 1
0400FD             0016*  
0400FD             0017*  			; SEGMENT CODE
0400FD             0018*  
0400FD             0019*  			; XDEF	FPP
0400FD             0020*  			; XDEF	DLOAD5
0400FD             0021*  			; XDEF	DLOAD5_SPL
0400FD             0022*  ;
0400FD             0023*  ;BINARY FLOATING POINT REPRESENTATION:
0400FD             0024*  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0400FD             0025*  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0400FD             0026*  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0400FD             0027*  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0400FD             0028*  ;
0400FD             0029*  ;BINARY INTEGER REPRESENTATION:
0400FD             0030*  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0400FD             0031*  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0400FD             0032*  ;
0400FD             0033*  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0400FD             0034*  ;                            EXPONENT - C
0400FD             0035*  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0400FD             0036*  ;                               EXPONENT - B
0400FD             0037*  
0400FD             0038*  ;
0400FD             0039*  ;Error codes:
0400FD             0040*  ;
0400FD             0041*  
0400FD             0042*  BADOP:			EQU     1               ;Bad operation code
0400FD             0043*  DIVBY0:			EQU     18              ;Division by zero
0400FD             0044*  TOOBIG_FP:			EQU     20              ;Too big
0400FD             0045*  NGROOT:			EQU     21              ;Negative root
0400FD             0046*  LOGRNG:			EQU     22              ;Log range
0400FD             0047*  ACLOST:			EQU     23              ;Accuracy lost
0400FD             0048*  EXPRNG:			EQU     24              ;Exp range
0400FD             0049*  ;
0400FD             0050*  ;Call entry and despatch code:
0400FD             0051*  ;
0400FD FD E5       0052*  FPP:			PUSH    IY              ;Save IY
0400FF FD 21 00 00 0053*          		LD      IY,0
       00          
040104 FD 39       0054*          		ADD     IY,SP           ;Save SP in IY
040106 CD 16 01 04 0055*          		CALL    OP              ;Perform operation
04010A BF          0056*          		CP      A               ;Good return (Z, NC)
04010B FD E1       0057*  EXIT_FP_:			POP     IY              ;Restore IY
04010D C9          0058*          		RET                     ;Return to caller
04010E             0059*  ;
04010E             0060*  ;Error exit:
04010E             0061*  ;
04010E 3E 01       0062*  BAD_FP:			LD      A,BADOP         ;"Bad operation code"
040110 FD F9       0063*  ERROR_FP_:			LD      SP,IY           ;Restore SP from IY
040112 B7          0064*          		OR      A               ;Set NZ
040113 37          0065*          		SCF                     ;Set C
040114 18 F5       0066*          		JR      EXIT_FP_
040116             0067*  ;
040116             0068*  ;Perform operation or function:
040116             0069*  ;
040116             0070*  ; OP:			CP      (RTABLE-DTABLE)/3
040116 FE 2A       0071*  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
040118             0072*  
040118 30 F4       0073*          		JR      NC,BAD_FP
04011A             0074*          		; CP      (FTABLE-DTABLE)/3
04011A FE 10       0075*  				CP      FTABLE-DTABLE/3 ; ditto
04011C 30 08       0076*          		JR      NC,DISPAT_FP
04011E 08          0077*          		EX      AF,AF'
04011F 78          0078*          		LD      A,B
040120 B1          0079*          		OR      C               ;Both integer?
040121 C4 29 0C 04 0080*          		CALL    NZ,FLOATA       ;No, so float both
040125 08          0081*          		EX      AF,AF'
040126 E5          0082*  DISPAT_FP:			PUSH    HL
040127 21 39 01 04 0083*          		LD      HL,DTABLE
04012B C5          0084*          		PUSH    BC
04012C 01 03 00 00 0085*  			LD	BC, 3		; C = 3
040130 47          0086*  			LD	B, A 		; B = op-code
040131 ED 4C       0087*  			MLT 	BC 		;BC = op-code * 3
040133 09          0088*  			ADD	HL, BC 		;Add to table base
040134 ED 27       0089*  			LD	HL, (HL)	;Get the routine address (24-bit)
040136             0090*  
040136             0091*  ;        		ADD     A, A            ;A = op-code * 2
040136             0092*  ;        		LD      C,A
040136             0093*  ;        		LD      B,0             ;BC = op-code * 2
040136             0094*  ;        		ADD     HL,BC
040136             0095*  ;        		LD      A,(HL)          ;Get low byte
040136             0096*  ;        		INC     HL
040136             0097*  ;        		LD      H,(HL)          ;Get high byte
040136             0098*  ;        		LD      L,A
040136             0099*  
040136 C1          0100*          		POP     BC
040137 E3          0101*          		EX      (SP),HL
040138 C9          0102*          		RET                     ;Off to routine
040139             0103*  ;
040139             0104*  ;Despatch table:
040139             0105*  ;
040139 EB 01 04    0106*  DTABLE:			DW24  IAND            ;AND (INTEGER)
04013C 59 02 04    0107*          		DW24  IBDIV           ;DIV
04013F FE 01 04    0108*          		DW24  IEOR            ;EOR
040142 24 02 04    0109*          		DW24  IMOD            ;MOD
040145 11 02 04    0110*          		DW24  IOR             ;OR
040148 DF 04 04    0111*          		DW24  ILE             ;<=
04014B EE 04 04    0112*          		DW24  INE             ;<>
04014E D2 04 04    0113*          		DW24  IGE             ;>=
040151 B7 04 04    0114*          		DW24  ILT             ;<
040154 FB 04 04    0115*          		DW24  IEQ             ;=
040157 47 03 04    0116*          		DW24  IMUL            ;*
04015A 82 02 04    0117*          		DW24  IADD            ;+
04015D C4 04 04    0118*          		DW24  IGT             ;>
040160 69 02 04    0119*          		DW24  ISUB            ;-
040163 FE 03 04    0120*          		DW24  IPOW            ;^
040166 F4 02 04    0121*          		DW24  IDIV            ;/
040169             0122*  ;
040169             0123*  FTABLE:
040169 0D 05 04    0124*  				DW24  ABSV_FP            ;ABS
04016C F3 08 04    0125*          		DW24  ACS_FP             ;ACS
04016F 31 08 04    0126*          		DW24  ASN_FP             ;ASN
040172 61 08 04    0127*          		DW24  ATN_FP             ;ATN
040175 2C 06 04    0128*          		DW24  COS_FP             ;COS
040178 3B 05 04    0129*          		DW24  DEG_FP             ;DEG
04017B E8 06 04    0130*          		DW24  EXP_FP             ;EXP
04017E 8F 05 04    0131*          		DW24  INT_FP_            ;INT
040181 86 07 04    0132*          		DW24  LN_FP              ;LN
040184 1B 08 04    0133*          		DW24  LOG_FP             ;LOG
040187 19 05 04    0134*          		DW24  NOTK_FP            ;NOT
04018A 45 05 04    0135*          		DW24  RAD_FP             ;RAD
04018D 60 05 04    0136*          		DW24  SGN_FP             ;SGN
040190 39 06 04    0137*          		DW24  SIN_FP             ;SIN
040193 A8 05 04    0138*          		DW24  SQR_FP             ;SQR
040196 06 06 04    0139*          		DW24  TAN_FP             ;TAN
040199             0140*  ;
040199 B6 0C 04    0141*  		        DW24  ZERO_FP            ;ZERO
04019C C1 06 04    0142*          		DW24  FONE_FP            ;FONE
04019F 00 05 04    0143*          		DW24  TRUE_FP            ;TRUE
0401A2 2D 05 04    0144*          		DW24  PI_FP              ;PI
0401A5             0145*  ;
0401A5 74 05 04    0146*  		        DW24  VAL_FP             ;VAL
0401A8 FC 08 04    0147*          		DW24  STR_FP             ;STR$
0401AB             0148*  ;
0401AB 5D 0B 04    0149*          		DW24  SFIX_FP            ;FIX
0401AE 39 0C 04    0150*          		DW24  SFLOAT_FP          ;FLOAT
0401B1             0151*  ;
0401B1 87 0C 04    0152*  		        DW24  FTEST_FP           ;TEST
0401B4 99 0C 04    0153*          		DW24  FCOMP_FP           ;COMPARE
0401B7             0154*  ;
0401B7 E7 01 04    0155*  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0401BA 55 02 04    0156*          		DW24  FBDIV           ;DIV
0401BD FA 01 04    0157*          		DW24  FEOR            ;EOR
0401C0 20 02 04    0158*          		DW24  FMOD            ;MOD
0401C3 0D 02 04    0159*          		DW24  FFOR             ;OR
0401C6 D9 04 04    0160*          		DW24  FLE             ;<=
0401C9 E8 04 04    0161*          		DW24  FNE             ;<>
0401CC CC 04 04    0162*          		DW24  FGE             ;>=
0401CF B1 04 04    0163*          		DW24  FLT             ;<
0401D2 F5 04 04    0164*          		DW24  FEQ             ;=
0401D5 A1 03 04    0165*          		DW24  FMUL            ;*
0401D8 8F 02 04    0166*          		DW24  FADD            ;+
0401DB BE 04 04    0167*          		DW24  FGT             ;>
0401DE 76 02 04    0168*          		DW24  FSUB            ;-
0401E1 7E 04 04    0169*          		DW24  FPOW            ;^
0401E4 F8 02 04    0170*          		DW24  FDIV            ;/
0401E7             0171*  ;
0401E7             0172*  ;       PAGE
0401E7             0173*  ;
0401E7             0174*  ;ARITHMETIC AND LOGICAL OPERATORS:
0401E7             0175*  ;All take two arguments, in HLH'L'C & DED'E'B.
0401E7             0176*  ;Output in HLH'L'C
0401E7             0177*  ;All registers except IX, IY destroyed.
0401E7             0178*  ; (N.B. FPOW destroys IX).
0401E7             0179*  ;
0401E7             0180*  ;FAND - Floating-point AND.
0401E7             0181*  ;IAND - Integer AND.
0401E7             0182*  ;
0401E7 CD 51 0B 04 0183*  FAND:			CALL    FIX2
0401EB 7C          0184*  IAND:			LD      A,H
0401EC A2          0185*          		AND     D
0401ED 67          0186*          		LD      H,A
0401EE 7D          0187*          		LD      A,L
0401EF A3          0188*          		AND     E
0401F0 6F          0189*          		LD      L,A
0401F1 D9          0190*          		EXX
0401F2 7C          0191*          		LD      A,H
0401F3 A2          0192*          		AND     D
0401F4 67          0193*          		LD      H,A
0401F5 7D          0194*          		LD      A,L
0401F6 A3          0195*          		AND     E
0401F7 6F          0196*          		LD      L,A
0401F8 D9          0197*          		EXX
0401F9 C9          0198*          		RET
0401FA             0199*  ;
0401FA             0200*  ;FEOR - Floating-point exclusive-OR.
0401FA             0201*  ;IEOR - Integer exclusive-OR.
0401FA             0202*  ;
0401FA CD 51 0B 04 0203*  FEOR:			CALL    FIX2
0401FE 7C          0204*  IEOR:			LD      A,H
0401FF AA          0205*          		XOR     D
040200 67          0206*          		LD      H,A
040201 7D          0207*          		LD      A,L
040202 AB          0208*          		XOR     E
040203 6F          0209*          		LD      L,A
040204 D9          0210*          		EXX
040205 7C          0211*          		LD      A,H
040206 AA          0212*          		XOR     D
040207 67          0213*          		LD      H,A
040208 7D          0214*          		LD      A,L
040209 AB          0215*          		XOR     E
04020A 6F          0216*          		LD      L,A
04020B D9          0217*          		EXX
04020C C9          0218*          		RET
04020D             0219*  ;
04020D             0220*  ;FOR - Floating-point OR.
04020D             0221*  ;IOR - Integer OR.
04020D             0222*  ;
04020D CD 51 0B 04 0223*  FFOR:			CALL    FIX2
040211 7C          0224*  IOR:			LD      A,H
040212 B2          0225*          		OR      D
040213 67          0226*          		LD      H,A
040214 7D          0227*          		LD      A,L
040215 B3          0228*          		OR      E
040216 6F          0229*          		LD      L,A
040217 D9          0230*          		EXX
040218 7C          0231*          		LD      A,H
040219 B2          0232*          		OR      D
04021A 67          0233*          		LD      H,A
04021B 7D          0234*          		LD      A,L
04021C B3          0235*          		OR      E
04021D 6F          0236*          		LD      L,A
04021E D9          0237*          		EXX
04021F C9          0238*          		RET
040220             0239*  ;
040220             0240*  ;FMOD - Floating-point remainder.
040220             0241*  ;IMOD - Integer remainder.
040220             0242*  ;
040220 CD 51 0B 04 0243*  FMOD:			CALL    FIX2
040224 7C          0244*  IMOD:			LD      A,H
040225 AA          0245*          		XOR     D               ;DIV RESULT SIGN
040226 CB 7C       0246*          		BIT     7,H
040228 08          0247*          		EX      AF,AF'
040229 CB 7C       0248*          		BIT     7,H
04022B C4 6D 0B 04 0249*          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
04022F CD 6A 0C 04 0250*          		CALL    SWAP_FP
040233 CB 7C       0251*          		BIT     7,H
040235 C4 6D 0B 04 0252*          		CALL    NZ,NEGATE
040239 44          0253*          		LD      B,H
04023A 4D          0254*          		LD      C,L
04023B 21 00 00 00 0255*          		LD      HL,0
04023F D9          0256*          		EXX
040240 44          0257*          		LD      B,H
040241 4D          0258*          		LD      C,L
040242 21 00 00 00 0259*          		LD      HL,0
040246 3E DF       0260*          		LD      A,-33
040248 CD F7 0D 04 0261*          		CALL    DIVA            ;DIVIDE
04024C D9          0262*          		EXX
04024D 0E 00       0263*          		LD      C,0             ;INTEGER MARKER
04024F 08          0264*          		EX      AF,AF'
040250 C8          0265*          		RET     Z
040251 C3 6D 0B 04 0266*          		JP      NEGATE
040255             0267*  ;
040255             0268*  ;BDIV - Integer division.
040255             0269*  ;
040255 CD 51 0B 04 0270*  FBDIV:			CALL    FIX2
040259 CD 24 02 04 0271*  IBDIV:			CALL    IMOD
04025D B7          0272*          		OR      A
04025E CD 6A 0C 04 0273*          		CALL    SWAP_FP
040262 0E 00       0274*          		LD      C,0
040264 F0          0275*          		RET     P
040265 C3 6D 0B 04 0276*          		JP      NEGATE
040269             0277*  ;
040269             0278*  ;ISUB - Integer subtraction.
040269             0279*  ;FSUB - Floating point subtraction with rounding.
040269             0280*  ;
040269 CD 05 0D 04 0281*  ISUB:			CALL    SUB_
04026D E0          0282*          		RET     PO
04026E CD FD 0C 04 0283*          		CALL    ADD_
040272 CD 2D 0C 04 0284*          		CALL    FLOAT2
040276 7A          0285*  FSUB:			LD      A,D
040277 EE 80       0286*          		XOR     80H             ;CHANGE SIGN THEN ADD
040279 57          0287*          		LD      D,A
04027A 18 13       0288*          		JR      FADD
04027C             0289*  ;
04027C             0290*  ;Reverse subtract.
04027C             0291*  ;
04027C 7C          0292*  RSUB:			LD      A,H
04027D EE 80       0293*          		XOR     80H
04027F 67          0294*          		LD      H,A
040280 18 0D       0295*          		JR      FADD
040282             0296*  ;
040282             0297*  ;IADD - Integer addition.
040282             0298*  ;FADD - Floating point addition with rounding.
040282             0299*  ;
040282 CD FD 0C 04 0300*  IADD:			CALL    ADD_
040286 E0          0301*          		RET     PO
040287 CD 05 0D 04 0302*          		CALL    SUB_
04028B CD 2D 0C 04 0303*          		CALL    FLOAT2
04028F 05          0304*  FADD:			DEC     B
040290 04          0305*          		INC     B
040291 C8          0306*          		RET     Z               ;ARG 2 ZERO
040292 0D          0307*          		DEC     C
040293 0C          0308*          		INC     C
040294 CA 6A 0C 04 0309*          		JP      Z,SWAP_FP          ;ARG 1 ZERO
040298 D9          0310*          		EXX
040299 01 00 00 00 0311*          		LD      BC,0            ;INITIALISE
04029D D9          0312*          		EXX
04029E 7C          0313*          		LD      A,H
04029F AA          0314*          		XOR     D               ;XOR SIGNS
0402A0 F5          0315*          		PUSH    AF
0402A1 78          0316*          		LD      A,B
0402A2 B9          0317*          		CP      C               ;COMPARE EXPONENTS
0402A3 DC 6A 0C 04 0318*          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0402A7 78          0319*          		LD      A,B
0402A8 CB FC       0320*          		SET     7,H             ;IMPLIED 1
0402AA C4 3E 0B 04 0321*          		CALL    NZ,FIX          ;ALIGN
0402AE F1          0322*          		POP     AF
0402AF 7A          0323*          		LD      A,D             ;SIGN OF LARGER
0402B0 CB FA       0324*          		SET     7,D             ;IMPLIED 1
0402B2 FA C2 02 04 0325*          		JP      M,FADD3         ;SIGNS DIFFERENT
0402B6 CD FD 0C 04 0326*          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0402BA DC 72 0C 04 0327*          		CALL    C,DIV2          ;NORMALISE
0402BE CB FC       0328*          		SET     7,H
0402C0 18 0D       0329*          		JR      FADD4
0402C2             0330*  ;
0402C2 CD 05 0D 04 0331*  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0402C6 DC 85 0B 04 0332*          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0402CA CD 04 0C 04 0333*          		CALL    FLO48
0402CE 2F          0334*          		CPL                     ;CHANGE RESULT SIGN
0402CF D9          0335*  FADD4:			EXX
0402D0 EB          0336*          		EX      DE,HL
0402D1 21 00 80 00 0337*          		LD      HL,8000H
0402D5 B7          0338*          		OR      A               ;CLEAR CARRY
0402D6 52 ED 42    0339*          		SBC.S   HL,BC
0402D9 EB          0340*          		EX      DE,HL
0402DA D9          0341*          		EXX
0402DB CC 64 0C 04 0342*          		CALL    Z,ODD           ;ROUND UNBIASSED
0402DF DC 52 0C 04 0343*          		CALL    C,ADD1_FP          ;ROUND UP
0402E3 DC 7F 0C 04 0344*          		CALL    C,INCC
0402E7 CB BC       0345*          		RES     7,H
0402E9 0D          0346*          		DEC     C
0402EA 0C          0347*          		INC     C
0402EB CA B6 0C 04 0348*          		JP      Z,ZERO_FP
0402EF B7          0349*          		OR      A               ;RESULT SIGNQ
0402F0 F0          0350*          		RET     P               ;POSITIVE
0402F1 CB FC       0351*          		SET     7,H             ;NEGATIVE
0402F3 C9          0352*          		RET
0402F4             0353*  ;
0402F4             0354*  ;IDIV - Integer division.
0402F4             0355*  ;FDIV - Floating point division with rounding.
0402F4             0356*  ;
0402F4 CD 2D 0C 04 0357*  IDIV:			CALL    FLOAT2
0402F8 05          0358*  FDIV:			DEC     B               ;TEST FOR ZERO
0402F9 04          0359*          		INC     B
0402FA 3E 12       0360*          		LD      A,DIVBY0
0402FC CA 10 01 04 0361*          		JP      Z,ERROR_FP_         ;"Division by zero"
040300 0D          0362*          		DEC     C               ;TEST FOR ZERO
040301 0C          0363*          		INC     C
040302 C8          0364*          		RET     Z
040303 7C          0365*          		LD      A,H
040304 AA          0366*          		XOR     D               ;CALC. RESULT SIGN
040305 08          0367*          		EX      AF,AF'          ;SAVE SIGN
040306 CB FA       0368*          		SET     7,D             ;REPLACE IMPLIED 1's
040308 CB FC       0369*          		SET     7,H
04030A C5          0370*          		PUSH    BC              ;SAVE EXPONENTS
04030B 42          0371*          		LD      B,D             ;LOAD REGISTERS
04030C 4B          0372*          		LD      C,E
04030D 11 00 00 00 0373*          		LD      DE,0
040311 D9          0374*          		EXX
040312 42          0375*          		LD      B,D
040313 4B          0376*          		LD      C,E
040314 11 00 00 00 0377*          		LD      DE,0
040318 3E E0       0378*          		LD      A,-32           ;LOOP COUNTER
04031A CD F7 0D 04 0379*          		CALL    DIVA            ;DIVIDE
04031E D9          0380*          		EXX
04031F CB 7A       0381*          		BIT     7,D
040321 D9          0382*          		EXX
040322 CC 16 0E 04 0383*          		CALL    Z,DIVB          ;NORMALISE & INC A
040326 EB          0384*          		EX      DE,HL
040327 D9          0385*          		EXX
040328 CB 38       0386*          		SRL     B               ;DIVISOR/2
04032A CB 19       0387*          		RR      C
04032C B7          0388*          		OR      A               ;CLEAR CARRY
04032D 52 ED 42    0389*          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
040330 3F          0390*          		CCF
040331 EB          0391*          		EX      DE,HL           ;RESULT IN HLH'L'
040332 CC 64 0C 04 0392*          		CALL    Z,ODD           ;ROUND UNBIASSED
040336 DC 52 0C 04 0393*          		CALL    C,ADD1_FP          ;ROUND UP
04033A C1          0394*          		POP     BC              ;RESTORE EXPONENTS
04033B DC 7F 0C 04 0395*          		CALL    C,INCC
04033F 1F          0396*          		RRA                     ;LSB OF A TO CARRY
040340 79          0397*          		LD      A,C             ;COMPUTE NEW EXPONENT
040341 98          0398*          		SBC     A,B
040342 3F          0399*          		CCF
040343 C3 E4 03 04 0400*          		JP      CHKOVF
040347             0401*  ;
040347             0402*  ;IMUL - Integer multiplication.
040347             0403*  ;
040347 7C          0404*  IMUL:			LD      A,H
040348 AA          0405*          		XOR     D
040349 08          0406*          		EX      AF,AF'          ;SAVE RESULT SIGN
04034A CB 7C       0407*          		BIT     7,H
04034C C4 6D 0B 04 0408*          		CALL    NZ,NEGATE
040350 CD 6A 0C 04 0409*          		CALL    SWAP_FP
040354 CB 7C       0410*          		BIT     7,H
040356 C4 6D 0B 04 0411*          		CALL    NZ,NEGATE
04035A 44          0412*          		LD      B,H
04035B 4D          0413*          		LD      C,L
04035C 21 00 00 00 0414*          		LD      HL,0
040360 D9          0415*          		EXX
040361 44          0416*          		LD      B,H
040362 4D          0417*          		LD      C,L
040363 21 00 00 00 0418*          		LD      HL,0
040367 3E DF       0419*          		LD      A,-33
040369 CD 2E 0E 04 0420*          		CALL    MULA            ;MULTIPLY
04036D D9          0421*          		EXX
04036E 0E BF       0422*          		LD      C,191           ;PRESET EXPONENT
040370 CD 92 0C 04 0423*          		CALL    TEST_FP            ;TEST RANGE
040374 20 0F       0424*          		JR      NZ,IMUL1        ;TOO BIG
040376 CB 7A       0425*          		BIT     7,D
040378 20 0B       0426*          		JR      NZ,IMUL1
04037A CD 6A 0C 04 0427*          		CALL    SWAP_FP
04037E 4A          0428*          		LD      C,D             ;INTEGER MARKER
04037F 08          0429*          		EX      AF,AF'
040380 F0          0430*          		RET     P
040381 C3 6D 0B 04 0431*          		JP      NEGATE
040385             0432*  ;
040385 0D          0433*  IMUL1:			DEC     C
040386 D9          0434*          		EXX
040387 CB 23       0435*          		SLA     E
040389 CB 12       0436*          		RL      D
04038B D9          0437*          		EXX
04038C CB 13       0438*          		RL      E
04038E CB 12       0439*          		RL      D
040390 D9          0440*          		EXX
040391 52 ED 6A    0441*          		ADC.S   HL,HL
040394 D9          0442*          		EXX
040395 52 ED 6A    0443*          		ADC.S   HL,HL
040398 F2 85 03 04 0444*          		JP      P,IMUL1         ;NORMALISE
04039C 08          0445*          		EX      AF,AF'
04039D F8          0446*          		RET     M
04039E CB BC       0447*          		RES     7,H             ;POSITIVE
0403A0 C9          0448*          		RET
0403A1             0449*  ;
0403A1             0450*  ;FMUL - Floating point multiplication with rounding.
0403A1             0451*  ;
0403A1 05          0452*  FMUL:			DEC     B               ;TEST FOR ZERO
0403A2 04          0453*          		INC     B
0403A3 CA B6 0C 04 0454*          		JP      Z,ZERO_FP
0403A7 0D          0455*          		DEC     C               ;TEST FOR ZERO
0403A8 0C          0456*          		INC     C
0403A9 C8          0457*          		RET     Z
0403AA 7C          0458*          		LD      A,H
0403AB AA          0459*          		XOR     D               ;CALC. RESULT SIGN
0403AC 08          0460*          		EX      AF,AF'
0403AD CB FA       0461*          		SET     7,D             ;REPLACE IMPLIED 1's
0403AF CB FC       0462*          		SET     7,H
0403B1 C5          0463*          		PUSH    BC              ;SAVE EXPONENTS
0403B2 44          0464*          		LD      B,H             ;LOAD REGISTERS
0403B3 4D          0465*          		LD      C,L
0403B4 21 00 00 00 0466*          		LD      HL,0
0403B8 D9          0467*          		EXX
0403B9 44          0468*          		LD      B,H
0403BA 4D          0469*          		LD      C,L
0403BB 21 00 00 00 0470*          		LD      HL,0
0403BF 3E E0       0471*          		LD      A,-32           ;LOOP COUNTER
0403C1 CD 2E 0E 04 0472*          		CALL    MULA            ;MULTIPLY
0403C5 DC 44 0E 04 0473*          		CALL    C,MULB          ;NORMALISE & INC A
0403C9 D9          0474*          		EXX
0403CA E5          0475*          		PUSH    HL
0403CB 21 00 80 00 0476*          		LD      HL,8000H
0403CF B7          0477*          		OR      A               ;CLEAR CARRY
0403D0 52 ED 52    0478*          		SBC.S   HL,DE
0403D3 E1          0479*          		POP     HL
0403D4 CC 64 0C 04 0480*          		CALL    Z,ODD           ;ROUND UNBIASSED
0403D8 DC 52 0C 04 0481*          		CALL    C,ADD1_FP          ;ROUND UP
0403DC C1          0482*          		POP     BC              ;RESTORE EXPONENTS
0403DD DC 7F 0C 04 0483*          		CALL    C,INCC
0403E1 1F          0484*          		RRA                     ;LSB OF A TO CARRY
0403E2 79          0485*          		LD      A,C             ;COMPUTE NEW EXPONENT
0403E3 88          0486*          		ADC     A,B
0403E4 38 06       0487*  CHKOVF:			JR      C,CHKO1
0403E6 F2 B6 0C 04 0488*          		JP      P,ZERO_FP          ;UNDERFLOW
0403EA 18 04       0489*          		JR      CHKO2
0403EC FA 81 0C 04 0490*  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0403F0 C6 80       0491*  CHKO2:			ADD     A,80H
0403F2 4F          0492*          		LD      C,A
0403F3 CA B6 0C 04 0493*          		JP      Z,ZERO_FP
0403F7 08          0494*          		EX      AF,AF'          ;RESTORE SIGN BIT
0403F8 CB BC       0495*          		RES     7,H
0403FA F0          0496*          		RET     P
0403FB CB FC       0497*          		SET     7,H
0403FD C9          0498*          		RET
0403FE             0499*  ;
0403FE             0500*  ;IPOW - Integer involution.
0403FE             0501*  ;
0403FE CD 6A 0C 04 0502*  IPOW:			CALL    SWAP_FP
040402 CB 7C       0503*          		BIT     7,H
040404 F5          0504*          		PUSH    AF              ;SAVE SIGN
040405 C4 6D 0B 04 0505*          		CALL    NZ,NEGATE
040409 48          0506*  IPOW0:			LD      C,B
04040A 06 20       0507*          		LD      B,32            ;LOOP COUNTER
04040C CD 22 0D 04 0508*  IPOW1:			CALL    X2
040410 38 08       0509*          		JR      C,IPOW2
040412 10 F8       0510*          		DJNZ    IPOW1
040414 F1          0511*          		POP     AF
040415 D9          0512*          		EXX
040416 2C          0513*          		INC     L               ;RESULT=1
040417 D9          0514*          		EXX
040418 4C          0515*          		LD      C,H
040419 C9          0516*          		RET
04041A             0517*  ;
04041A F1          0518*  IPOW2:			POP     AF
04041B C5          0519*          		PUSH    BC
04041C EB          0520*          		EX      DE,HL
04041D E5          0521*          		PUSH    HL
04041E D9          0522*          		EXX
04041F EB          0523*          		EX      DE,HL
040420 E5          0524*          		PUSH    HL
040421 D9          0525*          		EXX
040422 DD 21 00 00 0526*          		LD      IX,0
       00          
040427 DD 39       0527*          		ADD     IX,SP
040429 28 48       0528*          		JR      Z,IPOW4
04042B C5          0529*          		PUSH    BC
04042C D9          0530*          		EXX
04042D D5          0531*          		PUSH    DE
04042E D9          0532*          		EXX
04042F D5          0533*          		PUSH    DE
040430 CD 39 0C 04 0534*          		CALL    SFLOAT_FP
040434 CD 6D 07 04 0535*          		CALL    RECIP
040438 DD 71 04    0536*          		LD      (IX+4),C
04043B D9          0537*          		EXX
04043C DD 75 00    0538*          		LD      (IX+0),L
04043F DD 74 01    0539*          		LD      (IX+1),H
040442 D9          0540*          		EXX
040443 DD 75 02    0541*          		LD      (IX+2),L
040446 DD 74 03    0542*          		LD      (IX+3),H
040449 18 21       0543*          		JR      IPOW5
04044B             0544*  ;
04044B C5          0545*  IPOW3:			PUSH    BC
04044C D9          0546*          		EXX
04044D CB 23       0547*          		SLA     E
04044F CB 12       0548*          		RL      D
040451 D5          0549*          		PUSH    DE
040452 D9          0550*          		EXX
040453 CB 13       0551*          		RL      E
040455 CB 12       0552*          		RL      D
040457 D5          0553*          		PUSH    DE
040458 3E 0A       0554*          		LD      A,'*' & 0FH
04045A F5          0555*          		PUSH    AF
04045B CD 36 0D 04 0556*          		CALL    COPY_
04045F CD 16 01 04 0557*          		CALL    OP              ;SQUARE
040463 F1          0558*          		POP     AF
040464 CD 62 0A 04 0559*          		CALL    DLOAD5
040468 DC 16 01 04 0560*          		CALL    C,OP            ;MULTIPLY BY X
04046C D1          0561*  IPOW5:			POP     DE
04046D D9          0562*          		EXX
04046E D1          0563*          		POP     DE
04046F D9          0564*          		EXX
040470 79          0565*          		LD      A,C
040471 C1          0566*          		POP     BC
040472 4F          0567*          		LD      C,A
040473 10 D6       0568*  IPOW4:			DJNZ    IPOW3
040475 F1          0569*          		POP     AF
040476 F1          0570*          		POP     AF
040477 F1          0571*          		POP     AF
040478 C9          0572*          		RET
040479             0573*  ;
040479 F1          0574*  FPOW0:			POP     AF
04047A F1          0575*          		POP     AF
04047B F1          0576*          		POP     AF
04047C 18 8B       0577*          		JR      IPOW0
04047E             0578*  ;
04047E             0579*  ;FPOW - Floating-point involution.
04047E             0580*  ;
04047E CB 7A       0581*  FPOW:			BIT     7,D
040480 F5          0582*          		PUSH    AF
040481 CD 6A 0C 04 0583*          		CALL    SWAP_FP
040485 CD 46 0D 04 0584*          		CALL    PUSH5
040489 0D          0585*          		DEC     C
04048A 0C          0586*          		INC     C
04048B 28 EC       0587*          		JR      Z,FPOW0
04048D 3E 9E       0588*          		LD      A,158
04048F B9          0589*          		CP      C
040490 38 0A       0590*          		JR      C,FPOW1
040492 3C          0591*          		INC     A
040493 CD 3E 0B 04 0592*          		CALL    FIX
040497 08          0593*          		EX      AF,AF'
040498 F2 79 04 04 0594*          		JP      P,FPOW0
04049C CD 6A 0C 04 0595*  FPOW1:			CALL    SWAP_FP
0404A0 CD 8A 07 04 0596*          		CALL    LN0
0404A4 CD 4F 0D 04 0597*          		CALL    POP5
0404A8 F1          0598*          		POP     AF
0404A9 CD A1 03 04 0599*          		CALL    FMUL
0404AD C3 EC 06 04 0600*          		JP      EXP0
0404B1             0601*  ;
0404B1             0602*  ;Integer and floating-point compare.
0404B1             0603*  ;Result is TRUE (-1) or FALSE (0).
0404B1             0604*  ;
0404B1 CD C0 0C 04 0605*  FLT:			CALL    FCP
0404B5 18 04       0606*          		JR      ILT1
0404B7 CD B2 0C 04 0607*  ILT:			CALL    ICP
0404BB D0          0608*  ILT1:			RET     NC
0404BC 18 42       0609*          		JR      TRUE_FP
0404BE             0610*  ;
0404BE CD C0 0C 04 0611*  FGT:			CALL    FCP
0404C2 18 04       0612*          		JR      IGT1
0404C4 CD B2 0C 04 0613*  IGT:			CALL    ICP
0404C8 C8          0614*  IGT1:			RET     Z
0404C9 D8          0615*          		RET     C
0404CA 18 34       0616*          		JR      TRUE_FP
0404CC             0617*  ;
0404CC CD C0 0C 04 0618*  FGE:			CALL    FCP
0404D0 18 04       0619*          		JR      IGE1
0404D2 CD B2 0C 04 0620*  IGE:			CALL    ICP
0404D6 D8          0621*  IGE1:			RET     C
0404D7 18 27       0622*          		JR      TRUE_FP
0404D9             0623*  ;
0404D9 CD C0 0C 04 0624*  FLE:			CALL    FCP
0404DD 18 04       0625*          		JR      ILE1
0404DF CD B2 0C 04 0626*  ILE:			CALL    ICP
0404E3 28 1B       0627*  ILE1:			JR      Z,TRUE_FP
0404E5 D0          0628*          		RET     NC
0404E6 18 18       0629*          		JR      TRUE_FP
0404E8             0630*  ;
0404E8 CD C0 0C 04 0631*  FNE:			CALL    FCP
0404EC 18 04       0632*          		JR      INE1
0404EE CD B2 0C 04 0633*  INE:			CALL    ICP
0404F2 C8          0634*  INE1:			RET     Z
0404F3 18 0B       0635*          		JR      TRUE_FP
0404F5             0636*  ;
0404F5 CD C0 0C 04 0637*  FEQ:			CALL    FCP
0404F9 18 04       0638*          		JR      IEQ1
0404FB CD B2 0C 04 0639*  IEQ:			CALL    ICP
0404FF C0          0640*  IEQ1:			RET     NZ
040500 21 FF FF FF 0641*  TRUE_FP:			LD      HL,-1
040504 D9          0642*          		EXX
040505 21 FF FF FF 0643*          		LD      HL,-1
040509 D9          0644*          		EXX
04050A AF          0645*          		XOR     A
04050B 4F          0646*          		LD      C,A
04050C C9          0647*          		RET
04050D             0648*  ;
04050D             0649*  ;FUNCTIONS:
04050D             0650*  ;
04050D             0651*  ;Result returned in HLH'L'C (floating point)
04050D             0652*  ;Result returned in HLH'L' (C=0) (integer)
04050D             0653*  ;All registers except IY destroyed.
04050D             0654*  ;
04050D             0655*  ;ABS - Absolute value
04050D             0656*  ;Result is numeric, variable type.
04050D             0657*  ;
04050D CB 7C       0658*  ABSV_FP:			BIT     7,H
04050F C8          0659*          		RET     Z               ;POSITIVE/ZERO
040510 0D          0660*          		DEC     C
040511 0C          0661*          		INC     C
040512 CA 6D 0B 04 0662*          		JP      Z,NEGATE        ;INTEGER
040516 CB BC       0663*          		RES     7,H
040518 C9          0664*          		RET
040519             0665*  ;
040519             0666*  ;NOT - Complement integer.
040519             0667*  ;Result is integer numeric.
040519             0668*  ;
040519 CD 5D 0B 04 0669*  NOTK_FP:			CALL    SFIX_FP
04051D 7C          0670*          		LD      A,H
04051E 2F          0671*          		CPL
04051F 67          0672*          		LD      H,A
040520 7D          0673*          		LD      A,L
040521 2F          0674*          		CPL
040522 6F          0675*          		LD      L,A
040523 D9          0676*          		EXX
040524 7C          0677*          		LD      A,H
040525 2F          0678*          		CPL
040526 67          0679*          		LD      H,A
040527 7D          0680*          		LD      A,L
040528 2F          0681*          		CPL
040529 6F          0682*          		LD      L,A
04052A D9          0683*          		EXX
04052B AF          0684*          		XOR     A               ;NUMERIC MARKER
04052C C9          0685*          		RET
04052D             0686*  ;
04052D             0687*  ;PI - Return PI (3.141592654)
04052D             0688*  ;Result is floating-point numeric.
04052D             0689*  ;
04052D 21 0F 49 00 0690*  PI_FP:			LD      HL,490FH
040531 D9          0691*          		EXX
040532 21 A2 DA 00 0692*          		LD      HL,0DAA2H
040536 D9          0693*          		EXX
040537 0E 81       0694*          		LD      C,81H
040539 AF          0695*          		XOR     A               ;NUMERIC MARKER
04053A C9          0696*          		RET
04053B             0697*  ;
04053B             0698*  ;DEG - Convert radians to degrees
04053B             0699*  ;Result is floating-point numeric.
04053B             0700*  ;
04053B CD 4F 05 04 0701*  DEG_FP:			CALL    FPI180
04053F CD A1 03 04 0702*          		CALL    FMUL
040543 AF          0703*          		XOR     A
040544 C9          0704*          		RET
040545             0705*  ;
040545             0706*  ;RAD - Convert degrees to radians
040545             0707*  ;Result is floating-point numeric.
040545             0708*  ;
040545 CD 4F 05 04 0709*  RAD_FP:			CALL    FPI180
040549 CD F8 02 04 0710*          		CALL    FDIV
04054D AF          0711*          		XOR     A
04054E C9          0712*          		RET
04054F             0713*  ;
04054F             0714*  ;180/PI
04054F             0715*  ;
04054F CD 39 0C 04 0716*  FPI180:			CALL    SFLOAT_FP
040553 11 2E 65 00 0717*          		LD      DE,652EH
040557 D9          0718*          		EXX
040558 11 D3 E0 00 0719*          		LD      DE,0E0D3H
04055C D9          0720*          		EXX
04055D 06 85       0721*          		LD      B,85H
04055F C9          0722*          		RET
040560             0723*  ;
040560             0724*  ;SGN - Return -1, 0 or +1
040560             0725*  ;Result is integer numeric.
040560             0726*  ;
040560 CD 92 0C 04 0727*  SGN_FP:			CALL    TEST_FP
040564 B1          0728*          		OR      C
040565 C8          0729*          		RET     Z               ;ZERO
040566 CB 7C       0730*          		BIT     7,H
040568 C2 00 05 04 0731*          		JP      NZ,TRUE_FP         ;-1
04056C CD B6 0C 04 0732*          		CALL    ZERO_FP
040570 C3 52 0C 04 0733*          		JP      ADD1_FP            ;1
040574             0734*  ;
040574             0735*  ;VAL - Return numeric value of string.
040574             0736*  ;Input: ASCII string at IX
040574             0737*  ;Result is variable type numeric.
040574             0738*  ;
040574 CD D0 0E 04 0739*  VAL_FP:			CALL    SIGNQ
040578 F5          0740*          		PUSH    AF
040579 CD 80 0A 04 0741*          		CALL    CON_FP
04057D F1          0742*          		POP     AF
04057E FE 2D       0743*          		CP      '-'
040580 3E 00       0744*          		LD      A,0             ;NUMERIC MARKER
040582 C0          0745*          		RET     NZ
040583 0D          0746*          		DEC     C
040584 0C          0747*          		INC     C
040585 CA 6D 0B 04 0748*          		JP      Z,NEGATE        ;ZERO/INTEGER
040589 7C          0749*          		LD      A,H
04058A EE 80       0750*          		XOR     80H             ;CHANGE SIGN (FP)
04058C 67          0751*          		LD      H,A
04058D AF          0752*          		XOR     A
04058E C9          0753*          		RET
04058F             0754*  ;
04058F             0755*  ;INT - Floor function
04058F             0756*  ;Result is integer numeric.
04058F             0757*  ;
04058F 0D          0758*  INT_FP_:			DEC     C
040590 0C          0759*          		INC     C
040591 C8          0760*          		RET     Z               ;ZERO/INTEGER
040592 3E 9F       0761*          		LD      A,159
040594 44          0762*          		LD      B,H             ;B7=SIGN BIT
040595 CD 3E 0B 04 0763*          		CALL    FIX
040599 08          0764*          		EX      AF,AF'
04059A A0          0765*          		AND     B
04059B FC 52 0C 04 0766*          		CALL    M,ADD1_FP          ;NEGATIVE NON-INTEGER
04059F 78          0767*          		LD      A,B
0405A0 B7          0768*          		OR      A
0405A1 FC 6D 0B 04 0769*          		CALL    M,NEGATE
0405A5 AF          0770*          		XOR     A
0405A6 4F          0771*          		LD      C,A
0405A7 C9          0772*          		RET
0405A8             0773*  ;
0405A8             0774*  ;SQR - square root
0405A8             0775*  ;Result is floating-point numeric.
0405A8             0776*  ;
0405A8 CD 39 0C 04 0777*  SQR_FP:			CALL    SFLOAT_FP
0405AC CB 7C       0778*  SQR0:			BIT     7,H
0405AE 3E 15       0779*          		LD      A,NGROOT
0405B0 C2 10 01 04 0780*          		JP      NZ,ERROR_FP_        ;"-ve root"
0405B4 0D          0781*          		DEC     C
0405B5 0C          0782*          		INC     C
0405B6 C8          0783*          		RET     Z               ;ZERO
0405B7 CB FC       0784*          		SET     7,H             ;IMPLIED 1
0405B9 CB 41       0785*          		BIT     0,C
0405BB CC 72 0C 04 0786*          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0405BF 79          0787*          		LD      A,C
0405C0 D6 80       0788*          		SUB     80H
0405C2 CB 2F       0789*          		SRA     A               ;HALVE EXPONENT
0405C4 C6 80       0790*          		ADD     A,80H
0405C6 4F          0791*          		LD      C,A
0405C7 C5          0792*          		PUSH    BC              ;SAVE EXPONENT
0405C8 EB          0793*          		EX      DE,HL
0405C9 21 00 00 00 0794*          		LD      HL,0
0405CD 44          0795*          		LD      B,H
0405CE 4D          0796*          		LD      C,L
0405CF D9          0797*          		EXX
0405D0 EB          0798*          		EX      DE,HL
0405D1 21 00 00 00 0799*          		LD      HL,0
0405D5 44          0800*          		LD      B,H
0405D6 4D          0801*          		LD      C,L
0405D7 3E E1       0802*          		LD      A,-31
0405D9 CD 68 0E 04 0803*          		CALL    SQRA            ;ROOT
0405DD D9          0804*          		EXX
0405DE CB 78       0805*          		BIT     7,B
0405E0 D9          0806*          		EXX
0405E1 CC 68 0E 04 0807*          		CALL    Z,SQRA          ;NORMALISE & INC A
0405E5 CD A9 0E 04 0808*          		CALL    SQRB
0405E9 B7          0809*          		OR      A               ;CLEAR CARRY
0405EA CD 16 0E 04 0810*          		CALL    DIVB
0405EE CB 1B       0811*          		RR      E               ;LSB TO CARRY
0405F0 60          0812*          		LD      H,B
0405F1 69          0813*          		LD      L,C
0405F2 D9          0814*          		EXX
0405F3 60          0815*          		LD      H,B
0405F4 69          0816*          		LD      L,C
0405F5 DC 52 0C 04 0817*          		CALL    C,ADD1_FP          ;ROUND UP
0405F9 C1          0818*          		POP     BC              ;RESTORE EXPONENT
0405FA DC 7F 0C 04 0819*          		CALL    C,INCC
0405FE 1F          0820*          		RRA
0405FF 9F          0821*          		SBC     A,A
040600 81          0822*          		ADD     A,C
040601 4F          0823*          		LD      C,A
040602 CB BC       0824*          		RES     7,H             ;POSITIVE
040604 AF          0825*          		XOR     A
040605 C9          0826*          		RET
040606             0827*  ;
040606             0828*  ;TAN - Tangent function
040606             0829*  ;Result is floating-point numeric.
040606             0830*  ;
040606 CD 39 0C 04 0831*  TAN_FP:			CALL    SFLOAT_FP
04060A CD 46 0D 04 0832*          		CALL    PUSH5
04060E CD 30 06 04 0833*          		CALL    COS0
040612 CD 4F 0D 04 0834*          		CALL    POP5
040616 CD 46 0D 04 0835*          		CALL    PUSH5
04061A CD 6A 0C 04 0836*          		CALL    SWAP_FP
04061E CD 3D 06 04 0837*          		CALL    SIN0
040622 CD 4F 0D 04 0838*          		CALL    POP5
040626 CD F8 02 04 0839*          		CALL    FDIV
04062A AF          0840*          		XOR     A               ;NUMERIC MARKER
04062B C9          0841*          		RET
04062C             0842*  ;
04062C             0843*  ;COS - Cosine function
04062C             0844*  ;Result is floating-point numeric.
04062C             0845*  ;
04062C CD 39 0C 04 0846*  COS_FP:			CALL    SFLOAT_FP
040630 CD 95 0B 04 0847*  COS0:			CALL    SCALE
040634 1C          0848*          		INC     E
040635 1C          0849*          		INC     E
040636 7B          0850*          		LD      A,E
040637 18 10       0851*          		JR      SIN1
040639             0852*  ;
040639             0853*  ;SIN - Sine function
040639             0854*  ;Result is floating-point numeric.
040639             0855*  ;
040639 CD 39 0C 04 0856*  SIN_FP:			CALL    SFLOAT_FP
04063D E5          0857*  SIN0:			PUSH    HL              ;H7=SIGN
04063E CD 95 0B 04 0858*          		CALL    SCALE
040642 F1          0859*          		POP     AF
040643 07          0860*          		RLCA
040644 07          0861*          		RLCA
040645 07          0862*          		RLCA
040646 E6 04       0863*          		AND     4
040648 AB          0864*          		XOR     E
040649 F5          0865*  SIN1:			PUSH    AF              ;OCTANT
04064A CB BC       0866*          		RES     7,H
04064C 1F          0867*          		RRA
04064D CD DB 06 04 0868*          		CALL    PIBY4
040651 DC 7C 02 04 0869*          		CALL    C,RSUB          ;X=(PI/4)-X
040655 F1          0870*          		POP     AF
040656 F5          0871*          		PUSH    AF
040657 E6 03       0872*          		AND     3
040659 E2 92 06 04 0873*          		JP      PO,SIN2         ;USE COSINE APPROX.
04065D CD 46 0D 04 0874*          		CALL    PUSH5           ;SAVE X
040661 CD 3E 0D 04 0875*          		CALL    SQUARE          ;PUSH X*X
040665 CD 83 0D 04 0876*          		CALL    POLY
040669 B7 A8       0877*          		DW	0A8B7H          ;a(8)
04066B 11 36       0878*          		DW	3611H
04066D 6D          0879*          		DB	6DH
04066E 26 DE       0880*          		DW	0DE26H          ;a(6)
040670 05 D0       0881*          		DW	0D005H
040672 73          0882*          		DB	73H
040673 C0 80       0883*          		DW	80C0H           ;a(4)
040675 88 08       0884*          		DW	888H
040677 79          0885*          		DB	79H
040678 9D AA       0886*          		DW	0AA9DH          ;a(2)
04067A AA AA       0887*          		DW	0AAAAH
04067C 7D          0888*          		DB	7DH
04067D 00 00       0889*          		DW	0               ;a(0)
04067F 00 00       0890*          		DW	0
040681 80          0891*          		DB	80H
040682 CD 4F 0D 04 0892*          		CALL    POP5
040686 CD 4F 0D 04 0893*          		CALL    POP5
04068A CD A1 03 04 0894*          		CALL    FMUL
04068E C3 B7 06 04 0895*          		JP      SIN3
040692             0896*  ;
040692 CD 3E 0D 04 0897*  SIN2:			CALL    SQUARE          ;PUSH X*X
040696 CD 83 0D 04 0898*          		CALL    POLY
04069A 71 D5       0899*          		DW	0D571H          ;b(8)
04069C 78 4C       0900*          		DW	4C78H
04069E 70          0901*          		DB	70H
04069F AF 94       0902*          		DW	94AFH           ;b(6)
0406A1 03 B6       0903*          		DW	0B603H
0406A3 76          0904*          		DB	76H
0406A4 C8 9C       0905*          		DW	9CC8H           ;b(4)
0406A6 AA 2A       0906*          		DW	2AAAH
0406A8 7B          0907*          		DB	7BH
0406A9 DD FF       0908*          		DW	0FFDDH          ;b(2)
0406AB FF FF       0909*          		DW	0FFFFH
0406AD 7E          0910*          		DB	7EH
0406AE 00 00       0911*          		DW	0               ;b(0)
0406B0 00 00       0912*          		DW	0
0406B2 80          0913*          		DB	80H
0406B3 CD 4F 0D 04 0914*          		CALL    POP5
0406B7 F1          0915*  SIN3:			POP     AF
0406B8 E6 04       0916*          		AND     4
0406BA C8          0917*          		RET     Z
0406BB 0D          0918*          		DEC     C
0406BC 0C          0919*          		INC     C
0406BD C8          0920*          		RET     Z               ;ZERO
0406BE CB FC       0921*          		SET     7,H             ;MAKE NEGATIVE
0406C0 C9          0922*          		RET
0406C1             0923*  ;
0406C1             0924*  ;Floating-point one:
0406C1             0925*  ;
0406C1 21 00 00 00 0926*  FONE_FP:			LD      HL,0
0406C5 D9          0927*          		EXX
0406C6 21 00 00 00 0928*          		LD      HL,0
0406CA D9          0929*          		EXX
0406CB 0E 80       0930*          		LD      C,80H
0406CD C9          0931*          		RET
0406CE             0932*  ;
0406CE 11 00 00 00 0933*  DONE:			LD      DE,0
0406D2 D9          0934*          		EXX
0406D3 11 00 00 00 0935*          		LD      DE,0
0406D7 D9          0936*          		EXX
0406D8 06 80       0937*          		LD      B,80H
0406DA C9          0938*          		RET
0406DB             0939*  ;
0406DB 11 0F 49 00 0940*  PIBY4:			LD      DE,490FH
0406DF D9          0941*          		EXX
0406E0 11 A2 DA 00 0942*          		LD      DE,0DAA2H
0406E4 D9          0943*          		EXX
0406E5 06 7F       0944*          		LD      B,7FH
0406E7 C9          0945*          		RET
0406E8             0946*  ;
0406E8             0947*  ;EXP - Exponential function
0406E8             0948*  ;Result is floating-point numeric.
0406E8             0949*  ;
0406E8 CD 39 0C 04 0950*  EXP_FP:			CALL    SFLOAT_FP
0406EC CD 79 07 04 0951*  EXP0:			CALL    LN2             ;LN(2)
0406F0 D9          0952*          		EXX
0406F1 1D          0953*  	        	DEC     E
0406F2 01 CF D1 00 0954*  		        LD      BC,0D1CFH       ;0.6931471805599453
0406F6 D9          0955*          		EXX
0406F7 E5          0956*          		PUSH    HL              ;H7=SIGN
0406F8 CD A8 0B 04 0957*          		CALL    MOD48           ;"MODULUS"
0406FC F1          0958*          		POP     AF
0406FD CB 7B       0959*          		BIT     7,E
0406FF 28 0B       0960*          		JR      Z,EXP1
040701 17          0961*          		RLA
040702 DA B6 0C 04 0962*          		JP      C,ZERO_FP
040706 3E 18       0963*          		LD      A,EXPRNG
040708 C3 10 01 04 0964*          		JP      ERROR_FP_           ;"Exp range"
04070C             0965*  ;
04070C E6 80       0966*  EXP1:			AND     80H
04070E B3          0967*          		OR      E
04070F F5          0968*          		PUSH    AF              ;INTEGER PART
040710 CB BC       0969*          		RES     7,H
040712 CD 46 0D 04 0970*          		CALL    PUSH5           ;PUSH X*LN(2)
040716 CD 83 0D 04 0971*          		CALL    POLY
04071A 72 40       0972*          		DW	4072H           ;a(7)
04071C 2E 94       0973*          		DW	942EH
04071E 73          0974*          		DB	73H
04071F 65 6F       0975*          		DW	6F65H           ;a(6)
040721 4F 2E       0976*          		DW	2E4FH
040723 76          0977*          		DB	76H
040724 37 6D       0978*          		DW	6D37H           ;a(5)
040726 02 88       0979*          		DW	8802H
040728 79          0980*          		DB	79H
040729 12 E5       0981*          		DW	0E512H          ;a(4)
04072B A0 2A       0982*          		DW	2AA0H
04072D 7B          0983*          		DB	7BH
04072E 14 4F       0984*          		DW	4F14H           ;a(3)
040730 AA AA       0985*          		DW	0AAAAH
040732 7D          0986*          		DB	7DH
040733 56 FD       0987*          		DW	0FD56H          ;a(2)
040735 FF 7F       0988*          		DW	7FFFH
040737 7E          0989*          		DB	7EH
040738 FE FF       0990*          		DW	0FFFEH          ;a(1)
04073A FF FF       0991*          		DW	0FFFFH
04073C 7F          0992*          		DB	7FH
04073D 00 00       0993*          		DW	0               ;a(0)
04073F 00 00       0994*          		DW	0
040741 80          0995*          		DB	80H
040742 CD 4F 0D 04 0996*          		CALL    POP5
040746 F1          0997*          		POP     AF
040747 F5          0998*          		PUSH    AF
040748 F4 6D 07 04 0999*          		CALL    P,RECIP         ;X=1/X
04074C F1          1000*          		POP     AF
04074D F2 55 07 04 1001*          		JP      P,EXP4
040751 E6 7F       1002*          		AND     7FH
040753 ED 44       1003*          		NEG
040755 C6 80       1004*  EXP4:			ADD     A,80H
040757 81          1005*          		ADD     A,C
040758 38 06       1006*          		JR      C,EXP2
04075A F2 B6 0C 04 1007*          		JP      P,ZERO_FP          ;UNDERFLOW
04075E 18 04       1008*          		JR      EXP3
040760 FA 81 0C 04 1009*  EXP2:			JP      M,OFLOW         ;OVERFLOW
040764 C6 80       1010*  EXP3:			ADD     A,80H
040766 CA B6 0C 04 1011*          		JP      Z,ZERO_FP
04076A 4F          1012*          		LD      C,A
04076B AF          1013*          		XOR     A               ;NUMERIC MARKER
04076C C9          1014*          		RET
04076D             1015*  ;
04076D CD CE 06 04 1016*  RECIP:			CALL    DONE
040771 CD 6A 0C 04 1017*  RDIV:			CALL    SWAP_FP
040775 C3 F8 02 04 1018*          		JP      FDIV            ;RECIPROCAL
040779             1019*  ;
040779 11 72 31 00 1020*  LN2:			LD      DE,3172H        ;LN(2)
04077D D9          1021*          		EXX
04077E 11 F8 17 00 1022*          		LD      DE,17F8H
040782 D9          1023*          		EXX
040783 06 7F       1024*          		LD      B,7FH
040785 C9          1025*          		RET
040786             1026*  ;
040786             1027*  ;LN - Natural log.
040786             1028*  ;Result is floating-point numeric.
040786             1029*  ;
040786 CD 39 0C 04 1030*  LN_FP:			CALL    SFLOAT_FP
04078A 3E 16       1031*  LN0:			LD      A,LOGRNG
04078C CB 7C       1032*          		BIT     7,H
04078E C2 10 01 04 1033*          		JP      NZ,ERROR_FP_        ;"Log range"
040792 0C          1034*          		INC     C
040793 0D          1035*          		DEC     C
040794 CA 10 01 04 1036*          		JP      Z,ERROR_FP_
040798 11 04 35 00 1037*          		LD      DE,3504H        ;SQR(2)
04079C D9          1038*          		EXX
04079D 11 33 F3 00 1039*          		LD      DE,0F333H       ;1.41421356237
0407A1 D9          1040*          		EXX
0407A2 CD C9 0C 04 1041*          		CALL    ICP0            ;MANTISSA>SQR(2)?
0407A6 79          1042*          		LD      A,C             ;EXPONENT
0407A7 0E 80       1043*          		LD      C,80H           ;1 <= X < 2
0407A9 38 02       1044*          		JR      C,LN4
0407AB 0D          1045*          		DEC     C
0407AC 3C          1046*          		INC     A
0407AD F5          1047*  LN4:			PUSH    AF              ;SAVE EXPONENT
0407AE CD 5B 0D 04 1048*          		CALL    RATIO           ;X=(X-1)/(X+1)
0407B2 CD 46 0D 04 1049*          		CALL    PUSH5
0407B6 CD 3E 0D 04 1050*  		        CALL    SQUARE          ;PUSH X*X
0407BA CD 83 0D 04 1051*          		CALL    POLY
0407BE 48 CC       1052*          		DW	0CC48H          ;a(9)
0407C0 FB 74       1053*          		DW	74FBH
0407C2 7D          1054*          		DB	7DH
0407C3 AF AE       1055*          		DW	0AEAFH          ;a(7)
0407C5 FF 11       1056*          		DW	11FFH
0407C7 7E          1057*          		DB	7EH
0407C8 8C D9       1058*          		DW	0D98CH          ;a(5)
0407CA CD 4C       1059*          		DW	4CCDH
0407CC 7E          1060*          		DB	7EH
0407CD E3 A9       1061*          		DW	0A9E3H          ;a(3)
0407CF AA 2A       1062*          		DW	2AAAH
0407D1 7F          1063*          		DB	7FH
0407D2 00 00       1064*          		DW	0               ;a(1)
0407D4 00 00       1065*          		DW	0
0407D6 81          1066*          		DB	81H
0407D7 CD 4F 0D 04 1067*          		CALL    POP5
0407DB CD 4F 0D 04 1068*          		CALL    POP5
0407DF CD A1 03 04 1069*          		CALL    FMUL
0407E3 F1          1070*          		POP     AF              ;EXPONENT
0407E4 CD 46 0D 04 1071*          		CALL    PUSH5
0407E8 08          1072*          		EX      AF,AF'
0407E9 CD B6 0C 04 1073*          		CALL    ZERO_FP
0407ED 08          1074*          		EX      AF,AF'
0407EE D6 80       1075*          		SUB     80H
0407F0 28 1F       1076*          		JR      Z,LN3
0407F2 30 02       1077*          		JR      NC,LN1
0407F4 2F          1078*          		CPL
0407F5 3C          1079*          		INC     A
0407F6 67          1080*  LN1:			LD      H,A
0407F7 0E 87       1081*          		LD      C,87H
0407F9 F5          1082*          		PUSH    AF
0407FA CD 19 0C 04 1083*          		CALL    FLOAT_
0407FE CB BC       1084*          		RES     7,H
040800 CD 79 07 04 1085*          		CALL    LN2
040804 CD A1 03 04 1086*          		CALL    FMUL
040808 F1          1087*          		POP     AF
040809 30 06       1088*          		JR      NC,LN3
04080B FA 11 08 04 1089*          		JP      M,LN3
04080F CB FC       1090*          		SET     7,H
040811 CD 4F 0D 04 1091*  LN3:			CALL    POP5
040815 CD 8F 02 04 1092*          		CALL    FADD
040819 AF          1093*          		XOR     A
04081A C9          1094*          		RET
04081B             1095*  ;
04081B             1096*  ;LOG - base-10 logarithm.
04081B             1097*  ;Result is floating-point numeric.
04081B             1098*  ;
04081B CD 86 07 04 1099*  LOG_FP:			CALL    LN_FP
04081F 11 5B 5E 00 1100*          		LD      DE,5E5BH        ;LOG(e)
040823 D9          1101*          		EXX
040824 11 A9 D8 00 1102*          		LD      DE,0D8A9H
040828 D9          1103*          		EXX
040829 06 7E       1104*          		LD      B,7EH
04082B CD A1 03 04 1105*          		CALL    FMUL
04082F AF          1106*          		XOR     A
040830 C9          1107*          		RET
040831             1108*  ;
040831             1109*  ;ASN - Arc-sine
040831             1110*  ;Result is floating-point numeric.
040831             1111*  ;
040831 CD 39 0C 04 1112*  ASN_FP:			CALL    SFLOAT_FP
040835 CD 46 0D 04 1113*          		CALL    PUSH5
040839 CD 36 0D 04 1114*          		CALL    COPY_
04083D CD A1 03 04 1115*          		CALL    FMUL
040841 CD CE 06 04 1116*          		CALL    DONE
040845 CD 7C 02 04 1117*          		CALL    RSUB
040849 CD AC 05 04 1118*          		CALL    SQR0
04084D CD 4F 0D 04 1119*          		CALL    POP5
040851 0C          1120*          		INC     C
040852 0D          1121*          		DEC     C
040853 3E 02       1122*          		LD      A,2
040855 D5          1123*          		PUSH    DE
040856 CA DB 08 04 1124*          		JP      Z,ACS1
04085A D1          1125*          		POP     DE
04085B CD 71 07 04 1126*          		CALL    RDIV
04085F 18 04       1127*          		JR      ATN0
040861             1128*  ;
040861             1129*  ;ATN - arc-tangent
040861             1130*  ;Result is floating-point numeric.
040861             1131*  ;
040861 CD 39 0C 04 1132*  ATN_FP:			CALL    SFLOAT_FP
040865 E5          1133*  ATN0:			PUSH    HL              ;SAVE SIGN
040866 CB BC       1134*          		RES     7,H
040868 11 13 54 00 1135*          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
04086C D9          1136*          		EXX
04086D 11 D0 CC 00 1137*          		LD      DE,0CCD0H
040871 D9          1138*          		EXX
040872 06 7E       1139*          		LD      B,7EH
040874 CD C6 0C 04 1140*          		CALL    FCP0            ;COMPARE
040878 06 00       1141*          		LD      B,0
04087A 38 22       1142*          		JR      C,ATN2
04087C 11 82 1A 00 1143*          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
040880 D9          1144*          		EXX
040881 11 9A 79 00 1145*          		LD      DE,799AH
040885 D9          1146*          		EXX
040886 06 81       1147*          		LD      B,81H
040888 CD C6 0C 04 1148*          		CALL    FCP0            ;COMPARE
04088C 38 0A       1149*          		JR      C,ATN1
04088E CD 6D 07 04 1150*          		CALL    RECIP           ;X=1/X
040892 06 02       1151*          		LD      B,2
040894 C3 9E 08 04 1152*          		JP      ATN2
040898 CD 5B 0D 04 1153*  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
04089C 06 01       1154*          		LD      B,1
04089E C5          1155*  ATN2:			PUSH    BC              ;SAVE FLAG
04089F CD 46 0D 04 1156*          		CALL    PUSH5
0408A3 CD 3E 0D 04 1157*          		CALL    SQUARE          ;PUSH X*X
0408A7 CD 83 0D 04 1158*          		CALL    POLY
0408AB 35 F3       1159*          		DW	0F335H          ;a(13)
0408AD D8 37       1160*          		DW	37D8H
0408AF 7B          1161*          		DB	7BH
0408B0 91 6B       1162*          		DW	6B91H           ;a(11)
0408B2 B9 AA       1163*          		DW	0AAB9H
0408B4 7C          1164*          		DB	7CH
0408B5 DE 41       1165*          		DW	41DEH           ;a(9)
0408B7 97 61       1166*          		DW	6197H
0408B9 7C          1167*          		DB	7CH
0408BA 7B 9D       1168*          		DW	9D7BH           ;a(7)
0408BC 37 92       1169*          		DW	9237H
0408BE 7D          1170*          		DB	7DH
0408BF 5A 2A       1171*          		DW	2A5AH           ;a(5)
0408C1 CC 4C       1172*          		DW	4CCCH
0408C3 7D          1173*          		DB	7DH
0408C4 5C A9       1174*          		DW	0A95CH          ;a(3)
0408C6 AA AA       1175*          		DW	0AAAAH
0408C8 7E          1176*          		DB	7EH
0408C9 00 00       1177*          		DW	0               ;a(1)
0408CB 00 00       1178*          		DW	0
0408CD 80          1179*          		DB	80H
0408CE CD 4F 0D 04 1180*          		CALL    POP5
0408D2 CD 4F 0D 04 1181*          		CALL    POP5
0408D6 CD A1 03 04 1182*          		CALL    FMUL
0408DA F1          1183*          		POP     AF
0408DB CD DB 06 04 1184*  ACS1:			CALL    PIBY4           ;PI/4
0408DF 1F          1185*          		RRA
0408E0 F5          1186*          		PUSH    AF
0408E1 DC 8F 02 04 1187*          		CALL    C,FADD
0408E5 F1          1188*          		POP     AF
0408E6 04          1189*          		INC     B
0408E7 1F          1190*          		RRA
0408E8 DC 7C 02 04 1191*          		CALL    C,RSUB
0408EC F1          1192*          		POP     AF
0408ED B7          1193*          		OR      A
0408EE F0          1194*          		RET     P
0408EF CB FC       1195*          		SET     7,H             ;MAKE NEGATIVE
0408F1 AF          1196*          		XOR     A
0408F2 C9          1197*          		RET
0408F3             1198*  ;
0408F3             1199*  ;ACS - Arc cosine=PI/2-ASN.
0408F3             1200*  ;Result is floating point numeric.
0408F3             1201*  ;
0408F3 CD 31 08 04 1202*  ACS_FP:			CALL    ASN_FP
0408F7 3E 02       1203*          		LD      A,2
0408F9 F5          1204*          		PUSH    AF
0408FA 18 DF       1205*          		JR      ACS1
0408FC             1206*  ;
0408FC             1207*  ;Function STR - convert numeric value to ASCII string.
0408FC             1208*  ;   Inputs: HLH'L'C = integer or floating-point number
0408FC             1209*  ;           DE = address at which to store string
0408FC             1210*  ;           IX = address of @% format control
0408FC             1211*  ;  Outputs: String stored, with NUL terminator
0408FC             1212*  ;
0408FC             1213*  ;First normalise for decimal output:
0408FC             1214*  ;
0408FC CD 39 0C 04 1215*  STR_FP:			CALL    SFLOAT_FP
040900 06 00       1216*          		LD      B,0             ;DEFAULT PT. POSITION
040902 CB 7C       1217*          		BIT     7,H             ;NEGATIVE?
040904 28 06       1218*          		JR      Z,STR10
040906 CB BC       1219*          		RES     7,H
040908 3E 2D       1220*          		LD      A,'-'
04090A 12          1221*          		LD      (DE),A          ;STORE SIGN
04090B 13          1222*          		INC     DE
04090C AF          1223*  STR10:			XOR     A               ;CLEAR A
04090D B9          1224*          		CP      C
04090E 28 4E       1225*          		JR      Z,STR02          ;ZERO
040910 D5          1226*          		PUSH    DE              ;SAVE TEXT POINTER
040911 78          1227*          		LD      A,B
040912 F5          1228*  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
040913 79          1229*          		LD      A,C             ;BINARY EXPONENT
040914 FE A1       1230*          		CP      161
040916 30 1C       1231*          		JR      NC,STR14
040918 FE 9B       1232*          		CP      155
04091A 30 29       1233*          		JR      NC,STR15
04091C 2F          1234*          		CPL
04091D FE E1       1235*          		CP      225
04091F 38 02       1236*          		JR      C,STR13
040921 3E F8       1237*          		LD      A,-8
040923 C6 1C       1238*  STR13:			ADD     A,28
040925 CD B2 0D 04 1239*          		CALL    POWR10
040929 F5          1240*          		PUSH    AF
04092A CD A1 03 04 1241*          		CALL    FMUL
04092E F1          1242*          		POP     AF
04092F 47          1243*          		LD      B,A
040930 F1          1244*          		POP     AF
040931 90          1245*          		SUB     B
040932 18 DE       1246*          		JR      STR11
040934 D6 20       1247*  STR14:			SUB     32
040936 CD B2 0D 04 1248*          		CALL    POWR10
04093A F5          1249*          		PUSH    AF
04093B CD F8 02 04 1250*          		CALL    FDIV
04093F F1          1251*          		POP     AF
040940 47          1252*          		LD      B,A
040941 F1          1253*          		POP     AF
040942 80          1254*          		ADD     A,B
040943 18 CD       1255*          		JR      STR11
040945 3E 09       1256*  STR15:			LD      A,9
040947 CD B2 0D 04 1257*          		CALL    POWR10          ;10^9
04094B CD C6 0C 04 1258*          		CALL    FCP0
04094F 79          1259*          		LD      A,C
040950 C1          1260*          		POP     BC
040951 4F          1261*          		LD      C,A
040952 CB FC       1262*          		SET     7,H             ;IMPLIED 1
040954 DC EE 0C 04 1263*          		CALL    C,X10B          ;X10, DEC B
040958 D1          1264*          		POP     DE              ;RESTORE TEXT POINTER
040959 CB B9       1265*          		RES     7,C
04095B 3E 00       1266*          		LD      A,0
04095D 17          1267*          		RLA                     ;PUT CARRY IN LSB
04095E             1268*  ;
04095E             1269*  ;At this point decimal normalisation has been done,
04095E             1270*  ;now convert to decimal digits:
04095E             1271*  ;      AHLH'L' = number in normalised integer form
04095E             1272*  ;            B = decimal place adjustment
04095E             1273*  ;            C = binary place adjustment (29-33)
04095E             1274*  ;
04095E 0C          1275*  STR02:			INC     C
04095F 08          1276*          		EX      AF,AF'          ;SAVE A
040960 78          1277*          		LD      A,B
040961 DD CB 02 4E 1278*          		BIT     1,(IX+2)
040965 20 08       1279*          		JR      NZ,STR20
040967 AF          1280*          		XOR     A
040968 DD BE 01    1281*          		CP      (IX+1)
04096B 28 0B       1282*          		JR      Z,STR21
04096D 3E F6       1283*          		LD      A,-10
04096F DD 86 01    1284*  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
040972 B7          1285*          		OR      A               ;CLEAR CARRY
040973 FA 78 09 04 1286*          		JP      M,STR21
040977 AF          1287*          		XOR     A
040978 F5          1288*  STR21:			PUSH    AF
040979 08          1289*          		EX      AF,AF'          ;RESTORE A
04097A CD 22 0D 04 1290*  STR22:			CALL    X2              ;RL AHLH'L'
04097E 8F          1291*          		ADC     A,A
04097F FE 0A       1292*          		CP      10
040981 38 05       1293*          		JR      C,STR23
040983 D6 0A       1294*          		SUB     10
040985 D9          1295*          		EXX
040986 2C          1296*          		INC     L               ;SET RESULT BIT
040987 D9          1297*          		EXX
040988 0D          1298*  STR23:			DEC     C
040989 20 EF       1299*          		JR      NZ,STR22        ;32 TIMES
04098B 4F          1300*          		LD      C,A             ;REMAINDER
04098C 7C          1301*          		LD      A,H
04098D E6 3F       1302*          		AND     3FH             ;CLEAR OUT JUNK
04098F 67          1303*          		LD      H,A
040990 F1          1304*          		POP     AF
040991 F2 9F 09 04 1305*          		JP      P,STR24
040995 3C          1306*          		INC     A
040996 20 1C       1307*          		JR      NZ,STR26
040998 3E 04       1308*          		LD      A,4
04099A B9          1309*          		CP      C               ;ROUND UP?
04099B 3E 00       1310*          		LD      A,0
04099D 18 15       1311*          		JR      STR26
04099F F5          1312*  STR24:			PUSH    AF
0409A0 79          1313*          		LD      A,C
0409A1 CE 30       1314*          		ADC     A,'0'           ;ADD CARRY
0409A3 FE 30       1315*          		CP      '0'
0409A5 28 05       1316*          		JR      Z,STR25         ;SUPPRESS ZERO
0409A7 FE 3A       1317*          		CP      '9'+1
0409A9 3F          1318*          		CCF
0409AA 30 08       1319*          		JR      NC,STR26
0409AC E3          1320*  STR25:			EX      (SP),HL
0409AD CB 75       1321*          		BIT     6,L             ;ZERO FLAG
0409AF E3          1322*  		        EX      (SP),HL
0409B0 20 05       1323*          		JR      NZ,STR27
0409B2 3E 30       1324*          		LD      A,'0'
0409B4 3C          1325*  STR26:			INC     A               ;SET +VE
0409B5 3D          1326*          		DEC     A
0409B6 F5          1327*          		PUSH    AF              ;PUT ON STACK + CARRY
0409B7 04          1328*  STR27:			INC     B
0409B8 CD 92 0C 04 1329*          		CALL    TEST_FP            ;IS HLH'L' ZERO?
0409BC 0E 20       1330*          		LD      C,32
0409BE 3E 00       1331*          		LD      A,0
0409C0 20 B8       1332*          		JR      NZ,STR22
0409C2 F1          1333*          		POP     AF
0409C3 F5          1334*          		PUSH    AF
0409C4 3E 00       1335*          		LD      A,0
0409C6 38 B2       1336*          		JR      C,STR22
0409C8             1337*  ;
0409C8             1338*  ;At this point, the decimal character string is stored
0409C8             1339*  ; on the stack. Trailing zeroes are suppressed and may
0409C8             1340*  ; need to be replaced.
0409C8             1341*  ;B register holds decimal point position.
0409C8             1342*  ;Now format number and store as ASCII string:
0409C8             1343*  ;
0409C8 EB          1344*  STR3:			EX      DE,HL           ;STRING POINTER
0409C9 0E FF       1345*          		LD      C,-1            ;FLAG "E"
0409CB 16 01       1346*          		LD      D,1
0409CD DD 5E 01    1347*          		LD      E,(IX+1)        ;f2
0409D0 DD CB 02 46 1348*          		BIT     0,(IX+2)
0409D4 20 35       1349*          		JR      NZ,STR34        ;E MODE
0409D6 DD CB 02 4E 1350*          		BIT     1,(IX+2)
0409DA 28 12       1351*          		JR      Z,STR31
0409DC 78          1352*          		LD      A,B             ;F MODE
0409DD B7          1353*          		OR      A
0409DE 28 05       1354*          		JR      Z,STR30
0409E0 FA E5 09 04 1355*          		JP      M,STR30
0409E4 50          1356*          		LD      D,B
0409E5 7A          1357*  STR30:			LD      A,D
0409E6 DD 86 01    1358*          		ADD     A,(IX+1)
0409E9 5F          1359*          		LD      E,A
0409EA FE 0B       1360*          		CP      11
0409EC 38 19       1361*          		JR      C,STR32
0409EE 78          1362*  STR31:			LD      A,B             ;G MODE
0409EF 11 01 01 00 1363*          		LD      DE,101H
0409F3 B7          1364*          		OR      A
0409F4 FA 0B 0A 04 1365*          		JP      M,STR34
0409F8 28 0D       1366*          		JR      Z,STR32
0409FA DD 7E 01    1367*          		LD      A,(IX+1)
0409FD B7          1368*          		OR      A
0409FE 20 02       1369*          		JR      NZ,STR3A
040A00 3E 0A       1370*          		LD      A,10
040A02 B8          1371*  STR3A:			CP      B
040A03 38 06       1372*          		JR      C,STR34
040A05 50          1373*          		LD      D,B
040A06 58          1374*          		LD      E,B
040A07 78          1375*  STR32:			LD      A,B
040A08 C6 81       1376*          		ADD     A,129
040A0A 4F          1377*          		LD      C,A
040A0B CB FA       1378*  STR34:			SET     7,D
040A0D 1D          1379*          		DEC     E
040A0E 7A          1380*  STR35:			LD      A,D
040A0F B9          1381*          		CP      C
040A10 30 0E       1382*          		JR      NC,STR33
040A12 F1          1383*  STR36:			POP     AF
040A13 28 04       1384*          		JR      Z,STR37
040A15 F2 22 0A 04 1385*          		JP      P,STR38
040A19 F5          1386*  STR37:			PUSH    AF
040A1A 1C          1387*          		INC     E
040A1B 1D          1388*          		DEC     E
040A1C FA 33 0A 04 1389*          		JP      M,STR4
040A20 3E 30       1390*  STR33:			LD      A,'0'
040A22 15          1391*  STR38:			DEC     D
040A23 E2 2A 0A 04 1392*          		JP      PO,STR39
040A27 36 2E       1393*          		LD      (HL),'.'
040A29 23          1394*          		INC     HL
040A2A 77          1395*  STR39:			LD      (HL),A
040A2B 23          1396*          		INC     HL
040A2C 1D          1397*          		DEC     E
040A2D F2 0E 0A 04 1398*          		JP      P,STR35
040A31 18 DF       1399*          		JR      STR36
040A33             1400*  ;
040A33 F1          1401*  STR4:			POP     AF
040A34 0C          1402*  STR40:			INC     C
040A35 4D          1403*          		LD      C,L
040A36 20 28       1404*          		JR      NZ,STR44
040A38 36 45       1405*          		LD      (HL),'E'        ;EXPONENT
040A3A 23          1406*          		INC     HL
040A3B 78          1407*          		LD      A,B
040A3C 3D          1408*          		DEC     A
040A3D F2 46 0A 04 1409*          		JP      P,STR41
040A41 36 2D       1410*          		LD      (HL),'-'
040A43 23          1411*          		INC     HL
040A44 ED 44       1412*          		NEG
040A46 36 30       1413*  STR41:			LD      (HL),'0'
040A48 28 15       1414*          		JR      Z,STR47
040A4A FE 0A       1415*          		CP      10
040A4C 47          1416*          		LD      B,A
040A4D 3E 3A       1417*          		LD      A,':'
040A4F 38 03       1418*          		JR      C,STR42
040A51 23          1419*          		INC     HL
040A52 36 30       1420*          		LD      (HL),'0'
040A54 34          1421*  STR42:			INC     (HL)
040A55 BE          1422*          		CP      (HL)
040A56 20 05       1423*          		JR      NZ,STR43
040A58 36 30       1424*          		LD      (HL),'0'
040A5A 2B          1425*          		DEC     HL
040A5B 34          1426*          		INC     (HL)
040A5C 23          1427*          		INC     HL
040A5D 10 F5       1428*  STR43:			DJNZ    STR42
040A5F 23          1429*  STR47:			INC     HL
040A60 EB          1430*  STR44:			EX      DE,HL
040A61 C9          1431*        			RET
040A62             1432*  ;
040A62             1433*  ;Support subroutines:
040A62             1434*  ;
040A62 DD 46 04    1435*  DLOAD5:			LD      B,(IX+4)
040A65 D9          1436*          		EXX
040A66 DD 5E 00    1437*          		LD      E,(IX+0)
040A69 DD 56 01    1438*          		LD      D,(IX+1)
040A6C D9          1439*          		EXX
040A6D DD 5E 02    1440*          		LD      E,(IX+2)
040A70 DD 56 03    1441*          		LD      D,(IX+3)
040A73 C9          1442*          		RET
040A74             1443*  ;
040A74 DD 46 06    1444*  DLOAD5_SPL:		LD      B,(IX+6)
040A77 D9          1445*  			EXX
040A78 DD 17 00    1446*  			LD	DE, (IX+0)
040A7B D9          1447*  			EXX
040A7C DD 17 03    1448*  			LD	DE, (IX+3)
040A7F C9          1449*  			RET
040A80             1450*  ;
040A80             1451*  ;CON_FP - Get unsigned numeric constant from ASCII string.
040A80             1452*  ;   Inputs: ASCII string at (IX).
040A80             1453*  ;  Outputs: Variable-type result in HLH'L'C
040A80             1454*  ;           IX updated (points to delimiter)
040A80             1455*  ;           A7 = 0 (numeric marker)
040A80             1456*  ;
040A80 CD B6 0C 04 1457*  CON_FP:			CALL    ZERO_FP            ;INITIALISE TO ZERO
040A84 0E 00       1458*          		LD      C,0             ;TRUNCATION COUNTER
040A86 CD 14 0B 04 1459*          		CALL    UINT          ;GET INTEGER PART
040A8A FE 2E       1460*          		CP      '.'
040A8C 06 00       1461*          		LD      B,0             ;DECL. PLACE COUNTER
040A8E CC 12 0B 04 1462*          		CALL    Z,NUMBIX        ;GET FRACTION PART
040A92 FE 45       1463*          		CP      'E'
040A94 3E 00       1464*          		LD      A,0             ;INITIALISE EXPONENT
040A96 CC E0 0A 04 1465*          		CALL    Z,GETEXP        ;GET EXPONENT
040A9A CB 7C       1466*          		BIT     7,H
040A9C 20 08       1467*          		JR      NZ,CON0         ;INTEGER OVERFLOW
040A9E B7          1468*          		OR      A
040A9F 20 05       1469*          		JR      NZ,CON0         ;EXPONENT NON-ZERO
040AA1 B8          1470*          		CP      B
040AA2 20 02       1471*          		JR      NZ,CON0         ;DECIMAL POINT
040AA4 B9          1472*          		CP      C
040AA5 C8          1473*          		RET     Z               ;INTEGER
040AA6 90          1474*  CON0:			SUB     B
040AA7 81          1475*          		ADD     A,C
040AA8 0E 9F       1476*          		LD      C,159
040AAA CD 19 0C 04 1477*          		CALL    FLOAT_
040AAE CB BC       1478*          		RES     7,H             ;DITCH IMPLIED 1
040AB0 B7          1479*          		OR      A
040AB1 C8          1480*          		RET     Z               ;DONE
040AB2 FA C0 0A 04 1481*          		JP      M,CON2          ;NEGATIVE EXPONENT
040AB6 CD B2 0D 04 1482*          		CALL    POWR10
040ABA CD A1 03 04 1483*          		CALL    FMUL            ;SCALE
040ABE AF          1484*          		XOR     A
040ABF C9          1485*          		RET
040AC0 FE DA       1486*  CON2:			CP      -38
040AC2 38 0C       1487*          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
040AC4 ED 44       1488*          		NEG
040AC6 CD B2 0D 04 1489*          		CALL    POWR10
040ACA CD F8 02 04 1490*          		CALL    FDIV            ;SCALE
040ACE AF          1491*          		XOR     A
040ACF C9          1492*          		RET
040AD0 F5          1493*  CON3:			PUSH    AF
040AD1 3E 26       1494*          		LD      A,38
040AD3 CD B2 0D 04 1495*          		CALL    POWR10
040AD7 CD F8 02 04 1496*          		CALL    FDIV
040ADB F1          1497*          		POP     AF
040ADC C6 26       1498*          		ADD     A,38
040ADE 18 E0       1499*          		JR      CON2
040AE0             1500*  ;
040AE0             1501*  ;GETEXP - Get decimal exponent from string
040AE0             1502*  ;     Inputs: ASCII string at (IX)
040AE0             1503*  ;             (IX points at 'E')
040AE0             1504*  ;             A = initial value
040AE0             1505*  ;    Outputs: A = new exponent
040AE0             1506*  ;             IX updated.
040AE0             1507*  ;   Destroys: A,A',IX,F,F'
040AE0             1508*  ;
040AE0 C5          1509*  GETEXP:			PUSH    BC              ;SAVE REGISTERS
040AE1 47          1510*          		LD      B,A             ;INITIAL VALUE
040AE2 0E 02       1511*          		LD      C,2             ;2 DIGITS MAX
040AE4 DD 23       1512*          		INC     IX              ;BUMP PAST 'E'
040AE6 CD D0 0E 04 1513*          		CALL    SIGNQ
040AEA 08          1514*          		EX      AF,AF'          ;SAVE EXPONENT SIGN
040AEB CD C6 0E 04 1515*  GETEX1:			CALL    DIGITQ
040AEF 38 18       1516*          		JR      C,GETEX2
040AF1 78          1517*          		LD      A,B             ;B=B*10
040AF2 87          1518*          		ADD     A,A
040AF3 87          1519*          		ADD     A,A
040AF4 80          1520*          		ADD     A,B
040AF5 87          1521*          		ADD     A,A
040AF6 47          1522*          		LD      B,A
040AF7 DD 7E 00    1523*          		LD      A,(IX)          ;GET BACK DIGIT
040AFA DD 23       1524*          		INC     IX
040AFC E6 0F       1525*          		AND     0FH             ;MASK UNWANTED BITS
040AFE 80          1526*          		ADD     A,B             ;ADD IN DIGIT
040AFF 47          1527*          		LD      B,A
040B00 0D          1528*          		DEC     C
040B01 F2 EB 0A 04 1529*          		JP      P,GETEX1
040B05 06 64       1530*          		LD      B,100           ;FORCE OVERFLOW
040B07 18 E2       1531*          		JR      GETEX1
040B09 08          1532*  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
040B0A FE 2D       1533*          		CP      '-'
040B0C 78          1534*          		LD      A,B
040B0D C1          1535*          		POP     BC              ;RESTORE
040B0E C0          1536*          		RET     NZ
040B0F ED 44       1537*          		NEG                     ;NEGATE EXPONENT
040B11 C9          1538*          		RET
040B12             1539*  ;
040B12             1540*  ;UINT: Get unsigned integer from string.
040B12             1541*  ;    Inputs: string at (IX)
040B12             1542*  ;            C = truncated digit count
040B12             1543*  ;                (initially zero)
040B12             1544*  ;            B = total digit count
040B12             1545*  ;            HLH'L' = initial value
040B12             1546*  ;   Outputs: HLH'L' = number (binary integer)
040B12             1547*  ;            A = delimiter.
040B12             1548*  ;            B, C & IX updated
040B12             1549*  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
040B12             1550*  ;
040B12 DD 23       1551*  NUMBIX:			INC     IX
040B14 CD C6 0E 04 1552*  UINT:			CALL    DIGITQ
040B18 D8          1553*          		RET     C
040B19 04          1554*          		INC     B               ;INCREMENT DIGIT COUNT
040B1A DD 23       1555*          		INC     IX
040B1C CD 0F 0D 04 1556*          		CALL    X10             ;*10 & COPY OLD VALUE
040B20 38 15       1557*          		JR      C,NUMB1         ;OVERFLOW
040B22 0D          1558*          		DEC     C               ;SEE IF TRUNCATED
040B23 0C          1559*          		INC     C
040B24 20 11       1560*          		JR      NZ,NUMB1        ;IMPORTANT!
040B26 E6 0F       1561*          		AND     0FH
040B28 D9          1562*          		EXX
040B29 06 00       1563*          		LD      B,0
040B2B 4F          1564*          		LD      C,A
040B2C 52 09       1565*          		ADD.S   HL,BC           ;ADD IN DIGIT
040B2E D9          1566*          		EXX
040B2F 30 E3       1567*          		JR      NC,UINT
040B31 52 23       1568*          		INC.S   HL              ;CARRY
040B33 7C          1569*          		LD      A,H
040B34 B5          1570*          		OR      L
040B35 20 DD       1571*          		JR      NZ,UINT
040B37 0C          1572*  NUMB1:			INC     C               ;TRUNCATION COUNTER
040B38 CD 6D 0C 04 1573*          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
040B3C 18 D6       1574*          		JR      UINT
040B3E             1575*  ;
040B3E             1576*  ;FIX - Fix number to specified exponent value.
040B3E             1577*  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
040B3E             1578*  ;            A = desired exponent (A>C)
040B3E             1579*  ;   Outputs: HLH'L'C = fixed number (unsigned)
040B3E             1580*  ;            fraction shifted into B'C'
040B3E             1581*  ;            A'F' positive if integer input
040B3E             1582*  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
040B3E             1583*  ;
040B3E 08          1584*  FIX:			EX      AF,AF'
040B3F AF          1585*          		XOR     A
040B40 08          1586*          		EX      AF,AF'
040B41 CB FC       1587*          		SET     7,H             ;IMPLIED 1
040B43 CD 72 0C 04 1588*  FIX1:			CALL    DIV2
040B47 B9          1589*          		CP      C
040B48 C8          1590*          		RET     Z
040B49 D2 43 0B 04 1591*          		JP      NC,FIX1
040B4D C3 81 0C 04 1592*          		JP      OFLOW
040B51             1593*  ;
040B51             1594*  ;SFIX - Convert to integer if necessary.
040B51             1595*  ;    Input: Variable-type number in HLH'L'C
040B51             1596*  ;   Output: Integer in HLH'L', C=0
040B51             1597*  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
040B51             1598*  ;
040B51             1599*  ;NEGATE - Negate HLH'L'
040B51             1600*  ;    Destroys: H,L,H',L',F
040B51             1601*  ;
040B51 CD 6A 0C 04 1602*  FIX2:			CALL    SWAP_FP
040B55 CD 5D 0B 04 1603*          		CALL    SFIX_FP
040B59 CD 6A 0C 04 1604*          		CALL    SWAP_FP
040B5D 0D          1605*  SFIX_FP:			DEC     C
040B5E 0C          1606*          		INC     C
040B5F C8          1607*          		RET     Z               ;INTEGER/ZERO
040B60 CB 7C       1608*          		BIT     7,H             ;SIGN
040B62 F5          1609*          		PUSH    AF
040B63 3E 9F       1610*          		LD      A,159
040B65 CD 3E 0B 04 1611*          		CALL    FIX
040B69 F1          1612*          		POP     AF
040B6A 0E 00       1613*          		LD      C,0
040B6C C8          1614*          		RET     Z
040B6D B7          1615*  NEGATE:			OR      A               ;CLEAR CARRY
040B6E D9          1616*          		EXX
040B6F D5          1617*  NEG0:			PUSH    DE
040B70 EB          1618*          		EX      DE,HL
040B71 21 00 00 00 1619*          		LD      HL,0
040B75 52 ED 52    1620*          		SBC.S   HL,DE
040B78 D1          1621*          		POP     DE
040B79 D9          1622*          		EXX
040B7A D5          1623*          		PUSH    DE
040B7B EB          1624*          		EX      DE,HL
040B7C 21 00 00 00 1625*          		LD      HL,0
040B80 52 ED 52    1626*          		SBC.S   HL,DE
040B83 D1          1627*          		POP     DE
040B84 C9          1628*          		RET
040B85             1629*  ;
040B85             1630*  ;NEG - Negate HLH'L'B'C'
040B85             1631*  ;    Also complements A (used in FADD)
040B85             1632*  ;    Destroys: A,H,L,B',C',H',L',F
040B85             1633*  ;
040B85 D9          1634*  NEG_:			EXX
040B86 2F          1635*          		CPL
040B87 E5          1636*          		PUSH    HL
040B88 B7          1637*          		OR      A               ;CLEAR CARRY
040B89 21 00 00 00 1638*          		LD      HL,0
040B8D 52 ED 42    1639*          		SBC.S   HL,BC
040B90 44          1640*          		LD      B,H
040B91 4D          1641*          		LD      C,L
040B92 E1          1642*          		POP     HL
040B93 18 DA       1643*          		JR      NEG0
040B95             1644*  ;
040B95             1645*  ;SCALE - Trig scaling.
040B95             1646*  ;MOD48 - 48-bit floating-point "modulus" (remainder).
040B95             1647*  ;   Inputs: HLH'L'C unsigned floating-point dividend
040B95             1648*  ;           DED'E'B'C'B unsigned 48-bit FP divisor
040B95             1649*  ;  Outputs: HLH'L'C floating point remainder (H7=1)
040B95             1650*  ;           E = quotient (bit 7 is sticky)
040B95             1651*  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
040B95             1652*  ;FLO48 - Float unsigned number (48 bits)
040B95             1653*  ;    Input/output in HLH'L'B'C'C
040B95             1654*  ;   Destroys: C,H,L,B',C',H',L',F
040B95             1655*  ;
040B95 3E 96       1656*  SCALE:			LD      A,150
040B97 B9          1657*          		CP      C
040B98 3E 17       1658*          		LD      A,ACLOST
040B9A DA 10 01 04 1659*          		JP      C,ERROR_FP_         ;"Accuracy lost"
040B9E CD DB 06 04 1660*          		CALL    PIBY4
040BA2 D9          1661*          		EXX
040BA3 01 69 21 00 1662*          		LD      BC,2169H        ;3.141592653589793238
040BA7 D9          1663*          		EXX
040BA8 CB FA       1664*  MOD48:			SET     7,D             ;IMPLIED 1
040BAA CB FC       1665*          		SET     7,H
040BAC 79          1666*          		LD      A,C
040BAD 0E 00       1667*          		LD      C,0             ;INIT QUOTIENT
040BAF DD 21 00 00 1668*          		LD      IX,0
       00          
040BB4 DD E5       1669*          		PUSH    IX              ;PUT ZERO ON STACK
040BB6 B8          1670*          		CP      B
040BB7 38 46       1671*          		JR      C,MOD485        ;DIVIDEND<DIVISOR
040BB9 D9          1672*  MOD481:			EXX                     ;CARRY=0 HERE
040BBA E3          1673*          		EX      (SP),HL
040BBB 52 ED 42    1674*          		SBC.S   HL,BC
040BBE E3          1675*          		EX      (SP),HL
040BBF 52 ED 52    1676*          		SBC.S   HL,DE
040BC2 D9          1677*          		EXX
040BC3 52 ED 52    1678*          		SBC.S   HL,DE
040BC6 30 0C       1679*          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
040BC8 D9          1680*          		EXX
040BC9 E3          1681*          		EX      (SP),HL
040BCA 52 09       1682*          		ADD.S   HL,BC
040BCC E3          1683*          		EX      (SP),HL
040BCD 52 ED 5A    1684*          		ADC.S   HL,DE
040BD0 D9          1685*          		EXX
040BD1 52 ED 5A    1686*          		ADC.S   HL,DE
040BD4 3F          1687*  MOD482:			CCF
040BD5 CB 11       1688*          		RL      C               ;QUOTIENT
040BD7 30 02       1689*          		JR      NC,MOD483
040BD9 CB F9       1690*          		SET     7,C             ;STICKY BIT
040BDB 3D          1691*  MOD483:			DEC     A
040BDC B8          1692*          		CP      B
040BDD 38 1F       1693*          		JR      C,MOD484        ;DIVIDEND<DIVISOR
040BDF E3          1694*          		EX      (SP),HL
040BE0 52 29       1695*          		ADD.S   HL,HL           ;DIVIDEND * 2
040BE2 E3          1696*          		EX      (SP),HL
040BE3 D9          1697*          		EXX
040BE4 52 ED 6A    1698*          		ADC.S   HL,HL
040BE7 D9          1699*          		EXX
040BE8 52 ED 6A    1700*          		ADC.S   HL,HL
040BEB 30 CC       1701*          		JR      NC,MOD481       ;AGAIN
040BED B7          1702*          		OR      A
040BEE D9          1703*          		EXX
040BEF E3          1704*          		EX      (SP),HL
040BF0 52 ED 42    1705*          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
040BF3 E3          1706*          		EX      (SP),HL
040BF4 52 ED 52    1707*          		SBC.S   HL,DE
040BF7 D9          1708*          		EXX
040BF8 52 ED 52    1709*          		SBC.S   HL,DE
040BFB B7          1710*          		OR      A
040BFC 18 D6       1711*          		JR      MOD482
040BFE             1712*  ;
040BFE 3C          1713*  MOD484:			INC     A
040BFF 59          1714*  MOD485:			LD      E,C             ;QUOTIENT
040C00 4F          1715*          		LD      C,A             ;REMAINDER EXPONENT
040C01 D9          1716*          		EXX
040C02 C1          1717*          		POP     BC
040C03 D9          1718*          		EXX
040C04 CB 7C       1719*  FLO48:			BIT     7,H
040C06 C0          1720*          		RET     NZ
040C07 D9          1721*          		EXX
040C08 CB 21       1722*          		SLA     C
040C0A CB 10       1723*          		RL      B
040C0C 52 ED 6A    1724*          		ADC.S   HL,HL
040C0F D9          1725*          		EXX
040C10 52 ED 6A    1726*          		ADC.S   HL,HL
040C13 0D          1727*          		DEC     C
040C14 C2 04 0C 04 1728*          		JP      NZ,FLO48
040C18 C9          1729*          		RET
040C19             1730*  ;
040C19             1731*  ;Float unsigned number
040C19             1732*  ;    Input/output in HLH'L'C
040C19             1733*  ;   Destroys: C,H,L,H',L',F
040C19             1734*  ;
040C19 CB 7C       1735*  FLOAT_:			BIT     7,H
040C1B C0          1736*          		RET     NZ
040C1C D9          1737*          		EXX                     ;SAME AS "X2"
040C1D 52 29       1738*          		ADD.S   HL,HL           ;TIME-CRITICAL
040C1F D9          1739*          		EXX                     ;REGION
040C20 52 ED 6A    1740*          		ADC.S   HL,HL           ;(BENCHMARKS)
040C23 0D          1741*          		DEC     C
040C24 C2 19 0C 04 1742*          		JP      NZ,FLOAT_
040C28 C9          1743*          		RET
040C29             1744*  ;
040C29             1745*  ;SFLOAT - Convert to floating-point if necessary.
040C29             1746*  ;    Input: Variable-type number in HLH'L'C
040C29             1747*  ;    Output: Floating-point in HLH'L'C
040C29             1748*  ;    Destroys: A,C,H,L,H',L',F
040C29             1749*  ;
040C29 08          1750*  FLOATA:			EX      AF,AF'
040C2A             1751*          		; ADD     A,(RTABLE-DTABLE)/3
040C2A C6 2A       1752*          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
040C2C 08          1753*          		EX      AF,AF'
040C2D CD 6A 0C 04 1754*  FLOAT2:			CALL    SWAP_FP
040C31 CD 39 0C 04 1755*          		CALL    SFLOAT_FP
040C35 CD 6A 0C 04 1756*          		CALL    SWAP_FP
040C39 0D          1757*  SFLOAT_FP:			DEC     C
040C3A 0C          1758*          		INC     C
040C3B C0          1759*          		RET     NZ              ;ALREADY FLOATING-POINT
040C3C CD 92 0C 04 1760*          		CALL    TEST_FP
040C40 C8          1761*          		RET     Z               ;ZERO
040C41 7C          1762*          		LD      A,H
040C42 B7          1763*          		OR      A
040C43 FC 6D 0B 04 1764*          		CALL    M,NEGATE
040C47 0E 9F       1765*          		LD      C,159
040C49 CD 19 0C 04 1766*          		CALL    FLOAT_
040C4D B7          1767*          		OR      A
040C4E F8          1768*          		RET     M               ;NEGATIVE
040C4F CB BC       1769*          		RES     7,H
040C51 C9          1770*          		RET
040C52             1771*  ;
040C52             1772*  ;ROUND UP
040C52             1773*  ;Return with carry set if 32-bit overflow
040C52             1774*  ;   Destroys: H,L,B',C',H',L',F
040C52             1775*  ;
040C52 D9          1776*  ADD1_FP:			EXX
040C53 01 01 00 00 1777*          		LD      BC,1
040C57 52 09       1778*          		ADD.S   HL,BC
040C59 D9          1779*          		EXX
040C5A D0          1780*          		RET     NC
040C5B C5          1781*          		PUSH    BC
040C5C 01 01 00 00 1782*          		LD      BC,1
040C60 52 09       1783*          		ADD.S   HL,BC
040C62 C1          1784*          		POP     BC
040C63 C9          1785*          		RET
040C64             1786*  ;
040C64             1787*  ;ODD - Add one if even, leave alone if odd.
040C64             1788*  ; (Used to perform unbiassed rounding, i.e.
040C64             1789*  ;  number is rounded up half the time)
040C64             1790*  ;    Destroys: L',F (carry cleared)
040C64             1791*  ;
040C64 B7          1792*  ODD:			OR      A               ;CLEAR CARRY
040C65 D9          1793*          		EXX
040C66 CB C5       1794*          		SET     0,L             ;MAKE ODD
040C68 D9          1795*          		EXX
040C69 C9          1796*          		RET
040C6A             1797*  ;
040C6A             1798*  ;SWAP_FP - Swap arguments.
040C6A             1799*  ;    Exchanges DE,HL D'E',H'L' and B,C
040C6A             1800*  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
040C6A             1801*  ;SWAP1 - Swap DEHL with D'E'H'L'
040C6A             1802*  ;    Destroys: D,E,H,L,D',E',H',L'
040C6A             1803*  ;
040C6A 79          1804*  SWAP_FP:			LD      A,C
040C6B 48          1805*          		LD      C,B
040C6C 47          1806*          		LD      B,A
040C6D EB          1807*  SWAP1:			EX      DE,HL
040C6E D9          1808*          		EXX
040C6F EB          1809*          		EX      DE,HL
040C70 D9          1810*          		EXX
040C71 C9          1811*          		RET
040C72             1812*  ;
040C72             1813*  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
040C72             1814*  ; INCC - destroys C,F
040C72             1815*  ; OFLOW
040C72             1816*  ;
040C72 CD 2B 0D 04 1817*  DIV2:			CALL    D2
040C76 D9          1818*          		EXX
040C77 CB 18       1819*          		RR      B
040C79 CB 19       1820*          		RR      C
040C7B 08          1821*          		EX      AF,AF'
040C7C B0          1822*          		OR      B
040C7D 08          1823*          		EX      AF,AF'
040C7E D9          1824*          		EXX
040C7F 0C          1825*  INCC:			INC     C
040C80 C0          1826*          		RET     NZ
040C81 3E 14       1827*  OFLOW:			LD      A,TOOBIG_FP
040C83 C3 10 01 04 1828*          		JP      ERROR_FP_           ;"Too big"
040C87             1829*  ;
040C87             1830*  ; FTEST - Test for zero & sign
040C87             1831*  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
040C87             1832*  ;
040C87 CD 92 0C 04 1833*  FTEST_FP:			CALL    TEST_FP
040C8B C8          1834*          		RET     Z
040C8C 7C          1835*          		LD      A,H
040C8D E6 80       1836*          		AND     10000000B
040C8F F6 40       1837*          		OR      01000000B
040C91 C9          1838*          		RET
040C92             1839*  ;
040C92             1840*  ; TEST_FP - Test HLH'L' for zero.
040C92             1841*  ;     Output: Z-flag set & A=0 if HLH'L'=0
040C92             1842*  ;     Destroys: A,F
040C92             1843*  ;
040C92 7C          1844*  TEST_FP:			LD      A,H
040C93 B5          1845*          		OR      L
040C94 D9          1846*          		EXX
040C95 B4          1847*          		OR      H
040C96 B5          1848*          		OR      L
040C97 D9          1849*          		EXX
040C98 C9          1850*          		RET
040C99             1851*  ;
040C99             1852*  ; FCOMP - Compare two numbers
040C99             1853*  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
040C99             1854*  ;
040C99 78          1855*  FCOMP_FP:			LD      A,B
040C9A B1          1856*          		OR      C               ;Both integer?
040C9B 20 0B       1857*          		JR      NZ,FCOMP1
040C9D CD B2 0C 04 1858*          		CALL    ICP
040CA1 3E 00       1859*  FCOMP0:			LD      A,0
040CA3 C8          1860*          		RET     Z               ;Equal
040CA4 3E 80       1861*          		LD      A,80H
040CA6 1F          1862*          		RRA
040CA7 C9          1863*          		RET
040CA8             1864*  ;
040CA8 CD 2D 0C 04 1865*  FCOMP1:			CALL    FLOAT2          ;Float both
040CAC CD C0 0C 04 1866*          		CALL    FCP
040CB0 18 EF       1867*          		JR      FCOMP0
040CB2             1868*  ;
040CB2             1869*  ; Integer and floating point compare.
040CB2             1870*  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
040CB2             1871*  ; Result pre-set to FALSE
040CB2             1872*  ; ICP1, FCP1 destroy A,F
040CB2             1873*  ;
040CB2             1874*  ; ZERO - Return zero.
040CB2             1875*  ;  Destroys: A,C,H,L,H',L'
040CB2             1876*  ;
040CB2 CD E5 0C 04 1877*  ICP:			CALL    ICP1
040CB6 3E 00       1878*  ZERO_FP:			LD      A,0
040CB8 D9          1879*          		EXX
040CB9 67          1880*          		LD      H,A
040CBA 6F          1881*  	       		LD      L,A
040CBB D9          1882*          		EXX
040CBC 67          1883*        			LD      H,A
040CBD 6F          1884*       			LD      L,A
040CBE 4F          1885*  	    		LD      C,A
040CBF C9          1886*          		RET
040CC0             1887*  ;
040CC0 CD D7 0C 04 1888*  FCP:			CALL    FCP1
040CC4 18 F0       1889*          		JR      ZERO_FP            ;PRESET FALSE
040CC6             1890*  ;
040CC6 79          1891*  FCP0:			LD      A,C
040CC7 B8          1892*          		CP      B               ;COMPARE EXPONENTS
040CC8 C0          1893*          		RET     NZ
040CC9             1894*  ICP0:
040CC9 52 ED 52    1895*  			SBC.S   HL,DE           ;COMP MANTISSA MSB
040CCC 52 19       1896*          		ADD.S   HL,DE
040CCE C0          1897*          		RET     NZ
040CCF D9          1898*          		EXX
040CD0 52 ED 52    1899*          		SBC.S   HL,DE           ;COMP MANTISSA LSB
040CD3 52 19       1900*          		ADD.S   HL,DE
040CD5 D9          1901*          		EXX
040CD6 C9          1902*          		RET
040CD7             1903*  ;
040CD7 7C          1904*  FCP1:			LD      A,H
040CD8 AA          1905*          		XOR     D
040CD9 7C          1906*          		LD      A,H
040CDA 17          1907*          		RLA
040CDB F8          1908*          		RET     M
040CDC 30 E8       1909*          		JR      NC,FCP0
040CDE CD C6 0C 04 1910*          		CALL    FCP0
040CE2 C8          1911*          		RET     Z               ;** V0.1 BUG FIX
040CE3 3F          1912*          		CCF
040CE4 C9          1913*          		RET
040CE5             1914*  ;
040CE5 7C          1915*  ICP1:			LD      A,H
040CE6 AA          1916*          		XOR     D
040CE7 F2 C9 0C 04 1917*          		JP      P,ICP0
040CEB 7C          1918*          		LD      A,H
040CEC 17          1919*          		RLA
040CED C9          1920*          		RET
040CEE             1921*  ;
040CEE             1922*  ; ADD - Integer add.
040CEE             1923*  ; Carry, sign & zero flags valid on exit
040CEE             1924*  ;     Destroys: H,L,H',L',F
040CEE             1925*  ;
040CEE 05          1926*  X10B:			DEC     B
040CEF 0C          1927*          		INC     C
040CF0 CD 37 0D 04 1928*  X5:			CALL    COPY0
040CF4 CD 2A 0D 04 1929*          		CALL    D2C
040CF8 CD 2A 0D 04 1930*          		CALL    D2C
040CFC 08          1931*          		EX      AF,AF'          ;SAVE CARRY
040CFD D9          1932*  ADD_:			EXX
040CFE 52 19       1933*          		ADD.S   HL,DE
040D00 D9          1934*          		EXX
040D01 52 ED 5A    1935*          		ADC.S   HL,DE
040D04 C9          1936*          		RET
040D05             1937*  ;
040D05             1938*  ; SUB - Integer subtract.
040D05             1939*  ; Carry, sign & zero flags valid on exit
040D05             1940*  ;     Destroys: H,L,H',L',F
040D05             1941*  ;
040D05 D9          1942*  SUB_:			EXX
040D06 B7          1943*          		OR      A
040D07 52 ED 52    1944*          		SBC.S   HL,DE
040D0A D9          1945*          		EXX
040D0B 52 ED 52    1946*          		SBC.S   HL,DE
040D0E C9          1947*          		RET
040D0F             1948*  ;
040D0F             1949*  ; X10 - unsigned integer * 10
040D0F             1950*  ;    Inputs: HLH'L' initial value
040D0F             1951*  ;   Outputs: DED'E' = initial HLH'L'
040D0F             1952*  ;            Carry bit set if overflow
040D0F             1953*  ;            If carry not set HLH'L'=result
040D0F             1954*  ;  Destroys: D,E,H,L,D',E',H',L',F
040D0F             1955*  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
040D0F             1956*  ;     Carry set if MSB=1 before shift.
040D0F             1957*  ;     Sign set if MSB=1 after shift.
040D0F             1958*  ;     Destroys: H,L,H',L',F
040D0F             1959*  ;
040D0F CD 37 0D 04 1960*  X10:			CALL    COPY0           ;DED'E'=HLH'L'
040D13 CD 22 0D 04 1961*          		CALL    X2
040D17 D8          1962*          		RET     C               ;TOO BIG
040D18 CD 22 0D 04 1963*          		CALL    X2
040D1C D8          1964*          		RET     C
040D1D CD FD 0C 04 1965*          		CALL    ADD_
040D21 D8          1966*          		RET     C
040D22 D9          1967*  X2:			EXX
040D23 52 29       1968*          		ADD.S   HL,HL
040D25 D9          1969*          		EXX
040D26 52 ED 6A    1970*          		ADC.S   HL,HL
040D29 C9          1971*          		RET
040D2A             1972*  ;
040D2A             1973*  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
040D2A             1974*  ;     Carry set if LSB=1 before shift.
040D2A             1975*  ;     Destroys: H,L,H',L',F
040D2A             1976*  ;
040D2A 0C          1977*  D2C:			INC     C
040D2B CB 3C       1978*  D2:			SRL     H
040D2D CB 1D       1979*          		RR      L
040D2F D9          1980*          		EXX
040D30 CB 1C       1981*          		RR      H
040D32 CB 1D       1982*          		RR      L
040D34 D9          1983*          		EXX
040D35 C9          1984*          		RET
040D36             1985*  ;
040D36             1986*  ; COPY - COPY HLH'L'C INTO DED'E'B
040D36             1987*  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
040D36             1988*  ;
040D36 41          1989*  COPY_:			LD      B,C
040D37 54          1990*  COPY0:			LD      D,H
040D38 5D          1991*          		LD      E,L
040D39 D9          1992*          		EXX
040D3A 54          1993*          		LD      D,H
040D3B 5D          1994*          		LD      E,L
040D3C D9          1995*          		EXX
040D3D C9          1996*          		RET
040D3E             1997*  ;
040D3E             1998*  ; SQUARE - PUSH X*X
040D3E             1999*  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
040D3E             2000*  ;   Destroys: SP,IX
040D3E             2001*  ;
040D3E CD 36 0D 04 2002*  SQUARE:			CALL    COPY_
040D42 CD A1 03 04 2003*          		CALL    FMUL
040D46 DD E1       2004*  PUSH5:			POP     IX              ;RETURN ADDRESS
040D48 C5          2005*          		PUSH    BC
040D49 E5          2006*          		PUSH    HL
040D4A D9          2007*          		EXX
040D4B E5          2008*          		PUSH    HL
040D4C D9          2009*          		EXX
040D4D DD E9       2010*          		JP      (IX)            ;"RETURN"
040D4F             2011*  ;
040D4F             2012*  ; POP5 - POP DED'E'B OFF STACK.
040D4F             2013*  ;   Destroys: A,B,D,E,D',E',SP,IX
040D4F             2014*  ;
040D4F DD E1       2015*  POP5:			POP     IX              ;RETURN ADDRESS
040D51 D9          2016*          		EXX
040D52 D1          2017*          		POP     DE
040D53 D9          2018*          		EXX
040D54 D1          2019*          		POP     DE
040D55 79          2020*          		LD      A,C
040D56 C1          2021*          		POP     BC
040D57 41          2022*          		LD      B,C
040D58 4F          2023*          		LD      C,A
040D59 DD E9       2024*          		JP      (IX)            ;"RETURN"
040D5B             2025*  ;
040D5B             2026*  ; RATIO - Calculate (X-1)/(X+1)
040D5B             2027*  ;     Inputs: X in HLH'L'C
040D5B             2028*  ;    Outputs: (X-1)/(X+1) in HLH'L'C
040D5B             2029*  ;   Destroys: Everything except IY,SP,I
040D5B             2030*  ;
040D5B CD 46 0D 04 2031*  RATIO:			CALL    PUSH5           ;SAVE X
040D5F CD CE 06 04 2032*          		CALL    DONE
040D63 CD 8F 02 04 2033*          		CALL    FADD
040D67 CD 4F 0D 04 2034*          		CALL    POP5            ;RESTORE X
040D6B CD 46 0D 04 2035*          		CALL    PUSH5           ;SAVE X+1
040D6F CD 6A 0C 04 2036*          		CALL    SWAP_FP
040D73 CD CE 06 04 2037*          		CALL    DONE
040D77 CD 76 02 04 2038*          		CALL    FSUB
040D7B CD 4F 0D 04 2039*          		CALL    POP5            ;RESTORE X+1
040D7F C3 F8 02 04 2040*          		JP      FDIV
040D83             2041*  ;
040D83             2042*  ; POLY - Evaluate a polynomial.
040D83             2043*  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
040D83             2044*  ;             Polynomial coefficients follow call.
040D83             2045*  ;    Outputs: Result in HLH'L'C
040D83             2046*  ;   Destroys: Everything except IY,SP,I
040D83             2047*  ; Routine terminates on finding a coefficient >=1.
040D83             2048*  ; Note: The last coefficient is EXECUTED on return
040D83             2049*  ;       so must contain only innocuous bytes!
040D83             2050*  ;
040D83 DD 21 03 00 2051*  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
040D88 DD 39       2052*          		ADD     IX, SP
040D8A DD E3       2053*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
040D8C             2054*  ;
040D8C CD 62 0A 04 2055*          		CALL    DLOAD5          		; Load the first coefficient from (IX)
040D90 CD A1 03 04 2056*  POLY1:			CALL    FMUL
040D94 11 05 00 00 2057*          		LD      DE, 5				; Skip to the next coefficient
040D98 DD 19       2058*          		ADD     IX, DE
040D9A CD 62 0A 04 2059*          		CALL    DLOAD5          		; Load the second coefficient from (IX)
040D9E DD E3       2060*          		EX      (SP), IX			; Restore the SP just in case we need to return
040DA0 04          2061*          		INC     B
040DA1 05          2062*          		DEC     B               		; Test B for end byte (80h)
040DA2 FA 8F 02 04 2063*          		JP      M,FADD				; Yes, so add and return
040DA6 CD 8F 02 04 2064*          		CALL    FADD				; No, so add
040DAA CD 74 0A 04 2065*          		CALL    DLOAD5_SPL			; Load X from SP
040DAE DD E3       2066*          		EX      (SP), IX			; IX: Points to the inline list of coefficients
040DB0 18 DE       2067*          		JR      POLY1				; And loop
040DB2             2068*  ;
040DB2             2069*  ; POWR10 - Calculate power of ten.
040DB2             2070*  ;     Inputs: A=power of 10 required (A<128)
040DB2             2071*  ;             A=binary exponent to be exceeded (A>=128)
040DB2             2072*  ;    Outputs: DED'E'B = result
040DB2             2073*  ;             A = actual power of ten returned
040DB2             2074*  ;   Destroys: A,B,D,E,A',D',E',F,F'
040DB2             2075*  ;
040DB2 3C          2076*  POWR10:			INC     A
040DB3 08          2077*          		EX      AF,AF'
040DB4 E5          2078*          		PUSH    HL
040DB5 D9          2079*          		EXX
040DB6 E5          2080*          		PUSH    HL
040DB7 D9          2081*          		EXX
040DB8 CD CE 06 04 2082*          		CALL    DONE
040DBC CD 6A 0C 04 2083*          		CALL    SWAP_FP
040DC0 AF          2084*          		XOR     A
040DC1 08          2085*  POWR11:			EX      AF,AF'
040DC2 3D          2086*          		DEC     A
040DC3 28 26       2087*          		JR      Z,POWR14        ;EXIT TYPE 1
040DC5 F2 CD 0D 04 2088*          		JP      P,POWR13
040DC9 B9          2089*          		CP      C
040DCA 38 1F       2090*          		JR      C,POWR14        ;EXIT TYPE 2
040DCC 3C          2091*          		INC     A
040DCD 08          2092*  POWR13:			EX      AF,AF'
040DCE 3C          2093*          		INC     A
040DCF CB FC       2094*          		SET     7,H
040DD1 CD F0 0C 04 2095*          		CALL    X5
040DD5 30 06       2096*          		JR      NC,POWR12
040DD7 08          2097*          		EX      AF,AF'
040DD8 CD 2A 0D 04 2098*          		CALL    D2C
040DDC 08          2099*          		EX      AF,AF'
040DDD 08          2100*  POWR12:			EX      AF,AF'
040DDE DC 52 0C 04 2101*          		CALL    C,ADD1_FP          ;ROUND UP
040DE2 0C          2102*          		INC     C
040DE3 FA C1 0D 04 2103*          		JP      M,POWR11
040DE7 C3 81 0C 04 2104*          		JP      OFLOW
040DEB CD 6A 0C 04 2105*  POWR14:			CALL    SWAP_FP
040DEF CB BA       2106*          		RES     7,D
040DF1 D9          2107*          		EXX
040DF2 E1          2108*          		POP     HL
040DF3 D9          2109*          		EXX
040DF4 E1          2110*          		POP     HL
040DF5 08          2111*          		EX      AF,AF'
040DF6 C9          2112*          		RET
040DF7             2113*  ;
040DF7             2114*  ; DIVA, DIVB - DIVISION PRIMITIVE.
040DF7             2115*  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
040DF7             2116*  ;               Remainder in H'L'HL
040DF7             2117*  ;     Inputs: A = loop counter (normally -32)
040DF7             2118*  ;     Destroys: A,D,E,H,L,D',E',H',L',F
040DF7             2119*  ;
040DF7 B7          2120*  DIVA:			OR      A               ;CLEAR CARRY
040DF8             2121*  DIV0:
040DF8 52 ED 42    2122*  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
040DFB D9          2123*          		EXX
040DFC 52 ED 42    2124*          		SBC.S   HL,BC
040DFF D9          2125*          		EXX
040E00 30 07       2126*          		JR      NC,DIV1
040E02 52 09       2127*          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
040E04 D9          2128*          		EXX
040E05 52 ED 4A    2129*          		ADC.S   HL,BC
040E08 D9          2130*          		EXX
040E09 3F          2131*  DIV1:			CCF
040E0A CB 13       2132*  DIVC:			RL      E               ;SHIFT RESULT INTO DE
040E0C CB 12       2133*          		RL      D
040E0E D9          2134*          		EXX
040E0F CB 13       2135*          		RL      E
040E11 CB 12       2136*          		RL      D
040E13 D9          2137*          		EXX
040E14 3C          2138*          		INC     A
040E15 F0          2139*          		RET     P
040E16             2140*  DIVB:
040E16 52 ED 6A    2141*  			ADC.S   HL,HL           ;DIVIDEND*2
040E19 D9          2142*          		EXX
040E1A 52 ED 6A    2143*          		ADC.S   HL,HL
040E1D D9          2144*          		EXX
040E1E 30 D8       2145*          		JR      NC,DIV0
040E20 B7          2146*          		OR      A
040E21 52 ED 42    2147*          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
040E24 D9          2148*          		EXX
040E25 52 ED 42    2149*          		SBC.S   HL,BC
040E28 D9          2150*          		EXX
040E29 37          2151*          		SCF
040E2A C3 0A 0E 04 2152*          		JP      DIVC
040E2E             2153*  ;
040E2E             2154*  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
040E2E             2155*  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
040E2E             2156*  ;    Inputs: A = loop counter (usually -32)
040E2E             2157*  ;            H'L'HL = 0
040E2E             2158*  ;    Destroys: D,E,H,L,D',E',H',L',A,F
040E2E             2159*  ;
040E2E B7          2160*  MULA:			OR      A               ;CLEAR CARRY
040E2F D9          2161*  MUL0:			EXX
040E30 CB 1A       2162*          		RR      D               ;MULTIPLIER/2
040E32 CB 1B       2163*          		RR      E
040E34 D9          2164*          		EXX
040E35 CB 1A       2165*          		RR      D
040E37 CB 1B       2166*          		RR      E
040E39 30 07       2167*          		JR      NC,MUL1
040E3B 52 09       2168*          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
040E3D D9          2169*          		EXX
040E3E 52 ED 4A    2170*          		ADC.S   HL,BC
040E41 D9          2171*          		EXX
040E42 3C          2172*  MUL1:			INC     A
040E43 F0          2173*          		RET     P
040E44 D9          2174*  MULB:			EXX
040E45 CB 1C       2175*          		RR      H               ;PRODUCT/2
040E47 CB 1D       2176*          		RR      L
040E49 D9          2177*          		EXX
040E4A CB 1C       2178*          		RR      H
040E4C CB 1D       2179*          		RR      L
040E4E C3 2F 0E 04 2180*          		JP      MUL0
040E52             2181*  ;
040E52             2182*  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
040E52             2183*  ;     Function: B'C'BC = SQR (D'E'DE)
040E52             2184*  ;     Inputs: A = loop counter (normally -31)
040E52             2185*  ;             B'C'BCH'L'HL initialised to 0
040E52             2186*  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
040E52             2187*  ;
040E52             2188*  SQR1:
040E52 52 ED 42    2189*  			SBC.S   HL,BC
040E55 D9          2190*          		EXX
040E56 52 ED 42    2191*          		SBC.S   HL,BC
040E59 D9          2192*          		EXX
040E5A 0C          2193*          		INC     C
040E5B 30 09       2194*          		JR      NC,SQR2
040E5D 0D          2195*          		DEC     C
040E5E 52 09       2196*          		ADD.S   HL,BC
040E60 D9          2197*          		EXX
040E61 52 ED 4A    2198*          		ADC.S   HL,BC
040E64 D9          2199*          		EXX
040E65 0D          2200*          		DEC     C
040E66 3C          2201*  SQR2:			INC     A
040E67 F0          2202*          		RET     P
040E68 CB 21       2203*  SQRA:			SLA     C
040E6A CB 10       2204*          		RL      B
040E6C D9          2205*          		EXX
040E6D CB 11       2206*          		RL      C
040E6F CB 10       2207*          		RL      B
040E71 D9          2208*          		EXX
040E72 0C          2209*          		INC     C
040E73 CB 23       2210*          		SLA     E
040E75 CB 12       2211*          		RL      D
040E77 D9          2212*          		EXX
040E78 CB 13       2213*          		RL      E
040E7A CB 12       2214*          		RL      D
040E7C D9          2215*          		EXX
040E7D 52 ED 6A    2216*          		ADC.S   HL,HL
040E80 D9          2217*          		EXX
040E81 52 ED 6A    2218*          		ADC.S   HL,HL
040E84 D9          2219*          		EXX
040E85 CB 23       2220*          		SLA     E
040E87 CB 12       2221*          		RL      D
040E89 D9          2222*          		EXX
040E8A CB 13       2223*          		RL      E
040E8C CB 12       2224*          		RL      D
040E8E D9          2225*          		EXX
040E8F 52 ED 6A    2226*          		ADC.S   HL,HL
040E92 D9          2227*          		EXX
040E93 52 ED 6A    2228*          		ADC.S   HL,HL
040E96 D9          2229*          		EXX
040E97 D2 52 0E 04 2230*          		JP      NC,SQR1
040E9B B7          2231*  SQR3:			OR      A
040E9C 52 ED 42    2232*          		SBC.S   HL,BC
040E9F D9          2233*          		EXX
040EA0 52 ED 42    2234*          		SBC.S   HL,BC
040EA3 D9          2235*          		EXX
040EA4 0C          2236*          		INC     C
040EA5 C3 66 0E 04 2237*          		JP      SQR2
040EA9             2238*  ;
040EA9             2239*  SQRB:
040EA9 52 29       2240*  			ADD.S   HL,HL
040EAB D9          2241*          		EXX
040EAC 52 ED 6A    2242*          		ADC.S   HL,HL
040EAF D9          2243*          		EXX
040EB0 38 E9       2244*          		JR      C,SQR3
040EB2 3C          2245*          		INC     A
040EB3 0C          2246*          		INC     C
040EB4 52 ED 42    2247*          		SBC.S   HL,BC
040EB7 D9          2248*          		EXX
040EB8 52 ED 42    2249*          		SBC.S   HL,BC
040EBB D9          2250*          		EXX
040EBC D0          2251*          		RET     NC
040EBD 52 09       2252*          		ADD.S   HL,BC
040EBF D9          2253*          		EXX
040EC0 52 ED 4A    2254*          		ADC.S   HL,BC
040EC3 D9          2255*          		EXX
040EC4 0D          2256*          		DEC     C
040EC5 C9          2257*          		RET
040EC6             2258*  ;
040EC6 DD 7E 00    2259*  DIGITQ:			LD      A,(IX)
040EC9 FE 3A       2260*          		CP      '9'+1
040ECB 3F          2261*          		CCF
040ECC D8          2262*          		RET     C
040ECD FE 30       2263*          		CP      '0'
040ECF C9          2264*          		RET
040ED0             2265*  ;
040ED0 DD 7E 00    2266*  SIGNQ:			LD      A,(IX)
040ED3 DD 23       2267*          		INC     IX
040ED5 FE 20       2268*          		CP      ' '
040ED7 28 F7       2269*          		JR      Z,SIGNQ
040ED9 FE 2B       2270*          		CP      '+'
040EDB C8          2271*          		RET     Z
040EDC FE 2D       2272*          		CP      '-'
040EDE C8          2273*          		RET     Z
040EDF DD 2B       2274*          		DEC     IX
040EE1 C9          2275*          		RET
040EE2             0066       include "functions.inc"
040EE2             0001*  
040EE2             0002*      MACRO printChar char
040EE2             0003*          LD A, char
040EE2             0004*          RST.LIL 10h
040EE2             0005*      ENDMACRO
040EE2             0006*  
040EE2             0007*  ; test the sign of HL
040EE2             0008*  ; inputs: HL obviously
040EE2             0009*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
040EE2             0010*  ; destroys: flags
040EE2             0011*      MACRO sign_hlu
040EE2             0012*          add hl,de
040EE2             0013*          or a
040EE2             0014*          sbc hl,de
040EE2             0015*      ENDMACRO
040EE2             0016*  
040EE2             0017*  ; Simulated call to subroutine at HL
040EE2             0018*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
040EE2             0019*  ; outputs: whatever the subroutine does, including HL and BC
040EE2             0020*  ; destroys: only what the subroutine does, but always BC
040EE2             0021*      MACRO callHL
040EE2             0022*          ld bc,$+7     ; Address of first instruction after the jump
040EE2             0023*          push bc       ; which constitutes the return address
040EE2             0024*          jp   (hl)     ; Jump to the address in HL
040EE2             0025*      ENDMACRO
040EE2             0026*  
040EE2             0027*  ; Simulated call to subroutine at IX
040EE2             0028*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
040EE2             0029*  ; outputs: whatever the subroutine does, including IX and BC
040EE2             0030*  ; destroys: only what the subroutine does, but always BC
040EE2             0031*      MACRO callIX
040EE2             0032*          ld bc,$+7     ; Address of first instruction after the jump
040EE2             0033*          push bc       ; which constitutes the return address
040EE2             0034*          jp   (ix)     ; Jump to the address in IX
040EE2             0035*      ENDMACRO
040EE2             0036*  
040EE2             0037*  ; Simulated call to soubroutinte at IY
040EE2             0038*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
040EE2             0039*  ; outputs: whatever the subroutine does, including IY and BC
040EE2             0040*  ; destroys: only what the subroutine does, but always BC
040EE2             0041*      MACRO callIY
040EE2             0042*          ld bc,$+7     ; Address of first instruction after the jump
040EE2             0043*          push bc       ; which constitutes the return address
040EE2             0044*          jp   (iy)     ; Jump to the address in IY
040EE2             0045*      ENDMACRO
040EE2             0046*  
040EE2             0047*  ; put the value in HLU into the accumulator
040EE2             0048*  ; destroys: af
040EE2             0049*      MACRO HLU_TO_A
040EE2             0050*          push hl ; 4 cycles
040EE2             0051*          inc sp ; 1 cycle
040EE2             0052*          pop af  ; 4 cycles
040EE2             0053*          dec sp ; 1 cycle
040EE2             0054*                 ; 10 cycles total
040EE2             0055*      ENDMACRO
040EE2             0056*  
040EE2             0057*  A_TO_HLU:
040EE2             0058*      ; call is 7 cycles
040EE2 22 EF 0E 04 0059*      ld (@scratch),hl ; 7 cycles
040EE6 32 F1 0E 04 0060*      ld (@scratch+2),a ; 5 cycles
040EEA 2A EF 0E 04 0061*      ld hl,(@scratch) ; 7 cycles
040EEE C9          0062*      ret ; 6 cycles
040EEF             0063*          ; 25 cycles total
040EEF 00 00 00    0064*  @scratch: dl 0
040EF2             0065*  
040EF2             0066*      ; TODO: implement this
040EF2             0067*      ; MACRO A_TO_HLU
040EF2             0068*      ;     push.s af
040EF2             0069*      ;     inc sp
040EF2             0070*      ;     push.s hl
040EF2             0071*      ;     pop hl
040EF2             0072*      ;     inc sp
040EF2             0073*      ;     inc sp
040EF2             0074*      ; ENDMACRO
040EF2             0075*  
040EF2             0076*      MACRO PUSH_ALL
040EF2             0077*          ex af,af'
040EF2             0078*          exx
040EF2             0079*          push af
040EF2             0080*          push hl
040EF2             0081*          push bc
040EF2             0082*          push de
040EF2             0083*  
040EF2             0084*          ex af,af'
040EF2             0085*          exx
040EF2             0086*          push af
040EF2             0087*          push hl
040EF2             0088*          push bc
040EF2             0089*          push de
040EF2             0090*          push ix
040EF2             0091*          push iy
040EF2             0092*      ENDMACRO
040EF2             0093*  
040EF2             0094*      MACRO POP_ALL
040EF2             0095*          pop iy
040EF2             0096*          pop ix
040EF2             0097*          pop de
040EF2             0098*          pop bc
040EF2             0099*          pop hl
040EF2             0100*          pop af
040EF2             0101*          ex af,af'
040EF2             0102*          exx
040EF2             0103*  
040EF2             0104*          pop de
040EF2             0105*          pop bc
040EF2             0106*          pop hl
040EF2             0107*          pop af
040EF2             0108*          ex af,af'
040EF2             0109*          exx
040EF2             0110*      ENDMACRO
040EF2             0111*  
040EF2             0112*  ; Print a zero-terminated string inline with code, e.g.:
040EF2             0113*  ;
040EF2             0114*  ;    call printInline
040EF2             0115*  ;    ASCIZ "Hello, world!\r\n"
040EF2             0116*  ;
040EF2             0117*  ; Destroys: HL,AF
040EF2             0118*  printInline:
040EF2 E1          0119*      pop hl ; get the return address = pointer to start of string
040EF3 CD F9 0E 04 0120*      call printString ; HL advances to end of string
040EF7 E5          0121*      push hl ; restore the return address = pointer to end of string
040EF8 C9          0122*      ret
040EF9             0123*  
040EF9             0124*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
040EF9             0125*  ; Print a zero-terminated string
040EF9             0126*  ; HL: Pointer to string
040EF9             0127*  printString:
040EF9 C5          0128*  	PUSH	BC
040EFA 01 00 00 00 0129*  	LD		BC,0
040EFE 3E 00       0130*  	LD 	 	A,0
040F00 5B DF       0131*  	RST.LIL 18h
040F02 C1          0132*  	POP		BC
040F03 C9          0133*  	RET
040F04             0134*  ; print a VDU sequence
040F04             0135*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
040F04             0136*  sendVDUsequence:
040F04 C5          0137*  	PUSH	BC
040F05 01 00 00 00 0138*  	LD		BC, 0
040F09 4E          0139*  	LD		C, (HL)
040F0A 5B DF       0140*  	RST.LIL	18h
040F0C C1          0141*  	POP		BC
040F0D C9          0142*  	RET
040F0E             0143*  ; Print Newline sequence to VDP
040F0E             0144*  printNewLine:
040F0E F5          0145*      push af ; for some reason rst.lil 10h sets carry flag
040F0F 3E 0D       0146*  	LD	A, '\r'
040F11 5B D7       0147*  	RST.LIL 10h
040F13 3E 0A       0148*  	LD	A, '\n'
040F15 5B D7       0149*  	RST.LIL 10h
040F17 F1          0150*      pop af
040F18 C9          0151*  	RET
040F19             0152*  
040F19             0153*  ; Print a 24-bit HEX number
040F19             0154*  ; HLU: Number to print
040F19             0155*  printHex24:
040F19             0156*      HLU_TO_A
040F19 E5          0001*M         push hl ; 4 cycles
040F1A 33          0002*M         inc sp ; 1 cycle
040F1B F1          0003*M         pop af  ; 4 cycles
040F1C 3B          0004*M         dec sp ; 1 cycle
040F1D             0005*M                ; 10 cycles total
040F1D CD 27 0F 04 0157*  	CALL	printHex8
040F21             0158*  ; Print a 16-bit HEX number
040F21             0159*  ; HL: Number to print
040F21             0160*  printHex16:
040F21 7C          0161*  	LD		A,H
040F22 CD 27 0F 04 0162*  	CALL	printHex8
040F26 7D          0163*  	LD		A,L
040F27             0164*  ; Print an 8-bit HEX number
040F27             0165*  ; A: Number to print
040F27             0166*  printHex8:
040F27 4F          0167*  	LD		C,A
040F28 1F          0168*  	RRA
040F29 1F          0169*  	RRA
040F2A 1F          0170*  	RRA
040F2B 1F          0171*  	RRA
040F2C CD 31 0F 04 0172*  	CALL	@F
040F30 79          0173*  	LD		A,C
040F31             0174*  @@:
040F31 E6 0F       0175*  	AND		0Fh
040F33 C6 90       0176*  	ADD		A,90h
040F35 27          0177*  	DAA
040F36 CE 40       0178*  	ADC		A,40h
040F38 27          0179*  	DAA
040F39 5B D7       0180*  	RST.LIL	10h
040F3B C9          0181*  	RET
040F3C             0182*  
040F3C             0183*  printHexA:
040F3C F5          0184*      push af
040F3D C5          0185*      push bc
040F3E CD 27 0F 04 0186*      call printHex8
040F42 3E 20       0187*      ld a,' '
040F44 5B D7       0188*      rst.lil 10h
040F46 C1          0189*      pop bc
040F47 F1          0190*      pop af
040F48 C9          0191*      ret
040F49             0192*  
040F49             0193*  printHexHL:
040F49 F5          0194*      push af
040F4A C5          0195*      push bc
040F4B CD 21 0F 04 0196*      call printHex16
040F4F 3E 20       0197*      ld a,' '
040F51 5B D7       0198*      rst.lil 10h
040F53 C1          0199*      pop bc
040F54 F1          0200*      pop af
040F55 C9          0201*      ret
040F56             0202*  
040F56             0203*  printHexUHL:
040F56 F5          0204*      push af
040F57 C5          0205*      push bc
040F58 CD 19 0F 04 0206*      call printHex24
040F5C 3E 20       0207*      ld a,' '
040F5E 5B D7       0208*      rst.lil 10h
040F60 C1          0209*      pop bc
040F61 F1          0210*      pop af
040F62 C9          0211*      ret
040F63             0212*  
040F63             0213*  printHexAUHL:
040F63 F5          0214*      push af
040F64 C5          0215*      push bc
040F65 CD 27 0F 04 0216*      call printHex8
040F69 3E 2E       0217*      ld a,'.'
040F6B 5B D7       0218*      rst.lil 10h
040F6D CD 19 0F 04 0219*      call printHex24
040F71 3E 20       0220*      ld a,' '
040F73 5B D7       0221*      rst.lil 10h
040F75 C1          0222*      pop bc
040F76 F1          0223*      pop af
040F77 C9          0224*      ret
040F78             0225*  
040F78             0226*  printHexABHL:
040F78             0227*  ; preserve registers
040F78 C5          0228*      push bc ; b will be ok c will not
040F79 F5          0229*      push af ; will get totally destroyed
040F7A             0230*  ; print a
040F7A CD 27 0F 04 0231*      call printHex8
040F7E             0232*  ; print b
040F7E 78          0233*      ld a,b
040F7F CD 27 0F 04 0234*      call printHex8
040F83             0235*  ; print hl
040F83 CD 21 0F 04 0236*      call printHex16
040F87             0237*  ; restore registers
040F87 F1          0238*      pop af
040F88 C1          0239*      pop bc
040F89 C9          0240*      ret
040F8A             0241*  
040F8A             0242*  printHexBHL:
040F8A             0243*  ; preserve registers
040F8A C5          0244*      push bc ; b will be ok c will not
040F8B F5          0245*      push af ; will get totally destroyed
040F8C             0246*  ; print b
040F8C 78          0247*      ld a,b
040F8D CD 27 0F 04 0248*      call printHex8
040F91             0249*  ; print hl
040F91 CD 21 0F 04 0250*      call printHex16
040F95             0251*  ; restore registers
040F95 F1          0252*      pop af
040F96 C1          0253*      pop bc
040F97 C9          0254*      ret
040F98             0255*  
040F98             0256*  printHexCDE:
040F98             0257*  ; preserve registers
040F98 C5          0258*      push bc ; b will be ok c will not
040F99 F5          0259*      push af ; will get totally destroyed
040F9A             0260*  ; print c
040F9A 79          0261*      ld a,c
040F9B CD 27 0F 04 0262*      call printHex8
040F9F             0263*  ; print de
040F9F EB          0264*      ex de,hl
040FA0 CD 21 0F 04 0265*      call printHex16
040FA4 EB          0266*      ex de,hl
040FA5             0267*  ; restore registers
040FA5 F1          0268*      pop af
040FA6 C1          0269*      pop bc
040FA7 C9          0270*      ret
040FA8             0271*  
040FA8             0272*  printHexUIX:
040FA8             0273*  ; store everything in scratch
040FA8 22 21 14 04 0274*      ld (uhl),hl
040FAC ED 43 24 14 0275*      ld (ubc),bc
       04          
040FB1 ED 53 27 14 0276*      ld (ude),de
       04          
040FB6 DD 22 2A 14 0277*      ld (uix),ix
       04          
040FBB FD 22 2D 14 0278*      ld (uiy),iy
       04          
040FC0 F5          0279*      push af ; fml
040FC1             0280*  
040FC1 21 B8 13 04 0281*      ld hl,str_ixu
040FC5 CD F9 0E 04 0282*      call printString
040FC9 2A 2A 14 04 0283*      ld hl,(uix)
040FCD CD 19 0F 04 0284*      call printHex24
040FD1 CD 0E 0F 04 0285*      call printNewLine
040FD5             0286*  
040FD5             0287*  ; restore everything
040FD5 2A 21 14 04 0288*      ld hl, (uhl)
040FD9 ED 4B 24 14 0289*      ld bc, (ubc)
       04          
040FDE ED 5B 27 14 0290*      ld de, (ude)
       04          
040FE3 DD 2A 2A 14 0291*      ld ix, (uix)
       04          
040FE8 FD 2A 2D 14 0292*      ld iy, (uiy)
       04          
040FED F1          0293*      pop af
040FEE             0294*  ; all done
040FEE C9          0295*      ret
040FEF             0296*  
040FEF             0297*  ; Print a 0x HEX prefix
040FEF             0298*  DisplayHexPrefix:
040FEF 3E 30       0299*  	LD	A, '0'
040FF1 5B D7       0300*  	RST.LIL 10h
040FF3 3E 78       0301*  	LD	A, 'x'
040FF5 5B D7       0302*  	RST.LIL 10h
040FF7 C9          0303*  	RET
040FF8             0304*  
040FF8             0305*      MACRO printDecBC
040FF8             0306*          push hl
040FF8             0307*          push bc
040FF8             0308*          pop hl
040FF8             0309*          call printDec
040FF8             0310*          pop hl
040FF8             0311*      ENDMACRO
040FF8             0312*  
040FF8             0313*      MACRO printDecDE
040FF8             0314*          push hl
040FF8             0315*          push de
040FF8             0316*          pop hl
040FF8             0317*          call printDec
040FF8             0318*          pop hl
040FF8             0319*      ENDMACRO
040FF8             0320*  
040FF8             0321*      MACRO printDecHL
040FF8             0322*          call printDec
040FF8             0323*      ENDMACRO
040FF8             0324*  
040FF8             0325*      MACRO printDecIX
040FF8             0326*          push hl
040FF8             0327*          push ix
040FF8             0328*          pop hl
040FF8             0329*          call printDec
040FF8             0330*          pop hl
040FF8             0331*      ENDMACRO
040FF8             0332*  
040FF8             0333*      MACRO printDecIY
040FF8             0334*          push hl
040FF8             0335*          push iy
040FF8             0336*          pop hl
040FF8             0337*          call printDec
040FF8             0338*          pop hl
040FF8             0339*      ENDMACRO
040FF8             0340*  
040FF8             0341*  
040FF8             0342*  ; Prints the right justified decimal value in HL without leading zeroes
040FF8             0343*  ; HL : Value to print
040FF8             0344*  ; preserves all registers and flags
040FF8             0345*  printDec:
040FF8             0346*  ; BEGIN MY CODE
040FF8             0347*  ; back up all the things
040FF8 F5          0348*      push af
040FF9 C5          0349*      push bc
040FFA D5          0350*      push de
040FFB E5          0351*      push hl
040FFC             0352*  ; END MY CODE
040FFC 11 24 10 04 0353*  	LD	 DE, _printDecBuffer
041000 CD 34 10 04 0354*  	CALL u24_to_ascii
041004             0355*  ; BEGIN MY CODE
041004             0356*  ; replace leading zeroes with spaces
041004 21 24 10 04 0357*      LD	 HL, _printDecBuffer
041008 06 07       0358*      ld   B, 7 ; if HL was 0, we want to keep the final zero
04100A             0359*  @loop:
04100A 7E          0360*      LD	 A, (HL)
04100B FE 30       0361*      CP	 '0'
04100D C2 17 10 04 0362*      JP	 NZ, @done
041011 3E 20       0363*      LD   A, ' '
041013 77          0364*      LD	 (HL), A
041014 23          0365*      INC	 HL
041015             0366*      ; CALL vdu_cursor_forward
041015 10 F3       0367*      DJNZ @loop
041017             0368*  @done:
041017             0369*  ; END MY CODE
041017 21 24 10 04 0370*  	LD	 HL, _printDecBuffer
04101B CD F9 0E 04 0371*  	CALL printString
04101F             0372*  ; BEGIN MY CODE
04101F             0373*  ; restore all the things
04101F E1          0374*      pop hl
041020 D1          0375*      pop de
041021 C1          0376*      pop bc
041022 F1          0377*      pop af
041023             0378*  ; END MY CODE
041023 C9          0379*  	RET
041024 00 00 00 00 0380*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041034             0381*  
041034             0382*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
041034             0383*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
041034             0384*  ; so it will allways be 8 characters length
041034             0385*  ; HL : Value to convert to string
041034             0386*  ; DE : pointer to buffer, at least 8 byte + 0
041034             0387*  u24_to_ascii:
041034 01 80 69 67 0388*  	LD	 BC,-10000000
041038 CD 6B 10 04 0389*  	CALL @one_digit
04103C 01 C0 BD F0 0390*  	LD	 BC,-1000000
041040 CD 6B 10 04 0391*  	CALL @one_digit
041044 01 60 79 FE 0392*  	LD	 BC,-100000
041048 CD 6B 10 04 0393*  	CALL @one_digit
04104C 01 F0 D8 FF 0394*  	LD   BC,-10000
041050 CD 6B 10 04 0395*  	CALL @one_digit
041054 01 18 FC FF 0396*  	LD   BC,-1000
041058 CD 6B 10 04 0397*  	CALL @one_digit
04105C 01 9C FF FF 0398*  	LD   BC,-100
041060 CD 6B 10 04 0399*  	CALL @one_digit
041064 0E F6       0400*  	LD   C,-10
041066 CD 6B 10 04 0401*  	CALL @one_digit
04106A 48          0402*  	LD   C,B
04106B             0403*  @one_digit:
04106B 3E 2F       0404*  	LD   A,'0'-1
04106D             0405*  @divide_me:
04106D 3C          0406*  	INC  A
04106E 09          0407*  	ADD  HL,BC
04106F 38 FC       0408*  	JR   C,@divide_me
041071 ED 42       0409*  	SBC  HL,BC
041073 12          0410*  	LD   (DE),A
041074 13          0411*  	INC  DE
041075 C9          0412*  	RET
041076             0413*  
041076             0414*  print_u24:
041076 D5          0415*      push de
041077 E5          0416*      push hl
041078 11 24 10 04 0417*      ld de,_printDecBuffer
04107C CD 34 10 04 0418*      call u24_to_ascii
041080 21 24 10 04 0419*      ld hl,_printDecBuffer
041084 CD F9 0E 04 0420*      call printString
041088 3E 20       0421*      ld a,' '
04108A 5B D7       0422*      rst.lil 10h
04108C E1          0423*      pop hl
04108D D1          0424*      pop de
04108E C9          0425*      ret
04108F             0426*  
04108F             0427*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
04108F             0428*  ; HL : Value to convert to string (integer part in H, fractional part in L)
04108F             0429*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
04108F             0430*  u168_to_ascii:
04108F             0431*  ; add a leading space to make room for sign flag if needed
04108F 3E 20       0432*      ld a,' '
041091 12          0433*      ld (de),a
041092 13          0434*      inc de
041093             0435*  ; Convert integer part
041093 E5          0436*      push hl               ; Save HL (well need the fractional part later)
041094 CD 7D 15 04 0437*      call hlu_udiv256    ; Shift to get integer portion in HL
041098 01 F0 D8 FF 0438*      ld   bc, -10000
04109C CD BF 10 04 0439*      call @one_int
0410A0 01 18 FC FF 0440*      ld   bc, -1000
0410A4 CD BF 10 04 0441*      call @one_int
0410A8 01 9C FF FF 0442*      ld   bc, -100
0410AC CD BF 10 04 0443*      call @one_int
0410B0 0E F6       0444*      ld   c, -10
0410B2 CD BF 10 04 0445*      call @one_int
0410B6 48          0446*      ld   c, b
0410B7 CD BF 10 04 0447*      call @one_int
0410BB C3 CA 10 04 0448*      jp   @frac            ; Jump to fractional part conversion
0410BF             0449*  @one_int:
0410BF 3E 2F       0450*      ld   a, '0' - 1       ; Start ASCII character at '0'
0410C1             0451*  @divide_me:
0410C1 3C          0452*      inc  a
0410C2 09          0453*      add  hl, bc           ; Accumulate until overflow
0410C3 38 FC       0454*      jr   c, @divide_me
0410C5 ED 42       0455*      sbc  hl, bc           ; Remove excess after overflow
0410C7 12          0456*      ld   (de), a          ; Store ASCII digit
0410C8 13          0457*      inc  de
0410C9 C9          0458*      ret
0410CA             0459*  ; Convert fractional part
0410CA             0460*  @frac:
0410CA 3E 2E       0461*      ld   a, '.'           ; Decimal point
0410CC 12          0462*      ld   (de), a
0410CD 13          0463*      inc  de
0410CE E1          0464*      pop  hl               ; Restore HL with original fraction
0410CF 06 03       0465*      ld   b, 3             ; Loop counter for 3 fractional digits
0410D1             0466*  @frac_loop:
0410D1 26 0A       0467*      ld   h, 10            ; Load multiplier for fractional part
0410D3 ED 6C       0468*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0410D5 3E 30       0469*      ld   a, '0'
0410D7 84          0470*      add  a, h             ; Convert integer part to ASCII
0410D8 12          0471*      ld   (de), a
0410D9 13          0472*      inc  de
0410DA 10 F5       0473*      djnz @frac_loop       ; Repeat for each fractional digit
0410DC             0474*  ; Add null terminator
0410DC AF          0475*      xor  a                ; Null terminator
0410DD 12          0476*      ld   (de), a
0410DE C9          0477*      ret
0410DF             0478*  
0410DF             0479*  print_u168:
0410DF D5          0480*      push de
0410E0 E5          0481*      push hl
0410E1 11 24 10 04 0482*      ld de,_printDecBuffer
0410E5 CD 8F 10 04 0483*      call u168_to_ascii
0410E9 21 24 10 04 0484*      ld hl,_printDecBuffer
0410ED CD F9 0E 04 0485*      call printString
0410F1 E1          0486*      pop hl
0410F2 D1          0487*      pop de
0410F3 C9          0488*      ret
0410F4             0489*  
0410F4             0490*  ; signed version of u168_to_ascii
0410F4             0491*  s168_to_ascii:
0410F4 D5          0492*      push de ; save starting address of buffer
0410F5 CD 16 15 04 0493*      call hlu_abs
0410F9 F5          0494*      push af ; save sign flag
0410FA CD 8F 10 04 0495*      call u168_to_ascii
0410FE F1          0496*      pop af ; restore sign flag
0410FF D1          0497*      pop de ; restore starting address of buffer
041100 F0          0498*      ret p ; hlu was positive so nothing to do
041101 3E 2D       0499*      ld a,'-'
041103 12          0500*      ld (de),a
041104 C9          0501*      ret
041105             0502*  
041105             0503*  print_s168:
041105 D5          0504*      push de
041106 E5          0505*      push hl
041107 11 24 10 04 0506*      ld de,_printDecBuffer
04110B CD F4 10 04 0507*      call s168_to_ascii
04110F 21 24 10 04 0508*      ld hl,_printDecBuffer
041113 CD F9 0E 04 0509*      call printString
041117 E1          0510*      pop hl
041118 D1          0511*      pop de
041119 C9          0512*      ret
04111A             0513*  
04111A             0514*  print_s168_hl:
04111A F5          0515*      push af
04111B E5          0516*      push hl
04111C CD 05 11 04 0517*      call print_s168
041120 3E 20       0518*      ld a,' '
041122 5B D7       0519*      rst.lil 10h
041124 E1          0520*      pop hl
041125 F1          0521*      pop af
041126 C9          0522*      ret
041127             0523*  
041127             0524*  print_s168_bc:
041127 F5          0525*      push af
041128 C5          0526*      push bc
041129 E5          0527*      push hl
04112A C5          0528*      push bc
04112B E1          0529*      pop hl
04112C CD 05 11 04 0530*      call print_s168
041130 3E 20       0531*      ld a,' '
041132 5B D7       0532*      rst.lil 10h
041134 E1          0533*      pop hl
041135 C1          0534*      pop bc
041136 F1          0535*      pop af
041137 C9          0536*      ret
041138             0537*  
041138             0538*  print_s168_de:
041138 F5          0539*      push af
041139 D5          0540*      push de
04113A E5          0541*      push hl
04113B EB          0542*      ex de,hl
04113C CD 05 11 04 0543*      call print_s168
041140 3E 20       0544*      ld a,' '
041142 5B D7       0545*      rst.lil 10h
041144 E1          0546*      pop hl
041145 D1          0547*      pop de
041146 F1          0548*      pop af
041147 C9          0549*      ret
041148             0550*  
041148             0551*  print_s168_hl_bc_de:
041148 F5          0552*      push af
041149 C5          0553*      push bc
04114A D5          0554*      push de
04114B E5          0555*      push hl
04114C CD 05 11 04 0556*      call print_s168
041150 3E 20       0557*      ld a,' '
041152 5B D7       0558*      rst.lil 10h
041154 C5          0559*      push bc
041155 E1          0560*      pop hl
041156 CD 05 11 04 0561*      call print_s168
04115A 3E 20       0562*      ld a,' '
04115C 5B D7       0563*      rst.lil 10h
04115E EB          0564*      ex de,hl
04115F CD 05 11 04 0565*      call print_s168
041163 3E 20       0566*      ld a,' '
041165 5B D7       0567*      rst.lil 10h
041167 E1          0568*      pop hl
041168 D1          0569*      pop de
041169 C1          0570*      pop bc
04116A F1          0571*      pop af
04116B C9          0572*      ret
04116C             0573*  
04116C             0574*  print_s168_bc_de:
04116C F5          0575*      push af
04116D C5          0576*      push bc
04116E D5          0577*      push de
04116F C5          0578*      push bc
041170 E1          0579*      pop hl
041171 CD 05 11 04 0580*      call print_s168
041175 3E 20       0581*      ld a,' '
041177 5B D7       0582*      rst.lil 10h
041179 EB          0583*      ex de,hl
04117A CD 05 11 04 0584*      call print_s168
04117E 3E 20       0585*      ld a,' '
041180 5B D7       0586*      rst.lil 10h
041182 E1          0587*      pop hl
041183 D1          0588*      pop de
041184 C1          0589*      pop bc
041185 F1          0590*      pop af
041186 C9          0591*      ret
041187             0592*  
041187             0593*  print_s168_a:
041187 F5          0594*      push af
041188 C5          0595*      push bc
041189 E5          0596*      push hl
04118A 21 00 00 00 0597*      ld hl,0
04118E 6F          0598*      ld l,a
04118F CD 1A 11 04 0599*      call print_s168_hl
041193 E1          0600*      pop hl
041194 C1          0601*      pop bc
041195 F1          0602*      pop af
041196 C9          0603*      ret
041197             0604*  
041197             0605*  ; #### new functions added by Brandon R. Gates ####
041197             0606*  
041197             0607*  ; print the binary representation of the 8-bit value in a
041197             0608*  ; destroys a, hl, bc
041197             0609*  printBin8:
041197 06 08       0610*      ld b,8      ; loop counter for 8 bits
041199 21 B4 11 04 0611*      ld hl,@cmd  ; set hl to the low byte of the output string
04119D             0612*                  ; (which will be the high bit of the value in a)
04119D             0613*  @loop:
04119D 07          0614*      rlca ; put the next highest bit into carry
04119E 38 04       0615*      jr c,@one
0411A0 36 30       0616*      ld (hl),'0'
0411A2 18 02       0617*      jr @next_bit
0411A4             0618*  @one:
0411A4 36 31       0619*      ld (hl),'1'
0411A6             0620*  @next_bit:
0411A6 23          0621*      inc hl
0411A7 10 F4       0622*      djnz @loop
0411A9             0623*  ; print it
0411A9 21 B4 11 04 0624*  	ld hl,@cmd
0411AD 01 08 00 00 0625*  	ld bc,@end-@cmd
0411B1 5B DF       0626*  	rst.lil $18
0411B3 C9          0627*  	ret
0411B4             0628*  @cmd: ds 8 ; eight bytes for eight bits
0411BC             0629*  @end:
0411BC             0630*  
0411BC             0631*  ; print the binary representation of the 8-bit value in a
0411BC             0632*  ; in reverse order (lsb first)
0411BC             0633*  ; destroys a, hl, bc
0411BC             0634*  printBin8Rev:
0411BC 06 08       0635*      ld b,8      ; loop counter for 8 bits
0411BE 21 D9 11 04 0636*      ld hl,@cmd  ; set hl to the low byte of the output string
0411C2             0637*                  ; (which will be the high bit of the value in a)
0411C2             0638*  @loop:
0411C2 0F          0639*      rrca ; put the next lowest bit into carry
0411C3 38 04       0640*      jr c,@one
0411C5 36 30       0641*      ld (hl),'0'
0411C7 18 02       0642*      jr @next_bit
0411C9             0643*  @one:
0411C9 36 31       0644*      ld (hl),'1'
0411CB             0645*  @next_bit:
0411CB 23          0646*      inc hl
0411CC 10 F4       0647*      djnz @loop
0411CE             0648*  ; print it
0411CE 21 D9 11 04 0649*  	ld hl,@cmd
0411D2 01 08 00 00 0650*  	ld bc,@end-@cmd
0411D6 5B DF       0651*  	rst.lil $18
0411D8 C9          0652*  	ret
0411D9             0653*  @cmd: ds 8 ; eight bytes for eight bits
0411E1             0654*  @end:
0411E1             0655*  
0411E1             0656*  ; print registers to screen in hexidecimal format
0411E1             0657*  ; inputs: none
0411E1             0658*  ; outputs: values of every register printed to screen
0411E1             0659*  ;    values of each register in global scratch memory
0411E1             0660*  ; destroys: nothing
0411E1             0661*  stepRegistersHex:
0411E1             0662*  ; store everything in scratch
0411E1 22 21 14 04 0663*      ld (uhl),hl
0411E5 ED 43 24 14 0664*      ld (ubc),bc
       04          
0411EA ED 53 27 14 0665*      ld (ude),de
       04          
0411EF DD 22 2A 14 0666*      ld (uix),ix
       04          
0411F4 FD 22 2D 14 0667*      ld (uiy),iy
       04          
0411F9 F5          0668*      push af ; fml
0411FA E1          0669*      pop hl  ; thanks, zilog
0411FB 22 1E 14 04 0670*      ld (uaf),hl
0411FF F5          0671*      push af ; dammit
041200             0672*  
041200             0673*  ; home the cursor
041200             0674*      ; call vdu_home_cursor
041200             0675*  
041200             0676*  ; print each register
041200 21 A4 13 04 0677*      ld hl,str_afu
041204 CD F9 0E 04 0678*      call printString
041208 2A 1E 14 04 0679*      ld hl,(uaf)
04120C CD 19 0F 04 0680*      call printHex24
041210 CD 0E 0F 04 0681*      call printNewLine
041214             0682*  
041214 21 A9 13 04 0683*      ld hl,str_hlu
041218 CD F9 0E 04 0684*      call printString
04121C 2A 21 14 04 0685*      ld hl,(uhl)
041220 CD 19 0F 04 0686*      call printHex24
041224 CD 0E 0F 04 0687*      call printNewLine
041228             0688*  
041228 21 AE 13 04 0689*      ld hl,str_bcu
04122C CD F9 0E 04 0690*      call printString
041230 2A 24 14 04 0691*      ld hl,(ubc)
041234 CD 19 0F 04 0692*      call printHex24
041238 CD 0E 0F 04 0693*      call printNewLine
04123C             0694*  
04123C 21 B3 13 04 0695*      ld hl,str_deu
041240 CD F9 0E 04 0696*      call printString
041244 2A 27 14 04 0697*      ld hl,(ude)
041248 CD 19 0F 04 0698*      call printHex24
04124C CD 0E 0F 04 0699*      call printNewLine
041250             0700*  
041250 21 B8 13 04 0701*      ld hl,str_ixu
041254 CD F9 0E 04 0702*      call printString
041258 2A 2A 14 04 0703*      ld hl,(uix)
04125C CD 19 0F 04 0704*      call printHex24
041260 CD 0E 0F 04 0705*      call printNewLine
041264             0706*  
041264 21 BD 13 04 0707*      ld hl,str_iyu
041268 CD F9 0E 04 0708*      call printString
04126C 2A 2D 14 04 0709*      ld hl,(uiy)
041270 CD 19 0F 04 0710*      call printHex24
041274 CD 0E 0F 04 0711*      call printNewLine
041278             0712*  
041278             0713*      ; call vsync
041278             0714*  
041278 CD 0E 0F 04 0715*      call printNewLine
04127C             0716*  
04127C             0717*  ; check for right shift key and quit if pressed
04127C             0718*  	MOSCALL mos_getkbmap
04127C 3E 1E       0001*M 			LD	A, function
04127E 49 CF       0002*M 			RST.LIS	08h
041280             0719*  @stayhere:
041280             0720*  ; 7 RightShift
041280 DD CB 00 76 0721*      bit 6,(ix+0)
041284 20 02       0722*      jr nz,@RightShift
041286 18 F8       0723*      jr @stayhere
041288             0724*  @RightShift:
041288 DD CB 0E 86 0725*      res 0,(ix+14) ; debounce the key (hopefully)
04128C 3E 80       0726*      ld a,%10000000
04128E             0727*      ; call multiPurposeDelay
04128E             0728*  
04128E             0729*  ; restore everything
04128E 2A 21 14 04 0730*      ld hl, (uhl)
041292 ED 4B 24 14 0731*      ld bc, (ubc)
       04          
041297 ED 5B 27 14 0732*      ld de, (ude)
       04          
04129C DD 2A 2A 14 0733*      ld ix, (uix)
       04          
0412A1 FD 2A 2D 14 0734*      ld iy, (uiy)
       04          
0412A6 F1          0735*      pop af
0412A7             0736*  ; all done
0412A7 C9          0737*      ret
0412A8             0738*  
0412A8             0739*  ; print registers to screen in hexidecimal format
0412A8             0740*  ; inputs: none
0412A8             0741*  ; outputs: values of every register printed to screen
0412A8             0742*  ;    values of each register in global scratch memory
0412A8             0743*  ; destroys: nothing
0412A8             0744*  dumpRegistersHex:
0412A8             0745*  ; store everything in scratch
0412A8 22 21 14 04 0746*      ld (uhl),hl
0412AC ED 43 24 14 0747*      ld (ubc),bc
       04          
0412B1 ED 53 27 14 0748*      ld (ude),de
       04          
0412B6 DD 22 2A 14 0749*      ld (uix),ix
       04          
0412BB FD 22 2D 14 0750*      ld (uiy),iy
       04          
0412C0 F5          0751*      push af ; fml
0412C1 E1          0752*      pop hl  ; thanks, zilog
0412C2 22 1E 14 04 0753*      ld (uaf),hl
0412C6 F5          0754*      push af ; dammit
0412C7             0755*  
0412C7             0756*  ; home the cursor
0412C7             0757*      ; call vdu_home_cursor
0412C7             0758*      ; call printNewLine
0412C7             0759*  
0412C7             0760*  ; print each register
0412C7 21 A4 13 04 0761*      ld hl,str_afu
0412CB CD F9 0E 04 0762*      call printString
0412CF 2A 1E 14 04 0763*      ld hl,(uaf)
0412D3 CD 19 0F 04 0764*      call printHex24
0412D7             0765*      ; call printNewLine
0412D7             0766*  
0412D7 21 A9 13 04 0767*      ld hl,str_hlu
0412DB CD F9 0E 04 0768*      call printString
0412DF 2A 21 14 04 0769*      ld hl,(uhl)
0412E3 CD 19 0F 04 0770*      call printHex24
0412E7             0771*      ; call printNewLine
0412E7             0772*  
0412E7 21 AE 13 04 0773*      ld hl,str_bcu
0412EB CD F9 0E 04 0774*      call printString
0412EF 2A 24 14 04 0775*      ld hl,(ubc)
0412F3 CD 19 0F 04 0776*      call printHex24
0412F7             0777*      ; call printNewLine
0412F7             0778*  
0412F7 21 B3 13 04 0779*      ld hl,str_deu
0412FB CD F9 0E 04 0780*      call printString
0412FF 2A 27 14 04 0781*      ld hl,(ude)
041303 CD 19 0F 04 0782*      call printHex24
041307             0783*      ; call printNewLine
041307             0784*  
041307 21 B8 13 04 0785*      ld hl,str_ixu
04130B CD F9 0E 04 0786*      call printString
04130F 2A 2A 14 04 0787*      ld hl,(uix)
041313 CD 19 0F 04 0788*      call printHex24
041317             0789*      ; call printNewLine
041317             0790*  
041317 21 BD 13 04 0791*      ld hl,str_iyu
04131B CD F9 0E 04 0792*      call printString
04131F 2A 2D 14 04 0793*      ld hl,(uiy)
041323 CD 19 0F 04 0794*      call printHex24
041327             0795*      ; call printNewLine
041327             0796*  
041327             0797*      ; call vdu_vblank
041327             0798*  
041327 CD 0E 0F 04 0799*      call printNewLine
04132B             0800*  ; restore everything
04132B 2A 21 14 04 0801*      ld hl, (uhl)
04132F ED 4B 24 14 0802*      ld bc, (ubc)
       04          
041334 ED 5B 27 14 0803*      ld de, (ude)
       04          
041339 DD 2A 2A 14 0804*      ld ix, (uix)
       04          
04133E FD 2A 2D 14 0805*      ld iy, (uiy)
       04          
041343 F1          0806*      pop af
041344             0807*  ; all done
041344 C9          0808*      ret
041345             0809*  
041345             0810*  dumpRegistersHexPrime:
041345 D9          0811*      exx
041346 08          0812*      ex af,af'
041347 CD A8 12 04 0813*      call dumpRegistersHex
04134B 08          0814*      ex af,af'
04134C D9          0815*      exx
04134D C9          0816*      ret
04134E             0817*  
04134E             0818*  ; additionally dump prime registers
04134E             0819*  ; inputs: none
04134E             0820*  ; outputs: values of every register printed to screen
04134E             0821*  ; destroys: nothing
04134E             0822*  dumpRegistersHexAll:
04134E CD A8 12 04 0823*      call dumpRegistersHex
041352 08          0824*      ex af,af'
041353 D9          0825*      exx
041354 CD A8 12 04 0826*      call dumpRegistersHex
041358 08          0827*      ex af,af'
041359 D9          0828*      exx
04135A C9          0829*      ret
04135B             0830*  
04135B             0831*  ; print hlu to screen in hexidecimal format
04135B             0832*  ; inputs: none
04135B             0833*  ; destroys: nothing
04135B             0834*  print_hex_hl:
04135B F5          0835*      push af
04135C E5          0836*      push hl
04135D 21 A9 13 04 0837*      ld hl,str_hlu
041361 CD F9 0E 04 0838*      call printString
041365 E1          0839*      pop hl
041366 E5          0840*      push hl
041367 CD 19 0F 04 0841*      call printHex24
04136B 3E 20       0842*      ld a,' '
04136D 5B D7       0843*      rst.lil 10h
04136F E1          0844*      pop hl
041370 F1          0845*      pop af
041371 C9          0846*      ret
041372             0847*  
041372             0848*  ; print bcu to screen in hexidecimal format
041372             0849*  ; inputs: none
041372             0850*  ; destroys: nothing
041372             0851*  print_hex_bc:
041372 F5          0852*      push af
041373 E5          0853*      push hl
041374 C5          0854*      push bc
041375 21 AE 13 04 0855*      ld hl,str_bcu
041379 CD F9 0E 04 0856*      call printString
04137D E1          0857*      pop hl
04137E E5          0858*      push hl
04137F CD 19 0F 04 0859*      call printHex24
041383 3E 20       0860*      ld a,' '
041385 5B D7       0861*      rst.lil 10h
041387 C1          0862*      pop bc
041388 E1          0863*      pop hl
041389 F1          0864*      pop af
04138A C9          0865*      ret
04138B             0866*  
04138B             0867*  ; print deu to screen in hexidecimal format
04138B             0868*  ; inputs: none
04138B             0869*  ; destroys: nothing
04138B             0870*  print_hex_de:
04138B F5          0871*      push af
04138C E5          0872*      push hl
04138D D5          0873*      push de
04138E 21 B3 13 04 0874*      ld hl,str_deu
041392 CD F9 0E 04 0875*      call printString
041396 E1          0876*      pop hl
041397 E5          0877*      push hl
041398 CD 19 0F 04 0878*      call printHex24
04139C 3E 20       0879*      ld a,' '
04139E 5B D7       0880*      rst.lil 10h
0413A0 D1          0881*      pop de
0413A1 E1          0882*      pop hl
0413A2 F1          0883*      pop af
0413A3 C9          0884*      ret
0413A4             0885*  
0413A4 20 61 66 3D 0886*  str_afu: db " af=",0
       00          
0413A9 20 68 6C 3D 0887*  str_hlu: db " hl=",0
       00          
0413AE 20 62 63 3D 0888*  str_bcu: db " bc=",0
       00          
0413B3 20 64 65 3D 0889*  str_deu: db " de=",0
       00          
0413B8 20 69 78 3D 0890*  str_ixu: db " ix=",0
       00          
0413BD 20 69 79 3D 0891*  str_iyu: db " iy=",0
       00          
0413C2             0892*  
0413C2             0893*  ; print udeuhl to screen in hexidecimal format
0413C2             0894*  ; inputs: none
0413C2             0895*  ; outputs: concatenated hexidecimal udeuhl
0413C2             0896*  ; destroys: nothing
0413C2             0897*  dumpUDEUHLHex:
0413C2             0898*  ; store everything in scratch
0413C2 22 21 14 04 0899*      ld (uhl),hl
0413C6 ED 43 24 14 0900*      ld (ubc),bc
       04          
0413CB ED 53 27 14 0901*      ld (ude),de
       04          
0413D0 DD 22 2A 14 0902*      ld (uix),ix
       04          
0413D5 FD 22 2D 14 0903*      ld (uiy),iy
       04          
0413DA F5          0904*      push af
0413DB             0905*  
0413DB             0906*  ; print each register
0413DB             0907*  
0413DB 21 15 14 04 0908*      ld hl,str_udeuhl
0413DF CD F9 0E 04 0909*      call printString
0413E3 2A 27 14 04 0910*      ld hl,(ude)
0413E7 CD 19 0F 04 0911*      call printHex24
0413EB 3E 2E       0912*  	ld a,'.'	; print a dot to separate the values
0413ED 5B D7       0913*  	rst.lil 10h
0413EF 2A 21 14 04 0914*      ld hl,(uhl)
0413F3 CD 19 0F 04 0915*      call printHex24
0413F7 CD 0E 0F 04 0916*      call printNewLine
0413FB             0917*  
0413FB             0918*  ; restore everything
0413FB 2A 21 14 04 0919*      ld hl, (uhl)
0413FF ED 4B 24 14 0920*      ld bc, (ubc)
       04          
041404 ED 5B 27 14 0921*      ld de, (ude)
       04          
041409 DD 2A 2A 14 0922*      ld ix, (uix)
       04          
04140E FD 2A 2D 14 0923*      ld iy, (uiy)
       04          
041413 F1          0924*      pop af
041414             0925*  ; all done
041414 C9          0926*      ret
041415             0927*  
041415 75 64 65 2E 0928*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
04141E             0929*  
04141E             0930*  ; global scratch memory for registers
04141E 00 00 00    0931*  uaf: dl 0
041421 00 00 00    0932*  uhl: dl 0
041424 00 00 00    0933*  ubc: dl 0
041427 00 00 00    0934*  ude: dl 0
04142A 00 00 00    0935*  uix: dl 0
04142D 00 00 00    0936*  uiy: dl 0
041430 00 00 00    0937*  usp: dl 0
041433 00 00 00    0938*  upc: dl 0
041436             0939*  
041436             0940*  ; inputs: whatever is in the flags register
041436             0941*  ; outputs: binary representation of flags
041436             0942*  ;          with a header so we know which is what
041436             0943*  ; destroys: nothing
041436             0944*  ; preserves: everything
041436             0945*  dumpFlags:
041436             0946*  ; first we curse zilog for not giving direct access to flags
041436 F5          0947*      push af ; this is so we can send it back unharmed
041437 F5          0948*      push af ; this is so we can pop it to hl
041438             0949*  ; store everything in scratch
041438 22 21 14 04 0950*      ld (uhl),hl
04143C ED 43 24 14 0951*      ld (ubc),bc
       04          
041441 ED 53 27 14 0952*      ld (ude),de
       04          
041446 DD 22 2A 14 0953*      ld (uix),ix
       04          
04144B FD 22 2D 14 0954*      ld (uiy),iy
       04          
041450             0955*  ; next we print the header
041450 21 7C 14 04 0956*      ld hl,@header
041454 CD F9 0E 04 0957*      call printString
041458 E1          0958*      pop hl ; flags are now in l
041459 7D          0959*      ld a,l ; flags are now in a
04145A CD 97 11 04 0960*      call printBin8
04145E CD 0E 0F 04 0961*  	call printNewLine
041462             0962*  ; restore everything
041462 2A 21 14 04 0963*      ld hl, (uhl)
041466 ED 4B 24 14 0964*      ld bc, (ubc)
       04          
04146B ED 5B 27 14 0965*      ld de, (ude)
       04          
041470 DD 2A 2A 14 0966*      ld ix, (uix)
       04          
041475 FD 2A 2D 14 0967*      ld iy, (uiy)
       04          
04147A F1          0968*      pop af ; send her home the way she came
04147B C9          0969*      ret
04147C             0970*  ; Bit 7 (S): Sign flag
04147C             0971*  ; Bit 6 (Z): Zero flag
04147C             0972*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
04147C             0973*  ; Bit 4 (H): Half Carry flag
04147C             0974*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
04147C             0975*  ; Bit 2 (PV): Parity/Overflow flag
04147C             0976*  ; Bit 1 (N): Subtract flag
04147C             0977*  ; Bit 0 (C): Carry flag
04147C 53 5A 78 48 0978*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
041487             0979*  
041487             0980*  ; set all the bits in the flag register
041487             0981*  ; more of an academic exercise than anything useful
041487             0982*  ; inputs; none
041487             0983*  ; outputs; a=0,f=255
041487             0984*  ; destroys: flags, hl
041487             0985*  ; preserves: a, because why not
041487             0986*  setAllFlags:
041487 21 FF 00 00 0987*      ld hl,255
04148B 67          0988*      ld h,a ; four cycles to preserve a is cheap
04148C E5          0989*      push hl
04148D F1          0990*      pop af
04148E C9          0991*      ret
04148F             0992*  
04148F             0993*  ; reset all the bits in the flag register
04148F             0994*  ; unlike its inverse counterpart, this may actually be useful
04148F             0995*  ; inputs; none
04148F             0996*  ; outputs; a=0,f=0
04148F             0997*  ; destroys: flags, hl
04148F             0998*  ; preserves: a, because why not
04148F             0999*  resetAllFlags:
04148F 21 00 00 00 1000*      ld hl,0
041493 67          1001*      ld h,a ; four cycles to preserve a is cheap
041494 E5          1002*      push hl
041495 F1          1003*      pop af
041496 C9          1004*      ret
041497             1005*  
041497             1006*  ; wait until user presses a key
041497             1007*  ; inputs: none
041497             1008*  ; outputs: ascii code of key pressed in a
041497             1009*  ; destroys: af,ix
041497             1010*  waitKeypress:
041497             1011*      MOSCALL mos_getkey
041497 3E 00       0001*M 			LD	A, function
041499 49 CF       0002*M 			RST.LIS	08h
04149B C9          1012*      ret
04149C             1013*  
04149C             1014*  ; print bytes from an address to the screen in hexidecimal format
04149C             1015*  ; inputs: hl = address of first byte to print, a = number of bytes to print
04149C             1016*  ; outputs: values of each byte printed to screen separated by spaces
04149C             1017*  ; destroys: nothing
04149C             1018*  dumpMemoryHex:
04149C             1019*  ; save registers to the stack
04149C C5          1020*      push bc
04149D E5          1021*      push hl
04149E F5          1022*      push af
04149F             1023*  
04149F             1024*  ; print the address and separator
04149F CD 19 0F 04 1025*      call printHex24
0414A3 3E 3A       1026*      ld a,':'
0414A5 5B D7       1027*      rst.lil 10h
0414A7 3E 20       1028*      ld a,' '
0414A9 5B D7       1029*      rst.lil 10h
0414AB             1030*  
0414AB             1031*  ; set b to be our loop counter
0414AB F1          1032*      pop af
0414AC 47          1033*      ld b,a
0414AD E1          1034*      pop hl
0414AE E5          1035*      push hl
0414AF F5          1036*      push af
0414B0             1037*  @loop:
0414B0             1038*  ; print the byte
0414B0 7E          1039*      ld a,(hl)
0414B1 CD 27 0F 04 1040*      call printHex8
0414B5             1041*  ; print a space
0414B5 3E 20       1042*      ld a,' '
0414B7 5B D7       1043*      rst.lil 10h
0414B9 23          1044*      inc hl
0414BA 10 F4       1045*      djnz @loop
0414BC CD 0E 0F 04 1046*      call printNewLine
0414C0             1047*  
0414C0             1048*  ; restore everything
0414C0 F1          1049*      pop af
0414C1 E1          1050*      pop hl
0414C2 C1          1051*      pop bc
0414C3             1052*  
0414C3             1053*  ; all done
0414C3 C9          1054*      ret
0414C4             1055*  
0414C4             1056*  
0414C4             1057*  ; print bytes from an address to the screen in binary format
0414C4             1058*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0414C4             1059*  ; outputs: values of each byte printed to screen separated by spaces
0414C4             1060*  ; destroys: nothing
0414C4             1061*  dumpMemoryBin:
0414C4             1062*  ; save all registers to the stack
0414C4 F5          1063*      push af
0414C5 C5          1064*      push bc
0414C6 D5          1065*      push de
0414C7 E5          1066*      push hl
0414C8 DD E5       1067*      push ix
0414CA FD E5       1068*      push iy
0414CC             1069*  
0414CC             1070*  ; set b to be our loop counter
0414CC 47          1071*      ld b,a
0414CD             1072*  @loop:
0414CD             1073*  ; print the byte
0414CD 7E          1074*      ld a,(hl)
0414CE E5          1075*      push hl
0414CF C5          1076*      push bc
0414D0 CD 97 11 04 1077*      call printBin8
0414D4 C1          1078*      pop bc
0414D5             1079*  ; print a space
0414D5 3E 20       1080*      ld a,' '
0414D7 5B D7       1081*      rst.lil 10h
0414D9 E1          1082*      pop hl
0414DA 23          1083*      inc hl
0414DB 10 F0       1084*      djnz @loop
0414DD CD 0E 0F 04 1085*      call printNewLine
0414E1             1086*  
0414E1             1087*  ; restore everything
0414E1 FD E1       1088*      pop iy
0414E3 DD E1       1089*      pop ix
0414E5 E1          1090*      pop hl
0414E6 D1          1091*      pop de
0414E7 C1          1092*      pop bc
0414E8 F1          1093*      pop af
0414E9             1094*  ; all done
0414E9 C9          1095*      ret
0414EA             1096*  
0414EA             1097*  ; print bytes from an address to the screen in binary format
0414EA             1098*  ; with the bits of each byte in reverse order (lsb first)
0414EA             1099*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0414EA             1100*  ; outputs: values of each byte printed to screen separated by spaces
0414EA             1101*  ; destroys: nothing
0414EA             1102*  dumpMemoryBinRev:
0414EA             1103*  ; save all registers to the stack
0414EA F5          1104*      push af
0414EB C5          1105*      push bc
0414EC D5          1106*      push de
0414ED E5          1107*      push hl
0414EE DD E5       1108*      push ix
0414F0 FD E5       1109*      push iy
0414F2             1110*  
0414F2             1111*  ; set b to be our loop counter
0414F2 47          1112*      ld b,a
0414F3             1113*  @loop:
0414F3             1114*  ; print the byte
0414F3 7E          1115*      ld a,(hl)
0414F4 E5          1116*      push hl
0414F5 C5          1117*      push bc
0414F6 CD BC 11 04 1118*      call printBin8Rev
0414FA C1          1119*      pop bc
0414FB             1120*  ; print a space
0414FB 3E 20       1121*      ld a,' '
0414FD 5B D7       1122*      rst.lil 10h
0414FF E1          1123*      pop hl
041500 23          1124*      inc hl
041501 10 F0       1125*      djnz @loop
041503 CD 0E 0F 04 1126*      call printNewLine
041507             1127*  
041507             1128*  ; restore everything
041507 FD E1       1129*      pop iy
041509 DD E1       1130*      pop ix
04150B E1          1131*      pop hl
04150C D1          1132*      pop de
04150D C1          1133*      pop bc
04150E F1          1134*      pop af
04150F             1135*  ; all done
04150F C9          1136*      ret
041510             0067   	include "maths.inc"
041510             0001*  ;------------------------------------------------------------------------
041510             0002*  ; Scratch area for calculations
041510             0003*  ;------------------------------------------------------------------------
041510 00 00 00    0004*  scratch1:	dw24	0	;bit manipulation buffer 1
041513 00 00 00    0005*  scratch2:	dw24	0	;bit manipulation buffer 2
041516             0006*  
041516             0007*  ; absolute value of hlu
041516             0008*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
041516             0009*  ;         s1,z0,pv0,n1,c0 if hlu was negative
041516             0010*  ;         s0,z1,pv0,n1,c0 if hlu was zero
041516             0011*  ;         s0,z0,pv0,n1,c0 if hlu was positive
041516             0012*  ; destroys: a
041516             0013*  hlu_abs:
041516 19          0014*      add hl,de
041517 B7          0015*      or a
041518 ED 52       0016*      sbc hl,de
04151A FA 1F 15 04 0017*      jp m,@is_neg
04151E C9          0018*      ret         ; hlu is positive or zero so we're done
04151F             0019*  @is_neg:
04151F F5          0020*      push af     ; otherwise, save current flags for return
041520 CD 26 15 04 0021*      call neg_hlu ; negate hlu
041524 F1          0022*      pop af      ; get back flags
041525 C9          0023*      ret
041526             0024*  
041526             0025*  ; flip the sign of hlu
041526             0026*  ; inputs: hlu
041526             0027*  ; returns: 0-hlu, flags set appropriately for the result:
041526             0028*  ;         s1,z0,pv0,n1,c1 if result is negative
041526             0029*  ;         s0,z1,pv0,n1,c0 if result is zero
041526             0030*  ;         s0,z0,pv0,n1,c1 if result is positive
041526             0031*  ; destroys a
041526             0032*  neg_hlu:
041526 D5          0033*      push de     ; save de
041527 EB          0034*      ex de,hl    ; put hl into de
041528 21 00 00 00 0035*      ld hl,0     ; clear hl
04152C AF          0036*      xor a       ; clear carry
04152D ED 52       0037*      sbc hl,de   ; 0-hlu = -hlu
04152F D1          0038*      pop de      ; get de back
041530 C9          0039*      ret         ; easy peasy
041531             0040*  
041531             0041*  ;------------------------------------------------------------------------
041531             0042*  ; divide hlu by 2, inspired by above
041531             0043*  ;------------------------------------------------------------------------
041531             0044*  hlu_div2:
041531 22 10 15 04 0045*  	ld		(scratch1),hl
041535 21 12 15 04 0046*  	ld		hl,scratch1+2
041539 CB 1E       0047*  	rr		(hl)
04153B 2B          0048*  	dec		hl
04153C CB 1E       0049*  	rr		(hl)
04153E 2B          0050*  	dec		hl
04153F CB 1E       0051*  	rr		(hl)
041541 23          0052*  	inc		hl
041542 23          0053*  	inc		hl
041543 2A 10 15 04 0054*      ld hl,(scratch1)
041547 C9          0055*      ret
041548             0056*  
041548             0057*  ; this is my little hack to divide by 16
041548             0058*  hlu_div16:
041548 AF          0059*      xor a
041549 29          0060*      add hl,hl
04154A 17          0061*      rla
04154B 29          0062*      add hl,hl
04154C 17          0063*      rla
04154D 29          0064*      add hl,hl
04154E 17          0065*      rla
04154F 29          0066*      add hl,hl
041550 17          0067*      rla
041551 22 5E 15 04 0068*      ld (@scratch),hl
041555 32 61 15 04 0069*      ld (@scratch+3),a
041559 2A 5F 15 04 0070*      ld hl,(@scratch+1)
04155D C9          0071*      ret
04155E             0072*  @scratch: ds 4
041562             0073*  
041562             0074*  ; hlu signed division by 256
041562             0075*  ; returns: hlu / 256
041562             0076*  ; destroys: af
041562             0077*  hlu_sdiv256:
041562 AF          0078*      xor a ; assume hl is positive
041563 22 79 15 04 0079*      ld (@buffer),hl
041567             0080*      sign_hlu
041567 19          0001*M         add hl,de
041568 B7          0002*M         or a
041569 ED 52       0003*M         sbc hl,de
04156B F2 70 15 04 0081*      jp p,@hl_pos
04156F 3D          0082*      dec a
041570             0083*  @hl_pos:
041570 32 7C 15 04 0084*      ld (@buffer+3),a
041574 2A 7A 15 04 0085*      ld hl,(@buffer+1)
041578 C9          0086*      ret
041579             0087*  @buffer: ds 4
04157D             0088*  
04157D             0089*  ; hlu 1 byte right shift, unsigned
04157D             0090*  ; returns: hlu / 256, fractional portion in a
04157D             0091*  ; destroys: af
04157D             0092*  hlu_udiv256:
04157D AF          0093*  	xor a
04157E 32 8F 15 04 0094*  	ld (@buffer+3),a
041582 7D          0095*  	ld a,l ; save the fractional portion
041583 22 8C 15 04 0096*  	ld (@buffer),hl
041587 2A 8D 15 04 0097*  	ld hl,(@buffer+1)
04158B C9          0098*  	ret
04158C             0099*  @buffer: ds 4
041590             0100*  
041590             0101*      MACRO hlu_mul256
041590             0102*          add hl,hl ; * 2
041590             0103*          add hl,hl ; * 4
041590             0104*          add hl,hl ; * 8
041590             0105*          add hl,hl ; * 16
041590             0106*          add hl,hl ; * 32
041590             0107*          add hl,hl ; * 64
041590             0108*          add hl,hl ; * 128
041590             0109*          add hl,hl ; * 256
041590             0110*      ENDMACRO
041590             0111*  
041590             0112*  ; compute the modulo of hlu by deu
041590             0113*  ; outputs: hlu = hlu % deu
041590             0114*  ; destroys: f, hl
041590             0115*  hlu_mod:
041590 B7          0116*  	or a ; clear carry
041591             0117*  @loop:
041591 ED 52       0118*      sbc hl,de
041593 DA 9B 15 04 0119*      jp c, @end
041597 C3 91 15 04 0120*      jp @loop
04159B             0121*  @end:
04159B 19          0122*      add hl,de
04159C C9          0123*  	ret
04159D             0124*  
04159D             0125*  
04159D 00 00 00 00 0126*  add_bcd_arg1: db #00,#00,#00,#00
0415A1 00 00 00 00 0127*  add_bcd_arg2: db #00,#00,#00,#00
0415A5             0128*  
0415A5             0129*  ; set bcd values in a scratch memory address from registers bcde
0415A5             0130*  ; input: hl; scratch address,bcde; 8-place bcd number
0415A5             0131*  ; destroys ; hl
0415A5             0132*  set_bcd:
0415A5 73          0133*      ld (hl),e
0415A6 23          0134*      inc hl
0415A7 72          0135*      ld (hl),d
0415A8 23          0136*      inc hl
0415A9 71          0137*      ld (hl),c
0415AA 23          0138*      inc hl
0415AB 70          0139*      ld (hl),b
0415AC C9          0140*      ret
0415AD             0141*  
0415AD             0142*  ; load bcd values from a scratch memory address to bcde
0415AD             0143*  ; input: hl; scratch address
0415AD             0144*  ; output: bcde; 8-place bcd number
0415AD             0145*  ; destroys: hl
0415AD             0146*  get_bcd:
0415AD 5E          0147*      ld e,(hl)
0415AE 23          0148*      inc hl
0415AF 56          0149*      ld d,(hl)
0415B0 23          0150*      inc hl
0415B1 4E          0151*      ld c,(hl)
0415B2 23          0152*      inc hl
0415B3 46          0153*      ld b,(hl)
0415B4 C9          0154*      ret
0415B5             0155*  
0415B5             0156*  ; BCD addition
0415B5             0157*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0415B5             0158*  ;       a is the number of bytes holding each number (number of places/2)
0415B5             0159*  ; outputs: (hl) + (de) --> (hl)
0415B5             0160*  ; destroys: a,b,de,hl
0415B5             0161*  add_bcd:
0415B5 47          0162*      ld b,a ; loop counter
0415B6 AF          0163*      xor a ; reset a, clear carry flag
0415B7             0164*  adcec:
0415B7 1A          0165*      ld a,(de) ; addend to acc
0415B8 8E          0166*      adc a,(hl) ; add (hl) to acc
0415B9 27          0167*      daa ; adjust result to bcd
0415BA 77          0168*      ld (hl),a ; store result
0415BB 23          0169*      inc hl ; advance memory pointers
0415BC 13          0170*      inc de
0415BD 10 F8       0171*      djnz adcec ; loop until b == 0
0415BF C9          0172*      ret
0415C0             0173*  
0415C0             0174*  ; BCD subtraction
0415C0             0175*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0415C0             0176*  ;       a is the number of bytes holding each number (number of places/2)
0415C0             0177*  ; outputs: (hl) - (de) --> (hl)
0415C0             0178*  ; destroys: a,b,de,hl
0415C0             0179*  sub_bcd:
0415C0 47          0180*      ld b,a ; loop counter
0415C1 AF          0181*      xor a ; reset a,clear carry flag
0415C2             0182*  subdec:
0415C2 1A          0183*      ld a,(de) ; subtrahend to acc
0415C3 9E          0184*      sbc a,(hl) ; subtract (hl) from acc
0415C4 27          0185*      daa ; adjust result to bcd
0415C5 77          0186*      ld (hl),a ; store result
0415C6 23          0187*      inc hl ; advance memory pointers
0415C7 13          0188*      inc de
0415C8 10 F8       0189*      djnz subdec ; loop until b == 0
0415CA C9          0190*      ret
0415CB             0191*  
0415CB             0192*  ; http://www.z80.info/pseudo-random.txt
0415CB             0193*  rand_8:
0415CB C5          0194*      push bc
0415CC 3A DF 15 04 0195*      ld a,(r_seed)
0415D0 4F          0196*      ld c,a
0415D1             0197*  
0415D1 0F          0198*      rrca ; multiply by 32
0415D2 0F          0199*      rrca
0415D3 0F          0200*      rrca
0415D4 EE 1F       0201*      xor 0x1f
0415D6             0202*  
0415D6 81          0203*      add a,c
0415D7 DE FF       0204*      sbc a,255 ; carry
0415D9             0205*  
0415D9 32 DF 15 04 0206*      ld (r_seed),a
0415DD C1          0207*      pop bc
0415DE C9          0208*      ret
0415DF 50          0209*  r_seed: defb $50
0415E0             0068       include "mathfpp.inc"
0415E0             0001*  ; integer operations
0415E0             0002*  iand:	EQU 58	; AND (INTEGER)
0415E0             0003*  ibdiv:	EQU 59	; DIV
0415E0             0004*  ieor:	EQU 60	; EOR
0415E0             0005*  imod:	EQU 61	; MOD
0415E0             0006*  ior:	EQU 62	; OR
0415E0             0007*  ile:	EQU 63	; <=
0415E0             0008*  ine:	EQU 64	; <>
0415E0             0009*  ige:	EQU 65	; >=
0415E0             0010*  ilt:	EQU 66	; <
0415E0             0011*  ieq:	EQU 67	; =
0415E0             0012*  imul:	EQU 68	; *
0415E0             0013*  iadd:	EQU 69	; +
0415E0             0014*  igt:	EQU 70	; >
0415E0             0015*  isub:	EQU 71	; -
0415E0             0016*  ipow:	EQU 72	; ^
0415E0             0017*  idiv:	EQU 73	; /
0415E0             0018*  ;
0415E0             0019*  ; floating point functions
0415E0             0020*  absv:	EQU 16	; ABS
0415E0             0021*  acs:	EQU 17	; ACS
0415E0             0022*  asn:	EQU 18	; ASN
0415E0             0023*  atn:	EQU 19	; ATN
0415E0             0024*  cos:	EQU 20	; COS
0415E0             0025*  deg:	EQU 21	; DEG
0415E0             0026*  exp:	EQU 22	; EXP
0415E0             0027*  int_:	EQU 23	; INT
0415E0             0028*  ln:	    EQU 24	; LN
0415E0             0029*  log:	EQU 25	; LOG
0415E0             0030*  notk:	EQU 26	; NOT
0415E0             0031*  rad:	EQU 27	; RAD
0415E0             0032*  sgn:	EQU 28	; SGN
0415E0             0033*  sin:	EQU 29	; SIN
0415E0             0034*  sqr:	EQU 30	; SQR
0415E0             0035*  tan:	EQU 31	; TAN
0415E0             0036*  zero:	EQU 32	; ZERO
0415E0             0037*  fone:	EQU 33	; FONE
0415E0             0038*  true:	EQU 34	; TRUE
0415E0             0039*  pi:	    EQU 35	; PI
0415E0             0040*  val:	EQU 36	; VAL
0415E0             0041*  str:	EQU 37	; STR$
0415E0             0042*  sfix:	EQU 38	; FIX
0415E0             0043*  sfloat:	EQU 39	; FLOAT
0415E0             0044*  ftest:	EQU 40	; TEST
0415E0             0045*  fcomp:	EQU 41	; COMPARE
0415E0             0046*  ;
0415E0             0047*  ; floating point operations
0415E0             0048*  fand:	EQU  0	; AND (FLOATING-POINT)
0415E0             0049*  fbdiv:	EQU  1	; DIV
0415E0             0050*  feor:	EQU  2	; EOR
0415E0             0051*  fmod:	EQU  3	; MOD
0415E0             0052*  ffor:	EQU  4	; OR
0415E0             0053*  fle:	EQU  5	; <=
0415E0             0054*  fne:	EQU  6	; <>
0415E0             0055*  fge:	EQU  7	; >=
0415E0             0056*  flt:	EQU  8	; <
0415E0             0057*  feq:	EQU  9	; =
0415E0             0058*  fmul:	EQU 10	; *
0415E0             0059*  fadd:	EQU 11	; +
0415E0             0060*  fgt:	EQU 12	; >
0415E0             0061*  fsub:	EQU 13	; -
0415E0             0062*  fpow:	EQU 14	; ^
0415E0             0063*  fdiv:	EQU 15	; /
0415E0             0064*  
0415E0             0065*      MACRO LOAD_FLOAT ARG
0415E0             0066*      ld ix,$+11
0415E0             0067*      call val_fp ; convert the string to a float
0415E0             0068*      jp (ix)
0415E0             0069*      asciz ARG
0415E0             0070*      ENDMACRO
0415E0             0071*  
0415E0             0072*  ; --- originally in eval.asm ---
0415E0             0073*  ;SWAP - Swap arguments
0415E0             0074*  ;Exchanges DE,HL D'E',H'L' and B,C
0415E0             0075*  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0415E0             0076*  ;
0415E0 79          0077*  SWAP:			LD      A,C
0415E1 48          0078*  			LD      C,B
0415E2 47          0079*  			LD      B,A
0415E3 EB          0080*  			EX      DE,HL
0415E4 D9          0081*  			EXX
0415E5 EB          0082*  			EX      DE,HL
0415E6 D9          0083*  			EXX
0415E7 C9          0084*  			RET
0415E8             0085*  
0415E8             0086*  ; same as VAL_FP in fpp.asm, but preserves any float stored in DED'E'B
0415E8             0087*  val_fp:
0415E8 FD E5       0088*      push iy ; preserve
0415EA FD 21 05 16 0089*      ld iy,@val
       04          
0415EF CD F7 16 04 0090*      call store_float_iy_alt
0415F3 3E 24       0091*      ld a,val
0415F5 CD FD 00 04 0092*      call FPP ; string converted to float in HLH'L'C
0415F9 FD 21 05 16 0093*      ld iy,@val
       04          
0415FE CD 09 17 04 0094*      call fetch_float_iy_alt
041602 FD E1       0095*      pop iy ; restore
041604 C9          0096*      ret
041605             0097*  @val: ds 5
04160A             0098*  
04160A             0099*  ; same as INT_FP_ in fpp.asm but preserves B, which keeps any float stored in DED'E'B intact
04160A             0100*  ; af will also return differently from the original
04160A             0101*  ;INT - Floor function
04160A             0102*  ;Result is integer numeric.
04160A             0103*  ;
04160A             0104*  int_fp_:
04160A C5          0105*      push bc ; preserve b
04160B 3E 17       0106*      ld a,int_
04160D CD FD 00 04 0107*      call FPP
041611 F1          0108*      pop af ; restore b to a
041612 47          0109*      ld b,a ; restore b
041613 C9          0110*      RET
041614             0111*  
041614             0112*  ; convert floating point number to integer and store it in HLU
041614             0113*  ; inputs: HLH'L'C = floating point number
041614             0114*  ; outputs: HLU = integer part of the number
041614             0115*  ; destroys: all except DEU and U'D'E'B, index registers
041614             0116*  int2hlu:
041614 CD 0A 16 04 0117*      call int_fp_
041618 7D          0118*      ld a,l
041619 F5          0119*      push af
04161A D9          0120*      exx
04161B E5          0121*      push hl
04161C D9          0122*      exx
04161D E1          0123*      pop hl
04161E F1          0124*      pop af
04161F CD E2 0E 04 0125*      call A_TO_HLU
041623 C9          0126*      ret
041624             0127*  
041624             0128*  ; convert polar coordinates to cartesian coordinates as deltas from the origin
041624             0129*  ; inputs: HLH'L'C = angle in radians
041624             0130*  ;         DED'E'B = radius
041624             0131*  ; outputs: HLH'L'C = dx
041624             0132*  ;          DED'E'B = dy
041624             0133*  polar_to_cartesian_fpp:
041624             0134*  ; store input parameters in scratch
041624 FD 21 7C 16 0135*      ld iy,@angle
       04          
041629 CD D3 16 04 0136*      call store_float_iy_nor
04162D FD 21 81 16 0137*      ld iy,@radius
       04          
041632 CD F7 16 04 0138*      call store_float_iy_alt
041636             0139*  ; compute dy = sin(angle) * radius
041636 3E 1D       0140*      ld a,sin
041638 CD FD 00 04 0141*      call FPP ; HLH'L'C = sin(angle)
04163C FD 21 81 16 0142*      ld iy,@radius
       04          
041641 CD 09 17 04 0143*      call fetch_float_iy_alt ; DED'E'B = radius
041645 3E 0A       0144*      ld a,fmul
041647 CD FD 00 04 0145*      call FPP ; HLH'L'C = sin(angle) * radius
04164B FD 21 86 16 0146*      ld iy,@scratch
       04          
041650 CD D3 16 04 0147*      call store_float_iy_nor ; @scratch = dy
041654             0148*  ; compute dx = cos(angle) * radius
041654 FD 21 7C 16 0149*      ld iy,@angle
       04          
041659 CD E5 16 04 0150*      call fetch_float_iy_nor
04165D 3E 14       0151*      ld a,cos
04165F CD FD 00 04 0152*      call FPP ; HLH'L'C = cos(angle)
041663 FD 21 81 16 0153*      ld iy,@radius
       04          
041668 CD 09 17 04 0154*      call fetch_float_iy_alt ; DED'E'B = radius
04166C 3E 0A       0155*      ld a,fmul
04166E CD FD 00 04 0156*      call FPP ; HLH'L'C = cos(angle) * radius
041672             0157*  ; restore dy from @scratch
041672 FD 21 86 16 0158*      ld iy,@scratch
       04          
041677 CD 09 17 04 0159*      call fetch_float_iy_alt
04167B C9          0160*      ret
04167C             0161*  @angle: ds 5
041681             0162*  @radius: ds 5
041686             0163*  @scratch: ds 5
04168B             0164*  
04168B             0165*  ; store HLH'L'C floating point number in a 40-bit buffer
04168B             0166*  ; inputs: HLH'L'C = floating point number
04168B             0167*  ;         ix = buffer address
04168B             0168*  ; outputs: buffer filled with floating point number
04168B             0169*  ; destroys: nothing
04168B             0170*  store_float_nor:
04168B DD 71 00    0171*      ld (ix+0),c
04168E DD 75 03    0172*      ld (ix+3),l
041691 DD 74 04    0173*      ld (ix+4),h
041694 D9          0174*      exx
041695 DD 75 01    0175*      ld (ix+1),l
041698 DD 74 02    0176*      ld (ix+2),h
04169B D9          0177*      exx
04169C C9          0178*      ret
04169D             0179*  
04169D             0180*  ; fetch HLH'L'C floating point number from a 40-bit buffer
04169D             0181*  ; inputs: ix = buffer address
04169D             0182*  ; outputs: HLH'L'C = floating point number
04169D             0183*  ; destroys: HLH'L'C
04169D             0184*  fetch_float_nor:
04169D DD 4E 00    0185*      ld c,(ix+0)
0416A0 DD 6E 03    0186*      ld l,(ix+3)
0416A3 DD 66 04    0187*      ld h,(ix+4)
0416A6 D9          0188*      exx
0416A7 DD 6E 01    0189*      ld l,(ix+1)
0416AA DD 66 02    0190*      ld h,(ix+2)
0416AD D9          0191*      exx
0416AE C9          0192*      ret
0416AF             0193*  
0416AF             0194*  ; store DED'E'B floating point number in a 40-bit buffer
0416AF             0195*  ; inputs: DED'E'B = floating point number
0416AF             0196*  ;         ix = buffer address
0416AF             0197*  ; outputs: buffer filled with floating point number
0416AF             0198*  ; destroys: nothing
0416AF             0199*  store_float_alt:
0416AF DD 70 00    0200*      ld (ix+0),b
0416B2 DD 73 03    0201*      ld (ix+3),e
0416B5 DD 72 04    0202*      ld (ix+4),d
0416B8 D9          0203*      exx
0416B9 DD 73 01    0204*      ld (ix+1),e
0416BC DD 72 02    0205*      ld (ix+2),d
0416BF D9          0206*      exx
0416C0 C9          0207*      ret
0416C1             0208*  
0416C1             0209*  ; fetch DED'E'B floating point number from a 40-bit buffer
0416C1             0210*  ; inputs: ix = buffer address
0416C1             0211*  ; outputs: DED'E'B = floating point number
0416C1             0212*  ; destroys: DED'E'B
0416C1             0213*  fetch_float_alt:
0416C1 DD 46 00    0214*      ld b,(ix+0)
0416C4 DD 5E 03    0215*      ld e,(ix+3)
0416C7 DD 56 04    0216*      ld d,(ix+4)
0416CA D9          0217*      exx
0416CB DD 5E 01    0218*      ld e,(ix+1)
0416CE DD 56 02    0219*      ld d,(ix+2)
0416D1 D9          0220*      exx
0416D2 C9          0221*      ret
0416D3             0222*  
0416D3             0223*  
0416D3             0224*  ; store HLH'L'C floating point number in a 40-bit buffer
0416D3             0225*  ; inputs: HLH'L'C = floating point number
0416D3             0226*  ;         iy = buffer address
0416D3             0227*  ; outputs: buffer filled with floating point number
0416D3             0228*  ; destroys: nothing
0416D3             0229*  store_float_iy_nor:
0416D3 FD 71 00    0230*      ld (iy+0),c
0416D6 FD 75 03    0231*      ld (iy+3),l
0416D9 FD 74 04    0232*      ld (iy+4),h
0416DC D9          0233*      exx
0416DD FD 75 01    0234*      ld (iy+1),l
0416E0 FD 74 02    0235*      ld (iy+2),h
0416E3 D9          0236*      exx
0416E4 C9          0237*      ret
0416E5             0238*  
0416E5             0239*  ; fetch HLH'L'C floating point number from a 40-bit buffer
0416E5             0240*  ; inputs: iy = buffer address
0416E5             0241*  ; outputs: HLH'L'C = floating point number
0416E5             0242*  ; destroys: HLH'L'C
0416E5             0243*  fetch_float_iy_nor:
0416E5 FD 4E 00    0244*      ld c,(iy+0)
0416E8 FD 6E 03    0245*      ld l,(iy+3)
0416EB FD 66 04    0246*      ld h,(iy+4)
0416EE D9          0247*      exx
0416EF FD 6E 01    0248*      ld l,(iy+1)
0416F2 FD 66 02    0249*      ld h,(iy+2)
0416F5 D9          0250*      exx
0416F6 C9          0251*      ret
0416F7             0252*  
0416F7             0253*  ; store DED'E'B floating point number in a 40-bit buffer
0416F7             0254*  ; inputs: DED'E'B = floating point number
0416F7             0255*  ;         iy = buffer address
0416F7             0256*  ; outputs: buffer filled with floating point number
0416F7             0257*  ; destroys: nothing
0416F7             0258*  store_float_iy_alt:
0416F7 FD 70 00    0259*      ld (iy+0),b
0416FA FD 73 03    0260*      ld (iy+3),e
0416FD FD 72 04    0261*      ld (iy+4),d
041700 D9          0262*      exx
041701 FD 73 01    0263*      ld (iy+1),e
041704 FD 72 02    0264*      ld (iy+2),d
041707 D9          0265*      exx
041708 C9          0266*      ret
041709             0267*  
041709             0268*  ; fetch DED'E'B floating point number from a 40-bit buffer
041709             0269*  ; inputs: iy = buffer address
041709             0270*  ; outputs: DED'E'B = floating point number
041709             0271*  ; destroys: DED'E'B
041709             0272*  fetch_float_iy_alt:
041709 FD 46 00    0273*      ld b,(iy+0)
04170C FD 5E 03    0274*      ld e,(iy+3)
04170F FD 56 04    0275*      ld d,(iy+4)
041712 D9          0276*      exx
041713 FD 5E 01    0277*      ld e,(iy+1)
041716 FD 56 02    0278*      ld d,(iy+2)
041719 D9          0279*      exx
04171A C9          0280*      ret
04171B             0281*  
04171B             0282*  ; print HLH'L'C floating point number in hex format
04171B             0283*  ; inputs: HLH'L'C = floating point number
04171B             0284*  print_float_hex_nor:
04171B             0285*      PUSH_ALL
04171B 08          0001*M         ex af,af'
04171C D9          0002*M         exx
04171D F5          0003*M         push af
04171E E5          0004*M         push hl
04171F C5          0005*M         push bc
041720 D5          0006*M         push de
041721             0007*M 
041721 08          0008*M         ex af,af'
041722 D9          0009*M         exx
041723 F5          0010*M         push af
041724 E5          0011*M         push hl
041725 C5          0012*M         push bc
041726 D5          0013*M         push de
041727 DD E5       0014*M         push ix
041729 FD E5       0015*M         push iy
04172B C5          0286*      push bc ; preserve c
04172C CD 21 0F 04 0287*      call printHex16
041730 3E 2E       0288*      ld a,'.'
041732 5B D7       0289*      rst.lil 10h
041734 D9          0290*      exx
041735 CD 21 0F 04 0291*      call printHex16
041739 D9          0292*      exx
04173A 3E 5E       0293*      ld a,'^'
04173C 5B D7       0294*      rst.lil 10h
04173E C1          0295*      pop bc ; restore c
04173F 79          0296*      ld a,c
041740 CD 27 0F 04 0297*      call printHex8
041744             0298*      POP_ALL
041744 FD E1       0001*M         pop iy
041746 DD E1       0002*M         pop ix
041748 D1          0003*M         pop de
041749 C1          0004*M         pop bc
04174A E1          0005*M         pop hl
04174B F1          0006*M         pop af
04174C 08          0007*M         ex af,af'
04174D D9          0008*M         exx
04174E             0009*M 
04174E D1          0010*M         pop de
04174F C1          0011*M         pop bc
041750 E1          0012*M         pop hl
041751 F1          0013*M         pop af
041752 08          0014*M         ex af,af'
041753 D9          0015*M         exx
041754 C9          0299*      ret
041755             0300*  
041755             0301*  ; print DED'E'B floating point number in hex format
041755             0302*  ; inputs: DED'E'B = floating point number
041755             0303*  print_float_hex_alt:
041755             0304*      PUSH_ALL
041755 08          0001*M         ex af,af'
041756 D9          0002*M         exx
041757 F5          0003*M         push af
041758 E5          0004*M         push hl
041759 C5          0005*M         push bc
04175A D5          0006*M         push de
04175B             0007*M 
04175B 08          0008*M         ex af,af'
04175C D9          0009*M         exx
04175D F5          0010*M         push af
04175E E5          0011*M         push hl
04175F C5          0012*M         push bc
041760 D5          0013*M         push de
041761 DD E5       0014*M         push ix
041763 FD E5       0015*M         push iy
041765 C5          0305*      push bc ; preserve b
041766 EB          0306*      ex de,hl
041767 CD 21 0F 04 0307*      call printHex16
04176B EB          0308*      ex de,hl
04176C 3E 2E       0309*      ld a,'.'
04176E 5B D7       0310*      rst.lil 10h
041770 D9          0311*      exx
041771 EB          0312*      ex de,hl
041772 CD 21 0F 04 0313*      call printHex16
041776 EB          0314*      ex de,hl
041777 D9          0315*      exx
041778 3E 5E       0316*      ld a,'^'
04177A 5B D7       0317*      rst.lil 10h
04177C F1          0318*      pop af ; restore b to a
04177D CD 27 0F 04 0319*      call printHex8
041781             0320*      POP_ALL
041781 FD E1       0001*M         pop iy
041783 DD E1       0002*M         pop ix
041785 D1          0003*M         pop de
041786 C1          0004*M         pop bc
041787 E1          0005*M         pop hl
041788 F1          0006*M         pop af
041789 08          0007*M         ex af,af'
04178A D9          0008*M         exx
04178B             0009*M 
04178B D1          0010*M         pop de
04178C C1          0011*M         pop bc
04178D E1          0012*M         pop hl
04178E F1          0013*M         pop af
04178F 08          0014*M         ex af,af'
041790 D9          0015*M         exx
041791 C9          0321*      ret
041792             0322*  
041792             0323*  print_floats_hex:
041792 CD 1B 17 04 0324*      call print_float_hex_nor
041796 3E 20       0325*      ld a,' '
041798 5B D7       0326*      rst.lil 10h
04179A CD 55 17 04 0327*      call print_float_hex_alt
04179E C9          0328*      ret
04179F             0329*  
04179F             0330*  ; print a floating point number in decimal format
04179F             0331*  ; inputs: HL'H'L'C is the number to print
04179F             0332*  ; outputs: number printed to screen
04179F             0333*  ;          ACCS null-terminated string representation of the number
04179F             0334*  ; destroys: everything except ix
04179F             0335*  print_float_dec:
04179F             0336*  print_float_dec_nor:
04179F DD E5       0337*      push ix             ; preserve
0417A1             0338*  
0417A1             0339*  ; back up floats in normal and alternate registers
0417A1 DD 21 E2 17 0340*      ld ix,@float_nor
       04          
0417A6 CD 8B 16 04 0341*      call store_float_nor
0417AA DD 21 E7 17 0342*      ld ix,@float_alt
       04          
0417AF CD AF 16 04 0343*      call store_float_alt
0417B3             0344*  
0417B3             0345*  ; convert the number to a string
0417B3 11 00 20 04 0346*      ld de,ACCS          ; point to the string accumulator
0417B7 DD 21 DF 17 0347*      ld ix,@G9-1         ; get the format code for the number
       04          
0417BC CD FC 08 04 0348*      call STR_FP         ; convert the number to a string
0417C0 EB          0349*      ex de,hl            ; point to end of the string
0417C1 36 00       0350*      ld (hl),0           ; null-terminate the string
0417C3 21 00 20 04 0351*      ld hl,ACCS          ; point to the string accumulator
0417C7 CD F9 0E 04 0352*      call printString
0417CB             0353*  
0417CB             0354*  ; restore floats in normal and alternate registers
0417CB DD 21 E2 17 0355*      ld ix,@float_nor
       04          
0417D0 CD 9D 16 04 0356*      call fetch_float_nor
0417D4 DD 21 E7 17 0357*      ld ix,@float_alt
       04          
0417D9 CD C1 16 04 0358*      call fetch_float_alt
0417DD             0359*  
0417DD             0360*  ; cleanup and go home
0417DD DD E1       0361*      pop ix              ; restore
0417DF C9          0362*      ret
0417E0 09 00       0363*  @G9:			DW    9
0417E2             0364*  @float_nor: ds 5
0417E7             0365*  @float_alt: ds 5
0417EC             0366*  
0417EC             0367*  print_float_dec_alt:
0417EC CD E0 15 04 0368*      CALL SWAP
0417F0 CD 9F 17 04 0369*      CALL print_float_dec_nor
0417F4 CD E0 15 04 0370*      CALL SWAP
0417F8 C9          0371*      ret
0417F9             0372*  
0417F9             0373*  ;PI - Return PI (3.14159265)
0417F9             0374*  ;Result is floating-point numeric.
0417F9             0375*  ;
0417F9 11 0F 49 00 0376*  pi_alt:			LD      DE,0x490F
0417FD D9          0377*          		EXX
0417FE 11 A2 DA 00 0378*          		LD      DE,0xDAA2
041802 D9          0379*          		EXX
041803 06 81       0380*          		LD      B,0x81
041805 AF          0381*          		XOR     A               ;NUMERIC MARKER
041806 C9          0382*          		RET
041807             0383*  
041807             0384*  ;PI - Return PI * 2 (6.28318531)
041807             0385*  ;Result is floating-point numeric.
041807             0386*  ;
041807 11 0F 49 00 0387*  pi2_alt:		LD      DE,0x490F
04180B D9          0388*          		EXX
04180C 11 A3 DA 00 0389*          		LD      DE,0xDAA3
041810 D9          0390*          		EXX
041811 06 82       0391*          		LD      B,0x82
041813 AF          0392*          		XOR     A               ;NUMERIC MARKER
041814 C9          0393*          		RET
041815             0069       include "vdu.inc"
041815             0001*  
041815             0002*  ; VDU 30: Home cursor
041815             0003*  vdu_home_cursor:
041815 3E 1E       0004*      ld a,30
041817 5B D7       0005*  	rst.lil $10
041819 C9          0006*  	ret
04181A             0007*  
04181A             0008*  cursor_on:
04181A 21 25 18 04 0009*  	ld hl,@cmd
04181E 01 03 00 00 0010*  	ld bc,@end-@cmd
041822 5B DF       0011*  	rst.lil $18
041824 C9          0012*  	ret
041825             0013*  @cmd:
041825 17 01 01    0014*  	db 23,1,1
041828             0015*  @end:
041828             0016*  
041828             0017*  cursor_off:
041828 21 33 18 04 0018*  	ld hl,@cmd
04182C 01 03 00 00 0019*  	ld bc,@end-@cmd
041830 5B DF       0020*  	rst.lil $18
041832 C9          0021*  	ret
041833             0022*  @cmd:
041833 17 01 00    0023*  	db 23,1,0
041836             0024*  @end:
041836             0025*  
041836             0026*  ; VDU 9: Move cursor forward one character
041836             0027*  vdu_cursor_forward:
041836 3E 09       0028*      ld a,9
041838 5B D7       0029*  	rst.lil $10
04183A C9          0030*  	ret
04183B             0031*  
04183B             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
04183B             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
04183B             0034*  vdu_move_cursor:
04183B ED 43 4C 18 0035*      ld (@x0),bc
       04          
041840 21 4B 18 04 0036*  	ld hl,@cmd
041844 01 03 00 00 0037*  	ld bc,@end-@cmd
041848 5B DF       0038*  	rst.lil $18
04184A C9          0039*  	ret
04184B 1F          0040*  @cmd: 	db 31
04184C 00          0041*  @x0:	db 0
04184D 00          0042*  @y0: 	db 0
04184E 00          0043*  @end: 	db 0 ; padding
04184F             0044*  
04184F             0045*  ; VDU 12: Clear text area (CLS)
04184F             0046*  vdu_cls:
04184F 3E 0C       0047*      ld a,12
041851 5B D7       0048*  	rst.lil $10
041853 C9          0049*  	ret
041854             0050*  
041854             0051*  vdu_flip:
041854 21 5F 18 04 0052*  	ld hl,@cmd
041858 01 03 00 00 0053*  	ld bc,@end-@cmd
04185C 5B DF       0054*  	rst.lil $18
04185E C9          0055*  	ret
04185F 17 00 C3    0056*  @cmd: db 23,0,0xC3
041862             0057*  @end:
041862             0058*  
041862             0059*  ; VDU 16: Clear graphics area (CLG)
041862             0060*  vdu_clg:
041862 3E 10       0061*      ld a,16
041864 5B D7       0062*  	rst.lil $10
041866 C9          0063*  	ret
041867             0064*  
041867             0065*  ; COLOUR MODES
041867             0066*  ; Mode	Effect
041867             0067*  ; 0	Set on-screen pixel to target colour value
041867             0068*  ; 1	OR value with the on-screen pixel
041867             0069*  ; 2	AND value with the on-screen pixel
041867             0070*  ; 3	XOR value with the on-screen pixel
041867             0071*  ; 4	Invert the on-screen pixel
041867             0072*  ; 5	No operation
041867             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
041867             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
041867             0075*  
041867             0076*  ; VDU 17, colour: Define text colour (COLOUR)
041867             0077*  vdu_colour_text:
041867 32 77 18 04 0078*  	ld (@arg),a
04186B 21 76 18 04 0079*  	ld hl,@cmd
04186F 01 02 00 00 0080*  	ld bc,@end-@cmd
041873 5B DF       0081*  	rst.lil $18
041875 C9          0082*  	ret
041876 11          0083*  @cmd: db 17
041877 00          0084*  @arg: db 0
041878             0085*  @end:
041878             0086*  
041878             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
041878             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
041878             0089*  vdu_gcol:
041878 32 8D 18 04 0090*  	ld (@mode),a
04187C 79          0091*      ld a,c
04187D 32 8E 18 04 0092*      ld (@col),a
041881 21 8C 18 04 0093*  	ld hl,@cmd
041885 01 03 00 00 0094*  	ld bc,@end-@cmd
041889 5B DF       0095*  	rst.lil $18
04188B C9          0096*  	ret
04188C 12          0097*  @cmd:  db 18
04188D 00          0098*  @mode: db 0
04188E 00          0099*  @col:  db 0
04188F             0100*  @end:
04188F             0101*  
04188F             0102*  
04188F             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
04188F             0104*  ; MIND THE LITTLE-ENDIANESS
04188F             0105*  ; inputs: c=left,b=bottom,e=right,d=top
04188F             0106*  ; outputs; nothing
04188F             0107*  ; destroys: a might make it out alive
04188F             0108*  vdu_set_txt_viewport:
04188F ED 43 A5 18 0109*      ld (@lb),bc
       04          
041894 ED 53 A7 18 0110*  	ld (@rt),de
       04          
041899 21 A4 18 04 0111*  	ld hl,@cmd
04189D 01 05 00 00 0112*  	ld bc,@end-@cmd
0418A1 5B DF       0113*  	rst.lil $18
0418A3 C9          0114*  	ret
0418A4 1C          0115*  @cmd:   db 28 ; set text viewport command
0418A5 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0418A7 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0418A9 00          0118*  @end:   db 0x00	  ; padding
0418AA             0119*  
0418AA             0120*  ; Wait for VBLANK interrupt
0418AA             0121*  vdu_vblank:
0418AA DD E5       0122*      PUSH 	IX
0418AC             0123*  	MOSCALL	mos_sysvars
0418AC 3E 08       0001*M 			LD	A, function
0418AE 49 CF       0002*M 			RST.LIS	08h
0418B0 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0418B3             0125*  @wait:
0418B3 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0418B6 28 FB       0127*      JR	Z, @wait
0418B8 DD E1       0128*      POP	IX
0418BA C9          0129*      RET
0418BB             0130*  
0418BB             0131*  ; VDU 29, x; y;: Set graphics origin
0418BB             0132*  ; This command sets the graphics origin.
0418BB             0133*  ; The origin is the point on the screen where the coordinates (0,0) are located.
0418BB             0134*  ; inputs: bc=x0,de=y0
0418BB             0135*  ; outputs; nothing
0418BB             0136*  ; destroys: a might make it out alive
0418BB             0137*  vdu_set_gfx_origin:
0418BB ED 43 D1 18 0138*      ld (@x0),bc
       04          
0418C0 ED 53 D3 18 0139*      ld (@y0),de
       04          
0418C5 21 D0 18 04 0140*      ld hl,@cmd
0418C9 01 05 00 00 0141*      ld bc,@end-@cmd
0418CD 5B DF       0142*      rst.lil $18
0418CF C9          0143*      ret
0418D0 1D          0144*  @cmd:   db 29 ; set graphics origin command
0418D1 00 00       0145*  @x0: 	dw 0x0000 ; set by bc
0418D3 00 00       0146*  @y0: 	dw 0x0000 ; set by de
0418D5 00          0147*  @end:   db 0x00	  ; padding
0418D6             0148*  
0418D6             0149*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0418D6             0150*  ; NOTE: the order of the y-coordinate parameters are inverted
0418D6             0151*  ; 	because we have turned off logical screen scaling
0418D6             0152*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0418D6             0153*  ; outputs; nothing
0418D6             0154*  ; destroys: a might make it out alive
0418D6             0155*  vdu_set_gfx_viewport:
0418D6 ED 43 F6 18 0156*      ld (@x0),bc
       04          
0418DB FD 22 F8 18 0157*      ld (@y1),iy
       04          
0418E0 DD 22 FA 18 0158*  	ld (@x1),ix
       04          
0418E5 ED 53 FC 18 0159*  	ld (@y0),de
       04          
0418EA 21 F5 18 04 0160*  	ld hl,@cmd
0418EE 01 09 00 00 0161*  	ld bc,@end-@cmd
0418F2 5B DF       0162*  	rst.lil $18
0418F4 C9          0163*  	ret
0418F5 18          0164*  @cmd:   db 24 ; set graphics viewport command
0418F6 00 00       0165*  @x0: 	dw 0x0000 ; set by bc
0418F8 00 00       0166*  @y1: 	dw 0x0000 ; set by iy
0418FA 00 00       0167*  @x1: 	dw 0x0000 ; set by ix
0418FC 00 00       0168*  @y0: 	dw 0x0000 ; set by de
0418FE 00          0169*  @end:   db 0x00	  ; padding
0418FF             0170*  
0418FF             0171*  ; SCREEN MODES
0418FF             0172*  ; ===============================
0418FF             0173*  ; Mode  Horz  Vert  Cols  Refresh
0418FF             0174*  ; ---   ----  ----  ----  -------
0418FF             0175*  ; 11    320   240   2     60hz
0418FF             0176*  ; 139   320   240   2     60hz
0418FF             0177*  ; 23    512   384   2     60hz
0418FF             0178*  ; 151   512   384   2     60hz
0418FF             0179*  ; 6     640   240   2     60hz
0418FF             0180*  ; 134   640   240   2     60hz
0418FF             0181*  ; 2     640   480   2     60hz
0418FF             0182*  ; 130   640   480   2     60hz
0418FF             0183*  ; 17    800   600   2     60hz
0418FF             0184*  ; 145   800   600   2     60hz
0418FF             0185*  ; 18    1024  768   2     60hz
0418FF             0186*  ; 146   1024  768   2     60hz
0418FF             0187*  ; ---   ----  ----  ----  -------
0418FF             0188*  ; 10    320   240   4     60hz
0418FF             0189*  ; 138   320   240   4     60hz
0418FF             0190*  ; 22    512   384   4     60hz
0418FF             0191*  ; 150   512   384   4     60hz
0418FF             0192*  ; 5     640   240   4     60hz
0418FF             0193*  ; 133   640   240   4     60hz
0418FF             0194*  ; 1     640   480   4     60hz
0418FF             0195*  ; 129   640   480   4     60hz
0418FF             0196*  ; 16    800   600   4     60hz
0418FF             0197*  ; 19    1024  768   4     60hz
0418FF             0198*  ; ---   ----  ----  ----  -------
0418FF             0199*  ; 9     320   240   16    60hz
0418FF             0200*  ; 137   320   240   16    60hz
0418FF             0201*  ; 21    512   384   16    60hz
0418FF             0202*  ; 149   512   384   16    60hz
0418FF             0203*  ; 4     640   240   16    60hz
0418FF             0204*  ; 132   640   240   16    60hz
0418FF             0205*  ; 0     640   480   16    60hz
0418FF             0206*  ; 7     n/a   n/a   16    60hz
0418FF             0207*  ; ---   ----  ----  ----  -------
0418FF             0208*  ; 8     320   240   64    60hz
0418FF             0209*  ; 136   320   240   64    60hz
0418FF             0210*  ; 20    512   384   64    60hz
0418FF             0211*  ; 3     640   240   64    60hz
0418FF             0212*  ; ---   ----  ----  ----  -------
0418FF             0213*  vdu_set_screen_mode:
0418FF 32 0F 19 04 0214*  	ld (@arg),a
041903 21 0E 19 04 0215*  	ld hl,@cmd
041907 01 02 00 00 0216*  	ld bc,@end-@cmd
04190B 5B DF       0217*  	rst.lil $18
04190D C9          0218*  	ret
04190E 16          0219*  @cmd: db 22 ; set screen mode
04190F 00          0220*  @arg: db 0  ; screen mode parameter
041910             0221*  @end:
041910             0222*  
041910             0223*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
041910             0224*  ; inputs: a is scaling mode, 1=on, 0=off
041910             0225*  ; note: default setting on boot is scaling ON
041910             0226*  vdu_set_scaling:
041910 32 22 19 04 0227*  	ld (@arg),a
041914 21 1F 19 04 0228*  	ld hl,@cmd
041918 01 04 00 00 0229*  	ld bc,@end-@cmd
04191C 5B DF       0230*  	rst.lil $18
04191E C9          0231*  	ret
04191F 17 00 C0    0232*  @cmd: db 23,0,0xC0
041922 00          0233*  @arg: db 0  ; scaling on/off
041923             0234*  @end:
041923             0235*  
041923             0236*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
041923             0237*  ; inputs: hl=bufferId
041923             0238*  vdu_buff_select:
041923 22 35 19 04 0239*  	ld (@bufferId),hl
041927 21 32 19 04 0240*  	ld hl,@cmd
04192B 01 05 00 00 0241*  	ld bc,@end-@cmd
04192F 5B DF       0242*  	rst.lil $18
041931 C9          0243*  	ret
041932 17 1B 20    0244*  @cmd: db 23,27,0x20
041935 00 00       0245*  @bufferId: dw 0x0000
041937 00          0246*  @end: db 0x00 ; padding
041938             0247*  
041938             0248*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
041938             0249*  ; inputs: a=format; bc=width; de=height
041938             0250*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
041938             0251*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
041938             0252*  ; 0 	RGBA8888 (4-bytes per pixel)
041938             0253*  ; 1 	RGBA2222 (1-bytes per pixel)
041938             0254*  ; 2 	Mono/Mask (1-bit per pixel)
041938             0255*  ; 3 	Reserved for internal use by VDP (native format)
041938             0256*  vdu_bmp_create:
041938 ED 43 54 19 0257*      ld (@width),bc
       04          
04193D ED 53 56 19 0258*      ld (@height),de
       04          
041942 32 58 19 04 0259*      ld (@fmt),a
041946 21 51 19 04 0260*  	ld hl,@cmd
04194A 01 08 00 00 0261*  	ld bc,@end-@cmd
04194E 5B DF       0262*  	rst.lil $18
041950 C9          0263*  	ret
041951 17 1B 21    0264*  @cmd:       db 23,27,0x21
041954 00 00       0265*  @width:     dw 0x0000
041956 00 00       0266*  @height:    dw 0x0000
041958 00          0267*  @fmt:       db 0x00
041959             0268*  @end:
041959             0269*  
041959             0270*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
041959             0271*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
041959             0272*  vdu_load_img_rgba2_to_8:
041959             0273*  ; backup the target buffer id and image dimensions
041959 E5          0274*      push hl
04195A D5          0275*      push de
04195B C5          0276*      push bc
04195C             0277*  ; load the rgba2 image to working buffer 65534
04195C 21 FE FF 00 0278*      ld hl,65534 ; temporary working buffer id
041960 CD 63 1A 04 0279*  	call vdu_load_buffer_from_file
041964             0280*  ; restore the image dimensions and target buffer id
041964 C1          0281*      pop bc
041965 D1          0282*      pop de
041966 E1          0283*      pop hl
041967             0284*  ; fall through to vdu_rgba2_to_8
041967             0285*  
041967             0286*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
041967             0287*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
041967             0288*  ; the "expand bitmap" command is:
041967             0289*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
041967             0290*  ; and then to reverse the byte order to fix endian-ness:
041967             0291*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
041967             0292*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
041967             0293*  ; VDU 23,27,&20,targetBufferID%;
041967             0294*  ; VDU 23,27,&21,width%;height%;0
041967             0295*  ; -------------------------------------------------------------------
041967             0296*  ; inputs: bc,de image width,height ; hl = targetBufferId
041967             0297*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
041967             0298*  vdu_rgba2_to_8:
041967             0299*  ; load the image dimensions and buffer id parameters
041967 ED 43 C3 19 0300*      ld (@width),bc
       04          
04196C ED 53 C5 19 0301*      ld (@height),de
       04          
041971 22 A8 19 04 0302*      ld (@bufferId0),hl
041975 22 B5 19 04 0303*      ld (@bufferId2),hl
041979 22 BE 19 04 0304*      ld (@bufferId1),hl
04197D             0305*  ; clean up bytes that got stomped on by the ID loads
04197D 3E 48       0306*      ld a,0x48
04197F 32 AA 19 04 0307*      ld (@bufferId0+2),a
041983 3E 17       0308*      ld a,23
041985 32 C0 19 04 0309*      ld (@bufferId1+2),a
041989 3E 18       0310*      ld a,24
04198B 32 B7 19 04 0311*      ld (@bufferId2+2),a
04198F AF          0312*      xor a
041990 32 C7 19 04 0313*      ld (@height+2),a
041994             0314*  ; send the vdu command strings
041994 21 9F 19 04 0315*      ld hl,@beg
041998 01 29 00 00 0316*      ld bc,@end-@beg
04199C 5B DF       0317*      rst.lil $18
04199E C9          0318*      ret
04199F             0319*  @beg:
04199F             0320*  ; Command 14: Consolidate blocks in a buffer
04199F             0321*  ; VDU 23, 0, &A0, bufferId; 14
04199F 17 00 A0    0322*      db 23,0,0xA0
0419A2 FE FF       0323*      dw 65534 ; workingBufferId
0419A4 0E          0324*      db 14 ; consolidate blocks
0419A5             0325*  ; the "expand bitmap" command is:
0419A5             0326*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0419A5 17 00 A0    0327*      db 23,0,0xA0
0419A8 00 00       0328*  @bufferId0: dw 0x0000 ; targetBufferId
0419AA 48          0329*      db 0x48 ; given as decimal command 72 in the docs
0419AB 02          0330*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0419AC FE FF       0331*      dw 65534 ; sourceBufferId
0419AE 00 7F BF FF 0332*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0419B2             0333*  ; reverse the byte order to fix endian-ness:
0419B2             0334*  ; Command 24: Reverse the order of data of blocks within a buffer
0419B2             0335*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0419B2             0336*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0419B2 17 00 A0    0337*      db 23,0,0xA0
0419B5 00 00       0338*  @bufferId2:    dw 0x0000 ; targetBufferId
0419B7 18          0339*      db 24 ; reverse byte order
0419B8 04          0340*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0419B9 04 00       0341*      dw 4 ; size (4 bytes)
0419BB             0342*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0419BB             0343*  ; VDU 23,27,&20,targetBufferID%;
0419BB 17 1B 20    0344*      db 23,27,0x20 ; select bitmap
0419BE 00 00       0345*  @bufferId1: dw 0x0000 ; targetBufferId
0419C0             0346*  ; VDU 23,27,&21,width%;height%;0
0419C0 17 1B 21    0347*      db 23,27,0x21 ; create bitmap from buffer
0419C3 00 00       0348*  @width: dw 0x0000
0419C5 00 00       0349*  @height: dw 0x0000
0419C7 00          0350*      db 0x00 ; rgba8888 format
0419C8             0351*  @end:
0419C8             0352*  
0419C8             0353*  ; scratch variables
0419C8 00 00 00    0354*  bufferId0: dl 0x000000
0419CB 00 00 00    0355*  bufferId1: dl 0x000000
0419CE             0356*  
0419CE             0357*  ; load a vdu buffer from local memory
0419CE             0358*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0419CE             0359*  vdu_load_buffer:
0419CE ED 43 F7 19 0360*      ld (@length),bc
       04          
0419D3 D5          0361*      push de ; save data pointer
0419D4             0362*  ; send the vdu command string
0419D4 7D          0363*      ld a,l
0419D5 32 F4 19 04 0364*      ld (@bufferId),a
0419D9 7C          0365*      ld a,h
0419DA 32 F5 19 04 0366*      ld (@bufferId+1),a
0419DE 21 F1 19 04 0367*      ld hl,@cmd
0419E2 01 08 00 00 0368*      ld bc,@end-@cmd
0419E6 5B DF       0369*      rst.lil $18
0419E8             0370*  ; send the buffer data
0419E8 E1          0371*      pop hl ; pointer to data
0419E9 ED 4B F7 19 0372*      ld bc,(@length)
       04          
0419EE 5B DF       0373*      rst.lil $18 ; send it
0419F0 C9          0374*      ret
0419F1             0375*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0419F1 17 00 A0    0376*  @cmd:       db 23,0,0xA0
0419F4 00 00       0377*  @bufferId:	dw 0x0000
0419F6 00          0378*  		    db 0 ; load buffer
0419F7 00 00       0379*  @length:	dw 0x0000
0419F9 00          0380*  @end: db 0 ; padding
0419FA             0381*  
0419FA             0382*  ; clear a buffer
0419FA             0383*  ; inputs: hl = bufferId
0419FA             0384*  vdu_clear_buffer:
0419FA 7D          0385*      ld a,l
0419FB 32 12 1A 04 0386*      ld (@bufferId),a
0419FF 7C          0387*      ld a,h
041A00 32 13 1A 04 0388*      ld (@bufferId+1),a
041A04 21 0F 1A 04 0389*      ld hl,@cmd
041A08 01 06 00 00 0390*      ld bc,@end-@cmd
041A0C 5B DF       0391*      rst.lil $18
041A0E C9          0392*      ret
041A0F 17 00 A0    0393*  @cmd:       db 23,0,0xA0
041A12 00 00       0394*  @bufferId:	dw 0x0000
041A14 02          0395*  		    db 2 ; clear buffer
041A15             0396*  @end:
041A15             0397*  
041A15             0398*  vdu_clear_all_buffers:
041A15             0399*  ; clear all buffers
041A15 21 20 1A 04 0400*      ld hl,@beg
041A19 01 06 00 00 0401*      ld bc,@end-@beg
041A1D 5B DF       0402*      rst.lil $18
041A1F C9          0403*      ret
041A20 17 00 A0    0404*  @beg: db 23,0,$A0
041A23 FF FF       0405*        dw -1 ; clear all buffers
041A25 02          0406*        db 2  ; command 2: clear a buffer
041A26             0407*  @end:
041A26             0408*  
041A26             0409*  ; Command 14: Consolidate blocks in a buffer
041A26             0410*  vdu_consolidate_buffer:
041A26             0411*  ; set parameters for vdu call
041A26 7D          0412*      ld a,l
041A27 32 3E 1A 04 0413*      ld (@bufferId),a
041A2B 7C          0414*      ld a,h
041A2C 32 3F 1A 04 0415*      ld (@bufferId+1),a
041A30 21 3B 1A 04 0416*      ld hl,@beg
041A34 01 06 00 00 0417*      ld bc,@end-@beg
041A38 5B DF       0418*      rst.lil $18
041A3A C9          0419*      ret
041A3B             0420*  ; VDU 23, 0, &A0, bufferId; 14
041A3B 17 00 A0    0421*  @beg: db 23,0,0xA0
041A3E 00 00       0422*  @bufferId: dw 0x0000
041A40 0E          0423*             db 14
041A41             0424*  @end:
041A41             0425*  
041A41             0426*  ; load an image file to a buffer and make it a bitmap
041A41             0427*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
041A41             0428*  vdu_load_img:
041A41             0429*  ; back up image type and dimension parameters
041A41 22 C8 19 04 0430*      ld (bufferId0),hl
041A45 F5          0431*      push af
041A46 C5          0432*  	push bc
041A47 D5          0433*  	push de
041A48             0434*  ; load the image
041A48 CD 63 1A 04 0435*  	call vdu_load_buffer_from_file
041A4C             0436*  ; now make it a bitmap
041A4C 2A C8 19 04 0437*      ld hl,(bufferId0)
041A50 CD 26 1A 04 0438*      call vdu_consolidate_buffer
041A54 2A C8 19 04 0439*      ld hl,(bufferId0)
041A58 CD 23 19 04 0440*      call vdu_buff_select
041A5C D1          0441*  	pop de ; image height
041A5D C1          0442*  	pop bc ; image width
041A5E F1          0443*  	pop af ; image type
041A5F C3 38 19 04 0444*  	jp vdu_bmp_create ; will return to caller from there
041A63             0445*  
041A63             0446*  ; inputs: hl = bufferId; iy = pointer to filename
041A63             0447*  vdu_load_buffer_from_file:
041A63 22 C8 19 04 0448*      ld (bufferId0),hl
041A67             0449*  
041A67             0450*  ; clear target buffer
041A67 CD FA 19 04 0451*      call vdu_clear_buffer
041A6B             0452*  
041A6B             0453*  ; open the file in read mode
041A6B             0454*  ; Open a file
041A6B             0455*  ; HLU: Filename
041A6B             0456*  ;   C: Mode
041A6B             0457*  ; Returns:
041A6B             0458*  ;   A: Filehandle, or 0 if couldn't open
041A6B FD E5       0459*  	push iy ; pointer to filename
041A6D E1          0460*  	pop hl
041A6E 0E 01       0461*  	ld c,fa_read
041A70             0462*      MOSCALL mos_fopen
041A70 3E 0A       0001*M 			LD	A, function
041A72 49 CF       0002*M 			RST.LIS	08h
041A74 32 AF 1A 04 0463*      ld (@filehandle),a
041A78             0464*  
041A78             0465*  @read_file:
041A78             0466*  ; Read a block of data from a file
041A78             0467*  ;   C: Filehandle
041A78             0468*  ; HLU: Pointer to where to write the data to
041A78             0469*  ; DEU: Number of bytes to read
041A78             0470*  ; Returns:
041A78             0471*  ; DEU: Number of bytes read
041A78 3A AF 1A 04 0472*      ld a,(@filehandle)
041A7C 4F          0473*      ld c,a
041A7D 21 00 E0 B7 0474*      ld hl,filedata
041A81 11 00 20 00 0475*      ld de,8192 ; max we can read into onboard sram at one time
041A85             0476*      MOSCALL mos_fread
041A85 3E 1A       0001*M 			LD	A, function
041A87 49 CF       0002*M 			RST.LIS	08h
041A89             0477*  
041A89             0478*  ; ; DEBUG: print chunk size
041A89             0479*  ;     push de
041A89             0480*  ;     pop hl
041A89             0481*  ;     call printDec
041A89             0482*  ;     call printNewLine
041A89             0483*  
041A89             0484*  ; test de for zero bytes read
041A89 21 00 00 00 0485*      ld hl,0
041A8D AF          0486*      xor a ; clear carry
041A8E ED 52       0487*      sbc hl,de
041A90 CA A6 1A 04 0488*      jp z,@close_file
041A94             0489*  
041A94             0490*  ; load a vdu buffer from local memory
041A94             0491*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
041A94 2A C8 19 04 0492*      ld hl,(bufferId0)
041A98 D5          0493*      push de ; chunksize
041A99 C1          0494*      pop bc
041A9A 11 00 E0 B7 0495*      ld de,filedata
041A9E CD CE 19 04 0496*      call vdu_load_buffer
041AA2             0497*  
041AA2             0498*  ; ; print progress breadcrumbs
041AA2             0499*  ;     ld a,'.'
041AA2             0500*  ;     rst.lil 10h
041AA2             0501*  
041AA2             0502*  ; read the next block
041AA2 C3 78 1A 04 0503*      jp @read_file
041AA6             0504*  
041AA6             0505*  ; close the file
041AA6             0506*  @close_file:
041AA6 3A AF 1A 04 0507*      ld a,(@filehandle)
041AAA             0508*      MOSCALL mos_fclose
041AAA 3E 0B       0001*M 			LD	A, function
041AAC 49 CF       0002*M 			RST.LIS	08h
041AAE C9          0509*      ret ; vdu_load_buffer_from_file
041AAF             0510*  
041AAF 00          0511*  @filehandle: db 0 ; file handle
041AB0 00 00 00    0512*  @fil: dl 0 ; pointer to FIL struct
041AB3             0513*  
041AB3 00 00 00    0514*  @chunkpointer: dl 0 ; pointer to current chunk
041AB6             0515*  
041AB6             0516*  ; File information structure (FILINFO)
041AB6             0517*  @filinfo:
041AB6 00 00 00 00 0518*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
041ABA 00 00       0519*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
041ABC 00 00       0520*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
041ABE 00          0521*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
041ABF 00 00 00 00 0522*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
041ACC 00 00 00 00 0523*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041BCC             0070       include "parse_args.inc"
041BCC             0001*  ; Parse the parameter string into a C array
041BCC             0002*  ; Parameters
041BCC             0003*  ; - HL: Address of parameter string
041BCC             0004*  ; - IX: Address for array pointer storage
041BCC             0005*  ; Returns:
041BCC             0006*  ; -  C: Number of parameters parsed
041BCC             0007*  ;
041BCC 01 04 00 04 0008*  _parse_params:		LD	BC, _exec_name
041BD0 DD 0F 00    0009*  			LD	(IX+0), BC		; ARGV[0] = the executable name
041BD3 ED 32 03    0010*  			LEA     IX, IX+3
041BD6 CD 0E 1C 04 0011*  			CALL	_skip_spaces		; Skip HL past any leading spaces
041BDA             0012*  ;
041BDA 01 01 00 00 0013*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
041BDE 06 0F       0014*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
041BE0             0015*  ;
041BE0             0016*  _parse_params_1:
041BE0 C5          0017*  			PUSH	BC			; Stack ARGC
041BE1 E5          0018*  			PUSH	HL			; Stack start address of token
041BE2 CD FF 1B 04 0019*  			CALL	_get_token		; Get the next token
041BE6 79          0020*  			LD	A, C			; A: Length of the token in characters
041BE7 D1          0021*  			POP	DE			; Start address of token (was in HL)
041BE8 C1          0022*  			POP	BC			; ARGC
041BE9 B7          0023*  			OR	A			; Check for A=0 (no token found) OR at end of string
041BEA C8          0024*  			RET	Z
041BEB             0025*  ;
041BEB DD 1F 00    0026*  			LD	(IX+0), DE		; Store the pointer to the token
041BEE E5          0027*  			PUSH	HL			; DE=HL
041BEF D1          0028*  			POP	DE
041BF0 CD 0E 1C 04 0029*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
041BF4 AF          0030*  			XOR	A
041BF5 12          0031*  			LD	(DE), A			; Zero-terminate the token
041BF6 ED 32 03    0032*  			LEA  	IX, IX+3			; Advance to next pointer position
041BF9 0C          0033*  			INC	C			; Increment ARGC
041BFA 79          0034*  			LD	A, C			; Check for C >= A
041BFB B8          0035*  			CP	B
041BFC 38 E2       0036*  			JR	C, _parse_params_1	; And loop
041BFE C9          0037*  			RET
041BFF             0038*  
041BFF             0039*  ; Get the next token
041BFF             0040*  ; Parameters:
041BFF             0041*  ; - HL: Address of parameter string
041BFF             0042*  ; Returns:
041BFF             0043*  ; - HL: Address of first character after token
041BFF             0044*  ; -  C: Length of token (in characters)
041BFF             0045*  ;
041BFF 0E 00       0046*  _get_token:		LD	C, 0			; Initialise length
041C01 7E          0047*  @@:			LD	A, (HL)			; Get the character from the parameter string
041C02 B7          0048*  			OR	A			; Exit if 0 (end of parameter string in MOS)
041C03 C8          0049*  			RET 	Z
041C04 FE 0D       0050*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
041C06 C8          0051*  			RET	Z
041C07 FE 20       0052*  			CP	' '			; Exit if space (end of token)
041C09 C8          0053*  			RET	Z
041C0A 23          0054*  			INC	HL			; Advance to next character
041C0B 0C          0055*  			INC 	C			; Increment length
041C0C 18 F3       0056*  			JR	@B
041C0E             0057*  
041C0E             0058*  ; Skip spaces in the parameter string
041C0E             0059*  ; Parameters:
041C0E             0060*  ; - HL: Address of parameter string
041C0E             0061*  ; Returns:
041C0E             0062*  ; - HL: Address of next none-space character
041C0E             0063*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
041C0E             0064*  ;
041C0E 7E          0065*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
041C0F FE 20       0066*  			CP	' '			; Exit if not space
041C11 C0          0067*  			RET	NZ
041C12 23          0068*  			INC	HL			; Advance to next character
041C13 18 F9       0069*  			JR	_skip_spaces		; Increment length
041C15             0070*  
041C15             0071*  ; Storage for the argv array pointers
041C15             0072*  min_args: equ 1
041C15             0073*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
041C15 00 00 00 00 0074*  argv_ptrs:		    BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041C45             0075*  _sps:			DS	3			; Storage for the stack pointer (used by BASIC)
041C48             0076*  
041C48             0077*  ; begin BASIC-specific end code
041C48             0078*  ; This bit of code is called from STAR_BYE and returns us safely to MOS
041C48 ED 7B 45 1C 0079*  _end:			LD		SP, (_sps)		; Restore the stack pointer
       04          
041C4D             0080*  ; fall through to _main_end_ok
041C4D             0081*  ; end BASIC-specific end code
041C4D             0082*  
041C4D             0083*  ; ========== HELPER FUNCTIONS ==========
041C4D             0084*  ;
041C4D             0085*  ; get the next argument after ix as a floating point number
041C4D             0086*  ; inputs: ix = pointer to the argument string
041C4D             0087*  ; outputs: HLH'L'C = floating point number, ix points to the next argument
041C4D             0088*  ; destroys: everything except iy, including prime registers
041C4D             0089*  get_arg_float:
041C4D ED 32 03    0090*      lea ix,ix+3 ; point to the next argument
041C50 DD E5       0091*      push ix ; preserve
041C52 DD 37 00    0092*      ld ix,(ix)  ; point to argument string
041C55 CD E8 15 04 0093*      call val_fp ; convert the string to a float
041C59 DD E1       0094*      pop ix ; restore
041C5B C9          0095*      ret ; return with the value in HLH'L'C
041C5C             0096*  
041C5C             0097*  ; get the next argument after ix as a floating point number and store it in buffer pointed to by iy
041C5C             0098*  ; inputs: ix = pointer to the argument string
041C5C             0099*  ; outputs: HLH'L'C = floating point number, ix points to the next argument
041C5C             0100*  ; destroys: everything except iy, including prime registers
041C5C             0101*  store_arg_iy_float:
041C5C ED 32 03    0102*      lea ix,ix+3 ; point to the next argument
041C5F DD E5       0103*      push ix ; preserve
041C61 DD 37 00    0104*      ld ix,(ix)  ; point to argument string
041C64 CD E8 15 04 0105*      call val_fp ; convert the string to a float
041C68 CD D3 16 04 0106*      call store_float_iy_nor ; save the float in buffer
041C6C DD E1       0107*      pop ix ; restore
041C6E C9          0108*      ret ; return with the value in HLH'L'C
041C6F             0071   
041C6F             0072   init:
041C6F             0073   ; ========================================
041C6F             0074   ; BASIC INITIALIZATION CODE FROM basic/init.asm
041C6F             0075   ; ========================================
041C6F             0076   ;
041C6F             0077   ;Clear the application memory
041C6F             0078   ;
041C6F             0079   _clear_ram:
041C6F E5          0080       push hl
041C70 C5          0081       PUSH		BC
041C71 21 00 20 04 0082       LD		HL, RAM_START
041C75 11 01 20 04 0083       LD		DE, RAM_START + 1
041C79 01 4F 03 00 0084       LD		BC, RAM_END - RAM_START - 1
041C7D AF          0085       XOR		A
041C7E 77          0086       LD		(HL), A
041C7F ED B0       0087       LDIR
041C81 C1          0088       POP		BC
041C82 E1          0089       pop hl
041C83             0090   
041C83             0091   ; initialization done
041C83 C9          0092       RET
041C84             0093   
041C84             0094   ; ========================================
041C84             0095   ; MAIN PROGRAM
041C84             0096   ; ========================================
041C84             0097   ; ---- input arguments (float) ----
041C84             0098   input_params_num: equ 8
041C84             0099   input_params:
041C84 81 1F 85 EB 0100   petals:             db   0x81, 0x1F, 0x85, 0xEB, 0x41 ; 3.03
       41          
041C89 80 D7 A3 70 0101   vectors:            db   0x80, 0xD7, 0xA3, 0x70, 0x7D ; 1.98
       7D          
041C8E 7F 9A 99 99 0102   depth:              db   0x7F, 0x9A, 0x99, 0x99, 0x19 ; 0.6
       19          
041C93 00 42 00 00 0103   periods:            db   0x00, 0x42, 0x00, 0x00, 0x00 ; 66.0
       00          
041C98 7F CC CC CC 0104   shrink:             db   0x7F, 0xCC, 0xCC, 0xCC, 0x4C ; 0.8
       4C          
041C9D 00 40 01 00 0105   radius_scale: 	    db   0x00, 0x40, 0x01, 0x00, 0x00 ; 320.0
       00          
041CA2 00 00 00 00 0106   theta_init: 	    db   0x00, 0x00, 0x00, 0x00, 0x00 ; 0
       00          
041CA7 00 01 00 00 0107   num_increments:     db   0x00, 0x01, 0x00, 0x00, 0x00 ; 1.0
       00          
041CAC             0108   
041CAC 00 00 00 00 0109   target_params: blkb input_params_num*5,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
041CD4             0110   
041CD4             0111   ; ---- amount to increment each parameter each loop (float) ----
041CD4             0112   inc_params:
041CD4 00 00 00 00 0113   petals_inc: blkb 5,0
       00          
041CD9 00 00 00 00 0114   vectors_inc: blkb 5,0
       00          
041CDE 00 00 00 00 0115   depth_inc: blkb 5,0
       00          
041CE3 00 00 00 00 0116   periods_inc: blkb 5,0
       00          
041CE8 00 00 00 00 0117   shrink_inc: blkb 5,0
       00          
041CED 00 00 00 00 0118   radius_scale_inc: blkb 5,0
       00          
041CF2 00 00 00 00 0119   theta_init_inc: blkb 5,0
       00          
041CF7             0120   
041CF7 09 00       0121   G9: DW 9 ; format code for converting floats to strings
041CF9             0122   
041CF9             0123   main:
041CF9             0124   ; set up the display
041CF9 3E 12       0125       ld a,18;+128 ; 18   1024  768   2     60hz  double-buffered
041CFB CD FF 18 04 0126       call vdu_set_screen_mode
041CFF CD 28 18 04 0127   	call cursor_off
041D03             0128   
041D03             0129   main_loop:
041D03             0130   ; get the starting parameters
041D03 CD 7C 1D 04 0131       call get_params
041D07 FD 21 84 1C 0132       ld iy,input_params
       04          
041D0C CD B1 1D 04 0133       call load_input
041D10             0134   
041D10             0135   ; bump pointer to the next sample
041D10 2A 63 00 04 0136       ld hl,(next_sample)
041D14 22 60 00 04 0137       ld (cur_sample),hl
041D18             0138   
041D18             0139   ; get the target parameters
041D18 CD 7C 1D 04 0140       call get_params
041D1C FD 21 AC 1C 0141       ld iy,target_params
       04          
041D21 CD B1 1D 04 0142       call load_input
041D25             0143   
041D25             0144   ; compute the increment parameters
041D25 CD 07 1E 04 0145       call compute_increments
041D29             0146   
041D29             0147   ; iterate to the target sample
041D29 DD 21 A7 1C 0148       ld ix,target_params-5 ; point to num_increments
       04          
041D2E CD 9D 16 04 0149       call fetch_float_nor
041D32 CD 14 16 04 0150       call int2hlu
041D36 45          0151       ld b,l ; loop counter
041D37 05          0152       dec b ; otherwise we draw the target twice ...
041D38 CA 03 1D 04 0153       jp z,main_loop
041D3C             0154   
041D3C             0155   @loop:
041D3C C5          0156       push bc
041D3D             0157   ; assemble the command string and draw the flower
041D3D CD BF 1D 04 0158       call assemble_command
041D41 CD 6D 1D 04 0159       call draw_flower
041D45 CD 54 18 04 0160       call vdu_flip
041D49             0161   
041D49 CD 97 14 04 0162       call waitKeypress
041D4D CD 37 1E 04 0163       call apply_increments
041D51             0164   
041D51             0165   ; check for escape key and quit if pressed
041D51             0166       MOSCALL mos_getkbmap
041D51 3E 1E       0001M  			LD	A, function
041D53 49 CF       0002M  			RST.LIS	08h
041D55 C1          0167       pop bc ; get back the loop counter
041D56             0168   ; 113 Escape
041D56 DD CB 0E 46 0169       bit 0,(ix+14)
041D5A 20 06       0170       jr nz,main_end
041D5C             0171   @Escape:
041D5C 10 DE       0172       djnz @loop ; loop until done
041D5E             0173   
041D5E C3 03 1D 04 0174       jp main_loop
041D62             0175   
041D62             0176   main_end:
041D62             0177   ; restore screen to something normalish
041D62 3E 14       0178       ld a,20 ; 20    512   384   64    60hz  single-buffered
041D64 CD FF 18 04 0179   	call vdu_set_screen_mode
041D68 CD 1A 18 04 0180   	call cursor_on
041D6C C9          0181   	ret
041D6D             0182   
041D6D             0183   draw_flower:
041D6D 21 8E 1E 04 0184       ld hl,command0
041D71             0185       MOSCALL mos_oscli
041D71 3E 10       0001M  			LD	A, function
041D73 49 CF       0002M  			RST.LIS	08h
041D75 3E 20       0186       ld a,' '          ; restore the space after "flower" since
041D77 32 94 1E 04 0187       ld (command1-1),a ; mos_oscli null-terminates each argument
041D7B C9          0188       ret
041D7C             0189   
041D7C             0190   get_params:
041D7C             0191   ; prepare to read the parameter string
041D7C 11 95 1E 04 0192       ld de,command1
041D80 2A 60 00 04 0193       ld hl,(cur_sample)
041D84 7E          0194       ld a,(hl)
041D85 B7          0195       or a
041D86 C2 92 1D 04 0196       jp nz,@loop ; not at end of list so proceed
041D8A 21 66 00 04 0197       ld hl,samples ;loop back to beginning of list
041D8E 22 60 00 04 0198       ld (cur_sample),hl
041D92             0199   @loop:
041D92             0200   ; copy the orginal string to the command buffer since _parse_params zero-terminates each token
041D92 7E          0201       ld a,(hl)
041D93 12          0202       ld (de),a
041D94 23          0203       inc hl
041D95 13          0204       inc de
041D96 B7          0205       or a
041D97 C2 92 1D 04 0206       jp nz,@loop
041D9B 22 63 00 04 0207       ld (next_sample),hl
041D9F             0208   ; parse the parameters
041D9F 21 95 1E 04 0209       ld hl,command1
041DA3 DD 21 15 1C 0210       LD IX,argv_ptrs		; The argv array pointer address
       04          
041DA8 DD E5       0211       PUSH IX
041DAA CD CC 1B 04 0212       CALL _parse_params	; Parse the parameters
041DAE DD E1       0213       POP IX
041DB0 C9          0214       ret
041DB1             0215   
041DB1             0216   ; inputs: ix points to the start of the argument pointers
041DB1             0217   ;         iy points to the start of the parameter values table
041DB1             0218   ; outputs: the parameter values are loaded into the table
041DB1             0219   ;          hl points to the next parameter set
041DB1             0220   load_input:
041DB1 06 08       0221       ld b,input_params_num ; loop counter
041DB3             0222   @loop:
041DB3 C5          0223       push bc ; save the loop counter
041DB4 CD 5C 1C 04 0224       call store_arg_iy_float ; get the next argument and store it
041DB8 ED 33 05    0225       lea iy,iy+5  ; point to the next parameter
041DBB C1          0226       pop bc ; get back the loop counter
041DBC 10 F5       0227       djnz @loop ; loop until done
041DBE C9          0228       ret
041DBF             0229   
041DBF             0230   assemble_command:
041DBF             0231   ; convert the loaded values back into strings and assemble the final command string
041DBF 06 08       0232       ld b,input_params_num ; loop counter
041DC1 FD 21 84 1C 0233       ld iy,input_params  ; point to the parameter values table
       04          
041DC6 DD 21 95 1E 0234       ld ix,command1      ; point to the command string buffer
       04          
041DCB             0235   @loop0:
041DCB C5          0236       push bc             ; save the loop counter
041DCC FD E5       0237       push iy             ; save the parameter pointer
041DCE DD E5       0238       push ix             ; save the command string pointer
041DD0 CD E5 16 04 0239       call fetch_float_iy_nor
041DD4 11 00 20 04 0240       ld de,ACCS          ; point to the string accumulator
041DD8 DD 21 F6 1C 0241       ld ix,G9-1          ; get the format code for the number
       04          
041DDD CD FC 08 04 0242       call STR_FP         ; convert the number to a string
041DE1 EB          0243       ex de,hl            ; point to end of the string
041DE2 36 00       0244       ld (hl),0           ; null-terminate the string
041DE4 21 00 20 04 0245       ld hl,ACCS          ; point to the string accumulator
041DE8 DD E1       0246       pop ix             ; get back the command string pointer
041DEA             0247   @loop1:
041DEA 7E          0248       ld a,(hl)           ; get a character
041DEB DD 77 00    0249       ld (ix),a           ; store it
041DEE 23          0250       inc hl              ; point to the next character
041DEF ED 32 01    0251       lea ix,ix+1         ; point to the next character
041DF2 B7          0252       or a                ; check for end of string
041DF3 20 F5       0253       jr nz,@loop1        ; loop until done
041DF5             0254   
041DF5 3E 20       0255       ld a,' '            ; overwrite the null with a space ...
041DF7 DD 77 FF    0256       ld (ix-1),a         ; ... in case we're not at the end
041DFA FD E1       0257       pop iy              ; get back the parameter pointer
041DFC ED 33 05    0258       lea iy,iy+5         ; point to the next parameter
041DFF C1          0259       pop bc              ; get back the loop counter
041E00 10 C9       0260       djnz @loop0         ; loop until done
041E02             0261   
041E02 AF          0262       xor a
041E03 DD 77 00    0263       ld (ix),a           ; now null-terminate the command string
041E06             0264   
041E06 C9          0265       ret
041E07             0266   
041E07             0267   offset_targets: equ input_params_num*5
041E07             0268   offset_increments: equ input_params_num*5*2
041E07             0269   
041E07             0270   compute_increments:
041E07 06 07       0271       ld b,input_params_num-1 ; loop counter (skip number of increments)
041E09 FD 21 84 1C 0272       ld iy,input_params  ; point to the parameter values table
       04          
041E0E             0273   @loop:
041E0E C5          0274       push bc ; save the loop counter
041E0F CD 58 1E 04 0275       call fetch_float_targets_nor
041E13 CD 09 17 04 0276       call fetch_float_iy_alt ; input_params
041E17 3E 0D       0277       ld a,fsub
041E19 CD FD 00 04 0278       call FPP ; HLH'L'C = target - input
041E1D DD 21 A7 1C 0279       ld ix,target_params-5 ; point to num_increments
       04          
041E22 CD C1 16 04 0280       call fetch_float_alt
041E26 3E 0F       0281       ld a,fdiv
041E28 CD FD 00 04 0282       call FPP ; HLH'L'C = (target - input) / num_increments
041E2C CD 6A 1E 04 0283       call store_float_increments_nor
041E30 ED 33 05    0284       lea iy,iy+5  ; point to the next parameter
041E33 C1          0285       pop bc ; get back the loop counter
041E34 10 D8       0286       djnz @loop ; loop until done
041E36 C9          0287       ret
041E37             0288   
041E37             0289   apply_increments:
041E37 06 08       0290       ld b,input_params_num ; loop counter
041E39 FD 21 84 1C 0291       ld iy,input_params  ; point to the parameter values table
       04          
041E3E             0292   @loop:
041E3E C5          0293       push bc ; save the loop counter
041E3F CD E5 16 04 0294       call fetch_float_iy_nor
041E43 CD 7C 1E 04 0295       call fetch_float_increments_alt
041E47 3E 0B       0296       ld a,fadd
041E49 CD FD 00 04 0297       call FPP ; HLH'L'C = input + increment
041E4D CD D3 16 04 0298       call store_float_iy_nor
041E51 ED 33 05    0299       lea iy,iy+5  ; point to the next parameter
041E54 C1          0300       pop bc ; get back the loop counter
041E55 10 E7       0301       djnz @loop ; loop until done
041E57 C9          0302       ret
041E58             0303   
041E58             0304   ; fetch HLH'L'C floating point number from a 40-bit buffer
041E58             0305   ; inputs: iy = buffer address
041E58             0306   ; outputs: HLH'L'C = floating point number
041E58             0307   ; destroys: HLH'L'C
041E58             0308   fetch_float_targets_nor:
041E58 FD 4E 28    0309       ld c,(iy+0+offset_targets)
041E5B FD 6E 2B    0310       ld l,(iy+3+offset_targets)
041E5E FD 66 2C    0311       ld h,(iy+4+offset_targets)
041E61 D9          0312       exx
041E62 FD 6E 29    0313       ld l,(iy+1+offset_targets)
041E65 FD 66 2A    0314       ld h,(iy+2+offset_targets)
041E68 D9          0315       exx
041E69 C9          0316       ret
041E6A             0317   
041E6A             0318   ; store HLH'L'C floating point number in a 40-bit buffer
041E6A             0319   ; inputs: HLH'L'C = floating point number
041E6A             0320   ;         iy = buffer address
041E6A             0321   ; outputs: buffer filled with floating point number
041E6A             0322   ; destroys: nothing
041E6A             0323   store_float_increments_nor:
041E6A FD 71 50    0324       ld (iy+0+offset_increments),c
041E6D FD 75 53    0325       ld (iy+3+offset_increments),l
041E70 FD 74 54    0326       ld (iy+4+offset_increments),h
041E73 D9          0327       exx
041E74 FD 75 51    0328       ld (iy+1+offset_increments),l
041E77 FD 74 52    0329       ld (iy+2+offset_increments),h
041E7A D9          0330       exx
041E7B C9          0331       ret
041E7C             0332   
041E7C             0333   ; fetch DED'E'B floating point number from a 40-bit buffer
041E7C             0334   ; inputs: iy = buffer address
041E7C             0335   ; outputs: DED'E'B = floating point number
041E7C             0336   ; destroys: DED'E'B
041E7C             0337   fetch_float_increments_alt:
041E7C FD 46 50    0338       ld b,(iy+0+offset_increments)
041E7F FD 5E 53    0339       ld e,(iy+3+offset_increments)
041E82 FD 56 54    0340       ld d,(iy+4+offset_increments)
041E85 D9          0341       exx
041E86 FD 5E 51    0342       ld e,(iy+1+offset_increments)
041E89 FD 56 52    0343       ld d,(iy+2+offset_increments)
041E8C D9          0344       exx
041E8D C9          0345       ret
041E8E             0346   
041E8E             0347   ; @command: asciz "flower 3.93 1.98 .6 66 .8 320 90"
041E8E 66 6C 6F 77 0348   command0: db "flower "
       65 72 20    
041E95 00 00 00 00 0349   command1: blkb 256-7,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00          
041F8E             0350   
041F8E             0351       include "basic/ram.asm" ; must be last so that RAM has room for BASIC operations
041F8E             0001*  ;
041F8E             0002*  ; Title:	BBC Basic Interpreter - Z80 version
041F8E             0003*  ;		RAM Module for BBC Basic Interpreter
041F8E             0004*  ;		For use with Version 2.0 of BBC BASIC
041F8E             0005*  ;		Standard CP/M Distribution Version
041F8E             0006*  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
041F8E             0007*  ; Modified By:	Dean Belfield
041F8E             0008*  ; Created:	12/05/2023
041F8E             0009*  ; Last Updated:	26/06/2023
041F8E             0010*  ;
041F8E             0011*  ; Modinfo:
041F8E             0012*  ; 06/06/2023:	Modified to run in ADL mode
041F8E             0013*  ; 26/06/2023:	Added temporary stores R0 and R1
041F8E             0014*  
041F8E             0015*  			; .ASSUME	ADL = 1
041F8E             0016*  
041F8E             0017*  			; DEFINE	LORAM, SPACE = ROM
041F8E             0018*  			; SEGMENT LORAM
041F8E             0019*  
041F8E             0020*  			; XDEF	ACCS
041F8E             0021*  			; XDEF	BUFFER
041F8E             0022*  			; XDEF	STAVAR
041F8E             0023*  			; XDEF	DYNVAR
041F8E             0024*  			; XDEF	FNPTR
041F8E             0025*  			; XDEF	PROPTR
041F8E             0026*  			; XDEF	PAGE_
041F8E             0027*  			; XDEF	TOP
041F8E             0028*  			; XDEF	LOMEM
041F8E             0029*  			; XDEF 	FREE
041F8E             0030*  			; XDEF	HIMEM
041F8E             0031*  			; XDEF	LINENO
041F8E             0032*  			; XDEF	TRACEN
041F8E             0033*  			; XDEF	AUTONO
041F8E             0034*  			; XDEF	ERRTRP
041F8E             0035*  			; XDEF	ERRTXT
041F8E             0036*  			; XDEF	DATPTR
041F8E             0037*  			; XDEF	ERL
041F8E             0038*  			; XDEF	ERRLIN
041F8E             0039*  			; XDEF	RANDOM
041F8E             0040*  			; XDEF	COUNT
041F8E             0041*  			; XDEF	WIDTH
041F8E             0042*  			; XDEF	ERR
041F8E             0043*  			; XDEF	LISTON
041F8E             0044*  			; XDEF	INCREM
041F8E             0045*  
041F8E             0046*  			; XDEF	FLAGS
041F8E             0047*  			; XDEF	OSWRCHPT
041F8E             0048*  			; XDEF	OSWRCHCH
041F8E             0049*  			; XDEF	OSWRCHFH
041F8E             0050*  			; XDEF	KEYDOWN
041F8E             0051*  			; XDEF	KEYASCII
041F8E             0052*  			; XDEF	KEYCOUNT
041F8E             0053*  
041F8E             0054*  			; XDEF	R0
041F8E             0055*  			; XDEF	R1
041F8E             0056*  
041F8E             0057*  			; XDEF	RAM_START
041F8E             0058*  			; XDEF	RAM_END
041F8E             0059*  			; XDEF	USER
041F8E             0060*  
041F8E             0061*  end_binary: ;  for assemble.py to know where to truncate the binary file
041F8E FF FF FF FF 0062*  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF       
042000             0063*  RAM_START:
042000             0064*  ;
042000 00 00 00 00 0065*  ACCS:           BLKB    256,0             ; String Accumulator
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042100 00 00 00 00 0066*  BUFFER:         BLKB    256,0             ; String Input Buffer
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
042200 00 00 00 00 0067*  STAVAR:         BLKB    27*4,0            ; Static Variables
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
04226C 00 00 00 00 0068*  DYNVAR:         BLKB    54*3,0            ; Dynamic Variable Pointers
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00       
04230E 00 00 00    0069*  FNPTR:          BLKB    3,0               ; Dynamic Function Pointers
042311 00 00 00    0070*  PROPTR:         BLKB    3,0               ; Dynamic Procedure Pointers
042314             0071*  ;
042314 00 00 00    0072*  PAGE_:          BLKB    3,0               ; Start of User Program
042317 00 00 00    0073*  TOP:            BLKB    3,0               ; First Location after User Program
04231A 00 00 00    0074*  LOMEM:          BLKB    3,0               ; Start of Dynamic Storage
04231D 00 00 00    0075*  FREE:           BLKB    3,0               ; First Free Space Byte
042320 00 00 00    0076*  HIMEM:          BLKB    3,0               ; First Protected Byte
042323             0077*  ;
042323 00 00 00    0078*  LINENO:         BLKB    3,0               ; Line Number
042326 00 00 00    0079*  TRACEN:         BLKB    3,0               ; Trace Flag
042329 00 00 00    0080*  AUTONO:         BLKB    3,0               ; Auto Flag
04232C 00 00 00    0081*  ERRTRP:         BLKB    3,0               ; Error Trap
04232F 00 00       0082*  ERRTXT:         BLKB    2,0               ; Error Message Pointer
042331 00 00       0083*  DATPTR:         BLKB    2,0               ; Data Pointer
042333 00 00       0084*  ERL:            BLKB    2,0               ; Error Line
042335 00 00 00    0085*  ERRLIN:         BLKB    3,0               ; The "ON ERROR" Line
042338 00 00 00 00 0086*  RANDOM:         BLKB    5,0               ; Random Number
       00          
04233D 00          0087*  COUNT:          BLKB    1,0               ; Print Position
04233E 00          0088*  WIDTH:          BLKB    1,0               ; Print Width
04233F 00          0089*  ERR:            BLKB    1,0               ; Error Number
042340 00          0090*  LISTON:         BLKB    1,0               ; LISTO (bottom nibble)
042341             0091*                                  ; - BIT 0: If set, output a space after the line number
042341             0092*                                  ; - BIT 1: If set, then indent FOR/NEXT loops
042341             0093*                                  ; - BIT 2: If set, then indent REPEAT/UNTIL loops
042341             0094*                                  ; - BIT 3: If set, then output to buffer for *EDIT
042341             0095*                                  ; OPT FLAG (top nibble)
042341             0096*                                  ; - BIT 4: If set, then list whilst assembling
042341             0097*                                  ; - BIT 5: If set, then assembler errors are reported
042341             0098*                                  ; - BIT 6: If set, then place the code starting at address pointed to by O%
042341             0099*                                  ; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
042341 00          0100*  INCREM:         BLKB    1,0               ; Auto-Increment Value
042342             0101*  ;
042342             0102*  ; --------------------------------------------------------------------------------------------
042342             0103*  ; BEGIN MODIFIED CODE
042342             0104*  ; --------------------------------------------------------------------------------------------
042342             0105*  ; Originally in equs.inc
042342             0106*  ;
042342             0107*  OC:			EQU     15*4+STAVAR     ; CODE ORIGIN (O%)
042342             0108*  PC:			EQU     16*4+STAVAR     ; PROGRAM COUNTER (P%)
042342             0109*  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
042342             0110*  ; --------------------------------------------------------------------------------------------
042342             0111*  ; END MODIFIED CODE
042342             0112*  ; --------------------------------------------------------------------------------------------
042342             0113*  
042342             0114*  ; Extra Agon-implementation specific system variables
042342             0115*  ;
042342 00          0116*  FLAGS:          BLKB    1,0       ; Miscellaneous flags
042343             0117*                                  ; - BIT 7: Set if ESC pressed
042343             0118*                                  ; - BIT 6: Set to disable ESC
042343 00 00       0119*  OSWRCHPT:       BLKB    2,0       ; Pointer for *EDIT
042345 00          0120*  OSWRCHCH:       BLKB    1,0       ; Channel of OSWRCH
042346             0121*                                  ; - 0: Console
042346             0122*                                  ; - 1: File
042346 00          0123*  OSWRCHFH:       BLKB    1,0       ; File handle for OSWRCHCHN
042347 00          0124*  KEYDOWN:        BLKB    1,0       ; Keydown flag
042348 00          0125*  KEYASCII:       BLKB    1,0       ; ASCII code of pressed key
042349 00          0126*  KEYCOUNT:       BLKB    1,0       ; Counts every time a key is pressed
04234A 00 00 00    0127*  R0:             BLKB    3,0       ; General purpose storage for 8/16 to 24 bit operations
04234D 00 00 00    0128*  R1:             BLKB    3,0
042350             0129*  
042350             0130*  ;
042350             0131*  ; This must be at the end
042350             0132*  ;
042350             0133*  RAM_END:
042350 FF FF FF FF 0134*  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
042400             0135*  USER:							; Must be aligned on a page boundary
042400             0136*  
