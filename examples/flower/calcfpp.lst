PC     Output      Line
040000             0001    ;
040000             0002    ; Title:	test
040000             0003    ; Author:	Brandon Gates
040000             0004    ; Created:	29/10/2024
040000             0005    
040000             0006        ASSUME	ADL = 1
040000             0007        INCLUDE "mos_api.inc"
040000             0001*   ;
040000             0002*   ; Title:	AGON MOS - API for user projects
040000             0003*   ; Author:	Dean Belfield
040000             0004*   ; Created:	03/08/2022
040000             0005*   ; Last Updated:	11/11/2023
040000             0006*   ;
040000             0007*   ; Modinfo:
040000             0008*   ; 05/08/2022:	Added mos_feof
040000             0009*   ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*   ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*   ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*   ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*   ; 13/10/2022:	Added mos_oscli
040000             0014*   ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*   ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*   ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*   ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*   ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*   ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*   ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*   ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*   ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*   ; 19/05/2023:	Added sysvar_scrMode
040000             0024*   ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*   ; 03/08/2023:	Added mos_setkbvector
040000             0026*   ; 10/08/2023:	Added mos_getkbmap
040000             0027*   ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*   ; 09/04/2024:   Adapter to ez80asm
040000             0029*   ; VDP control (VDU 23, 0, n)
040000             0030*   ;
040000             0031*   vdp_gp:			EQU 	80h
040000             0032*   vdp_keycode:		EQU 	81h
040000             0033*   vdp_cursor:		EQU	82h
040000             0034*   vdp_scrchar:		EQU	83h
040000             0035*   vdp_scrpixel:		EQU	84h
040000             0036*   vdp_audio:		EQU	85h
040000             0037*   vdp_mode:		EQU	86h
040000             0038*   vdp_rtc:		EQU	87h
040000             0039*   vdp_keystate:		EQU	88h
040000             0040*   vdp_logicalcoords:	EQU	C0h
040000             0041*   vdp_terminalmode:	EQU	FFh
040000             0042*   
040000             0043*   ; MOS high level functions
040000             0044*   ;
040000             0045*   mos_getkey:		EQU	00h
040000             0046*   mos_load:		EQU	01h
040000             0047*   mos_save:		EQU	02h
040000             0048*   mos_cd:			EQU	03h
040000             0049*   mos_dir:		EQU	04h
040000             0050*   mos_del:		EQU	05h
040000             0051*   mos_ren:		EQU	06h
040000             0052*   mos_mkdir:		EQU	07h
040000             0053*   mos_sysvars:		EQU	08h
040000             0054*   mos_editline:		EQU	09h
040000             0055*   mos_fopen:		EQU	0Ah
040000             0056*   mos_fclose:		EQU	0Bh
040000             0057*   mos_fgetc:		EQU	0Ch
040000             0058*   mos_fputc:		EQU	0Dh
040000             0059*   mos_feof:		EQU	0Eh
040000             0060*   mos_getError:		EQU	0Fh
040000             0061*   mos_oscli:		EQU	10h
040000             0062*   mos_copy:		EQU	11h
040000             0063*   mos_getrtc:		EQU	12h
040000             0064*   mos_setrtc:		EQU	13h
040000             0065*   mos_setintvector:	EQU	14h
040000             0066*   mos_uopen:		EQU	15h
040000             0067*   mos_uclose:		EQU	16h
040000             0068*   mos_ugetc:		EQU	17h
040000             0069*   mos_uputc:		EQU 	18h
040000             0070*   mos_getfil:		EQU	19h
040000             0071*   mos_fread:		EQU	1Ah
040000             0072*   mos_fwrite:		EQU	1Bh
040000             0073*   mos_flseek:		EQU	1Ch
040000             0074*   mos_setkbvector:	EQU	1Dh
040000             0075*   mos_getkbmap:		EQU	1Eh
040000             0076*   mos_i2c_open:		EQU	1Fh
040000             0077*   mos_i2c_close:		EQU	20h
040000             0078*   mos_i2c_write:		EQU	21h
040000             0079*   mos_i2c_read:		EQU	22h
040000             0080*   
040000             0081*   
040000             0082*   ; FatFS file access functions
040000             0083*   ;
040000             0084*   ffs_fopen:		EQU	80h
040000             0085*   ffs_fclose:		EQU	81h
040000             0086*   ffs_fread:		EQU	82h
040000             0087*   ffs_fwrite:		EQU	83h
040000             0088*   ffs_flseek:		EQU	84h
040000             0089*   ffs_ftruncate:		EQU	85h
040000             0090*   ffs_fsync:		EQU	86h
040000             0091*   ffs_fforward:		EQU	87h
040000             0092*   ffs_fexpand:		EQU	88h
040000             0093*   ffs_fgets:		EQU	89h
040000             0094*   ffs_fputc:		EQU	8Ah
040000             0095*   ffs_fputs:		EQU	8Bh
040000             0096*   ffs_fprintf:		EQU	8Ch
040000             0097*   ffs_ftell:		EQU	8Dh
040000             0098*   ffs_feof:		EQU	8Eh
040000             0099*   ffs_fsize:		EQU	8Fh
040000             0100*   ffs_ferror:		EQU	90h
040000             0101*   
040000             0102*   ; FatFS directory access functions
040000             0103*   ;
040000             0104*   ffs_dopen:		EQU	91h
040000             0105*   ffs_dclose:		EQU	92h
040000             0106*   ffs_dread:		EQU	93h
040000             0107*   ffs_dfindfirst:		EQU	94h
040000             0108*   ffs_dfindnext:		EQU	95h
040000             0109*   
040000             0110*   ; FatFS file and directory management functions
040000             0111*   ;
040000             0112*   ffs_stat:		EQU	96h
040000             0113*   ffs_unlink:		EQU	97h
040000             0114*   ffs_rename:		EQU	98h
040000             0115*   ffs_chmod:		EQU	99h
040000             0116*   ffs_utime:		EQU	9Ah
040000             0117*   ffs_mkdir:		EQU	9Bh
040000             0118*   ffs_chdir:		EQU	9Ch
040000             0119*   ffs_chdrive:		EQU	9Dh
040000             0120*   ffs_getcwd:		EQU	9Eh
040000             0121*   
040000             0122*   ; FatFS volume management and system configuration functions
040000             0123*   ;
040000             0124*   ffs_mount:		EQU	9Fh
040000             0125*   ffs_mkfs:		EQU	A0h
040000             0126*   ffs_fdisk:		EQU	A1h
040000             0127*   ffs_getfree:		EQU	A2h
040000             0128*   ffs_getlabel:		EQU	A3h
040000             0129*   ffs_setlabel:		EQU	A4h
040000             0130*   ffs_setcp:		EQU	A5h
040000             0131*   
040000             0132*   ; File access modes
040000             0133*   ;
040000             0134*   fa_read:		EQU	01h
040000             0135*   fa_write:		EQU	02h
040000             0136*   fa_open_existing:	EQU	00h
040000             0137*   fa_create_new:		EQU	04h
040000             0138*   fa_create_always:	EQU	08h
040000             0139*   fa_open_always:		EQU	10h
040000             0140*   fa_open_append:		EQU	30h
040000             0141*   
040000             0142*   ; System variable indexes for api_sysvars
040000             0143*   ; Index into _sysvars in globals.asm
040000             0144*   ;
040000             0145*   sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*   sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*   sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*   sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*   sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*   sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*   sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*   sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*   sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*   sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*   sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*   sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*   sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*   sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*   sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*   sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*   sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*   sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*   sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*   sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*   sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*   sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*   sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*   sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*   sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*   sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*   sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*   sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*   sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*   sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*   sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*   sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*   
040000             0178*   ; Flags for the VPD protocol
040000             0179*   ;
040000             0180*   vdp_pflag_cursor:	EQU	00000001b
040000             0181*   vdp_pflag_scrchar:	EQU	00000010b
040000             0182*   vdp_pflag_point:	EQU	00000100b
040000             0183*   vdp_pflag_audio:	EQU	00001000b
040000             0184*   vdp_pflag_mode:		EQU	00010000b
040000             0185*   vdp_pflag_rtc:		EQU	00100000b
040000             0186*   vdp_pflag_mouse:	EQU	01000000b
040000             0187*   ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*   
040000             0189*   ;
040000             0190*   ; FatFS structures
040000             0191*   ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*   ;
040000             0193*   ; Object ID and allocation information (FFOBJID)
040000             0194*   ;
040000             0195*   ;FFOBJID	.STRUCT
040000             0196*   ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*   ;	id:		DS	2	; Hosting volume mount ID
040000             0198*   ;	attr:		DS	1	; Object attribute;
040000             0199*   ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*   ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*   ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*   ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*   ;
040000             0204*   ; File object structure (FIL)
040000             0205*   ;
040000             0206*   ;FIL .STRUCT
040000             0207*   ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*   ;	flag:		DS	1	; File status flags
040000             0209*   ;	err:		DS	1	; Abort flag (error code)
040000             0210*   ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*   ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*   ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*   ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*   ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*   ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*   ;
040000             0217*   ; Directory object structure (DIR)
040000             0218*   ;
040000             0219*   ;DIR .STRUCT
040000             0220*   ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*   ;	dptr:		DS	4	; Current read/write offset
040000             0222*   ;	clust:		DS	4	; Current cluster
040000             0223*   ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*   ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*   ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*   ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*   ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*   ;
040000             0229*   ; File information structure (FILINFO)
040000             0230*   ;
040000             0231*   ;FILINFO .STRUCT
040000             0232*   ;	fsize:		DS 	4	; File size
040000             0233*   ;	fdate:		DS	2	; Modified date;
040000             0234*   ;	ftime:		DS	2	; Modified time
040000             0235*   ;	fattrib:	DS	1	; File attribute
040000             0236*   ;	altname:	DS	13	; Alternative file name
040000             0237*   ;	fname:		DS	256	; Primary file name
040000             0238*   ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*   
040000             0240*   ;
040000             0241*   ; Macro for calling the API
040000             0242*   ; Parameters:
040000             0243*   ; - function: One of the function numbers listed above
040000             0244*   ;
040000             0245*   			MACRO	MOSCALL function
040000             0246*   			LD	A, function
040000             0247*   			RST.L	08h
040000             0248*   			ENDMACRO
040000             0008        ORG 0x0B0000 ; Is a moslet
0B0000             0009    
0B0000             0010        MACRO PROGNAME
0B0000             0011        ASCIZ "calcfpp"
0B0000             0012        ENDMACRO
0B0000             0013    
0B0000             0014    ; STANDARD MOSLET INCLUDES
0B0000             0015        include "init.inc"
0B0000             0001*   ;
0B0000             0002*   ; Title:	Copy - Initialisation Code
0B0000             0003*   ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*   ; Created:	06/11/2022
0B0000             0005*   ; Last Updated:	26/12/2022
0B0000             0006*   ;
0B0000             0007*   ; Modinfo:
0B0000             0008*   ; 17/12/2022:	Added parameter processing
0B0000             0009*   ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*   ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*   
0B0000             0012*   
0B0000             0013*   argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*   
0B0000             0015*   ;
0B0000             0016*   ; Start in ADL mode
0B0000             0017*   ;
0B0000 C3 45 00 0B 0018*   			JP	_start			; Jump to start
0B0004             0019*   ;
0B0004             0020*   ; The header stuff is from byte 64 onwards
0B0004             0021*   ;
0B0004             0022*   
0B0004             0023*   _exec_name:
0B0004             0024*   			PROGNAME			; The executable name, only used in argv
0B0004 63 61 6C 63 0001*M      ASCIZ "calcfpp"
       66 70 70 00 
0B000C             0025*   
0B000C FF FF FF FF 0026*   			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0027*   
0B0040 4D 4F 53    0028*   			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*   			DB	00h			; MOS header version 0
0B0044 01          0030*   			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*   ;
0B0045             0032*   ; And the code follows on immediately after the header
0B0045             0033*   ;
0B0045 F5          0034*   _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*   			PUSH	BC
0B0047 D5          0036*   			PUSH	DE
0B0048 DD E5       0037*   			PUSH	IX
0B004A FD E5       0038*   			PUSH	IY
0B004C ED 6E       0039*   			LD	A, MB			; Save MB
0B004E F5          0040*   			PUSH 	AF
0B004F AF          0041*   			XOR 	A
0B0050 ED 6D       0042*   			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*   
0B0052 DD 21 B9 00 0044*   			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*   			PUSH	IX
0B0059 CD 70 00 0B 0046*   			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*   			POP	IX			; IX: argv
0B005F 06 00       0048*   			LD	B, 0			;  C: argc
0B0061 CD A2 47 0B 0049*   			CALL	_main			; Start user code
0B0065             0050*   
0B0065 F1          0051*   			POP 	AF
0B0066 ED 6D       0052*   			LD	MB, A
0B0068 FD E1       0053*   			POP	IY			; Restore registers
0B006A DD E1       0054*   			POP	IX
0B006C D1          0055*   			POP	DE
0B006D C1          0056*   			POP	BC
0B006E F1          0057*   			POP	AF
0B006F C9          0058*   			RET
0B0070             0059*   
0B0070             0060*   ; Parse the parameter string into a C array
0B0070             0061*   ; Parameters
0B0070             0062*   ; - HL: Address of parameter string
0B0070             0063*   ; - IX: Address for array pointer storage
0B0070             0064*   ; Returns:
0B0070             0065*   ; -  C: Number of parameters parsed
0B0070             0066*   ;
0B0070 01 04 00 0B 0067*   _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*   			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*   			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*   			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*   ;
0B007E 01 01 00 00 0072*   			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*   			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*   ;
0B0084             0075*   _parse_params_1:
0B0084 C5          0076*   			PUSH	BC			; Stack ARGC
0B0085 E5          0077*   			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*   			CALL	_get_token		; Get the next token
0B008A 79          0079*   			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*   			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*   			POP	BC			; ARGC
0B008D B7          0082*   			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*   			RET	Z
0B008F             0084*   ;
0B008F DD 1F 00    0085*   			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*   			PUSH	HL			; DE=HL
0B0093 D1          0087*   			POP	DE
0B0094 CD B2 00 0B 0088*   			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*   			XOR	A
0B0099 12          0090*   			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*   			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*   			INC	C			; Increment ARGC
0B009E 79          0093*   			LD	A, C			; Check for C >= A
0B009F B8          0094*   			CP	B
0B00A0 38 E2       0095*   			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*   			RET
0B00A3             0097*   
0B00A3             0098*   ; Get the next token
0B00A3             0099*   ; Parameters:
0B00A3             0100*   ; - HL: Address of parameter string
0B00A3             0101*   ; Returns:
0B00A3             0102*   ; - HL: Address of first character after token
0B00A3             0103*   ; -  C: Length of token (in characters)
0B00A3             0104*   ;
0B00A3 0E 00       0105*   _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*   @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*   			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*   			RET 	Z
0B00A8 FE 0D       0109*   			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*   			RET	Z
0B00AB FE 20       0111*   			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*   			RET	Z
0B00AE 23          0113*   			INC	HL			; Advance to next character
0B00AF 0C          0114*   			INC 	C			; Increment length
0B00B0 18 F3       0115*   			JR	@B
0B00B2             0116*   
0B00B2             0117*   ; Skip spaces in the parameter string
0B00B2             0118*   ; Parameters:
0B00B2             0119*   ; - HL: Address of parameter string
0B00B2             0120*   ; Returns:
0B00B2             0121*   ; - HL: Address of next none-space character
0B00B2             0122*   ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*   ;
0B00B2 7E          0124*   _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*   			CP	' '			; Exit if not space
0B00B5 C0          0126*   			RET	NZ
0B00B6 23          0127*   			INC	HL			; Advance to next character
0B00B7 18 F9       0128*   			JR	_skip_spaces		; Increment length
0B00B9             0129*   
0B00B9             0130*   ; Storage for the argv array pointers
0B00B9             0131*   ;
0B00B9 00 00 00 00 0132*   argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016        include "parse.inc"
0B00E9             0001*   ;
0B00E9             0002*   ; Title:	Number Parsing Functions
0B00E9             0003*   ; Author:	Dean Belfield
0B00E9             0004*   ; Created:	15/11/2022
0B00E9             0005*   ; Last Updated:	15/11/2022
0B00E9             0006*   ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*   ; Modinfo:
0B00E9             0008*   ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*   
0B00E9             0010*   ; Read a number and convert to binary
0B00E9             0011*   ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*   ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*   ;  Outputs: HL: Updated text pointer
0B00E9             0014*   ;           DE: Value
0B00E9             0015*   ;            A: Terminator (spaces skipped)
0B00E9             0016*   ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*   ; Destroys: A,D,E,H,L,F
0B00E9             0018*   ;
0B00E9 11 00 00 00 0019*   ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*   			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*   			LD		A, (HL)			; Read first character
0B00F2 B7          0022*   			OR		A			; Check for end of string
0B00F3 C8          0023*   			RET		Z			; Return with no carry if not
0B00F4 C5          0024*   			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*   			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*   			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*   			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*   ;
0B00FA 7E          0029*   ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*   			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*   			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*   			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*   			CP 		10			; Check if >= 10
0B0105 38 06       0034*   			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*   			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*   			CP 		16			; Check for > F
0B010B 30 2D       0037*   			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*   ;
0B010D E5          0039*   ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*   			PUSH		DE			; LD HL, DE
0B010F E1          0041*   			POP		HL
0B0110 29          0042*   			ADD		HL, HL
0B0111 29          0043*   			ADD		HL, HL
0B0112 29          0044*   			ADD		HL, HL
0B0113 29          0045*   			ADD		HL, HL
0B0114 E5          0046*   			PUSH		HL			; LD DE, HL
0B0115 D1          0047*   			POP		DE
0B0116 E1          0048*   			POP		HL			; Restore HL
0B0117 B3          0049*   			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*   			LD      	E, A
0B0119             0051*   ;
0B0119 23          0052*   			INC		HL			; Onto the next character
0B011A 18 DE       0053*   			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*   ;
0B011C 7E          0055*   ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*   			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*   			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*   			CP		10			; Check if >= 10
0B0123 30 15       0059*   			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*   ;
0B0125 E5          0061*   			PUSH		HL			; Stack HL
0B0126 D5          0062*   			PUSH		DE			; LD HL, DE
0B0127 E1          0063*   			POP		HL
0B0128 E5          0064*   			PUSH		HL			; LD BC, HL
0B0129 C1          0065*   			POP		BC
0B012A 29          0066*   			ADD		HL, HL 			; x 2
0B012B 29          0067*   			ADD		HL, HL 			; x 4
0B012C 09          0068*   			ADD		HL, BC 			; x 5
0B012D 29          0069*   			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*   			LD		BC, 0
0B0132 4F          0071*   			LD 		C, A			; LD BCU, A
0B0133 09          0072*   			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*   			PUSH		HL			; LD DE, HL
0B0135 D1          0074*   			POP		DE
0B0136 E1          0075*   			POP		HL			; Restore HL
0B0137             0076*   ;
0B0137 23          0077*   			INC		HL
0B0138 18 E2       0078*   			JR		ASC_TO_NUMBER3
0B013A C1          0079*   ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*   			SCF					; We have a valid number so set carry
0B013C C9          0081*   			RET
0B013D             0082*   
0B013D             0083*   
0B013D             0084*   ; Convert a character to upper case
0B013D             0085*   ;  A: Character to convert
0B013D             0086*   ;
0B013D E6 7F       0087*   UPPRC:  		AND     	7FH
0B013F FE 60       0088*   			CP      	'`'
0B0141 D8          0089*   			RET     	C
0B0142 E6 5F       0090*   			AND     	5FH			; Convert to upper case
0B0144 C9          0091*   			RET
0B0145             0092*   
0B0145             0093*   
0B0145             0094*   ;------------------------------------------------------------------------
0B0145             0095*   ; Read a number and convert to binary (decimal only)
0B0145             0096*   ; Inputs: hl: Pointer in string buffer
0B0145             0097*   ; Outputs: hl: Updated text pointer
0B0145             0098*   ;         de: Value
0B0145             0099*   ;         a: Terminator (spaces skipped)
0B0145             0100*   ;         f: Carry set if valid number, otherwise reset
0B0145             0101*   ; Destroys: a, d, e, h, l, f
0B0145             0102*   ;------------------------------------------------------------------------
0B0145             0103*   asc_to_s24:
0B0145 3E 01       0104*       ld a,1 ; set sign flag
0B0147 32 93 01 0B 0105*       ld (@sign),a ; store sign flag
0B014B             0106*   
0B014B 11 00 00 00 0107*       ld de, 0 ; initialise de
0B014F             0108*       ; call _skip_spaces ; skip whitespace
0B014F             0109*   
0B014F 7E          0110*       ld a, (hl) ; read first character
0B0150 B7          0111*       or a ; check for end of string
0B0151 C8          0112*       ret z ; return with no carry if not
0B0152             0113*   
0B0152 C5          0114*       push bc ; preserve bc
0B0153             0115*   
0B0153 FE 2D       0116*       cp '-' ; check for negative number
0B0155 C2 5F 01 0B 0117*       jp nz,@loop ; number is positive, nothing more to do
0B0159 AF          0118*       xor a ; sign flag to zero
0B015A 32 93 01 0B 0119*       ld (@sign),a ; store sign flag
0B015E 23          0120*       inc hl ; skip '-'
0B015F             0121*   
0B015F             0122*   @loop:
0B015F 7E          0123*       ld a, (hl)
0B0160 D6 30       0124*       sub '0' ; normalise to 0
0B0162 38 19       0125*       jr c, @integer_end ; return if < ascii '0'
0B0164 FE 0A       0126*       cp 10 ; check if >= 10
0B0166 30 15       0127*       jr nc, @integer_end ; return if >= 10
0B0168 E5          0128*       push hl ; stack hl
0B0169 D5          0129*       push de ; ld hl, de
0B016A E1          0130*       pop hl
0B016B E5          0131*       push hl ; ld bc, hl
0B016C C1          0132*       pop bc
0B016D 29          0133*       add hl, hl ; x 2
0B016E 29          0134*       add hl, hl ; x 4
0B016F 09          0135*       add hl, bc ; x 5
0B0170 29          0136*       add hl, hl ; x 10
0B0171 01 00 00 00 0137*       ld bc, 0
0B0175 4F          0138*       ld c, a ; ld bcu, a
0B0176 09          0139*       add hl, bc ; add bcu to hl
0B0177 E5          0140*       push hl ; ld de, hl
0B0178 D1          0141*       pop de
0B0179 E1          0142*       pop hl ; restore hl
0B017A 23          0143*       inc hl
0B017B 18 E2       0144*       jr @loop
0B017D             0145*   
0B017D             0146*   @integer_end:
0B017D C1          0147*       pop bc ; send bc back how she came in
0B017E 3A 93 01 0B 0148*       ld a, (@sign) ; get sign flag
0B0182 3D          0149*       dec a ; check if negative
0B0183 F2 91 01 0B 0150*       jp p,@pos ; positive number
0B0187             0151*   
0B0187             0152*   ; Negate de
0B0187 E5          0153*       push hl ; save text pointer
0B0188 21 00 00 00 0154*       ld hl, 0
0B018C AF          0155*       xor a ; clear carry
0B018D ED 52       0156*       sbc hl, de ; subtract DE from HL
0B018F EB          0157*       ex de, hl ; DE = 0-HL
0B0190 E1          0158*       pop hl ; restore text pointer
0B0191             0159*   
0B0191             0160*   @pos:
0B0191 37          0161*       scf ; we have a valid number so set carry
0B0192 C9          0162*       ret
0B0193             0163*   
0B0193 00          0164*   @sign: db 0 ; sign flag buffer
0B0194             0165*   
0B0194             0166*   
0B0194             0167*   ;------------------------------------------------------------------------
0B0194             0168*   ; Read a number and convert to binary (decimal only)
0B0194             0169*   ; Inputs: hl: Pointer in string buffer
0B0194             0170*   ; Outputs: hl: Updated text pointer
0B0194             0171*   ;         de: Value
0B0194             0172*   ;         a: Terminator (spaces skipped)
0B0194             0173*   ;         f: Carry set if valid number, otherwise reset
0B0194             0174*   ; Destroys: a, d, e, h, l, f
0B0194             0175*   ;------------------------------------------------------------------------
0B0194             0176*   asc_to_s168:
0B0194 3E 01       0177*       ld a,1 ; set sign flag
0B0196 32 53 02 0B 0178*       ld (@sign),a ; store sign flag
0B019A             0179*   
0B019A 11 00 00 00 0180*       ld de, 0 ; initialise de
0B019E ED 53 4B 02 0181*       ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A3 ED 53 4F 02 0182*       ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01A8             0183*   
0B01A8             0184*       ; call _skip_spaces ; skip whitespace
0B01A8             0185*   
0B01A8 7E          0186*       ld a, (hl) ; read first character
0B01A9 B7          0187*       or a ; check for end of string
0B01AA C8          0188*       ret z ; return with no carry if not
0B01AB             0189*   
0B01AB C5          0190*       push bc ; preserve bc
0B01AC             0191*   
0B01AC FE 2D       0192*       cp '-' ; check for negative number
0B01AE C2 B8 01 0B 0193*       jp nz,@loop ; number is positive, nothing more to do
0B01B2 AF          0194*       xor a ; sign flag to zero
0B01B3 32 53 02 0B 0195*       ld (@sign),a ; store sign flag
0B01B7 23          0196*       inc hl ; skip '-'
0B01B8             0197*   
0B01B8             0198*   @loop:
0B01B8 7E          0199*       ld a, (hl)
0B01B9             0200*   
0B01B9             0201*   ; chcek for decimal point
0B01B9 FE 2E       0202*       cp '.' ; check for decimal point
0B01BB CA FC 01 0B 0203*       jp z,@fractional_start ; jump to fractional part
0B01BF             0204*   
0B01BF             0205*   ; process integer part
0B01BF D6 30       0206*       sub '0' ; normalise to 0
0B01C1 38 19       0207*       jr c, @integer_end ; return if < ascii '0'
0B01C3 FE 0A       0208*       cp 10 ; check if >= 10
0B01C5 30 15       0209*       jr nc, @integer_end ; return if >= 10
0B01C7 E5          0210*       push hl ; stack hl
0B01C8 D5          0211*       push de ; ld hl, de
0B01C9 E1          0212*       pop hl
0B01CA E5          0213*       push hl ; ld bc, hl
0B01CB C1          0214*       pop bc
0B01CC 29          0215*       add hl, hl ; x 2
0B01CD 29          0216*       add hl, hl ; x 4
0B01CE 09          0217*       add hl, bc ; x 5
0B01CF 29          0218*       add hl, hl ; x 10
0B01D0 01 00 00 00 0219*       ld bc, 0
0B01D4 4F          0220*       ld c, a ; ld bcu, a
0B01D5 09          0221*       add hl, bc ; add bcu to hl
0B01D6 E5          0222*       push hl ; ld de, hl
0B01D7 D1          0223*       pop de
0B01D8 E1          0224*       pop hl ; restore hl
0B01D9 23          0225*       inc hl
0B01DA 18 DC       0226*       jr @loop
0B01DC             0227*   
0B01DC             0228*   @integer_end:
0B01DC ED 53 4C 02 0229*       ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E1             0230*   
0B01E1             0231*   @end:
0B01E1 C1          0232*       pop bc ; send bc back how she came in
0B01E2 ED 5B 4B 02 0233*       ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01E7 3A 53 02 0B 0234*       ld a, (@sign) ; get sign flag
0B01EB 3D          0235*       dec a ; check if negative
0B01EC F2 FA 01 0B 0236*       jp p,@pos ; positive number
0B01F0             0237*   
0B01F0             0238*   ; Negate de
0B01F0 E5          0239*       push hl ; save text pointer
0B01F1 21 00 00 00 0240*       ld hl, 0
0B01F5 AF          0241*       xor a ; clear carry
0B01F6 ED 52       0242*       sbc hl, de ; subtract DE from HL
0B01F8 EB          0243*       ex de, hl ; DE = 0-HL
0B01F9 E1          0244*       pop hl ; restore text pointer
0B01FA             0245*   
0B01FA             0246*   @pos:
0B01FA 37          0247*       scf ; we have a valid number so set carry
0B01FB C9          0248*       ret
0B01FC             0249*   
0B01FC             0250*   @fractional_start:
0B01FC DD E5       0251*       push ix                    ; preserve ix
0B01FE ED 53 4C 02 0252*       ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0203 06 03       0253*       ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0205 11 00 00 00 0254*       ld de, 0                   ; Initialize DE as the fractional accumulator
0B0209 DD 21 54 02 0255*       ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B020E 23          0256*       inc hl                     ; Skip decimal point
0B020F             0257*   
0B020F             0258*   @fractional_loop:
0B020F 7E          0259*       ld a, (hl)                 ; Load next character
0B0210 D6 30       0260*       sub '0'                    ; Normalize ASCII to decimal
0B0212 38 1C       0261*       jr c, @end_fraction        ; Exit if < '0'
0B0214 FE 0A       0262*       cp 10
0B0216 30 18       0263*       jr nc, @end_fraction       ; Exit if >= 10
0B0218             0264*   
0B0218             0265*       ; Multiply the current fractional accumulator by 10
0B0218 E5          0266*       push hl                    ; Save char pointer
0B0219 F5          0267*       push af                    ; Save the digit
0B021A EB          0268*       ex de, hl
0B021B E5          0269*       push hl
0B021C 29          0270*       add hl,hl ; * 2
0B021D 29          0271*       add hl,hl ; * 4
0B021E D1          0272*       pop de
0B021F 19          0273*       add hl,de ; * 5
0B0220 29          0274*       add hl,hl ; * 10
0B0221 11 00 00 00 0275*       ld de, 0                   ; Clear DEU
0B0225 F1          0276*       pop af                     ; Restore the current digit
0B0226 5F          0277*       ld e, a                    ; Load the digit into E
0B0227 19          0278*       add hl, de                 ; Add the digit to the accumulator
0B0228 EB          0279*       ex de, hl                  ; Result back to DE
0B0229 ED 32 03    0280*       lea ix,ix+3                ; Advance IX to the next scaling factor
0B022C E1          0281*       pop hl                     ; Restore char pointer
0B022D 23          0282*       inc hl                     ; Move to the next character
0B022E 10 DF       0283*       djnz @fractional_loop      ; Loop if more digits to process
0B0230             0284*   
0B0230             0285*   @end_fraction:
0B0230             0286*   ; Final scaling based on number of fractional digits processed
0B0230 ED 53 50 02 0287*       ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0235 2A 4F 02 0B 0288*       ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0239             0289*   
0B0239 DD 17 00    0290*       ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B023C CD 40 09 0B 0291*       call udiv24                ; Perform 24-bit division to scale down
0B0240 7B          0292*       ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0241 32 4B 02 0B 0293*       ld (@result), a            ; Store fractional part in result buffer
0B0245 DD E1       0294*       pop ix                     ; Restore ix
0B0247 C3 E1 01 0B 0295*       jp @end                    ; Final sign check and flag setup
0B024B             0296*   
0B024B             0297*   @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B024F             0298*   @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0253 00          0299*   @sign: db 0                    ; Sign flag buffer
0B0254             0300*   
0B0254             0301*   powers_of_10:
0B0254 01 00 00    0302*       dl 1                       ; 10^0
0B0257 0A 00 00    0303*       dl 10                      ; 10^1
0B025A 64 00 00    0304*       dl 100                     ; 10^2
0B025D E8 03 00    0305*       dl 1000                    ; 10^3
0B0260 10 27 00    0306*       dl 10000                   ; 10^4
0B0263             0017    
0B0263             0018    ; API INCLUDES
0B0263             0019        include "functions.inc"
0B0263             0001*       MACRO printChar char
0B0263             0002*           LD A, char
0B0263             0003*           RST.LIL 10h
0B0263             0004*       ENDMACRO
0B0263             0005*   
0B0263             0006*   ; test the sign of HL
0B0263             0007*   ; inputs: HL obviously
0B0263             0008*   ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0263             0009*   ; destroys: flags
0B0263             0010*       MACRO sign_hlu
0B0263             0011*           add hl,de
0B0263             0012*           or a
0B0263             0013*           sbc hl,de
0B0263             0014*       ENDMACRO
0B0263             0015*   
0B0263             0016*   ; Simulated call to subroutine at HL
0B0263             0017*   ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0263             0018*   ; outputs: whatever the subroutine does, including HL and BC
0B0263             0019*   ; destroys: only what the subroutine does, but always BC
0B0263             0020*       MACRO callHL
0B0263             0021*           ld bc,$+7     ; Address of first instruction after the jump
0B0263             0022*           push bc       ; which constitutes the return address
0B0263             0023*           jp   (hl)     ; Jump to the address in HL
0B0263             0024*       ENDMACRO
0B0263             0025*   
0B0263             0026*   ; Simulated call to subroutine at IX
0B0263             0027*   ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0263             0028*   ; outputs: whatever the subroutine does, including IX and BC
0B0263             0029*   ; destroys: only what the subroutine does, but always BC
0B0263             0030*       MACRO callIX
0B0263             0031*           ld bc,$+7     ; Address of first instruction after the jump
0B0263             0032*           push bc       ; which constitutes the return address
0B0263             0033*           jp   (ix)     ; Jump to the address in IX
0B0263             0034*       ENDMACRO
0B0263             0035*   
0B0263             0036*   ; Simulated call to soubroutinte at IY
0B0263             0037*   ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0263             0038*   ; outputs: whatever the subroutine does, including IY and BC
0B0263             0039*   ; destroys: only what the subroutine does, but always BC
0B0263             0040*       MACRO callIY
0B0263             0041*           ld bc,$+7     ; Address of first instruction after the jump
0B0263             0042*           push bc       ; which constitutes the return address
0B0263             0043*           jp   (iy)     ; Jump to the address in IY
0B0263             0044*       ENDMACRO
0B0263             0045*   
0B0263             0046*   ; put the value in HLU into the accumulator
0B0263             0047*   ; destroys: af
0B0263             0048*       MACRO HLU_TO_A
0B0263             0049*           push hl ; 4 cycles
0B0263             0050*           inc sp ; 1 cycle
0B0263             0051*           pop af  ; 4 cycles
0B0263             0052*           dec sp ; 1 cycle
0B0263             0053*                  ; 10 cycles total
0B0263             0054*       ENDMACRO
0B0263             0055*   
0B0263             0056*       MACRO PUSH_ALL
0B0263             0057*           ex af,af'
0B0263             0058*           exx
0B0263             0059*           push af
0B0263             0060*           push hl
0B0263             0061*           push bc
0B0263             0062*           push de
0B0263             0063*   
0B0263             0064*           ex af,af'
0B0263             0065*           exx
0B0263             0066*           push af
0B0263             0067*           push hl
0B0263             0068*           push bc
0B0263             0069*           push de
0B0263             0070*           push ix
0B0263             0071*           push iy
0B0263             0072*       ENDMACRO
0B0263             0073*   
0B0263             0074*       MACRO POP_ALL
0B0263             0075*           pop iy
0B0263             0076*           pop ix
0B0263             0077*           pop de
0B0263             0078*           pop bc
0B0263             0079*           pop hl
0B0263             0080*           pop af
0B0263             0081*           ex af,af'
0B0263             0082*           exx
0B0263             0083*   
0B0263             0084*           pop de
0B0263             0085*           pop bc
0B0263             0086*           pop hl
0B0263             0087*           pop af
0B0263             0088*           ex af,af'
0B0263             0089*           exx
0B0263             0090*       ENDMACRO
0B0263             0091*   
0B0263             0092*   A_TO_HLU:
0B0263             0093*       ; call is 7 cycles
0B0263 22 70 02 0B 0094*       ld (@scratch),hl ; 7 cycles
0B0267 32 72 02 0B 0095*       ld (@scratch+2),a ; 5 cycles
0B026B 2A 70 02 0B 0096*       ld hl,(@scratch) ; 7 cycles
0B026F C9          0097*       ret ; 6 cycles
0B0270             0098*           ; 25 cycles total
0B0270 00 00 00    0099*   @scratch: dl 0
0B0273             0100*   
0B0273             0101*       ; TODO: implement this
0B0273             0102*       ; MACRO A_TO_HLU
0B0273             0103*       ;     push.s af
0B0273             0104*       ;     inc sp
0B0273             0105*       ;     push.s hl
0B0273             0106*       ;     pop hl
0B0273             0107*       ;     inc sp
0B0273             0108*       ;     inc sp
0B0273             0109*       ; ENDMACRO
0B0273             0110*   
0B0273             0111*   ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0273             0112*   ; Print a zero-terminated string
0B0273             0113*   ; HL: Pointer to string
0B0273             0114*   printString:
0B0273 C5          0115*   	PUSH	BC
0B0274 01 00 00 00 0116*   	LD		BC,0
0B0278 3E 00       0117*   	LD 	 	A,0
0B027A 5B DF       0118*   	RST.LIL 18h
0B027C C1          0119*   	POP		BC
0B027D C9          0120*   	RET
0B027E             0121*   ; print a VDU sequence
0B027E             0122*   ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B027E             0123*   sendVDUsequence:
0B027E C5          0124*   	PUSH	BC
0B027F 01 00 00 00 0125*   	LD		BC, 0
0B0283 4E          0126*   	LD		C, (HL)
0B0284 5B DF       0127*   	RST.LIL	18h
0B0286 C1          0128*   	POP		BC
0B0287 C9          0129*   	RET
0B0288             0130*   ; Print Newline sequence to VDP
0B0288             0131*   printNewLine:
0B0288 F5          0132*       push af ; for some reason rst.lil 10h sets carry flag
0B0289 3E 0D       0133*   	LD	A, '\r'
0B028B 5B D7       0134*   	RST.LIL 10h
0B028D 3E 0A       0135*   	LD	A, '\n'
0B028F 5B D7       0136*   	RST.LIL 10h
0B0291 F1          0137*       pop af
0B0292 C9          0138*   	RET
0B0293             0139*   
0B0293             0140*   ; Print a 24-bit HEX number
0B0293             0141*   ; HLU: Number to print
0B0293             0142*   printHex24:
0B0293             0143*   	; PUSH	HL      ; 4 cycles
0B0293             0144*   	; LD		HL, 2   ; 4 cycles
0B0293             0145*   	; ADD		HL, SP  ; 1 cycle
0B0293             0146*   	; LD		A, (HL) ; 2 cycles
0B0293             0147*   	; POP		HL      ; 4 cycles
0B0293             0148*       ;                 ; 15 cycles total
0B0293 E5          0149*       push hl ; 4 cycles
0B0294 33          0150*       inc sp ; 1 cycle
0B0295 F1          0151*       pop af  ; 4 cycles
0B0296 3B          0152*       dec sp ; 1 cycle
0B0297             0153*               ; 10 cycles total
0B0297 CD A1 02 0B 0154*   	CALL	printHex8
0B029B             0155*   ; Print a 16-bit HEX number
0B029B             0156*   ; HL: Number to print
0B029B             0157*   printHex16:
0B029B 7C          0158*   	LD		A,H
0B029C CD A1 02 0B 0159*   	CALL	printHex8
0B02A0 7D          0160*   	LD		A,L
0B02A1             0161*   ; Print an 8-bit HEX number
0B02A1             0162*   ; A: Number to print
0B02A1             0163*   printHex8:
0B02A1 4F          0164*   	LD		C,A
0B02A2 1F          0165*   	RRA
0B02A3 1F          0166*   	RRA
0B02A4 1F          0167*   	RRA
0B02A5 1F          0168*   	RRA
0B02A6 CD AB 02 0B 0169*   	CALL	@F
0B02AA 79          0170*   	LD		A,C
0B02AB             0171*   @@:
0B02AB E6 0F       0172*   	AND		0Fh
0B02AD C6 90       0173*   	ADD		A,90h
0B02AF 27          0174*   	DAA
0B02B0 CE 40       0175*   	ADC		A,40h
0B02B2 27          0176*   	DAA
0B02B3 5B D7       0177*   	RST.LIL	10h
0B02B5 C9          0178*   	RET
0B02B6             0179*   
0B02B6             0180*   printHexA:
0B02B6 F5          0181*       push af
0B02B7 C5          0182*       push bc
0B02B8 CD A1 02 0B 0183*       call printHex8
0B02BC 3E 20       0184*       ld a,' '
0B02BE 5B D7       0185*       rst.lil 10h
0B02C0 C1          0186*       pop bc
0B02C1 F1          0187*       pop af
0B02C2 C9          0188*       ret
0B02C3             0189*   
0B02C3             0190*   printHexHL:
0B02C3 F5          0191*       push af
0B02C4 C5          0192*       push bc
0B02C5 CD 9B 02 0B 0193*       call printHex16
0B02C9 3E 20       0194*       ld a,' '
0B02CB 5B D7       0195*       rst.lil 10h
0B02CD C1          0196*       pop bc
0B02CE F1          0197*       pop af
0B02CF C9          0198*       ret
0B02D0             0199*   
0B02D0             0200*   printHexUHL:
0B02D0 F5          0201*       push af
0B02D1 C5          0202*       push bc
0B02D2 CD 93 02 0B 0203*       call printHex24
0B02D6 3E 20       0204*       ld a,' '
0B02D8 5B D7       0205*       rst.lil 10h
0B02DA C1          0206*       pop bc
0B02DB F1          0207*       pop af
0B02DC C9          0208*       ret
0B02DD             0209*   
0B02DD             0210*   printHexAUHL:
0B02DD F5          0211*       push af
0B02DE C5          0212*       push bc
0B02DF CD A1 02 0B 0213*       call printHex8
0B02E3 3E 2E       0214*       ld a,'.'
0B02E5 5B D7       0215*       rst.lil 10h
0B02E7 CD 93 02 0B 0216*       call printHex24
0B02EB 3E 20       0217*       ld a,' '
0B02ED 5B D7       0218*       rst.lil 10h
0B02EF C1          0219*       pop bc
0B02F0 F1          0220*       pop af
0B02F1 C9          0221*       ret
0B02F2             0222*   
0B02F2             0223*   printHexABHL:
0B02F2             0224*   ; preserve registers
0B02F2 C5          0225*       push bc ; b will be ok c will not
0B02F3 F5          0226*       push af ; will get totally destroyed
0B02F4             0227*   ; print a
0B02F4 CD A1 02 0B 0228*       call printHex8
0B02F8             0229*   ; print b
0B02F8 78          0230*       ld a,b
0B02F9 CD A1 02 0B 0231*       call printHex8
0B02FD             0232*   ; print hl
0B02FD CD 9B 02 0B 0233*       call printHex16
0B0301             0234*   ; restore registers
0B0301 F1          0235*       pop af
0B0302 C1          0236*       pop bc
0B0303 C9          0237*       ret
0B0304             0238*   
0B0304             0239*   printHexBHL:
0B0304             0240*   ; preserve registers
0B0304 C5          0241*       push bc ; b will be ok c will not
0B0305 F5          0242*       push af ; will get totally destroyed
0B0306             0243*   ; print b
0B0306 78          0244*       ld a,b
0B0307 CD A1 02 0B 0245*       call printHex8
0B030B             0246*   ; print hl
0B030B CD 9B 02 0B 0247*       call printHex16
0B030F             0248*   ; restore registers
0B030F F1          0249*       pop af
0B0310 C1          0250*       pop bc
0B0311 C9          0251*       ret
0B0312             0252*   
0B0312             0253*   printHexCDE:
0B0312             0254*   ; preserve registers
0B0312 C5          0255*       push bc ; b will be ok c will not
0B0313 F5          0256*       push af ; will get totally destroyed
0B0314             0257*   ; print c
0B0314 79          0258*       ld a,c
0B0315 CD A1 02 0B 0259*       call printHex8
0B0319             0260*   ; print de
0B0319 EB          0261*       ex de,hl
0B031A CD 9B 02 0B 0262*       call printHex16
0B031E EB          0263*       ex de,hl
0B031F             0264*   ; restore registers
0B031F F1          0265*       pop af
0B0320 C1          0266*       pop bc
0B0321 C9          0267*       ret
0B0322             0268*   
0B0322             0269*   ; Print a 0x HEX prefix
0B0322             0270*   DisplayHexPrefix:
0B0322 3E 30       0271*   	LD	A, '0'
0B0324 5B D7       0272*   	RST.LIL 10h
0B0326 3E 78       0273*   	LD	A, 'x'
0B0328 5B D7       0274*   	RST.LIL 10h
0B032A C9          0275*   	RET
0B032B             0276*   
0B032B             0277*       MACRO printDecBC
0B032B             0278*           push hl
0B032B             0279*           push bc
0B032B             0280*           pop hl
0B032B             0281*           call printDec
0B032B             0282*           pop hl
0B032B             0283*       ENDMACRO
0B032B             0284*   
0B032B             0285*       MACRO printDecDE
0B032B             0286*           push hl
0B032B             0287*           push de
0B032B             0288*           pop hl
0B032B             0289*           call printDec
0B032B             0290*           pop hl
0B032B             0291*       ENDMACRO
0B032B             0292*   
0B032B             0293*       MACRO printDecHL
0B032B             0294*           call printDec
0B032B             0295*       ENDMACRO
0B032B             0296*   
0B032B             0297*       MACRO printDecIX
0B032B             0298*           push hl
0B032B             0299*           push ix
0B032B             0300*           pop hl
0B032B             0301*           call printDec
0B032B             0302*           pop hl
0B032B             0303*       ENDMACRO
0B032B             0304*   
0B032B             0305*       MACRO printDecIY
0B032B             0306*           push hl
0B032B             0307*           push iy
0B032B             0308*           pop hl
0B032B             0309*           call printDec
0B032B             0310*           pop hl
0B032B             0311*       ENDMACRO
0B032B             0312*   
0B032B             0313*   
0B032B             0314*   ; Prints the right justified decimal value in HL without leading zeroes
0B032B             0315*   ; HL : Value to print
0B032B             0316*   ; preserves all registers and flags
0B032B             0317*   printDec:
0B032B             0318*   ; BEGIN MY CODE
0B032B             0319*   ; back up all the things
0B032B F5          0320*       push af
0B032C C5          0321*       push bc
0B032D D5          0322*       push de
0B032E E5          0323*       push hl
0B032F             0324*   ; END MY CODE
0B032F 11 57 03 0B 0325*   	LD	 DE, _printDecBuffer
0B0333 CD 67 03 0B 0326*   	CALL u24_to_ascii
0B0337             0327*   ; BEGIN MY CODE
0B0337             0328*   ; replace leading zeroes with spaces
0B0337 21 57 03 0B 0329*       LD	 HL, _printDecBuffer
0B033B 06 07       0330*       ld   B, 7 ; if HL was 0, we want to keep the final zero
0B033D             0331*   @loop:
0B033D 7E          0332*       LD	 A, (HL)
0B033E FE 30       0333*       CP	 '0'
0B0340 C2 4A 03 0B 0334*       JP	 NZ, @done
0B0344 3E 20       0335*       LD   A, ' '
0B0346 77          0336*       LD	 (HL), A
0B0347 23          0337*       INC	 HL
0B0348             0338*       ; CALL vdu_cursor_forward
0B0348 10 F3       0339*       DJNZ @loop
0B034A             0340*   @done:
0B034A             0341*   ; END MY CODE
0B034A 21 57 03 0B 0342*   	LD	 HL, _printDecBuffer
0B034E CD 73 02 0B 0343*   	CALL printString
0B0352             0344*   ; BEGIN MY CODE
0B0352             0345*   ; restore all the things
0B0352 E1          0346*       pop hl
0B0353 D1          0347*       pop de
0B0354 C1          0348*       pop bc
0B0355 F1          0349*       pop af
0B0356             0350*   ; END MY CODE
0B0356 C9          0351*   	RET
0B0357 00 00 00 00 0352*   _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0367             0353*   
0B0367             0354*   ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0367             0355*   ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0367             0356*   ; so it will allways be 8 characters length
0B0367             0357*   ; HL : Value to convert to string
0B0367             0358*   ; DE : pointer to buffer, at least 8 byte + 0
0B0367             0359*   u24_to_ascii:
0B0367 01 80 69 67 0360*   	LD	 BC,-10000000
0B036B CD 9E 03 0B 0361*   	CALL @one_digit
0B036F 01 C0 BD F0 0362*   	LD	 BC,-1000000
0B0373 CD 9E 03 0B 0363*   	CALL @one_digit
0B0377 01 60 79 FE 0364*   	LD	 BC,-100000
0B037B CD 9E 03 0B 0365*   	CALL @one_digit
0B037F 01 F0 D8 FF 0366*   	LD   BC,-10000
0B0383 CD 9E 03 0B 0367*   	CALL @one_digit
0B0387 01 18 FC FF 0368*   	LD   BC,-1000
0B038B CD 9E 03 0B 0369*   	CALL @one_digit
0B038F 01 9C FF FF 0370*   	LD   BC,-100
0B0393 CD 9E 03 0B 0371*   	CALL @one_digit
0B0397 0E F6       0372*   	LD   C,-10
0B0399 CD 9E 03 0B 0373*   	CALL @one_digit
0B039D 48          0374*   	LD   C,B
0B039E             0375*   @one_digit:
0B039E 3E 2F       0376*   	LD   A,'0'-1
0B03A0             0377*   @divide_me:
0B03A0 3C          0378*   	INC  A
0B03A1 09          0379*   	ADD  HL,BC
0B03A2 38 FC       0380*   	JR   C,@divide_me
0B03A4 ED 42       0381*   	SBC  HL,BC
0B03A6 12          0382*   	LD   (DE),A
0B03A7 13          0383*   	INC  DE
0B03A8 C9          0384*   	RET
0B03A9             0385*   
0B03A9             0386*   print_u24:
0B03A9 D5          0387*       push de
0B03AA E5          0388*       push hl
0B03AB 11 57 03 0B 0389*       ld de,_printDecBuffer
0B03AF CD 67 03 0B 0390*       call u24_to_ascii
0B03B3 21 57 03 0B 0391*       ld hl,_printDecBuffer
0B03B7 CD 73 02 0B 0392*       call printString
0B03BB 3E 20       0393*       ld a,' '
0B03BD 5B D7       0394*       rst.lil 10h
0B03BF E1          0395*       pop hl
0B03C0 D1          0396*       pop de
0B03C1 C9          0397*       ret
0B03C2             0398*   
0B03C2             0399*   ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03C2             0400*   ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03C2             0401*   ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03C2             0402*   u168_to_ascii:
0B03C2             0403*   ; add a leading space to make room for sign flag if needed
0B03C2 3E 20       0404*       ld a,' '
0B03C4 12          0405*       ld (de),a
0B03C5 13          0406*       inc de
0B03C6             0407*   ; Convert integer part
0B03C6 E5          0408*       push hl               ; Save HL (well need the fractional part later)
0B03C7 CD B8 08 0B 0409*       call hlu_udiv256    ; Shift to get integer portion in HL
0B03CB 01 F0 D8 FF 0410*       ld   bc, -10000
0B03CF CD F2 03 0B 0411*       call @one_int
0B03D3 01 18 FC FF 0412*       ld   bc, -1000
0B03D7 CD F2 03 0B 0413*       call @one_int
0B03DB 01 9C FF FF 0414*       ld   bc, -100
0B03DF CD F2 03 0B 0415*       call @one_int
0B03E3 0E F6       0416*       ld   c, -10
0B03E5 CD F2 03 0B 0417*       call @one_int
0B03E9 48          0418*       ld   c, b
0B03EA CD F2 03 0B 0419*       call @one_int
0B03EE C3 FD 03 0B 0420*       jp   @frac            ; Jump to fractional part conversion
0B03F2             0421*   @one_int:
0B03F2 3E 2F       0422*       ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F4             0423*   @divide_me:
0B03F4 3C          0424*       inc  a
0B03F5 09          0425*       add  hl, bc           ; Accumulate until overflow
0B03F6 38 FC       0426*       jr   c, @divide_me
0B03F8 ED 42       0427*       sbc  hl, bc           ; Remove excess after overflow
0B03FA 12          0428*       ld   (de), a          ; Store ASCII digit
0B03FB 13          0429*       inc  de
0B03FC C9          0430*       ret
0B03FD             0431*   ; Convert fractional part
0B03FD             0432*   @frac:
0B03FD 3E 2E       0433*       ld   a, '.'           ; Decimal point
0B03FF 12          0434*       ld   (de), a
0B0400 13          0435*       inc  de
0B0401 E1          0436*       pop  hl               ; Restore HL with original fraction
0B0402 06 03       0437*       ld   b, 3             ; Loop counter for 3 fractional digits
0B0404             0438*   @frac_loop:
0B0404 26 0A       0439*       ld   h, 10            ; Load multiplier for fractional part
0B0406 ED 6C       0440*       mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0408 3E 30       0441*       ld   a, '0'
0B040A 84          0442*       add  a, h             ; Convert integer part to ASCII
0B040B 12          0443*       ld   (de), a
0B040C 13          0444*       inc  de
0B040D 10 F5       0445*       djnz @frac_loop       ; Repeat for each fractional digit
0B040F             0446*   ; Add null terminator
0B040F AF          0447*       xor  a                ; Null terminator
0B0410 12          0448*       ld   (de), a
0B0411 C9          0449*       ret
0B0412             0450*   
0B0412             0451*   print_u168:
0B0412 D5          0452*       push de
0B0413 E5          0453*       push hl
0B0414 11 57 03 0B 0454*       ld de,_printDecBuffer
0B0418 CD C2 03 0B 0455*       call u168_to_ascii
0B041C 21 57 03 0B 0456*       ld hl,_printDecBuffer
0B0420 CD 73 02 0B 0457*       call printString
0B0424 E1          0458*       pop hl
0B0425 D1          0459*       pop de
0B0426 C9          0460*       ret
0B0427             0461*   
0B0427             0462*   ; signed version of u168_to_ascii
0B0427             0463*   s168_to_ascii:
0B0427 D5          0464*       push de ; save starting address of buffer
0B0428 CD 51 08 0B 0465*       call hlu_abs
0B042C F5          0466*       push af ; save sign flag
0B042D CD C2 03 0B 0467*       call u168_to_ascii
0B0431 F1          0468*       pop af ; restore sign flag
0B0432 D1          0469*       pop de ; restore starting address of buffer
0B0433 F0          0470*       ret p ; hlu was positive so nothing to do
0B0434 3E 2D       0471*       ld a,'-'
0B0436 12          0472*       ld (de),a
0B0437 C9          0473*       ret
0B0438             0474*   
0B0438             0475*   print_s168:
0B0438 D5          0476*       push de
0B0439 E5          0477*       push hl
0B043A 11 57 03 0B 0478*       ld de,_printDecBuffer
0B043E CD 27 04 0B 0479*       call s168_to_ascii
0B0442 21 57 03 0B 0480*       ld hl,_printDecBuffer
0B0446 CD 73 02 0B 0481*       call printString
0B044A E1          0482*       pop hl
0B044B D1          0483*       pop de
0B044C C9          0484*       ret
0B044D             0485*   
0B044D             0486*   print_s168_hl:
0B044D F5          0487*       push af
0B044E E5          0488*       push hl
0B044F CD 38 04 0B 0489*       call print_s168
0B0453 3E 20       0490*       ld a,' '
0B0455 5B D7       0491*       rst.lil 10h
0B0457 E1          0492*       pop hl
0B0458 F1          0493*       pop af
0B0459 C9          0494*       ret
0B045A             0495*   
0B045A             0496*   print_s168_bc:
0B045A F5          0497*       push af
0B045B C5          0498*       push bc
0B045C E5          0499*       push hl
0B045D C5          0500*       push bc
0B045E E1          0501*       pop hl
0B045F CD 38 04 0B 0502*       call print_s168
0B0463 3E 20       0503*       ld a,' '
0B0465 5B D7       0504*       rst.lil 10h
0B0467 E1          0505*       pop hl
0B0468 C1          0506*       pop bc
0B0469 F1          0507*       pop af
0B046A C9          0508*       ret
0B046B             0509*   
0B046B             0510*   print_s168_de:
0B046B F5          0511*       push af
0B046C D5          0512*       push de
0B046D E5          0513*       push hl
0B046E EB          0514*       ex de,hl
0B046F CD 38 04 0B 0515*       call print_s168
0B0473 3E 20       0516*       ld a,' '
0B0475 5B D7       0517*       rst.lil 10h
0B0477 E1          0518*       pop hl
0B0478 D1          0519*       pop de
0B0479 F1          0520*       pop af
0B047A C9          0521*       ret
0B047B             0522*   
0B047B             0523*   print_s168_hl_bc_de:
0B047B F5          0524*       push af
0B047C C5          0525*       push bc
0B047D D5          0526*       push de
0B047E E5          0527*       push hl
0B047F CD 38 04 0B 0528*       call print_s168
0B0483 3E 20       0529*       ld a,' '
0B0485 5B D7       0530*       rst.lil 10h
0B0487 C5          0531*       push bc
0B0488 E1          0532*       pop hl
0B0489 CD 38 04 0B 0533*       call print_s168
0B048D 3E 20       0534*       ld a,' '
0B048F 5B D7       0535*       rst.lil 10h
0B0491 EB          0536*       ex de,hl
0B0492 CD 38 04 0B 0537*       call print_s168
0B0496 3E 20       0538*       ld a,' '
0B0498 5B D7       0539*       rst.lil 10h
0B049A E1          0540*       pop hl
0B049B D1          0541*       pop de
0B049C C1          0542*       pop bc
0B049D F1          0543*       pop af
0B049E C9          0544*       ret
0B049F             0545*   
0B049F             0546*   print_s168_bc_de:
0B049F F5          0547*       push af
0B04A0 C5          0548*       push bc
0B04A1 D5          0549*       push de
0B04A2 C5          0550*       push bc
0B04A3 E1          0551*       pop hl
0B04A4 CD 38 04 0B 0552*       call print_s168
0B04A8 3E 20       0553*       ld a,' '
0B04AA 5B D7       0554*       rst.lil 10h
0B04AC EB          0555*       ex de,hl
0B04AD CD 38 04 0B 0556*       call print_s168
0B04B1 3E 20       0557*       ld a,' '
0B04B3 5B D7       0558*       rst.lil 10h
0B04B5 E1          0559*       pop hl
0B04B6 D1          0560*       pop de
0B04B7 C1          0561*       pop bc
0B04B8 F1          0562*       pop af
0B04B9 C9          0563*       ret
0B04BA             0564*   
0B04BA             0565*   print_s168_a:
0B04BA F5          0566*       push af
0B04BB C5          0567*       push bc
0B04BC E5          0568*       push hl
0B04BD 21 00 00 00 0569*       ld hl,0
0B04C1 6F          0570*       ld l,a
0B04C2 CD 4D 04 0B 0571*       call print_s168_hl
0B04C6 E1          0572*       pop hl
0B04C7 C1          0573*       pop bc
0B04C8 F1          0574*       pop af
0B04C9 C9          0575*       ret
0B04CA             0576*   
0B04CA             0577*   ; #### new functions added by Brandon R. Gates ####
0B04CA             0578*   
0B04CA             0579*   ; print the binary representation of the 8-bit value in a
0B04CA             0580*   ; destroys a, hl, bc
0B04CA             0581*   printBin8:
0B04CA 06 08       0582*       ld b,8      ; loop counter for 8 bits
0B04CC 21 E7 04 0B 0583*       ld hl,@cmd  ; set hl to the low byte of the output string
0B04D0             0584*                   ; (which will be the high bit of the value in a)
0B04D0             0585*   @loop:
0B04D0 07          0586*       rlca ; put the next highest bit into carry
0B04D1 38 04       0587*       jr c,@one
0B04D3 36 30       0588*       ld (hl),'0'
0B04D5 18 02       0589*       jr @next_bit
0B04D7             0590*   @one:
0B04D7 36 31       0591*       ld (hl),'1'
0B04D9             0592*   @next_bit:
0B04D9 23          0593*       inc hl
0B04DA 10 F4       0594*       djnz @loop
0B04DC             0595*   ; print it
0B04DC 21 E7 04 0B 0596*   	ld hl,@cmd
0B04E0 01 08 00 00 0597*   	ld bc,@end-@cmd
0B04E4 5B DF       0598*   	rst.lil $18
0B04E6 C9          0599*   	ret
0B04E7             0600*   @cmd: ds 8 ; eight bytes for eight bits
0B04EF             0601*   @end:
0B04EF             0602*   
0B04EF             0603*   ; print the binary representation of the 8-bit value in a
0B04EF             0604*   ; in reverse order (lsb first)
0B04EF             0605*   ; destroys a, hl, bc
0B04EF             0606*   printBin8Rev:
0B04EF 06 08       0607*       ld b,8      ; loop counter for 8 bits
0B04F1 21 0C 05 0B 0608*       ld hl,@cmd  ; set hl to the low byte of the output string
0B04F5             0609*                   ; (which will be the high bit of the value in a)
0B04F5             0610*   @loop:
0B04F5 0F          0611*       rrca ; put the next lowest bit into carry
0B04F6 38 04       0612*       jr c,@one
0B04F8 36 30       0613*       ld (hl),'0'
0B04FA 18 02       0614*       jr @next_bit
0B04FC             0615*   @one:
0B04FC 36 31       0616*       ld (hl),'1'
0B04FE             0617*   @next_bit:
0B04FE 23          0618*       inc hl
0B04FF 10 F4       0619*       djnz @loop
0B0501             0620*   ; print it
0B0501 21 0C 05 0B 0621*   	ld hl,@cmd
0B0505 01 08 00 00 0622*   	ld bc,@end-@cmd
0B0509 5B DF       0623*   	rst.lil $18
0B050B C9          0624*   	ret
0B050C             0625*   @cmd: ds 8 ; eight bytes for eight bits
0B0514             0626*   @end:
0B0514             0627*   
0B0514             0628*   ; print registers to screen in hexidecimal format
0B0514             0629*   ; inputs: none
0B0514             0630*   ; outputs: values of every register printed to screen
0B0514             0631*   ;    values of each register in global scratch memory
0B0514             0632*   ; destroys: nothing
0B0514             0633*   stepRegistersHex:
0B0514             0634*   ; store everything in scratch
0B0514 22 58 07 0B 0635*       ld (uhl),hl
0B0518 ED 43 5B 07 0636*       ld (ubc),bc
       0B          
0B051D ED 53 5E 07 0637*       ld (ude),de
       0B          
0B0522 DD 22 61 07 0638*       ld (uix),ix
       0B          
0B0527 FD 22 64 07 0639*       ld (uiy),iy
       0B          
0B052C F5          0640*       push af ; fml
0B052D E1          0641*       pop hl  ; thanks, zilog
0B052E 22 55 07 0B 0642*       ld (uaf),hl
0B0532 F5          0643*       push af ; dammit
0B0533             0644*   
0B0533             0645*   ; home the cursor
0B0533             0646*       ; call vdu_home_cursor
0B0533             0647*   
0B0533             0648*   ; print each register
0B0533 21 DB 06 0B 0649*       ld hl,str_afu
0B0537 CD 73 02 0B 0650*       call printString
0B053B 2A 55 07 0B 0651*       ld hl,(uaf)
0B053F CD 93 02 0B 0652*       call printHex24
0B0543 CD 88 02 0B 0653*       call printNewLine
0B0547             0654*   
0B0547 21 E0 06 0B 0655*       ld hl,str_hlu
0B054B CD 73 02 0B 0656*       call printString
0B054F 2A 58 07 0B 0657*       ld hl,(uhl)
0B0553 CD 93 02 0B 0658*       call printHex24
0B0557 CD 88 02 0B 0659*       call printNewLine
0B055B             0660*   
0B055B 21 E5 06 0B 0661*       ld hl,str_bcu
0B055F CD 73 02 0B 0662*       call printString
0B0563 2A 5B 07 0B 0663*       ld hl,(ubc)
0B0567 CD 93 02 0B 0664*       call printHex24
0B056B CD 88 02 0B 0665*       call printNewLine
0B056F             0666*   
0B056F 21 EA 06 0B 0667*       ld hl,str_deu
0B0573 CD 73 02 0B 0668*       call printString
0B0577 2A 5E 07 0B 0669*       ld hl,(ude)
0B057B CD 93 02 0B 0670*       call printHex24
0B057F CD 88 02 0B 0671*       call printNewLine
0B0583             0672*   
0B0583 21 EF 06 0B 0673*       ld hl,str_ixu
0B0587 CD 73 02 0B 0674*       call printString
0B058B 2A 61 07 0B 0675*       ld hl,(uix)
0B058F CD 93 02 0B 0676*       call printHex24
0B0593 CD 88 02 0B 0677*       call printNewLine
0B0597             0678*   
0B0597 21 F4 06 0B 0679*       ld hl,str_iyu
0B059B CD 73 02 0B 0680*       call printString
0B059F 2A 64 07 0B 0681*       ld hl,(uiy)
0B05A3 CD 93 02 0B 0682*       call printHex24
0B05A7 CD 88 02 0B 0683*       call printNewLine
0B05AB             0684*   
0B05AB             0685*       ; call vsync
0B05AB             0686*   
0B05AB CD 88 02 0B 0687*       call printNewLine
0B05AF             0688*   
0B05AF             0689*   ; check for right shift key and quit if pressed
0B05AF             0690*   	MOSCALL mos_getkbmap
0B05AF 3E 1E       0001*M  			LD	A, function
0B05B1 5B CF       0002*M  			RST.L	08h
0B05B3             0691*   @stayhere:
0B05B3             0692*   ; 7 RightShift
0B05B3 DD CB 00 76 0693*       bit 6,(ix+0)
0B05B7 20 02       0694*       jr nz,@RightShift
0B05B9 18 F8       0695*       jr @stayhere
0B05BB             0696*   @RightShift:
0B05BB DD CB 0E 86 0697*       res 0,(ix+14) ; debounce the key (hopefully)
0B05BF 3E 80       0698*       ld a,%10000000
0B05C1 CD 5A 1F 0B 0699*       call multiPurposeDelay
0B05C5             0700*   
0B05C5             0701*   ; restore everything
0B05C5 2A 58 07 0B 0702*       ld hl, (uhl)
0B05C9 ED 4B 5B 07 0703*       ld bc, (ubc)
       0B          
0B05CE ED 5B 5E 07 0704*       ld de, (ude)
       0B          
0B05D3 DD 2A 61 07 0705*       ld ix, (uix)
       0B          
0B05D8 FD 2A 64 07 0706*       ld iy, (uiy)
       0B          
0B05DD F1          0707*       pop af
0B05DE             0708*   ; all done
0B05DE C9          0709*       ret
0B05DF             0710*   
0B05DF             0711*   ; print registers to screen in hexidecimal format
0B05DF             0712*   ; inputs: none
0B05DF             0713*   ; outputs: values of every register printed to screen
0B05DF             0714*   ;    values of each register in global scratch memory
0B05DF             0715*   ; destroys: nothing
0B05DF             0716*   dumpRegistersHex:
0B05DF             0717*   ; store everything in scratch
0B05DF 22 58 07 0B 0718*       ld (uhl),hl
0B05E3 ED 43 5B 07 0719*       ld (ubc),bc
       0B          
0B05E8 ED 53 5E 07 0720*       ld (ude),de
       0B          
0B05ED DD 22 61 07 0721*       ld (uix),ix
       0B          
0B05F2 FD 22 64 07 0722*       ld (uiy),iy
       0B          
0B05F7 F5          0723*       push af ; fml
0B05F8 E1          0724*       pop hl  ; thanks, zilog
0B05F9 22 55 07 0B 0725*       ld (uaf),hl
0B05FD F5          0726*       push af ; dammit
0B05FE             0727*   
0B05FE             0728*   ; home the cursor
0B05FE             0729*       ; call vdu_home_cursor
0B05FE             0730*       ; call printNewLine
0B05FE             0731*   
0B05FE             0732*   ; print each register
0B05FE 21 DB 06 0B 0733*       ld hl,str_afu
0B0602 CD 73 02 0B 0734*       call printString
0B0606 2A 55 07 0B 0735*       ld hl,(uaf)
0B060A CD 93 02 0B 0736*       call printHex24
0B060E             0737*       ; call printNewLine
0B060E             0738*   
0B060E 21 E0 06 0B 0739*       ld hl,str_hlu
0B0612 CD 73 02 0B 0740*       call printString
0B0616 2A 58 07 0B 0741*       ld hl,(uhl)
0B061A CD 93 02 0B 0742*       call printHex24
0B061E             0743*       ; call printNewLine
0B061E             0744*   
0B061E 21 E5 06 0B 0745*       ld hl,str_bcu
0B0622 CD 73 02 0B 0746*       call printString
0B0626 2A 5B 07 0B 0747*       ld hl,(ubc)
0B062A CD 93 02 0B 0748*       call printHex24
0B062E             0749*       ; call printNewLine
0B062E             0750*   
0B062E 21 EA 06 0B 0751*       ld hl,str_deu
0B0632 CD 73 02 0B 0752*       call printString
0B0636 2A 5E 07 0B 0753*       ld hl,(ude)
0B063A CD 93 02 0B 0754*       call printHex24
0B063E             0755*       ; call printNewLine
0B063E             0756*   
0B063E 21 EF 06 0B 0757*       ld hl,str_ixu
0B0642 CD 73 02 0B 0758*       call printString
0B0646 2A 61 07 0B 0759*       ld hl,(uix)
0B064A CD 93 02 0B 0760*       call printHex24
0B064E             0761*       ; call printNewLine
0B064E             0762*   
0B064E 21 F4 06 0B 0763*       ld hl,str_iyu
0B0652 CD 73 02 0B 0764*       call printString
0B0656 2A 64 07 0B 0765*       ld hl,(uiy)
0B065A CD 93 02 0B 0766*       call printHex24
0B065E             0767*       ; call printNewLine
0B065E             0768*   
0B065E             0769*       ; call vdu_vblank
0B065E             0770*   
0B065E CD 88 02 0B 0771*       call printNewLine
0B0662             0772*   ; restore everything
0B0662 2A 58 07 0B 0773*       ld hl, (uhl)
0B0666 ED 4B 5B 07 0774*       ld bc, (ubc)
       0B          
0B066B ED 5B 5E 07 0775*       ld de, (ude)
       0B          
0B0670 DD 2A 61 07 0776*       ld ix, (uix)
       0B          
0B0675 FD 2A 64 07 0777*       ld iy, (uiy)
       0B          
0B067A F1          0778*       pop af
0B067B             0779*   ; all done
0B067B C9          0780*       ret
0B067C             0781*   
0B067C             0782*   dumpRegistersHexPrime:
0B067C D9          0783*       exx
0B067D 08          0784*       ex af,af'
0B067E CD DF 05 0B 0785*       call dumpRegistersHex
0B0682 08          0786*       ex af,af'
0B0683 D9          0787*       exx
0B0684 C9          0788*       ret
0B0685             0789*   
0B0685             0790*   ; additionally dump prime registers
0B0685             0791*   ; inputs: none
0B0685             0792*   ; outputs: values of every register printed to screen
0B0685             0793*   ; destroys: nothing
0B0685             0794*   dumpRegistersHexAll:
0B0685 CD DF 05 0B 0795*       call dumpRegistersHex
0B0689 08          0796*       ex af,af'
0B068A D9          0797*       exx
0B068B CD DF 05 0B 0798*       call dumpRegistersHex
0B068F 08          0799*       ex af,af'
0B0690 D9          0800*       exx
0B0691 C9          0801*       ret
0B0692             0802*   
0B0692             0803*   ; print hlu to screen in hexidecimal format
0B0692             0804*   ; inputs: none
0B0692             0805*   ; destroys: nothing
0B0692             0806*   print_hex_hl:
0B0692 F5          0807*       push af
0B0693 E5          0808*       push hl
0B0694 21 E0 06 0B 0809*       ld hl,str_hlu
0B0698 CD 73 02 0B 0810*       call printString
0B069C E1          0811*       pop hl
0B069D E5          0812*       push hl
0B069E CD 93 02 0B 0813*       call printHex24
0B06A2 3E 20       0814*       ld a,' '
0B06A4 5B D7       0815*       rst.lil 10h
0B06A6 E1          0816*       pop hl
0B06A7 F1          0817*       pop af
0B06A8 C9          0818*       ret
0B06A9             0819*   
0B06A9             0820*   ; print bcu to screen in hexidecimal format
0B06A9             0821*   ; inputs: none
0B06A9             0822*   ; destroys: nothing
0B06A9             0823*   print_hex_bc:
0B06A9 F5          0824*       push af
0B06AA E5          0825*       push hl
0B06AB C5          0826*       push bc
0B06AC 21 E5 06 0B 0827*       ld hl,str_bcu
0B06B0 CD 73 02 0B 0828*       call printString
0B06B4 E1          0829*       pop hl
0B06B5 E5          0830*       push hl
0B06B6 CD 93 02 0B 0831*       call printHex24
0B06BA 3E 20       0832*       ld a,' '
0B06BC 5B D7       0833*       rst.lil 10h
0B06BE C1          0834*       pop bc
0B06BF E1          0835*       pop hl
0B06C0 F1          0836*       pop af
0B06C1 C9          0837*       ret
0B06C2             0838*   
0B06C2             0839*   ; print deu to screen in hexidecimal format
0B06C2             0840*   ; inputs: none
0B06C2             0841*   ; destroys: nothing
0B06C2             0842*   print_hex_de:
0B06C2 F5          0843*       push af
0B06C3 E5          0844*       push hl
0B06C4 D5          0845*       push de
0B06C5 21 EA 06 0B 0846*       ld hl,str_deu
0B06C9 CD 73 02 0B 0847*       call printString
0B06CD E1          0848*       pop hl
0B06CE E5          0849*       push hl
0B06CF CD 93 02 0B 0850*       call printHex24
0B06D3 3E 20       0851*       ld a,' '
0B06D5 5B D7       0852*       rst.lil 10h
0B06D7 D1          0853*       pop de
0B06D8 E1          0854*       pop hl
0B06D9 F1          0855*       pop af
0B06DA C9          0856*       ret
0B06DB             0857*   
0B06DB 20 61 66 3D 0858*   str_afu: db " af=",0
       00          
0B06E0 20 68 6C 3D 0859*   str_hlu: db " hl=",0
       00          
0B06E5 20 62 63 3D 0860*   str_bcu: db " bc=",0
       00          
0B06EA 20 64 65 3D 0861*   str_deu: db " de=",0
       00          
0B06EF 20 69 78 3D 0862*   str_ixu: db " ix=",0
       00          
0B06F4 20 69 79 3D 0863*   str_iyu: db " iy=",0
       00          
0B06F9             0864*   
0B06F9             0865*   ; print udeuhl to screen in hexidecimal format
0B06F9             0866*   ; inputs: none
0B06F9             0867*   ; outputs: concatenated hexidecimal udeuhl
0B06F9             0868*   ; destroys: nothing
0B06F9             0869*   dumpUDEUHLHex:
0B06F9             0870*   ; store everything in scratch
0B06F9 22 58 07 0B 0871*       ld (uhl),hl
0B06FD ED 43 5B 07 0872*       ld (ubc),bc
       0B          
0B0702 ED 53 5E 07 0873*       ld (ude),de
       0B          
0B0707 DD 22 61 07 0874*       ld (uix),ix
       0B          
0B070C FD 22 64 07 0875*       ld (uiy),iy
       0B          
0B0711 F5          0876*       push af
0B0712             0877*   
0B0712             0878*   ; print each register
0B0712             0879*   
0B0712 21 4C 07 0B 0880*       ld hl,str_udeuhl
0B0716 CD 73 02 0B 0881*       call printString
0B071A 2A 5E 07 0B 0882*       ld hl,(ude)
0B071E CD 93 02 0B 0883*       call printHex24
0B0722 3E 2E       0884*   	ld a,'.'	; print a dot to separate the values
0B0724 5B D7       0885*   	rst.lil 10h
0B0726 2A 58 07 0B 0886*       ld hl,(uhl)
0B072A CD 93 02 0B 0887*       call printHex24
0B072E CD 88 02 0B 0888*       call printNewLine
0B0732             0889*   
0B0732             0890*   ; restore everything
0B0732 2A 58 07 0B 0891*       ld hl, (uhl)
0B0736 ED 4B 5B 07 0892*       ld bc, (ubc)
       0B          
0B073B ED 5B 5E 07 0893*       ld de, (ude)
       0B          
0B0740 DD 2A 61 07 0894*       ld ix, (uix)
       0B          
0B0745 FD 2A 64 07 0895*       ld iy, (uiy)
       0B          
0B074A F1          0896*       pop af
0B074B             0897*   ; all done
0B074B C9          0898*       ret
0B074C             0899*   
0B074C 75 64 65 2E 0900*   str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0755             0901*   
0B0755             0902*   ; global scratch memory for registers
0B0755 00 00 00    0903*   uaf: dl 0
0B0758 00 00 00    0904*   uhl: dl 0
0B075B 00 00 00    0905*   ubc: dl 0
0B075E 00 00 00    0906*   ude: dl 0
0B0761 00 00 00    0907*   uix: dl 0
0B0764 00 00 00    0908*   uiy: dl 0
0B0767 00 00 00    0909*   usp: dl 0
0B076A 00 00 00    0910*   upc: dl 0
0B076D             0911*   
0B076D             0912*   ; inputs: whatever is in the flags register
0B076D             0913*   ; outputs: binary representation of flags
0B076D             0914*   ;          with a header so we know which is what
0B076D             0915*   ; destroys: nothing
0B076D             0916*   ; preserves: everything
0B076D             0917*   dumpFlags:
0B076D             0918*   ; first we curse zilog for not giving direct access to flags
0B076D F5          0919*       push af ; this is so we can send it back unharmed
0B076E F5          0920*       push af ; this is so we can pop it to hl
0B076F             0921*   ; store everything in scratch
0B076F 22 58 07 0B 0922*       ld (uhl),hl
0B0773 ED 43 5B 07 0923*       ld (ubc),bc
       0B          
0B0778 ED 53 5E 07 0924*       ld (ude),de
       0B          
0B077D DD 22 61 07 0925*       ld (uix),ix
       0B          
0B0782 FD 22 64 07 0926*       ld (uiy),iy
       0B          
0B0787             0927*   ; next we print the header
0B0787 21 B3 07 0B 0928*       ld hl,@header
0B078B CD 73 02 0B 0929*       call printString
0B078F E1          0930*       pop hl ; flags are now in l
0B0790 7D          0931*       ld a,l ; flags are now in a
0B0791 CD CA 04 0B 0932*       call printBin8
0B0795 CD 88 02 0B 0933*   	call printNewLine
0B0799             0934*   ; restore everything
0B0799 2A 58 07 0B 0935*       ld hl, (uhl)
0B079D ED 4B 5B 07 0936*       ld bc, (ubc)
       0B          
0B07A2 ED 5B 5E 07 0937*       ld de, (ude)
       0B          
0B07A7 DD 2A 61 07 0938*       ld ix, (uix)
       0B          
0B07AC FD 2A 64 07 0939*       ld iy, (uiy)
       0B          
0B07B1 F1          0940*       pop af ; send her home the way she came
0B07B2 C9          0941*       ret
0B07B3             0942*   ; Bit 7 (S): Sign flag
0B07B3             0943*   ; Bit 6 (Z): Zero flag
0B07B3             0944*   ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B07B3             0945*   ; Bit 4 (H): Half Carry flag
0B07B3             0946*   ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B07B3             0947*   ; Bit 2 (PV): Parity/Overflow flag
0B07B3             0948*   ; Bit 1 (N): Subtract flag
0B07B3             0949*   ; Bit 0 (C): Carry flag
0B07B3 53 5A 78 48 0950*   @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B07BE             0951*   
0B07BE             0952*   ; set all the bits in the flag register
0B07BE             0953*   ; more of an academic exercise than anything useful
0B07BE             0954*   ; inputs; none
0B07BE             0955*   ; outputs; a=0,f=255
0B07BE             0956*   ; destroys: flags, hl
0B07BE             0957*   ; preserves: a, because why not
0B07BE             0958*   setAllFlags:
0B07BE 21 FF 00 00 0959*       ld hl,255
0B07C2 67          0960*       ld h,a ; four cycles to preserve a is cheap
0B07C3 E5          0961*       push hl
0B07C4 F1          0962*       pop af
0B07C5 C9          0963*       ret
0B07C6             0964*   
0B07C6             0965*   ; reset all the bits in the flag register
0B07C6             0966*   ; unlike its inverse counterpart, this may actually be useful
0B07C6             0967*   ; inputs; none
0B07C6             0968*   ; outputs; a=0,f=0
0B07C6             0969*   ; destroys: flags, hl
0B07C6             0970*   ; preserves: a, because why not
0B07C6             0971*   resetAllFlags:
0B07C6 21 00 00 00 0972*       ld hl,0
0B07CA 67          0973*       ld h,a ; four cycles to preserve a is cheap
0B07CB E5          0974*       push hl
0B07CC F1          0975*       pop af
0B07CD C9          0976*       ret
0B07CE             0977*   
0B07CE             0978*   ; wait until user presses a key
0B07CE             0979*   ; inputs: none
0B07CE             0980*   ; outputs: none
0B07CE             0981*   ; destroys: af,ix
0B07CE             0982*   waitKeypress:
0B07CE             0983*       MOSCALL mos_sysvars
0B07CE 3E 08       0001*M  			LD	A, function
0B07D0 5B CF       0002*M  			RST.L	08h
0B07D2 AF          0984*       xor a ; zero out any prior keypresses
0B07D3 DD 77 05    0985*       ld (ix+sysvar_keyascii),a
0B07D6             0986*   @loop:
0B07D6 DD 7E 05    0987*       ld a,(ix+sysvar_keyascii)
0B07D9 A7          0988*       and a
0B07DA C0          0989*       ret nz
0B07DB 18 F9       0990*       jr @loop
0B07DD             0991*   
0B07DD             0992*   
0B07DD             0993*   ; print bytes from an address to the screen in hexidecimal format
0B07DD             0994*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07DD             0995*   ; outputs: values of each byte printed to screen separated by spaces
0B07DD             0996*   ; destroys: nothing
0B07DD             0997*   dumpMemoryHex:
0B07DD             0998*   ; save registers to the stack
0B07DD C5          0999*       push bc
0B07DE E5          1000*       push hl
0B07DF F5          1001*       push af
0B07E0             1002*   
0B07E0             1003*   ; print the address and separator
0B07E0 CD 93 02 0B 1004*       call printHex24
0B07E4 3E 3A       1005*       ld a,':'
0B07E6 5B D7       1006*       rst.lil 10h
0B07E8 3E 20       1007*       ld a,' '
0B07EA 5B D7       1008*       rst.lil 10h
0B07EC             1009*   
0B07EC             1010*   ; set b to be our loop counter
0B07EC F1          1011*       pop af
0B07ED 47          1012*       ld b,a
0B07EE E1          1013*       pop hl
0B07EF E5          1014*       push hl
0B07F0 F5          1015*       push af
0B07F1             1016*   @loop:
0B07F1             1017*   ; print the byte
0B07F1 7E          1018*       ld a,(hl)
0B07F2 CD A1 02 0B 1019*       call printHex8
0B07F6             1020*   ; print a space
0B07F6 3E 20       1021*       ld a,' '
0B07F8 5B D7       1022*       rst.lil 10h
0B07FA 23          1023*       inc hl
0B07FB 10 F4       1024*       djnz @loop
0B07FD CD 88 02 0B 1025*       call printNewLine
0B0801             1026*   
0B0801             1027*   ; restore everything
0B0801 F1          1028*       pop af
0B0802 E1          1029*       pop hl
0B0803 C1          1030*       pop bc
0B0804             1031*   
0B0804             1032*   ; all done
0B0804 C9          1033*       ret
0B0805             1034*   
0B0805             1035*   
0B0805             1036*   ; print bytes from an address to the screen in binary format
0B0805             1037*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0805             1038*   ; outputs: values of each byte printed to screen separated by spaces
0B0805             1039*   ; destroys: nothing
0B0805             1040*   dumpMemoryBin:
0B0805             1041*   ; save all registers to the stack
0B0805 F5          1042*       push af
0B0806 C5          1043*       push bc
0B0807 D5          1044*       push de
0B0808 E5          1045*       push hl
0B0809 DD E5       1046*       push ix
0B080B FD E5       1047*       push iy
0B080D             1048*   
0B080D             1049*   ; set b to be our loop counter
0B080D 47          1050*       ld b,a
0B080E             1051*   @loop:
0B080E             1052*   ; print the byte
0B080E 7E          1053*       ld a,(hl)
0B080F E5          1054*       push hl
0B0810 C5          1055*       push bc
0B0811 CD CA 04 0B 1056*       call printBin8
0B0815 C1          1057*       pop bc
0B0816             1058*   ; print a space
0B0816 3E 20       1059*       ld a,' '
0B0818 5B D7       1060*       rst.lil 10h
0B081A E1          1061*       pop hl
0B081B 23          1062*       inc hl
0B081C 10 F0       1063*       djnz @loop
0B081E CD 88 02 0B 1064*       call printNewLine
0B0822             1065*   
0B0822             1066*   ; restore everything
0B0822 FD E1       1067*       pop iy
0B0824 DD E1       1068*       pop ix
0B0826 E1          1069*       pop hl
0B0827 D1          1070*       pop de
0B0828 C1          1071*       pop bc
0B0829 F1          1072*       pop af
0B082A             1073*   ; all done
0B082A C9          1074*       ret
0B082B             1075*   
0B082B             1076*   ; print bytes from an address to the screen in binary format
0B082B             1077*   ; with the bits of each byte in reverse order (lsb first)
0B082B             1078*   ; inputs: hl = address of first byte to print, a = number of bytes to print
0B082B             1079*   ; outputs: values of each byte printed to screen separated by spaces
0B082B             1080*   ; destroys: nothing
0B082B             1081*   dumpMemoryBinRev:
0B082B             1082*   ; save all registers to the stack
0B082B F5          1083*       push af
0B082C C5          1084*       push bc
0B082D D5          1085*       push de
0B082E E5          1086*       push hl
0B082F DD E5       1087*       push ix
0B0831 FD E5       1088*       push iy
0B0833             1089*   
0B0833             1090*   ; set b to be our loop counter
0B0833 47          1091*       ld b,a
0B0834             1092*   @loop:
0B0834             1093*   ; print the byte
0B0834 7E          1094*       ld a,(hl)
0B0835 E5          1095*       push hl
0B0836 C5          1096*       push bc
0B0837 CD EF 04 0B 1097*       call printBin8Rev
0B083B C1          1098*       pop bc
0B083C             1099*   ; print a space
0B083C 3E 20       1100*       ld a,' '
0B083E 5B D7       1101*       rst.lil 10h
0B0840 E1          1102*       pop hl
0B0841 23          1103*       inc hl
0B0842 10 F0       1104*       djnz @loop
0B0844 CD 88 02 0B 1105*       call printNewLine
0B0848             1106*   
0B0848             1107*   ; restore everything
0B0848 FD E1       1108*       pop iy
0B084A DD E1       1109*       pop ix
0B084C E1          1110*       pop hl
0B084D D1          1111*       pop de
0B084E C1          1112*       pop bc
0B084F F1          1113*       pop af
0B0850             1114*   ; all done
0B0850 C9          1115*       ret
0B0851             0020        include "maths.inc"
0B0851             0001*   ; absolute value of hlu
0B0851             0002*   ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B0851             0003*   ;         s1,z0,pv0,n1,c0 if hlu was negative
0B0851             0004*   ;         s0,z1,pv0,n1,c0 if hlu was zero
0B0851             0005*   ;         s0,z0,pv0,n1,c0 if hlu was positive
0B0851             0006*   ; destroys: a
0B0851             0007*   hlu_abs:
0B0851 19          0008*       add hl,de
0B0852 B7          0009*       or a
0B0853 ED 52       0010*       sbc hl,de
0B0855 FA 5A 08 0B 0011*       jp m,@is_neg
0B0859 C9          0012*       ret         ; hlu is positive or zero so we're done
0B085A             0013*   @is_neg:
0B085A F5          0014*       push af     ; otherwise, save current flags for return
0B085B CD 61 08 0B 0015*       call neg_hlu ; negate hlu
0B085F F1          0016*       pop af      ; get back flags
0B0860 C9          0017*       ret
0B0861             0018*   
0B0861             0019*   ; flip the sign of hlu
0B0861             0020*   ; inputs: hlu
0B0861             0021*   ; returns: 0-hlu, flags set appropriately for the result:
0B0861             0022*   ;         s1,z0,pv0,n1,c1 if result is negative
0B0861             0023*   ;         s0,z1,pv0,n1,c0 if result is zero
0B0861             0024*   ;         s0,z0,pv0,n1,c1 if result is positive
0B0861             0025*   ; destroys a
0B0861             0026*   neg_hlu:
0B0861 D5          0027*       push de     ; save de
0B0862 EB          0028*       ex de,hl    ; put hl into de
0B0863 21 00 00 00 0029*       ld hl,0     ; clear hl
0B0867 AF          0030*       xor a       ; clear carry
0B0868 ED 52       0031*       sbc hl,de   ; 0-hlu = -hlu
0B086A D1          0032*       pop de      ; get de back
0B086B C9          0033*       ret         ; easy peasy
0B086C             0034*   
0B086C             0035*   ;------------------------------------------------------------------------
0B086C             0036*   ; divide hlu by 2, inspired by above
0B086C             0037*   ;------------------------------------------------------------------------
0B086C             0038*   hlu_div2:
0B086C 22 FA 09 0B 0039*   	ld		(bitbuf1),hl
0B0870 21 FC 09 0B 0040*   	ld		hl,bitbuf1+2
0B0874 CB 1E       0041*   	rr		(hl)
0B0876 2B          0042*   	dec		hl
0B0877 CB 1E       0043*   	rr		(hl)
0B0879 2B          0044*   	dec		hl
0B087A CB 1E       0045*   	rr		(hl)
0B087C 23          0046*   	inc		hl
0B087D 23          0047*   	inc		hl
0B087E 2A FA 09 0B 0048*       ld hl,(bitbuf1)
0B0882 C9          0049*       ret
0B0883             0050*   
0B0883             0051*   ; this is my little hack to divide by 16
0B0883             0052*   hlu_div16:
0B0883 AF          0053*       xor a
0B0884 29          0054*       add hl,hl
0B0885 17          0055*       rla
0B0886 29          0056*       add hl,hl
0B0887 17          0057*       rla
0B0888 29          0058*       add hl,hl
0B0889 17          0059*       rla
0B088A 29          0060*       add hl,hl
0B088B 17          0061*       rla
0B088C 22 99 08 0B 0062*       ld (@scratch),hl
0B0890 32 9C 08 0B 0063*       ld (@scratch+3),a
0B0894 2A 9A 08 0B 0064*       ld hl,(@scratch+1)
0B0898 C9          0065*       ret
0B0899             0066*   @scratch: ds 4
0B089D             0067*   
0B089D             0068*   ; hlu signed division by 256
0B089D             0069*   ; returns: hlu / 256
0B089D             0070*   ; destroys: af
0B089D             0071*   hlu_sdiv256:
0B089D AF          0072*       xor a ; assume hl is positive
0B089E 22 B4 08 0B 0073*       ld (@buffer),hl
0B08A2             0074*       sign_hlu
0B08A2 19          0001*M          add hl,de
0B08A3 B7          0002*M          or a
0B08A4 ED 52       0003*M          sbc hl,de
0B08A6 F2 AB 08 0B 0075*       jp p,@hl_pos
0B08AA 3D          0076*       dec a
0B08AB             0077*   @hl_pos:
0B08AB 32 B7 08 0B 0078*       ld (@buffer+3),a
0B08AF 2A B5 08 0B 0079*       ld hl,(@buffer+1)
0B08B3 C9          0080*       ret
0B08B4             0081*   @buffer: ds 4
0B08B8             0082*   
0B08B8             0083*   ; hlu 1 byte right shift, unsigned
0B08B8             0084*   ; returns: hlu / 256, fractional portion in a
0B08B8             0085*   ; destroys: af
0B08B8             0086*   hlu_udiv256:
0B08B8 AF          0087*   	xor a
0B08B9 32 CA 08 0B 0088*   	ld (@buffer+3),a
0B08BD 7D          0089*   	ld a,l ; save the fractional portion
0B08BE 22 C7 08 0B 0090*   	ld (@buffer),hl
0B08C2 2A C8 08 0B 0091*   	ld hl,(@buffer+1)
0B08C6 C9          0092*   	ret
0B08C7             0093*   @buffer: ds 4
0B08CB             0094*   
0B08CB             0095*       MACRO hlu_mul256
0B08CB             0096*           add hl,hl ; * 2
0B08CB             0097*           add hl,hl ; * 4
0B08CB             0098*           add hl,hl ; * 8
0B08CB             0099*           add hl,hl ; * 16
0B08CB             0100*           add hl,hl ; * 32
0B08CB             0101*           add hl,hl ; * 64
0B08CB             0102*           add hl,hl ; * 128
0B08CB             0103*           add hl,hl ; * 256
0B08CB             0104*       ENDMACRO
0B08CB             0105*   
0B08CB             0106*   ; compute the modulo of hlu by deu
0B08CB             0107*   ; outputs: hlu = hlu % deu
0B08CB             0108*   ; destroys: f, hl
0B08CB             0109*   hlu_mod:
0B08CB B7          0110*   	or a ; clear carry
0B08CC             0111*   @loop:
0B08CC ED 52       0112*       sbc hl,de
0B08CE DA D6 08 0B 0113*       jp c, @end
0B08D2 C3 CC 08 0B 0114*       jp @loop
0B08D6             0115*   @end:
0B08D6 19          0116*       add hl,de
0B08D7 C9          0117*   	ret
0B08D8             0118*   
0B08D8             0119*   
0B08D8 00 00 00 00 0120*   add_bcd_arg1: db #00,#00,#00,#00
0B08DC 00 00 00 00 0121*   add_bcd_arg2: db #00,#00,#00,#00
0B08E0             0122*   
0B08E0             0123*   ; set bcd values in a scratch memory address from registers bcde
0B08E0             0124*   ; input: hl; scratch address,bcde; 8-place bcd number
0B08E0             0125*   ; destroys ; hl
0B08E0             0126*   set_bcd:
0B08E0 73          0127*       ld (hl),e
0B08E1 23          0128*       inc hl
0B08E2 72          0129*       ld (hl),d
0B08E3 23          0130*       inc hl
0B08E4 71          0131*       ld (hl),c
0B08E5 23          0132*       inc hl
0B08E6 70          0133*       ld (hl),b
0B08E7 C9          0134*       ret
0B08E8             0135*   
0B08E8             0136*   ; load bcd values from a scratch memory address to bcde
0B08E8             0137*   ; input: hl; scratch address
0B08E8             0138*   ; output: bcde; 8-place bcd number
0B08E8             0139*   ; destroys: hl
0B08E8             0140*   get_bcd:
0B08E8 5E          0141*       ld e,(hl)
0B08E9 23          0142*       inc hl
0B08EA 56          0143*       ld d,(hl)
0B08EB 23          0144*       inc hl
0B08EC 4E          0145*       ld c,(hl)
0B08ED 23          0146*       inc hl
0B08EE 46          0147*       ld b,(hl)
0B08EF C9          0148*       ret
0B08F0             0149*   
0B08F0             0150*   ; BCD addition
0B08F0             0151*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08F0             0152*   ;       a is the number of bytes holding each number (number of places/2)
0B08F0             0153*   ; outputs: (hl) + (de) --> (hl)
0B08F0             0154*   ; destroys: a,b,de,hl
0B08F0             0155*   add_bcd:
0B08F0 47          0156*       ld b,a ; loop counter
0B08F1 AF          0157*       xor a ; reset a, clear carry flag
0B08F2             0158*   adcec:
0B08F2 1A          0159*       ld a,(de) ; addend to acc
0B08F3 8E          0160*       adc a,(hl) ; add (hl) to acc
0B08F4 27          0161*       daa ; adjust result to bcd
0B08F5 77          0162*       ld (hl),a ; store result
0B08F6 23          0163*       inc hl ; advance memory pointers
0B08F7 13          0164*       inc de
0B08F8 10 F8       0165*       djnz adcec ; loop until b == 0
0B08FA C9          0166*       ret
0B08FB             0167*   
0B08FB             0168*   ; BCD subtraction
0B08FB             0169*   ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08FB             0170*   ;       a is the number of bytes holding each number (number of places/2)
0B08FB             0171*   ; outputs: (hl) - (de) --> (hl)
0B08FB             0172*   ; destroys: a,b,de,hl
0B08FB             0173*   sub_bcd:
0B08FB 47          0174*       ld b,a ; loop counter
0B08FC AF          0175*       xor a ; reset a,clear carry flag
0B08FD             0176*   subdec:
0B08FD 1A          0177*       ld a,(de) ; subtrahend to acc
0B08FE 9E          0178*       sbc a,(hl) ; subtract (hl) from acc
0B08FF 27          0179*       daa ; adjust result to bcd
0B0900 77          0180*       ld (hl),a ; store result
0B0901 23          0181*       inc hl ; advance memory pointers
0B0902 13          0182*       inc de
0B0903 10 F8       0183*       djnz subdec ; loop until b == 0
0B0905 C9          0184*       ret
0B0906             0185*   
0B0906             0186*   ; http://www.z80.info/pseudo-random.txt
0B0906             0187*   rand_8:
0B0906 C5          0188*       push bc
0B0907 3A 1A 09 0B 0189*       ld a,(r_seed)
0B090B 4F          0190*       ld c,a
0B090C             0191*   
0B090C 0F          0192*       rrca ; multiply by 32
0B090D 0F          0193*       rrca
0B090E 0F          0194*       rrca
0B090F EE 1F       0195*       xor 0x1f
0B0911             0196*   
0B0911 81          0197*       add a,c
0B0912 DE FF       0198*       sbc a,255 ; carry
0B0914             0199*   
0B0914 32 1A 09 0B 0200*       ld (r_seed),a
0B0918 C1          0201*       pop bc
0B0919 C9          0202*       ret
0B091A 50          0203*   r_seed: defb $50
0B091B             0204*   
0B091B             0205*   ; linear interpolation between two 24-bit numbers
0B091B             0206*   ; may be signed or unsigned, and treated as integers or fractional
0B091B             0207*   ; inputs: bc = start value, de = end value, a = interpolation factor
0B091B             0208*   ; outputs: hl = interpolated value, a = multiply overflow to 32 bits (0 if no overflow)
0B091B             0209*   ; destroys: af, hl, de
0B091B             0210*   interpolate24:
0B091B C5          0211*       push bc ; save start value
0B091C EB          0212*       ex de,hl ; end value to hl
0B091D B7          0213*       or a ; clear carry
0B091E ED 42       0214*       sbc hl,bc ; hl = end - start
0B0920 CD 2F 0B 0B 0215*       call umul24x8 ; hl = (end - start) * interpolation factor
0B0924 C1          0216*       pop bc ; get back start value (was hl)
0B0925 09          0217*       add hl,bc ; hl = start + (end - start) * interpolation factor
0B0926 C9          0218*       ret
0B0927             0021    	INCLUDE	"arith24.inc"
0B0927             0001*   ;------------------------------------------------------------------------
0B0927             0002*   ;  arith24.asm
0B0927             0003*   ;  24-bit ez80 arithmetic routines
0B0927             0004*   ;  Copyright (c) Shawn Sijnstra 2024
0B0927             0005*   ;  MIT license
0B0927             0006*   ;
0B0927             0007*   ;  This library was created as a tool to help make ez80
0B0927             0008*   ;  24-bit native assembly routines for simple mathematical problems
0B0927             0009*   ;  more widely available.
0B0927             0010*   ;
0B0927             0011*   ;------------------------------------------------------------------------
0B0927             0012*   
0B0927             0013*   ;------------------------------------------------------------------------
0B0927             0014*   ; umul24:	HL = HL*DE (unsigned)
0B0927             0015*   ; Preserves AF, BC, DE
0B0927             0016*   ; Uses a fast multiply routine.
0B0927             0017*   ;------------------------------------------------------------------------
0B0927             0018*   umul24:
0B0927 D5          0019*   	push	DE
0B0928 C5          0020*   	push	BC
0B0929 F5          0021*   	push	AF
0B092A E5          0022*   	push	HL
0B092B C1          0023*   	pop		BC
0B092C 3E 18       0024*       ld	 	a, 24 ; No. of bits to process
0B092E 21 00 00 00 0025*       ld	 	hl, 0 ; Result
0B0932             0026*   umul24_lp:
0B0932 29          0027*   	add	hl,hl
0B0933 EB          0028*   	ex	de,hl
0B0934 29          0029*   	add	hl,hl
0B0935 EB          0030*   	ex	de,hl
0B0936 30 01       0031*   	jr	nc,umul24_nc
0B0938 09          0032*   	add	hl,bc
0B0939             0033*   umul24_nc:
0B0939 3D          0034*   	dec	a
0B093A 20 F6       0035*   	jr	nz,umul24_lp
0B093C F1          0036*   	pop	af
0B093D C1          0037*   	pop	bc
0B093E D1          0038*   	pop	de
0B093F C9          0039*   	ret
0B0940             0040*   
0B0940             0041*   
0B0940             0042*   ;------------------------------------------------------------------------
0B0940             0043*   ; udiv24
0B0940             0044*   ; Unsigned 24-bit division
0B0940             0045*   ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0940             0046*   ;
0B0940             0047*   ; Uses AF BC DE HL
0B0940             0048*   ; Uses Restoring Division algorithm
0B0940             0049*   ;------------------------------------------------------------------------
0B0940             0050*   
0B0940             0051*   udiv24:
0B0940 E5          0052*   	push	hl
0B0941 C1          0053*   	pop		bc	;move dividend to BCU
0B0942 21 00 00 00 0054*   	ld		hl,0	;result
0B0946 A7          0055*   	and		a
0B0947 ED 52       0056*   	sbc		hl,de	;test for div by 0
0B0949 C8          0057*   	ret		z		;it's zero, carry flag is clear
0B094A 19          0058*   	add		hl,de	;HL is 0 again
0B094B 3E 18       0059*   	ld		a,24	;number of loops through.
0B094D             0060*   udiv1:
0B094D C5          0061*   	push	bc	;complicated way of doing this because of lack of access to top bits
0B094E E3          0062*   	ex		(sp),hl
0B094F 37          0063*   	scf
0B0950 ED 6A       0064*   	adc	hl,hl
0B0952 E3          0065*   	ex	(sp),hl
0B0953 C1          0066*   	pop	bc		;we now have bc = (bc * 2) + 1
0B0954             0067*   
0B0954 ED 6A       0068*   	adc	hl,hl
0B0956 A7          0069*   	and	a		;is this the bug
0B0957 ED 52       0070*   	sbc	hl,de
0B0959 30 02       0071*   	jr	nc,udiv2
0B095B 19          0072*   	add	hl,de
0B095C             0073*   ;	dec	c
0B095C 0B          0074*   	dec	bc
0B095D             0075*   udiv2:
0B095D 3D          0076*   	dec	a
0B095E 20 ED       0077*   	jr	nz,udiv1
0B0960 37          0078*   	scf		;flag used for div0 error
0B0961 C5          0079*   	push	bc
0B0962 D1          0080*   	pop		de	;remainder
0B0963 C9          0081*   	ret
0B0964             0082*   
0B0964             0083*   
0B0964             0084*   
0B0964             0085*   ;------------------------------------------------------------------------
0B0964             0086*   ; neg24
0B0964             0087*   ; Returns: HLU = 0-HLU
0B0964             0088*   ; preserves all other registers
0B0964             0089*   ;------------------------------------------------------------------------
0B0964             0090*   neg24:
0B0964 D5          0091*   	push	de
0B0965 EB          0092*   	ex		de,hl
0B0966 21 00 00 00 0093*   	ld		hl,0
0B096A B7          0094*   	or		a
0B096B ED 52       0095*   	sbc		hl,de
0B096D D1          0096*   	pop		de
0B096E C9          0097*   	ret
0B096F             0098*   
0B096F             0099*   ;------------------------------------------------------------------------
0B096F             0100*   ; or_hlu_deu: 24 bit bitwise OR
0B096F             0101*   ; Returns: hlu = hlu OR deu
0B096F             0102*   ; preserves all other registers
0B096F             0103*   ;------------------------------------------------------------------------
0B096F             0104*   or_hlu_deu:
0B096F 22 FA 09 0B 0105*   	ld	(bitbuf1),hl
0B0973 ED 53 FD 09 0106*   	ld	(bitbuf2),de
       0B          
0B0978 D5          0107*   	push	de	;preserve DEU
0B0979 C5          0108*   	push	bc	;preserve BCU
0B097A 06 03       0109*   	ld		b,3
0B097C 21 FA 09 0B 0110*   	ld	hl,bitbuf1
0B0980 11 FA 09 0B 0111*   	ld	de,bitbuf1
0B0984             0112*   orloop_24:
0B0984 1A          0113*   	ld	a,(de)
0B0985 B6          0114*   	or	(hl)
0B0986 12          0115*   	ld	(de),a
0B0987 13          0116*   	inc	de
0B0988 23          0117*   	inc	hl
0B0989 10 F9       0118*   	djnz	orloop_24
0B098B 2A FD 09 0B 0119*   	ld	hl,(bitbuf2)
0B098F C1          0120*   	pop		bc	;restore BC
0B0990 D1          0121*   	pop		de	;restore DE
0B0991             0122*   
0B0991             0123*   ;------------------------------------------------------------------------
0B0991             0124*   ; and_hlu_deu: 24 bit bitwise AND
0B0991             0125*   ; Returns: hlu = hlu AND deu
0B0991             0126*   ; preserves all other registers
0B0991             0127*   ;------------------------------------------------------------------------
0B0991             0128*   and_hlu_deu:
0B0991 22 FA 09 0B 0129*   	ld	(bitbuf1),hl
0B0995 ED 53 FD 09 0130*   	ld	(bitbuf2),de
       0B          
0B099A D5          0131*   	push	de	;preserve DEU
0B099B C5          0132*   	push	bc	;preserve BCU
0B099C 06 03       0133*   	ld		b,3
0B099E 21 FA 09 0B 0134*   	ld	hl,bitbuf1
0B09A2 11 FA 09 0B 0135*   	ld	de,bitbuf1
0B09A6             0136*   andloop_24:
0B09A6 1A          0137*   	ld	a,(de)
0B09A7 A6          0138*   	and	(hl)
0B09A8 12          0139*   	ld	(de),a
0B09A9 13          0140*   	inc	de
0B09AA 23          0141*   	inc	hl
0B09AB 10 F9       0142*   	djnz	andloop_24
0B09AD 2A FD 09 0B 0143*   	ld	hl,(bitbuf2)
0B09B1 C1          0144*   	pop		bc	;restore BC
0B09B2 D1          0145*   	pop		de	;restore DE
0B09B3             0146*   
0B09B3             0147*   ;------------------------------------------------------------------------
0B09B3             0148*   ; xor_hlu_deu: 24 bit bitwise XOR
0B09B3             0149*   ; Returns: hlu = hlu XOR deu
0B09B3             0150*   ; preserves all other registers
0B09B3             0151*   ;------------------------------------------------------------------------
0B09B3             0152*   xor_hlu_deu:
0B09B3 22 FA 09 0B 0153*   	ld	(bitbuf1),hl
0B09B7 ED 53 FD 09 0154*   	ld	(bitbuf2),de
       0B          
0B09BC D5          0155*   	push	de	;preserve DEU
0B09BD C5          0156*   	push	bc	;preserve BCU
0B09BE 06 03       0157*   	ld		b,3
0B09C0 21 FA 09 0B 0158*   	ld	hl,bitbuf1
0B09C4 11 FA 09 0B 0159*   	ld	de,bitbuf1
0B09C8             0160*   xorloop_24:
0B09C8 1A          0161*   	ld	a,(de)
0B09C9 AE          0162*   	xor	(hl)
0B09CA 12          0163*   	ld	(de),a
0B09CB 13          0164*   	inc	de
0B09CC 23          0165*   	inc	hl
0B09CD 10 F9       0166*   	djnz	xorloop_24
0B09CF 2A FD 09 0B 0167*   	ld	hl,(bitbuf2)
0B09D3 C1          0168*   	pop		bc	;restore BC
0B09D4 D1          0169*   	pop		de	;restore DE
0B09D5             0170*   
0B09D5             0171*   ;------------------------------------------------------------------------
0B09D5             0172*   ; shl_hlu: 24 bit shift left hlu by deu positions
0B09D5             0173*   ; Returns: hlu = hlu << deu
0B09D5             0174*   ;		   de = 0
0B09D5             0175*   ; NOTE: only considers deu up to 16 bits.
0B09D5             0176*   ; preserves all other registers
0B09D5             0177*   ;------------------------------------------------------------------------
0B09D5             0178*   shl_hlu:
0B09D5 7A          0179*   	ld		a,d		;up to 16 bit.
0B09D6 B3          0180*   	or		e
0B09D7 C8          0181*   	ret		z		;we're done
0B09D8 29          0182*   	add		hl,hl	;shift HLU left
0B09D9 1B          0183*   	dec		de
0B09DA 18 F9       0184*   	jr		shl_hlu
0B09DC             0185*   
0B09DC             0186*   ;------------------------------------------------------------------------
0B09DC             0187*   ; shr_hlu: 24 bit shift right hlu by deu positions
0B09DC             0188*   ; Returns: hlu = hlu >> deu
0B09DC             0189*   ;		   de = 0
0B09DC             0190*   ; NOTE: only considers deu up to 16 bits.
0B09DC             0191*   ; preserves all other registers
0B09DC             0192*   ;------------------------------------------------------------------------
0B09DC             0193*   shr_hlu:
0B09DC 22 FA 09 0B 0194*   	ld		(bitbuf1),hl
0B09E0 21 FC 09 0B 0195*   	ld		hl,bitbuf1+2
0B09E4             0196*   shr_loop:
0B09E4 7A          0197*   	ld		a,d		;up to 16 bit.
0B09E5 B3          0198*   	or		e
0B09E6 28 0D       0199*   	jr		z,shr_done		;we're done
0B09E8             0200*   ;carry is clear from or instruction
0B09E8 CB 1E       0201*   	rr		(hl)
0B09EA 2B          0202*   	dec		hl
0B09EB CB 1E       0203*   	rr		(hl)
0B09ED 2B          0204*   	dec		hl
0B09EE CB 1E       0205*   	rr		(hl)
0B09F0 23          0206*   	inc		hl
0B09F1 23          0207*   	inc		hl
0B09F2 1B          0208*   	dec		de
0B09F3 18 EF       0209*   	jr		shr_loop
0B09F5             0210*   shr_done:
0B09F5 2A FA 09 0B 0211*   	ld		hl,(bitbuf1)	;collect result
0B09F9 C9          0212*   	ret
0B09FA             0213*   
0B09FA             0214*   ;------------------------------------------------------------------------
0B09FA             0215*   ; Scratch area for calculations
0B09FA             0216*   ;------------------------------------------------------------------------
0B09FA 00 00 00    0217*   bitbuf1:	dw24	0	;bit manipulation buffer 1
0B09FD 00 00 00    0218*   bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0A00             0022        include "fixed24.inc"
0B0A00             0001*   arith24uaf: ds 6
0B0A06             0002*   arith24uhl: ds 6
0B0A0C             0003*   arith24ubc: ds 6
0B0A12             0004*   arith24ude: ds 6
0B0A18             0005*   arith24uix: ds 6
0B0A1E             0006*   arith24uiy: ds 6
0B0A24             0007*   arith24usp: ds 6
0B0A2A             0008*   arith24upc: ds 6
0B0A30             0009*   
0B0A30             0010*   ; write hlu to a 54-bit output buffer arithmetically shifted up or down a specified number of bits
0B0A30             0011*   ; uses whole-byte shifts for the initial shift and bit shifts for the remainder
0B0A30             0012*   ; inputs: hlu = 24-bit number to shift
0B0A30             0013*   ;         a = signed number of bits to shift
0B0A30             0014*   ;         ix = output buffer address
0B0A30             0015*   ; outputs: hlu = shifted 24-bit number, ix = modified pointer aligned with value in hlu
0B0A30             0016*   shift_hlu:
0B0A30 C5          0017*       push bc ; preserve
0B0A31 47          0018*       ld b,a            ; store shift value in b for later
0B0A32             0019*   
0B0A32             0020*   ; Initialize DE to zero and clear output buffer
0B0A32 11 00 00 00 0021*       ld de, 0
0B0A36 DD 1F FD    0022*       ld (ix-3), de
0B0A39 DD 1F 03    0023*       ld (ix+3), de
0B0A3C             0024*   
0B0A3C             0025*   ; Get absolute value of a and save its original sign
0B0A3C B7          0026*       or a
0B0A3D F5          0027*       push af ; save sign flag
0B0A3E F2 44 0A 0B 0028*       jp p,@F ; If a is positive do nothing
0B0A42 ED 44       0029*       neg ; If a is negative, negate it
0B0A44             0030*   @@:
0B0A44             0031*   
0B0A44             0032*   ; Write abs(HLU) to the output buffer and save its original sign
0B0A44 CD 51 08 0B 0033*       call hlu_abs
0B0A48 F5          0034*       push af ; save sign of HLU
0B0A49 DD 2F 00    0035*       ld (ix), hl
0B0A4C             0036*   
0B0A4C             0037*   ; Divide bits to shift by 8 to get the whole byte shift and bit remainder
0B0A4C 78          0038*       ld a,b            ; Restore original shift value into 'a'
0B0A4D CB 3F       0039*       srl a             ; a = a / 2 (shift right 1 bit)
0B0A4F CB 3F       0040*       srl a             ; a = a / 4 (shift right another bit)
0B0A51 CB 3F       0041*       srl a             ; a = a / 8 (final shift for division by 8)
0B0A53 4F          0042*       ld c,a            ; c holds the number of whole bytes to shift
0B0A54             0043*   
0B0A54             0044*   ; Calculate remainder of a (original shift) mod 8
0B0A54 E6 07       0045*       and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0B0A56 47          0046*       ld b,a            ; 'b' now holds the number of bits to shift back up
0B0A57 11 00 00 00 0047*       ld de,0           ; Clear deu for computing the offset address later
0B0A5B             0048*   
0B0A5B             0049*       ; call dumpRegistersHex ; DEBUG
0B0A5B             0050*   
0B0A5B             0051*   ; Get back the original sign of the byte shift
0B0A5B F1          0052*       pop af            ; Restore sign flag
0B0A5C F2 6A 0A 0B 0053*       jp p,@F           ; If a was positive, we're done
0B0A60 79          0054*       ld a,c            ; 'a' now holds the number of whole bytes to shift
0B0A61 ED 44       0055*       neg               ; Negate the number of whole bytes to shift
0B0A63 3D          0056*       dec a             ; Subtract 1 because that's just how this works
0B0A64 4F          0057*       ld c,a            ; 'c' now holds the number of whole bytes to shift
0B0A65 1B          0058*       dec de            ; DE = -1 to make the signed addition below work
0B0A66 3E 08       0059*       ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0B0A68 90          0060*       sub b
0B0A69 47          0061*       ld b,a            ; b is the number of bits to shift back up
0B0A6A             0062*   
0B0A6A             0063*       ; call dumpRegistersHex ; DEBUG
0B0A6A             0064*   
0B0A6A             0065*   @@:
0B0A6A             0066*   
0B0A6A             0067*   ; Add the byte offset to the base address of output buffer
0B0A6A 59          0068*       ld e,c            ; DEU and D were properly signed above
0B0A6B DD 19       0069*       add ix,de         ; Add byte-aligned offset (hl = output buffer + l)
0B0A6D             0070*   
0B0A6D             0071*       ; call dumpRegistersHex ; DEBUG
0B0A6D             0072*   
0B0A6D             0073*   ; Read the byte-aligned result into HL and shift in the required number of bits
0B0A6D DD 27 00    0074*       ld hl,(ix)        ; Byte-aligned result
0B0A70             0075*   
0B0A70 CD DF 05 0B 0076*       call dumpRegistersHex ; DEBUG
0B0A74             0077*   
0B0A74             0078*   ; Check whether we're already byte-aligned
0B0A74 AF          0079*       xor a
0B0A75 B0          0080*       or b
0B0A76 28 10       0081*       jr z,@end         ; If no bits to shift, we're done
0B0A78             0082*   
0B0A78             0083*   ; Otherwise shiften zee bitzen
0B0A78 DD 7E FF    0084*       ld a,(ix-1)       ; read one byte below for the bits to shift into HLU
0B0A7B             0085*   @loop:
0B0A7B 07          0086*       rlca              ; One bit to carry
0B0A7C             0087*   
0B0A7C CD 6D 07 0B 0088*       call dumpFlags ; DEBUG
0B0A80             0089*   
0B0A80 ED 6A       0090*       adc hl,hl         ; Shift the carry into the result
0B0A82             0091*   
0B0A82 CD DF 05 0B 0092*       call dumpRegistersHex ; DEBUG
0B0A86             0093*   
0B0A86 10 F3       0094*       djnz @loop        ; Loop until all bits are shifted up
0B0A88             0095*   
0B0A88             0096*   @end:
0B0A88             0097*   
0B0A88 CD DF 05 0B 0098*       call dumpRegistersHex ; DEBUG
0B0A8C             0099*   
0B0A8C             0100*   ; get back HLU's original sign and negate if necessary
0B0A8C F1          0101*       pop af
0B0A8D F2 95 0A 0B 0102*       jp p,@F
0B0A91 CD 61 08 0B 0103*       call neg_hlu
0B0A95             0104*   @@:
0B0A95             0105*   ; return the result
0B0A95 DD 2F 00    0106*       ld (ix),hl        ; Store the shifted result
0B0A98 C1          0107*       pop bc              ; Restore BC
0B0A99 C9          0108*       ret
0B0A9A             0109*   
0B0A9A             0110*   ; operation: UHL * UDE --> UHL
0B0A9A             0111*   ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
0B0A9A             0112*   ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0B0A9A             0113*   ; inputs: hl = 24-bit number, de = 24-bit number,
0B0A9A             0114*   ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0B0A9A             0115*   ; outputs: umulfxout = 48-bit intermediate
0B0A9A             0116*   ; destroys: af, hl, bc, de
0B0A9A             0117*   umulfx:
0B0A9A DD E5       0118*       push ix ; preserve
0B0A9C F5          0119*       push af ; need later
0B0A9D             0120*   
0B0A9D             0121*   ; do the multiplication
0B0A9D CD 5E 0B 0B 0122*       call umul24x24
0B0AA1             0123*       ; DEBUG
0B0AA1 21 F3 0A 0B 0124*       ld hl,umulfxout ; point to output buffer
0B0AA5 3E 06       0125*       ld a,6 ; 6 bytes to print
0B0AA7 CD DD 07 0B 0126*       call dumpMemoryHex ; print the result
0B0AAB             0127*       ; END DEBUG
0B0AAB             0128*   
0B0AAB             0129*   ; shift the result to the required output precision
0B0AAB 78          0130*       ld a,b
0B0AAC 81          0131*       add a,c ; a is left shift from the multiplication
0B0AAD C1          0132*       pop bc ; b is the output precision (was a)
0B0AAE 90          0133*       sub b ; a is the net shift of the output
0B0AAF             0134*   
0B0AAF             0135*   ; Get absolute value of a and save its original sign
0B0AAF B7          0136*       or a
0B0AB0 F5          0137*       push af ; save sign flag
0B0AB1 F2 B7 0A 0B 0138*       jp p,@F ; If a is positive do nothing
0B0AB5 ED 44       0139*       neg ; If a is negative, negate it
0B0AB7             0140*   @@:
0B0AB7             0141*   
0B0AB7             0142*   ; Divide a by 8 to get the whole byte shift and bit remainder
0B0AB7 47          0143*       ld b,a            ; Store 'a' temporarily in 'b' (net shift)
0B0AB8 CB 3F       0144*       srl a             ; a = a / 2 (shift right 1 bit)
0B0ABA CB 3F       0145*       srl a             ; a = a / 4 (shift right another bit)
0B0ABC CB 3F       0146*       srl a             ; a = a / 8 (final shift for division by 8)
0B0ABE 4F          0147*       ld c,a            ; c holds the number of whole bytes to shift
0B0ABF             0148*   
0B0ABF             0149*   ; Calculate remainder of a (original shift) mod 8
0B0ABF 78          0150*       ld a,b            ; Restore original shift value into 'a'
0B0AC0 E6 07       0151*       and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0B0AC2 47          0152*       ld b,a            ; 'b' now holds the number of bits to shift back up
0B0AC3 11 00 00 00 0153*       ld de,0           ; Clear deu for computing the offset address later
0B0AC7             0154*   
0B0AC7             0155*       ; call dumpRegistersHex ; DEBUG
0B0AC7             0156*   
0B0AC7             0157*   ; Get back the original sign of the byte shift
0B0AC7 F1          0158*       pop af            ; Restore sign flag
0B0AC8 F2 D6 0A 0B 0159*       jp p,@F           ; If a was positive, we're done
0B0ACC 79          0160*       ld a,c            ; 'a' now holds the number of whole bytes to shift
0B0ACD ED 44       0161*       neg               ; Negate the number of whole bytes to shift
0B0ACF 3D          0162*       dec a             ; Subtract 1 because that's just how this works
0B0AD0 4F          0163*       ld c,a            ; 'c' now holds the number of whole bytes to shift
0B0AD1 1B          0164*       dec de            ; DE = -1 to make the signed addition below work
0B0AD2 3E 08       0165*       ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0B0AD4 90          0166*       sub b
0B0AD5 47          0167*       ld b,a            ; b is the number of bits to shift back up
0B0AD6             0168*   
0B0AD6             0169*       ; call dumpRegistersHex ; DEBUG
0B0AD6             0170*   
0B0AD6             0171*   @@:
0B0AD6             0172*   
0B0AD6             0173*   ; Add the byte offset to the base address of umulfxout
0B0AD6 59          0174*       ld e,c            ; DEU and D were properly signed above
0B0AD7 DD 21 F3 0A 0175*       ld ix,umulfxout   ; Load base address of the output buffer
       0B          
0B0ADC DD 19       0176*       add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
0B0ADE             0177*   
0B0ADE             0178*       ; call dumpRegistersHex ; DEBUG
0B0ADE             0179*   
0B0ADE             0180*   ; Read the byte-aligned result into HL and shift in the required number of bits
0B0ADE DD 27 00    0181*       ld hl,(ix)        ; Byte-aligned result
0B0AE1 DD 7E FF    0182*       ld a,(ix-1)       ; One byte below
0B0AE4             0183*   
0B0AE4             0184*   ; Check whether we're already byte-aligned
0B0AE4 AF          0185*       xor a
0B0AE5 B0          0186*       or b
0B0AE6 28 05       0187*       jr z,@end         ; If no bits to shift, we're done
0B0AE8             0188*   
0B0AE8             0189*   ; Otherwise shiften zee bitzen
0B0AE8             0190*   @loop:
0B0AE8             0191*   
0B0AE8             0192*       ; call dumpRegistersHex ; DEBUG
0B0AE8             0193*   
0B0AE8 07          0194*       rlca              ; One bit to carry
0B0AE9 ED 6A       0195*       adc hl,hl         ; Shift the carry into the result
0B0AEB             0196*   
0B0AEB 10 FB       0197*       djnz @loop        ; Loop until all bits are shifted up
0B0AED             0198*   
0B0AED             0199*   @end:
0B0AED             0200*   ; return the result
0B0AED DD E1       0201*       pop ix ; restore
0B0AEF C9          0202*       ret
0B0AF0             0203*   
0B0AF0 00 00 00    0204*       dl 0 ; padding
0B0AF3 00 00 00 00 0205*   umulfxout: blkb 6,0
       00 00       
0B0AF9 00 00 00    0206*       dl 0 ; padding
0B0AFC             0207*   
0B0AFC             0208*   ; operation: UHL * UDE --> UHL
0B0AFC             0209*   ; multiply signed 24-bit numbers and return a 48-bit intermediate
0B0AFC             0210*   ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0B0AFC             0211*   ; inputs: hl = 24-bit number, de = 24-bit number,
0B0AFC             0212*   ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0B0AFC             0213*   ; outputs: umulfxout = 48-bit intermediate
0B0AFC             0214*   ; destroys: af, hl, bc, de
0B0AFC             0215*   smulfx:
0B0AFC             0216*   ; make everything positive and store sign flags
0B0AFC CD 51 08 0B 0217*   	call hlu_abs
0B0B00 F5          0218*   	push af
0B0B01 EB          0219*   	ex de,hl
0B0B02 CD 51 08 0B 0220*   	call hlu_abs
0B0B06 EB          0221*   	ex de,hl
0B0B07 F5          0222*   	push af
0B0B08             0223*   ; do the division
0B0B08 CD 9A 0A 0B 0224*       call umulfx ; hl = product
0B0B0C             0225*   ; adjust sign of result
0B0B0C F1          0226*   	pop af ; sign de
0B0B0D FA 18 0B 0B 0227*   	jp m,@de_neg
0B0B11 F1          0228*   	pop af ; sign hl
0B0B12 F0          0229*   	ret p ; both positive, nothing to do
0B0B13             0230*   @hl_neg:
0B0B13 CD 61 08 0B 0231*       call neg_hlu ; de pos, hl neg, result is negative
0B0B17 C9          0232*       ret
0B0B18             0233*   @de_neg:
0B0B18 F1          0234*   	pop af
0B0B19 F8          0235*   	ret m ; both negative, nothing to do
0B0B1A CD 61 08 0B 0236*   	call neg_hlu ; result is negative
0B0B1E C9          0237*   	ret
0B0B1F             0238*   
0B0B1F             0239*   ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B0B1F             0240*   ; uses EZ80 MLT instruction for speed
0B0B1F             0241*   ; operation: UHL * A --> UHL
0B0B1F             0242*   ; destroys: AF, HL
0B0B1F             0243*   smul24x8:
0B0B1F             0244*   ; make hl positive and store sign flag
0B0B1F CD 51 08 0B 0245*   	call hlu_abs
0B0B23 F5          0246*   	push af
0B0B24             0247*   ; do the division
0B0B24 CD 2F 0B 0B 0248*       call umul24x8 ; hl = product
0B0B28             0249*   ; adjust sign of result
0B0B28 F1          0250*   	pop af ; sign de
0B0B29 F0          0251*   	ret p ; hl was positive, nothing to do
0B0B2A CD 61 08 0B 0252*   	call neg_hlu ; result is negative
0B0B2E C9          0253*   	ret
0B0B2F             0254*   
0B0B2F             0255*   ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0B2F             0256*   ; uses EZ80 MLT instruction for speed
0B0B2F             0257*   ; operation: UHL * A --> AUHL
0B0B2F             0258*   ; destroys: AF, HL
0B0B2F             0259*   umul24x8:
0B0B2F D5          0260*   	push de ; preserve de
0B0B30             0261*   ; low byte
0B0B30 5D          0262*   	ld e,l
0B0B31 57          0263*   	ld d,a
0B0B32 ED 5C       0264*   	mlt de
0B0B34 6B          0265*   	ld l,e ; product low byte
0B0B35 08          0266*   	ex af,af' ; save multiplier
0B0B36 7A          0267*   	ld a,d ; carry
0B0B37 08          0268*   	ex af,af' ; save carry, restore multiplier
0B0B38             0269*   ; high byte
0B0B38 5C          0270*   	ld e,h
0B0B39 57          0271*   	ld d,a
0B0B3A ED 5C       0272*   	mlt de
0B0B3C 08          0273*   	ex af,af' ; save multiplier, restore carry
0B0B3D 83          0274*   	add a,e ; add carry
0B0B3E 67          0275*   	ld h,a ; product middle byte
0B0B3F 7A          0276*   	ld a,d ; carry
0B0B40 08          0277*   	ex af,af' ; save carry, restore multiplier
0B0B41             0278*   ; upper byte
0B0B41 E5          0279*   	push hl
0B0B42 33          0280*   	inc sp
0B0B43 D1          0281*   	pop de ; d = hlu
0B0B44 3B          0282*   	dec sp
0B0B45 5F          0283*   	ld e,a
0B0B46 ED 5C       0284*   	mlt de
0B0B48 08          0285*   	ex af,af' ; restore carry
0B0B49 8B          0286*   	adc a,e ; add carry
0B0B4A 22 5B 0B 0B 0287*       ld (@scratch),hl ; 7 cycles
0B0B4E 32 5D 0B 0B 0288*       ld (@scratch+2),a ; 5 cycles
0B0B52 2A 5B 0B 0B 0289*       ld hl,(@scratch) ; 7 cycles
0B0B56             0290*   ; highest byte
0B0B56 3E 00       0291*   	ld a,0 ; preserve carry flag
0B0B58 8A          0292*   	adc a,d ; product highest byte
0B0B59 D1          0293*   	pop de ; restore de
0B0B5A C9          0294*   	ret
0B0B5B             0295*   @scratch: ds 3
0B0B5E             0296*   
0B0B5E             0297*   ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0B5E             0298*   ; operation: UHL * UDE --> umulfxout
0B0B5E             0299*   umul24x24:
0B0B5E FD 21 F3 0A 0300*   	ld iy,umulfxout ; point to output buffer
       0B          
0B0B63 C5          0301*   	push bc
0B0B64 01 00 00 00 0302*   	ld bc,0
0B0B68 FD 0F 00    0303*   	ld (iy),bc
0B0B6B FD 0F 03    0304*   	ld (iy+3),bc
0B0B6E C1          0305*   	pop bc
0B0B6F             0306*   
0B0B6F             0307*   ; STEP 1: UHL * E
0B0B6F 7B          0308*   	ld a,e
0B0B70 E5          0309*   	push hl
0B0B71 CD 2F 0B 0B 0310*   	call umul24x8
0B0B75 FD 2F 00    0311*   	ld (iy+0),hl
0B0B78 FD 77 03    0312*   	ld (iy+3),a
0B0B7B             0313*   
0B0B7B             0314*   ; STEP 2: UHL * D
0B0B7B E1          0315*   	pop hl
0B0B7C E5          0316*   	push hl
0B0B7D 7A          0317*   	ld a,d
0B0B7E CD 2F 0B 0B 0318*   	call umul24x8
0B0B82 CD 8F 0B 0B 0319*   	call @accumulate
0B0B86             0320*   
0B0B86             0321*   ; STEP 3: UHL * DEU
0B0B86 E1          0322*   	pop hl
0B0B87 D5          0323*   	push de
0B0B88 33          0324*   	inc sp
0B0B89 F1          0325*   	pop af
0B0B8A 3B          0326*   	dec sp
0B0B8B CD 2F 0B 0B 0327*   	call umul24x8
0B0B8F             0328*   
0B0B8F             0329*   @accumulate:
0B0B8F FD 23       0330*   	inc iy
0B0B91             0331*   ; highest byte of product to carry
0B0B91 FD 77 03    0332*   	ld (iy+3),a
0B0B94             0333*   ; low byte of product
0B0B94 7D          0334*   	ld a,l
0B0B95 FD 86 00    0335*   	add a,(iy+0)
0B0B98 FD 77 00    0336*   	ld (iy+0),a
0B0B9B             0337*   ; high byte of product
0B0B9B 7C          0338*   	ld a,h
0B0B9C FD 8E 01    0339*   	adc a,(iy+1)
0B0B9F FD 77 01    0340*   	ld (iy+1),a
0B0BA2             0341*   ; uppper byte of product
0B0BA2 E5          0342*   	push hl
0B0BA3 33          0343*   	inc sp
0B0BA4 E1          0344*   	pop hl
0B0BA5 3B          0345*   	dec sp
0B0BA6 7C          0346*   	ld a,h
0B0BA7 FD 8E 02    0347*   	adc a,(iy+2)
0B0BAA FD 77 02    0348*   	ld (iy+2),a
0B0BAD             0349*   ; carry
0B0BAD 3E 00       0350*   	ld a,0 ; preserve flags
0B0BAF FD 8E 03    0351*   	adc a,(iy+3)
0B0BB2 FD 77 03    0352*   	ld (iy+3),a
0B0BB5 C9          0353*   	ret
0B0BB6             0354*   
0B0BB6             0355*   ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B0BB6             0356*   umul168:
0B0BB6 CD 5E 0B 0B 0357*   	call umul24x24
0B0BBA FD 27 FF    0358*   	ld hl,(iy-1)
0B0BBD C9          0359*   	ret
0B0BBE             0360*   
0B0BBE             0361*   ; smul168:	UH.L * UD.E --> UH.L (signed)
0B0BBE             0362*   smul168:
0B0BBE             0363*   ; make everything positive and store sign flags
0B0BBE CD 51 08 0B 0364*   	call hlu_abs
0B0BC2 F5          0365*   	push af
0B0BC3 EB          0366*   	ex de,hl
0B0BC4 CD 51 08 0B 0367*   	call hlu_abs
0B0BC8 EB          0368*   	ex de,hl
0B0BC9 F5          0369*   	push af
0B0BCA             0370*   ; do the division
0B0BCA CD B6 0B 0B 0371*       call umul168 ; hl = product
0B0BCE             0372*   ; adjust sign of result
0B0BCE F1          0373*   	pop af ; sign de
0B0BCF FA DA 0B 0B 0374*   	jp m,@de_neg
0B0BD3 F1          0375*   	pop af ; sign hl
0B0BD4 F0          0376*   	ret p ; both positive, nothing to do
0B0BD5             0377*   @hl_neg:
0B0BD5 CD 61 08 0B 0378*       call neg_hlu ; de pos, hl neg, result is negative
0B0BD9 C9          0379*       ret
0B0BDA             0380*   @de_neg:
0B0BDA F1          0381*   	pop af
0B0BDB F8          0382*   	ret m ; both negative, nothing to do
0B0BDC CD 61 08 0B 0383*   	call neg_hlu ; result is negative
0B0BE0 C9          0384*   	ret
0B0BE1             0385*   
0B0BE1             0386*   ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B0BE1             0387*   ; perform unsigned division of 16.8 fixed place values
0B0BE1             0388*   ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B0BE1             0389*   udiv168:
0B0BE1             0390*   ; back up divisor
0B0BE1 ED 53 18 0C 0391*   	ld (@ude),de
       0B          
0B0BE6             0392*   ; get the 16-bit integer part of the quotient
0B0BE6 CD 40 09 0B 0393*       call udiv24 ; de = quotient, hl = remainder
0B0BEA             0394*   ; load quotient to upper three bytes of output
0B0BEA ED 53 1F 0C 0395*       ld (div168_out+1),de
       0B          
0B0BEF             0396*   @div256:
0B0BEF             0397*   ; multiply remainder by 256
0B0BEF             0398*   	hlu_mul256
0B0BEF 29          0001*M          add hl,hl ; * 2
0B0BF0 29          0002*M          add hl,hl ; * 4
0B0BF1 29          0003*M          add hl,hl ; * 8
0B0BF2 29          0004*M          add hl,hl ; * 16
0B0BF3 29          0005*M          add hl,hl ; * 32
0B0BF4 29          0006*M          add hl,hl ; * 64
0B0BF5 29          0007*M          add hl,hl ; * 128
0B0BF6 29          0008*M          add hl,hl ; * 256
0B0BF7             0399*   ; skip fractional computation if remainder is zero
0B0BF7             0400*       sign_hlu
0B0BF7 19          0001*M          add hl,de
0B0BF8 B7          0002*M          or a
0B0BF9 ED 52       0003*M          sbc hl,de
0B0BFB 20 03       0401*       jr nz,@div_frac
0B0BFD AF          0402*       xor a
0B0BFE 18 0A       0403*       jr @write_frac
0B0C00             0404*   ; now divide the shifted remainder by the divisor
0B0C00             0405*   @div_frac:
0B0C00 ED 5B 18 0C 0406*   	ld de,(@ude) ; get back divisor
       0B          
0B0C05 CD 40 09 0B 0407*       call udiv24 ; de = quotient, hl = remainder
0B0C09             0408*   ; load low byte of quotient to low byte of output
0B0C09 7B          0409*       ld a,e
0B0C0A             0410*   @write_frac:
0B0C0A 32 1E 0C 0B 0411*       ld (div168_out),a
0B0C0E             0412*   ; load de with return value
0B0C0E ED 5B 1E 0C 0413*       ld de,(div168_out)
       0B          
0B0C13             0414*   ; load a with any overflow
0B0C13 3A 21 0C 0B 0415*       ld a,(div168_out+3)
0B0C17 C9          0416*       ret ; ud.e is the 16.8 result
0B0C18             0417*   @ude: ds 6
0B0C1E             0418*   div168_out: ds 4 ; the extra byte is for overflow
0B0C22             0419*   
0B0C22             0420*   ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B0C22             0421*   ; perform signed division of 16.8 fixed place values
0B0C22             0422*   ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B0C22             0423*   sdiv168:
0B0C22             0424*   ; make everything positive and store sign flags
0B0C22 CD 51 08 0B 0425*   	call hlu_abs
0B0C26 F5          0426*   	push af
0B0C27 EB          0427*   	ex de,hl
0B0C28 CD 51 08 0B 0428*   	call hlu_abs
0B0C2C EB          0429*   	ex de,hl
0B0C2D F5          0430*   	push af
0B0C2E             0431*   ; do the division
0B0C2E CD E1 0B 0B 0432*       call udiv168 ; de = quotient, hl = remainder
0B0C32             0433*   ; adjust sign of result
0B0C32 F1          0434*   	pop af ; sign de
0B0C33 FA 40 0C 0B 0435*   	jp m,@de_neg
0B0C37 F1          0436*   	pop af ; sign hl
0B0C38 F0          0437*   	ret p ; both positive, nothing to do
0B0C39             0438*   @hl_neg:
0B0C39 EB          0439*       ex de,hl ; hl = quotient, de = remainder
0B0C3A CD 61 08 0B 0440*       call neg_hlu ; de pos, hl neg, result is negative
0B0C3E EB          0441*       ex de,hl ; de = negated quotient, hl = remainder
0B0C3F C9          0442*       ret
0B0C40             0443*   @de_neg:
0B0C40 F1          0444*   	pop af
0B0C41 F8          0445*   	ret m ; both negative, nothing to do
0B0C42 EB          0446*       ex de,hl ; hl = quotient, de = remainder
0B0C43 CD 61 08 0B 0447*   	call neg_hlu ; result is negative
0B0C47 EB          0448*       ex de,hl ; de = negated quotient, hl = remainder
0B0C48 C9          0449*   	ret
0B0C49             0450*   ; ========== FROM maths24.inc ==========
0B0C49             0451*   
0B0C49             0452*   ; Expects  ADL mode
0B0C49             0453*   ; Inputs:  UH.L
0B0C49             0454*   ; Outputs: UH.L is the 16.8 square root
0B0C49             0455*   ;          UD.E is the difference inputHL-DE^2
0B0C49             0456*   ;          c flag reset
0B0C49             0457*   sqrt168:
0B0C49 CD 53 0C 0B 0458*       call sqrt24
0B0C4D EB          0459*       ex de,hl
0B0C4E 29          0460*       add hl,hl
0B0C4F 29          0461*       add hl,hl
0B0C50 29          0462*       add hl,hl
0B0C51 29          0463*       add hl,hl
0B0C52 C9          0464*       ret
0B0C53             0465*   
0B0C53             0466*   ; Expects  ADL mode
0B0C53             0467*   ; Inputs:  HL
0B0C53             0468*   ; Outputs: DE is the integer square root
0B0C53             0469*   ;          HL is the difference inputHL-DE^2
0B0C53             0470*   ;          c flag reset
0B0C53             0471*   sqrt24:
0B0C53 AF          0472*       xor a
0B0C54 45          0473*       ld b,l
0B0C55 C5          0474*       push bc
0B0C56 47          0475*       ld b,a
0B0C57 57          0476*       ld d,a
0B0C58 4F          0477*       ld c,a
0B0C59 6F          0478*       ld l,a
0B0C5A 5F          0479*       ld e,a
0B0C5B             0480*   
0B0C5B             0481*       ;Iteration 1
0B0C5B 29          0482*       add hl,hl
0B0C5C CB 11       0483*       rl c
0B0C5E 29          0484*       add hl,hl
0B0C5F CB 11       0485*       rl c
0B0C61 91          0486*       sub c
0B0C62 30 04       0487*       jr nc,$+6
0B0C64 1C          0488*       inc e
0B0C65 1C          0489*       inc e
0B0C66 2F          0490*       cpl
0B0C67 4F          0491*       ld c,a
0B0C68             0492*   
0B0C68             0493*       ;Iteration 2
0B0C68 29          0494*       add hl,hl
0B0C69 CB 11       0495*       rl c
0B0C6B 29          0496*       add hl,hl
0B0C6C CB 11       0497*       rl c
0B0C6E CB 13       0498*       rl e
0B0C70 7B          0499*       ld a,e
0B0C71 91          0500*       sub c
0B0C72 30 04       0501*       jr nc,$+6
0B0C74 1C          0502*       inc e
0B0C75 1C          0503*       inc e
0B0C76 2F          0504*       cpl
0B0C77 4F          0505*       ld c,a
0B0C78             0506*   
0B0C78             0507*       ;Iteration 3
0B0C78 29          0508*       add hl,hl
0B0C79 CB 11       0509*       rl c
0B0C7B 29          0510*       add hl,hl
0B0C7C CB 11       0511*       rl c
0B0C7E CB 13       0512*       rl e
0B0C80 7B          0513*       ld a,e
0B0C81 91          0514*       sub c
0B0C82 30 04       0515*       jr nc,$+6
0B0C84 1C          0516*       inc e
0B0C85 1C          0517*       inc e
0B0C86 2F          0518*       cpl
0B0C87 4F          0519*       ld c,a
0B0C88             0520*   
0B0C88             0521*       ;Iteration 4
0B0C88 29          0522*       add hl,hl
0B0C89 CB 11       0523*       rl c
0B0C8B 29          0524*       add hl,hl
0B0C8C CB 11       0525*       rl c
0B0C8E CB 13       0526*       rl e
0B0C90 7B          0527*       ld a,e
0B0C91 91          0528*       sub c
0B0C92 30 04       0529*       jr nc,$+6
0B0C94 1C          0530*       inc e
0B0C95 1C          0531*       inc e
0B0C96 2F          0532*       cpl
0B0C97 4F          0533*       ld c,a
0B0C98             0534*   
0B0C98             0535*       ;Iteration 5
0B0C98 29          0536*       add hl,hl
0B0C99 CB 11       0537*       rl c
0B0C9B 29          0538*       add hl,hl
0B0C9C CB 11       0539*       rl c
0B0C9E CB 13       0540*       rl e
0B0CA0 7B          0541*       ld a,e
0B0CA1 91          0542*       sub c
0B0CA2 30 04       0543*       jr nc,$+6
0B0CA4 1C          0544*       inc e
0B0CA5 1C          0545*       inc e
0B0CA6 2F          0546*       cpl
0B0CA7 4F          0547*       ld c,a
0B0CA8             0548*   
0B0CA8             0549*       ;Iteration 6
0B0CA8 29          0550*       add hl,hl
0B0CA9 CB 11       0551*       rl c
0B0CAB 29          0552*       add hl,hl
0B0CAC CB 11       0553*       rl c
0B0CAE CB 13       0554*       rl e
0B0CB0 7B          0555*       ld a,e
0B0CB1 91          0556*       sub c
0B0CB2 30 04       0557*       jr nc,$+6
0B0CB4 1C          0558*       inc e
0B0CB5 1C          0559*       inc e
0B0CB6 2F          0560*       cpl
0B0CB7 4F          0561*       ld c,a
0B0CB8             0562*   
0B0CB8             0563*       ;Iteration 7
0B0CB8 29          0564*       add hl,hl
0B0CB9 CB 11       0565*       rl c
0B0CBB 29          0566*       add hl,hl
0B0CBC CB 11       0567*       rl c
0B0CBE CB 10       0568*       rl b
0B0CC0 EB          0569*       ex de,hl
0B0CC1 29          0570*       add hl,hl
0B0CC2 E5          0571*       push hl
0B0CC3 ED 42       0572*       sbc hl,bc
0B0CC5 30 06       0573*       jr nc,$+8
0B0CC7 7C          0574*       ld a,h
0B0CC8 2F          0575*       cpl
0B0CC9 47          0576*       ld b,a
0B0CCA 7D          0577*       ld a,l
0B0CCB 2F          0578*       cpl
0B0CCC 4F          0579*       ld c,a
0B0CCD E1          0580*       pop hl
0B0CCE 30 02       0581*       jr nc,$+4
0B0CD0 23          0582*       inc hl
0B0CD1 23          0583*       inc hl
0B0CD2 EB          0584*       ex de,hl
0B0CD3             0585*   
0B0CD3             0586*       ;Iteration 8
0B0CD3 29          0587*       add hl,hl
0B0CD4 69          0588*       ld l,c
0B0CD5 60          0589*       ld h,b
0B0CD6 ED 6A       0590*       adc hl,hl
0B0CD8 ED 6A       0591*       adc hl,hl
0B0CDA EB          0592*       ex de,hl
0B0CDB 29          0593*       add hl,hl
0B0CDC ED 52       0594*       sbc hl,de
0B0CDE 19          0595*       add hl,de
0B0CDF EB          0596*       ex de,hl
0B0CE0 30 04       0597*       jr nc,$+6
0B0CE2 ED 52       0598*       sbc hl,de
0B0CE4 13          0599*       inc de
0B0CE5 13          0600*       inc de
0B0CE6             0601*   
0B0CE6             0602*       ;Iteration 9
0B0CE6 F1          0603*       pop af
0B0CE7 17          0604*       rla
0B0CE8 ED 6A       0605*       adc hl,hl
0B0CEA 17          0606*       rla
0B0CEB ED 6A       0607*       adc hl,hl
0B0CED EB          0608*       ex de,hl
0B0CEE 29          0609*       add hl,hl
0B0CEF ED 52       0610*       sbc hl,de
0B0CF1 19          0611*       add hl,de
0B0CF2 EB          0612*       ex de,hl
0B0CF3 30 04       0613*       jr nc,$+6
0B0CF5 ED 52       0614*       sbc hl,de
0B0CF7 13          0615*       inc de
0B0CF8 13          0616*       inc de
0B0CF9             0617*   
0B0CF9             0618*       ;Iteration 10
0B0CF9 17          0619*       rla
0B0CFA ED 6A       0620*       adc hl,hl
0B0CFC 17          0621*       rla
0B0CFD ED 6A       0622*       adc hl,hl
0B0CFF EB          0623*       ex de,hl
0B0D00 29          0624*       add hl,hl
0B0D01 ED 52       0625*       sbc hl,de
0B0D03 19          0626*       add hl,de
0B0D04 EB          0627*       ex de,hl
0B0D05 30 04       0628*       jr nc,$+6
0B0D07 ED 52       0629*       sbc hl,de
0B0D09 13          0630*       inc de
0B0D0A 13          0631*       inc de
0B0D0B             0632*   
0B0D0B             0633*       ;Iteration 11
0B0D0B 17          0634*       rla
0B0D0C ED 6A       0635*       adc hl,hl
0B0D0E 17          0636*       rla
0B0D0F ED 6A       0637*       adc hl,hl
0B0D11 EB          0638*       ex de,hl
0B0D12 29          0639*       add hl,hl
0B0D13 ED 52       0640*       sbc hl,de
0B0D15 19          0641*       add hl,de
0B0D16 EB          0642*       ex de,hl
0B0D17 30 04       0643*       jr nc,$+6
0B0D19 ED 52       0644*       sbc hl,de
0B0D1B 13          0645*       inc de
0B0D1C 13          0646*       inc de
0B0D1D             0647*   
0B0D1D             0648*       ;Iteration 11
0B0D1D 17          0649*       rla
0B0D1E ED 6A       0650*       adc hl,hl
0B0D20 17          0651*       rla
0B0D21 ED 6A       0652*       adc hl,hl
0B0D23 EB          0653*       ex de,hl
0B0D24 29          0654*       add hl,hl
0B0D25 ED 52       0655*       sbc hl,de
0B0D27 19          0656*       add hl,de
0B0D28 EB          0657*       ex de,hl
0B0D29 30 04       0658*       jr nc,$+6
0B0D2B ED 52       0659*       sbc hl,de
0B0D2D 13          0660*       inc de
0B0D2E 13          0661*       inc de
0B0D2F             0662*   
0B0D2F CB 1A       0663*       rr d
0B0D31 CB 1B       0664*       rr e
0B0D33 C9          0665*       ret
0B0D34             0023        include "trig24.inc"
0B0D34             0001*   
0B0D34             0002*   ; convert signed angles from a 360 to 256 degree circle
0B0D34             0003*   ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0D34             0004*   ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0D34             0005*   ; destroys: TODO
0B0D34             0006*   deg_360_to_256:
0B0D34 D5          0007*   	push de ; preserve de
0B0D35             0008*   ; make angle positive and store sign flag
0B0D35 CD 51 08 0B 0009*   	call hlu_abs
0B0D39 F5          0010*   	push af
0B0D3A             0011*   ; multiply by 256 first to keep precision
0B0D3A             0012*   	hlu_mul256 ; uh.l = uh.l * 256
0B0D3A 29          0001*M          add hl,hl ; * 2
0B0D3B 29          0002*M          add hl,hl ; * 4
0B0D3C 29          0003*M          add hl,hl ; * 8
0B0D3D 29          0004*M          add hl,hl ; * 16
0B0D3E 29          0005*M          add hl,hl ; * 32
0B0D3F 29          0006*M          add hl,hl ; * 64
0B0D40 29          0007*M          add hl,hl ; * 128
0B0D41 29          0008*M          add hl,hl ; * 256
0B0D42             0013*   ; divide uh.l by 360
0B0D42 11 68 01 00 0014*   	ld de,360
0B0D46 CD 40 09 0B 0015*   	call udiv24 ; ud.e = degrees / 360
0B0D4A EB          0016*   	ex de,hl    ; uh.l = degrees / 360
0B0D4B             0017*   ; restore sign flag and adjust output accordingly
0B0D4B F1          0018*   	pop af
0B0D4C F2 54 0D 0B 0019*   	jp p,@pos ; positive number
0B0D50 CD 61 08 0B 0020*   	call neg_hlu
0B0D54             0021*   @pos:
0B0D54             0022*   ; restore de and return uh.l as the result
0B0D54 D1          0023*   	pop de
0B0D55 C9          0024*   	ret
0B0D56             0025*   
0B0D56             0026*   ; fixed 16.8 routine
0B0D56             0027*   ; cos(uh.l) --> uh.l
0B0D56             0028*   ; destroys: de
0B0D56             0029*   cos168:
0B0D56             0030*   ; for cos we simply increment the angle by 90 degrees
0B0D56             0031*   ; or 0x004000 in 16.8 degrees256
0B0D56             0032*   ; which makes it a sin problem
0B0D56 11 00 40 00 0033*       ld de,0x004000
0B0D5A 19          0034*       add hl,de ; modulo 256 happens below
0B0D5B             0035*   ; fall through to sin168
0B0D5B             0036*   
0B0D5B             0037*   ; ---------------------
0B0D5B             0038*   ; fixed 16.8 routine
0B0D5B             0039*   ; sin(uh.l) --> uh.l
0B0D5B             0040*   ; destroys: af
0B0D5B             0041*   sin168:
0B0D5B D5          0042*   	push de
0B0D5C DD E5       0043*   	push ix
0B0D5E             0044*   ; handle negative angles appropriately
0B0D5E CD 51 08 0B 0045*   	call hlu_abs
0B0D62 F2 6B 0D 0B 0046*   	jp p,@f
0B0D66 11 00 00 FF 0047*   	ld de,-256*256
0B0D6A 19          0048*   	add hl,de
0B0D6B             0049*   @@:
0B0D6B             0050*   ; get the lookup value for the integer portion of the angle
0B0D6B 7D          0051*   	ld a,l ; save fractional part of the angle
0B0D6C 2E 06       0052*   	ld l,6 ; multiply by 6 to get our lookup index
0B0D6E EB          0053*   	ex de,hl ; can't add ix,hl
0B0D6F ED 5C       0054*   	mlt de ; gosh that is handy
0B0D71 DD 21 DD 11 0055*       ld ix,sin_lut_816 ; grab the lut address
       0B          
0B0D76 DD 19       0056*       add ix,de ; bump hl by the index
0B0D78 DD 27 00    0057*       ld hl,(ix) ; hl = sin(int(angle))
0B0D7B B7          0058*   	or a  ; check fractional part of the angle for zero
0B0D7C CA 8D 0D 0B 0059*   	jp z,@f ; no fractional part so skip interpolation
0B0D80             0060*   ; interpolate the fractional part of the angle
0B0D80 DD 17 03    0061*   	ld de,(ix+3)
0B0D83 EB          0062*   	ex de,hl
0B0D84 CD 1F 0B 0B 0063*   	call smul24x8
0B0D88 CD 9D 08 0B 0064*   	call hlu_sdiv256
0B0D8C 19          0065*   	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle))
0B0D8D             0066*   @@:
0B0D8D CD 9D 08 0B 0067*   	call hlu_sdiv256
0B0D91 DD E1       0068*   	pop ix
0B0D93 D1          0069*   	pop de
0B0D94 C9          0070*       ret ; and out
0B0D95             0071*   
0B0D95             0072*   ; 16.8 fixed inputs / outputs
0B0D95             0073*   ; takes: uh.l as angle in degrees 256
0B0D95             0074*   ;        ud.e as radius
0B0D95             0075*   ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B0D95             0076*   ;        displacements from origin (0,0)
0B0D95             0077*   ; destroys: everything except indexes
0B0D95             0078*   polar_to_cartesian:
0B0D95             0079*   	; call printNewLine ; DEBUG
0B0D95             0080*   ; back up input parameters
0B0D95 22 C0 0D 0B 0081*       ld (@angle), hl
0B0D99 ED 53 C3 0D 0082*       ld (@radius), de
       0B          
0B0D9E             0083*   ; compute dx = cos(uh.l) * ud.e
0B0D9E CD 56 0D 0B 0084*       call cos168 ; uh.l = cos(uh.l)
0B0DA2             0085*   	; call print_hex_hl ; DEBUG
0B0DA2             0086*   	; call print_s168_hl ; DEBUG
0B0DA2 ED 5B C3 0D 0087*   	ld de,(@radius)
       0B          
0B0DA7 CD BE 0B 0B 0088*   	call smul168 ; uh.l = dx
0B0DAB E5          0089*       push hl
0B0DAC             0090*   ; compute dy = sin(uh.l) * ud.e
0B0DAC 2A C0 0D 0B 0091*       ld hl,(@angle)
0B0DB0 CD 5B 0D 0B 0092*       call sin168 ; uh.l = sin(uh.l)
0B0DB4             0093*   	; call print_hex_hl ; DEBUG
0B0DB4             0094*   	; call print_s168_hl ; DEBUG
0B0DB4 ED 5B C3 0D 0095*       ld de,(@radius)
       0B          
0B0DB9 CD BE 0B 0B 0096*       call smul168    ; uh.l = dy
0B0DBD EB          0097*       ex de,hl       ; de = dy for output
0B0DBE C1          0098*       pop bc          ; bc = dx for output
0B0DBF             0099*   ; and out
0B0DBF C9          0100*       ret
0B0DC0             0101*   @angle: ds 3
0B0DC3             0102*   @radius: ds 3
0B0DC6             0103*   
0B0DC6             0104*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0DC6             0105*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0DC6             0106*   ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0DC6             0107*   ;         also populates scratch locations dx168 and dy168
0B0DC6             0108*   ; destroys: a,hl,bc,de
0B0DC6             0109*   dxy168:
0B0DC6             0110*   ; compute dx = x1-x0
0B0DC6 AF          0111*       xor a ; clear carry
0B0DC7 DD E5       0112*       push ix ; move ix to hl via the stack
0B0DC9 E1          0113*       pop hl ; hl = x1
0B0DCA ED 42       0114*       sbc hl,bc ; hl = dx
0B0DCC 22 21 0E 0B 0115*       ld (dx168),hl ; dx to scratch
0B0DD0             0116*   ; compute dy = y1-y0
0B0DD0 AF          0117*       xor a ; clear carry
0B0DD1 FD E5       0118*       push iy ; move iy to hl via the stack
0B0DD3 E1          0119*       pop hl ; hl = y1
0B0DD4 ED 52       0120*       sbc hl,de ; hl = dy
0B0DD6 22 27 0E 0B 0121*       ld (dy168),hl ; dy to scratch
0B0DDA             0122*   ; populate output registers and return
0B0DDA EB          0123*       ex de,hl        ; ud.e = dy
0B0DDB ED 4B 21 0E 0124*       ld bc,(dx168)   ; ub.c = dx
       0B          
0B0DE0 C9          0125*       ret
0B0DE1             0126*   
0B0DE1             0127*   ; compute the euclidian distance between two cartesian coordinates
0B0DE1             0128*   ; using the formula d = sqrt(dx^2+dy^2
0B0DE1             0129*   ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0DE1             0130*   ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0DE1             0131*   ; output; uh.l is the 16.8 fixed format distance
0B0DE1             0132*   ;       dx168/y are the 16.8 fixed format dx and dy
0B0DE1             0133*   ; destroys: a,hl,bc,de
0B0DE1             0134*   distance168:
0B0DE1             0135*   ; compute dx = x1-x0
0B0DE1 AF          0136*       xor a ; clear carry
0B0DE2 DD E5       0137*       push ix ; move ix to hl via the stack
0B0DE4 E1          0138*       pop hl ; hl = x1
0B0DE5 ED 42       0139*       sbc hl,bc ; hl = dx
0B0DE7 22 21 0E 0B 0140*       ld (dx168),hl ; dx to scratch
0B0DEB             0141*   ; ; test dx for overflow
0B0DEB             0142*   ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0DEB             0143*   ; 	ex de,hl
0B0DEB             0144*   ; 	sbc hl,de ; test for overflow
0B0DEB             0145*   ; 	push af ; carry indicates overflow
0B0DEB             0146*   ; compute dy = y1-y0
0B0DEB AF          0147*       xor a ; clear carry
0B0DEC FD E5       0148*       push iy ; move iy to hl via the stack
0B0DEE E1          0149*       pop hl ; hl = y1
0B0DEF ED 52       0150*       sbc hl,de ; hl = dy
0B0DF1 22 27 0E 0B 0151*       ld (dy168),hl ; dy to scratch
0B0DF5             0152*   ; ; test dy for overflow
0B0DF5             0153*   ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0DF5             0154*   ; 	ex de,hl
0B0DF5             0155*   ; 	sbc hl,de ; test for overflow
0B0DF5             0156*   ; 	push af ; carry indicates overflow
0B0DF5             0157*   ; compute dy^2
0B0DF5 2A 27 0E 0B 0158*   	ld hl,(dy168)
0B0DF9 CD 51 08 0B 0159*       call hlu_abs  ; make dy positive so we can use unsigned multiply
0B0DFD             0160*       ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0DFD E5          0161*       push hl ; load hl/2 to bc via the stack
0B0DFE C1          0162*       pop bc ; bc = dy/2
0B0DFF EB          0163*       ex de,hl ; de = dy/2
0B0E00 CD B6 0B 0B 0164*       call umul168 ; uh.l = dy^2/2
0B0E04 E5          0165*       push hl ; dy^2/2 to the stack
0B0E05             0166*   ; compute dx^2
0B0E05 2A 21 0E 0B 0167*       ld hl,(dx168) ; get back dx
0B0E09 CD 51 08 0B 0168*       call hlu_abs  ; make dx positive so we can use unsigned multiply
0B0E0D             0169*       ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0E0D E5          0170*       push hl ; load hl/2 to bc via the stack
0B0E0E C1          0171*       pop bc ; bc = dx/2
0B0E0F EB          0172*       ex de,hl ; de = dx/2
0B0E10 CD B6 0B 0B 0173*       call umul168 ; uh.l = dx^2/2
0B0E14             0174*   ; commpute dy^2+dx^2
0B0E14 D1          0175*       pop de ; get back dx^2/2
0B0E15 19          0176*       add hl,de ; hl = dx^2/2+dy^2/2
0B0E16             0177*   ; compute sqrt(dx^2/2+dy^2/2)
0B0E16 CD 49 0C 0B 0178*       call sqrt168 ; uh.l = distance/2
0B0E1A             0179*       ; add hl,hl ; hl = distance
0B0E1A             0180*   ; ; check for overflow
0B0E1A             0181*   ; 	pop af ; get back the overflow flags
0B0E1A             0182*   ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0E1A             0183*   ; 	ld b,a ; save the overflow flag
0B0E1A             0184*   ; 	pop af ; get back the overflow flags
0B0E1A             0185*   ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0E1A             0186*   ; 	add a,b ; if a != 0 then we had overflow
0B0E1A             0187*   ;     ret z ; no overflow we're done
0B0E1A             0188*   ; @overflow:
0B0E1A             0189*   ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0E1A C9          0190*   	ret
0B0E1B             0191*   @scratch: ds 6
0B0E21             0192*   dx168: ds 6
0B0E27             0193*   dy168: ds 6
0B0E2D             0194*   
0B0E2D             0195*   ; atan2(ub.c,ud.e) --> uh.l
0B0E2D             0196*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0E2D             0197*   ;   whether inputs are integers or fractional doesn't matter
0B0E2D             0198*   ;   so long as the sign bit of the upper byte is correct
0B0E2D             0199*   ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0E2D             0200*   ; angles are COMPASS HEADINGS based on
0B0E2D             0201*   ; screen coordinate conventions,where the y axis is flipped
0B0E2D             0202*   ; #E0 315      0       45 #20
0B0E2D             0203*   ;        -x,-y | +x,-y
0B0E2D             0204*   ; #C0 270------+------ 90 #40
0B0E2D             0205*   ;        -x,+y | +x,+y
0B0E2D             0206*   ; #A0 225   180 #80   135 #60
0B0E2D             0207*   atan2_168game:
0B0E2D             0208*   ; get signs and make everything positive
0B0E2D             0209*   ; get abs(x) and store its original sign
0B0E2D C5          0210*       push bc
0B0E2E E1          0211*       pop hl
0B0E2F CD 51 08 0B 0212*       call hlu_abs ; if x was negative this also sets the sign flag
0B0E33 E5          0213*       push hl ; store abs(x)
0B0E34 C1          0214*       pop bc ; bc = abs(x)
0B0E35 F5          0215*       push af ; store sign of x
0B0E36             0216*   ; get abs(y) and store its original sign
0B0E36 EB          0217*       ex de,hl ; hl = y
0B0E37 CD 51 08 0B 0218*       call hlu_abs ; if y was negative this also sets the sign flag
0B0E3B EB          0219*       ex de,hl ; de = abs(y)
0B0E3C F5          0220*       push af ; store sign of y
0B0E3D             0221*   ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0E3D             0222*   ; this ensures that our lookup value is between 0 and 1 inclusive
0B0E3D AF          0223*       xor a ; clear the carry flag
0B0E3E D5          0224*       push de
0B0E3F E1          0225*       pop hl
0B0E40 ED 42       0226*       sbc hl,bc
0B0E42 F5          0227*       push af ; save sign of de - bc
0B0E43 F2 4C 0E 0B 0228*       jp p,@1 ; bc <= de, so we skip ahead
0B0E47             0229*   ; otherwise we swap bc and de
0B0E47 C5          0230*       push bc
0B0E48 E1          0231*       pop hl
0B0E49 EB          0232*       ex de,hl
0B0E4A E5          0233*       push hl
0B0E4B C1          0234*       pop bc
0B0E4C             0235*   @1:
0B0E4C             0236*   ; now we're ready to snag our preliminary result
0B0E4C CD BA 0E 0B 0237*       call atan_168game ; uh.l comes back with prelim result
0B0E50             0238*   ; now we adjust uh.l based on sign of de - bc
0B0E50 F1          0239*       pop af
0B0E51 F2 5D 0E 0B 0240*       jp p,@2 ; bc <= de,so we skip ahead
0B0E55 EB          0241*       ex de,hl
0B0E56 21 00 40 00 0242*       ld hl,0x004000 ; 90 degrees
0B0E5A AF          0243*       xor a ; clear the carry flag
0B0E5B ED 52       0244*       sbc hl,de ; subtract result from 90 degrees
0B0E5D             0245*       ; ld de,0 ; prep to clear hlu
0B0E5D             0246*       ; ld d,h
0B0E5D             0247*       ; ld e,l
0B0E5D             0248*       ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0E5D             0249*       ; fall through
0B0E5D             0250*   @2:
0B0E5D             0251*   ; now the fun part of adjusting the result
0B0E5D             0252*   ; based on which quadrant (x,y) is in
0B0E5D             0253*   ; #E0 315      0       45 #20
0B0E5D             0254*   ;        -x,-y | +x,-y
0B0E5D             0255*   ; #C0 270------+------ 90 #40
0B0E5D             0256*   ;        -x,+y | +x,+y
0B0E5D             0257*   ; #A0 225   180 #80   135 #60
0B0E5D F1          0258*       pop af ; sign of y
0B0E5E CA 9B 0E 0B 0259*       jp z,@y_zero
0B0E62 F2 7B 0E 0B 0260*       jp p,@y_pos
0B0E66             0261*   ; y neg,check x
0B0E66 F1          0262*       pop af ; sign of x
0B0E67 CA 75 0E 0B 0263*       jp z,@y_neg_x_zero
0B0E6B F2 7A 0E 0B 0264*       jp p,@y_neg_x_pos
0B0E6F             0265*   ; y neg,x neg
0B0E6F             0266*   ; angle is 270-360
0B0E6F             0267*   ; negating the intermediate does the trick
0B0E6F CD 61 08 0B 0268*       call neg_hlu
0B0E73 18 31       0269*       jr @zero_hlu
0B0E75             0270*   
0B0E75             0271*   @y_neg_x_zero:
0B0E75             0272*   ; y neg,x zero
0B0E75             0273*   ; angle is 0
0B0E75 21 00 00 00 0274*       ld hl,0
0B0E79 C9          0275*       ret
0B0E7A             0276*   @y_neg_x_pos:
0B0E7A             0277*   ; y neg,x pos
0B0E7A             0278*   ; angle is 0 to 90
0B0E7A             0279*   ; so we're good
0B0E7A C9          0280*       ret
0B0E7B             0281*   
0B0E7B             0282*   @y_pos:
0B0E7B F1          0283*       pop af ; sign of x
0B0E7C CA 8B 0E 0B 0284*       jp z,@y_pos_x_zero
0B0E80 F2 90 0E 0B 0285*       jp p,@y_pos_x_pos
0B0E84             0286*   ; y pos,x neg
0B0E84             0287*   ; angle is 180-270
0B0E84             0288*   ; so we add 180 to intermediate
0B0E84 11 00 80 00 0289*       ld de,0x008000
0B0E88 19          0290*       add hl,de
0B0E89 18 1B       0291*       jr @zero_hlu
0B0E8B             0292*   @y_pos_x_zero:
0B0E8B             0293*   ; y pos,x zero
0B0E8B             0294*   ; angle is 180
0B0E8B 21 00 80 00 0295*       ld hl,0x008000
0B0E8F C9          0296*       ret
0B0E90             0297*   @y_pos_x_pos:
0B0E90             0298*   ; y pos,x pos
0B0E90             0299*   ; angle is 90-180
0B0E90             0300*   ; neg the intermediate and add 180 degrees
0B0E90 CD 61 08 0B 0301*       call neg_hlu
0B0E94 11 00 80 00 0302*       ld de,0x008000
0B0E98 19          0303*       add hl,de
0B0E99 18 0B       0304*       jr @zero_hlu
0B0E9B             0305*   
0B0E9B             0306*   @y_zero:
0B0E9B F1          0307*       pop af ; sign of x
0B0E9C FA A1 0E 0B 0308*       jp m,@y_zero_x_neg
0B0EA0             0309*   ; y zero,x pos
0B0EA0             0310*   ; angle is 90,nothing to do
0B0EA0 C9          0311*       ret
0B0EA1             0312*   @y_zero_x_neg:
0B0EA1             0313*   ; y zero ,x neg
0B0EA1             0314*   ; angle is 270
0B0EA1 21 00 C0 00 0315*       ld hl,0x00C000
0B0EA5 C9          0316*       ret
0B0EA6             0317*   @zero_hlu:
0B0EA6 AF          0318*       xor a
0B0EA7 22 B4 0E 0B 0319*       ld (@scratch),hl
0B0EAB 32 B6 0E 0B 0320*       ld (@scratch+2),a
0B0EAF 2A B4 0E 0B 0321*       ld hl,(@scratch)
0B0EB3 C9          0322*       ret
0B0EB4             0323*   @scratch: ds 6
0B0EBA             0324*   
0B0EBA             0325*   ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0EBA             0326*   ; output: uh.l is the 16.8 fixed format angle
0B0EBA             0327*   ; destroys: a,hl,bc,de
0B0EBA             0328*   ; the following note was written by github copilot:
0B0EBA             0329*   ; note: this routine is a bit of a hack
0B0EBA             0330*   ;      but it works
0B0EBA             0331*   ;      and it's fast
0B0EBA             0332*   ;      and it's small
0B0EBA             0333*   ;      and it's accurate
0B0EBA             0334*   ;      and it's easy to understand
0B0EBA             0335*   ;      and it's easy to modify
0B0EBA             0336*   ;      and it's easy to use
0B0EBA             0337*   ;      and it's easy to remember
0B0EBA             0338*   ;      and it's easy to love
0B0EBA             0339*   ;      and it's easy to hate
0B0EBA             0340*   ;      and it's easy to ignore
0B0EBA             0341*   ;      and it's easy to forget
0B0EBA             0342*   ;      and it's easy to remember
0B0EBA             0343*   ;      and it's easy to forget
0B0EBA             0344*   ;      and it's easy to remember
0B0EBA             0345*   ;      (ok the bot is stuck in a loop)
0B0EBA             0346*   ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0EBA             0347*   ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0EBA             0348*   atan_168game:
0B0EBA             0349*   ; because we use compass headings instead of geometric angles
0B0EBA             0350*   ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0EBA             0351*   ; we can do faster unsigned division here because we know dx and dy are positive
0B0EBA CD E1 0B 0B 0352*   	call udiv168 ; uh.l = dx/dy
0B0EBE             0353*   ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0EBE             0354*   ; ; test uh.l for 0
0B0EBE             0355*   ;     add hl,de
0B0EBE             0356*   ;     or a
0B0EBE             0357*   ;     sbc hl,de
0B0EBE             0358*   ;     jr z,@is_zero
0B0EBE             0359*   ; ; test uh.l for 1
0B0EBE             0360*   ;     xor a ; clear carry
0B0EBE             0361*   ;     ex de,hl
0B0EBE             0362*   ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0EBE             0363*   ;     sbc hl,de
0B0EBE             0364*   ;     jr z,@is_45
0B0EBE             0365*   ; ; END TODO
0B0EBE             0366*   
0B0EBE             0367*   ; no special cases so we move on
0B0EBE             0368*   ; l contains the fractional portion of tan(uh.l)
0B0EBE             0369*   ; we multiply it by three to get our lookup table index
0B0EBE 26 03       0370*       ld h,3
0B0EC0 ED 6C       0371*       mlt hl ; gosh that is handy
0B0EC2 11 00 00 00 0372*       ld de,0 ; clear deu
0B0EC6 54          0373*       ld d,h ; copy hl to de
0B0EC7 5D          0374*       ld e,l ; de contains our index
0B0EC8 21 E3 1A 0B 0375*       ld hl,atan_lut_168 ; grab the lut address
0B0ECC 19          0376*       add hl,de ; bump hl by the index
0B0ECD ED 27       0377*       ld hl,(hl) ; don't try this on a z80!
0B0ECF C9          0378*       ret ; and out
0B0ED0             0379*   @is_45:
0B0ED0 21 00 20 00 0380*       ld hl,0x002000 ; 45 degrees decimal
0B0ED4 C9          0381*       ret
0B0ED5             0382*   ; for the case tan(0)
0B0ED5             0383*   @is_zero:
0B0ED5 21 00 00 00 0384*       ld hl,0x000000
0B0ED9 C9          0385*       ret
0B0EDA             0386*   
0B0EDA             0387*   sin_lut_168:
0B0EDA 00 00 00    0388*   	dl 0x000000 ; 0.000 00, 0.000
0B0EDD 06 00 00    0389*   	dl 0x000006 ; 1.406 01, 0.025
0B0EE0 0C 00 00    0390*   	dl 0x00000C ; 2.813 02, 0.049
0B0EE3 12 00 00    0391*   	dl 0x000012 ; 4.219 03, 0.074
0B0EE6 19 00 00    0392*   	dl 0x000019 ; 5.625 04, 0.098
0B0EE9 1F 00 00    0393*   	dl 0x00001F ; 7.031 05, 0.122
0B0EEC 25 00 00    0394*   	dl 0x000025 ; 8.438 06, 0.147
0B0EEF 2B 00 00    0395*   	dl 0x00002B ; 9.844 07, 0.171
0B0EF2 31 00 00    0396*   	dl 0x000031 ; 11.250 08, 0.195
0B0EF5 38 00 00    0397*   	dl 0x000038 ; 12.656 09, 0.219
0B0EF8 3E 00 00    0398*   	dl 0x00003E ; 14.063 0A, 0.243
0B0EFB 44 00 00    0399*   	dl 0x000044 ; 15.469 0B, 0.267
0B0EFE 4A 00 00    0400*   	dl 0x00004A ; 16.875 0C, 0.290
0B0F01 50 00 00    0401*   	dl 0x000050 ; 18.281 0D, 0.314
0B0F04 56 00 00    0402*   	dl 0x000056 ; 19.688 0E, 0.337
0B0F07 5C 00 00    0403*   	dl 0x00005C ; 21.094 0F, 0.360
0B0F0A 61 00 00    0404*   	dl 0x000061 ; 22.500 10, 0.383
0B0F0D 67 00 00    0405*   	dl 0x000067 ; 23.906 11, 0.405
0B0F10 6D 00 00    0406*   	dl 0x00006D ; 25.313 12, 0.428
0B0F13 73 00 00    0407*   	dl 0x000073 ; 26.719 13, 0.450
0B0F16 78 00 00    0408*   	dl 0x000078 ; 28.125 14, 0.471
0B0F19 7E 00 00    0409*   	dl 0x00007E ; 29.531 15, 0.493
0B0F1C 83 00 00    0410*   	dl 0x000083 ; 30.938 16, 0.514
0B0F1F 88 00 00    0411*   	dl 0x000088 ; 32.344 17, 0.535
0B0F22 8E 00 00    0412*   	dl 0x00008E ; 33.750 18, 0.556
0B0F25 93 00 00    0413*   	dl 0x000093 ; 35.156 19, 0.576
0B0F28 98 00 00    0414*   	dl 0x000098 ; 36.563 1A, 0.596
0B0F2B 9D 00 00    0415*   	dl 0x00009D ; 37.969 1B, 0.615
0B0F2E A2 00 00    0416*   	dl 0x0000A2 ; 39.375 1C, 0.634
0B0F31 A7 00 00    0417*   	dl 0x0000A7 ; 40.781 1D, 0.653
0B0F34 AB 00 00    0418*   	dl 0x0000AB ; 42.188 1E, 0.672
0B0F37 B0 00 00    0419*   	dl 0x0000B0 ; 43.594 1F, 0.690
0B0F3A B5 00 00    0420*   	dl 0x0000B5 ; 45.000 20, 0.707
0B0F3D B9 00 00    0421*   	dl 0x0000B9 ; 46.406 21, 0.724
0B0F40 BD 00 00    0422*   	dl 0x0000BD ; 47.813 22, 0.741
0B0F43 C1 00 00    0423*   	dl 0x0000C1 ; 49.219 23, 0.757
0B0F46 C5 00 00    0424*   	dl 0x0000C5 ; 50.625 24, 0.773
0B0F49 C9 00 00    0425*   	dl 0x0000C9 ; 52.031 25, 0.788
0B0F4C CD 00 00    0426*   	dl 0x0000CD ; 53.438 26, 0.803
0B0F4F D1 00 00    0427*   	dl 0x0000D1 ; 54.844 27, 0.818
0B0F52 D4 00 00    0428*   	dl 0x0000D4 ; 56.250 28, 0.831
0B0F55 D8 00 00    0429*   	dl 0x0000D8 ; 57.656 29, 0.845
0B0F58 DB 00 00    0430*   	dl 0x0000DB ; 59.063 2A, 0.858
0B0F5B DE 00 00    0431*   	dl 0x0000DE ; 60.469 2B, 0.870
0B0F5E E1 00 00    0432*   	dl 0x0000E1 ; 61.875 2C, 0.882
0B0F61 E4 00 00    0433*   	dl 0x0000E4 ; 63.281 2D, 0.893
0B0F64 E7 00 00    0434*   	dl 0x0000E7 ; 64.688 2E, 0.904
0B0F67 EA 00 00    0435*   	dl 0x0000EA ; 66.094 2F, 0.914
0B0F6A EC 00 00    0436*   	dl 0x0000EC ; 67.500 30, 0.924
0B0F6D EE 00 00    0437*   	dl 0x0000EE ; 68.906 31, 0.933
0B0F70 F1 00 00    0438*   	dl 0x0000F1 ; 70.313 32, 0.942
0B0F73 F3 00 00    0439*   	dl 0x0000F3 ; 71.719 33, 0.950
0B0F76 F4 00 00    0440*   	dl 0x0000F4 ; 73.125 34, 0.957
0B0F79 F6 00 00    0441*   	dl 0x0000F6 ; 74.531 35, 0.964
0B0F7C F8 00 00    0442*   	dl 0x0000F8 ; 75.938 36, 0.970
0B0F7F F9 00 00    0443*   	dl 0x0000F9 ; 77.344 37, 0.976
0B0F82 FB 00 00    0444*   	dl 0x0000FB ; 78.750 38, 0.981
0B0F85 FC 00 00    0445*   	dl 0x0000FC ; 80.156 39, 0.985
0B0F88 FD 00 00    0446*   	dl 0x0000FD ; 81.563 3A, 0.989
0B0F8B FE 00 00    0447*   	dl 0x0000FE ; 82.969 3B, 0.992
0B0F8E FE 00 00    0448*   	dl 0x0000FE ; 84.375 3C, 0.995
0B0F91 FF 00 00    0449*   	dl 0x0000FF ; 85.781 3D, 0.997
0B0F94 FF 00 00    0450*   	dl 0x0000FF ; 87.188 3E, 0.999
0B0F97 FF 00 00    0451*   	dl 0x0000FF ; 88.594 3F, 1.000
0B0F9A 00 01 00    0452*   	dl 0x000100 ; 90.000 40, 1.000
0B0F9D FF 00 00    0453*   	dl 0x0000FF ; 91.406 41, 1.000
0B0FA0 FF 00 00    0454*   	dl 0x0000FF ; 92.813 42, 0.999
0B0FA3 FF 00 00    0455*   	dl 0x0000FF ; 94.219 43, 0.997
0B0FA6 FE 00 00    0456*   	dl 0x0000FE ; 95.625 44, 0.995
0B0FA9 FE 00 00    0457*   	dl 0x0000FE ; 97.031 45, 0.992
0B0FAC FD 00 00    0458*   	dl 0x0000FD ; 98.438 46, 0.989
0B0FAF FC 00 00    0459*   	dl 0x0000FC ; 99.844 47, 0.985
0B0FB2 FB 00 00    0460*   	dl 0x0000FB ; 101.250 48, 0.981
0B0FB5 F9 00 00    0461*   	dl 0x0000F9 ; 102.656 49, 0.976
0B0FB8 F8 00 00    0462*   	dl 0x0000F8 ; 104.063 4A, 0.970
0B0FBB F6 00 00    0463*   	dl 0x0000F6 ; 105.469 4B, 0.964
0B0FBE F4 00 00    0464*   	dl 0x0000F4 ; 106.875 4C, 0.957
0B0FC1 F3 00 00    0465*   	dl 0x0000F3 ; 108.281 4D, 0.950
0B0FC4 F1 00 00    0466*   	dl 0x0000F1 ; 109.688 4E, 0.942
0B0FC7 EE 00 00    0467*   	dl 0x0000EE ; 111.094 4F, 0.933
0B0FCA EC 00 00    0468*   	dl 0x0000EC ; 112.500 50, 0.924
0B0FCD EA 00 00    0469*   	dl 0x0000EA ; 113.906 51, 0.914
0B0FD0 E7 00 00    0470*   	dl 0x0000E7 ; 115.313 52, 0.904
0B0FD3 E4 00 00    0471*   	dl 0x0000E4 ; 116.719 53, 0.893
0B0FD6 E1 00 00    0472*   	dl 0x0000E1 ; 118.125 54, 0.882
0B0FD9 DE 00 00    0473*   	dl 0x0000DE ; 119.531 55, 0.870
0B0FDC DB 00 00    0474*   	dl 0x0000DB ; 120.938 56, 0.858
0B0FDF D8 00 00    0475*   	dl 0x0000D8 ; 122.344 57, 0.845
0B0FE2 D4 00 00    0476*   	dl 0x0000D4 ; 123.750 58, 0.831
0B0FE5 D1 00 00    0477*   	dl 0x0000D1 ; 125.156 59, 0.818
0B0FE8 CD 00 00    0478*   	dl 0x0000CD ; 126.563 5A, 0.803
0B0FEB C9 00 00    0479*   	dl 0x0000C9 ; 127.969 5B, 0.788
0B0FEE C5 00 00    0480*   	dl 0x0000C5 ; 129.375 5C, 0.773
0B0FF1 C1 00 00    0481*   	dl 0x0000C1 ; 130.781 5D, 0.757
0B0FF4 BD 00 00    0482*   	dl 0x0000BD ; 132.188 5E, 0.741
0B0FF7 B9 00 00    0483*   	dl 0x0000B9 ; 133.594 5F, 0.724
0B0FFA B5 00 00    0484*   	dl 0x0000B5 ; 135.000 60, 0.707
0B0FFD B0 00 00    0485*   	dl 0x0000B0 ; 136.406 61, 0.690
0B1000 AB 00 00    0486*   	dl 0x0000AB ; 137.813 62, 0.672
0B1003 A7 00 00    0487*   	dl 0x0000A7 ; 139.219 63, 0.653
0B1006 A2 00 00    0488*   	dl 0x0000A2 ; 140.625 64, 0.634
0B1009 9D 00 00    0489*   	dl 0x00009D ; 142.031 65, 0.615
0B100C 98 00 00    0490*   	dl 0x000098 ; 143.438 66, 0.596
0B100F 93 00 00    0491*   	dl 0x000093 ; 144.844 67, 0.576
0B1012 8E 00 00    0492*   	dl 0x00008E ; 146.250 68, 0.556
0B1015 88 00 00    0493*   	dl 0x000088 ; 147.656 69, 0.535
0B1018 83 00 00    0494*   	dl 0x000083 ; 149.063 6A, 0.514
0B101B 7E 00 00    0495*   	dl 0x00007E ; 150.469 6B, 0.493
0B101E 78 00 00    0496*   	dl 0x000078 ; 151.875 6C, 0.471
0B1021 73 00 00    0497*   	dl 0x000073 ; 153.281 6D, 0.450
0B1024 6D 00 00    0498*   	dl 0x00006D ; 154.688 6E, 0.428
0B1027 67 00 00    0499*   	dl 0x000067 ; 156.094 6F, 0.405
0B102A 61 00 00    0500*   	dl 0x000061 ; 157.500 70, 0.383
0B102D 5C 00 00    0501*   	dl 0x00005C ; 158.906 71, 0.360
0B1030 56 00 00    0502*   	dl 0x000056 ; 160.313 72, 0.337
0B1033 50 00 00    0503*   	dl 0x000050 ; 161.719 73, 0.314
0B1036 4A 00 00    0504*   	dl 0x00004A ; 163.125 74, 0.290
0B1039 44 00 00    0505*   	dl 0x000044 ; 164.531 75, 0.267
0B103C 3E 00 00    0506*   	dl 0x00003E ; 165.938 76, 0.243
0B103F 38 00 00    0507*   	dl 0x000038 ; 167.344 77, 0.219
0B1042 31 00 00    0508*   	dl 0x000031 ; 168.750 78, 0.195
0B1045 2B 00 00    0509*   	dl 0x00002B ; 170.156 79, 0.171
0B1048 25 00 00    0510*   	dl 0x000025 ; 171.563 7A, 0.147
0B104B 1F 00 00    0511*   	dl 0x00001F ; 172.969 7B, 0.122
0B104E 19 00 00    0512*   	dl 0x000019 ; 174.375 7C, 0.098
0B1051 12 00 00    0513*   	dl 0x000012 ; 175.781 7D, 0.074
0B1054 0C 00 00    0514*   	dl 0x00000C ; 177.188 7E, 0.049
0B1057 06 00 00    0515*   	dl 0x000006 ; 178.594 7F, 0.025
0B105A 00 00 00    0516*   	dl 0x000000 ; 180.000 80, 0.000
0B105D FA FF FF    0517*   	dl 0xFFFFFA ; 181.406 81, -0.025
0B1060 F4 FF FF    0518*   	dl 0xFFFFF4 ; 182.813 82, -0.049
0B1063 EE FF FF    0519*   	dl 0xFFFFEE ; 184.219 83, -0.074
0B1066 E7 FF FF    0520*   	dl 0xFFFFE7 ; 185.625 84, -0.098
0B1069 E1 FF FF    0521*   	dl 0xFFFFE1 ; 187.031 85, -0.122
0B106C DB FF FF    0522*   	dl 0xFFFFDB ; 188.438 86, -0.147
0B106F D5 FF FF    0523*   	dl 0xFFFFD5 ; 189.844 87, -0.171
0B1072 CF FF FF    0524*   	dl 0xFFFFCF ; 191.250 88, -0.195
0B1075 C8 FF FF    0525*   	dl 0xFFFFC8 ; 192.656 89, -0.219
0B1078 C2 FF FF    0526*   	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B107B BC FF FF    0527*   	dl 0xFFFFBC ; 195.469 8B, -0.267
0B107E B6 FF FF    0528*   	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B1081 B0 FF FF    0529*   	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B1084 AA FF FF    0530*   	dl 0xFFFFAA ; 199.688 8E, -0.337
0B1087 A4 FF FF    0531*   	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B108A 9F FF FF    0532*   	dl 0xFFFF9F ; 202.500 90, -0.383
0B108D 99 FF FF    0533*   	dl 0xFFFF99 ; 203.906 91, -0.405
0B1090 93 FF FF    0534*   	dl 0xFFFF93 ; 205.313 92, -0.428
0B1093 8D FF FF    0535*   	dl 0xFFFF8D ; 206.719 93, -0.450
0B1096 88 FF FF    0536*   	dl 0xFFFF88 ; 208.125 94, -0.471
0B1099 82 FF FF    0537*   	dl 0xFFFF82 ; 209.531 95, -0.493
0B109C 7D FF FF    0538*   	dl 0xFFFF7D ; 210.938 96, -0.514
0B109F 78 FF FF    0539*   	dl 0xFFFF78 ; 212.344 97, -0.535
0B10A2 72 FF FF    0540*   	dl 0xFFFF72 ; 213.750 98, -0.556
0B10A5 6D FF FF    0541*   	dl 0xFFFF6D ; 215.156 99, -0.576
0B10A8 68 FF FF    0542*   	dl 0xFFFF68 ; 216.563 9A, -0.596
0B10AB 63 FF FF    0543*   	dl 0xFFFF63 ; 217.969 9B, -0.615
0B10AE 5E FF FF    0544*   	dl 0xFFFF5E ; 219.375 9C, -0.634
0B10B1 59 FF FF    0545*   	dl 0xFFFF59 ; 220.781 9D, -0.653
0B10B4 55 FF FF    0546*   	dl 0xFFFF55 ; 222.188 9E, -0.672
0B10B7 50 FF FF    0547*   	dl 0xFFFF50 ; 223.594 9F, -0.690
0B10BA 4B FF FF    0548*   	dl 0xFFFF4B ; 225.000 A0, -0.707
0B10BD 47 FF FF    0549*   	dl 0xFFFF47 ; 226.406 A1, -0.724
0B10C0 43 FF FF    0550*   	dl 0xFFFF43 ; 227.813 A2, -0.741
0B10C3 3F FF FF    0551*   	dl 0xFFFF3F ; 229.219 A3, -0.757
0B10C6 3B FF FF    0552*   	dl 0xFFFF3B ; 230.625 A4, -0.773
0B10C9 37 FF FF    0553*   	dl 0xFFFF37 ; 232.031 A5, -0.788
0B10CC 33 FF FF    0554*   	dl 0xFFFF33 ; 233.438 A6, -0.803
0B10CF 2F FF FF    0555*   	dl 0xFFFF2F ; 234.844 A7, -0.818
0B10D2 2C FF FF    0556*   	dl 0xFFFF2C ; 236.250 A8, -0.831
0B10D5 28 FF FF    0557*   	dl 0xFFFF28 ; 237.656 A9, -0.845
0B10D8 25 FF FF    0558*   	dl 0xFFFF25 ; 239.063 AA, -0.858
0B10DB 22 FF FF    0559*   	dl 0xFFFF22 ; 240.469 AB, -0.870
0B10DE 1F FF FF    0560*   	dl 0xFFFF1F ; 241.875 AC, -0.882
0B10E1 1C FF FF    0561*   	dl 0xFFFF1C ; 243.281 AD, -0.893
0B10E4 19 FF FF    0562*   	dl 0xFFFF19 ; 244.688 AE, -0.904
0B10E7 16 FF FF    0563*   	dl 0xFFFF16 ; 246.094 AF, -0.914
0B10EA 14 FF FF    0564*   	dl 0xFFFF14 ; 247.500 B0, -0.924
0B10ED 12 FF FF    0565*   	dl 0xFFFF12 ; 248.906 B1, -0.933
0B10F0 0F FF FF    0566*   	dl 0xFFFF0F ; 250.313 B2, -0.942
0B10F3 0D FF FF    0567*   	dl 0xFFFF0D ; 251.719 B3, -0.950
0B10F6 0C FF FF    0568*   	dl 0xFFFF0C ; 253.125 B4, -0.957
0B10F9 0A FF FF    0569*   	dl 0xFFFF0A ; 254.531 B5, -0.964
0B10FC 08 FF FF    0570*   	dl 0xFFFF08 ; 255.938 B6, -0.970
0B10FF 07 FF FF    0571*   	dl 0xFFFF07 ; 257.344 B7, -0.976
0B1102 05 FF FF    0572*   	dl 0xFFFF05 ; 258.750 B8, -0.981
0B1105 04 FF FF    0573*   	dl 0xFFFF04 ; 260.156 B9, -0.985
0B1108 03 FF FF    0574*   	dl 0xFFFF03 ; 261.563 BA, -0.989
0B110B 02 FF FF    0575*   	dl 0xFFFF02 ; 262.969 BB, -0.992
0B110E 02 FF FF    0576*   	dl 0xFFFF02 ; 264.375 BC, -0.995
0B1111 01 FF FF    0577*   	dl 0xFFFF01 ; 265.781 BD, -0.997
0B1114 01 FF FF    0578*   	dl 0xFFFF01 ; 267.188 BE, -0.999
0B1117 01 FF FF    0579*   	dl 0xFFFF01 ; 268.594 BF, -1.000
0B111A 00 FF FF    0580*   	dl 0xFFFF00 ; 270.000 C0, -1.000
0B111D 01 FF FF    0581*   	dl 0xFFFF01 ; 271.406 C1, -1.000
0B1120 01 FF FF    0582*   	dl 0xFFFF01 ; 272.813 C2, -0.999
0B1123 01 FF FF    0583*   	dl 0xFFFF01 ; 274.219 C3, -0.997
0B1126 02 FF FF    0584*   	dl 0xFFFF02 ; 275.625 C4, -0.995
0B1129 02 FF FF    0585*   	dl 0xFFFF02 ; 277.031 C5, -0.992
0B112C 03 FF FF    0586*   	dl 0xFFFF03 ; 278.438 C6, -0.989
0B112F 04 FF FF    0587*   	dl 0xFFFF04 ; 279.844 C7, -0.985
0B1132 05 FF FF    0588*   	dl 0xFFFF05 ; 281.250 C8, -0.981
0B1135 07 FF FF    0589*   	dl 0xFFFF07 ; 282.656 C9, -0.976
0B1138 08 FF FF    0590*   	dl 0xFFFF08 ; 284.063 CA, -0.970
0B113B 0A FF FF    0591*   	dl 0xFFFF0A ; 285.469 CB, -0.964
0B113E 0C FF FF    0592*   	dl 0xFFFF0C ; 286.875 CC, -0.957
0B1141 0D FF FF    0593*   	dl 0xFFFF0D ; 288.281 CD, -0.950
0B1144 0F FF FF    0594*   	dl 0xFFFF0F ; 289.688 CE, -0.942
0B1147 12 FF FF    0595*   	dl 0xFFFF12 ; 291.094 CF, -0.933
0B114A 14 FF FF    0596*   	dl 0xFFFF14 ; 292.500 D0, -0.924
0B114D 16 FF FF    0597*   	dl 0xFFFF16 ; 293.906 D1, -0.914
0B1150 19 FF FF    0598*   	dl 0xFFFF19 ; 295.313 D2, -0.904
0B1153 1C FF FF    0599*   	dl 0xFFFF1C ; 296.719 D3, -0.893
0B1156 1F FF FF    0600*   	dl 0xFFFF1F ; 298.125 D4, -0.882
0B1159 22 FF FF    0601*   	dl 0xFFFF22 ; 299.531 D5, -0.870
0B115C 25 FF FF    0602*   	dl 0xFFFF25 ; 300.938 D6, -0.858
0B115F 28 FF FF    0603*   	dl 0xFFFF28 ; 302.344 D7, -0.845
0B1162 2C FF FF    0604*   	dl 0xFFFF2C ; 303.750 D8, -0.831
0B1165 2F FF FF    0605*   	dl 0xFFFF2F ; 305.156 D9, -0.818
0B1168 33 FF FF    0606*   	dl 0xFFFF33 ; 306.563 DA, -0.803
0B116B 37 FF FF    0607*   	dl 0xFFFF37 ; 307.969 DB, -0.788
0B116E 3B FF FF    0608*   	dl 0xFFFF3B ; 309.375 DC, -0.773
0B1171 3F FF FF    0609*   	dl 0xFFFF3F ; 310.781 DD, -0.757
0B1174 43 FF FF    0610*   	dl 0xFFFF43 ; 312.188 DE, -0.741
0B1177 47 FF FF    0611*   	dl 0xFFFF47 ; 313.594 DF, -0.724
0B117A 4B FF FF    0612*   	dl 0xFFFF4B ; 315.000 E0, -0.707
0B117D 50 FF FF    0613*   	dl 0xFFFF50 ; 316.406 E1, -0.690
0B1180 55 FF FF    0614*   	dl 0xFFFF55 ; 317.813 E2, -0.672
0B1183 59 FF FF    0615*   	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1186 5E FF FF    0616*   	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1189 63 FF FF    0617*   	dl 0xFFFF63 ; 322.031 E5, -0.615
0B118C 68 FF FF    0618*   	dl 0xFFFF68 ; 323.438 E6, -0.596
0B118F 6D FF FF    0619*   	dl 0xFFFF6D ; 324.844 E7, -0.576
0B1192 72 FF FF    0620*   	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1195 78 FF FF    0621*   	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1198 7D FF FF    0622*   	dl 0xFFFF7D ; 329.063 EA, -0.514
0B119B 82 FF FF    0623*   	dl 0xFFFF82 ; 330.469 EB, -0.493
0B119E 88 FF FF    0624*   	dl 0xFFFF88 ; 331.875 EC, -0.471
0B11A1 8D FF FF    0625*   	dl 0xFFFF8D ; 333.281 ED, -0.450
0B11A4 93 FF FF    0626*   	dl 0xFFFF93 ; 334.688 EE, -0.428
0B11A7 99 FF FF    0627*   	dl 0xFFFF99 ; 336.094 EF, -0.405
0B11AA 9F FF FF    0628*   	dl 0xFFFF9F ; 337.500 F0, -0.383
0B11AD A4 FF FF    0629*   	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B11B0 AA FF FF    0630*   	dl 0xFFFFAA ; 340.313 F2, -0.337
0B11B3 B0 FF FF    0631*   	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B11B6 B6 FF FF    0632*   	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B11B9 BC FF FF    0633*   	dl 0xFFFFBC ; 344.531 F5, -0.267
0B11BC C2 FF FF    0634*   	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B11BF C8 FF FF    0635*   	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B11C2 CF FF FF    0636*   	dl 0xFFFFCF ; 348.750 F8, -0.195
0B11C5 D5 FF FF    0637*   	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B11C8 DB FF FF    0638*   	dl 0xFFFFDB ; 351.563 FA, -0.147
0B11CB E1 FF FF    0639*   	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B11CE E7 FF FF    0640*   	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B11D1 EE FF FF    0641*   	dl 0xFFFFEE ; 355.781 FD, -0.074
0B11D4 F4 FF FF    0642*   	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B11D7 FA FF FF    0643*   	dl 0xFFFFFA ; 358.594 FF, -0.025
0B11DA 00 00 00    0644*   	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B11DD             0645*   
0B11DD             0646*   sin_lut_816:
0B11DD 00 00 00 48 0647*       dl 0x000000,0x000648 ; 00 000.000 0.000
       06 00       
0B11E3 48 06 00 48 0648*       dl 0x000648,0x000648 ; 01 001.406 0.025
       06 00       
0B11E9 90 0C 00 45 0649*       dl 0x000C90,0x000645 ; 02 002.813 0.049
       06 00       
0B11EF D5 12 00 42 0650*       dl 0x0012D5,0x000642 ; 03 004.219 0.074
       06 00       
0B11F5 17 19 00 3E 0651*       dl 0x001917,0x00063E ; 04 005.625 0.098
       06 00       
0B11FB 56 1F 00 3A 0652*       dl 0x001F56,0x00063A ; 05 007.031 0.122
       06 00       
0B1201 90 25 00 33 0653*       dl 0x002590,0x000633 ; 06 008.438 0.147
       06 00       
0B1207 C4 2B 00 2C 0654*       dl 0x002BC4,0x00062C ; 07 009.844 0.171
       06 00       
0B120D F1 31 00 25 0655*       dl 0x0031F1,0x000625 ; 08 011.250 0.195
       06 00       
0B1213 16 38 00 1D 0656*       dl 0x003816,0x00061D ; 09 012.656 0.219
       06 00       
0B1219 34 3E 00 13 0657*       dl 0x003E34,0x000613 ; 0A 014.063 0.243
       06 00       
0B121F 47 44 00 08 0658*       dl 0x004447,0x000608 ; 0B 015.469 0.267
       06 00       
0B1225 50 4A 00 FD 0659*       dl 0x004A50,0x0005FD ; 0C 016.875 0.290
       05 00       
0B122B 4D 50 00 F1 0660*       dl 0x00504D,0x0005F1 ; 0D 018.281 0.314
       05 00       
0B1231 3E 56 00 E3 0661*       dl 0x00563E,0x0005E3 ; 0E 019.688 0.337
       05 00       
0B1237 22 5C 00 D5 0662*       dl 0x005C22,0x0005D5 ; 0F 021.094 0.360
       05 00       
0B123D F7 61 00 C6 0663*       dl 0x0061F7,0x0005C6 ; 10 022.500 0.383
       05 00       
0B1243 BD 67 00 B7 0664*       dl 0x0067BD,0x0005B7 ; 11 023.906 0.405
       05 00       
0B1249 74 6D 00 A5 0665*       dl 0x006D74,0x0005A5 ; 12 025.313 0.428
       05 00       
0B124F 19 73 00 93 0666*       dl 0x007319,0x000593 ; 13 026.719 0.450
       05 00       
0B1255 AD 78 00 80 0667*       dl 0x0078AD,0x000580 ; 14 028.125 0.471
       05 00       
0B125B 2E 7E 00 6E 0668*       dl 0x007E2E,0x00056E ; 15 029.531 0.493
       05 00       
0B1261 9C 83 00 59 0669*       dl 0x00839C,0x000559 ; 16 030.938 0.514
       05 00       
0B1267 F5 88 00 44 0670*       dl 0x0088F5,0x000544 ; 17 032.344 0.535
       05 00       
0B126D 39 8E 00 2E 0671*       dl 0x008E39,0x00052E ; 18 033.750 0.556
       05 00       
0B1273 67 93 00 18 0672*       dl 0x009367,0x000518 ; 19 035.156 0.576
       05 00       
0B1279 80 98 00 FF 0673*       dl 0x009880,0x0004FF ; 1A 036.563 0.596
       04 00       
0B127F 80 9D 00 E7 0674*       dl 0x009D80,0x0004E7 ; 1B 037.969 0.615
       04 00       
0B1285 67 A2 00 CE 0675*       dl 0x00A267,0x0004CE ; 1C 039.375 0.634
       04 00       
0B128B 36 A7 00 B5 0676*       dl 0x00A736,0x0004B5 ; 1D 040.781 0.653
       04 00       
0B1291 EB AB 00 9A 0677*       dl 0x00ABEB,0x00049A ; 1E 042.188 0.672
       04 00       
0B1297 85 B0 00 7F 0678*       dl 0x00B085,0x00047F ; 1F 043.594 0.690
       04 00       
0B129D 04 B5 00 63 0679*       dl 0x00B504,0x000463 ; 20 045.000 0.707
       04 00       
0B12A3 68 B9 00 47 0680*       dl 0x00B968,0x000447 ; 21 046.406 0.724
       04 00       
0B12A9 AF BD 00 29 0681*       dl 0x00BDAF,0x000429 ; 22 047.813 0.741
       04 00       
0B12AF D8 C1 00 0B 0682*       dl 0x00C1D8,0x00040B ; 23 049.219 0.757
       04 00       
0B12B5 E4 C5 00 EC 0683*       dl 0x00C5E4,0x0003EC ; 24 050.625 0.773
       03 00       
0B12BB D0 C9 00 CE 0684*       dl 0x00C9D0,0x0003CE ; 25 052.031 0.788
       03 00       
0B12C1 9F CD 00 AE 0685*       dl 0x00CD9F,0x0003AE ; 26 053.438 0.803
       03 00       
0B12C7 4D D1 00 8D 0686*       dl 0x00D14D,0x00038D ; 27 054.844 0.818
       03 00       
0B12CD DB D4 00 6C 0687*       dl 0x00D4DB,0x00036C ; 28 056.250 0.831
       03 00       
0B12D3 48 D8 00 4C 0688*       dl 0x00D848,0x00034C ; 29 057.656 0.845
       03 00       
0B12D9 94 DB 00 29 0689*       dl 0x00DB94,0x000329 ; 2A 059.063 0.858
       03 00       
0B12DF BE DE 00 07 0690*       dl 0x00DEBE,0x000307 ; 2B 060.469 0.870
       03 00       
0B12E5 C5 E1 00 E4 0691*       dl 0x00E1C5,0x0002E4 ; 2C 061.875 0.882
       02 00       
0B12EB AA E4 00 C1 0692*       dl 0x00E4AA,0x0002C1 ; 2D 063.281 0.893
       02 00       
0B12F1 6C E7 00 9D 0693*       dl 0x00E76C,0x00029D ; 2E 064.688 0.904
       02 00       
0B12F7 09 EA 00 79 0694*       dl 0x00EA09,0x000279 ; 2F 066.094 0.914
       02 00       
0B12FD 83 EC 00 55 0695*       dl 0x00EC83,0x000255 ; 30 067.500 0.924
       02 00       
0B1303 D8 EE 00 30 0696*       dl 0x00EED8,0x000230 ; 31 068.906 0.933
       02 00       
0B1309 09 F1 00 0B 0697*       dl 0x00F109,0x00020B ; 32 070.313 0.942
       02 00       
0B130F 14 F3 00 E5 0698*       dl 0x00F314,0x0001E5 ; 33 071.719 0.950
       01 00       
0B1315 FA F4 00 BF 0699*       dl 0x00F4FA,0x0001BF ; 34 073.125 0.957
       01 00       
0B131B B9 F6 00 9A 0700*       dl 0x00F6B9,0x00019A ; 35 074.531 0.964
       01 00       
0B1321 54 F8 00 73 0701*       dl 0x00F854,0x000173 ; 36 075.938 0.970
       01 00       
0B1327 C7 F9 00 4D 0702*       dl 0x00F9C7,0x00014D ; 37 077.344 0.976
       01 00       
0B132D 14 FB 00 26 0703*       dl 0x00FB14,0x000126 ; 38 078.750 0.981
       01 00       
0B1333 3B FC 00 FF 0704*       dl 0x00FC3B,0x0000FF ; 39 080.156 0.985
       00 00       
0B1339 3A FD 00 D8 0705*       dl 0x00FD3A,0x0000D8 ; 3A 081.563 0.989
       00 00       
0B133F 13 FE 00 B1 0706*       dl 0x00FE13,0x0000B1 ; 3B 082.969 0.992
       00 00       
0B1345 C4 FE 00 89 0707*       dl 0x00FEC4,0x000089 ; 3C 084.375 0.995
       00 00       
0B134B 4E FF 00 62 0708*       dl 0x00FF4E,0x000062 ; 3D 085.781 0.997
       00 00       
0B1351 B1 FF 00 3B 0709*       dl 0x00FFB1,0x00003B ; 3E 087.188 0.999
       00 00       
0B1357 EC FF 00 13 0710*       dl 0x00FFEC,0x000013 ; 3F 088.594 1.000
       00 00       
0B135D 00 00 01 EC 0711*       dl 0x010000,0xFFFFEC ; 40 090.000 1.000
       FF FF       
0B1363 EC FF 00 C4 0712*       dl 0x00FFEC,0xFFFFC4 ; 41 091.406 1.000
       FF FF       
0B1369 B1 FF 00 9D 0713*       dl 0x00FFB1,0xFFFF9D ; 42 092.813 0.999
       FF FF       
0B136F 4E FF 00 76 0714*       dl 0x00FF4E,0xFFFF76 ; 43 094.219 0.997
       FF FF       
0B1375 C4 FE 00 4E 0715*       dl 0x00FEC4,0xFFFF4E ; 44 095.625 0.995
       FF FF       
0B137B 13 FE 00 27 0716*       dl 0x00FE13,0xFFFF27 ; 45 097.031 0.992
       FF FF       
0B1381 3A FD 00 00 0717*       dl 0x00FD3A,0xFFFF00 ; 46 098.438 0.989
       FF FF       
0B1387 3B FC 00 D9 0718*       dl 0x00FC3B,0xFFFED9 ; 47 099.844 0.985
       FE FF       
0B138D 14 FB 00 B2 0719*       dl 0x00FB14,0xFFFEB2 ; 48 101.250 0.981
       FE FF       
0B1393 C7 F9 00 8C 0720*       dl 0x00F9C7,0xFFFE8C ; 49 102.656 0.976
       FE FF       
0B1399 53 F8 00 66 0721*       dl 0x00F853,0xFFFE66 ; 4A 104.063 0.970
       FE FF       
0B139F B9 F6 00 40 0722*       dl 0x00F6B9,0xFFFE40 ; 4B 105.469 0.964
       FE FF       
0B13A5 FA F4 00 1A 0723*       dl 0x00F4FA,0xFFFE1A ; 4C 106.875 0.957
       FE FF       
0B13AB 14 F3 00 F4 0724*       dl 0x00F314,0xFFFDF4 ; 4D 108.281 0.950
       FD FF       
0B13B1 08 F1 00 CF 0725*       dl 0x00F108,0xFFFDCF ; 4E 109.688 0.942
       FD FF       
0B13B7 D8 EE 00 AA 0726*       dl 0x00EED8,0xFFFDAA ; 4F 111.094 0.933
       FD FF       
0B13BD 83 EC 00 86 0727*       dl 0x00EC83,0xFFFD86 ; 50 112.500 0.924
       FD FF       
0B13C3 09 EA 00 61 0728*       dl 0x00EA09,0xFFFD61 ; 51 113.906 0.914
       FD FF       
0B13C9 6B E7 00 3E 0729*       dl 0x00E76B,0xFFFD3E ; 52 115.313 0.904
       FD FF       
0B13CF AA E4 00 1B 0730*       dl 0x00E4AA,0xFFFD1B ; 53 116.719 0.893
       FD FF       
0B13D5 C5 E1 00 F8 0731*       dl 0x00E1C5,0xFFFCF8 ; 54 118.125 0.882
       FC FF       
0B13DB BE DE 00 D5 0732*       dl 0x00DEBE,0xFFFCD5 ; 55 119.531 0.870
       FC FF       
0B13E1 93 DB 00 B4 0733*       dl 0x00DB93,0xFFFCB4 ; 56 120.938 0.858
       FC FF       
0B13E7 48 D8 00 93 0734*       dl 0x00D848,0xFFFC93 ; 57 122.344 0.845
       FC FF       
0B13ED DB D4 00 72 0735*       dl 0x00D4DB,0xFFFC72 ; 58 123.750 0.831
       FC FF       
0B13F3 4D D1 00 51 0736*       dl 0x00D14D,0xFFFC51 ; 59 125.156 0.818
       FC FF       
0B13F9 9E CD 00 32 0737*       dl 0x00CD9E,0xFFFC32 ; 5A 126.563 0.803
       FC FF       
0B13FF D0 C9 00 13 0738*       dl 0x00C9D0,0xFFFC13 ; 5B 127.969 0.788
       FC FF       
0B1405 E4 C5 00 F4 0739*       dl 0x00C5E4,0xFFFBF4 ; 5C 129.375 0.773
       FB FF       
0B140B D8 C1 00 D5 0740*       dl 0x00C1D8,0xFFFBD5 ; 5D 130.781 0.757
       FB FF       
0B1411 AE BD 00 B9 0741*       dl 0x00BDAE,0xFFFBB9 ; 5E 132.188 0.741
       FB FF       
0B1417 68 B9 00 9C 0742*       dl 0x00B968,0xFFFB9C ; 5F 133.594 0.724
       FB FF       
0B141D 04 B5 00 80 0743*       dl 0x00B504,0xFFFB80 ; 60 135.000 0.707
       FB FF       
0B1423 85 B0 00 64 0744*       dl 0x00B085,0xFFFB64 ; 61 136.406 0.690
       FB FF       
0B1429 EA AB 00 4B 0745*       dl 0x00ABEA,0xFFFB4B ; 62 137.813 0.672
       FB FF       
0B142F 36 A7 00 31 0746*       dl 0x00A736,0xFFFB31 ; 63 139.219 0.653
       FB FF       
0B1435 67 A2 00 18 0747*       dl 0x00A267,0xFFFB18 ; 64 140.625 0.634
       FB FF       
0B143B 80 9D 00 FF 0748*       dl 0x009D80,0xFFFAFF ; 65 142.031 0.615
       FA FF       
0B1441 7F 98 00 E8 0749*       dl 0x00987F,0xFFFAE8 ; 66 143.438 0.596
       FA FF       
0B1447 67 93 00 D1 0750*       dl 0x009367,0xFFFAD1 ; 67 144.844 0.576
       FA FF       
0B144D 39 8E 00 BB 0751*       dl 0x008E39,0xFFFABB ; 68 146.250 0.556
       FA FF       
0B1453 F5 88 00 A5 0752*       dl 0x0088F5,0xFFFAA5 ; 69 147.656 0.535
       FA FF       
0B1459 9B 83 00 92 0753*       dl 0x00839B,0xFFFA92 ; 6A 149.063 0.514
       FA FF       
0B145F 2E 7E 00 7F 0754*       dl 0x007E2E,0xFFFA7F ; 6B 150.469 0.493
       FA FF       
0B1465 AD 78 00 6C 0755*       dl 0x0078AD,0xFFFA6C ; 6C 151.875 0.471
       FA FF       
0B146B 19 73 00 59 0756*       dl 0x007319,0xFFFA59 ; 6D 153.281 0.450
       FA FF       
0B1471 73 6D 00 49 0757*       dl 0x006D73,0xFFFA49 ; 6E 154.688 0.428
       FA FF       
0B1477 BD 67 00 39 0758*       dl 0x0067BD,0xFFFA39 ; 6F 156.094 0.405
       FA FF       
0B147D F7 61 00 2A 0759*       dl 0x0061F7,0xFFFA2A ; 70 157.500 0.383
       FA FF       
0B1483 22 5C 00 1B 0760*       dl 0x005C22,0xFFFA1B ; 71 158.906 0.360
       FA FF       
0B1489 3D 56 00 0F 0761*       dl 0x00563D,0xFFFA0F ; 72 160.313 0.337
       FA FF       
0B148F 4D 50 00 02 0762*       dl 0x00504D,0xFFFA02 ; 73 161.719 0.314
       FA FF       
0B1495 50 4A 00 F7 0763*       dl 0x004A50,0xFFF9F7 ; 74 163.125 0.290
       F9 FF       
0B149B 47 44 00 EB 0764*       dl 0x004447,0xFFF9EB ; 75 164.531 0.267
       F9 FF       
0B14A1 33 3E 00 E3 0765*       dl 0x003E33,0xFFF9E3 ; 76 165.938 0.243
       F9 FF       
0B14A7 16 38 00 DA 0766*       dl 0x003816,0xFFF9DA ; 77 167.344 0.219
       F9 FF       
0B14AD F1 31 00 D3 0767*       dl 0x0031F1,0xFFF9D3 ; 78 168.750 0.195
       F9 FF       
0B14B3 C4 2B 00 CB 0768*       dl 0x002BC4,0xFFF9CB ; 79 170.156 0.171
       F9 FF       
0B14B9 8F 25 00 C6 0769*       dl 0x00258F,0xFFF9C6 ; 7A 171.563 0.147
       F9 FF       
0B14BF 56 1F 00 C1 0770*       dl 0x001F56,0xFFF9C1 ; 7B 172.969 0.122
       F9 FF       
0B14C5 17 19 00 BD 0771*       dl 0x001917,0xFFF9BD ; 7C 174.375 0.098
       F9 FF       
0B14CB D5 12 00 B9 0772*       dl 0x0012D5,0xFFF9B9 ; 7D 175.781 0.074
       F9 FF       
0B14D1 8F 0C 00 B8 0773*       dl 0x000C8F,0xFFF9B8 ; 7E 177.188 0.049
       F9 FF       
0B14D7 48 06 00 B7 0774*       dl 0x000648,0xFFF9B7 ; 7F 178.594 0.025
       F9 FF       
0B14DD 00 00 00 B7 0775*       dl 0x000000,0xFFF9B7 ; 80 180.000 0.000
       F9 FF       
0B14E3 B8 F9 FF B7 0776*       dl 0xFFF9B8,0xFFF9B7 ; 81 181.406 -0.025
       F9 FF       
0B14E9 70 F3 FF BA 0777*       dl 0xFFF370,0xFFF9BA ; 82 182.813 -0.049
       F9 FF       
0B14EF 2B ED FF BD 0778*       dl 0xFFED2B,0xFFF9BD ; 83 184.219 -0.074
       F9 FF       
0B14F5 E9 E6 FF C1 0779*       dl 0xFFE6E9,0xFFF9C1 ; 84 185.625 -0.098
       F9 FF       
0B14FB AA E0 FF C5 0780*       dl 0xFFE0AA,0xFFF9C5 ; 85 187.031 -0.122
       F9 FF       
0B1501 70 DA FF CC 0781*       dl 0xFFDA70,0xFFF9CC ; 86 188.438 -0.147
       F9 FF       
0B1507 3C D4 FF D3 0782*       dl 0xFFD43C,0xFFF9D3 ; 87 189.844 -0.171
       F9 FF       
0B150D 0F CE FF DA 0783*       dl 0xFFCE0F,0xFFF9DA ; 88 191.250 -0.195
       F9 FF       
0B1513 EA C7 FF E2 0784*       dl 0xFFC7EA,0xFFF9E2 ; 89 192.656 -0.219
       F9 FF       
0B1519 CC C1 FF EC 0785*       dl 0xFFC1CC,0xFFF9EC ; 8A 194.063 -0.243
       F9 FF       
0B151F B9 BB FF F7 0786*       dl 0xFFBBB9,0xFFF9F7 ; 8B 195.469 -0.267
       F9 FF       
0B1525 B0 B5 FF 02 0787*       dl 0xFFB5B0,0xFFFA02 ; 8C 196.875 -0.290
       FA FF       
0B152B B3 AF FF 0E 0788*       dl 0xFFAFB3,0xFFFA0E ; 8D 198.281 -0.314
       FA FF       
0B1531 C2 A9 FF 1C 0789*       dl 0xFFA9C2,0xFFFA1C ; 8E 199.688 -0.337
       FA FF       
0B1537 DE A3 FF 2A 0790*       dl 0xFFA3DE,0xFFFA2A ; 8F 201.094 -0.360
       FA FF       
0B153D 09 9E FF 39 0791*       dl 0xFF9E09,0xFFFA39 ; 90 202.500 -0.383
       FA FF       
0B1543 43 98 FF 48 0792*       dl 0xFF9843,0xFFFA48 ; 91 203.906 -0.405
       FA FF       
0B1549 8C 92 FF 5A 0793*       dl 0xFF928C,0xFFFA5A ; 92 205.313 -0.428
       FA FF       
0B154F E7 8C FF 6C 0794*       dl 0xFF8CE7,0xFFFA6C ; 93 206.719 -0.450
       FA FF       
0B1555 53 87 FF 7F 0795*       dl 0xFF8753,0xFFFA7F ; 94 208.125 -0.471
       FA FF       
0B155B D2 81 FF 91 0796*       dl 0xFF81D2,0xFFFA91 ; 95 209.531 -0.493
       FA FF       
0B1561 64 7C FF A6 0797*       dl 0xFF7C64,0xFFFAA6 ; 96 210.938 -0.514
       FA FF       
0B1567 0B 77 FF BB 0798*       dl 0xFF770B,0xFFFABB ; 97 212.344 -0.535
       FA FF       
0B156D C7 71 FF D1 0799*       dl 0xFF71C7,0xFFFAD1 ; 98 213.750 -0.556
       FA FF       
0B1573 99 6C FF E7 0800*       dl 0xFF6C99,0xFFFAE7 ; 99 215.156 -0.576
       FA FF       
0B1579 80 67 FF 00 0801*       dl 0xFF6780,0xFFFB00 ; 9A 216.563 -0.596
       FB FF       
0B157F 80 62 FF 18 0802*       dl 0xFF6280,0xFFFB18 ; 9B 217.969 -0.615
       FB FF       
0B1585 99 5D FF 31 0803*       dl 0xFF5D99,0xFFFB31 ; 9C 219.375 -0.634
       FB FF       
0B158B CA 58 FF 4A 0804*       dl 0xFF58CA,0xFFFB4A ; 9D 220.781 -0.653
       FB FF       
0B1591 15 54 FF 65 0805*       dl 0xFF5415,0xFFFB65 ; 9E 222.188 -0.672
       FB FF       
0B1597 7B 4F FF 80 0806*       dl 0xFF4F7B,0xFFFB80 ; 9F 223.594 -0.690
       FB FF       
0B159D FC 4A FF 9C 0807*       dl 0xFF4AFC,0xFFFB9C ; A0 225.000 -0.707
       FB FF       
0B15A3 98 46 FF B8 0808*       dl 0xFF4698,0xFFFBB8 ; A1 226.406 -0.724
       FB FF       
0B15A9 51 42 FF D6 0809*       dl 0xFF4251,0xFFFBD6 ; A2 227.813 -0.741
       FB FF       
0B15AF 28 3E FF F4 0810*       dl 0xFF3E28,0xFFFBF4 ; A3 229.219 -0.757
       FB FF       
0B15B5 1C 3A FF 13 0811*       dl 0xFF3A1C,0xFFFC13 ; A4 230.625 -0.773
       FC FF       
0B15BB 30 36 FF 31 0812*       dl 0xFF3630,0xFFFC31 ; A5 232.031 -0.788
       FC FF       
0B15C1 61 32 FF 51 0813*       dl 0xFF3261,0xFFFC51 ; A6 233.438 -0.803
       FC FF       
0B15C7 B3 2E FF 72 0814*       dl 0xFF2EB3,0xFFFC72 ; A7 234.844 -0.818
       FC FF       
0B15CD 25 2B FF 93 0815*       dl 0xFF2B25,0xFFFC93 ; A8 236.250 -0.831
       FC FF       
0B15D3 B8 27 FF B3 0816*       dl 0xFF27B8,0xFFFCB3 ; A9 237.656 -0.845
       FC FF       
0B15D9 6C 24 FF D6 0817*       dl 0xFF246C,0xFFFCD6 ; AA 239.063 -0.858
       FC FF       
0B15DF 42 21 FF F8 0818*       dl 0xFF2142,0xFFFCF8 ; AB 240.469 -0.870
       FC FF       
0B15E5 3B 1E FF 1B 0819*       dl 0xFF1E3B,0xFFFD1B ; AC 241.875 -0.882
       FD FF       
0B15EB 56 1B FF 3E 0820*       dl 0xFF1B56,0xFFFD3E ; AD 243.281 -0.893
       FD FF       
0B15F1 94 18 FF 62 0821*       dl 0xFF1894,0xFFFD62 ; AE 244.688 -0.904
       FD FF       
0B15F7 F7 15 FF 86 0822*       dl 0xFF15F7,0xFFFD86 ; AF 246.094 -0.914
       FD FF       
0B15FD 7D 13 FF AA 0823*       dl 0xFF137D,0xFFFDAA ; B0 247.500 -0.924
       FD FF       
0B1603 28 11 FF CF 0824*       dl 0xFF1128,0xFFFDCF ; B1 248.906 -0.933
       FD FF       
0B1609 F7 0E FF F4 0825*       dl 0xFF0EF7,0xFFFDF4 ; B2 250.313 -0.942
       FD FF       
0B160F EC 0C FF 1A 0826*       dl 0xFF0CEC,0xFFFE1A ; B3 251.719 -0.950
       FE FF       
0B1615 06 0B FF 40 0827*       dl 0xFF0B06,0xFFFE40 ; B4 253.125 -0.957
       FE FF       
0B161B 47 09 FF 65 0828*       dl 0xFF0947,0xFFFE65 ; B5 254.531 -0.964
       FE FF       
0B1621 AC 07 FF 8C 0829*       dl 0xFF07AC,0xFFFE8C ; B6 255.938 -0.970
       FE FF       
0B1627 39 06 FF B2 0830*       dl 0xFF0639,0xFFFEB2 ; B7 257.344 -0.976
       FE FF       
0B162D EC 04 FF D9 0831*       dl 0xFF04EC,0xFFFED9 ; B8 258.750 -0.981
       FE FF       
0B1633 C5 03 FF 00 0832*       dl 0xFF03C5,0xFFFF00 ; B9 260.156 -0.985
       FF FF       
0B1639 C6 02 FF 27 0833*       dl 0xFF02C6,0xFFFF27 ; BA 261.563 -0.989
       FF FF       
0B163F ED 01 FF 4E 0834*       dl 0xFF01ED,0xFFFF4E ; BB 262.969 -0.992
       FF FF       
0B1645 3C 01 FF 76 0835*       dl 0xFF013C,0xFFFF76 ; BC 264.375 -0.995
       FF FF       
0B164B B2 00 FF 9D 0836*       dl 0xFF00B2,0xFFFF9D ; BD 265.781 -0.997
       FF FF       
0B1651 4F 00 FF C4 0837*       dl 0xFF004F,0xFFFFC4 ; BE 267.188 -0.999
       FF FF       
0B1657 14 00 FF EC 0838*       dl 0xFF0014,0xFFFFEC ; BF 268.594 -1.000
       FF FF       
0B165D 00 00 FF 13 0839*       dl 0xFF0000,0x000013 ; C0 270.000 -1.000
       00 00       
0B1663 14 00 FF 3B 0840*       dl 0xFF0014,0x00003B ; C1 271.406 -1.000
       00 00       
0B1669 4F 00 FF 62 0841*       dl 0xFF004F,0x000062 ; C2 272.813 -0.999
       00 00       
0B166F B2 00 FF 89 0842*       dl 0xFF00B2,0x000089 ; C3 274.219 -0.997
       00 00       
0B1675 3C 01 FF B1 0843*       dl 0xFF013C,0x0000B1 ; C4 275.625 -0.995
       00 00       
0B167B ED 01 FF D8 0844*       dl 0xFF01ED,0x0000D8 ; C5 277.031 -0.992
       00 00       
0B1681 C6 02 FF FF 0845*       dl 0xFF02C6,0x0000FF ; C6 278.438 -0.989
       00 00       
0B1687 C5 03 FF 26 0846*       dl 0xFF03C5,0x000126 ; C7 279.844 -0.985
       01 00       
0B168D EC 04 FF 4D 0847*       dl 0xFF04EC,0x00014D ; C8 281.250 -0.981
       01 00       
0B1693 39 06 FF 73 0848*       dl 0xFF0639,0x000173 ; C9 282.656 -0.976
       01 00       
0B1699 AD 07 FF 99 0849*       dl 0xFF07AD,0x000199 ; CA 284.063 -0.970
       01 00       
0B169F 47 09 FF BF 0850*       dl 0xFF0947,0x0001BF ; CB 285.469 -0.964
       01 00       
0B16A5 06 0B FF E5 0851*       dl 0xFF0B06,0x0001E5 ; CC 286.875 -0.957
       01 00       
0B16AB EC 0C FF 0B 0852*       dl 0xFF0CEC,0x00020B ; CD 288.281 -0.950
       02 00       
0B16B1 F8 0E FF 30 0853*       dl 0xFF0EF8,0x000230 ; CE 289.688 -0.942
       02 00       
0B16B7 28 11 FF 55 0854*       dl 0xFF1128,0x000255 ; CF 291.094 -0.933
       02 00       
0B16BD 7D 13 FF 79 0855*       dl 0xFF137D,0x000279 ; D0 292.500 -0.924
       02 00       
0B16C3 F7 15 FF 9E 0856*       dl 0xFF15F7,0x00029E ; D1 293.906 -0.914
       02 00       
0B16C9 95 18 FF C1 0857*       dl 0xFF1895,0x0002C1 ; D2 295.313 -0.904
       02 00       
0B16CF 56 1B FF E4 0858*       dl 0xFF1B56,0x0002E4 ; D3 296.719 -0.893
       02 00       
0B16D5 3B 1E FF 07 0859*       dl 0xFF1E3B,0x000307 ; D4 298.125 -0.882
       03 00       
0B16DB 42 21 FF 2A 0860*       dl 0xFF2142,0x00032A ; D5 299.531 -0.870
       03 00       
0B16E1 6D 24 FF 4B 0861*       dl 0xFF246D,0x00034B ; D6 300.938 -0.858
       03 00       
0B16E7 B8 27 FF 6C 0862*       dl 0xFF27B8,0x00036C ; D7 302.344 -0.845
       03 00       
0B16ED 25 2B FF 8D 0863*       dl 0xFF2B25,0x00038D ; D8 303.750 -0.831
       03 00       
0B16F3 B3 2E FF AE 0864*       dl 0xFF2EB3,0x0003AE ; D9 305.156 -0.818
       03 00       
0B16F9 62 32 FF CD 0865*       dl 0xFF3262,0x0003CD ; DA 306.563 -0.803
       03 00       
0B16FF 30 36 FF EC 0866*       dl 0xFF3630,0x0003EC ; DB 307.969 -0.788
       03 00       
0B1705 1C 3A FF 0B 0867*       dl 0xFF3A1C,0x00040B ; DC 309.375 -0.773
       04 00       
0B170B 28 3E FF 2A 0868*       dl 0xFF3E28,0x00042A ; DD 310.781 -0.757
       04 00       
0B1711 52 42 FF 46 0869*       dl 0xFF4252,0x000446 ; DE 312.188 -0.741
       04 00       
0B1717 98 46 FF 63 0870*       dl 0xFF4698,0x000463 ; DF 313.594 -0.724
       04 00       
0B171D FC 4A FF 7F 0871*       dl 0xFF4AFC,0x00047F ; E0 315.000 -0.707
       04 00       
0B1723 7B 4F FF 9B 0872*       dl 0xFF4F7B,0x00049B ; E1 316.406 -0.690
       04 00       
0B1729 16 54 FF B4 0873*       dl 0xFF5416,0x0004B4 ; E2 317.813 -0.672
       04 00       
0B172F CA 58 FF CE 0874*       dl 0xFF58CA,0x0004CE ; E3 319.219 -0.653
       04 00       
0B1735 99 5D FF E7 0875*       dl 0xFF5D99,0x0004E7 ; E4 320.625 -0.634
       04 00       
0B173B 80 62 FF 00 0876*       dl 0xFF6280,0x000500 ; E5 322.031 -0.615
       05 00       
0B1741 81 67 FF 17 0877*       dl 0xFF6781,0x000517 ; E6 323.438 -0.596
       05 00       
0B1747 99 6C FF 2E 0878*       dl 0xFF6C99,0x00052E ; E7 324.844 -0.576
       05 00       
0B174D C7 71 FF 44 0879*       dl 0xFF71C7,0x000544 ; E8 326.250 -0.556
       05 00       
0B1753 0B 77 FF 5A 0880*       dl 0xFF770B,0x00055A ; E9 327.656 -0.535
       05 00       
0B1759 65 7C FF 6D 0881*       dl 0xFF7C65,0x00056D ; EA 329.063 -0.514
       05 00       
0B175F D2 81 FF 80 0882*       dl 0xFF81D2,0x000580 ; EB 330.469 -0.493
       05 00       
0B1765 53 87 FF 93 0883*       dl 0xFF8753,0x000593 ; EC 331.875 -0.471
       05 00       
0B176B E7 8C FF A6 0884*       dl 0xFF8CE7,0x0005A6 ; ED 333.281 -0.450
       05 00       
0B1771 8D 92 FF B6 0885*       dl 0xFF928D,0x0005B6 ; EE 334.688 -0.428
       05 00       
0B1777 43 98 FF C6 0886*       dl 0xFF9843,0x0005C6 ; EF 336.094 -0.405
       05 00       
0B177D 09 9E FF D5 0887*       dl 0xFF9E09,0x0005D5 ; F0 337.500 -0.383
       05 00       
0B1783 DE A3 FF E4 0888*       dl 0xFFA3DE,0x0005E4 ; F1 338.906 -0.360
       05 00       
0B1789 C3 A9 FF F0 0889*       dl 0xFFA9C3,0x0005F0 ; F2 340.313 -0.337
       05 00       
0B178F B3 AF FF FD 0890*       dl 0xFFAFB3,0x0005FD ; F3 341.719 -0.314
       05 00       
0B1795 B0 B5 FF 08 0891*       dl 0xFFB5B0,0x000608 ; F4 343.125 -0.290
       06 00       
0B179B B9 BB FF 14 0892*       dl 0xFFBBB9,0x000614 ; F5 344.531 -0.267
       06 00       
0B17A1 CD C1 FF 1C 0893*       dl 0xFFC1CD,0x00061C ; F6 345.938 -0.243
       06 00       
0B17A7 EA C7 FF 25 0894*       dl 0xFFC7EA,0x000625 ; F7 347.344 -0.219
       06 00       
0B17AD 0F CE FF 2C 0895*       dl 0xFFCE0F,0x00062C ; F8 348.750 -0.195
       06 00       
0B17B3 3C D4 FF 34 0896*       dl 0xFFD43C,0x000634 ; F9 350.156 -0.171
       06 00       
0B17B9 71 DA FF 39 0897*       dl 0xFFDA71,0x000639 ; FA 351.563 -0.147
       06 00       
0B17BF AA E0 FF 3E 0898*       dl 0xFFE0AA,0x00063E ; FB 352.969 -0.122
       06 00       
0B17C5 E9 E6 FF 42 0899*       dl 0xFFE6E9,0x000642 ; FC 354.375 -0.098
       06 00       
0B17CB 2B ED FF 46 0900*       dl 0xFFED2B,0x000646 ; FD 355.781 -0.074
       06 00       
0B17D1 71 F3 FF 47 0901*       dl 0xFFF371,0x000647 ; FE 357.188 -0.049
       06 00       
0B17D7 B8 F9 FF 48 0902*       dl 0xFFF9B8,0x000648 ; FF 358.594 -0.025
       06 00       
0B17DD 00 00 00 48 0903*       dl 0x000000,0x000648 ; 00 360.000 0.000
       06 00       
0B17E3             0904*   
0B17E3             0905*   sin_lut_1212:
0B17E3 00 00 00    0906*       dl 0x000000 ; 00, 00.000, +0.000000
0B17E6 65 00 00    0907*       dl 0x000065 ; 01, 01.406, +0.024541
0B17E9 C9 00 00    0908*       dl 0x0000C9 ; 02, 02.812, +0.049068
0B17EC 2D 01 00    0909*       dl 0x00012D ; 03, 04.219, +0.073565
0B17EF 91 01 00    0910*       dl 0x000191 ; 04, 05.625, +0.098017
0B17F2 F5 01 00    0911*       dl 0x0001F5 ; 05, 07.031, +0.122411
0B17F5 59 02 00    0912*       dl 0x000259 ; 06, 08.438, +0.146730
0B17F8 BC 02 00    0913*       dl 0x0002BC ; 07, 09.844, +0.170962
0B17FB 1F 03 00    0914*       dl 0x00031F ; 08, 11.250, +0.195090
0B17FE 81 03 00    0915*       dl 0x000381 ; 09, 12.656, +0.219101
0B1801 E3 03 00    0916*       dl 0x0003E3 ; 0A, 14.062, +0.242980
0B1804 44 04 00    0917*       dl 0x000444 ; 0B, 15.469, +0.266713
0B1807 A5 04 00    0918*       dl 0x0004A5 ; 0C, 16.875, +0.290285
0B180A 05 05 00    0919*       dl 0x000505 ; 0D, 18.281, +0.313682
0B180D 64 05 00    0920*       dl 0x000564 ; 0E, 19.688, +0.336890
0B1810 C2 05 00    0921*       dl 0x0005C2 ; 0F, 21.094, +0.359895
0B1813 1F 06 00    0922*       dl 0x00061F ; 10, 22.500, +0.382683
0B1816 7C 06 00    0923*       dl 0x00067C ; 11, 23.906, +0.405241
0B1819 D7 06 00    0924*       dl 0x0006D7 ; 12, 25.312, +0.427555
0B181C 32 07 00    0925*       dl 0x000732 ; 13, 26.719, +0.449611
0B181F 8B 07 00    0926*       dl 0x00078B ; 14, 28.125, +0.471397
0B1822 E3 07 00    0927*       dl 0x0007E3 ; 15, 29.531, +0.492898
0B1825 3A 08 00    0928*       dl 0x00083A ; 16, 30.938, +0.514103
0B1828 8F 08 00    0929*       dl 0x00088F ; 17, 32.344, +0.534998
0B182B E4 08 00    0930*       dl 0x0008E4 ; 18, 33.750, +0.555570
0B182E 37 09 00    0931*       dl 0x000937 ; 19, 35.156, +0.575808
0B1831 88 09 00    0932*       dl 0x000988 ; 1A, 36.562, +0.595699
0B1834 D8 09 00    0933*       dl 0x0009D8 ; 1B, 37.969, +0.615232
0B1837 26 0A 00    0934*       dl 0x000A26 ; 1C, 39.375, +0.634393
0B183A 73 0A 00    0935*       dl 0x000A73 ; 1D, 40.781, +0.653173
0B183D BF 0A 00    0936*       dl 0x000ABF ; 1E, 42.188, +0.671559
0B1840 08 0B 00    0937*       dl 0x000B08 ; 1F, 43.594, +0.689541
0B1843 50 0B 00    0938*       dl 0x000B50 ; 20, 45.000, +0.707107
0B1846 97 0B 00    0939*       dl 0x000B97 ; 21, 46.406, +0.724247
0B1849 DB 0B 00    0940*       dl 0x000BDB ; 22, 47.812, +0.740951
0B184C 1E 0C 00    0941*       dl 0x000C1E ; 23, 49.219, +0.757209
0B184F 5E 0C 00    0942*       dl 0x000C5E ; 24, 50.625, +0.773010
0B1852 9D 0C 00    0943*       dl 0x000C9D ; 25, 52.031, +0.788346
0B1855 DA 0C 00    0944*       dl 0x000CDA ; 26, 53.438, +0.803208
0B1858 15 0D 00    0945*       dl 0x000D15 ; 27, 54.844, +0.817585
0B185B 4E 0D 00    0946*       dl 0x000D4E ; 28, 56.250, +0.831470
0B185E 85 0D 00    0947*       dl 0x000D85 ; 29, 57.656, +0.844854
0B1861 B9 0D 00    0948*       dl 0x000DB9 ; 2A, 59.062, +0.857729
0B1864 EC 0D 00    0949*       dl 0x000DEC ; 2B, 60.469, +0.870087
0B1867 1C 0E 00    0950*       dl 0x000E1C ; 2C, 61.875, +0.881921
0B186A 4B 0E 00    0951*       dl 0x000E4B ; 2D, 63.281, +0.893224
0B186D 77 0E 00    0952*       dl 0x000E77 ; 2E, 64.688, +0.903989
0B1870 A1 0E 00    0953*       dl 0x000EA1 ; 2F, 66.094, +0.914210
0B1873 C8 0E 00    0954*       dl 0x000EC8 ; 30, 67.500, +0.923880
0B1876 EE 0E 00    0955*       dl 0x000EEE ; 31, 68.906, +0.932993
0B1879 11 0F 00    0956*       dl 0x000F11 ; 32, 70.312, +0.941544
0B187C 31 0F 00    0957*       dl 0x000F31 ; 33, 71.719, +0.949528
0B187F 50 0F 00    0958*       dl 0x000F50 ; 34, 73.125, +0.956940
0B1882 6C 0F 00    0959*       dl 0x000F6C ; 35, 74.531, +0.963776
0B1885 85 0F 00    0960*       dl 0x000F85 ; 36, 75.938, +0.970031
0B1888 9C 0F 00    0961*       dl 0x000F9C ; 37, 77.344, +0.975702
0B188B B1 0F 00    0962*       dl 0x000FB1 ; 38, 78.750, +0.980785
0B188E C4 0F 00    0963*       dl 0x000FC4 ; 39, 80.156, +0.985278
0B1891 D4 0F 00    0964*       dl 0x000FD4 ; 3A, 81.562, +0.989177
0B1894 E1 0F 00    0965*       dl 0x000FE1 ; 3B, 82.969, +0.992480
0B1897 EC 0F 00    0966*       dl 0x000FEC ; 3C, 84.375, +0.995185
0B189A F5 0F 00    0967*       dl 0x000FF5 ; 3D, 85.781, +0.997290
0B189D FB 0F 00    0968*       dl 0x000FFB ; 3E, 87.188, +0.998795
0B18A0 FF 0F 00    0969*       dl 0x000FFF ; 3F, 88.594, +0.999699
0B18A3 00 10 00    0970*       dl 0x001000 ; 40, 90.000, +1.000000
0B18A6 FF 0F 00    0971*       dl 0x000FFF ; 41, 91.406, +0.999699
0B18A9 FB 0F 00    0972*       dl 0x000FFB ; 42, 92.812, +0.998795
0B18AC F5 0F 00    0973*       dl 0x000FF5 ; 43, 94.219, +0.997290
0B18AF EC 0F 00    0974*       dl 0x000FEC ; 44, 95.625, +0.995185
0B18B2 E1 0F 00    0975*       dl 0x000FE1 ; 45, 97.031, +0.992480
0B18B5 D4 0F 00    0976*       dl 0x000FD4 ; 46, 98.438, +0.989177
0B18B8 C4 0F 00    0977*       dl 0x000FC4 ; 47, 99.844, +0.985278
0B18BB B1 0F 00    0978*       dl 0x000FB1 ; 48, 101.250, +0.980785
0B18BE 9C 0F 00    0979*       dl 0x000F9C ; 49, 102.656, +0.975702
0B18C1 85 0F 00    0980*       dl 0x000F85 ; 4A, 104.062, +0.970031
0B18C4 6C 0F 00    0981*       dl 0x000F6C ; 4B, 105.469, +0.963776
0B18C7 50 0F 00    0982*       dl 0x000F50 ; 4C, 106.875, +0.956940
0B18CA 31 0F 00    0983*       dl 0x000F31 ; 4D, 108.281, +0.949528
0B18CD 11 0F 00    0984*       dl 0x000F11 ; 4E, 109.688, +0.941544
0B18D0 EE 0E 00    0985*       dl 0x000EEE ; 4F, 111.094, +0.932993
0B18D3 C8 0E 00    0986*       dl 0x000EC8 ; 50, 112.500, +0.923880
0B18D6 A1 0E 00    0987*       dl 0x000EA1 ; 51, 113.906, +0.914210
0B18D9 77 0E 00    0988*       dl 0x000E77 ; 52, 115.312, +0.903989
0B18DC 4B 0E 00    0989*       dl 0x000E4B ; 53, 116.719, +0.893224
0B18DF 1C 0E 00    0990*       dl 0x000E1C ; 54, 118.125, +0.881921
0B18E2 EC 0D 00    0991*       dl 0x000DEC ; 55, 119.531, +0.870087
0B18E5 B9 0D 00    0992*       dl 0x000DB9 ; 56, 120.938, +0.857729
0B18E8 85 0D 00    0993*       dl 0x000D85 ; 57, 122.344, +0.844854
0B18EB 4E 0D 00    0994*       dl 0x000D4E ; 58, 123.750, +0.831470
0B18EE 15 0D 00    0995*       dl 0x000D15 ; 59, 125.156, +0.817585
0B18F1 DA 0C 00    0996*       dl 0x000CDA ; 5A, 126.562, +0.803208
0B18F4 9D 0C 00    0997*       dl 0x000C9D ; 5B, 127.969, +0.788346
0B18F7 5E 0C 00    0998*       dl 0x000C5E ; 5C, 129.375, +0.773010
0B18FA 1E 0C 00    0999*       dl 0x000C1E ; 5D, 130.781, +0.757209
0B18FD DB 0B 00    1000*       dl 0x000BDB ; 5E, 132.188, +0.740951
0B1900 97 0B 00    1001*       dl 0x000B97 ; 5F, 133.594, +0.724247
0B1903 50 0B 00    1002*       dl 0x000B50 ; 60, 135.000, +0.707107
0B1906 08 0B 00    1003*       dl 0x000B08 ; 61, 136.406, +0.689541
0B1909 BF 0A 00    1004*       dl 0x000ABF ; 62, 137.812, +0.671559
0B190C 73 0A 00    1005*       dl 0x000A73 ; 63, 139.219, +0.653173
0B190F 26 0A 00    1006*       dl 0x000A26 ; 64, 140.625, +0.634393
0B1912 D8 09 00    1007*       dl 0x0009D8 ; 65, 142.031, +0.615232
0B1915 88 09 00    1008*       dl 0x000988 ; 66, 143.438, +0.595699
0B1918 37 09 00    1009*       dl 0x000937 ; 67, 144.844, +0.575808
0B191B E4 08 00    1010*       dl 0x0008E4 ; 68, 146.250, +0.555570
0B191E 8F 08 00    1011*       dl 0x00088F ; 69, 147.656, +0.534998
0B1921 3A 08 00    1012*       dl 0x00083A ; 6A, 149.062, +0.514103
0B1924 E3 07 00    1013*       dl 0x0007E3 ; 6B, 150.469, +0.492898
0B1927 8B 07 00    1014*       dl 0x00078B ; 6C, 151.875, +0.471397
0B192A 32 07 00    1015*       dl 0x000732 ; 6D, 153.281, +0.449611
0B192D D7 06 00    1016*       dl 0x0006D7 ; 6E, 154.688, +0.427555
0B1930 7C 06 00    1017*       dl 0x00067C ; 6F, 156.094, +0.405241
0B1933 1F 06 00    1018*       dl 0x00061F ; 70, 157.500, +0.382683
0B1936 C2 05 00    1019*       dl 0x0005C2 ; 71, 158.906, +0.359895
0B1939 64 05 00    1020*       dl 0x000564 ; 72, 160.312, +0.336890
0B193C 05 05 00    1021*       dl 0x000505 ; 73, 161.719, +0.313682
0B193F A5 04 00    1022*       dl 0x0004A5 ; 74, 163.125, +0.290285
0B1942 44 04 00    1023*       dl 0x000444 ; 75, 164.531, +0.266713
0B1945 E3 03 00    1024*       dl 0x0003E3 ; 76, 165.938, +0.242980
0B1948 81 03 00    1025*       dl 0x000381 ; 77, 167.344, +0.219101
0B194B 1F 03 00    1026*       dl 0x00031F ; 78, 168.750, +0.195090
0B194E BC 02 00    1027*       dl 0x0002BC ; 79, 170.156, +0.170962
0B1951 59 02 00    1028*       dl 0x000259 ; 7A, 171.562, +0.146730
0B1954 F5 01 00    1029*       dl 0x0001F5 ; 7B, 172.969, +0.122411
0B1957 91 01 00    1030*       dl 0x000191 ; 7C, 174.375, +0.098017
0B195A 2D 01 00    1031*       dl 0x00012D ; 7D, 175.781, +0.073565
0B195D C9 00 00    1032*       dl 0x0000C9 ; 7E, 177.188, +0.049068
0B1960 65 00 00    1033*       dl 0x000065 ; 7F, 178.594, +0.024541
0B1963 00 00 00    1034*       dl 0x000000 ; 80, 180.000, +0.000000
0B1966 9B FF FF    1035*       dl 0xFFFF9B ; 81, 181.406, -0.024541
0B1969 37 FF FF    1036*       dl 0xFFFF37 ; 82, 182.812, -0.049068
0B196C D3 FE FF    1037*       dl 0xFFFED3 ; 83, 184.219, -0.073565
0B196F 6F FE FF    1038*       dl 0xFFFE6F ; 84, 185.625, -0.098017
0B1972 0B FE FF    1039*       dl 0xFFFE0B ; 85, 187.031, -0.122411
0B1975 A7 FD FF    1040*       dl 0xFFFDA7 ; 86, 188.438, -0.146730
0B1978 44 FD FF    1041*       dl 0xFFFD44 ; 87, 189.844, -0.170962
0B197B E1 FC FF    1042*       dl 0xFFFCE1 ; 88, 191.250, -0.195090
0B197E 7F FC FF    1043*       dl 0xFFFC7F ; 89, 192.656, -0.219101
0B1981 1D FC FF    1044*       dl 0xFFFC1D ; 8A, 194.062, -0.242980
0B1984 BC FB FF    1045*       dl 0xFFFBBC ; 8B, 195.469, -0.266713
0B1987 5B FB FF    1046*       dl 0xFFFB5B ; 8C, 196.875, -0.290285
0B198A FB FA FF    1047*       dl 0xFFFAFB ; 8D, 198.281, -0.313682
0B198D 9C FA FF    1048*       dl 0xFFFA9C ; 8E, 199.688, -0.336890
0B1990 3E FA FF    1049*       dl 0xFFFA3E ; 8F, 201.094, -0.359895
0B1993 E1 F9 FF    1050*       dl 0xFFF9E1 ; 90, 202.500, -0.382683
0B1996 84 F9 FF    1051*       dl 0xFFF984 ; 91, 203.906, -0.405241
0B1999 29 F9 FF    1052*       dl 0xFFF929 ; 92, 205.312, -0.427555
0B199C CE F8 FF    1053*       dl 0xFFF8CE ; 93, 206.719, -0.449611
0B199F 75 F8 FF    1054*       dl 0xFFF875 ; 94, 208.125, -0.471397
0B19A2 1D F8 FF    1055*       dl 0xFFF81D ; 95, 209.531, -0.492898
0B19A5 C6 F7 FF    1056*       dl 0xFFF7C6 ; 96, 210.938, -0.514103
0B19A8 71 F7 FF    1057*       dl 0xFFF771 ; 97, 212.344, -0.534998
0B19AB 1C F7 FF    1058*       dl 0xFFF71C ; 98, 213.750, -0.555570
0B19AE C9 F6 FF    1059*       dl 0xFFF6C9 ; 99, 215.156, -0.575808
0B19B1 78 F6 FF    1060*       dl 0xFFF678 ; 9A, 216.562, -0.595699
0B19B4 28 F6 FF    1061*       dl 0xFFF628 ; 9B, 217.969, -0.615232
0B19B7 DA F5 FF    1062*       dl 0xFFF5DA ; 9C, 219.375, -0.634393
0B19BA 8D F5 FF    1063*       dl 0xFFF58D ; 9D, 220.781, -0.653173
0B19BD 41 F5 FF    1064*       dl 0xFFF541 ; 9E, 222.188, -0.671559
0B19C0 F8 F4 FF    1065*       dl 0xFFF4F8 ; 9F, 223.594, -0.689541
0B19C3 B0 F4 FF    1066*       dl 0xFFF4B0 ; A0, 225.000, -0.707107
0B19C6 69 F4 FF    1067*       dl 0xFFF469 ; A1, 226.406, -0.724247
0B19C9 25 F4 FF    1068*       dl 0xFFF425 ; A2, 227.812, -0.740951
0B19CC E2 F3 FF    1069*       dl 0xFFF3E2 ; A3, 229.219, -0.757209
0B19CF A2 F3 FF    1070*       dl 0xFFF3A2 ; A4, 230.625, -0.773010
0B19D2 63 F3 FF    1071*       dl 0xFFF363 ; A5, 232.031, -0.788346
0B19D5 26 F3 FF    1072*       dl 0xFFF326 ; A6, 233.438, -0.803208
0B19D8 EB F2 FF    1073*       dl 0xFFF2EB ; A7, 234.844, -0.817585
0B19DB B2 F2 FF    1074*       dl 0xFFF2B2 ; A8, 236.250, -0.831470
0B19DE 7B F2 FF    1075*       dl 0xFFF27B ; A9, 237.656, -0.844854
0B19E1 47 F2 FF    1076*       dl 0xFFF247 ; AA, 239.062, -0.857729
0B19E4 14 F2 FF    1077*       dl 0xFFF214 ; AB, 240.469, -0.870087
0B19E7 E4 F1 FF    1078*       dl 0xFFF1E4 ; AC, 241.875, -0.881921
0B19EA B5 F1 FF    1079*       dl 0xFFF1B5 ; AD, 243.281, -0.893224
0B19ED 89 F1 FF    1080*       dl 0xFFF189 ; AE, 244.688, -0.903989
0B19F0 5F F1 FF    1081*       dl 0xFFF15F ; AF, 246.094, -0.914210
0B19F3 38 F1 FF    1082*       dl 0xFFF138 ; B0, 247.500, -0.923880
0B19F6 12 F1 FF    1083*       dl 0xFFF112 ; B1, 248.906, -0.932993
0B19F9 EF F0 FF    1084*       dl 0xFFF0EF ; B2, 250.312, -0.941544
0B19FC CF F0 FF    1085*       dl 0xFFF0CF ; B3, 251.719, -0.949528
0B19FF B0 F0 FF    1086*       dl 0xFFF0B0 ; B4, 253.125, -0.956940
0B1A02 94 F0 FF    1087*       dl 0xFFF094 ; B5, 254.531, -0.963776
0B1A05 7B F0 FF    1088*       dl 0xFFF07B ; B6, 255.938, -0.970031
0B1A08 64 F0 FF    1089*       dl 0xFFF064 ; B7, 257.344, -0.975702
0B1A0B 4F F0 FF    1090*       dl 0xFFF04F ; B8, 258.750, -0.980785
0B1A0E 3C F0 FF    1091*       dl 0xFFF03C ; B9, 260.156, -0.985278
0B1A11 2C F0 FF    1092*       dl 0xFFF02C ; BA, 261.562, -0.989177
0B1A14 1F F0 FF    1093*       dl 0xFFF01F ; BB, 262.969, -0.992480
0B1A17 14 F0 FF    1094*       dl 0xFFF014 ; BC, 264.375, -0.995185
0B1A1A 0B F0 FF    1095*       dl 0xFFF00B ; BD, 265.781, -0.997290
0B1A1D 05 F0 FF    1096*       dl 0xFFF005 ; BE, 267.188, -0.998795
0B1A20 01 F0 FF    1097*       dl 0xFFF001 ; BF, 268.594, -0.999699
0B1A23 00 F0 FF    1098*       dl 0xFFF000 ; C0, 270.000, -1.000000
0B1A26 01 F0 FF    1099*       dl 0xFFF001 ; C1, 271.406, -0.999699
0B1A29 05 F0 FF    1100*       dl 0xFFF005 ; C2, 272.812, -0.998795
0B1A2C 0B F0 FF    1101*       dl 0xFFF00B ; C3, 274.219, -0.997290
0B1A2F 14 F0 FF    1102*       dl 0xFFF014 ; C4, 275.625, -0.995185
0B1A32 1F F0 FF    1103*       dl 0xFFF01F ; C5, 277.031, -0.992480
0B1A35 2C F0 FF    1104*       dl 0xFFF02C ; C6, 278.438, -0.989177
0B1A38 3C F0 FF    1105*       dl 0xFFF03C ; C7, 279.844, -0.985278
0B1A3B 4F F0 FF    1106*       dl 0xFFF04F ; C8, 281.250, -0.980785
0B1A3E 64 F0 FF    1107*       dl 0xFFF064 ; C9, 282.656, -0.975702
0B1A41 7B F0 FF    1108*       dl 0xFFF07B ; CA, 284.062, -0.970031
0B1A44 94 F0 FF    1109*       dl 0xFFF094 ; CB, 285.469, -0.963776
0B1A47 B0 F0 FF    1110*       dl 0xFFF0B0 ; CC, 286.875, -0.956940
0B1A4A CF F0 FF    1111*       dl 0xFFF0CF ; CD, 288.281, -0.949528
0B1A4D EF F0 FF    1112*       dl 0xFFF0EF ; CE, 289.688, -0.941544
0B1A50 12 F1 FF    1113*       dl 0xFFF112 ; CF, 291.094, -0.932993
0B1A53 38 F1 FF    1114*       dl 0xFFF138 ; D0, 292.500, -0.923880
0B1A56 5F F1 FF    1115*       dl 0xFFF15F ; D1, 293.906, -0.914210
0B1A59 89 F1 FF    1116*       dl 0xFFF189 ; D2, 295.312, -0.903989
0B1A5C B5 F1 FF    1117*       dl 0xFFF1B5 ; D3, 296.719, -0.893224
0B1A5F E4 F1 FF    1118*       dl 0xFFF1E4 ; D4, 298.125, -0.881921
0B1A62 14 F2 FF    1119*       dl 0xFFF214 ; D5, 299.531, -0.870087
0B1A65 47 F2 FF    1120*       dl 0xFFF247 ; D6, 300.938, -0.857729
0B1A68 7B F2 FF    1121*       dl 0xFFF27B ; D7, 302.344, -0.844854
0B1A6B B2 F2 FF    1122*       dl 0xFFF2B2 ; D8, 303.750, -0.831470
0B1A6E EB F2 FF    1123*       dl 0xFFF2EB ; D9, 305.156, -0.817585
0B1A71 26 F3 FF    1124*       dl 0xFFF326 ; DA, 306.562, -0.803208
0B1A74 63 F3 FF    1125*       dl 0xFFF363 ; DB, 307.969, -0.788346
0B1A77 A2 F3 FF    1126*       dl 0xFFF3A2 ; DC, 309.375, -0.773010
0B1A7A E2 F3 FF    1127*       dl 0xFFF3E2 ; DD, 310.781, -0.757209
0B1A7D 25 F4 FF    1128*       dl 0xFFF425 ; DE, 312.188, -0.740951
0B1A80 69 F4 FF    1129*       dl 0xFFF469 ; DF, 313.594, -0.724247
0B1A83 B0 F4 FF    1130*       dl 0xFFF4B0 ; E0, 315.000, -0.707107
0B1A86 F8 F4 FF    1131*       dl 0xFFF4F8 ; E1, 316.406, -0.689541
0B1A89 41 F5 FF    1132*       dl 0xFFF541 ; E2, 317.812, -0.671559
0B1A8C 8D F5 FF    1133*       dl 0xFFF58D ; E3, 319.219, -0.653173
0B1A8F DA F5 FF    1134*       dl 0xFFF5DA ; E4, 320.625, -0.634393
0B1A92 28 F6 FF    1135*       dl 0xFFF628 ; E5, 322.031, -0.615232
0B1A95 78 F6 FF    1136*       dl 0xFFF678 ; E6, 323.438, -0.595699
0B1A98 C9 F6 FF    1137*       dl 0xFFF6C9 ; E7, 324.844, -0.575808
0B1A9B 1C F7 FF    1138*       dl 0xFFF71C ; E8, 326.250, -0.555570
0B1A9E 71 F7 FF    1139*       dl 0xFFF771 ; E9, 327.656, -0.534998
0B1AA1 C6 F7 FF    1140*       dl 0xFFF7C6 ; EA, 329.062, -0.514103
0B1AA4 1D F8 FF    1141*       dl 0xFFF81D ; EB, 330.469, -0.492898
0B1AA7 75 F8 FF    1142*       dl 0xFFF875 ; EC, 331.875, -0.471397
0B1AAA CE F8 FF    1143*       dl 0xFFF8CE ; ED, 333.281, -0.449611
0B1AAD 29 F9 FF    1144*       dl 0xFFF929 ; EE, 334.688, -0.427555
0B1AB0 84 F9 FF    1145*       dl 0xFFF984 ; EF, 336.094, -0.405241
0B1AB3 E1 F9 FF    1146*       dl 0xFFF9E1 ; F0, 337.500, -0.382683
0B1AB6 3E FA FF    1147*       dl 0xFFFA3E ; F1, 338.906, -0.359895
0B1AB9 9C FA FF    1148*       dl 0xFFFA9C ; F2, 340.312, -0.336890
0B1ABC FB FA FF    1149*       dl 0xFFFAFB ; F3, 341.719, -0.313682
0B1ABF 5B FB FF    1150*       dl 0xFFFB5B ; F4, 343.125, -0.290285
0B1AC2 BC FB FF    1151*       dl 0xFFFBBC ; F5, 344.531, -0.266713
0B1AC5 1D FC FF    1152*       dl 0xFFFC1D ; F6, 345.938, -0.242980
0B1AC8 7F FC FF    1153*       dl 0xFFFC7F ; F7, 347.344, -0.219101
0B1ACB E1 FC FF    1154*       dl 0xFFFCE1 ; F8, 348.750, -0.195090
0B1ACE 44 FD FF    1155*       dl 0xFFFD44 ; F9, 350.156, -0.170962
0B1AD1 A7 FD FF    1156*       dl 0xFFFDA7 ; FA, 351.562, -0.146730
0B1AD4 0B FE FF    1157*       dl 0xFFFE0B ; FB, 352.969, -0.122411
0B1AD7 6F FE FF    1158*       dl 0xFFFE6F ; FC, 354.375, -0.098017
0B1ADA D3 FE FF    1159*       dl 0xFFFED3 ; FD, 355.781, -0.073565
0B1ADD 37 FF FF    1160*       dl 0xFFFF37 ; FE, 357.188, -0.049068
0B1AE0 9B FF FF    1161*       dl 0xFFFF9B ; FF, 358.594, -0.024541
0B1AE3             1162*   
0B1AE3             1163*   atan_lut_168:
0B1AE3 00 00 00    1164*   	dl 0x000000 ; 000000, 0.000
0B1AE6 28 00 00    1165*   	dl 0x000028 ; 000001, 0.224
0B1AE9 51 00 00    1166*   	dl 0x000051 ; 000002, 0.448
0B1AEC 7A 00 00    1167*   	dl 0x00007A ; 000003, 0.671
0B1AEF A2 00 00    1168*   	dl 0x0000A2 ; 000004, 0.895
0B1AF2 CB 00 00    1169*   	dl 0x0000CB ; 000005, 1.119
0B1AF5 F4 00 00    1170*   	dl 0x0000F4 ; 000006, 1.343
0B1AF8 1D 01 00    1171*   	dl 0x00011D ; 000007, 1.566
0B1AFB 45 01 00    1172*   	dl 0x000145 ; 000008, 1.790
0B1AFE 6E 01 00    1173*   	dl 0x00016E ; 000009, 2.013
0B1B01 97 01 00    1174*   	dl 0x000197 ; 00000A, 2.237
0B1B04 BF 01 00    1175*   	dl 0x0001BF ; 00000B, 2.460
0B1B07 E8 01 00    1176*   	dl 0x0001E8 ; 00000C, 2.684
0B1B0A 11 02 00    1177*   	dl 0x000211 ; 00000D, 2.907
0B1B0D 39 02 00    1178*   	dl 0x000239 ; 00000E, 3.130
0B1B10 62 02 00    1179*   	dl 0x000262 ; 00000F, 3.353
0B1B13 8B 02 00    1180*   	dl 0x00028B ; 000010, 3.576
0B1B16 B3 02 00    1181*   	dl 0x0002B3 ; 000011, 3.799
0B1B19 DC 02 00    1182*   	dl 0x0002DC ; 000012, 4.022
0B1B1C 04 03 00    1183*   	dl 0x000304 ; 000013, 4.245
0B1B1F 2D 03 00    1184*   	dl 0x00032D ; 000014, 4.467
0B1B22 55 03 00    1185*   	dl 0x000355 ; 000015, 4.690
0B1B25 7E 03 00    1186*   	dl 0x00037E ; 000016, 4.912
0B1B28 A6 03 00    1187*   	dl 0x0003A6 ; 000017, 5.134
0B1B2B CE 03 00    1188*   	dl 0x0003CE ; 000018, 5.356
0B1B2E F7 03 00    1189*   	dl 0x0003F7 ; 000019, 5.578
0B1B31 1F 04 00    1190*   	dl 0x00041F ; 00001A, 5.799
0B1B34 48 04 00    1191*   	dl 0x000448 ; 00001B, 6.021
0B1B37 70 04 00    1192*   	dl 0x000470 ; 00001C, 6.242
0B1B3A 98 04 00    1193*   	dl 0x000498 ; 00001D, 6.463
0B1B3D C0 04 00    1194*   	dl 0x0004C0 ; 00001E, 6.684
0B1B40 E8 04 00    1195*   	dl 0x0004E8 ; 00001F, 6.905
0B1B43 11 05 00    1196*   	dl 0x000511 ; 000020, 7.125
0B1B46 39 05 00    1197*   	dl 0x000539 ; 000021, 7.345
0B1B49 61 05 00    1198*   	dl 0x000561 ; 000022, 7.565
0B1B4C 89 05 00    1199*   	dl 0x000589 ; 000023, 7.785
0B1B4F B1 05 00    1200*   	dl 0x0005B1 ; 000024, 8.005
0B1B52 D9 05 00    1201*   	dl 0x0005D9 ; 000025, 8.224
0B1B55 01 06 00    1202*   	dl 0x000601 ; 000026, 8.443
0B1B58 28 06 00    1203*   	dl 0x000628 ; 000027, 8.662
0B1B5B 50 06 00    1204*   	dl 0x000650 ; 000028, 8.881
0B1B5E 78 06 00    1205*   	dl 0x000678 ; 000029, 9.099
0B1B61 A0 06 00    1206*   	dl 0x0006A0 ; 00002A, 9.317
0B1B64 C7 06 00    1207*   	dl 0x0006C7 ; 00002B, 9.535
0B1B67 EF 06 00    1208*   	dl 0x0006EF ; 00002C, 9.752
0B1B6A 16 07 00    1209*   	dl 0x000716 ; 00002D, 9.970
0B1B6D 3E 07 00    1210*   	dl 0x00073E ; 00002E, 10.187
0B1B70 65 07 00    1211*   	dl 0x000765 ; 00002F, 10.403
0B1B73 8D 07 00    1212*   	dl 0x00078D ; 000030, 10.620
0B1B76 B4 07 00    1213*   	dl 0x0007B4 ; 000031, 10.836
0B1B79 DB 07 00    1214*   	dl 0x0007DB ; 000032, 11.051
0B1B7C 03 08 00    1215*   	dl 0x000803 ; 000033, 11.267
0B1B7F 2A 08 00    1216*   	dl 0x00082A ; 000034, 11.482
0B1B82 51 08 00    1217*   	dl 0x000851 ; 000035, 11.697
0B1B85 78 08 00    1218*   	dl 0x000878 ; 000036, 11.911
0B1B88 9F 08 00    1219*   	dl 0x00089F ; 000037, 12.125
0B1B8B C6 08 00    1220*   	dl 0x0008C6 ; 000038, 12.339
0B1B8E ED 08 00    1221*   	dl 0x0008ED ; 000039, 12.553
0B1B91 13 09 00    1222*   	dl 0x000913 ; 00003A, 12.766
0B1B94 3A 09 00    1223*   	dl 0x00093A ; 00003B, 12.978
0B1B97 61 09 00    1224*   	dl 0x000961 ; 00003C, 13.191
0B1B9A 87 09 00    1225*   	dl 0x000987 ; 00003D, 13.403
0B1B9D AE 09 00    1226*   	dl 0x0009AE ; 00003E, 13.614
0B1BA0 D4 09 00    1227*   	dl 0x0009D4 ; 00003F, 13.825
0B1BA3 FB 09 00    1228*   	dl 0x0009FB ; 000040, 14.036
0B1BA6 21 0A 00    1229*   	dl 0x000A21 ; 000041, 14.247
0B1BA9 47 0A 00    1230*   	dl 0x000A47 ; 000042, 14.457
0B1BAC 6D 0A 00    1231*   	dl 0x000A6D ; 000043, 14.666
0B1BAF 94 0A 00    1232*   	dl 0x000A94 ; 000044, 14.876
0B1BB2 BA 0A 00    1233*   	dl 0x000ABA ; 000045, 15.085
0B1BB5 E0 0A 00    1234*   	dl 0x000AE0 ; 000046, 15.293
0B1BB8 05 0B 00    1235*   	dl 0x000B05 ; 000047, 15.501
0B1BBB 2B 0B 00    1236*   	dl 0x000B2B ; 000048, 15.709
0B1BBE 51 0B 00    1237*   	dl 0x000B51 ; 000049, 15.916
0B1BC1 77 0B 00    1238*   	dl 0x000B77 ; 00004A, 16.123
0B1BC4 9C 0B 00    1239*   	dl 0x000B9C ; 00004B, 16.329
0B1BC7 C2 0B 00    1240*   	dl 0x000BC2 ; 00004C, 16.535
0B1BCA E7 0B 00    1241*   	dl 0x000BE7 ; 00004D, 16.740
0B1BCD 0C 0C 00    1242*   	dl 0x000C0C ; 00004E, 16.945
0B1BD0 32 0C 00    1243*   	dl 0x000C32 ; 00004F, 17.150
0B1BD3 57 0C 00    1244*   	dl 0x000C57 ; 000050, 17.354
0B1BD6 7C 0C 00    1245*   	dl 0x000C7C ; 000051, 17.558
0B1BD9 A1 0C 00    1246*   	dl 0x000CA1 ; 000052, 17.761
0B1BDC C6 0C 00    1247*   	dl 0x000CC6 ; 000053, 17.964
0B1BDF EB 0C 00    1248*   	dl 0x000CEB ; 000054, 18.166
0B1BE2 0F 0D 00    1249*   	dl 0x000D0F ; 000055, 18.368
0B1BE5 34 0D 00    1250*   	dl 0x000D34 ; 000056, 18.569
0B1BE8 58 0D 00    1251*   	dl 0x000D58 ; 000057, 18.770
0B1BEB 7D 0D 00    1252*   	dl 0x000D7D ; 000058, 18.970
0B1BEE A1 0D 00    1253*   	dl 0x000DA1 ; 000059, 19.170
0B1BF1 C6 0D 00    1254*   	dl 0x000DC6 ; 00005A, 19.370
0B1BF4 EA 0D 00    1255*   	dl 0x000DEA ; 00005B, 19.569
0B1BF7 0E 0E 00    1256*   	dl 0x000E0E ; 00005C, 19.767
0B1BFA 32 0E 00    1257*   	dl 0x000E32 ; 00005D, 19.965
0B1BFD 56 0E 00    1258*   	dl 0x000E56 ; 00005E, 20.163
0B1C00 7A 0E 00    1259*   	dl 0x000E7A ; 00005F, 20.360
0B1C03 9E 0E 00    1260*   	dl 0x000E9E ; 000060, 20.556
0B1C06 C1 0E 00    1261*   	dl 0x000EC1 ; 000061, 20.752
0B1C09 E5 0E 00    1262*   	dl 0x000EE5 ; 000062, 20.947
0B1C0C 08 0F 00    1263*   	dl 0x000F08 ; 000063, 21.142
0B1C0F 2C 0F 00    1264*   	dl 0x000F2C ; 000064, 21.337
0B1C12 4F 0F 00    1265*   	dl 0x000F4F ; 000065, 21.531
0B1C15 72 0F 00    1266*   	dl 0x000F72 ; 000066, 21.724
0B1C18 95 0F 00    1267*   	dl 0x000F95 ; 000067, 21.917
0B1C1B B8 0F 00    1268*   	dl 0x000FB8 ; 000068, 22.109
0B1C1E DB 0F 00    1269*   	dl 0x000FDB ; 000069, 22.301
0B1C21 FE 0F 00    1270*   	dl 0x000FFE ; 00006A, 22.493
0B1C24 21 10 00    1271*   	dl 0x001021 ; 00006B, 22.683
0B1C27 44 10 00    1272*   	dl 0x001044 ; 00006C, 22.874
0B1C2A 66 10 00    1273*   	dl 0x001066 ; 00006D, 23.063
0B1C2D 89 10 00    1274*   	dl 0x001089 ; 00006E, 23.253
0B1C30 AB 10 00    1275*   	dl 0x0010AB ; 00006F, 23.441
0B1C33 CD 10 00    1276*   	dl 0x0010CD ; 000070, 23.629
0B1C36 EF 10 00    1277*   	dl 0x0010EF ; 000071, 23.817
0B1C39 11 11 00    1278*   	dl 0x001111 ; 000072, 24.004
0B1C3C 33 11 00    1279*   	dl 0x001133 ; 000073, 24.191
0B1C3F 55 11 00    1280*   	dl 0x001155 ; 000074, 24.376
0B1C42 77 11 00    1281*   	dl 0x001177 ; 000075, 24.562
0B1C45 99 11 00    1282*   	dl 0x001199 ; 000076, 24.747
0B1C48 BA 11 00    1283*   	dl 0x0011BA ; 000077, 24.931
0B1C4B DC 11 00    1284*   	dl 0x0011DC ; 000078, 25.115
0B1C4E FD 11 00    1285*   	dl 0x0011FD ; 000079, 25.298
0B1C51 1E 12 00    1286*   	dl 0x00121E ; 00007A, 25.481
0B1C54 3F 12 00    1287*   	dl 0x00123F ; 00007B, 25.663
0B1C57 60 12 00    1288*   	dl 0x001260 ; 00007C, 25.844
0B1C5A 81 12 00    1289*   	dl 0x001281 ; 00007D, 26.025
0B1C5D A2 12 00    1290*   	dl 0x0012A2 ; 00007E, 26.206
0B1C60 C3 12 00    1291*   	dl 0x0012C3 ; 00007F, 26.386
0B1C63 E4 12 00    1292*   	dl 0x0012E4 ; 000080, 26.565
0B1C66 04 13 00    1293*   	dl 0x001304 ; 000081, 26.744
0B1C69 25 13 00    1294*   	dl 0x001325 ; 000082, 26.922
0B1C6C 45 13 00    1295*   	dl 0x001345 ; 000083, 27.100
0B1C6F 65 13 00    1296*   	dl 0x001365 ; 000084, 27.277
0B1C72 85 13 00    1297*   	dl 0x001385 ; 000085, 27.453
0B1C75 A5 13 00    1298*   	dl 0x0013A5 ; 000086, 27.629
0B1C78 C5 13 00    1299*   	dl 0x0013C5 ; 000087, 27.805
0B1C7B E5 13 00    1300*   	dl 0x0013E5 ; 000088, 27.979
0B1C7E 05 14 00    1301*   	dl 0x001405 ; 000089, 28.154
0B1C81 24 14 00    1302*   	dl 0x001424 ; 00008A, 28.327
0B1C84 44 14 00    1303*   	dl 0x001444 ; 00008B, 28.501
0B1C87 63 14 00    1304*   	dl 0x001463 ; 00008C, 28.673
0B1C8A 83 14 00    1305*   	dl 0x001483 ; 00008D, 28.845
0B1C8D A2 14 00    1306*   	dl 0x0014A2 ; 00008E, 29.017
0B1C90 C1 14 00    1307*   	dl 0x0014C1 ; 00008F, 29.187
0B1C93 E0 14 00    1308*   	dl 0x0014E0 ; 000090, 29.358
0B1C96 FF 14 00    1309*   	dl 0x0014FF ; 000091, 29.527
0B1C99 1E 15 00    1310*   	dl 0x00151E ; 000092, 29.697
0B1C9C 3C 15 00    1311*   	dl 0x00153C ; 000093, 29.865
0B1C9F 5B 15 00    1312*   	dl 0x00155B ; 000094, 30.033
0B1CA2 79 15 00    1313*   	dl 0x001579 ; 000095, 30.201
0B1CA5 98 15 00    1314*   	dl 0x001598 ; 000096, 30.368
0B1CA8 B6 15 00    1315*   	dl 0x0015B6 ; 000097, 30.534
0B1CAB D4 15 00    1316*   	dl 0x0015D4 ; 000098, 30.700
0B1CAE F2 15 00    1317*   	dl 0x0015F2 ; 000099, 30.865
0B1CB1 10 16 00    1318*   	dl 0x001610 ; 00009A, 31.030
0B1CB4 2E 16 00    1319*   	dl 0x00162E ; 00009B, 31.194
0B1CB7 4C 16 00    1320*   	dl 0x00164C ; 00009C, 31.357
0B1CBA 6A 16 00    1321*   	dl 0x00166A ; 00009D, 31.520
0B1CBD 87 16 00    1322*   	dl 0x001687 ; 00009E, 31.682
0B1CC0 A5 16 00    1323*   	dl 0x0016A5 ; 00009F, 31.844
0B1CC3 C2 16 00    1324*   	dl 0x0016C2 ; 0000A0, 32.005
0B1CC6 DF 16 00    1325*   	dl 0x0016DF ; 0000A1, 32.166
0B1CC9 FC 16 00    1326*   	dl 0x0016FC ; 0000A2, 32.326
0B1CCC 19 17 00    1327*   	dl 0x001719 ; 0000A3, 32.486
0B1CCF 36 17 00    1328*   	dl 0x001736 ; 0000A4, 32.645
0B1CD2 53 17 00    1329*   	dl 0x001753 ; 0000A5, 32.803
0B1CD5 70 17 00    1330*   	dl 0x001770 ; 0000A6, 32.961
0B1CD8 8C 17 00    1331*   	dl 0x00178C ; 0000A7, 33.118
0B1CDB A9 17 00    1332*   	dl 0x0017A9 ; 0000A8, 33.275
0B1CDE C5 17 00    1333*   	dl 0x0017C5 ; 0000A9, 33.431
0B1CE1 E2 17 00    1334*   	dl 0x0017E2 ; 0000AA, 33.587
0B1CE4 FE 17 00    1335*   	dl 0x0017FE ; 0000AB, 33.742
0B1CE7 1A 18 00    1336*   	dl 0x00181A ; 0000AC, 33.896
0B1CEA 36 18 00    1337*   	dl 0x001836 ; 0000AD, 34.050
0B1CED 52 18 00    1338*   	dl 0x001852 ; 0000AE, 34.203
0B1CF0 6E 18 00    1339*   	dl 0x00186E ; 0000AF, 34.356
0B1CF3 8A 18 00    1340*   	dl 0x00188A ; 0000B0, 34.509
0B1CF6 A5 18 00    1341*   	dl 0x0018A5 ; 0000B1, 34.660
0B1CF9 C1 18 00    1342*   	dl 0x0018C1 ; 0000B2, 34.811
0B1CFC DC 18 00    1343*   	dl 0x0018DC ; 0000B3, 34.962
0B1CFF F7 18 00    1344*   	dl 0x0018F7 ; 0000B4, 35.112
0B1D02 13 19 00    1345*   	dl 0x001913 ; 0000B5, 35.262
0B1D05 2E 19 00    1346*   	dl 0x00192E ; 0000B6, 35.410
0B1D08 49 19 00    1347*   	dl 0x001949 ; 0000B7, 35.559
0B1D0B 64 19 00    1348*   	dl 0x001964 ; 0000B8, 35.707
0B1D0E 7F 19 00    1349*   	dl 0x00197F ; 0000B9, 35.854
0B1D11 99 19 00    1350*   	dl 0x001999 ; 0000BA, 36.001
0B1D14 B4 19 00    1351*   	dl 0x0019B4 ; 0000BB, 36.147
0B1D17 CE 19 00    1352*   	dl 0x0019CE ; 0000BC, 36.293
0B1D1A E9 19 00    1353*   	dl 0x0019E9 ; 0000BD, 36.438
0B1D1D 03 1A 00    1354*   	dl 0x001A03 ; 0000BE, 36.582
0B1D20 1D 1A 00    1355*   	dl 0x001A1D ; 0000BF, 36.726
0B1D23 37 1A 00    1356*   	dl 0x001A37 ; 0000C0, 36.870
0B1D26 51 1A 00    1357*   	dl 0x001A51 ; 0000C1, 37.013
0B1D29 6B 1A 00    1358*   	dl 0x001A6B ; 0000C2, 37.155
0B1D2C 85 1A 00    1359*   	dl 0x001A85 ; 0000C3, 37.297
0B1D2F 9F 1A 00    1360*   	dl 0x001A9F ; 0000C4, 37.439
0B1D32 B9 1A 00    1361*   	dl 0x001AB9 ; 0000C5, 37.579
0B1D35 D2 1A 00    1362*   	dl 0x001AD2 ; 0000C6, 37.720
0B1D38 EC 1A 00    1363*   	dl 0x001AEC ; 0000C7, 37.859
0B1D3B 05 1B 00    1364*   	dl 0x001B05 ; 0000C8, 37.999
0B1D3E 1E 1B 00    1365*   	dl 0x001B1E ; 0000C9, 38.137
0B1D41 37 1B 00    1366*   	dl 0x001B37 ; 0000CA, 38.276
0B1D44 50 1B 00    1367*   	dl 0x001B50 ; 0000CB, 38.413
0B1D47 69 1B 00    1368*   	dl 0x001B69 ; 0000CC, 38.550
0B1D4A 82 1B 00    1369*   	dl 0x001B82 ; 0000CD, 38.687
0B1D4D 9B 1B 00    1370*   	dl 0x001B9B ; 0000CE, 38.823
0B1D50 B4 1B 00    1371*   	dl 0x001BB4 ; 0000CF, 38.959
0B1D53 CC 1B 00    1372*   	dl 0x001BCC ; 0000D0, 39.094
0B1D56 E5 1B 00    1373*   	dl 0x001BE5 ; 0000D1, 39.228
0B1D59 FD 1B 00    1374*   	dl 0x001BFD ; 0000D2, 39.362
0B1D5C 16 1C 00    1375*   	dl 0x001C16 ; 0000D3, 39.496
0B1D5F 2E 1C 00    1376*   	dl 0x001C2E ; 0000D4, 39.629
0B1D62 46 1C 00    1377*   	dl 0x001C46 ; 0000D5, 39.762
0B1D65 5E 1C 00    1378*   	dl 0x001C5E ; 0000D6, 39.894
0B1D68 76 1C 00    1379*   	dl 0x001C76 ; 0000D7, 40.025
0B1D6B 8E 1C 00    1380*   	dl 0x001C8E ; 0000D8, 40.156
0B1D6E A5 1C 00    1381*   	dl 0x001CA5 ; 0000D9, 40.286
0B1D71 BD 1C 00    1382*   	dl 0x001CBD ; 0000DA, 40.416
0B1D74 D5 1C 00    1383*   	dl 0x001CD5 ; 0000DB, 40.546
0B1D77 EC 1C 00    1384*   	dl 0x001CEC ; 0000DC, 40.675
0B1D7A 04 1D 00    1385*   	dl 0x001D04 ; 0000DD, 40.803
0B1D7D 1B 1D 00    1386*   	dl 0x001D1B ; 0000DE, 40.931
0B1D80 32 1D 00    1387*   	dl 0x001D32 ; 0000DF, 41.059
0B1D83 49 1D 00    1388*   	dl 0x001D49 ; 0000E0, 41.186
0B1D86 60 1D 00    1389*   	dl 0x001D60 ; 0000E1, 41.312
0B1D89 77 1D 00    1390*   	dl 0x001D77 ; 0000E2, 41.438
0B1D8C 8E 1D 00    1391*   	dl 0x001D8E ; 0000E3, 41.564
0B1D8F A5 1D 00    1392*   	dl 0x001DA5 ; 0000E4, 41.689
0B1D92 BB 1D 00    1393*   	dl 0x001DBB ; 0000E5, 41.814
0B1D95 D2 1D 00    1394*   	dl 0x001DD2 ; 0000E6, 41.938
0B1D98 E9 1D 00    1395*   	dl 0x001DE9 ; 0000E7, 42.061
0B1D9B FF 1D 00    1396*   	dl 0x001DFF ; 0000E8, 42.184
0B1D9E 15 1E 00    1397*   	dl 0x001E15 ; 0000E9, 42.307
0B1DA1 2C 1E 00    1398*   	dl 0x001E2C ; 0000EA, 42.429
0B1DA4 42 1E 00    1399*   	dl 0x001E42 ; 0000EB, 42.551
0B1DA7 58 1E 00    1400*   	dl 0x001E58 ; 0000EC, 42.672
0B1DAA 6E 1E 00    1401*   	dl 0x001E6E ; 0000ED, 42.793
0B1DAD 84 1E 00    1402*   	dl 0x001E84 ; 0000EE, 42.913
0B1DB0 99 1E 00    1403*   	dl 0x001E99 ; 0000EF, 43.033
0B1DB3 AF 1E 00    1404*   	dl 0x001EAF ; 0000F0, 43.152
0B1DB6 C5 1E 00    1405*   	dl 0x001EC5 ; 0000F1, 43.271
0B1DB9 DA 1E 00    1406*   	dl 0x001EDA ; 0000F2, 43.390
0B1DBC F0 1E 00    1407*   	dl 0x001EF0 ; 0000F3, 43.508
0B1DBF 05 1F 00    1408*   	dl 0x001F05 ; 0000F4, 43.625
0B1DC2 1B 1F 00    1409*   	dl 0x001F1B ; 0000F5, 43.742
0B1DC5 30 1F 00    1410*   	dl 0x001F30 ; 0000F6, 43.859
0B1DC8 45 1F 00    1411*   	dl 0x001F45 ; 0000F7, 43.975
0B1DCB 5A 1F 00    1412*   	dl 0x001F5A ; 0000F8, 44.091
0B1DCE 6F 1F 00    1413*   	dl 0x001F6F ; 0000F9, 44.206
0B1DD1 84 1F 00    1414*   	dl 0x001F84 ; 0000FA, 44.321
0B1DD4 99 1F 00    1415*   	dl 0x001F99 ; 0000FB, 44.435
0B1DD7 AD 1F 00    1416*   	dl 0x001FAD ; 0000FC, 44.549
0B1DDA C2 1F 00    1417*   	dl 0x001FC2 ; 0000FD, 44.662
0B1DDD D7 1F 00    1418*   	dl 0x001FD7 ; 0000FE, 44.775
0B1DE0 EB 1F 00    1419*   	dl 0x001FEB ; 0000FF, 44.888
0B1DE3 00 20 00    1420*   	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B1DE6             0024        include "files.inc"
0B1DE6             0001*   ; load to onboard 8k sram
0B1DE6             0002*   filedata: equ 0xB7E000; Directory object structure (DIR)
0B1DE6             0025        include "timer.inc"
0B1DE6             0001*   ; Table 32. Timer Control Registers
0B1DE6             0002*   ; this constant is the base address of the timer control registers
0B1DE6             0003*   ; each timer takes three bytes:
0B1DE6             0004*   ;   0: control register
0B1DE6             0005*   ;   1: low byte of timer reset value
0B1DE6             0006*   ;   2: high byte of timer reset value
0B1DE6             0007*   ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B1DE6             0008*   ; which correctly force the high and upper bytes of the address bus to zero
0B1DE6             0009*   TMR_CTL:     equ 80h
0B1DE6             0010*   
0B1DE6             0011*   ; Timer Control Register Bit Definitions
0B1DE6             0012*   PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B1DE6             0013*                               ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B1DE6             0014*   PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B1DE6             0015*                               ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B1DE6             0016*                               ; the TMRx_CTL register is read.
0B1DE6             0017*   
0B1DE6             0018*   IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B1DE6             0019*   IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B1DE6             0020*   
0B1DE6             0021*   PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B1DE6             0022*                               ;  0,and counting stops when the end-of-count value is reached.
0B1DE6             0023*   PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B1DE6             0024*                               ; written to the counter when the end-of-count value is reached.
0B1DE6             0025*   
0B1DE6             0026*   ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B1DE6             0027*   CLK_DIV_256:  equ %00001100 ;
0B1DE6             0028*   CLK_DIV_64:   equ %00001000 ;
0B1DE6             0029*   CLK_DIV_16:   equ %00000100 ;
0B1DE6             0030*   CLK_DIV_4:    equ %00000000 ;
0B1DE6             0031*   
0B1DE6             0032*   RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B1DE6             0033*   RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B1DE6             0034*                               ; When a 1 is written to this bit,the values in the reload registers
0B1DE6             0035*                               ;  are loaded into the downcounter when the timer restarts. The
0B1DE6             0036*                               ; programmer must ensure that this bit is set to 1 each time
0B1DE6             0037*                               ; SINGLE-PASS mode is used.
0B1DE6             0038*   
0B1DE6             0039*   ; disable/enable the programmable reload timer
0B1DE6             0040*   PRT_EN_0:     equ %00000000 ;
0B1DE6             0041*   PRT_EN_1:     equ %00000001 ;
0B1DE6             0042*   
0B1DE6             0043*   ; Table 37. Timer Input Source Select Register
0B1DE6             0044*   ; Each of the 4 timers are allocated two bits of the 8-bit register
0B1DE6             0045*   ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B1DE6             0046*   ;   00: System clock / CLK_DIV
0B1DE6             0047*   ;   01: RTC / CLK_DIV
0B1DE6             0048*   ;   NOTE: these are the values given in the manual,but it may be a typo
0B1DE6             0049*   ;   10: GPIO port B pin 1.
0B1DE6             0050*   ;   11: GPIO port B pin 1.
0B1DE6             0051*   TMR_ISS:   equ 92h ; register address
0B1DE6             0052*   
0B1DE6             0053*   ; Table 51. Real-Time Clock Control Register
0B1DE6             0054*   RTC_CTRL: equ EDh ; register address
0B1DE6             0055*   
0B1DE6             0056*   ; alarm interrupt disable/enable
0B1DE6             0057*   RTC_ALARM_0:    equ %00000000
0B1DE6             0058*   RTC_ALARM_1:    equ %10000000
0B1DE6             0059*   
0B1DE6             0060*   ; interrupt on alarm disable/enable
0B1DE6             0061*   RTC_INT_ENT_0:  equ %00000000
0B1DE6             0062*   RTC_INT_ENT_1:  equ %01000000
0B1DE6             0063*   
0B1DE6             0064*   RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B1DE6             0065*   RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B1DE6             0066*   
0B1DE6             0067*   RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B1DE6             0068*                                   ; On-chip 32768 Hz oscillator is enabled.
0B1DE6             0069*   RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B1DE6             0070*                                   ; On-chip 32768 Hz oscillator is disabled.
0B1DE6             0071*   
0B1DE6             0072*   RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B1DE6             0073*   RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B1DE6             0074*   
0B1DE6             0075*   RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B1DE6             0076*   RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B1DE6             0077*   
0B1DE6             0078*   RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B1DE6             0079*                                   ; RTC counter is enabled.
0B1DE6             0080*   RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B1DE6             0081*                                   ; RTC counter is disabled.
0B1DE6             0082*   
0B1DE6             0083*   ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B1DE6             0084*   
0B1DE6             0085*   prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B1DE6             0086*   prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B1DE6 00 00 00    0087*   prt_reload: dl 0x000000
0B1DE9             0088*   
0B1DE9             0089*   ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B1DE9             0090*   ; ;          de = number PRT interrupts during test interval
0B1DE9             0091*   ; prt_calibrate:
0B1DE9             0092*   ;     call vdu_vblank
0B1DE9             0093*   ; ; set a MOS timer
0B1DE9             0094*   ;     ld hl,120*1 ; 1 second
0B1DE9             0095*   ;     ld iy,tmr_test
0B1DE9             0096*   ;     call tmr_set
0B1DE9             0097*   ; ; set a PRT timer
0B1DE9             0098*   ;     ; ld hl,prt_reload_hardware
0B1DE9             0099*   ;     ; ld hl,prt_reload_emulator
0B1DE9             0100*   ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B1DE9             0101*   ;     ld (prt_reload),hl
0B1DE9             0102*   ;     call prt_set
0B1DE9             0103*   ; @loop:
0B1DE9             0104*   ; ; check time remaining on MOS timer
0B1DE9             0105*   ;     call tmr_get
0B1DE9             0106*   ;     jp z,@done ; time expired,so quit
0B1DE9             0107*   ;     jp m,@done ; time past expiration (negative),so quit
0B1DE9             0108*   ;     jr @loop
0B1DE9             0109*   ; @done:
0B1DE9             0110*   ;     ld de,(prt_irq_counter)
0B1DE9             0111*   ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B1DE9             0112*   ;     ld (prt_reload),bc
0B1DE9             0113*   ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B1DE9             0114*   ;     xor a ; clear carry,zero is default value for running on hardware
0B1DE9             0115*   ;     ld (is_emulator),a
0B1DE9             0116*   ;     sbc hl,de
0B1DE9             0117*   ;     ld hl,on_hardware ; default message for running on hardware
0B1DE9             0118*   ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B1DE9             0119*   ;     ret m ; negative result means we're on hardware
0B1DE9             0120*   ;     inc a ; we're on emulator
0B1DE9             0121*   ;     ld (is_emulator),a
0B1DE9             0122*   ;     ld bc,prt_reload_emulator
0B1DE9             0123*   ;     ld (prt_reload),bc
0B1DE9             0124*   ;     ld hl,on_emulator
0B1DE9             0125*   ;     ret
0B1DE9             0126*   
0B1DE9             0127*   ; calibrating_timer: defb "Calibrating timer\r\n",0
0B1DE9             0128*   
0B1DE9             0129*   ; set PRT timer
0B1DE9             0130*   prt_set:
0B1DE9 21 00 00 00 0131*       ld hl,0
0B1DED 22 37 1E 0B 0132*       ld (prt_irq_counter),hl
0B1DF1 2A E6 1D 0B 0133*       ld hl,(prt_reload)
0B1DF5 ED 29 84    0134*       out0 ($84),l
0B1DF8 ED 21 85    0135*   	out0 ($85),h
0B1DFB             0136*   ; disable timer
0B1DFB 3E 06       0137*       ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B1DFD ED 39 83    0138*   	out0 ($83),a
0B1E00             0139*   ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B1E00 3E 57       0140*       ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B1E02 ED 39 83    0141*   	out0 ($83),a
0B1E05 C9          0142*       ret
0B1E06             0143*   
0B1E06             0144*   ; ===============================================
0B1E06             0145*   ; PRT Timer Interrupt Handling
0B1E06             0146*   ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B1E06             0147*   ; -----------------------------------------------
0B1E06             0148*   prt_irq_init:
0B1E06             0149*       ; set up interrupt vector table 2
0B1E06 21 00 00 00 0150*   	ld hl,0
0B1E0A 3A 0C 01 00 0151*   	ld a,($10c)
0B1E0E 6F          0152*   	ld l,a
0B1E0F 3A 0D 01 00 0153*   	ld a,($10d)
0B1E13 67          0154*   	ld h,a
0B1E14             0155*   
0B1E14             0156*   	; skip over CALL ($c3)
0B1E14 23          0157*   	inc hl
0B1E15             0158*   	; load address of jump into vector table 2 (in ram)
0B1E15 ED 27       0159*   	ld hl,(hl)
0B1E17             0160*   
0B1E17             0161*   	; write CALL prt_irq_handler to vector table 2
0B1E17 3E C3       0162*   	ld a,$c3
0B1E19 77          0163*   	ld (hl),a
0B1E1A 23          0164*   	inc hl
0B1E1B 11 22 1E 0B 0165*   	ld de,prt_irq_handler
0B1E1F ED 1F       0166*   	ld (hl),de
0B1E21             0167*   
0B1E21 C9          0168*       ret
0B1E22             0169*   
0B1E22             0170*   prt_irq_handler:
0B1E22 F3          0171*   	di
0B1E23 F5          0172*   	push af
0B1E24 E5          0173*       push hl
0B1E25 ED 38 83    0174*   	in0 a,($83)
0B1E28 2A 37 1E 0B 0175*   	ld hl,(prt_irq_counter)
0B1E2C 23          0176*   	inc hl
0B1E2D 22 37 1E 0B 0177*   	ld (prt_irq_counter),hl
0B1E31 E1          0178*       pop hl
0B1E32 F1          0179*   	pop af
0B1E33 FB          0180*   	ei
0B1E34 5B ED 4D    0181*   	reti.l
0B1E37             0182*   
0B1E37             0183*   prt_irq_counter:
0B1E37 00 00 00    0184*   	.dl 0
0B1E3A             0185*   prt_irq_counter_saved:
0B1E3A 00 00 00    0186*       .dl 0
0B1E3D             0187*   
0B1E3D             0188*   prt_loop_reset:
0B1E3D E5          0189*       push hl
0B1E3E 21 00 00 00 0190*   	ld hl,0
0B1E42 22 37 1E 0B 0191*   	ld (prt_irq_counter),hl
0B1E46 22 A8 1E 0B 0192*       ld (prt_loop_counter),hl
0B1E4A 22 AB 1E 0B 0193*       ld (prt_loops),hl
0B1E4E CD E9 1D 0B 0194*       call prt_set
0B1E52 E1          0195*       pop hl
0B1E53 C9          0196*       ret
0B1E54             0197*   
0B1E54             0198*   prt_loop_start:
0B1E54 E5          0199*       push hl
0B1E55 21 00 00 00 0200*   	ld hl,0
0B1E59 22 37 1E 0B 0201*   	ld (prt_irq_counter),hl
0B1E5D E1          0202*       pop hl
0B1E5E C9          0203*       ret
0B1E5F             0204*   
0B1E5F             0205*   prt_loop_stop:
0B1E5F E5          0206*       push hl
0B1E60 D5          0207*       push de
0B1E61 2A 37 1E 0B 0208*       ld hl,(prt_irq_counter)
0B1E65 ED 5B A8 1E 0209*       ld de,(prt_loop_counter)
       0B          
0B1E6A 19          0210*       add hl,de
0B1E6B 22 A8 1E 0B 0211*       ld (prt_loop_counter),hl
0B1E6F 21 00 00 00 0212*       ld hl,0
0B1E73 22 37 1E 0B 0213*       ld (prt_irq_counter),hl
0B1E77 2A AB 1E 0B 0214*       ld hl,(prt_loops)
0B1E7B 23          0215*       inc hl
0B1E7C 22 AB 1E 0B 0216*       ld (prt_loops),hl
0B1E80 D1          0217*       pop de
0B1E81 E1          0218*       pop hl
0B1E82 C9          0219*       ret
0B1E83             0220*   
0B1E83             0221*   ; inputs: bc = y,x text coordinates to print
0B1E83             0222*   prt_loop_print:
0B1E83 F5          0223*       push af
0B1E84 E5          0224*       push hl
0B1E85 C5          0225*       push bc
0B1E86 D5          0226*       push de
0B1E87 DD E5       0227*       push ix
0B1E89 FD E5       0228*       push iy
0B1E8B CD A0 1F 0B 0229*       call vdu_move_cursor
0B1E8F             0230*   
0B1E8F 2A A8 1E 0B 0231*       ld hl,(prt_loop_counter)
0B1E93 CD 2B 03 0B 0232*       call printDec
0B1E97             0233*   
0B1E97 2A AB 1E 0B 0234*       ld hl,(prt_loops)
0B1E9B CD 2B 03 0B 0235*       call printDec
0B1E9F             0236*   
0B1E9F FD E1       0237*       pop iy
0B1EA1 DD E1       0238*       pop ix
0B1EA3 D1          0239*       pop de
0B1EA4 C1          0240*       pop bc
0B1EA5 E1          0241*       pop hl
0B1EA6 F1          0242*       pop af
0B1EA7 C9          0243*       ret
0B1EA8             0244*   
0B1EA8             0245*   prt_loop_counter:
0B1EA8 00 00 00    0246*       .dl 0
0B1EAB             0247*   prt_loops:
0B1EAB 00 00 00    0248*       .dl 0
0B1EAE             0249*   
0B1EAE             0250*   ; ===============================================
0B1EAE             0251*   ; Timer functions
0B1EAE             0252*   ; -----------------------------------------------
0B1EAE             0253*   ; set a countdown timer
0B1EAE             0254*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1EAE             0255*   ; returns: hl = current time
0B1EAE             0256*   tmr_set:
0B1EAE FD 2F 03    0257*       ld (iy+3),hl            ; set time remaining
0B1EB1             0258*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1EB1 3E 08       0001*M  			LD	A, function
0B1EB3 5B CF       0002*M  			RST.L	08h
0B1EB5 DD 27 00    0259*       ld hl,(ix+sysvar_time)  ; get current time
0B1EB8 FD 2F 00    0260*       ld (iy+0),hl            ; set start time
0B1EBB C9          0261*       ret
0B1EBC             0262*   
0B1EBC             0263*   ; gets time remaining on a countdown timer
0B1EBC             0264*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1EBC             0265*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1EBC             0266*   ;          sign flags: pos = time not expired,zero or neg = time expired
0B1EBC             0267*   tmr_get:
0B1EBC             0268*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1EBC 3E 08       0001*M  			LD	A, function
0B1EBE 5B CF       0002*M  			RST.L	08h
0B1EC0 DD 17 00    0269*       ld de,(ix+sysvar_time)  ; get current time
0B1EC3 FD 27 00    0270*       ld hl,(iy+0)            ; get start time
0B1EC6 AF          0271*       xor a                   ; clear carry
0B1EC7 ED 52       0272*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1EC9 FD 17 03    0273*       ld de,(iy+3)            ; get timer set value
0B1ECC AF          0274*       xor a                   ; clear carry
0B1ECD ED 5A       0275*       adc hl,de               ; hl = time remaining
0B1ECF             0276*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1ECF C9          0277*       ret
0B1ED0             0278*   
0B1ED0 00 00 00    0279*   timestamp_now: dl 0
0B1ED3 00 00 00    0280*   timestamp_old: dl 0
0B1ED6 00 00 00    0281*   timestamp_chg: dl 0
0B1ED9             0282*   
0B1ED9             0283*   ; update the global timestamp from the system clock
0B1ED9             0284*   ; inputs: none
0B1ED9             0285*   ; returns: hl = time elapsed in 1/120ths of a second
0B1ED9             0286*   ;          de = current time
0B1ED9             0287*   ;          ix = pointer to syvars table
0B1ED9             0288*   ; destroys: af,hl,de,ix
0B1ED9             0289*   timestamp_tick:
0B1ED9 ED 5B D0 1E 0290*       ld de,(timestamp_now)   ; get previous time
       0B          
0B1EDE ED 53 D3 1E 0291*       ld (timestamp_old),de   ; save previous time
       0B          
0B1EE3             0292*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1EE3 3E 08       0001*M  			LD	A, function
0B1EE5 5B CF       0002*M  			RST.L	08h
0B1EE7 DD 27 00    0293*       ld hl,(ix+sysvar_time)  ; get current time
0B1EEA 22 D0 1E 0B 0294*       ld (timestamp_now),hl   ; save current time
0B1EEE AF          0295*       xor a                   ; clear carry
0B1EEF ED 52       0296*       sbc hl,de               ; hl = time elapsed
0B1EF1 22 D6 1E 0B 0297*       ld (timestamp_chg),hl   ; save elapsed time
0B1EF5 C9          0298*       ret
0B1EF6             0299*   
0B1EF6             0300*   ; set a countdown timer
0B1EF6             0301*   ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1EF6             0302*   ; requires: timestamp_tick to be called at least once before this function
0B1EF6             0303*   ; returns: hl = current time
0B1EF6             0304*   ; destroys: hl
0B1EF6             0305*   timestamp_tmr_set:
0B1EF6 FD 2F 03    0306*       ld (iy+3),hl            ; set time remaining
0B1EF9 2A D0 1E 0B 0307*       ld hl,(timestamp_now)   ; get current timestamp
0B1EFD FD 2F 00    0308*       ld (iy+0),hl            ; set start time
0B1F00 C9          0309*       ret
0B1F01             0310*   
0B1F01             0311*   ; gets time remaining on a countdown timer following the global timestamp
0B1F01             0312*   ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1F01             0313*   ; requires: timestamp_tick to be called at least once before this function
0B1F01             0314*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1F01             0315*   ;          sign flags: pos = time not expired,zero or neg = time expired
0B1F01             0316*   ; destroys: af,hl,de
0B1F01             0317*   timestamp_tmr_get:
0B1F01 ED 5B D0 1E 0318*       ld de,(timestamp_now)   ; get current timestamp
       0B          
0B1F06 FD 27 00    0319*       ld hl,(iy+0)            ; get start time
0B1F09 AF          0320*       xor a                   ; clear carry
0B1F0A ED 52       0321*       sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1F0C FD 17 03    0322*       ld de,(iy+3)            ; get timer set value
0B1F0F AF          0323*       xor a                   ; clear carry
0B1F10 ED 5A       0324*       adc hl,de               ; hl = time remaining
0B1F12             0325*                               ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1F12 C9          0326*       ret
0B1F13             0327*   
0B1F13             0328*   ; main loop timer functions
0B1F13             0329*   tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B1F19             0330*   
0B1F19             0331*   ; set a countdown timer for the main loop using the timestamp timer
0B1F19             0332*   ; inputs: hl = time to set in 1/120ths of a second
0B1F19             0333*   ; returns: hl = current time
0B1F19             0334*   ; destroys: af,hl,de,ix,iy
0B1F19             0335*   tmr_main_loop_set:
0B1F19 FD 21 13 1F 0336*       ld iy,tmr_main_loop
       0B          
0B1F1E FD 2F 03    0337*       ld (iy+3),hl ; set time remaining
0B1F21 CD D9 1E 0B 0338*       call timestamp_tick
0B1F25 2A D0 1E 0B 0339*       ld hl,(timestamp_now)   ; get current timestamp
0B1F29 FD 2F 00    0340*       ld (iy+0),hl ; set start time
0B1F2C C9          0341*       ret
0B1F2D             0342*   
0B1F2D             0343*   ; gets time remaining on the main loop countdown timer following the global timestamp
0B1F2D             0344*   ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1F2D             0345*   ;          sign flags: pos = time not expired,zero or neg = time expired
0B1F2D             0346*   ; destroys: af,hl,de,ix,iy
0B1F2D             0347*   tmr_main_loop_get:
0B1F2D CD D9 1E 0B 0348*       call timestamp_tick
0B1F31 FD 21 13 1F 0349*       ld iy,tmr_main_loop
       0B          
0B1F36 CD 01 1F 0B 0350*       call timestamp_tmr_get
0B1F3A C9          0351*       ret
0B1F3B             0352*   
0B1F3B             0353*   ; set a stopwatch
0B1F3B             0354*   ; returns: hl = start time
0B1F3B             0355*   ; destroys: hl,ix
0B1F3B             0356*   stopwatch_set:
0B1F3B             0357*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1F3B 3E 08       0001*M  			LD	A, function
0B1F3D 5B CF       0002*M  			RST.L	08h
0B1F3F DD 27 00    0358*       ld hl,(ix+sysvar_time)  ; get current time
0B1F42 22 57 1F 0B 0359*       ld (stopwatch_started),hl            ; set start time
0B1F46 C9          0360*       ret
0B1F47             0361*   
0B1F47             0362*   ; gets time elapsed on a stopwatch
0B1F47             0363*   ; returns: hl = time elapsed in 1/120ths of a second
0B1F47             0364*   ; destroys: af,hl,de,ix
0B1F47             0365*   stopwatch_get:
0B1F47             0366*       MOSCALL mos_sysvars     ; ix points to syvars table
0B1F47 3E 08       0001*M  			LD	A, function
0B1F49 5B CF       0002*M  			RST.L	08h
0B1F4B DD 27 00    0367*       ld hl,(ix+sysvar_time)  ; get current time
0B1F4E ED 5B 57 1F 0368*       ld de,(stopwatch_started)            ; get start time
       0B          
0B1F53 AF          0369*       xor a                   ; clear carry
0B1F54 ED 52       0370*       sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B1F56 C9          0371*       ret
0B1F57             0372*   
0B1F57             0373*   stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B1F5A             0374*   
0B1F5A             0375*   ; ------------------
0B1F5A             0376*   ; delay routine
0B1F5A             0377*   ; Author: Richard Turrnidge
0B1F5A             0378*   ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B1F5A             0379*   ; routine waits a fixed time,then returns
0B1F5A             0380*   ; arrive with A =  the delay byte. One bit to be set only.
0B1F5A             0381*   ; eg. ld A,00000100b
0B1F5A             0382*   
0B1F5A             0383*   multiPurposeDelay:
0B1F5A F5          0384*       push af
0B1F5B C5          0385*       push bc
0B1F5C DD E5       0386*       push ix
0B1F5E 47          0387*       ld b,a
0B1F5F 3E 08       0388*       ld a,$08
0B1F61 5B CF       0389*       RST.LIL	08h                 ; get IX pointer to sysvars
0B1F63             0390*   
0B1F63             0391*   waitLoop:
0B1F63             0392*   
0B1F63 DD 7E 00    0393*       ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B1F66             0394*   
0B1F66             0395*                                   ;   we check if bit set is same as last time we checked.
0B1F66             0396*                                   ;   bit 0 - don't use
0B1F66             0397*                                   ;   bit 1 - changes 64 times per second
0B1F66             0398*                                   ;   bit 2 - changes 32 times per second
0B1F66             0399*                                   ;   bit 3 - changes 16 times per second
0B1F66             0400*   
0B1F66             0401*                                   ;   bit 4 - changes 8 times per second
0B1F66             0402*                                   ;   bit 5 - changes 4 times per second
0B1F66             0403*                                   ;   bit 6 - changes 2 times per second
0B1F66             0404*                                   ;   bit 7 - changes 1 times per second
0B1F66 A0          0405*       and b
0B1F67 4F          0406*       ld c,a
0B1F68 3A 79 1F 0B 0407*       ld a,(oldTimeStamp)
0B1F6C B9          0408*       cp c                        ; is A same as last value?
0B1F6D 28 F4       0409*       jr z,waitLoop              ; loop here if it is
0B1F6F 79          0410*       ld a,c
0B1F70 32 79 1F 0B 0411*       ld (oldTimeStamp),a        ; set new value
0B1F74             0412*   
0B1F74 DD E1       0413*       pop ix
0B1F76 C1          0414*       pop bc
0B1F77 F1          0415*       pop af
0B1F78 C9          0416*       ret
0B1F79             0417*   
0B1F79 00          0418*   oldTimeStamp:   .db 00h
0B1F7A             0026        include "vdu.inc"
0B1F7A             0001*   
0B1F7A             0002*   ; VDU 30: Home cursor
0B1F7A             0003*   vdu_home_cursor:
0B1F7A 3E 1E       0004*       ld a,30
0B1F7C 5B D7       0005*   	rst.lil $10
0B1F7E C9          0006*   	ret
0B1F7F             0007*   
0B1F7F             0008*   cursor_on:
0B1F7F 21 8A 1F 0B 0009*   	ld hl,@cmd
0B1F83 01 03 00 00 0010*   	ld bc,@end-@cmd
0B1F87 5B DF       0011*   	rst.lil $18
0B1F89 C9          0012*   	ret
0B1F8A             0013*   @cmd:
0B1F8A 17 01 01    0014*   	db 23,1,1
0B1F8D             0015*   @end:
0B1F8D             0016*   
0B1F8D             0017*   cursor_off:
0B1F8D 21 98 1F 0B 0018*   	ld hl,@cmd
0B1F91 01 03 00 00 0019*   	ld bc,@end-@cmd
0B1F95 5B DF       0020*   	rst.lil $18
0B1F97 C9          0021*   	ret
0B1F98             0022*   @cmd:
0B1F98 17 01 00    0023*   	db 23,1,0
0B1F9B             0024*   @end:
0B1F9B             0025*   
0B1F9B             0026*   ; VDU 9: Move cursor forward one character
0B1F9B             0027*   vdu_cursor_forward:
0B1F9B 3E 09       0028*       ld a,9
0B1F9D 5B D7       0029*   	rst.lil $10
0B1F9F C9          0030*   	ret
0B1FA0             0031*   
0B1FA0             0032*   ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B1FA0             0033*   ; inputs: c=x, b=y 8-bit unsigned integers
0B1FA0             0034*   vdu_move_cursor:
0B1FA0 ED 43 B1 1F 0035*       ld (@x0),bc
       0B          
0B1FA5 21 B0 1F 0B 0036*   	ld hl,@cmd
0B1FA9 01 03 00 00 0037*   	ld bc,@end-@cmd
0B1FAD 5B DF       0038*   	rst.lil $18
0B1FAF C9          0039*   	ret
0B1FB0 1F          0040*   @cmd: 	db 31
0B1FB1 00          0041*   @x0:	db 0
0B1FB2 00          0042*   @y0: 	db 0
0B1FB3 00          0043*   @end: 	db 0 ; padding
0B1FB4             0044*   
0B1FB4             0045*   ; VDU 12: Clear text area (CLS)
0B1FB4             0046*   vdu_cls:
0B1FB4 3E 0C       0047*       ld a,12
0B1FB6 5B D7       0048*   	rst.lil $10
0B1FB8 C9          0049*   	ret
0B1FB9             0050*   
0B1FB9             0051*   vdu_flip:
0B1FB9 21 C4 1F 0B 0052*   	ld hl,@cmd
0B1FBD 01 03 00 00 0053*   	ld bc,@end-@cmd
0B1FC1 5B DF       0054*   	rst.lil $18
0B1FC3 C9          0055*   	ret
0B1FC4 17 00 C3    0056*   @cmd: db 23,0,0xC3
0B1FC7             0057*   @end:
0B1FC7             0058*   
0B1FC7             0059*   ; VDU 16: Clear graphics area (CLG)
0B1FC7             0060*   vdu_clg:
0B1FC7 3E 10       0061*       ld a,16
0B1FC9 5B D7       0062*   	rst.lil $10
0B1FCB C9          0063*   	ret
0B1FCC             0064*   
0B1FCC             0065*   ; COLOUR MODES
0B1FCC             0066*   ; Mode	Effect
0B1FCC             0067*   ; 0	Set on-screen pixel to target colour value
0B1FCC             0068*   ; 1	OR value with the on-screen pixel
0B1FCC             0069*   ; 2	AND value with the on-screen pixel
0B1FCC             0070*   ; 3	XOR value with the on-screen pixel
0B1FCC             0071*   ; 4	Invert the on-screen pixel
0B1FCC             0072*   ; 5	No operation
0B1FCC             0073*   ; 6	AND the inverse of the specified colour with the on-screen pixel
0B1FCC             0074*   ; 7	OR the inverse of the specified colour with the on-screen pixel
0B1FCC             0075*   
0B1FCC             0076*   ; VDU 17, colour: Define text colour (COLOUR)
0B1FCC             0077*   vdu_colour_text:
0B1FCC 32 DC 1F 0B 0078*   	ld (@arg),a
0B1FD0 21 DB 1F 0B 0079*   	ld hl,@cmd
0B1FD4 01 02 00 00 0080*   	ld bc,@end-@cmd
0B1FD8 5B DF       0081*   	rst.lil $18
0B1FDA C9          0082*   	ret
0B1FDB 11          0083*   @cmd: db 17
0B1FDC 00          0084*   @arg: db 0
0B1FDD             0085*   @end:
0B1FDD             0086*   
0B1FDD             0087*   ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B1FDD             0088*   ; inputs: a=mode, c=colour (add 128 to set background colour)
0B1FDD             0089*   vdu_gcol:
0B1FDD 32 F2 1F 0B 0090*   	ld (@mode),a
0B1FE1 79          0091*       ld a,c
0B1FE2 32 F3 1F 0B 0092*       ld (@col),a
0B1FE6 21 F1 1F 0B 0093*   	ld hl,@cmd
0B1FEA 01 03 00 00 0094*   	ld bc,@end-@cmd
0B1FEE 5B DF       0095*   	rst.lil $18
0B1FF0 C9          0096*   	ret
0B1FF1 12          0097*   @cmd:  db 18
0B1FF2 00          0098*   @mode: db 0
0B1FF3 00          0099*   @col:  db 0
0B1FF4             0100*   @end:
0B1FF4             0101*   
0B1FF4             0102*   
0B1FF4             0103*   ; VDU 28, left, bottom, right, top: Set text viewport **
0B1FF4             0104*   ; MIND THE LITTLE-ENDIANESS
0B1FF4             0105*   ; inputs: c=left,b=bottom,e=right,d=top
0B1FF4             0106*   ; outputs; nothing
0B1FF4             0107*   ; destroys: a might make it out alive
0B1FF4             0108*   vdu_set_txt_viewport:
0B1FF4 ED 43 0A 20 0109*       ld (@lb),bc
       0B          
0B1FF9 ED 53 0C 20 0110*   	ld (@rt),de
       0B          
0B1FFE 21 09 20 0B 0111*   	ld hl,@cmd
0B2002 01 05 00 00 0112*   	ld bc,@end-@cmd
0B2006 5B DF       0113*   	rst.lil $18
0B2008 C9          0114*   	ret
0B2009 1C          0115*   @cmd:   db 28 ; set text viewport command
0B200A 00 00       0116*   @lb: 	dw 0x0000 ; set by bc
0B200C 00 00       0117*   @rt: 	dw 0x0000 ; set by de
0B200E 00          0118*   @end:   db 0x00	  ; padding
0B200F             0119*   
0B200F             0120*   ; Wait for VBLANK interrupt
0B200F             0121*   vdu_vblank:
0B200F DD E5       0122*       PUSH 	IX
0B2011             0123*   	MOSCALL	mos_sysvars
0B2011 3E 08       0001*M  			LD	A, function
0B2013 5B CF       0002*M  			RST.L	08h
0B2015 DD 7E 00    0124*   	LD	A, (IX + sysvar_time + 0)
0B2018             0125*   @wait:
0B2018 DD BE 00    0126*       CP 	A, (IX + sysvar_time + 0)
0B201B 28 FB       0127*       JR	Z, @wait
0B201D DD E1       0128*       POP	IX
0B201F C9          0129*       RET
0B2020             0130*   
0B2020             0131*   ; VDU 29, x; y;: Set graphics origin
0B2020             0132*   ; This command sets the graphics origin.
0B2020             0133*   ; The origin is the point on the screen where the coordinates (0,0) are located.
0B2020             0134*   ; inputs: bc=x0,de=y0
0B2020             0135*   ; outputs; nothing
0B2020             0136*   ; destroys: a might make it out alive
0B2020             0137*   vdu_set_gfx_origin:
0B2020 ED 43 36 20 0138*       ld (@x0),bc
       0B          
0B2025 ED 53 38 20 0139*       ld (@y0),de
       0B          
0B202A 21 35 20 0B 0140*       ld hl,@cmd
0B202E 01 05 00 00 0141*       ld bc,@end-@cmd
0B2032 5B DF       0142*       rst.lil $18
0B2034 C9          0143*       ret
0B2035 1D          0144*   @cmd:   db 29 ; set graphics origin command
0B2036 00 00       0145*   @x0: 	dw 0x0000 ; set by bc
0B2038 00 00       0146*   @y0: 	dw 0x0000 ; set by de
0B203A 00          0147*   @end:   db 0x00	  ; padding
0B203B             0148*   
0B203B             0149*   ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B203B             0150*   ; NOTE: the order of the y-coordinate parameters are inverted
0B203B             0151*   ; 	because we have turned off logical screen scaling
0B203B             0152*   ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B203B             0153*   ; outputs; nothing
0B203B             0154*   ; destroys: a might make it out alive
0B203B             0155*   vdu_set_gfx_viewport:
0B203B ED 43 5B 20 0156*       ld (@x0),bc
       0B          
0B2040 FD 22 5D 20 0157*       ld (@y1),iy
       0B          
0B2045 DD 22 5F 20 0158*   	ld (@x1),ix
       0B          
0B204A ED 53 61 20 0159*   	ld (@y0),de
       0B          
0B204F 21 5A 20 0B 0160*   	ld hl,@cmd
0B2053 01 09 00 00 0161*   	ld bc,@end-@cmd
0B2057 5B DF       0162*   	rst.lil $18
0B2059 C9          0163*   	ret
0B205A 18          0164*   @cmd:   db 24 ; set graphics viewport command
0B205B 00 00       0165*   @x0: 	dw 0x0000 ; set by bc
0B205D 00 00       0166*   @y1: 	dw 0x0000 ; set by iy
0B205F 00 00       0167*   @x1: 	dw 0x0000 ; set by ix
0B2061 00 00       0168*   @y0: 	dw 0x0000 ; set by de
0B2063 00          0169*   @end:   db 0x00	  ; padding
0B2064             0170*   
0B2064             0171*   ; SCREEN MODES
0B2064             0172*   ; ===============================
0B2064             0173*   ; Mode  Horz  Vert  Cols  Refresh
0B2064             0174*   ; ---   ----  ----  ----  -------
0B2064             0175*   ; 11    320   240   2     60hz
0B2064             0176*   ; 139   320   240   2     60hz
0B2064             0177*   ; 23    512   384   2     60hz
0B2064             0178*   ; 151   512   384   2     60hz
0B2064             0179*   ; 6     640   240   2     60hz
0B2064             0180*   ; 134   640   240   2     60hz
0B2064             0181*   ; 2     640   480   2     60hz
0B2064             0182*   ; 130   640   480   2     60hz
0B2064             0183*   ; 17    800   600   2     60hz
0B2064             0184*   ; 145   800   600   2     60hz
0B2064             0185*   ; 18    1024  768   2     60hz
0B2064             0186*   ; 146   1024  768   2     60hz
0B2064             0187*   ; ---   ----  ----  ----  -------
0B2064             0188*   ; 10    320   240   4     60hz
0B2064             0189*   ; 138   320   240   4     60hz
0B2064             0190*   ; 22    512   384   4     60hz
0B2064             0191*   ; 150   512   384   4     60hz
0B2064             0192*   ; 5     640   240   4     60hz
0B2064             0193*   ; 133   640   240   4     60hz
0B2064             0194*   ; 1     640   480   4     60hz
0B2064             0195*   ; 129   640   480   4     60hz
0B2064             0196*   ; 16    800   600   4     60hz
0B2064             0197*   ; 19    1024  768   4     60hz
0B2064             0198*   ; ---   ----  ----  ----  -------
0B2064             0199*   ; 9     320   240   16    60hz
0B2064             0200*   ; 137   320   240   16    60hz
0B2064             0201*   ; 21    512   384   16    60hz
0B2064             0202*   ; 149   512   384   16    60hz
0B2064             0203*   ; 4     640   240   16    60hz
0B2064             0204*   ; 132   640   240   16    60hz
0B2064             0205*   ; 0     640   480   16    60hz
0B2064             0206*   ; 7     n/a   n/a   16    60hz
0B2064             0207*   ; ---   ----  ----  ----  -------
0B2064             0208*   ; 8     320   240   64    60hz
0B2064             0209*   ; 136   320   240   64    60hz
0B2064             0210*   ; 20    512   384   64    60hz
0B2064             0211*   ; 3     640   240   64    60hz
0B2064             0212*   ; ---   ----  ----  ----  -------
0B2064             0213*   vdu_set_screen_mode:
0B2064 32 74 20 0B 0214*   	ld (@arg),a
0B2068 21 73 20 0B 0215*   	ld hl,@cmd
0B206C 01 02 00 00 0216*   	ld bc,@end-@cmd
0B2070 5B DF       0217*   	rst.lil $18
0B2072 C9          0218*   	ret
0B2073 16          0219*   @cmd: db 22 ; set screen mode
0B2074 00          0220*   @arg: db 0  ; screen mode parameter
0B2075             0221*   @end:
0B2075             0222*   
0B2075             0223*   ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B2075             0224*   ; inputs: a is scaling mode, 1=on, 0=off
0B2075             0225*   ; note: default setting on boot is scaling ON
0B2075             0226*   vdu_set_scaling:
0B2075 32 87 20 0B 0227*   	ld (@arg),a
0B2079 21 84 20 0B 0228*   	ld hl,@cmd
0B207D 01 04 00 00 0229*   	ld bc,@end-@cmd
0B2081 5B DF       0230*   	rst.lil $18
0B2083 C9          0231*   	ret
0B2084 17 00 C0    0232*   @cmd: db 23,0,0xC0
0B2087 00          0233*   @arg: db 0  ; scaling on/off
0B2088             0234*   @end:
0B2088             0235*   
0B2088             0236*   ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B2088             0237*   ; inputs: hl=bufferId
0B2088             0238*   vdu_buff_select:
0B2088 22 9A 20 0B 0239*   	ld (@bufferId),hl
0B208C 21 97 20 0B 0240*   	ld hl,@cmd
0B2090 01 05 00 00 0241*   	ld bc,@end-@cmd
0B2094 5B DF       0242*   	rst.lil $18
0B2096 C9          0243*   	ret
0B2097 17 1B 20    0244*   @cmd: db 23,27,0x20
0B209A 00 00       0245*   @bufferId: dw 0x0000
0B209C 00          0246*   @end: db 0x00 ; padding
0B209D             0247*   
0B209D             0248*   ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B209D             0249*   ; inputs: a=format; bc=width; de=height
0B209D             0250*   ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B209D             0251*   ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B209D             0252*   ; 0 	RGBA8888 (4-bytes per pixel)
0B209D             0253*   ; 1 	RGBA2222 (1-bytes per pixel)
0B209D             0254*   ; 2 	Mono/Mask (1-bit per pixel)
0B209D             0255*   ; 3 	Reserved for internal use by VDP (native format)
0B209D             0256*   vdu_bmp_create:
0B209D ED 43 B9 20 0257*       ld (@width),bc
       0B          
0B20A2 ED 53 BB 20 0258*       ld (@height),de
       0B          
0B20A7 32 BD 20 0B 0259*       ld (@fmt),a
0B20AB 21 B6 20 0B 0260*   	ld hl,@cmd
0B20AF 01 08 00 00 0261*   	ld bc,@end-@cmd
0B20B3 5B DF       0262*   	rst.lil $18
0B20B5 C9          0263*   	ret
0B20B6 17 1B 21    0264*   @cmd:       db 23,27,0x21
0B20B9 00 00       0265*   @width:     dw 0x0000
0B20BB 00 00       0266*   @height:    dw 0x0000
0B20BD 00          0267*   @fmt:       db 0x00
0B20BE             0268*   @end:
0B20BE             0269*   
0B20BE             0270*   ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B20BE             0271*   ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B20BE             0272*   vdu_load_img_rgba2_to_8:
0B20BE             0273*   ; backup the target buffer id and image dimensions
0B20BE E5          0274*       push hl
0B20BF D5          0275*       push de
0B20C0 C5          0276*       push bc
0B20C1             0277*   ; load the rgba2 image to working buffer 65534
0B20C1 21 FE FF 00 0278*       ld hl,65534 ; temporary working buffer id
0B20C5 CD C8 21 0B 0279*   	call vdu_load_buffer_from_file
0B20C9             0280*   ; restore the image dimensions and target buffer id
0B20C9 C1          0281*       pop bc
0B20CA D1          0282*       pop de
0B20CB E1          0283*       pop hl
0B20CC             0284*   ; fall through to vdu_rgba2_to_8
0B20CC             0285*   
0B20CC             0286*   ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B20CC             0287*   ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B20CC             0288*   ; the "expand bitmap" command is:
0B20CC             0289*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B20CC             0290*   ; and then to reverse the byte order to fix endian-ness:
0B20CC             0291*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B20CC             0292*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B20CC             0293*   ; VDU 23,27,&20,targetBufferID%;
0B20CC             0294*   ; VDU 23,27,&21,width%;height%;0
0B20CC             0295*   ; -------------------------------------------------------------------
0B20CC             0296*   ; inputs: bc,de image width,height ; hl = targetBufferId
0B20CC             0297*   ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B20CC             0298*   vdu_rgba2_to_8:
0B20CC             0299*   ; load the image dimensions and buffer id parameters
0B20CC ED 43 28 21 0300*       ld (@width),bc
       0B          
0B20D1 ED 53 2A 21 0301*       ld (@height),de
       0B          
0B20D6 22 0D 21 0B 0302*       ld (@bufferId0),hl
0B20DA 22 1A 21 0B 0303*       ld (@bufferId2),hl
0B20DE 22 23 21 0B 0304*       ld (@bufferId1),hl
0B20E2             0305*   ; clean up bytes that got stomped on by the ID loads
0B20E2 3E 48       0306*       ld a,0x48
0B20E4 32 0F 21 0B 0307*       ld (@bufferId0+2),a
0B20E8 3E 17       0308*       ld a,23
0B20EA 32 25 21 0B 0309*       ld (@bufferId1+2),a
0B20EE 3E 18       0310*       ld a,24
0B20F0 32 1C 21 0B 0311*       ld (@bufferId2+2),a
0B20F4 AF          0312*       xor a
0B20F5 32 2C 21 0B 0313*       ld (@height+2),a
0B20F9             0314*   ; send the vdu command strings
0B20F9 21 04 21 0B 0315*       ld hl,@beg
0B20FD 01 29 00 00 0316*       ld bc,@end-@beg
0B2101 5B DF       0317*       rst.lil $18
0B2103 C9          0318*       ret
0B2104             0319*   @beg:
0B2104             0320*   ; Command 14: Consolidate blocks in a buffer
0B2104             0321*   ; VDU 23, 0, &A0, bufferId; 14
0B2104 17 00 A0    0322*       db 23,0,0xA0
0B2107 FE FF       0323*       dw 65534 ; workingBufferId
0B2109 0E          0324*       db 14 ; consolidate blocks
0B210A             0325*   ; the "expand bitmap" command is:
0B210A             0326*   ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B210A 17 00 A0    0327*       db 23,0,0xA0
0B210D 00 00       0328*   @bufferId0: dw 0x0000 ; targetBufferId
0B210F 48          0329*       db 0x48 ; given as decimal command 72 in the docs
0B2110 02          0330*       db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B2111 FE FF       0331*       dw 65534 ; sourceBufferId
0B2113 00 7F BF FF 0332*       db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B2117             0333*   ; reverse the byte order to fix endian-ness:
0B2117             0334*   ; Command 24: Reverse the order of data of blocks within a buffer
0B2117             0335*   ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B2117             0336*   ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B2117 17 00 A0    0337*       db 23,0,0xA0
0B211A 00 00       0338*   @bufferId2:    dw 0x0000 ; targetBufferId
0B211C 18          0339*       db 24 ; reverse byte order
0B211D 04          0340*       db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B211E 04 00       0341*       dw 4 ; size (4 bytes)
0B2120             0342*   ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B2120             0343*   ; VDU 23,27,&20,targetBufferID%;
0B2120 17 1B 20    0344*       db 23,27,0x20 ; select bitmap
0B2123 00 00       0345*   @bufferId1: dw 0x0000 ; targetBufferId
0B2125             0346*   ; VDU 23,27,&21,width%;height%;0
0B2125 17 1B 21    0347*       db 23,27,0x21 ; create bitmap from buffer
0B2128 00 00       0348*   @width: dw 0x0000
0B212A 00 00       0349*   @height: dw 0x0000
0B212C 00          0350*       db 0x00 ; rgba8888 format
0B212D             0351*   @end:
0B212D             0352*   
0B212D             0353*   ; scratch variables
0B212D 00 00 00    0354*   bufferId0: dl 0x000000
0B2130 00 00 00    0355*   bufferId1: dl 0x000000
0B2133             0356*   
0B2133             0357*   ; load a vdu buffer from local memory
0B2133             0358*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B2133             0359*   vdu_load_buffer:
0B2133 ED 43 5C 21 0360*       ld (@length),bc
       0B          
0B2138 D5          0361*       push de ; save data pointer
0B2139             0362*   ; send the vdu command string
0B2139 7D          0363*       ld a,l
0B213A 32 59 21 0B 0364*       ld (@bufferId),a
0B213E 7C          0365*       ld a,h
0B213F 32 5A 21 0B 0366*       ld (@bufferId+1),a
0B2143 21 56 21 0B 0367*       ld hl,@cmd
0B2147 01 08 00 00 0368*       ld bc,@end-@cmd
0B214B 5B DF       0369*       rst.lil $18
0B214D             0370*   ; send the buffer data
0B214D E1          0371*       pop hl ; pointer to data
0B214E ED 4B 5C 21 0372*       ld bc,(@length)
       0B          
0B2153 5B DF       0373*       rst.lil $18 ; send it
0B2155 C9          0374*       ret
0B2156             0375*   ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B2156 17 00 A0    0376*   @cmd:       db 23,0,0xA0
0B2159 00 00       0377*   @bufferId:	dw 0x0000
0B215B 00          0378*   		    db 0 ; load buffer
0B215C 00 00       0379*   @length:	dw 0x0000
0B215E 00          0380*   @end: db 0 ; padding
0B215F             0381*   
0B215F             0382*   ; clear a buffer
0B215F             0383*   ; inputs: hl = bufferId
0B215F             0384*   vdu_clear_buffer:
0B215F 7D          0385*       ld a,l
0B2160 32 77 21 0B 0386*       ld (@bufferId),a
0B2164 7C          0387*       ld a,h
0B2165 32 78 21 0B 0388*       ld (@bufferId+1),a
0B2169 21 74 21 0B 0389*       ld hl,@cmd
0B216D 01 06 00 00 0390*       ld bc,@end-@cmd
0B2171 5B DF       0391*       rst.lil $18
0B2173 C9          0392*       ret
0B2174 17 00 A0    0393*   @cmd:       db 23,0,0xA0
0B2177 00 00       0394*   @bufferId:	dw 0x0000
0B2179 02          0395*   		    db 2 ; clear buffer
0B217A             0396*   @end:
0B217A             0397*   
0B217A             0398*   vdu_clear_all_buffers:
0B217A             0399*   ; clear all buffers
0B217A 21 85 21 0B 0400*       ld hl,@beg
0B217E 01 06 00 00 0401*       ld bc,@end-@beg
0B2182 5B DF       0402*       rst.lil $18
0B2184 C9          0403*       ret
0B2185 17 00 A0    0404*   @beg: db 23,0,$A0
0B2188 FF FF       0405*         dw -1 ; clear all buffers
0B218A 02          0406*         db 2  ; command 2: clear a buffer
0B218B             0407*   @end:
0B218B             0408*   
0B218B             0409*   ; Command 14: Consolidate blocks in a buffer
0B218B             0410*   vdu_consolidate_buffer:
0B218B             0411*   ; set parameters for vdu call
0B218B 7D          0412*       ld a,l
0B218C 32 A3 21 0B 0413*       ld (@bufferId),a
0B2190 7C          0414*       ld a,h
0B2191 32 A4 21 0B 0415*       ld (@bufferId+1),a
0B2195 21 A0 21 0B 0416*       ld hl,@beg
0B2199 01 06 00 00 0417*       ld bc,@end-@beg
0B219D 5B DF       0418*       rst.lil $18
0B219F C9          0419*       ret
0B21A0             0420*   ; VDU 23, 0, &A0, bufferId; 14
0B21A0 17 00 A0    0421*   @beg: db 23,0,0xA0
0B21A3 00 00       0422*   @bufferId: dw 0x0000
0B21A5 0E          0423*              db 14
0B21A6             0424*   @end:
0B21A6             0425*   
0B21A6             0426*   ; load an image file to a buffer and make it a bitmap
0B21A6             0427*   ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B21A6             0428*   vdu_load_img:
0B21A6             0429*   ; back up image type and dimension parameters
0B21A6 22 2D 21 0B 0430*       ld (bufferId0),hl
0B21AA F5          0431*       push af
0B21AB C5          0432*   	push bc
0B21AC D5          0433*   	push de
0B21AD             0434*   ; load the image
0B21AD CD C8 21 0B 0435*   	call vdu_load_buffer_from_file
0B21B1             0436*   ; now make it a bitmap
0B21B1 2A 2D 21 0B 0437*       ld hl,(bufferId0)
0B21B5 CD 8B 21 0B 0438*       call vdu_consolidate_buffer
0B21B9 2A 2D 21 0B 0439*       ld hl,(bufferId0)
0B21BD CD 88 20 0B 0440*       call vdu_buff_select
0B21C1 D1          0441*   	pop de ; image height
0B21C2 C1          0442*   	pop bc ; image width
0B21C3 F1          0443*   	pop af ; image type
0B21C4 C3 9D 20 0B 0444*   	jp vdu_bmp_create ; will return to caller from there
0B21C8             0445*   
0B21C8             0446*   ; inputs: hl = bufferId; iy = pointer to filename
0B21C8             0447*   vdu_load_buffer_from_file:
0B21C8 22 2D 21 0B 0448*       ld (bufferId0),hl
0B21CC             0449*   
0B21CC             0450*   ; clear target buffer
0B21CC CD 5F 21 0B 0451*       call vdu_clear_buffer
0B21D0             0452*   
0B21D0             0453*   ; open the file in read mode
0B21D0             0454*   ; Open a file
0B21D0             0455*   ; HLU: Filename
0B21D0             0456*   ;   C: Mode
0B21D0             0457*   ; Returns:
0B21D0             0458*   ;   A: Filehandle, or 0 if couldn't open
0B21D0 FD E5       0459*   	push iy ; pointer to filename
0B21D2 E1          0460*   	pop hl
0B21D3 0E 01       0461*   	ld c,fa_read
0B21D5             0462*       MOSCALL mos_fopen
0B21D5 3E 0A       0001*M  			LD	A, function
0B21D7 5B CF       0002*M  			RST.L	08h
0B21D9 32 14 22 0B 0463*       ld (@filehandle),a
0B21DD             0464*   
0B21DD             0465*   @read_file:
0B21DD             0466*   ; Read a block of data from a file
0B21DD             0467*   ;   C: Filehandle
0B21DD             0468*   ; HLU: Pointer to where to write the data to
0B21DD             0469*   ; DEU: Number of bytes to read
0B21DD             0470*   ; Returns:
0B21DD             0471*   ; DEU: Number of bytes read
0B21DD 3A 14 22 0B 0472*       ld a,(@filehandle)
0B21E1 4F          0473*       ld c,a
0B21E2 21 00 E0 B7 0474*       ld hl,filedata
0B21E6 11 00 20 00 0475*       ld de,8192 ; max we can read into onboard sram at one time
0B21EA             0476*       MOSCALL mos_fread
0B21EA 3E 1A       0001*M  			LD	A, function
0B21EC 5B CF       0002*M  			RST.L	08h
0B21EE             0477*   
0B21EE             0478*   ; ; DEBUG: print chunk size
0B21EE             0479*   ;     push de
0B21EE             0480*   ;     pop hl
0B21EE             0481*   ;     call printDec
0B21EE             0482*   ;     call printNewLine
0B21EE             0483*   
0B21EE             0484*   ; test de for zero bytes read
0B21EE 21 00 00 00 0485*       ld hl,0
0B21F2 AF          0486*       xor a ; clear carry
0B21F3 ED 52       0487*       sbc hl,de
0B21F5 CA 0B 22 0B 0488*       jp z,@close_file
0B21F9             0489*   
0B21F9             0490*   ; load a vdu buffer from local memory
0B21F9             0491*   ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B21F9 2A 2D 21 0B 0492*       ld hl,(bufferId0)
0B21FD D5          0493*       push de ; chunksize
0B21FE C1          0494*       pop bc
0B21FF 11 00 E0 B7 0495*       ld de,filedata
0B2203 CD 33 21 0B 0496*       call vdu_load_buffer
0B2207             0497*   
0B2207             0498*   ; ; print progress breadcrumbs
0B2207             0499*   ;     ld a,'.'
0B2207             0500*   ;     rst.lil 10h
0B2207             0501*   
0B2207             0502*   ; read the next block
0B2207 C3 DD 21 0B 0503*       jp @read_file
0B220B             0504*   
0B220B             0505*   ; close the file
0B220B             0506*   @close_file:
0B220B 3A 14 22 0B 0507*       ld a,(@filehandle)
0B220F             0508*       MOSCALL mos_fclose
0B220F 3E 0B       0001*M  			LD	A, function
0B2211 5B CF       0002*M  			RST.L	08h
0B2213 C9          0509*       ret ; vdu_load_buffer_from_file
0B2214             0510*   
0B2214 00          0511*   @filehandle: db 0 ; file handle
0B2215 00 00 00    0512*   @fil: dl 0 ; pointer to FIL struct
0B2218             0513*   
0B2218 00 00 00    0514*   @chunkpointer: dl 0 ; pointer to current chunk
0B221B             0515*   
0B221B             0516*   ; File information structure (FILINFO)
0B221B             0517*   @filinfo:
0B221B 00 00 00 00 0518*   @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B221F 00 00       0519*   @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B2221 00 00       0520*   @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B2223 00          0521*   @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B2224 00 00 00 00 0522*   @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B2231 00 00 00 00 0523*   @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B2331             0027        ; include "vdu_fonts.inc"
0B2331             0028        include "vdu_plot.inc"
0B2331             0001*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B2331             0002*   ; PLOT code 	(Decimal) 	Effect
0B2331             0003*   ; &00-&07 	0-7 	Solid line, includes both ends
0B2331             0004*   plot_sl_both: equ 0x00
0B2331             0005*   
0B2331             0006*   ; &08-&0F 	8-15 	Solid line, final point omitted
0B2331             0007*   plot_sl_first: equ 0x08
0B2331             0008*   
0B2331             0009*   ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B2331             0010*   ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B2331             0011*   
0B2331             0012*   ; &20-&27 	32-39 	Solid line, first point omitted
0B2331             0013*   plot_sl_last: equ 0x20
0B2331             0014*   
0B2331             0015*   ; &28-&2F 	40-47 	Solid line, both points omitted
0B2331             0016*   plot_sl_none: equ 0x28
0B2331             0017*   
0B2331             0018*   ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B2331             0019*   ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B2331             0020*   
0B2331             0021*   ; &40-&47 	64-71 	Point plot
0B2331             0022*   plot_pt: equ 0x40
0B2331             0023*   
0B2331             0024*   ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B2331             0025*   plot_lf_lr_non_bg: equ 0x48
0B2331             0026*   
0B2331             0027*   ; &50-&57 	80-87 	Triangle fill
0B2331             0028*   plot_tf: equ 0x50
0B2331             0029*   
0B2331             0030*   ; &58-&5F 	88-95 	Line fill right to background 
0B2331             0031*   plot_lf_r_bg: equ 0x58
0B2331             0032*   
0B2331             0033*   ; &60-&67 	96-103 	Rectangle fill
0B2331             0034*   plot_rf: equ 0x60
0B2331             0035*   
0B2331             0036*   ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B2331             0037*   plot_lf_lr_fg: equ 0x60
0B2331             0038*   
0B2331             0039*   ; &70-&77 	112-119 	Parallelogram fill
0B2331             0040*   plot_pf: equ 0x70
0B2331             0041*   
0B2331             0042*   ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B2331             0043*   plot_lf_r_non_fg: equ 0x78
0B2331             0044*   
0B2331             0045*   ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B2331             0046*   ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B2331             0047*   
0B2331             0048*   ; &90-&97 	144-151 	Circle outline
0B2331             0049*   plot_co: equ 0x90
0B2331             0050*   
0B2331             0051*   ; &98-&9F 	152-159 	Circle fill
0B2331             0052*   plot_cf: equ 0x98
0B2331             0053*   
0B2331             0054*   ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B2331             0055*   ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B2331             0056*   ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B2331             0057*   
0B2331             0058*   ; &B8-&BF 	184-191 	Rectangle copy/move
0B2331             0059*   plot_rcm: equ 0xB8
0B2331             0060*   
0B2331             0061*   ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B2331             0062*   ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B2331             0063*   ; &D0-&D7 	208-215 	Not defined
0B2331             0064*   ; &D8-&DF 	216-223 	Not defined
0B2331             0065*   ; &E0-&E7 	224-231 	Not defined
0B2331             0066*   
0B2331             0067*   ; &E8-&EF 	232-239 	Bitmap plot 
0B2331             0068*   plot_bmp: equ 0xE8
0B2331             0069*   
0B2331             0070*   ; &F0-&F7 	240-247 	Not defined
0B2331             0071*   ; &F8-&FF 	248-255 	Not defined
0B2331             0072*   
0B2331             0073*   ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B2331             0074*   ; Agon Console8 VDP 2.2.0
0B2331             0075*   
0B2331             0076*   ; Within each group of eight plot codes, the effects are as follows:
0B2331             0077*   ; Plot code 	Effect
0B2331             0078*   ; 0 	Move relative
0B2331             0079*   mv_rel: equ 0
0B2331             0080*   
0B2331             0081*   ; 1 	Plot relative in current foreground colour
0B2331             0082*   dr_rel_fg: equ 1
0B2331             0083*   
0B2331             0084*   ; 2 	Not supported (Plot relative in logical inverse colour)
0B2331             0085*   ; 3 	Plot relative in current background colour
0B2331             0086*   dr_rel_bg: equ 3
0B2331             0087*   
0B2331             0088*   ; 4 	Move absolute
0B2331             0089*   mv_abs: equ 4
0B2331             0090*   
0B2331             0091*   ; 5 	Plot absolute in current foreground colour
0B2331             0092*   dr_abs_fg: equ 5
0B2331             0093*   
0B2331             0094*   ; 6 	Not supported (Plot absolute in logical inverse colour)
0B2331             0095*   ; 7 	Plot absolute in current background colour
0B2331             0096*   dr_abs_bg: equ 7
0B2331             0097*   
0B2331             0098*   ; Codes 0-3 use the position data provided as part of the command
0B2331             0099*   ; as a relative position, adding the position given to the current
0B2331             0100*   ; graphical cursor position. Codes 4-7 use the position data provided
0B2331             0101*   ; as part of the command as an absolute position, setting the current
0B2331             0102*   ; graphical cursor position to the position given.
0B2331             0103*   
0B2331             0104*   ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B2331             0105*   ; current pixel colour. These operations cannot currently be supported
0B2331             0106*   ; by the graphics system the Agon VDP uses, so these codes are not
0B2331             0107*   ; supported. Support for these codes may be added in a future version
0B2331             0108*   ; of the VDP firmware.
0B2331             0109*   
0B2331             0110*   ; 16 colour palette constants
0B2331             0111*   c_black: equ 0
0B2331             0112*   c_red_dk: equ 1
0B2331             0113*   c_green_dk: equ 2
0B2331             0114*   c_yellow_dk: equ 3
0B2331             0115*   c_blue_dk: equ 4
0B2331             0116*   c_magenta_dk: equ 5
0B2331             0117*   c_cyan_dk: equ 6
0B2331             0118*   c_grey: equ 7
0B2331             0119*   c_grey_dk: equ 8
0B2331             0120*   c_red: equ 9
0B2331             0121*   c_green: equ 10
0B2331             0122*   c_yellow: equ 11
0B2331             0123*   c_blue: equ 12
0B2331             0124*   c_magenta: equ 13
0B2331             0125*   c_cyan: equ 14
0B2331             0126*   c_white: equ 15
0B2331             0127*   
0B2331             0128*   ; VDU 25, mode, x; y;: PLOT command
0B2331             0129*   ; inputs: a=mode, bc=x0, de=y0
0B2331             0130*   vdu_plot:
0B2331 32 4B 23 0B 0131*       ld (@mode),a
0B2335 ED 43 4C 23 0132*       ld (@x0),bc
       0B          
0B233A ED 53 4E 23 0133*       ld (@y0),de
       0B          
0B233F 21 4A 23 0B 0134*   	ld hl,@cmd
0B2343 01 06 00 00 0135*   	ld bc,@end-@cmd
0B2347 5B DF       0136*   	rst.lil $18
0B2349 C9          0137*   	ret
0B234A 19          0138*   @cmd:   db 25
0B234B 00          0139*   @mode:  db 0
0B234C 00 00       0140*   @x0: 	dw 0
0B234E 00 00       0141*   @y0: 	dw 0
0B2350 00          0142*   @end:   db 0 ; extra byte to soak up deu
0B2351             0143*   
0B2351             0144*   ; VDU 25, mode, x; y;: PLOT command
0B2351             0145*   ; USING 16.8 FIXED POINT COORDINATES
0B2351             0146*   ; inputs: a=mode, ub.c=x0, ud.e=y0
0B2351             0147*   vdu_plot_168:
0B2351 ED 53 6D 23 0148*       ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
       0B          
0B2356 ED 43 6B 23 0149*       ld (@x0-1),bc ; integer portion only
       0B          
0B235B 32 6B 23 0B 0150*       ld (@mode),a  ; load this order b/c we shifted bc right
0B235F 21 6A 23 0B 0151*   	ld hl,@cmd
0B2363 01 06 00 00 0152*   	ld bc,@end-@cmd
0B2367 5B DF       0153*   	rst.lil $18
0B2369             0154*       ; ld hl,@cmd
0B2369             0155*       ; ld a,6
0B2369             0156*       ; call dumpMemoryHex
0B2369             0157*       ; call printNewLine
0B2369 C9          0158*   	ret
0B236A 19          0159*   @cmd:   db 25
0B236B 00          0160*   @mode:  db 0
0B236C 00 00       0161*   @x0: 	dw 0
0B236E 00 00       0162*   @y0: 	dw 0
0B2370             0163*   @end:  ; no padding required b/c we shifted de right
0B2370             0164*   
0B2370             0165*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B2370             0166*   ; &E8-&EF 	232-239 	Bitmap plot 
0B2370             0167*   ; VDU 25, mode, x; y;: PLOT command
0B2370             0168*   ; inputs: bc=x0, de=y0
0B2370             0169*   ; prerequisites: vdu_buff_select
0B2370             0170*   vdu_plot_bmp:
0B2370 ED 43 87 23 0171*       ld (@x0),bc
       0B          
0B2375 ED 53 89 23 0172*       ld (@y0),de
       0B          
0B237A 21 85 23 0B 0173*   	ld hl,@cmd
0B237E 01 06 00 00 0174*   	ld bc,@end-@cmd
0B2382 5B DF       0175*   	rst.lil $18
0B2384 C9          0176*   	ret
0B2385 19          0177*   @cmd:   db 25
0B2386 ED          0178*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B2387 00 00       0179*   @x0: 	dw 0x0000
0B2389 00 00       0180*   @y0: 	dw 0x0000
0B238B 00          0181*   @end:   db 0x00 ; padding
0B238C             0182*   
0B238C             0183*   ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B238C             0184*   ; &E8-&EF 	232-239 	Bitmap plot 
0B238C             0185*   ; VDU 25, mode, x; y;: PLOT command
0B238C             0186*   ; inputs: bc=x0, de=y0
0B238C             0187*   ; USING 16.8 FIXED POINT COORDINATES
0B238C             0188*   ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B238C             0189*   ;   the fractional portiion of the inputs are truncated
0B238C             0190*   ;   leaving only the 16-bit integer portion
0B238C             0191*   ; prerequisites: vdu_buff_select
0B238C             0192*   vdu_plot_bmp168:
0B238C             0193*   ; populate in the reverse of normal to keep the
0B238C             0194*   ; inputs from stomping on each other
0B238C ED 53 AA 23 0195*       ld (@y0-1),de
       0B          
0B2391 ED 43 A8 23 0196*       ld (@x0-1),bc
       0B          
0B2396 3E ED       0197*       ld a,plot_bmp+dr_abs_fg ; 0xED
0B2398 32 A8 23 0B 0198*       ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B239C 21 A7 23 0B 0199*   	ld hl,@cmd
0B23A0 01 06 00 00 0200*   	ld bc,@end-@cmd
0B23A4 5B DF       0201*   	rst.lil $18
0B23A6 C9          0202*   	ret
0B23A7 19          0203*   @cmd:   db 25
0B23A8 ED          0204*   @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B23A9 00 00       0205*   @x0: 	dw 0x0000
0B23AB 00 00       0206*   @y0: 	dw 0x0000
0B23AD             0207*   @end:  ; no padding required b/c we shifted de right
0B23AD             0208*   
0B23AD             0209*   ; draw a filled rectangle
0B23AD             0210*   vdu_plot_rf:
0B23AD ED 43 D4 23 0211*       ld (@x0),bc
       0B          
0B23B2 ED 53 D6 23 0212*       ld (@y0),de
       0B          
0B23B7 DD 22 DA 23 0213*       ld (@x1),ix
       0B          
0B23BC FD 22 DC 23 0214*       ld (@y1),iy
       0B          
0B23C1 3E 19       0215*       ld a,25 ; we have to reload the 2nd plot command
0B23C3 32 D8 23 0B 0216*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B23C7 21 D2 23 0B 0217*   	ld hl,@cmd0
0B23CB 01 0C 00 00 0218*   	ld bc,@end-@cmd0
0B23CF 5B DF       0219*   	rst.lil $18
0B23D1 C9          0220*       ret
0B23D2 19          0221*   @cmd0:  db 25 ; plot
0B23D3 04          0222*   @arg0:  db plot_sl_both+mv_abs
0B23D4 00 00       0223*   @x0:    dw 0x0000
0B23D6 00 00       0224*   @y0:    dw 0x0000
0B23D8 19          0225*   @cmd1:  db 25 ; plot
0B23D9 65          0226*   @arg1:  db plot_rf+dr_abs_fg
0B23DA 00 00       0227*   @x1:    dw 0x0000
0B23DC 00 00       0228*   @y1:    dw 0x0000
0B23DE 00          0229*   @end:   db 0x00 ; padding
0B23DF             0230*   
0B23DF             0231*   ; draw a filled circle
0B23DF             0232*   vdu_plot_cf:
0B23DF ED 43 06 24 0233*       ld (@x0),bc
       0B          
0B23E4 ED 53 08 24 0234*       ld (@y0),de
       0B          
0B23E9 DD 22 0C 24 0235*       ld (@x1),ix
       0B          
0B23EE FD 22 0E 24 0236*       ld (@y1),iy
       0B          
0B23F3 3E 19       0237*       ld a,25 ; we have to reload the 2nd plot command
0B23F5 32 0A 24 0B 0238*       ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B23F9 21 04 24 0B 0239*   	ld hl,@cmd0
0B23FD 01 0C 00 00 0240*   	ld bc,@end-@cmd0
0B2401 5B DF       0241*   	rst.lil $18
0B2403 C9          0242*       ret
0B2404 19          0243*   @cmd0:  db 25 ; plot
0B2405 04          0244*   @arg0:  db plot_sl_both+mv_abs
0B2406 00 00       0245*   @x0:    dw 0x0000
0B2408 00 00       0246*   @y0:    dw 0x0000
0B240A 19          0247*   @cmd1:  db 25 ; plot
0B240B 9D          0248*   @arg1:  db plot_cf+dr_abs_fg
0B240C 00 00       0249*   @x1:    dw 0x0000
0B240E 00 00       0250*   @y1:    dw 0x0000
0B2410 00          0251*   @end:   db 0x00 ; padding
0B2411             0252*   
0B2411             0253*   ; VDU 25, mode, x; y;: PLOT command
0B2411             0254*   ; inputs: a=mode, ix=x0, iy=y0
0B2411             0255*   plot:
0B2411 32 2B 24 0B 0256*       ld (@mode),a
0B2415 DD 22 2C 24 0257*       ld (@x0),ix
       0B          
0B241A FD 22 2E 24 0258*       ld (@y0),iy
       0B          
0B241F 21 2A 24 0B 0259*   	ld hl,@cmd
0B2423 01 06 00 00 0260*   	ld bc,@end-@cmd
0B2427 5B DF       0261*   	rst.lil $18
0B2429 C9          0262*   	ret
0B242A 19          0263*   @cmd:   db 25
0B242B 00          0264*   @mode:  db 0
0B242C 00 00       0265*   @x0: 	dw 0
0B242E 00 00       0266*   @y0: 	dw 0
0B2430 00          0267*   @end:   db 0 ; padding
0B2431             0268*   
0B2431             0269*   ; VDU 5: Write text at graphics cursor
0B2431             0270*   ; inputs: hl = pointer to text, ix=x0, iy=y0
0B2431             0271*   ; prerequisites: gcol foreground set, VDU 5 set
0B2431             0272*   plot_text:
0B2431 E5          0273*       push hl ; save text pointer
0B2432             0274*   ; move graphics cursor to x0, y0
0B2432 3E 44       0275*       ld a,plot_pt+mv_abs
0B2434 CD 11 24 0B 0276*       call plot
0B2438             0277*   ; write text
0B2438 E1          0278*       pop hl ; restore text pointer
0B2439 CD 73 02 0B 0279*       call printString
0B243D C9          0280*       ret
0B243E             0029    
0B243E             0030    ; SHAWN'S INCLUDES
0B243E             0031    	INCLUDE	"strings24.asm"
0B243E             0001*   ;------------------------------------------------------------------------
0B243E             0002*   ;  strings24.asm
0B243E             0003*   ;
0B243E             0004*   ; 24-bit native ez80 strings routines for numerical processing
0B243E             0005*   ;  Copyright (c) Shawn Sijnstra 2024
0B243E             0006*   ;  MIT license
0B243E             0007*   ;------------------------------------------------------------------------
0B243E             0008*   
0B243E             0009*   ;Print signed value in HLU in decimal with leading 0s removed
0B243E             0010*   ; and postpended with a minus sign if was negative
0B243E             0011*   ; Uses HLU, DEU, BCU
0B243E             0012*   print_HLU_s24:
0B243E CD 51 08 0B 0013*   	call hlu_abs
0B2442 F5          0014*   	push af ; save the sign and zero flags
0B2443 CD 4E 24 0B 0015*   	call print_HLU_u24
0B2447 F1          0016*   	pop af
0B2448 F0          0017*   	ret p ; HLU was positive so nothig more to do
0B2449 3E 2D       0018*   	ld a,'-'
0B244B 5B D7       0019*   	rst.lil 10h
0B244D C9          0020*   	ret
0B244E             0021*   
0B244E             0022*   ;------------------------------------------------------------------------
0B244E             0023*   ;Full print and buffer routine so you can adjust behaviour
0B244E             0024*   ; Double-Dabble AKA shift-and-add-3 algorithm
0B244E             0025*   ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B244E             0026*   ;Print value in HLU in decimal with leading 0s removed
0B244E             0027*   ; Uses HLU, DEU, BCU
0B244E             0028*   ;------------------------------------------------------------------------
0B244E             0029*   
0B244E             0030*   print_HLU_u24:
0B244E 22 2B 25 0B 0031*   	ld	(hex_temp),hl
0B2452 06 08       0032*   	ld	b,8	;8 digits max here with 24 bit unsigned
0B2454 11 2E 25 0B 0033*   	ld	de,outbuf
0B2458 D5          0034*   	push	de
0B2459 21 07 00 00 0035*   	ld	hl,7
0B245D 19          0036*   	add	hl,de
0B245E E5          0037*   	push	hl
0B245F D1          0038*   	pop	de	;copy HLU to DEU
0B2460 AF          0039*   	xor	a
0B2461             0040*   _pde_u_zerobuf:
0B2461 77          0041*   	ld	(hl),a	;zero out the output
0B2462 2B          0042*   	dec	hl
0B2463 10 FC       0043*   	djnz	_pde_u_zerobuf
0B2465             0044*   
0B2465 0E 18       0045*   	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B2467             0046*   _bcd_Convert:
0B2467             0047*   
0B2467 21 2B 25 0B 0048*   	ld hl,hex_temp
0B246B             0049*   ;
0B246B CB 26       0050*   	sla (hl)
0B246D 23          0051*   	inc hl
0B246E CB 16       0052*   	rl (hl)
0B2470 23          0053*   	inc hl
0B2471 CB 16       0054*   	rl (hl)		;24 bits rolled right
0B2473             0055*   
0B2473             0056*   
0B2473 06 08       0057*           ld	b,8	;8 digits max for 24 bit decimal output
0B2475 D5          0058*   	push	de
0B2476 E1          0059*   	pop	hl
0B2477             0060*   
0B2477             0061*   _bcd_Add3:
0B2477 7E          0062*   	ld	a,(hl)
0B2478 8F          0063*   	adc	a
0B2479 27          0064*           daa		;this is add 3 after shifting left; i.e. add 6.
0B247A FE 10       0065*   	cp	10h	;did we roll over nibble?
0B247C 3F          0066*   	ccf
0B247D CB A7       0067*   	res	4,a
0B247F             0068*   
0B247F 77          0069*           ld (hl),a
0B2480 2B          0070*   	dec	hl
0B2481 10 F4       0071*           djnz	_bcd_Add3	;loop for decimal digits
0B2483 0D          0072*           dec c
0B2484 20 E1       0073*           jr nz, _bcd_Convert	;loop around
0B2486             0074*   
0B2486             0075*   
0B2486 E1          0076*   	pop	hl
0B2487 E5          0077*   	push	hl
0B2488 06 07       0078*           ld	b,8-1		;one less than total in case output is '0'
0B248A             0079*   _pde_u_make_ascii:
0B248A 7E          0080*   	ld	a,(hl)
0B248B B7          0081*   	or	a
0B248C 20 05       0082*   	jr	nz,_pde_u_make_ascii2
0B248E 36 20       0083*   	ld	(hl),' '
0B2490 23          0084*   	inc	hl
0B2491 10 F7       0085*   	djnz	_pde_u_make_ascii
0B2493             0086*   _pde_u_make_ascii2:
0B2493 04          0087*   	inc	b
0B2494             0088*   _pde_u_make_ascii3:
0B2494 7E          0089*   	ld	a,(hl)
0B2495 F6 30       0090*   	or	30h
0B2497 77          0091*   	ld	(hl),a
0B2498 23          0092*   	inc	hl
0B2499 10 F9       0093*   	djnz	_pde_u_make_ascii3
0B249B             0094*   
0B249B E1          0095*   	pop	hl
0B249C 06 08       0096*   	ld	b,8
0B249E             0097*   _pde_u_final_out:
0B249E 7E          0098*   	ld	a,(hl)
0B249F 23          0099*   	inc	hl
0B24A0 FE 20       0100*   	cp	' '
0B24A2 28 02       0101*   	jr	z,_pde_u_final_out_strip
0B24A4 5B D7       0102*   	rst.lil	10h
0B24A6             0103*   _pde_u_final_out_strip:
0B24A6 10 F6       0104*   	djnz	_pde_u_final_out
0B24A8 C9          0105*   	ret
0B24A9             0106*   
0B24A9             0107*   ;------------------------------------------------------------------------
0B24A9             0108*   ; is_digit
0B24A9             0109*   ; C flag set if A is a digit
0B24A9             0110*   ; preserves all registers
0B24A9             0111*   ;------------------------------------------------------------------------
0B24A9             0112*   is_digit:
0B24A9 FE 30       0113*   	cp	'0'
0B24AB 3F          0114*   	ccf
0B24AC D0          0115*   	ret	nc	;less that '0'
0B24AD FE 3A       0116*   	cp	'9' + 1
0B24AF C9          0117*   	ret
0B24B0             0118*   
0B24B0             0119*   
0B24B0             0120*   ;------------------------------------------------------------------------
0B24B0             0121*   ; char2hex
0B24B0             0122*   ; Input: ASCII nibble in A
0B24B0             0123*   ; Returns: if valid nibble value in A; else 0FFh in A
0B24B0             0124*   ;------------------------------------------------------------------------
0B24B0             0125*   char2hex:
0B24B0 FE 30       0126*   	CP	'0'
0B24B2 38 1D       0127*   	JR	C, char_not_hex
0B24B4 FE 3A       0128*   	CP	'9' + 1
0B24B6 30 03       0129*   	JR	NC, char_not_09
0B24B8 D6 30       0130*   	sub	'0'
0B24BA C9          0131*   	ret
0B24BB             0132*   
0B24BB             0133*   char_not_09:
0B24BB             0134*   	; char is not 0 to 9. Try upper case
0B24BB FE 41       0135*   	CP	'A'
0B24BD 38 12       0136*   	JR	C, char_not_hex
0B24BF FE 47       0137*   	CP	'F' + 1
0B24C1 30 03       0138*   	JR	NC, char_not_AF
0B24C3 D6 37       0139*   	sub	'A'-10
0B24C5 C9          0140*   	ret
0B24C6             0141*   
0B24C6             0142*   char_not_AF:
0B24C6             0143*   	; char is not upper case A-F. Try lower
0B24C6 FE 61       0144*   	CP	'a'
0B24C8 38 07       0145*   	JR	C, char_not_hex
0B24CA FE 67       0146*   	CP	'f' + 1
0B24CC 30 03       0147*   	JR	NC, char_not_hex
0B24CE D6 57       0148*   	sub	'a' - 10
0B24D0 C9          0149*   	RET
0B24D1             0150*   
0B24D1             0151*   char_not_hex:
0B24D1 3E FF       0152*    	ld	a,0FFh	;return -1 for not a valid hex digit
0B24D3 C9          0153*   	RET
0B24D4             0154*   
0B24D4             0155*   ;------------------------------------------------------------------------
0B24D4             0156*   ;  newline
0B24D4             0157*   ;  Output CR+LF; all registers preserved
0B24D4             0158*   ;------------------------------------------------------------------------
0B24D4             0159*   newline:
0B24D4 F5          0160*          push   AF
0B24D5 3E 0D       0161*          LD     A, 13
0B24D7 5B D7       0162*          RST.LIL    10h
0B24D9 3E 0A       0163*          LD     A, 10
0B24DB 5B D7       0164*          RST.LIL    10h
0B24DD F1          0165*          POP    AF
0B24DE C9          0166*          RET
0B24DF             0167*   
0B24DF             0168*   ;------------------------------------------------------------------------
0B24DF             0169*   ;  put_nibble
0B24DF             0170*   ;  Output a single hex nibble in A
0B24DF             0171*   ;  All registers preserved
0B24DF             0172*   ;------------------------------------------------------------------------
0B24DF             0173*   put_nibble:
0B24DF F5          0174*   	push   AF
0B24E0 C6 90       0175*   	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B24E2 27          0176*   	daa
0B24E3 CE 40       0177*   	adc    a,040h
0B24E5 27          0178*   	daa
0B24E6 5B D7       0179*   	RST.LIL    10h	;output character in A
0B24E8 F1          0180*   	pop    AF
0B24E9 C9          0181*   	ret
0B24EA             0182*   
0B24EA             0183*   ;------------------------------------------------------------------------
0B24EA             0184*   ;  print_A
0B24EA             0185*   ;  Output the 8-bit hex number A
0B24EA             0186*   ;  All registers preserved
0B24EA             0187*   ;------------------------------------------------------------------------
0B24EA             0188*   print_A:
0B24EA F5          0189*   	push 	AF
0B24EB F5          0190*   	push 	AF	;save for second nibble
0B24EC 0F          0191*   	rrca
0B24ED 0F          0192*   	rrca
0B24EE 0F          0193*   	rrca
0B24EF 0F          0194*   	rrca
0B24F0 E6 0F       0195*   	and	0Fh	;first nibble
0B24F2 CD DF 24 0B 0196*   	call	put_nibble
0B24F6 F1          0197*   	pop 	AF
0B24F7 E6 0F       0198*   	and	0Fh	;second nibble
0B24F9 CD DF 24 0B 0199*   	call	put_nibble
0B24FD F1          0200*   	pop 	AF
0B24FE C9          0201*   	ret
0B24FF             0202*   
0B24FF             0203*   ;------------------------------------------------------------------------
0B24FF             0204*   ;  print_HLU_hex
0B24FF             0205*   ;  Output the 24-bit hex number HLU; other registers preserved
0B24FF             0206*   ;------------------------------------------------------------------------
0B24FF             0207*   print_HLU_hex:
0B24FF F5          0208*          push   AF
0B2500 22 2B 25 0B 0209*          ld     (hex_temp),hl
0B2504 3A 2D 25 0B 0210*          ld     a,(hex_temp+2)
0B2508 CD EA 24 0B 0211*          call   print_A
0B250C 3A 2C 25 0B 0212*          ld     a,(hex_temp+1)
0B2510 CD EA 24 0B 0213*          call   print_A
0B2514 3A 2B 25 0B 0214*          ld     a,(hex_temp)
0B2518 CD EA 24 0B 0215*          call   print_A
0B251C F1          0216*          POP    AF
0B251D C9          0217*          RET
0B251E             0218*   
0B251E             0219*   ;------------------------------------------------------------------------
0B251E             0220*   ;  puts
0B251E             0221*   ;  Output a zero-terminated string whose address is in HL; all
0B251E             0222*   ;  registers preserved.
0B251E             0223*   ;------------------------------------------------------------------------
0B251E             0224*   puts:
0B251E F5          0225*          push   AF
0B251F C5          0226*          push   BC
0B2520 01 00 00 00 0227*          ld     BC, 0                ; Set to 0, so length ignored...
0B2524 3E 00       0228*          ld     A, 0                 ; Use character in A as delimiter
0B2526 5B DF       0229*          RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B2528 C1          0230*          pop    BC
0B2529 F1          0231*          pop    AF
0B252A C9          0232*          ret
0B252B             0233*   
0B252B             0234*   ;------------------------------------------------------------------------
0B252B             0235*   ; Data area
0B252B             0236*   ; Storage for 24 bit conversion
0B252B             0237*   ;------------------------------------------------------------------------
0B252B             0238*   hex_temp:
0B252B 00 00 00    0239*          dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B252E             0240*   
0B252E             0241*   outbuf:
0B252E 31 36 37 37 0242*   	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B2537             0032    
0B2537             0033    ; BASIC FLOATING POINT FUNCTIONS
0B2537             0034        include "mathfpp.inc"
0B2537             0001*       include "basic/ram.asm"
0B2537             0001**  ;
0B2537             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B2537             0003**  ;		RAM Module for BBC Basic Interpreter
0B2537             0004**  ;		For use with Version 2.0 of BBC BASIC
0B2537             0005**  ;		Standard CP/M Distribution Version
0B2537             0006**  ; Author:	(C) Copyright  R.T.Russell 31-12-1983
0B2537             0007**  ; Modified By:	Dean Belfield
0B2537             0008**  ; Created:	12/05/2023
0B2537             0009**  ; Last Updated:	26/06/2023
0B2537             0010**  ;
0B2537             0011**  ; Modinfo:
0B2537             0012**  ; 06/06/2023:	Modified to run in ADL mode
0B2537             0013**  ; 26/06/2023:	Added temporary stores R0 and R1
0B2537             0014**  
0B2537             0015**  			.ASSUME	ADL = 1
0B2537             0016**  
0B2537             0017**  			; DEFINE	LORAM, SPACE = ROM
0B2537             0018**  			; SEGMENT LORAM
0B2537             0019**  
0B2537             0020**  			; XDEF	ACCS
0B2537             0021**  			; XDEF	BUFFER
0B2537             0022**  			; XDEF	STAVAR
0B2537             0023**  			; XDEF	DYNVAR
0B2537             0024**  			; XDEF	FNPTR
0B2537             0025**  			; XDEF	PROPTR
0B2537             0026**  			; XDEF	PAGE_
0B2537             0027**  			; XDEF	TOP
0B2537             0028**  			; XDEF	LOMEM
0B2537             0029**  			; XDEF 	FREE
0B2537             0030**  			; XDEF	HIMEM
0B2537             0031**  			; XDEF	LINENO
0B2537             0032**  			; XDEF	TRACEN
0B2537             0033**  			; XDEF	AUTONO
0B2537             0034**  			; XDEF	ERRTRP
0B2537             0035**  			; XDEF	ERRTXT
0B2537             0036**  			; XDEF	DATPTR
0B2537             0037**  			; XDEF	ERL
0B2537             0038**  			; XDEF	ERRLIN
0B2537             0039**  			; XDEF	RANDOM
0B2537             0040**  			; XDEF	COUNT
0B2537             0041**  			; XDEF	WIDTH
0B2537             0042**  			; XDEF	ERR
0B2537             0043**  			; XDEF	LISTON
0B2537             0044**  			; XDEF	INCREM
0B2537             0045**  
0B2537             0046**  			; XDEF	FLAGS
0B2537             0047**  			; XDEF	OSWRCHPT
0B2537             0048**  			; XDEF	OSWRCHCH
0B2537             0049**  			; XDEF	OSWRCHFH
0B2537             0050**  			; XDEF	KEYDOWN
0B2537             0051**  			; XDEF	KEYASCII
0B2537             0052**  			; XDEF	KEYCOUNT
0B2537             0053**  
0B2537             0054**  			; XDEF	R0
0B2537             0055**  			; XDEF	R1
0B2537             0056**  
0B2537             0057**  			; XDEF	RAM_START
0B2537             0058**  			; XDEF	RAM_END
0B2537             0059**  			; XDEF	USER
0B2537             0060**  
0B2537 FF FF FF FF 0061**  			ALIGN 		256		; ACCS, BUFFER & STAVAR must be on page boundaries
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
0B2600             0062**  RAM_START:
0B2600             0063**  ;
0B2600             0064**  ACCS:			DS		256             ; String Accumulator
0B2700             0065**  BUFFER:			DS		256             ; String Input Buffer
0B2800             0066**  STAVAR:			DS	 	27*4            ; Static Variables
0B286C             0067**  DYNVAR: 		DS 		54*3            ; Dynamic Variable Pointers
0B290E             0068**  FNPTR:  		DS    		3               ; Dynamic Function Pointers
0B2911             0069**  PROPTR: 		DS		3               ; Dynamic Procedure Pointers
0B2914             0070**  ;
0B2914             0071**  PAGE_:   		DS		3               ; Start of User Program
0B2917             0072**  TOP:    		DS		3               ; First Location after User Program
0B291A             0073**  LOMEM:  		DS		3               ; Start of Dynamic Storage
0B291D             0074**  FREE:   		DS		3               ; First Free Space Byte
0B2920             0075**  HIMEM:  		DS		3               ; First Protected Byte
0B2923             0076**  ;
0B2923             0077**  LINENO: 		DS		3               ; Line Number
0B2926             0078**  TRACEN:			DS		3               ; Trace Flag
0B2929             0079**  AUTONO:			DS		3               ; Auto Flag
0B292C             0080**  ERRTRP:			DS		3               ; Error Trap
0B292F             0081**  ERRTXT:			DS		2               ; Error Message Pointer
0B2931             0082**  DATPTR:			DS		2               ; Data Pointer
0B2933             0083**  ERL:			DS		2               ; Error Line
0B2935             0084**  ERRLIN:			DS		3               ; The "ON ERROR" Line
0B2938             0085**  RANDOM:			DS		5               ; Random Number
0B293D             0086**  COUNT:			DS		1               ; Print Position
0B293E             0087**  WIDTH:			DS		1               ; Print Width
0B293F             0088**  ERR:			DS		1               ; Error Number
0B2940             0089**  LISTON:			DS		1               ; LISTO (bottom nibble)
0B2941             0090**  							; - BIT 0: If set, output a space after the line number
0B2941             0091**  							; - BIT 1: If set, then indent FOR/NEXT loops
0B2941             0092**  							; - BIT 2: If set, then indent REPEAT/UNTIL loops
0B2941             0093**  							; - BIT 3: If set, then output to buffer for *EDIT
0B2941             0094**  							; OPT FLAG (top nibble)
0B2941             0095**  							; - BIT 4: If set, then list whilst assembling
0B2941             0096**  							; - BIT 5: If set, then assembler errors are reported
0B2941             0097**  							; - BIT 6: If set, then place the code starting at address pointed to by O%
0B2941             0098**  							; - BIT 7: If set, then assemble in ADL mode, otherwise assemble in Z80 mode
0B2941             0099**  INCREM:			DS		1               ; Auto-Increment Value
0B2942             0100**  ;
0B2942             0101**  ; Extra Agon-implementation specific system variables
0B2942             0102**  ;
0B2942             0103**  FLAGS:			DS		1		; Miscellaneous flags
0B2943             0104**  							; - BIT 7: Set if ESC pressed
0B2943             0105**  							; - BIT 6: Set to disable ESC
0B2943             0106**  OSWRCHPT:		DS		2		; Pointer for *EDIT
0B2945             0107**  OSWRCHCH:		DS		1		; Channel of OSWRCH
0B2946             0108**  							; - 0: Console
0B2946             0109**  							; - 1: File
0B2946             0110**  OSWRCHFH:		DS		1		; File handle for OSWRCHCHN
0B2947             0111**  KEYDOWN:		DS		1		; Keydown flag
0B2948             0112**  KEYASCII:		DS		1		; ASCII code of pressed key
0B2949             0113**  KEYCOUNT:		DS		1		; Counts every time a key is pressed
0B294A             0114**  R0:			DS		3		; General purpose storage for 8/16 to 24 bit operations
0B294D             0115**  R1:			DS		3		;
0B2950             0116**  ;
0B2950             0117**  ; This must be at the end
0B2950             0118**  ;
0B2950             0119**  RAM_END:
0B2950 FF FF FF FF 0120**  			ALIGN	256
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B2A00             0121**  USER:							; Must be aligned on a page boundary
0B2A00             0122**  
0B2A00             0002*       include "basic/eval.asm"
0B2A00             0001**  
0B2A00             0002**  ; ========================================
0B2A00             0003**  ; FROM eval.asm
0B2A00             0004**  ; ----------------------------------------
0B2A00             0005**  
0B2A00             0006**  ;
0B2A00             0007**  ; Title:	BBC Basic Interpreter - Z80 version
0B2A00             0008**  ;		Expression Evaluation & Arithmetic Module - "EVAL"
0B2A00             0009**  ; Author:	(C) Copyright  R.T.Russell  1984
0B2A00             0010**  ; Modified By:	Dean Belfield
0B2A00             0011**  ; Created:	12/05/2023
0B2A00             0012**  ; Last Updated:	17/08/2023
0B2A00             0013**  ;
0B2A00             0014**  ; Modinfo:
0B2A00             0015**  ; 07/06/2023:	Modified to run in ADL mode
0B2A00             0016**  ; 26/06/2023:	Fixed HEX and HEXSTR
0B2A00             0017**  ; 13/08/2023:	Added INKEY(-n) support (requires MOS 1.04)
0B2A00             0018**  ; 17/08/2023:	Added binary constants
0B2A00             0019**  
0B2A00             0020**  			; .ASSUME	ADL = 1
0B2A00             0021**  
0B2A00             0022**  			; include "ram.asm"
0B2A00             0023**  
0B2A00             0024**  			; INCLUDE	"equs.inc"
0B2A00             0025**  			; INCLUDE "macros.inc"
0B2A00             0026**  			; INCLUDE "mos_api.inc"	; In MOS/src
0B2A00             0027**  
0B2A00             0028**  			; include "fpp.asm"
0B2A00             0029**  			; include "snippets.asm"
0B2A00             0030**  
0B2A00             0031**  			; SEGMENT CODE
0B2A00             0032**  
0B2A00             0033**  ; 			XDEF	EXPR
0B2A00             0034**  ; 			XDEF	EXPRN
0B2A00             0035**  ; 			XDEF	EXPRI
0B2A00             0036**  ; 			XDEF	EXPRS
0B2A00             0037**  ; 			XDEF	ITEMI
0B2A00             0038**  ; 			XDEF	LOADN
0B2A00             0039**  ; 			XDEF	LOAD4
0B2A00             0040**  ; 			XDEF	CONS
0B2A00             0041**  ; 			XDEF	LOADS
0B2A00             0042**  ; 			XDEF	SFIX
0B2A00             0043**  ; 			XDEF	VAL0
0B2A00             0044**  ; 			XDEF	SEARCH
0B2A00             0045**  ; 			XDEF	SWAP
0B2A00             0046**  ; 			XDEF	TEST
0B2A00             0047**  ; 			XDEF	DECODE
0B2A00             0048**  ; 			XDEF	HEXSTR
0B2A00             0049**  ; 			XDEF	STR
0B2A00             0050**  ; 			XDEF	ZERO
0B2A00             0051**  ; 			XDEF	PUSHS
0B2A00             0052**  ; 			XDEF	POPS
0B2A00             0053**  ; 			XDEF	COMMA
0B2A00             0054**  ; 			XDEF	BRAKET
0B2A00             0055**  ; 			XDEF	NXT
0B2A00             0056**  ; 			XDEF	COUNT0
0B2A00             0057**  
0B2A00             0058**  ; 			XREF	ADVAL
0B2A00             0059**  ; 			XREF	FN
0B2A00             0060**  ; 			XREF	POINT
0B2A00             0061**  ; 			XREF	USR
0B2A00             0062**  ; 			XREF	SYNTAX
0B2A00             0063**  ; 			XREF	ERROR_
0B2A00             0064**  ; 			XREF	CHECK
0B2A00             0065**  ; 			XREF	GETVAR
0B2A00             0066**  ; 			XREF	LISTON
0B2A00             0067**  ; 			XREF	RANGE
0B2A00             0068**  ; 			XREF	FPP
0B2A00             0069**  ; 			XREF	GETCSR
0B2A00             0070**  ; 			XREF	CHANEL
0B2A00             0071**  ; 			XREF	OSSTAT
0B2A00             0072**  ; 			XREF	OSBGET
0B2A00             0073**  ; 			XREF	LOMEM
0B2A00             0074**  ; 			XREF	HIMEM
0B2A00             0075**  ; 			XREF	PAGE_
0B2A00             0076**  ; 			XREF	TOP
0B2A00             0077**  ; 			XREF	ERL
0B2A00             0078**  ; 			XREF	ERR
0B2A00             0079**  ; 			XREF	COUNT
0B2A00             0080**  ; 			XREF	OSOPEN
0B2A00             0081**  ; 			XREF	GETEXT
0B2A00             0082**  ; 			XREF	GETPTR
0B2A00             0083**  ; 			XREF	GETIME
0B2A00             0084**  ; 			XREF	GETIMS
0B2A00             0085**  ; 			XREF	LEXAN2
0B2A00             0086**  ; 			XREF	RANDOM
0B2A00             0087**  ; 			XREF	STORE5
0B2A00             0088**  ; 			XREF	GETSCHR
0B2A00             0089**  ; 			XREF	OSRDCH
0B2A00             0090**  ; 			XREF	OSKEY
0B2A00             0091**  ; 			XREF	INKEY1
0B2A00             0092**  ; 			XREF	EXTERR
0B2A00             0093**  ;
0B2A00             0094**  ; BINARY FLOATING POINT REPRESENTATION:
0B2A00             0095**  ;    32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B2A00             0096**  ;     8 BIT EXCESS-128 SIGNED EXPONENT
0B2A00             0097**  ;    SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B2A00             0098**  ;    MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B2A00             0099**  ;
0B2A00             0100**  ; BINARY INTEGER REPRESENTATION:
0B2A00             0101**  ;    32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B2A00             0102**  ;     "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B2A00             0103**  ;
0B2A00             0104**  ; NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B2A00             0105**  ;                             EXPONENT - C
0B2A00             0106**  ;
0B2A00             0107**  
0B2A00             0108**  ;
0B2A00             0109**  ; Table of addresses for functions
0B2A00             0110**  ;
0B2A00             0111**  FUNTOK:			EQU	8DH			; First token number
0B2A00             0112**  ;
0B2A00 C5 30 0B    0113**  FUNTBL:			DW24	DECODE			; Line number
0B2A03 15 2E 0B    0114**  			DW24	OPENIN			; OPENIN ; opening a file, we won't be using
0B2A06 18 2E 0B    0115**  			DW24	PTR_EV			; PTR ; related to file handling, we won't be using
0B2A09 AB 2A 0B    0116**  			DW24	PAGE			; PAGE
0B2A0C 19 2E 0B    0117**  			DW24	TIMEV_EV			; TIME ; related to time handling, we won't be using
0B2A0F C6 2D 0B    0118**  			DW24	LOMEMV_EV			; LOMEM
0B2A12 D0 2D 0B    0119**  			DW24	HIMEMV_EV			; HIMEM
0B2A15 56 2E 0B    0120**  			DW24	ABSV_EV			; ABS
0B2A18 92 2E 0B    0121**  			DW24	ACS_EV			; ACS
0B2A1B 1E 46 0B    0122**  			DW24	ADVAL			; ADVAL ; IN sorry.asm, don't need
0B2A1E AF 2D 0B    0123**  			DW24	ASC			; ASC
0B2A21 8A 2E 0B    0124**  			DW24	ASN_EV			; ASN
0B2A24 8E 2E 0B    0125**  			DW24	ATN_EV			; ATN
0B2A27 AB 2D 0B    0126**  			DW24	BGET			; BGET ; get a byte from a file, we won't be using
0B2A2A 76 2E 0B    0127**  			DW24	COS_EV			; COS
0B2A2D 01 2E 0B    0128**  			DW24	COUNTV			; COUNT
0B2A30 5E 2E 0B    0129**  			DW24	DEG_EV			; DEG
0B2A33 F5 2D 0B    0130**  			DW24	ERLV			; ERL
0B2A36 FB 2D 0B    0131**  			DW24	ERRV			; ERR
0B2A39 B7 2E 0B    0132**  			DW24	EVAL_			; EVAL
0B2A3C 7E 2E 0B    0133**  			DW24	EXP_EV			; EXP
0B2A3F 17 2E 0B    0134**  			DW24	EXT_EV			; EXT ; related to file handling, we won't be using
0B2A42 6E 31 0B    0135**  			DW24	ZERO			; FALSE
0B2A45 A4 00 00    0136**  			DW24	FN			; FN
0B2A48 AD 2D 0B    0137**  			DW24	GET			; GET ; reading from keyboard, we won't be using
0B2A4B AC 2D 0B    0138**  			DW24	INKEY			; INKEY ; reading from keyboard, we won't be using
0B2A4E 65 2F 0B    0139**  			DW24	INSTR			; INSTR(
0B2A51 6A 2E 0B    0140**  			DW24	INT_EV_			; INT
0B2A54 BF 2D 0B    0141**  			DW24	LEN			; LEN
0B2A57 82 2E 0B    0142**  			DW24	LN_EV			; LN
0B2A5A 86 2E 0B    0143**  			DW24	LOG_EV			; LOG
0B2A5D 5A 2E 0B    0144**  			DW24	NOTK_EV			; NOT
0B2A60 14 2E 0B    0145**  			DW24	OPENUP			; OPENUP ; related to file handling, we won't be using
0B2A63 13 2E 0B    0146**  			DW24	OPENOT			; OPENOUT ; related to file handling, we won't be using
0B2A66 52 2E 0B    0147**  			DW24	PI_EV			; PI
0B2A69 1C 46 0B    0148**  			DW24	POINT			; POINT( ; in agon_graphics.asm we won't be using
0B2A6C A8 2D 0B    0149**  			DW24	POS			; POS ; related to cursor position, we won't be using
0B2A6F 62 2E 0B    0150**  			DW24	RAD_EV			; RAD
0B2A72 EB 2E 0B    0151**  			DW24	RND			; RND
0B2A75 66 2E 0B    0152**  			DW24	SGN_EV			; SGN
0B2A78 7A 2E 0B    0153**  			DW24	SIN_EV			; SIN
0B2A7B 6E 2E 0B    0154**  			DW24	SQR_EV			; SQR
0B2A7E 72 2E 0B    0155**  			DW24	TAN_EV			; TAN
0B2A81 E4 2D 0B    0156**  			DW24	TOPV			; TO(P)
0B2A84 47 2E 0B    0157**  			DW24	FOR_EV			; FOR
0B2A87 1D 46 0B    0158**  			DW24	USR			; USR ; in exec.asm
0B2A8A A8 2E 0B    0159**  			DW24	VAL_EV			; VAL
0B2A8D A9 2D 0B    0160**  			DW24	VPOS			; VPOS ; related to cursor position, we won't be using
0B2A90 F9 2F 0B    0161**  			DW24	CHRS			; CHRS ; reading from keyboard, we won't be using
0B2A93 FA 2F 0B    0162**  			DW24	GETS			; GETS ; reading from keyboard, we won't be using
0B2A96 FC 2F 0B    0163**  			DW24	INKEYS			; INKEYS ; reading from keyboard, we won't be using
0B2A99 40 30 0B    0164**  			DW24	LEFTS			; LEFTS(
0B2A9C 08 30 0B    0165**  			DW24	MIDS			; MIDS(
0B2A9F 60 30 0B    0166**  			DW24	RIGHTS			; RIGHTS(
0B2AA2 29 31 0B    0167**  			DW24	STRS			; STR$
0B2AA5 81 30 0B    0168**  			DW24	STRING_			; STRINGS(
0B2AA8 AA 2D 0B    0169**  			DW24	EOF			; EOF ; reading from file, we won't be using
0B2AAB             0170**  
0B2AAB C9          0171**  PAGE: ret ; stub function for an item in FUNTBL which doesn't exist
0B2AAC             0172**  ;
0B2AAC             0173**  FUNTBL_END:		EQU	$
0B2AAC             0174**  ; TCMD:			EQU     FUNTOK+(FUNTBL_END-FUNTBL)/3
0B2AAC             0175**  TCMD_EV:			EQU     FUNTBL_END-FUNTBL/3+FUNTOK ; reorder because ez80asm doesn't do order of operations
0B2AAC             0176**  ;
0B2AAC             0177**  ANDK:			EQU     80H
0B2AAC             0178**  DIVK:			EQU     81H
0B2AAC             0179**  EORK:			EQU     82H
0B2AAC             0180**  MODK:			EQU     83H
0B2AAC             0181**  ORK:			EQU     84H
0B2AAC             0182**  ;
0B2AAC 32 2E 0B    0183**  SOPTBL:			DW24	SLE			; <= (STRING)
0B2AAF 3B 2E 0B    0184**  			DW24	SNE			; <>
0B2AB2 2B 2E 0B    0185**  			DW24	SGE			; >=
0B2AB5 1C 2E 0B    0186**  			DW24	SLT			; <
0B2AB8 42 2E 0B    0187**  			DW24	SEQ			; =
0B2ABB 23 2E 0B    0188**  			DW24	SGT			; >
0B2ABE             0189**  ;
0B2ABE             0190**  ; EXPR - VARIABLE-TYPE EXPRESSION EVALUATION
0B2ABE             0191**  ;     Expression type is returned in A'F':
0B2ABE             0192**  ;        Numeric - A' bit 7=0, F' sign bit cleared.
0B2ABE             0193**  ;         String - A' bit 7=1, F' sign bit set.
0B2ABE             0194**  ; Floating-point or integer result returned in HLH'L'C
0B2ABE             0195**  ; Integer result denoted by C=0 and HLH'L' non-zero.
0B2ABE             0196**  ; String result returned in string accumulator, DE set.
0B2ABE             0197**  ;
0B2ABE             0198**  ; Hierarchy is: (1) Variables, functions, constants, bracketed expressions.
0B2ABE             0199**  ;               (2) ^
0B2ABE             0200**  ;               (3) * / MOD DIV
0B2ABE             0201**  ;               (4) + -
0B2ABE             0202**  ;               (5) = <> <= >= > <
0B2ABE             0203**  ;               (6) AND
0B2ABE             0204**  ;               (7) EOR OR
0B2ABE             0205**  
0B2ABE             0206**  ;
0B2ABE             0207**  ; Level 7: EOR and OR
0B2ABE             0208**  ;
0B2ABE CD D7 2A 0B 0209**  EXPR:			CALL    EXPR1			; Get first operator by calling Level 6
0B2AC2 FE 82       0210**  EXPR0A:			CP      EORK            	; Is operator EOR?
0B2AC4 28 03       0211**  			JR      Z,EXPR0B		; Yes, so skip to next bit
0B2AC6 FE 84       0212**  			CP      ORK			; Is operator OR
0B2AC8 C0          0213**  			RET     NZ			; No, so return
0B2AC9             0214**  ;
0B2AC9 CD 18 32 0B 0215**  EXPR0B:			CALL    SAVE_EV            	; Save first operand
0B2ACD CD D7 2A 0B 0216**  			CALL    EXPR1           	; Get second operand
0B2AD1 CD 27 32 0B 0217**  			CALL    DOIT            	; Do the operation
0B2AD5 18 EB       0218**  			JR      EXPR0A          	; And continue
0B2AD7             0219**  ;
0B2AD7             0220**  ; Level 6: AND
0B2AD7             0221**  ;
0B2AD7 CD EC 2A 0B 0222**  EXPR1:			CALL    EXPR2			; Get first operator by calling Level 5
0B2ADB FE 80       0223**  EXPR1A:			CP      ANDK			; Is operator AND?
0B2ADD C0          0224**  			RET     NZ			; No, so return
0B2ADE CD 18 32 0B 0225**  			CALL    SAVE_EV			; Save first operand
0B2AE2 CD EC 2A 0B 0226**  			CALL    EXPR2			; Get second operand
0B2AE6 CD 27 32 0B 0227**  			CALL    DOIT			; Do the operation
0B2AEA 18 EF       0228**  			JR      EXPR1A			; And continue
0B2AEC             0229**  ;
0B2AEC             0230**  ; Level 5: Comparisons
0B2AEC             0231**  ;
0B2AEC CD 59 2B 0B 0232**  EXPR2:			CALL    EXPR3			; Get first operator by calling Level 4
0B2AF0 CD F3 31 0B 0233**  			CALL    RELOP?			; Is it ">", "=" or "<"?
0B2AF4 C0          0234**  			RET     NZ			; No, so return
0B2AF5 47          0235**  			LD      B,A			; Store the first operator in B
0B2AF6 FD 23       0236**  			INC     IY              	; Bump over operator
0B2AF8 CD 4A 32 0B 0237**  			CALL    NXT			;
0B2AFC CD F3 31 0B 0238**  			CALL    RELOP?          	; Is it a compound operator?
0B2B00 20 04       0239**  			JR      NZ,EXPR2B		; No, so skip next bit
0B2B02 FD 23       0240**  			INC     IY			; Bump over operator
0B2B04             0241**  			; CP      B			; Compare with first
0B2B04             0242**  			; JP      Z,SYNTAX        	; Trap illegal combinations ">>", "==", "<<" (but not "><", "=>", "=<")
0B2B04 80          0243**  			ADD     A,B
0B2B05 47          0244**  			LD      B,A			; B: Unique code for the compound operator
0B2B06 78          0245**  EXPR2B:			LD      A,B			; A: Code for the operator/compound operator
0B2B07 08          0246**  			EX      AF,AF'
0B2B08 FA 22 2B 0B 0247**  			JP      M,EXPR2S		; If it is a string, then branch here to handle it
0B2B0C 08          0248**  			EX      AF,AF'
0B2B0D D6 04       0249**  			SUB     4
0B2B0F FE 3A       0250**  			CP      '>'-4
0B2B11 20 02       0251**  			JR      NZ,EXPR2C
0B2B13 C6 02       0252**  			ADD     A,2
0B2B15 CD 1A 32 0B 0253**  EXPR2C:			CALL    SAVE1
0B2B19 CD 59 2B 0B 0254**  			CALL    EXPR3
0B2B1D CD 27 32 0B 0255**  			CALL    DOIT            	; NB: Must NOT be "JP DOIT"
0B2B21 C9          0256**  			RET
0B2B22             0257**  ;
0B2B22 08          0258**  EXPR2S:			EX      AF,AF'			; Handle string comparisons
0B2B23 3D          0259**  			DEC     A
0B2B24 E6 07       0260**  			AND     7
0B2B26 CD 8F 31 0B 0261**  			CALL    PUSHS           	; Save string on the stack
0B2B2A F5          0262**  			PUSH    AF              	; Save the operator
0B2B2B CD 59 2B 0B 0263**  			CALL    EXPR3           	; Get the second string
0B2B2F 08          0264**  			EX      AF,AF'
0B2B30 F2 29 2C 0B 0265**  			JP      P,TYPE_EV_
0B2B34 F1          0266**  			POP     AF
0B2B35 4B          0267**  			LD      C,E             	; Length of string #2
0B2B36 D1          0268**  			POP     DE
0B2B37 21 00 00 00 0269**  			LD      HL,0
0B2B3B 39          0270**  			ADD     HL,SP
0B2B3C 43          0271**  			LD      B,E             	; Length of string #1
0B2B3D D5          0272**  			PUSH    DE
0B2B3E 11 00 26 0B 0273**  			LD      DE,ACCS
0B2B42 EB          0274**  			EX      DE,HL
0B2B43 CD 56 32 0B 0275**  			CALL    DISPT2
0B2B47 D1          0276**  			POP     DE
0B2B48 EB          0277**  			EX      DE,HL
0B2B49 7D          0278**  			LD	A,L
0B2B4A 21 00 00 00 0279**  			LD	HL,0
0B2B4E 6F          0280**  			LD	L,A
0B2B4F 39          0281**  			ADD     HL,SP
0B2B50 F9          0282**  			LD      SP,HL
0B2B51 EB          0283**  			EX      DE,HL
0B2B52 AF          0284**  			XOR     A               	; Numeric marker
0B2B53 4F          0285**  			LD      C,A             	; Integer marker
0B2B54 08          0286**  			EX      AF,AF'
0B2B55 FD 7E 00    0287**  			LD      A,(IY)
0B2B58 C9          0288**  			RET
0B2B59             0289**  ;
0B2B59             0290**  ; Level 4: + and -
0B2B59             0291**  ;
0B2B59 CD B7 2B 0B 0292**  EXPR3:			CALL    EXPR4			; Get first operator by calling Level 3
0B2B5D FE 2D       0293**  EXPR3A:			CP      '-'			; Is it "-"?
0B2B5F 28 09       0294**  			JR      Z,EXPR3B		; Yes, so skip the next bit
0B2B61 FE 2B       0295**  			CP      '+'			; Is it "+"?
0B2B63 C0          0296**  			RET     NZ			; No, so return
0B2B64 08          0297**  			EX      AF,AF'			; Get the type
0B2B65 FA 78 2B 0B 0298**  			JP      M,EXPR3S		; Branch here if string
0B2B69 08          0299**  			EX      AF,AF'
0B2B6A CD 18 32 0B 0300**  EXPR3B:			CALL    SAVE_EV			; Save the first operator
0B2B6E CD B7 2B 0B 0301**  			CALL    EXPR4			; Fetch the second operator
0B2B72 CD 27 32 0B 0302**  			CALL    DOIT			; Do the operation
0B2B76 18 E5       0303**  			JR      EXPR3A			; And continue
0B2B78             0304**  ;
0B2B78 08          0305**  EXPR3S:			EX      AF,AF'			; Handle string concatenation
0B2B79 FD 23       0306**  			INC     IY              	; Bump past the "+"
0B2B7B CD 8F 31 0B 0307**  			CALL    PUSHS           	; Save the string on the stack
0B2B7F CD B7 2B 0B 0308**  			CALL    EXPR4           	; Fetch the second operator
0B2B83 08          0309**  			EX      AF,AF'
0B2B84 F2 29 2C 0B 0310**  			JP      P,TYPE_EV_			; If it is not a string, then Error: "Type mismatch"
0B2B88 01 00 00 00 0311**  			LD	BC, 0			; Clear BC
0B2B8C 4B          0312**  			LD      C,E             	; C: Length of the second string
0B2B8D D1          0313**  			POP     DE
0B2B8E D5          0314**  			PUSH    DE
0B2B8F 21 00 26 0B 0315**  			LD      HL,ACCS
0B2B93 7B          0316**  			LD	A,E			;  E: Length of the first string
0B2B94 11 00 26 0B 0317**  			LD      DE,ACCS
0B2B98 5F          0318**  			LD	E,A 			; DE: Pointer to the end of the first string
0B2B99 79          0319**  			LD      A,C
0B2B9A B7          0320**  			OR      A
0B2B9B 28 0B       0321**  			JR      Z,EXP3S3
0B2B9D 6F          0322**  			LD      L,A             	; Source
0B2B9E 83          0323**  			ADD     A,E
0B2B9F 5F          0324**  			LD      E,A             	; Destination
0B2BA0 3E 13       0325**  			LD      A,19
0B2BA2             0326**  			; JP      C,ERROR_         	; A carry indicates string > 255 bytes, so Error: "String too long"
0B2BA2 D5          0327**  			PUSH    DE
0B2BA3 1D          0328**  			DEC     E
0B2BA4 2D          0329**  			DEC     L
0B2BA5 ED B8       0330**  			LDDR                    	; Copy
0B2BA7 D1          0331**  			POP     DE
0B2BA8 D9          0332**  EXP3S3:			EXX
0B2BA9 C1          0333**  			POP     BC
0B2BAA CD BC 31 0B 0334**  			CALL    POPS            	; Restore from stack
0B2BAE D9          0335**  			EXX
0B2BAF F6 80       0336**  			OR      80H             	; Flag as a string
0B2BB1 08          0337**  			EX      AF,AF'
0B2BB2 FD 7E 00    0338**  			LD      A,(IY)			; Fetch the next character
0B2BB5 18 A6       0339**  			JR      EXPR3A			; And continue
0B2BB7             0340**  ;
0B2BB7             0341**  ; Level 3: * / MOD DIV
0B2BB7             0342**  ;
0B2BB7 CD D8 2B 0B 0343**  EXPR4:			CALL    EXPR5			; Get first operator by calling Level 2
0B2BBB FE 2A       0344**  EXPR4A:			CP      '*'			; "*" is valid
0B2BBD 28 0B       0345**  			JR      Z,EXPR4B
0B2BBF FE 2F       0346**  			CP      '/'			; "/" is valid
0B2BC1 28 07       0347**  			JR      Z,EXPR4B
0B2BC3 FE 83       0348**  			CP      MODK			; MOD token is valid
0B2BC5 28 03       0349**  			JR      Z,EXPR4B
0B2BC7 FE 81       0350**  			CP      DIVK			; DIV token is valid
0B2BC9 C0          0351**  			RET     NZ			; And return if it is anything else
0B2BCA CD 18 32 0B 0352**  EXPR4B:			CALL    SAVE_EV
0B2BCE CD D8 2B 0B 0353**  			CALL    EXPR5
0B2BD2 CD 27 32 0B 0354**  			CALL    DOIT
0B2BD6 18 E3       0355**  			JR      EXPR4A
0B2BD8             0356**  ;
0B2BD8             0357**  ; Level 2: ^
0B2BD8             0358**  ;
0B2BD8 CD AC 2C 0B 0359**  EXPR5:			CALL    ITEM			; Get variable
0B2BDC B7          0360**  			OR      A               	; Test type
0B2BDD 08          0361**  			EX      AF,AF'          	; Save type
0B2BDE CD 4A 32 0B 0362**  EXPR5A:			CALL    NXT			; Skip spaces
0B2BE2 FE 5E       0363**  			CP      '^'			; Is the operator "^"?
0B2BE4 C0          0364**  			RET     NZ			; No, so return
0B2BE5 CD 18 32 0B 0365**  			CALL    SAVE_EV			; Save first operand
0B2BE9 CD AC 2C 0B 0366**  			CALL    ITEM			; Get second operand
0B2BED B7          0367**  			OR      A			; Test type
0B2BEE 08          0368**  			EX      AF,AF'			; Save type
0B2BEF CD 27 32 0B 0369**  			CALL    DOIT			; Do the operation
0B2BF3 18 E9       0370**  			JR      EXPR5A			; And continue
0B2BF5             0371**  ;
0B2BF5             0372**  ; Evaluate a numeric expression
0B2BF5             0373**  ;
0B2BF5 CD BE 2A 0B 0374**  EXPRN:			CALL    EXPR			; Evaluate expression
0B2BF9 08          0375**  			EX      AF,AF'			; Get the type
0B2BFA F0          0376**  			RET     P			; And return if it is a number
0B2BFB 18 2C       0377**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B2BFD             0378**  ;
0B2BFD             0379**  ; Evaluate a fixed-point expression
0B2BFD             0380**  ;
0B2BFD CD BE 2A 0B 0381**  EXPRI:			CALL    EXPR			; Evaluate the expression
0B2C01 08          0382**  			EX      AF,AF'			; Get the type
0B2C02 F2 A0 2E 0B 0383**  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B2C06 18 21       0384**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B2C08             0385**  ;
0B2C08             0386**  ; Evaluate a string expression
0B2C08             0387**  ;
0B2C08 CD BE 2A 0B 0388**  EXPRS:			CALL    EXPR			; Evaluate the expression
0B2C0C 08          0389**  			EX      AF,AF'			; Get the type
0B2C0D F8          0390**  			RET     M			; And return if it is a string
0B2C0E 18 19       0391**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B2C10             0392**  ;
0B2C10             0393**  ; Get a numeric variable
0B2C10             0394**  ;
0B2C10 CD AC 2C 0B 0395**  ITEMN:			CALL    ITEM			; Get the variable
0B2C14 B7          0396**  			OR      A			; Test the type
0B2C15 F0          0397**  			RET     P			; And return if it is a number
0B2C16 18 11       0398**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B2C18             0399**  ;
0B2C18             0400**  ; Get a fixed-point variable
0B2C18             0401**  ;
0B2C18 CD AC 2C 0B 0402**  ITEMI:			CALL    ITEM			; Get the variable
0B2C1C B7          0403**  			OR      A			; Test the type
0B2C1D F2 A0 2E 0B 0404**  			JP      P,SFIX			; If it is numeric, then convert to fixed-point notation
0B2C21 18 06       0405**  			JR      TYPE_EV_			; Otherwise Error: "Type mismatch"
0B2C23             0406**  ;
0B2C23             0407**  ; Get a string variable
0B2C23             0408**  ;
0B2C23 CD AC 2C 0B 0409**  ITEMS:			CALL    ITEM			; Get the variable
0B2C27 B7          0410**  			OR      A			; Test the type
0B2C28 F8          0411**  			RET     M			; If it is a string, then return
0B2C29             0412**  ;							; Otherwise
0B2C29 3E 06       0413**  TYPE_EV_:			LD      A,6			; Error: "Type mismatch"
0B2C2B             0414**  			; JP      ERROR_
0B2C2B             0415**  ;
0B2C2B             0416**  ; Evaluate a bracketed expression
0B2C2B             0417**  ;
0B2C2B CD BE 2A 0B 0418**  ITEM1:			CALL    EXPR            	; Evaluate the expression
0B2C2F CD 0D 32 0B 0419**  			CALL    BRAKET			; Check for closing bracket
0B2C33 08          0420**  			EX      AF,AF'
0B2C34 C9          0421**  			RET
0B2C35             0422**  ;
0B2C35             0423**  ; HEX - Get hexadecimal constant.
0B2C35             0424**  ;   Inputs: ASCII string at (IY)
0B2C35             0425**  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0B2C35             0426**  ;           IY updated (points to delimiter)
0B2C35             0427**  ;
0B2C35 CD 6E 31 0B 0428**  HEX_EV:			CALL    ZERO			; Set result to 0
0B2C39 CD D6 31 0B 0429**  			CALL    HEXDIG			; Fetch the character from IY
0B2C3D 38 1B       0430**  			JR      C,BADHEX		; If invalid HEX character, then Error: "Bad HEX"
0B2C3F FD 23       0431**  HEX1:			INC     IY			; Move pointer to next character
0B2C41 E6 0F       0432**  			AND     0FH			; Clear the top nibble
0B2C43 06 04       0433**  			LD      B,4			; Loop counter
0B2C45             0434**  ;
0B2C45 D9          0435**  HEX2:			EXX				; Shift the result left B (4) times. This makes
0B2C46 52 29       0436**  			ADD.S   HL,HL			; space for the incoming nibble in the least significant 4 bits
0B2C48 D9          0437**  			EXX				; .
0B2C49 52 ED 6A    0438**  			ADC.S   HL,HL			; .
0B2C4C 10 F7       0439**  			DJNZ    HEX2			; And loop
0B2C4E D9          0440**  			EXX
0B2C4F B5          0441**  			OR      L			; OR in the digit
0B2C50 6F          0442**  			LD      L,A
0B2C51 D9          0443**  			EXX
0B2C52             0444**  ;
0B2C52 CD D6 31 0B 0445**  			CALL    HEXDIG			; Fetch the next character
0B2C56 30 E7       0446**  			JR      NC,HEX1			; If it is a HEX digit then loop
0B2C58 AF          0447**  			XOR     A			; Clear A
0B2C59 C9          0448**  			RET
0B2C5A             0449**  ;
0B2C5A 3E 1C       0450**  BADHEX:			LD      A,28
0B2C5C             0451**  			; JP      ERROR_          	; Error: "Bad HEX"
0B2C5C             0452**  ;
0B2C5C             0453**  ; BIN - Get binary constant.
0B2C5C             0454**  ;   Inputs: ASCII string at (IY)
0B2C5C             0455**  ;  Outputs: Integer result in H'L'HL, C=0, A7=0.
0B2C5C             0456**  ;           IY updated (points to delimiter)
0B2C5C             0457**  ;
0B2C5C CD 6E 31 0B 0458**  BIN:			CALL    ZERO			; Set result to 0
0B2C60 CD E9 31 0B 0459**  			CALL	BINDIG			; Fetch the character from IY
0B2C64 38 13       0460**  			JR	C,BADBIN		; If invalid BIN character then Error: "Bad Binary"
0B2C66 FD 23       0461**  BIN1:			INC	IY			; Move pointer to next character
0B2C68 0F          0462**  			RRCA				; Bit 0 of ASCII '0' is 0, and ASCII '1' is 1, so shift that bit into carry
0B2C69 D9          0463**  			EXX				;
0B2C6A 52 ED 6A    0464**  			ADC.S	HL,HL			; And shift back into into H'L'HL (note the ADC)
0B2C6D D9          0465**  			EXX
0B2C6E 52 ED 6A    0466**  			ADC.S	HL,HL
0B2C71 CD E9 31 0B 0467**  			CALL	BINDIG			; Fetch the next character
0B2C75 30 EF       0468**  			JR	NC,BIN1
0B2C77 AF          0469**  			XOR	A			; Clear A
0B2C78 C9          0470**  			RET
0B2C79             0471**  ;
0B2C79 3E 1C       0472**  BADBIN:			LD	A, 28			; Error: "Bad Binary" - reuses same error code as Bad HEX
0B2C7B             0473**  			; CALL	EXTERR
0B2C7B 42 61 64 20 0474**  			DB	"Bad Binary", 0
       42 69 6E 61 
       72 79 00    
0B2C86             0475**  ;
0B2C86             0476**  ; MINUS - Unary minus.
0B2C86             0477**  ;   Inputs: IY = text pointer
0B2C86             0478**  ;  Outputs: Numeric result, same type as argument.
0B2C86             0479**  ;           Result in H'L'HLC
0B2C86             0480**  ;
0B2C86 CD 10 2C 0B 0481**  MINUS:			CALL    ITEMN			; Get the numeric argument
0B2C8A 0D          0482**  MINUS0:			DEC     C			; Check exponent (C)
0B2C8B 0C          0483**  			INC     C			; If it is zero, then it's either a FP zero or an integer
0B2C8C 28 06       0484**  			JR      Z,NEGATE_EV        	; So do an integer negation
0B2C8E             0485**  ;
0B2C8E 7C          0486**  			LD      A,H			; Do a FP negation by
0B2C8F EE 80       0487**  			XOR     80H             	; Toggling the sign bit (H)
0B2C91 67          0488**  			LD      H,A
0B2C92 AF          0489**  			XOR     A               	; Numeric marker
0B2C93 C9          0490**  			RET
0B2C94             0491**  ;
0B2C94 D9          0492**  NEGATE_EV:			EXX				; This section does a two's complement negation on H'L'HLC
0B2C95 7C          0493**  			LD      A,H			; First do a one's complement by negating all the bytes
0B2C96 2F          0494**  			CPL
0B2C97 67          0495**  			LD      H,A
0B2C98 7D          0496**  			LD      A,L
0B2C99 2F          0497**  			CPL
0B2C9A 6F          0498**  			LD      L,A
0B2C9B D9          0499**  			EXX
0B2C9C 7C          0500**  			LD      A,H
0B2C9D 2F          0501**  			CPL
0B2C9E 67          0502**  			LD      H,A
0B2C9F 7D          0503**  			LD      A,L
0B2CA0 2F          0504**  			CPL
0B2CA1 6F          0505**  			LD      L,A
0B2CA2 D9          0506**  ADD1_EV:			EXX				; Then add 1
0B2CA3 23          0507**  			INC     HL
0B2CA4 7C          0508**  			LD      A,H
0B2CA5 B5          0509**  			OR      L
0B2CA6 D9          0510**  			EXX
0B2CA7 3E 00       0511**  			LD      A,0             	; Numeric marker
0B2CA9 C0          0512**  			RET     NZ
0B2CAA 23          0513**  			INC     HL
0B2CAB C9          0514**  			RET
0B2CAC             0515**  ;
0B2CAC             0516**  ; ITEM - VARIABLE TYPE NUMERIC OR STRING ITEM.
0B2CAC             0517**  ; Item type is returned in A:  Bit 7=0 numeric.
0B2CAC             0518**  ;                              Bit 7=1 string.
0B2CAC             0519**  ; Numeric item returned in HLH'L'C.
0B2CAC             0520**  ; String item returned in string accumulator,
0B2CAC             0521**  ;   DE addresses byte after last (E=length).
0B2CAC             0522**  ;
0B2CAC CD 57 40 0B 0523**  ITEM:			CALL    CHECK			; Check there's at least a page of free memory left and Error: "No room" if not
0B2CB0 CD 4A 32 0B 0524**  			CALL    NXT			; Skip spaces
0B2CB4 FD 23       0525**  			INC     IY			; Move to the prefix character
0B2CB6 FE 26       0526**  			CP      '&'			; If `&`
0B2CB8 CA 35 2C 0B 0527**  			JP      Z,HEX_EV           	; Then get a HEX constant
0B2CBC FE 25       0528**  			CP	'%'			; If '%'
0B2CBE 28 9C       0529**  			JR	Z,BIN			; Then get a BINARY constant
0B2CC0 FE 2D       0530**  			CP      '-'			; If `-`
0B2CC2 28 C2       0531**  			JR      Z,MINUS         	; Then get a negative number
0B2CC4 FE 2B       0532**  			CP      '+'			; If `+`
0B2CC6 CA 10 2C 0B 0533**  			JP      Z,ITEMN         	; Then just fetch the number (unary plus)
0B2CCA FE 28       0534**  			CP      '('			; If `(`
0B2CCC CA 2B 2C 0B 0535**  			JP      Z,ITEM1         	; Start of a bracketed expression
0B2CD0 FE 22       0536**  			CP      34			; If `"`
0B2CD2 28 72       0537**  			JR      Z,CONS          	; Start of a string constant
0B2CD4 FE C6       0538**  			CP      TCMD_EV			; Is it out of range of the function table?
0B2CD6             0539**  			; JP      NC,SYNTAX       	; Error: "Syntax Error"
0B2CD6 FE 8D       0540**  			CP      FUNTOK			; If it is in range, then
0B2CD8 D2 5D 32 0B 0541**  			JP      NC,DISPAT_EV       	; It's a function
0B2CDC FD 2B       0542**  			DEC     IY
0B2CDE FE 3A       0543**  			CP      ':'
0B2CE0 30 0C       0544**  			JR      NC,ITEM2		; VARIABLE?
0B2CE2 FE 30       0545**  			CP      '0'
0B2CE4 D2 69 2D 0B 0546**  			JP      NC,CON_EV			; NUMERIC CONSTANT
0B2CE8 FE 2E       0547**  			CP      '.'
0B2CEA CA 69 2D 0B 0548**  			JP      Z,CON_EV			; NUMERIC CONSTANT
0B2CEE CD 86 40 0B 0549**  ITEM2:			CALL    GETVAR			; VARIABLE
0B2CF2 20 37       0550**  			JR      NZ,NOSUCH
0B2CF4 B7          0551**  			OR      A
0B2CF5 FA 7B 2D 0B 0552**  			JP      M,LOADS			; STRING VARIABLE
0B2CF9 B7          0553**  LOADN:			OR      A
0B2CFA 28 20       0554**  			JR      Z,LOAD1			; BYTE VARIABLE
0B2CFC 0E 00       0555**  			LD      C,0
0B2CFE CB 47       0556**  			BIT     0,A
0B2D00 28 03       0557**  			JR      Z,LOAD4			; INTEGER VARIABLE
0B2D02 DD 4E 04    0558**  LOAD5:			LD      C,(IX+4)
0B2D05 D9          0559**  LOAD4:			EXX
0B2D06 21 00 00 00 0560**  			LD	HL, 0			; TODO: Optimise
0B2D0A DD 6E 00    0561**  			LD      L,(IX+0)
0B2D0D DD 66 01    0562**  			LD      H,(IX+1)
0B2D10 D9          0563**  			EXX
0B2D11 21 00 00 00 0564**  			LD	HL, 0			; TODO: Optimise
0B2D15 DD 6E 02    0565**  			LD      L,(IX+2)
0B2D18 DD 66 03    0566**  			LD      H,(IX+3)
0B2D1B C9          0567**  			RET
0B2D1C             0568**  ;
0B2D1C 21 00 00 00 0569**  LOAD1:			LD      HL,0
0B2D20 D9          0570**  			EXX
0B2D21 21 00 00 00 0571**  			LD      HL,0			; TODO: Optimise
0B2D25 DD 6E 00    0572**  			LD      L,(IX+0)
0B2D28 D9          0573**  			EXX
0B2D29 4C          0574**  			LD      C,H
0B2D2A C9          0575**  			RET
0B2D2B             0576**  ;
0B2D2B             0577**  NOSUCH:
0B2D2B             0578**  			; JP      C,SYNTAX
0B2D2B 3A 40 29 0B 0579**  			LD      A,(LISTON)
0B2D2F CB 6F       0580**  			BIT     5,A
0B2D31 3E 1A       0581**  			LD      A,26
0B2D33 20 26       0582**  			JR      NZ,ERROR0_EV		; Throw "No such variable"
0B2D35 FD 23       0583**  NOS1:			INC     IY
0B2D37 CD 49 42 0B 0584**  			CALL    RANGE
0B2D3B 30 F8       0585**  			JR      NC,NOS1
0B2D3D DD 21 40 A0 0586**  			LD      IX,PC
       2C          
0B2D42 AF          0587**  			XOR     A
0B2D43 4F          0588**  			LD      C,A
0B2D44 18 BF       0589**  			JR      LOAD4
0B2D46             0590**  ;
0B2D46             0591**  ;CONS - Get string constant from ASCII string.
0B2D46             0592**  ;   Inputs: ASCII string at (IY)
0B2D46             0593**  ;  Outputs: Result in string accumulator.
0B2D46             0594**  ;           D = MS byte of ACCS, E = string length
0B2D46             0595**  ;           A7 = 1 (string marker)
0B2D46             0596**  ;           IY updated
0B2D46             0597**  ;
0B2D46 11 00 26 0B 0598**  CONS:			LD      DE,ACCS			; DE: Pointer to the string accumulator
0B2D4A FD 7E 00    0599**  CONS3:			LD      A,(IY)			; Fetch the first character and
0B2D4D FD 23       0600**  			INC     IY			; Increment the pointer
0B2D4F FE 22       0601**  			CP      '"'			; Check for start quote
0B2D51 28 08       0602**  			JR      Z,CONS2			; Yes, so jump to the bit that parses the string
0B2D53             0603**  ;
0B2D53 12          0604**  CONS1:			LD      (DE),A			; Store the character in the string accumulator
0B2D54 1C          0605**  			INC     E			; Increment the string accumulator pointer
0B2D55 FE 0D       0606**  			CP      CR			; Is it CR
0B2D57 20 F1       0607**  			JR      NZ,CONS3		; No, so keep looping
0B2D59             0608**  ;
0B2D59 3E 09       0609**  			LD      A,9
0B2D5B             0610**  ERROR0_EV:
0B2D5B             0611**  			; JP      ERROR_           	; Throw error "Missing '"'
0B2D5B             0612**  ;
0B2D5B FD 7E 00    0613**  CONS2:			LD      A,(IY)			; Fetch the next character
0B2D5E FE 22       0614**  			CP      '"'			; Check for end quote?
0B2D60 FD 23       0615**  			INC     IY			; Increment the pointer
0B2D62 28 EF       0616**  			JR      Z,CONS1			; It is the end of string marker so jump to the end routine
0B2D64 FD 2B       0617**  			DEC     IY			;
0B2D66 3E 80       0618**  			LD      A,80H           	; String marker
0B2D68 C9          0619**  			RET
0B2D69             0620**  ;
0B2D69             0621**  ;CON_EV - Get unsigned numeric constant from ASCII string.
0B2D69             0622**  ;   Inputs: ASCII string at (IY).
0B2D69             0623**  ;  Outputs: Variable-type result in HLH'L'C
0B2D69             0624**  ;           IY updated (points to delimiter)
0B2D69             0625**  ;           A7 = 0 (numeric marker)
0B2D69             0626**  ;
0B2D69 FD E5       0627**  CON_EV:			PUSH    IY
0B2D6B DD E1       0628**  			POP     IX
0B2D6D 3E 24       0629**  			LD      A,36
0B2D6F CD 72 32 0B 0630**  			CALL    FPP
0B2D73 38 E6       0631**  			JR      C,ERROR0_EV
0B2D75 DD E5       0632**  			PUSH    IX
0B2D77 FD E1       0633**  			POP     IY
0B2D79 AF          0634**  			XOR     A
0B2D7A C9          0635**  			RET
0B2D7B             0636**  ;
0B2D7B 11 00 26 0B 0637**  LOADS:			LD      DE,ACCS			; Where to store the string
0B2D7F 1F          0638**  			RRA
0B2D80 30 1A       0639**  			JR      NC,LOADS2       	; Skip if it is a fixed string
0B2D82             0640**  ;
0B2D82 D9          0641**  			EXX				; This block was a call to LOAD4
0B2D83 DD 6E 00    0642**  			LD      L,(IX+0)		; The length of the string currently stored in the allocated space
0B2D86 DD 66 01    0643**  			LD      H,(IX+1)		; The maximum original string length
0B2D89 D9          0644**  			EXX
0B2D8A DD 27 02    0645**  			LD	HL,(IX+2)		; Address of the string (24-bit)
0B2D8D             0646**  ;
0B2D8D D9          0647**  			EXX
0B2D8E 7D          0648**  			LD      A,L
0B2D8F D9          0649**  			EXX
0B2D90 B7          0650**  			OR      A
0B2D91 01 00 00 00 0651**  			LD	BC,0			; BC: Number of bytes to copy
0B2D95 4F          0652**  			LD      C,A
0B2D96 3E 80       0653**  			LD      A,80H           	; String marker
0B2D98 C8          0654**  			RET     Z
0B2D99 ED B0       0655**  			LDIR
0B2D9B C9          0656**  			RET
0B2D9C 7E          0657**  LOADS2:			LD      A,(HL)
0B2D9D 12          0658**  			LD      (DE),A
0B2D9E 23          0659**  			INC     HL
0B2D9F FE 0D       0660**  			CP      CR
0B2DA1 3E 80       0661**  			LD      A,80H           	; String marker
0B2DA3 C8          0662**  			RET     Z
0B2DA4 1C          0663**  			INC     E
0B2DA5 20 F5       0664**  			JR      NZ,LOADS2
0B2DA7 C9          0665**  			RET                     	; Return null string
0B2DA8             0666**  ;
0B2DA8             0667**  ;VARIABLE-TYPE FUNCTIONS:
0B2DA8             0668**  ;
0B2DA8             0669**  ;Result returned in HLH'L'C (floating point)
0B2DA8             0670**  ;Result returned in HLH'L' (C=0) (integer)
0B2DA8             0671**  ;Result returned in string accumulator & DE (string)
0B2DA8             0672**  ;All registers destroyed.
0B2DA8             0673**  ;IY (text pointer) updated.
0B2DA8             0674**  ;Bit 7 of A indicates type: 0 = numeric, 1 = string.
0B2DA8             0675**  ;
0B2DA8             0676**  ;POS - horizontal cursor position.
0B2DA8             0677**  ;VPOS - vertical cursor position.
0B2DA8             0678**  ;EOF - return status of file.
0B2DA8             0679**  ;BGET - read byte from file.
0B2DA8             0680**  ;INKEY - as GET but wait only n centiseconds.
0B2DA8             0681**  ;GET - wait for keypress and return ASCII value.
0B2DA8             0682**  ;GET(n) - input from Z80 port n.
0B2DA8             0683**  ;ASC - ASCII value of string.
0B2DA8             0684**  ;LEN - length of string.
0B2DA8             0685**  ;LOMEM - location of dynamic variables.
0B2DA8             0686**  ;HIMEM - top of available RAM.
0B2DA8             0687**  ;PAGE - start of current text page.
0B2DA8             0688**  ;TOP - address of first free byte after program.
0B2DA8             0689**  ;ERL - line number where last error occurred.
0B2DA8             0690**  ;ERR - number of last error.
0B2DA8             0691**  ;COUNT - number of printing characters since CR.
0B2DA8             0692**  ;Results are integer numeric.
0B2DA8             0693**  ;
0B2DA8             0694**  ; we won't be using the following:
0B2DA8 C9          0695**  POS:		ret
0B2DA9             0696**  			; CALL    GETCSR			; Return the horizontal cursor position
0B2DA9             0697**  			; EX      DE,HL			;  L: The X cursor position
0B2DA9             0698**  			; JP      COUNT1			; Return an 8-bit value
0B2DA9             0699**  ;
0B2DA9 C9          0700**  VPOS:		ret
0B2DAA             0701**  			; CALL    GETCSR			; Return the vertical cursor position
0B2DAA             0702**  			; JP      COUNT1			; Return an 8-bit value
0B2DAA             0703**  
0B2DAA C9          0704**  EOF:		ret
0B2DAB             0705**  			; CALL    CHANEL			; Check for EOF
0B2DAB             0706**  			; CALL    OSSTAT
0B2DAB             0707**  			; JP      Z,FOR_EV			; Yes, so return true
0B2DAB             0708**  			; JP      ZERO			; Otherwise return false (zero)
0B2DAB             0709**  ;
0B2DAB C9          0710**  BGET:		ret
0B2DAC             0711**  			; CALL    CHANEL          	; Channel number
0B2DAC             0712**  			; CALL    OSBGET
0B2DAC             0713**  			; LD      L,A
0B2DAC             0714**  			; JP      COUNT0			; Return an 8-bit value
0B2DAC             0715**  ;
0B2DAC C9          0716**  INKEY:		ret
0B2DAD             0717**  			; CALL    ITEMI			; Get the argument
0B2DAD             0718**  			; BIT	7, H			; Check the sign
0B2DAD             0719**  			; EXX				; HL: The argument
0B2DAD             0720**  			; JP	NZ, INKEYM		; It's negative, so do INKEY(-n)
0B2DAD             0721**  			; CALL	INKEY0 			; Do INKEY(n)
0B2DAD             0722**  			; JR      ASC0			; Return a numeric value
0B2DAD             0723**  ;
0B2DAD C9          0724**  GET:		ret
0B2DAE             0725**  			; CALL    NXT			; Skip whitespace
0B2DAE             0726**  			; CP      '('			; Is it GET(
0B2DAE             0727**  			; JR      NZ,GET0			; No, so get a keyboard character
0B2DAE             0728**  			; CALL    ITEMI           	; Yes, so fetch the port address
0B2DAE             0729**  			; EXX
0B2DAE             0730**  			; LD      B,H			; BC: The port address
0B2DAE             0731**  			; LD      C,L
0B2DAE             0732**  			; IN      L,(C)           	;  L: Input from port BC
0B2DAE             0733**  			; JR      COUNT0			; Return an 8-bit value
0B2DAE             0734**  ;
0B2DAE C9          0735**  GET0:		ret
0B2DAF             0736**  			; CALL    GETS			; Read the keyboard character
0B2DAF             0737**  			; JR      ASC1			; And return the value
0B2DAF             0738**  
0B2DAF             0739**  ; end of the functions we won't be using
0B2DAF             0740**  
0B2DAF             0741**  
0B2DAF             0742**  ;
0B2DAF CD 23 2C 0B 0743**  ASC:			CALL    ITEMS			; Get the string argument argument
0B2DB3 AF          0744**  ASC0:			XOR     A			; Quickly check the length of the string in ACCS
0B2DB4 BB          0745**  			CP      E			; Is the pointer 0
0B2DB5 CA 47 2E 0B 0746**  			JP      Z,FOR_EV          	; Yes, so return -1 as it is a null string
0B2DB9 2A 00 26 0B 0747**  ASC1:			LD      HL,(ACCS)		;  L: The first character (H will be discarded in COUNT0
0B2DBD 18 46       0748**  			JR      COUNT0			; An 8-bit value
0B2DBF             0749**  ;
0B2DBF CD 23 2C 0B 0750**  LEN:			CALL    ITEMS			; Get the string argument
0B2DC3 EB          0751**  			EX      DE,HL			; HL: Pointer into ACCS
0B2DC4 18 3F       0752**  			JR      COUNT0			; Return L
0B2DC6             0753**  ;
0B2DC6 2A 1A 29 0B 0754**  LOMEMV_EV:			LD      HL,(LOMEM)		; Return the LOMEM system variable
0B2DCA 3A 1C 29 0B 0755**  			LD	A, (LOMEM+2)
0B2DCE 18 3D       0756**  			JR      COUNT2			; A 24-bit value
0B2DD0             0757**  ;
0B2DD0 2A 20 29 0B 0758**  HIMEMV_EV:			LD      HL,(HIMEM)		; Return the HIMEM system variable
0B2DD4 3A 22 29 0B 0759**  			LD	A, (HIMEM+2)
0B2DD8 18 33       0760**  			JR      COUNT2			; A 24-bit value
0B2DDA             0761**  ;
0B2DDA 2A 14 29 0B 0762**  PAGEV_EV:			LD    	HL,(PAGE_)		; Return the PAGE system variable
0B2DDE 3A 16 29 0B 0763**  			LD	A, (PAGE_+2)		; A 24-bit value
0B2DE2 18 29       0764**  			JR      COUNT2
0B2DE4             0765**  ;
0B2DE4 FD 7E 00    0766**  TOPV:			LD      A,(IY)			; Return the TOP system variable
0B2DE7 FD 23       0767**  			INC     IY              	; Skip "P"
0B2DE9 FE 50       0768**  			CP      'P'
0B2DEB             0769**  			; JP      NZ,SYNTAX       	; Throw "Syntax Error"
0B2DEB 2A 17 29 0B 0770**  			LD      HL,(TOP)
0B2DEF 3A 19 29 0B 0771**  			LD	A, (TOP+2)
0B2DF3 18 18       0772**  			JR      COUNT2
0B2DF5             0773**  ;
0B2DF5 2A 33 29 0B 0774**  ERLV:			LD      HL,(ERL)		; Return the error line
0B2DF9 18 0C       0775**  			JR      COUNT1			; A 16-bit value
0B2DFB             0776**  ;
0B2DFB 2A 3F 29 0B 0777**  ERRV:			LD      HL,(ERR)		; Return the error value
0B2DFF 18 04       0778**  			JR      COUNT0			; An 8-bit value
0B2E01             0779**  ;
0B2E01 2A 3D 29 0B 0780**  COUNTV:			LD      HL,(COUNT)		; Return the print position sysvar
0B2E05             0781**  
0B2E05 26 00       0782**  COUNT0:			LD      H,0			; Return L
0B2E07 D9          0783**  COUNT1:			EXX				; Return HL
0B2E08 AF          0784**  			XOR     A
0B2E09 4F          0785**  			LD      C,A             	; Integer marker
0B2E0A 67          0786**  			LD      H,A
0B2E0B 6F          0787**  			LD      L,A
0B2E0C C9          0788**  			RET
0B2E0D D9          0789**  COUNT2:			EXX
0B2E0E 6F          0790**  			LD	L,A
0B2E0F AF          0791**  			XOR	A
0B2E10 4F          0792**  			LD	C,A			; Integer marker
0B2E11 67          0793**  			LD	H,A
0B2E12 C9          0794**  			RET
0B2E13             0795**  
0B2E13             0796**  ; ; we won't be using the following:
0B2E13             0797**  ;OPENIN - Open a file for reading.
0B2E13             0798**  ;OPENOT - Open a file for writing.
0B2E13             0799**  ;OPENUP - Open a file for reading or writing.
0B2E13             0800**  ;Result is integer channel number (0 if error)
0B2E13             0801**  ;
0B2E13 C9          0802**  OPENOT:		ret
0B2E14             0803**  			; XOR     A			; Open for writing
0B2E14             0804**  			; JR	OPENIN_1
0B2E14             0805**  ;
0B2E14 C9          0806**  OPENUP:		ret
0B2E15             0807**  			; LD      A,2			; Open for reading / writing
0B2E15             0808**  			; JR	OPENIN_1
0B2E15             0809**  ;
0B2E15 C9          0810**  OPENIN:		ret
0B2E16             0811**  			; LD      A,1			; Open for reading
0B2E16             0812**  ;
0B2E16 C9          0813**  OPENIN_1:	ret
0B2E17             0814**  			; PUSH    AF              	; Save OPEN type
0B2E17             0815**  			; CALL    ITEMS           	; Fetch the filename
0B2E17             0816**  			; LD      A,CR
0B2E17             0817**  			; LD      (DE),A
0B2E17             0818**  			; POP     AF              	; Restore the OPEN type
0B2E17             0819**  			; ADD     A,-1            	; Affect the flags
0B2E17             0820**  			; LD      HL,ACCS
0B2E17             0821**  			; CALL    OSOPEN			; Call the OS specific OPEN routine in patch.asm
0B2E17             0822**  			; LD      L,A			; L: Channel number
0B2E17             0823**  			; JR      COUNT0			; Return channel number to BASIC
0B2E17             0824**  
0B2E17             0825**  ;EXT - Return length of file.
0B2E17             0826**  ;PTR - Return current file pointer.
0B2E17             0827**  ;Results are integer numeric.
0B2E17             0828**  ;
0B2E17 C9          0829**  EXT_EV:		ret
0B2E18             0830**  			; CALL    CHANEL
0B2E18             0831**  			; CALL    GETEXT
0B2E18             0832**  			; JR      TIME0
0B2E18             0833**  ;
0B2E18 C9          0834**  PTR_EV:		ret
0B2E19             0835**  			; CALL    CHANEL
0B2E19             0836**  			; CALL    GETPTR
0B2E19             0837**  			; JR      TIME0
0B2E19             0838**  
0B2E19             0839**  ;TIME - Return current value of elapsed time.
0B2E19             0840**  ;Result is integer numeric.
0B2E19             0841**  ;
0B2E19 C9          0842**  TIMEV_EV:	ret
0B2E1A             0843**  			; LD      A,(IY)
0B2E1A             0844**  			; CP      '$'
0B2E1A             0845**  			; JR      Z,TIMEVS_EV
0B2E1A             0846**  			; CALL    GETIME
0B2E1A C9          0847**  TIME0:		ret
0B2E1B             0848**  			; PUSH    DE
0B2E1B             0849**  			; EXX
0B2E1B             0850**  			; POP     HL
0B2E1B             0851**  			; XOR     A
0B2E1B             0852**  			; LD      C,A
0B2E1B             0853**  			; RET
0B2E1B             0854**  
0B2E1B             0855**  ;TIME$ - Return date/time string.
0B2E1B             0856**  ;Result is string
0B2E1B             0857**  ;
0B2E1B C9          0858**  TIMEVS_EV:	ret
0B2E1C             0859**  			; INC     IY              ;SKIP $
0B2E1C             0860**  			; CALL    GETIMS
0B2E1C             0861**  			; LD      A,80H           ;MARK STRING
0B2E1C             0862**  			; RET
0B2E1C             0863**  ; end of the functions we won't be using
0B2E1C             0864**  
0B2E1C             0865**  ;String comparison:
0B2E1C             0866**  ;
0B2E1C CD 6A 31 0B 0867**  SLT:			CALL    SCP
0B2E20 D0          0868**  			RET     NC
0B2E21 18 24       0869**  			JR      FOR_EV
0B2E23             0870**  ;
0B2E23 CD 6A 31 0B 0871**  SGT:			CALL    SCP
0B2E27 C8          0872**  			RET     Z
0B2E28 D8          0873**  			RET     C
0B2E29 18 1C       0874**  			JR      FOR_EV
0B2E2B             0875**  ;
0B2E2B CD 6A 31 0B 0876**  SGE:			CALL    SCP
0B2E2F D8          0877**  			RET     C
0B2E30 18 15       0878**  			JR      FOR_EV
0B2E32             0879**  ;
0B2E32 CD 6A 31 0B 0880**  SLE:			CALL    SCP
0B2E36 28 0F       0881**  			JR      Z,FOR_EV
0B2E38 D0          0882**  			RET     NC
0B2E39 18 0C       0883**  			JR      FOR_EV
0B2E3B             0884**  ;
0B2E3B CD 6A 31 0B 0885**  SNE:			CALL    SCP
0B2E3F C8          0886**  			RET     Z
0B2E40 18 05       0887**  			JR      FOR_EV
0B2E42             0888**  ;
0B2E42 CD 6A 31 0B 0889**  SEQ:			CALL    SCP
0B2E46 C0          0890**  			RET     NZ
0B2E47 3E FF       0891**  FOR_EV:			LD      A,-1
0B2E49 D9          0892**  			EXX
0B2E4A 67          0893**  			LD      H,A
0B2E4B 6F          0894**  			LD      L,A
0B2E4C D9          0895**  			EXX
0B2E4D 67          0896**  			LD      H,A
0B2E4E 6F          0897**  			LD      L,A
0B2E4F 3C          0898**  			INC     A
0B2E50 4F          0899**  			LD      C,A
0B2E51 C9          0900**  			RET
0B2E52             0901**  ;
0B2E52             0902**  ;PI - Return PI (3.141592654)
0B2E52             0903**  ;Result is floating-point numeric.
0B2E52             0904**  ;
0B2E52 3E 23       0905**  PI_EV:			LD      A,35
0B2E54 18 44       0906**  			JR      FPP1
0B2E56             0907**  ;
0B2E56             0908**  ;ABS - Absolute value
0B2E56             0909**  ;Result is numeric, variable type.
0B2E56             0910**  ;
0B2E56 3E 10       0911**  ABSV_EV:			LD      A,16
0B2E58 18 3A       0912**  			JR      FPPN
0B2E5A             0913**  ;
0B2E5A             0914**  ;NOT - Complement integer.
0B2E5A             0915**  ;Result is integer numeric.
0B2E5A             0916**  ;
0B2E5A 3E 1A       0917**  NOTK_EV:			LD      A,26
0B2E5C 18 36       0918**  			JR      FPPN
0B2E5E             0919**  ;
0B2E5E             0920**  ;DEG - Convert radians to degrees
0B2E5E             0921**  ;Result is floating-point numeric.
0B2E5E             0922**  ;
0B2E5E 3E 15       0923**  DEG_EV:			LD      A,21
0B2E60 18 32       0924**  			JR      FPPN
0B2E62             0925**  ;
0B2E62             0926**  ;RAD - Convert degrees to radians
0B2E62             0927**  ;Result is floating-point numeric.
0B2E62             0928**  ;
0B2E62 3E 1B       0929**  RAD_EV:			LD      A,27
0B2E64 18 2E       0930**  			JR      FPPN
0B2E66             0931**  ;
0B2E66             0932**  ;SGN - Return -1, 0 or +1
0B2E66             0933**  ;Result is integer numeric.
0B2E66             0934**  ;
0B2E66 3E 1C       0935**  SGN_EV:			LD      A,28
0B2E68 18 2A       0936**  			JR      FPPN
0B2E6A             0937**  ;
0B2E6A             0938**  ;INT - Floor function
0B2E6A             0939**  ;Result is integer numeric.
0B2E6A             0940**  ;
0B2E6A 3E 17       0941**  INT_EV_:			LD      A,23
0B2E6C 18 26       0942**  			JR      FPPN
0B2E6E             0943**  ;
0B2E6E             0944**  ;SQR - square root
0B2E6E             0945**  ;Result is floating-point numeric.
0B2E6E             0946**  ;
0B2E6E 3E 1E       0947**  SQR_EV:			LD      A,30
0B2E70 18 22       0948**  			JR      FPPN
0B2E72             0949**  ;
0B2E72             0950**  ;TAN - Tangent function
0B2E72             0951**  ;Result is floating-point numeric.
0B2E72             0952**  ;
0B2E72 3E 1F       0953**  TAN_EV:			LD      A,31
0B2E74 18 1E       0954**  			JR      FPPN
0B2E76             0955**  ;
0B2E76             0956**  ;COS - Cosine function
0B2E76             0957**  ;Result is floating-point numeric.
0B2E76             0958**  ;
0B2E76 3E 14       0959**  COS_EV:			LD      A,20
0B2E78 18 1A       0960**  			JR      FPPN
0B2E7A             0961**  ;
0B2E7A             0962**  ;SIN - Sine function
0B2E7A             0963**  ;Result is floating-point numeric.
0B2E7A             0964**  ;
0B2E7A 3E 1D       0965**  SIN_EV:			LD      A,29
0B2E7C 18 16       0966**  			JR      FPPN
0B2E7E             0967**  ;
0B2E7E             0968**  ;EXP - Exponential function
0B2E7E             0969**  ;Result is floating-point numeric.
0B2E7E             0970**  ;
0B2E7E 3E 16       0971**  EXP_EV:			LD      A,22
0B2E80 18 12       0972**  			JR      FPPN
0B2E82             0973**  ;
0B2E82             0974**  ;LN - Natural log.
0B2E82             0975**  ;Result is floating-point numeric.
0B2E82             0976**  ;
0B2E82 3E 18       0977**  LN_EV:			LD      A,24
0B2E84 18 0E       0978**  			JR      FPPN
0B2E86             0979**  ;
0B2E86             0980**  ;LOG - base-10 logarithm.
0B2E86             0981**  ;Result is floating-point numeric.
0B2E86             0982**  ;
0B2E86 3E 19       0983**  LOG_EV:			LD      A,25
0B2E88 18 0A       0984**  			JR      FPPN
0B2E8A             0985**  ;
0B2E8A             0986**  ;ASN - Arc-sine
0B2E8A             0987**  ;Result is floating-point numeric.
0B2E8A             0988**  ;
0B2E8A 3E 12       0989**  ASN_EV:			LD      A,18
0B2E8C 18 06       0990**  			JR      FPPN
0B2E8E             0991**  ;
0B2E8E             0992**  ;ATN - arc-tangent
0B2E8E             0993**  ;Result is floating-point numeric.
0B2E8E             0994**  ;
0B2E8E 3E 13       0995**  ATN_EV:			LD      A,19
0B2E90 18 02       0996**  			JR      FPPN
0B2E92             0997**  ;
0B2E92             0998**  ;ACS - arc-cosine
0B2E92             0999**  ;Result is floating point numeric.
0B2E92             1000**  ;
0B2E92 3E 11       1001**  ACS_EV:			LD      A,17
0B2E94 F5          1002**  FPPN:			PUSH    AF
0B2E95 CD 10 2C 0B 1003**  			CALL    ITEMN
0B2E99 F1          1004**  			POP     AF
0B2E9A CD 72 32 0B 1005**  FPP1:			CALL    FPP
0B2E9E             1006**  			; JP      C,ERROR_
0B2E9E AF          1007**  			XOR     A
0B2E9F C9          1008**  			RET
0B2EA0             1009**  ;
0B2EA0             1010**  ;SFIX - Convert to fixed-point notation
0B2EA0             1011**  ;
0B2EA0 3E 26       1012**  SFIX:			LD      A,38
0B2EA2 18 F6       1013**  			JR      FPP1
0B2EA4             1014**  ;
0B2EA4             1015**  ;SFLOAT - Convert to floating-point notation
0B2EA4             1016**  ;
0B2EA4 3E 27       1017**  SFLOAT_EV:			LD      A,39
0B2EA6 18 F2       1018**  			JR      FPP1
0B2EA8             1019**  ;
0B2EA8             1020**  ;VAL - Return numeric value of string.
0B2EA8             1021**  ;Result is variable type numeric.
0B2EA8             1022**  ;
0B2EA8 CD 23 2C 0B 1023**  VAL_EV:			CALL    ITEMS
0B2EAC AF          1024**  VAL0:			XOR     A
0B2EAD 12          1025**  			LD      (DE),A
0B2EAE DD 21 00 26 1026**  			LD      IX,ACCS
       0B          
0B2EB3 3E 24       1027**  			LD      A,36
0B2EB5 18 E3       1028**  			JR      FPP1
0B2EB7             1029**  ;
0B2EB7             1030**  ;EVAL - Pass string to expression evaluator.
0B2EB7             1031**  ;Result is variable type (numeric or string).
0B2EB7             1032**  ;
0B2EB7 CD 23 2C 0B 1033**  EVAL_:			CALL    ITEMS
0B2EBB 3E 0D       1034**  			LD      A,CR
0B2EBD 12          1035**  			LD      (DE),A
0B2EBE FD E5       1036**  			PUSH    IY
0B2EC0 11 00 26 0B 1037**  			LD      DE,ACCS
0B2EC4 FD 21 00 26 1038**  			LD      IY,ACCS
       0B          
0B2EC9 0E 00       1039**  			LD      C,0
0B2ECB CD 72 42 0B 1040**  			CALL    LEXAN2          ;TOKENISE
0B2ECF 12          1041**  			LD      (DE),A
0B2ED0 13          1042**  			INC     DE
0B2ED1 AF          1043**  			XOR     A
0B2ED2 CD 8F 31 0B 1044**  			CALL    PUSHS           ;PUT ON STACK
0B2ED6 FD 21 03 00 1045**  			LD      IY,SIZEW	;WAS 2
       00          
0B2EDB FD 39       1046**  			ADD     IY,SP
0B2EDD CD BE 2A 0B 1047**  			CALL    EXPR
0B2EE1 FD E1       1048**  			POP     IY
0B2EE3 FD 39       1049**  			ADD     IY,SP
0B2EE5 FD F9       1050**  			LD      SP,IY           ;ADJUST STACK POINTER
0B2EE7 FD E1       1051**  			POP     IY
0B2EE9 08          1052**  			EX      AF,AF'
0B2EEA C9          1053**  			RET
0B2EEB             1054**  ;
0B2EEB             1055**  ;RND - Random number function.
0B2EEB             1056**  ; RND gives random integer 0-&FFFFFFFF
0B2EEB             1057**  ; RND(-n) seeds random number & returns -n.
0B2EEB             1058**  ; RND(0) returns last value in RND(1) form.
0B2EEB             1059**  ; RND(1) returns floating-point 0-0.99999999.
0B2EEB             1060**  ; RND(n) returns random integer 1-n.
0B2EEB             1061**  ;
0B2EEB DD 21 38 29 1062**  RND:			LD      IX,RANDOM
       0B          
0B2EF0 CD 4A 32 0B 1063**  			CALL    NXT
0B2EF4 FE 28       1064**  			CP      '('
0B2EF6 28 20       1065**  			JR      Z,RND5          ;ARGUMENT FOLLOWS
0B2EF8 CD 02 2D 0B 1066**  			CALL    LOAD5
0B2EFC CB 19       1067**  RND1:			RR      C
0B2EFE 06 20       1068**  			LD      B,32
0B2F00 D9          1069**  RND2:			EXX                     ;CALCULATE NEXT
0B2F01 52 ED 6A    1070**  			ADC.S   HL,HL
0B2F04 D9          1071**  			EXX
0B2F05 52 ED 6A    1072**  			ADC.S   HL,HL
0B2F08 CB 5D       1073**  			BIT     3,L
0B2F0A 28 01       1074**  			JR      Z,RND3
0B2F0C 3F          1075**  			CCF
0B2F0D 10 F1       1076**  RND3:			DJNZ    RND2
0B2F0F CB 11       1077**  RND4:			RL      C               ;SAVE CARRY
0B2F11 CD EE 45 0B 1078**  			CALL    STORE5          ;STORE NEW NUMBER
0B2F15 AF          1079**  			XOR     A
0B2F16 4F          1080**  			LD      C,A
0B2F17 C9          1081**  			RET
0B2F18 CD 18 2C 0B 1082**  RND5:			CALL    ITEMI
0B2F1C DD 21 38 29 1083**  			LD      IX,RANDOM
       0B          
0B2F21 CB 7C       1084**  			BIT     7,H             ;NEGATIVE?
0B2F23 37          1085**  			SCF
0B2F24 20 E9       1086**  			JR      NZ,RND4         ;SEED
0B2F26 CD BE 30 0B 1087**  			CALL    TEST
0B2F2A F5          1088**  			PUSH    AF
0B2F2B CD B6 30 0B 1089**  			CALL    SWAP
0B2F2F D9          1090**  			EXX
0B2F30 CD 02 2D 0B 1091**  			CALL    LOAD5
0B2F34 C4 FC 2E 0B 1092**  			CALL    NZ,RND1         ;NEXT IF NON-ZERO
0B2F38 D9          1093**  			EXX                     ;SCRAMBLE (CARE!)
0B2F39 0E 7F       1094**  			LD      C,7FH
0B2F3B CB 7C       1095**  RND6:			BIT     7,H             ;FLOAT
0B2F3D 20 0A       1096**  			JR      NZ,RND7
0B2F3F D9          1097**  			EXX
0B2F40 52 29       1098**  			ADD.S   HL,HL
0B2F42 D9          1099**  			EXX
0B2F43 52 ED 6A    1100**  			ADC.S   HL,HL
0B2F46 0D          1101**  			DEC     C
0B2F47 20 F2       1102**  			JR      NZ,RND6
0B2F49 CB BC       1103**  RND7:			RES     7,H             ;POSITIVE 0-0.999999
0B2F4B F1          1104**  			POP     AF
0B2F4C C8          1105**  			RET     Z               ;ZERO ARGUMENT
0B2F4D D9          1106**  			EXX
0B2F4E 7B          1107**  			LD      A,E
0B2F4F 3D          1108**  			DEC     A
0B2F50 B2          1109**  			OR      D
0B2F51 D9          1110**  			EXX
0B2F52 B3          1111**  			OR      E
0B2F53 B2          1112**  			OR      D
0B2F54 C8          1113**  			RET     Z               ;ARGUMENT=1
0B2F55 06 00       1114**  			LD      B,0             ;INTEGER MARKER
0B2F57 3E 0A       1115**  			LD      A,10
0B2F59 CD 72 32 0B 1116**  			CALL    FPP             ;MULTIPLY
0B2F5D             1117**  			; JP      C,ERROR_
0B2F5D CD A0 2E 0B 1118**  			CALL    SFIX
0B2F61 C3 A2 2C 0B 1119**  			JP      ADD1_EV
0B2F65             1120**  ;
0B2F65             1121**  ; INSTR - String search.
0B2F65             1122**  ; Result is integer numeric.
0B2F65             1123**  ;
0B2F65 CD FC 31 0B 1124**  INSTR:			CALL    EXPRSC			; Get the first string expression
0B2F69 CD 8F 31 0B 1125**  			CALL    PUSHS           	; Push the string onto the stack
0B2F6D CD 08 2C 0B 1126**  			CALL    EXPRS           	; Get the second string expression
0B2F71 C1          1127**  			POP     BC			;  C: String length, B: Value of A before PUSHS was called
0B2F72 21 00 00 00 1128**  			LD      HL,0
0B2F76 39          1129**  			ADD     HL,SP           	; HL: Pointer to main string
0B2F77 C5          1130**  			PUSH    BC              	;  C: Main string length
0B2F78 43          1131**  			LD      B,E             	;  B: Sub-string length
0B2F79 CD 4A 32 0B 1132**  			CALL    NXT			; Skip whitespace
0B2F7D FE 2C       1133**  			CP      ','			; Check if there is a comma for the third parameter
0B2F7F 3E 00       1134**  			LD      A,0			;  A: Default start position in string
0B2F81 20 1A       1135**  			JR      NZ,INSTR1		; No, so skip the next bit
0B2F83 FD 23       1136**  			INC     IY              	; Skip the comma
0B2F85 C5          1137**  			PUSH    BC              	; Save the lengths
0B2F86 E5          1138**  			PUSH    HL              	; Save the pointer to the main string
0B2F87 CD 8F 31 0B 1139**  			CALL    PUSHS			; Push the string onto the stack
0B2F8B CD FD 2B 0B 1140**  			CALL    EXPRI			; Get the third (numeric) parameter - the starting position
0B2F8F C1          1141**  			POP     BC			;  C: String length, B: Value of A before PUSHS was called (discarded)
0B2F90 CD BC 31 0B 1142**  			CALL    POPS			; Pop the string off the stack
0B2F94 E1          1143**  			POP     HL              	; Restore the pointer to the main string
0B2F95 C1          1144**  			POP     BC              	; Restore the lengths
0B2F96 D9          1145**  			EXX
0B2F97 7D          1146**  			LD      A,L			; A: The start position in the  string
0B2F98 D9          1147**  			EXX
0B2F99 B7          1148**  			OR      A			; Set the flags
0B2F9A 28 01       1149**  			JR      Z,INSTR1		; If it is zero, then skip
0B2F9C 3D          1150**  			DEC     A
0B2F9D 11 00 26 0B 1151**  INSTR1:			LD      DE,ACCS         	; DE: Pointer to the sub string
0B2FA1 CD BF 2F 0B 1152**  			CALL    SEARCH			; Do the search
0B2FA5 D1          1153**  			POP     DE
0B2FA6 28 03       1154**  			JR      Z,INSTR2        	; NB: Carry cleared
0B2FA8 ED 62       1155**  			SBC     HL,HL
0B2FAA 39          1156**  			ADD     HL,SP
0B2FAB ED 72       1157**  INSTR2:			SBC     HL,SP
0B2FAD EB          1158**  			EX      DE,HL
0B2FAE 7D          1159**  			LD	A,L
0B2FAF 21 00 00 00 1160**  			LD      HL,0
0B2FB3 6F          1161**  			LD	L,A
0B2FB4 39          1162**  			ADD     HL,SP
0B2FB5 F9          1163**  			LD      SP,HL
0B2FB6 EB          1164**  			EX      DE,HL
0B2FB7 CD 0D 32 0B 1165**  			CALL    BRAKET			; Check for closing bracket
0B2FBB C3 07 2E 0B 1166**  			JP      COUNT1			; Return a numeric integer
0B2FBF             1167**  ;
0B2FBF             1168**  ; SEARCH - Search string for sub-string
0B2FBF             1169**  ;    Inputs: Main string at HL length C
0B2FBF             1170**  ;            Sub-string  at DE length B
0B2FBF             1171**  ;            Starting offset A
0B2FBF             1172**  ;   Outputs: NZ - not found
0B2FBF             1173**  ;            Z - found at location HL-1
0B2FBF             1174**  ;            Carry always cleared
0B2FBF             1175**  ;
0B2FBF C5          1176**  SEARCH:			PUSH    BC			; Add the starting offset to HL
0B2FC0 01 00 00 00 1177**  			LD      BC,0
0B2FC4 4F          1178**  			LD      C,A
0B2FC5 09          1179**  			ADD     HL,BC           	; New start address
0B2FC6 C1          1180**  			POP     BC
0B2FC7 91          1181**  			SUB     C			; If the starting offset > main string length, then do nothing
0B2FC8 30 2C       1182**  			JR      NC,SRCH4
0B2FCA ED 44       1183**  			NEG
0B2FCC 4F          1184**  			LD      C,A             	; Remaining length
0B2FCD             1185**  ;
0B2FCD C5          1186**  SRCH1_EV:			PUSH    BC
0B2FCE 79          1187**  			LD	A,C
0B2FCF 01 00 00 00 1188**  			LD	BC,0
0B2FD3 4F          1189**  			LD	C,A
0B2FD4 1A          1190**  			LD      A,(DE)
0B2FD5 ED B1       1191**  			CPIR                    	; Find the first character
0B2FD7 79          1192**  			LD      A,C
0B2FD8 C1          1193**  			POP     BC
0B2FD9 20 1B       1194**  			JR      NZ,SRCH4
0B2FDB 4F          1195**  			LD      C,A
0B2FDC             1196**  ;
0B2FDC             1197**  ; This block of four instructions was commented as a bug fix by R.T.Russell
0B2FDC             1198**  ;
0B2FDC 05          1199**  			DEC     B			; Bug fix
0B2FDD B8          1200**  			CP      B			; Bug fix
0B2FDE 04          1201**  			INC     B			; Bug fix
0B2FDF 38 15       1202**  			JR      C,SRCH4			; Bug fix
0B2FE1             1203**  ;
0B2FE1 C5          1204**  			PUSH    BC
0B2FE2 D5          1205**  			PUSH    DE
0B2FE3 E5          1206**  			PUSH    HL
0B2FE4 05          1207**  			DEC     B
0B2FE5 28 08       1208**  			JR      Z,SRCH3         	; Found!
0B2FE7 13          1209**  SRCH2_EV:			INC     DE
0B2FE8 1A          1210**  			LD      A,(DE)
0B2FE9 BE          1211**  			CP      (HL)
0B2FEA 20 03       1212**  			JR      NZ,SRCH3
0B2FEC 23          1213**  			INC     HL
0B2FED 10 F8       1214**  			DJNZ    SRCH2_EV
0B2FEF E1          1215**  SRCH3:			POP     HL
0B2FF0 D1          1216**  			POP     DE
0B2FF1 C1          1217**  			POP     BC
0B2FF2 20 D9       1218**  			JR      NZ,SRCH1_EV
0B2FF4 AF          1219**  			XOR     A               	; Flags: Z, NC
0B2FF5 C9          1220**  			RET                     	; Found
0B2FF6             1221**  ;
0B2FF6 F6 FF       1222**  SRCH4:			OR      0FFH            	; Flags: NZ, NC
0B2FF8 C9          1223**  			RET                     	; Not found
0B2FF9             1224**  
0B2FF9             1225**  ; we won't be using the following:
0B2FF9             1226**  ;CHRS - Return character with given ASCII value.
0B2FF9             1227**  ;Result is string.
0B2FF9             1228**  ;
0B2FF9 C9          1229**  CHRS:		ret
0B2FFA             1230**  			; CALL    ITEMI
0B2FFA             1231**  			; EXX
0B2FFA             1232**  			; LD      A,L
0B2FFA             1233**  			; JR      GET1
0B2FFA             1234**  ;
0B2FFA             1235**  ;GETS - Return key pressed as stringor character at position (X,Y).
0B2FFA             1236**  ;Result is string.
0B2FFA             1237**  ;
0B2FFA C9          1238**  GETS:		ret
0B2FFB             1239**  			; CALL	NXT		;NEW CODE FOR GET$(X,Y)
0B2FFB             1240**  			; CP	'('
0B2FFB             1241**  			; JP	Z, GETSCHR	;CALL FUNCTION IN PATCH.Z80
0B2FFB             1242**  			; CALL    OSRDCH
0B2FFB C9          1243**  GET1:		ret
0B2FFC             1244**  			; SCF
0B2FFC             1245**  			; JR      INKEY1
0B2FFC             1246**  ;
0B2FFC             1247**  ; INKEYS - Wait up to n centiseconds for keypress.
0B2FFC             1248**  ;          Return key pressed as string or null
0B2FFC             1249**  ;          string if time elapsed.
0B2FFC             1250**  ; Result is string.
0B2FFC             1251**  ;
0B2FFC C9          1252**  INKEYS:		ret
0B2FFD             1253**  			; CALL    ITEMI			; Fetch the argument
0B2FFD             1254**  			; EXX
0B2FFD C9          1255**  INKEY0:		ret
0B2FFE             1256**  			; CALL    OSKEY			; This is the entry point for INKEY(n)
0B2FFE C9          1257**  INKEY1:		ret
0B2FFF             1258**  			; LD      DE,ACCS			; Store the result in the string accumulator
0B2FFF             1259**  			; LD      (DE),A
0B2FFF             1260**  			; LD      A,80H
0B2FFF             1261**  			; RET     NC
0B2FFF             1262**  			; INC     E
0B2FFF             1263**  			; RET
0B2FFF             1264**  ;
0B2FFF             1265**  ; INKEYM - Check immediately whether a given key is being pressed
0B2FFF             1266**  ; Result is integer numeric
0B2FFF             1267**  ;
0B2FFF C9          1268**  INKEYM:		ret
0B3000             1269**  ; 			MOSCALL	mos_getkbmap		; Get the base address of the keyboard
0B3000             1270**  ; 			INC	HL			; Index from 0
0B3000             1271**  ; 			LD	A, L			; Negate the LSB of the answer
0B3000             1272**  ; 			NEG
0B3000             1273**  ; 			LD	C, A			;  E: The positive keycode value
0B3000             1274**  ; 			LD	A, 1			; Throw an "Out of range" error
0B3000             1275**  ; 			JP	M, ERROR_		; if the argument < - 128
0B3000             1276**  ; ;
0B3000             1277**  ; 			LD	HL, BITLOOKUP		; HL: The bit lookup table
0B3000             1278**  ; 			LD	DE, 0
0B3000             1279**  ; 			LD	A, C
0B3000             1280**  ; 			AND	00000111b		; Just need the first three bits
0B3000             1281**  ; 			LD	E, A			; DE: The bit number
0B3000             1282**  ; 			ADD	HL, DE
0B3000             1283**  ; 			LD	B, (HL)			;  B: The mask
0B3000             1284**  ; ;
0B3000             1285**  ; 			LD	A, C			; Fetch the keycode again
0B3000             1286**  ; 			AND	01111000b		; And divide by 8
0B3000             1287**  ; 			RRCA
0B3000             1288**  ; 			RRCA
0B3000             1289**  ; 			RRCA
0B3000             1290**  ; 			LD	E, A			; DE: The offset (the MSW has already been cleared previously)
0B3000             1291**  ; 			ADD	IX, DE			; IX: The address
0B3000             1292**  ; 			LD	A, B			;  B: The mask
0B3000             1293**  ; 			AND	(IX+0)			; Check whether the bit is set
0B3000             1294**  ; 			JP	Z, ZERO			; No, so return 0
0B3000             1295**  ; 			JP	FOR_EV			; Otherwise return -1
0B3000             1296**  
0B3000             1297**  ; end of the functions we won't be using
0B3000             1298**  
0B3000             1299**  ;
0B3000             1300**  ; A bit lookup table
0B3000             1301**  ;
0B3000 01 02 04 08 1302**  BITLOOKUP:		DB	01h, 02h, 04h, 08h
0B3004 10 20 40 80 1303**  			DB	10h, 20h, 40h, 80h
0B3008             1304**  ;
0B3008             1305**  ; MID$ - Return sub-string.
0B3008             1306**  ; Result is string.
0B3008             1307**  ;
0B3008 CD FC 31 0B 1308**  MIDS:			CALL    EXPRSC			; Get the first string expression
0B300C CD 8F 31 0B 1309**  			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B3010 CD FD 2B 0B 1310**  			CALL    EXPRI			; Get the second expression
0B3014 C1          1311**  			POP     BC			; C: String length, B: Value of A before PUSHS was called
0B3015 CD BC 31 0B 1312**  			CALL    POPS			; Pop the string back off the stack to the string accumulator
0B3019 D9          1313**  			EXX
0B301A 7D          1314**  			LD      A,L			; A: The start index
0B301B D9          1315**  			EXX
0B301C B7          1316**  			OR      A			; If the start index is 0, then we don't need to do the next bit
0B301D 28 0E       1317**  			JR      Z,MIDS1
0B301F 3D          1318**  			DEC     A
0B3020 6F          1319**  			LD      L,A			; L: The start index - 1
0B3021 93          1320**  			SUB     E			; Subtract from the string length
0B3022 1E 00       1321**  			LD      E,0			; Preemptively set the string length to 0
0B3024 30 07       1322**  			JR      NC,MIDS1		; If the first parameter is greater than the string length, then do nothing
0B3026 ED 44       1323**  			NEG				; Negate the answer and
0B3028 4F          1324**  			LD      C,A			; C: Number of bytes to copy
0B3029 CD 6C 30 0B 1325**  			CALL    RIGHT1			; We can do a RIGHT$ at this point with the result
0B302D CD 4A 32 0B 1326**  MIDS1:			CALL    NXT			; Skip whitespace
0B3031 FE 2C       1327**  			CP      ','			; Check for a comma
0B3033 FD 23       1328**  			INC     IY			; Advance to the next character in the BASIC line
0B3035 28 0D       1329**  			JR      Z,LEFT1			; If there is a comma then we do a LEFT$ on the remainder
0B3037 FD 2B       1330**  			DEC     IY			; Restore the BASIC program pointer
0B3039 CD 0D 32 0B 1331**  			CALL    BRAKET			; Check for a bracket
0B303D 3E 80       1332**  			LD      A,80H			; String marker
0B303F C9          1333**  			RET
0B3040             1334**  ;
0B3040             1335**  ; LEFT$ - Return left part of string.
0B3040             1336**  ; Carry cleared if entire string returned.
0B3040             1337**  ; Result is string.
0B3040             1338**  ;
0B3040 CD FC 31 0B 1339**  LEFTS:			CALL    EXPRSC			; Get the first string expression
0B3044 CD 8F 31 0B 1340**  LEFT1:			CALL    PUSHS           	; Push the string onto the stack from the string accumulator (ACCS)
0B3048 CD FD 2B 0B 1341**  			CALL    EXPRI			; Get the second expression
0B304C C1          1342**  			POP     BC			; C: String length, B: Value of A before PUSHS was called
0B304D CD BC 31 0B 1343**  			CALL    POPS			; Pop the string back off the stack to the string accumulator (ACCS)
0B3051 CD 0D 32 0B 1344**  			CALL    BRAKET			; Check for closing bracket
0B3055 D9          1345**  			EXX
0B3056 7D          1346**  			LD      A,L			; L: The second parameter
0B3057 D9          1347**  			EXX
0B3058 BB          1348**  			CP      E			; Compare with the string length
0B3059 30 02       1349**  			JR      NC,LEFT3		; If it is greater than or equal then do nothing
0B305B 6B          1350**  			LD      L,E             	; For RIGHTS, no effect in LEFTS
0B305C 5F          1351**  LEFT2:			LD      E,A			; E: The new length of string
0B305D 3E 80       1352**  LEFT3:			LD      A,80H           	; String marker
0B305F C9          1353**  			RET
0B3060             1354**  ;
0B3060             1355**  ; RIGHT$ - Return right part of string.
0B3060             1356**  ; Result is string.
0B3060             1357**  ;
0B3060 CD 40 30 0B 1358**  RIGHTS:			CALL    LEFTS			; Call LEFTS to get the string
0B3064 D0          1359**  			RET     NC			; Do nothing if the second parameter is >= string length
0B3065 1C          1360**  			INC     E			; Check for a zero length string
0B3066 1D          1361**  			DEC     E
0B3067 C8          1362**  			RET     Z			; Yes, so do nothing
0B3068 4B          1363**  			LD      C,E			;  C: Number of bytes to copy
0B3069 7D          1364**  			LD      A,L
0B306A 93          1365**  			SUB     E
0B306B 6F          1366**  			LD      L,A			;  L: Index into the string
0B306C 79          1367**  RIGHT1:			LD	A,C
0B306D 01 00 00 00 1368**  			LD	BC,0
0B3071 4F          1369**  			LD	C,A			; BC: Number of bytes to copy (with top word cleared)
0B3072 7D          1370**  			LD	A,L
0B3073 21 00 26 0B 1371**  			LD	HL,ACCS
0B3077 6F          1372**  			LD	L,A			; HL: Source (in ACCS)
0B3078 11 00 26 0B 1373**  			LD      DE,ACCS			; DE: Destination (start of ACCS)
0B307C ED B0       1374**  			LDIR                    	; Copy
0B307E 3E 80       1375**  			LD      A,80H			; String marker
0B3080 C9          1376**  			RET
0B3081             1377**  ;
0B3081             1378**  ; STRINGS - Return n concatenations of a string.
0B3081             1379**  ; Result is string.
0B3081             1380**  ;
0B3081 CD FD 2B 0B 1381**  STRING_:		CALL    EXPRI			; Get number of times to replicate
0B3085 CD 00 32 0B 1382**  			CALL    COMMA			; Check for comma
0B3089 D9          1383**  			EXX
0B308A 7D          1384**  			LD      A,L			; L: Number of iterations of string
0B308B D9          1385**  			EXX
0B308C F5          1386**  			PUSH    AF
0B308D CD 08 2C 0B 1387**  			CALL    EXPRS			; Get the string
0B3091 CD 0D 32 0B 1388**  			CALL    BRAKET			; Check for closing bracket
0B3095 F1          1389**  			POP     AF			; A: Number of iterations of string
0B3096 B7          1390**  			OR      A			; Set flags
0B3097 28 C3       1391**  			JR      Z,LEFT2         	; If iterations is 0, then this will return an empty string
0B3099 3D          1392**  			DEC     A
0B309A 4F          1393**  			LD      C,A			; C: Loop counter
0B309B 3E 80       1394**  			LD      A,80H			; String marker
0B309D C8          1395**  			RET     Z
0B309E 1C          1396**  			INC     E			; Check for empty string
0B309F 1D          1397**  			DEC     E
0B30A0 C8          1398**  			RET     Z              		; And return
0B30A1 43          1399**  			LD      B,E			; B: String length tally
0B30A2 21 00 26 0B 1400**  			LD	HL,ACCS
0B30A6 C5          1401**  STRIN1:			PUSH    BC
0B30A7 7E          1402**  STRIN2:			LD      A,(HL)
0B30A8 23          1403**  			INC     HL
0B30A9 12          1404**  			LD      (DE),A
0B30AA 1C          1405**  			INC     E
0B30AB 3E 13       1406**  			LD      A,19
0B30AD             1407**  			; JP      Z,ERROR_         	; Throw a "String too long" error
0B30AD 10 F8       1408**  			DJNZ    STRIN2
0B30AF C1          1409**  			POP     BC
0B30B0 0D          1410**  			DEC     C
0B30B1 20 F3       1411**  			JR      NZ,STRIN1
0B30B3 3E 80       1412**  			LD      A,80H
0B30B5 C9          1413**  			RET
0B30B6             1414**  ;
0B30B6             1415**  ;SUBROUTINES
0B30B6             1416**  ;
0B30B6             1417**  ;SWAP - Swap arguments
0B30B6             1418**  ;Exchanges DE,HL D'E',H'L' and B,C
0B30B6             1419**  ;Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B30B6             1420**  ;
0B30B6 79          1421**  SWAP:			LD      A,C
0B30B7 48          1422**  			LD      C,B
0B30B8 47          1423**  			LD      B,A
0B30B9 EB          1424**  			EX      DE,HL
0B30BA D9          1425**  			EXX
0B30BB EB          1426**  			EX      DE,HL
0B30BC D9          1427**  			EXX
0B30BD C9          1428**  			RET
0B30BE             1429**  ;
0B30BE             1430**  ;TEST - Test HLH'L' for zero
0B30BE             1431**  ;Outputs: Z-flag set & A=0 if zero
0B30BE             1432**  ;Destroys: A,F
0B30BE             1433**  ;
0B30BE 7C          1434**  TEST:			LD      A,H
0B30BF B5          1435**  			OR      L
0B30C0 D9          1436**  			EXX
0B30C1 B4          1437**  			OR      H
0B30C2 B5          1438**  			OR      L
0B30C3 D9          1439**  			EXX
0B30C4 C9          1440**  			RET
0B30C5             1441**  ;
0B30C5             1442**  ;DECODE - Decode line number in pseudo-binary.
0B30C5             1443**  ;   Inputs: IY = Text pointer.
0B30C5             1444**  ;   Outputs: HL=0, H'L'=line number, C=0.
0B30C5             1445**  ;   Destroys: A,C,H,L,H',L',IY,F
0B30C5             1446**  ;
0B30C5 D9          1447**  DECODE:			EXX
0B30C6 21 00 00 00 1448**  			LD	HL, 0
0B30CA FD 7E 00    1449**  			LD      A,(IY)
0B30CD FD 23       1450**  			INC     IY
0B30CF 17          1451**  			RLA
0B30D0 17          1452**  			RLA
0B30D1 67          1453**  			LD      H,A
0B30D2 E6 C0       1454**  			AND     0C0H
0B30D4 FD AE 00    1455**  			XOR     (IY)
0B30D7 FD 23       1456**  			INC     IY
0B30D9 6F          1457**  			LD      L,A
0B30DA 7C          1458**  			LD      A,H
0B30DB 17          1459**  			RLA
0B30DC 17          1460**  			RLA
0B30DD E6 C0       1461**  			AND     0C0H
0B30DF FD AE 00    1462**  			XOR     (IY)
0B30E2 FD 23       1463**  			INC     IY
0B30E4 67          1464**  			LD      H,A
0B30E5 D9          1465**  			EXX
0B30E6             1466**  ;			XOR     A
0B30E6             1467**  ;			LD      C,A
0B30E6             1468**  ;			LD      H,A
0B30E6             1469**  ;			LD      L,A
0B30E6 21 00 00 00 1470**  			LD	HL, 0
0B30EA 4D          1471**  			LD	C, L
0B30EB C9          1472**  			RET
0B30EC             1473**  ;
0B30EC             1474**  ;HEXSTR - convert numeric value to HEX string.
0B30EC             1475**  ;   Inputs: HLH'L'C = integer or floating-point number
0B30EC             1476**  ;  Outputs: String in string accumulator.
0B30EC             1477**  ;           E = string length.  D = ACCS/256
0B30EC             1478**  ;
0B30EC FD 23       1479**  HEXSTS:			INC     IY              ;SKIP TILDE
0B30EE CD 10 2C 0B 1480**  			CALL    ITEMN
0B30F2 CD F9 30 0B 1481**  			CALL    HEXSTR
0B30F6 3E 80       1482**  			LD      A,80H
0B30F8 C9          1483**  			RET
0B30F9             1484**  ;
0B30F9 CD A0 2E 0B 1485**  HEXSTR:			CALL    SFIX
0B30FD 01 08 00 00 1486**  			LD      BC,8
0B3101 11 00 26 0B 1487**  			LD      DE,ACCS
0B3105 C5          1488**  HEXST1:			PUSH    BC
0B3106 06 04       1489**  			LD      B,4
0B3108 AF          1490**  			XOR     A
0B3109 D9          1491**  HEXST2:			EXX
0B310A 52 29       1492**  			ADD.S	HL,HL
0B310C D9          1493**  			EXX
0B310D 52 ED 6A    1494**  			ADC.S	HL,HL
0B3110 17          1495**  			RLA
0B3111 10 F6       1496**  			DJNZ    HEXST2
0B3113 C1          1497**  			POP     BC
0B3114 0D          1498**  			DEC     C
0B3115 F8          1499**  			RET     M
0B3116 28 06       1500**  			JR      Z,HEXST3
0B3118 B7          1501**  			OR      A
0B3119 20 03       1502**  			JR      NZ,HEXST3
0B311B B8          1503**  			CP      B
0B311C 28 E7       1504**  			JR      Z,HEXST1
0B311E C6 90       1505**  HEXST3:			ADD     A,90H
0B3120 27          1506**  			DAA
0B3121 CE 40       1507**  			ADC     A,40H
0B3123 27          1508**  			DAA
0B3124 12          1509**  			LD      (DE),A
0B3125 13          1510**  			INC     DE
0B3126 47          1511**  			LD      B,A
0B3127 18 DC       1512**  			JR      HEXST1
0B3129             1513**  ;
0B3129             1514**  ;Function STR - convert numeric value to ASCII string.
0B3129             1515**  ;   Inputs: HLH'L'C = integer or floating-point number.
0B3129             1516**  ;  Outputs: String in string accumulator.
0B3129             1517**  ;           E = length, D = ACCS/256
0B3129             1518**  ;           A = 80H (type=string)
0B3129             1519**  ;
0B3129             1520**  ;First normalise for decimal output:
0B3129             1521**  ;
0B3129 CD 4A 32 0B 1522**  STRS:			CALL    NXT
0B312D FE 7E       1523**  			CP      '~'
0B312F 28 BB       1524**  			JR      Z,HEXSTS
0B3131 CD 10 2C 0B 1525**  			CALL    ITEMN
0B3135 DD 21 00 28 1526**  			LD      IX,STAVAR
       0B          
0B313A DD 7E 03    1527**  			LD      A,(IX+3)
0B313D B7          1528**  			OR      A
0B313E DD 21 67 31 1529**  			LD      IX,G9-1         ;G9 FORMAT
       0B          
0B3143 28 05       1530**  			JR      Z,STR0
0B3145 DD 21 00 28 1531**  STR:			LD      IX,STAVAR
       0B          
0B314A 11 00 26 0B 1532**  STR0:			LD      DE,ACCS
0B314E 3E 25       1533**  			LD      A,37
0B3150 CD 72 32 0B 1534**  			CALL    FPP
0B3154             1535**  			; JP      C,ERROR_
0B3154 DD CB 02 46 1536**  			BIT     0,(IX+2)
0B3158 3E 80       1537**  STR1:			LD      A,80H           ;STRING MARKER
0B315A C8          1538**  			RET     Z
0B315B 79          1539**  			LD      A,C
0B315C C6 04       1540**  			ADD     A,4
0B315E BB          1541**  STR2_EV:			CP      E
0B315F 28 F7       1542**  			JR      Z,STR1
0B3161 EB          1543**  			EX      DE,HL
0B3162 36 20       1544**  			LD      (HL),' '        ;TRAILING SPACE
0B3164 23          1545**  			INC     HL
0B3165 EB          1546**  			EX      DE,HL
0B3166 18 F6       1547**  			JR      STR2_EV
0B3168             1548**  ;
0B3168 09 00       1549**  G9:			DW    9
0B316A             1550**  ;
0B316A             1551**  ;STRING COMPARE
0B316A             1552**  ;Compare string (DE) length B with string (HL) length C.
0B316A             1553**  ;Result preset to false.
0B316A             1554**  ;
0B316A CD 78 31 0B 1555**  SCP:			CALL	SCP0
0B316E             1556**  ;
0B316E 3E 00       1557**  ZERO:			LD      A,0
0B3170 D9          1558**  			EXX
0B3171 67          1559**  			LD      H,A
0B3172 6F          1560**  			LD      L,A
0B3173 D9          1561**  			EXX
0B3174 67          1562**  			LD      H,A
0B3175 6F          1563**  			LD      L,A
0B3176 4F          1564**  			LD      C,A
0B3177 C9          1565**  			RET
0B3178             1566**  ;
0B3178 04          1567**  SCP0:			INC     B
0B3179 0C          1568**  			INC     C
0B317A 05          1569**  SCP1:			DEC     B
0B317B 28 0A       1570**  			JR      Z,SCP2
0B317D 0D          1571**  			DEC     C
0B317E 28 0C       1572**  			JR      Z,SCP3
0B3180 1A          1573**  			LD      A,(DE)
0B3181 BE          1574**  			CP      (HL)
0B3182 C0          1575**  			RET     NZ
0B3183 13          1576**  			INC     DE
0B3184 23          1577**  			INC     HL
0B3185 18 F3       1578**  			JR      SCP1
0B3187 B7          1579**  SCP2:			OR      A
0B3188 0D          1580**  			DEC     C
0B3189 C8          1581**  			RET     Z
0B318A 37          1582**  			SCF
0B318B C9          1583**  			RET
0B318C B7          1584**  SCP3:			OR      A
0B318D 0C          1585**  			INC     C
0B318E C9          1586**  			RET
0B318F             1587**  ;
0B318F             1588**  ; PUSHS - SAVE STRING ON STACK.
0B318F             1589**  ;     Inputs: String in string accumulator.
0B318F             1590**  ;             E = string length.
0B318F             1591**  ;             A - saved on stack.
0B318F             1592**  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0B318F             1593**  ;
0B318F CD 57 40 0B 1594**  PUSHS:			CALL    CHECK			; Check if there is sufficient space on the stack
0B3193 DD E1       1595**  			POP     IX              	; IX: Return address
0B3195 B7          1596**  			OR      A               	; Clear the carry flag
0B3196 01 00 00 00 1597**  			LD	BC,0			; BC: Length of the string
0B319A 4B          1598**  			LD	C,E
0B319B 21 00 26 0B 1599**  			LD      HL,ACCS			; HL: Pointer to the string accumulator
0B319F 11 00 26 0B 1600**  			LD	DE,ACCS
0B31A3 59          1601**  			LD	E,C 			; DE: Pointer to the end of the string in the accumulator
0B31A4 ED 52       1602**  			SBC     HL,DE			; HL: Number of bytes to reserve on the stack (a negative number)
0B31A6 39          1603**  			ADD     HL,SP			; Grow the stack
0B31A7 F9          1604**  			LD      SP,HL
0B31A8 57          1605**  			LD      D,A			;  D: This needs to be set to A for some functions
0B31A9 47          1606**  			LD	B,A			; Stack A and C (the string length)
0B31AA C5          1607**  			PUSH    BC			; Note that this stacks 3 bytes, not 2; the MSB is irrelevant
0B31AB 06 00       1608**  			LD	B,0			; Reset B to 0 for the LDIR in this function
0B31AD 28 0B       1609**  			JR      Z,PUSHS1        	; Is it zero length?
0B31AF 11 00 26 0B 1610**  			LD      DE,ACCS			; DE: Destination
0B31B3 EB          1611**  			EX      DE,HL			; HL: Destination, DE: Address on stack
0B31B4 ED B0       1612**  			LDIR	                    	; Copy to stack
0B31B6 CD 57 40 0B 1613**  			CALL    CHECK			; Final check to see if there is sufficient space on the stack
0B31BA DD E9       1614**  PUSHS1:			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B31BC             1615**  ;
0B31BC             1616**  ; POPS - RESTORE STRING FROM STACK.
0B31BC             1617**  ;     Inputs: C = string length.
0B31BC             1618**  ;    Outputs: String in string accumulator.
0B31BC             1619**  ;             E = string length.
0B31BC             1620**  ;   Destroys: B,C,D,E,H,L,IX,SP,F
0B31BC             1621**  ;
0B31BC DD E1       1622**  POPS:			POP     IX              	; IX: Return address
0B31BE 69          1623**  			LD	L,C			; Temporarily store string length in L
0B31BF 01 00 00 00 1624**  			LD	BC,0
0B31C3 4D          1625**  			LD	C,L			; BC: Number of bytes to copy
0B31C4 21 00 00 00 1626**  			LD      HL,0			; HL: 0
0B31C8 39          1627**  			ADD     HL,SP			; HL: Stack address
0B31C9 11 00 26 0B 1628**  			LD      DE,ACCS			; DE: Destination
0B31CD 0C          1629**  			INC     C			; Quick check to see if this is a zero length string
0B31CE 0D          1630**  			DEC     C
0B31CF 28 02       1631**  			JR      Z,POPS1         	; Yes it is, so skip
0B31D1 ED B0       1632**  			LDIR                    	; No, so copy from the stack
0B31D3 F9          1633**  POPS1:			LD      SP,HL			; Shrink the stack
0B31D4 DD E9       1634**  			JP      (IX)            	; Effectively "RET" (IX contains the return address)
0B31D6             1635**  ;
0B31D6 FD 7E 00    1636**  HEXDIG:			LD      A,(IY)
0B31D9 FE 30       1637**  			CP      '0'
0B31DB D8          1638**  			RET     C
0B31DC FE 3A       1639**  			CP      '9'+1
0B31DE 3F          1640**  			CCF
0B31DF D0          1641**  			RET     NC
0B31E0 FE 41       1642**  			CP      'A'
0B31E2 D8          1643**  			RET     C
0B31E3 D6 37       1644**  			SUB     'A'-10
0B31E5 FE 10       1645**  			CP      16
0B31E7 3F          1646**  			CCF
0B31E8 C9          1647**  			RET
0B31E9             1648**  ;
0B31E9 FD 7E 00    1649**  BINDIG:			LD	A,(IY)
0B31EC FE 30       1650**  			CP	'0'
0B31EE D8          1651**  			RET	C
0B31EF FE 32       1652**  			CP	'1'+1
0B31F1 3F          1653**  			CCF
0B31F2 C9          1654**  			RET
0B31F3             1655**  ;
0B31F3 FE 3E       1656**  RELOP?:			CP      '>'
0B31F5 D0          1657**  			RET     NC
0B31F6 FE 3D       1658**  			CP      '='
0B31F8 D0          1659**  			RET     NC
0B31F9 FE 3C       1660**  			CP      '<'
0B31FB C9          1661**  			RET
0B31FC             1662**  ;
0B31FC CD 08 2C 0B 1663**  EXPRSC:			CALL    EXPRS
0B3200 CD 4A 32 0B 1664**  COMMA:			CALL    NXT
0B3204 FD 23       1665**  			INC     IY
0B3206 FE 2C       1666**  			CP      ','
0B3208 C8          1667**  			RET     Z
0B3209 3E 05       1668**  			LD      A,5
0B320B 18 0B       1669**  			JR      ERROR1_EV          ;"Missing ,"
0B320D             1670**  ;
0B320D CD 4A 32 0B 1671**  BRAKET:			CALL    NXT
0B3211 FD 23       1672**  			INC     IY
0B3213 FE 29       1673**  			CP      ')'
0B3215 C8          1674**  			RET     Z
0B3216 3E 1B       1675**  			LD      A,27
0B3218             1676**  ERROR1_EV:
0B3218             1677**  	; JP      ERROR_           ;"Missing )"
0B3218             1678**  ;
0B3218 FD 23       1679**  SAVE_EV:			INC     IY
0B321A 08          1680**  SAVE1:			EX      AF,AF'
0B321B FA 29 2C 0B 1681**  			JP      M,TYPE_EV_
0B321F 08          1682**  			EX      AF,AF'
0B3220 E3          1683**  			EX      (SP),HL
0B3221 D9          1684**  			EXX
0B3222 E5          1685**  			PUSH    HL
0B3223 D9          1686**  			EXX
0B3224 F5          1687**  			PUSH    AF
0B3225 C5          1688**  			PUSH    BC
0B3226 E9          1689**  			JP      (HL)
0B3227             1690**  ;
0B3227 08          1691**  DOIT:			EX      AF,AF'
0B3228 FA 29 2C 0B 1692**  			JP      M,TYPE_EV_
0B322C D9          1693**  			EXX
0B322D C1          1694**  			POP     BC              ;RETURN ADDRESS
0B322E D9          1695**  			EXX
0B322F 79          1696**  			LD      A,C
0B3230 C1          1697**  			POP     BC
0B3231 47          1698**  			LD      B,A
0B3232 F1          1699**  			POP     AF              ;OPERATOR
0B3233 D9          1700**  			EXX
0B3234 EB          1701**  			EX      DE,HL
0B3235 E1          1702**  			POP     HL
0B3236 D9          1703**  			EXX
0B3237 EB          1704**  			EX      DE,HL
0B3238 E1          1705**  			POP     HL
0B3239 D9          1706**  			EXX
0B323A C5          1707**  			PUSH    BC
0B323B D9          1708**  			EXX
0B323C E6 0F       1709**  			AND     0FH
0B323E CD 72 32 0B 1710**  			CALL    FPP
0B3242 38 D4       1711**  			JR      C,ERROR1_EV
0B3244 AF          1712**  			XOR     A
0B3245 08          1713**  			EX      AF,AF'          ;TYPE
0B3246 FD 7E 00    1714**  			LD      A,(IY)
0B3249 C9          1715**  			RET
0B324A             1716**  ;
0B324A             1717**  ; Skip spaces
0B324A             1718**  ; - IY: String pointer
0B324A             1719**  ; Returns:
0B324A             1720**  ;  - A: The non-space character found
0B324A             1721**  ; - IY: Points to the character before that
0B324A             1722**  ;
0B324A FD 7E 00    1723**  NXT:			LD      A,(IY)			; Fetch the character
0B324D FE 20       1724**  			CP      ' '			; If it is space, then return
0B324F C0          1725**  			RET     NZ
0B3250 FD 23       1726**  			INC     IY			; Increment the pointer and
0B3252 C3 4A 32 0B 1727**  			JP      NXT			; Loop
0B3256             1728**  ;
0B3256 E5          1729**  DISPT2:			PUSH    HL
0B3257 21 AC 2A 0B 1730**  			LD      HL,SOPTBL
0B325B 18 07       1731**  			JR      DISPT0
0B325D             1732**  ;
0B325D E5          1733**  DISPAT_EV:			PUSH    HL
0B325E D6 8D       1734**  			SUB     FUNTOK
0B3260 21 00 2A 0B 1735**  			LD      HL,FUNTBL
0B3264 C5          1736**  DISPT0:			PUSH    BC
0B3265             1737**  
0B3265 01 03 00 00 1738**  			LD	BC, 3
0B3269 47          1739**  			LD	B, A
0B326A ED 4C       1740**  			MLT	BC
0B326C 09          1741**  			ADD	HL, BC
0B326D ED 27       1742**  			LD	HL, (HL)
0B326F             1743**  
0B326F             1744**  ;			ADD     A,A
0B326F             1745**  ;			LD      C,A
0B326F             1746**  ;			LD      B,0
0B326F             1747**  ;			ADD     HL,BC
0B326F             1748**  ;			LD      A,(HL)
0B326F             1749**  ;			INC     HL
0B326F             1750**  ;			LD      H,(HL)
0B326F             1751**  ;			LD      L,A
0B326F             1752**  
0B326F C1          1753**  			POP     BC
0B3270 E3          1754**  			EX      (SP),HL
0B3271 C9          1755**  			RET                     ;OFF TO ROUTINE
0B3272             1756**  
0B3272             0003*       INCLUDE	"basic/equs.inc"
0B3272             0001**  ;
0B3272             0002**  ; Title:	BBC Basic for AGON - Equs
0B3272             0003**  ; Author:	Dean Belfield
0B3272             0004**  ; Created:	12/05/2023
0B3272             0005**  ; Last Updated:	08/06/2023
0B3272             0006**  ;
0B3272             0007**  ; Modinfo:
0B3272             0008**  ; 08/06/2023:	Added SIZEW
0B3272             0009**  
0B3272             0010**  			; XREF		STAVAR
0B3272             0011**  			; XREF		ACCS
0B3272             0012**  
0B3272             0013**  RAM_Top:		EQU		0B0000h	; Initial value of HIMEM
0B3272             0014**  ;Stack_Top:		EQU		0000h	; Stack at top
0B3272             0015**  SIZEW:			EQU		3	; Size of a word (3 for ADL mode)
0B3272             0016**  
0B3272             0017**  ; For GPIO
0B3272             0018**  ; PA not available on eZ80L92
0B3272             0019**  ;
0B3272             0020**  PA_DR:			EQU		96h
0B3272             0021**  PA_DDR:			EQU		97h
0B3272             0022**  PA_ALT1:		EQU		98h
0B3272             0023**  PA_ALT2:		EQU		99h
0B3272             0024**  PB_DR:          	EQU		9Ah
0B3272             0025**  PB_DDR:        	 	EQU		9Bh
0B3272             0026**  PB_ALT1:        	EQU		9Ch
0B3272             0027**  PB_ALT2:        	EQU		9Dh
0B3272             0028**  PC_DR:          	EQU		9Eh
0B3272             0029**  PC_DDR:         	EQU		9Fh
0B3272             0030**  PC_ALT1:        	EQU		A0h
0B3272             0031**  PC_ALT2:        	EQU		A1h
0B3272             0032**  PD_DR:          	EQU		A2h
0B3272             0033**  PD_DDR:			EQU		A3h
0B3272             0034**  PD_ALT1:		EQU		A4h
0B3272             0035**  PD_ALT2:		EQU		A5h
0B3272             0036**  
0B3272             0037**  GPIOMODE_OUT:		EQU		0	; Output
0B3272             0038**  GPIOMODE_IN:		EQU		1	; Input
0B3272             0039**  GPIOMODE_DIO:		EQU		2	; Open Drain IO
0B3272             0040**  GPIOMODE_SIO:		EQU		3	; Open Source IO
0B3272             0041**  GPIOMODE_INTD:		EQU		4	; Interrupt, Dual Edge
0B3272             0042**  GPIOMODE_ALTF:		EQU		5;	; Alt Function
0B3272             0043**  GPIOMODE_INTAL:		EQU		6	; Interrupt, Active Low
0B3272             0044**  GPIOMODE_INTAH:		EQU		7	; Interrupt, Active High
0B3272             0045**  GPIOMODE_INTFE:		EQU		8	; Interrupt, Falling Edge
0B3272             0046**  GPIOMODE_INTRE:		EQU		9	; Interrupt, Rising Edge
0B3272             0047**  
0B3272             0048**  ; Originally in ram.asm
0B3272             0049**  ;
0B3272             0050**  OC:			EQU     STAVAR+15*4     ; CODE ORIGIN (O%)
0B3272             0051**  PC:			EQU     STAVAR+16*4     ; PROGRAM COUNTER (P%)
0B3272             0052**  VDU_BUFFER:		EQU	ACCS		; Storage for VDU commands
0B3272             0053**  
0B3272             0054**  ; Originally in main.asm
0B3272             0055**  ;
0B3272             0056**  CR:			EQU     0DH
0B3272             0057**  LF:			EQU     0AH
0B3272             0058**  ESC:			EQU     1BH
0B3272             0004*       INCLUDE "basic/macros.inc"
0B3272             0001**  	; Title:	BBC Basic Interpreter - Z80 version
0B3272             0002**  	;		Useful macros
0B3272             0003**  	; Author:	Dean Belfield
0B3272             0004**  	; Created:	12/05/2023
0B3272             0005**  	; Last Updated:	11/06/2023
0B3272             0006**  	;
0B3272             0007**  	; Modinfo:
0B3272             0008**  	; 11/06/2023:	Modified to run in ADL mode
0B3272             0009**  	; 11/06/2024:   Make compatible with ez80asm by Brandon R. Gates
0B3272             0010**  
0B3272             0011**  	MACRO EXREG	rp1, rp2
0B3272             0012**  		PUSH	rp1
0B3272             0013**  		POP	rp2
0B3272             0014**  	ENDMACRO
0B3272             0015**  
0B3272             0016**  	; MACRO ADD8U_DE	reg
0B3272             0017**  		MACRO ADD8U_DE
0B3272             0018**  		ADD	A, E
0B3272             0019**  		LD	E, A
0B3272             0020**  		ADC	A, D
0B3272             0021**  		SUB	E
0B3272             0022**  		LD	D, A
0B3272             0023**  	ENDMACRO
0B3272             0024**  
0B3272             0025**  	; MACRO ADD8U_HL	reg
0B3272             0026**  	MACRO ADD8U_HL
0B3272             0027**  		ADD	A, L
0B3272             0028**  		LD	L, A
0B3272             0029**  		ADC	A, H
0B3272             0030**  		SUB	L
0B3272             0031**  		LD	H, A
0B3272             0032**  	ENDMACRO
0B3272             0033**  
0B3272             0034**  	MACRO VDU	val
0B3272             0035**  		LD	A, val
0B3272             0036**  		CALL	OSWRCH
0B3272             0037**  	ENDMACRO
0B3272             0038**  
0B3272             0039**  	MACRO SET_GPIO	reg, val
0B3272             0040**  		IN0	A, (reg)
0B3272             0041**  		OR	val
0B3272             0042**  		OUT0	(reg), A
0B3272             0043**  	ENDMACRO
0B3272             0044**  
0B3272             0045**  	MACRO RES_GPIO	reg, val
0B3272             0046**  		PUSH	BC
0B3272             0047**  		LD	A, val
0B3272             0048**  		CPL
0B3272             0049**  		LD	C, A
0B3272             0050**  		IN0	A, (reg)
0B3272             0051**  		AND	C
0B3272             0052**  		OUT0	(reg), A
0B3272             0053**  		POP	BC
0B3272             0054**  	ENDMACRO
0B3272             0005*       include "basic/fpp.asm"
0B3272             0001**  ;
0B3272             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B3272             0003**  ;		Z80 Floating Point Package
0B3272             0004**  ; Author:	(C) Copyright  R.T.Russell  1986
0B3272             0005**  ; Modified By:	Dean Belfield
0B3272             0006**  ; Created:	03/05/2022
0B3272             0007**  ; Last Updated:	07/06/2023
0B3272             0008**  ;
0B3272             0009**  ; Modinfo:
0B3272             0010**  ; 26/10/1986:	Version 0.0
0B3272             0011**  ; 14/12/1988:	Vesion 0.1 (Bug Fix)
0B3272             0012**  ; 12/05/2023:	Modified by Dean Belfield
0B3272             0013**  ; 07/06/2023:	Modified to run in ADL mode
0B3272             0014**  
0B3272             0015**  			.ASSUME	ADL = 1
0B3272             0016**  
0B3272             0017**  			; SEGMENT CODE
0B3272             0018**  
0B3272             0019**  			; XDEF	FPP
0B3272             0020**  			; XDEF	DLOAD5
0B3272             0021**  			; XDEF	DLOAD5_SPL
0B3272             0022**  ;
0B3272             0023**  ;BINARY FLOATING POINT REPRESENTATION:
0B3272             0024**  ;   32 BIT SIGN-MAGNITUDE NORMALIZED MANTISSA
0B3272             0025**  ;    8 BIT EXCESS-128 SIGNED EXPONENT
0B3272             0026**  ;   SIGN BIT REPLACES MANTISSA MSB (IMPLIED "1")
0B3272             0027**  ;   MANTISSA=0 & EXPONENT=0 IMPLIES VALUE IS ZERO.
0B3272             0028**  ;
0B3272             0029**  ;BINARY INTEGER REPRESENTATION:
0B3272             0030**  ;   32 BIT 2'S-COMPLEMENT SIGNED INTEGER
0B3272             0031**  ;    "EXPONENT" BYTE = 0 (WHEN PRESENT)
0B3272             0032**  ;
0B3272             0033**  ;NORMAL REGISTER ALLOCATION: MANTISSA - HLH'L'
0B3272             0034**  ;                            EXPONENT - C
0B3272             0035**  ;ALTERNATE REGISTER ALLOCATION: MANTISSA - DED'E'
0B3272             0036**  ;                               EXPONENT - B
0B3272             0037**  
0B3272             0038**  ;
0B3272             0039**  ;Error codes:
0B3272             0040**  ;
0B3272             0041**  
0B3272             0042**  BADOP:			EQU     1               ;Bad operation code
0B3272             0043**  DIVBY0:			EQU     18              ;Division by zero
0B3272             0044**  TOOBIG:			EQU     20              ;Too big
0B3272             0045**  NGROOT:			EQU     21              ;Negative root
0B3272             0046**  LOGRNG:			EQU     22              ;Log range
0B3272             0047**  ACLOST:			EQU     23              ;Accuracy lost
0B3272             0048**  EXPRNG:			EQU     24              ;Exp range
0B3272             0049**  ;
0B3272             0050**  ;Call entry and despatch code:
0B3272             0051**  ;
0B3272 FD E5       0052**  FPP:			PUSH    IY              ;Save IY
0B3274 FD 21 00 00 0053**          		LD      IY,0
       00          
0B3279 FD 39       0054**          		ADD     IY,SP           ;Save SP in IY
0B327B CD 8B 32 0B 0055**          		CALL    OP              ;Perform operation
0B327F BF          0056**          		CP      A               ;Good return (Z, NC)
0B3280 FD E1       0057**  EXIT_:			POP     IY              ;Restore IY
0B3282 C9          0058**          		RET                     ;Return to caller
0B3283             0059**  ;
0B3283             0060**  ;Error exit:
0B3283             0061**  ;
0B3283 3E 01       0062**  BAD:			LD      A,BADOP         ;"Bad operation code"
0B3285 FD F9       0063**  ERROR_FP:			LD      SP,IY           ;Restore SP from IY
0B3287 B7          0064**          		OR      A               ;Set NZ
0B3288 37          0065**          		SCF                     ;Set C
0B3289 18 F5       0066**          		JR      EXIT_
0B328B             0067**  ;
0B328B             0068**  ;Perform operation or function:
0B328B             0069**  ;
0B328B             0070**  ; OP:			CP      (RTABLE-DTABLE)/3
0B328B FE 2A       0071**  OP:				CP      RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B328D 30 F4       0072**          		JR      NC,BAD
0B328F             0073**          		; CP      (FTABLE-DTABLE)/3
0B328F FE 10       0074**          		CP      FTABLE-DTABLE/3 ; ditto
0B3291 30 08       0075**          		JR      NC,DISPATCH
0B3293 08          0076**          		EX      AF,AF'
0B3294 78          0077**          		LD      A,B
0B3295 B1          0078**          		OR      C               ;Both integer?
0B3296 C4 9E 3D 0B 0079**          		CALL    NZ,FLOATA       ;No, so float both
0B329A 08          0080**          		EX      AF,AF'
0B329B E5          0081**  DISPATCH:			PUSH    HL
0B329C 21 AE 32 0B 0082**          		LD      HL,DTABLE
0B32A0 C5          0083**          		PUSH    BC
0B32A1 01 03 00 00 0084**  			LD	BC, 3		; C = 3
0B32A5 47          0085**  			LD	B, A 		; B = op-code
0B32A6 ED 4C       0086**  			MLT 	BC 		;BC = op-code * 3
0B32A8 09          0087**  			ADD	HL, BC 		;Add to table base
0B32A9 ED 27       0088**  			LD	HL, (HL)	;Get the routine address (24-bit)
0B32AB             0089**  
0B32AB             0090**  ;        		ADD     A, A            ;A = op-code * 2
0B32AB             0091**  ;        		LD      C,A
0B32AB             0092**  ;        		LD      B,0             ;BC = op-code * 2
0B32AB             0093**  ;        		ADD     HL,BC
0B32AB             0094**  ;        		LD      A,(HL)          ;Get low byte
0B32AB             0095**  ;        		INC     HL
0B32AB             0096**  ;        		LD      H,(HL)          ;Get high byte
0B32AB             0097**  ;        		LD      L,A
0B32AB             0098**  
0B32AB C1          0099**          		POP     BC
0B32AC E3          0100**          		EX      (SP),HL
0B32AD C9          0101**          		RET                     ;Off to routine
0B32AE             0102**  ;
0B32AE             0103**  ;Despatch table:
0B32AE             0104**  ;
0B32AE 60 33 0B    0105**  DTABLE:			DW24  IAND            ;AND (INTEGER)
0B32B1 CE 33 0B    0106**          		DW24  IBDIV           ;DIV
0B32B4 73 33 0B    0107**          		DW24  IEOR            ;EOR
0B32B7 99 33 0B    0108**          		DW24  IMOD            ;MOD
0B32BA 86 33 0B    0109**          		DW24  IOR             ;OR
0B32BD 54 36 0B    0110**          		DW24  ILE             ;<=
0B32C0 63 36 0B    0111**          		DW24  INE             ;<>
0B32C3 47 36 0B    0112**          		DW24  IGE             ;>=
0B32C6 2C 36 0B    0113**          		DW24  ILT             ;<
0B32C9 70 36 0B    0114**          		DW24  IEQ             ;=
0B32CC BC 34 0B    0115**          		DW24  IMUL            ;*
0B32CF F7 33 0B    0116**          		DW24  IADD            ;+
0B32D2 39 36 0B    0117**          		DW24  IGT             ;>
0B32D5 DE 33 0B    0118**          		DW24  ISUB            ;-
0B32D8 73 35 0B    0119**          		DW24  IPOW            ;^
0B32DB 69 34 0B    0120**          		DW24  IDIV            ;/
0B32DE             0121**  ;
0B32DE 82 36 0B    0122**  FTABLE:			DW24  ABSV            ;ABS
0B32E1 68 3A 0B    0123**          		DW24  ACS             ;ACS
0B32E4 A6 39 0B    0124**          		DW24  ASN             ;ASN
0B32E7 D6 39 0B    0125**          		DW24  ATN             ;ATN
0B32EA A1 37 0B    0126**          		DW24  COS             ;COS
0B32ED B0 36 0B    0127**          		DW24  DEG             ;DEG
0B32F0 5D 38 0B    0128**          		DW24  EXP             ;EXP
0B32F3 04 37 0B    0129**          		DW24  INT_            ;INT
0B32F6 FB 38 0B    0130**          		DW24  LN              ;LN
0B32F9 90 39 0B    0131**          		DW24  LOG             ;LOG
0B32FC 8E 36 0B    0132**          		DW24  NOTK            ;NOT
0B32FF BA 36 0B    0133**          		DW24  RAD             ;RAD
0B3302 D5 36 0B    0134**          		DW24  SGN             ;SGN
0B3305 AE 37 0B    0135**          		DW24  SIN             ;SIN
0B3308 1D 37 0B    0136**          		DW24  SQR             ;SQR
0B330B 7B 37 0B    0137**          		DW24  TAN             ;TAN
0B330E             0138**  ;
0B330E 2B 3E 0B    0139**  		        DW24  FPZERO            ;ZERO
0B3311 36 38 0B    0140**          		DW24  FONE            ;FONE
0B3314 75 36 0B    0141**          		DW24  TRUE            ;TRUE
0B3317 A2 36 0B    0142**          		DW24  PI              ;PI
0B331A             0143**  ;
0B331A E9 36 0B    0144**  		        DW24  VAL             ;VAL
0B331D 71 3A 0B    0145**          		DW24  STRING             ;STRING$
0B3320             0146**  ;
0B3320 D2 3C 0B    0147**          		DW24  SFIX_FP            ;FIX
0B3323 AE 3D 0B    0148**          		DW24  SFLOAT          ;FLOAT
0B3326             0149**  ;
0B3326 FC 3D 0B    0150**  		        DW24  FTEST           ;TEST
0B3329 0E 3E 0B    0151**          		DW24  FCOMP           ;COMPARE
0B332C             0152**  ;
0B332C 5C 33 0B    0153**  RTABLE:			DW24  FAND            ;AND (FLOATING-POINT)
0B332F CA 33 0B    0154**          		DW24  FBDIV           ;DIV
0B3332 6F 33 0B    0155**          		DW24  FEOR            ;EOR
0B3335 95 33 0B    0156**          		DW24  FMOD            ;MOD
0B3338 82 33 0B    0157**          		DW24  FFOR             ;OR (FLOATING-POINT)
0B333B 4E 36 0B    0158**          		DW24  FLE             ;<=
0B333E 5D 36 0B    0159**          		DW24  FNE             ;<>
0B3341 41 36 0B    0160**          		DW24  FGE             ;>=
0B3344 26 36 0B    0161**          		DW24  FLT             ;<
0B3347 6A 36 0B    0162**          		DW24  FEQ             ;=
0B334A 16 35 0B    0163**          		DW24  FMUL            ;*
0B334D 04 34 0B    0164**          		DW24  FADD            ;+
0B3350 33 36 0B    0165**          		DW24  FGT             ;>
0B3353 EB 33 0B    0166**          		DW24  FSUB            ;-
0B3356 F3 35 0B    0167**          		DW24  FPOW            ;^
0B3359 6D 34 0B    0168**          		DW24  FDIV            ;/
0B335C             0169**  ;
0B335C             0170**  ;       PAGE
0B335C             0171**  ;
0B335C             0172**  ;ARITHMETIC AND LOGICAL OPERATORS:
0B335C             0173**  ;All take two arguments, in HLH'L'C & DED'E'B.
0B335C             0174**  ;Output in HLH'L'C
0B335C             0175**  ;All registers except IX, IY destroyed.
0B335C             0176**  ; (N.B. FPOW destroys IX).
0B335C             0177**  ;
0B335C             0178**  ;FAND - Floating-point AND.
0B335C             0179**  ;IAND - Integer AND.
0B335C             0180**  ;
0B335C CD C6 3C 0B 0181**  FAND:			CALL    FIX2
0B3360 7C          0182**  IAND:			LD      A,H
0B3361 A2          0183**          		AND     D
0B3362 67          0184**          		LD      H,A
0B3363 7D          0185**          		LD      A,L
0B3364 A3          0186**          		AND     E
0B3365 6F          0187**          		LD      L,A
0B3366 D9          0188**          		EXX
0B3367 7C          0189**          		LD      A,H
0B3368 A2          0190**          		AND     D
0B3369 67          0191**          		LD      H,A
0B336A 7D          0192**          		LD      A,L
0B336B A3          0193**          		AND     E
0B336C 6F          0194**          		LD      L,A
0B336D D9          0195**          		EXX
0B336E C9          0196**          		RET
0B336F             0197**  ;
0B336F             0198**  ;FEOR - Floating-point exclusive-OR.
0B336F             0199**  ;IEOR - Integer exclusive-OR.
0B336F             0200**  ;
0B336F CD C6 3C 0B 0201**  FEOR:			CALL    FIX2
0B3373 7C          0202**  IEOR:			LD      A,H
0B3374 AA          0203**          		XOR     D
0B3375 67          0204**          		LD      H,A
0B3376 7D          0205**          		LD      A,L
0B3377 AB          0206**          		XOR     E
0B3378 6F          0207**          		LD      L,A
0B3379 D9          0208**          		EXX
0B337A 7C          0209**          		LD      A,H
0B337B AA          0210**          		XOR     D
0B337C 67          0211**          		LD      H,A
0B337D 7D          0212**          		LD      A,L
0B337E AB          0213**          		XOR     E
0B337F 6F          0214**          		LD      L,A
0B3380 D9          0215**          		EXX
0B3381 C9          0216**          		RET
0B3382             0217**  ;
0B3382             0218**  ;FFOR - Floating-point OR.
0B3382             0219**  ;IOR - Integer OR.
0B3382             0220**  ;
0B3382 CD C6 3C 0B 0221**  FFOR:			CALL    FIX2
0B3386 7C          0222**  IOR:			LD      A,H
0B3387 B2          0223**          		OR      D
0B3388 67          0224**          		LD      H,A
0B3389 7D          0225**          		LD      A,L
0B338A B3          0226**          		OR      E
0B338B 6F          0227**          		LD      L,A
0B338C D9          0228**          		EXX
0B338D 7C          0229**          		LD      A,H
0B338E B2          0230**          		OR      D
0B338F 67          0231**          		LD      H,A
0B3390 7D          0232**          		LD      A,L
0B3391 B3          0233**          		OR      E
0B3392 6F          0234**          		LD      L,A
0B3393 D9          0235**          		EXX
0B3394 C9          0236**          		RET
0B3395             0237**  ;
0B3395             0238**  ;FMOD - Floating-point remainder.
0B3395             0239**  ;IMOD - Integer remainder.
0B3395             0240**  ;
0B3395 CD C6 3C 0B 0241**  FMOD:			CALL    FIX2
0B3399 7C          0242**  IMOD:			LD      A,H
0B339A AA          0243**          		XOR     D               ;DIV RESULT SIGN
0B339B CB 7C       0244**          		BIT     7,H
0B339D 08          0245**          		EX      AF,AF'
0B339E CB 7C       0246**          		BIT     7,H
0B33A0 C4 E2 3C 0B 0247**          		CALL    NZ,NEGATE       ;MAKE ARGUMENTS +VE
0B33A4 CD DF 3D 0B 0248**          		CALL    SWAP_FP
0B33A8 CB 7C       0249**          		BIT     7,H
0B33AA C4 E2 3C 0B 0250**          		CALL    NZ,NEGATE
0B33AE 44          0251**          		LD      B,H
0B33AF 4D          0252**          		LD      C,L
0B33B0 21 00 00 00 0253**          		LD      HL,0
0B33B4 D9          0254**          		EXX
0B33B5 44          0255**          		LD      B,H
0B33B6 4D          0256**          		LD      C,L
0B33B7 21 00 00 00 0257**          		LD      HL,0
0B33BB 3E DF       0258**          		LD      A,-33
0B33BD CD 6C 3F 0B 0259**          		CALL    DIVA            ;DIVIDE
0B33C1 D9          0260**          		EXX
0B33C2 0E 00       0261**          		LD      C,0             ;INTEGER MARKER
0B33C4 08          0262**          		EX      AF,AF'
0B33C5 C8          0263**          		RET     Z
0B33C6 C3 E2 3C 0B 0264**          		JP      NEGATE
0B33CA             0265**  ;
0B33CA             0266**  ;BDIV - Integer division.
0B33CA             0267**  ;
0B33CA CD C6 3C 0B 0268**  FBDIV:			CALL    FIX2
0B33CE CD 99 33 0B 0269**  IBDIV:			CALL    IMOD
0B33D2 B7          0270**          		OR      A
0B33D3 CD DF 3D 0B 0271**          		CALL    SWAP_FP
0B33D7 0E 00       0272**          		LD      C,0
0B33D9 F0          0273**          		RET     P
0B33DA C3 E2 3C 0B 0274**          		JP      NEGATE
0B33DE             0275**  ;
0B33DE             0276**  ;ISUB - Integer subtraction.
0B33DE             0277**  ;FSUB - Floating point subtraction with rounding.
0B33DE             0278**  ;
0B33DE CD 7A 3E 0B 0279**  ISUB:			CALL    SUB_
0B33E2 E0          0280**          		RET     PO
0B33E3 CD 72 3E 0B 0281**          		CALL    ADD_
0B33E7 CD A2 3D 0B 0282**          		CALL    FLOAT2
0B33EB 7A          0283**  FSUB:			LD      A,D
0B33EC EE 80       0284**          		XOR     80H             ;CHANGE SIGN THEN ADD
0B33EE 57          0285**          		LD      D,A
0B33EF 18 13       0286**          		JR      FADD
0B33F1             0287**  ;
0B33F1             0288**  ;Reverse subtract.
0B33F1             0289**  ;
0B33F1 7C          0290**  RSUB:			LD      A,H
0B33F2 EE 80       0291**          		XOR     80H
0B33F4 67          0292**          		LD      H,A
0B33F5 18 0D       0293**          		JR      FADD
0B33F7             0294**  ;
0B33F7             0295**  ;IADD - Integer addition.
0B33F7             0296**  ;FADD - Floating point addition with rounding.
0B33F7             0297**  ;
0B33F7 CD 72 3E 0B 0298**  IADD:			CALL    ADD_
0B33FB E0          0299**          		RET     PO
0B33FC CD 7A 3E 0B 0300**          		CALL    SUB_
0B3400 CD A2 3D 0B 0301**          		CALL    FLOAT2
0B3404 05          0302**  FADD:			DEC     B
0B3405 04          0303**          		INC     B
0B3406 C8          0304**          		RET     Z               ;ARG 2 ZERO
0B3407 0D          0305**          		DEC     C
0B3408 0C          0306**          		INC     C
0B3409 CA DF 3D 0B 0307**          		JP      Z,SWAP_FP          ;ARG 1 ZERO
0B340D D9          0308**          		EXX
0B340E 01 00 00 00 0309**          		LD      BC,0            ;INITIALISE
0B3412 D9          0310**          		EXX
0B3413 7C          0311**          		LD      A,H
0B3414 AA          0312**          		XOR     D               ;XOR SIGNS
0B3415 F5          0313**          		PUSH    AF
0B3416 78          0314**          		LD      A,B
0B3417 B9          0315**          		CP      C               ;COMPARE EXPONENTS
0B3418 DC DF 3D 0B 0316**          		CALL    C,SWAP_FP          ;MAKE DED'E'B LARGEST
0B341C 78          0317**          		LD      A,B
0B341D CB FC       0318**          		SET     7,H             ;IMPLIED 1
0B341F C4 B3 3C 0B 0319**          		CALL    NZ,FIX          ;ALIGN
0B3423 F1          0320**          		POP     AF
0B3424 7A          0321**          		LD      A,D             ;SIGN OF LARGER
0B3425 CB FA       0322**          		SET     7,D             ;IMPLIED 1
0B3427 FA 37 34 0B 0323**          		JP      M,FADD3         ;SIGNS DIFFERENT
0B342B CD 72 3E 0B 0324**          		CALL    ADD_             ;HLH'L'=HLH'L'+DED'E'
0B342F DC E7 3D 0B 0325**          		CALL    C,DIV2          ;NORMALISE
0B3433 CB FC       0326**          		SET     7,H
0B3435 18 0D       0327**          		JR      FADD4
0B3437             0328**  ;
0B3437 CD 7A 3E 0B 0329**  FADD3:			CALL    SUB_             ;HLH'L'=HLH'L'-DED'E'
0B343B DC FA 3C 0B 0330**          		CALL    C,NEG_           ;NEGATE HLH'L'B'C'
0B343F CD 79 3D 0B 0331**          		CALL    FLO48
0B3443 2F          0332**          		CPL                     ;CHANGE RESULT SIGN
0B3444 D9          0333**  FADD4:			EXX
0B3445 EB          0334**          		EX      DE,HL
0B3446 21 00 80 00 0335**          		LD      HL,8000H
0B344A B7          0336**          		OR      A               ;CLEAR CARRY
0B344B 52 ED 42    0337**          		SBC.S   HL,BC
0B344E EB          0338**          		EX      DE,HL
0B344F D9          0339**          		EXX
0B3450 CC D9 3D 0B 0340**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B3454 DC C7 3D 0B 0341**          		CALL    C,ADD1          ;ROUND UP
0B3458 DC F4 3D 0B 0342**          		CALL    C,INCC
0B345C CB BC       0343**          		RES     7,H
0B345E 0D          0344**          		DEC     C
0B345F 0C          0345**          		INC     C
0B3460 CA 2B 3E 0B 0346**          		JP      Z,FPZERO
0B3464 B7          0347**          		OR      A               ;RESULT SIGNQ
0B3465 F0          0348**          		RET     P               ;POSITIVE
0B3466 CB FC       0349**          		SET     7,H             ;NEGATIVE
0B3468 C9          0350**          		RET
0B3469             0351**  ;
0B3469             0352**  ;IDIV - Integer division.
0B3469             0353**  ;FDIV - Floating point division with rounding.
0B3469             0354**  ;
0B3469 CD A2 3D 0B 0355**  IDIV:			CALL    FLOAT2
0B346D 05          0356**  FDIV:			DEC     B               ;TEST FOR ZERO
0B346E 04          0357**          		INC     B
0B346F 3E 12       0358**          		LD      A,DIVBY0
0B3471 CA 85 32 0B 0359**          		JP      Z,ERROR_FP         ;"Division by zero"
0B3475 0D          0360**          		DEC     C               ;TEST FOR ZERO
0B3476 0C          0361**          		INC     C
0B3477 C8          0362**          		RET     Z
0B3478 7C          0363**          		LD      A,H
0B3479 AA          0364**          		XOR     D               ;CALC. RESULT SIGN
0B347A 08          0365**          		EX      AF,AF'          ;SAVE SIGN
0B347B CB FA       0366**          		SET     7,D             ;REPLACE IMPLIED 1's
0B347D CB FC       0367**          		SET     7,H
0B347F C5          0368**          		PUSH    BC              ;SAVE EXPONENTS
0B3480 42          0369**          		LD      B,D             ;LOAD REGISTERS
0B3481 4B          0370**          		LD      C,E
0B3482 11 00 00 00 0371**          		LD      DE,0
0B3486 D9          0372**          		EXX
0B3487 42          0373**          		LD      B,D
0B3488 4B          0374**          		LD      C,E
0B3489 11 00 00 00 0375**          		LD      DE,0
0B348D 3E E0       0376**          		LD      A,-32           ;LOOP COUNTER
0B348F CD 6C 3F 0B 0377**          		CALL    DIVA            ;DIVIDE
0B3493 D9          0378**          		EXX
0B3494 CB 7A       0379**          		BIT     7,D
0B3496 D9          0380**          		EXX
0B3497 CC 8B 3F 0B 0381**          		CALL    Z,DIVB          ;NORMALISE & INC A
0B349B EB          0382**          		EX      DE,HL
0B349C D9          0383**          		EXX
0B349D CB 38       0384**          		SRL     B               ;DIVISOR/2
0B349F CB 19       0385**          		RR      C
0B34A1 B7          0386**          		OR      A               ;CLEAR CARRY
0B34A2 52 ED 42    0387**          		SBC.S   HL,BC           ;REMAINDER-DIVISOR/2
0B34A5 3F          0388**          		CCF
0B34A6 EB          0389**          		EX      DE,HL           ;RESULT IN HLH'L'
0B34A7 CC D9 3D 0B 0390**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B34AB DC C7 3D 0B 0391**          		CALL    C,ADD1          ;ROUND UP
0B34AF C1          0392**          		POP     BC              ;RESTORE EXPONENTS
0B34B0 DC F4 3D 0B 0393**          		CALL    C,INCC
0B34B4 1F          0394**          		RRA                     ;LSB OF A TO CARRY
0B34B5 79          0395**          		LD      A,C             ;COMPUTE NEW EXPONENT
0B34B6 98          0396**          		SBC     A,B
0B34B7 3F          0397**          		CCF
0B34B8 C3 59 35 0B 0398**          		JP      CHKOVF
0B34BC             0399**  ;
0B34BC             0400**  ;IMUL - Integer multiplication.
0B34BC             0401**  ;
0B34BC 7C          0402**  IMUL:			LD      A,H
0B34BD AA          0403**          		XOR     D
0B34BE 08          0404**          		EX      AF,AF'          ;SAVE RESULT SIGN
0B34BF CB 7C       0405**          		BIT     7,H
0B34C1 C4 E2 3C 0B 0406**          		CALL    NZ,NEGATE
0B34C5 CD DF 3D 0B 0407**          		CALL    SWAP_FP
0B34C9 CB 7C       0408**          		BIT     7,H
0B34CB C4 E2 3C 0B 0409**          		CALL    NZ,NEGATE
0B34CF 44          0410**          		LD      B,H
0B34D0 4D          0411**          		LD      C,L
0B34D1 21 00 00 00 0412**          		LD      HL,0
0B34D5 D9          0413**          		EXX
0B34D6 44          0414**          		LD      B,H
0B34D7 4D          0415**          		LD      C,L
0B34D8 21 00 00 00 0416**          		LD      HL,0
0B34DC 3E DF       0417**          		LD      A,-33
0B34DE CD A3 3F 0B 0418**          		CALL    MULA            ;MULTIPLY
0B34E2 D9          0419**          		EXX
0B34E3 0E BF       0420**          		LD      C,191           ;PRESET EXPONENT
0B34E5 CD 07 3E 0B 0421**          		CALL    TEST_FP            ;TEST RANGE
0B34E9 20 0F       0422**          		JR      NZ,IMUL1        ;TOO BIG
0B34EB CB 7A       0423**          		BIT     7,D
0B34ED 20 0B       0424**          		JR      NZ,IMUL1
0B34EF CD DF 3D 0B 0425**          		CALL    SWAP_FP
0B34F3 4A          0426**          		LD      C,D             ;INTEGER MARKER
0B34F4 08          0427**          		EX      AF,AF'
0B34F5 F0          0428**          		RET     P
0B34F6 C3 E2 3C 0B 0429**          		JP      NEGATE
0B34FA             0430**  ;
0B34FA 0D          0431**  IMUL1:			DEC     C
0B34FB D9          0432**          		EXX
0B34FC CB 23       0433**          		SLA     E
0B34FE CB 12       0434**          		RL      D
0B3500 D9          0435**          		EXX
0B3501 CB 13       0436**          		RL      E
0B3503 CB 12       0437**          		RL      D
0B3505 D9          0438**          		EXX
0B3506 52 ED 6A    0439**          		ADC.S   HL,HL
0B3509 D9          0440**          		EXX
0B350A 52 ED 6A    0441**          		ADC.S   HL,HL
0B350D F2 FA 34 0B 0442**          		JP      P,IMUL1         ;NORMALISE
0B3511 08          0443**          		EX      AF,AF'
0B3512 F8          0444**          		RET     M
0B3513 CB BC       0445**          		RES     7,H             ;POSITIVE
0B3515 C9          0446**          		RET
0B3516             0447**  ;
0B3516             0448**  ;FMUL - Floating point multiplication with rounding.
0B3516             0449**  ;
0B3516 05          0450**  FMUL:			DEC     B               ;TEST FOR ZERO
0B3517 04          0451**          		INC     B
0B3518 CA 2B 3E 0B 0452**          		JP      Z,FPZERO
0B351C 0D          0453**          		DEC     C               ;TEST FOR ZERO
0B351D 0C          0454**          		INC     C
0B351E C8          0455**          		RET     Z
0B351F 7C          0456**          		LD      A,H
0B3520 AA          0457**          		XOR     D               ;CALC. RESULT SIGN
0B3521 08          0458**          		EX      AF,AF'
0B3522 CB FA       0459**          		SET     7,D             ;REPLACE IMPLIED 1's
0B3524 CB FC       0460**          		SET     7,H
0B3526 C5          0461**          		PUSH    BC              ;SAVE EXPONENTS
0B3527 44          0462**          		LD      B,H             ;LOAD REGISTERS
0B3528 4D          0463**          		LD      C,L
0B3529 21 00 00 00 0464**          		LD      HL,0
0B352D D9          0465**          		EXX
0B352E 44          0466**          		LD      B,H
0B352F 4D          0467**          		LD      C,L
0B3530 21 00 00 00 0468**          		LD      HL,0
0B3534 3E E0       0469**          		LD      A,-32           ;LOOP COUNTER
0B3536 CD A3 3F 0B 0470**          		CALL    MULA            ;MULTIPLY
0B353A DC B9 3F 0B 0471**          		CALL    C,MULB          ;NORMALISE & INC A
0B353E D9          0472**          		EXX
0B353F E5          0473**          		PUSH    HL
0B3540 21 00 80 00 0474**          		LD      HL,8000H
0B3544 B7          0475**          		OR      A               ;CLEAR CARRY
0B3545 52 ED 52    0476**          		SBC.S   HL,DE
0B3548 E1          0477**          		POP     HL
0B3549 CC D9 3D 0B 0478**          		CALL    Z,ODD           ;ROUND UNBIASSED
0B354D DC C7 3D 0B 0479**          		CALL    C,ADD1          ;ROUND UP
0B3551 C1          0480**          		POP     BC              ;RESTORE EXPONENTS
0B3552 DC F4 3D 0B 0481**          		CALL    C,INCC
0B3556 1F          0482**          		RRA                     ;LSB OF A TO CARRY
0B3557 79          0483**          		LD      A,C             ;COMPUTE NEW EXPONENT
0B3558 88          0484**          		ADC     A,B
0B3559 38 06       0485**  CHKOVF:			JR      C,CHKO1
0B355B F2 2B 3E 0B 0486**          		JP      P,FPZERO          ;UNDERFLOW
0B355F 18 04       0487**          		JR      CHKO2
0B3561 FA F6 3D 0B 0488**  CHKO1:			JP      M,OFLOW         ;OVERFLOW
0B3565 C6 80       0489**  CHKO2:			ADD     A,80H
0B3567 4F          0490**          		LD      C,A
0B3568 CA 2B 3E 0B 0491**          		JP      Z,FPZERO
0B356C 08          0492**          		EX      AF,AF'          ;RESTORE SIGN BIT
0B356D CB BC       0493**          		RES     7,H
0B356F F0          0494**          		RET     P
0B3570 CB FC       0495**          		SET     7,H
0B3572 C9          0496**          		RET
0B3573             0497**  ;
0B3573             0498**  ;IPOW - Integer involution.
0B3573             0499**  ;
0B3573 CD DF 3D 0B 0500**  IPOW:			CALL    SWAP_FP
0B3577 CB 7C       0501**          		BIT     7,H
0B3579 F5          0502**          		PUSH    AF              ;SAVE SIGN
0B357A C4 E2 3C 0B 0503**          		CALL    NZ,NEGATE
0B357E 48          0504**  IPOW0:			LD      C,B
0B357F 06 20       0505**          		LD      B,32            ;LOOP COUNTER
0B3581 CD 97 3E 0B 0506**  IPOW1:			CALL    X2
0B3585 38 08       0507**          		JR      C,IPOW2
0B3587 10 F8       0508**          		DJNZ    IPOW1
0B3589 F1          0509**          		POP     AF
0B358A D9          0510**          		EXX
0B358B 2C          0511**          		INC     L               ;RESULT=1
0B358C D9          0512**          		EXX
0B358D 4C          0513**          		LD      C,H
0B358E C9          0514**          		RET
0B358F             0515**  ;
0B358F F1          0516**  IPOW2:			POP     AF
0B3590 C5          0517**          		PUSH    BC
0B3591 EB          0518**          		EX      DE,HL
0B3592 E5          0519**          		PUSH    HL
0B3593 D9          0520**          		EXX
0B3594 EB          0521**          		EX      DE,HL
0B3595 E5          0522**          		PUSH    HL
0B3596 D9          0523**          		EXX
0B3597 DD 21 00 00 0524**          		LD      IX,0
       00          
0B359C DD 39       0525**          		ADD     IX,SP
0B359E 28 48       0526**          		JR      Z,IPOW4
0B35A0 C5          0527**          		PUSH    BC
0B35A1 D9          0528**          		EXX
0B35A2 D5          0529**          		PUSH    DE
0B35A3 D9          0530**          		EXX
0B35A4 D5          0531**          		PUSH    DE
0B35A5 CD AE 3D 0B 0532**          		CALL    SFLOAT
0B35A9 CD E2 38 0B 0533**          		CALL    RECIP
0B35AD DD 71 04    0534**          		LD      (IX+4),C
0B35B0 D9          0535**          		EXX
0B35B1 DD 75 00    0536**          		LD      (IX+0),L
0B35B4 DD 74 01    0537**          		LD      (IX+1),H
0B35B7 D9          0538**          		EXX
0B35B8 DD 75 02    0539**          		LD      (IX+2),L
0B35BB DD 74 03    0540**          		LD      (IX+3),H
0B35BE 18 21       0541**          		JR      IPOW5
0B35C0             0542**  ;
0B35C0 C5          0543**  IPOW3:			PUSH    BC
0B35C1 D9          0544**          		EXX
0B35C2 CB 23       0545**          		SLA     E
0B35C4 CB 12       0546**          		RL      D
0B35C6 D5          0547**          		PUSH    DE
0B35C7 D9          0548**          		EXX
0B35C8 CB 13       0549**          		RL      E
0B35CA CB 12       0550**          		RL      D
0B35CC D5          0551**          		PUSH    DE
0B35CD 3E 0A       0552**          		LD      A,'*' & 0FH
0B35CF F5          0553**          		PUSH    AF
0B35D0 CD AB 3E 0B 0554**          		CALL    COPY_
0B35D4 CD 8B 32 0B 0555**          		CALL    OP              ;SQUARE
0B35D8 F1          0556**          		POP     AF
0B35D9 CD D7 3B 0B 0557**          		CALL    DLOAD5
0B35DD DC 8B 32 0B 0558**          		CALL    C,OP            ;MULTIPLY BY X
0B35E1 D1          0559**  IPOW5:			POP     DE
0B35E2 D9          0560**          		EXX
0B35E3 D1          0561**          		POP     DE
0B35E4 D9          0562**          		EXX
0B35E5 79          0563**          		LD      A,C
0B35E6 C1          0564**          		POP     BC
0B35E7 4F          0565**          		LD      C,A
0B35E8 10 D6       0566**  IPOW4:			DJNZ    IPOW3
0B35EA F1          0567**          		POP     AF
0B35EB F1          0568**          		POP     AF
0B35EC F1          0569**          		POP     AF
0B35ED C9          0570**          		RET
0B35EE             0571**  ;
0B35EE F1          0572**  FPOW0:			POP     AF
0B35EF F1          0573**          		POP     AF
0B35F0 F1          0574**          		POP     AF
0B35F1 18 8B       0575**          		JR      IPOW0
0B35F3             0576**  ;
0B35F3             0577**  ;FPOW - Floating-point involution.
0B35F3             0578**  ;
0B35F3 CB 7A       0579**  FPOW:			BIT     7,D
0B35F5 F5          0580**          		PUSH    AF
0B35F6 CD DF 3D 0B 0581**          		CALL    SWAP_FP
0B35FA CD BB 3E 0B 0582**          		CALL    PUSH5
0B35FE 0D          0583**          		DEC     C
0B35FF 0C          0584**          		INC     C
0B3600 28 EC       0585**          		JR      Z,FPOW0
0B3602 3E 9E       0586**          		LD      A,158
0B3604 B9          0587**          		CP      C
0B3605 38 0A       0588**          		JR      C,FPOW1
0B3607 3C          0589**          		INC     A
0B3608 CD B3 3C 0B 0590**          		CALL    FIX
0B360C 08          0591**          		EX      AF,AF'
0B360D F2 EE 35 0B 0592**          		JP      P,FPOW0
0B3611 CD DF 3D 0B 0593**  FPOW1:			CALL    SWAP_FP
0B3615 CD FF 38 0B 0594**          		CALL    LN0
0B3619 CD C4 3E 0B 0595**          		CALL    POP5
0B361D F1          0596**          		POP     AF
0B361E CD 16 35 0B 0597**          		CALL    FMUL
0B3622 C3 61 38 0B 0598**          		JP      EXP0
0B3626             0599**  ;
0B3626             0600**  ;Integer and floating-point compare.
0B3626             0601**  ;Result is TRUE (-1) or FALSE (0).
0B3626             0602**  ;
0B3626 CD 35 3E 0B 0603**  FLT:			CALL    FCP
0B362A 18 04       0604**          		JR      ILT1
0B362C CD 27 3E 0B 0605**  ILT:			CALL    ICP
0B3630 D0          0606**  ILT1:			RET     NC
0B3631 18 42       0607**          		JR      TRUE
0B3633             0608**  ;
0B3633 CD 35 3E 0B 0609**  FGT:			CALL    FCP
0B3637 18 04       0610**          		JR      IGT1
0B3639 CD 27 3E 0B 0611**  IGT:			CALL    ICP
0B363D C8          0612**  IGT1:			RET     Z
0B363E D8          0613**          		RET     C
0B363F 18 34       0614**          		JR      TRUE
0B3641             0615**  ;
0B3641 CD 35 3E 0B 0616**  FGE:			CALL    FCP
0B3645 18 04       0617**          		JR      IGE1
0B3647 CD 27 3E 0B 0618**  IGE:			CALL    ICP
0B364B D8          0619**  IGE1:			RET     C
0B364C 18 27       0620**          		JR      TRUE
0B364E             0621**  ;
0B364E CD 35 3E 0B 0622**  FLE:			CALL    FCP
0B3652 18 04       0623**          		JR      ILE1
0B3654 CD 27 3E 0B 0624**  ILE:			CALL    ICP
0B3658 28 1B       0625**  ILE1:			JR      Z,TRUE
0B365A D0          0626**          		RET     NC
0B365B 18 18       0627**          		JR      TRUE
0B365D             0628**  ;
0B365D CD 35 3E 0B 0629**  FNE:			CALL    FCP
0B3661 18 04       0630**          		JR      INE1
0B3663 CD 27 3E 0B 0631**  INE:			CALL    ICP
0B3667 C8          0632**  INE1:			RET     Z
0B3668 18 0B       0633**          		JR      TRUE
0B366A             0634**  ;
0B366A CD 35 3E 0B 0635**  FEQ:			CALL    FCP
0B366E 18 04       0636**          		JR      IEQ1
0B3670 CD 27 3E 0B 0637**  IEQ:			CALL    ICP
0B3674 C0          0638**  IEQ1:			RET     NZ
0B3675 21 FF FF FF 0639**  TRUE:			LD      HL,-1
0B3679 D9          0640**          		EXX
0B367A 21 FF FF FF 0641**          		LD      HL,-1
0B367E D9          0642**          		EXX
0B367F AF          0643**          		XOR     A
0B3680 4F          0644**          		LD      C,A
0B3681 C9          0645**          		RET
0B3682             0646**  ;
0B3682             0647**  ;FUNCTIONS:
0B3682             0648**  ;
0B3682             0649**  ;Result returned in HLH'L'C (floating point)
0B3682             0650**  ;Result returned in HLH'L' (C=0) (integer)
0B3682             0651**  ;All registers except IY destroyed.
0B3682             0652**  ;
0B3682             0653**  ;ABS - Absolute value
0B3682             0654**  ;Result is numeric, variable type.
0B3682             0655**  ;
0B3682 CB 7C       0656**  ABSV:			BIT     7,H
0B3684 C8          0657**          		RET     Z               ;POSITIVE/ZERO
0B3685 0D          0658**          		DEC     C
0B3686 0C          0659**          		INC     C
0B3687 CA E2 3C 0B 0660**          		JP      Z,NEGATE        ;INTEGER
0B368B CB BC       0661**          		RES     7,H
0B368D C9          0662**          		RET
0B368E             0663**  ;
0B368E             0664**  ;NOT - Complement integer.
0B368E             0665**  ;Result is integer numeric.
0B368E             0666**  ;
0B368E CD D2 3C 0B 0667**  NOTK:			CALL    SFIX_FP
0B3692 7C          0668**          		LD      A,H
0B3693 2F          0669**          		CPL
0B3694 67          0670**          		LD      H,A
0B3695 7D          0671**          		LD      A,L
0B3696 2F          0672**          		CPL
0B3697 6F          0673**          		LD      L,A
0B3698 D9          0674**          		EXX
0B3699 7C          0675**          		LD      A,H
0B369A 2F          0676**          		CPL
0B369B 67          0677**          		LD      H,A
0B369C 7D          0678**          		LD      A,L
0B369D 2F          0679**          		CPL
0B369E 6F          0680**          		LD      L,A
0B369F D9          0681**          		EXX
0B36A0 AF          0682**          		XOR     A               ;NUMERIC MARKER
0B36A1 C9          0683**          		RET
0B36A2             0684**  ;
0B36A2             0685**  ;PI - Return PI (3.141592654)
0B36A2             0686**  ;Result is floating-point numeric.
0B36A2             0687**  ;
0B36A2 21 0F 49 00 0688**  PI:			LD      HL,490FH
0B36A6 D9          0689**          		EXX
0B36A7 21 A2 DA 00 0690**          		LD      HL,0DAA2H
0B36AB D9          0691**          		EXX
0B36AC 0E 81       0692**          		LD      C,81H
0B36AE AF          0693**          		XOR     A               ;NUMERIC MARKER
0B36AF C9          0694**          		RET
0B36B0             0695**  ;
0B36B0             0696**  ;DEG - Convert radians to degrees
0B36B0             0697**  ;Result is floating-point numeric.
0B36B0             0698**  ;
0B36B0 CD C4 36 0B 0699**  DEG:			CALL    FPI180
0B36B4 CD 16 35 0B 0700**          		CALL    FMUL
0B36B8 AF          0701**          		XOR     A
0B36B9 C9          0702**          		RET
0B36BA             0703**  ;
0B36BA             0704**  ;RAD - Convert degrees to radians
0B36BA             0705**  ;Result is floating-point numeric.
0B36BA             0706**  ;
0B36BA CD C4 36 0B 0707**  RAD:			CALL    FPI180
0B36BE CD 6D 34 0B 0708**          		CALL    FDIV
0B36C2 AF          0709**          		XOR     A
0B36C3 C9          0710**          		RET
0B36C4             0711**  ;
0B36C4             0712**  ;180/PI
0B36C4             0713**  ;
0B36C4 CD AE 3D 0B 0714**  FPI180:			CALL    SFLOAT
0B36C8 11 2E 65 00 0715**          		LD      DE,652EH
0B36CC D9          0716**          		EXX
0B36CD 11 D3 E0 00 0717**          		LD      DE,0E0D3H
0B36D1 D9          0718**          		EXX
0B36D2 06 85       0719**          		LD      B,85H
0B36D4 C9          0720**          		RET
0B36D5             0721**  ;
0B36D5             0722**  ;SGN - Return -1, 0 or +1
0B36D5             0723**  ;Result is integer numeric.
0B36D5             0724**  ;
0B36D5 CD 07 3E 0B 0725**  SGN:			CALL    TEST_FP
0B36D9 B1          0726**          		OR      C
0B36DA C8          0727**          		RET     Z               ;ZERO
0B36DB CB 7C       0728**          		BIT     7,H
0B36DD C2 75 36 0B 0729**          		JP      NZ,TRUE         ;-1
0B36E1 CD 2B 3E 0B 0730**          		CALL    FPZERO
0B36E5 C3 C7 3D 0B 0731**          		JP      ADD1            ;1
0B36E9             0732**  ;
0B36E9             0733**  ;VAL - Return numeric value of string.
0B36E9             0734**  ;Input: ASCII string at IX
0B36E9             0735**  ;Result is variable type numeric.
0B36E9             0736**  ;
0B36E9 CD 45 40 0B 0737**  VAL:			CALL    SIGNQ
0B36ED F5          0738**          		PUSH    AF
0B36EE CD F5 3B 0B 0739**          		CALL    CON
0B36F2 F1          0740**          		POP     AF
0B36F3 FE 2D       0741**          		CP      '-'
0B36F5 3E 00       0742**          		LD      A,0             ;NUMERIC MARKER
0B36F7 C0          0743**          		RET     NZ
0B36F8 0D          0744**          		DEC     C
0B36F9 0C          0745**          		INC     C
0B36FA CA E2 3C 0B 0746**          		JP      Z,NEGATE        ;ZERO/INTEGER
0B36FE 7C          0747**          		LD      A,H
0B36FF EE 80       0748**          		XOR     80H             ;CHANGE SIGN (FP)
0B3701 67          0749**          		LD      H,A
0B3702 AF          0750**          		XOR     A
0B3703 C9          0751**          		RET
0B3704             0752**  ;
0B3704             0753**  ;INT - Floor function
0B3704             0754**  ;Result is integer numeric.
0B3704             0755**  ;
0B3704 0D          0756**  INT_:			DEC     C
0B3705 0C          0757**          		INC     C
0B3706 C8          0758**          		RET     Z               ;ZERO/INTEGER
0B3707 3E 9F       0759**          		LD      A,159
0B3709 44          0760**          		LD      B,H             ;B7=SIGN BIT
0B370A CD B3 3C 0B 0761**          		CALL    FIX
0B370E 08          0762**          		EX      AF,AF'
0B370F A0          0763**          		AND     B
0B3710 FC C7 3D 0B 0764**          		CALL    M,ADD1          ;NEGATIVE NON-INTEGER
0B3714 78          0765**          		LD      A,B
0B3715 B7          0766**          		OR      A
0B3716 FC E2 3C 0B 0767**          		CALL    M,NEGATE
0B371A AF          0768**          		XOR     A
0B371B 4F          0769**          		LD      C,A
0B371C C9          0770**          		RET
0B371D             0771**  ;
0B371D             0772**  ;SQR - square root
0B371D             0773**  ;Result is floating-point numeric.
0B371D             0774**  ;
0B371D CD AE 3D 0B 0775**  SQR:			CALL    SFLOAT
0B3721 CB 7C       0776**  SQR0:			BIT     7,H
0B3723 3E 15       0777**          		LD      A,NGROOT
0B3725 C2 85 32 0B 0778**          		JP      NZ,ERROR_FP        ;"-ve root"
0B3729 0D          0779**          		DEC     C
0B372A 0C          0780**          		INC     C
0B372B C8          0781**          		RET     Z               ;ZERO
0B372C CB FC       0782**          		SET     7,H             ;IMPLIED 1
0B372E CB 41       0783**          		BIT     0,C
0B3730 CC E7 3D 0B 0784**          		CALL    Z,DIV2          ;MAKE EXPONENT ODD
0B3734 79          0785**          		LD      A,C
0B3735 D6 80       0786**          		SUB     80H
0B3737 CB 2F       0787**          		SRA     A               ;HALVE EXPONENT
0B3739 C6 80       0788**          		ADD     A,80H
0B373B 4F          0789**          		LD      C,A
0B373C C5          0790**          		PUSH    BC              ;SAVE EXPONENT
0B373D EB          0791**          		EX      DE,HL
0B373E 21 00 00 00 0792**          		LD      HL,0
0B3742 44          0793**          		LD      B,H
0B3743 4D          0794**          		LD      C,L
0B3744 D9          0795**          		EXX
0B3745 EB          0796**          		EX      DE,HL
0B3746 21 00 00 00 0797**          		LD      HL,0
0B374A 44          0798**          		LD      B,H
0B374B 4D          0799**          		LD      C,L
0B374C 3E E1       0800**          		LD      A,-31
0B374E CD DD 3F 0B 0801**          		CALL    SQRA            ;ROOT
0B3752 D9          0802**          		EXX
0B3753 CB 78       0803**          		BIT     7,B
0B3755 D9          0804**          		EXX
0B3756 CC DD 3F 0B 0805**          		CALL    Z,SQRA          ;NORMALISE & INC A
0B375A CD 1E 40 0B 0806**          		CALL    SQRB
0B375E B7          0807**          		OR      A               ;CLEAR CARRY
0B375F CD 8B 3F 0B 0808**          		CALL    DIVB
0B3763 CB 1B       0809**          		RR      E               ;LSB TO CARRY
0B3765 60          0810**          		LD      H,B
0B3766 69          0811**          		LD      L,C
0B3767 D9          0812**          		EXX
0B3768 60          0813**          		LD      H,B
0B3769 69          0814**          		LD      L,C
0B376A DC C7 3D 0B 0815**          		CALL    C,ADD1          ;ROUND UP
0B376E C1          0816**          		POP     BC              ;RESTORE EXPONENT
0B376F DC F4 3D 0B 0817**          		CALL    C,INCC
0B3773 1F          0818**          		RRA
0B3774 9F          0819**          		SBC     A,A
0B3775 81          0820**          		ADD     A,C
0B3776 4F          0821**          		LD      C,A
0B3777 CB BC       0822**          		RES     7,H             ;POSITIVE
0B3779 AF          0823**          		XOR     A
0B377A C9          0824**          		RET
0B377B             0825**  ;
0B377B             0826**  ;TAN - Tangent function
0B377B             0827**  ;Result is floating-point numeric.
0B377B             0828**  ;
0B377B CD AE 3D 0B 0829**  TAN:			CALL    SFLOAT
0B377F CD BB 3E 0B 0830**          		CALL    PUSH5
0B3783 CD A5 37 0B 0831**          		CALL    COS0
0B3787 CD C4 3E 0B 0832**          		CALL    POP5
0B378B CD BB 3E 0B 0833**          		CALL    PUSH5
0B378F CD DF 3D 0B 0834**          		CALL    SWAP_FP
0B3793 CD B2 37 0B 0835**          		CALL    SIN0
0B3797 CD C4 3E 0B 0836**          		CALL    POP5
0B379B CD 6D 34 0B 0837**          		CALL    FDIV
0B379F AF          0838**          		XOR     A               ;NUMERIC MARKER
0B37A0 C9          0839**          		RET
0B37A1             0840**  ;
0B37A1             0841**  ;COS - Cosine function
0B37A1             0842**  ;Result is floating-point numeric.
0B37A1             0843**  ;
0B37A1 CD AE 3D 0B 0844**  COS:			CALL    SFLOAT
0B37A5 CD 0A 3D 0B 0845**  COS0:			CALL    SCALE
0B37A9 1C          0846**          		INC     E
0B37AA 1C          0847**          		INC     E
0B37AB 7B          0848**          		LD      A,E
0B37AC 18 10       0849**          		JR      SIN1
0B37AE             0850**  ;
0B37AE             0851**  ;SIN - Sine function
0B37AE             0852**  ;Result is floating-point numeric.
0B37AE             0853**  ;
0B37AE CD AE 3D 0B 0854**  SIN:			CALL    SFLOAT
0B37B2 E5          0855**  SIN0:			PUSH    HL              ;H7=SIGN
0B37B3 CD 0A 3D 0B 0856**          		CALL    SCALE
0B37B7 F1          0857**          		POP     AF
0B37B8 07          0858**          		RLCA
0B37B9 07          0859**          		RLCA
0B37BA 07          0860**          		RLCA
0B37BB E6 04       0861**          		AND     4
0B37BD AB          0862**          		XOR     E
0B37BE F5          0863**  SIN1:			PUSH    AF              ;OCTANT
0B37BF CB BC       0864**          		RES     7,H
0B37C1 1F          0865**          		RRA
0B37C2 CD 50 38 0B 0866**          		CALL    PIBY4
0B37C6 DC F1 33 0B 0867**          		CALL    C,RSUB          ;X=(PI/4)-X
0B37CA F1          0868**          		POP     AF
0B37CB F5          0869**          		PUSH    AF
0B37CC E6 03       0870**          		AND     3
0B37CE E2 07 38 0B 0871**          		JP      PO,SIN2         ;USE COSINE APPROX.
0B37D2 CD BB 3E 0B 0872**          		CALL    PUSH5           ;SAVE X
0B37D6 CD B3 3E 0B 0873**          		CALL    SQUARE          ;PUSH X*X
0B37DA CD F8 3E 0B 0874**          		CALL    POLY
0B37DE B7 A8       0875**          		DW	0A8B7H          ;a(8)
0B37E0 11 36       0876**          		DW	3611H
0B37E2 6D          0877**          		DB	6DH
0B37E3 26 DE       0878**          		DW	0DE26H          ;a(6)
0B37E5 05 D0       0879**          		DW	0D005H
0B37E7 73          0880**          		DB	73H
0B37E8 C0 80       0881**          		DW	80C0H           ;a(4)
0B37EA 88 08       0882**          		DW	888H
0B37EC 79          0883**          		DB	79H
0B37ED 9D AA       0884**          		DW	0AA9DH          ;a(2)
0B37EF AA AA       0885**          		DW	0AAAAH
0B37F1 7D          0886**          		DB	7DH
0B37F2 00 00       0887**          		DW	0               ;a(0)
0B37F4 00 00       0888**          		DW	0
0B37F6 80          0889**          		DB	80H
0B37F7 CD C4 3E 0B 0890**          		CALL    POP5
0B37FB CD C4 3E 0B 0891**          		CALL    POP5
0B37FF CD 16 35 0B 0892**          		CALL    FMUL
0B3803 C3 2C 38 0B 0893**          		JP      SIN3
0B3807             0894**  ;
0B3807 CD B3 3E 0B 0895**  SIN2:			CALL    SQUARE          ;PUSH X*X
0B380B CD F8 3E 0B 0896**          		CALL    POLY
0B380F 71 D5       0897**          		DW	0D571H          ;b(8)
0B3811 78 4C       0898**          		DW	4C78H
0B3813 70          0899**          		DB	70H
0B3814 AF 94       0900**          		DW	94AFH           ;b(6)
0B3816 03 B6       0901**          		DW	0B603H
0B3818 76          0902**          		DB	76H
0B3819 C8 9C       0903**          		DW	9CC8H           ;b(4)
0B381B AA 2A       0904**          		DW	2AAAH
0B381D 7B          0905**          		DB	7BH
0B381E DD FF       0906**          		DW	0FFDDH          ;b(2)
0B3820 FF FF       0907**          		DW	0FFFFH
0B3822 7E          0908**          		DB	7EH
0B3823 00 00       0909**          		DW	0               ;b(0)
0B3825 00 00       0910**          		DW	0
0B3827 80          0911**          		DB	80H
0B3828 CD C4 3E 0B 0912**          		CALL    POP5
0B382C F1          0913**  SIN3:			POP     AF
0B382D E6 04       0914**          		AND     4
0B382F C8          0915**          		RET     Z
0B3830 0D          0916**          		DEC     C
0B3831 0C          0917**          		INC     C
0B3832 C8          0918**          		RET     Z               ;ZERO
0B3833 CB FC       0919**          		SET     7,H             ;MAKE NEGATIVE
0B3835 C9          0920**          		RET
0B3836             0921**  ;
0B3836             0922**  ;Floating-point one:
0B3836             0923**  ;
0B3836 21 00 00 00 0924**  FONE:			LD      HL,0
0B383A D9          0925**          		EXX
0B383B 21 00 00 00 0926**          		LD      HL,0
0B383F D9          0927**          		EXX
0B3840 0E 80       0928**          		LD      C,80H
0B3842 C9          0929**          		RET
0B3843             0930**  ;
0B3843 11 00 00 00 0931**  DONE:			LD      DE,0
0B3847 D9          0932**          		EXX
0B3848 11 00 00 00 0933**          		LD      DE,0
0B384C D9          0934**          		EXX
0B384D 06 80       0935**          		LD      B,80H
0B384F C9          0936**          		RET
0B3850             0937**  ;
0B3850 11 0F 49 00 0938**  PIBY4:			LD      DE,490FH
0B3854 D9          0939**          		EXX
0B3855 11 A2 DA 00 0940**          		LD      DE,0DAA2H
0B3859 D9          0941**          		EXX
0B385A 06 7F       0942**          		LD      B,7FH
0B385C C9          0943**          		RET
0B385D             0944**  ;
0B385D             0945**  ;EXP - Exponential function
0B385D             0946**  ;Result is floating-point numeric.
0B385D             0947**  ;
0B385D CD AE 3D 0B 0948**  EXP:			CALL    SFLOAT
0B3861 CD EE 38 0B 0949**  EXP0:			CALL    LN2             ;LN(2)
0B3865 D9          0950**          		EXX
0B3866 1D          0951**  	        	DEC     E
0B3867 01 CF D1 00 0952**  		        LD      BC,0D1CFH       ;0.6931471805599453
0B386B D9          0953**          		EXX
0B386C E5          0954**          		PUSH    HL              ;H7=SIGN
0B386D CD 1D 3D 0B 0955**          		CALL    MOD48           ;"MODULUS"
0B3871 F1          0956**          		POP     AF
0B3872 CB 7B       0957**          		BIT     7,E
0B3874 28 0B       0958**          		JR      Z,EXP1
0B3876 17          0959**          		RLA
0B3877 DA 2B 3E 0B 0960**          		JP      C,FPZERO
0B387B 3E 18       0961**          		LD      A,EXPRNG
0B387D C3 85 32 0B 0962**          		JP      ERROR_FP           ;"Exp range"
0B3881             0963**  ;
0B3881 E6 80       0964**  EXP1:			AND     80H
0B3883 B3          0965**          		OR      E
0B3884 F5          0966**          		PUSH    AF              ;INTEGER PART
0B3885 CB BC       0967**          		RES     7,H
0B3887 CD BB 3E 0B 0968**          		CALL    PUSH5           ;PUSH X*LN(2)
0B388B CD F8 3E 0B 0969**          		CALL    POLY
0B388F 72 40       0970**          		DW	4072H           ;a(7)
0B3891 2E 94       0971**          		DW	942EH
0B3893 73          0972**          		DB	73H
0B3894 65 6F       0973**          		DW	6F65H           ;a(6)
0B3896 4F 2E       0974**          		DW	2E4FH
0B3898 76          0975**          		DB	76H
0B3899 37 6D       0976**          		DW	6D37H           ;a(5)
0B389B 02 88       0977**          		DW	8802H
0B389D 79          0978**          		DB	79H
0B389E 12 E5       0979**          		DW	0E512H          ;a(4)
0B38A0 A0 2A       0980**          		DW	2AA0H
0B38A2 7B          0981**          		DB	7BH
0B38A3 14 4F       0982**          		DW	4F14H           ;a(3)
0B38A5 AA AA       0983**          		DW	0AAAAH
0B38A7 7D          0984**          		DB	7DH
0B38A8 56 FD       0985**          		DW	0FD56H          ;a(2)
0B38AA FF 7F       0986**          		DW	7FFFH
0B38AC 7E          0987**          		DB	7EH
0B38AD FE FF       0988**          		DW	0FFFEH          ;a(1)
0B38AF FF FF       0989**          		DW	0FFFFH
0B38B1 7F          0990**          		DB	7FH
0B38B2 00 00       0991**          		DW	0               ;a(0)
0B38B4 00 00       0992**          		DW	0
0B38B6 80          0993**          		DB	80H
0B38B7 CD C4 3E 0B 0994**          		CALL    POP5
0B38BB F1          0995**          		POP     AF
0B38BC F5          0996**          		PUSH    AF
0B38BD F4 E2 38 0B 0997**          		CALL    P,RECIP         ;X=1/X
0B38C1 F1          0998**          		POP     AF
0B38C2 F2 CA 38 0B 0999**          		JP      P,EXP4
0B38C6 E6 7F       1000**          		AND     7FH
0B38C8 ED 44       1001**          		NEG
0B38CA C6 80       1002**  EXP4:			ADD     A,80H
0B38CC 81          1003**          		ADD     A,C
0B38CD 38 06       1004**          		JR      C,EXP2
0B38CF F2 2B 3E 0B 1005**          		JP      P,FPZERO          ;UNDERFLOW
0B38D3 18 04       1006**          		JR      EXP3
0B38D5 FA F6 3D 0B 1007**  EXP2:			JP      M,OFLOW         ;OVERFLOW
0B38D9 C6 80       1008**  EXP3:			ADD     A,80H
0B38DB CA 2B 3E 0B 1009**          		JP      Z,FPZERO
0B38DF 4F          1010**          		LD      C,A
0B38E0 AF          1011**          		XOR     A               ;NUMERIC MARKER
0B38E1 C9          1012**          		RET
0B38E2             1013**  ;
0B38E2 CD 43 38 0B 1014**  RECIP:			CALL    DONE
0B38E6 CD DF 3D 0B 1015**  RDIV:			CALL    SWAP_FP
0B38EA C3 6D 34 0B 1016**          		JP      FDIV            ;RECIPROCAL
0B38EE             1017**  ;
0B38EE 11 72 31 00 1018**  LN2:			LD      DE,3172H        ;LN(2)
0B38F2 D9          1019**          		EXX
0B38F3 11 F8 17 00 1020**          		LD      DE,17F8H
0B38F7 D9          1021**          		EXX
0B38F8 06 7F       1022**          		LD      B,7FH
0B38FA C9          1023**          		RET
0B38FB             1024**  ;
0B38FB             1025**  ;LN - Natural log.
0B38FB             1026**  ;Result is floating-point numeric.
0B38FB             1027**  ;
0B38FB CD AE 3D 0B 1028**  LN:			CALL    SFLOAT
0B38FF 3E 16       1029**  LN0:			LD      A,LOGRNG
0B3901 CB 7C       1030**          		BIT     7,H
0B3903 C2 85 32 0B 1031**          		JP      NZ,ERROR_FP        ;"Log range"
0B3907 0C          1032**          		INC     C
0B3908 0D          1033**          		DEC     C
0B3909 CA 85 32 0B 1034**          		JP      Z,ERROR_FP
0B390D 11 04 35 00 1035**          		LD      DE,3504H        ;SQR(2)
0B3911 D9          1036**          		EXX
0B3912 11 33 F3 00 1037**          		LD      DE,0F333H       ;1.41421356237
0B3916 D9          1038**          		EXX
0B3917 CD 3E 3E 0B 1039**          		CALL    ICP0            ;MANTISSA>SQR(2)?
0B391B 79          1040**          		LD      A,C             ;EXPONENT
0B391C 0E 80       1041**          		LD      C,80H           ;1 <= X < 2
0B391E 38 02       1042**          		JR      C,LN4
0B3920 0D          1043**          		DEC     C
0B3921 3C          1044**          		INC     A
0B3922 F5          1045**  LN4:			PUSH    AF              ;SAVE EXPONENT
0B3923 CD D0 3E 0B 1046**          		CALL    RATIO           ;X=(X-1)/(X+1)
0B3927 CD BB 3E 0B 1047**          		CALL    PUSH5
0B392B CD B3 3E 0B 1048**  		        CALL    SQUARE          ;PUSH X*X
0B392F CD F8 3E 0B 1049**          		CALL    POLY
0B3933 48 CC       1050**          		DW	0CC48H          ;a(9)
0B3935 FB 74       1051**          		DW	74FBH
0B3937 7D          1052**          		DB	7DH
0B3938 AF AE       1053**          		DW	0AEAFH          ;a(7)
0B393A FF 11       1054**          		DW	11FFH
0B393C 7E          1055**          		DB	7EH
0B393D 8C D9       1056**          		DW	0D98CH          ;a(5)
0B393F CD 4C       1057**          		DW	4CCDH
0B3941 7E          1058**          		DB	7EH
0B3942 E3 A9       1059**          		DW	0A9E3H          ;a(3)
0B3944 AA 2A       1060**          		DW	2AAAH
0B3946 7F          1061**          		DB	7FH
0B3947 00 00       1062**          		DW	0               ;a(1)
0B3949 00 00       1063**          		DW	0
0B394B 81          1064**          		DB	81H
0B394C CD C4 3E 0B 1065**          		CALL    POP5
0B3950 CD C4 3E 0B 1066**          		CALL    POP5
0B3954 CD 16 35 0B 1067**          		CALL    FMUL
0B3958 F1          1068**          		POP     AF              ;EXPONENT
0B3959 CD BB 3E 0B 1069**          		CALL    PUSH5
0B395D 08          1070**          		EX      AF,AF'
0B395E CD 2B 3E 0B 1071**          		CALL    FPZERO
0B3962 08          1072**          		EX      AF,AF'
0B3963 D6 80       1073**          		SUB     80H
0B3965 28 1F       1074**          		JR      Z,LN3
0B3967 30 02       1075**          		JR      NC,LN1
0B3969 2F          1076**          		CPL
0B396A 3C          1077**          		INC     A
0B396B 67          1078**  LN1:			LD      H,A
0B396C 0E 87       1079**          		LD      C,87H
0B396E F5          1080**          		PUSH    AF
0B396F CD 8E 3D 0B 1081**          		CALL    FLOAT_
0B3973 CB BC       1082**          		RES     7,H
0B3975 CD EE 38 0B 1083**          		CALL    LN2
0B3979 CD 16 35 0B 1084**          		CALL    FMUL
0B397D F1          1085**          		POP     AF
0B397E 30 06       1086**          		JR      NC,LN3
0B3980 FA 86 39 0B 1087**          		JP      M,LN3
0B3984 CB FC       1088**          		SET     7,H
0B3986 CD C4 3E 0B 1089**  LN3:			CALL    POP5
0B398A CD 04 34 0B 1090**          		CALL    FADD
0B398E AF          1091**          		XOR     A
0B398F C9          1092**          		RET
0B3990             1093**  ;
0B3990             1094**  ;LOG - base-10 logarithm.
0B3990             1095**  ;Result is floating-point numeric.
0B3990             1096**  ;
0B3990 CD FB 38 0B 1097**  LOG:			CALL    LN
0B3994 11 5B 5E 00 1098**          		LD      DE,5E5BH        ;LOG(e)
0B3998 D9          1099**          		EXX
0B3999 11 A9 D8 00 1100**          		LD      DE,0D8A9H
0B399D D9          1101**          		EXX
0B399E 06 7E       1102**          		LD      B,7EH
0B39A0 CD 16 35 0B 1103**          		CALL    FMUL
0B39A4 AF          1104**          		XOR     A
0B39A5 C9          1105**          		RET
0B39A6             1106**  ;
0B39A6             1107**  ;ASN - Arc-sine
0B39A6             1108**  ;Result is floating-point numeric.
0B39A6             1109**  ;
0B39A6 CD AE 3D 0B 1110**  ASN:			CALL    SFLOAT
0B39AA CD BB 3E 0B 1111**          		CALL    PUSH5
0B39AE CD AB 3E 0B 1112**          		CALL    COPY_
0B39B2 CD 16 35 0B 1113**          		CALL    FMUL
0B39B6 CD 43 38 0B 1114**          		CALL    DONE
0B39BA CD F1 33 0B 1115**          		CALL    RSUB
0B39BE CD 21 37 0B 1116**          		CALL    SQR0
0B39C2 CD C4 3E 0B 1117**          		CALL    POP5
0B39C6 0C          1118**          		INC     C
0B39C7 0D          1119**          		DEC     C
0B39C8 3E 02       1120**          		LD      A,2
0B39CA D5          1121**          		PUSH    DE
0B39CB CA 50 3A 0B 1122**          		JP      Z,ACS1
0B39CF D1          1123**          		POP     DE
0B39D0 CD E6 38 0B 1124**          		CALL    RDIV
0B39D4 18 04       1125**          		JR      ATN0
0B39D6             1126**  ;
0B39D6             1127**  ;ATN - arc-tangent
0B39D6             1128**  ;Result is floating-point numeric.
0B39D6             1129**  ;
0B39D6 CD AE 3D 0B 1130**  ATN:			CALL    SFLOAT
0B39DA E5          1131**  ATN0:			PUSH    HL              ;SAVE SIGN
0B39DB CB BC       1132**          		RES     7,H
0B39DD 11 13 54 00 1133**          		LD      DE,5413H        ;TAN(PI/8)=SQR(2)-1
0B39E1 D9          1134**          		EXX
0B39E2 11 D0 CC 00 1135**          		LD      DE,0CCD0H
0B39E6 D9          1136**          		EXX
0B39E7 06 7E       1137**          		LD      B,7EH
0B39E9 CD 3B 3E 0B 1138**          		CALL    FCP0            ;COMPARE
0B39ED 06 00       1139**          		LD      B,0
0B39EF 38 22       1140**          		JR      C,ATN2
0B39F1 11 82 1A 00 1141**          		LD      DE,1A82H        ;TAN(3*PI/8)=SQR(2)+1
0B39F5 D9          1142**          		EXX
0B39F6 11 9A 79 00 1143**          		LD      DE,799AH
0B39FA D9          1144**          		EXX
0B39FB 06 81       1145**          		LD      B,81H
0B39FD CD 3B 3E 0B 1146**          		CALL    FCP0            ;COMPARE
0B3A01 38 0A       1147**          		JR      C,ATN1
0B3A03 CD E2 38 0B 1148**          		CALL    RECIP           ;X=1/X
0B3A07 06 02       1149**          		LD      B,2
0B3A09 C3 13 3A 0B 1150**          		JP      ATN2
0B3A0D CD D0 3E 0B 1151**  ATN1:			CALL    RATIO           ;X=(X-1)/(X+1)
0B3A11 06 01       1152**          		LD      B,1
0B3A13 C5          1153**  ATN2:			PUSH    BC              ;SAVE FLAG
0B3A14 CD BB 3E 0B 1154**          		CALL    PUSH5
0B3A18 CD B3 3E 0B 1155**          		CALL    SQUARE          ;PUSH X*X
0B3A1C CD F8 3E 0B 1156**          		CALL    POLY
0B3A20 35 F3       1157**          		DW	0F335H          ;a(13)
0B3A22 D8 37       1158**          		DW	37D8H
0B3A24 7B          1159**          		DB	7BH
0B3A25 91 6B       1160**          		DW	6B91H           ;a(11)
0B3A27 B9 AA       1161**          		DW	0AAB9H
0B3A29 7C          1162**          		DB	7CH
0B3A2A DE 41       1163**          		DW	41DEH           ;a(9)
0B3A2C 97 61       1164**          		DW	6197H
0B3A2E 7C          1165**          		DB	7CH
0B3A2F 7B 9D       1166**          		DW	9D7BH           ;a(7)
0B3A31 37 92       1167**          		DW	9237H
0B3A33 7D          1168**          		DB	7DH
0B3A34 5A 2A       1169**          		DW	2A5AH           ;a(5)
0B3A36 CC 4C       1170**          		DW	4CCCH
0B3A38 7D          1171**          		DB	7DH
0B3A39 5C A9       1172**          		DW	0A95CH          ;a(3)
0B3A3B AA AA       1173**          		DW	0AAAAH
0B3A3D 7E          1174**          		DB	7EH
0B3A3E 00 00       1175**          		DW	0               ;a(1)
0B3A40 00 00       1176**          		DW	0
0B3A42 80          1177**          		DB	80H
0B3A43 CD C4 3E 0B 1178**          		CALL    POP5
0B3A47 CD C4 3E 0B 1179**          		CALL    POP5
0B3A4B CD 16 35 0B 1180**          		CALL    FMUL
0B3A4F F1          1181**          		POP     AF
0B3A50 CD 50 38 0B 1182**  ACS1:			CALL    PIBY4           ;PI/4
0B3A54 1F          1183**          		RRA
0B3A55 F5          1184**          		PUSH    AF
0B3A56 DC 04 34 0B 1185**          		CALL    C,FADD
0B3A5A F1          1186**          		POP     AF
0B3A5B 04          1187**          		INC     B
0B3A5C 1F          1188**          		RRA
0B3A5D DC F1 33 0B 1189**          		CALL    C,RSUB
0B3A61 F1          1190**          		POP     AF
0B3A62 B7          1191**          		OR      A
0B3A63 F0          1192**          		RET     P
0B3A64 CB FC       1193**          		SET     7,H             ;MAKE NEGATIVE
0B3A66 AF          1194**          		XOR     A
0B3A67 C9          1195**          		RET
0B3A68             1196**  ;
0B3A68             1197**  ;ACS - Arc cosine=PI/2-ASN.
0B3A68             1198**  ;Result is floating point numeric.
0B3A68             1199**  ;
0B3A68 CD A6 39 0B 1200**  ACS:			CALL    ASN
0B3A6C 3E 02       1201**          		LD      A,2
0B3A6E F5          1202**          		PUSH    AF
0B3A6F 18 DF       1203**          		JR      ACS1
0B3A71             1204**  ;
0B3A71             1205**  ;Function STRING - convert numeric value to ASCII string.
0B3A71             1206**  ;   Inputs: HLH'L'C = integer or floating-point number
0B3A71             1207**  ;           DE = address at which to store string
0B3A71             1208**  ;           IX = address of @% format control
0B3A71             1209**  ;  Outputs: String stored, with NUL terminator
0B3A71             1210**  ;
0B3A71             1211**  ;First normalise for decimal output:
0B3A71             1212**  ;
0B3A71 CD AE 3D 0B 1213**  STRING:			CALL    SFLOAT
0B3A75 06 00       1214**          		LD      B,0             ;DEFAULT PT. POSITION
0B3A77 CB 7C       1215**          		BIT     7,H             ;NEGATIVE?
0B3A79 28 06       1216**          		JR      Z,STR10
0B3A7B CB BC       1217**          		RES     7,H
0B3A7D 3E 2D       1218**          		LD      A,'-'
0B3A7F 12          1219**          		LD      (DE),A          ;STORE SIGN
0B3A80 13          1220**          		INC     DE
0B3A81 AF          1221**  STR10:			XOR     A               ;CLEAR A
0B3A82 B9          1222**          		CP      C
0B3A83 28 4E       1223**          		JR      Z,STRING2          ;ZERO
0B3A85 D5          1224**          		PUSH    DE              ;SAVE TEXT POINTER
0B3A86 78          1225**          		LD      A,B
0B3A87 F5          1226**  STR11:			PUSH    AF              ;SAVE DECIMAL COUNTER
0B3A88 79          1227**          		LD      A,C             ;BINARY EXPONENT
0B3A89 FE A1       1228**          		CP      161
0B3A8B 30 1C       1229**          		JR      NC,STR14
0B3A8D FE 9B       1230**          		CP      155
0B3A8F 30 29       1231**          		JR      NC,STR15
0B3A91 2F          1232**          		CPL
0B3A92 FE E1       1233**          		CP      225
0B3A94 38 02       1234**          		JR      C,STR13
0B3A96 3E F8       1235**          		LD      A,-8
0B3A98 C6 1C       1236**  STR13:			ADD     A,28
0B3A9A CD 27 3F 0B 1237**          		CALL    POWR10
0B3A9E F5          1238**          		PUSH    AF
0B3A9F CD 16 35 0B 1239**          		CALL    FMUL
0B3AA3 F1          1240**          		POP     AF
0B3AA4 47          1241**          		LD      B,A
0B3AA5 F1          1242**          		POP     AF
0B3AA6 90          1243**          		SUB     B
0B3AA7 18 DE       1244**          		JR      STR11
0B3AA9 D6 20       1245**  STR14:			SUB     32
0B3AAB CD 27 3F 0B 1246**          		CALL    POWR10
0B3AAF F5          1247**          		PUSH    AF
0B3AB0 CD 6D 34 0B 1248**          		CALL    FDIV
0B3AB4 F1          1249**          		POP     AF
0B3AB5 47          1250**          		LD      B,A
0B3AB6 F1          1251**          		POP     AF
0B3AB7 80          1252**          		ADD     A,B
0B3AB8 18 CD       1253**          		JR      STR11
0B3ABA 3E 09       1254**  STR15:			LD      A,9
0B3ABC CD 27 3F 0B 1255**          		CALL    POWR10          ;10^9
0B3AC0 CD 3B 3E 0B 1256**          		CALL    FCP0
0B3AC4 79          1257**          		LD      A,C
0B3AC5 C1          1258**          		POP     BC
0B3AC6 4F          1259**          		LD      C,A
0B3AC7 CB FC       1260**          		SET     7,H             ;IMPLIED 1
0B3AC9 DC 63 3E 0B 1261**          		CALL    C,X10B          ;X10, DEC B
0B3ACD D1          1262**          		POP     DE              ;RESTORE TEXT POINTER
0B3ACE CB B9       1263**          		RES     7,C
0B3AD0 3E 00       1264**          		LD      A,0
0B3AD2 17          1265**          		RLA                     ;PUT CARRY IN LSB
0B3AD3             1266**  ;
0B3AD3             1267**  ;At this point decimal normalisation has been done,
0B3AD3             1268**  ;now convert to decimal digits:
0B3AD3             1269**  ;      AHLH'L' = number in normalised integer form
0B3AD3             1270**  ;            B = decimal place adjustment
0B3AD3             1271**  ;            C = binary place adjustment (29-33)
0B3AD3             1272**  ;
0B3AD3 0C          1273**  STRING2:			INC     C
0B3AD4 08          1274**          		EX      AF,AF'          ;SAVE A
0B3AD5 78          1275**          		LD      A,B
0B3AD6 DD CB 02 4E 1276**          		BIT     1,(IX+2)
0B3ADA 20 08       1277**          		JR      NZ,STR20
0B3ADC AF          1278**          		XOR     A
0B3ADD DD BE 01    1279**          		CP      (IX+1)
0B3AE0 28 0B       1280**          		JR      Z,STR21
0B3AE2 3E F6       1281**          		LD      A,-10
0B3AE4 DD 86 01    1282**  STR20:			ADD     A,(IX+1)        ;SIG. FIG. COUNT
0B3AE7 B7          1283**          		OR      A               ;CLEAR CARRY
0B3AE8 FA ED 3A 0B 1284**          		JP      M,STR21
0B3AEC AF          1285**          		XOR     A
0B3AED F5          1286**  STR21:			PUSH    AF
0B3AEE 08          1287**          		EX      AF,AF'          ;RESTORE A
0B3AEF CD 97 3E 0B 1288**  STR22:			CALL    X2              ;RL AHLH'L'
0B3AF3 8F          1289**          		ADC     A,A
0B3AF4 FE 0A       1290**          		CP      10
0B3AF6 38 05       1291**          		JR      C,STR23
0B3AF8 D6 0A       1292**          		SUB     10
0B3AFA D9          1293**          		EXX
0B3AFB 2C          1294**          		INC     L               ;SET RESULT BIT
0B3AFC D9          1295**          		EXX
0B3AFD 0D          1296**  STR23:			DEC     C
0B3AFE 20 EF       1297**          		JR      NZ,STR22        ;32 TIMES
0B3B00 4F          1298**          		LD      C,A             ;REMAINDER
0B3B01 7C          1299**          		LD      A,H
0B3B02 E6 3F       1300**          		AND     3FH             ;CLEAR OUT JUNK
0B3B04 67          1301**          		LD      H,A
0B3B05 F1          1302**          		POP     AF
0B3B06 F2 14 3B 0B 1303**          		JP      P,STR24
0B3B0A 3C          1304**          		INC     A
0B3B0B 20 1C       1305**          		JR      NZ,STR26
0B3B0D 3E 04       1306**          		LD      A,4
0B3B0F B9          1307**          		CP      C               ;ROUND UP?
0B3B10 3E 00       1308**          		LD      A,0
0B3B12 18 15       1309**          		JR      STR26
0B3B14 F5          1310**  STR24:			PUSH    AF
0B3B15 79          1311**          		LD      A,C
0B3B16 CE 30       1312**          		ADC     A,'0'           ;ADD CARRY
0B3B18 FE 30       1313**          		CP      '0'
0B3B1A 28 05       1314**          		JR      Z,STR25         ;SUPPRESS ZERO
0B3B1C FE 3A       1315**          		CP      '9'+1
0B3B1E 3F          1316**          		CCF
0B3B1F 30 08       1317**          		JR      NC,STR26
0B3B21 E3          1318**  STR25:			EX      (SP),HL
0B3B22 CB 75       1319**          		BIT     6,L             ;ZERO FLAG
0B3B24 E3          1320**  		        EX      (SP),HL
0B3B25 20 05       1321**          		JR      NZ,STR27
0B3B27 3E 30       1322**          		LD      A,'0'
0B3B29 3C          1323**  STR26:			INC     A               ;SET +VE
0B3B2A 3D          1324**          		DEC     A
0B3B2B F5          1325**          		PUSH    AF              ;PUT ON STACK + CARRY
0B3B2C 04          1326**  STR27:			INC     B
0B3B2D CD 07 3E 0B 1327**          		CALL    TEST_FP            ;IS HLH'L' ZERO?
0B3B31 0E 20       1328**          		LD      C,32
0B3B33 3E 00       1329**          		LD      A,0
0B3B35 20 B8       1330**          		JR      NZ,STR22
0B3B37 F1          1331**          		POP     AF
0B3B38 F5          1332**          		PUSH    AF
0B3B39 3E 00       1333**          		LD      A,0
0B3B3B 38 B2       1334**          		JR      C,STR22
0B3B3D             1335**  ;
0B3B3D             1336**  ;At this point, the decimal character string is stored
0B3B3D             1337**  ; on the stack. Trailing zeroes are suppressed and may
0B3B3D             1338**  ; need to be replaced.
0B3B3D             1339**  ;B register holds decimal point position.
0B3B3D             1340**  ;Now format number and store as ASCII string:
0B3B3D             1341**  ;
0B3B3D EB          1342**  STR3:			EX      DE,HL           ;STRING POINTER
0B3B3E 0E FF       1343**          		LD      C,-1            ;FLAG "E"
0B3B40 16 01       1344**          		LD      D,1
0B3B42 DD 5E 01    1345**          		LD      E,(IX+1)        ;f2
0B3B45 DD CB 02 46 1346**          		BIT     0,(IX+2)
0B3B49 20 35       1347**          		JR      NZ,STR34        ;E MODE
0B3B4B DD CB 02 4E 1348**          		BIT     1,(IX+2)
0B3B4F 28 12       1349**          		JR      Z,STR31
0B3B51 78          1350**          		LD      A,B             ;F MODE
0B3B52 B7          1351**          		OR      A
0B3B53 28 05       1352**          		JR      Z,STR30
0B3B55 FA 5A 3B 0B 1353**          		JP      M,STR30
0B3B59 50          1354**          		LD      D,B
0B3B5A 7A          1355**  STR30:			LD      A,D
0B3B5B DD 86 01    1356**          		ADD     A,(IX+1)
0B3B5E 5F          1357**          		LD      E,A
0B3B5F FE 0B       1358**          		CP      11
0B3B61 38 19       1359**          		JR      C,STR32
0B3B63 78          1360**  STR31:			LD      A,B             ;G MODE
0B3B64 11 01 01 00 1361**          		LD      DE,101H
0B3B68 B7          1362**          		OR      A
0B3B69 FA 80 3B 0B 1363**          		JP      M,STR34
0B3B6D 28 0D       1364**          		JR      Z,STR32
0B3B6F DD 7E 01    1365**          		LD      A,(IX+1)
0B3B72 B7          1366**          		OR      A
0B3B73 20 02       1367**          		JR      NZ,STR3A
0B3B75 3E 0A       1368**          		LD      A,10
0B3B77 B8          1369**  STR3A:			CP      B
0B3B78 38 06       1370**          		JR      C,STR34
0B3B7A 50          1371**          		LD      D,B
0B3B7B 58          1372**          		LD      E,B
0B3B7C 78          1373**  STR32:			LD      A,B
0B3B7D C6 81       1374**          		ADD     A,129
0B3B7F 4F          1375**          		LD      C,A
0B3B80 CB FA       1376**  STR34:			SET     7,D
0B3B82 1D          1377**          		DEC     E
0B3B83 7A          1378**  STR35:			LD      A,D
0B3B84 B9          1379**          		CP      C
0B3B85 30 0E       1380**          		JR      NC,STR33
0B3B87 F1          1381**  STR36:			POP     AF
0B3B88 28 04       1382**          		JR      Z,STR37
0B3B8A F2 97 3B 0B 1383**          		JP      P,STR38
0B3B8E F5          1384**  STR37:			PUSH    AF
0B3B8F 1C          1385**          		INC     E
0B3B90 1D          1386**          		DEC     E
0B3B91 FA A8 3B 0B 1387**          		JP      M,STR4
0B3B95 3E 30       1388**  STR33:			LD      A,'0'
0B3B97 15          1389**  STR38:			DEC     D
0B3B98 E2 9F 3B 0B 1390**          		JP      PO,STR39
0B3B9C 36 2E       1391**          		LD      (HL),'.'
0B3B9E 23          1392**          		INC     HL
0B3B9F 77          1393**  STR39:			LD      (HL),A
0B3BA0 23          1394**          		INC     HL
0B3BA1 1D          1395**          		DEC     E
0B3BA2 F2 83 3B 0B 1396**          		JP      P,STR35
0B3BA6 18 DF       1397**          		JR      STR36
0B3BA8             1398**  ;
0B3BA8 F1          1399**  STR4:			POP     AF
0B3BA9 0C          1400**  STR40:			INC     C
0B3BAA 4D          1401**          		LD      C,L
0B3BAB 20 28       1402**          		JR      NZ,STR44
0B3BAD 36 45       1403**          		LD      (HL),'E'        ;EXPONENT
0B3BAF 23          1404**          		INC     HL
0B3BB0 78          1405**          		LD      A,B
0B3BB1 3D          1406**          		DEC     A
0B3BB2 F2 BB 3B 0B 1407**          		JP      P,STR41
0B3BB6 36 2D       1408**          		LD      (HL),'-'
0B3BB8 23          1409**          		INC     HL
0B3BB9 ED 44       1410**          		NEG
0B3BBB 36 30       1411**  STR41:			LD      (HL),'0'
0B3BBD 28 15       1412**          		JR      Z,STR47
0B3BBF FE 0A       1413**          		CP      10
0B3BC1 47          1414**          		LD      B,A
0B3BC2 3E 3A       1415**          		LD      A,':'
0B3BC4 38 03       1416**          		JR      C,STR42
0B3BC6 23          1417**          		INC     HL
0B3BC7 36 30       1418**          		LD      (HL),'0'
0B3BC9 34          1419**  STR42:			INC     (HL)
0B3BCA BE          1420**          		CP      (HL)
0B3BCB 20 05       1421**          		JR      NZ,STR43
0B3BCD 36 30       1422**          		LD      (HL),'0'
0B3BCF 2B          1423**          		DEC     HL
0B3BD0 34          1424**          		INC     (HL)
0B3BD1 23          1425**          		INC     HL
0B3BD2 10 F5       1426**  STR43:			DJNZ    STR42
0B3BD4 23          1427**  STR47:			INC     HL
0B3BD5 EB          1428**  STR44:			EX      DE,HL
0B3BD6 C9          1429**        			RET
0B3BD7             1430**  ;
0B3BD7             1431**  ;Support subroutines:
0B3BD7             1432**  ;
0B3BD7 DD 46 04    1433**  DLOAD5:			LD      B,(IX+4)
0B3BDA D9          1434**          		EXX
0B3BDB DD 5E 00    1435**          		LD      E,(IX+0)
0B3BDE DD 56 01    1436**          		LD      D,(IX+1)
0B3BE1 D9          1437**          		EXX
0B3BE2 DD 5E 02    1438**          		LD      E,(IX+2)
0B3BE5 DD 56 03    1439**          		LD      D,(IX+3)
0B3BE8 C9          1440**          		RET
0B3BE9             1441**  ;
0B3BE9 DD 46 06    1442**  DLOAD5_SPL:		LD      B,(IX+6)
0B3BEC D9          1443**  			EXX
0B3BED DD 17 00    1444**  			LD	DE, (IX+0)
0B3BF0 D9          1445**  			EXX
0B3BF1 DD 17 03    1446**  			LD	DE, (IX+3)
0B3BF4 C9          1447**  			RET
0B3BF5             1448**  ;
0B3BF5             1449**  ;CON - Get unsigned numeric constant from ASCII string.
0B3BF5             1450**  ;   Inputs: ASCII string at (IX).
0B3BF5             1451**  ;  Outputs: Variable-type result in HLH'L'C
0B3BF5             1452**  ;           IX updated (points to delimiter)
0B3BF5             1453**  ;           A7 = 0 (numeric marker)
0B3BF5             1454**  ;
0B3BF5 CD 2B 3E 0B 1455**  CON:			CALL    FPZERO            ;INITIALISE TO ZERO
0B3BF9 0E 00       1456**          		LD      C,0             ;TRUNCATION COUNTER
0B3BFB CD 89 3C 0B 1457**          		CALL    NUMBER          ;GET INTEGER PART
0B3BFF FE 2E       1458**          		CP      '.'
0B3C01 06 00       1459**          		LD      B,0             ;DECL. PLACE COUNTER
0B3C03 CC 87 3C 0B 1460**          		CALL    Z,NUMBIX        ;GET FRACTION PART
0B3C07 FE 45       1461**          		CP      'E'
0B3C09 3E 00       1462**          		LD      A,0             ;INITIALISE EXPONENT
0B3C0B CC 55 3C 0B 1463**          		CALL    Z,GETEXP        ;GET EXPONENT
0B3C0F CB 7C       1464**          		BIT     7,H
0B3C11 20 08       1465**          		JR      NZ,CON0         ;INTEGER OVERFLOW
0B3C13 B7          1466**          		OR      A
0B3C14 20 05       1467**          		JR      NZ,CON0         ;EXPONENT NON-ZERO
0B3C16 B8          1468**          		CP      B
0B3C17 20 02       1469**          		JR      NZ,CON0         ;DECIMAL POINT
0B3C19 B9          1470**          		CP      C
0B3C1A C8          1471**          		RET     Z               ;INTEGER
0B3C1B 90          1472**  CON0:			SUB     B
0B3C1C 81          1473**          		ADD     A,C
0B3C1D 0E 9F       1474**          		LD      C,159
0B3C1F CD 8E 3D 0B 1475**          		CALL    FLOAT_
0B3C23 CB BC       1476**          		RES     7,H             ;DITCH IMPLIED 1
0B3C25 B7          1477**          		OR      A
0B3C26 C8          1478**          		RET     Z               ;DONE
0B3C27 FA 35 3C 0B 1479**          		JP      M,CON2          ;NEGATIVE EXPONENT
0B3C2B CD 27 3F 0B 1480**          		CALL    POWR10
0B3C2F CD 16 35 0B 1481**          		CALL    FMUL            ;SCALE
0B3C33 AF          1482**          		XOR     A
0B3C34 C9          1483**          		RET
0B3C35 FE DA       1484**  CON2:			CP      -38
0B3C37 38 0C       1485**          		JR      C,CON3          ;CAN'T SCALE IN ONE GO
0B3C39 ED 44       1486**          		NEG
0B3C3B CD 27 3F 0B 1487**          		CALL    POWR10
0B3C3F CD 6D 34 0B 1488**          		CALL    FDIV            ;SCALE
0B3C43 AF          1489**          		XOR     A
0B3C44 C9          1490**          		RET
0B3C45 F5          1491**  CON3:			PUSH    AF
0B3C46 3E 26       1492**          		LD      A,38
0B3C48 CD 27 3F 0B 1493**          		CALL    POWR10
0B3C4C CD 6D 34 0B 1494**          		CALL    FDIV
0B3C50 F1          1495**          		POP     AF
0B3C51 C6 26       1496**          		ADD     A,38
0B3C53 18 E0       1497**          		JR      CON2
0B3C55             1498**  ;
0B3C55             1499**  ;GETEXP - Get decimal exponent from string
0B3C55             1500**  ;     Inputs: ASCII string at (IX)
0B3C55             1501**  ;             (IX points at 'E')
0B3C55             1502**  ;             A = initial value
0B3C55             1503**  ;    Outputs: A = new exponent
0B3C55             1504**  ;             IX updated.
0B3C55             1505**  ;   Destroys: A,A',IX,F,F'
0B3C55             1506**  ;
0B3C55 C5          1507**  GETEXP:			PUSH    BC              ;SAVE REGISTERS
0B3C56 47          1508**          		LD      B,A             ;INITIAL VALUE
0B3C57 0E 02       1509**          		LD      C,2             ;2 DIGITS MAX
0B3C59 DD 23       1510**          		INC     IX              ;BUMP PAST 'E'
0B3C5B CD 45 40 0B 1511**          		CALL    SIGNQ
0B3C5F 08          1512**          		EX      AF,AF'          ;SAVE EXPONENT SIGN
0B3C60 CD 3B 40 0B 1513**  GETEX1:			CALL    DIGITQ
0B3C64 38 18       1514**          		JR      C,GETEX2
0B3C66 78          1515**          		LD      A,B             ;B=B*10
0B3C67 87          1516**          		ADD     A,A
0B3C68 87          1517**          		ADD     A,A
0B3C69 80          1518**          		ADD     A,B
0B3C6A 87          1519**          		ADD     A,A
0B3C6B 47          1520**          		LD      B,A
0B3C6C DD 7E 00    1521**          		LD      A,(IX)          ;GET BACK DIGIT
0B3C6F DD 23       1522**          		INC     IX
0B3C71 E6 0F       1523**          		AND     0FH             ;MASK UNWANTED BITS
0B3C73 80          1524**          		ADD     A,B             ;ADD IN DIGIT
0B3C74 47          1525**          		LD      B,A
0B3C75 0D          1526**          		DEC     C
0B3C76 F2 60 3C 0B 1527**          		JP      P,GETEX1
0B3C7A 06 64       1528**          		LD      B,100           ;FORCE OVERFLOW
0B3C7C 18 E2       1529**          		JR      GETEX1
0B3C7E 08          1530**  GETEX2:			EX      AF,AF'          ;RESTORE SIGN
0B3C7F FE 2D       1531**          		CP      '-'
0B3C81 78          1532**          		LD      A,B
0B3C82 C1          1533**          		POP     BC              ;RESTORE
0B3C83 C0          1534**          		RET     NZ
0B3C84 ED 44       1535**          		NEG                     ;NEGATE EXPONENT
0B3C86 C9          1536**          		RET
0B3C87             1537**  ;
0B3C87             1538**  ;NUMBER: Get unsigned integer from string.
0B3C87             1539**  ;    Inputs: string at (IX)
0B3C87             1540**  ;            C = truncated digit count
0B3C87             1541**  ;                (initially zero)
0B3C87             1542**  ;            B = total digit count
0B3C87             1543**  ;            HLH'L' = initial value
0B3C87             1544**  ;   Outputs: HLH'L' = number (binary integer)
0B3C87             1545**  ;            A = delimiter.
0B3C87             1546**  ;            B, C & IX updated
0B3C87             1547**  ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B3C87             1548**  ;
0B3C87 DD 23       1549**  NUMBIX:			INC     IX
0B3C89 CD 3B 40 0B 1550**  NUMBER:			CALL    DIGITQ
0B3C8D D8          1551**          		RET     C
0B3C8E 04          1552**          		INC     B               ;INCREMENT DIGIT COUNT
0B3C8F DD 23       1553**          		INC     IX
0B3C91 CD 84 3E 0B 1554**          		CALL    X10             ;*10 & COPY OLD VALUE
0B3C95 38 15       1555**          		JR      C,NUMB1         ;OVERFLOW
0B3C97 0D          1556**          		DEC     C               ;SEE IF TRUNCATED
0B3C98 0C          1557**          		INC     C
0B3C99 20 11       1558**          		JR      NZ,NUMB1        ;IMPORTANT!
0B3C9B E6 0F       1559**          		AND     0FH
0B3C9D D9          1560**          		EXX
0B3C9E 06 00       1561**          		LD      B,0
0B3CA0 4F          1562**          		LD      C,A
0B3CA1 52 09       1563**          		ADD.S   HL,BC           ;ADD IN DIGIT
0B3CA3 D9          1564**          		EXX
0B3CA4 30 E3       1565**          		JR      NC,NUMBER
0B3CA6 52 23       1566**          		INC.S   HL              ;CARRY
0B3CA8 7C          1567**          		LD      A,H
0B3CA9 B5          1568**          		OR      L
0B3CAA 20 DD       1569**          		JR      NZ,NUMBER
0B3CAC 0C          1570**  NUMB1:			INC     C               ;TRUNCATION COUNTER
0B3CAD CD E2 3D 0B 1571**          		CALL    SWAP1           ;RESTORE PREVIOUS VALUE
0B3CB1 18 D6       1572**          		JR      NUMBER
0B3CB3             1573**  ;
0B3CB3             1574**  ;FIX - Fix number to specified exponent value.
0B3CB3             1575**  ;    Inputs: HLH'L'C = +ve non-zero number (floated)
0B3CB3             1576**  ;            A = desired exponent (A>C)
0B3CB3             1577**  ;   Outputs: HLH'L'C = fixed number (unsigned)
0B3CB3             1578**  ;            fraction shifted into B'C'
0B3CB3             1579**  ;            A'F' positive if integer input
0B3CB3             1580**  ;  Destroys: C,H,L,A',B',C',H',L',F,F'
0B3CB3             1581**  ;
0B3CB3 08          1582**  FIX:			EX      AF,AF'
0B3CB4 AF          1583**          		XOR     A
0B3CB5 08          1584**          		EX      AF,AF'
0B3CB6 CB FC       1585**          		SET     7,H             ;IMPLIED 1
0B3CB8 CD E7 3D 0B 1586**  FIX1:			CALL    DIV2
0B3CBC B9          1587**          		CP      C
0B3CBD C8          1588**          		RET     Z
0B3CBE D2 B8 3C 0B 1589**          		JP      NC,FIX1
0B3CC2 C3 F6 3D 0B 1590**          		JP      OFLOW
0B3CC6             1591**  ;
0B3CC6             1592**  ;SFIX_FP - Convert to integer if necessary.
0B3CC6             1593**  ;    Input: Variable-type number in HLH'L'C
0B3CC6             1594**  ;   Output: Integer in HLH'L', C=0
0B3CC6             1595**  ; Destroys: A,C,H,L,A',B',C',H',L',F,F'
0B3CC6             1596**  ;
0B3CC6             1597**  ;NEGATE - Negate HLH'L'
0B3CC6             1598**  ;    Destroys: H,L,H',L',F
0B3CC6             1599**  ;
0B3CC6 CD DF 3D 0B 1600**  FIX2:			CALL    SWAP_FP
0B3CCA CD D2 3C 0B 1601**          		CALL    SFIX_FP
0B3CCE CD DF 3D 0B 1602**          		CALL    SWAP_FP
0B3CD2 0D          1603**  SFIX_FP:			DEC     C
0B3CD3 0C          1604**          		INC     C
0B3CD4 C8          1605**          		RET     Z               ;INTEGER/ZERO
0B3CD5 CB 7C       1606**          		BIT     7,H             ;SIGN
0B3CD7 F5          1607**          		PUSH    AF
0B3CD8 3E 9F       1608**          		LD      A,159
0B3CDA CD B3 3C 0B 1609**          		CALL    FIX
0B3CDE F1          1610**          		POP     AF
0B3CDF 0E 00       1611**          		LD      C,0
0B3CE1 C8          1612**          		RET     Z
0B3CE2 B7          1613**  NEGATE:			OR      A               ;CLEAR CARRY
0B3CE3 D9          1614**          		EXX
0B3CE4 D5          1615**  NEG0:			PUSH    DE
0B3CE5 EB          1616**          		EX      DE,HL
0B3CE6 21 00 00 00 1617**          		LD      HL,0
0B3CEA 52 ED 52    1618**          		SBC.S   HL,DE
0B3CED D1          1619**          		POP     DE
0B3CEE D9          1620**          		EXX
0B3CEF D5          1621**          		PUSH    DE
0B3CF0 EB          1622**          		EX      DE,HL
0B3CF1 21 00 00 00 1623**          		LD      HL,0
0B3CF5 52 ED 52    1624**          		SBC.S   HL,DE
0B3CF8 D1          1625**          		POP     DE
0B3CF9 C9          1626**          		RET
0B3CFA             1627**  ;
0B3CFA             1628**  ;NEG - Negate HLH'L'B'C'
0B3CFA             1629**  ;    Also complements A (used in FADD)
0B3CFA             1630**  ;    Destroys: A,H,L,B',C',H',L',F
0B3CFA             1631**  ;
0B3CFA D9          1632**  NEG_:			EXX
0B3CFB 2F          1633**          		CPL
0B3CFC E5          1634**          		PUSH    HL
0B3CFD B7          1635**          		OR      A               ;CLEAR CARRY
0B3CFE 21 00 00 00 1636**          		LD      HL,0
0B3D02 52 ED 42    1637**          		SBC.S   HL,BC
0B3D05 44          1638**          		LD      B,H
0B3D06 4D          1639**          		LD      C,L
0B3D07 E1          1640**          		POP     HL
0B3D08 18 DA       1641**          		JR      NEG0
0B3D0A             1642**  ;
0B3D0A             1643**  ;SCALE - Trig scaling.
0B3D0A             1644**  ;MOD48 - 48-bit floating-point "modulus" (remainder).
0B3D0A             1645**  ;   Inputs: HLH'L'C unsigned floating-point dividend
0B3D0A             1646**  ;           DED'E'B'C'B unsigned 48-bit FP divisor
0B3D0A             1647**  ;  Outputs: HLH'L'C floating point remainder (H7=1)
0B3D0A             1648**  ;           E = quotient (bit 7 is sticky)
0B3D0A             1649**  ; Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B3D0A             1650**  ;FLO48 - Float unsigned number (48 bits)
0B3D0A             1651**  ;    Input/output in HLH'L'B'C'C
0B3D0A             1652**  ;   Destroys: C,H,L,B',C',H',L',F
0B3D0A             1653**  ;
0B3D0A 3E 96       1654**  SCALE:			LD      A,150
0B3D0C B9          1655**          		CP      C
0B3D0D 3E 17       1656**          		LD      A,ACLOST
0B3D0F DA 85 32 0B 1657**          		JP      C,ERROR_FP         ;"Accuracy lost"
0B3D13 CD 50 38 0B 1658**          		CALL    PIBY4
0B3D17 D9          1659**          		EXX
0B3D18 01 69 21 00 1660**          		LD      BC,2169H        ;3.141592653589793238
0B3D1C D9          1661**          		EXX
0B3D1D CB FA       1662**  MOD48:			SET     7,D             ;IMPLIED 1
0B3D1F CB FC       1663**          		SET     7,H
0B3D21 79          1664**          		LD      A,C
0B3D22 0E 00       1665**          		LD      C,0             ;INIT QUOTIENT
0B3D24 DD 21 00 00 1666**          		LD      IX,0
       00          
0B3D29 DD E5       1667**          		PUSH    IX              ;PUT ZERO ON STACK
0B3D2B B8          1668**          		CP      B
0B3D2C 38 46       1669**          		JR      C,MOD485        ;DIVIDEND<DIVISOR
0B3D2E D9          1670**  MOD481:			EXX                     ;CARRY=0 HERE
0B3D2F E3          1671**          		EX      (SP),HL
0B3D30 52 ED 42    1672**          		SBC.S   HL,BC
0B3D33 E3          1673**          		EX      (SP),HL
0B3D34 52 ED 52    1674**          		SBC.S   HL,DE
0B3D37 D9          1675**          		EXX
0B3D38 52 ED 52    1676**          		SBC.S   HL,DE
0B3D3B 30 0C       1677**          		JR      NC,MOD482       ;DIVIDEND>=DIVISOR
0B3D3D D9          1678**          		EXX
0B3D3E E3          1679**          		EX      (SP),HL
0B3D3F 52 09       1680**          		ADD.S   HL,BC
0B3D41 E3          1681**          		EX      (SP),HL
0B3D42 52 ED 5A    1682**          		ADC.S   HL,DE
0B3D45 D9          1683**          		EXX
0B3D46 52 ED 5A    1684**          		ADC.S   HL,DE
0B3D49 3F          1685**  MOD482:			CCF
0B3D4A CB 11       1686**          		RL      C               ;QUOTIENT
0B3D4C 30 02       1687**          		JR      NC,MOD483
0B3D4E CB F9       1688**          		SET     7,C             ;STICKY BIT
0B3D50 3D          1689**  MOD483:			DEC     A
0B3D51 B8          1690**          		CP      B
0B3D52 38 1F       1691**          		JR      C,MOD484        ;DIVIDEND<DIVISOR
0B3D54 E3          1692**          		EX      (SP),HL
0B3D55 52 29       1693**          		ADD.S   HL,HL           ;DIVIDEND * 2
0B3D57 E3          1694**          		EX      (SP),HL
0B3D58 D9          1695**          		EXX
0B3D59 52 ED 6A    1696**          		ADC.S   HL,HL
0B3D5C D9          1697**          		EXX
0B3D5D 52 ED 6A    1698**          		ADC.S   HL,HL
0B3D60 30 CC       1699**          		JR      NC,MOD481       ;AGAIN
0B3D62 B7          1700**          		OR      A
0B3D63 D9          1701**          		EXX
0B3D64 E3          1702**          		EX      (SP),HL
0B3D65 52 ED 42    1703**          		SBC.S   HL,BC           ;OVERFLOW, SO SUBTRACT
0B3D68 E3          1704**          		EX      (SP),HL
0B3D69 52 ED 52    1705**          		SBC.S   HL,DE
0B3D6C D9          1706**          		EXX
0B3D6D 52 ED 52    1707**          		SBC.S   HL,DE
0B3D70 B7          1708**          		OR      A
0B3D71 18 D6       1709**          		JR      MOD482
0B3D73             1710**  ;
0B3D73 3C          1711**  MOD484:			INC     A
0B3D74 59          1712**  MOD485:			LD      E,C             ;QUOTIENT
0B3D75 4F          1713**          		LD      C,A             ;REMAINDER EXPONENT
0B3D76 D9          1714**          		EXX
0B3D77 C1          1715**          		POP     BC
0B3D78 D9          1716**          		EXX
0B3D79 CB 7C       1717**  FLO48:			BIT     7,H
0B3D7B C0          1718**          		RET     NZ
0B3D7C D9          1719**          		EXX
0B3D7D CB 21       1720**          		SLA     C
0B3D7F CB 10       1721**          		RL      B
0B3D81 52 ED 6A    1722**          		ADC.S   HL,HL
0B3D84 D9          1723**          		EXX
0B3D85 52 ED 6A    1724**          		ADC.S   HL,HL
0B3D88 0D          1725**          		DEC     C
0B3D89 C2 79 3D 0B 1726**          		JP      NZ,FLO48
0B3D8D C9          1727**          		RET
0B3D8E             1728**  ;
0B3D8E             1729**  ;Float unsigned number
0B3D8E             1730**  ;    Input/output in HLH'L'C
0B3D8E             1731**  ;   Destroys: C,H,L,H',L',F
0B3D8E             1732**  ;
0B3D8E CB 7C       1733**  FLOAT_:			BIT     7,H
0B3D90 C0          1734**          		RET     NZ
0B3D91 D9          1735**          		EXX                     ;SAME AS "X2"
0B3D92 52 29       1736**          		ADD.S   HL,HL           ;TIME-CRITICAL
0B3D94 D9          1737**          		EXX                     ;REGION
0B3D95 52 ED 6A    1738**          		ADC.S   HL,HL           ;(BENCHMARKS)
0B3D98 0D          1739**          		DEC     C
0B3D99 C2 8E 3D 0B 1740**          		JP      NZ,FLOAT_
0B3D9D C9          1741**          		RET
0B3D9E             1742**  ;
0B3D9E             1743**  ;SFLOAT - Convert to floating-point if necessary.
0B3D9E             1744**  ;    Input: Variable-type number in HLH'L'C
0B3D9E             1745**  ;    Output: Floating-point in HLH'L'C
0B3D9E             1746**  ;    Destroys: A,C,H,L,H',L',F
0B3D9E             1747**  ;
0B3D9E 08          1748**  FLOATA:			EX      AF,AF'
0B3D9F             1749**          		; ADD     A,(RTABLE-DTABLE)/3
0B3D9F C6 2A       1750**          		ADD     A,RTABLE-DTABLE/3 ; ez80asm doesn't do nested expressions
0B3DA1 08          1751**          		EX      AF,AF'
0B3DA2 CD DF 3D 0B 1752**  FLOAT2:			CALL    SWAP_FP
0B3DA6 CD AE 3D 0B 1753**          		CALL    SFLOAT
0B3DAA CD DF 3D 0B 1754**          		CALL    SWAP_FP
0B3DAE 0D          1755**  SFLOAT:			DEC     C
0B3DAF 0C          1756**          		INC     C
0B3DB0 C0          1757**          		RET     NZ              ;ALREADY FLOATING-POINT
0B3DB1 CD 07 3E 0B 1758**          		CALL    TEST_FP
0B3DB5 C8          1759**          		RET     Z               ;ZERO
0B3DB6 7C          1760**          		LD      A,H
0B3DB7 B7          1761**          		OR      A
0B3DB8 FC E2 3C 0B 1762**          		CALL    M,NEGATE
0B3DBC 0E 9F       1763**          		LD      C,159
0B3DBE CD 8E 3D 0B 1764**          		CALL    FLOAT_
0B3DC2 B7          1765**          		OR      A
0B3DC3 F8          1766**          		RET     M               ;NEGATIVE
0B3DC4 CB BC       1767**          		RES     7,H
0B3DC6 C9          1768**          		RET
0B3DC7             1769**  ;
0B3DC7             1770**  ;ROUND UP
0B3DC7             1771**  ;Return with carry set if 32-bit overflow
0B3DC7             1772**  ;   Destroys: H,L,B',C',H',L',F
0B3DC7             1773**  ;
0B3DC7 D9          1774**  ADD1:			EXX
0B3DC8 01 01 00 00 1775**          		LD      BC,1
0B3DCC 52 09       1776**          		ADD.S   HL,BC
0B3DCE D9          1777**          		EXX
0B3DCF D0          1778**          		RET     NC
0B3DD0 C5          1779**          		PUSH    BC
0B3DD1 01 01 00 00 1780**          		LD      BC,1
0B3DD5 52 09       1781**          		ADD.S   HL,BC
0B3DD7 C1          1782**          		POP     BC
0B3DD8 C9          1783**          		RET
0B3DD9             1784**  ;
0B3DD9             1785**  ;ODD - Add one if even, leave alone if odd.
0B3DD9             1786**  ; (Used to perform unbiassed rounding, i.e.
0B3DD9             1787**  ;  number is rounded up half the time)
0B3DD9             1788**  ;    Destroys: L',F (carry cleared)
0B3DD9             1789**  ;
0B3DD9 B7          1790**  ODD:			OR      A               ;CLEAR CARRY
0B3DDA D9          1791**          		EXX
0B3DDB CB C5       1792**          		SET     0,L             ;MAKE ODD
0B3DDD D9          1793**          		EXX
0B3DDE C9          1794**          		RET
0B3DDF             1795**  ;
0B3DDF             1796**  ;SWAP_FP - Swap arguments.
0B3DDF             1797**  ;    Exchanges DE,HL D'E',H'L' and B,C
0B3DDF             1798**  ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B3DDF             1799**  ;SWAP1 - Swap DEHL with D'E'H'L'
0B3DDF             1800**  ;    Destroys: D,E,H,L,D',E',H',L'
0B3DDF             1801**  ;
0B3DDF 79          1802**  SWAP_FP:			LD      A,C
0B3DE0 48          1803**          		LD      C,B
0B3DE1 47          1804**          		LD      B,A
0B3DE2 EB          1805**  SWAP1:			EX      DE,HL
0B3DE3 D9          1806**          		EXX
0B3DE4 EB          1807**          		EX      DE,HL
0B3DE5 D9          1808**          		EXX
0B3DE6 C9          1809**          		RET
0B3DE7             1810**  ;
0B3DE7             1811**  ; DIV2 - destroys C,H,L,A',B',C',H',L',F,F'
0B3DE7             1812**  ; INCC - destroys C,F
0B3DE7             1813**  ; OFLOW
0B3DE7             1814**  ;
0B3DE7 CD A0 3E 0B 1815**  DIV2:			CALL    D2
0B3DEB D9          1816**          		EXX
0B3DEC CB 18       1817**          		RR      B
0B3DEE CB 19       1818**          		RR      C
0B3DF0 08          1819**          		EX      AF,AF'
0B3DF1 B0          1820**          		OR      B
0B3DF2 08          1821**          		EX      AF,AF'
0B3DF3 D9          1822**          		EXX
0B3DF4 0C          1823**  INCC:			INC     C
0B3DF5 C0          1824**          		RET     NZ
0B3DF6 3E 14       1825**  OFLOW:			LD      A,TOOBIG
0B3DF8 C3 85 32 0B 1826**          		JP      ERROR_FP           ;"Too big"
0B3DFC             1827**  ;
0B3DFC             1828**  ; FTEST - Test for zero & sign
0B3DFC             1829**  ;     Output: A=0 if zero, A=&40 if +ve, A=&C0 if -ve
0B3DFC             1830**  ;
0B3DFC CD 07 3E 0B 1831**  FTEST:			CALL    TEST_FP
0B3E00 C8          1832**          		RET     Z
0B3E01 7C          1833**          		LD      A,H
0B3E02 E6 80       1834**          		AND     10000000B
0B3E04 F6 40       1835**          		OR      01000000B
0B3E06 C9          1836**          		RET
0B3E07             1837**  ;
0B3E07             1838**  ; TEST_FP - Test HLH'L' for zero.
0B3E07             1839**  ;     Output: Z-flag set & A=0 if HLH'L'=0
0B3E07             1840**  ;     Destroys: A,F
0B3E07             1841**  ;
0B3E07 7C          1842**  TEST_FP:			LD      A,H
0B3E08 B5          1843**          		OR      L
0B3E09 D9          1844**          		EXX
0B3E0A B4          1845**          		OR      H
0B3E0B B5          1846**          		OR      L
0B3E0C D9          1847**          		EXX
0B3E0D C9          1848**          		RET
0B3E0E             1849**  ;
0B3E0E             1850**  ; FCOMP - Compare two numbers
0B3E0E             1851**  ;     Output: A=0 if equal, A=&40 if L>R, A=&C0 if L<R
0B3E0E             1852**  ;
0B3E0E 78          1853**  FCOMP:			LD      A,B
0B3E0F B1          1854**          		OR      C               ;Both integer?
0B3E10 20 0B       1855**          		JR      NZ,FCOMP1
0B3E12 CD 27 3E 0B 1856**          		CALL    ICP
0B3E16 3E 00       1857**  FCOMP0:			LD      A,0
0B3E18 C8          1858**          		RET     Z               ;Equal
0B3E19 3E 80       1859**          		LD      A,80H
0B3E1B 1F          1860**          		RRA
0B3E1C C9          1861**          		RET
0B3E1D             1862**  ;
0B3E1D CD A2 3D 0B 1863**  FCOMP1:			CALL    FLOAT2          ;Float both
0B3E21 CD 35 3E 0B 1864**          		CALL    FCP
0B3E25 18 EF       1865**          		JR      FCOMP0
0B3E27             1866**  ;
0B3E27             1867**  ; Integer and floating point compare.
0B3E27             1868**  ; Sets carry & zero flags according to HLH'L'C-DED'E'B
0B3E27             1869**  ; Result pre-set to FALSE
0B3E27             1870**  ; ICP1, FCP1 destroy A,F
0B3E27             1871**  ;
0B3E27             1872**  ; FPZERO - Return zero.
0B3E27             1873**  ;  Destroys: A,C,H,L,H',L'
0B3E27             1874**  ;
0B3E27 CD 5A 3E 0B 1875**  ICP:			CALL    ICP1
0B3E2B 3E 00       1876**  FPZERO:			LD      A,0
0B3E2D D9          1877**          		EXX
0B3E2E 67          1878**          		LD      H,A
0B3E2F 6F          1879**  	       		LD      L,A
0B3E30 D9          1880**          		EXX
0B3E31 67          1881**        			LD      H,A
0B3E32 6F          1882**       			LD      L,A
0B3E33 4F          1883**  	    		LD      C,A
0B3E34 C9          1884**          		RET
0B3E35             1885**  ;
0B3E35 CD 4C 3E 0B 1886**  FCP:			CALL    FCP1
0B3E39 18 F0       1887**          		JR      FPZERO            ;PRESET FALSE
0B3E3B             1888**  ;
0B3E3B 79          1889**  FCP0:			LD      A,C
0B3E3C B8          1890**          		CP      B               ;COMPARE EXPONENTS
0B3E3D C0          1891**          		RET     NZ
0B3E3E             1892**  ICP0:
0B3E3E 52 ED 52    1893**  			SBC.S   HL,DE           ;COMP MANTISSA MSB
0B3E41 52 19       1894**          		ADD.S   HL,DE
0B3E43 C0          1895**          		RET     NZ
0B3E44 D9          1896**          		EXX
0B3E45 52 ED 52    1897**          		SBC.S   HL,DE           ;COMP MANTISSA LSB
0B3E48 52 19       1898**          		ADD.S   HL,DE
0B3E4A D9          1899**          		EXX
0B3E4B C9          1900**          		RET
0B3E4C             1901**  ;
0B3E4C 7C          1902**  FCP1:			LD      A,H
0B3E4D AA          1903**          		XOR     D
0B3E4E 7C          1904**          		LD      A,H
0B3E4F 17          1905**          		RLA
0B3E50 F8          1906**          		RET     M
0B3E51 30 E8       1907**          		JR      NC,FCP0
0B3E53 CD 3B 3E 0B 1908**          		CALL    FCP0
0B3E57 C8          1909**          		RET     Z               ;** V0.1 BUG FIX
0B3E58 3F          1910**          		CCF
0B3E59 C9          1911**          		RET
0B3E5A             1912**  ;
0B3E5A 7C          1913**  ICP1:			LD      A,H
0B3E5B AA          1914**          		XOR     D
0B3E5C F2 3E 3E 0B 1915**          		JP      P,ICP0
0B3E60 7C          1916**          		LD      A,H
0B3E61 17          1917**          		RLA
0B3E62 C9          1918**          		RET
0B3E63             1919**  ;
0B3E63             1920**  ; ADD - Integer add.
0B3E63             1921**  ; Carry, sign & zero flags valid on exit
0B3E63             1922**  ;     Destroys: H,L,H',L',F
0B3E63             1923**  ;
0B3E63 05          1924**  X10B:			DEC     B
0B3E64 0C          1925**          		INC     C
0B3E65 CD AC 3E 0B 1926**  X5:			CALL    COPY0
0B3E69 CD 9F 3E 0B 1927**          		CALL    D2C
0B3E6D CD 9F 3E 0B 1928**          		CALL    D2C
0B3E71 08          1929**          		EX      AF,AF'          ;SAVE CARRY
0B3E72 D9          1930**  ADD_:			EXX
0B3E73 52 19       1931**          		ADD.S   HL,DE
0B3E75 D9          1932**          		EXX
0B3E76 52 ED 5A    1933**          		ADC.S   HL,DE
0B3E79 C9          1934**          		RET
0B3E7A             1935**  ;
0B3E7A             1936**  ; SUB - Integer subtract.
0B3E7A             1937**  ; Carry, sign & zero flags valid on exit
0B3E7A             1938**  ;     Destroys: H,L,H',L',F
0B3E7A             1939**  ;
0B3E7A D9          1940**  SUB_:			EXX
0B3E7B B7          1941**          		OR      A
0B3E7C 52 ED 52    1942**          		SBC.S   HL,DE
0B3E7F D9          1943**          		EXX
0B3E80 52 ED 52    1944**          		SBC.S   HL,DE
0B3E83 C9          1945**          		RET
0B3E84             1946**  ;
0B3E84             1947**  ; X10 - unsigned integer * 10
0B3E84             1948**  ;    Inputs: HLH'L' initial value
0B3E84             1949**  ;   Outputs: DED'E' = initial HLH'L'
0B3E84             1950**  ;            Carry bit set if overflow
0B3E84             1951**  ;            If carry not set HLH'L'=result
0B3E84             1952**  ;  Destroys: D,E,H,L,D',E',H',L',F
0B3E84             1953**  ; X2 - Multiply HLH'L' by 2 as 32-bit integer.
0B3E84             1954**  ;     Carry set if MSB=1 before shift.
0B3E84             1955**  ;     Sign set if MSB=1 after shift.
0B3E84             1956**  ;     Destroys: H,L,H',L',F
0B3E84             1957**  ;
0B3E84 CD AC 3E 0B 1958**  X10:			CALL    COPY0           ;DED'E'=HLH'L'
0B3E88 CD 97 3E 0B 1959**          		CALL    X2
0B3E8C D8          1960**          		RET     C               ;TOO BIG
0B3E8D CD 97 3E 0B 1961**          		CALL    X2
0B3E91 D8          1962**          		RET     C
0B3E92 CD 72 3E 0B 1963**          		CALL    ADD_
0B3E96 D8          1964**          		RET     C
0B3E97 D9          1965**  X2:			EXX
0B3E98 52 29       1966**          		ADD.S   HL,HL
0B3E9A D9          1967**          		EXX
0B3E9B 52 ED 6A    1968**          		ADC.S   HL,HL
0B3E9E C9          1969**          		RET
0B3E9F             1970**  ;
0B3E9F             1971**  ; D2 - Divide HLH'L' by 2 as 32-bit integer.
0B3E9F             1972**  ;     Carry set if LSB=1 before shift.
0B3E9F             1973**  ;     Destroys: H,L,H',L',F
0B3E9F             1974**  ;
0B3E9F 0C          1975**  D2C:			INC     C
0B3EA0 CB 3C       1976**  D2:			SRL     H
0B3EA2 CB 1D       1977**          		RR      L
0B3EA4 D9          1978**          		EXX
0B3EA5 CB 1C       1979**          		RR      H
0B3EA7 CB 1D       1980**          		RR      L
0B3EA9 D9          1981**          		EXX
0B3EAA C9          1982**          		RET
0B3EAB             1983**  ;
0B3EAB             1984**  ; COPY - COPY HLH'L'C INTO DED'E'B
0B3EAB             1985**  ;   Destroys: B,C,D,E,H,L,D',E',H',L'
0B3EAB             1986**  ;
0B3EAB 41          1987**  COPY_:			LD      B,C
0B3EAC 54          1988**  COPY0:			LD      D,H
0B3EAD 5D          1989**          		LD      E,L
0B3EAE D9          1990**          		EXX
0B3EAF 54          1991**          		LD      D,H
0B3EB0 5D          1992**          		LD      E,L
0B3EB1 D9          1993**          		EXX
0B3EB2 C9          1994**          		RET
0B3EB3             1995**  ;
0B3EB3             1996**  ; SQUARE - PUSH X*X
0B3EB3             1997**  ; PUSH5 - PUSH HLH'L'C ONTO STACK.
0B3EB3             1998**  ;   Destroys: SP,IX
0B3EB3             1999**  ;
0B3EB3 CD AB 3E 0B 2000**  SQUARE:			CALL    COPY_
0B3EB7 CD 16 35 0B 2001**          		CALL    FMUL
0B3EBB DD E1       2002**  PUSH5:			POP     IX              ;RETURN ADDRESS
0B3EBD C5          2003**          		PUSH    BC
0B3EBE E5          2004**          		PUSH    HL
0B3EBF D9          2005**          		EXX
0B3EC0 E5          2006**          		PUSH    HL
0B3EC1 D9          2007**          		EXX
0B3EC2 DD E9       2008**          		JP      (IX)            ;"RETURN"
0B3EC4             2009**  ;
0B3EC4             2010**  ; POP5 - POP DED'E'B OFF STACK.
0B3EC4             2011**  ;   Destroys: A,B,D,E,D',E',SP,IX
0B3EC4             2012**  ;
0B3EC4 DD E1       2013**  POP5:			POP     IX              ;RETURN ADDRESS
0B3EC6 D9          2014**          		EXX
0B3EC7 D1          2015**          		POP     DE
0B3EC8 D9          2016**          		EXX
0B3EC9 D1          2017**          		POP     DE
0B3ECA 79          2018**          		LD      A,C
0B3ECB C1          2019**          		POP     BC
0B3ECC 41          2020**          		LD      B,C
0B3ECD 4F          2021**          		LD      C,A
0B3ECE DD E9       2022**          		JP      (IX)            ;"RETURN"
0B3ED0             2023**  ;
0B3ED0             2024**  ; RATIO - Calculate (X-1)/(X+1)
0B3ED0             2025**  ;     Inputs: X in HLH'L'C
0B3ED0             2026**  ;    Outputs: (X-1)/(X+1) in HLH'L'C
0B3ED0             2027**  ;   Destroys: Everything except IY,SP,I
0B3ED0             2028**  ;
0B3ED0 CD BB 3E 0B 2029**  RATIO:			CALL    PUSH5           ;SAVE X
0B3ED4 CD 43 38 0B 2030**          		CALL    DONE
0B3ED8 CD 04 34 0B 2031**          		CALL    FADD
0B3EDC CD C4 3E 0B 2032**          		CALL    POP5            ;RESTORE X
0B3EE0 CD BB 3E 0B 2033**          		CALL    PUSH5           ;SAVE X+1
0B3EE4 CD DF 3D 0B 2034**          		CALL    SWAP_FP
0B3EE8 CD 43 38 0B 2035**          		CALL    DONE
0B3EEC CD EB 33 0B 2036**          		CALL    FSUB
0B3EF0 CD C4 3E 0B 2037**          		CALL    POP5            ;RESTORE X+1
0B3EF4 C3 6D 34 0B 2038**          		JP      FDIV
0B3EF8             2039**  ;
0B3EF8             2040**  ; POLY - Evaluate a polynomial.
0B3EF8             2041**  ;     Inputs: X in HLH'L'C and also stored at (SP+2)
0B3EF8             2042**  ;             Polynomial coefficients follow call.
0B3EF8             2043**  ;    Outputs: Result in HLH'L'C
0B3EF8             2044**  ;   Destroys: Everything except IY,SP,I
0B3EF8             2045**  ; Routine terminates on finding a coefficient >=1.
0B3EF8             2046**  ; Note: The last coefficient is EXECUTED on return
0B3EF8             2047**  ;       so must contain only innocuous bytes!
0B3EF8             2048**  ;
0B3EF8 DD 21 03 00 2049**  POLY:			LD      IX, 3				; Advance the SP to the return address
       00          
0B3EFD DD 39       2050**          		ADD     IX, SP
0B3EFF DD E3       2051**          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B3F01             2052**  ;
0B3F01 CD D7 3B 0B 2053**          		CALL    DLOAD5          		; Load the first coefficient from (IX)
0B3F05 CD 16 35 0B 2054**  POLY1:			CALL    FMUL
0B3F09 11 05 00 00 2055**          		LD      DE, 5				; Skip to the next coefficient
0B3F0D DD 19       2056**          		ADD     IX, DE
0B3F0F CD D7 3B 0B 2057**          		CALL    DLOAD5          		; Load the second coefficient from (IX)
0B3F13 DD E3       2058**          		EX      (SP), IX			; Restore the SP just in case we need to return
0B3F15 04          2059**          		INC     B
0B3F16 05          2060**          		DEC     B               		; Test B for end byte (80h)
0B3F17 FA 04 34 0B 2061**          		JP      M,FADD				; Yes, so add and return
0B3F1B CD 04 34 0B 2062**          		CALL    FADD				; No, so add
0B3F1F CD E9 3B 0B 2063**          		CALL    DLOAD5_SPL			; Load X from SP
0B3F23 DD E3       2064**          		EX      (SP), IX			; IX: Points to the inline list of coefficients
0B3F25 18 DE       2065**          		JR      POLY1				; And loop
0B3F27             2066**  ;
0B3F27             2067**  ; POWR10 - Calculate power of ten.
0B3F27             2068**  ;     Inputs: A=power of 10 required (A<128)
0B3F27             2069**  ;             A=binary exponent to be exceeded (A>=128)
0B3F27             2070**  ;    Outputs: DED'E'B = result
0B3F27             2071**  ;             A = actual power of ten returned
0B3F27             2072**  ;   Destroys: A,B,D,E,A',D',E',F,F'
0B3F27             2073**  ;
0B3F27 3C          2074**  POWR10:			INC     A
0B3F28 08          2075**          		EX      AF,AF'
0B3F29 E5          2076**          		PUSH    HL
0B3F2A D9          2077**          		EXX
0B3F2B E5          2078**          		PUSH    HL
0B3F2C D9          2079**          		EXX
0B3F2D CD 43 38 0B 2080**          		CALL    DONE
0B3F31 CD DF 3D 0B 2081**          		CALL    SWAP_FP
0B3F35 AF          2082**          		XOR     A
0B3F36 08          2083**  POWR11:			EX      AF,AF'
0B3F37 3D          2084**          		DEC     A
0B3F38 28 26       2085**          		JR      Z,POWR14        ;EXIT TYPE 1
0B3F3A F2 42 3F 0B 2086**          		JP      P,POWR13
0B3F3E B9          2087**          		CP      C
0B3F3F 38 1F       2088**          		JR      C,POWR14        ;EXIT TYPE 2
0B3F41 3C          2089**          		INC     A
0B3F42 08          2090**  POWR13:			EX      AF,AF'
0B3F43 3C          2091**          		INC     A
0B3F44 CB FC       2092**          		SET     7,H
0B3F46 CD 65 3E 0B 2093**          		CALL    X5
0B3F4A 30 06       2094**          		JR      NC,POWR12
0B3F4C 08          2095**          		EX      AF,AF'
0B3F4D CD 9F 3E 0B 2096**          		CALL    D2C
0B3F51 08          2097**          		EX      AF,AF'
0B3F52 08          2098**  POWR12:			EX      AF,AF'
0B3F53 DC C7 3D 0B 2099**          		CALL    C,ADD1          ;ROUND UP
0B3F57 0C          2100**          		INC     C
0B3F58 FA 36 3F 0B 2101**          		JP      M,POWR11
0B3F5C C3 F6 3D 0B 2102**          		JP      OFLOW
0B3F60 CD DF 3D 0B 2103**  POWR14:			CALL    SWAP_FP
0B3F64 CB BA       2104**          		RES     7,D
0B3F66 D9          2105**          		EXX
0B3F67 E1          2106**          		POP     HL
0B3F68 D9          2107**          		EXX
0B3F69 E1          2108**          		POP     HL
0B3F6A 08          2109**          		EX      AF,AF'
0B3F6B C9          2110**          		RET
0B3F6C             2111**  ;
0B3F6C             2112**  ; DIVA, DIVB - DIVISION PRIMITIVE.
0B3F6C             2113**  ;     Function: D'E'DE = H'L'HLD'E'DE / B'C'BC
0B3F6C             2114**  ;               Remainder in H'L'HL
0B3F6C             2115**  ;     Inputs: A = loop counter (normally -32)
0B3F6C             2116**  ;     Destroys: A,D,E,H,L,D',E',H',L',F
0B3F6C             2117**  ;
0B3F6C B7          2118**  DIVA:			OR      A               ;CLEAR CARRY
0B3F6D             2119**  DIV0:
0B3F6D 52 ED 42    2120**  			SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B3F70 D9          2121**          		EXX
0B3F71 52 ED 42    2122**          		SBC.S   HL,BC
0B3F74 D9          2123**          		EXX
0B3F75 30 07       2124**          		JR      NC,DIV1
0B3F77 52 09       2125**          		ADD.S   HL,BC           ;DIVIDEND+DIVISOR
0B3F79 D9          2126**          		EXX
0B3F7A 52 ED 4A    2127**          		ADC.S   HL,BC
0B3F7D D9          2128**          		EXX
0B3F7E 3F          2129**  DIV1:			CCF
0B3F7F CB 13       2130**  DIVC:			RL      E               ;SHIFT RESULT INTO DE
0B3F81 CB 12       2131**          		RL      D
0B3F83 D9          2132**          		EXX
0B3F84 CB 13       2133**          		RL      E
0B3F86 CB 12       2134**          		RL      D
0B3F88 D9          2135**          		EXX
0B3F89 3C          2136**          		INC     A
0B3F8A F0          2137**          		RET     P
0B3F8B             2138**  DIVB:
0B3F8B 52 ED 6A    2139**  			ADC.S   HL,HL           ;DIVIDEND*2
0B3F8E D9          2140**          		EXX
0B3F8F 52 ED 6A    2141**          		ADC.S   HL,HL
0B3F92 D9          2142**          		EXX
0B3F93 30 D8       2143**          		JR      NC,DIV0
0B3F95 B7          2144**          		OR      A
0B3F96 52 ED 42    2145**          		SBC.S   HL,BC           ;DIVIDEND-DIVISOR
0B3F99 D9          2146**          		EXX
0B3F9A 52 ED 42    2147**          		SBC.S   HL,BC
0B3F9D D9          2148**          		EXX
0B3F9E 37          2149**          		SCF
0B3F9F C3 7F 3F 0B 2150**          		JP      DIVC
0B3FA3             2151**  ;
0B3FA3             2152**  ;MULA, MULB - MULTIPLICATION PRIMITIVE.
0B3FA3             2153**  ;    Function: H'L'HLD'E'DE = B'C'BC * D'E'DE
0B3FA3             2154**  ;    Inputs: A = loop counter (usually -32)
0B3FA3             2155**  ;            H'L'HL = 0
0B3FA3             2156**  ;    Destroys: D,E,H,L,D',E',H',L',A,F
0B3FA3             2157**  ;
0B3FA3 B7          2158**  MULA:			OR      A               ;CLEAR CARRY
0B3FA4 D9          2159**  MUL0:			EXX
0B3FA5 CB 1A       2160**          		RR      D               ;MULTIPLIER/2
0B3FA7 CB 1B       2161**          		RR      E
0B3FA9 D9          2162**          		EXX
0B3FAA CB 1A       2163**          		RR      D
0B3FAC CB 1B       2164**          		RR      E
0B3FAE 30 07       2165**          		JR      NC,MUL1
0B3FB0 52 09       2166**          		ADD.S   HL,BC           ;ADD IN MULTIPLICAND
0B3FB2 D9          2167**          		EXX
0B3FB3 52 ED 4A    2168**          		ADC.S   HL,BC
0B3FB6 D9          2169**          		EXX
0B3FB7 3C          2170**  MUL1:			INC     A
0B3FB8 F0          2171**          		RET     P
0B3FB9 D9          2172**  MULB:			EXX
0B3FBA CB 1C       2173**          		RR      H               ;PRODUCT/2
0B3FBC CB 1D       2174**          		RR      L
0B3FBE D9          2175**          		EXX
0B3FBF CB 1C       2176**          		RR      H
0B3FC1 CB 1D       2177**          		RR      L
0B3FC3 C3 A4 3F 0B 2178**          		JP      MUL0
0B3FC7             2179**  ;
0B3FC7             2180**  ; SQRA, SQRB - SQUARE ROOT PRIMITIVES
0B3FC7             2181**  ;     Function: B'C'BC = SQR (D'E'DE)
0B3FC7             2182**  ;     Inputs: A = loop counter (normally -31)
0B3FC7             2183**  ;             B'C'BCH'L'HL initialised to 0
0B3FC7             2184**  ;   Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',F
0B3FC7             2185**  ;
0B3FC7             2186**  SQR1:
0B3FC7 52 ED 42    2187**  			SBC.S   HL,BC
0B3FCA D9          2188**          		EXX
0B3FCB 52 ED 42    2189**          		SBC.S   HL,BC
0B3FCE D9          2190**          		EXX
0B3FCF 0C          2191**          		INC     C
0B3FD0 30 09       2192**          		JR      NC,SQR2
0B3FD2 0D          2193**          		DEC     C
0B3FD3 52 09       2194**          		ADD.S   HL,BC
0B3FD5 D9          2195**          		EXX
0B3FD6 52 ED 4A    2196**          		ADC.S   HL,BC
0B3FD9 D9          2197**          		EXX
0B3FDA 0D          2198**          		DEC     C
0B3FDB 3C          2199**  SQR2:			INC     A
0B3FDC F0          2200**          		RET     P
0B3FDD CB 21       2201**  SQRA:			SLA     C
0B3FDF CB 10       2202**          		RL      B
0B3FE1 D9          2203**          		EXX
0B3FE2 CB 11       2204**          		RL      C
0B3FE4 CB 10       2205**          		RL      B
0B3FE6 D9          2206**          		EXX
0B3FE7 0C          2207**          		INC     C
0B3FE8 CB 23       2208**          		SLA     E
0B3FEA CB 12       2209**          		RL      D
0B3FEC D9          2210**          		EXX
0B3FED CB 13       2211**          		RL      E
0B3FEF CB 12       2212**          		RL      D
0B3FF1 D9          2213**          		EXX
0B3FF2 52 ED 6A    2214**          		ADC.S   HL,HL
0B3FF5 D9          2215**          		EXX
0B3FF6 52 ED 6A    2216**          		ADC.S   HL,HL
0B3FF9 D9          2217**          		EXX
0B3FFA CB 23       2218**          		SLA     E
0B3FFC CB 12       2219**          		RL      D
0B3FFE D9          2220**          		EXX
0B3FFF CB 13       2221**          		RL      E
0B4001 CB 12       2222**          		RL      D
0B4003 D9          2223**          		EXX
0B4004 52 ED 6A    2224**          		ADC.S   HL,HL
0B4007 D9          2225**          		EXX
0B4008 52 ED 6A    2226**          		ADC.S   HL,HL
0B400B D9          2227**          		EXX
0B400C D2 C7 3F 0B 2228**          		JP      NC,SQR1
0B4010 B7          2229**  SQR3:			OR      A
0B4011 52 ED 42    2230**          		SBC.S   HL,BC
0B4014 D9          2231**          		EXX
0B4015 52 ED 42    2232**          		SBC.S   HL,BC
0B4018 D9          2233**          		EXX
0B4019 0C          2234**          		INC     C
0B401A C3 DB 3F 0B 2235**          		JP      SQR2
0B401E             2236**  ;
0B401E             2237**  SQRB:
0B401E 52 29       2238**  			ADD.S   HL,HL
0B4020 D9          2239**          		EXX
0B4021 52 ED 6A    2240**          		ADC.S   HL,HL
0B4024 D9          2241**          		EXX
0B4025 38 E9       2242**          		JR      C,SQR3
0B4027 3C          2243**          		INC     A
0B4028 0C          2244**          		INC     C
0B4029 52 ED 42    2245**          		SBC.S   HL,BC
0B402C D9          2246**          		EXX
0B402D 52 ED 42    2247**          		SBC.S   HL,BC
0B4030 D9          2248**          		EXX
0B4031 D0          2249**          		RET     NC
0B4032 52 09       2250**          		ADD.S   HL,BC
0B4034 D9          2251**          		EXX
0B4035 52 ED 4A    2252**          		ADC.S   HL,BC
0B4038 D9          2253**          		EXX
0B4039 0D          2254**          		DEC     C
0B403A C9          2255**          		RET
0B403B             2256**  ;
0B403B DD 7E 00    2257**  DIGITQ:			LD      A,(IX)
0B403E FE 3A       2258**          		CP      '9'+1
0B4040 3F          2259**          		CCF
0B4041 D8          2260**          		RET     C
0B4042 FE 30       2261**          		CP      '0'
0B4044 C9          2262**          		RET
0B4045             2263**  ;
0B4045 DD 7E 00    2264**  SIGNQ:			LD      A,(IX)
0B4048 DD 23       2265**          		INC     IX
0B404A FE 20       2266**          		CP      ' '
0B404C 28 F7       2267**          		JR      Z,SIGNQ
0B404E FE 2B       2268**          		CP      '+'
0B4050 C8          2269**          		RET     Z
0B4051 FE 2D       2270**          		CP      '-'
0B4053 C8          2271**          		RET     Z
0B4054 DD 2B       2272**          		DEC     IX
0B4056             2273**  
0B4056             2274**  				; call dumpRegistersHex
0B4056             2275**  
0B4056 C9          2276**          		RET
0B4057             0006*       include "basic/snippets.asm"
0B4057             0001**  
0B4057             0002**  ; from exec.asm
0B4057             0003**  ; Check whether the stack is full
0B4057             0004**  ;
0B4057 E5          0005**  CHECK:			PUSH    HL
0B4058 C5          0006**  			PUSH	BC
0B4059 2A 1D 29 0B 0007**  			LD      HL,(FREE)		; HL: Address of first free space byte
0B405D 01 00 01 00 0008**  			LD	BC,100h			; BC: One page of memory
0B4061 09          0009**  			ADD	HL,BC			; Add a page to FREE
0B4062 ED 72       0010**  			SBC     HL,SP			; And subtract the current SP
0B4064 C1          0011**  			POP	BC
0B4065 E1          0012**  			POP     HL
0B4066 D8          0013**  			RET     C			; The SP is not in the same page, so just return
0B4067             0014**  			; XOR     A			; Otherwise
0B4067             0015**  			; JP      ERROR_			; Throw error "No room"
0B4067             0016**  ;
0B4067 01 00 00 00 0017**  STORS3:			LD	BC,0
0B406B 4B          0018**  			LD      C,E			; BC: String length
0B406C DD E5       0019**  			PUSH    IX
0B406E D1          0020**  			POP     DE			; DE: Destination
0B406F AF          0021**  			XOR     A			; Check if string length is 0
0B4070 B9          0022**  			CP      C
0B4071 28 02       0023**  			JR      Z,STORS5		; Yes, so don't copy
0B4073 ED B0       0024**  			LDIR
0B4075 3E 0D       0025**  STORS5:			LD      A,CR			; Finally add the terminator
0B4077 12          0026**  			LD      (DE),A
0B4078 C9          0027**  			RET
0B4079             0028**  
0B4079             0029**  
0B4079             0030**  ; from main.asm
0B4079             0031**  
0B4079             0032**  ; PUTVAR - CREATE VARIABLE AND INITIALISE TO ZERO.
0B4079             0033**  ;   Inputs: HL, IY as returned from GETVAR (NZ).
0B4079             0034**  ;  Outputs: As GETVAR.
0B4079             0035**  ; Destroys: everything
0B4079             0036**  ;
0B4079 CD 47 41 0B 0037**  PUTVAR:			CALL    CREATE			; Create the variable
0B407D FD 7E 00    0038**  			LD      A,(IY)			; Fetch the next character
0B4080 FE 28       0039**  			CP      '('			; Check for bad use of array
0B4082 20 6C       0040**  			JR      NZ,GETVZ        	; It's fine, so set the exit conditions
0B4084 3E 0E       0041**  ARRAY:			LD      A,14            	; Otherwise Error: 'Array'
0B4086             0042**  ERROR3:
0B4086             0043**              ; JP      ERROR_
0B4086             0044**  ;
0B4086             0045**  ;GETVAR - GET LOCATION OF VARIABLE, RETURN IN HL & IX
0B4086             0046**  ;   Inputs: IY addresses first character.
0B4086             0047**  ;  Outputs: Carry set and NZ if illegal character.
0B4086             0048**  ;           Z-flag set if variable found, then:
0B4086             0049**  ;            A = variable type (0,4,5,128 or 129)
0B4086             0050**  ;            HL = IX = variable pointer.
0B4086             0051**  ;            IY updated
0B4086             0052**  ;           If Z-flag & carry reset, then:
0B4086             0053**  ;            HL, IY set for subsequent PUTVAR call.
0B4086             0054**  ; Destroys: everything
0B4086             0055**  ;
0B4086 FD 7E 00    0056**  GETVAR:			LD      A,(IY)			; Get the first character
0B4089 FE 24       0057**  			CP      '$'			; Is it a string?
0B408B 28 69       0058**  			JR      Z,GETV4			; Yes, so branch here
0B408D FE 21       0059**  			CP      '!'			; Is it indirection (32-bit)?
0B408F 28 69       0060**  			JR      Z,GETV5			; Yes, so branch here
0B4091 FE 3F       0061**  			CP      '?'			; Is it indirection (8-bit)?
0B4093 28 69       0062**  			JR      Z,GETV6			; Yes, so branch here
0B4095             0063**  ;
0B4095 CD 92 41 0B 0064**  			CALL    LOCATE			; Locate the variable
0B4099 C0          0065**  			RET     NZ			; And exit here if not found
0B409A             0066**  ;
0B409A             0067**  ; At this point:
0B409A             0068**  ;  HL: Address of variable in memory
0B409A             0069**  ;   D: Variable type (4 = Integer, 5 = Floating point, 129 = String)
0B409A             0070**  ;
0B409A FD 7E 00    0071**  			LD      A,(IY)			; Further checks
0B409D FE 28       0072**  			CP      '('             	; Is it an array?
0B409F 20 47       0073**  			JR      NZ,GETVX        	; No, so exit
0B40A1             0074**  ;
0B40A1             0075**  ; We are processing an array at this point
0B40A1             0076**  ;
0B40A1 D5          0077**  			PUSH    DE              	; Save the variable type (in D)
0B40A2 7E          0078**  			LD      A,(HL)          	; Fetch the number of dimensions
0B40A3 B7          0079**  			OR      A
0B40A4 28 DE       0080**  			JR      Z,ARRAY			; If there are none, then Error: 'Array'
0B40A6 23          0081**  			INC     HL			;
0B40A7 11 00 00 00 0082**  			LD      DE,0            	; Accumulator
0B40AB F5          0083**  			PUSH    AF
0B40AC FD 23       0084**  			INC     IY              	; Skip "("
0B40AE 18 05       0085**  			JR      GETV3
0B40B0             0086**  ;
0B40B0 F5          0087**  GETV2:			PUSH    AF
0B40B1 CD 00 32 0B 0088**  			CALL    COMMA
0B40B5 E5          0089**  GETV3:			PUSH    HL
0B40B6 D5          0090**  			PUSH    DE
0B40B7 CD FD 2B 0B 0091**  			CALL    EXPRI			; Get the subscript
0B40BB D9          0092**  			EXX
0B40BC D1          0093**  			POP     DE
0B40BD E3          0094**  			EX      (SP),HL
0B40BE 4E          0095**  			LD      C,(HL)
0B40BF 23          0096**  			INC     HL
0B40C0 46          0097**  			LD      B,(HL)
0B40C1 23          0098**  			INC     HL
0B40C2 E3          0099**  			EX      (SP),HL
0B40C3 EB          0100**  			EX      DE,HL
0B40C4 D5          0101**  			PUSH    DE
0B40C5 CD 28 42 0B 0102**  			CALL    MUL16			; HL=HL*BC
0B40C9 D1          0103**  			POP     DE
0B40CA 19          0104**  			ADD     HL,DE
0B40CB EB          0105**  			EX      DE,HL
0B40CC B7          0106**  			OR      A
0B40CD ED 42       0107**  			SBC     HL,BC
0B40CF 3E 0F       0108**  			LD      A,15
0B40D1 30 B3       0109**  			JR      NC,ERROR3		; Throw a "Subscript" error
0B40D3 E1          0110**  			POP     HL
0B40D4 F1          0111**  			POP     AF
0B40D5 3D          0112**  			DEC     A               	; Dimension counter
0B40D6 20 D8       0113**  			JR      NZ,GETV2
0B40D8 CD 0D 32 0B 0114**  			CALL    BRAKET          	; Check for closing bracket
0B40DC F1          0115**  			POP     AF              	; Restore the type
0B40DD E5          0116**  			PUSH    HL
0B40DE CD 3C 42 0B 0117**  			CALL    X4OR5           	; DE=DE*n
0B40E2 E1          0118**  			POP     HL
0B40E3 19          0119**  			ADD     HL,DE
0B40E4 57          0120**  			LD      D,A             	; The type
0B40E5 FD 7E 00    0121**  			LD      A,(IY)
0B40E8 FE 3F       0122**  GETVX:			CP      '?'
0B40EA 28 1E       0123**  			JR      Z,GETV9
0B40EC FE 21       0124**  			CP      '!'
0B40EE 28 16       0125**  			JR      Z,GETV8
0B40F0 E5          0126**  GETVZ:			PUSH    HL              	; Set exit conditions
0B40F1 DD E1       0127**  			POP     IX
0B40F3 7A          0128**  			LD      A,D
0B40F4 BF          0129**  			CP      A
0B40F5 C9          0130**  			RET
0B40F6             0131**  ;
0B40F6             0132**  ; Process strings, unary & binary indirection:
0B40F6             0133**  ;
0B40F6 3E 80       0134**  GETV4:			LD      A,128           	; Static strings
0B40F8 18 05       0135**  			JR      GETV7
0B40FA             0136**  ;
0B40FA 3E 04       0137**  GETV5:			LD      A,4             	; Unary 32-bit indirection
0B40FC 18 01       0138**  			JR      GETV7
0B40FE             0139**  ;
0B40FE AF          0140**  GETV6:			XOR     A               	; Unary 8-bit indirection
0B40FF             0141**  ;
0B40FF 21 00 00 00 0142**  GETV7:			LD      HL,0
0B4103 F5          0143**  			PUSH    AF
0B4104 18 24       0144**  			JR      GETV0
0B4106             0145**  ;
0B4106 06 04       0146**  GETV8:			LD      B,4             	; Binary 32-bt indirection
0B4108 18 02       0147**  			JR      GETVA
0B410A             0148**  ;
0B410A 06 00       0149**  GETV9:			LD      B,0             	; Binary 8-bit indirection
0B410C             0150**  ;
0B410C E5          0151**  GETVA:			PUSH    HL
0B410D DD E1       0152**  			POP     IX
0B410F 7A          0153**  			LD      A,D            		; Fetch the variable type
0B4110 FE 81       0154**  			CP      129			; Is it a string?
0B4112 C8          0155**  			RET     Z               	; Yes, so exit here
0B4113 C5          0156**  			PUSH    BC
0B4114 CD F9 2C 0B 0157**  			CALL    LOADN           	; Left operand of the binary indirection (var?index or var!index)
0B4118 CD A0 2E 0B 0158**  			CALL    SFIX
0B411C 7D          0159**  			LD	A,L
0B411D D9          0160**  			EXX
0B411E 22 4A 29 0B 0161**  			LD	(R0+0),HL
0B4122 32 4C 29 0B 0162**  			LD	(R0+2),A
0B4126 2A 4A 29 0B 0163**  			LD	HL,(R0)			; HL: 24-bit address of the variable in memory
0B412A             0164**  ;
0B412A E5          0165**  GETV0:			PUSH    HL			; HL will be 0 for a unary indirection, or the address of the variable for a binary indirection
0B412B FD 23       0166**  			INC     IY
0B412D CD 18 2C 0B 0167**  			CALL    ITEMI
0B4131 7D          0168**  			LD	A,L			;  A: The MSB of the address
0B4132 D9          0169**  			EXX
0B4133 22 4A 29 0B 0170**  			LD	(R0+0),HL		; HL: The LSW of the address
0B4137 32 4C 29 0B 0171**  			LD	(R0+2),A		; R0: L'HL or the 24-bit address
0B413B D1          0172**  			POP     DE
0B413C F1          0173**  			POP     AF
0B413D 2A 4A 29 0B 0174**  			LD	HL,(R0)			; HL: L'HL
0B4141 19          0175**  			ADD     HL,DE
0B4142 E5          0176**  			PUSH    HL
0B4143 DD E1       0177**  			POP     IX
0B4145 BF          0178**  			CP      A
0B4146 C9          0179**  			RET
0B4147             0180**  
0B4147             0181**  
0B4147             0182**  ; CREATE - CREATE NEW ENTRY, INITIALISE TO ZERO.
0B4147             0183**  ;   Inputs: HL, IY as returned from LOCATE (NZ).
0B4147             0184**  ;  Outputs: As LOCATE, GETDEF.
0B4147             0185**  ; Destroys: As LOCATE, GETDEF.
0B4147             0186**  ;
0B4147 AF          0187**  CREATE:			XOR     A
0B4148 ED 5B 1D 29 0188**  			LD      DE,(FREE)		; Get the last byte of available RAM
       0B          
0B414D ED 1F       0189**  			LD	(HL), DE		; Store
0B414F EB          0190**  			EX      DE,HL
0B4150 77          0191**  			LD      (HL),A			; Clear the link of the new entity
0B4151 23          0192**  			INC     HL
0B4152 77          0193**  			LD      (HL),A
0B4153 23          0194**  			INC     HL
0B4154 77          0195**  			LD      (HL),A
0B4155 23          0196**  			INC     HL
0B4156 FD 23       0197**  LOC7:			INC     IY
0B4158 CD 49 42 0B 0198**  			CALL    RANGE           	; END OF VARIABLE?
0B415C 38 15       0199**  			JR      C,LOC8
0B415E 77          0200**  			LD      (HL),A
0B415F 23          0201**  			INC     HL
0B4160 CD 55 42 0B 0202**  			CALL    RANGE1
0B4164 30 F0       0203**  			JR      NC,LOC7
0B4166 FE 28       0204**  			CP      '('
0B4168 28 09       0205**  			JR      Z,LOC8
0B416A FD 7E 01    0206**  			LD      A,(IY+1)
0B416D FE 28       0207**  			CP      '('
0B416F 28 E5       0208**  			JR      Z,LOC7
0B4171 FD 23       0209**  			INC     IY
0B4173 36 00       0210**  LOC8:			LD      (HL),0          	; TERMINATOR
0B4175 23          0211**  			INC     HL
0B4176 E5          0212**  			PUSH    HL
0B4177 CD 16 42 0B 0213**  			CALL    TYPE_			; Get the variable type in D
0B417B 3E 04       0214**  			LD      A,4			; If it is an integer then it takes up 4 bytes
0B417D BA          0215**  			CP      D
0B417E 28 01       0216**  			JR      Z,LOC9			; So skip the next bit
0B4180 3C          0217**  			INC     A			; Strings and floats take up 5 bytes (NB: Strings take up 4 in BBC BASIC for Z80)
0B4181 36 00       0218**  LOC9:			LD      (HL),0          	; Initialise the memory to zero
0B4183 23          0219**  			INC     HL
0B4184 3D          0220**  			DEC     A
0B4185 20 FA       0221**  			JR      NZ,LOC9
0B4187 22 1D 29 0B 0222**  			LD      (FREE),HL		; Adjust the stack
0B418B CD 57 40 0B 0223**  			CALL    CHECK			; Check whether we are out of space
0B418F E1          0224**  			POP     HL
0B4190 AF          0225**  			XOR     A
0B4191 C9          0226**  			RET
0B4192             0227**  
0B4192             0228**  
0B4192             0229**  ; LOCATE - Try to locate variable name in static or dynamic variables.
0B4192             0230**  ; If illegal first character return carry, non-zero.
0B4192             0231**  ; If found, return no-carry, zero.
0B4192             0232**  ; If not found, return no-carry, non-zero.
0B4192             0233**  ;   Inputs: IY=Addresses first character of name.
0B4192             0234**  ;            A=(IY)
0B4192             0235**  ;  Outputs:  F=Z set if found, then:
0B4192             0236**  ;           IY=addresses terminator
0B4192             0237**  ;           HL=addresses location of variable
0B4192             0238**  ;            D=type of variable: 4 = integer
0B4192             0239**  ;                                5 = floating point
0B4192             0240**  ;                              129 = string
0B4192             0241**  ; Destroys: A,D,E,H,L,IY,F
0B4192             0242**  ;
0B4192             0243**  ; Variable names can start with any letter of the alphabet (upper or lower case), underscore (_), or the grave accent (`)
0B4192             0244**  ; They can contain any alphanumeric character and underscore (_)
0B4192             0245**  ; String variables are postfixed with the dollar ($) character
0B4192             0246**  ; Integer variables are postfixed with the percent (%) character
0B4192             0247**  ; Static integer variables are named @%, A% to Z%
0B4192             0248**  ; All other variables are dynamic
0B4192             0249**  ;
0B4192 D6 40       0250**  LOCATE:			SUB     '@'			; Check for valid range
0B4194 D8          0251**  			RET     C			; First character not "@", "A" to "Z" or "a" to "z", so not a variable
0B4195 21 00 00 00 0252**  			LD      HL, 0			; Clear HL
0B4199 FE 1B       0253**  			CP      'Z'-'@'+1		; Check for static ("@", "A" to "Z"); if it is not static...
0B419B 30 1E       0254**  			JR      NC,LOC0         	; Then branch here
0B419D 6F          0255**  			LD	L, A			; HL = A
0B419E FD 7E 01    0256**  			LD      A,(IY+1)        	; Check the 2nd character
0B41A1 FE 25       0257**  			CP      '%'			; If not "%" then it is not static...
0B41A3 20 21       0258**  			JR      NZ,LOC1         	; Branch here
0B41A5 FD 7E 02    0259**  			LD      A,(IY+2)		; Check the 3rd character
0B41A8 FE 28       0260**  			CP      '('			; If it is "(" (array) then it is not static...
0B41AA 28 1A       0261**  			JR      Z,LOC1          	; Branch here
0B41AC             0262**  ;
0B41AC             0263**  ; At this point we're dealing with a static variable
0B41AC             0264**  ;
0B41AC 29          0265**  			ADD     HL,HL			; HL: Variable index * 4
0B41AD 29          0266**  			ADD	HL,HL
0B41AE 11 00 28 0B 0267**  			LD      DE,STAVAR       	; The static variable area in memory
0B41B2 19          0268**  			ADD     HL,DE			; HL: The address of the static variable
0B41B3 FD 23       0269**  			INC     IY			; Skip the program pointer past the static variable name
0B41B5 FD 23       0270**  			INC     IY
0B41B7 16 04       0271**  			LD      D,4             	; Set the type to be integer
0B41B9 AF          0272**  			XOR     A			; Set the Z flag
0B41BA C9          0273**  			RET
0B41BB             0274**  ;
0B41BB             0275**  ; At this point it's potentially a dynamic variable, just need to do a few more checks
0B41BB             0276**  ;
0B41BB FE 1F       0277**  LOC0:			CP      '_'-'@'			; Check the first character is in
0B41BD D8          0278**  			RET     C			; the range "_" to
0B41BE FE 3B       0279**  			CP      'z'-'@'+1		; "z" (lowercase characters only)
0B41C0 3F          0280**  			CCF				; If it is not in range then
0B41C1 3D          0281**  			DEC     A               	; Set NZ flag and
0B41C2 D8          0282**  			RET     C			; Exit here
0B41C3 D6 03       0283**  			SUB     3			; This brings it in the range of 27 upwards (need to confirm)
0B41C5 6F          0284**  			LD	L, A			; HL = A
0B41C6             0285**  ;
0B41C6             0286**  ; Yes, it's definitely a dynamic variable at this point...
0B41C6             0287**  ;
0B41C6 7D          0288**  LOC1:			LD	A, L			; Fetch variable index
0B41C7 87          0289**  			ADD	A, A			; x 2
0B41C8 85          0290**  			ADD	A, L			; x 3
0B41C9 D6 03       0291**  			SUB	3			; Subtract 2 TODO: Should be 3
0B41CB 6F          0292**  			LD	L, A
0B41CC 11 6C 28 0B 0293**  			LD      DE, DYNVAR       	; The dynamic variable storage
0B41D0 D8          0294**  			RET	C			; Bounds check to trap for variable '@'
0B41D1 19          0295**  			ADD     HL, DE			; HL: Address of first entry
0B41D2             0296**  ;
0B41D2             0297**  ; Loop through the linked list of variables to find a match
0B41D2             0298**  ;
0B41D2 ED 17       0299**  LOC2:			LD	DE, (HL)		; Fetch the original pointer
0B41D4 E5          0300**  			PUSH	HL			; Need to preserve HL for LOC6
0B41D5 AF          0301**  			XOR	A			; Reset carry flag
0B41D6 ED 62       0302**  			SBC	HL, HL			; Set HL to 0
0B41D8 ED 52       0303**  			SBC	HL, DE			; Compare with 0
0B41DA E1          0304**  			POP	HL			; Restore the original pointer
0B41DB 28 49       0305**  			JR	Z, LOC6			; If the pointer in DE is zero, the variable is undefined at this point
0B41DD             0306**  			; LD	HL, DE			; Make a copy of this pointer in HL
0B41DD D5          0307**  			push de ; HOW DID THE ABOVE EVEN ASSEMBLE IN THE ORIGINAL?!
0B41DE E1          0308**  			pop hl	; Make a copy of this pointer in HL
0B41DF 23          0309**  			INC     HL              	; Skip the link (24-bits)
0B41E0 23          0310**  			INC     HL
0B41E1 23          0311**  			INC	HL			; HL: Address of the variable name in DYNVARS
0B41E2 FD E5       0312**  			PUSH    IY			; IY: Address of the variable name in the program
0B41E4             0313**  ;
0B41E4 7E          0314**  LOC3:			LD      A,(HL)         		; Compare
0B41E5 23          0315**  			INC     HL
0B41E6 FD 23       0316**  			INC     IY
0B41E8 FD BE 00    0317**  			CP      (IY)
0B41EB 28 F7       0318**  			JR      Z, LOC3			; Keep looping whilst we've got a match...
0B41ED B7          0319**  			OR      A               	; Have we hit a terminator?
0B41EE 28 07       0320**  			JR      Z,LOC5          	; Yes, so maybe we've found a variable
0B41F0             0321**  ;
0B41F0 FD E1       0322**  LOC4:			POP     IY			; Restore the pointer in the program
0B41F2 EB          0323**  			EX      DE, HL			; HL: New pointer in DYNVARS
0B41F3 C3 D2 41 0B 0324**  			JP      LOC2            	; Loop round and try again
0B41F7             0325**  ;
0B41F7             0326**  ; We might have located a variable at this point, just need to do a few more tests
0B41F7             0327**  ;
0B41F7 FD 2B       0328**  LOC5:			DEC     IY
0B41F9 FD 7E 00    0329**  			LD      A,(IY)
0B41FC FE 28       0330**  			CP      '('
0B41FE 28 15       0331**  			JR      Z,LOC5A         	; FOUND
0B4200 FD 23       0332**  			INC     IY
0B4202 CD 49 42 0B 0333**  			CALL    RANGE
0B4206 38 0D       0334**  			JR      C,LOC5A         	; FOUND
0B4208 FE 28       0335**  			CP      '('
0B420A 28 E4       0336**  			JR      Z,LOC4          	; KEEP LOOKING
0B420C FD 7E FF    0337**  			LD      A,(IY-1)
0B420F CD 55 42 0B 0338**  			CALL    RANGE1
0B4213 30 DB       0339**  			JR      NC,LOC4         	; KEEP LOOKING
0B4215 D1          0340**  LOC5A:			POP     DE
0B4216 FD 7E FF    0341**  TYPE_:			LD      A,(IY-1)		; Check the string type postfix
0B4219 FE 24       0342**  			CP      '$'			; Is it a string?
0B421B 16 81       0343**  			LD      D,129			; Yes, so return D = 129
0B421D C8          0344**  			RET     Z
0B421E FE 25       0345**  			CP      '%'			; Is it an integer?
0B4220 16 04       0346**  			LD      D,4			; Yes, so return D = 4
0B4222 C8          0347**  			RET     Z
0B4223 14          0348**  			INC     D			; At this point it must be a float
0B4224 BF          0349**  			CP      A			; Set the flags
0B4225 C9          0350**  			RET
0B4226             0351**  ;
0B4226             0352**  ; The variable is undefined at this point; HL will be zero
0B4226             0353**  ;
0B4226 3C          0354**  LOC6:			INC     A               	; Set NZ flag
0B4227 C9          0355**  			RET
0B4228             0356**  ;
0B4228             0357**  ; from exec.asm
0B4228             0358**  
0B4228             0359**  ; 16-bit unsigned multiply
0B4228             0360**  ; - HL: Operand 1
0B4228             0361**  ; - BC: Operand 2
0B4228             0362**  ; Returns:
0B4228             0363**  ; - HL: Result
0B4228             0364**  ; -  F: C if overflow
0B4228             0365**  ;
0B4228 C5          0366**  MUL16:			PUSH	BC
0B4229 51          0367**  			LD	D, C			; Set up the registers for the multiplies
0B422A 5D          0368**  			LD	E, L
0B422B 69          0369**  			LD	L, C
0B422C 4B          0370**  			LD	C, E
0B422D ED 6C       0371**  			MLT	HL			; HL = H * C (*256)
0B422F ED 5C       0372**  			MLT	DE			; DE = L * C
0B4231 ED 4C       0373**  			MLT	BC			; BC = B * L (*256)
0B4233 09          0374**  			ADD	HL, BC			; HL = The sum of the two most significant multiplications
0B4234 C1          0375**  			POP	BC
0B4235 AF          0376**  			XOR	A
0B4236 9C          0377**  			SBC	H			; If H is not zero then it's an overflow
0B4237 D8          0378**  			RET	C
0B4238 65          0379**  			LD	H, L			; HL = ((H * C) + (B * L) * 256) + (L * C)
0B4239 6F          0380**  			LD	L, A
0B423A 19          0381**  			ADD	HL, DE
0B423B C9          0382**  			RET
0B423C             0383**  
0B423C             0384**  
0B423C             0385**  ; Multiply by 4 or 5
0B423C             0386**  ; This function is used to allocate space for dimensioned variables
0B423C             0387**  ; This is a 24-bit operation
0B423C             0388**  ; - DE: Number to multiple
0B423C             0389**  ; -  A: 04h (Integer) - takes up 4 bytes
0B423C             0390**  ;       05h (Float)   - takes up 5 bytes
0B423C             0391**  ;       81h (String)  - takes up 5 bytes - this is different from BBC BASIC for Z80 where strings only take up 4 bytes
0B423C             0392**  ; Returns:
0B423C             0393**  ; - DE: Multiplied by 4 if A = 4, otherwise multiplies by 5
0B423C             0394**  ; -  F: Carry if overflow
0B423C             0395**  ; Corrupts:
0B423C             0396**  ; - HL
0B423C FE 04       0397**  X4OR5:			CP      4			; Check A = 4 (Z flag is used later)
0B423E             0398**  			; LD	HL,DE  ; HOW!?
0B423E D5          0399**  			push de
0B423F E1          0400**  			pop hl
0B4240 29          0401**  			ADD     HL,HL			; Multiply by 2 (note this operation preserves the zero flag)
0B4241 D8          0402**  			RET     C			; Exit if overflow
0B4242 29          0403**  			ADD     HL,HL			; Multiply by 2 again
0B4243 D8          0404**  			RET     C			; Exit if overflow
0B4244 EB          0405**  			EX      DE,HL			; DE: Product
0B4245 C8          0406**  			RET     Z			; Exit if A = 4
0B4246 19          0407**  			ADD     HL,DE			; Add original value to HL (effectively multiplying by 5)
0B4247 EB          0408**  			EX      DE,HL			; DE: Product
0B4248 C9          0409**  			RET
0B4249             0410**  
0B4249             0411**  
0B4249             0412**  ; from main.asm
0B4249             0413**  ; TEST FOR VALID CHARACTER IN VARIABLE NAME:
0B4249             0414**  ;   Inputs: IY addresses character
0B4249             0415**  ;  Outputs: Carry set if out-of-range.
0B4249             0416**  ; Destroys: A,F
0B4249             0417**  ;
0B4249             0418**  ; It is called here to check the following
0B4249             0419**  ; In range: "$", "%" and "("
0B4249             0420**  ;   Plus all characters in RANGE1 and RANGE2
0B4249             0421**  ;
0B4249 FD 7E 00    0422**  RANGE:			LD      A,(IY)			; Fetch the character
0B424C FE 24       0423**  			CP      '$'			; Postfix for string variable is valid
0B424E C8          0424**  			RET     Z
0B424F FE 25       0425**  			CP      '%'			; Postfix for integer variable is valid
0B4251 C8          0426**  			RET     Z
0B4252 FE 28       0427**  			CP      '('			; Postfix for array is valid
0B4254 C8          0428**  			RET     Z
0B4255             0429**  ;
0B4255             0430**  ; It is called here to check the following
0B4255             0431**  ; In range: "0" to "9" and "@"
0B4255             0432**  ;   Plus all characters in RANGE2
0B4255             0433**  ;
0B4255 FE 30       0434**  RANGE1:			CP      '0'			; If it is between '0'...
0B4257 D8          0435**  			RET     C
0B4258 FE 3A       0436**  			CP      '9'+1			; And '9'...
0B425A 3F          0437**  			CCF
0B425B D0          0438**  			RET     NC			; Then it is valid
0B425C FE 40       0439**  			CP      '@'             	; The prefix @ is valid (@% controls numeric print formatting - v2.4)
0B425E C8          0440**  			RET     Z
0B425F             0441**  ;
0B425F             0442**  ; It is called here to check the following
0B425F             0443**  ; In range: "A" to "Z", "a' to "z", "_" and "`"
0B425F             0444**  ;
0B425F FE 41       0445**  RANGE2:			CP      'A'			; If it is between 'A'...
0B4261 D8          0446**  			RET     C
0B4262 FE 5B       0447**  			CP      'Z'+1			; And 'Z'...
0B4264 3F          0448**  			CCF
0B4265 D0          0449**  			RET     NC			; Then it is valid
0B4266 FE 5F       0450**  			CP      '_'			; If it is underscore, grave, or between 'a'
0B4268 D8          0451**  			RET     C
0B4269 FE 7B       0452**  			CP      'z'+1			; And 'z'
0B426B 3F          0453**  			CCF				; Then it is valid
0B426C C9          0454**  			RET
0B426D             0455**  
0B426D             0456**  
0B426D             0457**  ; Throw a 'LINE space' error (line too long)
0B426D             0458**  ; This is called from LEXAN
0B426D             0459**  ;
0B426D AF          0460**  SPACE_: 		XOR     A
0B426E             0461**  			; CALL    EXTERR          	; "LINE space"
0B426E             0462**  			; DB    	LINE_, 8, 0
0B426E             0463**  ;
0B426E             0464**  ; LEXAN - LEXICAL ANALYSIS.
0B426E             0465**  ;  Bit 0,C: 1=left, 0=right
0B426E             0466**  ;  Bit 2,C: 1=in BINARY
0B426E             0467**  ;  Bit 3,C: 1=in HEX
0B426E             0468**  ;  Bit 4,C: 1=accept line number
0B426E             0469**  ;  Bit 5,C: 1=in variable, FN, PROC
0B426E             0470**  ;  Bit 6,C: 1=in REM, DATA, *
0B426E             0471**  ;  Bit 7,C: 1=in quotes
0B426E             0472**  ;   Inputs: IY addresses source string
0B426E             0473**  ;           DE addresses destination string (must be page boundary)
0B426E             0474**  ;            C sets initial mode
0B426E             0475**  ;  Outputs: DE, IY updated
0B426E             0476**  ;            A holds carriage return
0B426E             0477**  ;
0B426E 12          0478**  LEXAN1:			LD      (DE),A          	; Transfer to buffer
0B426F 13          0479**  			INC     DE              	; Increment the pointers
0B4270 FD 23       0480**  			INC     IY			; And fall through to the main function
0B4272             0481**  ;
0B4272             0482**  ; This is the main entry point
0B4272             0483**  ;
0B4272 7B          0484**  LEXAN2:			LD      A,E             	; Destination buffer on page boundary, so E can be used as length
0B4273 FE FC       0485**  			CP      252             	; If it is >= 252 bytes, then...
0B4275 30 F6       0486**  			JR      NC,SPACE_        	; Throw a 'LINE space' error (line too long)
0B4277 FD 7E 00    0487**  			LD      A,(IY)			; Fetch character from source string
0B427A FE 0D       0488**  			CP      CR			; If it is a CR
0B427C C8          0489**  			RET     Z               	; Then it is end of line; we're done parsing
0B427D CD 55 42 0B 0490**  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B4281 30 06       0491**  			JR      NC,LEXAN3		; Yes, so skip
0B4283 CB A9       0492**  			RES     5,C             	; FLAG: NOT IN VARIABLE
0B4285 CB 99       0493**  			RES     3,C             	; FLAG: NOT IN HEX
0B4287 CB 91       0494**  			RES	2,C			; FLAG: NOT IN BINARY
0B4289             0495**  ;
0B4289 FE 20       0496**  LEXAN3:			CP      ' '			; Ignore spaces
0B428B 28 E1       0497**  			JR      Z,LEXAN1
0B428D FE 2C       0498**  			CP      ','			; Ignore commas
0B428F 28 DD       0499**  			JR      Z,LEXAN1
0B4291 FE 32       0500**  			CP	'2'			; If less than '2'
0B4293 30 02       0501**  			JR	NC, @F			; No, so skip
0B4295 CB 91       0502**  			RES	2,C			; FLAG: NOT IN BINARY
0B4297 FE 47       0503**  @@:			CP      'G'			; If less then 'G'
0B4299 38 02       0504**  			JR      C,LEXAN4		; Yes, so skip
0B429B CB 99       0505**  			RES     3,C             	; FLAG: NOT IN HEX
0B429D             0506**  ;
0B429D FE 22       0507**  LEXAN4:			CP      34			; Is it a quote character?
0B429F 20 05       0508**  			JR      NZ,LEXAN5		; No, so skip
0B42A1 CB 11       0509**  			RL      C			; Toggle bit 7 of C by shifting it into carry flag
0B42A3 3F          0510**  			CCF                     	; Toggle the carry
0B42A4 CB 19       0511**  			RR      C			; And then shifting it back into bit 7 of C
0B42A6             0512**  ;
0B42A6             0513**  LEXAN5:
0B42A6             0514**              ; BIT     4,C			; Accept line number?
0B42A6             0515**  			; JR      Z,LEXAN6		; No, so skip
0B42A6             0516**  			; RES     4,C			; FLAG: DON'T ACCEPT LINE NUMBER
0B42A6             0517**  			; PUSH    BC
0B42A6             0518**  			; PUSH    DE
0B42A6             0519**  			; CALL    LINNUM         		; Parse the line number to HL
0B42A6             0520**  			; POP     DE
0B42A6             0521**  			; POP     BC
0B42A6             0522**  			; LD      A,H			; If it is not zero
0B42A6             0523**  			; OR      L
0B42A6             0524**  			; CALL    NZ,ENCODE       	; Then encode the line number HL to the destination (DE)
0B42A6             0525**  			; JR      LEXAN2          	; And loop
0B42A6             0526**  ;
0B42A6 0D          0527**  LEXAN6:			DEC     C			; Check for C=1 (LEFT)
0B42A7 28 0A       0528**  			JR      Z,LEXAN7        	; If so, skip
0B42A9 0C          0529**  			INC     C			; Otherwise restore C
0B42AA 20 C2       0530**  			JR      NZ,LEXAN1		; If C was 0 (RIGHT) then...
0B42AC B7          0531**  			OR      A			; Set the flags based on the character
0B42AD F4 F0 42 0B 0532**  			CALL    P,LEX           	; Tokenise if A < 128
0B42B1 18 13       0533**  			JR      LEXAN8			; And skip
0B42B3             0534**  ;
0B42B3             0535**  ; Processing the LEFT hand side here
0B42B3             0536**  ;
0B42B3 FE 2A       0537**  LEXAN7:			CP      '*'			; Is it a '*' (for star commands)
0B42B5 28 17       0538**  			JR      Z,LEXAN9		; Yes, so skip to quit tokenising
0B42B7 B7          0539**  			OR      A			; Set the flags based on the character
0B42B8 F4 F0 42 0B 0540**  			CALL    P,LEX           	; Tokenise if A < 128
0B42BC             0541**  ;
0B42BC             0542**  ; This bit of code checks if the tokens are one of the pseudo-variables PTR, PAGE, TIME, LOMEM, HIMEM
0B42BC             0543**  ; These tokens are duplicate in the table with a GET version and a SET version offset by the define OFFSET (40h)
0B42BC             0544**  ; Examples:
0B42BC             0545**  ;   LET A% = PAGE : REM This is the GET version
0B42BC             0546**  ;   PAGE = 40000  : REM This is the SET version
0B42BC             0547**  ;
0B42BC FE 8F       0548**  			CP      TOKLO			; TOKLO is 8Fh
0B42BE 38 06       0549**  			JR      C,LEXAN8		; If A is < 8Fh then skip to LEX8
0B42C0 FE 94       0550**  			CP      TOKHI+1			; TOKHI is 93h
0B42C2 30 02       0551**  			JR      NC,LEXAN8		; If A is >= 94h then skip to LEX8
0B42C4 C6 40       0552**  			ADD     A,OFFSET       		; Add OFFSET (40h) to make the token the SET version
0B42C6             0553**  ;
0B42C6 FE F4       0554**  LEXAN8:			CP      REM			; If the token is REM
0B42C8 28 04       0555**  			JR      Z,LEXAN9		; Then stop tokenising
0B42CA FE DC       0556**  			CP      DATA_			; If it is not DATA then
0B42CC 20 02       0557**  			JR      NZ,LEXANA		; Skip
0B42CE CB F1       0558**  LEXAN9:			SET     6,C             	; FLAG: STOP TOKENISING
0B42D0             0559**  ;
0B42D0 FE A4       0560**  LEXANA:			CP      FN			; If the token is FN
0B42D2 28 0A       0561**  			JR      Z,LEXANB
0B42D4 FE F2       0562**  			CP      PROC			; Or the token is PROC
0B42D6 28 06       0563**  			JR      Z,LEXANB		; Then jump to here
0B42D8 CD 5F 42 0B 0564**  			CALL    RANGE2			; Otherwise check the input is alphanumeric, "_" or "`"
0B42DC 38 02       0565**  			JR      C,LEXANC		; Jump here if out of range
0B42DE             0566**  ;
0B42DE CB E9       0567**  LEXANB:			SET     5,C             	; FLAG: IN VARIABLE/FN/PROC
0B42E0 FE 26       0568**  LEXANC:			CP      '&'			; Check for hex prefix
0B42E2 20 02       0569**  			JR      NZ,LEXAND		; If not, skip
0B42E4 CB D9       0570**  			SET     3,C             	; FLAG: IN HEX
0B42E6             0571**  ;
0B42E6 FE 25       0572**  LEXAND:			CP	'%'			; Check for binary prefix
0B42E8 20 02       0573**  			JR	NZ,LEXANE		; If not, skip
0B42EA CB D1       0574**  			SET	2,C			; FLAG: IN BINARY
0B42EC             0575**  ;
0B42EC             0576**  LEXANE:
0B42EC             0577**              ; LD      HL,LIST1		; List of tokens that must be followed by a line number
0B42EC             0578**  			; PUSH    BC
0B42EC             0579**  			; LD      BC,LIST1L		; The list length
0B42EC             0580**  			; CPIR				; Check if the token is in this list
0B42EC             0581**  			; POP     BC
0B42EC             0582**  			; JR      NZ,LEXANF		; If not, then skip
0B42EC             0583**  			; SET     4,C             	; FLAG: ACCEPT LINE NUMBER
0B42EC             0584**  ;
0B42EC             0585**  LEXANF:
0B42EC             0586**              ; LD      HL,LIST2		; List of tokens that switch the lexical analysis back to LEFT mode
0B42EC             0587**  			; PUSH    BC
0B42EC             0588**  			; LD      BC,LIST2L		; The list length
0B42EC             0589**  			; CPIR				; Check if the token is in this list
0B42EC             0590**  			; POP     BC
0B42EC             0591**  			; JR      NZ,LEXANG		; If not, then skip
0B42EC             0592**  			; SET     0,C             	; FLAG: ENTER LEFT MODE
0B42EC C3 6E 42 0B 0593**  LEXANG:			JP      LEXAN1			; And loop
0B42F0             0594**  
0B42F0             0595**  
0B42F0             0596**  ; SUBROUTINES:
0B42F0             0597**  ;
0B42F0             0598**  ; LEX - SEARCH FOR KEYWORDS
0B42F0             0599**  ;   Inputs: HL = start of keyword table
0B42F0             0600**  ;           IY = start of match text
0B42F0             0601**  ;  Outputs: If found, Z-flag set, A=token.
0B42F0             0602**  ;           If not found, Z-flag reset, A=(IY).
0B42F0             0603**  ;           IY updated (if NZ, IY unchanged).
0B42F0             0604**  ; Destroys: A,B,H,L,IY,F
0B42F0             0605**  ;
0B42F0 21 2B 43 0B 0606**  LEX:			LD      HL,KEYWDS		; Address of the keywords table
0B42F4             0607**  ;
0B42F4 FD 7E 00    0608**  LEX0:			LD      A,(IY)			; Fetch the character to match
0B42F7 46          0609**  			LD      B,(HL)			; B: The token from the keywords table
0B42F8 23          0610**  			INC     HL			; Increment the pointer in the keywords table
0B42F9 BE          0611**  			CP      (HL)			; Compare the first characters
0B42FA 28 08       0612**  			JR      Z,LEX2			; If there is a match, then skip to LEX2
0B42FC D8          0613**  			RET     C               	; No match, so fail
0B42FD             0614**  ;
0B42FD             0615**  ; This snippet of code skips to the next token in the KEYWDS table
0B42FD             0616**  ;
0B42FD 23          0617**  LEX1:			INC     HL			; Increment the pointer
0B42FE CB 7E       0618**  			BIT     7,(HL)			; Check if bit 7 set (all token IDs have bit 7 set)
0B4300 28 FB       0619**  			JR      Z,LEX1			; No, so loop
0B4302 18 F0       0620**  			JR      LEX0			; At this point HL is pointing to the start of the next keyword
0B4304             0621**  ;
0B4304 FD E5       0622**  LEX2:			PUSH    IY              	; Save the input pointer
0B4306 23          0623**  LEX3:			INC     HL			; Increment the keyword pointer
0B4307 CB 7E       0624**  			BIT     7,(HL)			; If we've reached the end (marked by the start of the next token) then
0B4309 20 1C       0625**  			JR      NZ,LEX6         	; Jump to here as we've found a token
0B430B FD 23       0626**  			INC     IY			; Increment the text pointer
0B430D FD 7E 00    0627**  			LD      A,(IY)			; Fetch the character
0B4310 FE 2E       0628**  			CP      '.'			; Is it an abbreviated keyword?
0B4312 28 13       0629**  			JR      Z,LEX6          	; Yes, so we'll return with the token we've found
0B4314 BE          0630**  			CP      (HL)			; Compare with the keywords list
0B4315 28 EF       0631**  			JR      Z,LEX3			; It's a match, so continue checking this keyword
0B4317 CD 55 42 0B 0632**  			CALL    RANGE1			; Is it alphanumeric, '@', '_' or '`'
0B431B 38 04       0633**  			JR      C,LEX5			; No, so check whether keyword needs to be immediately delimited
0B431D             0634**  ;
0B431D FD E1       0635**  LEX4:			POP     IY              	; Restore the input pointer ready for the next search
0B431F 18 DC       0636**  			JR      LEX1			; And loop back to start again
0B4321             0637**  ;
0B4321             0638**  ; This section handles the 0 byte at the end of keywords that indicate the keyword needs to be
0B4321             0639**  ; immediately delimited
0B4321             0640**  ;
0B4321 7E          0641**  LEX5:			LD      A,(HL)			; Fetch the byte from the keywords table
0B4322 B7          0642**  			OR      A			; If it is not zero, then...
0B4323 20 F8       0643**  			JR      NZ,LEX4			; Keep searching
0B4325 FD 2B       0644**  			DEC     IY			; If it is zero, then skip the input pointer back one byte
0B4327             0645**  ;
0B4327             0646**  ; We've found a token at this point
0B4327             0647**  ;
0B4327 F1          0648**  LEX6:			POP     AF			; Discard IY input pointer pushed on the stack
0B4328 AF          0649**  			XOR     A			; Set the Z flag
0B4329 78          0650**  			LD      A,B			; A: The token
0B432A C9          0651**  			RET
0B432B             0652**  
0B432B             0653**  
0B432B             0654**  ; A handful of common token IDs
0B432B             0655**  ;
0B432B             0656**  TERROR:			EQU     85H
0B432B             0657**  LINE_:			EQU     86H
0B432B             0658**  ELSE_:			EQU     8BH
0B432B             0659**  THEN:			EQU     8CH
0B432B             0660**  LINO:			EQU     8DH
0B432B             0661**  FN:			EQU     A4H
0B432B             0662**  TO:			EQU     B8H
0B432B             0663**  REN:			EQU     CCH
0B432B             0664**  DATA_:			EQU     DCH
0B432B             0665**  DIM:			EQU     DEH
0B432B             0666**  FOR:			EQU     E3H
0B432B             0667**  GOSUB:			EQU     E4H
0B432B             0668**  GOTO:			EQU     E5H
0B432B             0669**  TIF:			EQU     E7H
0B432B             0670**  LOCAL_:			EQU     EAH
0B432B             0671**  NEXT:			EQU     EDH
0B432B             0672**  ON_:			EQU     EEH
0B432B             0673**  PROC:			EQU     F2H
0B432B             0674**  REM:			EQU     F4H
0B432B             0675**  REPEAT:			EQU     F5H
0B432B             0676**  RESTOR:			EQU     F7H
0B432B             0677**  TRACE:			EQU     FCH
0B432B             0678**  UNTIL:			EQU     FDH
0B432B             0679**  ;
0B432B             0680**  ; This defines the block of tokens that are pseudo-variables.
0B432B             0681**  ; There are two versions of each token, a GET and a SET
0B432B             0682**  
0B432B             0683**  ; Name  : GET : SET
0B432B             0684**  ; ------:-----:----
0B432B             0685**  ; PTR   : 8Fh : CFh
0B432B             0686**  ; PAGE  : 90h : D0h
0B432B             0687**  ; TIME  : 91h : D1h
0B432B             0688**  ; LOMEM : 92h : D2h
0B432B             0689**  ; HIMEM : 93h : D3h
0B432B             0690**  ;
0B432B             0691**  ; Examples:
0B432B             0692**  ;   LET A% = PAGE : REM This is the GET version
0B432B             0693**  ;   PAGE = 40000  : REM This is the SET version
0B432B             0694**  ;
0B432B             0695**  TOKLO:			EQU     8FH			; This defines the block of tokens that are pseudo-variables
0B432B             0696**  TOKHI:			EQU     93H			; PTR, PAGE, TIME, LOMEM, HIMEM
0B432B             0697**  OFFSET:			EQU     CFH-TOKLO		; Offset to the parameterised SET versions
0B432B             0698**  
0B432B             0699**  
0B432B             0700**  ; List of tokens and keywords. If a keyword is followed by 0 then
0B432B             0701**  ; it will only match with the keyword followed immediately by
0B432B             0702**  ; a delimiter
0B432B             0703**  ;
0B432B 80 41 4E 44 0704**  KEYWDS:			DB    80H, "AND"
0B432F 94 41 42 53 0705**  			DB    94H, "ABS"
0B4333 95 41 43 53 0706**  			DB    95H, "ACS"
0B4337 96 41 44 56 0707**  			DB    96H, "ADVAL"
       41 4C       
0B433D 97 41 53 43 0708**  			DB    97H, "ASC"
0B4341 98 41 53 4E 0709**  			DB    98H, "ASN"
0B4345 99 41 54 4E 0710**  			DB    99H, "ATN"
0B4349 C6 41 55 54 0711**  			DB    C6H, "AUTO"
       4F          
0B434E 9A 42 47 45 0712**  			DB    9AH, "BGET", 0
       54 00       
0B4354 D5 42 50 55 0713**  			DB    D5H, "BPUT", 0
       54 00       
0B435A FB 43 4F 4C 0714**  			DB    FBH, "COLOUR"
       4F 55 52    
0B4361 FB 43 4F 4C 0715**  			DB    FBH, "COLOR"
       4F 52       
0B4367 D6 43 41 4C 0716**  			DB    D6H, "CALL"
       4C          
0B436C D7 43 48 41 0717**  			DB    D7H, "CHAIN"
       49 4E       
0B4372 BD 43 48 52 0718**  			DB    BDH, "CHR$"
       24          
0B4377 D8 43 4C 45 0719**  			DB    D8H, "CLEAR", 0
       41 52 00    
0B437E D9 43 4C 4F 0720**  			DB    D9H, "CLOSE", 0
       53 45 00    
0B4385 DA 43 4C 47 0721**  			DB    DAH, "CLG", 0
       00          
0B438A DB 43 4C 53 0722**  			DB    DBH, "CLS", 0
       00          
0B438F 9B 43 4F 53 0723**  			DB    9BH, "COS"
0B4393 9C 43 4F 55 0724**  			DB    9CH, "COUNT", 0
       4E 54 00    
0B439A DC 44 41 54 0725**  			DB    DCH, "DATA"
       41          
0B439F 9D 44 45 47 0726**  			DB    9DH, "DEG"
0B43A3 DD 44 45 46 0727**  			DB    DDH, "DEF"
0B43A7 C7 44 45 4C 0728**  			DB    C7H, "DELETE"
       45 54 45    
0B43AE 81 44 49 56 0729**  			DB    81H, "DIV"
0B43B2 DE 44 49 4D 0730**  			DB    DEH, "DIM"
0B43B6 DF 44 52 41 0731**  			DB    DFH, "DRAW"
       57          
0B43BB E1 45 4E 44 0732**  			DB    E1H, "ENDPROC", 0
       50 52 4F 43 
       00          
0B43C4 E0 45 4E 44 0733**  			DB    E0H, "END", 0
       00          
0B43C9 E2 45 4E 56 0734**  			DB    E2H, "ENVELOPE"
       45 4C 4F 50 
       45          
0B43D2 8B 45 4C 53 0735**  			DB    8BH, "ELSE"
       45          
0B43D7 A0 45 56 41 0736**  			DB    A0H, "EVAL"
       4C          
0B43DC 9E 45 52 4C 0737**  			DB    9EH, "ERL", 0
       00          
0B43E1 85 45 52 52 0738**  			DB    85H, "ERROR"
       4F 52       
0B43E7 C5 45 4F 46 0739**  			DB    C5H, "EOF", 0
       00          
0B43EC 82 45 4F 52 0740**  			DB    82H, "EOR"
0B43F0 9F 45 52 52 0741**  			DB    9FH, "ERR", 0
       00          
0B43F5 A1 45 58 50 0742**  			DB    A1H, "EXP"
0B43F9 A2 45 58 54 0743**  			DB    A2H, "EXT", 0
       00          
0B43FE E3 46 4F 52 0744**  			DB    E3H, "FOR"
0B4402 A3 46 41 4C 0745**  			DB    A3H, "FALSE", 0
       53 45 00    
0B4409 A4 46 4E    0746**  			DB    A4H, "FN"
0B440C E5 47 4F 54 0747**  			DB    E5H, "GOTO"
       4F          
0B4411 BE 47 45 54 0748**  			DB    BEH, "GET$"
       24          
0B4416 A5 47 45 54 0749**  			DB    A5H, "GET"
0B441A E4 47 4F 53 0750**  			DB    E4H, "GOSUB"
       55 42       
0B4420 E6 47 43 4F 0751**  			DB    E6H, "GCOL"
       4C          
0B4425 93 48 49 4D 0752**  			DB    93H, "HIMEM", 0
       45 4D 00    
0B442C E8 49 4E 50 0753**  			DB    E8H, "INPUT"
       55 54       
0B4432 E7 49 46    0754**  			DB    E7H, "IF"
0B4435 BF 49 4E 4B 0755**  			DB    BFH, "INKEY$"
       45 59 24    
0B443C A6 49 4E 4B 0756**  			DB    A6H, "INKEY"
       45 59       
0B4442 A8 49 4E 54 0757**  			DB    A8H, "INT"
0B4446 A7 49 4E 53 0758**  			DB    A7H, "INSTR("
       54 52 28    
0B444D C9 4C 49 53 0759**  			DB    C9H, "LIST"
       54          
0B4452 86 4C 49 4E 0760**  			DB    86H, "LINE"
       45          
0B4457 C8 4C 4F 41 0761**  			DB    C8H, "LOAD"
       44          
0B445C 92 4C 4F 4D 0762**  			DB    92H, "LOMEM", 0
       45 4D 00    
0B4463 EA 4C 4F 43 0763**  			DB    EAH, "LOCAL"
       41 4C       
0B4469 C0 4C 45 46 0764**  			DB    C0H, "LEFT$("
       54 24 28    
0B4470 A9 4C 45 4E 0765**  			DB    A9H, "LEN"
0B4474 E9 4C 45 54 0766**  			DB    E9H, "LET"
0B4478 AB 4C 4F 47 0767**  			DB    ABH, "LOG"
0B447C AA 4C 4E    0768**  			DB    AAH, "LN"
0B447F C1 4D 49 44 0769**  			DB    C1H, "MID$("
       24 28       
0B4485 EB 4D 4F 44 0770**  			DB    EBH, "MODE"
       45          
0B448A 83 4D 4F 44 0771**  			DB    83H, "MOD"
0B448E EC 4D 4F 56 0772**  			DB    ECH, "MOVE"
       45          
0B4493 ED 4E 45 58 0773**  			DB    EDH, "NEXT"
       54          
0B4498 CA 4E 45 57 0774**  			DB    CAH, "NEW", 0
       00          
0B449D AC 4E 4F 54 0775**  			DB    ACH, "NOT"
0B44A1 CB 4F 4C 44 0776**  			DB    CBH, "OLD", 0
       00          
0B44A6 EE 4F 4E    0777**  			DB    EEH, "ON"
0B44A9 87 4F 46 46 0778**  			DB    87H, "OFF"
0B44AD 84 4F 52    0779**  			DB    84H, "OR"
0B44B0 8E 4F 50 45 0780**  			DB    8EH, "OPENIN"
       4E 49 4E    
0B44B7 AE 4F 50 45 0781**  			DB    AEH, "OPENOUT"
       4E 4F 55 54 
0B44BF AD 4F 50 45 0782**  			DB    ADH, "OPENUP"
       4E 55 50    
0B44C6 FF 4F 53 43 0783**  			DB    FFH, "OSCLI"
       4C 49       
0B44CC F1 50 52 49 0784**  			DB    F1H, "PRINT"
       4E 54       
0B44D2 90 50 41 47 0785**  			DB    90H, "PAGE", 0
       45 00       
0B44D8 8F 50 54 52 0786**  			DB    8FH, "PTR", 0
       00          
0B44DD AF 50 49 00 0787**  			DB    AFH, "PI", 0
0B44E1 F0 50 4C 4F 0788**  			DB    F0H, "PLOT"
       54          
0B44E6 B0 50 4F 49 0789**  			DB    B0H, "POINT("
       4E 54 28    
0B44ED F2 50 52 4F 0790**  			DB    F2H, "PROC"
       43          
0B44F2 B1 50 4F 53 0791**  			DB    B1H, "POS", 0
       00          
0B44F7 CE 50 55 54 0792**  			DB    CEH, "PUT"
0B44FB F8 52 45 54 0793**  			DB    F8H, "RETURN", 0
       55 52 4E 00 
0B4503 F5 52 45 50 0794**  			DB    F5H, "REPEAT"
       45 41 54    
0B450A F6 52 45 50 0795**  			DB    F6H, "REPORT", 0
       4F 52 54 00 
0B4512 F3 52 45 41 0796**  			DB    F3H, "READ"
       44          
0B4517 F4 52 45 4D 0797**  			DB    F4H, "REM"
0B451B F9 52 55 4E 0798**  			DB    F9H, "RUN", 0
       00          
0B4520 B2 52 41 44 0799**  			DB    B2H, "RAD"
0B4524 F7 52 45 53 0800**  			DB    F7H, "RESTORE"
       54 4F 52 45 
0B452C C2 52 49 47 0801**  			DB    C2H, "RIGHT$("
       48 54 24 28 
0B4534 B3 52 4E 44 0802**  			DB    B3H, "RND", 0
       00          
0B4539 CC 52 45 4E 0803**  			DB    CCH, "RENUMBER"
       55 4D 42 45 
       52          
0B4542 88 53 54 45 0804**  			DB    88H, "STEP"
       50          
0B4547 CD 53 41 56 0805**  			DB    CDH, "SAVE"
       45          
0B454C B4 53 47 4E 0806**  			DB    B4H, "SGN"
0B4550 B5 53 49 4E 0807**  			DB    B5H, "SIN"
0B4554 B6 53 51 52 0808**  			DB    B6H, "SQR"
0B4558 89 53 50 43 0809**  			DB    89H, "SPC"
0B455C C3 53 54 52 0810**  			DB    C3H, "STR$"
       24          
0B4561 C4 53 54 52 0811**  			DB    C4H, "STRING$("
       49 4E 47 24 
       28          
0B456A D4 53 4F 55 0812**  			DB    D4H, "SOUND"
       4E 44       
0B4570 FA 53 54 4F 0813**  			DB    FAH, "STOP", 0
       50 00       
0B4576 B7 54 41 4E 0814**  			DB    B7H, "TAN"
0B457A 8C 54 48 45 0815**  			DB    8CH, "THEN"
       4E          
0B457F B8 54 4F    0816**  			DB    B8H, "TO"
0B4582 8A 54 41 42 0817**  			DB    8AH, "TAB("
       28          
0B4587 FC 54 52 41 0818**  			DB    FCH, "TRACE"
       43 45       
0B458D 91 54 49 4D 0819**  			DB    91H, "TIME", 0
       45 00       
0B4593 B9 54 52 55 0820**  			DB    B9H, "TRUE", 0
       45 00       
0B4599 FD 55 4E 54 0821**  			DB    FDH, "UNTIL"
       49 4C       
0B459F BA 55 53 52 0822**  			DB    BAH, "USR"
0B45A3 EF 56 44 55 0823**  			DB    EFH, "VDU"
0B45A7 BB 56 41 4C 0824**  			DB    BBH, "VAL"
0B45AB BC 56 50 4F 0825**  			DB    BCH, "VPOS", 0
       53 00       
0B45B1 FE 57 49 44 0826**  			DB    FEH, "WIDTH"
       54 48       
0B45B7 D3 48 49 4D 0827**  			DB    D3H, "HIMEM"
       45 4D       
0B45BD D2 4C 4F 4D 0828**  			DB    D2H, "LOMEM"
       45 4D       
0B45C3 D0 50 41 47 0829**  			DB    D0H, "PAGE"
       45          
0B45C8 CF 50 54 52 0830**  			DB    CFH, "PTR"
0B45CC D1 54 49 4D 0831**  			DB    D1H, "TIME"
       45          
0B45D1             0832**  
0B45D1             0833**  
0B45D1             0834**  ; from exec.asm
0B45D1             0835**  
0B45D1             0836**  ; ASSIGN - Assign a numeric value to a variable.
0B45D1             0837**  ; Outputs: NC,  Z - OK, numeric.
0B45D1             0838**  ;          NC, NZ - OK, string.
0B45D1             0839**  ;           C, NZ - illegal
0B45D1             0840**  ;
0B45D1 CD 86 40 0B 0841**  ASSIGN:			CALL    GETVAR          	; Try to get the variable
0B45D5 D8          0842**  			RET     C               	; Return with C if it is an illegal variable
0B45D6 C4 79 40 0B 0843**  			CALL    NZ,PUTVAR		; If it does not exist, then create the variable
0B45DA B7          0844**  			OR      A
0B45DB F8          0845**  			RET     M               	; Return if type is string (81h)
0B45DC F5          0846**  			PUSH    AF              	; It's a numeric type from this point on
0B45DD CD 13 46 0B 0847**  			CALL    EQUALS			; Check if the variable is followed by an '=' symbol; this will throw a 'Mistake' error if not
0B45E1 E5          0848**  			PUSH    HL
0B45E2 CD F5 2B 0B 0849**  			CALL    EXPRN
0B45E6 DD E1       0850**  			POP     IX
0B45E8 F1          0851**  			POP     AF
0B45E9 CB 47       0852**  STORE:			BIT     0,A
0B45EB 28 13       0853**  			JR      Z,STOREI
0B45ED BF          0854**  			CP      A               	; Set the variable to 0
0B45EE DD 71 04    0855**  STORE5:			LD      (IX+4),C
0B45F1 D9          0856**  STORE4:			EXX
0B45F2 DD 75 00    0857**  			LD      (IX+0),L
0B45F5 DD 74 01    0858**  			LD      (IX+1),H
0B45F8 D9          0859**  			EXX
0B45F9 DD 75 02    0860**  			LD      (IX+2),L
0B45FC DD 74 03    0861**  			LD      (IX+3),H
0B45FF C9          0862**  			RET
0B4600 F5          0863**  STOREI:			PUSH    AF
0B4601 0C          0864**  			INC     C               ;SPEED - & PRESERVE F'
0B4602 0D          0865**  			DEC     C               ; WHEN CALLED BY FNEND0
0B4603 C4 A0 2E 0B 0866**  			CALL    NZ,SFIX         ;CONVERT TO INTEGER
0B4607 F1          0867**  			POP     AF
0B4608 FE 04       0868**  			CP      4
0B460A 28 E5       0869**  			JR      Z,STORE4
0B460C BF          0870**  			CP      A               ;SET ZERO
0B460D D9          0871**  STORE1:			EXX
0B460E DD 75 00    0872**  			LD      (IX+0),L
0B4611 D9          0873**  			EXX
0B4612 C9          0874**  			RET
0B4613             0875**  
0B4613             0876**  
0B4613             0877**  ; This snippet is used to check whether an expression is followed by an '=' symbol
0B4613             0878**  ;
0B4613 CD 4A 32 0B 0879**  EQUALS:			CALL    NXT			; Skip whitespace
0B4617 FD 23       0880**  			INC     IY			; Skip past the character in question
0B4619 FE 3D       0881**  			CP      '='			; Is it '='
0B461B C8          0882**  			RET     Z			; Yes, so return
0B461C             0883**  			; LD      A,4			; Otherwise
0B461C             0884**  			; JP      ERROR_           	; Throw error "Mistake"
0B461C             0885**  
0B461C             0886**  
0B461C             0887**  ; STUBS OF STUFF WE WON'T BE USING
0B461C C9          0888**  POINT:      ret			; POINT( ; in agon_graphics.asm we won't be using
0B461D C9          0889**  USR:        ret			; USR ; in exec.asm
0B461E             0007*       include "basic/sorry.asm"
0B461E             0001**  ;
0B461E             0002**  ; Title:	BBC Basic Interpreter - Z80 version
0B461E             0003**  ;		Catch-all for unimplemented functionality
0B461E             0004**  ; Author:	Dean Belfield
0B461E             0005**  ; Created:	12/05/2023
0B461E             0006**  ; Last Updated:	12/05/2023
0B461E             0007**  ;
0B461E             0008**  ; Modinfo:
0B461E             0009**  
0B461E             0010**  			.ASSUME	ADL = 1
0B461E             0011**  
0B461E             0012**  			; SEGMENT CODE
0B461E             0013**  
0B461E             0014**  			; XDEF	ENVEL
0B461E             0015**  			; XDEF	ADVAL
0B461E             0016**  			; XDEF	PUTIMS
0B461E             0017**  
0B461E             0018**  			; XREF	EXTERR
0B461E             0019**  
0B461E             0020**  ENVEL:
0B461E             0021**  ADVAL:
0B461E C9          0022**  PUTIMS: 	ret ; hopefully we won't be needing this
0B461F             0023**  			; XOR     A
0B461F             0024**  			; CALL    EXTERR
0B461F             0025**  			; DEFB    "Sorry"
0B461F             0026**  			; DEFB    0
0B461F             0008*   
0B461F             0009*   ; -------------------- from basic/fpp.asm --------------------
0B461F             0010*   
0B461F             0011*   
0B461F             0012*   ;Function STRING - convert numeric value to ASCII string.
0B461F             0013*   ;   Inputs: HLH'L'C = integer or floating-point number
0B461F             0014*   ;           DE = address at which to store string
0B461F             0015*   ;           IX = address of @% format control
0B461F             0016*   ;  Outputs: String stored, with NUL terminator
0B461F             0017*   
0B461F             0018*   ;NUMBER: Get unsigned integer from string.
0B461F             0019*   ;    Inputs: string at (IX)
0B461F             0020*   ;            C = truncated digit count
0B461F             0021*   ;                (initially zero)
0B461F             0022*   ;            B = total digit count
0B461F             0023*   ;            HLH'L' = initial value
0B461F             0024*   ;   Outputs: HLH'L' = number (binary integer)
0B461F             0025*   ;            A = delimiter.
0B461F             0026*   ;            B, C & IX updated
0B461F             0027*   ;  Destroys: A,B,C,D,E,H,L,B',C',D',E',H',L',IX,F
0B461F             0028*   
0B461F             0029*   ;VAL - Return numeric value of string.
0B461F             0030*   ;Input: ASCII string at IX
0B461F             0031*   ;Result is variable type numeric.
0B461F             0032*   
0B461F             0033*   ;SWAP_FP - Swap arguments.
0B461F             0034*   ;    Exchanges DE,HL D'E',H'L' and B,C
0B461F             0035*   ;    Destroys: A,B,C,D,E,H,L,D',E',H',L'
0B461F             0036*   ;SWAP1 - Swap DEHL with D'E'H'L'
0B461F             0037*   ;    Destroys: D,E,H,L,D',E',H',L'
0B461F             0038*   
0B461F             0039*   
0B461F             0040*   ;
0B461F             0041*   ;IADD - Integer addition.
0B461F             0042*   ;FADD - Floating point addition with rounding.
0B461F             0043*   ;
0B461F             0044*   
0B461F             0045*   ; -------------------- from basic/eval.asm --------------------
0B461F             0046*   ;
0B461F             0047*   ;Function STR - convert numeric value to ASCII string.
0B461F             0048*   ;   Inputs: HLH'L'C = integer or floating-point number.
0B461F             0049*   ;  Outputs: String in string accumulator.
0B461F             0050*   ;           E = length, D = ACCS/256
0B461F             0051*   ;           A = 80H (type=string)
0B461F             0052*   
0B461F             0053*   
0B461F             0054*   ;HEXSTR - convert numeric value to HEX string.
0B461F             0055*   ;   Inputs: HLH'L'C = integer or floating-point number
0B461F             0056*   ;  Outputs: String in string accumulator.
0B461F             0057*   ;           E = string length.  D = ACCS/256
0B461F             0058*   
0B461F             0059*   
0B461F             0060*   
0B461F             0061*   ; ==================== CONVENIENCE FUNCTIONS ====================
0B461F             0062*   ;
0B461F             0063*   ; print a floating point number in decimal format
0B461F             0064*   ; inputs: HL'H'L'C is the number to print
0B461F             0065*   ; outputs: number printed to screen
0B461F             0066*   ;          STROUT null-terminated string representation of the number
0B461F             0067*   ; destroys: nothing
0B461F             0068*   print_float_dec:
0B461F             0069*       PUSH_ALL
0B461F 08          0001*M          ex af,af'
0B4620 D9          0002*M          exx
0B4621 F5          0003*M          push af
0B4622 E5          0004*M          push hl
0B4623 C5          0005*M          push bc
0B4624 D5          0006*M          push de
0B4625             0007*M  
0B4625 08          0008*M          ex af,af'
0B4626 D9          0009*M          exx
0B4627 F5          0010*M          push af
0B4628 E5          0011*M          push hl
0B4629 C5          0012*M          push bc
0B462A D5          0013*M          push de
0B462B DD E5       0014*M          push ix
0B462D FD E5       0015*M          push iy
0B462F DD 21 5F 47 0070*       ld ix,NUMF ; point to the format code buffer
       0B          
0B4634 1E 0A       0071*       ld e,10 ; fractional digits
0B4636 DD 73 01    0072*       ld (ix+1),e ; store the format code
0B4639 16 02       0073*       ld d,%000000010
0B463B DD 72 02    0074*       ld (ix+2),d ; store the format code
0B463E 11 5F 46 0B 0075*       ld de,STROUT ; point to the output buffer
0B4642 CD 71 3A 0B 0076*       call STRING ; convert the number back to a string
0B4646 21 5F 46 0B 0077*       ld hl,STROUT ; point to the string output buffer
0B464A CD 73 02 0B 0078*       call printString
0B464E             0079*       POP_ALL
0B464E FD E1       0001*M          pop iy
0B4650 DD E1       0002*M          pop ix
0B4652 D1          0003*M          pop de
0B4653 C1          0004*M          pop bc
0B4654 E1          0005*M          pop hl
0B4655 F1          0006*M          pop af
0B4656 08          0007*M          ex af,af'
0B4657 D9          0008*M          exx
0B4658             0009*M  
0B4658 D1          0010*M          pop de
0B4659 C1          0011*M          pop bc
0B465A E1          0012*M          pop hl
0B465B F1          0013*M          pop af
0B465C 08          0014*M          ex af,af'
0B465D D9          0015*M          exx
0B465E C9          0080*       ret
0B465F             0081*   
0B465F             0082*   
0B465F             0083*   ; output buffer for strings from BASIC
0B465F 00 00 00 00 0084*   STROUT: blkb 256,0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B475F             0085*   ; numeric string format code
0B475F             0086*   ; byte 1 is the number of significant digits:
0B475F             0087*   ; -- up to 10
0B475F             0088*   ; -- 0 or > 10 defaults to max decimal notation
0B475F             0089*   ; -- if less than number of integer digits, output will be in E notation
0B475F             0090*   ; byte 2 bit 1 is E notation flag when set
0B475F             0091*   ; -- trailing zeros are added to bring number of significant digits to the specified number
0B475F 00 00 00    0092*   NUMF: dl 0
0B4762             0093*   
0B4762             0094*   ; num1: blkb 6,0
0B4762             0095*   ; num2: blkb 6,0
0B4762             0096*   ; ; store HLH'L'C in num1
0B4762             0097*   ; store1:
0B4762             0098*   ;     push ix
0B4762             0099*   ;     ld ix,num1
0B4762             0100*   ;     exx
0B4762             0101*   ;     ld (ix+0),c
0B4762             0102*   ;     ld (ix+1),l
0B4762             0103*   ;     ld (ix+2),h
0B4762             0104*   ;     exx
0B4762             0105*   ;     ld (ix+3),l
0B4762             0106*   ;     ld (ix+4),h
0B4762             0107*   
0B4762             0108*   ;     call debug_print
0B4762             0109*   ;     push hl
0B4762             0110*   ;     ld hl,num1
0B4762             0111*   ;     ld a,6
0B4762             0112*   ;     call dumpMemoryHex
0B4762             0113*   ;     pop hl
0B4762             0114*   
0B4762             0115*   ;     pop ix
0B4762             0116*   ;     ret
0B4762             0117*   
0B4762             0118*   ; get1:
0B4762             0119*   ;     push ix
0B4762             0120*   ;     ld ix,num1
0B4762             0121*   ;     exx
0B4762             0122*   ;     ld c,(ix+0)
0B4762             0123*   ;     ld l,(ix+1)
0B4762             0124*   ;     ld h,(ix+2)
0B4762             0125*   ;     exx
0B4762             0126*   ;     ld l,(ix+3)
0B4762             0127*   ;     ld h,(ix+4)
0B4762             0128*   ;     pop ix
0B4762             0129*   ;     ret
0B4762             0130*   
0B4762             0131*   ; ; store DED'E'B in num2
0B4762             0132*   ; store2:
0B4762             0133*   ;     push ix
0B4762             0134*   ;     ld ix,num2
0B4762             0135*   ;     exx
0B4762             0136*   ;     ld (ix+0),b
0B4762             0137*   ;     ld (ix+1),e
0B4762             0138*   ;     ld (ix+2),d
0B4762             0139*   ;     exx
0B4762             0140*   ;     ld (ix+3),e
0B4762             0141*   ;     ld (ix+4),d
0B4762             0142*   
0B4762             0143*   ;     call debug_print
0B4762             0144*   ;     push hl
0B4762             0145*   ;     ld hl,num2
0B4762             0146*   ;     ld a,6
0B4762             0147*   ;     call dumpMemoryHex
0B4762             0148*   
0B4762             0149*   ;     pop ix
0B4762             0150*   ;     ret
0B4762             0151*   
0B4762             0152*   ; ; get DED'E'B from num2
0B4762             0153*   ; get2:
0B4762             0154*   ;     push ix
0B4762             0155*   ;     ld ix,num2
0B4762             0156*   ;     exx
0B4762             0157*   ;     ld b,(ix+0)
0B4762             0158*   ;     ld e,(ix+1)
0B4762             0159*   ;     ld d,(ix+2)
0B4762             0160*   ;     exx
0B4762             0161*   ;     ld e,(ix+3)
0B4762             0162*   ;     ld d,(ix+4)
0B4762             0163*   ;     pop ix
0B4762             0164*   ;     ret
0B4762             0035    
0B4762             0036    ; APPLICATION INCLUDES
0B4762 55 73 61 67 0037    str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B477A 45 72 72 6F 0038    str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B4783 53 75 63 63 0039    str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B478E             0040    
0B478E             0041    ; ========= MAIN LOOP =========
0B478E             0042    ; The main routine
0B478E             0043    ; IXU: argv - pointer to array of parameters
0B478E             0044    ;   C: argc - number of parameters
0B478E             0045    ; Returns:
0B478E             0046    ;  HL: Error code, or 0 if OK
0B478E             0047    
0B478E             0048    min_args: equ 3
0B478E             0049    
0B478E 36 35 35 33 0050    arg1: ASCIZ "65535.275"
       35 2E 32 37 
       35 00       
0B4798 33 32 37 36 0051    arg2: ASCIZ "32767.667"
       37 2E 36 36 
       37 00       
0B47A2             0052    
0B47A2             0053    _main:
0B47A2             0054    ; TEMP DEBUG CODE
0B47A2 CD 88 02 0B 0055        call printNewLine
0B47A6             0056    
0B47A6 FD 21 8E 47 0057        ld iy,arg1
       0B          
0B47AB CD BE 2A 0B 0058        call EXPR
0B47AF CD 85 06 0B 0059        call dumpRegistersHexAll
0B47B3 CD 1F 46 0B 0060        call print_float_dec
0B47B7 CD 88 02 0B 0061        call printNewLine
0B47BB CD BB 3E 0B 0062        CALL PUSH5
0B47BF             0063    
0B47BF FD 21 98 47 0064        ld iy,arg2
       0B          
0B47C4 CD BE 2A 0B 0065        call EXPR
0B47C8 CD 85 06 0B 0066        call dumpRegistersHexAll
0B47CC CD 1F 46 0B 0067        call print_float_dec
0B47D0 CD 88 02 0B 0068        call printNewLine
0B47D4             0069    
0B47D4 CD C4 3E 0B 0070        CALL POP5
0B47D8 CD 85 06 0B 0071        call dumpRegistersHexAll
0B47DC CD 04 34 0B 0072        call FADD
0B47E0 CD 85 06 0B 0073        call dumpRegistersHexAll
0B47E4 CD 1F 46 0B 0074        call print_float_dec
0B47E8 CD 88 02 0B 0075        call printNewLine
0B47EC             0076    
0B47EC C3 0A 48 0B 0077        jp _main_end_ok
0B47F0             0078    
0B47F0             0079    ; END TEMP DEBUG CODE
0B47F0 79          0080        ld a,c              ; how many arguments?
0B47F1 FE 03       0081        cp min_args         ; not enough?
0B47F3 30 22       0082        jr nc,main          ; if enough, go to main loop
0B47F5 21 62 47 0B 0083        ld hl,str_usage     ; if not enough, print usage
0B47F9 CD 73 02 0B 0084        call printString
0B47FD             0085                            ; fall through to _main_end_error
0B47FD             0086    
0B47FD             0087    _main_end_error:
0B47FD 21 7A 47 0B 0088        ld hl,str_error     ; print error message
0B4801 CD 73 02 0B 0089        call printString
0B4805 21 13 00 00 0090        ld hl,19            ; return error code 19
0B4809 C9          0091        ret
0B480A             0092    
0B480A             0093    _main_end_ok:
0B480A 21 83 47 0B 0094        ld hl,str_success   ; print success message
0B480E CD 73 02 0B 0095        call printString
0B4812 21 00 00 00 0096        ld hl,0             ; return 0 for success
0B4816 C9          0097        ret
0B4817             0098    
0B4817             0099    ; ========= BEGIN CUSTOM MAIN LOOP =========
0B4817             0100    main:
0B4817 0D          0101        dec c               ; decrement the argument count to skip the program name
0B4818             0102        ; call debug_print
0B4818             0103    
0B4818             0104    ; match on BASIC functions
0B4818 FD 21 7F 48 0105        ld iy,BASIC
       0B          
0B481D CD 5D 4A 0B 0106        call match_next_and_print ; iy = function pointer, zero flag set if match
0B4821 CA 6C 48 0B 0107        jp z,BASIC_EXEC
0B4825             0108    @@:
0B4825 ED 32 FD    0109        lea ix,ix-3
0B4828             0110    
0B4828             0111        ; call debug_print
0B4828             0112    
0B4828             0113    
0B4828             0114    ; get first numeric argument
0B4828 CD F2 49 0B 0115        call get_arg_float ; HLH'L'C = arg1
0B482C CD 1F 46 0B 0116        call print_float_dec
0B4830             0117    
0B4830             0118        ; call debug_print
0B4830             0119    
0B4830             0120        ; call store1
0B4830 CD BB 3E 0B 0121        call PUSH5
0B4834             0122    
0B4834             0123        ; call debug_print
0B4834             0124    
0B4834             0125    
0B4834             0126    ; match on single number functions
0B4834 FD 21 64 49 0127        ld iy,function
       0B          
0B4839 CD 5D 4A 0B 0128        call match_next_and_print ; iy = function pointer, zero flag set if match
0B483D CA 59 48 0B 0129        jp z,@execute
0B4841             0130    
0B4841             0131    ; match on two-number operators
0B4841 ED 32 FD    0132        lea ix,ix-3
0B4844 FD 21 98 48 0133        ld iy,operator
       0B          
0B4849             0134        ; call debug_print
0B4849 CD 5D 4A 0B 0135        call match_next_and_print ; iy = operator pointer, zero flag set if match
0B484D             0136        ; call printNewLine
0B484D             0137        ; call dumpFlags
0B484D             0138        ; call debug_print
0B484D C2 FD 47 0B 0139        jp nz,_main_end_error
0B4851             0140    
0B4851             0141    ; get second numeric argument if needed
0B4851 CD F2 49 0B 0142        call get_arg_float ; HLH'L'C = arg2
0B4855 CD 1F 46 0B 0143        call print_float_dec
0B4859             0144        ; call SWAP_FP ; DED'E'B = arg2
0B4859             0145        ; call store2
0B4859             0146        ; fall through to @execute
0B4859             0147    
0B4859             0148    @execute:
0B4859             0149        callIY ; call the function
0B4859 01 60 48 0B 0001M           ld bc,$+7     ; Address of first instruction after the jump
0B485D C5          0002M           push bc       ; which constitutes the return address
0B485E FD E9       0003M           jp   (iy)     ; Jump to the address in IY
0B4860 CD 88 02 0B 0150        call printNewLine
0B4864 CD 88 02 0B 0151        call printNewLine
0B4868 C3 0A 48 0B 0152        jp _main_end_ok
0B486C             0153    
0B486C             0154    ; ========== DISPATCH TABLES ==========
0B486C             0155    ; BASIC FUNCTIONS
0B486C             0156    BASIC_EXEC:
0B486C C2 FD 47 0B 0157        jp nz,_main_end_error
0B4870             0158    
0B4870             0159        callIY ; call the function
0B4870 01 77 48 0B 0001M           ld bc,$+7     ; Address of first instruction after the jump
0B4874 C5          0002M           push bc       ; which constitutes the return address
0B4875 FD E9       0003M           jp   (iy)     ; Jump to the address in IY
0B4877 CD 88 02 0B 0160        call printNewLine
0B487B C3 0A 48 0B 0161        jp _main_end_ok
0B487F             0162    
0B487F             0163    BASIC:
0B487F 85 48 0B    0164        dl val
0B4882 00 00 00    0165        dl 0x000000 ; list terminator
0B4885             0166    val:
0B4885 18 04       0167        jr @start
0B4887 76 61 6C 00 0168        asciz "val"
0B488B             0169    @start:
0B488B CD F2 49 0B 0170        call get_arg_float
0B488F CD 1F 46 0B 0171        call print_float_dec
0B4893 CD 88 02 0B 0172        call printNewLine
0B4897 C9          0173        ret
0B4898             0174    
0B4898             0175    ; TWO-NUMBER OPERATORS
0B4898             0176    operator:
0B4898 B6 48 0B    0177        dl addition
0B489B CB 48 0B    0178        dl subtract
0B489E E4 48 0B    0179        dl multiply
0B48A1 FB 48 0B    0180        dl divide
0B48A4 14 49 0B    0181        dl tan
0B48A7 1B 49 0B    0182        dl atan2
0B48AA 24 49 0B    0183        dl polar2cart
0B48AD 56 49 0B    0184        dl cart2polar
0B48B0 D7 49 0B    0185        dl shift
0B48B3 00 00 00    0186        dl 0x000000 ; list terminator
0B48B6             0187    addition:
0B48B6 18 02       0188        jr @start
0B48B8 2B 00       0189        asciz "+"
0B48BA             0190    @start:
0B48BA CD C4 3E 0B 0191        call POP5 ; DED'E'B = arg1
0B48BE CD 04 34 0B 0192        call FADD ; HLH'L'C + DED'E'B --> HLH'L'C
0B48C2 3E 3D       0193        ld a,'='
0B48C4 5B D7       0194        rst.lil $10
0B48C6 CD 1F 46 0B 0195        call print_float_dec
0B48CA C9          0196        ret
0B48CB             0197    subtract:
0B48CB 18 02       0198        jr @start
0B48CD 2D 00       0199        asciz "-"
0B48CF             0200    @start:
0B48CF CD C4 3E 0B 0201        call POP5 ; DED'E'B = arg1
0B48D3 CD B6 30 0B 0202        call SWAP ; HLH'L'C <--> DED'E'B
0B48D7 CD EB 33 0B 0203        call FSUB ; HLH'L'C - DED'E'B --> HLH'L'C
0B48DB 3E 3D       0204        ld a,'='
0B48DD 5B D7       0205        rst.lil $10
0B48DF CD 1F 46 0B 0206        call print_float_dec
0B48E3 C9          0207        ret
0B48E4             0208    multiply:
0B48E4 18 02       0209        jr @start
0B48E6 2A 00       0210        asciz "*"
0B48E8             0211    @start:
0B48E8 3E 08       0212        ld a,8 ; 8 fractional bits output
0B48EA 06 08       0213        ld b,8 ; 8 fractional bits input arg1
0B48EC 0E 08       0214        ld c,8 ; 8 fractional bits input arg2
0B48EE CD FC 0A 0B 0215        call smulfx ; hl = hl * de
0B48F2 CD 92 06 0B 0216        call print_hex_hl
0B48F6 CD 4D 04 0B 0217        call print_s168_hl
0B48FA C9          0218        ret
0B48FB             0219    divide:
0B48FB 18 02       0220        jr @start
0B48FD 2F 00       0221        asciz "/"
0B48FF             0222    @start:
0B48FF CD 22 0C 0B 0223        call sdiv168
0B4903 CD C2 06 0B 0224        call print_hex_de
0B4907 CD 6B 04 0B 0225        call print_s168_de
0B490B CD 92 06 0B 0226        call print_hex_hl ; remainder
0B490F CD 4D 04 0B 0227        call print_s168_hl ; remainder
0B4913 C9          0228        ret
0B4914             0229    tan:
0B4914 18 04       0230        jr @start
0B4916 74 61 6E 00 0231        asciz "tan"
0B491A             0232    @start:
0B491A             0233        ; call tan168
0B491A C9          0234        ret
0B491B             0235    atan2:
0B491B 18 06       0236        jr @start
0B491D 61 74 61 6E 0237        asciz "atan2"
       32 00       
0B4923             0238    @start:
0B4923             0239        ; call atan2_168
0B4923 C9          0240        ret
0B4924             0241    polar2cart:
0B4924 18 0B       0242        jr @start
0B4926 70 6F 6C 61 0243        asciz "polar2cart"
       72 32 63 61 
       72 74 00    
0B4931             0244    @start:
0B4931 CD 34 0D 0B 0245        call deg_360_to_256
0B4935 CD 92 06 0B 0246        call print_hex_hl
0B4939 CD 4D 04 0B 0247        call print_s168_hl
0B493D CD 95 0D 0B 0248        call polar_to_cartesian
0B4941 CD 88 02 0B 0249        call printNewLine
0B4945 CD A9 06 0B 0250        call print_hex_bc
0B4949 CD 5A 04 0B 0251        call print_s168_bc
0B494D CD C2 06 0B 0252        call print_hex_de
0B4951 CD 6B 04 0B 0253        call print_s168_de
0B4955 C9          0254        ret
0B4956             0255    cart2polar:
0B4956 18 0B       0256        jr @start
0B4958 63 61 72 74 0257        asciz "cart2polar"
       32 70 6F 6C 
       61 72 00    
0B4963             0258    @start:
0B4963             0259        ; call cartesian_to_polar
0B4963 C9          0260        ret
0B4964             0261    
0B4964             0262    function:
0B4964 73 49 0B    0263        dl sin
0B4967 92 49 0B    0264        dl cos
0B496A B1 49 0B    0265        dl sqrt
0B496D C1 49 0B    0266        dl deg256
0B4970 00 00 00    0267        dl 0x000000 ; list terminator
0B4973             0268    sin:
0B4973 18 04       0269        jr @start
0B4975 73 69 6E 00 0270        asciz "sin"
0B4979             0271    @start:
0B4979 CD 34 0D 0B 0272        call deg_360_to_256
0B497D CD 92 06 0B 0273        call print_hex_hl
0B4981 CD 4D 04 0B 0274        call print_s168_hl
0B4985 CD 5B 0D 0B 0275        call sin168
0B4989 CD 92 06 0B 0276        call print_hex_hl
0B498D CD 4D 04 0B 0277        call print_s168_hl
0B4991 C9          0278        ret
0B4992             0279    cos:
0B4992 18 04       0280        jr @start
0B4994 63 6F 73 00 0281        asciz "cos"
0B4998             0282    @start:
0B4998 CD 34 0D 0B 0283        call deg_360_to_256
0B499C CD 92 06 0B 0284        call print_hex_hl
0B49A0 CD 4D 04 0B 0285        call print_s168_hl
0B49A4 CD 56 0D 0B 0286        call cos168
0B49A8 CD 92 06 0B 0287        call print_hex_hl
0B49AC CD 4D 04 0B 0288        call print_s168_hl
0B49B0 C9          0289        ret
0B49B1             0290    sqrt:
0B49B1 18 05       0291        jr @start
0B49B3 73 71 72 74 0292        asciz "sqrt"
       00          
0B49B8             0293    @start:
0B49B8 CD 49 0C 0B 0294        call sqrt168
0B49BC CD 4D 04 0B 0295        call print_s168_hl
0B49C0 C9          0296        ret
0B49C1             0297    deg256:
0B49C1 18 07       0298        jr @start
0B49C3 64 65 67 32 0299        asciz "deg256"
       35 36 00    
0B49CA             0300    @start:
0B49CA CD 34 0D 0B 0301        call deg_360_to_256
0B49CE CD 92 06 0B 0302        call print_hex_hl
0B49D2 CD 4D 04 0B 0303        call print_s168_hl
0B49D6 C9          0304        ret
0B49D7             0305    shift:
0B49D7 18 06       0306        jr @start
0B49D9 73 68 69 66 0307        asciz "shift"
       74 00       
0B49DF             0308    @start:
0B49DF DD 21 06 0A 0309        ld ix,arith24uhl ; pointer to output buffer
       0B          
0B49E4 7A          0310        ld a,d ; integer portion of ude is number of bits to shift
0B49E5 CD 30 0A 0B 0311        call shift_hlu
0B49E9 CD 92 06 0B 0312        call print_hex_hl
0B49ED CD 4D 04 0B 0313        call print_s168_hl
0B49F1 C9          0314        ret
0B49F2             0315    
0B49F2             0316    ; ========== HELPER FUNCTIONS ==========
0B49F2             0317    ; get the next argument after ix as a floating point number
0B49F2             0318    ; inputs: ix = pointer to the argument string
0B49F2             0319    ; outputs: HLH'L'C = floating point number, ix points to the next argument
0B49F2             0320    ; destroys: everything except iy, including prime registers
0B49F2             0321    get_arg_float:
0B49F2 ED 32 03    0322        lea ix,ix+3 ; point to the next argument
0B49F5 DD E5       0323        push ix ; preserve
0B49F7 DD 37 00    0324        ld ix,(ix)  ; point to argument string
0B49FA CD E9 36 0B 0325        call VAL ; convert the string to a float
0B49FE DD E1       0326        pop ix ; restore
0B4A00 C9          0327        ret ; return with the value in HLH'L'C
0B4A01             0328    
0B4A01             0329    ; get the next argument after ix as a string
0B4A01             0330    ; inputs: ix = pointer to the argument string
0B4A01             0331    ; outputs: HL = pointer to the argument string, ix points to the next argument
0B4A01             0332    ; destroys: a, h, l, f
0B4A01             0333    get_arg_text:
0B4A01 ED 32 03    0334        lea ix,ix+3 ; point to the next argument
0B4A04 DD 27 00    0335        ld hl,(ix)  ; get the argument string
0B4A07 C9          0336        ret
0B4A08             0337    
0B4A08             0338    ; get the next argument after ix as a signed 16.8 fixed point number
0B4A08             0339    ; inputs: ix = pointer to the argument string
0B4A08             0340    ; outputs: ude = signed 16.8 fixed point number
0B4A08             0341    ; destroys: a, d, e, h, l, f
0B4A08             0342    get_arg_s168:
0B4A08 ED 32 03    0343        lea ix,ix+3 ; point to the next argument
0B4A0B DD 27 00    0344        ld hl,(ix)  ; get the argument string
0B4A0E CD 94 01 0B 0345        call asc_to_s168 ; convert the string to a number
0B4A12 C9          0346        ret ; return with the value in DE
0B4A13             0347    
0B4A13             0348    ; Inputs: ix = pointer to the argument string
0B4A13             0349    ; Outputs: ude = signed 24-bit integer
0B4A13             0350    ; Destroys: a, d, e, h, l, f
0B4A13             0351    get_arg_s24:
0B4A13 ED 32 03    0352        lea ix,ix+3 ; point to the next argument
0B4A16 DD 27 00    0353        ld hl,(ix)  ; get the argument string
0B4A19 CD 45 01 0B 0354        call asc_to_s24 ; convert the string to a number
0B4A1D C9          0355        ret ; return with the value in DE
0B4A1E             0356    
0B4A1E             0357    get_plot_coords:
0B4A1E             0358    ; get the move coordinates
0B4A1E ED 32 03    0359        lea ix,ix+3 ; pointer to next argument address
0B4A21 DD 27 00    0360        ld hl,(ix)  ; pointer to the x coordinate string
0B4A24 CD 94 01 0B 0361        call asc_to_s168 ; de = x coordinate
0B4A28 D5          0362        push de
0B4A29 C1          0363        pop bc ; bc = x coordinate
0B4A2A ED 32 03    0364        lea ix,ix+3 ; pointer to next argument address
0B4A2D DD 27 00    0365        ld hl,(ix)  ; pointer to the y coordinate string
0B4A30 CD 94 01 0B 0366        call asc_to_s168 ; de = y coordinate
0B4A34 C9          0367        ret
0B4A35             0368    
0B4A35             0369    ; match the next argument after ix to the dispatch table at iy
0B4A35             0370    ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B4A35             0371    ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B4A35             0372    ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B4A35             0373    ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B4A35             0374    ; destroys: a, hl, de, ix, iy, flags
0B4A35             0375    match_next:
0B4A35 ED 32 03    0376        lea ix,ix+3         ; point to the next argument
0B4A38             0377    @loop:
0B4A38 FD 27 00    0378        ld hl,(iy)          ; pointer argument dispatch record
0B4A3B             0379        sign_hlu            ; check for list terminator
0B4A3B 19          0001M           add hl,de
0B4A3C B7          0002M           or a
0B4A3D ED 52       0003M           sbc hl,de
0B4A3F CA 57 4A 0B 0380        jp z,@no_match      ; if a=0, return error
0B4A43 23          0381        inc hl              ; skip over jp instruction
0B4A44 23          0382        inc hl
0B4A45 DD 17 00    0383        ld de,(ix)          ; pointer to the argument string
0B4A48 CD 6E 4A 0B 0384        call str_equal      ; compare the argument to the dispatch table entry
0B4A4C CA 59 4A 0B 0385        jp z,@match         ; if equal, return success
0B4A50 ED 33 03    0386        lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B4A53 C3 38 4A 0B 0387        jp @loop            ; and loop
0B4A57             0388    @no_match:
0B4A57 3C          0389        inc a               ; no match so return a=1 and zero flag reset
0B4A58 C9          0390        ret
0B4A59             0391    @match:
0B4A59 FD 37 00    0392        ld iy,(iy)          ; get the function pointer
0B4A5C C9          0393        ret                 ; return a=0 and zero flag set
0B4A5D             0394    
0B4A5D             0395    ; same as match_next, but prints the parameter if a match is found
0B4A5D             0396    match_next_and_print:
0B4A5D CD 35 4A 0B 0397        call match_next
0B4A61 C0          0398        ret nz ; no match found
0B4A62 ED 32 FD    0399        lea ix,ix-3
0B4A65 CD 01 4A 0B 0400        call get_arg_text ; hl points to the operator string
0B4A69 CD 79 4A 0B 0401        call print_param
0B4A6D C9          0402        ret
0B4A6E             0403    
0B4A6E             0404    ; compare two zero-terminated strings for equality, case-sensitive
0B4A6E             0405    ; hl: pointer to first string, de: pointer to second string
0B4A6E             0406    ; returns: z if equal, nz if not equal
0B4A6E             0407    ; destroys: a, hl, de
0B4A6E             0408    str_equal:
0B4A6E 1A          0409        ld a,(de)           ; get the first character
0B4A6F BE          0410        cp (hl)             ; compare to the second character
0B4A70 C0          0411        ret nz              ; if not equal, return
0B4A71 B7          0412        or a
0B4A72 C8          0413        ret z               ; if equal and zero, return
0B4A73 23          0414        inc hl              ; next character
0B4A74 13          0415        inc de
0B4A75 C3 6E 4A 0B 0416        jp str_equal        ; loop until end of string
0B4A79             0417    
0B4A79             0418    ; print the parameter string pointed to by ix
0B4A79             0419    ; destroys: a, hl
0B4A79             0420    print_param:
0B4A79 DD 27 00    0421        ld hl,(ix)          ; get the parameter pointer
0B4A7C CD 73 02 0B 0422        call printString    ; print the parameter string
0B4A80 3E 20       0423        ld a,' '            ; print a space separator
0B4A82 5B D7       0424        rst.lil $10
0B4A84 C9          0425        ret
0B4A85             0426    
0B4A85             0427    ; print the parameters
0B4A85             0428    ; inputs: b = number of parameters, ix = pointer to the parameters
0B4A85             0429    ; destroys: a, hl, bc
0B4A85             0430    print_params:
0B4A85 41          0431        ld b,c              ; loop counter = number of parameters
0B4A86 DD E5       0432        push ix             ; save the pointer to the parameters
0B4A88             0433    @loop:
0B4A88 C5          0434        push bc             ; save the loop counter
0B4A89 CD 79 4A 0B 0435        call print_param    ; print the parameter
0B4A8D ED 32 03    0436        lea ix,ix+3         ; next parameter pointer
0B4A90 C1          0437        pop bc              ; get back the loop counter
0B4A91 10 F5       0438        djnz @loop          ; loop until done
0B4A93 DD E1       0439        pop ix              ; restore the pointer to the parameters
0B4A95 C9          0440        ret
0B4A96             0441    
0B4A96             0442    debug_print:
0B4A96 CD 88 02 0B 0443        call printNewLine
0B4A9A CD 85 06 0B 0444        call dumpRegistersHexAll
0B4A9E CD 88 02 0B 0445        call printNewLine
0B4AA2 C9          0446        ret
0B4AA3             0447    
