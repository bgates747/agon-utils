PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "flower.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 66 6C 6F 77 0001*M     ASCIZ "flower.bin"
       65 72 2E 62 
       69 6E 00    
0B000F             0025*  
0B000F FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD 93 18 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  signed_asc_to_int:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 97 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F CD B2 00 0B 0108*      call _skip_spaces ; skip whitespace
0B0153             0109*  
0B0153 7E          0110*      ld a, (hl) ; read first character
0B0154 B7          0111*      or a ; check for end of string
0B0155 C8          0112*      ret z ; return with no carry if not
0B0156             0113*  
0B0156 C5          0114*      push bc ; preserve bc
0B0157             0115*  
0B0157 FE 2D       0116*      cp '-' ; check for negative number
0B0159 C2 63 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B015D AF          0118*      xor a ; sign flag to zero
0B015E 32 97 01 0B 0119*      ld (@sign),a ; store sign flag
0B0162 23          0120*      inc hl ; skip '-'
0B0163             0121*  
0B0163             0122*  @loop:
0B0163 7E          0123*      ld a, (hl)
0B0164 D6 30       0124*      sub '0' ; normalise to 0
0B0166 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0168 FE 0A       0126*      cp 10 ; check if >= 10
0B016A 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B016C E5          0128*      push hl ; stack hl
0B016D D5          0129*      push de ; ld hl, de
0B016E E1          0130*      pop hl
0B016F E5          0131*      push hl ; ld bc, hl
0B0170 C1          0132*      pop bc
0B0171 29          0133*      add hl, hl ; x 2
0B0172 29          0134*      add hl, hl ; x 4
0B0173 09          0135*      add hl, bc ; x 5
0B0174 29          0136*      add hl, hl ; x 10
0B0175 01 00 00 00 0137*      ld bc, 0
0B0179 4F          0138*      ld c, a ; ld bcu, a
0B017A 09          0139*      add hl, bc ; add bcu to hl
0B017B E5          0140*      push hl ; ld de, hl
0B017C D1          0141*      pop de
0B017D E1          0142*      pop hl ; restore hl
0B017E 23          0143*      inc hl
0B017F 18 E2       0144*      jr @loop
0B0181             0145*  
0B0181             0146*  @integer_end:
0B0181 C1          0147*      pop bc ; send bc back how she came in
0B0182 3A 97 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0186 3D          0149*      dec a ; check if negative
0B0187 F2 95 01 0B 0150*      jp p,@pos ; positive number
0B018B             0151*  
0B018B             0152*  ; Negate de
0B018B E5          0153*      push hl ; save text pointer
0B018C 21 00 00 00 0154*      ld hl, 0
0B0190 AF          0155*      xor a ; clear carry
0B0191 ED 52       0156*      sbc hl, de ; subtract DE from HL
0B0193 EB          0157*      ex de, hl ; DE = 0-HL
0B0194 E1          0158*      pop hl ; restore text pointer
0B0195             0159*  
0B0195             0160*  @pos:
0B0195 37          0161*      scf ; we have a valid number so set carry
0B0196 C9          0162*      ret
0B0197             0163*  
0B0197 00          0164*  @sign: db 0 ; sign flag buffer
0B0198             0165*  
0B0198             0166*  
0B0198             0167*  ;------------------------------------------------------------------------
0B0198             0168*  ; Read a number and convert to binary (decimal only)
0B0198             0169*  ; Inputs: hl: Pointer in string buffer
0B0198             0170*  ; Outputs: hl: Updated text pointer
0B0198             0171*  ;         de: Value
0B0198             0172*  ;         a: Terminator (spaces skipped)
0B0198             0173*  ;         f: Carry set if valid number, otherwise reset
0B0198             0174*  ; Destroys: a, d, e, h, l, f
0B0198             0175*  ;------------------------------------------------------------------------
0B0198             0176*  signed_asc_to_168:
0B0198 3E 01       0177*      ld a,1 ; set sign flag
0B019A 32 57 02 0B 0178*      ld (@sign),a ; store sign flag
0B019E             0179*  
0B019E 11 00 00 00 0180*      ld de, 0 ; initialise de
0B01A2 ED 53 4F 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A7 ED 53 53 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01AC             0183*  
0B01AC CD B2 00 0B 0184*      call _skip_spaces ; skip whitespace
0B01B0             0185*  
0B01B0 7E          0186*      ld a, (hl) ; read first character
0B01B1 B7          0187*      or a ; check for end of string
0B01B2 C8          0188*      ret z ; return with no carry if not
0B01B3             0189*  
0B01B3 C5          0190*      push bc ; preserve bc
0B01B4             0191*  
0B01B4 FE 2D       0192*      cp '-' ; check for negative number
0B01B6 C2 C0 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01BA AF          0194*      xor a ; sign flag to zero
0B01BB 32 57 02 0B 0195*      ld (@sign),a ; store sign flag
0B01BF 23          0196*      inc hl ; skip '-'
0B01C0             0197*  
0B01C0             0198*  @loop:
0B01C0 7E          0199*      ld a, (hl)
0B01C1             0200*  
0B01C1             0201*  ; chcek for decimal point
0B01C1 FE 2E       0202*      cp '.' ; check for decimal point
0B01C3 CA 04 02 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01C7             0204*  
0B01C7             0205*  ; process integer part
0B01C7 D6 30       0206*      sub '0' ; normalise to 0
0B01C9 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01CB FE 0A       0208*      cp 10 ; check if >= 10
0B01CD 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01CF E5          0210*      push hl ; stack hl
0B01D0 D5          0211*      push de ; ld hl, de
0B01D1 E1          0212*      pop hl
0B01D2 E5          0213*      push hl ; ld bc, hl
0B01D3 C1          0214*      pop bc
0B01D4 29          0215*      add hl, hl ; x 2
0B01D5 29          0216*      add hl, hl ; x 4
0B01D6 09          0217*      add hl, bc ; x 5
0B01D7 29          0218*      add hl, hl ; x 10
0B01D8 01 00 00 00 0219*      ld bc, 0
0B01DC 4F          0220*      ld c, a ; ld bcu, a
0B01DD 09          0221*      add hl, bc ; add bcu to hl
0B01DE E5          0222*      push hl ; ld de, hl
0B01DF D1          0223*      pop de
0B01E0 E1          0224*      pop hl ; restore hl
0B01E1 23          0225*      inc hl
0B01E2 18 DC       0226*      jr @loop
0B01E4             0227*  
0B01E4             0228*  @integer_end:
0B01E4 ED 53 50 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E9             0230*  
0B01E9             0231*  @end:
0B01E9 C1          0232*      pop bc ; send bc back how she came in
0B01EA ED 5B 4F 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01EF 3A 57 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01F3 3D          0235*      dec a ; check if negative
0B01F4 F2 02 02 0B 0236*      jp p,@pos ; positive number
0B01F8             0237*  
0B01F8             0238*  ; Negate de
0B01F8 E5          0239*      push hl ; save text pointer
0B01F9 21 00 00 00 0240*      ld hl, 0
0B01FD AF          0241*      xor a ; clear carry
0B01FE ED 52       0242*      sbc hl, de ; subtract DE from HL
0B0200 EB          0243*      ex de, hl ; DE = 0-HL
0B0201 E1          0244*      pop hl ; restore text pointer
0B0202             0245*  
0B0202             0246*  @pos:
0B0202 37          0247*      scf ; we have a valid number so set carry
0B0203 C9          0248*      ret
0B0204             0249*  
0B0204             0250*  @fractional_start:
0B0204 ED 53 50 02 0251*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0209 06 03       0252*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B020B 11 00 00 00 0253*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B020F DD 21 58 02 0254*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0214 23          0255*      inc hl                     ; Skip decimal point
0B0215             0256*  
0B0215             0257*  @fractional_loop:
0B0215 7E          0258*      ld a, (hl)                 ; Load next character
0B0216 D6 30       0259*      sub '0'                    ; Normalize ASCII to decimal
0B0218 38 1C       0260*      jr c, @end_fraction        ; Exit if < '0'
0B021A FE 0A       0261*      cp 10
0B021C 30 18       0262*      jr nc, @end_fraction       ; Exit if >= 10
0B021E             0263*  
0B021E             0264*      ; Multiply the current fractional accumulator by 10
0B021E E5          0265*      push hl                    ; Save char pointer
0B021F F5          0266*      push af                    ; Save the digit
0B0220 EB          0267*      ex de, hl
0B0221 E5          0268*      push hl
0B0222 29          0269*      add hl,hl ; * 2
0B0223 29          0270*      add hl,hl ; * 4
0B0224 D1          0271*      pop de
0B0225 19          0272*      add hl,de ; * 5
0B0226 29          0273*      add hl,hl ; * 10
0B0227 11 00 00 00 0274*      ld de, 0                   ; Clear DEU
0B022B F1          0275*      pop af                     ; Restore the current digit
0B022C 5F          0276*      ld e, a                    ; Load the digit into E
0B022D 19          0277*      add hl, de                 ; Add the digit to the accumulator
0B022E EB          0278*      ex de, hl                  ; Result back to DE
0B022F ED 32 03    0279*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0232 E1          0280*      pop hl                     ; Restore char pointer
0B0233 23          0281*      inc hl                     ; Move to the next character
0B0234 10 DF       0282*      djnz @fractional_loop      ; Loop if more digits to process
0B0236             0283*  
0B0236             0284*  @end_fraction:
0B0236             0285*  ; Final scaling based on number of fractional digits processed
0B0236 ED 53 54 02 0286*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B023B 2A 53 02 0B 0287*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B023F             0288*  
0B023F DD 17 00    0289*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0242 CD AA 0D 0B 0290*      call udiv24                ; Perform 24-bit division to scale down
0B0246 7B          0291*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0247 32 4F 02 0B 0292*      ld (@result), a            ; Store fractional part in result buffer
0B024B C3 E9 01 0B 0293*      jp @end                    ; Final sign check and flag setup
0B024F             0294*  
0B024F             0295*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0253             0296*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0257 00          0297*  @sign: db 0                    ; Sign flag buffer
0B0258             0298*  
0B0258             0299*  powers_of_10:
0B0258 01 00 00    0300*      dl 1                       ; 10^0
0B025B 0A 00 00    0301*      dl 10                      ; 10^1
0B025E 64 00 00    0302*      dl 100                     ; 10^2
0B0261 E8 03 00    0303*      dl 1000                    ; 10^3
0B0264 10 27 00    0304*      dl 10000                   ; 10^4
0B0267             0017   
0B0267             0018   ; API INCLUDES
0B0267             0019       include "functions.inc"
0B0267             0001*      MACRO printChar char
0B0267             0002*          LD A, char
0B0267             0003*          RST.LIL 10h
0B0267             0004*      ENDMACRO
0B0267             0005*  
0B0267             0006*  ; test the sign of HL
0B0267             0007*  ; inputs: HL obviously
0B0267             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0267             0009*  ; destroys: flags
0B0267             0010*      MACRO signHL
0B0267             0011*          add hl,de
0B0267             0012*          or a
0B0267             0013*          sbc hl,de
0B0267             0014*      ENDMACRO
0B0267             0015*  
0B0267             0016*  ; Simulated call to subroutine at HL
0B0267             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0267             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0267             0019*  ; destroys: only what the subroutine does, but always BC
0B0267             0020*      MACRO callHL
0B0267             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0022*          push bc       ; which constitutes the return address
0B0267             0023*          jp   (hl)     ; Jump to the address in HL
0B0267             0024*      ENDMACRO
0B0267             0025*  
0B0267             0026*  ; Simulated call to subroutine at IX
0B0267             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0267             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0267             0029*  ; destroys: only what the subroutine does, but always BC
0B0267             0030*      MACRO callIX
0B0267             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0032*          push bc       ; which constitutes the return address
0B0267             0033*          jp   (ix)     ; Jump to the address in IX
0B0267             0034*      ENDMACRO
0B0267             0035*  
0B0267             0036*  ; Simulated call to soubroutinte at IY
0B0267             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0267             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0267             0039*  ; destroys: only what the subroutine does, but always BC
0B0267             0040*      MACRO callIY
0B0267             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0042*          push bc       ; which constitutes the return address
0B0267             0043*          jp   (iy)     ; Jump to the address in IY
0B0267             0044*      ENDMACRO
0B0267             0045*  
0B0267             0046*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0267             0047*  ; Print a zero-terminated string
0B0267             0048*  ; HL: Pointer to string
0B0267             0049*  printString:
0B0267 C5          0050*  	PUSH	BC
0B0268 01 00 00 00 0051*  	LD		BC,0
0B026C 3E 00       0052*  	LD 	 	A,0
0B026E 5B DF       0053*  	RST.LIL 18h
0B0270 C1          0054*  	POP		BC
0B0271 C9          0055*  	RET
0B0272             0056*  ; print a VDU sequence
0B0272             0057*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0272             0058*  sendVDUsequence:
0B0272 C5          0059*  	PUSH	BC
0B0273 01 00 00 00 0060*  	LD		BC, 0
0B0277 4E          0061*  	LD		C, (HL)
0B0278 5B DF       0062*  	RST.LIL	18h
0B027A C1          0063*  	POP		BC
0B027B C9          0064*  	RET
0B027C             0065*  ; Print Newline sequence to VDP
0B027C             0066*  printNewLine:
0B027C F5          0067*      push af ; for some reason rst.lil 10h sets carry flag
0B027D 3E 0D       0068*  	LD	A, '\r'
0B027F 5B D7       0069*  	RST.LIL 10h
0B0281 3E 0A       0070*  	LD	A, '\n'
0B0283 5B D7       0071*  	RST.LIL 10h
0B0285 F1          0072*      pop af
0B0286 C9          0073*  	RET
0B0287             0074*  ; Print a 24-bit HEX number
0B0287             0075*  ; HLU: Number to print
0B0287             0076*  printHex24:
0B0287 E5          0077*  	PUSH	HL
0B0288 21 02 00 00 0078*  	LD		HL, 2
0B028C 39          0079*  	ADD		HL, SP
0B028D 7E          0080*  	LD		A, (HL)
0B028E E1          0081*  	POP		HL
0B028F CD 99 02 0B 0082*  	CALL	printHex8
0B0293             0083*  ; Print a 16-bit HEX number
0B0293             0084*  ; HL: Number to print
0B0293             0085*  printHex16:
0B0293 7C          0086*  	LD		A,H
0B0294 CD 99 02 0B 0087*  	CALL	printHex8
0B0298 7D          0088*  	LD		A,L
0B0299             0089*  ; Print an 8-bit HEX number
0B0299             0090*  ; A: Number to print
0B0299             0091*  printHex8:
0B0299 4F          0092*  	LD		C,A
0B029A 1F          0093*  	RRA
0B029B 1F          0094*  	RRA
0B029C 1F          0095*  	RRA
0B029D 1F          0096*  	RRA
0B029E CD A3 02 0B 0097*  	CALL	@F
0B02A2 79          0098*  	LD		A,C
0B02A3             0099*  @@:
0B02A3 E6 0F       0100*  	AND		0Fh
0B02A5 C6 90       0101*  	ADD		A,90h
0B02A7 27          0102*  	DAA
0B02A8 CE 40       0103*  	ADC		A,40h
0B02AA 27          0104*  	DAA
0B02AB 5B D7       0105*  	RST.LIL	10h
0B02AD C9          0106*  	RET
0B02AE             0107*  
0B02AE             0108*  ; Print a 0x HEX prefix
0B02AE             0109*  DisplayHexPrefix:
0B02AE 3E 30       0110*  	LD	A, '0'
0B02B0 5B D7       0111*  	RST.LIL 10h
0B02B2 3E 78       0112*  	LD	A, 'x'
0B02B4 5B D7       0113*  	RST.LIL 10h
0B02B6 C9          0114*  	RET
0B02B7             0115*  
0B02B7             0116*      MACRO printDecBC
0B02B7             0117*          push hl
0B02B7             0118*          push bc
0B02B7             0119*          pop hl
0B02B7             0120*          call printDec
0B02B7             0121*          pop hl
0B02B7             0122*      ENDMACRO
0B02B7             0123*  
0B02B7             0124*      MACRO printDecDE
0B02B7             0125*          push hl
0B02B7             0126*          push de
0B02B7             0127*          pop hl
0B02B7             0128*          call printDec
0B02B7             0129*          pop hl
0B02B7             0130*      ENDMACRO
0B02B7             0131*  
0B02B7             0132*      MACRO printDecHL
0B02B7             0133*          call printDec
0B02B7             0134*      ENDMACRO
0B02B7             0135*  
0B02B7             0136*      MACRO printDecIX
0B02B7             0137*          push hl
0B02B7             0138*          push ix
0B02B7             0139*          pop hl
0B02B7             0140*          call printDec
0B02B7             0141*          pop hl
0B02B7             0142*      ENDMACRO
0B02B7             0143*  
0B02B7             0144*      MACRO printDecIY
0B02B7             0145*          push hl
0B02B7             0146*          push iy
0B02B7             0147*          pop hl
0B02B7             0148*          call printDec
0B02B7             0149*          pop hl
0B02B7             0150*      ENDMACRO
0B02B7             0151*  
0B02B7             0152*  ; Prints the right justified decimal value in HL without leading zeroes
0B02B7             0153*  ; HL : Value to print
0B02B7             0154*  ; preserves all registers and flags
0B02B7             0155*  printDec:
0B02B7             0156*  ; BEGIN MY CODE
0B02B7             0157*  ; back up all the things
0B02B7 F5          0158*      push af
0B02B8 C5          0159*      push bc
0B02B9 D5          0160*      push de
0B02BA E5          0161*      push hl
0B02BB             0162*  ; END MY CODE
0B02BB 11 E3 02 0B 0163*  	LD	 DE, _printDecBuffer
0B02BF CD EC 02 0B 0164*  	CALL Num2String
0B02C3             0165*  ; BEGIN MY CODE
0B02C3             0166*  ; replace leading zeroes with spaces
0B02C3 21 E3 02 0B 0167*      LD	 HL, _printDecBuffer
0B02C7 06 07       0168*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B02C9             0169*  @loop:
0B02C9 7E          0170*      LD	 A, (HL)
0B02CA FE 30       0171*      CP	 '0'
0B02CC C2 DA 02 0B 0172*      JP	 NZ, @done
0B02D0 3E 20       0173*      LD   A, ' '
0B02D2 77          0174*      LD	 (HL), A
0B02D3 23          0175*      INC	 HL
0B02D4 CD 0F 08 0B 0176*      CALL vdu_cursor_forward
0B02D8 10 EF       0177*      DJNZ @loop
0B02DA             0178*  @done:
0B02DA             0179*  ; END MY CODE
0B02DA             0180*  	; LD	 HL, _printDecBuffer
0B02DA CD 67 02 0B 0181*  	CALL printString
0B02DE             0182*  ; BEGIN MY CODE
0B02DE             0183*  ; restore all the things
0B02DE E1          0184*      pop hl
0B02DF D1          0185*      pop de
0B02E0 C1          0186*      pop bc
0B02E1 F1          0187*      pop af
0B02E2             0188*  ; END MY CODE
0B02E2 C9          0189*  	RET
0B02E3 00 00 00 00 0190*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0B02EC             0191*  
0B02EC             0192*  ; This routine converts the value from HL into it's ASCII representation,
0B02EC             0193*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B02EC             0194*  ; so it will allways be 8 characters length
0B02EC             0195*  ; HL : Value to convert to string
0B02EC             0196*  ; DE : pointer to buffer, at least 8 byte + 0
0B02EC             0197*  Num2String:
0B02EC 01 80 69 67 0198*  	LD	 BC,-10000000
0B02F0 CD 23 03 0B 0199*  	CALL OneDigit
0B02F4 01 C0 BD F0 0200*  	LD	 BC,-1000000
0B02F8 CD 23 03 0B 0201*  	CALL OneDigit
0B02FC 01 60 79 FE 0202*  	LD	 BC,-100000
0B0300 CD 23 03 0B 0203*  	CALL OneDigit
0B0304 01 F0 D8 FF 0204*  	LD   BC,-10000
0B0308 CD 23 03 0B 0205*  	CALL OneDigit
0B030C 01 18 FC FF 0206*  	LD   BC,-1000
0B0310 CD 23 03 0B 0207*  	CALL OneDigit
0B0314 01 9C FF FF 0208*  	LD   BC,-100
0B0318 CD 23 03 0B 0209*  	CALL OneDigit
0B031C 0E F6       0210*  	LD   C,-10
0B031E CD 23 03 0B 0211*  	CALL OneDigit
0B0322 48          0212*  	LD   C,B
0B0323             0213*  OneDigit:
0B0323 3E 2F       0214*  	LD   A,'0'-1
0B0325             0215*  DivideMe:
0B0325 3C          0216*  	INC  A
0B0326 09          0217*  	ADD  HL,BC
0B0327 38 FC       0218*  	JR   C,DivideMe
0B0329 ED 42       0219*  	SBC  HL,BC
0B032B 12          0220*  	LD   (DE),A
0B032C 13          0221*  	INC  DE
0B032D C9          0222*  	RET
0B032E             0223*  
0B032E             0224*  
0B032E             0225*  ; #### new functions added by Brandon R. Gates ####
0B032E             0226*  
0B032E             0227*  ; print the binary representation of the 8-bit value in a
0B032E             0228*  ; destroys a, hl, bc
0B032E             0229*  printBin8:
0B032E 06 08       0230*      ld b,8      ; loop counter for 8 bits
0B0330 21 4B 03 0B 0231*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0334             0232*                  ; (which will be the high bit of the value in a)
0B0334             0233*  @loop:
0B0334 07          0234*      rlca ; put the next highest bit into carry
0B0335 38 04       0235*      jr c,@one
0B0337 36 30       0236*      ld (hl),'0'
0B0339 18 02       0237*      jr @next_bit
0B033B             0238*  @one:
0B033B 36 31       0239*      ld (hl),'1'
0B033D             0240*  @next_bit:
0B033D 23          0241*      inc hl
0B033E 10 F4       0242*      djnz @loop
0B0340             0243*  ; print it
0B0340 21 4B 03 0B 0244*  	ld hl,@cmd
0B0344 01 08 00 00 0245*  	ld bc,@end-@cmd
0B0348 5B DF       0246*  	rst.lil $18
0B034A C9          0247*  	ret
0B034B             0248*  @cmd: ds 8 ; eight bytes for eight bits
0B0353             0249*  @end:
0B0353             0250*  
0B0353             0251*  ; print the binary representation of the 8-bit value in a
0B0353             0252*  ; in reverse order (lsb first)
0B0353             0253*  ; destroys a, hl, bc
0B0353             0254*  printBin8Rev:
0B0353 06 08       0255*      ld b,8      ; loop counter for 8 bits
0B0355 21 70 03 0B 0256*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0359             0257*                  ; (which will be the high bit of the value in a)
0B0359             0258*  @loop:
0B0359 0F          0259*      rrca ; put the next lowest bit into carry
0B035A 38 04       0260*      jr c,@one
0B035C 36 30       0261*      ld (hl),'0'
0B035E 18 02       0262*      jr @next_bit
0B0360             0263*  @one:
0B0360 36 31       0264*      ld (hl),'1'
0B0362             0265*  @next_bit:
0B0362 23          0266*      inc hl
0B0363 10 F4       0267*      djnz @loop
0B0365             0268*  ; print it
0B0365 21 70 03 0B 0269*  	ld hl,@cmd
0B0369 01 08 00 00 0270*  	ld bc,@end-@cmd
0B036D 5B DF       0271*  	rst.lil $18
0B036F C9          0272*  	ret
0B0370             0273*  @cmd: ds 8 ; eight bytes for eight bits
0B0378             0274*  @end:
0B0378             0275*  
0B0378             0276*  ; print registers to screen in hexidecimal format
0B0378             0277*  ; inputs: none
0B0378             0278*  ; outputs: values of every register printed to screen
0B0378             0279*  ;    values of each register in global scratch memory
0B0378             0280*  ; destroys: nothing
0B0378             0281*  stepRegistersHex:
0B0378             0282*  ; store everything in scratch
0B0378 22 65 05 0B 0283*      ld (uhl),hl
0B037C ED 43 68 05 0284*      ld (ubc),bc
       0B          
0B0381 ED 53 6B 05 0285*      ld (ude),de
       0B          
0B0386 DD 22 6E 05 0286*      ld (uix),ix
       0B          
0B038B FD 22 71 05 0287*      ld (uiy),iy
       0B          
0B0390 F5          0288*      push af ; fml
0B0391 E1          0289*      pop hl  ; thanks, zilog
0B0392 22 62 05 0B 0290*      ld (uaf),hl
0B0396 F5          0291*      push af ; dammit
0B0397             0292*  
0B0397             0293*  ; home the cursor
0B0397 CD EE 07 0B 0294*      call vdu_home_cursor
0B039B             0295*  
0B039B             0296*  ; print each register
0B039B 21 E8 04 0B 0297*      ld hl,str_afu
0B039F CD 67 02 0B 0298*      call printString
0B03A3 2A 62 05 0B 0299*      ld hl,(uaf)
0B03A7 CD 87 02 0B 0300*      call printHex24
0B03AB CD 7C 02 0B 0301*      call printNewLine
0B03AF             0302*  
0B03AF 21 ED 04 0B 0303*      ld hl,str_hlu
0B03B3 CD 67 02 0B 0304*      call printString
0B03B7 2A 65 05 0B 0305*      ld hl,(uhl)
0B03BB CD 87 02 0B 0306*      call printHex24
0B03BF CD 7C 02 0B 0307*      call printNewLine
0B03C3             0308*  
0B03C3 21 F2 04 0B 0309*      ld hl,str_bcu
0B03C7 CD 67 02 0B 0310*      call printString
0B03CB 2A 68 05 0B 0311*      ld hl,(ubc)
0B03CF CD 87 02 0B 0312*      call printHex24
0B03D3 CD 7C 02 0B 0313*      call printNewLine
0B03D7             0314*  
0B03D7 21 F7 04 0B 0315*      ld hl,str_deu
0B03DB CD 67 02 0B 0316*      call printString
0B03DF 2A 6B 05 0B 0317*      ld hl,(ude)
0B03E3 CD 87 02 0B 0318*      call printHex24
0B03E7 CD 7C 02 0B 0319*      call printNewLine
0B03EB             0320*  
0B03EB 21 FC 04 0B 0321*      ld hl,str_ixu
0B03EF CD 67 02 0B 0322*      call printString
0B03F3 2A 6E 05 0B 0323*      ld hl,(uix)
0B03F7 CD 87 02 0B 0324*      call printHex24
0B03FB CD 7C 02 0B 0325*      call printNewLine
0B03FF             0326*  
0B03FF 21 01 05 0B 0327*      ld hl,str_iyu
0B0403 CD 67 02 0B 0328*      call printString
0B0407 2A 71 05 0B 0329*      ld hl,(uiy)
0B040B CD 87 02 0B 0330*      call printHex24
0B040F CD 7C 02 0B 0331*      call printNewLine
0B0413             0332*  
0B0413             0333*      ; call vsync
0B0413             0334*  
0B0413 CD 7C 02 0B 0335*      call printNewLine
0B0417             0336*  
0B0417             0337*  ; check for right shift key and quit if pressed
0B0417             0338*  	MOSCALL mos_getkbmap
0B0417 3E 1E       0001*M 			LD	A, function
0B0419 5B CF       0002*M 			RST.L	08h
0B041B             0339*  @stayhere:
0B041B             0340*  ; 7 RightShift
0B041B DD CB 00 76 0341*      bit 6,(ix+0)
0B041F 20 02       0342*      jr nz,@RightShift
0B0421 18 F8       0343*      jr @stayhere
0B0423             0344*  @RightShift:
0B0423 DD CB 0E 86 0345*      res 0,(ix+14) ; debounce the key (hopefully)
0B0427 3E 80       0346*      ld a,%10000000
0B0429 CD CE 07 0B 0347*      call multiPurposeDelay
0B042D             0348*  
0B042D             0349*  ; restore everything
0B042D 2A 65 05 0B 0350*      ld hl, (uhl)
0B0431 ED 4B 68 05 0351*      ld bc, (ubc)
       0B          
0B0436 ED 5B 6B 05 0352*      ld de, (ude)
       0B          
0B043B DD 2A 6E 05 0353*      ld ix, (uix)
       0B          
0B0440 FD 2A 71 05 0354*      ld iy, (uiy)
       0B          
0B0445 F1          0355*      pop af
0B0446             0356*  ; all done
0B0446 C9          0357*      ret
0B0447             0358*  
0B0447             0359*  ; print registers to screen in hexidecimal format
0B0447             0360*  ; inputs: none
0B0447             0361*  ; outputs: values of every register printed to screen
0B0447             0362*  ;    values of each register in global scratch memory
0B0447             0363*  ; destroys: nothing
0B0447             0364*  dumpRegistersHex:
0B0447             0365*  ; store everything in scratch
0B0447 22 65 05 0B 0366*      ld (uhl),hl
0B044B ED 43 68 05 0367*      ld (ubc),bc
       0B          
0B0450 ED 53 6B 05 0368*      ld (ude),de
       0B          
0B0455 DD 22 6E 05 0369*      ld (uix),ix
       0B          
0B045A FD 22 71 05 0370*      ld (uiy),iy
       0B          
0B045F F5          0371*      push af ; fml
0B0460 E1          0372*      pop hl  ; thanks, zilog
0B0461 22 62 05 0B 0373*      ld (uaf),hl
0B0465 F5          0374*      push af ; dammit
0B0466             0375*  
0B0466             0376*  ; home the cursor
0B0466             0377*      ; call vdu_home_cursor
0B0466             0378*      ; call printNewLine
0B0466             0379*  
0B0466             0380*  ; print each register
0B0466 21 E8 04 0B 0381*      ld hl,str_afu
0B046A CD 67 02 0B 0382*      call printString
0B046E 2A 62 05 0B 0383*      ld hl,(uaf)
0B0472 CD 87 02 0B 0384*      call printHex24
0B0476             0385*      ; call printNewLine
0B0476             0386*  
0B0476 21 ED 04 0B 0387*      ld hl,str_hlu
0B047A CD 67 02 0B 0388*      call printString
0B047E 2A 65 05 0B 0389*      ld hl,(uhl)
0B0482 CD 87 02 0B 0390*      call printHex24
0B0486             0391*      ; call printNewLine
0B0486             0392*  
0B0486 21 F2 04 0B 0393*      ld hl,str_bcu
0B048A CD 67 02 0B 0394*      call printString
0B048E 2A 68 05 0B 0395*      ld hl,(ubc)
0B0492 CD 87 02 0B 0396*      call printHex24
0B0496             0397*      ; call printNewLine
0B0496             0398*  
0B0496 21 F7 04 0B 0399*      ld hl,str_deu
0B049A CD 67 02 0B 0400*      call printString
0B049E 2A 6B 05 0B 0401*      ld hl,(ude)
0B04A2 CD 87 02 0B 0402*      call printHex24
0B04A6             0403*      ; call printNewLine
0B04A6             0404*  
0B04A6 21 FC 04 0B 0405*      ld hl,str_ixu
0B04AA CD 67 02 0B 0406*      call printString
0B04AE 2A 6E 05 0B 0407*      ld hl,(uix)
0B04B2 CD 87 02 0B 0408*      call printHex24
0B04B6             0409*      ; call printNewLine
0B04B6             0410*  
0B04B6 21 01 05 0B 0411*      ld hl,str_iyu
0B04BA CD 67 02 0B 0412*      call printString
0B04BE 2A 71 05 0B 0413*      ld hl,(uiy)
0B04C2 CD 87 02 0B 0414*      call printHex24
0B04C6             0415*      ; call printNewLine
0B04C6             0416*  
0B04C6 CD 83 08 0B 0417*      call vdu_vblank
0B04CA             0418*  
0B04CA CD 7C 02 0B 0419*      call printNewLine
0B04CE             0420*  ; restore everything
0B04CE 2A 65 05 0B 0421*      ld hl, (uhl)
0B04D2 ED 4B 68 05 0422*      ld bc, (ubc)
       0B          
0B04D7 ED 5B 6B 05 0423*      ld de, (ude)
       0B          
0B04DC DD 2A 6E 05 0424*      ld ix, (uix)
       0B          
0B04E1 FD 2A 71 05 0425*      ld iy, (uiy)
       0B          
0B04E6 F1          0426*      pop af
0B04E7             0427*  ; all done
0B04E7 C9          0428*      ret
0B04E8             0429*  
0B04E8 20 61 66 3D 0430*  str_afu: db " af=",0
       00          
0B04ED 20 68 6C 3D 0431*  str_hlu: db " hl=",0
       00          
0B04F2 20 62 63 3D 0432*  str_bcu: db " bc=",0
       00          
0B04F7 20 64 65 3D 0433*  str_deu: db " de=",0
       00          
0B04FC 20 69 78 3D 0434*  str_ixu: db " ix=",0
       00          
0B0501 20 69 79 3D 0435*  str_iyu: db " iy=",0
       00          
0B0506             0436*  
0B0506             0437*  ; print udeuhl to screen in hexidecimal format
0B0506             0438*  ; inputs: none
0B0506             0439*  ; outputs: concatenated hexidecimal udeuhl
0B0506             0440*  ; destroys: nothing
0B0506             0441*  dumpUDEUHLHex:
0B0506             0442*  ; store everything in scratch
0B0506 22 65 05 0B 0443*      ld (uhl),hl
0B050A ED 43 68 05 0444*      ld (ubc),bc
       0B          
0B050F ED 53 6B 05 0445*      ld (ude),de
       0B          
0B0514 DD 22 6E 05 0446*      ld (uix),ix
       0B          
0B0519 FD 22 71 05 0447*      ld (uiy),iy
       0B          
0B051E F5          0448*      push af
0B051F             0449*  
0B051F             0450*  ; print each register
0B051F             0451*  
0B051F 21 59 05 0B 0452*      ld hl,str_udeuhl
0B0523 CD 67 02 0B 0453*      call printString
0B0527 2A 6B 05 0B 0454*      ld hl,(ude)
0B052B CD 87 02 0B 0455*      call printHex24
0B052F 3E 2E       0456*  	ld a,'.'	; print a dot to separate the values
0B0531 5B D7       0457*  	rst.lil 10h
0B0533 2A 65 05 0B 0458*      ld hl,(uhl)
0B0537 CD 87 02 0B 0459*      call printHex24
0B053B CD 7C 02 0B 0460*      call printNewLine
0B053F             0461*  
0B053F             0462*  ; restore everything
0B053F 2A 65 05 0B 0463*      ld hl, (uhl)
0B0543 ED 4B 68 05 0464*      ld bc, (ubc)
       0B          
0B0548 ED 5B 6B 05 0465*      ld de, (ude)
       0B          
0B054D DD 2A 6E 05 0466*      ld ix, (uix)
       0B          
0B0552 FD 2A 71 05 0467*      ld iy, (uiy)
       0B          
0B0557 F1          0468*      pop af
0B0558             0469*  ; all done
0B0558 C9          0470*      ret
0B0559             0471*  
0B0559 75 64 65 2E 0472*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0562             0473*  
0B0562             0474*  ; global scratch memory for registers
0B0562 00 00 00    0475*  uaf: dl 0
0B0565 00 00 00    0476*  uhl: dl 0
0B0568 00 00 00    0477*  ubc: dl 0
0B056B 00 00 00    0478*  ude: dl 0
0B056E 00 00 00    0479*  uix: dl 0
0B0571 00 00 00    0480*  uiy: dl 0
0B0574 00 00 00    0481*  usp: dl 0
0B0577 00 00 00    0482*  upc: dl 0
0B057A             0483*  
0B057A             0484*  ; inputs: whatever is in the flags register
0B057A             0485*  ; outputs: binary representation of flags
0B057A             0486*  ;          with a header so we know which is what
0B057A             0487*  ; destroys: nothing
0B057A             0488*  ; preserves: everything
0B057A             0489*  dumpFlags:
0B057A             0490*  ; first we curse zilog for not giving direct access to flags
0B057A F5          0491*      push af ; this is so we can send it back unharmed
0B057B F5          0492*      push af ; this is so we can pop it to hl
0B057C             0493*  ; store everything in scratch
0B057C 22 65 05 0B 0494*      ld (uhl),hl
0B0580 ED 43 68 05 0495*      ld (ubc),bc
       0B          
0B0585 ED 53 6B 05 0496*      ld (ude),de
       0B          
0B058A DD 22 6E 05 0497*      ld (uix),ix
       0B          
0B058F FD 22 71 05 0498*      ld (uiy),iy
       0B          
0B0594             0499*  ; next we print the header
0B0594 21 C0 05 0B 0500*      ld hl,@header
0B0598 CD 67 02 0B 0501*      call printString
0B059C E1          0502*      pop hl ; flags are now in l
0B059D 7D          0503*      ld a,l ; flags are now in a
0B059E CD 2E 03 0B 0504*      call printBin8
0B05A2 CD 7C 02 0B 0505*  	call printNewLine
0B05A6             0506*  ; restore everything
0B05A6 2A 65 05 0B 0507*      ld hl, (uhl)
0B05AA ED 4B 68 05 0508*      ld bc, (ubc)
       0B          
0B05AF ED 5B 6B 05 0509*      ld de, (ude)
       0B          
0B05B4 DD 2A 6E 05 0510*      ld ix, (uix)
       0B          
0B05B9 FD 2A 71 05 0511*      ld iy, (uiy)
       0B          
0B05BE F1          0512*      pop af ; send her home the way she came
0B05BF C9          0513*      ret
0B05C0             0514*  ; Bit 7 (S): Sign flag
0B05C0             0515*  ; Bit 6 (Z): Zero flag
0B05C0             0516*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B05C0             0517*  ; Bit 4 (H): Half Carry flag
0B05C0             0518*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B05C0             0519*  ; Bit 2 (PV): Parity/Overflow flag
0B05C0             0520*  ; Bit 1 (N): Subtract flag
0B05C0             0521*  ; Bit 0 (C): Carry flag
0B05C0 53 5A 78 48 0522*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B05CB             0523*  
0B05CB             0524*  ; set all the bits in the flag register
0B05CB             0525*  ; more of an academic exercise than anything useful
0B05CB             0526*  ; inputs; none
0B05CB             0527*  ; outputs; a=0,f=255
0B05CB             0528*  ; destroys: flags, hl
0B05CB             0529*  ; preserves: a, because why not
0B05CB             0530*  setAllFlags:
0B05CB 21 FF 00 00 0531*      ld hl,255
0B05CF 67          0532*      ld h,a ; four cycles to preserve a is cheap
0B05D0 E5          0533*      push hl
0B05D1 F1          0534*      pop af
0B05D2 C9          0535*      ret
0B05D3             0536*  
0B05D3             0537*  ; reset all the bits in the flag register
0B05D3             0538*  ; unlike its inverse counterpart, this may actually be useful
0B05D3             0539*  ; inputs; none
0B05D3             0540*  ; outputs; a=0,f=0
0B05D3             0541*  ; destroys: flags, hl
0B05D3             0542*  ; preserves: a, because why not
0B05D3             0543*  resetAllFlags:
0B05D3 21 00 00 00 0544*      ld hl,0
0B05D7 67          0545*      ld h,a ; four cycles to preserve a is cheap
0B05D8 E5          0546*      push hl
0B05D9 F1          0547*      pop af
0B05DA C9          0548*      ret
0B05DB             0549*  
0B05DB             0550*  ; wait until user presses a key
0B05DB             0551*  ; inputs: none
0B05DB             0552*  ; outputs: none
0B05DB             0553*  ; destroys: af,ix
0B05DB             0554*  waitKeypress:
0B05DB             0555*      MOSCALL mos_sysvars
0B05DB 3E 08       0001*M 			LD	A, function
0B05DD 5B CF       0002*M 			RST.L	08h
0B05DF AF          0556*      xor a ; zero out any prior keypresses
0B05E0 DD 77 05    0557*      ld (ix+sysvar_keyascii),a
0B05E3             0558*  @loop:
0B05E3 DD 7E 05    0559*      ld a,(ix+sysvar_keyascii)
0B05E6 A7          0560*      and a
0B05E7 C0          0561*      ret nz
0B05E8 18 F9       0562*      jr @loop
0B05EA             0563*  
0B05EA             0564*  
0B05EA             0565*  ; print bytes from an address to the screen in hexidecimal format
0B05EA             0566*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B05EA             0567*  ; outputs: values of each byte printed to screen separated by spaces
0B05EA             0568*  ; destroys: nothing
0B05EA             0569*  dumpMemoryHex:
0B05EA             0570*  ; save registers to the stack
0B05EA C5          0571*      push bc
0B05EB E5          0572*      push hl
0B05EC F5          0573*      push af
0B05ED             0574*  
0B05ED             0575*  ; print the address and separator
0B05ED CD 87 02 0B 0576*      call printHex24
0B05F1 3E 3A       0577*      ld a,':'
0B05F3 5B D7       0578*      rst.lil 10h
0B05F5 3E 20       0579*      ld a,' '
0B05F7 5B D7       0580*      rst.lil 10h
0B05F9             0581*  
0B05F9             0582*  ; set b to be our loop counter
0B05F9 F1          0583*      pop af
0B05FA 47          0584*      ld b,a
0B05FB E1          0585*      pop hl
0B05FC E5          0586*      push hl
0B05FD F5          0587*      push af
0B05FE             0588*  @loop:
0B05FE             0589*  ; print the byte
0B05FE 7E          0590*      ld a,(hl)
0B05FF CD 99 02 0B 0591*      call printHex8
0B0603             0592*  ; print a space
0B0603 3E 20       0593*      ld a,' '
0B0605 5B D7       0594*      rst.lil 10h
0B0607 23          0595*      inc hl
0B0608 10 F4       0596*      djnz @loop
0B060A             0597*      ; call printNewLine
0B060A             0598*  
0B060A             0599*  ; restore everything
0B060A F1          0600*      pop af
0B060B E1          0601*      pop hl
0B060C C1          0602*      pop bc
0B060D             0603*  
0B060D             0604*  ; all done
0B060D C9          0605*      ret
0B060E             0606*  
0B060E             0607*  
0B060E             0608*  ; print bytes from an address to the screen in binary format
0B060E             0609*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B060E             0610*  ; outputs: values of each byte printed to screen separated by spaces
0B060E             0611*  ; destroys: nothing
0B060E             0612*  dumpMemoryBin:
0B060E             0613*  ; save all registers to the stack
0B060E F5          0614*      push af
0B060F C5          0615*      push bc
0B0610 D5          0616*      push de
0B0611 E5          0617*      push hl
0B0612 DD E5       0618*      push ix
0B0614 FD E5       0619*      push iy
0B0616             0620*  
0B0616             0621*  ; set b to be our loop counter
0B0616 47          0622*      ld b,a
0B0617             0623*  @loop:
0B0617             0624*  ; print the byte
0B0617 7E          0625*      ld a,(hl)
0B0618 E5          0626*      push hl
0B0619 C5          0627*      push bc
0B061A CD 2E 03 0B 0628*      call printBin8
0B061E C1          0629*      pop bc
0B061F             0630*  ; print a space
0B061F 3E 20       0631*      ld a,' '
0B0621 5B D7       0632*      rst.lil 10h
0B0623 E1          0633*      pop hl
0B0624 23          0634*      inc hl
0B0625 10 F0       0635*      djnz @loop
0B0627 CD 7C 02 0B 0636*      call printNewLine
0B062B             0637*  
0B062B             0638*  ; restore everything
0B062B FD E1       0639*      pop iy
0B062D DD E1       0640*      pop ix
0B062F E1          0641*      pop hl
0B0630 D1          0642*      pop de
0B0631 C1          0643*      pop bc
0B0632 F1          0644*      pop af
0B0633             0645*  ; all done
0B0633 C9          0646*      ret
0B0634             0647*  
0B0634             0648*  ; print bytes from an address to the screen in binary format
0B0634             0649*  ; with the bits of each byte in reverse order (lsb first)
0B0634             0650*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0634             0651*  ; outputs: values of each byte printed to screen separated by spaces
0B0634             0652*  ; destroys: nothing
0B0634             0653*  dumpMemoryBinRev:
0B0634             0654*  ; save all registers to the stack
0B0634 F5          0655*      push af
0B0635 C5          0656*      push bc
0B0636 D5          0657*      push de
0B0637 E5          0658*      push hl
0B0638 DD E5       0659*      push ix
0B063A FD E5       0660*      push iy
0B063C             0661*  
0B063C             0662*  ; set b to be our loop counter
0B063C 47          0663*      ld b,a
0B063D             0664*  @loop:
0B063D             0665*  ; print the byte
0B063D 7E          0666*      ld a,(hl)
0B063E E5          0667*      push hl
0B063F C5          0668*      push bc
0B0640 CD 53 03 0B 0669*      call printBin8Rev
0B0644 C1          0670*      pop bc
0B0645             0671*  ; print a space
0B0645 3E 20       0672*      ld a,' '
0B0647 5B D7       0673*      rst.lil 10h
0B0649 E1          0674*      pop hl
0B064A 23          0675*      inc hl
0B064B 10 F0       0676*      djnz @loop
0B064D CD 7C 02 0B 0677*      call printNewLine
0B0651             0678*  
0B0651             0679*  ; restore everything
0B0651 FD E1       0680*      pop iy
0B0653 DD E1       0681*      pop ix
0B0655 E1          0682*      pop hl
0B0656 D1          0683*      pop de
0B0657 C1          0684*      pop bc
0B0658 F1          0685*      pop af
0B0659             0686*  ; all done
0B0659 C9          0687*      ret
0B065A             0020       include "files.inc"
0B065A             0001*  ; load to onboard 8k sram
0B065A             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B065A             0021       include "timer.inc"
0B065A             0001*  ; Table 32. Timer Control Registers
0B065A             0002*  ; this constant is the base address of the timer control registers
0B065A             0003*  ; each timer takes three bytes:
0B065A             0004*  ;   0: control register
0B065A             0005*  ;   1: low byte of timer reset value
0B065A             0006*  ;   2: high byte of timer reset value
0B065A             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B065A             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B065A             0009*  TMR_CTL:     equ 80h
0B065A             0010*  
0B065A             0011*  ; Timer Control Register Bit Definitions
0B065A             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B065A             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B065A             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B065A             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B065A             0016*                              ; the TMRx_CTL register is read.
0B065A             0017*  
0B065A             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B065A             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B065A             0020*  
0B065A             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B065A             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B065A             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B065A             0024*                              ; written to the counter when the end-of-count value is reached.
0B065A             0025*  
0B065A             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B065A             0027*  CLK_DIV_256:  equ %00001100 ;
0B065A             0028*  CLK_DIV_64:   equ %00001000 ;
0B065A             0029*  CLK_DIV_16:   equ %00000100 ;
0B065A             0030*  CLK_DIV_4:    equ %00000000 ;
0B065A             0031*  
0B065A             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B065A             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B065A             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B065A             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B065A             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B065A             0037*                              ; SINGLE-PASS mode is used.
0B065A             0038*  
0B065A             0039*  ; disable/enable the programmable reload timer
0B065A             0040*  PRT_EN_0:     equ %00000000 ;
0B065A             0041*  PRT_EN_1:     equ %00000001 ;
0B065A             0042*  
0B065A             0043*  ; Table 37. Timer Input Source Select Register
0B065A             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B065A             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B065A             0046*  ;   00: System clock / CLK_DIV
0B065A             0047*  ;   01: RTC / CLK_DIV
0B065A             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B065A             0049*  ;   10: GPIO port B pin 1.
0B065A             0050*  ;   11: GPIO port B pin 1.
0B065A             0051*  TMR_ISS:   equ 92h ; register address
0B065A             0052*  
0B065A             0053*  ; Table 51. Real-Time Clock Control Register
0B065A             0054*  RTC_CTRL: equ EDh ; register address
0B065A             0055*  
0B065A             0056*  ; alarm interrupt disable/enable
0B065A             0057*  RTC_ALARM_0:    equ %00000000
0B065A             0058*  RTC_ALARM_1:    equ %10000000
0B065A             0059*  
0B065A             0060*  ; interrupt on alarm disable/enable
0B065A             0061*  RTC_INT_ENT_0:  equ %00000000
0B065A             0062*  RTC_INT_ENT_1:  equ %01000000
0B065A             0063*  
0B065A             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B065A             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B065A             0066*  
0B065A             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B065A             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B065A             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B065A             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B065A             0071*  
0B065A             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B065A             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B065A             0074*  
0B065A             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B065A             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B065A             0077*  
0B065A             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B065A             0079*                                  ; RTC counter is enabled.
0B065A             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B065A             0081*                                  ; RTC counter is disabled.
0B065A             0082*  
0B065A             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B065A             0084*  
0B065A             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B065A             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B065A 00 00 00    0087*  prt_reload: dl 0x000000
0B065D             0088*  
0B065D             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B065D             0090*  ; ;          de = number PRT interrupts during test interval
0B065D             0091*  ; prt_calibrate:
0B065D             0092*  ;     call vdu_vblank
0B065D             0093*  ; ; set a MOS timer
0B065D             0094*  ;     ld hl,120*1 ; 1 second
0B065D             0095*  ;     ld iy,tmr_test
0B065D             0096*  ;     call tmr_set
0B065D             0097*  ; ; set a PRT timer
0B065D             0098*  ;     ; ld hl,prt_reload_hardware
0B065D             0099*  ;     ; ld hl,prt_reload_emulator
0B065D             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B065D             0101*  ;     ld (prt_reload),hl
0B065D             0102*  ;     call prt_set
0B065D             0103*  ; @loop:
0B065D             0104*  ; ; check time remaining on MOS timer
0B065D             0105*  ;     call tmr_get
0B065D             0106*  ;     jp z,@done ; time expired,so quit
0B065D             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B065D             0108*  ;     jr @loop
0B065D             0109*  ; @done:
0B065D             0110*  ;     ld de,(prt_irq_counter)
0B065D             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B065D             0112*  ;     ld (prt_reload),bc
0B065D             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B065D             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B065D             0115*  ;     ld (is_emulator),a
0B065D             0116*  ;     sbc hl,de
0B065D             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B065D             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B065D             0119*  ;     ret m ; negative result means we're on hardware
0B065D             0120*  ;     inc a ; we're on emulator
0B065D             0121*  ;     ld (is_emulator),a
0B065D             0122*  ;     ld bc,prt_reload_emulator
0B065D             0123*  ;     ld (prt_reload),bc
0B065D             0124*  ;     ld hl,on_emulator
0B065D             0125*  ;     ret
0B065D             0126*  
0B065D             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B065D             0128*  
0B065D             0129*  ; set PRT timer
0B065D             0130*  prt_set:
0B065D 21 00 00 00 0131*      ld hl,0
0B0661 22 AB 06 0B 0132*      ld (prt_irq_counter),hl
0B0665 2A 5A 06 0B 0133*      ld hl,(prt_reload)
0B0669 ED 29 84    0134*      out0 ($84),l
0B066C ED 21 85    0135*  	out0 ($85),h
0B066F             0136*  ; disable timer
0B066F 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B0671 ED 39 83    0138*  	out0 ($83),a
0B0674             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B0674 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B0676 ED 39 83    0141*  	out0 ($83),a
0B0679 C9          0142*      ret
0B067A             0143*  
0B067A             0144*  ; ===============================================
0B067A             0145*  ; PRT Timer Interrupt Handling
0B067A             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B067A             0147*  ; -----------------------------------------------
0B067A             0148*  prt_irq_init:
0B067A             0149*      ; set up interrupt vector table 2
0B067A 21 00 00 00 0150*  	ld hl,0
0B067E 3A 0C 01 00 0151*  	ld a,($10c)
0B0682 6F          0152*  	ld l,a
0B0683 3A 0D 01 00 0153*  	ld a,($10d)
0B0687 67          0154*  	ld h,a
0B0688             0155*  
0B0688             0156*  	; skip over CALL ($c3)
0B0688 23          0157*  	inc hl
0B0689             0158*  	; load address of jump into vector table 2 (in ram)
0B0689 ED 27       0159*  	ld hl,(hl)
0B068B             0160*  
0B068B             0161*  	; write CALL prt_irq_handler to vector table 2
0B068B 3E C3       0162*  	ld a,$c3
0B068D 77          0163*  	ld (hl),a
0B068E 23          0164*  	inc hl
0B068F 11 96 06 0B 0165*  	ld de,prt_irq_handler
0B0693 ED 1F       0166*  	ld (hl),de
0B0695             0167*  
0B0695 C9          0168*      ret
0B0696             0169*  
0B0696             0170*  prt_irq_handler:
0B0696 F3          0171*  	di
0B0697 F5          0172*  	push af
0B0698 E5          0173*      push hl
0B0699 ED 38 83    0174*  	in0 a,($83)
0B069C 2A AB 06 0B 0175*  	ld hl,(prt_irq_counter)
0B06A0 23          0176*  	inc hl
0B06A1 22 AB 06 0B 0177*  	ld (prt_irq_counter),hl
0B06A5 E1          0178*      pop hl
0B06A6 F1          0179*  	pop af
0B06A7 FB          0180*  	ei
0B06A8 5B ED 4D    0181*  	reti.l
0B06AB             0182*  
0B06AB             0183*  prt_irq_counter:
0B06AB 00 00 00    0184*  	.dl 0
0B06AE             0185*  prt_irq_counter_saved:
0B06AE 00 00 00    0186*      .dl 0
0B06B1             0187*  
0B06B1             0188*  prt_loop_reset:
0B06B1 E5          0189*      push hl
0B06B2 21 00 00 00 0190*  	ld hl,0
0B06B6 22 AB 06 0B 0191*  	ld (prt_irq_counter),hl
0B06BA 22 1C 07 0B 0192*      ld (prt_loop_counter),hl
0B06BE 22 1F 07 0B 0193*      ld (prt_loops),hl
0B06C2 CD 5D 06 0B 0194*      call prt_set
0B06C6 E1          0195*      pop hl
0B06C7 C9          0196*      ret
0B06C8             0197*  
0B06C8             0198*  prt_loop_start:
0B06C8 E5          0199*      push hl
0B06C9 21 00 00 00 0200*  	ld hl,0
0B06CD 22 AB 06 0B 0201*  	ld (prt_irq_counter),hl
0B06D1 E1          0202*      pop hl
0B06D2 C9          0203*      ret
0B06D3             0204*  
0B06D3             0205*  prt_loop_stop:
0B06D3 E5          0206*      push hl
0B06D4 D5          0207*      push de
0B06D5 2A AB 06 0B 0208*      ld hl,(prt_irq_counter)
0B06D9 ED 5B 1C 07 0209*      ld de,(prt_loop_counter)
       0B          
0B06DE 19          0210*      add hl,de
0B06DF 22 1C 07 0B 0211*      ld (prt_loop_counter),hl
0B06E3 21 00 00 00 0212*      ld hl,0
0B06E7 22 AB 06 0B 0213*      ld (prt_irq_counter),hl
0B06EB 2A 1F 07 0B 0214*      ld hl,(prt_loops)
0B06EF 23          0215*      inc hl
0B06F0 22 1F 07 0B 0216*      ld (prt_loops),hl
0B06F4 D1          0217*      pop de
0B06F5 E1          0218*      pop hl
0B06F6 C9          0219*      ret
0B06F7             0220*  
0B06F7             0221*  ; inputs: bc = y,x text coordinates to print
0B06F7             0222*  prt_loop_print:
0B06F7 F5          0223*      push af
0B06F8 E5          0224*      push hl
0B06F9 C5          0225*      push bc
0B06FA D5          0226*      push de
0B06FB DD E5       0227*      push ix
0B06FD FD E5       0228*      push iy
0B06FF CD 14 08 0B 0229*      call vdu_move_cursor
0B0703             0230*  
0B0703 2A 1C 07 0B 0231*      ld hl,(prt_loop_counter)
0B0707 CD B7 02 0B 0232*      call printDec
0B070B             0233*  
0B070B 2A 1F 07 0B 0234*      ld hl,(prt_loops)
0B070F CD B7 02 0B 0235*      call printDec
0B0713             0236*  
0B0713 FD E1       0237*      pop iy
0B0715 DD E1       0238*      pop ix
0B0717 D1          0239*      pop de
0B0718 C1          0240*      pop bc
0B0719 E1          0241*      pop hl
0B071A F1          0242*      pop af
0B071B C9          0243*      ret
0B071C             0244*  
0B071C             0245*  prt_loop_counter:
0B071C 00 00 00    0246*      .dl 0
0B071F             0247*  prt_loops:
0B071F 00 00 00    0248*      .dl 0
0B0722             0249*  
0B0722             0250*  ; ===============================================
0B0722             0251*  ; Timer functions
0B0722             0252*  ; -----------------------------------------------
0B0722             0253*  ; set a countdown timer
0B0722             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0722             0255*  ; returns: hl = current time
0B0722             0256*  tmr_set:
0B0722 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B0725             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0725 3E 08       0001*M 			LD	A, function
0B0727 5B CF       0002*M 			RST.L	08h
0B0729 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B072C FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B072F C9          0261*      ret
0B0730             0262*  
0B0730             0263*  ; gets time remaining on a countdown timer
0B0730             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0730             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0730             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0730             0267*  tmr_get:
0B0730             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0730 3E 08       0001*M 			LD	A, function
0B0732 5B CF       0002*M 			RST.L	08h
0B0734 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B0737 FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B073A AF          0271*      xor a                   ; clear carry
0B073B ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B073D FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B0740 AF          0274*      xor a                   ; clear carry
0B0741 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B0743             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0743 C9          0277*      ret
0B0744             0278*  
0B0744 00 00 00    0279*  timestamp_now: dl 0
0B0747 00 00 00    0280*  timestamp_old: dl 0
0B074A 00 00 00    0281*  timestamp_chg: dl 0
0B074D             0282*  
0B074D             0283*  ; update the global timestamp from the system clock
0B074D             0284*  ; inputs: none
0B074D             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B074D             0286*  ;          de = current time
0B074D             0287*  ;          ix = pointer to syvars table
0B074D             0288*  ; destroys: af,hl,de,ix
0B074D             0289*  timestamp_tick:
0B074D ED 5B 44 07 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B0752 ED 53 47 07 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B0757             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0757 3E 08       0001*M 			LD	A, function
0B0759 5B CF       0002*M 			RST.L	08h
0B075B DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B075E 22 44 07 0B 0294*      ld (timestamp_now),hl   ; save current time
0B0762 AF          0295*      xor a                   ; clear carry
0B0763 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B0765 22 4A 07 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B0769 C9          0298*      ret
0B076A             0299*  
0B076A             0300*  ; set a countdown timer
0B076A             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B076A             0302*  ; requires: timestamp_tick to be called at least once before this function
0B076A             0303*  ; returns: hl = current time
0B076A             0304*  ; destroys: hl
0B076A             0305*  timestamp_tmr_set:
0B076A FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B076D 2A 44 07 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B0771 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B0774 C9          0309*      ret
0B0775             0310*  
0B0775             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B0775             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0775             0313*  ; requires: timestamp_tick to be called at least once before this function
0B0775             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0775             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0775             0316*  ; destroys: af,hl,de
0B0775             0317*  timestamp_tmr_get:
0B0775 ED 5B 44 07 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B077A FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B077D AF          0320*      xor a                   ; clear carry
0B077E ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0780 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B0783 AF          0323*      xor a                   ; clear carry
0B0784 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B0786             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0786 C9          0326*      ret
0B0787             0327*  
0B0787             0328*  ; main loop timer functions
0B0787             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B078D             0330*  
0B078D             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B078D             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B078D             0333*  ; returns: hl = current time
0B078D             0334*  ; destroys: af,hl,de,ix,iy
0B078D             0335*  tmr_main_loop_set:
0B078D FD 21 87 07 0336*      ld iy,tmr_main_loop
       0B          
0B0792 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B0795 CD 4D 07 0B 0338*      call timestamp_tick
0B0799 2A 44 07 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B079D FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B07A0 C9          0341*      ret
0B07A1             0342*  
0B07A1             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B07A1             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B07A1             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B07A1             0346*  ; destroys: af,hl,de,ix,iy
0B07A1             0347*  tmr_main_loop_get:
0B07A1 CD 4D 07 0B 0348*      call timestamp_tick
0B07A5 FD 21 87 07 0349*      ld iy,tmr_main_loop
       0B          
0B07AA CD 75 07 0B 0350*      call timestamp_tmr_get
0B07AE C9          0351*      ret
0B07AF             0352*  
0B07AF             0353*  ; set a stopwatch
0B07AF             0354*  ; returns: hl = start time
0B07AF             0355*  ; destroys: hl,ix
0B07AF             0356*  stopwatch_set:
0B07AF             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07AF 3E 08       0001*M 			LD	A, function
0B07B1 5B CF       0002*M 			RST.L	08h
0B07B3 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B07B6 22 CB 07 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B07BA C9          0360*      ret
0B07BB             0361*  
0B07BB             0362*  ; gets time elapsed on a stopwatch
0B07BB             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B07BB             0364*  ; destroys: af,hl,de,ix
0B07BB             0365*  stopwatch_get:
0B07BB             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07BB 3E 08       0001*M 			LD	A, function
0B07BD 5B CF       0002*M 			RST.L	08h
0B07BF DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B07C2 ED 5B CB 07 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B07C7 AF          0369*      xor a                   ; clear carry
0B07C8 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B07CA C9          0371*      ret
0B07CB             0372*  
0B07CB             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B07CE             0374*  
0B07CE             0375*  ; ------------------
0B07CE             0376*  ; delay routine
0B07CE             0377*  ; Author: Richard Turrnidge
0B07CE             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B07CE             0379*  ; routine waits a fixed time,then returns
0B07CE             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B07CE             0381*  ; eg. ld A,00000100b
0B07CE             0382*  
0B07CE             0383*  multiPurposeDelay:
0B07CE F5          0384*      push af
0B07CF C5          0385*      push bc
0B07D0 DD E5       0386*      push ix
0B07D2 47          0387*      ld b,a
0B07D3 3E 08       0388*      ld a,$08
0B07D5 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B07D7             0390*  
0B07D7             0391*  waitLoop:
0B07D7             0392*  
0B07D7 DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B07DA             0394*  
0B07DA             0395*                                  ;   we check if bit set is same as last time we checked.
0B07DA             0396*                                  ;   bit 0 - don't use
0B07DA             0397*                                  ;   bit 1 - changes 64 times per second
0B07DA             0398*                                  ;   bit 2 - changes 32 times per second
0B07DA             0399*                                  ;   bit 3 - changes 16 times per second
0B07DA             0400*  
0B07DA             0401*                                  ;   bit 4 - changes 8 times per second
0B07DA             0402*                                  ;   bit 5 - changes 4 times per second
0B07DA             0403*                                  ;   bit 6 - changes 2 times per second
0B07DA             0404*                                  ;   bit 7 - changes 1 times per second
0B07DA A0          0405*      and b
0B07DB 4F          0406*      ld c,a
0B07DC 3A ED 07 0B 0407*      ld a,(oldTimeStamp)
0B07E0 B9          0408*      cp c                        ; is A same as last value?
0B07E1 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B07E3 79          0410*      ld a,c
0B07E4 32 ED 07 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B07E8             0412*  
0B07E8 DD E1       0413*      pop ix
0B07EA C1          0414*      pop bc
0B07EB F1          0415*      pop af
0B07EC C9          0416*      ret
0B07ED             0417*  
0B07ED 00          0418*  oldTimeStamp:   .db 00h
0B07EE             0022       include "vdu.inc"
0B07EE             0001*  
0B07EE             0002*  ; VDU 30: Home cursor
0B07EE             0003*  vdu_home_cursor:
0B07EE 3E 1E       0004*      ld a,30
0B07F0 5B D7       0005*  	rst.lil $10
0B07F2 C9          0006*  	ret
0B07F3             0007*  
0B07F3             0008*  cursor_on:
0B07F3 21 FE 07 0B 0009*  	ld hl,@cmd
0B07F7 01 03 00 00 0010*  	ld bc,@end-@cmd
0B07FB 5B DF       0011*  	rst.lil $18
0B07FD C9          0012*  	ret
0B07FE             0013*  @cmd:
0B07FE 17 01 01    0014*  	db 23,1,1
0B0801             0015*  @end:
0B0801             0016*  
0B0801             0017*  cursor_off:
0B0801 21 0C 08 0B 0018*  	ld hl,@cmd
0B0805 01 03 00 00 0019*  	ld bc,@end-@cmd
0B0809 5B DF       0020*  	rst.lil $18
0B080B C9          0021*  	ret
0B080C             0022*  @cmd:
0B080C 17 01 00    0023*  	db 23,1,0
0B080F             0024*  @end:
0B080F             0025*  
0B080F             0026*  ; VDU 9: Move cursor forward one character
0B080F             0027*  vdu_cursor_forward:
0B080F 3E 09       0028*      ld a,9
0B0811 5B D7       0029*  	rst.lil $10
0B0813 C9          0030*  	ret
0B0814             0031*  
0B0814             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B0814             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B0814             0034*  vdu_move_cursor:
0B0814 ED 43 25 08 0035*      ld (@x0),bc
       0B          
0B0819 21 24 08 0B 0036*  	ld hl,@cmd
0B081D 01 03 00 00 0037*  	ld bc,@end-@cmd
0B0821 5B DF       0038*  	rst.lil $18
0B0823 C9          0039*  	ret
0B0824 1F          0040*  @cmd: 	db 31
0B0825 00          0041*  @x0:	db 0
0B0826 00          0042*  @y0: 	db 0
0B0827 00          0043*  @end: 	db 0 ; padding
0B0828             0044*  
0B0828             0045*  ; VDU 12: Clear text area (CLS)
0B0828             0046*  vdu_cls:
0B0828 3E 0C       0047*      ld a,12
0B082A 5B D7       0048*  	rst.lil $10
0B082C C9          0049*  	ret
0B082D             0050*  
0B082D             0051*  vdu_flip:
0B082D 21 38 08 0B 0052*  	ld hl,@cmd
0B0831 01 03 00 00 0053*  	ld bc,@end-@cmd
0B0835 5B DF       0054*  	rst.lil $18
0B0837 C9          0055*  	ret
0B0838 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B083B             0057*  @end:
0B083B             0058*  
0B083B             0059*  ; VDU 16: Clear graphics area (CLG)
0B083B             0060*  vdu_clg:
0B083B 3E 10       0061*      ld a,16
0B083D 5B D7       0062*  	rst.lil $10
0B083F C9          0063*  	ret
0B0840             0064*  
0B0840             0065*  ; COLOUR MODES
0B0840             0066*  ; Mode	Effect
0B0840             0067*  ; 0	Set on-screen pixel to target colour value
0B0840             0068*  ; 1	OR value with the on-screen pixel
0B0840             0069*  ; 2	AND value with the on-screen pixel
0B0840             0070*  ; 3	XOR value with the on-screen pixel
0B0840             0071*  ; 4	Invert the on-screen pixel
0B0840             0072*  ; 5	No operation
0B0840             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B0840             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B0840             0075*  
0B0840             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B0840             0077*  vdu_colour_text:
0B0840 32 50 08 0B 0078*  	ld (@arg),a
0B0844 21 4F 08 0B 0079*  	ld hl,@cmd
0B0848 01 02 00 00 0080*  	ld bc,@end-@cmd
0B084C 5B DF       0081*  	rst.lil $18
0B084E C9          0082*  	ret
0B084F 11          0083*  @cmd: db 17
0B0850 00          0084*  @arg: db 0
0B0851             0085*  @end:
0B0851             0086*  
0B0851             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B0851             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B0851             0089*  vdu_gcol:
0B0851 32 66 08 0B 0090*  	ld (@mode),a
0B0855 79          0091*      ld a,c
0B0856 32 67 08 0B 0092*      ld (@col),a
0B085A 21 65 08 0B 0093*  	ld hl,@cmd
0B085E 01 03 00 00 0094*  	ld bc,@end-@cmd
0B0862 5B DF       0095*  	rst.lil $18
0B0864 C9          0096*  	ret
0B0865 12          0097*  @cmd:  db 18
0B0866 00          0098*  @mode: db 0
0B0867 00          0099*  @col:  db 0
0B0868             0100*  @end:
0B0868             0101*  
0B0868             0102*  
0B0868             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B0868             0104*  ; MIND THE LITTLE-ENDIANESS
0B0868             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B0868             0106*  ; outputs; nothing
0B0868             0107*  ; destroys: a might make it out alive
0B0868             0108*  vdu_set_txt_viewport:
0B0868 ED 43 7E 08 0109*      ld (@lb),bc
       0B          
0B086D ED 53 80 08 0110*  	ld (@rt),de
       0B          
0B0872 21 7D 08 0B 0111*  	ld hl,@cmd
0B0876 01 05 00 00 0112*  	ld bc,@end-@cmd
0B087A 5B DF       0113*  	rst.lil $18
0B087C C9          0114*  	ret
0B087D 1C          0115*  @cmd:   db 28 ; set text viewport command
0B087E 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B0880 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B0882 00          0118*  @end:   db 0x00	  ; padding
0B0883             0119*  
0B0883             0120*  ; Wait for VBLANK interrupt
0B0883             0121*  vdu_vblank:
0B0883 DD E5       0122*      PUSH 	IX
0B0885             0123*  	MOSCALL	mos_sysvars
0B0885 3E 08       0001*M 			LD	A, function
0B0887 5B CF       0002*M 			RST.L	08h
0B0889 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B088C             0125*  @wait:
0B088C DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B088F 28 FB       0127*      JR	Z, @wait
0B0891 DD E1       0128*      POP	IX
0B0893 C9          0129*      RET
0B0894             0130*  
0B0894             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B0894             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B0894             0133*  ; 	because we have turned off logical screen scaling
0B0894             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B0894             0135*  ; outputs; nothing
0B0894             0136*  ; destroys: a might make it out alive
0B0894             0137*  vdu_set_gfx_viewport:
0B0894 ED 43 B4 08 0138*      ld (@x0),bc
       0B          
0B0899 FD 22 B6 08 0139*      ld (@y1),iy
       0B          
0B089E DD 22 B8 08 0140*  	ld (@x1),ix
       0B          
0B08A3 ED 53 BA 08 0141*  	ld (@y0),de
       0B          
0B08A8 21 B3 08 0B 0142*  	ld hl,@cmd
0B08AC 01 09 00 00 0143*  	ld bc,@end-@cmd
0B08B0 5B DF       0144*  	rst.lil $18
0B08B2 C9          0145*  	ret
0B08B3 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B08B4 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B08B6 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B08B8 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B08BA 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B08BC 00          0151*  @end:   db 0x00	  ; padding
0B08BD             0152*  
0B08BD             0153*  ; SCREEN MODES
0B08BD             0154*  ; ===============================
0B08BD             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B08BD             0156*  ; ---   ----  ----  ----  -------
0B08BD             0157*  ; 11    320   240   2     60hz
0B08BD             0158*  ; 139   320   240   2     60hz
0B08BD             0159*  ; 23    512   384   2     60hz
0B08BD             0160*  ; 151   512   384   2     60hz
0B08BD             0161*  ; 6     640   240   2     60hz
0B08BD             0162*  ; 134   640   240   2     60hz
0B08BD             0163*  ; 2     640   480   2     60hz
0B08BD             0164*  ; 130   640   480   2     60hz
0B08BD             0165*  ; 17    800   600   2     60hz
0B08BD             0166*  ; 145   800   600   2     60hz
0B08BD             0167*  ; 18    1024  768   2     60hz
0B08BD             0168*  ; 146   1024  768   2     60hz
0B08BD             0169*  ; ---   ----  ----  ----  -------
0B08BD             0170*  ; 10    320   240   4     60hz
0B08BD             0171*  ; 138   320   240   4     60hz
0B08BD             0172*  ; 22    512   384   4     60hz
0B08BD             0173*  ; 150   512   384   4     60hz
0B08BD             0174*  ; 5     640   240   4     60hz
0B08BD             0175*  ; 133   640   240   4     60hz
0B08BD             0176*  ; 1     640   480   4     60hz
0B08BD             0177*  ; 129   640   480   4     60hz
0B08BD             0178*  ; 16    800   600   4     60hz
0B08BD             0179*  ; 19    1024  768   4     60hz
0B08BD             0180*  ; ---   ----  ----  ----  -------
0B08BD             0181*  ; 9     320   240   16    60hz
0B08BD             0182*  ; 137   320   240   16    60hz
0B08BD             0183*  ; 21    512   384   16    60hz
0B08BD             0184*  ; 149   512   384   16    60hz
0B08BD             0185*  ; 4     640   240   16    60hz
0B08BD             0186*  ; 132   640   240   16    60hz
0B08BD             0187*  ; 0     640   480   16    60hz
0B08BD             0188*  ; 7     n/a   n/a   16    60hz
0B08BD             0189*  ; ---   ----  ----  ----  -------
0B08BD             0190*  ; 8     320   240   64    60hz
0B08BD             0191*  ; 136   320   240   64    60hz
0B08BD             0192*  ; 20    512   384   64    60hz
0B08BD             0193*  ; 3     640   240   64    60hz
0B08BD             0194*  ; ---   ----  ----  ----  -------
0B08BD             0195*  vdu_set_screen_mode:
0B08BD 32 CD 08 0B 0196*  	ld (@arg),a
0B08C1 21 CC 08 0B 0197*  	ld hl,@cmd
0B08C5 01 02 00 00 0198*  	ld bc,@end-@cmd
0B08C9 5B DF       0199*  	rst.lil $18
0B08CB C9          0200*  	ret
0B08CC 16          0201*  @cmd: db 22 ; set screen mode
0B08CD 00          0202*  @arg: db 0  ; screen mode parameter
0B08CE             0203*  @end:
0B08CE             0204*  
0B08CE             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B08CE             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B08CE             0207*  ; note: default setting on boot is scaling ON
0B08CE             0208*  vdu_set_scaling:
0B08CE 32 E0 08 0B 0209*  	ld (@arg),a
0B08D2 21 DD 08 0B 0210*  	ld hl,@cmd
0B08D6 01 04 00 00 0211*  	ld bc,@end-@cmd
0B08DA 5B DF       0212*  	rst.lil $18
0B08DC C9          0213*  	ret
0B08DD 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B08E0 00          0215*  @arg: db 0  ; scaling on/off
0B08E1             0216*  @end:
0B08E1             0217*  
0B08E1             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B08E1             0219*  ; inputs: hl=bufferId
0B08E1             0220*  vdu_buff_select:
0B08E1 22 F3 08 0B 0221*  	ld (@bufferId),hl
0B08E5 21 F0 08 0B 0222*  	ld hl,@cmd
0B08E9 01 05 00 00 0223*  	ld bc,@end-@cmd
0B08ED 5B DF       0224*  	rst.lil $18
0B08EF C9          0225*  	ret
0B08F0 17 1B 20    0226*  @cmd: db 23,27,0x20
0B08F3 00 00       0227*  @bufferId: dw 0x0000
0B08F5 00          0228*  @end: db 0x00 ; padding
0B08F6             0229*  
0B08F6             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B08F6             0231*  ; inputs: a=format; bc=width; de=height
0B08F6             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B08F6             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B08F6             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B08F6             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B08F6             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B08F6             0237*  ; 3 	Reserved for internal use by VDP (“native” format)
0B08F6             0238*  vdu_bmp_create:
0B08F6 ED 43 12 09 0239*      ld (@width),bc
       0B          
0B08FB ED 53 14 09 0240*      ld (@height),de
       0B          
0B0900 32 16 09 0B 0241*      ld (@fmt),a
0B0904 21 0F 09 0B 0242*  	ld hl,@cmd
0B0908 01 08 00 00 0243*  	ld bc,@end-@cmd
0B090C 5B DF       0244*  	rst.lil $18
0B090E C9          0245*  	ret
0B090F 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B0912 00 00       0247*  @width:     dw 0x0000
0B0914 00 00       0248*  @height:    dw 0x0000
0B0916 00          0249*  @fmt:       db 0x00
0B0917             0250*  @end:
0B0917             0251*  
0B0917             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B0917             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B0917             0254*  vdu_load_img_rgba2_to_8:
0B0917             0255*  ; backup the target buffer id and image dimensions
0B0917 E5          0256*      push hl
0B0918 D5          0257*      push de
0B0919 C5          0258*      push bc
0B091A             0259*  ; load the rgba2 image to working buffer 65534
0B091A 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B091E CD 21 0A 0B 0261*  	call vdu_load_buffer_from_file
0B0922             0262*  ; restore the image dimensions and target buffer id
0B0922 C1          0263*      pop bc
0B0923 D1          0264*      pop de
0B0924 E1          0265*      pop hl
0B0925             0266*  ; fall through to vdu_rgba2_to_8
0B0925             0267*  
0B0925             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B0925             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B0925             0270*  ; the "expand bitmap" command is:
0B0925             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0925             0272*  ; and then to reverse the byte order to fix endian-ness:
0B0925             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0925             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0925             0275*  ; VDU 23,27,&20,targetBufferID%;
0B0925             0276*  ; VDU 23,27,&21,width%;height%;0
0B0925             0277*  ; -------------------------------------------------------------------
0B0925             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B0925             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B0925             0280*  vdu_rgba2_to_8:
0B0925             0281*  ; load the image dimensions and buffer id parameters
0B0925 ED 43 81 09 0282*      ld (@width),bc
       0B          
0B092A ED 53 83 09 0283*      ld (@height),de
       0B          
0B092F 22 66 09 0B 0284*      ld (@bufferId0),hl
0B0933 22 73 09 0B 0285*      ld (@bufferId2),hl
0B0937 22 7C 09 0B 0286*      ld (@bufferId1),hl
0B093B             0287*  ; clean up bytes that got stomped on by the ID loads
0B093B 3E 48       0288*      ld a,0x48
0B093D 32 68 09 0B 0289*      ld (@bufferId0+2),a
0B0941 3E 17       0290*      ld a,23
0B0943 32 7E 09 0B 0291*      ld (@bufferId1+2),a
0B0947 3E 18       0292*      ld a,24
0B0949 32 75 09 0B 0293*      ld (@bufferId2+2),a
0B094D AF          0294*      xor a
0B094E 32 85 09 0B 0295*      ld (@height+2),a
0B0952             0296*  ; send the vdu command strings
0B0952 21 5D 09 0B 0297*      ld hl,@beg
0B0956 01 29 00 00 0298*      ld bc,@end-@beg
0B095A 5B DF       0299*      rst.lil $18
0B095C C9          0300*      ret
0B095D             0301*  @beg:
0B095D             0302*  ; Command 14: Consolidate blocks in a buffer
0B095D             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B095D 17 00 A0    0304*      db 23,0,0xA0
0B0960 FE FF       0305*      dw 65534 ; workingBufferId
0B0962 0E          0306*      db 14 ; consolidate blocks
0B0963             0307*  ; the "expand bitmap" command is:
0B0963             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0963 17 00 A0    0309*      db 23,0,0xA0
0B0966 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B0968 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B0969 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B096A FE FF       0313*      dw 65534 ; sourceBufferId
0B096C 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B0970             0315*  ; reverse the byte order to fix endian-ness:
0B0970             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B0970             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B0970             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0970 17 00 A0    0319*      db 23,0,0xA0
0B0973 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B0975 18          0321*      db 24 ; reverse byte order
0B0976 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B0977 04 00       0323*      dw 4 ; size (4 bytes)
0B0979             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0979             0325*  ; VDU 23,27,&20,targetBufferID%;
0B0979 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B097C 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B097E             0328*  ; VDU 23,27,&21,width%;height%;0
0B097E 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B0981 00 00       0330*  @width: dw 0x0000
0B0983 00 00       0331*  @height: dw 0x0000
0B0985 00          0332*      db 0x00 ; rgba8888 format
0B0986             0333*  @end:
0B0986             0334*  
0B0986             0335*  ; scratch variables
0B0986 00 00 00    0336*  bufferId0: dl 0x000000
0B0989 00 00 00    0337*  bufferId1: dl 0x000000
0B098C             0338*  
0B098C             0339*  ; load a vdu buffer from local memory
0B098C             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B098C             0341*  vdu_load_buffer:
0B098C ED 43 B5 09 0342*      ld (@length),bc
       0B          
0B0991 D5          0343*      push de ; save data pointer
0B0992             0344*  ; send the vdu command string
0B0992 7D          0345*      ld a,l
0B0993 32 B2 09 0B 0346*      ld (@bufferId),a
0B0997 7C          0347*      ld a,h
0B0998 32 B3 09 0B 0348*      ld (@bufferId+1),a
0B099C 21 AF 09 0B 0349*      ld hl,@cmd
0B09A0 01 08 00 00 0350*      ld bc,@end-@cmd
0B09A4 5B DF       0351*      rst.lil $18
0B09A6             0352*  ; send the buffer data
0B09A6 E1          0353*      pop hl ; pointer to data
0B09A7 ED 4B B5 09 0354*      ld bc,(@length)
       0B          
0B09AC 5B DF       0355*      rst.lil $18 ; send it
0B09AE C9          0356*      ret
0B09AF             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B09AF 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B09B2 00 00       0359*  @bufferId:	dw 0x0000
0B09B4 00          0360*  		    db 0 ; load buffer
0B09B5 00 00       0361*  @length:	dw 0x0000
0B09B7 00          0362*  @end: db 0 ; padding
0B09B8             0363*  
0B09B8             0364*  ; clear a buffer
0B09B8             0365*  ; inputs: hl = bufferId
0B09B8             0366*  vdu_clear_buffer:
0B09B8 7D          0367*      ld a,l
0B09B9 32 D0 09 0B 0368*      ld (@bufferId),a
0B09BD 7C          0369*      ld a,h
0B09BE 32 D1 09 0B 0370*      ld (@bufferId+1),a
0B09C2 21 CD 09 0B 0371*      ld hl,@cmd
0B09C6 01 06 00 00 0372*      ld bc,@end-@cmd
0B09CA 5B DF       0373*      rst.lil $18
0B09CC C9          0374*      ret
0B09CD 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B09D0 00 00       0376*  @bufferId:	dw 0x0000
0B09D2 02          0377*  		    db 2 ; clear buffer
0B09D3             0378*  @end:
0B09D3             0379*  
0B09D3             0380*  vdu_clear_all_buffers:
0B09D3             0381*  ; clear all buffers
0B09D3 21 DE 09 0B 0382*      ld hl,@beg
0B09D7 01 06 00 00 0383*      ld bc,@end-@beg
0B09DB 5B DF       0384*      rst.lil $18
0B09DD C9          0385*      ret
0B09DE 17 00 A0    0386*  @beg: db 23,0,$A0
0B09E1 FF FF       0387*        dw -1 ; clear all buffers
0B09E3 02          0388*        db 2  ; command 2: clear a buffer
0B09E4             0389*  @end:
0B09E4             0390*  
0B09E4             0391*  ; Command 14: Consolidate blocks in a buffer
0B09E4             0392*  vdu_consolidate_buffer:
0B09E4             0393*  ; set parameters for vdu call
0B09E4 7D          0394*      ld a,l
0B09E5 32 FC 09 0B 0395*      ld (@bufferId),a
0B09E9 7C          0396*      ld a,h
0B09EA 32 FD 09 0B 0397*      ld (@bufferId+1),a
0B09EE 21 F9 09 0B 0398*      ld hl,@beg
0B09F2 01 06 00 00 0399*      ld bc,@end-@beg
0B09F6 5B DF       0400*      rst.lil $18
0B09F8 C9          0401*      ret
0B09F9             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B09F9 17 00 A0    0403*  @beg: db 23,0,0xA0
0B09FC 00 00       0404*  @bufferId: dw 0x0000
0B09FE 0E          0405*             db 14
0B09FF             0406*  @end:
0B09FF             0407*  
0B09FF             0408*  ; load an image file to a buffer and make it a bitmap
0B09FF             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B09FF             0410*  vdu_load_img:
0B09FF             0411*  ; back up image type and dimension parameters
0B09FF 22 86 09 0B 0412*      ld (bufferId0),hl
0B0A03 F5          0413*      push af
0B0A04 C5          0414*  	push bc
0B0A05 D5          0415*  	push de
0B0A06             0416*  ; load the image
0B0A06 CD 21 0A 0B 0417*  	call vdu_load_buffer_from_file
0B0A0A             0418*  ; now make it a bitmap
0B0A0A 2A 86 09 0B 0419*      ld hl,(bufferId0)
0B0A0E CD E4 09 0B 0420*      call vdu_consolidate_buffer
0B0A12 2A 86 09 0B 0421*      ld hl,(bufferId0)
0B0A16 CD E1 08 0B 0422*      call vdu_buff_select
0B0A1A D1          0423*  	pop de ; image height
0B0A1B C1          0424*  	pop bc ; image width
0B0A1C F1          0425*  	pop af ; image type
0B0A1D C3 F6 08 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B0A21             0427*  
0B0A21             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B0A21             0429*  vdu_load_buffer_from_file:
0B0A21 22 86 09 0B 0430*      ld (bufferId0),hl
0B0A25             0431*  
0B0A25             0432*  ; clear target buffer
0B0A25 CD B8 09 0B 0433*      call vdu_clear_buffer
0B0A29             0434*  
0B0A29             0435*  ; open the file in read mode
0B0A29             0436*  ; Open a file
0B0A29             0437*  ; HLU: Filename
0B0A29             0438*  ;   C: Mode
0B0A29             0439*  ; Returns:
0B0A29             0440*  ;   A: Filehandle, or 0 if couldn't open
0B0A29 FD E5       0441*  	push iy ; pointer to filename
0B0A2B E1          0442*  	pop hl
0B0A2C 0E 01       0443*  	ld c,fa_read
0B0A2E             0444*      MOSCALL mos_fopen
0B0A2E 3E 0A       0001*M 			LD	A, function
0B0A30 5B CF       0002*M 			RST.L	08h
0B0A32 32 6D 0A 0B 0445*      ld (@filehandle),a
0B0A36             0446*  
0B0A36             0447*  @read_file:
0B0A36             0448*  ; Read a block of data from a file
0B0A36             0449*  ;   C: Filehandle
0B0A36             0450*  ; HLU: Pointer to where to write the data to
0B0A36             0451*  ; DEU: Number of bytes to read
0B0A36             0452*  ; Returns:
0B0A36             0453*  ; DEU: Number of bytes read
0B0A36 3A 6D 0A 0B 0454*      ld a,(@filehandle)
0B0A3A 4F          0455*      ld c,a
0B0A3B 21 00 E0 B7 0456*      ld hl,filedata
0B0A3F 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B0A43             0458*      MOSCALL mos_fread
0B0A43 3E 1A       0001*M 			LD	A, function
0B0A45 5B CF       0002*M 			RST.L	08h
0B0A47             0459*  
0B0A47             0460*  ; ; DEBUG: print chunk size
0B0A47             0461*  ;     push de
0B0A47             0462*  ;     pop hl
0B0A47             0463*  ;     call printDec
0B0A47             0464*  ;     call printNewLine
0B0A47             0465*  
0B0A47             0466*  ; test de for zero bytes read
0B0A47 21 00 00 00 0467*      ld hl,0
0B0A4B AF          0468*      xor a ; clear carry
0B0A4C ED 52       0469*      sbc hl,de
0B0A4E CA 64 0A 0B 0470*      jp z,@close_file
0B0A52             0471*  
0B0A52             0472*  ; load a vdu buffer from local memory
0B0A52             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0A52 2A 86 09 0B 0474*      ld hl,(bufferId0)
0B0A56 D5          0475*      push de ; chunksize
0B0A57 C1          0476*      pop bc
0B0A58 11 00 E0 B7 0477*      ld de,filedata
0B0A5C CD 8C 09 0B 0478*      call vdu_load_buffer
0B0A60             0479*  
0B0A60             0480*  ; ; print progress breadcrumbs
0B0A60             0481*  ;     ld a,'.'
0B0A60             0482*  ;     rst.lil 10h
0B0A60             0483*  
0B0A60             0484*  ; read the next block
0B0A60 C3 36 0A 0B 0485*      jp @read_file
0B0A64             0486*  
0B0A64             0487*  ; close the file
0B0A64             0488*  @close_file:
0B0A64 3A 6D 0A 0B 0489*      ld a,(@filehandle)
0B0A68             0490*      MOSCALL mos_fclose
0B0A68 3E 0B       0001*M 			LD	A, function
0B0A6A 5B CF       0002*M 			RST.L	08h
0B0A6C C9          0491*      ret ; vdu_load_buffer_from_file
0B0A6D             0492*  
0B0A6D 00          0493*  @filehandle: db 0 ; file handle
0B0A6E 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B0A71             0495*  
0B0A71 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B0A74             0497*  
0B0A74             0498*  ; File information structure (FILINFO)
0B0A74             0499*  @filinfo:
0B0A74 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B0A78 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B0A7A 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B0A7C 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B0A7D 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B0A8A 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0B8A             0023       ; include "vdu_fonts.inc"
0B0B8A             0024       include "vdu_plot.inc"
0B0B8A             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0B8A             0002*  ; PLOT code 	(Decimal) 	Effect
0B0B8A             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B0B8A             0004*  plot_sl_both: equ 0x00
0B0B8A             0005*  
0B0B8A             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B0B8A             0007*  plot_sl_first: equ 0x08
0B0B8A             0008*  
0B0B8A             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B0B8A             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B0B8A             0011*  
0B0B8A             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B0B8A             0013*  plot_sl_last: equ 0x20
0B0B8A             0014*  
0B0B8A             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B0B8A             0016*  plot_sl_none: equ 0x28
0B0B8A             0017*  
0B0B8A             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B0B8A             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B0B8A             0020*  
0B0B8A             0021*  ; &40-&47 	64-71 	Point plot
0B0B8A             0022*  plot_pt: equ 0x40
0B0B8A             0023*  
0B0B8A             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0B0B8A             0025*  plot_lf_lr_non_bg: equ 0x48
0B0B8A             0026*  
0B0B8A             0027*  ; &50-&57 	80-87 	Triangle fill
0B0B8A             0028*  plot_tf: equ 0x50
0B0B8A             0029*  
0B0B8A             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0B0B8A             0031*  plot_lf_r_bg: equ 0x58
0B0B8A             0032*  
0B0B8A             0033*  ; &60-&67 	96-103 	Rectangle fill
0B0B8A             0034*  plot_rf: equ 0x60
0B0B8A             0035*  
0B0B8A             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0B0B8A             0037*  plot_lf_lr_fg: equ 0x60
0B0B8A             0038*  
0B0B8A             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B0B8A             0040*  plot_pf: equ 0x70
0B0B8A             0041*  
0B0B8A             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0B0B8A             0043*  plot_lf_r_non_fg: equ 0x78
0B0B8A             0044*  
0B0B8A             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B0B8A             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B0B8A             0047*  
0B0B8A             0048*  ; &90-&97 	144-151 	Circle outline
0B0B8A             0049*  plot_co: equ 0x90
0B0B8A             0050*  
0B0B8A             0051*  ; &98-&9F 	152-159 	Circle fill
0B0B8A             0052*  plot_cf: equ 0x98
0B0B8A             0053*  
0B0B8A             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B0B8A             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B0B8A             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B0B8A             0057*  
0B0B8A             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B0B8A             0059*  plot_rcm: equ 0xB8
0B0B8A             0060*  
0B0B8A             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B0B8A             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B0B8A             0063*  ; &D0-&D7 	208-215 	Not defined
0B0B8A             0064*  ; &D8-&DF 	216-223 	Not defined
0B0B8A             0065*  ; &E0-&E7 	224-231 	Not defined
0B0B8A             0066*  
0B0B8A             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0B0B8A             0068*  plot_bmp: equ 0xE8
0B0B8A             0069*  
0B0B8A             0070*  ; &F0-&F7 	240-247 	Not defined
0B0B8A             0071*  ; &F8-&FF 	248-255 	Not defined
0B0B8A             0072*  
0B0B8A             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0B0B8A             0074*  ; Agon Console8 VDP 2.2.0
0B0B8A             0075*  
0B0B8A             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B0B8A             0077*  ; Plot code 	Effect
0B0B8A             0078*  ; 0 	Move relative
0B0B8A             0079*  mv_rel: equ 0
0B0B8A             0080*  
0B0B8A             0081*  ; 1 	Plot relative in current foreground colour
0B0B8A             0082*  dr_rel_fg: equ 1
0B0B8A             0083*  
0B0B8A             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B0B8A             0085*  ; 3 	Plot relative in current background colour
0B0B8A             0086*  dr_rel_bg: equ 3
0B0B8A             0087*  
0B0B8A             0088*  ; 4 	Move absolute
0B0B8A             0089*  mv_abs: equ 4
0B0B8A             0090*  
0B0B8A             0091*  ; 5 	Plot absolute in current foreground colour
0B0B8A             0092*  dr_abs_fg: equ 5
0B0B8A             0093*  
0B0B8A             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B0B8A             0095*  ; 7 	Plot absolute in current background colour
0B0B8A             0096*  dr_abs_bg: equ 7
0B0B8A             0097*  
0B0B8A             0098*  ; Codes 0-3 use the position data provided as part of the command
0B0B8A             0099*  ; as a relative position, adding the position given to the current
0B0B8A             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B0B8A             0101*  ; as part of the command as an absolute position, setting the current
0B0B8A             0102*  ; graphical cursor position to the position given.
0B0B8A             0103*  
0B0B8A             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B0B8A             0105*  ; current pixel colour. These operations cannot currently be supported
0B0B8A             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B0B8A             0107*  ; supported. Support for these codes may be added in a future version
0B0B8A             0108*  ; of the VDP firmware.
0B0B8A             0109*  
0B0B8A             0110*  ; 16 colour palette constants
0B0B8A             0111*  c_black: equ 0
0B0B8A             0112*  c_red_dk: equ 1
0B0B8A             0113*  c_green_dk: equ 2
0B0B8A             0114*  c_yellow_dk: equ 3
0B0B8A             0115*  c_blue_dk: equ 4
0B0B8A             0116*  c_magenta_dk: equ 5
0B0B8A             0117*  c_cyan_dk: equ 6
0B0B8A             0118*  c_grey: equ 7
0B0B8A             0119*  c_grey_dk: equ 8
0B0B8A             0120*  c_red: equ 9
0B0B8A             0121*  c_green: equ 10
0B0B8A             0122*  c_yellow: equ 11
0B0B8A             0123*  c_blue: equ 12
0B0B8A             0124*  c_magenta: equ 13
0B0B8A             0125*  c_cyan: equ 14
0B0B8A             0126*  c_white: equ 15
0B0B8A             0127*  
0B0B8A             0128*  ; VDU 25, mode, x; y;: PLOT command
0B0B8A             0129*  ; inputs: a=mode, bc=x0, de=y0
0B0B8A             0130*  vdu_plot:
0B0B8A 32 A4 0B 0B 0131*      ld (@mode),a
0B0B8E ED 43 A5 0B 0132*      ld (@x0),bc
       0B          
0B0B93 ED 53 A7 0B 0133*      ld (@y0),de
       0B          
0B0B98 21 A3 0B 0B 0134*  	ld hl,@cmd
0B0B9C 01 06 00 00 0135*  	ld bc,@end-@cmd
0B0BA0 5B DF       0136*  	rst.lil $18
0B0BA2 C9          0137*  	ret
0B0BA3 19          0138*  @cmd:   db 25
0B0BA4 00          0139*  @mode:  db 0
0B0BA5 00 00       0140*  @x0: 	dw 0
0B0BA7 00 00       0141*  @y0: 	dw 0
0B0BA9 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B0BAA             0143*  
0B0BAA             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0BAA             0145*  ; &E8-&EF 	232-239 	Bitmap plot §
0B0BAA             0146*  ; VDU 25, mode, x; y;: PLOT command
0B0BAA             0147*  ; inputs: bc=x0, de=y0
0B0BAA             0148*  ; prerequisites: vdu_buff_select
0B0BAA             0149*  vdu_plot_bmp:
0B0BAA ED 43 C1 0B 0150*      ld (@x0),bc
       0B          
0B0BAF ED 53 C3 0B 0151*      ld (@y0),de
       0B          
0B0BB4 21 BF 0B 0B 0152*  	ld hl,@cmd
0B0BB8 01 06 00 00 0153*  	ld bc,@end-@cmd
0B0BBC 5B DF       0154*  	rst.lil $18
0B0BBE C9          0155*  	ret
0B0BBF 19          0156*  @cmd:   db 25
0B0BC0 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0BC1 00 00       0158*  @x0: 	dw 0x0000
0B0BC3 00 00       0159*  @y0: 	dw 0x0000
0B0BC5 00          0160*  @end:   db 0x00 ; padding
0B0BC6             0161*  
0B0BC6             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0BC6             0163*  ; &E8-&EF 	232-239 	Bitmap plot §
0B0BC6             0164*  ; VDU 25, mode, x; y;: PLOT command
0B0BC6             0165*  ; inputs: bc=x0, de=y0
0B0BC6             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B0BC6             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B0BC6             0168*  ;   the fractional portiion of the inputs are truncated
0B0BC6             0169*  ;   leaving only the 16-bit integer portion
0B0BC6             0170*  ; prerequisites: vdu_buff_select
0B0BC6             0171*  vdu_plot_bmp168:
0B0BC6             0172*  ; populate in the reverse of normal to keep the
0B0BC6             0173*  ; inputs from stomping on each other
0B0BC6 ED 53 E4 0B 0174*      ld (@y0-1),de
       0B          
0B0BCB ED 43 E2 0B 0175*      ld (@x0-1),bc
       0B          
0B0BD0 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B0BD2 32 E2 0B 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B0BD6 21 E1 0B 0B 0178*  	ld hl,@cmd
0B0BDA 01 06 00 00 0179*  	ld bc,@end-@cmd
0B0BDE 5B DF       0180*  	rst.lil $18
0B0BE0 C9          0181*  	ret
0B0BE1 19          0182*  @cmd:   db 25
0B0BE2 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0BE3 00 00       0184*  @x0: 	dw 0x0000
0B0BE5 00 00       0185*  @y0: 	dw 0x0000
0B0BE7             0186*  @end:  ; no padding required b/c we shifted de right
0B0BE7             0187*  
0B0BE7             0188*  ; draw a filled rectangle
0B0BE7             0189*  vdu_plot_rf:
0B0BE7 ED 43 0E 0C 0190*      ld (@x0),bc
       0B          
0B0BEC ED 53 10 0C 0191*      ld (@y0),de
       0B          
0B0BF1 DD 22 14 0C 0192*      ld (@x1),ix
       0B          
0B0BF6 FD 22 16 0C 0193*      ld (@y1),iy
       0B          
0B0BFB 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B0BFD 32 12 0C 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0C01 21 0C 0C 0B 0196*  	ld hl,@cmd0
0B0C05 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B0C09 5B DF       0198*  	rst.lil $18
0B0C0B C9          0199*      ret
0B0C0C 19          0200*  @cmd0:  db 25 ; plot
0B0C0D 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B0C0E 00 00       0202*  @x0:    dw 0x0000
0B0C10 00 00       0203*  @y0:    dw 0x0000
0B0C12 19          0204*  @cmd1:  db 25 ; plot
0B0C13 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B0C14 00 00       0206*  @x1:    dw 0x0000
0B0C16 00 00       0207*  @y1:    dw 0x0000
0B0C18 00          0208*  @end:   db 0x00 ; padding
0B0C19             0209*  
0B0C19             0210*  ; draw a filled circle
0B0C19             0211*  vdu_plot_cf:
0B0C19 ED 43 40 0C 0212*      ld (@x0),bc
       0B          
0B0C1E ED 53 42 0C 0213*      ld (@y0),de
       0B          
0B0C23 DD 22 46 0C 0214*      ld (@x1),ix
       0B          
0B0C28 FD 22 48 0C 0215*      ld (@y1),iy
       0B          
0B0C2D 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B0C2F 32 44 0C 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0C33 21 3E 0C 0B 0218*  	ld hl,@cmd0
0B0C37 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B0C3B 5B DF       0220*  	rst.lil $18
0B0C3D C9          0221*      ret
0B0C3E 19          0222*  @cmd0:  db 25 ; plot
0B0C3F 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B0C40 00 00       0224*  @x0:    dw 0x0000
0B0C42 00 00       0225*  @y0:    dw 0x0000
0B0C44 19          0226*  @cmd1:  db 25 ; plot
0B0C45 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B0C46 00 00       0228*  @x1:    dw 0x0000
0B0C48 00 00       0229*  @y1:    dw 0x0000
0B0C4A 00          0230*  @end:   db 0x00 ; padding
0B0C4B             0231*  
0B0C4B             0232*  ; VDU 25, mode, x; y;: PLOT command
0B0C4B             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B0C4B             0234*  plot:
0B0C4B 32 65 0C 0B 0235*      ld (@mode),a
0B0C4F DD 22 66 0C 0236*      ld (@x0),ix
       0B          
0B0C54 FD 22 68 0C 0237*      ld (@y0),iy
       0B          
0B0C59 21 64 0C 0B 0238*  	ld hl,@cmd
0B0C5D 01 06 00 00 0239*  	ld bc,@end-@cmd
0B0C61 5B DF       0240*  	rst.lil $18
0B0C63 C9          0241*  	ret
0B0C64 19          0242*  @cmd:   db 25
0B0C65 00          0243*  @mode:  db 0
0B0C66 00 00       0244*  @x0: 	dw 0
0B0C68 00 00       0245*  @y0: 	dw 0
0B0C6A 00          0246*  @end:   db 0 ; padding
0B0C6B             0247*  
0B0C6B             0248*  ; VDU 5: Write text at graphics cursor
0B0C6B             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B0C6B             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B0C6B             0251*  plot_text:
0B0C6B E5          0252*      push hl ; save text pointer
0B0C6C             0253*  ; move graphics cursor to x0, y0
0B0C6C 3E 44       0254*      ld a,plot_pt+mv_abs
0B0C6E CD 4B 0C 0B 0255*      call plot
0B0C72             0256*  ; write text
0B0C72 E1          0257*      pop hl ; restore text pointer
0B0C73 CD 67 02 0B 0258*      call printString
0B0C77 C9          0259*      ret
0B0C78             0025   
0B0C78             0026   ; SHAWN'S INCLUDES
0B0C78             0027   	INCLUDE	"strings24.asm"
0B0C78             0001*  ;------------------------------------------------------------------------
0B0C78             0002*  ;  strings24.asm
0B0C78             0003*  ;
0B0C78             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B0C78             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B0C78             0006*  ;  MIT license
0B0C78             0007*  ;------------------------------------------------------------------------
0B0C78             0008*  
0B0C78             0009*  ;------------------------------------------------------------------------
0B0C78             0010*  ;Full print and buffer routine so you can adjust behaviour
0B0C78             0011*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B0C78             0012*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B0C78             0013*  ;Print value in HLU in decimal with leading 0s removed
0B0C78             0014*  ; Uses HLU, DEU, BCU
0B0C78             0015*  ;------------------------------------------------------------------------
0B0C78             0016*  
0B0C78             0017*  print_HLU_u24:
0B0C78 22 55 0D 0B 0018*  	ld	(hex_temp),hl
0B0C7C 06 08       0019*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B0C7E 11 58 0D 0B 0020*  	ld	de,outbuf
0B0C82 D5          0021*  	push	de
0B0C83 21 07 00 00 0022*  	ld	hl,7
0B0C87 19          0023*  	add	hl,de
0B0C88 E5          0024*  	push	hl
0B0C89 D1          0025*  	pop	de	;copy HLU to DEU
0B0C8A AF          0026*  	xor	a
0B0C8B             0027*  _pde_u_zerobuf:
0B0C8B 77          0028*  	ld	(hl),a	;zero out the output
0B0C8C 2B          0029*  	dec	hl
0B0C8D 10 FC       0030*  	djnz	_pde_u_zerobuf
0B0C8F             0031*  
0B0C8F 0E 18       0032*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B0C91             0033*  _bcd_Convert:
0B0C91             0034*  
0B0C91 21 55 0D 0B 0035*  	ld hl,hex_temp
0B0C95             0036*  ;
0B0C95 CB 26       0037*  	sla (hl)
0B0C97 23          0038*  	inc hl
0B0C98 CB 16       0039*  	rl (hl)
0B0C9A 23          0040*  	inc hl
0B0C9B CB 16       0041*  	rl (hl)		;24 bits rolled right
0B0C9D             0042*  
0B0C9D             0043*  
0B0C9D 06 08       0044*          ld	b,8	;8 digits max for 24 bit decimal output
0B0C9F D5          0045*  	push	de
0B0CA0 E1          0046*  	pop	hl
0B0CA1             0047*  
0B0CA1             0048*  _bcd_Add3:
0B0CA1 7E          0049*  	ld	a,(hl)
0B0CA2 8F          0050*  	adc	a
0B0CA3 27          0051*          daa		;this is add 3 after shifting left; i.e. add 6.
0B0CA4 FE 10       0052*  	cp	10h	;did we roll over nibble?
0B0CA6 3F          0053*  	ccf
0B0CA7 CB A7       0054*  	res	4,a
0B0CA9             0055*  
0B0CA9 77          0056*          ld (hl),a
0B0CAA 2B          0057*  	dec	hl
0B0CAB 10 F4       0058*          djnz	_bcd_Add3	;loop for decimal digits
0B0CAD 0D          0059*          dec c
0B0CAE 20 E1       0060*          jr nz, _bcd_Convert	;loop around
0B0CB0             0061*  
0B0CB0             0062*  
0B0CB0 E1          0063*  	pop	hl
0B0CB1 E5          0064*  	push	hl
0B0CB2 06 07       0065*          ld	b,8-1		;one less than total in case output is '0'
0B0CB4             0066*  _pde_u_make_ascii:
0B0CB4 7E          0067*  	ld	a,(hl)
0B0CB5 B7          0068*  	or	a
0B0CB6 20 05       0069*  	jr	nz,_pde_u_make_ascii2
0B0CB8 36 20       0070*  	ld	(hl),' '
0B0CBA 23          0071*  	inc	hl
0B0CBB 10 F7       0072*  	djnz	_pde_u_make_ascii
0B0CBD             0073*  _pde_u_make_ascii2:
0B0CBD 04          0074*  	inc	b
0B0CBE             0075*  _pde_u_make_ascii3:
0B0CBE 7E          0076*  	ld	a,(hl)
0B0CBF F6 30       0077*  	or	30h
0B0CC1 77          0078*  	ld	(hl),a
0B0CC2 23          0079*  	inc	hl
0B0CC3 10 F9       0080*  	djnz	_pde_u_make_ascii3
0B0CC5             0081*  
0B0CC5 E1          0082*  	pop	hl
0B0CC6 06 08       0083*  	ld	b,8
0B0CC8             0084*  _pde_u_final_out:
0B0CC8 7E          0085*  	ld	a,(hl)
0B0CC9 23          0086*  	inc	hl
0B0CCA FE 20       0087*  	cp	' '
0B0CCC 28 02       0088*  	jr	z,_pde_u_final_out_strip
0B0CCE 5B D7       0089*  	rst.lil	10h
0B0CD0             0090*  _pde_u_final_out_strip:
0B0CD0 10 F6       0091*  	djnz	_pde_u_final_out
0B0CD2 C9          0092*  	ret
0B0CD3             0093*  
0B0CD3             0094*  ;------------------------------------------------------------------------
0B0CD3             0095*  ; is_digit
0B0CD3             0096*  ; C flag set if A is a digit
0B0CD3             0097*  ; preserves all registers
0B0CD3             0098*  ;------------------------------------------------------------------------
0B0CD3             0099*  is_digit:
0B0CD3 FE 30       0100*  	cp	'0'
0B0CD5 3F          0101*  	ccf
0B0CD6 D0          0102*  	ret	nc	;less that '0'
0B0CD7 FE 3A       0103*  	cp	'9' + 1
0B0CD9 C9          0104*  	ret
0B0CDA             0105*  
0B0CDA             0106*  
0B0CDA             0107*  ;------------------------------------------------------------------------
0B0CDA             0108*  ; char2hex
0B0CDA             0109*  ; Input: ASCII nibble in A
0B0CDA             0110*  ; Returns: if valid nibble value in A; else 0FFh in A
0B0CDA             0111*  ;------------------------------------------------------------------------
0B0CDA             0112*  char2hex:
0B0CDA FE 30       0113*  	CP	'0'
0B0CDC 38 1D       0114*  	JR	C, char_not_hex
0B0CDE FE 3A       0115*  	CP	'9' + 1
0B0CE0 30 03       0116*  	JR	NC, char_not_09
0B0CE2 D6 30       0117*  	sub	'0'
0B0CE4 C9          0118*  	ret
0B0CE5             0119*  
0B0CE5             0120*  char_not_09:
0B0CE5             0121*  	; char is not 0 to 9. Try upper case
0B0CE5 FE 41       0122*  	CP	'A'
0B0CE7 38 12       0123*  	JR	C, char_not_hex
0B0CE9 FE 47       0124*  	CP	'F' + 1
0B0CEB 30 03       0125*  	JR	NC, char_not_AF
0B0CED D6 37       0126*  	sub	'A'-10
0B0CEF C9          0127*  	ret
0B0CF0             0128*  
0B0CF0             0129*  char_not_AF:
0B0CF0             0130*  	; char is not upper case A-F. Try lower
0B0CF0 FE 61       0131*  	CP	'a'
0B0CF2 38 07       0132*  	JR	C, char_not_hex
0B0CF4 FE 67       0133*  	CP	'f' + 1
0B0CF6 30 03       0134*  	JR	NC, char_not_hex
0B0CF8 D6 57       0135*  	sub	'a' - 10
0B0CFA C9          0136*  	RET
0B0CFB             0137*  
0B0CFB             0138*  char_not_hex:
0B0CFB 3E FF       0139*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B0CFD C9          0140*  	RET
0B0CFE             0141*  
0B0CFE             0142*  ;------------------------------------------------------------------------
0B0CFE             0143*  ;  newline
0B0CFE             0144*  ;  Output CR+LF; all registers preserved
0B0CFE             0145*  ;------------------------------------------------------------------------
0B0CFE             0146*  newline:
0B0CFE F5          0147*         push   AF
0B0CFF 3E 0D       0148*         LD     A, 13
0B0D01 5B D7       0149*         RST.LIL    10h
0B0D03 3E 0A       0150*         LD     A, 10
0B0D05 5B D7       0151*         RST.LIL    10h
0B0D07 F1          0152*         POP    AF
0B0D08 C9          0153*         RET
0B0D09             0154*  
0B0D09             0155*  ;------------------------------------------------------------------------
0B0D09             0156*  ;  put_nibble
0B0D09             0157*  ;  Output a single hex nibble in A
0B0D09             0158*  ;  All registers preserved
0B0D09             0159*  ;------------------------------------------------------------------------
0B0D09             0160*  put_nibble:
0B0D09 F5          0161*  	push   AF
0B0D0A C6 90       0162*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B0D0C 27          0163*  	daa
0B0D0D CE 40       0164*  	adc    a,040h
0B0D0F 27          0165*  	daa
0B0D10 5B D7       0166*  	RST.LIL    10h	;output character in A
0B0D12 F1          0167*  	pop    AF
0B0D13 C9          0168*  	ret
0B0D14             0169*  
0B0D14             0170*  ;------------------------------------------------------------------------
0B0D14             0171*  ;  print_A
0B0D14             0172*  ;  Output the 8-bit hex number A
0B0D14             0173*  ;  All registers preserved
0B0D14             0174*  ;------------------------------------------------------------------------
0B0D14             0175*  print_A:
0B0D14 F5          0176*  	push 	AF
0B0D15 F5          0177*  	push 	AF	;save for second nibble
0B0D16 0F          0178*  	rrca
0B0D17 0F          0179*  	rrca
0B0D18 0F          0180*  	rrca
0B0D19 0F          0181*  	rrca
0B0D1A E6 0F       0182*  	and	0Fh	;first nibble
0B0D1C CD 09 0D 0B 0183*  	call	put_nibble
0B0D20 F1          0184*  	pop 	AF
0B0D21 E6 0F       0185*  	and	0Fh	;second nibble
0B0D23 CD 09 0D 0B 0186*  	call	put_nibble
0B0D27 F1          0187*  	pop 	AF
0B0D28 C9          0188*  	ret
0B0D29             0189*  
0B0D29             0190*  ;------------------------------------------------------------------------
0B0D29             0191*  ;  print_HLU_hex
0B0D29             0192*  ;  Output the 24-bit hex number HLU; other registers preserved
0B0D29             0193*  ;------------------------------------------------------------------------
0B0D29             0194*  print_HLU_hex:
0B0D29 F5          0195*         push   AF
0B0D2A 22 55 0D 0B 0196*         ld     (hex_temp),hl
0B0D2E 3A 57 0D 0B 0197*         ld     a,(hex_temp+2)
0B0D32 CD 14 0D 0B 0198*         call   print_A
0B0D36 3A 56 0D 0B 0199*         ld     a,(hex_temp+1)
0B0D3A CD 14 0D 0B 0200*         call   print_A
0B0D3E 3A 55 0D 0B 0201*         ld     a,(hex_temp)
0B0D42 CD 14 0D 0B 0202*         call   print_A
0B0D46 F1          0203*         POP    AF
0B0D47 C9          0204*         RET
0B0D48             0205*  
0B0D48             0206*  ;------------------------------------------------------------------------
0B0D48             0207*  ;  puts
0B0D48             0208*  ;  Output a zero-terminated string whose address is in HL; all
0B0D48             0209*  ;  registers preserved.
0B0D48             0210*  ;------------------------------------------------------------------------
0B0D48             0211*  puts:
0B0D48 F5          0212*         push   AF
0B0D49 C5          0213*         push   BC
0B0D4A 01 00 00 00 0214*         ld     BC, 0                ; Set to 0, so length ignored...
0B0D4E 3E 00       0215*         ld     A, 0                 ; Use character in A as delimiter
0B0D50 5B DF       0216*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B0D52 C1          0217*         pop    BC
0B0D53 F1          0218*         pop    AF
0B0D54 C9          0219*         ret
0B0D55             0220*  
0B0D55             0221*  ;------------------------------------------------------------------------
0B0D55             0222*  ; Data area
0B0D55             0223*  ; Storage for 24 bit conversion
0B0D55             0224*  ;------------------------------------------------------------------------
0B0D55             0225*  hex_temp:
0B0D55 00 00 00    0226*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B0D58             0227*  
0B0D58             0228*  outbuf:
0B0D58 31 36 37 37 0229*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B0D61             0028   	INCLUDE	"arith24.asm"
0B0D61             0001*  
0B0D61             0002*  arith24uaf: ds 6
0B0D67             0003*  arith24uhl: ds 6
0B0D6D             0004*  arith24ubc: ds 6
0B0D73             0005*  arith24ude: ds 6
0B0D79             0006*  arith24uix: ds 6
0B0D7F             0007*  arith24uiy: ds 6
0B0D85             0008*  arith24usp: ds 6
0B0D8B             0009*  arith24upc: ds 6
0B0D91             0010*  
0B0D91             0011*  ;------------------------------------------------------------------------
0B0D91             0012*  ;  arith24.asm
0B0D91             0013*  ;  24-bit ez80 arithmetic routines
0B0D91             0014*  ;  Copyright (c) Shawn Sijnstra 2024
0B0D91             0015*  ;  MIT license
0B0D91             0016*  ;
0B0D91             0017*  ;  This library was created as a tool to help make ez80
0B0D91             0018*  ;  24-bit native assembly routines for simple mathematical problems
0B0D91             0019*  ;  more widely available.
0B0D91             0020*  ;
0B0D91             0021*  ;------------------------------------------------------------------------
0B0D91             0022*  
0B0D91             0023*  ;------------------------------------------------------------------------
0B0D91             0024*  ; umul24:	HL = HL*DE (unsigned)
0B0D91             0025*  ; Preserves AF, BC, DE
0B0D91             0026*  ; Uses a fast multiply routine.
0B0D91             0027*  ;------------------------------------------------------------------------
0B0D91             0028*  umul24:
0B0D91 D5          0029*  	push	DE
0B0D92 C5          0030*  	push	BC
0B0D93 F5          0031*  	push	AF
0B0D94 E5          0032*  	push	HL
0B0D95 C1          0033*  	pop		BC
0B0D96 3E 18       0034*      ld	 	a, 24 ; No. of bits to process
0B0D98 21 00 00 00 0035*      ld	 	hl, 0 ; Result
0B0D9C             0036*  umul24_lp:
0B0D9C 29          0037*  	add	hl,hl
0B0D9D EB          0038*  	ex	de,hl
0B0D9E 29          0039*  	add	hl,hl
0B0D9F EB          0040*  	ex	de,hl
0B0DA0 30 01       0041*  	jr	nc,umul24_nc
0B0DA2 09          0042*  	add	hl,bc
0B0DA3             0043*  umul24_nc:
0B0DA3 3D          0044*  	dec	a
0B0DA4 20 F6       0045*  	jr	nz,umul24_lp
0B0DA6 F1          0046*  	pop	af
0B0DA7 C1          0047*  	pop	bc
0B0DA8 D1          0048*  	pop	de
0B0DA9 C9          0049*  	ret
0B0DAA             0050*  
0B0DAA             0051*  
0B0DAA             0052*  ;------------------------------------------------------------------------
0B0DAA             0053*  ; udiv24
0B0DAA             0054*  ; Unsigned 24-bit division
0B0DAA             0055*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0DAA             0056*  ;
0B0DAA             0057*  ; Uses AF BC DE HL
0B0DAA             0058*  ; Uses Restoring Division algorithm
0B0DAA             0059*  ;------------------------------------------------------------------------
0B0DAA             0060*  
0B0DAA             0061*  udiv24:
0B0DAA E5          0062*  	push	hl
0B0DAB C1          0063*  	pop		bc	;move dividend to BCU
0B0DAC 21 00 00 00 0064*  	ld		hl,0	;result
0B0DB0 A7          0065*  	and		a
0B0DB1 ED 52       0066*  	sbc		hl,de	;test for div by 0
0B0DB3 C8          0067*  	ret		z		;it's zero, carry flag is clear
0B0DB4 19          0068*  	add		hl,de	;HL is 0 again
0B0DB5 3E 18       0069*  	ld		a,24	;number of loops through.
0B0DB7             0070*  udiv1:
0B0DB7 C5          0071*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0DB8 E3          0072*  	ex		(sp),hl
0B0DB9 37          0073*  	scf
0B0DBA ED 6A       0074*  	adc	hl,hl
0B0DBC E3          0075*  	ex	(sp),hl
0B0DBD C1          0076*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0DBE             0077*  
0B0DBE ED 6A       0078*  	adc	hl,hl
0B0DC0 A7          0079*  	and	a		;is this the bug
0B0DC1 ED 52       0080*  	sbc	hl,de
0B0DC3 30 02       0081*  	jr	nc,udiv2
0B0DC5 19          0082*  	add	hl,de
0B0DC6             0083*  ;	dec	c
0B0DC6 0B          0084*  	dec	bc
0B0DC7             0085*  udiv2:
0B0DC7 3D          0086*  	dec	a
0B0DC8 20 ED       0087*  	jr	nz,udiv1
0B0DCA 37          0088*  	scf		;flag used for div0 error
0B0DCB C5          0089*  	push	bc
0B0DCC D1          0090*  	pop		de	;remainder
0B0DCD C9          0091*  	ret
0B0DCE             0092*  
0B0DCE             0093*  
0B0DCE             0094*  
0B0DCE             0095*  ;------------------------------------------------------------------------
0B0DCE             0096*  ; neg24
0B0DCE             0097*  ; Returns: HLU = 0-HLU
0B0DCE             0098*  ; preserves all other registers
0B0DCE             0099*  ;------------------------------------------------------------------------
0B0DCE             0100*  neg24:
0B0DCE D5          0101*  	push	de
0B0DCF EB          0102*  	ex		de,hl
0B0DD0 21 00 00 00 0103*  	ld		hl,0
0B0DD4 B7          0104*  	or		a
0B0DD5 ED 52       0105*  	sbc		hl,de
0B0DD7 D1          0106*  	pop		de
0B0DD8 C9          0107*  	ret
0B0DD9             0108*  
0B0DD9             0109*  ;------------------------------------------------------------------------
0B0DD9             0110*  ; or_hlu_deu: 24 bit bitwise OR
0B0DD9             0111*  ; Returns: hlu = hlu OR deu
0B0DD9             0112*  ; preserves all other registers
0B0DD9             0113*  ;------------------------------------------------------------------------
0B0DD9             0114*  or_hlu_deu:
0B0DD9 22 64 0E 0B 0115*  	ld	(bitbuf1),hl
0B0DDD ED 53 67 0E 0116*  	ld	(bitbuf2),de
       0B          
0B0DE2 D5          0117*  	push	de	;preserve DEU
0B0DE3 C5          0118*  	push	bc	;preserve BCU
0B0DE4 06 03       0119*  	ld		b,3
0B0DE6 21 64 0E 0B 0120*  	ld	hl,bitbuf1
0B0DEA 11 64 0E 0B 0121*  	ld	de,bitbuf1
0B0DEE             0122*  orloop_24:
0B0DEE 1A          0123*  	ld	a,(de)
0B0DEF B6          0124*  	or	(hl)
0B0DF0 12          0125*  	ld	(de),a
0B0DF1 13          0126*  	inc	de
0B0DF2 23          0127*  	inc	hl
0B0DF3 10 F9       0128*  	djnz	orloop_24
0B0DF5 2A 67 0E 0B 0129*  	ld	hl,(bitbuf2)
0B0DF9 C1          0130*  	pop		bc	;restore BC
0B0DFA D1          0131*  	pop		de	;restore DE
0B0DFB             0132*  
0B0DFB             0133*  ;------------------------------------------------------------------------
0B0DFB             0134*  ; and_hlu_deu: 24 bit bitwise AND
0B0DFB             0135*  ; Returns: hlu = hlu AND deu
0B0DFB             0136*  ; preserves all other registers
0B0DFB             0137*  ;------------------------------------------------------------------------
0B0DFB             0138*  and_hlu_deu:
0B0DFB 22 64 0E 0B 0139*  	ld	(bitbuf1),hl
0B0DFF ED 53 67 0E 0140*  	ld	(bitbuf2),de
       0B          
0B0E04 D5          0141*  	push	de	;preserve DEU
0B0E05 C5          0142*  	push	bc	;preserve BCU
0B0E06 06 03       0143*  	ld		b,3
0B0E08 21 64 0E 0B 0144*  	ld	hl,bitbuf1
0B0E0C 11 64 0E 0B 0145*  	ld	de,bitbuf1
0B0E10             0146*  andloop_24:
0B0E10 1A          0147*  	ld	a,(de)
0B0E11 A6          0148*  	and	(hl)
0B0E12 12          0149*  	ld	(de),a
0B0E13 13          0150*  	inc	de
0B0E14 23          0151*  	inc	hl
0B0E15 10 F9       0152*  	djnz	andloop_24
0B0E17 2A 67 0E 0B 0153*  	ld	hl,(bitbuf2)
0B0E1B C1          0154*  	pop		bc	;restore BC
0B0E1C D1          0155*  	pop		de	;restore DE
0B0E1D             0156*  
0B0E1D             0157*  ;------------------------------------------------------------------------
0B0E1D             0158*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0E1D             0159*  ; Returns: hlu = hlu XOR deu
0B0E1D             0160*  ; preserves all other registers
0B0E1D             0161*  ;------------------------------------------------------------------------
0B0E1D             0162*  xor_hlu_deu:
0B0E1D 22 64 0E 0B 0163*  	ld	(bitbuf1),hl
0B0E21 ED 53 67 0E 0164*  	ld	(bitbuf2),de
       0B          
0B0E26 D5          0165*  	push	de	;preserve DEU
0B0E27 C5          0166*  	push	bc	;preserve BCU
0B0E28 06 03       0167*  	ld		b,3
0B0E2A 21 64 0E 0B 0168*  	ld	hl,bitbuf1
0B0E2E 11 64 0E 0B 0169*  	ld	de,bitbuf1
0B0E32             0170*  xorloop_24:
0B0E32 1A          0171*  	ld	a,(de)
0B0E33 AE          0172*  	xor	(hl)
0B0E34 12          0173*  	ld	(de),a
0B0E35 13          0174*  	inc	de
0B0E36 23          0175*  	inc	hl
0B0E37 10 F9       0176*  	djnz	xorloop_24
0B0E39 2A 67 0E 0B 0177*  	ld	hl,(bitbuf2)
0B0E3D C1          0178*  	pop		bc	;restore BC
0B0E3E D1          0179*  	pop		de	;restore DE
0B0E3F             0180*  
0B0E3F             0181*  ;------------------------------------------------------------------------
0B0E3F             0182*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B0E3F             0183*  ; Returns: hlu = hlu << deu
0B0E3F             0184*  ;		   de = 0
0B0E3F             0185*  ; NOTE: only considers deu up to 16 bits.
0B0E3F             0186*  ; preserves all other registers
0B0E3F             0187*  ;------------------------------------------------------------------------
0B0E3F             0188*  shl_hlu:
0B0E3F 7A          0189*  	ld		a,d		;up to 16 bit.
0B0E40 B3          0190*  	or		e
0B0E41 C8          0191*  	ret		z		;we're done
0B0E42 29          0192*  	add		hl,hl	;shift HLU left
0B0E43 1B          0193*  	dec		de
0B0E44 18 F9       0194*  	jr		shl_hlu
0B0E46             0195*  
0B0E46             0196*  ;------------------------------------------------------------------------
0B0E46             0197*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B0E46             0198*  ; Returns: hlu = hlu >> deu
0B0E46             0199*  ;		   de = 0
0B0E46             0200*  ; NOTE: only considers deu up to 16 bits.
0B0E46             0201*  ; preserves all other registers
0B0E46             0202*  ;------------------------------------------------------------------------
0B0E46             0203*  shr_hlu:
0B0E46 22 64 0E 0B 0204*  	ld		(bitbuf1),hl
0B0E4A 21 66 0E 0B 0205*  	ld		hl,bitbuf1+2
0B0E4E             0206*  shr_loop:
0B0E4E 7A          0207*  	ld		a,d		;up to 16 bit.
0B0E4F B3          0208*  	or		e
0B0E50 28 0D       0209*  	jr		z,shr_done		;we're done
0B0E52             0210*  ;carry is clear from or instruction
0B0E52 CB 1E       0211*  	rr		(hl)
0B0E54 2B          0212*  	dec		hl
0B0E55 CB 1E       0213*  	rr		(hl)
0B0E57 2B          0214*  	dec		hl
0B0E58 CB 1E       0215*  	rr		(hl)
0B0E5A 23          0216*  	inc		hl
0B0E5B 23          0217*  	inc		hl
0B0E5C 1B          0218*  	dec		de
0B0E5D 18 EF       0219*  	jr		shr_loop
0B0E5F             0220*  shr_done:
0B0E5F 2A 64 0E 0B 0221*  	ld		hl,(bitbuf1)	;collect result
0B0E63 C9          0222*  	ret
0B0E64             0223*  
0B0E64             0224*  ;------------------------------------------------------------------------
0B0E64             0225*  ; Scratch area for calculations
0B0E64             0226*  ;------------------------------------------------------------------------
0B0E64 00 00 00    0227*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B0E67 00 00 00    0228*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0E6A             0229*  
0B0E6A             0230*  ; ========== FROM maths24.inc ==========
0B0E6A             0231*  
0B0E6A             0232*  ; http://www.z80.info/pseudo-random.txt
0B0E6A             0233*  rand_8:
0B0E6A C5          0234*      push bc
0B0E6B 3A 7E 0E 0B 0235*      ld a,(r_seed)
0B0E6F 4F          0236*      ld c,a
0B0E70             0237*  
0B0E70 0F          0238*      rrca ; multiply by 32
0B0E71 0F          0239*      rrca
0B0E72 0F          0240*      rrca
0B0E73 EE 1F       0241*      xor 0x1f
0B0E75             0242*  
0B0E75 81          0243*      add a,c
0B0E76 DE FF       0244*      sbc a,255 ; carry
0B0E78             0245*  
0B0E78 32 7E 0E 0B 0246*      ld (r_seed),a
0B0E7C C1          0247*      pop bc
0B0E7D C9          0248*      ret
0B0E7E 50          0249*  r_seed: defb $50
0B0E7F             0250*  
0B0E7F             0251*  ; tests the sign of 24-bit register hlu
0B0E7F             0252*  ; returns: a in [-1,0,1]
0B0E7F             0253*  ;   sign and zero flags as expected
0B0E7F             0254*  ;   hl is untouched
0B0E7F             0255*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
0B0E7F             0256*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
0B0E7F             0257*  get_sign_hlu:
0B0E7F             0258*      ; Load the upper byte of HLU into A
0B0E7F E5          0259*      push hl
0B0E80 DD 21 00 00 0260*      ld ix,0
       00          
0B0E85 DD 39       0261*      add ix,sp
0B0E87 DD 7E 02    0262*      ld a,(ix+2)
0B0E8A E1          0263*      pop hl
0B0E8B             0264*  
0B0E8B B5          0265*      or l                ; OR with the low byte to check if HL is zero
0B0E8C C8          0266*      ret z               ; Return if HL is zero
0B0E8D             0267*  
0B0E8D 3E FF       0268*      ld a,-1             ; Send A back as -1 if the sign flag is set
0B0E8F CB 7C       0269*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
0B0E91 C0          0270*      ret nz              ; If set,HL is negative,return with the sign flag set
0B0E92             0271*  
0B0E92 3E 01       0272*      ld a,1             ; Otherwise,HL is positive
0B0E94 A7          0273*      and a               ; Reset the zero flag
0B0E95 C9          0274*      ret                 ; Return with A set to 1
0B0E96             0275*  
0B0E96             0276*  ; convert angles from a 360 to 255 degree circle
0B0E96             0277*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0E96             0278*  ; outputs: uh.l is the angle255 in 16.8 fixed format
0B0E96             0279*  ; destroys: TODO
0B0E96             0280*  ; note: even though the inputs and outputs are 16.8 fixed format
0B0E96             0281*  ;       precision is effectively limited to 8.8 fixed format
0B0E96             0282*  deg_360_to_255:
0B0E96             0283*  
0B0E96             0284*  @scratch: ds 6 ; scratch area for fast byte-shifting 24-bit registers
0B0E9C             0285*  
0B0E9C             0286*  ; 16.8 fixed inputs / outputs
0B0E9C             0287*  ; takes: uh.l as angle in degrees 256
0B0E9C             0288*  ;        ud.e as radius
0B0E9C             0289*  ; returns ub.c as dx, ud.e as dy
0B0E9C             0290*  ;        displacements from origin (0,0)
0B0E9C             0291*  ; destroys: everything except indexes
0B0E9C             0292*  polar_to_cartesian:
0B0E9C             0293*  ; back up input parameters
0B0E9C 22 67 0D 0B 0294*      ld (arith24uhl), hl
0B0EA0 ED 53 73 0D 0295*      ld (arith24ude), de
       0B          
0B0EA5             0296*  ; compute dx = sin(uh.l) * ud.e
0B0EA5 CD D4 0E 0B 0297*      call sin168
0B0EA9 E5          0298*      push hl
0B0EAA C1          0299*      pop bc          ; ub.c = sin(uh.l)
0B0EAB ED 5B 73 0D 0300*  	ld de, (arith24ude)   ; get radius back
       0B          
0B0EB0 CD 2D 18 0B 0301*  	call smul168    ; uh.l = ub.c * ud.e = dx
0B0EB4 E5          0302*      push hl         ; store dx for output
0B0EB5             0303*  ; compute dy = -cos(uh.l) * ud.e
0B0EB5 2A 67 0D 0B 0304*      ld hl, (arith24uhl)
0B0EB9 CD CF 0E 0B 0305*      call cos168
0B0EBD CD 9F 17 0B 0306*  	call neg_hlu    ; invert dy for screen coords convention
0B0EC1 E5          0307*      push hl
0B0EC2 C1          0308*      pop bc          ; ub.c = -cos(uh.l)
0B0EC3 ED 5B 73 0D 0309*      ld de, (arith24ude)   ; get radius back
       0B          
0B0EC8 CD 2D 18 0B 0310*      call smul168    ; uh.l = ub.c * ud.e = dy
0B0ECC EB          0311*      ex de, hl       ; de = dy for output
0B0ECD C1          0312*      pop bc          ; bc = dx for output
0B0ECE             0313*  ; and out
0B0ECE C9          0314*      ret
0B0ECF             0315*  
0B0ECF             0316*  ; fixed 16.8 routine
0B0ECF             0317*  ; cos(uh.l) --> uh.l
0B0ECF             0318*  ; destroys: de
0B0ECF             0319*  cos168:
0B0ECF             0320*  ; for cos we simply increment the angle by 90 degrees
0B0ECF             0321*  ; or 0x004000 in 16.8 degrees256
0B0ECF             0322*  ; which makes it a sin problem
0B0ECF 11 00 40 00 0323*      ld de,0x004000
0B0ED3 19          0324*      add hl,de ; modulo 256 happens below
0B0ED4             0325*  ; fall through to sin168
0B0ED4             0326*  ; ---------------------
0B0ED4             0327*  ; fixed 16.8 routine
0B0ED4             0328*  ; sin(uh.l) --> uh.l
0B0ED4             0329*  ; destroys: de
0B0ED4             0330*  sin168:
0B0ED4             0331*  ; h contains the integer portion of our angle
0B0ED4             0332*  ; we multiply it by three to get our lookup table index
0B0ED4 2E 03       0333*      ld l,3
0B0ED6 ED 6C       0334*      mlt hl ; gosh that is handy
0B0ED8 11 00 00 00 0335*      ld de,0 ; clear deu
0B0EDC 54          0336*      ld d,h ; copy hl to de
0B0EDD 5D          0337*      ld e,l ; de contains our index
0B0EDE 21 E5 10 0B 0338*      ld hl,sin_lut_168 ; grab the lut address
0B0EE2 19          0339*      add hl,de ; bump hl by the index
0B0EE3 ED 27       0340*      ld hl,(hl) ; don't try this on a z80!
0B0EE5 C9          0341*      ret ; and out
0B0EE6             0342*  
0B0EE6             0343*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0EE6             0344*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0EE6             0345*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0EE6             0346*  ;         also populates scratch locations dx168 and dy168
0B0EE6             0347*  ; destroys: a,hl,bc,de
0B0EE6             0348*  dxy168:
0B0EE6             0349*  ; compute dx = x1-x0
0B0EE6 AF          0350*      xor a ; clear carry
0B0EE7 DD E5       0351*      push ix ; move ix to hl via the stack
0B0EE9 E1          0352*      pop hl ; hl = x1
0B0EEA ED 42       0353*      sbc hl,bc ; hl = dx
0B0EEC 22 41 0F 0B 0354*      ld (dx168),hl ; dx to scratch
0B0EF0             0355*  ; compute dy = y1-y0
0B0EF0 AF          0356*      xor a ; clear carry
0B0EF1 FD E5       0357*      push iy ; move iy to hl via the stack
0B0EF3 E1          0358*      pop hl ; hl = y1
0B0EF4 ED 52       0359*      sbc hl,de ; hl = dy
0B0EF6 22 47 0F 0B 0360*      ld (dy168),hl ; dy to scratch
0B0EFA             0361*  ; populate output registers and return
0B0EFA EB          0362*      ex de,hl        ; ud.e = dy
0B0EFB ED 4B 41 0F 0363*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0F00 C9          0364*      ret
0B0F01             0365*  
0B0F01             0366*  ; compute the euclidian distance between two cartesian coordinates
0B0F01             0367*  ; using the formula d = sqrt(dx^2+dy^2
0B0F01             0368*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0F01             0369*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0F01             0370*  ; output; uh.l is the 16.8 fixed format distance
0B0F01             0371*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0F01             0372*  ; destroys: a,hl,bc,de
0B0F01             0373*  distance168:
0B0F01             0374*  ; compute dx = x1-x0
0B0F01 AF          0375*      xor a ; clear carry
0B0F02 DD E5       0376*      push ix ; move ix to hl via the stack
0B0F04 E1          0377*      pop hl ; hl = x1
0B0F05 ED 42       0378*      sbc hl,bc ; hl = dx
0B0F07 22 41 0F 0B 0379*      ld (dx168),hl ; dx to scratch
0B0F0B             0380*  ; ; test dx for overflow
0B0F0B             0381*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0F0B             0382*  ; 	ex de,hl
0B0F0B             0383*  ; 	sbc hl,de ; test for overflow
0B0F0B             0384*  ; 	push af ; carry indicates overflow
0B0F0B             0385*  ; compute dy = y1-y0
0B0F0B AF          0386*      xor a ; clear carry
0B0F0C FD E5       0387*      push iy ; move iy to hl via the stack
0B0F0E E1          0388*      pop hl ; hl = y1
0B0F0F ED 52       0389*      sbc hl,de ; hl = dy
0B0F11 22 47 0F 0B 0390*      ld (dy168),hl ; dy to scratch
0B0F15             0391*  ; ; test dy for overflow
0B0F15             0392*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0F15             0393*  ; 	ex de,hl
0B0F15             0394*  ; 	sbc hl,de ; test for overflow
0B0F15             0395*  ; 	push af ; carry indicates overflow
0B0F15             0396*  ; compute dy^2
0B0F15 2A 47 0F 0B 0397*  	ld hl,(dy168)
0B0F19 CD 8F 17 0B 0398*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B0F1D             0399*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0F1D E5          0400*      push hl ; load hl/2 to bc via the stack
0B0F1E C1          0401*      pop bc ; bc = dy/2
0B0F1F EB          0402*      ex de,hl ; de = dy/2
0B0F20 CD 11 18 0B 0403*      call umul168 ; uh.l = dy^2/2
0B0F24 E5          0404*      push hl ; dy^2/2 to the stack
0B0F25             0405*  ; compute dx^2
0B0F25 2A 41 0F 0B 0406*      ld hl,(dx168) ; get back dx
0B0F29 CD 8F 17 0B 0407*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B0F2D             0408*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0F2D E5          0409*      push hl ; load hl/2 to bc via the stack
0B0F2E C1          0410*      pop bc ; bc = dx/2
0B0F2F EB          0411*      ex de,hl ; de = dx/2
0B0F30 CD 11 18 0B 0412*      call umul168 ; uh.l = dx^2/2
0B0F34             0413*  ; commpute dy^2+dx^2
0B0F34 D1          0414*      pop de ; get back dx^2/2
0B0F35 19          0415*      add hl,de ; hl = dx^2/2+dy^2/2
0B0F36             0416*  ; compute sqrt(dx^2/2+dy^2/2)
0B0F36 CD FA 0F 0B 0417*      call sqrt168 ; uh.l = distance/2
0B0F3A             0418*      ; add hl,hl ; hl = distance
0B0F3A             0419*  ; ; check for overflow
0B0F3A             0420*  ; 	pop af ; get back the overflow flags
0B0F3A             0421*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0F3A             0422*  ; 	ld b,a ; save the overflow flag
0B0F3A             0423*  ; 	pop af ; get back the overflow flags
0B0F3A             0424*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0F3A             0425*  ; 	add a,b ; if a != 0 then we had overflow
0B0F3A             0426*  ;     ret z ; no overflow we're done
0B0F3A             0427*  ; @overflow:
0B0F3A             0428*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0F3A C9          0429*  	ret
0B0F3B             0430*  @scratch: ds 6
0B0F41             0431*  dx168: ds 6
0B0F47             0432*  dy168: ds 6
0B0F4D             0433*  
0B0F4D             0434*  ; atan2(ub.c,ud.e) --> uh.l
0B0F4D             0435*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0F4D             0436*  ;   whether inputs are integers or fractional doesn't matter
0B0F4D             0437*  ;   so long as the sign bit of the upper byte is correct
0B0F4D             0438*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0F4D             0439*  ; angles are COMPASS HEADINGS based on
0B0F4D             0440*  ; screen coordinate conventions,where the y axis is flipped
0B0F4D             0441*  ; #E0 315      0       45 #20
0B0F4D             0442*  ;        -x,-y | +x,-y
0B0F4D             0443*  ; #C0 270------+------ 90 #40
0B0F4D             0444*  ;        -x,+y | +x,+y
0B0F4D             0445*  ; #A0 225   180 #80   135 #60
0B0F4D             0446*  atan2_168game:
0B0F4D             0447*  ; get signs and make everything positive
0B0F4D             0448*  ; get abs(x) and store its original sign
0B0F4D C5          0449*      push bc
0B0F4E E1          0450*      pop hl
0B0F4F CD 8F 17 0B 0451*      call abs_hlu ; if x was negative this also sets the sign flag
0B0F53 E5          0452*      push hl ; store abs(x)
0B0F54 C1          0453*      pop bc ; bc = abs(x)
0B0F55 F5          0454*      push af ; store sign of x
0B0F56             0455*  ; get abs(y) and store its original sign
0B0F56 EB          0456*      ex de,hl ; hl = y
0B0F57 CD 8F 17 0B 0457*      call abs_hlu ; if y was negative this also sets the sign flag
0B0F5B EB          0458*      ex de,hl ; de = abs(y)
0B0F5C F5          0459*      push af ; store sign of y
0B0F5D             0460*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0F5D             0461*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B0F5D AF          0462*      xor a ; clear the carry flag
0B0F5E D5          0463*      push de
0B0F5F E1          0464*      pop hl
0B0F60 ED 42       0465*      sbc hl,bc
0B0F62 F5          0466*      push af ; save sign of de - bc
0B0F63 F2 6C 0F 0B 0467*      jp p,@1 ; bc <= de, so we skip ahead
0B0F67             0468*  ; otherwise we swap bc and de
0B0F67 C5          0469*      push bc
0B0F68 E1          0470*      pop hl
0B0F69 EB          0471*      ex de,hl
0B0F6A E5          0472*      push hl
0B0F6B C1          0473*      pop bc
0B0F6C             0474*  @1:
0B0F6C             0475*  ; now we're ready to snag our preliminary result
0B0F6C CD DA 0F 0B 0476*      call atan_168game ; uh.l comes back with prelim result
0B0F70             0477*  ; now we adjust uh.l based on sign of de - bc
0B0F70 F1          0478*      pop af
0B0F71 F2 7D 0F 0B 0479*      jp p,@2 ; bc <= de,so we skip ahead
0B0F75 EB          0480*      ex de,hl
0B0F76 21 00 40 00 0481*      ld hl,0x004000 ; 90 degrees
0B0F7A AF          0482*      xor a ; clear the carry flag
0B0F7B ED 52       0483*      sbc hl,de ; subtract result from 90 degrees
0B0F7D             0484*      ; ld de,0 ; prep to clear hlu
0B0F7D             0485*      ; ld d,h
0B0F7D             0486*      ; ld e,l
0B0F7D             0487*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0F7D             0488*      ; fall through
0B0F7D             0489*  @2:
0B0F7D             0490*  ; now the fun part of adjusting the result
0B0F7D             0491*  ; based on which quadrant (x,y) is in
0B0F7D             0492*  ; #E0 315      0       45 #20
0B0F7D             0493*  ;        -x,-y | +x,-y
0B0F7D             0494*  ; #C0 270------+------ 90 #40
0B0F7D             0495*  ;        -x,+y | +x,+y
0B0F7D             0496*  ; #A0 225   180 #80   135 #60
0B0F7D F1          0497*      pop af ; sign of y
0B0F7E CA BB 0F 0B 0498*      jp z,@y_zero
0B0F82 F2 9B 0F 0B 0499*      jp p,@y_pos
0B0F86             0500*  ; y neg,check x
0B0F86 F1          0501*      pop af ; sign of x
0B0F87 CA 95 0F 0B 0502*      jp z,@y_neg_x_zero
0B0F8B F2 9A 0F 0B 0503*      jp p,@y_neg_x_pos
0B0F8F             0504*  ; y neg,x neg
0B0F8F             0505*  ; angle is 270-360
0B0F8F             0506*  ; negating the intermediate does the trick
0B0F8F CD 9F 17 0B 0507*      call neg_hlu
0B0F93 18 31       0508*      jr @zero_hlu
0B0F95             0509*  
0B0F95             0510*  @y_neg_x_zero:
0B0F95             0511*  ; y neg,x zero
0B0F95             0512*  ; angle is 0
0B0F95 21 00 00 00 0513*      ld hl,0
0B0F99 C9          0514*      ret
0B0F9A             0515*  @y_neg_x_pos:
0B0F9A             0516*  ; y neg,x pos
0B0F9A             0517*  ; angle is 0 to 90
0B0F9A             0518*  ; so we're good
0B0F9A C9          0519*      ret
0B0F9B             0520*  
0B0F9B             0521*  @y_pos:
0B0F9B F1          0522*      pop af ; sign of x
0B0F9C CA AB 0F 0B 0523*      jp z,@y_pos_x_zero
0B0FA0 F2 B0 0F 0B 0524*      jp p,@y_pos_x_pos
0B0FA4             0525*  ; y pos,x neg
0B0FA4             0526*  ; angle is 180-270
0B0FA4             0527*  ; so we add 180 to intermediate
0B0FA4 11 00 80 00 0528*      ld de,0x008000
0B0FA8 19          0529*      add hl,de
0B0FA9 18 1B       0530*      jr @zero_hlu
0B0FAB             0531*  @y_pos_x_zero:
0B0FAB             0532*  ; y pos,x zero
0B0FAB             0533*  ; angle is 180
0B0FAB 21 00 80 00 0534*      ld hl,0x008000
0B0FAF C9          0535*      ret
0B0FB0             0536*  @y_pos_x_pos:
0B0FB0             0537*  ; y pos,x pos
0B0FB0             0538*  ; angle is 90-180
0B0FB0             0539*  ; neg the intermediate and add 180 degrees
0B0FB0 CD 9F 17 0B 0540*      call neg_hlu
0B0FB4 11 00 80 00 0541*      ld de,0x008000
0B0FB8 19          0542*      add hl,de
0B0FB9 18 0B       0543*      jr @zero_hlu
0B0FBB             0544*  
0B0FBB             0545*  @y_zero:
0B0FBB F1          0546*      pop af ; sign of x
0B0FBC FA C1 0F 0B 0547*      jp m,@y_zero_x_neg
0B0FC0             0548*  ; y zero,x pos
0B0FC0             0549*  ; angle is 90,nothing to do
0B0FC0 C9          0550*      ret
0B0FC1             0551*  @y_zero_x_neg:
0B0FC1             0552*  ; y zero ,x neg
0B0FC1             0553*  ; angle is 270
0B0FC1 21 00 C0 00 0554*      ld hl,0x00C000
0B0FC5 C9          0555*      ret
0B0FC6             0556*  @zero_hlu:
0B0FC6 AF          0557*      xor a
0B0FC7 22 D4 0F 0B 0558*      ld (@scratch),hl
0B0FCB 32 D6 0F 0B 0559*      ld (@scratch+2),a
0B0FCF 2A D4 0F 0B 0560*      ld hl,(@scratch)
0B0FD3 C9          0561*      ret
0B0FD4             0562*  @scratch: ds 6
0B0FDA             0563*  
0B0FDA             0564*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0FDA             0565*  ; output: uh.l is the 16.8 fixed format angle
0B0FDA             0566*  ; destroys: a,hl,bc,de
0B0FDA             0567*  ; the following note was written by github copilot:
0B0FDA             0568*  ; note: this routine is a bit of a hack
0B0FDA             0569*  ;      but it works
0B0FDA             0570*  ;      and it's fast
0B0FDA             0571*  ;      and it's small
0B0FDA             0572*  ;      and it's accurate
0B0FDA             0573*  ;      and it's easy to understand
0B0FDA             0574*  ;      and it's easy to modify
0B0FDA             0575*  ;      and it's easy to use
0B0FDA             0576*  ;      and it's easy to remember
0B0FDA             0577*  ;      and it's easy to love
0B0FDA             0578*  ;      and it's easy to hate
0B0FDA             0579*  ;      and it's easy to ignore
0B0FDA             0580*  ;      and it's easy to forget
0B0FDA             0581*  ;      and it's easy to remember
0B0FDA             0582*  ;      and it's easy to forget
0B0FDA             0583*  ;      and it's easy to remember
0B0FDA             0584*  ;      (ok the bot is stuck in a loop)
0B0FDA             0585*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0FDA             0586*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0FDA             0587*  atan_168game:
0B0FDA             0588*  ; because we use compass headings instead of geometric angles
0B0FDA             0589*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0FDA             0590*  ; we can do faster unsigned division here because we know dx and dy are positive
0B0FDA CD 26 17 0B 0591*  	call udiv168 ; uh.l = dx/dy
0B0FDE             0592*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0FDE             0593*  ; ; test uh.l for 0
0B0FDE             0594*  ;     add hl,de
0B0FDE             0595*  ;     or a
0B0FDE             0596*  ;     sbc hl,de
0B0FDE             0597*  ;     jr z,@is_zero
0B0FDE             0598*  ; ; test uh.l for 1
0B0FDE             0599*  ;     xor a ; clear carry
0B0FDE             0600*  ;     ex de,hl
0B0FDE             0601*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0FDE             0602*  ;     sbc hl,de
0B0FDE             0603*  ;     jr z,@is_45
0B0FDE             0604*  ; ; END TODO
0B0FDE             0605*  
0B0FDE             0606*  ; no special cases so we move on
0B0FDE             0607*  ; l contains the fractional portion of tan(uh.l)
0B0FDE             0608*  ; we multiply it by three to get our lookup table index
0B0FDE 26 03       0609*      ld h,3
0B0FE0 ED 6C       0610*      mlt hl ; gosh that is handy
0B0FE2 11 00 00 00 0611*      ld de,0 ; clear deu
0B0FE6 54          0612*      ld d,h ; copy hl to de
0B0FE7 5D          0613*      ld e,l ; de contains our index
0B0FE8 21 E5 13 0B 0614*      ld hl,atan_lut_168 ; grab the lut address
0B0FEC 19          0615*      add hl,de ; bump hl by the index
0B0FED ED 27       0616*      ld hl,(hl) ; don't try this on a z80!
0B0FEF C9          0617*      ret ; and out
0B0FF0             0618*  @is_45:
0B0FF0 21 00 20 00 0619*      ld hl,0x002000 ; 45 degrees decimal
0B0FF4 C9          0620*      ret
0B0FF5             0621*  ; for the case tan(0)
0B0FF5             0622*  @is_zero:
0B0FF5 21 00 00 00 0623*      ld hl,0x000000
0B0FF9 C9          0624*      ret
0B0FFA             0625*  
0B0FFA             0626*  ; Expects  ADL mode
0B0FFA             0627*  ; Inputs:  UH.L
0B0FFA             0628*  ; Outputs: UH.L is the 16.8 square root
0B0FFA             0629*  ;          UD.E is the difference inputHL-DE^2
0B0FFA             0630*  ;          c flag reset
0B0FFA             0631*  sqrt168:
0B0FFA CD 04 10 0B 0632*      call sqrt24
0B0FFE EB          0633*      ex de,hl
0B0FFF 29          0634*      add hl,hl
0B1000 29          0635*      add hl,hl
0B1001 29          0636*      add hl,hl
0B1002 29          0637*      add hl,hl
0B1003 C9          0638*      ret
0B1004             0639*  
0B1004             0640*  ; Expects  ADL mode
0B1004             0641*  ; Inputs:  HL
0B1004             0642*  ; Outputs: DE is the integer square root
0B1004             0643*  ;          HL is the difference inputHL-DE^2
0B1004             0644*  ;          c flag reset
0B1004             0645*  sqrt24:
0B1004 AF          0646*      xor a
0B1005 45          0647*      ld b,l
0B1006 C5          0648*      push bc
0B1007 47          0649*      ld b,a
0B1008 57          0650*      ld d,a
0B1009 4F          0651*      ld c,a
0B100A 6F          0652*      ld l,a
0B100B 5F          0653*      ld e,a
0B100C             0654*  
0B100C             0655*      ;Iteration 1
0B100C 29          0656*      add hl,hl
0B100D CB 11       0657*      rl c
0B100F 29          0658*      add hl,hl
0B1010 CB 11       0659*      rl c
0B1012 91          0660*      sub c
0B1013 30 04       0661*      jr nc,$+6
0B1015 1C          0662*      inc e
0B1016 1C          0663*      inc e
0B1017 2F          0664*      cpl
0B1018 4F          0665*      ld c,a
0B1019             0666*  
0B1019             0667*      ;Iteration 2
0B1019 29          0668*      add hl,hl
0B101A CB 11       0669*      rl c
0B101C 29          0670*      add hl,hl
0B101D CB 11       0671*      rl c
0B101F CB 13       0672*      rl e
0B1021 7B          0673*      ld a,e
0B1022 91          0674*      sub c
0B1023 30 04       0675*      jr nc,$+6
0B1025 1C          0676*      inc e
0B1026 1C          0677*      inc e
0B1027 2F          0678*      cpl
0B1028 4F          0679*      ld c,a
0B1029             0680*  
0B1029             0681*      ;Iteration 3
0B1029 29          0682*      add hl,hl
0B102A CB 11       0683*      rl c
0B102C 29          0684*      add hl,hl
0B102D CB 11       0685*      rl c
0B102F CB 13       0686*      rl e
0B1031 7B          0687*      ld a,e
0B1032 91          0688*      sub c
0B1033 30 04       0689*      jr nc,$+6
0B1035 1C          0690*      inc e
0B1036 1C          0691*      inc e
0B1037 2F          0692*      cpl
0B1038 4F          0693*      ld c,a
0B1039             0694*  
0B1039             0695*      ;Iteration 4
0B1039 29          0696*      add hl,hl
0B103A CB 11       0697*      rl c
0B103C 29          0698*      add hl,hl
0B103D CB 11       0699*      rl c
0B103F CB 13       0700*      rl e
0B1041 7B          0701*      ld a,e
0B1042 91          0702*      sub c
0B1043 30 04       0703*      jr nc,$+6
0B1045 1C          0704*      inc e
0B1046 1C          0705*      inc e
0B1047 2F          0706*      cpl
0B1048 4F          0707*      ld c,a
0B1049             0708*  
0B1049             0709*      ;Iteration 5
0B1049 29          0710*      add hl,hl
0B104A CB 11       0711*      rl c
0B104C 29          0712*      add hl,hl
0B104D CB 11       0713*      rl c
0B104F CB 13       0714*      rl e
0B1051 7B          0715*      ld a,e
0B1052 91          0716*      sub c
0B1053 30 04       0717*      jr nc,$+6
0B1055 1C          0718*      inc e
0B1056 1C          0719*      inc e
0B1057 2F          0720*      cpl
0B1058 4F          0721*      ld c,a
0B1059             0722*  
0B1059             0723*      ;Iteration 6
0B1059 29          0724*      add hl,hl
0B105A CB 11       0725*      rl c
0B105C 29          0726*      add hl,hl
0B105D CB 11       0727*      rl c
0B105F CB 13       0728*      rl e
0B1061 7B          0729*      ld a,e
0B1062 91          0730*      sub c
0B1063 30 04       0731*      jr nc,$+6
0B1065 1C          0732*      inc e
0B1066 1C          0733*      inc e
0B1067 2F          0734*      cpl
0B1068 4F          0735*      ld c,a
0B1069             0736*  
0B1069             0737*      ;Iteration 7
0B1069 29          0738*      add hl,hl
0B106A CB 11       0739*      rl c
0B106C 29          0740*      add hl,hl
0B106D CB 11       0741*      rl c
0B106F CB 10       0742*      rl b
0B1071 EB          0743*      ex de,hl
0B1072 29          0744*      add hl,hl
0B1073 E5          0745*      push hl
0B1074 ED 42       0746*      sbc hl,bc
0B1076 30 06       0747*      jr nc,$+8
0B1078 7C          0748*      ld a,h
0B1079 2F          0749*      cpl
0B107A 47          0750*      ld b,a
0B107B 7D          0751*      ld a,l
0B107C 2F          0752*      cpl
0B107D 4F          0753*      ld c,a
0B107E E1          0754*      pop hl
0B107F 30 02       0755*      jr nc,$+4
0B1081 23          0756*      inc hl
0B1082 23          0757*      inc hl
0B1083 EB          0758*      ex de,hl
0B1084             0759*  
0B1084             0760*      ;Iteration 8
0B1084 29          0761*      add hl,hl
0B1085 69          0762*      ld l,c
0B1086 60          0763*      ld h,b
0B1087 ED 6A       0764*      adc hl,hl
0B1089 ED 6A       0765*      adc hl,hl
0B108B EB          0766*      ex de,hl
0B108C 29          0767*      add hl,hl
0B108D ED 52       0768*      sbc hl,de
0B108F 19          0769*      add hl,de
0B1090 EB          0770*      ex de,hl
0B1091 30 04       0771*      jr nc,$+6
0B1093 ED 52       0772*      sbc hl,de
0B1095 13          0773*      inc de
0B1096 13          0774*      inc de
0B1097             0775*  
0B1097             0776*      ;Iteration 9
0B1097 F1          0777*      pop af
0B1098 17          0778*      rla
0B1099 ED 6A       0779*      adc hl,hl
0B109B 17          0780*      rla
0B109C ED 6A       0781*      adc hl,hl
0B109E EB          0782*      ex de,hl
0B109F 29          0783*      add hl,hl
0B10A0 ED 52       0784*      sbc hl,de
0B10A2 19          0785*      add hl,de
0B10A3 EB          0786*      ex de,hl
0B10A4 30 04       0787*      jr nc,$+6
0B10A6 ED 52       0788*      sbc hl,de
0B10A8 13          0789*      inc de
0B10A9 13          0790*      inc de
0B10AA             0791*  
0B10AA             0792*      ;Iteration 10
0B10AA 17          0793*      rla
0B10AB ED 6A       0794*      adc hl,hl
0B10AD 17          0795*      rla
0B10AE ED 6A       0796*      adc hl,hl
0B10B0 EB          0797*      ex de,hl
0B10B1 29          0798*      add hl,hl
0B10B2 ED 52       0799*      sbc hl,de
0B10B4 19          0800*      add hl,de
0B10B5 EB          0801*      ex de,hl
0B10B6 30 04       0802*      jr nc,$+6
0B10B8 ED 52       0803*      sbc hl,de
0B10BA 13          0804*      inc de
0B10BB 13          0805*      inc de
0B10BC             0806*  
0B10BC             0807*      ;Iteration 11
0B10BC 17          0808*      rla
0B10BD ED 6A       0809*      adc hl,hl
0B10BF 17          0810*      rla
0B10C0 ED 6A       0811*      adc hl,hl
0B10C2 EB          0812*      ex de,hl
0B10C3 29          0813*      add hl,hl
0B10C4 ED 52       0814*      sbc hl,de
0B10C6 19          0815*      add hl,de
0B10C7 EB          0816*      ex de,hl
0B10C8 30 04       0817*      jr nc,$+6
0B10CA ED 52       0818*      sbc hl,de
0B10CC 13          0819*      inc de
0B10CD 13          0820*      inc de
0B10CE             0821*  
0B10CE             0822*      ;Iteration 11
0B10CE 17          0823*      rla
0B10CF ED 6A       0824*      adc hl,hl
0B10D1 17          0825*      rla
0B10D2 ED 6A       0826*      adc hl,hl
0B10D4 EB          0827*      ex de,hl
0B10D5 29          0828*      add hl,hl
0B10D6 ED 52       0829*      sbc hl,de
0B10D8 19          0830*      add hl,de
0B10D9 EB          0831*      ex de,hl
0B10DA 30 04       0832*      jr nc,$+6
0B10DC ED 52       0833*      sbc hl,de
0B10DE 13          0834*      inc de
0B10DF 13          0835*      inc de
0B10E0             0836*  
0B10E0 CB 1A       0837*      rr d
0B10E2 CB 1B       0838*      rr e
0B10E4 C9          0839*      ret
0B10E5             0840*  
0B10E5             0841*  sin_lut_168:
0B10E5 00 00 00    0842*  	dl 0x000000 ; 0.000 00, 0.000
0B10E8 06 00 00    0843*  	dl 0x000006 ; 1.406 01, 0.025
0B10EB 0C 00 00    0844*  	dl 0x00000C ; 2.813 02, 0.049
0B10EE 12 00 00    0845*  	dl 0x000012 ; 4.219 03, 0.074
0B10F1 19 00 00    0846*  	dl 0x000019 ; 5.625 04, 0.098
0B10F4 1F 00 00    0847*  	dl 0x00001F ; 7.031 05, 0.122
0B10F7 25 00 00    0848*  	dl 0x000025 ; 8.438 06, 0.147
0B10FA 2B 00 00    0849*  	dl 0x00002B ; 9.844 07, 0.171
0B10FD 31 00 00    0850*  	dl 0x000031 ; 11.250 08, 0.195
0B1100 38 00 00    0851*  	dl 0x000038 ; 12.656 09, 0.219
0B1103 3E 00 00    0852*  	dl 0x00003E ; 14.063 0A, 0.243
0B1106 44 00 00    0853*  	dl 0x000044 ; 15.469 0B, 0.267
0B1109 4A 00 00    0854*  	dl 0x00004A ; 16.875 0C, 0.290
0B110C 50 00 00    0855*  	dl 0x000050 ; 18.281 0D, 0.314
0B110F 56 00 00    0856*  	dl 0x000056 ; 19.688 0E, 0.337
0B1112 5C 00 00    0857*  	dl 0x00005C ; 21.094 0F, 0.360
0B1115 61 00 00    0858*  	dl 0x000061 ; 22.500 10, 0.383
0B1118 67 00 00    0859*  	dl 0x000067 ; 23.906 11, 0.405
0B111B 6D 00 00    0860*  	dl 0x00006D ; 25.313 12, 0.428
0B111E 73 00 00    0861*  	dl 0x000073 ; 26.719 13, 0.450
0B1121 78 00 00    0862*  	dl 0x000078 ; 28.125 14, 0.471
0B1124 7E 00 00    0863*  	dl 0x00007E ; 29.531 15, 0.493
0B1127 83 00 00    0864*  	dl 0x000083 ; 30.938 16, 0.514
0B112A 88 00 00    0865*  	dl 0x000088 ; 32.344 17, 0.535
0B112D 8E 00 00    0866*  	dl 0x00008E ; 33.750 18, 0.556
0B1130 93 00 00    0867*  	dl 0x000093 ; 35.156 19, 0.576
0B1133 98 00 00    0868*  	dl 0x000098 ; 36.563 1A, 0.596
0B1136 9D 00 00    0869*  	dl 0x00009D ; 37.969 1B, 0.615
0B1139 A2 00 00    0870*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B113C A7 00 00    0871*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B113F AB 00 00    0872*  	dl 0x0000AB ; 42.188 1E, 0.672
0B1142 B0 00 00    0873*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B1145 B5 00 00    0874*  	dl 0x0000B5 ; 45.000 20, 0.707
0B1148 B9 00 00    0875*  	dl 0x0000B9 ; 46.406 21, 0.724
0B114B BD 00 00    0876*  	dl 0x0000BD ; 47.813 22, 0.741
0B114E C1 00 00    0877*  	dl 0x0000C1 ; 49.219 23, 0.757
0B1151 C5 00 00    0878*  	dl 0x0000C5 ; 50.625 24, 0.773
0B1154 C9 00 00    0879*  	dl 0x0000C9 ; 52.031 25, 0.788
0B1157 CD 00 00    0880*  	dl 0x0000CD ; 53.438 26, 0.803
0B115A D1 00 00    0881*  	dl 0x0000D1 ; 54.844 27, 0.818
0B115D D4 00 00    0882*  	dl 0x0000D4 ; 56.250 28, 0.831
0B1160 D8 00 00    0883*  	dl 0x0000D8 ; 57.656 29, 0.845
0B1163 DB 00 00    0884*  	dl 0x0000DB ; 59.063 2A, 0.858
0B1166 DE 00 00    0885*  	dl 0x0000DE ; 60.469 2B, 0.870
0B1169 E1 00 00    0886*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B116C E4 00 00    0887*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B116F E7 00 00    0888*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B1172 EA 00 00    0889*  	dl 0x0000EA ; 66.094 2F, 0.914
0B1175 EC 00 00    0890*  	dl 0x0000EC ; 67.500 30, 0.924
0B1178 EE 00 00    0891*  	dl 0x0000EE ; 68.906 31, 0.933
0B117B F1 00 00    0892*  	dl 0x0000F1 ; 70.313 32, 0.942
0B117E F3 00 00    0893*  	dl 0x0000F3 ; 71.719 33, 0.950
0B1181 F4 00 00    0894*  	dl 0x0000F4 ; 73.125 34, 0.957
0B1184 F6 00 00    0895*  	dl 0x0000F6 ; 74.531 35, 0.964
0B1187 F8 00 00    0896*  	dl 0x0000F8 ; 75.938 36, 0.970
0B118A F9 00 00    0897*  	dl 0x0000F9 ; 77.344 37, 0.976
0B118D FB 00 00    0898*  	dl 0x0000FB ; 78.750 38, 0.981
0B1190 FC 00 00    0899*  	dl 0x0000FC ; 80.156 39, 0.985
0B1193 FD 00 00    0900*  	dl 0x0000FD ; 81.563 3A, 0.989
0B1196 FE 00 00    0901*  	dl 0x0000FE ; 82.969 3B, 0.992
0B1199 FE 00 00    0902*  	dl 0x0000FE ; 84.375 3C, 0.995
0B119C FF 00 00    0903*  	dl 0x0000FF ; 85.781 3D, 0.997
0B119F FF 00 00    0904*  	dl 0x0000FF ; 87.188 3E, 0.999
0B11A2 FF 00 00    0905*  	dl 0x0000FF ; 88.594 3F, 1.000
0B11A5 00 01 00    0906*  	dl 0x000100 ; 90.000 40, 1.000
0B11A8 FF 00 00    0907*  	dl 0x0000FF ; 91.406 41, 1.000
0B11AB FF 00 00    0908*  	dl 0x0000FF ; 92.813 42, 0.999
0B11AE FF 00 00    0909*  	dl 0x0000FF ; 94.219 43, 0.997
0B11B1 FE 00 00    0910*  	dl 0x0000FE ; 95.625 44, 0.995
0B11B4 FE 00 00    0911*  	dl 0x0000FE ; 97.031 45, 0.992
0B11B7 FD 00 00    0912*  	dl 0x0000FD ; 98.438 46, 0.989
0B11BA FC 00 00    0913*  	dl 0x0000FC ; 99.844 47, 0.985
0B11BD FB 00 00    0914*  	dl 0x0000FB ; 101.250 48, 0.981
0B11C0 F9 00 00    0915*  	dl 0x0000F9 ; 102.656 49, 0.976
0B11C3 F8 00 00    0916*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B11C6 F6 00 00    0917*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B11C9 F4 00 00    0918*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B11CC F3 00 00    0919*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B11CF F1 00 00    0920*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B11D2 EE 00 00    0921*  	dl 0x0000EE ; 111.094 4F, 0.933
0B11D5 EC 00 00    0922*  	dl 0x0000EC ; 112.500 50, 0.924
0B11D8 EA 00 00    0923*  	dl 0x0000EA ; 113.906 51, 0.914
0B11DB E7 00 00    0924*  	dl 0x0000E7 ; 115.313 52, 0.904
0B11DE E4 00 00    0925*  	dl 0x0000E4 ; 116.719 53, 0.893
0B11E1 E1 00 00    0926*  	dl 0x0000E1 ; 118.125 54, 0.882
0B11E4 DE 00 00    0927*  	dl 0x0000DE ; 119.531 55, 0.870
0B11E7 DB 00 00    0928*  	dl 0x0000DB ; 120.938 56, 0.858
0B11EA D8 00 00    0929*  	dl 0x0000D8 ; 122.344 57, 0.845
0B11ED D4 00 00    0930*  	dl 0x0000D4 ; 123.750 58, 0.831
0B11F0 D1 00 00    0931*  	dl 0x0000D1 ; 125.156 59, 0.818
0B11F3 CD 00 00    0932*  	dl 0x0000CD ; 126.563 5A, 0.803
0B11F6 C9 00 00    0933*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B11F9 C5 00 00    0934*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B11FC C1 00 00    0935*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B11FF BD 00 00    0936*  	dl 0x0000BD ; 132.188 5E, 0.741
0B1202 B9 00 00    0937*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B1205 B5 00 00    0938*  	dl 0x0000B5 ; 135.000 60, 0.707
0B1208 B0 00 00    0939*  	dl 0x0000B0 ; 136.406 61, 0.690
0B120B AB 00 00    0940*  	dl 0x0000AB ; 137.813 62, 0.672
0B120E A7 00 00    0941*  	dl 0x0000A7 ; 139.219 63, 0.653
0B1211 A2 00 00    0942*  	dl 0x0000A2 ; 140.625 64, 0.634
0B1214 9D 00 00    0943*  	dl 0x00009D ; 142.031 65, 0.615
0B1217 98 00 00    0944*  	dl 0x000098 ; 143.438 66, 0.596
0B121A 93 00 00    0945*  	dl 0x000093 ; 144.844 67, 0.576
0B121D 8E 00 00    0946*  	dl 0x00008E ; 146.250 68, 0.556
0B1220 88 00 00    0947*  	dl 0x000088 ; 147.656 69, 0.535
0B1223 83 00 00    0948*  	dl 0x000083 ; 149.063 6A, 0.514
0B1226 7E 00 00    0949*  	dl 0x00007E ; 150.469 6B, 0.493
0B1229 78 00 00    0950*  	dl 0x000078 ; 151.875 6C, 0.471
0B122C 73 00 00    0951*  	dl 0x000073 ; 153.281 6D, 0.450
0B122F 6D 00 00    0952*  	dl 0x00006D ; 154.688 6E, 0.428
0B1232 67 00 00    0953*  	dl 0x000067 ; 156.094 6F, 0.405
0B1235 61 00 00    0954*  	dl 0x000061 ; 157.500 70, 0.383
0B1238 5C 00 00    0955*  	dl 0x00005C ; 158.906 71, 0.360
0B123B 56 00 00    0956*  	dl 0x000056 ; 160.313 72, 0.337
0B123E 50 00 00    0957*  	dl 0x000050 ; 161.719 73, 0.314
0B1241 4A 00 00    0958*  	dl 0x00004A ; 163.125 74, 0.290
0B1244 44 00 00    0959*  	dl 0x000044 ; 164.531 75, 0.267
0B1247 3E 00 00    0960*  	dl 0x00003E ; 165.938 76, 0.243
0B124A 38 00 00    0961*  	dl 0x000038 ; 167.344 77, 0.219
0B124D 31 00 00    0962*  	dl 0x000031 ; 168.750 78, 0.195
0B1250 2B 00 00    0963*  	dl 0x00002B ; 170.156 79, 0.171
0B1253 25 00 00    0964*  	dl 0x000025 ; 171.563 7A, 0.147
0B1256 1F 00 00    0965*  	dl 0x00001F ; 172.969 7B, 0.122
0B1259 19 00 00    0966*  	dl 0x000019 ; 174.375 7C, 0.098
0B125C 12 00 00    0967*  	dl 0x000012 ; 175.781 7D, 0.074
0B125F 0C 00 00    0968*  	dl 0x00000C ; 177.188 7E, 0.049
0B1262 06 00 00    0969*  	dl 0x000006 ; 178.594 7F, 0.025
0B1265 00 00 00    0970*  	dl 0x000000 ; 180.000 80, 0.000
0B1268 FA FF FF    0971*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B126B F4 FF FF    0972*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B126E EE FF FF    0973*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B1271 E7 FF FF    0974*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B1274 E1 FF FF    0975*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B1277 DB FF FF    0976*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B127A D5 FF FF    0977*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B127D CF FF FF    0978*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B1280 C8 FF FF    0979*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B1283 C2 FF FF    0980*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B1286 BC FF FF    0981*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B1289 B6 FF FF    0982*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B128C B0 FF FF    0983*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B128F AA FF FF    0984*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B1292 A4 FF FF    0985*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B1295 9F FF FF    0986*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B1298 99 FF FF    0987*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B129B 93 FF FF    0988*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B129E 8D FF FF    0989*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B12A1 88 FF FF    0990*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B12A4 82 FF FF    0991*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B12A7 7D FF FF    0992*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B12AA 78 FF FF    0993*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B12AD 72 FF FF    0994*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B12B0 6D FF FF    0995*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B12B3 68 FF FF    0996*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B12B6 63 FF FF    0997*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B12B9 5E FF FF    0998*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B12BC 59 FF FF    0999*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B12BF 55 FF FF    1000*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B12C2 50 FF FF    1001*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B12C5 4B FF FF    1002*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B12C8 47 FF FF    1003*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B12CB 43 FF FF    1004*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B12CE 3F FF FF    1005*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B12D1 3B FF FF    1006*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B12D4 37 FF FF    1007*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B12D7 33 FF FF    1008*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B12DA 2F FF FF    1009*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B12DD 2C FF FF    1010*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B12E0 28 FF FF    1011*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B12E3 25 FF FF    1012*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B12E6 22 FF FF    1013*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B12E9 1F FF FF    1014*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B12EC 1C FF FF    1015*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B12EF 19 FF FF    1016*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B12F2 16 FF FF    1017*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B12F5 14 FF FF    1018*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B12F8 12 FF FF    1019*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B12FB 0F FF FF    1020*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B12FE 0D FF FF    1021*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B1301 0C FF FF    1022*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B1304 0A FF FF    1023*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B1307 08 FF FF    1024*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B130A 07 FF FF    1025*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B130D 05 FF FF    1026*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B1310 04 FF FF    1027*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B1313 03 FF FF    1028*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B1316 02 FF FF    1029*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B1319 02 FF FF    1030*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B131C 01 FF FF    1031*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B131F 01 FF FF    1032*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B1322 01 FF FF    1033*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B1325 00 FF FF    1034*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B1328 01 FF FF    1035*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B132B 01 FF FF    1036*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B132E 01 FF FF    1037*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B1331 02 FF FF    1038*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B1334 02 FF FF    1039*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B1337 03 FF FF    1040*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B133A 04 FF FF    1041*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B133D 05 FF FF    1042*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B1340 07 FF FF    1043*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B1343 08 FF FF    1044*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B1346 0A FF FF    1045*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B1349 0C FF FF    1046*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B134C 0D FF FF    1047*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B134F 0F FF FF    1048*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B1352 12 FF FF    1049*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B1355 14 FF FF    1050*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B1358 16 FF FF    1051*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B135B 19 FF FF    1052*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B135E 1C FF FF    1053*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B1361 1F FF FF    1054*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B1364 22 FF FF    1055*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B1367 25 FF FF    1056*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B136A 28 FF FF    1057*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B136D 2C FF FF    1058*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B1370 2F FF FF    1059*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B1373 33 FF FF    1060*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B1376 37 FF FF    1061*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B1379 3B FF FF    1062*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B137C 3F FF FF    1063*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B137F 43 FF FF    1064*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B1382 47 FF FF    1065*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B1385 4B FF FF    1066*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B1388 50 FF FF    1067*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B138B 55 FF FF    1068*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B138E 59 FF FF    1069*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1391 5E FF FF    1070*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1394 63 FF FF    1071*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B1397 68 FF FF    1072*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B139A 6D FF FF    1073*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B139D 72 FF FF    1074*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B13A0 78 FF FF    1075*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B13A3 7D FF FF    1076*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B13A6 82 FF FF    1077*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B13A9 88 FF FF    1078*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B13AC 8D FF FF    1079*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B13AF 93 FF FF    1080*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B13B2 99 FF FF    1081*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B13B5 9F FF FF    1082*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B13B8 A4 FF FF    1083*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B13BB AA FF FF    1084*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B13BE B0 FF FF    1085*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B13C1 B6 FF FF    1086*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B13C4 BC FF FF    1087*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B13C7 C2 FF FF    1088*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B13CA C8 FF FF    1089*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B13CD CF FF FF    1090*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B13D0 D5 FF FF    1091*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B13D3 DB FF FF    1092*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B13D6 E1 FF FF    1093*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B13D9 E7 FF FF    1094*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B13DC EE FF FF    1095*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B13DF F4 FF FF    1096*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B13E2 FA FF FF    1097*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B13E5             1098*  
0B13E5             1099*  atan_lut_168:
0B13E5 00 00 00    1100*  	dl 0x000000 ; 000000, 0.000
0B13E8 28 00 00    1101*  	dl 0x000028 ; 000001, 0.224
0B13EB 51 00 00    1102*  	dl 0x000051 ; 000002, 0.448
0B13EE 7A 00 00    1103*  	dl 0x00007A ; 000003, 0.671
0B13F1 A2 00 00    1104*  	dl 0x0000A2 ; 000004, 0.895
0B13F4 CB 00 00    1105*  	dl 0x0000CB ; 000005, 1.119
0B13F7 F4 00 00    1106*  	dl 0x0000F4 ; 000006, 1.343
0B13FA 1D 01 00    1107*  	dl 0x00011D ; 000007, 1.566
0B13FD 45 01 00    1108*  	dl 0x000145 ; 000008, 1.790
0B1400 6E 01 00    1109*  	dl 0x00016E ; 000009, 2.013
0B1403 97 01 00    1110*  	dl 0x000197 ; 00000A, 2.237
0B1406 BF 01 00    1111*  	dl 0x0001BF ; 00000B, 2.460
0B1409 E8 01 00    1112*  	dl 0x0001E8 ; 00000C, 2.684
0B140C 11 02 00    1113*  	dl 0x000211 ; 00000D, 2.907
0B140F 39 02 00    1114*  	dl 0x000239 ; 00000E, 3.130
0B1412 62 02 00    1115*  	dl 0x000262 ; 00000F, 3.353
0B1415 8B 02 00    1116*  	dl 0x00028B ; 000010, 3.576
0B1418 B3 02 00    1117*  	dl 0x0002B3 ; 000011, 3.799
0B141B DC 02 00    1118*  	dl 0x0002DC ; 000012, 4.022
0B141E 04 03 00    1119*  	dl 0x000304 ; 000013, 4.245
0B1421 2D 03 00    1120*  	dl 0x00032D ; 000014, 4.467
0B1424 55 03 00    1121*  	dl 0x000355 ; 000015, 4.690
0B1427 7E 03 00    1122*  	dl 0x00037E ; 000016, 4.912
0B142A A6 03 00    1123*  	dl 0x0003A6 ; 000017, 5.134
0B142D CE 03 00    1124*  	dl 0x0003CE ; 000018, 5.356
0B1430 F7 03 00    1125*  	dl 0x0003F7 ; 000019, 5.578
0B1433 1F 04 00    1126*  	dl 0x00041F ; 00001A, 5.799
0B1436 48 04 00    1127*  	dl 0x000448 ; 00001B, 6.021
0B1439 70 04 00    1128*  	dl 0x000470 ; 00001C, 6.242
0B143C 98 04 00    1129*  	dl 0x000498 ; 00001D, 6.463
0B143F C0 04 00    1130*  	dl 0x0004C0 ; 00001E, 6.684
0B1442 E8 04 00    1131*  	dl 0x0004E8 ; 00001F, 6.905
0B1445 11 05 00    1132*  	dl 0x000511 ; 000020, 7.125
0B1448 39 05 00    1133*  	dl 0x000539 ; 000021, 7.345
0B144B 61 05 00    1134*  	dl 0x000561 ; 000022, 7.565
0B144E 89 05 00    1135*  	dl 0x000589 ; 000023, 7.785
0B1451 B1 05 00    1136*  	dl 0x0005B1 ; 000024, 8.005
0B1454 D9 05 00    1137*  	dl 0x0005D9 ; 000025, 8.224
0B1457 01 06 00    1138*  	dl 0x000601 ; 000026, 8.443
0B145A 28 06 00    1139*  	dl 0x000628 ; 000027, 8.662
0B145D 50 06 00    1140*  	dl 0x000650 ; 000028, 8.881
0B1460 78 06 00    1141*  	dl 0x000678 ; 000029, 9.099
0B1463 A0 06 00    1142*  	dl 0x0006A0 ; 00002A, 9.317
0B1466 C7 06 00    1143*  	dl 0x0006C7 ; 00002B, 9.535
0B1469 EF 06 00    1144*  	dl 0x0006EF ; 00002C, 9.752
0B146C 16 07 00    1145*  	dl 0x000716 ; 00002D, 9.970
0B146F 3E 07 00    1146*  	dl 0x00073E ; 00002E, 10.187
0B1472 65 07 00    1147*  	dl 0x000765 ; 00002F, 10.403
0B1475 8D 07 00    1148*  	dl 0x00078D ; 000030, 10.620
0B1478 B4 07 00    1149*  	dl 0x0007B4 ; 000031, 10.836
0B147B DB 07 00    1150*  	dl 0x0007DB ; 000032, 11.051
0B147E 03 08 00    1151*  	dl 0x000803 ; 000033, 11.267
0B1481 2A 08 00    1152*  	dl 0x00082A ; 000034, 11.482
0B1484 51 08 00    1153*  	dl 0x000851 ; 000035, 11.697
0B1487 78 08 00    1154*  	dl 0x000878 ; 000036, 11.911
0B148A 9F 08 00    1155*  	dl 0x00089F ; 000037, 12.125
0B148D C6 08 00    1156*  	dl 0x0008C6 ; 000038, 12.339
0B1490 ED 08 00    1157*  	dl 0x0008ED ; 000039, 12.553
0B1493 13 09 00    1158*  	dl 0x000913 ; 00003A, 12.766
0B1496 3A 09 00    1159*  	dl 0x00093A ; 00003B, 12.978
0B1499 61 09 00    1160*  	dl 0x000961 ; 00003C, 13.191
0B149C 87 09 00    1161*  	dl 0x000987 ; 00003D, 13.403
0B149F AE 09 00    1162*  	dl 0x0009AE ; 00003E, 13.614
0B14A2 D4 09 00    1163*  	dl 0x0009D4 ; 00003F, 13.825
0B14A5 FB 09 00    1164*  	dl 0x0009FB ; 000040, 14.036
0B14A8 21 0A 00    1165*  	dl 0x000A21 ; 000041, 14.247
0B14AB 47 0A 00    1166*  	dl 0x000A47 ; 000042, 14.457
0B14AE 6D 0A 00    1167*  	dl 0x000A6D ; 000043, 14.666
0B14B1 94 0A 00    1168*  	dl 0x000A94 ; 000044, 14.876
0B14B4 BA 0A 00    1169*  	dl 0x000ABA ; 000045, 15.085
0B14B7 E0 0A 00    1170*  	dl 0x000AE0 ; 000046, 15.293
0B14BA 05 0B 00    1171*  	dl 0x000B05 ; 000047, 15.501
0B14BD 2B 0B 00    1172*  	dl 0x000B2B ; 000048, 15.709
0B14C0 51 0B 00    1173*  	dl 0x000B51 ; 000049, 15.916
0B14C3 77 0B 00    1174*  	dl 0x000B77 ; 00004A, 16.123
0B14C6 9C 0B 00    1175*  	dl 0x000B9C ; 00004B, 16.329
0B14C9 C2 0B 00    1176*  	dl 0x000BC2 ; 00004C, 16.535
0B14CC E7 0B 00    1177*  	dl 0x000BE7 ; 00004D, 16.740
0B14CF 0C 0C 00    1178*  	dl 0x000C0C ; 00004E, 16.945
0B14D2 32 0C 00    1179*  	dl 0x000C32 ; 00004F, 17.150
0B14D5 57 0C 00    1180*  	dl 0x000C57 ; 000050, 17.354
0B14D8 7C 0C 00    1181*  	dl 0x000C7C ; 000051, 17.558
0B14DB A1 0C 00    1182*  	dl 0x000CA1 ; 000052, 17.761
0B14DE C6 0C 00    1183*  	dl 0x000CC6 ; 000053, 17.964
0B14E1 EB 0C 00    1184*  	dl 0x000CEB ; 000054, 18.166
0B14E4 0F 0D 00    1185*  	dl 0x000D0F ; 000055, 18.368
0B14E7 34 0D 00    1186*  	dl 0x000D34 ; 000056, 18.569
0B14EA 58 0D 00    1187*  	dl 0x000D58 ; 000057, 18.770
0B14ED 7D 0D 00    1188*  	dl 0x000D7D ; 000058, 18.970
0B14F0 A1 0D 00    1189*  	dl 0x000DA1 ; 000059, 19.170
0B14F3 C6 0D 00    1190*  	dl 0x000DC6 ; 00005A, 19.370
0B14F6 EA 0D 00    1191*  	dl 0x000DEA ; 00005B, 19.569
0B14F9 0E 0E 00    1192*  	dl 0x000E0E ; 00005C, 19.767
0B14FC 32 0E 00    1193*  	dl 0x000E32 ; 00005D, 19.965
0B14FF 56 0E 00    1194*  	dl 0x000E56 ; 00005E, 20.163
0B1502 7A 0E 00    1195*  	dl 0x000E7A ; 00005F, 20.360
0B1505 9E 0E 00    1196*  	dl 0x000E9E ; 000060, 20.556
0B1508 C1 0E 00    1197*  	dl 0x000EC1 ; 000061, 20.752
0B150B E5 0E 00    1198*  	dl 0x000EE5 ; 000062, 20.947
0B150E 08 0F 00    1199*  	dl 0x000F08 ; 000063, 21.142
0B1511 2C 0F 00    1200*  	dl 0x000F2C ; 000064, 21.337
0B1514 4F 0F 00    1201*  	dl 0x000F4F ; 000065, 21.531
0B1517 72 0F 00    1202*  	dl 0x000F72 ; 000066, 21.724
0B151A 95 0F 00    1203*  	dl 0x000F95 ; 000067, 21.917
0B151D B8 0F 00    1204*  	dl 0x000FB8 ; 000068, 22.109
0B1520 DB 0F 00    1205*  	dl 0x000FDB ; 000069, 22.301
0B1523 FE 0F 00    1206*  	dl 0x000FFE ; 00006A, 22.493
0B1526 21 10 00    1207*  	dl 0x001021 ; 00006B, 22.683
0B1529 44 10 00    1208*  	dl 0x001044 ; 00006C, 22.874
0B152C 66 10 00    1209*  	dl 0x001066 ; 00006D, 23.063
0B152F 89 10 00    1210*  	dl 0x001089 ; 00006E, 23.253
0B1532 AB 10 00    1211*  	dl 0x0010AB ; 00006F, 23.441
0B1535 CD 10 00    1212*  	dl 0x0010CD ; 000070, 23.629
0B1538 EF 10 00    1213*  	dl 0x0010EF ; 000071, 23.817
0B153B 11 11 00    1214*  	dl 0x001111 ; 000072, 24.004
0B153E 33 11 00    1215*  	dl 0x001133 ; 000073, 24.191
0B1541 55 11 00    1216*  	dl 0x001155 ; 000074, 24.376
0B1544 77 11 00    1217*  	dl 0x001177 ; 000075, 24.562
0B1547 99 11 00    1218*  	dl 0x001199 ; 000076, 24.747
0B154A BA 11 00    1219*  	dl 0x0011BA ; 000077, 24.931
0B154D DC 11 00    1220*  	dl 0x0011DC ; 000078, 25.115
0B1550 FD 11 00    1221*  	dl 0x0011FD ; 000079, 25.298
0B1553 1E 12 00    1222*  	dl 0x00121E ; 00007A, 25.481
0B1556 3F 12 00    1223*  	dl 0x00123F ; 00007B, 25.663
0B1559 60 12 00    1224*  	dl 0x001260 ; 00007C, 25.844
0B155C 81 12 00    1225*  	dl 0x001281 ; 00007D, 26.025
0B155F A2 12 00    1226*  	dl 0x0012A2 ; 00007E, 26.206
0B1562 C3 12 00    1227*  	dl 0x0012C3 ; 00007F, 26.386
0B1565 E4 12 00    1228*  	dl 0x0012E4 ; 000080, 26.565
0B1568 04 13 00    1229*  	dl 0x001304 ; 000081, 26.744
0B156B 25 13 00    1230*  	dl 0x001325 ; 000082, 26.922
0B156E 45 13 00    1231*  	dl 0x001345 ; 000083, 27.100
0B1571 65 13 00    1232*  	dl 0x001365 ; 000084, 27.277
0B1574 85 13 00    1233*  	dl 0x001385 ; 000085, 27.453
0B1577 A5 13 00    1234*  	dl 0x0013A5 ; 000086, 27.629
0B157A C5 13 00    1235*  	dl 0x0013C5 ; 000087, 27.805
0B157D E5 13 00    1236*  	dl 0x0013E5 ; 000088, 27.979
0B1580 05 14 00    1237*  	dl 0x001405 ; 000089, 28.154
0B1583 24 14 00    1238*  	dl 0x001424 ; 00008A, 28.327
0B1586 44 14 00    1239*  	dl 0x001444 ; 00008B, 28.501
0B1589 63 14 00    1240*  	dl 0x001463 ; 00008C, 28.673
0B158C 83 14 00    1241*  	dl 0x001483 ; 00008D, 28.845
0B158F A2 14 00    1242*  	dl 0x0014A2 ; 00008E, 29.017
0B1592 C1 14 00    1243*  	dl 0x0014C1 ; 00008F, 29.187
0B1595 E0 14 00    1244*  	dl 0x0014E0 ; 000090, 29.358
0B1598 FF 14 00    1245*  	dl 0x0014FF ; 000091, 29.527
0B159B 1E 15 00    1246*  	dl 0x00151E ; 000092, 29.697
0B159E 3C 15 00    1247*  	dl 0x00153C ; 000093, 29.865
0B15A1 5B 15 00    1248*  	dl 0x00155B ; 000094, 30.033
0B15A4 79 15 00    1249*  	dl 0x001579 ; 000095, 30.201
0B15A7 98 15 00    1250*  	dl 0x001598 ; 000096, 30.368
0B15AA B6 15 00    1251*  	dl 0x0015B6 ; 000097, 30.534
0B15AD D4 15 00    1252*  	dl 0x0015D4 ; 000098, 30.700
0B15B0 F2 15 00    1253*  	dl 0x0015F2 ; 000099, 30.865
0B15B3 10 16 00    1254*  	dl 0x001610 ; 00009A, 31.030
0B15B6 2E 16 00    1255*  	dl 0x00162E ; 00009B, 31.194
0B15B9 4C 16 00    1256*  	dl 0x00164C ; 00009C, 31.357
0B15BC 6A 16 00    1257*  	dl 0x00166A ; 00009D, 31.520
0B15BF 87 16 00    1258*  	dl 0x001687 ; 00009E, 31.682
0B15C2 A5 16 00    1259*  	dl 0x0016A5 ; 00009F, 31.844
0B15C5 C2 16 00    1260*  	dl 0x0016C2 ; 0000A0, 32.005
0B15C8 DF 16 00    1261*  	dl 0x0016DF ; 0000A1, 32.166
0B15CB FC 16 00    1262*  	dl 0x0016FC ; 0000A2, 32.326
0B15CE 19 17 00    1263*  	dl 0x001719 ; 0000A3, 32.486
0B15D1 36 17 00    1264*  	dl 0x001736 ; 0000A4, 32.645
0B15D4 53 17 00    1265*  	dl 0x001753 ; 0000A5, 32.803
0B15D7 70 17 00    1266*  	dl 0x001770 ; 0000A6, 32.961
0B15DA 8C 17 00    1267*  	dl 0x00178C ; 0000A7, 33.118
0B15DD A9 17 00    1268*  	dl 0x0017A9 ; 0000A8, 33.275
0B15E0 C5 17 00    1269*  	dl 0x0017C5 ; 0000A9, 33.431
0B15E3 E2 17 00    1270*  	dl 0x0017E2 ; 0000AA, 33.587
0B15E6 FE 17 00    1271*  	dl 0x0017FE ; 0000AB, 33.742
0B15E9 1A 18 00    1272*  	dl 0x00181A ; 0000AC, 33.896
0B15EC 36 18 00    1273*  	dl 0x001836 ; 0000AD, 34.050
0B15EF 52 18 00    1274*  	dl 0x001852 ; 0000AE, 34.203
0B15F2 6E 18 00    1275*  	dl 0x00186E ; 0000AF, 34.356
0B15F5 8A 18 00    1276*  	dl 0x00188A ; 0000B0, 34.509
0B15F8 A5 18 00    1277*  	dl 0x0018A5 ; 0000B1, 34.660
0B15FB C1 18 00    1278*  	dl 0x0018C1 ; 0000B2, 34.811
0B15FE DC 18 00    1279*  	dl 0x0018DC ; 0000B3, 34.962
0B1601 F7 18 00    1280*  	dl 0x0018F7 ; 0000B4, 35.112
0B1604 13 19 00    1281*  	dl 0x001913 ; 0000B5, 35.262
0B1607 2E 19 00    1282*  	dl 0x00192E ; 0000B6, 35.410
0B160A 49 19 00    1283*  	dl 0x001949 ; 0000B7, 35.559
0B160D 64 19 00    1284*  	dl 0x001964 ; 0000B8, 35.707
0B1610 7F 19 00    1285*  	dl 0x00197F ; 0000B9, 35.854
0B1613 99 19 00    1286*  	dl 0x001999 ; 0000BA, 36.001
0B1616 B4 19 00    1287*  	dl 0x0019B4 ; 0000BB, 36.147
0B1619 CE 19 00    1288*  	dl 0x0019CE ; 0000BC, 36.293
0B161C E9 19 00    1289*  	dl 0x0019E9 ; 0000BD, 36.438
0B161F 03 1A 00    1290*  	dl 0x001A03 ; 0000BE, 36.582
0B1622 1D 1A 00    1291*  	dl 0x001A1D ; 0000BF, 36.726
0B1625 37 1A 00    1292*  	dl 0x001A37 ; 0000C0, 36.870
0B1628 51 1A 00    1293*  	dl 0x001A51 ; 0000C1, 37.013
0B162B 6B 1A 00    1294*  	dl 0x001A6B ; 0000C2, 37.155
0B162E 85 1A 00    1295*  	dl 0x001A85 ; 0000C3, 37.297
0B1631 9F 1A 00    1296*  	dl 0x001A9F ; 0000C4, 37.439
0B1634 B9 1A 00    1297*  	dl 0x001AB9 ; 0000C5, 37.579
0B1637 D2 1A 00    1298*  	dl 0x001AD2 ; 0000C6, 37.720
0B163A EC 1A 00    1299*  	dl 0x001AEC ; 0000C7, 37.859
0B163D 05 1B 00    1300*  	dl 0x001B05 ; 0000C8, 37.999
0B1640 1E 1B 00    1301*  	dl 0x001B1E ; 0000C9, 38.137
0B1643 37 1B 00    1302*  	dl 0x001B37 ; 0000CA, 38.276
0B1646 50 1B 00    1303*  	dl 0x001B50 ; 0000CB, 38.413
0B1649 69 1B 00    1304*  	dl 0x001B69 ; 0000CC, 38.550
0B164C 82 1B 00    1305*  	dl 0x001B82 ; 0000CD, 38.687
0B164F 9B 1B 00    1306*  	dl 0x001B9B ; 0000CE, 38.823
0B1652 B4 1B 00    1307*  	dl 0x001BB4 ; 0000CF, 38.959
0B1655 CC 1B 00    1308*  	dl 0x001BCC ; 0000D0, 39.094
0B1658 E5 1B 00    1309*  	dl 0x001BE5 ; 0000D1, 39.228
0B165B FD 1B 00    1310*  	dl 0x001BFD ; 0000D2, 39.362
0B165E 16 1C 00    1311*  	dl 0x001C16 ; 0000D3, 39.496
0B1661 2E 1C 00    1312*  	dl 0x001C2E ; 0000D4, 39.629
0B1664 46 1C 00    1313*  	dl 0x001C46 ; 0000D5, 39.762
0B1667 5E 1C 00    1314*  	dl 0x001C5E ; 0000D6, 39.894
0B166A 76 1C 00    1315*  	dl 0x001C76 ; 0000D7, 40.025
0B166D 8E 1C 00    1316*  	dl 0x001C8E ; 0000D8, 40.156
0B1670 A5 1C 00    1317*  	dl 0x001CA5 ; 0000D9, 40.286
0B1673 BD 1C 00    1318*  	dl 0x001CBD ; 0000DA, 40.416
0B1676 D5 1C 00    1319*  	dl 0x001CD5 ; 0000DB, 40.546
0B1679 EC 1C 00    1320*  	dl 0x001CEC ; 0000DC, 40.675
0B167C 04 1D 00    1321*  	dl 0x001D04 ; 0000DD, 40.803
0B167F 1B 1D 00    1322*  	dl 0x001D1B ; 0000DE, 40.931
0B1682 32 1D 00    1323*  	dl 0x001D32 ; 0000DF, 41.059
0B1685 49 1D 00    1324*  	dl 0x001D49 ; 0000E0, 41.186
0B1688 60 1D 00    1325*  	dl 0x001D60 ; 0000E1, 41.312
0B168B 77 1D 00    1326*  	dl 0x001D77 ; 0000E2, 41.438
0B168E 8E 1D 00    1327*  	dl 0x001D8E ; 0000E3, 41.564
0B1691 A5 1D 00    1328*  	dl 0x001DA5 ; 0000E4, 41.689
0B1694 BB 1D 00    1329*  	dl 0x001DBB ; 0000E5, 41.814
0B1697 D2 1D 00    1330*  	dl 0x001DD2 ; 0000E6, 41.938
0B169A E9 1D 00    1331*  	dl 0x001DE9 ; 0000E7, 42.061
0B169D FF 1D 00    1332*  	dl 0x001DFF ; 0000E8, 42.184
0B16A0 15 1E 00    1333*  	dl 0x001E15 ; 0000E9, 42.307
0B16A3 2C 1E 00    1334*  	dl 0x001E2C ; 0000EA, 42.429
0B16A6 42 1E 00    1335*  	dl 0x001E42 ; 0000EB, 42.551
0B16A9 58 1E 00    1336*  	dl 0x001E58 ; 0000EC, 42.672
0B16AC 6E 1E 00    1337*  	dl 0x001E6E ; 0000ED, 42.793
0B16AF 84 1E 00    1338*  	dl 0x001E84 ; 0000EE, 42.913
0B16B2 99 1E 00    1339*  	dl 0x001E99 ; 0000EF, 43.033
0B16B5 AF 1E 00    1340*  	dl 0x001EAF ; 0000F0, 43.152
0B16B8 C5 1E 00    1341*  	dl 0x001EC5 ; 0000F1, 43.271
0B16BB DA 1E 00    1342*  	dl 0x001EDA ; 0000F2, 43.390
0B16BE F0 1E 00    1343*  	dl 0x001EF0 ; 0000F3, 43.508
0B16C1 05 1F 00    1344*  	dl 0x001F05 ; 0000F4, 43.625
0B16C4 1B 1F 00    1345*  	dl 0x001F1B ; 0000F5, 43.742
0B16C7 30 1F 00    1346*  	dl 0x001F30 ; 0000F6, 43.859
0B16CA 45 1F 00    1347*  	dl 0x001F45 ; 0000F7, 43.975
0B16CD 5A 1F 00    1348*  	dl 0x001F5A ; 0000F8, 44.091
0B16D0 6F 1F 00    1349*  	dl 0x001F6F ; 0000F9, 44.206
0B16D3 84 1F 00    1350*  	dl 0x001F84 ; 0000FA, 44.321
0B16D6 99 1F 00    1351*  	dl 0x001F99 ; 0000FB, 44.435
0B16D9 AD 1F 00    1352*  	dl 0x001FAD ; 0000FC, 44.549
0B16DC C2 1F 00    1353*  	dl 0x001FC2 ; 0000FD, 44.662
0B16DF D7 1F 00    1354*  	dl 0x001FD7 ; 0000FE, 44.775
0B16E2 EB 1F 00    1355*  	dl 0x001FEB ; 0000FF, 44.888
0B16E5 00 20 00    1356*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B16E8             1357*  
0B16E8             1358*  
0B16E8             1359*  	; ======= div_168_signed.inc stuff =======
0B16E8             1360*  
0B16E8             1361*  	; 24-bit integer and 16.8 fixed point division routines
0B16E8             1362*  ; by Brandon R. Gates (BeeGee747)
0B16E8             1363*  ; have undergone cursory testing and seem to be generating
0B16E8             1364*  ; correct results (assuming no overflows) but seem very inefficient,
0B16E8             1365*  ; so they have been published for review and improvement
0B16E8             1366*  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
0B16E8             1367*  ;
0B16E8             1368*  ; ---------------------------------------------------------
0B16E8             1369*  ; BEGIN DIVISION ROUTINES
0B16E8             1370*  ; ---------------------------------------------------------
0B16E8             1371*  ;
0B16E8             1372*  ; perform signed division of 16.8 fixed place values
0B16E8             1373*  ; with an signed 16.8 fixed place result
0B16E8             1374*  ; inputs: ub.c is dividend,ud.e is divisor
0B16E8             1375*  ; outputs: uh.l is quotient
0B16E8             1376*  ; destroys: a,bc
0B16E8             1377*  ; note: uses carry flag to test for sign of operands and result
0B16E8             1378*  ;       which can be confusing and should perhaps be changed
0B16E8             1379*  ; note2: helper functions abs_hlu and neg_hlu have been modified
0B16E8             1380*  ;       to return accurate flags according to the origional signs
0B16E8             1381*  ;       (or zero) of this function's inputs
0B16E8             1382*  sdiv168:
0B16E8             1383*  ; make everything positive and save signs
0B16E8 C5          1384*      push bc         ; get bc to hl
0B16E9 E1          1385*      pop hl          ; for the next call
0B16EA CD 8F 17 0B 1386*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
0B16EE CA 21 17 0B 1387*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B16F2 F5          1388*      push af         ; save sign of bc
0B16F3 E5          1389*      push hl         ; now put abs(hl)
0B16F4 C1          1390*      pop bc          ; back into bc = abs(bc)
0B16F5 EB          1391*      ex de,hl        ; now we do de same way
0B16F6 CD 8F 17 0B 1392*      call abs_hlu
0B16FA CA 23 17 0B 1393*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
0B16FE EB          1394*      ex de,hl        ; hl back to de = abs(de)
0B16FF             1395*  ; determine sign of result
0B16FF F2 0A 17 0B 1396*      jp p,@de_pos    ; sign positive,de is positive
0B1703 F1          1397*      pop af          ; get back sign of bc
0B1704 FA 13 17 0B 1398*      jp m,@result_pos  ; bc and de negative, result is positive
0B1708 18 05       1399*      jr @result_neg
0B170A             1400*  @de_pos:
0B170A F1          1401*      pop af          ; get back sign of bc
0B170B F2 13 17 0B 1402*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B170F             1403*                      ; fall through to result_neg
0B170F             1404*  @result_neg:
0B170F AF          1405*      xor a           ; zero a and clear carry
0B1710 3D          1406*      dec a           ; set sign flag to negative
0B1711 18 02       1407*      jr @do_div
0B1713             1408*  @result_pos:
0B1713 AF          1409*      xor a           ; zero a and clear carry
0B1714 3C          1410*      inc a           ; set sign flag to negative
0B1715             1411*                      ; fall through to do_div
0B1715             1412*  @do_div:
0B1715 F5          1413*      push af         ; save sign of result
0B1716 CD 26 17 0B 1414*      call udiv168
0B171A F1          1415*      pop af          ; get back sign of result
0B171B F0          1416*      ret p           ; result is positive so nothing to do
0B171C CD 9F 17 0B 1417*      call neg_hlu    ; result is negative so negate it
0B1720 C9          1418*      ret
0B1721             1419*  @is_zero:           ; result is zero
0B1721 AF          1420*      xor a           ; sets zero flag, which we want,
0B1722             1421*                      ; sets pv flag which we might not (zero is parity even)
0B1722             1422*                      ; resets all others which is okay
0B1722 C9          1423*      ret
0B1723             1424*  @div_by_zero:       ; result is undefined, which isn't defined in binary
0B1723             1425*                      ; so we'll just return zero until i can think of something better
0B1723 F1          1426*      pop af          ; dummy pop
0B1724 AF          1427*      xor a           ; sets zero flag, which is ok,
0B1725             1428*                      ; sets pv flag which could be interpreted as overflow, which is good
0B1725             1429*                      ; resets all others which is okay
0B1725 C9          1430*      ret
0B1726             1431*  
0B1726             1432*  ; ; perform unsigned division of 16.8 fixed place values
0B1726             1433*  ; ; with an unsigned 16.8 fixed place result
0B1726             1434*  ; ; inputs: ub.c is dividend,ud.e is divisor
0B1726             1435*  ; ; outputs: uh.l is quotient
0B1726             1436*  ; ; destroys: a,bc
0B1726             1437*  ; udiv168:
0B1726             1438*  ; ; get the 16-bit integer part of the quotient
0B1726             1439*  ;     ; call div_24
0B1726             1440*  ;     call udiv24
0B1726             1441*  ;     ; call dumpRegistersHex
0B1726             1442*  ; ; load quotient to upper three bytes of output
0B1726             1443*  ;     ld (div168_out+1),bc
0B1726             1444*  ; ; TODO: THIS MAY BE BUGGED
0B1726             1445*  ; ; check remainder for zero, and if it is
0B1726             1446*  ; ; we can skip calculating the fractional part
0B1726             1447*  ;     add hl,de
0B1726             1448*  ;     or a
0B1726             1449*  ;     sbc hl,de
0B1726             1450*  ;     jr nz,@div256
0B1726             1451*  ;     xor a
0B1726             1452*  ;     jr @write_frac
0B1726             1453*  ; ; END TODO
0B1726             1454*  ; @div256:
0B1726             1455*  ; ; divide divisor by 256
0B1726             1456*  ;     push hl ; save remainder
0B1726             1457*  ; ; TODO: it feels like this could be more efficient
0B1726             1458*  ;     ld (arith24ude),de
0B1726             1459*  ;     ld a,d
0B1726             1460*  ;     ld (arith24ude),a
0B1726             1461*  ;     ld a,(ude+2)
0B1726             1462*  ;     ld (ude+1),a
0B1726             1463*  ;     xor a
0B1726             1464*  ;     ld (ude+2),a
0B1726             1465*  ;     ld hl,(arith24ude) ; (just for now, we want it in de eventually)
0B1726             1466*  ; ; TODO: THIS MAY BE BUGGED
0B1726             1467*  ; ; now we check the shifted divisor for zero, and if it is
0B1726             1468*  ; ; we again set the fractional part to zero
0B1726             1469*  ;     add hl,de
0B1726             1470*  ;     or a
0B1726             1471*  ;     sbc hl,de
0B1726             1472*  ;     ex de,hl ; now de is where it's supposed to be
0B1726             1473*  ;     pop hl ; get remainder back
0B1726             1474*  ; ; TODO: THIS MAY BE BUGGED
0B1726             1475*  ;     jr nz,@div_frac
0B1726             1476*  ;     xor a
0B1726             1477*  ;     jr @write_frac
0B1726             1478*  ; ; END TODO
0B1726             1479*  ; ; now divide the remainder by the shifted divisor
0B1726             1480*  ; @div_frac:
0B1726             1481*  ;     push hl ; my kingdom for ld bc,hl
0B1726             1482*  ;     pop bc  ; or even ex bc,hl
0B1726             1483*  ;     ; call div_24
0B1726             1484*  ;     call udiv24
0B1726             1485*  ; ; load low byte of quotient to low byte of output
0B1726             1486*  ;     ld a,c
0B1726             1487*  ; @write_frac:
0B1726             1488*  ;     ld (div168_out),a
0B1726             1489*  ; ; load hl with return value
0B1726             1490*  ;     ld hl,(div168_out)
0B1726             1491*  ; ; load a with any overflow
0B1726             1492*  ;     ld a,(div168_out+3)
0B1726             1493*  ;     ret ; uh.l is the 16.8 result
0B1726             1494*  ; div168_out: ds 4 ; the extra byte is for overflow
0B1726             1495*  
0B1726             1496*  ; perform unsigned division of fixed place values
0B1726             1497*  ; with an unsigned 16.8 fixed place result
0B1726             1498*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0B1726             1499*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0B1726             1500*  ; destroys: a,bc
0B1726             1501*  udiv168:
0B1726             1502*  ; shift dividend left 8 bits
0B1726 ED 43 6E 0D 1503*      ld (arith24ubc+1),bc
       0B          
0B172B AF          1504*      xor a
0B172C 32 6D 0D 0B 1505*      ld (arith24ubc),a
0B1730 ED 4B 6D 0D 1506*      ld bc,(arith24ubc)
       0B          
0B1735 CD AA 0D 0B 1507*      call udiv24
0B1739             1508*  ; flip-flop outptuts to satisfy downstream consumers
0B1739             1509*  ; TODO: this is a hack and should be fixed
0B1739             1510*  ; (so says copilot ... but it's not wrong)
0B1739 E5          1511*      push hl
0B173A C5          1512*      push bc
0B173B E1          1513*      pop hl
0B173C C1          1514*      pop bc
0B173D C9          1515*      ret
0B173E             1516*  
0B173E             1517*  ; this is an adaptation of Div16 extended to 24 bits
0B173E             1518*  ; from https://map.grauw.nl/articles/mult_div_shifts.php
0B173E             1519*  ; it works by shifting each byte of the dividend left into carry 8 times
0B173E             1520*  ; and adding the dividend into hl if the carry is set
0B173E             1521*  ; thus hl accumulates a remainder depending on the result of each iteration
0B173E             1522*  ; ---------------------------------------------------------
0B173E             1523*  ; Divide 24-bit unsigned values
0B173E             1524*  ;   with 24-bit unsigned result
0B173E             1525*  ;   and 24-bit remainder
0B173E             1526*  ; In: Divide ubc by ude
0B173E             1527*  ; Out: ubc = result, uhl = remainder
0B173E             1528*  ; Destroys: a,hl,bc
0B173E             1529*  div_24:
0B173E 21 00 00 00 1530*      ld hl,0     ; Clear accumulator for remainder
0B1742             1531*  ; put dividend in scratch so we can get at all its bytes
0B1742 ED 43 6D 0D 1532*      ld (arith24ubc),bc ; scratch ubc also accumulates the quotient
       0B          
0B1747 3A 6F 0D 0B 1533*      ld a,(arith24ubc+2); grab the upper byte of the dividend
0B174B 06 08       1534*      ld b,8      ; loop counter for 8 bits in a byte
0B174D             1535*  @loop0:
0B174D 17          1536*      rla         ; shift the next bit of dividend into the carry flag
0B174E ED 6A       1537*      adc hl,hl   ; shift the remainder left one bit and add carry if any
0B1750 ED 52       1538*      sbc hl,de   ; subtract divisor from remainder
0B1752 30 01       1539*      jr nc,@noadd0   ; if no carry,remainder is <= divisor
0B1754             1540*                  ; meaning remainder is divisible by divisor
0B1754 19          1541*      add hl,de   ; otherwise add divisor back to remainder
0B1755             1542*                  ; reversing the previous subtraction
0B1755             1543*  @noadd0:
0B1755 10 F6       1544*      djnz @loop0 ; repeat for all 8 bits
0B1757 17          1545*      rla         ; now we shift a left one more time
0B1758 2F          1546*      cpl         ; then flip its bits for some reason
0B1759 32 6F 0D 0B 1547*      ld (arith24ubc+2),a; magically this is the upper byte of the quotient
0B175D 3A 6E 0D 0B 1548*      ld a,(arith24ubc+1); now we pick up the middle byte of the dividend
0B1761 06 08       1549*      ld b,8      ; set up the next loop and do it all again ...
0B1763             1550*  @loop1:
0B1763 17          1551*      rla
0B1764 ED 6A       1552*      adc hl,hl
0B1766 ED 52       1553*      sbc hl,de
0B1768 30 01       1554*      jr nc,@noadd1
0B176A 19          1555*      add hl,de
0B176B             1556*  @noadd1:
0B176B 10 F6       1557*      djnz @loop1
0B176D 17          1558*      rla
0B176E 2F          1559*      cpl
0B176F 32 6E 0D 0B 1560*      ld (arith24ubc+1),a ; writing the middle byte of quotient
0B1773 3A 6D 0D 0B 1561*      ld a,(arith24ubc)
0B1777 06 08       1562*      ld b,8
0B1779             1563*  @loop2:          ; compute low byte of quotient
0B1779 17          1564*      rla
0B177A ED 6A       1565*      adc hl,hl
0B177C ED 52       1566*      sbc hl,de
0B177E 30 01       1567*      jr nc,@noadd2
0B1780 19          1568*      add hl,de
0B1781             1569*  @noadd2:
0B1781 10 F6       1570*      djnz @loop2
0B1783 17          1571*      rla
0B1784 2F          1572*      cpl
0B1785 32 6D 0D 0B 1573*      ld (arith24ubc),a  ; ... write low byte of quotient
0B1789 ED 4B 6D 0D 1574*      ld bc,(arith24ubc) ; load quotient into bc for return
       0B          
0B178E C9          1575*      ret         ; hl already contains remainder so we're done
0B178F             1576*  
0B178F             1577*  ; ---------------------------------------------------------
0B178F             1578*  ; BEGIN HELPER ROUTINES
0B178F             1579*  ; ---------------------------------------------------------
0B178F             1580*  ;
0B178F             1581*  ; absolute value of hlu
0B178F             1582*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B178F             1583*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B178F             1584*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B178F             1585*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B178F             1586*  ; destroys: a
0B178F             1587*  abs_hlu:
0B178F 19          1588*      add hl,de
0B1790 B7          1589*      or a
0B1791 ED 52       1590*      sbc hl,de
0B1793 FA 98 17 0B 1591*      jp m,@is_neg
0B1797 C9          1592*      ret         ; hlu is positive or zero so we're done
0B1798             1593*  @is_neg:
0B1798 F5          1594*      push af     ; otherwise, save current flags for return
0B1799 CD 9F 17 0B 1595*      call neg_hlu ; negate hlu
0B179D F1          1596*      pop af      ; get back flags
0B179E C9          1597*      ret
0B179F             1598*  
0B179F             1599*  ; flip the sign of hlu
0B179F             1600*  ; inputs: hlu
0B179F             1601*  ; returns: 0-hlu, flags set appropriately for the result:
0B179F             1602*  ;         s1,z0,pv0,n1,c1 if result is negative
0B179F             1603*  ;         s0,z1,pv0,n1,c0 if result is zero
0B179F             1604*  ;         s0,z0,pv0,n1,c1 if result is positive
0B179F             1605*  ; destroys a
0B179F             1606*  neg_hlu:
0B179F D5          1607*      push de     ; save de
0B17A0 EB          1608*      ex de,hl    ; put hl into de
0B17A1 21 00 00 00 1609*      ld hl,0     ; clear hl
0B17A5 AF          1610*      xor a       ; clear carry
0B17A6 ED 52       1611*      sbc hl,de   ; 0-hlu = -hlu
0B17A8 D1          1612*      pop de      ; get de back
0B17A9 C9          1613*      ret         ; easy peasy
0B17AA             1614*  
0B17AA             1615*  ;------------------------------------------------------------------------
0B17AA             1616*  ; divide hlu by 2, inspired by above
0B17AA             1617*  ;------------------------------------------------------------------------
0B17AA             1618*  hlu_div2:
0B17AA 22 64 0E 0B 1619*  	ld		(bitbuf1),hl
0B17AE 21 66 0E 0B 1620*  	ld		hl,bitbuf1+2
0B17B2 CB 1E       1621*  	rr		(hl)
0B17B4 2B          1622*  	dec		hl
0B17B5 CB 1E       1623*  	rr		(hl)
0B17B7 2B          1624*  	dec		hl
0B17B8 CB 1E       1625*  	rr		(hl)
0B17BA 23          1626*  	inc		hl
0B17BB 23          1627*  	inc		hl
0B17BC 2A 64 0E 0B 1628*      ld hl,(bitbuf1)
0B17C0 C9          1629*      ret
0B17C1             1630*  
0B17C1             1631*  ; this is my little hack to divide by 16
0B17C1             1632*  hlu_div16:
0B17C1 AF          1633*      xor a
0B17C2 29          1634*      add hl,hl
0B17C3 17          1635*      rla
0B17C4 29          1636*      add hl,hl
0B17C5 17          1637*      rla
0B17C6 29          1638*      add hl,hl
0B17C7 17          1639*      rla
0B17C8 29          1640*      add hl,hl
0B17C9 17          1641*      rla
0B17CA 22 D7 17 0B 1642*      ld (@scratch),hl
0B17CE 32 DA 17 0B 1643*      ld (@scratch+3),a
0B17D2 2A D8 17 0B 1644*      ld hl,(@scratch+1)
0B17D6 C9          1645*      ret
0B17D7             1646*  @scratch: ds 4
0B17DB             1647*  
0B17DB             1648*  ; -----------------------------------------------------------------------
0B17DB             1649*  ; EEMES TUTORIALS
0B17DB             1650*  ; -----------------------------------------------------------------------
0B17DB             1651*  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
0B17DB             1652*  ; DEHL=BC*DE
0B17DB             1653*  Mul16:
0B17DB 21 00 00 00 1654*      ld hl,0
0B17DF 3E 10       1655*      ld a,16
0B17E1             1656*  Mul16Loop:
0B17E1 29          1657*      add hl,hl
0B17E2 CB 13       1658*      rl e
0B17E4 CB 12       1659*      rl d
0B17E6 D2 F0 17 0B 1660*      jp nc,NoMul16
0B17EA 09          1661*      add hl,bc
0B17EB D2 F0 17 0B 1662*      jp nc,NoMul16
0B17EF 13          1663*      inc de
0B17F0             1664*  NoMul16:
0B17F0 3D          1665*      dec a
0B17F1 C2 E1 17 0B 1666*      jp nz,Mul16Loop
0B17F5 C9          1667*      ret
0B17F6             1668*  
0B17F6             1669*  ; DEUHLU=BCU*DEU
0B17F6             1670*  umul2448:
0B17F6 21 00 00 00 1671*      ld hl,0
0B17FA 3E 18       1672*      ld a,24
0B17FC             1673*  umul2448Loop:
0B17FC 29          1674*      add hl,hl
0B17FD EB          1675*      ex de,hl
0B17FE ED 6A       1676*      adc hl,hl
0B1800 EB          1677*      ex de,hl
0B1801 D2 0B 18 0B 1678*      jp nc,Noumul2448
0B1805 09          1679*      add hl,bc
0B1806 D2 0B 18 0B 1680*      jp nc,Noumul2448
0B180A 13          1681*      inc de
0B180B             1682*  Noumul2448:
0B180B 3D          1683*      dec a
0B180C C2 FC 17 0B 1684*      jp nz,umul2448Loop
0B1810 C9          1685*      ret
0B1811             1686*  
0B1811             1687*  umul168:
0B1811 CD F6 17 0B 1688*      call umul2448
0B1815             1689*  
0B1815             1690*      ; call dumpUDEUHLHex
0B1815             1691*  
0B1815             1692*  ; UDEU.HL is the 32.16 fixed result
0B1815             1693*  ; we want UH.L to be the 16.8 fixed result
0B1815             1694*  ; so we divide by 256 by shiftng down a byte
0B1815             1695*  ; easiest way is to write deu and hlu to scratch
0B1815 ED 53 2A 18 1696*      ld (umul168out+3),de
       0B          
0B181A 22 27 18 0B 1697*      ld (umul168out),hl
0B181E             1698*  ; then load hlu from scratch shfited forward a byte
0B181E 2A 28 18 0B 1699*      ld hl,(umul168out+1)
0B1822 3A 2C 18 0B 1700*      ld a,(umul168out+5) ; send a back with any overflow
0B1826 C9          1701*      ret
0B1827             1702*  umul168out: ds 6
0B182D             1703*  
0B182D             1704*  ; perform signed multiplication of 16.8 fixed place values
0B182D             1705*  ; with an signed 16.8 fixed place result
0B182D             1706*  ; inputs: ub.c and ud.e are the operands
0B182D             1707*  ; outputs: uh.l is the product
0B182D             1708*  ; destroys: a,bc
0B182D             1709*  ; TODO: make flags appropriate to the sign of the result
0B182D             1710*  smul168:
0B182D             1711*  ; make everything positive and save signs
0B182D C5          1712*      push bc         ; get bc to hl
0B182E E1          1713*      pop hl          ; for the next call
0B182F CD 8F 17 0B 1714*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
0B1833             1715*  
0B1833             1716*      ; call dumpFlags ; passes
0B1833             1717*  
0B1833 CA 66 18 0B 1718*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B1837 F5          1719*      push af         ; save sign of bc
0B1838 E5          1720*      push hl         ; now put abs(hl)
0B1839 C1          1721*      pop bc          ; back into bc = abs(bc)
0B183A EB          1722*      ex de,hl        ; now we do de same way
0B183B CD 8F 17 0B 1723*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
0B183F             1724*  
0B183F             1725*      ; call dumpFlags ; passes
0B183F             1726*  
0B183F CA 66 18 0B 1727*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
0B1843 EB          1728*      ex de,hl        ; hl back to de = abs(de)
0B1844             1729*  ; determine sign of result
0B1844 F2 4F 18 0B 1730*      jp p,@de_pos    ; sign positive,de is positive
0B1848             1731*  
0B1848             1732*      ; call dumpFlags ; correctly doesnt make it here
0B1848             1733*  
0B1848 F1          1734*      pop af          ; get back sign of bc
0B1849             1735*  
0B1849             1736*      ; call dumpFlags ; correctly doesn't make it here
0B1849             1737*  
0B1849 FA 58 18 0B 1738*      jp m,@result_pos  ; bc and de negative, result is positive
0B184D             1739*  
0B184D             1740*      ; call dumpFlags  ; corectly doesn't make it here
0B184D             1741*  
0B184D 18 05       1742*      jr @result_neg
0B184F             1743*  @de_pos:
0B184F F1          1744*      pop af          ; get back sign of bc
0B1850             1745*  
0B1850             1746*      ; call dumpFlags  ; passes
0B1850             1747*  
0B1850 F2 58 18 0B 1748*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B1854             1749*  
0B1854             1750*      ; call dumpFlags ; correctly makes it here
0B1854             1751*  
0B1854             1752*                      ; fall through to result_neg
0B1854             1753*  @result_neg:
0B1854 AF          1754*      xor a           ; zero a and clear carry
0B1855 3D          1755*      dec a           ; set sign flag to negative
0B1856             1756*  
0B1856             1757*      ; call dumpFlags ; passes
0B1856             1758*  
0B1856 18 02       1759*      jr @do_mul
0B1858             1760*  @result_pos:
0B1858 AF          1761*      xor a           ; zero a and clear carry
0B1859 3C          1762*      inc a           ; set sign flag to positive
0B185A             1763*                      ; fall through to do_mul
0B185A             1764*  
0B185A             1765*      ; call dumpFlags ; correctly doesn't make it here
0B185A             1766*  
0B185A             1767*  @do_mul:
0B185A F5          1768*      push af         ; save sign of result
0B185B CD 11 18 0B 1769*      call umul168
0B185F F1          1770*      pop af          ; get back sign of result
0B1860             1771*  
0B1860             1772*      ; call dumpFlags ; passes
0B1860             1773*  
0B1860 F0          1774*      ret p           ; result is positive so nothing to do
0B1861             1775*  
0B1861             1776*      ; call dumpRegistersHex ; passes
0B1861             1777*  
0B1861 CD 9F 17 0B 1778*      call neg_hlu    ; result is negative so negate it
0B1865             1779*  
0B1865             1780*      ; call dumpRegistersHex ; passes
0B1865 C9          1781*      ret
0B1866             1782*  @is_zero:           ; result is zero
0B1866 AF          1783*      xor a           ; sets zero flag, which we want,
0B1867             1784*                      ; sets pv flag which we might not (zero is parity even)
0B1867             1785*                      ; resets all others which is okay
0B1867 C9          1786*      ret
0B1868             0029   
0B1868             0030   ; APPLICATION INCLUDES
0B1868 55 73 61 67 0031   str_usage: ASCIZ "Usage: flower <args>\r\n"
       65 3A 20 66 
       6C 6F 77 65 
       72 20 3C 61 
       72 67 73 3E 
       0D 0A 00    
0B187F 45 72 72 6F 0032   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B1888 53 75 63 63 0033   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1893             0034   
0B1893             0035   ; This program draws 2D curves related to the hypotrochoid / epitrochoid family (i.e. Spirographs),
0B1893             0036   ; more generally known as roulettes. While it is possible to construct curves fitting the precise
0B1893             0037   ; definitions of such curves, the program is not limited to them as slipping of the outer circle
0B1893             0038   ; is allowable. In addition, continually plotting the curve insribed by the outer circle is not required.
0B1893             0039   ; This allows rotating polygonal shapes remniscent of string art, as well as daisy-like curves.
0B1893             0040   ; Hence the name "flower" even though the program is not limited to such shapes.
0B1893             0041   ; Another key difference is that cumulative shrinking can be applied to the radii of the rotating circles,
0B1893             0042   ; thus allowing curves which form true spirals in contrast to the Spirograph toy, which does not.
0B1893             0043   ;
0B1893             0044   ; Parameters with example values:
0B1893             0045   ; petals      = 3.03  :
0B1893             0046   ; vectors     = 1.98  :
0B1893             0047   ; depth       = 0.6   :
0B1893             0048   ; periods     = 66    :
0B1893             0049   ; shrink      = 0.8   :
0B1893             0050   ; clock_prime = 1.0   :
0B1893             0051   ; clock_petal = 1.0   :
0B1893             0052   ; theta_prime = 0.0   :
0B1893             0053   ; theta_petal = 0.0   :
0B1893             0054   ; radius_scale= 480   :
0B1893             0055   
0B1893             0056   ; ========= BOILERPLATE MAIN LOOP =========
0B1893             0057   ; The main routine
0B1893             0058   ; IXU: argv - pointer to array of parameters
0B1893             0059   ;   C: argc - number of parameters
0B1893             0060   ; Returns:
0B1893             0061   ;  HL: Error code, or 0 if OK
0B1893             0062   
0B1893             0063   min_args: equ 2
0B1893             0064   
0B1893             0065   _main:
0B1893 79          0066       ld a,c              ; how many arguments?
0B1894 FE 02       0067       cp min_args         ; not enough?
0B1896 30 54       0068       jr nc,main          ; if enough, go to main loop
0B1898 21 68 18 0B 0069       ld hl,str_usage     ; if not enough, print usage
0B189C CD 67 02 0B 0070       call printString
0B18A0             0071                           ; fall through to _main_end_error
0B18A0             0072   
0B18A0             0073   _main_end_error:
0B18A0 21 7F 18 0B 0074       ld hl,str_error     ; print error message
0B18A4 CD 67 02 0B 0075       call printString
0B18A8 21 13 00 00 0076       ld hl,19            ; return error code 19
0B18AC C9          0077       ret
0B18AD             0078   
0B18AD             0079   _main_end_ok:
0B18AD 21 88 18 0B 0080       ld hl,str_success   ; print success message
0B18B1 CD 67 02 0B 0081       call printString
0B18B5 21 00 00 00 0082       ld hl,0             ; return 0 for success
0B18B9 C9          0083       ret
0B18BA             0084   
0B18BA             0085   ; GLOBAL VARIABLES / DEFAULTS
0B18BA             0086   ; ---- input arguments (16.8 fixed) ----
0B18BA             0087   input_params_num: equ 10
0B18BA             0088   input_params:               ; label so we can traverse the table in loops
0B18BA 07 03 00    0089   petals: 	    dl 0x000307	; 3.03
0B18BD FA 01 00    0090   vectors: 	    dl 0x0001FA	; 1.98
0B18C0 99 00 00    0091   depth: 	        dl 0x000099	; 0.6
0B18C3 00 42 00    0092   periods: 	    dl 0x004200	; 66
0B18C6 CC 00 00    0093   shrink: 	    dl 0x0000CC	; 0.8
0B18C9 00 01 00    0094   clock_prime: 	dl 0x000100	; 1
0B18CC 00 01 00    0095   clock_petal: 	dl 0x000100	; 1
0B18CF 00 00 00    0096   theta_prime: 	dl 0x000000	; 0
0B18D2 00 00 00    0097   theta_petal: 	dl 0x000000	; 0
0B18D5 00 E0 01    0098   radius_scale: 	dl 0x01E000	; 480
0B18D8             0099   
0B18D8             0100   ; ---- main loop parameters (16.8 fixed) ----
0B18D8 00 00 00    0101   step_theta_prime:   dl 0x000000  ; Step increment for theta_prime in each loop iteration
0B18DB 00 00 00    0102   step_theta_petal:   dl 0x000000  ; Step increment for theta_petal in each loop iteration
0B18DE 00 00 00    0103   total_steps:        dl 0x000000  ; Total number of iterations based on periods and step_theta_prime
0B18E1 00 00 00    0104   shrink_step:        dl 0x000000  ; Step decrement applied to radius in each iteration
0B18E4             0105   
0B18E4             0106   ; ---- main loop state variables (16.8 fixed) ----
0B18E4 00 00 00    0107   prime_radius:       dl 0x000000  ; Initial radius before shrink factor is applied
0B18E7             0108   
0B18E7             0109   
0B18E7             0110   main_loop:
0B18E7             0111   ; --- convert input thetas to 8.8 fixed point degrees255
0B18E7             0112   ; --- compute the main loop parameters ---
0B18E7             0113   
0B18E7             0114   
0B18E7             0115   @loop:
0B18E7             0116   
0B18E7 C3 E7 18 0B 0117           jp @loop
0B18EB C9          0118           ret
0B18EC             0119   
0B18EC             0120   
0B18EC             0121   
0B18EC             0122   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B18EC             0123   main:
0B18EC 0D          0124       dec c               ; decrement the argument count to skip the program name
0B18ED CD F9 18 0B 0125       call load_input     ; load the input arguments
0B18F1 CD E7 18 0B 0126       call main_loop      ; run the main loop
0B18F5 C3 AD 18 0B 0127       jp _main_end_ok     ; exit with success
0B18F9             0128   
0B18F9             0129   ; --- Load arguments ---
0B18F9             0130   ; --------------------------------
0B18F9             0131   load_input:
0B18F9 79          0132       ld a,c ; put the number of entered arguments in a
0B18FA 06 0A       0133       ld b,input_params_num ; loop counter = number of arguments
0B18FC B8          0134       cp b ; compare the number of arguments to the number of arguments
0B18FD C4 13 19 0B 0135       call nz,args_count_off ; handle discrepancies
0B1901             0136       ; TODO: we may want to branch here according to the result
0B1901 FD 21 BA 18 0137       ld iy,input_params  ; point to the arguments table
       0B          
0B1906             0138   @loop:
0B1906 CD 38 19 0B 0139           call get_numeric_arg ; get the next argument
0B190A FD 1F 00    0140           ld (iy),de ; store the argument in the table
0B190D ED 33 03    0141           lea iy,iy+3  ; point to the next parameter
0B1910 10 F4       0142           djnz @loop ; loop until done
0B1912 C9          0143           ret
0B1913             0144   
0B1913             0145   
0B1913             0146   
0B1913             0147   
0B1913             0148   
0B1913             0149   ; --- Specific parameter processing functions ---
0B1913             0150   args_count_off:
0B1913 21 1C 19 0B 0151       ld hl,@str_args_count_off
0B1917 CD 67 02 0B 0152       call printString
0B191B C9          0153       ret ; TODO: implement this
0B191C 41 72 67 75 0154   @str_args_count_off: db "Argument counts mismatch!\r\n",0
       6D 65 6E 74 
       20 63 6F 75 
       6E 74 73 20 
       6D 69 73 6D 
       61 74 63 68 
       21 0D 0A 00 
0B1938             0155   
0B1938             0156   
0B1938             0157   ; ========== HELPER FUNCTIONS ==========
0B1938             0158   get_numeric_arg:
0B1938 ED 32 03    0159       lea ix,ix+3 ; point to the next argument
0B193B DD 27 00    0160       ld hl,(ix)  ; get the argument string
0B193E CD 98 01 0B 0161       call signed_asc_to_168 ; convert the string to a number
0B1942 C9          0162       ret ; return with the value in DE
0B1943             0163   
0B1943             0164   get_plot_coords:
0B1943             0165   ; get the move coordinates
0B1943 ED 32 03    0166       lea ix,ix+3 ; pointer to next argument address
0B1946 DD 27 00    0167       ld hl,(ix)  ; pointer to the x coordinate string
0B1949 CD 98 01 0B 0168       call signed_asc_to_168 ; de = x coordinate
0B194D D5          0169       push de
0B194E C1          0170       pop bc ; bc = x coordinate
0B194F ED 32 03    0171       lea ix,ix+3 ; pointer to next argument address
0B1952 DD 27 00    0172       ld hl,(ix)  ; pointer to the y coordinate string
0B1955 CD 98 01 0B 0173       call signed_asc_to_168 ; de = y coordinate
0B1959 C9          0174       ret
0B195A             0175   
0B195A             0176   ; match the next argument after ix to the dispatch table at iy
0B195A             0177   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B195A             0178   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B195A             0179   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B195A             0180   ;          ON MATCH: iy=dispatch address, a=0 and zero flag se
0B195A             0181   ; destroys: a, hl, de, ix, iy, flags
0B195A             0182   match_next:
0B195A ED 32 03    0183       lea ix,ix+3         ; point to the next argument
0B195D             0184   @loop:
0B195D FD 27 00    0185       ld hl,(iy)          ; pointer argument dispatch record
0B1960             0186       signHL              ; check for list terminator
0B1960 19          0001M          add hl,de
0B1961 B7          0002M          or a
0B1962 ED 52       0003M          sbc hl,de
0B1964 CA 7C 19 0B 0187       jp z,@no_match      ; if a=0, return error
0B1968 23          0188       inc hl              ; skip over jp instruction
0B1969 23          0189       inc hl
0B196A DD 17 00    0190       ld de,(ix)          ; pointer to the argument string
0B196D CD 82 19 0B 0191       call str_equal      ; compare the argument to the dispatch table entry
0B1971 CA 7E 19 0B 0192       jp z,@match         ; if equal, return success
0B1975 ED 33 03    0193       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1978 C3 5D 19 0B 0194       jp @loop            ; and loop
0B197C             0195   @no_match:
0B197C 3C          0196       inc a               ; no match so return a=1 and zero flag reset
0B197D C9          0197       ret
0B197E             0198   @match:
0B197E FD 37 00    0199       ld iy,(iy)          ; get the function pointer
0B1981 C9          0200       ret                 ; return a=0 and zero flag set
0B1982             0201   
0B1982             0202   ; compare two zero-terminated strings for equality, case-sensitive
0B1982             0203   ; hl: pointer to first string, de: pointer to second string
0B1982             0204   ; returns: z if equal, nz if not equal
0B1982             0205   ; destroys: a, hl, de
0B1982             0206   str_equal:
0B1982 1A          0207       ld a,(de)           ; get the first character
0B1983 BE          0208       cp (hl)             ; compare to the second character
0B1984 C0          0209       ret nz              ; if not equal, return
0B1985 B7          0210       or a
0B1986 C8          0211       ret z               ; if equal and zero, return
0B1987 23          0212       inc hl              ; next character
0B1988 13          0213       inc de
0B1989 C3 82 19 0B 0214       jp str_equal        ; loop until end of string
0B198D             0215   
0B198D             0216   ; print the parameter string pointed to by ix
0B198D             0217   ; destroys: a, hl
0B198D             0218   print_param:
0B198D DD 27 00    0219       ld hl,(ix)          ; get the parameter pointer
0B1990 CD 67 02 0B 0220       call printString    ; print the parameter string
0B1994 3E 20       0221       ld a,' '            ; print a space separator
0B1996 5B D7       0222       rst.lil $10
0B1998 C9          0223       ret
0B1999             0224   
0B1999             0225   ; print the parameters
0B1999             0226   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1999             0227   ; destroys: a, hl, bc
0B1999             0228   print_params:
0B1999 41          0229       ld b,c              ; loop counter = number of parameters
0B199A DD E5       0230       push ix             ; save the pointer to the parameters
0B199C             0231   @loop:
0B199C C5          0232       push bc             ; save the loop counter
0B199D CD 8D 19 0B 0233       call print_param    ; print the parameter
0B19A1 ED 32 03    0234       lea ix,ix+3         ; next parameter pointer
0B19A4 C1          0235       pop bc              ; get back the loop counter
0B19A5 10 F5       0236       djnz @loop          ; loop until done
0B19A7 DD E1       0237       pop ix              ; restore the pointer to the parameters
0B19A9 C9          0238       ret
0B19AA             0239   
0B19AA             0240   debug_print:
0B19AA CD 7C 02 0B 0241       call printNewLine   ; DEBUG
0B19AE CD 7A 05 0B 0242       call dumpFlags      ; DEBUG
0B19B2 CD 8D 19 0B 0243       call print_param    ; DEBUG
0B19B6 CD 7C 02 0B 0244       call printNewLine   ; DEBUG
0B19BA CD 7C 02 0B 0245       call printNewLine   ; DEBUG
0B19BE C9          0246       ret
