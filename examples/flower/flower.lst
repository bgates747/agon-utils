PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "flower.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 66 6C 6F 77 0001*M     ASCIZ "flower.bin"
       65 72 2E 62 
       69 6E 00    
0B000F             0025*  
0B000F FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD C0 1A 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 93 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F             0108*      ; call _skip_spaces ; skip whitespace
0B014F             0109*  
0B014F 7E          0110*      ld a, (hl) ; read first character
0B0150 B7          0111*      or a ; check for end of string
0B0151 C8          0112*      ret z ; return with no carry if not
0B0152             0113*  
0B0152 C5          0114*      push bc ; preserve bc
0B0153             0115*  
0B0153 FE 2D       0116*      cp '-' ; check for negative number
0B0155 C2 5F 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B0159 AF          0118*      xor a ; sign flag to zero
0B015A 32 93 01 0B 0119*      ld (@sign),a ; store sign flag
0B015E 23          0120*      inc hl ; skip '-'
0B015F             0121*  
0B015F             0122*  @loop:
0B015F 7E          0123*      ld a, (hl)
0B0160 D6 30       0124*      sub '0' ; normalise to 0
0B0162 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0164 FE 0A       0126*      cp 10 ; check if >= 10
0B0166 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B0168 E5          0128*      push hl ; stack hl
0B0169 D5          0129*      push de ; ld hl, de
0B016A E1          0130*      pop hl
0B016B E5          0131*      push hl ; ld bc, hl
0B016C C1          0132*      pop bc
0B016D 29          0133*      add hl, hl ; x 2
0B016E 29          0134*      add hl, hl ; x 4
0B016F 09          0135*      add hl, bc ; x 5
0B0170 29          0136*      add hl, hl ; x 10
0B0171 01 00 00 00 0137*      ld bc, 0
0B0175 4F          0138*      ld c, a ; ld bcu, a
0B0176 09          0139*      add hl, bc ; add bcu to hl
0B0177 E5          0140*      push hl ; ld de, hl
0B0178 D1          0141*      pop de
0B0179 E1          0142*      pop hl ; restore hl
0B017A 23          0143*      inc hl
0B017B 18 E2       0144*      jr @loop
0B017D             0145*  
0B017D             0146*  @integer_end:
0B017D C1          0147*      pop bc ; send bc back how she came in
0B017E 3A 93 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0182 3D          0149*      dec a ; check if negative
0B0183 F2 91 01 0B 0150*      jp p,@pos ; positive number
0B0187             0151*  
0B0187             0152*  ; Negate de
0B0187 E5          0153*      push hl ; save text pointer
0B0188 21 00 00 00 0154*      ld hl, 0
0B018C AF          0155*      xor a ; clear carry
0B018D ED 52       0156*      sbc hl, de ; subtract DE from HL
0B018F EB          0157*      ex de, hl ; DE = 0-HL
0B0190 E1          0158*      pop hl ; restore text pointer
0B0191             0159*  
0B0191             0160*  @pos:
0B0191 37          0161*      scf ; we have a valid number so set carry
0B0192 C9          0162*      ret
0B0193             0163*  
0B0193 00          0164*  @sign: db 0 ; sign flag buffer
0B0194             0165*  
0B0194             0166*  
0B0194             0167*  ;------------------------------------------------------------------------
0B0194             0168*  ; Read a number and convert to binary (decimal only)
0B0194             0169*  ; Inputs: hl: Pointer in string buffer
0B0194             0170*  ; Outputs: hl: Updated text pointer
0B0194             0171*  ;         de: Value
0B0194             0172*  ;         a: Terminator (spaces skipped)
0B0194             0173*  ;         f: Carry set if valid number, otherwise reset
0B0194             0174*  ; Destroys: a, d, e, h, l, f
0B0194             0175*  ;------------------------------------------------------------------------
0B0194             0176*  asc_to_s168:
0B0194 3E 01       0177*      ld a,1 ; set sign flag
0B0196 32 53 02 0B 0178*      ld (@sign),a ; store sign flag
0B019A             0179*  
0B019A 11 00 00 00 0180*      ld de, 0 ; initialise de
0B019E ED 53 4B 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A3 ED 53 4F 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01A8             0183*  
0B01A8             0184*      ; call _skip_spaces ; skip whitespace
0B01A8             0185*  
0B01A8 7E          0186*      ld a, (hl) ; read first character
0B01A9 B7          0187*      or a ; check for end of string
0B01AA C8          0188*      ret z ; return with no carry if not
0B01AB             0189*  
0B01AB C5          0190*      push bc ; preserve bc
0B01AC             0191*  
0B01AC FE 2D       0192*      cp '-' ; check for negative number
0B01AE C2 B8 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01B2 AF          0194*      xor a ; sign flag to zero
0B01B3 32 53 02 0B 0195*      ld (@sign),a ; store sign flag
0B01B7 23          0196*      inc hl ; skip '-'
0B01B8             0197*  
0B01B8             0198*  @loop:
0B01B8 7E          0199*      ld a, (hl)
0B01B9             0200*  
0B01B9             0201*  ; chcek for decimal point
0B01B9 FE 2E       0202*      cp '.' ; check for decimal point
0B01BB CA FC 01 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01BF             0204*  
0B01BF             0205*  ; process integer part
0B01BF D6 30       0206*      sub '0' ; normalise to 0
0B01C1 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01C3 FE 0A       0208*      cp 10 ; check if >= 10
0B01C5 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01C7 E5          0210*      push hl ; stack hl
0B01C8 D5          0211*      push de ; ld hl, de
0B01C9 E1          0212*      pop hl
0B01CA E5          0213*      push hl ; ld bc, hl
0B01CB C1          0214*      pop bc
0B01CC 29          0215*      add hl, hl ; x 2
0B01CD 29          0216*      add hl, hl ; x 4
0B01CE 09          0217*      add hl, bc ; x 5
0B01CF 29          0218*      add hl, hl ; x 10
0B01D0 01 00 00 00 0219*      ld bc, 0
0B01D4 4F          0220*      ld c, a ; ld bcu, a
0B01D5 09          0221*      add hl, bc ; add bcu to hl
0B01D6 E5          0222*      push hl ; ld de, hl
0B01D7 D1          0223*      pop de
0B01D8 E1          0224*      pop hl ; restore hl
0B01D9 23          0225*      inc hl
0B01DA 18 DC       0226*      jr @loop
0B01DC             0227*  
0B01DC             0228*  @integer_end:
0B01DC ED 53 4C 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E1             0230*  
0B01E1             0231*  @end:
0B01E1 C1          0232*      pop bc ; send bc back how she came in
0B01E2 ED 5B 4B 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01E7 3A 53 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01EB 3D          0235*      dec a ; check if negative
0B01EC F2 FA 01 0B 0236*      jp p,@pos ; positive number
0B01F0             0237*  
0B01F0             0238*  ; Negate de
0B01F0 E5          0239*      push hl ; save text pointer
0B01F1 21 00 00 00 0240*      ld hl, 0
0B01F5 AF          0241*      xor a ; clear carry
0B01F6 ED 52       0242*      sbc hl, de ; subtract DE from HL
0B01F8 EB          0243*      ex de, hl ; DE = 0-HL
0B01F9 E1          0244*      pop hl ; restore text pointer
0B01FA             0245*  
0B01FA             0246*  @pos:
0B01FA 37          0247*      scf ; we have a valid number so set carry
0B01FB C9          0248*      ret
0B01FC             0249*  
0B01FC             0250*  @fractional_start:
0B01FC DD E5       0251*      push ix                    ; preserve ix
0B01FE ED 53 4C 02 0252*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0203 06 03       0253*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0205 11 00 00 00 0254*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0209 DD 21 54 02 0255*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B020E 23          0256*      inc hl                     ; Skip decimal point
0B020F             0257*  
0B020F             0258*  @fractional_loop:
0B020F 7E          0259*      ld a, (hl)                 ; Load next character
0B0210 D6 30       0260*      sub '0'                    ; Normalize ASCII to decimal
0B0212 38 1C       0261*      jr c, @end_fraction        ; Exit if < '0'
0B0214 FE 0A       0262*      cp 10
0B0216 30 18       0263*      jr nc, @end_fraction       ; Exit if >= 10
0B0218             0264*  
0B0218             0265*      ; Multiply the current fractional accumulator by 10
0B0218 E5          0266*      push hl                    ; Save char pointer
0B0219 F5          0267*      push af                    ; Save the digit
0B021A EB          0268*      ex de, hl
0B021B E5          0269*      push hl
0B021C 29          0270*      add hl,hl ; * 2
0B021D 29          0271*      add hl,hl ; * 4
0B021E D1          0272*      pop de
0B021F 19          0273*      add hl,de ; * 5
0B0220 29          0274*      add hl,hl ; * 10
0B0221 11 00 00 00 0275*      ld de, 0                   ; Clear DEU
0B0225 F1          0276*      pop af                     ; Restore the current digit
0B0226 5F          0277*      ld e, a                    ; Load the digit into E
0B0227 19          0278*      add hl, de                 ; Add the digit to the accumulator
0B0228 EB          0279*      ex de, hl                  ; Result back to DE
0B0229 ED 32 03    0280*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B022C E1          0281*      pop hl                     ; Restore char pointer
0B022D 23          0282*      inc hl                     ; Move to the next character
0B022E 10 DF       0283*      djnz @fractional_loop      ; Loop if more digits to process
0B0230             0284*  
0B0230             0285*  @end_fraction:
0B0230             0286*  ; Final scaling based on number of fractional digits processed
0B0230 ED 53 50 02 0287*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0235 2A 4F 02 0B 0288*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0239             0289*  
0B0239 DD 17 00    0290*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B023C CD B4 09 0B 0291*      call udiv24                ; Perform 24-bit division to scale down
0B0240 7B          0292*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0241 32 4B 02 0B 0293*      ld (@result), a            ; Store fractional part in result buffer
0B0245 DD E1       0294*      pop ix                     ; Restore ix
0B0247 C3 E1 01 0B 0295*      jp @end                    ; Final sign check and flag setup
0B024B             0296*  
0B024B             0297*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B024F             0298*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0253 00          0299*  @sign: db 0                    ; Sign flag buffer
0B0254             0300*  
0B0254             0301*  powers_of_10:
0B0254 01 00 00    0302*      dl 1                       ; 10^0
0B0257 0A 00 00    0303*      dl 10                      ; 10^1
0B025A 64 00 00    0304*      dl 100                     ; 10^2
0B025D E8 03 00    0305*      dl 1000                    ; 10^3
0B0260 10 27 00    0306*      dl 10000                   ; 10^4
0B0263             0017   
0B0263             0018   ; API INCLUDES
0B0263             0019       include "functions.inc"
0B0263             0001*      MACRO printChar char
0B0263             0002*          LD A, char
0B0263             0003*          RST.LIL 10h
0B0263             0004*      ENDMACRO
0B0263             0005*  
0B0263             0006*  ; test the sign of HL
0B0263             0007*  ; inputs: HL obviously
0B0263             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0263             0009*  ; destroys: flags
0B0263             0010*      MACRO sign_hlu
0B0263             0011*          add hl,de
0B0263             0012*          or a
0B0263             0013*          sbc hl,de
0B0263             0014*      ENDMACRO
0B0263             0015*  
0B0263             0016*  ; Simulated call to subroutine at HL
0B0263             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0263             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0263             0019*  ; destroys: only what the subroutine does, but always BC
0B0263             0020*      MACRO callHL
0B0263             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0022*          push bc       ; which constitutes the return address
0B0263             0023*          jp   (hl)     ; Jump to the address in HL
0B0263             0024*      ENDMACRO
0B0263             0025*  
0B0263             0026*  ; Simulated call to subroutine at IX
0B0263             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0263             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0263             0029*  ; destroys: only what the subroutine does, but always BC
0B0263             0030*      MACRO callIX
0B0263             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0032*          push bc       ; which constitutes the return address
0B0263             0033*          jp   (ix)     ; Jump to the address in IX
0B0263             0034*      ENDMACRO
0B0263             0035*  
0B0263             0036*  ; Simulated call to soubroutinte at IY
0B0263             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0263             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0263             0039*  ; destroys: only what the subroutine does, but always BC
0B0263             0040*      MACRO callIY
0B0263             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0042*          push bc       ; which constitutes the return address
0B0263             0043*          jp   (iy)     ; Jump to the address in IY
0B0263             0044*      ENDMACRO
0B0263             0045*  
0B0263             0046*  ; put the value in HLU into the accumulator
0B0263             0047*  ; destroys: af
0B0263             0048*      MACRO HLU_TO_A
0B0263             0049*          push hl ; 4 cycles
0B0263             0050*          inc sp ; 1 cycle
0B0263             0051*          pop af  ; 4 cycles
0B0263             0052*          dec sp ; 1 cycle
0B0263             0053*                 ; 10 cycles total
0B0263             0054*      ENDMACRO
0B0263             0055*  
0B0263             0056*  A_TO_HLU:
0B0263             0057*      ; call is 7 cycles
0B0263 22 70 02 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0267 32 72 02 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B026B 2A 70 02 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B026F C9          0061*      ret ; 6 cycles
0B0270             0062*          ; 25 cycles total
0B0270 00 00 00    0063*  @scratch: dl 0
0B0273             0064*  
0B0273             0065*      ; TODO: implement this
0B0273             0066*      ; MACRO A_TO_HLU
0B0273             0067*      ;     push.s af
0B0273             0068*      ;     inc sp
0B0273             0069*      ;     push.s hl
0B0273             0070*      ;     pop hl
0B0273             0071*      ;     inc sp
0B0273             0072*      ;     inc sp
0B0273             0073*      ; ENDMACRO
0B0273             0074*  
0B0273             0075*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0273             0076*  ; Print a zero-terminated string
0B0273             0077*  ; HL: Pointer to string
0B0273             0078*  printString:
0B0273 C5          0079*  	PUSH	BC
0B0274 01 00 00 00 0080*  	LD		BC,0
0B0278 3E 00       0081*  	LD 	 	A,0
0B027A 5B DF       0082*  	RST.LIL 18h
0B027C C1          0083*  	POP		BC
0B027D C9          0084*  	RET
0B027E             0085*  ; print a VDU sequence
0B027E             0086*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B027E             0087*  sendVDUsequence:
0B027E C5          0088*  	PUSH	BC
0B027F 01 00 00 00 0089*  	LD		BC, 0
0B0283 4E          0090*  	LD		C, (HL)
0B0284 5B DF       0091*  	RST.LIL	18h
0B0286 C1          0092*  	POP		BC
0B0287 C9          0093*  	RET
0B0288             0094*  ; Print Newline sequence to VDP
0B0288             0095*  printNewLine:
0B0288 F5          0096*      push af ; for some reason rst.lil 10h sets carry flag
0B0289 3E 0D       0097*  	LD	A, '\r'
0B028B 5B D7       0098*  	RST.LIL 10h
0B028D 3E 0A       0099*  	LD	A, '\n'
0B028F 5B D7       0100*  	RST.LIL 10h
0B0291 F1          0101*      pop af
0B0292 C9          0102*  	RET
0B0293             0103*  
0B0293             0104*  ; Print a 24-bit HEX number
0B0293             0105*  ; HLU: Number to print
0B0293             0106*  printHex24:
0B0293             0107*  	; PUSH	HL      ; 4 cycles
0B0293             0108*  	; LD		HL, 2   ; 4 cycles
0B0293             0109*  	; ADD		HL, SP  ; 1 cycle
0B0293             0110*  	; LD		A, (HL) ; 2 cycles
0B0293             0111*  	; POP		HL      ; 4 cycles
0B0293             0112*      ;                 ; 15 cycles total
0B0293 E5          0113*      push hl ; 4 cycles
0B0294 33          0114*      inc sp ; 1 cycle
0B0295 F1          0115*      pop af  ; 4 cycles
0B0296 3B          0116*      dec sp ; 1 cycle
0B0297             0117*              ; 10 cycles total
0B0297 CD A1 02 0B 0118*  	CALL	printHex8
0B029B             0119*  ; Print a 16-bit HEX number
0B029B             0120*  ; HL: Number to print
0B029B             0121*  printHex16:
0B029B 7C          0122*  	LD		A,H
0B029C CD A1 02 0B 0123*  	CALL	printHex8
0B02A0 7D          0124*  	LD		A,L
0B02A1             0125*  ; Print an 8-bit HEX number
0B02A1             0126*  ; A: Number to print
0B02A1             0127*  printHex8:
0B02A1 4F          0128*  	LD		C,A
0B02A2 1F          0129*  	RRA
0B02A3 1F          0130*  	RRA
0B02A4 1F          0131*  	RRA
0B02A5 1F          0132*  	RRA
0B02A6 CD AB 02 0B 0133*  	CALL	@F
0B02AA 79          0134*  	LD		A,C
0B02AB             0135*  @@:
0B02AB E6 0F       0136*  	AND		0Fh
0B02AD C6 90       0137*  	ADD		A,90h
0B02AF 27          0138*  	DAA
0B02B0 CE 40       0139*  	ADC		A,40h
0B02B2 27          0140*  	DAA
0B02B3 5B D7       0141*  	RST.LIL	10h
0B02B5 C9          0142*  	RET
0B02B6             0143*  
0B02B6             0144*  printHexA:
0B02B6 F5          0145*      push af
0B02B7 C5          0146*      push bc
0B02B8 CD A1 02 0B 0147*      call printHex8
0B02BC 3E 20       0148*      ld a,' '
0B02BE 5B D7       0149*      rst.lil 10h
0B02C0 C1          0150*      pop bc
0B02C1 F1          0151*      pop af
0B02C2 C9          0152*      ret
0B02C3             0153*  
0B02C3             0154*  printHexHL:
0B02C3 F5          0155*      push af
0B02C4 C5          0156*      push bc
0B02C5 CD 9B 02 0B 0157*      call printHex16
0B02C9 3E 20       0158*      ld a,' '
0B02CB 5B D7       0159*      rst.lil 10h
0B02CD C1          0160*      pop bc
0B02CE F1          0161*      pop af
0B02CF C9          0162*      ret
0B02D0             0163*  
0B02D0             0164*  printHexUHL:
0B02D0 F5          0165*      push af
0B02D1 C5          0166*      push bc
0B02D2 CD 93 02 0B 0167*      call printHex24
0B02D6 3E 20       0168*      ld a,' '
0B02D8 5B D7       0169*      rst.lil 10h
0B02DA C1          0170*      pop bc
0B02DB F1          0171*      pop af
0B02DC C9          0172*      ret
0B02DD             0173*  
0B02DD             0174*  printHexAUHL:
0B02DD F5          0175*      push af
0B02DE C5          0176*      push bc
0B02DF CD A1 02 0B 0177*      call printHex8
0B02E3 3E 2E       0178*      ld a,'.'
0B02E5 5B D7       0179*      rst.lil 10h
0B02E7 CD 93 02 0B 0180*      call printHex24
0B02EB 3E 20       0181*      ld a,' '
0B02ED 5B D7       0182*      rst.lil 10h
0B02EF C1          0183*      pop bc
0B02F0 F1          0184*      pop af
0B02F1 C9          0185*      ret
0B02F2             0186*  
0B02F2             0187*  printHexABHL:
0B02F2             0188*  ; preserve registers
0B02F2 C5          0189*      push bc ; b will be ok c will not
0B02F3 F5          0190*      push af ; will get totally destroyed
0B02F4             0191*  ; print a
0B02F4 CD A1 02 0B 0192*      call printHex8
0B02F8             0193*  ; print b
0B02F8 78          0194*      ld a,b
0B02F9 CD A1 02 0B 0195*      call printHex8
0B02FD             0196*  ; print hl
0B02FD CD 9B 02 0B 0197*      call printHex16
0B0301             0198*  ; restore registers
0B0301 F1          0199*      pop af
0B0302 C1          0200*      pop bc
0B0303 C9          0201*      ret
0B0304             0202*  
0B0304             0203*  printHexBHL:
0B0304             0204*  ; preserve registers
0B0304 C5          0205*      push bc ; b will be ok c will not
0B0305 F5          0206*      push af ; will get totally destroyed
0B0306             0207*  ; print b
0B0306 78          0208*      ld a,b
0B0307 CD A1 02 0B 0209*      call printHex8
0B030B             0210*  ; print hl
0B030B CD 9B 02 0B 0211*      call printHex16
0B030F             0212*  ; restore registers
0B030F F1          0213*      pop af
0B0310 C1          0214*      pop bc
0B0311 C9          0215*      ret
0B0312             0216*  
0B0312             0217*  printHexCDE:
0B0312             0218*  ; preserve registers
0B0312 C5          0219*      push bc ; b will be ok c will not
0B0313 F5          0220*      push af ; will get totally destroyed
0B0314             0221*  ; print c
0B0314 79          0222*      ld a,c
0B0315 CD A1 02 0B 0223*      call printHex8
0B0319             0224*  ; print de
0B0319 EB          0225*      ex de,hl
0B031A CD 9B 02 0B 0226*      call printHex16
0B031E EB          0227*      ex de,hl
0B031F             0228*  ; restore registers
0B031F F1          0229*      pop af
0B0320 C1          0230*      pop bc
0B0321 C9          0231*      ret
0B0322             0232*  
0B0322             0233*  ; Print a 0x HEX prefix
0B0322             0234*  DisplayHexPrefix:
0B0322 3E 30       0235*  	LD	A, '0'
0B0324 5B D7       0236*  	RST.LIL 10h
0B0326 3E 78       0237*  	LD	A, 'x'
0B0328 5B D7       0238*  	RST.LIL 10h
0B032A C9          0239*  	RET
0B032B             0240*  
0B032B             0241*      MACRO printDecBC
0B032B             0242*          push hl
0B032B             0243*          push bc
0B032B             0244*          pop hl
0B032B             0245*          call printDec
0B032B             0246*          pop hl
0B032B             0247*      ENDMACRO
0B032B             0248*  
0B032B             0249*      MACRO printDecDE
0B032B             0250*          push hl
0B032B             0251*          push de
0B032B             0252*          pop hl
0B032B             0253*          call printDec
0B032B             0254*          pop hl
0B032B             0255*      ENDMACRO
0B032B             0256*  
0B032B             0257*      MACRO printDecHL
0B032B             0258*          call printDec
0B032B             0259*      ENDMACRO
0B032B             0260*  
0B032B             0261*      MACRO printDecIX
0B032B             0262*          push hl
0B032B             0263*          push ix
0B032B             0264*          pop hl
0B032B             0265*          call printDec
0B032B             0266*          pop hl
0B032B             0267*      ENDMACRO
0B032B             0268*  
0B032B             0269*      MACRO printDecIY
0B032B             0270*          push hl
0B032B             0271*          push iy
0B032B             0272*          pop hl
0B032B             0273*          call printDec
0B032B             0274*          pop hl
0B032B             0275*      ENDMACRO
0B032B             0276*  
0B032B             0277*  
0B032B             0278*  ; Prints the right justified decimal value in HL without leading zeroes
0B032B             0279*  ; HL : Value to print
0B032B             0280*  ; preserves all registers and flags
0B032B             0281*  printDec:
0B032B             0282*  ; BEGIN MY CODE
0B032B             0283*  ; back up all the things
0B032B F5          0284*      push af
0B032C C5          0285*      push bc
0B032D D5          0286*      push de
0B032E E5          0287*      push hl
0B032F             0288*  ; END MY CODE
0B032F 11 53 03 0B 0289*  	LD	 DE, _printDecBuffer
0B0333 CD 63 03 0B 0290*  	CALL u24_to_ascii
0B0337             0291*  ; BEGIN MY CODE
0B0337             0292*  ; replace leading zeroes with spaces
0B0337 21 53 03 0B 0293*      LD	 HL, _printDecBuffer
0B033B 06 07       0294*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B033D             0295*  @loop:
0B033D 7E          0296*      LD	 A, (HL)
0B033E FE 30       0297*      CP	 '0'
0B0340 C2 4A 03 0B 0298*      JP	 NZ, @done
0B0344 3E 20       0299*      LD   A, ' '
0B0346 77          0300*      LD	 (HL), A
0B0347 23          0301*      INC	 HL
0B0348             0302*      ; CALL vdu_cursor_forward
0B0348 10 F3       0303*      DJNZ @loop
0B034A             0304*  @done:
0B034A             0305*  ; END MY CODE
0B034A             0306*  	; LD	 HL, _printDecBuffer
0B034A CD 73 02 0B 0307*  	CALL printString
0B034E             0308*  ; BEGIN MY CODE
0B034E             0309*  ; restore all the things
0B034E E1          0310*      pop hl
0B034F D1          0311*      pop de
0B0350 C1          0312*      pop bc
0B0351 F1          0313*      pop af
0B0352             0314*  ; END MY CODE
0B0352 C9          0315*  	RET
0B0353 00 00 00 00 0316*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0363             0317*  
0B0363             0318*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0363             0319*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0363             0320*  ; so it will allways be 8 characters length
0B0363             0321*  ; HL : Value to convert to string
0B0363             0322*  ; DE : pointer to buffer, at least 8 byte + 0
0B0363             0323*  u24_to_ascii:
0B0363 01 80 69 67 0324*  	LD	 BC,-10000000
0B0367 CD 9A 03 0B 0325*  	CALL @one_digit
0B036B 01 C0 BD F0 0326*  	LD	 BC,-1000000
0B036F CD 9A 03 0B 0327*  	CALL @one_digit
0B0373 01 60 79 FE 0328*  	LD	 BC,-100000
0B0377 CD 9A 03 0B 0329*  	CALL @one_digit
0B037B 01 F0 D8 FF 0330*  	LD   BC,-10000
0B037F CD 9A 03 0B 0331*  	CALL @one_digit
0B0383 01 18 FC FF 0332*  	LD   BC,-1000
0B0387 CD 9A 03 0B 0333*  	CALL @one_digit
0B038B 01 9C FF FF 0334*  	LD   BC,-100
0B038F CD 9A 03 0B 0335*  	CALL @one_digit
0B0393 0E F6       0336*  	LD   C,-10
0B0395 CD 9A 03 0B 0337*  	CALL @one_digit
0B0399 48          0338*  	LD   C,B
0B039A             0339*  @one_digit:
0B039A 3E 2F       0340*  	LD   A,'0'-1
0B039C             0341*  @divide_me:
0B039C 3C          0342*  	INC  A
0B039D 09          0343*  	ADD  HL,BC
0B039E 38 FC       0344*  	JR   C,@divide_me
0B03A0 ED 42       0345*  	SBC  HL,BC
0B03A2 12          0346*  	LD   (DE),A
0B03A3 13          0347*  	INC  DE
0B03A4 C9          0348*  	RET
0B03A5             0349*  
0B03A5             0350*  print_u24:
0B03A5 D5          0351*      push de
0B03A6 E5          0352*      push hl
0B03A7 11 53 03 0B 0353*      ld de,_printDecBuffer
0B03AB CD 63 03 0B 0354*      call u24_to_ascii
0B03AF 21 53 03 0B 0355*      ld hl,_printDecBuffer
0B03B3 CD 73 02 0B 0356*      call printString
0B03B7 3E 20       0357*      ld a,' '
0B03B9 5B D7       0358*      rst.lil 10h
0B03BB E1          0359*      pop hl
0B03BC D1          0360*      pop de
0B03BD C9          0361*      ret
0B03BE             0362*  
0B03BE             0363*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03BE             0364*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03BE             0365*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03BE             0366*  u168_to_ascii:
0B03BE             0367*  ; add a leading space to make room for sign flag if needed
0B03BE 3E 20       0368*      ld a,' '
0B03C0 12          0369*      ld (de),a
0B03C1 13          0370*      inc de
0B03C2             0371*  ; Convert integer part
0B03C2 E5          0372*      push hl               ; Save HL (we’ll need the fractional part later)
0B03C3 CD 41 08 0B 0373*      call hlu_udiv256    ; Shift to get integer portion in HL
0B03C7 01 F0 D8 FF 0374*      ld   bc, -10000
0B03CB CD EE 03 0B 0375*      call @one_int
0B03CF 01 18 FC FF 0376*      ld   bc, -1000
0B03D3 CD EE 03 0B 0377*      call @one_int
0B03D7 01 9C FF FF 0378*      ld   bc, -100
0B03DB CD EE 03 0B 0379*      call @one_int
0B03DF 0E F6       0380*      ld   c, -10
0B03E1 CD EE 03 0B 0381*      call @one_int
0B03E5 48          0382*      ld   c, b
0B03E6 CD EE 03 0B 0383*      call @one_int
0B03EA C3 F9 03 0B 0384*      jp   @frac            ; Jump to fractional part conversion
0B03EE             0385*  @one_int:
0B03EE 3E 2F       0386*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F0             0387*  @divide_me:
0B03F0 3C          0388*      inc  a
0B03F1 09          0389*      add  hl, bc           ; Accumulate until overflow
0B03F2 38 FC       0390*      jr   c, @divide_me
0B03F4 ED 42       0391*      sbc  hl, bc           ; Remove excess after overflow
0B03F6 12          0392*      ld   (de), a          ; Store ASCII digit
0B03F7 13          0393*      inc  de
0B03F8 C9          0394*      ret
0B03F9             0395*  ; Convert fractional part
0B03F9             0396*  @frac:
0B03F9 3E 2E       0397*      ld   a, '.'           ; Decimal point
0B03FB 12          0398*      ld   (de), a
0B03FC 13          0399*      inc  de
0B03FD E1          0400*      pop  hl               ; Restore HL with original fraction
0B03FE 06 03       0401*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0400             0402*  @frac_loop:
0B0400 26 0A       0403*      ld   h, 10            ; Load multiplier for fractional part
0B0402 ED 6C       0404*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0404 3E 30       0405*      ld   a, '0'
0B0406 84          0406*      add  a, h             ; Convert integer part to ASCII
0B0407 12          0407*      ld   (de), a
0B0408 13          0408*      inc  de
0B0409 10 F5       0409*      djnz @frac_loop       ; Repeat for each fractional digit
0B040B             0410*  ; Add null terminator
0B040B AF          0411*      xor  a                ; Null terminator
0B040C 12          0412*      ld   (de), a
0B040D C9          0413*      ret
0B040E             0414*  
0B040E             0415*  print_u168:
0B040E D5          0416*      push de
0B040F E5          0417*      push hl
0B0410 11 53 03 0B 0418*      ld de,_printDecBuffer
0B0414 CD BE 03 0B 0419*      call u168_to_ascii
0B0418 21 53 03 0B 0420*      ld hl,_printDecBuffer
0B041C CD 73 02 0B 0421*      call printString
0B0420 E1          0422*      pop hl
0B0421 D1          0423*      pop de
0B0422 C9          0424*      ret
0B0423             0425*  
0B0423             0426*  ; signed version of u168_to_ascii
0B0423             0427*  s168_to_ascii:
0B0423 D5          0428*      push de ; save starting address of buffer
0B0424 CD DA 07 0B 0429*      call abs_hlu
0B0428 F5          0430*      push af ; save sign flag
0B0429 CD BE 03 0B 0431*      call u168_to_ascii
0B042D F1          0432*      pop af ; restore sign flag
0B042E D1          0433*      pop de ; restore starting address of buffer
0B042F F0          0434*      ret p ; hlu was positive so nothing to do
0B0430 3E 2D       0435*      ld a,'-'
0B0432 12          0436*      ld (de),a
0B0433 C9          0437*      ret
0B0434             0438*  
0B0434             0439*  print_s168:
0B0434 D5          0440*      push de
0B0435 E5          0441*      push hl
0B0436 11 53 03 0B 0442*      ld de,_printDecBuffer
0B043A CD 23 04 0B 0443*      call s168_to_ascii
0B043E 21 53 03 0B 0444*      ld hl,_printDecBuffer
0B0442 CD 73 02 0B 0445*      call printString
0B0446 E1          0446*      pop hl
0B0447 D1          0447*      pop de
0B0448 C9          0448*      ret
0B0449             0449*  
0B0449             0450*  print_s168_hl:
0B0449 F5          0451*      push af
0B044A E5          0452*      push hl
0B044B CD 34 04 0B 0453*      call print_s168
0B044F 3E 20       0454*      ld a,' '
0B0451 5B D7       0455*      rst.lil 10h
0B0453 E1          0456*      pop hl
0B0454 F1          0457*      pop af
0B0455 C9          0458*      ret
0B0456             0459*  
0B0456             0460*  print_s168_bc:
0B0456 F5          0461*      push af
0B0457 C5          0462*      push bc
0B0458 E5          0463*      push hl
0B0459 C5          0464*      push bc
0B045A E1          0465*      pop hl
0B045B CD 34 04 0B 0466*      call print_s168
0B045F 3E 20       0467*      ld a,' '
0B0461 5B D7       0468*      rst.lil 10h
0B0463 E1          0469*      pop hl
0B0464 C1          0470*      pop bc
0B0465 F1          0471*      pop af
0B0466 C9          0472*      ret
0B0467             0473*  
0B0467             0474*  print_s168_de:
0B0467 F5          0475*      push af
0B0468 D5          0476*      push de
0B0469 E5          0477*      push hl
0B046A EB          0478*      ex de,hl
0B046B CD 34 04 0B 0479*      call print_s168
0B046F 3E 20       0480*      ld a,' '
0B0471 5B D7       0481*      rst.lil 10h
0B0473 E1          0482*      pop hl
0B0474 D1          0483*      pop de
0B0475 F1          0484*      pop af
0B0476 C9          0485*      ret
0B0477             0486*  
0B0477             0487*  print_s168_hl_bc_de:
0B0477 F5          0488*      push af
0B0478 C5          0489*      push bc
0B0479 D5          0490*      push de
0B047A E5          0491*      push hl
0B047B CD 34 04 0B 0492*      call print_s168
0B047F 3E 20       0493*      ld a,' '
0B0481 5B D7       0494*      rst.lil 10h
0B0483 C5          0495*      push bc
0B0484 E1          0496*      pop hl
0B0485 CD 34 04 0B 0497*      call print_s168
0B0489 3E 20       0498*      ld a,' '
0B048B 5B D7       0499*      rst.lil 10h
0B048D EB          0500*      ex de,hl
0B048E CD 34 04 0B 0501*      call print_s168
0B0492 3E 20       0502*      ld a,' '
0B0494 5B D7       0503*      rst.lil 10h
0B0496 E1          0504*      pop hl
0B0497 D1          0505*      pop de
0B0498 C1          0506*      pop bc
0B0499 F1          0507*      pop af
0B049A C9          0508*      ret
0B049B             0509*  
0B049B             0510*  print_s168_bc_de:
0B049B F5          0511*      push af
0B049C C5          0512*      push bc
0B049D D5          0513*      push de
0B049E C5          0514*      push bc
0B049F E1          0515*      pop hl
0B04A0 CD 34 04 0B 0516*      call print_s168
0B04A4 3E 20       0517*      ld a,' '
0B04A6 5B D7       0518*      rst.lil 10h
0B04A8 EB          0519*      ex de,hl
0B04A9 CD 34 04 0B 0520*      call print_s168
0B04AD 3E 20       0521*      ld a,' '
0B04AF 5B D7       0522*      rst.lil 10h
0B04B1 E1          0523*      pop hl
0B04B2 D1          0524*      pop de
0B04B3 C1          0525*      pop bc
0B04B4 F1          0526*      pop af
0B04B5 C9          0527*      ret
0B04B6             0528*  
0B04B6             0529*  ; #### new functions added by Brandon R. Gates ####
0B04B6             0530*  
0B04B6             0531*  ; print the binary representation of the 8-bit value in a
0B04B6             0532*  ; destroys a, hl, bc
0B04B6             0533*  printBin8:
0B04B6 06 08       0534*      ld b,8      ; loop counter for 8 bits
0B04B8 21 D3 04 0B 0535*      ld hl,@cmd  ; set hl to the low byte of the output string
0B04BC             0536*                  ; (which will be the high bit of the value in a)
0B04BC             0537*  @loop:
0B04BC 07          0538*      rlca ; put the next highest bit into carry
0B04BD 38 04       0539*      jr c,@one
0B04BF 36 30       0540*      ld (hl),'0'
0B04C1 18 02       0541*      jr @next_bit
0B04C3             0542*  @one:
0B04C3 36 31       0543*      ld (hl),'1'
0B04C5             0544*  @next_bit:
0B04C5 23          0545*      inc hl
0B04C6 10 F4       0546*      djnz @loop
0B04C8             0547*  ; print it
0B04C8 21 D3 04 0B 0548*  	ld hl,@cmd
0B04CC 01 08 00 00 0549*  	ld bc,@end-@cmd
0B04D0 5B DF       0550*  	rst.lil $18
0B04D2 C9          0551*  	ret
0B04D3             0552*  @cmd: ds 8 ; eight bytes for eight bits
0B04DB             0553*  @end:
0B04DB             0554*  
0B04DB             0555*  ; print the binary representation of the 8-bit value in a
0B04DB             0556*  ; in reverse order (lsb first)
0B04DB             0557*  ; destroys a, hl, bc
0B04DB             0558*  printBin8Rev:
0B04DB 06 08       0559*      ld b,8      ; loop counter for 8 bits
0B04DD 21 F8 04 0B 0560*      ld hl,@cmd  ; set hl to the low byte of the output string
0B04E1             0561*                  ; (which will be the high bit of the value in a)
0B04E1             0562*  @loop:
0B04E1 0F          0563*      rrca ; put the next lowest bit into carry
0B04E2 38 04       0564*      jr c,@one
0B04E4 36 30       0565*      ld (hl),'0'
0B04E6 18 02       0566*      jr @next_bit
0B04E8             0567*  @one:
0B04E8 36 31       0568*      ld (hl),'1'
0B04EA             0569*  @next_bit:
0B04EA 23          0570*      inc hl
0B04EB 10 F4       0571*      djnz @loop
0B04ED             0572*  ; print it
0B04ED 21 F8 04 0B 0573*  	ld hl,@cmd
0B04F1 01 08 00 00 0574*  	ld bc,@end-@cmd
0B04F5 5B DF       0575*  	rst.lil $18
0B04F7 C9          0576*  	ret
0B04F8             0577*  @cmd: ds 8 ; eight bytes for eight bits
0B0500             0578*  @end:
0B0500             0579*  
0B0500             0580*  ; print registers to screen in hexidecimal format
0B0500             0581*  ; inputs: none
0B0500             0582*  ; outputs: values of every register printed to screen
0B0500             0583*  ;    values of each register in global scratch memory
0B0500             0584*  ; destroys: nothing
0B0500             0585*  stepRegistersHex:
0B0500             0586*  ; store everything in scratch
0B0500 22 E5 06 0B 0587*      ld (uhl),hl
0B0504 ED 43 E8 06 0588*      ld (ubc),bc
       0B          
0B0509 ED 53 EB 06 0589*      ld (ude),de
       0B          
0B050E DD 22 EE 06 0590*      ld (uix),ix
       0B          
0B0513 FD 22 F1 06 0591*      ld (uiy),iy
       0B          
0B0518 F5          0592*      push af ; fml
0B0519 E1          0593*      pop hl  ; thanks, zilog
0B051A 22 E2 06 0B 0594*      ld (uaf),hl
0B051E F5          0595*      push af ; dammit
0B051F             0596*  
0B051F             0597*  ; home the cursor
0B051F             0598*      ; call vdu_home_cursor
0B051F             0599*  
0B051F             0600*  ; print each register
0B051F 21 68 06 0B 0601*      ld hl,str_afu
0B0523 CD 73 02 0B 0602*      call printString
0B0527 2A E2 06 0B 0603*      ld hl,(uaf)
0B052B CD 93 02 0B 0604*      call printHex24
0B052F CD 88 02 0B 0605*      call printNewLine
0B0533             0606*  
0B0533 21 6D 06 0B 0607*      ld hl,str_hlu
0B0537 CD 73 02 0B 0608*      call printString
0B053B 2A E5 06 0B 0609*      ld hl,(uhl)
0B053F CD 93 02 0B 0610*      call printHex24
0B0543 CD 88 02 0B 0611*      call printNewLine
0B0547             0612*  
0B0547 21 72 06 0B 0613*      ld hl,str_bcu
0B054B CD 73 02 0B 0614*      call printString
0B054F 2A E8 06 0B 0615*      ld hl,(ubc)
0B0553 CD 93 02 0B 0616*      call printHex24
0B0557 CD 88 02 0B 0617*      call printNewLine
0B055B             0618*  
0B055B 21 77 06 0B 0619*      ld hl,str_deu
0B055F CD 73 02 0B 0620*      call printString
0B0563 2A EB 06 0B 0621*      ld hl,(ude)
0B0567 CD 93 02 0B 0622*      call printHex24
0B056B CD 88 02 0B 0623*      call printNewLine
0B056F             0624*  
0B056F 21 7C 06 0B 0625*      ld hl,str_ixu
0B0573 CD 73 02 0B 0626*      call printString
0B0577 2A EE 06 0B 0627*      ld hl,(uix)
0B057B CD 93 02 0B 0628*      call printHex24
0B057F CD 88 02 0B 0629*      call printNewLine
0B0583             0630*  
0B0583 21 81 06 0B 0631*      ld hl,str_iyu
0B0587 CD 73 02 0B 0632*      call printString
0B058B 2A F1 06 0B 0633*      ld hl,(uiy)
0B058F CD 93 02 0B 0634*      call printHex24
0B0593 CD 88 02 0B 0635*      call printNewLine
0B0597             0636*  
0B0597             0637*      ; call vsync
0B0597             0638*  
0B0597 CD 88 02 0B 0639*      call printNewLine
0B059B             0640*  
0B059B             0641*  ; check for right shift key and quit if pressed
0B059B             0642*  	MOSCALL mos_getkbmap
0B059B 3E 1E       0001*M 			LD	A, function
0B059D 5B CF       0002*M 			RST.L	08h
0B059F             0643*  @stayhere:
0B059F             0644*  ; 7 RightShift
0B059F DD CB 00 76 0645*      bit 6,(ix+0)
0B05A3 20 02       0646*      jr nz,@RightShift
0B05A5 18 F8       0647*      jr @stayhere
0B05A7             0648*  @RightShift:
0B05A7 DD CB 0E 86 0649*      res 0,(ix+14) ; debounce the key (hopefully)
0B05AB 3E 80       0650*      ld a,%10000000
0B05AD CD D3 14 0B 0651*      call multiPurposeDelay
0B05B1             0652*  
0B05B1             0653*  ; restore everything
0B05B1 2A E5 06 0B 0654*      ld hl, (uhl)
0B05B5 ED 4B E8 06 0655*      ld bc, (ubc)
       0B          
0B05BA ED 5B EB 06 0656*      ld de, (ude)
       0B          
0B05BF DD 2A EE 06 0657*      ld ix, (uix)
       0B          
0B05C4 FD 2A F1 06 0658*      ld iy, (uiy)
       0B          
0B05C9 F1          0659*      pop af
0B05CA             0660*  ; all done
0B05CA C9          0661*      ret
0B05CB             0662*  
0B05CB             0663*  ; print registers to screen in hexidecimal format
0B05CB             0664*  ; inputs: none
0B05CB             0665*  ; outputs: values of every register printed to screen
0B05CB             0666*  ;    values of each register in global scratch memory
0B05CB             0667*  ; destroys: nothing
0B05CB             0668*  dumpRegistersHex:
0B05CB             0669*  ; store everything in scratch
0B05CB 22 E5 06 0B 0670*      ld (uhl),hl
0B05CF ED 43 E8 06 0671*      ld (ubc),bc
       0B          
0B05D4 ED 53 EB 06 0672*      ld (ude),de
       0B          
0B05D9 DD 22 EE 06 0673*      ld (uix),ix
       0B          
0B05DE FD 22 F1 06 0674*      ld (uiy),iy
       0B          
0B05E3 F5          0675*      push af ; fml
0B05E4 E1          0676*      pop hl  ; thanks, zilog
0B05E5 22 E2 06 0B 0677*      ld (uaf),hl
0B05E9 F5          0678*      push af ; dammit
0B05EA             0679*  
0B05EA             0680*  ; home the cursor
0B05EA             0681*      ; call vdu_home_cursor
0B05EA             0682*      ; call printNewLine
0B05EA             0683*  
0B05EA             0684*  ; print each register
0B05EA 21 68 06 0B 0685*      ld hl,str_afu
0B05EE CD 73 02 0B 0686*      call printString
0B05F2 2A E2 06 0B 0687*      ld hl,(uaf)
0B05F6 CD 93 02 0B 0688*      call printHex24
0B05FA             0689*      ; call printNewLine
0B05FA             0690*  
0B05FA 21 6D 06 0B 0691*      ld hl,str_hlu
0B05FE CD 73 02 0B 0692*      call printString
0B0602 2A E5 06 0B 0693*      ld hl,(uhl)
0B0606 CD 93 02 0B 0694*      call printHex24
0B060A             0695*      ; call printNewLine
0B060A             0696*  
0B060A 21 72 06 0B 0697*      ld hl,str_bcu
0B060E CD 73 02 0B 0698*      call printString
0B0612 2A E8 06 0B 0699*      ld hl,(ubc)
0B0616 CD 93 02 0B 0700*      call printHex24
0B061A             0701*      ; call printNewLine
0B061A             0702*  
0B061A 21 77 06 0B 0703*      ld hl,str_deu
0B061E CD 73 02 0B 0704*      call printString
0B0622 2A EB 06 0B 0705*      ld hl,(ude)
0B0626 CD 93 02 0B 0706*      call printHex24
0B062A             0707*      ; call printNewLine
0B062A             0708*  
0B062A 21 7C 06 0B 0709*      ld hl,str_ixu
0B062E CD 73 02 0B 0710*      call printString
0B0632 2A EE 06 0B 0711*      ld hl,(uix)
0B0636 CD 93 02 0B 0712*      call printHex24
0B063A             0713*      ; call printNewLine
0B063A             0714*  
0B063A 21 81 06 0B 0715*      ld hl,str_iyu
0B063E CD 73 02 0B 0716*      call printString
0B0642 2A F1 06 0B 0717*      ld hl,(uiy)
0B0646 CD 93 02 0B 0718*      call printHex24
0B064A             0719*      ; call printNewLine
0B064A             0720*  
0B064A             0721*      ; call vdu_vblank
0B064A             0722*  
0B064A CD 88 02 0B 0723*      call printNewLine
0B064E             0724*  ; restore everything
0B064E 2A E5 06 0B 0725*      ld hl, (uhl)
0B0652 ED 4B E8 06 0726*      ld bc, (ubc)
       0B          
0B0657 ED 5B EB 06 0727*      ld de, (ude)
       0B          
0B065C DD 2A EE 06 0728*      ld ix, (uix)
       0B          
0B0661 FD 2A F1 06 0729*      ld iy, (uiy)
       0B          
0B0666 F1          0730*      pop af
0B0667             0731*  ; all done
0B0667 C9          0732*      ret
0B0668             0733*  
0B0668 20 61 66 3D 0734*  str_afu: db " af=",0
       00          
0B066D 20 68 6C 3D 0735*  str_hlu: db " hl=",0
       00          
0B0672 20 62 63 3D 0736*  str_bcu: db " bc=",0
       00          
0B0677 20 64 65 3D 0737*  str_deu: db " de=",0
       00          
0B067C 20 69 78 3D 0738*  str_ixu: db " ix=",0
       00          
0B0681 20 69 79 3D 0739*  str_iyu: db " iy=",0
       00          
0B0686             0740*  
0B0686             0741*  ; print udeuhl to screen in hexidecimal format
0B0686             0742*  ; inputs: none
0B0686             0743*  ; outputs: concatenated hexidecimal udeuhl
0B0686             0744*  ; destroys: nothing
0B0686             0745*  dumpUDEUHLHex:
0B0686             0746*  ; store everything in scratch
0B0686 22 E5 06 0B 0747*      ld (uhl),hl
0B068A ED 43 E8 06 0748*      ld (ubc),bc
       0B          
0B068F ED 53 EB 06 0749*      ld (ude),de
       0B          
0B0694 DD 22 EE 06 0750*      ld (uix),ix
       0B          
0B0699 FD 22 F1 06 0751*      ld (uiy),iy
       0B          
0B069E F5          0752*      push af
0B069F             0753*  
0B069F             0754*  ; print each register
0B069F             0755*  
0B069F 21 D9 06 0B 0756*      ld hl,str_udeuhl
0B06A3 CD 73 02 0B 0757*      call printString
0B06A7 2A EB 06 0B 0758*      ld hl,(ude)
0B06AB CD 93 02 0B 0759*      call printHex24
0B06AF 3E 2E       0760*  	ld a,'.'	; print a dot to separate the values
0B06B1 5B D7       0761*  	rst.lil 10h
0B06B3 2A E5 06 0B 0762*      ld hl,(uhl)
0B06B7 CD 93 02 0B 0763*      call printHex24
0B06BB CD 88 02 0B 0764*      call printNewLine
0B06BF             0765*  
0B06BF             0766*  ; restore everything
0B06BF 2A E5 06 0B 0767*      ld hl, (uhl)
0B06C3 ED 4B E8 06 0768*      ld bc, (ubc)
       0B          
0B06C8 ED 5B EB 06 0769*      ld de, (ude)
       0B          
0B06CD DD 2A EE 06 0770*      ld ix, (uix)
       0B          
0B06D2 FD 2A F1 06 0771*      ld iy, (uiy)
       0B          
0B06D7 F1          0772*      pop af
0B06D8             0773*  ; all done
0B06D8 C9          0774*      ret
0B06D9             0775*  
0B06D9 75 64 65 2E 0776*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B06E2             0777*  
0B06E2             0778*  ; global scratch memory for registers
0B06E2 00 00 00    0779*  uaf: dl 0
0B06E5 00 00 00    0780*  uhl: dl 0
0B06E8 00 00 00    0781*  ubc: dl 0
0B06EB 00 00 00    0782*  ude: dl 0
0B06EE 00 00 00    0783*  uix: dl 0
0B06F1 00 00 00    0784*  uiy: dl 0
0B06F4 00 00 00    0785*  usp: dl 0
0B06F7 00 00 00    0786*  upc: dl 0
0B06FA             0787*  
0B06FA             0788*  ; inputs: whatever is in the flags register
0B06FA             0789*  ; outputs: binary representation of flags
0B06FA             0790*  ;          with a header so we know which is what
0B06FA             0791*  ; destroys: nothing
0B06FA             0792*  ; preserves: everything
0B06FA             0793*  dumpFlags:
0B06FA             0794*  ; first we curse zilog for not giving direct access to flags
0B06FA F5          0795*      push af ; this is so we can send it back unharmed
0B06FB F5          0796*      push af ; this is so we can pop it to hl
0B06FC             0797*  ; store everything in scratch
0B06FC 22 E5 06 0B 0798*      ld (uhl),hl
0B0700 ED 43 E8 06 0799*      ld (ubc),bc
       0B          
0B0705 ED 53 EB 06 0800*      ld (ude),de
       0B          
0B070A DD 22 EE 06 0801*      ld (uix),ix
       0B          
0B070F FD 22 F1 06 0802*      ld (uiy),iy
       0B          
0B0714             0803*  ; next we print the header
0B0714 21 40 07 0B 0804*      ld hl,@header
0B0718 CD 73 02 0B 0805*      call printString
0B071C E1          0806*      pop hl ; flags are now in l
0B071D 7D          0807*      ld a,l ; flags are now in a
0B071E CD B6 04 0B 0808*      call printBin8
0B0722 CD 88 02 0B 0809*  	call printNewLine
0B0726             0810*  ; restore everything
0B0726 2A E5 06 0B 0811*      ld hl, (uhl)
0B072A ED 4B E8 06 0812*      ld bc, (ubc)
       0B          
0B072F ED 5B EB 06 0813*      ld de, (ude)
       0B          
0B0734 DD 2A EE 06 0814*      ld ix, (uix)
       0B          
0B0739 FD 2A F1 06 0815*      ld iy, (uiy)
       0B          
0B073E F1          0816*      pop af ; send her home the way she came
0B073F C9          0817*      ret
0B0740             0818*  ; Bit 7 (S): Sign flag
0B0740             0819*  ; Bit 6 (Z): Zero flag
0B0740             0820*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B0740             0821*  ; Bit 4 (H): Half Carry flag
0B0740             0822*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B0740             0823*  ; Bit 2 (PV): Parity/Overflow flag
0B0740             0824*  ; Bit 1 (N): Subtract flag
0B0740             0825*  ; Bit 0 (C): Carry flag
0B0740 53 5A 78 48 0826*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B074B             0827*  
0B074B             0828*  ; set all the bits in the flag register
0B074B             0829*  ; more of an academic exercise than anything useful
0B074B             0830*  ; inputs; none
0B074B             0831*  ; outputs; a=0,f=255
0B074B             0832*  ; destroys: flags, hl
0B074B             0833*  ; preserves: a, because why not
0B074B             0834*  setAllFlags:
0B074B 21 FF 00 00 0835*      ld hl,255
0B074F 67          0836*      ld h,a ; four cycles to preserve a is cheap
0B0750 E5          0837*      push hl
0B0751 F1          0838*      pop af
0B0752 C9          0839*      ret
0B0753             0840*  
0B0753             0841*  ; reset all the bits in the flag register
0B0753             0842*  ; unlike its inverse counterpart, this may actually be useful
0B0753             0843*  ; inputs; none
0B0753             0844*  ; outputs; a=0,f=0
0B0753             0845*  ; destroys: flags, hl
0B0753             0846*  ; preserves: a, because why not
0B0753             0847*  resetAllFlags:
0B0753 21 00 00 00 0848*      ld hl,0
0B0757 67          0849*      ld h,a ; four cycles to preserve a is cheap
0B0758 E5          0850*      push hl
0B0759 F1          0851*      pop af
0B075A C9          0852*      ret
0B075B             0853*  
0B075B             0854*  ; wait until user presses a key
0B075B             0855*  ; inputs: none
0B075B             0856*  ; outputs: none
0B075B             0857*  ; destroys: af,ix
0B075B             0858*  waitKeypress:
0B075B             0859*      MOSCALL mos_sysvars
0B075B 3E 08       0001*M 			LD	A, function
0B075D 5B CF       0002*M 			RST.L	08h
0B075F AF          0860*      xor a ; zero out any prior keypresses
0B0760 DD 77 05    0861*      ld (ix+sysvar_keyascii),a
0B0763             0862*  @loop:
0B0763 DD 7E 05    0863*      ld a,(ix+sysvar_keyascii)
0B0766 A7          0864*      and a
0B0767 C0          0865*      ret nz
0B0768 18 F9       0866*      jr @loop
0B076A             0867*  
0B076A             0868*  
0B076A             0869*  ; print bytes from an address to the screen in hexidecimal format
0B076A             0870*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B076A             0871*  ; outputs: values of each byte printed to screen separated by spaces
0B076A             0872*  ; destroys: nothing
0B076A             0873*  dumpMemoryHex:
0B076A             0874*  ; save registers to the stack
0B076A C5          0875*      push bc
0B076B E5          0876*      push hl
0B076C F5          0877*      push af
0B076D             0878*  
0B076D             0879*  ; print the address and separator
0B076D CD 93 02 0B 0880*      call printHex24
0B0771 3E 3A       0881*      ld a,':'
0B0773 5B D7       0882*      rst.lil 10h
0B0775 3E 20       0883*      ld a,' '
0B0777 5B D7       0884*      rst.lil 10h
0B0779             0885*  
0B0779             0886*  ; set b to be our loop counter
0B0779 F1          0887*      pop af
0B077A 47          0888*      ld b,a
0B077B E1          0889*      pop hl
0B077C E5          0890*      push hl
0B077D F5          0891*      push af
0B077E             0892*  @loop:
0B077E             0893*  ; print the byte
0B077E 7E          0894*      ld a,(hl)
0B077F CD A1 02 0B 0895*      call printHex8
0B0783             0896*  ; print a space
0B0783 3E 20       0897*      ld a,' '
0B0785 5B D7       0898*      rst.lil 10h
0B0787 23          0899*      inc hl
0B0788 10 F4       0900*      djnz @loop
0B078A             0901*      ; call printNewLine
0B078A             0902*  
0B078A             0903*  ; restore everything
0B078A F1          0904*      pop af
0B078B E1          0905*      pop hl
0B078C C1          0906*      pop bc
0B078D             0907*  
0B078D             0908*  ; all done
0B078D C9          0909*      ret
0B078E             0910*  
0B078E             0911*  
0B078E             0912*  ; print bytes from an address to the screen in binary format
0B078E             0913*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B078E             0914*  ; outputs: values of each byte printed to screen separated by spaces
0B078E             0915*  ; destroys: nothing
0B078E             0916*  dumpMemoryBin:
0B078E             0917*  ; save all registers to the stack
0B078E F5          0918*      push af
0B078F C5          0919*      push bc
0B0790 D5          0920*      push de
0B0791 E5          0921*      push hl
0B0792 DD E5       0922*      push ix
0B0794 FD E5       0923*      push iy
0B0796             0924*  
0B0796             0925*  ; set b to be our loop counter
0B0796 47          0926*      ld b,a
0B0797             0927*  @loop:
0B0797             0928*  ; print the byte
0B0797 7E          0929*      ld a,(hl)
0B0798 E5          0930*      push hl
0B0799 C5          0931*      push bc
0B079A CD B6 04 0B 0932*      call printBin8
0B079E C1          0933*      pop bc
0B079F             0934*  ; print a space
0B079F 3E 20       0935*      ld a,' '
0B07A1 5B D7       0936*      rst.lil 10h
0B07A3 E1          0937*      pop hl
0B07A4 23          0938*      inc hl
0B07A5 10 F0       0939*      djnz @loop
0B07A7 CD 88 02 0B 0940*      call printNewLine
0B07AB             0941*  
0B07AB             0942*  ; restore everything
0B07AB FD E1       0943*      pop iy
0B07AD DD E1       0944*      pop ix
0B07AF E1          0945*      pop hl
0B07B0 D1          0946*      pop de
0B07B1 C1          0947*      pop bc
0B07B2 F1          0948*      pop af
0B07B3             0949*  ; all done
0B07B3 C9          0950*      ret
0B07B4             0951*  
0B07B4             0952*  ; print bytes from an address to the screen in binary format
0B07B4             0953*  ; with the bits of each byte in reverse order (lsb first)
0B07B4             0954*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07B4             0955*  ; outputs: values of each byte printed to screen separated by spaces
0B07B4             0956*  ; destroys: nothing
0B07B4             0957*  dumpMemoryBinRev:
0B07B4             0958*  ; save all registers to the stack
0B07B4 F5          0959*      push af
0B07B5 C5          0960*      push bc
0B07B6 D5          0961*      push de
0B07B7 E5          0962*      push hl
0B07B8 DD E5       0963*      push ix
0B07BA FD E5       0964*      push iy
0B07BC             0965*  
0B07BC             0966*  ; set b to be our loop counter
0B07BC 47          0967*      ld b,a
0B07BD             0968*  @loop:
0B07BD             0969*  ; print the byte
0B07BD 7E          0970*      ld a,(hl)
0B07BE E5          0971*      push hl
0B07BF C5          0972*      push bc
0B07C0 CD DB 04 0B 0973*      call printBin8Rev
0B07C4 C1          0974*      pop bc
0B07C5             0975*  ; print a space
0B07C5 3E 20       0976*      ld a,' '
0B07C7 5B D7       0977*      rst.lil 10h
0B07C9 E1          0978*      pop hl
0B07CA 23          0979*      inc hl
0B07CB 10 F0       0980*      djnz @loop
0B07CD CD 88 02 0B 0981*      call printNewLine
0B07D1             0982*  
0B07D1             0983*  ; restore everything
0B07D1 FD E1       0984*      pop iy
0B07D3 DD E1       0985*      pop ix
0B07D5 E1          0986*      pop hl
0B07D6 D1          0987*      pop de
0B07D7 C1          0988*      pop bc
0B07D8 F1          0989*      pop af
0B07D9             0990*  ; all done
0B07D9 C9          0991*      ret
0B07DA             0020       include "maths.inc"
0B07DA             0001*  ; absolute value of hlu
0B07DA             0002*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B07DA             0003*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B07DA             0004*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B07DA             0005*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B07DA             0006*  ; destroys: a
0B07DA             0007*  abs_hlu:
0B07DA 19          0008*      add hl,de
0B07DB B7          0009*      or a
0B07DC ED 52       0010*      sbc hl,de
0B07DE FA E3 07 0B 0011*      jp m,@is_neg
0B07E2 C9          0012*      ret         ; hlu is positive or zero so we're done
0B07E3             0013*  @is_neg:
0B07E3 F5          0014*      push af     ; otherwise, save current flags for return
0B07E4 CD EA 07 0B 0015*      call neg_hlu ; negate hlu
0B07E8 F1          0016*      pop af      ; get back flags
0B07E9 C9          0017*      ret
0B07EA             0018*  
0B07EA             0019*  ; flip the sign of hlu
0B07EA             0020*  ; inputs: hlu
0B07EA             0021*  ; returns: 0-hlu, flags set appropriately for the result:
0B07EA             0022*  ;         s1,z0,pv0,n1,c1 if result is negative
0B07EA             0023*  ;         s0,z1,pv0,n1,c0 if result is zero
0B07EA             0024*  ;         s0,z0,pv0,n1,c1 if result is positive
0B07EA             0025*  ; destroys a
0B07EA             0026*  neg_hlu:
0B07EA D5          0027*      push de     ; save de
0B07EB EB          0028*      ex de,hl    ; put hl into de
0B07EC 21 00 00 00 0029*      ld hl,0     ; clear hl
0B07F0 AF          0030*      xor a       ; clear carry
0B07F1 ED 52       0031*      sbc hl,de   ; 0-hlu = -hlu
0B07F3 D1          0032*      pop de      ; get de back
0B07F4 C9          0033*      ret         ; easy peasy
0B07F5             0034*  
0B07F5             0035*  ;------------------------------------------------------------------------
0B07F5             0036*  ; divide hlu by 2, inspired by above
0B07F5             0037*  ;------------------------------------------------------------------------
0B07F5             0038*  hlu_div2:
0B07F5 22 D6 0A 0B 0039*  	ld		(bitbuf1),hl
0B07F9 21 D8 0A 0B 0040*  	ld		hl,bitbuf1+2
0B07FD CB 1E       0041*  	rr		(hl)
0B07FF 2B          0042*  	dec		hl
0B0800 CB 1E       0043*  	rr		(hl)
0B0802 2B          0044*  	dec		hl
0B0803 CB 1E       0045*  	rr		(hl)
0B0805 23          0046*  	inc		hl
0B0806 23          0047*  	inc		hl
0B0807 2A D6 0A 0B 0048*      ld hl,(bitbuf1)
0B080B C9          0049*      ret
0B080C             0050*  
0B080C             0051*  ; this is my little hack to divide by 16
0B080C             0052*  hlu_div16:
0B080C AF          0053*      xor a
0B080D 29          0054*      add hl,hl
0B080E 17          0055*      rla
0B080F 29          0056*      add hl,hl
0B0810 17          0057*      rla
0B0811 29          0058*      add hl,hl
0B0812 17          0059*      rla
0B0813 29          0060*      add hl,hl
0B0814 17          0061*      rla
0B0815 22 22 08 0B 0062*      ld (@scratch),hl
0B0819 32 25 08 0B 0063*      ld (@scratch+3),a
0B081D 2A 23 08 0B 0064*      ld hl,(@scratch+1)
0B0821 C9          0065*      ret
0B0822             0066*  @scratch: ds 4
0B0826             0067*  
0B0826             0068*  ; hlu signed division by 256
0B0826             0069*  ; returns: hlu / 256
0B0826             0070*  ; destroys: af
0B0826             0071*  hlu_sdiv256:
0B0826 AF          0072*      xor a ; assume hl is positive
0B0827 22 3D 08 0B 0073*      ld (@buffer),hl
0B082B             0074*      sign_hlu
0B082B 19          0001*M         add hl,de
0B082C B7          0002*M         or a
0B082D ED 52       0003*M         sbc hl,de
0B082F F2 34 08 0B 0075*      jp p,@hl_pos
0B0833 3D          0076*      dec a
0B0834             0077*  @hl_pos:
0B0834 32 40 08 0B 0078*      ld (@buffer+3),a
0B0838 2A 3E 08 0B 0079*      ld hl,(@buffer+1)
0B083C C9          0080*      ret
0B083D             0081*  @buffer: ds 4
0B0841             0082*  
0B0841             0083*  ; hlu 1 byte right shift, unsigned
0B0841             0084*  ; returns: hlu / 256, fractional portion in a
0B0841             0085*  ; destroys: af
0B0841             0086*  hlu_udiv256:
0B0841 AF          0087*  	xor a
0B0842 32 53 08 0B 0088*  	ld (@buffer+3),a
0B0846 7D          0089*  	ld a,l ; save the fractional portion
0B0847 22 50 08 0B 0090*  	ld (@buffer),hl
0B084B 2A 51 08 0B 0091*  	ld hl,(@buffer+1)
0B084F C9          0092*  	ret
0B0850             0093*  @buffer: ds 4
0B0854             0094*  
0B0854             0095*      MACRO hlu_mul256
0B0854             0096*          add hl,hl ; * 2
0B0854             0097*          add hl,hl ; * 4
0B0854             0098*          add hl,hl ; * 8
0B0854             0099*          add hl,hl ; * 16
0B0854             0100*          add hl,hl ; * 32
0B0854             0101*          add hl,hl ; * 64
0B0854             0102*          add hl,hl ; * 128
0B0854             0103*          add hl,hl ; * 256
0B0854             0104*      ENDMACRO
0B0854             0105*  
0B0854 00 00 00 00 0106*  add_bcd_arg1: db #00,#00,#00,#00
0B0858 00 00 00 00 0107*  add_bcd_arg2: db #00,#00,#00,#00
0B085C             0108*  
0B085C             0109*  ; set bcd values in a scratch memory address from registers bcde
0B085C             0110*  ; input: hl; scratch address,bcde; 8-place bcd number
0B085C             0111*  ; destroys ; hl
0B085C             0112*  set_bcd:
0B085C 73          0113*      ld (hl),e
0B085D 23          0114*      inc hl
0B085E 72          0115*      ld (hl),d
0B085F 23          0116*      inc hl
0B0860 71          0117*      ld (hl),c
0B0861 23          0118*      inc hl
0B0862 70          0119*      ld (hl),b
0B0863 C9          0120*      ret
0B0864             0121*  
0B0864             0122*  ; load bcd values from a scratch memory address to bcde
0B0864             0123*  ; input: hl; scratch address
0B0864             0124*  ; output: bcde; 8-place bcd number
0B0864             0125*  ; destroys: hl
0B0864             0126*  get_bcd:
0B0864 5E          0127*      ld e,(hl)
0B0865 23          0128*      inc hl
0B0866 56          0129*      ld d,(hl)
0B0867 23          0130*      inc hl
0B0868 4E          0131*      ld c,(hl)
0B0869 23          0132*      inc hl
0B086A 46          0133*      ld b,(hl)
0B086B C9          0134*      ret
0B086C             0135*  
0B086C             0136*  ; BCD addition
0B086C             0137*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B086C             0138*  ;       a is the number of bytes holding each number (number of places/2)
0B086C             0139*  ; outputs: (hl) + (de) --> (hl)
0B086C             0140*  ; destroys: a,b,de,hl
0B086C             0141*  add_bcd:
0B086C 47          0142*      ld b,a ; loop counter
0B086D AF          0143*      xor a ; reset a, clear carry flag
0B086E             0144*  adcec:
0B086E 1A          0145*      ld a,(de) ; addend to acc
0B086F 8E          0146*      adc a,(hl) ; add (hl) to acc
0B0870 27          0147*      daa ; adjust result to bcd
0B0871 77          0148*      ld (hl),a ; store result
0B0872 23          0149*      inc hl ; advance memory pointers
0B0873 13          0150*      inc de
0B0874 10 F8       0151*      djnz adcec ; loop until b == 0
0B0876 C9          0152*      ret
0B0877             0153*  
0B0877             0154*  ; BCD subtraction
0B0877             0155*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B0877             0156*  ;       a is the number of bytes holding each number (number of places/2)
0B0877             0157*  ; outputs: (hl) - (de) --> (hl)
0B0877             0158*  ; destroys: a,b,de,hl
0B0877             0159*  sub_bcd:
0B0877 47          0160*      ld b,a ; loop counter
0B0878 AF          0161*      xor a ; reset a,clear carry flag
0B0879             0162*  subdec:
0B0879 1A          0163*      ld a,(de) ; subtrahend to acc
0B087A 9E          0164*      sbc a,(hl) ; subtract (hl) from acc
0B087B 27          0165*      daa ; adjust result to bcd
0B087C 77          0166*      ld (hl),a ; store result
0B087D 23          0167*      inc hl ; advance memory pointers
0B087E 13          0168*      inc de
0B087F 10 F8       0169*      djnz subdec ; loop until b == 0
0B0881 C9          0170*      ret
0B0882             0171*  
0B0882             0172*  ; http://www.z80.info/pseudo-random.txt
0B0882             0173*  rand_8:
0B0882 C5          0174*      push bc
0B0883 3A 96 08 0B 0175*      ld a,(r_seed)
0B0887 4F          0176*      ld c,a
0B0888             0177*  
0B0888 0F          0178*      rrca ; multiply by 32
0B0889 0F          0179*      rrca
0B088A 0F          0180*      rrca
0B088B EE 1F       0181*      xor 0x1f
0B088D             0182*  
0B088D 81          0183*      add a,c
0B088E DE FF       0184*      sbc a,255 ; carry
0B0890             0185*  
0B0890 32 96 08 0B 0186*      ld (r_seed),a
0B0894 C1          0187*      pop bc
0B0895 C9          0188*      ret
0B0896 50          0189*  r_seed: defb $50
0B0897             0190*  
0B0897             0191*  ; linear interpolation between two 24-bit numbers
0B0897             0192*  ; may be signed or unsigned, and treated as integers or fractional
0B0897             0193*  ; inputs: bc = start value, de = end value, a = interpolation factor
0B0897             0194*  ; outputs: hl = interpolated value, a = multiply overflow to 32 bits (0 if no overflow)
0B0897             0195*  ; destroys: af, hl, de
0B0897             0196*  interpolate24:
0B0897 C5          0197*      push bc ; save start value
0B0898 EB          0198*      ex de,hl ; end value to hl
0B0899 B7          0199*      or a ; clear carry
0B089A ED 42       0200*      sbc hl,bc ; hl = end - start
0B089C CD E3 08 0B 0201*      call umul24x8 ; hl = (end - start) * interpolation factor
0B08A0 C1          0202*      pop bc ; get back start value (was hl)
0B08A1 09          0203*      add hl,bc ; hl = start + (end - start) * interpolation factor
0B08A2 C9          0204*      ret
0B08A3             0021   	INCLUDE	"arith24.inc"
0B08A3             0001*  arith24uaf: ds 6
0B08A9             0002*  arith24uhl: ds 6
0B08AF             0003*  arith24ubc: ds 6
0B08B5             0004*  arith24ude: ds 6
0B08BB             0005*  arith24uix: ds 6
0B08C1             0006*  arith24uiy: ds 6
0B08C7             0007*  arith24usp: ds 6
0B08CD             0008*  arith24upc: ds 6
0B08D3             0009*  
0B08D3             0010*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B08D3             0011*  ; uses EZ80 MLT instruction for speed
0B08D3             0012*  ; operation: UHL * A --> UHL
0B08D3             0013*  ; destroys: AF, HL
0B08D3             0014*  smul24x8:
0B08D3             0015*  ; make hl positive and store sign flag
0B08D3 CD DA 07 0B 0016*  	call abs_hlu
0B08D7 F5          0017*  	push af
0B08D8             0018*  ; do the division
0B08D8 CD E3 08 0B 0019*      call umul24x8 ; hl = product
0B08DC             0020*  ; adjust sign of result
0B08DC F1          0021*  	pop af ; sign de
0B08DD F0          0022*  	ret p ; hl was positive, nothing to do
0B08DE CD EA 07 0B 0023*  	call neg_hlu ; result is negative
0B08E2 C9          0024*  	ret
0B08E3             0025*  
0B08E3             0026*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B08E3             0027*  ; uses EZ80 MLT instruction for speed
0B08E3             0028*  ; operation: UHL * A --> AUHL
0B08E3             0029*  ; destroys: AF, HL
0B08E3             0030*  umul24x8:
0B08E3 D5          0031*  	push de ; preserve de
0B08E4             0032*  ; low byte
0B08E4 5D          0033*  	ld e,l
0B08E5 57          0034*  	ld d,a
0B08E6 ED 5C       0035*  	mlt de
0B08E8 6B          0036*  	ld l,e ; product low byte
0B08E9 08          0037*  	ex af,af' ; save multiplier
0B08EA 7A          0038*  	ld a,d ; carry
0B08EB 08          0039*  	ex af,af' ; save carry, restore multiplier
0B08EC             0040*  ; high byte
0B08EC 5C          0041*  	ld e,h
0B08ED 57          0042*  	ld d,a
0B08EE ED 5C       0043*  	mlt de
0B08F0 08          0044*  	ex af,af' ; save multiplier, restore carry
0B08F1 83          0045*  	add a,e ; add carry
0B08F2 67          0046*  	ld h,a ; product middle byte
0B08F3 7A          0047*  	ld a,d ; carry
0B08F4 08          0048*  	ex af,af' ; save carry, restore multiplier
0B08F5             0049*  ; upper byte
0B08F5 E5          0050*  	push hl
0B08F6 33          0051*  	inc sp
0B08F7 D1          0052*  	pop de ; d = hlu
0B08F8 3B          0053*  	dec sp
0B08F9 5F          0054*  	ld e,a
0B08FA ED 5C       0055*  	mlt de
0B08FC 08          0056*  	ex af,af' ; restore carry
0B08FD 8B          0057*  	adc a,e ; add carry
0B08FE 22 0F 09 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0902 32 11 09 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B0906 2A 0F 09 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B090A             0061*  ; highest byte
0B090A 3E 00       0062*  	ld a,0 ; preserve carry flag
0B090C 8A          0063*  	adc a,d ; product highest byte
0B090D D1          0064*  	pop de ; restore de
0B090E C9          0065*  	ret
0B090F             0066*  @scratch: ds 3
0B0912             0067*  
0B0912             0068*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0912             0069*  ; operation: UHL * UDE --> umul24x24out
0B0912             0070*  umul24x24:
0B0912 FD 21 6A 09 0071*  	ld iy,umul24x24out ; point to output buffer
       0B          
0B0917 C5          0072*  	push bc
0B0918 01 00 00 00 0073*  	ld bc,0
0B091C FD 0F 00    0074*  	ld (iy),bc
0B091F FD 0F 03    0075*  	ld (iy+3),bc
0B0922 C1          0076*  	pop bc
0B0923             0077*  
0B0923             0078*  ; STEP 1: UHL * E
0B0923 7B          0079*  	ld a,e
0B0924 E5          0080*  	push hl
0B0925 CD E3 08 0B 0081*  	call umul24x8
0B0929 FD 2F 00    0082*  	ld (iy+0),hl
0B092C FD 77 03    0083*  	ld (iy+3),a
0B092F             0084*  
0B092F             0085*  ; STEP 2: UHL * D
0B092F E1          0086*  	pop hl
0B0930 E5          0087*  	push hl
0B0931 7A          0088*  	ld a,d
0B0932 CD E3 08 0B 0089*  	call umul24x8
0B0936 CD 43 09 0B 0090*  	call @accumulate
0B093A             0091*  
0B093A             0092*  ; STEP 3: UHL * DEU
0B093A E1          0093*  	pop hl
0B093B D5          0094*  	push de
0B093C 33          0095*  	inc sp
0B093D F1          0096*  	pop af
0B093E 3B          0097*  	dec sp
0B093F CD E3 08 0B 0098*  	call umul24x8
0B0943             0099*  
0B0943             0100*  @accumulate:
0B0943 FD 23       0101*  	inc iy
0B0945             0102*  ; highest byte of product to carry
0B0945 FD 77 03    0103*  	ld (iy+3),a
0B0948             0104*  ; low byte of product
0B0948 7D          0105*  	ld a,l
0B0949 FD 86 00    0106*  	add a,(iy+0)
0B094C FD 77 00    0107*  	ld (iy+0),a
0B094F             0108*  ; high byte of product
0B094F 7C          0109*  	ld a,h
0B0950 FD 8E 01    0110*  	adc a,(iy+1)
0B0953 FD 77 01    0111*  	ld (iy+1),a
0B0956             0112*  ; uppper byte of product
0B0956 E5          0113*  	push hl
0B0957 33          0114*  	inc sp
0B0958 E1          0115*  	pop hl
0B0959 3B          0116*  	dec sp
0B095A 7C          0117*  	ld a,h
0B095B FD 8E 02    0118*  	adc a,(iy+2)
0B095E FD 77 02    0119*  	ld (iy+2),a
0B0961             0120*  ; carry
0B0961 3E 00       0121*  	ld a,0 ; preserve flags
0B0963 FD 8E 03    0122*  	adc a,(iy+3)
0B0966 FD 77 03    0123*  	ld (iy+3),a
0B0969 C9          0124*  	ret
0B096A             0125*  umul24x24out: ds 6 ; output buffer
0B0970             0126*  
0B0970             0127*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B0970             0128*  umul168:
0B0970 CD 12 09 0B 0129*  	call umul24x24
0B0974 FD 27 FF    0130*  	ld hl,(iy-1)
0B0977 C9          0131*  	ret
0B0978             0132*  
0B0978             0133*  ; smul168:	UH.L * UD.E --> UH.L (signed)
0B0978             0134*  smul168:
0B0978             0135*  ; make everything positive and store sign flags
0B0978 CD DA 07 0B 0136*  	call abs_hlu
0B097C F5          0137*  	push af
0B097D EB          0138*  	ex de,hl
0B097E CD DA 07 0B 0139*  	call abs_hlu
0B0982 EB          0140*  	ex de,hl
0B0983 F5          0141*  	push af
0B0984             0142*  ; do the division
0B0984 CD 70 09 0B 0143*      call umul168 ; hl = product
0B0988             0144*  ; adjust sign of result
0B0988 F1          0145*  	pop af ; sign de
0B0989 FA 94 09 0B 0146*  	jp m,@de_neg
0B098D F1          0147*  	pop af ; sign hl
0B098E F0          0148*  	ret p ; both positive, nothing to do
0B098F             0149*  @hl_neg:
0B098F CD EA 07 0B 0150*      call neg_hlu ; de pos, hl neg, result is negative
0B0993 C9          0151*      ret
0B0994             0152*  @de_neg:
0B0994 F1          0153*  	pop af
0B0995 F8          0154*  	ret m ; both negative, nothing to do
0B0996 CD EA 07 0B 0155*  	call neg_hlu ; result is negative
0B099A C9          0156*  	ret
0B099B             0157*  
0B099B             0158*  ;------------------------------------------------------------------------
0B099B             0159*  ;  arith24.inc
0B099B             0160*  ;  24-bit ez80 arithmetic routines
0B099B             0161*  ;  Copyright (c) Shawn Sijnstra 2024
0B099B             0162*  ;  MIT license
0B099B             0163*  ;
0B099B             0164*  ;  This library was created as a tool to help make ez80
0B099B             0165*  ;  24-bit native assembly routines for simple mathematical problems
0B099B             0166*  ;  more widely available.
0B099B             0167*  ;
0B099B             0168*  ;------------------------------------------------------------------------
0B099B             0169*  
0B099B             0170*  ;------------------------------------------------------------------------
0B099B             0171*  ; umul24:	HL = HL*DE (unsigned)
0B099B             0172*  ; Preserves AF, BC, DE
0B099B             0173*  ; Uses a fast multiply routine.
0B099B             0174*  ;------------------------------------------------------------------------
0B099B             0175*  umul24:
0B099B D5          0176*  	push	DE
0B099C C5          0177*  	push	BC
0B099D F5          0178*  	push	AF
0B099E E5          0179*  	push	HL
0B099F C1          0180*  	pop		BC
0B09A0 3E 18       0181*      ld	 	a, 24 ; No. of bits to process
0B09A2 21 00 00 00 0182*      ld	 	hl, 0 ; Result
0B09A6             0183*  umul24_lp:
0B09A6 29          0184*  	add	hl,hl
0B09A7 EB          0185*  	ex	de,hl
0B09A8 29          0186*  	add	hl,hl
0B09A9 EB          0187*  	ex	de,hl
0B09AA 30 01       0188*  	jr	nc,umul24_nc
0B09AC 09          0189*  	add	hl,bc
0B09AD             0190*  umul24_nc:
0B09AD 3D          0191*  	dec	a
0B09AE 20 F6       0192*  	jr	nz,umul24_lp
0B09B0 F1          0193*  	pop	af
0B09B1 C1          0194*  	pop	bc
0B09B2 D1          0195*  	pop	de
0B09B3 C9          0196*  	ret
0B09B4             0197*  
0B09B4             0198*  ;------------------------------------------------------------------------
0B09B4             0199*  ; udiv24
0B09B4             0200*  ; Unsigned 24-bit division
0B09B4             0201*  ; HLU / DEU --> DEU rem HLU
0B09B4             0202*  ; Uses AF BC DE HL
0B09B4             0203*  ; Uses Restoring Division algorithm
0B09B4             0204*  ;------------------------------------------------------------------------
0B09B4             0205*  
0B09B4             0206*  udiv24:
0B09B4 E5          0207*  	push	hl
0B09B5 C1          0208*  	pop		bc	;move dividend to BCU
0B09B6 21 00 00 00 0209*  	ld		hl,0	;result
0B09BA A7          0210*  	and		a
0B09BB ED 52       0211*  	sbc		hl,de	;test for div by 0
0B09BD C8          0212*  	ret		z		;it's zero, carry flag is clear
0B09BE 19          0213*  	add		hl,de	;HL is 0 again
0B09BF 3E 18       0214*  	ld		a,24	;number of loops through.
0B09C1             0215*  udiv1:
0B09C1 C5          0216*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B09C2 E3          0217*  	ex		(sp),hl
0B09C3 37          0218*  	scf
0B09C4 ED 6A       0219*  	adc	hl,hl
0B09C6 E3          0220*  	ex	(sp),hl
0B09C7 C1          0221*  	pop	bc		;we now have bc = (bc * 2) + 1
0B09C8             0222*  
0B09C8 ED 6A       0223*  	adc	hl,hl
0B09CA A7          0224*  	and	a		;is this the bug
0B09CB ED 52       0225*  	sbc	hl,de
0B09CD 30 02       0226*  	jr	nc,udiv2
0B09CF 19          0227*  	add	hl,de
0B09D0             0228*  ;	dec	c
0B09D0 0B          0229*  	dec	bc
0B09D1             0230*  udiv2:
0B09D1 3D          0231*  	dec	a
0B09D2 20 ED       0232*  	jr	nz,udiv1
0B09D4 37          0233*  	scf		;flag used for div0 error
0B09D5 C5          0234*  	push	bc
0B09D6 D1          0235*  	pop		de	;remainder
0B09D7 C9          0236*  	ret
0B09D8             0237*  
0B09D8             0238*  
0B09D8             0239*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B09D8             0240*  ; perform unsigned division of 16.8 fixed place values
0B09D8             0241*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B09D8             0242*  udiv168:
0B09D8             0243*  ; back up divisor
0B09D8 ED 53 0F 0A 0244*  	ld (@ude),de
       0B          
0B09DD             0245*  ; get the 16-bit integer part of the quotient
0B09DD CD B4 09 0B 0246*      call udiv24 ; de = quotient, hl = remainder
0B09E1             0247*  ; load quotient to upper three bytes of output
0B09E1 ED 53 16 0A 0248*      ld (div168_out+1),de
       0B          
0B09E6             0249*  @div256:
0B09E6             0250*  ; multiply remainder by 256
0B09E6             0251*  	hlu_mul256
0B09E6 29          0001*M         add hl,hl ; * 2
0B09E7 29          0002*M         add hl,hl ; * 4
0B09E8 29          0003*M         add hl,hl ; * 8
0B09E9 29          0004*M         add hl,hl ; * 16
0B09EA 29          0005*M         add hl,hl ; * 32
0B09EB 29          0006*M         add hl,hl ; * 64
0B09EC 29          0007*M         add hl,hl ; * 128
0B09ED 29          0008*M         add hl,hl ; * 256
0B09EE             0252*  ; skip fractional computation if remainder is zero
0B09EE             0253*      sign_hlu
0B09EE 19          0001*M         add hl,de
0B09EF B7          0002*M         or a
0B09F0 ED 52       0003*M         sbc hl,de
0B09F2 20 03       0254*      jr nz,@div_frac
0B09F4 AF          0255*      xor a
0B09F5 18 0A       0256*      jr @write_frac
0B09F7             0257*  ; now divide the shifted remainder by the divisor
0B09F7             0258*  @div_frac:
0B09F7 ED 5B 0F 0A 0259*  	ld de,(@ude) ; get back divisor
       0B          
0B09FC CD B4 09 0B 0260*      call udiv24 ; de = quotient, hl = remainder
0B0A00             0261*  ; load low byte of quotient to low byte of output
0B0A00 7B          0262*      ld a,e
0B0A01             0263*  @write_frac:
0B0A01 32 15 0A 0B 0264*      ld (div168_out),a
0B0A05             0265*  ; load de with return value
0B0A05 ED 5B 15 0A 0266*      ld de,(div168_out)
       0B          
0B0A0A             0267*  ; load a with any overflow
0B0A0A 3A 18 0A 0B 0268*      ld a,(div168_out+3)
0B0A0E C9          0269*      ret ; ud.e is the 16.8 result
0B0A0F             0270*  @ude: ds 6
0B0A15             0271*  div168_out: ds 4 ; the extra byte is for overflow
0B0A19             0272*  
0B0A19             0273*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B0A19             0274*  ; perform signed division of 16.8 fixed place values
0B0A19             0275*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B0A19             0276*  sdiv168:
0B0A19             0277*  ; make everything positive and store sign flags
0B0A19 CD DA 07 0B 0278*  	call abs_hlu
0B0A1D F5          0279*  	push af
0B0A1E EB          0280*  	ex de,hl
0B0A1F CD DA 07 0B 0281*  	call abs_hlu
0B0A23 EB          0282*  	ex de,hl
0B0A24 F5          0283*  	push af
0B0A25             0284*  ; do the division
0B0A25 CD D8 09 0B 0285*      call udiv168 ; de = quotient, hl = remainder
0B0A29             0286*  ; adjust sign of result
0B0A29 F1          0287*  	pop af ; sign de
0B0A2A FA 37 0A 0B 0288*  	jp m,@de_neg
0B0A2E F1          0289*  	pop af ; sign hl
0B0A2F F0          0290*  	ret p ; both positive, nothing to do
0B0A30             0291*  @hl_neg:
0B0A30 EB          0292*      ex de,hl ; hl = quotient, de = remainder
0B0A31 CD EA 07 0B 0293*      call neg_hlu ; de pos, hl neg, result is negative
0B0A35 EB          0294*      ex de,hl ; de = negated quotient, hl = remainder
0B0A36 C9          0295*      ret
0B0A37             0296*  @de_neg:
0B0A37 F1          0297*  	pop af
0B0A38 F8          0298*  	ret m ; both negative, nothing to do
0B0A39 EB          0299*      ex de,hl ; hl = quotient, de = remainder
0B0A3A CD EA 07 0B 0300*  	call neg_hlu ; result is negative
0B0A3E EB          0301*      ex de,hl ; de = negated quotient, hl = remainder
0B0A3F C9          0302*  	ret
0B0A40             0303*  
0B0A40             0304*  ;------------------------------------------------------------------------
0B0A40             0305*  ; neg24
0B0A40             0306*  ; Returns: HLU = 0-HLU
0B0A40             0307*  ; preserves all other registers
0B0A40             0308*  ;------------------------------------------------------------------------
0B0A40             0309*  neg24:
0B0A40 D5          0310*  	push	de
0B0A41 EB          0311*  	ex		de,hl
0B0A42 21 00 00 00 0312*  	ld		hl,0
0B0A46 B7          0313*  	or		a
0B0A47 ED 52       0314*  	sbc		hl,de
0B0A49 D1          0315*  	pop		de
0B0A4A C9          0316*  	ret
0B0A4B             0317*  
0B0A4B             0318*  ;------------------------------------------------------------------------
0B0A4B             0319*  ; or_hlu_deu: 24 bit bitwise OR
0B0A4B             0320*  ; Returns: hlu = hlu OR deu
0B0A4B             0321*  ; preserves all other registers
0B0A4B             0322*  ;------------------------------------------------------------------------
0B0A4B             0323*  or_hlu_deu:
0B0A4B 22 D6 0A 0B 0324*  	ld	(bitbuf1),hl
0B0A4F ED 53 D9 0A 0325*  	ld	(bitbuf2),de
       0B          
0B0A54 D5          0326*  	push	de	;preserve DEU
0B0A55 C5          0327*  	push	bc	;preserve BCU
0B0A56 06 03       0328*  	ld		b,3
0B0A58 21 D6 0A 0B 0329*  	ld	hl,bitbuf1
0B0A5C 11 D6 0A 0B 0330*  	ld	de,bitbuf1
0B0A60             0331*  orloop_24:
0B0A60 1A          0332*  	ld	a,(de)
0B0A61 B6          0333*  	or	(hl)
0B0A62 12          0334*  	ld	(de),a
0B0A63 13          0335*  	inc	de
0B0A64 23          0336*  	inc	hl
0B0A65 10 F9       0337*  	djnz	orloop_24
0B0A67 2A D9 0A 0B 0338*  	ld	hl,(bitbuf2)
0B0A6B C1          0339*  	pop		bc	;restore BC
0B0A6C D1          0340*  	pop		de	;restore DE
0B0A6D             0341*  
0B0A6D             0342*  ;------------------------------------------------------------------------
0B0A6D             0343*  ; and_hlu_deu: 24 bit bitwise AND
0B0A6D             0344*  ; Returns: hlu = hlu AND deu
0B0A6D             0345*  ; preserves all other registers
0B0A6D             0346*  ;------------------------------------------------------------------------
0B0A6D             0347*  and_hlu_deu:
0B0A6D 22 D6 0A 0B 0348*  	ld	(bitbuf1),hl
0B0A71 ED 53 D9 0A 0349*  	ld	(bitbuf2),de
       0B          
0B0A76 D5          0350*  	push	de	;preserve DEU
0B0A77 C5          0351*  	push	bc	;preserve BCU
0B0A78 06 03       0352*  	ld		b,3
0B0A7A 21 D6 0A 0B 0353*  	ld	hl,bitbuf1
0B0A7E 11 D6 0A 0B 0354*  	ld	de,bitbuf1
0B0A82             0355*  andloop_24:
0B0A82 1A          0356*  	ld	a,(de)
0B0A83 A6          0357*  	and	(hl)
0B0A84 12          0358*  	ld	(de),a
0B0A85 13          0359*  	inc	de
0B0A86 23          0360*  	inc	hl
0B0A87 10 F9       0361*  	djnz	andloop_24
0B0A89 2A D9 0A 0B 0362*  	ld	hl,(bitbuf2)
0B0A8D C1          0363*  	pop		bc	;restore BC
0B0A8E D1          0364*  	pop		de	;restore DE
0B0A8F             0365*  
0B0A8F             0366*  ;------------------------------------------------------------------------
0B0A8F             0367*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0A8F             0368*  ; Returns: hlu = hlu XOR deu
0B0A8F             0369*  ; preserves all other registers
0B0A8F             0370*  ;------------------------------------------------------------------------
0B0A8F             0371*  xor_hlu_deu:
0B0A8F 22 D6 0A 0B 0372*  	ld	(bitbuf1),hl
0B0A93 ED 53 D9 0A 0373*  	ld	(bitbuf2),de
       0B          
0B0A98 D5          0374*  	push	de	;preserve DEU
0B0A99 C5          0375*  	push	bc	;preserve BCU
0B0A9A 06 03       0376*  	ld		b,3
0B0A9C 21 D6 0A 0B 0377*  	ld	hl,bitbuf1
0B0AA0 11 D6 0A 0B 0378*  	ld	de,bitbuf1
0B0AA4             0379*  xorloop_24:
0B0AA4 1A          0380*  	ld	a,(de)
0B0AA5 AE          0381*  	xor	(hl)
0B0AA6 12          0382*  	ld	(de),a
0B0AA7 13          0383*  	inc	de
0B0AA8 23          0384*  	inc	hl
0B0AA9 10 F9       0385*  	djnz	xorloop_24
0B0AAB 2A D9 0A 0B 0386*  	ld	hl,(bitbuf2)
0B0AAF C1          0387*  	pop		bc	;restore BC
0B0AB0 D1          0388*  	pop		de	;restore DE
0B0AB1             0389*  
0B0AB1             0390*  ;------------------------------------------------------------------------
0B0AB1             0391*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B0AB1             0392*  ; Returns: hlu = hlu << deu
0B0AB1             0393*  ;		   de = 0
0B0AB1             0394*  ; NOTE: only considers deu up to 16 bits.
0B0AB1             0395*  ; preserves all other registers
0B0AB1             0396*  ;------------------------------------------------------------------------
0B0AB1             0397*  shl_hlu:
0B0AB1 7A          0398*  	ld		a,d		;up to 16 bit.
0B0AB2 B3          0399*  	or		e
0B0AB3 C8          0400*  	ret		z		;we're done
0B0AB4 29          0401*  	add		hl,hl	;shift HLU left
0B0AB5 1B          0402*  	dec		de
0B0AB6 18 F9       0403*  	jr		shl_hlu
0B0AB8             0404*  
0B0AB8             0405*  ;------------------------------------------------------------------------
0B0AB8             0406*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B0AB8             0407*  ; Returns: hlu = hlu >> deu
0B0AB8             0408*  ;		   de = 0
0B0AB8             0409*  ; NOTE: only considers deu up to 16 bits.
0B0AB8             0410*  ; preserves all other registers
0B0AB8             0411*  ;------------------------------------------------------------------------
0B0AB8             0412*  shr_hlu:
0B0AB8 22 D6 0A 0B 0413*  	ld		(bitbuf1),hl
0B0ABC 21 D8 0A 0B 0414*  	ld		hl,bitbuf1+2
0B0AC0             0415*  shr_loop:
0B0AC0 7A          0416*  	ld		a,d		;up to 16 bit.
0B0AC1 B3          0417*  	or		e
0B0AC2 28 0D       0418*  	jr		z,shr_done		;we're done
0B0AC4             0419*  ;carry is clear from or instruction
0B0AC4 CB 1E       0420*  	rr		(hl)
0B0AC6 2B          0421*  	dec		hl
0B0AC7 CB 1E       0422*  	rr		(hl)
0B0AC9 2B          0423*  	dec		hl
0B0ACA CB 1E       0424*  	rr		(hl)
0B0ACC 23          0425*  	inc		hl
0B0ACD 23          0426*  	inc		hl
0B0ACE 1B          0427*  	dec		de
0B0ACF 18 EF       0428*  	jr		shr_loop
0B0AD1             0429*  shr_done:
0B0AD1 2A D6 0A 0B 0430*  	ld		hl,(bitbuf1)	;collect result
0B0AD5 C9          0431*  	ret
0B0AD6             0432*  
0B0AD6             0433*  ;------------------------------------------------------------------------
0B0AD6             0434*  ; Scratch area for calculations
0B0AD6             0435*  ;------------------------------------------------------------------------
0B0AD6 00 00 00    0436*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B0AD9 00 00 00    0437*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0ADC             0438*  
0B0ADC             0439*  ; ========== FROM maths24.inc ==========
0B0ADC             0440*  
0B0ADC             0441*  ; Expects  ADL mode
0B0ADC             0442*  ; Inputs:  UH.L
0B0ADC             0443*  ; Outputs: UH.L is the 16.8 square root
0B0ADC             0444*  ;          UD.E is the difference inputHL-DE^2
0B0ADC             0445*  ;          c flag reset
0B0ADC             0446*  sqrt168:
0B0ADC CD E6 0A 0B 0447*      call sqrt24
0B0AE0 EB          0448*      ex de,hl
0B0AE1 29          0449*      add hl,hl
0B0AE2 29          0450*      add hl,hl
0B0AE3 29          0451*      add hl,hl
0B0AE4 29          0452*      add hl,hl
0B0AE5 C9          0453*      ret
0B0AE6             0454*  
0B0AE6             0455*  ; Expects  ADL mode
0B0AE6             0456*  ; Inputs:  HL
0B0AE6             0457*  ; Outputs: DE is the integer square root
0B0AE6             0458*  ;          HL is the difference inputHL-DE^2
0B0AE6             0459*  ;          c flag reset
0B0AE6             0460*  sqrt24:
0B0AE6 AF          0461*      xor a
0B0AE7 45          0462*      ld b,l
0B0AE8 C5          0463*      push bc
0B0AE9 47          0464*      ld b,a
0B0AEA 57          0465*      ld d,a
0B0AEB 4F          0466*      ld c,a
0B0AEC 6F          0467*      ld l,a
0B0AED 5F          0468*      ld e,a
0B0AEE             0469*  
0B0AEE             0470*      ;Iteration 1
0B0AEE 29          0471*      add hl,hl
0B0AEF CB 11       0472*      rl c
0B0AF1 29          0473*      add hl,hl
0B0AF2 CB 11       0474*      rl c
0B0AF4 91          0475*      sub c
0B0AF5 30 04       0476*      jr nc,$+6
0B0AF7 1C          0477*      inc e
0B0AF8 1C          0478*      inc e
0B0AF9 2F          0479*      cpl
0B0AFA 4F          0480*      ld c,a
0B0AFB             0481*  
0B0AFB             0482*      ;Iteration 2
0B0AFB 29          0483*      add hl,hl
0B0AFC CB 11       0484*      rl c
0B0AFE 29          0485*      add hl,hl
0B0AFF CB 11       0486*      rl c
0B0B01 CB 13       0487*      rl e
0B0B03 7B          0488*      ld a,e
0B0B04 91          0489*      sub c
0B0B05 30 04       0490*      jr nc,$+6
0B0B07 1C          0491*      inc e
0B0B08 1C          0492*      inc e
0B0B09 2F          0493*      cpl
0B0B0A 4F          0494*      ld c,a
0B0B0B             0495*  
0B0B0B             0496*      ;Iteration 3
0B0B0B 29          0497*      add hl,hl
0B0B0C CB 11       0498*      rl c
0B0B0E 29          0499*      add hl,hl
0B0B0F CB 11       0500*      rl c
0B0B11 CB 13       0501*      rl e
0B0B13 7B          0502*      ld a,e
0B0B14 91          0503*      sub c
0B0B15 30 04       0504*      jr nc,$+6
0B0B17 1C          0505*      inc e
0B0B18 1C          0506*      inc e
0B0B19 2F          0507*      cpl
0B0B1A 4F          0508*      ld c,a
0B0B1B             0509*  
0B0B1B             0510*      ;Iteration 4
0B0B1B 29          0511*      add hl,hl
0B0B1C CB 11       0512*      rl c
0B0B1E 29          0513*      add hl,hl
0B0B1F CB 11       0514*      rl c
0B0B21 CB 13       0515*      rl e
0B0B23 7B          0516*      ld a,e
0B0B24 91          0517*      sub c
0B0B25 30 04       0518*      jr nc,$+6
0B0B27 1C          0519*      inc e
0B0B28 1C          0520*      inc e
0B0B29 2F          0521*      cpl
0B0B2A 4F          0522*      ld c,a
0B0B2B             0523*  
0B0B2B             0524*      ;Iteration 5
0B0B2B 29          0525*      add hl,hl
0B0B2C CB 11       0526*      rl c
0B0B2E 29          0527*      add hl,hl
0B0B2F CB 11       0528*      rl c
0B0B31 CB 13       0529*      rl e
0B0B33 7B          0530*      ld a,e
0B0B34 91          0531*      sub c
0B0B35 30 04       0532*      jr nc,$+6
0B0B37 1C          0533*      inc e
0B0B38 1C          0534*      inc e
0B0B39 2F          0535*      cpl
0B0B3A 4F          0536*      ld c,a
0B0B3B             0537*  
0B0B3B             0538*      ;Iteration 6
0B0B3B 29          0539*      add hl,hl
0B0B3C CB 11       0540*      rl c
0B0B3E 29          0541*      add hl,hl
0B0B3F CB 11       0542*      rl c
0B0B41 CB 13       0543*      rl e
0B0B43 7B          0544*      ld a,e
0B0B44 91          0545*      sub c
0B0B45 30 04       0546*      jr nc,$+6
0B0B47 1C          0547*      inc e
0B0B48 1C          0548*      inc e
0B0B49 2F          0549*      cpl
0B0B4A 4F          0550*      ld c,a
0B0B4B             0551*  
0B0B4B             0552*      ;Iteration 7
0B0B4B 29          0553*      add hl,hl
0B0B4C CB 11       0554*      rl c
0B0B4E 29          0555*      add hl,hl
0B0B4F CB 11       0556*      rl c
0B0B51 CB 10       0557*      rl b
0B0B53 EB          0558*      ex de,hl
0B0B54 29          0559*      add hl,hl
0B0B55 E5          0560*      push hl
0B0B56 ED 42       0561*      sbc hl,bc
0B0B58 30 06       0562*      jr nc,$+8
0B0B5A 7C          0563*      ld a,h
0B0B5B 2F          0564*      cpl
0B0B5C 47          0565*      ld b,a
0B0B5D 7D          0566*      ld a,l
0B0B5E 2F          0567*      cpl
0B0B5F 4F          0568*      ld c,a
0B0B60 E1          0569*      pop hl
0B0B61 30 02       0570*      jr nc,$+4
0B0B63 23          0571*      inc hl
0B0B64 23          0572*      inc hl
0B0B65 EB          0573*      ex de,hl
0B0B66             0574*  
0B0B66             0575*      ;Iteration 8
0B0B66 29          0576*      add hl,hl
0B0B67 69          0577*      ld l,c
0B0B68 60          0578*      ld h,b
0B0B69 ED 6A       0579*      adc hl,hl
0B0B6B ED 6A       0580*      adc hl,hl
0B0B6D EB          0581*      ex de,hl
0B0B6E 29          0582*      add hl,hl
0B0B6F ED 52       0583*      sbc hl,de
0B0B71 19          0584*      add hl,de
0B0B72 EB          0585*      ex de,hl
0B0B73 30 04       0586*      jr nc,$+6
0B0B75 ED 52       0587*      sbc hl,de
0B0B77 13          0588*      inc de
0B0B78 13          0589*      inc de
0B0B79             0590*  
0B0B79             0591*      ;Iteration 9
0B0B79 F1          0592*      pop af
0B0B7A 17          0593*      rla
0B0B7B ED 6A       0594*      adc hl,hl
0B0B7D 17          0595*      rla
0B0B7E ED 6A       0596*      adc hl,hl
0B0B80 EB          0597*      ex de,hl
0B0B81 29          0598*      add hl,hl
0B0B82 ED 52       0599*      sbc hl,de
0B0B84 19          0600*      add hl,de
0B0B85 EB          0601*      ex de,hl
0B0B86 30 04       0602*      jr nc,$+6
0B0B88 ED 52       0603*      sbc hl,de
0B0B8A 13          0604*      inc de
0B0B8B 13          0605*      inc de
0B0B8C             0606*  
0B0B8C             0607*      ;Iteration 10
0B0B8C 17          0608*      rla
0B0B8D ED 6A       0609*      adc hl,hl
0B0B8F 17          0610*      rla
0B0B90 ED 6A       0611*      adc hl,hl
0B0B92 EB          0612*      ex de,hl
0B0B93 29          0613*      add hl,hl
0B0B94 ED 52       0614*      sbc hl,de
0B0B96 19          0615*      add hl,de
0B0B97 EB          0616*      ex de,hl
0B0B98 30 04       0617*      jr nc,$+6
0B0B9A ED 52       0618*      sbc hl,de
0B0B9C 13          0619*      inc de
0B0B9D 13          0620*      inc de
0B0B9E             0621*  
0B0B9E             0622*      ;Iteration 11
0B0B9E 17          0623*      rla
0B0B9F ED 6A       0624*      adc hl,hl
0B0BA1 17          0625*      rla
0B0BA2 ED 6A       0626*      adc hl,hl
0B0BA4 EB          0627*      ex de,hl
0B0BA5 29          0628*      add hl,hl
0B0BA6 ED 52       0629*      sbc hl,de
0B0BA8 19          0630*      add hl,de
0B0BA9 EB          0631*      ex de,hl
0B0BAA 30 04       0632*      jr nc,$+6
0B0BAC ED 52       0633*      sbc hl,de
0B0BAE 13          0634*      inc de
0B0BAF 13          0635*      inc de
0B0BB0             0636*  
0B0BB0             0637*      ;Iteration 11
0B0BB0 17          0638*      rla
0B0BB1 ED 6A       0639*      adc hl,hl
0B0BB3 17          0640*      rla
0B0BB4 ED 6A       0641*      adc hl,hl
0B0BB6 EB          0642*      ex de,hl
0B0BB7 29          0643*      add hl,hl
0B0BB8 ED 52       0644*      sbc hl,de
0B0BBA 19          0645*      add hl,de
0B0BBB EB          0646*      ex de,hl
0B0BBC 30 04       0647*      jr nc,$+6
0B0BBE ED 52       0648*      sbc hl,de
0B0BC0 13          0649*      inc de
0B0BC1 13          0650*      inc de
0B0BC2             0651*  
0B0BC2 CB 1A       0652*      rr d
0B0BC4 CB 1B       0653*      rr e
0B0BC6 C9          0654*      ret
0B0BC7             0022       include "trig24.inc"
0B0BC7             0001*  
0B0BC7             0002*  ; convert signed angles from a 360 to 256 degree circle
0B0BC7             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0BC7             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0BC7             0005*  ; destroys: TODO
0B0BC7             0006*  deg_360_to_256:
0B0BC7 D5          0007*  	push de ; preserve de
0B0BC8             0008*  ; make angle positive and store sign flag
0B0BC8 CD DA 07 0B 0009*  	call abs_hlu
0B0BCC F5          0010*  	push af
0B0BCD             0011*  ; multiply by 256 first to keep precision
0B0BCD             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0B0BCD 29          0001*M         add hl,hl ; * 2
0B0BCE 29          0002*M         add hl,hl ; * 4
0B0BCF 29          0003*M         add hl,hl ; * 8
0B0BD0 29          0004*M         add hl,hl ; * 16
0B0BD1 29          0005*M         add hl,hl ; * 32
0B0BD2 29          0006*M         add hl,hl ; * 64
0B0BD3 29          0007*M         add hl,hl ; * 128
0B0BD4 29          0008*M         add hl,hl ; * 256
0B0BD5             0013*  ; divide uh.l by 360
0B0BD5 11 68 01 00 0014*  	ld de,360
0B0BD9 CD B4 09 0B 0015*  	call udiv24 ; ud.e = degrees / 360
0B0BDD EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0B0BDE             0017*  ; restore sign flag and adjust output accordingly
0B0BDE F1          0018*  	pop af
0B0BDF F2 E7 0B 0B 0019*  	jp p,@pos ; positive number
0B0BE3 CD EA 07 0B 0020*  	call neg_hlu
0B0BE7             0021*  @pos:
0B0BE7             0022*  ; restore de and return uh.l as the result
0B0BE7 D1          0023*  	pop de
0B0BE8 C9          0024*  	ret
0B0BE9             0025*  
0B0BE9             0026*  ; fixed 16.8 routine
0B0BE9             0027*  ; cos(uh.l) --> uh.l
0B0BE9             0028*  ; destroys: de
0B0BE9             0029*  cos168:
0B0BE9             0030*  ; for cos we simply increment the angle by 90 degrees
0B0BE9             0031*  ; or 0x004000 in 16.8 degrees256
0B0BE9             0032*  ; which makes it a sin problem
0B0BE9 11 00 40 00 0033*      ld de,0x004000
0B0BED 19          0034*      add hl,de ; modulo 256 happens below
0B0BEE             0035*  ; fall through to sin168
0B0BEE             0036*  
0B0BEE             0037*  ; ---------------------
0B0BEE             0038*  ; fixed 16.8 routine
0B0BEE             0039*  ; sin(uh.l) --> uh.l
0B0BEE             0040*  ; destroys: de
0B0BEE             0041*  sin168:
0B0BEE CD 88 02 0B 0042*  	call printNewLine
0B0BF2             0043*  ; get the lookup value for the integer portion of the angle
0B0BF2 7D          0044*  	ld a,l ; save fractional part of the angle
0B0BF3 2E 03       0045*  	ld l,3 ; multiply by 3 to get our lookup index
0B0BF5 ED 6C       0046*  	mlt hl ; gosh that is handy
0B0BF7 11 59 0D 0B 0047*      ld de,sin_lut_168 ; grab the lut address
0B0BFB 19          0048*      add hl,de ; bump hl by the index
0B0BFC E5          0049*  	push hl
0B0BFD D1          0050*  	pop de ; de also has the lut address
0B0BFE ED 27       0051*      ld hl,(hl) ; hl = sin(int(angle))
0B0C00             0052*  
0B0C00             0053*  ; interpolate the fractional part of the angle
0B0C00 B7          0054*  	or a  ; check for zero and clear carry
0B0C01 C8          0055*  	ret z ; return if no fractional part
0B0C02 EB          0056*  	ex de,hl ; hl = lut address, de = sin(int(angle))
0B0C03 23          0057*  	inc hl
0B0C04 23          0058*  	inc hl
0B0C05 23          0059*  	inc hl ; hl = lut address of next value in table
0B0C06 ED 27       0060*  	ld hl,(hl) ; hl = sin(int(angle+1))
0B0C08 ED 52       0061*  	sbc hl,de ; hl = sin(int(angle+1)0 - sin(int(angle)), de = sin(int(angle))
0B0C0A CD D3 08 0B 0062*  	call smul24x8 ; hl = interpolation factor * (sin(int(angle+1)) - sin(int(angle))) * 256
0B0C0E CD 26 08 0B 0063*  	call hlu_sdiv256 ; hl = interpolation factor * (sin(int(angle+1)) - sin(int(angle)))
0B0C12 19          0064*  	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle)))
0B0C13 C9          0065*      ret ; and out
0B0C14             0066*  
0B0C14             0067*  ; ; 16.8 fixed inputs / outputs
0B0C14             0068*  ; ; takes: uh.l as angle in degrees 256
0B0C14             0069*  ; ;        ud.e as radius
0B0C14             0070*  ; ; returns ub.c as dx, ud.e as dy
0B0C14             0071*  ; ;        displacements from origin (0,0)
0B0C14             0072*  ; ; destroys: everything except indexes
0B0C14             0073*  ; polar_to_cartesian:
0B0C14             0074*  ; ; back up input parameters
0B0C14             0075*  ;     ld (arith24uhl), hl
0B0C14             0076*  ;     ld (arith24ude), de
0B0C14             0077*  ; ; compute dx = sin(uh.l) * ud.e
0B0C14             0078*  ;     call sin168
0B0C14             0079*  ;     push hl
0B0C14             0080*  ;     pop bc          ; ub.c = sin(uh.l)
0B0C14             0081*  ; 	ld de, (arith24ude)   ; get radius back
0B0C14             0082*  ; 	call smul168    ; uh.l = ub.c * ud.e = dx
0B0C14             0083*  ;     push hl         ; store dx for output
0B0C14             0084*  ; ; compute dy = -cos(uh.l) * ud.e
0B0C14             0085*  ;     ld hl, (arith24uhl)
0B0C14             0086*  ;     call cos168
0B0C14             0087*  ; 	call neg_hlu    ; invert dy for screen coords convention
0B0C14             0088*  ;     push hl
0B0C14             0089*  ;     pop bc          ; ub.c = -cos(uh.l)
0B0C14             0090*  ;     ld de, (arith24ude)   ; get radius back
0B0C14             0091*  ;     call smul168    ; uh.l = ub.c * ud.e = dy
0B0C14             0092*  ;     ex de, hl       ; de = dy for output
0B0C14             0093*  ;     pop bc          ; bc = dx for output
0B0C14             0094*  ; ; and out
0B0C14             0095*  ;     ret
0B0C14             0096*  
0B0C14             0097*  ; 16.8 fixed inputs / outputs
0B0C14             0098*  ; takes: uh.l as angle in degrees 256
0B0C14             0099*  ;        ud.e as radius
0B0C14             0100*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B0C14             0101*  ;        displacements from origin (0,0)
0B0C14             0102*  ; destroys: everything except indexes
0B0C14             0103*  polar_to_cartesian:
0B0C14             0104*  ; back up input parameters
0B0C14 22 3F 0C 0B 0105*      ld (@angle), hl
0B0C18 ED 53 42 0C 0106*      ld (@radius), de
       0B          
0B0C1D             0107*  ; compute dx = cos(uh.l) * ud.e
0B0C1D CD E9 0B 0B 0108*      call cos168 ; uh.l = cos(uh.l)
0B0C21 ED 5B 42 0C 0109*  	ld de,(@radius)
       0B          
0B0C26 CD 78 09 0B 0110*  	call smul168 ; uh.l = dx
0B0C2A E5          0111*      push hl
0B0C2B             0112*  ; compute dy = sin(uh.l) * ud.e
0B0C2B 2A 3F 0C 0B 0113*      ld hl,(@angle)
0B0C2F CD EE 0B 0B 0114*      call sin168 ; uh.l = sin(uh.l)
0B0C33 ED 5B 42 0C 0115*      ld de,(@radius)
       0B          
0B0C38 CD 78 09 0B 0116*      call smul168    ; uh.l = dy
0B0C3C EB          0117*      ex de,hl       ; de = dy for output
0B0C3D C1          0118*      pop bc          ; bc = dx for output
0B0C3E             0119*  ; and out
0B0C3E C9          0120*      ret
0B0C3F             0121*  @angle: ds 3
0B0C42             0122*  @radius: ds 3
0B0C45             0123*  
0B0C45             0124*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0C45             0125*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0C45             0126*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0C45             0127*  ;         also populates scratch locations dx168 and dy168
0B0C45             0128*  ; destroys: a,hl,bc,de
0B0C45             0129*  dxy168:
0B0C45             0130*  ; compute dx = x1-x0
0B0C45 AF          0131*      xor a ; clear carry
0B0C46 DD E5       0132*      push ix ; move ix to hl via the stack
0B0C48 E1          0133*      pop hl ; hl = x1
0B0C49 ED 42       0134*      sbc hl,bc ; hl = dx
0B0C4B 22 A0 0C 0B 0135*      ld (dx168),hl ; dx to scratch
0B0C4F             0136*  ; compute dy = y1-y0
0B0C4F AF          0137*      xor a ; clear carry
0B0C50 FD E5       0138*      push iy ; move iy to hl via the stack
0B0C52 E1          0139*      pop hl ; hl = y1
0B0C53 ED 52       0140*      sbc hl,de ; hl = dy
0B0C55 22 A6 0C 0B 0141*      ld (dy168),hl ; dy to scratch
0B0C59             0142*  ; populate output registers and return
0B0C59 EB          0143*      ex de,hl        ; ud.e = dy
0B0C5A ED 4B A0 0C 0144*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0C5F C9          0145*      ret
0B0C60             0146*  
0B0C60             0147*  ; compute the euclidian distance between two cartesian coordinates
0B0C60             0148*  ; using the formula d = sqrt(dx^2+dy^2
0B0C60             0149*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0C60             0150*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0C60             0151*  ; output; uh.l is the 16.8 fixed format distance
0B0C60             0152*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0C60             0153*  ; destroys: a,hl,bc,de
0B0C60             0154*  distance168:
0B0C60             0155*  ; compute dx = x1-x0
0B0C60 AF          0156*      xor a ; clear carry
0B0C61 DD E5       0157*      push ix ; move ix to hl via the stack
0B0C63 E1          0158*      pop hl ; hl = x1
0B0C64 ED 42       0159*      sbc hl,bc ; hl = dx
0B0C66 22 A0 0C 0B 0160*      ld (dx168),hl ; dx to scratch
0B0C6A             0161*  ; ; test dx for overflow
0B0C6A             0162*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0C6A             0163*  ; 	ex de,hl
0B0C6A             0164*  ; 	sbc hl,de ; test for overflow
0B0C6A             0165*  ; 	push af ; carry indicates overflow
0B0C6A             0166*  ; compute dy = y1-y0
0B0C6A AF          0167*      xor a ; clear carry
0B0C6B FD E5       0168*      push iy ; move iy to hl via the stack
0B0C6D E1          0169*      pop hl ; hl = y1
0B0C6E ED 52       0170*      sbc hl,de ; hl = dy
0B0C70 22 A6 0C 0B 0171*      ld (dy168),hl ; dy to scratch
0B0C74             0172*  ; ; test dy for overflow
0B0C74             0173*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0C74             0174*  ; 	ex de,hl
0B0C74             0175*  ; 	sbc hl,de ; test for overflow
0B0C74             0176*  ; 	push af ; carry indicates overflow
0B0C74             0177*  ; compute dy^2
0B0C74 2A A6 0C 0B 0178*  	ld hl,(dy168)
0B0C78 CD DA 07 0B 0179*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B0C7C             0180*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0C7C E5          0181*      push hl ; load hl/2 to bc via the stack
0B0C7D C1          0182*      pop bc ; bc = dy/2
0B0C7E EB          0183*      ex de,hl ; de = dy/2
0B0C7F CD 70 09 0B 0184*      call umul168 ; uh.l = dy^2/2
0B0C83 E5          0185*      push hl ; dy^2/2 to the stack
0B0C84             0186*  ; compute dx^2
0B0C84 2A A0 0C 0B 0187*      ld hl,(dx168) ; get back dx
0B0C88 CD DA 07 0B 0188*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B0C8C             0189*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0C8C E5          0190*      push hl ; load hl/2 to bc via the stack
0B0C8D C1          0191*      pop bc ; bc = dx/2
0B0C8E EB          0192*      ex de,hl ; de = dx/2
0B0C8F CD 70 09 0B 0193*      call umul168 ; uh.l = dx^2/2
0B0C93             0194*  ; commpute dy^2+dx^2
0B0C93 D1          0195*      pop de ; get back dx^2/2
0B0C94 19          0196*      add hl,de ; hl = dx^2/2+dy^2/2
0B0C95             0197*  ; compute sqrt(dx^2/2+dy^2/2)
0B0C95 CD DC 0A 0B 0198*      call sqrt168 ; uh.l = distance/2
0B0C99             0199*      ; add hl,hl ; hl = distance
0B0C99             0200*  ; ; check for overflow
0B0C99             0201*  ; 	pop af ; get back the overflow flags
0B0C99             0202*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0C99             0203*  ; 	ld b,a ; save the overflow flag
0B0C99             0204*  ; 	pop af ; get back the overflow flags
0B0C99             0205*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0C99             0206*  ; 	add a,b ; if a != 0 then we had overflow
0B0C99             0207*  ;     ret z ; no overflow we're done
0B0C99             0208*  ; @overflow:
0B0C99             0209*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0C99 C9          0210*  	ret
0B0C9A             0211*  @scratch: ds 6
0B0CA0             0212*  dx168: ds 6
0B0CA6             0213*  dy168: ds 6
0B0CAC             0214*  
0B0CAC             0215*  ; atan2(ub.c,ud.e) --> uh.l
0B0CAC             0216*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0CAC             0217*  ;   whether inputs are integers or fractional doesn't matter
0B0CAC             0218*  ;   so long as the sign bit of the upper byte is correct
0B0CAC             0219*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0CAC             0220*  ; angles are COMPASS HEADINGS based on
0B0CAC             0221*  ; screen coordinate conventions,where the y axis is flipped
0B0CAC             0222*  ; #E0 315      0       45 #20
0B0CAC             0223*  ;        -x,-y | +x,-y
0B0CAC             0224*  ; #C0 270------+------ 90 #40
0B0CAC             0225*  ;        -x,+y | +x,+y
0B0CAC             0226*  ; #A0 225   180 #80   135 #60
0B0CAC             0227*  atan2_168game:
0B0CAC             0228*  ; get signs and make everything positive
0B0CAC             0229*  ; get abs(x) and store its original sign
0B0CAC C5          0230*      push bc
0B0CAD E1          0231*      pop hl
0B0CAE CD DA 07 0B 0232*      call abs_hlu ; if x was negative this also sets the sign flag
0B0CB2 E5          0233*      push hl ; store abs(x)
0B0CB3 C1          0234*      pop bc ; bc = abs(x)
0B0CB4 F5          0235*      push af ; store sign of x
0B0CB5             0236*  ; get abs(y) and store its original sign
0B0CB5 EB          0237*      ex de,hl ; hl = y
0B0CB6 CD DA 07 0B 0238*      call abs_hlu ; if y was negative this also sets the sign flag
0B0CBA EB          0239*      ex de,hl ; de = abs(y)
0B0CBB F5          0240*      push af ; store sign of y
0B0CBC             0241*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0CBC             0242*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B0CBC AF          0243*      xor a ; clear the carry flag
0B0CBD D5          0244*      push de
0B0CBE E1          0245*      pop hl
0B0CBF ED 42       0246*      sbc hl,bc
0B0CC1 F5          0247*      push af ; save sign of de - bc
0B0CC2 F2 CB 0C 0B 0248*      jp p,@1 ; bc <= de, so we skip ahead
0B0CC6             0249*  ; otherwise we swap bc and de
0B0CC6 C5          0250*      push bc
0B0CC7 E1          0251*      pop hl
0B0CC8 EB          0252*      ex de,hl
0B0CC9 E5          0253*      push hl
0B0CCA C1          0254*      pop bc
0B0CCB             0255*  @1:
0B0CCB             0256*  ; now we're ready to snag our preliminary result
0B0CCB CD 39 0D 0B 0257*      call atan_168game ; uh.l comes back with prelim result
0B0CCF             0258*  ; now we adjust uh.l based on sign of de - bc
0B0CCF F1          0259*      pop af
0B0CD0 F2 DC 0C 0B 0260*      jp p,@2 ; bc <= de,so we skip ahead
0B0CD4 EB          0261*      ex de,hl
0B0CD5 21 00 40 00 0262*      ld hl,0x004000 ; 90 degrees
0B0CD9 AF          0263*      xor a ; clear the carry flag
0B0CDA ED 52       0264*      sbc hl,de ; subtract result from 90 degrees
0B0CDC             0265*      ; ld de,0 ; prep to clear hlu
0B0CDC             0266*      ; ld d,h
0B0CDC             0267*      ; ld e,l
0B0CDC             0268*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0CDC             0269*      ; fall through
0B0CDC             0270*  @2:
0B0CDC             0271*  ; now the fun part of adjusting the result
0B0CDC             0272*  ; based on which quadrant (x,y) is in
0B0CDC             0273*  ; #E0 315      0       45 #20
0B0CDC             0274*  ;        -x,-y | +x,-y
0B0CDC             0275*  ; #C0 270------+------ 90 #40
0B0CDC             0276*  ;        -x,+y | +x,+y
0B0CDC             0277*  ; #A0 225   180 #80   135 #60
0B0CDC F1          0278*      pop af ; sign of y
0B0CDD CA 1A 0D 0B 0279*      jp z,@y_zero
0B0CE1 F2 FA 0C 0B 0280*      jp p,@y_pos
0B0CE5             0281*  ; y neg,check x
0B0CE5 F1          0282*      pop af ; sign of x
0B0CE6 CA F4 0C 0B 0283*      jp z,@y_neg_x_zero
0B0CEA F2 F9 0C 0B 0284*      jp p,@y_neg_x_pos
0B0CEE             0285*  ; y neg,x neg
0B0CEE             0286*  ; angle is 270-360
0B0CEE             0287*  ; negating the intermediate does the trick
0B0CEE CD EA 07 0B 0288*      call neg_hlu
0B0CF2 18 31       0289*      jr @zero_hlu
0B0CF4             0290*  
0B0CF4             0291*  @y_neg_x_zero:
0B0CF4             0292*  ; y neg,x zero
0B0CF4             0293*  ; angle is 0
0B0CF4 21 00 00 00 0294*      ld hl,0
0B0CF8 C9          0295*      ret
0B0CF9             0296*  @y_neg_x_pos:
0B0CF9             0297*  ; y neg,x pos
0B0CF9             0298*  ; angle is 0 to 90
0B0CF9             0299*  ; so we're good
0B0CF9 C9          0300*      ret
0B0CFA             0301*  
0B0CFA             0302*  @y_pos:
0B0CFA F1          0303*      pop af ; sign of x
0B0CFB CA 0A 0D 0B 0304*      jp z,@y_pos_x_zero
0B0CFF F2 0F 0D 0B 0305*      jp p,@y_pos_x_pos
0B0D03             0306*  ; y pos,x neg
0B0D03             0307*  ; angle is 180-270
0B0D03             0308*  ; so we add 180 to intermediate
0B0D03 11 00 80 00 0309*      ld de,0x008000
0B0D07 19          0310*      add hl,de
0B0D08 18 1B       0311*      jr @zero_hlu
0B0D0A             0312*  @y_pos_x_zero:
0B0D0A             0313*  ; y pos,x zero
0B0D0A             0314*  ; angle is 180
0B0D0A 21 00 80 00 0315*      ld hl,0x008000
0B0D0E C9          0316*      ret
0B0D0F             0317*  @y_pos_x_pos:
0B0D0F             0318*  ; y pos,x pos
0B0D0F             0319*  ; angle is 90-180
0B0D0F             0320*  ; neg the intermediate and add 180 degrees
0B0D0F CD EA 07 0B 0321*      call neg_hlu
0B0D13 11 00 80 00 0322*      ld de,0x008000
0B0D17 19          0323*      add hl,de
0B0D18 18 0B       0324*      jr @zero_hlu
0B0D1A             0325*  
0B0D1A             0326*  @y_zero:
0B0D1A F1          0327*      pop af ; sign of x
0B0D1B FA 20 0D 0B 0328*      jp m,@y_zero_x_neg
0B0D1F             0329*  ; y zero,x pos
0B0D1F             0330*  ; angle is 90,nothing to do
0B0D1F C9          0331*      ret
0B0D20             0332*  @y_zero_x_neg:
0B0D20             0333*  ; y zero ,x neg
0B0D20             0334*  ; angle is 270
0B0D20 21 00 C0 00 0335*      ld hl,0x00C000
0B0D24 C9          0336*      ret
0B0D25             0337*  @zero_hlu:
0B0D25 AF          0338*      xor a
0B0D26 22 33 0D 0B 0339*      ld (@scratch),hl
0B0D2A 32 35 0D 0B 0340*      ld (@scratch+2),a
0B0D2E 2A 33 0D 0B 0341*      ld hl,(@scratch)
0B0D32 C9          0342*      ret
0B0D33             0343*  @scratch: ds 6
0B0D39             0344*  
0B0D39             0345*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0D39             0346*  ; output: uh.l is the 16.8 fixed format angle
0B0D39             0347*  ; destroys: a,hl,bc,de
0B0D39             0348*  ; the following note was written by github copilot:
0B0D39             0349*  ; note: this routine is a bit of a hack
0B0D39             0350*  ;      but it works
0B0D39             0351*  ;      and it's fast
0B0D39             0352*  ;      and it's small
0B0D39             0353*  ;      and it's accurate
0B0D39             0354*  ;      and it's easy to understand
0B0D39             0355*  ;      and it's easy to modify
0B0D39             0356*  ;      and it's easy to use
0B0D39             0357*  ;      and it's easy to remember
0B0D39             0358*  ;      and it's easy to love
0B0D39             0359*  ;      and it's easy to hate
0B0D39             0360*  ;      and it's easy to ignore
0B0D39             0361*  ;      and it's easy to forget
0B0D39             0362*  ;      and it's easy to remember
0B0D39             0363*  ;      and it's easy to forget
0B0D39             0364*  ;      and it's easy to remember
0B0D39             0365*  ;      (ok the bot is stuck in a loop)
0B0D39             0366*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0D39             0367*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0D39             0368*  atan_168game:
0B0D39             0369*  ; because we use compass headings instead of geometric angles
0B0D39             0370*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0D39             0371*  ; we can do faster unsigned division here because we know dx and dy are positive
0B0D39 CD D8 09 0B 0372*  	call udiv168 ; uh.l = dx/dy
0B0D3D             0373*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0D3D             0374*  ; ; test uh.l for 0
0B0D3D             0375*  ;     add hl,de
0B0D3D             0376*  ;     or a
0B0D3D             0377*  ;     sbc hl,de
0B0D3D             0378*  ;     jr z,@is_zero
0B0D3D             0379*  ; ; test uh.l for 1
0B0D3D             0380*  ;     xor a ; clear carry
0B0D3D             0381*  ;     ex de,hl
0B0D3D             0382*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0D3D             0383*  ;     sbc hl,de
0B0D3D             0384*  ;     jr z,@is_45
0B0D3D             0385*  ; ; END TODO
0B0D3D             0386*  
0B0D3D             0387*  ; no special cases so we move on
0B0D3D             0388*  ; l contains the fractional portion of tan(uh.l)
0B0D3D             0389*  ; we multiply it by three to get our lookup table index
0B0D3D 26 03       0390*      ld h,3
0B0D3F ED 6C       0391*      mlt hl ; gosh that is handy
0B0D41 11 00 00 00 0392*      ld de,0 ; clear deu
0B0D45 54          0393*      ld d,h ; copy hl to de
0B0D46 5D          0394*      ld e,l ; de contains our index
0B0D47 21 5C 10 0B 0395*      ld hl,atan_lut_168 ; grab the lut address
0B0D4B 19          0396*      add hl,de ; bump hl by the index
0B0D4C ED 27       0397*      ld hl,(hl) ; don't try this on a z80!
0B0D4E C9          0398*      ret ; and out
0B0D4F             0399*  @is_45:
0B0D4F 21 00 20 00 0400*      ld hl,0x002000 ; 45 degrees decimal
0B0D53 C9          0401*      ret
0B0D54             0402*  ; for the case tan(0)
0B0D54             0403*  @is_zero:
0B0D54 21 00 00 00 0404*      ld hl,0x000000
0B0D58 C9          0405*      ret
0B0D59             0406*  
0B0D59             0407*  
0B0D59             0408*  sin_lut_168:
0B0D59 00 00 00    0409*  	dl 0x000000 ; 0.000 00, 0.000
0B0D5C 06 00 00    0410*  	dl 0x000006 ; 1.406 01, 0.025
0B0D5F 0C 00 00    0411*  	dl 0x00000C ; 2.813 02, 0.049
0B0D62 12 00 00    0412*  	dl 0x000012 ; 4.219 03, 0.074
0B0D65 19 00 00    0413*  	dl 0x000019 ; 5.625 04, 0.098
0B0D68 1F 00 00    0414*  	dl 0x00001F ; 7.031 05, 0.122
0B0D6B 25 00 00    0415*  	dl 0x000025 ; 8.438 06, 0.147
0B0D6E 2B 00 00    0416*  	dl 0x00002B ; 9.844 07, 0.171
0B0D71 31 00 00    0417*  	dl 0x000031 ; 11.250 08, 0.195
0B0D74 38 00 00    0418*  	dl 0x000038 ; 12.656 09, 0.219
0B0D77 3E 00 00    0419*  	dl 0x00003E ; 14.063 0A, 0.243
0B0D7A 44 00 00    0420*  	dl 0x000044 ; 15.469 0B, 0.267
0B0D7D 4A 00 00    0421*  	dl 0x00004A ; 16.875 0C, 0.290
0B0D80 50 00 00    0422*  	dl 0x000050 ; 18.281 0D, 0.314
0B0D83 56 00 00    0423*  	dl 0x000056 ; 19.688 0E, 0.337
0B0D86 5C 00 00    0424*  	dl 0x00005C ; 21.094 0F, 0.360
0B0D89 61 00 00    0425*  	dl 0x000061 ; 22.500 10, 0.383
0B0D8C 67 00 00    0426*  	dl 0x000067 ; 23.906 11, 0.405
0B0D8F 6D 00 00    0427*  	dl 0x00006D ; 25.313 12, 0.428
0B0D92 73 00 00    0428*  	dl 0x000073 ; 26.719 13, 0.450
0B0D95 78 00 00    0429*  	dl 0x000078 ; 28.125 14, 0.471
0B0D98 7E 00 00    0430*  	dl 0x00007E ; 29.531 15, 0.493
0B0D9B 83 00 00    0431*  	dl 0x000083 ; 30.938 16, 0.514
0B0D9E 88 00 00    0432*  	dl 0x000088 ; 32.344 17, 0.535
0B0DA1 8E 00 00    0433*  	dl 0x00008E ; 33.750 18, 0.556
0B0DA4 93 00 00    0434*  	dl 0x000093 ; 35.156 19, 0.576
0B0DA7 98 00 00    0435*  	dl 0x000098 ; 36.563 1A, 0.596
0B0DAA 9D 00 00    0436*  	dl 0x00009D ; 37.969 1B, 0.615
0B0DAD A2 00 00    0437*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0DB0 A7 00 00    0438*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0DB3 AB 00 00    0439*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0DB6 B0 00 00    0440*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B0DB9 B5 00 00    0441*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0DBC B9 00 00    0442*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0DBF BD 00 00    0443*  	dl 0x0000BD ; 47.813 22, 0.741
0B0DC2 C1 00 00    0444*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0DC5 C5 00 00    0445*  	dl 0x0000C5 ; 50.625 24, 0.773
0B0DC8 C9 00 00    0446*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0DCB CD 00 00    0447*  	dl 0x0000CD ; 53.438 26, 0.803
0B0DCE D1 00 00    0448*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0DD1 D4 00 00    0449*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0DD4 D8 00 00    0450*  	dl 0x0000D8 ; 57.656 29, 0.845
0B0DD7 DB 00 00    0451*  	dl 0x0000DB ; 59.063 2A, 0.858
0B0DDA DE 00 00    0452*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0DDD E1 00 00    0453*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0DE0 E4 00 00    0454*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0DE3 E7 00 00    0455*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B0DE6 EA 00 00    0456*  	dl 0x0000EA ; 66.094 2F, 0.914
0B0DE9 EC 00 00    0457*  	dl 0x0000EC ; 67.500 30, 0.924
0B0DEC EE 00 00    0458*  	dl 0x0000EE ; 68.906 31, 0.933
0B0DEF F1 00 00    0459*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0DF2 F3 00 00    0460*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0DF5 F4 00 00    0461*  	dl 0x0000F4 ; 73.125 34, 0.957
0B0DF8 F6 00 00    0462*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0DFB F8 00 00    0463*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0DFE F9 00 00    0464*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0E01 FB 00 00    0465*  	dl 0x0000FB ; 78.750 38, 0.981
0B0E04 FC 00 00    0466*  	dl 0x0000FC ; 80.156 39, 0.985
0B0E07 FD 00 00    0467*  	dl 0x0000FD ; 81.563 3A, 0.989
0B0E0A FE 00 00    0468*  	dl 0x0000FE ; 82.969 3B, 0.992
0B0E0D FE 00 00    0469*  	dl 0x0000FE ; 84.375 3C, 0.995
0B0E10 FF 00 00    0470*  	dl 0x0000FF ; 85.781 3D, 0.997
0B0E13 FF 00 00    0471*  	dl 0x0000FF ; 87.188 3E, 0.999
0B0E16 FF 00 00    0472*  	dl 0x0000FF ; 88.594 3F, 1.000
0B0E19 00 01 00    0473*  	dl 0x000100 ; 90.000 40, 1.000
0B0E1C FF 00 00    0474*  	dl 0x0000FF ; 91.406 41, 1.000
0B0E1F FF 00 00    0475*  	dl 0x0000FF ; 92.813 42, 0.999
0B0E22 FF 00 00    0476*  	dl 0x0000FF ; 94.219 43, 0.997
0B0E25 FE 00 00    0477*  	dl 0x0000FE ; 95.625 44, 0.995
0B0E28 FE 00 00    0478*  	dl 0x0000FE ; 97.031 45, 0.992
0B0E2B FD 00 00    0479*  	dl 0x0000FD ; 98.438 46, 0.989
0B0E2E FC 00 00    0480*  	dl 0x0000FC ; 99.844 47, 0.985
0B0E31 FB 00 00    0481*  	dl 0x0000FB ; 101.250 48, 0.981
0B0E34 F9 00 00    0482*  	dl 0x0000F9 ; 102.656 49, 0.976
0B0E37 F8 00 00    0483*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B0E3A F6 00 00    0484*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B0E3D F4 00 00    0485*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B0E40 F3 00 00    0486*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B0E43 F1 00 00    0487*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B0E46 EE 00 00    0488*  	dl 0x0000EE ; 111.094 4F, 0.933
0B0E49 EC 00 00    0489*  	dl 0x0000EC ; 112.500 50, 0.924
0B0E4C EA 00 00    0490*  	dl 0x0000EA ; 113.906 51, 0.914
0B0E4F E7 00 00    0491*  	dl 0x0000E7 ; 115.313 52, 0.904
0B0E52 E4 00 00    0492*  	dl 0x0000E4 ; 116.719 53, 0.893
0B0E55 E1 00 00    0493*  	dl 0x0000E1 ; 118.125 54, 0.882
0B0E58 DE 00 00    0494*  	dl 0x0000DE ; 119.531 55, 0.870
0B0E5B DB 00 00    0495*  	dl 0x0000DB ; 120.938 56, 0.858
0B0E5E D8 00 00    0496*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0E61 D4 00 00    0497*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0E64 D1 00 00    0498*  	dl 0x0000D1 ; 125.156 59, 0.818
0B0E67 CD 00 00    0499*  	dl 0x0000CD ; 126.563 5A, 0.803
0B0E6A C9 00 00    0500*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0E6D C5 00 00    0501*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0E70 C1 00 00    0502*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0E73 BD 00 00    0503*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0E76 B9 00 00    0504*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B0E79 B5 00 00    0505*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0E7C B0 00 00    0506*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0E7F AB 00 00    0507*  	dl 0x0000AB ; 137.813 62, 0.672
0B0E82 A7 00 00    0508*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0E85 A2 00 00    0509*  	dl 0x0000A2 ; 140.625 64, 0.634
0B0E88 9D 00 00    0510*  	dl 0x00009D ; 142.031 65, 0.615
0B0E8B 98 00 00    0511*  	dl 0x000098 ; 143.438 66, 0.596
0B0E8E 93 00 00    0512*  	dl 0x000093 ; 144.844 67, 0.576
0B0E91 8E 00 00    0513*  	dl 0x00008E ; 146.250 68, 0.556
0B0E94 88 00 00    0514*  	dl 0x000088 ; 147.656 69, 0.535
0B0E97 83 00 00    0515*  	dl 0x000083 ; 149.063 6A, 0.514
0B0E9A 7E 00 00    0516*  	dl 0x00007E ; 150.469 6B, 0.493
0B0E9D 78 00 00    0517*  	dl 0x000078 ; 151.875 6C, 0.471
0B0EA0 73 00 00    0518*  	dl 0x000073 ; 153.281 6D, 0.450
0B0EA3 6D 00 00    0519*  	dl 0x00006D ; 154.688 6E, 0.428
0B0EA6 67 00 00    0520*  	dl 0x000067 ; 156.094 6F, 0.405
0B0EA9 61 00 00    0521*  	dl 0x000061 ; 157.500 70, 0.383
0B0EAC 5C 00 00    0522*  	dl 0x00005C ; 158.906 71, 0.360
0B0EAF 56 00 00    0523*  	dl 0x000056 ; 160.313 72, 0.337
0B0EB2 50 00 00    0524*  	dl 0x000050 ; 161.719 73, 0.314
0B0EB5 4A 00 00    0525*  	dl 0x00004A ; 163.125 74, 0.290
0B0EB8 44 00 00    0526*  	dl 0x000044 ; 164.531 75, 0.267
0B0EBB 3E 00 00    0527*  	dl 0x00003E ; 165.938 76, 0.243
0B0EBE 38 00 00    0528*  	dl 0x000038 ; 167.344 77, 0.219
0B0EC1 31 00 00    0529*  	dl 0x000031 ; 168.750 78, 0.195
0B0EC4 2B 00 00    0530*  	dl 0x00002B ; 170.156 79, 0.171
0B0EC7 25 00 00    0531*  	dl 0x000025 ; 171.563 7A, 0.147
0B0ECA 1F 00 00    0532*  	dl 0x00001F ; 172.969 7B, 0.122
0B0ECD 19 00 00    0533*  	dl 0x000019 ; 174.375 7C, 0.098
0B0ED0 12 00 00    0534*  	dl 0x000012 ; 175.781 7D, 0.074
0B0ED3 0C 00 00    0535*  	dl 0x00000C ; 177.188 7E, 0.049
0B0ED6 06 00 00    0536*  	dl 0x000006 ; 178.594 7F, 0.025
0B0ED9 00 00 00    0537*  	dl 0x000000 ; 180.000 80, 0.000
0B0EDC FA FF FF    0538*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0EDF F4 FF FF    0539*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0EE2 EE FF FF    0540*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0EE5 E7 FF FF    0541*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B0EE8 E1 FF FF    0542*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0EEB DB FF FF    0543*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0EEE D5 FF FF    0544*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0EF1 CF FF FF    0545*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0EF4 C8 FF FF    0546*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B0EF7 C2 FF FF    0547*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B0EFA BC FF FF    0548*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0EFD B6 FF FF    0549*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B0F00 B0 FF FF    0550*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B0F03 AA FF FF    0551*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B0F06 A4 FF FF    0552*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B0F09 9F FF FF    0553*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B0F0C 99 FF FF    0554*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B0F0F 93 FF FF    0555*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B0F12 8D FF FF    0556*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B0F15 88 FF FF    0557*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B0F18 82 FF FF    0558*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B0F1B 7D FF FF    0559*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B0F1E 78 FF FF    0560*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B0F21 72 FF FF    0561*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B0F24 6D FF FF    0562*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B0F27 68 FF FF    0563*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B0F2A 63 FF FF    0564*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B0F2D 5E FF FF    0565*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B0F30 59 FF FF    0566*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B0F33 55 FF FF    0567*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B0F36 50 FF FF    0568*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B0F39 4B FF FF    0569*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B0F3C 47 FF FF    0570*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B0F3F 43 FF FF    0571*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B0F42 3F FF FF    0572*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B0F45 3B FF FF    0573*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B0F48 37 FF FF    0574*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B0F4B 33 FF FF    0575*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B0F4E 2F FF FF    0576*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B0F51 2C FF FF    0577*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B0F54 28 FF FF    0578*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B0F57 25 FF FF    0579*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B0F5A 22 FF FF    0580*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B0F5D 1F FF FF    0581*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B0F60 1C FF FF    0582*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B0F63 19 FF FF    0583*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B0F66 16 FF FF    0584*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B0F69 14 FF FF    0585*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B0F6C 12 FF FF    0586*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B0F6F 0F FF FF    0587*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B0F72 0D FF FF    0588*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B0F75 0C FF FF    0589*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B0F78 0A FF FF    0590*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B0F7B 08 FF FF    0591*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B0F7E 07 FF FF    0592*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B0F81 05 FF FF    0593*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B0F84 04 FF FF    0594*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B0F87 03 FF FF    0595*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B0F8A 02 FF FF    0596*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B0F8D 02 FF FF    0597*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B0F90 01 FF FF    0598*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B0F93 01 FF FF    0599*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B0F96 01 FF FF    0600*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B0F99 00 FF FF    0601*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B0F9C 01 FF FF    0602*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B0F9F 01 FF FF    0603*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B0FA2 01 FF FF    0604*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B0FA5 02 FF FF    0605*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B0FA8 02 FF FF    0606*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B0FAB 03 FF FF    0607*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B0FAE 04 FF FF    0608*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B0FB1 05 FF FF    0609*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B0FB4 07 FF FF    0610*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B0FB7 08 FF FF    0611*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B0FBA 0A FF FF    0612*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B0FBD 0C FF FF    0613*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B0FC0 0D FF FF    0614*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B0FC3 0F FF FF    0615*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B0FC6 12 FF FF    0616*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B0FC9 14 FF FF    0617*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B0FCC 16 FF FF    0618*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B0FCF 19 FF FF    0619*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B0FD2 1C FF FF    0620*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B0FD5 1F FF FF    0621*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B0FD8 22 FF FF    0622*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B0FDB 25 FF FF    0623*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B0FDE 28 FF FF    0624*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B0FE1 2C FF FF    0625*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B0FE4 2F FF FF    0626*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B0FE7 33 FF FF    0627*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B0FEA 37 FF FF    0628*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B0FED 3B FF FF    0629*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B0FF0 3F FF FF    0630*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B0FF3 43 FF FF    0631*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B0FF6 47 FF FF    0632*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B0FF9 4B FF FF    0633*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B0FFC 50 FF FF    0634*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B0FFF 55 FF FF    0635*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B1002 59 FF FF    0636*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1005 5E FF FF    0637*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1008 63 FF FF    0638*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B100B 68 FF FF    0639*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B100E 6D FF FF    0640*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B1011 72 FF FF    0641*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1014 78 FF FF    0642*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1017 7D FF FF    0643*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B101A 82 FF FF    0644*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B101D 88 FF FF    0645*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B1020 8D FF FF    0646*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B1023 93 FF FF    0647*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B1026 99 FF FF    0648*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B1029 9F FF FF    0649*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B102C A4 FF FF    0650*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B102F AA FF FF    0651*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B1032 B0 FF FF    0652*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B1035 B6 FF FF    0653*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B1038 BC FF FF    0654*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B103B C2 FF FF    0655*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B103E C8 FF FF    0656*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B1041 CF FF FF    0657*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B1044 D5 FF FF    0658*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B1047 DB FF FF    0659*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B104A E1 FF FF    0660*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B104D E7 FF FF    0661*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B1050 EE FF FF    0662*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B1053 F4 FF FF    0663*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B1056 FA FF FF    0664*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B1059 00 00 00    0665*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B105C             0666*  
0B105C             0667*  atan_lut_168:
0B105C 00 00 00    0668*  	dl 0x000000 ; 000000, 0.000
0B105F 28 00 00    0669*  	dl 0x000028 ; 000001, 0.224
0B1062 51 00 00    0670*  	dl 0x000051 ; 000002, 0.448
0B1065 7A 00 00    0671*  	dl 0x00007A ; 000003, 0.671
0B1068 A2 00 00    0672*  	dl 0x0000A2 ; 000004, 0.895
0B106B CB 00 00    0673*  	dl 0x0000CB ; 000005, 1.119
0B106E F4 00 00    0674*  	dl 0x0000F4 ; 000006, 1.343
0B1071 1D 01 00    0675*  	dl 0x00011D ; 000007, 1.566
0B1074 45 01 00    0676*  	dl 0x000145 ; 000008, 1.790
0B1077 6E 01 00    0677*  	dl 0x00016E ; 000009, 2.013
0B107A 97 01 00    0678*  	dl 0x000197 ; 00000A, 2.237
0B107D BF 01 00    0679*  	dl 0x0001BF ; 00000B, 2.460
0B1080 E8 01 00    0680*  	dl 0x0001E8 ; 00000C, 2.684
0B1083 11 02 00    0681*  	dl 0x000211 ; 00000D, 2.907
0B1086 39 02 00    0682*  	dl 0x000239 ; 00000E, 3.130
0B1089 62 02 00    0683*  	dl 0x000262 ; 00000F, 3.353
0B108C 8B 02 00    0684*  	dl 0x00028B ; 000010, 3.576
0B108F B3 02 00    0685*  	dl 0x0002B3 ; 000011, 3.799
0B1092 DC 02 00    0686*  	dl 0x0002DC ; 000012, 4.022
0B1095 04 03 00    0687*  	dl 0x000304 ; 000013, 4.245
0B1098 2D 03 00    0688*  	dl 0x00032D ; 000014, 4.467
0B109B 55 03 00    0689*  	dl 0x000355 ; 000015, 4.690
0B109E 7E 03 00    0690*  	dl 0x00037E ; 000016, 4.912
0B10A1 A6 03 00    0691*  	dl 0x0003A6 ; 000017, 5.134
0B10A4 CE 03 00    0692*  	dl 0x0003CE ; 000018, 5.356
0B10A7 F7 03 00    0693*  	dl 0x0003F7 ; 000019, 5.578
0B10AA 1F 04 00    0694*  	dl 0x00041F ; 00001A, 5.799
0B10AD 48 04 00    0695*  	dl 0x000448 ; 00001B, 6.021
0B10B0 70 04 00    0696*  	dl 0x000470 ; 00001C, 6.242
0B10B3 98 04 00    0697*  	dl 0x000498 ; 00001D, 6.463
0B10B6 C0 04 00    0698*  	dl 0x0004C0 ; 00001E, 6.684
0B10B9 E8 04 00    0699*  	dl 0x0004E8 ; 00001F, 6.905
0B10BC 11 05 00    0700*  	dl 0x000511 ; 000020, 7.125
0B10BF 39 05 00    0701*  	dl 0x000539 ; 000021, 7.345
0B10C2 61 05 00    0702*  	dl 0x000561 ; 000022, 7.565
0B10C5 89 05 00    0703*  	dl 0x000589 ; 000023, 7.785
0B10C8 B1 05 00    0704*  	dl 0x0005B1 ; 000024, 8.005
0B10CB D9 05 00    0705*  	dl 0x0005D9 ; 000025, 8.224
0B10CE 01 06 00    0706*  	dl 0x000601 ; 000026, 8.443
0B10D1 28 06 00    0707*  	dl 0x000628 ; 000027, 8.662
0B10D4 50 06 00    0708*  	dl 0x000650 ; 000028, 8.881
0B10D7 78 06 00    0709*  	dl 0x000678 ; 000029, 9.099
0B10DA A0 06 00    0710*  	dl 0x0006A0 ; 00002A, 9.317
0B10DD C7 06 00    0711*  	dl 0x0006C7 ; 00002B, 9.535
0B10E0 EF 06 00    0712*  	dl 0x0006EF ; 00002C, 9.752
0B10E3 16 07 00    0713*  	dl 0x000716 ; 00002D, 9.970
0B10E6 3E 07 00    0714*  	dl 0x00073E ; 00002E, 10.187
0B10E9 65 07 00    0715*  	dl 0x000765 ; 00002F, 10.403
0B10EC 8D 07 00    0716*  	dl 0x00078D ; 000030, 10.620
0B10EF B4 07 00    0717*  	dl 0x0007B4 ; 000031, 10.836
0B10F2 DB 07 00    0718*  	dl 0x0007DB ; 000032, 11.051
0B10F5 03 08 00    0719*  	dl 0x000803 ; 000033, 11.267
0B10F8 2A 08 00    0720*  	dl 0x00082A ; 000034, 11.482
0B10FB 51 08 00    0721*  	dl 0x000851 ; 000035, 11.697
0B10FE 78 08 00    0722*  	dl 0x000878 ; 000036, 11.911
0B1101 9F 08 00    0723*  	dl 0x00089F ; 000037, 12.125
0B1104 C6 08 00    0724*  	dl 0x0008C6 ; 000038, 12.339
0B1107 ED 08 00    0725*  	dl 0x0008ED ; 000039, 12.553
0B110A 13 09 00    0726*  	dl 0x000913 ; 00003A, 12.766
0B110D 3A 09 00    0727*  	dl 0x00093A ; 00003B, 12.978
0B1110 61 09 00    0728*  	dl 0x000961 ; 00003C, 13.191
0B1113 87 09 00    0729*  	dl 0x000987 ; 00003D, 13.403
0B1116 AE 09 00    0730*  	dl 0x0009AE ; 00003E, 13.614
0B1119 D4 09 00    0731*  	dl 0x0009D4 ; 00003F, 13.825
0B111C FB 09 00    0732*  	dl 0x0009FB ; 000040, 14.036
0B111F 21 0A 00    0733*  	dl 0x000A21 ; 000041, 14.247
0B1122 47 0A 00    0734*  	dl 0x000A47 ; 000042, 14.457
0B1125 6D 0A 00    0735*  	dl 0x000A6D ; 000043, 14.666
0B1128 94 0A 00    0736*  	dl 0x000A94 ; 000044, 14.876
0B112B BA 0A 00    0737*  	dl 0x000ABA ; 000045, 15.085
0B112E E0 0A 00    0738*  	dl 0x000AE0 ; 000046, 15.293
0B1131 05 0B 00    0739*  	dl 0x000B05 ; 000047, 15.501
0B1134 2B 0B 00    0740*  	dl 0x000B2B ; 000048, 15.709
0B1137 51 0B 00    0741*  	dl 0x000B51 ; 000049, 15.916
0B113A 77 0B 00    0742*  	dl 0x000B77 ; 00004A, 16.123
0B113D 9C 0B 00    0743*  	dl 0x000B9C ; 00004B, 16.329
0B1140 C2 0B 00    0744*  	dl 0x000BC2 ; 00004C, 16.535
0B1143 E7 0B 00    0745*  	dl 0x000BE7 ; 00004D, 16.740
0B1146 0C 0C 00    0746*  	dl 0x000C0C ; 00004E, 16.945
0B1149 32 0C 00    0747*  	dl 0x000C32 ; 00004F, 17.150
0B114C 57 0C 00    0748*  	dl 0x000C57 ; 000050, 17.354
0B114F 7C 0C 00    0749*  	dl 0x000C7C ; 000051, 17.558
0B1152 A1 0C 00    0750*  	dl 0x000CA1 ; 000052, 17.761
0B1155 C6 0C 00    0751*  	dl 0x000CC6 ; 000053, 17.964
0B1158 EB 0C 00    0752*  	dl 0x000CEB ; 000054, 18.166
0B115B 0F 0D 00    0753*  	dl 0x000D0F ; 000055, 18.368
0B115E 34 0D 00    0754*  	dl 0x000D34 ; 000056, 18.569
0B1161 58 0D 00    0755*  	dl 0x000D58 ; 000057, 18.770
0B1164 7D 0D 00    0756*  	dl 0x000D7D ; 000058, 18.970
0B1167 A1 0D 00    0757*  	dl 0x000DA1 ; 000059, 19.170
0B116A C6 0D 00    0758*  	dl 0x000DC6 ; 00005A, 19.370
0B116D EA 0D 00    0759*  	dl 0x000DEA ; 00005B, 19.569
0B1170 0E 0E 00    0760*  	dl 0x000E0E ; 00005C, 19.767
0B1173 32 0E 00    0761*  	dl 0x000E32 ; 00005D, 19.965
0B1176 56 0E 00    0762*  	dl 0x000E56 ; 00005E, 20.163
0B1179 7A 0E 00    0763*  	dl 0x000E7A ; 00005F, 20.360
0B117C 9E 0E 00    0764*  	dl 0x000E9E ; 000060, 20.556
0B117F C1 0E 00    0765*  	dl 0x000EC1 ; 000061, 20.752
0B1182 E5 0E 00    0766*  	dl 0x000EE5 ; 000062, 20.947
0B1185 08 0F 00    0767*  	dl 0x000F08 ; 000063, 21.142
0B1188 2C 0F 00    0768*  	dl 0x000F2C ; 000064, 21.337
0B118B 4F 0F 00    0769*  	dl 0x000F4F ; 000065, 21.531
0B118E 72 0F 00    0770*  	dl 0x000F72 ; 000066, 21.724
0B1191 95 0F 00    0771*  	dl 0x000F95 ; 000067, 21.917
0B1194 B8 0F 00    0772*  	dl 0x000FB8 ; 000068, 22.109
0B1197 DB 0F 00    0773*  	dl 0x000FDB ; 000069, 22.301
0B119A FE 0F 00    0774*  	dl 0x000FFE ; 00006A, 22.493
0B119D 21 10 00    0775*  	dl 0x001021 ; 00006B, 22.683
0B11A0 44 10 00    0776*  	dl 0x001044 ; 00006C, 22.874
0B11A3 66 10 00    0777*  	dl 0x001066 ; 00006D, 23.063
0B11A6 89 10 00    0778*  	dl 0x001089 ; 00006E, 23.253
0B11A9 AB 10 00    0779*  	dl 0x0010AB ; 00006F, 23.441
0B11AC CD 10 00    0780*  	dl 0x0010CD ; 000070, 23.629
0B11AF EF 10 00    0781*  	dl 0x0010EF ; 000071, 23.817
0B11B2 11 11 00    0782*  	dl 0x001111 ; 000072, 24.004
0B11B5 33 11 00    0783*  	dl 0x001133 ; 000073, 24.191
0B11B8 55 11 00    0784*  	dl 0x001155 ; 000074, 24.376
0B11BB 77 11 00    0785*  	dl 0x001177 ; 000075, 24.562
0B11BE 99 11 00    0786*  	dl 0x001199 ; 000076, 24.747
0B11C1 BA 11 00    0787*  	dl 0x0011BA ; 000077, 24.931
0B11C4 DC 11 00    0788*  	dl 0x0011DC ; 000078, 25.115
0B11C7 FD 11 00    0789*  	dl 0x0011FD ; 000079, 25.298
0B11CA 1E 12 00    0790*  	dl 0x00121E ; 00007A, 25.481
0B11CD 3F 12 00    0791*  	dl 0x00123F ; 00007B, 25.663
0B11D0 60 12 00    0792*  	dl 0x001260 ; 00007C, 25.844
0B11D3 81 12 00    0793*  	dl 0x001281 ; 00007D, 26.025
0B11D6 A2 12 00    0794*  	dl 0x0012A2 ; 00007E, 26.206
0B11D9 C3 12 00    0795*  	dl 0x0012C3 ; 00007F, 26.386
0B11DC E4 12 00    0796*  	dl 0x0012E4 ; 000080, 26.565
0B11DF 04 13 00    0797*  	dl 0x001304 ; 000081, 26.744
0B11E2 25 13 00    0798*  	dl 0x001325 ; 000082, 26.922
0B11E5 45 13 00    0799*  	dl 0x001345 ; 000083, 27.100
0B11E8 65 13 00    0800*  	dl 0x001365 ; 000084, 27.277
0B11EB 85 13 00    0801*  	dl 0x001385 ; 000085, 27.453
0B11EE A5 13 00    0802*  	dl 0x0013A5 ; 000086, 27.629
0B11F1 C5 13 00    0803*  	dl 0x0013C5 ; 000087, 27.805
0B11F4 E5 13 00    0804*  	dl 0x0013E5 ; 000088, 27.979
0B11F7 05 14 00    0805*  	dl 0x001405 ; 000089, 28.154
0B11FA 24 14 00    0806*  	dl 0x001424 ; 00008A, 28.327
0B11FD 44 14 00    0807*  	dl 0x001444 ; 00008B, 28.501
0B1200 63 14 00    0808*  	dl 0x001463 ; 00008C, 28.673
0B1203 83 14 00    0809*  	dl 0x001483 ; 00008D, 28.845
0B1206 A2 14 00    0810*  	dl 0x0014A2 ; 00008E, 29.017
0B1209 C1 14 00    0811*  	dl 0x0014C1 ; 00008F, 29.187
0B120C E0 14 00    0812*  	dl 0x0014E0 ; 000090, 29.358
0B120F FF 14 00    0813*  	dl 0x0014FF ; 000091, 29.527
0B1212 1E 15 00    0814*  	dl 0x00151E ; 000092, 29.697
0B1215 3C 15 00    0815*  	dl 0x00153C ; 000093, 29.865
0B1218 5B 15 00    0816*  	dl 0x00155B ; 000094, 30.033
0B121B 79 15 00    0817*  	dl 0x001579 ; 000095, 30.201
0B121E 98 15 00    0818*  	dl 0x001598 ; 000096, 30.368
0B1221 B6 15 00    0819*  	dl 0x0015B6 ; 000097, 30.534
0B1224 D4 15 00    0820*  	dl 0x0015D4 ; 000098, 30.700
0B1227 F2 15 00    0821*  	dl 0x0015F2 ; 000099, 30.865
0B122A 10 16 00    0822*  	dl 0x001610 ; 00009A, 31.030
0B122D 2E 16 00    0823*  	dl 0x00162E ; 00009B, 31.194
0B1230 4C 16 00    0824*  	dl 0x00164C ; 00009C, 31.357
0B1233 6A 16 00    0825*  	dl 0x00166A ; 00009D, 31.520
0B1236 87 16 00    0826*  	dl 0x001687 ; 00009E, 31.682
0B1239 A5 16 00    0827*  	dl 0x0016A5 ; 00009F, 31.844
0B123C C2 16 00    0828*  	dl 0x0016C2 ; 0000A0, 32.005
0B123F DF 16 00    0829*  	dl 0x0016DF ; 0000A1, 32.166
0B1242 FC 16 00    0830*  	dl 0x0016FC ; 0000A2, 32.326
0B1245 19 17 00    0831*  	dl 0x001719 ; 0000A3, 32.486
0B1248 36 17 00    0832*  	dl 0x001736 ; 0000A4, 32.645
0B124B 53 17 00    0833*  	dl 0x001753 ; 0000A5, 32.803
0B124E 70 17 00    0834*  	dl 0x001770 ; 0000A6, 32.961
0B1251 8C 17 00    0835*  	dl 0x00178C ; 0000A7, 33.118
0B1254 A9 17 00    0836*  	dl 0x0017A9 ; 0000A8, 33.275
0B1257 C5 17 00    0837*  	dl 0x0017C5 ; 0000A9, 33.431
0B125A E2 17 00    0838*  	dl 0x0017E2 ; 0000AA, 33.587
0B125D FE 17 00    0839*  	dl 0x0017FE ; 0000AB, 33.742
0B1260 1A 18 00    0840*  	dl 0x00181A ; 0000AC, 33.896
0B1263 36 18 00    0841*  	dl 0x001836 ; 0000AD, 34.050
0B1266 52 18 00    0842*  	dl 0x001852 ; 0000AE, 34.203
0B1269 6E 18 00    0843*  	dl 0x00186E ; 0000AF, 34.356
0B126C 8A 18 00    0844*  	dl 0x00188A ; 0000B0, 34.509
0B126F A5 18 00    0845*  	dl 0x0018A5 ; 0000B1, 34.660
0B1272 C1 18 00    0846*  	dl 0x0018C1 ; 0000B2, 34.811
0B1275 DC 18 00    0847*  	dl 0x0018DC ; 0000B3, 34.962
0B1278 F7 18 00    0848*  	dl 0x0018F7 ; 0000B4, 35.112
0B127B 13 19 00    0849*  	dl 0x001913 ; 0000B5, 35.262
0B127E 2E 19 00    0850*  	dl 0x00192E ; 0000B6, 35.410
0B1281 49 19 00    0851*  	dl 0x001949 ; 0000B7, 35.559
0B1284 64 19 00    0852*  	dl 0x001964 ; 0000B8, 35.707
0B1287 7F 19 00    0853*  	dl 0x00197F ; 0000B9, 35.854
0B128A 99 19 00    0854*  	dl 0x001999 ; 0000BA, 36.001
0B128D B4 19 00    0855*  	dl 0x0019B4 ; 0000BB, 36.147
0B1290 CE 19 00    0856*  	dl 0x0019CE ; 0000BC, 36.293
0B1293 E9 19 00    0857*  	dl 0x0019E9 ; 0000BD, 36.438
0B1296 03 1A 00    0858*  	dl 0x001A03 ; 0000BE, 36.582
0B1299 1D 1A 00    0859*  	dl 0x001A1D ; 0000BF, 36.726
0B129C 37 1A 00    0860*  	dl 0x001A37 ; 0000C0, 36.870
0B129F 51 1A 00    0861*  	dl 0x001A51 ; 0000C1, 37.013
0B12A2 6B 1A 00    0862*  	dl 0x001A6B ; 0000C2, 37.155
0B12A5 85 1A 00    0863*  	dl 0x001A85 ; 0000C3, 37.297
0B12A8 9F 1A 00    0864*  	dl 0x001A9F ; 0000C4, 37.439
0B12AB B9 1A 00    0865*  	dl 0x001AB9 ; 0000C5, 37.579
0B12AE D2 1A 00    0866*  	dl 0x001AD2 ; 0000C6, 37.720
0B12B1 EC 1A 00    0867*  	dl 0x001AEC ; 0000C7, 37.859
0B12B4 05 1B 00    0868*  	dl 0x001B05 ; 0000C8, 37.999
0B12B7 1E 1B 00    0869*  	dl 0x001B1E ; 0000C9, 38.137
0B12BA 37 1B 00    0870*  	dl 0x001B37 ; 0000CA, 38.276
0B12BD 50 1B 00    0871*  	dl 0x001B50 ; 0000CB, 38.413
0B12C0 69 1B 00    0872*  	dl 0x001B69 ; 0000CC, 38.550
0B12C3 82 1B 00    0873*  	dl 0x001B82 ; 0000CD, 38.687
0B12C6 9B 1B 00    0874*  	dl 0x001B9B ; 0000CE, 38.823
0B12C9 B4 1B 00    0875*  	dl 0x001BB4 ; 0000CF, 38.959
0B12CC CC 1B 00    0876*  	dl 0x001BCC ; 0000D0, 39.094
0B12CF E5 1B 00    0877*  	dl 0x001BE5 ; 0000D1, 39.228
0B12D2 FD 1B 00    0878*  	dl 0x001BFD ; 0000D2, 39.362
0B12D5 16 1C 00    0879*  	dl 0x001C16 ; 0000D3, 39.496
0B12D8 2E 1C 00    0880*  	dl 0x001C2E ; 0000D4, 39.629
0B12DB 46 1C 00    0881*  	dl 0x001C46 ; 0000D5, 39.762
0B12DE 5E 1C 00    0882*  	dl 0x001C5E ; 0000D6, 39.894
0B12E1 76 1C 00    0883*  	dl 0x001C76 ; 0000D7, 40.025
0B12E4 8E 1C 00    0884*  	dl 0x001C8E ; 0000D8, 40.156
0B12E7 A5 1C 00    0885*  	dl 0x001CA5 ; 0000D9, 40.286
0B12EA BD 1C 00    0886*  	dl 0x001CBD ; 0000DA, 40.416
0B12ED D5 1C 00    0887*  	dl 0x001CD5 ; 0000DB, 40.546
0B12F0 EC 1C 00    0888*  	dl 0x001CEC ; 0000DC, 40.675
0B12F3 04 1D 00    0889*  	dl 0x001D04 ; 0000DD, 40.803
0B12F6 1B 1D 00    0890*  	dl 0x001D1B ; 0000DE, 40.931
0B12F9 32 1D 00    0891*  	dl 0x001D32 ; 0000DF, 41.059
0B12FC 49 1D 00    0892*  	dl 0x001D49 ; 0000E0, 41.186
0B12FF 60 1D 00    0893*  	dl 0x001D60 ; 0000E1, 41.312
0B1302 77 1D 00    0894*  	dl 0x001D77 ; 0000E2, 41.438
0B1305 8E 1D 00    0895*  	dl 0x001D8E ; 0000E3, 41.564
0B1308 A5 1D 00    0896*  	dl 0x001DA5 ; 0000E4, 41.689
0B130B BB 1D 00    0897*  	dl 0x001DBB ; 0000E5, 41.814
0B130E D2 1D 00    0898*  	dl 0x001DD2 ; 0000E6, 41.938
0B1311 E9 1D 00    0899*  	dl 0x001DE9 ; 0000E7, 42.061
0B1314 FF 1D 00    0900*  	dl 0x001DFF ; 0000E8, 42.184
0B1317 15 1E 00    0901*  	dl 0x001E15 ; 0000E9, 42.307
0B131A 2C 1E 00    0902*  	dl 0x001E2C ; 0000EA, 42.429
0B131D 42 1E 00    0903*  	dl 0x001E42 ; 0000EB, 42.551
0B1320 58 1E 00    0904*  	dl 0x001E58 ; 0000EC, 42.672
0B1323 6E 1E 00    0905*  	dl 0x001E6E ; 0000ED, 42.793
0B1326 84 1E 00    0906*  	dl 0x001E84 ; 0000EE, 42.913
0B1329 99 1E 00    0907*  	dl 0x001E99 ; 0000EF, 43.033
0B132C AF 1E 00    0908*  	dl 0x001EAF ; 0000F0, 43.152
0B132F C5 1E 00    0909*  	dl 0x001EC5 ; 0000F1, 43.271
0B1332 DA 1E 00    0910*  	dl 0x001EDA ; 0000F2, 43.390
0B1335 F0 1E 00    0911*  	dl 0x001EF0 ; 0000F3, 43.508
0B1338 05 1F 00    0912*  	dl 0x001F05 ; 0000F4, 43.625
0B133B 1B 1F 00    0913*  	dl 0x001F1B ; 0000F5, 43.742
0B133E 30 1F 00    0914*  	dl 0x001F30 ; 0000F6, 43.859
0B1341 45 1F 00    0915*  	dl 0x001F45 ; 0000F7, 43.975
0B1344 5A 1F 00    0916*  	dl 0x001F5A ; 0000F8, 44.091
0B1347 6F 1F 00    0917*  	dl 0x001F6F ; 0000F9, 44.206
0B134A 84 1F 00    0918*  	dl 0x001F84 ; 0000FA, 44.321
0B134D 99 1F 00    0919*  	dl 0x001F99 ; 0000FB, 44.435
0B1350 AD 1F 00    0920*  	dl 0x001FAD ; 0000FC, 44.549
0B1353 C2 1F 00    0921*  	dl 0x001FC2 ; 0000FD, 44.662
0B1356 D7 1F 00    0922*  	dl 0x001FD7 ; 0000FE, 44.775
0B1359 EB 1F 00    0923*  	dl 0x001FEB ; 0000FF, 44.888
0B135C 00 20 00    0924*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B135F             0023       include "files.inc"
0B135F             0001*  ; load to onboard 8k sram
0B135F             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B135F             0024       include "timer.inc"
0B135F             0001*  ; Table 32. Timer Control Registers
0B135F             0002*  ; this constant is the base address of the timer control registers
0B135F             0003*  ; each timer takes three bytes:
0B135F             0004*  ;   0: control register
0B135F             0005*  ;   1: low byte of timer reset value
0B135F             0006*  ;   2: high byte of timer reset value
0B135F             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B135F             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B135F             0009*  TMR_CTL:     equ 80h
0B135F             0010*  
0B135F             0011*  ; Timer Control Register Bit Definitions
0B135F             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B135F             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B135F             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B135F             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B135F             0016*                              ; the TMRx_CTL register is read.
0B135F             0017*  
0B135F             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B135F             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B135F             0020*  
0B135F             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B135F             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B135F             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B135F             0024*                              ; written to the counter when the end-of-count value is reached.
0B135F             0025*  
0B135F             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B135F             0027*  CLK_DIV_256:  equ %00001100 ;
0B135F             0028*  CLK_DIV_64:   equ %00001000 ;
0B135F             0029*  CLK_DIV_16:   equ %00000100 ;
0B135F             0030*  CLK_DIV_4:    equ %00000000 ;
0B135F             0031*  
0B135F             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B135F             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B135F             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B135F             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B135F             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B135F             0037*                              ; SINGLE-PASS mode is used.
0B135F             0038*  
0B135F             0039*  ; disable/enable the programmable reload timer
0B135F             0040*  PRT_EN_0:     equ %00000000 ;
0B135F             0041*  PRT_EN_1:     equ %00000001 ;
0B135F             0042*  
0B135F             0043*  ; Table 37. Timer Input Source Select Register
0B135F             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B135F             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B135F             0046*  ;   00: System clock / CLK_DIV
0B135F             0047*  ;   01: RTC / CLK_DIV
0B135F             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B135F             0049*  ;   10: GPIO port B pin 1.
0B135F             0050*  ;   11: GPIO port B pin 1.
0B135F             0051*  TMR_ISS:   equ 92h ; register address
0B135F             0052*  
0B135F             0053*  ; Table 51. Real-Time Clock Control Register
0B135F             0054*  RTC_CTRL: equ EDh ; register address
0B135F             0055*  
0B135F             0056*  ; alarm interrupt disable/enable
0B135F             0057*  RTC_ALARM_0:    equ %00000000
0B135F             0058*  RTC_ALARM_1:    equ %10000000
0B135F             0059*  
0B135F             0060*  ; interrupt on alarm disable/enable
0B135F             0061*  RTC_INT_ENT_0:  equ %00000000
0B135F             0062*  RTC_INT_ENT_1:  equ %01000000
0B135F             0063*  
0B135F             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B135F             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B135F             0066*  
0B135F             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B135F             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B135F             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B135F             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B135F             0071*  
0B135F             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B135F             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B135F             0074*  
0B135F             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B135F             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B135F             0077*  
0B135F             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B135F             0079*                                  ; RTC counter is enabled.
0B135F             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B135F             0081*                                  ; RTC counter is disabled.
0B135F             0082*  
0B135F             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B135F             0084*  
0B135F             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B135F             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B135F 00 00 00    0087*  prt_reload: dl 0x000000
0B1362             0088*  
0B1362             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B1362             0090*  ; ;          de = number PRT interrupts during test interval
0B1362             0091*  ; prt_calibrate:
0B1362             0092*  ;     call vdu_vblank
0B1362             0093*  ; ; set a MOS timer
0B1362             0094*  ;     ld hl,120*1 ; 1 second
0B1362             0095*  ;     ld iy,tmr_test
0B1362             0096*  ;     call tmr_set
0B1362             0097*  ; ; set a PRT timer
0B1362             0098*  ;     ; ld hl,prt_reload_hardware
0B1362             0099*  ;     ; ld hl,prt_reload_emulator
0B1362             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B1362             0101*  ;     ld (prt_reload),hl
0B1362             0102*  ;     call prt_set
0B1362             0103*  ; @loop:
0B1362             0104*  ; ; check time remaining on MOS timer
0B1362             0105*  ;     call tmr_get
0B1362             0106*  ;     jp z,@done ; time expired,so quit
0B1362             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B1362             0108*  ;     jr @loop
0B1362             0109*  ; @done:
0B1362             0110*  ;     ld de,(prt_irq_counter)
0B1362             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B1362             0112*  ;     ld (prt_reload),bc
0B1362             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B1362             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B1362             0115*  ;     ld (is_emulator),a
0B1362             0116*  ;     sbc hl,de
0B1362             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B1362             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B1362             0119*  ;     ret m ; negative result means we're on hardware
0B1362             0120*  ;     inc a ; we're on emulator
0B1362             0121*  ;     ld (is_emulator),a
0B1362             0122*  ;     ld bc,prt_reload_emulator
0B1362             0123*  ;     ld (prt_reload),bc
0B1362             0124*  ;     ld hl,on_emulator
0B1362             0125*  ;     ret
0B1362             0126*  
0B1362             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B1362             0128*  
0B1362             0129*  ; set PRT timer
0B1362             0130*  prt_set:
0B1362 21 00 00 00 0131*      ld hl,0
0B1366 22 B0 13 0B 0132*      ld (prt_irq_counter),hl
0B136A 2A 5F 13 0B 0133*      ld hl,(prt_reload)
0B136E ED 29 84    0134*      out0 ($84),l
0B1371 ED 21 85    0135*  	out0 ($85),h
0B1374             0136*  ; disable timer
0B1374 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B1376 ED 39 83    0138*  	out0 ($83),a
0B1379             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B1379 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B137B ED 39 83    0141*  	out0 ($83),a
0B137E C9          0142*      ret
0B137F             0143*  
0B137F             0144*  ; ===============================================
0B137F             0145*  ; PRT Timer Interrupt Handling
0B137F             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B137F             0147*  ; -----------------------------------------------
0B137F             0148*  prt_irq_init:
0B137F             0149*      ; set up interrupt vector table 2
0B137F 21 00 00 00 0150*  	ld hl,0
0B1383 3A 0C 01 00 0151*  	ld a,($10c)
0B1387 6F          0152*  	ld l,a
0B1388 3A 0D 01 00 0153*  	ld a,($10d)
0B138C 67          0154*  	ld h,a
0B138D             0155*  
0B138D             0156*  	; skip over CALL ($c3)
0B138D 23          0157*  	inc hl
0B138E             0158*  	; load address of jump into vector table 2 (in ram)
0B138E ED 27       0159*  	ld hl,(hl)
0B1390             0160*  
0B1390             0161*  	; write CALL prt_irq_handler to vector table 2
0B1390 3E C3       0162*  	ld a,$c3
0B1392 77          0163*  	ld (hl),a
0B1393 23          0164*  	inc hl
0B1394 11 9B 13 0B 0165*  	ld de,prt_irq_handler
0B1398 ED 1F       0166*  	ld (hl),de
0B139A             0167*  
0B139A C9          0168*      ret
0B139B             0169*  
0B139B             0170*  prt_irq_handler:
0B139B F3          0171*  	di
0B139C F5          0172*  	push af
0B139D E5          0173*      push hl
0B139E ED 38 83    0174*  	in0 a,($83)
0B13A1 2A B0 13 0B 0175*  	ld hl,(prt_irq_counter)
0B13A5 23          0176*  	inc hl
0B13A6 22 B0 13 0B 0177*  	ld (prt_irq_counter),hl
0B13AA E1          0178*      pop hl
0B13AB F1          0179*  	pop af
0B13AC FB          0180*  	ei
0B13AD 5B ED 4D    0181*  	reti.l
0B13B0             0182*  
0B13B0             0183*  prt_irq_counter:
0B13B0 00 00 00    0184*  	.dl 0
0B13B3             0185*  prt_irq_counter_saved:
0B13B3 00 00 00    0186*      .dl 0
0B13B6             0187*  
0B13B6             0188*  prt_loop_reset:
0B13B6 E5          0189*      push hl
0B13B7 21 00 00 00 0190*  	ld hl,0
0B13BB 22 B0 13 0B 0191*  	ld (prt_irq_counter),hl
0B13BF 22 21 14 0B 0192*      ld (prt_loop_counter),hl
0B13C3 22 24 14 0B 0193*      ld (prt_loops),hl
0B13C7 CD 62 13 0B 0194*      call prt_set
0B13CB E1          0195*      pop hl
0B13CC C9          0196*      ret
0B13CD             0197*  
0B13CD             0198*  prt_loop_start:
0B13CD E5          0199*      push hl
0B13CE 21 00 00 00 0200*  	ld hl,0
0B13D2 22 B0 13 0B 0201*  	ld (prt_irq_counter),hl
0B13D6 E1          0202*      pop hl
0B13D7 C9          0203*      ret
0B13D8             0204*  
0B13D8             0205*  prt_loop_stop:
0B13D8 E5          0206*      push hl
0B13D9 D5          0207*      push de
0B13DA 2A B0 13 0B 0208*      ld hl,(prt_irq_counter)
0B13DE ED 5B 21 14 0209*      ld de,(prt_loop_counter)
       0B          
0B13E3 19          0210*      add hl,de
0B13E4 22 21 14 0B 0211*      ld (prt_loop_counter),hl
0B13E8 21 00 00 00 0212*      ld hl,0
0B13EC 22 B0 13 0B 0213*      ld (prt_irq_counter),hl
0B13F0 2A 24 14 0B 0214*      ld hl,(prt_loops)
0B13F4 23          0215*      inc hl
0B13F5 22 24 14 0B 0216*      ld (prt_loops),hl
0B13F9 D1          0217*      pop de
0B13FA E1          0218*      pop hl
0B13FB C9          0219*      ret
0B13FC             0220*  
0B13FC             0221*  ; inputs: bc = y,x text coordinates to print
0B13FC             0222*  prt_loop_print:
0B13FC F5          0223*      push af
0B13FD E5          0224*      push hl
0B13FE C5          0225*      push bc
0B13FF D5          0226*      push de
0B1400 DD E5       0227*      push ix
0B1402 FD E5       0228*      push iy
0B1404 CD 19 15 0B 0229*      call vdu_move_cursor
0B1408             0230*  
0B1408 2A 21 14 0B 0231*      ld hl,(prt_loop_counter)
0B140C CD 2B 03 0B 0232*      call printDec
0B1410             0233*  
0B1410 2A 24 14 0B 0234*      ld hl,(prt_loops)
0B1414 CD 2B 03 0B 0235*      call printDec
0B1418             0236*  
0B1418 FD E1       0237*      pop iy
0B141A DD E1       0238*      pop ix
0B141C D1          0239*      pop de
0B141D C1          0240*      pop bc
0B141E E1          0241*      pop hl
0B141F F1          0242*      pop af
0B1420 C9          0243*      ret
0B1421             0244*  
0B1421             0245*  prt_loop_counter:
0B1421 00 00 00    0246*      .dl 0
0B1424             0247*  prt_loops:
0B1424 00 00 00    0248*      .dl 0
0B1427             0249*  
0B1427             0250*  ; ===============================================
0B1427             0251*  ; Timer functions
0B1427             0252*  ; -----------------------------------------------
0B1427             0253*  ; set a countdown timer
0B1427             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1427             0255*  ; returns: hl = current time
0B1427             0256*  tmr_set:
0B1427 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B142A             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B142A 3E 08       0001*M 			LD	A, function
0B142C 5B CF       0002*M 			RST.L	08h
0B142E DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B1431 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B1434 C9          0261*      ret
0B1435             0262*  
0B1435             0263*  ; gets time remaining on a countdown timer
0B1435             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1435             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1435             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1435             0267*  tmr_get:
0B1435             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1435 3E 08       0001*M 			LD	A, function
0B1437 5B CF       0002*M 			RST.L	08h
0B1439 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B143C FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B143F AF          0271*      xor a                   ; clear carry
0B1440 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1442 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B1445 AF          0274*      xor a                   ; clear carry
0B1446 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B1448             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1448 C9          0277*      ret
0B1449             0278*  
0B1449 00 00 00    0279*  timestamp_now: dl 0
0B144C 00 00 00    0280*  timestamp_old: dl 0
0B144F 00 00 00    0281*  timestamp_chg: dl 0
0B1452             0282*  
0B1452             0283*  ; update the global timestamp from the system clock
0B1452             0284*  ; inputs: none
0B1452             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B1452             0286*  ;          de = current time
0B1452             0287*  ;          ix = pointer to syvars table
0B1452             0288*  ; destroys: af,hl,de,ix
0B1452             0289*  timestamp_tick:
0B1452 ED 5B 49 14 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B1457 ED 53 4C 14 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B145C             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B145C 3E 08       0001*M 			LD	A, function
0B145E 5B CF       0002*M 			RST.L	08h
0B1460 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B1463 22 49 14 0B 0294*      ld (timestamp_now),hl   ; save current time
0B1467 AF          0295*      xor a                   ; clear carry
0B1468 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B146A 22 4F 14 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B146E C9          0298*      ret
0B146F             0299*  
0B146F             0300*  ; set a countdown timer
0B146F             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B146F             0302*  ; requires: timestamp_tick to be called at least once before this function
0B146F             0303*  ; returns: hl = current time
0B146F             0304*  ; destroys: hl
0B146F             0305*  timestamp_tmr_set:
0B146F FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B1472 2A 49 14 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B1476 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B1479 C9          0309*      ret
0B147A             0310*  
0B147A             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B147A             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B147A             0313*  ; requires: timestamp_tick to be called at least once before this function
0B147A             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B147A             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B147A             0316*  ; destroys: af,hl,de
0B147A             0317*  timestamp_tmr_get:
0B147A ED 5B 49 14 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B147F FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B1482 AF          0320*      xor a                   ; clear carry
0B1483 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1485 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B1488 AF          0323*      xor a                   ; clear carry
0B1489 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B148B             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B148B C9          0326*      ret
0B148C             0327*  
0B148C             0328*  ; main loop timer functions
0B148C             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B1492             0330*  
0B1492             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B1492             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B1492             0333*  ; returns: hl = current time
0B1492             0334*  ; destroys: af,hl,de,ix,iy
0B1492             0335*  tmr_main_loop_set:
0B1492 FD 21 8C 14 0336*      ld iy,tmr_main_loop
       0B          
0B1497 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B149A CD 52 14 0B 0338*      call timestamp_tick
0B149E 2A 49 14 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B14A2 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B14A5 C9          0341*      ret
0B14A6             0342*  
0B14A6             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B14A6             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B14A6             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B14A6             0346*  ; destroys: af,hl,de,ix,iy
0B14A6             0347*  tmr_main_loop_get:
0B14A6 CD 52 14 0B 0348*      call timestamp_tick
0B14AA FD 21 8C 14 0349*      ld iy,tmr_main_loop
       0B          
0B14AF CD 7A 14 0B 0350*      call timestamp_tmr_get
0B14B3 C9          0351*      ret
0B14B4             0352*  
0B14B4             0353*  ; set a stopwatch
0B14B4             0354*  ; returns: hl = start time
0B14B4             0355*  ; destroys: hl,ix
0B14B4             0356*  stopwatch_set:
0B14B4             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B14B4 3E 08       0001*M 			LD	A, function
0B14B6 5B CF       0002*M 			RST.L	08h
0B14B8 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B14BB 22 D0 14 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B14BF C9          0360*      ret
0B14C0             0361*  
0B14C0             0362*  ; gets time elapsed on a stopwatch
0B14C0             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B14C0             0364*  ; destroys: af,hl,de,ix
0B14C0             0365*  stopwatch_get:
0B14C0             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B14C0 3E 08       0001*M 			LD	A, function
0B14C2 5B CF       0002*M 			RST.L	08h
0B14C4 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B14C7 ED 5B D0 14 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B14CC AF          0369*      xor a                   ; clear carry
0B14CD ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B14CF C9          0371*      ret
0B14D0             0372*  
0B14D0             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B14D3             0374*  
0B14D3             0375*  ; ------------------
0B14D3             0376*  ; delay routine
0B14D3             0377*  ; Author: Richard Turrnidge
0B14D3             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B14D3             0379*  ; routine waits a fixed time,then returns
0B14D3             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B14D3             0381*  ; eg. ld A,00000100b
0B14D3             0382*  
0B14D3             0383*  multiPurposeDelay:
0B14D3 F5          0384*      push af
0B14D4 C5          0385*      push bc
0B14D5 DD E5       0386*      push ix
0B14D7 47          0387*      ld b,a
0B14D8 3E 08       0388*      ld a,$08
0B14DA 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B14DC             0390*  
0B14DC             0391*  waitLoop:
0B14DC             0392*  
0B14DC DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B14DF             0394*  
0B14DF             0395*                                  ;   we check if bit set is same as last time we checked.
0B14DF             0396*                                  ;   bit 0 - don't use
0B14DF             0397*                                  ;   bit 1 - changes 64 times per second
0B14DF             0398*                                  ;   bit 2 - changes 32 times per second
0B14DF             0399*                                  ;   bit 3 - changes 16 times per second
0B14DF             0400*  
0B14DF             0401*                                  ;   bit 4 - changes 8 times per second
0B14DF             0402*                                  ;   bit 5 - changes 4 times per second
0B14DF             0403*                                  ;   bit 6 - changes 2 times per second
0B14DF             0404*                                  ;   bit 7 - changes 1 times per second
0B14DF A0          0405*      and b
0B14E0 4F          0406*      ld c,a
0B14E1 3A F2 14 0B 0407*      ld a,(oldTimeStamp)
0B14E5 B9          0408*      cp c                        ; is A same as last value?
0B14E6 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B14E8 79          0410*      ld a,c
0B14E9 32 F2 14 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B14ED             0412*  
0B14ED DD E1       0413*      pop ix
0B14EF C1          0414*      pop bc
0B14F0 F1          0415*      pop af
0B14F1 C9          0416*      ret
0B14F2             0417*  
0B14F2 00          0418*  oldTimeStamp:   .db 00h
0B14F3             0025       include "vdu.inc"
0B14F3             0001*  
0B14F3             0002*  ; VDU 30: Home cursor
0B14F3             0003*  vdu_home_cursor:
0B14F3 3E 1E       0004*      ld a,30
0B14F5 5B D7       0005*  	rst.lil $10
0B14F7 C9          0006*  	ret
0B14F8             0007*  
0B14F8             0008*  cursor_on:
0B14F8 21 03 15 0B 0009*  	ld hl,@cmd
0B14FC 01 03 00 00 0010*  	ld bc,@end-@cmd
0B1500 5B DF       0011*  	rst.lil $18
0B1502 C9          0012*  	ret
0B1503             0013*  @cmd:
0B1503 17 01 01    0014*  	db 23,1,1
0B1506             0015*  @end:
0B1506             0016*  
0B1506             0017*  cursor_off:
0B1506 21 11 15 0B 0018*  	ld hl,@cmd
0B150A 01 03 00 00 0019*  	ld bc,@end-@cmd
0B150E 5B DF       0020*  	rst.lil $18
0B1510 C9          0021*  	ret
0B1511             0022*  @cmd:
0B1511 17 01 00    0023*  	db 23,1,0
0B1514             0024*  @end:
0B1514             0025*  
0B1514             0026*  ; VDU 9: Move cursor forward one character
0B1514             0027*  vdu_cursor_forward:
0B1514 3E 09       0028*      ld a,9
0B1516 5B D7       0029*  	rst.lil $10
0B1518 C9          0030*  	ret
0B1519             0031*  
0B1519             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B1519             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B1519             0034*  vdu_move_cursor:
0B1519 ED 43 2A 15 0035*      ld (@x0),bc
       0B          
0B151E 21 29 15 0B 0036*  	ld hl,@cmd
0B1522 01 03 00 00 0037*  	ld bc,@end-@cmd
0B1526 5B DF       0038*  	rst.lil $18
0B1528 C9          0039*  	ret
0B1529 1F          0040*  @cmd: 	db 31
0B152A 00          0041*  @x0:	db 0
0B152B 00          0042*  @y0: 	db 0
0B152C 00          0043*  @end: 	db 0 ; padding
0B152D             0044*  
0B152D             0045*  ; VDU 12: Clear text area (CLS)
0B152D             0046*  vdu_cls:
0B152D 3E 0C       0047*      ld a,12
0B152F 5B D7       0048*  	rst.lil $10
0B1531 C9          0049*  	ret
0B1532             0050*  
0B1532             0051*  vdu_flip:
0B1532 21 3D 15 0B 0052*  	ld hl,@cmd
0B1536 01 03 00 00 0053*  	ld bc,@end-@cmd
0B153A 5B DF       0054*  	rst.lil $18
0B153C C9          0055*  	ret
0B153D 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B1540             0057*  @end:
0B1540             0058*  
0B1540             0059*  ; VDU 16: Clear graphics area (CLG)
0B1540             0060*  vdu_clg:
0B1540 3E 10       0061*      ld a,16
0B1542 5B D7       0062*  	rst.lil $10
0B1544 C9          0063*  	ret
0B1545             0064*  
0B1545             0065*  ; COLOUR MODES
0B1545             0066*  ; Mode	Effect
0B1545             0067*  ; 0	Set on-screen pixel to target colour value
0B1545             0068*  ; 1	OR value with the on-screen pixel
0B1545             0069*  ; 2	AND value with the on-screen pixel
0B1545             0070*  ; 3	XOR value with the on-screen pixel
0B1545             0071*  ; 4	Invert the on-screen pixel
0B1545             0072*  ; 5	No operation
0B1545             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B1545             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B1545             0075*  
0B1545             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B1545             0077*  vdu_colour_text:
0B1545 32 55 15 0B 0078*  	ld (@arg),a
0B1549 21 54 15 0B 0079*  	ld hl,@cmd
0B154D 01 02 00 00 0080*  	ld bc,@end-@cmd
0B1551 5B DF       0081*  	rst.lil $18
0B1553 C9          0082*  	ret
0B1554 11          0083*  @cmd: db 17
0B1555 00          0084*  @arg: db 0
0B1556             0085*  @end:
0B1556             0086*  
0B1556             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B1556             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B1556             0089*  vdu_gcol:
0B1556 32 6B 15 0B 0090*  	ld (@mode),a
0B155A 79          0091*      ld a,c
0B155B 32 6C 15 0B 0092*      ld (@col),a
0B155F 21 6A 15 0B 0093*  	ld hl,@cmd
0B1563 01 03 00 00 0094*  	ld bc,@end-@cmd
0B1567 5B DF       0095*  	rst.lil $18
0B1569 C9          0096*  	ret
0B156A 12          0097*  @cmd:  db 18
0B156B 00          0098*  @mode: db 0
0B156C 00          0099*  @col:  db 0
0B156D             0100*  @end:
0B156D             0101*  
0B156D             0102*  
0B156D             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B156D             0104*  ; MIND THE LITTLE-ENDIANESS
0B156D             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B156D             0106*  ; outputs; nothing
0B156D             0107*  ; destroys: a might make it out alive
0B156D             0108*  vdu_set_txt_viewport:
0B156D ED 43 83 15 0109*      ld (@lb),bc
       0B          
0B1572 ED 53 85 15 0110*  	ld (@rt),de
       0B          
0B1577 21 82 15 0B 0111*  	ld hl,@cmd
0B157B 01 05 00 00 0112*  	ld bc,@end-@cmd
0B157F 5B DF       0113*  	rst.lil $18
0B1581 C9          0114*  	ret
0B1582 1C          0115*  @cmd:   db 28 ; set text viewport command
0B1583 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B1585 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B1587 00          0118*  @end:   db 0x00	  ; padding
0B1588             0119*  
0B1588             0120*  ; Wait for VBLANK interrupt
0B1588             0121*  vdu_vblank:
0B1588 DD E5       0122*      PUSH 	IX
0B158A             0123*  	MOSCALL	mos_sysvars
0B158A 3E 08       0001*M 			LD	A, function
0B158C 5B CF       0002*M 			RST.L	08h
0B158E DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B1591             0125*  @wait:
0B1591 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B1594 28 FB       0127*      JR	Z, @wait
0B1596 DD E1       0128*      POP	IX
0B1598 C9          0129*      RET
0B1599             0130*  
0B1599             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B1599             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B1599             0133*  ; 	because we have turned off logical screen scaling
0B1599             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B1599             0135*  ; outputs; nothing
0B1599             0136*  ; destroys: a might make it out alive
0B1599             0137*  vdu_set_gfx_viewport:
0B1599 ED 43 B9 15 0138*      ld (@x0),bc
       0B          
0B159E FD 22 BB 15 0139*      ld (@y1),iy
       0B          
0B15A3 DD 22 BD 15 0140*  	ld (@x1),ix
       0B          
0B15A8 ED 53 BF 15 0141*  	ld (@y0),de
       0B          
0B15AD 21 B8 15 0B 0142*  	ld hl,@cmd
0B15B1 01 09 00 00 0143*  	ld bc,@end-@cmd
0B15B5 5B DF       0144*  	rst.lil $18
0B15B7 C9          0145*  	ret
0B15B8 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B15B9 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B15BB 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B15BD 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B15BF 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B15C1 00          0151*  @end:   db 0x00	  ; padding
0B15C2             0152*  
0B15C2             0153*  ; SCREEN MODES
0B15C2             0154*  ; ===============================
0B15C2             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B15C2             0156*  ; ---   ----  ----  ----  -------
0B15C2             0157*  ; 11    320   240   2     60hz
0B15C2             0158*  ; 139   320   240   2     60hz
0B15C2             0159*  ; 23    512   384   2     60hz
0B15C2             0160*  ; 151   512   384   2     60hz
0B15C2             0161*  ; 6     640   240   2     60hz
0B15C2             0162*  ; 134   640   240   2     60hz
0B15C2             0163*  ; 2     640   480   2     60hz
0B15C2             0164*  ; 130   640   480   2     60hz
0B15C2             0165*  ; 17    800   600   2     60hz
0B15C2             0166*  ; 145   800   600   2     60hz
0B15C2             0167*  ; 18    1024  768   2     60hz
0B15C2             0168*  ; 146   1024  768   2     60hz
0B15C2             0169*  ; ---   ----  ----  ----  -------
0B15C2             0170*  ; 10    320   240   4     60hz
0B15C2             0171*  ; 138   320   240   4     60hz
0B15C2             0172*  ; 22    512   384   4     60hz
0B15C2             0173*  ; 150   512   384   4     60hz
0B15C2             0174*  ; 5     640   240   4     60hz
0B15C2             0175*  ; 133   640   240   4     60hz
0B15C2             0176*  ; 1     640   480   4     60hz
0B15C2             0177*  ; 129   640   480   4     60hz
0B15C2             0178*  ; 16    800   600   4     60hz
0B15C2             0179*  ; 19    1024  768   4     60hz
0B15C2             0180*  ; ---   ----  ----  ----  -------
0B15C2             0181*  ; 9     320   240   16    60hz
0B15C2             0182*  ; 137   320   240   16    60hz
0B15C2             0183*  ; 21    512   384   16    60hz
0B15C2             0184*  ; 149   512   384   16    60hz
0B15C2             0185*  ; 4     640   240   16    60hz
0B15C2             0186*  ; 132   640   240   16    60hz
0B15C2             0187*  ; 0     640   480   16    60hz
0B15C2             0188*  ; 7     n/a   n/a   16    60hz
0B15C2             0189*  ; ---   ----  ----  ----  -------
0B15C2             0190*  ; 8     320   240   64    60hz
0B15C2             0191*  ; 136   320   240   64    60hz
0B15C2             0192*  ; 20    512   384   64    60hz
0B15C2             0193*  ; 3     640   240   64    60hz
0B15C2             0194*  ; ---   ----  ----  ----  -------
0B15C2             0195*  vdu_set_screen_mode:
0B15C2 32 D2 15 0B 0196*  	ld (@arg),a
0B15C6 21 D1 15 0B 0197*  	ld hl,@cmd
0B15CA 01 02 00 00 0198*  	ld bc,@end-@cmd
0B15CE 5B DF       0199*  	rst.lil $18
0B15D0 C9          0200*  	ret
0B15D1 16          0201*  @cmd: db 22 ; set screen mode
0B15D2 00          0202*  @arg: db 0  ; screen mode parameter
0B15D3             0203*  @end:
0B15D3             0204*  
0B15D3             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B15D3             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B15D3             0207*  ; note: default setting on boot is scaling ON
0B15D3             0208*  vdu_set_scaling:
0B15D3 32 E5 15 0B 0209*  	ld (@arg),a
0B15D7 21 E2 15 0B 0210*  	ld hl,@cmd
0B15DB 01 04 00 00 0211*  	ld bc,@end-@cmd
0B15DF 5B DF       0212*  	rst.lil $18
0B15E1 C9          0213*  	ret
0B15E2 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B15E5 00          0215*  @arg: db 0  ; scaling on/off
0B15E6             0216*  @end:
0B15E6             0217*  
0B15E6             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B15E6             0219*  ; inputs: hl=bufferId
0B15E6             0220*  vdu_buff_select:
0B15E6 22 F8 15 0B 0221*  	ld (@bufferId),hl
0B15EA 21 F5 15 0B 0222*  	ld hl,@cmd
0B15EE 01 05 00 00 0223*  	ld bc,@end-@cmd
0B15F2 5B DF       0224*  	rst.lil $18
0B15F4 C9          0225*  	ret
0B15F5 17 1B 20    0226*  @cmd: db 23,27,0x20
0B15F8 00 00       0227*  @bufferId: dw 0x0000
0B15FA 00          0228*  @end: db 0x00 ; padding
0B15FB             0229*  
0B15FB             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B15FB             0231*  ; inputs: a=format; bc=width; de=height
0B15FB             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B15FB             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B15FB             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B15FB             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B15FB             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B15FB             0237*  ; 3 	Reserved for internal use by VDP (“native” format)
0B15FB             0238*  vdu_bmp_create:
0B15FB ED 43 17 16 0239*      ld (@width),bc
       0B          
0B1600 ED 53 19 16 0240*      ld (@height),de
       0B          
0B1605 32 1B 16 0B 0241*      ld (@fmt),a
0B1609 21 14 16 0B 0242*  	ld hl,@cmd
0B160D 01 08 00 00 0243*  	ld bc,@end-@cmd
0B1611 5B DF       0244*  	rst.lil $18
0B1613 C9          0245*  	ret
0B1614 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B1617 00 00       0247*  @width:     dw 0x0000
0B1619 00 00       0248*  @height:    dw 0x0000
0B161B 00          0249*  @fmt:       db 0x00
0B161C             0250*  @end:
0B161C             0251*  
0B161C             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B161C             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B161C             0254*  vdu_load_img_rgba2_to_8:
0B161C             0255*  ; backup the target buffer id and image dimensions
0B161C E5          0256*      push hl
0B161D D5          0257*      push de
0B161E C5          0258*      push bc
0B161F             0259*  ; load the rgba2 image to working buffer 65534
0B161F 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B1623 CD 26 17 0B 0261*  	call vdu_load_buffer_from_file
0B1627             0262*  ; restore the image dimensions and target buffer id
0B1627 C1          0263*      pop bc
0B1628 D1          0264*      pop de
0B1629 E1          0265*      pop hl
0B162A             0266*  ; fall through to vdu_rgba2_to_8
0B162A             0267*  
0B162A             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B162A             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B162A             0270*  ; the "expand bitmap" command is:
0B162A             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B162A             0272*  ; and then to reverse the byte order to fix endian-ness:
0B162A             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B162A             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B162A             0275*  ; VDU 23,27,&20,targetBufferID%;
0B162A             0276*  ; VDU 23,27,&21,width%;height%;0
0B162A             0277*  ; -------------------------------------------------------------------
0B162A             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B162A             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B162A             0280*  vdu_rgba2_to_8:
0B162A             0281*  ; load the image dimensions and buffer id parameters
0B162A ED 43 86 16 0282*      ld (@width),bc
       0B          
0B162F ED 53 88 16 0283*      ld (@height),de
       0B          
0B1634 22 6B 16 0B 0284*      ld (@bufferId0),hl
0B1638 22 78 16 0B 0285*      ld (@bufferId2),hl
0B163C 22 81 16 0B 0286*      ld (@bufferId1),hl
0B1640             0287*  ; clean up bytes that got stomped on by the ID loads
0B1640 3E 48       0288*      ld a,0x48
0B1642 32 6D 16 0B 0289*      ld (@bufferId0+2),a
0B1646 3E 17       0290*      ld a,23
0B1648 32 83 16 0B 0291*      ld (@bufferId1+2),a
0B164C 3E 18       0292*      ld a,24
0B164E 32 7A 16 0B 0293*      ld (@bufferId2+2),a
0B1652 AF          0294*      xor a
0B1653 32 8A 16 0B 0295*      ld (@height+2),a
0B1657             0296*  ; send the vdu command strings
0B1657 21 62 16 0B 0297*      ld hl,@beg
0B165B 01 29 00 00 0298*      ld bc,@end-@beg
0B165F 5B DF       0299*      rst.lil $18
0B1661 C9          0300*      ret
0B1662             0301*  @beg:
0B1662             0302*  ; Command 14: Consolidate blocks in a buffer
0B1662             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B1662 17 00 A0    0304*      db 23,0,0xA0
0B1665 FE FF       0305*      dw 65534 ; workingBufferId
0B1667 0E          0306*      db 14 ; consolidate blocks
0B1668             0307*  ; the "expand bitmap" command is:
0B1668             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B1668 17 00 A0    0309*      db 23,0,0xA0
0B166B 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B166D 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B166E 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B166F FE FF       0313*      dw 65534 ; sourceBufferId
0B1671 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B1675             0315*  ; reverse the byte order to fix endian-ness:
0B1675             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B1675             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B1675             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B1675 17 00 A0    0319*      db 23,0,0xA0
0B1678 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B167A 18          0321*      db 24 ; reverse byte order
0B167B 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B167C 04 00       0323*      dw 4 ; size (4 bytes)
0B167E             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B167E             0325*  ; VDU 23,27,&20,targetBufferID%;
0B167E 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B1681 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B1683             0328*  ; VDU 23,27,&21,width%;height%;0
0B1683 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B1686 00 00       0330*  @width: dw 0x0000
0B1688 00 00       0331*  @height: dw 0x0000
0B168A 00          0332*      db 0x00 ; rgba8888 format
0B168B             0333*  @end:
0B168B             0334*  
0B168B             0335*  ; scratch variables
0B168B 00 00 00    0336*  bufferId0: dl 0x000000
0B168E 00 00 00    0337*  bufferId1: dl 0x000000
0B1691             0338*  
0B1691             0339*  ; load a vdu buffer from local memory
0B1691             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1691             0341*  vdu_load_buffer:
0B1691 ED 43 BA 16 0342*      ld (@length),bc
       0B          
0B1696 D5          0343*      push de ; save data pointer
0B1697             0344*  ; send the vdu command string
0B1697 7D          0345*      ld a,l
0B1698 32 B7 16 0B 0346*      ld (@bufferId),a
0B169C 7C          0347*      ld a,h
0B169D 32 B8 16 0B 0348*      ld (@bufferId+1),a
0B16A1 21 B4 16 0B 0349*      ld hl,@cmd
0B16A5 01 08 00 00 0350*      ld bc,@end-@cmd
0B16A9 5B DF       0351*      rst.lil $18
0B16AB             0352*  ; send the buffer data
0B16AB E1          0353*      pop hl ; pointer to data
0B16AC ED 4B BA 16 0354*      ld bc,(@length)
       0B          
0B16B1 5B DF       0355*      rst.lil $18 ; send it
0B16B3 C9          0356*      ret
0B16B4             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B16B4 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B16B7 00 00       0359*  @bufferId:	dw 0x0000
0B16B9 00          0360*  		    db 0 ; load buffer
0B16BA 00 00       0361*  @length:	dw 0x0000
0B16BC 00          0362*  @end: db 0 ; padding
0B16BD             0363*  
0B16BD             0364*  ; clear a buffer
0B16BD             0365*  ; inputs: hl = bufferId
0B16BD             0366*  vdu_clear_buffer:
0B16BD 7D          0367*      ld a,l
0B16BE 32 D5 16 0B 0368*      ld (@bufferId),a
0B16C2 7C          0369*      ld a,h
0B16C3 32 D6 16 0B 0370*      ld (@bufferId+1),a
0B16C7 21 D2 16 0B 0371*      ld hl,@cmd
0B16CB 01 06 00 00 0372*      ld bc,@end-@cmd
0B16CF 5B DF       0373*      rst.lil $18
0B16D1 C9          0374*      ret
0B16D2 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B16D5 00 00       0376*  @bufferId:	dw 0x0000
0B16D7 02          0377*  		    db 2 ; clear buffer
0B16D8             0378*  @end:
0B16D8             0379*  
0B16D8             0380*  vdu_clear_all_buffers:
0B16D8             0381*  ; clear all buffers
0B16D8 21 E3 16 0B 0382*      ld hl,@beg
0B16DC 01 06 00 00 0383*      ld bc,@end-@beg
0B16E0 5B DF       0384*      rst.lil $18
0B16E2 C9          0385*      ret
0B16E3 17 00 A0    0386*  @beg: db 23,0,$A0
0B16E6 FF FF       0387*        dw -1 ; clear all buffers
0B16E8 02          0388*        db 2  ; command 2: clear a buffer
0B16E9             0389*  @end:
0B16E9             0390*  
0B16E9             0391*  ; Command 14: Consolidate blocks in a buffer
0B16E9             0392*  vdu_consolidate_buffer:
0B16E9             0393*  ; set parameters for vdu call
0B16E9 7D          0394*      ld a,l
0B16EA 32 01 17 0B 0395*      ld (@bufferId),a
0B16EE 7C          0396*      ld a,h
0B16EF 32 02 17 0B 0397*      ld (@bufferId+1),a
0B16F3 21 FE 16 0B 0398*      ld hl,@beg
0B16F7 01 06 00 00 0399*      ld bc,@end-@beg
0B16FB 5B DF       0400*      rst.lil $18
0B16FD C9          0401*      ret
0B16FE             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B16FE 17 00 A0    0403*  @beg: db 23,0,0xA0
0B1701 00 00       0404*  @bufferId: dw 0x0000
0B1703 0E          0405*             db 14
0B1704             0406*  @end:
0B1704             0407*  
0B1704             0408*  ; load an image file to a buffer and make it a bitmap
0B1704             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B1704             0410*  vdu_load_img:
0B1704             0411*  ; back up image type and dimension parameters
0B1704 22 8B 16 0B 0412*      ld (bufferId0),hl
0B1708 F5          0413*      push af
0B1709 C5          0414*  	push bc
0B170A D5          0415*  	push de
0B170B             0416*  ; load the image
0B170B CD 26 17 0B 0417*  	call vdu_load_buffer_from_file
0B170F             0418*  ; now make it a bitmap
0B170F 2A 8B 16 0B 0419*      ld hl,(bufferId0)
0B1713 CD E9 16 0B 0420*      call vdu_consolidate_buffer
0B1717 2A 8B 16 0B 0421*      ld hl,(bufferId0)
0B171B CD E6 15 0B 0422*      call vdu_buff_select
0B171F D1          0423*  	pop de ; image height
0B1720 C1          0424*  	pop bc ; image width
0B1721 F1          0425*  	pop af ; image type
0B1722 C3 FB 15 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B1726             0427*  
0B1726             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B1726             0429*  vdu_load_buffer_from_file:
0B1726 22 8B 16 0B 0430*      ld (bufferId0),hl
0B172A             0431*  
0B172A             0432*  ; clear target buffer
0B172A CD BD 16 0B 0433*      call vdu_clear_buffer
0B172E             0434*  
0B172E             0435*  ; open the file in read mode
0B172E             0436*  ; Open a file
0B172E             0437*  ; HLU: Filename
0B172E             0438*  ;   C: Mode
0B172E             0439*  ; Returns:
0B172E             0440*  ;   A: Filehandle, or 0 if couldn't open
0B172E FD E5       0441*  	push iy ; pointer to filename
0B1730 E1          0442*  	pop hl
0B1731 0E 01       0443*  	ld c,fa_read
0B1733             0444*      MOSCALL mos_fopen
0B1733 3E 0A       0001*M 			LD	A, function
0B1735 5B CF       0002*M 			RST.L	08h
0B1737 32 72 17 0B 0445*      ld (@filehandle),a
0B173B             0446*  
0B173B             0447*  @read_file:
0B173B             0448*  ; Read a block of data from a file
0B173B             0449*  ;   C: Filehandle
0B173B             0450*  ; HLU: Pointer to where to write the data to
0B173B             0451*  ; DEU: Number of bytes to read
0B173B             0452*  ; Returns:
0B173B             0453*  ; DEU: Number of bytes read
0B173B 3A 72 17 0B 0454*      ld a,(@filehandle)
0B173F 4F          0455*      ld c,a
0B1740 21 00 E0 B7 0456*      ld hl,filedata
0B1744 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B1748             0458*      MOSCALL mos_fread
0B1748 3E 1A       0001*M 			LD	A, function
0B174A 5B CF       0002*M 			RST.L	08h
0B174C             0459*  
0B174C             0460*  ; ; DEBUG: print chunk size
0B174C             0461*  ;     push de
0B174C             0462*  ;     pop hl
0B174C             0463*  ;     call printDec
0B174C             0464*  ;     call printNewLine
0B174C             0465*  
0B174C             0466*  ; test de for zero bytes read
0B174C 21 00 00 00 0467*      ld hl,0
0B1750 AF          0468*      xor a ; clear carry
0B1751 ED 52       0469*      sbc hl,de
0B1753 CA 69 17 0B 0470*      jp z,@close_file
0B1757             0471*  
0B1757             0472*  ; load a vdu buffer from local memory
0B1757             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B1757 2A 8B 16 0B 0474*      ld hl,(bufferId0)
0B175B D5          0475*      push de ; chunksize
0B175C C1          0476*      pop bc
0B175D 11 00 E0 B7 0477*      ld de,filedata
0B1761 CD 91 16 0B 0478*      call vdu_load_buffer
0B1765             0479*  
0B1765             0480*  ; ; print progress breadcrumbs
0B1765             0481*  ;     ld a,'.'
0B1765             0482*  ;     rst.lil 10h
0B1765             0483*  
0B1765             0484*  ; read the next block
0B1765 C3 3B 17 0B 0485*      jp @read_file
0B1769             0486*  
0B1769             0487*  ; close the file
0B1769             0488*  @close_file:
0B1769 3A 72 17 0B 0489*      ld a,(@filehandle)
0B176D             0490*      MOSCALL mos_fclose
0B176D 3E 0B       0001*M 			LD	A, function
0B176F 5B CF       0002*M 			RST.L	08h
0B1771 C9          0491*      ret ; vdu_load_buffer_from_file
0B1772             0492*  
0B1772 00          0493*  @filehandle: db 0 ; file handle
0B1773 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B1776             0495*  
0B1776 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B1779             0497*  
0B1779             0498*  ; File information structure (FILINFO)
0B1779             0499*  @filinfo:
0B1779 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B177D 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B177F 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B1781 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B1782 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B178F 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B188F             0026       ; include "vdu_fonts.inc"
0B188F             0027       include "vdu_plot.inc"
0B188F             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B188F             0002*  ; PLOT code 	(Decimal) 	Effect
0B188F             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B188F             0004*  plot_sl_both: equ 0x00
0B188F             0005*  
0B188F             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B188F             0007*  plot_sl_first: equ 0x08
0B188F             0008*  
0B188F             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B188F             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B188F             0011*  
0B188F             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B188F             0013*  plot_sl_last: equ 0x20
0B188F             0014*  
0B188F             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B188F             0016*  plot_sl_none: equ 0x28
0B188F             0017*  
0B188F             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B188F             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B188F             0020*  
0B188F             0021*  ; &40-&47 	64-71 	Point plot
0B188F             0022*  plot_pt: equ 0x40
0B188F             0023*  
0B188F             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0B188F             0025*  plot_lf_lr_non_bg: equ 0x48
0B188F             0026*  
0B188F             0027*  ; &50-&57 	80-87 	Triangle fill
0B188F             0028*  plot_tf: equ 0x50
0B188F             0029*  
0B188F             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0B188F             0031*  plot_lf_r_bg: equ 0x58
0B188F             0032*  
0B188F             0033*  ; &60-&67 	96-103 	Rectangle fill
0B188F             0034*  plot_rf: equ 0x60
0B188F             0035*  
0B188F             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0B188F             0037*  plot_lf_lr_fg: equ 0x60
0B188F             0038*  
0B188F             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B188F             0040*  plot_pf: equ 0x70
0B188F             0041*  
0B188F             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0B188F             0043*  plot_lf_r_non_fg: equ 0x78
0B188F             0044*  
0B188F             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B188F             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B188F             0047*  
0B188F             0048*  ; &90-&97 	144-151 	Circle outline
0B188F             0049*  plot_co: equ 0x90
0B188F             0050*  
0B188F             0051*  ; &98-&9F 	152-159 	Circle fill
0B188F             0052*  plot_cf: equ 0x98
0B188F             0053*  
0B188F             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B188F             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B188F             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B188F             0057*  
0B188F             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B188F             0059*  plot_rcm: equ 0xB8
0B188F             0060*  
0B188F             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B188F             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B188F             0063*  ; &D0-&D7 	208-215 	Not defined
0B188F             0064*  ; &D8-&DF 	216-223 	Not defined
0B188F             0065*  ; &E0-&E7 	224-231 	Not defined
0B188F             0066*  
0B188F             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0B188F             0068*  plot_bmp: equ 0xE8
0B188F             0069*  
0B188F             0070*  ; &F0-&F7 	240-247 	Not defined
0B188F             0071*  ; &F8-&FF 	248-255 	Not defined
0B188F             0072*  
0B188F             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0B188F             0074*  ; Agon Console8 VDP 2.2.0
0B188F             0075*  
0B188F             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B188F             0077*  ; Plot code 	Effect
0B188F             0078*  ; 0 	Move relative
0B188F             0079*  mv_rel: equ 0
0B188F             0080*  
0B188F             0081*  ; 1 	Plot relative in current foreground colour
0B188F             0082*  dr_rel_fg: equ 1
0B188F             0083*  
0B188F             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B188F             0085*  ; 3 	Plot relative in current background colour
0B188F             0086*  dr_rel_bg: equ 3
0B188F             0087*  
0B188F             0088*  ; 4 	Move absolute
0B188F             0089*  mv_abs: equ 4
0B188F             0090*  
0B188F             0091*  ; 5 	Plot absolute in current foreground colour
0B188F             0092*  dr_abs_fg: equ 5
0B188F             0093*  
0B188F             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B188F             0095*  ; 7 	Plot absolute in current background colour
0B188F             0096*  dr_abs_bg: equ 7
0B188F             0097*  
0B188F             0098*  ; Codes 0-3 use the position data provided as part of the command
0B188F             0099*  ; as a relative position, adding the position given to the current
0B188F             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B188F             0101*  ; as part of the command as an absolute position, setting the current
0B188F             0102*  ; graphical cursor position to the position given.
0B188F             0103*  
0B188F             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B188F             0105*  ; current pixel colour. These operations cannot currently be supported
0B188F             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B188F             0107*  ; supported. Support for these codes may be added in a future version
0B188F             0108*  ; of the VDP firmware.
0B188F             0109*  
0B188F             0110*  ; 16 colour palette constants
0B188F             0111*  c_black: equ 0
0B188F             0112*  c_red_dk: equ 1
0B188F             0113*  c_green_dk: equ 2
0B188F             0114*  c_yellow_dk: equ 3
0B188F             0115*  c_blue_dk: equ 4
0B188F             0116*  c_magenta_dk: equ 5
0B188F             0117*  c_cyan_dk: equ 6
0B188F             0118*  c_grey: equ 7
0B188F             0119*  c_grey_dk: equ 8
0B188F             0120*  c_red: equ 9
0B188F             0121*  c_green: equ 10
0B188F             0122*  c_yellow: equ 11
0B188F             0123*  c_blue: equ 12
0B188F             0124*  c_magenta: equ 13
0B188F             0125*  c_cyan: equ 14
0B188F             0126*  c_white: equ 15
0B188F             0127*  
0B188F             0128*  ; VDU 25, mode, x; y;: PLOT command
0B188F             0129*  ; inputs: a=mode, bc=x0, de=y0
0B188F             0130*  vdu_plot:
0B188F 32 A9 18 0B 0131*      ld (@mode),a
0B1893 ED 43 AA 18 0132*      ld (@x0),bc
       0B          
0B1898 ED 53 AC 18 0133*      ld (@y0),de
       0B          
0B189D 21 A8 18 0B 0134*  	ld hl,@cmd
0B18A1 01 06 00 00 0135*  	ld bc,@end-@cmd
0B18A5 5B DF       0136*  	rst.lil $18
0B18A7 C9          0137*  	ret
0B18A8 19          0138*  @cmd:   db 25
0B18A9 00          0139*  @mode:  db 0
0B18AA 00 00       0140*  @x0: 	dw 0
0B18AC 00 00       0141*  @y0: 	dw 0
0B18AE 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B18AF             0143*  
0B18AF             0144*  ; VDU 25, mode, x; y;: PLOT command
0B18AF             0145*  ; USING 16.8 FIXED POINT COORDINATES
0B18AF             0146*  ; inputs: a=mode, ub.c=x0, ud.e=y0
0B18AF             0147*  vdu_plot_168:
0B18AF ED 43 C9 18 0148*      ld (@x0-1),bc ; integer portion only
       0B          
0B18B4 ED 53 CB 18 0149*      ld (@y0-1),de ; ibid
       0B          
0B18B9 32 C9 18 0B 0150*      ld (@mode),a  ; load this order b/c we shifted bc right
0B18BD 21 C8 18 0B 0151*  	ld hl,@cmd
0B18C1 01 06 00 00 0152*  	ld bc,@end-@cmd
0B18C5 5B DF       0153*  	rst.lil $18
0B18C7 C9          0154*  	ret
0B18C8 19          0155*  @cmd:   db 25
0B18C9 00          0156*  @mode:  db 0
0B18CA 00 00       0157*  @x0: 	dw 0
0B18CC 00 00       0158*  @y0: 	dw 0
0B18CE             0159*  @end:  ; no padding required b/c we shifted de right
0B18CE             0160*  
0B18CE             0161*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B18CE             0162*  ; &E8-&EF 	232-239 	Bitmap plot §
0B18CE             0163*  ; VDU 25, mode, x; y;: PLOT command
0B18CE             0164*  ; inputs: bc=x0, de=y0
0B18CE             0165*  ; prerequisites: vdu_buff_select
0B18CE             0166*  vdu_plot_bmp:
0B18CE ED 43 E5 18 0167*      ld (@x0),bc
       0B          
0B18D3 ED 53 E7 18 0168*      ld (@y0),de
       0B          
0B18D8 21 E3 18 0B 0169*  	ld hl,@cmd
0B18DC 01 06 00 00 0170*  	ld bc,@end-@cmd
0B18E0 5B DF       0171*  	rst.lil $18
0B18E2 C9          0172*  	ret
0B18E3 19          0173*  @cmd:   db 25
0B18E4 ED          0174*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B18E5 00 00       0175*  @x0: 	dw 0x0000
0B18E7 00 00       0176*  @y0: 	dw 0x0000
0B18E9 00          0177*  @end:   db 0x00 ; padding
0B18EA             0178*  
0B18EA             0179*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B18EA             0180*  ; &E8-&EF 	232-239 	Bitmap plot §
0B18EA             0181*  ; VDU 25, mode, x; y;: PLOT command
0B18EA             0182*  ; inputs: bc=x0, de=y0
0B18EA             0183*  ; USING 16.8 FIXED POINT COORDINATES
0B18EA             0184*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B18EA             0185*  ;   the fractional portiion of the inputs are truncated
0B18EA             0186*  ;   leaving only the 16-bit integer portion
0B18EA             0187*  ; prerequisites: vdu_buff_select
0B18EA             0188*  vdu_plot_bmp168:
0B18EA             0189*  ; populate in the reverse of normal to keep the
0B18EA             0190*  ; inputs from stomping on each other
0B18EA ED 53 08 19 0191*      ld (@y0-1),de
       0B          
0B18EF ED 43 06 19 0192*      ld (@x0-1),bc
       0B          
0B18F4 3E ED       0193*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B18F6 32 06 19 0B 0194*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B18FA 21 05 19 0B 0195*  	ld hl,@cmd
0B18FE 01 06 00 00 0196*  	ld bc,@end-@cmd
0B1902 5B DF       0197*  	rst.lil $18
0B1904 C9          0198*  	ret
0B1905 19          0199*  @cmd:   db 25
0B1906 ED          0200*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B1907 00 00       0201*  @x0: 	dw 0x0000
0B1909 00 00       0202*  @y0: 	dw 0x0000
0B190B             0203*  @end:  ; no padding required b/c we shifted de right
0B190B             0204*  
0B190B             0205*  ; draw a filled rectangle
0B190B             0206*  vdu_plot_rf:
0B190B ED 43 32 19 0207*      ld (@x0),bc
       0B          
0B1910 ED 53 34 19 0208*      ld (@y0),de
       0B          
0B1915 DD 22 38 19 0209*      ld (@x1),ix
       0B          
0B191A FD 22 3A 19 0210*      ld (@y1),iy
       0B          
0B191F 3E 19       0211*      ld a,25 ; we have to reload the 2nd plot command
0B1921 32 36 19 0B 0212*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1925 21 30 19 0B 0213*  	ld hl,@cmd0
0B1929 01 0C 00 00 0214*  	ld bc,@end-@cmd0
0B192D 5B DF       0215*  	rst.lil $18
0B192F C9          0216*      ret
0B1930 19          0217*  @cmd0:  db 25 ; plot
0B1931 04          0218*  @arg0:  db plot_sl_both+mv_abs
0B1932 00 00       0219*  @x0:    dw 0x0000
0B1934 00 00       0220*  @y0:    dw 0x0000
0B1936 19          0221*  @cmd1:  db 25 ; plot
0B1937 65          0222*  @arg1:  db plot_rf+dr_abs_fg
0B1938 00 00       0223*  @x1:    dw 0x0000
0B193A 00 00       0224*  @y1:    dw 0x0000
0B193C 00          0225*  @end:   db 0x00 ; padding
0B193D             0226*  
0B193D             0227*  ; draw a filled circle
0B193D             0228*  vdu_plot_cf:
0B193D ED 43 64 19 0229*      ld (@x0),bc
       0B          
0B1942 ED 53 66 19 0230*      ld (@y0),de
       0B          
0B1947 DD 22 6A 19 0231*      ld (@x1),ix
       0B          
0B194C FD 22 6C 19 0232*      ld (@y1),iy
       0B          
0B1951 3E 19       0233*      ld a,25 ; we have to reload the 2nd plot command
0B1953 32 68 19 0B 0234*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B1957 21 62 19 0B 0235*  	ld hl,@cmd0
0B195B 01 0C 00 00 0236*  	ld bc,@end-@cmd0
0B195F 5B DF       0237*  	rst.lil $18
0B1961 C9          0238*      ret
0B1962 19          0239*  @cmd0:  db 25 ; plot
0B1963 04          0240*  @arg0:  db plot_sl_both+mv_abs
0B1964 00 00       0241*  @x0:    dw 0x0000
0B1966 00 00       0242*  @y0:    dw 0x0000
0B1968 19          0243*  @cmd1:  db 25 ; plot
0B1969 9D          0244*  @arg1:  db plot_cf+dr_abs_fg
0B196A 00 00       0245*  @x1:    dw 0x0000
0B196C 00 00       0246*  @y1:    dw 0x0000
0B196E 00          0247*  @end:   db 0x00 ; padding
0B196F             0248*  
0B196F             0249*  ; VDU 25, mode, x; y;: PLOT command
0B196F             0250*  ; inputs: a=mode, ix=x0, iy=y0
0B196F             0251*  plot:
0B196F 32 89 19 0B 0252*      ld (@mode),a
0B1973 DD 22 8A 19 0253*      ld (@x0),ix
       0B          
0B1978 FD 22 8C 19 0254*      ld (@y0),iy
       0B          
0B197D 21 88 19 0B 0255*  	ld hl,@cmd
0B1981 01 06 00 00 0256*  	ld bc,@end-@cmd
0B1985 5B DF       0257*  	rst.lil $18
0B1987 C9          0258*  	ret
0B1988 19          0259*  @cmd:   db 25
0B1989 00          0260*  @mode:  db 0
0B198A 00 00       0261*  @x0: 	dw 0
0B198C 00 00       0262*  @y0: 	dw 0
0B198E 00          0263*  @end:   db 0 ; padding
0B198F             0264*  
0B198F             0265*  ; VDU 5: Write text at graphics cursor
0B198F             0266*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B198F             0267*  ; prerequisites: gcol foreground set, VDU 5 set
0B198F             0268*  plot_text:
0B198F E5          0269*      push hl ; save text pointer
0B1990             0270*  ; move graphics cursor to x0, y0
0B1990 3E 44       0271*      ld a,plot_pt+mv_abs
0B1992 CD 6F 19 0B 0272*      call plot
0B1996             0273*  ; write text
0B1996 E1          0274*      pop hl ; restore text pointer
0B1997 CD 73 02 0B 0275*      call printString
0B199B C9          0276*      ret
0B199C             0028   
0B199C             0029   ; SHAWN'S INCLUDES
0B199C             0030   	INCLUDE	"strings24.asm"
0B199C             0001*  ;------------------------------------------------------------------------
0B199C             0002*  ;  strings24.asm
0B199C             0003*  ;
0B199C             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B199C             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B199C             0006*  ;  MIT license
0B199C             0007*  ;------------------------------------------------------------------------
0B199C             0008*  
0B199C             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B199C             0010*  ; and postpended with a minus sign if was negative
0B199C             0011*  ; Uses HLU, DEU, BCU
0B199C             0012*  print_HLU_s24:
0B199C CD DA 07 0B 0013*  	call abs_hlu
0B19A0 F5          0014*  	push af ; save the sign and zero flags
0B19A1 CD AC 19 0B 0015*  	call print_HLU_u24
0B19A5 F1          0016*  	pop af
0B19A6 F0          0017*  	ret p ; HLU was positive so nothig more to do
0B19A7 3E 2D       0018*  	ld a,'-'
0B19A9 5B D7       0019*  	rst.lil 10h
0B19AB C9          0020*  	ret
0B19AC             0021*  
0B19AC             0022*  ;------------------------------------------------------------------------
0B19AC             0023*  ;Full print and buffer routine so you can adjust behaviour
0B19AC             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B19AC             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B19AC             0026*  ;Print value in HLU in decimal with leading 0s removed
0B19AC             0027*  ; Uses HLU, DEU, BCU
0B19AC             0028*  ;------------------------------------------------------------------------
0B19AC             0029*  
0B19AC             0030*  print_HLU_u24:
0B19AC 22 89 1A 0B 0031*  	ld	(hex_temp),hl
0B19B0 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B19B2 11 8C 1A 0B 0033*  	ld	de,outbuf
0B19B6 D5          0034*  	push	de
0B19B7 21 07 00 00 0035*  	ld	hl,7
0B19BB 19          0036*  	add	hl,de
0B19BC E5          0037*  	push	hl
0B19BD D1          0038*  	pop	de	;copy HLU to DEU
0B19BE AF          0039*  	xor	a
0B19BF             0040*  _pde_u_zerobuf:
0B19BF 77          0041*  	ld	(hl),a	;zero out the output
0B19C0 2B          0042*  	dec	hl
0B19C1 10 FC       0043*  	djnz	_pde_u_zerobuf
0B19C3             0044*  
0B19C3 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B19C5             0046*  _bcd_Convert:
0B19C5             0047*  
0B19C5 21 89 1A 0B 0048*  	ld hl,hex_temp
0B19C9             0049*  ;
0B19C9 CB 26       0050*  	sla (hl)
0B19CB 23          0051*  	inc hl
0B19CC CB 16       0052*  	rl (hl)
0B19CE 23          0053*  	inc hl
0B19CF CB 16       0054*  	rl (hl)		;24 bits rolled right
0B19D1             0055*  
0B19D1             0056*  
0B19D1 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B19D3 D5          0058*  	push	de
0B19D4 E1          0059*  	pop	hl
0B19D5             0060*  
0B19D5             0061*  _bcd_Add3:
0B19D5 7E          0062*  	ld	a,(hl)
0B19D6 8F          0063*  	adc	a
0B19D7 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B19D8 FE 10       0065*  	cp	10h	;did we roll over nibble?
0B19DA 3F          0066*  	ccf
0B19DB CB A7       0067*  	res	4,a
0B19DD             0068*  
0B19DD 77          0069*          ld (hl),a
0B19DE 2B          0070*  	dec	hl
0B19DF 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B19E1 0D          0072*          dec c
0B19E2 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B19E4             0074*  
0B19E4             0075*  
0B19E4 E1          0076*  	pop	hl
0B19E5 E5          0077*  	push	hl
0B19E6 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B19E8             0079*  _pde_u_make_ascii:
0B19E8 7E          0080*  	ld	a,(hl)
0B19E9 B7          0081*  	or	a
0B19EA 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B19EC 36 20       0083*  	ld	(hl),' '
0B19EE 23          0084*  	inc	hl
0B19EF 10 F7       0085*  	djnz	_pde_u_make_ascii
0B19F1             0086*  _pde_u_make_ascii2:
0B19F1 04          0087*  	inc	b
0B19F2             0088*  _pde_u_make_ascii3:
0B19F2 7E          0089*  	ld	a,(hl)
0B19F3 F6 30       0090*  	or	30h
0B19F5 77          0091*  	ld	(hl),a
0B19F6 23          0092*  	inc	hl
0B19F7 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B19F9             0094*  
0B19F9 E1          0095*  	pop	hl
0B19FA 06 08       0096*  	ld	b,8
0B19FC             0097*  _pde_u_final_out:
0B19FC 7E          0098*  	ld	a,(hl)
0B19FD 23          0099*  	inc	hl
0B19FE FE 20       0100*  	cp	' '
0B1A00 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B1A02 5B D7       0102*  	rst.lil	10h
0B1A04             0103*  _pde_u_final_out_strip:
0B1A04 10 F6       0104*  	djnz	_pde_u_final_out
0B1A06 C9          0105*  	ret
0B1A07             0106*  
0B1A07             0107*  ;------------------------------------------------------------------------
0B1A07             0108*  ; is_digit
0B1A07             0109*  ; C flag set if A is a digit
0B1A07             0110*  ; preserves all registers
0B1A07             0111*  ;------------------------------------------------------------------------
0B1A07             0112*  is_digit:
0B1A07 FE 30       0113*  	cp	'0'
0B1A09 3F          0114*  	ccf
0B1A0A D0          0115*  	ret	nc	;less that '0'
0B1A0B FE 3A       0116*  	cp	'9' + 1
0B1A0D C9          0117*  	ret
0B1A0E             0118*  
0B1A0E             0119*  
0B1A0E             0120*  ;------------------------------------------------------------------------
0B1A0E             0121*  ; char2hex
0B1A0E             0122*  ; Input: ASCII nibble in A
0B1A0E             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B1A0E             0124*  ;------------------------------------------------------------------------
0B1A0E             0125*  char2hex:
0B1A0E FE 30       0126*  	CP	'0'
0B1A10 38 1D       0127*  	JR	C, char_not_hex
0B1A12 FE 3A       0128*  	CP	'9' + 1
0B1A14 30 03       0129*  	JR	NC, char_not_09
0B1A16 D6 30       0130*  	sub	'0'
0B1A18 C9          0131*  	ret
0B1A19             0132*  
0B1A19             0133*  char_not_09:
0B1A19             0134*  	; char is not 0 to 9. Try upper case
0B1A19 FE 41       0135*  	CP	'A'
0B1A1B 38 12       0136*  	JR	C, char_not_hex
0B1A1D FE 47       0137*  	CP	'F' + 1
0B1A1F 30 03       0138*  	JR	NC, char_not_AF
0B1A21 D6 37       0139*  	sub	'A'-10
0B1A23 C9          0140*  	ret
0B1A24             0141*  
0B1A24             0142*  char_not_AF:
0B1A24             0143*  	; char is not upper case A-F. Try lower
0B1A24 FE 61       0144*  	CP	'a'
0B1A26 38 07       0145*  	JR	C, char_not_hex
0B1A28 FE 67       0146*  	CP	'f' + 1
0B1A2A 30 03       0147*  	JR	NC, char_not_hex
0B1A2C D6 57       0148*  	sub	'a' - 10
0B1A2E C9          0149*  	RET
0B1A2F             0150*  
0B1A2F             0151*  char_not_hex:
0B1A2F 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B1A31 C9          0153*  	RET
0B1A32             0154*  
0B1A32             0155*  ;------------------------------------------------------------------------
0B1A32             0156*  ;  newline
0B1A32             0157*  ;  Output CR+LF; all registers preserved
0B1A32             0158*  ;------------------------------------------------------------------------
0B1A32             0159*  newline:
0B1A32 F5          0160*         push   AF
0B1A33 3E 0D       0161*         LD     A, 13
0B1A35 5B D7       0162*         RST.LIL    10h
0B1A37 3E 0A       0163*         LD     A, 10
0B1A39 5B D7       0164*         RST.LIL    10h
0B1A3B F1          0165*         POP    AF
0B1A3C C9          0166*         RET
0B1A3D             0167*  
0B1A3D             0168*  ;------------------------------------------------------------------------
0B1A3D             0169*  ;  put_nibble
0B1A3D             0170*  ;  Output a single hex nibble in A
0B1A3D             0171*  ;  All registers preserved
0B1A3D             0172*  ;------------------------------------------------------------------------
0B1A3D             0173*  put_nibble:
0B1A3D F5          0174*  	push   AF
0B1A3E C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B1A40 27          0176*  	daa
0B1A41 CE 40       0177*  	adc    a,040h
0B1A43 27          0178*  	daa
0B1A44 5B D7       0179*  	RST.LIL    10h	;output character in A
0B1A46 F1          0180*  	pop    AF
0B1A47 C9          0181*  	ret
0B1A48             0182*  
0B1A48             0183*  ;------------------------------------------------------------------------
0B1A48             0184*  ;  print_A
0B1A48             0185*  ;  Output the 8-bit hex number A
0B1A48             0186*  ;  All registers preserved
0B1A48             0187*  ;------------------------------------------------------------------------
0B1A48             0188*  print_A:
0B1A48 F5          0189*  	push 	AF
0B1A49 F5          0190*  	push 	AF	;save for second nibble
0B1A4A 0F          0191*  	rrca
0B1A4B 0F          0192*  	rrca
0B1A4C 0F          0193*  	rrca
0B1A4D 0F          0194*  	rrca
0B1A4E E6 0F       0195*  	and	0Fh	;first nibble
0B1A50 CD 3D 1A 0B 0196*  	call	put_nibble
0B1A54 F1          0197*  	pop 	AF
0B1A55 E6 0F       0198*  	and	0Fh	;second nibble
0B1A57 CD 3D 1A 0B 0199*  	call	put_nibble
0B1A5B F1          0200*  	pop 	AF
0B1A5C C9          0201*  	ret
0B1A5D             0202*  
0B1A5D             0203*  ;------------------------------------------------------------------------
0B1A5D             0204*  ;  print_HLU_hex
0B1A5D             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B1A5D             0206*  ;------------------------------------------------------------------------
0B1A5D             0207*  print_HLU_hex:
0B1A5D F5          0208*         push   AF
0B1A5E 22 89 1A 0B 0209*         ld     (hex_temp),hl
0B1A62 3A 8B 1A 0B 0210*         ld     a,(hex_temp+2)
0B1A66 CD 48 1A 0B 0211*         call   print_A
0B1A6A 3A 8A 1A 0B 0212*         ld     a,(hex_temp+1)
0B1A6E CD 48 1A 0B 0213*         call   print_A
0B1A72 3A 89 1A 0B 0214*         ld     a,(hex_temp)
0B1A76 CD 48 1A 0B 0215*         call   print_A
0B1A7A F1          0216*         POP    AF
0B1A7B C9          0217*         RET
0B1A7C             0218*  
0B1A7C             0219*  ;------------------------------------------------------------------------
0B1A7C             0220*  ;  puts
0B1A7C             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B1A7C             0222*  ;  registers preserved.
0B1A7C             0223*  ;------------------------------------------------------------------------
0B1A7C             0224*  puts:
0B1A7C F5          0225*         push   AF
0B1A7D C5          0226*         push   BC
0B1A7E 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B1A82 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B1A84 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B1A86 C1          0230*         pop    BC
0B1A87 F1          0231*         pop    AF
0B1A88 C9          0232*         ret
0B1A89             0233*  
0B1A89             0234*  ;------------------------------------------------------------------------
0B1A89             0235*  ; Data area
0B1A89             0236*  ; Storage for 24 bit conversion
0B1A89             0237*  ;------------------------------------------------------------------------
0B1A89             0238*  hex_temp:
0B1A89 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B1A8C             0240*  
0B1A8C             0241*  outbuf:
0B1A8C 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B1A95             0031   
0B1A95             0032   ; APPLICATION INCLUDES
0B1A95 55 73 61 67 0033   str_usage: ASCIZ "Usage: flower <args>\r\n"
       65 3A 20 66 
       6C 6F 77 65 
       72 20 3C 61 
       72 67 73 3E 
       0D 0A 00    
0B1AAC 45 72 72 6F 0034   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B1AB5 53 75 63 63 0035   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1AC0             0036   
0B1AC0             0037   ; This program draws 2D curves related to the hypotrochoid / epitrochoid family (i.e. Spirographs),
0B1AC0             0038   ; more generally known as roulettes. While it is possible to construct curves fitting the precise
0B1AC0             0039   ; definitions of such curves, the program is not limited to them as slipping of the outer circle
0B1AC0             0040   ; is allowable. In addition, continually plotting the curve insribed by the outer circle is not required.
0B1AC0             0041   ; This allows rotating polygonal shapes remniscent of string art, as well as daisy-like curves.
0B1AC0             0042   ; Hence the name "flower" even though the program is not limited to such shapes.
0B1AC0             0043   ; Another key difference is that cumulative shrinking can be applied to the radii of the rotating circles,
0B1AC0             0044   ; thus allowing curves which form true spirals in contrast to the Spirograph toy, which does not.
0B1AC0             0045   ;
0B1AC0             0046   ; Parameters with example values:
0B1AC0             0047   ; petals      = 3.03  :
0B1AC0             0048   ; vectors     = 1.98  :
0B1AC0             0049   ; depth       = 0.6   :
0B1AC0             0050   ; periods     = 66    :
0B1AC0             0051   ; shrink      = 0.8   :
0B1AC0             0052   ; theta_prime = 0.0   :
0B1AC0             0053   ; radius_scale= 480   :
0B1AC0             0054   
0B1AC0             0055   ; ========= BOILERPLATE MAIN LOOP =========
0B1AC0             0056   ; The main routine
0B1AC0             0057   ; IXU: argv - pointer to array of parameters
0B1AC0             0058   ;   C: argc - number of parameters
0B1AC0             0059   ; Returns:
0B1AC0             0060   ;  HL: Error code, or 0 if OK
0B1AC0             0061   
0B1AC0             0062   min_args: equ 2
0B1AC0             0063   
0B1AC0             0064   _main:
0B1AC0 79          0065       ld a,c              ; how many arguments?
0B1AC1 FE 02       0066       cp min_args         ; not enough?
0B1AC3 D2 AE 1B 0B 0067       jp nc,main          ; if enough, go to main loop
0B1AC7 21 95 1A 0B 0068       ld hl,str_usage     ; if not enough, print usage
0B1ACB CD 73 02 0B 0069       call printString
0B1ACF             0070                           ; fall through to _main_end_error
0B1ACF             0071   
0B1ACF             0072   _main_end_error:
0B1ACF 21 AC 1A 0B 0073       ld hl,str_error     ; print error message
0B1AD3 CD 73 02 0B 0074       call printString
0B1AD7 21 13 00 00 0075       ld hl,19            ; return error code 19
0B1ADB C9          0076       ret
0B1ADC             0077   
0B1ADC             0078   _main_end_ok:
0B1ADC             0079       ; ld hl,str_success   ; print success message
0B1ADC             0080       ; call printString
0B1ADC 21 00 00 00 0081       ld hl,0             ; return 0 for success
0B1AE0 C9          0082       ret
0B1AE1             0083   
0B1AE1             0084   ; GLOBAL VARIABLES / DEFAULTS
0B1AE1             0085   ; ---- input arguments (16.8 fixed) ----
0B1AE1             0086   input_params_num: equ 5
0B1AE1             0087   input_params:               ; label so we can traverse the table in loops
0B1AE1 07 03 00    0088   petals: 	    dl 0x000307	; 3.03
0B1AE4 FA 01 00    0089   vectors: 	    dl 0x0001FA	; 1.98
0B1AE7 99 00 00    0090   depth: 	        dl 0x000099	; 0.6
0B1AEA 00 42 00    0091   periods: 	    dl 0x004200	; 66
0B1AED CC 00 00    0092   shrink: 	    dl 0x0000CC	; 0.8
0B1AF0 00 01 00    0093   clock_prime: 	dl 0x000100	; 1
0B1AF3 00 01 00    0094   clock_petal: 	dl 0x000100	; 1
0B1AF6 00 00 00    0095   theta_prime: 	dl 0x000000	; 0
0B1AF9 00 00 00    0096   theta_petal: 	dl 0x000000	; 0
0B1AFC 00 E0 01    0097   radius_scale: 	dl 0x01E000	; 480
0B1AFF             0098   
0B1AFF             0099   ; ---- main loop parameters (16.8 fixed) ----
0B1AFF 00 00 00    0100   step_theta_prime:   dl 0x000000  ; Step increment for theta_prime in each loop iteration
0B1B02 00 00 00    0101   step_theta_petal:   dl 0x000000  ; Step increment for theta_petal in each loop iteration
0B1B05 00 00 00    0102   total_steps:        dl 0x000000  ; Total number of iterations based on periods and step_theta_prime
0B1B08 00 00 00    0103   shrink_step:        dl 0x000000  ; Step decrement applied to radius in each iteration
0B1B0B             0104   
0B1B0B             0105   ; ---- main loop state variables (16.8 fixed) ----
0B1B0B 00 00 00    0106   prime_radius:       dl 0x000000  ; Initial radius before shrink factor is applied
0B1B0E             0107   
0B1B0E             0108   
0B1B0E             0109   main_loop:
0B1B0E             0110   ; --- convert input thetas to 16.8 fixed point degrees255
0B1B0E 2A F6 1A 0B 0111       ld hl,(theta_prime) ; get the theta_prime value
0B1B12 CD C7 0B 0B 0112       call deg_360_to_256 ; convert to 16.8 fixed point
0B1B16 22 F6 1A 0B 0113       ld (theta_prime),hl ; store the result
0B1B1A             0114   
0B1B1A 2A F9 1A 0B 0115       ld hl,(theta_petal) ; get the theta_petal value
0B1B1E CD C7 0B 0B 0116       call deg_360_to_256 ; convert to 16.8 fixed point
0B1B22 22 F9 1A 0B 0117       ld (theta_petal),hl ; store the result
0B1B26             0118   
0B1B26             0119   ; --- compute the main loop parameters ---
0B1B26             0120   ; step_theta_prime = 2 * math.pi / (petals * vectors)
0B1B26 2A E1 1A 0B 0121       ld hl,(petals)
0B1B2A ED 5B E4 1A 0122       ld de,(vectors)
       0B          
0B1B2F CD 70 09 0B 0123       call umul168 ; uh.l = petals * vectors
0B1B33 EB          0124       ex de,hl ; de = petals * vectors
0B1B34 21 00 00 01 0125       ld hl,256*256 ; 360 degrees in 16.8 fixed point
0B1B38 CD D8 09 0B 0126       call udiv168 ; ud.e = 256 / (petals * vectors)
0B1B3C ED 53 FF 1A 0127       ld (step_theta_prime),de ; store the result
       0B          
0B1B41             0128   
0B1B41             0129   ; step_theta_petal = 2 * math.pi / vectors
0B1B41 21 00 00 01 0130       ld hl,256*256 ; 360 degrees in 16.8 fixed point
0B1B45 ED 5B E4 1A 0131       ld de,(vectors)
       0B          
0B1B4A CD D8 09 0B 0132       call udiv168 ; ud.e = 256 / vectors
0B1B4E ED 53 02 1B 0133       ld (step_theta_petal),de ; store the result
       0B          
0B1B53             0134   
0B1B53             0135   ; total_steps = int(2 * math.pi / step_theta_prime * periods)
0B1B53 21 00 00 01 0136       ld hl,256*256 ; 360 degrees in 16.8 fixed point
0B1B57 ED 5B FF 1A 0137       ld de,(step_theta_prime)
       0B          
0B1B5C CD D8 09 0B 0138       call udiv168 ; ud.e = 256 / step_theta_prime
0B1B60 2A EA 1A 0B 0139       ld hl,(periods)
0B1B64 CD 70 09 0B 0140       call umul168 ; uh.l = periods * 256 / step_theta_prime
0B1B68 22 05 1B 0B 0141       ld (total_steps),hl ; store the result
0B1B6C             0142   
0B1B6C             0143   ; set initial point and move graphics cursor to it
0B1B6C CD 89 1B 0B 0144       call calc_point ; ub.c = x, ud.e = y
0B1B70 3E 44       0145       ld a,plot_pt+mv_abs ; plot mode
0B1B72 CD AF 18 0B 0146       call vdu_plot_168
0B1B76             0147       ; fall through to main loop
0B1B76             0148   
0B1B76 CD CB 05 0B 0149       call dumpRegistersHex
0B1B7A CD 0E 04 0B 0150       call print_u168
0B1B7E EB          0151       ex de,hl
0B1B7F CD 0E 04 0B 0152       call print_u168
0B1B83 EB          0153       ex de,hl
0B1B84 CD 88 02 0B 0154       call printNewLine
0B1B88             0155   
0B1B88             0156   @loop:
0B1B88             0157   
0B1B88             0158           ; jp @loop
0B1B88 C9          0159           ret
0B1B89             0160   
0B1B89             0161   ; compute the Cartesian coordinates of the next point on the curve
0B1B89             0162   ; inputs: theta_prime, theta_petal, prime_radius, depth
0B1B89             0163   ; outputs: ub.c = x, ud.e = y
0B1B89             0164   calc_point:
0B1B89             0165   ; Calculate the petal radius and total radius (unit circle)
0B1B89             0166       ; petal_radius = math.cos(theta_petal) * depth
0B1B89 2A F9 1A 0B 0167       ld hl,(theta_petal)
0B1B8D CD E9 0B 0B 0168       call cos168 ; uh.l = cos(theta_petal)
0B1B91 ED 5B E7 1A 0169       ld de,(depth)
       0B          
0B1B96 CD 78 09 0B 0170       call smul168 ; uh.l = petal_radius
0B1B9A             0171   
0B1B9A             0172       ; radius = prime_radius + petal_radius * prime_radius
0B1B9A ED 5B 0B 1B 0173       ld de,(prime_radius)
       0B          
0B1B9F CD 78 09 0B 0174       call smul168 ; uh.l = petal_radius * prime_radius
0B1BA3 19          0175       add hl,de ; uh.l = prime_radius + petal_radius * prime_radius
0B1BA4 EB          0176       ex de,hl ; de = radius
0B1BA5             0177   
0B1BA5             0178   ; Convert polar to Cartesian coordinates
0B1BA5             0179       ; x, y = polar_to_cartesian(radius, theta_prime)
0B1BA5 2A F6 1A 0B 0180       ld hl,(theta_prime)
0B1BA9 CD 14 0C 0B 0181       call polar_to_cartesian ; ub.c = x, ud.e = y
0B1BAD             0182   
0B1BAD             0183   ; all done
0B1BAD C9          0184       ret
0B1BAE             0185   
0B1BAE             0186   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B1BAE             0187   main:
0B1BAE 0D          0188       dec c               ; decrement the argument count to skip the program name
0B1BAF CD BB 1B 0B 0189       call load_input     ; load the input arguments
0B1BB3 CD 0E 1B 0B 0190       call main_loop      ; run the main loop
0B1BB7 C3 DC 1A 0B 0191       jp _main_end_ok     ; exit with success
0B1BBB             0192   
0B1BBB             0193   ; --- Load arguments ---
0B1BBB             0194   ; --------------------------------
0B1BBB             0195   load_input:
0B1BBB 79          0196       ld a,c ; put the number of entered arguments in a
0B1BBC 06 05       0197       ld b,input_params_num ; loop counter = number of arguments
0B1BBE B8          0198       cp b ; compare the number of arguments to the number of arguments
0B1BBF C4 D5 1B 0B 0199       call nz,args_count_off ; handle discrepancies
0B1BC3             0200       ; TODO: we may want to branch here according to the result
0B1BC3 FD 21 E1 1A 0201       ld iy,input_params  ; point to the arguments table
       0B          
0B1BC8             0202   @loop:
0B1BC8 CD FA 1B 0B 0203           call get_arg_s168 ; get the next argument
0B1BCC FD 1F 00    0204           ld (iy),de ; store the argument in the table
0B1BCF ED 33 03    0205           lea iy,iy+3  ; point to the next parameter
0B1BD2 10 F4       0206           djnz @loop ; loop until done
0B1BD4 C9          0207           ret
0B1BD5             0208   
0B1BD5             0209   
0B1BD5             0210   
0B1BD5             0211   
0B1BD5             0212   
0B1BD5             0213   ; --- Specific parameter processing functions ---
0B1BD5             0214   args_count_off:
0B1BD5 21 DE 1B 0B 0215       ld hl,@str_args_count_off
0B1BD9 CD 73 02 0B 0216       call printString
0B1BDD C9          0217       ret ; TODO: implement this
0B1BDE 41 72 67 75 0218   @str_args_count_off: db "Argument counts mismatch!\r\n",0
       6D 65 6E 74 
       20 63 6F 75 
       6E 74 73 20 
       6D 69 73 6D 
       61 74 63 68 
       21 0D 0A 00 
0B1BFA             0219   
0B1BFA             0220   
0B1BFA             0221   ; ========== HELPER FUNCTIONS ==========
0B1BFA             0222   ; get the next argument after ix as a signed 16.8 fixed point number
0B1BFA             0223   ; inputs: ix = pointer to the argument string
0B1BFA             0224   ; outputs: ude = signed 16.8 fixed point number
0B1BFA             0225   ; destroys: a, d, e, h, l, f
0B1BFA             0226   get_arg_s168:
0B1BFA ED 32 03    0227       lea ix,ix+3 ; point to the next argument
0B1BFD DD 27 00    0228       ld hl,(ix)  ; get the argument string
0B1C00 CD 94 01 0B 0229       call asc_to_s168 ; convert the string to a number
0B1C04 C9          0230       ret ; return with the value in DE
0B1C05             0231   
0B1C05             0232   ; Inputs: ix = pointer to the argument string
0B1C05             0233   ; Outputs: ude = signed 24-bit integer
0B1C05             0234   ; Destroys: a, d, e, h, l, f
0B1C05             0235   get_arg_s24:
0B1C05 ED 32 03    0236       lea ix,ix+3 ; point to the next argument
0B1C08 DD 27 00    0237       ld hl,(ix)  ; get the argument string
0B1C0B CD 45 01 0B 0238       call asc_to_s24 ; convert the string to a number
0B1C0F C9          0239       ret ; return with the value in DE
0B1C10             0240   
0B1C10             0241   get_plot_coords:
0B1C10             0242   ; get the move coordinates
0B1C10 ED 32 03    0243       lea ix,ix+3 ; pointer to next argument address
0B1C13 DD 27 00    0244       ld hl,(ix)  ; pointer to the x coordinate string
0B1C16 CD 94 01 0B 0245       call asc_to_s168 ; de = x coordinate
0B1C1A D5          0246       push de
0B1C1B C1          0247       pop bc ; bc = x coordinate
0B1C1C ED 32 03    0248       lea ix,ix+3 ; pointer to next argument address
0B1C1F DD 27 00    0249       ld hl,(ix)  ; pointer to the y coordinate string
0B1C22 CD 94 01 0B 0250       call asc_to_s168 ; de = y coordinate
0B1C26 C9          0251       ret
0B1C27             0252   
0B1C27             0253   get_arg_text:
0B1C27 ED 32 03    0254       lea ix,ix+3 ; point to the next argument
0B1C2A DD 27 00    0255       ld hl,(ix)  ; get the argument string
0B1C2D C9          0256       ret
0B1C2E             0257   
0B1C2E             0258   ; match the next argument after ix to the dispatch table at iy
0B1C2E             0259   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1C2E             0260   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1C2E             0261   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1C2E             0262   ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B1C2E             0263   ; destroys: a, hl, de, ix, iy, flags
0B1C2E             0264   match_next:
0B1C2E ED 32 03    0265       lea ix,ix+3         ; point to the next argument
0B1C31             0266   @loop:
0B1C31 FD 27 00    0267       ld hl,(iy)          ; pointer argument dispatch record
0B1C34             0268       sign_hlu            ; check for list terminator
0B1C34 19          0001M          add hl,de
0B1C35 B7          0002M          or a
0B1C36 ED 52       0003M          sbc hl,de
0B1C38 CA 50 1C 0B 0269       jp z,@no_match      ; if a=0, return error
0B1C3C 23          0270       inc hl              ; skip over jp instruction
0B1C3D 23          0271       inc hl
0B1C3E DD 17 00    0272       ld de,(ix)          ; pointer to the argument string
0B1C41 CD 67 1C 0B 0273       call str_equal      ; compare the argument to the dispatch table entry
0B1C45 CA 52 1C 0B 0274       jp z,@match         ; if equal, return success
0B1C49 ED 33 03    0275       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1C4C C3 31 1C 0B 0276       jp @loop            ; and loop
0B1C50             0277   @no_match:
0B1C50 3C          0278       inc a               ; no match so return a=1 and zero flag reset
0B1C51 C9          0279       ret
0B1C52             0280   @match:
0B1C52 FD 37 00    0281       ld iy,(iy)          ; get the function pointer
0B1C55 C9          0282       ret                 ; return a=0 and zero flag set
0B1C56             0283   
0B1C56             0284   ; same as match_next, but prints the parameter if a match is found
0B1C56             0285   match_next_and_print:
0B1C56 CD 2E 1C 0B 0286       call match_next
0B1C5A C0          0287       ret nz ; no match found
0B1C5B ED 32 FD    0288       lea ix,ix-3
0B1C5E CD 27 1C 0B 0289       call get_arg_text ; hl points to the operator string
0B1C62 CD 72 1C 0B 0290       call print_param
0B1C66 C9          0291       ret
0B1C67             0292   
0B1C67             0293   ; compare two zero-terminated strings for equality, case-sensitive
0B1C67             0294   ; hl: pointer to first string, de: pointer to second string
0B1C67             0295   ; returns: z if equal, nz if not equal
0B1C67             0296   ; destroys: a, hl, de
0B1C67             0297   str_equal:
0B1C67 1A          0298       ld a,(de)           ; get the first character
0B1C68 BE          0299       cp (hl)             ; compare to the second character
0B1C69 C0          0300       ret nz              ; if not equal, return
0B1C6A B7          0301       or a
0B1C6B C8          0302       ret z               ; if equal and zero, return
0B1C6C 23          0303       inc hl              ; next character
0B1C6D 13          0304       inc de
0B1C6E C3 67 1C 0B 0305       jp str_equal        ; loop until end of string
0B1C72             0306   
0B1C72             0307   ; print the parameter string pointed to by ix
0B1C72             0308   ; destroys: a, hl
0B1C72             0309   print_param:
0B1C72 DD 27 00    0310       ld hl,(ix)          ; get the parameter pointer
0B1C75 CD 73 02 0B 0311       call printString    ; print the parameter string
0B1C79 3E 20       0312       ld a,' '            ; print a space separator
0B1C7B 5B D7       0313       rst.lil $10
0B1C7D C9          0314       ret
0B1C7E             0315   
0B1C7E             0316   ; print the parameters
0B1C7E             0317   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1C7E             0318   ; destroys: a, hl, bc
0B1C7E             0319   print_params:
0B1C7E 41          0320       ld b,c              ; loop counter = number of parameters
0B1C7F DD E5       0321       push ix             ; save the pointer to the parameters
0B1C81             0322   @loop:
0B1C81 C5          0323       push bc             ; save the loop counter
0B1C82 CD 72 1C 0B 0324       call print_param    ; print the parameter
0B1C86 ED 32 03    0325       lea ix,ix+3         ; next parameter pointer
0B1C89 C1          0326       pop bc              ; get back the loop counter
0B1C8A 10 F5       0327       djnz @loop          ; loop until done
0B1C8C DD E1       0328       pop ix              ; restore the pointer to the parameters
0B1C8E C9          0329       ret
0B1C8F             0330   
0B1C8F             0331   debug_print:
0B1C8F CD 88 02 0B 0332       call printNewLine   ; DEBUG
0B1C93 CD FA 06 0B 0333       call dumpFlags      ; DEBUG
0B1C97 CD 72 1C 0B 0334       call print_param    ; DEBUG
0B1C9B CD 88 02 0B 0335       call printNewLine   ; DEBUG
0B1C9F CD 88 02 0B 0336       call printNewLine   ; DEBUG
0B1CA3 C9          0337       ret
