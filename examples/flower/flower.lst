PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "flower.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 66 6C 6F 77 0001*M     ASCIZ "flower.bin"
       65 72 2E 62 
       69 6E 00    
0B000F             0025*  
0B000F FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF          
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD E2 24 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 93 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F             0108*      ; call _skip_spaces ; skip whitespace
0B014F             0109*  
0B014F 7E          0110*      ld a, (hl) ; read first character
0B0150 B7          0111*      or a ; check for end of string
0B0151 C8          0112*      ret z ; return with no carry if not
0B0152             0113*  
0B0152 C5          0114*      push bc ; preserve bc
0B0153             0115*  
0B0153 FE 2D       0116*      cp '-' ; check for negative number
0B0155 C2 5F 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B0159 AF          0118*      xor a ; sign flag to zero
0B015A 32 93 01 0B 0119*      ld (@sign),a ; store sign flag
0B015E 23          0120*      inc hl ; skip '-'
0B015F             0121*  
0B015F             0122*  @loop:
0B015F 7E          0123*      ld a, (hl)
0B0160 D6 30       0124*      sub '0' ; normalise to 0
0B0162 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0164 FE 0A       0126*      cp 10 ; check if >= 10
0B0166 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B0168 E5          0128*      push hl ; stack hl
0B0169 D5          0129*      push de ; ld hl, de
0B016A E1          0130*      pop hl
0B016B E5          0131*      push hl ; ld bc, hl
0B016C C1          0132*      pop bc
0B016D 29          0133*      add hl, hl ; x 2
0B016E 29          0134*      add hl, hl ; x 4
0B016F 09          0135*      add hl, bc ; x 5
0B0170 29          0136*      add hl, hl ; x 10
0B0171 01 00 00 00 0137*      ld bc, 0
0B0175 4F          0138*      ld c, a ; ld bcu, a
0B0176 09          0139*      add hl, bc ; add bcu to hl
0B0177 E5          0140*      push hl ; ld de, hl
0B0178 D1          0141*      pop de
0B0179 E1          0142*      pop hl ; restore hl
0B017A 23          0143*      inc hl
0B017B 18 E2       0144*      jr @loop
0B017D             0145*  
0B017D             0146*  @integer_end:
0B017D C1          0147*      pop bc ; send bc back how she came in
0B017E 3A 93 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0182 3D          0149*      dec a ; check if negative
0B0183 F2 91 01 0B 0150*      jp p,@pos ; positive number
0B0187             0151*  
0B0187             0152*  ; Negate de
0B0187 E5          0153*      push hl ; save text pointer
0B0188 21 00 00 00 0154*      ld hl, 0
0B018C AF          0155*      xor a ; clear carry
0B018D ED 52       0156*      sbc hl, de ; subtract DE from HL
0B018F EB          0157*      ex de, hl ; DE = 0-HL
0B0190 E1          0158*      pop hl ; restore text pointer
0B0191             0159*  
0B0191             0160*  @pos:
0B0191 37          0161*      scf ; we have a valid number so set carry
0B0192 C9          0162*      ret
0B0193             0163*  
0B0193 00          0164*  @sign: db 0 ; sign flag buffer
0B0194             0165*  
0B0194             0166*  
0B0194             0167*  ;------------------------------------------------------------------------
0B0194             0168*  ; Read a number and convert to binary (decimal only)
0B0194             0169*  ; Inputs: hl: Pointer in string buffer
0B0194             0170*  ; Outputs: hl: Updated text pointer
0B0194             0171*  ;         de: Value
0B0194             0172*  ;         a: Terminator (spaces skipped)
0B0194             0173*  ;         f: Carry set if valid number, otherwise reset
0B0194             0174*  ; Destroys: a, d, e, h, l, f
0B0194             0175*  ;------------------------------------------------------------------------
0B0194             0176*  asc_to_s168:
0B0194 3E 01       0177*      ld a,1 ; set sign flag
0B0196 32 53 02 0B 0178*      ld (@sign),a ; store sign flag
0B019A             0179*  
0B019A 11 00 00 00 0180*      ld de, 0 ; initialise de
0B019E ED 53 4B 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A3 ED 53 4F 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01A8             0183*  
0B01A8             0184*      ; call _skip_spaces ; skip whitespace
0B01A8             0185*  
0B01A8 7E          0186*      ld a, (hl) ; read first character
0B01A9 B7          0187*      or a ; check for end of string
0B01AA C8          0188*      ret z ; return with no carry if not
0B01AB             0189*  
0B01AB C5          0190*      push bc ; preserve bc
0B01AC             0191*  
0B01AC FE 2D       0192*      cp '-' ; check for negative number
0B01AE C2 B8 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01B2 AF          0194*      xor a ; sign flag to zero
0B01B3 32 53 02 0B 0195*      ld (@sign),a ; store sign flag
0B01B7 23          0196*      inc hl ; skip '-'
0B01B8             0197*  
0B01B8             0198*  @loop:
0B01B8 7E          0199*      ld a, (hl)
0B01B9             0200*  
0B01B9             0201*  ; chcek for decimal point
0B01B9 FE 2E       0202*      cp '.' ; check for decimal point
0B01BB CA FC 01 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01BF             0204*  
0B01BF             0205*  ; process integer part
0B01BF D6 30       0206*      sub '0' ; normalise to 0
0B01C1 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01C3 FE 0A       0208*      cp 10 ; check if >= 10
0B01C5 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01C7 E5          0210*      push hl ; stack hl
0B01C8 D5          0211*      push de ; ld hl, de
0B01C9 E1          0212*      pop hl
0B01CA E5          0213*      push hl ; ld bc, hl
0B01CB C1          0214*      pop bc
0B01CC 29          0215*      add hl, hl ; x 2
0B01CD 29          0216*      add hl, hl ; x 4
0B01CE 09          0217*      add hl, bc ; x 5
0B01CF 29          0218*      add hl, hl ; x 10
0B01D0 01 00 00 00 0219*      ld bc, 0
0B01D4 4F          0220*      ld c, a ; ld bcu, a
0B01D5 09          0221*      add hl, bc ; add bcu to hl
0B01D6 E5          0222*      push hl ; ld de, hl
0B01D7 D1          0223*      pop de
0B01D8 E1          0224*      pop hl ; restore hl
0B01D9 23          0225*      inc hl
0B01DA 18 DC       0226*      jr @loop
0B01DC             0227*  
0B01DC             0228*  @integer_end:
0B01DC ED 53 4C 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E1             0230*  
0B01E1             0231*  @end:
0B01E1 C1          0232*      pop bc ; send bc back how she came in
0B01E2 ED 5B 4B 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01E7 3A 53 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01EB 3D          0235*      dec a ; check if negative
0B01EC F2 FA 01 0B 0236*      jp p,@pos ; positive number
0B01F0             0237*  
0B01F0             0238*  ; Negate de
0B01F0 E5          0239*      push hl ; save text pointer
0B01F1 21 00 00 00 0240*      ld hl, 0
0B01F5 AF          0241*      xor a ; clear carry
0B01F6 ED 52       0242*      sbc hl, de ; subtract DE from HL
0B01F8 EB          0243*      ex de, hl ; DE = 0-HL
0B01F9 E1          0244*      pop hl ; restore text pointer
0B01FA             0245*  
0B01FA             0246*  @pos:
0B01FA 37          0247*      scf ; we have a valid number so set carry
0B01FB C9          0248*      ret
0B01FC             0249*  
0B01FC             0250*  @fractional_start:
0B01FC DD E5       0251*      push ix                    ; preserve ix
0B01FE ED 53 4C 02 0252*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0203 06 03       0253*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B0205 11 00 00 00 0254*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B0209 DD 21 54 02 0255*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B020E 23          0256*      inc hl                     ; Skip decimal point
0B020F             0257*  
0B020F             0258*  @fractional_loop:
0B020F 7E          0259*      ld a, (hl)                 ; Load next character
0B0210 D6 30       0260*      sub '0'                    ; Normalize ASCII to decimal
0B0212 38 1C       0261*      jr c, @end_fraction        ; Exit if < '0'
0B0214 FE 0A       0262*      cp 10
0B0216 30 18       0263*      jr nc, @end_fraction       ; Exit if >= 10
0B0218             0264*  
0B0218             0265*      ; Multiply the current fractional accumulator by 10
0B0218 E5          0266*      push hl                    ; Save char pointer
0B0219 F5          0267*      push af                    ; Save the digit
0B021A EB          0268*      ex de, hl
0B021B E5          0269*      push hl
0B021C 29          0270*      add hl,hl ; * 2
0B021D 29          0271*      add hl,hl ; * 4
0B021E D1          0272*      pop de
0B021F 19          0273*      add hl,de ; * 5
0B0220 29          0274*      add hl,hl ; * 10
0B0221 11 00 00 00 0275*      ld de, 0                   ; Clear DEU
0B0225 F1          0276*      pop af                     ; Restore the current digit
0B0226 5F          0277*      ld e, a                    ; Load the digit into E
0B0227 19          0278*      add hl, de                 ; Add the digit to the accumulator
0B0228 EB          0279*      ex de, hl                  ; Result back to DE
0B0229 ED 32 03    0280*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B022C E1          0281*      pop hl                     ; Restore char pointer
0B022D 23          0282*      inc hl                     ; Move to the next character
0B022E 10 DF       0283*      djnz @fractional_loop      ; Loop if more digits to process
0B0230             0284*  
0B0230             0285*  @end_fraction:
0B0230             0286*  ; Final scaling based on number of fractional digits processed
0B0230 ED 53 50 02 0287*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B0235 2A 4F 02 0B 0288*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0239             0289*  
0B0239 DD 17 00    0290*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B023C CD 2A 09 0B 0291*      call udiv24                ; Perform 24-bit division to scale down
0B0240 7B          0292*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0241 32 4B 02 0B 0293*      ld (@result), a            ; Store fractional part in result buffer
0B0245 DD E1       0294*      pop ix                     ; Restore ix
0B0247 C3 E1 01 0B 0295*      jp @end                    ; Final sign check and flag setup
0B024B             0296*  
0B024B             0297*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B024F             0298*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0253 00          0299*  @sign: db 0                    ; Sign flag buffer
0B0254             0300*  
0B0254             0301*  powers_of_10:
0B0254 01 00 00    0302*      dl 1                       ; 10^0
0B0257 0A 00 00    0303*      dl 10                      ; 10^1
0B025A 64 00 00    0304*      dl 100                     ; 10^2
0B025D E8 03 00    0305*      dl 1000                    ; 10^3
0B0260 10 27 00    0306*      dl 10000                   ; 10^4
0B0263             0017   
0B0263             0018   ; API INCLUDES
0B0263             0019       include "functions.inc"
0B0263             0001*      MACRO printChar char
0B0263             0002*          LD A, char
0B0263             0003*          RST.LIL 10h
0B0263             0004*      ENDMACRO
0B0263             0005*  
0B0263             0006*  ; test the sign of HL
0B0263             0007*  ; inputs: HL obviously
0B0263             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0263             0009*  ; destroys: flags
0B0263             0010*      MACRO sign_hlu
0B0263             0011*          add hl,de
0B0263             0012*          or a
0B0263             0013*          sbc hl,de
0B0263             0014*      ENDMACRO
0B0263             0015*  
0B0263             0016*  ; Simulated call to subroutine at HL
0B0263             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0263             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0263             0019*  ; destroys: only what the subroutine does, but always BC
0B0263             0020*      MACRO callHL
0B0263             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0022*          push bc       ; which constitutes the return address
0B0263             0023*          jp   (hl)     ; Jump to the address in HL
0B0263             0024*      ENDMACRO
0B0263             0025*  
0B0263             0026*  ; Simulated call to subroutine at IX
0B0263             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0263             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0263             0029*  ; destroys: only what the subroutine does, but always BC
0B0263             0030*      MACRO callIX
0B0263             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0032*          push bc       ; which constitutes the return address
0B0263             0033*          jp   (ix)     ; Jump to the address in IX
0B0263             0034*      ENDMACRO
0B0263             0035*  
0B0263             0036*  ; Simulated call to soubroutinte at IY
0B0263             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0263             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0263             0039*  ; destroys: only what the subroutine does, but always BC
0B0263             0040*      MACRO callIY
0B0263             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0263             0042*          push bc       ; which constitutes the return address
0B0263             0043*          jp   (iy)     ; Jump to the address in IY
0B0263             0044*      ENDMACRO
0B0263             0045*  
0B0263             0046*  ; put the value in HLU into the accumulator
0B0263             0047*  ; destroys: af
0B0263             0048*      MACRO HLU_TO_A
0B0263             0049*          push hl ; 4 cycles
0B0263             0050*          inc sp ; 1 cycle
0B0263             0051*          pop af  ; 4 cycles
0B0263             0052*          dec sp ; 1 cycle
0B0263             0053*                 ; 10 cycles total
0B0263             0054*      ENDMACRO
0B0263             0055*  
0B0263             0056*  A_TO_HLU:
0B0263             0057*      ; call is 7 cycles
0B0263 22 70 02 0B 0058*      ld (@scratch),hl ; 7 cycles
0B0267 32 72 02 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B026B 2A 70 02 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B026F C9          0061*      ret ; 6 cycles
0B0270             0062*          ; 25 cycles total
0B0270 00 00 00    0063*  @scratch: dl 0
0B0273             0064*  
0B0273             0065*      ; TODO: implement this
0B0273             0066*      ; MACRO A_TO_HLU
0B0273             0067*      ;     push.s af
0B0273             0068*      ;     inc sp
0B0273             0069*      ;     push.s hl
0B0273             0070*      ;     pop hl
0B0273             0071*      ;     inc sp
0B0273             0072*      ;     inc sp
0B0273             0073*      ; ENDMACRO
0B0273             0074*  
0B0273             0075*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0273             0076*  ; Print a zero-terminated string
0B0273             0077*  ; HL: Pointer to string
0B0273             0078*  printString:
0B0273 C5          0079*  	PUSH	BC
0B0274 01 00 00 00 0080*  	LD		BC,0
0B0278 3E 00       0081*  	LD 	 	A,0
0B027A 5B DF       0082*  	RST.LIL 18h
0B027C C1          0083*  	POP		BC
0B027D C9          0084*  	RET
0B027E             0085*  ; print a VDU sequence
0B027E             0086*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B027E             0087*  sendVDUsequence:
0B027E C5          0088*  	PUSH	BC
0B027F 01 00 00 00 0089*  	LD		BC, 0
0B0283 4E          0090*  	LD		C, (HL)
0B0284 5B DF       0091*  	RST.LIL	18h
0B0286 C1          0092*  	POP		BC
0B0287 C9          0093*  	RET
0B0288             0094*  ; Print Newline sequence to VDP
0B0288             0095*  printNewLine:
0B0288 F5          0096*      push af ; for some reason rst.lil 10h sets carry flag
0B0289 3E 0D       0097*  	LD	A, '\r'
0B028B 5B D7       0098*  	RST.LIL 10h
0B028D 3E 0A       0099*  	LD	A, '\n'
0B028F 5B D7       0100*  	RST.LIL 10h
0B0291 F1          0101*      pop af
0B0292 C9          0102*  	RET
0B0293             0103*  
0B0293             0104*  ; Print a 24-bit HEX number
0B0293             0105*  ; HLU: Number to print
0B0293             0106*  printHex24:
0B0293             0107*  	; PUSH	HL      ; 4 cycles
0B0293             0108*  	; LD		HL, 2   ; 4 cycles
0B0293             0109*  	; ADD		HL, SP  ; 1 cycle
0B0293             0110*  	; LD		A, (HL) ; 2 cycles
0B0293             0111*  	; POP		HL      ; 4 cycles
0B0293             0112*      ;                 ; 15 cycles total
0B0293 E5          0113*      push hl ; 4 cycles
0B0294 33          0114*      inc sp ; 1 cycle
0B0295 F1          0115*      pop af  ; 4 cycles
0B0296 3B          0116*      dec sp ; 1 cycle
0B0297             0117*              ; 10 cycles total
0B0297 CD A1 02 0B 0118*  	CALL	printHex8
0B029B             0119*  ; Print a 16-bit HEX number
0B029B             0120*  ; HL: Number to print
0B029B             0121*  printHex16:
0B029B 7C          0122*  	LD		A,H
0B029C CD A1 02 0B 0123*  	CALL	printHex8
0B02A0 7D          0124*  	LD		A,L
0B02A1             0125*  ; Print an 8-bit HEX number
0B02A1             0126*  ; A: Number to print
0B02A1             0127*  printHex8:
0B02A1 4F          0128*  	LD		C,A
0B02A2 1F          0129*  	RRA
0B02A3 1F          0130*  	RRA
0B02A4 1F          0131*  	RRA
0B02A5 1F          0132*  	RRA
0B02A6 CD AB 02 0B 0133*  	CALL	@F
0B02AA 79          0134*  	LD		A,C
0B02AB             0135*  @@:
0B02AB E6 0F       0136*  	AND		0Fh
0B02AD C6 90       0137*  	ADD		A,90h
0B02AF 27          0138*  	DAA
0B02B0 CE 40       0139*  	ADC		A,40h
0B02B2 27          0140*  	DAA
0B02B3 5B D7       0141*  	RST.LIL	10h
0B02B5 C9          0142*  	RET
0B02B6             0143*  
0B02B6             0144*  printHexA:
0B02B6 F5          0145*      push af
0B02B7 C5          0146*      push bc
0B02B8 CD A1 02 0B 0147*      call printHex8
0B02BC 3E 20       0148*      ld a,' '
0B02BE 5B D7       0149*      rst.lil 10h
0B02C0 C1          0150*      pop bc
0B02C1 F1          0151*      pop af
0B02C2 C9          0152*      ret
0B02C3             0153*  
0B02C3             0154*  printHexHL:
0B02C3 F5          0155*      push af
0B02C4 C5          0156*      push bc
0B02C5 CD 9B 02 0B 0157*      call printHex16
0B02C9 3E 20       0158*      ld a,' '
0B02CB 5B D7       0159*      rst.lil 10h
0B02CD C1          0160*      pop bc
0B02CE F1          0161*      pop af
0B02CF C9          0162*      ret
0B02D0             0163*  
0B02D0             0164*  printHexUHL:
0B02D0 F5          0165*      push af
0B02D1 C5          0166*      push bc
0B02D2 CD 93 02 0B 0167*      call printHex24
0B02D6 3E 20       0168*      ld a,' '
0B02D8 5B D7       0169*      rst.lil 10h
0B02DA C1          0170*      pop bc
0B02DB F1          0171*      pop af
0B02DC C9          0172*      ret
0B02DD             0173*  
0B02DD             0174*  printHexAUHL:
0B02DD F5          0175*      push af
0B02DE C5          0176*      push bc
0B02DF CD A1 02 0B 0177*      call printHex8
0B02E3 3E 2E       0178*      ld a,'.'
0B02E5 5B D7       0179*      rst.lil 10h
0B02E7 CD 93 02 0B 0180*      call printHex24
0B02EB 3E 20       0181*      ld a,' '
0B02ED 5B D7       0182*      rst.lil 10h
0B02EF C1          0183*      pop bc
0B02F0 F1          0184*      pop af
0B02F1 C9          0185*      ret
0B02F2             0186*  
0B02F2             0187*  printHexABHL:
0B02F2             0188*  ; preserve registers
0B02F2 C5          0189*      push bc ; b will be ok c will not
0B02F3 F5          0190*      push af ; will get totally destroyed
0B02F4             0191*  ; print a
0B02F4 CD A1 02 0B 0192*      call printHex8
0B02F8             0193*  ; print b
0B02F8 78          0194*      ld a,b
0B02F9 CD A1 02 0B 0195*      call printHex8
0B02FD             0196*  ; print hl
0B02FD CD 9B 02 0B 0197*      call printHex16
0B0301             0198*  ; restore registers
0B0301 F1          0199*      pop af
0B0302 C1          0200*      pop bc
0B0303 C9          0201*      ret
0B0304             0202*  
0B0304             0203*  printHexBHL:
0B0304             0204*  ; preserve registers
0B0304 C5          0205*      push bc ; b will be ok c will not
0B0305 F5          0206*      push af ; will get totally destroyed
0B0306             0207*  ; print b
0B0306 78          0208*      ld a,b
0B0307 CD A1 02 0B 0209*      call printHex8
0B030B             0210*  ; print hl
0B030B CD 9B 02 0B 0211*      call printHex16
0B030F             0212*  ; restore registers
0B030F F1          0213*      pop af
0B0310 C1          0214*      pop bc
0B0311 C9          0215*      ret
0B0312             0216*  
0B0312             0217*  printHexCDE:
0B0312             0218*  ; preserve registers
0B0312 C5          0219*      push bc ; b will be ok c will not
0B0313 F5          0220*      push af ; will get totally destroyed
0B0314             0221*  ; print c
0B0314 79          0222*      ld a,c
0B0315 CD A1 02 0B 0223*      call printHex8
0B0319             0224*  ; print de
0B0319 EB          0225*      ex de,hl
0B031A CD 9B 02 0B 0226*      call printHex16
0B031E EB          0227*      ex de,hl
0B031F             0228*  ; restore registers
0B031F F1          0229*      pop af
0B0320 C1          0230*      pop bc
0B0321 C9          0231*      ret
0B0322             0232*  
0B0322             0233*  ; Print a 0x HEX prefix
0B0322             0234*  DisplayHexPrefix:
0B0322 3E 30       0235*  	LD	A, '0'
0B0324 5B D7       0236*  	RST.LIL 10h
0B0326 3E 78       0237*  	LD	A, 'x'
0B0328 5B D7       0238*  	RST.LIL 10h
0B032A C9          0239*  	RET
0B032B             0240*  
0B032B             0241*      MACRO printDecBC
0B032B             0242*          push hl
0B032B             0243*          push bc
0B032B             0244*          pop hl
0B032B             0245*          call printDec
0B032B             0246*          pop hl
0B032B             0247*      ENDMACRO
0B032B             0248*  
0B032B             0249*      MACRO printDecDE
0B032B             0250*          push hl
0B032B             0251*          push de
0B032B             0252*          pop hl
0B032B             0253*          call printDec
0B032B             0254*          pop hl
0B032B             0255*      ENDMACRO
0B032B             0256*  
0B032B             0257*      MACRO printDecHL
0B032B             0258*          call printDec
0B032B             0259*      ENDMACRO
0B032B             0260*  
0B032B             0261*      MACRO printDecIX
0B032B             0262*          push hl
0B032B             0263*          push ix
0B032B             0264*          pop hl
0B032B             0265*          call printDec
0B032B             0266*          pop hl
0B032B             0267*      ENDMACRO
0B032B             0268*  
0B032B             0269*      MACRO printDecIY
0B032B             0270*          push hl
0B032B             0271*          push iy
0B032B             0272*          pop hl
0B032B             0273*          call printDec
0B032B             0274*          pop hl
0B032B             0275*      ENDMACRO
0B032B             0276*  
0B032B             0277*  
0B032B             0278*  ; Prints the right justified decimal value in HL without leading zeroes
0B032B             0279*  ; HL : Value to print
0B032B             0280*  ; preserves all registers and flags
0B032B             0281*  printDec:
0B032B             0282*  ; BEGIN MY CODE
0B032B             0283*  ; back up all the things
0B032B F5          0284*      push af
0B032C C5          0285*      push bc
0B032D D5          0286*      push de
0B032E E5          0287*      push hl
0B032F             0288*  ; END MY CODE
0B032F 11 57 03 0B 0289*  	LD	 DE, _printDecBuffer
0B0333 CD 67 03 0B 0290*  	CALL u24_to_ascii
0B0337             0291*  ; BEGIN MY CODE
0B0337             0292*  ; replace leading zeroes with spaces
0B0337 21 57 03 0B 0293*      LD	 HL, _printDecBuffer
0B033B 06 07       0294*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B033D             0295*  @loop:
0B033D 7E          0296*      LD	 A, (HL)
0B033E FE 30       0297*      CP	 '0'
0B0340 C2 4A 03 0B 0298*      JP	 NZ, @done
0B0344 3E 20       0299*      LD   A, ' '
0B0346 77          0300*      LD	 (HL), A
0B0347 23          0301*      INC	 HL
0B0348             0302*      ; CALL vdu_cursor_forward
0B0348 10 F3       0303*      DJNZ @loop
0B034A             0304*  @done:
0B034A             0305*  ; END MY CODE
0B034A 21 57 03 0B 0306*  	LD	 HL, _printDecBuffer
0B034E CD 73 02 0B 0307*  	CALL printString
0B0352             0308*  ; BEGIN MY CODE
0B0352             0309*  ; restore all the things
0B0352 E1          0310*      pop hl
0B0353 D1          0311*      pop de
0B0354 C1          0312*      pop bc
0B0355 F1          0313*      pop af
0B0356             0314*  ; END MY CODE
0B0356 C9          0315*  	RET
0B0357 00 00 00 00 0316*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0367             0317*  
0B0367             0318*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B0367             0319*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B0367             0320*  ; so it will allways be 8 characters length
0B0367             0321*  ; HL : Value to convert to string
0B0367             0322*  ; DE : pointer to buffer, at least 8 byte + 0
0B0367             0323*  u24_to_ascii:
0B0367 01 80 69 67 0324*  	LD	 BC,-10000000
0B036B CD 9E 03 0B 0325*  	CALL @one_digit
0B036F 01 C0 BD F0 0326*  	LD	 BC,-1000000
0B0373 CD 9E 03 0B 0327*  	CALL @one_digit
0B0377 01 60 79 FE 0328*  	LD	 BC,-100000
0B037B CD 9E 03 0B 0329*  	CALL @one_digit
0B037F 01 F0 D8 FF 0330*  	LD   BC,-10000
0B0383 CD 9E 03 0B 0331*  	CALL @one_digit
0B0387 01 18 FC FF 0332*  	LD   BC,-1000
0B038B CD 9E 03 0B 0333*  	CALL @one_digit
0B038F 01 9C FF FF 0334*  	LD   BC,-100
0B0393 CD 9E 03 0B 0335*  	CALL @one_digit
0B0397 0E F6       0336*  	LD   C,-10
0B0399 CD 9E 03 0B 0337*  	CALL @one_digit
0B039D 48          0338*  	LD   C,B
0B039E             0339*  @one_digit:
0B039E 3E 2F       0340*  	LD   A,'0'-1
0B03A0             0341*  @divide_me:
0B03A0 3C          0342*  	INC  A
0B03A1 09          0343*  	ADD  HL,BC
0B03A2 38 FC       0344*  	JR   C,@divide_me
0B03A4 ED 42       0345*  	SBC  HL,BC
0B03A6 12          0346*  	LD   (DE),A
0B03A7 13          0347*  	INC  DE
0B03A8 C9          0348*  	RET
0B03A9             0349*  
0B03A9             0350*  print_u24:
0B03A9 D5          0351*      push de
0B03AA E5          0352*      push hl
0B03AB 11 57 03 0B 0353*      ld de,_printDecBuffer
0B03AF CD 67 03 0B 0354*      call u24_to_ascii
0B03B3 21 57 03 0B 0355*      ld hl,_printDecBuffer
0B03B7 CD 73 02 0B 0356*      call printString
0B03BB 3E 20       0357*      ld a,' '
0B03BD 5B D7       0358*      rst.lil 10h
0B03BF E1          0359*      pop hl
0B03C0 D1          0360*      pop de
0B03C1 C9          0361*      ret
0B03C2             0362*  
0B03C2             0363*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03C2             0364*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03C2             0365*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03C2             0366*  u168_to_ascii:
0B03C2             0367*  ; add a leading space to make room for sign flag if needed
0B03C2 3E 20       0368*      ld a,' '
0B03C4 12          0369*      ld (de),a
0B03C5 13          0370*      inc de
0B03C6             0371*  ; Convert integer part
0B03C6 E5          0372*      push hl               ; Save HL (we’ll need the fractional part later)
0B03C7 CD A2 08 0B 0373*      call hlu_udiv256    ; Shift to get integer portion in HL
0B03CB 01 F0 D8 FF 0374*      ld   bc, -10000
0B03CF CD F2 03 0B 0375*      call @one_int
0B03D3 01 18 FC FF 0376*      ld   bc, -1000
0B03D7 CD F2 03 0B 0377*      call @one_int
0B03DB 01 9C FF FF 0378*      ld   bc, -100
0B03DF CD F2 03 0B 0379*      call @one_int
0B03E3 0E F6       0380*      ld   c, -10
0B03E5 CD F2 03 0B 0381*      call @one_int
0B03E9 48          0382*      ld   c, b
0B03EA CD F2 03 0B 0383*      call @one_int
0B03EE C3 FD 03 0B 0384*      jp   @frac            ; Jump to fractional part conversion
0B03F2             0385*  @one_int:
0B03F2 3E 2F       0386*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F4             0387*  @divide_me:
0B03F4 3C          0388*      inc  a
0B03F5 09          0389*      add  hl, bc           ; Accumulate until overflow
0B03F6 38 FC       0390*      jr   c, @divide_me
0B03F8 ED 42       0391*      sbc  hl, bc           ; Remove excess after overflow
0B03FA 12          0392*      ld   (de), a          ; Store ASCII digit
0B03FB 13          0393*      inc  de
0B03FC C9          0394*      ret
0B03FD             0395*  ; Convert fractional part
0B03FD             0396*  @frac:
0B03FD 3E 2E       0397*      ld   a, '.'           ; Decimal point
0B03FF 12          0398*      ld   (de), a
0B0400 13          0399*      inc  de
0B0401 E1          0400*      pop  hl               ; Restore HL with original fraction
0B0402 06 03       0401*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0404             0402*  @frac_loop:
0B0404 26 0A       0403*      ld   h, 10            ; Load multiplier for fractional part
0B0406 ED 6C       0404*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0408 3E 30       0405*      ld   a, '0'
0B040A 84          0406*      add  a, h             ; Convert integer part to ASCII
0B040B 12          0407*      ld   (de), a
0B040C 13          0408*      inc  de
0B040D 10 F5       0409*      djnz @frac_loop       ; Repeat for each fractional digit
0B040F             0410*  ; Add null terminator
0B040F AF          0411*      xor  a                ; Null terminator
0B0410 12          0412*      ld   (de), a
0B0411 C9          0413*      ret
0B0412             0414*  
0B0412             0415*  print_u168:
0B0412 D5          0416*      push de
0B0413 E5          0417*      push hl
0B0414 11 57 03 0B 0418*      ld de,_printDecBuffer
0B0418 CD C2 03 0B 0419*      call u168_to_ascii
0B041C 21 57 03 0B 0420*      ld hl,_printDecBuffer
0B0420 CD 73 02 0B 0421*      call printString
0B0424 E1          0422*      pop hl
0B0425 D1          0423*      pop de
0B0426 C9          0424*      ret
0B0427             0425*  
0B0427             0426*  ; signed version of u168_to_ascii
0B0427             0427*  s168_to_ascii:
0B0427 D5          0428*      push de ; save starting address of buffer
0B0428 CD 3B 08 0B 0429*      call hlu_abs
0B042C F5          0430*      push af ; save sign flag
0B042D CD C2 03 0B 0431*      call u168_to_ascii
0B0431 F1          0432*      pop af ; restore sign flag
0B0432 D1          0433*      pop de ; restore starting address of buffer
0B0433 F0          0434*      ret p ; hlu was positive so nothing to do
0B0434 3E 2D       0435*      ld a,'-'
0B0436 12          0436*      ld (de),a
0B0437 C9          0437*      ret
0B0438             0438*  
0B0438             0439*  print_s168:
0B0438 D5          0440*      push de
0B0439 E5          0441*      push hl
0B043A 11 57 03 0B 0442*      ld de,_printDecBuffer
0B043E CD 27 04 0B 0443*      call s168_to_ascii
0B0442 21 57 03 0B 0444*      ld hl,_printDecBuffer
0B0446 CD 73 02 0B 0445*      call printString
0B044A E1          0446*      pop hl
0B044B D1          0447*      pop de
0B044C C9          0448*      ret
0B044D             0449*  
0B044D             0450*  print_s168_hl:
0B044D F5          0451*      push af
0B044E E5          0452*      push hl
0B044F CD 38 04 0B 0453*      call print_s168
0B0453 3E 20       0454*      ld a,' '
0B0455 5B D7       0455*      rst.lil 10h
0B0457 E1          0456*      pop hl
0B0458 F1          0457*      pop af
0B0459 C9          0458*      ret
0B045A             0459*  
0B045A             0460*  print_s168_bc:
0B045A F5          0461*      push af
0B045B C5          0462*      push bc
0B045C E5          0463*      push hl
0B045D C5          0464*      push bc
0B045E E1          0465*      pop hl
0B045F CD 38 04 0B 0466*      call print_s168
0B0463 3E 20       0467*      ld a,' '
0B0465 5B D7       0468*      rst.lil 10h
0B0467 E1          0469*      pop hl
0B0468 C1          0470*      pop bc
0B0469 F1          0471*      pop af
0B046A C9          0472*      ret
0B046B             0473*  
0B046B             0474*  print_s168_de:
0B046B F5          0475*      push af
0B046C D5          0476*      push de
0B046D E5          0477*      push hl
0B046E EB          0478*      ex de,hl
0B046F CD 38 04 0B 0479*      call print_s168
0B0473 3E 20       0480*      ld a,' '
0B0475 5B D7       0481*      rst.lil 10h
0B0477 E1          0482*      pop hl
0B0478 D1          0483*      pop de
0B0479 F1          0484*      pop af
0B047A C9          0485*      ret
0B047B             0486*  
0B047B             0487*  print_s168_hl_bc_de:
0B047B F5          0488*      push af
0B047C C5          0489*      push bc
0B047D D5          0490*      push de
0B047E E5          0491*      push hl
0B047F CD 38 04 0B 0492*      call print_s168
0B0483 3E 20       0493*      ld a,' '
0B0485 5B D7       0494*      rst.lil 10h
0B0487 C5          0495*      push bc
0B0488 E1          0496*      pop hl
0B0489 CD 38 04 0B 0497*      call print_s168
0B048D 3E 20       0498*      ld a,' '
0B048F 5B D7       0499*      rst.lil 10h
0B0491 EB          0500*      ex de,hl
0B0492 CD 38 04 0B 0501*      call print_s168
0B0496 3E 20       0502*      ld a,' '
0B0498 5B D7       0503*      rst.lil 10h
0B049A E1          0504*      pop hl
0B049B D1          0505*      pop de
0B049C C1          0506*      pop bc
0B049D F1          0507*      pop af
0B049E C9          0508*      ret
0B049F             0509*  
0B049F             0510*  print_s168_bc_de:
0B049F F5          0511*      push af
0B04A0 C5          0512*      push bc
0B04A1 D5          0513*      push de
0B04A2 C5          0514*      push bc
0B04A3 E1          0515*      pop hl
0B04A4 CD 38 04 0B 0516*      call print_s168
0B04A8 3E 20       0517*      ld a,' '
0B04AA 5B D7       0518*      rst.lil 10h
0B04AC EB          0519*      ex de,hl
0B04AD CD 38 04 0B 0520*      call print_s168
0B04B1 3E 20       0521*      ld a,' '
0B04B3 5B D7       0522*      rst.lil 10h
0B04B5 E1          0523*      pop hl
0B04B6 D1          0524*      pop de
0B04B7 C1          0525*      pop bc
0B04B8 F1          0526*      pop af
0B04B9 C9          0527*      ret
0B04BA             0528*  
0B04BA             0529*  print_s168_a:
0B04BA F5          0530*      push af
0B04BB C5          0531*      push bc
0B04BC E5          0532*      push hl
0B04BD 21 00 00 00 0533*      ld hl,0
0B04C1 6F          0534*      ld l,a
0B04C2 CD 4D 04 0B 0535*      call print_s168_hl
0B04C6 E1          0536*      pop hl
0B04C7 C1          0537*      pop bc
0B04C8 F1          0538*      pop af
0B04C9 C9          0539*      ret
0B04CA             0540*  
0B04CA             0541*  ; #### new functions added by Brandon R. Gates ####
0B04CA             0542*  
0B04CA             0543*  ; print the binary representation of the 8-bit value in a
0B04CA             0544*  ; destroys a, hl, bc
0B04CA             0545*  printBin8:
0B04CA 06 08       0546*      ld b,8      ; loop counter for 8 bits
0B04CC 21 E7 04 0B 0547*      ld hl,@cmd  ; set hl to the low byte of the output string
0B04D0             0548*                  ; (which will be the high bit of the value in a)
0B04D0             0549*  @loop:
0B04D0 07          0550*      rlca ; put the next highest bit into carry
0B04D1 38 04       0551*      jr c,@one
0B04D3 36 30       0552*      ld (hl),'0'
0B04D5 18 02       0553*      jr @next_bit
0B04D7             0554*  @one:
0B04D7 36 31       0555*      ld (hl),'1'
0B04D9             0556*  @next_bit:
0B04D9 23          0557*      inc hl
0B04DA 10 F4       0558*      djnz @loop
0B04DC             0559*  ; print it
0B04DC 21 E7 04 0B 0560*  	ld hl,@cmd
0B04E0 01 08 00 00 0561*  	ld bc,@end-@cmd
0B04E4 5B DF       0562*  	rst.lil $18
0B04E6 C9          0563*  	ret
0B04E7             0564*  @cmd: ds 8 ; eight bytes for eight bits
0B04EF             0565*  @end:
0B04EF             0566*  
0B04EF             0567*  ; print the binary representation of the 8-bit value in a
0B04EF             0568*  ; in reverse order (lsb first)
0B04EF             0569*  ; destroys a, hl, bc
0B04EF             0570*  printBin8Rev:
0B04EF 06 08       0571*      ld b,8      ; loop counter for 8 bits
0B04F1 21 0C 05 0B 0572*      ld hl,@cmd  ; set hl to the low byte of the output string
0B04F5             0573*                  ; (which will be the high bit of the value in a)
0B04F5             0574*  @loop:
0B04F5 0F          0575*      rrca ; put the next lowest bit into carry
0B04F6 38 04       0576*      jr c,@one
0B04F8 36 30       0577*      ld (hl),'0'
0B04FA 18 02       0578*      jr @next_bit
0B04FC             0579*  @one:
0B04FC 36 31       0580*      ld (hl),'1'
0B04FE             0581*  @next_bit:
0B04FE 23          0582*      inc hl
0B04FF 10 F4       0583*      djnz @loop
0B0501             0584*  ; print it
0B0501 21 0C 05 0B 0585*  	ld hl,@cmd
0B0505 01 08 00 00 0586*  	ld bc,@end-@cmd
0B0509 5B DF       0587*  	rst.lil $18
0B050B C9          0588*  	ret
0B050C             0589*  @cmd: ds 8 ; eight bytes for eight bits
0B0514             0590*  @end:
0B0514             0591*  
0B0514             0592*  ; print registers to screen in hexidecimal format
0B0514             0593*  ; inputs: none
0B0514             0594*  ; outputs: values of every register printed to screen
0B0514             0595*  ;    values of each register in global scratch memory
0B0514             0596*  ; destroys: nothing
0B0514             0597*  stepRegistersHex:
0B0514             0598*  ; store everything in scratch
0B0514 22 42 07 0B 0599*      ld (uhl),hl
0B0518 ED 43 45 07 0600*      ld (ubc),bc
       0B          
0B051D ED 53 48 07 0601*      ld (ude),de
       0B          
0B0522 DD 22 4B 07 0602*      ld (uix),ix
       0B          
0B0527 FD 22 4E 07 0603*      ld (uiy),iy
       0B          
0B052C F5          0604*      push af ; fml
0B052D E1          0605*      pop hl  ; thanks, zilog
0B052E 22 3F 07 0B 0606*      ld (uaf),hl
0B0532 F5          0607*      push af ; dammit
0B0533             0608*  
0B0533             0609*  ; home the cursor
0B0533             0610*      ; call vdu_home_cursor
0B0533             0611*  
0B0533             0612*  ; print each register
0B0533 21 C5 06 0B 0613*      ld hl,str_afu
0B0537 CD 73 02 0B 0614*      call printString
0B053B 2A 3F 07 0B 0615*      ld hl,(uaf)
0B053F CD 93 02 0B 0616*      call printHex24
0B0543 CD 88 02 0B 0617*      call printNewLine
0B0547             0618*  
0B0547 21 CA 06 0B 0619*      ld hl,str_hlu
0B054B CD 73 02 0B 0620*      call printString
0B054F 2A 42 07 0B 0621*      ld hl,(uhl)
0B0553 CD 93 02 0B 0622*      call printHex24
0B0557 CD 88 02 0B 0623*      call printNewLine
0B055B             0624*  
0B055B 21 CF 06 0B 0625*      ld hl,str_bcu
0B055F CD 73 02 0B 0626*      call printString
0B0563 2A 45 07 0B 0627*      ld hl,(ubc)
0B0567 CD 93 02 0B 0628*      call printHex24
0B056B CD 88 02 0B 0629*      call printNewLine
0B056F             0630*  
0B056F 21 D4 06 0B 0631*      ld hl,str_deu
0B0573 CD 73 02 0B 0632*      call printString
0B0577 2A 48 07 0B 0633*      ld hl,(ude)
0B057B CD 93 02 0B 0634*      call printHex24
0B057F CD 88 02 0B 0635*      call printNewLine
0B0583             0636*  
0B0583 21 D9 06 0B 0637*      ld hl,str_ixu
0B0587 CD 73 02 0B 0638*      call printString
0B058B 2A 4B 07 0B 0639*      ld hl,(uix)
0B058F CD 93 02 0B 0640*      call printHex24
0B0593 CD 88 02 0B 0641*      call printNewLine
0B0597             0642*  
0B0597 21 DE 06 0B 0643*      ld hl,str_iyu
0B059B CD 73 02 0B 0644*      call printString
0B059F 2A 4E 07 0B 0645*      ld hl,(uiy)
0B05A3 CD 93 02 0B 0646*      call printHex24
0B05A7 CD 88 02 0B 0647*      call printNewLine
0B05AB             0648*  
0B05AB             0649*      ; call vsync
0B05AB             0650*  
0B05AB CD 88 02 0B 0651*      call printNewLine
0B05AF             0652*  
0B05AF             0653*  ; check for right shift key and quit if pressed
0B05AF             0654*  	MOSCALL mos_getkbmap
0B05AF 3E 1E       0001*M 			LD	A, function
0B05B1 5B CF       0002*M 			RST.L	08h
0B05B3             0655*  @stayhere:
0B05B3             0656*  ; 7 RightShift
0B05B3 DD CB 00 76 0657*      bit 6,(ix+0)
0B05B7 20 02       0658*      jr nz,@RightShift
0B05B9 18 F8       0659*      jr @stayhere
0B05BB             0660*  @RightShift:
0B05BB DD CB 0E 86 0661*      res 0,(ix+14) ; debounce the key (hopefully)
0B05BF 3E 80       0662*      ld a,%10000000
0B05C1 CD DA 1E 0B 0663*      call multiPurposeDelay
0B05C5             0664*  
0B05C5             0665*  ; restore everything
0B05C5 2A 42 07 0B 0666*      ld hl, (uhl)
0B05C9 ED 4B 45 07 0667*      ld bc, (ubc)
       0B          
0B05CE ED 5B 48 07 0668*      ld de, (ude)
       0B          
0B05D3 DD 2A 4B 07 0669*      ld ix, (uix)
       0B          
0B05D8 FD 2A 4E 07 0670*      ld iy, (uiy)
       0B          
0B05DD F1          0671*      pop af
0B05DE             0672*  ; all done
0B05DE C9          0673*      ret
0B05DF             0674*  
0B05DF             0675*  ; print registers to screen in hexidecimal format
0B05DF             0676*  ; inputs: none
0B05DF             0677*  ; outputs: values of every register printed to screen
0B05DF             0678*  ;    values of each register in global scratch memory
0B05DF             0679*  ; destroys: nothing
0B05DF             0680*  dumpRegistersHex:
0B05DF             0681*  ; store everything in scratch
0B05DF 22 42 07 0B 0682*      ld (uhl),hl
0B05E3 ED 43 45 07 0683*      ld (ubc),bc
       0B          
0B05E8 ED 53 48 07 0684*      ld (ude),de
       0B          
0B05ED DD 22 4B 07 0685*      ld (uix),ix
       0B          
0B05F2 FD 22 4E 07 0686*      ld (uiy),iy
       0B          
0B05F7 F5          0687*      push af ; fml
0B05F8 E1          0688*      pop hl  ; thanks, zilog
0B05F9 22 3F 07 0B 0689*      ld (uaf),hl
0B05FD F5          0690*      push af ; dammit
0B05FE             0691*  
0B05FE             0692*  ; home the cursor
0B05FE             0693*      ; call vdu_home_cursor
0B05FE             0694*      ; call printNewLine
0B05FE             0695*  
0B05FE             0696*  ; print each register
0B05FE 21 C5 06 0B 0697*      ld hl,str_afu
0B0602 CD 73 02 0B 0698*      call printString
0B0606 2A 3F 07 0B 0699*      ld hl,(uaf)
0B060A CD 93 02 0B 0700*      call printHex24
0B060E             0701*      ; call printNewLine
0B060E             0702*  
0B060E 21 CA 06 0B 0703*      ld hl,str_hlu
0B0612 CD 73 02 0B 0704*      call printString
0B0616 2A 42 07 0B 0705*      ld hl,(uhl)
0B061A CD 93 02 0B 0706*      call printHex24
0B061E             0707*      ; call printNewLine
0B061E             0708*  
0B061E 21 CF 06 0B 0709*      ld hl,str_bcu
0B0622 CD 73 02 0B 0710*      call printString
0B0626 2A 45 07 0B 0711*      ld hl,(ubc)
0B062A CD 93 02 0B 0712*      call printHex24
0B062E             0713*      ; call printNewLine
0B062E             0714*  
0B062E 21 D4 06 0B 0715*      ld hl,str_deu
0B0632 CD 73 02 0B 0716*      call printString
0B0636 2A 48 07 0B 0717*      ld hl,(ude)
0B063A CD 93 02 0B 0718*      call printHex24
0B063E             0719*      ; call printNewLine
0B063E             0720*  
0B063E 21 D9 06 0B 0721*      ld hl,str_ixu
0B0642 CD 73 02 0B 0722*      call printString
0B0646 2A 4B 07 0B 0723*      ld hl,(uix)
0B064A CD 93 02 0B 0724*      call printHex24
0B064E             0725*      ; call printNewLine
0B064E             0726*  
0B064E 21 DE 06 0B 0727*      ld hl,str_iyu
0B0652 CD 73 02 0B 0728*      call printString
0B0656 2A 4E 07 0B 0729*      ld hl,(uiy)
0B065A CD 93 02 0B 0730*      call printHex24
0B065E             0731*      ; call printNewLine
0B065E             0732*  
0B065E             0733*      ; call vdu_vblank
0B065E             0734*  
0B065E CD 88 02 0B 0735*      call printNewLine
0B0662             0736*  ; restore everything
0B0662 2A 42 07 0B 0737*      ld hl, (uhl)
0B0666 ED 4B 45 07 0738*      ld bc, (ubc)
       0B          
0B066B ED 5B 48 07 0739*      ld de, (ude)
       0B          
0B0670 DD 2A 4B 07 0740*      ld ix, (uix)
       0B          
0B0675 FD 2A 4E 07 0741*      ld iy, (uiy)
       0B          
0B067A F1          0742*      pop af
0B067B             0743*  ; all done
0B067B C9          0744*      ret
0B067C             0745*  
0B067C             0746*  ; print hlu to screen in hexidecimal format
0B067C             0747*  ; inputs: none
0B067C             0748*  ; destroys: nothing
0B067C             0749*  print_hex_hl:
0B067C F5          0750*      push af
0B067D E5          0751*      push hl
0B067E 21 CA 06 0B 0752*      ld hl,str_hlu
0B0682 CD 73 02 0B 0753*      call printString
0B0686 E1          0754*      pop hl
0B0687 E5          0755*      push hl
0B0688 CD 93 02 0B 0756*      call printHex24
0B068C 3E 20       0757*      ld a,' '
0B068E 5B D7       0758*      rst.lil 10h
0B0690 E1          0759*      pop hl
0B0691 F1          0760*      pop af
0B0692 C9          0761*      ret
0B0693             0762*  
0B0693             0763*  ; print bcu to screen in hexidecimal format
0B0693             0764*  ; inputs: none
0B0693             0765*  ; destroys: nothing
0B0693             0766*  print_hex_bc:
0B0693 F5          0767*      push af
0B0694 E5          0768*      push hl
0B0695 C5          0769*      push bc
0B0696 21 CF 06 0B 0770*      ld hl,str_bcu
0B069A CD 73 02 0B 0771*      call printString
0B069E E1          0772*      pop hl
0B069F E5          0773*      push hl
0B06A0 CD 93 02 0B 0774*      call printHex24
0B06A4 3E 20       0775*      ld a,' '
0B06A6 5B D7       0776*      rst.lil 10h
0B06A8 C1          0777*      pop bc
0B06A9 E1          0778*      pop hl
0B06AA F1          0779*      pop af
0B06AB C9          0780*      ret
0B06AC             0781*  
0B06AC             0782*  ; print deu to screen in hexidecimal format
0B06AC             0783*  ; inputs: none
0B06AC             0784*  ; destroys: nothing
0B06AC             0785*  print_hex_de:
0B06AC F5          0786*      push af
0B06AD E5          0787*      push hl
0B06AE D5          0788*      push de
0B06AF 21 D4 06 0B 0789*      ld hl,str_deu
0B06B3 CD 73 02 0B 0790*      call printString
0B06B7 E1          0791*      pop hl
0B06B8 E5          0792*      push hl
0B06B9 CD 93 02 0B 0793*      call printHex24
0B06BD 3E 20       0794*      ld a,' '
0B06BF 5B D7       0795*      rst.lil 10h
0B06C1 D1          0796*      pop de
0B06C2 E1          0797*      pop hl
0B06C3 F1          0798*      pop af
0B06C4 C9          0799*      ret
0B06C5             0800*  
0B06C5 20 61 66 3D 0801*  str_afu: db " af=",0
       00          
0B06CA 20 68 6C 3D 0802*  str_hlu: db " hl=",0
       00          
0B06CF 20 62 63 3D 0803*  str_bcu: db " bc=",0
       00          
0B06D4 20 64 65 3D 0804*  str_deu: db " de=",0
       00          
0B06D9 20 69 78 3D 0805*  str_ixu: db " ix=",0
       00          
0B06DE 20 69 79 3D 0806*  str_iyu: db " iy=",0
       00          
0B06E3             0807*  
0B06E3             0808*  ; print udeuhl to screen in hexidecimal format
0B06E3             0809*  ; inputs: none
0B06E3             0810*  ; outputs: concatenated hexidecimal udeuhl
0B06E3             0811*  ; destroys: nothing
0B06E3             0812*  dumpUDEUHLHex:
0B06E3             0813*  ; store everything in scratch
0B06E3 22 42 07 0B 0814*      ld (uhl),hl
0B06E7 ED 43 45 07 0815*      ld (ubc),bc
       0B          
0B06EC ED 53 48 07 0816*      ld (ude),de
       0B          
0B06F1 DD 22 4B 07 0817*      ld (uix),ix
       0B          
0B06F6 FD 22 4E 07 0818*      ld (uiy),iy
       0B          
0B06FB F5          0819*      push af
0B06FC             0820*  
0B06FC             0821*  ; print each register
0B06FC             0822*  
0B06FC 21 36 07 0B 0823*      ld hl,str_udeuhl
0B0700 CD 73 02 0B 0824*      call printString
0B0704 2A 48 07 0B 0825*      ld hl,(ude)
0B0708 CD 93 02 0B 0826*      call printHex24
0B070C 3E 2E       0827*  	ld a,'.'	; print a dot to separate the values
0B070E 5B D7       0828*  	rst.lil 10h
0B0710 2A 42 07 0B 0829*      ld hl,(uhl)
0B0714 CD 93 02 0B 0830*      call printHex24
0B0718 CD 88 02 0B 0831*      call printNewLine
0B071C             0832*  
0B071C             0833*  ; restore everything
0B071C 2A 42 07 0B 0834*      ld hl, (uhl)
0B0720 ED 4B 45 07 0835*      ld bc, (ubc)
       0B          
0B0725 ED 5B 48 07 0836*      ld de, (ude)
       0B          
0B072A DD 2A 4B 07 0837*      ld ix, (uix)
       0B          
0B072F FD 2A 4E 07 0838*      ld iy, (uiy)
       0B          
0B0734 F1          0839*      pop af
0B0735             0840*  ; all done
0B0735 C9          0841*      ret
0B0736             0842*  
0B0736 75 64 65 2E 0843*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B073F             0844*  
0B073F             0845*  ; global scratch memory for registers
0B073F 00 00 00    0846*  uaf: dl 0
0B0742 00 00 00    0847*  uhl: dl 0
0B0745 00 00 00    0848*  ubc: dl 0
0B0748 00 00 00    0849*  ude: dl 0
0B074B 00 00 00    0850*  uix: dl 0
0B074E 00 00 00    0851*  uiy: dl 0
0B0751 00 00 00    0852*  usp: dl 0
0B0754 00 00 00    0853*  upc: dl 0
0B0757             0854*  
0B0757             0855*  ; inputs: whatever is in the flags register
0B0757             0856*  ; outputs: binary representation of flags
0B0757             0857*  ;          with a header so we know which is what
0B0757             0858*  ; destroys: nothing
0B0757             0859*  ; preserves: everything
0B0757             0860*  dumpFlags:
0B0757             0861*  ; first we curse zilog for not giving direct access to flags
0B0757 F5          0862*      push af ; this is so we can send it back unharmed
0B0758 F5          0863*      push af ; this is so we can pop it to hl
0B0759             0864*  ; store everything in scratch
0B0759 22 42 07 0B 0865*      ld (uhl),hl
0B075D ED 43 45 07 0866*      ld (ubc),bc
       0B          
0B0762 ED 53 48 07 0867*      ld (ude),de
       0B          
0B0767 DD 22 4B 07 0868*      ld (uix),ix
       0B          
0B076C FD 22 4E 07 0869*      ld (uiy),iy
       0B          
0B0771             0870*  ; next we print the header
0B0771 21 9D 07 0B 0871*      ld hl,@header
0B0775 CD 73 02 0B 0872*      call printString
0B0779 E1          0873*      pop hl ; flags are now in l
0B077A 7D          0874*      ld a,l ; flags are now in a
0B077B CD CA 04 0B 0875*      call printBin8
0B077F CD 88 02 0B 0876*  	call printNewLine
0B0783             0877*  ; restore everything
0B0783 2A 42 07 0B 0878*      ld hl, (uhl)
0B0787 ED 4B 45 07 0879*      ld bc, (ubc)
       0B          
0B078C ED 5B 48 07 0880*      ld de, (ude)
       0B          
0B0791 DD 2A 4B 07 0881*      ld ix, (uix)
       0B          
0B0796 FD 2A 4E 07 0882*      ld iy, (uiy)
       0B          
0B079B F1          0883*      pop af ; send her home the way she came
0B079C C9          0884*      ret
0B079D             0885*  ; Bit 7 (S): Sign flag
0B079D             0886*  ; Bit 6 (Z): Zero flag
0B079D             0887*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B079D             0888*  ; Bit 4 (H): Half Carry flag
0B079D             0889*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B079D             0890*  ; Bit 2 (PV): Parity/Overflow flag
0B079D             0891*  ; Bit 1 (N): Subtract flag
0B079D             0892*  ; Bit 0 (C): Carry flag
0B079D 53 5A 78 48 0893*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B07A8             0894*  
0B07A8             0895*  ; set all the bits in the flag register
0B07A8             0896*  ; more of an academic exercise than anything useful
0B07A8             0897*  ; inputs; none
0B07A8             0898*  ; outputs; a=0,f=255
0B07A8             0899*  ; destroys: flags, hl
0B07A8             0900*  ; preserves: a, because why not
0B07A8             0901*  setAllFlags:
0B07A8 21 FF 00 00 0902*      ld hl,255
0B07AC 67          0903*      ld h,a ; four cycles to preserve a is cheap
0B07AD E5          0904*      push hl
0B07AE F1          0905*      pop af
0B07AF C9          0906*      ret
0B07B0             0907*  
0B07B0             0908*  ; reset all the bits in the flag register
0B07B0             0909*  ; unlike its inverse counterpart, this may actually be useful
0B07B0             0910*  ; inputs; none
0B07B0             0911*  ; outputs; a=0,f=0
0B07B0             0912*  ; destroys: flags, hl
0B07B0             0913*  ; preserves: a, because why not
0B07B0             0914*  resetAllFlags:
0B07B0 21 00 00 00 0915*      ld hl,0
0B07B4 67          0916*      ld h,a ; four cycles to preserve a is cheap
0B07B5 E5          0917*      push hl
0B07B6 F1          0918*      pop af
0B07B7 C9          0919*      ret
0B07B8             0920*  
0B07B8             0921*  ; wait until user presses a key
0B07B8             0922*  ; inputs: none
0B07B8             0923*  ; outputs: none
0B07B8             0924*  ; destroys: af,ix
0B07B8             0925*  waitKeypress:
0B07B8             0926*      MOSCALL mos_sysvars
0B07B8 3E 08       0001*M 			LD	A, function
0B07BA 5B CF       0002*M 			RST.L	08h
0B07BC AF          0927*      xor a ; zero out any prior keypresses
0B07BD DD 77 05    0928*      ld (ix+sysvar_keyascii),a
0B07C0             0929*  @loop:
0B07C0 DD 7E 05    0930*      ld a,(ix+sysvar_keyascii)
0B07C3 A7          0931*      and a
0B07C4 C0          0932*      ret nz
0B07C5 18 F9       0933*      jr @loop
0B07C7             0934*  
0B07C7             0935*  
0B07C7             0936*  ; print bytes from an address to the screen in hexidecimal format
0B07C7             0937*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07C7             0938*  ; outputs: values of each byte printed to screen separated by spaces
0B07C7             0939*  ; destroys: nothing
0B07C7             0940*  dumpMemoryHex:
0B07C7             0941*  ; save registers to the stack
0B07C7 C5          0942*      push bc
0B07C8 E5          0943*      push hl
0B07C9 F5          0944*      push af
0B07CA             0945*  
0B07CA             0946*  ; print the address and separator
0B07CA CD 93 02 0B 0947*      call printHex24
0B07CE 3E 3A       0948*      ld a,':'
0B07D0 5B D7       0949*      rst.lil 10h
0B07D2 3E 20       0950*      ld a,' '
0B07D4 5B D7       0951*      rst.lil 10h
0B07D6             0952*  
0B07D6             0953*  ; set b to be our loop counter
0B07D6 F1          0954*      pop af
0B07D7 47          0955*      ld b,a
0B07D8 E1          0956*      pop hl
0B07D9 E5          0957*      push hl
0B07DA F5          0958*      push af
0B07DB             0959*  @loop:
0B07DB             0960*  ; print the byte
0B07DB 7E          0961*      ld a,(hl)
0B07DC CD A1 02 0B 0962*      call printHex8
0B07E0             0963*  ; print a space
0B07E0 3E 20       0964*      ld a,' '
0B07E2 5B D7       0965*      rst.lil 10h
0B07E4 23          0966*      inc hl
0B07E5 10 F4       0967*      djnz @loop
0B07E7 CD 88 02 0B 0968*      call printNewLine
0B07EB             0969*  
0B07EB             0970*  ; restore everything
0B07EB F1          0971*      pop af
0B07EC E1          0972*      pop hl
0B07ED C1          0973*      pop bc
0B07EE             0974*  
0B07EE             0975*  ; all done
0B07EE C9          0976*      ret
0B07EF             0977*  
0B07EF             0978*  
0B07EF             0979*  ; print bytes from an address to the screen in binary format
0B07EF             0980*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B07EF             0981*  ; outputs: values of each byte printed to screen separated by spaces
0B07EF             0982*  ; destroys: nothing
0B07EF             0983*  dumpMemoryBin:
0B07EF             0984*  ; save all registers to the stack
0B07EF F5          0985*      push af
0B07F0 C5          0986*      push bc
0B07F1 D5          0987*      push de
0B07F2 E5          0988*      push hl
0B07F3 DD E5       0989*      push ix
0B07F5 FD E5       0990*      push iy
0B07F7             0991*  
0B07F7             0992*  ; set b to be our loop counter
0B07F7 47          0993*      ld b,a
0B07F8             0994*  @loop:
0B07F8             0995*  ; print the byte
0B07F8 7E          0996*      ld a,(hl)
0B07F9 E5          0997*      push hl
0B07FA C5          0998*      push bc
0B07FB CD CA 04 0B 0999*      call printBin8
0B07FF C1          1000*      pop bc
0B0800             1001*  ; print a space
0B0800 3E 20       1002*      ld a,' '
0B0802 5B D7       1003*      rst.lil 10h
0B0804 E1          1004*      pop hl
0B0805 23          1005*      inc hl
0B0806 10 F0       1006*      djnz @loop
0B0808 CD 88 02 0B 1007*      call printNewLine
0B080C             1008*  
0B080C             1009*  ; restore everything
0B080C FD E1       1010*      pop iy
0B080E DD E1       1011*      pop ix
0B0810 E1          1012*      pop hl
0B0811 D1          1013*      pop de
0B0812 C1          1014*      pop bc
0B0813 F1          1015*      pop af
0B0814             1016*  ; all done
0B0814 C9          1017*      ret
0B0815             1018*  
0B0815             1019*  ; print bytes from an address to the screen in binary format
0B0815             1020*  ; with the bits of each byte in reverse order (lsb first)
0B0815             1021*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0815             1022*  ; outputs: values of each byte printed to screen separated by spaces
0B0815             1023*  ; destroys: nothing
0B0815             1024*  dumpMemoryBinRev:
0B0815             1025*  ; save all registers to the stack
0B0815 F5          1026*      push af
0B0816 C5          1027*      push bc
0B0817 D5          1028*      push de
0B0818 E5          1029*      push hl
0B0819 DD E5       1030*      push ix
0B081B FD E5       1031*      push iy
0B081D             1032*  
0B081D             1033*  ; set b to be our loop counter
0B081D 47          1034*      ld b,a
0B081E             1035*  @loop:
0B081E             1036*  ; print the byte
0B081E 7E          1037*      ld a,(hl)
0B081F E5          1038*      push hl
0B0820 C5          1039*      push bc
0B0821 CD EF 04 0B 1040*      call printBin8Rev
0B0825 C1          1041*      pop bc
0B0826             1042*  ; print a space
0B0826 3E 20       1043*      ld a,' '
0B0828 5B D7       1044*      rst.lil 10h
0B082A E1          1045*      pop hl
0B082B 23          1046*      inc hl
0B082C 10 F0       1047*      djnz @loop
0B082E CD 88 02 0B 1048*      call printNewLine
0B0832             1049*  
0B0832             1050*  ; restore everything
0B0832 FD E1       1051*      pop iy
0B0834 DD E1       1052*      pop ix
0B0836 E1          1053*      pop hl
0B0837 D1          1054*      pop de
0B0838 C1          1055*      pop bc
0B0839 F1          1056*      pop af
0B083A             1057*  ; all done
0B083A C9          1058*      ret
0B083B             0020       include "maths.inc"
0B083B             0001*  ; absolute value of hlu
0B083B             0002*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B083B             0003*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B083B             0004*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B083B             0005*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B083B             0006*  ; destroys: a
0B083B             0007*  hlu_abs:
0B083B 19          0008*      add hl,de
0B083C B7          0009*      or a
0B083D ED 52       0010*      sbc hl,de
0B083F FA 44 08 0B 0011*      jp m,@is_neg
0B0843 C9          0012*      ret         ; hlu is positive or zero so we're done
0B0844             0013*  @is_neg:
0B0844 F5          0014*      push af     ; otherwise, save current flags for return
0B0845 CD 4B 08 0B 0015*      call neg_hlu ; negate hlu
0B0849 F1          0016*      pop af      ; get back flags
0B084A C9          0017*      ret
0B084B             0018*  
0B084B             0019*  ; flip the sign of hlu
0B084B             0020*  ; inputs: hlu
0B084B             0021*  ; returns: 0-hlu, flags set appropriately for the result:
0B084B             0022*  ;         s1,z0,pv0,n1,c1 if result is negative
0B084B             0023*  ;         s0,z1,pv0,n1,c0 if result is zero
0B084B             0024*  ;         s0,z0,pv0,n1,c1 if result is positive
0B084B             0025*  ; destroys a
0B084B             0026*  neg_hlu:
0B084B D5          0027*      push de     ; save de
0B084C EB          0028*      ex de,hl    ; put hl into de
0B084D 21 00 00 00 0029*      ld hl,0     ; clear hl
0B0851 AF          0030*      xor a       ; clear carry
0B0852 ED 52       0031*      sbc hl,de   ; 0-hlu = -hlu
0B0854 D1          0032*      pop de      ; get de back
0B0855 C9          0033*      ret         ; easy peasy
0B0856             0034*  
0B0856             0035*  ;------------------------------------------------------------------------
0B0856             0036*  ; divide hlu by 2, inspired by above
0B0856             0037*  ;------------------------------------------------------------------------
0B0856             0038*  hlu_div2:
0B0856 22 E4 09 0B 0039*  	ld		(bitbuf1),hl
0B085A 21 E6 09 0B 0040*  	ld		hl,bitbuf1+2
0B085E CB 1E       0041*  	rr		(hl)
0B0860 2B          0042*  	dec		hl
0B0861 CB 1E       0043*  	rr		(hl)
0B0863 2B          0044*  	dec		hl
0B0864 CB 1E       0045*  	rr		(hl)
0B0866 23          0046*  	inc		hl
0B0867 23          0047*  	inc		hl
0B0868 2A E4 09 0B 0048*      ld hl,(bitbuf1)
0B086C C9          0049*      ret
0B086D             0050*  
0B086D             0051*  ; this is my little hack to divide by 16
0B086D             0052*  hlu_div16:
0B086D AF          0053*      xor a
0B086E 29          0054*      add hl,hl
0B086F 17          0055*      rla
0B0870 29          0056*      add hl,hl
0B0871 17          0057*      rla
0B0872 29          0058*      add hl,hl
0B0873 17          0059*      rla
0B0874 29          0060*      add hl,hl
0B0875 17          0061*      rla
0B0876 22 83 08 0B 0062*      ld (@scratch),hl
0B087A 32 86 08 0B 0063*      ld (@scratch+3),a
0B087E 2A 84 08 0B 0064*      ld hl,(@scratch+1)
0B0882 C9          0065*      ret
0B0883             0066*  @scratch: ds 4
0B0887             0067*  
0B0887             0068*  ; hlu signed division by 256
0B0887             0069*  ; returns: hlu / 256
0B0887             0070*  ; destroys: af
0B0887             0071*  hlu_sdiv256:
0B0887 AF          0072*      xor a ; assume hl is positive
0B0888 22 9E 08 0B 0073*      ld (@buffer),hl
0B088C             0074*      sign_hlu
0B088C 19          0001*M         add hl,de
0B088D B7          0002*M         or a
0B088E ED 52       0003*M         sbc hl,de
0B0890 F2 95 08 0B 0075*      jp p,@hl_pos
0B0894 3D          0076*      dec a
0B0895             0077*  @hl_pos:
0B0895 32 A1 08 0B 0078*      ld (@buffer+3),a
0B0899 2A 9F 08 0B 0079*      ld hl,(@buffer+1)
0B089D C9          0080*      ret
0B089E             0081*  @buffer: ds 4
0B08A2             0082*  
0B08A2             0083*  ; hlu 1 byte right shift, unsigned
0B08A2             0084*  ; returns: hlu / 256, fractional portion in a
0B08A2             0085*  ; destroys: af
0B08A2             0086*  hlu_udiv256:
0B08A2 AF          0087*  	xor a
0B08A3 32 B4 08 0B 0088*  	ld (@buffer+3),a
0B08A7 7D          0089*  	ld a,l ; save the fractional portion
0B08A8 22 B1 08 0B 0090*  	ld (@buffer),hl
0B08AC 2A B2 08 0B 0091*  	ld hl,(@buffer+1)
0B08B0 C9          0092*  	ret
0B08B1             0093*  @buffer: ds 4
0B08B5             0094*  
0B08B5             0095*      MACRO hlu_mul256
0B08B5             0096*          add hl,hl ; * 2
0B08B5             0097*          add hl,hl ; * 4
0B08B5             0098*          add hl,hl ; * 8
0B08B5             0099*          add hl,hl ; * 16
0B08B5             0100*          add hl,hl ; * 32
0B08B5             0101*          add hl,hl ; * 64
0B08B5             0102*          add hl,hl ; * 128
0B08B5             0103*          add hl,hl ; * 256
0B08B5             0104*      ENDMACRO
0B08B5             0105*  
0B08B5             0106*  ; compute the modulo of hlu by deu
0B08B5             0107*  ; outputs: hlu = hlu % deu
0B08B5             0108*  ; destroys: f, hl
0B08B5             0109*  hlu_mod:
0B08B5 B7          0110*  	or a ; clear carry
0B08B6             0111*  @loop:
0B08B6 ED 52       0112*      sbc hl,de
0B08B8 DA C0 08 0B 0113*      jp c, @end
0B08BC C3 B6 08 0B 0114*      jp @loop
0B08C0             0115*  @end:
0B08C0 19          0116*      add hl,de
0B08C1 C9          0117*  	ret
0B08C2             0118*  
0B08C2             0119*  
0B08C2 00 00 00 00 0120*  add_bcd_arg1: db #00,#00,#00,#00
0B08C6 00 00 00 00 0121*  add_bcd_arg2: db #00,#00,#00,#00
0B08CA             0122*  
0B08CA             0123*  ; set bcd values in a scratch memory address from registers bcde
0B08CA             0124*  ; input: hl; scratch address,bcde; 8-place bcd number
0B08CA             0125*  ; destroys ; hl
0B08CA             0126*  set_bcd:
0B08CA 73          0127*      ld (hl),e
0B08CB 23          0128*      inc hl
0B08CC 72          0129*      ld (hl),d
0B08CD 23          0130*      inc hl
0B08CE 71          0131*      ld (hl),c
0B08CF 23          0132*      inc hl
0B08D0 70          0133*      ld (hl),b
0B08D1 C9          0134*      ret
0B08D2             0135*  
0B08D2             0136*  ; load bcd values from a scratch memory address to bcde
0B08D2             0137*  ; input: hl; scratch address
0B08D2             0138*  ; output: bcde; 8-place bcd number
0B08D2             0139*  ; destroys: hl
0B08D2             0140*  get_bcd:
0B08D2 5E          0141*      ld e,(hl)
0B08D3 23          0142*      inc hl
0B08D4 56          0143*      ld d,(hl)
0B08D5 23          0144*      inc hl
0B08D6 4E          0145*      ld c,(hl)
0B08D7 23          0146*      inc hl
0B08D8 46          0147*      ld b,(hl)
0B08D9 C9          0148*      ret
0B08DA             0149*  
0B08DA             0150*  ; BCD addition
0B08DA             0151*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08DA             0152*  ;       a is the number of bytes holding each number (number of places/2)
0B08DA             0153*  ; outputs: (hl) + (de) --> (hl)
0B08DA             0154*  ; destroys: a,b,de,hl
0B08DA             0155*  add_bcd:
0B08DA 47          0156*      ld b,a ; loop counter
0B08DB AF          0157*      xor a ; reset a, clear carry flag
0B08DC             0158*  adcec:
0B08DC 1A          0159*      ld a,(de) ; addend to acc
0B08DD 8E          0160*      adc a,(hl) ; add (hl) to acc
0B08DE 27          0161*      daa ; adjust result to bcd
0B08DF 77          0162*      ld (hl),a ; store result
0B08E0 23          0163*      inc hl ; advance memory pointers
0B08E1 13          0164*      inc de
0B08E2 10 F8       0165*      djnz adcec ; loop until b == 0
0B08E4 C9          0166*      ret
0B08E5             0167*  
0B08E5             0168*  ; BCD subtraction
0B08E5             0169*  ; inputs: (hl) and (de) point to BCD numbers of equal length (divisible by 2)
0B08E5             0170*  ;       a is the number of bytes holding each number (number of places/2)
0B08E5             0171*  ; outputs: (hl) - (de) --> (hl)
0B08E5             0172*  ; destroys: a,b,de,hl
0B08E5             0173*  sub_bcd:
0B08E5 47          0174*      ld b,a ; loop counter
0B08E6 AF          0175*      xor a ; reset a,clear carry flag
0B08E7             0176*  subdec:
0B08E7 1A          0177*      ld a,(de) ; subtrahend to acc
0B08E8 9E          0178*      sbc a,(hl) ; subtract (hl) from acc
0B08E9 27          0179*      daa ; adjust result to bcd
0B08EA 77          0180*      ld (hl),a ; store result
0B08EB 23          0181*      inc hl ; advance memory pointers
0B08EC 13          0182*      inc de
0B08ED 10 F8       0183*      djnz subdec ; loop until b == 0
0B08EF C9          0184*      ret
0B08F0             0185*  
0B08F0             0186*  ; http://www.z80.info/pseudo-random.txt
0B08F0             0187*  rand_8:
0B08F0 C5          0188*      push bc
0B08F1 3A 04 09 0B 0189*      ld a,(r_seed)
0B08F5 4F          0190*      ld c,a
0B08F6             0191*  
0B08F6 0F          0192*      rrca ; multiply by 32
0B08F7 0F          0193*      rrca
0B08F8 0F          0194*      rrca
0B08F9 EE 1F       0195*      xor 0x1f
0B08FB             0196*  
0B08FB 81          0197*      add a,c
0B08FC DE FF       0198*      sbc a,255 ; carry
0B08FE             0199*  
0B08FE 32 04 09 0B 0200*      ld (r_seed),a
0B0902 C1          0201*      pop bc
0B0903 C9          0202*      ret
0B0904 50          0203*  r_seed: defb $50
0B0905             0204*  
0B0905             0205*  ; linear interpolation between two 24-bit numbers
0B0905             0206*  ; may be signed or unsigned, and treated as integers or fractional
0B0905             0207*  ; inputs: bc = start value, de = end value, a = interpolation factor
0B0905             0208*  ; outputs: hl = interpolated value, a = multiply overflow to 32 bits (0 if no overflow)
0B0905             0209*  ; destroys: af, hl, de
0B0905             0210*  interpolate24:
0B0905 C5          0211*      push bc ; save start value
0B0906 EB          0212*      ex de,hl ; end value to hl
0B0907 B7          0213*      or a ; clear carry
0B0908 ED 42       0214*      sbc hl,bc ; hl = end - start
0B090A CD AF 0A 0B 0215*      call umul24x8 ; hl = (end - start) * interpolation factor
0B090E C1          0216*      pop bc ; get back start value (was hl)
0B090F 09          0217*      add hl,bc ; hl = start + (end - start) * interpolation factor
0B0910 C9          0218*      ret
0B0911             0021   	INCLUDE	"arith24.inc"
0B0911             0001*  ;------------------------------------------------------------------------
0B0911             0002*  ;  arith24.asm
0B0911             0003*  ;  24-bit ez80 arithmetic routines
0B0911             0004*  ;  Copyright (c) Shawn Sijnstra 2024
0B0911             0005*  ;  MIT license
0B0911             0006*  ;
0B0911             0007*  ;  This library was created as a tool to help make ez80
0B0911             0008*  ;  24-bit native assembly routines for simple mathematical problems
0B0911             0009*  ;  more widely available.
0B0911             0010*  ;
0B0911             0011*  ;------------------------------------------------------------------------
0B0911             0012*  
0B0911             0013*  ;------------------------------------------------------------------------
0B0911             0014*  ; umul24:	HL = HL*DE (unsigned)
0B0911             0015*  ; Preserves AF, BC, DE
0B0911             0016*  ; Uses a fast multiply routine.
0B0911             0017*  ;------------------------------------------------------------------------
0B0911             0018*  umul24:
0B0911 D5          0019*  	push	DE
0B0912 C5          0020*  	push	BC
0B0913 F5          0021*  	push	AF
0B0914 E5          0022*  	push	HL
0B0915 C1          0023*  	pop		BC
0B0916 3E 18       0024*      ld	 	a, 24 ; No. of bits to process
0B0918 21 00 00 00 0025*      ld	 	hl, 0 ; Result
0B091C             0026*  umul24_lp:
0B091C 29          0027*  	add	hl,hl
0B091D EB          0028*  	ex	de,hl
0B091E 29          0029*  	add	hl,hl
0B091F EB          0030*  	ex	de,hl
0B0920 30 01       0031*  	jr	nc,umul24_nc
0B0922 09          0032*  	add	hl,bc
0B0923             0033*  umul24_nc:
0B0923 3D          0034*  	dec	a
0B0924 20 F6       0035*  	jr	nz,umul24_lp
0B0926 F1          0036*  	pop	af
0B0927 C1          0037*  	pop	bc
0B0928 D1          0038*  	pop	de
0B0929 C9          0039*  	ret
0B092A             0040*  
0B092A             0041*  
0B092A             0042*  ;------------------------------------------------------------------------
0B092A             0043*  ; udiv24
0B092A             0044*  ; Unsigned 24-bit division
0B092A             0045*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B092A             0046*  ;
0B092A             0047*  ; Uses AF BC DE HL
0B092A             0048*  ; Uses Restoring Division algorithm
0B092A             0049*  ;------------------------------------------------------------------------
0B092A             0050*  
0B092A             0051*  udiv24:
0B092A E5          0052*  	push	hl
0B092B C1          0053*  	pop		bc	;move dividend to BCU
0B092C 21 00 00 00 0054*  	ld		hl,0	;result
0B0930 A7          0055*  	and		a
0B0931 ED 52       0056*  	sbc		hl,de	;test for div by 0
0B0933 C8          0057*  	ret		z		;it's zero, carry flag is clear
0B0934 19          0058*  	add		hl,de	;HL is 0 again
0B0935 3E 18       0059*  	ld		a,24	;number of loops through.
0B0937             0060*  udiv1:
0B0937 C5          0061*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0938 E3          0062*  	ex		(sp),hl
0B0939 37          0063*  	scf
0B093A ED 6A       0064*  	adc	hl,hl
0B093C E3          0065*  	ex	(sp),hl
0B093D C1          0066*  	pop	bc		;we now have bc = (bc * 2) + 1
0B093E             0067*  
0B093E ED 6A       0068*  	adc	hl,hl
0B0940 A7          0069*  	and	a		;is this the bug
0B0941 ED 52       0070*  	sbc	hl,de
0B0943 30 02       0071*  	jr	nc,udiv2
0B0945 19          0072*  	add	hl,de
0B0946             0073*  ;	dec	c
0B0946 0B          0074*  	dec	bc
0B0947             0075*  udiv2:
0B0947 3D          0076*  	dec	a
0B0948 20 ED       0077*  	jr	nz,udiv1
0B094A 37          0078*  	scf		;flag used for div0 error
0B094B C5          0079*  	push	bc
0B094C D1          0080*  	pop		de	;remainder
0B094D C9          0081*  	ret
0B094E             0082*  
0B094E             0083*  
0B094E             0084*  
0B094E             0085*  ;------------------------------------------------------------------------
0B094E             0086*  ; neg24
0B094E             0087*  ; Returns: HLU = 0-HLU
0B094E             0088*  ; preserves all other registers
0B094E             0089*  ;------------------------------------------------------------------------
0B094E             0090*  neg24:
0B094E D5          0091*  	push	de
0B094F EB          0092*  	ex		de,hl
0B0950 21 00 00 00 0093*  	ld		hl,0
0B0954 B7          0094*  	or		a
0B0955 ED 52       0095*  	sbc		hl,de
0B0957 D1          0096*  	pop		de
0B0958 C9          0097*  	ret
0B0959             0098*  
0B0959             0099*  ;------------------------------------------------------------------------
0B0959             0100*  ; or_hlu_deu: 24 bit bitwise OR
0B0959             0101*  ; Returns: hlu = hlu OR deu
0B0959             0102*  ; preserves all other registers
0B0959             0103*  ;------------------------------------------------------------------------
0B0959             0104*  or_hlu_deu:
0B0959 22 E4 09 0B 0105*  	ld	(bitbuf1),hl
0B095D ED 53 E7 09 0106*  	ld	(bitbuf2),de
       0B          
0B0962 D5          0107*  	push	de	;preserve DEU
0B0963 C5          0108*  	push	bc	;preserve BCU
0B0964 06 03       0109*  	ld		b,3
0B0966 21 E4 09 0B 0110*  	ld	hl,bitbuf1
0B096A 11 E4 09 0B 0111*  	ld	de,bitbuf1
0B096E             0112*  orloop_24:
0B096E 1A          0113*  	ld	a,(de)
0B096F B6          0114*  	or	(hl)
0B0970 12          0115*  	ld	(de),a
0B0971 13          0116*  	inc	de
0B0972 23          0117*  	inc	hl
0B0973 10 F9       0118*  	djnz	orloop_24
0B0975 2A E7 09 0B 0119*  	ld	hl,(bitbuf2)
0B0979 C1          0120*  	pop		bc	;restore BC
0B097A D1          0121*  	pop		de	;restore DE
0B097B             0122*  
0B097B             0123*  ;------------------------------------------------------------------------
0B097B             0124*  ; and_hlu_deu: 24 bit bitwise AND
0B097B             0125*  ; Returns: hlu = hlu AND deu
0B097B             0126*  ; preserves all other registers
0B097B             0127*  ;------------------------------------------------------------------------
0B097B             0128*  and_hlu_deu:
0B097B 22 E4 09 0B 0129*  	ld	(bitbuf1),hl
0B097F ED 53 E7 09 0130*  	ld	(bitbuf2),de
       0B          
0B0984 D5          0131*  	push	de	;preserve DEU
0B0985 C5          0132*  	push	bc	;preserve BCU
0B0986 06 03       0133*  	ld		b,3
0B0988 21 E4 09 0B 0134*  	ld	hl,bitbuf1
0B098C 11 E4 09 0B 0135*  	ld	de,bitbuf1
0B0990             0136*  andloop_24:
0B0990 1A          0137*  	ld	a,(de)
0B0991 A6          0138*  	and	(hl)
0B0992 12          0139*  	ld	(de),a
0B0993 13          0140*  	inc	de
0B0994 23          0141*  	inc	hl
0B0995 10 F9       0142*  	djnz	andloop_24
0B0997 2A E7 09 0B 0143*  	ld	hl,(bitbuf2)
0B099B C1          0144*  	pop		bc	;restore BC
0B099C D1          0145*  	pop		de	;restore DE
0B099D             0146*  
0B099D             0147*  ;------------------------------------------------------------------------
0B099D             0148*  ; xor_hlu_deu: 24 bit bitwise XOR
0B099D             0149*  ; Returns: hlu = hlu XOR deu
0B099D             0150*  ; preserves all other registers
0B099D             0151*  ;------------------------------------------------------------------------
0B099D             0152*  xor_hlu_deu:
0B099D 22 E4 09 0B 0153*  	ld	(bitbuf1),hl
0B09A1 ED 53 E7 09 0154*  	ld	(bitbuf2),de
       0B          
0B09A6 D5          0155*  	push	de	;preserve DEU
0B09A7 C5          0156*  	push	bc	;preserve BCU
0B09A8 06 03       0157*  	ld		b,3
0B09AA 21 E4 09 0B 0158*  	ld	hl,bitbuf1
0B09AE 11 E4 09 0B 0159*  	ld	de,bitbuf1
0B09B2             0160*  xorloop_24:
0B09B2 1A          0161*  	ld	a,(de)
0B09B3 AE          0162*  	xor	(hl)
0B09B4 12          0163*  	ld	(de),a
0B09B5 13          0164*  	inc	de
0B09B6 23          0165*  	inc	hl
0B09B7 10 F9       0166*  	djnz	xorloop_24
0B09B9 2A E7 09 0B 0167*  	ld	hl,(bitbuf2)
0B09BD C1          0168*  	pop		bc	;restore BC
0B09BE D1          0169*  	pop		de	;restore DE
0B09BF             0170*  
0B09BF             0171*  ;------------------------------------------------------------------------
0B09BF             0172*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B09BF             0173*  ; Returns: hlu = hlu << deu
0B09BF             0174*  ;		   de = 0
0B09BF             0175*  ; NOTE: only considers deu up to 16 bits.
0B09BF             0176*  ; preserves all other registers
0B09BF             0177*  ;------------------------------------------------------------------------
0B09BF             0178*  shl_hlu:
0B09BF 7A          0179*  	ld		a,d		;up to 16 bit.
0B09C0 B3          0180*  	or		e
0B09C1 C8          0181*  	ret		z		;we're done
0B09C2 29          0182*  	add		hl,hl	;shift HLU left
0B09C3 1B          0183*  	dec		de
0B09C4 18 F9       0184*  	jr		shl_hlu
0B09C6             0185*  
0B09C6             0186*  ;------------------------------------------------------------------------
0B09C6             0187*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B09C6             0188*  ; Returns: hlu = hlu >> deu
0B09C6             0189*  ;		   de = 0
0B09C6             0190*  ; NOTE: only considers deu up to 16 bits.
0B09C6             0191*  ; preserves all other registers
0B09C6             0192*  ;------------------------------------------------------------------------
0B09C6             0193*  shr_hlu:
0B09C6 22 E4 09 0B 0194*  	ld		(bitbuf1),hl
0B09CA 21 E6 09 0B 0195*  	ld		hl,bitbuf1+2
0B09CE             0196*  shr_loop:
0B09CE 7A          0197*  	ld		a,d		;up to 16 bit.
0B09CF B3          0198*  	or		e
0B09D0 28 0D       0199*  	jr		z,shr_done		;we're done
0B09D2             0200*  ;carry is clear from or instruction
0B09D2 CB 1E       0201*  	rr		(hl)
0B09D4 2B          0202*  	dec		hl
0B09D5 CB 1E       0203*  	rr		(hl)
0B09D7 2B          0204*  	dec		hl
0B09D8 CB 1E       0205*  	rr		(hl)
0B09DA 23          0206*  	inc		hl
0B09DB 23          0207*  	inc		hl
0B09DC 1B          0208*  	dec		de
0B09DD 18 EF       0209*  	jr		shr_loop
0B09DF             0210*  shr_done:
0B09DF 2A E4 09 0B 0211*  	ld		hl,(bitbuf1)	;collect result
0B09E3 C9          0212*  	ret
0B09E4             0213*  
0B09E4             0214*  ;------------------------------------------------------------------------
0B09E4             0215*  ; Scratch area for calculations
0B09E4             0216*  ;------------------------------------------------------------------------
0B09E4 00 00 00    0217*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B09E7 00 00 00    0218*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B09EA             0022       include "fixed24.inc"
0B09EA             0001*  arith24uaf: ds 6
0B09F0             0002*  arith24uhl: ds 6
0B09F6             0003*  arith24ubc: ds 6
0B09FC             0004*  arith24ude: ds 6
0B0A02             0005*  arith24uix: ds 6
0B0A08             0006*  arith24uiy: ds 6
0B0A0E             0007*  arith24usp: ds 6
0B0A14             0008*  arith24upc: ds 6
0B0A1A             0009*  
0B0A1A             0010*  ; operation: UHL * UDE --> UHL
0B0A1A             0011*  ; multiply unsigned 24-bit numbers and return a 48-bit intermediate
0B0A1A             0012*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0B0A1A             0013*  ; inputs: hl = 24-bit number, de = 24-bit number,
0B0A1A             0014*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0B0A1A             0015*  ; outputs: umulfxout = 48-bit intermediate
0B0A1A             0016*  ; destroys: af, hl, bc, de
0B0A1A             0017*  umulfx:
0B0A1A DD E5       0018*      push ix ; preserve
0B0A1C F5          0019*      push af ; need later
0B0A1D             0020*  
0B0A1D             0021*  ; do the multiplication
0B0A1D CD DE 0A 0B 0022*      call umul24x24
0B0A21             0023*      ; DEBUG
0B0A21 21 73 0A 0B 0024*      ld hl,umulfxout ; point to output buffer
0B0A25 3E 06       0025*      ld a,6 ; 6 bytes to print
0B0A27 CD C7 07 0B 0026*      call dumpMemoryHex ; print the result
0B0A2B             0027*      ; END DEBUG
0B0A2B             0028*  
0B0A2B             0029*  ; shift the result to the required output precision
0B0A2B 78          0030*      ld a,b
0B0A2C 81          0031*      add a,c ; a is left shift from the multiplication
0B0A2D C1          0032*      pop bc ; b is the output precision (was a)
0B0A2E 90          0033*      sub b ; a is the net shift of the output
0B0A2F             0034*  
0B0A2F             0035*  ; Get absolute value of a and save its original sign
0B0A2F B7          0036*      or a
0B0A30 F5          0037*      push af ; save sign flag
0B0A31 F2 37 0A 0B 0038*      jp p,@F ; If a is positive do nothing
0B0A35 ED 44       0039*      neg ; If a is negative, negate it
0B0A37             0040*  @@:
0B0A37             0041*  
0B0A37             0042*  ; Divide a by 8 to get the whole byte shift and bit remainder
0B0A37 47          0043*      ld b,a            ; Store 'a' temporarily in 'b' (net shift)
0B0A38 CB 3F       0044*      srl a             ; a = a / 2 (shift right 1 bit)
0B0A3A CB 3F       0045*      srl a             ; a = a / 4 (shift right another bit)
0B0A3C CB 3F       0046*      srl a             ; a = a / 8 (final shift for division by 8)
0B0A3E 4F          0047*      ld c,a            ; c holds the number of whole bytes to shift
0B0A3F             0048*  
0B0A3F             0049*  ; Calculate remainder of a (original shift) mod 8
0B0A3F 78          0050*      ld a,b            ; Restore original shift value into 'a'
0B0A40 E6 07       0051*      and 0x07          ; Mask with 0x07 to get the remainder (bits to shift back up)
0B0A42 47          0052*      ld b,a            ; 'b' now holds the number of bits to shift back up
0B0A43 11 00 00 00 0053*      ld de,0           ; Clear deu for computing the offset address later
0B0A47             0054*  
0B0A47             0055*      ; call dumpRegistersHex ; DEBUG
0B0A47             0056*  
0B0A47             0057*  ; Get back the original sign of the byte shift
0B0A47 F1          0058*      pop af            ; Restore sign flag
0B0A48 F2 56 0A 0B 0059*      jp p,@F           ; If a was positive, we're done
0B0A4C 79          0060*      ld a,c            ; 'a' now holds the number of whole bytes to shift
0B0A4D ED 44       0061*      neg               ; Negate the number of whole bytes to shift
0B0A4F 3D          0062*      dec a             ; Subtract 1 because that's just how this works
0B0A50 4F          0063*      ld c,a            ; 'c' now holds the number of whole bytes to shift
0B0A51 1B          0064*      dec de            ; DE = -1 to make the signed addition below work
0B0A52 3E 08       0065*      ld a,8            ; Subtract bits to shift from 8 because we're in backwards land
0B0A54 90          0066*      sub b
0B0A55 47          0067*      ld b,a            ; b is the number of bits to shift back up
0B0A56             0068*  
0B0A56             0069*      ; call dumpRegistersHex ; DEBUG
0B0A56             0070*  
0B0A56             0071*  @@:
0B0A56             0072*  
0B0A56             0073*  ; Add the byte offset to the base address of umulfxout
0B0A56 59          0074*      ld e,c            ; DEU and D were properly signed above
0B0A57 DD 21 73 0A 0075*      ld ix,umulfxout   ; Load base address of the output buffer
       0B          
0B0A5C DD 19       0076*      add ix,de         ; Add byte-aligned offset (hl = umulfxout + l)
0B0A5E             0077*  
0B0A5E             0078*      ; call dumpRegistersHex ; DEBUG
0B0A5E             0079*  
0B0A5E             0080*  ; Read the byte-aligned result into HL and shift in the required number of bits
0B0A5E DD 27 00    0081*      ld hl,(ix)        ; Byte-aligned result
0B0A61 DD 7E FF    0082*      ld a,(ix-1)       ; One byte below
0B0A64             0083*  
0B0A64             0084*  ; Check whether we're already byte-aligned
0B0A64 AF          0085*      xor a
0B0A65 B0          0086*      or b
0B0A66 28 05       0087*      jr z,@end         ; If no bits to shift, we're done
0B0A68             0088*  
0B0A68             0089*  ; Otherwise shiften zee bitzen
0B0A68             0090*  @loop:
0B0A68             0091*  
0B0A68             0092*      ; call dumpRegistersHex ; DEBUG
0B0A68             0093*  
0B0A68 07          0094*      rlca              ; One bit to carry
0B0A69 ED 6A       0095*      adc hl,hl         ; Shift the carry into the result
0B0A6B             0096*  
0B0A6B 10 FB       0097*      djnz @loop        ; Loop until all bits are shifted up
0B0A6D             0098*  
0B0A6D             0099*  @end:
0B0A6D             0100*  ; return the result
0B0A6D DD E1       0101*      pop ix ; restore
0B0A6F C9          0102*      ret
0B0A70             0103*  
0B0A70 00 00 00    0104*      dl 0 ; padding
0B0A73 00 00 00 00 0105*  umulfxout: blkb 6,0
       00 00       
0B0A79 00 00 00    0106*      dl 0 ; padding
0B0A7C             0107*  
0B0A7C             0108*  ; operation: UHL * UDE --> UHL
0B0A7C             0109*  ; multiply signed 24-bit numbers and return a 48-bit intermediate
0B0A7C             0110*  ; with inputs and outputs having an arbitrary number of fractional bits from 0 to 24
0B0A7C             0111*  ; inputs: hl = 24-bit number, de = 24-bit number,
0B0A7C             0112*  ;         b = hl fractional bits, c = de fractional bits, a = output fractional bits
0B0A7C             0113*  ; outputs: umulfxout = 48-bit intermediate
0B0A7C             0114*  ; destroys: af, hl, bc, de
0B0A7C             0115*  smulfx:
0B0A7C             0116*  ; make everything positive and store sign flags
0B0A7C CD 3B 08 0B 0117*  	call hlu_abs
0B0A80 F5          0118*  	push af
0B0A81 EB          0119*  	ex de,hl
0B0A82 CD 3B 08 0B 0120*  	call hlu_abs
0B0A86 EB          0121*  	ex de,hl
0B0A87 F5          0122*  	push af
0B0A88             0123*  ; do the division
0B0A88 CD 1A 0A 0B 0124*      call umulfx ; hl = product
0B0A8C             0125*  ; adjust sign of result
0B0A8C F1          0126*  	pop af ; sign de
0B0A8D FA 98 0A 0B 0127*  	jp m,@de_neg
0B0A91 F1          0128*  	pop af ; sign hl
0B0A92 F0          0129*  	ret p ; both positive, nothing to do
0B0A93             0130*  @hl_neg:
0B0A93 CD 4B 08 0B 0131*      call neg_hlu ; de pos, hl neg, result is negative
0B0A97 C9          0132*      ret
0B0A98             0133*  @de_neg:
0B0A98 F1          0134*  	pop af
0B0A99 F8          0135*  	ret m ; both negative, nothing to do
0B0A9A CD 4B 08 0B 0136*  	call neg_hlu ; result is negative
0B0A9E C9          0137*  	ret
0B0A9F             0138*  
0B0A9F             0139*  ; multiply a signed 24-bit number by an unsigned 8-bit number giving a signed 24-bit result
0B0A9F             0140*  ; uses EZ80 MLT instruction for speed
0B0A9F             0141*  ; operation: UHL * A --> UHL
0B0A9F             0142*  ; destroys: AF, HL
0B0A9F             0143*  smul24x8:
0B0A9F             0144*  ; make hl positive and store sign flag
0B0A9F CD 3B 08 0B 0145*  	call hlu_abs
0B0AA3 F5          0146*  	push af
0B0AA4             0147*  ; do the division
0B0AA4 CD AF 0A 0B 0148*      call umul24x8 ; hl = product
0B0AA8             0149*  ; adjust sign of result
0B0AA8 F1          0150*  	pop af ; sign de
0B0AA9 F0          0151*  	ret p ; hl was positive, nothing to do
0B0AAA CD 4B 08 0B 0152*  	call neg_hlu ; result is negative
0B0AAE C9          0153*  	ret
0B0AAF             0154*  
0B0AAF             0155*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0AAF             0156*  ; uses EZ80 MLT instruction for speed
0B0AAF             0157*  ; operation: UHL * A --> AUHL
0B0AAF             0158*  ; destroys: AF, HL
0B0AAF             0159*  umul24x8:
0B0AAF D5          0160*  	push de ; preserve de
0B0AB0             0161*  ; low byte
0B0AB0 5D          0162*  	ld e,l
0B0AB1 57          0163*  	ld d,a
0B0AB2 ED 5C       0164*  	mlt de
0B0AB4 6B          0165*  	ld l,e ; product low byte
0B0AB5 08          0166*  	ex af,af' ; save multiplier
0B0AB6 7A          0167*  	ld a,d ; carry
0B0AB7 08          0168*  	ex af,af' ; save carry, restore multiplier
0B0AB8             0169*  ; high byte
0B0AB8 5C          0170*  	ld e,h
0B0AB9 57          0171*  	ld d,a
0B0ABA ED 5C       0172*  	mlt de
0B0ABC 08          0173*  	ex af,af' ; save multiplier, restore carry
0B0ABD 83          0174*  	add a,e ; add carry
0B0ABE 67          0175*  	ld h,a ; product middle byte
0B0ABF 7A          0176*  	ld a,d ; carry
0B0AC0 08          0177*  	ex af,af' ; save carry, restore multiplier
0B0AC1             0178*  ; upper byte
0B0AC1 E5          0179*  	push hl
0B0AC2 33          0180*  	inc sp
0B0AC3 D1          0181*  	pop de ; d = hlu
0B0AC4 3B          0182*  	dec sp
0B0AC5 5F          0183*  	ld e,a
0B0AC6 ED 5C       0184*  	mlt de
0B0AC8 08          0185*  	ex af,af' ; restore carry
0B0AC9 8B          0186*  	adc a,e ; add carry
0B0ACA 22 DB 0A 0B 0187*      ld (@scratch),hl ; 7 cycles
0B0ACE 32 DD 0A 0B 0188*      ld (@scratch+2),a ; 5 cycles
0B0AD2 2A DB 0A 0B 0189*      ld hl,(@scratch) ; 7 cycles
0B0AD6             0190*  ; highest byte
0B0AD6 3E 00       0191*  	ld a,0 ; preserve carry flag
0B0AD8 8A          0192*  	adc a,d ; product highest byte
0B0AD9 D1          0193*  	pop de ; restore de
0B0ADA C9          0194*  	ret
0B0ADB             0195*  @scratch: ds 3
0B0ADE             0196*  
0B0ADE             0197*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0ADE             0198*  ; operation: UHL * UDE --> umulfxout
0B0ADE             0199*  umul24x24:
0B0ADE FD 21 73 0A 0200*  	ld iy,umulfxout ; point to output buffer
       0B          
0B0AE3 C5          0201*  	push bc
0B0AE4 01 00 00 00 0202*  	ld bc,0
0B0AE8 FD 0F 00    0203*  	ld (iy),bc
0B0AEB FD 0F 03    0204*  	ld (iy+3),bc
0B0AEE C1          0205*  	pop bc
0B0AEF             0206*  
0B0AEF             0207*  ; STEP 1: UHL * E
0B0AEF 7B          0208*  	ld a,e
0B0AF0 E5          0209*  	push hl
0B0AF1 CD AF 0A 0B 0210*  	call umul24x8
0B0AF5 FD 2F 00    0211*  	ld (iy+0),hl
0B0AF8 FD 77 03    0212*  	ld (iy+3),a
0B0AFB             0213*  
0B0AFB             0214*  ; STEP 2: UHL * D
0B0AFB E1          0215*  	pop hl
0B0AFC E5          0216*  	push hl
0B0AFD 7A          0217*  	ld a,d
0B0AFE CD AF 0A 0B 0218*  	call umul24x8
0B0B02 CD 0F 0B 0B 0219*  	call @accumulate
0B0B06             0220*  
0B0B06             0221*  ; STEP 3: UHL * DEU
0B0B06 E1          0222*  	pop hl
0B0B07 D5          0223*  	push de
0B0B08 33          0224*  	inc sp
0B0B09 F1          0225*  	pop af
0B0B0A 3B          0226*  	dec sp
0B0B0B CD AF 0A 0B 0227*  	call umul24x8
0B0B0F             0228*  
0B0B0F             0229*  @accumulate:
0B0B0F FD 23       0230*  	inc iy
0B0B11             0231*  ; highest byte of product to carry
0B0B11 FD 77 03    0232*  	ld (iy+3),a
0B0B14             0233*  ; low byte of product
0B0B14 7D          0234*  	ld a,l
0B0B15 FD 86 00    0235*  	add a,(iy+0)
0B0B18 FD 77 00    0236*  	ld (iy+0),a
0B0B1B             0237*  ; high byte of product
0B0B1B 7C          0238*  	ld a,h
0B0B1C FD 8E 01    0239*  	adc a,(iy+1)
0B0B1F FD 77 01    0240*  	ld (iy+1),a
0B0B22             0241*  ; uppper byte of product
0B0B22 E5          0242*  	push hl
0B0B23 33          0243*  	inc sp
0B0B24 E1          0244*  	pop hl
0B0B25 3B          0245*  	dec sp
0B0B26 7C          0246*  	ld a,h
0B0B27 FD 8E 02    0247*  	adc a,(iy+2)
0B0B2A FD 77 02    0248*  	ld (iy+2),a
0B0B2D             0249*  ; carry
0B0B2D 3E 00       0250*  	ld a,0 ; preserve flags
0B0B2F FD 8E 03    0251*  	adc a,(iy+3)
0B0B32 FD 77 03    0252*  	ld (iy+3),a
0B0B35 C9          0253*  	ret
0B0B36             0254*  
0B0B36             0255*  ; umul168:	UH.L = UH.L*UD.E (unsigned)
0B0B36             0256*  umul168:
0B0B36 CD DE 0A 0B 0257*  	call umul24x24
0B0B3A FD 27 FF    0258*  	ld hl,(iy-1)
0B0B3D C9          0259*  	ret
0B0B3E             0260*  
0B0B3E             0261*  ; smul168:	UH.L * UD.E --> UH.L (signed)
0B0B3E             0262*  smul168:
0B0B3E             0263*  ; make everything positive and store sign flags
0B0B3E CD 3B 08 0B 0264*  	call hlu_abs
0B0B42 F5          0265*  	push af
0B0B43 EB          0266*  	ex de,hl
0B0B44 CD 3B 08 0B 0267*  	call hlu_abs
0B0B48 EB          0268*  	ex de,hl
0B0B49 F5          0269*  	push af
0B0B4A             0270*  ; do the division
0B0B4A CD 36 0B 0B 0271*      call umul168 ; hl = product
0B0B4E             0272*  ; adjust sign of result
0B0B4E F1          0273*  	pop af ; sign de
0B0B4F FA 5A 0B 0B 0274*  	jp m,@de_neg
0B0B53 F1          0275*  	pop af ; sign hl
0B0B54 F0          0276*  	ret p ; both positive, nothing to do
0B0B55             0277*  @hl_neg:
0B0B55 CD 4B 08 0B 0278*      call neg_hlu ; de pos, hl neg, result is negative
0B0B59 C9          0279*      ret
0B0B5A             0280*  @de_neg:
0B0B5A F1          0281*  	pop af
0B0B5B F8          0282*  	ret m ; both negative, nothing to do
0B0B5C CD 4B 08 0B 0283*  	call neg_hlu ; result is negative
0B0B60 C9          0284*  	ret
0B0B61             0285*  
0B0B61             0286*  ; UH.L / UD.E --> UD.E rem UHL (unsigned)
0B0B61             0287*  ; perform unsigned division of 16.8 fixed place values
0B0B61             0288*  ; with an unsigned 16.8 fixed place result and 24-bit remainder
0B0B61             0289*  udiv168:
0B0B61             0290*  ; back up divisor
0B0B61 ED 53 98 0B 0291*  	ld (@ude),de
       0B          
0B0B66             0292*  ; get the 16-bit integer part of the quotient
0B0B66 CD 2A 09 0B 0293*      call udiv24 ; de = quotient, hl = remainder
0B0B6A             0294*  ; load quotient to upper three bytes of output
0B0B6A ED 53 9F 0B 0295*      ld (div168_out+1),de
       0B          
0B0B6F             0296*  @div256:
0B0B6F             0297*  ; multiply remainder by 256
0B0B6F             0298*  	hlu_mul256
0B0B6F 29          0001*M         add hl,hl ; * 2
0B0B70 29          0002*M         add hl,hl ; * 4
0B0B71 29          0003*M         add hl,hl ; * 8
0B0B72 29          0004*M         add hl,hl ; * 16
0B0B73 29          0005*M         add hl,hl ; * 32
0B0B74 29          0006*M         add hl,hl ; * 64
0B0B75 29          0007*M         add hl,hl ; * 128
0B0B76 29          0008*M         add hl,hl ; * 256
0B0B77             0299*  ; skip fractional computation if remainder is zero
0B0B77             0300*      sign_hlu
0B0B77 19          0001*M         add hl,de
0B0B78 B7          0002*M         or a
0B0B79 ED 52       0003*M         sbc hl,de
0B0B7B 20 03       0301*      jr nz,@div_frac
0B0B7D AF          0302*      xor a
0B0B7E 18 0A       0303*      jr @write_frac
0B0B80             0304*  ; now divide the shifted remainder by the divisor
0B0B80             0305*  @div_frac:
0B0B80 ED 5B 98 0B 0306*  	ld de,(@ude) ; get back divisor
       0B          
0B0B85 CD 2A 09 0B 0307*      call udiv24 ; de = quotient, hl = remainder
0B0B89             0308*  ; load low byte of quotient to low byte of output
0B0B89 7B          0309*      ld a,e
0B0B8A             0310*  @write_frac:
0B0B8A 32 9E 0B 0B 0311*      ld (div168_out),a
0B0B8E             0312*  ; load de with return value
0B0B8E ED 5B 9E 0B 0313*      ld de,(div168_out)
       0B          
0B0B93             0314*  ; load a with any overflow
0B0B93 3A A1 0B 0B 0315*      ld a,(div168_out+3)
0B0B97 C9          0316*      ret ; ud.e is the 16.8 result
0B0B98             0317*  @ude: ds 6
0B0B9E             0318*  div168_out: ds 4 ; the extra byte is for overflow
0B0BA2             0319*  
0B0BA2             0320*  ; UH.L / UD.E --> UD.E (signed) rem UHL (unsigned)
0B0BA2             0321*  ; perform signed division of 16.8 fixed place values
0B0BA2             0322*  ; with a signed 16.8 fixed place result and unsigned 24-bit remainder
0B0BA2             0323*  sdiv168:
0B0BA2             0324*  ; make everything positive and store sign flags
0B0BA2 CD 3B 08 0B 0325*  	call hlu_abs
0B0BA6 F5          0326*  	push af
0B0BA7 EB          0327*  	ex de,hl
0B0BA8 CD 3B 08 0B 0328*  	call hlu_abs
0B0BAC EB          0329*  	ex de,hl
0B0BAD F5          0330*  	push af
0B0BAE             0331*  ; do the division
0B0BAE CD 61 0B 0B 0332*      call udiv168 ; de = quotient, hl = remainder
0B0BB2             0333*  ; adjust sign of result
0B0BB2 F1          0334*  	pop af ; sign de
0B0BB3 FA C0 0B 0B 0335*  	jp m,@de_neg
0B0BB7 F1          0336*  	pop af ; sign hl
0B0BB8 F0          0337*  	ret p ; both positive, nothing to do
0B0BB9             0338*  @hl_neg:
0B0BB9 EB          0339*      ex de,hl ; hl = quotient, de = remainder
0B0BBA CD 4B 08 0B 0340*      call neg_hlu ; de pos, hl neg, result is negative
0B0BBE EB          0341*      ex de,hl ; de = negated quotient, hl = remainder
0B0BBF C9          0342*      ret
0B0BC0             0343*  @de_neg:
0B0BC0 F1          0344*  	pop af
0B0BC1 F8          0345*  	ret m ; both negative, nothing to do
0B0BC2 EB          0346*      ex de,hl ; hl = quotient, de = remainder
0B0BC3 CD 4B 08 0B 0347*  	call neg_hlu ; result is negative
0B0BC7 EB          0348*      ex de,hl ; de = negated quotient, hl = remainder
0B0BC8 C9          0349*  	ret
0B0BC9             0350*  ; ========== FROM maths24.inc ==========
0B0BC9             0351*  
0B0BC9             0352*  ; Expects  ADL mode
0B0BC9             0353*  ; Inputs:  UH.L
0B0BC9             0354*  ; Outputs: UH.L is the 16.8 square root
0B0BC9             0355*  ;          UD.E is the difference inputHL-DE^2
0B0BC9             0356*  ;          c flag reset
0B0BC9             0357*  sqrt168:
0B0BC9 CD D3 0B 0B 0358*      call sqrt24
0B0BCD EB          0359*      ex de,hl
0B0BCE 29          0360*      add hl,hl
0B0BCF 29          0361*      add hl,hl
0B0BD0 29          0362*      add hl,hl
0B0BD1 29          0363*      add hl,hl
0B0BD2 C9          0364*      ret
0B0BD3             0365*  
0B0BD3             0366*  ; Expects  ADL mode
0B0BD3             0367*  ; Inputs:  HL
0B0BD3             0368*  ; Outputs: DE is the integer square root
0B0BD3             0369*  ;          HL is the difference inputHL-DE^2
0B0BD3             0370*  ;          c flag reset
0B0BD3             0371*  sqrt24:
0B0BD3 AF          0372*      xor a
0B0BD4 45          0373*      ld b,l
0B0BD5 C5          0374*      push bc
0B0BD6 47          0375*      ld b,a
0B0BD7 57          0376*      ld d,a
0B0BD8 4F          0377*      ld c,a
0B0BD9 6F          0378*      ld l,a
0B0BDA 5F          0379*      ld e,a
0B0BDB             0380*  
0B0BDB             0381*      ;Iteration 1
0B0BDB 29          0382*      add hl,hl
0B0BDC CB 11       0383*      rl c
0B0BDE 29          0384*      add hl,hl
0B0BDF CB 11       0385*      rl c
0B0BE1 91          0386*      sub c
0B0BE2 30 04       0387*      jr nc,$+6
0B0BE4 1C          0388*      inc e
0B0BE5 1C          0389*      inc e
0B0BE6 2F          0390*      cpl
0B0BE7 4F          0391*      ld c,a
0B0BE8             0392*  
0B0BE8             0393*      ;Iteration 2
0B0BE8 29          0394*      add hl,hl
0B0BE9 CB 11       0395*      rl c
0B0BEB 29          0396*      add hl,hl
0B0BEC CB 11       0397*      rl c
0B0BEE CB 13       0398*      rl e
0B0BF0 7B          0399*      ld a,e
0B0BF1 91          0400*      sub c
0B0BF2 30 04       0401*      jr nc,$+6
0B0BF4 1C          0402*      inc e
0B0BF5 1C          0403*      inc e
0B0BF6 2F          0404*      cpl
0B0BF7 4F          0405*      ld c,a
0B0BF8             0406*  
0B0BF8             0407*      ;Iteration 3
0B0BF8 29          0408*      add hl,hl
0B0BF9 CB 11       0409*      rl c
0B0BFB 29          0410*      add hl,hl
0B0BFC CB 11       0411*      rl c
0B0BFE CB 13       0412*      rl e
0B0C00 7B          0413*      ld a,e
0B0C01 91          0414*      sub c
0B0C02 30 04       0415*      jr nc,$+6
0B0C04 1C          0416*      inc e
0B0C05 1C          0417*      inc e
0B0C06 2F          0418*      cpl
0B0C07 4F          0419*      ld c,a
0B0C08             0420*  
0B0C08             0421*      ;Iteration 4
0B0C08 29          0422*      add hl,hl
0B0C09 CB 11       0423*      rl c
0B0C0B 29          0424*      add hl,hl
0B0C0C CB 11       0425*      rl c
0B0C0E CB 13       0426*      rl e
0B0C10 7B          0427*      ld a,e
0B0C11 91          0428*      sub c
0B0C12 30 04       0429*      jr nc,$+6
0B0C14 1C          0430*      inc e
0B0C15 1C          0431*      inc e
0B0C16 2F          0432*      cpl
0B0C17 4F          0433*      ld c,a
0B0C18             0434*  
0B0C18             0435*      ;Iteration 5
0B0C18 29          0436*      add hl,hl
0B0C19 CB 11       0437*      rl c
0B0C1B 29          0438*      add hl,hl
0B0C1C CB 11       0439*      rl c
0B0C1E CB 13       0440*      rl e
0B0C20 7B          0441*      ld a,e
0B0C21 91          0442*      sub c
0B0C22 30 04       0443*      jr nc,$+6
0B0C24 1C          0444*      inc e
0B0C25 1C          0445*      inc e
0B0C26 2F          0446*      cpl
0B0C27 4F          0447*      ld c,a
0B0C28             0448*  
0B0C28             0449*      ;Iteration 6
0B0C28 29          0450*      add hl,hl
0B0C29 CB 11       0451*      rl c
0B0C2B 29          0452*      add hl,hl
0B0C2C CB 11       0453*      rl c
0B0C2E CB 13       0454*      rl e
0B0C30 7B          0455*      ld a,e
0B0C31 91          0456*      sub c
0B0C32 30 04       0457*      jr nc,$+6
0B0C34 1C          0458*      inc e
0B0C35 1C          0459*      inc e
0B0C36 2F          0460*      cpl
0B0C37 4F          0461*      ld c,a
0B0C38             0462*  
0B0C38             0463*      ;Iteration 7
0B0C38 29          0464*      add hl,hl
0B0C39 CB 11       0465*      rl c
0B0C3B 29          0466*      add hl,hl
0B0C3C CB 11       0467*      rl c
0B0C3E CB 10       0468*      rl b
0B0C40 EB          0469*      ex de,hl
0B0C41 29          0470*      add hl,hl
0B0C42 E5          0471*      push hl
0B0C43 ED 42       0472*      sbc hl,bc
0B0C45 30 06       0473*      jr nc,$+8
0B0C47 7C          0474*      ld a,h
0B0C48 2F          0475*      cpl
0B0C49 47          0476*      ld b,a
0B0C4A 7D          0477*      ld a,l
0B0C4B 2F          0478*      cpl
0B0C4C 4F          0479*      ld c,a
0B0C4D E1          0480*      pop hl
0B0C4E 30 02       0481*      jr nc,$+4
0B0C50 23          0482*      inc hl
0B0C51 23          0483*      inc hl
0B0C52 EB          0484*      ex de,hl
0B0C53             0485*  
0B0C53             0486*      ;Iteration 8
0B0C53 29          0487*      add hl,hl
0B0C54 69          0488*      ld l,c
0B0C55 60          0489*      ld h,b
0B0C56 ED 6A       0490*      adc hl,hl
0B0C58 ED 6A       0491*      adc hl,hl
0B0C5A EB          0492*      ex de,hl
0B0C5B 29          0493*      add hl,hl
0B0C5C ED 52       0494*      sbc hl,de
0B0C5E 19          0495*      add hl,de
0B0C5F EB          0496*      ex de,hl
0B0C60 30 04       0497*      jr nc,$+6
0B0C62 ED 52       0498*      sbc hl,de
0B0C64 13          0499*      inc de
0B0C65 13          0500*      inc de
0B0C66             0501*  
0B0C66             0502*      ;Iteration 9
0B0C66 F1          0503*      pop af
0B0C67 17          0504*      rla
0B0C68 ED 6A       0505*      adc hl,hl
0B0C6A 17          0506*      rla
0B0C6B ED 6A       0507*      adc hl,hl
0B0C6D EB          0508*      ex de,hl
0B0C6E 29          0509*      add hl,hl
0B0C6F ED 52       0510*      sbc hl,de
0B0C71 19          0511*      add hl,de
0B0C72 EB          0512*      ex de,hl
0B0C73 30 04       0513*      jr nc,$+6
0B0C75 ED 52       0514*      sbc hl,de
0B0C77 13          0515*      inc de
0B0C78 13          0516*      inc de
0B0C79             0517*  
0B0C79             0518*      ;Iteration 10
0B0C79 17          0519*      rla
0B0C7A ED 6A       0520*      adc hl,hl
0B0C7C 17          0521*      rla
0B0C7D ED 6A       0522*      adc hl,hl
0B0C7F EB          0523*      ex de,hl
0B0C80 29          0524*      add hl,hl
0B0C81 ED 52       0525*      sbc hl,de
0B0C83 19          0526*      add hl,de
0B0C84 EB          0527*      ex de,hl
0B0C85 30 04       0528*      jr nc,$+6
0B0C87 ED 52       0529*      sbc hl,de
0B0C89 13          0530*      inc de
0B0C8A 13          0531*      inc de
0B0C8B             0532*  
0B0C8B             0533*      ;Iteration 11
0B0C8B 17          0534*      rla
0B0C8C ED 6A       0535*      adc hl,hl
0B0C8E 17          0536*      rla
0B0C8F ED 6A       0537*      adc hl,hl
0B0C91 EB          0538*      ex de,hl
0B0C92 29          0539*      add hl,hl
0B0C93 ED 52       0540*      sbc hl,de
0B0C95 19          0541*      add hl,de
0B0C96 EB          0542*      ex de,hl
0B0C97 30 04       0543*      jr nc,$+6
0B0C99 ED 52       0544*      sbc hl,de
0B0C9B 13          0545*      inc de
0B0C9C 13          0546*      inc de
0B0C9D             0547*  
0B0C9D             0548*      ;Iteration 11
0B0C9D 17          0549*      rla
0B0C9E ED 6A       0550*      adc hl,hl
0B0CA0 17          0551*      rla
0B0CA1 ED 6A       0552*      adc hl,hl
0B0CA3 EB          0553*      ex de,hl
0B0CA4 29          0554*      add hl,hl
0B0CA5 ED 52       0555*      sbc hl,de
0B0CA7 19          0556*      add hl,de
0B0CA8 EB          0557*      ex de,hl
0B0CA9 30 04       0558*      jr nc,$+6
0B0CAB ED 52       0559*      sbc hl,de
0B0CAD 13          0560*      inc de
0B0CAE 13          0561*      inc de
0B0CAF             0562*  
0B0CAF CB 1A       0563*      rr d
0B0CB1 CB 1B       0564*      rr e
0B0CB3 C9          0565*      ret
0B0CB4             0023       include "trig24.inc"
0B0CB4             0001*  
0B0CB4             0002*  ; convert signed angles from a 360 to 256 degree circle
0B0CB4             0003*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B0CB4             0004*  ; outputs: uh.l is the angle256 in 16.8 fixed format
0B0CB4             0005*  ; destroys: TODO
0B0CB4             0006*  deg_360_to_256:
0B0CB4 D5          0007*  	push de ; preserve de
0B0CB5             0008*  ; make angle positive and store sign flag
0B0CB5 CD 3B 08 0B 0009*  	call hlu_abs
0B0CB9 F5          0010*  	push af
0B0CBA             0011*  ; multiply by 256 first to keep precision
0B0CBA             0012*  	hlu_mul256 ; uh.l = uh.l * 256
0B0CBA 29          0001*M         add hl,hl ; * 2
0B0CBB 29          0002*M         add hl,hl ; * 4
0B0CBC 29          0003*M         add hl,hl ; * 8
0B0CBD 29          0004*M         add hl,hl ; * 16
0B0CBE 29          0005*M         add hl,hl ; * 32
0B0CBF 29          0006*M         add hl,hl ; * 64
0B0CC0 29          0007*M         add hl,hl ; * 128
0B0CC1 29          0008*M         add hl,hl ; * 256
0B0CC2             0013*  ; divide uh.l by 360
0B0CC2 11 68 01 00 0014*  	ld de,360
0B0CC6 CD 2A 09 0B 0015*  	call udiv24 ; ud.e = degrees / 360
0B0CCA EB          0016*  	ex de,hl    ; uh.l = degrees / 360
0B0CCB             0017*  ; restore sign flag and adjust output accordingly
0B0CCB F1          0018*  	pop af
0B0CCC F2 D4 0C 0B 0019*  	jp p,@pos ; positive number
0B0CD0 CD 4B 08 0B 0020*  	call neg_hlu
0B0CD4             0021*  @pos:
0B0CD4             0022*  ; restore de and return uh.l as the result
0B0CD4 D1          0023*  	pop de
0B0CD5 C9          0024*  	ret
0B0CD6             0025*  
0B0CD6             0026*  ; fixed 16.8 routine
0B0CD6             0027*  ; cos(uh.l) --> uh.l
0B0CD6             0028*  ; destroys: de
0B0CD6             0029*  cos168:
0B0CD6             0030*  ; for cos we simply increment the angle by 90 degrees
0B0CD6             0031*  ; or 0x004000 in 16.8 degrees256
0B0CD6             0032*  ; which makes it a sin problem
0B0CD6 11 00 40 00 0033*      ld de,0x004000
0B0CDA 19          0034*      add hl,de ; modulo 256 happens below
0B0CDB             0035*  ; fall through to sin168
0B0CDB             0036*  
0B0CDB             0037*  ; ---------------------
0B0CDB             0038*  ; fixed 16.8 routine
0B0CDB             0039*  ; sin(uh.l) --> uh.l
0B0CDB             0040*  ; destroys: af
0B0CDB             0041*  sin168:
0B0CDB D5          0042*  	push de
0B0CDC DD E5       0043*  	push ix
0B0CDE             0044*  ; handle negative angles appropriately
0B0CDE CD 3B 08 0B 0045*  	call hlu_abs
0B0CE2 F2 EB 0C 0B 0046*  	jp p,@f
0B0CE6 11 00 00 FF 0047*  	ld de,-256*256
0B0CEA 19          0048*  	add hl,de
0B0CEB             0049*  @@:
0B0CEB             0050*  ; get the lookup value for the integer portion of the angle
0B0CEB 7D          0051*  	ld a,l ; save fractional part of the angle
0B0CEC 2E 06       0052*  	ld l,6 ; multiply by 6 to get our lookup index
0B0CEE EB          0053*  	ex de,hl ; can't add ix,hl
0B0CEF ED 5C       0054*  	mlt de ; gosh that is handy
0B0CF1 DD 21 5D 11 0055*      ld ix,sin_lut_816 ; grab the lut address
       0B          
0B0CF6 DD 19       0056*      add ix,de ; bump hl by the index
0B0CF8 DD 27 00    0057*      ld hl,(ix) ; hl = sin(int(angle))
0B0CFB B7          0058*  	or a  ; check fractional part of the angle for zero
0B0CFC CA 0D 0D 0B 0059*  	jp z,@f ; no fractional part so skip interpolation
0B0D00             0060*  ; interpolate the fractional part of the angle
0B0D00 DD 17 03    0061*  	ld de,(ix+3)
0B0D03 EB          0062*  	ex de,hl
0B0D04 CD 9F 0A 0B 0063*  	call smul24x8
0B0D08 CD 87 08 0B 0064*  	call hlu_sdiv256
0B0D0C 19          0065*  	add hl,de ; hl = sin(int(angle)) + interpolation factor * (sin(int(angle+1)) - sin(int(angle))
0B0D0D             0066*  @@:
0B0D0D CD 87 08 0B 0067*  	call hlu_sdiv256
0B0D11 DD E1       0068*  	pop ix
0B0D13 D1          0069*  	pop de
0B0D14 C9          0070*      ret ; and out
0B0D15             0071*  
0B0D15             0072*  ; 16.8 fixed inputs / outputs
0B0D15             0073*  ; takes: uh.l as angle in degrees 256
0B0D15             0074*  ;        ud.e as radius
0B0D15             0075*  ; returns ub.c as dx, ud.e as dy, uh.l as radius
0B0D15             0076*  ;        displacements from origin (0,0)
0B0D15             0077*  ; destroys: everything except indexes
0B0D15             0078*  polar_to_cartesian:
0B0D15             0079*  	; call printNewLine ; DEBUG
0B0D15             0080*  ; back up input parameters
0B0D15 22 40 0D 0B 0081*      ld (@angle), hl
0B0D19 ED 53 43 0D 0082*      ld (@radius), de
       0B          
0B0D1E             0083*  ; compute dx = cos(uh.l) * ud.e
0B0D1E CD D6 0C 0B 0084*      call cos168 ; uh.l = cos(uh.l)
0B0D22             0085*  	; call print_hex_hl ; DEBUG
0B0D22             0086*  	; call print_s168_hl ; DEBUG
0B0D22 ED 5B 43 0D 0087*  	ld de,(@radius)
       0B          
0B0D27 CD 3E 0B 0B 0088*  	call smul168 ; uh.l = dx
0B0D2B E5          0089*      push hl
0B0D2C             0090*  ; compute dy = sin(uh.l) * ud.e
0B0D2C 2A 40 0D 0B 0091*      ld hl,(@angle)
0B0D30 CD DB 0C 0B 0092*      call sin168 ; uh.l = sin(uh.l)
0B0D34             0093*  	; call print_hex_hl ; DEBUG
0B0D34             0094*  	; call print_s168_hl ; DEBUG
0B0D34 ED 5B 43 0D 0095*      ld de,(@radius)
       0B          
0B0D39 CD 3E 0B 0B 0096*      call smul168    ; uh.l = dy
0B0D3D EB          0097*      ex de,hl       ; de = dy for output
0B0D3E C1          0098*      pop bc          ; bc = dx for output
0B0D3F             0099*  ; and out
0B0D3F C9          0100*      ret
0B0D40             0101*  @angle: ds 3
0B0D43             0102*  @radius: ds 3
0B0D46             0103*  
0B0D46             0104*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0D46             0105*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0D46             0106*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0D46             0107*  ;         also populates scratch locations dx168 and dy168
0B0D46             0108*  ; destroys: a,hl,bc,de
0B0D46             0109*  dxy168:
0B0D46             0110*  ; compute dx = x1-x0
0B0D46 AF          0111*      xor a ; clear carry
0B0D47 DD E5       0112*      push ix ; move ix to hl via the stack
0B0D49 E1          0113*      pop hl ; hl = x1
0B0D4A ED 42       0114*      sbc hl,bc ; hl = dx
0B0D4C 22 A1 0D 0B 0115*      ld (dx168),hl ; dx to scratch
0B0D50             0116*  ; compute dy = y1-y0
0B0D50 AF          0117*      xor a ; clear carry
0B0D51 FD E5       0118*      push iy ; move iy to hl via the stack
0B0D53 E1          0119*      pop hl ; hl = y1
0B0D54 ED 52       0120*      sbc hl,de ; hl = dy
0B0D56 22 A7 0D 0B 0121*      ld (dy168),hl ; dy to scratch
0B0D5A             0122*  ; populate output registers and return
0B0D5A EB          0123*      ex de,hl        ; ud.e = dy
0B0D5B ED 4B A1 0D 0124*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B0D60 C9          0125*      ret
0B0D61             0126*  
0B0D61             0127*  ; compute the euclidian distance between two cartesian coordinates
0B0D61             0128*  ; using the formula d = sqrt(dx^2+dy^2
0B0D61             0129*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B0D61             0130*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B0D61             0131*  ; output; uh.l is the 16.8 fixed format distance
0B0D61             0132*  ;       dx168/y are the 16.8 fixed format dx and dy
0B0D61             0133*  ; destroys: a,hl,bc,de
0B0D61             0134*  distance168:
0B0D61             0135*  ; compute dx = x1-x0
0B0D61 AF          0136*      xor a ; clear carry
0B0D62 DD E5       0137*      push ix ; move ix to hl via the stack
0B0D64 E1          0138*      pop hl ; hl = x1
0B0D65 ED 42       0139*      sbc hl,bc ; hl = dx
0B0D67 22 A1 0D 0B 0140*      ld (dx168),hl ; dx to scratch
0B0D6B             0141*  ; ; test dx for overflow
0B0D6B             0142*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0D6B             0143*  ; 	ex de,hl
0B0D6B             0144*  ; 	sbc hl,de ; test for overflow
0B0D6B             0145*  ; 	push af ; carry indicates overflow
0B0D6B             0146*  ; compute dy = y1-y0
0B0D6B AF          0147*      xor a ; clear carry
0B0D6C FD E5       0148*      push iy ; move iy to hl via the stack
0B0D6E E1          0149*      pop hl ; hl = y1
0B0D6F ED 52       0150*      sbc hl,de ; hl = dy
0B0D71 22 A7 0D 0B 0151*      ld (dy168),hl ; dy to scratch
0B0D75             0152*  ; ; test dy for overflow
0B0D75             0153*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B0D75             0154*  ; 	ex de,hl
0B0D75             0155*  ; 	sbc hl,de ; test for overflow
0B0D75             0156*  ; 	push af ; carry indicates overflow
0B0D75             0157*  ; compute dy^2
0B0D75 2A A7 0D 0B 0158*  	ld hl,(dy168)
0B0D79 CD 3B 08 0B 0159*      call hlu_abs  ; make dy positive so we can use unsigned multiply
0B0D7D             0160*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0D7D E5          0161*      push hl ; load hl/2 to bc via the stack
0B0D7E C1          0162*      pop bc ; bc = dy/2
0B0D7F EB          0163*      ex de,hl ; de = dy/2
0B0D80 CD 36 0B 0B 0164*      call umul168 ; uh.l = dy^2/2
0B0D84 E5          0165*      push hl ; dy^2/2 to the stack
0B0D85             0166*  ; compute dx^2
0B0D85 2A A1 0D 0B 0167*      ld hl,(dx168) ; get back dx
0B0D89 CD 3B 08 0B 0168*      call hlu_abs  ; make dx positive so we can use unsigned multiply
0B0D8D             0169*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B0D8D E5          0170*      push hl ; load hl/2 to bc via the stack
0B0D8E C1          0171*      pop bc ; bc = dx/2
0B0D8F EB          0172*      ex de,hl ; de = dx/2
0B0D90 CD 36 0B 0B 0173*      call umul168 ; uh.l = dx^2/2
0B0D94             0174*  ; commpute dy^2+dx^2
0B0D94 D1          0175*      pop de ; get back dx^2/2
0B0D95 19          0176*      add hl,de ; hl = dx^2/2+dy^2/2
0B0D96             0177*  ; compute sqrt(dx^2/2+dy^2/2)
0B0D96 CD C9 0B 0B 0178*      call sqrt168 ; uh.l = distance/2
0B0D9A             0179*      ; add hl,hl ; hl = distance
0B0D9A             0180*  ; ; check for overflow
0B0D9A             0181*  ; 	pop af ; get back the overflow flags
0B0D9A             0182*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0D9A             0183*  ; 	ld b,a ; save the overflow flag
0B0D9A             0184*  ; 	pop af ; get back the overflow flags
0B0D9A             0185*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B0D9A             0186*  ; 	add a,b ; if a != 0 then we had overflow
0B0D9A             0187*  ;     ret z ; no overflow we're done
0B0D9A             0188*  ; @overflow:
0B0D9A             0189*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B0D9A C9          0190*  	ret
0B0D9B             0191*  @scratch: ds 6
0B0DA1             0192*  dx168: ds 6
0B0DA7             0193*  dy168: ds 6
0B0DAD             0194*  
0B0DAD             0195*  ; atan2(ub.c,ud.e) --> uh.l
0B0DAD             0196*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0DAD             0197*  ;   whether inputs are integers or fractional doesn't matter
0B0DAD             0198*  ;   so long as the sign bit of the upper byte is correct
0B0DAD             0199*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B0DAD             0200*  ; angles are COMPASS HEADINGS based on
0B0DAD             0201*  ; screen coordinate conventions,where the y axis is flipped
0B0DAD             0202*  ; #E0 315      0       45 #20
0B0DAD             0203*  ;        -x,-y | +x,-y
0B0DAD             0204*  ; #C0 270------+------ 90 #40
0B0DAD             0205*  ;        -x,+y | +x,+y
0B0DAD             0206*  ; #A0 225   180 #80   135 #60
0B0DAD             0207*  atan2_168game:
0B0DAD             0208*  ; get signs and make everything positive
0B0DAD             0209*  ; get abs(x) and store its original sign
0B0DAD C5          0210*      push bc
0B0DAE E1          0211*      pop hl
0B0DAF CD 3B 08 0B 0212*      call hlu_abs ; if x was negative this also sets the sign flag
0B0DB3 E5          0213*      push hl ; store abs(x)
0B0DB4 C1          0214*      pop bc ; bc = abs(x)
0B0DB5 F5          0215*      push af ; store sign of x
0B0DB6             0216*  ; get abs(y) and store its original sign
0B0DB6 EB          0217*      ex de,hl ; hl = y
0B0DB7 CD 3B 08 0B 0218*      call hlu_abs ; if y was negative this also sets the sign flag
0B0DBB EB          0219*      ex de,hl ; de = abs(y)
0B0DBC F5          0220*      push af ; store sign of y
0B0DBD             0221*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B0DBD             0222*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B0DBD AF          0223*      xor a ; clear the carry flag
0B0DBE D5          0224*      push de
0B0DBF E1          0225*      pop hl
0B0DC0 ED 42       0226*      sbc hl,bc
0B0DC2 F5          0227*      push af ; save sign of de - bc
0B0DC3 F2 CC 0D 0B 0228*      jp p,@1 ; bc <= de, so we skip ahead
0B0DC7             0229*  ; otherwise we swap bc and de
0B0DC7 C5          0230*      push bc
0B0DC8 E1          0231*      pop hl
0B0DC9 EB          0232*      ex de,hl
0B0DCA E5          0233*      push hl
0B0DCB C1          0234*      pop bc
0B0DCC             0235*  @1:
0B0DCC             0236*  ; now we're ready to snag our preliminary result
0B0DCC CD 3A 0E 0B 0237*      call atan_168game ; uh.l comes back with prelim result
0B0DD0             0238*  ; now we adjust uh.l based on sign of de - bc
0B0DD0 F1          0239*      pop af
0B0DD1 F2 DD 0D 0B 0240*      jp p,@2 ; bc <= de,so we skip ahead
0B0DD5 EB          0241*      ex de,hl
0B0DD6 21 00 40 00 0242*      ld hl,0x004000 ; 90 degrees
0B0DDA AF          0243*      xor a ; clear the carry flag
0B0DDB ED 52       0244*      sbc hl,de ; subtract result from 90 degrees
0B0DDD             0245*      ; ld de,0 ; prep to clear hlu
0B0DDD             0246*      ; ld d,h
0B0DDD             0247*      ; ld e,l
0B0DDD             0248*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B0DDD             0249*      ; fall through
0B0DDD             0250*  @2:
0B0DDD             0251*  ; now the fun part of adjusting the result
0B0DDD             0252*  ; based on which quadrant (x,y) is in
0B0DDD             0253*  ; #E0 315      0       45 #20
0B0DDD             0254*  ;        -x,-y | +x,-y
0B0DDD             0255*  ; #C0 270------+------ 90 #40
0B0DDD             0256*  ;        -x,+y | +x,+y
0B0DDD             0257*  ; #A0 225   180 #80   135 #60
0B0DDD F1          0258*      pop af ; sign of y
0B0DDE CA 1B 0E 0B 0259*      jp z,@y_zero
0B0DE2 F2 FB 0D 0B 0260*      jp p,@y_pos
0B0DE6             0261*  ; y neg,check x
0B0DE6 F1          0262*      pop af ; sign of x
0B0DE7 CA F5 0D 0B 0263*      jp z,@y_neg_x_zero
0B0DEB F2 FA 0D 0B 0264*      jp p,@y_neg_x_pos
0B0DEF             0265*  ; y neg,x neg
0B0DEF             0266*  ; angle is 270-360
0B0DEF             0267*  ; negating the intermediate does the trick
0B0DEF CD 4B 08 0B 0268*      call neg_hlu
0B0DF3 18 31       0269*      jr @zero_hlu
0B0DF5             0270*  
0B0DF5             0271*  @y_neg_x_zero:
0B0DF5             0272*  ; y neg,x zero
0B0DF5             0273*  ; angle is 0
0B0DF5 21 00 00 00 0274*      ld hl,0
0B0DF9 C9          0275*      ret
0B0DFA             0276*  @y_neg_x_pos:
0B0DFA             0277*  ; y neg,x pos
0B0DFA             0278*  ; angle is 0 to 90
0B0DFA             0279*  ; so we're good
0B0DFA C9          0280*      ret
0B0DFB             0281*  
0B0DFB             0282*  @y_pos:
0B0DFB F1          0283*      pop af ; sign of x
0B0DFC CA 0B 0E 0B 0284*      jp z,@y_pos_x_zero
0B0E00 F2 10 0E 0B 0285*      jp p,@y_pos_x_pos
0B0E04             0286*  ; y pos,x neg
0B0E04             0287*  ; angle is 180-270
0B0E04             0288*  ; so we add 180 to intermediate
0B0E04 11 00 80 00 0289*      ld de,0x008000
0B0E08 19          0290*      add hl,de
0B0E09 18 1B       0291*      jr @zero_hlu
0B0E0B             0292*  @y_pos_x_zero:
0B0E0B             0293*  ; y pos,x zero
0B0E0B             0294*  ; angle is 180
0B0E0B 21 00 80 00 0295*      ld hl,0x008000
0B0E0F C9          0296*      ret
0B0E10             0297*  @y_pos_x_pos:
0B0E10             0298*  ; y pos,x pos
0B0E10             0299*  ; angle is 90-180
0B0E10             0300*  ; neg the intermediate and add 180 degrees
0B0E10 CD 4B 08 0B 0301*      call neg_hlu
0B0E14 11 00 80 00 0302*      ld de,0x008000
0B0E18 19          0303*      add hl,de
0B0E19 18 0B       0304*      jr @zero_hlu
0B0E1B             0305*  
0B0E1B             0306*  @y_zero:
0B0E1B F1          0307*      pop af ; sign of x
0B0E1C FA 21 0E 0B 0308*      jp m,@y_zero_x_neg
0B0E20             0309*  ; y zero,x pos
0B0E20             0310*  ; angle is 90,nothing to do
0B0E20 C9          0311*      ret
0B0E21             0312*  @y_zero_x_neg:
0B0E21             0313*  ; y zero ,x neg
0B0E21             0314*  ; angle is 270
0B0E21 21 00 C0 00 0315*      ld hl,0x00C000
0B0E25 C9          0316*      ret
0B0E26             0317*  @zero_hlu:
0B0E26 AF          0318*      xor a
0B0E27 22 34 0E 0B 0319*      ld (@scratch),hl
0B0E2B 32 36 0E 0B 0320*      ld (@scratch+2),a
0B0E2F 2A 34 0E 0B 0321*      ld hl,(@scratch)
0B0E33 C9          0322*      ret
0B0E34             0323*  @scratch: ds 6
0B0E3A             0324*  
0B0E3A             0325*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B0E3A             0326*  ; output: uh.l is the 16.8 fixed format angle
0B0E3A             0327*  ; destroys: a,hl,bc,de
0B0E3A             0328*  ; the following note was written by github copilot:
0B0E3A             0329*  ; note: this routine is a bit of a hack
0B0E3A             0330*  ;      but it works
0B0E3A             0331*  ;      and it's fast
0B0E3A             0332*  ;      and it's small
0B0E3A             0333*  ;      and it's accurate
0B0E3A             0334*  ;      and it's easy to understand
0B0E3A             0335*  ;      and it's easy to modify
0B0E3A             0336*  ;      and it's easy to use
0B0E3A             0337*  ;      and it's easy to remember
0B0E3A             0338*  ;      and it's easy to love
0B0E3A             0339*  ;      and it's easy to hate
0B0E3A             0340*  ;      and it's easy to ignore
0B0E3A             0341*  ;      and it's easy to forget
0B0E3A             0342*  ;      and it's easy to remember
0B0E3A             0343*  ;      and it's easy to forget
0B0E3A             0344*  ;      and it's easy to remember
0B0E3A             0345*  ;      (ok the bot is stuck in a loop)
0B0E3A             0346*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B0E3A             0347*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B0E3A             0348*  atan_168game:
0B0E3A             0349*  ; because we use compass headings instead of geometric angles
0B0E3A             0350*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B0E3A             0351*  ; we can do faster unsigned division here because we know dx and dy are positive
0B0E3A CD 61 0B 0B 0352*  	call udiv168 ; uh.l = dx/dy
0B0E3E             0353*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B0E3E             0354*  ; ; test uh.l for 0
0B0E3E             0355*  ;     add hl,de
0B0E3E             0356*  ;     or a
0B0E3E             0357*  ;     sbc hl,de
0B0E3E             0358*  ;     jr z,@is_zero
0B0E3E             0359*  ; ; test uh.l for 1
0B0E3E             0360*  ;     xor a ; clear carry
0B0E3E             0361*  ;     ex de,hl
0B0E3E             0362*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B0E3E             0363*  ;     sbc hl,de
0B0E3E             0364*  ;     jr z,@is_45
0B0E3E             0365*  ; ; END TODO
0B0E3E             0366*  
0B0E3E             0367*  ; no special cases so we move on
0B0E3E             0368*  ; l contains the fractional portion of tan(uh.l)
0B0E3E             0369*  ; we multiply it by three to get our lookup table index
0B0E3E 26 03       0370*      ld h,3
0B0E40 ED 6C       0371*      mlt hl ; gosh that is handy
0B0E42 11 00 00 00 0372*      ld de,0 ; clear deu
0B0E46 54          0373*      ld d,h ; copy hl to de
0B0E47 5D          0374*      ld e,l ; de contains our index
0B0E48 21 63 1A 0B 0375*      ld hl,atan_lut_168 ; grab the lut address
0B0E4C 19          0376*      add hl,de ; bump hl by the index
0B0E4D ED 27       0377*      ld hl,(hl) ; don't try this on a z80!
0B0E4F C9          0378*      ret ; and out
0B0E50             0379*  @is_45:
0B0E50 21 00 20 00 0380*      ld hl,0x002000 ; 45 degrees decimal
0B0E54 C9          0381*      ret
0B0E55             0382*  ; for the case tan(0)
0B0E55             0383*  @is_zero:
0B0E55 21 00 00 00 0384*      ld hl,0x000000
0B0E59 C9          0385*      ret
0B0E5A             0386*  
0B0E5A             0387*  sin_lut_168:
0B0E5A 00 00 00    0388*  	dl 0x000000 ; 0.000 00, 0.000
0B0E5D 06 00 00    0389*  	dl 0x000006 ; 1.406 01, 0.025
0B0E60 0C 00 00    0390*  	dl 0x00000C ; 2.813 02, 0.049
0B0E63 12 00 00    0391*  	dl 0x000012 ; 4.219 03, 0.074
0B0E66 19 00 00    0392*  	dl 0x000019 ; 5.625 04, 0.098
0B0E69 1F 00 00    0393*  	dl 0x00001F ; 7.031 05, 0.122
0B0E6C 25 00 00    0394*  	dl 0x000025 ; 8.438 06, 0.147
0B0E6F 2B 00 00    0395*  	dl 0x00002B ; 9.844 07, 0.171
0B0E72 31 00 00    0396*  	dl 0x000031 ; 11.250 08, 0.195
0B0E75 38 00 00    0397*  	dl 0x000038 ; 12.656 09, 0.219
0B0E78 3E 00 00    0398*  	dl 0x00003E ; 14.063 0A, 0.243
0B0E7B 44 00 00    0399*  	dl 0x000044 ; 15.469 0B, 0.267
0B0E7E 4A 00 00    0400*  	dl 0x00004A ; 16.875 0C, 0.290
0B0E81 50 00 00    0401*  	dl 0x000050 ; 18.281 0D, 0.314
0B0E84 56 00 00    0402*  	dl 0x000056 ; 19.688 0E, 0.337
0B0E87 5C 00 00    0403*  	dl 0x00005C ; 21.094 0F, 0.360
0B0E8A 61 00 00    0404*  	dl 0x000061 ; 22.500 10, 0.383
0B0E8D 67 00 00    0405*  	dl 0x000067 ; 23.906 11, 0.405
0B0E90 6D 00 00    0406*  	dl 0x00006D ; 25.313 12, 0.428
0B0E93 73 00 00    0407*  	dl 0x000073 ; 26.719 13, 0.450
0B0E96 78 00 00    0408*  	dl 0x000078 ; 28.125 14, 0.471
0B0E99 7E 00 00    0409*  	dl 0x00007E ; 29.531 15, 0.493
0B0E9C 83 00 00    0410*  	dl 0x000083 ; 30.938 16, 0.514
0B0E9F 88 00 00    0411*  	dl 0x000088 ; 32.344 17, 0.535
0B0EA2 8E 00 00    0412*  	dl 0x00008E ; 33.750 18, 0.556
0B0EA5 93 00 00    0413*  	dl 0x000093 ; 35.156 19, 0.576
0B0EA8 98 00 00    0414*  	dl 0x000098 ; 36.563 1A, 0.596
0B0EAB 9D 00 00    0415*  	dl 0x00009D ; 37.969 1B, 0.615
0B0EAE A2 00 00    0416*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B0EB1 A7 00 00    0417*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B0EB4 AB 00 00    0418*  	dl 0x0000AB ; 42.188 1E, 0.672
0B0EB7 B0 00 00    0419*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B0EBA B5 00 00    0420*  	dl 0x0000B5 ; 45.000 20, 0.707
0B0EBD B9 00 00    0421*  	dl 0x0000B9 ; 46.406 21, 0.724
0B0EC0 BD 00 00    0422*  	dl 0x0000BD ; 47.813 22, 0.741
0B0EC3 C1 00 00    0423*  	dl 0x0000C1 ; 49.219 23, 0.757
0B0EC6 C5 00 00    0424*  	dl 0x0000C5 ; 50.625 24, 0.773
0B0EC9 C9 00 00    0425*  	dl 0x0000C9 ; 52.031 25, 0.788
0B0ECC CD 00 00    0426*  	dl 0x0000CD ; 53.438 26, 0.803
0B0ECF D1 00 00    0427*  	dl 0x0000D1 ; 54.844 27, 0.818
0B0ED2 D4 00 00    0428*  	dl 0x0000D4 ; 56.250 28, 0.831
0B0ED5 D8 00 00    0429*  	dl 0x0000D8 ; 57.656 29, 0.845
0B0ED8 DB 00 00    0430*  	dl 0x0000DB ; 59.063 2A, 0.858
0B0EDB DE 00 00    0431*  	dl 0x0000DE ; 60.469 2B, 0.870
0B0EDE E1 00 00    0432*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B0EE1 E4 00 00    0433*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B0EE4 E7 00 00    0434*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B0EE7 EA 00 00    0435*  	dl 0x0000EA ; 66.094 2F, 0.914
0B0EEA EC 00 00    0436*  	dl 0x0000EC ; 67.500 30, 0.924
0B0EED EE 00 00    0437*  	dl 0x0000EE ; 68.906 31, 0.933
0B0EF0 F1 00 00    0438*  	dl 0x0000F1 ; 70.313 32, 0.942
0B0EF3 F3 00 00    0439*  	dl 0x0000F3 ; 71.719 33, 0.950
0B0EF6 F4 00 00    0440*  	dl 0x0000F4 ; 73.125 34, 0.957
0B0EF9 F6 00 00    0441*  	dl 0x0000F6 ; 74.531 35, 0.964
0B0EFC F8 00 00    0442*  	dl 0x0000F8 ; 75.938 36, 0.970
0B0EFF F9 00 00    0443*  	dl 0x0000F9 ; 77.344 37, 0.976
0B0F02 FB 00 00    0444*  	dl 0x0000FB ; 78.750 38, 0.981
0B0F05 FC 00 00    0445*  	dl 0x0000FC ; 80.156 39, 0.985
0B0F08 FD 00 00    0446*  	dl 0x0000FD ; 81.563 3A, 0.989
0B0F0B FE 00 00    0447*  	dl 0x0000FE ; 82.969 3B, 0.992
0B0F0E FE 00 00    0448*  	dl 0x0000FE ; 84.375 3C, 0.995
0B0F11 FF 00 00    0449*  	dl 0x0000FF ; 85.781 3D, 0.997
0B0F14 FF 00 00    0450*  	dl 0x0000FF ; 87.188 3E, 0.999
0B0F17 FF 00 00    0451*  	dl 0x0000FF ; 88.594 3F, 1.000
0B0F1A 00 01 00    0452*  	dl 0x000100 ; 90.000 40, 1.000
0B0F1D FF 00 00    0453*  	dl 0x0000FF ; 91.406 41, 1.000
0B0F20 FF 00 00    0454*  	dl 0x0000FF ; 92.813 42, 0.999
0B0F23 FF 00 00    0455*  	dl 0x0000FF ; 94.219 43, 0.997
0B0F26 FE 00 00    0456*  	dl 0x0000FE ; 95.625 44, 0.995
0B0F29 FE 00 00    0457*  	dl 0x0000FE ; 97.031 45, 0.992
0B0F2C FD 00 00    0458*  	dl 0x0000FD ; 98.438 46, 0.989
0B0F2F FC 00 00    0459*  	dl 0x0000FC ; 99.844 47, 0.985
0B0F32 FB 00 00    0460*  	dl 0x0000FB ; 101.250 48, 0.981
0B0F35 F9 00 00    0461*  	dl 0x0000F9 ; 102.656 49, 0.976
0B0F38 F8 00 00    0462*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B0F3B F6 00 00    0463*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B0F3E F4 00 00    0464*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B0F41 F3 00 00    0465*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B0F44 F1 00 00    0466*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B0F47 EE 00 00    0467*  	dl 0x0000EE ; 111.094 4F, 0.933
0B0F4A EC 00 00    0468*  	dl 0x0000EC ; 112.500 50, 0.924
0B0F4D EA 00 00    0469*  	dl 0x0000EA ; 113.906 51, 0.914
0B0F50 E7 00 00    0470*  	dl 0x0000E7 ; 115.313 52, 0.904
0B0F53 E4 00 00    0471*  	dl 0x0000E4 ; 116.719 53, 0.893
0B0F56 E1 00 00    0472*  	dl 0x0000E1 ; 118.125 54, 0.882
0B0F59 DE 00 00    0473*  	dl 0x0000DE ; 119.531 55, 0.870
0B0F5C DB 00 00    0474*  	dl 0x0000DB ; 120.938 56, 0.858
0B0F5F D8 00 00    0475*  	dl 0x0000D8 ; 122.344 57, 0.845
0B0F62 D4 00 00    0476*  	dl 0x0000D4 ; 123.750 58, 0.831
0B0F65 D1 00 00    0477*  	dl 0x0000D1 ; 125.156 59, 0.818
0B0F68 CD 00 00    0478*  	dl 0x0000CD ; 126.563 5A, 0.803
0B0F6B C9 00 00    0479*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B0F6E C5 00 00    0480*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B0F71 C1 00 00    0481*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B0F74 BD 00 00    0482*  	dl 0x0000BD ; 132.188 5E, 0.741
0B0F77 B9 00 00    0483*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B0F7A B5 00 00    0484*  	dl 0x0000B5 ; 135.000 60, 0.707
0B0F7D B0 00 00    0485*  	dl 0x0000B0 ; 136.406 61, 0.690
0B0F80 AB 00 00    0486*  	dl 0x0000AB ; 137.813 62, 0.672
0B0F83 A7 00 00    0487*  	dl 0x0000A7 ; 139.219 63, 0.653
0B0F86 A2 00 00    0488*  	dl 0x0000A2 ; 140.625 64, 0.634
0B0F89 9D 00 00    0489*  	dl 0x00009D ; 142.031 65, 0.615
0B0F8C 98 00 00    0490*  	dl 0x000098 ; 143.438 66, 0.596
0B0F8F 93 00 00    0491*  	dl 0x000093 ; 144.844 67, 0.576
0B0F92 8E 00 00    0492*  	dl 0x00008E ; 146.250 68, 0.556
0B0F95 88 00 00    0493*  	dl 0x000088 ; 147.656 69, 0.535
0B0F98 83 00 00    0494*  	dl 0x000083 ; 149.063 6A, 0.514
0B0F9B 7E 00 00    0495*  	dl 0x00007E ; 150.469 6B, 0.493
0B0F9E 78 00 00    0496*  	dl 0x000078 ; 151.875 6C, 0.471
0B0FA1 73 00 00    0497*  	dl 0x000073 ; 153.281 6D, 0.450
0B0FA4 6D 00 00    0498*  	dl 0x00006D ; 154.688 6E, 0.428
0B0FA7 67 00 00    0499*  	dl 0x000067 ; 156.094 6F, 0.405
0B0FAA 61 00 00    0500*  	dl 0x000061 ; 157.500 70, 0.383
0B0FAD 5C 00 00    0501*  	dl 0x00005C ; 158.906 71, 0.360
0B0FB0 56 00 00    0502*  	dl 0x000056 ; 160.313 72, 0.337
0B0FB3 50 00 00    0503*  	dl 0x000050 ; 161.719 73, 0.314
0B0FB6 4A 00 00    0504*  	dl 0x00004A ; 163.125 74, 0.290
0B0FB9 44 00 00    0505*  	dl 0x000044 ; 164.531 75, 0.267
0B0FBC 3E 00 00    0506*  	dl 0x00003E ; 165.938 76, 0.243
0B0FBF 38 00 00    0507*  	dl 0x000038 ; 167.344 77, 0.219
0B0FC2 31 00 00    0508*  	dl 0x000031 ; 168.750 78, 0.195
0B0FC5 2B 00 00    0509*  	dl 0x00002B ; 170.156 79, 0.171
0B0FC8 25 00 00    0510*  	dl 0x000025 ; 171.563 7A, 0.147
0B0FCB 1F 00 00    0511*  	dl 0x00001F ; 172.969 7B, 0.122
0B0FCE 19 00 00    0512*  	dl 0x000019 ; 174.375 7C, 0.098
0B0FD1 12 00 00    0513*  	dl 0x000012 ; 175.781 7D, 0.074
0B0FD4 0C 00 00    0514*  	dl 0x00000C ; 177.188 7E, 0.049
0B0FD7 06 00 00    0515*  	dl 0x000006 ; 178.594 7F, 0.025
0B0FDA 00 00 00    0516*  	dl 0x000000 ; 180.000 80, 0.000
0B0FDD FA FF FF    0517*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B0FE0 F4 FF FF    0518*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B0FE3 EE FF FF    0519*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B0FE6 E7 FF FF    0520*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B0FE9 E1 FF FF    0521*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B0FEC DB FF FF    0522*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B0FEF D5 FF FF    0523*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B0FF2 CF FF FF    0524*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B0FF5 C8 FF FF    0525*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B0FF8 C2 FF FF    0526*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B0FFB BC FF FF    0527*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B0FFE B6 FF FF    0528*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B1001 B0 FF FF    0529*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B1004 AA FF FF    0530*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B1007 A4 FF FF    0531*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B100A 9F FF FF    0532*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B100D 99 FF FF    0533*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B1010 93 FF FF    0534*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B1013 8D FF FF    0535*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B1016 88 FF FF    0536*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B1019 82 FF FF    0537*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B101C 7D FF FF    0538*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B101F 78 FF FF    0539*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B1022 72 FF FF    0540*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B1025 6D FF FF    0541*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B1028 68 FF FF    0542*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B102B 63 FF FF    0543*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B102E 5E FF FF    0544*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B1031 59 FF FF    0545*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B1034 55 FF FF    0546*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B1037 50 FF FF    0547*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B103A 4B FF FF    0548*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B103D 47 FF FF    0549*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B1040 43 FF FF    0550*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B1043 3F FF FF    0551*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B1046 3B FF FF    0552*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B1049 37 FF FF    0553*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B104C 33 FF FF    0554*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B104F 2F FF FF    0555*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B1052 2C FF FF    0556*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B1055 28 FF FF    0557*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B1058 25 FF FF    0558*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B105B 22 FF FF    0559*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B105E 1F FF FF    0560*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B1061 1C FF FF    0561*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B1064 19 FF FF    0562*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B1067 16 FF FF    0563*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B106A 14 FF FF    0564*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B106D 12 FF FF    0565*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B1070 0F FF FF    0566*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B1073 0D FF FF    0567*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B1076 0C FF FF    0568*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B1079 0A FF FF    0569*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B107C 08 FF FF    0570*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B107F 07 FF FF    0571*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B1082 05 FF FF    0572*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B1085 04 FF FF    0573*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B1088 03 FF FF    0574*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B108B 02 FF FF    0575*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B108E 02 FF FF    0576*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B1091 01 FF FF    0577*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B1094 01 FF FF    0578*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B1097 01 FF FF    0579*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B109A 00 FF FF    0580*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B109D 01 FF FF    0581*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B10A0 01 FF FF    0582*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B10A3 01 FF FF    0583*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B10A6 02 FF FF    0584*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B10A9 02 FF FF    0585*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B10AC 03 FF FF    0586*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B10AF 04 FF FF    0587*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B10B2 05 FF FF    0588*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B10B5 07 FF FF    0589*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B10B8 08 FF FF    0590*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B10BB 0A FF FF    0591*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B10BE 0C FF FF    0592*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B10C1 0D FF FF    0593*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B10C4 0F FF FF    0594*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B10C7 12 FF FF    0595*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B10CA 14 FF FF    0596*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B10CD 16 FF FF    0597*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B10D0 19 FF FF    0598*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B10D3 1C FF FF    0599*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B10D6 1F FF FF    0600*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B10D9 22 FF FF    0601*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B10DC 25 FF FF    0602*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B10DF 28 FF FF    0603*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B10E2 2C FF FF    0604*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B10E5 2F FF FF    0605*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B10E8 33 FF FF    0606*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B10EB 37 FF FF    0607*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B10EE 3B FF FF    0608*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B10F1 3F FF FF    0609*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B10F4 43 FF FF    0610*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B10F7 47 FF FF    0611*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B10FA 4B FF FF    0612*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B10FD 50 FF FF    0613*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B1100 55 FF FF    0614*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B1103 59 FF FF    0615*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1106 5E FF FF    0616*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1109 63 FF FF    0617*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B110C 68 FF FF    0618*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B110F 6D FF FF    0619*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B1112 72 FF FF    0620*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1115 78 FF FF    0621*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1118 7D FF FF    0622*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B111B 82 FF FF    0623*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B111E 88 FF FF    0624*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B1121 8D FF FF    0625*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B1124 93 FF FF    0626*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B1127 99 FF FF    0627*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B112A 9F FF FF    0628*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B112D A4 FF FF    0629*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B1130 AA FF FF    0630*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B1133 B0 FF FF    0631*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B1136 B6 FF FF    0632*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B1139 BC FF FF    0633*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B113C C2 FF FF    0634*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B113F C8 FF FF    0635*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B1142 CF FF FF    0636*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B1145 D5 FF FF    0637*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B1148 DB FF FF    0638*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B114B E1 FF FF    0639*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B114E E7 FF FF    0640*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B1151 EE FF FF    0641*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B1154 F4 FF FF    0642*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B1157 FA FF FF    0643*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B115A 00 00 00    0644*  	dl 0x000000 ; 0.000 00, 0.000 for interpolation
0B115D             0645*  
0B115D             0646*  sin_lut_816:
0B115D 00 00 00 48 0647*      dl 0x000000,0x000648 ; 00 000.000 0.000
       06 00       
0B1163 48 06 00 48 0648*      dl 0x000648,0x000648 ; 01 001.406 0.025
       06 00       
0B1169 90 0C 00 45 0649*      dl 0x000C90,0x000645 ; 02 002.813 0.049
       06 00       
0B116F D5 12 00 42 0650*      dl 0x0012D5,0x000642 ; 03 004.219 0.074
       06 00       
0B1175 17 19 00 3E 0651*      dl 0x001917,0x00063E ; 04 005.625 0.098
       06 00       
0B117B 56 1F 00 3A 0652*      dl 0x001F56,0x00063A ; 05 007.031 0.122
       06 00       
0B1181 90 25 00 33 0653*      dl 0x002590,0x000633 ; 06 008.438 0.147
       06 00       
0B1187 C4 2B 00 2C 0654*      dl 0x002BC4,0x00062C ; 07 009.844 0.171
       06 00       
0B118D F1 31 00 25 0655*      dl 0x0031F1,0x000625 ; 08 011.250 0.195
       06 00       
0B1193 16 38 00 1D 0656*      dl 0x003816,0x00061D ; 09 012.656 0.219
       06 00       
0B1199 34 3E 00 13 0657*      dl 0x003E34,0x000613 ; 0A 014.063 0.243
       06 00       
0B119F 47 44 00 08 0658*      dl 0x004447,0x000608 ; 0B 015.469 0.267
       06 00       
0B11A5 50 4A 00 FD 0659*      dl 0x004A50,0x0005FD ; 0C 016.875 0.290
       05 00       
0B11AB 4D 50 00 F1 0660*      dl 0x00504D,0x0005F1 ; 0D 018.281 0.314
       05 00       
0B11B1 3E 56 00 E3 0661*      dl 0x00563E,0x0005E3 ; 0E 019.688 0.337
       05 00       
0B11B7 22 5C 00 D5 0662*      dl 0x005C22,0x0005D5 ; 0F 021.094 0.360
       05 00       
0B11BD F7 61 00 C6 0663*      dl 0x0061F7,0x0005C6 ; 10 022.500 0.383
       05 00       
0B11C3 BD 67 00 B7 0664*      dl 0x0067BD,0x0005B7 ; 11 023.906 0.405
       05 00       
0B11C9 74 6D 00 A5 0665*      dl 0x006D74,0x0005A5 ; 12 025.313 0.428
       05 00       
0B11CF 19 73 00 93 0666*      dl 0x007319,0x000593 ; 13 026.719 0.450
       05 00       
0B11D5 AD 78 00 80 0667*      dl 0x0078AD,0x000580 ; 14 028.125 0.471
       05 00       
0B11DB 2E 7E 00 6E 0668*      dl 0x007E2E,0x00056E ; 15 029.531 0.493
       05 00       
0B11E1 9C 83 00 59 0669*      dl 0x00839C,0x000559 ; 16 030.938 0.514
       05 00       
0B11E7 F5 88 00 44 0670*      dl 0x0088F5,0x000544 ; 17 032.344 0.535
       05 00       
0B11ED 39 8E 00 2E 0671*      dl 0x008E39,0x00052E ; 18 033.750 0.556
       05 00       
0B11F3 67 93 00 18 0672*      dl 0x009367,0x000518 ; 19 035.156 0.576
       05 00       
0B11F9 80 98 00 FF 0673*      dl 0x009880,0x0004FF ; 1A 036.563 0.596
       04 00       
0B11FF 80 9D 00 E7 0674*      dl 0x009D80,0x0004E7 ; 1B 037.969 0.615
       04 00       
0B1205 67 A2 00 CE 0675*      dl 0x00A267,0x0004CE ; 1C 039.375 0.634
       04 00       
0B120B 36 A7 00 B5 0676*      dl 0x00A736,0x0004B5 ; 1D 040.781 0.653
       04 00       
0B1211 EB AB 00 9A 0677*      dl 0x00ABEB,0x00049A ; 1E 042.188 0.672
       04 00       
0B1217 85 B0 00 7F 0678*      dl 0x00B085,0x00047F ; 1F 043.594 0.690
       04 00       
0B121D 04 B5 00 63 0679*      dl 0x00B504,0x000463 ; 20 045.000 0.707
       04 00       
0B1223 68 B9 00 47 0680*      dl 0x00B968,0x000447 ; 21 046.406 0.724
       04 00       
0B1229 AF BD 00 29 0681*      dl 0x00BDAF,0x000429 ; 22 047.813 0.741
       04 00       
0B122F D8 C1 00 0B 0682*      dl 0x00C1D8,0x00040B ; 23 049.219 0.757
       04 00       
0B1235 E4 C5 00 EC 0683*      dl 0x00C5E4,0x0003EC ; 24 050.625 0.773
       03 00       
0B123B D0 C9 00 CE 0684*      dl 0x00C9D0,0x0003CE ; 25 052.031 0.788
       03 00       
0B1241 9F CD 00 AE 0685*      dl 0x00CD9F,0x0003AE ; 26 053.438 0.803
       03 00       
0B1247 4D D1 00 8D 0686*      dl 0x00D14D,0x00038D ; 27 054.844 0.818
       03 00       
0B124D DB D4 00 6C 0687*      dl 0x00D4DB,0x00036C ; 28 056.250 0.831
       03 00       
0B1253 48 D8 00 4C 0688*      dl 0x00D848,0x00034C ; 29 057.656 0.845
       03 00       
0B1259 94 DB 00 29 0689*      dl 0x00DB94,0x000329 ; 2A 059.063 0.858
       03 00       
0B125F BE DE 00 07 0690*      dl 0x00DEBE,0x000307 ; 2B 060.469 0.870
       03 00       
0B1265 C5 E1 00 E4 0691*      dl 0x00E1C5,0x0002E4 ; 2C 061.875 0.882
       02 00       
0B126B AA E4 00 C1 0692*      dl 0x00E4AA,0x0002C1 ; 2D 063.281 0.893
       02 00       
0B1271 6C E7 00 9D 0693*      dl 0x00E76C,0x00029D ; 2E 064.688 0.904
       02 00       
0B1277 09 EA 00 79 0694*      dl 0x00EA09,0x000279 ; 2F 066.094 0.914
       02 00       
0B127D 83 EC 00 55 0695*      dl 0x00EC83,0x000255 ; 30 067.500 0.924
       02 00       
0B1283 D8 EE 00 30 0696*      dl 0x00EED8,0x000230 ; 31 068.906 0.933
       02 00       
0B1289 09 F1 00 0B 0697*      dl 0x00F109,0x00020B ; 32 070.313 0.942
       02 00       
0B128F 14 F3 00 E5 0698*      dl 0x00F314,0x0001E5 ; 33 071.719 0.950
       01 00       
0B1295 FA F4 00 BF 0699*      dl 0x00F4FA,0x0001BF ; 34 073.125 0.957
       01 00       
0B129B B9 F6 00 9A 0700*      dl 0x00F6B9,0x00019A ; 35 074.531 0.964
       01 00       
0B12A1 54 F8 00 73 0701*      dl 0x00F854,0x000173 ; 36 075.938 0.970
       01 00       
0B12A7 C7 F9 00 4D 0702*      dl 0x00F9C7,0x00014D ; 37 077.344 0.976
       01 00       
0B12AD 14 FB 00 26 0703*      dl 0x00FB14,0x000126 ; 38 078.750 0.981
       01 00       
0B12B3 3B FC 00 FF 0704*      dl 0x00FC3B,0x0000FF ; 39 080.156 0.985
       00 00       
0B12B9 3A FD 00 D8 0705*      dl 0x00FD3A,0x0000D8 ; 3A 081.563 0.989
       00 00       
0B12BF 13 FE 00 B1 0706*      dl 0x00FE13,0x0000B1 ; 3B 082.969 0.992
       00 00       
0B12C5 C4 FE 00 89 0707*      dl 0x00FEC4,0x000089 ; 3C 084.375 0.995
       00 00       
0B12CB 4E FF 00 62 0708*      dl 0x00FF4E,0x000062 ; 3D 085.781 0.997
       00 00       
0B12D1 B1 FF 00 3B 0709*      dl 0x00FFB1,0x00003B ; 3E 087.188 0.999
       00 00       
0B12D7 EC FF 00 13 0710*      dl 0x00FFEC,0x000013 ; 3F 088.594 1.000
       00 00       
0B12DD 00 00 01 EC 0711*      dl 0x010000,0xFFFFEC ; 40 090.000 1.000
       FF FF       
0B12E3 EC FF 00 C4 0712*      dl 0x00FFEC,0xFFFFC4 ; 41 091.406 1.000
       FF FF       
0B12E9 B1 FF 00 9D 0713*      dl 0x00FFB1,0xFFFF9D ; 42 092.813 0.999
       FF FF       
0B12EF 4E FF 00 76 0714*      dl 0x00FF4E,0xFFFF76 ; 43 094.219 0.997
       FF FF       
0B12F5 C4 FE 00 4E 0715*      dl 0x00FEC4,0xFFFF4E ; 44 095.625 0.995
       FF FF       
0B12FB 13 FE 00 27 0716*      dl 0x00FE13,0xFFFF27 ; 45 097.031 0.992
       FF FF       
0B1301 3A FD 00 00 0717*      dl 0x00FD3A,0xFFFF00 ; 46 098.438 0.989
       FF FF       
0B1307 3B FC 00 D9 0718*      dl 0x00FC3B,0xFFFED9 ; 47 099.844 0.985
       FE FF       
0B130D 14 FB 00 B2 0719*      dl 0x00FB14,0xFFFEB2 ; 48 101.250 0.981
       FE FF       
0B1313 C7 F9 00 8C 0720*      dl 0x00F9C7,0xFFFE8C ; 49 102.656 0.976
       FE FF       
0B1319 53 F8 00 66 0721*      dl 0x00F853,0xFFFE66 ; 4A 104.063 0.970
       FE FF       
0B131F B9 F6 00 40 0722*      dl 0x00F6B9,0xFFFE40 ; 4B 105.469 0.964
       FE FF       
0B1325 FA F4 00 1A 0723*      dl 0x00F4FA,0xFFFE1A ; 4C 106.875 0.957
       FE FF       
0B132B 14 F3 00 F4 0724*      dl 0x00F314,0xFFFDF4 ; 4D 108.281 0.950
       FD FF       
0B1331 08 F1 00 CF 0725*      dl 0x00F108,0xFFFDCF ; 4E 109.688 0.942
       FD FF       
0B1337 D8 EE 00 AA 0726*      dl 0x00EED8,0xFFFDAA ; 4F 111.094 0.933
       FD FF       
0B133D 83 EC 00 86 0727*      dl 0x00EC83,0xFFFD86 ; 50 112.500 0.924
       FD FF       
0B1343 09 EA 00 61 0728*      dl 0x00EA09,0xFFFD61 ; 51 113.906 0.914
       FD FF       
0B1349 6B E7 00 3E 0729*      dl 0x00E76B,0xFFFD3E ; 52 115.313 0.904
       FD FF       
0B134F AA E4 00 1B 0730*      dl 0x00E4AA,0xFFFD1B ; 53 116.719 0.893
       FD FF       
0B1355 C5 E1 00 F8 0731*      dl 0x00E1C5,0xFFFCF8 ; 54 118.125 0.882
       FC FF       
0B135B BE DE 00 D5 0732*      dl 0x00DEBE,0xFFFCD5 ; 55 119.531 0.870
       FC FF       
0B1361 93 DB 00 B4 0733*      dl 0x00DB93,0xFFFCB4 ; 56 120.938 0.858
       FC FF       
0B1367 48 D8 00 93 0734*      dl 0x00D848,0xFFFC93 ; 57 122.344 0.845
       FC FF       
0B136D DB D4 00 72 0735*      dl 0x00D4DB,0xFFFC72 ; 58 123.750 0.831
       FC FF       
0B1373 4D D1 00 51 0736*      dl 0x00D14D,0xFFFC51 ; 59 125.156 0.818
       FC FF       
0B1379 9E CD 00 32 0737*      dl 0x00CD9E,0xFFFC32 ; 5A 126.563 0.803
       FC FF       
0B137F D0 C9 00 13 0738*      dl 0x00C9D0,0xFFFC13 ; 5B 127.969 0.788
       FC FF       
0B1385 E4 C5 00 F4 0739*      dl 0x00C5E4,0xFFFBF4 ; 5C 129.375 0.773
       FB FF       
0B138B D8 C1 00 D5 0740*      dl 0x00C1D8,0xFFFBD5 ; 5D 130.781 0.757
       FB FF       
0B1391 AE BD 00 B9 0741*      dl 0x00BDAE,0xFFFBB9 ; 5E 132.188 0.741
       FB FF       
0B1397 68 B9 00 9C 0742*      dl 0x00B968,0xFFFB9C ; 5F 133.594 0.724
       FB FF       
0B139D 04 B5 00 80 0743*      dl 0x00B504,0xFFFB80 ; 60 135.000 0.707
       FB FF       
0B13A3 85 B0 00 64 0744*      dl 0x00B085,0xFFFB64 ; 61 136.406 0.690
       FB FF       
0B13A9 EA AB 00 4B 0745*      dl 0x00ABEA,0xFFFB4B ; 62 137.813 0.672
       FB FF       
0B13AF 36 A7 00 31 0746*      dl 0x00A736,0xFFFB31 ; 63 139.219 0.653
       FB FF       
0B13B5 67 A2 00 18 0747*      dl 0x00A267,0xFFFB18 ; 64 140.625 0.634
       FB FF       
0B13BB 80 9D 00 FF 0748*      dl 0x009D80,0xFFFAFF ; 65 142.031 0.615
       FA FF       
0B13C1 7F 98 00 E8 0749*      dl 0x00987F,0xFFFAE8 ; 66 143.438 0.596
       FA FF       
0B13C7 67 93 00 D1 0750*      dl 0x009367,0xFFFAD1 ; 67 144.844 0.576
       FA FF       
0B13CD 39 8E 00 BB 0751*      dl 0x008E39,0xFFFABB ; 68 146.250 0.556
       FA FF       
0B13D3 F5 88 00 A5 0752*      dl 0x0088F5,0xFFFAA5 ; 69 147.656 0.535
       FA FF       
0B13D9 9B 83 00 92 0753*      dl 0x00839B,0xFFFA92 ; 6A 149.063 0.514
       FA FF       
0B13DF 2E 7E 00 7F 0754*      dl 0x007E2E,0xFFFA7F ; 6B 150.469 0.493
       FA FF       
0B13E5 AD 78 00 6C 0755*      dl 0x0078AD,0xFFFA6C ; 6C 151.875 0.471
       FA FF       
0B13EB 19 73 00 59 0756*      dl 0x007319,0xFFFA59 ; 6D 153.281 0.450
       FA FF       
0B13F1 73 6D 00 49 0757*      dl 0x006D73,0xFFFA49 ; 6E 154.688 0.428
       FA FF       
0B13F7 BD 67 00 39 0758*      dl 0x0067BD,0xFFFA39 ; 6F 156.094 0.405
       FA FF       
0B13FD F7 61 00 2A 0759*      dl 0x0061F7,0xFFFA2A ; 70 157.500 0.383
       FA FF       
0B1403 22 5C 00 1B 0760*      dl 0x005C22,0xFFFA1B ; 71 158.906 0.360
       FA FF       
0B1409 3D 56 00 0F 0761*      dl 0x00563D,0xFFFA0F ; 72 160.313 0.337
       FA FF       
0B140F 4D 50 00 02 0762*      dl 0x00504D,0xFFFA02 ; 73 161.719 0.314
       FA FF       
0B1415 50 4A 00 F7 0763*      dl 0x004A50,0xFFF9F7 ; 74 163.125 0.290
       F9 FF       
0B141B 47 44 00 EB 0764*      dl 0x004447,0xFFF9EB ; 75 164.531 0.267
       F9 FF       
0B1421 33 3E 00 E3 0765*      dl 0x003E33,0xFFF9E3 ; 76 165.938 0.243
       F9 FF       
0B1427 16 38 00 DA 0766*      dl 0x003816,0xFFF9DA ; 77 167.344 0.219
       F9 FF       
0B142D F1 31 00 D3 0767*      dl 0x0031F1,0xFFF9D3 ; 78 168.750 0.195
       F9 FF       
0B1433 C4 2B 00 CB 0768*      dl 0x002BC4,0xFFF9CB ; 79 170.156 0.171
       F9 FF       
0B1439 8F 25 00 C6 0769*      dl 0x00258F,0xFFF9C6 ; 7A 171.563 0.147
       F9 FF       
0B143F 56 1F 00 C1 0770*      dl 0x001F56,0xFFF9C1 ; 7B 172.969 0.122
       F9 FF       
0B1445 17 19 00 BD 0771*      dl 0x001917,0xFFF9BD ; 7C 174.375 0.098
       F9 FF       
0B144B D5 12 00 B9 0772*      dl 0x0012D5,0xFFF9B9 ; 7D 175.781 0.074
       F9 FF       
0B1451 8F 0C 00 B8 0773*      dl 0x000C8F,0xFFF9B8 ; 7E 177.188 0.049
       F9 FF       
0B1457 48 06 00 B7 0774*      dl 0x000648,0xFFF9B7 ; 7F 178.594 0.025
       F9 FF       
0B145D 00 00 00 B7 0775*      dl 0x000000,0xFFF9B7 ; 80 180.000 0.000
       F9 FF       
0B1463 B8 F9 FF B7 0776*      dl 0xFFF9B8,0xFFF9B7 ; 81 181.406 -0.025
       F9 FF       
0B1469 70 F3 FF BA 0777*      dl 0xFFF370,0xFFF9BA ; 82 182.813 -0.049
       F9 FF       
0B146F 2B ED FF BD 0778*      dl 0xFFED2B,0xFFF9BD ; 83 184.219 -0.074
       F9 FF       
0B1475 E9 E6 FF C1 0779*      dl 0xFFE6E9,0xFFF9C1 ; 84 185.625 -0.098
       F9 FF       
0B147B AA E0 FF C5 0780*      dl 0xFFE0AA,0xFFF9C5 ; 85 187.031 -0.122
       F9 FF       
0B1481 70 DA FF CC 0781*      dl 0xFFDA70,0xFFF9CC ; 86 188.438 -0.147
       F9 FF       
0B1487 3C D4 FF D3 0782*      dl 0xFFD43C,0xFFF9D3 ; 87 189.844 -0.171
       F9 FF       
0B148D 0F CE FF DA 0783*      dl 0xFFCE0F,0xFFF9DA ; 88 191.250 -0.195
       F9 FF       
0B1493 EA C7 FF E2 0784*      dl 0xFFC7EA,0xFFF9E2 ; 89 192.656 -0.219
       F9 FF       
0B1499 CC C1 FF EC 0785*      dl 0xFFC1CC,0xFFF9EC ; 8A 194.063 -0.243
       F9 FF       
0B149F B9 BB FF F7 0786*      dl 0xFFBBB9,0xFFF9F7 ; 8B 195.469 -0.267
       F9 FF       
0B14A5 B0 B5 FF 02 0787*      dl 0xFFB5B0,0xFFFA02 ; 8C 196.875 -0.290
       FA FF       
0B14AB B3 AF FF 0E 0788*      dl 0xFFAFB3,0xFFFA0E ; 8D 198.281 -0.314
       FA FF       
0B14B1 C2 A9 FF 1C 0789*      dl 0xFFA9C2,0xFFFA1C ; 8E 199.688 -0.337
       FA FF       
0B14B7 DE A3 FF 2A 0790*      dl 0xFFA3DE,0xFFFA2A ; 8F 201.094 -0.360
       FA FF       
0B14BD 09 9E FF 39 0791*      dl 0xFF9E09,0xFFFA39 ; 90 202.500 -0.383
       FA FF       
0B14C3 43 98 FF 48 0792*      dl 0xFF9843,0xFFFA48 ; 91 203.906 -0.405
       FA FF       
0B14C9 8C 92 FF 5A 0793*      dl 0xFF928C,0xFFFA5A ; 92 205.313 -0.428
       FA FF       
0B14CF E7 8C FF 6C 0794*      dl 0xFF8CE7,0xFFFA6C ; 93 206.719 -0.450
       FA FF       
0B14D5 53 87 FF 7F 0795*      dl 0xFF8753,0xFFFA7F ; 94 208.125 -0.471
       FA FF       
0B14DB D2 81 FF 91 0796*      dl 0xFF81D2,0xFFFA91 ; 95 209.531 -0.493
       FA FF       
0B14E1 64 7C FF A6 0797*      dl 0xFF7C64,0xFFFAA6 ; 96 210.938 -0.514
       FA FF       
0B14E7 0B 77 FF BB 0798*      dl 0xFF770B,0xFFFABB ; 97 212.344 -0.535
       FA FF       
0B14ED C7 71 FF D1 0799*      dl 0xFF71C7,0xFFFAD1 ; 98 213.750 -0.556
       FA FF       
0B14F3 99 6C FF E7 0800*      dl 0xFF6C99,0xFFFAE7 ; 99 215.156 -0.576
       FA FF       
0B14F9 80 67 FF 00 0801*      dl 0xFF6780,0xFFFB00 ; 9A 216.563 -0.596
       FB FF       
0B14FF 80 62 FF 18 0802*      dl 0xFF6280,0xFFFB18 ; 9B 217.969 -0.615
       FB FF       
0B1505 99 5D FF 31 0803*      dl 0xFF5D99,0xFFFB31 ; 9C 219.375 -0.634
       FB FF       
0B150B CA 58 FF 4A 0804*      dl 0xFF58CA,0xFFFB4A ; 9D 220.781 -0.653
       FB FF       
0B1511 15 54 FF 65 0805*      dl 0xFF5415,0xFFFB65 ; 9E 222.188 -0.672
       FB FF       
0B1517 7B 4F FF 80 0806*      dl 0xFF4F7B,0xFFFB80 ; 9F 223.594 -0.690
       FB FF       
0B151D FC 4A FF 9C 0807*      dl 0xFF4AFC,0xFFFB9C ; A0 225.000 -0.707
       FB FF       
0B1523 98 46 FF B8 0808*      dl 0xFF4698,0xFFFBB8 ; A1 226.406 -0.724
       FB FF       
0B1529 51 42 FF D6 0809*      dl 0xFF4251,0xFFFBD6 ; A2 227.813 -0.741
       FB FF       
0B152F 28 3E FF F4 0810*      dl 0xFF3E28,0xFFFBF4 ; A3 229.219 -0.757
       FB FF       
0B1535 1C 3A FF 13 0811*      dl 0xFF3A1C,0xFFFC13 ; A4 230.625 -0.773
       FC FF       
0B153B 30 36 FF 31 0812*      dl 0xFF3630,0xFFFC31 ; A5 232.031 -0.788
       FC FF       
0B1541 61 32 FF 51 0813*      dl 0xFF3261,0xFFFC51 ; A6 233.438 -0.803
       FC FF       
0B1547 B3 2E FF 72 0814*      dl 0xFF2EB3,0xFFFC72 ; A7 234.844 -0.818
       FC FF       
0B154D 25 2B FF 93 0815*      dl 0xFF2B25,0xFFFC93 ; A8 236.250 -0.831
       FC FF       
0B1553 B8 27 FF B3 0816*      dl 0xFF27B8,0xFFFCB3 ; A9 237.656 -0.845
       FC FF       
0B1559 6C 24 FF D6 0817*      dl 0xFF246C,0xFFFCD6 ; AA 239.063 -0.858
       FC FF       
0B155F 42 21 FF F8 0818*      dl 0xFF2142,0xFFFCF8 ; AB 240.469 -0.870
       FC FF       
0B1565 3B 1E FF 1B 0819*      dl 0xFF1E3B,0xFFFD1B ; AC 241.875 -0.882
       FD FF       
0B156B 56 1B FF 3E 0820*      dl 0xFF1B56,0xFFFD3E ; AD 243.281 -0.893
       FD FF       
0B1571 94 18 FF 62 0821*      dl 0xFF1894,0xFFFD62 ; AE 244.688 -0.904
       FD FF       
0B1577 F7 15 FF 86 0822*      dl 0xFF15F7,0xFFFD86 ; AF 246.094 -0.914
       FD FF       
0B157D 7D 13 FF AA 0823*      dl 0xFF137D,0xFFFDAA ; B0 247.500 -0.924
       FD FF       
0B1583 28 11 FF CF 0824*      dl 0xFF1128,0xFFFDCF ; B1 248.906 -0.933
       FD FF       
0B1589 F7 0E FF F4 0825*      dl 0xFF0EF7,0xFFFDF4 ; B2 250.313 -0.942
       FD FF       
0B158F EC 0C FF 1A 0826*      dl 0xFF0CEC,0xFFFE1A ; B3 251.719 -0.950
       FE FF       
0B1595 06 0B FF 40 0827*      dl 0xFF0B06,0xFFFE40 ; B4 253.125 -0.957
       FE FF       
0B159B 47 09 FF 65 0828*      dl 0xFF0947,0xFFFE65 ; B5 254.531 -0.964
       FE FF       
0B15A1 AC 07 FF 8C 0829*      dl 0xFF07AC,0xFFFE8C ; B6 255.938 -0.970
       FE FF       
0B15A7 39 06 FF B2 0830*      dl 0xFF0639,0xFFFEB2 ; B7 257.344 -0.976
       FE FF       
0B15AD EC 04 FF D9 0831*      dl 0xFF04EC,0xFFFED9 ; B8 258.750 -0.981
       FE FF       
0B15B3 C5 03 FF 00 0832*      dl 0xFF03C5,0xFFFF00 ; B9 260.156 -0.985
       FF FF       
0B15B9 C6 02 FF 27 0833*      dl 0xFF02C6,0xFFFF27 ; BA 261.563 -0.989
       FF FF       
0B15BF ED 01 FF 4E 0834*      dl 0xFF01ED,0xFFFF4E ; BB 262.969 -0.992
       FF FF       
0B15C5 3C 01 FF 76 0835*      dl 0xFF013C,0xFFFF76 ; BC 264.375 -0.995
       FF FF       
0B15CB B2 00 FF 9D 0836*      dl 0xFF00B2,0xFFFF9D ; BD 265.781 -0.997
       FF FF       
0B15D1 4F 00 FF C4 0837*      dl 0xFF004F,0xFFFFC4 ; BE 267.188 -0.999
       FF FF       
0B15D7 14 00 FF EC 0838*      dl 0xFF0014,0xFFFFEC ; BF 268.594 -1.000
       FF FF       
0B15DD 00 00 FF 13 0839*      dl 0xFF0000,0x000013 ; C0 270.000 -1.000
       00 00       
0B15E3 14 00 FF 3B 0840*      dl 0xFF0014,0x00003B ; C1 271.406 -1.000
       00 00       
0B15E9 4F 00 FF 62 0841*      dl 0xFF004F,0x000062 ; C2 272.813 -0.999
       00 00       
0B15EF B2 00 FF 89 0842*      dl 0xFF00B2,0x000089 ; C3 274.219 -0.997
       00 00       
0B15F5 3C 01 FF B1 0843*      dl 0xFF013C,0x0000B1 ; C4 275.625 -0.995
       00 00       
0B15FB ED 01 FF D8 0844*      dl 0xFF01ED,0x0000D8 ; C5 277.031 -0.992
       00 00       
0B1601 C6 02 FF FF 0845*      dl 0xFF02C6,0x0000FF ; C6 278.438 -0.989
       00 00       
0B1607 C5 03 FF 26 0846*      dl 0xFF03C5,0x000126 ; C7 279.844 -0.985
       01 00       
0B160D EC 04 FF 4D 0847*      dl 0xFF04EC,0x00014D ; C8 281.250 -0.981
       01 00       
0B1613 39 06 FF 73 0848*      dl 0xFF0639,0x000173 ; C9 282.656 -0.976
       01 00       
0B1619 AD 07 FF 99 0849*      dl 0xFF07AD,0x000199 ; CA 284.063 -0.970
       01 00       
0B161F 47 09 FF BF 0850*      dl 0xFF0947,0x0001BF ; CB 285.469 -0.964
       01 00       
0B1625 06 0B FF E5 0851*      dl 0xFF0B06,0x0001E5 ; CC 286.875 -0.957
       01 00       
0B162B EC 0C FF 0B 0852*      dl 0xFF0CEC,0x00020B ; CD 288.281 -0.950
       02 00       
0B1631 F8 0E FF 30 0853*      dl 0xFF0EF8,0x000230 ; CE 289.688 -0.942
       02 00       
0B1637 28 11 FF 55 0854*      dl 0xFF1128,0x000255 ; CF 291.094 -0.933
       02 00       
0B163D 7D 13 FF 79 0855*      dl 0xFF137D,0x000279 ; D0 292.500 -0.924
       02 00       
0B1643 F7 15 FF 9E 0856*      dl 0xFF15F7,0x00029E ; D1 293.906 -0.914
       02 00       
0B1649 95 18 FF C1 0857*      dl 0xFF1895,0x0002C1 ; D2 295.313 -0.904
       02 00       
0B164F 56 1B FF E4 0858*      dl 0xFF1B56,0x0002E4 ; D3 296.719 -0.893
       02 00       
0B1655 3B 1E FF 07 0859*      dl 0xFF1E3B,0x000307 ; D4 298.125 -0.882
       03 00       
0B165B 42 21 FF 2A 0860*      dl 0xFF2142,0x00032A ; D5 299.531 -0.870
       03 00       
0B1661 6D 24 FF 4B 0861*      dl 0xFF246D,0x00034B ; D6 300.938 -0.858
       03 00       
0B1667 B8 27 FF 6C 0862*      dl 0xFF27B8,0x00036C ; D7 302.344 -0.845
       03 00       
0B166D 25 2B FF 8D 0863*      dl 0xFF2B25,0x00038D ; D8 303.750 -0.831
       03 00       
0B1673 B3 2E FF AE 0864*      dl 0xFF2EB3,0x0003AE ; D9 305.156 -0.818
       03 00       
0B1679 62 32 FF CD 0865*      dl 0xFF3262,0x0003CD ; DA 306.563 -0.803
       03 00       
0B167F 30 36 FF EC 0866*      dl 0xFF3630,0x0003EC ; DB 307.969 -0.788
       03 00       
0B1685 1C 3A FF 0B 0867*      dl 0xFF3A1C,0x00040B ; DC 309.375 -0.773
       04 00       
0B168B 28 3E FF 2A 0868*      dl 0xFF3E28,0x00042A ; DD 310.781 -0.757
       04 00       
0B1691 52 42 FF 46 0869*      dl 0xFF4252,0x000446 ; DE 312.188 -0.741
       04 00       
0B1697 98 46 FF 63 0870*      dl 0xFF4698,0x000463 ; DF 313.594 -0.724
       04 00       
0B169D FC 4A FF 7F 0871*      dl 0xFF4AFC,0x00047F ; E0 315.000 -0.707
       04 00       
0B16A3 7B 4F FF 9B 0872*      dl 0xFF4F7B,0x00049B ; E1 316.406 -0.690
       04 00       
0B16A9 16 54 FF B4 0873*      dl 0xFF5416,0x0004B4 ; E2 317.813 -0.672
       04 00       
0B16AF CA 58 FF CE 0874*      dl 0xFF58CA,0x0004CE ; E3 319.219 -0.653
       04 00       
0B16B5 99 5D FF E7 0875*      dl 0xFF5D99,0x0004E7 ; E4 320.625 -0.634
       04 00       
0B16BB 80 62 FF 00 0876*      dl 0xFF6280,0x000500 ; E5 322.031 -0.615
       05 00       
0B16C1 81 67 FF 17 0877*      dl 0xFF6781,0x000517 ; E6 323.438 -0.596
       05 00       
0B16C7 99 6C FF 2E 0878*      dl 0xFF6C99,0x00052E ; E7 324.844 -0.576
       05 00       
0B16CD C7 71 FF 44 0879*      dl 0xFF71C7,0x000544 ; E8 326.250 -0.556
       05 00       
0B16D3 0B 77 FF 5A 0880*      dl 0xFF770B,0x00055A ; E9 327.656 -0.535
       05 00       
0B16D9 65 7C FF 6D 0881*      dl 0xFF7C65,0x00056D ; EA 329.063 -0.514
       05 00       
0B16DF D2 81 FF 80 0882*      dl 0xFF81D2,0x000580 ; EB 330.469 -0.493
       05 00       
0B16E5 53 87 FF 93 0883*      dl 0xFF8753,0x000593 ; EC 331.875 -0.471
       05 00       
0B16EB E7 8C FF A6 0884*      dl 0xFF8CE7,0x0005A6 ; ED 333.281 -0.450
       05 00       
0B16F1 8D 92 FF B6 0885*      dl 0xFF928D,0x0005B6 ; EE 334.688 -0.428
       05 00       
0B16F7 43 98 FF C6 0886*      dl 0xFF9843,0x0005C6 ; EF 336.094 -0.405
       05 00       
0B16FD 09 9E FF D5 0887*      dl 0xFF9E09,0x0005D5 ; F0 337.500 -0.383
       05 00       
0B1703 DE A3 FF E4 0888*      dl 0xFFA3DE,0x0005E4 ; F1 338.906 -0.360
       05 00       
0B1709 C3 A9 FF F0 0889*      dl 0xFFA9C3,0x0005F0 ; F2 340.313 -0.337
       05 00       
0B170F B3 AF FF FD 0890*      dl 0xFFAFB3,0x0005FD ; F3 341.719 -0.314
       05 00       
0B1715 B0 B5 FF 08 0891*      dl 0xFFB5B0,0x000608 ; F4 343.125 -0.290
       06 00       
0B171B B9 BB FF 14 0892*      dl 0xFFBBB9,0x000614 ; F5 344.531 -0.267
       06 00       
0B1721 CD C1 FF 1C 0893*      dl 0xFFC1CD,0x00061C ; F6 345.938 -0.243
       06 00       
0B1727 EA C7 FF 25 0894*      dl 0xFFC7EA,0x000625 ; F7 347.344 -0.219
       06 00       
0B172D 0F CE FF 2C 0895*      dl 0xFFCE0F,0x00062C ; F8 348.750 -0.195
       06 00       
0B1733 3C D4 FF 34 0896*      dl 0xFFD43C,0x000634 ; F9 350.156 -0.171
       06 00       
0B1739 71 DA FF 39 0897*      dl 0xFFDA71,0x000639 ; FA 351.563 -0.147
       06 00       
0B173F AA E0 FF 3E 0898*      dl 0xFFE0AA,0x00063E ; FB 352.969 -0.122
       06 00       
0B1745 E9 E6 FF 42 0899*      dl 0xFFE6E9,0x000642 ; FC 354.375 -0.098
       06 00       
0B174B 2B ED FF 46 0900*      dl 0xFFED2B,0x000646 ; FD 355.781 -0.074
       06 00       
0B1751 71 F3 FF 47 0901*      dl 0xFFF371,0x000647 ; FE 357.188 -0.049
       06 00       
0B1757 B8 F9 FF 48 0902*      dl 0xFFF9B8,0x000648 ; FF 358.594 -0.025
       06 00       
0B175D 00 00 00 48 0903*      dl 0x000000,0x000648 ; 00 360.000 0.000
       06 00       
0B1763             0904*  
0B1763             0905*  sin_lut_1212:
0B1763 00 00 00    0906*      dl 0x000000 ; 00, 00.000, +0.000000
0B1766 65 00 00    0907*      dl 0x000065 ; 01, 01.406, +0.024541
0B1769 C9 00 00    0908*      dl 0x0000C9 ; 02, 02.812, +0.049068
0B176C 2D 01 00    0909*      dl 0x00012D ; 03, 04.219, +0.073565
0B176F 91 01 00    0910*      dl 0x000191 ; 04, 05.625, +0.098017
0B1772 F5 01 00    0911*      dl 0x0001F5 ; 05, 07.031, +0.122411
0B1775 59 02 00    0912*      dl 0x000259 ; 06, 08.438, +0.146730
0B1778 BC 02 00    0913*      dl 0x0002BC ; 07, 09.844, +0.170962
0B177B 1F 03 00    0914*      dl 0x00031F ; 08, 11.250, +0.195090
0B177E 81 03 00    0915*      dl 0x000381 ; 09, 12.656, +0.219101
0B1781 E3 03 00    0916*      dl 0x0003E3 ; 0A, 14.062, +0.242980
0B1784 44 04 00    0917*      dl 0x000444 ; 0B, 15.469, +0.266713
0B1787 A5 04 00    0918*      dl 0x0004A5 ; 0C, 16.875, +0.290285
0B178A 05 05 00    0919*      dl 0x000505 ; 0D, 18.281, +0.313682
0B178D 64 05 00    0920*      dl 0x000564 ; 0E, 19.688, +0.336890
0B1790 C2 05 00    0921*      dl 0x0005C2 ; 0F, 21.094, +0.359895
0B1793 1F 06 00    0922*      dl 0x00061F ; 10, 22.500, +0.382683
0B1796 7C 06 00    0923*      dl 0x00067C ; 11, 23.906, +0.405241
0B1799 D7 06 00    0924*      dl 0x0006D7 ; 12, 25.312, +0.427555
0B179C 32 07 00    0925*      dl 0x000732 ; 13, 26.719, +0.449611
0B179F 8B 07 00    0926*      dl 0x00078B ; 14, 28.125, +0.471397
0B17A2 E3 07 00    0927*      dl 0x0007E3 ; 15, 29.531, +0.492898
0B17A5 3A 08 00    0928*      dl 0x00083A ; 16, 30.938, +0.514103
0B17A8 8F 08 00    0929*      dl 0x00088F ; 17, 32.344, +0.534998
0B17AB E4 08 00    0930*      dl 0x0008E4 ; 18, 33.750, +0.555570
0B17AE 37 09 00    0931*      dl 0x000937 ; 19, 35.156, +0.575808
0B17B1 88 09 00    0932*      dl 0x000988 ; 1A, 36.562, +0.595699
0B17B4 D8 09 00    0933*      dl 0x0009D8 ; 1B, 37.969, +0.615232
0B17B7 26 0A 00    0934*      dl 0x000A26 ; 1C, 39.375, +0.634393
0B17BA 73 0A 00    0935*      dl 0x000A73 ; 1D, 40.781, +0.653173
0B17BD BF 0A 00    0936*      dl 0x000ABF ; 1E, 42.188, +0.671559
0B17C0 08 0B 00    0937*      dl 0x000B08 ; 1F, 43.594, +0.689541
0B17C3 50 0B 00    0938*      dl 0x000B50 ; 20, 45.000, +0.707107
0B17C6 97 0B 00    0939*      dl 0x000B97 ; 21, 46.406, +0.724247
0B17C9 DB 0B 00    0940*      dl 0x000BDB ; 22, 47.812, +0.740951
0B17CC 1E 0C 00    0941*      dl 0x000C1E ; 23, 49.219, +0.757209
0B17CF 5E 0C 00    0942*      dl 0x000C5E ; 24, 50.625, +0.773010
0B17D2 9D 0C 00    0943*      dl 0x000C9D ; 25, 52.031, +0.788346
0B17D5 DA 0C 00    0944*      dl 0x000CDA ; 26, 53.438, +0.803208
0B17D8 15 0D 00    0945*      dl 0x000D15 ; 27, 54.844, +0.817585
0B17DB 4E 0D 00    0946*      dl 0x000D4E ; 28, 56.250, +0.831470
0B17DE 85 0D 00    0947*      dl 0x000D85 ; 29, 57.656, +0.844854
0B17E1 B9 0D 00    0948*      dl 0x000DB9 ; 2A, 59.062, +0.857729
0B17E4 EC 0D 00    0949*      dl 0x000DEC ; 2B, 60.469, +0.870087
0B17E7 1C 0E 00    0950*      dl 0x000E1C ; 2C, 61.875, +0.881921
0B17EA 4B 0E 00    0951*      dl 0x000E4B ; 2D, 63.281, +0.893224
0B17ED 77 0E 00    0952*      dl 0x000E77 ; 2E, 64.688, +0.903989
0B17F0 A1 0E 00    0953*      dl 0x000EA1 ; 2F, 66.094, +0.914210
0B17F3 C8 0E 00    0954*      dl 0x000EC8 ; 30, 67.500, +0.923880
0B17F6 EE 0E 00    0955*      dl 0x000EEE ; 31, 68.906, +0.932993
0B17F9 11 0F 00    0956*      dl 0x000F11 ; 32, 70.312, +0.941544
0B17FC 31 0F 00    0957*      dl 0x000F31 ; 33, 71.719, +0.949528
0B17FF 50 0F 00    0958*      dl 0x000F50 ; 34, 73.125, +0.956940
0B1802 6C 0F 00    0959*      dl 0x000F6C ; 35, 74.531, +0.963776
0B1805 85 0F 00    0960*      dl 0x000F85 ; 36, 75.938, +0.970031
0B1808 9C 0F 00    0961*      dl 0x000F9C ; 37, 77.344, +0.975702
0B180B B1 0F 00    0962*      dl 0x000FB1 ; 38, 78.750, +0.980785
0B180E C4 0F 00    0963*      dl 0x000FC4 ; 39, 80.156, +0.985278
0B1811 D4 0F 00    0964*      dl 0x000FD4 ; 3A, 81.562, +0.989177
0B1814 E1 0F 00    0965*      dl 0x000FE1 ; 3B, 82.969, +0.992480
0B1817 EC 0F 00    0966*      dl 0x000FEC ; 3C, 84.375, +0.995185
0B181A F5 0F 00    0967*      dl 0x000FF5 ; 3D, 85.781, +0.997290
0B181D FB 0F 00    0968*      dl 0x000FFB ; 3E, 87.188, +0.998795
0B1820 FF 0F 00    0969*      dl 0x000FFF ; 3F, 88.594, +0.999699
0B1823 00 10 00    0970*      dl 0x001000 ; 40, 90.000, +1.000000
0B1826 FF 0F 00    0971*      dl 0x000FFF ; 41, 91.406, +0.999699
0B1829 FB 0F 00    0972*      dl 0x000FFB ; 42, 92.812, +0.998795
0B182C F5 0F 00    0973*      dl 0x000FF5 ; 43, 94.219, +0.997290
0B182F EC 0F 00    0974*      dl 0x000FEC ; 44, 95.625, +0.995185
0B1832 E1 0F 00    0975*      dl 0x000FE1 ; 45, 97.031, +0.992480
0B1835 D4 0F 00    0976*      dl 0x000FD4 ; 46, 98.438, +0.989177
0B1838 C4 0F 00    0977*      dl 0x000FC4 ; 47, 99.844, +0.985278
0B183B B1 0F 00    0978*      dl 0x000FB1 ; 48, 101.250, +0.980785
0B183E 9C 0F 00    0979*      dl 0x000F9C ; 49, 102.656, +0.975702
0B1841 85 0F 00    0980*      dl 0x000F85 ; 4A, 104.062, +0.970031
0B1844 6C 0F 00    0981*      dl 0x000F6C ; 4B, 105.469, +0.963776
0B1847 50 0F 00    0982*      dl 0x000F50 ; 4C, 106.875, +0.956940
0B184A 31 0F 00    0983*      dl 0x000F31 ; 4D, 108.281, +0.949528
0B184D 11 0F 00    0984*      dl 0x000F11 ; 4E, 109.688, +0.941544
0B1850 EE 0E 00    0985*      dl 0x000EEE ; 4F, 111.094, +0.932993
0B1853 C8 0E 00    0986*      dl 0x000EC8 ; 50, 112.500, +0.923880
0B1856 A1 0E 00    0987*      dl 0x000EA1 ; 51, 113.906, +0.914210
0B1859 77 0E 00    0988*      dl 0x000E77 ; 52, 115.312, +0.903989
0B185C 4B 0E 00    0989*      dl 0x000E4B ; 53, 116.719, +0.893224
0B185F 1C 0E 00    0990*      dl 0x000E1C ; 54, 118.125, +0.881921
0B1862 EC 0D 00    0991*      dl 0x000DEC ; 55, 119.531, +0.870087
0B1865 B9 0D 00    0992*      dl 0x000DB9 ; 56, 120.938, +0.857729
0B1868 85 0D 00    0993*      dl 0x000D85 ; 57, 122.344, +0.844854
0B186B 4E 0D 00    0994*      dl 0x000D4E ; 58, 123.750, +0.831470
0B186E 15 0D 00    0995*      dl 0x000D15 ; 59, 125.156, +0.817585
0B1871 DA 0C 00    0996*      dl 0x000CDA ; 5A, 126.562, +0.803208
0B1874 9D 0C 00    0997*      dl 0x000C9D ; 5B, 127.969, +0.788346
0B1877 5E 0C 00    0998*      dl 0x000C5E ; 5C, 129.375, +0.773010
0B187A 1E 0C 00    0999*      dl 0x000C1E ; 5D, 130.781, +0.757209
0B187D DB 0B 00    1000*      dl 0x000BDB ; 5E, 132.188, +0.740951
0B1880 97 0B 00    1001*      dl 0x000B97 ; 5F, 133.594, +0.724247
0B1883 50 0B 00    1002*      dl 0x000B50 ; 60, 135.000, +0.707107
0B1886 08 0B 00    1003*      dl 0x000B08 ; 61, 136.406, +0.689541
0B1889 BF 0A 00    1004*      dl 0x000ABF ; 62, 137.812, +0.671559
0B188C 73 0A 00    1005*      dl 0x000A73 ; 63, 139.219, +0.653173
0B188F 26 0A 00    1006*      dl 0x000A26 ; 64, 140.625, +0.634393
0B1892 D8 09 00    1007*      dl 0x0009D8 ; 65, 142.031, +0.615232
0B1895 88 09 00    1008*      dl 0x000988 ; 66, 143.438, +0.595699
0B1898 37 09 00    1009*      dl 0x000937 ; 67, 144.844, +0.575808
0B189B E4 08 00    1010*      dl 0x0008E4 ; 68, 146.250, +0.555570
0B189E 8F 08 00    1011*      dl 0x00088F ; 69, 147.656, +0.534998
0B18A1 3A 08 00    1012*      dl 0x00083A ; 6A, 149.062, +0.514103
0B18A4 E3 07 00    1013*      dl 0x0007E3 ; 6B, 150.469, +0.492898
0B18A7 8B 07 00    1014*      dl 0x00078B ; 6C, 151.875, +0.471397
0B18AA 32 07 00    1015*      dl 0x000732 ; 6D, 153.281, +0.449611
0B18AD D7 06 00    1016*      dl 0x0006D7 ; 6E, 154.688, +0.427555
0B18B0 7C 06 00    1017*      dl 0x00067C ; 6F, 156.094, +0.405241
0B18B3 1F 06 00    1018*      dl 0x00061F ; 70, 157.500, +0.382683
0B18B6 C2 05 00    1019*      dl 0x0005C2 ; 71, 158.906, +0.359895
0B18B9 64 05 00    1020*      dl 0x000564 ; 72, 160.312, +0.336890
0B18BC 05 05 00    1021*      dl 0x000505 ; 73, 161.719, +0.313682
0B18BF A5 04 00    1022*      dl 0x0004A5 ; 74, 163.125, +0.290285
0B18C2 44 04 00    1023*      dl 0x000444 ; 75, 164.531, +0.266713
0B18C5 E3 03 00    1024*      dl 0x0003E3 ; 76, 165.938, +0.242980
0B18C8 81 03 00    1025*      dl 0x000381 ; 77, 167.344, +0.219101
0B18CB 1F 03 00    1026*      dl 0x00031F ; 78, 168.750, +0.195090
0B18CE BC 02 00    1027*      dl 0x0002BC ; 79, 170.156, +0.170962
0B18D1 59 02 00    1028*      dl 0x000259 ; 7A, 171.562, +0.146730
0B18D4 F5 01 00    1029*      dl 0x0001F5 ; 7B, 172.969, +0.122411
0B18D7 91 01 00    1030*      dl 0x000191 ; 7C, 174.375, +0.098017
0B18DA 2D 01 00    1031*      dl 0x00012D ; 7D, 175.781, +0.073565
0B18DD C9 00 00    1032*      dl 0x0000C9 ; 7E, 177.188, +0.049068
0B18E0 65 00 00    1033*      dl 0x000065 ; 7F, 178.594, +0.024541
0B18E3 00 00 00    1034*      dl 0x000000 ; 80, 180.000, +0.000000
0B18E6 9B FF FF    1035*      dl 0xFFFF9B ; 81, 181.406, -0.024541
0B18E9 37 FF FF    1036*      dl 0xFFFF37 ; 82, 182.812, -0.049068
0B18EC D3 FE FF    1037*      dl 0xFFFED3 ; 83, 184.219, -0.073565
0B18EF 6F FE FF    1038*      dl 0xFFFE6F ; 84, 185.625, -0.098017
0B18F2 0B FE FF    1039*      dl 0xFFFE0B ; 85, 187.031, -0.122411
0B18F5 A7 FD FF    1040*      dl 0xFFFDA7 ; 86, 188.438, -0.146730
0B18F8 44 FD FF    1041*      dl 0xFFFD44 ; 87, 189.844, -0.170962
0B18FB E1 FC FF    1042*      dl 0xFFFCE1 ; 88, 191.250, -0.195090
0B18FE 7F FC FF    1043*      dl 0xFFFC7F ; 89, 192.656, -0.219101
0B1901 1D FC FF    1044*      dl 0xFFFC1D ; 8A, 194.062, -0.242980
0B1904 BC FB FF    1045*      dl 0xFFFBBC ; 8B, 195.469, -0.266713
0B1907 5B FB FF    1046*      dl 0xFFFB5B ; 8C, 196.875, -0.290285
0B190A FB FA FF    1047*      dl 0xFFFAFB ; 8D, 198.281, -0.313682
0B190D 9C FA FF    1048*      dl 0xFFFA9C ; 8E, 199.688, -0.336890
0B1910 3E FA FF    1049*      dl 0xFFFA3E ; 8F, 201.094, -0.359895
0B1913 E1 F9 FF    1050*      dl 0xFFF9E1 ; 90, 202.500, -0.382683
0B1916 84 F9 FF    1051*      dl 0xFFF984 ; 91, 203.906, -0.405241
0B1919 29 F9 FF    1052*      dl 0xFFF929 ; 92, 205.312, -0.427555
0B191C CE F8 FF    1053*      dl 0xFFF8CE ; 93, 206.719, -0.449611
0B191F 75 F8 FF    1054*      dl 0xFFF875 ; 94, 208.125, -0.471397
0B1922 1D F8 FF    1055*      dl 0xFFF81D ; 95, 209.531, -0.492898
0B1925 C6 F7 FF    1056*      dl 0xFFF7C6 ; 96, 210.938, -0.514103
0B1928 71 F7 FF    1057*      dl 0xFFF771 ; 97, 212.344, -0.534998
0B192B 1C F7 FF    1058*      dl 0xFFF71C ; 98, 213.750, -0.555570
0B192E C9 F6 FF    1059*      dl 0xFFF6C9 ; 99, 215.156, -0.575808
0B1931 78 F6 FF    1060*      dl 0xFFF678 ; 9A, 216.562, -0.595699
0B1934 28 F6 FF    1061*      dl 0xFFF628 ; 9B, 217.969, -0.615232
0B1937 DA F5 FF    1062*      dl 0xFFF5DA ; 9C, 219.375, -0.634393
0B193A 8D F5 FF    1063*      dl 0xFFF58D ; 9D, 220.781, -0.653173
0B193D 41 F5 FF    1064*      dl 0xFFF541 ; 9E, 222.188, -0.671559
0B1940 F8 F4 FF    1065*      dl 0xFFF4F8 ; 9F, 223.594, -0.689541
0B1943 B0 F4 FF    1066*      dl 0xFFF4B0 ; A0, 225.000, -0.707107
0B1946 69 F4 FF    1067*      dl 0xFFF469 ; A1, 226.406, -0.724247
0B1949 25 F4 FF    1068*      dl 0xFFF425 ; A2, 227.812, -0.740951
0B194C E2 F3 FF    1069*      dl 0xFFF3E2 ; A3, 229.219, -0.757209
0B194F A2 F3 FF    1070*      dl 0xFFF3A2 ; A4, 230.625, -0.773010
0B1952 63 F3 FF    1071*      dl 0xFFF363 ; A5, 232.031, -0.788346
0B1955 26 F3 FF    1072*      dl 0xFFF326 ; A6, 233.438, -0.803208
0B1958 EB F2 FF    1073*      dl 0xFFF2EB ; A7, 234.844, -0.817585
0B195B B2 F2 FF    1074*      dl 0xFFF2B2 ; A8, 236.250, -0.831470
0B195E 7B F2 FF    1075*      dl 0xFFF27B ; A9, 237.656, -0.844854
0B1961 47 F2 FF    1076*      dl 0xFFF247 ; AA, 239.062, -0.857729
0B1964 14 F2 FF    1077*      dl 0xFFF214 ; AB, 240.469, -0.870087
0B1967 E4 F1 FF    1078*      dl 0xFFF1E4 ; AC, 241.875, -0.881921
0B196A B5 F1 FF    1079*      dl 0xFFF1B5 ; AD, 243.281, -0.893224
0B196D 89 F1 FF    1080*      dl 0xFFF189 ; AE, 244.688, -0.903989
0B1970 5F F1 FF    1081*      dl 0xFFF15F ; AF, 246.094, -0.914210
0B1973 38 F1 FF    1082*      dl 0xFFF138 ; B0, 247.500, -0.923880
0B1976 12 F1 FF    1083*      dl 0xFFF112 ; B1, 248.906, -0.932993
0B1979 EF F0 FF    1084*      dl 0xFFF0EF ; B2, 250.312, -0.941544
0B197C CF F0 FF    1085*      dl 0xFFF0CF ; B3, 251.719, -0.949528
0B197F B0 F0 FF    1086*      dl 0xFFF0B0 ; B4, 253.125, -0.956940
0B1982 94 F0 FF    1087*      dl 0xFFF094 ; B5, 254.531, -0.963776
0B1985 7B F0 FF    1088*      dl 0xFFF07B ; B6, 255.938, -0.970031
0B1988 64 F0 FF    1089*      dl 0xFFF064 ; B7, 257.344, -0.975702
0B198B 4F F0 FF    1090*      dl 0xFFF04F ; B8, 258.750, -0.980785
0B198E 3C F0 FF    1091*      dl 0xFFF03C ; B9, 260.156, -0.985278
0B1991 2C F0 FF    1092*      dl 0xFFF02C ; BA, 261.562, -0.989177
0B1994 1F F0 FF    1093*      dl 0xFFF01F ; BB, 262.969, -0.992480
0B1997 14 F0 FF    1094*      dl 0xFFF014 ; BC, 264.375, -0.995185
0B199A 0B F0 FF    1095*      dl 0xFFF00B ; BD, 265.781, -0.997290
0B199D 05 F0 FF    1096*      dl 0xFFF005 ; BE, 267.188, -0.998795
0B19A0 01 F0 FF    1097*      dl 0xFFF001 ; BF, 268.594, -0.999699
0B19A3 00 F0 FF    1098*      dl 0xFFF000 ; C0, 270.000, -1.000000
0B19A6 01 F0 FF    1099*      dl 0xFFF001 ; C1, 271.406, -0.999699
0B19A9 05 F0 FF    1100*      dl 0xFFF005 ; C2, 272.812, -0.998795
0B19AC 0B F0 FF    1101*      dl 0xFFF00B ; C3, 274.219, -0.997290
0B19AF 14 F0 FF    1102*      dl 0xFFF014 ; C4, 275.625, -0.995185
0B19B2 1F F0 FF    1103*      dl 0xFFF01F ; C5, 277.031, -0.992480
0B19B5 2C F0 FF    1104*      dl 0xFFF02C ; C6, 278.438, -0.989177
0B19B8 3C F0 FF    1105*      dl 0xFFF03C ; C7, 279.844, -0.985278
0B19BB 4F F0 FF    1106*      dl 0xFFF04F ; C8, 281.250, -0.980785
0B19BE 64 F0 FF    1107*      dl 0xFFF064 ; C9, 282.656, -0.975702
0B19C1 7B F0 FF    1108*      dl 0xFFF07B ; CA, 284.062, -0.970031
0B19C4 94 F0 FF    1109*      dl 0xFFF094 ; CB, 285.469, -0.963776
0B19C7 B0 F0 FF    1110*      dl 0xFFF0B0 ; CC, 286.875, -0.956940
0B19CA CF F0 FF    1111*      dl 0xFFF0CF ; CD, 288.281, -0.949528
0B19CD EF F0 FF    1112*      dl 0xFFF0EF ; CE, 289.688, -0.941544
0B19D0 12 F1 FF    1113*      dl 0xFFF112 ; CF, 291.094, -0.932993
0B19D3 38 F1 FF    1114*      dl 0xFFF138 ; D0, 292.500, -0.923880
0B19D6 5F F1 FF    1115*      dl 0xFFF15F ; D1, 293.906, -0.914210
0B19D9 89 F1 FF    1116*      dl 0xFFF189 ; D2, 295.312, -0.903989
0B19DC B5 F1 FF    1117*      dl 0xFFF1B5 ; D3, 296.719, -0.893224
0B19DF E4 F1 FF    1118*      dl 0xFFF1E4 ; D4, 298.125, -0.881921
0B19E2 14 F2 FF    1119*      dl 0xFFF214 ; D5, 299.531, -0.870087
0B19E5 47 F2 FF    1120*      dl 0xFFF247 ; D6, 300.938, -0.857729
0B19E8 7B F2 FF    1121*      dl 0xFFF27B ; D7, 302.344, -0.844854
0B19EB B2 F2 FF    1122*      dl 0xFFF2B2 ; D8, 303.750, -0.831470
0B19EE EB F2 FF    1123*      dl 0xFFF2EB ; D9, 305.156, -0.817585
0B19F1 26 F3 FF    1124*      dl 0xFFF326 ; DA, 306.562, -0.803208
0B19F4 63 F3 FF    1125*      dl 0xFFF363 ; DB, 307.969, -0.788346
0B19F7 A2 F3 FF    1126*      dl 0xFFF3A2 ; DC, 309.375, -0.773010
0B19FA E2 F3 FF    1127*      dl 0xFFF3E2 ; DD, 310.781, -0.757209
0B19FD 25 F4 FF    1128*      dl 0xFFF425 ; DE, 312.188, -0.740951
0B1A00 69 F4 FF    1129*      dl 0xFFF469 ; DF, 313.594, -0.724247
0B1A03 B0 F4 FF    1130*      dl 0xFFF4B0 ; E0, 315.000, -0.707107
0B1A06 F8 F4 FF    1131*      dl 0xFFF4F8 ; E1, 316.406, -0.689541
0B1A09 41 F5 FF    1132*      dl 0xFFF541 ; E2, 317.812, -0.671559
0B1A0C 8D F5 FF    1133*      dl 0xFFF58D ; E3, 319.219, -0.653173
0B1A0F DA F5 FF    1134*      dl 0xFFF5DA ; E4, 320.625, -0.634393
0B1A12 28 F6 FF    1135*      dl 0xFFF628 ; E5, 322.031, -0.615232
0B1A15 78 F6 FF    1136*      dl 0xFFF678 ; E6, 323.438, -0.595699
0B1A18 C9 F6 FF    1137*      dl 0xFFF6C9 ; E7, 324.844, -0.575808
0B1A1B 1C F7 FF    1138*      dl 0xFFF71C ; E8, 326.250, -0.555570
0B1A1E 71 F7 FF    1139*      dl 0xFFF771 ; E9, 327.656, -0.534998
0B1A21 C6 F7 FF    1140*      dl 0xFFF7C6 ; EA, 329.062, -0.514103
0B1A24 1D F8 FF    1141*      dl 0xFFF81D ; EB, 330.469, -0.492898
0B1A27 75 F8 FF    1142*      dl 0xFFF875 ; EC, 331.875, -0.471397
0B1A2A CE F8 FF    1143*      dl 0xFFF8CE ; ED, 333.281, -0.449611
0B1A2D 29 F9 FF    1144*      dl 0xFFF929 ; EE, 334.688, -0.427555
0B1A30 84 F9 FF    1145*      dl 0xFFF984 ; EF, 336.094, -0.405241
0B1A33 E1 F9 FF    1146*      dl 0xFFF9E1 ; F0, 337.500, -0.382683
0B1A36 3E FA FF    1147*      dl 0xFFFA3E ; F1, 338.906, -0.359895
0B1A39 9C FA FF    1148*      dl 0xFFFA9C ; F2, 340.312, -0.336890
0B1A3C FB FA FF    1149*      dl 0xFFFAFB ; F3, 341.719, -0.313682
0B1A3F 5B FB FF    1150*      dl 0xFFFB5B ; F4, 343.125, -0.290285
0B1A42 BC FB FF    1151*      dl 0xFFFBBC ; F5, 344.531, -0.266713
0B1A45 1D FC FF    1152*      dl 0xFFFC1D ; F6, 345.938, -0.242980
0B1A48 7F FC FF    1153*      dl 0xFFFC7F ; F7, 347.344, -0.219101
0B1A4B E1 FC FF    1154*      dl 0xFFFCE1 ; F8, 348.750, -0.195090
0B1A4E 44 FD FF    1155*      dl 0xFFFD44 ; F9, 350.156, -0.170962
0B1A51 A7 FD FF    1156*      dl 0xFFFDA7 ; FA, 351.562, -0.146730
0B1A54 0B FE FF    1157*      dl 0xFFFE0B ; FB, 352.969, -0.122411
0B1A57 6F FE FF    1158*      dl 0xFFFE6F ; FC, 354.375, -0.098017
0B1A5A D3 FE FF    1159*      dl 0xFFFED3 ; FD, 355.781, -0.073565
0B1A5D 37 FF FF    1160*      dl 0xFFFF37 ; FE, 357.188, -0.049068
0B1A60 9B FF FF    1161*      dl 0xFFFF9B ; FF, 358.594, -0.024541
0B1A63             1162*  
0B1A63             1163*  atan_lut_168:
0B1A63 00 00 00    1164*  	dl 0x000000 ; 000000, 0.000
0B1A66 28 00 00    1165*  	dl 0x000028 ; 000001, 0.224
0B1A69 51 00 00    1166*  	dl 0x000051 ; 000002, 0.448
0B1A6C 7A 00 00    1167*  	dl 0x00007A ; 000003, 0.671
0B1A6F A2 00 00    1168*  	dl 0x0000A2 ; 000004, 0.895
0B1A72 CB 00 00    1169*  	dl 0x0000CB ; 000005, 1.119
0B1A75 F4 00 00    1170*  	dl 0x0000F4 ; 000006, 1.343
0B1A78 1D 01 00    1171*  	dl 0x00011D ; 000007, 1.566
0B1A7B 45 01 00    1172*  	dl 0x000145 ; 000008, 1.790
0B1A7E 6E 01 00    1173*  	dl 0x00016E ; 000009, 2.013
0B1A81 97 01 00    1174*  	dl 0x000197 ; 00000A, 2.237
0B1A84 BF 01 00    1175*  	dl 0x0001BF ; 00000B, 2.460
0B1A87 E8 01 00    1176*  	dl 0x0001E8 ; 00000C, 2.684
0B1A8A 11 02 00    1177*  	dl 0x000211 ; 00000D, 2.907
0B1A8D 39 02 00    1178*  	dl 0x000239 ; 00000E, 3.130
0B1A90 62 02 00    1179*  	dl 0x000262 ; 00000F, 3.353
0B1A93 8B 02 00    1180*  	dl 0x00028B ; 000010, 3.576
0B1A96 B3 02 00    1181*  	dl 0x0002B3 ; 000011, 3.799
0B1A99 DC 02 00    1182*  	dl 0x0002DC ; 000012, 4.022
0B1A9C 04 03 00    1183*  	dl 0x000304 ; 000013, 4.245
0B1A9F 2D 03 00    1184*  	dl 0x00032D ; 000014, 4.467
0B1AA2 55 03 00    1185*  	dl 0x000355 ; 000015, 4.690
0B1AA5 7E 03 00    1186*  	dl 0x00037E ; 000016, 4.912
0B1AA8 A6 03 00    1187*  	dl 0x0003A6 ; 000017, 5.134
0B1AAB CE 03 00    1188*  	dl 0x0003CE ; 000018, 5.356
0B1AAE F7 03 00    1189*  	dl 0x0003F7 ; 000019, 5.578
0B1AB1 1F 04 00    1190*  	dl 0x00041F ; 00001A, 5.799
0B1AB4 48 04 00    1191*  	dl 0x000448 ; 00001B, 6.021
0B1AB7 70 04 00    1192*  	dl 0x000470 ; 00001C, 6.242
0B1ABA 98 04 00    1193*  	dl 0x000498 ; 00001D, 6.463
0B1ABD C0 04 00    1194*  	dl 0x0004C0 ; 00001E, 6.684
0B1AC0 E8 04 00    1195*  	dl 0x0004E8 ; 00001F, 6.905
0B1AC3 11 05 00    1196*  	dl 0x000511 ; 000020, 7.125
0B1AC6 39 05 00    1197*  	dl 0x000539 ; 000021, 7.345
0B1AC9 61 05 00    1198*  	dl 0x000561 ; 000022, 7.565
0B1ACC 89 05 00    1199*  	dl 0x000589 ; 000023, 7.785
0B1ACF B1 05 00    1200*  	dl 0x0005B1 ; 000024, 8.005
0B1AD2 D9 05 00    1201*  	dl 0x0005D9 ; 000025, 8.224
0B1AD5 01 06 00    1202*  	dl 0x000601 ; 000026, 8.443
0B1AD8 28 06 00    1203*  	dl 0x000628 ; 000027, 8.662
0B1ADB 50 06 00    1204*  	dl 0x000650 ; 000028, 8.881
0B1ADE 78 06 00    1205*  	dl 0x000678 ; 000029, 9.099
0B1AE1 A0 06 00    1206*  	dl 0x0006A0 ; 00002A, 9.317
0B1AE4 C7 06 00    1207*  	dl 0x0006C7 ; 00002B, 9.535
0B1AE7 EF 06 00    1208*  	dl 0x0006EF ; 00002C, 9.752
0B1AEA 16 07 00    1209*  	dl 0x000716 ; 00002D, 9.970
0B1AED 3E 07 00    1210*  	dl 0x00073E ; 00002E, 10.187
0B1AF0 65 07 00    1211*  	dl 0x000765 ; 00002F, 10.403
0B1AF3 8D 07 00    1212*  	dl 0x00078D ; 000030, 10.620
0B1AF6 B4 07 00    1213*  	dl 0x0007B4 ; 000031, 10.836
0B1AF9 DB 07 00    1214*  	dl 0x0007DB ; 000032, 11.051
0B1AFC 03 08 00    1215*  	dl 0x000803 ; 000033, 11.267
0B1AFF 2A 08 00    1216*  	dl 0x00082A ; 000034, 11.482
0B1B02 51 08 00    1217*  	dl 0x000851 ; 000035, 11.697
0B1B05 78 08 00    1218*  	dl 0x000878 ; 000036, 11.911
0B1B08 9F 08 00    1219*  	dl 0x00089F ; 000037, 12.125
0B1B0B C6 08 00    1220*  	dl 0x0008C6 ; 000038, 12.339
0B1B0E ED 08 00    1221*  	dl 0x0008ED ; 000039, 12.553
0B1B11 13 09 00    1222*  	dl 0x000913 ; 00003A, 12.766
0B1B14 3A 09 00    1223*  	dl 0x00093A ; 00003B, 12.978
0B1B17 61 09 00    1224*  	dl 0x000961 ; 00003C, 13.191
0B1B1A 87 09 00    1225*  	dl 0x000987 ; 00003D, 13.403
0B1B1D AE 09 00    1226*  	dl 0x0009AE ; 00003E, 13.614
0B1B20 D4 09 00    1227*  	dl 0x0009D4 ; 00003F, 13.825
0B1B23 FB 09 00    1228*  	dl 0x0009FB ; 000040, 14.036
0B1B26 21 0A 00    1229*  	dl 0x000A21 ; 000041, 14.247
0B1B29 47 0A 00    1230*  	dl 0x000A47 ; 000042, 14.457
0B1B2C 6D 0A 00    1231*  	dl 0x000A6D ; 000043, 14.666
0B1B2F 94 0A 00    1232*  	dl 0x000A94 ; 000044, 14.876
0B1B32 BA 0A 00    1233*  	dl 0x000ABA ; 000045, 15.085
0B1B35 E0 0A 00    1234*  	dl 0x000AE0 ; 000046, 15.293
0B1B38 05 0B 00    1235*  	dl 0x000B05 ; 000047, 15.501
0B1B3B 2B 0B 00    1236*  	dl 0x000B2B ; 000048, 15.709
0B1B3E 51 0B 00    1237*  	dl 0x000B51 ; 000049, 15.916
0B1B41 77 0B 00    1238*  	dl 0x000B77 ; 00004A, 16.123
0B1B44 9C 0B 00    1239*  	dl 0x000B9C ; 00004B, 16.329
0B1B47 C2 0B 00    1240*  	dl 0x000BC2 ; 00004C, 16.535
0B1B4A E7 0B 00    1241*  	dl 0x000BE7 ; 00004D, 16.740
0B1B4D 0C 0C 00    1242*  	dl 0x000C0C ; 00004E, 16.945
0B1B50 32 0C 00    1243*  	dl 0x000C32 ; 00004F, 17.150
0B1B53 57 0C 00    1244*  	dl 0x000C57 ; 000050, 17.354
0B1B56 7C 0C 00    1245*  	dl 0x000C7C ; 000051, 17.558
0B1B59 A1 0C 00    1246*  	dl 0x000CA1 ; 000052, 17.761
0B1B5C C6 0C 00    1247*  	dl 0x000CC6 ; 000053, 17.964
0B1B5F EB 0C 00    1248*  	dl 0x000CEB ; 000054, 18.166
0B1B62 0F 0D 00    1249*  	dl 0x000D0F ; 000055, 18.368
0B1B65 34 0D 00    1250*  	dl 0x000D34 ; 000056, 18.569
0B1B68 58 0D 00    1251*  	dl 0x000D58 ; 000057, 18.770
0B1B6B 7D 0D 00    1252*  	dl 0x000D7D ; 000058, 18.970
0B1B6E A1 0D 00    1253*  	dl 0x000DA1 ; 000059, 19.170
0B1B71 C6 0D 00    1254*  	dl 0x000DC6 ; 00005A, 19.370
0B1B74 EA 0D 00    1255*  	dl 0x000DEA ; 00005B, 19.569
0B1B77 0E 0E 00    1256*  	dl 0x000E0E ; 00005C, 19.767
0B1B7A 32 0E 00    1257*  	dl 0x000E32 ; 00005D, 19.965
0B1B7D 56 0E 00    1258*  	dl 0x000E56 ; 00005E, 20.163
0B1B80 7A 0E 00    1259*  	dl 0x000E7A ; 00005F, 20.360
0B1B83 9E 0E 00    1260*  	dl 0x000E9E ; 000060, 20.556
0B1B86 C1 0E 00    1261*  	dl 0x000EC1 ; 000061, 20.752
0B1B89 E5 0E 00    1262*  	dl 0x000EE5 ; 000062, 20.947
0B1B8C 08 0F 00    1263*  	dl 0x000F08 ; 000063, 21.142
0B1B8F 2C 0F 00    1264*  	dl 0x000F2C ; 000064, 21.337
0B1B92 4F 0F 00    1265*  	dl 0x000F4F ; 000065, 21.531
0B1B95 72 0F 00    1266*  	dl 0x000F72 ; 000066, 21.724
0B1B98 95 0F 00    1267*  	dl 0x000F95 ; 000067, 21.917
0B1B9B B8 0F 00    1268*  	dl 0x000FB8 ; 000068, 22.109
0B1B9E DB 0F 00    1269*  	dl 0x000FDB ; 000069, 22.301
0B1BA1 FE 0F 00    1270*  	dl 0x000FFE ; 00006A, 22.493
0B1BA4 21 10 00    1271*  	dl 0x001021 ; 00006B, 22.683
0B1BA7 44 10 00    1272*  	dl 0x001044 ; 00006C, 22.874
0B1BAA 66 10 00    1273*  	dl 0x001066 ; 00006D, 23.063
0B1BAD 89 10 00    1274*  	dl 0x001089 ; 00006E, 23.253
0B1BB0 AB 10 00    1275*  	dl 0x0010AB ; 00006F, 23.441
0B1BB3 CD 10 00    1276*  	dl 0x0010CD ; 000070, 23.629
0B1BB6 EF 10 00    1277*  	dl 0x0010EF ; 000071, 23.817
0B1BB9 11 11 00    1278*  	dl 0x001111 ; 000072, 24.004
0B1BBC 33 11 00    1279*  	dl 0x001133 ; 000073, 24.191
0B1BBF 55 11 00    1280*  	dl 0x001155 ; 000074, 24.376
0B1BC2 77 11 00    1281*  	dl 0x001177 ; 000075, 24.562
0B1BC5 99 11 00    1282*  	dl 0x001199 ; 000076, 24.747
0B1BC8 BA 11 00    1283*  	dl 0x0011BA ; 000077, 24.931
0B1BCB DC 11 00    1284*  	dl 0x0011DC ; 000078, 25.115
0B1BCE FD 11 00    1285*  	dl 0x0011FD ; 000079, 25.298
0B1BD1 1E 12 00    1286*  	dl 0x00121E ; 00007A, 25.481
0B1BD4 3F 12 00    1287*  	dl 0x00123F ; 00007B, 25.663
0B1BD7 60 12 00    1288*  	dl 0x001260 ; 00007C, 25.844
0B1BDA 81 12 00    1289*  	dl 0x001281 ; 00007D, 26.025
0B1BDD A2 12 00    1290*  	dl 0x0012A2 ; 00007E, 26.206
0B1BE0 C3 12 00    1291*  	dl 0x0012C3 ; 00007F, 26.386
0B1BE3 E4 12 00    1292*  	dl 0x0012E4 ; 000080, 26.565
0B1BE6 04 13 00    1293*  	dl 0x001304 ; 000081, 26.744
0B1BE9 25 13 00    1294*  	dl 0x001325 ; 000082, 26.922
0B1BEC 45 13 00    1295*  	dl 0x001345 ; 000083, 27.100
0B1BEF 65 13 00    1296*  	dl 0x001365 ; 000084, 27.277
0B1BF2 85 13 00    1297*  	dl 0x001385 ; 000085, 27.453
0B1BF5 A5 13 00    1298*  	dl 0x0013A5 ; 000086, 27.629
0B1BF8 C5 13 00    1299*  	dl 0x0013C5 ; 000087, 27.805
0B1BFB E5 13 00    1300*  	dl 0x0013E5 ; 000088, 27.979
0B1BFE 05 14 00    1301*  	dl 0x001405 ; 000089, 28.154
0B1C01 24 14 00    1302*  	dl 0x001424 ; 00008A, 28.327
0B1C04 44 14 00    1303*  	dl 0x001444 ; 00008B, 28.501
0B1C07 63 14 00    1304*  	dl 0x001463 ; 00008C, 28.673
0B1C0A 83 14 00    1305*  	dl 0x001483 ; 00008D, 28.845
0B1C0D A2 14 00    1306*  	dl 0x0014A2 ; 00008E, 29.017
0B1C10 C1 14 00    1307*  	dl 0x0014C1 ; 00008F, 29.187
0B1C13 E0 14 00    1308*  	dl 0x0014E0 ; 000090, 29.358
0B1C16 FF 14 00    1309*  	dl 0x0014FF ; 000091, 29.527
0B1C19 1E 15 00    1310*  	dl 0x00151E ; 000092, 29.697
0B1C1C 3C 15 00    1311*  	dl 0x00153C ; 000093, 29.865
0B1C1F 5B 15 00    1312*  	dl 0x00155B ; 000094, 30.033
0B1C22 79 15 00    1313*  	dl 0x001579 ; 000095, 30.201
0B1C25 98 15 00    1314*  	dl 0x001598 ; 000096, 30.368
0B1C28 B6 15 00    1315*  	dl 0x0015B6 ; 000097, 30.534
0B1C2B D4 15 00    1316*  	dl 0x0015D4 ; 000098, 30.700
0B1C2E F2 15 00    1317*  	dl 0x0015F2 ; 000099, 30.865
0B1C31 10 16 00    1318*  	dl 0x001610 ; 00009A, 31.030
0B1C34 2E 16 00    1319*  	dl 0x00162E ; 00009B, 31.194
0B1C37 4C 16 00    1320*  	dl 0x00164C ; 00009C, 31.357
0B1C3A 6A 16 00    1321*  	dl 0x00166A ; 00009D, 31.520
0B1C3D 87 16 00    1322*  	dl 0x001687 ; 00009E, 31.682
0B1C40 A5 16 00    1323*  	dl 0x0016A5 ; 00009F, 31.844
0B1C43 C2 16 00    1324*  	dl 0x0016C2 ; 0000A0, 32.005
0B1C46 DF 16 00    1325*  	dl 0x0016DF ; 0000A1, 32.166
0B1C49 FC 16 00    1326*  	dl 0x0016FC ; 0000A2, 32.326
0B1C4C 19 17 00    1327*  	dl 0x001719 ; 0000A3, 32.486
0B1C4F 36 17 00    1328*  	dl 0x001736 ; 0000A4, 32.645
0B1C52 53 17 00    1329*  	dl 0x001753 ; 0000A5, 32.803
0B1C55 70 17 00    1330*  	dl 0x001770 ; 0000A6, 32.961
0B1C58 8C 17 00    1331*  	dl 0x00178C ; 0000A7, 33.118
0B1C5B A9 17 00    1332*  	dl 0x0017A9 ; 0000A8, 33.275
0B1C5E C5 17 00    1333*  	dl 0x0017C5 ; 0000A9, 33.431
0B1C61 E2 17 00    1334*  	dl 0x0017E2 ; 0000AA, 33.587
0B1C64 FE 17 00    1335*  	dl 0x0017FE ; 0000AB, 33.742
0B1C67 1A 18 00    1336*  	dl 0x00181A ; 0000AC, 33.896
0B1C6A 36 18 00    1337*  	dl 0x001836 ; 0000AD, 34.050
0B1C6D 52 18 00    1338*  	dl 0x001852 ; 0000AE, 34.203
0B1C70 6E 18 00    1339*  	dl 0x00186E ; 0000AF, 34.356
0B1C73 8A 18 00    1340*  	dl 0x00188A ; 0000B0, 34.509
0B1C76 A5 18 00    1341*  	dl 0x0018A5 ; 0000B1, 34.660
0B1C79 C1 18 00    1342*  	dl 0x0018C1 ; 0000B2, 34.811
0B1C7C DC 18 00    1343*  	dl 0x0018DC ; 0000B3, 34.962
0B1C7F F7 18 00    1344*  	dl 0x0018F7 ; 0000B4, 35.112
0B1C82 13 19 00    1345*  	dl 0x001913 ; 0000B5, 35.262
0B1C85 2E 19 00    1346*  	dl 0x00192E ; 0000B6, 35.410
0B1C88 49 19 00    1347*  	dl 0x001949 ; 0000B7, 35.559
0B1C8B 64 19 00    1348*  	dl 0x001964 ; 0000B8, 35.707
0B1C8E 7F 19 00    1349*  	dl 0x00197F ; 0000B9, 35.854
0B1C91 99 19 00    1350*  	dl 0x001999 ; 0000BA, 36.001
0B1C94 B4 19 00    1351*  	dl 0x0019B4 ; 0000BB, 36.147
0B1C97 CE 19 00    1352*  	dl 0x0019CE ; 0000BC, 36.293
0B1C9A E9 19 00    1353*  	dl 0x0019E9 ; 0000BD, 36.438
0B1C9D 03 1A 00    1354*  	dl 0x001A03 ; 0000BE, 36.582
0B1CA0 1D 1A 00    1355*  	dl 0x001A1D ; 0000BF, 36.726
0B1CA3 37 1A 00    1356*  	dl 0x001A37 ; 0000C0, 36.870
0B1CA6 51 1A 00    1357*  	dl 0x001A51 ; 0000C1, 37.013
0B1CA9 6B 1A 00    1358*  	dl 0x001A6B ; 0000C2, 37.155
0B1CAC 85 1A 00    1359*  	dl 0x001A85 ; 0000C3, 37.297
0B1CAF 9F 1A 00    1360*  	dl 0x001A9F ; 0000C4, 37.439
0B1CB2 B9 1A 00    1361*  	dl 0x001AB9 ; 0000C5, 37.579
0B1CB5 D2 1A 00    1362*  	dl 0x001AD2 ; 0000C6, 37.720
0B1CB8 EC 1A 00    1363*  	dl 0x001AEC ; 0000C7, 37.859
0B1CBB 05 1B 00    1364*  	dl 0x001B05 ; 0000C8, 37.999
0B1CBE 1E 1B 00    1365*  	dl 0x001B1E ; 0000C9, 38.137
0B1CC1 37 1B 00    1366*  	dl 0x001B37 ; 0000CA, 38.276
0B1CC4 50 1B 00    1367*  	dl 0x001B50 ; 0000CB, 38.413
0B1CC7 69 1B 00    1368*  	dl 0x001B69 ; 0000CC, 38.550
0B1CCA 82 1B 00    1369*  	dl 0x001B82 ; 0000CD, 38.687
0B1CCD 9B 1B 00    1370*  	dl 0x001B9B ; 0000CE, 38.823
0B1CD0 B4 1B 00    1371*  	dl 0x001BB4 ; 0000CF, 38.959
0B1CD3 CC 1B 00    1372*  	dl 0x001BCC ; 0000D0, 39.094
0B1CD6 E5 1B 00    1373*  	dl 0x001BE5 ; 0000D1, 39.228
0B1CD9 FD 1B 00    1374*  	dl 0x001BFD ; 0000D2, 39.362
0B1CDC 16 1C 00    1375*  	dl 0x001C16 ; 0000D3, 39.496
0B1CDF 2E 1C 00    1376*  	dl 0x001C2E ; 0000D4, 39.629
0B1CE2 46 1C 00    1377*  	dl 0x001C46 ; 0000D5, 39.762
0B1CE5 5E 1C 00    1378*  	dl 0x001C5E ; 0000D6, 39.894
0B1CE8 76 1C 00    1379*  	dl 0x001C76 ; 0000D7, 40.025
0B1CEB 8E 1C 00    1380*  	dl 0x001C8E ; 0000D8, 40.156
0B1CEE A5 1C 00    1381*  	dl 0x001CA5 ; 0000D9, 40.286
0B1CF1 BD 1C 00    1382*  	dl 0x001CBD ; 0000DA, 40.416
0B1CF4 D5 1C 00    1383*  	dl 0x001CD5 ; 0000DB, 40.546
0B1CF7 EC 1C 00    1384*  	dl 0x001CEC ; 0000DC, 40.675
0B1CFA 04 1D 00    1385*  	dl 0x001D04 ; 0000DD, 40.803
0B1CFD 1B 1D 00    1386*  	dl 0x001D1B ; 0000DE, 40.931
0B1D00 32 1D 00    1387*  	dl 0x001D32 ; 0000DF, 41.059
0B1D03 49 1D 00    1388*  	dl 0x001D49 ; 0000E0, 41.186
0B1D06 60 1D 00    1389*  	dl 0x001D60 ; 0000E1, 41.312
0B1D09 77 1D 00    1390*  	dl 0x001D77 ; 0000E2, 41.438
0B1D0C 8E 1D 00    1391*  	dl 0x001D8E ; 0000E3, 41.564
0B1D0F A5 1D 00    1392*  	dl 0x001DA5 ; 0000E4, 41.689
0B1D12 BB 1D 00    1393*  	dl 0x001DBB ; 0000E5, 41.814
0B1D15 D2 1D 00    1394*  	dl 0x001DD2 ; 0000E6, 41.938
0B1D18 E9 1D 00    1395*  	dl 0x001DE9 ; 0000E7, 42.061
0B1D1B FF 1D 00    1396*  	dl 0x001DFF ; 0000E8, 42.184
0B1D1E 15 1E 00    1397*  	dl 0x001E15 ; 0000E9, 42.307
0B1D21 2C 1E 00    1398*  	dl 0x001E2C ; 0000EA, 42.429
0B1D24 42 1E 00    1399*  	dl 0x001E42 ; 0000EB, 42.551
0B1D27 58 1E 00    1400*  	dl 0x001E58 ; 0000EC, 42.672
0B1D2A 6E 1E 00    1401*  	dl 0x001E6E ; 0000ED, 42.793
0B1D2D 84 1E 00    1402*  	dl 0x001E84 ; 0000EE, 42.913
0B1D30 99 1E 00    1403*  	dl 0x001E99 ; 0000EF, 43.033
0B1D33 AF 1E 00    1404*  	dl 0x001EAF ; 0000F0, 43.152
0B1D36 C5 1E 00    1405*  	dl 0x001EC5 ; 0000F1, 43.271
0B1D39 DA 1E 00    1406*  	dl 0x001EDA ; 0000F2, 43.390
0B1D3C F0 1E 00    1407*  	dl 0x001EF0 ; 0000F3, 43.508
0B1D3F 05 1F 00    1408*  	dl 0x001F05 ; 0000F4, 43.625
0B1D42 1B 1F 00    1409*  	dl 0x001F1B ; 0000F5, 43.742
0B1D45 30 1F 00    1410*  	dl 0x001F30 ; 0000F6, 43.859
0B1D48 45 1F 00    1411*  	dl 0x001F45 ; 0000F7, 43.975
0B1D4B 5A 1F 00    1412*  	dl 0x001F5A ; 0000F8, 44.091
0B1D4E 6F 1F 00    1413*  	dl 0x001F6F ; 0000F9, 44.206
0B1D51 84 1F 00    1414*  	dl 0x001F84 ; 0000FA, 44.321
0B1D54 99 1F 00    1415*  	dl 0x001F99 ; 0000FB, 44.435
0B1D57 AD 1F 00    1416*  	dl 0x001FAD ; 0000FC, 44.549
0B1D5A C2 1F 00    1417*  	dl 0x001FC2 ; 0000FD, 44.662
0B1D5D D7 1F 00    1418*  	dl 0x001FD7 ; 0000FE, 44.775
0B1D60 EB 1F 00    1419*  	dl 0x001FEB ; 0000FF, 44.888
0B1D63 00 20 00    1420*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B1D66             0024       include "files.inc"
0B1D66             0001*  ; load to onboard 8k sram
0B1D66             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B1D66             0025       include "timer.inc"
0B1D66             0001*  ; Table 32. Timer Control Registers
0B1D66             0002*  ; this constant is the base address of the timer control registers
0B1D66             0003*  ; each timer takes three bytes:
0B1D66             0004*  ;   0: control register
0B1D66             0005*  ;   1: low byte of timer reset value
0B1D66             0006*  ;   2: high byte of timer reset value
0B1D66             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B1D66             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B1D66             0009*  TMR_CTL:     equ 80h
0B1D66             0010*  
0B1D66             0011*  ; Timer Control Register Bit Definitions
0B1D66             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B1D66             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B1D66             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B1D66             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B1D66             0016*                              ; the TMRx_CTL register is read.
0B1D66             0017*  
0B1D66             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B1D66             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B1D66             0020*  
0B1D66             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B1D66             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B1D66             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B1D66             0024*                              ; written to the counter when the end-of-count value is reached.
0B1D66             0025*  
0B1D66             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B1D66             0027*  CLK_DIV_256:  equ %00001100 ;
0B1D66             0028*  CLK_DIV_64:   equ %00001000 ;
0B1D66             0029*  CLK_DIV_16:   equ %00000100 ;
0B1D66             0030*  CLK_DIV_4:    equ %00000000 ;
0B1D66             0031*  
0B1D66             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B1D66             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B1D66             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B1D66             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B1D66             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B1D66             0037*                              ; SINGLE-PASS mode is used.
0B1D66             0038*  
0B1D66             0039*  ; disable/enable the programmable reload timer
0B1D66             0040*  PRT_EN_0:     equ %00000000 ;
0B1D66             0041*  PRT_EN_1:     equ %00000001 ;
0B1D66             0042*  
0B1D66             0043*  ; Table 37. Timer Input Source Select Register
0B1D66             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B1D66             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B1D66             0046*  ;   00: System clock / CLK_DIV
0B1D66             0047*  ;   01: RTC / CLK_DIV
0B1D66             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B1D66             0049*  ;   10: GPIO port B pin 1.
0B1D66             0050*  ;   11: GPIO port B pin 1.
0B1D66             0051*  TMR_ISS:   equ 92h ; register address
0B1D66             0052*  
0B1D66             0053*  ; Table 51. Real-Time Clock Control Register
0B1D66             0054*  RTC_CTRL: equ EDh ; register address
0B1D66             0055*  
0B1D66             0056*  ; alarm interrupt disable/enable
0B1D66             0057*  RTC_ALARM_0:    equ %00000000
0B1D66             0058*  RTC_ALARM_1:    equ %10000000
0B1D66             0059*  
0B1D66             0060*  ; interrupt on alarm disable/enable
0B1D66             0061*  RTC_INT_ENT_0:  equ %00000000
0B1D66             0062*  RTC_INT_ENT_1:  equ %01000000
0B1D66             0063*  
0B1D66             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B1D66             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B1D66             0066*  
0B1D66             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B1D66             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B1D66             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B1D66             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B1D66             0071*  
0B1D66             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B1D66             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B1D66             0074*  
0B1D66             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B1D66             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B1D66             0077*  
0B1D66             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B1D66             0079*                                  ; RTC counter is enabled.
0B1D66             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B1D66             0081*                                  ; RTC counter is disabled.
0B1D66             0082*  
0B1D66             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B1D66             0084*  
0B1D66             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B1D66             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B1D66 00 00 00    0087*  prt_reload: dl 0x000000
0B1D69             0088*  
0B1D69             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B1D69             0090*  ; ;          de = number PRT interrupts during test interval
0B1D69             0091*  ; prt_calibrate:
0B1D69             0092*  ;     call vdu_vblank
0B1D69             0093*  ; ; set a MOS timer
0B1D69             0094*  ;     ld hl,120*1 ; 1 second
0B1D69             0095*  ;     ld iy,tmr_test
0B1D69             0096*  ;     call tmr_set
0B1D69             0097*  ; ; set a PRT timer
0B1D69             0098*  ;     ; ld hl,prt_reload_hardware
0B1D69             0099*  ;     ; ld hl,prt_reload_emulator
0B1D69             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B1D69             0101*  ;     ld (prt_reload),hl
0B1D69             0102*  ;     call prt_set
0B1D69             0103*  ; @loop:
0B1D69             0104*  ; ; check time remaining on MOS timer
0B1D69             0105*  ;     call tmr_get
0B1D69             0106*  ;     jp z,@done ; time expired,so quit
0B1D69             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B1D69             0108*  ;     jr @loop
0B1D69             0109*  ; @done:
0B1D69             0110*  ;     ld de,(prt_irq_counter)
0B1D69             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B1D69             0112*  ;     ld (prt_reload),bc
0B1D69             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B1D69             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B1D69             0115*  ;     ld (is_emulator),a
0B1D69             0116*  ;     sbc hl,de
0B1D69             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B1D69             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B1D69             0119*  ;     ret m ; negative result means we're on hardware
0B1D69             0120*  ;     inc a ; we're on emulator
0B1D69             0121*  ;     ld (is_emulator),a
0B1D69             0122*  ;     ld bc,prt_reload_emulator
0B1D69             0123*  ;     ld (prt_reload),bc
0B1D69             0124*  ;     ld hl,on_emulator
0B1D69             0125*  ;     ret
0B1D69             0126*  
0B1D69             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B1D69             0128*  
0B1D69             0129*  ; set PRT timer
0B1D69             0130*  prt_set:
0B1D69 21 00 00 00 0131*      ld hl,0
0B1D6D 22 B7 1D 0B 0132*      ld (prt_irq_counter),hl
0B1D71 2A 66 1D 0B 0133*      ld hl,(prt_reload)
0B1D75 ED 29 84    0134*      out0 ($84),l
0B1D78 ED 21 85    0135*  	out0 ($85),h
0B1D7B             0136*  ; disable timer
0B1D7B 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B1D7D ED 39 83    0138*  	out0 ($83),a
0B1D80             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B1D80 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B1D82 ED 39 83    0141*  	out0 ($83),a
0B1D85 C9          0142*      ret
0B1D86             0143*  
0B1D86             0144*  ; ===============================================
0B1D86             0145*  ; PRT Timer Interrupt Handling
0B1D86             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B1D86             0147*  ; -----------------------------------------------
0B1D86             0148*  prt_irq_init:
0B1D86             0149*      ; set up interrupt vector table 2
0B1D86 21 00 00 00 0150*  	ld hl,0
0B1D8A 3A 0C 01 00 0151*  	ld a,($10c)
0B1D8E 6F          0152*  	ld l,a
0B1D8F 3A 0D 01 00 0153*  	ld a,($10d)
0B1D93 67          0154*  	ld h,a
0B1D94             0155*  
0B1D94             0156*  	; skip over CALL ($c3)
0B1D94 23          0157*  	inc hl
0B1D95             0158*  	; load address of jump into vector table 2 (in ram)
0B1D95 ED 27       0159*  	ld hl,(hl)
0B1D97             0160*  
0B1D97             0161*  	; write CALL prt_irq_handler to vector table 2
0B1D97 3E C3       0162*  	ld a,$c3
0B1D99 77          0163*  	ld (hl),a
0B1D9A 23          0164*  	inc hl
0B1D9B 11 A2 1D 0B 0165*  	ld de,prt_irq_handler
0B1D9F ED 1F       0166*  	ld (hl),de
0B1DA1             0167*  
0B1DA1 C9          0168*      ret
0B1DA2             0169*  
0B1DA2             0170*  prt_irq_handler:
0B1DA2 F3          0171*  	di
0B1DA3 F5          0172*  	push af
0B1DA4 E5          0173*      push hl
0B1DA5 ED 38 83    0174*  	in0 a,($83)
0B1DA8 2A B7 1D 0B 0175*  	ld hl,(prt_irq_counter)
0B1DAC 23          0176*  	inc hl
0B1DAD 22 B7 1D 0B 0177*  	ld (prt_irq_counter),hl
0B1DB1 E1          0178*      pop hl
0B1DB2 F1          0179*  	pop af
0B1DB3 FB          0180*  	ei
0B1DB4 5B ED 4D    0181*  	reti.l
0B1DB7             0182*  
0B1DB7             0183*  prt_irq_counter:
0B1DB7 00 00 00    0184*  	.dl 0
0B1DBA             0185*  prt_irq_counter_saved:
0B1DBA 00 00 00    0186*      .dl 0
0B1DBD             0187*  
0B1DBD             0188*  prt_loop_reset:
0B1DBD E5          0189*      push hl
0B1DBE 21 00 00 00 0190*  	ld hl,0
0B1DC2 22 B7 1D 0B 0191*  	ld (prt_irq_counter),hl
0B1DC6 22 28 1E 0B 0192*      ld (prt_loop_counter),hl
0B1DCA 22 2B 1E 0B 0193*      ld (prt_loops),hl
0B1DCE CD 69 1D 0B 0194*      call prt_set
0B1DD2 E1          0195*      pop hl
0B1DD3 C9          0196*      ret
0B1DD4             0197*  
0B1DD4             0198*  prt_loop_start:
0B1DD4 E5          0199*      push hl
0B1DD5 21 00 00 00 0200*  	ld hl,0
0B1DD9 22 B7 1D 0B 0201*  	ld (prt_irq_counter),hl
0B1DDD E1          0202*      pop hl
0B1DDE C9          0203*      ret
0B1DDF             0204*  
0B1DDF             0205*  prt_loop_stop:
0B1DDF E5          0206*      push hl
0B1DE0 D5          0207*      push de
0B1DE1 2A B7 1D 0B 0208*      ld hl,(prt_irq_counter)
0B1DE5 ED 5B 28 1E 0209*      ld de,(prt_loop_counter)
       0B          
0B1DEA 19          0210*      add hl,de
0B1DEB 22 28 1E 0B 0211*      ld (prt_loop_counter),hl
0B1DEF 21 00 00 00 0212*      ld hl,0
0B1DF3 22 B7 1D 0B 0213*      ld (prt_irq_counter),hl
0B1DF7 2A 2B 1E 0B 0214*      ld hl,(prt_loops)
0B1DFB 23          0215*      inc hl
0B1DFC 22 2B 1E 0B 0216*      ld (prt_loops),hl
0B1E00 D1          0217*      pop de
0B1E01 E1          0218*      pop hl
0B1E02 C9          0219*      ret
0B1E03             0220*  
0B1E03             0221*  ; inputs: bc = y,x text coordinates to print
0B1E03             0222*  prt_loop_print:
0B1E03 F5          0223*      push af
0B1E04 E5          0224*      push hl
0B1E05 C5          0225*      push bc
0B1E06 D5          0226*      push de
0B1E07 DD E5       0227*      push ix
0B1E09 FD E5       0228*      push iy
0B1E0B CD 20 1F 0B 0229*      call vdu_move_cursor
0B1E0F             0230*  
0B1E0F 2A 28 1E 0B 0231*      ld hl,(prt_loop_counter)
0B1E13 CD 2B 03 0B 0232*      call printDec
0B1E17             0233*  
0B1E17 2A 2B 1E 0B 0234*      ld hl,(prt_loops)
0B1E1B CD 2B 03 0B 0235*      call printDec
0B1E1F             0236*  
0B1E1F FD E1       0237*      pop iy
0B1E21 DD E1       0238*      pop ix
0B1E23 D1          0239*      pop de
0B1E24 C1          0240*      pop bc
0B1E25 E1          0241*      pop hl
0B1E26 F1          0242*      pop af
0B1E27 C9          0243*      ret
0B1E28             0244*  
0B1E28             0245*  prt_loop_counter:
0B1E28 00 00 00    0246*      .dl 0
0B1E2B             0247*  prt_loops:
0B1E2B 00 00 00    0248*      .dl 0
0B1E2E             0249*  
0B1E2E             0250*  ; ===============================================
0B1E2E             0251*  ; Timer functions
0B1E2E             0252*  ; -----------------------------------------------
0B1E2E             0253*  ; set a countdown timer
0B1E2E             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1E2E             0255*  ; returns: hl = current time
0B1E2E             0256*  tmr_set:
0B1E2E FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B1E31             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1E31 3E 08       0001*M 			LD	A, function
0B1E33 5B CF       0002*M 			RST.L	08h
0B1E35 DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B1E38 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B1E3B C9          0261*      ret
0B1E3C             0262*  
0B1E3C             0263*  ; gets time remaining on a countdown timer
0B1E3C             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1E3C             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1E3C             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1E3C             0267*  tmr_get:
0B1E3C             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1E3C 3E 08       0001*M 			LD	A, function
0B1E3E 5B CF       0002*M 			RST.L	08h
0B1E40 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B1E43 FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B1E46 AF          0271*      xor a                   ; clear carry
0B1E47 ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1E49 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B1E4C AF          0274*      xor a                   ; clear carry
0B1E4D ED 5A       0275*      adc hl,de               ; hl = time remaining
0B1E4F             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1E4F C9          0277*      ret
0B1E50             0278*  
0B1E50 00 00 00    0279*  timestamp_now: dl 0
0B1E53 00 00 00    0280*  timestamp_old: dl 0
0B1E56 00 00 00    0281*  timestamp_chg: dl 0
0B1E59             0282*  
0B1E59             0283*  ; update the global timestamp from the system clock
0B1E59             0284*  ; inputs: none
0B1E59             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B1E59             0286*  ;          de = current time
0B1E59             0287*  ;          ix = pointer to syvars table
0B1E59             0288*  ; destroys: af,hl,de,ix
0B1E59             0289*  timestamp_tick:
0B1E59 ED 5B 50 1E 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B1E5E ED 53 53 1E 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B1E63             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1E63 3E 08       0001*M 			LD	A, function
0B1E65 5B CF       0002*M 			RST.L	08h
0B1E67 DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B1E6A 22 50 1E 0B 0294*      ld (timestamp_now),hl   ; save current time
0B1E6E AF          0295*      xor a                   ; clear carry
0B1E6F ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B1E71 22 56 1E 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B1E75 C9          0298*      ret
0B1E76             0299*  
0B1E76             0300*  ; set a countdown timer
0B1E76             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1E76             0302*  ; requires: timestamp_tick to be called at least once before this function
0B1E76             0303*  ; returns: hl = current time
0B1E76             0304*  ; destroys: hl
0B1E76             0305*  timestamp_tmr_set:
0B1E76 FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B1E79 2A 50 1E 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B1E7D FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B1E80 C9          0309*      ret
0B1E81             0310*  
0B1E81             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B1E81             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B1E81             0313*  ; requires: timestamp_tick to be called at least once before this function
0B1E81             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1E81             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1E81             0316*  ; destroys: af,hl,de
0B1E81             0317*  timestamp_tmr_get:
0B1E81 ED 5B 50 1E 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B1E86 FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B1E89 AF          0320*      xor a                   ; clear carry
0B1E8A ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B1E8C FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B1E8F AF          0323*      xor a                   ; clear carry
0B1E90 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B1E92             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B1E92 C9          0326*      ret
0B1E93             0327*  
0B1E93             0328*  ; main loop timer functions
0B1E93             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B1E99             0330*  
0B1E99             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B1E99             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B1E99             0333*  ; returns: hl = current time
0B1E99             0334*  ; destroys: af,hl,de,ix,iy
0B1E99             0335*  tmr_main_loop_set:
0B1E99 FD 21 93 1E 0336*      ld iy,tmr_main_loop
       0B          
0B1E9E FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B1EA1 CD 59 1E 0B 0338*      call timestamp_tick
0B1EA5 2A 50 1E 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B1EA9 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B1EAC C9          0341*      ret
0B1EAD             0342*  
0B1EAD             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B1EAD             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B1EAD             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B1EAD             0346*  ; destroys: af,hl,de,ix,iy
0B1EAD             0347*  tmr_main_loop_get:
0B1EAD CD 59 1E 0B 0348*      call timestamp_tick
0B1EB1 FD 21 93 1E 0349*      ld iy,tmr_main_loop
       0B          
0B1EB6 CD 81 1E 0B 0350*      call timestamp_tmr_get
0B1EBA C9          0351*      ret
0B1EBB             0352*  
0B1EBB             0353*  ; set a stopwatch
0B1EBB             0354*  ; returns: hl = start time
0B1EBB             0355*  ; destroys: hl,ix
0B1EBB             0356*  stopwatch_set:
0B1EBB             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1EBB 3E 08       0001*M 			LD	A, function
0B1EBD 5B CF       0002*M 			RST.L	08h
0B1EBF DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B1EC2 22 D7 1E 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B1EC6 C9          0360*      ret
0B1EC7             0361*  
0B1EC7             0362*  ; gets time elapsed on a stopwatch
0B1EC7             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B1EC7             0364*  ; destroys: af,hl,de,ix
0B1EC7             0365*  stopwatch_get:
0B1EC7             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B1EC7 3E 08       0001*M 			LD	A, function
0B1EC9 5B CF       0002*M 			RST.L	08h
0B1ECB DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B1ECE ED 5B D7 1E 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B1ED3 AF          0369*      xor a                   ; clear carry
0B1ED4 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B1ED6 C9          0371*      ret
0B1ED7             0372*  
0B1ED7             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B1EDA             0374*  
0B1EDA             0375*  ; ------------------
0B1EDA             0376*  ; delay routine
0B1EDA             0377*  ; Author: Richard Turrnidge
0B1EDA             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B1EDA             0379*  ; routine waits a fixed time,then returns
0B1EDA             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B1EDA             0381*  ; eg. ld A,00000100b
0B1EDA             0382*  
0B1EDA             0383*  multiPurposeDelay:
0B1EDA F5          0384*      push af
0B1EDB C5          0385*      push bc
0B1EDC DD E5       0386*      push ix
0B1EDE 47          0387*      ld b,a
0B1EDF 3E 08       0388*      ld a,$08
0B1EE1 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B1EE3             0390*  
0B1EE3             0391*  waitLoop:
0B1EE3             0392*  
0B1EE3 DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B1EE6             0394*  
0B1EE6             0395*                                  ;   we check if bit set is same as last time we checked.
0B1EE6             0396*                                  ;   bit 0 - don't use
0B1EE6             0397*                                  ;   bit 1 - changes 64 times per second
0B1EE6             0398*                                  ;   bit 2 - changes 32 times per second
0B1EE6             0399*                                  ;   bit 3 - changes 16 times per second
0B1EE6             0400*  
0B1EE6             0401*                                  ;   bit 4 - changes 8 times per second
0B1EE6             0402*                                  ;   bit 5 - changes 4 times per second
0B1EE6             0403*                                  ;   bit 6 - changes 2 times per second
0B1EE6             0404*                                  ;   bit 7 - changes 1 times per second
0B1EE6 A0          0405*      and b
0B1EE7 4F          0406*      ld c,a
0B1EE8 3A F9 1E 0B 0407*      ld a,(oldTimeStamp)
0B1EEC B9          0408*      cp c                        ; is A same as last value?
0B1EED 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B1EEF 79          0410*      ld a,c
0B1EF0 32 F9 1E 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B1EF4             0412*  
0B1EF4 DD E1       0413*      pop ix
0B1EF6 C1          0414*      pop bc
0B1EF7 F1          0415*      pop af
0B1EF8 C9          0416*      ret
0B1EF9             0417*  
0B1EF9 00          0418*  oldTimeStamp:   .db 00h
0B1EFA             0026       include "vdu.inc"
0B1EFA             0001*  
0B1EFA             0002*  ; VDU 30: Home cursor
0B1EFA             0003*  vdu_home_cursor:
0B1EFA 3E 1E       0004*      ld a,30
0B1EFC 5B D7       0005*  	rst.lil $10
0B1EFE C9          0006*  	ret
0B1EFF             0007*  
0B1EFF             0008*  cursor_on:
0B1EFF 21 0A 1F 0B 0009*  	ld hl,@cmd
0B1F03 01 03 00 00 0010*  	ld bc,@end-@cmd
0B1F07 5B DF       0011*  	rst.lil $18
0B1F09 C9          0012*  	ret
0B1F0A             0013*  @cmd:
0B1F0A 17 01 01    0014*  	db 23,1,1
0B1F0D             0015*  @end:
0B1F0D             0016*  
0B1F0D             0017*  cursor_off:
0B1F0D 21 18 1F 0B 0018*  	ld hl,@cmd
0B1F11 01 03 00 00 0019*  	ld bc,@end-@cmd
0B1F15 5B DF       0020*  	rst.lil $18
0B1F17 C9          0021*  	ret
0B1F18             0022*  @cmd:
0B1F18 17 01 00    0023*  	db 23,1,0
0B1F1B             0024*  @end:
0B1F1B             0025*  
0B1F1B             0026*  ; VDU 9: Move cursor forward one character
0B1F1B             0027*  vdu_cursor_forward:
0B1F1B 3E 09       0028*      ld a,9
0B1F1D 5B D7       0029*  	rst.lil $10
0B1F1F C9          0030*  	ret
0B1F20             0031*  
0B1F20             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B1F20             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B1F20             0034*  vdu_move_cursor:
0B1F20 ED 43 31 1F 0035*      ld (@x0),bc
       0B          
0B1F25 21 30 1F 0B 0036*  	ld hl,@cmd
0B1F29 01 03 00 00 0037*  	ld bc,@end-@cmd
0B1F2D 5B DF       0038*  	rst.lil $18
0B1F2F C9          0039*  	ret
0B1F30 1F          0040*  @cmd: 	db 31
0B1F31 00          0041*  @x0:	db 0
0B1F32 00          0042*  @y0: 	db 0
0B1F33 00          0043*  @end: 	db 0 ; padding
0B1F34             0044*  
0B1F34             0045*  ; VDU 12: Clear text area (CLS)
0B1F34             0046*  vdu_cls:
0B1F34 3E 0C       0047*      ld a,12
0B1F36 5B D7       0048*  	rst.lil $10
0B1F38 C9          0049*  	ret
0B1F39             0050*  
0B1F39             0051*  vdu_flip:
0B1F39 21 44 1F 0B 0052*  	ld hl,@cmd
0B1F3D 01 03 00 00 0053*  	ld bc,@end-@cmd
0B1F41 5B DF       0054*  	rst.lil $18
0B1F43 C9          0055*  	ret
0B1F44 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B1F47             0057*  @end:
0B1F47             0058*  
0B1F47             0059*  ; VDU 16: Clear graphics area (CLG)
0B1F47             0060*  vdu_clg:
0B1F47 3E 10       0061*      ld a,16
0B1F49 5B D7       0062*  	rst.lil $10
0B1F4B C9          0063*  	ret
0B1F4C             0064*  
0B1F4C             0065*  ; COLOUR MODES
0B1F4C             0066*  ; Mode	Effect
0B1F4C             0067*  ; 0	Set on-screen pixel to target colour value
0B1F4C             0068*  ; 1	OR value with the on-screen pixel
0B1F4C             0069*  ; 2	AND value with the on-screen pixel
0B1F4C             0070*  ; 3	XOR value with the on-screen pixel
0B1F4C             0071*  ; 4	Invert the on-screen pixel
0B1F4C             0072*  ; 5	No operation
0B1F4C             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B1F4C             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B1F4C             0075*  
0B1F4C             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B1F4C             0077*  vdu_colour_text:
0B1F4C 32 5C 1F 0B 0078*  	ld (@arg),a
0B1F50 21 5B 1F 0B 0079*  	ld hl,@cmd
0B1F54 01 02 00 00 0080*  	ld bc,@end-@cmd
0B1F58 5B DF       0081*  	rst.lil $18
0B1F5A C9          0082*  	ret
0B1F5B 11          0083*  @cmd: db 17
0B1F5C 00          0084*  @arg: db 0
0B1F5D             0085*  @end:
0B1F5D             0086*  
0B1F5D             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B1F5D             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B1F5D             0089*  vdu_gcol:
0B1F5D 32 72 1F 0B 0090*  	ld (@mode),a
0B1F61 79          0091*      ld a,c
0B1F62 32 73 1F 0B 0092*      ld (@col),a
0B1F66 21 71 1F 0B 0093*  	ld hl,@cmd
0B1F6A 01 03 00 00 0094*  	ld bc,@end-@cmd
0B1F6E 5B DF       0095*  	rst.lil $18
0B1F70 C9          0096*  	ret
0B1F71 12          0097*  @cmd:  db 18
0B1F72 00          0098*  @mode: db 0
0B1F73 00          0099*  @col:  db 0
0B1F74             0100*  @end:
0B1F74             0101*  
0B1F74             0102*  
0B1F74             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B1F74             0104*  ; MIND THE LITTLE-ENDIANESS
0B1F74             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B1F74             0106*  ; outputs; nothing
0B1F74             0107*  ; destroys: a might make it out alive
0B1F74             0108*  vdu_set_txt_viewport:
0B1F74 ED 43 8A 1F 0109*      ld (@lb),bc
       0B          
0B1F79 ED 53 8C 1F 0110*  	ld (@rt),de
       0B          
0B1F7E 21 89 1F 0B 0111*  	ld hl,@cmd
0B1F82 01 05 00 00 0112*  	ld bc,@end-@cmd
0B1F86 5B DF       0113*  	rst.lil $18
0B1F88 C9          0114*  	ret
0B1F89 1C          0115*  @cmd:   db 28 ; set text viewport command
0B1F8A 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B1F8C 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B1F8E 00          0118*  @end:   db 0x00	  ; padding
0B1F8F             0119*  
0B1F8F             0120*  ; Wait for VBLANK interrupt
0B1F8F             0121*  vdu_vblank:
0B1F8F DD E5       0122*      PUSH 	IX
0B1F91             0123*  	MOSCALL	mos_sysvars
0B1F91 3E 08       0001*M 			LD	A, function
0B1F93 5B CF       0002*M 			RST.L	08h
0B1F95 DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B1F98             0125*  @wait:
0B1F98 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B1F9B 28 FB       0127*      JR	Z, @wait
0B1F9D DD E1       0128*      POP	IX
0B1F9F C9          0129*      RET
0B1FA0             0130*  
0B1FA0             0131*  ; VDU 29, x; y;: Set graphics origin
0B1FA0             0132*  ; This command sets the graphics origin.
0B1FA0             0133*  ; The origin is the point on the screen where the coordinates (0,0) are located.
0B1FA0             0134*  ; inputs: bc=x0,de=y0
0B1FA0             0135*  ; outputs; nothing
0B1FA0             0136*  ; destroys: a might make it out alive
0B1FA0             0137*  vdu_set_gfx_origin:
0B1FA0 ED 43 B6 1F 0138*      ld (@x0),bc
       0B          
0B1FA5 ED 53 B8 1F 0139*      ld (@y0),de
       0B          
0B1FAA 21 B5 1F 0B 0140*      ld hl,@cmd
0B1FAE 01 05 00 00 0141*      ld bc,@end-@cmd
0B1FB2 5B DF       0142*      rst.lil $18
0B1FB4 C9          0143*      ret
0B1FB5 1D          0144*  @cmd:   db 29 ; set graphics origin command
0B1FB6 00 00       0145*  @x0: 	dw 0x0000 ; set by bc
0B1FB8 00 00       0146*  @y0: 	dw 0x0000 ; set by de
0B1FBA 00          0147*  @end:   db 0x00	  ; padding
0B1FBB             0148*  
0B1FBB             0149*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B1FBB             0150*  ; NOTE: the order of the y-coordinate parameters are inverted
0B1FBB             0151*  ; 	because we have turned off logical screen scaling
0B1FBB             0152*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B1FBB             0153*  ; outputs; nothing
0B1FBB             0154*  ; destroys: a might make it out alive
0B1FBB             0155*  vdu_set_gfx_viewport:
0B1FBB ED 43 DB 1F 0156*      ld (@x0),bc
       0B          
0B1FC0 FD 22 DD 1F 0157*      ld (@y1),iy
       0B          
0B1FC5 DD 22 DF 1F 0158*  	ld (@x1),ix
       0B          
0B1FCA ED 53 E1 1F 0159*  	ld (@y0),de
       0B          
0B1FCF 21 DA 1F 0B 0160*  	ld hl,@cmd
0B1FD3 01 09 00 00 0161*  	ld bc,@end-@cmd
0B1FD7 5B DF       0162*  	rst.lil $18
0B1FD9 C9          0163*  	ret
0B1FDA 18          0164*  @cmd:   db 24 ; set graphics viewport command
0B1FDB 00 00       0165*  @x0: 	dw 0x0000 ; set by bc
0B1FDD 00 00       0166*  @y1: 	dw 0x0000 ; set by iy
0B1FDF 00 00       0167*  @x1: 	dw 0x0000 ; set by ix
0B1FE1 00 00       0168*  @y0: 	dw 0x0000 ; set by de
0B1FE3 00          0169*  @end:   db 0x00	  ; padding
0B1FE4             0170*  
0B1FE4             0171*  ; SCREEN MODES
0B1FE4             0172*  ; ===============================
0B1FE4             0173*  ; Mode  Horz  Vert  Cols  Refresh
0B1FE4             0174*  ; ---   ----  ----  ----  -------
0B1FE4             0175*  ; 11    320   240   2     60hz
0B1FE4             0176*  ; 139   320   240   2     60hz
0B1FE4             0177*  ; 23    512   384   2     60hz
0B1FE4             0178*  ; 151   512   384   2     60hz
0B1FE4             0179*  ; 6     640   240   2     60hz
0B1FE4             0180*  ; 134   640   240   2     60hz
0B1FE4             0181*  ; 2     640   480   2     60hz
0B1FE4             0182*  ; 130   640   480   2     60hz
0B1FE4             0183*  ; 17    800   600   2     60hz
0B1FE4             0184*  ; 145   800   600   2     60hz
0B1FE4             0185*  ; 18    1024  768   2     60hz
0B1FE4             0186*  ; 146   1024  768   2     60hz
0B1FE4             0187*  ; ---   ----  ----  ----  -------
0B1FE4             0188*  ; 10    320   240   4     60hz
0B1FE4             0189*  ; 138   320   240   4     60hz
0B1FE4             0190*  ; 22    512   384   4     60hz
0B1FE4             0191*  ; 150   512   384   4     60hz
0B1FE4             0192*  ; 5     640   240   4     60hz
0B1FE4             0193*  ; 133   640   240   4     60hz
0B1FE4             0194*  ; 1     640   480   4     60hz
0B1FE4             0195*  ; 129   640   480   4     60hz
0B1FE4             0196*  ; 16    800   600   4     60hz
0B1FE4             0197*  ; 19    1024  768   4     60hz
0B1FE4             0198*  ; ---   ----  ----  ----  -------
0B1FE4             0199*  ; 9     320   240   16    60hz
0B1FE4             0200*  ; 137   320   240   16    60hz
0B1FE4             0201*  ; 21    512   384   16    60hz
0B1FE4             0202*  ; 149   512   384   16    60hz
0B1FE4             0203*  ; 4     640   240   16    60hz
0B1FE4             0204*  ; 132   640   240   16    60hz
0B1FE4             0205*  ; 0     640   480   16    60hz
0B1FE4             0206*  ; 7     n/a   n/a   16    60hz
0B1FE4             0207*  ; ---   ----  ----  ----  -------
0B1FE4             0208*  ; 8     320   240   64    60hz
0B1FE4             0209*  ; 136   320   240   64    60hz
0B1FE4             0210*  ; 20    512   384   64    60hz
0B1FE4             0211*  ; 3     640   240   64    60hz
0B1FE4             0212*  ; ---   ----  ----  ----  -------
0B1FE4             0213*  vdu_set_screen_mode:
0B1FE4 32 F4 1F 0B 0214*  	ld (@arg),a
0B1FE8 21 F3 1F 0B 0215*  	ld hl,@cmd
0B1FEC 01 02 00 00 0216*  	ld bc,@end-@cmd
0B1FF0 5B DF       0217*  	rst.lil $18
0B1FF2 C9          0218*  	ret
0B1FF3 16          0219*  @cmd: db 22 ; set screen mode
0B1FF4 00          0220*  @arg: db 0  ; screen mode parameter
0B1FF5             0221*  @end:
0B1FF5             0222*  
0B1FF5             0223*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B1FF5             0224*  ; inputs: a is scaling mode, 1=on, 0=off
0B1FF5             0225*  ; note: default setting on boot is scaling ON
0B1FF5             0226*  vdu_set_scaling:
0B1FF5 32 07 20 0B 0227*  	ld (@arg),a
0B1FF9 21 04 20 0B 0228*  	ld hl,@cmd
0B1FFD 01 04 00 00 0229*  	ld bc,@end-@cmd
0B2001 5B DF       0230*  	rst.lil $18
0B2003 C9          0231*  	ret
0B2004 17 00 C0    0232*  @cmd: db 23,0,0xC0
0B2007 00          0233*  @arg: db 0  ; scaling on/off
0B2008             0234*  @end:
0B2008             0235*  
0B2008             0236*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B2008             0237*  ; inputs: hl=bufferId
0B2008             0238*  vdu_buff_select:
0B2008 22 1A 20 0B 0239*  	ld (@bufferId),hl
0B200C 21 17 20 0B 0240*  	ld hl,@cmd
0B2010 01 05 00 00 0241*  	ld bc,@end-@cmd
0B2014 5B DF       0242*  	rst.lil $18
0B2016 C9          0243*  	ret
0B2017 17 1B 20    0244*  @cmd: db 23,27,0x20
0B201A 00 00       0245*  @bufferId: dw 0x0000
0B201C 00          0246*  @end: db 0x00 ; padding
0B201D             0247*  
0B201D             0248*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B201D             0249*  ; inputs: a=format; bc=width; de=height
0B201D             0250*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B201D             0251*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B201D             0252*  ; 0 	RGBA8888 (4-bytes per pixel)
0B201D             0253*  ; 1 	RGBA2222 (1-bytes per pixel)
0B201D             0254*  ; 2 	Mono/Mask (1-bit per pixel)
0B201D             0255*  ; 3 	Reserved for internal use by VDP (“native” format)
0B201D             0256*  vdu_bmp_create:
0B201D ED 43 39 20 0257*      ld (@width),bc
       0B          
0B2022 ED 53 3B 20 0258*      ld (@height),de
       0B          
0B2027 32 3D 20 0B 0259*      ld (@fmt),a
0B202B 21 36 20 0B 0260*  	ld hl,@cmd
0B202F 01 08 00 00 0261*  	ld bc,@end-@cmd
0B2033 5B DF       0262*  	rst.lil $18
0B2035 C9          0263*  	ret
0B2036 17 1B 21    0264*  @cmd:       db 23,27,0x21
0B2039 00 00       0265*  @width:     dw 0x0000
0B203B 00 00       0266*  @height:    dw 0x0000
0B203D 00          0267*  @fmt:       db 0x00
0B203E             0268*  @end:
0B203E             0269*  
0B203E             0270*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B203E             0271*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B203E             0272*  vdu_load_img_rgba2_to_8:
0B203E             0273*  ; backup the target buffer id and image dimensions
0B203E E5          0274*      push hl
0B203F D5          0275*      push de
0B2040 C5          0276*      push bc
0B2041             0277*  ; load the rgba2 image to working buffer 65534
0B2041 21 FE FF 00 0278*      ld hl,65534 ; temporary working buffer id
0B2045 CD 48 21 0B 0279*  	call vdu_load_buffer_from_file
0B2049             0280*  ; restore the image dimensions and target buffer id
0B2049 C1          0281*      pop bc
0B204A D1          0282*      pop de
0B204B E1          0283*      pop hl
0B204C             0284*  ; fall through to vdu_rgba2_to_8
0B204C             0285*  
0B204C             0286*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B204C             0287*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B204C             0288*  ; the "expand bitmap" command is:
0B204C             0289*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B204C             0290*  ; and then to reverse the byte order to fix endian-ness:
0B204C             0291*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B204C             0292*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B204C             0293*  ; VDU 23,27,&20,targetBufferID%;
0B204C             0294*  ; VDU 23,27,&21,width%;height%;0
0B204C             0295*  ; -------------------------------------------------------------------
0B204C             0296*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B204C             0297*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B204C             0298*  vdu_rgba2_to_8:
0B204C             0299*  ; load the image dimensions and buffer id parameters
0B204C ED 43 A8 20 0300*      ld (@width),bc
       0B          
0B2051 ED 53 AA 20 0301*      ld (@height),de
       0B          
0B2056 22 8D 20 0B 0302*      ld (@bufferId0),hl
0B205A 22 9A 20 0B 0303*      ld (@bufferId2),hl
0B205E 22 A3 20 0B 0304*      ld (@bufferId1),hl
0B2062             0305*  ; clean up bytes that got stomped on by the ID loads
0B2062 3E 48       0306*      ld a,0x48
0B2064 32 8F 20 0B 0307*      ld (@bufferId0+2),a
0B2068 3E 17       0308*      ld a,23
0B206A 32 A5 20 0B 0309*      ld (@bufferId1+2),a
0B206E 3E 18       0310*      ld a,24
0B2070 32 9C 20 0B 0311*      ld (@bufferId2+2),a
0B2074 AF          0312*      xor a
0B2075 32 AC 20 0B 0313*      ld (@height+2),a
0B2079             0314*  ; send the vdu command strings
0B2079 21 84 20 0B 0315*      ld hl,@beg
0B207D 01 29 00 00 0316*      ld bc,@end-@beg
0B2081 5B DF       0317*      rst.lil $18
0B2083 C9          0318*      ret
0B2084             0319*  @beg:
0B2084             0320*  ; Command 14: Consolidate blocks in a buffer
0B2084             0321*  ; VDU 23, 0, &A0, bufferId; 14
0B2084 17 00 A0    0322*      db 23,0,0xA0
0B2087 FE FF       0323*      dw 65534 ; workingBufferId
0B2089 0E          0324*      db 14 ; consolidate blocks
0B208A             0325*  ; the "expand bitmap" command is:
0B208A             0326*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B208A 17 00 A0    0327*      db 23,0,0xA0
0B208D 00 00       0328*  @bufferId0: dw 0x0000 ; targetBufferId
0B208F 48          0329*      db 0x48 ; given as decimal command 72 in the docs
0B2090 02          0330*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B2091 FE FF       0331*      dw 65534 ; sourceBufferId
0B2093 00 7F BF FF 0332*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B2097             0333*  ; reverse the byte order to fix endian-ness:
0B2097             0334*  ; Command 24: Reverse the order of data of blocks within a buffer
0B2097             0335*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B2097             0336*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B2097 17 00 A0    0337*      db 23,0,0xA0
0B209A 00 00       0338*  @bufferId2:    dw 0x0000 ; targetBufferId
0B209C 18          0339*      db 24 ; reverse byte order
0B209D 04          0340*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B209E 04 00       0341*      dw 4 ; size (4 bytes)
0B20A0             0342*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B20A0             0343*  ; VDU 23,27,&20,targetBufferID%;
0B20A0 17 1B 20    0344*      db 23,27,0x20 ; select bitmap
0B20A3 00 00       0345*  @bufferId1: dw 0x0000 ; targetBufferId
0B20A5             0346*  ; VDU 23,27,&21,width%;height%;0
0B20A5 17 1B 21    0347*      db 23,27,0x21 ; create bitmap from buffer
0B20A8 00 00       0348*  @width: dw 0x0000
0B20AA 00 00       0349*  @height: dw 0x0000
0B20AC 00          0350*      db 0x00 ; rgba8888 format
0B20AD             0351*  @end:
0B20AD             0352*  
0B20AD             0353*  ; scratch variables
0B20AD 00 00 00    0354*  bufferId0: dl 0x000000
0B20B0 00 00 00    0355*  bufferId1: dl 0x000000
0B20B3             0356*  
0B20B3             0357*  ; load a vdu buffer from local memory
0B20B3             0358*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B20B3             0359*  vdu_load_buffer:
0B20B3 ED 43 DC 20 0360*      ld (@length),bc
       0B          
0B20B8 D5          0361*      push de ; save data pointer
0B20B9             0362*  ; send the vdu command string
0B20B9 7D          0363*      ld a,l
0B20BA 32 D9 20 0B 0364*      ld (@bufferId),a
0B20BE 7C          0365*      ld a,h
0B20BF 32 DA 20 0B 0366*      ld (@bufferId+1),a
0B20C3 21 D6 20 0B 0367*      ld hl,@cmd
0B20C7 01 08 00 00 0368*      ld bc,@end-@cmd
0B20CB 5B DF       0369*      rst.lil $18
0B20CD             0370*  ; send the buffer data
0B20CD E1          0371*      pop hl ; pointer to data
0B20CE ED 4B DC 20 0372*      ld bc,(@length)
       0B          
0B20D3 5B DF       0373*      rst.lil $18 ; send it
0B20D5 C9          0374*      ret
0B20D6             0375*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B20D6 17 00 A0    0376*  @cmd:       db 23,0,0xA0
0B20D9 00 00       0377*  @bufferId:	dw 0x0000
0B20DB 00          0378*  		    db 0 ; load buffer
0B20DC 00 00       0379*  @length:	dw 0x0000
0B20DE 00          0380*  @end: db 0 ; padding
0B20DF             0381*  
0B20DF             0382*  ; clear a buffer
0B20DF             0383*  ; inputs: hl = bufferId
0B20DF             0384*  vdu_clear_buffer:
0B20DF 7D          0385*      ld a,l
0B20E0 32 F7 20 0B 0386*      ld (@bufferId),a
0B20E4 7C          0387*      ld a,h
0B20E5 32 F8 20 0B 0388*      ld (@bufferId+1),a
0B20E9 21 F4 20 0B 0389*      ld hl,@cmd
0B20ED 01 06 00 00 0390*      ld bc,@end-@cmd
0B20F1 5B DF       0391*      rst.lil $18
0B20F3 C9          0392*      ret
0B20F4 17 00 A0    0393*  @cmd:       db 23,0,0xA0
0B20F7 00 00       0394*  @bufferId:	dw 0x0000
0B20F9 02          0395*  		    db 2 ; clear buffer
0B20FA             0396*  @end:
0B20FA             0397*  
0B20FA             0398*  vdu_clear_all_buffers:
0B20FA             0399*  ; clear all buffers
0B20FA 21 05 21 0B 0400*      ld hl,@beg
0B20FE 01 06 00 00 0401*      ld bc,@end-@beg
0B2102 5B DF       0402*      rst.lil $18
0B2104 C9          0403*      ret
0B2105 17 00 A0    0404*  @beg: db 23,0,$A0
0B2108 FF FF       0405*        dw -1 ; clear all buffers
0B210A 02          0406*        db 2  ; command 2: clear a buffer
0B210B             0407*  @end:
0B210B             0408*  
0B210B             0409*  ; Command 14: Consolidate blocks in a buffer
0B210B             0410*  vdu_consolidate_buffer:
0B210B             0411*  ; set parameters for vdu call
0B210B 7D          0412*      ld a,l
0B210C 32 23 21 0B 0413*      ld (@bufferId),a
0B2110 7C          0414*      ld a,h
0B2111 32 24 21 0B 0415*      ld (@bufferId+1),a
0B2115 21 20 21 0B 0416*      ld hl,@beg
0B2119 01 06 00 00 0417*      ld bc,@end-@beg
0B211D 5B DF       0418*      rst.lil $18
0B211F C9          0419*      ret
0B2120             0420*  ; VDU 23, 0, &A0, bufferId; 14
0B2120 17 00 A0    0421*  @beg: db 23,0,0xA0
0B2123 00 00       0422*  @bufferId: dw 0x0000
0B2125 0E          0423*             db 14
0B2126             0424*  @end:
0B2126             0425*  
0B2126             0426*  ; load an image file to a buffer and make it a bitmap
0B2126             0427*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B2126             0428*  vdu_load_img:
0B2126             0429*  ; back up image type and dimension parameters
0B2126 22 AD 20 0B 0430*      ld (bufferId0),hl
0B212A F5          0431*      push af
0B212B C5          0432*  	push bc
0B212C D5          0433*  	push de
0B212D             0434*  ; load the image
0B212D CD 48 21 0B 0435*  	call vdu_load_buffer_from_file
0B2131             0436*  ; now make it a bitmap
0B2131 2A AD 20 0B 0437*      ld hl,(bufferId0)
0B2135 CD 0B 21 0B 0438*      call vdu_consolidate_buffer
0B2139 2A AD 20 0B 0439*      ld hl,(bufferId0)
0B213D CD 08 20 0B 0440*      call vdu_buff_select
0B2141 D1          0441*  	pop de ; image height
0B2142 C1          0442*  	pop bc ; image width
0B2143 F1          0443*  	pop af ; image type
0B2144 C3 1D 20 0B 0444*  	jp vdu_bmp_create ; will return to caller from there
0B2148             0445*  
0B2148             0446*  ; inputs: hl = bufferId; iy = pointer to filename
0B2148             0447*  vdu_load_buffer_from_file:
0B2148 22 AD 20 0B 0448*      ld (bufferId0),hl
0B214C             0449*  
0B214C             0450*  ; clear target buffer
0B214C CD DF 20 0B 0451*      call vdu_clear_buffer
0B2150             0452*  
0B2150             0453*  ; open the file in read mode
0B2150             0454*  ; Open a file
0B2150             0455*  ; HLU: Filename
0B2150             0456*  ;   C: Mode
0B2150             0457*  ; Returns:
0B2150             0458*  ;   A: Filehandle, or 0 if couldn't open
0B2150 FD E5       0459*  	push iy ; pointer to filename
0B2152 E1          0460*  	pop hl
0B2153 0E 01       0461*  	ld c,fa_read
0B2155             0462*      MOSCALL mos_fopen
0B2155 3E 0A       0001*M 			LD	A, function
0B2157 5B CF       0002*M 			RST.L	08h
0B2159 32 94 21 0B 0463*      ld (@filehandle),a
0B215D             0464*  
0B215D             0465*  @read_file:
0B215D             0466*  ; Read a block of data from a file
0B215D             0467*  ;   C: Filehandle
0B215D             0468*  ; HLU: Pointer to where to write the data to
0B215D             0469*  ; DEU: Number of bytes to read
0B215D             0470*  ; Returns:
0B215D             0471*  ; DEU: Number of bytes read
0B215D 3A 94 21 0B 0472*      ld a,(@filehandle)
0B2161 4F          0473*      ld c,a
0B2162 21 00 E0 B7 0474*      ld hl,filedata
0B2166 11 00 20 00 0475*      ld de,8192 ; max we can read into onboard sram at one time
0B216A             0476*      MOSCALL mos_fread
0B216A 3E 1A       0001*M 			LD	A, function
0B216C 5B CF       0002*M 			RST.L	08h
0B216E             0477*  
0B216E             0478*  ; ; DEBUG: print chunk size
0B216E             0479*  ;     push de
0B216E             0480*  ;     pop hl
0B216E             0481*  ;     call printDec
0B216E             0482*  ;     call printNewLine
0B216E             0483*  
0B216E             0484*  ; test de for zero bytes read
0B216E 21 00 00 00 0485*      ld hl,0
0B2172 AF          0486*      xor a ; clear carry
0B2173 ED 52       0487*      sbc hl,de
0B2175 CA 8B 21 0B 0488*      jp z,@close_file
0B2179             0489*  
0B2179             0490*  ; load a vdu buffer from local memory
0B2179             0491*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B2179 2A AD 20 0B 0492*      ld hl,(bufferId0)
0B217D D5          0493*      push de ; chunksize
0B217E C1          0494*      pop bc
0B217F 11 00 E0 B7 0495*      ld de,filedata
0B2183 CD B3 20 0B 0496*      call vdu_load_buffer
0B2187             0497*  
0B2187             0498*  ; ; print progress breadcrumbs
0B2187             0499*  ;     ld a,'.'
0B2187             0500*  ;     rst.lil 10h
0B2187             0501*  
0B2187             0502*  ; read the next block
0B2187 C3 5D 21 0B 0503*      jp @read_file
0B218B             0504*  
0B218B             0505*  ; close the file
0B218B             0506*  @close_file:
0B218B 3A 94 21 0B 0507*      ld a,(@filehandle)
0B218F             0508*      MOSCALL mos_fclose
0B218F 3E 0B       0001*M 			LD	A, function
0B2191 5B CF       0002*M 			RST.L	08h
0B2193 C9          0509*      ret ; vdu_load_buffer_from_file
0B2194             0510*  
0B2194 00          0511*  @filehandle: db 0 ; file handle
0B2195 00 00 00    0512*  @fil: dl 0 ; pointer to FIL struct
0B2198             0513*  
0B2198 00 00 00    0514*  @chunkpointer: dl 0 ; pointer to current chunk
0B219B             0515*  
0B219B             0516*  ; File information structure (FILINFO)
0B219B             0517*  @filinfo:
0B219B 00 00 00 00 0518*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B219F 00 00       0519*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B21A1 00 00       0520*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B21A3 00          0521*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B21A4 00 00 00 00 0522*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B21B1 00 00 00 00 0523*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B22B1             0027       ; include "vdu_fonts.inc"
0B22B1             0028       include "vdu_plot.inc"
0B22B1             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B22B1             0002*  ; PLOT code 	(Decimal) 	Effect
0B22B1             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B22B1             0004*  plot_sl_both: equ 0x00
0B22B1             0005*  
0B22B1             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B22B1             0007*  plot_sl_first: equ 0x08
0B22B1             0008*  
0B22B1             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B22B1             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B22B1             0011*  
0B22B1             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B22B1             0013*  plot_sl_last: equ 0x20
0B22B1             0014*  
0B22B1             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B22B1             0016*  plot_sl_none: equ 0x28
0B22B1             0017*  
0B22B1             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B22B1             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B22B1             0020*  
0B22B1             0021*  ; &40-&47 	64-71 	Point plot
0B22B1             0022*  plot_pt: equ 0x40
0B22B1             0023*  
0B22B1             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background §§
0B22B1             0025*  plot_lf_lr_non_bg: equ 0x48
0B22B1             0026*  
0B22B1             0027*  ; &50-&57 	80-87 	Triangle fill
0B22B1             0028*  plot_tf: equ 0x50
0B22B1             0029*  
0B22B1             0030*  ; &58-&5F 	88-95 	Line fill right to background §§
0B22B1             0031*  plot_lf_r_bg: equ 0x58
0B22B1             0032*  
0B22B1             0033*  ; &60-&67 	96-103 	Rectangle fill
0B22B1             0034*  plot_rf: equ 0x60
0B22B1             0035*  
0B22B1             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground §§
0B22B1             0037*  plot_lf_lr_fg: equ 0x60
0B22B1             0038*  
0B22B1             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B22B1             0040*  plot_pf: equ 0x70
0B22B1             0041*  
0B22B1             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground §§
0B22B1             0043*  plot_lf_r_non_fg: equ 0x78
0B22B1             0044*  
0B22B1             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B22B1             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B22B1             0047*  
0B22B1             0048*  ; &90-&97 	144-151 	Circle outline
0B22B1             0049*  plot_co: equ 0x90
0B22B1             0050*  
0B22B1             0051*  ; &98-&9F 	152-159 	Circle fill
0B22B1             0052*  plot_cf: equ 0x98
0B22B1             0053*  
0B22B1             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B22B1             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B22B1             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B22B1             0057*  
0B22B1             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B22B1             0059*  plot_rcm: equ 0xB8
0B22B1             0060*  
0B22B1             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B22B1             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B22B1             0063*  ; &D0-&D7 	208-215 	Not defined
0B22B1             0064*  ; &D8-&DF 	216-223 	Not defined
0B22B1             0065*  ; &E0-&E7 	224-231 	Not defined
0B22B1             0066*  
0B22B1             0067*  ; &E8-&EF 	232-239 	Bitmap plot §
0B22B1             0068*  plot_bmp: equ 0xE8
0B22B1             0069*  
0B22B1             0070*  ; &F0-&F7 	240-247 	Not defined
0B22B1             0071*  ; &F8-&FF 	248-255 	Not defined
0B22B1             0072*  
0B22B1             0073*  ; § Support added in Agon Console8 VDP 2.1.0 §§ Support added in
0B22B1             0074*  ; Agon Console8 VDP 2.2.0
0B22B1             0075*  
0B22B1             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B22B1             0077*  ; Plot code 	Effect
0B22B1             0078*  ; 0 	Move relative
0B22B1             0079*  mv_rel: equ 0
0B22B1             0080*  
0B22B1             0081*  ; 1 	Plot relative in current foreground colour
0B22B1             0082*  dr_rel_fg: equ 1
0B22B1             0083*  
0B22B1             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B22B1             0085*  ; 3 	Plot relative in current background colour
0B22B1             0086*  dr_rel_bg: equ 3
0B22B1             0087*  
0B22B1             0088*  ; 4 	Move absolute
0B22B1             0089*  mv_abs: equ 4
0B22B1             0090*  
0B22B1             0091*  ; 5 	Plot absolute in current foreground colour
0B22B1             0092*  dr_abs_fg: equ 5
0B22B1             0093*  
0B22B1             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B22B1             0095*  ; 7 	Plot absolute in current background colour
0B22B1             0096*  dr_abs_bg: equ 7
0B22B1             0097*  
0B22B1             0098*  ; Codes 0-3 use the position data provided as part of the command
0B22B1             0099*  ; as a relative position, adding the position given to the current
0B22B1             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B22B1             0101*  ; as part of the command as an absolute position, setting the current
0B22B1             0102*  ; graphical cursor position to the position given.
0B22B1             0103*  
0B22B1             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B22B1             0105*  ; current pixel colour. These operations cannot currently be supported
0B22B1             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B22B1             0107*  ; supported. Support for these codes may be added in a future version
0B22B1             0108*  ; of the VDP firmware.
0B22B1             0109*  
0B22B1             0110*  ; 16 colour palette constants
0B22B1             0111*  c_black: equ 0
0B22B1             0112*  c_red_dk: equ 1
0B22B1             0113*  c_green_dk: equ 2
0B22B1             0114*  c_yellow_dk: equ 3
0B22B1             0115*  c_blue_dk: equ 4
0B22B1             0116*  c_magenta_dk: equ 5
0B22B1             0117*  c_cyan_dk: equ 6
0B22B1             0118*  c_grey: equ 7
0B22B1             0119*  c_grey_dk: equ 8
0B22B1             0120*  c_red: equ 9
0B22B1             0121*  c_green: equ 10
0B22B1             0122*  c_yellow: equ 11
0B22B1             0123*  c_blue: equ 12
0B22B1             0124*  c_magenta: equ 13
0B22B1             0125*  c_cyan: equ 14
0B22B1             0126*  c_white: equ 15
0B22B1             0127*  
0B22B1             0128*  ; VDU 25, mode, x; y;: PLOT command
0B22B1             0129*  ; inputs: a=mode, bc=x0, de=y0
0B22B1             0130*  vdu_plot:
0B22B1 32 CB 22 0B 0131*      ld (@mode),a
0B22B5 ED 43 CC 22 0132*      ld (@x0),bc
       0B          
0B22BA ED 53 CE 22 0133*      ld (@y0),de
       0B          
0B22BF 21 CA 22 0B 0134*  	ld hl,@cmd
0B22C3 01 06 00 00 0135*  	ld bc,@end-@cmd
0B22C7 5B DF       0136*  	rst.lil $18
0B22C9 C9          0137*  	ret
0B22CA 19          0138*  @cmd:   db 25
0B22CB 00          0139*  @mode:  db 0
0B22CC 00 00       0140*  @x0: 	dw 0
0B22CE 00 00       0141*  @y0: 	dw 0
0B22D0 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B22D1             0143*  
0B22D1             0144*  ; VDU 25, mode, x; y;: PLOT command
0B22D1             0145*  ; USING 16.8 FIXED POINT COORDINATES
0B22D1             0146*  ; inputs: a=mode, ub.c=x0, ud.e=y0
0B22D1             0147*  vdu_plot_168:
0B22D1 ED 53 ED 22 0148*      ld (@y0-1),de ; load in reverse order to avoid stomping on inputs
       0B          
0B22D6 ED 43 EB 22 0149*      ld (@x0-1),bc ; integer portion only
       0B          
0B22DB 32 EB 22 0B 0150*      ld (@mode),a  ; load this order b/c we shifted bc right
0B22DF 21 EA 22 0B 0151*  	ld hl,@cmd
0B22E3 01 06 00 00 0152*  	ld bc,@end-@cmd
0B22E7 5B DF       0153*  	rst.lil $18
0B22E9             0154*      ; ld hl,@cmd
0B22E9             0155*      ; ld a,6
0B22E9             0156*      ; call dumpMemoryHex
0B22E9             0157*      ; call printNewLine
0B22E9 C9          0158*  	ret
0B22EA 19          0159*  @cmd:   db 25
0B22EB 00          0160*  @mode:  db 0
0B22EC 00 00       0161*  @x0: 	dw 0
0B22EE 00 00       0162*  @y0: 	dw 0
0B22F0             0163*  @end:  ; no padding required b/c we shifted de right
0B22F0             0164*  
0B22F0             0165*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B22F0             0166*  ; &E8-&EF 	232-239 	Bitmap plot §
0B22F0             0167*  ; VDU 25, mode, x; y;: PLOT command
0B22F0             0168*  ; inputs: bc=x0, de=y0
0B22F0             0169*  ; prerequisites: vdu_buff_select
0B22F0             0170*  vdu_plot_bmp:
0B22F0 ED 43 07 23 0171*      ld (@x0),bc
       0B          
0B22F5 ED 53 09 23 0172*      ld (@y0),de
       0B          
0B22FA 21 05 23 0B 0173*  	ld hl,@cmd
0B22FE 01 06 00 00 0174*  	ld bc,@end-@cmd
0B2302 5B DF       0175*  	rst.lil $18
0B2304 C9          0176*  	ret
0B2305 19          0177*  @cmd:   db 25
0B2306 ED          0178*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B2307 00 00       0179*  @x0: 	dw 0x0000
0B2309 00 00       0180*  @y0: 	dw 0x0000
0B230B 00          0181*  @end:   db 0x00 ; padding
0B230C             0182*  
0B230C             0183*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B230C             0184*  ; &E8-&EF 	232-239 	Bitmap plot §
0B230C             0185*  ; VDU 25, mode, x; y;: PLOT command
0B230C             0186*  ; inputs: bc=x0, de=y0
0B230C             0187*  ; USING 16.8 FIXED POINT COORDINATES
0B230C             0188*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B230C             0189*  ;   the fractional portiion of the inputs are truncated
0B230C             0190*  ;   leaving only the 16-bit integer portion
0B230C             0191*  ; prerequisites: vdu_buff_select
0B230C             0192*  vdu_plot_bmp168:
0B230C             0193*  ; populate in the reverse of normal to keep the
0B230C             0194*  ; inputs from stomping on each other
0B230C ED 53 2A 23 0195*      ld (@y0-1),de
       0B          
0B2311 ED 43 28 23 0196*      ld (@x0-1),bc
       0B          
0B2316 3E ED       0197*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B2318 32 28 23 0B 0198*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B231C 21 27 23 0B 0199*  	ld hl,@cmd
0B2320 01 06 00 00 0200*  	ld bc,@end-@cmd
0B2324 5B DF       0201*  	rst.lil $18
0B2326 C9          0202*  	ret
0B2327 19          0203*  @cmd:   db 25
0B2328 ED          0204*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B2329 00 00       0205*  @x0: 	dw 0x0000
0B232B 00 00       0206*  @y0: 	dw 0x0000
0B232D             0207*  @end:  ; no padding required b/c we shifted de right
0B232D             0208*  
0B232D             0209*  ; draw a filled rectangle
0B232D             0210*  vdu_plot_rf:
0B232D ED 43 54 23 0211*      ld (@x0),bc
       0B          
0B2332 ED 53 56 23 0212*      ld (@y0),de
       0B          
0B2337 DD 22 5A 23 0213*      ld (@x1),ix
       0B          
0B233C FD 22 5C 23 0214*      ld (@y1),iy
       0B          
0B2341 3E 19       0215*      ld a,25 ; we have to reload the 2nd plot command
0B2343 32 58 23 0B 0216*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B2347 21 52 23 0B 0217*  	ld hl,@cmd0
0B234B 01 0C 00 00 0218*  	ld bc,@end-@cmd0
0B234F 5B DF       0219*  	rst.lil $18
0B2351 C9          0220*      ret
0B2352 19          0221*  @cmd0:  db 25 ; plot
0B2353 04          0222*  @arg0:  db plot_sl_both+mv_abs
0B2354 00 00       0223*  @x0:    dw 0x0000
0B2356 00 00       0224*  @y0:    dw 0x0000
0B2358 19          0225*  @cmd1:  db 25 ; plot
0B2359 65          0226*  @arg1:  db plot_rf+dr_abs_fg
0B235A 00 00       0227*  @x1:    dw 0x0000
0B235C 00 00       0228*  @y1:    dw 0x0000
0B235E 00          0229*  @end:   db 0x00 ; padding
0B235F             0230*  
0B235F             0231*  ; draw a filled circle
0B235F             0232*  vdu_plot_cf:
0B235F ED 43 86 23 0233*      ld (@x0),bc
       0B          
0B2364 ED 53 88 23 0234*      ld (@y0),de
       0B          
0B2369 DD 22 8C 23 0235*      ld (@x1),ix
       0B          
0B236E FD 22 8E 23 0236*      ld (@y1),iy
       0B          
0B2373 3E 19       0237*      ld a,25 ; we have to reload the 2nd plot command
0B2375 32 8A 23 0B 0238*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B2379 21 84 23 0B 0239*  	ld hl,@cmd0
0B237D 01 0C 00 00 0240*  	ld bc,@end-@cmd0
0B2381 5B DF       0241*  	rst.lil $18
0B2383 C9          0242*      ret
0B2384 19          0243*  @cmd0:  db 25 ; plot
0B2385 04          0244*  @arg0:  db plot_sl_both+mv_abs
0B2386 00 00       0245*  @x0:    dw 0x0000
0B2388 00 00       0246*  @y0:    dw 0x0000
0B238A 19          0247*  @cmd1:  db 25 ; plot
0B238B 9D          0248*  @arg1:  db plot_cf+dr_abs_fg
0B238C 00 00       0249*  @x1:    dw 0x0000
0B238E 00 00       0250*  @y1:    dw 0x0000
0B2390 00          0251*  @end:   db 0x00 ; padding
0B2391             0252*  
0B2391             0253*  ; VDU 25, mode, x; y;: PLOT command
0B2391             0254*  ; inputs: a=mode, ix=x0, iy=y0
0B2391             0255*  plot:
0B2391 32 AB 23 0B 0256*      ld (@mode),a
0B2395 DD 22 AC 23 0257*      ld (@x0),ix
       0B          
0B239A FD 22 AE 23 0258*      ld (@y0),iy
       0B          
0B239F 21 AA 23 0B 0259*  	ld hl,@cmd
0B23A3 01 06 00 00 0260*  	ld bc,@end-@cmd
0B23A7 5B DF       0261*  	rst.lil $18
0B23A9 C9          0262*  	ret
0B23AA 19          0263*  @cmd:   db 25
0B23AB 00          0264*  @mode:  db 0
0B23AC 00 00       0265*  @x0: 	dw 0
0B23AE 00 00       0266*  @y0: 	dw 0
0B23B0 00          0267*  @end:   db 0 ; padding
0B23B1             0268*  
0B23B1             0269*  ; VDU 5: Write text at graphics cursor
0B23B1             0270*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B23B1             0271*  ; prerequisites: gcol foreground set, VDU 5 set
0B23B1             0272*  plot_text:
0B23B1 E5          0273*      push hl ; save text pointer
0B23B2             0274*  ; move graphics cursor to x0, y0
0B23B2 3E 44       0275*      ld a,plot_pt+mv_abs
0B23B4 CD 91 23 0B 0276*      call plot
0B23B8             0277*  ; write text
0B23B8 E1          0278*      pop hl ; restore text pointer
0B23B9 CD 73 02 0B 0279*      call printString
0B23BD C9          0280*      ret
0B23BE             0029   
0B23BE             0030   ; SHAWN'S INCLUDES
0B23BE             0031   	INCLUDE	"strings24.asm"
0B23BE             0001*  ;------------------------------------------------------------------------
0B23BE             0002*  ;  strings24.asm
0B23BE             0003*  ;
0B23BE             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B23BE             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B23BE             0006*  ;  MIT license
0B23BE             0007*  ;------------------------------------------------------------------------
0B23BE             0008*  
0B23BE             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B23BE             0010*  ; and postpended with a minus sign if was negative
0B23BE             0011*  ; Uses HLU, DEU, BCU
0B23BE             0012*  print_HLU_s24:
0B23BE CD 3B 08 0B 0013*  	call hlu_abs
0B23C2 F5          0014*  	push af ; save the sign and zero flags
0B23C3 CD CE 23 0B 0015*  	call print_HLU_u24
0B23C7 F1          0016*  	pop af
0B23C8 F0          0017*  	ret p ; HLU was positive so nothig more to do
0B23C9 3E 2D       0018*  	ld a,'-'
0B23CB 5B D7       0019*  	rst.lil 10h
0B23CD C9          0020*  	ret
0B23CE             0021*  
0B23CE             0022*  ;------------------------------------------------------------------------
0B23CE             0023*  ;Full print and buffer routine so you can adjust behaviour
0B23CE             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B23CE             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B23CE             0026*  ;Print value in HLU in decimal with leading 0s removed
0B23CE             0027*  ; Uses HLU, DEU, BCU
0B23CE             0028*  ;------------------------------------------------------------------------
0B23CE             0029*  
0B23CE             0030*  print_HLU_u24:
0B23CE 22 AB 24 0B 0031*  	ld	(hex_temp),hl
0B23D2 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B23D4 11 AE 24 0B 0033*  	ld	de,outbuf
0B23D8 D5          0034*  	push	de
0B23D9 21 07 00 00 0035*  	ld	hl,7
0B23DD 19          0036*  	add	hl,de
0B23DE E5          0037*  	push	hl
0B23DF D1          0038*  	pop	de	;copy HLU to DEU
0B23E0 AF          0039*  	xor	a
0B23E1             0040*  _pde_u_zerobuf:
0B23E1 77          0041*  	ld	(hl),a	;zero out the output
0B23E2 2B          0042*  	dec	hl
0B23E3 10 FC       0043*  	djnz	_pde_u_zerobuf
0B23E5             0044*  
0B23E5 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B23E7             0046*  _bcd_Convert:
0B23E7             0047*  
0B23E7 21 AB 24 0B 0048*  	ld hl,hex_temp
0B23EB             0049*  ;
0B23EB CB 26       0050*  	sla (hl)
0B23ED 23          0051*  	inc hl
0B23EE CB 16       0052*  	rl (hl)
0B23F0 23          0053*  	inc hl
0B23F1 CB 16       0054*  	rl (hl)		;24 bits rolled right
0B23F3             0055*  
0B23F3             0056*  
0B23F3 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B23F5 D5          0058*  	push	de
0B23F6 E1          0059*  	pop	hl
0B23F7             0060*  
0B23F7             0061*  _bcd_Add3:
0B23F7 7E          0062*  	ld	a,(hl)
0B23F8 8F          0063*  	adc	a
0B23F9 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B23FA FE 10       0065*  	cp	10h	;did we roll over nibble?
0B23FC 3F          0066*  	ccf
0B23FD CB A7       0067*  	res	4,a
0B23FF             0068*  
0B23FF 77          0069*          ld (hl),a
0B2400 2B          0070*  	dec	hl
0B2401 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B2403 0D          0072*          dec c
0B2404 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B2406             0074*  
0B2406             0075*  
0B2406 E1          0076*  	pop	hl
0B2407 E5          0077*  	push	hl
0B2408 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B240A             0079*  _pde_u_make_ascii:
0B240A 7E          0080*  	ld	a,(hl)
0B240B B7          0081*  	or	a
0B240C 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B240E 36 20       0083*  	ld	(hl),' '
0B2410 23          0084*  	inc	hl
0B2411 10 F7       0085*  	djnz	_pde_u_make_ascii
0B2413             0086*  _pde_u_make_ascii2:
0B2413 04          0087*  	inc	b
0B2414             0088*  _pde_u_make_ascii3:
0B2414 7E          0089*  	ld	a,(hl)
0B2415 F6 30       0090*  	or	30h
0B2417 77          0091*  	ld	(hl),a
0B2418 23          0092*  	inc	hl
0B2419 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B241B             0094*  
0B241B E1          0095*  	pop	hl
0B241C 06 08       0096*  	ld	b,8
0B241E             0097*  _pde_u_final_out:
0B241E 7E          0098*  	ld	a,(hl)
0B241F 23          0099*  	inc	hl
0B2420 FE 20       0100*  	cp	' '
0B2422 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B2424 5B D7       0102*  	rst.lil	10h
0B2426             0103*  _pde_u_final_out_strip:
0B2426 10 F6       0104*  	djnz	_pde_u_final_out
0B2428 C9          0105*  	ret
0B2429             0106*  
0B2429             0107*  ;------------------------------------------------------------------------
0B2429             0108*  ; is_digit
0B2429             0109*  ; C flag set if A is a digit
0B2429             0110*  ; preserves all registers
0B2429             0111*  ;------------------------------------------------------------------------
0B2429             0112*  is_digit:
0B2429 FE 30       0113*  	cp	'0'
0B242B 3F          0114*  	ccf
0B242C D0          0115*  	ret	nc	;less that '0'
0B242D FE 3A       0116*  	cp	'9' + 1
0B242F C9          0117*  	ret
0B2430             0118*  
0B2430             0119*  
0B2430             0120*  ;------------------------------------------------------------------------
0B2430             0121*  ; char2hex
0B2430             0122*  ; Input: ASCII nibble in A
0B2430             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B2430             0124*  ;------------------------------------------------------------------------
0B2430             0125*  char2hex:
0B2430 FE 30       0126*  	CP	'0'
0B2432 38 1D       0127*  	JR	C, char_not_hex
0B2434 FE 3A       0128*  	CP	'9' + 1
0B2436 30 03       0129*  	JR	NC, char_not_09
0B2438 D6 30       0130*  	sub	'0'
0B243A C9          0131*  	ret
0B243B             0132*  
0B243B             0133*  char_not_09:
0B243B             0134*  	; char is not 0 to 9. Try upper case
0B243B FE 41       0135*  	CP	'A'
0B243D 38 12       0136*  	JR	C, char_not_hex
0B243F FE 47       0137*  	CP	'F' + 1
0B2441 30 03       0138*  	JR	NC, char_not_AF
0B2443 D6 37       0139*  	sub	'A'-10
0B2445 C9          0140*  	ret
0B2446             0141*  
0B2446             0142*  char_not_AF:
0B2446             0143*  	; char is not upper case A-F. Try lower
0B2446 FE 61       0144*  	CP	'a'
0B2448 38 07       0145*  	JR	C, char_not_hex
0B244A FE 67       0146*  	CP	'f' + 1
0B244C 30 03       0147*  	JR	NC, char_not_hex
0B244E D6 57       0148*  	sub	'a' - 10
0B2450 C9          0149*  	RET
0B2451             0150*  
0B2451             0151*  char_not_hex:
0B2451 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B2453 C9          0153*  	RET
0B2454             0154*  
0B2454             0155*  ;------------------------------------------------------------------------
0B2454             0156*  ;  newline
0B2454             0157*  ;  Output CR+LF; all registers preserved
0B2454             0158*  ;------------------------------------------------------------------------
0B2454             0159*  newline:
0B2454 F5          0160*         push   AF
0B2455 3E 0D       0161*         LD     A, 13
0B2457 5B D7       0162*         RST.LIL    10h
0B2459 3E 0A       0163*         LD     A, 10
0B245B 5B D7       0164*         RST.LIL    10h
0B245D F1          0165*         POP    AF
0B245E C9          0166*         RET
0B245F             0167*  
0B245F             0168*  ;------------------------------------------------------------------------
0B245F             0169*  ;  put_nibble
0B245F             0170*  ;  Output a single hex nibble in A
0B245F             0171*  ;  All registers preserved
0B245F             0172*  ;------------------------------------------------------------------------
0B245F             0173*  put_nibble:
0B245F F5          0174*  	push   AF
0B2460 C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B2462 27          0176*  	daa
0B2463 CE 40       0177*  	adc    a,040h
0B2465 27          0178*  	daa
0B2466 5B D7       0179*  	RST.LIL    10h	;output character in A
0B2468 F1          0180*  	pop    AF
0B2469 C9          0181*  	ret
0B246A             0182*  
0B246A             0183*  ;------------------------------------------------------------------------
0B246A             0184*  ;  print_A
0B246A             0185*  ;  Output the 8-bit hex number A
0B246A             0186*  ;  All registers preserved
0B246A             0187*  ;------------------------------------------------------------------------
0B246A             0188*  print_A:
0B246A F5          0189*  	push 	AF
0B246B F5          0190*  	push 	AF	;save for second nibble
0B246C 0F          0191*  	rrca
0B246D 0F          0192*  	rrca
0B246E 0F          0193*  	rrca
0B246F 0F          0194*  	rrca
0B2470 E6 0F       0195*  	and	0Fh	;first nibble
0B2472 CD 5F 24 0B 0196*  	call	put_nibble
0B2476 F1          0197*  	pop 	AF
0B2477 E6 0F       0198*  	and	0Fh	;second nibble
0B2479 CD 5F 24 0B 0199*  	call	put_nibble
0B247D F1          0200*  	pop 	AF
0B247E C9          0201*  	ret
0B247F             0202*  
0B247F             0203*  ;------------------------------------------------------------------------
0B247F             0204*  ;  print_HLU_hex
0B247F             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B247F             0206*  ;------------------------------------------------------------------------
0B247F             0207*  print_HLU_hex:
0B247F F5          0208*         push   AF
0B2480 22 AB 24 0B 0209*         ld     (hex_temp),hl
0B2484 3A AD 24 0B 0210*         ld     a,(hex_temp+2)
0B2488 CD 6A 24 0B 0211*         call   print_A
0B248C 3A AC 24 0B 0212*         ld     a,(hex_temp+1)
0B2490 CD 6A 24 0B 0213*         call   print_A
0B2494 3A AB 24 0B 0214*         ld     a,(hex_temp)
0B2498 CD 6A 24 0B 0215*         call   print_A
0B249C F1          0216*         POP    AF
0B249D C9          0217*         RET
0B249E             0218*  
0B249E             0219*  ;------------------------------------------------------------------------
0B249E             0220*  ;  puts
0B249E             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B249E             0222*  ;  registers preserved.
0B249E             0223*  ;------------------------------------------------------------------------
0B249E             0224*  puts:
0B249E F5          0225*         push   AF
0B249F C5          0226*         push   BC
0B24A0 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B24A4 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B24A6 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B24A8 C1          0230*         pop    BC
0B24A9 F1          0231*         pop    AF
0B24AA C9          0232*         ret
0B24AB             0233*  
0B24AB             0234*  ;------------------------------------------------------------------------
0B24AB             0235*  ; Data area
0B24AB             0236*  ; Storage for 24 bit conversion
0B24AB             0237*  ;------------------------------------------------------------------------
0B24AB             0238*  hex_temp:
0B24AB 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B24AE             0240*  
0B24AE             0241*  outbuf:
0B24AE 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B24B7             0032   
0B24B7             0033   ; APPLICATION INCLUDES
0B24B7 55 73 61 67 0034   str_usage: ASCIZ "Usage: flower <args>\r\n"
       65 3A 20 66 
       6C 6F 77 65 
       72 20 3C 61 
       72 67 73 3E 
       0D 0A 00    
0B24CE 45 72 72 6F 0035   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B24D7 53 75 63 63 0036   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B24E2             0037   
0B24E2             0038   ; This program draws 2D curves related to the hypotrochoid / epitrochoid family (i.e. Spirographs),
0B24E2             0039   ; more generally known as roulettes. While it is possible to construct curves fitting the precise
0B24E2             0040   ; definitions of such curves, the program is not limited to them as slipping of the outer circle
0B24E2             0041   ; is allowable. In addition, continually plotting the curve insribed by the outer circle is not required.
0B24E2             0042   ; This allows rotating polygonal shapes remniscent of string art, as well as daisy-like curves.
0B24E2             0043   ; Hence the name "flower" even though the program is not limited to such shapes.
0B24E2             0044   ; Another key difference is that cumulative shrinking can be applied to the radii of the rotating circles,
0B24E2             0045   ; thus allowing curves which form true spirals in contrast to the Spirograph toy, which does not.
0B24E2             0046   ;
0B24E2             0047   ; Parameters with example values:
0B24E2             0048   ; petals      = 3.03  :
0B24E2             0049   ; vectors     = 1.98  :
0B24E2             0050   ; depth       = 0.6   :
0B24E2             0051   ; periods     = 66    :
0B24E2             0052   ; shrink      = 0.8   :
0B24E2             0053   ; theta_prime = 0.0   :
0B24E2             0054   ; radius_scale= 480   :
0B24E2             0055   
0B24E2             0056   ; ========= BOILERPLATE MAIN LOOP =========
0B24E2             0057   ; The main routine
0B24E2             0058   ; IXU: argv - pointer to array of parameters
0B24E2             0059   ;   C: argc - number of parameters
0B24E2             0060   ; Returns:
0B24E2             0061   ;  HL: Error code, or 0 if OK
0B24E2             0062   
0B24E2             0063   min_args: equ 2
0B24E2             0064   
0B24E2             0065   _main:
0B24E2 79          0066       ld a,c              ; how many arguments?
0B24E3 FE 02       0067       cp min_args         ; not enough?
0B24E5 D2 75 26 0B 0068       jp nc,main          ; if enough, go to main loop
0B24E9 21 B7 24 0B 0069       ld hl,str_usage     ; if not enough, print usage
0B24ED CD 73 02 0B 0070       call printString
0B24F1             0071                           ; fall through to _main_end_error
0B24F1             0072   
0B24F1             0073   _main_end_error:
0B24F1 21 CE 24 0B 0074       ld hl,str_error     ; print error message
0B24F5 CD 73 02 0B 0075       call printString
0B24F9 21 13 00 00 0076       ld hl,19            ; return error code 19
0B24FD C9          0077       ret
0B24FE             0078   
0B24FE             0079   _main_end_ok:
0B24FE             0080       ; ld hl,str_success   ; print success message
0B24FE             0081       ; call printString
0B24FE CD 88 02 0B 0082       call printNewLine
0B2502 21 00 00 00 0083       ld hl,0             ; return 0 for success
0B2506 C9          0084       ret
0B2507             0085   
0B2507             0086   ; GLOBAL VARIABLES / DEFAULTS
0B2507             0087   ; ---- input arguments (16.8 fixed) ----
0B2507             0088   input_params_num: equ 5
0B2507             0089   input_params:               ; label so we can traverse the table in loops
0B2507 07 03 00    0090   petals: 	        dl 0x000307	; 3.03
0B250A FA 01 00    0091   vectors: 	        dl 0x0001FA	; 1.98
0B250D 99 00 00    0092   depth: 	            dl 0x000099	; 0.6
0B2510 00 42 00    0093   periods: 	        dl 0x004200	; 66
0B2513 CC 00 00    0094   shrink: 	        dl 0x0000CC	; 0.8
0B2516 00 01 00    0095   clock_prime: 	    dl 0x000100	; 1
0B2519 00 01 00    0096   clock_petal: 	    dl 0x000100	; 1
0B251C             0097   ; radius_scale: 	dl 0x01E000	; 480
0B251C 00 00 01    0098   radius_scale: 	    dl 0x010000 ; 256
0B251F             0099   
0B251F             0100   ; ---- main loop parameters (16.8 fixed) ----
0B251F 00 00 00    0101   step_theta_prime:   dl 0x000000  ; Step increment for theta_prime in each loop iteration
0B2522 00 00 00    0102   step_theta_petal:   dl 0x000000  ; Step increment for theta_petal in each loop iteration
0B2525 00 00 00    0103   total_steps:        dl 0x000000  ; Total number of iterations based on periods and step_theta_prime
0B2528 00 00 00    0104   step_shrink:        dl 0x000000  ; Step decrement applied to radius in each iteration
0B252B             0105   
0B252B             0106   ; ---- main loop state variables (16.8 fixed) ----
0B252B 00 00 00    0107   theta_prime: 	    dl 0x000000	; 0
0B252E 00 00 00    0108   theta_petal: 	    dl 0x000000	; 0
0B2531 00 00 00    0109   radius_prime:       dl 0x000000  ; Initial radius before shrink factor is applied
0B2534 00 00 00    0110   radius_petal:       dl 0x000000  ; Radius of the petal circle
0B2537 00 00 00    0111   radius:             dl 0x000000  ; Total radius of the curve
0B253A 00 00 00    0112   x_prev:             dl 0x000000  ; Previous x coordinate
0B253D 00 00 00    0113   y_prev:             dl 0x000000  ; Previous y coordinate
0B2540             0114   
0B2540             0115   main_loop:
0B2540             0116   ; --- clear the screen ---
0B2540 CD 34 1F 0B 0117       call vdu_cls
0B2544             0118   
0B2544             0119   ; --- convert input thetas to 16.8 fixed point degrees255
0B2544 2A 2B 25 0B 0120       ld hl,(theta_prime) ; get the theta_prime value
0B2548 CD B4 0C 0B 0121       call deg_360_to_256 ; convert to 16.8 fixed point
0B254C 22 2B 25 0B 0122       ld (theta_prime),hl ; store the result
0B2550             0123   
0B2550 2A 2E 25 0B 0124       ld hl,(theta_petal) ; get the theta_petal value
0B2554 CD B4 0C 0B 0125       call deg_360_to_256 ; convert to 16.8 fixed point
0B2558 22 2E 25 0B 0126       ld (theta_petal),hl ; store the result
0B255C             0127   
0B255C             0128   ; --- compute the main loop parameters ---
0B255C             0129   ; step_theta_prime = 256 degrees / (petals * vectors)
0B255C 2A 07 25 0B 0130       ld hl,(petals)
0B2560 ED 5B 0A 25 0131       ld de,(vectors)
       0B          
0B2565 CD 36 0B 0B 0132       call umul168 ; uh.l = petals * vectors
0B2569 EB          0133       ex de,hl ; de = petals * vectors
0B256A 21 00 00 01 0134       ld hl,256*256 ; 360 degrees in 16.8 fixed point
0B256E CD 61 0B 0B 0135       call udiv168 ; ud.e = 256 / (petals * vectors)
0B2572 ED 53 1F 25 0136       ld (step_theta_prime),de ; store the result
       0B          
0B2577 CD 4C 27 0B 0137       call print_step_theta_prime
0B257B             0138   
0B257B             0139   ; step_theta_petal = 256 degrees / vectors
0B257B 21 00 00 01 0140       ld hl,256*256 ; 360 degrees in 16.8 fixed point
0B257F ED 5B 0A 25 0141       ld de,(vectors)
       0B          
0B2584 CD 61 0B 0B 0142       call udiv168 ; ud.e = 256 / vectors
0B2588 ED 53 22 25 0143       ld (step_theta_petal),de ; store the result
       0B          
0B258D CD 5F 27 0B 0144       call print_step_theta_petal
0B2591             0145   
0B2591             0146   ; total_steps = int(petals * vectors * periods)
0B2591 2A 07 25 0B 0147       ld hl,(petals)
0B2595 ED 5B 0A 25 0148       ld de,(vectors)
       0B          
0B259A CD 36 0B 0B 0149       call umul168 ; uh.l = petals * vectors
0B259E CD A2 08 0B 0150       call hlu_udiv256 ; uh.l = int(petals * vectors)
0B25A2 EB          0151       ex de,hl ; de = petals * vectors
0B25A3 2A 10 25 0B 0152       ld hl,(periods)
0B25A7 CD A2 08 0B 0153       call hlu_udiv256 ; uh.l = int(periods)
0B25AB CD 11 09 0B 0154       call umul24 ; uh.l = int(petals * vectors * periods)
0B25AF 22 25 25 0B 0155       ld (total_steps),hl ; store the result
0B25B3 CD 72 27 0B 0156       call print_total_steps
0B25B7             0157   
0B25B7             0158   ; Calculate shrink per step (linear)
0B25B7             0159       ; step_shrink = -shrink * radius_scale / total_steps
0B25B7             0160   
0B25B7             0161       ; multiply first to maintain precision
0B25B7 2A 13 25 0B 0162       ld hl,(shrink)
0B25BB ED 5B 1C 25 0163       ld de,(radius_scale)
       0B          
0B25C0 CD 36 0B 0B 0164       call umul168 ; uh.l = shrink * radius_scale
0B25C4             0165       hlu_mul256 ; shift up a byte for even moar precision
0B25C4 29          0001M          add hl,hl ; * 2
0B25C5 29          0002M          add hl,hl ; * 4
0B25C6 29          0003M          add hl,hl ; * 8
0B25C7 29          0004M          add hl,hl ; * 16
0B25C8 29          0005M          add hl,hl ; * 32
0B25C9 29          0006M          add hl,hl ; * 64
0B25CA 29          0007M          add hl,hl ; * 128
0B25CB 29          0008M          add hl,hl ; * 256
0B25CC             0166   
0B25CC             0167       ; divide by total_steps
0B25CC ED 5B 25 25 0168       ld de,(total_steps)
       0B          
0B25D1 CD 61 0B 0B 0169       call udiv168 ; ud.e = shrink * radius_scale / total_steps
0B25D5 CD 4B 08 0B 0170       call neg_hlu ; uh.l = -shrink / total_steps
0B25D9 22 28 25 0B 0171       ld (step_shrink),hl ; store the result
0B25DD CD 8D 27 0B 0172       call print_step_shrink
0B25E1             0173   
0B25E1             0174   ; ; Initialize radius_prime
0B25E1             0175   ;     ; radius_prime = (1 - (depth / 2)) * radius_scale
0B25E1             0176   ;     ld hl,(depth)
0B25E1             0177   ;     ld de,1
0B25E1             0178   ;     call shr_hlu ; uh.l = depth / 2
0B25E1             0179   ;     ex de,hl ; de = depth / 2
0B25E1             0180   ;     ld hl,1*256 ; 1 in 16.8 fixed point
0B25E1             0181   ;     or a ; clear carry
0B25E1             0182   ;     sbc hl,de ; uh.l = 1 - depth / 2
0B25E1             0183   ;     ld de,(radius_scale)
0B25E1             0184   ;     call smul168 ; uh.l = (1 - depth / 2) * radius_scale
0B25E1             0185   ;     ld (radius_prime),hl ; store the result
0B25E1             0186   ;     ; call print_hex_hl
0B25E1             0187   ;     ; call print_s168_hl
0B25E1             0188   ;     ; call printNewLine
0B25E1 2A 1C 25 0B 0189       ld hl,(radius_scale)
0B25E5 22 31 25 0B 0190       ld (radius_prime),hl
0B25E9             0191   
0B25E9             0192   ; Set screen origin to the center
0B25E9 01 80 02 00 0193       ld bc,1280/2 ; x
0B25ED 11 00 02 00 0194       ld de,1024/2 ; y
0B25F1 CD A0 1F 0B 0195       call vdu_set_gfx_origin
0B25F5             0196   
0B25F5             0197   ; set initial point and move graphics cursor to it
0B25F5 CD 3D 26 0B 0198       call calc_point ; ub.c = x, ud.e = y
0B25F9 3E 44       0199       ld a,plot_pt+mv_abs ; plot mode
0B25FB CD D1 22 0B 0200       call vdu_plot_168
0B25FF             0201       ; fall through to main loop
0B25FF             0202   
0B25FF             0203   @loop:
0B25FF             0204       ; Advance theta values
0B25FF             0205           ; theta_prime += step_theta_prime
0B25FF 2A 2B 25 0B 0206           ld hl,(theta_prime)
0B2603 ED 5B 1F 25 0207           ld de,(step_theta_prime)
       0B          
0B2608 19          0208           add hl,de
0B2609 22 2B 25 0B 0209           ld (theta_prime),hl
0B260D             0210   
0B260D             0211           ; theta_petal += step_theta_petal
0B260D 2A 2E 25 0B 0212           ld hl,(theta_petal)
0B2611 ED 5B 22 25 0213           ld de,(step_theta_petal)
       0B          
0B2616 19          0214           add hl,de
0B2617 22 2E 25 0B 0215           ld (theta_petal),hl
0B261B             0216   
0B261B             0217       ; Update radius_prime
0B261B             0218           ; radius_prime += step_shrink
0B261B 2A 31 25 0B 0219           ld hl,(radius_prime)
0B261F ED 5B 28 25 0220           ld de,(step_shrink)
       0B          
0B2624 19          0221           add hl,de
0B2625 22 31 25 0B 0222           ld (radius_prime),hl
0B2629             0223   
0B2629             0224       ; Calculate new coordinates and draw a line from the previous point
0B2629 CD 3D 26 0B 0225           call calc_point ; ub.c = x, ud.e = y
0B262D 3E 05       0226           ld a,plot_sl_both+dr_abs_fg ; plot mode
0B262F CD D1 22 0B 0227           call vdu_plot_168
0B2633             0228   
0B2633             0229           ; call printNewLine
0B2633             0230           ; call print_theta_prime
0B2633             0231           ; call print_theta_petal
0B2633             0232           ; ; call print_radius_prime
0B2633             0233           ; ; call print_radius_petal
0B2633             0234           ; call print_radius
0B2633             0235           ; call print_xy
0B2633             0236   
0B2633             0237       ; Decrement the loop counter
0B2633 21 25 25 0B 0238           ld hl,total_steps
0B2637 35          0239           dec (hl)
0B2638 C2 FF 25 0B 0240           jp nz,@loop
0B263C C9          0241       ret
0B263D             0242   
0B263D             0243   ; compute the Cartesian coordinates of the next point on the curve
0B263D             0244   ; inputs: theta_prime, theta_petal, radius_prime, depth
0B263D             0245   ; outputs: ub.c = x, ud.e = y
0B263D             0246   calc_point:
0B263D             0247   ; Calculate the petal radius and total radius
0B263D             0248       ; radius_petal = math.cos(theta_petal) * depth
0B263D 2A 2E 25 0B 0249       ld hl,(theta_petal)
0B2641 CD D6 0C 0B 0250       call cos168 ; uh.l = cos(theta_petal)
0B2645 ED 5B 0D 25 0251       ld de,(depth)
       0B          
0B264A CD 3E 0B 0B 0252       call smul168 ; uh.l = radius_petal
0B264E 22 34 25 0B 0253       ld (radius_petal),hl
0B2652             0254   
0B2652             0255       ; radius = radius_prime + radius_petal * radius_prime
0B2652 ED 5B 31 25 0256       ld de,(radius_prime)
       0B          
0B2657 CD 3E 0B 0B 0257       call smul168 ; uh.l = radius_petal * radius_prime
0B265B 19          0258       add hl,de ; uh.l = radius_prime + radius_petal * radius_prime
0B265C EB          0259       ex de,hl ; de = radius
0B265D ED 53 37 25 0260       ld (radius),de
       0B          
0B2662             0261   
0B2662             0262   ; Convert polar to Cartesian coordinates
0B2662             0263       ; x, y = polar_to_cartesian(radius, theta_prime)
0B2662 2A 2B 25 0B 0264       ld hl,(theta_prime)
0B2666 CD 15 0D 0B 0265       call polar_to_cartesian ; ub.c = x, ud.e = y
0B266A ED 43 3A 25 0266       ld (x_prev),bc
       0B          
0B266F ED 53 3D 25 0267       ld (y_prev),de
       0B          
0B2674             0268   
0B2674             0269   ; ; Debug print
0B2674             0270   ;     call print_hex_bc
0B2674             0271   ;     call print_s168_bc
0B2674             0272   ;     call print_hex_de
0B2674             0273   ;     call print_s168_de
0B2674             0274   ;     ; call printNewLine
0B2674             0275   
0B2674             0276   ; all done
0B2674 C9          0277       ret
0B2675             0278   
0B2675             0279   
0B2675             0280   
0B2675             0281   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B2675             0282   main:
0B2675 0D          0283       dec c               ; decrement the argument count to skip the program name
0B2676 CD 82 26 0B 0284       call load_input     ; load the input arguments
0B267A CD 40 25 0B 0285       call main_loop      ; run the main loop
0B267E C3 FE 24 0B 0286       jp _main_end_ok     ; exit with success
0B2682             0287   
0B2682             0288   ; --- Load arguments ---
0B2682             0289   ; --------------------------------
0B2682             0290   load_input:
0B2682 79          0291       ld a,c ; put the number of entered arguments in a
0B2683 06 05       0292       ld b,input_params_num ; loop counter = number of arguments
0B2685 B8          0293       cp b ; compare the number of arguments to the number of arguments
0B2686 C4 9C 26 0B 0294       call nz,args_count_off ; handle discrepancies
0B268A             0295       ; TODO: we may want to branch here according to the result
0B268A FD 21 07 25 0296       ld iy,input_params  ; point to the arguments table
       0B          
0B268F             0297   @loop:
0B268F CD 1A 28 0B 0298           call get_arg_s168 ; get the next argument
0B2693 FD 1F 00    0299           ld (iy),de ; store the argument in the table
0B2696 ED 33 03    0300           lea iy,iy+3  ; point to the next parameter
0B2699 10 F4       0301           djnz @loop ; loop until done
0B269B C9          0302           ret
0B269C             0303   
0B269C             0304   ; --- Specific parameter processing functions ---
0B269C             0305   args_count_off:
0B269C 21 A5 26 0B 0306       ld hl,@str_args_count_off
0B26A0 CD 73 02 0B 0307       call printString
0B26A4 C9          0308       ret ; TODO: implement this
0B26A5 41 72 67 75 0309   @str_args_count_off: db "Argument counts mismatch!\r\n",0
       6D 65 6E 74 
       20 63 6F 75 
       6E 74 73 20 
       6D 69 73 6D 
       61 74 63 68 
       21 0D 0A 00 
0B26C1             0310   
0B26C1             0311   ; ---- text strings ----
0B26C1 73 74 65 70 0312   str_step_theta_prime: ASCIZ "step_theta_prime: "
       5F 74 68 65 
       74 61 5F 70 
       72 69 6D 65 
       3A 20 00    
0B26D4 73 74 65 70 0313   str_step_theta_petal: ASCIZ "step_theta_petal: "
       5F 74 68 65 
       74 61 5F 70 
       65 74 61 6C 
       3A 20 00    
0B26E7 74 6F 74 61 0314   str_total_steps: ASCIZ "total_steps: "
       6C 5F 73 74 
       65 70 73 3A 
       20 00       
0B26F5 73 74 65 70 0315   str_step_shrink: ASCIZ "step_shrink: "
       5F 73 68 72 
       69 6E 6B 3A 
       20 00       
0B2703             0316   
0B2703 74 68 65 74 0317   str_theta_prime: ASCIZ "theta_prime: "
       61 5F 70 72 
       69 6D 65 3A 
       20 00       
0B2711 72 61 64 69 0318   str_radius_prime: ASCIZ "radius_prime: "
       75 73 5F 70 
       72 69 6D 65 
       3A 20 00    
0B2720 72 61 64 69 0319   str_radius_petal: ASCIZ "radius_petal: "
       75 73 5F 70 
       65 74 61 6C 
       3A 20 00    
0B272F 74 68 65 74 0320   str_theta_petal: ASCIZ "theta_petal: "
       61 5F 70 65 
       74 61 6C 3A 
       20 00       
0B273D             0321   
0B273D 72 61 64 69 0322   str_radius: ASCIZ "radius: "
       75 73 3A 20 
       00          
0B2746 78 2C 79 3A 0323   str_xy: ASCIZ "x,y: "
       20 00       
0B274C             0324   
0B274C             0325   print_step_theta_prime:
0B274C E5          0326       push hl
0B274D 21 C1 26 0B 0327       ld hl,str_step_theta_prime
0B2751 CD 73 02 0B 0328       call printString
0B2755 2A 1F 25 0B 0329       ld hl,(step_theta_prime)
0B2759             0330       ; call print_hex_hl
0B2759 CD 4D 04 0B 0331       call print_s168_hl
0B275D             0332       ; call printNewLine
0B275D E1          0333       pop hl
0B275E C9          0334       ret
0B275F             0335   
0B275F             0336   print_step_theta_petal:
0B275F E5          0337       push hl
0B2760 21 D4 26 0B 0338       ld hl,str_step_theta_petal
0B2764 CD 73 02 0B 0339       call printString
0B2768 2A 22 25 0B 0340       ld hl,(step_theta_petal)
0B276C             0341       ; call print_hex_hl
0B276C CD 4D 04 0B 0342       call print_s168_hl
0B2770             0343       ; call printNewLine
0B2770 E1          0344       pop hl
0B2771 C9          0345       ret
0B2772             0346   
0B2772             0347   print_total_steps:
0B2772 E5          0348       push hl
0B2773 21 E7 26 0B 0349       ld hl,str_total_steps
0B2777 CD 73 02 0B 0350       call printString
0B277B 2A 25 25 0B 0351       ld hl,(total_steps)
0B277F             0352       hlu_mul256 ; uh.l = total_steps 16.8 fixed
0B277F 29          0001M          add hl,hl ; * 2
0B2780 29          0002M          add hl,hl ; * 4
0B2781 29          0003M          add hl,hl ; * 8
0B2782 29          0004M          add hl,hl ; * 16
0B2783 29          0005M          add hl,hl ; * 32
0B2784 29          0006M          add hl,hl ; * 64
0B2785 29          0007M          add hl,hl ; * 128
0B2786 29          0008M          add hl,hl ; * 256
0B2787             0353       ; call print_hex_hl
0B2787 CD 4D 04 0B 0354       call print_s168_hl
0B278B             0355       ; call printNewLine
0B278B E1          0356       pop hl
0B278C C9          0357       ret
0B278D             0358   
0B278D             0359   print_step_shrink:
0B278D E5          0360       push hl
0B278E 21 F5 26 0B 0361       ld hl,str_step_shrink
0B2792 CD 73 02 0B 0362       call printString
0B2796 2A 28 25 0B 0363       ld hl,(step_shrink)
0B279A             0364       ; call print_hex_hl
0B279A CD 4D 04 0B 0365       call print_s168_hl
0B279E             0366       ; call printNewLine
0B279E E1          0367       pop hl
0B279F C9          0368       ret
0B27A0             0369   
0B27A0             0370   print_theta_prime:
0B27A0 E5          0371       push hl
0B27A1 21 03 27 0B 0372       ld hl,str_theta_prime
0B27A5 CD 73 02 0B 0373       call printString
0B27A9 2A 2B 25 0B 0374       ld hl,(theta_prime)
0B27AD             0375       ; call print_hex_hl
0B27AD CD 4D 04 0B 0376       call print_s168_hl
0B27B1             0377       ; call printNewLine
0B27B1 E1          0378       pop hl
0B27B2 C9          0379       ret
0B27B3             0380   
0B27B3             0381   print_radius_prime:
0B27B3 E5          0382       push hl
0B27B4 21 11 27 0B 0383       ld hl,str_radius_prime
0B27B8 CD 73 02 0B 0384       call printString
0B27BC 2A 31 25 0B 0385       ld hl,(radius_prime)
0B27C0             0386       ; call print_hex_hl
0B27C0 CD 4D 04 0B 0387       call print_s168_hl
0B27C4             0388       ; call printNewLine
0B27C4 E1          0389       pop hl
0B27C5 C9          0390       ret
0B27C6             0391   
0B27C6             0392   print_theta_petal:
0B27C6 E5          0393       push hl
0B27C7 21 2F 27 0B 0394       ld hl,str_theta_petal
0B27CB CD 73 02 0B 0395       call printString
0B27CF 2A 2E 25 0B 0396       ld hl,(theta_petal)
0B27D3             0397       ; call print_hex_hl
0B27D3 CD 4D 04 0B 0398       call print_s168_hl
0B27D7             0399       ; call printNewLine
0B27D7 E1          0400       pop hl
0B27D8 C9          0401       ret
0B27D9             0402   
0B27D9             0403   print_radius_petal:
0B27D9 E5          0404       push hl
0B27DA 21 20 27 0B 0405       ld hl,str_radius_petal
0B27DE CD 73 02 0B 0406       call printString
0B27E2 2A 34 25 0B 0407       ld hl,(radius_petal)
0B27E6             0408       ; call print_hex_hl
0B27E6 CD 4D 04 0B 0409       call print_s168_hl
0B27EA             0410       ; call printNewLine
0B27EA E1          0411       pop hl
0B27EB C9          0412       ret
0B27EC             0413   
0B27EC             0414   print_radius:
0B27EC E5          0415       push hl
0B27ED 21 3D 27 0B 0416       ld hl,str_radius
0B27F1 CD 73 02 0B 0417       call printString
0B27F5 2A 37 25 0B 0418       ld hl,(radius)
0B27F9             0419       ; call print_hex_hl
0B27F9 CD 4D 04 0B 0420       call print_s168_hl
0B27FD             0421       ; call printNewLine
0B27FD E1          0422       pop hl
0B27FE C9          0423       ret
0B27FF             0424   
0B27FF             0425   print_xy:
0B27FF E5          0426       push hl
0B2800 21 46 27 0B 0427       ld hl,str_xy
0B2804 CD 73 02 0B 0428       call printString
0B2808 2A 3A 25 0B 0429       ld hl,(x_prev)
0B280C CD 4D 04 0B 0430       call print_s168_hl
0B2810 2A 3D 25 0B 0431       ld hl,(y_prev)
0B2814 CD 4D 04 0B 0432       call print_s168_hl
0B2818             0433       ; call printNewLine
0B2818 E1          0434       pop hl
0B2819 C9          0435       ret
0B281A             0436   
0B281A             0437   ; ========== HELPER FUNCTIONS ==========
0B281A             0438   ; get the next argument after ix as a signed 16.8 fixed point number
0B281A             0439   ; inputs: ix = pointer to the argument string
0B281A             0440   ; outputs: ude = signed 16.8 fixed point number
0B281A             0441   ; destroys: a, d, e, h, l, f
0B281A             0442   get_arg_s168:
0B281A ED 32 03    0443       lea ix,ix+3 ; point to the next argument
0B281D DD 27 00    0444       ld hl,(ix)  ; get the argument string
0B2820 CD 94 01 0B 0445       call asc_to_s168 ; convert the string to a number
0B2824 C9          0446       ret ; return with the value in DE
0B2825             0447   
0B2825             0448   ; Inputs: ix = pointer to the argument string
0B2825             0449   ; Outputs: ude = signed 24-bit integer
0B2825             0450   ; Destroys: a, d, e, h, l, f
0B2825             0451   get_arg_s24:
0B2825 ED 32 03    0452       lea ix,ix+3 ; point to the next argument
0B2828 DD 27 00    0453       ld hl,(ix)  ; get the argument string
0B282B CD 45 01 0B 0454       call asc_to_s24 ; convert the string to a number
0B282F C9          0455       ret ; return with the value in DE
0B2830             0456   
0B2830             0457   get_plot_coords:
0B2830             0458   ; get the move coordinates
0B2830 ED 32 03    0459       lea ix,ix+3 ; pointer to next argument address
0B2833 DD 27 00    0460       ld hl,(ix)  ; pointer to the x coordinate string
0B2836 CD 94 01 0B 0461       call asc_to_s168 ; de = x coordinate
0B283A D5          0462       push de
0B283B C1          0463       pop bc ; bc = x coordinate
0B283C ED 32 03    0464       lea ix,ix+3 ; pointer to next argument address
0B283F DD 27 00    0465       ld hl,(ix)  ; pointer to the y coordinate string
0B2842 CD 94 01 0B 0466       call asc_to_s168 ; de = y coordinate
0B2846 C9          0467       ret
0B2847             0468   
0B2847             0469   get_arg_text:
0B2847 ED 32 03    0470       lea ix,ix+3 ; point to the next argument
0B284A DD 27 00    0471       ld hl,(ix)  ; get the argument string
0B284D C9          0472       ret
0B284E             0473   
0B284E             0474   ; match the next argument after ix to the dispatch table at iy
0B284E             0475   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B284E             0476   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B284E             0477   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B284E             0478   ;          ON MATCH: iy=dispatch address, a=0 and zero flag set
0B284E             0479   ; destroys: a, hl, de, ix, iy, flags
0B284E             0480   match_next:
0B284E ED 32 03    0481       lea ix,ix+3         ; point to the next argument
0B2851             0482   @loop:
0B2851 FD 27 00    0483       ld hl,(iy)          ; pointer argument dispatch record
0B2854             0484       sign_hlu            ; check for list terminator
0B2854 19          0001M          add hl,de
0B2855 B7          0002M          or a
0B2856 ED 52       0003M          sbc hl,de
0B2858 CA 70 28 0B 0485       jp z,@no_match      ; if a=0, return error
0B285C 23          0486       inc hl              ; skip over jp instruction
0B285D 23          0487       inc hl
0B285E DD 17 00    0488       ld de,(ix)          ; pointer to the argument string
0B2861 CD 87 28 0B 0489       call str_equal      ; compare the argument to the dispatch table entry
0B2865 CA 72 28 0B 0490       jp z,@match         ; if equal, return success
0B2869 ED 33 03    0491       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B286C C3 51 28 0B 0492       jp @loop            ; and loop
0B2870             0493   @no_match:
0B2870 3C          0494       inc a               ; no match so return a=1 and zero flag reset
0B2871 C9          0495       ret
0B2872             0496   @match:
0B2872 FD 37 00    0497       ld iy,(iy)          ; get the function pointer
0B2875 C9          0498       ret                 ; return a=0 and zero flag set
0B2876             0499   
0B2876             0500   ; same as match_next, but prints the parameter if a match is found
0B2876             0501   match_next_and_print:
0B2876 CD 4E 28 0B 0502       call match_next
0B287A C0          0503       ret nz ; no match found
0B287B ED 32 FD    0504       lea ix,ix-3
0B287E CD 47 28 0B 0505       call get_arg_text ; hl points to the operator string
0B2882 CD 92 28 0B 0506       call print_param
0B2886 C9          0507       ret
0B2887             0508   
0B2887             0509   ; compare two zero-terminated strings for equality, case-sensitive
0B2887             0510   ; hl: pointer to first string, de: pointer to second string
0B2887             0511   ; returns: z if equal, nz if not equal
0B2887             0512   ; destroys: a, hl, de
0B2887             0513   str_equal:
0B2887 1A          0514       ld a,(de)           ; get the first character
0B2888 BE          0515       cp (hl)             ; compare to the second character
0B2889 C0          0516       ret nz              ; if not equal, return
0B288A B7          0517       or a
0B288B C8          0518       ret z               ; if equal and zero, return
0B288C 23          0519       inc hl              ; next character
0B288D 13          0520       inc de
0B288E C3 87 28 0B 0521       jp str_equal        ; loop until end of string
0B2892             0522   
0B2892             0523   ; print the parameter string pointed to by ix
0B2892             0524   ; destroys: a, hl
0B2892             0525   print_param:
0B2892 DD 27 00    0526       ld hl,(ix)          ; get the parameter pointer
0B2895 CD 73 02 0B 0527       call printString    ; print the parameter string
0B2899 3E 20       0528       ld a,' '            ; print a space separator
0B289B 5B D7       0529       rst.lil $10
0B289D C9          0530       ret
0B289E             0531   
0B289E             0532   ; print the parameters
0B289E             0533   ; inputs: b = number of parameters, ix = pointer to the parameters
0B289E             0534   ; destroys: a, hl, bc
0B289E             0535   print_params:
0B289E 41          0536       ld b,c              ; loop counter = number of parameters
0B289F DD E5       0537       push ix             ; save the pointer to the parameters
0B28A1             0538   @loop:
0B28A1 C5          0539       push bc             ; save the loop counter
0B28A2 CD 92 28 0B 0540       call print_param    ; print the parameter
0B28A6 ED 32 03    0541       lea ix,ix+3         ; next parameter pointer
0B28A9 C1          0542       pop bc              ; get back the loop counter
0B28AA 10 F5       0543       djnz @loop          ; loop until done
0B28AC DD E1       0544       pop ix              ; restore the pointer to the parameters
0B28AE C9          0545       ret
