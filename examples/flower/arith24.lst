PC     Output      Line
040000             0001  
040000             0002  arith24uaf: ds 6
040006             0003  arith24uhl: ds 6
04000C             0004  arith24ubc: ds 6
040012             0005  arith24ude: ds 6
040018             0006  arith24uix: ds 6
04001E             0007  arith24uiy: ds 6
040024             0008  arith24usp: ds 6
04002A             0009  arith24upc: ds 6
040030             0010  
040030             0011  ;------------------------------------------------------------------------
040030             0012  ;  arith24.asm
040030             0013  ;  24-bit ez80 arithmetic routines
040030             0014  ;  Copyright (c) Shawn Sijnstra 2024
040030             0015  ;  MIT license
040030             0016  ;
040030             0017  ;  This library was created as a tool to help make ez80
040030             0018  ;  24-bit native assembly routines for simple mathematical problems
040030             0019  ;  more widely available.
040030             0020  ;
040030             0021  ;------------------------------------------------------------------------
040030             0022  
040030             0023  ;------------------------------------------------------------------------
040030             0024  ; umul24:	HL = HL*DE (unsigned)
040030             0025  ; Preserves AF, BC, DE
040030             0026  ; Uses a fast multiply routine.
040030             0027  ;------------------------------------------------------------------------
040030             0028  umul24:
040030 D5          0029  	push	DE
040031 C5          0030  	push	BC
040032 F5          0031  	push	AF
040033 E5          0032  	push	HL
040034 C1          0033  	pop		BC
040035 3E 18       0034      ld	 	a, 24 ; No. of bits to process
040037 21 00 00 00 0035      ld	 	hl, 0 ; Result
04003B             0036  umul24_lp:
04003B 29          0037  	add	hl,hl
04003C EB          0038  	ex	de,hl
04003D 29          0039  	add	hl,hl
04003E EB          0040  	ex	de,hl
04003F 30 01       0041  	jr	nc,umul24_nc
040041 09          0042  	add	hl,bc
040042             0043  umul24_nc:
040042 3D          0044  	dec	a
040043 20 F6       0045  	jr	nz,umul24_lp
040045 F1          0046  	pop	af
040046 C1          0047  	pop	bc
040047 D1          0048  	pop	de
040048 C9          0049  	ret
040049             0050  
040049             0051  
040049             0052  ;------------------------------------------------------------------------
040049             0053  ; udiv24
040049             0054  ; Unsigned 24-bit division
040049             0055  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
040049             0056  ;
040049             0057  ; Uses AF BC DE HL
040049             0058  ; Uses Restoring Division algorithm
040049             0059  ;------------------------------------------------------------------------
040049             0060  
040049             0061  udiv24:
040049 E5          0062  	push	hl
04004A C1          0063  	pop		bc	;move dividend to BCU
04004B 21 00 00 00 0064  	ld		hl,0	;result
04004F A7          0065  	and		a
040050 ED 52       0066  	sbc		hl,de	;test for div by 0
040052 C8          0067  	ret		z		;it's zero, carry flag is clear
040053 19          0068  	add		hl,de	;HL is 0 again
040054 3E 18       0069  	ld		a,24	;number of loops through.
040056             0070  udiv1:
040056 C5          0071  	push	bc	;complicated way of doing this because of lack of access to top bits
040057 E3          0072  	ex		(sp),hl
040058 37          0073  	scf
040059 ED 6A       0074  	adc	hl,hl
04005B E3          0075  	ex	(sp),hl
04005C C1          0076  	pop	bc		;we now have bc = (bc * 2) + 1
04005D             0077  
04005D ED 6A       0078  	adc	hl,hl
04005F A7          0079  	and	a		;is this the bug
040060 ED 52       0080  	sbc	hl,de
040062 30 02       0081  	jr	nc,udiv2
040064 19          0082  	add	hl,de
040065             0083  ;	dec	c
040065 0B          0084  	dec	bc
040066             0085  udiv2:
040066 3D          0086  	dec	a
040067 20 ED       0087  	jr	nz,udiv1
040069 37          0088  	scf		;flag used for div0 error
04006A C5          0089  	push	bc
04006B D1          0090  	pop		de	;remainder
04006C C9          0091  	ret
04006D             0092  
04006D             0093  
04006D             0094  
04006D             0095  ;------------------------------------------------------------------------
04006D             0096  ; neg24
04006D             0097  ; Returns: HLU = 0-HLU
04006D             0098  ; preserves all other registers
04006D             0099  ;------------------------------------------------------------------------
04006D             0100  neg24:
04006D D5          0101  	push	de
04006E EB          0102  	ex		de,hl
04006F 21 00 00 00 0103  	ld		hl,0
040073 B7          0104  	or		a
040074 ED 52       0105  	sbc		hl,de
040076 D1          0106  	pop		de
040077 C9          0107  	ret
040078             0108  
040078             0109  ;------------------------------------------------------------------------
040078             0110  ; or_hlu_deu: 24 bit bitwise OR
040078             0111  ; Returns: hlu = hlu OR deu
040078             0112  ; preserves all other registers
040078             0113  ;------------------------------------------------------------------------
040078             0114  or_hlu_deu:
040078 22 03 01 04 0115  	ld	(bitbuf1),hl
04007C ED 53 06 01 0116  	ld	(bitbuf2),de
       04          
040081 D5          0117  	push	de	;preserve DEU
040082 C5          0118  	push	bc	;preserve BCU
040083 06 03       0119  	ld		b,3
040085 21 03 01 04 0120  	ld	hl,bitbuf1
040089 11 03 01 04 0121  	ld	de,bitbuf1
04008D             0122  orloop_24:
04008D 1A          0123  	ld	a,(de)
04008E B6          0124  	or	(hl)
04008F 12          0125  	ld	(de),a
040090 13          0126  	inc	de
040091 23          0127  	inc	hl
040092 10 F9       0128  	djnz	orloop_24
040094 2A 06 01 04 0129  	ld	hl,(bitbuf2)
040098 C1          0130  	pop		bc	;restore BC
040099 D1          0131  	pop		de	;restore DE
04009A             0132  
04009A             0133  ;------------------------------------------------------------------------
04009A             0134  ; and_hlu_deu: 24 bit bitwise AND
04009A             0135  ; Returns: hlu = hlu AND deu
04009A             0136  ; preserves all other registers
04009A             0137  ;------------------------------------------------------------------------
04009A             0138  and_hlu_deu:
04009A 22 03 01 04 0139  	ld	(bitbuf1),hl
04009E ED 53 06 01 0140  	ld	(bitbuf2),de
       04          
0400A3 D5          0141  	push	de	;preserve DEU
0400A4 C5          0142  	push	bc	;preserve BCU
0400A5 06 03       0143  	ld		b,3
0400A7 21 03 01 04 0144  	ld	hl,bitbuf1
0400AB 11 03 01 04 0145  	ld	de,bitbuf1
0400AF             0146  andloop_24:
0400AF 1A          0147  	ld	a,(de)
0400B0 A6          0148  	and	(hl)
0400B1 12          0149  	ld	(de),a
0400B2 13          0150  	inc	de
0400B3 23          0151  	inc	hl
0400B4 10 F9       0152  	djnz	andloop_24
0400B6 2A 06 01 04 0153  	ld	hl,(bitbuf2)
0400BA C1          0154  	pop		bc	;restore BC
0400BB D1          0155  	pop		de	;restore DE
0400BC             0156  
0400BC             0157  ;------------------------------------------------------------------------
0400BC             0158  ; xor_hlu_deu: 24 bit bitwise XOR
0400BC             0159  ; Returns: hlu = hlu XOR deu
0400BC             0160  ; preserves all other registers
0400BC             0161  ;------------------------------------------------------------------------
0400BC             0162  xor_hlu_deu:
0400BC 22 03 01 04 0163  	ld	(bitbuf1),hl
0400C0 ED 53 06 01 0164  	ld	(bitbuf2),de
       04          
0400C5 D5          0165  	push	de	;preserve DEU
0400C6 C5          0166  	push	bc	;preserve BCU
0400C7 06 03       0167  	ld		b,3
0400C9 21 03 01 04 0168  	ld	hl,bitbuf1
0400CD 11 03 01 04 0169  	ld	de,bitbuf1
0400D1             0170  xorloop_24:
0400D1 1A          0171  	ld	a,(de)
0400D2 AE          0172  	xor	(hl)
0400D3 12          0173  	ld	(de),a
0400D4 13          0174  	inc	de
0400D5 23          0175  	inc	hl
0400D6 10 F9       0176  	djnz	xorloop_24
0400D8 2A 06 01 04 0177  	ld	hl,(bitbuf2)
0400DC C1          0178  	pop		bc	;restore BC
0400DD D1          0179  	pop		de	;restore DE
0400DE             0180  
0400DE             0181  ;------------------------------------------------------------------------
0400DE             0182  ; shl_hlu: 24 bit shift left hlu by deu positions
0400DE             0183  ; Returns: hlu = hlu << deu
0400DE             0184  ;		   de = 0
0400DE             0185  ; NOTE: only considers deu up to 16 bits.
0400DE             0186  ; preserves all other registers
0400DE             0187  ;------------------------------------------------------------------------
0400DE             0188  shl_hlu:
0400DE 7A          0189  	ld		a,d		;up to 16 bit.
0400DF B3          0190  	or		e
0400E0 C8          0191  	ret		z		;we're done
0400E1 29          0192  	add		hl,hl	;shift HLU left
0400E2 1B          0193  	dec		de
0400E3 18 F9       0194  	jr		shl_hlu
0400E5             0195  
0400E5             0196  ;------------------------------------------------------------------------
0400E5             0197  ; shr_hlu: 24 bit shift right hlu by deu positions
0400E5             0198  ; Returns: hlu = hlu >> deu
0400E5             0199  ;		   de = 0
0400E5             0200  ; NOTE: only considers deu up to 16 bits.
0400E5             0201  ; preserves all other registers
0400E5             0202  ;------------------------------------------------------------------------
0400E5             0203  shr_hlu:
0400E5 22 03 01 04 0204  	ld		(bitbuf1),hl
0400E9 21 05 01 04 0205  	ld		hl,bitbuf1+2
0400ED             0206  shr_loop:
0400ED 7A          0207  	ld		a,d		;up to 16 bit.
0400EE B3          0208  	or		e
0400EF 28 0D       0209  	jr		z,shr_done		;we're done
0400F1             0210  ;carry is clear from or instruction
0400F1 CB 1E       0211  	rr		(hl)
0400F3 2B          0212  	dec		hl
0400F4 CB 1E       0213  	rr		(hl)
0400F6 2B          0214  	dec		hl
0400F7 CB 1E       0215  	rr		(hl)
0400F9 23          0216  	inc		hl
0400FA 23          0217  	inc		hl
0400FB 1B          0218  	dec		de
0400FC 18 EF       0219  	jr		shr_loop
0400FE             0220  shr_done:
0400FE 2A 03 01 04 0221  	ld		hl,(bitbuf1)	;collect result
040102 C9          0222  	ret
040103             0223  
040103             0224  ;------------------------------------------------------------------------
040103             0225  ; Scratch area for calculations
040103             0226  ;------------------------------------------------------------------------
040103 00 00 00    0227  bitbuf1:	dw24	0	;bit manipulation buffer 1
040106 00 00 00    0228  bitbuf2:	dw24	0	;bit manipulation buffer 2
040109             0229  
040109             0230  ; ========== FROM maths24.inc ==========
040109             0231  
040109             0232  ; http://www.z80.info/pseudo-random.txt
040109             0233  rand_8:
040109 C5          0234      push bc
04010A 3A 1D 01 04 0235      ld a,(r_seed)
04010E 4F          0236      ld c,a
04010F             0237  
04010F 0F          0238      rrca ; multiply by 32
040110 0F          0239      rrca
040111 0F          0240      rrca
040112 EE 1F       0241      xor 0x1f
040114             0242  
040114 81          0243      add a,c
040115 DE FF       0244      sbc a,255 ; carry
040117             0245  
040117 32 1D 01 04 0246      ld (r_seed),a
04011B C1          0247      pop bc
04011C C9          0248      ret
04011D 50          0249  r_seed: defb $50
04011E             0250  
04011E             0251  ; tests the sign of 24-bit register hlu
04011E             0252  ; returns: a in [-1,0,1]
04011E             0253  ;   sign and zero flags as expected
04011E             0254  ;   hl is untouched
04011E             0255  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
04011E             0256  ; and it left the zero flag set after ld a,1,which i fixed by anding it
04011E             0257  get_sign_hlu:
04011E             0258      ; Load the upper byte of HLU into A
04011E E5          0259      push hl
04011F DD 21 00 00 0260      ld ix,0
       00          
040124 DD 39       0261      add ix,sp
040126 DD 7E 02    0262      ld a,(ix+2)
040129 E1          0263      pop hl
04012A             0264  
04012A B5          0265      or l                ; OR with the low byte to check if HL is zero
04012B C8          0266      ret z               ; Return if HL is zero
04012C             0267  
04012C 3E FF       0268      ld a,-1             ; Send A back as -1 if the sign flag is set
04012E CB 7C       0269      bit 7,h            ; Test the sign bit (7th bit) of the high byte
040130 C0          0270      ret nz              ; If set,HL is negative,return with the sign flag set
040131             0271  
040131 3E 01       0272      ld a,1             ; Otherwise,HL is positive
040133 A7          0273      and a               ; Reset the zero flag
040134 C9          0274      ret                 ; Return with A set to 1
040135             0275  
040135             0276  ; convert angles from a 360 to 255 degree circle
040135             0277  ; inputs: uh.l is the angle360 in 16.8 fixed format
040135             0278  ; outputs: uh.l is the angle255 in 16.8 fixed format
040135             0279  ; destroys: TODO
040135             0280  ; note: even though the inputs and outputs are 16.8 fixed format
040135             0281  ;       precision is effectively limited to 8.8 fixed format
040135             0282  deg_360_to_255:
040135             0283  
040135             0284  @scratch: ds 6 ; scratch area for fast byte-shifting 24-bit registers
04013B             0285  
04013B             0286  ; 16.8 fixed inputs / outputs
04013B             0287  ; takes: uh.l as angle in degrees 256
04013B             0288  ;        ud.e as radius
04013B             0289  ; returns ub.c as dx, ud.e as dy
04013B             0290  ;        displacements from origin (0,0)
04013B             0291  ; destroys: everything except indexes
04013B             0292  polar_to_cartesian:
04013B             0293  ; back up input parameters
04013B 22 06 00 04 0294      ld (arith24uhl), hl
04013F ED 53 12 00 0295      ld (arith24ude), de
       04          
040144             0296  ; compute dx = sin(uh.l) * ud.e
040144 CD 73 01 04 0297      call sin168
040148 E5          0298      push hl
040149 C1          0299      pop bc          ; ub.c = sin(uh.l)
04014A ED 5B 12 00 0300  	ld de, (arith24ude)   ; get radius back
       04          
04014F CD CC 0A 04 0301  	call smul168    ; uh.l = ub.c * ud.e = dx
040153 E5          0302      push hl         ; store dx for output
040154             0303  ; compute dy = -cos(uh.l) * ud.e
040154 2A 06 00 04 0304      ld hl, (arith24uhl)
040158 CD 6E 01 04 0305      call cos168
04015C CD 3E 0A 04 0306  	call neg_hlu    ; invert dy for screen coords convention
040160 E5          0307      push hl
040161 C1          0308      pop bc          ; ub.c = -cos(uh.l)
040162 ED 5B 12 00 0309      ld de, (arith24ude)   ; get radius back
       04          
040167 CD CC 0A 04 0310      call smul168    ; uh.l = ub.c * ud.e = dy
04016B EB          0311      ex de, hl       ; de = dy for output
04016C C1          0312      pop bc          ; bc = dx for output
04016D             0313  ; and out
04016D C9          0314      ret
04016E             0315  
04016E             0316  
04016E             0317  
04016E             0318  
04016E             0319  ; fixed 16.8 routine
04016E             0320  ; cos(uh.l) --> uh.l
04016E             0321  ; destroys: de
04016E             0322  cos168:
04016E             0323  ; for cos we simply increment the angle by 90 degrees
04016E             0324  ; or 0x004000 in 16.8 degrees256
04016E             0325  ; which makes it a sin problem
04016E 11 00 40 00 0326      ld de,0x004000
040172 19          0327      add hl,de ; modulo 256 happens below
040173             0328  ; fall through to sin168
040173             0329  ; ---------------------
040173             0330  ; fixed 16.8 routine
040173             0331  ; sin(uh.l) --> uh.l
040173             0332  ; destroys: de
040173             0333  sin168:
040173             0334  ; h contains the integer portion of our angle
040173             0335  ; we multiply it by three to get our lookup table index
040173 2E 03       0336      ld l,3
040175 ED 6C       0337      mlt hl ; gosh that is handy
040177 11 00 00 00 0338      ld de,0 ; clear deu
04017B 54          0339      ld d,h ; copy hl to de
04017C 5D          0340      ld e,l ; de contains our index
04017D 21 84 03 04 0341      ld hl,sin_lut_168 ; grab the lut address
040181 19          0342      add hl,de ; bump hl by the index
040182 ED 27       0343      ld hl,(hl) ; don't try this on a z80!
040184 C9          0344      ret ; and out
040185             0345  
040185             0346  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
040185             0347  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
040185             0348  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
040185             0349  ;         also populates scratch locations dx168 and dy168
040185             0350  ; destroys: a,hl,bc,de
040185             0351  dxy168:
040185             0352  ; compute dx = x1-x0
040185 AF          0353      xor a ; clear carry
040186 DD E5       0354      push ix ; move ix to hl via the stack
040188 E1          0355      pop hl ; hl = x1
040189 ED 42       0356      sbc hl,bc ; hl = dx
04018B 22 E0 01 04 0357      ld (dx168),hl ; dx to scratch
04018F             0358  ; compute dy = y1-y0
04018F AF          0359      xor a ; clear carry
040190 FD E5       0360      push iy ; move iy to hl via the stack
040192 E1          0361      pop hl ; hl = y1
040193 ED 52       0362      sbc hl,de ; hl = dy
040195 22 E6 01 04 0363      ld (dy168),hl ; dy to scratch
040199             0364  ; populate output registers and return
040199 EB          0365      ex de,hl        ; ud.e = dy
04019A ED 4B E0 01 0366      ld bc,(dx168)   ; ub.c = dx
       04          
04019F C9          0367      ret
0401A0             0368  
0401A0             0369  ; compute the euclidian distance between two cartesian coordinates
0401A0             0370  ; using the formula d = sqrt(dx^2+dy^2
0401A0             0371  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0401A0             0372  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0401A0             0373  ; output; uh.l is the 16.8 fixed format distance
0401A0             0374  ;       dx168/y are the 16.8 fixed format dx and dy
0401A0             0375  ; destroys: a,hl,bc,de
0401A0             0376  distance168:
0401A0             0377  ; compute dx = x1-x0
0401A0 AF          0378      xor a ; clear carry
0401A1 DD E5       0379      push ix ; move ix to hl via the stack
0401A3 E1          0380      pop hl ; hl = x1
0401A4 ED 42       0381      sbc hl,bc ; hl = dx
0401A6 22 E0 01 04 0382      ld (dx168),hl ; dx to scratch
0401AA             0383  ; ; test dx for overflow
0401AA             0384  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0401AA             0385  ; 	ex de,hl
0401AA             0386  ; 	sbc hl,de ; test for overflow
0401AA             0387  ; 	push af ; carry indicates overflow
0401AA             0388  ; compute dy = y1-y0
0401AA AF          0389      xor a ; clear carry
0401AB FD E5       0390      push iy ; move iy to hl via the stack
0401AD E1          0391      pop hl ; hl = y1
0401AE ED 52       0392      sbc hl,de ; hl = dy
0401B0 22 E6 01 04 0393      ld (dy168),hl ; dy to scratch
0401B4             0394  ; ; test dy for overflow
0401B4             0395  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0401B4             0396  ; 	ex de,hl
0401B4             0397  ; 	sbc hl,de ; test for overflow
0401B4             0398  ; 	push af ; carry indicates overflow
0401B4             0399  ; compute dy^2
0401B4 2A E6 01 04 0400  	ld hl,(dy168)
0401B8 CD 2E 0A 04 0401      call abs_hlu  ; make dy positive so we can use unsigned multiply
0401BC             0402      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0401BC E5          0403      push hl ; load hl/2 to bc via the stack
0401BD C1          0404      pop bc ; bc = dy/2
0401BE EB          0405      ex de,hl ; de = dy/2
0401BF CD B0 0A 04 0406      call umul168 ; uh.l = dy^2/2
0401C3 E5          0407      push hl ; dy^2/2 to the stack
0401C4             0408  ; compute dx^2
0401C4 2A E0 01 04 0409      ld hl,(dx168) ; get back dx
0401C8 CD 2E 0A 04 0410      call abs_hlu  ; make dx positive so we can use unsigned multiply
0401CC             0411      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0401CC E5          0412      push hl ; load hl/2 to bc via the stack
0401CD C1          0413      pop bc ; bc = dx/2
0401CE EB          0414      ex de,hl ; de = dx/2
0401CF CD B0 0A 04 0415      call umul168 ; uh.l = dx^2/2
0401D3             0416  ; commpute dy^2+dx^2
0401D3 D1          0417      pop de ; get back dx^2/2
0401D4 19          0418      add hl,de ; hl = dx^2/2+dy^2/2
0401D5             0419  ; compute sqrt(dx^2/2+dy^2/2)
0401D5 CD 99 02 04 0420      call sqrt168 ; uh.l = distance/2
0401D9             0421      ; add hl,hl ; hl = distance
0401D9             0422  ; ; check for overflow
0401D9             0423  ; 	pop af ; get back the overflow flags
0401D9             0424  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0401D9             0425  ; 	ld b,a ; save the overflow flag
0401D9             0426  ; 	pop af ; get back the overflow flags
0401D9             0427  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0401D9             0428  ; 	add a,b ; if a != 0 then we had overflow
0401D9             0429  ;     ret z ; no overflow we're done
0401D9             0430  ; @overflow:
0401D9             0431  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0401D9 C9          0432  	ret
0401DA             0433  @scratch: ds 6
0401E0             0434  dx168: ds 6
0401E6             0435  dy168: ds 6
0401EC             0436  
0401EC             0437  ; atan2(ub.c,ud.e) --> uh.l
0401EC             0438  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0401EC             0439  ;   whether inputs are integers or fractional doesn't matter
0401EC             0440  ;   so long as the sign bit of the upper byte is correct
0401EC             0441  ; output: uh.l is the 16.8 fixed angle in degrees 256
0401EC             0442  ; angles are COMPASS HEADINGS based on
0401EC             0443  ; screen coordinate conventions,where the y axis is flipped
0401EC             0444  ; #E0 315      0       45 #20
0401EC             0445  ;        -x,-y | +x,-y
0401EC             0446  ; #C0 270------+------ 90 #40
0401EC             0447  ;        -x,+y | +x,+y
0401EC             0448  ; #A0 225   180 #80   135 #60
0401EC             0449  atan2_168game:
0401EC             0450  ; get signs and make everything positive
0401EC             0451  ; get abs(x) and store its original sign
0401EC C5          0452      push bc
0401ED E1          0453      pop hl
0401EE CD 2E 0A 04 0454      call abs_hlu ; if x was negative this also sets the sign flag
0401F2 E5          0455      push hl ; store abs(x)
0401F3 C1          0456      pop bc ; bc = abs(x)
0401F4 F5          0457      push af ; store sign of x
0401F5             0458  ; get abs(y) and store its original sign
0401F5 EB          0459      ex de,hl ; hl = y
0401F6 CD 2E 0A 04 0460      call abs_hlu ; if y was negative this also sets the sign flag
0401FA EB          0461      ex de,hl ; de = abs(y)
0401FB F5          0462      push af ; store sign of y
0401FC             0463  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0401FC             0464  ; this ensures that our lookup value is between 0 and 1 inclusive
0401FC AF          0465      xor a ; clear the carry flag
0401FD D5          0466      push de
0401FE E1          0467      pop hl
0401FF ED 42       0468      sbc hl,bc
040201 F5          0469      push af ; save sign of de - bc
040202 F2 0B 02 04 0470      jp p,@1 ; bc <= de, so we skip ahead
040206             0471  ; otherwise we swap bc and de
040206 C5          0472      push bc
040207 E1          0473      pop hl
040208 EB          0474      ex de,hl
040209 E5          0475      push hl
04020A C1          0476      pop bc
04020B             0477  @1:
04020B             0478  ; now we're ready to snag our preliminary result
04020B CD 79 02 04 0479      call atan_168game ; uh.l comes back with prelim result
04020F             0480  ; now we adjust uh.l based on sign of de - bc
04020F F1          0481      pop af
040210 F2 1C 02 04 0482      jp p,@2 ; bc <= de,so we skip ahead
040214 EB          0483      ex de,hl
040215 21 00 40 00 0484      ld hl,0x004000 ; 90 degrees
040219 AF          0485      xor a ; clear the carry flag
04021A ED 52       0486      sbc hl,de ; subtract result from 90 degrees
04021C             0487      ; ld de,0 ; prep to clear hlu
04021C             0488      ; ld d,h
04021C             0489      ; ld e,l
04021C             0490      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
04021C             0491      ; fall through
04021C             0492  @2:
04021C             0493  ; now the fun part of adjusting the result
04021C             0494  ; based on which quadrant (x,y) is in
04021C             0495  ; #E0 315      0       45 #20
04021C             0496  ;        -x,-y | +x,-y
04021C             0497  ; #C0 270------+------ 90 #40
04021C             0498  ;        -x,+y | +x,+y
04021C             0499  ; #A0 225   180 #80   135 #60
04021C F1          0500      pop af ; sign of y
04021D CA 5A 02 04 0501      jp z,@y_zero
040221 F2 3A 02 04 0502      jp p,@y_pos
040225             0503  ; y neg,check x
040225 F1          0504      pop af ; sign of x
040226 CA 34 02 04 0505      jp z,@y_neg_x_zero
04022A F2 39 02 04 0506      jp p,@y_neg_x_pos
04022E             0507  ; y neg,x neg
04022E             0508  ; angle is 270-360
04022E             0509  ; negating the intermediate does the trick
04022E CD 3E 0A 04 0510      call neg_hlu
040232 18 31       0511      jr @zero_hlu
040234             0512  
040234             0513  @y_neg_x_zero:
040234             0514  ; y neg,x zero
040234             0515  ; angle is 0
040234 21 00 00 00 0516      ld hl,0
040238 C9          0517      ret
040239             0518  @y_neg_x_pos:
040239             0519  ; y neg,x pos
040239             0520  ; angle is 0 to 90
040239             0521  ; so we're good
040239 C9          0522      ret
04023A             0523  
04023A             0524  @y_pos:
04023A F1          0525      pop af ; sign of x
04023B CA 4A 02 04 0526      jp z,@y_pos_x_zero
04023F F2 4F 02 04 0527      jp p,@y_pos_x_pos
040243             0528  ; y pos,x neg
040243             0529  ; angle is 180-270
040243             0530  ; so we add 180 to intermediate
040243 11 00 80 00 0531      ld de,0x008000
040247 19          0532      add hl,de
040248 18 1B       0533      jr @zero_hlu
04024A             0534  @y_pos_x_zero:
04024A             0535  ; y pos,x zero
04024A             0536  ; angle is 180
04024A 21 00 80 00 0537      ld hl,0x008000
04024E C9          0538      ret
04024F             0539  @y_pos_x_pos:
04024F             0540  ; y pos,x pos
04024F             0541  ; angle is 90-180
04024F             0542  ; neg the intermediate and add 180 degrees
04024F CD 3E 0A 04 0543      call neg_hlu
040253 11 00 80 00 0544      ld de,0x008000
040257 19          0545      add hl,de
040258 18 0B       0546      jr @zero_hlu
04025A             0547  
04025A             0548  @y_zero:
04025A F1          0549      pop af ; sign of x
04025B FA 60 02 04 0550      jp m,@y_zero_x_neg
04025F             0551  ; y zero,x pos
04025F             0552  ; angle is 90,nothing to do
04025F C9          0553      ret
040260             0554  @y_zero_x_neg:
040260             0555  ; y zero ,x neg
040260             0556  ; angle is 270
040260 21 00 C0 00 0557      ld hl,0x00C000
040264 C9          0558      ret
040265             0559  @zero_hlu:
040265 AF          0560      xor a
040266 22 73 02 04 0561      ld (@scratch),hl
04026A 32 75 02 04 0562      ld (@scratch+2),a
04026E 2A 73 02 04 0563      ld hl,(@scratch)
040272 C9          0564      ret
040273             0565  @scratch: ds 6
040279             0566  
040279             0567  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
040279             0568  ; output: uh.l is the 16.8 fixed format angle
040279             0569  ; destroys: a,hl,bc,de
040279             0570  ; the following note was written by github copilot:
040279             0571  ; note: this routine is a bit of a hack
040279             0572  ;      but it works
040279             0573  ;      and it's fast
040279             0574  ;      and it's small
040279             0575  ;      and it's accurate
040279             0576  ;      and it's easy to understand
040279             0577  ;      and it's easy to modify
040279             0578  ;      and it's easy to use
040279             0579  ;      and it's easy to remember
040279             0580  ;      and it's easy to love
040279             0581  ;      and it's easy to hate
040279             0582  ;      and it's easy to ignore
040279             0583  ;      and it's easy to forget
040279             0584  ;      and it's easy to remember
040279             0585  ;      and it's easy to forget
040279             0586  ;      and it's easy to remember
040279             0587  ;      (ok the bot is stuck in a loop)
040279             0588  ; REAL NOTE: only works for angles from 0 to 45 degrees
040279             0589  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
040279             0590  atan_168game:
040279             0591  ; because we use compass headings instead of geometric angles
040279             0592  ; we compute dx/dy which is 1/tan(theta) in the maths world
040279             0593  ; we can do faster unsigned division here because we know dx and dy are positive
040279 CD C5 09 04 0594  	call udiv168 ; uh.l = dx/dy
04027D             0595  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
04027D             0596  ; ; test uh.l for 0
04027D             0597  ;     add hl,de
04027D             0598  ;     or a
04027D             0599  ;     sbc hl,de
04027D             0600  ;     jr z,@is_zero
04027D             0601  ; ; test uh.l for 1
04027D             0602  ;     xor a ; clear carry
04027D             0603  ;     ex de,hl
04027D             0604  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
04027D             0605  ;     sbc hl,de
04027D             0606  ;     jr z,@is_45
04027D             0607  ; ; END TODO
04027D             0608  
04027D             0609  ; no special cases so we move on
04027D             0610  ; l contains the fractional portion of tan(uh.l)
04027D             0611  ; we multiply it by three to get our lookup table index
04027D 26 03       0612      ld h,3
04027F ED 6C       0613      mlt hl ; gosh that is handy
040281 11 00 00 00 0614      ld de,0 ; clear deu
040285 54          0615      ld d,h ; copy hl to de
040286 5D          0616      ld e,l ; de contains our index
040287 21 84 06 04 0617      ld hl,atan_lut_168 ; grab the lut address
04028B 19          0618      add hl,de ; bump hl by the index
04028C ED 27       0619      ld hl,(hl) ; don't try this on a z80!
04028E C9          0620      ret ; and out
04028F             0621  @is_45:
04028F 21 00 20 00 0622      ld hl,0x002000 ; 45 degrees decimal
040293 C9          0623      ret
040294             0624  ; for the case tan(0)
040294             0625  @is_zero:
040294 21 00 00 00 0626      ld hl,0x000000
040298 C9          0627      ret
040299             0628  
040299             0629  ; Expects  ADL mode
040299             0630  ; Inputs:  UH.L
040299             0631  ; Outputs: UH.L is the 16.8 square root
040299             0632  ;          UD.E is the difference inputHL-DE^2
040299             0633  ;          c flag reset
040299             0634  sqrt168:
040299 CD A3 02 04 0635      call sqrt24
04029D EB          0636      ex de,hl
04029E 29          0637      add hl,hl
04029F 29          0638      add hl,hl
0402A0 29          0639      add hl,hl
0402A1 29          0640      add hl,hl
0402A2 C9          0641      ret
0402A3             0642  
0402A3             0643  ; Expects  ADL mode
0402A3             0644  ; Inputs:  HL
0402A3             0645  ; Outputs: DE is the integer square root
0402A3             0646  ;          HL is the difference inputHL-DE^2
0402A3             0647  ;          c flag reset
0402A3             0648  sqrt24:
0402A3 AF          0649      xor a
0402A4 45          0650      ld b,l
0402A5 C5          0651      push bc
0402A6 47          0652      ld b,a
0402A7 57          0653      ld d,a
0402A8 4F          0654      ld c,a
0402A9 6F          0655      ld l,a
0402AA 5F          0656      ld e,a
0402AB             0657  
0402AB             0658      ;Iteration 1
0402AB 29          0659      add hl,hl
0402AC CB 11       0660      rl c
0402AE 29          0661      add hl,hl
0402AF CB 11       0662      rl c
0402B1 91          0663      sub c
0402B2 30 04       0664      jr nc,$+6
0402B4 1C          0665      inc e
0402B5 1C          0666      inc e
0402B6 2F          0667      cpl
0402B7 4F          0668      ld c,a
0402B8             0669  
0402B8             0670      ;Iteration 2
0402B8 29          0671      add hl,hl
0402B9 CB 11       0672      rl c
0402BB 29          0673      add hl,hl
0402BC CB 11       0674      rl c
0402BE CB 13       0675      rl e
0402C0 7B          0676      ld a,e
0402C1 91          0677      sub c
0402C2 30 04       0678      jr nc,$+6
0402C4 1C          0679      inc e
0402C5 1C          0680      inc e
0402C6 2F          0681      cpl
0402C7 4F          0682      ld c,a
0402C8             0683  
0402C8             0684      ;Iteration 3
0402C8 29          0685      add hl,hl
0402C9 CB 11       0686      rl c
0402CB 29          0687      add hl,hl
0402CC CB 11       0688      rl c
0402CE CB 13       0689      rl e
0402D0 7B          0690      ld a,e
0402D1 91          0691      sub c
0402D2 30 04       0692      jr nc,$+6
0402D4 1C          0693      inc e
0402D5 1C          0694      inc e
0402D6 2F          0695      cpl
0402D7 4F          0696      ld c,a
0402D8             0697  
0402D8             0698      ;Iteration 4
0402D8 29          0699      add hl,hl
0402D9 CB 11       0700      rl c
0402DB 29          0701      add hl,hl
0402DC CB 11       0702      rl c
0402DE CB 13       0703      rl e
0402E0 7B          0704      ld a,e
0402E1 91          0705      sub c
0402E2 30 04       0706      jr nc,$+6
0402E4 1C          0707      inc e
0402E5 1C          0708      inc e
0402E6 2F          0709      cpl
0402E7 4F          0710      ld c,a
0402E8             0711  
0402E8             0712      ;Iteration 5
0402E8 29          0713      add hl,hl
0402E9 CB 11       0714      rl c
0402EB 29          0715      add hl,hl
0402EC CB 11       0716      rl c
0402EE CB 13       0717      rl e
0402F0 7B          0718      ld a,e
0402F1 91          0719      sub c
0402F2 30 04       0720      jr nc,$+6
0402F4 1C          0721      inc e
0402F5 1C          0722      inc e
0402F6 2F          0723      cpl
0402F7 4F          0724      ld c,a
0402F8             0725  
0402F8             0726      ;Iteration 6
0402F8 29          0727      add hl,hl
0402F9 CB 11       0728      rl c
0402FB 29          0729      add hl,hl
0402FC CB 11       0730      rl c
0402FE CB 13       0731      rl e
040300 7B          0732      ld a,e
040301 91          0733      sub c
040302 30 04       0734      jr nc,$+6
040304 1C          0735      inc e
040305 1C          0736      inc e
040306 2F          0737      cpl
040307 4F          0738      ld c,a
040308             0739  
040308             0740      ;Iteration 7
040308 29          0741      add hl,hl
040309 CB 11       0742      rl c
04030B 29          0743      add hl,hl
04030C CB 11       0744      rl c
04030E CB 10       0745      rl b
040310 EB          0746      ex de,hl
040311 29          0747      add hl,hl
040312 E5          0748      push hl
040313 ED 42       0749      sbc hl,bc
040315 30 06       0750      jr nc,$+8
040317 7C          0751      ld a,h
040318 2F          0752      cpl
040319 47          0753      ld b,a
04031A 7D          0754      ld a,l
04031B 2F          0755      cpl
04031C 4F          0756      ld c,a
04031D E1          0757      pop hl
04031E 30 02       0758      jr nc,$+4
040320 23          0759      inc hl
040321 23          0760      inc hl
040322 EB          0761      ex de,hl
040323             0762  
040323             0763      ;Iteration 8
040323 29          0764      add hl,hl
040324 69          0765      ld l,c
040325 60          0766      ld h,b
040326 ED 6A       0767      adc hl,hl
040328 ED 6A       0768      adc hl,hl
04032A EB          0769      ex de,hl
04032B 29          0770      add hl,hl
04032C ED 52       0771      sbc hl,de
04032E 19          0772      add hl,de
04032F EB          0773      ex de,hl
040330 30 04       0774      jr nc,$+6
040332 ED 52       0775      sbc hl,de
040334 13          0776      inc de
040335 13          0777      inc de
040336             0778  
040336             0779      ;Iteration 9
040336 F1          0780      pop af
040337 17          0781      rla
040338 ED 6A       0782      adc hl,hl
04033A 17          0783      rla
04033B ED 6A       0784      adc hl,hl
04033D EB          0785      ex de,hl
04033E 29          0786      add hl,hl
04033F ED 52       0787      sbc hl,de
040341 19          0788      add hl,de
040342 EB          0789      ex de,hl
040343 30 04       0790      jr nc,$+6
040345 ED 52       0791      sbc hl,de
040347 13          0792      inc de
040348 13          0793      inc de
040349             0794  
040349             0795      ;Iteration 10
040349 17          0796      rla
04034A ED 6A       0797      adc hl,hl
04034C 17          0798      rla
04034D ED 6A       0799      adc hl,hl
04034F EB          0800      ex de,hl
040350 29          0801      add hl,hl
040351 ED 52       0802      sbc hl,de
040353 19          0803      add hl,de
040354 EB          0804      ex de,hl
040355 30 04       0805      jr nc,$+6
040357 ED 52       0806      sbc hl,de
040359 13          0807      inc de
04035A 13          0808      inc de
04035B             0809  
04035B             0810      ;Iteration 11
04035B 17          0811      rla
04035C ED 6A       0812      adc hl,hl
04035E 17          0813      rla
04035F ED 6A       0814      adc hl,hl
040361 EB          0815      ex de,hl
040362 29          0816      add hl,hl
040363 ED 52       0817      sbc hl,de
040365 19          0818      add hl,de
040366 EB          0819      ex de,hl
040367 30 04       0820      jr nc,$+6
040369 ED 52       0821      sbc hl,de
04036B 13          0822      inc de
04036C 13          0823      inc de
04036D             0824  
04036D             0825      ;Iteration 11
04036D 17          0826      rla
04036E ED 6A       0827      adc hl,hl
040370 17          0828      rla
040371 ED 6A       0829      adc hl,hl
040373 EB          0830      ex de,hl
040374 29          0831      add hl,hl
040375 ED 52       0832      sbc hl,de
040377 19          0833      add hl,de
040378 EB          0834      ex de,hl
040379 30 04       0835      jr nc,$+6
04037B ED 52       0836      sbc hl,de
04037D 13          0837      inc de
04037E 13          0838      inc de
04037F             0839  
04037F CB 1A       0840      rr d
040381 CB 1B       0841      rr e
040383 C9          0842      ret
040384             0843  
040384             0844  sin_lut_168:
040384 00 00 00    0845  	dl 0x000000 ; 0.000 00, 0.000
040387 06 00 00    0846  	dl 0x000006 ; 1.406 01, 0.025
04038A 0C 00 00    0847  	dl 0x00000C ; 2.813 02, 0.049
04038D 12 00 00    0848  	dl 0x000012 ; 4.219 03, 0.074
040390 19 00 00    0849  	dl 0x000019 ; 5.625 04, 0.098
040393 1F 00 00    0850  	dl 0x00001F ; 7.031 05, 0.122
040396 25 00 00    0851  	dl 0x000025 ; 8.438 06, 0.147
040399 2B 00 00    0852  	dl 0x00002B ; 9.844 07, 0.171
04039C 31 00 00    0853  	dl 0x000031 ; 11.250 08, 0.195
04039F 38 00 00    0854  	dl 0x000038 ; 12.656 09, 0.219
0403A2 3E 00 00    0855  	dl 0x00003E ; 14.063 0A, 0.243
0403A5 44 00 00    0856  	dl 0x000044 ; 15.469 0B, 0.267
0403A8 4A 00 00    0857  	dl 0x00004A ; 16.875 0C, 0.290
0403AB 50 00 00    0858  	dl 0x000050 ; 18.281 0D, 0.314
0403AE 56 00 00    0859  	dl 0x000056 ; 19.688 0E, 0.337
0403B1 5C 00 00    0860  	dl 0x00005C ; 21.094 0F, 0.360
0403B4 61 00 00    0861  	dl 0x000061 ; 22.500 10, 0.383
0403B7 67 00 00    0862  	dl 0x000067 ; 23.906 11, 0.405
0403BA 6D 00 00    0863  	dl 0x00006D ; 25.313 12, 0.428
0403BD 73 00 00    0864  	dl 0x000073 ; 26.719 13, 0.450
0403C0 78 00 00    0865  	dl 0x000078 ; 28.125 14, 0.471
0403C3 7E 00 00    0866  	dl 0x00007E ; 29.531 15, 0.493
0403C6 83 00 00    0867  	dl 0x000083 ; 30.938 16, 0.514
0403C9 88 00 00    0868  	dl 0x000088 ; 32.344 17, 0.535
0403CC 8E 00 00    0869  	dl 0x00008E ; 33.750 18, 0.556
0403CF 93 00 00    0870  	dl 0x000093 ; 35.156 19, 0.576
0403D2 98 00 00    0871  	dl 0x000098 ; 36.563 1A, 0.596
0403D5 9D 00 00    0872  	dl 0x00009D ; 37.969 1B, 0.615
0403D8 A2 00 00    0873  	dl 0x0000A2 ; 39.375 1C, 0.634
0403DB A7 00 00    0874  	dl 0x0000A7 ; 40.781 1D, 0.653
0403DE AB 00 00    0875  	dl 0x0000AB ; 42.188 1E, 0.672
0403E1 B0 00 00    0876  	dl 0x0000B0 ; 43.594 1F, 0.690
0403E4 B5 00 00    0877  	dl 0x0000B5 ; 45.000 20, 0.707
0403E7 B9 00 00    0878  	dl 0x0000B9 ; 46.406 21, 0.724
0403EA BD 00 00    0879  	dl 0x0000BD ; 47.813 22, 0.741
0403ED C1 00 00    0880  	dl 0x0000C1 ; 49.219 23, 0.757
0403F0 C5 00 00    0881  	dl 0x0000C5 ; 50.625 24, 0.773
0403F3 C9 00 00    0882  	dl 0x0000C9 ; 52.031 25, 0.788
0403F6 CD 00 00    0883  	dl 0x0000CD ; 53.438 26, 0.803
0403F9 D1 00 00    0884  	dl 0x0000D1 ; 54.844 27, 0.818
0403FC D4 00 00    0885  	dl 0x0000D4 ; 56.250 28, 0.831
0403FF D8 00 00    0886  	dl 0x0000D8 ; 57.656 29, 0.845
040402 DB 00 00    0887  	dl 0x0000DB ; 59.063 2A, 0.858
040405 DE 00 00    0888  	dl 0x0000DE ; 60.469 2B, 0.870
040408 E1 00 00    0889  	dl 0x0000E1 ; 61.875 2C, 0.882
04040B E4 00 00    0890  	dl 0x0000E4 ; 63.281 2D, 0.893
04040E E7 00 00    0891  	dl 0x0000E7 ; 64.688 2E, 0.904
040411 EA 00 00    0892  	dl 0x0000EA ; 66.094 2F, 0.914
040414 EC 00 00    0893  	dl 0x0000EC ; 67.500 30, 0.924
040417 EE 00 00    0894  	dl 0x0000EE ; 68.906 31, 0.933
04041A F1 00 00    0895  	dl 0x0000F1 ; 70.313 32, 0.942
04041D F3 00 00    0896  	dl 0x0000F3 ; 71.719 33, 0.950
040420 F4 00 00    0897  	dl 0x0000F4 ; 73.125 34, 0.957
040423 F6 00 00    0898  	dl 0x0000F6 ; 74.531 35, 0.964
040426 F8 00 00    0899  	dl 0x0000F8 ; 75.938 36, 0.970
040429 F9 00 00    0900  	dl 0x0000F9 ; 77.344 37, 0.976
04042C FB 00 00    0901  	dl 0x0000FB ; 78.750 38, 0.981
04042F FC 00 00    0902  	dl 0x0000FC ; 80.156 39, 0.985
040432 FD 00 00    0903  	dl 0x0000FD ; 81.563 3A, 0.989
040435 FE 00 00    0904  	dl 0x0000FE ; 82.969 3B, 0.992
040438 FE 00 00    0905  	dl 0x0000FE ; 84.375 3C, 0.995
04043B FF 00 00    0906  	dl 0x0000FF ; 85.781 3D, 0.997
04043E FF 00 00    0907  	dl 0x0000FF ; 87.188 3E, 0.999
040441 FF 00 00    0908  	dl 0x0000FF ; 88.594 3F, 1.000
040444 00 01 00    0909  	dl 0x000100 ; 90.000 40, 1.000
040447 FF 00 00    0910  	dl 0x0000FF ; 91.406 41, 1.000
04044A FF 00 00    0911  	dl 0x0000FF ; 92.813 42, 0.999
04044D FF 00 00    0912  	dl 0x0000FF ; 94.219 43, 0.997
040450 FE 00 00    0913  	dl 0x0000FE ; 95.625 44, 0.995
040453 FE 00 00    0914  	dl 0x0000FE ; 97.031 45, 0.992
040456 FD 00 00    0915  	dl 0x0000FD ; 98.438 46, 0.989
040459 FC 00 00    0916  	dl 0x0000FC ; 99.844 47, 0.985
04045C FB 00 00    0917  	dl 0x0000FB ; 101.250 48, 0.981
04045F F9 00 00    0918  	dl 0x0000F9 ; 102.656 49, 0.976
040462 F8 00 00    0919  	dl 0x0000F8 ; 104.063 4A, 0.970
040465 F6 00 00    0920  	dl 0x0000F6 ; 105.469 4B, 0.964
040468 F4 00 00    0921  	dl 0x0000F4 ; 106.875 4C, 0.957
04046B F3 00 00    0922  	dl 0x0000F3 ; 108.281 4D, 0.950
04046E F1 00 00    0923  	dl 0x0000F1 ; 109.688 4E, 0.942
040471 EE 00 00    0924  	dl 0x0000EE ; 111.094 4F, 0.933
040474 EC 00 00    0925  	dl 0x0000EC ; 112.500 50, 0.924
040477 EA 00 00    0926  	dl 0x0000EA ; 113.906 51, 0.914
04047A E7 00 00    0927  	dl 0x0000E7 ; 115.313 52, 0.904
04047D E4 00 00    0928  	dl 0x0000E4 ; 116.719 53, 0.893
040480 E1 00 00    0929  	dl 0x0000E1 ; 118.125 54, 0.882
040483 DE 00 00    0930  	dl 0x0000DE ; 119.531 55, 0.870
040486 DB 00 00    0931  	dl 0x0000DB ; 120.938 56, 0.858
040489 D8 00 00    0932  	dl 0x0000D8 ; 122.344 57, 0.845
04048C D4 00 00    0933  	dl 0x0000D4 ; 123.750 58, 0.831
04048F D1 00 00    0934  	dl 0x0000D1 ; 125.156 59, 0.818
040492 CD 00 00    0935  	dl 0x0000CD ; 126.563 5A, 0.803
040495 C9 00 00    0936  	dl 0x0000C9 ; 127.969 5B, 0.788
040498 C5 00 00    0937  	dl 0x0000C5 ; 129.375 5C, 0.773
04049B C1 00 00    0938  	dl 0x0000C1 ; 130.781 5D, 0.757
04049E BD 00 00    0939  	dl 0x0000BD ; 132.188 5E, 0.741
0404A1 B9 00 00    0940  	dl 0x0000B9 ; 133.594 5F, 0.724
0404A4 B5 00 00    0941  	dl 0x0000B5 ; 135.000 60, 0.707
0404A7 B0 00 00    0942  	dl 0x0000B0 ; 136.406 61, 0.690
0404AA AB 00 00    0943  	dl 0x0000AB ; 137.813 62, 0.672
0404AD A7 00 00    0944  	dl 0x0000A7 ; 139.219 63, 0.653
0404B0 A2 00 00    0945  	dl 0x0000A2 ; 140.625 64, 0.634
0404B3 9D 00 00    0946  	dl 0x00009D ; 142.031 65, 0.615
0404B6 98 00 00    0947  	dl 0x000098 ; 143.438 66, 0.596
0404B9 93 00 00    0948  	dl 0x000093 ; 144.844 67, 0.576
0404BC 8E 00 00    0949  	dl 0x00008E ; 146.250 68, 0.556
0404BF 88 00 00    0950  	dl 0x000088 ; 147.656 69, 0.535
0404C2 83 00 00    0951  	dl 0x000083 ; 149.063 6A, 0.514
0404C5 7E 00 00    0952  	dl 0x00007E ; 150.469 6B, 0.493
0404C8 78 00 00    0953  	dl 0x000078 ; 151.875 6C, 0.471
0404CB 73 00 00    0954  	dl 0x000073 ; 153.281 6D, 0.450
0404CE 6D 00 00    0955  	dl 0x00006D ; 154.688 6E, 0.428
0404D1 67 00 00    0956  	dl 0x000067 ; 156.094 6F, 0.405
0404D4 61 00 00    0957  	dl 0x000061 ; 157.500 70, 0.383
0404D7 5C 00 00    0958  	dl 0x00005C ; 158.906 71, 0.360
0404DA 56 00 00    0959  	dl 0x000056 ; 160.313 72, 0.337
0404DD 50 00 00    0960  	dl 0x000050 ; 161.719 73, 0.314
0404E0 4A 00 00    0961  	dl 0x00004A ; 163.125 74, 0.290
0404E3 44 00 00    0962  	dl 0x000044 ; 164.531 75, 0.267
0404E6 3E 00 00    0963  	dl 0x00003E ; 165.938 76, 0.243
0404E9 38 00 00    0964  	dl 0x000038 ; 167.344 77, 0.219
0404EC 31 00 00    0965  	dl 0x000031 ; 168.750 78, 0.195
0404EF 2B 00 00    0966  	dl 0x00002B ; 170.156 79, 0.171
0404F2 25 00 00    0967  	dl 0x000025 ; 171.563 7A, 0.147
0404F5 1F 00 00    0968  	dl 0x00001F ; 172.969 7B, 0.122
0404F8 19 00 00    0969  	dl 0x000019 ; 174.375 7C, 0.098
0404FB 12 00 00    0970  	dl 0x000012 ; 175.781 7D, 0.074
0404FE 0C 00 00    0971  	dl 0x00000C ; 177.188 7E, 0.049
040501 06 00 00    0972  	dl 0x000006 ; 178.594 7F, 0.025
040504 00 00 00    0973  	dl 0x000000 ; 180.000 80, 0.000
040507 FA FF FF    0974  	dl 0xFFFFFA ; 181.406 81, -0.025
04050A F4 FF FF    0975  	dl 0xFFFFF4 ; 182.813 82, -0.049
04050D EE FF FF    0976  	dl 0xFFFFEE ; 184.219 83, -0.074
040510 E7 FF FF    0977  	dl 0xFFFFE7 ; 185.625 84, -0.098
040513 E1 FF FF    0978  	dl 0xFFFFE1 ; 187.031 85, -0.122
040516 DB FF FF    0979  	dl 0xFFFFDB ; 188.438 86, -0.147
040519 D5 FF FF    0980  	dl 0xFFFFD5 ; 189.844 87, -0.171
04051C CF FF FF    0981  	dl 0xFFFFCF ; 191.250 88, -0.195
04051F C8 FF FF    0982  	dl 0xFFFFC8 ; 192.656 89, -0.219
040522 C2 FF FF    0983  	dl 0xFFFFC2 ; 194.063 8A, -0.243
040525 BC FF FF    0984  	dl 0xFFFFBC ; 195.469 8B, -0.267
040528 B6 FF FF    0985  	dl 0xFFFFB6 ; 196.875 8C, -0.290
04052B B0 FF FF    0986  	dl 0xFFFFB0 ; 198.281 8D, -0.314
04052E AA FF FF    0987  	dl 0xFFFFAA ; 199.688 8E, -0.337
040531 A4 FF FF    0988  	dl 0xFFFFA4 ; 201.094 8F, -0.360
040534 9F FF FF    0989  	dl 0xFFFF9F ; 202.500 90, -0.383
040537 99 FF FF    0990  	dl 0xFFFF99 ; 203.906 91, -0.405
04053A 93 FF FF    0991  	dl 0xFFFF93 ; 205.313 92, -0.428
04053D 8D FF FF    0992  	dl 0xFFFF8D ; 206.719 93, -0.450
040540 88 FF FF    0993  	dl 0xFFFF88 ; 208.125 94, -0.471
040543 82 FF FF    0994  	dl 0xFFFF82 ; 209.531 95, -0.493
040546 7D FF FF    0995  	dl 0xFFFF7D ; 210.938 96, -0.514
040549 78 FF FF    0996  	dl 0xFFFF78 ; 212.344 97, -0.535
04054C 72 FF FF    0997  	dl 0xFFFF72 ; 213.750 98, -0.556
04054F 6D FF FF    0998  	dl 0xFFFF6D ; 215.156 99, -0.576
040552 68 FF FF    0999  	dl 0xFFFF68 ; 216.563 9A, -0.596
040555 63 FF FF    1000  	dl 0xFFFF63 ; 217.969 9B, -0.615
040558 5E FF FF    1001  	dl 0xFFFF5E ; 219.375 9C, -0.634
04055B 59 FF FF    1002  	dl 0xFFFF59 ; 220.781 9D, -0.653
04055E 55 FF FF    1003  	dl 0xFFFF55 ; 222.188 9E, -0.672
040561 50 FF FF    1004  	dl 0xFFFF50 ; 223.594 9F, -0.690
040564 4B FF FF    1005  	dl 0xFFFF4B ; 225.000 A0, -0.707
040567 47 FF FF    1006  	dl 0xFFFF47 ; 226.406 A1, -0.724
04056A 43 FF FF    1007  	dl 0xFFFF43 ; 227.813 A2, -0.741
04056D 3F FF FF    1008  	dl 0xFFFF3F ; 229.219 A3, -0.757
040570 3B FF FF    1009  	dl 0xFFFF3B ; 230.625 A4, -0.773
040573 37 FF FF    1010  	dl 0xFFFF37 ; 232.031 A5, -0.788
040576 33 FF FF    1011  	dl 0xFFFF33 ; 233.438 A6, -0.803
040579 2F FF FF    1012  	dl 0xFFFF2F ; 234.844 A7, -0.818
04057C 2C FF FF    1013  	dl 0xFFFF2C ; 236.250 A8, -0.831
04057F 28 FF FF    1014  	dl 0xFFFF28 ; 237.656 A9, -0.845
040582 25 FF FF    1015  	dl 0xFFFF25 ; 239.063 AA, -0.858
040585 22 FF FF    1016  	dl 0xFFFF22 ; 240.469 AB, -0.870
040588 1F FF FF    1017  	dl 0xFFFF1F ; 241.875 AC, -0.882
04058B 1C FF FF    1018  	dl 0xFFFF1C ; 243.281 AD, -0.893
04058E 19 FF FF    1019  	dl 0xFFFF19 ; 244.688 AE, -0.904
040591 16 FF FF    1020  	dl 0xFFFF16 ; 246.094 AF, -0.914
040594 14 FF FF    1021  	dl 0xFFFF14 ; 247.500 B0, -0.924
040597 12 FF FF    1022  	dl 0xFFFF12 ; 248.906 B1, -0.933
04059A 0F FF FF    1023  	dl 0xFFFF0F ; 250.313 B2, -0.942
04059D 0D FF FF    1024  	dl 0xFFFF0D ; 251.719 B3, -0.950
0405A0 0C FF FF    1025  	dl 0xFFFF0C ; 253.125 B4, -0.957
0405A3 0A FF FF    1026  	dl 0xFFFF0A ; 254.531 B5, -0.964
0405A6 08 FF FF    1027  	dl 0xFFFF08 ; 255.938 B6, -0.970
0405A9 07 FF FF    1028  	dl 0xFFFF07 ; 257.344 B7, -0.976
0405AC 05 FF FF    1029  	dl 0xFFFF05 ; 258.750 B8, -0.981
0405AF 04 FF FF    1030  	dl 0xFFFF04 ; 260.156 B9, -0.985
0405B2 03 FF FF    1031  	dl 0xFFFF03 ; 261.563 BA, -0.989
0405B5 02 FF FF    1032  	dl 0xFFFF02 ; 262.969 BB, -0.992
0405B8 02 FF FF    1033  	dl 0xFFFF02 ; 264.375 BC, -0.995
0405BB 01 FF FF    1034  	dl 0xFFFF01 ; 265.781 BD, -0.997
0405BE 01 FF FF    1035  	dl 0xFFFF01 ; 267.188 BE, -0.999
0405C1 01 FF FF    1036  	dl 0xFFFF01 ; 268.594 BF, -1.000
0405C4 00 FF FF    1037  	dl 0xFFFF00 ; 270.000 C0, -1.000
0405C7 01 FF FF    1038  	dl 0xFFFF01 ; 271.406 C1, -1.000
0405CA 01 FF FF    1039  	dl 0xFFFF01 ; 272.813 C2, -0.999
0405CD 01 FF FF    1040  	dl 0xFFFF01 ; 274.219 C3, -0.997
0405D0 02 FF FF    1041  	dl 0xFFFF02 ; 275.625 C4, -0.995
0405D3 02 FF FF    1042  	dl 0xFFFF02 ; 277.031 C5, -0.992
0405D6 03 FF FF    1043  	dl 0xFFFF03 ; 278.438 C6, -0.989
0405D9 04 FF FF    1044  	dl 0xFFFF04 ; 279.844 C7, -0.985
0405DC 05 FF FF    1045  	dl 0xFFFF05 ; 281.250 C8, -0.981
0405DF 07 FF FF    1046  	dl 0xFFFF07 ; 282.656 C9, -0.976
0405E2 08 FF FF    1047  	dl 0xFFFF08 ; 284.063 CA, -0.970
0405E5 0A FF FF    1048  	dl 0xFFFF0A ; 285.469 CB, -0.964
0405E8 0C FF FF    1049  	dl 0xFFFF0C ; 286.875 CC, -0.957
0405EB 0D FF FF    1050  	dl 0xFFFF0D ; 288.281 CD, -0.950
0405EE 0F FF FF    1051  	dl 0xFFFF0F ; 289.688 CE, -0.942
0405F1 12 FF FF    1052  	dl 0xFFFF12 ; 291.094 CF, -0.933
0405F4 14 FF FF    1053  	dl 0xFFFF14 ; 292.500 D0, -0.924
0405F7 16 FF FF    1054  	dl 0xFFFF16 ; 293.906 D1, -0.914
0405FA 19 FF FF    1055  	dl 0xFFFF19 ; 295.313 D2, -0.904
0405FD 1C FF FF    1056  	dl 0xFFFF1C ; 296.719 D3, -0.893
040600 1F FF FF    1057  	dl 0xFFFF1F ; 298.125 D4, -0.882
040603 22 FF FF    1058  	dl 0xFFFF22 ; 299.531 D5, -0.870
040606 25 FF FF    1059  	dl 0xFFFF25 ; 300.938 D6, -0.858
040609 28 FF FF    1060  	dl 0xFFFF28 ; 302.344 D7, -0.845
04060C 2C FF FF    1061  	dl 0xFFFF2C ; 303.750 D8, -0.831
04060F 2F FF FF    1062  	dl 0xFFFF2F ; 305.156 D9, -0.818
040612 33 FF FF    1063  	dl 0xFFFF33 ; 306.563 DA, -0.803
040615 37 FF FF    1064  	dl 0xFFFF37 ; 307.969 DB, -0.788
040618 3B FF FF    1065  	dl 0xFFFF3B ; 309.375 DC, -0.773
04061B 3F FF FF    1066  	dl 0xFFFF3F ; 310.781 DD, -0.757
04061E 43 FF FF    1067  	dl 0xFFFF43 ; 312.188 DE, -0.741
040621 47 FF FF    1068  	dl 0xFFFF47 ; 313.594 DF, -0.724
040624 4B FF FF    1069  	dl 0xFFFF4B ; 315.000 E0, -0.707
040627 50 FF FF    1070  	dl 0xFFFF50 ; 316.406 E1, -0.690
04062A 55 FF FF    1071  	dl 0xFFFF55 ; 317.813 E2, -0.672
04062D 59 FF FF    1072  	dl 0xFFFF59 ; 319.219 E3, -0.653
040630 5E FF FF    1073  	dl 0xFFFF5E ; 320.625 E4, -0.634
040633 63 FF FF    1074  	dl 0xFFFF63 ; 322.031 E5, -0.615
040636 68 FF FF    1075  	dl 0xFFFF68 ; 323.438 E6, -0.596
040639 6D FF FF    1076  	dl 0xFFFF6D ; 324.844 E7, -0.576
04063C 72 FF FF    1077  	dl 0xFFFF72 ; 326.250 E8, -0.556
04063F 78 FF FF    1078  	dl 0xFFFF78 ; 327.656 E9, -0.535
040642 7D FF FF    1079  	dl 0xFFFF7D ; 329.063 EA, -0.514
040645 82 FF FF    1080  	dl 0xFFFF82 ; 330.469 EB, -0.493
040648 88 FF FF    1081  	dl 0xFFFF88 ; 331.875 EC, -0.471
04064B 8D FF FF    1082  	dl 0xFFFF8D ; 333.281 ED, -0.450
04064E 93 FF FF    1083  	dl 0xFFFF93 ; 334.688 EE, -0.428
040651 99 FF FF    1084  	dl 0xFFFF99 ; 336.094 EF, -0.405
040654 9F FF FF    1085  	dl 0xFFFF9F ; 337.500 F0, -0.383
040657 A4 FF FF    1086  	dl 0xFFFFA4 ; 338.906 F1, -0.360
04065A AA FF FF    1087  	dl 0xFFFFAA ; 340.313 F2, -0.337
04065D B0 FF FF    1088  	dl 0xFFFFB0 ; 341.719 F3, -0.314
040660 B6 FF FF    1089  	dl 0xFFFFB6 ; 343.125 F4, -0.290
040663 BC FF FF    1090  	dl 0xFFFFBC ; 344.531 F5, -0.267
040666 C2 FF FF    1091  	dl 0xFFFFC2 ; 345.938 F6, -0.243
040669 C8 FF FF    1092  	dl 0xFFFFC8 ; 347.344 F7, -0.219
04066C CF FF FF    1093  	dl 0xFFFFCF ; 348.750 F8, -0.195
04066F D5 FF FF    1094  	dl 0xFFFFD5 ; 350.156 F9, -0.171
040672 DB FF FF    1095  	dl 0xFFFFDB ; 351.563 FA, -0.147
040675 E1 FF FF    1096  	dl 0xFFFFE1 ; 352.969 FB, -0.122
040678 E7 FF FF    1097  	dl 0xFFFFE7 ; 354.375 FC, -0.098
04067B EE FF FF    1098  	dl 0xFFFFEE ; 355.781 FD, -0.074
04067E F4 FF FF    1099  	dl 0xFFFFF4 ; 357.188 FE, -0.049
040681 FA FF FF    1100  	dl 0xFFFFFA ; 358.594 FF, -0.025
040684             1101  
040684             1102  atan_lut_168:
040684 00 00 00    1103  	dl 0x000000 ; 000000, 0.000
040687 28 00 00    1104  	dl 0x000028 ; 000001, 0.224
04068A 51 00 00    1105  	dl 0x000051 ; 000002, 0.448
04068D 7A 00 00    1106  	dl 0x00007A ; 000003, 0.671
040690 A2 00 00    1107  	dl 0x0000A2 ; 000004, 0.895
040693 CB 00 00    1108  	dl 0x0000CB ; 000005, 1.119
040696 F4 00 00    1109  	dl 0x0000F4 ; 000006, 1.343
040699 1D 01 00    1110  	dl 0x00011D ; 000007, 1.566
04069C 45 01 00    1111  	dl 0x000145 ; 000008, 1.790
04069F 6E 01 00    1112  	dl 0x00016E ; 000009, 2.013
0406A2 97 01 00    1113  	dl 0x000197 ; 00000A, 2.237
0406A5 BF 01 00    1114  	dl 0x0001BF ; 00000B, 2.460
0406A8 E8 01 00    1115  	dl 0x0001E8 ; 00000C, 2.684
0406AB 11 02 00    1116  	dl 0x000211 ; 00000D, 2.907
0406AE 39 02 00    1117  	dl 0x000239 ; 00000E, 3.130
0406B1 62 02 00    1118  	dl 0x000262 ; 00000F, 3.353
0406B4 8B 02 00    1119  	dl 0x00028B ; 000010, 3.576
0406B7 B3 02 00    1120  	dl 0x0002B3 ; 000011, 3.799
0406BA DC 02 00    1121  	dl 0x0002DC ; 000012, 4.022
0406BD 04 03 00    1122  	dl 0x000304 ; 000013, 4.245
0406C0 2D 03 00    1123  	dl 0x00032D ; 000014, 4.467
0406C3 55 03 00    1124  	dl 0x000355 ; 000015, 4.690
0406C6 7E 03 00    1125  	dl 0x00037E ; 000016, 4.912
0406C9 A6 03 00    1126  	dl 0x0003A6 ; 000017, 5.134
0406CC CE 03 00    1127  	dl 0x0003CE ; 000018, 5.356
0406CF F7 03 00    1128  	dl 0x0003F7 ; 000019, 5.578
0406D2 1F 04 00    1129  	dl 0x00041F ; 00001A, 5.799
0406D5 48 04 00    1130  	dl 0x000448 ; 00001B, 6.021
0406D8 70 04 00    1131  	dl 0x000470 ; 00001C, 6.242
0406DB 98 04 00    1132  	dl 0x000498 ; 00001D, 6.463
0406DE C0 04 00    1133  	dl 0x0004C0 ; 00001E, 6.684
0406E1 E8 04 00    1134  	dl 0x0004E8 ; 00001F, 6.905
0406E4 11 05 00    1135  	dl 0x000511 ; 000020, 7.125
0406E7 39 05 00    1136  	dl 0x000539 ; 000021, 7.345
0406EA 61 05 00    1137  	dl 0x000561 ; 000022, 7.565
0406ED 89 05 00    1138  	dl 0x000589 ; 000023, 7.785
0406F0 B1 05 00    1139  	dl 0x0005B1 ; 000024, 8.005
0406F3 D9 05 00    1140  	dl 0x0005D9 ; 000025, 8.224
0406F6 01 06 00    1141  	dl 0x000601 ; 000026, 8.443
0406F9 28 06 00    1142  	dl 0x000628 ; 000027, 8.662
0406FC 50 06 00    1143  	dl 0x000650 ; 000028, 8.881
0406FF 78 06 00    1144  	dl 0x000678 ; 000029, 9.099
040702 A0 06 00    1145  	dl 0x0006A0 ; 00002A, 9.317
040705 C7 06 00    1146  	dl 0x0006C7 ; 00002B, 9.535
040708 EF 06 00    1147  	dl 0x0006EF ; 00002C, 9.752
04070B 16 07 00    1148  	dl 0x000716 ; 00002D, 9.970
04070E 3E 07 00    1149  	dl 0x00073E ; 00002E, 10.187
040711 65 07 00    1150  	dl 0x000765 ; 00002F, 10.403
040714 8D 07 00    1151  	dl 0x00078D ; 000030, 10.620
040717 B4 07 00    1152  	dl 0x0007B4 ; 000031, 10.836
04071A DB 07 00    1153  	dl 0x0007DB ; 000032, 11.051
04071D 03 08 00    1154  	dl 0x000803 ; 000033, 11.267
040720 2A 08 00    1155  	dl 0x00082A ; 000034, 11.482
040723 51 08 00    1156  	dl 0x000851 ; 000035, 11.697
040726 78 08 00    1157  	dl 0x000878 ; 000036, 11.911
040729 9F 08 00    1158  	dl 0x00089F ; 000037, 12.125
04072C C6 08 00    1159  	dl 0x0008C6 ; 000038, 12.339
04072F ED 08 00    1160  	dl 0x0008ED ; 000039, 12.553
040732 13 09 00    1161  	dl 0x000913 ; 00003A, 12.766
040735 3A 09 00    1162  	dl 0x00093A ; 00003B, 12.978
040738 61 09 00    1163  	dl 0x000961 ; 00003C, 13.191
04073B 87 09 00    1164  	dl 0x000987 ; 00003D, 13.403
04073E AE 09 00    1165  	dl 0x0009AE ; 00003E, 13.614
040741 D4 09 00    1166  	dl 0x0009D4 ; 00003F, 13.825
040744 FB 09 00    1167  	dl 0x0009FB ; 000040, 14.036
040747 21 0A 00    1168  	dl 0x000A21 ; 000041, 14.247
04074A 47 0A 00    1169  	dl 0x000A47 ; 000042, 14.457
04074D 6D 0A 00    1170  	dl 0x000A6D ; 000043, 14.666
040750 94 0A 00    1171  	dl 0x000A94 ; 000044, 14.876
040753 BA 0A 00    1172  	dl 0x000ABA ; 000045, 15.085
040756 E0 0A 00    1173  	dl 0x000AE0 ; 000046, 15.293
040759 05 0B 00    1174  	dl 0x000B05 ; 000047, 15.501
04075C 2B 0B 00    1175  	dl 0x000B2B ; 000048, 15.709
04075F 51 0B 00    1176  	dl 0x000B51 ; 000049, 15.916
040762 77 0B 00    1177  	dl 0x000B77 ; 00004A, 16.123
040765 9C 0B 00    1178  	dl 0x000B9C ; 00004B, 16.329
040768 C2 0B 00    1179  	dl 0x000BC2 ; 00004C, 16.535
04076B E7 0B 00    1180  	dl 0x000BE7 ; 00004D, 16.740
04076E 0C 0C 00    1181  	dl 0x000C0C ; 00004E, 16.945
040771 32 0C 00    1182  	dl 0x000C32 ; 00004F, 17.150
040774 57 0C 00    1183  	dl 0x000C57 ; 000050, 17.354
040777 7C 0C 00    1184  	dl 0x000C7C ; 000051, 17.558
04077A A1 0C 00    1185  	dl 0x000CA1 ; 000052, 17.761
04077D C6 0C 00    1186  	dl 0x000CC6 ; 000053, 17.964
040780 EB 0C 00    1187  	dl 0x000CEB ; 000054, 18.166
040783 0F 0D 00    1188  	dl 0x000D0F ; 000055, 18.368
040786 34 0D 00    1189  	dl 0x000D34 ; 000056, 18.569
040789 58 0D 00    1190  	dl 0x000D58 ; 000057, 18.770
04078C 7D 0D 00    1191  	dl 0x000D7D ; 000058, 18.970
04078F A1 0D 00    1192  	dl 0x000DA1 ; 000059, 19.170
040792 C6 0D 00    1193  	dl 0x000DC6 ; 00005A, 19.370
040795 EA 0D 00    1194  	dl 0x000DEA ; 00005B, 19.569
040798 0E 0E 00    1195  	dl 0x000E0E ; 00005C, 19.767
04079B 32 0E 00    1196  	dl 0x000E32 ; 00005D, 19.965
04079E 56 0E 00    1197  	dl 0x000E56 ; 00005E, 20.163
0407A1 7A 0E 00    1198  	dl 0x000E7A ; 00005F, 20.360
0407A4 9E 0E 00    1199  	dl 0x000E9E ; 000060, 20.556
0407A7 C1 0E 00    1200  	dl 0x000EC1 ; 000061, 20.752
0407AA E5 0E 00    1201  	dl 0x000EE5 ; 000062, 20.947
0407AD 08 0F 00    1202  	dl 0x000F08 ; 000063, 21.142
0407B0 2C 0F 00    1203  	dl 0x000F2C ; 000064, 21.337
0407B3 4F 0F 00    1204  	dl 0x000F4F ; 000065, 21.531
0407B6 72 0F 00    1205  	dl 0x000F72 ; 000066, 21.724
0407B9 95 0F 00    1206  	dl 0x000F95 ; 000067, 21.917
0407BC B8 0F 00    1207  	dl 0x000FB8 ; 000068, 22.109
0407BF DB 0F 00    1208  	dl 0x000FDB ; 000069, 22.301
0407C2 FE 0F 00    1209  	dl 0x000FFE ; 00006A, 22.493
0407C5 21 10 00    1210  	dl 0x001021 ; 00006B, 22.683
0407C8 44 10 00    1211  	dl 0x001044 ; 00006C, 22.874
0407CB 66 10 00    1212  	dl 0x001066 ; 00006D, 23.063
0407CE 89 10 00    1213  	dl 0x001089 ; 00006E, 23.253
0407D1 AB 10 00    1214  	dl 0x0010AB ; 00006F, 23.441
0407D4 CD 10 00    1215  	dl 0x0010CD ; 000070, 23.629
0407D7 EF 10 00    1216  	dl 0x0010EF ; 000071, 23.817
0407DA 11 11 00    1217  	dl 0x001111 ; 000072, 24.004
0407DD 33 11 00    1218  	dl 0x001133 ; 000073, 24.191
0407E0 55 11 00    1219  	dl 0x001155 ; 000074, 24.376
0407E3 77 11 00    1220  	dl 0x001177 ; 000075, 24.562
0407E6 99 11 00    1221  	dl 0x001199 ; 000076, 24.747
0407E9 BA 11 00    1222  	dl 0x0011BA ; 000077, 24.931
0407EC DC 11 00    1223  	dl 0x0011DC ; 000078, 25.115
0407EF FD 11 00    1224  	dl 0x0011FD ; 000079, 25.298
0407F2 1E 12 00    1225  	dl 0x00121E ; 00007A, 25.481
0407F5 3F 12 00    1226  	dl 0x00123F ; 00007B, 25.663
0407F8 60 12 00    1227  	dl 0x001260 ; 00007C, 25.844
0407FB 81 12 00    1228  	dl 0x001281 ; 00007D, 26.025
0407FE A2 12 00    1229  	dl 0x0012A2 ; 00007E, 26.206
040801 C3 12 00    1230  	dl 0x0012C3 ; 00007F, 26.386
040804 E4 12 00    1231  	dl 0x0012E4 ; 000080, 26.565
040807 04 13 00    1232  	dl 0x001304 ; 000081, 26.744
04080A 25 13 00    1233  	dl 0x001325 ; 000082, 26.922
04080D 45 13 00    1234  	dl 0x001345 ; 000083, 27.100
040810 65 13 00    1235  	dl 0x001365 ; 000084, 27.277
040813 85 13 00    1236  	dl 0x001385 ; 000085, 27.453
040816 A5 13 00    1237  	dl 0x0013A5 ; 000086, 27.629
040819 C5 13 00    1238  	dl 0x0013C5 ; 000087, 27.805
04081C E5 13 00    1239  	dl 0x0013E5 ; 000088, 27.979
04081F 05 14 00    1240  	dl 0x001405 ; 000089, 28.154
040822 24 14 00    1241  	dl 0x001424 ; 00008A, 28.327
040825 44 14 00    1242  	dl 0x001444 ; 00008B, 28.501
040828 63 14 00    1243  	dl 0x001463 ; 00008C, 28.673
04082B 83 14 00    1244  	dl 0x001483 ; 00008D, 28.845
04082E A2 14 00    1245  	dl 0x0014A2 ; 00008E, 29.017
040831 C1 14 00    1246  	dl 0x0014C1 ; 00008F, 29.187
040834 E0 14 00    1247  	dl 0x0014E0 ; 000090, 29.358
040837 FF 14 00    1248  	dl 0x0014FF ; 000091, 29.527
04083A 1E 15 00    1249  	dl 0x00151E ; 000092, 29.697
04083D 3C 15 00    1250  	dl 0x00153C ; 000093, 29.865
040840 5B 15 00    1251  	dl 0x00155B ; 000094, 30.033
040843 79 15 00    1252  	dl 0x001579 ; 000095, 30.201
040846 98 15 00    1253  	dl 0x001598 ; 000096, 30.368
040849 B6 15 00    1254  	dl 0x0015B6 ; 000097, 30.534
04084C D4 15 00    1255  	dl 0x0015D4 ; 000098, 30.700
04084F F2 15 00    1256  	dl 0x0015F2 ; 000099, 30.865
040852 10 16 00    1257  	dl 0x001610 ; 00009A, 31.030
040855 2E 16 00    1258  	dl 0x00162E ; 00009B, 31.194
040858 4C 16 00    1259  	dl 0x00164C ; 00009C, 31.357
04085B 6A 16 00    1260  	dl 0x00166A ; 00009D, 31.520
04085E 87 16 00    1261  	dl 0x001687 ; 00009E, 31.682
040861 A5 16 00    1262  	dl 0x0016A5 ; 00009F, 31.844
040864 C2 16 00    1263  	dl 0x0016C2 ; 0000A0, 32.005
040867 DF 16 00    1264  	dl 0x0016DF ; 0000A1, 32.166
04086A FC 16 00    1265  	dl 0x0016FC ; 0000A2, 32.326
04086D 19 17 00    1266  	dl 0x001719 ; 0000A3, 32.486
040870 36 17 00    1267  	dl 0x001736 ; 0000A4, 32.645
040873 53 17 00    1268  	dl 0x001753 ; 0000A5, 32.803
040876 70 17 00    1269  	dl 0x001770 ; 0000A6, 32.961
040879 8C 17 00    1270  	dl 0x00178C ; 0000A7, 33.118
04087C A9 17 00    1271  	dl 0x0017A9 ; 0000A8, 33.275
04087F C5 17 00    1272  	dl 0x0017C5 ; 0000A9, 33.431
040882 E2 17 00    1273  	dl 0x0017E2 ; 0000AA, 33.587
040885 FE 17 00    1274  	dl 0x0017FE ; 0000AB, 33.742
040888 1A 18 00    1275  	dl 0x00181A ; 0000AC, 33.896
04088B 36 18 00    1276  	dl 0x001836 ; 0000AD, 34.050
04088E 52 18 00    1277  	dl 0x001852 ; 0000AE, 34.203
040891 6E 18 00    1278  	dl 0x00186E ; 0000AF, 34.356
040894 8A 18 00    1279  	dl 0x00188A ; 0000B0, 34.509
040897 A5 18 00    1280  	dl 0x0018A5 ; 0000B1, 34.660
04089A C1 18 00    1281  	dl 0x0018C1 ; 0000B2, 34.811
04089D DC 18 00    1282  	dl 0x0018DC ; 0000B3, 34.962
0408A0 F7 18 00    1283  	dl 0x0018F7 ; 0000B4, 35.112
0408A3 13 19 00    1284  	dl 0x001913 ; 0000B5, 35.262
0408A6 2E 19 00    1285  	dl 0x00192E ; 0000B6, 35.410
0408A9 49 19 00    1286  	dl 0x001949 ; 0000B7, 35.559
0408AC 64 19 00    1287  	dl 0x001964 ; 0000B8, 35.707
0408AF 7F 19 00    1288  	dl 0x00197F ; 0000B9, 35.854
0408B2 99 19 00    1289  	dl 0x001999 ; 0000BA, 36.001
0408B5 B4 19 00    1290  	dl 0x0019B4 ; 0000BB, 36.147
0408B8 CE 19 00    1291  	dl 0x0019CE ; 0000BC, 36.293
0408BB E9 19 00    1292  	dl 0x0019E9 ; 0000BD, 36.438
0408BE 03 1A 00    1293  	dl 0x001A03 ; 0000BE, 36.582
0408C1 1D 1A 00    1294  	dl 0x001A1D ; 0000BF, 36.726
0408C4 37 1A 00    1295  	dl 0x001A37 ; 0000C0, 36.870
0408C7 51 1A 00    1296  	dl 0x001A51 ; 0000C1, 37.013
0408CA 6B 1A 00    1297  	dl 0x001A6B ; 0000C2, 37.155
0408CD 85 1A 00    1298  	dl 0x001A85 ; 0000C3, 37.297
0408D0 9F 1A 00    1299  	dl 0x001A9F ; 0000C4, 37.439
0408D3 B9 1A 00    1300  	dl 0x001AB9 ; 0000C5, 37.579
0408D6 D2 1A 00    1301  	dl 0x001AD2 ; 0000C6, 37.720
0408D9 EC 1A 00    1302  	dl 0x001AEC ; 0000C7, 37.859
0408DC 05 1B 00    1303  	dl 0x001B05 ; 0000C8, 37.999
0408DF 1E 1B 00    1304  	dl 0x001B1E ; 0000C9, 38.137
0408E2 37 1B 00    1305  	dl 0x001B37 ; 0000CA, 38.276
0408E5 50 1B 00    1306  	dl 0x001B50 ; 0000CB, 38.413
0408E8 69 1B 00    1307  	dl 0x001B69 ; 0000CC, 38.550
0408EB 82 1B 00    1308  	dl 0x001B82 ; 0000CD, 38.687
0408EE 9B 1B 00    1309  	dl 0x001B9B ; 0000CE, 38.823
0408F1 B4 1B 00    1310  	dl 0x001BB4 ; 0000CF, 38.959
0408F4 CC 1B 00    1311  	dl 0x001BCC ; 0000D0, 39.094
0408F7 E5 1B 00    1312  	dl 0x001BE5 ; 0000D1, 39.228
0408FA FD 1B 00    1313  	dl 0x001BFD ; 0000D2, 39.362
0408FD 16 1C 00    1314  	dl 0x001C16 ; 0000D3, 39.496
040900 2E 1C 00    1315  	dl 0x001C2E ; 0000D4, 39.629
040903 46 1C 00    1316  	dl 0x001C46 ; 0000D5, 39.762
040906 5E 1C 00    1317  	dl 0x001C5E ; 0000D6, 39.894
040909 76 1C 00    1318  	dl 0x001C76 ; 0000D7, 40.025
04090C 8E 1C 00    1319  	dl 0x001C8E ; 0000D8, 40.156
04090F A5 1C 00    1320  	dl 0x001CA5 ; 0000D9, 40.286
040912 BD 1C 00    1321  	dl 0x001CBD ; 0000DA, 40.416
040915 D5 1C 00    1322  	dl 0x001CD5 ; 0000DB, 40.546
040918 EC 1C 00    1323  	dl 0x001CEC ; 0000DC, 40.675
04091B 04 1D 00    1324  	dl 0x001D04 ; 0000DD, 40.803
04091E 1B 1D 00    1325  	dl 0x001D1B ; 0000DE, 40.931
040921 32 1D 00    1326  	dl 0x001D32 ; 0000DF, 41.059
040924 49 1D 00    1327  	dl 0x001D49 ; 0000E0, 41.186
040927 60 1D 00    1328  	dl 0x001D60 ; 0000E1, 41.312
04092A 77 1D 00    1329  	dl 0x001D77 ; 0000E2, 41.438
04092D 8E 1D 00    1330  	dl 0x001D8E ; 0000E3, 41.564
040930 A5 1D 00    1331  	dl 0x001DA5 ; 0000E4, 41.689
040933 BB 1D 00    1332  	dl 0x001DBB ; 0000E5, 41.814
040936 D2 1D 00    1333  	dl 0x001DD2 ; 0000E6, 41.938
040939 E9 1D 00    1334  	dl 0x001DE9 ; 0000E7, 42.061
04093C FF 1D 00    1335  	dl 0x001DFF ; 0000E8, 42.184
04093F 15 1E 00    1336  	dl 0x001E15 ; 0000E9, 42.307
040942 2C 1E 00    1337  	dl 0x001E2C ; 0000EA, 42.429
040945 42 1E 00    1338  	dl 0x001E42 ; 0000EB, 42.551
040948 58 1E 00    1339  	dl 0x001E58 ; 0000EC, 42.672
04094B 6E 1E 00    1340  	dl 0x001E6E ; 0000ED, 42.793
04094E 84 1E 00    1341  	dl 0x001E84 ; 0000EE, 42.913
040951 99 1E 00    1342  	dl 0x001E99 ; 0000EF, 43.033
040954 AF 1E 00    1343  	dl 0x001EAF ; 0000F0, 43.152
040957 C5 1E 00    1344  	dl 0x001EC5 ; 0000F1, 43.271
04095A DA 1E 00    1345  	dl 0x001EDA ; 0000F2, 43.390
04095D F0 1E 00    1346  	dl 0x001EF0 ; 0000F3, 43.508
040960 05 1F 00    1347  	dl 0x001F05 ; 0000F4, 43.625
040963 1B 1F 00    1348  	dl 0x001F1B ; 0000F5, 43.742
040966 30 1F 00    1349  	dl 0x001F30 ; 0000F6, 43.859
040969 45 1F 00    1350  	dl 0x001F45 ; 0000F7, 43.975
04096C 5A 1F 00    1351  	dl 0x001F5A ; 0000F8, 44.091
04096F 6F 1F 00    1352  	dl 0x001F6F ; 0000F9, 44.206
040972 84 1F 00    1353  	dl 0x001F84 ; 0000FA, 44.321
040975 99 1F 00    1354  	dl 0x001F99 ; 0000FB, 44.435
040978 AD 1F 00    1355  	dl 0x001FAD ; 0000FC, 44.549
04097B C2 1F 00    1356  	dl 0x001FC2 ; 0000FD, 44.662
04097E D7 1F 00    1357  	dl 0x001FD7 ; 0000FE, 44.775
040981 EB 1F 00    1358  	dl 0x001FEB ; 0000FF, 44.888
040984 00 20 00    1359  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
040987             1360  
040987             1361  
040987             1362  	; ======= div_168_signed.inc stuff =======
040987             1363  
040987             1364  	; 24-bit integer and 16.8 fixed point division routines
040987             1365  ; by Brandon R. Gates (BeeGee747)
040987             1366  ; have undergone cursory testing and seem to be generating
040987             1367  ; correct results (assuming no overflows) but seem very inefficient,
040987             1368  ; so they have been published for review and improvement
040987             1369  ; see: https://discord.com/channels/1158535358624039014/1158536711148675072/1212136741608099910
040987             1370  ;
040987             1371  ; ---------------------------------------------------------
040987             1372  ; BEGIN DIVISION ROUTINES
040987             1373  ; ---------------------------------------------------------
040987             1374  ;
040987             1375  ; perform signed division of 16.8 fixed place values
040987             1376  ; with an signed 16.8 fixed place result
040987             1377  ; inputs: ub.c is dividend,ud.e is divisor
040987             1378  ; outputs: uh.l is quotient
040987             1379  ; destroys: a,bc
040987             1380  ; note: uses carry flag to test for sign of operands and result
040987             1381  ;       which can be confusing and should perhaps be changed
040987             1382  ; note2: helper functions abs_hlu and neg_hlu have been modified
040987             1383  ;       to return accurate flags according to the origional signs
040987             1384  ;       (or zero) of this function's inputs
040987             1385  sdiv168:
040987             1386  ; make everything positive and save signs
040987 C5          1387      push bc         ; get bc to hl
040988 E1          1388      pop hl          ; for the next call
040989 CD 2E 0A 04 1389      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
04098D CA C0 09 04 1390      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040991 F5          1391      push af         ; save sign of bc
040992 E5          1392      push hl         ; now put abs(hl)
040993 C1          1393      pop bc          ; back into bc = abs(bc)
040994 EB          1394      ex de,hl        ; now we do de same way
040995 CD 2E 0A 04 1395      call abs_hlu
040999 CA C2 09 04 1396      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
04099D EB          1397      ex de,hl        ; hl back to de = abs(de)
04099E             1398  ; determine sign of result
04099E F2 A9 09 04 1399      jp p,@de_pos    ; sign positive,de is positive
0409A2 F1          1400      pop af          ; get back sign of bc
0409A3 FA B2 09 04 1401      jp m,@result_pos  ; bc and de negative, result is positive
0409A7 18 05       1402      jr @result_neg
0409A9             1403  @de_pos:
0409A9 F1          1404      pop af          ; get back sign of bc
0409AA F2 B2 09 04 1405      jp p,@result_pos   ; bc and de are both positive so result is positive
0409AE             1406                      ; fall through to result_neg
0409AE             1407  @result_neg:
0409AE AF          1408      xor a           ; zero a and clear carry
0409AF 3D          1409      dec a           ; set sign flag to negative
0409B0 18 02       1410      jr @do_div
0409B2             1411  @result_pos:
0409B2 AF          1412      xor a           ; zero a and clear carry
0409B3 3C          1413      inc a           ; set sign flag to negative
0409B4             1414                      ; fall through to do_div
0409B4             1415  @do_div:
0409B4 F5          1416      push af         ; save sign of result
0409B5 CD C5 09 04 1417      call udiv168
0409B9 F1          1418      pop af          ; get back sign of result
0409BA F0          1419      ret p           ; result is positive so nothing to do
0409BB CD 3E 0A 04 1420      call neg_hlu    ; result is negative so negate it
0409BF C9          1421      ret
0409C0             1422  @is_zero:           ; result is zero
0409C0 AF          1423      xor a           ; sets zero flag, which we want,
0409C1             1424                      ; sets pv flag which we might not (zero is parity even)
0409C1             1425                      ; resets all others which is okay
0409C1 C9          1426      ret
0409C2             1427  @div_by_zero:       ; result is undefined, which isn't defined in binary
0409C2             1428                      ; so we'll just return zero until i can think of something better
0409C2 F1          1429      pop af          ; dummy pop
0409C3 AF          1430      xor a           ; sets zero flag, which is ok,
0409C4             1431                      ; sets pv flag which could be interpreted as overflow, which is good
0409C4             1432                      ; resets all others which is okay
0409C4 C9          1433      ret
0409C5             1434  
0409C5             1435  ; ; perform unsigned division of 16.8 fixed place values
0409C5             1436  ; ; with an unsigned 16.8 fixed place result
0409C5             1437  ; ; inputs: ub.c is dividend,ud.e is divisor
0409C5             1438  ; ; outputs: uh.l is quotient
0409C5             1439  ; ; destroys: a,bc
0409C5             1440  ; udiv168:
0409C5             1441  ; ; get the 16-bit integer part of the quotient
0409C5             1442  ;     ; call div_24
0409C5             1443  ;     call udiv24
0409C5             1444  ;     ; call dumpRegistersHex
0409C5             1445  ; ; load quotient to upper three bytes of output
0409C5             1446  ;     ld (div168_out+1),bc
0409C5             1447  ; ; TODO: THIS MAY BE BUGGED
0409C5             1448  ; ; check remainder for zero, and if it is
0409C5             1449  ; ; we can skip calculating the fractional part
0409C5             1450  ;     add hl,de
0409C5             1451  ;     or a
0409C5             1452  ;     sbc hl,de
0409C5             1453  ;     jr nz,@div256
0409C5             1454  ;     xor a
0409C5             1455  ;     jr @write_frac
0409C5             1456  ; ; END TODO
0409C5             1457  ; @div256:
0409C5             1458  ; ; divide divisor by 256
0409C5             1459  ;     push hl ; save remainder
0409C5             1460  ; ; TODO: it feels like this could be more efficient
0409C5             1461  ;     ld (arith24ude),de
0409C5             1462  ;     ld a,d
0409C5             1463  ;     ld (arith24ude),a
0409C5             1464  ;     ld a,(ude+2)
0409C5             1465  ;     ld (ude+1),a
0409C5             1466  ;     xor a
0409C5             1467  ;     ld (ude+2),a
0409C5             1468  ;     ld hl,(arith24ude) ; (just for now, we want it in de eventually)
0409C5             1469  ; ; TODO: THIS MAY BE BUGGED
0409C5             1470  ; ; now we check the shifted divisor for zero, and if it is
0409C5             1471  ; ; we again set the fractional part to zero
0409C5             1472  ;     add hl,de
0409C5             1473  ;     or a
0409C5             1474  ;     sbc hl,de
0409C5             1475  ;     ex de,hl ; now de is where it's supposed to be
0409C5             1476  ;     pop hl ; get remainder back
0409C5             1477  ; ; TODO: THIS MAY BE BUGGED
0409C5             1478  ;     jr nz,@div_frac
0409C5             1479  ;     xor a
0409C5             1480  ;     jr @write_frac
0409C5             1481  ; ; END TODO
0409C5             1482  ; ; now divide the remainder by the shifted divisor
0409C5             1483  ; @div_frac:
0409C5             1484  ;     push hl ; my kingdom for ld bc,hl
0409C5             1485  ;     pop bc  ; or even ex bc,hl
0409C5             1486  ;     ; call div_24
0409C5             1487  ;     call udiv24
0409C5             1488  ; ; load low byte of quotient to low byte of output
0409C5             1489  ;     ld a,c
0409C5             1490  ; @write_frac:
0409C5             1491  ;     ld (div168_out),a
0409C5             1492  ; ; load hl with return value
0409C5             1493  ;     ld hl,(div168_out)
0409C5             1494  ; ; load a with any overflow
0409C5             1495  ;     ld a,(div168_out+3)
0409C5             1496  ;     ret ; uh.l is the 16.8 result
0409C5             1497  ; div168_out: ds 4 ; the extra byte is for overflow
0409C5             1498  
0409C5             1499  ; perform unsigned division of fixed place values
0409C5             1500  ; with an unsigned 16.8 fixed place result
0409C5             1501  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0409C5             1502  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0409C5             1503  ; destroys: a,bc
0409C5             1504  udiv168:
0409C5             1505  ; shift dividend left 8 bits
0409C5 ED 43 0D 00 1506      ld (arith24ubc+1),bc
       04          
0409CA AF          1507      xor a
0409CB 32 0C 00 04 1508      ld (arith24ubc),a
0409CF ED 4B 0C 00 1509      ld bc,(arith24ubc)
       04          
0409D4 CD 49 00 04 1510      call udiv24
0409D8             1511  ; flip-flop outptuts to satisfy downstream consumers
0409D8             1512  ; TODO: this is a hack and should be fixed
0409D8             1513  ; (so says copilot ... but it's not wrong)
0409D8 E5          1514      push hl
0409D9 C5          1515      push bc
0409DA E1          1516      pop hl
0409DB C1          1517      pop bc
0409DC C9          1518      ret
0409DD             1519  
0409DD             1520  ; this is an adaptation of Div16 extended to 24 bits
0409DD             1521  ; from https://map.grauw.nl/articles/mult_div_shifts.php
0409DD             1522  ; it works by shifting each byte of the dividend left into carry 8 times
0409DD             1523  ; and adding the dividend into hl if the carry is set
0409DD             1524  ; thus hl accumulates a remainder depending on the result of each iteration
0409DD             1525  ; ---------------------------------------------------------
0409DD             1526  ; Divide 24-bit unsigned values
0409DD             1527  ;   with 24-bit unsigned result
0409DD             1528  ;   and 24-bit remainder
0409DD             1529  ; In: Divide ubc by ude
0409DD             1530  ; Out: ubc = result, uhl = remainder
0409DD             1531  ; Destroys: a,hl,bc
0409DD             1532  div_24:
0409DD 21 00 00 00 1533      ld hl,0     ; Clear accumulator for remainder
0409E1             1534  ; put dividend in scratch so we can get at all its bytes
0409E1 ED 43 0C 00 1535      ld (arith24ubc),bc ; scratch ubc also accumulates the quotient
       04          
0409E6 3A 0E 00 04 1536      ld a,(arith24ubc+2); grab the upper byte of the dividend
0409EA 06 08       1537      ld b,8      ; loop counter for 8 bits in a byte
0409EC             1538  @loop0:
0409EC 17          1539      rla         ; shift the next bit of dividend into the carry flag
0409ED ED 6A       1540      adc hl,hl   ; shift the remainder left one bit and add carry if any
0409EF ED 52       1541      sbc hl,de   ; subtract divisor from remainder
0409F1 30 01       1542      jr nc,@noadd0   ; if no carry,remainder is <= divisor
0409F3             1543                  ; meaning remainder is divisible by divisor
0409F3 19          1544      add hl,de   ; otherwise add divisor back to remainder
0409F4             1545                  ; reversing the previous subtraction
0409F4             1546  @noadd0:
0409F4 10 F6       1547      djnz @loop0 ; repeat for all 8 bits
0409F6 17          1548      rla         ; now we shift a left one more time
0409F7 2F          1549      cpl         ; then flip its bits for some reason
0409F8 32 0E 00 04 1550      ld (arith24ubc+2),a; magically this is the upper byte of the quotient
0409FC 3A 0D 00 04 1551      ld a,(arith24ubc+1); now we pick up the middle byte of the dividend
040A00 06 08       1552      ld b,8      ; set up the next loop and do it all again ...
040A02             1553  @loop1:
040A02 17          1554      rla
040A03 ED 6A       1555      adc hl,hl
040A05 ED 52       1556      sbc hl,de
040A07 30 01       1557      jr nc,@noadd1
040A09 19          1558      add hl,de
040A0A             1559  @noadd1:
040A0A 10 F6       1560      djnz @loop1
040A0C 17          1561      rla
040A0D 2F          1562      cpl
040A0E 32 0D 00 04 1563      ld (arith24ubc+1),a ; writing the middle byte of quotient
040A12 3A 0C 00 04 1564      ld a,(arith24ubc)
040A16 06 08       1565      ld b,8
040A18             1566  @loop2:          ; compute low byte of quotient
040A18 17          1567      rla
040A19 ED 6A       1568      adc hl,hl
040A1B ED 52       1569      sbc hl,de
040A1D 30 01       1570      jr nc,@noadd2
040A1F 19          1571      add hl,de
040A20             1572  @noadd2:
040A20 10 F6       1573      djnz @loop2
040A22 17          1574      rla
040A23 2F          1575      cpl
040A24 32 0C 00 04 1576      ld (arith24ubc),a  ; ... write low byte of quotient
040A28 ED 4B 0C 00 1577      ld bc,(arith24ubc) ; load quotient into bc for return
       04          
040A2D C9          1578      ret         ; hl already contains remainder so we're done
040A2E             1579  
040A2E             1580  ; ---------------------------------------------------------
040A2E             1581  ; BEGIN HELPER ROUTINES
040A2E             1582  ; ---------------------------------------------------------
040A2E             1583  ;
040A2E             1584  ; absolute value of hlu
040A2E             1585  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
040A2E             1586  ;         s1,z0,pv0,n1,c0 if hlu was negative
040A2E             1587  ;         s0,z1,pv0,n1,c0 if hlu was zero
040A2E             1588  ;         s0,z0,pv0,n1,c0 if hlu was positive
040A2E             1589  ; destroys: a
040A2E             1590  abs_hlu:
040A2E 19          1591      add hl,de
040A2F B7          1592      or a
040A30 ED 52       1593      sbc hl,de
040A32 FA 37 0A 04 1594      jp m,@is_neg
040A36 C9          1595      ret         ; hlu is positive or zero so we're done
040A37             1596  @is_neg:
040A37 F5          1597      push af     ; otherwise, save current flags for return
040A38 CD 3E 0A 04 1598      call neg_hlu ; negate hlu
040A3C F1          1599      pop af      ; get back flags
040A3D C9          1600      ret
040A3E             1601  
040A3E             1602  ; flip the sign of hlu
040A3E             1603  ; inputs: hlu
040A3E             1604  ; returns: 0-hlu, flags set appropriately for the result:
040A3E             1605  ;         s1,z0,pv0,n1,c1 if result is negative
040A3E             1606  ;         s0,z1,pv0,n1,c0 if result is zero
040A3E             1607  ;         s0,z0,pv0,n1,c1 if result is positive
040A3E             1608  ; destroys a
040A3E             1609  neg_hlu:
040A3E D5          1610      push de     ; save de
040A3F EB          1611      ex de,hl    ; put hl into de
040A40 21 00 00 00 1612      ld hl,0     ; clear hl
040A44 AF          1613      xor a       ; clear carry
040A45 ED 52       1614      sbc hl,de   ; 0-hlu = -hlu
040A47 D1          1615      pop de      ; get de back
040A48 C9          1616      ret         ; easy peasy
040A49             1617  
040A49             1618  ;------------------------------------------------------------------------
040A49             1619  ; divide hlu by 2, inspired by above
040A49             1620  ;------------------------------------------------------------------------
040A49             1621  hlu_div2:
040A49 22 03 01 04 1622  	ld		(bitbuf1),hl
040A4D 21 05 01 04 1623  	ld		hl,bitbuf1+2
040A51 CB 1E       1624  	rr		(hl)
040A53 2B          1625  	dec		hl
040A54 CB 1E       1626  	rr		(hl)
040A56 2B          1627  	dec		hl
040A57 CB 1E       1628  	rr		(hl)
040A59 23          1629  	inc		hl
040A5A 23          1630  	inc		hl
040A5B 2A 03 01 04 1631      ld hl,(bitbuf1)
040A5F C9          1632      ret
040A60             1633  
040A60             1634  ; this is my little hack to divide by 16
040A60             1635  hlu_div16:
040A60 AF          1636      xor a
040A61 29          1637      add hl,hl
040A62 17          1638      rla
040A63 29          1639      add hl,hl
040A64 17          1640      rla
040A65 29          1641      add hl,hl
040A66 17          1642      rla
040A67 29          1643      add hl,hl
040A68 17          1644      rla
040A69 22 76 0A 04 1645      ld (@scratch),hl
040A6D 32 79 0A 04 1646      ld (@scratch+3),a
040A71 2A 77 0A 04 1647      ld hl,(@scratch+1)
040A75 C9          1648      ret
040A76             1649  @scratch: ds 4
040A7A             1650  
040A7A             1651  ; -----------------------------------------------------------------------
040A7A             1652  ; EEMES TUTORIALS
040A7A             1653  ; -----------------------------------------------------------------------
040A7A             1654  ; https://tutorials.eeems.ca/Z80ASM/part4.htm
040A7A             1655  ; DEHL=BC*DE
040A7A             1656  Mul16:
040A7A 21 00 00 00 1657      ld hl,0
040A7E 3E 10       1658      ld a,16
040A80             1659  Mul16Loop:
040A80 29          1660      add hl,hl
040A81 CB 13       1661      rl e
040A83 CB 12       1662      rl d
040A85 D2 8F 0A 04 1663      jp nc,NoMul16
040A89 09          1664      add hl,bc
040A8A D2 8F 0A 04 1665      jp nc,NoMul16
040A8E 13          1666      inc de
040A8F             1667  NoMul16:
040A8F 3D          1668      dec a
040A90 C2 80 0A 04 1669      jp nz,Mul16Loop
040A94 C9          1670      ret
040A95             1671  
040A95             1672  ; DEUHLU=BCU*DEU
040A95             1673  umul2448:
040A95 21 00 00 00 1674      ld hl,0
040A99 3E 18       1675      ld a,24
040A9B             1676  umul2448Loop:
040A9B 29          1677      add hl,hl
040A9C EB          1678      ex de,hl
040A9D ED 6A       1679      adc hl,hl
040A9F EB          1680      ex de,hl
040AA0 D2 AA 0A 04 1681      jp nc,Noumul2448
040AA4 09          1682      add hl,bc
040AA5 D2 AA 0A 04 1683      jp nc,Noumul2448
040AA9 13          1684      inc de
040AAA             1685  Noumul2448:
040AAA 3D          1686      dec a
040AAB C2 9B 0A 04 1687      jp nz,umul2448Loop
040AAF C9          1688      ret
040AB0             1689  
040AB0             1690  umul168:
040AB0 CD 95 0A 04 1691      call umul2448
040AB4             1692  
040AB4             1693      ; call dumpUDEUHLHex
040AB4             1694  
040AB4             1695  ; UDEU.HL is the 32.16 fixed result
040AB4             1696  ; we want UH.L to be the 16.8 fixed result
040AB4             1697  ; so we divide by 256 by shiftng down a byte
040AB4             1698  ; easiest way is to write deu and hlu to scratch
040AB4 ED 53 C9 0A 1699      ld (umul168out+3),de
       04          
040AB9 22 C6 0A 04 1700      ld (umul168out),hl
040ABD             1701  ; then load hlu from scratch shfited forward a byte
040ABD 2A C7 0A 04 1702      ld hl,(umul168out+1)
040AC1 3A CB 0A 04 1703      ld a,(umul168out+5) ; send a back with any overflow
040AC5 C9          1704      ret
040AC6             1705  umul168out: ds 6
040ACC             1706  
040ACC             1707  ; perform signed multiplication of 16.8 fixed place values
040ACC             1708  ; with an signed 16.8 fixed place result
040ACC             1709  ; inputs: ub.c and ud.e are the operands
040ACC             1710  ; outputs: uh.l is the product
040ACC             1711  ; destroys: a,bc
040ACC             1712  ; TODO: make flags appropriate to the sign of the result
040ACC             1713  smul168:
040ACC             1714  ; make everything positive and save signs
040ACC C5          1715      push bc         ; get bc to hl
040ACD E1          1716      pop hl          ; for the next call
040ACE CD 2E 0A 04 1717      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
040AD2             1718  
040AD2             1719      ; call dumpFlags ; passes
040AD2             1720  
040AD2 CA 05 0B 04 1721      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
040AD6 F5          1722      push af         ; save sign of bc
040AD7 E5          1723      push hl         ; now put abs(hl)
040AD8 C1          1724      pop bc          ; back into bc = abs(bc)
040AD9 EB          1725      ex de,hl        ; now we do de same way
040ADA CD 2E 0A 04 1726      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
040ADE             1727  
040ADE             1728      ; call dumpFlags ; passes
040ADE             1729  
040ADE CA 05 0B 04 1730      jp z,@is_zero  ; if de was zero, answer is zero and we're done
040AE2 EB          1731      ex de,hl        ; hl back to de = abs(de)
040AE3             1732  ; determine sign of result
040AE3 F2 EE 0A 04 1733      jp p,@de_pos    ; sign positive,de is positive
040AE7             1734  
040AE7             1735      ; call dumpFlags ; correctly doesnt make it here
040AE7             1736  
040AE7 F1          1737      pop af          ; get back sign of bc
040AE8             1738  
040AE8             1739      ; call dumpFlags ; correctly doesn't make it here
040AE8             1740  
040AE8 FA F7 0A 04 1741      jp m,@result_pos  ; bc and de negative, result is positive
040AEC             1742  
040AEC             1743      ; call dumpFlags  ; corectly doesn't make it here
040AEC             1744  
040AEC 18 05       1745      jr @result_neg
040AEE             1746  @de_pos:
040AEE F1          1747      pop af          ; get back sign of bc
040AEF             1748  
040AEF             1749      ; call dumpFlags  ; passes
040AEF             1750  
040AEF F2 F7 0A 04 1751      jp p,@result_pos   ; bc and de are both positive so result is positive
040AF3             1752  
040AF3             1753      ; call dumpFlags ; correctly makes it here
040AF3             1754  
040AF3             1755                      ; fall through to result_neg
040AF3             1756  @result_neg:
040AF3 AF          1757      xor a           ; zero a and clear carry
040AF4 3D          1758      dec a           ; set sign flag to negative
040AF5             1759  
040AF5             1760      ; call dumpFlags ; passes
040AF5             1761  
040AF5 18 02       1762      jr @do_mul
040AF7             1763  @result_pos:
040AF7 AF          1764      xor a           ; zero a and clear carry
040AF8 3C          1765      inc a           ; set sign flag to positive
040AF9             1766                      ; fall through to do_mul
040AF9             1767  
040AF9             1768      ; call dumpFlags ; correctly doesn't make it here
040AF9             1769  
040AF9             1770  @do_mul:
040AF9 F5          1771      push af         ; save sign of result
040AFA CD B0 0A 04 1772      call umul168
040AFE F1          1773      pop af          ; get back sign of result
040AFF             1774  
040AFF             1775      ; call dumpFlags ; passes
040AFF             1776  
040AFF F0          1777      ret p           ; result is positive so nothing to do
040B00             1778  
040B00             1779      ; call dumpRegistersHex ; passes
040B00             1780  
040B00 CD 3E 0A 04 1781      call neg_hlu    ; result is negative so negate it
040B04             1782  
040B04             1783      ; call dumpRegistersHex ; passes
040B04 C9          1784      ret
040B05             1785  @is_zero:           ; result is zero
040B05 AF          1786      xor a           ; sets zero flag, which we want,
040B06             1787                      ; sets pv flag which we might not (zero is parity even)
040B06             1788                      ; resets all others which is okay
040B06 C9          1789      ret
