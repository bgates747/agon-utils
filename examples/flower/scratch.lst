PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "scratch.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 73 63 72 61 0001*M     ASCIZ "scratch.bin"
       74 63 68 2E 
       62 69 6E 00 
0B0010             0025*  
0B0010 FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD F0 19 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 97 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F CD B2 00 0B 0108*      call _skip_spaces ; skip whitespace
0B0153             0109*  
0B0153 7E          0110*      ld a, (hl) ; read first character
0B0154 B7          0111*      or a ; check for end of string
0B0155 C8          0112*      ret z ; return with no carry if not
0B0156             0113*  
0B0156 C5          0114*      push bc ; preserve bc
0B0157             0115*  
0B0157 FE 2D       0116*      cp '-' ; check for negative number
0B0159 C2 63 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B015D AF          0118*      xor a ; sign flag to zero
0B015E 32 97 01 0B 0119*      ld (@sign),a ; store sign flag
0B0162 23          0120*      inc hl ; skip '-'
0B0163             0121*  
0B0163             0122*  @loop:
0B0163 7E          0123*      ld a, (hl)
0B0164 D6 30       0124*      sub '0' ; normalise to 0
0B0166 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0168 FE 0A       0126*      cp 10 ; check if >= 10
0B016A 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B016C E5          0128*      push hl ; stack hl
0B016D D5          0129*      push de ; ld hl, de
0B016E E1          0130*      pop hl
0B016F E5          0131*      push hl ; ld bc, hl
0B0170 C1          0132*      pop bc
0B0171 29          0133*      add hl, hl ; x 2
0B0172 29          0134*      add hl, hl ; x 4
0B0173 09          0135*      add hl, bc ; x 5
0B0174 29          0136*      add hl, hl ; x 10
0B0175 01 00 00 00 0137*      ld bc, 0
0B0179 4F          0138*      ld c, a ; ld bcu, a
0B017A 09          0139*      add hl, bc ; add bcu to hl
0B017B E5          0140*      push hl ; ld de, hl
0B017C D1          0141*      pop de
0B017D E1          0142*      pop hl ; restore hl
0B017E 23          0143*      inc hl
0B017F 18 E2       0144*      jr @loop
0B0181             0145*  
0B0181             0146*  @integer_end:
0B0181 C1          0147*      pop bc ; send bc back how she came in
0B0182 3A 97 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0186 3D          0149*      dec a ; check if negative
0B0187 F2 95 01 0B 0150*      jp p,@pos ; positive number
0B018B             0151*  
0B018B             0152*  ; Negate de
0B018B E5          0153*      push hl ; save text pointer
0B018C 21 00 00 00 0154*      ld hl, 0
0B0190 AF          0155*      xor a ; clear carry
0B0191 ED 52       0156*      sbc hl, de ; subtract DE from HL
0B0193 EB          0157*      ex de, hl ; DE = 0-HL
0B0194 E1          0158*      pop hl ; restore text pointer
0B0195             0159*  
0B0195             0160*  @pos:
0B0195 37          0161*      scf ; we have a valid number so set carry
0B0196 C9          0162*      ret
0B0197             0163*  
0B0197 00          0164*  @sign: db 0 ; sign flag buffer
0B0198             0165*  
0B0198             0166*  
0B0198             0167*  ;------------------------------------------------------------------------
0B0198             0168*  ; Read a number and convert to binary (decimal only)
0B0198             0169*  ; Inputs: hl: Pointer in string buffer
0B0198             0170*  ; Outputs: hl: Updated text pointer
0B0198             0171*  ;         de: Value
0B0198             0172*  ;         a: Terminator (spaces skipped)
0B0198             0173*  ;         f: Carry set if valid number, otherwise reset
0B0198             0174*  ; Destroys: a, d, e, h, l, f
0B0198             0175*  ;------------------------------------------------------------------------
0B0198             0176*  asc_to_s168:
0B0198 3E 01       0177*      ld a,1 ; set sign flag
0B019A 32 57 02 0B 0178*      ld (@sign),a ; store sign flag
0B019E             0179*  
0B019E 11 00 00 00 0180*      ld de, 0 ; initialise de
0B01A2 ED 53 4F 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A7 ED 53 53 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01AC             0183*  
0B01AC CD B2 00 0B 0184*      call _skip_spaces ; skip whitespace
0B01B0             0185*  
0B01B0 7E          0186*      ld a, (hl) ; read first character
0B01B1 B7          0187*      or a ; check for end of string
0B01B2 C8          0188*      ret z ; return with no carry if not
0B01B3             0189*  
0B01B3 C5          0190*      push bc ; preserve bc
0B01B4             0191*  
0B01B4 FE 2D       0192*      cp '-' ; check for negative number
0B01B6 C2 C0 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01BA AF          0194*      xor a ; sign flag to zero
0B01BB 32 57 02 0B 0195*      ld (@sign),a ; store sign flag
0B01BF 23          0196*      inc hl ; skip '-'
0B01C0             0197*  
0B01C0             0198*  @loop:
0B01C0 7E          0199*      ld a, (hl)
0B01C1             0200*  
0B01C1             0201*  ; chcek for decimal point
0B01C1 FE 2E       0202*      cp '.' ; check for decimal point
0B01C3 CA 04 02 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01C7             0204*  
0B01C7             0205*  ; process integer part
0B01C7 D6 30       0206*      sub '0' ; normalise to 0
0B01C9 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01CB FE 0A       0208*      cp 10 ; check if >= 10
0B01CD 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01CF E5          0210*      push hl ; stack hl
0B01D0 D5          0211*      push de ; ld hl, de
0B01D1 E1          0212*      pop hl
0B01D2 E5          0213*      push hl ; ld bc, hl
0B01D3 C1          0214*      pop bc
0B01D4 29          0215*      add hl, hl ; x 2
0B01D5 29          0216*      add hl, hl ; x 4
0B01D6 09          0217*      add hl, bc ; x 5
0B01D7 29          0218*      add hl, hl ; x 10
0B01D8 01 00 00 00 0219*      ld bc, 0
0B01DC 4F          0220*      ld c, a ; ld bcu, a
0B01DD 09          0221*      add hl, bc ; add bcu to hl
0B01DE E5          0222*      push hl ; ld de, hl
0B01DF D1          0223*      pop de
0B01E0 E1          0224*      pop hl ; restore hl
0B01E1 23          0225*      inc hl
0B01E2 18 DC       0226*      jr @loop
0B01E4             0227*  
0B01E4             0228*  @integer_end:
0B01E4 ED 53 50 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E9             0230*  
0B01E9             0231*  @end:
0B01E9 C1          0232*      pop bc ; send bc back how she came in
0B01EA ED 5B 4F 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01EF 3A 57 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01F3 3D          0235*      dec a ; check if negative
0B01F4 F2 02 02 0B 0236*      jp p,@pos ; positive number
0B01F8             0237*  
0B01F8             0238*  ; Negate de
0B01F8 E5          0239*      push hl ; save text pointer
0B01F9 21 00 00 00 0240*      ld hl, 0
0B01FD AF          0241*      xor a ; clear carry
0B01FE ED 52       0242*      sbc hl, de ; subtract DE from HL
0B0200 EB          0243*      ex de, hl ; DE = 0-HL
0B0201 E1          0244*      pop hl ; restore text pointer
0B0202             0245*  
0B0202             0246*  @pos:
0B0202 37          0247*      scf ; we have a valid number so set carry
0B0203 C9          0248*      ret
0B0204             0249*  
0B0204             0250*  @fractional_start:
0B0204 ED 53 50 02 0251*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0209 06 03       0252*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B020B 11 00 00 00 0253*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B020F DD 21 58 02 0254*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0214 23          0255*      inc hl                     ; Skip decimal point
0B0215             0256*  
0B0215             0257*  @fractional_loop:
0B0215 7E          0258*      ld a, (hl)                 ; Load next character
0B0216 D6 30       0259*      sub '0'                    ; Normalize ASCII to decimal
0B0218 38 1C       0260*      jr c, @end_fraction        ; Exit if < '0'
0B021A FE 0A       0261*      cp 10
0B021C 30 18       0262*      jr nc, @end_fraction       ; Exit if >= 10
0B021E             0263*  
0B021E             0264*      ; Multiply the current fractional accumulator by 10
0B021E E5          0265*      push hl                    ; Save char pointer
0B021F F5          0266*      push af                    ; Save the digit
0B0220 EB          0267*      ex de, hl
0B0221 E5          0268*      push hl
0B0222 29          0269*      add hl,hl ; * 2
0B0223 29          0270*      add hl,hl ; * 4
0B0224 D1          0271*      pop de
0B0225 19          0272*      add hl,de ; * 5
0B0226 29          0273*      add hl,hl ; * 10
0B0227 11 00 00 00 0274*      ld de, 0                   ; Clear DEU
0B022B F1          0275*      pop af                     ; Restore the current digit
0B022C 5F          0276*      ld e, a                    ; Load the digit into E
0B022D 19          0277*      add hl, de                 ; Add the digit to the accumulator
0B022E EB          0278*      ex de, hl                  ; Result back to DE
0B022F ED 32 03    0279*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0232 E1          0280*      pop hl                     ; Restore char pointer
0B0233 23          0281*      inc hl                     ; Move to the next character
0B0234 10 DF       0282*      djnz @fractional_loop      ; Loop if more digits to process
0B0236             0283*  
0B0236             0284*  @end_fraction:
0B0236             0285*  ; Final scaling based on number of fractional digits processed
0B0236 ED 53 54 02 0286*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B023B 2A 53 02 0B 0287*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B023F             0288*  
0B023F DD 17 00    0289*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0242 CD 6D 0F 0B 0290*      call udiv24                ; Perform 24-bit division to scale down
0B0246 7B          0291*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0247 32 4F 02 0B 0292*      ld (@result), a            ; Store fractional part in result buffer
0B024B C3 E9 01 0B 0293*      jp @end                    ; Final sign check and flag setup
0B024F             0294*  
0B024F             0295*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0253             0296*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0257 00          0297*  @sign: db 0                    ; Sign flag buffer
0B0258             0298*  
0B0258             0299*  powers_of_10:
0B0258 01 00 00    0300*      dl 1                       ; 10^0
0B025B 0A 00 00    0301*      dl 10                      ; 10^1
0B025E 64 00 00    0302*      dl 100                     ; 10^2
0B0261 E8 03 00    0303*      dl 1000                    ; 10^3
0B0264 10 27 00    0304*      dl 10000                   ; 10^4
0B0267             0017   
0B0267             0018   ; API INCLUDES
0B0267             0019       include "functions.inc"
0B0267             0001*      MACRO printChar char
0B0267             0002*          LD A, char
0B0267             0003*          RST.LIL 10h
0B0267             0004*      ENDMACRO
0B0267             0005*  
0B0267             0006*  ; test the sign of HL
0B0267             0007*  ; inputs: HL obviously
0B0267             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0267             0009*  ; destroys: flags
0B0267             0010*      MACRO signHL
0B0267             0011*          add hl,de
0B0267             0012*          or a
0B0267             0013*          sbc hl,de
0B0267             0014*      ENDMACRO
0B0267             0015*  
0B0267             0016*  ; Simulated call to subroutine at HL
0B0267             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0267             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0267             0019*  ; destroys: only what the subroutine does, but always BC
0B0267             0020*      MACRO callHL
0B0267             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0022*          push bc       ; which constitutes the return address
0B0267             0023*          jp   (hl)     ; Jump to the address in HL
0B0267             0024*      ENDMACRO
0B0267             0025*  
0B0267             0026*  ; Simulated call to subroutine at IX
0B0267             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0267             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0267             0029*  ; destroys: only what the subroutine does, but always BC
0B0267             0030*      MACRO callIX
0B0267             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0032*          push bc       ; which constitutes the return address
0B0267             0033*          jp   (ix)     ; Jump to the address in IX
0B0267             0034*      ENDMACRO
0B0267             0035*  
0B0267             0036*  ; Simulated call to soubroutinte at IY
0B0267             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0267             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0267             0039*  ; destroys: only what the subroutine does, but always BC
0B0267             0040*      MACRO callIY
0B0267             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0042*          push bc       ; which constitutes the return address
0B0267             0043*          jp   (iy)     ; Jump to the address in IY
0B0267             0044*      ENDMACRO
0B0267             0045*  
0B0267             0046*  ; put the value in HLU into the accumulator
0B0267             0047*  ; destroys: af
0B0267             0048*      MACRO HLU_TO_A
0B0267             0049*          push hl ; 4 cycles
0B0267             0050*          inc sp ; 1 cycle
0B0267             0051*          pop af  ; 4 cycles
0B0267             0052*          dec sp ; 1 cycle
0B0267             0053*                 ; 10 cycles total
0B0267             0054*      ENDMACRO
0B0267             0055*  
0B0267             0056*  A_TO_HLU:
0B0267             0057*      ; call is 7 cycles
0B0267 22 74 02 0B 0058*      ld (@scratch),hl ; 7 cycles
0B026B 32 76 02 0B 0059*      ld (@scratch+2),a ; 5 cycles
0B026F 2A 74 02 0B 0060*      ld hl,(@scratch) ; 7 cycles
0B0273 C9          0061*      ret ; 6 cycles
0B0274             0062*          ; 25 cycles total
0B0274 00 00 00    0063*  @scratch: dl 0
0B0277             0064*  
0B0277             0065*      MACRO A_TO_HLU
0B0277             0066*          push.s af
0B0277             0067*          inc sp
0B0277             0068*          push.s hl
0B0277             0069*          pop hl
0B0277             0070*          inc sp
0B0277             0071*          inc sp
0B0277             0072*      ENDMACRO
0B0277             0073*  
0B0277             0074*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0277             0075*  ; Print a zero-terminated string
0B0277             0076*  ; HL: Pointer to string
0B0277             0077*  printString:
0B0277 C5          0078*  	PUSH	BC
0B0278 01 00 00 00 0079*  	LD		BC,0
0B027C 3E 00       0080*  	LD 	 	A,0
0B027E 5B DF       0081*  	RST.LIL 18h
0B0280 C1          0082*  	POP		BC
0B0281 C9          0083*  	RET
0B0282             0084*  ; print a VDU sequence
0B0282             0085*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0282             0086*  sendVDUsequence:
0B0282 C5          0087*  	PUSH	BC
0B0283 01 00 00 00 0088*  	LD		BC, 0
0B0287 4E          0089*  	LD		C, (HL)
0B0288 5B DF       0090*  	RST.LIL	18h
0B028A C1          0091*  	POP		BC
0B028B C9          0092*  	RET
0B028C             0093*  ; Print Newline sequence to VDP
0B028C             0094*  printNewLine:
0B028C F5          0095*      push af ; for some reason rst.lil 10h sets carry flag
0B028D 3E 0D       0096*  	LD	A, '\r'
0B028F 5B D7       0097*  	RST.LIL 10h
0B0291 3E 0A       0098*  	LD	A, '\n'
0B0293 5B D7       0099*  	RST.LIL 10h
0B0295 F1          0100*      pop af
0B0296 C9          0101*  	RET
0B0297             0102*  
0B0297             0103*  ; Print a 24-bit HEX number
0B0297             0104*  ; HLU: Number to print
0B0297             0105*  printHex24:
0B0297             0106*  	; PUSH	HL      ; 4 cycles
0B0297             0107*  	; LD		HL, 2   ; 4 cycles
0B0297             0108*  	; ADD		HL, SP  ; 1 cycle
0B0297             0109*  	; LD		A, (HL) ; 2 cycles
0B0297             0110*  	; POP		HL      ; 4 cycles
0B0297             0111*      ;                 ; 15 cycles total
0B0297 E5          0112*      push hl ; 4 cycles
0B0298 33          0113*      inc sp ; 1 cycle
0B0299 F1          0114*      pop af  ; 4 cycles
0B029A 3B          0115*      dec sp ; 1 cycle
0B029B             0116*              ; 10 cycles total
0B029B CD A5 02 0B 0117*  	CALL	printHex8
0B029F             0118*  ; Print a 16-bit HEX number
0B029F             0119*  ; HL: Number to print
0B029F             0120*  printHex16:
0B029F 7C          0121*  	LD		A,H
0B02A0 CD A5 02 0B 0122*  	CALL	printHex8
0B02A4 7D          0123*  	LD		A,L
0B02A5             0124*  ; Print an 8-bit HEX number
0B02A5             0125*  ; A: Number to print
0B02A5             0126*  printHex8:
0B02A5 4F          0127*  	LD		C,A
0B02A6 1F          0128*  	RRA
0B02A7 1F          0129*  	RRA
0B02A8 1F          0130*  	RRA
0B02A9 1F          0131*  	RRA
0B02AA CD AF 02 0B 0132*  	CALL	@F
0B02AE 79          0133*  	LD		A,C
0B02AF             0134*  @@:
0B02AF E6 0F       0135*  	AND		0Fh
0B02B1 C6 90       0136*  	ADD		A,90h
0B02B3 27          0137*  	DAA
0B02B4 CE 40       0138*  	ADC		A,40h
0B02B6 27          0139*  	DAA
0B02B7 5B D7       0140*  	RST.LIL	10h
0B02B9 C9          0141*  	RET
0B02BA             0142*  
0B02BA             0143*  printHexA:
0B02BA F5          0144*      push af
0B02BB C5          0145*      push bc
0B02BC CD A5 02 0B 0146*      call printHex8
0B02C0 3E 20       0147*      ld a,' '
0B02C2 5B D7       0148*      rst.lil 10h
0B02C4 C1          0149*      pop bc
0B02C5 F1          0150*      pop af
0B02C6 C9          0151*      ret
0B02C7             0152*  
0B02C7             0153*  printHexHL:
0B02C7 F5          0154*      push af
0B02C8 C5          0155*      push bc
0B02C9 CD 9F 02 0B 0156*      call printHex16
0B02CD 3E 20       0157*      ld a,' '
0B02CF 5B D7       0158*      rst.lil 10h
0B02D1 C1          0159*      pop bc
0B02D2 F1          0160*      pop af
0B02D3 C9          0161*      ret
0B02D4             0162*  
0B02D4             0163*  printHexUHL:
0B02D4 F5          0164*      push af
0B02D5 C5          0165*      push bc
0B02D6 CD 97 02 0B 0166*      call printHex24
0B02DA 3E 20       0167*      ld a,' '
0B02DC 5B D7       0168*      rst.lil 10h
0B02DE C1          0169*      pop bc
0B02DF F1          0170*      pop af
0B02E0 C9          0171*      ret
0B02E1             0172*  
0B02E1             0173*  printHexAUHL:
0B02E1 F5          0174*      push af
0B02E2 C5          0175*      push bc
0B02E3 CD A5 02 0B 0176*      call printHex8
0B02E7 3E 2E       0177*      ld a,'.'
0B02E9 5B D7       0178*      rst.lil 10h
0B02EB CD 97 02 0B 0179*      call printHex24
0B02EF 3E 20       0180*      ld a,' '
0B02F1 5B D7       0181*      rst.lil 10h
0B02F3 C1          0182*      pop bc
0B02F4 F1          0183*      pop af
0B02F5 C9          0184*      ret
0B02F6             0185*  
0B02F6             0186*  printHexABHL:
0B02F6             0187*  ; preserve registers
0B02F6 C5          0188*      push bc ; b will be ok c will not
0B02F7 F5          0189*      push af ; will get totally destroyed
0B02F8             0190*  ; print a
0B02F8 CD A5 02 0B 0191*      call printHex8
0B02FC             0192*  ; print b
0B02FC 78          0193*      ld a,b
0B02FD CD A5 02 0B 0194*      call printHex8
0B0301             0195*  ; print hl
0B0301 CD 9F 02 0B 0196*      call printHex16
0B0305             0197*  ; restore registers
0B0305 F1          0198*      pop af
0B0306 C1          0199*      pop bc
0B0307 C9          0200*      ret
0B0308             0201*  
0B0308             0202*  printHexBHL:
0B0308             0203*  ; preserve registers
0B0308 C5          0204*      push bc ; b will be ok c will not
0B0309 F5          0205*      push af ; will get totally destroyed
0B030A             0206*  ; print b
0B030A 78          0207*      ld a,b
0B030B CD A5 02 0B 0208*      call printHex8
0B030F             0209*  ; print hl
0B030F CD 9F 02 0B 0210*      call printHex16
0B0313             0211*  ; restore registers
0B0313 F1          0212*      pop af
0B0314 C1          0213*      pop bc
0B0315 C9          0214*      ret
0B0316             0215*  
0B0316             0216*  printHexCDE:
0B0316             0217*  ; preserve registers
0B0316 C5          0218*      push bc ; b will be ok c will not
0B0317 F5          0219*      push af ; will get totally destroyed
0B0318             0220*  ; print c
0B0318 79          0221*      ld a,c
0B0319 CD A5 02 0B 0222*      call printHex8
0B031D             0223*  ; print de
0B031D EB          0224*      ex de,hl
0B031E CD 9F 02 0B 0225*      call printHex16
0B0322 EB          0226*      ex de,hl
0B0323             0227*  ; restore registers
0B0323 F1          0228*      pop af
0B0324 C1          0229*      pop bc
0B0325 C9          0230*      ret
0B0326             0231*  
0B0326             0232*  ; Print a 0x HEX prefix
0B0326             0233*  DisplayHexPrefix:
0B0326 3E 30       0234*  	LD	A, '0'
0B0328 5B D7       0235*  	RST.LIL 10h
0B032A 3E 78       0236*  	LD	A, 'x'
0B032C 5B D7       0237*  	RST.LIL 10h
0B032E C9          0238*  	RET
0B032F             0239*  
0B032F             0240*      MACRO printDecBC
0B032F             0241*          push hl
0B032F             0242*          push bc
0B032F             0243*          pop hl
0B032F             0244*          call printDec
0B032F             0245*          pop hl
0B032F             0246*      ENDMACRO
0B032F             0247*  
0B032F             0248*      MACRO printDecDE
0B032F             0249*          push hl
0B032F             0250*          push de
0B032F             0251*          pop hl
0B032F             0252*          call printDec
0B032F             0253*          pop hl
0B032F             0254*      ENDMACRO
0B032F             0255*  
0B032F             0256*      MACRO printDecHL
0B032F             0257*          call printDec
0B032F             0258*      ENDMACRO
0B032F             0259*  
0B032F             0260*      MACRO printDecIX
0B032F             0261*          push hl
0B032F             0262*          push ix
0B032F             0263*          pop hl
0B032F             0264*          call printDec
0B032F             0265*          pop hl
0B032F             0266*      ENDMACRO
0B032F             0267*  
0B032F             0268*      MACRO printDecIY
0B032F             0269*          push hl
0B032F             0270*          push iy
0B032F             0271*          pop hl
0B032F             0272*          call printDec
0B032F             0273*          pop hl
0B032F             0274*      ENDMACRO
0B032F             0275*  
0B032F             0276*  
0B032F             0277*  ; Prints the right justified decimal value in HL without leading zeroes
0B032F             0278*  ; HL : Value to print
0B032F             0279*  ; preserves all registers and flags
0B032F             0280*  printDec:
0B032F             0281*  ; BEGIN MY CODE
0B032F             0282*  ; back up all the things
0B032F F5          0283*      push af
0B0330 C5          0284*      push bc
0B0331 D5          0285*      push de
0B0332 E5          0286*      push hl
0B0333             0287*  ; END MY CODE
0B0333 11 5B 03 0B 0288*  	LD	 DE, _printDecBuffer
0B0337 CD 6B 03 0B 0289*  	CALL u24_to_ascii
0B033B             0290*  ; BEGIN MY CODE
0B033B             0291*  ; replace leading zeroes with spaces
0B033B 21 5B 03 0B 0292*      LD	 HL, _printDecBuffer
0B033F 06 07       0293*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0341             0294*  @loop:
0B0341 7E          0295*      LD	 A, (HL)
0B0342 FE 30       0296*      CP	 '0'
0B0344 C2 52 03 0B 0297*      JP	 NZ, @done
0B0348 3E 20       0298*      LD   A, ' '
0B034A 77          0299*      LD	 (HL), A
0B034B 23          0300*      INC	 HL
0B034C CD 22 09 0B 0301*      CALL vdu_cursor_forward
0B0350 10 EF       0302*      DJNZ @loop
0B0352             0303*  @done:
0B0352             0304*  ; END MY CODE
0B0352             0305*  	; LD	 HL, _printDecBuffer
0B0352 CD 77 02 0B 0306*  	CALL printString
0B0356             0307*  ; BEGIN MY CODE
0B0356             0308*  ; restore all the things
0B0356 E1          0309*      pop hl
0B0357 D1          0310*      pop de
0B0358 C1          0311*      pop bc
0B0359 F1          0312*      pop af
0B035A             0313*  ; END MY CODE
0B035A C9          0314*  	RET
0B035B 00 00 00 00 0315*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B036B             0316*  
0B036B             0317*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B036B             0318*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B036B             0319*  ; so it will allways be 8 characters length
0B036B             0320*  ; HL : Value to convert to string
0B036B             0321*  ; DE : pointer to buffer, at least 8 byte + 0
0B036B             0322*  u24_to_ascii:
0B036B 01 80 69 67 0323*  	LD	 BC,-10000000
0B036F CD A2 03 0B 0324*  	CALL @one_digit
0B0373 01 C0 BD F0 0325*  	LD	 BC,-1000000
0B0377 CD A2 03 0B 0326*  	CALL @one_digit
0B037B 01 60 79 FE 0327*  	LD	 BC,-100000
0B037F CD A2 03 0B 0328*  	CALL @one_digit
0B0383 01 F0 D8 FF 0329*  	LD   BC,-10000
0B0387 CD A2 03 0B 0330*  	CALL @one_digit
0B038B 01 18 FC FF 0331*  	LD   BC,-1000
0B038F CD A2 03 0B 0332*  	CALL @one_digit
0B0393 01 9C FF FF 0333*  	LD   BC,-100
0B0397 CD A2 03 0B 0334*  	CALL @one_digit
0B039B 0E F6       0335*  	LD   C,-10
0B039D CD A2 03 0B 0336*  	CALL @one_digit
0B03A1 48          0337*  	LD   C,B
0B03A2             0338*  @one_digit:
0B03A2 3E 2F       0339*  	LD   A,'0'-1
0B03A4             0340*  @divide_me:
0B03A4 3C          0341*  	INC  A
0B03A5 09          0342*  	ADD  HL,BC
0B03A6 38 FC       0343*  	JR   C,@divide_me
0B03A8 ED 42       0344*  	SBC  HL,BC
0B03AA 12          0345*  	LD   (DE),A
0B03AB 13          0346*  	INC  DE
0B03AC C9          0347*  	RET
0B03AD             0348*  
0B03AD             0349*  print_u24:
0B03AD 11 5B 03 0B 0350*      ld de,_printDecBuffer
0B03B1 CD 6B 03 0B 0351*      call u24_to_ascii
0B03B5 21 5B 03 0B 0352*      ld hl,_printDecBuffer
0B03B9 CD 77 02 0B 0353*      call printString
0B03BD C9          0354*      ret
0B03BE             0355*  
0B03BE             0356*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B03BE             0357*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B03BE             0358*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B03BE             0359*  u168_to_ascii:
0B03BE             0360*  ; add a leading space to make room for sign flag if needed
0B03BE 3E 20       0361*      ld a,' '
0B03C0 12          0362*      ld (de),a
0B03C1 13          0363*      inc de
0B03C2             0364*  ; Convert integer part
0B03C2 E5          0365*      push hl               ; Save HL (well need the fractional part later)
0B03C3 CD 41 0F 0B 0366*      call shift_hlu_r1b    ; Shift to get integer portion in HL
0B03C7 01 F0 D8 FF 0367*      ld   bc, -10000
0B03CB CD EE 03 0B 0368*      call @one_int
0B03CF 01 18 FC FF 0369*      ld   bc, -1000
0B03D3 CD EE 03 0B 0370*      call @one_int
0B03D7 01 9C FF FF 0371*      ld   bc, -100
0B03DB CD EE 03 0B 0372*      call @one_int
0B03DF 0E F6       0373*      ld   c, -10
0B03E1 CD EE 03 0B 0374*      call @one_int
0B03E5 48          0375*      ld   c, b
0B03E6 CD EE 03 0B 0376*      call @one_int
0B03EA C3 F9 03 0B 0377*      jp   @frac            ; Jump to fractional part conversion
0B03EE             0378*  @one_int:
0B03EE 3E 2F       0379*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03F0             0380*  @divide_me:
0B03F0 3C          0381*      inc  a
0B03F1 09          0382*      add  hl, bc           ; Accumulate until overflow
0B03F2 38 FC       0383*      jr   c, @divide_me
0B03F4 ED 42       0384*      sbc  hl, bc           ; Remove excess after overflow
0B03F6 12          0385*      ld   (de), a          ; Store ASCII digit
0B03F7 13          0386*      inc  de
0B03F8 C9          0387*      ret
0B03F9             0388*  ; Convert fractional part
0B03F9             0389*  @frac:
0B03F9 3E 2E       0390*      ld   a, '.'           ; Decimal point
0B03FB 12          0391*      ld   (de), a
0B03FC 13          0392*      inc  de
0B03FD E1          0393*      pop  hl               ; Restore HL with original fraction
0B03FE 06 03       0394*      ld   b, 3             ; Loop counter for 3 fractional digits
0B0400             0395*  @frac_loop:
0B0400 26 0A       0396*      ld   h, 10            ; Load multiplier for fractional part
0B0402 ED 6C       0397*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B0404 3E 30       0398*      ld   a, '0'
0B0406 84          0399*      add  a, h             ; Convert integer part to ASCII
0B0407 12          0400*      ld   (de), a
0B0408 13          0401*      inc  de
0B0409 10 F5       0402*      djnz @frac_loop       ; Repeat for each fractional digit
0B040B             0403*  ; Add null terminator
0B040B AF          0404*      xor  a                ; Null terminator
0B040C 12          0405*      ld   (de), a
0B040D C9          0406*      ret
0B040E             0407*  
0B040E             0408*  print_u168:
0B040E 11 5B 03 0B 0409*      ld de,_printDecBuffer
0B0412 CD BE 03 0B 0410*      call u168_to_ascii
0B0416 21 5B 03 0B 0411*      ld hl,_printDecBuffer
0B041A CD 77 02 0B 0412*      call printString
0B041E C9          0413*      ret
0B041F             0414*  
0B041F             0415*  ; signed version of u168_to_ascii
0B041F             0416*  s168_to_ascii:
0B041F D5          0417*      push de ; save starting address of buffer
0B0420 CD 78 19 0B 0418*      call abs_hlu
0B0424 F5          0419*      push af ; save sign flag
0B0425 CD BE 03 0B 0420*      call u168_to_ascii
0B0429 F1          0421*      pop af ; restore sign flag
0B042A D1          0422*      pop de ; restore starting address of buffer
0B042B F0          0423*      ret p ; hlu was positive so nothing to do
0B042C 3E 2D       0424*      ld a,'-'
0B042E 12          0425*      ld (de),a
0B042F C9          0426*      ret
0B0430             0427*  
0B0430             0428*  print_s168:
0B0430 11 5B 03 0B 0429*      ld de,_printDecBuffer
0B0434 CD 1F 04 0B 0430*      call s168_to_ascii
0B0438 21 5B 03 0B 0431*      ld hl,_printDecBuffer
0B043C CD 77 02 0B 0432*      call printString
0B0440 C9          0433*      ret
0B0441             0434*  
0B0441             0435*  ; #### new functions added by Brandon R. Gates ####
0B0441             0436*  
0B0441             0437*  ; print the binary representation of the 8-bit value in a
0B0441             0438*  ; destroys a, hl, bc
0B0441             0439*  printBin8:
0B0441 06 08       0440*      ld b,8      ; loop counter for 8 bits
0B0443 21 5E 04 0B 0441*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0447             0442*                  ; (which will be the high bit of the value in a)
0B0447             0443*  @loop:
0B0447 07          0444*      rlca ; put the next highest bit into carry
0B0448 38 04       0445*      jr c,@one
0B044A 36 30       0446*      ld (hl),'0'
0B044C 18 02       0447*      jr @next_bit
0B044E             0448*  @one:
0B044E 36 31       0449*      ld (hl),'1'
0B0450             0450*  @next_bit:
0B0450 23          0451*      inc hl
0B0451 10 F4       0452*      djnz @loop
0B0453             0453*  ; print it
0B0453 21 5E 04 0B 0454*  	ld hl,@cmd
0B0457 01 08 00 00 0455*  	ld bc,@end-@cmd
0B045B 5B DF       0456*  	rst.lil $18
0B045D C9          0457*  	ret
0B045E             0458*  @cmd: ds 8 ; eight bytes for eight bits
0B0466             0459*  @end:
0B0466             0460*  
0B0466             0461*  ; print the binary representation of the 8-bit value in a
0B0466             0462*  ; in reverse order (lsb first)
0B0466             0463*  ; destroys a, hl, bc
0B0466             0464*  printBin8Rev:
0B0466 06 08       0465*      ld b,8      ; loop counter for 8 bits
0B0468 21 83 04 0B 0466*      ld hl,@cmd  ; set hl to the low byte of the output string
0B046C             0467*                  ; (which will be the high bit of the value in a)
0B046C             0468*  @loop:
0B046C 0F          0469*      rrca ; put the next lowest bit into carry
0B046D 38 04       0470*      jr c,@one
0B046F 36 30       0471*      ld (hl),'0'
0B0471 18 02       0472*      jr @next_bit
0B0473             0473*  @one:
0B0473 36 31       0474*      ld (hl),'1'
0B0475             0475*  @next_bit:
0B0475 23          0476*      inc hl
0B0476 10 F4       0477*      djnz @loop
0B0478             0478*  ; print it
0B0478 21 83 04 0B 0479*  	ld hl,@cmd
0B047C 01 08 00 00 0480*  	ld bc,@end-@cmd
0B0480 5B DF       0481*  	rst.lil $18
0B0482 C9          0482*  	ret
0B0483             0483*  @cmd: ds 8 ; eight bytes for eight bits
0B048B             0484*  @end:
0B048B             0485*  
0B048B             0486*  ; print registers to screen in hexidecimal format
0B048B             0487*  ; inputs: none
0B048B             0488*  ; outputs: values of every register printed to screen
0B048B             0489*  ;    values of each register in global scratch memory
0B048B             0490*  ; destroys: nothing
0B048B             0491*  stepRegistersHex:
0B048B             0492*  ; store everything in scratch
0B048B 22 78 06 0B 0493*      ld (uhl),hl
0B048F ED 43 7B 06 0494*      ld (ubc),bc
       0B          
0B0494 ED 53 7E 06 0495*      ld (ude),de
       0B          
0B0499 DD 22 81 06 0496*      ld (uix),ix
       0B          
0B049E FD 22 84 06 0497*      ld (uiy),iy
       0B          
0B04A3 F5          0498*      push af ; fml
0B04A4 E1          0499*      pop hl  ; thanks, zilog
0B04A5 22 75 06 0B 0500*      ld (uaf),hl
0B04A9 F5          0501*      push af ; dammit
0B04AA             0502*  
0B04AA             0503*  ; home the cursor
0B04AA CD 01 09 0B 0504*      call vdu_home_cursor
0B04AE             0505*  
0B04AE             0506*  ; print each register
0B04AE 21 FB 05 0B 0507*      ld hl,str_afu
0B04B2 CD 77 02 0B 0508*      call printString
0B04B6 2A 75 06 0B 0509*      ld hl,(uaf)
0B04BA CD 97 02 0B 0510*      call printHex24
0B04BE CD 8C 02 0B 0511*      call printNewLine
0B04C2             0512*  
0B04C2 21 00 06 0B 0513*      ld hl,str_hlu
0B04C6 CD 77 02 0B 0514*      call printString
0B04CA 2A 78 06 0B 0515*      ld hl,(uhl)
0B04CE CD 97 02 0B 0516*      call printHex24
0B04D2 CD 8C 02 0B 0517*      call printNewLine
0B04D6             0518*  
0B04D6 21 05 06 0B 0519*      ld hl,str_bcu
0B04DA CD 77 02 0B 0520*      call printString
0B04DE 2A 7B 06 0B 0521*      ld hl,(ubc)
0B04E2 CD 97 02 0B 0522*      call printHex24
0B04E6 CD 8C 02 0B 0523*      call printNewLine
0B04EA             0524*  
0B04EA 21 0A 06 0B 0525*      ld hl,str_deu
0B04EE CD 77 02 0B 0526*      call printString
0B04F2 2A 7E 06 0B 0527*      ld hl,(ude)
0B04F6 CD 97 02 0B 0528*      call printHex24
0B04FA CD 8C 02 0B 0529*      call printNewLine
0B04FE             0530*  
0B04FE 21 0F 06 0B 0531*      ld hl,str_ixu
0B0502 CD 77 02 0B 0532*      call printString
0B0506 2A 81 06 0B 0533*      ld hl,(uix)
0B050A CD 97 02 0B 0534*      call printHex24
0B050E CD 8C 02 0B 0535*      call printNewLine
0B0512             0536*  
0B0512 21 14 06 0B 0537*      ld hl,str_iyu
0B0516 CD 77 02 0B 0538*      call printString
0B051A 2A 84 06 0B 0539*      ld hl,(uiy)
0B051E CD 97 02 0B 0540*      call printHex24
0B0522 CD 8C 02 0B 0541*      call printNewLine
0B0526             0542*  
0B0526             0543*      ; call vsync
0B0526             0544*  
0B0526 CD 8C 02 0B 0545*      call printNewLine
0B052A             0546*  
0B052A             0547*  ; check for right shift key and quit if pressed
0B052A             0548*  	MOSCALL mos_getkbmap
0B052A 3E 1E       0001*M 			LD	A, function
0B052C 5B CF       0002*M 			RST.L	08h
0B052E             0549*  @stayhere:
0B052E             0550*  ; 7 RightShift
0B052E DD CB 00 76 0551*      bit 6,(ix+0)
0B0532 20 02       0552*      jr nz,@RightShift
0B0534 18 F8       0553*      jr @stayhere
0B0536             0554*  @RightShift:
0B0536 DD CB 0E 86 0555*      res 0,(ix+14) ; debounce the key (hopefully)
0B053A 3E 80       0556*      ld a,%10000000
0B053C CD E1 08 0B 0557*      call multiPurposeDelay
0B0540             0558*  
0B0540             0559*  ; restore everything
0B0540 2A 78 06 0B 0560*      ld hl, (uhl)
0B0544 ED 4B 7B 06 0561*      ld bc, (ubc)
       0B          
0B0549 ED 5B 7E 06 0562*      ld de, (ude)
       0B          
0B054E DD 2A 81 06 0563*      ld ix, (uix)
       0B          
0B0553 FD 2A 84 06 0564*      ld iy, (uiy)
       0B          
0B0558 F1          0565*      pop af
0B0559             0566*  ; all done
0B0559 C9          0567*      ret
0B055A             0568*  
0B055A             0569*  ; print registers to screen in hexidecimal format
0B055A             0570*  ; inputs: none
0B055A             0571*  ; outputs: values of every register printed to screen
0B055A             0572*  ;    values of each register in global scratch memory
0B055A             0573*  ; destroys: nothing
0B055A             0574*  dumpRegistersHex:
0B055A             0575*  ; store everything in scratch
0B055A 22 78 06 0B 0576*      ld (uhl),hl
0B055E ED 43 7B 06 0577*      ld (ubc),bc
       0B          
0B0563 ED 53 7E 06 0578*      ld (ude),de
       0B          
0B0568 DD 22 81 06 0579*      ld (uix),ix
       0B          
0B056D FD 22 84 06 0580*      ld (uiy),iy
       0B          
0B0572 F5          0581*      push af ; fml
0B0573 E1          0582*      pop hl  ; thanks, zilog
0B0574 22 75 06 0B 0583*      ld (uaf),hl
0B0578 F5          0584*      push af ; dammit
0B0579             0585*  
0B0579             0586*  ; home the cursor
0B0579             0587*      ; call vdu_home_cursor
0B0579             0588*      ; call printNewLine
0B0579             0589*  
0B0579             0590*  ; print each register
0B0579 21 FB 05 0B 0591*      ld hl,str_afu
0B057D CD 77 02 0B 0592*      call printString
0B0581 2A 75 06 0B 0593*      ld hl,(uaf)
0B0585 CD 97 02 0B 0594*      call printHex24
0B0589             0595*      ; call printNewLine
0B0589             0596*  
0B0589 21 00 06 0B 0597*      ld hl,str_hlu
0B058D CD 77 02 0B 0598*      call printString
0B0591 2A 78 06 0B 0599*      ld hl,(uhl)
0B0595 CD 97 02 0B 0600*      call printHex24
0B0599             0601*      ; call printNewLine
0B0599             0602*  
0B0599 21 05 06 0B 0603*      ld hl,str_bcu
0B059D CD 77 02 0B 0604*      call printString
0B05A1 2A 7B 06 0B 0605*      ld hl,(ubc)
0B05A5 CD 97 02 0B 0606*      call printHex24
0B05A9             0607*      ; call printNewLine
0B05A9             0608*  
0B05A9 21 0A 06 0B 0609*      ld hl,str_deu
0B05AD CD 77 02 0B 0610*      call printString
0B05B1 2A 7E 06 0B 0611*      ld hl,(ude)
0B05B5 CD 97 02 0B 0612*      call printHex24
0B05B9             0613*      ; call printNewLine
0B05B9             0614*  
0B05B9 21 0F 06 0B 0615*      ld hl,str_ixu
0B05BD CD 77 02 0B 0616*      call printString
0B05C1 2A 81 06 0B 0617*      ld hl,(uix)
0B05C5 CD 97 02 0B 0618*      call printHex24
0B05C9             0619*      ; call printNewLine
0B05C9             0620*  
0B05C9 21 14 06 0B 0621*      ld hl,str_iyu
0B05CD CD 77 02 0B 0622*      call printString
0B05D1 2A 84 06 0B 0623*      ld hl,(uiy)
0B05D5 CD 97 02 0B 0624*      call printHex24
0B05D9             0625*      ; call printNewLine
0B05D9             0626*  
0B05D9 CD 96 09 0B 0627*      call vdu_vblank
0B05DD             0628*  
0B05DD CD 8C 02 0B 0629*      call printNewLine
0B05E1             0630*  ; restore everything
0B05E1 2A 78 06 0B 0631*      ld hl, (uhl)
0B05E5 ED 4B 7B 06 0632*      ld bc, (ubc)
       0B          
0B05EA ED 5B 7E 06 0633*      ld de, (ude)
       0B          
0B05EF DD 2A 81 06 0634*      ld ix, (uix)
       0B          
0B05F4 FD 2A 84 06 0635*      ld iy, (uiy)
       0B          
0B05F9 F1          0636*      pop af
0B05FA             0637*  ; all done
0B05FA C9          0638*      ret
0B05FB             0639*  
0B05FB 20 61 66 3D 0640*  str_afu: db " af=",0
       00          
0B0600 20 68 6C 3D 0641*  str_hlu: db " hl=",0
       00          
0B0605 20 62 63 3D 0642*  str_bcu: db " bc=",0
       00          
0B060A 20 64 65 3D 0643*  str_deu: db " de=",0
       00          
0B060F 20 69 78 3D 0644*  str_ixu: db " ix=",0
       00          
0B0614 20 69 79 3D 0645*  str_iyu: db " iy=",0
       00          
0B0619             0646*  
0B0619             0647*  ; print udeuhl to screen in hexidecimal format
0B0619             0648*  ; inputs: none
0B0619             0649*  ; outputs: concatenated hexidecimal udeuhl
0B0619             0650*  ; destroys: nothing
0B0619             0651*  dumpUDEUHLHex:
0B0619             0652*  ; store everything in scratch
0B0619 22 78 06 0B 0653*      ld (uhl),hl
0B061D ED 43 7B 06 0654*      ld (ubc),bc
       0B          
0B0622 ED 53 7E 06 0655*      ld (ude),de
       0B          
0B0627 DD 22 81 06 0656*      ld (uix),ix
       0B          
0B062C FD 22 84 06 0657*      ld (uiy),iy
       0B          
0B0631 F5          0658*      push af
0B0632             0659*  
0B0632             0660*  ; print each register
0B0632             0661*  
0B0632 21 6C 06 0B 0662*      ld hl,str_udeuhl
0B0636 CD 77 02 0B 0663*      call printString
0B063A 2A 7E 06 0B 0664*      ld hl,(ude)
0B063E CD 97 02 0B 0665*      call printHex24
0B0642 3E 2E       0666*  	ld a,'.'	; print a dot to separate the values
0B0644 5B D7       0667*  	rst.lil 10h
0B0646 2A 78 06 0B 0668*      ld hl,(uhl)
0B064A CD 97 02 0B 0669*      call printHex24
0B064E CD 8C 02 0B 0670*      call printNewLine
0B0652             0671*  
0B0652             0672*  ; restore everything
0B0652 2A 78 06 0B 0673*      ld hl, (uhl)
0B0656 ED 4B 7B 06 0674*      ld bc, (ubc)
       0B          
0B065B ED 5B 7E 06 0675*      ld de, (ude)
       0B          
0B0660 DD 2A 81 06 0676*      ld ix, (uix)
       0B          
0B0665 FD 2A 84 06 0677*      ld iy, (uiy)
       0B          
0B066A F1          0678*      pop af
0B066B             0679*  ; all done
0B066B C9          0680*      ret
0B066C             0681*  
0B066C 75 64 65 2E 0682*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0675             0683*  
0B0675             0684*  ; global scratch memory for registers
0B0675 00 00 00    0685*  uaf: dl 0
0B0678 00 00 00    0686*  uhl: dl 0
0B067B 00 00 00    0687*  ubc: dl 0
0B067E 00 00 00    0688*  ude: dl 0
0B0681 00 00 00    0689*  uix: dl 0
0B0684 00 00 00    0690*  uiy: dl 0
0B0687 00 00 00    0691*  usp: dl 0
0B068A 00 00 00    0692*  upc: dl 0
0B068D             0693*  
0B068D             0694*  ; inputs: whatever is in the flags register
0B068D             0695*  ; outputs: binary representation of flags
0B068D             0696*  ;          with a header so we know which is what
0B068D             0697*  ; destroys: nothing
0B068D             0698*  ; preserves: everything
0B068D             0699*  dumpFlags:
0B068D             0700*  ; first we curse zilog for not giving direct access to flags
0B068D F5          0701*      push af ; this is so we can send it back unharmed
0B068E F5          0702*      push af ; this is so we can pop it to hl
0B068F             0703*  ; store everything in scratch
0B068F 22 78 06 0B 0704*      ld (uhl),hl
0B0693 ED 43 7B 06 0705*      ld (ubc),bc
       0B          
0B0698 ED 53 7E 06 0706*      ld (ude),de
       0B          
0B069D DD 22 81 06 0707*      ld (uix),ix
       0B          
0B06A2 FD 22 84 06 0708*      ld (uiy),iy
       0B          
0B06A7             0709*  ; next we print the header
0B06A7 21 D3 06 0B 0710*      ld hl,@header
0B06AB CD 77 02 0B 0711*      call printString
0B06AF E1          0712*      pop hl ; flags are now in l
0B06B0 7D          0713*      ld a,l ; flags are now in a
0B06B1 CD 41 04 0B 0714*      call printBin8
0B06B5 CD 8C 02 0B 0715*  	call printNewLine
0B06B9             0716*  ; restore everything
0B06B9 2A 78 06 0B 0717*      ld hl, (uhl)
0B06BD ED 4B 7B 06 0718*      ld bc, (ubc)
       0B          
0B06C2 ED 5B 7E 06 0719*      ld de, (ude)
       0B          
0B06C7 DD 2A 81 06 0720*      ld ix, (uix)
       0B          
0B06CC FD 2A 84 06 0721*      ld iy, (uiy)
       0B          
0B06D1 F1          0722*      pop af ; send her home the way she came
0B06D2 C9          0723*      ret
0B06D3             0724*  ; Bit 7 (S): Sign flag
0B06D3             0725*  ; Bit 6 (Z): Zero flag
0B06D3             0726*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B06D3             0727*  ; Bit 4 (H): Half Carry flag
0B06D3             0728*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B06D3             0729*  ; Bit 2 (PV): Parity/Overflow flag
0B06D3             0730*  ; Bit 1 (N): Subtract flag
0B06D3             0731*  ; Bit 0 (C): Carry flag
0B06D3 53 5A 78 48 0732*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B06DE             0733*  
0B06DE             0734*  ; set all the bits in the flag register
0B06DE             0735*  ; more of an academic exercise than anything useful
0B06DE             0736*  ; inputs; none
0B06DE             0737*  ; outputs; a=0,f=255
0B06DE             0738*  ; destroys: flags, hl
0B06DE             0739*  ; preserves: a, because why not
0B06DE             0740*  setAllFlags:
0B06DE 21 FF 00 00 0741*      ld hl,255
0B06E2 67          0742*      ld h,a ; four cycles to preserve a is cheap
0B06E3 E5          0743*      push hl
0B06E4 F1          0744*      pop af
0B06E5 C9          0745*      ret
0B06E6             0746*  
0B06E6             0747*  ; reset all the bits in the flag register
0B06E6             0748*  ; unlike its inverse counterpart, this may actually be useful
0B06E6             0749*  ; inputs; none
0B06E6             0750*  ; outputs; a=0,f=0
0B06E6             0751*  ; destroys: flags, hl
0B06E6             0752*  ; preserves: a, because why not
0B06E6             0753*  resetAllFlags:
0B06E6 21 00 00 00 0754*      ld hl,0
0B06EA 67          0755*      ld h,a ; four cycles to preserve a is cheap
0B06EB E5          0756*      push hl
0B06EC F1          0757*      pop af
0B06ED C9          0758*      ret
0B06EE             0759*  
0B06EE             0760*  ; wait until user presses a key
0B06EE             0761*  ; inputs: none
0B06EE             0762*  ; outputs: none
0B06EE             0763*  ; destroys: af,ix
0B06EE             0764*  waitKeypress:
0B06EE             0765*      MOSCALL mos_sysvars
0B06EE 3E 08       0001*M 			LD	A, function
0B06F0 5B CF       0002*M 			RST.L	08h
0B06F2 AF          0766*      xor a ; zero out any prior keypresses
0B06F3 DD 77 05    0767*      ld (ix+sysvar_keyascii),a
0B06F6             0768*  @loop:
0B06F6 DD 7E 05    0769*      ld a,(ix+sysvar_keyascii)
0B06F9 A7          0770*      and a
0B06FA C0          0771*      ret nz
0B06FB 18 F9       0772*      jr @loop
0B06FD             0773*  
0B06FD             0774*  
0B06FD             0775*  ; print bytes from an address to the screen in hexidecimal format
0B06FD             0776*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06FD             0777*  ; outputs: values of each byte printed to screen separated by spaces
0B06FD             0778*  ; destroys: nothing
0B06FD             0779*  dumpMemoryHex:
0B06FD             0780*  ; save registers to the stack
0B06FD C5          0781*      push bc
0B06FE E5          0782*      push hl
0B06FF F5          0783*      push af
0B0700             0784*  
0B0700             0785*  ; print the address and separator
0B0700 CD 97 02 0B 0786*      call printHex24
0B0704 3E 3A       0787*      ld a,':'
0B0706 5B D7       0788*      rst.lil 10h
0B0708 3E 20       0789*      ld a,' '
0B070A 5B D7       0790*      rst.lil 10h
0B070C             0791*  
0B070C             0792*  ; set b to be our loop counter
0B070C F1          0793*      pop af
0B070D 47          0794*      ld b,a
0B070E E1          0795*      pop hl
0B070F E5          0796*      push hl
0B0710 F5          0797*      push af
0B0711             0798*  @loop:
0B0711             0799*  ; print the byte
0B0711 7E          0800*      ld a,(hl)
0B0712 CD A5 02 0B 0801*      call printHex8
0B0716             0802*  ; print a space
0B0716 3E 20       0803*      ld a,' '
0B0718 5B D7       0804*      rst.lil 10h
0B071A 23          0805*      inc hl
0B071B 10 F4       0806*      djnz @loop
0B071D             0807*      ; call printNewLine
0B071D             0808*  
0B071D             0809*  ; restore everything
0B071D F1          0810*      pop af
0B071E E1          0811*      pop hl
0B071F C1          0812*      pop bc
0B0720             0813*  
0B0720             0814*  ; all done
0B0720 C9          0815*      ret
0B0721             0816*  
0B0721             0817*  
0B0721             0818*  ; print bytes from an address to the screen in binary format
0B0721             0819*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0721             0820*  ; outputs: values of each byte printed to screen separated by spaces
0B0721             0821*  ; destroys: nothing
0B0721             0822*  dumpMemoryBin:
0B0721             0823*  ; save all registers to the stack
0B0721 F5          0824*      push af
0B0722 C5          0825*      push bc
0B0723 D5          0826*      push de
0B0724 E5          0827*      push hl
0B0725 DD E5       0828*      push ix
0B0727 FD E5       0829*      push iy
0B0729             0830*  
0B0729             0831*  ; set b to be our loop counter
0B0729 47          0832*      ld b,a
0B072A             0833*  @loop:
0B072A             0834*  ; print the byte
0B072A 7E          0835*      ld a,(hl)
0B072B E5          0836*      push hl
0B072C C5          0837*      push bc
0B072D CD 41 04 0B 0838*      call printBin8
0B0731 C1          0839*      pop bc
0B0732             0840*  ; print a space
0B0732 3E 20       0841*      ld a,' '
0B0734 5B D7       0842*      rst.lil 10h
0B0736 E1          0843*      pop hl
0B0737 23          0844*      inc hl
0B0738 10 F0       0845*      djnz @loop
0B073A CD 8C 02 0B 0846*      call printNewLine
0B073E             0847*  
0B073E             0848*  ; restore everything
0B073E FD E1       0849*      pop iy
0B0740 DD E1       0850*      pop ix
0B0742 E1          0851*      pop hl
0B0743 D1          0852*      pop de
0B0744 C1          0853*      pop bc
0B0745 F1          0854*      pop af
0B0746             0855*  ; all done
0B0746 C9          0856*      ret
0B0747             0857*  
0B0747             0858*  ; print bytes from an address to the screen in binary format
0B0747             0859*  ; with the bits of each byte in reverse order (lsb first)
0B0747             0860*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0747             0861*  ; outputs: values of each byte printed to screen separated by spaces
0B0747             0862*  ; destroys: nothing
0B0747             0863*  dumpMemoryBinRev:
0B0747             0864*  ; save all registers to the stack
0B0747 F5          0865*      push af
0B0748 C5          0866*      push bc
0B0749 D5          0867*      push de
0B074A E5          0868*      push hl
0B074B DD E5       0869*      push ix
0B074D FD E5       0870*      push iy
0B074F             0871*  
0B074F             0872*  ; set b to be our loop counter
0B074F 47          0873*      ld b,a
0B0750             0874*  @loop:
0B0750             0875*  ; print the byte
0B0750 7E          0876*      ld a,(hl)
0B0751 E5          0877*      push hl
0B0752 C5          0878*      push bc
0B0753 CD 66 04 0B 0879*      call printBin8Rev
0B0757 C1          0880*      pop bc
0B0758             0881*  ; print a space
0B0758 3E 20       0882*      ld a,' '
0B075A 5B D7       0883*      rst.lil 10h
0B075C E1          0884*      pop hl
0B075D 23          0885*      inc hl
0B075E 10 F0       0886*      djnz @loop
0B0760 CD 8C 02 0B 0887*      call printNewLine
0B0764             0888*  
0B0764             0889*  ; restore everything
0B0764 FD E1       0890*      pop iy
0B0766 DD E1       0891*      pop ix
0B0768 E1          0892*      pop hl
0B0769 D1          0893*      pop de
0B076A C1          0894*      pop bc
0B076B F1          0895*      pop af
0B076C             0896*  ; all done
0B076C C9          0897*      ret
0B076D             0020       include "files.inc"
0B076D             0001*  ; load to onboard 8k sram
0B076D             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B076D             0021       include "timer.inc"
0B076D             0001*  ; Table 32. Timer Control Registers
0B076D             0002*  ; this constant is the base address of the timer control registers
0B076D             0003*  ; each timer takes three bytes:
0B076D             0004*  ;   0: control register
0B076D             0005*  ;   1: low byte of timer reset value
0B076D             0006*  ;   2: high byte of timer reset value
0B076D             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B076D             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B076D             0009*  TMR_CTL:     equ 80h
0B076D             0010*  
0B076D             0011*  ; Timer Control Register Bit Definitions
0B076D             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B076D             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B076D             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B076D             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B076D             0016*                              ; the TMRx_CTL register is read.
0B076D             0017*  
0B076D             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B076D             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B076D             0020*  
0B076D             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B076D             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B076D             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B076D             0024*                              ; written to the counter when the end-of-count value is reached.
0B076D             0025*  
0B076D             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B076D             0027*  CLK_DIV_256:  equ %00001100 ;
0B076D             0028*  CLK_DIV_64:   equ %00001000 ;
0B076D             0029*  CLK_DIV_16:   equ %00000100 ;
0B076D             0030*  CLK_DIV_4:    equ %00000000 ;
0B076D             0031*  
0B076D             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B076D             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B076D             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B076D             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B076D             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B076D             0037*                              ; SINGLE-PASS mode is used.
0B076D             0038*  
0B076D             0039*  ; disable/enable the programmable reload timer
0B076D             0040*  PRT_EN_0:     equ %00000000 ;
0B076D             0041*  PRT_EN_1:     equ %00000001 ;
0B076D             0042*  
0B076D             0043*  ; Table 37. Timer Input Source Select Register
0B076D             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B076D             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B076D             0046*  ;   00: System clock / CLK_DIV
0B076D             0047*  ;   01: RTC / CLK_DIV
0B076D             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B076D             0049*  ;   10: GPIO port B pin 1.
0B076D             0050*  ;   11: GPIO port B pin 1.
0B076D             0051*  TMR_ISS:   equ 92h ; register address
0B076D             0052*  
0B076D             0053*  ; Table 51. Real-Time Clock Control Register
0B076D             0054*  RTC_CTRL: equ EDh ; register address
0B076D             0055*  
0B076D             0056*  ; alarm interrupt disable/enable
0B076D             0057*  RTC_ALARM_0:    equ %00000000
0B076D             0058*  RTC_ALARM_1:    equ %10000000
0B076D             0059*  
0B076D             0060*  ; interrupt on alarm disable/enable
0B076D             0061*  RTC_INT_ENT_0:  equ %00000000
0B076D             0062*  RTC_INT_ENT_1:  equ %01000000
0B076D             0063*  
0B076D             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B076D             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B076D             0066*  
0B076D             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B076D             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B076D             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B076D             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B076D             0071*  
0B076D             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B076D             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B076D             0074*  
0B076D             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B076D             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B076D             0077*  
0B076D             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B076D             0079*                                  ; RTC counter is enabled.
0B076D             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B076D             0081*                                  ; RTC counter is disabled.
0B076D             0082*  
0B076D             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B076D             0084*  
0B076D             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B076D             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B076D 00 00 00    0087*  prt_reload: dl 0x000000
0B0770             0088*  
0B0770             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B0770             0090*  ; ;          de = number PRT interrupts during test interval
0B0770             0091*  ; prt_calibrate:
0B0770             0092*  ;     call vdu_vblank
0B0770             0093*  ; ; set a MOS timer
0B0770             0094*  ;     ld hl,120*1 ; 1 second
0B0770             0095*  ;     ld iy,tmr_test
0B0770             0096*  ;     call tmr_set
0B0770             0097*  ; ; set a PRT timer
0B0770             0098*  ;     ; ld hl,prt_reload_hardware
0B0770             0099*  ;     ; ld hl,prt_reload_emulator
0B0770             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B0770             0101*  ;     ld (prt_reload),hl
0B0770             0102*  ;     call prt_set
0B0770             0103*  ; @loop:
0B0770             0104*  ; ; check time remaining on MOS timer
0B0770             0105*  ;     call tmr_get
0B0770             0106*  ;     jp z,@done ; time expired,so quit
0B0770             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B0770             0108*  ;     jr @loop
0B0770             0109*  ; @done:
0B0770             0110*  ;     ld de,(prt_irq_counter)
0B0770             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B0770             0112*  ;     ld (prt_reload),bc
0B0770             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B0770             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B0770             0115*  ;     ld (is_emulator),a
0B0770             0116*  ;     sbc hl,de
0B0770             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B0770             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B0770             0119*  ;     ret m ; negative result means we're on hardware
0B0770             0120*  ;     inc a ; we're on emulator
0B0770             0121*  ;     ld (is_emulator),a
0B0770             0122*  ;     ld bc,prt_reload_emulator
0B0770             0123*  ;     ld (prt_reload),bc
0B0770             0124*  ;     ld hl,on_emulator
0B0770             0125*  ;     ret
0B0770             0126*  
0B0770             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B0770             0128*  
0B0770             0129*  ; set PRT timer
0B0770             0130*  prt_set:
0B0770 21 00 00 00 0131*      ld hl,0
0B0774 22 BE 07 0B 0132*      ld (prt_irq_counter),hl
0B0778 2A 6D 07 0B 0133*      ld hl,(prt_reload)
0B077C ED 29 84    0134*      out0 ($84),l
0B077F ED 21 85    0135*  	out0 ($85),h
0B0782             0136*  ; disable timer
0B0782 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B0784 ED 39 83    0138*  	out0 ($83),a
0B0787             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B0787 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B0789 ED 39 83    0141*  	out0 ($83),a
0B078C C9          0142*      ret
0B078D             0143*  
0B078D             0144*  ; ===============================================
0B078D             0145*  ; PRT Timer Interrupt Handling
0B078D             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B078D             0147*  ; -----------------------------------------------
0B078D             0148*  prt_irq_init:
0B078D             0149*      ; set up interrupt vector table 2
0B078D 21 00 00 00 0150*  	ld hl,0
0B0791 3A 0C 01 00 0151*  	ld a,($10c)
0B0795 6F          0152*  	ld l,a
0B0796 3A 0D 01 00 0153*  	ld a,($10d)
0B079A 67          0154*  	ld h,a
0B079B             0155*  
0B079B             0156*  	; skip over CALL ($c3)
0B079B 23          0157*  	inc hl
0B079C             0158*  	; load address of jump into vector table 2 (in ram)
0B079C ED 27       0159*  	ld hl,(hl)
0B079E             0160*  
0B079E             0161*  	; write CALL prt_irq_handler to vector table 2
0B079E 3E C3       0162*  	ld a,$c3
0B07A0 77          0163*  	ld (hl),a
0B07A1 23          0164*  	inc hl
0B07A2 11 A9 07 0B 0165*  	ld de,prt_irq_handler
0B07A6 ED 1F       0166*  	ld (hl),de
0B07A8             0167*  
0B07A8 C9          0168*      ret
0B07A9             0169*  
0B07A9             0170*  prt_irq_handler:
0B07A9 F3          0171*  	di
0B07AA F5          0172*  	push af
0B07AB E5          0173*      push hl
0B07AC ED 38 83    0174*  	in0 a,($83)
0B07AF 2A BE 07 0B 0175*  	ld hl,(prt_irq_counter)
0B07B3 23          0176*  	inc hl
0B07B4 22 BE 07 0B 0177*  	ld (prt_irq_counter),hl
0B07B8 E1          0178*      pop hl
0B07B9 F1          0179*  	pop af
0B07BA FB          0180*  	ei
0B07BB 5B ED 4D    0181*  	reti.l
0B07BE             0182*  
0B07BE             0183*  prt_irq_counter:
0B07BE 00 00 00    0184*  	.dl 0
0B07C1             0185*  prt_irq_counter_saved:
0B07C1 00 00 00    0186*      .dl 0
0B07C4             0187*  
0B07C4             0188*  prt_loop_reset:
0B07C4 E5          0189*      push hl
0B07C5 21 00 00 00 0190*  	ld hl,0
0B07C9 22 BE 07 0B 0191*  	ld (prt_irq_counter),hl
0B07CD 22 2F 08 0B 0192*      ld (prt_loop_counter),hl
0B07D1 22 32 08 0B 0193*      ld (prt_loops),hl
0B07D5 CD 70 07 0B 0194*      call prt_set
0B07D9 E1          0195*      pop hl
0B07DA C9          0196*      ret
0B07DB             0197*  
0B07DB             0198*  prt_loop_start:
0B07DB E5          0199*      push hl
0B07DC 21 00 00 00 0200*  	ld hl,0
0B07E0 22 BE 07 0B 0201*  	ld (prt_irq_counter),hl
0B07E4 E1          0202*      pop hl
0B07E5 C9          0203*      ret
0B07E6             0204*  
0B07E6             0205*  prt_loop_stop:
0B07E6 E5          0206*      push hl
0B07E7 D5          0207*      push de
0B07E8 2A BE 07 0B 0208*      ld hl,(prt_irq_counter)
0B07EC ED 5B 2F 08 0209*      ld de,(prt_loop_counter)
       0B          
0B07F1 19          0210*      add hl,de
0B07F2 22 2F 08 0B 0211*      ld (prt_loop_counter),hl
0B07F6 21 00 00 00 0212*      ld hl,0
0B07FA 22 BE 07 0B 0213*      ld (prt_irq_counter),hl
0B07FE 2A 32 08 0B 0214*      ld hl,(prt_loops)
0B0802 23          0215*      inc hl
0B0803 22 32 08 0B 0216*      ld (prt_loops),hl
0B0807 D1          0217*      pop de
0B0808 E1          0218*      pop hl
0B0809 C9          0219*      ret
0B080A             0220*  
0B080A             0221*  ; inputs: bc = y,x text coordinates to print
0B080A             0222*  prt_loop_print:
0B080A F5          0223*      push af
0B080B E5          0224*      push hl
0B080C C5          0225*      push bc
0B080D D5          0226*      push de
0B080E DD E5       0227*      push ix
0B0810 FD E5       0228*      push iy
0B0812 CD 27 09 0B 0229*      call vdu_move_cursor
0B0816             0230*  
0B0816 2A 2F 08 0B 0231*      ld hl,(prt_loop_counter)
0B081A CD 2F 03 0B 0232*      call printDec
0B081E             0233*  
0B081E 2A 32 08 0B 0234*      ld hl,(prt_loops)
0B0822 CD 2F 03 0B 0235*      call printDec
0B0826             0236*  
0B0826 FD E1       0237*      pop iy
0B0828 DD E1       0238*      pop ix
0B082A D1          0239*      pop de
0B082B C1          0240*      pop bc
0B082C E1          0241*      pop hl
0B082D F1          0242*      pop af
0B082E C9          0243*      ret
0B082F             0244*  
0B082F             0245*  prt_loop_counter:
0B082F 00 00 00    0246*      .dl 0
0B0832             0247*  prt_loops:
0B0832 00 00 00    0248*      .dl 0
0B0835             0249*  
0B0835             0250*  ; ===============================================
0B0835             0251*  ; Timer functions
0B0835             0252*  ; -----------------------------------------------
0B0835             0253*  ; set a countdown timer
0B0835             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0835             0255*  ; returns: hl = current time
0B0835             0256*  tmr_set:
0B0835 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B0838             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0838 3E 08       0001*M 			LD	A, function
0B083A 5B CF       0002*M 			RST.L	08h
0B083C DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B083F FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B0842 C9          0261*      ret
0B0843             0262*  
0B0843             0263*  ; gets time remaining on a countdown timer
0B0843             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0843             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0843             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0843             0267*  tmr_get:
0B0843             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0843 3E 08       0001*M 			LD	A, function
0B0845 5B CF       0002*M 			RST.L	08h
0B0847 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B084A FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B084D AF          0271*      xor a                   ; clear carry
0B084E ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0850 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B0853 AF          0274*      xor a                   ; clear carry
0B0854 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B0856             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0856 C9          0277*      ret
0B0857             0278*  
0B0857 00 00 00    0279*  timestamp_now: dl 0
0B085A 00 00 00    0280*  timestamp_old: dl 0
0B085D 00 00 00    0281*  timestamp_chg: dl 0
0B0860             0282*  
0B0860             0283*  ; update the global timestamp from the system clock
0B0860             0284*  ; inputs: none
0B0860             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B0860             0286*  ;          de = current time
0B0860             0287*  ;          ix = pointer to syvars table
0B0860             0288*  ; destroys: af,hl,de,ix
0B0860             0289*  timestamp_tick:
0B0860 ED 5B 57 08 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B0865 ED 53 5A 08 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B086A             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B086A 3E 08       0001*M 			LD	A, function
0B086C 5B CF       0002*M 			RST.L	08h
0B086E DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B0871 22 57 08 0B 0294*      ld (timestamp_now),hl   ; save current time
0B0875 AF          0295*      xor a                   ; clear carry
0B0876 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B0878 22 5D 08 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B087C C9          0298*      ret
0B087D             0299*  
0B087D             0300*  ; set a countdown timer
0B087D             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B087D             0302*  ; requires: timestamp_tick to be called at least once before this function
0B087D             0303*  ; returns: hl = current time
0B087D             0304*  ; destroys: hl
0B087D             0305*  timestamp_tmr_set:
0B087D FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B0880 2A 57 08 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B0884 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B0887 C9          0309*      ret
0B0888             0310*  
0B0888             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B0888             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0888             0313*  ; requires: timestamp_tick to be called at least once before this function
0B0888             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0888             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0888             0316*  ; destroys: af,hl,de
0B0888             0317*  timestamp_tmr_get:
0B0888 ED 5B 57 08 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B088D FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B0890 AF          0320*      xor a                   ; clear carry
0B0891 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0893 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B0896 AF          0323*      xor a                   ; clear carry
0B0897 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B0899             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0899 C9          0326*      ret
0B089A             0327*  
0B089A             0328*  ; main loop timer functions
0B089A             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B08A0             0330*  
0B08A0             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B08A0             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B08A0             0333*  ; returns: hl = current time
0B08A0             0334*  ; destroys: af,hl,de,ix,iy
0B08A0             0335*  tmr_main_loop_set:
0B08A0 FD 21 9A 08 0336*      ld iy,tmr_main_loop
       0B          
0B08A5 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B08A8 CD 60 08 0B 0338*      call timestamp_tick
0B08AC 2A 57 08 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B08B0 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B08B3 C9          0341*      ret
0B08B4             0342*  
0B08B4             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B08B4             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B08B4             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B08B4             0346*  ; destroys: af,hl,de,ix,iy
0B08B4             0347*  tmr_main_loop_get:
0B08B4 CD 60 08 0B 0348*      call timestamp_tick
0B08B8 FD 21 9A 08 0349*      ld iy,tmr_main_loop
       0B          
0B08BD CD 88 08 0B 0350*      call timestamp_tmr_get
0B08C1 C9          0351*      ret
0B08C2             0352*  
0B08C2             0353*  ; set a stopwatch
0B08C2             0354*  ; returns: hl = start time
0B08C2             0355*  ; destroys: hl,ix
0B08C2             0356*  stopwatch_set:
0B08C2             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B08C2 3E 08       0001*M 			LD	A, function
0B08C4 5B CF       0002*M 			RST.L	08h
0B08C6 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B08C9 22 DE 08 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B08CD C9          0360*      ret
0B08CE             0361*  
0B08CE             0362*  ; gets time elapsed on a stopwatch
0B08CE             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B08CE             0364*  ; destroys: af,hl,de,ix
0B08CE             0365*  stopwatch_get:
0B08CE             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B08CE 3E 08       0001*M 			LD	A, function
0B08D0 5B CF       0002*M 			RST.L	08h
0B08D2 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B08D5 ED 5B DE 08 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B08DA AF          0369*      xor a                   ; clear carry
0B08DB ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B08DD C9          0371*      ret
0B08DE             0372*  
0B08DE             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B08E1             0374*  
0B08E1             0375*  ; ------------------
0B08E1             0376*  ; delay routine
0B08E1             0377*  ; Author: Richard Turrnidge
0B08E1             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B08E1             0379*  ; routine waits a fixed time,then returns
0B08E1             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B08E1             0381*  ; eg. ld A,00000100b
0B08E1             0382*  
0B08E1             0383*  multiPurposeDelay:
0B08E1 F5          0384*      push af
0B08E2 C5          0385*      push bc
0B08E3 DD E5       0386*      push ix
0B08E5 47          0387*      ld b,a
0B08E6 3E 08       0388*      ld a,$08
0B08E8 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B08EA             0390*  
0B08EA             0391*  waitLoop:
0B08EA             0392*  
0B08EA DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B08ED             0394*  
0B08ED             0395*                                  ;   we check if bit set is same as last time we checked.
0B08ED             0396*                                  ;   bit 0 - don't use
0B08ED             0397*                                  ;   bit 1 - changes 64 times per second
0B08ED             0398*                                  ;   bit 2 - changes 32 times per second
0B08ED             0399*                                  ;   bit 3 - changes 16 times per second
0B08ED             0400*  
0B08ED             0401*                                  ;   bit 4 - changes 8 times per second
0B08ED             0402*                                  ;   bit 5 - changes 4 times per second
0B08ED             0403*                                  ;   bit 6 - changes 2 times per second
0B08ED             0404*                                  ;   bit 7 - changes 1 times per second
0B08ED A0          0405*      and b
0B08EE 4F          0406*      ld c,a
0B08EF 3A 00 09 0B 0407*      ld a,(oldTimeStamp)
0B08F3 B9          0408*      cp c                        ; is A same as last value?
0B08F4 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B08F6 79          0410*      ld a,c
0B08F7 32 00 09 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B08FB             0412*  
0B08FB DD E1       0413*      pop ix
0B08FD C1          0414*      pop bc
0B08FE F1          0415*      pop af
0B08FF C9          0416*      ret
0B0900             0417*  
0B0900 00          0418*  oldTimeStamp:   .db 00h
0B0901             0022       include "vdu.inc"
0B0901             0001*  
0B0901             0002*  ; VDU 30: Home cursor
0B0901             0003*  vdu_home_cursor:
0B0901 3E 1E       0004*      ld a,30
0B0903 5B D7       0005*  	rst.lil $10
0B0905 C9          0006*  	ret
0B0906             0007*  
0B0906             0008*  cursor_on:
0B0906 21 11 09 0B 0009*  	ld hl,@cmd
0B090A 01 03 00 00 0010*  	ld bc,@end-@cmd
0B090E 5B DF       0011*  	rst.lil $18
0B0910 C9          0012*  	ret
0B0911             0013*  @cmd:
0B0911 17 01 01    0014*  	db 23,1,1
0B0914             0015*  @end:
0B0914             0016*  
0B0914             0017*  cursor_off:
0B0914 21 1F 09 0B 0018*  	ld hl,@cmd
0B0918 01 03 00 00 0019*  	ld bc,@end-@cmd
0B091C 5B DF       0020*  	rst.lil $18
0B091E C9          0021*  	ret
0B091F             0022*  @cmd:
0B091F 17 01 00    0023*  	db 23,1,0
0B0922             0024*  @end:
0B0922             0025*  
0B0922             0026*  ; VDU 9: Move cursor forward one character
0B0922             0027*  vdu_cursor_forward:
0B0922 3E 09       0028*      ld a,9
0B0924 5B D7       0029*  	rst.lil $10
0B0926 C9          0030*  	ret
0B0927             0031*  
0B0927             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B0927             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B0927             0034*  vdu_move_cursor:
0B0927 ED 43 38 09 0035*      ld (@x0),bc
       0B          
0B092C 21 37 09 0B 0036*  	ld hl,@cmd
0B0930 01 03 00 00 0037*  	ld bc,@end-@cmd
0B0934 5B DF       0038*  	rst.lil $18
0B0936 C9          0039*  	ret
0B0937 1F          0040*  @cmd: 	db 31
0B0938 00          0041*  @x0:	db 0
0B0939 00          0042*  @y0: 	db 0
0B093A 00          0043*  @end: 	db 0 ; padding
0B093B             0044*  
0B093B             0045*  ; VDU 12: Clear text area (CLS)
0B093B             0046*  vdu_cls:
0B093B 3E 0C       0047*      ld a,12
0B093D 5B D7       0048*  	rst.lil $10
0B093F C9          0049*  	ret
0B0940             0050*  
0B0940             0051*  vdu_flip:
0B0940 21 4B 09 0B 0052*  	ld hl,@cmd
0B0944 01 03 00 00 0053*  	ld bc,@end-@cmd
0B0948 5B DF       0054*  	rst.lil $18
0B094A C9          0055*  	ret
0B094B 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B094E             0057*  @end:
0B094E             0058*  
0B094E             0059*  ; VDU 16: Clear graphics area (CLG)
0B094E             0060*  vdu_clg:
0B094E 3E 10       0061*      ld a,16
0B0950 5B D7       0062*  	rst.lil $10
0B0952 C9          0063*  	ret
0B0953             0064*  
0B0953             0065*  ; COLOUR MODES
0B0953             0066*  ; Mode	Effect
0B0953             0067*  ; 0	Set on-screen pixel to target colour value
0B0953             0068*  ; 1	OR value with the on-screen pixel
0B0953             0069*  ; 2	AND value with the on-screen pixel
0B0953             0070*  ; 3	XOR value with the on-screen pixel
0B0953             0071*  ; 4	Invert the on-screen pixel
0B0953             0072*  ; 5	No operation
0B0953             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B0953             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B0953             0075*  
0B0953             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B0953             0077*  vdu_colour_text:
0B0953 32 63 09 0B 0078*  	ld (@arg),a
0B0957 21 62 09 0B 0079*  	ld hl,@cmd
0B095B 01 02 00 00 0080*  	ld bc,@end-@cmd
0B095F 5B DF       0081*  	rst.lil $18
0B0961 C9          0082*  	ret
0B0962 11          0083*  @cmd: db 17
0B0963 00          0084*  @arg: db 0
0B0964             0085*  @end:
0B0964             0086*  
0B0964             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B0964             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B0964             0089*  vdu_gcol:
0B0964 32 79 09 0B 0090*  	ld (@mode),a
0B0968 79          0091*      ld a,c
0B0969 32 7A 09 0B 0092*      ld (@col),a
0B096D 21 78 09 0B 0093*  	ld hl,@cmd
0B0971 01 03 00 00 0094*  	ld bc,@end-@cmd
0B0975 5B DF       0095*  	rst.lil $18
0B0977 C9          0096*  	ret
0B0978 12          0097*  @cmd:  db 18
0B0979 00          0098*  @mode: db 0
0B097A 00          0099*  @col:  db 0
0B097B             0100*  @end:
0B097B             0101*  
0B097B             0102*  
0B097B             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B097B             0104*  ; MIND THE LITTLE-ENDIANESS
0B097B             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B097B             0106*  ; outputs; nothing
0B097B             0107*  ; destroys: a might make it out alive
0B097B             0108*  vdu_set_txt_viewport:
0B097B ED 43 91 09 0109*      ld (@lb),bc
       0B          
0B0980 ED 53 93 09 0110*  	ld (@rt),de
       0B          
0B0985 21 90 09 0B 0111*  	ld hl,@cmd
0B0989 01 05 00 00 0112*  	ld bc,@end-@cmd
0B098D 5B DF       0113*  	rst.lil $18
0B098F C9          0114*  	ret
0B0990 1C          0115*  @cmd:   db 28 ; set text viewport command
0B0991 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B0993 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B0995 00          0118*  @end:   db 0x00	  ; padding
0B0996             0119*  
0B0996             0120*  ; Wait for VBLANK interrupt
0B0996             0121*  vdu_vblank:
0B0996 DD E5       0122*      PUSH 	IX
0B0998             0123*  	MOSCALL	mos_sysvars
0B0998 3E 08       0001*M 			LD	A, function
0B099A 5B CF       0002*M 			RST.L	08h
0B099C DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B099F             0125*  @wait:
0B099F DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B09A2 28 FB       0127*      JR	Z, @wait
0B09A4 DD E1       0128*      POP	IX
0B09A6 C9          0129*      RET
0B09A7             0130*  
0B09A7             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B09A7             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B09A7             0133*  ; 	because we have turned off logical screen scaling
0B09A7             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B09A7             0135*  ; outputs; nothing
0B09A7             0136*  ; destroys: a might make it out alive
0B09A7             0137*  vdu_set_gfx_viewport:
0B09A7 ED 43 C7 09 0138*      ld (@x0),bc
       0B          
0B09AC FD 22 C9 09 0139*      ld (@y1),iy
       0B          
0B09B1 DD 22 CB 09 0140*  	ld (@x1),ix
       0B          
0B09B6 ED 53 CD 09 0141*  	ld (@y0),de
       0B          
0B09BB 21 C6 09 0B 0142*  	ld hl,@cmd
0B09BF 01 09 00 00 0143*  	ld bc,@end-@cmd
0B09C3 5B DF       0144*  	rst.lil $18
0B09C5 C9          0145*  	ret
0B09C6 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B09C7 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B09C9 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B09CB 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B09CD 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B09CF 00          0151*  @end:   db 0x00	  ; padding
0B09D0             0152*  
0B09D0             0153*  ; SCREEN MODES
0B09D0             0154*  ; ===============================
0B09D0             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B09D0             0156*  ; ---   ----  ----  ----  -------
0B09D0             0157*  ; 11    320   240   2     60hz
0B09D0             0158*  ; 139   320   240   2     60hz
0B09D0             0159*  ; 23    512   384   2     60hz
0B09D0             0160*  ; 151   512   384   2     60hz
0B09D0             0161*  ; 6     640   240   2     60hz
0B09D0             0162*  ; 134   640   240   2     60hz
0B09D0             0163*  ; 2     640   480   2     60hz
0B09D0             0164*  ; 130   640   480   2     60hz
0B09D0             0165*  ; 17    800   600   2     60hz
0B09D0             0166*  ; 145   800   600   2     60hz
0B09D0             0167*  ; 18    1024  768   2     60hz
0B09D0             0168*  ; 146   1024  768   2     60hz
0B09D0             0169*  ; ---   ----  ----  ----  -------
0B09D0             0170*  ; 10    320   240   4     60hz
0B09D0             0171*  ; 138   320   240   4     60hz
0B09D0             0172*  ; 22    512   384   4     60hz
0B09D0             0173*  ; 150   512   384   4     60hz
0B09D0             0174*  ; 5     640   240   4     60hz
0B09D0             0175*  ; 133   640   240   4     60hz
0B09D0             0176*  ; 1     640   480   4     60hz
0B09D0             0177*  ; 129   640   480   4     60hz
0B09D0             0178*  ; 16    800   600   4     60hz
0B09D0             0179*  ; 19    1024  768   4     60hz
0B09D0             0180*  ; ---   ----  ----  ----  -------
0B09D0             0181*  ; 9     320   240   16    60hz
0B09D0             0182*  ; 137   320   240   16    60hz
0B09D0             0183*  ; 21    512   384   16    60hz
0B09D0             0184*  ; 149   512   384   16    60hz
0B09D0             0185*  ; 4     640   240   16    60hz
0B09D0             0186*  ; 132   640   240   16    60hz
0B09D0             0187*  ; 0     640   480   16    60hz
0B09D0             0188*  ; 7     n/a   n/a   16    60hz
0B09D0             0189*  ; ---   ----  ----  ----  -------
0B09D0             0190*  ; 8     320   240   64    60hz
0B09D0             0191*  ; 136   320   240   64    60hz
0B09D0             0192*  ; 20    512   384   64    60hz
0B09D0             0193*  ; 3     640   240   64    60hz
0B09D0             0194*  ; ---   ----  ----  ----  -------
0B09D0             0195*  vdu_set_screen_mode:
0B09D0 32 E0 09 0B 0196*  	ld (@arg),a
0B09D4 21 DF 09 0B 0197*  	ld hl,@cmd
0B09D8 01 02 00 00 0198*  	ld bc,@end-@cmd
0B09DC 5B DF       0199*  	rst.lil $18
0B09DE C9          0200*  	ret
0B09DF 16          0201*  @cmd: db 22 ; set screen mode
0B09E0 00          0202*  @arg: db 0  ; screen mode parameter
0B09E1             0203*  @end:
0B09E1             0204*  
0B09E1             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B09E1             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B09E1             0207*  ; note: default setting on boot is scaling ON
0B09E1             0208*  vdu_set_scaling:
0B09E1 32 F3 09 0B 0209*  	ld (@arg),a
0B09E5 21 F0 09 0B 0210*  	ld hl,@cmd
0B09E9 01 04 00 00 0211*  	ld bc,@end-@cmd
0B09ED 5B DF       0212*  	rst.lil $18
0B09EF C9          0213*  	ret
0B09F0 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B09F3 00          0215*  @arg: db 0  ; scaling on/off
0B09F4             0216*  @end:
0B09F4             0217*  
0B09F4             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B09F4             0219*  ; inputs: hl=bufferId
0B09F4             0220*  vdu_buff_select:
0B09F4 22 06 0A 0B 0221*  	ld (@bufferId),hl
0B09F8 21 03 0A 0B 0222*  	ld hl,@cmd
0B09FC 01 05 00 00 0223*  	ld bc,@end-@cmd
0B0A00 5B DF       0224*  	rst.lil $18
0B0A02 C9          0225*  	ret
0B0A03 17 1B 20    0226*  @cmd: db 23,27,0x20
0B0A06 00 00       0227*  @bufferId: dw 0x0000
0B0A08 00          0228*  @end: db 0x00 ; padding
0B0A09             0229*  
0B0A09             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B0A09             0231*  ; inputs: a=format; bc=width; de=height
0B0A09             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B0A09             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B0A09             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B0A09             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B0A09             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B0A09             0237*  ; 3 	Reserved for internal use by VDP (native format)
0B0A09             0238*  vdu_bmp_create:
0B0A09 ED 43 25 0A 0239*      ld (@width),bc
       0B          
0B0A0E ED 53 27 0A 0240*      ld (@height),de
       0B          
0B0A13 32 29 0A 0B 0241*      ld (@fmt),a
0B0A17 21 22 0A 0B 0242*  	ld hl,@cmd
0B0A1B 01 08 00 00 0243*  	ld bc,@end-@cmd
0B0A1F 5B DF       0244*  	rst.lil $18
0B0A21 C9          0245*  	ret
0B0A22 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B0A25 00 00       0247*  @width:     dw 0x0000
0B0A27 00 00       0248*  @height:    dw 0x0000
0B0A29 00          0249*  @fmt:       db 0x00
0B0A2A             0250*  @end:
0B0A2A             0251*  
0B0A2A             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B0A2A             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B0A2A             0254*  vdu_load_img_rgba2_to_8:
0B0A2A             0255*  ; backup the target buffer id and image dimensions
0B0A2A E5          0256*      push hl
0B0A2B D5          0257*      push de
0B0A2C C5          0258*      push bc
0B0A2D             0259*  ; load the rgba2 image to working buffer 65534
0B0A2D 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B0A31 CD 34 0B 0B 0261*  	call vdu_load_buffer_from_file
0B0A35             0262*  ; restore the image dimensions and target buffer id
0B0A35 C1          0263*      pop bc
0B0A36 D1          0264*      pop de
0B0A37 E1          0265*      pop hl
0B0A38             0266*  ; fall through to vdu_rgba2_to_8
0B0A38             0267*  
0B0A38             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B0A38             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B0A38             0270*  ; the "expand bitmap" command is:
0B0A38             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0A38             0272*  ; and then to reverse the byte order to fix endian-ness:
0B0A38             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0A38             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0A38             0275*  ; VDU 23,27,&20,targetBufferID%;
0B0A38             0276*  ; VDU 23,27,&21,width%;height%;0
0B0A38             0277*  ; -------------------------------------------------------------------
0B0A38             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B0A38             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B0A38             0280*  vdu_rgba2_to_8:
0B0A38             0281*  ; load the image dimensions and buffer id parameters
0B0A38 ED 43 94 0A 0282*      ld (@width),bc
       0B          
0B0A3D ED 53 96 0A 0283*      ld (@height),de
       0B          
0B0A42 22 79 0A 0B 0284*      ld (@bufferId0),hl
0B0A46 22 86 0A 0B 0285*      ld (@bufferId2),hl
0B0A4A 22 8F 0A 0B 0286*      ld (@bufferId1),hl
0B0A4E             0287*  ; clean up bytes that got stomped on by the ID loads
0B0A4E 3E 48       0288*      ld a,0x48
0B0A50 32 7B 0A 0B 0289*      ld (@bufferId0+2),a
0B0A54 3E 17       0290*      ld a,23
0B0A56 32 91 0A 0B 0291*      ld (@bufferId1+2),a
0B0A5A 3E 18       0292*      ld a,24
0B0A5C 32 88 0A 0B 0293*      ld (@bufferId2+2),a
0B0A60 AF          0294*      xor a
0B0A61 32 98 0A 0B 0295*      ld (@height+2),a
0B0A65             0296*  ; send the vdu command strings
0B0A65 21 70 0A 0B 0297*      ld hl,@beg
0B0A69 01 29 00 00 0298*      ld bc,@end-@beg
0B0A6D 5B DF       0299*      rst.lil $18
0B0A6F C9          0300*      ret
0B0A70             0301*  @beg:
0B0A70             0302*  ; Command 14: Consolidate blocks in a buffer
0B0A70             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B0A70 17 00 A0    0304*      db 23,0,0xA0
0B0A73 FE FF       0305*      dw 65534 ; workingBufferId
0B0A75 0E          0306*      db 14 ; consolidate blocks
0B0A76             0307*  ; the "expand bitmap" command is:
0B0A76             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0A76 17 00 A0    0309*      db 23,0,0xA0
0B0A79 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B0A7B 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B0A7C 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B0A7D FE FF       0313*      dw 65534 ; sourceBufferId
0B0A7F 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B0A83             0315*  ; reverse the byte order to fix endian-ness:
0B0A83             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B0A83             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B0A83             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0A83 17 00 A0    0319*      db 23,0,0xA0
0B0A86 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B0A88 18          0321*      db 24 ; reverse byte order
0B0A89 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B0A8A 04 00       0323*      dw 4 ; size (4 bytes)
0B0A8C             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0A8C             0325*  ; VDU 23,27,&20,targetBufferID%;
0B0A8C 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B0A8F 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B0A91             0328*  ; VDU 23,27,&21,width%;height%;0
0B0A91 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B0A94 00 00       0330*  @width: dw 0x0000
0B0A96 00 00       0331*  @height: dw 0x0000
0B0A98 00          0332*      db 0x00 ; rgba8888 format
0B0A99             0333*  @end:
0B0A99             0334*  
0B0A99             0335*  ; scratch variables
0B0A99 00 00 00    0336*  bufferId0: dl 0x000000
0B0A9C 00 00 00    0337*  bufferId1: dl 0x000000
0B0A9F             0338*  
0B0A9F             0339*  ; load a vdu buffer from local memory
0B0A9F             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0A9F             0341*  vdu_load_buffer:
0B0A9F ED 43 C8 0A 0342*      ld (@length),bc
       0B          
0B0AA4 D5          0343*      push de ; save data pointer
0B0AA5             0344*  ; send the vdu command string
0B0AA5 7D          0345*      ld a,l
0B0AA6 32 C5 0A 0B 0346*      ld (@bufferId),a
0B0AAA 7C          0347*      ld a,h
0B0AAB 32 C6 0A 0B 0348*      ld (@bufferId+1),a
0B0AAF 21 C2 0A 0B 0349*      ld hl,@cmd
0B0AB3 01 08 00 00 0350*      ld bc,@end-@cmd
0B0AB7 5B DF       0351*      rst.lil $18
0B0AB9             0352*  ; send the buffer data
0B0AB9 E1          0353*      pop hl ; pointer to data
0B0ABA ED 4B C8 0A 0354*      ld bc,(@length)
       0B          
0B0ABF 5B DF       0355*      rst.lil $18 ; send it
0B0AC1 C9          0356*      ret
0B0AC2             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B0AC2 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B0AC5 00 00       0359*  @bufferId:	dw 0x0000
0B0AC7 00          0360*  		    db 0 ; load buffer
0B0AC8 00 00       0361*  @length:	dw 0x0000
0B0ACA 00          0362*  @end: db 0 ; padding
0B0ACB             0363*  
0B0ACB             0364*  ; clear a buffer
0B0ACB             0365*  ; inputs: hl = bufferId
0B0ACB             0366*  vdu_clear_buffer:
0B0ACB 7D          0367*      ld a,l
0B0ACC 32 E3 0A 0B 0368*      ld (@bufferId),a
0B0AD0 7C          0369*      ld a,h
0B0AD1 32 E4 0A 0B 0370*      ld (@bufferId+1),a
0B0AD5 21 E0 0A 0B 0371*      ld hl,@cmd
0B0AD9 01 06 00 00 0372*      ld bc,@end-@cmd
0B0ADD 5B DF       0373*      rst.lil $18
0B0ADF C9          0374*      ret
0B0AE0 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B0AE3 00 00       0376*  @bufferId:	dw 0x0000
0B0AE5 02          0377*  		    db 2 ; clear buffer
0B0AE6             0378*  @end:
0B0AE6             0379*  
0B0AE6             0380*  vdu_clear_all_buffers:
0B0AE6             0381*  ; clear all buffers
0B0AE6 21 F1 0A 0B 0382*      ld hl,@beg
0B0AEA 01 06 00 00 0383*      ld bc,@end-@beg
0B0AEE 5B DF       0384*      rst.lil $18
0B0AF0 C9          0385*      ret
0B0AF1 17 00 A0    0386*  @beg: db 23,0,$A0
0B0AF4 FF FF       0387*        dw -1 ; clear all buffers
0B0AF6 02          0388*        db 2  ; command 2: clear a buffer
0B0AF7             0389*  @end:
0B0AF7             0390*  
0B0AF7             0391*  ; Command 14: Consolidate blocks in a buffer
0B0AF7             0392*  vdu_consolidate_buffer:
0B0AF7             0393*  ; set parameters for vdu call
0B0AF7 7D          0394*      ld a,l
0B0AF8 32 0F 0B 0B 0395*      ld (@bufferId),a
0B0AFC 7C          0396*      ld a,h
0B0AFD 32 10 0B 0B 0397*      ld (@bufferId+1),a
0B0B01 21 0C 0B 0B 0398*      ld hl,@beg
0B0B05 01 06 00 00 0399*      ld bc,@end-@beg
0B0B09 5B DF       0400*      rst.lil $18
0B0B0B C9          0401*      ret
0B0B0C             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B0B0C 17 00 A0    0403*  @beg: db 23,0,0xA0
0B0B0F 00 00       0404*  @bufferId: dw 0x0000
0B0B11 0E          0405*             db 14
0B0B12             0406*  @end:
0B0B12             0407*  
0B0B12             0408*  ; load an image file to a buffer and make it a bitmap
0B0B12             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B0B12             0410*  vdu_load_img:
0B0B12             0411*  ; back up image type and dimension parameters
0B0B12 22 99 0A 0B 0412*      ld (bufferId0),hl
0B0B16 F5          0413*      push af
0B0B17 C5          0414*  	push bc
0B0B18 D5          0415*  	push de
0B0B19             0416*  ; load the image
0B0B19 CD 34 0B 0B 0417*  	call vdu_load_buffer_from_file
0B0B1D             0418*  ; now make it a bitmap
0B0B1D 2A 99 0A 0B 0419*      ld hl,(bufferId0)
0B0B21 CD F7 0A 0B 0420*      call vdu_consolidate_buffer
0B0B25 2A 99 0A 0B 0421*      ld hl,(bufferId0)
0B0B29 CD F4 09 0B 0422*      call vdu_buff_select
0B0B2D D1          0423*  	pop de ; image height
0B0B2E C1          0424*  	pop bc ; image width
0B0B2F F1          0425*  	pop af ; image type
0B0B30 C3 09 0A 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B0B34             0427*  
0B0B34             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B0B34             0429*  vdu_load_buffer_from_file:
0B0B34 22 99 0A 0B 0430*      ld (bufferId0),hl
0B0B38             0431*  
0B0B38             0432*  ; clear target buffer
0B0B38 CD CB 0A 0B 0433*      call vdu_clear_buffer
0B0B3C             0434*  
0B0B3C             0435*  ; open the file in read mode
0B0B3C             0436*  ; Open a file
0B0B3C             0437*  ; HLU: Filename
0B0B3C             0438*  ;   C: Mode
0B0B3C             0439*  ; Returns:
0B0B3C             0440*  ;   A: Filehandle, or 0 if couldn't open
0B0B3C FD E5       0441*  	push iy ; pointer to filename
0B0B3E E1          0442*  	pop hl
0B0B3F 0E 01       0443*  	ld c,fa_read
0B0B41             0444*      MOSCALL mos_fopen
0B0B41 3E 0A       0001*M 			LD	A, function
0B0B43 5B CF       0002*M 			RST.L	08h
0B0B45 32 80 0B 0B 0445*      ld (@filehandle),a
0B0B49             0446*  
0B0B49             0447*  @read_file:
0B0B49             0448*  ; Read a block of data from a file
0B0B49             0449*  ;   C: Filehandle
0B0B49             0450*  ; HLU: Pointer to where to write the data to
0B0B49             0451*  ; DEU: Number of bytes to read
0B0B49             0452*  ; Returns:
0B0B49             0453*  ; DEU: Number of bytes read
0B0B49 3A 80 0B 0B 0454*      ld a,(@filehandle)
0B0B4D 4F          0455*      ld c,a
0B0B4E 21 00 E0 B7 0456*      ld hl,filedata
0B0B52 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B0B56             0458*      MOSCALL mos_fread
0B0B56 3E 1A       0001*M 			LD	A, function
0B0B58 5B CF       0002*M 			RST.L	08h
0B0B5A             0459*  
0B0B5A             0460*  ; ; DEBUG: print chunk size
0B0B5A             0461*  ;     push de
0B0B5A             0462*  ;     pop hl
0B0B5A             0463*  ;     call printDec
0B0B5A             0464*  ;     call printNewLine
0B0B5A             0465*  
0B0B5A             0466*  ; test de for zero bytes read
0B0B5A 21 00 00 00 0467*      ld hl,0
0B0B5E AF          0468*      xor a ; clear carry
0B0B5F ED 52       0469*      sbc hl,de
0B0B61 CA 77 0B 0B 0470*      jp z,@close_file
0B0B65             0471*  
0B0B65             0472*  ; load a vdu buffer from local memory
0B0B65             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0B65 2A 99 0A 0B 0474*      ld hl,(bufferId0)
0B0B69 D5          0475*      push de ; chunksize
0B0B6A C1          0476*      pop bc
0B0B6B 11 00 E0 B7 0477*      ld de,filedata
0B0B6F CD 9F 0A 0B 0478*      call vdu_load_buffer
0B0B73             0479*  
0B0B73             0480*  ; ; print progress breadcrumbs
0B0B73             0481*  ;     ld a,'.'
0B0B73             0482*  ;     rst.lil 10h
0B0B73             0483*  
0B0B73             0484*  ; read the next block
0B0B73 C3 49 0B 0B 0485*      jp @read_file
0B0B77             0486*  
0B0B77             0487*  ; close the file
0B0B77             0488*  @close_file:
0B0B77 3A 80 0B 0B 0489*      ld a,(@filehandle)
0B0B7B             0490*      MOSCALL mos_fclose
0B0B7B 3E 0B       0001*M 			LD	A, function
0B0B7D 5B CF       0002*M 			RST.L	08h
0B0B7F C9          0491*      ret ; vdu_load_buffer_from_file
0B0B80             0492*  
0B0B80 00          0493*  @filehandle: db 0 ; file handle
0B0B81 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B0B84             0495*  
0B0B84 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B0B87             0497*  
0B0B87             0498*  ; File information structure (FILINFO)
0B0B87             0499*  @filinfo:
0B0B87 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B0B8B 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B0B8D 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B0B8F 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B0B90 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B0B9D 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C9D             0023       ; include "vdu_fonts.inc"
0B0C9D             0024       include "vdu_plot.inc"
0B0C9D             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0C9D             0002*  ; PLOT code 	(Decimal) 	Effect
0B0C9D             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B0C9D             0004*  plot_sl_both: equ 0x00
0B0C9D             0005*  
0B0C9D             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B0C9D             0007*  plot_sl_first: equ 0x08
0B0C9D             0008*  
0B0C9D             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B0C9D             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B0C9D             0011*  
0B0C9D             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B0C9D             0013*  plot_sl_last: equ 0x20
0B0C9D             0014*  
0B0C9D             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B0C9D             0016*  plot_sl_none: equ 0x28
0B0C9D             0017*  
0B0C9D             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B0C9D             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B0C9D             0020*  
0B0C9D             0021*  ; &40-&47 	64-71 	Point plot
0B0C9D             0022*  plot_pt: equ 0x40
0B0C9D             0023*  
0B0C9D             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B0C9D             0025*  plot_lf_lr_non_bg: equ 0x48
0B0C9D             0026*  
0B0C9D             0027*  ; &50-&57 	80-87 	Triangle fill
0B0C9D             0028*  plot_tf: equ 0x50
0B0C9D             0029*  
0B0C9D             0030*  ; &58-&5F 	88-95 	Line fill right to background 
0B0C9D             0031*  plot_lf_r_bg: equ 0x58
0B0C9D             0032*  
0B0C9D             0033*  ; &60-&67 	96-103 	Rectangle fill
0B0C9D             0034*  plot_rf: equ 0x60
0B0C9D             0035*  
0B0C9D             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B0C9D             0037*  plot_lf_lr_fg: equ 0x60
0B0C9D             0038*  
0B0C9D             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B0C9D             0040*  plot_pf: equ 0x70
0B0C9D             0041*  
0B0C9D             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B0C9D             0043*  plot_lf_r_non_fg: equ 0x78
0B0C9D             0044*  
0B0C9D             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B0C9D             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B0C9D             0047*  
0B0C9D             0048*  ; &90-&97 	144-151 	Circle outline
0B0C9D             0049*  plot_co: equ 0x90
0B0C9D             0050*  
0B0C9D             0051*  ; &98-&9F 	152-159 	Circle fill
0B0C9D             0052*  plot_cf: equ 0x98
0B0C9D             0053*  
0B0C9D             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B0C9D             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B0C9D             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B0C9D             0057*  
0B0C9D             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B0C9D             0059*  plot_rcm: equ 0xB8
0B0C9D             0060*  
0B0C9D             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B0C9D             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B0C9D             0063*  ; &D0-&D7 	208-215 	Not defined
0B0C9D             0064*  ; &D8-&DF 	216-223 	Not defined
0B0C9D             0065*  ; &E0-&E7 	224-231 	Not defined
0B0C9D             0066*  
0B0C9D             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0C9D             0068*  plot_bmp: equ 0xE8
0B0C9D             0069*  
0B0C9D             0070*  ; &F0-&F7 	240-247 	Not defined
0B0C9D             0071*  ; &F8-&FF 	248-255 	Not defined
0B0C9D             0072*  
0B0C9D             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B0C9D             0074*  ; Agon Console8 VDP 2.2.0
0B0C9D             0075*  
0B0C9D             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B0C9D             0077*  ; Plot code 	Effect
0B0C9D             0078*  ; 0 	Move relative
0B0C9D             0079*  mv_rel: equ 0
0B0C9D             0080*  
0B0C9D             0081*  ; 1 	Plot relative in current foreground colour
0B0C9D             0082*  dr_rel_fg: equ 1
0B0C9D             0083*  
0B0C9D             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B0C9D             0085*  ; 3 	Plot relative in current background colour
0B0C9D             0086*  dr_rel_bg: equ 3
0B0C9D             0087*  
0B0C9D             0088*  ; 4 	Move absolute
0B0C9D             0089*  mv_abs: equ 4
0B0C9D             0090*  
0B0C9D             0091*  ; 5 	Plot absolute in current foreground colour
0B0C9D             0092*  dr_abs_fg: equ 5
0B0C9D             0093*  
0B0C9D             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B0C9D             0095*  ; 7 	Plot absolute in current background colour
0B0C9D             0096*  dr_abs_bg: equ 7
0B0C9D             0097*  
0B0C9D             0098*  ; Codes 0-3 use the position data provided as part of the command
0B0C9D             0099*  ; as a relative position, adding the position given to the current
0B0C9D             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B0C9D             0101*  ; as part of the command as an absolute position, setting the current
0B0C9D             0102*  ; graphical cursor position to the position given.
0B0C9D             0103*  
0B0C9D             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B0C9D             0105*  ; current pixel colour. These operations cannot currently be supported
0B0C9D             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B0C9D             0107*  ; supported. Support for these codes may be added in a future version
0B0C9D             0108*  ; of the VDP firmware.
0B0C9D             0109*  
0B0C9D             0110*  ; 16 colour palette constants
0B0C9D             0111*  c_black: equ 0
0B0C9D             0112*  c_red_dk: equ 1
0B0C9D             0113*  c_green_dk: equ 2
0B0C9D             0114*  c_yellow_dk: equ 3
0B0C9D             0115*  c_blue_dk: equ 4
0B0C9D             0116*  c_magenta_dk: equ 5
0B0C9D             0117*  c_cyan_dk: equ 6
0B0C9D             0118*  c_grey: equ 7
0B0C9D             0119*  c_grey_dk: equ 8
0B0C9D             0120*  c_red: equ 9
0B0C9D             0121*  c_green: equ 10
0B0C9D             0122*  c_yellow: equ 11
0B0C9D             0123*  c_blue: equ 12
0B0C9D             0124*  c_magenta: equ 13
0B0C9D             0125*  c_cyan: equ 14
0B0C9D             0126*  c_white: equ 15
0B0C9D             0127*  
0B0C9D             0128*  ; VDU 25, mode, x; y;: PLOT command
0B0C9D             0129*  ; inputs: a=mode, bc=x0, de=y0
0B0C9D             0130*  vdu_plot:
0B0C9D 32 B7 0C 0B 0131*      ld (@mode),a
0B0CA1 ED 43 B8 0C 0132*      ld (@x0),bc
       0B          
0B0CA6 ED 53 BA 0C 0133*      ld (@y0),de
       0B          
0B0CAB 21 B6 0C 0B 0134*  	ld hl,@cmd
0B0CAF 01 06 00 00 0135*  	ld bc,@end-@cmd
0B0CB3 5B DF       0136*  	rst.lil $18
0B0CB5 C9          0137*  	ret
0B0CB6 19          0138*  @cmd:   db 25
0B0CB7 00          0139*  @mode:  db 0
0B0CB8 00 00       0140*  @x0: 	dw 0
0B0CBA 00 00       0141*  @y0: 	dw 0
0B0CBC 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B0CBD             0143*  
0B0CBD             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0CBD             0145*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0CBD             0146*  ; VDU 25, mode, x; y;: PLOT command
0B0CBD             0147*  ; inputs: bc=x0, de=y0
0B0CBD             0148*  ; prerequisites: vdu_buff_select
0B0CBD             0149*  vdu_plot_bmp:
0B0CBD ED 43 D4 0C 0150*      ld (@x0),bc
       0B          
0B0CC2 ED 53 D6 0C 0151*      ld (@y0),de
       0B          
0B0CC7 21 D2 0C 0B 0152*  	ld hl,@cmd
0B0CCB 01 06 00 00 0153*  	ld bc,@end-@cmd
0B0CCF 5B DF       0154*  	rst.lil $18
0B0CD1 C9          0155*  	ret
0B0CD2 19          0156*  @cmd:   db 25
0B0CD3 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0CD4 00 00       0158*  @x0: 	dw 0x0000
0B0CD6 00 00       0159*  @y0: 	dw 0x0000
0B0CD8 00          0160*  @end:   db 0x00 ; padding
0B0CD9             0161*  
0B0CD9             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0CD9             0163*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0CD9             0164*  ; VDU 25, mode, x; y;: PLOT command
0B0CD9             0165*  ; inputs: bc=x0, de=y0
0B0CD9             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B0CD9             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B0CD9             0168*  ;   the fractional portiion of the inputs are truncated
0B0CD9             0169*  ;   leaving only the 16-bit integer portion
0B0CD9             0170*  ; prerequisites: vdu_buff_select
0B0CD9             0171*  vdu_plot_bmp168:
0B0CD9             0172*  ; populate in the reverse of normal to keep the
0B0CD9             0173*  ; inputs from stomping on each other
0B0CD9 ED 53 F7 0C 0174*      ld (@y0-1),de
       0B          
0B0CDE ED 43 F5 0C 0175*      ld (@x0-1),bc
       0B          
0B0CE3 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B0CE5 32 F5 0C 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B0CE9 21 F4 0C 0B 0178*  	ld hl,@cmd
0B0CED 01 06 00 00 0179*  	ld bc,@end-@cmd
0B0CF1 5B DF       0180*  	rst.lil $18
0B0CF3 C9          0181*  	ret
0B0CF4 19          0182*  @cmd:   db 25
0B0CF5 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0CF6 00 00       0184*  @x0: 	dw 0x0000
0B0CF8 00 00       0185*  @y0: 	dw 0x0000
0B0CFA             0186*  @end:  ; no padding required b/c we shifted de right
0B0CFA             0187*  
0B0CFA             0188*  ; draw a filled rectangle
0B0CFA             0189*  vdu_plot_rf:
0B0CFA ED 43 21 0D 0190*      ld (@x0),bc
       0B          
0B0CFF ED 53 23 0D 0191*      ld (@y0),de
       0B          
0B0D04 DD 22 27 0D 0192*      ld (@x1),ix
       0B          
0B0D09 FD 22 29 0D 0193*      ld (@y1),iy
       0B          
0B0D0E 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B0D10 32 25 0D 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0D14 21 1F 0D 0B 0196*  	ld hl,@cmd0
0B0D18 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B0D1C 5B DF       0198*  	rst.lil $18
0B0D1E C9          0199*      ret
0B0D1F 19          0200*  @cmd0:  db 25 ; plot
0B0D20 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B0D21 00 00       0202*  @x0:    dw 0x0000
0B0D23 00 00       0203*  @y0:    dw 0x0000
0B0D25 19          0204*  @cmd1:  db 25 ; plot
0B0D26 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B0D27 00 00       0206*  @x1:    dw 0x0000
0B0D29 00 00       0207*  @y1:    dw 0x0000
0B0D2B 00          0208*  @end:   db 0x00 ; padding
0B0D2C             0209*  
0B0D2C             0210*  ; draw a filled circle
0B0D2C             0211*  vdu_plot_cf:
0B0D2C ED 43 53 0D 0212*      ld (@x0),bc
       0B          
0B0D31 ED 53 55 0D 0213*      ld (@y0),de
       0B          
0B0D36 DD 22 59 0D 0214*      ld (@x1),ix
       0B          
0B0D3B FD 22 5B 0D 0215*      ld (@y1),iy
       0B          
0B0D40 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B0D42 32 57 0D 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0D46 21 51 0D 0B 0218*  	ld hl,@cmd0
0B0D4A 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B0D4E 5B DF       0220*  	rst.lil $18
0B0D50 C9          0221*      ret
0B0D51 19          0222*  @cmd0:  db 25 ; plot
0B0D52 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B0D53 00 00       0224*  @x0:    dw 0x0000
0B0D55 00 00       0225*  @y0:    dw 0x0000
0B0D57 19          0226*  @cmd1:  db 25 ; plot
0B0D58 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B0D59 00 00       0228*  @x1:    dw 0x0000
0B0D5B 00 00       0229*  @y1:    dw 0x0000
0B0D5D 00          0230*  @end:   db 0x00 ; padding
0B0D5E             0231*  
0B0D5E             0232*  ; VDU 25, mode, x; y;: PLOT command
0B0D5E             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B0D5E             0234*  plot:
0B0D5E 32 78 0D 0B 0235*      ld (@mode),a
0B0D62 DD 22 79 0D 0236*      ld (@x0),ix
       0B          
0B0D67 FD 22 7B 0D 0237*      ld (@y0),iy
       0B          
0B0D6C 21 77 0D 0B 0238*  	ld hl,@cmd
0B0D70 01 06 00 00 0239*  	ld bc,@end-@cmd
0B0D74 5B DF       0240*  	rst.lil $18
0B0D76 C9          0241*  	ret
0B0D77 19          0242*  @cmd:   db 25
0B0D78 00          0243*  @mode:  db 0
0B0D79 00 00       0244*  @x0: 	dw 0
0B0D7B 00 00       0245*  @y0: 	dw 0
0B0D7D 00          0246*  @end:   db 0 ; padding
0B0D7E             0247*  
0B0D7E             0248*  ; VDU 5: Write text at graphics cursor
0B0D7E             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B0D7E             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B0D7E             0251*  plot_text:
0B0D7E E5          0252*      push hl ; save text pointer
0B0D7F             0253*  ; move graphics cursor to x0, y0
0B0D7F 3E 44       0254*      ld a,plot_pt+mv_abs
0B0D81 CD 5E 0D 0B 0255*      call plot
0B0D85             0256*  ; write text
0B0D85 E1          0257*      pop hl ; restore text pointer
0B0D86 CD 77 02 0B 0258*      call printString
0B0D8A C9          0259*      ret
0B0D8B             0025   
0B0D8B             0026   ; SHAWN'S INCLUDES
0B0D8B             0027   	INCLUDE	"strings24.asm"
0B0D8B             0001*  ;------------------------------------------------------------------------
0B0D8B             0002*  ;  strings24.asm
0B0D8B             0003*  ;
0B0D8B             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B0D8B             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B0D8B             0006*  ;  MIT license
0B0D8B             0007*  ;------------------------------------------------------------------------
0B0D8B             0008*  
0B0D8B             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B0D8B             0010*  ; and postpended with a minus sign if was negative
0B0D8B             0011*  ; Uses HLU, DEU, BCU
0B0D8B             0012*  print_HLU_s24:
0B0D8B CD 78 19 0B 0013*  	call abs_hlu
0B0D8F F5          0014*  	push af ; save the sign and zero flags
0B0D90 CD 9B 0D 0B 0015*  	call print_HLU_u24
0B0D94 F1          0016*  	pop af
0B0D95 F0          0017*  	ret p ; HLU was positive so nothig more to do
0B0D96 3E 2D       0018*  	ld a,'-'
0B0D98 5B D7       0019*  	rst.lil 10h
0B0D9A C9          0020*  	ret
0B0D9B             0021*  
0B0D9B             0022*  ;------------------------------------------------------------------------
0B0D9B             0023*  ;Full print and buffer routine so you can adjust behaviour
0B0D9B             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B0D9B             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B0D9B             0026*  ;Print value in HLU in decimal with leading 0s removed
0B0D9B             0027*  ; Uses HLU, DEU, BCU
0B0D9B             0028*  ;------------------------------------------------------------------------
0B0D9B             0029*  
0B0D9B             0030*  print_HLU_u24:
0B0D9B 22 78 0E 0B 0031*  	ld	(hex_temp),hl
0B0D9F 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B0DA1 11 7B 0E 0B 0033*  	ld	de,outbuf
0B0DA5 D5          0034*  	push	de
0B0DA6 21 07 00 00 0035*  	ld	hl,7
0B0DAA 19          0036*  	add	hl,de
0B0DAB E5          0037*  	push	hl
0B0DAC D1          0038*  	pop	de	;copy HLU to DEU
0B0DAD AF          0039*  	xor	a
0B0DAE             0040*  _pde_u_zerobuf:
0B0DAE 77          0041*  	ld	(hl),a	;zero out the output
0B0DAF 2B          0042*  	dec	hl
0B0DB0 10 FC       0043*  	djnz	_pde_u_zerobuf
0B0DB2             0044*  
0B0DB2 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B0DB4             0046*  _bcd_Convert:
0B0DB4             0047*  
0B0DB4 21 78 0E 0B 0048*  	ld hl,hex_temp
0B0DB8             0049*  ;
0B0DB8 CB 26       0050*  	sla (hl)
0B0DBA 23          0051*  	inc hl
0B0DBB CB 16       0052*  	rl (hl)
0B0DBD 23          0053*  	inc hl
0B0DBE CB 16       0054*  	rl (hl)		;24 bits rolled right
0B0DC0             0055*  
0B0DC0             0056*  
0B0DC0 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B0DC2 D5          0058*  	push	de
0B0DC3 E1          0059*  	pop	hl
0B0DC4             0060*  
0B0DC4             0061*  _bcd_Add3:
0B0DC4 7E          0062*  	ld	a,(hl)
0B0DC5 8F          0063*  	adc	a
0B0DC6 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B0DC7 FE 10       0065*  	cp	10h	;did we roll over nibble?
0B0DC9 3F          0066*  	ccf
0B0DCA CB A7       0067*  	res	4,a
0B0DCC             0068*  
0B0DCC 77          0069*          ld (hl),a
0B0DCD 2B          0070*  	dec	hl
0B0DCE 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B0DD0 0D          0072*          dec c
0B0DD1 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B0DD3             0074*  
0B0DD3             0075*  
0B0DD3 E1          0076*  	pop	hl
0B0DD4 E5          0077*  	push	hl
0B0DD5 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B0DD7             0079*  _pde_u_make_ascii:
0B0DD7 7E          0080*  	ld	a,(hl)
0B0DD8 B7          0081*  	or	a
0B0DD9 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B0DDB 36 20       0083*  	ld	(hl),' '
0B0DDD 23          0084*  	inc	hl
0B0DDE 10 F7       0085*  	djnz	_pde_u_make_ascii
0B0DE0             0086*  _pde_u_make_ascii2:
0B0DE0 04          0087*  	inc	b
0B0DE1             0088*  _pde_u_make_ascii3:
0B0DE1 7E          0089*  	ld	a,(hl)
0B0DE2 F6 30       0090*  	or	30h
0B0DE4 77          0091*  	ld	(hl),a
0B0DE5 23          0092*  	inc	hl
0B0DE6 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B0DE8             0094*  
0B0DE8 E1          0095*  	pop	hl
0B0DE9 06 08       0096*  	ld	b,8
0B0DEB             0097*  _pde_u_final_out:
0B0DEB 7E          0098*  	ld	a,(hl)
0B0DEC 23          0099*  	inc	hl
0B0DED FE 20       0100*  	cp	' '
0B0DEF 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B0DF1 5B D7       0102*  	rst.lil	10h
0B0DF3             0103*  _pde_u_final_out_strip:
0B0DF3 10 F6       0104*  	djnz	_pde_u_final_out
0B0DF5 C9          0105*  	ret
0B0DF6             0106*  
0B0DF6             0107*  ;------------------------------------------------------------------------
0B0DF6             0108*  ; is_digit
0B0DF6             0109*  ; C flag set if A is a digit
0B0DF6             0110*  ; preserves all registers
0B0DF6             0111*  ;------------------------------------------------------------------------
0B0DF6             0112*  is_digit:
0B0DF6 FE 30       0113*  	cp	'0'
0B0DF8 3F          0114*  	ccf
0B0DF9 D0          0115*  	ret	nc	;less that '0'
0B0DFA FE 3A       0116*  	cp	'9' + 1
0B0DFC C9          0117*  	ret
0B0DFD             0118*  
0B0DFD             0119*  
0B0DFD             0120*  ;------------------------------------------------------------------------
0B0DFD             0121*  ; char2hex
0B0DFD             0122*  ; Input: ASCII nibble in A
0B0DFD             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B0DFD             0124*  ;------------------------------------------------------------------------
0B0DFD             0125*  char2hex:
0B0DFD FE 30       0126*  	CP	'0'
0B0DFF 38 1D       0127*  	JR	C, char_not_hex
0B0E01 FE 3A       0128*  	CP	'9' + 1
0B0E03 30 03       0129*  	JR	NC, char_not_09
0B0E05 D6 30       0130*  	sub	'0'
0B0E07 C9          0131*  	ret
0B0E08             0132*  
0B0E08             0133*  char_not_09:
0B0E08             0134*  	; char is not 0 to 9. Try upper case
0B0E08 FE 41       0135*  	CP	'A'
0B0E0A 38 12       0136*  	JR	C, char_not_hex
0B0E0C FE 47       0137*  	CP	'F' + 1
0B0E0E 30 03       0138*  	JR	NC, char_not_AF
0B0E10 D6 37       0139*  	sub	'A'-10
0B0E12 C9          0140*  	ret
0B0E13             0141*  
0B0E13             0142*  char_not_AF:
0B0E13             0143*  	; char is not upper case A-F. Try lower
0B0E13 FE 61       0144*  	CP	'a'
0B0E15 38 07       0145*  	JR	C, char_not_hex
0B0E17 FE 67       0146*  	CP	'f' + 1
0B0E19 30 03       0147*  	JR	NC, char_not_hex
0B0E1B D6 57       0148*  	sub	'a' - 10
0B0E1D C9          0149*  	RET
0B0E1E             0150*  
0B0E1E             0151*  char_not_hex:
0B0E1E 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B0E20 C9          0153*  	RET
0B0E21             0154*  
0B0E21             0155*  ;------------------------------------------------------------------------
0B0E21             0156*  ;  newline
0B0E21             0157*  ;  Output CR+LF; all registers preserved
0B0E21             0158*  ;------------------------------------------------------------------------
0B0E21             0159*  newline:
0B0E21 F5          0160*         push   AF
0B0E22 3E 0D       0161*         LD     A, 13
0B0E24 5B D7       0162*         RST.LIL    10h
0B0E26 3E 0A       0163*         LD     A, 10
0B0E28 5B D7       0164*         RST.LIL    10h
0B0E2A F1          0165*         POP    AF
0B0E2B C9          0166*         RET
0B0E2C             0167*  
0B0E2C             0168*  ;------------------------------------------------------------------------
0B0E2C             0169*  ;  put_nibble
0B0E2C             0170*  ;  Output a single hex nibble in A
0B0E2C             0171*  ;  All registers preserved
0B0E2C             0172*  ;------------------------------------------------------------------------
0B0E2C             0173*  put_nibble:
0B0E2C F5          0174*  	push   AF
0B0E2D C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B0E2F 27          0176*  	daa
0B0E30 CE 40       0177*  	adc    a,040h
0B0E32 27          0178*  	daa
0B0E33 5B D7       0179*  	RST.LIL    10h	;output character in A
0B0E35 F1          0180*  	pop    AF
0B0E36 C9          0181*  	ret
0B0E37             0182*  
0B0E37             0183*  ;------------------------------------------------------------------------
0B0E37             0184*  ;  print_A
0B0E37             0185*  ;  Output the 8-bit hex number A
0B0E37             0186*  ;  All registers preserved
0B0E37             0187*  ;------------------------------------------------------------------------
0B0E37             0188*  print_A:
0B0E37 F5          0189*  	push 	AF
0B0E38 F5          0190*  	push 	AF	;save for second nibble
0B0E39 0F          0191*  	rrca
0B0E3A 0F          0192*  	rrca
0B0E3B 0F          0193*  	rrca
0B0E3C 0F          0194*  	rrca
0B0E3D E6 0F       0195*  	and	0Fh	;first nibble
0B0E3F CD 2C 0E 0B 0196*  	call	put_nibble
0B0E43 F1          0197*  	pop 	AF
0B0E44 E6 0F       0198*  	and	0Fh	;second nibble
0B0E46 CD 2C 0E 0B 0199*  	call	put_nibble
0B0E4A F1          0200*  	pop 	AF
0B0E4B C9          0201*  	ret
0B0E4C             0202*  
0B0E4C             0203*  ;------------------------------------------------------------------------
0B0E4C             0204*  ;  print_HLU_hex
0B0E4C             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B0E4C             0206*  ;------------------------------------------------------------------------
0B0E4C             0207*  print_HLU_hex:
0B0E4C F5          0208*         push   AF
0B0E4D 22 78 0E 0B 0209*         ld     (hex_temp),hl
0B0E51 3A 7A 0E 0B 0210*         ld     a,(hex_temp+2)
0B0E55 CD 37 0E 0B 0211*         call   print_A
0B0E59 3A 79 0E 0B 0212*         ld     a,(hex_temp+1)
0B0E5D CD 37 0E 0B 0213*         call   print_A
0B0E61 3A 78 0E 0B 0214*         ld     a,(hex_temp)
0B0E65 CD 37 0E 0B 0215*         call   print_A
0B0E69 F1          0216*         POP    AF
0B0E6A C9          0217*         RET
0B0E6B             0218*  
0B0E6B             0219*  ;------------------------------------------------------------------------
0B0E6B             0220*  ;  puts
0B0E6B             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B0E6B             0222*  ;  registers preserved.
0B0E6B             0223*  ;------------------------------------------------------------------------
0B0E6B             0224*  puts:
0B0E6B F5          0225*         push   AF
0B0E6C C5          0226*         push   BC
0B0E6D 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B0E71 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B0E73 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B0E75 C1          0230*         pop    BC
0B0E76 F1          0231*         pop    AF
0B0E77 C9          0232*         ret
0B0E78             0233*  
0B0E78             0234*  ;------------------------------------------------------------------------
0B0E78             0235*  ; Data area
0B0E78             0236*  ; Storage for 24 bit conversion
0B0E78             0237*  ;------------------------------------------------------------------------
0B0E78             0238*  hex_temp:
0B0E78 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B0E7B             0240*  
0B0E7B             0241*  outbuf:
0B0E7B 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B0E84             0028   	INCLUDE	"arith24.asm"
0B0E84             0001*  
0B0E84             0002*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0E84             0003*  ; uses EZ80 MLT instruction for speed
0B0E84             0004*  ; operation: UHL * A --> AUHL
0B0E84             0005*  ; destroys: AF, HL
0B0E84             0006*  umul24x8:
0B0E84 D5          0007*  	push de ; preserve de
0B0E85             0008*  ; low byte
0B0E85 5D          0009*  	ld e,l
0B0E86 57          0010*  	ld d,a
0B0E87 ED 5C       0011*  	mlt de
0B0E89 6B          0012*  	ld l,e ; product low byte
0B0E8A 08          0013*  	ex af,af' ; save multiplier
0B0E8B 7A          0014*  	ld a,d ; carry
0B0E8C 08          0015*  	ex af,af' ; save carry, restore multiplier
0B0E8D             0016*  ; high byte
0B0E8D 5C          0017*  	ld e,h
0B0E8E 57          0018*  	ld d,a
0B0E8F ED 5C       0019*  	mlt de
0B0E91 08          0020*  	ex af,af' ; save multiplier, restore carry
0B0E92 83          0021*  	add a,e ; add carry
0B0E93 67          0022*  	ld h,a ; product middle byte
0B0E94 7A          0023*  	ld a,d ; carry
0B0E95 08          0024*  	ex af,af' ; save carry, restore multiplier
0B0E96             0025*  ; upper byte
0B0E96 E5          0026*  	push hl
0B0E97 33          0027*  	inc sp
0B0E98 D1          0028*  	pop de ; d = hlu
0B0E99 3B          0029*  	dec sp
0B0E9A 5F          0030*  	ld e,a
0B0E9B ED 5C       0031*  	mlt de
0B0E9D 08          0032*  	ex af,af' ; restore carry
0B0E9E 8B          0033*  	adc a,e ; add carry
0B0E9F             0034*  ; highest byte
0B0E9F 22 B0 0E 0B 0035*      ld (@scratch),hl ; 7 cycles
0B0EA3 32 B2 0E 0B 0036*      ld (@scratch+2),a ; 5 cycles
0B0EA7 2A B0 0E 0B 0037*      ld hl,(@scratch) ; 7 cycles
0B0EAB 3E 00       0038*  	ld a,0 ; preserve carry flag
0B0EAD 8A          0039*  	adc a,d ; product highest byte
0B0EAE D1          0040*  	pop de ; restore de
0B0EAF C9          0041*  	ret
0B0EB0             0042*  @scratch: ds 3
0B0EB3             0043*  
0B0EB3             0044*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0EB3             0045*  ; operation: UHL * UDE --> umul24x24out
0B0EB3             0046*  umul24x24:
0B0EB3 FD 21 0B 0F 0047*  	ld iy,umul24x24out ; point to output buffer
       0B          
0B0EB8 C5          0048*  	push bc
0B0EB9 01 00 00 00 0049*  	ld bc,0
0B0EBD FD 0F 00    0050*  	ld (iy),bc
0B0EC0 FD 0F 03    0051*  	ld (iy+3),bc
0B0EC3 C1          0052*  	pop bc
0B0EC4             0053*  
0B0EC4             0054*  ; STEP 1: UHL * E
0B0EC4 7B          0055*  	ld a,e
0B0EC5 E5          0056*  	push hl
0B0EC6 CD 84 0E 0B 0057*  	call umul24x8
0B0ECA FD 2F 00    0058*  	ld (iy+0),hl
0B0ECD FD 77 03    0059*  	ld (iy+3),a
0B0ED0             0060*  
0B0ED0             0061*  ; STEP 2: UHL * D
0B0ED0 E1          0062*  	pop hl
0B0ED1 E5          0063*  	push hl
0B0ED2 7A          0064*  	ld a,d
0B0ED3 CD 84 0E 0B 0065*  	call umul24x8
0B0ED7 CD E4 0E 0B 0066*  	call @accumulate
0B0EDB             0067*  
0B0EDB             0068*  ; STEP 3: UHL * DEU
0B0EDB E1          0069*  	pop hl
0B0EDC D5          0070*  	push de
0B0EDD 33          0071*  	inc sp
0B0EDE F1          0072*  	pop af
0B0EDF 3B          0073*  	dec sp
0B0EE0 CD 84 0E 0B 0074*  	call umul24x8
0B0EE4             0075*  
0B0EE4             0076*  @accumulate:
0B0EE4 FD 23       0077*  	inc iy
0B0EE6             0078*  ; highest byte of product to carry
0B0EE6 FD 77 03    0079*  	ld (iy+3),a
0B0EE9             0080*  ; low byte of product
0B0EE9 7D          0081*  	ld a,l
0B0EEA FD 86 00    0082*  	add a,(iy+0)
0B0EED FD 77 00    0083*  	ld (iy+0),a
0B0EF0             0084*  ; high byte of product
0B0EF0 7C          0085*  	ld a,h
0B0EF1 FD 8E 01    0086*  	adc a,(iy+1)
0B0EF4 FD 77 01    0087*  	ld (iy+1),a
0B0EF7             0088*  ; uppper byte of product
0B0EF7 E5          0089*  	push hl
0B0EF8 33          0090*  	inc sp
0B0EF9 E1          0091*  	pop hl
0B0EFA 3B          0092*  	dec sp
0B0EFB 7C          0093*  	ld a,h
0B0EFC FD 8E 02    0094*  	adc a,(iy+2)
0B0EFF FD 77 02    0095*  	ld (iy+2),a
0B0F02             0096*  ; carry
0B0F02 3E 00       0097*  	ld a,0 ; preserve flags
0B0F04 FD 8E 03    0098*  	adc a,(iy+3)
0B0F07 FD 77 03    0099*  	ld (iy+3),a
0B0F0A C9          0100*  	ret
0B0F0B             0101*  
0B0F0B             0102*  umul24x24out: ds 6 ; output buffer
0B0F11             0103*  
0B0F11             0104*  arith24uaf: ds 6
0B0F17             0105*  arith24uhl: ds 6
0B0F1D             0106*  arith24ubc: ds 6
0B0F23             0107*  arith24ude: ds 6
0B0F29             0108*  arith24uix: ds 6
0B0F2F             0109*  arith24uiy: ds 6
0B0F35             0110*  arith24usp: ds 6
0B0F3B             0111*  arith24upc: ds 6
0B0F41             0112*  
0B0F41             0113*  ; hlu 1 byte right shift
0B0F41             0114*  ; returns: hlu / 256, fractional portion in a
0B0F41             0115*  ; destroys: af
0B0F41             0116*  shift_hlu_r1b:
0B0F41 AF          0117*  	xor a
0B0F42 32 53 0F 0B 0118*  	ld (@buffer+3),a
0B0F46 7D          0119*  	ld a,l ; save the fractional portion
0B0F47 22 50 0F 0B 0120*  	ld (@buffer),hl
0B0F4B 2A 51 0F 0B 0121*  	ld hl,(@buffer+1)
0B0F4F C9          0122*  	ret
0B0F50             0123*  @buffer: ds 4
0B0F54             0124*  
0B0F54             0125*  ;------------------------------------------------------------------------
0B0F54             0126*  ;  arith24.asm
0B0F54             0127*  ;  24-bit ez80 arithmetic routines
0B0F54             0128*  ;  Copyright (c) Shawn Sijnstra 2024
0B0F54             0129*  ;  MIT license
0B0F54             0130*  ;
0B0F54             0131*  ;  This library was created as a tool to help make ez80
0B0F54             0132*  ;  24-bit native assembly routines for simple mathematical problems
0B0F54             0133*  ;  more widely available.
0B0F54             0134*  ;
0B0F54             0135*  ;------------------------------------------------------------------------
0B0F54             0136*  
0B0F54             0137*  ;------------------------------------------------------------------------
0B0F54             0138*  ; umul24:	HL = HL*DE (unsigned)
0B0F54             0139*  ; Preserves AF, BC, DE
0B0F54             0140*  ; Uses a fast multiply routine.
0B0F54             0141*  ;------------------------------------------------------------------------
0B0F54             0142*  umul24:
0B0F54 D5          0143*  	push	DE
0B0F55 C5          0144*  	push	BC
0B0F56 F5          0145*  	push	AF
0B0F57 E5          0146*  	push	HL
0B0F58 C1          0147*  	pop		BC
0B0F59 3E 18       0148*      ld	 	a, 24 ; No. of bits to process
0B0F5B 21 00 00 00 0149*      ld	 	hl, 0 ; Result
0B0F5F             0150*  umul24_lp:
0B0F5F 29          0151*  	add	hl,hl
0B0F60 EB          0152*  	ex	de,hl
0B0F61 29          0153*  	add	hl,hl
0B0F62 EB          0154*  	ex	de,hl
0B0F63 30 01       0155*  	jr	nc,umul24_nc
0B0F65 09          0156*  	add	hl,bc
0B0F66             0157*  umul24_nc:
0B0F66 3D          0158*  	dec	a
0B0F67 20 F6       0159*  	jr	nz,umul24_lp
0B0F69 F1          0160*  	pop	af
0B0F6A C1          0161*  	pop	bc
0B0F6B D1          0162*  	pop	de
0B0F6C C9          0163*  	ret
0B0F6D             0164*  
0B0F6D             0165*  ;------------------------------------------------------------------------
0B0F6D             0166*  ; udiv24
0B0F6D             0167*  ; Unsigned 24-bit division
0B0F6D             0168*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0F6D             0169*  ;
0B0F6D             0170*  ; Uses AF BC DE HL
0B0F6D             0171*  ; Uses Restoring Division algorithm
0B0F6D             0172*  ;------------------------------------------------------------------------
0B0F6D             0173*  
0B0F6D             0174*  udiv24:
0B0F6D E5          0175*  	push	hl
0B0F6E C1          0176*  	pop		bc	;move dividend to BCU
0B0F6F 21 00 00 00 0177*  	ld		hl,0	;result
0B0F73 A7          0178*  	and		a
0B0F74 ED 52       0179*  	sbc		hl,de	;test for div by 0
0B0F76 C8          0180*  	ret		z		;it's zero, carry flag is clear
0B0F77 19          0181*  	add		hl,de	;HL is 0 again
0B0F78 3E 18       0182*  	ld		a,24	;number of loops through.
0B0F7A             0183*  udiv1:
0B0F7A C5          0184*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0F7B E3          0185*  	ex		(sp),hl
0B0F7C 37          0186*  	scf
0B0F7D ED 6A       0187*  	adc	hl,hl
0B0F7F E3          0188*  	ex	(sp),hl
0B0F80 C1          0189*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0F81             0190*  
0B0F81 ED 6A       0191*  	adc	hl,hl
0B0F83 A7          0192*  	and	a		;is this the bug
0B0F84 ED 52       0193*  	sbc	hl,de
0B0F86 30 02       0194*  	jr	nc,udiv2
0B0F88 19          0195*  	add	hl,de
0B0F89             0196*  ;	dec	c
0B0F89 0B          0197*  	dec	bc
0B0F8A             0198*  udiv2:
0B0F8A 3D          0199*  	dec	a
0B0F8B 20 ED       0200*  	jr	nz,udiv1
0B0F8D 37          0201*  	scf		;flag used for div0 error
0B0F8E C5          0202*  	push	bc
0B0F8F D1          0203*  	pop		de	;remainder
0B0F90 C9          0204*  	ret
0B0F91             0205*  
0B0F91             0206*  
0B0F91             0207*  ; umul24:	UH.L = UH.L*UD.E (unsigned)
0B0F91             0208*  ; Preserves AF, BC, DE
0B0F91             0209*  umul168:
0B0F91             0210*  
0B0F91             0211*  umul168out: ds 6
0B0F97             0212*  
0B0F97             0213*  ; perform signed multiplication of 16.8 fixed place values
0B0F97             0214*  ; with an signed 16.8 fixed place result
0B0F97             0215*  ; inputs: ub.c and ud.e are the operands
0B0F97             0216*  ; outputs: uh.l is the product
0B0F97             0217*  ; destroys: a,bc
0B0F97             0218*  ; TODO: make flags appropriate to the sign of the result
0B0F97             0219*  smul168:
0B0F97             0220*  ; make everything positive and save signs
0B0F97 C5          0221*      push bc         ; get bc to hl
0B0F98 E1          0222*      pop hl          ; for the next call
0B0F99 CD 78 19 0B 0223*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
0B0F9D             0224*  
0B0F9D             0225*      ; call dumpFlags ; passes
0B0F9D             0226*  
0B0F9D CA D0 0F 0B 0227*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B0FA1 F5          0228*      push af         ; save sign of bc
0B0FA2 E5          0229*      push hl         ; now put abs(hl)
0B0FA3 C1          0230*      pop bc          ; back into bc = abs(bc)
0B0FA4 EB          0231*      ex de,hl        ; now we do de same way
0B0FA5 CD 78 19 0B 0232*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
0B0FA9             0233*  
0B0FA9             0234*      ; call dumpFlags ; passes
0B0FA9             0235*  
0B0FA9 CA D0 0F 0B 0236*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
0B0FAD EB          0237*      ex de,hl        ; hl back to de = abs(de)
0B0FAE             0238*  ; determine sign of result
0B0FAE F2 B9 0F 0B 0239*      jp p,@de_pos    ; sign positive,de is positive
0B0FB2             0240*  
0B0FB2             0241*      ; call dumpFlags ; correctly doesnt make it here
0B0FB2             0242*  
0B0FB2 F1          0243*      pop af          ; get back sign of bc
0B0FB3             0244*  
0B0FB3             0245*      ; call dumpFlags ; correctly doesn't make it here
0B0FB3             0246*  
0B0FB3 FA C2 0F 0B 0247*      jp m,@result_pos  ; bc and de negative, result is positive
0B0FB7             0248*  
0B0FB7             0249*      ; call dumpFlags  ; corectly doesn't make it here
0B0FB7             0250*  
0B0FB7 18 05       0251*      jr @result_neg
0B0FB9             0252*  @de_pos:
0B0FB9 F1          0253*      pop af          ; get back sign of bc
0B0FBA             0254*  
0B0FBA             0255*      ; call dumpFlags  ; passes
0B0FBA             0256*  
0B0FBA F2 C2 0F 0B 0257*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B0FBE             0258*  
0B0FBE             0259*      ; call dumpFlags ; correctly makes it here
0B0FBE             0260*  
0B0FBE             0261*                      ; fall through to result_neg
0B0FBE             0262*  @result_neg:
0B0FBE AF          0263*      xor a           ; zero a and clear carry
0B0FBF 3D          0264*      dec a           ; set sign flag to negative
0B0FC0             0265*  
0B0FC0             0266*      ; call dumpFlags ; passes
0B0FC0             0267*  
0B0FC0 18 02       0268*      jr @do_mul
0B0FC2             0269*  @result_pos:
0B0FC2 AF          0270*      xor a           ; zero a and clear carry
0B0FC3 3C          0271*      inc a           ; set sign flag to positive
0B0FC4             0272*                      ; fall through to do_mul
0B0FC4             0273*  
0B0FC4             0274*      ; call dumpFlags ; correctly doesn't make it here
0B0FC4             0275*  
0B0FC4             0276*  @do_mul:
0B0FC4 F5          0277*      push af         ; save sign of result
0B0FC5 CD 91 0F 0B 0278*      call umul168
0B0FC9 F1          0279*      pop af          ; get back sign of result
0B0FCA             0280*  
0B0FCA             0281*      ; call dumpFlags ; passes
0B0FCA             0282*  
0B0FCA F0          0283*      ret p           ; result is positive so nothing to do
0B0FCB             0284*  
0B0FCB             0285*      ; call dumpRegistersHex ; passes
0B0FCB             0286*  
0B0FCB CD 88 19 0B 0287*      call neg_hlu    ; result is negative so negate it
0B0FCF             0288*  
0B0FCF             0289*      ; call dumpRegistersHex ; passes
0B0FCF C9          0290*      ret
0B0FD0             0291*  @is_zero:           ; result is zero
0B0FD0 AF          0292*      xor a           ; sets zero flag, which we want,
0B0FD1             0293*                      ; sets pv flag which we might not (zero is parity even)
0B0FD1             0294*                      ; resets all others which is okay
0B0FD1 C9          0295*      ret
0B0FD2             0296*  
0B0FD2             0297*  ; perform unsigned division of fixed place values
0B0FD2             0298*  ; with an unsigned 16.8 fixed place result
0B0FD2             0299*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0B0FD2             0300*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0B0FD2             0301*  ; destroys: a,bc
0B0FD2             0302*  udiv168:
0B0FD2             0303*  ; shift dividend left 8 bits
0B0FD2 ED 43 1E 0F 0304*      ld (arith24ubc+1),bc
       0B          
0B0FD7 AF          0305*      xor a
0B0FD8 32 1D 0F 0B 0306*      ld (arith24ubc),a
0B0FDC ED 4B 1D 0F 0307*      ld bc,(arith24ubc)
       0B          
0B0FE1 CD 6D 0F 0B 0308*      call udiv24
0B0FE5             0309*  ; flip-flop outptuts to satisfy downstream consumers
0B0FE5             0310*  ; TODO: this is a hack and should be fixed
0B0FE5             0311*  ; (so says copilot ... but it's not wrong)
0B0FE5 E5          0312*      push hl
0B0FE6 C5          0313*      push bc
0B0FE7 E1          0314*      pop hl
0B0FE8 C1          0315*      pop bc
0B0FE9 C9          0316*      ret
0B0FEA             0317*  
0B0FEA             0318*  ; perform signed division of 16.8 fixed place values
0B0FEA             0319*  ; with an signed 16.8 fixed place result
0B0FEA             0320*  ; inputs: ub.c is dividend,ud.e is divisor
0B0FEA             0321*  ; outputs: uh.l is quotient
0B0FEA             0322*  ; destroys: a,bc
0B0FEA             0323*  ; note: uses carry flag to test for sign of operands and result
0B0FEA             0324*  ;       which can be confusing and should perhaps be changed
0B0FEA             0325*  ; note2: helper functions abs_hlu and neg_hlu have been modified
0B0FEA             0326*  ;       to return accurate flags according to the origional signs
0B0FEA             0327*  ;       (or zero) of this function's inputs
0B0FEA             0328*  sdiv168:
0B0FEA             0329*  ; make everything positive and save signs
0B0FEA C5          0330*      push bc         ; get bc to hl
0B0FEB E1          0331*      pop hl          ; for the next call
0B0FEC CD 78 19 0B 0332*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
0B0FF0 CA 23 10 0B 0333*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B0FF4 F5          0334*      push af         ; save sign of bc
0B0FF5 E5          0335*      push hl         ; now put abs(hl)
0B0FF6 C1          0336*      pop bc          ; back into bc = abs(bc)
0B0FF7 EB          0337*      ex de,hl        ; now we do de same way
0B0FF8 CD 78 19 0B 0338*      call abs_hlu
0B0FFC CA 25 10 0B 0339*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
0B1000 EB          0340*      ex de,hl        ; hl back to de = abs(de)
0B1001             0341*  ; determine sign of result
0B1001 F2 0C 10 0B 0342*      jp p,@de_pos    ; sign positive,de is positive
0B1005 F1          0343*      pop af          ; get back sign of bc
0B1006 FA 15 10 0B 0344*      jp m,@result_pos  ; bc and de negative, result is positive
0B100A 18 05       0345*      jr @result_neg
0B100C             0346*  @de_pos:
0B100C F1          0347*      pop af          ; get back sign of bc
0B100D F2 15 10 0B 0348*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B1011             0349*                      ; fall through to result_neg
0B1011             0350*  @result_neg:
0B1011 AF          0351*      xor a           ; zero a and clear carry
0B1012 3D          0352*      dec a           ; set sign flag to negative
0B1013 18 02       0353*      jr @do_div
0B1015             0354*  @result_pos:
0B1015 AF          0355*      xor a           ; zero a and clear carry
0B1016 3C          0356*      inc a           ; set sign flag to negative
0B1017             0357*                      ; fall through to do_div
0B1017             0358*  @do_div:
0B1017 F5          0359*      push af         ; save sign of result
0B1018 CD D2 0F 0B 0360*      call udiv168
0B101C F1          0361*      pop af          ; get back sign of result
0B101D F0          0362*      ret p           ; result is positive so nothing to do
0B101E CD 88 19 0B 0363*      call neg_hlu    ; result is negative so negate it
0B1022 C9          0364*      ret
0B1023             0365*  @is_zero:           ; result is zero
0B1023 AF          0366*      xor a           ; sets zero flag, which we want,
0B1024             0367*                      ; sets pv flag which we might not (zero is parity even)
0B1024             0368*                      ; resets all others which is okay
0B1024 C9          0369*      ret
0B1025             0370*  @div_by_zero:       ; result is undefined, which isn't defined in binary
0B1025             0371*                      ; so we'll just return zero until i can think of something better
0B1025 F1          0372*      pop af          ; dummy pop
0B1026 AF          0373*      xor a           ; sets zero flag, which is ok,
0B1027             0374*                      ; sets pv flag which could be interpreted as overflow, which is good
0B1027             0375*                      ; resets all others which is okay
0B1027 C9          0376*      ret
0B1028             0377*  
0B1028             0378*  ;------------------------------------------------------------------------
0B1028             0379*  ; neg24
0B1028             0380*  ; Returns: HLU = 0-HLU
0B1028             0381*  ; preserves all other registers
0B1028             0382*  ;------------------------------------------------------------------------
0B1028             0383*  neg24:
0B1028 D5          0384*  	push	de
0B1029 EB          0385*  	ex		de,hl
0B102A 21 00 00 00 0386*  	ld		hl,0
0B102E B7          0387*  	or		a
0B102F ED 52       0388*  	sbc		hl,de
0B1031 D1          0389*  	pop		de
0B1032 C9          0390*  	ret
0B1033             0391*  
0B1033             0392*  ;------------------------------------------------------------------------
0B1033             0393*  ; or_hlu_deu: 24 bit bitwise OR
0B1033             0394*  ; Returns: hlu = hlu OR deu
0B1033             0395*  ; preserves all other registers
0B1033             0396*  ;------------------------------------------------------------------------
0B1033             0397*  or_hlu_deu:
0B1033 22 BE 10 0B 0398*  	ld	(bitbuf1),hl
0B1037 ED 53 C1 10 0399*  	ld	(bitbuf2),de
       0B          
0B103C D5          0400*  	push	de	;preserve DEU
0B103D C5          0401*  	push	bc	;preserve BCU
0B103E 06 03       0402*  	ld		b,3
0B1040 21 BE 10 0B 0403*  	ld	hl,bitbuf1
0B1044 11 BE 10 0B 0404*  	ld	de,bitbuf1
0B1048             0405*  orloop_24:
0B1048 1A          0406*  	ld	a,(de)
0B1049 B6          0407*  	or	(hl)
0B104A 12          0408*  	ld	(de),a
0B104B 13          0409*  	inc	de
0B104C 23          0410*  	inc	hl
0B104D 10 F9       0411*  	djnz	orloop_24
0B104F 2A C1 10 0B 0412*  	ld	hl,(bitbuf2)
0B1053 C1          0413*  	pop		bc	;restore BC
0B1054 D1          0414*  	pop		de	;restore DE
0B1055             0415*  
0B1055             0416*  ;------------------------------------------------------------------------
0B1055             0417*  ; and_hlu_deu: 24 bit bitwise AND
0B1055             0418*  ; Returns: hlu = hlu AND deu
0B1055             0419*  ; preserves all other registers
0B1055             0420*  ;------------------------------------------------------------------------
0B1055             0421*  and_hlu_deu:
0B1055 22 BE 10 0B 0422*  	ld	(bitbuf1),hl
0B1059 ED 53 C1 10 0423*  	ld	(bitbuf2),de
       0B          
0B105E D5          0424*  	push	de	;preserve DEU
0B105F C5          0425*  	push	bc	;preserve BCU
0B1060 06 03       0426*  	ld		b,3
0B1062 21 BE 10 0B 0427*  	ld	hl,bitbuf1
0B1066 11 BE 10 0B 0428*  	ld	de,bitbuf1
0B106A             0429*  andloop_24:
0B106A 1A          0430*  	ld	a,(de)
0B106B A6          0431*  	and	(hl)
0B106C 12          0432*  	ld	(de),a
0B106D 13          0433*  	inc	de
0B106E 23          0434*  	inc	hl
0B106F 10 F9       0435*  	djnz	andloop_24
0B1071 2A C1 10 0B 0436*  	ld	hl,(bitbuf2)
0B1075 C1          0437*  	pop		bc	;restore BC
0B1076 D1          0438*  	pop		de	;restore DE
0B1077             0439*  
0B1077             0440*  ;------------------------------------------------------------------------
0B1077             0441*  ; xor_hlu_deu: 24 bit bitwise XOR
0B1077             0442*  ; Returns: hlu = hlu XOR deu
0B1077             0443*  ; preserves all other registers
0B1077             0444*  ;------------------------------------------------------------------------
0B1077             0445*  xor_hlu_deu:
0B1077 22 BE 10 0B 0446*  	ld	(bitbuf1),hl
0B107B ED 53 C1 10 0447*  	ld	(bitbuf2),de
       0B          
0B1080 D5          0448*  	push	de	;preserve DEU
0B1081 C5          0449*  	push	bc	;preserve BCU
0B1082 06 03       0450*  	ld		b,3
0B1084 21 BE 10 0B 0451*  	ld	hl,bitbuf1
0B1088 11 BE 10 0B 0452*  	ld	de,bitbuf1
0B108C             0453*  xorloop_24:
0B108C 1A          0454*  	ld	a,(de)
0B108D AE          0455*  	xor	(hl)
0B108E 12          0456*  	ld	(de),a
0B108F 13          0457*  	inc	de
0B1090 23          0458*  	inc	hl
0B1091 10 F9       0459*  	djnz	xorloop_24
0B1093 2A C1 10 0B 0460*  	ld	hl,(bitbuf2)
0B1097 C1          0461*  	pop		bc	;restore BC
0B1098 D1          0462*  	pop		de	;restore DE
0B1099             0463*  
0B1099             0464*  ;------------------------------------------------------------------------
0B1099             0465*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B1099             0466*  ; Returns: hlu = hlu << deu
0B1099             0467*  ;		   de = 0
0B1099             0468*  ; NOTE: only considers deu up to 16 bits.
0B1099             0469*  ; preserves all other registers
0B1099             0470*  ;------------------------------------------------------------------------
0B1099             0471*  shl_hlu:
0B1099 7A          0472*  	ld		a,d		;up to 16 bit.
0B109A B3          0473*  	or		e
0B109B C8          0474*  	ret		z		;we're done
0B109C 29          0475*  	add		hl,hl	;shift HLU left
0B109D 1B          0476*  	dec		de
0B109E 18 F9       0477*  	jr		shl_hlu
0B10A0             0478*  
0B10A0             0479*  ;------------------------------------------------------------------------
0B10A0             0480*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B10A0             0481*  ; Returns: hlu = hlu >> deu
0B10A0             0482*  ;		   de = 0
0B10A0             0483*  ; NOTE: only considers deu up to 16 bits.
0B10A0             0484*  ; preserves all other registers
0B10A0             0485*  ;------------------------------------------------------------------------
0B10A0             0486*  shr_hlu:
0B10A0 22 BE 10 0B 0487*  	ld		(bitbuf1),hl
0B10A4 21 C0 10 0B 0488*  	ld		hl,bitbuf1+2
0B10A8             0489*  shr_loop:
0B10A8 7A          0490*  	ld		a,d		;up to 16 bit.
0B10A9 B3          0491*  	or		e
0B10AA 28 0D       0492*  	jr		z,shr_done		;we're done
0B10AC             0493*  ;carry is clear from or instruction
0B10AC CB 1E       0494*  	rr		(hl)
0B10AE 2B          0495*  	dec		hl
0B10AF CB 1E       0496*  	rr		(hl)
0B10B1 2B          0497*  	dec		hl
0B10B2 CB 1E       0498*  	rr		(hl)
0B10B4 23          0499*  	inc		hl
0B10B5 23          0500*  	inc		hl
0B10B6 1B          0501*  	dec		de
0B10B7 18 EF       0502*  	jr		shr_loop
0B10B9             0503*  shr_done:
0B10B9 2A BE 10 0B 0504*  	ld		hl,(bitbuf1)	;collect result
0B10BD C9          0505*  	ret
0B10BE             0506*  
0B10BE             0507*  ;------------------------------------------------------------------------
0B10BE             0508*  ; Scratch area for calculations
0B10BE             0509*  ;------------------------------------------------------------------------
0B10BE 00 00 00    0510*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B10C1 00 00 00    0511*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B10C4             0512*  
0B10C4             0513*  ; ========== FROM maths24.inc ==========
0B10C4             0514*  
0B10C4             0515*  ; http://www.z80.info/pseudo-random.txt
0B10C4             0516*  rand_8:
0B10C4 C5          0517*      push bc
0B10C5 3A D8 10 0B 0518*      ld a,(r_seed)
0B10C9 4F          0519*      ld c,a
0B10CA             0520*  
0B10CA 0F          0521*      rrca ; multiply by 32
0B10CB 0F          0522*      rrca
0B10CC 0F          0523*      rrca
0B10CD EE 1F       0524*      xor 0x1f
0B10CF             0525*  
0B10CF 81          0526*      add a,c
0B10D0 DE FF       0527*      sbc a,255 ; carry
0B10D2             0528*  
0B10D2 32 D8 10 0B 0529*      ld (r_seed),a
0B10D6 C1          0530*      pop bc
0B10D7 C9          0531*      ret
0B10D8 50          0532*  r_seed: defb $50
0B10D9             0533*  
0B10D9             0534*  ; tests the sign of 24-bit register hlu
0B10D9             0535*  ; returns: a in [-1,0,1]
0B10D9             0536*  ;   sign and zero flags as expected
0B10D9             0537*  ;   hl is untouched
0B10D9             0538*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
0B10D9             0539*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
0B10D9             0540*  get_sign_hlu:
0B10D9             0541*      ; Load the upper byte of HLU into A
0B10D9 E5          0542*      push hl
0B10DA DD 21 00 00 0543*      ld ix,0
       00          
0B10DF DD 39       0544*      add ix,sp
0B10E1 DD 7E 02    0545*      ld a,(ix+2)
0B10E4 E1          0546*      pop hl
0B10E5             0547*  
0B10E5 B5          0548*      or l                ; OR with the low byte to check if HL is zero
0B10E6 C8          0549*      ret z               ; Return if HL is zero
0B10E7             0550*  
0B10E7 3E FF       0551*      ld a,-1             ; Send A back as -1 if the sign flag is set
0B10E9 CB 7C       0552*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
0B10EB C0          0553*      ret nz              ; If set,HL is negative,return with the sign flag set
0B10EC             0554*  
0B10EC 3E 01       0555*      ld a,1             ; Otherwise,HL is positive
0B10EE A7          0556*      and a               ; Reset the zero flag
0B10EF C9          0557*      ret                 ; Return with A set to 1
0B10F0             0558*  
0B10F0             0559*  ; convert unsigned angles from a 360 to 255 degree circle
0B10F0             0560*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B10F0             0561*  ; outputs: uh.l is the angle255 in 16.8 fixed format
0B10F0             0562*  ; destroys: TODO
0B10F0             0563*  ; note: even though the inputs and outputs are 16.8 fixed format
0B10F0             0564*  ;       precision is effectively limited to 8.8 fixed format
0B10F0             0565*  deg_360_to_255:
0B10F0             0566*  ; clear scratch buffer
0B10F0 11 00 00 00 0567*  	ld de,0
0B10F4 ED 53 20 11 0568*  	ld (@scratch),de
       0B          
0B10F9             0569*  ; divide uh.l by 360
0B10F9 11 68 01 00 0570*  	ld de,360
0B10FD             0571*  ; get integer portion
0B10FD CD 6D 0F 0B 0572*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B1101 ED 53 27 11 0573*  	ld (@output+1),de ; shift result up one byte
       0B          
0B1106             0574*  ; get fractional portion
0B1106 22 21 11 0B 0575*  	ld (@scratch+1),hl ; shift remainder up one byte
0B110A 2A 20 11 0B 0576*  	ld hl,(@scratch)
0B110E 11 68 01 00 0577*  	ld de,360
0B1112 CD 6D 0F 0B 0578*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B1116 7B          0579*  	ld a,e ; lowest byte is all we need
0B1117 32 26 11 0B 0580*  	ld (@output),a
0B111B             0581*  ; we want the low 3 bytes for 16.8 output
0B111B 2A 26 11 0B 0582*  	ld hl,(@output)
0B111F C9          0583*  	ret
0B1120             0584*  @scratch: ds 6 ; scratch buffer for shifting bytes
0B1126             0585*  @output: ds 6 ; scratch buffer to accumulate output
0B112C             0586*  
0B112C             0587*  ; 16.8 fixed inputs / outputs
0B112C             0588*  ; takes: uh.l as angle in degrees 256
0B112C             0589*  ;        ud.e as radius
0B112C             0590*  ; returns ub.c as dx, ud.e as dy
0B112C             0591*  ;        displacements from origin (0,0)
0B112C             0592*  ; destroys: everything except indexes
0B112C             0593*  polar_to_cartesian:
0B112C             0594*  ; back up input parameters
0B112C 22 17 0F 0B 0595*      ld (arith24uhl), hl
0B1130 ED 53 23 0F 0596*      ld (arith24ude), de
       0B          
0B1135             0597*  ; compute dx = sin(uh.l) * ud.e
0B1135 CD 64 11 0B 0598*      call sin168
0B1139 E5          0599*      push hl
0B113A C1          0600*      pop bc          ; ub.c = sin(uh.l)
0B113B ED 5B 23 0F 0601*  	ld de, (arith24ude)   ; get radius back
       0B          
0B1140 CD 97 0F 0B 0602*  	call smul168    ; uh.l = ub.c * ud.e = dx
0B1144 E5          0603*      push hl         ; store dx for output
0B1145             0604*  ; compute dy = -cos(uh.l) * ud.e
0B1145 2A 17 0F 0B 0605*      ld hl, (arith24uhl)
0B1149 CD 5F 11 0B 0606*      call cos168
0B114D CD 88 19 0B 0607*  	call neg_hlu    ; invert dy for screen coords convention
0B1151 E5          0608*      push hl
0B1152 C1          0609*      pop bc          ; ub.c = -cos(uh.l)
0B1153 ED 5B 23 0F 0610*      ld de, (arith24ude)   ; get radius back
       0B          
0B1158 CD 97 0F 0B 0611*      call smul168    ; uh.l = ub.c * ud.e = dy
0B115C EB          0612*      ex de, hl       ; de = dy for output
0B115D C1          0613*      pop bc          ; bc = dx for output
0B115E             0614*  ; and out
0B115E C9          0615*      ret
0B115F             0616*  
0B115F             0617*  ; fixed 16.8 routine
0B115F             0618*  ; cos(uh.l) --> uh.l
0B115F             0619*  ; destroys: de
0B115F             0620*  cos168:
0B115F             0621*  ; for cos we simply increment the angle by 90 degrees
0B115F             0622*  ; or 0x004000 in 16.8 degrees256
0B115F             0623*  ; which makes it a sin problem
0B115F 11 00 40 00 0624*      ld de,0x004000
0B1163 19          0625*      add hl,de ; modulo 256 happens below
0B1164             0626*  ; fall through to sin168
0B1164             0627*  ; ---------------------
0B1164             0628*  ; fixed 16.8 routine
0B1164             0629*  ; sin(uh.l) --> uh.l
0B1164             0630*  ; destroys: de
0B1164             0631*  sin168:
0B1164             0632*  ; h contains the integer portion of our angle
0B1164             0633*  ; we multiply it by three to get our lookup table index
0B1164 2E 03       0634*      ld l,3
0B1166 ED 6C       0635*      mlt hl ; gosh that is handy
0B1168 11 00 00 00 0636*      ld de,0 ; clear deu
0B116C 54          0637*      ld d,h ; copy hl to de
0B116D 5D          0638*      ld e,l ; de contains our index
0B116E 21 75 13 0B 0639*      ld hl,sin_lut_168 ; grab the lut address
0B1172 19          0640*      add hl,de ; bump hl by the index
0B1173 ED 27       0641*      ld hl,(hl) ; don't try this on a z80!
0B1175 C9          0642*      ret ; and out
0B1176             0643*  
0B1176             0644*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B1176             0645*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B1176             0646*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B1176             0647*  ;         also populates scratch locations dx168 and dy168
0B1176             0648*  ; destroys: a,hl,bc,de
0B1176             0649*  dxy168:
0B1176             0650*  ; compute dx = x1-x0
0B1176 AF          0651*      xor a ; clear carry
0B1177 DD E5       0652*      push ix ; move ix to hl via the stack
0B1179 E1          0653*      pop hl ; hl = x1
0B117A ED 42       0654*      sbc hl,bc ; hl = dx
0B117C 22 D1 11 0B 0655*      ld (dx168),hl ; dx to scratch
0B1180             0656*  ; compute dy = y1-y0
0B1180 AF          0657*      xor a ; clear carry
0B1181 FD E5       0658*      push iy ; move iy to hl via the stack
0B1183 E1          0659*      pop hl ; hl = y1
0B1184 ED 52       0660*      sbc hl,de ; hl = dy
0B1186 22 D7 11 0B 0661*      ld (dy168),hl ; dy to scratch
0B118A             0662*  ; populate output registers and return
0B118A EB          0663*      ex de,hl        ; ud.e = dy
0B118B ED 4B D1 11 0664*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B1190 C9          0665*      ret
0B1191             0666*  
0B1191             0667*  ; compute the euclidian distance between two cartesian coordinates
0B1191             0668*  ; using the formula d = sqrt(dx^2+dy^2
0B1191             0669*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B1191             0670*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B1191             0671*  ; output; uh.l is the 16.8 fixed format distance
0B1191             0672*  ;       dx168/y are the 16.8 fixed format dx and dy
0B1191             0673*  ; destroys: a,hl,bc,de
0B1191             0674*  distance168:
0B1191             0675*  ; compute dx = x1-x0
0B1191 AF          0676*      xor a ; clear carry
0B1192 DD E5       0677*      push ix ; move ix to hl via the stack
0B1194 E1          0678*      pop hl ; hl = x1
0B1195 ED 42       0679*      sbc hl,bc ; hl = dx
0B1197 22 D1 11 0B 0680*      ld (dx168),hl ; dx to scratch
0B119B             0681*  ; ; test dx for overflow
0B119B             0682*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B119B             0683*  ; 	ex de,hl
0B119B             0684*  ; 	sbc hl,de ; test for overflow
0B119B             0685*  ; 	push af ; carry indicates overflow
0B119B             0686*  ; compute dy = y1-y0
0B119B AF          0687*      xor a ; clear carry
0B119C FD E5       0688*      push iy ; move iy to hl via the stack
0B119E E1          0689*      pop hl ; hl = y1
0B119F ED 52       0690*      sbc hl,de ; hl = dy
0B11A1 22 D7 11 0B 0691*      ld (dy168),hl ; dy to scratch
0B11A5             0692*  ; ; test dy for overflow
0B11A5             0693*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B11A5             0694*  ; 	ex de,hl
0B11A5             0695*  ; 	sbc hl,de ; test for overflow
0B11A5             0696*  ; 	push af ; carry indicates overflow
0B11A5             0697*  ; compute dy^2
0B11A5 2A D7 11 0B 0698*  	ld hl,(dy168)
0B11A9 CD 78 19 0B 0699*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B11AD             0700*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B11AD E5          0701*      push hl ; load hl/2 to bc via the stack
0B11AE C1          0702*      pop bc ; bc = dy/2
0B11AF EB          0703*      ex de,hl ; de = dy/2
0B11B0 CD 91 0F 0B 0704*      call umul168 ; uh.l = dy^2/2
0B11B4 E5          0705*      push hl ; dy^2/2 to the stack
0B11B5             0706*  ; compute dx^2
0B11B5 2A D1 11 0B 0707*      ld hl,(dx168) ; get back dx
0B11B9 CD 78 19 0B 0708*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B11BD             0709*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B11BD E5          0710*      push hl ; load hl/2 to bc via the stack
0B11BE C1          0711*      pop bc ; bc = dx/2
0B11BF EB          0712*      ex de,hl ; de = dx/2
0B11C0 CD 91 0F 0B 0713*      call umul168 ; uh.l = dx^2/2
0B11C4             0714*  ; commpute dy^2+dx^2
0B11C4 D1          0715*      pop de ; get back dx^2/2
0B11C5 19          0716*      add hl,de ; hl = dx^2/2+dy^2/2
0B11C6             0717*  ; compute sqrt(dx^2/2+dy^2/2)
0B11C6 CD 8A 12 0B 0718*      call sqrt168 ; uh.l = distance/2
0B11CA             0719*      ; add hl,hl ; hl = distance
0B11CA             0720*  ; ; check for overflow
0B11CA             0721*  ; 	pop af ; get back the overflow flags
0B11CA             0722*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B11CA             0723*  ; 	ld b,a ; save the overflow flag
0B11CA             0724*  ; 	pop af ; get back the overflow flags
0B11CA             0725*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B11CA             0726*  ; 	add a,b ; if a != 0 then we had overflow
0B11CA             0727*  ;     ret z ; no overflow we're done
0B11CA             0728*  ; @overflow:
0B11CA             0729*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B11CA C9          0730*  	ret
0B11CB             0731*  @scratch: ds 6
0B11D1             0732*  dx168: ds 6
0B11D7             0733*  dy168: ds 6
0B11DD             0734*  
0B11DD             0735*  ; atan2(ub.c,ud.e) --> uh.l
0B11DD             0736*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B11DD             0737*  ;   whether inputs are integers or fractional doesn't matter
0B11DD             0738*  ;   so long as the sign bit of the upper byte is correct
0B11DD             0739*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B11DD             0740*  ; angles are COMPASS HEADINGS based on
0B11DD             0741*  ; screen coordinate conventions,where the y axis is flipped
0B11DD             0742*  ; #E0 315      0       45 #20
0B11DD             0743*  ;        -x,-y | +x,-y
0B11DD             0744*  ; #C0 270------+------ 90 #40
0B11DD             0745*  ;        -x,+y | +x,+y
0B11DD             0746*  ; #A0 225   180 #80   135 #60
0B11DD             0747*  atan2_168game:
0B11DD             0748*  ; get signs and make everything positive
0B11DD             0749*  ; get abs(x) and store its original sign
0B11DD C5          0750*      push bc
0B11DE E1          0751*      pop hl
0B11DF CD 78 19 0B 0752*      call abs_hlu ; if x was negative this also sets the sign flag
0B11E3 E5          0753*      push hl ; store abs(x)
0B11E4 C1          0754*      pop bc ; bc = abs(x)
0B11E5 F5          0755*      push af ; store sign of x
0B11E6             0756*  ; get abs(y) and store its original sign
0B11E6 EB          0757*      ex de,hl ; hl = y
0B11E7 CD 78 19 0B 0758*      call abs_hlu ; if y was negative this also sets the sign flag
0B11EB EB          0759*      ex de,hl ; de = abs(y)
0B11EC F5          0760*      push af ; store sign of y
0B11ED             0761*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B11ED             0762*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B11ED AF          0763*      xor a ; clear the carry flag
0B11EE D5          0764*      push de
0B11EF E1          0765*      pop hl
0B11F0 ED 42       0766*      sbc hl,bc
0B11F2 F5          0767*      push af ; save sign of de - bc
0B11F3 F2 FC 11 0B 0768*      jp p,@1 ; bc <= de, so we skip ahead
0B11F7             0769*  ; otherwise we swap bc and de
0B11F7 C5          0770*      push bc
0B11F8 E1          0771*      pop hl
0B11F9 EB          0772*      ex de,hl
0B11FA E5          0773*      push hl
0B11FB C1          0774*      pop bc
0B11FC             0775*  @1:
0B11FC             0776*  ; now we're ready to snag our preliminary result
0B11FC CD 6A 12 0B 0777*      call atan_168game ; uh.l comes back with prelim result
0B1200             0778*  ; now we adjust uh.l based on sign of de - bc
0B1200 F1          0779*      pop af
0B1201 F2 0D 12 0B 0780*      jp p,@2 ; bc <= de,so we skip ahead
0B1205 EB          0781*      ex de,hl
0B1206 21 00 40 00 0782*      ld hl,0x004000 ; 90 degrees
0B120A AF          0783*      xor a ; clear the carry flag
0B120B ED 52       0784*      sbc hl,de ; subtract result from 90 degrees
0B120D             0785*      ; ld de,0 ; prep to clear hlu
0B120D             0786*      ; ld d,h
0B120D             0787*      ; ld e,l
0B120D             0788*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B120D             0789*      ; fall through
0B120D             0790*  @2:
0B120D             0791*  ; now the fun part of adjusting the result
0B120D             0792*  ; based on which quadrant (x,y) is in
0B120D             0793*  ; #E0 315      0       45 #20
0B120D             0794*  ;        -x,-y | +x,-y
0B120D             0795*  ; #C0 270------+------ 90 #40
0B120D             0796*  ;        -x,+y | +x,+y
0B120D             0797*  ; #A0 225   180 #80   135 #60
0B120D F1          0798*      pop af ; sign of y
0B120E CA 4B 12 0B 0799*      jp z,@y_zero
0B1212 F2 2B 12 0B 0800*      jp p,@y_pos
0B1216             0801*  ; y neg,check x
0B1216 F1          0802*      pop af ; sign of x
0B1217 CA 25 12 0B 0803*      jp z,@y_neg_x_zero
0B121B F2 2A 12 0B 0804*      jp p,@y_neg_x_pos
0B121F             0805*  ; y neg,x neg
0B121F             0806*  ; angle is 270-360
0B121F             0807*  ; negating the intermediate does the trick
0B121F CD 88 19 0B 0808*      call neg_hlu
0B1223 18 31       0809*      jr @zero_hlu
0B1225             0810*  
0B1225             0811*  @y_neg_x_zero:
0B1225             0812*  ; y neg,x zero
0B1225             0813*  ; angle is 0
0B1225 21 00 00 00 0814*      ld hl,0
0B1229 C9          0815*      ret
0B122A             0816*  @y_neg_x_pos:
0B122A             0817*  ; y neg,x pos
0B122A             0818*  ; angle is 0 to 90
0B122A             0819*  ; so we're good
0B122A C9          0820*      ret
0B122B             0821*  
0B122B             0822*  @y_pos:
0B122B F1          0823*      pop af ; sign of x
0B122C CA 3B 12 0B 0824*      jp z,@y_pos_x_zero
0B1230 F2 40 12 0B 0825*      jp p,@y_pos_x_pos
0B1234             0826*  ; y pos,x neg
0B1234             0827*  ; angle is 180-270
0B1234             0828*  ; so we add 180 to intermediate
0B1234 11 00 80 00 0829*      ld de,0x008000
0B1238 19          0830*      add hl,de
0B1239 18 1B       0831*      jr @zero_hlu
0B123B             0832*  @y_pos_x_zero:
0B123B             0833*  ; y pos,x zero
0B123B             0834*  ; angle is 180
0B123B 21 00 80 00 0835*      ld hl,0x008000
0B123F C9          0836*      ret
0B1240             0837*  @y_pos_x_pos:
0B1240             0838*  ; y pos,x pos
0B1240             0839*  ; angle is 90-180
0B1240             0840*  ; neg the intermediate and add 180 degrees
0B1240 CD 88 19 0B 0841*      call neg_hlu
0B1244 11 00 80 00 0842*      ld de,0x008000
0B1248 19          0843*      add hl,de
0B1249 18 0B       0844*      jr @zero_hlu
0B124B             0845*  
0B124B             0846*  @y_zero:
0B124B F1          0847*      pop af ; sign of x
0B124C FA 51 12 0B 0848*      jp m,@y_zero_x_neg
0B1250             0849*  ; y zero,x pos
0B1250             0850*  ; angle is 90,nothing to do
0B1250 C9          0851*      ret
0B1251             0852*  @y_zero_x_neg:
0B1251             0853*  ; y zero ,x neg
0B1251             0854*  ; angle is 270
0B1251 21 00 C0 00 0855*      ld hl,0x00C000
0B1255 C9          0856*      ret
0B1256             0857*  @zero_hlu:
0B1256 AF          0858*      xor a
0B1257 22 64 12 0B 0859*      ld (@scratch),hl
0B125B 32 66 12 0B 0860*      ld (@scratch+2),a
0B125F 2A 64 12 0B 0861*      ld hl,(@scratch)
0B1263 C9          0862*      ret
0B1264             0863*  @scratch: ds 6
0B126A             0864*  
0B126A             0865*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B126A             0866*  ; output: uh.l is the 16.8 fixed format angle
0B126A             0867*  ; destroys: a,hl,bc,de
0B126A             0868*  ; the following note was written by github copilot:
0B126A             0869*  ; note: this routine is a bit of a hack
0B126A             0870*  ;      but it works
0B126A             0871*  ;      and it's fast
0B126A             0872*  ;      and it's small
0B126A             0873*  ;      and it's accurate
0B126A             0874*  ;      and it's easy to understand
0B126A             0875*  ;      and it's easy to modify
0B126A             0876*  ;      and it's easy to use
0B126A             0877*  ;      and it's easy to remember
0B126A             0878*  ;      and it's easy to love
0B126A             0879*  ;      and it's easy to hate
0B126A             0880*  ;      and it's easy to ignore
0B126A             0881*  ;      and it's easy to forget
0B126A             0882*  ;      and it's easy to remember
0B126A             0883*  ;      and it's easy to forget
0B126A             0884*  ;      and it's easy to remember
0B126A             0885*  ;      (ok the bot is stuck in a loop)
0B126A             0886*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B126A             0887*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B126A             0888*  atan_168game:
0B126A             0889*  ; because we use compass headings instead of geometric angles
0B126A             0890*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B126A             0891*  ; we can do faster unsigned division here because we know dx and dy are positive
0B126A CD D2 0F 0B 0892*  	call udiv168 ; uh.l = dx/dy
0B126E             0893*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B126E             0894*  ; ; test uh.l for 0
0B126E             0895*  ;     add hl,de
0B126E             0896*  ;     or a
0B126E             0897*  ;     sbc hl,de
0B126E             0898*  ;     jr z,@is_zero
0B126E             0899*  ; ; test uh.l for 1
0B126E             0900*  ;     xor a ; clear carry
0B126E             0901*  ;     ex de,hl
0B126E             0902*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B126E             0903*  ;     sbc hl,de
0B126E             0904*  ;     jr z,@is_45
0B126E             0905*  ; ; END TODO
0B126E             0906*  
0B126E             0907*  ; no special cases so we move on
0B126E             0908*  ; l contains the fractional portion of tan(uh.l)
0B126E             0909*  ; we multiply it by three to get our lookup table index
0B126E 26 03       0910*      ld h,3
0B1270 ED 6C       0911*      mlt hl ; gosh that is handy
0B1272 11 00 00 00 0912*      ld de,0 ; clear deu
0B1276 54          0913*      ld d,h ; copy hl to de
0B1277 5D          0914*      ld e,l ; de contains our index
0B1278 21 75 16 0B 0915*      ld hl,atan_lut_168 ; grab the lut address
0B127C 19          0916*      add hl,de ; bump hl by the index
0B127D ED 27       0917*      ld hl,(hl) ; don't try this on a z80!
0B127F C9          0918*      ret ; and out
0B1280             0919*  @is_45:
0B1280 21 00 20 00 0920*      ld hl,0x002000 ; 45 degrees decimal
0B1284 C9          0921*      ret
0B1285             0922*  ; for the case tan(0)
0B1285             0923*  @is_zero:
0B1285 21 00 00 00 0924*      ld hl,0x000000
0B1289 C9          0925*      ret
0B128A             0926*  
0B128A             0927*  ; Expects  ADL mode
0B128A             0928*  ; Inputs:  UH.L
0B128A             0929*  ; Outputs: UH.L is the 16.8 square root
0B128A             0930*  ;          UD.E is the difference inputHL-DE^2
0B128A             0931*  ;          c flag reset
0B128A             0932*  sqrt168:
0B128A CD 94 12 0B 0933*      call sqrt24
0B128E EB          0934*      ex de,hl
0B128F 29          0935*      add hl,hl
0B1290 29          0936*      add hl,hl
0B1291 29          0937*      add hl,hl
0B1292 29          0938*      add hl,hl
0B1293 C9          0939*      ret
0B1294             0940*  
0B1294             0941*  ; Expects  ADL mode
0B1294             0942*  ; Inputs:  HL
0B1294             0943*  ; Outputs: DE is the integer square root
0B1294             0944*  ;          HL is the difference inputHL-DE^2
0B1294             0945*  ;          c flag reset
0B1294             0946*  sqrt24:
0B1294 AF          0947*      xor a
0B1295 45          0948*      ld b,l
0B1296 C5          0949*      push bc
0B1297 47          0950*      ld b,a
0B1298 57          0951*      ld d,a
0B1299 4F          0952*      ld c,a
0B129A 6F          0953*      ld l,a
0B129B 5F          0954*      ld e,a
0B129C             0955*  
0B129C             0956*      ;Iteration 1
0B129C 29          0957*      add hl,hl
0B129D CB 11       0958*      rl c
0B129F 29          0959*      add hl,hl
0B12A0 CB 11       0960*      rl c
0B12A2 91          0961*      sub c
0B12A3 30 04       0962*      jr nc,$+6
0B12A5 1C          0963*      inc e
0B12A6 1C          0964*      inc e
0B12A7 2F          0965*      cpl
0B12A8 4F          0966*      ld c,a
0B12A9             0967*  
0B12A9             0968*      ;Iteration 2
0B12A9 29          0969*      add hl,hl
0B12AA CB 11       0970*      rl c
0B12AC 29          0971*      add hl,hl
0B12AD CB 11       0972*      rl c
0B12AF CB 13       0973*      rl e
0B12B1 7B          0974*      ld a,e
0B12B2 91          0975*      sub c
0B12B3 30 04       0976*      jr nc,$+6
0B12B5 1C          0977*      inc e
0B12B6 1C          0978*      inc e
0B12B7 2F          0979*      cpl
0B12B8 4F          0980*      ld c,a
0B12B9             0981*  
0B12B9             0982*      ;Iteration 3
0B12B9 29          0983*      add hl,hl
0B12BA CB 11       0984*      rl c
0B12BC 29          0985*      add hl,hl
0B12BD CB 11       0986*      rl c
0B12BF CB 13       0987*      rl e
0B12C1 7B          0988*      ld a,e
0B12C2 91          0989*      sub c
0B12C3 30 04       0990*      jr nc,$+6
0B12C5 1C          0991*      inc e
0B12C6 1C          0992*      inc e
0B12C7 2F          0993*      cpl
0B12C8 4F          0994*      ld c,a
0B12C9             0995*  
0B12C9             0996*      ;Iteration 4
0B12C9 29          0997*      add hl,hl
0B12CA CB 11       0998*      rl c
0B12CC 29          0999*      add hl,hl
0B12CD CB 11       1000*      rl c
0B12CF CB 13       1001*      rl e
0B12D1 7B          1002*      ld a,e
0B12D2 91          1003*      sub c
0B12D3 30 04       1004*      jr nc,$+6
0B12D5 1C          1005*      inc e
0B12D6 1C          1006*      inc e
0B12D7 2F          1007*      cpl
0B12D8 4F          1008*      ld c,a
0B12D9             1009*  
0B12D9             1010*      ;Iteration 5
0B12D9 29          1011*      add hl,hl
0B12DA CB 11       1012*      rl c
0B12DC 29          1013*      add hl,hl
0B12DD CB 11       1014*      rl c
0B12DF CB 13       1015*      rl e
0B12E1 7B          1016*      ld a,e
0B12E2 91          1017*      sub c
0B12E3 30 04       1018*      jr nc,$+6
0B12E5 1C          1019*      inc e
0B12E6 1C          1020*      inc e
0B12E7 2F          1021*      cpl
0B12E8 4F          1022*      ld c,a
0B12E9             1023*  
0B12E9             1024*      ;Iteration 6
0B12E9 29          1025*      add hl,hl
0B12EA CB 11       1026*      rl c
0B12EC 29          1027*      add hl,hl
0B12ED CB 11       1028*      rl c
0B12EF CB 13       1029*      rl e
0B12F1 7B          1030*      ld a,e
0B12F2 91          1031*      sub c
0B12F3 30 04       1032*      jr nc,$+6
0B12F5 1C          1033*      inc e
0B12F6 1C          1034*      inc e
0B12F7 2F          1035*      cpl
0B12F8 4F          1036*      ld c,a
0B12F9             1037*  
0B12F9             1038*      ;Iteration 7
0B12F9 29          1039*      add hl,hl
0B12FA CB 11       1040*      rl c
0B12FC 29          1041*      add hl,hl
0B12FD CB 11       1042*      rl c
0B12FF CB 10       1043*      rl b
0B1301 EB          1044*      ex de,hl
0B1302 29          1045*      add hl,hl
0B1303 E5          1046*      push hl
0B1304 ED 42       1047*      sbc hl,bc
0B1306 30 06       1048*      jr nc,$+8
0B1308 7C          1049*      ld a,h
0B1309 2F          1050*      cpl
0B130A 47          1051*      ld b,a
0B130B 7D          1052*      ld a,l
0B130C 2F          1053*      cpl
0B130D 4F          1054*      ld c,a
0B130E E1          1055*      pop hl
0B130F 30 02       1056*      jr nc,$+4
0B1311 23          1057*      inc hl
0B1312 23          1058*      inc hl
0B1313 EB          1059*      ex de,hl
0B1314             1060*  
0B1314             1061*      ;Iteration 8
0B1314 29          1062*      add hl,hl
0B1315 69          1063*      ld l,c
0B1316 60          1064*      ld h,b
0B1317 ED 6A       1065*      adc hl,hl
0B1319 ED 6A       1066*      adc hl,hl
0B131B EB          1067*      ex de,hl
0B131C 29          1068*      add hl,hl
0B131D ED 52       1069*      sbc hl,de
0B131F 19          1070*      add hl,de
0B1320 EB          1071*      ex de,hl
0B1321 30 04       1072*      jr nc,$+6
0B1323 ED 52       1073*      sbc hl,de
0B1325 13          1074*      inc de
0B1326 13          1075*      inc de
0B1327             1076*  
0B1327             1077*      ;Iteration 9
0B1327 F1          1078*      pop af
0B1328 17          1079*      rla
0B1329 ED 6A       1080*      adc hl,hl
0B132B 17          1081*      rla
0B132C ED 6A       1082*      adc hl,hl
0B132E EB          1083*      ex de,hl
0B132F 29          1084*      add hl,hl
0B1330 ED 52       1085*      sbc hl,de
0B1332 19          1086*      add hl,de
0B1333 EB          1087*      ex de,hl
0B1334 30 04       1088*      jr nc,$+6
0B1336 ED 52       1089*      sbc hl,de
0B1338 13          1090*      inc de
0B1339 13          1091*      inc de
0B133A             1092*  
0B133A             1093*      ;Iteration 10
0B133A 17          1094*      rla
0B133B ED 6A       1095*      adc hl,hl
0B133D 17          1096*      rla
0B133E ED 6A       1097*      adc hl,hl
0B1340 EB          1098*      ex de,hl
0B1341 29          1099*      add hl,hl
0B1342 ED 52       1100*      sbc hl,de
0B1344 19          1101*      add hl,de
0B1345 EB          1102*      ex de,hl
0B1346 30 04       1103*      jr nc,$+6
0B1348 ED 52       1104*      sbc hl,de
0B134A 13          1105*      inc de
0B134B 13          1106*      inc de
0B134C             1107*  
0B134C             1108*      ;Iteration 11
0B134C 17          1109*      rla
0B134D ED 6A       1110*      adc hl,hl
0B134F 17          1111*      rla
0B1350 ED 6A       1112*      adc hl,hl
0B1352 EB          1113*      ex de,hl
0B1353 29          1114*      add hl,hl
0B1354 ED 52       1115*      sbc hl,de
0B1356 19          1116*      add hl,de
0B1357 EB          1117*      ex de,hl
0B1358 30 04       1118*      jr nc,$+6
0B135A ED 52       1119*      sbc hl,de
0B135C 13          1120*      inc de
0B135D 13          1121*      inc de
0B135E             1122*  
0B135E             1123*      ;Iteration 11
0B135E 17          1124*      rla
0B135F ED 6A       1125*      adc hl,hl
0B1361 17          1126*      rla
0B1362 ED 6A       1127*      adc hl,hl
0B1364 EB          1128*      ex de,hl
0B1365 29          1129*      add hl,hl
0B1366 ED 52       1130*      sbc hl,de
0B1368 19          1131*      add hl,de
0B1369 EB          1132*      ex de,hl
0B136A 30 04       1133*      jr nc,$+6
0B136C ED 52       1134*      sbc hl,de
0B136E 13          1135*      inc de
0B136F 13          1136*      inc de
0B1370             1137*  
0B1370 CB 1A       1138*      rr d
0B1372 CB 1B       1139*      rr e
0B1374 C9          1140*      ret
0B1375             1141*  
0B1375             1142*  sin_lut_168:
0B1375 00 00 00    1143*  	dl 0x000000 ; 0.000 00, 0.000
0B1378 06 00 00    1144*  	dl 0x000006 ; 1.406 01, 0.025
0B137B 0C 00 00    1145*  	dl 0x00000C ; 2.813 02, 0.049
0B137E 12 00 00    1146*  	dl 0x000012 ; 4.219 03, 0.074
0B1381 19 00 00    1147*  	dl 0x000019 ; 5.625 04, 0.098
0B1384 1F 00 00    1148*  	dl 0x00001F ; 7.031 05, 0.122
0B1387 25 00 00    1149*  	dl 0x000025 ; 8.438 06, 0.147
0B138A 2B 00 00    1150*  	dl 0x00002B ; 9.844 07, 0.171
0B138D 31 00 00    1151*  	dl 0x000031 ; 11.250 08, 0.195
0B1390 38 00 00    1152*  	dl 0x000038 ; 12.656 09, 0.219
0B1393 3E 00 00    1153*  	dl 0x00003E ; 14.063 0A, 0.243
0B1396 44 00 00    1154*  	dl 0x000044 ; 15.469 0B, 0.267
0B1399 4A 00 00    1155*  	dl 0x00004A ; 16.875 0C, 0.290
0B139C 50 00 00    1156*  	dl 0x000050 ; 18.281 0D, 0.314
0B139F 56 00 00    1157*  	dl 0x000056 ; 19.688 0E, 0.337
0B13A2 5C 00 00    1158*  	dl 0x00005C ; 21.094 0F, 0.360
0B13A5 61 00 00    1159*  	dl 0x000061 ; 22.500 10, 0.383
0B13A8 67 00 00    1160*  	dl 0x000067 ; 23.906 11, 0.405
0B13AB 6D 00 00    1161*  	dl 0x00006D ; 25.313 12, 0.428
0B13AE 73 00 00    1162*  	dl 0x000073 ; 26.719 13, 0.450
0B13B1 78 00 00    1163*  	dl 0x000078 ; 28.125 14, 0.471
0B13B4 7E 00 00    1164*  	dl 0x00007E ; 29.531 15, 0.493
0B13B7 83 00 00    1165*  	dl 0x000083 ; 30.938 16, 0.514
0B13BA 88 00 00    1166*  	dl 0x000088 ; 32.344 17, 0.535
0B13BD 8E 00 00    1167*  	dl 0x00008E ; 33.750 18, 0.556
0B13C0 93 00 00    1168*  	dl 0x000093 ; 35.156 19, 0.576
0B13C3 98 00 00    1169*  	dl 0x000098 ; 36.563 1A, 0.596
0B13C6 9D 00 00    1170*  	dl 0x00009D ; 37.969 1B, 0.615
0B13C9 A2 00 00    1171*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B13CC A7 00 00    1172*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B13CF AB 00 00    1173*  	dl 0x0000AB ; 42.188 1E, 0.672
0B13D2 B0 00 00    1174*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B13D5 B5 00 00    1175*  	dl 0x0000B5 ; 45.000 20, 0.707
0B13D8 B9 00 00    1176*  	dl 0x0000B9 ; 46.406 21, 0.724
0B13DB BD 00 00    1177*  	dl 0x0000BD ; 47.813 22, 0.741
0B13DE C1 00 00    1178*  	dl 0x0000C1 ; 49.219 23, 0.757
0B13E1 C5 00 00    1179*  	dl 0x0000C5 ; 50.625 24, 0.773
0B13E4 C9 00 00    1180*  	dl 0x0000C9 ; 52.031 25, 0.788
0B13E7 CD 00 00    1181*  	dl 0x0000CD ; 53.438 26, 0.803
0B13EA D1 00 00    1182*  	dl 0x0000D1 ; 54.844 27, 0.818
0B13ED D4 00 00    1183*  	dl 0x0000D4 ; 56.250 28, 0.831
0B13F0 D8 00 00    1184*  	dl 0x0000D8 ; 57.656 29, 0.845
0B13F3 DB 00 00    1185*  	dl 0x0000DB ; 59.063 2A, 0.858
0B13F6 DE 00 00    1186*  	dl 0x0000DE ; 60.469 2B, 0.870
0B13F9 E1 00 00    1187*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B13FC E4 00 00    1188*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B13FF E7 00 00    1189*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B1402 EA 00 00    1190*  	dl 0x0000EA ; 66.094 2F, 0.914
0B1405 EC 00 00    1191*  	dl 0x0000EC ; 67.500 30, 0.924
0B1408 EE 00 00    1192*  	dl 0x0000EE ; 68.906 31, 0.933
0B140B F1 00 00    1193*  	dl 0x0000F1 ; 70.313 32, 0.942
0B140E F3 00 00    1194*  	dl 0x0000F3 ; 71.719 33, 0.950
0B1411 F4 00 00    1195*  	dl 0x0000F4 ; 73.125 34, 0.957
0B1414 F6 00 00    1196*  	dl 0x0000F6 ; 74.531 35, 0.964
0B1417 F8 00 00    1197*  	dl 0x0000F8 ; 75.938 36, 0.970
0B141A F9 00 00    1198*  	dl 0x0000F9 ; 77.344 37, 0.976
0B141D FB 00 00    1199*  	dl 0x0000FB ; 78.750 38, 0.981
0B1420 FC 00 00    1200*  	dl 0x0000FC ; 80.156 39, 0.985
0B1423 FD 00 00    1201*  	dl 0x0000FD ; 81.563 3A, 0.989
0B1426 FE 00 00    1202*  	dl 0x0000FE ; 82.969 3B, 0.992
0B1429 FE 00 00    1203*  	dl 0x0000FE ; 84.375 3C, 0.995
0B142C FF 00 00    1204*  	dl 0x0000FF ; 85.781 3D, 0.997
0B142F FF 00 00    1205*  	dl 0x0000FF ; 87.188 3E, 0.999
0B1432 FF 00 00    1206*  	dl 0x0000FF ; 88.594 3F, 1.000
0B1435 00 01 00    1207*  	dl 0x000100 ; 90.000 40, 1.000
0B1438 FF 00 00    1208*  	dl 0x0000FF ; 91.406 41, 1.000
0B143B FF 00 00    1209*  	dl 0x0000FF ; 92.813 42, 0.999
0B143E FF 00 00    1210*  	dl 0x0000FF ; 94.219 43, 0.997
0B1441 FE 00 00    1211*  	dl 0x0000FE ; 95.625 44, 0.995
0B1444 FE 00 00    1212*  	dl 0x0000FE ; 97.031 45, 0.992
0B1447 FD 00 00    1213*  	dl 0x0000FD ; 98.438 46, 0.989
0B144A FC 00 00    1214*  	dl 0x0000FC ; 99.844 47, 0.985
0B144D FB 00 00    1215*  	dl 0x0000FB ; 101.250 48, 0.981
0B1450 F9 00 00    1216*  	dl 0x0000F9 ; 102.656 49, 0.976
0B1453 F8 00 00    1217*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B1456 F6 00 00    1218*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B1459 F4 00 00    1219*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B145C F3 00 00    1220*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B145F F1 00 00    1221*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B1462 EE 00 00    1222*  	dl 0x0000EE ; 111.094 4F, 0.933
0B1465 EC 00 00    1223*  	dl 0x0000EC ; 112.500 50, 0.924
0B1468 EA 00 00    1224*  	dl 0x0000EA ; 113.906 51, 0.914
0B146B E7 00 00    1225*  	dl 0x0000E7 ; 115.313 52, 0.904
0B146E E4 00 00    1226*  	dl 0x0000E4 ; 116.719 53, 0.893
0B1471 E1 00 00    1227*  	dl 0x0000E1 ; 118.125 54, 0.882
0B1474 DE 00 00    1228*  	dl 0x0000DE ; 119.531 55, 0.870
0B1477 DB 00 00    1229*  	dl 0x0000DB ; 120.938 56, 0.858
0B147A D8 00 00    1230*  	dl 0x0000D8 ; 122.344 57, 0.845
0B147D D4 00 00    1231*  	dl 0x0000D4 ; 123.750 58, 0.831
0B1480 D1 00 00    1232*  	dl 0x0000D1 ; 125.156 59, 0.818
0B1483 CD 00 00    1233*  	dl 0x0000CD ; 126.563 5A, 0.803
0B1486 C9 00 00    1234*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B1489 C5 00 00    1235*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B148C C1 00 00    1236*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B148F BD 00 00    1237*  	dl 0x0000BD ; 132.188 5E, 0.741
0B1492 B9 00 00    1238*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B1495 B5 00 00    1239*  	dl 0x0000B5 ; 135.000 60, 0.707
0B1498 B0 00 00    1240*  	dl 0x0000B0 ; 136.406 61, 0.690
0B149B AB 00 00    1241*  	dl 0x0000AB ; 137.813 62, 0.672
0B149E A7 00 00    1242*  	dl 0x0000A7 ; 139.219 63, 0.653
0B14A1 A2 00 00    1243*  	dl 0x0000A2 ; 140.625 64, 0.634
0B14A4 9D 00 00    1244*  	dl 0x00009D ; 142.031 65, 0.615
0B14A7 98 00 00    1245*  	dl 0x000098 ; 143.438 66, 0.596
0B14AA 93 00 00    1246*  	dl 0x000093 ; 144.844 67, 0.576
0B14AD 8E 00 00    1247*  	dl 0x00008E ; 146.250 68, 0.556
0B14B0 88 00 00    1248*  	dl 0x000088 ; 147.656 69, 0.535
0B14B3 83 00 00    1249*  	dl 0x000083 ; 149.063 6A, 0.514
0B14B6 7E 00 00    1250*  	dl 0x00007E ; 150.469 6B, 0.493
0B14B9 78 00 00    1251*  	dl 0x000078 ; 151.875 6C, 0.471
0B14BC 73 00 00    1252*  	dl 0x000073 ; 153.281 6D, 0.450
0B14BF 6D 00 00    1253*  	dl 0x00006D ; 154.688 6E, 0.428
0B14C2 67 00 00    1254*  	dl 0x000067 ; 156.094 6F, 0.405
0B14C5 61 00 00    1255*  	dl 0x000061 ; 157.500 70, 0.383
0B14C8 5C 00 00    1256*  	dl 0x00005C ; 158.906 71, 0.360
0B14CB 56 00 00    1257*  	dl 0x000056 ; 160.313 72, 0.337
0B14CE 50 00 00    1258*  	dl 0x000050 ; 161.719 73, 0.314
0B14D1 4A 00 00    1259*  	dl 0x00004A ; 163.125 74, 0.290
0B14D4 44 00 00    1260*  	dl 0x000044 ; 164.531 75, 0.267
0B14D7 3E 00 00    1261*  	dl 0x00003E ; 165.938 76, 0.243
0B14DA 38 00 00    1262*  	dl 0x000038 ; 167.344 77, 0.219
0B14DD 31 00 00    1263*  	dl 0x000031 ; 168.750 78, 0.195
0B14E0 2B 00 00    1264*  	dl 0x00002B ; 170.156 79, 0.171
0B14E3 25 00 00    1265*  	dl 0x000025 ; 171.563 7A, 0.147
0B14E6 1F 00 00    1266*  	dl 0x00001F ; 172.969 7B, 0.122
0B14E9 19 00 00    1267*  	dl 0x000019 ; 174.375 7C, 0.098
0B14EC 12 00 00    1268*  	dl 0x000012 ; 175.781 7D, 0.074
0B14EF 0C 00 00    1269*  	dl 0x00000C ; 177.188 7E, 0.049
0B14F2 06 00 00    1270*  	dl 0x000006 ; 178.594 7F, 0.025
0B14F5 00 00 00    1271*  	dl 0x000000 ; 180.000 80, 0.000
0B14F8 FA FF FF    1272*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B14FB F4 FF FF    1273*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B14FE EE FF FF    1274*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B1501 E7 FF FF    1275*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B1504 E1 FF FF    1276*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B1507 DB FF FF    1277*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B150A D5 FF FF    1278*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B150D CF FF FF    1279*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B1510 C8 FF FF    1280*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B1513 C2 FF FF    1281*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B1516 BC FF FF    1282*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B1519 B6 FF FF    1283*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B151C B0 FF FF    1284*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B151F AA FF FF    1285*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B1522 A4 FF FF    1286*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B1525 9F FF FF    1287*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B1528 99 FF FF    1288*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B152B 93 FF FF    1289*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B152E 8D FF FF    1290*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B1531 88 FF FF    1291*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B1534 82 FF FF    1292*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B1537 7D FF FF    1293*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B153A 78 FF FF    1294*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B153D 72 FF FF    1295*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B1540 6D FF FF    1296*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B1543 68 FF FF    1297*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B1546 63 FF FF    1298*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B1549 5E FF FF    1299*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B154C 59 FF FF    1300*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B154F 55 FF FF    1301*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B1552 50 FF FF    1302*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B1555 4B FF FF    1303*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B1558 47 FF FF    1304*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B155B 43 FF FF    1305*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B155E 3F FF FF    1306*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B1561 3B FF FF    1307*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B1564 37 FF FF    1308*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B1567 33 FF FF    1309*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B156A 2F FF FF    1310*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B156D 2C FF FF    1311*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B1570 28 FF FF    1312*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B1573 25 FF FF    1313*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B1576 22 FF FF    1314*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B1579 1F FF FF    1315*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B157C 1C FF FF    1316*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B157F 19 FF FF    1317*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B1582 16 FF FF    1318*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B1585 14 FF FF    1319*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B1588 12 FF FF    1320*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B158B 0F FF FF    1321*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B158E 0D FF FF    1322*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B1591 0C FF FF    1323*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B1594 0A FF FF    1324*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B1597 08 FF FF    1325*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B159A 07 FF FF    1326*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B159D 05 FF FF    1327*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B15A0 04 FF FF    1328*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B15A3 03 FF FF    1329*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B15A6 02 FF FF    1330*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B15A9 02 FF FF    1331*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B15AC 01 FF FF    1332*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B15AF 01 FF FF    1333*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B15B2 01 FF FF    1334*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B15B5 00 FF FF    1335*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B15B8 01 FF FF    1336*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B15BB 01 FF FF    1337*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B15BE 01 FF FF    1338*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B15C1 02 FF FF    1339*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B15C4 02 FF FF    1340*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B15C7 03 FF FF    1341*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B15CA 04 FF FF    1342*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B15CD 05 FF FF    1343*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B15D0 07 FF FF    1344*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B15D3 08 FF FF    1345*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B15D6 0A FF FF    1346*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B15D9 0C FF FF    1347*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B15DC 0D FF FF    1348*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B15DF 0F FF FF    1349*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B15E2 12 FF FF    1350*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B15E5 14 FF FF    1351*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B15E8 16 FF FF    1352*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B15EB 19 FF FF    1353*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B15EE 1C FF FF    1354*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B15F1 1F FF FF    1355*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B15F4 22 FF FF    1356*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B15F7 25 FF FF    1357*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B15FA 28 FF FF    1358*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B15FD 2C FF FF    1359*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B1600 2F FF FF    1360*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B1603 33 FF FF    1361*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B1606 37 FF FF    1362*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B1609 3B FF FF    1363*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B160C 3F FF FF    1364*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B160F 43 FF FF    1365*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B1612 47 FF FF    1366*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B1615 4B FF FF    1367*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B1618 50 FF FF    1368*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B161B 55 FF FF    1369*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B161E 59 FF FF    1370*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1621 5E FF FF    1371*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B1624 63 FF FF    1372*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B1627 68 FF FF    1373*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B162A 6D FF FF    1374*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B162D 72 FF FF    1375*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1630 78 FF FF    1376*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B1633 7D FF FF    1377*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B1636 82 FF FF    1378*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B1639 88 FF FF    1379*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B163C 8D FF FF    1380*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B163F 93 FF FF    1381*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B1642 99 FF FF    1382*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B1645 9F FF FF    1383*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B1648 A4 FF FF    1384*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B164B AA FF FF    1385*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B164E B0 FF FF    1386*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B1651 B6 FF FF    1387*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B1654 BC FF FF    1388*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B1657 C2 FF FF    1389*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B165A C8 FF FF    1390*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B165D CF FF FF    1391*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B1660 D5 FF FF    1392*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B1663 DB FF FF    1393*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B1666 E1 FF FF    1394*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B1669 E7 FF FF    1395*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B166C EE FF FF    1396*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B166F F4 FF FF    1397*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B1672 FA FF FF    1398*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B1675             1399*  
0B1675             1400*  atan_lut_168:
0B1675 00 00 00    1401*  	dl 0x000000 ; 000000, 0.000
0B1678 28 00 00    1402*  	dl 0x000028 ; 000001, 0.224
0B167B 51 00 00    1403*  	dl 0x000051 ; 000002, 0.448
0B167E 7A 00 00    1404*  	dl 0x00007A ; 000003, 0.671
0B1681 A2 00 00    1405*  	dl 0x0000A2 ; 000004, 0.895
0B1684 CB 00 00    1406*  	dl 0x0000CB ; 000005, 1.119
0B1687 F4 00 00    1407*  	dl 0x0000F4 ; 000006, 1.343
0B168A 1D 01 00    1408*  	dl 0x00011D ; 000007, 1.566
0B168D 45 01 00    1409*  	dl 0x000145 ; 000008, 1.790
0B1690 6E 01 00    1410*  	dl 0x00016E ; 000009, 2.013
0B1693 97 01 00    1411*  	dl 0x000197 ; 00000A, 2.237
0B1696 BF 01 00    1412*  	dl 0x0001BF ; 00000B, 2.460
0B1699 E8 01 00    1413*  	dl 0x0001E8 ; 00000C, 2.684
0B169C 11 02 00    1414*  	dl 0x000211 ; 00000D, 2.907
0B169F 39 02 00    1415*  	dl 0x000239 ; 00000E, 3.130
0B16A2 62 02 00    1416*  	dl 0x000262 ; 00000F, 3.353
0B16A5 8B 02 00    1417*  	dl 0x00028B ; 000010, 3.576
0B16A8 B3 02 00    1418*  	dl 0x0002B3 ; 000011, 3.799
0B16AB DC 02 00    1419*  	dl 0x0002DC ; 000012, 4.022
0B16AE 04 03 00    1420*  	dl 0x000304 ; 000013, 4.245
0B16B1 2D 03 00    1421*  	dl 0x00032D ; 000014, 4.467
0B16B4 55 03 00    1422*  	dl 0x000355 ; 000015, 4.690
0B16B7 7E 03 00    1423*  	dl 0x00037E ; 000016, 4.912
0B16BA A6 03 00    1424*  	dl 0x0003A6 ; 000017, 5.134
0B16BD CE 03 00    1425*  	dl 0x0003CE ; 000018, 5.356
0B16C0 F7 03 00    1426*  	dl 0x0003F7 ; 000019, 5.578
0B16C3 1F 04 00    1427*  	dl 0x00041F ; 00001A, 5.799
0B16C6 48 04 00    1428*  	dl 0x000448 ; 00001B, 6.021
0B16C9 70 04 00    1429*  	dl 0x000470 ; 00001C, 6.242
0B16CC 98 04 00    1430*  	dl 0x000498 ; 00001D, 6.463
0B16CF C0 04 00    1431*  	dl 0x0004C0 ; 00001E, 6.684
0B16D2 E8 04 00    1432*  	dl 0x0004E8 ; 00001F, 6.905
0B16D5 11 05 00    1433*  	dl 0x000511 ; 000020, 7.125
0B16D8 39 05 00    1434*  	dl 0x000539 ; 000021, 7.345
0B16DB 61 05 00    1435*  	dl 0x000561 ; 000022, 7.565
0B16DE 89 05 00    1436*  	dl 0x000589 ; 000023, 7.785
0B16E1 B1 05 00    1437*  	dl 0x0005B1 ; 000024, 8.005
0B16E4 D9 05 00    1438*  	dl 0x0005D9 ; 000025, 8.224
0B16E7 01 06 00    1439*  	dl 0x000601 ; 000026, 8.443
0B16EA 28 06 00    1440*  	dl 0x000628 ; 000027, 8.662
0B16ED 50 06 00    1441*  	dl 0x000650 ; 000028, 8.881
0B16F0 78 06 00    1442*  	dl 0x000678 ; 000029, 9.099
0B16F3 A0 06 00    1443*  	dl 0x0006A0 ; 00002A, 9.317
0B16F6 C7 06 00    1444*  	dl 0x0006C7 ; 00002B, 9.535
0B16F9 EF 06 00    1445*  	dl 0x0006EF ; 00002C, 9.752
0B16FC 16 07 00    1446*  	dl 0x000716 ; 00002D, 9.970
0B16FF 3E 07 00    1447*  	dl 0x00073E ; 00002E, 10.187
0B1702 65 07 00    1448*  	dl 0x000765 ; 00002F, 10.403
0B1705 8D 07 00    1449*  	dl 0x00078D ; 000030, 10.620
0B1708 B4 07 00    1450*  	dl 0x0007B4 ; 000031, 10.836
0B170B DB 07 00    1451*  	dl 0x0007DB ; 000032, 11.051
0B170E 03 08 00    1452*  	dl 0x000803 ; 000033, 11.267
0B1711 2A 08 00    1453*  	dl 0x00082A ; 000034, 11.482
0B1714 51 08 00    1454*  	dl 0x000851 ; 000035, 11.697
0B1717 78 08 00    1455*  	dl 0x000878 ; 000036, 11.911
0B171A 9F 08 00    1456*  	dl 0x00089F ; 000037, 12.125
0B171D C6 08 00    1457*  	dl 0x0008C6 ; 000038, 12.339
0B1720 ED 08 00    1458*  	dl 0x0008ED ; 000039, 12.553
0B1723 13 09 00    1459*  	dl 0x000913 ; 00003A, 12.766
0B1726 3A 09 00    1460*  	dl 0x00093A ; 00003B, 12.978
0B1729 61 09 00    1461*  	dl 0x000961 ; 00003C, 13.191
0B172C 87 09 00    1462*  	dl 0x000987 ; 00003D, 13.403
0B172F AE 09 00    1463*  	dl 0x0009AE ; 00003E, 13.614
0B1732 D4 09 00    1464*  	dl 0x0009D4 ; 00003F, 13.825
0B1735 FB 09 00    1465*  	dl 0x0009FB ; 000040, 14.036
0B1738 21 0A 00    1466*  	dl 0x000A21 ; 000041, 14.247
0B173B 47 0A 00    1467*  	dl 0x000A47 ; 000042, 14.457
0B173E 6D 0A 00    1468*  	dl 0x000A6D ; 000043, 14.666
0B1741 94 0A 00    1469*  	dl 0x000A94 ; 000044, 14.876
0B1744 BA 0A 00    1470*  	dl 0x000ABA ; 000045, 15.085
0B1747 E0 0A 00    1471*  	dl 0x000AE0 ; 000046, 15.293
0B174A 05 0B 00    1472*  	dl 0x000B05 ; 000047, 15.501
0B174D 2B 0B 00    1473*  	dl 0x000B2B ; 000048, 15.709
0B1750 51 0B 00    1474*  	dl 0x000B51 ; 000049, 15.916
0B1753 77 0B 00    1475*  	dl 0x000B77 ; 00004A, 16.123
0B1756 9C 0B 00    1476*  	dl 0x000B9C ; 00004B, 16.329
0B1759 C2 0B 00    1477*  	dl 0x000BC2 ; 00004C, 16.535
0B175C E7 0B 00    1478*  	dl 0x000BE7 ; 00004D, 16.740
0B175F 0C 0C 00    1479*  	dl 0x000C0C ; 00004E, 16.945
0B1762 32 0C 00    1480*  	dl 0x000C32 ; 00004F, 17.150
0B1765 57 0C 00    1481*  	dl 0x000C57 ; 000050, 17.354
0B1768 7C 0C 00    1482*  	dl 0x000C7C ; 000051, 17.558
0B176B A1 0C 00    1483*  	dl 0x000CA1 ; 000052, 17.761
0B176E C6 0C 00    1484*  	dl 0x000CC6 ; 000053, 17.964
0B1771 EB 0C 00    1485*  	dl 0x000CEB ; 000054, 18.166
0B1774 0F 0D 00    1486*  	dl 0x000D0F ; 000055, 18.368
0B1777 34 0D 00    1487*  	dl 0x000D34 ; 000056, 18.569
0B177A 58 0D 00    1488*  	dl 0x000D58 ; 000057, 18.770
0B177D 7D 0D 00    1489*  	dl 0x000D7D ; 000058, 18.970
0B1780 A1 0D 00    1490*  	dl 0x000DA1 ; 000059, 19.170
0B1783 C6 0D 00    1491*  	dl 0x000DC6 ; 00005A, 19.370
0B1786 EA 0D 00    1492*  	dl 0x000DEA ; 00005B, 19.569
0B1789 0E 0E 00    1493*  	dl 0x000E0E ; 00005C, 19.767
0B178C 32 0E 00    1494*  	dl 0x000E32 ; 00005D, 19.965
0B178F 56 0E 00    1495*  	dl 0x000E56 ; 00005E, 20.163
0B1792 7A 0E 00    1496*  	dl 0x000E7A ; 00005F, 20.360
0B1795 9E 0E 00    1497*  	dl 0x000E9E ; 000060, 20.556
0B1798 C1 0E 00    1498*  	dl 0x000EC1 ; 000061, 20.752
0B179B E5 0E 00    1499*  	dl 0x000EE5 ; 000062, 20.947
0B179E 08 0F 00    1500*  	dl 0x000F08 ; 000063, 21.142
0B17A1 2C 0F 00    1501*  	dl 0x000F2C ; 000064, 21.337
0B17A4 4F 0F 00    1502*  	dl 0x000F4F ; 000065, 21.531
0B17A7 72 0F 00    1503*  	dl 0x000F72 ; 000066, 21.724
0B17AA 95 0F 00    1504*  	dl 0x000F95 ; 000067, 21.917
0B17AD B8 0F 00    1505*  	dl 0x000FB8 ; 000068, 22.109
0B17B0 DB 0F 00    1506*  	dl 0x000FDB ; 000069, 22.301
0B17B3 FE 0F 00    1507*  	dl 0x000FFE ; 00006A, 22.493
0B17B6 21 10 00    1508*  	dl 0x001021 ; 00006B, 22.683
0B17B9 44 10 00    1509*  	dl 0x001044 ; 00006C, 22.874
0B17BC 66 10 00    1510*  	dl 0x001066 ; 00006D, 23.063
0B17BF 89 10 00    1511*  	dl 0x001089 ; 00006E, 23.253
0B17C2 AB 10 00    1512*  	dl 0x0010AB ; 00006F, 23.441
0B17C5 CD 10 00    1513*  	dl 0x0010CD ; 000070, 23.629
0B17C8 EF 10 00    1514*  	dl 0x0010EF ; 000071, 23.817
0B17CB 11 11 00    1515*  	dl 0x001111 ; 000072, 24.004
0B17CE 33 11 00    1516*  	dl 0x001133 ; 000073, 24.191
0B17D1 55 11 00    1517*  	dl 0x001155 ; 000074, 24.376
0B17D4 77 11 00    1518*  	dl 0x001177 ; 000075, 24.562
0B17D7 99 11 00    1519*  	dl 0x001199 ; 000076, 24.747
0B17DA BA 11 00    1520*  	dl 0x0011BA ; 000077, 24.931
0B17DD DC 11 00    1521*  	dl 0x0011DC ; 000078, 25.115
0B17E0 FD 11 00    1522*  	dl 0x0011FD ; 000079, 25.298
0B17E3 1E 12 00    1523*  	dl 0x00121E ; 00007A, 25.481
0B17E6 3F 12 00    1524*  	dl 0x00123F ; 00007B, 25.663
0B17E9 60 12 00    1525*  	dl 0x001260 ; 00007C, 25.844
0B17EC 81 12 00    1526*  	dl 0x001281 ; 00007D, 26.025
0B17EF A2 12 00    1527*  	dl 0x0012A2 ; 00007E, 26.206
0B17F2 C3 12 00    1528*  	dl 0x0012C3 ; 00007F, 26.386
0B17F5 E4 12 00    1529*  	dl 0x0012E4 ; 000080, 26.565
0B17F8 04 13 00    1530*  	dl 0x001304 ; 000081, 26.744
0B17FB 25 13 00    1531*  	dl 0x001325 ; 000082, 26.922
0B17FE 45 13 00    1532*  	dl 0x001345 ; 000083, 27.100
0B1801 65 13 00    1533*  	dl 0x001365 ; 000084, 27.277
0B1804 85 13 00    1534*  	dl 0x001385 ; 000085, 27.453
0B1807 A5 13 00    1535*  	dl 0x0013A5 ; 000086, 27.629
0B180A C5 13 00    1536*  	dl 0x0013C5 ; 000087, 27.805
0B180D E5 13 00    1537*  	dl 0x0013E5 ; 000088, 27.979
0B1810 05 14 00    1538*  	dl 0x001405 ; 000089, 28.154
0B1813 24 14 00    1539*  	dl 0x001424 ; 00008A, 28.327
0B1816 44 14 00    1540*  	dl 0x001444 ; 00008B, 28.501
0B1819 63 14 00    1541*  	dl 0x001463 ; 00008C, 28.673
0B181C 83 14 00    1542*  	dl 0x001483 ; 00008D, 28.845
0B181F A2 14 00    1543*  	dl 0x0014A2 ; 00008E, 29.017
0B1822 C1 14 00    1544*  	dl 0x0014C1 ; 00008F, 29.187
0B1825 E0 14 00    1545*  	dl 0x0014E0 ; 000090, 29.358
0B1828 FF 14 00    1546*  	dl 0x0014FF ; 000091, 29.527
0B182B 1E 15 00    1547*  	dl 0x00151E ; 000092, 29.697
0B182E 3C 15 00    1548*  	dl 0x00153C ; 000093, 29.865
0B1831 5B 15 00    1549*  	dl 0x00155B ; 000094, 30.033
0B1834 79 15 00    1550*  	dl 0x001579 ; 000095, 30.201
0B1837 98 15 00    1551*  	dl 0x001598 ; 000096, 30.368
0B183A B6 15 00    1552*  	dl 0x0015B6 ; 000097, 30.534
0B183D D4 15 00    1553*  	dl 0x0015D4 ; 000098, 30.700
0B1840 F2 15 00    1554*  	dl 0x0015F2 ; 000099, 30.865
0B1843 10 16 00    1555*  	dl 0x001610 ; 00009A, 31.030
0B1846 2E 16 00    1556*  	dl 0x00162E ; 00009B, 31.194
0B1849 4C 16 00    1557*  	dl 0x00164C ; 00009C, 31.357
0B184C 6A 16 00    1558*  	dl 0x00166A ; 00009D, 31.520
0B184F 87 16 00    1559*  	dl 0x001687 ; 00009E, 31.682
0B1852 A5 16 00    1560*  	dl 0x0016A5 ; 00009F, 31.844
0B1855 C2 16 00    1561*  	dl 0x0016C2 ; 0000A0, 32.005
0B1858 DF 16 00    1562*  	dl 0x0016DF ; 0000A1, 32.166
0B185B FC 16 00    1563*  	dl 0x0016FC ; 0000A2, 32.326
0B185E 19 17 00    1564*  	dl 0x001719 ; 0000A3, 32.486
0B1861 36 17 00    1565*  	dl 0x001736 ; 0000A4, 32.645
0B1864 53 17 00    1566*  	dl 0x001753 ; 0000A5, 32.803
0B1867 70 17 00    1567*  	dl 0x001770 ; 0000A6, 32.961
0B186A 8C 17 00    1568*  	dl 0x00178C ; 0000A7, 33.118
0B186D A9 17 00    1569*  	dl 0x0017A9 ; 0000A8, 33.275
0B1870 C5 17 00    1570*  	dl 0x0017C5 ; 0000A9, 33.431
0B1873 E2 17 00    1571*  	dl 0x0017E2 ; 0000AA, 33.587
0B1876 FE 17 00    1572*  	dl 0x0017FE ; 0000AB, 33.742
0B1879 1A 18 00    1573*  	dl 0x00181A ; 0000AC, 33.896
0B187C 36 18 00    1574*  	dl 0x001836 ; 0000AD, 34.050
0B187F 52 18 00    1575*  	dl 0x001852 ; 0000AE, 34.203
0B1882 6E 18 00    1576*  	dl 0x00186E ; 0000AF, 34.356
0B1885 8A 18 00    1577*  	dl 0x00188A ; 0000B0, 34.509
0B1888 A5 18 00    1578*  	dl 0x0018A5 ; 0000B1, 34.660
0B188B C1 18 00    1579*  	dl 0x0018C1 ; 0000B2, 34.811
0B188E DC 18 00    1580*  	dl 0x0018DC ; 0000B3, 34.962
0B1891 F7 18 00    1581*  	dl 0x0018F7 ; 0000B4, 35.112
0B1894 13 19 00    1582*  	dl 0x001913 ; 0000B5, 35.262
0B1897 2E 19 00    1583*  	dl 0x00192E ; 0000B6, 35.410
0B189A 49 19 00    1584*  	dl 0x001949 ; 0000B7, 35.559
0B189D 64 19 00    1585*  	dl 0x001964 ; 0000B8, 35.707
0B18A0 7F 19 00    1586*  	dl 0x00197F ; 0000B9, 35.854
0B18A3 99 19 00    1587*  	dl 0x001999 ; 0000BA, 36.001
0B18A6 B4 19 00    1588*  	dl 0x0019B4 ; 0000BB, 36.147
0B18A9 CE 19 00    1589*  	dl 0x0019CE ; 0000BC, 36.293
0B18AC E9 19 00    1590*  	dl 0x0019E9 ; 0000BD, 36.438
0B18AF 03 1A 00    1591*  	dl 0x001A03 ; 0000BE, 36.582
0B18B2 1D 1A 00    1592*  	dl 0x001A1D ; 0000BF, 36.726
0B18B5 37 1A 00    1593*  	dl 0x001A37 ; 0000C0, 36.870
0B18B8 51 1A 00    1594*  	dl 0x001A51 ; 0000C1, 37.013
0B18BB 6B 1A 00    1595*  	dl 0x001A6B ; 0000C2, 37.155
0B18BE 85 1A 00    1596*  	dl 0x001A85 ; 0000C3, 37.297
0B18C1 9F 1A 00    1597*  	dl 0x001A9F ; 0000C4, 37.439
0B18C4 B9 1A 00    1598*  	dl 0x001AB9 ; 0000C5, 37.579
0B18C7 D2 1A 00    1599*  	dl 0x001AD2 ; 0000C6, 37.720
0B18CA EC 1A 00    1600*  	dl 0x001AEC ; 0000C7, 37.859
0B18CD 05 1B 00    1601*  	dl 0x001B05 ; 0000C8, 37.999
0B18D0 1E 1B 00    1602*  	dl 0x001B1E ; 0000C9, 38.137
0B18D3 37 1B 00    1603*  	dl 0x001B37 ; 0000CA, 38.276
0B18D6 50 1B 00    1604*  	dl 0x001B50 ; 0000CB, 38.413
0B18D9 69 1B 00    1605*  	dl 0x001B69 ; 0000CC, 38.550
0B18DC 82 1B 00    1606*  	dl 0x001B82 ; 0000CD, 38.687
0B18DF 9B 1B 00    1607*  	dl 0x001B9B ; 0000CE, 38.823
0B18E2 B4 1B 00    1608*  	dl 0x001BB4 ; 0000CF, 38.959
0B18E5 CC 1B 00    1609*  	dl 0x001BCC ; 0000D0, 39.094
0B18E8 E5 1B 00    1610*  	dl 0x001BE5 ; 0000D1, 39.228
0B18EB FD 1B 00    1611*  	dl 0x001BFD ; 0000D2, 39.362
0B18EE 16 1C 00    1612*  	dl 0x001C16 ; 0000D3, 39.496
0B18F1 2E 1C 00    1613*  	dl 0x001C2E ; 0000D4, 39.629
0B18F4 46 1C 00    1614*  	dl 0x001C46 ; 0000D5, 39.762
0B18F7 5E 1C 00    1615*  	dl 0x001C5E ; 0000D6, 39.894
0B18FA 76 1C 00    1616*  	dl 0x001C76 ; 0000D7, 40.025
0B18FD 8E 1C 00    1617*  	dl 0x001C8E ; 0000D8, 40.156
0B1900 A5 1C 00    1618*  	dl 0x001CA5 ; 0000D9, 40.286
0B1903 BD 1C 00    1619*  	dl 0x001CBD ; 0000DA, 40.416
0B1906 D5 1C 00    1620*  	dl 0x001CD5 ; 0000DB, 40.546
0B1909 EC 1C 00    1621*  	dl 0x001CEC ; 0000DC, 40.675
0B190C 04 1D 00    1622*  	dl 0x001D04 ; 0000DD, 40.803
0B190F 1B 1D 00    1623*  	dl 0x001D1B ; 0000DE, 40.931
0B1912 32 1D 00    1624*  	dl 0x001D32 ; 0000DF, 41.059
0B1915 49 1D 00    1625*  	dl 0x001D49 ; 0000E0, 41.186
0B1918 60 1D 00    1626*  	dl 0x001D60 ; 0000E1, 41.312
0B191B 77 1D 00    1627*  	dl 0x001D77 ; 0000E2, 41.438
0B191E 8E 1D 00    1628*  	dl 0x001D8E ; 0000E3, 41.564
0B1921 A5 1D 00    1629*  	dl 0x001DA5 ; 0000E4, 41.689
0B1924 BB 1D 00    1630*  	dl 0x001DBB ; 0000E5, 41.814
0B1927 D2 1D 00    1631*  	dl 0x001DD2 ; 0000E6, 41.938
0B192A E9 1D 00    1632*  	dl 0x001DE9 ; 0000E7, 42.061
0B192D FF 1D 00    1633*  	dl 0x001DFF ; 0000E8, 42.184
0B1930 15 1E 00    1634*  	dl 0x001E15 ; 0000E9, 42.307
0B1933 2C 1E 00    1635*  	dl 0x001E2C ; 0000EA, 42.429
0B1936 42 1E 00    1636*  	dl 0x001E42 ; 0000EB, 42.551
0B1939 58 1E 00    1637*  	dl 0x001E58 ; 0000EC, 42.672
0B193C 6E 1E 00    1638*  	dl 0x001E6E ; 0000ED, 42.793
0B193F 84 1E 00    1639*  	dl 0x001E84 ; 0000EE, 42.913
0B1942 99 1E 00    1640*  	dl 0x001E99 ; 0000EF, 43.033
0B1945 AF 1E 00    1641*  	dl 0x001EAF ; 0000F0, 43.152
0B1948 C5 1E 00    1642*  	dl 0x001EC5 ; 0000F1, 43.271
0B194B DA 1E 00    1643*  	dl 0x001EDA ; 0000F2, 43.390
0B194E F0 1E 00    1644*  	dl 0x001EF0 ; 0000F3, 43.508
0B1951 05 1F 00    1645*  	dl 0x001F05 ; 0000F4, 43.625
0B1954 1B 1F 00    1646*  	dl 0x001F1B ; 0000F5, 43.742
0B1957 30 1F 00    1647*  	dl 0x001F30 ; 0000F6, 43.859
0B195A 45 1F 00    1648*  	dl 0x001F45 ; 0000F7, 43.975
0B195D 5A 1F 00    1649*  	dl 0x001F5A ; 0000F8, 44.091
0B1960 6F 1F 00    1650*  	dl 0x001F6F ; 0000F9, 44.206
0B1963 84 1F 00    1651*  	dl 0x001F84 ; 0000FA, 44.321
0B1966 99 1F 00    1652*  	dl 0x001F99 ; 0000FB, 44.435
0B1969 AD 1F 00    1653*  	dl 0x001FAD ; 0000FC, 44.549
0B196C C2 1F 00    1654*  	dl 0x001FC2 ; 0000FD, 44.662
0B196F D7 1F 00    1655*  	dl 0x001FD7 ; 0000FE, 44.775
0B1972 EB 1F 00    1656*  	dl 0x001FEB ; 0000FF, 44.888
0B1975 00 20 00    1657*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B1978             1658*  
0B1978             1659*  ; ---------------------------------------------------------
0B1978             1660*  ; BEGIN HELPER ROUTINES
0B1978             1661*  ; ---------------------------------------------------------
0B1978             1662*  ;
0B1978             1663*  ; absolute value of hlu
0B1978             1664*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B1978             1665*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B1978             1666*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B1978             1667*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B1978             1668*  ; destroys: a
0B1978             1669*  abs_hlu:
0B1978 19          1670*      add hl,de
0B1979 B7          1671*      or a
0B197A ED 52       1672*      sbc hl,de
0B197C FA 81 19 0B 1673*      jp m,@is_neg
0B1980 C9          1674*      ret         ; hlu is positive or zero so we're done
0B1981             1675*  @is_neg:
0B1981 F5          1676*      push af     ; otherwise, save current flags for return
0B1982 CD 88 19 0B 1677*      call neg_hlu ; negate hlu
0B1986 F1          1678*      pop af      ; get back flags
0B1987 C9          1679*      ret
0B1988             1680*  
0B1988             1681*  ; flip the sign of hlu
0B1988             1682*  ; inputs: hlu
0B1988             1683*  ; returns: 0-hlu, flags set appropriately for the result:
0B1988             1684*  ;         s1,z0,pv0,n1,c1 if result is negative
0B1988             1685*  ;         s0,z1,pv0,n1,c0 if result is zero
0B1988             1686*  ;         s0,z0,pv0,n1,c1 if result is positive
0B1988             1687*  ; destroys a
0B1988             1688*  neg_hlu:
0B1988 D5          1689*      push de     ; save de
0B1989 EB          1690*      ex de,hl    ; put hl into de
0B198A 21 00 00 00 1691*      ld hl,0     ; clear hl
0B198E AF          1692*      xor a       ; clear carry
0B198F ED 52       1693*      sbc hl,de   ; 0-hlu = -hlu
0B1991 D1          1694*      pop de      ; get de back
0B1992 C9          1695*      ret         ; easy peasy
0B1993             1696*  
0B1993             1697*  ;------------------------------------------------------------------------
0B1993             1698*  ; divide hlu by 2, inspired by above
0B1993             1699*  ;------------------------------------------------------------------------
0B1993             1700*  hlu_div2:
0B1993 22 BE 10 0B 1701*  	ld		(bitbuf1),hl
0B1997 21 C0 10 0B 1702*  	ld		hl,bitbuf1+2
0B199B CB 1E       1703*  	rr		(hl)
0B199D 2B          1704*  	dec		hl
0B199E CB 1E       1705*  	rr		(hl)
0B19A0 2B          1706*  	dec		hl
0B19A1 CB 1E       1707*  	rr		(hl)
0B19A3 23          1708*  	inc		hl
0B19A4 23          1709*  	inc		hl
0B19A5 2A BE 10 0B 1710*      ld hl,(bitbuf1)
0B19A9 C9          1711*      ret
0B19AA             1712*  
0B19AA             1713*  ; this is my little hack to divide by 16
0B19AA             1714*  hlu_div16:
0B19AA AF          1715*      xor a
0B19AB 29          1716*      add hl,hl
0B19AC 17          1717*      rla
0B19AD 29          1718*      add hl,hl
0B19AE 17          1719*      rla
0B19AF 29          1720*      add hl,hl
0B19B0 17          1721*      rla
0B19B1 29          1722*      add hl,hl
0B19B2 17          1723*      rla
0B19B3 22 C0 19 0B 1724*      ld (@scratch),hl
0B19B7 32 C3 19 0B 1725*      ld (@scratch+3),a
0B19BB 2A C1 19 0B 1726*      ld hl,(@scratch+1)
0B19BF C9          1727*      ret
0B19C0             1728*  @scratch: ds 4
0B19C4             0029   
0B19C4             0030   ; APPLICATION INCLUDES
0B19C4 55 73 61 67 0031   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B19DC 45 72 72 6F 0032   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B19E5 53 75 63 63 0033   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B19F0             0034   
0B19F0             0035   ; This is a scratch moslet for testing new features
0B19F0             0036   ; Parameters:
0B19F0             0037   ;
0B19F0             0038   
0B19F0             0039   ; ========= BOILERPLATE MAIN LOOP =========
0B19F0             0040   ; The main routine
0B19F0             0041   ; IXU: argv - pointer to array of parameters
0B19F0             0042   ;   C: argc - number of parameters
0B19F0             0043   ; Returns:
0B19F0             0044   ;  HL: Error code, or 0 if OK
0B19F0             0045   
0B19F0             0046   min_args: equ 2
0B19F0             0047   
0B19F0             0048   _main:
0B19F0 79          0049       ld a,c              ; how many arguments?
0B19F1 FE 02       0050       cp min_args         ; not enough?
0B19F3 30 1A       0051       jr nc,main          ; if enough, go to main loop
0B19F5 21 C4 19 0B 0052       ld hl,str_usage     ; if not enough, print usage
0B19F9 CD 77 02 0B 0053       call printString
0B19FD             0054                           ; fall through to _main_end_error
0B19FD             0055   
0B19FD             0056   _main_end_error:
0B19FD 21 DC 19 0B 0057       ld hl,str_error     ; print error message
0B1A01 CD 77 02 0B 0058       call printString
0B1A05 21 13 00 00 0059       ld hl,19            ; return error code 19
0B1A09 C9          0060       ret
0B1A0A             0061   
0B1A0A             0062   _main_end_ok:
0B1A0A             0063       ; ld hl,str_success   ; print success message
0B1A0A             0064       ; call printString
0B1A0A 21 00 00 00 0065       ld hl,0             ; return 0 for success
0B1A0E C9          0066       ret
0B1A0F             0067   
0B1A0F             0068   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B1A0F             0069   main:
0B1A0F 0D          0070       dec c               ; decrement the argument count to skip the program name
0B1A10             0071   
0B1A10             0072   test_umul24x24:
0B1A10 CD D5 1A 0B 0073       call get_arg_s24
0B1A14 D5          0074       push de
0B1A15 CD D5 1A 0B 0075       call get_arg_s24
0B1A19 E1          0076       pop hl
0B1A1A             0077   
0B1A1A CD 5A 05 0B 0078       call dumpRegistersHex
0B1A1E CD B3 0E 0B 0079       call umul24x24
0B1A22             0080   
0B1A22 2A 0E 0F 0B 0081       ld hl,(umul24x24out+3)
0B1A26 CD D4 02 0B 0082       call printHexUHL
0B1A2A             0083   
0B1A2A 2A 0B 0F 0B 0084       ld hl,(umul24x24out+0)
0B1A2E CD D4 02 0B 0085       call printHexUHL
0B1A32 CD 8C 02 0B 0086       call printNewLine
0B1A36             0087   
0B1A36 C3 0A 1A 0B 0088       jp _main_end_ok
0B1A3A             0089   
0B1A3A             0090   test_umul24x8:
0B1A3A             0091   ; 24-bit argument to BHL
0B1A3A CD D5 1A 0B 0092       call get_arg_s24
0B1A3E EB          0093       ex de,hl
0B1A3F             0094       HLU_TO_A
0B1A3F E5          0001M          push hl ; 4 cycles
0B1A40 33          0002M          inc sp ; 1 cycle
0B1A41 F1          0003M          pop af  ; 4 cycles
0B1A42 3B          0004M          dec sp ; 1 cycle
0B1A43             0005M                 ; 10 cycles total
0B1A43 47          0095       ld b,a ; b = high 8-bits
0B1A44 E5          0096       push hl ; store low 16-bits, b will be fine
0B1A45             0097   
0B1A45             0098   ; 8-bit argument to A TODO: write an 8-bit argument parser for performance
0B1A45 CD D5 1A 0B 0099       call get_arg_s24
0B1A49 7B          0100       ld a,e ; 8-bit argument
0B1A4A E1          0101       pop hl ; bhl is the 24-bit argument
0B1A4B             0102   
0B1A4B             0103   ; do the multiplication
0B1A4B CD 84 0E 0B 0104       call umul24x8
0B1A4F CD F6 02 0B 0105       call printHexABHL
0B1A53 CD 8C 02 0B 0106       call printNewLine
0B1A57 C3 0A 1A 0B 0107       jp _main_end_ok
0B1A5B             0108   
0B1A5B             0109   test_scratch:
0B1A5B CD D5 1A 0B 0110       call get_arg_s24
0B1A5F EB          0111       ex de,hl
0B1A60             0112       HLU_TO_A
0B1A60 E5          0001M          push hl ; 4 cycles
0B1A61 33          0002M          inc sp ; 1 cycle
0B1A62 F1          0003M          pop af  ; 4 cycles
0B1A63 3B          0004M          dec sp ; 1 cycle
0B1A64             0005M                 ; 10 cycles total
0B1A64 CD 5A 05 0B 0113       call dumpRegistersHex
0B1A68 CD 8C 02 0B 0114       call printNewLine
0B1A6C C3 0A 1A 0B 0115       jp _main_end_ok
0B1A70             0116   
0B1A70             0117   test_udiv24:
0B1A70             0118   ; get dividend
0B1A70 CD D5 1A 0B 0119       call get_arg_s24
0B1A74 D5          0120       push de
0B1A75             0121   ; get divisor
0B1A75 CD D5 1A 0B 0122       call get_arg_s24
0B1A79 E1          0123       pop hl ; dividend (was de)
0B1A7A CD 5A 05 0B 0124       call dumpRegistersHex
0B1A7E             0125   ; do the division
0B1A7E CD 6D 0F 0B 0126       call udiv24 ; ude = uhl / ude rem uhl
0B1A82 EB          0127       ex de,hl    ; uhl = uhl / ude rem de
0B1A83 CD 5A 05 0B 0128       call dumpRegistersHex
0B1A87 CD AD 03 0B 0129       call print_u24
0B1A8B CD 8C 02 0B 0130       call printNewLine
0B1A8F C3 0A 1A 0B 0131       jp _main_end_ok
0B1A93             0132   
0B1A93             0133   ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0B1A93             0134   ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0B1A93             0135   ; destroys: a,bc
0B1A93             0136   test_sdiv168:
0B1A93             0137   ; get dividend
0B1A93 CD CA 1A 0B 0138       call get_arg_s168
0B1A97 D5          0139       push de
0B1A98             0140   ; get divisor
0B1A98 CD CA 1A 0B 0141       call get_arg_s168
0B1A9C C1          0142       pop bc ; dividend to bc (was de)
0B1A9D             0143   ; do the division
0B1A9D CD EA 0F 0B 0144       call sdiv168 ; uh.l = ub.c / ud.e
0B1AA1 CD 5A 05 0B 0145       call dumpRegistersHex
0B1AA5 CD 30 04 0B 0146       call print_s168
0B1AA9 CD 8C 02 0B 0147       call printNewLine
0B1AAD C3 0A 1A 0B 0148       jp _main_end_ok
0B1AB1             0149   
0B1AB1             0150   test_deg_360_to_255:
0B1AB1 CD CA 1A 0B 0151       call get_arg_s168 ; argument value to de
0B1AB5 EB          0152       ex de,hl             ; argument to hl for function call
0B1AB6 CD F0 10 0B 0153       call deg_360_to_255
0B1ABA CD 5A 05 0B 0154       call dumpRegistersHex
0B1ABE CD 30 04 0B 0155       call print_s168
0B1AC2 CD 8C 02 0B 0156       call printNewLine
0B1AC6 C3 0A 1A 0B 0157       jp _main_end_ok
0B1ACA             0158   
0B1ACA             0159   ; ========== HELPER FUNCTIONS ==========
0B1ACA             0160   ; get the next argument after ix as a signed 16.8 fixed point number
0B1ACA             0161   ; inputs: ix = pointer to the argument string
0B1ACA             0162   ; outputs: ude = signed 16.8 fixed point number
0B1ACA             0163   ; destroys: a, d, e, h, l, f
0B1ACA             0164   get_arg_s168:
0B1ACA ED 32 03    0165       lea ix,ix+3 ; point to the next argument
0B1ACD DD 27 00    0166       ld hl,(ix)  ; get the argument string
0B1AD0 CD 98 01 0B 0167       call asc_to_s168 ; convert the string to a number
0B1AD4 C9          0168       ret ; return with the value in DE
0B1AD5             0169   
0B1AD5             0170   ; Inputs: ix = pointer to the argument string
0B1AD5             0171   ; Outputs: ude = signed 24-bit integer
0B1AD5             0172   ; Destroys: a, d, e, h, l, f
0B1AD5             0173   get_arg_s24:
0B1AD5 ED 32 03    0174       lea ix,ix+3 ; point to the next argument
0B1AD8 DD 27 00    0175       ld hl,(ix)  ; get the argument string
0B1ADB CD 45 01 0B 0176       call asc_to_s24 ; convert the string to a number
0B1ADF C9          0177       ret ; return with the value in DE
0B1AE0             0178   
0B1AE0             0179   get_plot_coords:
0B1AE0             0180   ; get the move coordinates
0B1AE0 ED 32 03    0181       lea ix,ix+3 ; pointer to next argument address
0B1AE3 DD 27 00    0182       ld hl,(ix)  ; pointer to the x coordinate string
0B1AE6 CD 98 01 0B 0183       call asc_to_s168 ; de = x coordinate
0B1AEA D5          0184       push de
0B1AEB C1          0185       pop bc ; bc = x coordinate
0B1AEC ED 32 03    0186       lea ix,ix+3 ; pointer to next argument address
0B1AEF DD 27 00    0187       ld hl,(ix)  ; pointer to the y coordinate string
0B1AF2 CD 98 01 0B 0188       call asc_to_s168 ; de = y coordinate
0B1AF6 C9          0189       ret
0B1AF7             0190   
0B1AF7             0191   ; match the next argument after ix to the dispatch table at iy
0B1AF7             0192   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1AF7             0193   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1AF7             0194   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1AF7             0195   ;          ON MATCH: iy=dispatch address, a=0 and zero flag se
0B1AF7             0196   ; destroys: a, hl, de, ix, iy, flags
0B1AF7             0197   match_next:
0B1AF7 ED 32 03    0198       lea ix,ix+3         ; point to the next argument
0B1AFA             0199   @loop:
0B1AFA FD 27 00    0200       ld hl,(iy)          ; pointer argument dispatch record
0B1AFD             0201       signHL              ; check for list terminator
0B1AFD 19          0001M          add hl,de
0B1AFE B7          0002M          or a
0B1AFF ED 52       0003M          sbc hl,de
0B1B01 CA 19 1B 0B 0202       jp z,@no_match      ; if a=0, return error
0B1B05 23          0203       inc hl              ; skip over jp instruction
0B1B06 23          0204       inc hl
0B1B07 DD 17 00    0205       ld de,(ix)          ; pointer to the argument string
0B1B0A CD 1F 1B 0B 0206       call str_equal      ; compare the argument to the dispatch table entry
0B1B0E CA 1B 1B 0B 0207       jp z,@match         ; if equal, return success
0B1B12 ED 33 03    0208       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1B15 C3 FA 1A 0B 0209       jp @loop            ; and loop
0B1B19             0210   @no_match:
0B1B19 3C          0211       inc a               ; no match so return a=1 and zero flag reset
0B1B1A C9          0212       ret
0B1B1B             0213   @match:
0B1B1B FD 37 00    0214       ld iy,(iy)          ; get the function pointer
0B1B1E C9          0215       ret                 ; return a=0 and zero flag set
0B1B1F             0216   
0B1B1F             0217   ; compare two zero-terminated strings for equality, case-sensitive
0B1B1F             0218   ; hl: pointer to first string, de: pointer to second string
0B1B1F             0219   ; returns: z if equal, nz if not equal
0B1B1F             0220   ; destroys: a, hl, de
0B1B1F             0221   str_equal:
0B1B1F 1A          0222       ld a,(de)           ; get the first character
0B1B20 BE          0223       cp (hl)             ; compare to the second character
0B1B21 C0          0224       ret nz              ; if not equal, return
0B1B22 B7          0225       or a
0B1B23 C8          0226       ret z               ; if equal and zero, return
0B1B24 23          0227       inc hl              ; next character
0B1B25 13          0228       inc de
0B1B26 C3 1F 1B 0B 0229       jp str_equal        ; loop until end of string
0B1B2A             0230   
0B1B2A             0231   ; print the parameter string pointed to by ix
0B1B2A             0232   ; destroys: a, hl
0B1B2A             0233   print_param:
0B1B2A DD 27 00    0234       ld hl,(ix)          ; get the parameter pointer
0B1B2D CD 77 02 0B 0235       call printString    ; print the parameter string
0B1B31 3E 20       0236       ld a,' '            ; print a space separator
0B1B33 5B D7       0237       rst.lil $10
0B1B35 C9          0238       ret
0B1B36             0239   
0B1B36             0240   ; print the parameters
0B1B36             0241   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1B36             0242   ; destroys: a, hl, bc
0B1B36             0243   print_params:
0B1B36 41          0244       ld b,c              ; loop counter = number of parameters
0B1B37 DD E5       0245       push ix             ; save the pointer to the parameters
0B1B39             0246   @loop:
0B1B39 C5          0247       push bc             ; save the loop counter
0B1B3A CD 2A 1B 0B 0248       call print_param    ; print the parameter
0B1B3E ED 32 03    0249       lea ix,ix+3         ; next parameter pointer
0B1B41 C1          0250       pop bc              ; get back the loop counter
0B1B42 10 F5       0251       djnz @loop          ; loop until done
0B1B44 DD E1       0252       pop ix              ; restore the pointer to the parameters
0B1B46 C9          0253       ret
0B1B47             0254   
0B1B47             0255   debug_print:
0B1B47 CD 8C 02 0B 0256       call printNewLine   ; DEBUG
0B1B4B CD 8D 06 0B 0257       call dumpFlags      ; DEBUG
0B1B4F CD 2A 1B 0B 0258       call print_param    ; DEBUG
0B1B53 CD 8C 02 0B 0259       call printNewLine   ; DEBUG
0B1B57 CD 8C 02 0B 0260       call printNewLine   ; DEBUG
0B1B5B C9          0261       ret
