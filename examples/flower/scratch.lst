PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "../moslets/mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "scratch.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 73 63 72 61 0001*M     ASCIZ "scratch.bin"
       74 63 68 2E 
       62 69 6E 00 
0B0010             0025*  
0B0010 FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD 67 0E 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  signed_asc_to_int:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 97 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F CD B2 00 0B 0108*      call _skip_spaces ; skip whitespace
0B0153             0109*  
0B0153 7E          0110*      ld a, (hl) ; read first character
0B0154 B7          0111*      or a ; check for end of string
0B0155 C8          0112*      ret z ; return with no carry if not
0B0156             0113*  
0B0156 C5          0114*      push bc ; preserve bc
0B0157             0115*  
0B0157 FE 2D       0116*      cp '-' ; check for negative number
0B0159 C2 63 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B015D AF          0118*      xor a ; sign flag to zero
0B015E 32 97 01 0B 0119*      ld (@sign),a ; store sign flag
0B0162 23          0120*      inc hl ; skip '-'
0B0163             0121*  
0B0163             0122*  @loop:
0B0163 7E          0123*      ld a, (hl)
0B0164 D6 30       0124*      sub '0' ; normalise to 0
0B0166 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0168 FE 0A       0126*      cp 10 ; check if >= 10
0B016A 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B016C E5          0128*      push hl ; stack hl
0B016D D5          0129*      push de ; ld hl, de
0B016E E1          0130*      pop hl
0B016F E5          0131*      push hl ; ld bc, hl
0B0170 C1          0132*      pop bc
0B0171 29          0133*      add hl, hl ; x 2
0B0172 29          0134*      add hl, hl ; x 4
0B0173 09          0135*      add hl, bc ; x 5
0B0174 29          0136*      add hl, hl ; x 10
0B0175 01 00 00 00 0137*      ld bc, 0
0B0179 4F          0138*      ld c, a ; ld bcu, a
0B017A 09          0139*      add hl, bc ; add bcu to hl
0B017B E5          0140*      push hl ; ld de, hl
0B017C D1          0141*      pop de
0B017D E1          0142*      pop hl ; restore hl
0B017E 23          0143*      inc hl
0B017F 18 E2       0144*      jr @loop
0B0181             0145*  
0B0181             0146*  @integer_end:
0B0181 C1          0147*      pop bc ; send bc back how she came in
0B0182 3A 97 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0186 3D          0149*      dec a ; check if negative
0B0187 F2 95 01 0B 0150*      jp p,@pos ; positive number
0B018B             0151*  
0B018B             0152*  ; Negate de
0B018B E5          0153*      push hl ; save text pointer
0B018C 21 00 00 00 0154*      ld hl, 0
0B0190 AF          0155*      xor a ; clear carry
0B0191 ED 52       0156*      sbc hl, de ; subtract DE from HL
0B0193 EB          0157*      ex de, hl ; DE = 0-HL
0B0194 E1          0158*      pop hl ; restore text pointer
0B0195             0159*  
0B0195             0160*  @pos:
0B0195 37          0161*      scf ; we have a valid number so set carry
0B0196 C9          0162*      ret
0B0197             0163*  
0B0197 00          0164*  @sign: db 0 ; sign flag buffer
0B0198             0165*  
0B0198             0166*  
0B0198             0167*  ;------------------------------------------------------------------------
0B0198             0168*  ; Read a number and convert to binary (decimal only)
0B0198             0169*  ; Inputs: hl: Pointer in string buffer
0B0198             0170*  ; Outputs: hl: Updated text pointer
0B0198             0171*  ;         de: Value
0B0198             0172*  ;         a: Terminator (spaces skipped)
0B0198             0173*  ;         f: Carry set if valid number, otherwise reset
0B0198             0174*  ; Destroys: a, d, e, h, l, f
0B0198             0175*  ;------------------------------------------------------------------------
0B0198             0176*  signed_asc_to_168:
0B0198 3E 01       0177*      ld a,1 ; set sign flag
0B019A 32 58 02 0B 0178*      ld (@sign),a ; store sign flag
0B019E             0179*  
0B019E 11 00 00 00 0180*      ld de, 0 ; initialise de
0B01A2 ED 53 50 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A7 ED 53 54 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01AC             0183*  
0B01AC CD B2 00 0B 0184*      call _skip_spaces ; skip whitespace
0B01B0             0185*  
0B01B0 7E          0186*      ld a, (hl) ; read first character
0B01B1 B7          0187*      or a ; check for end of string
0B01B2 C8          0188*      ret z ; return with no carry if not
0B01B3             0189*  
0B01B3 C5          0190*      push bc ; preserve bc
0B01B4             0191*  
0B01B4 FE 2D       0192*      cp '-' ; check for negative number
0B01B6 C2 C0 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01BA AF          0194*      xor a ; sign flag to zero
0B01BB 32 58 02 0B 0195*      ld (@sign),a ; store sign flag
0B01BF 23          0196*      inc hl ; skip '-'
0B01C0             0197*  
0B01C0             0198*  @loop:
0B01C0 7E          0199*      ld a, (hl)
0B01C1             0200*  
0B01C1             0201*  ; chcek for decimal point
0B01C1 FE 2E       0202*      cp '.' ; check for decimal point
0B01C3 CA 04 02 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01C7             0204*  
0B01C7             0205*  ; process integer part
0B01C7 D6 30       0206*      sub '0' ; normalise to 0
0B01C9 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01CB FE 0A       0208*      cp 10 ; check if >= 10
0B01CD 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01CF E5          0210*      push hl ; stack hl
0B01D0 D5          0211*      push de ; ld hl, de
0B01D1 E1          0212*      pop hl
0B01D2 E5          0213*      push hl ; ld bc, hl
0B01D3 C1          0214*      pop bc
0B01D4 29          0215*      add hl, hl ; x 2
0B01D5 29          0216*      add hl, hl ; x 4
0B01D6 09          0217*      add hl, bc ; x 5
0B01D7 29          0218*      add hl, hl ; x 10
0B01D8 01 00 00 00 0219*      ld bc, 0
0B01DC 4F          0220*      ld c, a ; ld bcu, a
0B01DD 09          0221*      add hl, bc ; add bcu to hl
0B01DE E5          0222*      push hl ; ld de, hl
0B01DF D1          0223*      pop de
0B01E0 E1          0224*      pop hl ; restore hl
0B01E1 23          0225*      inc hl
0B01E2 18 DC       0226*      jr @loop
0B01E4             0227*  
0B01E4             0228*  @integer_end:
0B01E4 ED 53 51 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E9             0230*  
0B01E9             0231*  @end:
0B01E9 C1          0232*      pop bc ; send bc back how she came in
0B01EA ED 5B 50 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01EF 3A 58 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01F3 3D          0235*      dec a ; check if negative
0B01F4 F2 02 02 0B 0236*      jp p,@pos ; positive number
0B01F8             0237*  
0B01F8             0238*  ; Negate de
0B01F8 E5          0239*      push hl ; save text pointer
0B01F9 21 00 00 00 0240*      ld hl, 0
0B01FD AF          0241*      xor a ; clear carry
0B01FE ED 52       0242*      sbc hl, de ; subtract DE from HL
0B0200 EB          0243*      ex de, hl ; DE = 0-HL
0B0201 E1          0244*      pop hl ; restore text pointer
0B0202             0245*  
0B0202             0246*  @pos:
0B0202 37          0247*      scf ; we have a valid number so set carry
0B0203 C9          0248*      ret
0B0204             0249*  
0B0204             0250*  @fractional_start:
0B0204 ED 53 51 02 0251*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0209 06 03       0252*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B020B 11 00 00 00 0253*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B020F DD 21 59 02 0254*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0214 23          0255*      inc hl                     ; Skip decimal point
0B0215             0256*  
0B0215             0257*  @fractional_loop:
0B0215 7E          0258*      ld a, (hl)                 ; Load next character
0B0216 D6 30       0259*      sub '0'                    ; Normalize ASCII to decimal
0B0218 38 1D       0260*      jr c, @end_fraction        ; Exit if < '0'
0B021A FE 0A       0261*      cp 10
0B021C 30 19       0262*      jr nc, @end_fraction       ; Exit if >= 10
0B021E             0263*  
0B021E             0264*      ; Multiply the current fractional accumulator by 10
0B021E E5          0265*      push hl                    ; Save HL (used as pointer)
0B021F F5          0266*      push af                    ; Save the digit
0B0220 21 0A 00 00 0267*      ld hl, 10                  ; Prepare to multiply by 10
0B0224 CD 62 0D 0B 0268*      call umul24                ; hl = de * 10
0B0228 11 00 00 00 0269*      ld de, 0                   ; Clear DEU
0B022C F1          0270*      pop af                     ; Restore the current digit
0B022D 5F          0271*      ld e, a                    ; Load the digit into E
0B022E 19          0272*      add hl, de                 ; Add the digit to the accumulator
0B022F EB          0273*      ex de, hl                  ; Result back to DE
0B0230 ED 32 03    0274*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0233 E1          0275*      pop hl                     ; Restore char pointer
0B0234 23          0276*      inc hl                     ; Move to the next character
0B0235 10 DE       0277*      djnz @fractional_loop      ; Loop if more digits to process
0B0237             0278*  
0B0237             0279*  @end_fraction:
0B0237             0280*  ; Final scaling based on number of fractional digits processed
0B0237 ED 53 55 02 0281*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B023C 2A 54 02 0B 0282*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B0240             0283*  
0B0240 DD 17 00    0284*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0243 CD 7B 0D 0B 0285*      call udiv24                ; Perform 24-bit division to scale down
0B0247 7B          0286*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0248 32 50 02 0B 0287*      ld (@result), a            ; Store fractional part in result buffer
0B024C C3 E9 01 0B 0288*      jp @end                    ; Final sign check and flag setup
0B0250             0289*  
0B0250             0290*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0254             0291*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0258 00          0292*  @sign: db 0                    ; Sign flag buffer
0B0259             0293*  
0B0259             0294*  powers_of_10:
0B0259 01 00 00    0295*      dl 1                       ; 10^0
0B025C 0A 00 00    0296*      dl 10                      ; 10^1
0B025F 64 00 00    0297*      dl 100                     ; 10^2
0B0262 E8 03 00    0298*      dl 1000                    ; 10^3
0B0265 10 27 00    0299*      dl 10000                   ; 10^4
0B0268             0017   
0B0268             0018   ; API INCLUDES
0B0268             0019       include "../moslets/functions.inc"
0B0268             0001*      MACRO printChar char
0B0268             0002*          LD A, char
0B0268             0003*          RST.LIL 10h
0B0268             0004*      ENDMACRO
0B0268             0005*  
0B0268             0006*  ; test the sign of HL
0B0268             0007*  ; inputs: HL obviously
0B0268             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0268             0009*  ; destroys: flags
0B0268             0010*      MACRO signHL
0B0268             0011*          add hl,de
0B0268             0012*          or a
0B0268             0013*          sbc hl,de
0B0268             0014*      ENDMACRO
0B0268             0015*  
0B0268             0016*  ; Simulated call to subroutine at HL
0B0268             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0268             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0268             0019*  ; destroys: only what the subroutine does, but always BC
0B0268             0020*      MACRO callHL
0B0268             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0268             0022*          push bc       ; which constitutes the return address
0B0268             0023*          jp   (hl)     ; Jump to the address in HL
0B0268             0024*      ENDMACRO
0B0268             0025*  
0B0268             0026*  ; Simulated call to subroutine at IX
0B0268             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0268             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0268             0029*  ; destroys: only what the subroutine does, but always BC
0B0268             0030*      MACRO callIX
0B0268             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0268             0032*          push bc       ; which constitutes the return address
0B0268             0033*          jp   (ix)     ; Jump to the address in IX
0B0268             0034*      ENDMACRO
0B0268             0035*  
0B0268             0036*  ; Simulated call to soubroutinte at IY
0B0268             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0268             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0268             0039*  ; destroys: only what the subroutine does, but always BC
0B0268             0040*      MACRO callIY
0B0268             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0268             0042*          push bc       ; which constitutes the return address
0B0268             0043*          jp   (iy)     ; Jump to the address in IY
0B0268             0044*      ENDMACRO
0B0268             0045*  
0B0268             0046*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0268             0047*  ; Print a zero-terminated string
0B0268             0048*  ; HL: Pointer to string
0B0268             0049*  printString:
0B0268 C5          0050*  	PUSH	BC
0B0269 01 00 00 00 0051*  	LD		BC,0
0B026D 3E 00       0052*  	LD 	 	A,0
0B026F 5B DF       0053*  	RST.LIL 18h
0B0271 C1          0054*  	POP		BC
0B0272 C9          0055*  	RET
0B0273             0056*  ; print a VDU sequence
0B0273             0057*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0273             0058*  sendVDUsequence:
0B0273 C5          0059*  	PUSH	BC
0B0274 01 00 00 00 0060*  	LD		BC, 0
0B0278 4E          0061*  	LD		C, (HL)
0B0279 5B DF       0062*  	RST.LIL	18h
0B027B C1          0063*  	POP		BC
0B027C C9          0064*  	RET
0B027D             0065*  ; Print Newline sequence to VDP
0B027D             0066*  printNewLine:
0B027D F5          0067*      push af ; for some reason rst.lil 10h sets carry flag
0B027E 3E 0D       0068*  	LD	A, '\r'
0B0280 5B D7       0069*  	RST.LIL 10h
0B0282 3E 0A       0070*  	LD	A, '\n'
0B0284 5B D7       0071*  	RST.LIL 10h
0B0286 F1          0072*      pop af
0B0287 C9          0073*  	RET
0B0288             0074*  ; Print a 24-bit HEX number
0B0288             0075*  ; HLU: Number to print
0B0288             0076*  printHex24:
0B0288 E5          0077*  	PUSH	HL
0B0289 21 02 00 00 0078*  	LD		HL, 2
0B028D 39          0079*  	ADD		HL, SP
0B028E 7E          0080*  	LD		A, (HL)
0B028F E1          0081*  	POP		HL
0B0290 CD 9A 02 0B 0082*  	CALL	printHex8
0B0294             0083*  ; Print a 16-bit HEX number
0B0294             0084*  ; HL: Number to print
0B0294             0085*  printHex16:
0B0294 7C          0086*  	LD		A,H
0B0295 CD 9A 02 0B 0087*  	CALL	printHex8
0B0299 7D          0088*  	LD		A,L
0B029A             0089*  ; Print an 8-bit HEX number
0B029A             0090*  ; A: Number to print
0B029A             0091*  printHex8:
0B029A 4F          0092*  	LD		C,A
0B029B 1F          0093*  	RRA
0B029C 1F          0094*  	RRA
0B029D 1F          0095*  	RRA
0B029E 1F          0096*  	RRA
0B029F CD A4 02 0B 0097*  	CALL	@F
0B02A3 79          0098*  	LD		A,C
0B02A4             0099*  @@:
0B02A4 E6 0F       0100*  	AND		0Fh
0B02A6 C6 90       0101*  	ADD		A,90h
0B02A8 27          0102*  	DAA
0B02A9 CE 40       0103*  	ADC		A,40h
0B02AB 27          0104*  	DAA
0B02AC 5B D7       0105*  	RST.LIL	10h
0B02AE C9          0106*  	RET
0B02AF             0107*  
0B02AF             0108*  ; Print a 0x HEX prefix
0B02AF             0109*  DisplayHexPrefix:
0B02AF 3E 30       0110*  	LD	A, '0'
0B02B1 5B D7       0111*  	RST.LIL 10h
0B02B3 3E 78       0112*  	LD	A, 'x'
0B02B5 5B D7       0113*  	RST.LIL 10h
0B02B7 C9          0114*  	RET
0B02B8             0115*  
0B02B8             0116*      MACRO printDecBC
0B02B8             0117*          push hl
0B02B8             0118*          push bc
0B02B8             0119*          pop hl
0B02B8             0120*          call printDec
0B02B8             0121*          pop hl
0B02B8             0122*      ENDMACRO
0B02B8             0123*  
0B02B8             0124*      MACRO printDecDE
0B02B8             0125*          push hl
0B02B8             0126*          push de
0B02B8             0127*          pop hl
0B02B8             0128*          call printDec
0B02B8             0129*          pop hl
0B02B8             0130*      ENDMACRO
0B02B8             0131*  
0B02B8             0132*      MACRO printDecHL
0B02B8             0133*          call printDec
0B02B8             0134*      ENDMACRO
0B02B8             0135*  
0B02B8             0136*      MACRO printDecIX
0B02B8             0137*          push hl
0B02B8             0138*          push ix
0B02B8             0139*          pop hl
0B02B8             0140*          call printDec
0B02B8             0141*          pop hl
0B02B8             0142*      ENDMACRO
0B02B8             0143*  
0B02B8             0144*      MACRO printDecIY
0B02B8             0145*          push hl
0B02B8             0146*          push iy
0B02B8             0147*          pop hl
0B02B8             0148*          call printDec
0B02B8             0149*          pop hl
0B02B8             0150*      ENDMACRO
0B02B8             0151*  
0B02B8             0152*  ; Prints the right justified decimal value in HL without leading zeroes
0B02B8             0153*  ; HL : Value to print
0B02B8             0154*  ; preserves all registers and flags
0B02B8             0155*  printDec:
0B02B8             0156*  ; BEGIN MY CODE
0B02B8             0157*  ; back up all the things
0B02B8 F5          0158*      push af
0B02B9 C5          0159*      push bc
0B02BA D5          0160*      push de
0B02BB E5          0161*      push hl
0B02BC             0162*  ; END MY CODE
0B02BC 11 E4 02 0B 0163*  	LD	 DE, _printDecBuffer
0B02C0 CD ED 02 0B 0164*  	CALL Num2String
0B02C4             0165*  ; BEGIN MY CODE
0B02C4             0166*  ; replace leading zeroes with spaces
0B02C4 21 E4 02 0B 0167*      LD	 HL, _printDecBuffer
0B02C8 06 07       0168*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B02CA             0169*  @loop:
0B02CA 7E          0170*      LD	 A, (HL)
0B02CB FE 30       0171*      CP	 '0'
0B02CD C2 DB 02 0B 0172*      JP	 NZ, @done
0B02D1 3E 20       0173*      LD   A, ' '
0B02D3 77          0174*      LD	 (HL), A
0B02D4 23          0175*      INC	 HL
0B02D5 CD 10 08 0B 0176*      CALL vdu_cursor_forward
0B02D9 10 EF       0177*      DJNZ @loop
0B02DB             0178*  @done:
0B02DB             0179*  ; END MY CODE
0B02DB             0180*  	; LD	 HL, _printDecBuffer
0B02DB CD 68 02 0B 0181*  	CALL printString
0B02DF             0182*  ; BEGIN MY CODE
0B02DF             0183*  ; restore all the things
0B02DF E1          0184*      pop hl
0B02E0 D1          0185*      pop de
0B02E1 C1          0186*      pop bc
0B02E2 F1          0187*      pop af
0B02E3             0188*  ; END MY CODE
0B02E3 C9          0189*  	RET
0B02E4 00 00 00 00 0190*  _printDecBuffer: blkb 9,0 ; nine bytes full of zeroes
       00 00 00 00 
       00          
0B02ED             0191*  
0B02ED             0192*  ; This routine converts the value from HL into it's ASCII representation,
0B02ED             0193*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B02ED             0194*  ; so it will allways be 8 characters length
0B02ED             0195*  ; HL : Value to convert to string
0B02ED             0196*  ; DE : pointer to buffer, at least 8 byte + 0
0B02ED             0197*  Num2String:
0B02ED 01 80 69 67 0198*  	LD	 BC,-10000000
0B02F1 CD 24 03 0B 0199*  	CALL OneDigit
0B02F5 01 C0 BD F0 0200*  	LD	 BC,-1000000
0B02F9 CD 24 03 0B 0201*  	CALL OneDigit
0B02FD 01 60 79 FE 0202*  	LD	 BC,-100000
0B0301 CD 24 03 0B 0203*  	CALL OneDigit
0B0305 01 F0 D8 FF 0204*  	LD   BC,-10000
0B0309 CD 24 03 0B 0205*  	CALL OneDigit
0B030D 01 18 FC FF 0206*  	LD   BC,-1000
0B0311 CD 24 03 0B 0207*  	CALL OneDigit
0B0315 01 9C FF FF 0208*  	LD   BC,-100
0B0319 CD 24 03 0B 0209*  	CALL OneDigit
0B031D 0E F6       0210*  	LD   C,-10
0B031F CD 24 03 0B 0211*  	CALL OneDigit
0B0323 48          0212*  	LD   C,B
0B0324             0213*  OneDigit:
0B0324 3E 2F       0214*  	LD   A,'0'-1
0B0326             0215*  DivideMe:
0B0326 3C          0216*  	INC  A
0B0327 09          0217*  	ADD  HL,BC
0B0328 38 FC       0218*  	JR   C,DivideMe
0B032A ED 42       0219*  	SBC  HL,BC
0B032C 12          0220*  	LD   (DE),A
0B032D 13          0221*  	INC  DE
0B032E C9          0222*  	RET
0B032F             0223*  
0B032F             0224*  
0B032F             0225*  ; #### new functions added by Brandon R. Gates ####
0B032F             0226*  
0B032F             0227*  ; print the binary representation of the 8-bit value in a
0B032F             0228*  ; destroys a, hl, bc
0B032F             0229*  printBin8:
0B032F 06 08       0230*      ld b,8      ; loop counter for 8 bits
0B0331 21 4C 03 0B 0231*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0335             0232*                  ; (which will be the high bit of the value in a)
0B0335             0233*  @loop:
0B0335 07          0234*      rlca ; put the next highest bit into carry
0B0336 38 04       0235*      jr c,@one
0B0338 36 30       0236*      ld (hl),'0'
0B033A 18 02       0237*      jr @next_bit
0B033C             0238*  @one:
0B033C 36 31       0239*      ld (hl),'1'
0B033E             0240*  @next_bit:
0B033E 23          0241*      inc hl
0B033F 10 F4       0242*      djnz @loop
0B0341             0243*  ; print it
0B0341 21 4C 03 0B 0244*  	ld hl,@cmd
0B0345 01 08 00 00 0245*  	ld bc,@end-@cmd
0B0349 5B DF       0246*  	rst.lil $18
0B034B C9          0247*  	ret
0B034C             0248*  @cmd: ds 8 ; eight bytes for eight bits
0B0354             0249*  @end:
0B0354             0250*  
0B0354             0251*  ; print the binary representation of the 8-bit value in a
0B0354             0252*  ; in reverse order (lsb first)
0B0354             0253*  ; destroys a, hl, bc
0B0354             0254*  printBin8Rev:
0B0354 06 08       0255*      ld b,8      ; loop counter for 8 bits
0B0356 21 71 03 0B 0256*      ld hl,@cmd  ; set hl to the low byte of the output string
0B035A             0257*                  ; (which will be the high bit of the value in a)
0B035A             0258*  @loop:
0B035A 0F          0259*      rrca ; put the next lowest bit into carry
0B035B 38 04       0260*      jr c,@one
0B035D 36 30       0261*      ld (hl),'0'
0B035F 18 02       0262*      jr @next_bit
0B0361             0263*  @one:
0B0361 36 31       0264*      ld (hl),'1'
0B0363             0265*  @next_bit:
0B0363 23          0266*      inc hl
0B0364 10 F4       0267*      djnz @loop
0B0366             0268*  ; print it
0B0366 21 71 03 0B 0269*  	ld hl,@cmd
0B036A 01 08 00 00 0270*  	ld bc,@end-@cmd
0B036E 5B DF       0271*  	rst.lil $18
0B0370 C9          0272*  	ret
0B0371             0273*  @cmd: ds 8 ; eight bytes for eight bits
0B0379             0274*  @end:
0B0379             0275*  
0B0379             0276*  ; print registers to screen in hexidecimal format
0B0379             0277*  ; inputs: none
0B0379             0278*  ; outputs: values of every register printed to screen
0B0379             0279*  ;    values of each register in global scratch memory
0B0379             0280*  ; destroys: nothing
0B0379             0281*  stepRegistersHex:
0B0379             0282*  ; store everything in scratch
0B0379 22 66 05 0B 0283*      ld (uhl),hl
0B037D ED 43 69 05 0284*      ld (ubc),bc
       0B          
0B0382 ED 53 6C 05 0285*      ld (ude),de
       0B          
0B0387 DD 22 6F 05 0286*      ld (uix),ix
       0B          
0B038C FD 22 72 05 0287*      ld (uiy),iy
       0B          
0B0391 F5          0288*      push af ; fml
0B0392 E1          0289*      pop hl  ; thanks, zilog
0B0393 22 63 05 0B 0290*      ld (uaf),hl
0B0397 F5          0291*      push af ; dammit
0B0398             0292*  
0B0398             0293*  ; home the cursor
0B0398 CD EF 07 0B 0294*      call vdu_home_cursor
0B039C             0295*  
0B039C             0296*  ; print each register
0B039C 21 E9 04 0B 0297*      ld hl,str_afu
0B03A0 CD 68 02 0B 0298*      call printString
0B03A4 2A 63 05 0B 0299*      ld hl,(uaf)
0B03A8 CD 88 02 0B 0300*      call printHex24
0B03AC CD 7D 02 0B 0301*      call printNewLine
0B03B0             0302*  
0B03B0 21 EE 04 0B 0303*      ld hl,str_hlu
0B03B4 CD 68 02 0B 0304*      call printString
0B03B8 2A 66 05 0B 0305*      ld hl,(uhl)
0B03BC CD 88 02 0B 0306*      call printHex24
0B03C0 CD 7D 02 0B 0307*      call printNewLine
0B03C4             0308*  
0B03C4 21 F3 04 0B 0309*      ld hl,str_bcu
0B03C8 CD 68 02 0B 0310*      call printString
0B03CC 2A 69 05 0B 0311*      ld hl,(ubc)
0B03D0 CD 88 02 0B 0312*      call printHex24
0B03D4 CD 7D 02 0B 0313*      call printNewLine
0B03D8             0314*  
0B03D8 21 F8 04 0B 0315*      ld hl,str_deu
0B03DC CD 68 02 0B 0316*      call printString
0B03E0 2A 6C 05 0B 0317*      ld hl,(ude)
0B03E4 CD 88 02 0B 0318*      call printHex24
0B03E8 CD 7D 02 0B 0319*      call printNewLine
0B03EC             0320*  
0B03EC 21 FD 04 0B 0321*      ld hl,str_ixu
0B03F0 CD 68 02 0B 0322*      call printString
0B03F4 2A 6F 05 0B 0323*      ld hl,(uix)
0B03F8 CD 88 02 0B 0324*      call printHex24
0B03FC CD 7D 02 0B 0325*      call printNewLine
0B0400             0326*  
0B0400 21 02 05 0B 0327*      ld hl,str_iyu
0B0404 CD 68 02 0B 0328*      call printString
0B0408 2A 72 05 0B 0329*      ld hl,(uiy)
0B040C CD 88 02 0B 0330*      call printHex24
0B0410 CD 7D 02 0B 0331*      call printNewLine
0B0414             0332*  
0B0414             0333*      ; call vsync
0B0414             0334*  
0B0414 CD 7D 02 0B 0335*      call printNewLine
0B0418             0336*  
0B0418             0337*  ; check for right shift key and quit if pressed
0B0418             0338*  	MOSCALL mos_getkbmap
0B0418 3E 1E       0001*M 			LD	A, function
0B041A 5B CF       0002*M 			RST.L	08h
0B041C             0339*  @stayhere:
0B041C             0340*  ; 7 RightShift
0B041C DD CB 00 76 0341*      bit 6,(ix+0)
0B0420 20 02       0342*      jr nz,@RightShift
0B0422 18 F8       0343*      jr @stayhere
0B0424             0344*  @RightShift:
0B0424 DD CB 0E 86 0345*      res 0,(ix+14) ; debounce the key (hopefully)
0B0428 3E 80       0346*      ld a,%10000000
0B042A CD CF 07 0B 0347*      call multiPurposeDelay
0B042E             0348*  
0B042E             0349*  ; restore everything
0B042E 2A 66 05 0B 0350*      ld hl, (uhl)
0B0432 ED 4B 69 05 0351*      ld bc, (ubc)
       0B          
0B0437 ED 5B 6C 05 0352*      ld de, (ude)
       0B          
0B043C DD 2A 6F 05 0353*      ld ix, (uix)
       0B          
0B0441 FD 2A 72 05 0354*      ld iy, (uiy)
       0B          
0B0446 F1          0355*      pop af
0B0447             0356*  ; all done
0B0447 C9          0357*      ret
0B0448             0358*  
0B0448             0359*  ; print registers to screen in hexidecimal format
0B0448             0360*  ; inputs: none
0B0448             0361*  ; outputs: values of every register printed to screen
0B0448             0362*  ;    values of each register in global scratch memory
0B0448             0363*  ; destroys: nothing
0B0448             0364*  dumpRegistersHex:
0B0448             0365*  ; store everything in scratch
0B0448 22 66 05 0B 0366*      ld (uhl),hl
0B044C ED 43 69 05 0367*      ld (ubc),bc
       0B          
0B0451 ED 53 6C 05 0368*      ld (ude),de
       0B          
0B0456 DD 22 6F 05 0369*      ld (uix),ix
       0B          
0B045B FD 22 72 05 0370*      ld (uiy),iy
       0B          
0B0460 F5          0371*      push af ; fml
0B0461 E1          0372*      pop hl  ; thanks, zilog
0B0462 22 63 05 0B 0373*      ld (uaf),hl
0B0466 F5          0374*      push af ; dammit
0B0467             0375*  
0B0467             0376*  ; home the cursor
0B0467             0377*      ; call vdu_home_cursor
0B0467             0378*      ; call printNewLine
0B0467             0379*  
0B0467             0380*  ; print each register
0B0467 21 E9 04 0B 0381*      ld hl,str_afu
0B046B CD 68 02 0B 0382*      call printString
0B046F 2A 63 05 0B 0383*      ld hl,(uaf)
0B0473 CD 88 02 0B 0384*      call printHex24
0B0477             0385*      ; call printNewLine
0B0477             0386*  
0B0477 21 EE 04 0B 0387*      ld hl,str_hlu
0B047B CD 68 02 0B 0388*      call printString
0B047F 2A 66 05 0B 0389*      ld hl,(uhl)
0B0483 CD 88 02 0B 0390*      call printHex24
0B0487             0391*      ; call printNewLine
0B0487             0392*  
0B0487 21 F3 04 0B 0393*      ld hl,str_bcu
0B048B CD 68 02 0B 0394*      call printString
0B048F 2A 69 05 0B 0395*      ld hl,(ubc)
0B0493 CD 88 02 0B 0396*      call printHex24
0B0497             0397*      ; call printNewLine
0B0497             0398*  
0B0497 21 F8 04 0B 0399*      ld hl,str_deu
0B049B CD 68 02 0B 0400*      call printString
0B049F 2A 6C 05 0B 0401*      ld hl,(ude)
0B04A3 CD 88 02 0B 0402*      call printHex24
0B04A7             0403*      ; call printNewLine
0B04A7             0404*  
0B04A7 21 FD 04 0B 0405*      ld hl,str_ixu
0B04AB CD 68 02 0B 0406*      call printString
0B04AF 2A 6F 05 0B 0407*      ld hl,(uix)
0B04B3 CD 88 02 0B 0408*      call printHex24
0B04B7             0409*      ; call printNewLine
0B04B7             0410*  
0B04B7 21 02 05 0B 0411*      ld hl,str_iyu
0B04BB CD 68 02 0B 0412*      call printString
0B04BF 2A 72 05 0B 0413*      ld hl,(uiy)
0B04C3 CD 88 02 0B 0414*      call printHex24
0B04C7             0415*      ; call printNewLine
0B04C7             0416*  
0B04C7 CD 84 08 0B 0417*      call vdu_vblank
0B04CB             0418*  
0B04CB CD 7D 02 0B 0419*      call printNewLine
0B04CF             0420*  ; restore everything
0B04CF 2A 66 05 0B 0421*      ld hl, (uhl)
0B04D3 ED 4B 69 05 0422*      ld bc, (ubc)
       0B          
0B04D8 ED 5B 6C 05 0423*      ld de, (ude)
       0B          
0B04DD DD 2A 6F 05 0424*      ld ix, (uix)
       0B          
0B04E2 FD 2A 72 05 0425*      ld iy, (uiy)
       0B          
0B04E7 F1          0426*      pop af
0B04E8             0427*  ; all done
0B04E8 C9          0428*      ret
0B04E9             0429*  
0B04E9 20 61 66 3D 0430*  str_afu: db " af=",0
       00          
0B04EE 20 68 6C 3D 0431*  str_hlu: db " hl=",0
       00          
0B04F3 20 62 63 3D 0432*  str_bcu: db " bc=",0
       00          
0B04F8 20 64 65 3D 0433*  str_deu: db " de=",0
       00          
0B04FD 20 69 78 3D 0434*  str_ixu: db " ix=",0
       00          
0B0502 20 69 79 3D 0435*  str_iyu: db " iy=",0
       00          
0B0507             0436*  
0B0507             0437*  ; print udeuhl to screen in hexidecimal format
0B0507             0438*  ; inputs: none
0B0507             0439*  ; outputs: concatenated hexidecimal udeuhl
0B0507             0440*  ; destroys: nothing
0B0507             0441*  dumpUDEUHLHex:
0B0507             0442*  ; store everything in scratch
0B0507 22 66 05 0B 0443*      ld (uhl),hl
0B050B ED 43 69 05 0444*      ld (ubc),bc
       0B          
0B0510 ED 53 6C 05 0445*      ld (ude),de
       0B          
0B0515 DD 22 6F 05 0446*      ld (uix),ix
       0B          
0B051A FD 22 72 05 0447*      ld (uiy),iy
       0B          
0B051F F5          0448*      push af
0B0520             0449*  
0B0520             0450*  ; print each register
0B0520             0451*  
0B0520 21 5A 05 0B 0452*      ld hl,str_udeuhl
0B0524 CD 68 02 0B 0453*      call printString
0B0528 2A 6C 05 0B 0454*      ld hl,(ude)
0B052C CD 88 02 0B 0455*      call printHex24
0B0530 3E 2E       0456*  	ld a,'.'	; print a dot to separate the values
0B0532 5B D7       0457*  	rst.lil 10h
0B0534 2A 66 05 0B 0458*      ld hl,(uhl)
0B0538 CD 88 02 0B 0459*      call printHex24
0B053C CD 7D 02 0B 0460*      call printNewLine
0B0540             0461*  
0B0540             0462*  ; restore everything
0B0540 2A 66 05 0B 0463*      ld hl, (uhl)
0B0544 ED 4B 69 05 0464*      ld bc, (ubc)
       0B          
0B0549 ED 5B 6C 05 0465*      ld de, (ude)
       0B          
0B054E DD 2A 6F 05 0466*      ld ix, (uix)
       0B          
0B0553 FD 2A 72 05 0467*      ld iy, (uiy)
       0B          
0B0558 F1          0468*      pop af
0B0559             0469*  ; all done
0B0559 C9          0470*      ret
0B055A             0471*  
0B055A 75 64 65 2E 0472*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0563             0473*  
0B0563             0474*  ; global scratch memory for registers
0B0563 00 00 00    0475*  uaf: dl 0
0B0566 00 00 00    0476*  uhl: dl 0
0B0569 00 00 00    0477*  ubc: dl 0
0B056C 00 00 00    0478*  ude: dl 0
0B056F 00 00 00    0479*  uix: dl 0
0B0572 00 00 00    0480*  uiy: dl 0
0B0575 00 00 00    0481*  usp: dl 0
0B0578 00 00 00    0482*  upc: dl 0
0B057B             0483*  
0B057B             0484*  ; inputs: whatever is in the flags register
0B057B             0485*  ; outputs: binary representation of flags
0B057B             0486*  ;          with a header so we know which is what
0B057B             0487*  ; destroys: nothing
0B057B             0488*  ; preserves: everything
0B057B             0489*  dumpFlags:
0B057B             0490*  ; first we curse zilog for not giving direct access to flags
0B057B F5          0491*      push af ; this is so we can send it back unharmed
0B057C F5          0492*      push af ; this is so we can pop it to hl
0B057D             0493*  ; store everything in scratch
0B057D 22 66 05 0B 0494*      ld (uhl),hl
0B0581 ED 43 69 05 0495*      ld (ubc),bc
       0B          
0B0586 ED 53 6C 05 0496*      ld (ude),de
       0B          
0B058B DD 22 6F 05 0497*      ld (uix),ix
       0B          
0B0590 FD 22 72 05 0498*      ld (uiy),iy
       0B          
0B0595             0499*  ; next we print the header
0B0595 21 C1 05 0B 0500*      ld hl,@header
0B0599 CD 68 02 0B 0501*      call printString
0B059D E1          0502*      pop hl ; flags are now in l
0B059E 7D          0503*      ld a,l ; flags are now in a
0B059F CD 2F 03 0B 0504*      call printBin8
0B05A3 CD 7D 02 0B 0505*  	call printNewLine
0B05A7             0506*  ; restore everything
0B05A7 2A 66 05 0B 0507*      ld hl, (uhl)
0B05AB ED 4B 69 05 0508*      ld bc, (ubc)
       0B          
0B05B0 ED 5B 6C 05 0509*      ld de, (ude)
       0B          
0B05B5 DD 2A 6F 05 0510*      ld ix, (uix)
       0B          
0B05BA FD 2A 72 05 0511*      ld iy, (uiy)
       0B          
0B05BF F1          0512*      pop af ; send her home the way she came
0B05C0 C9          0513*      ret
0B05C1             0514*  ; Bit 7 (S): Sign flag
0B05C1             0515*  ; Bit 6 (Z): Zero flag
0B05C1             0516*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B05C1             0517*  ; Bit 4 (H): Half Carry flag
0B05C1             0518*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B05C1             0519*  ; Bit 2 (PV): Parity/Overflow flag
0B05C1             0520*  ; Bit 1 (N): Subtract flag
0B05C1             0521*  ; Bit 0 (C): Carry flag
0B05C1 53 5A 78 48 0522*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B05CC             0523*  
0B05CC             0524*  ; set all the bits in the flag register
0B05CC             0525*  ; more of an academic exercise than anything useful
0B05CC             0526*  ; inputs; none
0B05CC             0527*  ; outputs; a=0,f=255
0B05CC             0528*  ; destroys: flags, hl
0B05CC             0529*  ; preserves: a, because why not
0B05CC             0530*  setAllFlags:
0B05CC 21 FF 00 00 0531*      ld hl,255
0B05D0 67          0532*      ld h,a ; four cycles to preserve a is cheap
0B05D1 E5          0533*      push hl
0B05D2 F1          0534*      pop af
0B05D3 C9          0535*      ret
0B05D4             0536*  
0B05D4             0537*  ; reset all the bits in the flag register
0B05D4             0538*  ; unlike its inverse counterpart, this may actually be useful
0B05D4             0539*  ; inputs; none
0B05D4             0540*  ; outputs; a=0,f=0
0B05D4             0541*  ; destroys: flags, hl
0B05D4             0542*  ; preserves: a, because why not
0B05D4             0543*  resetAllFlags:
0B05D4 21 00 00 00 0544*      ld hl,0
0B05D8 67          0545*      ld h,a ; four cycles to preserve a is cheap
0B05D9 E5          0546*      push hl
0B05DA F1          0547*      pop af
0B05DB C9          0548*      ret
0B05DC             0549*  
0B05DC             0550*  ; wait until user presses a key
0B05DC             0551*  ; inputs: none
0B05DC             0552*  ; outputs: none
0B05DC             0553*  ; destroys: af,ix
0B05DC             0554*  waitKeypress:
0B05DC             0555*      MOSCALL mos_sysvars
0B05DC 3E 08       0001*M 			LD	A, function
0B05DE 5B CF       0002*M 			RST.L	08h
0B05E0 AF          0556*      xor a ; zero out any prior keypresses
0B05E1 DD 77 05    0557*      ld (ix+sysvar_keyascii),a
0B05E4             0558*  @loop:
0B05E4 DD 7E 05    0559*      ld a,(ix+sysvar_keyascii)
0B05E7 A7          0560*      and a
0B05E8 C0          0561*      ret nz
0B05E9 18 F9       0562*      jr @loop
0B05EB             0563*  
0B05EB             0564*  
0B05EB             0565*  ; print bytes from an address to the screen in hexidecimal format
0B05EB             0566*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B05EB             0567*  ; outputs: values of each byte printed to screen separated by spaces
0B05EB             0568*  ; destroys: nothing
0B05EB             0569*  dumpMemoryHex:
0B05EB             0570*  ; save registers to the stack
0B05EB C5          0571*      push bc
0B05EC E5          0572*      push hl
0B05ED F5          0573*      push af
0B05EE             0574*  
0B05EE             0575*  ; print the address and separator
0B05EE CD 88 02 0B 0576*      call printHex24
0B05F2 3E 3A       0577*      ld a,':'
0B05F4 5B D7       0578*      rst.lil 10h
0B05F6 3E 20       0579*      ld a,' '
0B05F8 5B D7       0580*      rst.lil 10h
0B05FA             0581*  
0B05FA             0582*  ; set b to be our loop counter
0B05FA F1          0583*      pop af
0B05FB 47          0584*      ld b,a
0B05FC E1          0585*      pop hl
0B05FD E5          0586*      push hl
0B05FE F5          0587*      push af
0B05FF             0588*  @loop:
0B05FF             0589*  ; print the byte
0B05FF 7E          0590*      ld a,(hl)
0B0600 CD 9A 02 0B 0591*      call printHex8
0B0604             0592*  ; print a space
0B0604 3E 20       0593*      ld a,' '
0B0606 5B D7       0594*      rst.lil 10h
0B0608 23          0595*      inc hl
0B0609 10 F4       0596*      djnz @loop
0B060B             0597*      ; call printNewLine
0B060B             0598*  
0B060B             0599*  ; restore everything
0B060B F1          0600*      pop af
0B060C E1          0601*      pop hl
0B060D C1          0602*      pop bc
0B060E             0603*  
0B060E             0604*  ; all done
0B060E C9          0605*      ret
0B060F             0606*  
0B060F             0607*  
0B060F             0608*  ; print bytes from an address to the screen in binary format
0B060F             0609*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B060F             0610*  ; outputs: values of each byte printed to screen separated by spaces
0B060F             0611*  ; destroys: nothing
0B060F             0612*  dumpMemoryBin:
0B060F             0613*  ; save all registers to the stack
0B060F F5          0614*      push af
0B0610 C5          0615*      push bc
0B0611 D5          0616*      push de
0B0612 E5          0617*      push hl
0B0613 DD E5       0618*      push ix
0B0615 FD E5       0619*      push iy
0B0617             0620*  
0B0617             0621*  ; set b to be our loop counter
0B0617 47          0622*      ld b,a
0B0618             0623*  @loop:
0B0618             0624*  ; print the byte
0B0618 7E          0625*      ld a,(hl)
0B0619 E5          0626*      push hl
0B061A C5          0627*      push bc
0B061B CD 2F 03 0B 0628*      call printBin8
0B061F C1          0629*      pop bc
0B0620             0630*  ; print a space
0B0620 3E 20       0631*      ld a,' '
0B0622 5B D7       0632*      rst.lil 10h
0B0624 E1          0633*      pop hl
0B0625 23          0634*      inc hl
0B0626 10 F0       0635*      djnz @loop
0B0628 CD 7D 02 0B 0636*      call printNewLine
0B062C             0637*  
0B062C             0638*  ; restore everything
0B062C FD E1       0639*      pop iy
0B062E DD E1       0640*      pop ix
0B0630 E1          0641*      pop hl
0B0631 D1          0642*      pop de
0B0632 C1          0643*      pop bc
0B0633 F1          0644*      pop af
0B0634             0645*  ; all done
0B0634 C9          0646*      ret
0B0635             0647*  
0B0635             0648*  ; print bytes from an address to the screen in binary format
0B0635             0649*  ; with the bits of each byte in reverse order (lsb first)
0B0635             0650*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0635             0651*  ; outputs: values of each byte printed to screen separated by spaces
0B0635             0652*  ; destroys: nothing
0B0635             0653*  dumpMemoryBinRev:
0B0635             0654*  ; save all registers to the stack
0B0635 F5          0655*      push af
0B0636 C5          0656*      push bc
0B0637 D5          0657*      push de
0B0638 E5          0658*      push hl
0B0639 DD E5       0659*      push ix
0B063B FD E5       0660*      push iy
0B063D             0661*  
0B063D             0662*  ; set b to be our loop counter
0B063D 47          0663*      ld b,a
0B063E             0664*  @loop:
0B063E             0665*  ; print the byte
0B063E 7E          0666*      ld a,(hl)
0B063F E5          0667*      push hl
0B0640 C5          0668*      push bc
0B0641 CD 54 03 0B 0669*      call printBin8Rev
0B0645 C1          0670*      pop bc
0B0646             0671*  ; print a space
0B0646 3E 20       0672*      ld a,' '
0B0648 5B D7       0673*      rst.lil 10h
0B064A E1          0674*      pop hl
0B064B 23          0675*      inc hl
0B064C 10 F0       0676*      djnz @loop
0B064E CD 7D 02 0B 0677*      call printNewLine
0B0652             0678*  
0B0652             0679*  ; restore everything
0B0652 FD E1       0680*      pop iy
0B0654 DD E1       0681*      pop ix
0B0656 E1          0682*      pop hl
0B0657 D1          0683*      pop de
0B0658 C1          0684*      pop bc
0B0659 F1          0685*      pop af
0B065A             0686*  ; all done
0B065A C9          0687*      ret
0B065B             0020       include "../moslets/files.inc"
0B065B             0001*  ; load to onboard 8k sram
0B065B             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B065B             0021       include "../moslets/timer.inc"
0B065B             0001*  ; Table 32. Timer Control Registers
0B065B             0002*  ; this constant is the base address of the timer control registers
0B065B             0003*  ; each timer takes three bytes:
0B065B             0004*  ;   0: control register
0B065B             0005*  ;   1: low byte of timer reset value
0B065B             0006*  ;   2: high byte of timer reset value
0B065B             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B065B             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B065B             0009*  TMR_CTL:     equ 80h
0B065B             0010*  
0B065B             0011*  ; Timer Control Register Bit Definitions
0B065B             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B065B             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B065B             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B065B             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B065B             0016*                              ; the TMRx_CTL register is read.
0B065B             0017*  
0B065B             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B065B             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B065B             0020*  
0B065B             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B065B             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B065B             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B065B             0024*                              ; written to the counter when the end-of-count value is reached.
0B065B             0025*  
0B065B             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B065B             0027*  CLK_DIV_256:  equ %00001100 ;
0B065B             0028*  CLK_DIV_64:   equ %00001000 ;
0B065B             0029*  CLK_DIV_16:   equ %00000100 ;
0B065B             0030*  CLK_DIV_4:    equ %00000000 ;
0B065B             0031*  
0B065B             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B065B             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B065B             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B065B             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B065B             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B065B             0037*                              ; SINGLE-PASS mode is used.
0B065B             0038*  
0B065B             0039*  ; disable/enable the programmable reload timer
0B065B             0040*  PRT_EN_0:     equ %00000000 ;
0B065B             0041*  PRT_EN_1:     equ %00000001 ;
0B065B             0042*  
0B065B             0043*  ; Table 37. Timer Input Source Select Register
0B065B             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B065B             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B065B             0046*  ;   00: System clock / CLK_DIV
0B065B             0047*  ;   01: RTC / CLK_DIV
0B065B             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B065B             0049*  ;   10: GPIO port B pin 1.
0B065B             0050*  ;   11: GPIO port B pin 1.
0B065B             0051*  TMR_ISS:   equ 92h ; register address
0B065B             0052*  
0B065B             0053*  ; Table 51. Real-Time Clock Control Register
0B065B             0054*  RTC_CTRL: equ EDh ; register address
0B065B             0055*  
0B065B             0056*  ; alarm interrupt disable/enable
0B065B             0057*  RTC_ALARM_0:    equ %00000000
0B065B             0058*  RTC_ALARM_1:    equ %10000000
0B065B             0059*  
0B065B             0060*  ; interrupt on alarm disable/enable
0B065B             0061*  RTC_INT_ENT_0:  equ %00000000
0B065B             0062*  RTC_INT_ENT_1:  equ %01000000
0B065B             0063*  
0B065B             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B065B             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B065B             0066*  
0B065B             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B065B             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B065B             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B065B             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B065B             0071*  
0B065B             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B065B             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B065B             0074*  
0B065B             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B065B             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B065B             0077*  
0B065B             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B065B             0079*                                  ; RTC counter is enabled.
0B065B             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B065B             0081*                                  ; RTC counter is disabled.
0B065B             0082*  
0B065B             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B065B             0084*  
0B065B             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B065B             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B065B 00 00 00    0087*  prt_reload: dl 0x000000
0B065E             0088*  
0B065E             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B065E             0090*  ; ;          de = number PRT interrupts during test interval
0B065E             0091*  ; prt_calibrate:
0B065E             0092*  ;     call vdu_vblank
0B065E             0093*  ; ; set a MOS timer
0B065E             0094*  ;     ld hl,120*1 ; 1 second
0B065E             0095*  ;     ld iy,tmr_test
0B065E             0096*  ;     call tmr_set
0B065E             0097*  ; ; set a PRT timer
0B065E             0098*  ;     ; ld hl,prt_reload_hardware
0B065E             0099*  ;     ; ld hl,prt_reload_emulator
0B065E             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B065E             0101*  ;     ld (prt_reload),hl
0B065E             0102*  ;     call prt_set
0B065E             0103*  ; @loop:
0B065E             0104*  ; ; check time remaining on MOS timer
0B065E             0105*  ;     call tmr_get
0B065E             0106*  ;     jp z,@done ; time expired,so quit
0B065E             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B065E             0108*  ;     jr @loop
0B065E             0109*  ; @done:
0B065E             0110*  ;     ld de,(prt_irq_counter)
0B065E             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B065E             0112*  ;     ld (prt_reload),bc
0B065E             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B065E             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B065E             0115*  ;     ld (is_emulator),a
0B065E             0116*  ;     sbc hl,de
0B065E             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B065E             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B065E             0119*  ;     ret m ; negative result means we're on hardware
0B065E             0120*  ;     inc a ; we're on emulator
0B065E             0121*  ;     ld (is_emulator),a
0B065E             0122*  ;     ld bc,prt_reload_emulator
0B065E             0123*  ;     ld (prt_reload),bc
0B065E             0124*  ;     ld hl,on_emulator
0B065E             0125*  ;     ret
0B065E             0126*  
0B065E             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B065E             0128*  
0B065E             0129*  ; set PRT timer
0B065E             0130*  prt_set:
0B065E 21 00 00 00 0131*      ld hl,0
0B0662 22 AC 06 0B 0132*      ld (prt_irq_counter),hl
0B0666 2A 5B 06 0B 0133*      ld hl,(prt_reload)
0B066A ED 29 84    0134*      out0 ($84),l
0B066D ED 21 85    0135*  	out0 ($85),h
0B0670             0136*  ; disable timer
0B0670 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B0672 ED 39 83    0138*  	out0 ($83),a
0B0675             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B0675 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B0677 ED 39 83    0141*  	out0 ($83),a
0B067A C9          0142*      ret
0B067B             0143*  
0B067B             0144*  ; ===============================================
0B067B             0145*  ; PRT Timer Interrupt Handling
0B067B             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B067B             0147*  ; -----------------------------------------------
0B067B             0148*  prt_irq_init:
0B067B             0149*      ; set up interrupt vector table 2
0B067B 21 00 00 00 0150*  	ld hl,0
0B067F 3A 0C 01 00 0151*  	ld a,($10c)
0B0683 6F          0152*  	ld l,a
0B0684 3A 0D 01 00 0153*  	ld a,($10d)
0B0688 67          0154*  	ld h,a
0B0689             0155*  
0B0689             0156*  	; skip over CALL ($c3)
0B0689 23          0157*  	inc hl
0B068A             0158*  	; load address of jump into vector table 2 (in ram)
0B068A ED 27       0159*  	ld hl,(hl)
0B068C             0160*  
0B068C             0161*  	; write CALL prt_irq_handler to vector table 2
0B068C 3E C3       0162*  	ld a,$c3
0B068E 77          0163*  	ld (hl),a
0B068F 23          0164*  	inc hl
0B0690 11 97 06 0B 0165*  	ld de,prt_irq_handler
0B0694 ED 1F       0166*  	ld (hl),de
0B0696             0167*  
0B0696 C9          0168*      ret
0B0697             0169*  
0B0697             0170*  prt_irq_handler:
0B0697 F3          0171*  	di
0B0698 F5          0172*  	push af
0B0699 E5          0173*      push hl
0B069A ED 38 83    0174*  	in0 a,($83)
0B069D 2A AC 06 0B 0175*  	ld hl,(prt_irq_counter)
0B06A1 23          0176*  	inc hl
0B06A2 22 AC 06 0B 0177*  	ld (prt_irq_counter),hl
0B06A6 E1          0178*      pop hl
0B06A7 F1          0179*  	pop af
0B06A8 FB          0180*  	ei
0B06A9 5B ED 4D    0181*  	reti.l
0B06AC             0182*  
0B06AC             0183*  prt_irq_counter:
0B06AC 00 00 00    0184*  	.dl 0
0B06AF             0185*  prt_irq_counter_saved:
0B06AF 00 00 00    0186*      .dl 0
0B06B2             0187*  
0B06B2             0188*  prt_loop_reset:
0B06B2 E5          0189*      push hl
0B06B3 21 00 00 00 0190*  	ld hl,0
0B06B7 22 AC 06 0B 0191*  	ld (prt_irq_counter),hl
0B06BB 22 1D 07 0B 0192*      ld (prt_loop_counter),hl
0B06BF 22 20 07 0B 0193*      ld (prt_loops),hl
0B06C3 CD 5E 06 0B 0194*      call prt_set
0B06C7 E1          0195*      pop hl
0B06C8 C9          0196*      ret
0B06C9             0197*  
0B06C9             0198*  prt_loop_start:
0B06C9 E5          0199*      push hl
0B06CA 21 00 00 00 0200*  	ld hl,0
0B06CE 22 AC 06 0B 0201*  	ld (prt_irq_counter),hl
0B06D2 E1          0202*      pop hl
0B06D3 C9          0203*      ret
0B06D4             0204*  
0B06D4             0205*  prt_loop_stop:
0B06D4 E5          0206*      push hl
0B06D5 D5          0207*      push de
0B06D6 2A AC 06 0B 0208*      ld hl,(prt_irq_counter)
0B06DA ED 5B 1D 07 0209*      ld de,(prt_loop_counter)
       0B          
0B06DF 19          0210*      add hl,de
0B06E0 22 1D 07 0B 0211*      ld (prt_loop_counter),hl
0B06E4 21 00 00 00 0212*      ld hl,0
0B06E8 22 AC 06 0B 0213*      ld (prt_irq_counter),hl
0B06EC 2A 20 07 0B 0214*      ld hl,(prt_loops)
0B06F0 23          0215*      inc hl
0B06F1 22 20 07 0B 0216*      ld (prt_loops),hl
0B06F5 D1          0217*      pop de
0B06F6 E1          0218*      pop hl
0B06F7 C9          0219*      ret
0B06F8             0220*  
0B06F8             0221*  ; inputs: bc = y,x text coordinates to print
0B06F8             0222*  prt_loop_print:
0B06F8 F5          0223*      push af
0B06F9 E5          0224*      push hl
0B06FA C5          0225*      push bc
0B06FB D5          0226*      push de
0B06FC DD E5       0227*      push ix
0B06FE FD E5       0228*      push iy
0B0700 CD 15 08 0B 0229*      call vdu_move_cursor
0B0704             0230*  
0B0704 2A 1D 07 0B 0231*      ld hl,(prt_loop_counter)
0B0708 CD B8 02 0B 0232*      call printDec
0B070C             0233*  
0B070C 2A 20 07 0B 0234*      ld hl,(prt_loops)
0B0710 CD B8 02 0B 0235*      call printDec
0B0714             0236*  
0B0714 FD E1       0237*      pop iy
0B0716 DD E1       0238*      pop ix
0B0718 D1          0239*      pop de
0B0719 C1          0240*      pop bc
0B071A E1          0241*      pop hl
0B071B F1          0242*      pop af
0B071C C9          0243*      ret
0B071D             0244*  
0B071D             0245*  prt_loop_counter:
0B071D 00 00 00    0246*      .dl 0
0B0720             0247*  prt_loops:
0B0720 00 00 00    0248*      .dl 0
0B0723             0249*  
0B0723             0250*  ; ===============================================
0B0723             0251*  ; Timer functions
0B0723             0252*  ; -----------------------------------------------
0B0723             0253*  ; set a countdown timer
0B0723             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0723             0255*  ; returns: hl = current time
0B0723             0256*  tmr_set:
0B0723 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B0726             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0726 3E 08       0001*M 			LD	A, function
0B0728 5B CF       0002*M 			RST.L	08h
0B072A DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B072D FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B0730 C9          0261*      ret
0B0731             0262*  
0B0731             0263*  ; gets time remaining on a countdown timer
0B0731             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0731             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0731             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0731             0267*  tmr_get:
0B0731             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0731 3E 08       0001*M 			LD	A, function
0B0733 5B CF       0002*M 			RST.L	08h
0B0735 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B0738 FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B073B AF          0271*      xor a                   ; clear carry
0B073C ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B073E FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B0741 AF          0274*      xor a                   ; clear carry
0B0742 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B0744             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0744 C9          0277*      ret
0B0745             0278*  
0B0745 00 00 00    0279*  timestamp_now: dl 0
0B0748 00 00 00    0280*  timestamp_old: dl 0
0B074B 00 00 00    0281*  timestamp_chg: dl 0
0B074E             0282*  
0B074E             0283*  ; update the global timestamp from the system clock
0B074E             0284*  ; inputs: none
0B074E             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B074E             0286*  ;          de = current time
0B074E             0287*  ;          ix = pointer to syvars table
0B074E             0288*  ; destroys: af,hl,de,ix
0B074E             0289*  timestamp_tick:
0B074E ED 5B 45 07 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B0753 ED 53 48 07 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B0758             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0758 3E 08       0001*M 			LD	A, function
0B075A 5B CF       0002*M 			RST.L	08h
0B075C DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B075F 22 45 07 0B 0294*      ld (timestamp_now),hl   ; save current time
0B0763 AF          0295*      xor a                   ; clear carry
0B0764 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B0766 22 4B 07 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B076A C9          0298*      ret
0B076B             0299*  
0B076B             0300*  ; set a countdown timer
0B076B             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B076B             0302*  ; requires: timestamp_tick to be called at least once before this function
0B076B             0303*  ; returns: hl = current time
0B076B             0304*  ; destroys: hl
0B076B             0305*  timestamp_tmr_set:
0B076B FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B076E 2A 45 07 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B0772 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B0775 C9          0309*      ret
0B0776             0310*  
0B0776             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B0776             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0776             0313*  ; requires: timestamp_tick to be called at least once before this function
0B0776             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0776             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0776             0316*  ; destroys: af,hl,de
0B0776             0317*  timestamp_tmr_get:
0B0776 ED 5B 45 07 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B077B FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B077E AF          0320*      xor a                   ; clear carry
0B077F ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0781 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B0784 AF          0323*      xor a                   ; clear carry
0B0785 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B0787             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0787 C9          0326*      ret
0B0788             0327*  
0B0788             0328*  ; main loop timer functions
0B0788             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B078E             0330*  
0B078E             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B078E             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B078E             0333*  ; returns: hl = current time
0B078E             0334*  ; destroys: af,hl,de,ix,iy
0B078E             0335*  tmr_main_loop_set:
0B078E FD 21 88 07 0336*      ld iy,tmr_main_loop
       0B          
0B0793 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B0796 CD 4E 07 0B 0338*      call timestamp_tick
0B079A 2A 45 07 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B079E FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B07A1 C9          0341*      ret
0B07A2             0342*  
0B07A2             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B07A2             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B07A2             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B07A2             0346*  ; destroys: af,hl,de,ix,iy
0B07A2             0347*  tmr_main_loop_get:
0B07A2 CD 4E 07 0B 0348*      call timestamp_tick
0B07A6 FD 21 88 07 0349*      ld iy,tmr_main_loop
       0B          
0B07AB CD 76 07 0B 0350*      call timestamp_tmr_get
0B07AF C9          0351*      ret
0B07B0             0352*  
0B07B0             0353*  ; set a stopwatch
0B07B0             0354*  ; returns: hl = start time
0B07B0             0355*  ; destroys: hl,ix
0B07B0             0356*  stopwatch_set:
0B07B0             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07B0 3E 08       0001*M 			LD	A, function
0B07B2 5B CF       0002*M 			RST.L	08h
0B07B4 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B07B7 22 CC 07 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B07BB C9          0360*      ret
0B07BC             0361*  
0B07BC             0362*  ; gets time elapsed on a stopwatch
0B07BC             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B07BC             0364*  ; destroys: af,hl,de,ix
0B07BC             0365*  stopwatch_get:
0B07BC             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B07BC 3E 08       0001*M 			LD	A, function
0B07BE 5B CF       0002*M 			RST.L	08h
0B07C0 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B07C3 ED 5B CC 07 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B07C8 AF          0369*      xor a                   ; clear carry
0B07C9 ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B07CB C9          0371*      ret
0B07CC             0372*  
0B07CC             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B07CF             0374*  
0B07CF             0375*  ; ------------------
0B07CF             0376*  ; delay routine
0B07CF             0377*  ; Author: Richard Turrnidge
0B07CF             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B07CF             0379*  ; routine waits a fixed time,then returns
0B07CF             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B07CF             0381*  ; eg. ld A,00000100b
0B07CF             0382*  
0B07CF             0383*  multiPurposeDelay:
0B07CF F5          0384*      push af
0B07D0 C5          0385*      push bc
0B07D1 DD E5       0386*      push ix
0B07D3 47          0387*      ld b,a
0B07D4 3E 08       0388*      ld a,$08
0B07D6 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B07D8             0390*  
0B07D8             0391*  waitLoop:
0B07D8             0392*  
0B07D8 DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B07DB             0394*  
0B07DB             0395*                                  ;   we check if bit set is same as last time we checked.
0B07DB             0396*                                  ;   bit 0 - don't use
0B07DB             0397*                                  ;   bit 1 - changes 64 times per second
0B07DB             0398*                                  ;   bit 2 - changes 32 times per second
0B07DB             0399*                                  ;   bit 3 - changes 16 times per second
0B07DB             0400*  
0B07DB             0401*                                  ;   bit 4 - changes 8 times per second
0B07DB             0402*                                  ;   bit 5 - changes 4 times per second
0B07DB             0403*                                  ;   bit 6 - changes 2 times per second
0B07DB             0404*                                  ;   bit 7 - changes 1 times per second
0B07DB A0          0405*      and b
0B07DC 4F          0406*      ld c,a
0B07DD 3A EE 07 0B 0407*      ld a,(oldTimeStamp)
0B07E1 B9          0408*      cp c                        ; is A same as last value?
0B07E2 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B07E4 79          0410*      ld a,c
0B07E5 32 EE 07 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B07E9             0412*  
0B07E9 DD E1       0413*      pop ix
0B07EB C1          0414*      pop bc
0B07EC F1          0415*      pop af
0B07ED C9          0416*      ret
0B07EE             0417*  
0B07EE 00          0418*  oldTimeStamp:   .db 00h
0B07EF             0022       include "../moslets/vdu.inc"
0B07EF             0001*  
0B07EF             0002*  ; VDU 30: Home cursor
0B07EF             0003*  vdu_home_cursor:
0B07EF 3E 1E       0004*      ld a,30
0B07F1 5B D7       0005*  	rst.lil $10
0B07F3 C9          0006*  	ret
0B07F4             0007*  
0B07F4             0008*  cursor_on:
0B07F4 21 FF 07 0B 0009*  	ld hl,@cmd
0B07F8 01 03 00 00 0010*  	ld bc,@end-@cmd
0B07FC 5B DF       0011*  	rst.lil $18
0B07FE C9          0012*  	ret
0B07FF             0013*  @cmd:
0B07FF 17 01 01    0014*  	db 23,1,1
0B0802             0015*  @end:
0B0802             0016*  
0B0802             0017*  cursor_off:
0B0802 21 0D 08 0B 0018*  	ld hl,@cmd
0B0806 01 03 00 00 0019*  	ld bc,@end-@cmd
0B080A 5B DF       0020*  	rst.lil $18
0B080C C9          0021*  	ret
0B080D             0022*  @cmd:
0B080D 17 01 00    0023*  	db 23,1,0
0B0810             0024*  @end:
0B0810             0025*  
0B0810             0026*  ; VDU 9: Move cursor forward one character
0B0810             0027*  vdu_cursor_forward:
0B0810 3E 09       0028*      ld a,9
0B0812 5B D7       0029*  	rst.lil $10
0B0814 C9          0030*  	ret
0B0815             0031*  
0B0815             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B0815             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B0815             0034*  vdu_move_cursor:
0B0815 ED 43 26 08 0035*      ld (@x0),bc
       0B          
0B081A 21 25 08 0B 0036*  	ld hl,@cmd
0B081E 01 03 00 00 0037*  	ld bc,@end-@cmd
0B0822 5B DF       0038*  	rst.lil $18
0B0824 C9          0039*  	ret
0B0825 1F          0040*  @cmd: 	db 31
0B0826 00          0041*  @x0:	db 0
0B0827 00          0042*  @y0: 	db 0
0B0828 00          0043*  @end: 	db 0 ; padding
0B0829             0044*  
0B0829             0045*  ; VDU 12: Clear text area (CLS)
0B0829             0046*  vdu_cls:
0B0829 3E 0C       0047*      ld a,12
0B082B 5B D7       0048*  	rst.lil $10
0B082D C9          0049*  	ret
0B082E             0050*  
0B082E             0051*  vdu_flip:
0B082E 21 39 08 0B 0052*  	ld hl,@cmd
0B0832 01 03 00 00 0053*  	ld bc,@end-@cmd
0B0836 5B DF       0054*  	rst.lil $18
0B0838 C9          0055*  	ret
0B0839 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B083C             0057*  @end:
0B083C             0058*  
0B083C             0059*  ; VDU 16: Clear graphics area (CLG)
0B083C             0060*  vdu_clg:
0B083C 3E 10       0061*      ld a,16
0B083E 5B D7       0062*  	rst.lil $10
0B0840 C9          0063*  	ret
0B0841             0064*  
0B0841             0065*  ; COLOUR MODES
0B0841             0066*  ; Mode	Effect
0B0841             0067*  ; 0	Set on-screen pixel to target colour value
0B0841             0068*  ; 1	OR value with the on-screen pixel
0B0841             0069*  ; 2	AND value with the on-screen pixel
0B0841             0070*  ; 3	XOR value with the on-screen pixel
0B0841             0071*  ; 4	Invert the on-screen pixel
0B0841             0072*  ; 5	No operation
0B0841             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B0841             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B0841             0075*  
0B0841             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B0841             0077*  vdu_colour_text:
0B0841 32 51 08 0B 0078*  	ld (@arg),a
0B0845 21 50 08 0B 0079*  	ld hl,@cmd
0B0849 01 02 00 00 0080*  	ld bc,@end-@cmd
0B084D 5B DF       0081*  	rst.lil $18
0B084F C9          0082*  	ret
0B0850 11          0083*  @cmd: db 17
0B0851 00          0084*  @arg: db 0
0B0852             0085*  @end:
0B0852             0086*  
0B0852             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B0852             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B0852             0089*  vdu_gcol:
0B0852 32 67 08 0B 0090*  	ld (@mode),a
0B0856 79          0091*      ld a,c
0B0857 32 68 08 0B 0092*      ld (@col),a
0B085B 21 66 08 0B 0093*  	ld hl,@cmd
0B085F 01 03 00 00 0094*  	ld bc,@end-@cmd
0B0863 5B DF       0095*  	rst.lil $18
0B0865 C9          0096*  	ret
0B0866 12          0097*  @cmd:  db 18
0B0867 00          0098*  @mode: db 0
0B0868 00          0099*  @col:  db 0
0B0869             0100*  @end:
0B0869             0101*  
0B0869             0102*  
0B0869             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B0869             0104*  ; MIND THE LITTLE-ENDIANESS
0B0869             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B0869             0106*  ; outputs; nothing
0B0869             0107*  ; destroys: a might make it out alive
0B0869             0108*  vdu_set_txt_viewport:
0B0869 ED 43 7F 08 0109*      ld (@lb),bc
       0B          
0B086E ED 53 81 08 0110*  	ld (@rt),de
       0B          
0B0873 21 7E 08 0B 0111*  	ld hl,@cmd
0B0877 01 05 00 00 0112*  	ld bc,@end-@cmd
0B087B 5B DF       0113*  	rst.lil $18
0B087D C9          0114*  	ret
0B087E 1C          0115*  @cmd:   db 28 ; set text viewport command
0B087F 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B0881 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B0883 00          0118*  @end:   db 0x00	  ; padding
0B0884             0119*  
0B0884             0120*  ; Wait for VBLANK interrupt
0B0884             0121*  vdu_vblank:
0B0884 DD E5       0122*      PUSH 	IX
0B0886             0123*  	MOSCALL	mos_sysvars
0B0886 3E 08       0001*M 			LD	A, function
0B0888 5B CF       0002*M 			RST.L	08h
0B088A DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B088D             0125*  @wait:
0B088D DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B0890 28 FB       0127*      JR	Z, @wait
0B0892 DD E1       0128*      POP	IX
0B0894 C9          0129*      RET
0B0895             0130*  
0B0895             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B0895             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B0895             0133*  ; 	because we have turned off logical screen scaling
0B0895             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B0895             0135*  ; outputs; nothing
0B0895             0136*  ; destroys: a might make it out alive
0B0895             0137*  vdu_set_gfx_viewport:
0B0895 ED 43 B5 08 0138*      ld (@x0),bc
       0B          
0B089A FD 22 B7 08 0139*      ld (@y1),iy
       0B          
0B089F DD 22 B9 08 0140*  	ld (@x1),ix
       0B          
0B08A4 ED 53 BB 08 0141*  	ld (@y0),de
       0B          
0B08A9 21 B4 08 0B 0142*  	ld hl,@cmd
0B08AD 01 09 00 00 0143*  	ld bc,@end-@cmd
0B08B1 5B DF       0144*  	rst.lil $18
0B08B3 C9          0145*  	ret
0B08B4 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B08B5 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B08B7 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B08B9 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B08BB 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B08BD 00          0151*  @end:   db 0x00	  ; padding
0B08BE             0152*  
0B08BE             0153*  ; SCREEN MODES
0B08BE             0154*  ; ===============================
0B08BE             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B08BE             0156*  ; ---   ----  ----  ----  -------
0B08BE             0157*  ; 11    320   240   2     60hz
0B08BE             0158*  ; 139   320   240   2     60hz
0B08BE             0159*  ; 23    512   384   2     60hz
0B08BE             0160*  ; 151   512   384   2     60hz
0B08BE             0161*  ; 6     640   240   2     60hz
0B08BE             0162*  ; 134   640   240   2     60hz
0B08BE             0163*  ; 2     640   480   2     60hz
0B08BE             0164*  ; 130   640   480   2     60hz
0B08BE             0165*  ; 17    800   600   2     60hz
0B08BE             0166*  ; 145   800   600   2     60hz
0B08BE             0167*  ; 18    1024  768   2     60hz
0B08BE             0168*  ; 146   1024  768   2     60hz
0B08BE             0169*  ; ---   ----  ----  ----  -------
0B08BE             0170*  ; 10    320   240   4     60hz
0B08BE             0171*  ; 138   320   240   4     60hz
0B08BE             0172*  ; 22    512   384   4     60hz
0B08BE             0173*  ; 150   512   384   4     60hz
0B08BE             0174*  ; 5     640   240   4     60hz
0B08BE             0175*  ; 133   640   240   4     60hz
0B08BE             0176*  ; 1     640   480   4     60hz
0B08BE             0177*  ; 129   640   480   4     60hz
0B08BE             0178*  ; 16    800   600   4     60hz
0B08BE             0179*  ; 19    1024  768   4     60hz
0B08BE             0180*  ; ---   ----  ----  ----  -------
0B08BE             0181*  ; 9     320   240   16    60hz
0B08BE             0182*  ; 137   320   240   16    60hz
0B08BE             0183*  ; 21    512   384   16    60hz
0B08BE             0184*  ; 149   512   384   16    60hz
0B08BE             0185*  ; 4     640   240   16    60hz
0B08BE             0186*  ; 132   640   240   16    60hz
0B08BE             0187*  ; 0     640   480   16    60hz
0B08BE             0188*  ; 7     n/a   n/a   16    60hz
0B08BE             0189*  ; ---   ----  ----  ----  -------
0B08BE             0190*  ; 8     320   240   64    60hz
0B08BE             0191*  ; 136   320   240   64    60hz
0B08BE             0192*  ; 20    512   384   64    60hz
0B08BE             0193*  ; 3     640   240   64    60hz
0B08BE             0194*  ; ---   ----  ----  ----  -------
0B08BE             0195*  vdu_set_screen_mode:
0B08BE 32 CE 08 0B 0196*  	ld (@arg),a
0B08C2 21 CD 08 0B 0197*  	ld hl,@cmd
0B08C6 01 02 00 00 0198*  	ld bc,@end-@cmd
0B08CA 5B DF       0199*  	rst.lil $18
0B08CC C9          0200*  	ret
0B08CD 16          0201*  @cmd: db 22 ; set screen mode
0B08CE 00          0202*  @arg: db 0  ; screen mode parameter
0B08CF             0203*  @end:
0B08CF             0204*  
0B08CF             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B08CF             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B08CF             0207*  ; note: default setting on boot is scaling ON
0B08CF             0208*  vdu_set_scaling:
0B08CF 32 E1 08 0B 0209*  	ld (@arg),a
0B08D3 21 DE 08 0B 0210*  	ld hl,@cmd
0B08D7 01 04 00 00 0211*  	ld bc,@end-@cmd
0B08DB 5B DF       0212*  	rst.lil $18
0B08DD C9          0213*  	ret
0B08DE 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B08E1 00          0215*  @arg: db 0  ; scaling on/off
0B08E2             0216*  @end:
0B08E2             0217*  
0B08E2             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B08E2             0219*  ; inputs: hl=bufferId
0B08E2             0220*  vdu_buff_select:
0B08E2 22 F4 08 0B 0221*  	ld (@bufferId),hl
0B08E6 21 F1 08 0B 0222*  	ld hl,@cmd
0B08EA 01 05 00 00 0223*  	ld bc,@end-@cmd
0B08EE 5B DF       0224*  	rst.lil $18
0B08F0 C9          0225*  	ret
0B08F1 17 1B 20    0226*  @cmd: db 23,27,0x20
0B08F4 00 00       0227*  @bufferId: dw 0x0000
0B08F6 00          0228*  @end: db 0x00 ; padding
0B08F7             0229*  
0B08F7             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B08F7             0231*  ; inputs: a=format; bc=width; de=height
0B08F7             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B08F7             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B08F7             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B08F7             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B08F7             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B08F7             0237*  ; 3 	Reserved for internal use by VDP (native format)
0B08F7             0238*  vdu_bmp_create:
0B08F7 ED 43 13 09 0239*      ld (@width),bc
       0B          
0B08FC ED 53 15 09 0240*      ld (@height),de
       0B          
0B0901 32 17 09 0B 0241*      ld (@fmt),a
0B0905 21 10 09 0B 0242*  	ld hl,@cmd
0B0909 01 08 00 00 0243*  	ld bc,@end-@cmd
0B090D 5B DF       0244*  	rst.lil $18
0B090F C9          0245*  	ret
0B0910 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B0913 00 00       0247*  @width:     dw 0x0000
0B0915 00 00       0248*  @height:    dw 0x0000
0B0917 00          0249*  @fmt:       db 0x00
0B0918             0250*  @end:
0B0918             0251*  
0B0918             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B0918             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B0918             0254*  vdu_load_img_rgba2_to_8:
0B0918             0255*  ; backup the target buffer id and image dimensions
0B0918 E5          0256*      push hl
0B0919 D5          0257*      push de
0B091A C5          0258*      push bc
0B091B             0259*  ; load the rgba2 image to working buffer 65534
0B091B 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B091F CD 22 0A 0B 0261*  	call vdu_load_buffer_from_file
0B0923             0262*  ; restore the image dimensions and target buffer id
0B0923 C1          0263*      pop bc
0B0924 D1          0264*      pop de
0B0925 E1          0265*      pop hl
0B0926             0266*  ; fall through to vdu_rgba2_to_8
0B0926             0267*  
0B0926             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B0926             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B0926             0270*  ; the "expand bitmap" command is:
0B0926             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0926             0272*  ; and then to reverse the byte order to fix endian-ness:
0B0926             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0926             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0926             0275*  ; VDU 23,27,&20,targetBufferID%;
0B0926             0276*  ; VDU 23,27,&21,width%;height%;0
0B0926             0277*  ; -------------------------------------------------------------------
0B0926             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B0926             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B0926             0280*  vdu_rgba2_to_8:
0B0926             0281*  ; load the image dimensions and buffer id parameters
0B0926 ED 43 82 09 0282*      ld (@width),bc
       0B          
0B092B ED 53 84 09 0283*      ld (@height),de
       0B          
0B0930 22 67 09 0B 0284*      ld (@bufferId0),hl
0B0934 22 74 09 0B 0285*      ld (@bufferId2),hl
0B0938 22 7D 09 0B 0286*      ld (@bufferId1),hl
0B093C             0287*  ; clean up bytes that got stomped on by the ID loads
0B093C 3E 48       0288*      ld a,0x48
0B093E 32 69 09 0B 0289*      ld (@bufferId0+2),a
0B0942 3E 17       0290*      ld a,23
0B0944 32 7F 09 0B 0291*      ld (@bufferId1+2),a
0B0948 3E 18       0292*      ld a,24
0B094A 32 76 09 0B 0293*      ld (@bufferId2+2),a
0B094E AF          0294*      xor a
0B094F 32 86 09 0B 0295*      ld (@height+2),a
0B0953             0296*  ; send the vdu command strings
0B0953 21 5E 09 0B 0297*      ld hl,@beg
0B0957 01 29 00 00 0298*      ld bc,@end-@beg
0B095B 5B DF       0299*      rst.lil $18
0B095D C9          0300*      ret
0B095E             0301*  @beg:
0B095E             0302*  ; Command 14: Consolidate blocks in a buffer
0B095E             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B095E 17 00 A0    0304*      db 23,0,0xA0
0B0961 FE FF       0305*      dw 65534 ; workingBufferId
0B0963 0E          0306*      db 14 ; consolidate blocks
0B0964             0307*  ; the "expand bitmap" command is:
0B0964             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0964 17 00 A0    0309*      db 23,0,0xA0
0B0967 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B0969 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B096A 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B096B FE FF       0313*      dw 65534 ; sourceBufferId
0B096D 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B0971             0315*  ; reverse the byte order to fix endian-ness:
0B0971             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B0971             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B0971             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0971 17 00 A0    0319*      db 23,0,0xA0
0B0974 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B0976 18          0321*      db 24 ; reverse byte order
0B0977 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B0978 04 00       0323*      dw 4 ; size (4 bytes)
0B097A             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B097A             0325*  ; VDU 23,27,&20,targetBufferID%;
0B097A 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B097D 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B097F             0328*  ; VDU 23,27,&21,width%;height%;0
0B097F 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B0982 00 00       0330*  @width: dw 0x0000
0B0984 00 00       0331*  @height: dw 0x0000
0B0986 00          0332*      db 0x00 ; rgba8888 format
0B0987             0333*  @end:
0B0987             0334*  
0B0987             0335*  ; scratch variables
0B0987 00 00 00    0336*  bufferId0: dl 0x000000
0B098A 00 00 00    0337*  bufferId1: dl 0x000000
0B098D             0338*  
0B098D             0339*  ; load a vdu buffer from local memory
0B098D             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B098D             0341*  vdu_load_buffer:
0B098D ED 43 B6 09 0342*      ld (@length),bc
       0B          
0B0992 D5          0343*      push de ; save data pointer
0B0993             0344*  ; send the vdu command string
0B0993 7D          0345*      ld a,l
0B0994 32 B3 09 0B 0346*      ld (@bufferId),a
0B0998 7C          0347*      ld a,h
0B0999 32 B4 09 0B 0348*      ld (@bufferId+1),a
0B099D 21 B0 09 0B 0349*      ld hl,@cmd
0B09A1 01 08 00 00 0350*      ld bc,@end-@cmd
0B09A5 5B DF       0351*      rst.lil $18
0B09A7             0352*  ; send the buffer data
0B09A7 E1          0353*      pop hl ; pointer to data
0B09A8 ED 4B B6 09 0354*      ld bc,(@length)
       0B          
0B09AD 5B DF       0355*      rst.lil $18 ; send it
0B09AF C9          0356*      ret
0B09B0             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B09B0 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B09B3 00 00       0359*  @bufferId:	dw 0x0000
0B09B5 00          0360*  		    db 0 ; load buffer
0B09B6 00 00       0361*  @length:	dw 0x0000
0B09B8 00          0362*  @end: db 0 ; padding
0B09B9             0363*  
0B09B9             0364*  ; clear a buffer
0B09B9             0365*  ; inputs: hl = bufferId
0B09B9             0366*  vdu_clear_buffer:
0B09B9 7D          0367*      ld a,l
0B09BA 32 D1 09 0B 0368*      ld (@bufferId),a
0B09BE 7C          0369*      ld a,h
0B09BF 32 D2 09 0B 0370*      ld (@bufferId+1),a
0B09C3 21 CE 09 0B 0371*      ld hl,@cmd
0B09C7 01 06 00 00 0372*      ld bc,@end-@cmd
0B09CB 5B DF       0373*      rst.lil $18
0B09CD C9          0374*      ret
0B09CE 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B09D1 00 00       0376*  @bufferId:	dw 0x0000
0B09D3 02          0377*  		    db 2 ; clear buffer
0B09D4             0378*  @end:
0B09D4             0379*  
0B09D4             0380*  vdu_clear_all_buffers:
0B09D4             0381*  ; clear all buffers
0B09D4 21 DF 09 0B 0382*      ld hl,@beg
0B09D8 01 06 00 00 0383*      ld bc,@end-@beg
0B09DC 5B DF       0384*      rst.lil $18
0B09DE C9          0385*      ret
0B09DF 17 00 A0    0386*  @beg: db 23,0,$A0
0B09E2 FF FF       0387*        dw -1 ; clear all buffers
0B09E4 02          0388*        db 2  ; command 2: clear a buffer
0B09E5             0389*  @end:
0B09E5             0390*  
0B09E5             0391*  ; Command 14: Consolidate blocks in a buffer
0B09E5             0392*  vdu_consolidate_buffer:
0B09E5             0393*  ; set parameters for vdu call
0B09E5 7D          0394*      ld a,l
0B09E6 32 FD 09 0B 0395*      ld (@bufferId),a
0B09EA 7C          0396*      ld a,h
0B09EB 32 FE 09 0B 0397*      ld (@bufferId+1),a
0B09EF 21 FA 09 0B 0398*      ld hl,@beg
0B09F3 01 06 00 00 0399*      ld bc,@end-@beg
0B09F7 5B DF       0400*      rst.lil $18
0B09F9 C9          0401*      ret
0B09FA             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B09FA 17 00 A0    0403*  @beg: db 23,0,0xA0
0B09FD 00 00       0404*  @bufferId: dw 0x0000
0B09FF 0E          0405*             db 14
0B0A00             0406*  @end:
0B0A00             0407*  
0B0A00             0408*  ; load an image file to a buffer and make it a bitmap
0B0A00             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B0A00             0410*  vdu_load_img:
0B0A00             0411*  ; back up image type and dimension parameters
0B0A00 22 87 09 0B 0412*      ld (bufferId0),hl
0B0A04 F5          0413*      push af
0B0A05 C5          0414*  	push bc
0B0A06 D5          0415*  	push de
0B0A07             0416*  ; load the image
0B0A07 CD 22 0A 0B 0417*  	call vdu_load_buffer_from_file
0B0A0B             0418*  ; now make it a bitmap
0B0A0B 2A 87 09 0B 0419*      ld hl,(bufferId0)
0B0A0F CD E5 09 0B 0420*      call vdu_consolidate_buffer
0B0A13 2A 87 09 0B 0421*      ld hl,(bufferId0)
0B0A17 CD E2 08 0B 0422*      call vdu_buff_select
0B0A1B D1          0423*  	pop de ; image height
0B0A1C C1          0424*  	pop bc ; image width
0B0A1D F1          0425*  	pop af ; image type
0B0A1E C3 F7 08 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B0A22             0427*  
0B0A22             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B0A22             0429*  vdu_load_buffer_from_file:
0B0A22 22 87 09 0B 0430*      ld (bufferId0),hl
0B0A26             0431*  
0B0A26             0432*  ; clear target buffer
0B0A26 CD B9 09 0B 0433*      call vdu_clear_buffer
0B0A2A             0434*  
0B0A2A             0435*  ; open the file in read mode
0B0A2A             0436*  ; Open a file
0B0A2A             0437*  ; HLU: Filename
0B0A2A             0438*  ;   C: Mode
0B0A2A             0439*  ; Returns:
0B0A2A             0440*  ;   A: Filehandle, or 0 if couldn't open
0B0A2A FD E5       0441*  	push iy ; pointer to filename
0B0A2C E1          0442*  	pop hl
0B0A2D 0E 01       0443*  	ld c,fa_read
0B0A2F             0444*      MOSCALL mos_fopen
0B0A2F 3E 0A       0001*M 			LD	A, function
0B0A31 5B CF       0002*M 			RST.L	08h
0B0A33 32 6E 0A 0B 0445*      ld (@filehandle),a
0B0A37             0446*  
0B0A37             0447*  @read_file:
0B0A37             0448*  ; Read a block of data from a file
0B0A37             0449*  ;   C: Filehandle
0B0A37             0450*  ; HLU: Pointer to where to write the data to
0B0A37             0451*  ; DEU: Number of bytes to read
0B0A37             0452*  ; Returns:
0B0A37             0453*  ; DEU: Number of bytes read
0B0A37 3A 6E 0A 0B 0454*      ld a,(@filehandle)
0B0A3B 4F          0455*      ld c,a
0B0A3C 21 00 E0 B7 0456*      ld hl,filedata
0B0A40 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B0A44             0458*      MOSCALL mos_fread
0B0A44 3E 1A       0001*M 			LD	A, function
0B0A46 5B CF       0002*M 			RST.L	08h
0B0A48             0459*  
0B0A48             0460*  ; ; DEBUG: print chunk size
0B0A48             0461*  ;     push de
0B0A48             0462*  ;     pop hl
0B0A48             0463*  ;     call printDec
0B0A48             0464*  ;     call printNewLine
0B0A48             0465*  
0B0A48             0466*  ; test de for zero bytes read
0B0A48 21 00 00 00 0467*      ld hl,0
0B0A4C AF          0468*      xor a ; clear carry
0B0A4D ED 52       0469*      sbc hl,de
0B0A4F CA 65 0A 0B 0470*      jp z,@close_file
0B0A53             0471*  
0B0A53             0472*  ; load a vdu buffer from local memory
0B0A53             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0A53 2A 87 09 0B 0474*      ld hl,(bufferId0)
0B0A57 D5          0475*      push de ; chunksize
0B0A58 C1          0476*      pop bc
0B0A59 11 00 E0 B7 0477*      ld de,filedata
0B0A5D CD 8D 09 0B 0478*      call vdu_load_buffer
0B0A61             0479*  
0B0A61             0480*  ; ; print progress breadcrumbs
0B0A61             0481*  ;     ld a,'.'
0B0A61             0482*  ;     rst.lil 10h
0B0A61             0483*  
0B0A61             0484*  ; read the next block
0B0A61 C3 37 0A 0B 0485*      jp @read_file
0B0A65             0486*  
0B0A65             0487*  ; close the file
0B0A65             0488*  @close_file:
0B0A65 3A 6E 0A 0B 0489*      ld a,(@filehandle)
0B0A69             0490*      MOSCALL mos_fclose
0B0A69 3E 0B       0001*M 			LD	A, function
0B0A6B 5B CF       0002*M 			RST.L	08h
0B0A6D C9          0491*      ret ; vdu_load_buffer_from_file
0B0A6E             0492*  
0B0A6E 00          0493*  @filehandle: db 0 ; file handle
0B0A6F 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B0A72             0495*  
0B0A72 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B0A75             0497*  
0B0A75             0498*  ; File information structure (FILINFO)
0B0A75             0499*  @filinfo:
0B0A75 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B0A79 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B0A7B 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B0A7D 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B0A7E 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B0A8B 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0B8B             0023       ; include "../moslets/vdu_fonts.inc"
0B0B8B             0024       include "../moslets/vdu_plot.inc"
0B0B8B             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0B8B             0002*  ; PLOT code 	(Decimal) 	Effect
0B0B8B             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B0B8B             0004*  plot_sl_both: equ 0x00
0B0B8B             0005*  
0B0B8B             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B0B8B             0007*  plot_sl_first: equ 0x08
0B0B8B             0008*  
0B0B8B             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B0B8B             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B0B8B             0011*  
0B0B8B             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B0B8B             0013*  plot_sl_last: equ 0x20
0B0B8B             0014*  
0B0B8B             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B0B8B             0016*  plot_sl_none: equ 0x28
0B0B8B             0017*  
0B0B8B             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B0B8B             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B0B8B             0020*  
0B0B8B             0021*  ; &40-&47 	64-71 	Point plot
0B0B8B             0022*  plot_pt: equ 0x40
0B0B8B             0023*  
0B0B8B             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B0B8B             0025*  plot_lf_lr_non_bg: equ 0x48
0B0B8B             0026*  
0B0B8B             0027*  ; &50-&57 	80-87 	Triangle fill
0B0B8B             0028*  plot_tf: equ 0x50
0B0B8B             0029*  
0B0B8B             0030*  ; &58-&5F 	88-95 	Line fill right to background 
0B0B8B             0031*  plot_lf_r_bg: equ 0x58
0B0B8B             0032*  
0B0B8B             0033*  ; &60-&67 	96-103 	Rectangle fill
0B0B8B             0034*  plot_rf: equ 0x60
0B0B8B             0035*  
0B0B8B             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B0B8B             0037*  plot_lf_lr_fg: equ 0x60
0B0B8B             0038*  
0B0B8B             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B0B8B             0040*  plot_pf: equ 0x70
0B0B8B             0041*  
0B0B8B             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B0B8B             0043*  plot_lf_r_non_fg: equ 0x78
0B0B8B             0044*  
0B0B8B             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B0B8B             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B0B8B             0047*  
0B0B8B             0048*  ; &90-&97 	144-151 	Circle outline
0B0B8B             0049*  plot_co: equ 0x90
0B0B8B             0050*  
0B0B8B             0051*  ; &98-&9F 	152-159 	Circle fill
0B0B8B             0052*  plot_cf: equ 0x98
0B0B8B             0053*  
0B0B8B             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B0B8B             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B0B8B             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B0B8B             0057*  
0B0B8B             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B0B8B             0059*  plot_rcm: equ 0xB8
0B0B8B             0060*  
0B0B8B             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B0B8B             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B0B8B             0063*  ; &D0-&D7 	208-215 	Not defined
0B0B8B             0064*  ; &D8-&DF 	216-223 	Not defined
0B0B8B             0065*  ; &E0-&E7 	224-231 	Not defined
0B0B8B             0066*  
0B0B8B             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0B8B             0068*  plot_bmp: equ 0xE8
0B0B8B             0069*  
0B0B8B             0070*  ; &F0-&F7 	240-247 	Not defined
0B0B8B             0071*  ; &F8-&FF 	248-255 	Not defined
0B0B8B             0072*  
0B0B8B             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B0B8B             0074*  ; Agon Console8 VDP 2.2.0
0B0B8B             0075*  
0B0B8B             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B0B8B             0077*  ; Plot code 	Effect
0B0B8B             0078*  ; 0 	Move relative
0B0B8B             0079*  mv_rel: equ 0
0B0B8B             0080*  
0B0B8B             0081*  ; 1 	Plot relative in current foreground colour
0B0B8B             0082*  dr_rel_fg: equ 1
0B0B8B             0083*  
0B0B8B             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B0B8B             0085*  ; 3 	Plot relative in current background colour
0B0B8B             0086*  dr_rel_bg: equ 3
0B0B8B             0087*  
0B0B8B             0088*  ; 4 	Move absolute
0B0B8B             0089*  mv_abs: equ 4
0B0B8B             0090*  
0B0B8B             0091*  ; 5 	Plot absolute in current foreground colour
0B0B8B             0092*  dr_abs_fg: equ 5
0B0B8B             0093*  
0B0B8B             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B0B8B             0095*  ; 7 	Plot absolute in current background colour
0B0B8B             0096*  dr_abs_bg: equ 7
0B0B8B             0097*  
0B0B8B             0098*  ; Codes 0-3 use the position data provided as part of the command
0B0B8B             0099*  ; as a relative position, adding the position given to the current
0B0B8B             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B0B8B             0101*  ; as part of the command as an absolute position, setting the current
0B0B8B             0102*  ; graphical cursor position to the position given.
0B0B8B             0103*  
0B0B8B             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B0B8B             0105*  ; current pixel colour. These operations cannot currently be supported
0B0B8B             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B0B8B             0107*  ; supported. Support for these codes may be added in a future version
0B0B8B             0108*  ; of the VDP firmware.
0B0B8B             0109*  
0B0B8B             0110*  ; 16 colour palette constants
0B0B8B             0111*  c_black: equ 0
0B0B8B             0112*  c_red_dk: equ 1
0B0B8B             0113*  c_green_dk: equ 2
0B0B8B             0114*  c_yellow_dk: equ 3
0B0B8B             0115*  c_blue_dk: equ 4
0B0B8B             0116*  c_magenta_dk: equ 5
0B0B8B             0117*  c_cyan_dk: equ 6
0B0B8B             0118*  c_grey: equ 7
0B0B8B             0119*  c_grey_dk: equ 8
0B0B8B             0120*  c_red: equ 9
0B0B8B             0121*  c_green: equ 10
0B0B8B             0122*  c_yellow: equ 11
0B0B8B             0123*  c_blue: equ 12
0B0B8B             0124*  c_magenta: equ 13
0B0B8B             0125*  c_cyan: equ 14
0B0B8B             0126*  c_white: equ 15
0B0B8B             0127*  
0B0B8B             0128*  ; VDU 25, mode, x; y;: PLOT command
0B0B8B             0129*  ; inputs: a=mode, bc=x0, de=y0
0B0B8B             0130*  vdu_plot:
0B0B8B 32 A5 0B 0B 0131*      ld (@mode),a
0B0B8F ED 43 A6 0B 0132*      ld (@x0),bc
       0B          
0B0B94 ED 53 A8 0B 0133*      ld (@y0),de
       0B          
0B0B99 21 A4 0B 0B 0134*  	ld hl,@cmd
0B0B9D 01 06 00 00 0135*  	ld bc,@end-@cmd
0B0BA1 5B DF       0136*  	rst.lil $18
0B0BA3 C9          0137*  	ret
0B0BA4 19          0138*  @cmd:   db 25
0B0BA5 00          0139*  @mode:  db 0
0B0BA6 00 00       0140*  @x0: 	dw 0
0B0BA8 00 00       0141*  @y0: 	dw 0
0B0BAA 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B0BAB             0143*  
0B0BAB             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0BAB             0145*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0BAB             0146*  ; VDU 25, mode, x; y;: PLOT command
0B0BAB             0147*  ; inputs: bc=x0, de=y0
0B0BAB             0148*  ; prerequisites: vdu_buff_select
0B0BAB             0149*  vdu_plot_bmp:
0B0BAB ED 43 C2 0B 0150*      ld (@x0),bc
       0B          
0B0BB0 ED 53 C4 0B 0151*      ld (@y0),de
       0B          
0B0BB5 21 C0 0B 0B 0152*  	ld hl,@cmd
0B0BB9 01 06 00 00 0153*  	ld bc,@end-@cmd
0B0BBD 5B DF       0154*  	rst.lil $18
0B0BBF C9          0155*  	ret
0B0BC0 19          0156*  @cmd:   db 25
0B0BC1 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0BC2 00 00       0158*  @x0: 	dw 0x0000
0B0BC4 00 00       0159*  @y0: 	dw 0x0000
0B0BC6 00          0160*  @end:   db 0x00 ; padding
0B0BC7             0161*  
0B0BC7             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0BC7             0163*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0BC7             0164*  ; VDU 25, mode, x; y;: PLOT command
0B0BC7             0165*  ; inputs: bc=x0, de=y0
0B0BC7             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B0BC7             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B0BC7             0168*  ;   the fractional portiion of the inputs are truncated
0B0BC7             0169*  ;   leaving only the 16-bit integer portion
0B0BC7             0170*  ; prerequisites: vdu_buff_select
0B0BC7             0171*  vdu_plot_bmp168:
0B0BC7             0172*  ; populate in the reverse of normal to keep the
0B0BC7             0173*  ; inputs from stomping on each other
0B0BC7 ED 53 E5 0B 0174*      ld (@y0-1),de
       0B          
0B0BCC ED 43 E3 0B 0175*      ld (@x0-1),bc
       0B          
0B0BD1 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B0BD3 32 E3 0B 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B0BD7 21 E2 0B 0B 0178*  	ld hl,@cmd
0B0BDB 01 06 00 00 0179*  	ld bc,@end-@cmd
0B0BDF 5B DF       0180*  	rst.lil $18
0B0BE1 C9          0181*  	ret
0B0BE2 19          0182*  @cmd:   db 25
0B0BE3 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0BE4 00 00       0184*  @x0: 	dw 0x0000
0B0BE6 00 00       0185*  @y0: 	dw 0x0000
0B0BE8             0186*  @end:  ; no padding required b/c we shifted de right
0B0BE8             0187*  
0B0BE8             0188*  ; draw a filled rectangle
0B0BE8             0189*  vdu_plot_rf:
0B0BE8 ED 43 0F 0C 0190*      ld (@x0),bc
       0B          
0B0BED ED 53 11 0C 0191*      ld (@y0),de
       0B          
0B0BF2 DD 22 15 0C 0192*      ld (@x1),ix
       0B          
0B0BF7 FD 22 17 0C 0193*      ld (@y1),iy
       0B          
0B0BFC 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B0BFE 32 13 0C 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0C02 21 0D 0C 0B 0196*  	ld hl,@cmd0
0B0C06 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B0C0A 5B DF       0198*  	rst.lil $18
0B0C0C C9          0199*      ret
0B0C0D 19          0200*  @cmd0:  db 25 ; plot
0B0C0E 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B0C0F 00 00       0202*  @x0:    dw 0x0000
0B0C11 00 00       0203*  @y0:    dw 0x0000
0B0C13 19          0204*  @cmd1:  db 25 ; plot
0B0C14 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B0C15 00 00       0206*  @x1:    dw 0x0000
0B0C17 00 00       0207*  @y1:    dw 0x0000
0B0C19 00          0208*  @end:   db 0x00 ; padding
0B0C1A             0209*  
0B0C1A             0210*  ; draw a filled circle
0B0C1A             0211*  vdu_plot_cf:
0B0C1A ED 43 41 0C 0212*      ld (@x0),bc
       0B          
0B0C1F ED 53 43 0C 0213*      ld (@y0),de
       0B          
0B0C24 DD 22 47 0C 0214*      ld (@x1),ix
       0B          
0B0C29 FD 22 49 0C 0215*      ld (@y1),iy
       0B          
0B0C2E 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B0C30 32 45 0C 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0C34 21 3F 0C 0B 0218*  	ld hl,@cmd0
0B0C38 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B0C3C 5B DF       0220*  	rst.lil $18
0B0C3E C9          0221*      ret
0B0C3F 19          0222*  @cmd0:  db 25 ; plot
0B0C40 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B0C41 00 00       0224*  @x0:    dw 0x0000
0B0C43 00 00       0225*  @y0:    dw 0x0000
0B0C45 19          0226*  @cmd1:  db 25 ; plot
0B0C46 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B0C47 00 00       0228*  @x1:    dw 0x0000
0B0C49 00 00       0229*  @y1:    dw 0x0000
0B0C4B 00          0230*  @end:   db 0x00 ; padding
0B0C4C             0231*  
0B0C4C             0232*  ; VDU 25, mode, x; y;: PLOT command
0B0C4C             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B0C4C             0234*  plot:
0B0C4C 32 66 0C 0B 0235*      ld (@mode),a
0B0C50 DD 22 67 0C 0236*      ld (@x0),ix
       0B          
0B0C55 FD 22 69 0C 0237*      ld (@y0),iy
       0B          
0B0C5A 21 65 0C 0B 0238*  	ld hl,@cmd
0B0C5E 01 06 00 00 0239*  	ld bc,@end-@cmd
0B0C62 5B DF       0240*  	rst.lil $18
0B0C64 C9          0241*  	ret
0B0C65 19          0242*  @cmd:   db 25
0B0C66 00          0243*  @mode:  db 0
0B0C67 00 00       0244*  @x0: 	dw 0
0B0C69 00 00       0245*  @y0: 	dw 0
0B0C6B 00          0246*  @end:   db 0 ; padding
0B0C6C             0247*  
0B0C6C             0248*  ; VDU 5: Write text at graphics cursor
0B0C6C             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B0C6C             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B0C6C             0251*  plot_text:
0B0C6C E5          0252*      push hl ; save text pointer
0B0C6D             0253*  ; move graphics cursor to x0, y0
0B0C6D 3E 44       0254*      ld a,plot_pt+mv_abs
0B0C6F CD 4C 0C 0B 0255*      call plot
0B0C73             0256*  ; write text
0B0C73 E1          0257*      pop hl ; restore text pointer
0B0C74 CD 68 02 0B 0258*      call printString
0B0C78 C9          0259*      ret
0B0C79             0025   
0B0C79             0026   ; SHAWN'S INCLUDES
0B0C79             0027   	INCLUDE	"strings24.asm"
0B0C79             0001*  ;------------------------------------------------------------------------
0B0C79             0002*  ;  strings24.asm
0B0C79             0003*  ;
0B0C79             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B0C79             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B0C79             0006*  ;  MIT license
0B0C79             0007*  ;------------------------------------------------------------------------
0B0C79             0008*  
0B0C79             0009*  ;------------------------------------------------------------------------
0B0C79             0010*  ;Full print and buffer routine so you can adjust behaviour
0B0C79             0011*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B0C79             0012*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B0C79             0013*  ;Print value in HLU in decimal with leading 0s removed
0B0C79             0014*  ; Uses HLU, DEU, BCU
0B0C79             0015*  ;------------------------------------------------------------------------
0B0C79             0016*  
0B0C79             0017*  print_HLU_u24:
0B0C79 22 56 0D 0B 0018*  	ld	(hex_temp),hl
0B0C7D 06 08       0019*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B0C7F 11 59 0D 0B 0020*  	ld	de,outbuf
0B0C83 D5          0021*  	push	de
0B0C84 21 07 00 00 0022*  	ld	hl,7
0B0C88 19          0023*  	add	hl,de
0B0C89 E5          0024*  	push	hl
0B0C8A D1          0025*  	pop	de	;copy HLU to DEU
0B0C8B AF          0026*  	xor	a
0B0C8C             0027*  _pde_u_zerobuf:
0B0C8C 77          0028*  	ld	(hl),a	;zero out the output
0B0C8D 2B          0029*  	dec	hl
0B0C8E 10 FC       0030*  	djnz	_pde_u_zerobuf
0B0C90             0031*  
0B0C90 0E 18       0032*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B0C92             0033*  _bcd_Convert:
0B0C92             0034*  
0B0C92 21 56 0D 0B 0035*  	ld hl,hex_temp
0B0C96             0036*  ;
0B0C96 CB 26       0037*  	sla (hl)
0B0C98 23          0038*  	inc hl
0B0C99 CB 16       0039*  	rl (hl)
0B0C9B 23          0040*  	inc hl
0B0C9C CB 16       0041*  	rl (hl)		;24 bits rolled right
0B0C9E             0042*  
0B0C9E             0043*  
0B0C9E 06 08       0044*          ld	b,8	;8 digits max for 24 bit decimal output
0B0CA0 D5          0045*  	push	de
0B0CA1 E1          0046*  	pop	hl
0B0CA2             0047*  
0B0CA2             0048*  _bcd_Add3:
0B0CA2 7E          0049*  	ld	a,(hl)
0B0CA3 8F          0050*  	adc	a
0B0CA4 27          0051*          daa		;this is add 3 after shifting left; i.e. add 6.
0B0CA5 FE 10       0052*  	cp	10h	;did we roll over nibble?
0B0CA7 3F          0053*  	ccf
0B0CA8 CB A7       0054*  	res	4,a
0B0CAA             0055*  
0B0CAA 77          0056*          ld (hl),a
0B0CAB 2B          0057*  	dec	hl
0B0CAC 10 F4       0058*          djnz	_bcd_Add3	;loop for decimal digits
0B0CAE 0D          0059*          dec c
0B0CAF 20 E1       0060*          jr nz, _bcd_Convert	;loop around
0B0CB1             0061*  
0B0CB1             0062*  
0B0CB1 E1          0063*  	pop	hl
0B0CB2 E5          0064*  	push	hl
0B0CB3 06 07       0065*          ld	b,8-1		;one less than total in case output is '0'
0B0CB5             0066*  _pde_u_make_ascii:
0B0CB5 7E          0067*  	ld	a,(hl)
0B0CB6 B7          0068*  	or	a
0B0CB7 20 05       0069*  	jr	nz,_pde_u_make_ascii2
0B0CB9 36 20       0070*  	ld	(hl),' '
0B0CBB 23          0071*  	inc	hl
0B0CBC 10 F7       0072*  	djnz	_pde_u_make_ascii
0B0CBE             0073*  _pde_u_make_ascii2:
0B0CBE 04          0074*  	inc	b
0B0CBF             0075*  _pde_u_make_ascii3:
0B0CBF 7E          0076*  	ld	a,(hl)
0B0CC0 F6 30       0077*  	or	30h
0B0CC2 77          0078*  	ld	(hl),a
0B0CC3 23          0079*  	inc	hl
0B0CC4 10 F9       0080*  	djnz	_pde_u_make_ascii3
0B0CC6             0081*  
0B0CC6 E1          0082*  	pop	hl
0B0CC7 06 08       0083*  	ld	b,8
0B0CC9             0084*  _pde_u_final_out:
0B0CC9 7E          0085*  	ld	a,(hl)
0B0CCA 23          0086*  	inc	hl
0B0CCB FE 20       0087*  	cp	' '
0B0CCD 28 02       0088*  	jr	z,_pde_u_final_out_strip
0B0CCF 5B D7       0089*  	rst.lil	10h
0B0CD1             0090*  _pde_u_final_out_strip:
0B0CD1 10 F6       0091*  	djnz	_pde_u_final_out
0B0CD3 C9          0092*  	ret
0B0CD4             0093*  
0B0CD4             0094*  ;------------------------------------------------------------------------
0B0CD4             0095*  ; is_digit
0B0CD4             0096*  ; C flag set if A is a digit
0B0CD4             0097*  ; preserves all registers
0B0CD4             0098*  ;------------------------------------------------------------------------
0B0CD4             0099*  is_digit:
0B0CD4 FE 30       0100*  	cp	'0'
0B0CD6 3F          0101*  	ccf
0B0CD7 D0          0102*  	ret	nc	;less that '0'
0B0CD8 FE 3A       0103*  	cp	'9' + 1
0B0CDA C9          0104*  	ret
0B0CDB             0105*  
0B0CDB             0106*  
0B0CDB             0107*  ;------------------------------------------------------------------------
0B0CDB             0108*  ; char2hex
0B0CDB             0109*  ; Input: ASCII nibble in A
0B0CDB             0110*  ; Returns: if valid nibble value in A; else 0FFh in A
0B0CDB             0111*  ;------------------------------------------------------------------------
0B0CDB             0112*  char2hex:
0B0CDB FE 30       0113*  	CP	'0'
0B0CDD 38 1D       0114*  	JR	C, char_not_hex
0B0CDF FE 3A       0115*  	CP	'9' + 1
0B0CE1 30 03       0116*  	JR	NC, char_not_09
0B0CE3 D6 30       0117*  	sub	'0'
0B0CE5 C9          0118*  	ret
0B0CE6             0119*  
0B0CE6             0120*  char_not_09:
0B0CE6             0121*  	; char is not 0 to 9. Try upper case
0B0CE6 FE 41       0122*  	CP	'A'
0B0CE8 38 12       0123*  	JR	C, char_not_hex
0B0CEA FE 47       0124*  	CP	'F' + 1
0B0CEC 30 03       0125*  	JR	NC, char_not_AF
0B0CEE D6 37       0126*  	sub	'A'-10
0B0CF0 C9          0127*  	ret
0B0CF1             0128*  
0B0CF1             0129*  char_not_AF:
0B0CF1             0130*  	; char is not upper case A-F. Try lower
0B0CF1 FE 61       0131*  	CP	'a'
0B0CF3 38 07       0132*  	JR	C, char_not_hex
0B0CF5 FE 67       0133*  	CP	'f' + 1
0B0CF7 30 03       0134*  	JR	NC, char_not_hex
0B0CF9 D6 57       0135*  	sub	'a' - 10
0B0CFB C9          0136*  	RET
0B0CFC             0137*  
0B0CFC             0138*  char_not_hex:
0B0CFC 3E FF       0139*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B0CFE C9          0140*  	RET
0B0CFF             0141*  
0B0CFF             0142*  ;------------------------------------------------------------------------
0B0CFF             0143*  ;  newline
0B0CFF             0144*  ;  Output CR+LF; all registers preserved
0B0CFF             0145*  ;------------------------------------------------------------------------
0B0CFF             0146*  newline:
0B0CFF F5          0147*         push   AF
0B0D00 3E 0D       0148*         LD     A, 13
0B0D02 5B D7       0149*         RST.LIL    10h
0B0D04 3E 0A       0150*         LD     A, 10
0B0D06 5B D7       0151*         RST.LIL    10h
0B0D08 F1          0152*         POP    AF
0B0D09 C9          0153*         RET
0B0D0A             0154*  
0B0D0A             0155*  ;------------------------------------------------------------------------
0B0D0A             0156*  ;  put_nibble
0B0D0A             0157*  ;  Output a single hex nibble in A
0B0D0A             0158*  ;  All registers preserved
0B0D0A             0159*  ;------------------------------------------------------------------------
0B0D0A             0160*  put_nibble:
0B0D0A F5          0161*  	push   AF
0B0D0B C6 90       0162*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B0D0D 27          0163*  	daa
0B0D0E CE 40       0164*  	adc    a,040h
0B0D10 27          0165*  	daa
0B0D11 5B D7       0166*  	RST.LIL    10h	;output character in A
0B0D13 F1          0167*  	pop    AF
0B0D14 C9          0168*  	ret
0B0D15             0169*  
0B0D15             0170*  ;------------------------------------------------------------------------
0B0D15             0171*  ;  print_A
0B0D15             0172*  ;  Output the 8-bit hex number A
0B0D15             0173*  ;  All registers preserved
0B0D15             0174*  ;------------------------------------------------------------------------
0B0D15             0175*  print_A:
0B0D15 F5          0176*  	push 	AF
0B0D16 F5          0177*  	push 	AF	;save for second nibble
0B0D17 0F          0178*  	rrca
0B0D18 0F          0179*  	rrca
0B0D19 0F          0180*  	rrca
0B0D1A 0F          0181*  	rrca
0B0D1B E6 0F       0182*  	and	0Fh	;first nibble
0B0D1D CD 0A 0D 0B 0183*  	call	put_nibble
0B0D21 F1          0184*  	pop 	AF
0B0D22 E6 0F       0185*  	and	0Fh	;second nibble
0B0D24 CD 0A 0D 0B 0186*  	call	put_nibble
0B0D28 F1          0187*  	pop 	AF
0B0D29 C9          0188*  	ret
0B0D2A             0189*  
0B0D2A             0190*  ;------------------------------------------------------------------------
0B0D2A             0191*  ;  print_HLU_hex
0B0D2A             0192*  ;  Output the 24-bit hex number HLU; other registers preserved
0B0D2A             0193*  ;------------------------------------------------------------------------
0B0D2A             0194*  print_HLU_hex:
0B0D2A F5          0195*         push   AF
0B0D2B 22 56 0D 0B 0196*         ld     (hex_temp),hl
0B0D2F 3A 58 0D 0B 0197*         ld     a,(hex_temp+2)
0B0D33 CD 15 0D 0B 0198*         call   print_A
0B0D37 3A 57 0D 0B 0199*         ld     a,(hex_temp+1)
0B0D3B CD 15 0D 0B 0200*         call   print_A
0B0D3F 3A 56 0D 0B 0201*         ld     a,(hex_temp)
0B0D43 CD 15 0D 0B 0202*         call   print_A
0B0D47 F1          0203*         POP    AF
0B0D48 C9          0204*         RET
0B0D49             0205*  
0B0D49             0206*  ;------------------------------------------------------------------------
0B0D49             0207*  ;  puts
0B0D49             0208*  ;  Output a zero-terminated string whose address is in HL; all
0B0D49             0209*  ;  registers preserved.
0B0D49             0210*  ;------------------------------------------------------------------------
0B0D49             0211*  puts:
0B0D49 F5          0212*         push   AF
0B0D4A C5          0213*         push   BC
0B0D4B 01 00 00 00 0214*         ld     BC, 0                ; Set to 0, so length ignored...
0B0D4F 3E 00       0215*         ld     A, 0                 ; Use character in A as delimiter
0B0D51 5B DF       0216*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B0D53 C1          0217*         pop    BC
0B0D54 F1          0218*         pop    AF
0B0D55 C9          0219*         ret
0B0D56             0220*  
0B0D56             0221*  ;------------------------------------------------------------------------
0B0D56             0222*  ; Data area
0B0D56             0223*  ; Storage for 24 bit conversion
0B0D56             0224*  ;------------------------------------------------------------------------
0B0D56             0225*  hex_temp:
0B0D56 00 00 00    0226*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B0D59             0227*  
0B0D59             0228*  outbuf:
0B0D59 31 36 37 37 0229*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B0D62             0028   	INCLUDE	"arith24.asm"
0B0D62             0001*  ;------------------------------------------------------------------------
0B0D62             0002*  ;  arith24.asm
0B0D62             0003*  ;  24-bit ez80 arithmetic routines
0B0D62             0004*  ;  Copyright (c) Shawn Sijnstra 2024
0B0D62             0005*  ;  MIT license
0B0D62             0006*  ;
0B0D62             0007*  ;  This library was created as a tool to help make ez80
0B0D62             0008*  ;  24-bit native assembly routines for simple mathematical problems
0B0D62             0009*  ;  more widely available.
0B0D62             0010*  ;
0B0D62             0011*  ;------------------------------------------------------------------------
0B0D62             0012*  
0B0D62             0013*  ;------------------------------------------------------------------------
0B0D62             0014*  ; umul24:	HL = HL*DE (unsigned)
0B0D62             0015*  ; Preserves AF, BC, DE
0B0D62             0016*  ; Uses a fast multiply routine.
0B0D62             0017*  ;------------------------------------------------------------------------
0B0D62             0018*  umul24:
0B0D62 D5          0019*  	push	DE
0B0D63 C5          0020*  	push	BC
0B0D64 F5          0021*  	push	AF
0B0D65 E5          0022*  	push	HL
0B0D66 C1          0023*  	pop		BC
0B0D67 3E 18       0024*      ld	 	a, 24 ; No. of bits to process
0B0D69 21 00 00 00 0025*      ld	 	hl, 0 ; Result
0B0D6D             0026*  umul24_lp:
0B0D6D 29          0027*  	add	hl,hl
0B0D6E EB          0028*  	ex	de,hl
0B0D6F 29          0029*  	add	hl,hl
0B0D70 EB          0030*  	ex	de,hl
0B0D71 30 01       0031*  	jr	nc,umul24_nc
0B0D73 09          0032*  	add	hl,bc
0B0D74             0033*  umul24_nc:
0B0D74 3D          0034*  	dec	a
0B0D75 20 F6       0035*  	jr	nz,umul24_lp
0B0D77 F1          0036*  	pop	af
0B0D78 C1          0037*  	pop	bc
0B0D79 D1          0038*  	pop	de
0B0D7A C9          0039*  	ret
0B0D7B             0040*  
0B0D7B             0041*  
0B0D7B             0042*  ;------------------------------------------------------------------------
0B0D7B             0043*  ; udiv24
0B0D7B             0044*  ; Unsigned 24-bit division
0B0D7B             0045*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0D7B             0046*  ;
0B0D7B             0047*  ; Uses AF BC DE HL
0B0D7B             0048*  ; Uses Restoring Division algorithm
0B0D7B             0049*  ;------------------------------------------------------------------------
0B0D7B             0050*  
0B0D7B             0051*  udiv24:
0B0D7B E5          0052*  	push	hl
0B0D7C C1          0053*  	pop		bc	;move dividend to BCU
0B0D7D 21 00 00 00 0054*  	ld		hl,0	;result
0B0D81 A7          0055*  	and		a
0B0D82 ED 52       0056*  	sbc		hl,de	;test for div by 0
0B0D84 C8          0057*  	ret		z		;it's zero, carry flag is clear
0B0D85 19          0058*  	add		hl,de	;HL is 0 again
0B0D86 3E 18       0059*  	ld		a,24	;number of loops through.
0B0D88             0060*  udiv1:
0B0D88 C5          0061*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0D89 E3          0062*  	ex		(sp),hl
0B0D8A 37          0063*  	scf
0B0D8B ED 6A       0064*  	adc	hl,hl
0B0D8D E3          0065*  	ex	(sp),hl
0B0D8E C1          0066*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0D8F             0067*  
0B0D8F ED 6A       0068*  	adc	hl,hl
0B0D91 A7          0069*  	and	a		;is this the bug
0B0D92 ED 52       0070*  	sbc	hl,de
0B0D94 30 02       0071*  	jr	nc,udiv2
0B0D96 19          0072*  	add	hl,de
0B0D97             0073*  ;	dec	c
0B0D97 0B          0074*  	dec	bc
0B0D98             0075*  udiv2:
0B0D98 3D          0076*  	dec	a
0B0D99 20 ED       0077*  	jr	nz,udiv1
0B0D9B 37          0078*  	scf		;flag used for div0 error
0B0D9C C5          0079*  	push	bc
0B0D9D D1          0080*  	pop		de	;remainder
0B0D9E C9          0081*  	ret
0B0D9F             0082*  
0B0D9F             0083*  
0B0D9F             0084*  
0B0D9F             0085*  ;------------------------------------------------------------------------
0B0D9F             0086*  ; neg24
0B0D9F             0087*  ; Returns: HLU = 0-HLU
0B0D9F             0088*  ; preserves all other registers
0B0D9F             0089*  ;------------------------------------------------------------------------
0B0D9F             0090*  neg24:
0B0D9F D5          0091*  	push	de
0B0DA0 EB          0092*  	ex		de,hl
0B0DA1 21 00 00 00 0093*  	ld		hl,0
0B0DA5 B7          0094*  	or		a
0B0DA6 ED 52       0095*  	sbc		hl,de
0B0DA8 D1          0096*  	pop		de
0B0DA9 C9          0097*  	ret
0B0DAA             0098*  
0B0DAA             0099*  ;------------------------------------------------------------------------
0B0DAA             0100*  ; or_hlu_deu: 24 bit bitwise OR
0B0DAA             0101*  ; Returns: hlu = hlu OR deu
0B0DAA             0102*  ; preserves all other registers
0B0DAA             0103*  ;------------------------------------------------------------------------
0B0DAA             0104*  or_hlu_deu:
0B0DAA 22 35 0E 0B 0105*  	ld	(bitbuf1),hl
0B0DAE ED 53 38 0E 0106*  	ld	(bitbuf2),de
       0B          
0B0DB3 D5          0107*  	push	de	;preserve DEU
0B0DB4 C5          0108*  	push	bc	;preserve BCU
0B0DB5 06 03       0109*  	ld		b,3
0B0DB7 21 35 0E 0B 0110*  	ld	hl,bitbuf1
0B0DBB 11 35 0E 0B 0111*  	ld	de,bitbuf1
0B0DBF             0112*  orloop_24:
0B0DBF 1A          0113*  	ld	a,(de)
0B0DC0 B6          0114*  	or	(hl)
0B0DC1 12          0115*  	ld	(de),a
0B0DC2 13          0116*  	inc	de
0B0DC3 23          0117*  	inc	hl
0B0DC4 10 F9       0118*  	djnz	orloop_24
0B0DC6 2A 38 0E 0B 0119*  	ld	hl,(bitbuf2)
0B0DCA C1          0120*  	pop		bc	;restore BC
0B0DCB D1          0121*  	pop		de	;restore DE
0B0DCC             0122*  
0B0DCC             0123*  ;------------------------------------------------------------------------
0B0DCC             0124*  ; and_hlu_deu: 24 bit bitwise AND
0B0DCC             0125*  ; Returns: hlu = hlu AND deu
0B0DCC             0126*  ; preserves all other registers
0B0DCC             0127*  ;------------------------------------------------------------------------
0B0DCC             0128*  and_hlu_deu:
0B0DCC 22 35 0E 0B 0129*  	ld	(bitbuf1),hl
0B0DD0 ED 53 38 0E 0130*  	ld	(bitbuf2),de
       0B          
0B0DD5 D5          0131*  	push	de	;preserve DEU
0B0DD6 C5          0132*  	push	bc	;preserve BCU
0B0DD7 06 03       0133*  	ld		b,3
0B0DD9 21 35 0E 0B 0134*  	ld	hl,bitbuf1
0B0DDD 11 35 0E 0B 0135*  	ld	de,bitbuf1
0B0DE1             0136*  andloop_24:
0B0DE1 1A          0137*  	ld	a,(de)
0B0DE2 A6          0138*  	and	(hl)
0B0DE3 12          0139*  	ld	(de),a
0B0DE4 13          0140*  	inc	de
0B0DE5 23          0141*  	inc	hl
0B0DE6 10 F9       0142*  	djnz	andloop_24
0B0DE8 2A 38 0E 0B 0143*  	ld	hl,(bitbuf2)
0B0DEC C1          0144*  	pop		bc	;restore BC
0B0DED D1          0145*  	pop		de	;restore DE
0B0DEE             0146*  
0B0DEE             0147*  ;------------------------------------------------------------------------
0B0DEE             0148*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0DEE             0149*  ; Returns: hlu = hlu XOR deu
0B0DEE             0150*  ; preserves all other registers
0B0DEE             0151*  ;------------------------------------------------------------------------
0B0DEE             0152*  xor_hlu_deu:
0B0DEE 22 35 0E 0B 0153*  	ld	(bitbuf1),hl
0B0DF2 ED 53 38 0E 0154*  	ld	(bitbuf2),de
       0B          
0B0DF7 D5          0155*  	push	de	;preserve DEU
0B0DF8 C5          0156*  	push	bc	;preserve BCU
0B0DF9 06 03       0157*  	ld		b,3
0B0DFB 21 35 0E 0B 0158*  	ld	hl,bitbuf1
0B0DFF 11 35 0E 0B 0159*  	ld	de,bitbuf1
0B0E03             0160*  xorloop_24:
0B0E03 1A          0161*  	ld	a,(de)
0B0E04 AE          0162*  	xor	(hl)
0B0E05 12          0163*  	ld	(de),a
0B0E06 13          0164*  	inc	de
0B0E07 23          0165*  	inc	hl
0B0E08 10 F9       0166*  	djnz	xorloop_24
0B0E0A 2A 38 0E 0B 0167*  	ld	hl,(bitbuf2)
0B0E0E C1          0168*  	pop		bc	;restore BC
0B0E0F D1          0169*  	pop		de	;restore DE
0B0E10             0170*  
0B0E10             0171*  ;------------------------------------------------------------------------
0B0E10             0172*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B0E10             0173*  ; Returns: hlu = hlu << deu
0B0E10             0174*  ;		   de = 0
0B0E10             0175*  ; NOTE: only considers deu up to 16 bits.
0B0E10             0176*  ; preserves all other registers
0B0E10             0177*  ;------------------------------------------------------------------------
0B0E10             0178*  shl_hlu:
0B0E10 7A          0179*  	ld		a,d		;up to 16 bit.
0B0E11 B3          0180*  	or		e
0B0E12 C8          0181*  	ret		z		;we're done
0B0E13 29          0182*  	add		hl,hl	;shift HLU left
0B0E14 1B          0183*  	dec		de
0B0E15 18 F9       0184*  	jr		shl_hlu
0B0E17             0185*  
0B0E17             0186*  ;------------------------------------------------------------------------
0B0E17             0187*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B0E17             0188*  ; Returns: hlu = hlu >> deu
0B0E17             0189*  ;		   de = 0
0B0E17             0190*  ; NOTE: only considers deu up to 16 bits.
0B0E17             0191*  ; preserves all other registers
0B0E17             0192*  ;------------------------------------------------------------------------
0B0E17             0193*  shr_hlu:
0B0E17 22 35 0E 0B 0194*  	ld		(bitbuf1),hl
0B0E1B 21 37 0E 0B 0195*  	ld		hl,bitbuf1+2
0B0E1F             0196*  shr_loop:
0B0E1F 7A          0197*  	ld		a,d		;up to 16 bit.
0B0E20 B3          0198*  	or		e
0B0E21 28 0D       0199*  	jr		z,shr_done		;we're done
0B0E23             0200*  ;carry is clear from or instruction
0B0E23 CB 1E       0201*  	rr		(hl)
0B0E25 2B          0202*  	dec		hl
0B0E26 CB 1E       0203*  	rr		(hl)
0B0E28 2B          0204*  	dec		hl
0B0E29 CB 1E       0205*  	rr		(hl)
0B0E2B 23          0206*  	inc		hl
0B0E2C 23          0207*  	inc		hl
0B0E2D 1B          0208*  	dec		de
0B0E2E 18 EF       0209*  	jr		shr_loop
0B0E30             0210*  shr_done:
0B0E30 2A 35 0E 0B 0211*  	ld		hl,(bitbuf1)	;collect result
0B0E34 C9          0212*  	ret
0B0E35             0213*  
0B0E35             0214*  ;------------------------------------------------------------------------
0B0E35             0215*  ; Scratch area for calculations
0B0E35             0216*  ;------------------------------------------------------------------------
0B0E35 00 00 00    0217*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B0E38 00 00 00    0218*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B0E3B             0029   
0B0E3B             0030   ; APPLICATION INCLUDES
0B0E3B 55 73 61 67 0031   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B0E53 45 72 72 6F 0032   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B0E5C 53 75 63 63 0033   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B0E67             0034   
0B0E67             0035   ; This is a scratch moslet for testing new features
0B0E67             0036   ; Parameters:
0B0E67             0037   ;
0B0E67             0038   
0B0E67             0039   ; ========= BOILERPLATE MAIN LOOP =========
0B0E67             0040   ; The main routine
0B0E67             0041   ; IXU: argv - pointer to array of parameters
0B0E67             0042   ;   C: argc - number of parameters
0B0E67             0043   ; Returns:
0B0E67             0044   ;  HL: Error code, or 0 if OK
0B0E67             0045   
0B0E67             0046   min_args: equ 2
0B0E67             0047   
0B0E67             0048   _main:
0B0E67 79          0049       ld a,c              ; how many arguments?
0B0E68 FE 02       0050       cp min_args         ; not enough?
0B0E6A 30 22       0051       jr nc,main          ; if enough, go to main loop
0B0E6C 21 3B 0E 0B 0052       ld hl,str_usage     ; if not enough, print usage
0B0E70 CD 68 02 0B 0053       call printString
0B0E74             0054                           ; fall through to _main_end_error
0B0E74             0055   
0B0E74             0056   _main_end_error:
0B0E74 21 53 0E 0B 0057       ld hl,str_error     ; print error message
0B0E78 CD 68 02 0B 0058       call printString
0B0E7C 21 13 00 00 0059       ld hl,19            ; return error code 19
0B0E80 C9          0060       ret
0B0E81             0061   
0B0E81             0062   _main_end_ok:
0B0E81 21 5C 0E 0B 0063       ld hl,str_success   ; print success message
0B0E85 CD 68 02 0B 0064       call printString
0B0E89 21 00 00 00 0065       ld hl,0             ; return 0 for success
0B0E8D C9          0066       ret
0B0E8E             0067   
0B0E8E             0068   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B0E8E             0069   main:
0B0E8E 0D          0070       dec c               ; decrement the argument count to skip the program name
0B0E8F             0071   
0B0E8F             0072   ; assume the first argument is numeric
0B0E8F CD A4 0E 0B 0073       call get_numeric_arg ; de contains the numeric value of the first argument
0B0E93 EB          0074       ex de,hl            ; move result in de to hl
0B0E94 CD 48 04 0B 0075       call dumpRegistersHex ; print the registers
0B0E98 CD B8 02 0B 0076       call printDec       ; print the number
0B0E9C CD 7D 02 0B 0077       call printNewLine   ; print a newline
0B0EA0 C3 81 0E 0B 0078       jp _main_end_ok
0B0EA4             0079   
0B0EA4             0080   
0B0EA4             0081   ; ========== HELPER FUNCTIONS ==========
0B0EA4             0082   get_numeric_arg:
0B0EA4 ED 32 03    0083       lea ix,ix+3 ; point to the next argument
0B0EA7 DD 27 00    0084       ld hl,(ix)  ; get the argument string
0B0EAA CD 98 01 0B 0085       call signed_asc_to_168 ; convert the string to a number
0B0EAE C9          0086       ret ; return with the value in DE
0B0EAF             0087   
0B0EAF             0088   get_plot_coords:
0B0EAF             0089   ; get the move coordinates
0B0EAF ED 32 03    0090       lea ix,ix+3 ; pointer to next argument address
0B0EB2 DD 27 00    0091       ld hl,(ix)  ; pointer to the x coordinate string
0B0EB5 CD 98 01 0B 0092       call signed_asc_to_168 ; de = x coordinate
0B0EB9 D5          0093       push de
0B0EBA C1          0094       pop bc ; bc = x coordinate
0B0EBB ED 32 03    0095       lea ix,ix+3 ; pointer to next argument address
0B0EBE DD 27 00    0096       ld hl,(ix)  ; pointer to the y coordinate string
0B0EC1 CD 98 01 0B 0097       call signed_asc_to_168 ; de = y coordinate
0B0EC5 C9          0098       ret
0B0EC6             0099   
0B0EC6             0100   ; match the next argument after ix to the dispatch table at iy
0B0EC6             0101   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B0EC6             0102   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B0EC6             0103   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B0EC6             0104   ;          ON MATCH: iy=dispatch address, a=0 and zero flag se
0B0EC6             0105   ; destroys: a, hl, de, ix, iy, flags
0B0EC6             0106   match_next:
0B0EC6 ED 32 03    0107       lea ix,ix+3         ; point to the next argument
0B0EC9             0108   @loop:
0B0EC9 FD 27 00    0109       ld hl,(iy)          ; pointer argument dispatch record
0B0ECC             0110       signHL              ; check for list terminator
0B0ECC 19          0001M          add hl,de
0B0ECD B7          0002M          or a
0B0ECE ED 52       0003M          sbc hl,de
0B0ED0 CA E8 0E 0B 0111       jp z,@no_match      ; if a=0, return error
0B0ED4 23          0112       inc hl              ; skip over jp instruction
0B0ED5 23          0113       inc hl
0B0ED6 DD 17 00    0114       ld de,(ix)          ; pointer to the argument string
0B0ED9 CD EE 0E 0B 0115       call str_equal      ; compare the argument to the dispatch table entry
0B0EDD CA EA 0E 0B 0116       jp z,@match         ; if equal, return success
0B0EE1 ED 33 03    0117       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B0EE4 C3 C9 0E 0B 0118       jp @loop            ; and loop
0B0EE8             0119   @no_match:
0B0EE8 3C          0120       inc a               ; no match so return a=1 and zero flag reset
0B0EE9 C9          0121       ret
0B0EEA             0122   @match:
0B0EEA FD 37 00    0123       ld iy,(iy)          ; get the function pointer
0B0EED C9          0124       ret                 ; return a=0 and zero flag set
0B0EEE             0125   
0B0EEE             0126   ; compare two zero-terminated strings for equality, case-sensitive
0B0EEE             0127   ; hl: pointer to first string, de: pointer to second string
0B0EEE             0128   ; returns: z if equal, nz if not equal
0B0EEE             0129   ; destroys: a, hl, de
0B0EEE             0130   str_equal:
0B0EEE 1A          0131       ld a,(de)           ; get the first character
0B0EEF BE          0132       cp (hl)             ; compare to the second character
0B0EF0 C0          0133       ret nz              ; if not equal, return
0B0EF1 B7          0134       or a
0B0EF2 C8          0135       ret z               ; if equal and zero, return
0B0EF3 23          0136       inc hl              ; next character
0B0EF4 13          0137       inc de
0B0EF5 C3 EE 0E 0B 0138       jp str_equal        ; loop until end of string
0B0EF9             0139   
0B0EF9             0140   ; print the parameter string pointed to by ix
0B0EF9             0141   ; destroys: a, hl
0B0EF9             0142   print_param:
0B0EF9 DD 27 00    0143       ld hl,(ix)          ; get the parameter pointer
0B0EFC CD 68 02 0B 0144       call printString    ; print the parameter string
0B0F00 3E 20       0145       ld a,' '            ; print a space separator
0B0F02 5B D7       0146       rst.lil $10
0B0F04 C9          0147       ret
0B0F05             0148   
0B0F05             0149   ; print the parameters
0B0F05             0150   ; inputs: b = number of parameters, ix = pointer to the parameters
0B0F05             0151   ; destroys: a, hl, bc
0B0F05             0152   print_params:
0B0F05 41          0153       ld b,c              ; loop counter = number of parameters
0B0F06 DD E5       0154       push ix             ; save the pointer to the parameters
0B0F08             0155   @loop:
0B0F08 C5          0156       push bc             ; save the loop counter
0B0F09 CD F9 0E 0B 0157       call print_param    ; print the parameter
0B0F0D ED 32 03    0158       lea ix,ix+3         ; next parameter pointer
0B0F10 C1          0159       pop bc              ; get back the loop counter
0B0F11 10 F5       0160       djnz @loop          ; loop until done
0B0F13 DD E1       0161       pop ix              ; restore the pointer to the parameters
0B0F15 C9          0162       ret
0B0F16             0163   
0B0F16             0164   debug_print:
0B0F16 CD 7D 02 0B 0165       call printNewLine   ; DEBUG
0B0F1A CD 7B 05 0B 0166       call dumpFlags      ; DEBUG
0B0F1E CD F9 0E 0B 0167       call print_param    ; DEBUG
0B0F22 CD 7D 02 0B 0168       call printNewLine   ; DEBUG
0B0F26 CD 7D 02 0B 0169       call printNewLine   ; DEBUG
0B0F2A C9          0170       ret
