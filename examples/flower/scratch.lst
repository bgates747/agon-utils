PC     Output      Line
040000             0001   ;
040000             0002   ; Title:	test
040000             0003   ; Author:	Brandon Gates
040000             0004   ; Created:	29/10/2024
040000             0005   
040000             0006       ASSUME	ADL = 1
040000             0007       INCLUDE "mos_api.inc"
040000             0001*  ;
040000             0002*  ; Title:	AGON MOS - API for user projects
040000             0003*  ; Author:	Dean Belfield
040000             0004*  ; Created:	03/08/2022
040000             0005*  ; Last Updated:	11/11/2023
040000             0006*  ;
040000             0007*  ; Modinfo:
040000             0008*  ; 05/08/2022:	Added mos_feof
040000             0009*  ; 09/08/2022:	Added system variables: cursorX, cursorY
040000             0010*  ; 18/08/2022:	Added system variables: scrchar, scrpixel, audioChannel, audioSuccess, vpd_pflags
040000             0011*  ; 05/09/2022:	Added mos_ren, vdp_pflag_mode
040000             0012*  ; 24/09/2022:	Added mos_getError, mos_mkdir
040000             0013*  ; 13/10/2022:	Added mos_oscli
040000             0014*  ; 23/02/2023:	Added more sysvars, fixed typo in sysvar_audioSuccess, offsets for sysvar_scrCols, sysvar_scrRows
040000             0015*  ; 04/03/2023:	Added sysvar_scrpixelIndex
040000             0016*  ; 08/03/2023:	Renamed sysvar_keycode to sysvar_keyascii, added sysvar_vkeycode
040000             0017*  ; 15/03/2023:	Added mos_copy, mos_getrtc, mos_setrtc, rtc, vdp_pflag_rtc
040000             0018*  ; 21/03/2023:	Added mos_setintvector, sysvars for keyboard status, vdu codes for vdp
040000             0019*  ; 22/03/2023:	The VDP commands are now indexed from 0x80
040000             0020*  ; 29/03/2023:	Added mos_uopen, mos_uclose, mos_ugetc, mos_uputc
040000             0021*  ; 13/04/2023:	Added FatFS file structures (FFOBJID, FIL, DIR, FILINFO)
040000             0022*  ; 15/04/2023:	Added mos_getfil, mos_fread, mos_fwrite and mos_flseek
040000             0023*  ; 19/05/2023:	Added sysvar_scrMode
040000             0024*  ; 05/06/2023:	Added sysvar_rtcEnable
040000             0025*  ; 03/08/2023:	Added mos_setkbvector
040000             0026*  ; 10/08/2023:	Added mos_getkbmap
040000             0027*  ; 11/11/2023:	Added mos_i2c_open, mos_i2c_close, mos_i2c_write and mos_i2c_read
040000             0028*  ; 09/04/2024:   Adapter to ez80asm
040000             0029*  ; VDP control (VDU 23, 0, n)
040000             0030*  ;
040000             0031*  vdp_gp:			EQU 	80h
040000             0032*  vdp_keycode:		EQU 	81h
040000             0033*  vdp_cursor:		EQU	82h
040000             0034*  vdp_scrchar:		EQU	83h
040000             0035*  vdp_scrpixel:		EQU	84h
040000             0036*  vdp_audio:		EQU	85h
040000             0037*  vdp_mode:		EQU	86h
040000             0038*  vdp_rtc:		EQU	87h
040000             0039*  vdp_keystate:		EQU	88h
040000             0040*  vdp_logicalcoords:	EQU	C0h
040000             0041*  vdp_terminalmode:	EQU	FFh
040000             0042*  
040000             0043*  ; MOS high level functions
040000             0044*  ;
040000             0045*  mos_getkey:		EQU	00h
040000             0046*  mos_load:		EQU	01h
040000             0047*  mos_save:		EQU	02h
040000             0048*  mos_cd:			EQU	03h
040000             0049*  mos_dir:		EQU	04h
040000             0050*  mos_del:		EQU	05h
040000             0051*  mos_ren:		EQU	06h
040000             0052*  mos_mkdir:		EQU	07h
040000             0053*  mos_sysvars:		EQU	08h
040000             0054*  mos_editline:		EQU	09h
040000             0055*  mos_fopen:		EQU	0Ah
040000             0056*  mos_fclose:		EQU	0Bh
040000             0057*  mos_fgetc:		EQU	0Ch
040000             0058*  mos_fputc:		EQU	0Dh
040000             0059*  mos_feof:		EQU	0Eh
040000             0060*  mos_getError:		EQU	0Fh
040000             0061*  mos_oscli:		EQU	10h
040000             0062*  mos_copy:		EQU	11h
040000             0063*  mos_getrtc:		EQU	12h
040000             0064*  mos_setrtc:		EQU	13h
040000             0065*  mos_setintvector:	EQU	14h
040000             0066*  mos_uopen:		EQU	15h
040000             0067*  mos_uclose:		EQU	16h
040000             0068*  mos_ugetc:		EQU	17h
040000             0069*  mos_uputc:		EQU 	18h
040000             0070*  mos_getfil:		EQU	19h
040000             0071*  mos_fread:		EQU	1Ah
040000             0072*  mos_fwrite:		EQU	1Bh
040000             0073*  mos_flseek:		EQU	1Ch
040000             0074*  mos_setkbvector:	EQU	1Dh
040000             0075*  mos_getkbmap:		EQU	1Eh
040000             0076*  mos_i2c_open:		EQU	1Fh
040000             0077*  mos_i2c_close:		EQU	20h
040000             0078*  mos_i2c_write:		EQU	21h
040000             0079*  mos_i2c_read:		EQU	22h
040000             0080*  
040000             0081*  
040000             0082*  ; FatFS file access functions
040000             0083*  ;
040000             0084*  ffs_fopen:		EQU	80h
040000             0085*  ffs_fclose:		EQU	81h
040000             0086*  ffs_fread:		EQU	82h
040000             0087*  ffs_fwrite:		EQU	83h
040000             0088*  ffs_flseek:		EQU	84h
040000             0089*  ffs_ftruncate:		EQU	85h
040000             0090*  ffs_fsync:		EQU	86h
040000             0091*  ffs_fforward:		EQU	87h
040000             0092*  ffs_fexpand:		EQU	88h
040000             0093*  ffs_fgets:		EQU	89h
040000             0094*  ffs_fputc:		EQU	8Ah
040000             0095*  ffs_fputs:		EQU	8Bh
040000             0096*  ffs_fprintf:		EQU	8Ch
040000             0097*  ffs_ftell:		EQU	8Dh
040000             0098*  ffs_feof:		EQU	8Eh
040000             0099*  ffs_fsize:		EQU	8Fh
040000             0100*  ffs_ferror:		EQU	90h
040000             0101*  
040000             0102*  ; FatFS directory access functions
040000             0103*  ;
040000             0104*  ffs_dopen:		EQU	91h
040000             0105*  ffs_dclose:		EQU	92h
040000             0106*  ffs_dread:		EQU	93h
040000             0107*  ffs_dfindfirst:		EQU	94h
040000             0108*  ffs_dfindnext:		EQU	95h
040000             0109*  
040000             0110*  ; FatFS file and directory management functions
040000             0111*  ;
040000             0112*  ffs_stat:		EQU	96h
040000             0113*  ffs_unlink:		EQU	97h
040000             0114*  ffs_rename:		EQU	98h
040000             0115*  ffs_chmod:		EQU	99h
040000             0116*  ffs_utime:		EQU	9Ah
040000             0117*  ffs_mkdir:		EQU	9Bh
040000             0118*  ffs_chdir:		EQU	9Ch
040000             0119*  ffs_chdrive:		EQU	9Dh
040000             0120*  ffs_getcwd:		EQU	9Eh
040000             0121*  
040000             0122*  ; FatFS volume management and system configuration functions
040000             0123*  ;
040000             0124*  ffs_mount:		EQU	9Fh
040000             0125*  ffs_mkfs:		EQU	A0h
040000             0126*  ffs_fdisk:		EQU	A1h
040000             0127*  ffs_getfree:		EQU	A2h
040000             0128*  ffs_getlabel:		EQU	A3h
040000             0129*  ffs_setlabel:		EQU	A4h
040000             0130*  ffs_setcp:		EQU	A5h
040000             0131*  
040000             0132*  ; File access modes
040000             0133*  ;
040000             0134*  fa_read:		EQU	01h
040000             0135*  fa_write:		EQU	02h
040000             0136*  fa_open_existing:	EQU	00h
040000             0137*  fa_create_new:		EQU	04h
040000             0138*  fa_create_always:	EQU	08h
040000             0139*  fa_open_always:		EQU	10h
040000             0140*  fa_open_append:		EQU	30h
040000             0141*  
040000             0142*  ; System variable indexes for api_sysvars
040000             0143*  ; Index into _sysvars in globals.asm
040000             0144*  ;
040000             0145*  sysvar_time:		EQU	00h	; 4: Clock timer in centiseconds (incremented by 2 every VBLANK)
040000             0146*  sysvar_vpd_pflags:	EQU	04h	; 1: Flags to indicate completion of VDP commands
040000             0147*  sysvar_keyascii:	EQU	05h	; 1: ASCII keycode, or 0 if no key is pressed
040000             0148*  sysvar_keymods:		EQU	06h	; 1: Keycode modifiers
040000             0149*  sysvar_cursorX:		EQU	07h	; 1: Cursor X position
040000             0150*  sysvar_cursorY:		EQU	08h	; 1: Cursor Y position
040000             0151*  sysvar_scrchar:		EQU	09h	; 1: Character read from screen
040000             0152*  sysvar_scrpixel:	EQU	0Ah	; 3: Pixel data read from screen (R,B,G)
040000             0153*  sysvar_audioChannel:	EQU	0Dh	; 1: Audio channel
040000             0154*  sysvar_audioSuccess:	EQU	0Eh	; 1: Audio channel note queued (0 = no, 1 = yes)
040000             0155*  sysvar_scrWidth:	EQU	0Fh	; 2: Screen width in pixels
040000             0156*  sysvar_scrHeight:	EQU	11h	; 2: Screen height in pixels
040000             0157*  sysvar_scrCols:		EQU	13h	; 1: Screen columns in characters
040000             0158*  sysvar_scrRows:		EQU	14h	; 1: Screen rows in characters
040000             0159*  sysvar_scrColours:	EQU	15h	; 1: Number of colours displayed
040000             0160*  sysvar_scrpixelIndex:	EQU	16h	; 1: Index of pixel data read from screen
040000             0161*  sysvar_vkeycode:	EQU	17h	; 1: Virtual key code from FabGL
040000             0162*  sysvar_vkeydown:	EQU	18h	; 1: Virtual key state from FabGL (0=up, 1=down)
040000             0163*  sysvar_vkeycount:	EQU	19h	; 1: Incremented every time a key packet is received
040000             0164*  sysvar_rtc:		EQU	1Ah	; 6: Real time clock data
040000             0165*  sysvar_spare:		EQU	20h	; 2: Spare, previously used by rtc
040000             0166*  sysvar_keydelay:	EQU	22h	; 2: Keyboard repeat delay
040000             0167*  sysvar_keyrate:		EQU	24h	; 2: Keyboard repeat reat
040000             0168*  sysvar_keyled:		EQU	26h	; 1: Keyboard LED status
040000             0169*  sysvar_scrMode:		EQU	27h	; 1: Screen mode
040000             0170*  sysvar_rtcEnable:	EQU	28h	; 1: RTC enable flag (0: disabled, 1: use ESP32 RTC)
040000             0171*  sysvar_mouseX:		EQU	29h	; 2: Mouse X position
040000             0172*  sysvar_mouseY:		EQU	2Bh	; 2: Mouse Y position
040000             0173*  sysvar_mouseButtons:	EQU	2Dh	; 1: Mouse button state
040000             0174*  sysvar_mouseWheel:	EQU	2Eh	; 1: Mouse wheel delta
040000             0175*  sysvar_mouseXDelta:	EQU	2Fh	; 2: Mouse X delta
040000             0176*  sysvar_mouseYDelta:	EQU	31h	; 2: Mouse Y delta
040000             0177*  
040000             0178*  ; Flags for the VPD protocol
040000             0179*  ;
040000             0180*  vdp_pflag_cursor:	EQU	00000001b
040000             0181*  vdp_pflag_scrchar:	EQU	00000010b
040000             0182*  vdp_pflag_point:	EQU	00000100b
040000             0183*  vdp_pflag_audio:	EQU	00001000b
040000             0184*  vdp_pflag_mode:		EQU	00010000b
040000             0185*  vdp_pflag_rtc:		EQU	00100000b
040000             0186*  vdp_pflag_mouse:	EQU	01000000b
040000             0187*  ; vdp_pflag_buffered:	EQU	10000000b
040000             0188*  
040000             0189*  ;
040000             0190*  ; FatFS structures
040000             0191*  ; These mirror the structures contained in src_fatfs/ff.h in the MOS project
040000             0192*  ;
040000             0193*  ; Object ID and allocation information (FFOBJID)
040000             0194*  ;
040000             0195*  ;FFOBJID	.STRUCT
040000             0196*  ;	fs:		DS	3	; Pointer to the hosting volume of this object
040000             0197*  ;	id:		DS	2	; Hosting volume mount ID
040000             0198*  ;	attr:		DS	1	; Object attribute;
040000             0199*  ;	stat:		DS	1	; Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched)
040000             0200*  ;	sclust:		DS	4	; Object data start cluster (0:no cluster or root directory)
040000             0201*  ;	objsize:	DS	4	; Object size (valid when sclust != 0)
040000             0202*  ;FFOBJID_SIZE .ENDSTRUCT FFOBJID
040000             0203*  ;
040000             0204*  ; File object structure (FIL)
040000             0205*  ;
040000             0206*  ;FIL .STRUCT
040000             0207*  ;	obj:		.TAG	FFOBJID	; Object identifier
040000             0208*  ;	flag:		DS	1	; File status flags
040000             0209*  ;	err:		DS	1	; Abort flag (error code)
040000             0210*  ;	fptr:		DS	4	; File read/write pointer (Zeroed on file open)
040000             0211*  ;	clust:		DS	4	; Current cluster of fpter (invalid when fptr is 0)
040000             0212*  ;	sect:		DS	4	; Sector number appearing in buf[] (0:invalid)
040000             0213*  ;	dir_sect:	DS	4	; Sector number containing the directory entry
040000             0214*  ;	dir_ptr:	DS	3	; Pointer to the directory entry in the win[]
040000             0215*  ;FIL_SIZE .ENDSTRUCT FIL
040000             0216*  ;
040000             0217*  ; Directory object structure (DIR)
040000             0218*  ;
040000             0219*  ;DIR .STRUCT
040000             0220*  ;	obj:		.TAG	FFOBJID	; Object identifier;
040000             0221*  ;	dptr:		DS	4	; Current read/write offset
040000             0222*  ;	clust:		DS	4	; Current cluster
040000             0223*  ;	sect:		DS	4	; Current sector (0:Read operation has terminated)
040000             0224*  ;	dir:		DS	3	; Pointer to the directory item in the win[]
040000             0225*  ;	fn:		DS	12	; SFN (in/out) {body[8],ext[3],status[1]}
040000             0226*  ;	blk_ofs:	DS	4	; Offset of current entry block being processed (0xFFFFFFFF:Invalid)
040000             0227*  ;DIR_SIZE .ENDSTRUCT DIR
040000             0228*  ;
040000             0229*  ; File information structure (FILINFO)
040000             0230*  ;
040000             0231*  ;FILINFO .STRUCT
040000             0232*  ;	fsize:		DS 	4	; File size
040000             0233*  ;	fdate:		DS	2	; Modified date;
040000             0234*  ;	ftime:		DS	2	; Modified time
040000             0235*  ;	fattrib:	DS	1	; File attribute
040000             0236*  ;	altname:	DS	13	; Alternative file name
040000             0237*  ;	fname:		DS	256	; Primary file name
040000             0238*  ;FILINFO_SIZE .ENDSTRUCT FILINFO
040000             0239*  
040000             0240*  ;
040000             0241*  ; Macro for calling the API
040000             0242*  ; Parameters:
040000             0243*  ; - function: One of the function numbers listed above
040000             0244*  ;
040000             0245*  			MACRO	MOSCALL function
040000             0246*  			LD	A, function
040000             0247*  			RST.L	08h
040000             0248*  			ENDMACRO
040000             0008       ORG 0x0B0000 ; Is a moslet
0B0000             0009   
0B0000             0010       MACRO PROGNAME
0B0000             0011       ASCIZ "scratch.bin"
0B0000             0012       ENDMACRO
0B0000             0013   
0B0000             0014   ; STANDARD MOSLET INCLUDES
0B0000             0015       include "init.inc"
0B0000             0001*  ;
0B0000             0002*  ; Title:	Copy - Initialisation Code
0B0000             0003*  ; Author:	Dean Belfield, Lennart Benschop
0B0000             0004*  ; Created:	06/11/2022
0B0000             0005*  ; Last Updated:	26/12/2022
0B0000             0006*  ;
0B0000             0007*  ; Modinfo:
0B0000             0008*  ; 17/12/2022:	Added parameter processing
0B0000             0009*  ; 26/12/2022:   Adapted to Copy program, use LEA instead of 3x INC IX, Save/restore MB
0B0000             0010*  ; Changed:      08/04/2924 adapt to ez80asm
0B0000             0011*  
0B0000             0012*  
0B0000             0013*  argv_ptrs_max:		EQU	16			; Maximum number of arguments allowed in argv
0B0000             0014*  
0B0000             0015*  ;
0B0000             0016*  ; Start in ADL mode
0B0000             0017*  ;
0B0000 C3 45 00 0B 0018*  			JP	_start			; Jump to start
0B0004             0019*  ;
0B0004             0020*  ; The header stuff is from byte 64 onwards
0B0004             0021*  ;
0B0004             0022*  
0B0004             0023*  _exec_name:
0B0004             0024*  			PROGNAME			; The executable name, only used in argv
0B0004 73 63 72 61 0001*M     ASCIZ "scratch.bin"
       74 63 68 2E 
       62 69 6E 00 
0B0010             0025*  
0B0010 FF FF FF FF 0026*  			ALIGN	64
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
       FF FF FF FF 
0B0040             0027*  
0B0040 4D 4F 53    0028*  			DB	"MOS"			; Flag for MOS - to confirm this is a valid MOS command
0B0043 00          0029*  			DB	00h			; MOS header version 0
0B0044 01          0030*  			DB	01h			; Flag for run mode (0: Z80, 1: ADL)
0B0045             0031*  ;
0B0045             0032*  ; And the code follows on immediately after the header
0B0045             0033*  ;
0B0045 F5          0034*  _start:			PUSH	AF			; Preserve the registers
0B0046 C5          0035*  			PUSH	BC
0B0047 D5          0036*  			PUSH	DE
0B0048 DD E5       0037*  			PUSH	IX
0B004A FD E5       0038*  			PUSH	IY
0B004C ED 6E       0039*  			LD	A, MB			; Save MB
0B004E F5          0040*  			PUSH 	AF
0B004F AF          0041*  			XOR 	A
0B0050 ED 6D       0042*  			LD 	MB, A                   ; Clear to zero so MOS API calls know how to use 24-bit addresses.
0B0052             0043*  
0B0052 DD 21 B9 00 0044*  			LD	IX, argv_ptrs		; The argv array pointer address
       0B          
0B0057 DD E5       0045*  			PUSH	IX
0B0059 CD 70 00 0B 0046*  			CALL	_parse_params		; Parse the parameters
0B005D DD E1       0047*  			POP	IX			; IX: argv
0B005F 06 00       0048*  			LD	B, 0			;  C: argc
0B0061 CD 58 19 0B 0049*  			CALL	_main			; Start user code
0B0065             0050*  
0B0065 F1          0051*  			POP 	AF
0B0066 ED 6D       0052*  			LD	MB, A
0B0068 FD E1       0053*  			POP	IY			; Restore registers
0B006A DD E1       0054*  			POP	IX
0B006C D1          0055*  			POP	DE
0B006D C1          0056*  			POP	BC
0B006E F1          0057*  			POP	AF
0B006F C9          0058*  			RET
0B0070             0059*  
0B0070             0060*  ; Parse the parameter string into a C array
0B0070             0061*  ; Parameters
0B0070             0062*  ; - HL: Address of parameter string
0B0070             0063*  ; - IX: Address for array pointer storage
0B0070             0064*  ; Returns:
0B0070             0065*  ; -  C: Number of parameters parsed
0B0070             0066*  ;
0B0070 01 04 00 0B 0067*  _parse_params:		LD	BC, _exec_name
0B0074 DD 0F 00    0068*  			LD	(IX+0), BC		; ARGV[0] = the executable name
0B0077 ED 32 03    0069*  			LEA     IX, IX+3
0B007A CD B2 00 0B 0070*  			CALL	_skip_spaces		; Skip HL past any leading spaces
0B007E             0071*  ;
0B007E 01 01 00 00 0072*  			LD	BC, 1			; C: ARGC = 1 - also clears out top 16 bits of BCU
0B0082 06 0F       0073*  			LD	B, argv_ptrs_max - 1	; B: Maximum number of argv_ptrs
0B0084             0074*  ;
0B0084             0075*  _parse_params_1:
0B0084 C5          0076*  			PUSH	BC			; Stack ARGC
0B0085 E5          0077*  			PUSH	HL			; Stack start address of token
0B0086 CD A3 00 0B 0078*  			CALL	_get_token		; Get the next token
0B008A 79          0079*  			LD	A, C			; A: Length of the token in characters
0B008B D1          0080*  			POP	DE			; Start address of token (was in HL)
0B008C C1          0081*  			POP	BC			; ARGC
0B008D B7          0082*  			OR	A			; Check for A=0 (no token found) OR at end of string
0B008E C8          0083*  			RET	Z
0B008F             0084*  ;
0B008F DD 1F 00    0085*  			LD	(IX+0), DE		; Store the pointer to the token
0B0092 E5          0086*  			PUSH	HL			; DE=HL
0B0093 D1          0087*  			POP	DE
0B0094 CD B2 00 0B 0088*  			CALL	_skip_spaces		; And skip HL past any spaces onto the next character
0B0098 AF          0089*  			XOR	A
0B0099 12          0090*  			LD	(DE), A			; Zero-terminate the token
0B009A ED 32 03    0091*  			LEA  	IX, IX+3			; Advance to next pointer position
0B009D 0C          0092*  			INC	C			; Increment ARGC
0B009E 79          0093*  			LD	A, C			; Check for C >= A
0B009F B8          0094*  			CP	B
0B00A0 38 E2       0095*  			JR	C, _parse_params_1	; And loop
0B00A2 C9          0096*  			RET
0B00A3             0097*  
0B00A3             0098*  ; Get the next token
0B00A3             0099*  ; Parameters:
0B00A3             0100*  ; - HL: Address of parameter string
0B00A3             0101*  ; Returns:
0B00A3             0102*  ; - HL: Address of first character after token
0B00A3             0103*  ; -  C: Length of token (in characters)
0B00A3             0104*  ;
0B00A3 0E 00       0105*  _get_token:		LD	C, 0			; Initialise length
0B00A5 7E          0106*  @@:			LD	A, (HL)			; Get the character from the parameter string
0B00A6 B7          0107*  			OR	A			; Exit if 0 (end of parameter string in MOS)
0B00A7 C8          0108*  			RET 	Z
0B00A8 FE 0D       0109*  			CP	13			; Exit if CR (end of parameter string in BBC BASIC)
0B00AA C8          0110*  			RET	Z
0B00AB FE 20       0111*  			CP	' '			; Exit if space (end of token)
0B00AD C8          0112*  			RET	Z
0B00AE 23          0113*  			INC	HL			; Advance to next character
0B00AF 0C          0114*  			INC 	C			; Increment length
0B00B0 18 F3       0115*  			JR	@B
0B00B2             0116*  
0B00B2             0117*  ; Skip spaces in the parameter string
0B00B2             0118*  ; Parameters:
0B00B2             0119*  ; - HL: Address of parameter string
0B00B2             0120*  ; Returns:
0B00B2             0121*  ; - HL: Address of next none-space character
0B00B2             0122*  ;    F: Z if at end of string, otherwise NZ if there are more tokens to be parsed
0B00B2             0123*  ;
0B00B2 7E          0124*  _skip_spaces:		LD	A, (HL)			; Get the character from the parameter string
0B00B3 FE 20       0125*  			CP	' '			; Exit if not space
0B00B5 C0          0126*  			RET	NZ
0B00B6 23          0127*  			INC	HL			; Advance to next character
0B00B7 18 F9       0128*  			JR	_skip_spaces		; Increment length
0B00B9             0129*  
0B00B9             0130*  ; Storage for the argv array pointers
0B00B9             0131*  ;
0B00B9 00 00 00 00 0132*  argv_ptrs:		BLKP	argv_ptrs_max, 0
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B00E9             0016       include "parse.inc"
0B00E9             0001*  ;
0B00E9             0002*  ; Title:	Number Parsing Functions
0B00E9             0003*  ; Author:	Dean Belfield
0B00E9             0004*  ; Created:	15/11/2022
0B00E9             0005*  ; Last Updated:	15/11/2022
0B00E9             0006*  ; Last Updated: 29/12/2022 Lennart Benchop adapt for 24-bit mode.
0B00E9             0007*  ; Modinfo:
0B00E9             0008*  ; 2024/04/08    Adapt for ez80asm
0B00E9             0009*  
0B00E9             0010*  ; Read a number and convert to binary
0B00E9             0011*  ; If prefixed with &, will read as hex, otherwise decimal
0B00E9             0012*  ;   Inputs: HL: Pointer in string buffer
0B00E9             0013*  ;  Outputs: HL: Updated text pointer
0B00E9             0014*  ;           DE: Value
0B00E9             0015*  ;            A: Terminator (spaces skipped)
0B00E9             0016*  ;            F: Carry set if valid number, otherwise reset
0B00E9             0017*  ; Destroys: A,D,E,H,L,F
0B00E9             0018*  ;
0B00E9 11 00 00 00 0019*  ASC_TO_NUMBER:		LD		DE, 0			; Initialise DE
0B00ED CD B2 00 0B 0020*  			CALL		_skip_spaces		; Skip whitespace
0B00F1 7E          0021*  			LD		A, (HL)			; Read first character
0B00F2 B7          0022*  			OR		A			; Check for end of string
0B00F3 C8          0023*  			RET		Z			; Return with no carry if not
0B00F4 C5          0024*  			PUSH		BC			; Preserve BC
0B00F5 FE 26       0025*  			CP		'&'			; Is it prefixed with '&' (HEX number)?
0B00F7 20 23       0026*  			JR		NZ, ASC_TO_NUMBER3	; Jump to decimal parser if not
0B00F9 23          0027*  			INC		HL			; Otherwise fall through to ASC_TO_HEX
0B00FA             0028*  ;
0B00FA 7E          0029*  ASC_TO_NUMBER1:		LD		A, (HL)			; Fetch the character
0B00FB CD 3D 01 0B 0030*  			CALL   	 	UPPRC			; Convert to uppercase
0B00FF D6 30       0031*  			SUB		'0'			; Normalise to 0
0B0101 38 37       0032*  			JR 		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0103 FE 0A       0033*  			CP 		10			; Check if >= 10
0B0105 38 06       0034*  			JR 		C, ASC_TO_NUMBER2	; No, so skip next bit
0B0107 D6 07       0035*  			SUB 		7			; Adjust ASCII A-F to nibble
0B0109 FE 10       0036*  			CP 		16			; Check for > F
0B010B 30 2D       0037*  			JR 		NC, ASC_TO_NUMBER4	; Return if out of range
0B010D             0038*  ;
0B010D E5          0039*  ASC_TO_NUMBER2:		PUSH		HL			; Stack HL
0B010E D5          0040*  			PUSH		DE			; LD HL, DE
0B010F E1          0041*  			POP		HL
0B0110 29          0042*  			ADD		HL, HL
0B0111 29          0043*  			ADD		HL, HL
0B0112 29          0044*  			ADD		HL, HL
0B0113 29          0045*  			ADD		HL, HL
0B0114 E5          0046*  			PUSH		HL			; LD DE, HL
0B0115 D1          0047*  			POP		DE
0B0116 E1          0048*  			POP		HL			; Restore HL
0B0117 B3          0049*  			OR      	E			; OR the new digit in to the least significant nibble
0B0118 5F          0050*  			LD      	E, A
0B0119             0051*  ;
0B0119 23          0052*  			INC		HL			; Onto the next character
0B011A 18 DE       0053*  			JR      	ASC_TO_NUMBER1		; And loop
0B011C             0054*  ;
0B011C 7E          0055*  ASC_TO_NUMBER3:		LD		A, (HL)
0B011D D6 30       0056*  			SUB		'0'			; Normalise to 0
0B011F 38 19       0057*  			JR		C, ASC_TO_NUMBER4	; Return if < ASCII '0'
0B0121 FE 0A       0058*  			CP		10			; Check if >= 10
0B0123 30 15       0059*  			JR		NC, ASC_TO_NUMBER4	; Return if >= 10
0B0125             0060*  ;
0B0125 E5          0061*  			PUSH		HL			; Stack HL
0B0126 D5          0062*  			PUSH		DE			; LD HL, DE
0B0127 E1          0063*  			POP		HL
0B0128 E5          0064*  			PUSH		HL			; LD BC, HL
0B0129 C1          0065*  			POP		BC
0B012A 29          0066*  			ADD		HL, HL 			; x 2
0B012B 29          0067*  			ADD		HL, HL 			; x 4
0B012C 09          0068*  			ADD		HL, BC 			; x 5
0B012D 29          0069*  			ADD		HL, HL 			; x 10
0B012E 01 00 00 00 0070*  			LD		BC, 0
0B0132 4F          0071*  			LD 		C, A			; LD BCU, A
0B0133 09          0072*  			ADD		HL, BC			; Add BCU to HL
0B0134 E5          0073*  			PUSH		HL			; LD DE, HL
0B0135 D1          0074*  			POP		DE
0B0136 E1          0075*  			POP		HL			; Restore HL
0B0137             0076*  ;
0B0137 23          0077*  			INC		HL
0B0138 18 E2       0078*  			JR		ASC_TO_NUMBER3
0B013A C1          0079*  ASC_TO_NUMBER4:		POP		BC
0B013B 37          0080*  			SCF					; We have a valid number so set carry
0B013C C9          0081*  			RET
0B013D             0082*  
0B013D             0083*  
0B013D             0084*  ; Convert a character to upper case
0B013D             0085*  ;  A: Character to convert
0B013D             0086*  ;
0B013D E6 7F       0087*  UPPRC:  		AND     	7FH
0B013F FE 60       0088*  			CP      	'`'
0B0141 D8          0089*  			RET     	C
0B0142 E6 5F       0090*  			AND     	5FH			; Convert to upper case
0B0144 C9          0091*  			RET
0B0145             0092*  
0B0145             0093*  
0B0145             0094*  ;------------------------------------------------------------------------
0B0145             0095*  ; Read a number and convert to binary (decimal only)
0B0145             0096*  ; Inputs: hl: Pointer in string buffer
0B0145             0097*  ; Outputs: hl: Updated text pointer
0B0145             0098*  ;         de: Value
0B0145             0099*  ;         a: Terminator (spaces skipped)
0B0145             0100*  ;         f: Carry set if valid number, otherwise reset
0B0145             0101*  ; Destroys: a, d, e, h, l, f
0B0145             0102*  ;------------------------------------------------------------------------
0B0145             0103*  asc_to_s24:
0B0145 3E 01       0104*      ld a,1 ; set sign flag
0B0147 32 97 01 0B 0105*      ld (@sign),a ; store sign flag
0B014B             0106*  
0B014B 11 00 00 00 0107*      ld de, 0 ; initialise de
0B014F CD B2 00 0B 0108*      call _skip_spaces ; skip whitespace
0B0153             0109*  
0B0153 7E          0110*      ld a, (hl) ; read first character
0B0154 B7          0111*      or a ; check for end of string
0B0155 C8          0112*      ret z ; return with no carry if not
0B0156             0113*  
0B0156 C5          0114*      push bc ; preserve bc
0B0157             0115*  
0B0157 FE 2D       0116*      cp '-' ; check for negative number
0B0159 C2 63 01 0B 0117*      jp nz,@loop ; number is positive, nothing more to do
0B015D AF          0118*      xor a ; sign flag to zero
0B015E 32 97 01 0B 0119*      ld (@sign),a ; store sign flag
0B0162 23          0120*      inc hl ; skip '-'
0B0163             0121*  
0B0163             0122*  @loop:
0B0163 7E          0123*      ld a, (hl)
0B0164 D6 30       0124*      sub '0' ; normalise to 0
0B0166 38 19       0125*      jr c, @integer_end ; return if < ascii '0'
0B0168 FE 0A       0126*      cp 10 ; check if >= 10
0B016A 30 15       0127*      jr nc, @integer_end ; return if >= 10
0B016C E5          0128*      push hl ; stack hl
0B016D D5          0129*      push de ; ld hl, de
0B016E E1          0130*      pop hl
0B016F E5          0131*      push hl ; ld bc, hl
0B0170 C1          0132*      pop bc
0B0171 29          0133*      add hl, hl ; x 2
0B0172 29          0134*      add hl, hl ; x 4
0B0173 09          0135*      add hl, bc ; x 5
0B0174 29          0136*      add hl, hl ; x 10
0B0175 01 00 00 00 0137*      ld bc, 0
0B0179 4F          0138*      ld c, a ; ld bcu, a
0B017A 09          0139*      add hl, bc ; add bcu to hl
0B017B E5          0140*      push hl ; ld de, hl
0B017C D1          0141*      pop de
0B017D E1          0142*      pop hl ; restore hl
0B017E 23          0143*      inc hl
0B017F 18 E2       0144*      jr @loop
0B0181             0145*  
0B0181             0146*  @integer_end:
0B0181 C1          0147*      pop bc ; send bc back how she came in
0B0182 3A 97 01 0B 0148*      ld a, (@sign) ; get sign flag
0B0186 3D          0149*      dec a ; check if negative
0B0187 F2 95 01 0B 0150*      jp p,@pos ; positive number
0B018B             0151*  
0B018B             0152*  ; Negate de
0B018B E5          0153*      push hl ; save text pointer
0B018C 21 00 00 00 0154*      ld hl, 0
0B0190 AF          0155*      xor a ; clear carry
0B0191 ED 52       0156*      sbc hl, de ; subtract DE from HL
0B0193 EB          0157*      ex de, hl ; DE = 0-HL
0B0194 E1          0158*      pop hl ; restore text pointer
0B0195             0159*  
0B0195             0160*  @pos:
0B0195 37          0161*      scf ; we have a valid number so set carry
0B0196 C9          0162*      ret
0B0197             0163*  
0B0197 00          0164*  @sign: db 0 ; sign flag buffer
0B0198             0165*  
0B0198             0166*  
0B0198             0167*  ;------------------------------------------------------------------------
0B0198             0168*  ; Read a number and convert to binary (decimal only)
0B0198             0169*  ; Inputs: hl: Pointer in string buffer
0B0198             0170*  ; Outputs: hl: Updated text pointer
0B0198             0171*  ;         de: Value
0B0198             0172*  ;         a: Terminator (spaces skipped)
0B0198             0173*  ;         f: Carry set if valid number, otherwise reset
0B0198             0174*  ; Destroys: a, d, e, h, l, f
0B0198             0175*  ;------------------------------------------------------------------------
0B0198             0176*  asc_to_s168:
0B0198 3E 01       0177*      ld a,1 ; set sign flag
0B019A 32 57 02 0B 0178*      ld (@sign),a ; store sign flag
0B019E             0179*  
0B019E 11 00 00 00 0180*      ld de, 0 ; initialise de
0B01A2 ED 53 4F 02 0181*      ld (@result), de ; clear low bytes of result buffer
       0B          
0B01A7 ED 53 53 02 0182*      ld (@scratch), de ; clear low bytes of scratch buffer
       0B          
0B01AC             0183*  
0B01AC CD B2 00 0B 0184*      call _skip_spaces ; skip whitespace
0B01B0             0185*  
0B01B0 7E          0186*      ld a, (hl) ; read first character
0B01B1 B7          0187*      or a ; check for end of string
0B01B2 C8          0188*      ret z ; return with no carry if not
0B01B3             0189*  
0B01B3 C5          0190*      push bc ; preserve bc
0B01B4             0191*  
0B01B4 FE 2D       0192*      cp '-' ; check for negative number
0B01B6 C2 C0 01 0B 0193*      jp nz,@loop ; number is positive, nothing more to do
0B01BA AF          0194*      xor a ; sign flag to zero
0B01BB 32 57 02 0B 0195*      ld (@sign),a ; store sign flag
0B01BF 23          0196*      inc hl ; skip '-'
0B01C0             0197*  
0B01C0             0198*  @loop:
0B01C0 7E          0199*      ld a, (hl)
0B01C1             0200*  
0B01C1             0201*  ; chcek for decimal point
0B01C1 FE 2E       0202*      cp '.' ; check for decimal point
0B01C3 CA 04 02 0B 0203*      jp z,@fractional_start ; jump to fractional part
0B01C7             0204*  
0B01C7             0205*  ; process integer part
0B01C7 D6 30       0206*      sub '0' ; normalise to 0
0B01C9 38 19       0207*      jr c, @integer_end ; return if < ascii '0'
0B01CB FE 0A       0208*      cp 10 ; check if >= 10
0B01CD 30 15       0209*      jr nc, @integer_end ; return if >= 10
0B01CF E5          0210*      push hl ; stack hl
0B01D0 D5          0211*      push de ; ld hl, de
0B01D1 E1          0212*      pop hl
0B01D2 E5          0213*      push hl ; ld bc, hl
0B01D3 C1          0214*      pop bc
0B01D4 29          0215*      add hl, hl ; x 2
0B01D5 29          0216*      add hl, hl ; x 4
0B01D6 09          0217*      add hl, bc ; x 5
0B01D7 29          0218*      add hl, hl ; x 10
0B01D8 01 00 00 00 0219*      ld bc, 0
0B01DC 4F          0220*      ld c, a ; ld bcu, a
0B01DD 09          0221*      add hl, bc ; add bcu to hl
0B01DE E5          0222*      push hl ; ld de, hl
0B01DF D1          0223*      pop de
0B01E0 E1          0224*      pop hl ; restore hl
0B01E1 23          0225*      inc hl
0B01E2 18 DC       0226*      jr @loop
0B01E4             0227*  
0B01E4             0228*  @integer_end:
0B01E4 ED 53 50 02 0229*      ld (@result+1), de      ; Store integer part in result buffer (shifted up one byte)
       0B          
0B01E9             0230*  
0B01E9             0231*  @end:
0B01E9 C1          0232*      pop bc ; send bc back how she came in
0B01EA ED 5B 4F 02 0233*      ld de,(@result) ; will contain shifted integer part combined with any fractional value
       0B          
0B01EF 3A 57 02 0B 0234*      ld a, (@sign) ; get sign flag
0B01F3 3D          0235*      dec a ; check if negative
0B01F4 F2 02 02 0B 0236*      jp p,@pos ; positive number
0B01F8             0237*  
0B01F8             0238*  ; Negate de
0B01F8 E5          0239*      push hl ; save text pointer
0B01F9 21 00 00 00 0240*      ld hl, 0
0B01FD AF          0241*      xor a ; clear carry
0B01FE ED 52       0242*      sbc hl, de ; subtract DE from HL
0B0200 EB          0243*      ex de, hl ; DE = 0-HL
0B0201 E1          0244*      pop hl ; restore text pointer
0B0202             0245*  
0B0202             0246*  @pos:
0B0202 37          0247*      scf ; we have a valid number so set carry
0B0203 C9          0248*      ret
0B0204             0249*  
0B0204             0250*  @fractional_start:
0B0204 ED 53 50 02 0251*      ld (@result+1), de         ; Store integer part in result buffer (shifted up one byte)
       0B          
0B0209 06 03       0252*      ld b, 3                    ; Set loop counter to 3 for up to three fractional digits
0B020B 11 00 00 00 0253*      ld de, 0                   ; Initialize DE as the fractional accumulator
0B020F DD 21 58 02 0254*      ld ix, powers_of_10        ; Point IX to the lookup table for the scaling factor based on digits
       0B          
0B0214 23          0255*      inc hl                     ; Skip decimal point
0B0215             0256*  
0B0215             0257*  @fractional_loop:
0B0215 7E          0258*      ld a, (hl)                 ; Load next character
0B0216 D6 30       0259*      sub '0'                    ; Normalize ASCII to decimal
0B0218 38 1C       0260*      jr c, @end_fraction        ; Exit if < '0'
0B021A FE 0A       0261*      cp 10
0B021C 30 18       0262*      jr nc, @end_fraction       ; Exit if >= 10
0B021E             0263*  
0B021E             0264*      ; Multiply the current fractional accumulator by 10
0B021E E5          0265*      push hl                    ; Save char pointer
0B021F F5          0266*      push af                    ; Save the digit
0B0220 EB          0267*      ex de, hl
0B0221 E5          0268*      push hl
0B0222 29          0269*      add hl,hl ; * 2
0B0223 29          0270*      add hl,hl ; * 4
0B0224 D1          0271*      pop de
0B0225 19          0272*      add hl,de ; * 5
0B0226 29          0273*      add hl,hl ; * 10
0B0227 11 00 00 00 0274*      ld de, 0                   ; Clear DEU
0B022B F1          0275*      pop af                     ; Restore the current digit
0B022C 5F          0276*      ld e, a                    ; Load the digit into E
0B022D 19          0277*      add hl, de                 ; Add the digit to the accumulator
0B022E EB          0278*      ex de, hl                  ; Result back to DE
0B022F ED 32 03    0279*      lea ix,ix+3                ; Advance IX to the next scaling factor
0B0232 E1          0280*      pop hl                     ; Restore char pointer
0B0233 23          0281*      inc hl                     ; Move to the next character
0B0234 10 DF       0282*      djnz @fractional_loop      ; Loop if more digits to process
0B0236             0283*  
0B0236             0284*  @end_fraction:
0B0236             0285*  ; Final scaling based on number of fractional digits processed
0B0236 ED 53 54 02 0286*      ld (@scratch+1), de          ; Shift fractional part up a byte
       0B          
0B023B 2A 53 02 0B 0287*      ld hl,(@scratch)             ; Load the shifted fractional part into HL
0B023F             0288*  
0B023F DD 17 00    0289*      ld de, (ix)                ; Load final scaling factor from IX based on digit count
0B0242 CD D5 0E 0B 0290*      call udiv24                ; Perform 24-bit division to scale down
0B0246 7B          0291*      ld a, e                    ; Load the low byte (8-bit fractional part) into A
0B0247 32 4F 02 0B 0292*      ld (@result), a            ; Store fractional part in result buffer
0B024B C3 E9 01 0B 0293*      jp @end                    ; Final sign check and flag setup
0B024F             0294*  
0B024F             0295*  @result: ds 4                  ; 32-bit result buffer to shift integer part up one byte
0B0253             0296*  @scratch: ds 4                 ; 32-bit scratch buffer for intermediate calculations
0B0257 00          0297*  @sign: db 0                    ; Sign flag buffer
0B0258             0298*  
0B0258             0299*  powers_of_10:
0B0258 01 00 00    0300*      dl 1                       ; 10^0
0B025B 0A 00 00    0301*      dl 10                      ; 10^1
0B025E 64 00 00    0302*      dl 100                     ; 10^2
0B0261 E8 03 00    0303*      dl 1000                    ; 10^3
0B0264 10 27 00    0304*      dl 10000                   ; 10^4
0B0267             0017   
0B0267             0018   ; API INCLUDES
0B0267             0019       include "functions.inc"
0B0267             0001*      MACRO printChar char
0B0267             0002*          LD A, char
0B0267             0003*          RST.LIL 10h
0B0267             0004*      ENDMACRO
0B0267             0005*  
0B0267             0006*  ; test the sign of HL
0B0267             0007*  ; inputs: HL obviously
0B0267             0008*  ; outputs: sign flag set if HL is negative, zero flag set if HL is zero
0B0267             0009*  ; destroys: flags
0B0267             0010*      MACRO signHL
0B0267             0011*          add hl,de
0B0267             0012*          or a
0B0267             0013*          sbc hl,de
0B0267             0014*      ENDMACRO
0B0267             0015*  
0B0267             0016*  ; Simulated call to subroutine at HL
0B0267             0017*  ; inputs: HL pointing to the subroutine address plus whatever the called function expects
0B0267             0018*  ; outputs: whatever the subroutine does, including HL and BC
0B0267             0019*  ; destroys: only what the subroutine does, but always BC
0B0267             0020*      MACRO callHL
0B0267             0021*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0022*          push bc       ; which constitutes the return address
0B0267             0023*          jp   (hl)     ; Jump to the address in HL
0B0267             0024*      ENDMACRO
0B0267             0025*  
0B0267             0026*  ; Simulated call to subroutine at IX
0B0267             0027*  ; inputs: IX pointing to the subroutine address plus whatever the called function expects
0B0267             0028*  ; outputs: whatever the subroutine does, including IX and BC
0B0267             0029*  ; destroys: only what the subroutine does, but always BC
0B0267             0030*      MACRO callIX
0B0267             0031*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0032*          push bc       ; which constitutes the return address
0B0267             0033*          jp   (ix)     ; Jump to the address in IX
0B0267             0034*      ENDMACRO
0B0267             0035*  
0B0267             0036*  ; Simulated call to soubroutinte at IY
0B0267             0037*  ; inputs: IY pointing to the subroutine address plus whatever the called function expects
0B0267             0038*  ; outputs: whatever the subroutine does, including IY and BC
0B0267             0039*  ; destroys: only what the subroutine does, but always BC
0B0267             0040*      MACRO callIY
0B0267             0041*          ld bc,$+7     ; Address of first instruction after the jump
0B0267             0042*          push bc       ; which constitutes the return address
0B0267             0043*          jp   (iy)     ; Jump to the address in IY
0B0267             0044*      ENDMACRO
0B0267             0045*  
0B0267             0046*      MACRO HLU_TO_A
0B0267             0047*          push hl
0B0267             0048*          inc sp
0B0267             0049*          pop af
0B0267             0050*          dec sp
0B0267             0051*      ENDMACRO
0B0267             0052*  
0B0267             0053*  ; https://github.com/envenomator/Agon/blob/master/ez80asm%20examples%20(annotated)/functions.s
0B0267             0054*  ; Print a zero-terminated string
0B0267             0055*  ; HL: Pointer to string
0B0267             0056*  printString:
0B0267 C5          0057*  	PUSH	BC
0B0268 01 00 00 00 0058*  	LD		BC,0
0B026C 3E 00       0059*  	LD 	 	A,0
0B026E 5B DF       0060*  	RST.LIL 18h
0B0270 C1          0061*  	POP		BC
0B0271 C9          0062*  	RET
0B0272             0063*  ; print a VDU sequence
0B0272             0064*  ; HL: Pointer to VDU sequence - <1 byte length> <data>
0B0272             0065*  sendVDUsequence:
0B0272 C5          0066*  	PUSH	BC
0B0273 01 00 00 00 0067*  	LD		BC, 0
0B0277 4E          0068*  	LD		C, (HL)
0B0278 5B DF       0069*  	RST.LIL	18h
0B027A C1          0070*  	POP		BC
0B027B C9          0071*  	RET
0B027C             0072*  ; Print Newline sequence to VDP
0B027C             0073*  printNewLine:
0B027C F5          0074*      push af ; for some reason rst.lil 10h sets carry flag
0B027D 3E 0D       0075*  	LD	A, '\r'
0B027F 5B D7       0076*  	RST.LIL 10h
0B0281 3E 0A       0077*  	LD	A, '\n'
0B0283 5B D7       0078*  	RST.LIL 10h
0B0285 F1          0079*      pop af
0B0286 C9          0080*  	RET
0B0287             0081*  
0B0287             0082*  ; Print a 24-bit HEX number
0B0287             0083*  ; HLU: Number to print
0B0287             0084*  printHex24:
0B0287 E5          0085*  	PUSH	HL
0B0288 21 02 00 00 0086*  	LD		HL, 2
0B028C 39          0087*  	ADD		HL, SP
0B028D 7E          0088*  	LD		A, (HL)
0B028E E1          0089*  	POP		HL
0B028F CD 99 02 0B 0090*  	CALL	printHex8
0B0293             0091*  ; Print a 16-bit HEX number
0B0293             0092*  ; HL: Number to print
0B0293             0093*  printHex16:
0B0293 7C          0094*  	LD		A,H
0B0294 CD 99 02 0B 0095*  	CALL	printHex8
0B0298 7D          0096*  	LD		A,L
0B0299             0097*  ; Print an 8-bit HEX number
0B0299             0098*  ; A: Number to print
0B0299             0099*  printHex8:
0B0299 4F          0100*  	LD		C,A
0B029A 1F          0101*  	RRA
0B029B 1F          0102*  	RRA
0B029C 1F          0103*  	RRA
0B029D 1F          0104*  	RRA
0B029E CD A3 02 0B 0105*  	CALL	@F
0B02A2 79          0106*  	LD		A,C
0B02A3             0107*  @@:
0B02A3 E6 0F       0108*  	AND		0Fh
0B02A5 C6 90       0109*  	ADD		A,90h
0B02A7 27          0110*  	DAA
0B02A8 CE 40       0111*  	ADC		A,40h
0B02AA 27          0112*  	DAA
0B02AB 5B D7       0113*  	RST.LIL	10h
0B02AD C9          0114*  	RET
0B02AE             0115*  
0B02AE             0116*  printHexA:
0B02AE F5          0117*      push af
0B02AF C5          0118*      push bc
0B02B0 CD 99 02 0B 0119*      call printHex8
0B02B4 C1          0120*      pop bc
0B02B5 F1          0121*      pop af
0B02B6 C9          0122*      ret
0B02B7             0123*  
0B02B7             0124*  printHexHL:
0B02B7 F5          0125*      push af
0B02B8 C5          0126*      push bc
0B02B9 CD 93 02 0B 0127*      call printHex16
0B02BD C1          0128*      pop bc
0B02BE F1          0129*      pop af
0B02BF             0130*  
0B02BF             0131*  printHexUHL:
0B02BF F5          0132*      push af
0B02C0 C5          0133*      push bc
0B02C1 CD 87 02 0B 0134*      call printHex24
0B02C5 C1          0135*      pop bc
0B02C6 F1          0136*      pop af
0B02C7             0137*  
0B02C7             0138*  printHexABHL:
0B02C7             0139*  ; preserve registers
0B02C7 C5          0140*      push bc ; b will be ok c will not
0B02C8 F5          0141*      push af ; will get totally destroyed
0B02C9             0142*  ; print a
0B02C9 CD 99 02 0B 0143*      call printHex8
0B02CD             0144*  ; print b
0B02CD 78          0145*      ld a,b
0B02CE CD 99 02 0B 0146*      call printHex8
0B02D2             0147*  ; print hl
0B02D2 CD 93 02 0B 0148*      call printHex16
0B02D6             0149*  ; restore registers
0B02D6 F1          0150*      pop af
0B02D7 C1          0151*      pop bc
0B02D8 C9          0152*      ret
0B02D9             0153*  
0B02D9             0154*  printHexBHL:
0B02D9             0155*  ; preserve registers
0B02D9 C5          0156*      push bc ; b will be ok c will not
0B02DA F5          0157*      push af ; will get totally destroyed
0B02DB             0158*  ; print b
0B02DB 78          0159*      ld a,b
0B02DC CD 99 02 0B 0160*      call printHex8
0B02E0             0161*  ; print hl
0B02E0 CD 93 02 0B 0162*      call printHex16
0B02E4             0163*  ; restore registers
0B02E4 F1          0164*      pop af
0B02E5 C1          0165*      pop bc
0B02E6 C9          0166*      ret
0B02E7             0167*  
0B02E7             0168*  printHexCDE:
0B02E7             0169*  ; preserve registers
0B02E7 C5          0170*      push bc ; b will be ok c will not
0B02E8 F5          0171*      push af ; will get totally destroyed
0B02E9             0172*  ; print c
0B02E9 79          0173*      ld a,c
0B02EA CD 99 02 0B 0174*      call printHex8
0B02EE             0175*  ; print de
0B02EE EB          0176*      ex de,hl
0B02EF CD 93 02 0B 0177*      call printHex16
0B02F3 EB          0178*      ex de,hl
0B02F4             0179*  ; restore registers
0B02F4 F1          0180*      pop af
0B02F5 C1          0181*      pop bc
0B02F6 C9          0182*      ret
0B02F7             0183*  
0B02F7             0184*  ; Print a 0x HEX prefix
0B02F7             0185*  DisplayHexPrefix:
0B02F7 3E 30       0186*  	LD	A, '0'
0B02F9 5B D7       0187*  	RST.LIL 10h
0B02FB 3E 78       0188*  	LD	A, 'x'
0B02FD 5B D7       0189*  	RST.LIL 10h
0B02FF C9          0190*  	RET
0B0300             0191*  
0B0300             0192*      MACRO printDecBC
0B0300             0193*          push hl
0B0300             0194*          push bc
0B0300             0195*          pop hl
0B0300             0196*          call printDec
0B0300             0197*          pop hl
0B0300             0198*      ENDMACRO
0B0300             0199*  
0B0300             0200*      MACRO printDecDE
0B0300             0201*          push hl
0B0300             0202*          push de
0B0300             0203*          pop hl
0B0300             0204*          call printDec
0B0300             0205*          pop hl
0B0300             0206*      ENDMACRO
0B0300             0207*  
0B0300             0208*      MACRO printDecHL
0B0300             0209*          call printDec
0B0300             0210*      ENDMACRO
0B0300             0211*  
0B0300             0212*      MACRO printDecIX
0B0300             0213*          push hl
0B0300             0214*          push ix
0B0300             0215*          pop hl
0B0300             0216*          call printDec
0B0300             0217*          pop hl
0B0300             0218*      ENDMACRO
0B0300             0219*  
0B0300             0220*      MACRO printDecIY
0B0300             0221*          push hl
0B0300             0222*          push iy
0B0300             0223*          pop hl
0B0300             0224*          call printDec
0B0300             0225*          pop hl
0B0300             0226*      ENDMACRO
0B0300             0227*  
0B0300             0228*  
0B0300             0229*  ; Prints the right justified decimal value in HL without leading zeroes
0B0300             0230*  ; HL : Value to print
0B0300             0231*  ; preserves all registers and flags
0B0300             0232*  printDec:
0B0300             0233*  ; BEGIN MY CODE
0B0300             0234*  ; back up all the things
0B0300 F5          0235*      push af
0B0301 C5          0236*      push bc
0B0302 D5          0237*      push de
0B0303 E5          0238*      push hl
0B0304             0239*  ; END MY CODE
0B0304 11 2C 03 0B 0240*  	LD	 DE, _printDecBuffer
0B0308 CD 3C 03 0B 0241*  	CALL u24_to_ascii
0B030C             0242*  ; BEGIN MY CODE
0B030C             0243*  ; replace leading zeroes with spaces
0B030C 21 2C 03 0B 0244*      LD	 HL, _printDecBuffer
0B0310 06 07       0245*      ld   B, 7 ; if HL was 0, we want to keep the final zero
0B0312             0246*  @loop:
0B0312 7E          0247*      LD	 A, (HL)
0B0313 FE 30       0248*      CP	 '0'
0B0315 C2 23 03 0B 0249*      JP	 NZ, @done
0B0319 3E 20       0250*      LD   A, ' '
0B031B 77          0251*      LD	 (HL), A
0B031C 23          0252*      INC	 HL
0B031D CD F3 08 0B 0253*      CALL vdu_cursor_forward
0B0321 10 EF       0254*      DJNZ @loop
0B0323             0255*  @done:
0B0323             0256*  ; END MY CODE
0B0323             0257*  	; LD	 HL, _printDecBuffer
0B0323 CD 67 02 0B 0258*  	CALL printString
0B0327             0259*  ; BEGIN MY CODE
0B0327             0260*  ; restore all the things
0B0327 E1          0261*      pop hl
0B0328 D1          0262*      pop de
0B0329 C1          0263*      pop bc
0B032A F1          0264*      pop af
0B032B             0265*  ; END MY CODE
0B032B C9          0266*  	RET
0B032C 00 00 00 00 0267*  _printDecBuffer: blkb 16,0 ; a few bytes extra just to be sure
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B033C             0268*  
0B033C             0269*  ; This routine converts the unsigned 24-bit value in HLU into it's ASCII representation,
0B033C             0270*  ; starting to memory location pointing by DE, in decimal form and with leading zeroes
0B033C             0271*  ; so it will allways be 8 characters length
0B033C             0272*  ; HL : Value to convert to string
0B033C             0273*  ; DE : pointer to buffer, at least 8 byte + 0
0B033C             0274*  u24_to_ascii:
0B033C 01 80 69 67 0275*  	LD	 BC,-10000000
0B0340 CD 73 03 0B 0276*  	CALL @one_digit
0B0344 01 C0 BD F0 0277*  	LD	 BC,-1000000
0B0348 CD 73 03 0B 0278*  	CALL @one_digit
0B034C 01 60 79 FE 0279*  	LD	 BC,-100000
0B0350 CD 73 03 0B 0280*  	CALL @one_digit
0B0354 01 F0 D8 FF 0281*  	LD   BC,-10000
0B0358 CD 73 03 0B 0282*  	CALL @one_digit
0B035C 01 18 FC FF 0283*  	LD   BC,-1000
0B0360 CD 73 03 0B 0284*  	CALL @one_digit
0B0364 01 9C FF FF 0285*  	LD   BC,-100
0B0368 CD 73 03 0B 0286*  	CALL @one_digit
0B036C 0E F6       0287*  	LD   C,-10
0B036E CD 73 03 0B 0288*  	CALL @one_digit
0B0372 48          0289*  	LD   C,B
0B0373             0290*  @one_digit:
0B0373 3E 2F       0291*  	LD   A,'0'-1
0B0375             0292*  @divide_me:
0B0375 3C          0293*  	INC  A
0B0376 09          0294*  	ADD  HL,BC
0B0377 38 FC       0295*  	JR   C,@divide_me
0B0379 ED 42       0296*  	SBC  HL,BC
0B037B 12          0297*  	LD   (DE),A
0B037C 13          0298*  	INC  DE
0B037D C9          0299*  	RET
0B037E             0300*  
0B037E             0301*  print_u24:
0B037E 11 2C 03 0B 0302*      ld de,_printDecBuffer
0B0382 CD 3C 03 0B 0303*      call u24_to_ascii
0B0386 21 2C 03 0B 0304*      ld hl,_printDecBuffer
0B038A CD 67 02 0B 0305*      call printString
0B038E C9          0306*      ret
0B038F             0307*  
0B038F             0308*  ; u168_to_ascii: Converts an unsigned 16.8 fixed-point value in HL to an ASCII string.
0B038F             0309*  ; HL : Value to convert to string (integer part in H, fractional part in L)
0B038F             0310*  ; DE : Pointer to buffer, requires at least 11 bytes (8 digits, sign, decimal point, and null terminator)
0B038F             0311*  u168_to_ascii:
0B038F             0312*  ; add a leading space to make room for sign flag if needed
0B038F 3E 20       0313*      ld a,' '
0B0391 12          0314*      ld (de),a
0B0392 13          0315*      inc de
0B0393             0316*  ; Convert integer part
0B0393 E5          0317*      push hl               ; Save HL (well need the fractional part later)
0B0394 CD A9 0E 0B 0318*      call shift_hlu_r1b    ; Shift to get integer portion in HL
0B0398 01 F0 D8 FF 0319*      ld   bc, -10000
0B039C CD BF 03 0B 0320*      call @one_int
0B03A0 01 18 FC FF 0321*      ld   bc, -1000
0B03A4 CD BF 03 0B 0322*      call @one_int
0B03A8 01 9C FF FF 0323*      ld   bc, -100
0B03AC CD BF 03 0B 0324*      call @one_int
0B03B0 0E F6       0325*      ld   c, -10
0B03B2 CD BF 03 0B 0326*      call @one_int
0B03B6 48          0327*      ld   c, b
0B03B7 CD BF 03 0B 0328*      call @one_int
0B03BB C3 CA 03 0B 0329*      jp   @frac            ; Jump to fractional part conversion
0B03BF             0330*  @one_int:
0B03BF 3E 2F       0331*      ld   a, '0' - 1       ; Start ASCII character at '0'
0B03C1             0332*  @divide_me:
0B03C1 3C          0333*      inc  a
0B03C2 09          0334*      add  hl, bc           ; Accumulate until overflow
0B03C3 38 FC       0335*      jr   c, @divide_me
0B03C5 ED 42       0336*      sbc  hl, bc           ; Remove excess after overflow
0B03C7 12          0337*      ld   (de), a          ; Store ASCII digit
0B03C8 13          0338*      inc  de
0B03C9 C9          0339*      ret
0B03CA             0340*  ; Convert fractional part
0B03CA             0341*  @frac:
0B03CA 3E 2E       0342*      ld   a, '.'           ; Decimal point
0B03CC 12          0343*      ld   (de), a
0B03CD 13          0344*      inc  de
0B03CE E1          0345*      pop  hl               ; Restore HL with original fraction
0B03CF 06 03       0346*      ld   b, 3             ; Loop counter for 3 fractional digits
0B03D1             0347*  @frac_loop:
0B03D1 26 0A       0348*      ld   h, 10            ; Load multiplier for fractional part
0B03D3 ED 6C       0349*      mlt  hl               ; Multiply by 10, result in HL (H holds the integer part)
0B03D5 3E 30       0350*      ld   a, '0'
0B03D7 84          0351*      add  a, h             ; Convert integer part to ASCII
0B03D8 12          0352*      ld   (de), a
0B03D9 13          0353*      inc  de
0B03DA 10 F5       0354*      djnz @frac_loop       ; Repeat for each fractional digit
0B03DC             0355*  ; Add null terminator
0B03DC AF          0356*      xor  a                ; Null terminator
0B03DD 12          0357*      ld   (de), a
0B03DE C9          0358*      ret
0B03DF             0359*  
0B03DF             0360*  print_u168:
0B03DF 11 2C 03 0B 0361*      ld de,_printDecBuffer
0B03E3 CD 8F 03 0B 0362*      call u168_to_ascii
0B03E7 21 2C 03 0B 0363*      ld hl,_printDecBuffer
0B03EB CD 67 02 0B 0364*      call printString
0B03EF C9          0365*      ret
0B03F0             0366*  
0B03F0             0367*  ; signed version of u168_to_ascii
0B03F0             0368*  s168_to_ascii:
0B03F0 D5          0369*      push de ; save starting address of buffer
0B03F1 CD E0 18 0B 0370*      call abs_hlu
0B03F5 F5          0371*      push af ; save sign flag
0B03F6 CD 8F 03 0B 0372*      call u168_to_ascii
0B03FA F1          0373*      pop af ; restore sign flag
0B03FB D1          0374*      pop de ; restore starting address of buffer
0B03FC F0          0375*      ret p ; hlu was positive so nothing to do
0B03FD 3E 2D       0376*      ld a,'-'
0B03FF 12          0377*      ld (de),a
0B0400 C9          0378*      ret
0B0401             0379*  
0B0401             0380*  print_s168:
0B0401 11 2C 03 0B 0381*      ld de,_printDecBuffer
0B0405 CD F0 03 0B 0382*      call s168_to_ascii
0B0409 21 2C 03 0B 0383*      ld hl,_printDecBuffer
0B040D CD 67 02 0B 0384*      call printString
0B0411 C9          0385*      ret
0B0412             0386*  
0B0412             0387*  ; #### new functions added by Brandon R. Gates ####
0B0412             0388*  
0B0412             0389*  ; print the binary representation of the 8-bit value in a
0B0412             0390*  ; destroys a, hl, bc
0B0412             0391*  printBin8:
0B0412 06 08       0392*      ld b,8      ; loop counter for 8 bits
0B0414 21 2F 04 0B 0393*      ld hl,@cmd  ; set hl to the low byte of the output string
0B0418             0394*                  ; (which will be the high bit of the value in a)
0B0418             0395*  @loop:
0B0418 07          0396*      rlca ; put the next highest bit into carry
0B0419 38 04       0397*      jr c,@one
0B041B 36 30       0398*      ld (hl),'0'
0B041D 18 02       0399*      jr @next_bit
0B041F             0400*  @one:
0B041F 36 31       0401*      ld (hl),'1'
0B0421             0402*  @next_bit:
0B0421 23          0403*      inc hl
0B0422 10 F4       0404*      djnz @loop
0B0424             0405*  ; print it
0B0424 21 2F 04 0B 0406*  	ld hl,@cmd
0B0428 01 08 00 00 0407*  	ld bc,@end-@cmd
0B042C 5B DF       0408*  	rst.lil $18
0B042E C9          0409*  	ret
0B042F             0410*  @cmd: ds 8 ; eight bytes for eight bits
0B0437             0411*  @end:
0B0437             0412*  
0B0437             0413*  ; print the binary representation of the 8-bit value in a
0B0437             0414*  ; in reverse order (lsb first)
0B0437             0415*  ; destroys a, hl, bc
0B0437             0416*  printBin8Rev:
0B0437 06 08       0417*      ld b,8      ; loop counter for 8 bits
0B0439 21 54 04 0B 0418*      ld hl,@cmd  ; set hl to the low byte of the output string
0B043D             0419*                  ; (which will be the high bit of the value in a)
0B043D             0420*  @loop:
0B043D 0F          0421*      rrca ; put the next lowest bit into carry
0B043E 38 04       0422*      jr c,@one
0B0440 36 30       0423*      ld (hl),'0'
0B0442 18 02       0424*      jr @next_bit
0B0444             0425*  @one:
0B0444 36 31       0426*      ld (hl),'1'
0B0446             0427*  @next_bit:
0B0446 23          0428*      inc hl
0B0447 10 F4       0429*      djnz @loop
0B0449             0430*  ; print it
0B0449 21 54 04 0B 0431*  	ld hl,@cmd
0B044D 01 08 00 00 0432*  	ld bc,@end-@cmd
0B0451 5B DF       0433*  	rst.lil $18
0B0453 C9          0434*  	ret
0B0454             0435*  @cmd: ds 8 ; eight bytes for eight bits
0B045C             0436*  @end:
0B045C             0437*  
0B045C             0438*  ; print registers to screen in hexidecimal format
0B045C             0439*  ; inputs: none
0B045C             0440*  ; outputs: values of every register printed to screen
0B045C             0441*  ;    values of each register in global scratch memory
0B045C             0442*  ; destroys: nothing
0B045C             0443*  stepRegistersHex:
0B045C             0444*  ; store everything in scratch
0B045C 22 49 06 0B 0445*      ld (uhl),hl
0B0460 ED 43 4C 06 0446*      ld (ubc),bc
       0B          
0B0465 ED 53 4F 06 0447*      ld (ude),de
       0B          
0B046A DD 22 52 06 0448*      ld (uix),ix
       0B          
0B046F FD 22 55 06 0449*      ld (uiy),iy
       0B          
0B0474 F5          0450*      push af ; fml
0B0475 E1          0451*      pop hl  ; thanks, zilog
0B0476 22 46 06 0B 0452*      ld (uaf),hl
0B047A F5          0453*      push af ; dammit
0B047B             0454*  
0B047B             0455*  ; home the cursor
0B047B CD D2 08 0B 0456*      call vdu_home_cursor
0B047F             0457*  
0B047F             0458*  ; print each register
0B047F 21 CC 05 0B 0459*      ld hl,str_afu
0B0483 CD 67 02 0B 0460*      call printString
0B0487 2A 46 06 0B 0461*      ld hl,(uaf)
0B048B CD 87 02 0B 0462*      call printHex24
0B048F CD 7C 02 0B 0463*      call printNewLine
0B0493             0464*  
0B0493 21 D1 05 0B 0465*      ld hl,str_hlu
0B0497 CD 67 02 0B 0466*      call printString
0B049B 2A 49 06 0B 0467*      ld hl,(uhl)
0B049F CD 87 02 0B 0468*      call printHex24
0B04A3 CD 7C 02 0B 0469*      call printNewLine
0B04A7             0470*  
0B04A7 21 D6 05 0B 0471*      ld hl,str_bcu
0B04AB CD 67 02 0B 0472*      call printString
0B04AF 2A 4C 06 0B 0473*      ld hl,(ubc)
0B04B3 CD 87 02 0B 0474*      call printHex24
0B04B7 CD 7C 02 0B 0475*      call printNewLine
0B04BB             0476*  
0B04BB 21 DB 05 0B 0477*      ld hl,str_deu
0B04BF CD 67 02 0B 0478*      call printString
0B04C3 2A 4F 06 0B 0479*      ld hl,(ude)
0B04C7 CD 87 02 0B 0480*      call printHex24
0B04CB CD 7C 02 0B 0481*      call printNewLine
0B04CF             0482*  
0B04CF 21 E0 05 0B 0483*      ld hl,str_ixu
0B04D3 CD 67 02 0B 0484*      call printString
0B04D7 2A 52 06 0B 0485*      ld hl,(uix)
0B04DB CD 87 02 0B 0486*      call printHex24
0B04DF CD 7C 02 0B 0487*      call printNewLine
0B04E3             0488*  
0B04E3 21 E5 05 0B 0489*      ld hl,str_iyu
0B04E7 CD 67 02 0B 0490*      call printString
0B04EB 2A 55 06 0B 0491*      ld hl,(uiy)
0B04EF CD 87 02 0B 0492*      call printHex24
0B04F3 CD 7C 02 0B 0493*      call printNewLine
0B04F7             0494*  
0B04F7             0495*      ; call vsync
0B04F7             0496*  
0B04F7 CD 7C 02 0B 0497*      call printNewLine
0B04FB             0498*  
0B04FB             0499*  ; check for right shift key and quit if pressed
0B04FB             0500*  	MOSCALL mos_getkbmap
0B04FB 3E 1E       0001*M 			LD	A, function
0B04FD 5B CF       0002*M 			RST.L	08h
0B04FF             0501*  @stayhere:
0B04FF             0502*  ; 7 RightShift
0B04FF DD CB 00 76 0503*      bit 6,(ix+0)
0B0503 20 02       0504*      jr nz,@RightShift
0B0505 18 F8       0505*      jr @stayhere
0B0507             0506*  @RightShift:
0B0507 DD CB 0E 86 0507*      res 0,(ix+14) ; debounce the key (hopefully)
0B050B 3E 80       0508*      ld a,%10000000
0B050D CD B2 08 0B 0509*      call multiPurposeDelay
0B0511             0510*  
0B0511             0511*  ; restore everything
0B0511 2A 49 06 0B 0512*      ld hl, (uhl)
0B0515 ED 4B 4C 06 0513*      ld bc, (ubc)
       0B          
0B051A ED 5B 4F 06 0514*      ld de, (ude)
       0B          
0B051F DD 2A 52 06 0515*      ld ix, (uix)
       0B          
0B0524 FD 2A 55 06 0516*      ld iy, (uiy)
       0B          
0B0529 F1          0517*      pop af
0B052A             0518*  ; all done
0B052A C9          0519*      ret
0B052B             0520*  
0B052B             0521*  ; print registers to screen in hexidecimal format
0B052B             0522*  ; inputs: none
0B052B             0523*  ; outputs: values of every register printed to screen
0B052B             0524*  ;    values of each register in global scratch memory
0B052B             0525*  ; destroys: nothing
0B052B             0526*  dumpRegistersHex:
0B052B             0527*  ; store everything in scratch
0B052B 22 49 06 0B 0528*      ld (uhl),hl
0B052F ED 43 4C 06 0529*      ld (ubc),bc
       0B          
0B0534 ED 53 4F 06 0530*      ld (ude),de
       0B          
0B0539 DD 22 52 06 0531*      ld (uix),ix
       0B          
0B053E FD 22 55 06 0532*      ld (uiy),iy
       0B          
0B0543 F5          0533*      push af ; fml
0B0544 E1          0534*      pop hl  ; thanks, zilog
0B0545 22 46 06 0B 0535*      ld (uaf),hl
0B0549 F5          0536*      push af ; dammit
0B054A             0537*  
0B054A             0538*  ; home the cursor
0B054A             0539*      ; call vdu_home_cursor
0B054A             0540*      ; call printNewLine
0B054A             0541*  
0B054A             0542*  ; print each register
0B054A 21 CC 05 0B 0543*      ld hl,str_afu
0B054E CD 67 02 0B 0544*      call printString
0B0552 2A 46 06 0B 0545*      ld hl,(uaf)
0B0556 CD 87 02 0B 0546*      call printHex24
0B055A             0547*      ; call printNewLine
0B055A             0548*  
0B055A 21 D1 05 0B 0549*      ld hl,str_hlu
0B055E CD 67 02 0B 0550*      call printString
0B0562 2A 49 06 0B 0551*      ld hl,(uhl)
0B0566 CD 87 02 0B 0552*      call printHex24
0B056A             0553*      ; call printNewLine
0B056A             0554*  
0B056A 21 D6 05 0B 0555*      ld hl,str_bcu
0B056E CD 67 02 0B 0556*      call printString
0B0572 2A 4C 06 0B 0557*      ld hl,(ubc)
0B0576 CD 87 02 0B 0558*      call printHex24
0B057A             0559*      ; call printNewLine
0B057A             0560*  
0B057A 21 DB 05 0B 0561*      ld hl,str_deu
0B057E CD 67 02 0B 0562*      call printString
0B0582 2A 4F 06 0B 0563*      ld hl,(ude)
0B0586 CD 87 02 0B 0564*      call printHex24
0B058A             0565*      ; call printNewLine
0B058A             0566*  
0B058A 21 E0 05 0B 0567*      ld hl,str_ixu
0B058E CD 67 02 0B 0568*      call printString
0B0592 2A 52 06 0B 0569*      ld hl,(uix)
0B0596 CD 87 02 0B 0570*      call printHex24
0B059A             0571*      ; call printNewLine
0B059A             0572*  
0B059A 21 E5 05 0B 0573*      ld hl,str_iyu
0B059E CD 67 02 0B 0574*      call printString
0B05A2 2A 55 06 0B 0575*      ld hl,(uiy)
0B05A6 CD 87 02 0B 0576*      call printHex24
0B05AA             0577*      ; call printNewLine
0B05AA             0578*  
0B05AA CD 67 09 0B 0579*      call vdu_vblank
0B05AE             0580*  
0B05AE CD 7C 02 0B 0581*      call printNewLine
0B05B2             0582*  ; restore everything
0B05B2 2A 49 06 0B 0583*      ld hl, (uhl)
0B05B6 ED 4B 4C 06 0584*      ld bc, (ubc)
       0B          
0B05BB ED 5B 4F 06 0585*      ld de, (ude)
       0B          
0B05C0 DD 2A 52 06 0586*      ld ix, (uix)
       0B          
0B05C5 FD 2A 55 06 0587*      ld iy, (uiy)
       0B          
0B05CA F1          0588*      pop af
0B05CB             0589*  ; all done
0B05CB C9          0590*      ret
0B05CC             0591*  
0B05CC 20 61 66 3D 0592*  str_afu: db " af=",0
       00          
0B05D1 20 68 6C 3D 0593*  str_hlu: db " hl=",0
       00          
0B05D6 20 62 63 3D 0594*  str_bcu: db " bc=",0
       00          
0B05DB 20 64 65 3D 0595*  str_deu: db " de=",0
       00          
0B05E0 20 69 78 3D 0596*  str_ixu: db " ix=",0
       00          
0B05E5 20 69 79 3D 0597*  str_iyu: db " iy=",0
       00          
0B05EA             0598*  
0B05EA             0599*  ; print udeuhl to screen in hexidecimal format
0B05EA             0600*  ; inputs: none
0B05EA             0601*  ; outputs: concatenated hexidecimal udeuhl
0B05EA             0602*  ; destroys: nothing
0B05EA             0603*  dumpUDEUHLHex:
0B05EA             0604*  ; store everything in scratch
0B05EA 22 49 06 0B 0605*      ld (uhl),hl
0B05EE ED 43 4C 06 0606*      ld (ubc),bc
       0B          
0B05F3 ED 53 4F 06 0607*      ld (ude),de
       0B          
0B05F8 DD 22 52 06 0608*      ld (uix),ix
       0B          
0B05FD FD 22 55 06 0609*      ld (uiy),iy
       0B          
0B0602 F5          0610*      push af
0B0603             0611*  
0B0603             0612*  ; print each register
0B0603             0613*  
0B0603 21 3D 06 0B 0614*      ld hl,str_udeuhl
0B0607 CD 67 02 0B 0615*      call printString
0B060B 2A 4F 06 0B 0616*      ld hl,(ude)
0B060F CD 87 02 0B 0617*      call printHex24
0B0613 3E 2E       0618*  	ld a,'.'	; print a dot to separate the values
0B0615 5B D7       0619*  	rst.lil 10h
0B0617 2A 49 06 0B 0620*      ld hl,(uhl)
0B061B CD 87 02 0B 0621*      call printHex24
0B061F CD 7C 02 0B 0622*      call printNewLine
0B0623             0623*  
0B0623             0624*  ; restore everything
0B0623 2A 49 06 0B 0625*      ld hl, (uhl)
0B0627 ED 4B 4C 06 0626*      ld bc, (ubc)
       0B          
0B062C ED 5B 4F 06 0627*      ld de, (ude)
       0B          
0B0631 DD 2A 52 06 0628*      ld ix, (uix)
       0B          
0B0636 FD 2A 55 06 0629*      ld iy, (uiy)
       0B          
0B063B F1          0630*      pop af
0B063C             0631*  ; all done
0B063C C9          0632*      ret
0B063D             0633*  
0B063D 75 64 65 2E 0634*  str_udeuhl: db "ude.uhl=",0
       75 68 6C 3D 
       00          
0B0646             0635*  
0B0646             0636*  ; global scratch memory for registers
0B0646 00 00 00    0637*  uaf: dl 0
0B0649 00 00 00    0638*  uhl: dl 0
0B064C 00 00 00    0639*  ubc: dl 0
0B064F 00 00 00    0640*  ude: dl 0
0B0652 00 00 00    0641*  uix: dl 0
0B0655 00 00 00    0642*  uiy: dl 0
0B0658 00 00 00    0643*  usp: dl 0
0B065B 00 00 00    0644*  upc: dl 0
0B065E             0645*  
0B065E             0646*  ; inputs: whatever is in the flags register
0B065E             0647*  ; outputs: binary representation of flags
0B065E             0648*  ;          with a header so we know which is what
0B065E             0649*  ; destroys: nothing
0B065E             0650*  ; preserves: everything
0B065E             0651*  dumpFlags:
0B065E             0652*  ; first we curse zilog for not giving direct access to flags
0B065E F5          0653*      push af ; this is so we can send it back unharmed
0B065F F5          0654*      push af ; this is so we can pop it to hl
0B0660             0655*  ; store everything in scratch
0B0660 22 49 06 0B 0656*      ld (uhl),hl
0B0664 ED 43 4C 06 0657*      ld (ubc),bc
       0B          
0B0669 ED 53 4F 06 0658*      ld (ude),de
       0B          
0B066E DD 22 52 06 0659*      ld (uix),ix
       0B          
0B0673 FD 22 55 06 0660*      ld (uiy),iy
       0B          
0B0678             0661*  ; next we print the header
0B0678 21 A4 06 0B 0662*      ld hl,@header
0B067C CD 67 02 0B 0663*      call printString
0B0680 E1          0664*      pop hl ; flags are now in l
0B0681 7D          0665*      ld a,l ; flags are now in a
0B0682 CD 12 04 0B 0666*      call printBin8
0B0686 CD 7C 02 0B 0667*  	call printNewLine
0B068A             0668*  ; restore everything
0B068A 2A 49 06 0B 0669*      ld hl, (uhl)
0B068E ED 4B 4C 06 0670*      ld bc, (ubc)
       0B          
0B0693 ED 5B 4F 06 0671*      ld de, (ude)
       0B          
0B0698 DD 2A 52 06 0672*      ld ix, (uix)
       0B          
0B069D FD 2A 55 06 0673*      ld iy, (uiy)
       0B          
0B06A2 F1          0674*      pop af ; send her home the way she came
0B06A3 C9          0675*      ret
0B06A4             0676*  ; Bit 7 (S): Sign flag
0B06A4             0677*  ; Bit 6 (Z): Zero flag
0B06A4             0678*  ; Bit 5 (5): Reserved (copy of bit 5 of the result)
0B06A4             0679*  ; Bit 4 (H): Half Carry flag
0B06A4             0680*  ; Bit 3 (3): Reserved (copy of bit 3 of the result)
0B06A4             0681*  ; Bit 2 (PV): Parity/Overflow flag
0B06A4             0682*  ; Bit 1 (N): Subtract flag
0B06A4             0683*  ; Bit 0 (C): Carry flag
0B06A4 53 5A 78 48 0684*  @header: db "SZxHxPNC\r\n",0 ; cr/lf and 0 terminator
       78 50 4E 43 
       0D 0A 00    
0B06AF             0685*  
0B06AF             0686*  ; set all the bits in the flag register
0B06AF             0687*  ; more of an academic exercise than anything useful
0B06AF             0688*  ; inputs; none
0B06AF             0689*  ; outputs; a=0,f=255
0B06AF             0690*  ; destroys: flags, hl
0B06AF             0691*  ; preserves: a, because why not
0B06AF             0692*  setAllFlags:
0B06AF 21 FF 00 00 0693*      ld hl,255
0B06B3 67          0694*      ld h,a ; four cycles to preserve a is cheap
0B06B4 E5          0695*      push hl
0B06B5 F1          0696*      pop af
0B06B6 C9          0697*      ret
0B06B7             0698*  
0B06B7             0699*  ; reset all the bits in the flag register
0B06B7             0700*  ; unlike its inverse counterpart, this may actually be useful
0B06B7             0701*  ; inputs; none
0B06B7             0702*  ; outputs; a=0,f=0
0B06B7             0703*  ; destroys: flags, hl
0B06B7             0704*  ; preserves: a, because why not
0B06B7             0705*  resetAllFlags:
0B06B7 21 00 00 00 0706*      ld hl,0
0B06BB 67          0707*      ld h,a ; four cycles to preserve a is cheap
0B06BC E5          0708*      push hl
0B06BD F1          0709*      pop af
0B06BE C9          0710*      ret
0B06BF             0711*  
0B06BF             0712*  ; wait until user presses a key
0B06BF             0713*  ; inputs: none
0B06BF             0714*  ; outputs: none
0B06BF             0715*  ; destroys: af,ix
0B06BF             0716*  waitKeypress:
0B06BF             0717*      MOSCALL mos_sysvars
0B06BF 3E 08       0001*M 			LD	A, function
0B06C1 5B CF       0002*M 			RST.L	08h
0B06C3 AF          0718*      xor a ; zero out any prior keypresses
0B06C4 DD 77 05    0719*      ld (ix+sysvar_keyascii),a
0B06C7             0720*  @loop:
0B06C7 DD 7E 05    0721*      ld a,(ix+sysvar_keyascii)
0B06CA A7          0722*      and a
0B06CB C0          0723*      ret nz
0B06CC 18 F9       0724*      jr @loop
0B06CE             0725*  
0B06CE             0726*  
0B06CE             0727*  ; print bytes from an address to the screen in hexidecimal format
0B06CE             0728*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06CE             0729*  ; outputs: values of each byte printed to screen separated by spaces
0B06CE             0730*  ; destroys: nothing
0B06CE             0731*  dumpMemoryHex:
0B06CE             0732*  ; save registers to the stack
0B06CE C5          0733*      push bc
0B06CF E5          0734*      push hl
0B06D0 F5          0735*      push af
0B06D1             0736*  
0B06D1             0737*  ; print the address and separator
0B06D1 CD 87 02 0B 0738*      call printHex24
0B06D5 3E 3A       0739*      ld a,':'
0B06D7 5B D7       0740*      rst.lil 10h
0B06D9 3E 20       0741*      ld a,' '
0B06DB 5B D7       0742*      rst.lil 10h
0B06DD             0743*  
0B06DD             0744*  ; set b to be our loop counter
0B06DD F1          0745*      pop af
0B06DE 47          0746*      ld b,a
0B06DF E1          0747*      pop hl
0B06E0 E5          0748*      push hl
0B06E1 F5          0749*      push af
0B06E2             0750*  @loop:
0B06E2             0751*  ; print the byte
0B06E2 7E          0752*      ld a,(hl)
0B06E3 CD 99 02 0B 0753*      call printHex8
0B06E7             0754*  ; print a space
0B06E7 3E 20       0755*      ld a,' '
0B06E9 5B D7       0756*      rst.lil 10h
0B06EB 23          0757*      inc hl
0B06EC 10 F4       0758*      djnz @loop
0B06EE             0759*      ; call printNewLine
0B06EE             0760*  
0B06EE             0761*  ; restore everything
0B06EE F1          0762*      pop af
0B06EF E1          0763*      pop hl
0B06F0 C1          0764*      pop bc
0B06F1             0765*  
0B06F1             0766*  ; all done
0B06F1 C9          0767*      ret
0B06F2             0768*  
0B06F2             0769*  
0B06F2             0770*  ; print bytes from an address to the screen in binary format
0B06F2             0771*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B06F2             0772*  ; outputs: values of each byte printed to screen separated by spaces
0B06F2             0773*  ; destroys: nothing
0B06F2             0774*  dumpMemoryBin:
0B06F2             0775*  ; save all registers to the stack
0B06F2 F5          0776*      push af
0B06F3 C5          0777*      push bc
0B06F4 D5          0778*      push de
0B06F5 E5          0779*      push hl
0B06F6 DD E5       0780*      push ix
0B06F8 FD E5       0781*      push iy
0B06FA             0782*  
0B06FA             0783*  ; set b to be our loop counter
0B06FA 47          0784*      ld b,a
0B06FB             0785*  @loop:
0B06FB             0786*  ; print the byte
0B06FB 7E          0787*      ld a,(hl)
0B06FC E5          0788*      push hl
0B06FD C5          0789*      push bc
0B06FE CD 12 04 0B 0790*      call printBin8
0B0702 C1          0791*      pop bc
0B0703             0792*  ; print a space
0B0703 3E 20       0793*      ld a,' '
0B0705 5B D7       0794*      rst.lil 10h
0B0707 E1          0795*      pop hl
0B0708 23          0796*      inc hl
0B0709 10 F0       0797*      djnz @loop
0B070B CD 7C 02 0B 0798*      call printNewLine
0B070F             0799*  
0B070F             0800*  ; restore everything
0B070F FD E1       0801*      pop iy
0B0711 DD E1       0802*      pop ix
0B0713 E1          0803*      pop hl
0B0714 D1          0804*      pop de
0B0715 C1          0805*      pop bc
0B0716 F1          0806*      pop af
0B0717             0807*  ; all done
0B0717 C9          0808*      ret
0B0718             0809*  
0B0718             0810*  ; print bytes from an address to the screen in binary format
0B0718             0811*  ; with the bits of each byte in reverse order (lsb first)
0B0718             0812*  ; inputs: hl = address of first byte to print, a = number of bytes to print
0B0718             0813*  ; outputs: values of each byte printed to screen separated by spaces
0B0718             0814*  ; destroys: nothing
0B0718             0815*  dumpMemoryBinRev:
0B0718             0816*  ; save all registers to the stack
0B0718 F5          0817*      push af
0B0719 C5          0818*      push bc
0B071A D5          0819*      push de
0B071B E5          0820*      push hl
0B071C DD E5       0821*      push ix
0B071E FD E5       0822*      push iy
0B0720             0823*  
0B0720             0824*  ; set b to be our loop counter
0B0720 47          0825*      ld b,a
0B0721             0826*  @loop:
0B0721             0827*  ; print the byte
0B0721 7E          0828*      ld a,(hl)
0B0722 E5          0829*      push hl
0B0723 C5          0830*      push bc
0B0724 CD 37 04 0B 0831*      call printBin8Rev
0B0728 C1          0832*      pop bc
0B0729             0833*  ; print a space
0B0729 3E 20       0834*      ld a,' '
0B072B 5B D7       0835*      rst.lil 10h
0B072D E1          0836*      pop hl
0B072E 23          0837*      inc hl
0B072F 10 F0       0838*      djnz @loop
0B0731 CD 7C 02 0B 0839*      call printNewLine
0B0735             0840*  
0B0735             0841*  ; restore everything
0B0735 FD E1       0842*      pop iy
0B0737 DD E1       0843*      pop ix
0B0739 E1          0844*      pop hl
0B073A D1          0845*      pop de
0B073B C1          0846*      pop bc
0B073C F1          0847*      pop af
0B073D             0848*  ; all done
0B073D C9          0849*      ret
0B073E             0020       include "files.inc"
0B073E             0001*  ; load to onboard 8k sram
0B073E             0002*  filedata: equ 0xB7E000; Directory object structure (DIR)
0B073E             0021       include "timer.inc"
0B073E             0001*  ; Table 32. Timer Control Registers
0B073E             0002*  ; this constant is the base address of the timer control registers
0B073E             0003*  ; each timer takes three bytes:
0B073E             0004*  ;   0: control register
0B073E             0005*  ;   1: low byte of timer reset value
0B073E             0006*  ;   2: high byte of timer reset value
0B073E             0007*  ; note that the value is only 8-bits,so we use in0/out0 i/o calls,
0B073E             0008*  ; which correctly force the high and upper bytes of the address bus to zero
0B073E             0009*  TMR_CTL:     equ 80h
0B073E             0010*  
0B073E             0011*  ; Timer Control Register Bit Definitions
0B073E             0012*  PRT_IRQ_0:    equ %00000000 ; The timer does not reach its end-of-count value.
0B073E             0013*                              ; This bit is reset to 0 every time the TMRx_CTL register is read.
0B073E             0014*  PRT_IRQ_1:    equ %10000000 ; The timer reaches its end-of-count value. If IRQ_EN is set to 1,
0B073E             0015*                              ; an interrupt signal is sent to the CPU. This bit remains 1 until
0B073E             0016*                              ; the TMRx_CTL register is read.
0B073E             0017*  
0B073E             0018*  IRQ_EN_0:     equ %00000000 ; Timer interrupt requests are disabled.
0B073E             0019*  IRQ_EN_1:     equ %01000000 ; Timer interrupt requests are enabled.
0B073E             0020*  
0B073E             0021*  PRT_MODE_0:   equ %00000000 ; The timer operates in SINGLE PASS mode. PRT_EN (bit 0) is reset to
0B073E             0022*                              ;  0,and counting stops when the end-of-count value is reached.
0B073E             0023*  PRT_MODE_1:   equ %00010000 ; The timer operates in CONTINUOUS mode. The timer reload value is
0B073E             0024*                              ; written to the counter when the end-of-count value is reached.
0B073E             0025*  
0B073E             0026*  ; CLK_DIV is a 2-bit mask that sets the timer input source clock divider
0B073E             0027*  CLK_DIV_256:  equ %00001100 ;
0B073E             0028*  CLK_DIV_64:   equ %00001000 ;
0B073E             0029*  CLK_DIV_16:   equ %00000100 ;
0B073E             0030*  CLK_DIV_4:    equ %00000000 ;
0B073E             0031*  
0B073E             0032*  RST_EN_0:     equ %00000000 ; The reload and restart function is disabled.
0B073E             0033*  RST_EN_1:     equ %00000010 ; The reload and restart function is enabled.
0B073E             0034*                              ; When a 1 is written to this bit,the values in the reload registers
0B073E             0035*                              ;  are loaded into the downcounter when the timer restarts. The
0B073E             0036*                              ; programmer must ensure that this bit is set to 1 each time
0B073E             0037*                              ; SINGLE-PASS mode is used.
0B073E             0038*  
0B073E             0039*  ; disable/enable the programmable reload timer
0B073E             0040*  PRT_EN_0:     equ %00000000 ;
0B073E             0041*  PRT_EN_1:     equ %00000001 ;
0B073E             0042*  
0B073E             0043*  ; Table 37. Timer Input Source Select Register
0B073E             0044*  ; Each of the 4 timers are allocated two bits of the 8-bit register
0B073E             0045*  ; in little-endian order,with TMR0 using bits 0 and 1,TMR1 using bits 2 and 3,etc.
0B073E             0046*  ;   00: System clock / CLK_DIV
0B073E             0047*  ;   01: RTC / CLK_DIV
0B073E             0048*  ;   NOTE: these are the values given in the manual,but it may be a typo
0B073E             0049*  ;   10: GPIO port B pin 1.
0B073E             0050*  ;   11: GPIO port B pin 1.
0B073E             0051*  TMR_ISS:   equ 92h ; register address
0B073E             0052*  
0B073E             0053*  ; Table 51. Real-Time Clock Control Register
0B073E             0054*  RTC_CTRL: equ EDh ; register address
0B073E             0055*  
0B073E             0056*  ; alarm interrupt disable/enable
0B073E             0057*  RTC_ALARM_0:    equ %00000000
0B073E             0058*  RTC_ALARM_1:    equ %10000000
0B073E             0059*  
0B073E             0060*  ; interrupt on alarm disable/enable
0B073E             0061*  RTC_INT_ENT_0:  equ %00000000
0B073E             0062*  RTC_INT_ENT_1:  equ %01000000
0B073E             0063*  
0B073E             0064*  RTC_BCD_EN_0:   equ %00000000   ; RTC count and alarm registers are binary
0B073E             0065*  RTC_BCD_EN_1:   equ %00100000   ; RTC count and alarm registers are BCD
0B073E             0066*  
0B073E             0067*  RTC_CLK_SEL_0:  equ %00000000   ; RTC clock source is crystal oscillator output (32768 Hz).
0B073E             0068*                                  ; On-chip 32768 Hz oscillator is enabled.
0B073E             0069*  RTC_CLK_SEL_1:  equ %00010000   ; RTC clock source is power line frequency input as set by FREQ_SEL.
0B073E             0070*                                  ; On-chip 32768 Hz oscillator is disabled.
0B073E             0071*  
0B073E             0072*  RTC_FREQ_SEL_0: equ %00000000   ; 60 Hz power line frequency.
0B073E             0073*  RTC_FREQ_SEL_1: equ %00001000   ; 50 Hz power line frequency.
0B073E             0074*  
0B073E             0075*  RTC_SLP_WAKE_0: equ %00000000   ; RTC does not generate a sleep-mode recovery reset.
0B073E             0076*  RTC_SLP_WAKE_1: equ %00000010   ; RTC generates a sleep-mode recovery reset.
0B073E             0077*  
0B073E             0078*  RTC_UNLOCK_0:   equ %00000000   ; RTC count registers are locked to prevent Write access.
0B073E             0079*                                  ; RTC counter is enabled.
0B073E             0080*  RTC_UNLOCK_1:   equ %00000001   ; RTC count registers are unlocked to allow Write access.
0B073E             0081*                                  ; RTC counter is disabled.
0B073E             0082*  
0B073E             0083*  ; prt_reload_emulator: equ 11234 ; 1/102.4 seconds on emulator with 16 clock divider
0B073E             0084*  
0B073E             0085*  prt_reload_emulator: equ 11519 ; 1 centisecond on emulator with 16 clock divider
0B073E             0086*  prt_reload_hardware: equ 11532 ; 1 centisecond on hardware with 16 clock divider
0B073E 00 00 00    0087*  prt_reload: dl 0x000000
0B0741             0088*  
0B0741             0089*  ; ; returns: a = 0 if running on hardware,1 if running on emulator
0B0741             0090*  ; ;          de = number PRT interrupts during test interval
0B0741             0091*  ; prt_calibrate:
0B0741             0092*  ;     call vdu_vblank
0B0741             0093*  ; ; set a MOS timer
0B0741             0094*  ;     ld hl,120*1 ; 1 second
0B0741             0095*  ;     ld iy,tmr_test
0B0741             0096*  ;     call tmr_set
0B0741             0097*  ; ; set a PRT timer
0B0741             0098*  ;     ; ld hl,prt_reload_hardware
0B0741             0099*  ;     ; ld hl,prt_reload_emulator
0B0741             0100*  ;     ld hl,prt_reload_emulator + prt_reload_hardware / 2
0B0741             0101*  ;     ld (prt_reload),hl
0B0741             0102*  ;     call prt_set
0B0741             0103*  ; @loop:
0B0741             0104*  ; ; check time remaining on MOS timer
0B0741             0105*  ;     call tmr_get
0B0741             0106*  ;     jp z,@done ; time expired,so quit
0B0741             0107*  ;     jp m,@done ; time past expiration (negative),so quit
0B0741             0108*  ;     jr @loop
0B0741             0109*  ; @done:
0B0741             0110*  ;     ld de,(prt_irq_counter)
0B0741             0111*  ;     ld bc,prt_reload_hardware ; default value for running on hardware
0B0741             0112*  ;     ld (prt_reload),bc
0B0741             0113*  ;     ld hl,100 ; halfway between 101 for real hardware and 99 for emulator
0B0741             0114*  ;     xor a ; clear carry,zero is default value for running on hardware
0B0741             0115*  ;     ld (is_emulator),a
0B0741             0116*  ;     sbc hl,de
0B0741             0117*  ;     ld hl,on_hardware ; default message for running on hardware
0B0741             0118*  ;     jp z,prt_calibrate ; zero result is indeterminate so we try again
0B0741             0119*  ;     ret m ; negative result means we're on hardware
0B0741             0120*  ;     inc a ; we're on emulator
0B0741             0121*  ;     ld (is_emulator),a
0B0741             0122*  ;     ld bc,prt_reload_emulator
0B0741             0123*  ;     ld (prt_reload),bc
0B0741             0124*  ;     ld hl,on_emulator
0B0741             0125*  ;     ret
0B0741             0126*  
0B0741             0127*  ; calibrating_timer: defb "Calibrating timer\r\n",0
0B0741             0128*  
0B0741             0129*  ; set PRT timer
0B0741             0130*  prt_set:
0B0741 21 00 00 00 0131*      ld hl,0
0B0745 22 8F 07 0B 0132*      ld (prt_irq_counter),hl
0B0749 2A 3E 07 0B 0133*      ld hl,(prt_reload)
0B074D ED 29 84    0134*      out0 ($84),l
0B0750 ED 21 85    0135*  	out0 ($85),h
0B0753             0136*  ; disable timer
0B0753 3E 06       0137*      ld a,PRT_IRQ_0 | IRQ_EN_0 | PRT_MODE_0 | CLK_DIV_16 | RST_EN_1 | PRT_EN_0
0B0755 ED 39 83    0138*  	out0 ($83),a
0B0758             0139*  ; enable timer,with interrupt and CONTINUOUS mode,clock divider 16
0B0758 3E 57       0140*      ld a,PRT_IRQ_0 | IRQ_EN_1 | PRT_MODE_1 | CLK_DIV_16 | RST_EN_1 | PRT_EN_1
0B075A ED 39 83    0141*  	out0 ($83),a
0B075D C9          0142*      ret
0B075E             0143*  
0B075E             0144*  ; ===============================================
0B075E             0145*  ; PRT Timer Interrupt Handling
0B075E             0146*  ; https://github.com/tomm/agon-cpu-emulator/blob/main/sdcard/regression_suite/timerirq.inc
0B075E             0147*  ; -----------------------------------------------
0B075E             0148*  prt_irq_init:
0B075E             0149*      ; set up interrupt vector table 2
0B075E 21 00 00 00 0150*  	ld hl,0
0B0762 3A 0C 01 00 0151*  	ld a,($10c)
0B0766 6F          0152*  	ld l,a
0B0767 3A 0D 01 00 0153*  	ld a,($10d)
0B076B 67          0154*  	ld h,a
0B076C             0155*  
0B076C             0156*  	; skip over CALL ($c3)
0B076C 23          0157*  	inc hl
0B076D             0158*  	; load address of jump into vector table 2 (in ram)
0B076D ED 27       0159*  	ld hl,(hl)
0B076F             0160*  
0B076F             0161*  	; write CALL prt_irq_handler to vector table 2
0B076F 3E C3       0162*  	ld a,$c3
0B0771 77          0163*  	ld (hl),a
0B0772 23          0164*  	inc hl
0B0773 11 7A 07 0B 0165*  	ld de,prt_irq_handler
0B0777 ED 1F       0166*  	ld (hl),de
0B0779             0167*  
0B0779 C9          0168*      ret
0B077A             0169*  
0B077A             0170*  prt_irq_handler:
0B077A F3          0171*  	di
0B077B F5          0172*  	push af
0B077C E5          0173*      push hl
0B077D ED 38 83    0174*  	in0 a,($83)
0B0780 2A 8F 07 0B 0175*  	ld hl,(prt_irq_counter)
0B0784 23          0176*  	inc hl
0B0785 22 8F 07 0B 0177*  	ld (prt_irq_counter),hl
0B0789 E1          0178*      pop hl
0B078A F1          0179*  	pop af
0B078B FB          0180*  	ei
0B078C 5B ED 4D    0181*  	reti.l
0B078F             0182*  
0B078F             0183*  prt_irq_counter:
0B078F 00 00 00    0184*  	.dl 0
0B0792             0185*  prt_irq_counter_saved:
0B0792 00 00 00    0186*      .dl 0
0B0795             0187*  
0B0795             0188*  prt_loop_reset:
0B0795 E5          0189*      push hl
0B0796 21 00 00 00 0190*  	ld hl,0
0B079A 22 8F 07 0B 0191*  	ld (prt_irq_counter),hl
0B079E 22 00 08 0B 0192*      ld (prt_loop_counter),hl
0B07A2 22 03 08 0B 0193*      ld (prt_loops),hl
0B07A6 CD 41 07 0B 0194*      call prt_set
0B07AA E1          0195*      pop hl
0B07AB C9          0196*      ret
0B07AC             0197*  
0B07AC             0198*  prt_loop_start:
0B07AC E5          0199*      push hl
0B07AD 21 00 00 00 0200*  	ld hl,0
0B07B1 22 8F 07 0B 0201*  	ld (prt_irq_counter),hl
0B07B5 E1          0202*      pop hl
0B07B6 C9          0203*      ret
0B07B7             0204*  
0B07B7             0205*  prt_loop_stop:
0B07B7 E5          0206*      push hl
0B07B8 D5          0207*      push de
0B07B9 2A 8F 07 0B 0208*      ld hl,(prt_irq_counter)
0B07BD ED 5B 00 08 0209*      ld de,(prt_loop_counter)
       0B          
0B07C2 19          0210*      add hl,de
0B07C3 22 00 08 0B 0211*      ld (prt_loop_counter),hl
0B07C7 21 00 00 00 0212*      ld hl,0
0B07CB 22 8F 07 0B 0213*      ld (prt_irq_counter),hl
0B07CF 2A 03 08 0B 0214*      ld hl,(prt_loops)
0B07D3 23          0215*      inc hl
0B07D4 22 03 08 0B 0216*      ld (prt_loops),hl
0B07D8 D1          0217*      pop de
0B07D9 E1          0218*      pop hl
0B07DA C9          0219*      ret
0B07DB             0220*  
0B07DB             0221*  ; inputs: bc = y,x text coordinates to print
0B07DB             0222*  prt_loop_print:
0B07DB F5          0223*      push af
0B07DC E5          0224*      push hl
0B07DD C5          0225*      push bc
0B07DE D5          0226*      push de
0B07DF DD E5       0227*      push ix
0B07E1 FD E5       0228*      push iy
0B07E3 CD F8 08 0B 0229*      call vdu_move_cursor
0B07E7             0230*  
0B07E7 2A 00 08 0B 0231*      ld hl,(prt_loop_counter)
0B07EB CD 00 03 0B 0232*      call printDec
0B07EF             0233*  
0B07EF 2A 03 08 0B 0234*      ld hl,(prt_loops)
0B07F3 CD 00 03 0B 0235*      call printDec
0B07F7             0236*  
0B07F7 FD E1       0237*      pop iy
0B07F9 DD E1       0238*      pop ix
0B07FB D1          0239*      pop de
0B07FC C1          0240*      pop bc
0B07FD E1          0241*      pop hl
0B07FE F1          0242*      pop af
0B07FF C9          0243*      ret
0B0800             0244*  
0B0800             0245*  prt_loop_counter:
0B0800 00 00 00    0246*      .dl 0
0B0803             0247*  prt_loops:
0B0803 00 00 00    0248*      .dl 0
0B0806             0249*  
0B0806             0250*  ; ===============================================
0B0806             0251*  ; Timer functions
0B0806             0252*  ; -----------------------------------------------
0B0806             0253*  ; set a countdown timer
0B0806             0254*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0806             0255*  ; returns: hl = current time
0B0806             0256*  tmr_set:
0B0806 FD 2F 03    0257*      ld (iy+3),hl            ; set time remaining
0B0809             0258*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0809 3E 08       0001*M 			LD	A, function
0B080B 5B CF       0002*M 			RST.L	08h
0B080D DD 27 00    0259*      ld hl,(ix+sysvar_time)  ; get current time
0B0810 FD 2F 00    0260*      ld (iy+0),hl            ; set start time
0B0813 C9          0261*      ret
0B0814             0262*  
0B0814             0263*  ; gets time remaining on a countdown timer
0B0814             0264*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0814             0265*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0814             0266*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0814             0267*  tmr_get:
0B0814             0268*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0814 3E 08       0001*M 			LD	A, function
0B0816 5B CF       0002*M 			RST.L	08h
0B0818 DD 17 00    0269*      ld de,(ix+sysvar_time)  ; get current time
0B081B FD 27 00    0270*      ld hl,(iy+0)            ; get start time
0B081E AF          0271*      xor a                   ; clear carry
0B081F ED 52       0272*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0821 FD 17 03    0273*      ld de,(iy+3)            ; get timer set value
0B0824 AF          0274*      xor a                   ; clear carry
0B0825 ED 5A       0275*      adc hl,de               ; hl = time remaining
0B0827             0276*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B0827 C9          0277*      ret
0B0828             0278*  
0B0828 00 00 00    0279*  timestamp_now: dl 0
0B082B 00 00 00    0280*  timestamp_old: dl 0
0B082E 00 00 00    0281*  timestamp_chg: dl 0
0B0831             0282*  
0B0831             0283*  ; update the global timestamp from the system clock
0B0831             0284*  ; inputs: none
0B0831             0285*  ; returns: hl = time elapsed in 1/120ths of a second
0B0831             0286*  ;          de = current time
0B0831             0287*  ;          ix = pointer to syvars table
0B0831             0288*  ; destroys: af,hl,de,ix
0B0831             0289*  timestamp_tick:
0B0831 ED 5B 28 08 0290*      ld de,(timestamp_now)   ; get previous time
       0B          
0B0836 ED 53 2B 08 0291*      ld (timestamp_old),de   ; save previous time
       0B          
0B083B             0292*      MOSCALL mos_sysvars     ; ix points to syvars table
0B083B 3E 08       0001*M 			LD	A, function
0B083D 5B CF       0002*M 			RST.L	08h
0B083F DD 27 00    0293*      ld hl,(ix+sysvar_time)  ; get current time
0B0842 22 28 08 0B 0294*      ld (timestamp_now),hl   ; save current time
0B0846 AF          0295*      xor a                   ; clear carry
0B0847 ED 52       0296*      sbc hl,de               ; hl = time elapsed
0B0849 22 2E 08 0B 0297*      ld (timestamp_chg),hl   ; save elapsed time
0B084D C9          0298*      ret
0B084E             0299*  
0B084E             0300*  ; set a countdown timer
0B084E             0301*  ; inputs: hl = time to set in 1/120ths of a second; iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B084E             0302*  ; requires: timestamp_tick to be called at least once before this function
0B084E             0303*  ; returns: hl = current time
0B084E             0304*  ; destroys: hl
0B084E             0305*  timestamp_tmr_set:
0B084E FD 2F 03    0306*      ld (iy+3),hl            ; set time remaining
0B0851 2A 28 08 0B 0307*      ld hl,(timestamp_now)   ; get current timestamp
0B0855 FD 2F 00    0308*      ld (iy+0),hl            ; set start time
0B0858 C9          0309*      ret
0B0859             0310*  
0B0859             0311*  ; gets time remaining on a countdown timer following the global timestamp
0B0859             0312*  ; inputs: iy = pointer to 3-byte buffer holding start time,iy+3 = pointer to 3-byte buffer holding timer set value
0B0859             0313*  ; requires: timestamp_tick to be called at least once before this function
0B0859             0314*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0859             0315*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0859             0316*  ; destroys: af,hl,de
0B0859             0317*  timestamp_tmr_get:
0B0859 ED 5B 28 08 0318*      ld de,(timestamp_now)   ; get current timestamp
       0B          
0B085E FD 27 00    0319*      ld hl,(iy+0)            ; get start time
0B0861 AF          0320*      xor a                   ; clear carry
0B0862 ED 52       0321*      sbc hl,de               ; hl = time elapsed (will always be zero or negative)
0B0864 FD 17 03    0322*      ld de,(iy+3)            ; get timer set value
0B0867 AF          0323*      xor a                   ; clear carry
0B0868 ED 5A       0324*      adc hl,de               ; hl = time remaining
0B086A             0325*                              ; (we do adc because add hl,rr doesn't set sign or zero flags)
0B086A C9          0326*      ret
0B086B             0327*  
0B086B             0328*  ; main loop timer functions
0B086B             0329*  tmr_main_loop: ds 6 ; buffer to hold main loop timer
0B0871             0330*  
0B0871             0331*  ; set a countdown timer for the main loop using the timestamp timer
0B0871             0332*  ; inputs: hl = time to set in 1/120ths of a second
0B0871             0333*  ; returns: hl = current time
0B0871             0334*  ; destroys: af,hl,de,ix,iy
0B0871             0335*  tmr_main_loop_set:
0B0871 FD 21 6B 08 0336*      ld iy,tmr_main_loop
       0B          
0B0876 FD 2F 03    0337*      ld (iy+3),hl ; set time remaining
0B0879 CD 31 08 0B 0338*      call timestamp_tick
0B087D 2A 28 08 0B 0339*      ld hl,(timestamp_now)   ; get current timestamp
0B0881 FD 2F 00    0340*      ld (iy+0),hl ; set start time
0B0884 C9          0341*      ret
0B0885             0342*  
0B0885             0343*  ; gets time remaining on the main loop countdown timer following the global timestamp
0B0885             0344*  ; returns: hl pos = time remaining in 1/120ths of a second,hl neg = time past expiration
0B0885             0345*  ;          sign flags: pos = time not expired,zero or neg = time expired
0B0885             0346*  ; destroys: af,hl,de,ix,iy
0B0885             0347*  tmr_main_loop_get:
0B0885 CD 31 08 0B 0348*      call timestamp_tick
0B0889 FD 21 6B 08 0349*      ld iy,tmr_main_loop
       0B          
0B088E CD 59 08 0B 0350*      call timestamp_tmr_get
0B0892 C9          0351*      ret
0B0893             0352*  
0B0893             0353*  ; set a stopwatch
0B0893             0354*  ; returns: hl = start time
0B0893             0355*  ; destroys: hl,ix
0B0893             0356*  stopwatch_set:
0B0893             0357*      MOSCALL mos_sysvars     ; ix points to syvars table
0B0893 3E 08       0001*M 			LD	A, function
0B0895 5B CF       0002*M 			RST.L	08h
0B0897 DD 27 00    0358*      ld hl,(ix+sysvar_time)  ; get current time
0B089A 22 AF 08 0B 0359*      ld (stopwatch_started),hl            ; set start time
0B089E C9          0360*      ret
0B089F             0361*  
0B089F             0362*  ; gets time elapsed on a stopwatch
0B089F             0363*  ; returns: hl = time elapsed in 1/120ths of a second
0B089F             0364*  ; destroys: af,hl,de,ix
0B089F             0365*  stopwatch_get:
0B089F             0366*      MOSCALL mos_sysvars     ; ix points to syvars table
0B089F 3E 08       0001*M 			LD	A, function
0B08A1 5B CF       0002*M 			RST.L	08h
0B08A3 DD 27 00    0367*      ld hl,(ix+sysvar_time)  ; get current time
0B08A6 ED 5B AF 08 0368*      ld de,(stopwatch_started)            ; get start time
       0B          
0B08AB AF          0369*      xor a                   ; clear carry
0B08AC ED 52       0370*      sbc hl,de               ; hl = time elapsed (will always be zero or positive)
0B08AE C9          0371*      ret
0B08AF             0372*  
0B08AF             0373*  stopwatch_started: ds 3 ; buffer to hold stopwatch start time
0B08B2             0374*  
0B08B2             0375*  ; ------------------
0B08B2             0376*  ; delay routine
0B08B2             0377*  ; Author: Richard Turrnidge
0B08B2             0378*  ; https://github.com/richardturnnidge/lessons/blob/main/slowdown.inc
0B08B2             0379*  ; routine waits a fixed time,then returns
0B08B2             0380*  ; arrive with A =  the delay byte. One bit to be set only.
0B08B2             0381*  ; eg. ld A,00000100b
0B08B2             0382*  
0B08B2             0383*  multiPurposeDelay:
0B08B2 F5          0384*      push af
0B08B3 C5          0385*      push bc
0B08B4 DD E5       0386*      push ix
0B08B6 47          0387*      ld b,a
0B08B7 3E 08       0388*      ld a,$08
0B08B9 5B CF       0389*      RST.LIL	08h                 ; get IX pointer to sysvars
0B08BB             0390*  
0B08BB             0391*  waitLoop:
0B08BB             0392*  
0B08BB DD 7E 00    0393*      ld a,(ix + 0)              ; ix+0h is lowest byte of clock timer
0B08BE             0394*  
0B08BE             0395*                                  ;   we check if bit set is same as last time we checked.
0B08BE             0396*                                  ;   bit 0 - don't use
0B08BE             0397*                                  ;   bit 1 - changes 64 times per second
0B08BE             0398*                                  ;   bit 2 - changes 32 times per second
0B08BE             0399*                                  ;   bit 3 - changes 16 times per second
0B08BE             0400*  
0B08BE             0401*                                  ;   bit 4 - changes 8 times per second
0B08BE             0402*                                  ;   bit 5 - changes 4 times per second
0B08BE             0403*                                  ;   bit 6 - changes 2 times per second
0B08BE             0404*                                  ;   bit 7 - changes 1 times per second
0B08BE A0          0405*      and b
0B08BF 4F          0406*      ld c,a
0B08C0 3A D1 08 0B 0407*      ld a,(oldTimeStamp)
0B08C4 B9          0408*      cp c                        ; is A same as last value?
0B08C5 28 F4       0409*      jr z,waitLoop              ; loop here if it is
0B08C7 79          0410*      ld a,c
0B08C8 32 D1 08 0B 0411*      ld (oldTimeStamp),a        ; set new value
0B08CC             0412*  
0B08CC DD E1       0413*      pop ix
0B08CE C1          0414*      pop bc
0B08CF F1          0415*      pop af
0B08D0 C9          0416*      ret
0B08D1             0417*  
0B08D1 00          0418*  oldTimeStamp:   .db 00h
0B08D2             0022       include "vdu.inc"
0B08D2             0001*  
0B08D2             0002*  ; VDU 30: Home cursor
0B08D2             0003*  vdu_home_cursor:
0B08D2 3E 1E       0004*      ld a,30
0B08D4 5B D7       0005*  	rst.lil $10
0B08D6 C9          0006*  	ret
0B08D7             0007*  
0B08D7             0008*  cursor_on:
0B08D7 21 E2 08 0B 0009*  	ld hl,@cmd
0B08DB 01 03 00 00 0010*  	ld bc,@end-@cmd
0B08DF 5B DF       0011*  	rst.lil $18
0B08E1 C9          0012*  	ret
0B08E2             0013*  @cmd:
0B08E2 17 01 01    0014*  	db 23,1,1
0B08E5             0015*  @end:
0B08E5             0016*  
0B08E5             0017*  cursor_off:
0B08E5 21 F0 08 0B 0018*  	ld hl,@cmd
0B08E9 01 03 00 00 0019*  	ld bc,@end-@cmd
0B08ED 5B DF       0020*  	rst.lil $18
0B08EF C9          0021*  	ret
0B08F0             0022*  @cmd:
0B08F0 17 01 00    0023*  	db 23,1,0
0B08F3             0024*  @end:
0B08F3             0025*  
0B08F3             0026*  ; VDU 9: Move cursor forward one character
0B08F3             0027*  vdu_cursor_forward:
0B08F3 3E 09       0028*      ld a,9
0B08F5 5B D7       0029*  	rst.lil $10
0B08F7 C9          0030*  	ret
0B08F8             0031*  
0B08F8             0032*  ; VDU 31, x, y: Move text cursor to x, y text position (TAB(x, y))
0B08F8             0033*  ; inputs: c=x, b=y 8-bit unsigned integers
0B08F8             0034*  vdu_move_cursor:
0B08F8 ED 43 09 09 0035*      ld (@x0),bc
       0B          
0B08FD 21 08 09 0B 0036*  	ld hl,@cmd
0B0901 01 03 00 00 0037*  	ld bc,@end-@cmd
0B0905 5B DF       0038*  	rst.lil $18
0B0907 C9          0039*  	ret
0B0908 1F          0040*  @cmd: 	db 31
0B0909 00          0041*  @x0:	db 0
0B090A 00          0042*  @y0: 	db 0
0B090B 00          0043*  @end: 	db 0 ; padding
0B090C             0044*  
0B090C             0045*  ; VDU 12: Clear text area (CLS)
0B090C             0046*  vdu_cls:
0B090C 3E 0C       0047*      ld a,12
0B090E 5B D7       0048*  	rst.lil $10
0B0910 C9          0049*  	ret
0B0911             0050*  
0B0911             0051*  vdu_flip:
0B0911 21 1C 09 0B 0052*  	ld hl,@cmd
0B0915 01 03 00 00 0053*  	ld bc,@end-@cmd
0B0919 5B DF       0054*  	rst.lil $18
0B091B C9          0055*  	ret
0B091C 17 00 C3    0056*  @cmd: db 23,0,0xC3
0B091F             0057*  @end:
0B091F             0058*  
0B091F             0059*  ; VDU 16: Clear graphics area (CLG)
0B091F             0060*  vdu_clg:
0B091F 3E 10       0061*      ld a,16
0B0921 5B D7       0062*  	rst.lil $10
0B0923 C9          0063*  	ret
0B0924             0064*  
0B0924             0065*  ; COLOUR MODES
0B0924             0066*  ; Mode	Effect
0B0924             0067*  ; 0	Set on-screen pixel to target colour value
0B0924             0068*  ; 1	OR value with the on-screen pixel
0B0924             0069*  ; 2	AND value with the on-screen pixel
0B0924             0070*  ; 3	XOR value with the on-screen pixel
0B0924             0071*  ; 4	Invert the on-screen pixel
0B0924             0072*  ; 5	No operation
0B0924             0073*  ; 6	AND the inverse of the specified colour with the on-screen pixel
0B0924             0074*  ; 7	OR the inverse of the specified colour with the on-screen pixel
0B0924             0075*  
0B0924             0076*  ; VDU 17, colour: Define text colour (COLOUR)
0B0924             0077*  vdu_colour_text:
0B0924 32 34 09 0B 0078*  	ld (@arg),a
0B0928 21 33 09 0B 0079*  	ld hl,@cmd
0B092C 01 02 00 00 0080*  	ld bc,@end-@cmd
0B0930 5B DF       0081*  	rst.lil $18
0B0932 C9          0082*  	ret
0B0933 11          0083*  @cmd: db 17
0B0934 00          0084*  @arg: db 0
0B0935             0085*  @end:
0B0935             0086*  
0B0935             0087*  ; VDU 18, mode, colour: Set graphics colour (GCOL mode, colour)
0B0935             0088*  ; inputs: a=mode, c=colour (add 128 to set background colour)
0B0935             0089*  vdu_gcol:
0B0935 32 4A 09 0B 0090*  	ld (@mode),a
0B0939 79          0091*      ld a,c
0B093A 32 4B 09 0B 0092*      ld (@col),a
0B093E 21 49 09 0B 0093*  	ld hl,@cmd
0B0942 01 03 00 00 0094*  	ld bc,@end-@cmd
0B0946 5B DF       0095*  	rst.lil $18
0B0948 C9          0096*  	ret
0B0949 12          0097*  @cmd:  db 18
0B094A 00          0098*  @mode: db 0
0B094B 00          0099*  @col:  db 0
0B094C             0100*  @end:
0B094C             0101*  
0B094C             0102*  
0B094C             0103*  ; VDU 28, left, bottom, right, top: Set text viewport **
0B094C             0104*  ; MIND THE LITTLE-ENDIANESS
0B094C             0105*  ; inputs: c=left,b=bottom,e=right,d=top
0B094C             0106*  ; outputs; nothing
0B094C             0107*  ; destroys: a might make it out alive
0B094C             0108*  vdu_set_txt_viewport:
0B094C ED 43 62 09 0109*      ld (@lb),bc
       0B          
0B0951 ED 53 64 09 0110*  	ld (@rt),de
       0B          
0B0956 21 61 09 0B 0111*  	ld hl,@cmd
0B095A 01 05 00 00 0112*  	ld bc,@end-@cmd
0B095E 5B DF       0113*  	rst.lil $18
0B0960 C9          0114*  	ret
0B0961 1C          0115*  @cmd:   db 28 ; set text viewport command
0B0962 00 00       0116*  @lb: 	dw 0x0000 ; set by bc
0B0964 00 00       0117*  @rt: 	dw 0x0000 ; set by de
0B0966 00          0118*  @end:   db 0x00	  ; padding
0B0967             0119*  
0B0967             0120*  ; Wait for VBLANK interrupt
0B0967             0121*  vdu_vblank:
0B0967 DD E5       0122*      PUSH 	IX
0B0969             0123*  	MOSCALL	mos_sysvars
0B0969 3E 08       0001*M 			LD	A, function
0B096B 5B CF       0002*M 			RST.L	08h
0B096D DD 7E 00    0124*  	LD	A, (IX + sysvar_time + 0)
0B0970             0125*  @wait:
0B0970 DD BE 00    0126*      CP 	A, (IX + sysvar_time + 0)
0B0973 28 FB       0127*      JR	Z, @wait
0B0975 DD E1       0128*      POP	IX
0B0977 C9          0129*      RET
0B0978             0130*  
0B0978             0131*  ; VDU 24, left; bottom; right; top;: Set graphics viewport
0B0978             0132*  ; NOTE: the order of the y-coordinate parameters are inverted
0B0978             0133*  ; 	because we have turned off logical screen scaling
0B0978             0134*  ; inputs: bc=x0,de=y0,ix=x1,iy=y1
0B0978             0135*  ; outputs; nothing
0B0978             0136*  ; destroys: a might make it out alive
0B0978             0137*  vdu_set_gfx_viewport:
0B0978 ED 43 98 09 0138*      ld (@x0),bc
       0B          
0B097D FD 22 9A 09 0139*      ld (@y1),iy
       0B          
0B0982 DD 22 9C 09 0140*  	ld (@x1),ix
       0B          
0B0987 ED 53 9E 09 0141*  	ld (@y0),de
       0B          
0B098C 21 97 09 0B 0142*  	ld hl,@cmd
0B0990 01 09 00 00 0143*  	ld bc,@end-@cmd
0B0994 5B DF       0144*  	rst.lil $18
0B0996 C9          0145*  	ret
0B0997 18          0146*  @cmd:   db 24 ; set graphics viewport command
0B0998 00 00       0147*  @x0: 	dw 0x0000 ; set by bc
0B099A 00 00       0148*  @y1: 	dw 0x0000 ; set by iy
0B099C 00 00       0149*  @x1: 	dw 0x0000 ; set by ix
0B099E 00 00       0150*  @y0: 	dw 0x0000 ; set by de
0B09A0 00          0151*  @end:   db 0x00	  ; padding
0B09A1             0152*  
0B09A1             0153*  ; SCREEN MODES
0B09A1             0154*  ; ===============================
0B09A1             0155*  ; Mode  Horz  Vert  Cols  Refresh
0B09A1             0156*  ; ---   ----  ----  ----  -------
0B09A1             0157*  ; 11    320   240   2     60hz
0B09A1             0158*  ; 139   320   240   2     60hz
0B09A1             0159*  ; 23    512   384   2     60hz
0B09A1             0160*  ; 151   512   384   2     60hz
0B09A1             0161*  ; 6     640   240   2     60hz
0B09A1             0162*  ; 134   640   240   2     60hz
0B09A1             0163*  ; 2     640   480   2     60hz
0B09A1             0164*  ; 130   640   480   2     60hz
0B09A1             0165*  ; 17    800   600   2     60hz
0B09A1             0166*  ; 145   800   600   2     60hz
0B09A1             0167*  ; 18    1024  768   2     60hz
0B09A1             0168*  ; 146   1024  768   2     60hz
0B09A1             0169*  ; ---   ----  ----  ----  -------
0B09A1             0170*  ; 10    320   240   4     60hz
0B09A1             0171*  ; 138   320   240   4     60hz
0B09A1             0172*  ; 22    512   384   4     60hz
0B09A1             0173*  ; 150   512   384   4     60hz
0B09A1             0174*  ; 5     640   240   4     60hz
0B09A1             0175*  ; 133   640   240   4     60hz
0B09A1             0176*  ; 1     640   480   4     60hz
0B09A1             0177*  ; 129   640   480   4     60hz
0B09A1             0178*  ; 16    800   600   4     60hz
0B09A1             0179*  ; 19    1024  768   4     60hz
0B09A1             0180*  ; ---   ----  ----  ----  -------
0B09A1             0181*  ; 9     320   240   16    60hz
0B09A1             0182*  ; 137   320   240   16    60hz
0B09A1             0183*  ; 21    512   384   16    60hz
0B09A1             0184*  ; 149   512   384   16    60hz
0B09A1             0185*  ; 4     640   240   16    60hz
0B09A1             0186*  ; 132   640   240   16    60hz
0B09A1             0187*  ; 0     640   480   16    60hz
0B09A1             0188*  ; 7     n/a   n/a   16    60hz
0B09A1             0189*  ; ---   ----  ----  ----  -------
0B09A1             0190*  ; 8     320   240   64    60hz
0B09A1             0191*  ; 136   320   240   64    60hz
0B09A1             0192*  ; 20    512   384   64    60hz
0B09A1             0193*  ; 3     640   240   64    60hz
0B09A1             0194*  ; ---   ----  ----  ----  -------
0B09A1             0195*  vdu_set_screen_mode:
0B09A1 32 B1 09 0B 0196*  	ld (@arg),a
0B09A5 21 B0 09 0B 0197*  	ld hl,@cmd
0B09A9 01 02 00 00 0198*  	ld bc,@end-@cmd
0B09AD 5B DF       0199*  	rst.lil $18
0B09AF C9          0200*  	ret
0B09B0 16          0201*  @cmd: db 22 ; set screen mode
0B09B1 00          0202*  @arg: db 0  ; screen mode parameter
0B09B2             0203*  @end:
0B09B2             0204*  
0B09B2             0205*  ; VDU 23, 0, &C0, n: Turn logical screen scaling on and off *
0B09B2             0206*  ; inputs: a is scaling mode, 1=on, 0=off
0B09B2             0207*  ; note: default setting on boot is scaling ON
0B09B2             0208*  vdu_set_scaling:
0B09B2 32 C4 09 0B 0209*  	ld (@arg),a
0B09B6 21 C1 09 0B 0210*  	ld hl,@cmd
0B09BA 01 04 00 00 0211*  	ld bc,@end-@cmd
0B09BE 5B DF       0212*  	rst.lil $18
0B09C0 C9          0213*  	ret
0B09C1 17 00 C0    0214*  @cmd: db 23,0,0xC0
0B09C4 00          0215*  @arg: db 0  ; scaling on/off
0B09C5             0216*  @end:
0B09C5             0217*  
0B09C5             0218*  ; VDU 23, 27, &20, bufferId; : Select bitmap (using a buffer ID)
0B09C5             0219*  ; inputs: hl=bufferId
0B09C5             0220*  vdu_buff_select:
0B09C5 22 D7 09 0B 0221*  	ld (@bufferId),hl
0B09C9 21 D4 09 0B 0222*  	ld hl,@cmd
0B09CD 01 05 00 00 0223*  	ld bc,@end-@cmd
0B09D1 5B DF       0224*  	rst.lil $18
0B09D3 C9          0225*  	ret
0B09D4 17 1B 20    0226*  @cmd: db 23,27,0x20
0B09D7 00 00       0227*  @bufferId: dw 0x0000
0B09D9 00          0228*  @end: db 0x00 ; padding
0B09DA             0229*  
0B09DA             0230*  ; VDU 23, 27, &21, w; h; format: Create bitmap from selected buffer
0B09DA             0231*  ; inputs: a=format; bc=width; de=height
0B09DA             0232*  ; prerequisites: buffer selected by vdu_bmp_select or vdu_buff_select
0B09DA             0233*  ; formats: https://agonconsole8.github.io/agon-docs/VDP---Bitmaps-API.html
0B09DA             0234*  ; 0 	RGBA8888 (4-bytes per pixel)
0B09DA             0235*  ; 1 	RGBA2222 (1-bytes per pixel)
0B09DA             0236*  ; 2 	Mono/Mask (1-bit per pixel)
0B09DA             0237*  ; 3 	Reserved for internal use by VDP (native format)
0B09DA             0238*  vdu_bmp_create:
0B09DA ED 43 F6 09 0239*      ld (@width),bc
       0B          
0B09DF ED 53 F8 09 0240*      ld (@height),de
       0B          
0B09E4 32 FA 09 0B 0241*      ld (@fmt),a
0B09E8 21 F3 09 0B 0242*  	ld hl,@cmd
0B09EC 01 08 00 00 0243*  	ld bc,@end-@cmd
0B09F0 5B DF       0244*  	rst.lil $18
0B09F2 C9          0245*  	ret
0B09F3 17 1B 21    0246*  @cmd:       db 23,27,0x21
0B09F6 00 00       0247*  @width:     dw 0x0000
0B09F8 00 00       0248*  @height:    dw 0x0000
0B09FA 00          0249*  @fmt:       db 0x00
0B09FB             0250*  @end:
0B09FB             0251*  
0B09FB             0252*  ; load an rgba2222 image file to a working buffer and make it an rgba8888 bitmap in a target buffer
0B09FB             0253*  ; inputs: bc,de image width,height ; hl = targetBufferId ; ix = file size ; iy = pointer to filename
0B09FB             0254*  vdu_load_img_rgba2_to_8:
0B09FB             0255*  ; backup the target buffer id and image dimensions
0B09FB E5          0256*      push hl
0B09FC D5          0257*      push de
0B09FD C5          0258*      push bc
0B09FE             0259*  ; load the rgba2 image to working buffer 65534
0B09FE 21 FE FF 00 0260*      ld hl,65534 ; temporary working buffer id
0B0A02 CD 05 0B 0B 0261*  	call vdu_load_buffer_from_file
0B0A06             0262*  ; restore the image dimensions and target buffer id
0B0A06 C1          0263*      pop bc
0B0A07 D1          0264*      pop de
0B0A08 E1          0265*      pop hl
0B0A09             0266*  ; fall through to vdu_rgba2_to_8
0B0A09             0267*  
0B0A09             0268*  ; https://discord.com/channels/1158535358624039014/1158536711148675072/1257757461729771771
0B0A09             0269*  ; ok, so the "expand bitmap" can be used, when coupled with a "reverse" - the expanded bitmap _doesn't_ come out "right" otherwise, cos of endian-ness
0B0A09             0270*  ; the "expand bitmap" command is:
0B0A09             0271*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0A09             0272*  ; and then to reverse the byte order to fix endian-ness:
0B0A09             0273*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0A09             0274*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0A09             0275*  ; VDU 23,27,&20,targetBufferID%;
0B0A09             0276*  ; VDU 23,27,&21,width%;height%;0
0B0A09             0277*  ; -------------------------------------------------------------------
0B0A09             0278*  ; inputs: bc,de image width,height ; hl = targetBufferId
0B0A09             0279*  ; prerequisites: rgba2 image data loaded into workingBufferId 65534
0B0A09             0280*  vdu_rgba2_to_8:
0B0A09             0281*  ; load the image dimensions and buffer id parameters
0B0A09 ED 43 65 0A 0282*      ld (@width),bc
       0B          
0B0A0E ED 53 67 0A 0283*      ld (@height),de
       0B          
0B0A13 22 4A 0A 0B 0284*      ld (@bufferId0),hl
0B0A17 22 57 0A 0B 0285*      ld (@bufferId2),hl
0B0A1B 22 60 0A 0B 0286*      ld (@bufferId1),hl
0B0A1F             0287*  ; clean up bytes that got stomped on by the ID loads
0B0A1F 3E 48       0288*      ld a,0x48
0B0A21 32 4C 0A 0B 0289*      ld (@bufferId0+2),a
0B0A25 3E 17       0290*      ld a,23
0B0A27 32 62 0A 0B 0291*      ld (@bufferId1+2),a
0B0A2B 3E 18       0292*      ld a,24
0B0A2D 32 59 0A 0B 0293*      ld (@bufferId2+2),a
0B0A31 AF          0294*      xor a
0B0A32 32 69 0A 0B 0295*      ld (@height+2),a
0B0A36             0296*  ; send the vdu command strings
0B0A36 21 41 0A 0B 0297*      ld hl,@beg
0B0A3A 01 29 00 00 0298*      ld bc,@end-@beg
0B0A3E 5B DF       0299*      rst.lil $18
0B0A40 C9          0300*      ret
0B0A41             0301*  @beg:
0B0A41             0302*  ; Command 14: Consolidate blocks in a buffer
0B0A41             0303*  ; VDU 23, 0, &A0, bufferId; 14
0B0A41 17 00 A0    0304*      db 23,0,0xA0
0B0A44 FE FF       0305*      dw 65534 ; workingBufferId
0B0A46 0E          0306*      db 14 ; consolidate blocks
0B0A47             0307*  ; the "expand bitmap" command is:
0B0A47             0308*  ; VDU 23,0,&A0,targetBufferID%;&48,2,sourceBufferId%;0,&7F,&BF,&FF
0B0A47 17 00 A0    0309*      db 23,0,0xA0
0B0A4A 00 00       0310*  @bufferId0: dw 0x0000 ; targetBufferId
0B0A4C 48          0311*      db 0x48 ; given as decimal command 72 in the docs
0B0A4D 02          0312*      db 2 ; options mask: %00000011 is the number of bits per pixel in the source bitmap
0B0A4E FE FF       0313*      dw 65534 ; sourceBufferId
0B0A50 00 7F BF FF 0314*      db 0x00,0x7F,0xBF,0xFF ; expanding to bytes by bit-shifting?
0B0A54             0315*  ; reverse the byte order to fix endian-ness:
0B0A54             0316*  ; Command 24: Reverse the order of data of blocks within a buffer
0B0A54             0317*  ; VDU 23, 0, &A0, bufferId; 24, options, [valueSize;] [chunkSize;]
0B0A54             0318*  ; VDU 23,0,&A0,targetBufferID%;24,4,4;
0B0A54 17 00 A0    0319*      db 23,0,0xA0
0B0A57 00 00       0320*  @bufferId2:    dw 0x0000 ; targetBufferId
0B0A59 18          0321*      db 24 ; reverse byte order
0B0A5A 04          0322*      db 4 ; option: Reverse data of the value size within chunk of data of the specified size
0B0A5B 04 00       0323*      dw 4 ; size (4 bytes)
0B0A5D             0324*  ; finally you'd need to set that buffer to be an RGBA8888 format bitmap:
0B0A5D             0325*  ; VDU 23,27,&20,targetBufferID%;
0B0A5D 17 1B 20    0326*      db 23,27,0x20 ; select bitmap
0B0A60 00 00       0327*  @bufferId1: dw 0x0000 ; targetBufferId
0B0A62             0328*  ; VDU 23,27,&21,width%;height%;0
0B0A62 17 1B 21    0329*      db 23,27,0x21 ; create bitmap from buffer
0B0A65 00 00       0330*  @width: dw 0x0000
0B0A67 00 00       0331*  @height: dw 0x0000
0B0A69 00          0332*      db 0x00 ; rgba8888 format
0B0A6A             0333*  @end:
0B0A6A             0334*  
0B0A6A             0335*  ; scratch variables
0B0A6A 00 00 00    0336*  bufferId0: dl 0x000000
0B0A6D 00 00 00    0337*  bufferId1: dl 0x000000
0B0A70             0338*  
0B0A70             0339*  ; load a vdu buffer from local memory
0B0A70             0340*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0A70             0341*  vdu_load_buffer:
0B0A70 ED 43 99 0A 0342*      ld (@length),bc
       0B          
0B0A75 D5          0343*      push de ; save data pointer
0B0A76             0344*  ; send the vdu command string
0B0A76 7D          0345*      ld a,l
0B0A77 32 96 0A 0B 0346*      ld (@bufferId),a
0B0A7B 7C          0347*      ld a,h
0B0A7C 32 97 0A 0B 0348*      ld (@bufferId+1),a
0B0A80 21 93 0A 0B 0349*      ld hl,@cmd
0B0A84 01 08 00 00 0350*      ld bc,@end-@cmd
0B0A88 5B DF       0351*      rst.lil $18
0B0A8A             0352*  ; send the buffer data
0B0A8A E1          0353*      pop hl ; pointer to data
0B0A8B ED 4B 99 0A 0354*      ld bc,(@length)
       0B          
0B0A90 5B DF       0355*      rst.lil $18 ; send it
0B0A92 C9          0356*      ret
0B0A93             0357*  ; Upload data :: VDU 23, 0 &A0, bufferId; 0, length; <buffer-data>
0B0A93 17 00 A0    0358*  @cmd:       db 23,0,0xA0
0B0A96 00 00       0359*  @bufferId:	dw 0x0000
0B0A98 00          0360*  		    db 0 ; load buffer
0B0A99 00 00       0361*  @length:	dw 0x0000
0B0A9B 00          0362*  @end: db 0 ; padding
0B0A9C             0363*  
0B0A9C             0364*  ; clear a buffer
0B0A9C             0365*  ; inputs: hl = bufferId
0B0A9C             0366*  vdu_clear_buffer:
0B0A9C 7D          0367*      ld a,l
0B0A9D 32 B4 0A 0B 0368*      ld (@bufferId),a
0B0AA1 7C          0369*      ld a,h
0B0AA2 32 B5 0A 0B 0370*      ld (@bufferId+1),a
0B0AA6 21 B1 0A 0B 0371*      ld hl,@cmd
0B0AAA 01 06 00 00 0372*      ld bc,@end-@cmd
0B0AAE 5B DF       0373*      rst.lil $18
0B0AB0 C9          0374*      ret
0B0AB1 17 00 A0    0375*  @cmd:       db 23,0,0xA0
0B0AB4 00 00       0376*  @bufferId:	dw 0x0000
0B0AB6 02          0377*  		    db 2 ; clear buffer
0B0AB7             0378*  @end:
0B0AB7             0379*  
0B0AB7             0380*  vdu_clear_all_buffers:
0B0AB7             0381*  ; clear all buffers
0B0AB7 21 C2 0A 0B 0382*      ld hl,@beg
0B0ABB 01 06 00 00 0383*      ld bc,@end-@beg
0B0ABF 5B DF       0384*      rst.lil $18
0B0AC1 C9          0385*      ret
0B0AC2 17 00 A0    0386*  @beg: db 23,0,$A0
0B0AC5 FF FF       0387*        dw -1 ; clear all buffers
0B0AC7 02          0388*        db 2  ; command 2: clear a buffer
0B0AC8             0389*  @end:
0B0AC8             0390*  
0B0AC8             0391*  ; Command 14: Consolidate blocks in a buffer
0B0AC8             0392*  vdu_consolidate_buffer:
0B0AC8             0393*  ; set parameters for vdu call
0B0AC8 7D          0394*      ld a,l
0B0AC9 32 E0 0A 0B 0395*      ld (@bufferId),a
0B0ACD 7C          0396*      ld a,h
0B0ACE 32 E1 0A 0B 0397*      ld (@bufferId+1),a
0B0AD2 21 DD 0A 0B 0398*      ld hl,@beg
0B0AD6 01 06 00 00 0399*      ld bc,@end-@beg
0B0ADA 5B DF       0400*      rst.lil $18
0B0ADC C9          0401*      ret
0B0ADD             0402*  ; VDU 23, 0, &A0, bufferId; 14
0B0ADD 17 00 A0    0403*  @beg: db 23,0,0xA0
0B0AE0 00 00       0404*  @bufferId: dw 0x0000
0B0AE2 0E          0405*             db 14
0B0AE3             0406*  @end:
0B0AE3             0407*  
0B0AE3             0408*  ; load an image file to a buffer and make it a bitmap
0B0AE3             0409*  ; inputs: a = image type ; bc,de image width,height ; hl = bufferId ; ix = file size ; iy = pointer to filename
0B0AE3             0410*  vdu_load_img:
0B0AE3             0411*  ; back up image type and dimension parameters
0B0AE3 22 6A 0A 0B 0412*      ld (bufferId0),hl
0B0AE7 F5          0413*      push af
0B0AE8 C5          0414*  	push bc
0B0AE9 D5          0415*  	push de
0B0AEA             0416*  ; load the image
0B0AEA CD 05 0B 0B 0417*  	call vdu_load_buffer_from_file
0B0AEE             0418*  ; now make it a bitmap
0B0AEE 2A 6A 0A 0B 0419*      ld hl,(bufferId0)
0B0AF2 CD C8 0A 0B 0420*      call vdu_consolidate_buffer
0B0AF6 2A 6A 0A 0B 0421*      ld hl,(bufferId0)
0B0AFA CD C5 09 0B 0422*      call vdu_buff_select
0B0AFE D1          0423*  	pop de ; image height
0B0AFF C1          0424*  	pop bc ; image width
0B0B00 F1          0425*  	pop af ; image type
0B0B01 C3 DA 09 0B 0426*  	jp vdu_bmp_create ; will return to caller from there
0B0B05             0427*  
0B0B05             0428*  ; inputs: hl = bufferId; iy = pointer to filename
0B0B05             0429*  vdu_load_buffer_from_file:
0B0B05 22 6A 0A 0B 0430*      ld (bufferId0),hl
0B0B09             0431*  
0B0B09             0432*  ; clear target buffer
0B0B09 CD 9C 0A 0B 0433*      call vdu_clear_buffer
0B0B0D             0434*  
0B0B0D             0435*  ; open the file in read mode
0B0B0D             0436*  ; Open a file
0B0B0D             0437*  ; HLU: Filename
0B0B0D             0438*  ;   C: Mode
0B0B0D             0439*  ; Returns:
0B0B0D             0440*  ;   A: Filehandle, or 0 if couldn't open
0B0B0D FD E5       0441*  	push iy ; pointer to filename
0B0B0F E1          0442*  	pop hl
0B0B10 0E 01       0443*  	ld c,fa_read
0B0B12             0444*      MOSCALL mos_fopen
0B0B12 3E 0A       0001*M 			LD	A, function
0B0B14 5B CF       0002*M 			RST.L	08h
0B0B16 32 51 0B 0B 0445*      ld (@filehandle),a
0B0B1A             0446*  
0B0B1A             0447*  @read_file:
0B0B1A             0448*  ; Read a block of data from a file
0B0B1A             0449*  ;   C: Filehandle
0B0B1A             0450*  ; HLU: Pointer to where to write the data to
0B0B1A             0451*  ; DEU: Number of bytes to read
0B0B1A             0452*  ; Returns:
0B0B1A             0453*  ; DEU: Number of bytes read
0B0B1A 3A 51 0B 0B 0454*      ld a,(@filehandle)
0B0B1E 4F          0455*      ld c,a
0B0B1F 21 00 E0 B7 0456*      ld hl,filedata
0B0B23 11 00 20 00 0457*      ld de,8192 ; max we can read into onboard sram at one time
0B0B27             0458*      MOSCALL mos_fread
0B0B27 3E 1A       0001*M 			LD	A, function
0B0B29 5B CF       0002*M 			RST.L	08h
0B0B2B             0459*  
0B0B2B             0460*  ; ; DEBUG: print chunk size
0B0B2B             0461*  ;     push de
0B0B2B             0462*  ;     pop hl
0B0B2B             0463*  ;     call printDec
0B0B2B             0464*  ;     call printNewLine
0B0B2B             0465*  
0B0B2B             0466*  ; test de for zero bytes read
0B0B2B 21 00 00 00 0467*      ld hl,0
0B0B2F AF          0468*      xor a ; clear carry
0B0B30 ED 52       0469*      sbc hl,de
0B0B32 CA 48 0B 0B 0470*      jp z,@close_file
0B0B36             0471*  
0B0B36             0472*  ; load a vdu buffer from local memory
0B0B36             0473*  ; inputs: hl = bufferId ; bc = length ; de = pointer to data
0B0B36 2A 6A 0A 0B 0474*      ld hl,(bufferId0)
0B0B3A D5          0475*      push de ; chunksize
0B0B3B C1          0476*      pop bc
0B0B3C 11 00 E0 B7 0477*      ld de,filedata
0B0B40 CD 70 0A 0B 0478*      call vdu_load_buffer
0B0B44             0479*  
0B0B44             0480*  ; ; print progress breadcrumbs
0B0B44             0481*  ;     ld a,'.'
0B0B44             0482*  ;     rst.lil 10h
0B0B44             0483*  
0B0B44             0484*  ; read the next block
0B0B44 C3 1A 0B 0B 0485*      jp @read_file
0B0B48             0486*  
0B0B48             0487*  ; close the file
0B0B48             0488*  @close_file:
0B0B48 3A 51 0B 0B 0489*      ld a,(@filehandle)
0B0B4C             0490*      MOSCALL mos_fclose
0B0B4C 3E 0B       0001*M 			LD	A, function
0B0B4E 5B CF       0002*M 			RST.L	08h
0B0B50 C9          0491*      ret ; vdu_load_buffer_from_file
0B0B51             0492*  
0B0B51 00          0493*  @filehandle: db 0 ; file handle
0B0B52 00 00 00    0494*  @fil: dl 0 ; pointer to FIL struct
0B0B55             0495*  
0B0B55 00 00 00    0496*  @chunkpointer: dl 0 ; pointer to current chunk
0B0B58             0497*  
0B0B58             0498*  ; File information structure (FILINFO)
0B0B58             0499*  @filinfo:
0B0B58 00 00 00 00 0500*  @filinfo_fsize:    blkb 4, 0   ; File size (4 bytes)
0B0B5C 00 00       0501*  @filinfo_fdate:    blkb 2, 0   ; Modified date (2 bytes)
0B0B5E 00 00       0502*  @filinfo_ftime:    blkb 2, 0   ; Modified time (2 bytes)
0B0B60 00          0503*  @filinfo_fattrib:  blkb 1, 0   ; File attribute (1 byte)
0B0B61 00 00 00 00 0504*  @filinfo_altname:  blkb 13, 0  ; Alternative file name (13 bytes)
       00 00 00 00 
       00 00 00 00 
       00          
0B0B6E 00 00 00 00 0505*  @filinfo_fname:    blkb 256, 0 ; Primary file name (256 bytes)
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
       00 00 00 00 
0B0C6E             0023       ; include "vdu_fonts.inc"
0B0C6E             0024       include "vdu_plot.inc"
0B0C6E             0001*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0C6E             0002*  ; PLOT code 	(Decimal) 	Effect
0B0C6E             0003*  ; &00-&07 	0-7 	Solid line, includes both ends
0B0C6E             0004*  plot_sl_both: equ 0x00
0B0C6E             0005*  
0B0C6E             0006*  ; &08-&0F 	8-15 	Solid line, final point omitted
0B0C6E             0007*  plot_sl_first: equ 0x08
0B0C6E             0008*  
0B0C6E             0009*  ; &10-&17 	16-23 	Not supported (Dot-dash line, includes both ends, pattern restarted)
0B0C6E             0010*  ; &18-&1F 	24-31 	Not supported (Dot-dash line, first point omitted, pattern restarted)
0B0C6E             0011*  
0B0C6E             0012*  ; &20-&27 	32-39 	Solid line, first point omitted
0B0C6E             0013*  plot_sl_last: equ 0x20
0B0C6E             0014*  
0B0C6E             0015*  ; &28-&2F 	40-47 	Solid line, both points omitted
0B0C6E             0016*  plot_sl_none: equ 0x28
0B0C6E             0017*  
0B0C6E             0018*  ; &30-&37 	48-55 	Not supported (Dot-dash line, first point omitted, pattern continued)
0B0C6E             0019*  ; &38-&3F 	56-63 	Not supported (Dot-dash line, both points omitted, pattern continued)
0B0C6E             0020*  
0B0C6E             0021*  ; &40-&47 	64-71 	Point plot
0B0C6E             0022*  plot_pt: equ 0x40
0B0C6E             0023*  
0B0C6E             0024*  ; &48-&4F 	72-79 	Line fill left and right to non-background 
0B0C6E             0025*  plot_lf_lr_non_bg: equ 0x48
0B0C6E             0026*  
0B0C6E             0027*  ; &50-&57 	80-87 	Triangle fill
0B0C6E             0028*  plot_tf: equ 0x50
0B0C6E             0029*  
0B0C6E             0030*  ; &58-&5F 	88-95 	Line fill right to background 
0B0C6E             0031*  plot_lf_r_bg: equ 0x58
0B0C6E             0032*  
0B0C6E             0033*  ; &60-&67 	96-103 	Rectangle fill
0B0C6E             0034*  plot_rf: equ 0x60
0B0C6E             0035*  
0B0C6E             0036*  ; &68-&6F 	104-111 	Line fill left and right to foreground 
0B0C6E             0037*  plot_lf_lr_fg: equ 0x60
0B0C6E             0038*  
0B0C6E             0039*  ; &70-&77 	112-119 	Parallelogram fill
0B0C6E             0040*  plot_pf: equ 0x70
0B0C6E             0041*  
0B0C6E             0042*  ; &78-&7F 	120-127 	Line fill right to non-foreground 
0B0C6E             0043*  plot_lf_r_non_fg: equ 0x78
0B0C6E             0044*  
0B0C6E             0045*  ; &80-&87 	128-135 	Not supported (Flood until non-background)
0B0C6E             0046*  ; &88-&8F 	136-143 	Not supported (Flood until foreground)
0B0C6E             0047*  
0B0C6E             0048*  ; &90-&97 	144-151 	Circle outline
0B0C6E             0049*  plot_co: equ 0x90
0B0C6E             0050*  
0B0C6E             0051*  ; &98-&9F 	152-159 	Circle fill
0B0C6E             0052*  plot_cf: equ 0x98
0B0C6E             0053*  
0B0C6E             0054*  ; &A0-&A7 	160-167 	Not supported (Circular arc)
0B0C6E             0055*  ; &A8-&AF 	168-175 	Not supported (Circular segment)
0B0C6E             0056*  ; &B0-&B7 	176-183 	Not supported (Circular sector)
0B0C6E             0057*  
0B0C6E             0058*  ; &B8-&BF 	184-191 	Rectangle copy/move
0B0C6E             0059*  plot_rcm: equ 0xB8
0B0C6E             0060*  
0B0C6E             0061*  ; &C0-&C7 	192-199 	Not supported (Ellipse outline)
0B0C6E             0062*  ; &C8-&CF 	200-207 	Not supported (Ellipse fill)
0B0C6E             0063*  ; &D0-&D7 	208-215 	Not defined
0B0C6E             0064*  ; &D8-&DF 	216-223 	Not defined
0B0C6E             0065*  ; &E0-&E7 	224-231 	Not defined
0B0C6E             0066*  
0B0C6E             0067*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0C6E             0068*  plot_bmp: equ 0xE8
0B0C6E             0069*  
0B0C6E             0070*  ; &F0-&F7 	240-247 	Not defined
0B0C6E             0071*  ; &F8-&FF 	248-255 	Not defined
0B0C6E             0072*  
0B0C6E             0073*  ;  Support added in Agon Console8 VDP 2.1.0  Support added in
0B0C6E             0074*  ; Agon Console8 VDP 2.2.0
0B0C6E             0075*  
0B0C6E             0076*  ; Within each group of eight plot codes, the effects are as follows:
0B0C6E             0077*  ; Plot code 	Effect
0B0C6E             0078*  ; 0 	Move relative
0B0C6E             0079*  mv_rel: equ 0
0B0C6E             0080*  
0B0C6E             0081*  ; 1 	Plot relative in current foreground colour
0B0C6E             0082*  dr_rel_fg: equ 1
0B0C6E             0083*  
0B0C6E             0084*  ; 2 	Not supported (Plot relative in logical inverse colour)
0B0C6E             0085*  ; 3 	Plot relative in current background colour
0B0C6E             0086*  dr_rel_bg: equ 3
0B0C6E             0087*  
0B0C6E             0088*  ; 4 	Move absolute
0B0C6E             0089*  mv_abs: equ 4
0B0C6E             0090*  
0B0C6E             0091*  ; 5 	Plot absolute in current foreground colour
0B0C6E             0092*  dr_abs_fg: equ 5
0B0C6E             0093*  
0B0C6E             0094*  ; 6 	Not supported (Plot absolute in logical inverse colour)
0B0C6E             0095*  ; 7 	Plot absolute in current background colour
0B0C6E             0096*  dr_abs_bg: equ 7
0B0C6E             0097*  
0B0C6E             0098*  ; Codes 0-3 use the position data provided as part of the command
0B0C6E             0099*  ; as a relative position, adding the position given to the current
0B0C6E             0100*  ; graphical cursor position. Codes 4-7 use the position data provided
0B0C6E             0101*  ; as part of the command as an absolute position, setting the current
0B0C6E             0102*  ; graphical cursor position to the position given.
0B0C6E             0103*  
0B0C6E             0104*  ; Codes 2 and 6 on Acorn systems plot using a logical inverse of the
0B0C6E             0105*  ; current pixel colour. These operations cannot currently be supported
0B0C6E             0106*  ; by the graphics system the Agon VDP uses, so these codes are not
0B0C6E             0107*  ; supported. Support for these codes may be added in a future version
0B0C6E             0108*  ; of the VDP firmware.
0B0C6E             0109*  
0B0C6E             0110*  ; 16 colour palette constants
0B0C6E             0111*  c_black: equ 0
0B0C6E             0112*  c_red_dk: equ 1
0B0C6E             0113*  c_green_dk: equ 2
0B0C6E             0114*  c_yellow_dk: equ 3
0B0C6E             0115*  c_blue_dk: equ 4
0B0C6E             0116*  c_magenta_dk: equ 5
0B0C6E             0117*  c_cyan_dk: equ 6
0B0C6E             0118*  c_grey: equ 7
0B0C6E             0119*  c_grey_dk: equ 8
0B0C6E             0120*  c_red: equ 9
0B0C6E             0121*  c_green: equ 10
0B0C6E             0122*  c_yellow: equ 11
0B0C6E             0123*  c_blue: equ 12
0B0C6E             0124*  c_magenta: equ 13
0B0C6E             0125*  c_cyan: equ 14
0B0C6E             0126*  c_white: equ 15
0B0C6E             0127*  
0B0C6E             0128*  ; VDU 25, mode, x; y;: PLOT command
0B0C6E             0129*  ; inputs: a=mode, bc=x0, de=y0
0B0C6E             0130*  vdu_plot:
0B0C6E 32 88 0C 0B 0131*      ld (@mode),a
0B0C72 ED 43 89 0C 0132*      ld (@x0),bc
       0B          
0B0C77 ED 53 8B 0C 0133*      ld (@y0),de
       0B          
0B0C7C 21 87 0C 0B 0134*  	ld hl,@cmd
0B0C80 01 06 00 00 0135*  	ld bc,@end-@cmd
0B0C84 5B DF       0136*  	rst.lil $18
0B0C86 C9          0137*  	ret
0B0C87 19          0138*  @cmd:   db 25
0B0C88 00          0139*  @mode:  db 0
0B0C89 00 00       0140*  @x0: 	dw 0
0B0C8B 00 00       0141*  @y0: 	dw 0
0B0C8D 00          0142*  @end:   db 0 ; extra byte to soak up deu
0B0C8E             0143*  
0B0C8E             0144*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0C8E             0145*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0C8E             0146*  ; VDU 25, mode, x; y;: PLOT command
0B0C8E             0147*  ; inputs: bc=x0, de=y0
0B0C8E             0148*  ; prerequisites: vdu_buff_select
0B0C8E             0149*  vdu_plot_bmp:
0B0C8E ED 43 A5 0C 0150*      ld (@x0),bc
       0B          
0B0C93 ED 53 A7 0C 0151*      ld (@y0),de
       0B          
0B0C98 21 A3 0C 0B 0152*  	ld hl,@cmd
0B0C9C 01 06 00 00 0153*  	ld bc,@end-@cmd
0B0CA0 5B DF       0154*  	rst.lil $18
0B0CA2 C9          0155*  	ret
0B0CA3 19          0156*  @cmd:   db 25
0B0CA4 ED          0157*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0CA5 00 00       0158*  @x0: 	dw 0x0000
0B0CA7 00 00       0159*  @y0: 	dw 0x0000
0B0CA9 00          0160*  @end:   db 0x00 ; padding
0B0CAA             0161*  
0B0CAA             0162*  ; https://agonconsole8.github.io/agon-docs/VDP---PLOT-Commands.html
0B0CAA             0163*  ; &E8-&EF 	232-239 	Bitmap plot 
0B0CAA             0164*  ; VDU 25, mode, x; y;: PLOT command
0B0CAA             0165*  ; inputs: bc=x0, de=y0
0B0CAA             0166*  ; USING 16.8 FIXED POINT COORDINATES
0B0CAA             0167*  ; inputs: ub.c is x coordinate, ud.e is y coordinate
0B0CAA             0168*  ;   the fractional portiion of the inputs are truncated
0B0CAA             0169*  ;   leaving only the 16-bit integer portion
0B0CAA             0170*  ; prerequisites: vdu_buff_select
0B0CAA             0171*  vdu_plot_bmp168:
0B0CAA             0172*  ; populate in the reverse of normal to keep the
0B0CAA             0173*  ; inputs from stomping on each other
0B0CAA ED 53 C8 0C 0174*      ld (@y0-1),de
       0B          
0B0CAF ED 43 C6 0C 0175*      ld (@x0-1),bc
       0B          
0B0CB4 3E ED       0176*      ld a,plot_bmp+dr_abs_fg ; 0xED
0B0CB6 32 C6 0C 0B 0177*      ld (@mode),a ; restore the mode byte that got stomped on by bcu
0B0CBA 21 C5 0C 0B 0178*  	ld hl,@cmd
0B0CBE 01 06 00 00 0179*  	ld bc,@end-@cmd
0B0CC2 5B DF       0180*  	rst.lil $18
0B0CC4 C9          0181*  	ret
0B0CC5 19          0182*  @cmd:   db 25
0B0CC6 ED          0183*  @mode:  db plot_bmp+dr_abs_fg ; 0xED
0B0CC7 00 00       0184*  @x0: 	dw 0x0000
0B0CC9 00 00       0185*  @y0: 	dw 0x0000
0B0CCB             0186*  @end:  ; no padding required b/c we shifted de right
0B0CCB             0187*  
0B0CCB             0188*  ; draw a filled rectangle
0B0CCB             0189*  vdu_plot_rf:
0B0CCB ED 43 F2 0C 0190*      ld (@x0),bc
       0B          
0B0CD0 ED 53 F4 0C 0191*      ld (@y0),de
       0B          
0B0CD5 DD 22 F8 0C 0192*      ld (@x1),ix
       0B          
0B0CDA FD 22 FA 0C 0193*      ld (@y1),iy
       0B          
0B0CDF 3E 19       0194*      ld a,25 ; we have to reload the 2nd plot command
0B0CE1 32 F6 0C 0B 0195*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0CE5 21 F0 0C 0B 0196*  	ld hl,@cmd0
0B0CE9 01 0C 00 00 0197*  	ld bc,@end-@cmd0
0B0CED 5B DF       0198*  	rst.lil $18
0B0CEF C9          0199*      ret
0B0CF0 19          0200*  @cmd0:  db 25 ; plot
0B0CF1 04          0201*  @arg0:  db plot_sl_both+mv_abs
0B0CF2 00 00       0202*  @x0:    dw 0x0000
0B0CF4 00 00       0203*  @y0:    dw 0x0000
0B0CF6 19          0204*  @cmd1:  db 25 ; plot
0B0CF7 65          0205*  @arg1:  db plot_rf+dr_abs_fg
0B0CF8 00 00       0206*  @x1:    dw 0x0000
0B0CFA 00 00       0207*  @y1:    dw 0x0000
0B0CFC 00          0208*  @end:   db 0x00 ; padding
0B0CFD             0209*  
0B0CFD             0210*  ; draw a filled circle
0B0CFD             0211*  vdu_plot_cf:
0B0CFD ED 43 24 0D 0212*      ld (@x0),bc
       0B          
0B0D02 ED 53 26 0D 0213*      ld (@y0),de
       0B          
0B0D07 DD 22 2A 0D 0214*      ld (@x1),ix
       0B          
0B0D0C FD 22 2C 0D 0215*      ld (@y1),iy
       0B          
0B0D11 3E 19       0216*      ld a,25 ; we have to reload the 2nd plot command
0B0D13 32 28 0D 0B 0217*      ld (@cmd1),a ; because the 24-bit y0 load stomped on it
0B0D17 21 22 0D 0B 0218*  	ld hl,@cmd0
0B0D1B 01 0C 00 00 0219*  	ld bc,@end-@cmd0
0B0D1F 5B DF       0220*  	rst.lil $18
0B0D21 C9          0221*      ret
0B0D22 19          0222*  @cmd0:  db 25 ; plot
0B0D23 04          0223*  @arg0:  db plot_sl_both+mv_abs
0B0D24 00 00       0224*  @x0:    dw 0x0000
0B0D26 00 00       0225*  @y0:    dw 0x0000
0B0D28 19          0226*  @cmd1:  db 25 ; plot
0B0D29 9D          0227*  @arg1:  db plot_cf+dr_abs_fg
0B0D2A 00 00       0228*  @x1:    dw 0x0000
0B0D2C 00 00       0229*  @y1:    dw 0x0000
0B0D2E 00          0230*  @end:   db 0x00 ; padding
0B0D2F             0231*  
0B0D2F             0232*  ; VDU 25, mode, x; y;: PLOT command
0B0D2F             0233*  ; inputs: a=mode, ix=x0, iy=y0
0B0D2F             0234*  plot:
0B0D2F 32 49 0D 0B 0235*      ld (@mode),a
0B0D33 DD 22 4A 0D 0236*      ld (@x0),ix
       0B          
0B0D38 FD 22 4C 0D 0237*      ld (@y0),iy
       0B          
0B0D3D 21 48 0D 0B 0238*  	ld hl,@cmd
0B0D41 01 06 00 00 0239*  	ld bc,@end-@cmd
0B0D45 5B DF       0240*  	rst.lil $18
0B0D47 C9          0241*  	ret
0B0D48 19          0242*  @cmd:   db 25
0B0D49 00          0243*  @mode:  db 0
0B0D4A 00 00       0244*  @x0: 	dw 0
0B0D4C 00 00       0245*  @y0: 	dw 0
0B0D4E 00          0246*  @end:   db 0 ; padding
0B0D4F             0247*  
0B0D4F             0248*  ; VDU 5: Write text at graphics cursor
0B0D4F             0249*  ; inputs: hl = pointer to text, ix=x0, iy=y0
0B0D4F             0250*  ; prerequisites: gcol foreground set, VDU 5 set
0B0D4F             0251*  plot_text:
0B0D4F E5          0252*      push hl ; save text pointer
0B0D50             0253*  ; move graphics cursor to x0, y0
0B0D50 3E 44       0254*      ld a,plot_pt+mv_abs
0B0D52 CD 2F 0D 0B 0255*      call plot
0B0D56             0256*  ; write text
0B0D56 E1          0257*      pop hl ; restore text pointer
0B0D57 CD 67 02 0B 0258*      call printString
0B0D5B C9          0259*      ret
0B0D5C             0025   
0B0D5C             0026   ; SHAWN'S INCLUDES
0B0D5C             0027   	INCLUDE	"strings24.asm"
0B0D5C             0001*  ;------------------------------------------------------------------------
0B0D5C             0002*  ;  strings24.asm
0B0D5C             0003*  ;
0B0D5C             0004*  ; 24-bit native ez80 strings routines for numerical processing
0B0D5C             0005*  ;  Copyright (c) Shawn Sijnstra 2024
0B0D5C             0006*  ;  MIT license
0B0D5C             0007*  ;------------------------------------------------------------------------
0B0D5C             0008*  
0B0D5C             0009*  ;Print signed value in HLU in decimal with leading 0s removed
0B0D5C             0010*  ; and postpended with a minus sign if was negative
0B0D5C             0011*  ; Uses HLU, DEU, BCU
0B0D5C             0012*  print_HLU_s24:
0B0D5C CD E0 18 0B 0013*  	call abs_hlu
0B0D60 F5          0014*  	push af ; save the sign and zero flags
0B0D61 CD 6C 0D 0B 0015*  	call print_HLU_u24
0B0D65 F1          0016*  	pop af
0B0D66 F0          0017*  	ret p ; HLU was positive so nothig more to do
0B0D67 3E 2D       0018*  	ld a,'-'
0B0D69 5B D7       0019*  	rst.lil 10h
0B0D6B C9          0020*  	ret
0B0D6C             0021*  
0B0D6C             0022*  ;------------------------------------------------------------------------
0B0D6C             0023*  ;Full print and buffer routine so you can adjust behaviour
0B0D6C             0024*  ; Double-Dabble AKA shift-and-add-3 algorithm
0B0D6C             0025*  ; breakdown at https://en.wikipedia.org/wiki/Double_dabble
0B0D6C             0026*  ;Print value in HLU in decimal with leading 0s removed
0B0D6C             0027*  ; Uses HLU, DEU, BCU
0B0D6C             0028*  ;------------------------------------------------------------------------
0B0D6C             0029*  
0B0D6C             0030*  print_HLU_u24:
0B0D6C 22 49 0E 0B 0031*  	ld	(hex_temp),hl
0B0D70 06 08       0032*  	ld	b,8	;8 digits max here with 24 bit unsigned
0B0D72 11 4C 0E 0B 0033*  	ld	de,outbuf
0B0D76 D5          0034*  	push	de
0B0D77 21 07 00 00 0035*  	ld	hl,7
0B0D7B 19          0036*  	add	hl,de
0B0D7C E5          0037*  	push	hl
0B0D7D D1          0038*  	pop	de	;copy HLU to DEU
0B0D7E AF          0039*  	xor	a
0B0D7F             0040*  _pde_u_zerobuf:
0B0D7F 77          0041*  	ld	(hl),a	;zero out the output
0B0D80 2B          0042*  	dec	hl
0B0D81 10 FC       0043*  	djnz	_pde_u_zerobuf
0B0D83             0044*  
0B0D83 0E 18       0045*  	ld c,3 * 8	;4 * 8	; number of loops through NUM_SRC_BYTES * 8
0B0D85             0046*  _bcd_Convert:
0B0D85             0047*  
0B0D85 21 49 0E 0B 0048*  	ld hl,hex_temp
0B0D89             0049*  ;
0B0D89 CB 26       0050*  	sla (hl)
0B0D8B 23          0051*  	inc hl
0B0D8C CB 16       0052*  	rl (hl)
0B0D8E 23          0053*  	inc hl
0B0D8F CB 16       0054*  	rl (hl)		;24 bits rolled right
0B0D91             0055*  
0B0D91             0056*  
0B0D91 06 08       0057*          ld	b,8	;8 digits max for 24 bit decimal output
0B0D93 D5          0058*  	push	de
0B0D94 E1          0059*  	pop	hl
0B0D95             0060*  
0B0D95             0061*  _bcd_Add3:
0B0D95 7E          0062*  	ld	a,(hl)
0B0D96 8F          0063*  	adc	a
0B0D97 27          0064*          daa		;this is add 3 after shifting left; i.e. add 6.
0B0D98 FE 10       0065*  	cp	10h	;did we roll over nibble?
0B0D9A 3F          0066*  	ccf
0B0D9B CB A7       0067*  	res	4,a
0B0D9D             0068*  
0B0D9D 77          0069*          ld (hl),a
0B0D9E 2B          0070*  	dec	hl
0B0D9F 10 F4       0071*          djnz	_bcd_Add3	;loop for decimal digits
0B0DA1 0D          0072*          dec c
0B0DA2 20 E1       0073*          jr nz, _bcd_Convert	;loop around
0B0DA4             0074*  
0B0DA4             0075*  
0B0DA4 E1          0076*  	pop	hl
0B0DA5 E5          0077*  	push	hl
0B0DA6 06 07       0078*          ld	b,8-1		;one less than total in case output is '0'
0B0DA8             0079*  _pde_u_make_ascii:
0B0DA8 7E          0080*  	ld	a,(hl)
0B0DA9 B7          0081*  	or	a
0B0DAA 20 05       0082*  	jr	nz,_pde_u_make_ascii2
0B0DAC 36 20       0083*  	ld	(hl),' '
0B0DAE 23          0084*  	inc	hl
0B0DAF 10 F7       0085*  	djnz	_pde_u_make_ascii
0B0DB1             0086*  _pde_u_make_ascii2:
0B0DB1 04          0087*  	inc	b
0B0DB2             0088*  _pde_u_make_ascii3:
0B0DB2 7E          0089*  	ld	a,(hl)
0B0DB3 F6 30       0090*  	or	30h
0B0DB5 77          0091*  	ld	(hl),a
0B0DB6 23          0092*  	inc	hl
0B0DB7 10 F9       0093*  	djnz	_pde_u_make_ascii3
0B0DB9             0094*  
0B0DB9 E1          0095*  	pop	hl
0B0DBA 06 08       0096*  	ld	b,8
0B0DBC             0097*  _pde_u_final_out:
0B0DBC 7E          0098*  	ld	a,(hl)
0B0DBD 23          0099*  	inc	hl
0B0DBE FE 20       0100*  	cp	' '
0B0DC0 28 02       0101*  	jr	z,_pde_u_final_out_strip
0B0DC2 5B D7       0102*  	rst.lil	10h
0B0DC4             0103*  _pde_u_final_out_strip:
0B0DC4 10 F6       0104*  	djnz	_pde_u_final_out
0B0DC6 C9          0105*  	ret
0B0DC7             0106*  
0B0DC7             0107*  ;------------------------------------------------------------------------
0B0DC7             0108*  ; is_digit
0B0DC7             0109*  ; C flag set if A is a digit
0B0DC7             0110*  ; preserves all registers
0B0DC7             0111*  ;------------------------------------------------------------------------
0B0DC7             0112*  is_digit:
0B0DC7 FE 30       0113*  	cp	'0'
0B0DC9 3F          0114*  	ccf
0B0DCA D0          0115*  	ret	nc	;less that '0'
0B0DCB FE 3A       0116*  	cp	'9' + 1
0B0DCD C9          0117*  	ret
0B0DCE             0118*  
0B0DCE             0119*  
0B0DCE             0120*  ;------------------------------------------------------------------------
0B0DCE             0121*  ; char2hex
0B0DCE             0122*  ; Input: ASCII nibble in A
0B0DCE             0123*  ; Returns: if valid nibble value in A; else 0FFh in A
0B0DCE             0124*  ;------------------------------------------------------------------------
0B0DCE             0125*  char2hex:
0B0DCE FE 30       0126*  	CP	'0'
0B0DD0 38 1D       0127*  	JR	C, char_not_hex
0B0DD2 FE 3A       0128*  	CP	'9' + 1
0B0DD4 30 03       0129*  	JR	NC, char_not_09
0B0DD6 D6 30       0130*  	sub	'0'
0B0DD8 C9          0131*  	ret
0B0DD9             0132*  
0B0DD9             0133*  char_not_09:
0B0DD9             0134*  	; char is not 0 to 9. Try upper case
0B0DD9 FE 41       0135*  	CP	'A'
0B0DDB 38 12       0136*  	JR	C, char_not_hex
0B0DDD FE 47       0137*  	CP	'F' + 1
0B0DDF 30 03       0138*  	JR	NC, char_not_AF
0B0DE1 D6 37       0139*  	sub	'A'-10
0B0DE3 C9          0140*  	ret
0B0DE4             0141*  
0B0DE4             0142*  char_not_AF:
0B0DE4             0143*  	; char is not upper case A-F. Try lower
0B0DE4 FE 61       0144*  	CP	'a'
0B0DE6 38 07       0145*  	JR	C, char_not_hex
0B0DE8 FE 67       0146*  	CP	'f' + 1
0B0DEA 30 03       0147*  	JR	NC, char_not_hex
0B0DEC D6 57       0148*  	sub	'a' - 10
0B0DEE C9          0149*  	RET
0B0DEF             0150*  
0B0DEF             0151*  char_not_hex:
0B0DEF 3E FF       0152*   	ld	a,0FFh	;return -1 for not a valid hex digit
0B0DF1 C9          0153*  	RET
0B0DF2             0154*  
0B0DF2             0155*  ;------------------------------------------------------------------------
0B0DF2             0156*  ;  newline
0B0DF2             0157*  ;  Output CR+LF; all registers preserved
0B0DF2             0158*  ;------------------------------------------------------------------------
0B0DF2             0159*  newline:
0B0DF2 F5          0160*         push   AF
0B0DF3 3E 0D       0161*         LD     A, 13
0B0DF5 5B D7       0162*         RST.LIL    10h
0B0DF7 3E 0A       0163*         LD     A, 10
0B0DF9 5B D7       0164*         RST.LIL    10h
0B0DFB F1          0165*         POP    AF
0B0DFC C9          0166*         RET
0B0DFD             0167*  
0B0DFD             0168*  ;------------------------------------------------------------------------
0B0DFD             0169*  ;  put_nibble
0B0DFD             0170*  ;  Output a single hex nibble in A
0B0DFD             0171*  ;  All registers preserved
0B0DFD             0172*  ;------------------------------------------------------------------------
0B0DFD             0173*  put_nibble:
0B0DFD F5          0174*  	push   AF
0B0DFE C6 90       0175*  	add    a,090h ;Neat trick to convert hex nibble in A to ASCII
0B0E00 27          0176*  	daa
0B0E01 CE 40       0177*  	adc    a,040h
0B0E03 27          0178*  	daa
0B0E04 5B D7       0179*  	RST.LIL    10h	;output character in A
0B0E06 F1          0180*  	pop    AF
0B0E07 C9          0181*  	ret
0B0E08             0182*  
0B0E08             0183*  ;------------------------------------------------------------------------
0B0E08             0184*  ;  print_A
0B0E08             0185*  ;  Output the 8-bit hex number A
0B0E08             0186*  ;  All registers preserved
0B0E08             0187*  ;------------------------------------------------------------------------
0B0E08             0188*  print_A:
0B0E08 F5          0189*  	push 	AF
0B0E09 F5          0190*  	push 	AF	;save for second nibble
0B0E0A 0F          0191*  	rrca
0B0E0B 0F          0192*  	rrca
0B0E0C 0F          0193*  	rrca
0B0E0D 0F          0194*  	rrca
0B0E0E E6 0F       0195*  	and	0Fh	;first nibble
0B0E10 CD FD 0D 0B 0196*  	call	put_nibble
0B0E14 F1          0197*  	pop 	AF
0B0E15 E6 0F       0198*  	and	0Fh	;second nibble
0B0E17 CD FD 0D 0B 0199*  	call	put_nibble
0B0E1B F1          0200*  	pop 	AF
0B0E1C C9          0201*  	ret
0B0E1D             0202*  
0B0E1D             0203*  ;------------------------------------------------------------------------
0B0E1D             0204*  ;  print_HLU_hex
0B0E1D             0205*  ;  Output the 24-bit hex number HLU; other registers preserved
0B0E1D             0206*  ;------------------------------------------------------------------------
0B0E1D             0207*  print_HLU_hex:
0B0E1D F5          0208*         push   AF
0B0E1E 22 49 0E 0B 0209*         ld     (hex_temp),hl
0B0E22 3A 4B 0E 0B 0210*         ld     a,(hex_temp+2)
0B0E26 CD 08 0E 0B 0211*         call   print_A
0B0E2A 3A 4A 0E 0B 0212*         ld     a,(hex_temp+1)
0B0E2E CD 08 0E 0B 0213*         call   print_A
0B0E32 3A 49 0E 0B 0214*         ld     a,(hex_temp)
0B0E36 CD 08 0E 0B 0215*         call   print_A
0B0E3A F1          0216*         POP    AF
0B0E3B C9          0217*         RET
0B0E3C             0218*  
0B0E3C             0219*  ;------------------------------------------------------------------------
0B0E3C             0220*  ;  puts
0B0E3C             0221*  ;  Output a zero-terminated string whose address is in HL; all
0B0E3C             0222*  ;  registers preserved.
0B0E3C             0223*  ;------------------------------------------------------------------------
0B0E3C             0224*  puts:
0B0E3C F5          0225*         push   AF
0B0E3D C5          0226*         push   BC
0B0E3E 01 00 00 00 0227*         ld     BC, 0                ; Set to 0, so length ignored...
0B0E42 3E 00       0228*         ld     A, 0                 ; Use character in A as delimiter
0B0E44 5B DF       0229*         RST.LIL    18h                  ; This calls a RST in the eZ80 address space
0B0E46 C1          0230*         pop    BC
0B0E47 F1          0231*         pop    AF
0B0E48 C9          0232*         ret
0B0E49             0233*  
0B0E49             0234*  ;------------------------------------------------------------------------
0B0E49             0235*  ; Data area
0B0E49             0236*  ; Storage for 24 bit conversion
0B0E49             0237*  ;------------------------------------------------------------------------
0B0E49             0238*  hex_temp:
0B0E49 00 00 00    0239*         dw24     0      ;3 bytes for HL used for both hex and decimal temp
0B0E4C             0240*  
0B0E4C             0241*  outbuf:
0B0E4C 31 36 37 37 0242*  	db	"16777215 "	;largest number with an extra space
       37 32 31 35 
       20          
0B0E55             0028   	INCLUDE	"arith24.asm"
0B0E55             0001*  
0B0E55             0002*  
0B0E55             0003*  ; unsigned multiplication of a 24-bit and 8-bit number giving a 32-bit result
0B0E55             0004*  ; uses EZ80 MLT instruction for speed
0B0E55             0005*  ; operation: BHL * A --> ABHL
0B0E55             0006*  umul824:
0B0E55 D5          0007*  	push de ; preserve de
0B0E56             0008*  ; low byte
0B0E56 5D          0009*  	ld e,l
0B0E57 57          0010*  	ld d,a
0B0E58 ED 5C       0011*  	mlt de
0B0E5A 6B          0012*  	ld l,e ; product low byte
0B0E5B 08          0013*  	ex af,af' ; save multiplier
0B0E5C 7A          0014*  	ld a,d ; carry
0B0E5D 08          0015*  	ex af,af' ; save carry, restore multiplier
0B0E5E             0016*  ; high byte
0B0E5E 5C          0017*  	ld e,h
0B0E5F 57          0018*  	ld d,a
0B0E60 ED 5C       0019*  	mlt de
0B0E62 08          0020*  	ex af,af' ; save multiplier, restore carry
0B0E63 83          0021*  	add a,e ; add carry
0B0E64 67          0022*  	ld h,a ; product middle byte
0B0E65 7A          0023*  	ld a,d ; carry
0B0E66 08          0024*  	ex af,af' ; save carry, restore multiplier
0B0E67             0025*  ; upper byte
0B0E67 58          0026*  	ld e,b
0B0E68 57          0027*  	ld d,a
0B0E69 ED 5C       0028*  	mlt de
0B0E6B 08          0029*  	ex af,af' ; restore carry
0B0E6C 8B          0030*  	adc a,e ; add carry
0B0E6D 47          0031*  	ld b,a ; product upper byte
0B0E6E             0032*  ; highest byte
0B0E6E 3E 00       0033*  	ld a,0 ; preserve carry flag
0B0E70 8A          0034*  	adc a,d ; product highest byte
0B0E71 D1          0035*  	pop de ; restore de
0B0E72 C9          0036*  	ret
0B0E73             0037*  
0B0E73             0038*  
0B0E73             0039*  
0B0E73             0040*  ; unsigned multiplication of two 24-bit numbers giving a 48-bit result
0B0E73             0041*  ; uses EZ80 MLT instruction and shadow registers for speed
0B0E73             0042*  ; operation: BHL * CDE --> BHLCDE
0B0E73             0043*  ; destroys: everything including shadow registers but not index registers
0B0E73             0044*  umul2424:
0B0E73             0045*  ; put HLU and DEU into B and C respectively
0B0E73             0046*  
0B0E73             0047*  umul2448out: ds 6 ; output buffer
0B0E79             0048*  
0B0E79             0049*  arith24uaf: ds 6
0B0E7F             0050*  arith24uhl: ds 6
0B0E85             0051*  arith24ubc: ds 6
0B0E8B             0052*  arith24ude: ds 6
0B0E91             0053*  arith24uix: ds 6
0B0E97             0054*  arith24uiy: ds 6
0B0E9D             0055*  arith24usp: ds 6
0B0EA3             0056*  arith24upc: ds 6
0B0EA9             0057*  
0B0EA9             0058*  ; hlu 1 byte right shift
0B0EA9             0059*  ; returns: hlu / 256, fractional portion in a
0B0EA9             0060*  ; destroys: af
0B0EA9             0061*  shift_hlu_r1b:
0B0EA9 AF          0062*  	xor a
0B0EAA 32 BB 0E 0B 0063*  	ld (@buffer+3),a
0B0EAE 7D          0064*  	ld a,l ; save the fractional portion
0B0EAF 22 B8 0E 0B 0065*  	ld (@buffer),hl
0B0EB3 2A B9 0E 0B 0066*  	ld hl,(@buffer+1)
0B0EB7 C9          0067*  	ret
0B0EB8             0068*  @buffer: ds 4
0B0EBC             0069*  
0B0EBC             0070*  ;------------------------------------------------------------------------
0B0EBC             0071*  ;  arith24.asm
0B0EBC             0072*  ;  24-bit ez80 arithmetic routines
0B0EBC             0073*  ;  Copyright (c) Shawn Sijnstra 2024
0B0EBC             0074*  ;  MIT license
0B0EBC             0075*  ;
0B0EBC             0076*  ;  This library was created as a tool to help make ez80
0B0EBC             0077*  ;  24-bit native assembly routines for simple mathematical problems
0B0EBC             0078*  ;  more widely available.
0B0EBC             0079*  ;
0B0EBC             0080*  ;------------------------------------------------------------------------
0B0EBC             0081*  
0B0EBC             0082*  ;------------------------------------------------------------------------
0B0EBC             0083*  ; umul24:	HL = HL*DE (unsigned)
0B0EBC             0084*  ; Preserves AF, BC, DE
0B0EBC             0085*  ; Uses a fast multiply routine.
0B0EBC             0086*  ;------------------------------------------------------------------------
0B0EBC             0087*  umul24:
0B0EBC D5          0088*  	push	DE
0B0EBD C5          0089*  	push	BC
0B0EBE F5          0090*  	push	AF
0B0EBF E5          0091*  	push	HL
0B0EC0 C1          0092*  	pop		BC
0B0EC1 3E 18       0093*      ld	 	a, 24 ; No. of bits to process
0B0EC3 21 00 00 00 0094*      ld	 	hl, 0 ; Result
0B0EC7             0095*  umul24_lp:
0B0EC7 29          0096*  	add	hl,hl
0B0EC8 EB          0097*  	ex	de,hl
0B0EC9 29          0098*  	add	hl,hl
0B0ECA EB          0099*  	ex	de,hl
0B0ECB 30 01       0100*  	jr	nc,umul24_nc
0B0ECD 09          0101*  	add	hl,bc
0B0ECE             0102*  umul24_nc:
0B0ECE 3D          0103*  	dec	a
0B0ECF 20 F6       0104*  	jr	nz,umul24_lp
0B0ED1 F1          0105*  	pop	af
0B0ED2 C1          0106*  	pop	bc
0B0ED3 D1          0107*  	pop	de
0B0ED4 C9          0108*  	ret
0B0ED5             0109*  
0B0ED5             0110*  ;------------------------------------------------------------------------
0B0ED5             0111*  ; udiv24
0B0ED5             0112*  ; Unsigned 24-bit division
0B0ED5             0113*  ; Divides HLU by DEU. Gives result in DEU (and BC), remainder in HLU.
0B0ED5             0114*  ;
0B0ED5             0115*  ; Uses AF BC DE HL
0B0ED5             0116*  ; Uses Restoring Division algorithm
0B0ED5             0117*  ;------------------------------------------------------------------------
0B0ED5             0118*  
0B0ED5             0119*  udiv24:
0B0ED5 E5          0120*  	push	hl
0B0ED6 C1          0121*  	pop		bc	;move dividend to BCU
0B0ED7 21 00 00 00 0122*  	ld		hl,0	;result
0B0EDB A7          0123*  	and		a
0B0EDC ED 52       0124*  	sbc		hl,de	;test for div by 0
0B0EDE C8          0125*  	ret		z		;it's zero, carry flag is clear
0B0EDF 19          0126*  	add		hl,de	;HL is 0 again
0B0EE0 3E 18       0127*  	ld		a,24	;number of loops through.
0B0EE2             0128*  udiv1:
0B0EE2 C5          0129*  	push	bc	;complicated way of doing this because of lack of access to top bits
0B0EE3 E3          0130*  	ex		(sp),hl
0B0EE4 37          0131*  	scf
0B0EE5 ED 6A       0132*  	adc	hl,hl
0B0EE7 E3          0133*  	ex	(sp),hl
0B0EE8 C1          0134*  	pop	bc		;we now have bc = (bc * 2) + 1
0B0EE9             0135*  
0B0EE9 ED 6A       0136*  	adc	hl,hl
0B0EEB A7          0137*  	and	a		;is this the bug
0B0EEC ED 52       0138*  	sbc	hl,de
0B0EEE 30 02       0139*  	jr	nc,udiv2
0B0EF0 19          0140*  	add	hl,de
0B0EF1             0141*  ;	dec	c
0B0EF1 0B          0142*  	dec	bc
0B0EF2             0143*  udiv2:
0B0EF2 3D          0144*  	dec	a
0B0EF3 20 ED       0145*  	jr	nz,udiv1
0B0EF5 37          0146*  	scf		;flag used for div0 error
0B0EF6 C5          0147*  	push	bc
0B0EF7 D1          0148*  	pop		de	;remainder
0B0EF8 C9          0149*  	ret
0B0EF9             0150*  
0B0EF9             0151*  
0B0EF9             0152*  ; umul24:	UH.L = UH.L*UD.E (unsigned)
0B0EF9             0153*  ; Preserves AF, BC, DE
0B0EF9             0154*  umul168:
0B0EF9             0155*  
0B0EF9             0156*  umul168out: ds 6
0B0EFF             0157*  
0B0EFF             0158*  ; perform signed multiplication of 16.8 fixed place values
0B0EFF             0159*  ; with an signed 16.8 fixed place result
0B0EFF             0160*  ; inputs: ub.c and ud.e are the operands
0B0EFF             0161*  ; outputs: uh.l is the product
0B0EFF             0162*  ; destroys: a,bc
0B0EFF             0163*  ; TODO: make flags appropriate to the sign of the result
0B0EFF             0164*  smul168:
0B0EFF             0165*  ; make everything positive and save signs
0B0EFF C5          0166*      push bc         ; get bc to hl
0B0F00 E1          0167*      pop hl          ; for the next call
0B0F01 CD E0 18 0B 0168*      call abs_hlu    ; sets sign flag if ubc was negative, zero if zero
0B0F05             0169*  
0B0F05             0170*      ; call dumpFlags ; passes
0B0F05             0171*  
0B0F05 CA 38 0F 0B 0172*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B0F09 F5          0173*      push af         ; save sign of bc
0B0F0A E5          0174*      push hl         ; now put abs(hl)
0B0F0B C1          0175*      pop bc          ; back into bc = abs(bc)
0B0F0C EB          0176*      ex de,hl        ; now we do de same way
0B0F0D CD E0 18 0B 0177*      call abs_hlu    ; sets sign flag if ude was negative, zero if zero
0B0F11             0178*  
0B0F11             0179*      ; call dumpFlags ; passes
0B0F11             0180*  
0B0F11 CA 38 0F 0B 0181*      jp z,@is_zero  ; if de was zero, answer is zero and we're done
0B0F15 EB          0182*      ex de,hl        ; hl back to de = abs(de)
0B0F16             0183*  ; determine sign of result
0B0F16 F2 21 0F 0B 0184*      jp p,@de_pos    ; sign positive,de is positive
0B0F1A             0185*  
0B0F1A             0186*      ; call dumpFlags ; correctly doesnt make it here
0B0F1A             0187*  
0B0F1A F1          0188*      pop af          ; get back sign of bc
0B0F1B             0189*  
0B0F1B             0190*      ; call dumpFlags ; correctly doesn't make it here
0B0F1B             0191*  
0B0F1B FA 2A 0F 0B 0192*      jp m,@result_pos  ; bc and de negative, result is positive
0B0F1F             0193*  
0B0F1F             0194*      ; call dumpFlags  ; corectly doesn't make it here
0B0F1F             0195*  
0B0F1F 18 05       0196*      jr @result_neg
0B0F21             0197*  @de_pos:
0B0F21 F1          0198*      pop af          ; get back sign of bc
0B0F22             0199*  
0B0F22             0200*      ; call dumpFlags  ; passes
0B0F22             0201*  
0B0F22 F2 2A 0F 0B 0202*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B0F26             0203*  
0B0F26             0204*      ; call dumpFlags ; correctly makes it here
0B0F26             0205*  
0B0F26             0206*                      ; fall through to result_neg
0B0F26             0207*  @result_neg:
0B0F26 AF          0208*      xor a           ; zero a and clear carry
0B0F27 3D          0209*      dec a           ; set sign flag to negative
0B0F28             0210*  
0B0F28             0211*      ; call dumpFlags ; passes
0B0F28             0212*  
0B0F28 18 02       0213*      jr @do_mul
0B0F2A             0214*  @result_pos:
0B0F2A AF          0215*      xor a           ; zero a and clear carry
0B0F2B 3C          0216*      inc a           ; set sign flag to positive
0B0F2C             0217*                      ; fall through to do_mul
0B0F2C             0218*  
0B0F2C             0219*      ; call dumpFlags ; correctly doesn't make it here
0B0F2C             0220*  
0B0F2C             0221*  @do_mul:
0B0F2C F5          0222*      push af         ; save sign of result
0B0F2D CD F9 0E 0B 0223*      call umul168
0B0F31 F1          0224*      pop af          ; get back sign of result
0B0F32             0225*  
0B0F32             0226*      ; call dumpFlags ; passes
0B0F32             0227*  
0B0F32 F0          0228*      ret p           ; result is positive so nothing to do
0B0F33             0229*  
0B0F33             0230*      ; call dumpRegistersHex ; passes
0B0F33             0231*  
0B0F33 CD F0 18 0B 0232*      call neg_hlu    ; result is negative so negate it
0B0F37             0233*  
0B0F37             0234*      ; call dumpRegistersHex ; passes
0B0F37 C9          0235*      ret
0B0F38             0236*  @is_zero:           ; result is zero
0B0F38 AF          0237*      xor a           ; sets zero flag, which we want,
0B0F39             0238*                      ; sets pv flag which we might not (zero is parity even)
0B0F39             0239*                      ; resets all others which is okay
0B0F39 C9          0240*      ret
0B0F3A             0241*  
0B0F3A             0242*  ; perform unsigned division of fixed place values
0B0F3A             0243*  ; with an unsigned 16.8 fixed place result
0B0F3A             0244*  ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0B0F3A             0245*  ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0B0F3A             0246*  ; destroys: a,bc
0B0F3A             0247*  udiv168:
0B0F3A             0248*  ; shift dividend left 8 bits
0B0F3A ED 43 86 0E 0249*      ld (arith24ubc+1),bc
       0B          
0B0F3F AF          0250*      xor a
0B0F40 32 85 0E 0B 0251*      ld (arith24ubc),a
0B0F44 ED 4B 85 0E 0252*      ld bc,(arith24ubc)
       0B          
0B0F49 CD D5 0E 0B 0253*      call udiv24
0B0F4D             0254*  ; flip-flop outptuts to satisfy downstream consumers
0B0F4D             0255*  ; TODO: this is a hack and should be fixed
0B0F4D             0256*  ; (so says copilot ... but it's not wrong)
0B0F4D E5          0257*      push hl
0B0F4E C5          0258*      push bc
0B0F4F E1          0259*      pop hl
0B0F50 C1          0260*      pop bc
0B0F51 C9          0261*      ret
0B0F52             0262*  
0B0F52             0263*  ; perform signed division of 16.8 fixed place values
0B0F52             0264*  ; with an signed 16.8 fixed place result
0B0F52             0265*  ; inputs: ub.c is dividend,ud.e is divisor
0B0F52             0266*  ; outputs: uh.l is quotient
0B0F52             0267*  ; destroys: a,bc
0B0F52             0268*  ; note: uses carry flag to test for sign of operands and result
0B0F52             0269*  ;       which can be confusing and should perhaps be changed
0B0F52             0270*  ; note2: helper functions abs_hlu and neg_hlu have been modified
0B0F52             0271*  ;       to return accurate flags according to the origional signs
0B0F52             0272*  ;       (or zero) of this function's inputs
0B0F52             0273*  sdiv168:
0B0F52             0274*  ; make everything positive and save signs
0B0F52 C5          0275*      push bc         ; get bc to hl
0B0F53 E1          0276*      pop hl          ; for the next call
0B0F54 CD E0 18 0B 0277*      call abs_hlu    ; sets sign flag if hlu was negative, zero if zero
0B0F58 CA 8B 0F 0B 0278*      jp z,@is_zero   ; if bc is zero, answer is zero and we're done
0B0F5C F5          0279*      push af         ; save sign of bc
0B0F5D E5          0280*      push hl         ; now put abs(hl)
0B0F5E C1          0281*      pop bc          ; back into bc = abs(bc)
0B0F5F EB          0282*      ex de,hl        ; now we do de same way
0B0F60 CD E0 18 0B 0283*      call abs_hlu
0B0F64 CA 8D 0F 0B 0284*      jp z,@div_by_zero  ; if de was zero, answer is undefined and we're done
0B0F68 EB          0285*      ex de,hl        ; hl back to de = abs(de)
0B0F69             0286*  ; determine sign of result
0B0F69 F2 74 0F 0B 0287*      jp p,@de_pos    ; sign positive,de is positive
0B0F6D F1          0288*      pop af          ; get back sign of bc
0B0F6E FA 7D 0F 0B 0289*      jp m,@result_pos  ; bc and de negative, result is positive
0B0F72 18 05       0290*      jr @result_neg
0B0F74             0291*  @de_pos:
0B0F74 F1          0292*      pop af          ; get back sign of bc
0B0F75 F2 7D 0F 0B 0293*      jp p,@result_pos   ; bc and de are both positive so result is positive
0B0F79             0294*                      ; fall through to result_neg
0B0F79             0295*  @result_neg:
0B0F79 AF          0296*      xor a           ; zero a and clear carry
0B0F7A 3D          0297*      dec a           ; set sign flag to negative
0B0F7B 18 02       0298*      jr @do_div
0B0F7D             0299*  @result_pos:
0B0F7D AF          0300*      xor a           ; zero a and clear carry
0B0F7E 3C          0301*      inc a           ; set sign flag to negative
0B0F7F             0302*                      ; fall through to do_div
0B0F7F             0303*  @do_div:
0B0F7F F5          0304*      push af         ; save sign of result
0B0F80 CD 3A 0F 0B 0305*      call udiv168
0B0F84 F1          0306*      pop af          ; get back sign of result
0B0F85 F0          0307*      ret p           ; result is positive so nothing to do
0B0F86 CD F0 18 0B 0308*      call neg_hlu    ; result is negative so negate it
0B0F8A C9          0309*      ret
0B0F8B             0310*  @is_zero:           ; result is zero
0B0F8B AF          0311*      xor a           ; sets zero flag, which we want,
0B0F8C             0312*                      ; sets pv flag which we might not (zero is parity even)
0B0F8C             0313*                      ; resets all others which is okay
0B0F8C C9          0314*      ret
0B0F8D             0315*  @div_by_zero:       ; result is undefined, which isn't defined in binary
0B0F8D             0316*                      ; so we'll just return zero until i can think of something better
0B0F8D F1          0317*      pop af          ; dummy pop
0B0F8E AF          0318*      xor a           ; sets zero flag, which is ok,
0B0F8F             0319*                      ; sets pv flag which could be interpreted as overflow, which is good
0B0F8F             0320*                      ; resets all others which is okay
0B0F8F C9          0321*      ret
0B0F90             0322*  
0B0F90             0323*  ;------------------------------------------------------------------------
0B0F90             0324*  ; neg24
0B0F90             0325*  ; Returns: HLU = 0-HLU
0B0F90             0326*  ; preserves all other registers
0B0F90             0327*  ;------------------------------------------------------------------------
0B0F90             0328*  neg24:
0B0F90 D5          0329*  	push	de
0B0F91 EB          0330*  	ex		de,hl
0B0F92 21 00 00 00 0331*  	ld		hl,0
0B0F96 B7          0332*  	or		a
0B0F97 ED 52       0333*  	sbc		hl,de
0B0F99 D1          0334*  	pop		de
0B0F9A C9          0335*  	ret
0B0F9B             0336*  
0B0F9B             0337*  ;------------------------------------------------------------------------
0B0F9B             0338*  ; or_hlu_deu: 24 bit bitwise OR
0B0F9B             0339*  ; Returns: hlu = hlu OR deu
0B0F9B             0340*  ; preserves all other registers
0B0F9B             0341*  ;------------------------------------------------------------------------
0B0F9B             0342*  or_hlu_deu:
0B0F9B 22 26 10 0B 0343*  	ld	(bitbuf1),hl
0B0F9F ED 53 29 10 0344*  	ld	(bitbuf2),de
       0B          
0B0FA4 D5          0345*  	push	de	;preserve DEU
0B0FA5 C5          0346*  	push	bc	;preserve BCU
0B0FA6 06 03       0347*  	ld		b,3
0B0FA8 21 26 10 0B 0348*  	ld	hl,bitbuf1
0B0FAC 11 26 10 0B 0349*  	ld	de,bitbuf1
0B0FB0             0350*  orloop_24:
0B0FB0 1A          0351*  	ld	a,(de)
0B0FB1 B6          0352*  	or	(hl)
0B0FB2 12          0353*  	ld	(de),a
0B0FB3 13          0354*  	inc	de
0B0FB4 23          0355*  	inc	hl
0B0FB5 10 F9       0356*  	djnz	orloop_24
0B0FB7 2A 29 10 0B 0357*  	ld	hl,(bitbuf2)
0B0FBB C1          0358*  	pop		bc	;restore BC
0B0FBC D1          0359*  	pop		de	;restore DE
0B0FBD             0360*  
0B0FBD             0361*  ;------------------------------------------------------------------------
0B0FBD             0362*  ; and_hlu_deu: 24 bit bitwise AND
0B0FBD             0363*  ; Returns: hlu = hlu AND deu
0B0FBD             0364*  ; preserves all other registers
0B0FBD             0365*  ;------------------------------------------------------------------------
0B0FBD             0366*  and_hlu_deu:
0B0FBD 22 26 10 0B 0367*  	ld	(bitbuf1),hl
0B0FC1 ED 53 29 10 0368*  	ld	(bitbuf2),de
       0B          
0B0FC6 D5          0369*  	push	de	;preserve DEU
0B0FC7 C5          0370*  	push	bc	;preserve BCU
0B0FC8 06 03       0371*  	ld		b,3
0B0FCA 21 26 10 0B 0372*  	ld	hl,bitbuf1
0B0FCE 11 26 10 0B 0373*  	ld	de,bitbuf1
0B0FD2             0374*  andloop_24:
0B0FD2 1A          0375*  	ld	a,(de)
0B0FD3 A6          0376*  	and	(hl)
0B0FD4 12          0377*  	ld	(de),a
0B0FD5 13          0378*  	inc	de
0B0FD6 23          0379*  	inc	hl
0B0FD7 10 F9       0380*  	djnz	andloop_24
0B0FD9 2A 29 10 0B 0381*  	ld	hl,(bitbuf2)
0B0FDD C1          0382*  	pop		bc	;restore BC
0B0FDE D1          0383*  	pop		de	;restore DE
0B0FDF             0384*  
0B0FDF             0385*  ;------------------------------------------------------------------------
0B0FDF             0386*  ; xor_hlu_deu: 24 bit bitwise XOR
0B0FDF             0387*  ; Returns: hlu = hlu XOR deu
0B0FDF             0388*  ; preserves all other registers
0B0FDF             0389*  ;------------------------------------------------------------------------
0B0FDF             0390*  xor_hlu_deu:
0B0FDF 22 26 10 0B 0391*  	ld	(bitbuf1),hl
0B0FE3 ED 53 29 10 0392*  	ld	(bitbuf2),de
       0B          
0B0FE8 D5          0393*  	push	de	;preserve DEU
0B0FE9 C5          0394*  	push	bc	;preserve BCU
0B0FEA 06 03       0395*  	ld		b,3
0B0FEC 21 26 10 0B 0396*  	ld	hl,bitbuf1
0B0FF0 11 26 10 0B 0397*  	ld	de,bitbuf1
0B0FF4             0398*  xorloop_24:
0B0FF4 1A          0399*  	ld	a,(de)
0B0FF5 AE          0400*  	xor	(hl)
0B0FF6 12          0401*  	ld	(de),a
0B0FF7 13          0402*  	inc	de
0B0FF8 23          0403*  	inc	hl
0B0FF9 10 F9       0404*  	djnz	xorloop_24
0B0FFB 2A 29 10 0B 0405*  	ld	hl,(bitbuf2)
0B0FFF C1          0406*  	pop		bc	;restore BC
0B1000 D1          0407*  	pop		de	;restore DE
0B1001             0408*  
0B1001             0409*  ;------------------------------------------------------------------------
0B1001             0410*  ; shl_hlu: 24 bit shift left hlu by deu positions
0B1001             0411*  ; Returns: hlu = hlu << deu
0B1001             0412*  ;		   de = 0
0B1001             0413*  ; NOTE: only considers deu up to 16 bits.
0B1001             0414*  ; preserves all other registers
0B1001             0415*  ;------------------------------------------------------------------------
0B1001             0416*  shl_hlu:
0B1001 7A          0417*  	ld		a,d		;up to 16 bit.
0B1002 B3          0418*  	or		e
0B1003 C8          0419*  	ret		z		;we're done
0B1004 29          0420*  	add		hl,hl	;shift HLU left
0B1005 1B          0421*  	dec		de
0B1006 18 F9       0422*  	jr		shl_hlu
0B1008             0423*  
0B1008             0424*  ;------------------------------------------------------------------------
0B1008             0425*  ; shr_hlu: 24 bit shift right hlu by deu positions
0B1008             0426*  ; Returns: hlu = hlu >> deu
0B1008             0427*  ;		   de = 0
0B1008             0428*  ; NOTE: only considers deu up to 16 bits.
0B1008             0429*  ; preserves all other registers
0B1008             0430*  ;------------------------------------------------------------------------
0B1008             0431*  shr_hlu:
0B1008 22 26 10 0B 0432*  	ld		(bitbuf1),hl
0B100C 21 28 10 0B 0433*  	ld		hl,bitbuf1+2
0B1010             0434*  shr_loop:
0B1010 7A          0435*  	ld		a,d		;up to 16 bit.
0B1011 B3          0436*  	or		e
0B1012 28 0D       0437*  	jr		z,shr_done		;we're done
0B1014             0438*  ;carry is clear from or instruction
0B1014 CB 1E       0439*  	rr		(hl)
0B1016 2B          0440*  	dec		hl
0B1017 CB 1E       0441*  	rr		(hl)
0B1019 2B          0442*  	dec		hl
0B101A CB 1E       0443*  	rr		(hl)
0B101C 23          0444*  	inc		hl
0B101D 23          0445*  	inc		hl
0B101E 1B          0446*  	dec		de
0B101F 18 EF       0447*  	jr		shr_loop
0B1021             0448*  shr_done:
0B1021 2A 26 10 0B 0449*  	ld		hl,(bitbuf1)	;collect result
0B1025 C9          0450*  	ret
0B1026             0451*  
0B1026             0452*  ;------------------------------------------------------------------------
0B1026             0453*  ; Scratch area for calculations
0B1026             0454*  ;------------------------------------------------------------------------
0B1026 00 00 00    0455*  bitbuf1:	dw24	0	;bit manipulation buffer 1
0B1029 00 00 00    0456*  bitbuf2:	dw24	0	;bit manipulation buffer 2
0B102C             0457*  
0B102C             0458*  ; ========== FROM maths24.inc ==========
0B102C             0459*  
0B102C             0460*  ; http://www.z80.info/pseudo-random.txt
0B102C             0461*  rand_8:
0B102C C5          0462*      push bc
0B102D 3A 40 10 0B 0463*      ld a,(r_seed)
0B1031 4F          0464*      ld c,a
0B1032             0465*  
0B1032 0F          0466*      rrca ; multiply by 32
0B1033 0F          0467*      rrca
0B1034 0F          0468*      rrca
0B1035 EE 1F       0469*      xor 0x1f
0B1037             0470*  
0B1037 81          0471*      add a,c
0B1038 DE FF       0472*      sbc a,255 ; carry
0B103A             0473*  
0B103A 32 40 10 0B 0474*      ld (r_seed),a
0B103E C1          0475*      pop bc
0B103F C9          0476*      ret
0B1040 50          0477*  r_seed: defb $50
0B1041             0478*  
0B1041             0479*  ; tests the sign of 24-bit register hlu
0B1041             0480*  ; returns: a in [-1,0,1]
0B1041             0481*  ;   sign and zero flags as expected
0B1041             0482*  ;   hl is untouched
0B1041             0483*  ; GPT-4 wrote most of this. the or l was inspired. it did bit 7,a instead of h
0B1041             0484*  ; and it left the zero flag set after ld a,1,which i fixed by anding it
0B1041             0485*  get_sign_hlu:
0B1041             0486*      ; Load the upper byte of HLU into A
0B1041 E5          0487*      push hl
0B1042 DD 21 00 00 0488*      ld ix,0
       00          
0B1047 DD 39       0489*      add ix,sp
0B1049 DD 7E 02    0490*      ld a,(ix+2)
0B104C E1          0491*      pop hl
0B104D             0492*  
0B104D B5          0493*      or l                ; OR with the low byte to check if HL is zero
0B104E C8          0494*      ret z               ; Return if HL is zero
0B104F             0495*  
0B104F 3E FF       0496*      ld a,-1             ; Send A back as -1 if the sign flag is set
0B1051 CB 7C       0497*      bit 7,h            ; Test the sign bit (7th bit) of the high byte
0B1053 C0          0498*      ret nz              ; If set,HL is negative,return with the sign flag set
0B1054             0499*  
0B1054 3E 01       0500*      ld a,1             ; Otherwise,HL is positive
0B1056 A7          0501*      and a               ; Reset the zero flag
0B1057 C9          0502*      ret                 ; Return with A set to 1
0B1058             0503*  
0B1058             0504*  ; convert unsigned angles from a 360 to 255 degree circle
0B1058             0505*  ; inputs: uh.l is the angle360 in 16.8 fixed format
0B1058             0506*  ; outputs: uh.l is the angle255 in 16.8 fixed format
0B1058             0507*  ; destroys: TODO
0B1058             0508*  ; note: even though the inputs and outputs are 16.8 fixed format
0B1058             0509*  ;       precision is effectively limited to 8.8 fixed format
0B1058             0510*  deg_360_to_255:
0B1058             0511*  ; clear scratch buffer
0B1058 11 00 00 00 0512*  	ld de,0
0B105C ED 53 88 10 0513*  	ld (@scratch),de
       0B          
0B1061             0514*  ; divide uh.l by 360
0B1061 11 68 01 00 0515*  	ld de,360
0B1065             0516*  ; get integer portion
0B1065 CD D5 0E 0B 0517*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B1069 ED 53 8F 10 0518*  	ld (@output+1),de ; shift result up one byte
       0B          
0B106E             0519*  ; get fractional portion
0B106E 22 89 10 0B 0520*  	ld (@scratch+1),hl ; shift remainder up one byte
0B1072 2A 88 10 0B 0521*  	ld hl,(@scratch)
0B1076 11 68 01 00 0522*  	ld de,360
0B107A CD D5 0E 0B 0523*  	call udiv24 ; DEU AND BCU = HLU / DEU, remainder in HLU
0B107E 7B          0524*  	ld a,e ; lowest byte is all we need
0B107F 32 8E 10 0B 0525*  	ld (@output),a
0B1083             0526*  ; we want the low 3 bytes for 16.8 output
0B1083 2A 8E 10 0B 0527*  	ld hl,(@output)
0B1087 C9          0528*  	ret
0B1088             0529*  @scratch: ds 6 ; scratch buffer for shifting bytes
0B108E             0530*  @output: ds 6 ; scratch buffer to accumulate output
0B1094             0531*  
0B1094             0532*  ; 16.8 fixed inputs / outputs
0B1094             0533*  ; takes: uh.l as angle in degrees 256
0B1094             0534*  ;        ud.e as radius
0B1094             0535*  ; returns ub.c as dx, ud.e as dy
0B1094             0536*  ;        displacements from origin (0,0)
0B1094             0537*  ; destroys: everything except indexes
0B1094             0538*  polar_to_cartesian:
0B1094             0539*  ; back up input parameters
0B1094 22 7F 0E 0B 0540*      ld (arith24uhl), hl
0B1098 ED 53 8B 0E 0541*      ld (arith24ude), de
       0B          
0B109D             0542*  ; compute dx = sin(uh.l) * ud.e
0B109D CD CC 10 0B 0543*      call sin168
0B10A1 E5          0544*      push hl
0B10A2 C1          0545*      pop bc          ; ub.c = sin(uh.l)
0B10A3 ED 5B 8B 0E 0546*  	ld de, (arith24ude)   ; get radius back
       0B          
0B10A8 CD FF 0E 0B 0547*  	call smul168    ; uh.l = ub.c * ud.e = dx
0B10AC E5          0548*      push hl         ; store dx for output
0B10AD             0549*  ; compute dy = -cos(uh.l) * ud.e
0B10AD 2A 7F 0E 0B 0550*      ld hl, (arith24uhl)
0B10B1 CD C7 10 0B 0551*      call cos168
0B10B5 CD F0 18 0B 0552*  	call neg_hlu    ; invert dy for screen coords convention
0B10B9 E5          0553*      push hl
0B10BA C1          0554*      pop bc          ; ub.c = -cos(uh.l)
0B10BB ED 5B 8B 0E 0555*      ld de, (arith24ude)   ; get radius back
       0B          
0B10C0 CD FF 0E 0B 0556*      call smul168    ; uh.l = ub.c * ud.e = dy
0B10C4 EB          0557*      ex de, hl       ; de = dy for output
0B10C5 C1          0558*      pop bc          ; bc = dx for output
0B10C6             0559*  ; and out
0B10C6 C9          0560*      ret
0B10C7             0561*  
0B10C7             0562*  ; fixed 16.8 routine
0B10C7             0563*  ; cos(uh.l) --> uh.l
0B10C7             0564*  ; destroys: de
0B10C7             0565*  cos168:
0B10C7             0566*  ; for cos we simply increment the angle by 90 degrees
0B10C7             0567*  ; or 0x004000 in 16.8 degrees256
0B10C7             0568*  ; which makes it a sin problem
0B10C7 11 00 40 00 0569*      ld de,0x004000
0B10CB 19          0570*      add hl,de ; modulo 256 happens below
0B10CC             0571*  ; fall through to sin168
0B10CC             0572*  ; ---------------------
0B10CC             0573*  ; fixed 16.8 routine
0B10CC             0574*  ; sin(uh.l) --> uh.l
0B10CC             0575*  ; destroys: de
0B10CC             0576*  sin168:
0B10CC             0577*  ; h contains the integer portion of our angle
0B10CC             0578*  ; we multiply it by three to get our lookup table index
0B10CC 2E 03       0579*      ld l,3
0B10CE ED 6C       0580*      mlt hl ; gosh that is handy
0B10D0 11 00 00 00 0581*      ld de,0 ; clear deu
0B10D4 54          0582*      ld d,h ; copy hl to de
0B10D5 5D          0583*      ld e,l ; de contains our index
0B10D6 21 DD 12 0B 0584*      ld hl,sin_lut_168 ; grab the lut address
0B10DA 19          0585*      add hl,de ; bump hl by the index
0B10DB ED 27       0586*      ld hl,(hl) ; don't try this on a z80!
0B10DD C9          0587*      ret ; and out
0B10DE             0588*  
0B10DE             0589*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B10DE             0590*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B10DE             0591*  ; output: ub.c and ud.e are dx and dy in 16.8 fixed format
0B10DE             0592*  ;         also populates scratch locations dx168 and dy168
0B10DE             0593*  ; destroys: a,hl,bc,de
0B10DE             0594*  dxy168:
0B10DE             0595*  ; compute dx = x1-x0
0B10DE AF          0596*      xor a ; clear carry
0B10DF DD E5       0597*      push ix ; move ix to hl via the stack
0B10E1 E1          0598*      pop hl ; hl = x1
0B10E2 ED 42       0599*      sbc hl,bc ; hl = dx
0B10E4 22 39 11 0B 0600*      ld (dx168),hl ; dx to scratch
0B10E8             0601*  ; compute dy = y1-y0
0B10E8 AF          0602*      xor a ; clear carry
0B10E9 FD E5       0603*      push iy ; move iy to hl via the stack
0B10EB E1          0604*      pop hl ; hl = y1
0B10EC ED 52       0605*      sbc hl,de ; hl = dy
0B10EE 22 3F 11 0B 0606*      ld (dy168),hl ; dy to scratch
0B10F2             0607*  ; populate output registers and return
0B10F2 EB          0608*      ex de,hl        ; ud.e = dy
0B10F3 ED 4B 39 11 0609*      ld bc,(dx168)   ; ub.c = dx
       0B          
0B10F8 C9          0610*      ret
0B10F9             0611*  
0B10F9             0612*  ; compute the euclidian distance between two cartesian coordinates
0B10F9             0613*  ; using the formula d = sqrt(dx^2+dy^2
0B10F9             0614*  ; inputs: ub.c and ud.e are x0 and y0 in 16.8 fixed format
0B10F9             0615*  ;         ui.x and ui.y are x1 and y1 in 16.8 fixed format
0B10F9             0616*  ; output; uh.l is the 16.8 fixed format distance
0B10F9             0617*  ;       dx168/y are the 16.8 fixed format dx and dy
0B10F9             0618*  ; destroys: a,hl,bc,de
0B10F9             0619*  distance168:
0B10F9             0620*  ; compute dx = x1-x0
0B10F9 AF          0621*      xor a ; clear carry
0B10FA DD E5       0622*      push ix ; move ix to hl via the stack
0B10FC E1          0623*      pop hl ; hl = x1
0B10FD ED 42       0624*      sbc hl,bc ; hl = dx
0B10FF 22 39 11 0B 0625*      ld (dx168),hl ; dx to scratch
0B1103             0626*  ; ; test dx for overflow
0B1103             0627*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B1103             0628*  ; 	ex de,hl
0B1103             0629*  ; 	sbc hl,de ; test for overflow
0B1103             0630*  ; 	push af ; carry indicates overflow
0B1103             0631*  ; compute dy = y1-y0
0B1103 AF          0632*      xor a ; clear carry
0B1104 FD E5       0633*      push iy ; move iy to hl via the stack
0B1106 E1          0634*      pop hl ; hl = y1
0B1107 ED 52       0635*      sbc hl,de ; hl = dy
0B1109 22 3F 11 0B 0636*      ld (dy168),hl ; dy to scratch
0B110D             0637*  ; ; test dy for overflow
0B110D             0638*  ; 	ld de,0x007F00 ; max positive 16.8 value we can square without overflow
0B110D             0639*  ; 	ex de,hl
0B110D             0640*  ; 	sbc hl,de ; test for overflow
0B110D             0641*  ; 	push af ; carry indicates overflow
0B110D             0642*  ; compute dy^2
0B110D 2A 3F 11 0B 0643*  	ld hl,(dy168)
0B1111 CD E0 18 0B 0644*      call abs_hlu  ; make dy positive so we can use unsigned multiply
0B1115             0645*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B1115 E5          0646*      push hl ; load hl/2 to bc via the stack
0B1116 C1          0647*      pop bc ; bc = dy/2
0B1117 EB          0648*      ex de,hl ; de = dy/2
0B1118 CD F9 0E 0B 0649*      call umul168 ; uh.l = dy^2/2
0B111C E5          0650*      push hl ; dy^2/2 to the stack
0B111D             0651*  ; compute dx^2
0B111D 2A 39 11 0B 0652*      ld hl,(dx168) ; get back dx
0B1121 CD E0 18 0B 0653*      call abs_hlu  ; make dx positive so we can use unsigned multiply
0B1125             0654*      ; call hlu_div2 ; divide hlu by 2 to give us some headroom
0B1125 E5          0655*      push hl ; load hl/2 to bc via the stack
0B1126 C1          0656*      pop bc ; bc = dx/2
0B1127 EB          0657*      ex de,hl ; de = dx/2
0B1128 CD F9 0E 0B 0658*      call umul168 ; uh.l = dx^2/2
0B112C             0659*  ; commpute dy^2+dx^2
0B112C D1          0660*      pop de ; get back dx^2/2
0B112D 19          0661*      add hl,de ; hl = dx^2/2+dy^2/2
0B112E             0662*  ; compute sqrt(dx^2/2+dy^2/2)
0B112E CD F2 11 0B 0663*      call sqrt168 ; uh.l = distance/2
0B1132             0664*      ; add hl,hl ; hl = distance
0B1132             0665*  ; ; check for overflow
0B1132             0666*  ; 	pop af ; get back the overflow flags
0B1132             0667*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B1132             0668*  ; 	ld b,a ; save the overflow flag
0B1132             0669*  ; 	pop af ; get back the overflow flags
0B1132             0670*  ; 	sbc a,a ; will be -1 if overflow, 0 if not
0B1132             0671*  ; 	add a,b ; if a != 0 then we had overflow
0B1132             0672*  ;     ret z ; no overflow we're done
0B1132             0673*  ; @overflow:
0B1132             0674*  ; 	ld hl,0x7FFFFF ; max positive 16.8 fixed value indicates overflow
0B1132 C9          0675*  	ret
0B1133             0676*  @scratch: ds 6
0B1139             0677*  dx168: ds 6
0B113F             0678*  dy168: ds 6
0B1145             0679*  
0B1145             0680*  ; atan2(ub.c,ud.e) --> uh.l
0B1145             0681*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B1145             0682*  ;   whether inputs are integers or fractional doesn't matter
0B1145             0683*  ;   so long as the sign bit of the upper byte is correct
0B1145             0684*  ; output: uh.l is the 16.8 fixed angle in degrees 256
0B1145             0685*  ; angles are COMPASS HEADINGS based on
0B1145             0686*  ; screen coordinate conventions,where the y axis is flipped
0B1145             0687*  ; #E0 315      0       45 #20
0B1145             0688*  ;        -x,-y | +x,-y
0B1145             0689*  ; #C0 270------+------ 90 #40
0B1145             0690*  ;        -x,+y | +x,+y
0B1145             0691*  ; #A0 225   180 #80   135 #60
0B1145             0692*  atan2_168game:
0B1145             0693*  ; get signs and make everything positive
0B1145             0694*  ; get abs(x) and store its original sign
0B1145 C5          0695*      push bc
0B1146 E1          0696*      pop hl
0B1147 CD E0 18 0B 0697*      call abs_hlu ; if x was negative this also sets the sign flag
0B114B E5          0698*      push hl ; store abs(x)
0B114C C1          0699*      pop bc ; bc = abs(x)
0B114D F5          0700*      push af ; store sign of x
0B114E             0701*  ; get abs(y) and store its original sign
0B114E EB          0702*      ex de,hl ; hl = y
0B114F CD E0 18 0B 0703*      call abs_hlu ; if y was negative this also sets the sign flag
0B1153 EB          0704*      ex de,hl ; de = abs(y)
0B1154 F5          0705*      push af ; store sign of y
0B1155             0706*  ; if abs(bc) < abs(de),then we do bc/de,otherwise de/bc
0B1155             0707*  ; this ensures that our lookup value is between 0 and 1 inclusive
0B1155 AF          0708*      xor a ; clear the carry flag
0B1156 D5          0709*      push de
0B1157 E1          0710*      pop hl
0B1158 ED 42       0711*      sbc hl,bc
0B115A F5          0712*      push af ; save sign of de - bc
0B115B F2 64 11 0B 0713*      jp p,@1 ; bc <= de, so we skip ahead
0B115F             0714*  ; otherwise we swap bc and de
0B115F C5          0715*      push bc
0B1160 E1          0716*      pop hl
0B1161 EB          0717*      ex de,hl
0B1162 E5          0718*      push hl
0B1163 C1          0719*      pop bc
0B1164             0720*  @1:
0B1164             0721*  ; now we're ready to snag our preliminary result
0B1164 CD D2 11 0B 0722*      call atan_168game ; uh.l comes back with prelim result
0B1168             0723*  ; now we adjust uh.l based on sign of de - bc
0B1168 F1          0724*      pop af
0B1169 F2 75 11 0B 0725*      jp p,@2 ; bc <= de,so we skip ahead
0B116D EB          0726*      ex de,hl
0B116E 21 00 40 00 0727*      ld hl,0x004000 ; 90 degrees
0B1172 AF          0728*      xor a ; clear the carry flag
0B1173 ED 52       0729*      sbc hl,de ; subtract result from 90 degrees
0B1175             0730*      ; ld de,0 ; prep to clear hlu
0B1175             0731*      ; ld d,h
0B1175             0732*      ; ld e,l
0B1175             0733*      ; ex de,hl ; now we have 0 <= uh.l < 256 in 16.8 fixed format
0B1175             0734*      ; fall through
0B1175             0735*  @2:
0B1175             0736*  ; now the fun part of adjusting the result
0B1175             0737*  ; based on which quadrant (x,y) is in
0B1175             0738*  ; #E0 315      0       45 #20
0B1175             0739*  ;        -x,-y | +x,-y
0B1175             0740*  ; #C0 270------+------ 90 #40
0B1175             0741*  ;        -x,+y | +x,+y
0B1175             0742*  ; #A0 225   180 #80   135 #60
0B1175 F1          0743*      pop af ; sign of y
0B1176 CA B3 11 0B 0744*      jp z,@y_zero
0B117A F2 93 11 0B 0745*      jp p,@y_pos
0B117E             0746*  ; y neg,check x
0B117E F1          0747*      pop af ; sign of x
0B117F CA 8D 11 0B 0748*      jp z,@y_neg_x_zero
0B1183 F2 92 11 0B 0749*      jp p,@y_neg_x_pos
0B1187             0750*  ; y neg,x neg
0B1187             0751*  ; angle is 270-360
0B1187             0752*  ; negating the intermediate does the trick
0B1187 CD F0 18 0B 0753*      call neg_hlu
0B118B 18 31       0754*      jr @zero_hlu
0B118D             0755*  
0B118D             0756*  @y_neg_x_zero:
0B118D             0757*  ; y neg,x zero
0B118D             0758*  ; angle is 0
0B118D 21 00 00 00 0759*      ld hl,0
0B1191 C9          0760*      ret
0B1192             0761*  @y_neg_x_pos:
0B1192             0762*  ; y neg,x pos
0B1192             0763*  ; angle is 0 to 90
0B1192             0764*  ; so we're good
0B1192 C9          0765*      ret
0B1193             0766*  
0B1193             0767*  @y_pos:
0B1193 F1          0768*      pop af ; sign of x
0B1194 CA A3 11 0B 0769*      jp z,@y_pos_x_zero
0B1198 F2 A8 11 0B 0770*      jp p,@y_pos_x_pos
0B119C             0771*  ; y pos,x neg
0B119C             0772*  ; angle is 180-270
0B119C             0773*  ; so we add 180 to intermediate
0B119C 11 00 80 00 0774*      ld de,0x008000
0B11A0 19          0775*      add hl,de
0B11A1 18 1B       0776*      jr @zero_hlu
0B11A3             0777*  @y_pos_x_zero:
0B11A3             0778*  ; y pos,x zero
0B11A3             0779*  ; angle is 180
0B11A3 21 00 80 00 0780*      ld hl,0x008000
0B11A7 C9          0781*      ret
0B11A8             0782*  @y_pos_x_pos:
0B11A8             0783*  ; y pos,x pos
0B11A8             0784*  ; angle is 90-180
0B11A8             0785*  ; neg the intermediate and add 180 degrees
0B11A8 CD F0 18 0B 0786*      call neg_hlu
0B11AC 11 00 80 00 0787*      ld de,0x008000
0B11B0 19          0788*      add hl,de
0B11B1 18 0B       0789*      jr @zero_hlu
0B11B3             0790*  
0B11B3             0791*  @y_zero:
0B11B3 F1          0792*      pop af ; sign of x
0B11B4 FA B9 11 0B 0793*      jp m,@y_zero_x_neg
0B11B8             0794*  ; y zero,x pos
0B11B8             0795*  ; angle is 90,nothing to do
0B11B8 C9          0796*      ret
0B11B9             0797*  @y_zero_x_neg:
0B11B9             0798*  ; y zero ,x neg
0B11B9             0799*  ; angle is 270
0B11B9 21 00 C0 00 0800*      ld hl,0x00C000
0B11BD C9          0801*      ret
0B11BE             0802*  @zero_hlu:
0B11BE AF          0803*      xor a
0B11BF 22 CC 11 0B 0804*      ld (@scratch),hl
0B11C3 32 CE 11 0B 0805*      ld (@scratch+2),a
0B11C7 2A CC 11 0B 0806*      ld hl,(@scratch)
0B11CB C9          0807*      ret
0B11CC             0808*  @scratch: ds 6
0B11D2             0809*  
0B11D2             0810*  ; inputs: ub.c and ud.e are dx and dy in 16.8 fixed format
0B11D2             0811*  ; output: uh.l is the 16.8 fixed format angle
0B11D2             0812*  ; destroys: a,hl,bc,de
0B11D2             0813*  ; the following note was written by github copilot:
0B11D2             0814*  ; note: this routine is a bit of a hack
0B11D2             0815*  ;      but it works
0B11D2             0816*  ;      and it's fast
0B11D2             0817*  ;      and it's small
0B11D2             0818*  ;      and it's accurate
0B11D2             0819*  ;      and it's easy to understand
0B11D2             0820*  ;      and it's easy to modify
0B11D2             0821*  ;      and it's easy to use
0B11D2             0822*  ;      and it's easy to remember
0B11D2             0823*  ;      and it's easy to love
0B11D2             0824*  ;      and it's easy to hate
0B11D2             0825*  ;      and it's easy to ignore
0B11D2             0826*  ;      and it's easy to forget
0B11D2             0827*  ;      and it's easy to remember
0B11D2             0828*  ;      and it's easy to forget
0B11D2             0829*  ;      and it's easy to remember
0B11D2             0830*  ;      (ok the bot is stuck in a loop)
0B11D2             0831*  ; REAL NOTE: only works for angles from 0 to 45 degrees
0B11D2             0832*  ;   use atan2_168 (which calls this proc) to handle the full 360 degrees
0B11D2             0833*  atan_168game:
0B11D2             0834*  ; because we use compass headings instead of geometric angles
0B11D2             0835*  ; we compute dx/dy which is 1/tan(theta) in the maths world
0B11D2             0836*  ; we can do faster unsigned division here because we know dx and dy are positive
0B11D2 CD 3A 0F 0B 0837*  	call udiv168 ; uh.l = dx/dy
0B11D6             0838*  ; ; TODO: IMPLEMENT THIS, RIGHT NOW IS IS BUGGED
0B11D6             0839*  ; ; test uh.l for 0
0B11D6             0840*  ;     add hl,de
0B11D6             0841*  ;     or a
0B11D6             0842*  ;     sbc hl,de
0B11D6             0843*  ;     jr z,@is_zero
0B11D6             0844*  ; ; test uh.l for 1
0B11D6             0845*  ;     xor a ; clear carry
0B11D6             0846*  ;     ex de,hl
0B11D6             0847*  ;     ld hl,0x000100 ; 1 in 16.8 fixed format
0B11D6             0848*  ;     sbc hl,de
0B11D6             0849*  ;     jr z,@is_45
0B11D6             0850*  ; ; END TODO
0B11D6             0851*  
0B11D6             0852*  ; no special cases so we move on
0B11D6             0853*  ; l contains the fractional portion of tan(uh.l)
0B11D6             0854*  ; we multiply it by three to get our lookup table index
0B11D6 26 03       0855*      ld h,3
0B11D8 ED 6C       0856*      mlt hl ; gosh that is handy
0B11DA 11 00 00 00 0857*      ld de,0 ; clear deu
0B11DE 54          0858*      ld d,h ; copy hl to de
0B11DF 5D          0859*      ld e,l ; de contains our index
0B11E0 21 DD 15 0B 0860*      ld hl,atan_lut_168 ; grab the lut address
0B11E4 19          0861*      add hl,de ; bump hl by the index
0B11E5 ED 27       0862*      ld hl,(hl) ; don't try this on a z80!
0B11E7 C9          0863*      ret ; and out
0B11E8             0864*  @is_45:
0B11E8 21 00 20 00 0865*      ld hl,0x002000 ; 45 degrees decimal
0B11EC C9          0866*      ret
0B11ED             0867*  ; for the case tan(0)
0B11ED             0868*  @is_zero:
0B11ED 21 00 00 00 0869*      ld hl,0x000000
0B11F1 C9          0870*      ret
0B11F2             0871*  
0B11F2             0872*  ; Expects  ADL mode
0B11F2             0873*  ; Inputs:  UH.L
0B11F2             0874*  ; Outputs: UH.L is the 16.8 square root
0B11F2             0875*  ;          UD.E is the difference inputHL-DE^2
0B11F2             0876*  ;          c flag reset
0B11F2             0877*  sqrt168:
0B11F2 CD FC 11 0B 0878*      call sqrt24
0B11F6 EB          0879*      ex de,hl
0B11F7 29          0880*      add hl,hl
0B11F8 29          0881*      add hl,hl
0B11F9 29          0882*      add hl,hl
0B11FA 29          0883*      add hl,hl
0B11FB C9          0884*      ret
0B11FC             0885*  
0B11FC             0886*  ; Expects  ADL mode
0B11FC             0887*  ; Inputs:  HL
0B11FC             0888*  ; Outputs: DE is the integer square root
0B11FC             0889*  ;          HL is the difference inputHL-DE^2
0B11FC             0890*  ;          c flag reset
0B11FC             0891*  sqrt24:
0B11FC AF          0892*      xor a
0B11FD 45          0893*      ld b,l
0B11FE C5          0894*      push bc
0B11FF 47          0895*      ld b,a
0B1200 57          0896*      ld d,a
0B1201 4F          0897*      ld c,a
0B1202 6F          0898*      ld l,a
0B1203 5F          0899*      ld e,a
0B1204             0900*  
0B1204             0901*      ;Iteration 1
0B1204 29          0902*      add hl,hl
0B1205 CB 11       0903*      rl c
0B1207 29          0904*      add hl,hl
0B1208 CB 11       0905*      rl c
0B120A 91          0906*      sub c
0B120B 30 04       0907*      jr nc,$+6
0B120D 1C          0908*      inc e
0B120E 1C          0909*      inc e
0B120F 2F          0910*      cpl
0B1210 4F          0911*      ld c,a
0B1211             0912*  
0B1211             0913*      ;Iteration 2
0B1211 29          0914*      add hl,hl
0B1212 CB 11       0915*      rl c
0B1214 29          0916*      add hl,hl
0B1215 CB 11       0917*      rl c
0B1217 CB 13       0918*      rl e
0B1219 7B          0919*      ld a,e
0B121A 91          0920*      sub c
0B121B 30 04       0921*      jr nc,$+6
0B121D 1C          0922*      inc e
0B121E 1C          0923*      inc e
0B121F 2F          0924*      cpl
0B1220 4F          0925*      ld c,a
0B1221             0926*  
0B1221             0927*      ;Iteration 3
0B1221 29          0928*      add hl,hl
0B1222 CB 11       0929*      rl c
0B1224 29          0930*      add hl,hl
0B1225 CB 11       0931*      rl c
0B1227 CB 13       0932*      rl e
0B1229 7B          0933*      ld a,e
0B122A 91          0934*      sub c
0B122B 30 04       0935*      jr nc,$+6
0B122D 1C          0936*      inc e
0B122E 1C          0937*      inc e
0B122F 2F          0938*      cpl
0B1230 4F          0939*      ld c,a
0B1231             0940*  
0B1231             0941*      ;Iteration 4
0B1231 29          0942*      add hl,hl
0B1232 CB 11       0943*      rl c
0B1234 29          0944*      add hl,hl
0B1235 CB 11       0945*      rl c
0B1237 CB 13       0946*      rl e
0B1239 7B          0947*      ld a,e
0B123A 91          0948*      sub c
0B123B 30 04       0949*      jr nc,$+6
0B123D 1C          0950*      inc e
0B123E 1C          0951*      inc e
0B123F 2F          0952*      cpl
0B1240 4F          0953*      ld c,a
0B1241             0954*  
0B1241             0955*      ;Iteration 5
0B1241 29          0956*      add hl,hl
0B1242 CB 11       0957*      rl c
0B1244 29          0958*      add hl,hl
0B1245 CB 11       0959*      rl c
0B1247 CB 13       0960*      rl e
0B1249 7B          0961*      ld a,e
0B124A 91          0962*      sub c
0B124B 30 04       0963*      jr nc,$+6
0B124D 1C          0964*      inc e
0B124E 1C          0965*      inc e
0B124F 2F          0966*      cpl
0B1250 4F          0967*      ld c,a
0B1251             0968*  
0B1251             0969*      ;Iteration 6
0B1251 29          0970*      add hl,hl
0B1252 CB 11       0971*      rl c
0B1254 29          0972*      add hl,hl
0B1255 CB 11       0973*      rl c
0B1257 CB 13       0974*      rl e
0B1259 7B          0975*      ld a,e
0B125A 91          0976*      sub c
0B125B 30 04       0977*      jr nc,$+6
0B125D 1C          0978*      inc e
0B125E 1C          0979*      inc e
0B125F 2F          0980*      cpl
0B1260 4F          0981*      ld c,a
0B1261             0982*  
0B1261             0983*      ;Iteration 7
0B1261 29          0984*      add hl,hl
0B1262 CB 11       0985*      rl c
0B1264 29          0986*      add hl,hl
0B1265 CB 11       0987*      rl c
0B1267 CB 10       0988*      rl b
0B1269 EB          0989*      ex de,hl
0B126A 29          0990*      add hl,hl
0B126B E5          0991*      push hl
0B126C ED 42       0992*      sbc hl,bc
0B126E 30 06       0993*      jr nc,$+8
0B1270 7C          0994*      ld a,h
0B1271 2F          0995*      cpl
0B1272 47          0996*      ld b,a
0B1273 7D          0997*      ld a,l
0B1274 2F          0998*      cpl
0B1275 4F          0999*      ld c,a
0B1276 E1          1000*      pop hl
0B1277 30 02       1001*      jr nc,$+4
0B1279 23          1002*      inc hl
0B127A 23          1003*      inc hl
0B127B EB          1004*      ex de,hl
0B127C             1005*  
0B127C             1006*      ;Iteration 8
0B127C 29          1007*      add hl,hl
0B127D 69          1008*      ld l,c
0B127E 60          1009*      ld h,b
0B127F ED 6A       1010*      adc hl,hl
0B1281 ED 6A       1011*      adc hl,hl
0B1283 EB          1012*      ex de,hl
0B1284 29          1013*      add hl,hl
0B1285 ED 52       1014*      sbc hl,de
0B1287 19          1015*      add hl,de
0B1288 EB          1016*      ex de,hl
0B1289 30 04       1017*      jr nc,$+6
0B128B ED 52       1018*      sbc hl,de
0B128D 13          1019*      inc de
0B128E 13          1020*      inc de
0B128F             1021*  
0B128F             1022*      ;Iteration 9
0B128F F1          1023*      pop af
0B1290 17          1024*      rla
0B1291 ED 6A       1025*      adc hl,hl
0B1293 17          1026*      rla
0B1294 ED 6A       1027*      adc hl,hl
0B1296 EB          1028*      ex de,hl
0B1297 29          1029*      add hl,hl
0B1298 ED 52       1030*      sbc hl,de
0B129A 19          1031*      add hl,de
0B129B EB          1032*      ex de,hl
0B129C 30 04       1033*      jr nc,$+6
0B129E ED 52       1034*      sbc hl,de
0B12A0 13          1035*      inc de
0B12A1 13          1036*      inc de
0B12A2             1037*  
0B12A2             1038*      ;Iteration 10
0B12A2 17          1039*      rla
0B12A3 ED 6A       1040*      adc hl,hl
0B12A5 17          1041*      rla
0B12A6 ED 6A       1042*      adc hl,hl
0B12A8 EB          1043*      ex de,hl
0B12A9 29          1044*      add hl,hl
0B12AA ED 52       1045*      sbc hl,de
0B12AC 19          1046*      add hl,de
0B12AD EB          1047*      ex de,hl
0B12AE 30 04       1048*      jr nc,$+6
0B12B0 ED 52       1049*      sbc hl,de
0B12B2 13          1050*      inc de
0B12B3 13          1051*      inc de
0B12B4             1052*  
0B12B4             1053*      ;Iteration 11
0B12B4 17          1054*      rla
0B12B5 ED 6A       1055*      adc hl,hl
0B12B7 17          1056*      rla
0B12B8 ED 6A       1057*      adc hl,hl
0B12BA EB          1058*      ex de,hl
0B12BB 29          1059*      add hl,hl
0B12BC ED 52       1060*      sbc hl,de
0B12BE 19          1061*      add hl,de
0B12BF EB          1062*      ex de,hl
0B12C0 30 04       1063*      jr nc,$+6
0B12C2 ED 52       1064*      sbc hl,de
0B12C4 13          1065*      inc de
0B12C5 13          1066*      inc de
0B12C6             1067*  
0B12C6             1068*      ;Iteration 11
0B12C6 17          1069*      rla
0B12C7 ED 6A       1070*      adc hl,hl
0B12C9 17          1071*      rla
0B12CA ED 6A       1072*      adc hl,hl
0B12CC EB          1073*      ex de,hl
0B12CD 29          1074*      add hl,hl
0B12CE ED 52       1075*      sbc hl,de
0B12D0 19          1076*      add hl,de
0B12D1 EB          1077*      ex de,hl
0B12D2 30 04       1078*      jr nc,$+6
0B12D4 ED 52       1079*      sbc hl,de
0B12D6 13          1080*      inc de
0B12D7 13          1081*      inc de
0B12D8             1082*  
0B12D8 CB 1A       1083*      rr d
0B12DA CB 1B       1084*      rr e
0B12DC C9          1085*      ret
0B12DD             1086*  
0B12DD             1087*  sin_lut_168:
0B12DD 00 00 00    1088*  	dl 0x000000 ; 0.000 00, 0.000
0B12E0 06 00 00    1089*  	dl 0x000006 ; 1.406 01, 0.025
0B12E3 0C 00 00    1090*  	dl 0x00000C ; 2.813 02, 0.049
0B12E6 12 00 00    1091*  	dl 0x000012 ; 4.219 03, 0.074
0B12E9 19 00 00    1092*  	dl 0x000019 ; 5.625 04, 0.098
0B12EC 1F 00 00    1093*  	dl 0x00001F ; 7.031 05, 0.122
0B12EF 25 00 00    1094*  	dl 0x000025 ; 8.438 06, 0.147
0B12F2 2B 00 00    1095*  	dl 0x00002B ; 9.844 07, 0.171
0B12F5 31 00 00    1096*  	dl 0x000031 ; 11.250 08, 0.195
0B12F8 38 00 00    1097*  	dl 0x000038 ; 12.656 09, 0.219
0B12FB 3E 00 00    1098*  	dl 0x00003E ; 14.063 0A, 0.243
0B12FE 44 00 00    1099*  	dl 0x000044 ; 15.469 0B, 0.267
0B1301 4A 00 00    1100*  	dl 0x00004A ; 16.875 0C, 0.290
0B1304 50 00 00    1101*  	dl 0x000050 ; 18.281 0D, 0.314
0B1307 56 00 00    1102*  	dl 0x000056 ; 19.688 0E, 0.337
0B130A 5C 00 00    1103*  	dl 0x00005C ; 21.094 0F, 0.360
0B130D 61 00 00    1104*  	dl 0x000061 ; 22.500 10, 0.383
0B1310 67 00 00    1105*  	dl 0x000067 ; 23.906 11, 0.405
0B1313 6D 00 00    1106*  	dl 0x00006D ; 25.313 12, 0.428
0B1316 73 00 00    1107*  	dl 0x000073 ; 26.719 13, 0.450
0B1319 78 00 00    1108*  	dl 0x000078 ; 28.125 14, 0.471
0B131C 7E 00 00    1109*  	dl 0x00007E ; 29.531 15, 0.493
0B131F 83 00 00    1110*  	dl 0x000083 ; 30.938 16, 0.514
0B1322 88 00 00    1111*  	dl 0x000088 ; 32.344 17, 0.535
0B1325 8E 00 00    1112*  	dl 0x00008E ; 33.750 18, 0.556
0B1328 93 00 00    1113*  	dl 0x000093 ; 35.156 19, 0.576
0B132B 98 00 00    1114*  	dl 0x000098 ; 36.563 1A, 0.596
0B132E 9D 00 00    1115*  	dl 0x00009D ; 37.969 1B, 0.615
0B1331 A2 00 00    1116*  	dl 0x0000A2 ; 39.375 1C, 0.634
0B1334 A7 00 00    1117*  	dl 0x0000A7 ; 40.781 1D, 0.653
0B1337 AB 00 00    1118*  	dl 0x0000AB ; 42.188 1E, 0.672
0B133A B0 00 00    1119*  	dl 0x0000B0 ; 43.594 1F, 0.690
0B133D B5 00 00    1120*  	dl 0x0000B5 ; 45.000 20, 0.707
0B1340 B9 00 00    1121*  	dl 0x0000B9 ; 46.406 21, 0.724
0B1343 BD 00 00    1122*  	dl 0x0000BD ; 47.813 22, 0.741
0B1346 C1 00 00    1123*  	dl 0x0000C1 ; 49.219 23, 0.757
0B1349 C5 00 00    1124*  	dl 0x0000C5 ; 50.625 24, 0.773
0B134C C9 00 00    1125*  	dl 0x0000C9 ; 52.031 25, 0.788
0B134F CD 00 00    1126*  	dl 0x0000CD ; 53.438 26, 0.803
0B1352 D1 00 00    1127*  	dl 0x0000D1 ; 54.844 27, 0.818
0B1355 D4 00 00    1128*  	dl 0x0000D4 ; 56.250 28, 0.831
0B1358 D8 00 00    1129*  	dl 0x0000D8 ; 57.656 29, 0.845
0B135B DB 00 00    1130*  	dl 0x0000DB ; 59.063 2A, 0.858
0B135E DE 00 00    1131*  	dl 0x0000DE ; 60.469 2B, 0.870
0B1361 E1 00 00    1132*  	dl 0x0000E1 ; 61.875 2C, 0.882
0B1364 E4 00 00    1133*  	dl 0x0000E4 ; 63.281 2D, 0.893
0B1367 E7 00 00    1134*  	dl 0x0000E7 ; 64.688 2E, 0.904
0B136A EA 00 00    1135*  	dl 0x0000EA ; 66.094 2F, 0.914
0B136D EC 00 00    1136*  	dl 0x0000EC ; 67.500 30, 0.924
0B1370 EE 00 00    1137*  	dl 0x0000EE ; 68.906 31, 0.933
0B1373 F1 00 00    1138*  	dl 0x0000F1 ; 70.313 32, 0.942
0B1376 F3 00 00    1139*  	dl 0x0000F3 ; 71.719 33, 0.950
0B1379 F4 00 00    1140*  	dl 0x0000F4 ; 73.125 34, 0.957
0B137C F6 00 00    1141*  	dl 0x0000F6 ; 74.531 35, 0.964
0B137F F8 00 00    1142*  	dl 0x0000F8 ; 75.938 36, 0.970
0B1382 F9 00 00    1143*  	dl 0x0000F9 ; 77.344 37, 0.976
0B1385 FB 00 00    1144*  	dl 0x0000FB ; 78.750 38, 0.981
0B1388 FC 00 00    1145*  	dl 0x0000FC ; 80.156 39, 0.985
0B138B FD 00 00    1146*  	dl 0x0000FD ; 81.563 3A, 0.989
0B138E FE 00 00    1147*  	dl 0x0000FE ; 82.969 3B, 0.992
0B1391 FE 00 00    1148*  	dl 0x0000FE ; 84.375 3C, 0.995
0B1394 FF 00 00    1149*  	dl 0x0000FF ; 85.781 3D, 0.997
0B1397 FF 00 00    1150*  	dl 0x0000FF ; 87.188 3E, 0.999
0B139A FF 00 00    1151*  	dl 0x0000FF ; 88.594 3F, 1.000
0B139D 00 01 00    1152*  	dl 0x000100 ; 90.000 40, 1.000
0B13A0 FF 00 00    1153*  	dl 0x0000FF ; 91.406 41, 1.000
0B13A3 FF 00 00    1154*  	dl 0x0000FF ; 92.813 42, 0.999
0B13A6 FF 00 00    1155*  	dl 0x0000FF ; 94.219 43, 0.997
0B13A9 FE 00 00    1156*  	dl 0x0000FE ; 95.625 44, 0.995
0B13AC FE 00 00    1157*  	dl 0x0000FE ; 97.031 45, 0.992
0B13AF FD 00 00    1158*  	dl 0x0000FD ; 98.438 46, 0.989
0B13B2 FC 00 00    1159*  	dl 0x0000FC ; 99.844 47, 0.985
0B13B5 FB 00 00    1160*  	dl 0x0000FB ; 101.250 48, 0.981
0B13B8 F9 00 00    1161*  	dl 0x0000F9 ; 102.656 49, 0.976
0B13BB F8 00 00    1162*  	dl 0x0000F8 ; 104.063 4A, 0.970
0B13BE F6 00 00    1163*  	dl 0x0000F6 ; 105.469 4B, 0.964
0B13C1 F4 00 00    1164*  	dl 0x0000F4 ; 106.875 4C, 0.957
0B13C4 F3 00 00    1165*  	dl 0x0000F3 ; 108.281 4D, 0.950
0B13C7 F1 00 00    1166*  	dl 0x0000F1 ; 109.688 4E, 0.942
0B13CA EE 00 00    1167*  	dl 0x0000EE ; 111.094 4F, 0.933
0B13CD EC 00 00    1168*  	dl 0x0000EC ; 112.500 50, 0.924
0B13D0 EA 00 00    1169*  	dl 0x0000EA ; 113.906 51, 0.914
0B13D3 E7 00 00    1170*  	dl 0x0000E7 ; 115.313 52, 0.904
0B13D6 E4 00 00    1171*  	dl 0x0000E4 ; 116.719 53, 0.893
0B13D9 E1 00 00    1172*  	dl 0x0000E1 ; 118.125 54, 0.882
0B13DC DE 00 00    1173*  	dl 0x0000DE ; 119.531 55, 0.870
0B13DF DB 00 00    1174*  	dl 0x0000DB ; 120.938 56, 0.858
0B13E2 D8 00 00    1175*  	dl 0x0000D8 ; 122.344 57, 0.845
0B13E5 D4 00 00    1176*  	dl 0x0000D4 ; 123.750 58, 0.831
0B13E8 D1 00 00    1177*  	dl 0x0000D1 ; 125.156 59, 0.818
0B13EB CD 00 00    1178*  	dl 0x0000CD ; 126.563 5A, 0.803
0B13EE C9 00 00    1179*  	dl 0x0000C9 ; 127.969 5B, 0.788
0B13F1 C5 00 00    1180*  	dl 0x0000C5 ; 129.375 5C, 0.773
0B13F4 C1 00 00    1181*  	dl 0x0000C1 ; 130.781 5D, 0.757
0B13F7 BD 00 00    1182*  	dl 0x0000BD ; 132.188 5E, 0.741
0B13FA B9 00 00    1183*  	dl 0x0000B9 ; 133.594 5F, 0.724
0B13FD B5 00 00    1184*  	dl 0x0000B5 ; 135.000 60, 0.707
0B1400 B0 00 00    1185*  	dl 0x0000B0 ; 136.406 61, 0.690
0B1403 AB 00 00    1186*  	dl 0x0000AB ; 137.813 62, 0.672
0B1406 A7 00 00    1187*  	dl 0x0000A7 ; 139.219 63, 0.653
0B1409 A2 00 00    1188*  	dl 0x0000A2 ; 140.625 64, 0.634
0B140C 9D 00 00    1189*  	dl 0x00009D ; 142.031 65, 0.615
0B140F 98 00 00    1190*  	dl 0x000098 ; 143.438 66, 0.596
0B1412 93 00 00    1191*  	dl 0x000093 ; 144.844 67, 0.576
0B1415 8E 00 00    1192*  	dl 0x00008E ; 146.250 68, 0.556
0B1418 88 00 00    1193*  	dl 0x000088 ; 147.656 69, 0.535
0B141B 83 00 00    1194*  	dl 0x000083 ; 149.063 6A, 0.514
0B141E 7E 00 00    1195*  	dl 0x00007E ; 150.469 6B, 0.493
0B1421 78 00 00    1196*  	dl 0x000078 ; 151.875 6C, 0.471
0B1424 73 00 00    1197*  	dl 0x000073 ; 153.281 6D, 0.450
0B1427 6D 00 00    1198*  	dl 0x00006D ; 154.688 6E, 0.428
0B142A 67 00 00    1199*  	dl 0x000067 ; 156.094 6F, 0.405
0B142D 61 00 00    1200*  	dl 0x000061 ; 157.500 70, 0.383
0B1430 5C 00 00    1201*  	dl 0x00005C ; 158.906 71, 0.360
0B1433 56 00 00    1202*  	dl 0x000056 ; 160.313 72, 0.337
0B1436 50 00 00    1203*  	dl 0x000050 ; 161.719 73, 0.314
0B1439 4A 00 00    1204*  	dl 0x00004A ; 163.125 74, 0.290
0B143C 44 00 00    1205*  	dl 0x000044 ; 164.531 75, 0.267
0B143F 3E 00 00    1206*  	dl 0x00003E ; 165.938 76, 0.243
0B1442 38 00 00    1207*  	dl 0x000038 ; 167.344 77, 0.219
0B1445 31 00 00    1208*  	dl 0x000031 ; 168.750 78, 0.195
0B1448 2B 00 00    1209*  	dl 0x00002B ; 170.156 79, 0.171
0B144B 25 00 00    1210*  	dl 0x000025 ; 171.563 7A, 0.147
0B144E 1F 00 00    1211*  	dl 0x00001F ; 172.969 7B, 0.122
0B1451 19 00 00    1212*  	dl 0x000019 ; 174.375 7C, 0.098
0B1454 12 00 00    1213*  	dl 0x000012 ; 175.781 7D, 0.074
0B1457 0C 00 00    1214*  	dl 0x00000C ; 177.188 7E, 0.049
0B145A 06 00 00    1215*  	dl 0x000006 ; 178.594 7F, 0.025
0B145D 00 00 00    1216*  	dl 0x000000 ; 180.000 80, 0.000
0B1460 FA FF FF    1217*  	dl 0xFFFFFA ; 181.406 81, -0.025
0B1463 F4 FF FF    1218*  	dl 0xFFFFF4 ; 182.813 82, -0.049
0B1466 EE FF FF    1219*  	dl 0xFFFFEE ; 184.219 83, -0.074
0B1469 E7 FF FF    1220*  	dl 0xFFFFE7 ; 185.625 84, -0.098
0B146C E1 FF FF    1221*  	dl 0xFFFFE1 ; 187.031 85, -0.122
0B146F DB FF FF    1222*  	dl 0xFFFFDB ; 188.438 86, -0.147
0B1472 D5 FF FF    1223*  	dl 0xFFFFD5 ; 189.844 87, -0.171
0B1475 CF FF FF    1224*  	dl 0xFFFFCF ; 191.250 88, -0.195
0B1478 C8 FF FF    1225*  	dl 0xFFFFC8 ; 192.656 89, -0.219
0B147B C2 FF FF    1226*  	dl 0xFFFFC2 ; 194.063 8A, -0.243
0B147E BC FF FF    1227*  	dl 0xFFFFBC ; 195.469 8B, -0.267
0B1481 B6 FF FF    1228*  	dl 0xFFFFB6 ; 196.875 8C, -0.290
0B1484 B0 FF FF    1229*  	dl 0xFFFFB0 ; 198.281 8D, -0.314
0B1487 AA FF FF    1230*  	dl 0xFFFFAA ; 199.688 8E, -0.337
0B148A A4 FF FF    1231*  	dl 0xFFFFA4 ; 201.094 8F, -0.360
0B148D 9F FF FF    1232*  	dl 0xFFFF9F ; 202.500 90, -0.383
0B1490 99 FF FF    1233*  	dl 0xFFFF99 ; 203.906 91, -0.405
0B1493 93 FF FF    1234*  	dl 0xFFFF93 ; 205.313 92, -0.428
0B1496 8D FF FF    1235*  	dl 0xFFFF8D ; 206.719 93, -0.450
0B1499 88 FF FF    1236*  	dl 0xFFFF88 ; 208.125 94, -0.471
0B149C 82 FF FF    1237*  	dl 0xFFFF82 ; 209.531 95, -0.493
0B149F 7D FF FF    1238*  	dl 0xFFFF7D ; 210.938 96, -0.514
0B14A2 78 FF FF    1239*  	dl 0xFFFF78 ; 212.344 97, -0.535
0B14A5 72 FF FF    1240*  	dl 0xFFFF72 ; 213.750 98, -0.556
0B14A8 6D FF FF    1241*  	dl 0xFFFF6D ; 215.156 99, -0.576
0B14AB 68 FF FF    1242*  	dl 0xFFFF68 ; 216.563 9A, -0.596
0B14AE 63 FF FF    1243*  	dl 0xFFFF63 ; 217.969 9B, -0.615
0B14B1 5E FF FF    1244*  	dl 0xFFFF5E ; 219.375 9C, -0.634
0B14B4 59 FF FF    1245*  	dl 0xFFFF59 ; 220.781 9D, -0.653
0B14B7 55 FF FF    1246*  	dl 0xFFFF55 ; 222.188 9E, -0.672
0B14BA 50 FF FF    1247*  	dl 0xFFFF50 ; 223.594 9F, -0.690
0B14BD 4B FF FF    1248*  	dl 0xFFFF4B ; 225.000 A0, -0.707
0B14C0 47 FF FF    1249*  	dl 0xFFFF47 ; 226.406 A1, -0.724
0B14C3 43 FF FF    1250*  	dl 0xFFFF43 ; 227.813 A2, -0.741
0B14C6 3F FF FF    1251*  	dl 0xFFFF3F ; 229.219 A3, -0.757
0B14C9 3B FF FF    1252*  	dl 0xFFFF3B ; 230.625 A4, -0.773
0B14CC 37 FF FF    1253*  	dl 0xFFFF37 ; 232.031 A5, -0.788
0B14CF 33 FF FF    1254*  	dl 0xFFFF33 ; 233.438 A6, -0.803
0B14D2 2F FF FF    1255*  	dl 0xFFFF2F ; 234.844 A7, -0.818
0B14D5 2C FF FF    1256*  	dl 0xFFFF2C ; 236.250 A8, -0.831
0B14D8 28 FF FF    1257*  	dl 0xFFFF28 ; 237.656 A9, -0.845
0B14DB 25 FF FF    1258*  	dl 0xFFFF25 ; 239.063 AA, -0.858
0B14DE 22 FF FF    1259*  	dl 0xFFFF22 ; 240.469 AB, -0.870
0B14E1 1F FF FF    1260*  	dl 0xFFFF1F ; 241.875 AC, -0.882
0B14E4 1C FF FF    1261*  	dl 0xFFFF1C ; 243.281 AD, -0.893
0B14E7 19 FF FF    1262*  	dl 0xFFFF19 ; 244.688 AE, -0.904
0B14EA 16 FF FF    1263*  	dl 0xFFFF16 ; 246.094 AF, -0.914
0B14ED 14 FF FF    1264*  	dl 0xFFFF14 ; 247.500 B0, -0.924
0B14F0 12 FF FF    1265*  	dl 0xFFFF12 ; 248.906 B1, -0.933
0B14F3 0F FF FF    1266*  	dl 0xFFFF0F ; 250.313 B2, -0.942
0B14F6 0D FF FF    1267*  	dl 0xFFFF0D ; 251.719 B3, -0.950
0B14F9 0C FF FF    1268*  	dl 0xFFFF0C ; 253.125 B4, -0.957
0B14FC 0A FF FF    1269*  	dl 0xFFFF0A ; 254.531 B5, -0.964
0B14FF 08 FF FF    1270*  	dl 0xFFFF08 ; 255.938 B6, -0.970
0B1502 07 FF FF    1271*  	dl 0xFFFF07 ; 257.344 B7, -0.976
0B1505 05 FF FF    1272*  	dl 0xFFFF05 ; 258.750 B8, -0.981
0B1508 04 FF FF    1273*  	dl 0xFFFF04 ; 260.156 B9, -0.985
0B150B 03 FF FF    1274*  	dl 0xFFFF03 ; 261.563 BA, -0.989
0B150E 02 FF FF    1275*  	dl 0xFFFF02 ; 262.969 BB, -0.992
0B1511 02 FF FF    1276*  	dl 0xFFFF02 ; 264.375 BC, -0.995
0B1514 01 FF FF    1277*  	dl 0xFFFF01 ; 265.781 BD, -0.997
0B1517 01 FF FF    1278*  	dl 0xFFFF01 ; 267.188 BE, -0.999
0B151A 01 FF FF    1279*  	dl 0xFFFF01 ; 268.594 BF, -1.000
0B151D 00 FF FF    1280*  	dl 0xFFFF00 ; 270.000 C0, -1.000
0B1520 01 FF FF    1281*  	dl 0xFFFF01 ; 271.406 C1, -1.000
0B1523 01 FF FF    1282*  	dl 0xFFFF01 ; 272.813 C2, -0.999
0B1526 01 FF FF    1283*  	dl 0xFFFF01 ; 274.219 C3, -0.997
0B1529 02 FF FF    1284*  	dl 0xFFFF02 ; 275.625 C4, -0.995
0B152C 02 FF FF    1285*  	dl 0xFFFF02 ; 277.031 C5, -0.992
0B152F 03 FF FF    1286*  	dl 0xFFFF03 ; 278.438 C6, -0.989
0B1532 04 FF FF    1287*  	dl 0xFFFF04 ; 279.844 C7, -0.985
0B1535 05 FF FF    1288*  	dl 0xFFFF05 ; 281.250 C8, -0.981
0B1538 07 FF FF    1289*  	dl 0xFFFF07 ; 282.656 C9, -0.976
0B153B 08 FF FF    1290*  	dl 0xFFFF08 ; 284.063 CA, -0.970
0B153E 0A FF FF    1291*  	dl 0xFFFF0A ; 285.469 CB, -0.964
0B1541 0C FF FF    1292*  	dl 0xFFFF0C ; 286.875 CC, -0.957
0B1544 0D FF FF    1293*  	dl 0xFFFF0D ; 288.281 CD, -0.950
0B1547 0F FF FF    1294*  	dl 0xFFFF0F ; 289.688 CE, -0.942
0B154A 12 FF FF    1295*  	dl 0xFFFF12 ; 291.094 CF, -0.933
0B154D 14 FF FF    1296*  	dl 0xFFFF14 ; 292.500 D0, -0.924
0B1550 16 FF FF    1297*  	dl 0xFFFF16 ; 293.906 D1, -0.914
0B1553 19 FF FF    1298*  	dl 0xFFFF19 ; 295.313 D2, -0.904
0B1556 1C FF FF    1299*  	dl 0xFFFF1C ; 296.719 D3, -0.893
0B1559 1F FF FF    1300*  	dl 0xFFFF1F ; 298.125 D4, -0.882
0B155C 22 FF FF    1301*  	dl 0xFFFF22 ; 299.531 D5, -0.870
0B155F 25 FF FF    1302*  	dl 0xFFFF25 ; 300.938 D6, -0.858
0B1562 28 FF FF    1303*  	dl 0xFFFF28 ; 302.344 D7, -0.845
0B1565 2C FF FF    1304*  	dl 0xFFFF2C ; 303.750 D8, -0.831
0B1568 2F FF FF    1305*  	dl 0xFFFF2F ; 305.156 D9, -0.818
0B156B 33 FF FF    1306*  	dl 0xFFFF33 ; 306.563 DA, -0.803
0B156E 37 FF FF    1307*  	dl 0xFFFF37 ; 307.969 DB, -0.788
0B1571 3B FF FF    1308*  	dl 0xFFFF3B ; 309.375 DC, -0.773
0B1574 3F FF FF    1309*  	dl 0xFFFF3F ; 310.781 DD, -0.757
0B1577 43 FF FF    1310*  	dl 0xFFFF43 ; 312.188 DE, -0.741
0B157A 47 FF FF    1311*  	dl 0xFFFF47 ; 313.594 DF, -0.724
0B157D 4B FF FF    1312*  	dl 0xFFFF4B ; 315.000 E0, -0.707
0B1580 50 FF FF    1313*  	dl 0xFFFF50 ; 316.406 E1, -0.690
0B1583 55 FF FF    1314*  	dl 0xFFFF55 ; 317.813 E2, -0.672
0B1586 59 FF FF    1315*  	dl 0xFFFF59 ; 319.219 E3, -0.653
0B1589 5E FF FF    1316*  	dl 0xFFFF5E ; 320.625 E4, -0.634
0B158C 63 FF FF    1317*  	dl 0xFFFF63 ; 322.031 E5, -0.615
0B158F 68 FF FF    1318*  	dl 0xFFFF68 ; 323.438 E6, -0.596
0B1592 6D FF FF    1319*  	dl 0xFFFF6D ; 324.844 E7, -0.576
0B1595 72 FF FF    1320*  	dl 0xFFFF72 ; 326.250 E8, -0.556
0B1598 78 FF FF    1321*  	dl 0xFFFF78 ; 327.656 E9, -0.535
0B159B 7D FF FF    1322*  	dl 0xFFFF7D ; 329.063 EA, -0.514
0B159E 82 FF FF    1323*  	dl 0xFFFF82 ; 330.469 EB, -0.493
0B15A1 88 FF FF    1324*  	dl 0xFFFF88 ; 331.875 EC, -0.471
0B15A4 8D FF FF    1325*  	dl 0xFFFF8D ; 333.281 ED, -0.450
0B15A7 93 FF FF    1326*  	dl 0xFFFF93 ; 334.688 EE, -0.428
0B15AA 99 FF FF    1327*  	dl 0xFFFF99 ; 336.094 EF, -0.405
0B15AD 9F FF FF    1328*  	dl 0xFFFF9F ; 337.500 F0, -0.383
0B15B0 A4 FF FF    1329*  	dl 0xFFFFA4 ; 338.906 F1, -0.360
0B15B3 AA FF FF    1330*  	dl 0xFFFFAA ; 340.313 F2, -0.337
0B15B6 B0 FF FF    1331*  	dl 0xFFFFB0 ; 341.719 F3, -0.314
0B15B9 B6 FF FF    1332*  	dl 0xFFFFB6 ; 343.125 F4, -0.290
0B15BC BC FF FF    1333*  	dl 0xFFFFBC ; 344.531 F5, -0.267
0B15BF C2 FF FF    1334*  	dl 0xFFFFC2 ; 345.938 F6, -0.243
0B15C2 C8 FF FF    1335*  	dl 0xFFFFC8 ; 347.344 F7, -0.219
0B15C5 CF FF FF    1336*  	dl 0xFFFFCF ; 348.750 F8, -0.195
0B15C8 D5 FF FF    1337*  	dl 0xFFFFD5 ; 350.156 F9, -0.171
0B15CB DB FF FF    1338*  	dl 0xFFFFDB ; 351.563 FA, -0.147
0B15CE E1 FF FF    1339*  	dl 0xFFFFE1 ; 352.969 FB, -0.122
0B15D1 E7 FF FF    1340*  	dl 0xFFFFE7 ; 354.375 FC, -0.098
0B15D4 EE FF FF    1341*  	dl 0xFFFFEE ; 355.781 FD, -0.074
0B15D7 F4 FF FF    1342*  	dl 0xFFFFF4 ; 357.188 FE, -0.049
0B15DA FA FF FF    1343*  	dl 0xFFFFFA ; 358.594 FF, -0.025
0B15DD             1344*  
0B15DD             1345*  atan_lut_168:
0B15DD 00 00 00    1346*  	dl 0x000000 ; 000000, 0.000
0B15E0 28 00 00    1347*  	dl 0x000028 ; 000001, 0.224
0B15E3 51 00 00    1348*  	dl 0x000051 ; 000002, 0.448
0B15E6 7A 00 00    1349*  	dl 0x00007A ; 000003, 0.671
0B15E9 A2 00 00    1350*  	dl 0x0000A2 ; 000004, 0.895
0B15EC CB 00 00    1351*  	dl 0x0000CB ; 000005, 1.119
0B15EF F4 00 00    1352*  	dl 0x0000F4 ; 000006, 1.343
0B15F2 1D 01 00    1353*  	dl 0x00011D ; 000007, 1.566
0B15F5 45 01 00    1354*  	dl 0x000145 ; 000008, 1.790
0B15F8 6E 01 00    1355*  	dl 0x00016E ; 000009, 2.013
0B15FB 97 01 00    1356*  	dl 0x000197 ; 00000A, 2.237
0B15FE BF 01 00    1357*  	dl 0x0001BF ; 00000B, 2.460
0B1601 E8 01 00    1358*  	dl 0x0001E8 ; 00000C, 2.684
0B1604 11 02 00    1359*  	dl 0x000211 ; 00000D, 2.907
0B1607 39 02 00    1360*  	dl 0x000239 ; 00000E, 3.130
0B160A 62 02 00    1361*  	dl 0x000262 ; 00000F, 3.353
0B160D 8B 02 00    1362*  	dl 0x00028B ; 000010, 3.576
0B1610 B3 02 00    1363*  	dl 0x0002B3 ; 000011, 3.799
0B1613 DC 02 00    1364*  	dl 0x0002DC ; 000012, 4.022
0B1616 04 03 00    1365*  	dl 0x000304 ; 000013, 4.245
0B1619 2D 03 00    1366*  	dl 0x00032D ; 000014, 4.467
0B161C 55 03 00    1367*  	dl 0x000355 ; 000015, 4.690
0B161F 7E 03 00    1368*  	dl 0x00037E ; 000016, 4.912
0B1622 A6 03 00    1369*  	dl 0x0003A6 ; 000017, 5.134
0B1625 CE 03 00    1370*  	dl 0x0003CE ; 000018, 5.356
0B1628 F7 03 00    1371*  	dl 0x0003F7 ; 000019, 5.578
0B162B 1F 04 00    1372*  	dl 0x00041F ; 00001A, 5.799
0B162E 48 04 00    1373*  	dl 0x000448 ; 00001B, 6.021
0B1631 70 04 00    1374*  	dl 0x000470 ; 00001C, 6.242
0B1634 98 04 00    1375*  	dl 0x000498 ; 00001D, 6.463
0B1637 C0 04 00    1376*  	dl 0x0004C0 ; 00001E, 6.684
0B163A E8 04 00    1377*  	dl 0x0004E8 ; 00001F, 6.905
0B163D 11 05 00    1378*  	dl 0x000511 ; 000020, 7.125
0B1640 39 05 00    1379*  	dl 0x000539 ; 000021, 7.345
0B1643 61 05 00    1380*  	dl 0x000561 ; 000022, 7.565
0B1646 89 05 00    1381*  	dl 0x000589 ; 000023, 7.785
0B1649 B1 05 00    1382*  	dl 0x0005B1 ; 000024, 8.005
0B164C D9 05 00    1383*  	dl 0x0005D9 ; 000025, 8.224
0B164F 01 06 00    1384*  	dl 0x000601 ; 000026, 8.443
0B1652 28 06 00    1385*  	dl 0x000628 ; 000027, 8.662
0B1655 50 06 00    1386*  	dl 0x000650 ; 000028, 8.881
0B1658 78 06 00    1387*  	dl 0x000678 ; 000029, 9.099
0B165B A0 06 00    1388*  	dl 0x0006A0 ; 00002A, 9.317
0B165E C7 06 00    1389*  	dl 0x0006C7 ; 00002B, 9.535
0B1661 EF 06 00    1390*  	dl 0x0006EF ; 00002C, 9.752
0B1664 16 07 00    1391*  	dl 0x000716 ; 00002D, 9.970
0B1667 3E 07 00    1392*  	dl 0x00073E ; 00002E, 10.187
0B166A 65 07 00    1393*  	dl 0x000765 ; 00002F, 10.403
0B166D 8D 07 00    1394*  	dl 0x00078D ; 000030, 10.620
0B1670 B4 07 00    1395*  	dl 0x0007B4 ; 000031, 10.836
0B1673 DB 07 00    1396*  	dl 0x0007DB ; 000032, 11.051
0B1676 03 08 00    1397*  	dl 0x000803 ; 000033, 11.267
0B1679 2A 08 00    1398*  	dl 0x00082A ; 000034, 11.482
0B167C 51 08 00    1399*  	dl 0x000851 ; 000035, 11.697
0B167F 78 08 00    1400*  	dl 0x000878 ; 000036, 11.911
0B1682 9F 08 00    1401*  	dl 0x00089F ; 000037, 12.125
0B1685 C6 08 00    1402*  	dl 0x0008C6 ; 000038, 12.339
0B1688 ED 08 00    1403*  	dl 0x0008ED ; 000039, 12.553
0B168B 13 09 00    1404*  	dl 0x000913 ; 00003A, 12.766
0B168E 3A 09 00    1405*  	dl 0x00093A ; 00003B, 12.978
0B1691 61 09 00    1406*  	dl 0x000961 ; 00003C, 13.191
0B1694 87 09 00    1407*  	dl 0x000987 ; 00003D, 13.403
0B1697 AE 09 00    1408*  	dl 0x0009AE ; 00003E, 13.614
0B169A D4 09 00    1409*  	dl 0x0009D4 ; 00003F, 13.825
0B169D FB 09 00    1410*  	dl 0x0009FB ; 000040, 14.036
0B16A0 21 0A 00    1411*  	dl 0x000A21 ; 000041, 14.247
0B16A3 47 0A 00    1412*  	dl 0x000A47 ; 000042, 14.457
0B16A6 6D 0A 00    1413*  	dl 0x000A6D ; 000043, 14.666
0B16A9 94 0A 00    1414*  	dl 0x000A94 ; 000044, 14.876
0B16AC BA 0A 00    1415*  	dl 0x000ABA ; 000045, 15.085
0B16AF E0 0A 00    1416*  	dl 0x000AE0 ; 000046, 15.293
0B16B2 05 0B 00    1417*  	dl 0x000B05 ; 000047, 15.501
0B16B5 2B 0B 00    1418*  	dl 0x000B2B ; 000048, 15.709
0B16B8 51 0B 00    1419*  	dl 0x000B51 ; 000049, 15.916
0B16BB 77 0B 00    1420*  	dl 0x000B77 ; 00004A, 16.123
0B16BE 9C 0B 00    1421*  	dl 0x000B9C ; 00004B, 16.329
0B16C1 C2 0B 00    1422*  	dl 0x000BC2 ; 00004C, 16.535
0B16C4 E7 0B 00    1423*  	dl 0x000BE7 ; 00004D, 16.740
0B16C7 0C 0C 00    1424*  	dl 0x000C0C ; 00004E, 16.945
0B16CA 32 0C 00    1425*  	dl 0x000C32 ; 00004F, 17.150
0B16CD 57 0C 00    1426*  	dl 0x000C57 ; 000050, 17.354
0B16D0 7C 0C 00    1427*  	dl 0x000C7C ; 000051, 17.558
0B16D3 A1 0C 00    1428*  	dl 0x000CA1 ; 000052, 17.761
0B16D6 C6 0C 00    1429*  	dl 0x000CC6 ; 000053, 17.964
0B16D9 EB 0C 00    1430*  	dl 0x000CEB ; 000054, 18.166
0B16DC 0F 0D 00    1431*  	dl 0x000D0F ; 000055, 18.368
0B16DF 34 0D 00    1432*  	dl 0x000D34 ; 000056, 18.569
0B16E2 58 0D 00    1433*  	dl 0x000D58 ; 000057, 18.770
0B16E5 7D 0D 00    1434*  	dl 0x000D7D ; 000058, 18.970
0B16E8 A1 0D 00    1435*  	dl 0x000DA1 ; 000059, 19.170
0B16EB C6 0D 00    1436*  	dl 0x000DC6 ; 00005A, 19.370
0B16EE EA 0D 00    1437*  	dl 0x000DEA ; 00005B, 19.569
0B16F1 0E 0E 00    1438*  	dl 0x000E0E ; 00005C, 19.767
0B16F4 32 0E 00    1439*  	dl 0x000E32 ; 00005D, 19.965
0B16F7 56 0E 00    1440*  	dl 0x000E56 ; 00005E, 20.163
0B16FA 7A 0E 00    1441*  	dl 0x000E7A ; 00005F, 20.360
0B16FD 9E 0E 00    1442*  	dl 0x000E9E ; 000060, 20.556
0B1700 C1 0E 00    1443*  	dl 0x000EC1 ; 000061, 20.752
0B1703 E5 0E 00    1444*  	dl 0x000EE5 ; 000062, 20.947
0B1706 08 0F 00    1445*  	dl 0x000F08 ; 000063, 21.142
0B1709 2C 0F 00    1446*  	dl 0x000F2C ; 000064, 21.337
0B170C 4F 0F 00    1447*  	dl 0x000F4F ; 000065, 21.531
0B170F 72 0F 00    1448*  	dl 0x000F72 ; 000066, 21.724
0B1712 95 0F 00    1449*  	dl 0x000F95 ; 000067, 21.917
0B1715 B8 0F 00    1450*  	dl 0x000FB8 ; 000068, 22.109
0B1718 DB 0F 00    1451*  	dl 0x000FDB ; 000069, 22.301
0B171B FE 0F 00    1452*  	dl 0x000FFE ; 00006A, 22.493
0B171E 21 10 00    1453*  	dl 0x001021 ; 00006B, 22.683
0B1721 44 10 00    1454*  	dl 0x001044 ; 00006C, 22.874
0B1724 66 10 00    1455*  	dl 0x001066 ; 00006D, 23.063
0B1727 89 10 00    1456*  	dl 0x001089 ; 00006E, 23.253
0B172A AB 10 00    1457*  	dl 0x0010AB ; 00006F, 23.441
0B172D CD 10 00    1458*  	dl 0x0010CD ; 000070, 23.629
0B1730 EF 10 00    1459*  	dl 0x0010EF ; 000071, 23.817
0B1733 11 11 00    1460*  	dl 0x001111 ; 000072, 24.004
0B1736 33 11 00    1461*  	dl 0x001133 ; 000073, 24.191
0B1739 55 11 00    1462*  	dl 0x001155 ; 000074, 24.376
0B173C 77 11 00    1463*  	dl 0x001177 ; 000075, 24.562
0B173F 99 11 00    1464*  	dl 0x001199 ; 000076, 24.747
0B1742 BA 11 00    1465*  	dl 0x0011BA ; 000077, 24.931
0B1745 DC 11 00    1466*  	dl 0x0011DC ; 000078, 25.115
0B1748 FD 11 00    1467*  	dl 0x0011FD ; 000079, 25.298
0B174B 1E 12 00    1468*  	dl 0x00121E ; 00007A, 25.481
0B174E 3F 12 00    1469*  	dl 0x00123F ; 00007B, 25.663
0B1751 60 12 00    1470*  	dl 0x001260 ; 00007C, 25.844
0B1754 81 12 00    1471*  	dl 0x001281 ; 00007D, 26.025
0B1757 A2 12 00    1472*  	dl 0x0012A2 ; 00007E, 26.206
0B175A C3 12 00    1473*  	dl 0x0012C3 ; 00007F, 26.386
0B175D E4 12 00    1474*  	dl 0x0012E4 ; 000080, 26.565
0B1760 04 13 00    1475*  	dl 0x001304 ; 000081, 26.744
0B1763 25 13 00    1476*  	dl 0x001325 ; 000082, 26.922
0B1766 45 13 00    1477*  	dl 0x001345 ; 000083, 27.100
0B1769 65 13 00    1478*  	dl 0x001365 ; 000084, 27.277
0B176C 85 13 00    1479*  	dl 0x001385 ; 000085, 27.453
0B176F A5 13 00    1480*  	dl 0x0013A5 ; 000086, 27.629
0B1772 C5 13 00    1481*  	dl 0x0013C5 ; 000087, 27.805
0B1775 E5 13 00    1482*  	dl 0x0013E5 ; 000088, 27.979
0B1778 05 14 00    1483*  	dl 0x001405 ; 000089, 28.154
0B177B 24 14 00    1484*  	dl 0x001424 ; 00008A, 28.327
0B177E 44 14 00    1485*  	dl 0x001444 ; 00008B, 28.501
0B1781 63 14 00    1486*  	dl 0x001463 ; 00008C, 28.673
0B1784 83 14 00    1487*  	dl 0x001483 ; 00008D, 28.845
0B1787 A2 14 00    1488*  	dl 0x0014A2 ; 00008E, 29.017
0B178A C1 14 00    1489*  	dl 0x0014C1 ; 00008F, 29.187
0B178D E0 14 00    1490*  	dl 0x0014E0 ; 000090, 29.358
0B1790 FF 14 00    1491*  	dl 0x0014FF ; 000091, 29.527
0B1793 1E 15 00    1492*  	dl 0x00151E ; 000092, 29.697
0B1796 3C 15 00    1493*  	dl 0x00153C ; 000093, 29.865
0B1799 5B 15 00    1494*  	dl 0x00155B ; 000094, 30.033
0B179C 79 15 00    1495*  	dl 0x001579 ; 000095, 30.201
0B179F 98 15 00    1496*  	dl 0x001598 ; 000096, 30.368
0B17A2 B6 15 00    1497*  	dl 0x0015B6 ; 000097, 30.534
0B17A5 D4 15 00    1498*  	dl 0x0015D4 ; 000098, 30.700
0B17A8 F2 15 00    1499*  	dl 0x0015F2 ; 000099, 30.865
0B17AB 10 16 00    1500*  	dl 0x001610 ; 00009A, 31.030
0B17AE 2E 16 00    1501*  	dl 0x00162E ; 00009B, 31.194
0B17B1 4C 16 00    1502*  	dl 0x00164C ; 00009C, 31.357
0B17B4 6A 16 00    1503*  	dl 0x00166A ; 00009D, 31.520
0B17B7 87 16 00    1504*  	dl 0x001687 ; 00009E, 31.682
0B17BA A5 16 00    1505*  	dl 0x0016A5 ; 00009F, 31.844
0B17BD C2 16 00    1506*  	dl 0x0016C2 ; 0000A0, 32.005
0B17C0 DF 16 00    1507*  	dl 0x0016DF ; 0000A1, 32.166
0B17C3 FC 16 00    1508*  	dl 0x0016FC ; 0000A2, 32.326
0B17C6 19 17 00    1509*  	dl 0x001719 ; 0000A3, 32.486
0B17C9 36 17 00    1510*  	dl 0x001736 ; 0000A4, 32.645
0B17CC 53 17 00    1511*  	dl 0x001753 ; 0000A5, 32.803
0B17CF 70 17 00    1512*  	dl 0x001770 ; 0000A6, 32.961
0B17D2 8C 17 00    1513*  	dl 0x00178C ; 0000A7, 33.118
0B17D5 A9 17 00    1514*  	dl 0x0017A9 ; 0000A8, 33.275
0B17D8 C5 17 00    1515*  	dl 0x0017C5 ; 0000A9, 33.431
0B17DB E2 17 00    1516*  	dl 0x0017E2 ; 0000AA, 33.587
0B17DE FE 17 00    1517*  	dl 0x0017FE ; 0000AB, 33.742
0B17E1 1A 18 00    1518*  	dl 0x00181A ; 0000AC, 33.896
0B17E4 36 18 00    1519*  	dl 0x001836 ; 0000AD, 34.050
0B17E7 52 18 00    1520*  	dl 0x001852 ; 0000AE, 34.203
0B17EA 6E 18 00    1521*  	dl 0x00186E ; 0000AF, 34.356
0B17ED 8A 18 00    1522*  	dl 0x00188A ; 0000B0, 34.509
0B17F0 A5 18 00    1523*  	dl 0x0018A5 ; 0000B1, 34.660
0B17F3 C1 18 00    1524*  	dl 0x0018C1 ; 0000B2, 34.811
0B17F6 DC 18 00    1525*  	dl 0x0018DC ; 0000B3, 34.962
0B17F9 F7 18 00    1526*  	dl 0x0018F7 ; 0000B4, 35.112
0B17FC 13 19 00    1527*  	dl 0x001913 ; 0000B5, 35.262
0B17FF 2E 19 00    1528*  	dl 0x00192E ; 0000B6, 35.410
0B1802 49 19 00    1529*  	dl 0x001949 ; 0000B7, 35.559
0B1805 64 19 00    1530*  	dl 0x001964 ; 0000B8, 35.707
0B1808 7F 19 00    1531*  	dl 0x00197F ; 0000B9, 35.854
0B180B 99 19 00    1532*  	dl 0x001999 ; 0000BA, 36.001
0B180E B4 19 00    1533*  	dl 0x0019B4 ; 0000BB, 36.147
0B1811 CE 19 00    1534*  	dl 0x0019CE ; 0000BC, 36.293
0B1814 E9 19 00    1535*  	dl 0x0019E9 ; 0000BD, 36.438
0B1817 03 1A 00    1536*  	dl 0x001A03 ; 0000BE, 36.582
0B181A 1D 1A 00    1537*  	dl 0x001A1D ; 0000BF, 36.726
0B181D 37 1A 00    1538*  	dl 0x001A37 ; 0000C0, 36.870
0B1820 51 1A 00    1539*  	dl 0x001A51 ; 0000C1, 37.013
0B1823 6B 1A 00    1540*  	dl 0x001A6B ; 0000C2, 37.155
0B1826 85 1A 00    1541*  	dl 0x001A85 ; 0000C3, 37.297
0B1829 9F 1A 00    1542*  	dl 0x001A9F ; 0000C4, 37.439
0B182C B9 1A 00    1543*  	dl 0x001AB9 ; 0000C5, 37.579
0B182F D2 1A 00    1544*  	dl 0x001AD2 ; 0000C6, 37.720
0B1832 EC 1A 00    1545*  	dl 0x001AEC ; 0000C7, 37.859
0B1835 05 1B 00    1546*  	dl 0x001B05 ; 0000C8, 37.999
0B1838 1E 1B 00    1547*  	dl 0x001B1E ; 0000C9, 38.137
0B183B 37 1B 00    1548*  	dl 0x001B37 ; 0000CA, 38.276
0B183E 50 1B 00    1549*  	dl 0x001B50 ; 0000CB, 38.413
0B1841 69 1B 00    1550*  	dl 0x001B69 ; 0000CC, 38.550
0B1844 82 1B 00    1551*  	dl 0x001B82 ; 0000CD, 38.687
0B1847 9B 1B 00    1552*  	dl 0x001B9B ; 0000CE, 38.823
0B184A B4 1B 00    1553*  	dl 0x001BB4 ; 0000CF, 38.959
0B184D CC 1B 00    1554*  	dl 0x001BCC ; 0000D0, 39.094
0B1850 E5 1B 00    1555*  	dl 0x001BE5 ; 0000D1, 39.228
0B1853 FD 1B 00    1556*  	dl 0x001BFD ; 0000D2, 39.362
0B1856 16 1C 00    1557*  	dl 0x001C16 ; 0000D3, 39.496
0B1859 2E 1C 00    1558*  	dl 0x001C2E ; 0000D4, 39.629
0B185C 46 1C 00    1559*  	dl 0x001C46 ; 0000D5, 39.762
0B185F 5E 1C 00    1560*  	dl 0x001C5E ; 0000D6, 39.894
0B1862 76 1C 00    1561*  	dl 0x001C76 ; 0000D7, 40.025
0B1865 8E 1C 00    1562*  	dl 0x001C8E ; 0000D8, 40.156
0B1868 A5 1C 00    1563*  	dl 0x001CA5 ; 0000D9, 40.286
0B186B BD 1C 00    1564*  	dl 0x001CBD ; 0000DA, 40.416
0B186E D5 1C 00    1565*  	dl 0x001CD5 ; 0000DB, 40.546
0B1871 EC 1C 00    1566*  	dl 0x001CEC ; 0000DC, 40.675
0B1874 04 1D 00    1567*  	dl 0x001D04 ; 0000DD, 40.803
0B1877 1B 1D 00    1568*  	dl 0x001D1B ; 0000DE, 40.931
0B187A 32 1D 00    1569*  	dl 0x001D32 ; 0000DF, 41.059
0B187D 49 1D 00    1570*  	dl 0x001D49 ; 0000E0, 41.186
0B1880 60 1D 00    1571*  	dl 0x001D60 ; 0000E1, 41.312
0B1883 77 1D 00    1572*  	dl 0x001D77 ; 0000E2, 41.438
0B1886 8E 1D 00    1573*  	dl 0x001D8E ; 0000E3, 41.564
0B1889 A5 1D 00    1574*  	dl 0x001DA5 ; 0000E4, 41.689
0B188C BB 1D 00    1575*  	dl 0x001DBB ; 0000E5, 41.814
0B188F D2 1D 00    1576*  	dl 0x001DD2 ; 0000E6, 41.938
0B1892 E9 1D 00    1577*  	dl 0x001DE9 ; 0000E7, 42.061
0B1895 FF 1D 00    1578*  	dl 0x001DFF ; 0000E8, 42.184
0B1898 15 1E 00    1579*  	dl 0x001E15 ; 0000E9, 42.307
0B189B 2C 1E 00    1580*  	dl 0x001E2C ; 0000EA, 42.429
0B189E 42 1E 00    1581*  	dl 0x001E42 ; 0000EB, 42.551
0B18A1 58 1E 00    1582*  	dl 0x001E58 ; 0000EC, 42.672
0B18A4 6E 1E 00    1583*  	dl 0x001E6E ; 0000ED, 42.793
0B18A7 84 1E 00    1584*  	dl 0x001E84 ; 0000EE, 42.913
0B18AA 99 1E 00    1585*  	dl 0x001E99 ; 0000EF, 43.033
0B18AD AF 1E 00    1586*  	dl 0x001EAF ; 0000F0, 43.152
0B18B0 C5 1E 00    1587*  	dl 0x001EC5 ; 0000F1, 43.271
0B18B3 DA 1E 00    1588*  	dl 0x001EDA ; 0000F2, 43.390
0B18B6 F0 1E 00    1589*  	dl 0x001EF0 ; 0000F3, 43.508
0B18B9 05 1F 00    1590*  	dl 0x001F05 ; 0000F4, 43.625
0B18BC 1B 1F 00    1591*  	dl 0x001F1B ; 0000F5, 43.742
0B18BF 30 1F 00    1592*  	dl 0x001F30 ; 0000F6, 43.859
0B18C2 45 1F 00    1593*  	dl 0x001F45 ; 0000F7, 43.975
0B18C5 5A 1F 00    1594*  	dl 0x001F5A ; 0000F8, 44.091
0B18C8 6F 1F 00    1595*  	dl 0x001F6F ; 0000F9, 44.206
0B18CB 84 1F 00    1596*  	dl 0x001F84 ; 0000FA, 44.321
0B18CE 99 1F 00    1597*  	dl 0x001F99 ; 0000FB, 44.435
0B18D1 AD 1F 00    1598*  	dl 0x001FAD ; 0000FC, 44.549
0B18D4 C2 1F 00    1599*  	dl 0x001FC2 ; 0000FD, 44.662
0B18D7 D7 1F 00    1600*  	dl 0x001FD7 ; 0000FE, 44.775
0B18DA EB 1F 00    1601*  	dl 0x001FEB ; 0000FF, 44.888
0B18DD 00 20 00    1602*  	dl 0x002000 ; 000100, 45.000 only needed for interpolation
0B18E0             1603*  
0B18E0             1604*  ; ---------------------------------------------------------
0B18E0             1605*  ; BEGIN HELPER ROUTINES
0B18E0             1606*  ; ---------------------------------------------------------
0B18E0             1607*  ;
0B18E0             1608*  ; absolute value of hlu
0B18E0             1609*  ; returns: abs(hlu), flags set according to the incoming sign of hlu:
0B18E0             1610*  ;         s1,z0,pv0,n1,c0 if hlu was negative
0B18E0             1611*  ;         s0,z1,pv0,n1,c0 if hlu was zero
0B18E0             1612*  ;         s0,z0,pv0,n1,c0 if hlu was positive
0B18E0             1613*  ; destroys: a
0B18E0             1614*  abs_hlu:
0B18E0 19          1615*      add hl,de
0B18E1 B7          1616*      or a
0B18E2 ED 52       1617*      sbc hl,de
0B18E4 FA E9 18 0B 1618*      jp m,@is_neg
0B18E8 C9          1619*      ret         ; hlu is positive or zero so we're done
0B18E9             1620*  @is_neg:
0B18E9 F5          1621*      push af     ; otherwise, save current flags for return
0B18EA CD F0 18 0B 1622*      call neg_hlu ; negate hlu
0B18EE F1          1623*      pop af      ; get back flags
0B18EF C9          1624*      ret
0B18F0             1625*  
0B18F0             1626*  ; flip the sign of hlu
0B18F0             1627*  ; inputs: hlu
0B18F0             1628*  ; returns: 0-hlu, flags set appropriately for the result:
0B18F0             1629*  ;         s1,z0,pv0,n1,c1 if result is negative
0B18F0             1630*  ;         s0,z1,pv0,n1,c0 if result is zero
0B18F0             1631*  ;         s0,z0,pv0,n1,c1 if result is positive
0B18F0             1632*  ; destroys a
0B18F0             1633*  neg_hlu:
0B18F0 D5          1634*      push de     ; save de
0B18F1 EB          1635*      ex de,hl    ; put hl into de
0B18F2 21 00 00 00 1636*      ld hl,0     ; clear hl
0B18F6 AF          1637*      xor a       ; clear carry
0B18F7 ED 52       1638*      sbc hl,de   ; 0-hlu = -hlu
0B18F9 D1          1639*      pop de      ; get de back
0B18FA C9          1640*      ret         ; easy peasy
0B18FB             1641*  
0B18FB             1642*  ;------------------------------------------------------------------------
0B18FB             1643*  ; divide hlu by 2, inspired by above
0B18FB             1644*  ;------------------------------------------------------------------------
0B18FB             1645*  hlu_div2:
0B18FB 22 26 10 0B 1646*  	ld		(bitbuf1),hl
0B18FF 21 28 10 0B 1647*  	ld		hl,bitbuf1+2
0B1903 CB 1E       1648*  	rr		(hl)
0B1905 2B          1649*  	dec		hl
0B1906 CB 1E       1650*  	rr		(hl)
0B1908 2B          1651*  	dec		hl
0B1909 CB 1E       1652*  	rr		(hl)
0B190B 23          1653*  	inc		hl
0B190C 23          1654*  	inc		hl
0B190D 2A 26 10 0B 1655*      ld hl,(bitbuf1)
0B1911 C9          1656*      ret
0B1912             1657*  
0B1912             1658*  ; this is my little hack to divide by 16
0B1912             1659*  hlu_div16:
0B1912 AF          1660*      xor a
0B1913 29          1661*      add hl,hl
0B1914 17          1662*      rla
0B1915 29          1663*      add hl,hl
0B1916 17          1664*      rla
0B1917 29          1665*      add hl,hl
0B1918 17          1666*      rla
0B1919 29          1667*      add hl,hl
0B191A 17          1668*      rla
0B191B 22 28 19 0B 1669*      ld (@scratch),hl
0B191F 32 2B 19 0B 1670*      ld (@scratch+3),a
0B1923 2A 29 19 0B 1671*      ld hl,(@scratch+1)
0B1927 C9          1672*      ret
0B1928             1673*  @scratch: ds 4
0B192C             0029   
0B192C             0030   ; APPLICATION INCLUDES
0B192C 55 73 61 67 0031   str_usage: ASCIZ "Usage: scratch <args>\r\n"
       65 3A 20 73 
       63 72 61 74 
       63 68 20 3C 
       61 72 67 73 
       3E 0D 0A 00 
0B1944 45 72 72 6F 0032   str_error: ASCIZ "Error!\r\n"
       72 21 0D 0A 
       00          
0B194D 53 75 63 63 0033   str_success: ASCIZ "Success!\r\n"
       65 73 73 21 
       0D 0A 00    
0B1958             0034   
0B1958             0035   ; This is a scratch moslet for testing new features
0B1958             0036   ; Parameters:
0B1958             0037   ;
0B1958             0038   
0B1958             0039   ; ========= BOILERPLATE MAIN LOOP =========
0B1958             0040   ; The main routine
0B1958             0041   ; IXU: argv - pointer to array of parameters
0B1958             0042   ;   C: argc - number of parameters
0B1958             0043   ; Returns:
0B1958             0044   ;  HL: Error code, or 0 if OK
0B1958             0045   
0B1958             0046   min_args: equ 2
0B1958             0047   
0B1958             0048   _main:
0B1958 79          0049       ld a,c              ; how many arguments?
0B1959 FE 02       0050       cp min_args         ; not enough?
0B195B 30 1A       0051       jr nc,main          ; if enough, go to main loop
0B195D 21 2C 19 0B 0052       ld hl,str_usage     ; if not enough, print usage
0B1961 CD 67 02 0B 0053       call printString
0B1965             0054                           ; fall through to _main_end_error
0B1965             0055   
0B1965             0056   _main_end_error:
0B1965 21 44 19 0B 0057       ld hl,str_error     ; print error message
0B1969 CD 67 02 0B 0058       call printString
0B196D 21 13 00 00 0059       ld hl,19            ; return error code 19
0B1971 C9          0060       ret
0B1972             0061   
0B1972             0062   _main_end_ok:
0B1972             0063       ; ld hl,str_success   ; print success message
0B1972             0064       ; call printString
0B1972 21 00 00 00 0065       ld hl,0             ; return 0 for success
0B1976 C9          0066       ret
0B1977             0067   
0B1977             0068   ; ========= BEGIN CUSTOM MAIN LOOP =========
0B1977             0069   main:
0B1977 0D          0070       dec c               ; decrement the argument count to skip the program name
0B1978             0071   
0B1978             0072   test_umul824:
0B1978             0073   ; 24-bit argument to BHL
0B1978 CD 13 1A 0B 0074       call get_arg_s24
0B197C EB          0075       ex de,hl
0B197D             0076       HLU_TO_A
0B197D E5          0001M          push hl
0B197E 33          0002M          inc sp
0B197F F1          0003M          pop af
0B1980 3B          0004M          dec sp
0B1981 47          0077       ld b,a ; b = high 8-bits
0B1982 E5          0078       push hl ; store low 16-bits, b will be fine
0B1983             0079   
0B1983             0080   ; 8-bit argument to A TODO: write an 8-bit argument parser for performance
0B1983 CD 13 1A 0B 0081       call get_arg_s24
0B1987 7B          0082       ld a,e ; 8-bit argument
0B1988 E1          0083       pop hl ; bhl is the 24-bit argument
0B1989             0084   
0B1989             0085   ; do the multiplication
0B1989 CD 55 0E 0B 0086       call umul824
0B198D CD C7 02 0B 0087       call printHexABHL
0B1991 CD 7C 02 0B 0088       call printNewLine
0B1995 C3 72 19 0B 0089       jp _main_end_ok
0B1999             0090   
0B1999             0091   test_scratch:
0B1999 CD 13 1A 0B 0092       call get_arg_s24
0B199D EB          0093       ex de,hl
0B199E             0094       HLU_TO_A
0B199E E5          0001M          push hl
0B199F 33          0002M          inc sp
0B19A0 F1          0003M          pop af
0B19A1 3B          0004M          dec sp
0B19A2 CD 2B 05 0B 0095       call dumpRegistersHex
0B19A6 CD 7C 02 0B 0096       call printNewLine
0B19AA C3 72 19 0B 0097       jp _main_end_ok
0B19AE             0098   
0B19AE             0099   test_udiv24:
0B19AE             0100   ; get dividend
0B19AE CD 13 1A 0B 0101       call get_arg_s24
0B19B2 D5          0102       push de
0B19B3             0103   ; get divisor
0B19B3 CD 13 1A 0B 0104       call get_arg_s24
0B19B7 E1          0105       pop hl ; dividend (was de)
0B19B8 CD 2B 05 0B 0106       call dumpRegistersHex
0B19BC             0107   ; do the division
0B19BC CD D5 0E 0B 0108       call udiv24 ; ude = uhl / ude rem uhl
0B19C0 EB          0109       ex de,hl    ; uhl = uhl / ude rem de
0B19C1 CD 2B 05 0B 0110       call dumpRegistersHex
0B19C5 CD 7E 03 0B 0111       call print_u24
0B19C9 CD 7C 02 0B 0112       call printNewLine
0B19CD C3 72 19 0B 0113       jp _main_end_ok
0B19D1             0114   
0B19D1             0115   ; inputs: b.c is 8.8 dividend, ud.e is 16.8 divisor
0B19D1             0116   ; outputs: uh.l is the 16.8 quotient ub.c is the 16.8 remainder
0B19D1             0117   ; destroys: a,bc
0B19D1             0118   test_sdiv168:
0B19D1             0119   ; get dividend
0B19D1 CD 08 1A 0B 0120       call get_arg_s168
0B19D5 D5          0121       push de
0B19D6             0122   ; get divisor
0B19D6 CD 08 1A 0B 0123       call get_arg_s168
0B19DA C1          0124       pop bc ; dividend to bc (was de)
0B19DB             0125   ; do the division
0B19DB CD 52 0F 0B 0126       call sdiv168 ; uh.l = ub.c / ud.e
0B19DF CD 2B 05 0B 0127       call dumpRegistersHex
0B19E3 CD 01 04 0B 0128       call print_s168
0B19E7 CD 7C 02 0B 0129       call printNewLine
0B19EB C3 72 19 0B 0130       jp _main_end_ok
0B19EF             0131   
0B19EF             0132   test_deg_360_to_255:
0B19EF CD 08 1A 0B 0133       call get_arg_s168 ; argument value to de
0B19F3 EB          0134       ex de,hl             ; argument to hl for function call
0B19F4 CD 58 10 0B 0135       call deg_360_to_255
0B19F8 CD 2B 05 0B 0136       call dumpRegistersHex
0B19FC CD 01 04 0B 0137       call print_s168
0B1A00 CD 7C 02 0B 0138       call printNewLine
0B1A04 C3 72 19 0B 0139       jp _main_end_ok
0B1A08             0140   
0B1A08             0141   ; ========== HELPER FUNCTIONS ==========
0B1A08             0142   ; get the next argument after ix as a signed 16.8 fixed point number
0B1A08             0143   ; inputs: ix = pointer to the argument string
0B1A08             0144   ; outputs: ude = signed 16.8 fixed point number
0B1A08             0145   ; destroys: a, d, e, h, l, f
0B1A08             0146   get_arg_s168:
0B1A08 ED 32 03    0147       lea ix,ix+3 ; point to the next argument
0B1A0B DD 27 00    0148       ld hl,(ix)  ; get the argument string
0B1A0E CD 98 01 0B 0149       call asc_to_s168 ; convert the string to a number
0B1A12 C9          0150       ret ; return with the value in DE
0B1A13             0151   
0B1A13             0152   ; Inputs: ix = pointer to the argument string
0B1A13             0153   ; Outputs: ude = signed 24-bit integer
0B1A13             0154   ; Destroys: a, d, e, h, l, f
0B1A13             0155   get_arg_s24:
0B1A13 ED 32 03    0156       lea ix,ix+3 ; point to the next argument
0B1A16 DD 27 00    0157       ld hl,(ix)  ; get the argument string
0B1A19 CD 45 01 0B 0158       call asc_to_s24 ; convert the string to a number
0B1A1D C9          0159       ret ; return with the value in DE
0B1A1E             0160   
0B1A1E             0161   get_plot_coords:
0B1A1E             0162   ; get the move coordinates
0B1A1E ED 32 03    0163       lea ix,ix+3 ; pointer to next argument address
0B1A21 DD 27 00    0164       ld hl,(ix)  ; pointer to the x coordinate string
0B1A24 CD 98 01 0B 0165       call asc_to_s168 ; de = x coordinate
0B1A28 D5          0166       push de
0B1A29 C1          0167       pop bc ; bc = x coordinate
0B1A2A ED 32 03    0168       lea ix,ix+3 ; pointer to next argument address
0B1A2D DD 27 00    0169       ld hl,(ix)  ; pointer to the y coordinate string
0B1A30 CD 98 01 0B 0170       call asc_to_s168 ; de = y coordinate
0B1A34 C9          0171       ret
0B1A35             0172   
0B1A35             0173   ; match the next argument after ix to the dispatch table at iy
0B1A35             0174   ;   - arguments and dispatch entries are zero-terminated, case-sensitive strings
0B1A35             0175   ;   - final entry of dispatch table must be a 3-byte zero or bad things will happen
0B1A35             0176   ; returns: NO MATCH: iy=dispatch list terminator a=1 and zero flag reset
0B1A35             0177   ;          ON MATCH: iy=dispatch address, a=0 and zero flag se
0B1A35             0178   ; destroys: a, hl, de, ix, iy, flags
0B1A35             0179   match_next:
0B1A35 ED 32 03    0180       lea ix,ix+3         ; point to the next argument
0B1A38             0181   @loop:
0B1A38 FD 27 00    0182       ld hl,(iy)          ; pointer argument dispatch record
0B1A3B             0183       signHL              ; check for list terminator
0B1A3B 19          0001M          add hl,de
0B1A3C B7          0002M          or a
0B1A3D ED 52       0003M          sbc hl,de
0B1A3F CA 57 1A 0B 0184       jp z,@no_match      ; if a=0, return error
0B1A43 23          0185       inc hl              ; skip over jp instruction
0B1A44 23          0186       inc hl
0B1A45 DD 17 00    0187       ld de,(ix)          ; pointer to the argument string
0B1A48 CD 5D 1A 0B 0188       call str_equal      ; compare the argument to the dispatch table entry
0B1A4C CA 59 1A 0B 0189       jp z,@match         ; if equal, return success
0B1A50 ED 33 03    0190       lea iy,iy+3         ; if not equal, bump iy to next dispatch table entry
0B1A53 C3 38 1A 0B 0191       jp @loop            ; and loop
0B1A57             0192   @no_match:
0B1A57 3C          0193       inc a               ; no match so return a=1 and zero flag reset
0B1A58 C9          0194       ret
0B1A59             0195   @match:
0B1A59 FD 37 00    0196       ld iy,(iy)          ; get the function pointer
0B1A5C C9          0197       ret                 ; return a=0 and zero flag set
0B1A5D             0198   
0B1A5D             0199   ; compare two zero-terminated strings for equality, case-sensitive
0B1A5D             0200   ; hl: pointer to first string, de: pointer to second string
0B1A5D             0201   ; returns: z if equal, nz if not equal
0B1A5D             0202   ; destroys: a, hl, de
0B1A5D             0203   str_equal:
0B1A5D 1A          0204       ld a,(de)           ; get the first character
0B1A5E BE          0205       cp (hl)             ; compare to the second character
0B1A5F C0          0206       ret nz              ; if not equal, return
0B1A60 B7          0207       or a
0B1A61 C8          0208       ret z               ; if equal and zero, return
0B1A62 23          0209       inc hl              ; next character
0B1A63 13          0210       inc de
0B1A64 C3 5D 1A 0B 0211       jp str_equal        ; loop until end of string
0B1A68             0212   
0B1A68             0213   ; print the parameter string pointed to by ix
0B1A68             0214   ; destroys: a, hl
0B1A68             0215   print_param:
0B1A68 DD 27 00    0216       ld hl,(ix)          ; get the parameter pointer
0B1A6B CD 67 02 0B 0217       call printString    ; print the parameter string
0B1A6F 3E 20       0218       ld a,' '            ; print a space separator
0B1A71 5B D7       0219       rst.lil $10
0B1A73 C9          0220       ret
0B1A74             0221   
0B1A74             0222   ; print the parameters
0B1A74             0223   ; inputs: b = number of parameters, ix = pointer to the parameters
0B1A74             0224   ; destroys: a, hl, bc
0B1A74             0225   print_params:
0B1A74 41          0226       ld b,c              ; loop counter = number of parameters
0B1A75 DD E5       0227       push ix             ; save the pointer to the parameters
0B1A77             0228   @loop:
0B1A77 C5          0229       push bc             ; save the loop counter
0B1A78 CD 68 1A 0B 0230       call print_param    ; print the parameter
0B1A7C ED 32 03    0231       lea ix,ix+3         ; next parameter pointer
0B1A7F C1          0232       pop bc              ; get back the loop counter
0B1A80 10 F5       0233       djnz @loop          ; loop until done
0B1A82 DD E1       0234       pop ix              ; restore the pointer to the parameters
0B1A84 C9          0235       ret
0B1A85             0236   
0B1A85             0237   debug_print:
0B1A85 CD 7C 02 0B 0238       call printNewLine   ; DEBUG
0B1A89 CD 5E 06 0B 0239       call dumpFlags      ; DEBUG
0B1A8D CD 68 1A 0B 0240       call print_param    ; DEBUG
0B1A91 CD 7C 02 0B 0241       call printNewLine   ; DEBUG
0B1A95 CD 7C 02 0B 0242       call printNewLine   ; DEBUG
0B1A99 C9          0243       ret
